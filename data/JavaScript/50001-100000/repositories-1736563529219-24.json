{
  "metadata": {
    "timestamp": 1736563529219,
    "page": 24,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjI4",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "scutan90/DeepLearning-500-questions",
      "stars": 55176,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".DS_Store",
          "type": "blob",
          "size": 10.00390625,
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.046875,
          "content": ".ipynb_checkpoints\n.DS_Store\n.gitignore\n*.ipynb\n"
        },
        {
          "name": ".nojekyll",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "English version",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.3251953125,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.421875,
          "content": "\n# 京东售卖链接：https://item.jd.com/12785031.html\n# 京东商城100多家书店有现货。\n\n## 深度学习500问——AI工程师面试宝典(博文视点出品)，谈继勇 主编，郭子钊，李剑，佃松宜 副主编 著\n\n# 内容简介\n\n本书系统地描述了深度学习的基本理论算法及应用。全书共14章，第1-3章论述了数学基础、机器学习基础和深度学习基础；第4-7章介绍了一些经典网络及计算机视觉领域中常用的CNN、RNN、GAN等网络结构技术；第8-9章介绍了深度学习在计算机视觉领域的目标检测及图像分割两大应用；第10-14章介绍了计算机视觉领域主要的优化方法及思路等，包括迁移学习、网络架构及训练、网络优化技巧、超参数调整及模型的压缩和加速等。本书凝聚了众多一线科研人员及工程师的经验，旨在培养读者发现问题、解决问题、扩展问题的能力。\n\n本书内容取材于编者在日常学习过程中总结的知识点及各大公司常见的笔试、面试题。本书可为高等院校计算机科学、信息科学、人工智能、控制科学与工程、电子科学与技术等领域的研究及教学人员提供参考，也可为相关专业本科生及研究生提供思考方向，还可为深度学习及计算机视觉领域的初、中级研究人员和工程技术人员提供参考，尤其适合需要查漏补缺的应聘者及提供相关岗位的面试官阅读。\n\n# 作者简介\n谈继勇 主编\n\n南方科技大学和哈尔滨工业大学联合培养博士（在读），现任瀚维智能医疗技术总监，深圳工信局专家库专家，兼任南方科技大学、四川大学研究生企业导师，南方科技大学和瀚维智能医疗联合实验室副主任，北京探工所特聘技术专家，曾先后在中科院信工所、香港中文大学（深圳）、FOXCONN机器人与人工智能实验室、顺丰科技等单位任职。主要专注于智能感知与控制、实时智能与计算机视觉方向的研究，主持/主研国家自然科学基金、省重点研发计划、深圳战略性新兴产业计划等项目20余项，发表SCI/EI论文20余篇，申请发明专利40余项，获全国发明金奖。\n\n郭子钊 副主编\n\n四川大学计算机科学专业博士，硕士毕业于四川大学自动化系，主要从事AI芯片、深度学习、行为检测识别、人脸检测识别等相关研究工作。\n\n李剑 副主编\n\n同济大学计算机科学专业博士，浙江农林大学副教授、硕士生导师，主要从事推荐系统、排序学习、凸优化等机器学习领域的科研和教学工作，发表SCI论文10余篇，曾获浙江省科技进步二等奖等多项省部级奖项。\n\n佃松宜 副主编\n\n日本东北大学博士，四川大学电气工程学院教授、自动化系系主任，四川省信息与自动化技术重点实验室主任。主要专注于先进控制理论与人工智能算法研究、嵌入式计算与实时智能系统的研究与开发、机器人与智能装备的智能感知与控制技术的研究、工业测控与智能物联的研究。近5年来主持包括国家重点研发计划、基金、国网总部项目等各类科研项目近30项，累计总经费近2200万元；发表论文100多篇，其中SCI/EI检索近40篇，ESI高引论文1篇。参与编撰专著3部（其中英文专著1部），参编国家九五规划教材1部。\n\n王晋东 特邀编委\n\n中科院计算所博士，微软亚洲研究院机器学习研究员，主要从事迁移学习和机器学习方向的研究工作，在IJCAI、CVPR、ICDM、UbiComp、ACMMM、PERCOM、IJCNN、PRICAI、IEEE TNNLS、NEUNET、PRL、PMCJ、IMWUT、IJMLC、ICME、ACM TIST等国际权威期刊和会议上发表论文20余篇，多次获得“最佳论文”奖。作品有《迁移学习简明手册》等。\n\n王超锋\n\n上海大学硕士，百度计算机视觉算法工程师，主研图像处理，深度学习等方向。曾多次在国内外各类知名计算机视觉挑战赛中获得优异成绩。\n\n郭晓锋\n\n中国科学院硕士，爱奇艺算法工程师，主要从事图像处理、深度学习等方向的研究，曾获“2017华为软件精英挑战赛”复赛第6名。\n\n黄伟\n\n华南理工大学硕士，顺丰科技机器人算法工程师，主要从事计算机视觉和自然语言处理方向的研究。曾在相关领域国际期刊、会议上发表论文，并在相关竞赛中获得优异成绩。\n\n陈方杰（Amusi）\n\n上海大学硕士，CVer（计算机视觉知识分享和学习交流平台）创始人。\n\n李元伟\n\n国防科技大学硕士，深圳瀚维智能医疗科技公司高级算法工程师，南方科技大学和瀚维智能医疗联合实验室委员，主要从事机器视觉、图像处理及深度学习方向的研究工作，参编普通高等教育十三五规划教材《图像通信基础》，在IEEE TCSVT、COGN COMPUT等发表学术论文多篇，曾获湖南省/全军优秀硕士论文。\n\n陈琳\n\n北京航空航天大学博士（在读），研究方向为无人机智能控制与决策、仿生智能计算。\n\n\n# 目录\n第1章 数学基础 1\n\n1.1 向量和矩阵 1\n\n1.1.1 标量、向量、矩阵和张量 1\n\n1.1.2 张量与矩阵的区别 2\n\n1.1.3 矩阵和向量相乘的结果 2\n\n1.1.4 向量和矩阵的范数归纳 2\n\n1.1.5 判断一个矩阵是否为正定矩阵 4\n\n1.2 导数和偏导数 5\n\n1.2.1 导数偏导计算 5\n\n1.2.2 导数和偏导数的区别 6\n\n1.3 特征值和特征向量 6\n\n1.3.1 特征值分解 6\n\n1.3.2 奇异值和特征值的关系 6\n\n1.4 概率分布与随机变量 7\n\n1.4.1 机器学习为什么要使用概率 7\n\n1.4.2 变量与随机变量的区别 7\n\n1.4.3 随机变量与概率分布的联系 8\n\n1.4.4 离散型随机变量和概率质量函数 8\n\n1.4.5 连续型随机变量和概率密度函数 8\n\n1.4.6 举例理解条件概率 9\n\n1.4.7 联合概率与边缘概率的区别和联系 9\n\n1.4.8 条件概率的链式法则 10\n\n1.4.9 独立性和条件独立性 10\n\n1.5 常见概率分布 11\n\n1.5.1 伯努利分布 11\n\n1.5.2 高斯分布 11\n\n1.5.3 何时采用正态分布 12\n\n1.5.4 指数分布 12\n\n1.5.5 Laplace分布 13\n\n1.5.6 Dirac分布和经验分布 13\n\n1.6 期望、方差、协方差、相关系数 13\n\n1.6.1 期望 13\n\n1.6.2 方差 14\n\n1.6.3 协方差 14\n\n1.6.4 相关系数 15\n\n第2章 机器学习基础 16\n\n2.1 基本概念 16\n\n2.1.1 大话机器学习本质 16\n\n2.1.2 什么是神经网络 16\n\n2.1.3 各种常见算法图示 17\n\n2.1.4 计算图的导数计算 17\n\n2.1.5 理解局部最优与全局最优 18\n\n2.1.6 大数据与深度学习之间的关系 19\n\n2.2 机器学习的学习方式 20\n\n2.2.1 监督学习 20\n\n2.2.2 非监督学习 20\n\n2.2.3 半监督学习 20\n\n2.2.4 弱监督学习 20\n\n2.2.5 监督学习模型的搭建步骤 21\n\n2.3 分类算法 22\n\n2.3.1 常用分类算法的优缺点 22\n\n2.3.2 分类算法的评估方法 23\n\n2.3.3 正确率能否很好地评估分类算法 25\n\n2.3.4 什么样的分类器是最好的 26\n\n2.4 逻辑回归 26\n\n2.4.1 回归的种类 26\n\n2.4.2 逻辑回归适用性 27\n\n2.4.3 逻辑回归与朴素贝叶斯的区别 27\n\n2.4.4 线性回归与逻辑回归的区别 27\n\n2.5 代价函数 28\n\n2.5.1 为什么需要代价函数 28\n\n2.5.2 代价函数作用原理 28\n\n2.5.3 常见代价函数 30\n\n2.5.4 为什么代价函数要非负 31\n\n2.5.5 为什么用交叉熵代替二次代价函数 31\n\n2.6 损失函数 32\n\n2.6.1 什么是损失函数 32\n\n2.6.2 常见的损失函数 32\n\n2.6.3 逻辑回归为什么使用对数损失函数 34\n\n2.6.4 对数损失函数如何度量损失 34\n\n2.7 梯度下降法 35\n\n2.7.1 梯度下降法的作用 36\n\n2.7.2 梯度下降法的直观理解 36\n\n2.7.3 梯度下降法算法描述 37\n\n2.7.4 梯度下降法的缺点 38\n\n2.7.5 如何对梯度下降法进行调优 38\n\n2.7.6 随机梯度下降和批量梯度下降的区别 38\n\n2.7.7 各种梯度下降法性能比较 40\n\n2.8 线性判别分析 40\n\n2.8.1 LDA思想总结 40\n\n2.8.2 图解LDA核心思想 41\n\n2.8.3 二类LDA算法原理 41\n\n2.8.4 LDA算法流程总结 42\n\n2.8.5 LDA和PCA的异同 43\n\n2.8.6 LDA的优缺点 43\n\n2.9 主成分分析 43\n\n2.9.1 图解PCA核心思想 43\n\n2.9.2 PCA算法推理 44\n\n2.9.3 PCA算法流程总结 45\n\n2.9.4 PCA思想总结 46\n\n2.9.5 PCA算法的优缺点 46\n\n2.9.6 降维的必要性及目的 46\n\n2.9.7 KPCA与PCA的区别 47\n\n2.10 模型评估 47\n\n2.10.1 模型评估常用方法 48\n\n2.10.2 误差、偏差和方差的区别和联系 48\n\n2.10.3 为什么使用标准差 49\n\n2.10.4 经验误差与泛化误差 50\n\n2.10.5 图解欠拟合与过拟合 50\n\n2.10.6 如何解决欠拟合与过拟合 52\n\n2.10.7 交叉验证的主要作用 52\n\n2.10.8 理解K折交叉验证 53\n\n2.10.9 理解混淆矩阵 53\n\n2.10.10 理解查准率与查全率 53\n\n2.10.11 理解ROC与AUC 54\n\n2.10.12 如何绘制ROC曲线 55\n\n2.10.13 如何计算TPR和FPR 56\n\n2.10.14 如何计算AUC 58\n\n2.10.15 直观理解AUC 58\n\n2.10.16 ROC评估分类器 60\n\n2.10.17 代价敏感错误率与代价曲线 60\n\n2.10.18 比较检验方法 61\n\n2.11 决策树 61\n\n2.11.1 决策树的基本原理 62\n\n2.11.2 决策树的生成过程 62\n\n2.11.3 决策树学习基本算法步骤 62\n\n2.11.4 决策树算法的优缺点 63\n\n2.11.5 决策树和熵的联系 63\n\n2.11.6 熵的概念及定义 63\n\n2.11.7 理解信息增益 64\n\n2.11.8 决策树中熵、条件熵和信息增益的联系 64\n\n2.11.9 决策树算法中剪枝的作用及策略 65\n\n2.12 支持向量机（SVM） 65\n\n2.12.1 什么是SVM 65\n\n2.12.2 SVM能解决的问题 66\n\n2.12.3 核函数特点及其作用 67\n\n2.12.4 SVM为什么引入对偶问题 67\n\n2.12.5 如何理解SVM中的对偶问题 67\n\n2.12.6 常见的核函数 69\n\n2.12.7 SVM的主要特点 69\n\n2.12.8 SVM的主要缺点 70\n\n2.12.9 逻辑回归与SVM的异同 70\n\n2.13 贝叶斯分类器 72\n\n2.13.1 贝叶斯分类器的基本原理 72\n\n2.13.2 朴素贝叶斯分类器 72\n\n2.13.3 举例理解朴素贝叶斯分类器 73\n\n2.13.4 半朴素贝叶斯分类器 75\n\n2.13.5 极大似然估计和贝叶斯估计的联系与区别 75\n\n2.13.6 极大似然估计原理 76\n\n2.13.7 图解极大似然估计 76\n\n2.14 EM算法 77\n\n2.14.1 EM算法的基本思想 77\n\n2.14.2 EM算法推导 77\n\n2.14.3 图解EM算法 78\n\n2.14.4 EM算法流程 79\n\n2.15 降维和聚类 79\n\n2.15.1 图解为什么会产生维数灾难 79\n\n2.15.2 怎样避免维数灾难 83\n\n2.15.3 聚类和降维 83\n\n2.15.4 聚类算法优劣的衡量标准 84\n\n2.15.5 聚类和分类 85\n\n2.15.6 聚类算法的性能比较 85\n\n2.15.7 4种常用聚类方法比较 85\n\n第3章 深度学习基础 89\n\n3.1 基本概念 89\n\n3.1.1 神经网络的类型 89\n\n3.1.2 神经网络的常用模型结构 92\n\n3.1.3 深度学习和机器学习的区别与联系 93\n\n3.1.4 为什么使用深层表示 93\n\n3.1.5 深度学习架构分类 94\n\n3.1.6 如何选择深度学习开发平台 94\n\n3.2 神经网络计算 95\n\n3.2.1 前向传播和反向传播 95\n\n3.2.2 如何计算神经网络的输出 96\n\n3.2.3 如何计算卷积神经网络输出值 97\n\n3.2.4 如何计算池化层输出值 100\n\n3.2.5 反向传播实例 101\n\n3.2.6 神经网络更“深”的意义 104\n\n3.3 激活函数 104\n\n3.3.1 为什么需要激活函数 104\n\n3.3.2 为什么激活函数需要非线性函数 105\n\n3.3.3 常见的激活函数及其图像 105\n\n3.3.4 常见激活函数的导数计算 107\n\n3.3.5 激活函数有哪些性质 108\n\n3.3.6 如何选择激活函数 108\n\n3.3.7 为什么tanh收敛速度比sigmoid快 109\n\n3.3.8 Relu激活函数的优点 109\n\n3.3.9 理解Relu激活函数的稀疏激活性 109\n\n3.3.10 什么时候可以用线性激活函数 109\n\n3.3.11 softmax函数的定义及作用 110\n\n3.3.12 softmax函数如何应用于多分类 110\n\n3.4 BATCH SIZE 112\n\n3.4.1 为什么需要Batch Size 112\n\n3.4.2 如何选择Batch Size值 112\n\n3.4.3 调节Batch Size对训练效果的影响 113\n\n3.4.4 在合理范围内增大Batch Size的好处 113\n\n3.4.5 盲目增大Batch Size的坏处 114\n\n3.5 归一化 114\n\n3.5.1 理解归一化含义 114\n\n3.5.2 归一化和标准化的联系与区别 114\n\n3.5.3 为什么要归一化或标准化 115\n\n3.5.4 图解为什么要归一化 115\n\n3.5.5 为什么归一化能提高求最优解速度 115\n\n3.5.6 归一化有哪些类型 116\n\n3.5.7 局部响应归一化作用 116\n\n3.5.8 局部响应归一化原理 117\n\n3.5.9 什么是批归一化 118\n\n3.5.10 批归一化的优点 118\n\n3.5.11 批归一化算法流程 118\n\n3.5.12 批归一化和组归一化比较 119\n\n3.5.13 权重归一化和批归一化比较 119\n\n3.5.14 批归一化适用范围 120\n\n3.5.15 BN、LN、IN和GN的对比 120\n\n3.6 参数初始化 121\n\n3.6.1 参数初始化应满足的条件 121\n\n3.6.2 常用的几种初始化方式 121\n\n3.6.3 全0初始化带来的问题 121\n\n3.6.4 全都初始化为同样的值 122\n\n3.6.5 初始化为小的随机数 123\n\n3.6.6 用 校准方差 123\n\n3.7 预训练与微调 123\n\n3.7.1 什么是预训练和微调 123\n\n3.7.2 预训练和微调的作用 124\n\n3.7.3 预训练模型的复用 124\n\n3.7.4 预训练和迁移学习 125\n\n3.7.5 微调时网络参数是否更新 125\n\n3.7.6 微调模型的三种状态 125\n\n3.7.7 为什么深层神经网络难以训练 125\n\n3.8 超参数 127\n\n3.8.1 超参数有哪些 127\n\n3.8.2 参数和模型的关系 127\n\n3.8.3 参数和超参数的区别 127\n\n3.8.4 如何寻找超参数的最优值 128\n\n3.8.5 超参数搜索的一般过程 128\n\n3.9 学习率 129\n\n3.9.1 学习率的作用 129\n\n3.9.2 学习率衰减的常用参数 129\n\n3.9.3 常用的学习率衰减方法 129\n\n3.10 正则化 133\n\n3.10.1 为什么要正则化 133\n\n3.10.2 常见正则化方法 133\n\n3.10.3 图解L1和L2正则化 134\n\n3.10.4 Dropout具体工作流程 135\n\n3.10.5 为什么Dropout可以解决过拟合问题 137\n\n3.10.6 Dropout的缺点\n"
        },
        {
          "name": "Translation Required",
          "type": "blob",
          "size": 0.05859375,
          "content": "Please include a language translator, preferably to English\n"
        },
        {
          "name": "_sidebar.md",
          "type": "blob",
          "size": 2.0302734375,
          "content": "* [简介]()\n* [1. 第一章 数学基础](ch01_数学基础/第一章_数学基础.md)\n* [2. 第二章 机器学习基础](ch02_机器学习基础/第二章_机器学习基础.md)\n* [3. 第三章 深度学习基础](ch03_深度学习基础/第三章_深度学习基础.md)\n* [4. 第四章 经典网络](ch04_经典网络/第四章_经典网络.md)\n* [5. 第五章 卷积神经网络(CNN)](ch05_卷积神经网络(CNN)/第五章_卷积神经网络(CNN).md)\n* [6. 第六章 循环神经网络(RNN)](ch06_循环神经网络(RNN)/第六章_循环神经网络(RNN).md)\n* [7. 第七章 生成对抗网络(GAN)](ch07_生成对抗网络(GAN)/ch7.md)\n* [8. 第八章 目标检测](ch08_目标检测/第八章_目标检测.md)\n* [9. 第九章 图像分割](ch09_图像分割/第九章_图像分割.md)\n* [10. 第十章 强化学习](ch10_强化学习/第十章_强化学习.md)\n* [11. 第十一章 迁移学习](ch11_迁移学习/第十一章_迁移学习.md)\n* [12. 第十二章 网络搭建及训练](ch12_网络搭建及训练/第十二章_网络搭建及训练.md)\n* [13. 第十三章 优化算法](ch13_优化算法/第十三章_优化算法.md)\n* [14. 第十四章 超参数调整](ch14_超参数调整/第十四章_超参数调整.md)\n* [15. 第十五章 异构运算、GPU及框架选型](ch15_GPU和框架选型/第十五章_异构运算、GPU及框架选型.md)\n* [16. 第十六章 自然语言处理](ch16_自然语言处理(NLP)/第十六章_NLP.md)\n* [17. 第十七章 模型压缩、加速及移动端部署](ch17_模型压缩、加速及移动端部署/第十七章_模型压缩、加速及移动端部署.md)\n* [18. 第十八章 后端架构选型、离线及实时计算](ch18_后端架构选型、离线及实时计算/第十八章_后端架构选型、离线及实时计算.md)\n* [19. 第十八章 后端架构选型及应用场景](ch18_后端架构选型及应用场景/第十八章_后端架构选型及应用场景.md)\n* [20. 第十九章 软件专利申请及权利保护](ch19_软件专利申请及权利保护/第十九章_软件专利申请及权利保护.md)\n\n"
        },
        {
          "name": "ch01_数学基础",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch02_机器学习基础",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch03_深度学习基础",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch04_经典网络",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch05_卷积神经网络(CNN)",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch06_循环神经网络(RNN)",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch07_生成对抗网络(GAN)",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch08_目标检测",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch09_图像分割",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch10_强化学习",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch11_迁移学习",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch12_网络搭建及训练",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch13_优化算法",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch14_超参数调整",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch15_GPU和框架选型",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch16_自然语言处理(NLP)",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch17_模型压缩、加速及移动端部署",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch18_后端架构选型、离线及实时计算",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch18_后端架构选型及应用场景",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch19_软件专利申请及权利保护",
          "type": "tree",
          "content": null
        },
        {
          "name": "docsify.js",
          "type": "blob",
          "size": 148.787109375,
          "content": "(function () {\n    /**\n     * Create a cached version of a pure function.\n     */\n    function cached(fn) {\n      var cache = Object.create(null);\n      return function (str) {\n        var key = isPrimitive(str) ? str : JSON.stringify(str);\n        var hit = cache[key];\n        return hit || (cache[key] = fn(str))\n      }\n    }\n    \n    /**\n     * Hyphenate a camelCase string.\n     */\n    var hyphenate = cached(function (str) {\n      return str.replace(/([A-Z])/g, function (m) { return '-' + m.toLowerCase(); })\n    });\n    \n    var hasOwn = Object.prototype.hasOwnProperty;\n    \n    /**\n     * Simple Object.assign polyfill\n     */\n    var merge =\n      Object.assign ||\n      function (to) {\n        var arguments$1 = arguments;\n    \n        for (var i = 1; i < arguments.length; i++) {\n          var from = Object(arguments$1[i]);\n    \n          for (var key in from) {\n            if (hasOwn.call(from, key)) {\n              to[key] = from[key];\n            }\n          }\n        }\n    \n        return to\n      };\n    \n    /**\n     * Check if value is primitive\n     */\n    function isPrimitive(value) {\n      return typeof value === 'string' || typeof value === 'number'\n    }\n    \n    /**\n     * Perform no operation.\n     */\n    function noop() {}\n    \n    /**\n     * Check if value is function\n     */\n    function isFn(obj) {\n      return typeof obj === 'function'\n    }\n    \n    function config () {\n      var config = merge(\n        {\n          el: '#app',\n          repo: '',\n          maxLevel: 6,\n          subMaxLevel: 0,\n          loadSidebar: null,\n          loadNavbar: null,\n          homepage: 'README.md',\n          coverpage: '',\n          basePath: '',\n          auto2top: false,\n          name: '',\n          themeColor: '',\n          nameLink: window.location.pathname,\n          autoHeader: false,\n          executeScript: null,\n          noEmoji: false,\n          ga: '',\n          ext: '.md',\n          mergeNavbar: false,\n          formatUpdated: '',\n          externalLinkTarget: '_blank',\n          routerMode: 'hash',\n          noCompileLinks: [],\n          relativePath: false\n        },\n        window.$docsify\n      );\n    \n      var script =\n        document.currentScript ||\n        [].slice\n          .call(document.getElementsByTagName('script'))\n          .filter(function (n) { return /docsify\\./.test(n.src); })[0];\n    \n      if (script) {\n        for (var prop in config) {\n          if (hasOwn.call(config, prop)) {\n            var val = script.getAttribute('data-' + hyphenate(prop));\n    \n            if (isPrimitive(val)) {\n              config[prop] = val === '' ? true : val;\n            }\n          }\n        }\n    \n        if (config.loadSidebar === true) {\n          config.loadSidebar = '_sidebar' + config.ext;\n        }\n        if (config.loadNavbar === true) {\n          config.loadNavbar = '_navbar' + config.ext;\n        }\n        if (config.coverpage === true) {\n          config.coverpage = '_coverpage' + config.ext;\n        }\n        if (config.repo === true) {\n          config.repo = '';\n        }\n        if (config.name === true) {\n          config.name = '';\n        }\n      }\n    \n      window.$docsify = config;\n    \n      return config\n    }\n    \n    function initLifecycle(vm) {\n      var hooks = [\n        'init',\n        'mounted',\n        'beforeEach',\n        'afterEach',\n        'doneEach',\n        'ready'\n      ];\n    \n      vm._hooks = {};\n      vm._lifecycle = {};\n      hooks.forEach(function (hook) {\n        var arr = (vm._hooks[hook] = []);\n        vm._lifecycle[hook] = function (fn) { return arr.push(fn); };\n      });\n    }\n    \n    function callHook(vm, hook, data, next) {\n      if ( next === void 0 ) next = noop;\n    \n      var queue = vm._hooks[hook];\n    \n      var step = function (index) {\n        var hook = queue[index];\n        if (index >= queue.length) {\n          next(data);\n        } else if (typeof hook === 'function') {\n          if (hook.length === 2) {\n            hook(data, function (result) {\n              data = result;\n              step(index + 1);\n            });\n          } else {\n            var result = hook(data);\n            data = result === undefined ? data : result;\n            step(index + 1);\n          }\n        } else {\n          step(index + 1);\n        }\n      };\n    \n      step(0);\n    }\n    \n    var inBrowser = !false;\n    \n    var isMobile = inBrowser && document.body.clientWidth <= 600;\n    \n    /**\n     * @see https://github.com/MoOx/pjax/blob/master/lib/is-supported.js\n     */\n    var supportsPushState =\n      inBrowser &&\n      (function () {\n        // Borrowed wholesale from https://github.com/defunkt/jquery-pjax\n        return (\n          window.history &&\n          window.history.pushState &&\n          window.history.replaceState &&\n          // PushState isn’t reliable on iOS until 5.\n          !navigator.userAgent.match(\n            /((iPod|iPhone|iPad).+\\bOS\\s+[1-4]\\D|WebApps\\/.+CFNetwork)/\n          )\n        )\n      })();\n    \n    var cacheNode = {};\n    \n    /**\n     * Get Node\n     * @param  {String|Element} el\n     * @param  {Boolean} noCache\n     * @return {Element}\n     */\n    function getNode(el, noCache) {\n      if ( noCache === void 0 ) noCache = false;\n    \n      if (typeof el === 'string') {\n        if (typeof window.Vue !== 'undefined') {\n          return find(el)\n        }\n        el = noCache ? find(el) : cacheNode[el] || (cacheNode[el] = find(el));\n      }\n    \n      return el\n    }\n    \n    var $ = inBrowser && document;\n    \n    var body = inBrowser && $.body;\n    \n    var head = inBrowser && $.head;\n    \n    /**\n     * Find element\n     * @example\n     * find('nav') => document.querySelector('nav')\n     * find(nav, 'a') => nav.querySelector('a')\n     */\n    function find(el, node) {\n      return node ? el.querySelector(node) : $.querySelector(el)\n    }\n    \n    /**\n     * Find all elements\n     * @example\n     * findAll('a') => [].slice.call(document.querySelectorAll('a'))\n     * findAll(nav, 'a') => [].slice.call(nav.querySelectorAll('a'))\n     */\n    function findAll(el, node) {\n      return [].slice.call(\n        node ? el.querySelectorAll(node) : $.querySelectorAll(el)\n      )\n    }\n    \n    function create(node, tpl) {\n      node = $.createElement(node);\n      if (tpl) {\n        node.innerHTML = tpl;\n      }\n      return node\n    }\n    \n    function appendTo(target, el) {\n      return target.appendChild(el)\n    }\n    \n    function before(target, el) {\n      return target.insertBefore(el, target.children[0])\n    }\n    \n    function on(el, type, handler) {\n      isFn(type) ?\n        window.addEventListener(el, type) :\n        el.addEventListener(type, handler);\n    }\n    \n    function off(el, type, handler) {\n      isFn(type) ?\n        window.removeEventListener(el, type) :\n        el.removeEventListener(type, handler);\n    }\n    \n    /**\n     * Toggle class\n     *\n     * @example\n     * toggleClass(el, 'active') => el.classList.toggle('active')\n     * toggleClass(el, 'add', 'active') => el.classList.add('active')\n     */\n    function toggleClass(el, type, val) {\n      el && el.classList[val ? type : 'toggle'](val || type);\n    }\n    \n    function style(content) {\n      appendTo(head, create('style', content));\n    }\n    \n    \n    var dom = Object.freeze({\n        getNode: getNode,\n        $: $,\n        body: body,\n        head: head,\n        find: find,\n        findAll: findAll,\n        create: create,\n        appendTo: appendTo,\n        before: before,\n        on: on,\n        off: off,\n        toggleClass: toggleClass,\n        style: style\n    });\n    \n    /**\n     * Render github corner\n     * @param  {Object} data\n     * @return {String}\n     */\n    function corner(data) {\n      if (!data) {\n        return ''\n      }\n      if (!/\\/\\//.test(data)) {\n        data = 'https://github.com/' + data;\n      }\n      data = data.replace(/^git\\+/, '');\n    \n      return (\n        \"<a href=\\\"\" + data + \"\\\" class=\\\"github-corner\\\" aria-label=\\\"View source on Github\\\">\" +\n        '<svg viewBox=\"0 0 250 250\" aria-hidden=\"true\">' +\n        '<path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\"></path>' +\n        '<path d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\" fill=\"currentColor\" style=\"transform-origin: 130px 106px;\" class=\"octo-arm\"></path>' +\n        '<path d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\" fill=\"currentColor\" class=\"octo-body\"></path>' +\n        '</svg>' +\n        '</a>'\n      )\n    }\n    \n    /**\n     * Render main content\n     */\n    function main(config) {\n      var aside =\n        '<button class=\"sidebar-toggle\">' +\n        '<div class=\"sidebar-toggle-button\">' +\n        '<span></span><span></span><span></span>' +\n        '</div>' +\n        '</button>' +\n        '<aside class=\"sidebar\">' +\n        (config.name ?\n          (\"<h1 class=\\\"app-name\\\"><a class=\\\"app-name-link\\\" data-nosearch>\" + (config.logo ?\n              (\"<img alt=\" + (config.name) + \" src=\" + (config.logo) + \">\") :\n              config.name) + \"</a></h1>\") :\n          '') +\n        '<div class=\"sidebar-nav\"><!--sidebar--></div>' +\n        '</aside>';\n    \n      return (\n        (isMobile ? (aside + \"<main>\") : (\"<main>\" + aside)) +\n        '<section class=\"content\">' +\n        '<article class=\"markdown-section\" id=\"main\"><!--main--></article>' +\n        '</section>' +\n        '</main>'\n      )\n    }\n    \n    /**\n     * Cover Page\n     */\n    function cover() {\n      var SL = ', 100%, 85%';\n      var bgc =\n        'linear-gradient(to left bottom, ' +\n        \"hsl(\" + (Math.floor(Math.random() * 255) + SL) + \") 0%,\" +\n        \"hsl(\" + (Math.floor(Math.random() * 255) + SL) + \") 100%)\";\n    \n      return (\n        \"<section class=\\\"cover show\\\" style=\\\"background: \" + bgc + \"\\\">\" +\n        '<div class=\"cover-main\"><!--cover--></div>' +\n        '<div class=\"mask\"></div>' +\n        '</section>'\n      )\n    }\n    \n    /**\n     * Render tree\n     * @param  {Array} tree\n     * @param  {String} tpl\n     * @return {String}\n     */\n    function tree(toc, tpl) {\n      if ( tpl === void 0 ) tpl = '<ul class=\"app-sub-sidebar\">{inner}</ul>';\n    \n      if (!toc || !toc.length) {\n        return ''\n      }\n      var innerHTML = '';\n      toc.forEach(function (node) {\n        innerHTML += \"<li><a class=\\\"section-link\\\" href=\\\"\" + (node.slug) + \"\\\">\" + (node.title) + \"</a></li>\";\n        if (node.children) {\n          innerHTML += tree(node.children, tpl);\n        }\n      });\n      return tpl.replace('{inner}', innerHTML)\n    }\n    \n    function helper(className, content) {\n      return (\"<p class=\\\"\" + className + \"\\\">\" + (content.slice(5).trim()) + \"</p>\")\n    }\n    \n    function theme(color) {\n      return (\"<style>:root{--theme-color: \" + color + \";}</style>\")\n    }\n    \n    var barEl;\n    var timeId;\n    \n    /**\n     * Init progress component\n     */\n    function init() {\n      var div = create('div');\n    \n      div.classList.add('progress');\n      appendTo(body, div);\n      barEl = div;\n    }\n    /**\n     * Render progress bar\n     */\n    function progressbar (ref) {\n      var loaded = ref.loaded;\n      var total = ref.total;\n      var step = ref.step;\n    \n      var num;\n    \n      !barEl && init();\n    \n      if (step) {\n        num = parseInt(barEl.style.width || 0, 10) + step;\n        num = num > 80 ? 80 : num;\n      } else {\n        num = Math.floor(loaded / total * 100);\n      }\n    \n      barEl.style.opacity = 1;\n      barEl.style.width = num >= 95 ? '100%' : num + '%';\n    \n      if (num >= 95) {\n        clearTimeout(timeId);\n        timeId = setTimeout(function (_) {\n          barEl.style.opacity = 0;\n          barEl.style.width = '0%';\n        }, 200);\n      }\n    }\n    \n    var cache = {};\n    \n    /**\n     * Simple ajax get\n     * @param {string} url\n     * @param {boolean} [hasBar=false] has progress bar\n     * @return { then(resolve, reject), abort }\n     */\n    function get(url, hasBar, headers) {\n      if ( hasBar === void 0 ) hasBar = false;\n      if ( headers === void 0 ) headers = {};\n    \n      var xhr = new XMLHttpRequest();\n      var on = function () {\n        xhr.addEventListener.apply(xhr, arguments);\n      };\n      var cached$$1 = cache[url];\n    \n      if (cached$$1) {\n        return {then: function (cb) { return cb(cached$$1.content, cached$$1.opt); }, abort: noop}\n      }\n    \n      xhr.open('GET', url);\n      for (var i in headers) {\n        if (hasOwn.call(headers, i)) {\n          xhr.setRequestHeader(i, headers[i]);\n        }\n      }\n      xhr.send();\n    \n      return {\n        then: function (success, error) {\n          if ( error === void 0 ) error = noop;\n    \n          if (hasBar) {\n            var id = setInterval(\n              function (_) { return progressbar({\n                  step: Math.floor(Math.random() * 5 + 1)\n                }); },\n              500\n            );\n    \n            on('progress', progressbar);\n            on('loadend', function (evt) {\n              progressbar(evt);\n              clearInterval(id);\n            });\n          }\n    \n          on('error', error);\n          on('load', function (ref) {\n            var target = ref.target;\n    \n            if (target.status >= 400) {\n              error(target);\n            } else {\n              var result = (cache[url] = {\n                content: target.response,\n                opt: {\n                  updatedAt: xhr.getResponseHeader('last-modified')\n                }\n              });\n    \n              success(result.content, result.opt);\n            }\n          });\n        },\n        abort: function (_) { return xhr.readyState !== 4 && xhr.abort(); }\n      }\n    }\n    \n    function replaceVar(block, color) {\n      block.innerHTML = block.innerHTML.replace(\n        /var\\(\\s*--theme-color.*?\\)/g,\n        color\n      );\n    }\n    \n    function cssVars (color) {\n      // Variable support\n      if (window.CSS && window.CSS.supports && window.CSS.supports('(--v:red)')) {\n        return\n      }\n    \n      var styleBlocks = findAll('style:not(.inserted),link');\n      [].forEach.call(styleBlocks, function (block) {\n        if (block.nodeName === 'STYLE') {\n          replaceVar(block, color);\n        } else if (block.nodeName === 'LINK') {\n          var href = block.getAttribute('href');\n    \n          if (!/\\.css$/.test(href)) {\n            return\n          }\n    \n          get(href).then(function (res) {\n            var style$$1 = create('style', res);\n    \n            head.appendChild(style$$1);\n            replaceVar(style$$1, color);\n          });\n        }\n      });\n    }\n    \n    var RGX = /([^{]*?)\\w(?=\\})/g;\n    \n    var dict = {\n        YYYY: 'getFullYear',\n        YY: 'getYear',\n        MM: function (d) {\n            return d.getMonth() + 1;\n        },\n        DD: 'getDate',\n        HH: 'getHours',\n        mm: 'getMinutes',\n        ss: 'getSeconds'\n    };\n    \n    function tinydate (str) {\n        var parts=[], offset=0;\n        str.replace(RGX, function (key, _, idx) {\n            // save preceding string\n            parts.push(str.substring(offset, idx - 1));\n            offset = idx += key.length + 1;\n            // save function\n            parts.push(function(d){\n                return ('00' + (typeof dict[key]==='string' ? d[dict[key]]() : dict[key](d))).slice(-key.length);\n            });\n        });\n    \n        if (offset !== str.length) {\n            parts.push(str.substring(offset));\n        }\n    \n        return function (arg) {\n            var out='', i=0, d=arg||new Date();\n            for (; i<parts.length; i++) {\n                out += (typeof parts[i]==='string') ? parts[i] : parts[i](d);\n            }\n            return out;\n        };\n    }\n    \n    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n    \n    \n    \n    \n    \n    function createCommonjsModule(fn, module) {\n        return module = { exports: {} }, fn(module, module.exports), module.exports;\n    }\n    \n    var marked = createCommonjsModule(function (module, exports) {\n    /**\n     * marked - a markdown parser\n     * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)\n     * https://github.com/markedjs/marked\n     */\n    \n    (function(root) {\n    var block = {\n      newline: /^\\n+/,\n      code: /^( {4}[^\\n]+\\n*)+/,\n      fences: noop,\n      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n      heading: /^ *(#{1,6}) *([^\\n]+?) *(?:#+ *)?(?:\\n+|$)/,\n      nptable: noop,\n      blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n      blocklatex: /^(\\${2}) *((?:[^$]|\\\\\\$)+?) *\\n\\1(?:\\n|$)/,\n      list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n      html: '^ {0,3}(?:' // optional indentation\n        + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n        + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n        + '|<\\\\?[\\\\s\\\\S]*?\\\\?>\\\\n*' // (3)\n        + '|<![A-Z][\\\\s\\\\S]*?>\\\\n*' // (4)\n        + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\\\\n*' // (5)\n        + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n        + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=\\\\h*\\\\n)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n        + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=\\\\h*\\\\n)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n        + ')',\n      def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n      table: noop,\n      lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n      paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading| {0,3}>|<\\/?(?:tag)(?: +|\\n|\\/?>)|<(?:script|pre|style|!--))[^\\n]+)*)/,\n      text: /^[^\\n]+/\n    };\n    \n    block._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n    block._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n    block.def = edit(block.def)\n      .replace('label', block._label)\n      .replace('title', block._title)\n      .getRegex();\n    \n    block.bullet = /(?:[*+-]|\\d+\\.)/;\n    block.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\n    block.item = edit(block.item, 'gm')\n      .replace(/bull/g, block.bullet)\n      .getRegex();\n    \n    block.list = edit(block.list)\n      .replace(/bull/g, block.bullet)\n      .replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))')\n      .replace('def', '\\\\n+(?=' + block.def.source + ')')\n      .getRegex();\n    \n    block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n      + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n      + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n      + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n      + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n      + '|track|ul';\n    block._comment = /<!--(?!-?>)[\\s\\S]*?-->/;\n    block.html = edit(block.html, 'i')\n      .replace('comment', block._comment)\n      .replace('tag', block._tag)\n      .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n      .getRegex();\n    \n    block.paragraph = edit(block.paragraph)\n      .replace('hr', block.hr)\n      .replace('heading', block.heading)\n      .replace('lheading', block.lheading)\n      .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n      .getRegex();\n    \n    block.blockquote = edit(block.blockquote)\n      .replace('paragraph', block.paragraph)\n      .getRegex();\n    \n    /**\n     * Normal Block Grammar\n     */\n    \n    block.normal = merge({}, block);\n    \n    /**\n     * GFM Block Grammar\n     */\n    \n    block.gfm = merge({}, block.normal, {\n      fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\n? *\\1 *(?:\\n+|$)/,\n      paragraph: /^/,\n      heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\n    });\n    \n    block.gfm.paragraph = edit(block.paragraph)\n      .replace('(?!', '(?!'\n        + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\n        + block.list.source.replace('\\\\1', '\\\\3') + '|')\n      .getRegex();\n    \n    /**\n     * GFM + Tables Block Grammar\n     */\n    \n    block.tables = merge({}, block.gfm, {\n      nptable: /^ *([^|\\n ].*\\|.*)\\n *([-:]+ *\\|[-| :]*)(?:\\n((?:.*[^>\\n ].*(?:\\n|$))*)\\n*|$)/,\n      table: /^ *\\|(.+)\\n *\\|?( *[-:]+[-| :]*)(?:\\n((?: *[^>\\n ].*(?:\\n|$))*)\\n*|$)/\n    });\n    \n    /**\n     * Pedantic grammar\n     */\n    \n    block.pedantic = merge({}, block.normal, {\n      html: edit(\n        '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', block._comment)\n        .replace(/tag/g, '(?!(?:'\n          + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n          + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n          + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n      def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/\n    });\n    \n    /**\n     * Block Lexer\n     */\n    \n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = {};\n      this.options = options || marked.defaults;\n      this.rules = block.normal;\n    \n      if (this.options.pedantic) {\n        this.rules = block.pedantic;\n      } else if (this.options.gfm) {\n        if (this.options.tables) {\n          this.rules = block.tables;\n        } else {\n          this.rules = block.gfm;\n        }\n      }\n    }\n    \n    /**\n     * Expose Block Rules\n     */\n    \n    Lexer.rules = block;\n    \n    /**\n     * Static Lex Method\n     */\n    \n    Lexer.lex = function(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    };\n    \n    /**\n     * Preprocessing\n     */\n    \n    Lexer.prototype.lex = function(src) {\n      src = src\n        .replace(/\\r\\n|\\r/g, '\\n')\n        .replace(/\\t/g, '    ')\n        .replace(/\\u00a0/g, ' ')\n        .replace(/\\u2424/g, '\\n');\n    \n      return this.token(src, true);\n    };\n    \n    /**\n     * Lexing\n     */\n    \n    Lexer.prototype.token = function(src, top) {\n      src = src.replace(/^ +$/gm, '');\n      var next,\n          loose,\n          cap,\n          bull,\n          b,\n          item,\n          space,\n          i,\n          tag,\n          l,\n          isordered,\n          istask,\n          ischecked;\n    \n      while (src) {\n        // newline\n        if (cap = this.rules.newline.exec(src)) {\n          src = src.substring(cap[0].length);\n          if (cap[0].length > 1) {\n            this.tokens.push({\n              type: 'space'\n            });\n          }\n        }\n    \n        // code\n        if (cap = this.rules.code.exec(src)) {\n          src = src.substring(cap[0].length);\n          cap = cap[0].replace(/^ {4}/gm, '');\n          this.tokens.push({\n            type: 'code',\n            text: !this.options.pedantic\n              ? cap.replace(/\\n+$/, '')\n              : cap\n          });\n          continue;\n        }\n    \n        // fences (gfm)\n        if (cap = this.rules.fences.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'code',\n            lang: cap[2],\n            text: cap[3] || ''\n          });\n          continue;\n        }\n    \n        // heading\n        if (cap = this.rules.heading.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'heading',\n            depth: cap[1].length,\n            text: cap[2]\n          });\n          continue;\n        }\n    \n        // latex\n        if (cap = this.rules.blocklatex.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'blocklatex',\n            text: cap[2]\n          });\n          continue;\n        }\n    \n        // table no leading pipe (gfm)\n        if (top && (cap = this.rules.nptable.exec(src))) {\n          item = {\n            type: 'table',\n            header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n            align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n            cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n          };\n    \n          if (item.header.length === item.align.length) {\n            src = src.substring(cap[0].length);\n    \n            for (i = 0; i < item.align.length; i++) {\n              if (/^ *-+: *$/.test(item.align[i])) {\n                item.align[i] = 'right';\n              } else if (/^ *:-+: *$/.test(item.align[i])) {\n                item.align[i] = 'center';\n              } else if (/^ *:-+ *$/.test(item.align[i])) {\n                item.align[i] = 'left';\n              } else {\n                item.align[i] = null;\n              }\n            }\n    \n            for (i = 0; i < item.cells.length; i++) {\n              item.cells[i] = splitCells(item.cells[i], item.header.length);\n            }\n    \n            this.tokens.push(item);\n    \n            continue;\n          }\n        }\n    \n        // hr\n        if (cap = this.rules.hr.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'hr'\n          });\n          continue;\n        }\n    \n        // blockquote\n        if (cap = this.rules.blockquote.exec(src)) {\n          src = src.substring(cap[0].length);\n    \n          this.tokens.push({\n            type: 'blockquote_start'\n          });\n    \n          cap = cap[0].replace(/^ *> ?/gm, '');\n    \n          // Pass `top` to keep the current\n          // \"toplevel\" state. This is exactly\n          // how markdown.pl works.\n          this.token(cap, top);\n    \n          this.tokens.push({\n            type: 'blockquote_end'\n          });\n    \n          continue;\n        }\n    \n        // list\n        if (cap = this.rules.list.exec(src)) {\n          src = src.substring(cap[0].length);\n          bull = cap[2];\n          isordered = bull.length > 1;\n    \n          this.tokens.push({\n            type: 'list_start',\n            ordered: isordered,\n            start: isordered ? +bull : ''\n          });\n    \n          // Get each top-level item.\n          cap = cap[0].match(this.rules.item);\n    \n          next = false;\n          l = cap.length;\n          i = 0;\n    \n          for (; i < l; i++) {\n            item = cap[i];\n    \n            // Remove the list item's bullet\n            // so it is seen as the next token.\n            space = item.length;\n            item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n    \n            // Outdent whatever the\n            // list item contains. Hacky.\n            if (~item.indexOf('\\n ')) {\n              space -= item.length;\n              item = !this.options.pedantic\n                ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n                : item.replace(/^ {1,4}/gm, '');\n            }\n    \n            // Determine whether the next list item belongs here.\n            // Backpedal if it does not belong in this list.\n            if (this.options.smartLists && i !== l - 1) {\n              b = block.bullet.exec(cap[i + 1])[0];\n              if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n                src = cap.slice(i + 1).join('\\n') + src;\n                i = l - 1;\n              }\n            }\n    \n            // Determine whether item is loose or not.\n            // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n            // for discount behavior.\n            loose = next || /\\n\\n(?!\\s*$)/.test(item);\n            if (i !== l - 1) {\n              next = item.charAt(item.length - 1) === '\\n';\n              if (!loose) loose = next;\n            }\n    \n            // Check for task list items\n            istask = /^\\[[ xX]\\] /.test(item);\n            ischecked = undefined;\n            if (istask) {\n              ischecked = item[1] !== ' ';\n              item = item.replace(/^\\[[ xX]\\] +/, '');\n            }\n    \n            this.tokens.push({\n              type: loose\n                ? 'loose_item_start'\n                : 'list_item_start',\n              task: istask,\n              checked: ischecked\n            });\n    \n            // Recurse.\n            this.token(item, false);\n    \n            this.tokens.push({\n              type: 'list_item_end'\n            });\n          }\n    \n          this.tokens.push({\n            type: 'list_end'\n          });\n    \n          continue;\n        }\n    \n        // html\n        if (cap = this.rules.html.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: this.options.sanitize\n              ? 'paragraph'\n              : 'html',\n            pre: !this.options.sanitizer\n              && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n            text: cap[0]\n          });\n          continue;\n        }\n    \n        // def\n        if (top && (cap = this.rules.def.exec(src))) {\n          src = src.substring(cap[0].length);\n          if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n          tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n          if (!this.tokens.links[tag]) {\n            this.tokens.links[tag] = {\n              href: cap[2],\n              title: cap[3]\n            };\n          }\n          continue;\n        }\n    \n        // table (gfm)\n        if (top && (cap = this.rules.table.exec(src))) {\n          item = {\n            type: 'table',\n            header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n            align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n            cells: cap[3] ? cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n') : []\n          };\n    \n          if (item.header.length === item.align.length) {\n            src = src.substring(cap[0].length);\n    \n            for (i = 0; i < item.align.length; i++) {\n              if (/^ *-+: *$/.test(item.align[i])) {\n                item.align[i] = 'right';\n              } else if (/^ *:-+: *$/.test(item.align[i])) {\n                item.align[i] = 'center';\n              } else if (/^ *:-+ *$/.test(item.align[i])) {\n                item.align[i] = 'left';\n              } else {\n                item.align[i] = null;\n              }\n            }\n    \n            for (i = 0; i < item.cells.length; i++) {\n              item.cells[i] = splitCells(\n                item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n                item.header.length);\n            }\n    \n            this.tokens.push(item);\n    \n            continue;\n          }\n        }\n    \n        // lheading\n        if (cap = this.rules.lheading.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'heading',\n            depth: cap[2] === '=' ? 1 : 2,\n            text: cap[1]\n          });\n          continue;\n        }\n    \n        // top-level paragraph\n        if (top && (cap = this.rules.paragraph.exec(src))) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'paragraph',\n            text: cap[1].charAt(cap[1].length - 1) === '\\n'\n              ? cap[1].slice(0, -1)\n              : cap[1]\n          });\n          continue;\n        }\n    \n        // text\n        if (cap = this.rules.text.exec(src)) {\n          // Top-level should never reach here.\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'text',\n            text: cap[0]\n          });\n          continue;\n        }\n    \n        if (src) {\n          throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n        }\n      }\n    \n      return this.tokens;\n    };\n    \n    /**\n     * Inline-Level Grammar\n     */\n    \n    var inline = {\n      escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n      autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n      url: noop,\n      tag: '^comment'\n        + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n        + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n        + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n        + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n        + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>', // CDATA section\n      link: /^!?\\[(label)\\]\\(href(?:\\s+(title))?\\s*\\)/,\n      reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n      nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n      strong: /^__([^\\s][\\s\\S]*?[^\\s])__(?!_)|^\\*\\*([^\\s][\\s\\S]*?[^\\s])\\*\\*(?!\\*)|^__([^\\s])__(?!_)|^\\*\\*([^\\s])\\*\\*(?!\\*)/,\n      em: /^_([^\\s][\\s\\S]*?[^\\s_])_(?!_)|^_([^\\s_][\\s\\S]*?[^\\s])_(?!_)|^\\*([^\\s][\\s\\S]*?[^\\s*])\\*(?!\\*)|^\\*([^\\s*][\\s\\S]*?[^\\s])\\*(?!\\*)|^_([^\\s_])_(?!_)|^\\*([^\\s*])\\*(?!\\*)/,\n      code: /^(`+)\\s*([\\s\\S]*?[^`]?)\\s*\\1(?!`)/,\n      inlinelatex: /^(\\${1,2}) *((?:[^\\\\$]|\\\\\\S)+?) *\\1(?!\\$)/,\n      br: /^ {2,}\\n(?!\\s*$)/,\n      del: noop,\n      text: /^[\\s\\S]+?(?=[\\\\<!\\[`*$]|\\b_| {2,}\\n|$)/\n    };\n    \n    inline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n    \n    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n    inline.autolink = edit(inline.autolink)\n      .replace('scheme', inline._scheme)\n      .replace('email', inline._email)\n      .getRegex();\n    \n    inline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n    \n    inline.tag = edit(inline.tag)\n      .replace('comment', block._comment)\n      .replace('attribute', inline._attribute)\n      .getRegex();\n    \n    inline._label = /(?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]?|`[^`]*`|[^\\[\\]\\\\])*?/;\n    inline._href = /\\s*(<(?:\\\\[<>]?|[^\\s<>\\\\])*>|(?:\\\\[()]?|\\([^\\s\\x00-\\x1f()\\\\]*\\)|[^\\s\\x00-\\x1f()\\\\])*?)/;\n    inline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n    \n    inline.link = edit(inline.link)\n      .replace('label', inline._label)\n      .replace('href', inline._href)\n      .replace('title', inline._title)\n      .getRegex();\n    \n    inline.reflink = edit(inline.reflink)\n      .replace('label', inline._label)\n      .getRegex();\n    \n    /**\n     * Normal Inline Grammar\n     */\n    \n    inline.normal = merge({}, inline);\n    \n    /**\n     * Pedantic Inline Grammar\n     */\n    \n    inline.pedantic = merge({}, inline.normal, {\n      strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/,\n      link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', inline._label)\n        .getRegex(),\n      reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', inline._label)\n        .getRegex()\n    });\n    \n    /**\n     * GFM Inline Grammar\n     */\n    \n    inline.gfm = merge({}, inline.normal, {\n      escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n      url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/)\n        .replace('email', inline._email)\n        .getRegex(),\n      _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n      del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n      text: edit(inline.text)\n        .replace(']|', '~]|')\n        .replace('|', '|https?://|ftp://|www\\\\.|[a-zA-Z0-9.!#$%&\\'*+/=?^_`{\\\\|}~-]+@|')\n        .getRegex()\n    });\n    \n    /**\n     * GFM + Line Breaks Inline Grammar\n     */\n    \n    inline.breaks = merge({}, inline.gfm, {\n      br: edit(inline.br).replace('{2,}', '*').getRegex(),\n      text: edit(inline.gfm.text).replace('{2,}', '*').getRegex()\n    });\n    \n    /**\n     * Inline Lexer & Compiler\n     */\n    \n    function InlineLexer(links, options) {\n      this.options = options || marked.defaults;\n      this.links = links;\n      this.rules = inline.normal;\n      this.renderer = this.options.renderer || new Renderer();\n      this.renderer.latex = this.renderer.latex || Renderer.prototype.latex\n      this.renderer.options = this.options;\n    \n      if (!this.links) {\n        throw new Error('Tokens array requires a `links` property.');\n      }\n    \n      if (this.options.pedantic) {\n        this.rules = inline.pedantic;\n      } else if (this.options.gfm) {\n        if (this.options.breaks) {\n          this.rules = inline.breaks;\n        } else {\n          this.rules = inline.gfm;\n        }\n      }\n    }\n    \n    /**\n     * Expose Inline Rules\n     */\n    \n    InlineLexer.rules = inline;\n    \n    /**\n     * Static Lexing/Compiling Method\n     */\n    \n    InlineLexer.output = function(src, links, options) {\n      var inline = new InlineLexer(links, options);\n      return inline.output(src);\n    };\n    \n    /**\n     * Lexing/Compiling\n     */\n    \n    InlineLexer.prototype.output = function(src) {\n      var out = '',\n          link,\n          text,\n          href,\n          title,\n          cap;\n    \n      while (src) {\n        // escape\n        if (cap = this.rules.escape.exec(src)) {\n          src = src.substring(cap[0].length);\n          out += cap[1];\n          continue;\n        }\n    \n        // autolink\n        if (cap = this.rules.autolink.exec(src)) {\n          src = src.substring(cap[0].length);\n          if (cap[2] === '@') {\n            text = escape(this.mangle(cap[1]));\n            href = 'mailto:' + text;\n          } else {\n            text = escape(cap[1]);\n            href = text;\n          }\n          out += this.renderer.link(href, null, text);\n          continue;\n        }\n    \n        // url (gfm)\n        if (!this.inLink && (cap = this.rules.url.exec(src))) {\n          cap[0] = this.rules._backpedal.exec(cap[0])[0];\n          src = src.substring(cap[0].length);\n          if (cap[2] === '@') {\n            text = escape(cap[0]);\n            href = 'mailto:' + text;\n          } else {\n            text = escape(cap[0]);\n            if (cap[1] === 'www.') {\n              href = 'http://' + text;\n            } else {\n              href = text;\n            }\n          }\n          out += this.renderer.link(href, null, text);\n          continue;\n        }\n    \n        // tag\n        if (cap = this.rules.tag.exec(src)) {\n          if (!this.inLink && /^<a /i.test(cap[0])) {\n            this.inLink = true;\n          } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n            this.inLink = false;\n          }\n          src = src.substring(cap[0].length);\n          out += this.options.sanitize\n            ? this.options.sanitizer\n              ? this.options.sanitizer(cap[0])\n              : escape(cap[0])\n            : cap[0]\n          continue;\n        }\n    \n        // link\n        if (cap = this.rules.link.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.inLink = true;\n          href = cap[2];\n          if (this.options.pedantic) {\n            link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n    \n            if (link) {\n              href = link[1];\n              title = link[3];\n            } else {\n              title = '';\n            }\n          } else {\n            title = cap[3] ? cap[3].slice(1, -1) : '';\n          }\n          href = href.trim().replace(/^<([\\s\\S]*)>$/, '$1');\n          out += this.outputLink(cap, {\n            href: InlineLexer.escapes(href),\n            title: InlineLexer.escapes(title)\n          });\n          this.inLink = false;\n          continue;\n        }\n    \n        // reflink, nolink\n        if ((cap = this.rules.reflink.exec(src))\n            || (cap = this.rules.nolink.exec(src))) {\n          src = src.substring(cap[0].length);\n          link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n          link = this.links[link.toLowerCase()];\n          if (!link || !link.href) {\n            out += cap[0].charAt(0);\n            src = cap[0].substring(1) + src;\n            continue;\n          }\n          this.inLink = true;\n          out += this.outputLink(cap, link);\n          this.inLink = false;\n          continue;\n        }\n    \n        // strong\n        if (cap = this.rules.strong.exec(src)) {\n          src = src.substring(cap[0].length);\n          out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));\n          continue;\n        }\n    \n        // em\n        if (cap = this.rules.em.exec(src)) {\n          src = src.substring(cap[0].length);\n          out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));\n          continue;\n        }\n    \n        // code\n        if (cap = this.rules.code.exec(src)) {\n          src = src.substring(cap[0].length);\n          out += this.renderer.codespan(escape(cap[2].trim(), true));\n          continue;\n        }\n    \n        // latex\n        if (cap = this.rules.inlinelatex.exec(src)) {\n          src = src.substring(cap[0].length);\n          out += this.renderer.latex(cap[2], '$$'===cap[1])\n          continue;\n        }\n    \n        // br\n        if (cap = this.rules.br.exec(src)) {\n          src = src.substring(cap[0].length);\n          out += this.renderer.br();\n          continue;\n        }\n    \n        // del (gfm)\n        if (cap = this.rules.del.exec(src)) {\n          src = src.substring(cap[0].length);\n          out += this.renderer.del(this.output(cap[1]));\n          continue;\n        }\n    \n        // text\n        if (cap = this.rules.text.exec(src)) {\n          src = src.substring(cap[0].length);\n          out += this.renderer.text(escape(this.smartypants(cap[0])));\n          continue;\n        }\n    \n        if (src) {\n          throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n        }\n      }\n    \n      return out;\n    };\n    \n    InlineLexer.escapes = function(text) {\n      return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;\n    }\n    \n    /**\n     * Compile Link\n     */\n    \n    InlineLexer.prototype.outputLink = function(cap, link) {\n      var href = link.href,\n          title = link.title ? escape(link.title) : null;\n    \n      return cap[0].charAt(0) !== '!'\n        ? this.renderer.link(href, title, this.output(cap[1]))\n        : this.renderer.image(href, title, escape(cap[1]));\n    };\n    \n    /**\n     * Smartypants Transformations\n     */\n    \n    InlineLexer.prototype.smartypants = function(text) {\n      if (!this.options.smartypants) return text;\n      return text\n        // em-dashes\n        .replace(/---/g, '\\u2014')\n        // en-dashes\n        .replace(/--/g, '\\u2013')\n        // opening singles\n        .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n        // closing singles & apostrophes\n        .replace(/'/g, '\\u2019')\n        // opening doubles\n        .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n        // closing doubles\n        .replace(/\"/g, '\\u201d')\n        // ellipses\n        .replace(/\\.{3}/g, '\\u2026');\n    };\n    \n    /**\n     * Mangle Links\n     */\n    \n    InlineLexer.prototype.mangle = function(text) {\n      if (!this.options.mangle) return text;\n      var out = '',\n          l = text.length,\n          i = 0,\n          ch;\n    \n      for (; i < l; i++) {\n        ch = text.charCodeAt(i);\n        if (Math.random() > 0.5) {\n          ch = 'x' + ch.toString(16);\n        }\n        out += '&#' + ch + ';';\n      }\n    \n      return out;\n    };\n    \n    /**\n     * Renderer\n     */\n    \n    function Renderer(options) {\n      this.options = options || marked.defaults;\n    }\n    \n    Renderer.prototype.code = function(code, lang, escaped) {\n      if (this.options.highlight) {\n        var out = this.options.highlight(code, lang);\n        if (out != null && out !== code) {\n          escaped = true;\n          code = out;\n        }\n      }\n    \n      if (!lang) {\n        return '<pre><code>'\n          + (escaped ? code : escape(code, true))\n          + '</code></pre>';\n      }\n    \n      return '<pre><code class=\"'\n        + this.options.langPrefix\n        + escape(lang, true)\n        + '\">'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n';\n    };\n    \n    Renderer.prototype.blockquote = function(quote) {\n      return '<blockquote>\\n' + quote + '</blockquote>\\n';\n    };\n    \n    Renderer.prototype.html = function(html) {\n      return html;\n    };\n    \n    Renderer.prototype.latex = function(text, block=false) {\n      var out;\n      try {\n        if (marked.defaults.latexRender) {\n          var html = marked.defaults.latexRender(text);\n          if (block) {\n            out = '<div style=\"text-align:center; maring:10px;padding:10px;\">' + html + '</div>';\n          }else{\n            out = html;\n          }\n        } else {\n          console.log('No latexRender');\n        }\n      } catch (e) {\n        console.info('Failed to render latex: \"' + text + '\"');\n        out = '$$' + escape(text) + '$$';\n      }\n      return out;\n    };\n    \n    Renderer.prototype.heading = function(text, level, raw) {\n      if (this.options.headerIds) {\n        return '<h'\n          + level\n          + ' id=\"'\n          + this.options.headerPrefix\n          + raw.toLowerCase().replace(/[^\\w]+/g, '-')\n          + '\">'\n          + text\n          + '</h'\n          + level\n          + '>\\n';\n      }\n      // ignore IDs\n      return '<h' + level + '>' + text + '</h' + level + '>\\n';\n    };\n    \n    Renderer.prototype.hr = function() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n    \n    Renderer.prototype.list = function(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n          startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    };\n    \n    Renderer.prototype.listitem = function(text) {\n      return '<li>' + text + '</li>\\n';\n    };\n    \n    Renderer.prototype.checkbox = function(checked) {\n      return '<input '\n        + (checked ? 'checked=\"\" ' : '')\n        + 'disabled=\"\" type=\"checkbox\"'\n        + (this.options.xhtml ? ' /' : '')\n        + '> ';\n    }\n    \n    Renderer.prototype.paragraph = function(text) {\n      return '<p>' + text + '</p>\\n';\n    };\n    \n    Renderer.prototype.table = function(header, body) {\n      if (body) body = '<tbody>' + body + '</tbody>';\n    \n      return '<table>\\n'\n        + '<thead>\\n'\n        + header\n        + '</thead>\\n'\n        + body\n        + '</table>\\n';\n    };\n    \n    Renderer.prototype.tablerow = function(content) {\n      return '<tr>\\n' + content + '</tr>\\n';\n    };\n    \n    Renderer.prototype.tablecell = function(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align\n        ? '<' + type + ' align=\"' + flags.align + '\">'\n        : '<' + type + '>';\n      return tag + content + '</' + type + '>\\n';\n    };\n    \n    // span level renderer\n    Renderer.prototype.strong = function(text) {\n      return '<strong>' + text + '</strong>';\n    };\n    \n    Renderer.prototype.em = function(text) {\n      return '<em>' + text + '</em>';\n    };\n    \n    Renderer.prototype.codespan = function(text) {\n      return '<code>' + text + '</code>';\n    };\n    \n    Renderer.prototype.br = function() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    };\n    \n    Renderer.prototype.del = function(text) {\n      return '<del>' + text + '</del>';\n    };\n    \n    Renderer.prototype.link = function(href, title, text) {\n      if (this.options.sanitize) {\n        try {\n          var prot = decodeURIComponent(unescape(href))\n            .replace(/[^\\w:]/g, '')\n            .toLowerCase();\n        } catch (e) {\n          return text;\n        }\n        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n          return text;\n        }\n      }\n      if (this.options.baseUrl && !originIndependentUrl.test(href)) {\n        href = resolveUrl(this.options.baseUrl, href);\n      }\n      try {\n        href = encodeURI(href).replace(/%25/g, '%');\n      } catch (e) {\n        return text;\n      }\n      var out = '<a href=\"' + escape(href) + '\"';\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n      out += '>' + text + '</a>';\n      return out;\n    };\n    \n    Renderer.prototype.image = function(href, title, text) {\n      if (this.options.baseUrl && !originIndependentUrl.test(href)) {\n        href = resolveUrl(this.options.baseUrl, href);\n      }\n      var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n    \n    Renderer.prototype.text = function(text) {\n      return text;\n    };\n    \n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */\n    \n    function TextRenderer() {}\n    \n    // no need for block level renderers\n    \n    TextRenderer.prototype.strong =\n    TextRenderer.prototype.em =\n    TextRenderer.prototype.codespan =\n    TextRenderer.prototype.del =\n    TextRenderer.prototype.text = function (text) {\n      return text;\n    }\n    \n    TextRenderer.prototype.link =\n    TextRenderer.prototype.image = function(href, title, text) {\n      return '' + text;\n    }\n    \n    TextRenderer.prototype.br = function() {\n      return '';\n    }\n    \n    /**\n     * Parsing & Compiling\n     */\n    \n    function Parser(options) {\n      this.tokens = [];\n      this.token = null;\n      this.options = options || marked.defaults;\n      this.options.renderer = this.options.renderer || new Renderer();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n    }\n    \n    /**\n     * Static Parse Method\n     */\n    \n    Parser.parse = function(src, options) {\n      var parser = new Parser(options);\n      return parser.parse(src);\n    };\n    \n    /**\n     * Parse Loop\n     */\n    \n    Parser.prototype.parse = function(src) {\n      this.inline = new InlineLexer(src.links, this.options);\n      // use an InlineLexer with a TextRenderer to extract pure text\n      this.inlineText = new InlineLexer(\n        src.links,\n        merge({}, this.options, {renderer: new TextRenderer()})\n      );\n      this.tokens = src.reverse();\n    \n      var out = '';\n      while (this.next()) {\n        out += this.tok();\n      }\n    \n      return out;\n    };\n    \n    /**\n     * Next Token\n     */\n    \n    Parser.prototype.next = function() {\n      return this.token = this.tokens.pop();\n    };\n    \n    /**\n     * Preview Next Token\n     */\n    \n    Parser.prototype.peek = function() {\n      return this.tokens[this.tokens.length - 1] || 0;\n    };\n    \n    /**\n     * Parse Text Tokens\n     */\n    \n    Parser.prototype.parseText = function() {\n      var body = this.token.text;\n    \n      while (this.peek().type === 'text') {\n        body += '\\n' + this.next().text;\n      }\n    \n      return this.inline.output(body);\n    };\n    \n    /**\n     * Parse Current Token\n     */\n    \n    Parser.prototype.tok = function() {\n      switch (this.token.type) {\n        case 'space': {\n          return '';\n        }\n        case 'hr': {\n          return this.renderer.hr();\n        }\n        case 'heading': {\n          return this.renderer.heading(\n            this.inline.output(this.token.text),\n            this.token.depth,\n            unescape(this.inlineText.output(this.token.text)));\n        }\n        case 'blocklatex': {\n          return this.renderer.latex(this.token.text, true)\n        }\n        case 'code': {\n          return this.renderer.code(this.token.text,\n            this.token.lang,\n            this.token.escaped);\n        }\n        case 'table': {\n          var header = '',\n              body = '',\n              i,\n              row,\n              cell,\n              j;\n    \n          // header\n          cell = '';\n          for (i = 0; i < this.token.header.length; i++) {\n            cell += this.renderer.tablecell(\n              this.inline.output(this.token.header[i]),\n              { header: true, align: this.token.align[i] }\n            );\n          }\n          header += this.renderer.tablerow(cell);\n    \n          for (i = 0; i < this.token.cells.length; i++) {\n            row = this.token.cells[i];\n    \n            cell = '';\n            for (j = 0; j < row.length; j++) {\n              cell += this.renderer.tablecell(\n                this.inline.output(row[j]),\n                { header: false, align: this.token.align[j] }\n              );\n            }\n    \n            body += this.renderer.tablerow(cell);\n          }\n          return this.renderer.table(header, body);\n        }\n        case 'blockquote_start': {\n          body = '';\n    \n          while (this.next().type !== 'blockquote_end') {\n            body += this.tok();\n          }\n    \n          return this.renderer.blockquote(body);\n        }\n        case 'list_start': {\n          body = '';\n          var ordered = this.token.ordered,\n              start = this.token.start;\n    \n          while (this.next().type !== 'list_end') {\n            body += this.tok();\n          }\n    \n          return this.renderer.list(body, ordered, start);\n        }\n        case 'list_item_start': {\n          body = '';\n    \n          if (this.token.task) {\n            body += this.renderer.checkbox(this.token.checked);\n          }\n    \n          while (this.next().type !== 'list_item_end') {\n            body += this.token.type === 'text'\n              ? this.parseText()\n              : this.tok();\n          }\n    \n          return this.renderer.listitem(body);\n        }\n        case 'loose_item_start': {\n          body = '';\n    \n          while (this.next().type !== 'list_item_end') {\n            body += this.tok();\n          }\n    \n          return this.renderer.listitem(body);\n        }\n        case 'html': {\n          // TODO parse inline content if parameter markdown=1\n          return this.renderer.html(this.token.text);\n        }\n        case 'paragraph': {\n          return this.renderer.paragraph(this.inline.output(this.token.text));\n        }\n        case 'text': {\n          return this.renderer.paragraph(this.parseText());\n        }\n      }\n    };\n    \n    /**\n     * Helpers\n     */\n    \n    function escape(html, encode) {\n      return html\n        .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n    }\n    \n    function unescape(html) {\n      // explicitly match decimal, hex, and named HTML entities\n      return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig, function(_, n) {\n        n = n.toLowerCase();\n        if (n === 'colon') return ':';\n        if (n.charAt(0) === '#') {\n          return n.charAt(1) === 'x'\n            ? String.fromCharCode(parseInt(n.substring(2), 16))\n            : String.fromCharCode(+n.substring(1));\n        }\n        return '';\n      });\n    }\n    \n    function edit(regex, opt) {\n      regex = regex.source || regex;\n      opt = opt || '';\n      return {\n        replace: function(name, val) {\n          val = val.source || val;\n          val = val.replace(/(^|[^\\[])\\^/g, '$1');\n          regex = regex.replace(name, val);\n          return this;\n        },\n        getRegex: function() {\n          return new RegExp(regex, opt);\n        }\n      };\n    }\n    \n    function resolveUrl(base, href) {\n      if (!baseUrls[' ' + base]) {\n        // we can ignore everything in base after the last slash of its path component,\n        // but we might need to add _that_\n        // https://tools.ietf.org/html/rfc3986#section-3\n        if (/^[^:]+:\\/*[^/]*$/.test(base)) {\n          baseUrls[' ' + base] = base + '/';\n        } else {\n          baseUrls[' ' + base] = base.replace(/[^/]*$/, '');\n        }\n      }\n      base = baseUrls[' ' + base];\n    \n      if (href.slice(0, 2) === '//') {\n        return base.replace(/:[\\s\\S]*/, ':') + href;\n      } else if (href.charAt(0) === '/') {\n        return base.replace(/(:\\/*[^/]*)[\\s\\S]*/, '$1') + href;\n      } else {\n        return base + href;\n      }\n    }\n    var baseUrls = {};\n    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n    \n    function noop() {}\n    noop.exec = noop;\n    \n    function merge(obj) {\n      var i = 1,\n          target,\n          key;\n    \n      for (; i < arguments.length; i++) {\n        target = arguments[i];\n        for (key in target) {\n          if (Object.prototype.hasOwnProperty.call(target, key)) {\n            obj[key] = target[key];\n          }\n        }\n      }\n    \n      return obj;\n    }\n    \n    function splitCells(tableRow, count) {\n      var cells = tableRow.replace(/([^\\\\])\\|/g, '$1 |').split(/ +\\| */),\n          i = 0;\n    \n      if (cells.length > count) {\n        cells.splice(count);\n      } else {\n        while (cells.length < count) cells.push('');\n      }\n    \n      for (; i < cells.length; i++) {\n        cells[i] = cells[i].replace(/\\\\\\|/g, '|');\n      }\n      return cells;\n    }\n    \n    /**\n     * Marked\n     */\n    \n    function marked(src, opt, callback) {\n      // throw error in case of non string input\n      if (typeof src === 'undefined' || src === null) {\n        throw new Error('marked(): input parameter is undefined or null');\n      }\n      if (typeof src !== 'string') {\n        throw new Error('marked(): input parameter is of type '\n          + Object.prototype.toString.call(src) + ', string expected');\n      }\n    \n      if (callback || typeof opt === 'function') {\n        if (!callback) {\n          callback = opt;\n          opt = null;\n        }\n    \n        opt = merge({}, marked.defaults, opt || {});\n    \n        var highlight = opt.highlight,\n            tokens,\n            pending,\n            i = 0;\n    \n        try {\n          tokens = Lexer.lex(src, opt)\n        } catch (e) {\n          return callback(e);\n        }\n    \n        pending = tokens.length;\n    \n        var done = function(err) {\n          if (err) {\n            opt.highlight = highlight;\n            return callback(err);\n          }\n    \n          var out;\n    \n          try {\n            out = Parser.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n    \n          opt.highlight = highlight;\n    \n          return err\n            ? callback(err)\n            : callback(null, out);\n        };\n    \n        if (!highlight || highlight.length < 3) {\n          return done();\n        }\n    \n        delete opt.highlight;\n    \n        if (!pending) return done();\n    \n        for (; i < tokens.length; i++) {\n          (function(token) {\n            if (token.type !== 'code') {\n              return --pending || done();\n            }\n            return highlight(token.text, token.lang, function(err, code) {\n              if (err) return done(err);\n              if (code == null || code === token.text) {\n                return --pending || done();\n              }\n              token.text = code;\n              token.escaped = true;\n              --pending || done();\n            });\n          })(tokens[i]);\n        }\n    \n        return;\n      }\n      try {\n        if (opt) opt = merge({}, marked.defaults, opt);\n        return Parser.parse(Lexer.lex(src, opt), opt);\n      } catch (e) {\n        e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n        if ((opt || marked.defaults).silent) {\n          return '<p>An error occurred:</p><pre>'\n            + escape(e.message + '', true)\n            + '</pre>';\n        }\n        throw e;\n      }\n    }\n    \n    /**\n     * Options\n     */\n    \n    marked.options =\n    marked.setOptions = function(opt) {\n      merge(marked.defaults, opt);\n      return marked;\n    };\n    \n    marked.getDefaults = function () {\n      return {\n        baseUrl: null,\n        breaks: false,\n        gfm: true,\n        headerIds: true,\n        headerPrefix: '',\n        highlight: null,\n        langPrefix: 'language-',\n        mangle: true,\n        pedantic: false,\n        renderer: new Renderer(),\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartLists: false,\n        smartypants: false,\n        tables: true,\n        xhtml: false\n      };\n    }\n    \n    marked.defaults = marked.getDefaults();\n    \n    /**\n     * Expose\n     */\n    \n    marked.Parser = Parser;\n    marked.parser = Parser.parse;\n    \n    marked.Renderer = Renderer;\n    marked.TextRenderer = TextRenderer;\n    \n    marked.Lexer = Lexer;\n    marked.lexer = Lexer.lex;\n    \n    marked.InlineLexer = InlineLexer;\n    marked.inlineLexer = InlineLexer.output;\n    \n    marked.parse = marked;\n    \n    {\n      module.exports = marked;\n    }\n    })(commonjsGlobal || (typeof window !== 'undefined' ? window : commonjsGlobal));\n    });\n    \n    var prism = createCommonjsModule(function (module) {\n    /* **********************************************\n         Begin prism-core.js\n    ********************************************** */\n    \n    var _self = (typeof window !== 'undefined')\n        ? window   // if in browser\n        : (\n            (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n            ? self // if in worker\n            : {}   // if in node js\n        );\n    \n    /**\n     * Prism: Lightweight, robust, elegant syntax highlighting\n     * MIT license http://www.opensource.org/licenses/mit-license.php/\n     * @author Lea Verou http://lea.verou.me\n     */\n    \n    var Prism = (function(){\n    \n    // Private helper vars\n    var lang = /\\blang(?:uage)?-([\\w-]+)\\b/i;\n    var uniqueId = 0;\n    \n    var _ = _self.Prism = {\n        manual: _self.Prism && _self.Prism.manual,\n        disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n        util: {\n            encode: function (tokens) {\n                if (tokens instanceof Token) {\n                    return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\n                } else if (_.util.type(tokens) === 'Array') {\n                    return tokens.map(_.util.encode);\n                } else {\n                    return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n                }\n            },\n    \n            type: function (o) {\n                return Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n            },\n    \n            objId: function (obj) {\n                if (!obj['__id']) {\n                    Object.defineProperty(obj, '__id', { value: ++uniqueId });\n                }\n                return obj['__id'];\n            },\n    \n            // Deep clone a language definition (e.g. to extend it)\n            clone: function (o, visited) {\n                var type = _.util.type(o);\n                visited = visited || {};\n    \n                switch (type) {\n                    case 'Object':\n                        if (visited[_.util.objId(o)]) {\n                            return visited[_.util.objId(o)];\n                        }\n                        var clone = {};\n                        visited[_.util.objId(o)] = clone;\n    \n                        for (var key in o) {\n                            if (o.hasOwnProperty(key)) {\n                                clone[key] = _.util.clone(o[key], visited);\n                            }\n                        }\n    \n                        return clone;\n    \n                    case 'Array':\n                        if (visited[_.util.objId(o)]) {\n                            return visited[_.util.objId(o)];\n                        }\n                        var clone = [];\n                        visited[_.util.objId(o)] = clone;\n    \n                        o.forEach(function (v, i) {\n                            clone[i] = _.util.clone(v, visited);\n                        });\n    \n                        return clone;\n                }\n    \n                return o;\n            }\n        },\n    \n        languages: {\n            extend: function (id, redef) {\n                var lang = _.util.clone(_.languages[id]);\n    \n                for (var key in redef) {\n                    lang[key] = redef[key];\n                }\n    \n                return lang;\n            },\n    \n            /**\n             * Insert a token before another token in a language literal\n             * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n             * we cannot just provide an object, we need anobject and a key.\n             * @param inside The key (or language id) of the parent\n             * @param before The key to insert before. If not provided, the function appends instead.\n             * @param insert Object with the key/value pairs to insert\n             * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n             */\n            insertBefore: function (inside, before, insert, root) {\n                root = root || _.languages;\n                var grammar = root[inside];\n    \n                if (arguments.length == 2) {\n                    insert = arguments[1];\n    \n                    for (var newToken in insert) {\n                        if (insert.hasOwnProperty(newToken)) {\n                            grammar[newToken] = insert[newToken];\n                        }\n                    }\n    \n                    return grammar;\n                }\n    \n                var ret = {};\n    \n                for (var token in grammar) {\n    \n                    if (grammar.hasOwnProperty(token)) {\n    \n                        if (token == before) {\n    \n                            for (var newToken in insert) {\n    \n                                if (insert.hasOwnProperty(newToken)) {\n                                    ret[newToken] = insert[newToken];\n                                }\n                            }\n                        }\n    \n                        ret[token] = grammar[token];\n                    }\n                }\n    \n                // Update references in other language definitions\n                _.languages.DFS(_.languages, function(key, value) {\n                    if (value === root[inside] && key != inside) {\n                        this[key] = ret;\n                    }\n                });\n    \n                return root[inside] = ret;\n            },\n    \n            // Traverse a language definition with Depth First Search\n            DFS: function(o, callback, type, visited) {\n                visited = visited || {};\n                for (var i in o) {\n                    if (o.hasOwnProperty(i)) {\n                        callback.call(o, i, o[i], type || i);\n    \n                        if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\n                            visited[_.util.objId(o[i])] = true;\n                            _.languages.DFS(o[i], callback, null, visited);\n                        }\n                        else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\n                            visited[_.util.objId(o[i])] = true;\n                            _.languages.DFS(o[i], callback, i, visited);\n                        }\n                    }\n                }\n            }\n        },\n        plugins: {},\n    \n        highlightAll: function(async, callback) {\n            _.highlightAllUnder(document, async, callback);\n        },\n    \n        highlightAllUnder: function(container, async, callback) {\n            var env = {\n                callback: callback,\n                selector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n            };\n    \n            _.hooks.run(\"before-highlightall\", env);\n    \n            var elements = env.elements || container.querySelectorAll(env.selector);\n    \n            for (var i=0, element; element = elements[i++];) {\n                _.highlightElement(element, async === true, env.callback);\n            }\n        },\n    \n        highlightElement: function(element, async, callback) {\n            // Find language\n            var language, grammar, parent = element;\n    \n            while (parent && !lang.test(parent.className)) {\n                parent = parent.parentNode;\n            }\n    \n            if (parent) {\n                language = (parent.className.match(lang) || [,''])[1].toLowerCase();\n                grammar = _.languages[language];\n            }\n    \n            // Set language on the element, if not present\n            element.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n    \n            if (element.parentNode) {\n                // Set language on the parent, for styling\n                parent = element.parentNode;\n    \n                if (/pre/i.test(parent.nodeName)) {\n                    parent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n                }\n            }\n    \n            var code = element.textContent;\n    \n            var env = {\n                element: element,\n                language: language,\n                grammar: grammar,\n                code: code\n            };\n    \n            _.hooks.run('before-sanity-check', env);\n    \n            if (!env.code || !env.grammar) {\n                if (env.code) {\n                    _.hooks.run('before-highlight', env);\n                    env.element.textContent = env.code;\n                    _.hooks.run('after-highlight', env);\n                }\n                _.hooks.run('complete', env);\n                return;\n            }\n    \n            _.hooks.run('before-highlight', env);\n    \n            if (async && _self.Worker) {\n                var worker = new Worker(_.filename);\n    \n                worker.onmessage = function(evt) {\n                    env.highlightedCode = evt.data;\n    \n                    _.hooks.run('before-insert', env);\n    \n                    env.element.innerHTML = env.highlightedCode;\n    \n                    callback && callback.call(env.element);\n                    _.hooks.run('after-highlight', env);\n                    _.hooks.run('complete', env);\n                };\n    \n                worker.postMessage(JSON.stringify({\n                    language: env.language,\n                    code: env.code,\n                    immediateClose: true\n                }));\n            }\n            else {\n                env.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n    \n                _.hooks.run('before-insert', env);\n    \n                env.element.innerHTML = env.highlightedCode;\n    \n                callback && callback.call(element);\n    \n                _.hooks.run('after-highlight', env);\n                _.hooks.run('complete', env);\n            }\n        },\n    \n        highlight: function (text, grammar, language) {\n            var env = {\n                code: text,\n                grammar: grammar,\n                language: language\n            };\n            _.hooks.run('before-tokenize', env);\n            env.tokens = _.tokenize(env.code, env.grammar);\n            _.hooks.run('after-tokenize', env);\n            return Token.stringify(_.util.encode(env.tokens), env.language);\n        },\n    \n        matchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {\n            var Token = _.Token;\n    \n            for (var token in grammar) {\n                if(!grammar.hasOwnProperty(token) || !grammar[token]) {\n                    continue;\n                }\n    \n                if (token == target) {\n                    return;\n                }\n    \n                var patterns = grammar[token];\n                patterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];\n    \n                for (var j = 0; j < patterns.length; ++j) {\n                    var pattern = patterns[j],\n                        inside = pattern.inside,\n                        lookbehind = !!pattern.lookbehind,\n                        greedy = !!pattern.greedy,\n                        lookbehindLength = 0,\n                        alias = pattern.alias;\n    \n                    if (greedy && !pattern.pattern.global) {\n                        // Without the global flag, lastIndex won't work\n                        var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];\n                        pattern.pattern = RegExp(pattern.pattern.source, flags + \"g\");\n                    }\n    \n                    pattern = pattern.pattern || pattern;\n    \n                    // Don’t cache length as it changes during the loop\n                    for (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {\n    \n                        var str = strarr[i];\n    \n                        if (strarr.length > text.length) {\n                            // Something went terribly wrong, ABORT, ABORT!\n                            return;\n                        }\n    \n                        if (str instanceof Token) {\n                            continue;\n                        }\n    \n                        if (greedy && i != strarr.length - 1) {\n                            pattern.lastIndex = pos;\n                            var match = pattern.exec(text);\n                            if (!match) {\n                                break;\n                            }\n    \n                            var from = match.index + (lookbehind ? match[1].length : 0),\n                                to = match.index + match[0].length,\n                                k = i,\n                                p = pos;\n    \n                            for (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {\n                                p += strarr[k].length;\n                                // Move the index i to the element in strarr that is closest to from\n                                if (from >= p) {\n                                    ++i;\n                                    pos = p;\n                                }\n                            }\n    \n                            // If strarr[i] is a Token, then the match starts inside another Token, which is invalid\n                            if (strarr[i] instanceof Token) {\n                                continue;\n                            }\n    \n                            // Number of tokens to delete and replace with the new match\n                            delNum = k - i;\n                            str = text.slice(pos, p);\n                            match.index -= pos;\n                        } else {\n                            pattern.lastIndex = 0;\n    \n                            var match = pattern.exec(str),\n                                delNum = 1;\n                        }\n    \n                        if (!match) {\n                            if (oneshot) {\n                                break;\n                            }\n    \n                            continue;\n                        }\n    \n                        if(lookbehind) {\n                            lookbehindLength = match[1] ? match[1].length : 0;\n                        }\n    \n                        var from = match.index + lookbehindLength,\n                            match = match[0].slice(lookbehindLength),\n                            to = from + match.length,\n                            before = str.slice(0, from),\n                            after = str.slice(to);\n    \n                        var args = [i, delNum];\n    \n                        if (before) {\n                            ++i;\n                            pos += before.length;\n                            args.push(before);\n                        }\n    \n                        var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);\n    \n                        args.push(wrapped);\n    \n                        if (after) {\n                            args.push(after);\n                        }\n    \n                        Array.prototype.splice.apply(strarr, args);\n    \n                        if (delNum != 1)\n                            { _.matchGrammar(text, strarr, grammar, i, pos, true, token); }\n    \n                        if (oneshot)\n                            { break; }\n                    }\n                }\n            }\n        },\n    \n        tokenize: function(text, grammar, language) {\n            var strarr = [text];\n    \n            var rest = grammar.rest;\n    \n            if (rest) {\n                for (var token in rest) {\n                    grammar[token] = rest[token];\n                }\n    \n                delete grammar.rest;\n            }\n    \n            _.matchGrammar(text, strarr, grammar, 0, 0, false);\n    \n            return strarr;\n        },\n    \n        hooks: {\n            all: {},\n    \n            add: function (name, callback) {\n                var hooks = _.hooks.all;\n    \n                hooks[name] = hooks[name] || [];\n    \n                hooks[name].push(callback);\n            },\n    \n            run: function (name, env) {\n                var callbacks = _.hooks.all[name];\n    \n                if (!callbacks || !callbacks.length) {\n                    return;\n                }\n    \n                for (var i=0, callback; callback = callbacks[i++];) {\n                    callback(env);\n                }\n            }\n        }\n    };\n    \n    var Token = _.Token = function(type, content, alias, matchedStr, greedy) {\n        this.type = type;\n        this.content = content;\n        this.alias = alias;\n        // Copy of the full string this token was created from\n        this.length = (matchedStr || \"\").length|0;\n        this.greedy = !!greedy;\n    };\n    \n    Token.stringify = function(o, language, parent) {\n        if (typeof o == 'string') {\n            return o;\n        }\n    \n        if (_.util.type(o) === 'Array') {\n            return o.map(function(element) {\n                return Token.stringify(element, language, o);\n            }).join('');\n        }\n    \n        var env = {\n            type: o.type,\n            content: Token.stringify(o.content, language, parent),\n            tag: 'span',\n            classes: ['token', o.type],\n            attributes: {},\n            language: language,\n            parent: parent\n        };\n    \n        if (o.alias) {\n            var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n            Array.prototype.push.apply(env.classes, aliases);\n        }\n    \n        _.hooks.run('wrap', env);\n    \n        var attributes = Object.keys(env.attributes).map(function(name) {\n            return name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n        }).join(' ');\n    \n        return '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';\n    \n    };\n    \n    if (!_self.document) {\n        if (!_self.addEventListener) {\n            // in Node.js\n            return _self.Prism;\n        }\n    \n        if (!_.disableWorkerMessageHandler) {\n            // In worker\n            _self.addEventListener('message', function (evt) {\n                var message = JSON.parse(evt.data),\n                    lang = message.language,\n                    code = message.code,\n                    immediateClose = message.immediateClose;\n    \n                _self.postMessage(_.highlight(code, _.languages[lang], lang));\n                if (immediateClose) {\n                    _self.close();\n                }\n            }, false);\n        }\n    \n        return _self.Prism;\n    }\n    \n    //Get current script and highlight\n    var script = document.currentScript || [].slice.call(document.getElementsByTagName(\"script\")).pop();\n    \n    if (script) {\n        _.filename = script.src;\n    \n        if (!_.manual && !script.hasAttribute('data-manual')) {\n            if(document.readyState !== \"loading\") {\n                if (window.requestAnimationFrame) {\n                    window.requestAnimationFrame(_.highlightAll);\n                } else {\n                    window.setTimeout(_.highlightAll, 16);\n                }\n            }\n            else {\n                document.addEventListener('DOMContentLoaded', _.highlightAll);\n            }\n        }\n    }\n    \n    return _self.Prism;\n    \n    })();\n    \n    if ('object' !== 'undefined' && module.exports) {\n        module.exports = Prism;\n    }\n    \n    // hack for components to work correctly in node.js\n    if (typeof commonjsGlobal !== 'undefined') {\n        commonjsGlobal.Prism = Prism;\n    }\n    \n    \n    /* **********************************************\n         Begin prism-markup.js\n    ********************************************** */\n    \n    Prism.languages.markup = {\n        'comment': /<!--[\\s\\S]*?-->/,\n        'prolog': /<\\?[\\s\\S]+?\\?>/,\n        'doctype': /<!DOCTYPE[\\s\\S]+?>/i,\n        'cdata': /<!\\[CDATA\\[[\\s\\S]*?]]>/i,\n        'tag': {\n            pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,\n            greedy: true,\n            inside: {\n                'tag': {\n                    pattern: /^<\\/?[^\\s>\\/]+/i,\n                    inside: {\n                        'punctuation': /^<\\/?/,\n                        'namespace': /^[^\\s>\\/:]+:/\n                    }\n                },\n                'attr-value': {\n                    pattern: /=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i,\n                    inside: {\n                        'punctuation': [\n                            /^=/,\n                            {\n                                pattern: /(^|[^\\\\])[\"']/,\n                                lookbehind: true\n                            }\n                        ]\n                    }\n                },\n                'punctuation': /\\/?>/,\n                'attr-name': {\n                    pattern: /[^\\s>\\/]+/,\n                    inside: {\n                        'namespace': /^[^\\s>\\/:]+:/\n                    }\n                }\n    \n            }\n        },\n        'entity': /&#?[\\da-z]{1,8};/i\n    };\n    \n    Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n        Prism.languages.markup['entity'];\n    \n    // Plugin to make entity title show the real entity, idea by Roman Komarov\n    Prism.hooks.add('wrap', function(env) {\n    \n        if (env.type === 'entity') {\n            env.attributes['title'] = env.content.replace(/&amp;/, '&');\n        }\n    });\n    \n    Prism.languages.xml = Prism.languages.markup;\n    Prism.languages.html = Prism.languages.markup;\n    Prism.languages.mathml = Prism.languages.markup;\n    Prism.languages.svg = Prism.languages.markup;\n    \n    \n    /* **********************************************\n         Begin prism-css.js\n    ********************************************** */\n    \n    Prism.languages.css = {\n        'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n        'atrule': {\n            pattern: /@[\\w-]+?.*?(?:;|(?=\\s*\\{))/i,\n            inside: {\n                'rule': /@[\\w-]+/\n                // See rest below\n            }\n        },\n        'url': /url\\((?:([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1|.*?)\\)/i,\n        'selector': /[^{}\\s][^{};]*?(?=\\s*\\{)/,\n        'string': {\n            pattern: /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n            greedy: true\n        },\n        'property': /[-_a-z\\xA0-\\uFFFF][-\\w\\xA0-\\uFFFF]*(?=\\s*:)/i,\n        'important': /\\B!important\\b/i,\n        'function': /[-a-z0-9]+(?=\\()/i,\n        'punctuation': /[(){};:]/\n    };\n    \n    Prism.languages.css['atrule'].inside.rest = Prism.languages.css;\n    \n    if (Prism.languages.markup) {\n        Prism.languages.insertBefore('markup', 'tag', {\n            'style': {\n                pattern: /(<style[\\s\\S]*?>)[\\s\\S]*?(?=<\\/style>)/i,\n                lookbehind: true,\n                inside: Prism.languages.css,\n                alias: 'language-css',\n                greedy: true\n            }\n        });\n    \n        Prism.languages.insertBefore('inside', 'attr-value', {\n            'style-attr': {\n                pattern: /\\s*style=(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1/i,\n                inside: {\n                    'attr-name': {\n                        pattern: /^\\s*style/i,\n                        inside: Prism.languages.markup.tag.inside\n                    },\n                    'punctuation': /^\\s*=\\s*['\"]|['\"]\\s*$/,\n                    'attr-value': {\n                        pattern: /.+/i,\n                        inside: Prism.languages.css\n                    }\n                },\n                alias: 'language-css'\n            }\n        }, Prism.languages.markup.tag);\n    }\n    \n    /* **********************************************\n         Begin prism-clike.js\n    ********************************************** */\n    \n    Prism.languages.clike = {\n        'comment': [\n            {\n                pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n                lookbehind: true\n            },\n            {\n                pattern: /(^|[^\\\\:])\\/\\/.*/,\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        'string': {\n            pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n            greedy: true\n        },\n        'class-name': {\n            pattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[\\w.\\\\]+/i,\n            lookbehind: true,\n            inside: {\n                punctuation: /[.\\\\]/\n            }\n        },\n        'keyword': /\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n        'boolean': /\\b(?:true|false)\\b/,\n        'function': /[a-z0-9_]+(?=\\()/i,\n        'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n        'operator': /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n        'punctuation': /[{}[\\];(),.:]/\n    };\n    \n    \n    /* **********************************************\n         Begin prism-javascript.js\n    ********************************************** */\n    \n    Prism.languages.javascript = Prism.languages.extend('clike', {\n        'keyword': /\\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,\n        'number': /\\b(?:0[xX][\\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:[Ee][+-]?\\d+)?/,\n        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n        'function': /[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*\\()/i,\n        'operator': /-[-=]?|\\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\\|[|=]?|\\*\\*?=?|\\/=?|~|\\^=?|%=?|\\?|\\.{3}/\n    });\n    \n    Prism.languages.insertBefore('javascript', 'keyword', {\n        'regex': {\n            pattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s])\\s*)\\/(\\[[^\\]\\r\\n]+]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})\\]]))/,\n            lookbehind: true,\n            greedy: true\n        },\n        // This must be declared before keyword because we use \"function\" inside the look-forward\n        'function-variable': {\n            pattern: /[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*=\\s*(?:function\\b|(?:\\([^()]*\\)|[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)\\s*=>))/i,\n            alias: 'function'\n        },\n        'constant': /\\b[A-Z][A-Z\\d_]*\\b/\n    });\n    \n    Prism.languages.insertBefore('javascript', 'string', {\n        'template-string': {\n            pattern: /`(?:\\\\[\\s\\S]|\\${[^}]+}|[^\\\\`])*`/,\n            greedy: true,\n            inside: {\n                'interpolation': {\n                    pattern: /\\${[^}]+}/,\n                    inside: {\n                        'interpolation-punctuation': {\n                            pattern: /^\\${|}$/,\n                            alias: 'punctuation'\n                        },\n                        rest: null // See below\n                    }\n                },\n                'string': /[\\s\\S]+/\n            }\n        }\n    });\n    Prism.languages.javascript['template-string'].inside['interpolation'].inside.rest = Prism.languages.javascript;\n    \n    if (Prism.languages.markup) {\n        Prism.languages.insertBefore('markup', 'tag', {\n            'script': {\n                pattern: /(<script[\\s\\S]*?>)[\\s\\S]*?(?=<\\/script>)/i,\n                lookbehind: true,\n                inside: Prism.languages.javascript,\n                alias: 'language-javascript',\n                greedy: true\n            }\n        });\n    }\n    \n    Prism.languages.js = Prism.languages.javascript;\n    \n    \n    /* **********************************************\n         Begin prism-file-highlight.js\n    ********************************************** */\n    \n    (function () {\n        if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {\n            return;\n        }\n    \n        self.Prism.fileHighlight = function() {\n    \n            var Extensions = {\n                'js': 'javascript',\n                'py': 'python',\n                'rb': 'ruby',\n                'ps1': 'powershell',\n                'psm1': 'powershell',\n                'sh': 'bash',\n                'bat': 'batch',\n                'h': 'c',\n                'tex': 'latex'\n            };\n    \n            Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {\n                var src = pre.getAttribute('data-src');\n    \n                var language, parent = pre;\n                var lang = /\\blang(?:uage)?-([\\w-]+)\\b/i;\n                while (parent && !lang.test(parent.className)) {\n                    parent = parent.parentNode;\n                }\n    \n                if (parent) {\n                    language = (pre.className.match(lang) || [, ''])[1];\n                }\n    \n                if (!language) {\n                    var extension = (src.match(/\\.(\\w+)$/) || [, ''])[1];\n                    language = Extensions[extension] || extension;\n                }\n    \n                var code = document.createElement('code');\n                code.className = 'language-' + language;\n    \n                pre.textContent = '';\n    \n                code.textContent = 'Loading…';\n    \n                pre.appendChild(code);\n    \n                var xhr = new XMLHttpRequest();\n    \n                xhr.open('GET', src, true);\n    \n                xhr.onreadystatechange = function () {\n                    if (xhr.readyState == 4) {\n    \n                        if (xhr.status < 400 && xhr.responseText) {\n                            code.textContent = xhr.responseText;\n    \n                            Prism.highlightElement(code);\n                        }\n                        else if (xhr.status >= 400) {\n                            code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;\n                        }\n                        else {\n                            code.textContent = '✖ Error: File does not exist or is empty';\n                        }\n                    }\n                };\n    \n                xhr.send(null);\n            });\n    \n            if (Prism.plugins.toolbar) {\n                Prism.plugins.toolbar.registerButton('download-file', function (env) {\n                    var pre = env.element.parentNode;\n                    if (!pre || !/pre/i.test(pre.nodeName) || !pre.hasAttribute('data-src') || !pre.hasAttribute('data-download-link')) {\n                        return;\n                    }\n                    var src = pre.getAttribute('data-src');\n                    var a = document.createElement('a');\n                    a.textContent = pre.getAttribute('data-download-link-label') || 'Download';\n                    a.setAttribute('download', '');\n                    a.href = src;\n                    return a;\n                });\n            }\n    \n        };\n    \n        document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);\n    \n    })();\n    });\n    \n    /**\n     * Gen toc tree\n     * @link https://github.com/killercup/grock/blob/5280ae63e16c5739e9233d9009bc235ed7d79a50/styles/solarized/assets/js/behavior.coffee#L54-L81\n     * @param  {Array} toc\n     * @param  {Number} maxLevel\n     * @return {Array}\n     */\n    function genTree(toc, maxLevel) {\n      var headlines = [];\n      var last = {};\n    \n      toc.forEach(function (headline) {\n        var level = headline.level || 1;\n        var len = level - 1;\n    \n        if (level > maxLevel) {\n          return\n        }\n        if (last[len]) {\n          last[len].children = (last[len].children || []).concat(headline);\n        } else {\n          headlines.push(headline);\n        }\n        last[level] = headline;\n      });\n    \n      return headlines\n    }\n    \n    var cache$1 = {};\n    var re = /[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g;\n    \n    function lower(string) {\n      return string.toLowerCase()\n    }\n    \n    function slugify(str) {\n      if (typeof str !== 'string') {\n        return ''\n      }\n    \n      var slug = str\n        .trim()\n        .replace(/[A-Z]+/g, lower)\n        .replace(/<[^>\\d]+>/g, '')\n        .replace(re, '')\n        .replace(/\\s/g, '-')\n        .replace(/-+/g, '-')\n        .replace(/^(\\d)/, '_$1');\n      var count = cache$1[slug];\n    \n      count = hasOwn.call(cache$1, slug) ? count + 1 : 0;\n      cache$1[slug] = count;\n    \n      if (count) {\n        slug = slug + '-' + count;\n      }\n    \n      return slug\n    }\n    \n    slugify.clear = function () {\n      cache$1 = {};\n    };\n    \n    function replace(m, $1) {\n      return '<img class=\"emoji\" src=\"https://github.githubassets.com/images/icons/emoji/' + $1 + '.png\" alt=\"' + $1 + '\" />'\n    }\n    \n    function emojify(text) {\n      return text\n        .replace(/<(pre|template|code)[^>]*?>[\\s\\S]+?<\\/(pre|template|code)>/g, function (m) { return m.replace(/:/g, '__colon__'); })\n        .replace(/:(\\w+?):/ig, (inBrowser && window.emojify) || replace)\n        .replace(/__colon__/g, ':')\n    }\n    \n    var decode = decodeURIComponent;\n    var encode = encodeURIComponent;\n    \n    function parseQuery(query) {\n      var res = {};\n    \n      query = query.trim().replace(/^(\\?|#|&)/, '');\n    \n      if (!query) {\n        return res\n      }\n    \n      // Simple parse\n      query.split('&').forEach(function (param) {\n        var parts = param.replace(/\\+/g, ' ').split('=');\n    \n        res[parts[0]] = parts[1] && decode(parts[1]);\n      });\n    \n      return res\n    }\n    \n    function stringifyQuery(obj, ignores) {\n      if ( ignores === void 0 ) ignores = [];\n    \n      var qs = [];\n    \n      for (var key in obj) {\n        if (ignores.indexOf(key) > -1) {\n          continue\n        }\n        qs.push(\n          obj[key] ?\n            ((encode(key)) + \"=\" + (encode(obj[key]))).toLowerCase() :\n            encode(key)\n        );\n      }\n    \n      return qs.length ? (\"?\" + (qs.join('&'))) : ''\n    }\n    \n    var isAbsolutePath = cached(function (path) {\n      return /(:|(\\/{2}))/g.test(path)\n    });\n    \n    var getParentPath = cached(function (path) {\n      return /\\/$/g.test(path) ?\n        path :\n        (path = path.match(/(\\S*\\/)[^/]+$/)) ? path[1] : ''\n    });\n    \n    var cleanPath = cached(function (path) {\n      return path.replace(/^\\/+/, '/').replace(/([^:])\\/{2,}/g, '$1/')\n    });\n    \n    var resolvePath = cached(function (path) {\n      var segments = path.replace(/^\\//, '').split('/');\n      var resolved = [];\n      for (var i = 0, len = segments.length; i < len; i++) {\n        var segment = segments[i];\n        if (segment === '..') {\n          resolved.pop();\n        } else if (segment !== '.') {\n          resolved.push(segment);\n        }\n      }\n      return '/' + resolved.join('/')\n    });\n    \n    function getPath() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n    \n      return cleanPath(args.join('/'))\n    }\n    \n    var replaceSlug = cached(function (path) {\n      return path.replace('#', '?id=')\n    });\n    \n    Prism.languages['markup-templating'] = {};\n    \n    Object.defineProperties(Prism.languages['markup-templating'], {\n        buildPlaceholders: {\n            // Tokenize all inline templating expressions matching placeholderPattern\n            // If the replaceFilter function is provided, it will be called with every match.\n            // If it returns false, the match will not be replaced.\n            value: function (env, language, placeholderPattern, replaceFilter) {\n                if (env.language !== language) {\n                    return;\n                }\n    \n                env.tokenStack = [];\n    \n                env.code = env.code.replace(placeholderPattern, function(match) {\n                    if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n                        return match;\n                    }\n                    var i = env.tokenStack.length;\n                    // Check for existing strings\n                    while (env.code.indexOf('___' + language.toUpperCase() + i + '___') !== -1)\n                        { ++i; }\n    \n                    // Create a sparse array\n                    env.tokenStack[i] = match;\n    \n                    return '___' + language.toUpperCase() + i + '___';\n                });\n    \n                // Switch the grammar to markup\n                env.grammar = Prism.languages.markup;\n            }\n        },\n        tokenizePlaceholders: {\n            // Replace placeholders with proper tokens after tokenizing\n            value: function (env, language) {\n                if (env.language !== language || !env.tokenStack) {\n                    return;\n                }\n    \n                // Switch the grammar back\n                env.grammar = Prism.languages[language];\n    \n                var j = 0;\n                var keys = Object.keys(env.tokenStack);\n                var walkTokens = function (tokens) {\n                    if (j >= keys.length) {\n                        return;\n                    }\n                    for (var i = 0; i < tokens.length; i++) {\n                        var token = tokens[i];\n                        if (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n                            var k = keys[j];\n                            var t = env.tokenStack[k];\n                            var s = typeof token === 'string' ? token : token.content;\n    \n                            var index = s.indexOf('___' + language.toUpperCase() + k + '___');\n                            if (index > -1) {\n                                ++j;\n                                var before = s.substring(0, index);\n                                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar, language), 'language-' + language, t);\n                                var after = s.substring(index + ('___' + language.toUpperCase() + k + '___').length);\n                                var replacement;\n                                if (before || after) {\n                                    replacement = [before, middle, after].filter(function (v) { return !!v; });\n                                    walkTokens(replacement);\n                                } else {\n                                    replacement = middle;\n                                }\n                                if (typeof token === 'string') {\n                                    Array.prototype.splice.apply(tokens, [i, 1].concat(replacement));\n                                } else {\n                                    token.content = replacement;\n                                }\n    \n                                if (j >= keys.length) {\n                                    break;\n                                }\n                            }\n                        } else if (token.content && typeof token.content !== 'string') {\n                            walkTokens(token.content);\n                        }\n                    }\n                };\n    \n                walkTokens(env.tokens);\n            }\n        }\n    });\n    \n    // See https://github.com/PrismJS/prism/pull/1367\n    var cachedLinks = {};\n    \n    function getAndRemoveConfig(str) {\n      if ( str === void 0 ) str = '';\n    \n      var config = {};\n    \n      if (str) {\n        str = str\n          .replace(/^'/, '')\n          .replace(/'$/, '')\n          .replace(/(?:^|\\s):([\\w-]+)=?([\\w-]+)?/g, function (m, key, value) {\n            config[key] = (value && value.replace(/&quot;/g, '')) || true;\n            return ''\n          })\n          .trim();\n      }\n    \n      return {str: str, config: config}\n    }\n    \n    var compileMedia = {\n      markdown: function markdown(url) {\n        return {\n          url: url\n        }\n      },\n      mermaid: function mermaid(url) {\n        return {\n          url: url\n        }\n      },\n      iframe: function iframe(url, title) {\n        return {\n          html: (\"<iframe src=\\\"\" + url + \"\\\" \" + (title || 'width=100% height=400') + \"></iframe>\")\n        }\n      },\n      video: function video(url, title) {\n        return {\n          html: (\"<video src=\\\"\" + url + \"\\\" \" + (title || 'controls') + \">Not Support</video>\")\n        }\n      },\n      audio: function audio(url, title) {\n        return {\n          html: (\"<audio src=\\\"\" + url + \"\\\" \" + (title || 'controls') + \">Not Support</audio>\")\n        }\n      },\n      code: function code(url, title) {\n        var lang = url.match(/\\.(\\w+)$/);\n    \n        lang = title || (lang && lang[1]);\n        if (lang === 'md') {\n          lang = 'markdown';\n        }\n    \n        return {\n          url: url,\n          lang: lang\n        }\n      }\n    };\n    \n    var Compiler = function Compiler(config, router) {\n      var this$1 = this;\n    \n      this.config = config;\n      this.router = router;\n      this.cacheTree = {};\n      this.toc = [];\n      this.cacheTOC = {};\n      this.linkTarget = config.externalLinkTarget || '_blank';\n      this.contentBase = router.getBasePath();\n    \n      var renderer = this._initRenderer();\n      var compile;\n      var mdConf = config.markdown || {};\n    \n      if (isFn(mdConf)) {\n        compile = mdConf(marked, renderer);\n      } else {\n        marked.setOptions(\n          merge(mdConf, {\n            renderer: merge(renderer, mdConf.renderer)\n          })\n        );\n        compile = marked;\n      }\n    \n      this._marked = compile;\n      this.compile = function (text) {\n        var isCached = true;\n        var result = cached(function (_) {\n          isCached = false;\n          var html = '';\n    \n          if (!text) {\n            return text\n          }\n    \n          if (isPrimitive(text)) {\n            html = compile(text);\n          } else {\n            html = compile.parser(text);\n          }\n    \n          html = config.noEmoji ? html : emojify(html);\n          slugify.clear();\n    \n          return html\n        })(text);\n    \n        var curFileName = this$1.router.parse().file;\n    \n        if (isCached) {\n          this$1.toc = this$1.cacheTOC[curFileName];\n        } else {\n          this$1.cacheTOC[curFileName] = [].concat( this$1.toc );\n        }\n    \n        return result\n      };\n    };\n    \n    Compiler.prototype.compileEmbed = function compileEmbed (href, title) {\n      var ref = getAndRemoveConfig(title);\n        var str = ref.str;\n        var config = ref.config;\n      var embed;\n      title = str;\n    \n      if (config.include) {\n        if (!isAbsolutePath(href)) {\n          href = getPath(\n            this.contentBase,\n            getParentPath(this.router.getCurrentPath()),\n            href\n          );\n        }\n    \n        var media;\n        if (config.type && (media = compileMedia[config.type])) {\n          embed = media.call(this, href, title);\n          embed.type = config.type;\n        } else {\n          var type = 'code';\n          if (/\\.(md|markdown)/.test(href)) {\n            type = 'markdown';\n          } else if (/\\.mmd/.test(href)) {\n            type = 'mermaid';\n          } else if (/\\.html?/.test(href)) {\n            type = 'iframe';\n          } else if (/\\.(mp4|ogg)/.test(href)) {\n            type = 'video';\n          } else if (/\\.mp3/.test(href)) {\n            type = 'audio';\n          }\n          embed = compileMedia[type].call(this, href, title);\n          embed.type = type;\n        }\n        embed.fragment = config.fragment;\n    \n        return embed\n      }\n    };\n    \n    Compiler.prototype._matchNotCompileLink = function _matchNotCompileLink (link) {\n      var links = this.config.noCompileLinks || [];\n    \n      for (var i = 0; i < links.length; i++) {\n        var n = links[i];\n        var re = cachedLinks[n] || (cachedLinks[n] = new RegExp((\"^\" + n + \"$\")));\n    \n        if (re.test(link)) {\n          return link\n        }\n      }\n    };\n    \n    Compiler.prototype._initRenderer = function _initRenderer () {\n      var renderer = new marked.Renderer();\n      var ref = this;\n        var linkTarget = ref.linkTarget;\n        var router = ref.router;\n        var contentBase = ref.contentBase;\n      var _self = this;\n      var origin = {};\n    \n      /**\n       * Render anchor tag\n       * @link https://github.com/markedjs/marked#overriding-renderer-methods\n       */\n      origin.heading = renderer.heading = function (text, level) {\n        var ref = getAndRemoveConfig(text);\n          var str = ref.str;\n          var config = ref.config;\n        var nextToc = {level: level, title: str};\n    \n        if (/{docsify-ignore}/g.test(str)) {\n          str = str.replace('{docsify-ignore}', '');\n          nextToc.title = str;\n          nextToc.ignoreSubHeading = true;\n        }\n    \n        if (/{docsify-ignore-all}/g.test(str)) {\n          str = str.replace('{docsify-ignore-all}', '');\n          nextToc.title = str;\n          nextToc.ignoreAllSubs = true;\n        }\n    \n        var slug = slugify(config.id || str);\n        var url = router.toURL(router.getCurrentPath(), {id: slug});\n        nextToc.slug = url;\n        _self.toc.push(nextToc);\n    \n        return (\"<h\" + level + \" id=\\\"\" + slug + \"\\\"><a href=\\\"\" + url + \"\\\" data-id=\\\"\" + slug + \"\\\" class=\\\"anchor\\\"><span>\" + str + \"</span></a></h\" + level + \">\")\n      };\n      // Highlight code\n      origin.code = renderer.code = function (code, lang) {\n          if ( lang === void 0 ) lang = '';\n    \n        code = code.replace(/@DOCSIFY_QM@/g, '`');\n        var hl = prism.highlight(\n          code,\n          prism.languages[lang] || prism.languages.markup\n        );\n    \n        return (\"<pre v-pre data-lang=\\\"\" + lang + \"\\\"><code class=\\\"lang-\" + lang + \"\\\">\" + hl + \"</code></pre>\")\n      };\n      origin.link = renderer.link = function (href, title, text) {\n          if ( title === void 0 ) title = '';\n    \n        var attrs = '';\n    \n        var ref = getAndRemoveConfig(title);\n          var str = ref.str;\n          var config = ref.config;\n        title = str;\n    \n        if (\n          !isAbsolutePath(href) &&\n          !_self._matchNotCompileLink(href) &&\n          !config.ignore\n        ) {\n          if (href === _self.config.homepage) {\n            href = 'README';\n          }\n          href = router.toURL(href, null, router.getCurrentPath());\n        } else {\n          attrs += href.indexOf('mailto:') === 0 ? '' : (\" target=\\\"\" + linkTarget + \"\\\"\");\n        }\n    \n        if (config.target) {\n          attrs += ' target=' + config.target;\n        }\n    \n        if (config.disabled) {\n          attrs += ' disabled';\n          href = 'javascript:void(0)';\n        }\n    \n        if (title) {\n          attrs += \" title=\\\"\" + title + \"\\\"\";\n        }\n    \n        return (\"<a href=\\\"\" + href + \"\\\"\" + attrs + \">\" + text + \"</a>\")\n      };\n      origin.paragraph = renderer.paragraph = function (text) {\n        var result;\n        if (/^!&gt;/.test(text)) {\n          result = helper('tip', text);\n        } else if (/^\\?&gt;/.test(text)) {\n          result = helper('warn', text);\n        } else {\n          result = \"<p>\" + text + \"</p>\";\n        }\n        return result\n      };\n      origin.image = renderer.image = function (href, title, text) {\n        var url = href;\n        var attrs = '';\n    \n        var ref = getAndRemoveConfig(title);\n          var str = ref.str;\n          var config = ref.config;\n        title = str;\n    \n        if (config['no-zoom']) {\n          attrs += ' data-no-zoom';\n        }\n    \n        if (title) {\n          attrs += \" title=\\\"\" + title + \"\\\"\";\n        }\n    \n        var size = config.size;\n        if (size) {\n          var sizes = size.split('x');\n          if (sizes[1]) {\n            attrs += 'width=' + sizes[0] + ' height=' + sizes[1];\n          } else {\n            attrs += 'width=' + sizes[0];\n          }\n        }\n    \n        if (!isAbsolutePath(href)) {\n          url = getPath(contentBase, getParentPath(router.getCurrentPath()), href);\n        }\n    \n        return (\"<img src=\\\"\" + url + \"\\\"data-origin=\\\"\" + href + \"\\\" alt=\\\"\" + text + \"\\\"\" + attrs + \">\")\n      };\n      origin.list = renderer.list = function (body, ordered, start) {\n        var isTaskList = /<li class=\"task-list-item\">/.test(body.split('class=\"task-list\"')[0]);\n        var isStartReq = start && start > 1;\n        var tag = ordered ? 'ol' : 'ul';\n        var tagAttrs = [\n          (isTaskList ? 'class=\"task-list\"' : ''),\n          (isStartReq ? (\"start=\\\"\" + start + \"\\\"\") : '')\n        ].join(' ').trim();\n    \n        return (\"<\" + tag + \" \" + tagAttrs + \">\" + body + \"</\" + tag + \">\")\n      };\n      origin.listitem = renderer.listitem = function (text) {\n        var isTaskItem = /^(<input.*type=\"checkbox\"[^>]*>)/.test(text);\n        var html = isTaskItem ? (\"<li class=\\\"task-list-item\\\"><label>\" + text + \"</label></li>\") : (\"<li>\" + text + \"</li>\");\n    \n        return html\n      };\n    \n      renderer.origin = origin;\n    \n      return renderer\n    };\n    \n    /**\n     * Compile sidebar\n     */\n    Compiler.prototype.sidebar = function sidebar (text, level) {\n      var ref = this;\n        var toc = ref.toc;\n      var currentPath = this.router.getCurrentPath();\n      var html = '';\n    \n      if (text) {\n        html = this.compile(text);\n      } else {\n        for (var i = 0; i < toc.length; i++) {\n          if (toc[i].ignoreSubHeading) {\n            var deletedHeaderLevel = toc[i].level;\n            toc.splice(i, 1);\n            // Remove headers who are under current header\n            for (var j = i; deletedHeaderLevel < toc[j].level && j < toc.length; j++) {\n              toc.splice(j, 1) && j-- && i++;\n            }\n            i--;\n          }\n        }\n        var tree$$1 = this.cacheTree[currentPath] || genTree(toc, level);\n        html = tree(tree$$1, '<ul>{inner}</ul>');\n        this.cacheTree[currentPath] = tree$$1;\n      }\n    \n      return html\n    };\n    \n    /**\n     * Compile sub sidebar\n     */\n    Compiler.prototype.subSidebar = function subSidebar (level) {\n      if (!level) {\n        this.toc = [];\n        return\n      }\n      var currentPath = this.router.getCurrentPath();\n      var ref = this;\n        var cacheTree = ref.cacheTree;\n        var toc = ref.toc;\n    \n      toc[0] && toc[0].ignoreAllSubs && toc.splice(0);\n      toc[0] && toc[0].level === 1 && toc.shift();\n    \n      for (var i = 0; i < toc.length; i++) {\n        toc[i].ignoreSubHeading && toc.splice(i, 1) && i--;\n      }\n      var tree$$1 = cacheTree[currentPath] || genTree(toc, level);\n    \n      cacheTree[currentPath] = tree$$1;\n      this.toc = [];\n      return tree(tree$$1)\n    };\n    \n    Compiler.prototype.article = function article (text) {\n      return this.compile(text)\n    };\n    \n    /**\n     * Compile cover page\n     */\n    Compiler.prototype.cover = function cover$$1 (text) {\n      var cacheToc = this.toc.slice();\n      var html = this.compile(text);\n    \n      this.toc = cacheToc.slice();\n    \n      return html\n    };\n    \n    var title = $.title;\n    /**\n     * Toggle button\n     */\n    function btn(el) {\n      var toggle = function (_) { return body.classList.toggle('close'); };\n    \n      el = getNode(el);\n      if (el == null) {\n        return\n      }\n      on(el, 'click', function (e) {\n        e.stopPropagation();\n        toggle();\n      });\n    \n      isMobile &&\n        on(\n          body,\n          'click',\n          function (_) { return body.classList.contains('close') && toggle(); }\n        );\n    }\n    \n    function collapse(el) {\n      el = getNode(el);\n      if (el == null) {\n        return\n      }\n      on(el, 'click', function (ref) {\n        var target = ref.target;\n    \n        if (\n          target.nodeName === 'A' &&\n          target.nextSibling &&\n          target.nextSibling.classList.contains('app-sub-sidebar')\n        ) {\n          toggleClass(target.parentNode, 'collapse');\n        }\n      });\n    }\n    \n    function sticky() {\n      var cover = getNode('section.cover');\n      if (!cover) {\n        return\n      }\n      var coverHeight = cover.getBoundingClientRect().height;\n    \n      if (window.pageYOffset >= coverHeight || cover.classList.contains('hidden')) {\n        toggleClass(body, 'add', 'sticky');\n      } else {\n        toggleClass(body, 'remove', 'sticky');\n      }\n    }\n    \n    /**\n     * Get and active link\n     * @param  {object} router\n     * @param  {string|element}  el\n     * @param  {Boolean} isParent   acitve parent\n     * @param  {Boolean} autoTitle  auto set title\n     * @return {element}\n     */\n    function getAndActive(router, el, isParent, autoTitle) {\n      el = getNode(el);\n      var links = [];\n      if (el != null) {\n        links = findAll(el, 'a');\n      }\n      var hash = decodeURI(router.toURL(router.getCurrentPath()));\n      var target;\n    \n      links.sort(function (a, b) { return b.href.length - a.href.length; }).forEach(function (a) {\n        var href = a.getAttribute('href');\n        var node = isParent ? a.parentNode : a;\n    \n        if (hash.indexOf(href) === 0 && !target) {\n          target = a;\n          toggleClass(node, 'add', 'active');\n        } else {\n          toggleClass(node, 'remove', 'active');\n        }\n      });\n    \n      if (autoTitle) {\n        $.title = target ? (target.title || ((target.innerText) + \" - \" + title)) : title;\n      }\n    \n      return target\n    }\n    \n    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();\n    \n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n    \n    var Tweezer = function () {\n      function Tweezer() {\n        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    \n        _classCallCheck(this, Tweezer);\n    \n        this.duration = opts.duration || 1000;\n        this.ease = opts.easing || this._defaultEase;\n        this.start = opts.start;\n        this.end = opts.end;\n    \n        this.frame = null;\n        this.next = null;\n        this.isRunning = false;\n        this.events = {};\n        this.direction = this.start < this.end ? 'up' : 'down';\n      }\n    \n      _createClass(Tweezer, [{\n        key: 'begin',\n        value: function begin() {\n          if (!this.isRunning && this.next !== this.end) {\n            this.frame = window.requestAnimationFrame(this._tick.bind(this));\n          }\n          return this;\n        }\n      }, {\n        key: 'stop',\n        value: function stop() {\n          window.cancelAnimationFrame(this.frame);\n          this.isRunning = false;\n          this.frame = null;\n          this.timeStart = null;\n          this.next = null;\n          return this;\n        }\n      }, {\n        key: 'on',\n        value: function on(name, handler) {\n          this.events[name] = this.events[name] || [];\n          this.events[name].push(handler);\n          return this;\n        }\n      }, {\n        key: 'emit',\n        value: function emit(name, val) {\n          var _this = this;\n    \n          var e = this.events[name];\n          e && e.forEach(function (handler) {\n            return handler.call(_this, val);\n          });\n        }\n      }, {\n        key: '_tick',\n        value: function _tick(currentTime) {\n          this.isRunning = true;\n    \n          var lastTick = this.next || this.start;\n    \n          if (!this.timeStart) { this.timeStart = currentTime; }\n          this.timeElapsed = currentTime - this.timeStart;\n          this.next = Math.round(this.ease(this.timeElapsed, this.start, this.end - this.start, this.duration));\n    \n          if (this._shouldTick(lastTick)) {\n            this.emit('tick', this.next);\n            this.frame = window.requestAnimationFrame(this._tick.bind(this));\n          } else {\n            this.emit('tick', this.end);\n            this.emit('done', null);\n          }\n        }\n      }, {\n        key: '_shouldTick',\n        value: function _shouldTick(lastTick) {\n          return {\n            up: this.next < this.end && lastTick <= this.next,\n            down: this.next > this.end && lastTick >= this.next\n          }[this.direction];\n        }\n      }, {\n        key: '_defaultEase',\n        value: function _defaultEase(t, b, c, d) {\n          if ((t /= d / 2) < 1) { return c / 2 * t * t + b; }\n          return -c / 2 * (--t * (t - 2) - 1) + b;\n        }\n      }]);\n    \n      return Tweezer;\n    }();\n    \n    var nav = {};\n    var hoverOver = false;\n    var scroller = null;\n    var enableScrollEvent = true;\n    var coverHeight = 0;\n    \n    function scrollTo(el) {\n      if (scroller) {\n        scroller.stop();\n      }\n      enableScrollEvent = false;\n      scroller = new Tweezer({\n        start: window.pageYOffset,\n        end: el.getBoundingClientRect().top + window.pageYOffset,\n        duration: 500\n      })\n        .on('tick', function (v) { return window.scrollTo(0, v); })\n        .on('done', function () {\n          enableScrollEvent = true;\n          scroller = null;\n        })\n        .begin();\n    }\n    \n    function highlight(path) {\n      if (!enableScrollEvent) {\n        return\n      }\n      var sidebar = getNode('.sidebar');\n      var anchors = findAll('.anchor');\n      var wrap = find(sidebar, '.sidebar-nav');\n      var active = find(sidebar, 'li.active');\n      var doc = document.documentElement;\n      var top = ((doc && doc.scrollTop) || document.body.scrollTop) - coverHeight;\n      var last;\n    \n      for (var i = 0, len = anchors.length; i < len; i += 1) {\n        var node = anchors[i];\n    \n        if (node.offsetTop > top) {\n          if (!last) {\n            last = node;\n          }\n          break\n        } else {\n          last = node;\n        }\n      }\n      if (!last) {\n        return\n      }\n      var li = nav[getNavKey(decodeURIComponent(path), last.getAttribute('data-id'))];\n    \n      if (!li || li === active) {\n        return\n      }\n    \n      active && active.classList.remove('active');\n      li.classList.add('active');\n      active = li;\n    \n      // Scroll into view\n      // https://github.com/vuejs/vuejs.org/blob/master/themes/vue/source/js/common.js#L282-L297\n      if (!hoverOver && body.classList.contains('sticky')) {\n        var height = sidebar.clientHeight;\n        var curOffset = 0;\n        var cur = active.offsetTop + active.clientHeight + 40;\n        var isInView =\n          active.offsetTop >= wrap.scrollTop && cur <= wrap.scrollTop + height;\n        var notThan = cur - curOffset < height;\n        var top$1 = isInView ? wrap.scrollTop : notThan ? curOffset : cur - height;\n    \n        sidebar.scrollTop = top$1;\n      }\n    }\n    \n    function getNavKey(path, id) {\n      return (path + \"?id=\" + id)\n    }\n    \n    function scrollActiveSidebar(router) {\n      var cover = find('.cover.show');\n      coverHeight = cover ? cover.offsetHeight : 0;\n    \n      var sidebar = getNode('.sidebar');\n      var lis = [];\n      if (sidebar != null) {\n        lis = findAll(sidebar, 'li');\n      }\n    \n      for (var i = 0, len = lis.length; i < len; i += 1) {\n        var li = lis[i];\n        var a = li.querySelector('a');\n        if (!a) {\n          continue\n        }\n        var href = a.getAttribute('href');\n    \n        if (href !== '/') {\n          var ref = router.parse(href);\n          var id = ref.query.id;\n          var path$1 = ref.path;\n          if (id) {\n            href = getNavKey(path$1, id);\n          }\n        }\n    \n        if (href) {\n          nav[decodeURIComponent(href)] = li;\n        }\n      }\n    \n      if (isMobile) {\n        return\n      }\n      var path = router.getCurrentPath();\n      off('scroll', function () { return highlight(path); });\n      on('scroll', function () { return highlight(path); });\n      on(sidebar, 'mouseover', function () {\n        hoverOver = true;\n      });\n      on(sidebar, 'mouseleave', function () {\n        hoverOver = false;\n      });\n    }\n    \n    function scrollIntoView(path, id) {\n      if (!id) {\n        return\n      }\n    \n      var section = find('#' + id);\n      section && scrollTo(section);\n    \n      var li = nav[getNavKey(path, id)];\n      var sidebar = getNode('.sidebar');\n      var active = find(sidebar, 'li.active');\n      active && active.classList.remove('active');\n      li && li.classList.add('active');\n    }\n    \n    var scrollEl = $.scrollingElement || $.documentElement;\n    \n    function scroll2Top(offset) {\n      if ( offset === void 0 ) offset = 0;\n    \n      scrollEl.scrollTop = offset === true ? 0 : Number(offset);\n    }\n    \n    var cached$1 = {};\n    \n    function walkFetchEmbed(ref, cb) {\n      var embedTokens = ref.embedTokens;\n      var compile = ref.compile;\n      var fetch = ref.fetch;\n    \n      var token;\n      var step = 0;\n      var count = 1;\n    \n      if (!embedTokens.length) {\n        return cb({})\n      }\n    \n      while ((token = embedTokens[step++])) {\n        var next = (function (token) {\n          return function (text) {\n            var embedToken;\n            if (text) {\n              if (token.embed.type === 'markdown') {\n                embedToken = compile.lexer(text);\n              } else if (token.embed.type === 'code') {\n                if (token.embed.fragment) {\n                  var fragment = token.embed.fragment;\n                  var pattern = new RegExp((\"(?:###|\\\\/\\\\/\\\\/)\\\\s*\\\\[\" + fragment + \"\\\\]([\\\\s\\\\S]*)(?:###|\\\\/\\\\/\\\\/)\\\\s*\\\\[\" + fragment + \"\\\\]\"));\n                  text = ((text.match(pattern) || [])[1] || '').trim();\n                }\n                embedToken = compile.lexer(\n                  '```' +\n                    token.embed.lang +\n                    '\\n' +\n                    text.replace(/`/g, '@DOCSIFY_QM@') +\n                    '\\n```\\n'\n                );\n              } else if (token.embed.type === 'mermaid') {\n                embedToken = [\n                  {type: 'html', text: (\"<div class=\\\"mermaid\\\">\\n\" + text + \"\\n</div>\")}\n                ];\n                embedToken.links = {};\n              } else {\n                embedToken = [{type: 'html', text: text}];\n                embedToken.links = {};\n              }\n            }\n            cb({token: token, embedToken: embedToken});\n            if (++count >= step) {\n              cb({});\n            }\n          }\n        })(token);\n    \n        if (token.embed.url) {\n          {\n            get(token.embed.url).then(next);\n          }\n        } else {\n          next(token.embed.html);\n        }\n      }\n    }\n    \n    function prerenderEmbed(ref, done) {\n      var compiler = ref.compiler;\n      var raw = ref.raw; if ( raw === void 0 ) raw = '';\n      var fetch = ref.fetch;\n    \n      var hit = cached$1[raw];\n      if (hit) {\n        var copy = hit.slice();\n        copy.links = hit.links;\n        return done(copy)\n      }\n    \n      var compile = compiler._marked;\n      var tokens = compile.lexer(raw);\n      var embedTokens = [];\n      var linkRE = compile.InlineLexer.rules.link;\n      var links = tokens.links;\n    \n      tokens.forEach(function (token, index) {\n        if (token.type === 'paragraph') {\n          token.text = token.text.replace(\n            new RegExp(linkRE.source, 'g'),\n            function (src, filename, href, title) {\n              var embed = compiler.compileEmbed(href, title);\n    \n              if (embed) {\n                embedTokens.push({\n                  index: index,\n                  embed: embed\n                });\n              }\n    \n              return src\n            }\n          );\n        }\n      });\n    \n      var moveIndex = 0;\n      walkFetchEmbed({compile: compile, embedTokens: embedTokens, fetch: fetch}, function (ref) {\n        var embedToken = ref.embedToken;\n        var token = ref.token;\n    \n        if (token) {\n          var index = token.index + moveIndex;\n    \n          merge(links, embedToken.links);\n    \n          tokens = tokens\n            .slice(0, index)\n            .concat(embedToken, tokens.slice(index + 1));\n          moveIndex += embedToken.length - 1;\n        } else {\n          cached$1[raw] = tokens.concat();\n          tokens.links = cached$1[raw].links = links;\n          done(tokens);\n        }\n      });\n    }\n    \n    function executeScript() {\n      var script = findAll('.markdown-section>script')\n        .filter(function (s) { return !/template/.test(s.type); })[0];\n      if (!script) {\n        return false\n      }\n      var code = script.innerText.trim();\n      if (!code) {\n        return false\n      }\n    \n      setTimeout(function (_) {\n        window.__EXECUTE_RESULT__ = new Function(code)();\n      }, 0);\n    }\n    \n    function formatUpdated(html, updated, fn) {\n      updated =\n        typeof fn === 'function' ?\n          fn(updated) :\n          typeof fn === 'string' ?\n            tinydate(fn)(new Date(updated)) :\n            updated;\n    \n      return html.replace(/{docsify-updated}/g, updated)\n    }\n    \n    function renderMain(html) {\n      if (!html) {\n        html = '<h1>404 - Not found</h1>';\n      }\n    \n      this._renderTo('.markdown-section', html);\n      // Render sidebar with the TOC\n      !this.config.loadSidebar && this._renderSidebar();\n    \n      // Execute script\n      if (\n        this.config.executeScript !== false &&\n        typeof window.Vue !== 'undefined' &&\n        !executeScript()\n      ) {\n        setTimeout(function (_) {\n          var vueVM = window.__EXECUTE_RESULT__;\n          vueVM && vueVM.$destroy && vueVM.$destroy();\n          window.__EXECUTE_RESULT__ = new window.Vue().$mount('#main');\n        }, 0);\n      } else {\n        this.config.executeScript && executeScript();\n      }\n    }\n    \n    function renderNameLink(vm) {\n      var el = getNode('.app-name-link');\n      var nameLink = vm.config.nameLink;\n      var path = vm.route.path;\n    \n      if (!el) {\n        return\n      }\n    \n      if (isPrimitive(vm.config.nameLink)) {\n        el.setAttribute('href', nameLink);\n      } else if (typeof nameLink === 'object') {\n        var match = Object.keys(nameLink).filter(function (key) { return path.indexOf(key) > -1; })[0];\n    \n        el.setAttribute('href', nameLink[match]);\n      }\n    }\n    \n    function renderMixin(proto) {\n      proto._renderTo = function (el, content, replace) {\n        var node = getNode(el);\n        if (node) {\n          node[replace ? 'outerHTML' : 'innerHTML'] = content;\n        }\n      };\n    \n      proto._renderSidebar = function (text) {\n        var ref = this.config;\n        var maxLevel = ref.maxLevel;\n        var subMaxLevel = ref.subMaxLevel;\n        var loadSidebar = ref.loadSidebar;\n    \n        this._renderTo('.sidebar-nav', this.compiler.sidebar(text, maxLevel));\n        var activeEl = getAndActive(this.router, '.sidebar-nav', true, true);\n        if (loadSidebar && activeEl) {\n          activeEl.parentNode.innerHTML +=\n            this.compiler.subSidebar(subMaxLevel) || '';\n        } else {\n          // Reset toc\n          this.compiler.subSidebar();\n        }\n        // Bind event\n        this._bindEventOnRendered(activeEl);\n      };\n    \n      proto._bindEventOnRendered = function (activeEl) {\n        var ref = this.config;\n        var autoHeader = ref.autoHeader;\n        var auto2top = ref.auto2top;\n    \n        scrollActiveSidebar(this.router);\n    \n        if (autoHeader && activeEl) {\n          var main$$1 = getNode('#main');\n          var firstNode = main$$1.children[0];\n          if (firstNode && firstNode.tagName !== 'H1') {\n            var h1 = create('h1');\n            h1.innerText = activeEl.innerText;\n            before(main$$1, h1);\n          }\n        }\n    \n        auto2top && scroll2Top(auto2top);\n      };\n    \n      proto._renderNav = function (text) {\n        text && this._renderTo('nav', this.compiler.compile(text));\n        if (this.config.loadNavbar) {\n          getAndActive(this.router, 'nav');\n        }\n      };\n    \n      proto._renderMain = function (text, opt, next) {\n        var this$1 = this;\n        if ( opt === void 0 ) opt = {};\n    \n        if (!text) {\n          return renderMain.call(this, text)\n        }\n    \n        callHook(this, 'beforeEach', text, function (result) {\n          var html;\n          var callback = function () {\n            if (opt.updatedAt) {\n              html = formatUpdated(html, opt.updatedAt, this$1.config.formatUpdated);\n            }\n    \n            callHook(this$1, 'afterEach', html, function (text) { return renderMain.call(this$1, text); });\n          };\n          if (this$1.isHTML) {\n            html = this$1.result = text;\n            callback();\n            next();\n          } else {\n            prerenderEmbed(\n              {\n                compiler: this$1.compiler,\n                raw: result\n              },\n              function (tokens) {\n                html = this$1.compiler.compile(tokens);\n                callback();\n                next();\n              }\n            );\n          }\n        });\n      };\n    \n      proto._renderCover = function (text, coverOnly) {\n        var el = getNode('.cover');\n    \n        toggleClass(getNode('main'), coverOnly ? 'add' : 'remove', 'hidden');\n        if (!text) {\n          toggleClass(el, 'remove', 'show');\n          return\n        }\n        toggleClass(el, 'add', 'show');\n    \n        var html = this.coverIsHTML ? text : this.compiler.cover(text);\n    \n        var m = html\n          .trim()\n          .match('<p><img.*?data-origin=\"(.*?)\"[^a]+alt=\"(.*?)\">([^<]*?)</p>$');\n    \n        if (m) {\n          if (m[2] === 'color') {\n            el.style.background = m[1] + (m[3] || '');\n          } else {\n            var path = m[1];\n    \n            toggleClass(el, 'add', 'has-mask');\n            if (!isAbsolutePath(m[1])) {\n              path = getPath(this.router.getBasePath(), m[1]);\n            }\n            el.style.backgroundImage = \"url(\" + path + \")\";\n            el.style.backgroundSize = 'cover';\n            el.style.backgroundPosition = 'center center';\n          }\n          html = html.replace(m[0], '');\n        }\n    \n        this._renderTo('.cover-main', html);\n        sticky();\n      };\n    \n      proto._updateRender = function () {\n        // Render name link\n        renderNameLink(this);\n      };\n    }\n    \n    function initRender(vm) {\n      var config = vm.config;\n    \n      // Init markdown compiler\n      vm.compiler = new Compiler(config, vm.router);\n      if (inBrowser) {\n        window.__current_docsify_compiler__ = vm.compiler;\n      }\n    \n      var id = config.el || '#app';\n      var navEl = find('nav') || create('nav');\n    \n      var el = find(id);\n      var html = '';\n      var navAppendToTarget = body;\n    \n      if (el) {\n        if (config.repo) {\n          html += corner(config.repo);\n        }\n        if (config.coverpage) {\n          html += cover();\n        }\n    \n        if (config.logo) {\n          var isBase64 = /^data:image/.test(config.logo);\n          var isExternal = /(?:http[s]?:)?\\/\\//.test(config.logo);\n          var isRelative = /^\\./.test(config.logo);\n    \n          if (!isBase64 && !isExternal && !isRelative) {\n            config.logo = getPath(vm.router.getBasePath(), config.logo);\n          }\n        }\n    \n        html += main(config);\n        // Render main app\n        vm._renderTo(el, html, true);\n      } else {\n        vm.rendered = true;\n      }\n    \n      if (config.mergeNavbar && isMobile) {\n        navAppendToTarget = find('.sidebar');\n      } else {\n        navEl.classList.add('app-nav');\n    \n        if (!config.repo) {\n          navEl.classList.add('no-badge');\n        }\n      }\n    \n      // Add nav\n      if (config.loadNavbar) {\n        before(navAppendToTarget, navEl);\n      }\n    \n      if (config.themeColor) {\n        $.head.appendChild(\n          create('div', theme(config.themeColor)).firstElementChild\n        );\n        // Polyfll\n        cssVars(config.themeColor);\n      }\n      vm._updateRender();\n      toggleClass(body, 'ready');\n    }\n    \n    var cached$2 = {};\n    \n    function getAlias(path, alias, last) {\n      var match = Object.keys(alias).filter(function (key) {\n        var re = cached$2[key] || (cached$2[key] = new RegExp((\"^\" + key + \"$\")));\n        return re.test(path) && path !== last\n      })[0];\n    \n      return match ?\n        getAlias(path.replace(cached$2[match], alias[match]), alias, path) :\n        path\n    }\n    \n    function getFileName(path, ext) {\n      return new RegExp((\"\\\\.(\" + (ext.replace(/^\\./, '')) + \"|html)$\"), 'g').test(path) ?\n        path :\n        /\\/$/g.test(path) ? (path + \"README\" + ext) : (\"\" + path + ext)\n    }\n    \n    var History = function History(config) {\n      this.config = config;\n    };\n    \n    History.prototype.getBasePath = function getBasePath () {\n      return this.config.basePath\n    };\n    \n    History.prototype.getFile = function getFile (path, isRelative) {\n        if ( path === void 0 ) path = this.getCurrentPath();\n    \n      var ref = this;\n        var config = ref.config;\n      var base = this.getBasePath();\n      var ext = typeof config.ext === 'string' ? config.ext : '.md';\n    \n      path = config.alias ? getAlias(path, config.alias) : path;\n      path = getFileName(path, ext);\n      path = path === (\"/README\" + ext) ? config.homepage || path : path;\n      path = isAbsolutePath(path) ? path : getPath(base, path);\n    \n      if (isRelative) {\n        path = path.replace(new RegExp((\"^\" + base)), '');\n      }\n    \n      return path\n    };\n    \n    History.prototype.onchange = function onchange (cb) {\n        if ( cb === void 0 ) cb = noop;\n    \n      cb();\n    };\n    \n    History.prototype.getCurrentPath = function getCurrentPath () {};\n    \n    History.prototype.normalize = function normalize () {};\n    \n    History.prototype.parse = function parse () {};\n    \n    History.prototype.toURL = function toURL (path, params, currentRoute) {\n      var local = currentRoute && path[0] === '#';\n      var route = this.parse(replaceSlug(path));\n    \n      route.query = merge({}, route.query, params);\n      path = route.path + stringifyQuery(route.query);\n      path = path.replace(/\\.md(\\?)|\\.md$/, '$1');\n    \n      if (local) {\n        var idIndex = currentRoute.indexOf('?');\n        path =\n          (idIndex > 0 ? currentRoute.substring(0, idIndex) : currentRoute) + path;\n      }\n    \n      if (this.config.relativePath && path.indexOf('/') !== 0) {\n        var currentDir = currentRoute.substring(0, currentRoute.lastIndexOf('/') + 1);\n        return cleanPath(resolvePath(currentDir + path))\n      }\n      return cleanPath('/' + path)\n    };\n    \n    function replaceHash(path) {\n      var i = location.href.indexOf('#');\n      location.replace(location.href.slice(0, i >= 0 ? i : 0) + '#' + path);\n    }\n    \n    var HashHistory = (function (History$$1) {\n      function HashHistory(config) {\n        History$$1.call(this, config);\n        this.mode = 'hash';\n      }\n    \n      if ( History$$1 ) HashHistory.__proto__ = History$$1;\n      HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n      HashHistory.prototype.constructor = HashHistory;\n    \n      HashHistory.prototype.getBasePath = function getBasePath () {\n        var path = window.location.pathname || '';\n        var base = this.config.basePath;\n    \n        return /^(\\/|https?:)/g.test(base) ? base : cleanPath(path + '/' + base)\n      };\n    \n      HashHistory.prototype.getCurrentPath = function getCurrentPath () {\n        // We can't use location.hash here because it's not\n        // consistent across browsers - Firefox will pre-decode it!\n        var href = location.href;\n        var index = href.indexOf('#');\n        return index === -1 ? '' : href.slice(index + 1)\n      };\n    \n      HashHistory.prototype.onchange = function onchange (cb) {\n        if ( cb === void 0 ) cb = noop;\n    \n        on('hashchange', cb);\n      };\n    \n      HashHistory.prototype.normalize = function normalize () {\n        var path = this.getCurrentPath();\n    \n        path = replaceSlug(path);\n    \n        if (path.charAt(0) === '/') {\n          return replaceHash(path)\n        }\n        replaceHash('/' + path);\n      };\n    \n      /**\n       * Parse the url\n       * @param {string} [path=location.herf]\n       * @return {object} { path, query }\n       */\n      HashHistory.prototype.parse = function parse (path) {\n        if ( path === void 0 ) path = location.href;\n    \n        var query = '';\n    \n        var hashIndex = path.indexOf('#');\n        if (hashIndex >= 0) {\n          path = path.slice(hashIndex + 1);\n        }\n    \n        var queryIndex = path.indexOf('?');\n        if (queryIndex >= 0) {\n          query = path.slice(queryIndex + 1);\n          path = path.slice(0, queryIndex);\n        }\n    \n        return {\n          path: path,\n          file: this.getFile(path, true),\n          query: parseQuery(query)\n        }\n      };\n    \n      HashHistory.prototype.toURL = function toURL (path, params, currentRoute) {\n        return '#' + History$$1.prototype.toURL.call(this, path, params, currentRoute)\n      };\n    \n      return HashHistory;\n    }(History));\n    \n    var HTML5History = (function (History$$1) {\n      function HTML5History(config) {\n        History$$1.call(this, config);\n        this.mode = 'history';\n      }\n    \n      if ( History$$1 ) HTML5History.__proto__ = History$$1;\n      HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n      HTML5History.prototype.constructor = HTML5History;\n    \n      HTML5History.prototype.getCurrentPath = function getCurrentPath () {\n        var base = this.getBasePath();\n        var path = window.location.pathname;\n    \n        if (base && path.indexOf(base) === 0) {\n          path = path.slice(base.length);\n        }\n    \n        return (path || '/') + window.location.search + window.location.hash\n      };\n    \n      HTML5History.prototype.onchange = function onchange (cb) {\n        if ( cb === void 0 ) cb = noop;\n    \n        on('click', function (e) {\n          var el = e.target.tagName === 'A' ? e.target : e.target.parentNode;\n    \n          if (el.tagName === 'A' && !/_blank/.test(el.target)) {\n            e.preventDefault();\n            var url = el.href;\n            window.history.pushState({key: url}, '', url);\n            cb();\n          }\n        });\n    \n        on('popstate', cb);\n      };\n    \n      /**\n       * Parse the url\n       * @param {string} [path=location.href]\n       * @return {object} { path, query }\n       */\n      HTML5History.prototype.parse = function parse (path) {\n        if ( path === void 0 ) path = location.href;\n    \n        var query = '';\n    \n        var queryIndex = path.indexOf('?');\n        if (queryIndex >= 0) {\n          query = path.slice(queryIndex + 1);\n          path = path.slice(0, queryIndex);\n        }\n    \n        var base = getPath(location.origin);\n        var baseIndex = path.indexOf(base);\n    \n        if (baseIndex > -1) {\n          path = path.slice(baseIndex + base.length);\n        }\n    \n        return {\n          path: path,\n          file: this.getFile(path),\n          query: parseQuery(query)\n        }\n      };\n    \n      return HTML5History;\n    }(History));\n    \n    function routerMixin(proto) {\n      proto.route = {};\n    }\n    \n    var lastRoute = {};\n    \n    function updateRender(vm) {\n      vm.router.normalize();\n      vm.route = vm.router.parse();\n      body.setAttribute('data-page', vm.route.file);\n    }\n    \n    function initRouter(vm) {\n      var config = vm.config;\n      var mode = config.routerMode || 'hash';\n      var router;\n    \n      if (mode === 'history' && supportsPushState) {\n        router = new HTML5History(config);\n      } else {\n        router = new HashHistory(config);\n      }\n    \n      vm.router = router;\n      updateRender(vm);\n      lastRoute = vm.route;\n    \n      router.onchange(function (_) {\n        updateRender(vm);\n        vm._updateRender();\n    \n        if (lastRoute.path === vm.route.path) {\n          vm.$resetEvents();\n          return\n        }\n    \n        vm.$fetch();\n        lastRoute = vm.route;\n      });\n    }\n    \n    function eventMixin(proto) {\n      proto.$resetEvents = function () {\n        scrollIntoView(this.route.path, this.route.query.id);\n    \n        if (this.config.loadNavbar) {\n          getAndActive(this.router, 'nav');\n        }\n      };\n    }\n    \n    function initEvent(vm) {\n      // Bind toggle button\n      btn('button.sidebar-toggle', vm.router);\n      collapse('.sidebar', vm.router);\n      // Bind sticky effect\n      if (vm.config.coverpage) {\n        !isMobile && on('scroll', sticky);\n      } else {\n        body.classList.add('sticky');\n      }\n    }\n    \n    function loadNested(path, qs, file, next, vm, first) {\n      path = first ? path : path.replace(/\\/$/, '');\n      path = getParentPath(path);\n    \n      if (!path) {\n        return\n      }\n    \n      get(\n        vm.router.getFile(path + file) + qs,\n        false,\n        vm.config.requestHeaders\n      ).then(next, function (_) { return loadNested(path, qs, file, next, vm); });\n    }\n    \n    function fetchMixin(proto) {\n      var last;\n    \n      var abort = function () { return last && last.abort && last.abort(); };\n      var request = function (url, hasbar, requestHeaders) {\n        abort();\n        last = get(url, true, requestHeaders);\n        return last\n      };\n    \n      var get404Path = function (path, config) {\n        var notFoundPage = config.notFoundPage;\n        var ext = config.ext;\n        var defaultPath = '_404' + (ext || '.md');\n        var key;\n        var path404;\n    \n        switch (typeof notFoundPage) {\n          case 'boolean':\n            path404 = defaultPath;\n            break\n          case 'string':\n            path404 = notFoundPage;\n            break\n    \n          case 'object':\n            key = Object.keys(notFoundPage)\n              .sort(function (a, b) { return b.length - a.length; })\n              .find(function (key) { return path.match(new RegExp('^' + key)); });\n    \n            path404 = (key && notFoundPage[key]) || defaultPath;\n            break\n    \n          default:\n            break\n        }\n    \n        return path404\n      };\n    \n      proto._loadSideAndNav = function (path, qs, loadSidebar, cb) {\n        var this$1 = this;\n    \n        return function () {\n          if (!loadSidebar) {\n            return cb()\n          }\n    \n          var fn = function (result) {\n            this$1._renderSidebar(result);\n            cb();\n          };\n    \n          // Load sidebar\n          loadNested(path, qs, loadSidebar, fn, this$1, true);\n        }\n      };\n    \n      proto._fetch = function (cb) {\n        var this$1 = this;\n        if ( cb === void 0 ) cb = noop;\n    \n        var ref = this.route;\n        var path = ref.path;\n        var query = ref.query;\n        var qs = stringifyQuery(query, ['id']);\n        var ref$1 = this.config;\n        var loadNavbar = ref$1.loadNavbar;\n        var requestHeaders = ref$1.requestHeaders;\n        var loadSidebar = ref$1.loadSidebar;\n        // Abort last request\n    \n        var file = this.router.getFile(path);\n        var req = request(file + qs, true, requestHeaders);\n    \n        // Current page is html\n        this.isHTML = /\\.html$/g.test(file);\n    \n        // Load main content\n        req.then(\n          function (text, opt) { return this$1._renderMain(\n              text,\n              opt,\n              this$1._loadSideAndNav(path, qs, loadSidebar, cb)\n            ); },\n          function (_) {\n            this$1._fetchFallbackPage(file, qs, cb) || this$1._fetch404(file, qs, cb);\n          }\n        );\n    \n        // Load nav\n        loadNavbar &&\n          loadNested(\n            path,\n            qs,\n            loadNavbar,\n            function (text) { return this$1._renderNav(text); },\n            this,\n            true\n          );\n      };\n    \n      proto._fetchCover = function () {\n        var this$1 = this;\n    \n        var ref = this.config;\n        var coverpage = ref.coverpage;\n        var requestHeaders = ref.requestHeaders;\n        var query = this.route.query;\n        var root = getParentPath(this.route.path);\n    \n        if (coverpage) {\n          var path = null;\n          var routePath = this.route.path;\n          if (typeof coverpage === 'string') {\n            if (routePath === '/') {\n              path = coverpage;\n            }\n          } else if (Array.isArray(coverpage)) {\n            path = coverpage.indexOf(routePath) > -1 && '_coverpage';\n          } else {\n            var cover = coverpage[routePath];\n            path = cover === true ? '_coverpage' : cover;\n          }\n    \n          var coverOnly = Boolean(path) && this.config.onlyCover;\n          if (path) {\n            path = this.router.getFile(root + path);\n            this.coverIsHTML = /\\.html$/g.test(path);\n            get(path + stringifyQuery(query, ['id']), false, requestHeaders).then(\n              function (text) { return this$1._renderCover(text, coverOnly); }\n            );\n          } else {\n            this._renderCover(null, coverOnly);\n          }\n          return coverOnly\n        }\n      };\n    \n      proto.$fetch = function (cb) {\n        var this$1 = this;\n        if ( cb === void 0 ) cb = noop;\n    \n        var done = function () {\n          callHook(this$1, 'doneEach');\n          cb();\n        };\n    \n        var onlyCover = this._fetchCover();\n    \n        if (onlyCover) {\n          done();\n        } else {\n          this._fetch(function () {\n            this$1.$resetEvents();\n            done();\n          });\n        }\n      };\n    \n      proto._fetchFallbackPage = function (path, qs, cb) {\n        var this$1 = this;\n        if ( cb === void 0 ) cb = noop;\n    \n        var ref = this.config;\n        var requestHeaders = ref.requestHeaders;\n        var fallbackLanguages = ref.fallbackLanguages;\n        var loadSidebar = ref.loadSidebar;\n    \n        if (!fallbackLanguages) {\n          return false\n        }\n    \n        var local = path.split('/')[1];\n    \n        if (fallbackLanguages.indexOf(local) === -1) {\n          return false\n        }\n        var newPath = path.replace(new RegExp((\"^/\" + local)), '');\n        var req = request(newPath + qs, true, requestHeaders);\n    \n        req.then(\n          function (text, opt) { return this$1._renderMain(\n              text,\n              opt,\n              this$1._loadSideAndNav(path, qs, loadSidebar, cb)\n            ); },\n          function () { return this$1._fetch404(path, qs, cb); }\n        );\n    \n        return true\n      };\n      /**\n       * Load the 404 page\n       * @param path\n       * @param qs\n       * @param cb\n       * @returns {*}\n       * @private\n       */\n      proto._fetch404 = function (path, qs, cb) {\n        var this$1 = this;\n        if ( cb === void 0 ) cb = noop;\n    \n        var ref = this.config;\n        var loadSidebar = ref.loadSidebar;\n        var requestHeaders = ref.requestHeaders;\n        var notFoundPage = ref.notFoundPage;\n    \n        var fnLoadSideAndNav = this._loadSideAndNav(path, qs, loadSidebar, cb);\n        if (notFoundPage) {\n          var path404 = get404Path(path, this.config);\n    \n          request(this.router.getFile(path404), true, requestHeaders).then(\n            function (text, opt) { return this$1._renderMain(text, opt, fnLoadSideAndNav); },\n            function () { return this$1._renderMain(null, {}, fnLoadSideAndNav); }\n          );\n          return true\n        }\n    \n        this._renderMain(null, {}, fnLoadSideAndNav);\n        return false\n      };\n    }\n    \n    function initFetch(vm) {\n      var ref = vm.config;\n      var loadSidebar = ref.loadSidebar;\n    \n      // Server-Side Rendering\n      if (vm.rendered) {\n        var activeEl = getAndActive(vm.router, '.sidebar-nav', true, true);\n        if (loadSidebar && activeEl) {\n          activeEl.parentNode.innerHTML += window.__SUB_SIDEBAR__;\n        }\n        vm._bindEventOnRendered(activeEl);\n        vm.$resetEvents();\n        callHook(vm, 'doneEach');\n        callHook(vm, 'ready');\n      } else {\n        vm.$fetch(function (_) { return callHook(vm, 'ready'); });\n      }\n    }\n    \n    function initMixin(proto) {\n      proto._init = function () {\n        var vm = this;\n        vm.config = config();\n    \n        initLifecycle(vm); // Init hooks\n        initPlugin(vm); // Install plugins\n        callHook(vm, 'init');\n        initRouter(vm); // Add router\n        initRender(vm); // Render base DOM\n        initEvent(vm); // Bind events\n        initFetch(vm); // Fetch data\n        callHook(vm, 'mounted');\n      };\n    }\n    \n    function initPlugin(vm) {\n      [].concat(vm.config.plugins).forEach(function (fn) { return isFn(fn) && fn(vm._lifecycle, vm); });\n    }\n    \n    \n    \n    var util = Object.freeze({\n        cached: cached,\n        hyphenate: hyphenate,\n        hasOwn: hasOwn,\n        merge: merge,\n        isPrimitive: isPrimitive,\n        noop: noop,\n        isFn: isFn,\n        inBrowser: inBrowser,\n        isMobile: isMobile,\n        supportsPushState: supportsPushState,\n        parseQuery: parseQuery,\n        stringifyQuery: stringifyQuery,\n        isAbsolutePath: isAbsolutePath,\n        getParentPath: getParentPath,\n        cleanPath: cleanPath,\n        resolvePath: resolvePath,\n        getPath: getPath,\n        replaceSlug: replaceSlug\n    });\n    \n    function initGlobalAPI () {\n      window.Docsify = {\n        util: util,\n        dom: dom,\n        get: get,\n        slugify: slugify,\n        version: '4.9.4'\n      };\n      window.DocsifyCompiler = Compiler;\n      window.marked = marked;\n      window.Prism = prism;\n    }\n    \n    /**\n     * Fork https://github.com/bendrucker/document-ready/blob/master/index.js\n     */\n    function ready(callback) {\n      var state = document.readyState;\n    \n      if (state === 'complete' || state === 'interactive') {\n        return setTimeout(callback, 0)\n      }\n    \n      document.addEventListener('DOMContentLoaded', callback);\n    }\n    \n    function Docsify() {\n      this._init();\n    }\n    \n    var proto = Docsify.prototype;\n    \n    initMixin(proto);\n    routerMixin(proto);\n    renderMixin(proto);\n    fetchMixin(proto);\n    eventMixin(proto);\n    \n    /**\n     * Global API\n     */\n    initGlobalAPI();\n    \n    /**\n     * Run Docsify\n     */\n    ready(function (_) { return new Docsify(); });\n    \n    }());\n    "
        },
        {
          "name": "index.html",
          "type": "blob",
          "size": 2.8427734375,
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>深度学习500问</title>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"description\" content=\"Description\">\n  <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n  <link rel=\"stylesheet\" href=\"//unpkg.com/docsify/lib/themes/vue.css\">\n  <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css\">\n  <script src=\"https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js\"></script>\n  <style>\n    .sidebar>h1 a {\n      font-size: 20px;\n      color: black;\n    }\n    .content {\n      padding-top: 5px;\n    }\n    .markdown-section {\n      padding-top: 10px;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script>\n    window.$docsify = {\n      themeColor: '#fc7e09',\n      loadSidebar: true,\n      maxLevel: 2,\n      subMaxLevel: 2,\n      auto2top: true,\n      alias: {\n        '/.*/_sidebar.md': '/_sidebar.md',\n      },\n      markdown: {\n        latexRender: katex.renderToString.bind(katex)\n      },\n      search: {\n      \tplaceholder: 'Type to search',\n      \tnoData: 'No Results!',\n        paths: 'auto',\n        depth: 6\n      },\n      plugins: [\n        function(hook, vm) {\n          hook.beforeEach(function(content) {\n            // 每次开始解析 Markdown 内容时调用\n            // 将所有../img替换成img\n            // https://github.com/docsifyjs/docsify/issues/936\n            return content.replace(/..\\/img/g, \"img\");\n          })\n\n          hook.doneEach(function () {\n            window.MathJax.Hub.Queue([\"Typeset\", MathJax.Hub, document.getElementById('app')]);\n          })\n        }\n      ],\n      externalLinkTarget: '_target',\n      name: '深度学习500问',\n      repo: 'https://github.com/scutan90/DeepLearning-500-questions'\n    }\n  </script>\n  <script type=\"text/x-mathjax-config\">\n    MathJax.Hub.Config({\n      extensions: [\"tex2jax.js\"],\n      jax: [\"input/TeX\", \"output/HTML-CSS\"],\n      tex2jax: {\n        inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n        displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ],\n        processEscapes: true,\n        skipTags: [\"script\", \"noscript\", \"style\", \"textarea\", \"pre\", \"code\", \"a\"]\n      },\n      \"HTML-CSS\": { fonts: [\"TeX\"] }\n    });\n  </script>\n  <script src=\"docsify.js\"></script>\n  <script src=\"//unpkg.com/docsify/lib/plugins/zoom-image.js\"></script>\n  <script src=\"//unpkg.com/docsify-copy-code\"></script>\n  <script src=\"//unpkg.com/prismjs/components/prism-bash.js\"></script>\n  <script src=\"//unpkg.com/prismjs/components/prism-python.js\"></script>\n  <script src=\"//unpkg.com/docsify/lib/plugins/search.js\"></script>\n  <script async=\"async\" type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>\n</body>\n</html>\n"
        },
        {
          "name": "qun.png",
          "type": "blob",
          "size": 84.1181640625,
          "content": null
        },
        {
          "name": "深度学习2020",
          "type": "blob",
          "size": 0.0009765625,
          "content": "\n"
        },
        {
          "name": "深度学习500问-Tan-00目录.docx",
          "type": "blob",
          "size": 32.337890625,
          "content": null
        },
        {
          "name": "目录预览.md",
          "type": "blob",
          "size": 17.2119140625,
          "content": "# 目录\t2\n## 第一章 数学基础\t1\n1.1标量、向量、张量之间的联系\t1  \n1.2张量与矩阵的区别？\t1  \n1.3矩阵和向量相乘结果\t1  \n1.4向量和矩阵的范数归纳\t1  \n1.5如何判断一个矩阵为正定？\t2  \n1.6导数偏导计算\t3  \n1.7导数和偏导数有什么区别？\t3  \n1.8特征值分解与特征向量\t3  \n1.9奇异值与特征值有什么关系？\t4  \n1.10机器学习为什么要使用概率？\t4  \n1.11变量与随机变量有什么区别？\t4  \n1.12常见概率分布？\t5  \n1.13举例理解条件概率\t9  \n1.14联合概率与边缘概率联系区别？\t10  \n1.15条件概率的链式法则\t10  \n1.16独立性和条件独立性\t11  \n1.17期望、方差、协方差、相关系数总结\t11  \n## 第二章 机器学习基础\t14  \n2.1 各种常见算法图示\t14\n2.2监督学习、非监督学习、半监督学习、弱监督学习？\t15  \n2.3 监督学习有哪些步骤\t16  \n2.4 多实例学习？\t17  \n2.5 分类网络和回归的区别？\t17  \n2.6 什么是神经网络？\t17  \n2.7 常用分类算法的优缺点？\t18  \n2.8 正确率能很好的评估分类算法吗？\t20  \n2.9 分类算法的评估方法？\t20  \n2.10 什么样的分类器是最好的？\t22  \n2.11大数据与深度学习的关系\t22  \n2.12 理解局部最优与全局最优\t23  \n2.13 理解逻辑回归\t24  \n2.14 逻辑回归与朴素贝叶斯有什么区别？\t24  \n2.15 为什么需要代价函数？\t25  \n2.16 代价函数作用原理 \t25  \n2.17 为什么代价函数要非负？\t26  \n2.18 常见代价函数？\t26  \n2.19为什么用交叉熵代替二次代价函数\t28  \n2.20 什么是损失函数？\t28  \n2.21 常见的损失函数\t28  \n2.22 逻辑回归为什么使用对数损失函数？\t30  \n0.00 对数损失函数是如何度量损失的？\t31  \n2.23 机器学习中为什么需要梯度下降？\t32  \n2.24 梯度下降法缺点？\t32  \n2.25 梯度下降法直观理解？\t32  \n2.23 梯度下降法算法描述？\t33  \n2.24 如何对梯度下降法进行调优？\t35  \n2.25 随机梯度和批量梯度区别？\t35  \n2.26 各种梯度下降法性能比较\t37  \n2.27计算图的导数计算图解？\t37  \n2.28 线性判别分析（LDA）思想总结\t39  \n2.29 图解LDA核心思想\t39  \n2.30 二类LDA算法原理？\t40  \n2.30 LDA算法流程总结？\t41  \n2.31 LDA和PCA区别？\t41  \n2.32 LDA优缺点？\t41  \n2.33 主成分分析（PCA）思想总结\t42  \n2.34 图解PCA核心思想\t42  \n2.35 PCA算法推理\t43  \n2.36 PCA算法流程总结\t44  \n2.37 PCA算法主要优缺点\t45  \n2.38 降维的必要性及目的\t45  \n2.39 KPCA与PCA的区别？\t46  \n2.40模型评估\t47  \n2.40.1模型评估常用方法？\t47  \n2.40.2 经验误差与泛化误差\t47  \n2.40.3 图解欠拟合、过拟合\t48  \n2.40.4 如何解决过拟合与欠拟合？\t49  \n2.40.5 交叉验证的主要作用？\t50  \n2.40.6 k折交叉验证？\t50  \n2.40.7 混淆矩阵\t50  \n2.40.8 错误率及精度\t51  \n2.40.9 查准率与查全率\t51  \n2.40.10 ROC与AUC\t52  \n2.40.11如何画ROC曲线？\t53  \n2.40.12如何计算TPR，FPR？\t54  \n2.40.13如何计算Auc？\t56  \n2.40.14为什么使用Roc和Auc评价分类器？\t56  \n2.40.15 直观理解AUC\t56  \n2.40.16 代价敏感错误率与代价曲线\t57  \n2.40.17 模型有哪些比较检验方法\t59  \n2.40.18 偏差与方差\t59  \n2.40.19为什么使用标准差？\t60  \n2.40.20 点估计思想\t61  \n2.40.21 点估计优良性原则？\t61  \n2.40.22点估计、区间估计、中心极限定理之间的联系？\t62  \n2.40.23 类别不平衡产生原因？\t62  \n2.40.24 常见的类别不平衡问题解决方法\t62  \n2.41 决策树\t64  \n2.41.1 决策树的基本原理\t64  \n2.41.2 决策树的三要素？\t64  \n2.41.3 决策树学习基本算法\t65  \n2.41.4 决策树算法优缺点\t65  \n2.40.5熵的概念以及理解\t66  \n2.40.6 信息增益的理解\t66  \n2.40.7 剪枝处理的作用及策略？\t67  \n2.41 支持向量机\t67  \n2.41.1 什么是支持向量机\t67  \n2.25.2 支持向量机解决的问题？\t68  \n2.25.2 核函数作用？\t69  \n2.25.3 对偶问题\t69  \n2.25.4 理解支持向量回归\t69  \n2.25.5 理解SVM（核函数）\t69  \n2.25.6 常见的核函数有哪些？\t69  \n2.25.6 软间隔与正则化\t73  \n2.25.7 SVM主要特点及缺点？\t73  \n2.26 贝叶斯\t74  \n2.26.1 图解极大似然估计\t74  \n2.26.2 朴素贝叶斯分类器和一般的贝叶斯分类器有什么区别？\t76  \n2.26.4 朴素与半朴素贝叶斯分类器\t76  \n2.26.5 贝叶斯网三种典型结构\t76  \n2.26.6 什么是贝叶斯错误率\t76  \n2.26.7 什么是贝叶斯最优错误率\t76  \n2.27 EM算法解决问题及实现流程\t76  \n2.28 为什么会产生维数灾难？\t78  \n2.29怎样避免维数灾难\t82  \n2.30聚类和降维有什么区别与联系？\t82  \n2.31 GBDT和随机森林的区别\t83  \n2.32 四种聚类方法之比较\t84  \n## 第三章 深度学习基础\t88  \n3.1基本概念\t88  \n3.1.1神经网络组成？\t88  \n3.1.2神经网络有哪些常用模型结构？\t90  \n3.1.3如何选择深度学习开发平台？\t92  \n3.1.4为什么使用深层表示\t92  \n3.1.5为什么深层神经网络难以训练？\t93  \n3.1.6深度学习和机器学习有什么不同\t94  \n3.2 网络操作与计算\t95  \n3.2.1前向传播与反向传播？\t95  \n3.2.2如何计算神经网络的输出？\t97  \n3.2.3如何计算卷积神经网络输出值？\t98  \n3.2.4如何计算Pooling层输出值输出值？\t101  \n3.2.5实例理解反向传播\t102  \n3.3超参数\t105  \n3.3.1什么是超参数？\t105  \n3.3.2如何寻找超参数的最优值？\t105  \n3.3.3超参数搜索一般过程？\t106  \n3.4激活函数\t106  \n3.4.1为什么需要非线性激活函数？\t106  \n3.4.2常见的激活函数及图像\t107  \n3.4.3 常见激活函数的导数计算？\t109  \n3.4.4激活函数有哪些性质？\t110  \n3.4.5 如何选择激活函数？\t110  \n3.4.6使用ReLu激活函数的优点？\t111  \n3.4.7什么时候可以用线性激活函数？\t111  \n3.4.8怎样理解Relu（<0时）是非线性激活函数？\t 111  \n3.4.9 Softmax函数如何应用于多分类？\t112  \n3.5 Batch_Size\t113  \n3.5.1为什么需要Batch_Size？\t113  \n3.5.2 Batch_Size值的选择\t114  \n3.5.3在合理范围内，增大 Batch_Size 有何好处？\t114  \n3.5.4盲目增大 Batch_Size 有何坏处？\t114  \n3.5.5调节 Batch_Size 对训练效果影响到底如何？\t114  \n3.6 归一化\t115  \n3.6.1归一化含义？\t115  \n3.6.2为什么要归一化\t115  \n3.6.3为什么归一化能提高求解最优解速度？\t115  \n3.6.4 3D图解未归一化\t116  \n3.6.5归一化有哪些类型？\t117  \n3.6.6局部响应归一化作用\t117  \n3.6.7理解局部响应归一化公式\t117  \n3.6.8什么是批归一化（Batch Normalization）\t118  \n3.6.9批归一化（BN）算法的优点\t119  \n3.6.10批归一化（BN）算法流程\t119  \n3.6.11批归一化和群组归一化\t120  \n3.6.12 Weight Normalization和Batch Normalization\t120  \n3.7 预训练与微调(fine tuning)\t121  \n3.7.1为什么无监督预训练可以帮助深度学习？\t121  \n3.7.2什么是模型微调fine tuning\t121  \n3.7.3微调时候网络参数是否更新？\t122  \n3.7.4 fine-tuning模型的三种状态\t122  \n3.8权重偏差初始化\t122  \n3.8.1 全都初始化为0\t122  \n3.8.2 全都初始化为同样的值\t123  \n3.8.3 初始化为小的随机数\t124  \n3.8.4用1/sqrt(n)校准方差\t125  \n3.8.5稀疏初始化(Sparse Initialazation)\t125  \n3.8.6初始化偏差\t125  \n3.9 Softmax\t126  \n3.9.1 Softmax定义及作用\t126  \n3.9.2 Softmax推导\t126  \n3.10 理解One Hot Encodeing原理及作用？\t126  \n3.11 常用的优化器有哪些\t127  \n3.12 Dropout 系列问题\t128  \n3.12.1 dropout率的选择\t128  \n3.27 Padding 系列问题\t128  \n## 第四章 经典网络\t129  \n4.1LetNet5\t129  \n4.1.1模型结构\t129  \n4.1.2模型结构\t129  \n4.1.3 模型特性\t131  \n4.2 AlexNet\t131  \n4.2.1 模型结构\t131  \n4.2.2模型解读\t131  \n4.2.3模型特性\t135  \n4.3 可视化ZFNet-解卷积\t135  \n4.3.1 基本的思想及其过程\t135  \n4.3.2 卷积与解卷积\t136  \n4.3.3卷积可视化\t137  \n4.3.4 ZFNe和AlexNet比较\t139  \n4.4 VGG\t140  \n4.1.1 模型结构\t140  \n4.1.2 模型特点\t140  \n4.5 Network in Network\t141  \n4.5.1 模型结构\t141  \n4.5.2 模型创新点\t141  \n4.6 GoogleNet\t143  \n4.6.1 模型结构\t143  \n4.6.2 Inception 结构\t145  \n4.6.3 模型层次关系\t146  \n4.7 Inception 系列\t148  \n4.7.1 Inception v1\t148  \n4.7.2 Inception v2\t150  \n4.7.3 Inception v3\t153  \n4.7.4 Inception V4\t155  \n4.7.5 Inception-ResNet-v2\t157  \n4.8 ResNet及其变体\t158  \n4.8.1重新审视ResNet\t159  \n4.8.2残差块\t160  \n4.8.3 ResNet架构\t162  \n4.8.4残差块的变体\t162  \n4.8.5 ResNeXt\t162  \n4.8.6 Densely Connected CNN\t164  \n4.8.7 ResNet作为小型网络的组合\t165  \n4.8.8 ResNet中路径的特点\t166  \n4.9为什么现在的CNN模型都是在GoogleNet、VGGNet或者AlexNet上调整的？\t167  \n## 第五章 卷积神经网络(CNN)\t170  \n5.1 卷积神经网络的组成层\t170  \n5.2 卷积如何检测边缘信息？\t171  \n5.2 卷积的几个基本定义？\t174  \n5.2.1卷积核大小\t174  \n5.2.2卷积核的步长\t174  \n5.2.3边缘填充\t174  \n5.2.4输入和输出通道\t174  \n5.3 卷积网络类型分类？\t174  \n5.3.1普通卷积\t174  \n5.3.2扩张卷积\t175  \n5.3.3转置卷积\t176  \n5.3.4可分离卷积\t177  \n5.3 图解12种不同类型的2D卷积？\t178  \n5.4 2D卷积与3D卷积有什么区别？\t181  \n5.4.1 2D 卷积\t181  \n5.4.2 3D卷积\t182  \n5.5 有哪些池化方法？\t183  \n5.5.1一般池化（General Pooling）\t183  \n5.5.2重叠池化（OverlappingPooling）\t184  \n5.5.3空金字塔池化（Spatial Pyramid Pooling）\t184  \n5.6 1x1卷积作用？\t186  \n5.7卷积层和池化层有什么区别？ \t187  \n5.8卷积核一定越大越好？\t189  \n5.9每层卷积只能用一种尺寸的卷积核？\t189  \n5.10怎样才能减少卷积层参数量？\t190  \n5.11卷积操作时必须同时考虑通道和区域吗？\t191  \n5.12采用宽卷积的好处有什么？ \t192  \n5.12.1窄卷积和宽卷积\t192  \n5.12.2 为什么采用宽卷积？\t192  \n5.13卷积层输出的深度与哪个部件的个数相同？ \t192  \n5.14 如何得到卷积层输出的深度？\t193  \n5.15激活函数通常放在卷积神经网络的那个操作之后？ \t194  \n5.16 如何理解最大池化层有几分缩小？\t194  \n5.17理解图像卷积与反卷积\t194  \n5.17.1图像卷积\t194  \n5.17.2图像反卷积\t196  \n5.18不同卷积后图像大小计算？\t198  \n5.18.1 类型划分\t198  \n5.18.2 计算公式\t199  \n5.19 步长、填充大小与输入输出关系总结？\t199  \n5.19.1没有0填充，单位步长\t200  \n5.19.2零填充，单位步长\t200  \n5.19.3不填充，非单位步长\t202  \n5.19.4零填充，非单位步长\t202  \n5.20 理解反卷积和棋盘效应\t204  \n5.20.1为什么出现棋盘现象？\t204  \n5.20.2 有哪些方法可以避免棋盘效应？\t205  \n5.21 CNN主要的计算瓶颈？\t207  \n5.22 CNN的参数经验设置\t207  \n5.23 提高泛化能力的方法总结\t208  \n5.23.1 主要方法\t208  \n5.23.2 实验证明\t208  \n5.24 CNN在CV与NLP领域运用的联系与区别？\t213  \n5.24.1联系\t213  \n5.24.2区别\t213  \n5.25 CNN凸显共性的手段？\t213  \n5.25.1 局部连接\t213  \n5.25.2 权值共享\t214  \n5.25.3 池化操作\t215  \n5.26 全卷积与Local-Conv的异同点\t215  \n5.27 举例理解Local-Conv的作用\t215  \n5.28 简述卷积神经网络进化史\t216  \n## 第六章 循环神经网络(RNN)\t218  \n6.1 RNNs和FNNs有什么区别？\t218  \n6.2 RNNs典型特点？\t218  \n6.3 RNNs能干什么？\t219  \n6.4 RNNs在NLP中典型应用？\t220  \n6.5 RNNs训练和传统ANN训练异同点？\t220  \n6.6常见的RNNs扩展和改进模型\t221  \n6.6.1 Simple RNNs(SRNs)\t221  \n6.6.2 Bidirectional RNNs\t221  \n6.6.3 Deep(Bidirectional) RNNs\t222  \n6.6.4 Echo State Networks（ESNs）\t222  \n6.6.5 Gated Recurrent Unit Recurrent Neural Networks\t224  \n6.6.6 LSTM Netwoorks\t224  \n6.6.7 Clockwork RNNs(CW-RNNs)\t225  \n## 第七章 目标检测\t228  \n7.1基于候选区域的目标检测器\t228  \n7.1.1滑动窗口检测器\t228  \n7.1.2选择性搜索\t229  \n7.1.3 R-CNN\t230  \n7.1.4边界框回归器\t230  \n7.1.5 Fast R-CNN\t231  \n7.1.6 ROI 池化\t233  \n7.1.7 Faster R-CNN\t233  \n7.1.8候选区域网络\t234  \n7.1.9 R-CNN 方法的性能\t236  \n7.2 基于区域的全卷积神经网络（R-FCN）\t237  \n7.3 单次目标检测器\t240  \n7.3.1单次检测器\t241  \n7.3.2滑动窗口进行预测\t241  \n7.3.3 SSD\t243  \n7.4 YOLO系列\t244  \n7.4.1 YOLOv1介绍\t244  \n7.4.2 YOLOv1模型优缺点？\t252  \n7.4.3 YOLOv2\t253  \n7.4.4 YOLOv2改进策略\t254  \n7.4.5 YOLOv2的训练\t261  \n7.4.6 YOLO9000\t261  \n7.4.7 YOLOv3\t263  \n7.4.8 YOLOv3改进\t264  \n## 第八章 图像分割\t269  \n8.1 传统的基于CNN的分割方法缺点？\t269  \n8.1 FCN\t269  \n8.1.1 FCN改变了什么?\t269  \n8.1.2 FCN网络结构？\t270  \n8.1.3全卷积网络举例？\t271  \n8.1.4为什么CNN对像素级别的分类很难？\t271  \n8.1.5全连接层和卷积层如何相互转化？\t272  \n8.1.6 FCN的输入图片为什么可以是任意大小？\t272  \n8.1.7把全连接层的权重W重塑成卷积层的滤波器有什么好处？\t273  \n8.1.8反卷积层理解\t275  \n8.1.9跳级(skip)结构\t276  \n8.1.10模型训练\t277  \n8.1.11 FCN缺点\t280  \n8.2 U-Net\t280  \n8.3 SegNet\t282  \n8.4空洞卷积(Dilated Convolutions)\t283  \n8.4 RefineNet\t285  \n8.5 PSPNet\t286  \n8.6 DeepLab系列\t288  \n8.6.1 DeepLabv1\t288  \n8.6.2 DeepLabv2\t289  \n8.6.3 DeepLabv3\t289  \n8.6.4 DeepLabv3+\t290  \n8.7 Mask-R-CNN\t293  \n8.7.1 Mask-RCNN 的网络结构示意图\t293  \n8.7.2 RCNN行人检测框架\t293  \n8.7.3 Mask-RCNN 技术要点\t294  \n8.8 CNN在基于弱监督学习的图像分割中的应用\t295  \n8.8.1 Scribble标记\t295  \n8.8.2 图像级别标记\t297  \n8.8.3 DeepLab+bounding box+image-level labels\t298  \n8.8.4统一的框架\t299  \n##  第九章 强化学习\t301  \n9.1强化学习的主要特点？\t301  \n9.2强化学习应用实例\t302  \n9.3强化学习和监督式学习、非监督式学习的区别\t303  \n9.4 强化学习主要有哪些算法？\t305  \n9.5深度迁移强化学习算法\t305  \n9.6分层深度强化学习算法\t306  \n9.7深度记忆强化学习算法\t306  \n9.8 多智能体深度强化学习算法\t307  \n9.9深度强化学习算法小结\t307  \n## 第十章 迁移学习\t309  \n10.1 什么是迁移学习？\t309  \n10.2 什么是多任务学习？\t309  \n10.3 多任务学习有什么意义？\t309  \n10.4 什么是端到端的深度学习？\t311  \n10.5 端到端的深度学习举例？\t311  \n10.6 端到端的深度学习有什么挑战？\t311  \n10.7 端到端的深度学习优缺点？\t312  \n## 第十三章 优化算法\t314  \n13.1 CPU和GPU 的区别？\t314  \n13.2如何解决训练样本少的问题\t315  \n13.3 什么样的样本集不适合用深度学习?\t315  \n13.4 有没有可能找到比已知算法更好的算法?\t316  \n13.5 何为共线性, 跟过拟合有啥关联?\t316  \n13.6 广义线性模型是怎被应用在深度学习中?\t316  \n13.7 造成梯度消失的原因?\t317  \n13.8 权值初始化方法有哪些\t317  \n13.9 启发式优化算法中，如何避免陷入局部最优解？\t318  \n13.10 凸优化中如何改进GD方法以防止陷入局部最优解\t319  \n13.11 常见的损失函数？\t319  \n13.14 如何进行特征选择（feature selection）？\t321  \n13.14.1 如何考虑特征选择\t321  \n13.14.2 特征选择方法分类\t321  \n13.14.3 特征选择目的\t322  \n13.15 梯度消失/梯度爆炸原因，以及解决方法\t322  \n13.15.1 为什么要使用梯度更新规则？\t322  \n13.15.2 梯度消失、爆炸原因？\t323  \n13.15.3 梯度消失、爆炸的解决方案\t324  \n13.16 深度学习为什么不用二阶优化\t325  \n13.17 怎样优化你的深度学习系统？\t326  \n13.18为什么要设置单一数字评估指标？\t326  \n13.19满足和优化指标（Satisficing and optimizing metrics）\t327  \n13.20 怎样划分训练/开发/测试集\t328  \n13.21如何划分开发/测试集大小\t329  \n13.22什么时候该改变开发/测试集和指标？\t329  \n13.23 设置评估指标的意义？\t330  \n13.24 什么是可避免偏差？\t331  \n13.25 什么是TOP5错误率？\t331  \n13.26 什么是人类水平错误率？\t332  \n13.27 可避免偏差、几大错误率之间的关系？\t332  \n13.28 怎样选取可避免偏差及贝叶斯错误率？\t332  \n13.29 怎样减少方差？\t333  \n13.30贝叶斯错误率的最佳估计\t333  \n13.31举机器学习超过单个人类表现几个例子？\t334  \n13.32如何改善你的模型？\t334  \n13.33 理解误差分析\t335  \n13.34 为什么值得花时间查看错误标记数据？\t336  \n13.35 快速搭建初始系统的意义？\t336  \n13.36 为什么要在不同的划分上训练及测试？\t337  \n13.37 如何解决数据不匹配问题？\t338  \n13.38 梯度检验注意事项？\t340  \n13.39什么是随机梯度下降？\t341  \n13.40什么是批量梯度下降？\t341  \n13.41什么是小批量梯度下降？\t341  \n13.42怎么配置mini-batch梯度下降\t342  \n13.43 局部最优的问题\t343  \n13.44提升算法性能思路\t346  \n## 第十四章 超参数调整\t358  \n14.1 调试处理\t358  \n14.2 有哪些超参数\t359  \n14.3 如何选择调试值?\t359  \n14.4 为超参数选择合适的范围\t359  \n14.5 如何搜索超参数？\t359  \n## 第十五章 正则化\t361  \n15.1 什么是正则化？\t361  \n15.2 正则化原理？\t361  \n15.3 为什么要正则化？\t361  \n15.4 为什么正则化有利于预防过拟合？\t361  \n15.5 为什么正则化可以减少方差？\t362  \n15.6 L2正则化的理解？\t362  \n15.7 理解dropout 正则化\t362  \n15.8 有哪些dropout 正则化方法？\t362  \n15.8 如何实施dropout 正则化\t363  \n15.9 Python 实现dropout 正则化\t363  \n15.10 L2正则化和dropout 有什么不同？\t363  \n15.11 dropout有什么缺点？\t363  \n15.12 其他正则化方法？\t364  \n## 参考文献\t366  \n"
        }
      ]
    }
  ]
}