{
  "metadata": {
    "timestamp": 1736563067582,
    "page": 705,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zxlie/FeHelper",
      "stars": 5146,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0888671875,
          "content": "# 工程文件\n.idea\n.DS_Store\nnode_modules/\npackage-lock.json\noutput/apps/\noutput-firefox/"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.2763671875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at xianliezhao@foxmail.com. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0712890625,
          "content": "MIT License\n\nCopyright (c) 2019 zhaoxianlie（xianliezhao@foxmail.com）\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.671875,
          "content": "FeHelper For Chrome&Firefox&MS-Edge\n=============================\n\n\n![FeHelper](https://user-images.githubusercontent.com/865735/75407628-7399c580-594e-11ea-8ef2-00adf39d61a8.jpg)\n\n[![Google Chrome](https://img.shields.io/chrome-web-store/v/pkgccpejnmalmdinmhkkfafefagiiiad.svg?logo=Google%20Chrome&logoColor=red&color=blue)](https://chrome.google.com/webstore/detail/pkgccpejnmalmdinmhkkfafefagiiiad)\n[![Google Chrome](https://img.shields.io/chrome-web-store/stars/pkgccpejnmalmdinmhkkfafefagiiiad.svg?logo=Google%20Chrome&logoColor=red&color=blue)](https://chrome.google.com/webstore/detail/pkgccpejnmalmdinmhkkfafefagiiiad)\n[![Google Chrome](https://img.shields.io/chrome-web-store/users/pkgccpejnmalmdinmhkkfafefagiiiad.svg?logo=Google%20Chrome&logoColor=red&color=blue)](https://chrome.google.com/webstore/detail/pkgccpejnmalmdinmhkkfafefagiiiad)    \n\n\n## 一、官网地址\nhttps://www.baidufe.com/fehelper/index/index.html\n\n### 1、扩展示例\n![Web前端助手-FeHelper](https://user-images.githubusercontent.com/865735/75407048-020d4780-594d-11ea-9dd6-48f6d5774c2f.png)\n\n### 2、关于新版\n- 新版本的FeHelper，是以开放平台为思路的设计，详细了解FeHelper新版，可以参考链接：\n    - [FeHelper-开放平台版介绍文档](/README_NEW.md)\n    - [开放平台思路下的FeHelper-阿烈叔的博客](https://www.baidufe.com/item/5b1e07d6f5106b6907bc.html)\n- 新版本FeHelper在一个新的`私有仓储`，待打磨得足够细腻了，再考虑开源    \n\n![FeHelper新版](https://user-images.githubusercontent.com/865735/75334978-b5315e80-58c3-11ea-9af0-e593149b0f7c.png)\n\n\n## 二、扩展安装地址：\n\n### 1、Chrome web store地址（推荐）\nhttps://chrome.google.com/webstore/detail/pkgccpejnmalmdinmhkkfafefagiiiad?hl=zh-cn\n\n- 官网安装，你可能需要额外的梯子\n    - [谷歌访问助手（官方正式版）](http://www.ggfwzs.com/)\n    - [谷歌访问助手（发烧友破解版）](https://github.com/haotian-wang/google-access-helper)\n\n### 2、Microsoft Edge Addons\nhttps://microsoftedge.microsoft.com/addons/detail/feolnkbgcbjmamimpfcnklggdcbgakhe?hl=zh-CN\n\n- 如果你在使用Microsoft Edge浏览器的话，`可以直接安装`，不用翻墙\n\n\n### 3、Firefox Add-ons\n- FeHelper官网一键安装： https://www.baidufe.com/fehelper/index/index.html\n- GitHub下载xpi安装：[点击进入下载页](/apps/static/screenshot/xpi)\n\n### 4、crx文件下载=>本地安装(Chrome)\n- 官网下载：https://www.baidufe.com/fehelper\n- 翻墙下载：https://chrome-extension-downloader.com/?extension=pkgccpejnmalmdinmhkkfafefagiiiad\n- 本站下载：[点击进入下载页](/apps/static/screenshot/crx)\n\n\n## 三、扩展功能：\n> FeHelper功能会逐渐增加，所有新的工具会自动出现在`FH应用市场`，查看介绍，可以直接去官网： https://www.baidufe.com/fehelper/index/index.html\n\n- JSON自动美化（页面自动检测并格式化）\n- JSON手动美化（粘贴文本、手动格式化）\n- JSON比对工具（支持左右两个JSON片段进行键值对比较）\n- 字符串编解码（Unicode/UTF8/Base64/MD5）\n- 代码美化工具（HTML/CSS/JS/XML/SQL）\n- 代码压缩工具（HTML/CSS/JS）\n- 二维码生成器（支持当前页面、图片、链接、选中的文字生成QrCode）\n- 二维码解码器（支持网页二维码`右键`解码）\n- ChatGPT工具（可以让它帮你写代码、查资料、做分析、甚至帮你画一幅画）\n- 简易Postman（Api接口测试，模拟HEAD/GET/POST方式）\n- 网页滚动截屏（将当前整个网页转为图片并保存）\n- Markdown转换（支持Markdown与HTML的互转）\n- 页面取色工具（滑动鼠标随意取色）\n- Js正则表达式（正则测试、常用正则列表）\n- 时间(戳)转换（Unix戳与本地时间的互转）\n- 图片Base64（任意图片转DataURI格式）\n- 随机密码生成（任意字符、任意长度、随机生成）\n- 多维小工具集（进制转换、RGB/HEX颜色转换、Crontab、还款计算器等）\n- 网页油猴工具（网页特效、网页定制、脚本注入、自动刷新等）\n- 我的便签笔记（便签笔记，支持导出）\n- Excel2Json（Excel转Json工具）\n- Websocket（ws://的抓包调试工具）\n- ... 更多工具，请去官网查看：https://www.baidufe.com/fehelper/index/index.html\n\n### 四、使用方法\n- iCON点击后的Popup窗口模式\n- 页面右键菜单模式\n\n### 五、用户反馈渠道\n- 在线反馈：https://www.baidufe.com/fehelper/feedback.html\n- Mail反馈：xianliezhao@foxmail.com\n- Wechat反馈：398824681 <br>\n![阿烈叔的个人微信](https://user-images.githubusercontent.com/865735/75407547-3cc3af80-594e-11ea-9abf-6168b94547a1.png)\n\n### 六、一些样例\n- [点击进入查看>>](/apps/static/screenshot/crx)\n"
        },
        {
          "name": "README_NEW.md",
          "type": "blob",
          "size": 25.0634765625,
          "content": "# FeHelper（开放平台版）\n\n![FeHelper](https://user-images.githubusercontent.com/865735/75407628-7399c580-594e-11ea-8ef2-00adf39d61a8.jpg)\n\n## 一、序言\n鉴于Google Chrome官方强制要求的`插件单一用原则`，老版本（V2019.12）接到chrome webstore的整改通知；为保证用户能继续正常使用FeHelper，并且以后也尽可能少的对FeHelper进行提审，索性启动FeHelper的一次大升级，`支持所有工具热更新`。\n先了解一下啥是Google的单一用途原则，直接看Google官方的说明吧：https://developer.chrome.com/extensions/single_purpose\n\n## 二、新版思路\n- 原来的功能：可参加老版本Readme中的介绍 https://github.com/zxlie/FeHelper\n- 新版本功能：\n    - 包内仅保留JSON格式化工具，包含JSON页面自动检测并格式化、JSON内容手动格式化工具；以确保工具完全符合官方要求的「插件单一用途」原则\n    - 将FeHelper新版按`开放平台`的思路进行设计：插件平台化，其他老版本的所有工具，可在插件配置页面`选择性安装/更新/卸载`\n\n## 三、新版界面\n![FeHelper新版](https://user-images.githubusercontent.com/865735/75334978-b5315e80-58c3-11ea-9af0-e593149b0f7c.png)\n\n## 四、开放平台实现\n### 4.1 如何将插件配置页打造成`工具市场`，满足工具的上架、更新、卸载等操作？\n- 配置页增加远程服务接口，从服务器 https://www.baidufe.com 获取相关配置，用配置直接生成工具列表，配置格式如：\n```javascript\n{\n    newTools: { // 这里维护新上架、有更新的工具\n        'color-picker': {\n            name: '页面取色工具',      // 工具的名称\n            tips: '将光标移动到页面上需要取色的位置，单击确定即可取色', // 工具描述\n            noPage: true,            // true表示此工具无独立页面\n            contentScript: true,     // 是否有内容注入的脚本\n            contentScriptCss: false, // 是否注入Css\n            minVersion: '2020.02.0718', // 工具从FeHelper的哪个版本开始支持\n            menuConfig: [{          // 可以配置多个右键菜单\n                icon: '✑',          // 右键菜单的icon，也是工具的默认icon\n                text: '页面取色工具', // 右键菜单中的工具名称\n                onClick: function (info, tab) { // 右键菜单点以后的动作\n                    chrome.DynamicToolRunner({\n                        query: 'tool=color-picker',\n                        noPage: true\n                    });\n                }\n            }]\n        },\n        ...\n    },\n    \n    removeTools: [ // 需要下架的工具，直接在这里配置即可\n        'code-standards' \n    ]\n}\n```\n- 每次进入到配置页/工具市场，都会从服务器端拉取最新配置，该配置与本地已存储的配置进行比对，可检测到每个工具是否有更新、是否需下架等\n- 针对已安装的工具，会从服务器端再次检测html模板内容与本地是否一致，不一致则`小红点提示`此工具有更新；这里有个细节，无论html、js、还是css文件发生过变更，都能通过只检测html模板的方式发现，因为html模板中引用js/css文件url后，都增加了文件`md5戳`，如此可做到只更新实际发生变更的文件\n    \n### 4.2 通过市场安装的工具，如何解决`资源存储`的问题，并确保存储空间足够大？\n- 下载的工具包，包含html、js、css文件资源，所有内容都需要在本地进行存储，如果工具越来越多，本地存储占用的空间会越来越大\n- 即便是在chrome-extension中，`localStorage`的存储上限也是`5M`，所以不能用它来存储已下载/安装的工具资源\n- 最终选择`chrome.storage.local`，搭配`unlimitedStorage`权限，可很好的解决资源存储问题，且突破存储空间的限制\n\n### 4.3 如何突破插件对`包外资源加载并执行`的限制，以实现动态安装的工具可在Chrome插件中正常运行？\n- 由于`content-security-policy`的限制，chrome-extension不允许执行包外资源，也严格不允许出现`inline`的脚本执行\n- 也不能无节制的去调整`content-security-policy`，将权限一再放大，这样确实会带来安全性的问题，审核也不容易通过\n- 最终方案，是用一个`dynamic/index.html`页面作为载体，通过`url-query`从本地存储中获取工具内容、加载并运行\n- 以加载`二维码/解码`工具为例，FeHelper最终会打开`chrome-extension://{id}/dynamic/index.html?tool=qr-code`\n- dynamic/index.html页面本身的内容很简单，就是一行代码`<script src=\"index.js\" type=\"text/javascript\"></script>`，在这个`index.js`文件中来加载数据，参考核心代码：\n```javascript\n(() => {\n    // 从本地存储获取工具资源进行渲染执行\n    let renderMyTool = (toolName, Awesome) => {\n\n        Awesome.getToolTpl(toolName).then(html => {\n            \n            // 回执html界面\n            document.write(html);\n\n            // 分析并获取静态文件列表\n            let allJs = [], allCss = [];\n            document.querySelectorAll('dynamic[data-source]').forEach(elm => {\n               let fileType = elm.getAttribute('data-type');\n               let files = (elm.getAttribute('data-source') || '').split(',');\n\n               if (fileType === 'js') {\n                   allJs = allJs.concat(files);\n               } else {\n                   allCss = allCss.concat(files);\n               } \n            });\n\n            // 从本地存储中获取静态资源进行注入 & 执行\n            Promise.all([Awesome.StorageMgr.get(allCss), Awesome.StorageMgr.get(allJs)]).then(values => {\n                allCss = allCss.map(f => values[0][f]).join(' ');\n                if (allCss.length) {            // css内容可以直接inline注入\n                    let node = document.createElement('style');\n                    node.textContent = allCss;\n                    document.head.appendChild(node);\n                }\n                allJs = allJs.map(f => values[1][f]).join(';');\n                allJs.length && eval(allJs);    // js内容不能注入，可通过eval或者new Function的方式执行\n            });\n        });\n    };\n\n    // 从URL中获取工具名称\n    let toolName = new URL(location.href).searchParams.get('tool');\n    if (toolName) {\n        import('./awesome.js').then(dynamicModule => {\n            renderMyTool(toolName, dynamicModule.default);\n        });\n    } else {\n        chrome.runtime.openOptionsPage() && window.close();\n    }\n})();\n```\n- 如此，用户安装的二维码工具便可在FeHelper中正常运行 \n\n### 4.4 市场内工具包含`不同形式`：有独立界面形式、纯content-script形式、混合模式，平台如何支持？\n- 这里涉及到的是不同的工具表现形式，资源加载方式都不一样，`4.3`中讲到了独立界面形式的工具资源加载，下面说一下`content-script`的资源加载\n- 正常情况下，`content-script`的资源加载，都是`明码形式`在manifest.json中进行配置，如：\n```javascript\n\"content_scripts\": [{\n  \"matches\": [\n    \"http://*/*\",\n    \"https://*/*\",\n    \"file://*/*\"\n  ],\n  \"js\": [\n    \"static/vendor/jquery/jquery-3.3.1.min.js\",\n    \"content-script/index.js\",\n    ...\n  ],\n  \"css\": [\n      ...\n  ],\n  \"run_at\": \"document_end\",\n  \"all_frames\": false\n}]\n```\n- 如上，需要将js和css文件列表全都列出来，但是针对工具市场安装的应用，所有资源都属于`包外资源`，也非独立文件形式，这里就完全满足不了了\n- 最终解决思路：在`content_scripts`配置项中，只列出一个核心js文件`content-script/index.js`，其他动态安装的工具脚本，都通过它来动态载入：\n```javascript\n/* content-script/index.js 文件内容 */\n(() => {\n    chrome.runtime.sendMessage({\n        type: 'fh-dynamic-any-thing',\n        params: {\n            tabId: window.__FH_TAB_ID__ || null\n        },\n        func: ((params, callback) => {\n            Awesome.getInstalledTools().then(tools => {\n                let list = Object.keys(tools).filter(tool => tools[tool].contentScript);\n                let promiseArr = list.map(tool => Awesome.getContentScript(tool));\n                Promise.all(promiseArr).then(values => {\n                    let installedTools = {};\n                    values.forEach((v, i) => { installedTools[list[i]] = v; });\n                    return installedTools;\n                }).then(tools => {\n                    let jsCodes = [];\n                    Object.keys(tools).forEach(tool => {\n                        jsCodes.push(`(()=>{ ${tools[tool]} ; let f = window['${tool}ContentScript'];f&&f();})()`);\n                    });\n\n                    chrome.tabs.executeScript(params.tabId, { code: jsCodes.join(';') });\n                });\n            });\n            callback && callback();\n            return true;\n        }).toString()\n    });\n})();\n```\n- 对上面的代码实现做几个原理解释：\n    - content-script首先通过sendMessage的方式，告知`background`，当前tab需要获取content-script\n    - background收到消息并处理，遍历`获取所有已安装应用`的content-script内容\n    - 为保证每个应用独有的content-script不发生变量冲突，一律通过`闭包代码块`进行独立执行\n    - 所有content-script，通过`chrome.tabs.executeScript`一次性安全注入当前Tab，自动执行\n- 另外，这里没有提到`content-script-css`如何注入，其实这个工作交给了各自content-script-js自行完成，具体方法：\n```javascript\nchrome.runtime.sendMessage({\n    type: 'fh-dynamic-any-thing',\n    func: ((params, callback) => {\n        Awesome.getContentScriptCss('qr-code').then(css => chrome.tabs.insertCSS({code: css}));\n        callback && callback();\n        return true;\n    }).toString()\n});\n```\n- 以此，所有动态安装的工具，其内容脚本content-script都能完美的得到运行\n\n### 4.5 市场内工具与插件background之间的`消息通信`种类多样，如何提供统一接口进行支持？\n- chrome extension的核心，其实就是`消息通信`，包括background、popup、content-script之间的各种消息互通\n- 尤其content-script中，因为chrome-extension的限制，权限不足，很多操作必须由background来完成\n- 所以这里需要一个巧妙的设计，`能将操作虚拟的交给content-script`，原理简单，就是让background接受某一个固定类型的消息，执行`sender`传递过来的function-body：\n```javascript\nchrome.runtime.onMessage.addListener(function (request, sender, callback) {\n    // 从消息中获取 func 参数，转换成function实体，执行\n    if (request.type === 'fh-dynamic-any-thing') {\n        let func = new Function(`return ${request.func}`)();\n        typeof func === 'function' && func(request.params, callback);\n    }\n    \n    return true;\n});\n```\n- 有了这样一个Bridge，在各自的`content-script`中就可以编写任意的代码，直接执行（其实最终的执行还是background，只不过代码不用再hardcode到background中了），比如4.4中qr-code工具的css加载示例：\n```javascript\nchrome.runtime.sendMessage({\n    type: 'fh-dynamic-any-thing',\n    func: ((params, callback) => {\n        Awesome.getContentScriptCss('qr-code').then(css => chrome.tabs.insertCSS({code: css}));\n        callback && callback();\n        return true;\n    }).toString()\n});\n```\n- 或者更高级点儿的用法，把callback用起来（这里需要注意：func中的操作如果是异步的，则callback是拿不到参数的）\n```javascript\nchrome.runtime.sendMessage({\n    type: 'fh-dynamic-any-thing',\n    func: ((params, callback) => {\n        // 这里可以做任何事情 \n        let manifest = chrome.runtime.getManifest();\n        \n        // 最终结果在这里通知callback\n        callback && callback(manifest);\n        return true;\n    }).toString()\n}, manifest => {\n    // 这里已经拿到background中执行的结果，直接使用\n    alert(`当前插件版本号为：${manifest.version}`);    \n});\n```\n- 上面`func`参数指定的function，其实最终就是在background中执行的，只不过`background部分的代码可以由工具自己来管理`\n\n\n### 4.6 工具的`使用方式`分两种：Toolbar-Popup-Page模式、Page-Context-Menu模式，如何统一管理？\n- Toolbar-Popup-Page的模式，是直接在浏览器工具栏点击插件icon进行使用\n- Page-Context-Menu的模式，是通过右键菜单进行使用\n- 两种模式的渲染和执行过程完全不一样，需要一个统一的`任务管理器`进行管理，其实就是前面示例中已经提到的`chrome.DynamicToolRunner`，我们来看方法定义：\n```javascript\n/**\n * 任务管理器，通过它，统一实现FeHelper工具的任务分配和运行\n * @param  {Object}  configs      启动任务管理器所需要的配置项\n * @config {String}  tool         要打开的工具名称，默认就是dynamic\n * @config {String}  withContent  默认携带的内容，在打开工具以后可读取\n * @config {String}  query        请求参数，访问页面可以携带一些默认参数\n * @config {Boolean} noPage       是否无页面模式（默认false，即独立页面）\n * @constructor\n */\nchrome.DynamicToolRunner = async function (configs) {\n\n    let tool = configs.tool || MSG_TYPE.DYNAMIC_TOOL;\n    let withContent = configs.withContent;\n    let query = configs.query;\n\n    // 如果是noPage模式，则表名只完成content-script的工作，直接发送命令即可\n    if (configs.noPage) {\n        tool = new URL(`http://f.h?${query}`).searchParams.get('tool').replace(/-/g, '');\n        chrome.tabs.query({active: true, currentWindow: true}, tabs => {\n            if (/^(http(s)?|file):\\/\\//.test(tabs[0].url)) {\n                chrome.tabs.executeScript(tabs[0].id, {\n                    code: `window['${tool}NoPage'] && window['${tool}NoPage'](${JSON.stringify(tabs[0])});`\n                });\n            } else {\n                notifyText({\n                    message:'抱歉，此工具无法在当前页面使用！'\n                });\n            }\n        });\n        return;\n    }\n\n    chrome.tabs.create({\n        url: `${tool}/index.html?${query}`,\n        active: true\n    }, tab => {\n        withContent && setTimeout(function () {\n            chrome.tabs.sendMessage(tab.id, {\n                type: MSG_TYPE.TAB_CREATED_OR_UPDATED,\n                content: withContent,\n                event: tool\n            });\n        }, 300);\n    });\n};\n```\n- 上面是任务管理器的核心代码部分，举两个使用场景的例子：\n```javascript\n// test case 1: popup-page中唤起image-base64工具，并传递一个需要进行base64的图片地址\nchrome.DynamicToolRunner({\n    query : 'tool=image-base64',\n    withContent : 'https://www.baidu.com/img/bd_logo1.png'\n});\n\n// test case 2: popup-page中唤起color-picker工具，此工具无独立页面\nchrome.DynamicToolRunner({\n    query : 'tool=color-picker',\n    noPage : true\n});\n\n// test case 3: context-menu中唤起qr-code工具，并将需要生成二维码的内容传递到页面\nchrome.contextMenus.create({\n    title: '二维码生成器',\n    contexts: ['all'],\n    parentId: FeJson.contextMenuId,\n    onclick: function (info, tab) {\n        chrome.tabs.executeScript(tab.id, {\n            code: '(' + (function (pInfo) {\n                let linkUrl = pInfo.linkUrl;\n                let pageUrl = pInfo.pageUrl;\n                let imgUrl = pInfo.srcUrl;\n                let selection = pInfo.selectionText;\n                \n                return linkUrl || imgUrl || selection || pageUrl;\n                }).toString() + ')(' + JSON.stringify(info) + ')',\n            allFrames: false\n        }, function (contents) {\n            chrome.DynamicToolRunner({\n                withContent: contents[0],\n                query: `tool=qr-code`\n            });\n        });\n    }\n});\n\n```\n\n### 4.7 除作者外，第三方`开发者如何发布自己的应用`到FeHelper工具市场？\n- FeHelper工具市场内一个完整的工具（zip包），需要包含如下几个部分：\n```text\n- ${tool}文件夹              `必选`\n    - fh-config.js          `必选，具体配置项参考下文`\n    - index.html            `必选，要去双击可独立运行`\n    - index.js              `必选`\n    - index.css             `可选`\n    - content-script.js     `可选，除非config中配置了true`\n    - content-script.css    `可选，除非config中配置了true`\n    - other js/css files    `可选，需在index.html中显式引用`\n    - images                `禁止，如果需要可用base64替代`\n    - font                  `禁止，如果需要可用base64替代`\n```        \n- 附`fh-config.js`配置项说明，以FeHelper中默认提供的`hello-world`为例：\n```javascript\n(function () {\n    return {\n        \"hello-world\": {\n            \"name\": \"Hello world!\",      // 工具的名称\n            \"tips\": \"这是一个FH自定义工具的入门示例！一切都从Hello world开始，大家可体验，或下载后学习！\", // 工具描述\n            \"noPage\": true,             // true表示此工具无独立页面\n            \"contentScript\": true,      // 是否有内容注入的脚本\n            \"contentScriptCss\": false,  // 是否注入Css\n            \"minVersion\": \"2020.02.0718\", // 工具从FeHelper的哪个版本开始支持\n            \"menuConfig\": [{            // 可以配置多个右键菜单\n                \"icon\": \"웃\",            // 右键菜单的icon，也是工具的默认icon\n                \"text\": \"Hello world\",  // 右键菜单中的工具名称\n                \"onClick\": function (info, tab) {\n                    alert('你好，我是Hello world；这是一个无独立页面的功能，我的内容已经输出到控制台了哦！');\n                    chrome.DynamicToolRunner({\n                        query: \"tool=hello-world\",\n                        noPage: true\n                    });\n                }\n            }]\n        }\n    };\n})();\n```\n- 此工具在开发者自行测试通过后，可打zip包后，邮件给我（`阿烈叔`），格式：\n```text\n收件：xianliezhao@foxmail.com\n标题：【FeHelper新工具提审】+ 新工具名称\n正文：描述新工具的使用场景、使用方法，最好附操作gif图或者视频教程\n附件：工具zip包，可增加其他使用教程\n```\n- `工具提审在线化`：目前规划中，可取代邮件提审的形式\n\n## 五、FH开发者工具\n### 5.1 无图无真相\n![FH开发者工具预览](https://user-images.githubusercontent.com/865735/75334554-0b51d200-58c3-11ea-98bf-56cd74c2309a.png)\n![FH自带编辑器](https://user-images.githubusercontent.com/865735/75334604-1dcc0b80-58c3-11ea-8cd5-d7f3190c53c4.png)\n\n### 5.2 工具介绍\n- FH开发者工具能干什么？\n    - 简单说就是：你基本可以`零基础`、`1分钟`搞定一个FH工具！\n    - 可以直接开启并体验`Hello world！`工具，也可以直接`下载示例zip包`进行学习！\n    - 可以直接通过开发者工具的`界面向导`操作，创建一个简单/复杂的FH工具！\n    - 已经创建好的工具，可以`下载zip包`继续在本地开发！\n    - 你也可以直接下载zip包后，`分享`给其他小伙伴儿！\n    - 当然，如果你觉得你的工具很实用，你也可以下载zip包，直接`邮件提审`给我（阿烈叔）！\n- FH开发者工具的一些贴心功能\n    - 在线创建、在线Coding、`自动保存`、`实时生效`\n    - 在线编辑`fh-config`配置时，整个工具的文件列表也会自动实时生效\n    - 图标不好找？FH给你提供了一批`现成的字符图标`，点一下就能用！\n\n## 六、Open API\n> 建议安装`FH开发者工具`以后，直接拿`hello-world`示例来学习！\n\n### 6.1 chrome.* API\n- 官方提供的Api基本都可以用，可以直接去官网看： https://developer.chrome.com/extensions/devguide\n- 如果访问不了`chrome.com`，你可以用`360的插件开发者Api`来学习使用，也基本够用： http://open.chrome.360.cn/extension_dev/overview.html\n- 如果也不行看`360`的Api，你还可以看`baidu浏览器插件的开发者Api`，也差不多够用： https://chajian.baidu.com/developer/extensions/api_index.html\n\n### 6.2 在工具独立页面使用chrome.* API\n- 如果你的工具没有配置`noPage: true`，那么你可以在`index.html`引用的js文件中直接使用`chrome.*`API\n\n### 6.3 content-script.js\n- 只要你配置了`contentScript: true`，工具就一定需要有content-script.js脚本文件\n- content-script.js文件中，一定要显示的在window上绑定一个方法，以`hello-world`为例：\n```javascript\n/**\n * 注意这里的方法名称，其实是：window[`${toolName.replace(/[-_]/g,'')}ContentScript`];\n * @author 阿烈叔\n */\nwindow.helloworldContentScript = function () {\n    console.log('你好，我是来自FeHelper的工具Demo：hello world！');\n};\n```\n- 你完全不必要担心`window对象被污染`，因为content-script是在一个独立的沙箱内运行的，对网页的正常运行毫无影响\n- content-script.js文件中，基本是除了`chrome.runtime`API，其他的`chrome.*`是用不了的，如果实在要用，可以参考`6.5`的消息机制\n- 在content-script.js中，你可以进行任意的`DOM操作`，就跟你正常的coding一样\n\n### 6.4 关于noPage配置\n- 如果你配置了`noPage: true`，那你的工具也一定需要有content-script.js脚本文件\n- content-script.js文件中，一定要显示的在window上绑定一个方法，依然以`hello-world`为例：\n```javascript\n/**\n * 如果在 fh-config.js 中指定了 noPage参数为true，则这里必须定义noPage的接口方法，如：\n * 注意这里的方法名称，其实是：window[`${toolName.replace(/[-_]/g,'')}NoPage`];\n * @author 阿烈叔\n */\nwindow.helloworldNoPage = function (tabInfo) {\n    alert('你好，我是来自FeHelper的工具Demo：hello world！你可以打开控制台看Demo的输出！');\n    console.log('你好，我是来自FeHelper的工具Demo：', tabInfo);\n};\n```\n- 既然noPage和content-script都一样，那`为什么还要有noPage`这个东西？\n    - noPage指明的是：该工具无独立页面\n    - 点击下拉列表中的工具入口、或者右键菜单中点击工具入口，会执行`window.xxxNoPage`中的代码\n- noPage的应用有没有一些实用的例子？    \n    - 比如，FeHelper中提供的`网页取色工具`，就是一个noPage的应用，点击工具，直接在网页上呼出一个取色器\n    - 再比如，FeHelper中提供的`二维码解码`工具，在二维码图片上右击，可以直接对该二维码进行解码\n    \n### 6.5 消息通信\n- 消息机制主要是提供给`content-script.js`使用的，它提供了一种`内容脚本使用chrome.* API`的可行性，示例：\n```javascript\n// background 示例：在content-script.js中获取当前浏览器的所有tab\nchrome.runtime.sendMessage({\n    type: 'fh-dynamic-any-thing',\n    params: {\n        tabId: window.__FH_TAB_ID__ // 这是FH的内置变量，表示当前Tab的id\n    },\n    func: ((params, callback) => {\n        // TODO: 这里可以调用 chrome.* 的API，随便用。。。\n\n        // Case1：获取当前窗口的全部tab\n        chrome.tabs.query({currentWindow: true}, tabs => {\n            let jsonInfo = JSON.stringify(tabs);\n\n            // 注入到页面，注意看这里如何读取外面传进来的参数\n            chrome.tabs.executeScript(params.tabId, {\n                code: 'console.log(' + jsonInfo + ');'\n            });\n        });\n\n        callback && callback();\n        return true;\n    }).toString()\n});\n```\n\n### 6.6 content-script.css\n- 如果配置了`contentScriptCss: true`，那说明你的FH工具还需要`向页面注入CSS代码`\n- FeHelper `v2020.03.1210`版本开始，内容css将有FH自动加载，content-script.js中调用下面方法即可注入\n```javascript\n// 以页面代码自动美化工具为例，注意这里的方法名：window.${toolName}ContentScriptCssInject()\nwindow.codebeautifyContentScriptCssInject();\n```\n- 以下为老版本FH的内容css加载方式（向后兼容）\n- content-script.css的加载机制，是在content-script.js中通过`6.5`中介绍的消息机制来完成的\n- 依然以`hello-world`为例，看代码示例：\n```javascript\n// 注入css and html fragment\nchrome.runtime.sendMessage({\n    type: 'fh-dynamic-any-thing',\n    func: ((params, callback) => {\n        // 通过这个内置方法来获取css内容，并直接注入当前网页\n        Awesome.getContentScript('hello-world', true).then(cssText => {\n            chrome.tabs.insertCSS({\n                code: cssText,\n                runAt: 'document_end'\n            });\n        });\n        callback && callback();\n        return true;\n    }).toString()\n});\n```\n- 当然，要想在content-script中使用自定义的css，办法还有很多，可以定义`contentScriptCss: false`，通过在页面上直接`硬编码插入`的方式来完成，比如：\n```javascript\nlet cssText = `/* Your CSS Codes Here... */`;\nlet elStyle = document.createElement('style');\nelStyle.textContent = cssText;\ndocument.head.appendChild(elStyle);\n```\n\n## 七、意见反馈\n- 大家可在feedback中反馈、也可加群反馈、或者直接Mail给我\n- 最后，欢迎搭建使用 FeHelper ，希望`开放平台`思路的FeHelper能给大家带来快感！"
        },
        {
          "name": "README_TEST.md",
          "type": "blob",
          "size": 0.9951171875,
          "content": "## FeHelper测试说明书\n\n> 本教程主要用于 output/fehelper.zip 包的本地测试，日常使用的话，建议安装线上正式版（Chrome商店版）\n\n### 一、测试包安装\n1. 下载fehelper.zip包，文件路径：`output/fehelper.zip`\n2. 解压fehelper.zip包，建议解压到一个`安全的目录`，别无意间被删掉了\n3. 打开chrome浏览器，地址栏输入：`chrome://extensions/` 进入插件管理界面\n4. 右上角`开启开发者模式`，确保所有的插件可被管理\n5. 如果本机已安装过线上FeHelper正式版，请找到它，并且`禁用它`\n6. 上方找到`加载已解压的扩展程序`按钮，选择fehelper.zip的解压目录\n7. 完成本地包载入，FeHelper本地包安装成功\n\n\n### 二、测试内容反馈\n大家可以把测试过程中发现的问题，统一提交到这里：[https://github.com/zxlie/FeHelper/issues/192](https://github.com/zxlie/FeHelper/issues/192) ，我会尽快跟进并修复它，为大家提供更高质量的FeHelper！\n"
        },
        {
          "name": "apps",
          "type": "tree",
          "content": null
        },
        {
          "name": "gulpfile.js",
          "type": "blob",
          "size": 5.8388671875,
          "content": "/**\n * FeHelper Chrome Extension Builder By Gulp\n * @author zhaoxianlie\n */\n\nlet gulp = require('gulp');\n\nlet clean = require('gulp-clean');\nlet copy = require('gulp-copy');\nlet zip = require('gulp-zip');\nlet uglifyjs = require('gulp-uglify-es').default;\nlet uglifycss = require('gulp-uglifycss');\nlet htmlmin = require('gulp-htmlmin');\nlet jsonmin = require('gulp-jsonminify');\nlet fs = require('fs');\nlet through = require('through2');\nlet path = require('path');\nlet pretty = require('pretty-bytes');\nlet shell = require('shelljs');\nlet runSequence = require('run-sequence');\n\ngulp.task('clean', () => {\n    return gulp.src('output', {read: false}).pipe(clean({force: true}));\n});\n\ngulp.task('copy', () => {\n    return gulp.src(['apps/**/*.{gif,png,jpg,jpeg,cur,ico}', '!apps/static/screenshot/**/*']).pipe(copy('output'));\n});\n\ngulp.task('json', () => {\n    return gulp.src('apps/**/*.json').pipe(jsonmin()).pipe(gulp.dest('output/apps'));\n});\n\ngulp.task('html', () => {\n    return gulp.src('apps/**/*.html').pipe(htmlmin({collapseWhitespace: true})).pipe(gulp.dest('output/apps'));\n});\n\n// 合并 & 压缩 js\ngulp.task('js', () => {\n    let jsMerge = () => {\n        return through.obj(function (file, enc, cb) {\n            let contents = file.contents.toString('utf-8');\n\n            let merge = (fp, fc) => {\n\n                // 合并 __importScript\n                return fc.replace(/__importScript\\(\\s*(['\"])([^'\"]*)\\1\\s*\\)/gm, function (frag, $1, mod) {\n                    let mp = path.resolve(fp, '../' + mod + (/\\.js$/.test(mod) ? '' : '.js'));\n                    let mc = fs.readFileSync(mp).toString('utf-8');\n                    return merge(mp, mc + ';');\n                });\n            };\n\n            contents = merge(file.path, contents);\n            file.contents = new Buffer.from(contents);\n            this.push(file);\n            return cb();\n        })\n    };\n\n    return gulp.src('apps/**/*.js').pipe(jsMerge()).pipe(uglifyjs()).pipe(gulp.dest('output/apps'));\n});\n\n// 合并 & 压缩 css\ngulp.task('css', () => {\n\n    let cssMerge = () => {\n        return through.obj(function (file, enc, cb) {\n            let contents = file.contents.toString('utf-8');\n\n            let merge = (fp, fc) => {\n                return fc.replace(/\\@import\\s+(url\\()?\\s*(['\"])(.*)\\2\\s*(\\))?\\s*;?/gm, function (frag, $1, $2, mod) {\n                    let mp = path.resolve(fp, '../' + mod + (/\\.css$/.test(mod) ? '' : '.css'));\n                    let mc = fs.readFileSync(mp).toString('utf-8');\n                    return merge(mp, mc);\n                });\n            };\n\n            contents = merge(file.path, contents);\n            file.contents = new Buffer.from(contents);\n            this.push(file);\n            return cb();\n        })\n    };\n\n    return gulp.src('apps/**/*.css').pipe(cssMerge()).pipe(uglifycss()).pipe(gulp.dest('output/apps'));\n});\n\n// 清理冗余文件，并且打包成zip，发布到chrome webstore\ngulp.task('zip', () => {\n\n    // 读取manifest文件\n    let pathOfMF = './output/apps/manifest.json';\n    let manifest = require(pathOfMF);\n\n    manifest.name = manifest.name.replace('-Dev', '');\n    fs.writeFileSync(pathOfMF, JSON.stringify(manifest));\n\n    // ============压缩打包================================================\n    shell.exec('cd output/ && rm -rf fehelper.zip && zip -r fehelper.zip apps/ > /dev/null && cd ../');\n    let size = fs.statSync('output/fehelper.zip').size;\n    size = pretty(size);\n\n\n    console.log('\\n\\n================================================================================');\n    console.log('    当前版本：', manifest.version, '\\t文件大小:', size);\n    console.log('    去Chrome商店发布吧：https://chrome.google.com/webstore/devconsole');\n    console.log('================================================================================\\n\\n');\n\n});\n\n// 打包Firefox安装包\ngulp.task('firefox', () => {\n    shell.exec('rm -rf output-firefox && cp -r output output-firefox && rm -rf output-firefox/fehelper.zip');\n\n    // 清理掉firefox里不支持的tools\n    let rmTools = ['page-capture', 'color-picker', 'ajax-debugger', 'wpo', 'code-standards', 'ruler', 'remove-bg'];\n    shell.cd('output-firefox/apps');\n    shell.find('./').forEach(f => {\n        if (rmTools.includes(f)) {\n            shell.rm('-rf', f);\n            console.log('已删除不支持的工具：', f);\n        }\n    });\n    shell.cd('../../');\n\n    // 更新firefox所需的配置文件\n    let pathOfMF = './output-firefox/apps/manifest.json';\n    let manifest = require(pathOfMF);\n    manifest.description = 'FE助手：JSON工具、代码美化、代码压缩、二维码工具、网页定制工具、便签笔记，等等';\n    delete manifest.update_url;\n    manifest.applications = {\n        \"gecko\": {\n            \"id\": \"fehelper@baidufe.com\",\n            \"strict_min_version\": \"57.0\"\n        }\n    };\n    manifest.version = manifest.version.replace(/\\./, '') + 'stable';\n    manifest.content_scripts.splice(1,2);\n    fs.writeFileSync(pathOfMF, JSON.stringify(manifest));\n\n    shell.exec('cd output-firefox/apps && zip -r ../fehelper.xpi ./ > /dev/null && cd ../../');\n    let size = fs.statSync('output-firefox/fehelper.xpi').size;\n    size = pretty(size);\n\n    console.log('\\n\\nfehelper.xpi 已打包完成！');\n\n    console.log('\\n\\n================================================================================');\n    console.log('    当前版本：', manifest.version, '\\t文件大小:', size);\n    console.log('    去Chrome商店发布吧：https://addons.mozilla.org/zh-CN/developers/addon/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8B-fehelper/versions');\n    console.log('================================================================================\\n\\n');\n});\n\n// builder\ngulp.task('default', ['clean'], () => {\n    runSequence(['copy', 'css', 'js', 'html', 'json'], 'zip');\n});\n\ngulp.task('sync', () => {\n    gulp.src('apps/**/*').pipe(gulp.dest('output/apps'));\n});\n"
        },
        {
          "name": "output",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.951171875,
          "content": "{\n  \"name\": \"FeHelper\",\n  \"version\": \"1.0.0\",\n  \"description\": \"FeHelper-前端助手\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"crypto\": \"^1.0.1\"\n  },\n  \"devDependencies\": {\n    \"gulp\": \"^3.9.1\",\n    \"gulp-clean\": \"^0.4.0\",\n    \"gulp-copy\": \"^1.1.0\",\n    \"gulp-htmlmin\": \"^4.0.0\",\n    \"gulp-jsonminify\": \"^1.1.0\",\n    \"gulp-uglify-es\": \"^1.0.1\",\n    \"gulp-uglifycss\": \"^1.0.9\",\n    \"gulp-zip\": \"^4.1.0\",\n    \"pretty-bytes\": \"^4.0.2\",\n    \"run-sequence\": \"^2.2.1\",\n    \"shelljs\": \"^0.8.1\"\n  },\n  \"scripts\": {\n    \"watch\": \"gulp watch\",\n    \"build\": \"gulp\",\n    \"preinstall\": \"npx npm-force-resolutions\"\n  },\n  \"resolutions\": {\n    \"graceful-fs\": \"^4.2.4\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/zxlie/FeOnline.git\"\n  },\n  \"keywords\": [\n    \"fehelper\"\n  ],\n  \"author\": \"zhaoxianlie\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://www.baidufe.com/fehelper/feedback.html\"\n  },\n  \"homepage\": \"https://www.baidufe.com/fehelper\"\n}\n"
        }
      ]
    }
  ]
}