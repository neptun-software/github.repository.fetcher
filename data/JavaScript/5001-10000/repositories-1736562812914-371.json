{
  "metadata": {
    "timestamp": 1736562812914,
    "page": 371,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "veltman/flubber",
      "stars": 6699,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.037109375,
          "content": "node_modules/*\njunk/*\n.DS_Store\n*.log\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.07421875,
          "content": "junk/\ntest/\ndemos/\nbuild/flubber.js\nrollup.config.js\n.gitignore\n.travis.yml\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0576171875,
          "content": "language: node_js\nnode_js:\n  - \"7\"\n  - \"6\"\n  - \"5\"\n  - \"4\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2017 Noah Veltman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.62109375,
          "content": "[![Build Status](https://travis-ci.org/veltman/flubber.svg?branch=master)](https://travis-ci.org/veltman/flubber)\n\n# flubber\n\nSome best-guess methods for smoothly interpolating between 2-D shapes.\n\n![Flubber in action](https://user-images.githubusercontent.com/2120446/27014160-e0ce7c04-4ea7-11e7-8da4-5dde839290eb.gif)\n\n### Why?\n\nLet's say you want to animate between two SVG paths or canvas shapes in a visualization. If you plug in their coordinates or their path strings to something like `d3.transition()`, it might work if the shapes *correspond* to each other really well - for example, turning a triangle into a different triangle. But once your shapes don't really correspond, you'll get unpredictable results with weird inversions and sudden jumps.\n\nThe goal of this library is to provide a best-guess interpolation for any two arbitrary shapes (or collections of shapes) that results in a reasonably smooth animation, without overthinking it.\n\n### Installation\n\nIn a browser (exposes the `flubber` global):\n\n```html\n<script src=\"https://unpkg.com/flubber@0.3.0\"></script>\n```\n\nWith NPM:\n\n```sh\nnpm install flubber\n```\n\nAnd then import/require it:\n\n```js\nvar flubber = require(\"flubber\"); // Node classic\nimport { interpolate } from \"flubber\" // ES6\n```\n\n### How to use\n\nFlubber expects a shape input to be either an SVG path string or an array of `[x, y]` points (a \"ring\"):\n\n```js\n\"M100,100 L200,100 L150,200Z\" // A triangle as a path string\n[[100, 100], [200, 100], [150, 200]] // A triangle as a ring\n```\n\nFlubber methods return **interpolators**, functions that you can call later with a value from 0 to 1 to get back the corresponding shape, where 0 is the beginning of the animation and 1 is the end.\n\nUsing D3, usage could look something like:\n\n```js\nvar triangle = [[1, 0], [2, 2], [0, 2]],\n    pentagon = [[0, 0], [2, 0], [2, 1], [1, 2], [0, 1]];\n\nvar interpolator = flubber.interpolate(triangle, pentagon);\n\nd3.select(\"path\")\n    .transition()\n    .attrTween(\"d\", function(){ return interpolator; });\n```\n\nWithout D3, usage might look something like this:\n```js\n// Mixing and matching input types is OK\nvar triangle = \"M1,0 L2,2 L0,2 Z\",\n    pentagon = [[0, 0], [2, 0], [2, 1], [1, 2], [0, 1]];\n\nvar interpolator = flubber.interpolate(triangle, pentagon);\n\nrequestAnimationFrame(draw);\n\nfunction draw(time) {\n    var t = howFarAlongTheAnimationIsOnAScaleOfZeroToOne(time);\n    myPathElement.setAttribute(\"d\", interpolator(t));\n    if (t < 1) {\n        requestAnimationFrame(draw);\n    }\n}\n```\n\nNote: it doesn't matter whether your ring has a closing point identical to the first point.\n\n### API\n\n#### flubber.interpolate(fromShape, toShape [, options])\n\n`fromShape` and `toShape` should each be a ring or an SVG path string. If your path string includes holes or multiple shapes in a single string, everything but the first outer shape will be ignored.\n\nThis returns a function that takes a value `t` from 0 to 1 and returns the in-between shape:\n\n```js\nvar interpolator = flubber.interpolate(triangle, octagon);\n\ninterpolator(0); // returns an SVG triangle path string\ninterpolator(0.5); // returns something halfway between the triangle and the octagon\ninterpolator(1); // returns an SVG octagon path string\n```\n\n`options` can include the following keys:\n\n`string`: whether to output results as an SVG path string or an array of points. (default: `true`)  \n`maxSegmentLength`: the lower this number is, the smoother the resulting animation will be, at the expense of performance. Represents a number in pixels (if no transforms are involved). Set it to `false` or `Infinity` for no smoothing. (default: `10`)\n\n[.interpolate() in action with SVG paths as input](https://veltman.github.io/flubber/demos/basic-svg.html)\n\n[.interpolate() in action with GeoJSON coordinates as input](https://veltman.github.io/flubber/demos/basic-array.html)\n\n#### flubber.toCircle(fromShape, x, y, r[, options])\n\nLike `interpolate()`, but for the specific case of transforming the shape to a circle centered at `[x, y]` with radius `r`.\n\n```js\nvar interpolator = flubber.toCircle(triangle, 100, 100, 10);\n\ninterpolator(0); // returns an SVG triangle path string\ninterpolator(0.5); // returns something halfway between the triangle and the circle\ninterpolator(1); // returns a circle path string centered at 100, 100 with a radius of 10\n```\n\n[.toCircle() in action](https://veltman.github.io/flubber/demos/circles.html)\n\n#### flubber.toRect(fromShape, x, y, width, height[, options])\n\nLike `interpolate()`, but for the specific case of transforming the shape to a rectangle with the upper-left corner `[x, y]` and the dimensions `width` x `height`.\n\n```js\nvar interpolator = flubber.toRect(triangle, 10, 50, 100, 200);\n\ninterpolator(0); // returns an SVG triangle path string\ninterpolator(0.5); // returns something halfway between the triangle and the rectangle\ninterpolator(1); // returns a rectangle path string from [10, 50] in the upper left to [110, 250] in the lower right\n```\n\n[.toRect() in action](https://veltman.github.io/flubber/demos/rects.html)\n\n#### flubber.fromCircle(x, y, r, toShape[, options])\n\nLike `toCircle()` but reversed.\n\n#### flubber.fromRect(x, y, width, height, toShape[, options])\n\nLike `toRect()` but reversed.\n\n#### flubber.separate(fromShape, toShapeList[, options])\n\nIf you're trying to interpolate between a single shape and multiple shapes (for example, a group of three circles turning into a single big circle), this method will break your shapes into pieces so you can animate between the two sets.  This isn't terribly performant and has some quirks but it tends to get the job done.\n\n`fromShape` should be a ring or SVG path string, and `toShapeList` should be an array of them.\n\nThe options are the same as for `interpolate()`, with the additional option of `single`, which defaults to `false`.\n\nIf `single` is false, this returns an array of `n` interpolator functions, where `n` is the length of `toShapeList`.  If `single` is set to true this returns one interpolator that combines things into one giant path string or one big array of rings.\n\n```js\n// returns an array of two interpolator functions\nvar interpolators = flubber.separate(triangle, [square, otherSquare]);\n\nd3.selectAll(\"path\")\n    .data(interpolators)\n    .transition()\n    .attrTween(\"d\", function(interpolator) { return interpolator; });\n```\n\n[.separate() in action](https://veltman.github.io/flubber/demos/multiple-distinct.html)\n\n```js\n// returns a single interpolator function\nvar combinedInterpolator = flubber.separate(triangle, [square, otherSquare], { single: true });\n\n// This one path element will be two squares at the end\nd3.select(\"path\")\n    .transition()\n    .attrTween(\"d\", function() { return combinedInterpolator; });\n```\n\n[.separate({ single: true }) in action](https://veltman.github.io/flubber/demos/multiple.html)\n\n#### flubber.combine(fromShapeList, toShape[, options])\n\nLike `separate()` but reversed.\n\n#### flubber.interpolateAll(fromShapeList, toShapeList[, options])\n\nLike `separate()` or `combine()` but instead expects two arrays of shapes the same length (e.g. an array of three triangles turning into an array of three squares). The shapes will be matched up in the order of the arrays (the first `fromShapeList` item will turn into the first `toShapeList` item, and so on).\n\n[.interpolateAll() in action](https://veltman.github.io/flubber/demos/all-distinct.html)\n\n[.interpolateAll({ single: true }) in action](https://veltman.github.io/flubber/demos/all.html)\n\n#### flubber.toPathString(ring)\n\nA helper function for converting an array of points to an SVG path string.\n\n```js\nflubber.toPathString([[1, 1], [2, 1], [1.5, 2]]);\n// Returns \"M1,1L2,1L1.5,2Z\"\n```\n\n#### flubber.splitPathString(pathString)\n\nA helper function for splitting an SVG path string that might contain multiple shapes into an array of one-shape path strings.\n\n```js\nflubber.splitPathString(\"M1,1 L2,1 L1.5,2Z M3,3 L4,3 L3.5,4 Z\");\n// Returns [\"M1,1 L2,1 L1.5,2Z\", \"M3,3 L4,3 L3.5,4 Z\"]\n```\n\n### Examples\n\n*Note: most of these demos use D3 to keep the code concise, but this can be used with any library, or with no library at all.*\n\n[Morphing SVG paths](https://veltman.github.io/flubber/demos/basic-svg.html)\n\n[Morphing GeoJSON coordinates](https://veltman.github.io/flubber/demos/basic-array.html)\n\n[Morphing to and from circles](https://veltman.github.io/flubber/demos/circles.html)\n\n[Morphing to and from rectangles](https://veltman.github.io/flubber/demos/rects.html)\n\n[Morphing between one shape and multiple shapes](https://veltman.github.io/flubber/demos/multiple.html) (one element)\n\n[Morphing between one shape and multiple shapes](https://veltman.github.io/flubber/demos/multiple-distinct.html) (multiple elements)\n\n[Morphing between two sets of multiple shapes](https://veltman.github.io/flubber/demos/all.html)\n\n[Vanilla JS + Canvas](https://veltman.github.io/flubber/demos/vanilla-canvas.html)\n\n[Medley of different methods](https://veltman.github.io/flubber/demos/medley.html)\n\n### To do\n\n* Maintain original vertices when polygonizing a path string with curves\n* Add `force: true` option to collapse small additional polygons onto the perimeter of the largest\n* Support unclosed lines\n* Use curves between points for `fromCircle()` and `toCircle()`\n* Deal with holes?\n* Accept SVG elements as arguments instead of just path strings?\n* Add pre-simplification as an option\n* Simulated annealing or random swapping for multishape matching?\n\n### Video\n\n[OpenVisConf 2017 talk about shape interpolation](https://www.youtube.com/watch?v=PLc1y-gim_0)\n\n### Alternatives\n\n[react-svg-morph](https://github.com/gorangajic/react-svg-morph) - utility for morphing between two SVGs in React\n\n[GreenSock MorphSVG plugin](https://greensock.com/morphSVG) - GSAP shape morphing utility (costs money, not open source)\n\n[d3.geo2rect](https://github.com/sebastian-meier/d3.geo2rect) - a plugin for morphing between GeoJSON and a rectangular SVG grid\n\n[d3-interpolate-path](https://github.com/pbeshai/d3-interpolate-path) - a D3 interpolator to interpolate between two unclosed lines, for things like line chart transitions with mismatched data\n\n[Wilderness](https://github.com/colinmeinke/wilderness) - an SVG manipulation and animation library\n\n[Cirque](https://github.com/two-n/cirque) - JS utility for morphing between circles and polygons\n\n### Credits\n\nMany thanks to:\n\n* Mike Bostock for [D3](https://d3js.org/) and [TopoJSON](https://github.com/topojson/topojson)\n* Vladimir Agafonkin and Mapbox for [earcut](https://github.com/mapbox/earcut)\n* Roger Veciana Rovira for [svg-path-properties](https://github.com/rveciana/svg-path-properties)\n* Fontello for [svgpath](https://github.com/fontello/svgpath)\n* Rich Harris for [Rollup](https://github.com/rollup/rollup) and [Bublé](http://buble.surge.sh/)\n\n### License\n\nMIT License\n\nCopyright (c) 2017 Noah Veltman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 0.2626953125,
          "content": "export { default as interpolate } from \"./src/interpolate.js\";\nexport { separate, combine, interpolateAll } from \"./src/multiple.js\";\nexport { splitPathString, toPathString } from \"./src/svg.js\";\nexport { fromCircle, toCircle, fromRect, toRect } from \"./src/shape.js\";\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.50390625,
          "content": "{\n  \"name\": \"flubber\",\n  \"version\": \"0.4.2\",\n  \"description\": \"Best-guess methods for smoothly interpolating and animating between shapes.\",\n  \"main\": \"build/flubber.min.js\",\n  \"browser\": \"build/flubber.min.js\",\n  \"scripts\": {\n    \"test\": \"babel-tape-runner 'test/**-test.js'\",\n    \"pretest\": \"rm -rf build && mkdir build && rollup --config rollup.config.js\",\n    \"build\": \"npm run pretest && uglifyjs -m -c -- build/flubber.js > build/flubber.min.js\"\n  },\n  \"module\": \"index\",\n  \"jsnext:main\": \"index\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/veltman/flubber.git\"\n  },\n  \"keywords\": [\n    \"shape\",\n    \"morph\",\n    \"tween\",\n    \"svg\",\n    \"animation\",\n    \"triangulation\"\n  ],\n  \"author\": \"Noah Veltman (@veltman)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/veltman/flubber/issues\"\n  },\n  \"homepage\": \"https://github.com/veltman/flubber#readme\",\n  \"devDependencies\": {\n    \"babel-plugin-add-module-exports\": \"^0.2.1\",\n    \"babel-preset-env\": \"^1.4.0\",\n    \"babel-tape-runner\": \"^2.0.1\",\n    \"rollup\": \"^0.41.6\",\n    \"rollup-plugin-buble\": \"^0.15.0\",\n    \"rollup-plugin-commonjs\": \"^8.0.2\",\n    \"rollup-plugin-node-resolve\": \"^2.1.1\",\n    \"tape\": \"^4.6.3\",\n    \"uglify-js\": \"^2.8.20\"\n  },\n  \"dependencies\": {\n    \"d3-array\": \"^1.2.0\",\n    \"d3-polygon\": \"^1.0.3\",\n    \"earcut\": \"^2.1.1\",\n    \"svg-path-properties\": \"^0.2.1\",\n    \"svgpath\": \"^2.2.1\",\n    \"topojson-client\": \"^3.0.0\"\n  },\n  \"babel\": {\n    \"presets\": [\n      \"env\"\n    ],\n    \"plugins\": [\n      \"add-module-exports\"\n    ]\n  }\n}\n"
        },
        {
          "name": "rollup.config.js",
          "type": "blob",
          "size": 0.375,
          "content": "import commonjs from \"rollup-plugin-commonjs\";\nimport resolve from \"rollup-plugin-node-resolve\";\nimport buble from \"rollup-plugin-buble\";\n\nexport default {\n  entry: \"index.js\",\n  dest: \"build/flubber.js\",\n  format: \"umd\",\n  moduleName: \"flubber\",\n  plugins: [\n    resolve({\n      jsnext: true,\n      main: true\n    }),\n    commonjs({\n      sourceMap: false\n    }),\n    buble()\n  ]\n};\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}