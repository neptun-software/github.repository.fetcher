{
  "metadata": {
    "timestamp": 1736563068490,
    "page": 706,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "haraka/Haraka",
      "stars": 5142,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1025390625,
          "content": "root = true\n\n[*]\nend_of_line = lf\nindent_style = space\n\n[*.js]\nindent_size = 4\n\n[*.json]\nindent_size = 2\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.373046875,
          "content": ".DS_Store\n/node_modules\nhttp/node_modules\n.coveralls.yml\nHaraka-*.gz\n*~\nbower_components\ncoverage\n.nyc_output\n.idea\n/test/node_modules\n/test/queue/plain\n/test/queue/multibyte\n/test/test-queue\n/config/me\n/config/dhparams.pem\n/config/tls_cert.pem\n/config/tls_key.pem\n/package-lock.json\n/config/dhparams.pem\n/config/me\n/config/smtp.json\n/config/tls_cert.pem\n/config/tls_key.pem\n/queue\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0830078125,
          "content": "[submodule \".release\"]\n\tpath = .release\n\turl = git@github.com:msimerson/.release.git\n"
        },
        {
          "name": ".lgtm.yml",
          "type": "blob",
          "size": 0.0537109375,
          "content": "queries:\n  - exclude: js/automatic-semicolon-insertion\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.1513671875,
          "content": ".github\n.DS_Store\n.editorconfig\n.gitignore\n.gitmodules\n.lgtm.yml\nhttp/bower_components\nhttp/node_modules\nappveyor.yml\ncodecov.yml\n.codeclimate.yml\n.release"
        },
        {
          "name": ".release",
          "type": "commit",
          "content": null
        },
        {
          "name": "CONTRIBUTORS.md",
          "type": "blob",
          "size": 5.9365234375,
          "content": "# Contributors\n\nThis handcrafted artisinal software is brought to you by:\n\n| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/261635?v=4\"><br><a href=\"https://github.com/msimerson\">msimerson</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=msimerson\">1623</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/662371?v=4\"><br><a href=\"https://github.com/baudehlo\">baudehlo</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=baudehlo\">969</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/550490?v=4\"><br><a href=\"https://github.com/smfreegard\">smfreegard</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=smfreegard\">794</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/959600?v=4\"><br><a href=\"https://github.com/godsflaw\">godsflaw</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=godsflaw\">171</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/934254?v=4\"><br><a href=\"https://github.com/analogic\">analogic</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=analogic\">42</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/1674289?v=4\"><br><a href=\"https://github.com/Dexus\">Dexus</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=Dexus\">42</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/82041?v=4\"><br><a href=\"https://github.com/gramakri\">gramakri</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=gramakri\">37</a>)|\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/203240?v=4\"><br><a href=\"https://github.com/lnedry\">lnedry</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=lnedry\">25</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/748075?v=4\"><br><a href=\"https://github.com/celesteking\">celesteking</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=celesteking\">21</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/791972?v=4\"><br><a href=\"https://github.com/lpatters\">lpatters</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=lpatters\">20</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/366268?v=4\"><br><a href=\"https://github.com/chazomaticus\">chazomaticus</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=chazomaticus\">19</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/271024?v=4\"><br><a href=\"https://github.com/hayesgm\">hayesgm</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=hayesgm\">16</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/123708?v=4\"><br><a href=\"https://github.com/arlolra\">arlolra</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=arlolra\">16</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/1573133?v=4\"><br><a href=\"https://github.com/gauravaror\">gauravaror</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=gauravaror\">14</a>)|\n| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/260607?v=4\"><br><a href=\"https://github.com/typingArtist\">typingArtist</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=typingArtist\">14</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/158380?v=4\"><br><a href=\"https://github.com/darkpixel\">darkpixel</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=darkpixel\">12</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/11343494?v=4\"><br><a href=\"https://github.com/superman20\">superman20</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=superman20\">12</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/9887966?v=4\"><br><a href=\"https://github.com/KingNoosh\">KingNoosh</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=KingNoosh\">11</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/5229495?v=4\"><br><a href=\"https://github.com/tstonis\">tstonis</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=tstonis\">10</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/1746394?v=4\"><br><a href=\"https://github.com/wltsmrz\">wltsmrz</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=wltsmrz\">9</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/2176651?v=4\"><br><a href=\"https://github.com/fatalbanana\">fatalbanana</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=fatalbanana\">8</a>)|\n| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/231081?v=4\"><br><a href=\"https://github.com/EyePulp\">EyePulp</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=EyePulp\">8</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/81561?v=4\"><br><a href=\"https://github.com/Synchro\">Synchro</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=Synchro\">8</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/3957811?v=4\"><br><a href=\"https://github.com/gene-hightower\">gene-hightower</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=gene-hightower\">7</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/103802?v=4\"><br><a href=\"https://github.com/joshuathayer\">joshuathayer</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=joshuathayer\">6</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/8224508?v=4\"><br><a href=\"https://github.com/DarkSorrow\">DarkSorrow</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=DarkSorrow\">6</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/1521113?v=4\"><br><a href=\"https://github.com/hontas\">hontas</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=hontas\">5</a>)| <img height=\"80\" src=\"https://avatars.githubusercontent.com/u/1263856?v=4\"><br><a href=\"https://github.com/ricardopolo\">ricardopolo</a> (<a href=\"https://github.com/haraka/Haraka/commits?author=ricardopolo\">5</a>)|\n\n<sub>this file is maintained by [.release](https://github.com/msimerson/.release)</sub>\n"
        },
        {
          "name": "Changes.md",
          "type": "blob",
          "size": 62.396484375,
          "content": "# Changelog\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/).\n\n### Unreleased\n\n- deps(eslint): update to v9\n- docs(plugins/\\*.md): use \\# to indicate heading levels\n- deps(various): bump to latest versions\n- fix(outbound): in outbound hook_delivered, when mx.exchange contains\n  an IP, use mx.from_dns\n- fix(bin/haraka): fix for finding path to config/docs/Plugins.md\n\n### [3.0.5] - 2024-09-27\n\n#### Fixed\n\n- fix(q/lmtp): revert a refactoring error #3407\n- fix: install Plugins.md when haraka -i #3406\n- fix(haraka -h): add missing return for plugin list #3405\n- fix `no_tls_hosts` related docs & tests #3404\n- fix: install docs/Plugins.md when haraka -i installed\n- fix(changes): spelling correction #3397\n\n#### Changed\n\n- lint: remove deprecated semi-style rule\n- removed dependency on ldap plugins #3399\n- doc(tls.md): add note for no_tls_hosts for outbound\n- test(tls): add tests for no_tls_hosts for inbound & outbound\n- dep version bumps:\n  - haraka-email-message: 1.2.4, #3408\n  - nodemailer: 6.9.15\n  - nopt: 8.0.0\n  - tld: 1.2.2\n  - plugin-dkim: 1.0.7\n  - plugin-dns-list: 1.2.1\n  - plugin-elastisearch: 8.0.3\n  - test-fixtures: 1.3.8\n\n\n### [3.0.4] - 2024-08-21\n\n#### Added\n\n- doc: add CONTRIBUTORS #3312\n- tls_socket: `config/tls` dir loading is now recursive\n\n#### Changed\n\n- prefix node libs with 'node:' #3359\n- .gitignore: add config/me and config/*.pem\n- auth_base: enable disabling constrain_sender at runtime #3298\n- auth_base: skip constrain_sender when auth user has no domain #3319\n- avg: repackaged as NPM module #3347\n- bounce: repackaged plugin as NPM module #3341\n- clamd: repackaged plugin as NPM module\n- config/plugins: consistent formatting #3359\n- connection: check remote is connected before queue #3338\n  - improve log message for queue* hooks, fixes #2998\n  - support IPv6 when setting remote.is_private #3295\n  - in setTLS, replace forEach with for...of\n  - NOTE: remove a handful of 3.0 sunset property names #3315\n- contrib/plugin2npm.sh: fix path to package.json #3359\n- deps: bump all versions to latest #3303, #3344, #3391\n- dkim: repackaged as NPM module #3311\n- esets: repackaged as NPM module #3353\n- greylist: repackaged as NPM module\n- helo.checks: require a successful HELO/EHLO #3352\n- new NPM plugin dns-list, repackages dnsbl, dnswl, backscatterer #3313\n- when using message-stream, don't send default options #3290\n- rcpt_to.host_list: add connection ID to log messages #3322\n- line_socket: remove unused callback #3344\n- logger: don't load outbound (race condition). Instead, set name property #3322\n- logger: extend add_log_methods to Classes (connection, plugins, hmail) #3322\n- logger: when logging via `logger` methods, use short names #3322\n- logger: check Object.hasOwn to avoid circular deps\n- mail_from.resolvable: refactored, leaning on improved net_utils #3322\n  - fixes haraka/haraka-net-utils#88\n- messagesniffer: repackaged as NPM module\n- outbound\n  - check for local_mx only when default route is used #3307\n  - client_pool: use tls_socket directly (shed line_socket)\n  - client_pool: sock.name is now JSON of socket args\n  - client_pool.get_client & release_client: arity of 5 -> 2\n  - mx_lookup: make it async/await\n  - mx_lookup: deleted. Logic moved into net_utils #3322\n  - use net_utils.HarakaMx for get_mx parsing #3344\n  - emit log message when ignoring local MX #3285\n  - pass in config when initiating txn #3315\n  - minor es6 updates #3315, #3322\n  - logging improvements #3322\n    - was: [-] [core] [outbound] Failed to get socket: Outbound connection error: Error: connect ECONNREFUSED 172.16.16.14:25\n    - now: [A63B62DF-F3B8-4096-8996-8CE83494A188.1.1] [outbound] Failed to get socket: connect ECONNREFUSED 172.16.16.14:25\n  - shorter logger syntax: logger.loginfo -> logger.info\n  - remove log prefixes of `[outbound] `, no longer needed\n  - delete try_deliver_host. Use net_utils to resolve MX hosts to IPs #3322\n  - remove config setting ipv6_enabled #3322\n  - remove undocumented use of send_email with arity of 2. #3322\n  - encapsulate force_tls logic into get_force_tls #3322\n  - es6(async/promise): pre_send_trans_email_respond, process_delivery\n- queue/lmtp: refactored for DRY and improved readability #3322\n- smtp_client: pass connect_timeout, maybe fixes #3281\n- spamassassin: repackaged as NPM module #3348\n- style(es6): more for...of loops\n- deps: moved attachment, spf, & dkim into optional deps\n- doc(Plugins.md): update registry\n- doc(Outbound.md): improve GHFM formatting\n- remove last vestiges of header_hide_version (long ago renamed)\n- server.js: use the local logger methods\n  - es6(async): _graceful, get_smtp_server, setup_smtp_listeners\n  - replace async.eachLimit with Promise.all batches\n- status: replace async.map with Promise.allSettled\n- get Haraka version from utils.getVersion (which includes git id if running from repo)\n- tls_socket: remove secureConnection. Fixes #2743\n  - getSocketOpts is now async\n  - parse_x509 is now async\n  - shed dependency on caolin/async & openssl-wrapper\n  - get_certs_dir is now async\n    - completely refactored.\n- transaction: init with conn.init_transaction, always pass in cfg #3315\n- test: add a connection.response test case with DSN #3305\n- test: convert test runner to mocha\n- test: rename tests -> test (where test runner expect) #3340\n\n#### Fixed\n\n- fix(logger): refactor add_log_methods, don't set extra `loglog*` names\n- doc(connection): update rfc7001 URL\n- fix(bin/haraka): list NPM installed plugin #3310\n- fix(bin/haraka): get hook list from doc/Plugins #3306\n- fix(outbound): call cb even if no MX is found #3294\n- fix(helo.checks): declare reject.literal_mismatch as boolean #3293\n- fix(outbound): allow LHLO over insecure socket if TLS is forced #3278\n- fix(outbound): include return path param SMTPUTF8 when required #3289\n- fix(outbound): replace empty Message-ID header #3288\n- fix(outbound): don't send SNI servername when connecting to an IP\n- fix(outbound): chown queue dir after creation #3291\n- fix(server): async endpoint.bind() and await in server.js #3366\n- fix(outbound): get_mx DNS error handling #3376\n\n### [3.0.3] - 2024-02-07\n\n#### Added\n\n- feat(auth_vpopmaild): when outbound, assure the envelope domain matches AUTH domain #3265\n- doc(Plugins.md): add pi-queue-kafka #3247\n- feat(rabbitmq_amqplib): configurable optional queue arguments #3239\n- feat(clamd): add x-haraka-virus header #3207\n\n#### Fixed\n\n- Fix: add empty string as param to .join() on bounce. #3237\n- Update links in documentation #3234\n- fix(ob/hmail):Add filename to the error for easy debugging\n- fix(ob/queue): Ignore 'error.' prefixed files in the queue because corrupted\n\n#### Changed\n\n- docs(outbound): remove example of outbound_ip #3253\n- transaction: simplify else condition in add_data #3252\n- q/smtp_forward: always register get_mx hook #3204\n- dep(pi-es): bump version to 8.0.2 #3206\n- dep(redis): bump version to 4.6.7 #3193\n- dep(pi-spf): bump version to 1.2.4\n- dep(net-utils): bump version to 1.5.3\n- dep(pi-redis): bump version to 2.0.6\n- dep(tld): bump version to 1.2.0\n- remove defunct config files: lookup_rdns.strict.ini, lookup_rdns.strict.timeout, lookup_rdns.strict.whitelist, lookup_rdns.strict.whitelist_regex, rcpt_to.blocklist, rdns.allow_regexps, rdns.deny_regexps\n\n### [3.0.2] - 2023-06-12\n\n#### Fixed\n\n- feat(q_forward): add LMTP routing handling #3199\n- chore(q_forward): tighten up queue.wants handling #3199\n- doc(q_forward): improve markdown formatting #3199\n- helo.checks: several fixes, #3191\n- q/smtp_forward: correct path to next_hop #3186\n- don't leak addr parsing errors into SMTP conversation #3185\n- connection: handle dns.reverse invalid throws on node v20 #3184\n- rename redis command setex to setEx #3181\n\n#### Changed\n\n- test(helo.checks): add regression tests for #3191 #3195\n- connection: handle dns.reverse invalid throws on node v20\n- build(deps): bump ipaddr.js from 2.0.1 to 2.1.0 #3194\n- chore: bump a few dependency versions #3184\n- dns_list_base: avoid test failure when public DNS used #3184\n- doc(outbound.ini) update link #3159\n- doc(clamd.md) fixed spelling error #3155\n\n### [3.0.1] - 2023-01-19\n\n#### Fixed\n\n- fix(bin/haraka): set server.cfg and pass to conn, fixes #3143\n- fix(bin/haraka): correct error messages for help options #3142\n- fix: dkim_verify fails to find record #3149\n\n#### Changed\n\n- plugins: Add haraka-plugin-outbound-logger to registry #3146\n- dep(pi-spf): bump version 1.1.3 to 1.2.0\n\n### [3.0.0] - 2022-12-17\n\n#### Added\n\n- feat: prevent local delivery loop when target exchange resolves to a local hostname #3002\n- feat: format DKIM signature to multiline #2991\n\n#### Fixed\n\n- fix(tls): redis promise syntax for tls & ob/tls #3064\n- fix(attachment): error handling with complex archive #3035\n- fix(smtp_client): run \"secured\" once, fixes #3020\n- fix(smtp_client): add missing `$` char in front of interpolated string\n- fix(auth_proxy): run \"secured\" only once, improvement for #3022\n- fix(helo): remove multi-check from should_skip #3041\n- fix(outbound): outbound local mx check #3010\n- fix(outbound): prevent delivery loop when target MX resolves to local hostname #3002\n- fix(conn): socket can't be released when disconnect after DATA command #2994\n\n#### Changed\n\n- dep(generic-pool): remove pooling from outbound #3115\n- smtp_client: disable pooling in get_client_plugin, #3113\n- smtp_forward: restore ability to enable queue_outbound #3119\n- ./mailbody & ./mailheader moved to haraka-email-message #3071\n- config/plugins: update name of uribl plugin\n- doc(queue.js) spelling & grammar improvement #3051\n- doc(rails): add haraka-plugin-queue-rails #2995\n- doc(smtp.ini): correct spelling of SMTPUTF8 #2993\n- style(es6): use optional chaining when accessing transactions #2732\n- style(smtp_client): pass args as objects (was positional)\n- style(plugin/\\*): transaction guarding #3032\n- dep(spf): remove to separate plugin #3078\n- dep(iconv): removed, declared in haraka-email-message)\n- dep(haraka-plugin-redis)!: 1.0 -> 2.0 #3038\n- dep(redis)!: 3.1 -> 4.1 #3058\n- dep(generic-pool): remove pooling from outbound #3115\n- smtp_client: remove smtp_\\* pooling support in #3113\n- dep: bump plugin versions #3063\n- dep: bump haraka-plugin-asn from 1.0.9 to 2.0.0 #3062\n- dep(redis): 3.1 -> 4.1 #3058\n- dep(nopt): 5 -> 6.0.0 #3076\n- dep(haraka-plugin-fcrdns): 1.0.3 -> 1.1.0 #3076\n- dep(haraka-plugin-redis): 1.0 -> 2.0 #3038\n- dep(nodemailer): 6.7.0 to 6.7.2 #3000, #3004\n- dep: add explicit dependency on node-gyp 9\n- ci: github action tweaks #3047\n- chore: transaction guarding #3032\n- ci: enable windows node 16 testing #3036\n- chore: update phusion image #2988\n- chore: add lots of `if (!transaction) return` in places #2732\n- chore(test): build shims for windows-2022 & node on windows #3052\n- chore(test): restore CI tests to working order #3030\n- dkim_sign: reformat dkim signature to multi-line #2991\n- dkim_sign: remove spurious error logging #3034\n- tls: add force_tls option to the ToDo object\n- fix(banner): banner was inserted erroneously into text attachments\n- outbound: remove hardcoded AUTH PLAIN authorization identity\n- outbound: set acquireTimeoutMillis to prevent constant reconnect to unreachable servers\n- style(smtp_client): pass args as objects (was positional)\n- uribl: timeout DNS 1 second before plugin, #3077\n- uribl: load .ini config to plugin.cfg, add basic tests #3077\n\n### 2.8.28 - 2021-10-14\n\n#### Changes\n\n- breaking: dkim.js has changed the constructor opts\n- tls_socket: more flexible pem file parsing #2986\n  - move bad certs into different directory, avoid test suite noise\n- added ability to define a default relay in relay_dest_domains\n- spamassassin: replace msg_too_big & should_check with should_skip #2972\n- spamassassin: allow returning DENYSOFT on errors #2967\n- dep: use caret version range for all dependencies #2965\n- outbound: disable outbound to localhost by default #2952\n- connection error logging: use key-value pairs #2921\n- tls: change default to NOT send TLS client certs #2902\n- dep: redis is now a dependency #2896\n- use address-rfc2821 2.0.0\n- http: use CDN for bootstrap/jquery, drop bower #2891\n- drop support for node 10 #2890\n\n#### New features\n\n- tls: require secure and verified sockets for configured hosts/domains\n- DKIM plugin has got a couple of config options now\n- tls: add `no_starttls_ports` - an array of incoming ports where STARTTLS is not advertised\n- outbound: add local_mx_ok config #2952\n- skip plugins at runtime by pushing name into transaction.skip_plugins #2966\n- outbound: add ability to specify delay times for temporary fails in `temp_fail_intervals` #2969\n\n#### Fixes\n\n- bounce: correctly set fail recipients #2901\n- bounce: correctly set bounce recipients #2899\n- Get local_ip from getsockname() instead of server properties #2914\n- Received header TLS section adheres more closely to RFC 8314 #2903\n- use RFC-2045 Quoted-Printable in email message body\n- use RFC-2047 Q encoded-words in email headers\n\n### 2.8.27 - 2021-01-05\n\n#### Changes\n\n- bump verions of several dependencies #2888\n- propagate hmail notes to split copies #2887\n- log.ini: add json to list of formats in config doc #2881\n- exclude port 587 from TLS NO-GO feature #2875\n- strip _haraka-plugin-_ prefixes off plugin names in config/plugins #2873\n- pass smtp.ini config from Server into connections & transactions #2872\n\n#### New features\n\n- add ability to disable SMTPUTF8 advertisement #2866\n\n#### Fixes\n\n- assure headers.max_lines is initialized as integer #2878\n- require haraka-net-utils >= 1.2.2 #2876\n\n### 2.8.26 - 2020-11-18\n\n#### Changes\n\n- add config options for OAR & AR headers #2855\n- plugins.js: also strip haraka-plugin prefix from plugin.name #2846\n- smtp_forward/spamssassin: grab refs of conn/txn to avoid crashes due to lack of existence. #2847\n- outbound: add extended reason to bounce message #2843\n- hgrep: replaced perl script with shell script #2842\n- connection: send temp error when requested #2841\n- headers: updated deprecated messages #2845\n- hmail: socket.on -> socket.once #2838\n- hmail: check for zero length queue file #2835\n- outbound: add os.hostname() as default for outbound HELO #2813\n- use node v10's mkdir instead of mkdirp #2797\n- CI: drop appveyor and Travis #2784\n- lint: add 'prefer-template'\n- update async to version 3.2.0 #2764\n- update redis to version 3.0.0 #2759\n- remove deprecated max_unrecognized_commands from config #2755\n- CI: add ES2017 support, drop node 8 #2740\n- fix broken bannering on nested mime parts #2736\n- restore TLS version info, set correctly #2723\n- better error message when invalid HELO hostname is rejected\n- bring STARTTLS \"TLS NO-GO\" feature in line with Outbound's #2792\n- add listener for secureConnect #2828\n- removed plugins/data.headers to haraka-plugin-headers #2826\n- add zero-length queue size check\n- send temp instead of hard error when asked to by `unrecognized_command`\n\n#### New features\n\n- Allow web interface to be bound to unix socket #2768\n- tls: add configurable minVersion to tls socket options #2738\n- connection_close_message: added ability to override close connection message replacing `closing connection. Have a jolly good day.` #2730\n- add JSON format for logging #2739\n- support binding web interface to unix socket\n\n#### Fixes\n\n- check for punycode domain names when resolving MX, avoid crash #2861\n- wait until entire message is spooled when spool_after in use #2840\n- hmail: add missing space in temp_fail emitter #2837\n- fix outbound config reloading after outbound split #2802\n- smtp_forward: remove redundant outbound hook #2796\n- smtp_forward: this plugin does not use the queue_outbound hook anymore #2795\n- Fix connection pool not being unique when hosts and ports were equal between domains #2789\n- fix connection pool not being unique when hosts and ports were equal between domains #2788\n- Fix outbound.bounce_message To: header (and add Auto-Submitted) #2782\n- Fix support for DKIM signing when forwarding and aliasing is enabled #2776\n- Better error message when EHLO hostname does not have a dot #2775\n- fix bannering on nested mime parts #2737\n- TLS: don't abort loading certs in config/tls dir when an error is encountered. Process every cert file and then emit errors. #2729\n- restore TLS version, correctly #2723\n\n### 2.8.25 - 2019-10-11\n\n#### Changes\n\n- conn: remove TLS version from header #2648\n- Actually enforce using key for INTERNALCMD #2643\n- trans: assign conditions to named vars #2638\n- drop node.js v6 support #2632\n- conn: use is_local instead of localhost addr tests #2627\n- spamassassin: spamassassin: strip useless WS from tests #2624\n- es6: many updates #2615, #2674, #2680\n- systemctl: update service definition #2612\n- lint: bracket style to match newer eslint:recommended #2680\n- lint: use object shorthands (eslint:recommended) #2680\n- logger: use safer Object.prototype.hasOwnProperty #2680\n- outbound: permit # char in SMTP status code response #2689\n- dkim_sign: improve docs, add tests, es6 updates #2649\n- dkim_sign: restore default key signing feature #2649\n- tmp module: update to latest #2614\n- semver: update to latest #2616, #2651\n- async: update to latest #2653, #2664\n- repo cleanup: replaced deprecated plugins with list #2681\n- spf: es6 patterns, results.pass, test improvements, es6 patterns #2700\n\n#### New features\n\n- spf: add config option to fail on NONE #2644\n\n#### Fixes\n\n- mailheader: fully quality header name in \\_remove_more #2647\n- haraka: Connection.createConnection is not a constructor #2618\n- problems with japanese characters in body and part header #2675\n- toobusy: fix hook name (connect_pre -> connect) #2672\n- outbound: watch for socket timeouts #2687\n- outbound: permit # char prefix in SMTP status code response #2691\n- mailheader: strip whitespace between encoded-words #2702\n\n### 2.8.24 - Mar 12, 2019\n\n#### Changes\n\n- early_talker: skip if sender has good karma #2551\n- dockerfile: update to node 10 #2552\n- Update deprecated usages of Buffer #2553\n- early_talker: extend reasons to skip checking #2564\n- tls: add 'ca' option (for CA root file) #2571\n- outbound: little cleanups #2572\n- smtp_client: pass pool_timeout to new SMTPClient #2574\n- server: default to nodes=1 (was undefined) #2573\n- test/server: use IPv4 127.0.0.1 instead of localhost #2584\n- queue/smtp_*: add v3 upgrade notice and config setting #2585\n- spf: use the skip config for helo/ehlo checks #2587\n- spf: avoid 2nd EHLO evaluation if EHLO host is identical #2592\n- queue.js refactoring #2593\n- Log dkim_sign parse errors with connection ID #2596\n- Update ipaddr.js to the latest version #2599\n- make inactivity timeout match docs #2607\n\n#### New Features\n\n- Implement SIGTERM graceful shutdown if pid is 1 #2547\n- tls: require validated certs on some ports with requireAuthorized #2554\n- spamassassin: disable checks when requested #2564\n- clamd: permit skipping for relay clients #2564\n- outbound: exported outbound.temp_fail_queue, outbound.delivery_queue and add TimerQueue.discard()\n- status: new plugin #2577\n\n#### Fixes\n\n- mf.resolvable: reduce timeout by one second (so < plugin.timeout) #2544\n- LMTP blocks under stress #2556\n- invalid DKIM when empty body #2410\n- prevent running callback multiple times on TLS unix socket #2509\n- add missing callback when listing queue and empty directory\n- correct MIME parsing when charset: utf8 and encoding: 8bit #2582\n- spamassassin: default check flags to true #2583\n- smtp_client: destroy when connection gets conn timeout error #2604\n- on error and timeout, remove listeners and destroy conn. #2606\n\n### 2.8.23 - Nov 18, 2018\n\n#### Changes\n\n- tighten Haraka pattern in .gitignore #2542\n\n### 2.8.22 - Nov 17, 2018\n\n#### New Features\n\n- enable tls/ssl for rabbitmq amqplib plugin #2518\n\n#### Fixes\n\n- hmail: don't send RSET to LMTP #2530\n\n#### Changes\n\n- clamd: add check.authenticated, check.private_ip, check.local_ip option\n- use get_decoded on headers that may be encoded #2537\n- connection: move max_mime_part config load to connection init #2528\n- outbound: init TLS when we send email, not when old queue file is loaded #2503\n- relay: update port 465 doc #2522\n- hmail: log the correct err message #2531\n- ob/tls: consistently use obtls (vs plugin) for \"this\" name #2524\n- outbound: add domain to loginfo message #2523\n- Add connection.remote.is_local #2532\n- update license #2525\n- perf: move max_mime_parts config load to connection init #2529\n- update semver to version 5.6.0 #2517\n- added hint to encrypted file authentication #2514\n- dkim_sign: improved log messages #2499\n- ehlo_hello_message: config/ehlo_hello_message can be used to overwrite the EHLO/HELO msg replacing `, Haraka is at your service` #2498\n- connection: add connection.remote.is_local flag for detecting loopback and link local IPs\n- add .name to outbound TLS for logs #2492\n\n### 2.8.21 - Jul 20, 2018\n\n#### New Features\n\n- outbound: skip STARTTLS after remote host fails TLS upgrade #2429\n- dns_list_base: introduce global plugin.lookback_is_rejected flag #2422\n\n#### Fixes\n\n- replace all \\_ chars in hostnames with code points #2485\n- Don't die on invalid commands #2481\n- outbound: check list exists before attempting to use it #2478\n  - refactor outbound/hmail.process_ehlo_data #2488\n- tls: skip when redis is undefined #2472\n- Don't run delivered hook on LMTP fail #2470\n- Add tls_socket.load_tls_ini() to tls.register() #2465\n\n#### Changes\n\n- outbound/tls: make into a class #2474\n- plugins: clear timeout on cancel #2477\n- txn.parse_body consistently a boolean #2476\n- update ipaddr.js to version 1.8.0 #2468\n\n### 2.8.20 - Jun 29, 2018\n\n#### Fixes\n\n- data_headers: check defined-ness of hdr_address _after_ try/catch #2458\n- tls: remove tls.ini loading from plugins/tls #2459\n- tls: remove invalid opt from load_tls_ini #2456\n- outbound: escape values in HTML bounce correctly #2446\n- dkim_sign: catch exceptions when address-rfc2822 fails to parse From #2457\n\n#### Changes\n\n- logger: Add \"obj\" log param to log hook that contains log data by type #2425\n- logger: include outbound client ID in logging #2425\n- logger: allow specifying uuid in params when logging #2425\n\n### 2.8.19 - Jun 26, 2018\n\n#### New features\n\n- outbound: received_header=disabled supresses outbound Received header addition. #2409\n- auth_base.js: `check_plain_passwd` and `check_cram_md5_passwd` can now pass `message` and `code` to callback routine\n- spf: allow bypass for relay and AUTH clients #2417\n- spf: optionally add OpenSPF help text to rejection #2417\n- auth_base: prevent storing of AUTH password in connection.notes.auth_passwd by setting plugin.blackout_password. #2421\n\n#### Fixes\n\n- Mitigate MIME part explosion attack #2447\n- Always prefix ClamAV with a Received header #2407\n- plugins/data.headers.js: wrap address-rfc2822 header parse into try block #2373\n- tls_socket: as client, only apply TLS opts if config is valid #2414\n- when installing, creates config/me if missing #2413\n- queue/qmail-queue: fix a 2nd crash bug when client disconnects unexpectedly #2360\n- remove desconstruction of SMTP commands to prevent exception #2398\n- attstream: return self so that pipe() calls can be chained together. #2424\n- outbound: fix dotfile cleanup to consider platform-based prefix. #2395\n- outbound: fix handling of LMTP socket when a socket path is specified. #2376\n\n#### Changes\n\n- relay: move relay acl check to connect_init so flag is set earlier #2442\n- process_title: add total recipients, avg rcpts/msg, recipients/sec cur/avg/max and messages/conn #2389\n- when relaying is set in a transaction, don't persist beyond the transaction #2393\n- connection.set supports dot delimited path syntax #2390\n- remove deprecated (since 2.8.16) ./dsn.js\n- Add transaction.msg_status property that reflects message status. #2427\n- Add transaction.notes.proxy object that hold HAProxy details. #2427\n- spamassassin: make relay header configurable. #2418\n- deprecate max_unrecognized_commands plugin in favor of limit. #2402\n- xclient: add support for DESTADDR/DESTPORT. #2396\n\n### 2.8.18 - Mar 8, 2018\n\n#### New features\n\n- smtp_forward: domain configuration is now chosen based on domain_selector #2346\n\n#### Fixes\n\n- queue/qmail-queue: fix crash bug when client disconnects unexpectedly #2360\n- tls: fix crash bug in `unrecognized_command` hook\n- `dkim_key_gen.sh`: improve usability and parameter parsing #2355\n\n#### Changes\n\n- document `force_shutdown_timeout` and `graceful_shutdown` settings #2350\n\n### 2.8.17 - Feb 16, 2017\n\n#### New Features\n\n- SMTPS port is configurable #2269\n- smtp_forward: enable_outbound can be set per domain #2335\n\n#### Fixes\n\n- Fix ability to set log level to emerg #2128\n- outbound/hmail: use Buffer to correctly read binary file data + tests #2231\n- quarantine: consolidate 2x hook_init_master functions\n- tls_socket: restore SNI functionality, emit count of TLS certs #2293\n- fix smtp_client error handling #2298\n- fix outbound pools #2317\n- add openssl-wrapper as dependency #2320\n- replace \\_ chars in hostnames with code points #2324\n- add this.removeAllListeners('connection-error') #2323\n- Fix crashing on RSET #2328\n- Prevent data headers crit fail #2329\n- Fix undefined max_lines in log message #2337\n\n#### Changes\n\n- line_socket: remove superfluous function #2339\n- consistent end of function declaration semicolon #2336\n- connection: assure hostname is set #2338\n- smtp_client: Fix log message typo #2334\n- Update ipaddr.js to version 1.6.0 #2333\n- Warn on max_header_lines #2331\n- update jquery version #2322\n- plugins: add SRS plugin to registry #2318\n- tls_socket: only generate dhparam.pem on master process #2313\n- add ENOTFOUND to also check A record #2310\n- smtp_forward: correct config file name in docs #2309\n- reduce severity of iconv conversion failure #2307\n- Add txn UUID to \"250 Message Queued\" #2305\n- mailheader: reduce log level priority #2299\n- greylist: only log redis DB errors when exist #2295\n- data.headers: reduce undef MLM logerror to logdebug #2294\n- quarantine: consolidate 2x hook_init_master() #2292\n- move test_queue to queue/test #2291\n- in haraka plugin test mode, add server.notes #2248\n- outbound/hmail: refactor #2238\n- outbound/hmail: add JSON sanity test before JSON.parse #2231\n- outbound/index: use newer Buffer.from syntax #2231\n- outbound/hmail: make haraka queue files human friendly #2231\n- plugins/rcpt_to.ldap -> haraka-plugin-rcpt-ldap #2144\n- plugins/auth/auth_ldap -> haraka-plugin-auth-ldap #2144\n- plugins/smtp_forward: enable_outbound can be enabled/disabled for specific domains\n- auth_proxy: read TLS key and cert files from tls.ini #2212\n- README: typo fixes #2210\n- incorrect RCPT TO reply message #2227\n- Resolve decoding bug when root part is base64 encoded. #2204\n- Resolve base64 data truncation #2188\n- Fix damaged encoding when body is non-utf #2187\n- Fix disconnect hooks #2184\n- ability to set log level to emerg #2128\n- Improve docs for `Address` objects #2224\n- connection: replace 3x ternaries with get_remote() #2169\n- connection.local.host populated with hostname (from config/me) #2165\n- connection.local.info populated with Haraka/version #2196\n- npm packaged plugins:\n  - plugins/rcpt_to.ldap -> haraka-plugin-rcpt-ldap #2144\n  - plugins/auth/auth_ldap -> haraka-plugin-auth-ldap #2144\n  - plugins/graph -> haraka-plugin-graph #2185\n- config: replace ./config.js with haraka-config #2119\n- Replace concatenated strings with template literals (#2129) in:\n  - attachment #2260\n  - bin/spf #2129\n  - bin/dkimverify #2278\n  - connection #2129, #2243\n  - delay_deny #2264\n  - dkim #2216\n  - dsn #2265\n  - host_pool #2198, #2245\n  - logger #2277, #2246\n  - mailbody #2280\n  - max_unrecognised_commands #2171\n  - outbound/hmail #2259\n  - outbound/index #2249\n  - outbound/todo #2233\n  - plugins #2239\n  - plugins/aliases #2229\n  - plugins/attachment #2155\n  - plugins/auth_base #2252\n  - plugins/avg #2156\n  - plugins/backscatterer #2261\n  - plugins/bounce #2229\n  - plugins/clamd #2237\n  - plugins/connect.rdns_access #2262\n  - plugins/data.headers #2263\n  - plugins/data.uribl #2258\n  - plugins/helo.checks #2255\n  - plugins/rcpt_to.in_host_list #2253\n  - plugins/spamassassin #2256\n  - plugins/profile #2170\n  - plugins/rcpt_to.host_list_base #2254\n  - plugins/relay #2174\n  - plugins/relay_acl #2177\n  - plugins/spf #2266\n  - plugins/toobusy #2186\n  - plugins/xclient #2159\n  - rfc1869 #2160\n  - smtp_client #2129, #2208\n  - tests/host_pool #2159\n- use es6 destructuring (#2075) in:\n  - connection #2230\n  - dkim #2232\n- use es6 classes (#2133) in:\n  - attachment #2260\n  - attachment_stream #2215\n  - chunkemitter #2219\n  - dkim #2206\n  - dsn #2247\n  - host_pool #2194\n  - mailheader #2213\n  - mailbody #2213\n  - smtp_client #2221\n  - spf #2214\n  - tls_socket #2190\n  - timer_queue #2226\n  - outbound/hmail #2197\n  - outbound/todo #2233\n- Automatically set connection.remote.is_private when connection.remote.ip is set #2192\n- Add remove_msgid and remove_date options to outbound.send_email #2209\n- Add origin option to outbound.send_mail #2314\n\n### 2.8.16 - Sep 30, 2017\n\n#### Changes\n\n  - additional tests get var -> const/let medicine #2122\n  - move connection states into haraka-constants #2121\n  - lint: remove useless escapes #2117\n  - lint: switch no-var to error #2109\n  - rspamd: repackaged as NPM module #2106\n  - dsn: repackaged as NPM module haraka-dsn #2105\n  - outbound: add results when queueing #2103\n  - spamassassin: skip adding headers when value is empty #2102\n  - Replace console.log with stdout #2100\n  - update js-yaml to version 3.10.0 #2097\n  - repackage p0f plugin to NPM #2076\n  - ES6: replace var with const or let #2073\n\n#### New Features\n\n- Bounces can have an HTML part #2091\n\n#### Fixes\n\n- daemon cwd #2126\n- updated fcrdns plugin name passed to results #2115\n- tls: only apply default key/cert paths when undefined #2111\n- dkim_verify: fix formatting of auth results #2107\n- smtp_forward: consistently use queue.wants #2107\n- haraka was adding TLS header on non-TLS connection #2103\n- dkim typo fix #2101\n- fix rfc2231 parsing code to cope with continuation #2089\n\n### 2.8.15 - Sep 10, 2017\n\n#### Changes\n\n- Permit log settings to be set w/o LOG prefix #2057\n- additional results storing in smtp_forward and quarantine #2067\n- publish p0f plugin to NPM #2076\n- smtp_forward stores queue note at queue.wants #2083\n- Remove unused folders from installation #2088\n- smtp_forward stores queue note at queue.wants #2083\n- add get/set to conn/txn.notes #2082\n- additional results storing in smtp_forward and quarantine #2067\n- Permit log settings to be set w/o LOG prefix #2057\n- support INFO _and_ LOGINFO as config settings #2056\n- log.ini, new default location for log related settings #2054\n- dcc: replace with npm packaged version #2052\n- qmd: replace rcpt_to.qmail_deliverable with npm #2051\n- rspamd: pass SPF evaluation #2050\n- add logfmt support #2047\n- update ipaddr.js to version 1.5.0 #2037\n- update redis to version 2.8.0 #2033\n- disable graceful for SIGTERM #2028\n- add additional integration tests #2026\n- move most npm packaged plugins into optionalDependencies #2023\n\n#### New Features\n\n- TLS certificate directory (config/tls) #2032\n- plugins can specify a queue plugin & next_hop route #2067\n- connection/transaction notes now have get/set #2082\n\n#### Fixes\n\n- haraka cli will now create folders if they don't exist #2088\n- maybe fix for #1852 503 response #2064\n- crash when 'AUTH LOGIN' is sent after a successful auth #2039\n- docs: fixed swaks test command #2034\n- dkim: prevent dkim_verify from causing 'cannot pipe' #1693\n\n### 2.8.14 - Jul 26, 2017\n\n#### Changes\n\n- Fix auth plugin failure when re-selecting auth method #2000\n- don't crash Haraka when invalid YAML config encountered #2013\n- update semver to version 5.4.0 #2015\n- relay docs: correct the config file name #2012\n- rename config/xclient.hosts to match plugin & docs #2014\n- build_todo() is part of the outbound/index.js api #2016\n- update js-yaml to version 3.9.0 #2002\n- outbound/hmail: use WRITE_EXCL from haraka-constants #2011\n- replace plugins/log.elasticsearch with npm packaged #2004\n- Remove two spurious log statements #1989\n- access: rebuild blacklist upon change (vs supplement) #1990\n- deliver to qmail-queue with LF line endings (not CRLF) #1997\n- doc: add note that smtp_forward only supports STARTTLS #1988\n- import Plugins.md from v3 #1991\n- update async to 2.5.0 #1982\n- update iconv to 2.3.0 #1981\n- require node.js v6+ #1958\n- update ipaddr.js to 1.4.0 #1972\n- support newer address-rfc2822 #1970\n- update node-address-rfc2821 version to 1.1.1 #1968\n- outbound: be consistent with todo.domain #1960\n- bump haraka-results required version #1949\n- logger: load in a setImmediate call #1948\n- logger: strip intermediate \\n chars #1947\n- tls consistency cleanups #1851\n- Get pool config handling simplifcation #1868\n  - add integration test: send message w/smtp_client\n- replace some legacy code with es6 #1862\n- update async to version 2.2.0 #1863\n- update ipaddr.js to version 1.3.0 #1857\n- update redis to version 2.7.0 #1854\n- assure conn/tran still exists before storing results #1849\n- moved tls.ini parsing to net_utils #1848\n- smtp forward dest split routing #1847\n- rspamd: refactor complex condition into function #1840\n- block js attachments #1837\n- helo.checks: bring plugin into alignment with docs #1833\n- when proxy enabled, update remote.is_private too #1811\n- create an outbound queue filename handler #1792\n- replace fcrdns with npm package #1810\n- add an additional node_modules plugin search path #1805\n- Set graceful shutdown off by default #1927\n- Allow outbound pools to be disabled #1917\n- Outbound split and move into folder #1850\n- don't emit binary characters into the logs #1902\n- Add .editorconfig #1884\n- tls: remove interim variables #1871\n\n#### New Features\n\n- Use punycode domain (support SMTPUTF8) #1944\n- Added RabbitMQ vhost support #1866\n- clamav: allow \"Unknown Result\" and Socket Error to try next host #1931\n- outbound client certificates #1908\n- Implement the missing upgrade method on SMTPClient #1901\n- Remove typo from relay.md #1886\n\n#### Fixes\n\n- outbound: fix queue not loaded for single process #1941\n- outbound: Fix undefined variable platformDOT in hmail.js #1943\n- outbound: fix undefined FsyncWriteStream var #1953\n- Fix cluster messaging for node v6+ #1938\n- outbound: fix loading under cluster. #1934\n- Check pool exists before delete #1937\n- be more strict in attachment filename matching #1957\n- doc typo fix #1963\n- RabbitMQ: fix encoding of user and password string #1964\n- spf: improve modifier regexp #1859\n- rabbitmq doc typo in config file name #1865\n- URL to manual was 404, point to Plugins.md #1844\n- smtp_client: set idleTimeout to 1s < pool_timeout #1842\n- fix broken continuations #1843\n- doc error for the 'check.authenticated' setting in rspamd plugin #1834\n- emit _the_ result, not all of them #1829\n- fix outbound logger #1827\n- fix forwarding with client auth over TLS (forward to gmail) #1803\n- Don't blow the stack on qstat #1930\n- run dumped logs through log plugins, not console #1929\n- Fix path parsing bug on Windows platform #1919\n- helo: make sure list_re is defined before access #1903\n- TLS: handle case where OCSP server is unavailable #1880\n- rspamd: add missing 'default' keyword #1856\n- disable naïve comment stripping #1876\n\n### 2.8.13 - Feb 03, 2017\n\n#### Changes\n\n- new [haraka-plugin-limit](https://github.com/haraka/haraka-plugin-limit) #1785\n  - replaces plugin/limit, plugin/rate_limit, and haraka-plugin-outbound-rate-limit\n- p0f: skip on private IPs (normally empty) #1758\n- spf: skip for outbound when context != myself #1763\n- redis: plugins using redis can inherit redis config #1777\n- redis: replace plugins/redis with haraka-plugin-redis #1786\n- lint: require space before function declaration #1784\n- lint: added eslint:recommended #1790\n- logger: remove logger.colorize code for legacy node versions\n\n#### New Features\n\n- redis: add `redis_subscribe_pattern()` #1766\n- queue/discard: add ENV that permits discarding #1791\n\n#### Improvements\n\n- rspamd: improve response parsing #1770\n- restore Windows testing to working state #1755\n- elasticsearch: use UTC dates for index creation #1771\n- tls: fix dhparam usage example syntax #1774\n- typo: logerr -> logerror #1776\n- when generating long DKIM keys, include a BIND compatible folded key #1775\n- in haraka-test-fixtures, access results via fixtures.results #1783\n- integration test: end to end server testing #1791\n\n#### Fixes\n\n- spf: restore functionality for relay context=myself #1759\n- rate_limit:if incr creates a new record, assure it has a TTL #1781\n- tls: do not create a top level secureContext #1787\n- dnswl: swap lines to fix missing inherited methods #1793\n- dnswl: fix config loader callback syntax #1794\n- tests/plugins: unset process.env.HARAKA to avoid side effects that interfere with other tests\n- remove auth_flat_file sample auth user #1796\n\n### 2.8.12 - Jan 03, 2017\n\n#### Changes\n\n- plugin/karma -> npm packaged haraka-plugin-karma #1747\n- update generic-pool 2.4.2 -> 2.5.0\n\n#### New Features\n\n- Added option to bypass SpamAssassin headers' merge #1745\n\n#### Improvements\n\n- reduce severity of debug message #1744\n- fix misleading entries in config/tls.ini #1734\n- Misc. performance improvements #1738\n- set tls.sessionIdContext property (for Thunderbird compat) #1740\n\n#### Fixes\n\n- Swap lines to avoid clobbering response array #1743\n\n### 2.8.11 - Nov 24, 2016\n\n#### Changes\n\n- rename core_require to haraka_require #1708\n- move log.syslog to haraka-plugin-syslog #1698\n- remove tls.ini loading and is_no_tls_host to net_utils #1690\n- replace ./utils with npm packaged haraka-utils #1720\n- require node 4\n- karma: add .top TLD scoring #1714\n\n#### New Features\n\n- Implement OCSP Stapling #1724\n\n#### Improvements\n\n- show help for npm packaged plugins included in core #1698\n- use tls.connect for client #1682\n- bring port 465 SMTPS TLS config support on par with STARTTLS #1667\n- use tls.connect instead of createSecurePair #1678\n- redis: improve error handling in tests #\n- replace / path seperators with path.* for cross platform compat #1713\n\n#### Fixes\n\n- dkim_sign: per-domain key finding fixed #1707\n- Rspamd: restore spam report header #1702\n- auth/vpopmail: do not toString() when null #1695\n- fix outbound to avoid recursive reading key/cert after refactoring #1692\n- tls: fix option servername (not hostname) #1728\n- correct Auth-Results cleaning #1726\n- fix results for connection.remote_host and NXDOMAIN #1716\n\n### 2.8.10 - Oct 20, 2016\n\n#### Changes\n\n- use standard npm syntax for lint and tests #1646\n- remove ./net_utils to haraka-net-utils #1644\n- remove incorrect and unused spf.hello_host #1635\n- remove rogue DENYSOFT copy-pasta error #1634\n- update async to v2 #1545\n- remove plugin/dir support from base haraka #1668\n  - use node_modules_dir support instead\n- use TLSSocket instead of createSecurePair #1672\n- refactor plugins/tls #1670\n- moved watch plugin to npm as haraka-plugin-watch #1657\n- normalize proxy properties #1650\n\n#### New Features\n\n- added connection.remote.is_private boolean #1648\n- added additional TLS options (@typingArtist) #1651\n- added wildcard boolean support to config loader #1680\n- tls: allow multiple key and cert parameters for RSA+ECDSA #1663\n- permit specifying haraka plugins w/o haraka-plugin- prefix #1645\n  - in config/plugins and resultstore\n\n#### Improvements\n\n- connection.geoip replaced by haraka-plugin-geoip #1645\n- connection.asn replaced by haraka-plugin-asn #1645\n- permit specifying npm packaged plugins w/o haraka-plugin prefix #1647\n- normalized connection properties #1547, #1577\n- Rspamd: fix spambar for negative scores #1630\n- set connection.remote.is_private early\n  - replace calls to net_utils with remote.is_private test\n\n#### Fixes\n\n- Tidy-up graceful shutdown and fix for non-cluster mode #1639\n- Fix data.headers plugin crash #1641\n- Fix access plugin crash #1640\n- Minor DKIM fix #1642\n- do not set TLS timer if timeout=0 #1632\n- do not overwrite config/host_list on install #1637\n- correct smtp_forward cfg for multiple rcpts #1680\n- fix TLS timeout errors #1665\n\n### 2.8.9 - Oct 02, 2016\n\n#### New Features\n\n- Support outbound.pool_timeout of 0 to effectively disable pooling. #1561\n- Added never_add_headers option to rspamd plugin. #1562\n- rcpt_to.routes URI format w/ LMTP support #1568\n\n#### Improvements\n\n- The delay_deny plugin now has a whitelist mode (vs blacklist). #1564\n- Don't show the private key in logs for dkim_sign. #1565\n- update geoip for compat with newer ES (#1622)\n- drop node 0.10 testing / official support (#1621)\n- watch plugin displays UUIDs as URL (#1624)\n- Catch errors on header decode in rfc2231 #1599\n- Attachment plugin updates (#1606)\n- add outbound.ini pool_timeout example setting #1584\n\n#### Fixes\n\n- Fixed some small documentation issues. #1573, #1616, #1612\n- Fixed AUTH PLAIN when it spreads over two lines. #1550\n- Fixed dkim_verify calling next() too soon. #1566\n- Fixed bugs with outbound pools who shutdown before we QUIT. #1561, #1572\n- outbound issues #1615, #1603\n- Fixed adding/removing headers in rspamd plugin. #1562\n- Fixed process_title not shutting down. #1560\n- fix a spurious error emitted by p0f (#1623)\n- fix header version hiding (#1617)\n- messagestream returns destination (#1610)\n- plugins.getdenyfn now passed 3rd params arg (#1591)\n- Fix scope of spf logdebug (#1598)\n- fix rabbitmq deliveryMode bug (#1594)\n- fix dkim_sign TypeError with null mail_from.host (#1592)\n- fix dkim_sign attempting to lower an undefined (#1587)\n\n### 2.8.8 - Jul 20, 2016\n\n#### Changes\n\n- removed UPGRADE.doc to [wiki](https://github.com/haraka/Haraka/wiki/Upgrade-Haraka)\n\n#### Improvements\n\n- support + wildcard in aliases plugin #1531\n- Support dkim_sign with outbound.send_email() #1512\n- spf: always check remote IP, then public IP if != pass #1528\n- spf: diplay IP used for SPF eval #1528\n\n#### Fixes\n\n- handle missing wss section in http.ini #1542\n- fix leak on socket write error #1541\n- add results property to outbound transaction #1535\n- don't unref unref'd wss server #1521\n\n### 2.8.7 - Jun 18, 2016\n\n#### Changes\n\n- Fix geoip test\n\n#### Improvements\n\n- Allow alias plugin to explode to a list of aliases\n- Support IPv6 literals in HELO tests (#1507 thanks @gramakri)\n- Make ldap plugin use the modified address if a rcpt hook\n  changes it (#1501 thanks @darkpixel)\n\n#### Fixes\n\n- Fix loading plugins as npm modules (#1513)\n- More DKIM fixes (#1506 thanks @zllovesuki)\n- Fix the long failing host-pool-timer test (#1508)\n- Fix clean shutdown of redis with new shutdown code\n  (#1504 and #1502 thanks @darkpixel)\n- More fixes to clean shutdown (#1503)\n\n### 2.8.6 - Jun 06, 2016\n\n#### Fixes\n\n- Fix loading under Node v4 which sends a blank message\n- Fix quit (SIGINT) when running without nodes=\n\n### 2.8.5 - Jun 04, 2016\n\n#### Changes\n\n- The connection object is now passed to `get_plain_passwd`. Older modules should continue to work as-is.\n- The reseed_rng plugin now just uses the Crypto module from core. Though it seems this plugin should be irrelevant with newer versions of node.js\n\n#### New Features\n\n- Outbound mail now uses pooled connections, only sending a `QUIT` message if the connection has been idle for a while.\n\n#### Improvements\n\n- Shut down and reload (via `haraka -c <path> --graceful`) is now graceful - allowing current connections to finish and plugins to clean up before ending.\n\n#### Fixes\n\n- Bind maxmind version to ignore API change (#1492)\n- Fix encodings when banners are used (#1477)\n- Various DKIM fixes (#1495)\n\n### 2.8.4 - May 24, 2016\n\n#### Fixes\n\n- Fix plugin loading override when installed (#1471)\n\n### 2.8.3 - May 18, 2016\n\n#### Fixes\n\n- Fix config overriding for core modules (#1468)\n\n### 2.8.2 - May 17, 2016\n\n#### Changes\n\n- Added Node v6 to travis tests\n\n#### New Features\n\n- Added bin/haraka --qunstick <domain> to flush all mails\n    for that domain (#1460)\n\n#### Improvements\n\n- Make bin/haraka --qlist show much more information (#1452)\n- Allow CIDR ranges in no_tls_hosts (#1450)\n\n#### Fixes\n\n- 2.8.0 was shipped with a broken config/plugins. (#1453)\n- Stop haraka dying when ldap connections fail (#1456)\n- Pick up domain specific config correctly in ldap (#1456)\n\n### 2.8.0 - May 06, 2016\n\n#### Changes\n\n- updated dependency versions (#1426, #1425)\n- use utf8 encoding for body filters (#1429)\n- remove spameatingmonkey from tests (#1421)\n- replace ./constants.js with haraka-constants (#1353)\n- Document HMail and TODO items (#1343)\n- Copy only a minimal config/* by default (#1341).\n- cfreader/* removed to haraka/haraka-config (#1350)\n- outbound and smtp_client honor tls.ini settings (#1350)\n- outbound TLS defaults to enabled\n- lint: remove all unused variables (#1358)\n- replace ./address.js with address-rfc2181 (#1359)\n\n#### New Features\n\n- smtp_forward: accepts a list of backend hosts, thanks @kgeoss (#1333)\n- config: add array[] syntax to INI files (#1345)\n- plugins.js: support require('./config') in plugins\n- Load plugin config from own folder and merge (#1335)\n- Allow original email's Subject to be included in bounce message (#1337)\n- new queue/smtp_bridge plugin, thanks @jesucarr (#1351)\n\n#### Improvements\n\n- early_talker: supports IP whitelisting (#1423)\n- loading plugins as packages (#1278)\n- removed TLD stuff to haraka/haraka-tld (#1301)\n- removed unused 'require('redis') in plugins/karma (#1348)\n- improved MIME header support per rfc2231 (#1344)\n- tls options can be defined for outbound and smtp_* (#1357)\n- explicitly disable SSLv2 (#1395)\n- cache STUN results\n- xclient plugin improvements (#1405)\n- tls: Set verify=NO correctly when no certificate presented (#1400)\n- improved message header decoding (#1403, #1406)\n- bounce: skip single_recipient check for relays/private_ips (#1385)\n- rspamd docs: Clarify usage of check.private_ip (#1383)\n- if rcpt_to returns DSN in msg, log it properly (#1375)\n\n#### Fixes\n\n- fix out-of-range errors from banner insertion (#1334)\n- dkim_verify: Call next only after message_stream ended (#1330)\n- outbound: remove type check from pid match (#1322)\n- lint: enable no-shadown and remove all shadow variables (#1349)\n- spf: fix log_debug syntax (#1416)\n- auto_proxy: fix a starttls loop (#1392)\n- fcrdns: corrected err variable name (#1391)\n- rspamd: Fix undefined variable (#1396)\n- dkim_verify: Fix header handling (#1371)\n- smtp_client: fix remote_ip (#1362)\n\n### 2.7.3 - Feb 04, 2016\n\n#### Changes\n\n- smtp_proxy & qmail-queue: default to enabled for outbound deliveries (previously used Outbound), to better matches user expectations.\n\n#### New Features\n\n- outbound: allow passing notes to send_email (#1295)\n\n#### Improvements\n\n- logging: emit log message queue before shutting down (#1296)\n- result_store: permit redis pub/sub to work when host != localhost (#1277)\n- tests: quiet the extremely verbose messages (#1282)\n- rspamd: add timeout error handling (#1276)\n- watch: fix display of early_talker results (#1281)\n- spamassassin: publish results to result_store (#1280)\n- karma: can now connect to redis on hosts other than localhost (#1275)\n- geoip & p0f: don't log empty/null values from RFC 1918 connects (#1267)\n- redis: make plugin params match docs (#1273)\n- mailbody: small refactoring (#1315)\n- smtp_proxy & qmail-queue: default to enabled for outbound (#1308)\n\n#### Fixes\n\n- redis: use correct path for db.select (#1273)\n- count errors correctly (#1274)\n- logger: ignore null arguments (#1299)\n- connection: pause for hook_reset_transaction (#1303)\n- rcpt_to.routes: update redis usage for compat with redis plugin (#1302)\n- smtp_forward: use correct config path to auth settings (#1327)\n- messagestream: correctly pass options parameter to get_data (#1316)\n- spf: honour configuration for mfrom scope (#1322)\n- outbound: Add missing dash to 'Final-Recipient' header name (#1320)\n\n### 2.7.2 - Dec 15, 2015\n\n#### Fixes\n\n- Revert a change that broke plugin loading\n\n### 2.7.1 - Dec 14, 2015\n\n#### New Features\n\n- added debian init.d file (#1255) @slattery\n\n#### Improvements\n\n- smtp_forward auth settings now work (#430)\n- better handling of broken messages (#1234)\n- Docker: use latest Phusion image && stdout (#1238, #1239)\n- Clean up plugin loading a tiny bit (#1242)\n- make dkim keydir case insensitive (1251)\n- ignore DNS errors that aren't errors (#1247)\n- outbound doc updates (#1258) @Currerius\n- outbound: return DENYSOFT on queue error (#1264)\n- smtp_client: if enable_tls is set and TLS files missing, warn (#1266)\n\n#### Fixes\n\n- Don't sent empty headers to rspamd (#1230)\n- Fix auth_base.js key need to be a string - number.toString() (#1228)\n- fix bug with empty charset= on mime parts … (#1225)\n- Fix \"passwd\" check crash with numeric password. (#1254)\n- result_store: show arrays when not empty (#1261)\n\n### 2.7.0 - Oct 07, 2015\n\n#### New Features\n\n- SPF bounce check\n- rspamd plugin (@fatalbanana)\n- watch plugin\n- limit plugin (connection concurrency, errors, unrecognized commands)\n- plugins can now be npm packages (see also #946)\n- built-in HTTP server (Express backed)\n- ESETS AV plugin\n- DCC plugin (incomplete)\n- Add LOGIN support to XCLIENT\n- backscatterer plugin\n- full IPv4 & IPv6 compatibility inbound #1120, #1123, #1154 (@Dexus)\n- Early talker #1075 (@smfreegard, @msimerson)\n- permit loading of plugins in node_modules #1056 (@msimerson)\n\n#### Improvements\n\n- Fix anti_spoof by use config #1171\n- Add license clause #1170\n- package.json dependencies and travis update #1147, #1168 (@Dexus)\n- logging: remove node-syslog and strong-fork-syslog with modern-syslog #1145 (@Dexus)\n- aliases: support for email, user and host aliases #1149 (@Dexus)\n- add docs for use private key with TLS #1130 (@Dexus)\n- outbound: ENOENT on dotfile - compatibility for windows #1129 (@Dexus)\n- plugin/attachment: block more attachment file types #1191 (@Dexus)\n- remove double functions #1126 (@Dexus)\n- Outbound Bounce messages according to RFC3464 #1189 (@hatsebutz)\n- toobusy: only run checks if toobusy.js installed and loads\n- HAProxy: set local_ip, local_port and remote_port\n- save auth pass/fail/user to result_store\n- ini files no longer require values (useful for storing lists)\n- connection: add MAIL and RCPT to results\n- results_store: enable 'emit' feature for .push()\n- add support for custom Outbound Received header value (@zombified)\n- save smtp_forward result to result_store\n- auth_base: permit a return message (@DarkSorrow)\n- add DSN.create() and RFC 4954 support\n- enhanced pipelining support\n- added config/access.domains with some tips (@EyePulp)\n- Add SSL detection over plain-text socket\n- earlytalker: store results\n- bounce: make it safe to check non_local_msgid\n- AVG: store results, added defer options\n- tls: change createCredentials to tls.createSecureContext (@DarkSorrow)\n- update dependency versions (esp async 0.2.9 -> 1.0.0)\n- ASN docs: add FTP download note for routeviews\n- karma: removed concurrency limits (see limit plugin) and penalty feature\n- added utils.elapsed()\n- deny message includes hostname\n- Add Fisher-Yates shuffle to randomize lookup order in data.uribl\n- change default message size limit to 25mb\n- auth_base: save auth results\n- upgrade toobusy plugin to toobusy-js (@alexkavon)\n- configfile: permit / char in ini keys\n- added utils.node_min()\n- added result_store.get_all()\n- updated ubuntu upstart script\n- plugin/rate_limit: return in no custom default is set 0 = unlimited #1186, #1185\n- Outbound.send_email: added dot-stuffing #1176, #1165 (@hatsebutz)\n- make sure server object is availabe to plugins loaded from node_modules #1162 (@bmonty)\n- Net_utils.get_ips_by_host #1160 (@msimerson)\n- fcrdns: don't log error for ENODATA #1140 (@msimerson)\n- improve MUA detection #1137 (@msimerson)\n- tls: tmp disable for hosts that fail STARTTLS #1136 (@msimerson)\n- karma: skip deny on outbound hooks #1100 (@msimerson)\n- Store HAProxy IP in connection object #1097 (@smfreegard)\n- Remove UUID from queued message #1092 (@smfreegard)\n\n#### Fixes\n\n- fix windows build and test failures #1076 (@msimerson)\n- Fix plugin ordering #1081 (@smfreegard)\n- Fix distance reporting to X-Haraka-GeoIP for geoip-lite #1086 (@smfreegard)\n- uribl: prevent calling next() more than 1x #1138 (@msimerson)\n- Fix so constants are imported when plugin is loaded from node_modules. #1133 (@bmonty)\n- Include STMP-code in bounce-reason string for upstream 5XX responses #1117 (@hatsebutz)\n- TLS fixes: add timed_out flag and karma should not run deny hook on it. #1109 (@smfreegard)\n- Fix port to number instead of string for HAProxy #1108 (@DarkSorrow)\n- Plugin dcc: fixed syntax error #1164 (@hatsebutz)\n- config: fix flat files if \\r\\n lines #1187 (@Dexus)\n- corrected hook_rcpt log code hook_rcpt_ok returns CONT\n- fix crash bug when loglevel = LOGDEBUG\n- corrected pathname in rcpt.ldap plugin (@abhas)\n- added helo.checks boolean for proto_mismatch\n- make rate_limit redis keys always expire @celesteking\n- dkim_sign: Buffer.concat expects an array of buffers\n- transaction: check discard_data before adding line end (@DarkSorrow)\n- fix 8-bit msg not displayed properly in gmail\n- fcrdns: always init results\n- TLS timer on error\n- dkim_verify: fixed timeout issue\n- smtp\\_[proxy|forward]: correct authentication example\n- Fork child workers after init_master hook\n- connection: return 450/550 for plugin DENY* (was 452/552)\n- spamassassin: don't call next() when transaction gone\n- outbound: fix crash when sending bounce mail\n- auth_base: fix bad protocol in auth_base.js #1121 (@Dexus)\n- outbound: Fix HELO/rDNS issue while using multiple outbound ip #1128 (@Dexus)\n- connection: Fix bug when client disconnect after sending data #1193\n- Fix connect.geoip bug #1144 (@smfreegard)\n- Fix tiny bug in messagesniffer #1198 (@smfreegard)\n\n### 2.6.1 - Mar 27, 2015\n\n- added sedation timers for config file re-reading\n- Add AUTH support to outbound\n- tests/spf: quiet excessive DEBUG noise\n- allow domains with underscore\n- correct name of domains config file in access\n- Fix SMTP AUTH in smtp_forward/proxy and add docs\n- Fix opts not being passed to HMailItem \\_bounce function\n- log.syslog will try strong-fork-syslog (for node 0.12 compat)\n- improvements to Plugin docs\n- rename net_utils.is_rfc1918 -> is_private_ip\n  - IPv6 compat\n  - test coverage\n  - add IPv6 unique local fc00::/7\n- pre-populated config/plugins\n- added utils.extend, copies props onto objects\n\n### 2.6.0 - Feb 21, 2015\n\n- other bug fixes\n- updated a few tests so test suite passes on Windows\n- log.syslog: handle failure to load node-syslog\n- plugin directory is $ENV definable (@martin1yness)\n- logging timestamps were static, fixed by @cloudbuy\n- queue/rabbitmq_amqplib, new plugin for RabbitMQ using amqplib (@esevece)\n- outbound:\n  - plugins can set the outbound IP (during get_mx)\n  - only replace line endings if not \\r\\n\n  - bannering fixes\n  - added support for per recipient routes\n- tls: don't register hooks upless certs exist\n- removed contrib/geolite-mirror-simple.pl (replaced by\n  docs update pointing to maxmind-geolite-mirror)\n- rcpt.routes: new plugin by @msimerson\n- make haproxy IPv6 compatible\n- record_envelope_addresses: new plugin by @deburau\n- prevent_credential_leaks: new plugin by @smfreegard\n- config:\n  - configfile: added .yaml support\n  - improved config file 'watch' logic\n  - Allow hyphens in params in config files (@abhas)\n  - cached requests include options in cache key name\n- asn: updates for node 0.11 compat\n- dnsbl: use aysync.each vs forEach (avoid race condition)\n- spamassassin: improved config loading and test coverage\n- geoip: deprecate geoip-lite in favor of maxmind, IPv6 compatible\n- disable SSLv3 (due to POODLE)\n- dkim & spf, updates for node 0.11 compatibiilty\n- karma: move neighbor scoring from code to karma.ini\n  - move excludes list to karma.ini\n  - apply awards before adding message header & permit rejection at queue\n  - karma.ini: score updates for access & uribl plugins\n  - score denials issued by skipped plugins\n  - add scores for specific DNSBLs\n- add transaction body filters (@chazomaticus)\n  - change bannering to use them\n- helo.checks: fix timeout bug\n  - match_re now validates and pre-compiles all REs\n  - Add new proto_mismatch check\n- p0f: add register(), load config once, early\n- server: improved config handling\n- data.headers: add Delivered-To check\n- rcpt_to.ldap: new plugin by @abhas\n- smtp*client: only load tls*- when cfg.enable_tls\n- added plugins/host_list_base\n- Platform independent temp dir (thanks @martinvd)\n- move deprecated docs into docs/deprecated\n- Switch to Phusion baseimage instead of stock Ubuntu (thanks @Synchro)\n- dkim_verify: new plugin by @smfreegard\n- many new tests\n- improved URI parser (for URIBL plugin)\n- Allow mixed case STARTTLS command\n- Install Node via package manager (Mohd Rozi)\n- Fix a couple crit errors (@Illirgway)\n- Add noisy/bulk out-of-band rule support to MessaageSniffer plugin\n- initial support for rabbitmq plugin (@samuelharden)\n- bounce, added non_local_msgid checks and much faster lookups\n- vpopmail: fail faster during a CRAM-MD5 auth attempt with an invalid user\n- fcrdns: handle a null hostname\n- Improve HAProxy support code and documentation\n- tls: reworked for efficiency and linear style\n- access: test hostname validity before PSL lookup\n  - load lists into objects (vs arrays), for much faster runtime access\n- host_list: huge performance increase, esp for many hosts\n\n### 2.5.0 - May 24, 2014\n\n- added automated build testing via Travis-CI.org\n- fixed dkim_sign crash issue #560\n- geoip can discover external IP via net_utils.get_public_ip\n- geoip: skip private IPs\n- qmd: when relaying, validate MAIL FROM against QMD, add per-domain\n  configurations, added reject option, added tests and bug fixes.\n- net_utils: added is_ipv4_literal, is_public_suffix, get_public_ip, added\n  tests, shed some CamelCase.\n- asn: looksup up ASN of connection, uses 3 providers, tests providers, saves\n  results, optionally adds headers. Includes tests.\n- access: new plugin that merges rdns_access, mail_from.access, and\n  rcpt_to.access.\n- fcrdns: new plugin (Forward Confirmed Reverse DNS)\n- bounce: new plugin (merges\n- data.headers: new plugin added direct_to_mx, check & reject settings, added MLM detection,\n  tests.\n- helo.checks: refactored, better config handling, new tests (match_rdns,\n  mismatch, results), reject option.\n- results_store: store processing results in data structures (vs notes)\n- spf: refactored, added outbound checks when relaying, added 15 tests,\n- dnsbl: return errors as Error objects, reduce list to unique zones, added\n  tests, added search=multi option, handle ENOTFOUND error, added reject=false option.\n- dns_list_base: bug fixes (race condition, returning invalid results)\n- bounce: refactored, each check has enable and reject switches, added tests,\n  added bad_bounce_to\n- clamav: add virus name to results, better config parsing, typo fixes\n- uribl:\n- mf_resolvable:\n- tls: add link to wiki article on TLS setup\n- relay_acl: fix issue #428, refactored, don't crash when relay_dest_domains.ini\n  missing, added tests\n- fix mx mechanism when no records are returned\n- vpopmaild: added per-domain feature\n- karma: added whitelist award, pass through temp (DENYSOFT) errors, made\n  tarpit variable, configurable reject hooks, doc rewrite, ASN awards, fix penalty days calculation, new DSL for karma awards,\n- bannering fixes\n- added log* stubs to test/fixtures/[plugin|connection]\n- tests/fixtures/stub_plugin: set name property\n- config: corrected handling of config.arg gets, fix caching bug, fix boolean\n  handling, added missing 'type' handling.\n- Adding the option of using CIDR ranges in the haproxy_hosts file\n- tarpit: added config option hooks_to_delay, added docs\n- contrib/haraka.bsd.rc: startup file for *BSD\n- Store attachment headers on stream\n- Record accepted domains at hook_rcpt and improve queue/lmtp\n- return after next() in the whitelist checks\n- Add new -o option to bin/haraka\n\n### 2.4.0 - Feb 12, 2014\n\n- Trim whitespace when reading \"list\" type config files (such as config/plugins)\n- Added LMTP via queue/lmtp plugin\n- Fixed bug in outbound when temp failing some of the recipients that would prevent delivery working to those recipients for future delivery attempts\n- Add additional details/parameters to delivered hook for outbound mail\n- Removed the hmail.bounce_extra object as that information now stored with the rcpt_to list\n- Store the RCPT TO rejection reason on the address object\n\n### 2.3.0 - Feb 07, 2014\n\n- Fix memory leak when watching config files for changes\n- Support for badly formatted MAIL FROM/RCPT TO lines\n- Fix a memory corruption when fixing line endings\n- Fix breakpoints in plugins when using node inspector\n- Reload config in relay_force_routing without restart\n- Don't re-attempt TLS upgrade if upgraded already and STARTTLS is re-advertised\n- Improved outbound logging\n- Pass failed recipients to bounce hook in outbound processing\n- Added startup checks to ensure Haraka has been installed correctly\n- Handle case of Haraka server running out of disk space better\n- In mail_from.is_resolvable: move re_bogus_ip into config\n- Added auth/auth_vpopmaild plugin - SMTP AUTH against a vpopmaild server\n- Fixed graph plugin to work with sqlite3\n- Added rcpt_to.qmail_deliverable plugin - Authenticate inbound RCPT TOs against Qmail::Deliverable daemon\n- Added data.headers plugin which merges header checks into one place.\n  Deprecates data.noreceived, data.rfc5322_header_checks, and data.nomsgid.\n- Added documentation for logging system\n- Added DKIM per-domain signing support\n- Added p0f plugin\n- In relay_acl, if host is allowed by acl, don't deny the recipient because the domain isn't in the allow list\n- Add Authentication-Results header (RFC 5451) to all emails\n- Fixed writing the todo file in outbound for newer Node versions\n- Added Karma plugin to support penalizing consistently evil senders\n- Added GeoIP plugin including distance calculation from your mail server\n- Added bounce plugin for handling incoming bounce messages in various ways\n- Fix underscores in documentation so web version doesn't look so weird\n- By default prevent SMTP AUTH unless on a private IP or using TLS WARNING: May break some uses of Haraka, but is worth it for security\n- In lookup_rdns.strict, check whitelist before looking up IP\n- Big rewrite of the SpamAssassin plugin for simplicity and mainly to pass through X-Spam-* headers provided\n- Added delay_deny plugin allowing more flexibility on when to reject mail\n- Improvements to ini file parsing allowing floats and negative integers, and specifying boolean keys\n- Fix issue causing a CRIT/crash with lost transaction/connection while sending inbound to ongoing SMTP server\n- Allow setting of spamd_user for spamassassin plugin\n\n### 2.0.0 - Nov 28, 2012\n\n- Various fixes to SMTP AUTH code, including providing SMTP AUTH to inbound\n  mail forwarders.\n- Updates to process_title plugin to show more details\n- Changed transaction.data_lines to a Stream (this will break all code which\n  uses transaction.data_lines currently - see the migration guide)\n- Changed attachments to be a Stream (this will break some code which uses\n  transaction.attachment_hooks - see the migration guide)\n- Capture and log signals sent to Haraka\n- Various performance improvements\n- Fixed a memory leak in connection pool\n- Improvements to TLS compatibility\n- RFC compliance improvements with greeting, EHLO/HELO, QUIT, and dot stuffing\n- Throw exception with set_banner as it is now non-functional. Will be returned in a future version.\n- Small fixes to data.uribl\n\n### 1.4.0 -\n\n[3.0.0]: https://github.com/haraka/Haraka/releases/tag/3.0.0\n[3.0.1]: https://github.com/haraka/Haraka/releases/tag/v3.0.1\n[3.0.2]: https://github.com/haraka/Haraka/releases/tag/v3.0.2\n[3.0.3]: https://github.com/haraka/Haraka/releases/tag/v3.0.3\n[3.0.4]: https://github.com/haraka/Haraka/releases/tag/3.0.4\n[3.0.5]: https://github.com/haraka/Haraka/releases/tag/v3.0.5\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.748046875,
          "content": "# NOTICE: This is user-contributed and not officially supported by the Haraka team. Use at your own risk.\n#\n# This file describes how to build Haraka into a runnable linux container with all dependencies installed\n# To build:\n# 1.) Install docker (http://docker.io)\n# 2.) Clone Haraka repo if you haven't already: git clone https://github.com/haraka/Haraka.git\n# 3.) Modify config/host_list with the domain(s) that you'd like to receive mail to\n# 4.) Build: cd Haraka && docker build .\n# 5.) Run:\n# docker run -d <imageid>\n#\n# VERSION           0.1\n# DOCKER-VERSION    0.5.3\n\n# See http://phusion.github.io/baseimage-docker/\nFROM phusion/baseimage:focal-1.2.0\n\nMAINTAINER Justin Plock <jplock@gmail.com>\n\nENV HOME /root\n\nRUN /etc/my_init.d/00_regen_ssh_host_keys.sh\n\nRUN sed 's/main$/main universe/' -i /etc/apt/sources.list\nRUN DEBIAN_FRONTEND=noninteractive apt-get -y -q update\nRUN DEBIAN_FRONTEND=noninteractive apt-get -y -q install software-properties-common g++ make git curl\nRUN curl -sL https://deb.nodesource.com/setup_18.x | setuser root bash -\nRUN DEBIAN_FRONTEND=noninteractive apt-get -y -q install nodejs && \\\n    apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\n# Optional, useful for development\n# See https://github.com/phusion/baseimage-docker#login_ssh\n#RUN rm -f /etc/service/sshd/down\n#RUN /usr/sbin/enable_insecure_key\n\n# Install Haraka\nRUN npm install -g Haraka --unsafe\nRUN haraka -i /usr/local/haraka\nADD ./config/host_list /usr/local/haraka/config/host_list\nADD ./config/plugins /usr/local/haraka/config/plugins\nRUN cd /usr/local/haraka && npm install\n\n# Create haraka runit service\nRUN mkdir /etc/service/haraka\nADD haraka.sh /etc/service/haraka/run\n\nEXPOSE 25\n\n# Start the init daemon - runit will launch the Haraka process\nCMD [\"/sbin/my_init\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "MIT License\n\nCopyright (c) 2011 - 2025 Matt Sergeant\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "Plugins.md",
          "type": "blob",
          "size": 17.33984375,
          "content": "# Haraka Plugins\n\nTo create your own plugin, see [Write a Plugin][write-plugin].\n\n## Installing NPM packaged plugins\n\nPlugins can be installed in the directory where Haraka was installed (where depends on your OS platform and whether you specified `-g`) or the Haraka install directory (haraka -i this\\_path). This example installs _my-great-plugin_ in the Haraka install directory:\n\n```\ncd /etc/haraka\nnpm install haraka-plugin-my-great-plugin\n```\n\nNPM then installs the plugin and its dependencies in a `node_modules` directory within the Haraka install directory.\n\n## Plugin Registry\n\nA comprehensive list of known plugins. Create a PR to add yours to these lists.\n\n### Auth Plugins\n\n| Name                             | Description                                       |\n| -------------------------------- | ------------------------------------------------- |\n| [auth-enc-file][url-authencflat] | Auth against user/pass in an encrypted file       |\n| [flat_file][url-authflat]        | Auth against user/pass in a file                  |\n| [auth_bridge][url-authbridge]    | Auth against remote MTA                           |\n| [auth-imap][url-auth-imap]       | Auth against IMAP server                          |\n| [auth_ldap][url-auth-ldap]       | Auth against LDAP                                 |\n| [auth_proxy][url-authproxy]      | Auth against remote MTA                           |\n| [auth_vpopmaild][url-authvpop]   | Auth against vpopmaild                            |\n| [dkim][url-dkim]                 | DKIM sign & verify                                |\n| [dovecot][url-dovecot]           | SMTP AUTH & recipient validation against dovecot  |\n| [LDAP][url-ldap]                 | Aliases, Auth, and Recipient validation from LDAP |\n| [mailauth][url-mailauth]         | Email Auth (SPF, DKIM, DMARC, ARC, & BIMI)        |\n| [opendkim][url-opendkim]         | DKIM sign and verify email messages               |\n| [spf][url-spf]                   | Perform SPF checks                                |\n\n### Queue Plugins\n\n| Name                             | Description                                                              |\n| -------------------------------- | ------------------------------------------------------------------------ |\n| [discard][url-qdisc]             | queues messages to /dev/null                                             |\n| [kafka][url-kafka]               | Queue inbound mail to a Kafka topic                                      |\n| [lmtp][url-qlmtp]                | deliver queued messages via LMTP                                         |\n| [mongodb][mongo-url]             | Queue emails to MongoDB                                                  |\n| [qmail-queue][url-qmail]         | queue to qmail                                                           |\n| [quarantine][url-qquart]         | queue to a quarantine directory                                          |\n| [rabbitmq][url-qrabbit]          | queue to RabbitMQ                                                        |\n| [rabbitmq_amqplib][url-qrabbita] | queue to RabbitMQ using amqplib                                          |\n| [rails][url-qrails]              | queue messages to a Rails app using [Action Mailbox][url-action-mailbox] |\n| [smtp_bridge][url-qbridge]       | Bridge SMTP sessions to another MTA                                      |\n| [smtp_forward][url-qforward]     | Forward emails to another MTA                                            |\n| [smtp_proxy][url-qproxy]         | Proxy SMTP connections to another MTA                                    |\n| [wildduck][url-wildduck]         | queue messages to Wild Duck                                              |\n\n### Filtering Plugins\n\n| Name                           | Description                                |\n| ------------------------------ | ------------------------------------------ |\n| [attachment][url-attach]       | Restrict attachment types                  |\n| [avg][url-avg]                 | AVG antivirus scanner                      |\n| [clamd][url-clamd]             | Anti-Virus scanning with ClamAV            |\n| [data.signatures][url-sigs]    | Block emails whose bodies match signatures |\n| [dcc][url-dcc]                 | Distributed Checksum Clearinghouse         |\n| [esets][url-esets]             | Virus scanning with ESET Mail Security     |\n| [messagesniffer][url-msgsniff] | Anti-spam via [MessageSniffer][url-ms]     |\n| [milter][url-milter]           | milter support                             |\n| [rspamd][url-rspamd]           | Scan emails with rspamd                    |\n| [spamassassin][url-spamass]    | Scan emails with SpamAssassin              |\n| [uribl][url-uribl]             | Block based on URI blacklists              |\n\n### Every other Plugin\n\n| Name                                       | Description                                                                                 |\n| ------------------------------------------ | ------------------------------------------------------------------------------------------- |\n| [access][url-access]                       | ACLs based on IPs, domains, email addrs, etc.                                               |\n| [accounting_files][url-acc-files]          | Retrieve, Store and Archive custom information of outbound traffic                          |\n| [aliases][url-aliases]                     | Email aliases                                                                               |\n| [ASN][url-asn]                             | Get ASN info for remote senders                                                             |\n| [block_me][url-blockme]                    | Populate block list via forwarded emails                                                    |\n| [bounce][url-bounce]                       | Many options for bounce processing                                                          |\n| [delay_deny][url-delay]                    | Delays all pre-DATA 'deny' results                                                          |\n| [dns-list][url-dns-list]                   | Check remote MTAs against DNS black, white, and karma lists                                 |\n| [dovecot][url-dovecot]                     | Recipient validation & SMTP AUTH against dovecot                                            |\n| [early_talker][url-early]                  | Reject remotes that talk early                                                              |\n| [fcrdns][url-fcrdns]                       | Forward Confirmed reverse DNS                                                               |\n| [geoip][url-geoip]                         | get geographic information about mail senders                                               |\n| [greylist][url-greylist]                   | Greylisting                                                                                 |\n| [headers][url-headers]                     | Inspect and verify various email headers                                                    |\n| [helo.checks][url-helo]                    | Validity checks of the HELO string                                                          |\n| [karma][url-karma]                         | Dynamic scoring of incoming connections                                                     |\n| [known-senders][url-known-senders]         | Reward emails from those you send mail to                                                   |\n| [LDAP][url-ldap]                           | Aliases, Auth, and Recipient validation from LDAP                                           |\n| [Limit][url-limit]                         | Apply many types of limits to SMTP connections                                              |\n| [elasticsearch][url-elastic]               | Store message metadata in Elasticsearch                                                     |\n| [log reader][url-logreader]                | extract log entries from the haraka log file                                                |\n| [syslog][url-syslog]                       | Log to syslog                                                                               |\n| [mail_from.is_resolvable][url-mfres]       | Verifies the MAIL FROM domain resolves to a MX                                              |\n| [outbound-logger][url-outbound-logger]     | JSON logging of outbound email traffic. Logs useful metadata about delivered/bounced emails |\n| [p0f][url-p0f]                             | TCP Fingerprinting                                                                          |\n| [prevent_credential_leaks][url-creds]      | Prevent users from emailing their credentials                                               |\n| [process_title][url-proctitle]             | Populate `ps` output with activity counters                                                 |\n| [recipient-routes][url-rroutes]            | Route emails based on their recipient(s)                                                    |\n| [redis][url-redis]                         | multi-purpose Redis db connection(s)                                                        |\n| [rcpt_to.in_host_list][url-rhost]          | Define local email domains in a file                                                        |\n| [rcpt_to.ldap][url-rcpt-ldap]              | Validate recipients against LDAP                                                            |\n| [rcpt-postgresql][url-postgres]            | validate recipients against PostgreSQL                                                      |\n| [qmail-deliverable][url-rqmd]              | Validate recipients against Qmail-Deliverable                                               |\n| [record_envelope_addresses][url-recordenv] | Adds message headers with ENV recips                                                        |\n| [relay][url-relay]                         | Manage relay permissions                                                                    |\n| [reseed_rng][url-rng]                      | Reseed the RNG                                                                              |\n| [batv-srs][url-batv]                       | BATV & SRS                                                                                  |\n| [srs][url-srs]                             | Sender Rewriting Scheme                                                                     |\n| [tarpit][url-tarpit]                       | Slow down connections                                                                       |\n| [tls][url-tls]                             | Implements TLS                                                                              |\n| [toobusy][url-toobusy]                     | Defers connections when too busy                                                            |\n| [vmta][url-vmta]                           | Virtual MTA management                                                                      |\n| [watch][url-watch]                         | Watch live SMTP traffic in a web interface                                                  |\n| [wildduck][url-wildduck]                   | provides recipient checks against Wild Duck                                                 |\n| [xclient][url-xclient]                     | Implements XCLIENT                                                                          |\n\n<!-- URLs tucked safely out of the way -->\n\n[write-plugin]: https://github.com/haraka/Haraka/wiki/Write-a-Plugin\n[plugins-doc]: https://haraka.github.io/core/Plugins\n[url-access]: https://github.com/haraka/haraka-plugin-access\n[url-acc-files]: https://github.com/acharkizakaria/haraka-plugin-accounting-files/blob/master/README.md\n[url-action-mailbox]: https://guides.rubyonrails.org/action_mailbox_basics.html\n[url-aliases]: https://github.com/haraka/Haraka/blob/master/docs/plugins/aliases.md\n[url-asn]: https://github.com/haraka/haraka-plugin-asn\n[url-attach]: https://github.com/haraka/haraka-plugin-attachment\n[url-authencflat]: https://github.com/AuspeXeu/haraka-plugin-auth-enc-file\n[url-authflat]: https://github.com/haraka/Haraka/blob/master/docs/plugins/auth/flat_file.md\n[url-authbridge]: https://github.com/haraka/Haraka/blob/master/docs/plugins/auth/auth_bridge.md\n[url-auth-imap]: https://github.com/haraka/haraka-plugin-auth-imap\n[url-auth-ldap]: https://github.com/haraka/haraka-plugin-auth-ldap\n[url-authproxy]: https://github.com/haraka/Haraka/blob/master/docs/plugins/auth/auth_proxy.md\n[url-authvpop]: https://github.com/haraka/Haraka/blob/master/docs/plugins/auth/auth_vpopmaild.md\n[url-avg]: https://github.com/haraka/haraka-plugin-avg\n[url-batv]: https://www.npmjs.com/package/haraka-plugin-batv\n[url-scatter]: https://github.com/haraka/Haraka/blob/master/docs/plugins/backscatterer.md\n[url-blockme]: https://github.com/haraka/Haraka/blob/master/docs/plugins/block_me.md\n[url-bounce]: https://www.npmjs.com/package/haraka-plugin-bounce\n[url-clamd]: https://github.com/haraka/haraka-plugin-clamd\n[url-dovecot]: https://github.com/haraka/haraka-plugin-dovecot\n[url-fcrdns]: https://github.com/haraka/haraka-plugin-fcrdns\n[url-p0f]: https://github.com/haraka/haraka-plugin-p0f\n[url-headers]: https://github.com/haraka/haraka-plugin-headers\n[url-sigs]: https://github.com/haraka/Haraka/blob/master/docs/plugins/data.signatures.md\n[url-uribl]: https://github.com/haraka/haraka-plugin-uribl\n[url-dcc]: https://github.com/haraka/haraka-plugin-dcc\n[url-delay]: https://github.com/haraka/Haraka/blob/master/docs/plugins/delay_deny.md\n[url-dkim]: https://github.com/haraka/haraka-plugin-dkim\n[url-opendkim]: https://www.npmjs.com/package/haraka-plugin-opendkim\n[url-dns-list]: https://github.com/haraka/haraka-plugin-dns-list\n[url-early]: https://github.com/haraka/Haraka/blob/master/docs/plugins/early_talker.md\n[url-esets]: https://github.com/haraka/haraka-plugin-esets\n[url-geoip]: https://github.com/haraka/haraka-plugin-geoip\n[url-graph]: https://github.com/haraka/haraka-plugin-graph\n[url-greylist]: https://github.com/haraka/haraka-plugin-greylist\n[url-helo]: https://github.com/haraka/haraka-plugin-helo.checks\n[url-karma]: https://github.com/haraka/haraka-plugin-karma\n[url-known-senders]: https://github.com/haraka/haraka-plugin-known-senders\n[url-elastic]: https://github.com/haraka/haraka-plugin-elasticsearch/\n[url-syslog]: https://github.com/haraka/haraka-plugin-syslog\n[url-ldap]: https://github.com/haraka/haraka-plugin-ldap\n[url-limit]: https://github.com/haraka/haraka-plugin-limit\n[url-logreader]: https://github.com/haraka/haraka-plugin-log-reader\n[url-milter]: https://github.com/haraka/haraka-plugin-milter\n[url-mfres]: https://github.com/haraka/Haraka/blob/master/docs/plugins/mail_from.is_resolvable.md\n[url-msgsniff]: https://github.com/haraka/haraka-plugin-messagesniffer\n[url-ms]: http://www.armresearch.com/Products/\n[url-creds]: https://github.com/haraka/Haraka/blob/master/docs/plugins/prevent_credential_leaks.md\n[url-postgres]: https://github.com/haraka/haraka-plugin-rcpt-postgresql\n[url-proctitle]: https://github.com/haraka/Haraka/blob/master/docs/plugins/process_title.md\n[url-qdisc]: https://github.com/haraka/Haraka/blob/master/docs/plugins/queue/discard.md\n[url-qlmtp]: https://github.com/haraka/Haraka/blob/master/docs/plugins/queue/lmtp.md\n[url-qmail]: https://github.com/haraka/Haraka/blob/master/docs/plugins/queue/qmail-queue.md\n[url-qquart]: https://github.com/haraka/Haraka/blob/master/docs/plugins/queue/quarantine.md\n[url-qrabbit]: https://github.com/haraka/Haraka/blob/master/docs/plugins/queue/rabbitmq.md\n[url-qrabbita]: https://github.com/haraka/Haraka/blob/master/docs/plugins/queue/rabbitmq_amqplib.md\n[url-qbridge]: https://github.com/haraka/Haraka/blob/master/docs/plugins/queue/smtp_bridge.md\n[url-qforward]: https://github.com/haraka/Haraka/blob/master/docs/plugins/queue/smtp_forward.md\n[url-qproxy]: https://github.com/haraka/Haraka/blob/master/docs/plugins/queue/smtp_proxy.md\n[url-qrails]: https://github.com/mailprotector/haraka-plugin-queue-rails\n[url-redis]: https://github.com/haraka/haraka-plugin-redis\n[url-rhost]: https://github.com/haraka/Haraka/blob/master/docs/plugins/rcpt_to.in_host_list.md\n[url-rcpt-ldap]: https://github.com/haraka/haraka-plugin-rcpt-ldap\n[url-rqmd]: https://github.com/haraka/haraka-plugin-qmail-deliverable\n[url-rroutes]: https://github.com/haraka/haraka-plugin-recipient-routes\n[url-recordenv]: https://github.com/haraka/Haraka/blob/master/docs/plugins/record_envelope_addresses.md\n[url-relay]: https://github.com/haraka/haraka-plugin-relay\n[url-rng]: https://github.com/haraka/Haraka/blob/master/docs/plugins/reseed_rng.md\n[url-rspamd]: https://github.com/haraka/haraka-plugin-rspamd\n[url-spamass]: https://github.com/haraka/haraka-plugin-spamassassin\n[url-spf]: https://github.com/haraka/haraka-plugin-spf\n[url-srs]: https://github.com/swerter/haraka-plugins/blob/master/plugins/srs.js\n[url-tarpit]: https://github.com/haraka/Haraka/blob/master/docs/plugins/tarpit.md\n[url-tls]: https://github.com/haraka/Haraka/blob/master/docs/plugins/tls.md\n[url-toobusy]: https://github.com/haraka/Haraka/blob/master/docs/plugins/toobusy.md\n[url-vmta]: https://github.com/haraka/haraka-plugin-vmta/blob/master/README.md\n[url-watch]: https://github.com/haraka/haraka-plugin-watch\n[url-wildduck]: https://github.com/nodemailer/haraka-plugin-wildduck\n[url-xclient]: https://github.com/haraka/Haraka/blob/master/docs/plugins/xclient.md\n[mongo-url]: https://github.com/Helpmonks/haraka-plugin-mongodb\n[url-outbound-logger]: https://github.com/mr-karan/haraka-plugin-outbound-logger\n[url-kafka]: https://github.com/benjamonnguyen/haraka-plugin-queue-kafka\n[url-mailauth]: https://www.npmjs.com/package/haraka-plugin-mailauth\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.576171875,
          "content": "## Haraka - a Node.js Mail Server\n\n![Tests](https://github.com/haraka/Haraka/actions/workflows/ci.yml/badge.svg)\n[![Coverage Status][cov-img]][cov-url]\n\nHaraka is a highly scalable [node.js][1] email server with a modular\nplugin architecture. Haraka can serve thousands of concurrent connections\nand deliver thousands of messages per second. Haraka and plugins are written\nin asynchronous JS and are very fast.\n\nHaraka has very good spam protection (see [plugins][4]) and works\nwell as a filtering [MTA][3]. It also works well as a [MSA][5] running on\nport 587 with auth and [dkim_sign][6] plugins enabled.\n\nHaraka makes no attempt to be a mail store (like Exchange or Postfix/Exim/Qmail),\na [LDA][7], nor an IMAP server (like Dovecot or Courier). Haraka is\ntypically used **with** such systems.\n\nHaraka has a scalable outbound mail delivery engine built in. Mail\nmarked as `relaying` (such as via an `auth` plugin) is automatically\nqueued for outbound delivery.\n\n### Getting Help\n\n- [Join the mailing list][8] (implemented as a Haraka plugin)\n- [GitHub Issues][15]\n\n### Screencast\n\n[Getting started with Haraka][2]\n\n### Why Use Haraka?\n\nHaraka's plugin architecture provides an easily extensible MTA that\ncomplements traditional MTAs that excel at managing mail stores but do\nnot have sufficient filtering.\n\nThe plugin system makes it easy to code new features. A typical example\nis providing qmail-like extended addresses to an Exchange system,\nwhereby you could receive mail as `user-anyword@domain.com`, and yet\nstill have it correctly routed to `user@domain.com`. This is a few lines of\ncode in Haraka.\n\nPlugins are provided for running mail through [SpamAssassin][9], validating\n[HELO][10] names, checking [DNS Blocklists][11], and [many others][12].\n\n### Installing Haraka\n\nHaraka requires [node.js][1] to run. Install Haraka with [npm][2]:\n\n```sh\n# If the second command gives \"nobody\" errors, uncomment & run the next command\n# npm -g config set user root\nnpm install -g Haraka\n```\n\nAfter installation, use the `haraka` binary to set up the service.\n\n### Running Haraka\n\nFirst, create the service:\n\n```sh\nharaka -i /path/to/haraka_test\n```\n\nThat creates the directory `haraka_test` with `config` and `plugin`\ndirectories within. It also sets the host name used by Haraka\nto the output of `hostname`.\n\nIf `hostname` is not correct, edit `config/host_list`. For example,\nto receive mail addressed to `user@domain.com`, add `domain.com` to the\n`config/host_list` file.\n\nFinally, start Haraka using root permissions:\n\n```sh\nharaka -c /path/to/haraka_test\n```\n\nAnd it will run.\n\n### Configure Haraka\n\nTo choose which plugins run, edit `config/plugins`. Plugins control the\noverall behaviour of Haraka. By default, only messages to domains listed\nin `config/host_list` will be accepted and then delivered via the\n`smtp-forward` plugin. Configure the destination in `config/smtp_forward.ini`.\n\n### Read the Fine Manual\n\n```sh\nharaka -h plugins/$name\n```\n\nThe docs detail how each plugin is configured. After editing\n`config/plugins`, restart Haraka and enjoy!\n\n### Running from git\n\nIf you are unable to use npm to install Haraka, you can run from git by\nfollowing these steps:\n\nFirst clone the repository:\n\n    $ git clone https://github.com/haraka/Haraka.git\n    $ cd Haraka\n\nInstall Haraka's node.js dependencies locally:\n\n    $ npm install\n\nEdit `config/plugins` and `config/smtp.ini` to specify the plugins and\nconfig you want.\n\nFinally run Haraka:\n\n    $ node haraka.js\n\n### License and Author\n\nHaraka is MIT licensed - see the [LICENSE][16] file for details.\n\nHaraka is a project started by [Matt Sergeant][17], a 10 year veteran of the email and anti-spam world. Previous projects have been the project leader for\nSpamAssassin and a hacker on [Qpsmtpd][13].\n\n[1]: http://nodejs.org/\n[2]: http://youtu.be/6twKXMAsPsw\n[3]: http://en.wikipedia.org/wiki/Message_transfer_agent\n[4]: https://github.com/haraka/Haraka/blob/master/Plugins.md\n[5]: http://en.wikipedia.org/wiki/Mail_submission_agent\n[6]: https://github.com/haraka/Haraka/blob/master/docs/plugins/dkim_sign.md\n[7]: https://en.wikipedia.org/wiki/Mail_delivery_agent\n[8]: mailto:haraka-sub@harakamail.com\n[9]: https://haraka.github.io/plugins/spamassassin\n[10]: https://haraka.github.io/plugins/helo.checks\n[11]: https://haraka.github.io/plugins/dnsbl\n[12]: https://github.com/haraka/Haraka/blob/master/Plugins.md\n[13]: https://github.com/smtpd/qpsmtpd/\n[15]: https://github.com/haraka/Haraka/issues\n[16]: https://github.com/haraka/Haraka/blob/master/LICENSE\n[17]: https://github.com/baudehlo\n[cov-img]: https://codecov.io/github/haraka/Haraka/coverage.svg\n[cov-url]: https://codecov.io/github/haraka/Haraka?branch=master\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.9990234375,
          "content": "- Milter support\n- Ability to modify the body of email\n    - Done for banners. Modifying the rest, not so much.\n\nOutbound improvements\n - Provide better command line tools for manipulating/inspecting the queue\n - Add the ability to force a run on a specific queue file or destination domain\n - Make retry times configurable (handle RFC requirements for 5 days and DSN queued warnings)\n - Disable deliveries for a domain\n\nPlugin behavior changes\n - in SpamAssassin plugin, change default behavior of 'legacy' status header.\n   Presently, when undefined, legacy is used. Legacy support should be changed to\n   only when requested, with a sunset date.\n - data.uribl; expand short URLs before lookups, add support for uri-a (sbl.spamhaus.org), uri-ns, uri-ns-a lookup types.\n\nBuilt-in HTTP server\n- use the same TLS/SSL certs as smtpd\n- auth against SMTP-AUTH provider\n\nUpdate tests to detect HARAKA_NETWORK_TESTS and skip network tests unless it's set\n  (to prevent annoying test suite failures that are tangential to Haraka)\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "connection.js",
          "type": "blob",
          "size": 67.724609375,
          "content": "'use strict';\n// a single connection\n\nconst dns         = require('node:dns');\nconst net         = require('node:net');\nconst os          = require('node:os');\n\n// npm libs\nconst ipaddr      = require('ipaddr.js');\nconst config      = require('haraka-config');\nconst constants   = require('haraka-constants');\nconst net_utils   = require('haraka-net-utils');\nconst Notes       = require('haraka-notes');\nconst utils       = require('haraka-utils');\nconst { Address } = require('address-rfc2821');\nconst ResultStore = require('haraka-results');\n\n// Haraka libs\nconst logger      = require('./logger');\nconst trans       = require('./transaction');\nconst plugins     = require('./plugins');\nconst rfc1869     = require('./rfc1869');\nconst outbound    = require('./outbound');\n\nconst states      = constants.connection.state;\n\n// Load HAProxy hosts into an object for fast lookups\n// as this list is checked on every new connection.\nlet haproxy_hosts_ipv4 = [];\nlet haproxy_hosts_ipv6 = [];\nfunction loadHAProxyHosts () {\n    const hosts = config.get('haproxy_hosts', 'list', loadHAProxyHosts);\n    const new_ipv4_hosts = [];\n    const new_ipv6_hosts = [];\n    for (let i=0; i<hosts.length; i++) {\n        const host = hosts[i].split(/\\//);\n        if (net.isIPv6(host[0])) {\n            new_ipv6_hosts[i] = [ipaddr.IPv6.parse(host[0]), parseInt(host[1] || 64)];\n        }\n        else {\n            new_ipv4_hosts[i] = [ipaddr.IPv4.parse(host[0]), parseInt(host[1] || 32)];\n        }\n    }\n    haproxy_hosts_ipv4 = new_ipv4_hosts;\n    haproxy_hosts_ipv6 = new_ipv6_hosts;\n}\nloadHAProxyHosts();\n\nclass Connection {\n    constructor (client, server, cfg) {\n        this.client = client;\n        this.server = server;\n        this.cfg = cfg;\n\n        this.local = {\n            ip: null,\n            port: null,\n            host: net_utils.get_primary_host_name(),\n            info: 'Haraka',\n        };\n        this.remote = {\n            ip:   null,\n            port: null,\n            host: null,\n            info: null,\n            closed: false,\n            is_private: false,\n            is_local: false,\n        };\n        this.hello = {\n            host: null,\n            verb: null,\n        };\n        this.tls = {\n            enabled: false,\n            advertised: false,\n            verified: false,\n            cipher: {},\n        };\n        this.proxy = {\n            allowed: false,\n            ip: null,\n            type: null,\n            timer: null,\n        };\n        this.set('tls', 'enabled', (!!server.has_tls));\n\n        this.current_data = null;\n        this.current_line = null;\n        this.state = states.PAUSE;\n        this.encoding = 'utf8';\n        this.prev_state = null;\n        this.loop_code = null;\n        this.loop_msg = null;\n        this.uuid = utils.uuid();\n        this.notes = new Notes();\n        this.transaction = null;\n        this.tran_count = 0;\n        this.capabilities = null;\n        this.ehlo_hello_message = config.get('ehlo_hello_message') || 'Haraka is at your service.';\n        this.connection_close_message = config.get('connection_close_message') || 'closing connection. Have a jolly good day.';\n        this.banner_includes_uuid = !!config.get('banner_includes_uuid');\n        this.deny_includes_uuid = config.get('deny_includes_uuid') || null;\n        this.early_talker = false;\n        this.pipelining = false;\n        this._relaying = false;\n        this.esmtp = false;\n        this.last_response = null;\n        this.hooks_to_run = [];\n        this.start_time = Date.now();\n        this.last_reject = '';\n        this.max_bytes = parseInt(config.get('databytes')) || 0;\n        this.max_mime_parts = parseInt(config.get('max_mime_parts')) || 1000;\n        this.totalbytes = 0;\n        this.rcpt_count = {\n            accept:   0,\n            tempfail: 0,\n            reject:   0,\n        };\n        this.msg_count = {\n            accept:   0,\n            tempfail: 0,\n            reject:   0,\n        };\n        this.max_line_length = parseInt(config.get('max_line_length')) || 512;\n        this.max_data_line_length = parseInt(config.get('max_data_line_length')) || 992;\n        this.results = new ResultStore(this);\n        this.errors = 0;\n        this.last_rcpt_msg = null;\n        this.hook = null;\n        if (this.cfg.headers.show_version) {\n            this.local.info += `/${utils.getVersion(__dirname)}`;\n        }\n        Connection.setupClient(this);\n    }\n    static setupClient (self) {\n        const ip = self.client.remoteAddress;\n        if (!ip) {\n            self.logdebug('setupClient got no IP address for this connection!');\n            self.client.destroy();\n            return;\n        }\n\n        const local_addr = self.server.address();\n        self.set('local', 'ip', ipaddr.process(self.client.localAddress || local_addr.address).toString());\n        self.set('local', 'port', (self.client.localPort || local_addr.port));\n        self.results.add({name: 'local'}, self.local);\n\n        self.set('remote', 'ip', ipaddr.process(ip).toString());\n        self.set('remote', 'port', self.client.remotePort);\n        self.results.add({name: 'remote'}, self.remote);\n\n        self.lognotice( 'connect', {\n            ip: self.remote.ip,\n            port: self.remote.port,\n            local_ip: self.local.ip,\n            local_port: self.local.port\n        });\n\n        if (!self.client.on) return;\n\n        const log_data = {ip: self.remote.ip}\n        if (self.remote.host) log_data.host = self.remote.host\n\n        self.client.on('end', () => {\n            if (self.state >= states.DISCONNECTING) return;\n            self.remote.closed = true;\n            self.loginfo('client half closed connection', log_data);\n            self.fail();\n        });\n\n        self.client.on('close', has_error => {\n            if (self.state >= states.DISCONNECTING) return;\n            self.remote.closed = true;\n            self.loginfo('client dropped connection', log_data);\n            self.fail();\n        });\n\n        self.client.on('error', err => {\n            if (self.state >= states.DISCONNECTING) return;\n            self.loginfo(`client connection error: ${err}`, log_data);\n            self.fail();\n        });\n\n        self.client.on('timeout', () => {\n            // FIN has sent, when timeout just destroy socket\n            if (self.state >= states.DISCONNECTED) {\n                self.client.destroy();\n                self.loginfo(`timeout, destroy socket (state:${self.state})`)\n                return;\n            }\n            if (self.state >= states.DISCONNECTING) return;\n            self.respond(421, 'timeout', () => {\n                self.fail('client connection timed out', log_data);\n            });\n        });\n\n        self.client.on('data', data => {\n            self.process_data(data);\n        });\n\n        const ha_list = net.isIPv6(self.remote.ip) ? haproxy_hosts_ipv6 : haproxy_hosts_ipv4;\n\n        if (ha_list.some((element, index, array) => {\n            return ipaddr.parse(self.remote.ip).match(element[0], element[1]);\n        })) {\n            self.proxy.allowed = true;\n            // Wait for PROXY command\n            self.proxy.timer = setTimeout(() => {\n                self.respond(421, 'PROXY timeout',() => {\n                    self.disconnect();\n                });\n            }, 30 * 1000);\n        }\n        else {\n            plugins.run_hooks('connect_init', self);\n        }\n    }\n    setTLS (obj) {\n        this.set('hello', 'host', undefined);\n        this.set('tls',   'enabled', true);\n        for (const t of ['cipher','verified','verifyError','peerCertificate']) {\n            if (obj[t] === undefined) return;\n            this.set('tls', t, obj[t]);\n        }\n        // prior to 2017-07, authorized and verified were both used. Verified\n        // seems to be the more common and has the property updated in the\n        // tls object. However, authorized has been up-to-date in the notes. Store\n        // in both, for backwards compatibility.\n        this.notes.tls = {\n            authorized: obj.verified,   // legacy name\n            authorizationError: obj.verifyError,\n            cipher: obj.cipher,\n            peerCertificate: obj.peerCertificate,\n        }\n    }\n    set (prop_str, val) {\n        if (arguments.length === 3) {\n            prop_str = `${arguments[0]}.${arguments[1]}`;\n            val = arguments[2];\n        }\n\n        const path_parts = prop_str.split('.');\n        let loc = this;\n        for (let i=0; i < path_parts.length; i++) {\n            const part = path_parts[i];\n            if (part === \"__proto__\" || part === \"constructor\") continue;\n\n            // while another part remains\n            if (i < (path_parts.length - 1)) {\n                if (loc[part] === undefined) loc[part] = {};   // initialize\n                loc = loc[part];   // descend\n                continue;\n            }\n\n            // last part, so assign the value\n            loc[part] = val;\n        }\n\n        // Set is_private, is_local automatically when remote.ip is set\n        if (prop_str === 'remote.ip') {\n            this.set('remote.is_local', net_utils.is_local_ip(this.remote.ip));\n            if (this.remote.is_local) {\n                this.set('remote.is_private', true);\n            }\n            else {\n                this.set('remote.is_private', net_utils.is_private_ip(this.remote.ip));\n            }\n        }\n    }\n    get (prop_str) {\n        return prop_str.split('.').reduce((prev, curr) => {\n            return prev ? prev[curr] : undefined\n        }, this)\n    }\n    set relaying (val) {\n        if (this.transaction) {\n            this.transaction._relaying = val;\n        }\n        else {\n            this._relaying = val;\n        }\n    }\n    get relaying () {\n        if (this.transaction && '_relaying' in this.transaction) return this.transaction._relaying;\n        return this._relaying;\n    }\n    process_line (line) {\n\n        if (this.state >= states.DISCONNECTING) {\n            if (logger.would_log(logger.LOGPROTOCOL)) {\n                this.logprotocol(`C: (after-disconnect): ${this.current_line}`, {'state': this.state});\n            }\n            this.loginfo(`data after disconnect from ${this.remote.ip}`);\n            return;\n        }\n\n        if (this.state === states.DATA) {\n            if (logger.would_log(logger.LOGDATA)) {\n                this.logdata(`C: ${line}`);\n            }\n            this.accumulate_data(line);\n            return;\n        }\n\n        this.current_line = line.toString(this.encoding).replace(/\\r?\\n/, '');\n        if (logger.would_log(logger.LOGPROTOCOL)) {\n            this.logprotocol(`C: ${this.current_line}`, {'state': this.state});\n        }\n\n        // Check for non-ASCII characters\n        /* eslint no-control-regex: 0 */\n        if (/[^\\x00-\\x7F]/.test(this.current_line)) {\n            // See if this is a TLS handshake\n            const buf = Buffer.from(this.current_line.substr(0,3), 'binary');\n            if (buf[0] === 0x16 && buf[1] === 0x03 &&\n               (buf[2] === 0x00 || buf[2] === 0x01) // SSLv3/TLS1.x format\n            ) {\n                // Nuke the current input buffer to prevent processing further input\n                this.current_data = null;\n                this.respond(501, 'SSL attempted over a non-SSL socket');\n                this.disconnect();\n                return;\n            }\n            else if (this.hello.verb == 'HELO') {\n                return this.respond(501, 'Syntax error (8-bit characters not allowed)');\n            }\n        }\n\n        if (this.state === states.CMD) {\n            this.state = states.PAUSE_SMTP;\n            const matches = /^([^ ]*)( +(.*))?$/.exec(this.current_line);\n            if (!matches) {\n                return plugins.run_hooks('unrecognized_command',\n                    this, [this.current_line]);\n            }\n            const cmd = matches[1];\n            const method = `cmd_${cmd.toLowerCase()}`;\n            const remaining = matches[3] || '';\n            if (this[method]) {\n                try {\n                    this[method](remaining);\n                }\n                catch (err) {\n                    if (err.stack) {\n                        this.logerror(`${method} failed: ${err}`);\n                        err.stack.split(\"\\n\").forEach(this.logerror);\n                    }\n                    else {\n                        this.logerror(`${method} failed: ${err}`);\n                    }\n                    this.respond(421, \"Internal Server Error\", () => {\n                        this.disconnect();\n                    });\n                }\n            }\n            else {\n                // unrecognized command\n                plugins.run_hooks('unrecognized_command', this, [ cmd, remaining ]);\n            }\n        }\n        else if (this.state === states.LOOP) {\n            // Allow QUIT\n            if (this.current_line.toUpperCase() === 'QUIT') {\n                this.cmd_quit();\n            }\n            else {\n                this.respond(this.loop_code, this.loop_msg);\n            }\n        }\n        else {\n            throw new Error(`unknown state ${this.state}`);\n        }\n    }\n    process_data (data) {\n        if (this.state >= states.DISCONNECTING) {\n            this.loginfo(`data after disconnect from ${this.remote.ip}`);\n            return;\n        }\n\n        if (!this.current_data || !this.current_data.length) {\n            this.current_data = data;\n        }\n        else {\n            // Data left over in buffer\n            const buf = Buffer.concat(\n                [ this.current_data, data ],\n                (this.current_data.length + data.length)\n            );\n            this.current_data = buf;\n        }\n\n        this._process_data();\n    }\n    _process_data () {\n        // We *must* detect disconnected connections here as the state\n        // only transitions to states.CMD in the respond function below.\n        // Otherwise if multiple commands are pipelined and then the\n        // connection is dropped; we'll end up in the function forever.\n        if (this.state >= states.DISCONNECTING) return;\n\n        let maxlength;\n        if (this.state === states.PAUSE_DATA || this.state === states.DATA) {\n            maxlength = this.max_data_line_length;\n        }\n        else {\n            maxlength = this.max_line_length;\n        }\n\n        let offset;\n        while (this.current_data && ((offset = utils.indexOfLF(this.current_data, maxlength)) !== -1)) {\n            if (this.state === states.PAUSE_DATA) {\n                return;\n            }\n            let this_line = this.current_data.slice(0, offset+1);\n            // Hack: bypass this code to allow HAProxy's PROXY extension\n            const proxyStart = this.proxy.allowed && /^PROXY /.test(this_line);\n            if (this.state === states.PAUSE && proxyStart) {\n                if (this.proxy.timer) clearTimeout(this.proxy.timer);\n                this.state = states.CMD;\n                this.current_data = this.current_data.slice(this_line.length);\n                this.process_line(this_line);\n            }\n            // Detect early_talker but allow PIPELINING extension (ESMTP)\n            else if ((this.state === states.PAUSE || this.state === states.PAUSE_SMTP) && !this.esmtp) {\n                // Allow EHLO/HELO to be pipelined with PROXY\n                if (this.proxy.allowed && /^(?:EH|HE)LO /i.test(this_line)) return;\n                if (!this.early_talker) {\n                    this_line = this_line.toString().replace(/\\r?\\n/,'');\n                    this.logdebug('[early_talker]', { state: this.state, esmtp: this.esmtp, line: this_line });\n                }\n                this.early_talker = true;\n                setImmediate(() => { this._process_data() });\n                break;\n            }\n            else if ((this.state === states.PAUSE || this.state === states.PAUSE_SMTP) && this.esmtp) {\n                let valid = true;\n                const cmd = this_line.toString('ascii').slice(0,4).toUpperCase();\n                switch (cmd) {\n                    case 'RSET':\n                    case 'MAIL':\n                    case 'SEND':\n                    case 'SOML':\n                    case 'SAML':\n                    case 'RCPT':\n                        // These can be anywhere in the group\n                        break;\n                    default:\n                        // Anything else *MUST* be the last command in the group\n                        if (this_line.length !== this.current_data.length) {\n                            valid = false;\n                        }\n                        break;\n                }\n                if (valid) {\n                    // Valid PIPELINING\n                    // We *don't want to process this yet otherwise the\n                    // current_data buffer will be lost.  The respond()\n                    // function will call this function again once it\n                    // has reset the state back to states.CMD and this\n                    // ensures that we only process one command at a\n                    // time.\n                    this.pipelining = true;\n                    this.logdebug(`pipeline: ${this_line}`);\n                }\n                else {\n                    // Invalid pipeline sequence\n                    // Treat this as early talker\n                    if (!this.early_talker) {\n                        this.logdebug('[early_talker]', { state: this.state, esmtp: this.esmtp, line: this_line });\n                    }\n                    this.early_talker = true;\n                    setImmediate(() => { this._process_data() });\n                }\n                break;\n            }\n            else {\n                this.current_data = this.current_data.slice(this_line.length);\n                this.process_line(this_line);\n            }\n        }\n\n        if (this.current_data && (this.current_data.length > maxlength) &&\n                (utils.indexOfLF(this.current_data, maxlength) === -1)) {\n            if (this.state !== states.DATA && this.state !== states.PAUSE_DATA) {\n                // In command mode, reject:\n                this.client.pause();\n                this.current_data = null;\n                return this.respond(521, \"Command line too long\", () => {\n                    this.disconnect();\n                });\n            }\n            else {\n                this.loginfo(`DATA line length (${this.current_data.length}) exceeds limit of ${maxlength} bytes`);\n                this.transaction.notes.data_line_length_exceeded = true;\n                const b = Buffer.concat([\n                    this.current_data.slice(0, maxlength - 2),\n                    Buffer.from(\"\\r\\n \", 'utf8'),\n                    this.current_data.slice(maxlength - 2)\n                ], this.current_data.length + 3);\n                this.current_data = b;\n                return this._process_data();\n            }\n        }\n    }\n    respond (code, msg, func) {\n        let uuid = '';\n        let messages;\n\n        if (this.state === states.DISCONNECTED) {\n            if (func) func();\n            return;\n        }\n        // Check to see if DSN object was passed in\n        if (typeof msg === 'object' && msg.constructor.name === 'DSN') {\n            // Override\n            code = msg.code;\n            msg = msg.reply;\n        }\n\n        if (!Array.isArray(msg)) {\n            messages = msg.toString().split(/\\n/);\n        }\n        else {\n            messages = msg.slice();\n        }\n        messages = messages.filter((msg2) => {\n            return /\\S/.test(msg2);\n        });\n\n        // Multiline AUTH PLAIN as in RFC-4954 page 8.\n        if (code === 334 && !messages.length) {\n            messages = [' '];\n        }\n\n        if (code >= 400) {\n            this.last_reject = `${code} ${messages.join(' ')}`;\n            if (this.deny_includes_uuid) {\n                uuid = (this.transaction || this).uuid;\n                if (this.deny_includes_uuid > 1) {\n                    uuid = uuid.substr(0, this.deny_includes_uuid);\n                }\n            }\n        }\n\n        let mess;\n        let buf = '';\n        const hostname = os.hostname().split('.').shift();\n        const _uuid = uuid ? `[${uuid}@${hostname}] ` : '';\n\n        while ((mess = messages.shift())) {\n            const line = `${code}${(messages.length ? \"-\" : \" \")}${_uuid}${mess}`;\n            this.logprotocol(`S: ${line}`);\n            buf = `${buf}${line}\\r\\n`;\n        }\n\n        if (this.client.write === undefined) return buf;  // testing\n\n        try {\n            this.client.write(buf);\n        }\n        catch (err) {\n            return this.fail(`Writing response: ${buf} failed: ${err}`);\n        }\n\n        // Store the last response\n        this.last_response = buf;\n\n        // Don't change loop state\n        if (this.state !== states.LOOP) {\n            this.state = states.CMD;\n        }\n\n        // Run optional closure before handling and further commands\n        if (func) func();\n\n        // Process any buffered commands (PIPELINING)\n        this._process_data();\n    }\n    fail (err, err_data) {\n        if (err) this.logwarn(err, err_data);\n        this.hooks_to_run = [];\n        this.disconnect();\n    }\n    disconnect () {\n        if (this.state >= states.DISCONNECTING) return;\n        this.state = states.DISCONNECTING;\n        this.current_data = null; // don't process any more data we have already received\n        this.reset_transaction(() => {\n            plugins.run_hooks('disconnect', this);\n        });\n    }\n    disconnect_respond () {\n        const logdetail = {\n            'ip': this.remote.ip,\n            'rdns': ((this.remote.host) ? this.remote.host : ''),\n            'helo': ((this.hello.host) ? this.hello.host : ''),\n            'relay': (this.relaying ? 'Y' : 'N'),\n            'early': (this.early_talker ? 'Y' : 'N'),\n            'esmtp': (this.esmtp ? 'Y' : 'N'),\n            'tls': (this.tls.enabled ? 'Y' : 'N'),\n            'pipe': (this.pipelining ? 'Y' : 'N'),\n            'errors': this.errors,\n            'txns': this.tran_count,\n            'rcpts': `${this.rcpt_count.accept}/${this.rcpt_count.tempfail}/${this.rcpt_count.reject}`,\n            'msgs': `${this.msg_count.accept}/${this.msg_count.tempfail}/${this.msg_count.reject}`,\n            'bytes': this.totalbytes,\n            'lr': ((this.last_reject) ? this.last_reject : ''),\n            'time': (Date.now() - this.start_time)/1000,\n        };\n\n        this.results.add({name: 'disconnect'}, {\n            duration: (Date.now() - this.start_time)/1000,\n        });\n        this.lognotice('disconnect', logdetail);\n        this.state = states.DISCONNECTED;\n        this.client.end();\n    }\n    get_capabilities () {\n        return [];\n    }\n    tran_uuid () {\n        this.tran_count++;\n        return `${this.uuid}.${this.tran_count}`;\n    }\n    reset_transaction (cb) {\n        this.results.add({name: 'reset'}, {\n            duration: (Date.now() - this.start_time)/1000,\n        });\n        if (this.transaction && this.transaction.resetting === false) {\n            // Pause connection to allow the hook to complete\n            this.pause();\n            this.transaction.resetting = true;\n            plugins.run_hooks('reset_transaction', this, cb);\n        }\n        else {\n            this.transaction = null;\n            if (cb) cb();\n        }\n    }\n    reset_transaction_respond (retval, msg, cb) {\n        if (this.transaction) {\n            this.transaction.message_stream.destroy();\n            this.transaction = null;\n        }\n        if (cb) cb();\n        // Allow the connection to continue\n        this.resume();\n    }\n    init_transaction (cb) {\n        this.reset_transaction(() => {\n            this.transaction = trans.createTransaction(this.tran_uuid(), this.cfg);\n            // Catch any errors from the message_stream\n            this.transaction.message_stream.on('error', (err) => {\n                this.logcrit(`message_stream error: ${err.message}`);\n                this.respond('421', 'Internal Server Error', () => {\n                    this.disconnect();\n                });\n            });\n            this.transaction.results = new ResultStore(this);\n            if (cb) cb();\n        });\n    }\n    loop_respond (code, msg) {\n        if (this.state >= states.DISCONNECTING) return;\n        this.state = states.LOOP;\n        this.loop_code = code;\n        this.loop_msg = msg;\n        this.respond(code, msg);\n    }\n    pause () {\n        if (this.state >= states.DISCONNECTING) return;\n        this.client.pause();\n        if (this.state !== states.PAUSE_DATA) this.prev_state = this.state;\n        this.state = states.PAUSE_DATA;\n    }\n    resume () {\n        if (this.state >= states.DISCONNECTING) return;\n        this.client.resume();\n        if (this.prev_state) {\n            this.state = this.prev_state;\n            this.prev_state = null;\n        }\n        setImmediate(() => this._process_data());\n    }\n    /////////////////////////////////////////////////////////////////////////////\n    // SMTP Responses\n    connect_init_respond (retval, msg) {\n        // retval and message are ignored\n        this.logdebug('running connect_init_respond');\n        plugins.run_hooks('lookup_rdns', this);\n    }\n    lookup_rdns_respond (retval, msg) {\n        switch (retval) {\n            case constants.ok:\n                this.set('remote', 'host', (msg || 'Unknown'));\n                this.set('remote', 'info', (this.remote.info || this.remote.host));\n                plugins.run_hooks('connect', this);\n                break;\n            case constants.deny:\n                this.loop_respond(554, msg || \"rDNS Lookup Failed\");\n                break;\n            case constants.denydisconnect:\n            case constants.disconnect:\n                this.respond(554, msg || \"rDNS Lookup Failed\", () => {\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.loop_respond(421, msg || \"rDNS Temporary Failure\");\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(421, msg || \"rDNS Temporary Failure\", () => {\n                    this.disconnect();\n                });\n                break;\n            default:\n                // BUG: dns.reverse throws on invalid input (and sometimes valid\n                // input nodejs/node#47847). Also throws when empty results\n                try {\n                    dns.reverse(this.remote.ip, (err, domains) => {\n                        this.rdns_response(err, domains);\n                    })\n                }\n                catch (err) {\n                    this.rdns_response(err, []);\n                }\n        }\n    }\n    rdns_response (err, domains) {\n        if (err) {\n            switch (err.code) {\n                case dns.NXDOMAIN:\n                case dns.NOTFOUND:\n                    this.set('remote', 'host', 'NXDOMAIN');\n                    break;\n                default:\n                    this.set('remote', 'host', 'DNSERROR');\n                    break;\n            }\n        }\n        else {\n            this.set('remote', 'host', (domains[0] || 'Unknown'));\n            this.results.add({name: 'remote'}, this.remote);\n        }\n        this.set('remote', 'info', this.remote.info || this.remote.host);\n        plugins.run_hooks('connect', this);\n    }\n    unrecognized_command_respond (retval, msg) {\n        switch (retval) {\n            case constants.ok:\n                // response already sent, cool...\n                break;\n            case constants.next_hook:\n                plugins.run_hooks(msg, this);\n                break;\n            case constants.deny:\n                this.respond(500, msg || \"Unrecognized command\");\n                break;\n            case constants.denydisconnect:\n            case constants.denysoftdisconnect:\n                this.respond(retval === constants.denydisconnect ? 521 : 421, msg || \"Unrecognized command\", () => {\n                    this.disconnect();\n                });\n                break;\n            default:\n                this.errors++;\n                this.respond(500, msg || \"Unrecognized command\");\n        }\n    }\n    connect_respond (retval, msg) {\n        // RFC 5321 Section 4.3.2 states that the only valid SMTP codes here are:\n        // 220 = Service ready\n        // 554 = Transaction failed (no SMTP service here)\n        // 421 = Service shutting down and closing transmission channel\n        switch (retval) {\n            case constants.deny:\n                this.loop_respond(554, msg || \"Your mail is not welcome here\");\n                break;\n            case constants.denydisconnect:\n            case constants.disconnect:\n                this.respond(554, msg || \"Your mail is not welcome here\", () => {\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.loop_respond(421, msg || \"Come back later\");\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(421, msg || \"Come back later\", () => {\n                    this.disconnect();\n                });\n                break;\n            default: {\n                let greeting = config.get('smtpgreeting', 'list');\n                if (greeting.length) {\n                    // RFC5321 section 4.2\n                    // Hostname/domain should appear after the 220\n                    greeting[0] = `${this.local.host} ESMTP ${greeting[0]}`;\n                    if (this.banner_includes_uuid) {\n                        greeting[0] += ` (${this.uuid})`;\n                    }\n                }\n                else {\n                    greeting = `${this.local.host} ESMTP ${this.local.info} ready`;\n                    if (this.banner_includes_uuid) {\n                        greeting += ` (${this.uuid})`;\n                    }\n                }\n                this.respond(220, msg || greeting);\n            }\n        }\n    }\n    get_remote (prop) {\n        switch (this.remote[prop]) {\n            case 'NXDOMAIN':\n            case 'DNSERROR':\n            case '':\n            case undefined:\n            case null:\n                return `[${this.remote.ip}]`;\n            default:\n                return `${this.remote[prop]} [${this.remote.ip}]`;\n        }\n    }\n    helo_respond (retval, msg) {\n        switch (retval) {\n            case constants.deny:\n                this.respond(550, msg || \"HELO denied\", () => {\n                    this.set('hello', 'verb', null);\n                    this.set('hello', 'host', null);\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(550, msg || \"HELO denied\", () => {\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(450, msg || \"HELO denied\", () => {\n                    this.set('hello', 'verb', null);\n                    this.set('hello', 'host', null);\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(450, msg || \"HELO denied\", () => {\n                    this.disconnect();\n                });\n                break;\n            default:\n                // RFC5321 section 4.1.1.1\n                // Hostname/domain should appear after 250\n                this.respond(250, `${this.local.host} Hello ${this.get_remote('host')}, ${this.ehlo_hello_message}`);\n        }\n    }\n    ehlo_respond (retval, msg) {\n\n        switch (retval) {\n            case constants.deny:\n                this.respond(550, msg || \"EHLO denied\", () => {\n                    this.set('hello', 'verb', null);\n                    this.set('hello', 'host', null);\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(550, msg || \"EHLO denied\", () => {\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(450, msg || \"EHLO denied\", () => {\n                    this.set('hello', 'verb', null);\n                    this.set('hello', 'host', null);\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(450, msg || \"EHLO denied\", () => {\n                    this.disconnect();\n                });\n                break;\n            default: {\n                // RFC5321 section 4.1.1.1\n                // Hostname/domain should appear after 250\n\n                const response = [\n                    `${this.local.host} Hello ${this.get_remote('host')}, ${this.ehlo_hello_message}`,\n                    \"PIPELINING\",\n                    \"8BITMIME\",\n                ];\n\n                if (this.cfg.main.smtputf8) {\n                    response.push(\"SMTPUTF8\");\n                }\n\n                response.push(`SIZE ${this.max_bytes}`);\n\n                this.capabilities = response;\n\n                plugins.run_hooks('capabilities', this);\n                this.esmtp = true;\n            }\n        }\n    }\n    capabilities_respond (retval, msg) {\n        this.respond(250, this.capabilities);\n    }\n    quit_respond (retval, msg) {\n        this.respond(221, msg || `${this.local.host} ${this.connection_close_message}`, () => {\n            this.disconnect();\n        });\n    }\n    vrfy_respond (retval, msg) {\n        switch (retval) {\n            case constants.deny:\n                this.respond(550, msg || \"Access Denied\", () => {\n                    this.reset_transaction();\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(550, msg || \"Access Denied\", () => {\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(450, msg || \"Lookup Failed\", () => {\n                    this.reset_transaction();\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(450, msg || \"Lookup Failed\", () => {\n                    this.disconnect();\n                });\n                break;\n            case constants.ok:\n                this.respond(250, msg || \"User OK\");\n                break;\n            default:\n                this.respond(252, \"Just try sending a mail and we'll see how it turns out...\");\n        }\n    }\n    noop_respond (retval, msg) {\n        switch (retval) {\n            case constants.deny:\n                this.respond(500, msg || \"Stop wasting my time\");\n                break;\n            case constants.denydisconnect:\n                this.respond(500, msg || \"Stop wasting my time\", () => {\n                    this.disconnect();\n                });\n                break;\n            default:\n                this.respond(250, \"OK\");\n        }\n    }\n    rset_respond (retval, msg) {\n        this.respond(250, \"OK\", () => {\n            this.reset_transaction();\n        })\n    }\n    mail_respond (retval, msg) {\n        if (!this.transaction) {\n            this.logerror(\"mail_respond found no transaction!\");\n            return;\n        }\n        const sender = this.transaction.mail_from;\n        const dmsg   = `sender ${sender.format()}`;\n        this.lognotice(\n            dmsg,\n            {\n                'code': constants.translate(retval),\n                'msg': (msg || ''),\n            }\n        );\n\n        const store_results = (action) => {\n            let addr = sender.format();\n            if (addr.length > 2) {  // all but null sender\n                addr = addr.substr(1, addr.length -2); // trim off < >\n            }\n            this.transaction.results.add({name: 'mail_from'}, {\n                action,\n                code: constants.translate(retval),\n                address: addr,\n            });\n        }\n\n        switch (retval) {\n            case constants.deny:\n                this.respond(550, msg || `${dmsg} denied`, () => {\n                    store_results('reject');\n                    this.reset_transaction();\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(550, msg ||  `${dmsg} denied`, () => {\n                    store_results('reject');\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(450, msg || `${dmsg} denied`, () => {\n                    store_results('tempfail');\n                    this.reset_transaction();\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(450, msg || `${dmsg} denied`, () => {\n                    store_results('tempfail');\n                    this.disconnect();\n                });\n                break;\n            default:\n                store_results('accept');\n                this.respond(250, msg || `${dmsg} OK`);\n        }\n    }\n    rcpt_incr (rcpt, action, msg, retval) {\n        this.transaction.rcpt_count[action]++;\n        this.rcpt_count[action]++;\n\n        const addr = rcpt.format();\n        const recipient = {\n            address: addr.substr(1, addr.length -2),\n            action\n        };\n\n        if (msg && action !== 'accept') {\n            if (typeof msg === 'object' && msg.constructor.name === 'DSN') {\n                recipient.msg  = msg.reply;\n                recipient.code = msg.code;\n            }\n            else {\n                recipient.msg  = msg;\n                recipient.code = constants.translate(retval);\n            }\n        }\n\n        this.transaction.results.push({name: 'rcpt_to'}, { recipient });\n    }\n    rcpt_ok_respond (retval, msg) {\n        if (!this.transaction) {\n            this.results.add(this, {err: 'rcpt_ok_respond found no transaction'});\n            return;\n        }\n        if (!msg) msg = this.last_rcpt_msg;\n        const rcpt = this.transaction.rcpt_to[this.transaction.rcpt_to.length - 1];\n        const dmsg = `recipient ${rcpt.format()}`;\n        // Log OK instead of CONT as this hook only runs if hook_rcpt returns OK\n        this.lognotice(\n            dmsg,\n            {\n                'code': constants.translate((retval === constants.cont ? constants.ok : retval)),\n                'msg': (msg || ''),\n                'sender': this.transaction.mail_from.address(),\n            }\n        );\n        switch (retval) {\n            case constants.deny:\n                this.respond(550, msg || `${dmsg} denied`, () => {\n                    this.rcpt_incr(rcpt, 'reject', msg, retval);\n                    this.transaction.rcpt_to.pop();\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(550, msg || `${dmsg} denied`, () => {\n                    this.rcpt_incr(rcpt, 'reject', msg, retval);\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(450, msg || `${dmsg} denied`, () => {\n                    this.rcpt_incr(rcpt, 'tempfail', msg, retval);\n                    this.transaction.rcpt_to.pop();\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(450, msg || `${dmsg} denied`, () => {\n                    this.rcpt_incr(rcpt, 'tempfail', msg, retval);\n                    this.disconnect();\n                });\n                break;\n            default:\n                this.respond(250, msg || `${dmsg} OK`, () => {\n                    this.rcpt_incr(rcpt, 'accept', msg, retval);\n                });\n        }\n    }\n    rcpt_respond (retval, msg) {\n        if (retval === constants.cont && this.relaying) {\n            retval = constants.ok;\n        }\n\n        if (!this.transaction) {\n            this.results.add(this, {err: 'rcpt_respond found no transaction'});\n            return;\n        }\n        const rcpt = this.transaction.rcpt_to[this.transaction.rcpt_to.length - 1];\n        const dmsg = `recipient ${rcpt.format()}`;\n        if (retval !== constants.ok) {\n            this.lognotice(\n                dmsg,\n                {\n                    'code': constants.translate((retval === constants.cont ? constants.ok : retval)),\n                    'msg': (msg || ''),\n                    'sender': this.transaction.mail_from.address(),\n                }\n            );\n        }\n        switch (retval) {\n            case constants.deny:\n                this.respond(550, msg || `${dmsg} denied`, () => {\n                    this.rcpt_incr(rcpt, 'reject', msg, retval);\n                    this.transaction.rcpt_to.pop();\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(550, msg || `${dmsg} denied`, () => {\n                    this.rcpt_incr(rcpt, 'reject', msg, retval);\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(450, msg || `${dmsg} denied`, () => {\n                    this.rcpt_incr(rcpt, 'tempfail', msg, retval);\n                    this.transaction.rcpt_to.pop();\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(450, msg || `${dmsg} denied`, () => {\n                    this.rcpt_incr(rcpt, 'tempfail', msg, retval);\n                    this.disconnect();\n                });\n                break;\n            case constants.ok:\n                // Store any msg for rcpt_ok\n                this.last_rcpt_msg = msg;\n                plugins.run_hooks('rcpt_ok', this, rcpt);\n                break;\n            default: {\n                if (retval !== constants.cont) {\n                    this.logalert(\"No plugin determined if relaying was allowed\");\n                }\n                const rej_msg = `I cannot deliver mail for ${rcpt.format()}`;\n                this.respond(550, rej_msg, () => {\n                    this.rcpt_incr(rcpt, 'reject', rej_msg, retval);\n                    this.transaction.rcpt_to.pop();\n                });\n            }\n        }\n    }\n    /////////////////////////////////////////////////////////////////////////////\n    // HAProxy support\n\n    cmd_proxy (line) {\n\n        if (!this.proxy.allowed) {\n            this.respond(421, `PROXY not allowed from ${this.remote.ip}`);\n            return this.disconnect();\n        }\n\n        const match = /(TCP4|TCP6|UNKNOWN) (\\S+) (\\S+) (\\d+) (\\d+)$/.exec(line);\n        if (!match) {\n            this.respond(421, 'Invalid PROXY format');\n            return this.disconnect();\n        }\n        const proto = match[1];\n        const src_ip = match[2];\n        const dst_ip = match[3];\n        const src_port = match[4];\n        const dst_port = match[5];\n\n        // Validate source/destination IP\n        /*eslint no-fallthrough: 0 */\n        switch (proto) {\n            case 'TCP4':\n                if (ipaddr.IPv4.isValid(src_ip) && ipaddr.IPv4.isValid(dst_ip)) {\n                    break;\n                }\n            case 'TCP6':\n                if (ipaddr.IPv6.isValid(src_ip) && ipaddr.IPv6.isValid(dst_ip)) {\n                    break;\n                }\n            // case 'UNKNOWN':\n            default:\n                this.respond(421, 'Invalid PROXY format');\n                return this.disconnect();\n        }\n\n        // Apply changes\n        this.loginfo(\n            'HAProxy',\n            {\n                proto,\n                src_ip: `${src_ip}:${src_port}`,\n                dst_ip: `${dst_ip}:${dst_port}`,\n            }\n        );\n\n        this.notes.proxy = {\n            type: 'haproxy',\n            proto,\n            src_ip,\n            src_port,\n            dst_ip,\n            dst_port,\n            proxy_ip: this.remote.ip\n        };\n\n        this.reset_transaction(() => {\n            this.set('proxy.ip', this.remote.ip);\n            this.set('proxy.type', 'haproxy');\n            this.relaying = false;\n            this.set('local.ip', dst_ip);\n            this.set('local.port', parseInt(dst_port, 10));\n            this.set('remote.ip', src_ip);\n            this.set('remote.port', parseInt(src_port, 10));\n            this.set('remote.host', null);\n            this.set('hello.host', null);\n            plugins.run_hooks('connect_init', this);\n        });\n    }\n    /////////////////////////////////////////////////////////////////////////////\n    // SMTP Commands\n\n    cmd_internalcmd (line) {\n        if (!this.remote.is_local) {\n            return this.respond(501, \"INTERNALCMD not allowed remotely\");\n        }\n        const results = (String(line)).split(/ +/);\n        if (/key:/.test(results[0])) {\n            const internal_key = config.get('internalcmd_key');\n            if (results[0] != `key:${internal_key}`) {\n                return this.respond(501, \"Invalid internalcmd_key - check config\");\n            }\n            results.shift();\n        }\n        else if (config.get('internalcmd_key')) {\n            return this.respond(501, \"Missing internalcmd_key - check config\");\n        }\n\n        // Now send the internal command to the master process\n        const command = results.shift();\n        if (!command) {\n            return this.respond(501, \"No command given\");\n        }\n\n        require('./server').sendToMaster(command, results);\n        return this.respond(250, \"Command sent for execution. Check Haraka logs for results.\");\n    }\n    cmd_helo (line) {\n        const results = (String(line)).split(/ +/);\n        const host = results[0];\n        if (!host) {\n            return this.respond(501, \"HELO requires domain/address - see RFC-2821 4.1.1.1\");\n        }\n\n        this.reset_transaction(() => {\n            this.set('hello', 'verb', 'HELO');\n            this.set('hello', 'host', host);\n            this.results.add({ name: 'helo' }, this.hello);\n            plugins.run_hooks('helo', this, host);\n        });\n    }\n    cmd_ehlo (line) {\n        const results = (String(line)).split(/ +/);\n        const host = results[0];\n        if (!host) {\n            return this.respond(501, \"EHLO requires domain/address - see RFC-2821 4.1.1.1\");\n        }\n\n        this.reset_transaction(() => {\n            this.set('hello', 'verb', 'EHLO');\n            this.set('hello', 'host', host);\n            this.results.add({ name: 'helo' }, this.hello);\n            plugins.run_hooks('ehlo', this, host);\n        });\n    }\n    cmd_quit (args) {\n        // RFC 5321 Section 4.3.2\n        // QUIT does not accept arguments\n        if (args) {\n            return this.respond(501, \"Syntax error\");\n        }\n        plugins.run_hooks('quit', this);\n    }\n    cmd_rset (args) {\n        // RFC 5321 Section 4.3.2\n        // RSET does not accept arguments\n        if (args) {\n            return this.respond(501, \"Syntax error\");\n        }\n        plugins.run_hooks('rset', this);\n    }\n    cmd_vrfy (line) {\n        // only supported via plugins\n        plugins.run_hooks('vrfy', this);\n    }\n    cmd_noop () {\n        plugins.run_hooks('noop', this);\n    }\n    cmd_help () {\n        this.respond(250, \"Not implemented\");\n    }\n    cmd_mail (line) {\n        if (!this.hello.host) {\n            this.errors++;\n            return this.respond(503, 'Use EHLO/HELO before MAIL');\n        }\n        // Require authentication on ports 587 & 465\n        if (!this.relaying && [587,465].includes(this.local.port)) {\n            this.errors++;\n            return this.respond(550, 'Authentication required');\n        }\n\n        let results;\n        try {\n            results = rfc1869.parse('mail', line, this.cfg.main.strict_rfc1869 && !this.relaying);\n        }\n        catch (err) {\n            this.errors++;\n            if (err.stack) {\n                this.lognotice(err.stack.split(/\\n/)[0]);\n            }\n            else {\n                this.logerror(err);\n            }\n            // Explicitly handle out-of-disk space errors\n            if (err.code === 'ENOSPC') {\n                return this.respond(452, 'Internal Server Error');\n            }\n            else {\n                return this.respond(501, ['Command parsing failed', err]);\n            }\n        }\n\n        let from;\n        try {\n            from = new Address(results.shift());\n        }\n        catch (err) {\n            return this.respond(501, `Invalid MAIL FROM address`);\n        }\n\n        // Get rest of key=value pairs\n        const params = {};\n        results.forEach(param => {\n            const kv = param.match(/^([^=]+)(?:=(.+))?$/);\n            if (kv)\n                params[kv[1].toUpperCase()] = kv[2] || null;\n        });\n\n        // Parameters are only valid if EHLO was sent\n        if (!this.esmtp && Object.keys(params).length > 0) {\n            return this.respond(555, 'Invalid command parameters');\n        }\n\n        // Handle SIZE extension\n        if (params?.SIZE && params.SIZE > 0) {\n            if (this.max_bytes > 0 && params.SIZE > this.max_bytes) {\n                return this.respond(550, 'Message too big!');\n            }\n        }\n\n        this.init_transaction(() => {\n            this.transaction.mail_from = from;\n            if (this.hello.verb == 'HELO') {\n                this.transaction.encoding = 'binary';\n                this.encoding = 'binary';\n            }\n            plugins.run_hooks('mail', this, [from, params]);\n        });\n    }\n    cmd_rcpt (line) {\n        if (!this.transaction || !this.transaction.mail_from) {\n            this.errors++;\n            return this.respond(503, \"Use MAIL before RCPT\");\n        }\n\n        let results;\n        try {\n            results = rfc1869.parse('rcpt', line, this.cfg.main.strict_rfc1869 && !this.relaying);\n        }\n        catch (err) {\n            this.errors++;\n            if (err.stack) {\n                this.lognotice(err.stack.split(/\\n/)[0]);\n            }\n            else {\n                this.logerror(err);\n            }\n            // Explicitly handle out-of-disk space errors\n            if (err.code === 'ENOSPC') {\n                return this.respond(452, 'Internal Server Error');\n            }\n            else {\n                return this.respond(501, [\"Command parsing failed\", err]);\n            }\n        }\n\n        let recip;\n        try {\n            recip = new Address(results.shift());\n        }\n        catch (err) {\n            return this.respond(501, `Invalid RCPT TO address`);\n        }\n\n        // Get rest of key=value pairs\n        const params = {};\n        results.forEach((param) => {\n            const kv = param.match(/^([^=]+)(?:=(.+))?$/);\n            if (kv)\n                params[kv[1].toUpperCase()] = kv[2] || null;\n        });\n\n        // Parameters are only valid if EHLO was sent\n        if (!this.esmtp && Object.keys(params).length > 0) {\n            return this.respond(555, 'Invalid command parameters');\n        }\n\n        this.transaction.rcpt_to.push(recip);\n        plugins.run_hooks('rcpt', this, [recip, params]);\n    }\n    received_line () {\n        let smtp = this.hello.verb === 'EHLO' ? 'ESMTP' : 'SMTP';\n        // Implement RFC3848\n        if (this.tls.enabled) smtp += 'S';\n        if (this.authheader) smtp += 'A';\n\n        let sslheader;\n\n        if (this.get('tls.cipher.version')) {\n            // standardName appeared in Node.js v12.16 and v13.4\n            // RFC 8314\n            sslheader = `tls ${this.tls.cipher.standardName || this.tls.cipher.name}`;\n        }\n\n        let received_header = `from ${this.hello.host} (${this.get_remote('info')})\\r\n\\tby ${this.local.host} (${this.local.info}) with ${smtp} id ${this.transaction.uuid}\\r\n\\tenvelope-from ${this.transaction.mail_from.format()}`;\n\n        if (sslheader)       received_header += `\\r\\n\\t${sslheader.replace(/\\r?\\n\\t?$/,'')}`\n\n        // Does not follow RFC 5321 section 4.4 grammar\n        if (this.authheader) received_header += ` ${this.authheader.replace(/\\r?\\n\\t?$/, '')}`\n\n        received_header += `;\\r\\n\\t${utils.date_to_str(new Date())}`\n\n        return received_header;\n    }\n    auth_results (message) {\n        // https://datatracker.ietf.org/doc/rfc7001/\n        const has_tran = !!((this.transaction?.notes));\n\n        // initialize connection note\n        if (!this.notes.authentication_results) {\n            this.notes.authentication_results = [];\n        }\n\n        // initialize transaction note, if possible\n        if (has_tran === true && !this.transaction.notes.authentication_results) {\n            this.transaction.notes.authentication_results = [];\n        }\n\n        // if message, store it in the appropriate note\n        if (message) {\n            if (has_tran === true) {\n                this.transaction.notes.authentication_results.push(message);\n            }\n            else {\n                this.notes.authentication_results.push(message);\n            }\n        }\n\n        // assemble the new header\n        let header = [ this.local.host ];\n        header = header.concat(this.notes.authentication_results);\n        if (has_tran === true) {\n            header = header.concat(this.transaction.notes.authentication_results);\n        }\n        if (header.length === 1) return '';  // no results\n        return header.join(\";\\r\\n\\t\");\n    }\n    auth_results_clean () {\n        // move any existing Auth-Res headers to Original-Auth-Res headers\n        // http://tools.ietf.org/html/draft-kucherawy-original-authres-00.html\n        const ars = this.transaction.header.get_all('Authentication-Results');\n        if (ars.length === 0) return;\n\n        for (const element of ars) {\n            this.transaction.add_header('Original-Authentication-Results', element);\n        }\n        this.transaction.remove_header('Authentication-Results');\n        this.logdebug(\"Authentication-Results moved to Original-Authentication-Results\");\n    }\n    cmd_data (args) {\n        // RFC 5321 Section 4.3.2\n        // DATA does not accept arguments\n        if (args) {\n            this.errors++;\n            return this.respond(501, \"Syntax error\");\n        }\n        if (!this.transaction) {\n            this.errors++;\n            return this.respond(503, \"MAIL required first\");\n        }\n        if (!this.transaction.rcpt_to.length) {\n            if (this.pipelining) {\n                return this.respond(554, \"No valid recipients\");\n            }\n            this.errors++;\n            return this.respond(503, \"RCPT required first\");\n        }\n\n        if (this.cfg.headers.add_received) {\n            this.accumulate_data(`Received: ${this.received_line()}\\r\\n`);\n        }\n        plugins.run_hooks('data', this);\n    }\n    data_respond (retval, msg) {\n        let cont = 0;\n        switch (retval) {\n            case constants.deny:\n                this.respond(554, msg || \"Message denied\", () => {\n                    this.reset_transaction();\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(554, msg || \"Message denied\", () => {\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(451, msg || \"Message denied\", () => {\n                    this.reset_transaction();\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(451, msg || \"Message denied\", () => {\n                    this.disconnect();\n                });\n                break;\n            default:\n                cont = 1;\n        }\n        if (!cont) return;\n\n        // We already checked for MAIL/RCPT in cmd_data\n        this.respond(354, \"go ahead, make my day\", () => {\n            // OK... now we get the data\n            this.state = states.DATA;\n            this.transaction.data_bytes = 0;\n        });\n    }\n    accumulate_data (line) {\n\n        this.transaction.data_bytes += line.length;\n\n        // Look for .\\r\\n\n        if (line.length === 3 &&\n            line[0] === 0x2e &&\n            line[1] === 0x0d &&\n            line[2] === 0x0a) {\n            this.data_done();\n            return;\n        }\n\n        // Look for .\\n\n        if (line.length === 2 &&\n            line[0] === 0x2e &&\n            line[1] === 0x0a) {\n            this.lognotice('Client sent bare line-feed - .\\\\n rather than .\\\\r\\\\n');\n            this.respond(451, \"Bare line-feed; see http://haraka.github.io/barelf/\", () => {\n                this.reset_transaction();\n            });\n            return;\n        }\n\n        // Stop accumulating data as we're going to reject at dot.\n        if (this.max_bytes && this.transaction.data_bytes > this.max_bytes) {\n            return;\n        }\n\n        if (this.transaction.mime_part_count >= this.max_mime_parts) {\n            this.logcrit(\"Possible DoS attempt - too many MIME parts\");\n            this.respond(554, \"Transaction failed due to too many MIME parts\", () => {\n                this.disconnect();\n            });\n            return;\n        }\n\n        this.transaction.add_data(line);\n    }\n    data_done () {\n        this.pause();\n        this.totalbytes += this.transaction.data_bytes;\n\n        // Check message size limit\n        if (this.max_bytes && this.transaction.data_bytes > this.max_bytes) {\n            this.lognotice(`Incoming message exceeded databytes size of ${this.max_bytes}`);\n            return plugins.run_hooks('max_data_exceeded', this);\n        }\n\n        // Check max received headers count\n        if (this.transaction.header.get_all('received').length > this.cfg.headers.max_received) {\n            this.logerror(\"Incoming message had too many Received headers\");\n            this.respond(550, \"Too many received headers - possible mail loop\", () => {\n                this.reset_transaction();\n            });\n            return;\n        }\n\n        // Warn if we hit the maximum parsed header lines limit\n        if (this.transaction.header_lines.length >= this.cfg.headers.max_lines) {\n            this.logwarn(`Incoming message reached maximum parsing limit of ${this.cfg.headers.max_lines} header lines`);\n        }\n\n        if (this.cfg.headers.clean_auth_results) {\n            this.auth_results_clean();   // rename old A-R headers\n        }\n        const ar_field = this.auth_results();  // assemble new one\n        if (ar_field) {\n            this.transaction.add_header('Authentication-Results', ar_field);\n        }\n\n        this.transaction.end_data(() => {\n            // As this will be called asynchronously,\n            // make sure we still have a transaction.\n            if (!this.transaction) return;\n            // Record the start time of this hook as we can't take too long\n            // as the client will typically hang up after 2 to 3 minutes\n            // despite the RFC mandating that 10 minutes should be allowed.\n            this.transaction.data_post_start = Date.now();\n            plugins.run_hooks('data_post', this);\n        });\n    }\n    data_post_respond (retval, msg) {\n        if (!this.transaction) return;\n        this.transaction.data_post_delay = (Date.now() - this.transaction.data_post_start)/1000;\n        const mid = this.transaction.header.get('Message-ID') || '';\n        this.lognotice(\n            'message',\n            {\n                'mid': mid.replace(/\\r?\\n/,''),\n                'size': this.transaction.data_bytes,\n                'rcpts': `${this.transaction.rcpt_count.accept}/${this.transaction.rcpt_count.tempfail}/${this.transaction.rcpt_count.reject}`,\n                'delay': this.transaction.data_post_delay,\n                'code':  constants.translate(retval),\n                'msg': (msg || ''),\n            }\n        );\n        const ar_field = this.auth_results();  // assemble A-R header\n        if (ar_field) {\n            this.transaction.remove_header('Authentication-Results');\n            this.transaction.add_leading_header('Authentication-Results', ar_field);\n        }\n        switch (retval) {\n            case constants.deny:\n                this.respond(550, msg || \"Message denied\", () => {\n                    this.msg_count.reject++;\n                    this.transaction.msg_status = 'rejected';\n                    this.reset_transaction(() => this.resume());\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(550, msg || \"Message denied\",() => {\n                    this.msg_count.reject++;\n                    this.transaction.msg_status = 'rejected';\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(450, msg || \"Message denied temporarily\", () =>  {\n                    this.msg_count.tempfail++;\n                    this.transaction.msg_status = 'deferred';\n                    this.reset_transaction(() => this.resume());\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(450, msg || \"Message denied temporarily\",() => {\n                    this.msg_count.tempfail++;\n                    this.transaction.msg_status = 'deferred';\n                    this.disconnect();\n                });\n                break;\n            default:\n                if (this.relaying) {\n                    plugins.run_hooks(\"queue_outbound\", this);\n                }\n                else {\n                    plugins.run_hooks(\"queue\", this);\n                }\n        }\n    }\n    max_data_exceeded_respond (retval, msg) {\n        // TODO: Maybe figure out what to do with other return codes\n        this.respond(retval === constants.denysoft ? 450 : 550, \"Message too big!\", () => {\n            this.reset_transaction();\n        });\n    }\n    queue_msg (retval, msg) {\n        if (msg) {\n            if (typeof msg === 'object' && msg.constructor.name === 'DSN') {\n                return msg.reply\n            }\n            return msg;\n        }\n\n        switch (retval) {\n            case constants.ok:\n                return 'Message Queued';\n            case constants.deny:\n            case constants.denydisconnect:\n                return 'Message denied';\n            case constants.denysoft:\n            case constants.denysoftdisconnect:\n                return 'Message denied temporarily';\n            default:\n                return '';\n        }\n    }\n    store_queue_result (retval, msg) {\n        const res_as = {name: 'queue'};\n        switch (retval) {\n            case constants.ok:\n                this.transaction.results.add(res_as, { pass: msg });\n                break;\n            case constants.deny:\n            case constants.denydisconnect:\n            case constants.denysoft:\n            case constants.denysoftdisconnect:\n                this.transaction.results.add(res_as, { fail: msg });\n                break;\n            case constants.cont:\n                break;\n            default:\n                this.transaction.results.add(res_as, { msg });\n                break;\n        }\n    }\n    queue_outbound_respond (retval, msg) {\n        if (this.remote.closed) return;\n        msg = this.queue_msg(retval, msg) || 'Message Queued';\n        this.store_queue_result(retval, msg);\n        msg = `${msg} (${this.transaction.uuid})`;\n        if (retval !== constants.ok) {\n            this.lognotice(\n                'queue',\n                {\n                    code: constants.translate(retval),\n                    msg\n                }\n            );\n        }\n        switch (retval) {\n            case constants.ok:\n                plugins.run_hooks('queue_ok', this, msg);\n                break;\n            case constants.deny:\n                this.respond(550, msg, () => {\n                    this.msg_count.reject++;\n                    this.transaction.msg_status = 'rejected';\n                    this.reset_transaction(() => this.resume());\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(550, msg, () => {\n                    this.msg_count.reject++;\n                    this.transaction.msg_status = 'rejected';\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(450, msg, () => {\n                    this.msg_count.tempfail++;\n                    this.transaction.msg_status = 'deferred';\n                    this.reset_transaction(() => this.resume());\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(450, msg, () => {\n                    this.msg_count.tempfail++;\n                    this.transaction.msg_status = 'deferred';\n                    this.disconnect();\n                });\n                break;\n            default:\n                outbound.send_trans_email(this.transaction, (retval2, msg2) => {\n                    if (!msg2) msg2 = this.queue_msg(retval2, msg);\n                    switch (retval2) {\n                        case constants.ok:\n                            if (!msg2) msg2 = this.queue_msg(retval2, msg2);\n                            plugins.run_hooks('queue_ok', this, msg2);\n                            break;\n                        case constants.deny:\n                            if (!msg2) msg2 = this.queue_msg(retval2, msg2);\n                            this.respond(550, msg2, () => {\n                                this.msg_count.reject++;\n                                this.transaction.msg_status = 'rejected';\n                                this.reset_transaction(() => {\n                                    this.resume();\n                                });\n                            });\n                            break;\n                        default:\n                            this.logerror(`Unrecognized response from outbound layer: ${retval2} : ${msg2}`);\n                            this.respond(550, msg2 || \"Internal Server Error\", () => {\n                                this.msg_count.reject++;\n                                this.transaction.msg_status = 'rejected';\n                                this.reset_transaction(() => {\n                                    this.resume();\n                                });\n                            });\n                    }\n                });\n        }\n    }\n    queue_respond (retval, msg) {\n        msg = this.queue_msg(retval, msg);\n        this.store_queue_result(retval, msg);\n        msg = `${msg} (${this.transaction.uuid})`;\n\n        if (retval !== constants.ok) {\n            this.lognotice(\n                'queue',\n                {\n                    code: constants.translate(retval),\n                    msg\n                }\n            );\n        }\n        switch (retval) {\n            case constants.ok:\n                plugins.run_hooks('queue_ok', this, msg);\n                break;\n            case constants.deny:\n                this.respond(550, msg, () => {\n                    this.msg_count.reject++;\n                    this.transaction.msg_status = 'rejected';\n                    this.reset_transaction(() =>  this.resume());\n                });\n                break;\n            case constants.denydisconnect:\n                this.respond(550, msg, () => {\n                    this.msg_count.reject++;\n                    this.transaction.msg_status = 'rejected';\n                    this.disconnect();\n                });\n                break;\n            case constants.denysoft:\n                this.respond(450, msg, () => {\n                    this.msg_count.tempfail++;\n                    this.transaction.msg_status = 'deferred';\n                    this.reset_transaction(() => this.resume());\n                });\n                break;\n            case constants.denysoftdisconnect:\n                this.respond(450, msg, () => {\n                    this.msg_count.tempfail++;\n                    this.transaction.msg_status = 'deferred';\n                    this.disconnect();\n                });\n                break;\n            default:\n                if (!msg) msg = 'Queuing declined or disabled, try later';\n                this.respond(451, msg, () => {\n                    this.msg_count.tempfail++;\n                    this.transaction.msg_status = 'deferred';\n                    this.reset_transaction(() => this.resume());\n                });\n                break;\n        }\n    }\n    queue_ok_respond (retval, msg, params) {\n        // This hook is common to both hook_queue and hook_queue_outbound\n        // retval and msg are ignored in this hook so we always log OK\n        this.lognotice(\n            'queue',\n            {\n                code: 'OK',\n                msg: (params || '')\n            }\n        );\n\n        this.respond(250, params, () => {\n            this.msg_count.accept++;\n            if (this.transaction) this.transaction.msg_status = 'accepted';\n            this.reset_transaction(() => this.resume());\n        });\n    }\n}\n\nexports.Connection = Connection;\n\nexports.createConnection = (client, server, cfg) => {\n    return new Connection(client, server, cfg);\n}\n\nlogger.add_log_methods(Connection)\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "endpoint.js",
          "type": "blob",
          "size": 2.0595703125,
          "content": "'use strict';\n// Socket address parser/formatter and server binding helper\n\nconst fs = require('node:fs/promises');\nconst sockaddr = require('sockaddr');\n\nmodule.exports = function endpoint (addr, defaultPort) {\n    try {\n        if ('string' === typeof addr || 'number' === typeof addr) {\n            addr = sockaddr(addr, {defaultPort});\n            const match = /^(.*):([0-7]{3})$/.exec(addr.path || '');\n            if (match) {\n                addr.path = match[1];\n                addr.mode = match[2];\n            }\n        }\n    }\n    catch (err) {\n        // Return the parse exception instead of throwing it\n        return err;\n    }\n    return new Endpoint(addr);\n}\n\nclass Endpoint {\n\n    constructor (addr) {\n        if (addr.path) {\n            this.path = addr.path;\n            if (addr.mode) this.mode = addr.mode;\n        }\n        else {\n            // Handle server.address() return as well as parsed host/port\n            const host = addr.address || addr.host || '::0';\n            // Normalize '::' to '::0'\n            this.host = ('::' === host) ? '::0' : host ;\n            this.port = parseInt(addr.port, 10);\n        }\n    }\n\n    toString () {\n        if (this.mode) return `${this.path}:${this.mode}`;\n        if (this.path) return this.path;\n        if (this.host.includes(':')) return `[${this.host}]:${this.port}`;\n        return `${this.host}:${this.port}`;\n    }\n\n    // Make server listen on this endpoint, w/optional options\n    async bind (server, opts) {\n        opts = {...opts};\n\n        const mode = this.mode ? parseInt(this.mode, 8) : false;\n        if (this.path) {\n            opts.path = this.path;\n            await fs.rm(this.path, { force: true }); // errors are ignored when force is true\n        } else {\n            opts.host = this.host;\n            opts.port = this.port;\n        }\n        \n        return new Promise((resolve, reject) => {\n            server.listen(opts, async (err) => {\n                if(err) return reject(err);\n                if (mode) await fs.chmod(opts.path, mode);\n                resolve()\n            });\n        });\n    }\n}\n"
        },
        {
          "name": "eslint.config.mjs",
          "type": "blob",
          "size": 0.662109375,
          "content": "import globals from \"globals\";\nimport path from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport js from \"@eslint/js\";\nimport { FlatCompat } from \"@eslint/eslintrc\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst compat = new FlatCompat({\n    baseDirectory: __dirname,\n    recommendedConfig: js.configs.recommended,\n    allConfig: js.configs.all\n});\n\nexport default [...compat.extends(\"@haraka\"), {\n    languageOptions: {\n        globals: {\n            ...globals.node,\n        },\n    },\n\n    rules: {\n        \"prefer-template\": \"warn\",\n        \"no-unneeded-ternary\": 1,\n        \"no-unused-vars\": 0,\n    },\n}];"
        },
        {
          "name": "haraka.js",
          "type": "blob",
          "size": 2.044921875,
          "content": "#!/usr/bin/env node\n\n'use strict';\nconst path = require('path');\nconst makePathJoin = () => path.join(process.env.HARAKA, 'node_modules');\n\nif (!process.env.HARAKA) {\n    console.warn(\"WARNING: Not running installed Haraka - command line arguments ignored\")\n}\n\n// this must be set before \"server.js\" is loaded\nprocess.env.HARAKA = process.env.HARAKA || path.resolve('.');\ntry {\n    require.paths.push(makePathJoin());\n}\ncatch (e) {\n    process.env.NODE_PATH = process.env.NODE_PATH ?\n        (`${process.env.NODE_PATH}:${makePathJoin()}`) :\n        (makePathJoin());\n    require('module')._initPaths(); // Horrible hack\n}\n\nconst utils = require('haraka-utils');\nconst logger = require('./logger');\nconst server = require('./server');\n\nexports.version = utils.getVersion(__dirname)\n\nprocess.on('uncaughtException', err => {\n    if (err.stack) {\n        err.stack.split(\"\\n\").forEach(line => logger.crit(line));\n    }\n    else {\n        logger.crit(`Caught exception: ${JSON.stringify(err)}`);\n    }\n    logger.dump_and_exit(1);\n});\n\nlet shutting_down = false;\nconst signals = ['SIGINT'];\n\nif (process.pid === 1) signals.push('SIGTERM')\n\nfor (const sig of signals) {\n    process.on(sig, () => {\n        if (shutting_down) return process.exit(1);\n        shutting_down = true;\n        const [, filename] = process.argv;\n        process.title = path.basename(filename, '.js');\n\n        logger.notice(`${sig} received`);\n        logger.dump_and_exit(() => {\n            if (server.cluster?.isMaster) {\n                server.performShutdown();\n            }\n            else if (!server.cluster) {\n                server.performShutdown();\n            }\n        });\n    });\n}\n\nprocess.on('SIGHUP', () => {\n    logger.notice('Flushing the temp fail queue');\n    server.flushQueue();\n});\n\nprocess.on('exit', code => {\n    if (shutting_down) return;\n    const [, filename] = process.argv;\n    process.title = path.basename(filename, '.js');\n\n    logger.notice('Shutting down');\n    logger.dump_logs();\n});\n\nlogger.log('NOTICE', `Starting up Haraka version ${exports.version}`);\n\nserver.createServer();\n"
        },
        {
          "name": "haraka.sh",
          "type": "blob",
          "size": 0.046875,
          "content": "#!/bin/sh\nexec haraka -c /usr/local/haraka 2>&1\n"
        },
        {
          "name": "host_pool.js",
          "type": "blob",
          "size": 5.2548828125,
          "content": "'use strict';\n\nconst net    = require('node:net');\nconst utils  = require('haraka-utils');\n\n/* HostPool:\n *\n * Starts with a pool of backend hosts from a \"forwarding_host_pool\"\n * configuration that looks like this (port defaults to 25 if not set):\n *\n *      1.1.1.1:11, 2.2.2.2:22, 3.3.3.3:33\n *\n * It randomizes the list and then gives then out sequentially (for\n * predictability).\n *\n * If failed() is called with one of the hosts, we mark it down for retry_secs\n * and don't give it out again until that period has passed.\n *\n * If *all* the hosts have been marked down, ignore the marks and give\n * out the next host. That's to keep a random short-lived but widespread\n * network failure from taking the whole system down.\n */\n\nconst logger = require('./logger');\n\nclass HostPool {\n\n    // takes a comma/space-separated list of ip:ports\n    //  1.1.1.1:22,  3.3.3.3:44\n    constructor (hostports_str, retry_secs) {\n        const hosts = (hostports_str || '')\n            .trim()\n            .split(/[\\s,]+/)\n            .map(hostport => {\n                const splithost = hostport.split(/:/);\n                if (! splithost[1]){\n                    splithost[1] = 25;\n                }\n                return {\n                    host: splithost[0],\n                    port: splithost[1]\n                };\n            });\n        this.hostports_str = hostports_str;\n        this.hosts = utils.shuffle(hosts);\n        this.dead_hosts = {};  // hostport => true/false\n        this.last_i = 0;  // the last one we checked\n        this.retry_secs = retry_secs || 10;\n    }\n\n    /* failed\n     *\n     * Part of the external API for this module. Call it when you see a failure to\n     * this backend host and it'll come out of the pool and put into the recheck\n     * timer.\n     */\n    failed (host, port) {\n        const self = this;\n        const key = `${host}:${port}`;\n        const retry_msecs = self.retry_secs * 1000;\n        self.dead_hosts[key] = true;\n\n        function cb_if_still_dead () {\n            logger.warn(`${host} ${key} is still dead, will retry in ${self.retry_secs} secs`);\n            self.dead_hosts[key] = true;\n            // console.log(1);\n            setTimeout(() => {\n                self.probe_dead_host(host, port, cb_if_still_dead, cb_if_alive);\n            }, retry_msecs);\n        }\n\n        function cb_if_alive () {\n            // console.log(2);\n            logger.info(`${host} ${key} is back! adding back into pool`);\n            delete self.dead_hosts[key];\n        }\n\n        setTimeout(() => {\n            self.probe_dead_host(host, port, cb_if_still_dead, cb_if_alive);\n        }, retry_msecs);\n    }\n\n    /* probe_dead_host\n     *\n     * When the timer fires, we'll ping the host, and if it's still dead we'll\n     * update the dead_hosts list.  If it's back online, we just don't touch the\n     * dead_hosts lists, and the next time get_host() is called, it'll be in the\n     * mix.\n     */\n    probe_dead_host (\n        host, port, cb_if_still_dead, cb_if_alive\n    ){\n        logger.info(`probing dead host ${host}:${port}`);\n\n        const connect_timeout_ms = 200; // keep it snappy\n        let s;\n        try {\n            s = this.get_socket();\n            s.setTimeout(connect_timeout_ms, () => {\n                // nobody home, it's still dead\n                s.destroy();\n                cb_if_still_dead();\n            });\n            s.on('error', e => {\n                // silently catch all errors - assume the port is closed\n                s.destroy();\n                cb_if_still_dead();\n            });\n\n            s.connect(port, host, () => {\n                cb_if_alive();\n                s.destroy(); // will this conflict with setTimeout's s.destroy?\n            });\n        }\n        catch (e) {\n            // only way to catch run-time javascript errors in here;\n            console.log(`ERROR in probe_dead_host, got error ${e}`);\n            throw e;\n        }\n    }\n\n    /* get_socket\n     *\n     * so we can override in unit test\n     */\n    get_socket () {\n        return new net.Socket();\n    }\n\n    /* get_host\n     *\n     * This approach borrowed from the danga mogilefs client code\n     *\n     * If all the hosts look dead, it returns the next one it would have tried\n     * anyway. That should make it more forgiving about transient but widespread\n     * network problems that make all the hosts look dead.\n     */\n    get_host () {\n        let host;\n        let found;\n\n        let first_i = this.last_i + 1;\n        if (first_i >= this.hosts.length){\n            first_i = 0;\n        }\n\n        for (let i = 0; i < this.hosts.length; ++i){\n            let j = i + first_i;\n            if (j >= this.hosts.length) {\n                j -= this.hosts.length;\n            }\n            host = this.hosts[j];\n            const key = `${host.host}:${host.port}`;\n            if (this.dead_hosts[key]) {\n                continue;\n            }\n            this.last_i = j;\n            found = true;\n            break;\n        }\n        if (found) {\n            return host;\n        }\n        else {\n            logger.warn(\n                `no working hosts found, retrying a dead one, config (probably from smtp_forward.forwarding_host_pool) is '${this.hostports_str}'`);\n            this.last_i = first_i;\n            return this.hosts[first_i];\n        }\n    }\n}\n\nmodule.exports = HostPool;\n"
        },
        {
          "name": "http",
          "type": "tree",
          "content": null
        },
        {
          "name": "line_socket.js",
          "type": "blob",
          "size": 1.224609375,
          "content": "'use strict';\n// A subclass of Socket which reads data by line\n\nconst net   = require('node:net');\nconst utils = require('haraka-utils');\n\nconst tls_socket = require('./tls_socket');\n\nclass Socket extends net.Socket {\n    constructor (options) {\n        super(options);\n        setup_line_processor(this);\n    }\n}\n\nfunction setup_line_processor (socket) {\n    let current_data = '';\n\n    socket.on('data', function on_socket_data (data) {\n        current_data += data;\n        let results;\n        while ((results = utils.line_regexp.exec(current_data))) {\n            const this_line = results[1];\n            current_data = current_data.slice(this_line.length);\n            socket.emit('line', this_line);\n        }\n    })\n\n    socket.on('end', function on_socket_end () {\n        if (current_data.length) {\n            socket.emit('line', current_data);\n        }\n        current_data = '';\n    })\n}\n\nexports.Socket = Socket;\n\n// New interface - uses TLS\nexports.connect = (port, host) => {\n    let options = {};\n    if (typeof port === 'object') {\n        options = port;\n    }\n    else {\n        options.port = port;\n        options.host = host;\n    }\n    const sock = tls_socket.connect(options);\n    setup_line_processor(sock);\n    return sock;\n}\n"
        },
        {
          "name": "logger.js",
          "type": "blob",
          "size": 9.2060546875,
          "content": "'use strict';\n// Log class\n\nconst util      = require('node:util');\nconst tty       = require('node:tty');\n\nconst config    = require('haraka-config');\nconst constants = require('haraka-constants');\n\nlet plugins;\n\nconst regex = /(^$|[ =\"\\\\])/;\nconst escape_replace_regex = /[\"\\\\]/g;\n\nfunction stringify (obj) {\n    let str = '';\n    let key;\n    for (key in obj) {\n        let v = obj[key];\n        if (v == null) {\n            str += `${key}=\"\" `;\n            continue;\n        }\n        v = v.toString();\n        if (regex.test(v)) {\n            str += `${key}=\"${v.replace(escape_replace_regex, '\\\\$&')}\" `;\n        }\n        else {\n            str += `${key}=${v} `;\n        }\n    }\n    return str.trim();\n}\n\nconst logger = exports;\n\nlogger.levels = {\n    DATA:     9,\n    PROTOCOL: 8,\n    DEBUG:    7,\n    INFO:     6,\n    NOTICE:   5,\n    WARN:     4,\n    ERROR:    3,\n    CRIT:     2,\n    ALERT:    1,\n    EMERG:    0,\n}\nconst level_names = Object.keys(logger.levels)\n\nfor (const le in logger.levels) {\n    logger.levels[`LOG${le}`] = logger.levels[le];\n    logger[`LOG${le}`] = logger.levels[le];\n}\n\nlogger.formats = {\n    DEFAULT: \"DEFAULT\",\n    LOGFMT: \"LOGFMT\",\n    JSON: \"JSON\",\n}\n\nlogger.loglevel      = logger.levels.WARN;\nlogger.format        = logger.formats.DEFAULT;\nlogger.timestamps    = false;\nlogger.deferred_logs = [];\nlogger.name          = 'logger'\n\nlogger.colors = {\n    \"DATA\" : \"green\",\n    \"PROTOCOL\" : \"green\",\n    \"DEBUG\" : \"grey\",\n    \"INFO\" : \"cyan\",\n    \"NOTICE\" : \"blue\",\n    \"WARN\" : \"red\",\n    \"ERROR\" : \"red\",\n    \"CRIT\" : \"red\",\n    \"ALERT\" : \"red\",\n    \"EMERG\" : \"red\",\n}\n\nconst stdout_is_tty = tty.isatty(process.stdout.fd);\n\nlogger._init = function () {\n    this.load_log_ini();\n    this._init_loglevel();\n    this._init_timestamps();\n}\n\nlogger.load_log_ini = function () {\n    this.cfg = config.get('log.ini', {\n        booleans: [\n            '+main.timestamps',\n        ]\n    },\n    () => {\n        this.load_log_ini();\n    });\n\n    this.set_loglevel(this.cfg.main.level);\n    this.set_timestamps(this.cfg.main.timestamps);\n    this.set_format(this.cfg.main.format);\n}\n\nlogger.colorize = (color, str) => {\n    if (!util.inspect.colors[color]) { return str; }  // unknown color\n    return `\\u001b[${util.inspect.colors[color][0]}m${str}\\u001b[${util.inspect.colors[color][1]}m`;\n}\n\nlogger.dump_logs = cb => {\n    while (logger.deferred_logs.length > 0) {\n        const log_item = logger.deferred_logs.shift();\n        plugins.run_hooks('log', logger, log_item);\n    }\n    // Run callback after flush\n    if (cb) process.stdout.write('', cb);\n    return true;\n}\n\nif (!util.isFunction) {\n    util.isFunction = functionToCheck => {\n        const getType = {};\n        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n    };\n}\n\nlogger.dump_and_exit = function (code) {\n    this.dump_logs(() => {\n        if (util.isFunction(code)) return code();\n        process.exit(code);\n    });\n}\n\nlogger.log = (level, data, logobj) => {\n    if (level === 'PROTOCOL') {\n        data = data.replace(/\\n/g, '\\\\n');\n    }\n    data = data.replace(/\\r/g, '\\\\r').replace(/\\n$/, '');\n\n    const item = { level, data, obj: logobj};\n\n    // buffer until plugins are loaded\n    const emptyPluginList = !plugins || Array.isArray(plugins.plugin_list) && !plugins.plugin_list.length;\n    if (emptyPluginList) {\n        logger.deferred_logs.push(item);\n        return true;\n    }\n\n    // process buffered logs\n    while (logger.deferred_logs.length > 0) {\n        const log_item = logger.deferred_logs.shift();\n        plugins.run_hooks('log', logger, log_item);\n    }\n\n    plugins.run_hooks('log', logger, item);\n    return true;\n}\n\nlogger.log_respond = (retval, msg, data) => {\n    // any other return code is irrelevant\n    if (retval !== constants.cont) return false;\n\n    let timestamp_string = '';\n    if (logger.timestamps) timestamp_string = `${new Date().toISOString()} `;\n\n    const color = logger.colors[data.level];\n    if (color && stdout_is_tty) {\n        process.stdout.write(`${timestamp_string}${logger.colorize(color,data.data)}\\n`);\n    }\n    else {\n        process.stdout.write(`${timestamp_string}${data.data}\\n`);\n    }\n\n    return true;\n}\n\nlogger.set_loglevel = function (level) {\n    if (level === undefined || level === null) return;\n\n    const loglevel_num = parseInt(level);\n    if (typeof level === 'string') {\n        this.log('INFO', `loglevel: ${level.toUpperCase()}`);\n        logger.loglevel = logger.levels[level.toUpperCase()];\n    }\n    else {\n        logger.loglevel = loglevel_num;\n    }\n\n    if (!Number.isInteger(logger.loglevel)) {\n        this.log('WARN', `invalid loglevel: ${level} defaulting to LOGWARN`);\n        logger.loglevel = logger.levels.WARN;\n    }\n}\n\nlogger.set_format = function (format) {\n    if (format) {\n        logger.format = logger.formats[format.toUpperCase()];\n        this.log('INFO', `log format: ${format.toUpperCase()}`);\n    }\n    else {\n        logger.format = null;\n    }\n    if (!logger.format) {\n        this.log('WARN', `invalid log format: ${format} defaulting to DEFAULT`);\n        logger.format = logger.formats.DEFAULT;\n    }\n}\n\nlogger._init_loglevel = function () {\n\n    const _loglevel = config.get('loglevel', 'value', () => {\n        this._init_loglevel();\n    });\n\n    this.set_loglevel(_loglevel);\n}\n\nlogger.would_log = level => {\n    if (logger.loglevel < level) return false;\n    return true;\n}\n\nlogger.set_timestamps = value => {\n    logger.timestamps = !!value;\n}\n\nlogger._init_timestamps = function () {\n\n    const _timestamps = config.get('log_timestamps', 'value', () => {\n        this._init_timestamps();\n    });\n\n    // If we've already been toggled to true by the cfg, we should respect this.\n    this.set_timestamps(logger.timestamps || _timestamps);\n}\n\nlogger._init();\n\nlogger.log_if_level = (level, key, origin) => function () {\n    if (logger.loglevel < logger[key]) return;\n\n    let logobj = {\n        level,\n        uuid: '-',\n        origin: (origin || 'core'),\n        message: ''\n    };\n\n    for (const data of arguments) {\n        if (typeof data !== 'object') {\n            logobj.message += (data);\n            continue;\n        }\n        if (!data) continue;\n\n        // if the object is a connection, add the connection id\n        if (data.constructor?.name === 'Connection') {\n            logobj.uuid = data.uuid;\n            if (data.tran_count > 0) logobj.uuid += `.${data.tran_count}`;\n        }\n        else if (data instanceof plugins.Plugin) {\n            logobj.origin = data.name;\n        }\n        else if (Object.hasOwn(data, 'name')) { // outbound\n            logobj.origin = data.name;\n            if (Object.hasOwn(data, 'uuid')) logobj.uuid = data.uuid;\n            if (data.todo?.uuid) logobj.uuid = data.todo.uuid; // outbound/hmail\n        }\n        else if (\n            logger.format === logger.formats.LOGFMT && data.constructor === Object) {\n            logobj = Object.assign(logobj, data);\n        }\n        else if (\n            logger.format === logger.formats.JSON && data.constructor === Object) {\n            logobj = Object.assign(logobj, data);\n        }\n        else if (Object.hasOwn(data, 'uuid')) { // outbound/client_pool\n            logobj.uuid = data.uuid;\n        }\n        else if (data.constructor === Object) {\n            if (!logobj.message.endsWith(' ')) logobj.message += ' ';\n            logobj.message += (stringify(data));\n        }\n        else {\n            logobj.message += (util.inspect(data));\n        }\n    }\n\n    switch (logger.format) {\n        case logger.formats.LOGFMT:\n            logger.log(\n                level,\n                stringify(logobj)\n            );\n            break\n        case logger.formats.JSON:\n            logger.log(\n                level,\n                JSON.stringify(logobj)\n            );\n            break\n        case logger.formats.DEFAULT:\n        default:\n            logger.log(\n                level,\n                `[${logobj.level}] [${logobj.uuid}] [${logobj.origin}] ${logobj.message}`\n            );\n    }\n    return true;\n}\n\nlogger.add_log_methods = (object, logName) => {\n    if (!object) return\n\n    if (typeof object === 'function') {\n        // add logging methods to class prototypes (Connection, Plugin, etc.)\n\n        for (const level of level_names.map(l => l.toLowerCase())) {\n            object.prototype[`log${level}`] = (function (level) {\n                return function () {\n                    logger[level].apply(logger, [ this, ...arguments ]);\n                };\n            })(`log${level}`);\n        }\n    }\n    else if (typeof object === 'object') {\n        // add logging methods to objects\n\n        for (const level of level_names) {\n            // objects gets log function names: loginfo, logwarn, logdebug, ...\n            const fnNames = [`log${level.toLowerCase()}`]\n\n            // logger also gets short names\n            if (Object.hasOwn(object, 'name') && object.name === 'logger') {\n                fnNames.push(level.toLowerCase())\n            }\n\n            for (const fnName of fnNames) {\n                if (Object.hasOwn(object, fnName)) continue; // already added\n                object[fnName] = logger.log_if_level(level, `LOG${level}`, logName);\n            }\n        }\n    }\n}\n\nlogger.add_log_methods(logger);\n\n// load these down here so it sees all the logger methods compiled above\nplugins = require('./plugins');\n"
        },
        {
          "name": "outbound",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 3.40625,
          "content": "{\n  \"author\": \"Matt Sergeant <helpme@gmail.com> (http://baudehlo.com/)\",\n  \"name\": \"Haraka\",\n  \"license\": \"MIT\",\n  \"description\": \"An SMTP Server project.\",\n  \"keywords\": [\n    \"haraka\",\n    \"smtp\",\n    \"server\",\n    \"email\"\n  ],\n  \"version\": \"3.0.5\",\n  \"homepage\": \"http://haraka.github.io\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/haraka/Haraka.git\"\n  },\n  \"main\": \"haraka.js\",\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"dependencies\": {\n    \"address-rfc2821\": \"^2.1.2\",\n    \"address-rfc2822\": \"^2.2.2\",\n    \"async\": \"^3.2.6\",\n    \"daemon\": \"~1.1.0\",\n    \"haraka-config\": \"^1.4.2\",\n    \"haraka-constants\": \"^1.0.7\",\n    \"haraka-dsn\": \"^1.1.0\",\n    \"haraka-email-message\": \"^1.2.4\",\n    \"haraka-message-stream\": \"^1.2.2\",\n    \"haraka-net-utils\": \"^1.7.1\",\n    \"haraka-notes\": \"^1.1.0\",\n    \"haraka-plugin-redis\": \"^2.0.8\",\n    \"haraka-results\": \"^2.2.4\",\n    \"haraka-tld\": \"^1.2.3\",\n    \"haraka-utils\": \"^1.1.3\",\n    \"ipaddr.js\": \"~2.2.0\",\n    \"node-gyp\": \"^11.0.0\",\n    \"nopt\": \"^8.0.0\",\n    \"npid\": \"~0.4.0\",\n    \"redis\": \"~4.7.0\",\n    \"semver\": \"^7.6.3\",\n    \"sockaddr\": \"^1.0.1\",\n    \"sprintf-js\": \"~1.1.3\"\n  },\n  \"optionalDependencies\": {\n    \"haraka-plugin-access\": \"^1.1.9\",\n    \"haraka-plugin-aliases\": \"^1.0.2\",\n    \"haraka-plugin-asn\": \"^2.0.3\",\n    \"haraka-plugin-attachment\": \"^1.1.2\",\n    \"haraka-plugin-avg\": \"^1.1.0\",\n    \"haraka-plugin-bounce\": \"1.0.2\",\n    \"haraka-plugin-clamd\": \"1.0.1\",\n    \"haraka-plugin-dcc\": \"^1.0.2\",\n    \"haraka-plugin-dkim\": \"^1.0.8\",\n    \"haraka-plugin-dns-list\": \"^1.2.2\",\n    \"haraka-plugin-elasticsearch\": \"^8.0.3\",\n    \"haraka-plugin-esets\": \"^1.0.0\",\n    \"haraka-plugin-fcrdns\": \"^1.1.0\",\n    \"haraka-plugin-geoip\": \"^1.1.0\",\n    \"haraka-plugin-graph\": \"^1.0.5\",\n    \"haraka-plugin-greylist\": \"^1.0.0\",\n    \"haraka-plugin-headers\": \"^1.0.5\",\n    \"haraka-plugin-helo.checks\": \"^1.0.1\",\n    \"haraka-plugin-karma\": \"^2.1.6\",\n    \"haraka-plugin-known-senders\": \"^1.1.0\",\n    \"haraka-plugin-limit\": \"^1.2.5\",\n    \"haraka-plugin-messagesniffer\": \"^1.0.0\",\n    \"haraka-plugin-p0f\": \"^1.0.9\",\n    \"haraka-plugin-qmail-deliverable\": \"^1.2.3\",\n    \"haraka-plugin-recipient-routes\": \"^1.2.1\",\n    \"haraka-plugin-relay\": \"^1.0.0\",\n    \"haraka-plugin-rspamd\": \"^1.3.1\",\n    \"haraka-plugin-spamassassin\": \"^1.0.1\",\n    \"haraka-plugin-spf\": \"1.2.9\",\n    \"haraka-plugin-syslog\": \"^1.0.6\",\n    \"haraka-plugin-uribl\": \"^1.0.9\",\n    \"haraka-plugin-watch\": \"^2.0.6\",\n    \"ocsp\": \"~1.2.0\",\n    \"tmp\": \"~0.2.3\"\n  },\n  \"devDependencies\": {\n    \"@haraka/eslint-config\": \"^2.0.2\",\n    \"haraka-test-fixtures\": \"^1.3.8\",\n    \"mocha\": \"^11.1.0\",\n    \"mock-require\": \"^3.0.3\",\n    \"nodemailer\": \"^6.9.16\"\n  },\n  \"bugs\": {\n    \"mail\": \"haraka.mail@gmail.com\",\n    \"url\": \"https://github.com/haraka/Haraka/issues\"\n  },\n  \"bin\": {\n    \"haraka\": \"./bin/haraka\",\n    \"haraka_grep\": \"./bin/haraka_grep\"\n  },\n  \"scripts\": {\n    \"format:NYET\": \"npm run prettier:fix && npm run lint:fix\",\n    \"lint\": \"npx eslint *.js outbound plugins plugins/*/*.js test test/*/*.js test/*/*/*.js bin/haraka\",\n    \"lint:fix\": \"npx eslint --fix *.js outbound plugins plugins/*/*.js test test/*/*.js test/*/*/*.js bin/haraka\",\n    \"prettier\": \"npx prettier . --check\",\n    \"prettier:fix\": \"npx prettier . --write --log-level=warn\",\n    \"test\": \"npx mocha --exit --timeout=4000 test test/outbound test/plugins/auth test/plugins/queue test/plugins\",\n    \"versions\": \"npx dependency-version-checker check\",\n    \"versions:fix\": \"npx dependency-version-checker update\"\n  }\n}\n"
        },
        {
          "name": "plugins.js",
          "type": "blob",
          "size": 19.3173828125,
          "content": "'use strict';\n// load all defined plugins\n\n// node built-ins\nconst fs          = require('node:fs');\nconst path        = require('node:path');\nconst vm          = require('node:vm');\n\n// npm modules\nexports.config    = require('haraka-config');\nconst constants   = require('haraka-constants');\n\n// local modules\nconst logger      = require('./logger');\n\nexports.registered_hooks = {};\nexports.registered_plugins = {};\nexports.plugin_list = [];\n\nlet order = 0;\n\nclass Plugin {\n\n    constructor (name) {\n        this.name = name;\n        this.base = {};\n        this.timeout = get_timeout(name);\n        this._get_plugin_path();\n        this.config = this._get_config();\n        this.hooks = {};\n    }\n\n    haraka_require (name) {\n        return require(`./${name}`);\n    }\n\n    core_require (name) {\n        return this.haraka_require(name);\n    }\n\n    _get_plugin_path () {\n        /* From https://github.com/haraka/Haraka/pull/1278#issuecomment-168856528\n        In Development mode, or install via a plain \"git clone\":\n\n            Plain plugin in plugins/ folder\n            Plugin in a folder in plugins/<name>/ folder. Contains a package.json.\n            Plugin in node_modules. Contains a package.json file.\n\n        In \"installed\" mode (via haraka -i <path>):\n\n            Plain plugin in <path>/plugins/ folder\n            Plugin in a folder in <path>/plugins/<name>/folder. (same concept as above)\n            Plugin in <path>/node_modules. Contains a package.json file.\n            Core plugin in <core_haraka_dir>/plugins/ folder\n            Plugin in a folder in <core_haraka_dir>/plugins/<name>/ folder. (same concept as above)\n            Plugin in <core_haraka_dir>/node_modules.\n        */\n\n        this.hasPackageJson = false;\n        const name = this.name.startsWith('haraka-plugin-') ? this.name.substr(14) : this.name;\n        if (this.name !== name) this.name = name;\n\n        let paths = [];\n        if (process.env.HARAKA) {\n            // Installed mode - started via bin/haraka\n            paths = paths.concat(plugin_search_paths(process.env.HARAKA, name));\n\n            // permit local \"folder\" plugins (/$name/package.json) (see #1649)\n            paths.push(\n                path.resolve(process.env.HARAKA, 'plugins', name, 'package.json'),\n                path.resolve(process.env.HARAKA, 'node_modules', name, 'package.json')\n            );\n        }\n\n        // development mode\n        paths = paths.concat(plugin_search_paths(__dirname, name));\n        for (const pp of paths) {\n            if (this.plugin_path) continue;\n            try {\n                fs.statSync(pp);\n                this.plugin_path = pp;\n                if (path.basename(pp) === 'package.json') {\n                    this.hasPackageJson = true;\n                }\n            }\n            catch (ignore) {}\n        }\n    }\n\n    _get_config () {\n        if (this.hasPackageJson) {\n            // It's a package/folder plugin - look in plugin folder for defaults,\n            // haraka/config folder for overrides\n            return exports.config.module_config(\n                path.dirname(this.plugin_path),\n                process.env.HARAKA || __dirname\n            );\n        }\n        if (process.env.HARAKA) {\n            // Plain .js file, installed mode - look in core folder for defaults,\n            // install dir for overrides\n            return exports.config.module_config(__dirname, process.env.HARAKA);\n        }\n        if (process.env.HARAKA_TEST_DIR) {\n            return exports.config.module_config(process.env.HARAKA_TEST_DIR);\n        }\n\n        // Plain .js file, git mode - just look in this folder\n        return exports.config.module_config(__dirname);\n    }\n\n    register_hook (hook_name, method_name, priority) {\n        priority = parseInt(priority);\n        if (!priority) priority = 0;\n        if (priority > 100) priority = 100;\n        if (priority < -100) priority = -100;\n\n        if (!Array.isArray(exports.registered_hooks[hook_name])) {\n            exports.registered_hooks[hook_name] = [];\n        }\n        exports.registered_hooks[hook_name].push({\n            plugin: this.name,\n            method: method_name,\n            priority,\n            timeout: this.timeout,\n            order: order++\n        });\n        this.hooks[hook_name] = this.hooks[hook_name] || [];\n        this.hooks[hook_name].push(method_name);\n\n        plugins.logdebug(`registered hook ${hook_name} to ${this.name}.${method_name} priority ${priority}`);\n    }\n\n    register () {} // noop\n\n    inherits (parent_name) {\n        const parent_plugin = plugins._load_and_compile_plugin(parent_name);\n        for (const method in parent_plugin) {\n            if (!this[method]) {\n                this[method] = parent_plugin[method];\n            }\n        }\n        if (parent_plugin.register) {\n            parent_plugin.register.call(this);\n        }\n        this.base[parent_name] = parent_plugin;\n    }\n\n    _make_custom_require () {\n        return module => {\n            if (this.hasPackageJson) {\n                const mod = require(module);\n                constants.import(global);\n                global.server = plugins.server;\n                return mod;\n            }\n\n            if (module === './config') {\n                return this.config;\n            }\n\n            if (!/^\\./.test(module)) {\n                return require(module);\n            }\n\n            if (fs.existsSync(path.join(__dirname, `${module}.js`)) ||\n                fs.existsSync(path.join(__dirname, module))) {\n                return require(module);\n            }\n\n            return require(path.join(path.dirname(this.plugin_path), module));\n        };\n    }\n\n    _get_code (pp) {\n\n        if (this.hasPackageJson) {\n            let packageDir = path.dirname(pp);\n            if (/^win(32|64)/.test(process.platform)) {\n                // escape the c:\\path\\back\\slashes else they disappear\n                packageDir = packageDir.replace(/\\\\/g, '\\\\\\\\');\n            }\n            return `var _p = require(\"${packageDir}\"); for (var k in _p) { exports[k] = _p[k] }`;\n        }\n\n        try {\n            return `\"use strict\";${fs.readFileSync(pp)}`;\n        }\n        catch (err) {\n            if (exports.config.get('smtp.ini').main.ignore_bad_plugins) {\n                plugins.logcrit(`Loading ${this.name} failed: ${err}`);\n                return;\n            }\n            throw `Loading plugin ${this.name} failed: ${err}`;\n        }\n    }\n\n    _compile () {\n\n        const pp = this.plugin_path;\n        const code = this._get_code(pp);\n        if (!code) return;\n\n        const sandbox = {\n            require: this._make_custom_require(),\n            __filename: pp,\n            __dirname:  path.dirname(pp),\n            exports: this,\n            setTimeout,\n            clearTimeout,\n            setInterval,\n            clearInterval,\n            process,\n            Buffer,\n            Math,\n            server: plugins.server,\n            setImmediate\n        };\n        if (this.hasPackageJson) {\n            delete sandbox.__filename;\n        }\n        constants.import(sandbox);\n        try {\n            vm.runInNewContext(code, sandbox, pp);\n        }\n        catch (err) {\n            plugins.logcrit(`compiling '${this.name}' failed`);\n            if (exports.config.get('smtp.ini').main.ignore_bad_plugins) {\n                plugins.logcrit(`Loading '${this.name}' failed: ${err.message} - skipping`);\n                return;\n            }\n            throw err; // default is to re-throw and stop Haraka\n        }\n    }\n}\n\nexports.shutdown_plugins = () => {\n    for (const i in exports.registered_plugins) {\n        if (exports.registered_plugins[i].shutdown) {\n            exports.registered_plugins[i].shutdown();\n        }\n    }\n}\n\nprocess.on('message', msg => {\n    if (msg.event && msg.event == 'plugins.shutdown') {\n        plugins.loginfo(\"Shutting down\");\n        exports.shutdown_plugins();\n    }\n});\n\nfunction plugin_search_paths (prefix, name) {\n    return [\n        path.resolve(prefix, 'plugins', `${name}.js`),\n        path.resolve(prefix, 'node_modules', `haraka-plugin-${name}`, 'package.json'),\n        path.resolve(prefix, '..', `haraka-plugin-${name}`, 'package.json')\n    ];\n}\n\nfunction get_timeout (name) {\n    let timeout = parseFloat((exports.config.get(`${name}.timeout`)));\n    if (isNaN(timeout)) {\n        plugins.logdebug(`no timeout in ${name}.timeout`);\n        timeout = parseFloat(exports.config.get('plugin_timeout'));\n    }\n    if (isNaN(timeout)) {\n        plugins.logdebug('no timeout in plugin_timeout');\n        timeout = 30;\n    }\n\n    plugins.logdebug(`plugin ${name} timeout is: ${timeout}s`);\n    return timeout;\n}\n\nlogger.add_log_methods(Plugin)\n\nconst plugins = exports;\n\nlogger.add_log_methods(plugins, 'plugins')\n\nplugins.Plugin = Plugin;\n\nplugins.load_plugins = override => {\n    plugins.logdebug('Loading');\n    let plugin_list;\n    if (override) {\n        if (!Array.isArray(override)) override = [ override ];\n        plugin_list = override;\n    }\n    else {\n        plugin_list = exports.config.get('plugins', 'list');\n    }\n\n    for (let plugin of plugin_list) {\n        if (plugin.startsWith('haraka-plugin-')) plugin = plugin.substr(14)\n        if (plugins.deprecated[plugin]) {\n            plugins.lognotice(`${plugin} has been replaced by '${plugins.deprecated[plugin]}'. Please update config/plugins`)\n            plugins.load_plugin(plugins.deprecated[plugin]);\n        }\n        else {\n            plugins.load_plugin(plugin);\n        }\n    }\n\n    plugins.plugin_list = Object.keys(plugins.registered_plugins);\n\n    // Sort registered_hooks by priority\n    for (const hook of Object.keys(plugins.registered_hooks)) {\n        plugins.registered_hooks[hook].sort((a, b) => {\n            if (a.priority < b.priority) return -1;\n            if (a.priority > b.priority) return 1;\n            if (a.priority == b.priority) {\n                if (a.order > b.order) return 1;\n                return -1;\n            }\n            return 0;\n        });\n    }\n\n    logger.dump_logs(); // now logging plugins are loaded.\n}\n\nplugins.deprecated = {\n    'auth/auth_ldap'      : 'auth-ldap',\n    'backscatterer'       : 'dns-list',\n    'connect.asn'         : 'asn',\n    'connect.fcrdns'      : 'fcrdns',\n    'connect.geoip'       : 'geoip',\n    'connect.p0f'         : 'p0f',\n    'connect.rdns_access' : 'access',\n    'data.nomsgid'        : 'headers',\n    'data.noreceived'     : 'headers',\n    'data.rfc5322_header_checks': 'headers',\n    'data.headers'        : 'headers',\n    'dkim_sign'           : 'dkim',\n    'dkim_verify'         : 'dkim',\n    'data.uribl'          : 'uribl',\n    'dnsbl'               : 'dns-list',\n    'dnswl'               : 'dns-list',\n    'log.syslog'          : 'syslog',\n    'mail_from.access'    : 'access',\n    'mail_from.blocklist' : 'access',\n    'mail_from.nobounces' : 'bounce',\n    'max_unrecognized_commands' : 'limit',\n    'rate_limit'          : 'limit',\n    'rcpt_to.access'      : 'access',\n    'rcpt_to.blocklist'   : 'access',\n    'rcpt_to.ldap'        : 'rcpt-ldap',\n    'rcpt_to.max_count'   : 'limit',\n    'rcpt_to.qmail_deliverable' : 'qmail-deliverable',\n    'rdns.regexp'         : 'access',\n    'relay_acl'           : 'relay',\n    'relay_all'           : 'relay',\n    'relay_force_routing' : 'relay',\n}\n\nplugins.load_plugin = name => {\n    plugins.loginfo(`loading ${name}`);\n\n    const plugin = plugins._load_and_compile_plugin(name);\n    if (plugin) {\n        plugins._register_plugin(plugin);\n    }\n\n    plugins.registered_plugins[name] = plugin;\n}\n\n// Set in server.js; initialized to empty object\n// to prevent it from blowing up any unit tests.\nplugins.server = { notes: {} };\n\nplugins._load_and_compile_plugin = name => {\n    const plugin = new Plugin(name);\n    if (!plugin.plugin_path) {\n        const err = `Loading plugin ${plugin.name} failed: No plugin with this name found`;\n        if (exports.config.get('smtp.ini').main.ignore_bad_plugins) {\n            plugins.logcrit(err);\n            return;\n        }\n        throw err;\n    }\n    plugin._compile();\n    return plugin;\n}\n\nplugins._register_plugin = plugin => {\n    plugin.register();\n\n    // register any hook_blah methods.\n    for (const method in plugin) {\n        const result = method.match(/^hook_(\\w+)\\b/);\n        if (result) {\n            plugin.register_hook(result[1], method);\n        }\n    }\n}\n\nplugins.run_hooks = (hook, object, params) => {\n    if (client_disconnected(object) && !is_required_hook(hook)) {\n        object.logdebug(`aborting ${hook} hook`);\n        return;\n    }\n\n    if (hook !== 'log') object.logdebug(`running ${hook} hooks`);\n\n    if (is_required_hook(hook) && object.current_hook) {\n        object.current_hook[2](); // call cancel function\n    }\n\n    if (!is_required_hook(hook) && hook !== 'deny' &&\n        object.hooks_to_run && object.hooks_to_run.length) {\n        throw new Error('We are already running hooks! Fatal error!');\n    }\n\n    if (hook === 'deny') {\n        // Save the hooks_to_run list so that we can run any remaining\n        // plugins on the previous hook once this hook is complete.\n        object.saved_hooks_to_run = object.hooks_to_run;\n    }\n    object.hooks_to_run = [];\n\n    if (plugins.registered_hooks[hook]) {\n        for (const item of plugins.registered_hooks[hook]) {\n            const plugin = plugins.registered_plugins[item.plugin];\n            object.hooks_to_run.push([plugin, item.method]);\n        }\n    }\n\n    plugins.run_next_hook(hook, object, params);\n}\n\nplugins.run_next_hook = (hook, object, params) => {\n    if (client_disconnected(object) && !is_required_hook(hook)) {\n        object.logdebug(`aborting ${hook} hook`);\n        return;\n    }\n    let called_once = false;\n    let timeout_id;\n    let timed_out = false;\n    let cancelled = false;\n    let item;\n\n    function cancel () {\n        if (timeout_id) clearTimeout(timeout_id);\n        cancelled = true;\n    }\n    function callback (retval, msg) {\n        if (timeout_id) clearTimeout(timeout_id);\n        object.current_hook = null;\n        if (cancelled) return; // This hook has been cancelled\n\n        // Bail if client has disconnected\n        if (client_disconnected(object) && !is_required_hook(hook)) {\n            object.logdebug(`ignoring ${item[0].name} plugin callback`);\n            return;\n        }\n        if (called_once && hook !== 'log') {\n            if (!timed_out) {\n                object.logerror(`${item[0].name} plugin ran callback ` +\n                        `multiple times - ignoring subsequent calls`);\n                // Write a stack trace to the log to aid debugging\n                object.logerror((new Error()).stack);\n            }\n            return;\n        }\n        called_once = true;\n        if (!retval) retval = constants.cont;\n\n        log_run_item(item, hook, retval, object, params, msg);\n\n        if (object.hooks_to_run.length !== 0) {\n            if (retval === constants.cont) {\n                return plugins.run_next_hook(hook, object, params);\n            }\n            if (hook === 'connect_init' || hook === 'disconnect') {\n                // these hooks ignore retval and always run for every plugin\n                return plugins.run_next_hook(hook, object, params);\n            }\n        }\n\n        const respond_method = `${hook}_respond`;\n        if (item && is_deny_retval(retval) && hook.substr(0,5) !== 'init_') {\n            object.deny_respond = get_denyfn(object, hook, params, retval, msg, respond_method);\n            plugins.run_hooks('deny', object, [retval, msg, item[0].name, item[1], params, hook]);\n        }\n        else {\n            object.hooks_to_run = [];\n            object[respond_method](retval, msg, params);\n        }\n    }\n\n    if (!object.hooks_to_run.length) return callback();\n\n    // shift the next one off the stack and run it.\n    item = object.hooks_to_run.shift();\n    item.push(cancel);\n\n    if (hook !== 'log' && item[0].timeout) {\n        timeout_id = setTimeout(() => {\n            timed_out = true;\n            object.logcrit(`Plugin ${item[0].name} timed out on hook ${hook} - make sure it calls the callback`);\n            callback(constants.denysoft, 'plugin timeout');\n        }, item[0].timeout * 1000);\n    }\n\n    if (hook !== 'log') {\n        object.logdebug(`running ${hook} hook in ${item[0].name} plugin`);\n    }\n\n    if (object.transaction?.notes.skip_plugins.includes(item[0].name)) {\n        object.logdebug(`skipping ${item[0].name}_${hook} by request in notes`);\n        return callback();\n    }\n\n    try {\n        object.current_hook = item;\n        object.hook = hook;\n        item[0][ item[1] ].call(item[0], callback, object, params);\n    }\n    catch (err) {\n        if (hook !== 'log') {\n            object.logcrit(`Plugin ${item[0].name} failed: ${(err.stack || err)}`);\n        }\n        callback();\n    }\n}\n\nfunction client_disconnected (object) {\n    if (object.constructor.name === 'Connection' &&\n        object.state >= constants.connection.state.DISCONNECTING) {\n        object.logdebug('client has disconnected');\n        return true;\n    }\n    return false;\n}\n\nfunction is_required_hook (hook) {\n    // Hooks that must always run\n    switch (hook) {\n        case 'reset_transaction':\n        case 'disconnect':\n        case 'log':\n            return true;\n        default:\n            return false;\n    }\n}\n\nfunction log_run_item (item, hook, retval, object, params, msg) {\n    if (!item) return;\n    if (hook === 'log') return;\n\n    let log = 'logdebug';\n    const is_not_cont = (retval !== constants.cont &&\n                       logger.would_log(logger.LOGINFO));\n    if (is_not_cont) log = 'loginfo';\n    if (is_not_cont || logger.would_log(logger.LOGDEBUG)) {\n        object[log]({\n            hook,\n            'plugin'    :  item[0].name,\n            'function'  :  item[1],\n            'params'    :  ((params) ? ((typeof params === 'string') ? params : params[0]) : ''),\n            'retval'    : constants.translate(retval),\n            'msg'       :  sanitize(msg),\n        });\n    }\n}\n\nfunction sanitize (msg) {\n    if (!msg) return ''\n    if (typeof msg === 'string') return msg\n    if (typeof msg === 'object') {\n        if (msg.constructor.name === 'DSN') return msg.reply\n        const sanitized = { ...msg }; // copy the message\n        for (const priv of ['password','auth_pass']) {\n            delete sanitized[priv]\n        }\n        return JSON.stringify(sanitized)\n    }\n    logger.logerror(`what is ${msg} (typeof ${typeof msg})?`)\n}\n\nfunction is_deny_retval (val) {\n    switch (val) {\n        case constants.deny:\n        case constants.denysoft:\n        case constants.denydisconnect:\n        case constants.denysoftdisconnect:\n            return true;\n    }\n    return false;\n}\n\nfunction get_denyfn (object, hook, params, retval, msg, respond_method) {\n    return (deny_retval, deny_msg) => {\n        switch (deny_retval) {\n            case constants.ok:\n                // Override rejection\n                object.loginfo(`deny(soft?) overriden by deny hook${(deny_msg ? ': deny_msg' : '')}`);\n                // Restore hooks_to_run with saved copy so that\n                // any other plugins on this hook can also run.\n                if (object.saved_hooks_to_run.length > 0) {\n                    object.hooks_to_run = object.saved_hooks_to_run;\n                    plugins.run_next_hook(hook, object, params);\n                }\n                else {\n                    object[respond_method](constants.cont, deny_msg, params);\n                }\n                break;\n            default:\n                object.saved_hooks_to_run = [];\n                object.hooks_to_run = [];\n                object[respond_method](retval, msg, params);\n        }\n    };\n}\n"
        },
        {
          "name": "plugins",
          "type": "tree",
          "content": null
        },
        {
          "name": "rfc1869.js",
          "type": "blob",
          "size": 3.01171875,
          "content": "'use strict';\n// RFC 1869 command parser\n\n// 6.  MAIL FROM and RCPT TO Parameters\n// [...]\n//\n//   esmtp-cmd        ::= inner-esmtp-cmd [SP esmtp-parameters] CR LF\n//   esmtp-parameters ::= esmtp-parameter *(SP esmtp-parameter)\n//   esmtp-parameter  ::= esmtp-keyword [\"=\" esmtp-value]\n//   esmtp-keyword    ::= (ALPHA / DIGIT) *(ALPHA / DIGIT / \"-\")\n//\n//                        ; syntax and values depend on esmtp-keyword\n//   esmtp-value      ::= 1*<any CHAR excluding \"=\", SP, and all\n//                           control characters (US ASCII 0-31\n//                           inclusive)>\n//\n//                        ; The following commands are extended to\n//                        ; accept extended parameters.\n//   inner-esmtp-cmd  ::= (\"MAIL FROM:\" reverse-path)   /\n//                        (\"RCPT TO:\" forward-path)\n\n/* eslint no-control-regex: 0 */\nconst chew_regexp = /\\s+([A-Za-z0-9][A-Za-z0-9-]*(?:=[^= \\x00-\\x1f]+)?)$/;\n\nexports.parse = (type, line, strict) => {\n    let params = [];\n    line = (new String(line)).replace(/\\s*$/, '');\n    if (type === 'mail') {\n        line = line.replace(strict ? /from:/i : /from:\\s*/i, '');\n    }\n    else {\n        line = line.replace(strict ? /to:/i : /to:\\s*/i, '');\n    }\n\n    while (1) {\n        const old_length = line.length;\n        line = line.replace(chew_regexp, function repl (str, p1) {\n            params.push(p1);\n            return '';\n        });\n        if (old_length === line.length) break;\n    }\n\n    params = params.reverse();\n\n    // the above will \"fail\" (i.e. all of the line in params) on\n    // some addresses without <> like\n    //    MAIL FROM: user=name@example.net\n    // or RCPT TO: postmaster\n\n    // let's see if $line contains nothing and use the first value as address:\n    if (line.length) {\n        // parameter syntax error, i.e. not all of the arguments were\n        // stripped by the while() loop:\n        if (line.match(/@.*\\s/)) {\n            throw new Error(`Syntax error in parameters (\"${line}\")`);\n        }\n\n        params.unshift(line);\n    }\n\n    line = params.shift() || '';\n    if (strict) {\n        if (!line.match(/^<.*>$/)) {\n            throw new Error(`Invalid format of ${type} command: ${line}`);\n        }\n    }\n\n    if (type === 'mail') {\n        if (!line.length) {\n            return [\"<>\"]; // 'MAIL FROM:' --> 'MAIL FROM:<>'\n        }\n        if (line.match(/@.*\\s/)) {\n            throw new Error('Syntax error in parameters');\n        }\n    }\n    else {\n        // console.log(`Looking at ${line}``);\n        if (line.match(/@.*\\s/)) {\n            throw new Error('Syntax error in parameters');\n        }\n        else {\n            if (line.match(/\\s/)) {\n                throw new Error('Syntax error in parameters');\n            }\n            else if (line.match(/@/)) {\n                if (!line.match(/^<.*>$/)) line = `<${line}>`;\n            }\n            else if (!line.match(/^<(postmaster|abuse)>$/i)) {\n                throw new Error(`Syntax error in address: ${line}`);\n            }\n        }\n    }\n\n    params.unshift(line);\n\n    return params;\n}\n"
        },
        {
          "name": "run_tests",
          "type": "blob",
          "size": 0.1162109375,
          "content": "#!/bin/sh\n\nTESTS=${1:-\"test test/outbound test/plugins/auth test/plugins/queue test/plugins\"}\n\nnpx mocha --exit $TESTS\n"
        },
        {
          "name": "server.js",
          "type": "blob",
          "size": 20.2353515625,
          "content": "'use strict';\n// smtp network server\n\nconst cluster     = require('node:cluster');\nconst fs          = require('node:fs');\nconst os          = require('node:os');\nconst path        = require('node:path');\nconst tls         = require('node:tls');\n\nconst daemon      = require('daemon');\nconst constants   = require('haraka-constants');\n\nconst tls_socket  = require('./tls_socket');\nconst conn        = require('./connection');\nconst outbound    = require('./outbound');\nconst endpoint    = require('./endpoint');\n\nconst Server      = exports;\nServer.logger     = require('./logger');\nServer.config     = require('haraka-config');\nServer.plugins    = require('./plugins');\nServer.notes      = {};\n\nconst { logger }  = Server;\n\n// Need these here so we can run hooks\nlogger.add_log_methods(Server, 'server');\n\nServer.listeners = [];\n\nServer.load_smtp_ini = () => {\n    Server.cfg = Server.config.get('smtp.ini', {\n        booleans: [\n            '-main.daemonize',\n            '-main.strict_rfc1869',\n            '+main.smtputf8',\n            '-main.graceful_shutdown',\n            '+headers.add_received',\n            '+headers.show_version',\n            '+headers.clean_auth_results',\n        ],\n    }, () => {\n        Server.load_smtp_ini();\n    });\n\n    if (Server.cfg.main.nodes === undefined) {\n        Server.logwarn(`smtp.ini.nodes unset, using 1, see https://github.com/haraka/Haraka/wiki/Performance-Tuning`)\n    }\n\n    const defaults = {\n        inactivity_timeout: 300,\n        daemon_log_file: '/var/log/haraka.log',\n        daemon_pid_file: '/var/run/haraka.pid',\n        force_shutdown_timeout: 30,\n        smtps_port: 465,\n        nodes: 1,\n    };\n\n    Server.cfg.headers.max_received = parseInt(Server.cfg.headers.max_received) || parseInt(Server.config.get('max_received_count')) || 100;\n    Server.cfg.headers.max_lines    = parseInt(Server.cfg.headers.max_lines) || parseInt(Server.config.get('max_header_lines')) || 1000;\n\n    const strict_ext = Server.config.get('strict_rfc1869');\n    if (Server.cfg.main.strict_rfc1869 === false && strict_ext) {\n        Server.logwarn(`legacy config config/strict_rfc1869 is overriding smtp.ini`)\n        Server.cfg.main.strict_rfc1869 = strict_ext;\n    }\n\n    for (const key in defaults) {\n        if (Server.cfg.main[key] !== undefined) continue;\n        Server.cfg.main[key] = defaults[key];\n    }\n}\n\nServer.load_http_ini = () => {\n    Server.http = {};\n    Server.http.cfg = Server.config.get('http.ini', () => {\n        Server.load_http_ini();\n    }).main;\n}\n\nServer.load_smtp_ini();\nServer.load_http_ini();\n\nServer.daemonize = function () {\n    const c = this.cfg.main;\n    if (!c.daemonize) return;\n\n    if (!process.env.__daemon) {\n        // Remove process.on('exit') listeners otherwise\n        // we get a spurious 'Exiting' log entry.\n        process.removeAllListeners('exit');\n        Server.lognotice('Daemonizing...');\n    }\n\n    const log_fd = fs.openSync(c.daemon_log_file, 'a');\n    daemon({ cwd: process.cwd(), stdout: log_fd });\n\n    // We are the daemon from here on...\n    const npid = require('npid');\n    try {\n        npid.create(c.daemon_pid_file).removeOnExit();\n    }\n    catch (err) {\n        Server.logerror(err.message);\n        logger.dump_and_exit(1);\n    }\n}\n\nServer.flushQueue = domain => {\n    if (!Server.cluster) {\n        outbound.flush_queue(domain);\n        return;\n    }\n\n    for (const id in cluster.workers) {\n        cluster.workers[id].send({event: 'outbound.flush_queue', domain});\n    }\n}\n\nlet graceful_in_progress = false;\n\nServer.gracefulRestart = () => {\n    Server._graceful();\n}\n\nServer.stopListeners = () => {\n    Server.loginfo('Shutting down listeners');\n    for (const l of Server.listeners) {\n        l.close();\n    }\n    Server.listeners = [];\n}\n\nServer.performShutdown = () => {\n    if (Server.cfg.main.graceful_shutdown) {\n        return Server.gracefulShutdown();\n    }\n    Server.loginfo(\"Shutting down.\");\n    process.exit(0);\n}\n\nServer.gracefulShutdown = () => {\n    Server.stopListeners();\n    Server._graceful(() => {\n        // log();\n        Server.loginfo(\"Failed to shutdown naturally. Exiting.\");\n        process.exit(0);\n    });\n}\n\nServer._graceful = async (shutdown) => {\n    if (!Server.cluster && shutdown) {\n        for (const module of ['outbound', 'cfreader', 'plugins']) {\n            process.emit('message', {event: `${module}.shutdown`});\n        }\n        const t = setTimeout(shutdown, Server.cfg.main.force_shutdown_timeout * 1000);\n        return t.unref();\n    }\n\n    if (graceful_in_progress) {\n        Server.lognotice(\"Restart currently in progress - ignoring request\");\n        return;\n    }\n\n    graceful_in_progress = true;\n    // TODO: Make these configurable\n    const disconnect_timeout = 30;\n    const exit_timeout = 30;\n    cluster.removeAllListeners('exit');\n\n    // we reload using eachLimit where limit = num_workers - 1\n    // this kills all-but-one workers in parallel, leaving one running\n    // for new connections, and then restarts that one last worker.\n\n    const worker_ids = Object.keys(cluster.workers);\n    let limit = worker_ids.length - 1;\n    if (limit < 2) limit = 1;\n\n    const todo = []\n\n    for (const id of Object.keys(cluster.workers)) {\n        todo.push((id) => {\n            return new Promise((resolve) => {\n                Server.lognotice(`Killing worker: ${id}`);\n                const worker = cluster.workers[id];\n                for (const module of ['outbound', 'cfreader', 'plugins']) {\n                    worker.send({event: `${module  }.shutdown`});\n                }\n                worker.disconnect();\n                let disconnect_received = false;\n                const disconnect_timer = setTimeout(() => {\n                    if (!disconnect_received) {\n                        Server.logcrit(\"Disconnect never received by worker. Killing.\");\n                        worker.kill();\n                    }\n                }, disconnect_timeout * 1000);\n\n                worker.once('disconnect', () => {\n                    clearTimeout(disconnect_timer);\n                    disconnect_received = true;\n                    Server.lognotice('Disconnect complete');\n                    let dead = false;\n                    const timer = setTimeout(() => {\n                        if (!dead) {\n                            Server.logcrit(`Worker ${id} failed to shutdown. Killing.`);\n                            worker.kill();\n                        }\n                    }, exit_timeout * 1000);\n                    worker.once('exit', () => {\n                        dead = true;\n                        clearTimeout(timer);\n                        if (shutdown) resolve()\n                    })\n                })\n                if (!shutdown) {\n                    const newWorker = cluster.fork();\n                    newWorker.once('listening', () => {\n                        Server.lognotice('Replacement worker online.');\n                        newWorker.on('exit', (code, signal) => {\n                            cluster_exit_listener(newWorker, code, signal);\n                        });\n                        resolve()\n                    })\n                }\n            })\n        })\n    }\n\n    while (todo.length) {\n        // process batches of workers\n        await Promise.all(todo.splice(0, limit))\n    }\n\n    if (shutdown) {\n        Server.loginfo(\"Workers closed. Shutting down master process subsystems\");\n        for (const module of ['outbound', 'cfreader', 'plugins']) {\n            process.emit('message', {event: `${module}.shutdown`});\n        }\n        const t2 = setTimeout(shutdown, Server.cfg.main.force_shutdown_timeout * 1000);\n        return t2.unref();\n    }\n    graceful_in_progress = false;\n    Server.lognotice(`Reload complete, workers: ${JSON.stringify(Object.keys(cluster.workers))}`);\n}\n\nServer.sendToMaster = (command, params) => {\n    // console.log(\"Send to master: \", command);\n    if (Server.cluster) {\n        if (Server.cluster.isMaster) {\n            Server.receiveAsMaster(command, params);\n        }\n        else {\n            process.send({cmd: command, params});\n        }\n    }\n    else {\n        Server.receiveAsMaster(command, params);\n    }\n}\n\nServer.receiveAsMaster = (command, params) => {\n    if (!Server[command]) {\n        Server.logerror(`Invalid command: ${command}`);\n        return;\n    }\n    Server[command].apply(Server, params);\n}\n\nfunction messageHandler (worker, msg, handle) {\n    // sunset Haraka v3 (Node < 6)\n    if (arguments.length === 2) {\n        handle = msg;\n        msg = worker;\n        worker = undefined;\n    }\n    // console.log(\"received cmd: \", msg);\n    if (msg?.cmd) {\n        Server.receiveAsMaster(msg.cmd, msg.params);\n    }\n}\n\nServer.get_listen_addrs = (cfg, port) => {\n    if (!port) port = 25;\n    let listeners = [];\n    if (cfg?.listen) {\n        listeners = cfg.listen.split(/\\s*,\\s*/);\n        if (listeners[0] === '') listeners = [];\n        for (let i=0; i < listeners.length; i++) {\n            const ep = endpoint(listeners[i], port);\n            if (ep instanceof Error) continue\n            listeners[i] = ep.toString();\n        }\n    }\n    if (cfg.port) {\n        let host = cfg.listen_host;\n        if (!host) {\n            host = '[::0]';\n            Server.default_host = true;\n        }\n        listeners.unshift(`${host}:${cfg.port}`);\n    }\n    if (listeners.length) return listeners;\n\n    Server.default_host = true;\n    listeners.push(`[::0]:${port}`);\n\n    return listeners;\n}\n\nServer.createServer = params => {\n    const c = Server.cfg.main;\n    for (const key in params) {\n        if (typeof params[key] === 'function') continue;\n        c[key] = params[key];\n    }\n\n    Server.notes = {};\n    Server.plugins.server = Server;\n    Server.plugins.load_plugins();\n\n    const inactivity_timeout = (c.inactivity_timeout || 300) * 1000;\n\n    if (!cluster || !c.nodes) {\n        Server.daemonize(c);\n        Server.setup_smtp_listeners(Server.plugins, 'master', inactivity_timeout);\n        return;\n    }\n\n    // Cluster\n    Server.cluster = cluster;\n\n    // Cluster Workers\n    if (!cluster.isMaster) {\n        Server.setup_smtp_listeners(Server.plugins, 'child', inactivity_timeout);\n        return;\n    }\n    else {\n        // console.log(\"Setting up message handler\");\n        cluster.on('message', messageHandler);\n    }\n\n    // Cluster Master\n    // We fork workers in init_master_respond so that plugins\n    // can put handlers on cluster events before they are emitted.\n    Server.plugins.run_hooks('init_master', Server);\n}\n\nServer.load_default_tls_config = done => {\n    // this fn exists solely for testing\n    if (Server.config.root_path != tls_socket.config.root_path) {\n        Server.loginfo(`resetting tls_config.config path to ${Server.config.root_path}`);\n        tls_socket.config = tls_socket.config.module_config(path.dirname(Server.config.root_path));\n    }\n    tls_socket.getSocketOpts('*').then(opts => {\n        done(opts);\n    })\n}\n\nServer.get_smtp_server = async (ep, inactivity_timeout) => {\n    let server;\n\n    function onConnect (client) {\n        client.setTimeout(inactivity_timeout);\n        const connection = conn.createConnection(client, server, Server.cfg);\n\n        if (!server.has_tls) return;\n\n        const cipher = client.getCipher();\n        cipher.version = client.getProtocol(); // replace min with actual\n\n        connection.setTLS({\n            cipher,\n            verified: client.authorized,\n            verifyError: client.authorizationError,\n            peerCertificate: client.getPeerCertificate(),\n        });\n    }\n\n    if (ep.port === parseInt(Server.cfg.main.smtps_port, 10)) {\n        Server.loginfo('getting SocketOpts for SMTPS server');\n        const opts = await tls_socket.getSocketOpts('*')\n        Server.loginfo(`Creating TLS server on ${ep}`);\n\n        opts.rejectUnauthorized = tls_socket.get_rejectUnauthorized(opts.rejectUnauthorized, ep.port, tls_socket.cfg.main.requireAuthorized)\n\n        server = tls.createServer(opts, onConnect);\n        tls_socket.addOCSP(server);\n        server.has_tls=true;\n        server.on('resumeSession', (id, rsDone) => {\n            Server.loginfo('client requested TLS resumeSession');\n            rsDone(null, null);\n        })\n        Server.listeners.push(server);\n        return server\n    }\n    else {\n        server = tls_socket.createServer(onConnect);\n        server.has_tls = false;\n        const opts = await tls_socket.getSocketOpts('*')\n        Server.listeners.push(server);\n        return server\n    }\n}\n\nServer.setup_smtp_listeners = async (plugins2, type, inactivity_timeout) => {\n\n    const errors = []\n\n    for (const listen_address of Server.get_listen_addrs(Server.cfg.main)) {\n\n        const ep = endpoint(listen_address, 25);\n\n        if (ep instanceof Error) {\n            Server.logerror(`Invalid \"listen\" format in smtp.ini: ${listen_address}`)\n            continue\n        }\n\n        const server = await Server.get_smtp_server(ep, inactivity_timeout)\n        if (!server) continue;\n\n        server.notes = Server.notes;\n        if (Server.cluster) server.cluster = Server.cluster;\n\n        server\n            .on('listening', function () {\n                const addr = this.address();\n                Server.lognotice(`Listening on ${endpoint(addr)}`);\n            })\n            .on('close', () => {\n                Server.loginfo(`Listener ${ep} stopped`);\n            })\n            .on('error', e => {\n                errors.push(e)\n                Server.logerror(`Failed to setup listeners: ${e.message}`);\n                if (e.code !== 'EAFNOSUPPORT') {\n                    Server.logerror(e)\n                    return\n                }\n                // Fallback from IPv6 to IPv4 if not supported\n                // But only if we supplied the default of [::0]:25\n                if (/^::0/.test(ep.host) && Server.default_host) {\n                    server.listen(ep.port, '0.0.0.0', 0);\n                    return;\n                }\n                // Pass error to callback\n                Server.logerror(e)\n            })\n\n        await ep.bind(server, {backlog: 0});\n    }\n\n    if (errors.length) {\n        for (const e of errors) {\n            Server.logerror(`Failed to setup listeners: ${e.message}`);\n        }\n        return logger.dump_and_exit(-1);\n    }\n    Server.listening();\n    plugins2.run_hooks(`init_${type}`, Server);\n}\n\nServer.setup_http_listeners = async () => {\n    if (!Server.http?.cfg?.listen) return;\n\n    const listeners = Server.get_listen_addrs(Server.http.cfg, 80);\n    if (!listeners.length) return;\n\n    try {\n        Server.http.express = require('express');\n        Server.loginfo('express loaded at Server.http.express');\n    }\n    catch (err) {\n        Server.logerror('express failed to load. No http server. Install express with: npm install -g express');\n        return;\n    }\n\n    const app = Server.http.express();\n    Server.http.app = app;\n    Server.loginfo('express app is at Server.http.app');\n\n    for (const listen_address of listeners) {\n\n        const ep = endpoint(listen_address, 80);\n        if (ep instanceof Error) {\n            Server.logerror(`Invalid format for listen in http.ini: ${listen_address}`)\n            continue\n        }\n\n        if (443 == ep.port) {\n            const tlsOpts = { ...tls_socket.certsByHost['*'] }\n            tlsOpts.requestCert = false; // not appropriate for HTTPS\n            Server.http.server = require('https').createServer(tlsOpts, app);\n        }\n        else {\n            Server.http.server = require('http').createServer(app);\n        }\n\n        Server.listeners.push(Server.http.server);\n\n        Server.http.server.on('listening', function () {\n            Server.lognotice(`Listening on ${endpoint(this.address())}`);\n        })\n\n        Server.http.server.on('error', e => {\n            Server.logerror(e);\n        })\n\n        await ep.bind(Server.http.server, {backlog: 0});\n    }\n\n    Server.plugins.run_hooks('init_http', Server);\n    app.use(Server.http.express.static(Server.get_http_docroot()));\n    app.use(Server.handle404);\n}\n\nServer.init_master_respond = (retval, msg) => {\n    if (!(retval === constants.ok || retval === constants.cont)) {\n        Server.logerror(`init_master returned error${((msg) ? `: ${msg}` : '')}`);\n        return logger.dump_and_exit(1);\n    }\n\n    const c = Server.cfg.main;\n    Server.ready = 1;\n\n    // Load the queue if we're just one process\n    if (!(cluster && c.nodes)) {\n        outbound.load_queue();\n        Server.setup_http_listeners();\n        return;\n    }\n\n    // Running under cluster, fork children here, so that\n    // cluster events can be registered in init_master hooks.\n    outbound.scan_queue_pids((err, pids) => {\n        if (err) {\n            Server.logcrit(\"Scanning queue failed. Shutting down.\");\n            return logger.dump_and_exit(1);\n        }\n        Server.daemonize();\n        // Fork workers\n        const workers = (c.nodes === 'cpus') ? os.cpus().length : c.nodes;\n        const new_workers = [];\n        for (let i=0; i<workers; i++) {\n            new_workers.push(cluster.fork({ CLUSTER_MASTER_PID: process.pid }));\n        }\n        for (let j=0; j<pids.length; j++) {\n            new_workers[j % new_workers.length]\n                .send({event: 'outbound.load_pid_queue', data: pids[j]});\n        }\n        cluster.on('online', worker => {\n            Server.lognotice(\n                'worker started',\n                { worker: worker.id, pid: worker.process.pid }\n            );\n        });\n        cluster.on('listening', (worker, address) => {\n            Server.lognotice(`worker ${worker.id} listening on ${endpoint(address)}`);\n        });\n        cluster.on('exit', cluster_exit_listener);\n    });\n}\n\nfunction cluster_exit_listener (worker, code, signal) {\n    if (signal) {\n        Server.lognotice(`worker ${worker.id} killed by signal ${signal}`);\n    }\n    else if (code !== 0) {\n        Server.lognotice(`worker ${worker.id} exited with error code: ${code}`);\n    }\n    if (signal || code !== 0) {\n        // Restart worker\n        const new_worker = cluster.fork({\n            CLUSTER_MASTER_PID: process.pid\n        });\n        new_worker.send({\n            event: 'outbound.load_pid_queue', data: worker.process.pid,\n        });\n    }\n}\n\nServer.init_child_respond = (retval, msg) => {\n    switch (retval) {\n        case constants.ok:\n        case constants.cont:\n            Server.setup_http_listeners();\n            return;\n    }\n\n    const pid = process.env.CLUSTER_MASTER_PID;\n    Server.logerror(`init_child returned error ${((msg) ? `: ${msg}` : '')}`);\n    try {\n        if (pid) {\n            process.kill(pid);\n            Server.logerror(`Killing master (pid=${pid})`);\n        }\n    }\n    catch (err) {\n        Server.logerror('Terminating child');\n    }\n    logger.dump_and_exit(1);\n}\n\nServer.listening = () => {\n    const c = Server.cfg.main;\n\n    // Drop privileges\n    if (c.group) {\n        Server.lognotice(`Switching from current gid: ${process.getgid()}`);\n        process.setgid(c.group);\n        Server.lognotice(`New gid: ${process.getgid()}`);\n    }\n    if (c.user) {\n        Server.lognotice(`Switching from current uid: ${process.getuid()}`);\n        process.setuid(c.user);\n        Server.lognotice(`New uid: ${process.getuid()}`);\n    }\n\n    Server.ready = 1;\n}\n\nServer.init_http_respond = () => {\n    Server.loginfo('init_http_respond');\n\n    let WebSocketServer;\n    try { WebSocketServer = require('ws').Server; }\n    catch (e) {\n        Server.logerror(`unable to load ws.\\n  did you: npm install -g ws?`);\n        return;\n    }\n\n    if (!WebSocketServer) {\n        Server.logerror('ws failed to load');\n        return;\n    }\n\n    Server.http.wss = new WebSocketServer({ server: Server.http.server });\n    Server.loginfo('Server.http.wss loaded');\n\n    Server.plugins.run_hooks('init_wss', Server);\n}\n\nServer.init_wss_respond = () => {\n    Server.loginfo('init_wss_respond');\n}\n\nServer.get_http_docroot = () => {\n    if (Server.http.cfg.docroot) return Server.http.cfg.docroot;\n\n    Server.http.cfg.docroot = path.join( (process.env.HARAKA || __dirname), 'http', 'html');\n    Server.loginfo(`using html docroot: ${Server.http.cfg.docroot}`);\n    return Server.http.cfg.docroot;\n}\n\nServer.handle404 = (req, res) => {\n    // abandon all hope, serve up a 404\n    const docroot = Server.get_http_docroot();\n\n    // respond with html page\n    if (req.accepts('html')) {\n        res.status(404).sendFile('404.html', { root: docroot });\n        return;\n    }\n\n    // respond with json\n    if (req.accepts('json')) {\n        res.status(404).send({ err: 'Not found' });\n        return;\n    }\n\n    res.status(404).send('Not found!');\n}\n"
        },
        {
          "name": "smtp_client.js",
          "type": "blob",
          "size": 17.02734375,
          "content": "'use strict';\n// SMTP client object and class. This allows every part of the client\n// protocol to be hooked for different levels of control, such as\n// smtp_forward and smtp_proxy queue plugins.\n// It can use HostPool to get a connection to a pool of\n// possible hosts in the configuration value \"forwarding_host_pool\", rather\n// than a bunch of connections to a single host from the configuration values\n// in \"host\" and \"port\" (see host_pool.js).\n\nconst events = require('node:events');\n\nconst ipaddr    = require('ipaddr.js');\nconst net_utils = require('haraka-net-utils');\nconst utils     = require('haraka-utils');\n\nconst tls_socket = require('./tls_socket')\nconst logger     = require('./logger');\nconst HostPool   = require('./host_pool');\n\nconst smtp_regexp = /^(\\d{3})([ -])(.*)/;\nconst STATE = {\n    IDLE: 1,\n    ACTIVE: 2,\n    RELEASED: 3,\n    DESTROYED: 4,\n}\n\nclass SMTPClient extends events.EventEmitter {\n    constructor (opts = {}) {\n        super();\n        this.uuid = utils.uuid();\n        this.connect_timeout = parseInt(opts.connect_timeout) || 30;\n        this.socket = opts.socket || this.get_socket(opts)\n        this.socket.setTimeout(this.connect_timeout * 1000);\n        this.socket.setKeepAlive(true);\n        this.state = STATE.IDLE;\n        this.command = 'greeting';\n        this.response = [];\n        this.connected = false;\n        this.authenticating= false;\n        this.authenticated = false;\n        this.auth_capabilities = [];\n        this.host = opts.host;\n        this.port = opts.port;\n        this.smtputf8 = false;\n\n        const client = this;\n\n        client.socket.on('line', (line) => {\n            client.emit('server_protocol', line);\n            const matches = smtp_regexp.exec(line);\n            if (!matches) {\n                client.emit('error', `${client.uuid}: Unrecognized response from upstream server: ${line}`);\n                client.destroy();\n                return;\n            }\n\n            const code = matches[1];\n            const cont = matches[2];\n            const msg = matches[3];\n\n            client.response.push(msg);\n            if (cont !== ' ') return;\n\n            if (client.command === 'auth' || client.authenticating) {\n                logger.info(`SERVER RESPONSE, CLIENT ${client.command}, authenticating=${client.authenticating},code=${code},cont=${cont},msg=${msg}`);\n                if (/^3/.test(code) && (\n                    msg === 'VXNlcm5hbWU6' ||\n                    msg === 'dXNlcm5hbWU6' // Workaround ill-mannered SMTP servers (namely smtp.163.com)\n                )) {\n                    client.emit('auth_username');\n                    return;\n                }\n                if (/^3/.test(code) && msg === 'UGFzc3dvcmQ6') {\n                    client.emit('auth_password');\n                    return;\n                }\n                if (/^2/.test(code) && client.authenticating) {\n                    logger.info('AUTHENTICATED');\n                    client.authenticating = false;\n                    client.authenticated = true;\n                    client.emit('auth');\n                    return;\n                }\n            }\n\n            if (client.command === 'ehlo') {\n                if (code.match(/^5/)) {\n                    // Handle fallback to HELO if EHLO is rejected\n                    client.emit('greeting', 'HELO');\n                    return;\n                }\n                client.emit('capabilities');\n                if (client.command !== 'ehlo') {\n                    return;\n                }\n            }\n\n            if (client.command === 'xclient' && /^5/.test(code)) {\n                // XCLIENT command was rejected (no permission?)\n                // Carry on without XCLIENT\n                client.command = 'helo';\n            }\n            else if (/^[45]/.test(code)) {\n                client.emit('bad_code', code, client.response.join(' '));\n                if (client.state !== STATE.ACTIVE) {\n                    return;\n                }\n            }\n\n            if (/^441/.test(code)) {\n                if (/Connection timed out/i.test(msg)) {\n                    client.destroy();\n                }\n            }\n\n            switch (client.command) {\n                case 'xclient':\n                    client.xclient = true;\n                    client.emit('xclient', 'EHLO');\n                    break;\n                case 'starttls':\n                    client.upgrade(client.tls_options);\n                    break;\n                case 'greeting':\n                    client.connected = true;\n                    client.emit('greeting', 'EHLO');\n                    break;\n                case 'ehlo':\n                    client.emit('helo');\n                    break;\n                case 'helo':\n                case 'mail':\n                case 'rcpt':\n                case 'data':\n                case 'dot':\n                case 'rset':\n                case 'auth':\n                    client.emit(client.command);\n                    break;\n                case 'quit':\n                    client.emit('quit');\n                    client.destroy();\n                    break;\n                default:\n                    throw new Error(`Unknown command: ${client.command}`);\n            }\n        });\n\n        client.socket.on('connect', () => {\n            // Replace connection timeout with idle timeout\n            client.socket.setTimeout((opts.idle_timeout || 300) * 1000);\n            if (!client.socket.remoteAddress) {\n                // \"Value may be undefined if the socket is destroyed\"\n                logger.debug('socket.remoteAddress undefined');\n                return;\n            }\n            client.remote_ip = ipaddr.process(client.socket.remoteAddress).toString();\n        })\n\n        function closed (msg) {\n            return error => {\n                if (!error) error = '';\n\n                // error is e.g. \"Error: connect ECONNREFUSED\"\n                const errMsg = `${client.uuid}: [${client.host}:${client.port}] SMTP connection ${msg} ${error}`;\n\n                /* eslint-disable no-fallthrough */\n                switch (client.state) {\n                    case STATE.ACTIVE:\n                        client.emit('error', errMsg);\n                    case STATE.IDLE:\n                    case STATE.RELEASED:\n                        client.destroy();\n                        break;\n                    case STATE.DESTROYED:\n                        if (msg === 'errored' || msg === 'timed out') {\n                            client.emit('connection-error', errMsg);\n                        }\n                        break\n                    default:\n                }\n\n                logger.debug(`[smtp_client] ${errMsg} (state=${client.state})`);\n            }\n        }\n\n        client.socket.on('error',   closed('errored'));\n        client.socket.on('timeout', closed('timed out'));\n        client.socket.on('close',   closed('closed'));\n        client.socket.on('end',     closed('ended'));\n    }\n\n    load_tls_config (opts) {\n\n        const tls_options = { servername: this.host };\n        if (opts) {\n            Object.assign(tls_options, opts);\n        }\n\n        this.tls_options = tls_options;\n    }\n\n    send_command (command, data) {\n        const line = (command === 'dot') ? '.' : command + (data ? (` ${data}`) : '');\n        this.emit('client_protocol', line);\n        this.command = command.toLowerCase();\n        this.response = [];\n        this.socket.write(`${line}\\r\\n`);\n    }\n\n    start_data (data) {\n        this.response = [];\n        this.command = 'dot';\n        data.pipe(this.socket, { dot_stuffing: true, ending_dot: true, end: false });\n    }\n\n    release () {\n        if (this.state === STATE.DESTROYED) return;\n        logger.debug(`[smtp_client] ${this.uuid} releasing, state=${this.state}`);\n\n        [\n            'auth',   'bad_code', 'capabilities', 'client_protocol', 'connection-error',\n            'data',   'dot',      'error',        'greeting',        'helo',\n            'mail',   'rcpt',     'rset',         'server_protocol', 'xclient',\n        ].forEach(l => {\n            this.removeAllListeners(l);\n        })\n\n        if (this.connected) this.send_command('QUIT');\n        this.destroy()\n    }\n\n    destroy () {\n        if (this.state === STATE.DESTROYED) return\n        this.state = STATE.DESTROYED;\n        this.socket.destroy();\n    }\n\n    upgrade (tls_options) {\n\n        this.socket.upgrade(tls_options, (verified, verifyError, cert, cipher) => {\n            logger.info(`secured:${\n\n                (cipher) ? ` cipher=${cipher.name} version=${cipher.version}` : ''\n            } verified=${verified}${\n                (verifyError) ? ` error=\"${verifyError}\"` : ''\n            }${(cert?.subject) ? ` cn=\"${cert.subject.CN}\" organization=\"${cert.subject.O}\"` : ''\n            }${(cert?.issuer) ? ` issuer=\"${cert.issuer.O}\"` : ''\n            }${(cert?.valid_to) ? ` expires=\"${cert.valid_to}\"` : ''\n            }${(cert?.fingerprint) ? ` fingerprint=${cert.fingerprint}` : ''}`);\n        });\n    }\n\n    is_dead_sender (plugin, connection) {\n        if (connection?.transaction) return false;\n\n        // This likely means the sender went away on us, cleanup.\n        connection.logwarn(plugin, \"transaction went away, releasing smtp_client\");\n        this.release();\n        return true;\n    }\n\n    get_socket(opts) {\n        const socket = tls_socket.connect({\n            host: opts.host,\n            port: opts.port,\n            timeout: this.connect_timeout,\n        })\n        net_utils.add_line_processor(socket)\n        return socket\n    }\n}\n\nexports.smtp_client = SMTPClient;\n\n// Get a smtp_client for the given attributes.\n// used only in testing\nexports.get_client = (server, callback, opts = {}) => {\n    const smtp_client = new SMTPClient(opts)\n    logger.debug(`[smtp_client] uuid=${smtp_client.uuid} host=${opts.host} port=${opts.port} created`)\n    callback(smtp_client)\n}\n\nexports.onCapabilitiesOutbound = (smtp_client, secured, connection, config, on_secured) => {\n    for (const line in smtp_client.response) {\n        if (/^XCLIENT/.test(smtp_client.response[line])) {\n            if (!smtp_client.xclient) {\n                smtp_client.send_command('XCLIENT', `ADDR=${connection.remote.ip}`);\n                return;\n            }\n        }\n\n        if (/^SMTPUTF8/.test(smtp_client.response[line])) {\n            smtp_client.smtputf8 = true;\n        }\n\n        if (/^STARTTLS/.test(smtp_client.response[line]) && !secured) {\n\n            let hostBanned = false\n            let serverBanned = false\n\n            // Check if there are any banned TLS hosts\n            if (smtp_client.tls_options.no_tls_hosts) {\n                // If there are check if these hosts are in the blacklist\n                hostBanned = net_utils.ip_in_list(smtp_client.tls_config.no_tls_hosts, config.host);\n                serverBanned = net_utils.ip_in_list(smtp_client.tls_config.no_tls_hosts, smtp_client.remote_ip);\n            }\n\n            if (!hostBanned && !serverBanned && config.enable_tls) {\n                smtp_client.socket.on('secure', on_secured);\n                smtp_client.secured = false;  // have to wait in forward plugin before we can do auth, even if capabilities are there on first EHLO\n                smtp_client.send_command('STARTTLS');\n                return;\n            }\n        }\n\n        let auth_matches = smtp_client.response[line].match(/^AUTH (.*)$/);\n        if (auth_matches) {\n            smtp_client.auth_capabilities = [];\n            auth_matches = auth_matches[1].split(' ');\n            for (const authMatch of auth_matches) {\n                smtp_client.auth_capabilities.push(authMatch.toLowerCase());\n            }\n        }\n    }\n}\n\n// Get a smtp_client for the given attributes and set up the common\n// config and listeners for plugins. This is what smtp_proxy and\n// smtp_forward have in common.\nexports.get_client_plugin = (plugin, connection, c, callback) => {\n    // c = config\n    // Merge in authentication settings from smtp_forward/proxy.ini if present\n    // FIXME: config.auth could be changed when API isn't frozen\n    if (c.auth_type || c.auth_user || c.auth_pass) {\n        c.auth = {\n            type: c.auth_type,\n            user: c.auth_user,\n            pass: c.auth_pass\n        }\n    }\n\n    const hostport = get_hostport(connection, connection.server, c);\n    const smtp_client = new SMTPClient(hostport)\n    logger.info(`[smtp_client] uuid=${smtp_client.uuid} host=${hostport.host} port=${hostport.port} created`);\n\n    connection.logdebug(plugin, `Got smtp_client: ${smtp_client.uuid}`);\n\n    let secured = false;\n\n    smtp_client.load_tls_config(plugin.tls_options);\n\n    smtp_client.call_next = function (retval, msg) {\n        if (this.next) {\n            const { next } = this;\n            delete this.next;\n            next(retval, msg);\n        }\n    }\n\n    smtp_client.on('client_protocol', (line) => {\n        connection.logprotocol(plugin, `C: ${line}`);\n    })\n\n    smtp_client.on('server_protocol', (line) => {\n        connection.logprotocol(plugin, `S: ${line}`);\n    })\n\n    function helo (command) {\n        if (smtp_client.xclient) {\n            smtp_client.send_command(command, connection.hello.host);\n        }\n        else {\n            smtp_client.send_command(command, connection.local.host);\n        }\n    }\n    smtp_client.on('greeting', helo);\n    smtp_client.on('xclient', helo);\n\n    function on_secured () {\n        if (secured) return;\n        secured = true;\n        smtp_client.secured = true;\n        smtp_client.emit('greeting', 'EHLO');\n    }\n\n    smtp_client.on('capabilities', () => {\n        exports.onCapabilitiesOutbound(smtp_client, secured, connection, c, on_secured);\n    });\n\n    smtp_client.on('helo', () => {\n        if (!c.auth || smtp_client.authenticated) {\n            if (smtp_client.is_dead_sender(plugin, connection)) return;\n\n            smtp_client.send_command('MAIL', `FROM:${connection.transaction.mail_from.format(!smtp_client.smtp_utf8)}`);\n            return;\n        }\n\n        if (c.auth.type === null || typeof (c.auth.type) === 'undefined') return; // Ignore blank\n        const auth_type = c.auth.type.toLowerCase();\n        if (!smtp_client.auth_capabilities.includes(auth_type)) {\n            throw new Error(`Auth type \"${auth_type}\" not supported by server (supports: ${smtp_client.auth_capabilities.join(',')})`);\n        }\n        switch (auth_type) {\n            case 'plain':\n                if (!c.auth.user || !c.auth.pass) {\n                    throw new Error(\"Must include auth.user and auth.pass for PLAIN auth.\");\n                }\n                logger.debug(`[smtp_client] uuid=${smtp_client.uuid} authenticating as \"${c.auth.user}\"`);\n                smtp_client.send_command('AUTH', `PLAIN ${utils.base64(`${c.auth.user}\\0${c.auth.user}\\0${c.auth.pass}`)}`);\n                break;\n            case 'cram-md5':\n                throw new Error(\"Not implemented\");\n            default:\n                throw new Error(`Unknown AUTH type: ${auth_type}`);\n        }\n    });\n\n    smtp_client.on('auth', () => {\n        // if authentication has been handled by plugin(s)\n        if (smtp_client.authenticating) return;\n\n        if (smtp_client.is_dead_sender(plugin, connection)) return;\n\n        smtp_client.authenticated = true;\n        smtp_client.send_command('MAIL', `FROM:${connection.transaction.mail_from.format(!smtp_client.smtp_utf8)}`);\n    });\n\n    // these errors only get thrown when the connection is still active\n    smtp_client.on('error', (msg) => {\n        connection.logwarn(plugin, msg);\n        smtp_client.call_next();\n    });\n\n    // these are the errors thrown when the connection is dead\n    smtp_client.on('connection-error', (error) => {\n        // error contains e.g. \"Error: connect ECONNREFUSE\"\n        logger.error(`backend failure: ${smtp_client.host}:${smtp_client.port} - ${error}`);\n        const { host_pool } = connection.server.notes;\n        // only exists for if forwarding_host_pool is set in the config\n        if (host_pool) {\n            host_pool.failed(smtp_client.host, smtp_client.port);\n        }\n        smtp_client.call_next();\n    });\n\n    if (smtp_client.connected) {\n        if (smtp_client.xclient) {\n            smtp_client.send_command('XCLIENT', `ADDR=${connection.remote.ip}`);\n        }\n        else {\n            smtp_client.emit('helo');\n        }\n    }\n\n    callback(null, smtp_client);\n}\n\nfunction get_hostport (connection, server, cfg) {\n\n    if (cfg.forwarding_host_pool) {\n        if (! server.notes.host_pool) {\n            connection.logwarn(`creating host_pool from ${cfg.forwarding_host_pool}`);\n            server.notes.host_pool =\n                new HostPool(\n                    cfg.forwarding_host_pool, // 1.2.3.4:420, 5.6.7.8:420\n                    cfg.dead_forwarding_host_retry_secs\n                );\n        }\n\n        const host = server.notes.host_pool.get_host();\n        if (host) return host; // { host: 1.2.3.4, port: 567 }\n\n        logger.error('[smtp_client] no backend hosts in pool!');\n        throw new Error(\"no backend hosts found in pool!\");\n    }\n\n    if (cfg.host && cfg.port) return { host: cfg.host, port: cfg.port };\n\n    logger.warn(\"[smtp_client] forwarding_host_pool or host and port were not found in config file\");\n    throw new Error(\"You must specify either forwarding_host_pool or host and port\");\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tls_socket.js",
          "type": "blob",
          "size": 21.515625,
          "content": "'use strict';\n\nconst cluster   = require('node:cluster');\nconst net       = require('node:net');\nconst path      = require('node:path');\nconst { spawn } = require('node:child_process');\nconst stream    = require('node:stream');\nconst tls       = require('node:tls');\nconst util      = require('node:util');\n\n// npm packages\nexports.config  = require('haraka-config');  // exported for tests\nconst Notes = require('haraka-notes')\n\nconst log       = require('./logger');\n\nconst certsByHost = new Notes();\nconst ctxByHost = {};\nlet ocsp;\nlet ocspCache;\n\n// provides a common socket for attaching\n// and detaching from either main socket, or crypto socket\nclass pluggableStream extends stream.Stream {\n    constructor (socket) {\n        super();\n        this.readable = this.writable = true;\n        this._timeout = 0;\n        this._keepalive = false;\n        this._writeState = true;\n        this._pending = [];\n        this._pendingCallbacks = [];\n        if (socket) this.attach(socket);\n    }\n\n    pause () {\n        if (this.targetsocket.pause) {\n            this.targetsocket.pause();\n            this.readable = false;\n        }\n    }\n\n    resume () {\n        if (this.targetsocket.resume) {\n            this.readable = true;\n            this.targetsocket.resume();\n        }\n    }\n\n    attach (socket) {\n        this.targetsocket = socket;\n        this.targetsocket.on('data', data => {\n            this.emit('data', data);\n        });\n        this.targetsocket.on('connect', (a, b) => {\n            this.emit('connect', a, b);\n        });\n        this.targetsocket.on('secureConnect', (a, b) => {\n            this.emit('secureConnect', a, b);\n            this.emit('secure', a, b);\n        });\n        this.targetsocket.on('secure', (a, b) => {\n            this.emit('secure', a, b);\n        });\n        this.targetsocket.on('end', () => {\n            this.writable = this.targetsocket.writable;\n            this.emit('end');\n        });\n        this.targetsocket.on('close', had_error => {\n            this.writable = this.targetsocket.writable;\n            this.emit('close', had_error);\n        });\n        this.targetsocket.on('drain', () => {\n            this.emit('drain');\n        });\n        this.targetsocket.once('error', exception => {\n            this.writable = this.targetsocket.writable;\n            exception.source = 'tls';\n            this.emit('error', exception);\n        });\n        this.targetsocket.on('timeout', () => {\n            this.emit('timeout');\n        });\n        if (this.targetsocket.remotePort) {\n            this.remotePort = this.targetsocket.remotePort;\n        }\n        if (this.targetsocket.remoteAddress) {\n            this.remoteAddress = this.targetsocket.remoteAddress;\n        }\n        if (this.targetsocket.localPort) {\n            this.localPort = this.targetsocket.localPort;\n        }\n        if (this.targetsocket.localAddress) {\n            this.localAddress = this.targetsocket.localAddress;\n        }\n    }\n\n    clean (data) {\n        if (this.targetsocket?.removeAllListeners) {\n            for (const name of ['data', 'secure', 'secureConnect', 'end', 'close', 'error', 'drain']) {\n                this.targetsocket.removeAllListeners(name);\n            }\n        }\n        this.targetsocket = {};\n        this.targetsocket.write = () => {};\n    }\n\n    write (data, encoding, callback) {\n        if (this.targetsocket.write) {\n            return this.targetsocket.write(data, encoding, callback);\n        }\n        return false;\n    }\n\n    end (data, encoding) {\n        if (this.targetsocket.end) {\n            return this.targetsocket.end(data, encoding);\n        }\n    }\n\n    destroySoon () {\n        if (this.targetsocket.destroySoon) {\n            return this.targetsocket.destroySoon();\n        }\n    }\n\n    destroy () {\n        if (this.targetsocket.destroy) {\n            return this.targetsocket.destroy();\n        }\n    }\n\n    setKeepAlive (bool) {\n        this._keepalive = bool;\n        return this.targetsocket.setKeepAlive(bool);\n    }\n\n    setNoDelay (/* true||false */) {\n    }\n\n    unref () {\n        return this.targetsocket.unref();\n    }\n\n    setTimeout (timeout) {\n        this._timeout = timeout;\n        return this.targetsocket.setTimeout(timeout);\n    }\n\n    isEncrypted () {\n        return this.targetsocket.encrypted;\n    }\n\n    isSecure () {\n        return this.targetsocket.encrypted && this.targetsocket.authorized;\n    }\n}\n\nexports.parse_x509 = async (string) => {\n    const res = {};\n    if (!string) return res\n\n    const keyRe  = new RegExp('([-]+BEGIN (?:\\\\w+ )?PRIVATE KEY[-]+[^-]*[-]+END (?:\\\\w+ )?PRIVATE KEY[-]+)', 'gm')\n    res.keys = string.match(keyRe)\n\n    const certRe = new RegExp('([-]+BEGIN CERTIFICATE[-]+[^-]*[-]+END CERTIFICATE[-]+)', 'gm')\n    res.chain = string.match(certRe)\n\n    if (res.chain?.length) {\n        const opensslArgs = [res.chain[0], 'x509', '-noout']\n        // shush openssl, https://github.com/openssl/openssl/issues/22893\n        // if (['darwin','linux','freebsd'].includes(process.platform))\n        //     opensslArgs.push('-in', '/dev/stdin')\n\n        // it's cleaner to call openssl with each of -enddate, -subject, etc, but it costs\n        // 40-50ms per spawn with node v21 on a M1 MBP\n        const raw = await openssl(...opensslArgs, '-enddate', '-subject', '-ext', 'subjectAltName')\n        if (!raw) return res\n\n        res.expire = new Date(raw.match(/notAfter=(.* [A-Z]{3})/)[1])\n\n        const match = /CN\\s*=\\s*([^/\\s,]+)/.exec(raw);\n        if (match && match[1]) res.names = [ match[1] ]\n\n        for (let name of Array.from(raw.matchAll(/DNS:([^\\s,]+)/gm), (m) => m[0])) {\n            name = name.replace('DNS:', '')\n            if (!res.names.includes(name)) res.names.push(name)\n        }\n    }\n\n    return res;\n}\n\nexports.load_tls_ini = (opts) => {\n\n    log.info(`loading tls.ini`); // from ${this.config.root_path}`);\n\n    const cfg = exports.config.get('tls.ini', {\n        booleans: [\n            '-redis.disable_for_failed_hosts',\n\n            // wildcards match in any section and are not initialized\n            '*.requestCert',\n            '*.rejectUnauthorized',\n            '*.honorCipherOrder' ,\n            '*.enableOCSPStapling',\n            '*.requestOCSP',\n\n            // explicitely declared booleans are initialized\n            '+main.requestCert',\n            '-main.rejectUnauthorized',\n            '+main.honorCipherOrder',\n            '-main.requestOCSP',\n            '-main.mutual_tls',\n        ]\n    }, () => {\n        this.load_tls_ini();\n    });\n\n    if (cfg.no_tls_hosts === undefined) cfg.no_tls_hosts = {};\n    if (cfg.mutual_auth_hosts === undefined) cfg.mutual_auth_hosts = {};\n    if (cfg.mutual_auth_hosts_exclude === undefined) cfg.mutual_auth_hosts_exclude = {};\n\n    if (cfg.main.enableOCSPStapling !== undefined) {\n        log.error('deprecated setting enableOCSPStapling in tls.ini');\n        cfg.main.requestOCSP = cfg.main.enableOCSPStapling;\n    }\n\n    if (ocsp === undefined && cfg.main.requestOCSP) {\n        try {\n            ocsp = require('ocsp');\n            log.debug('ocsp loaded');\n            ocspCache = new ocsp.Cache();\n        }\n        catch (ignore) {\n            log.notice(\"OCSP Stapling not available.\");\n        }\n    }\n\n    if (cfg.main.requireAuthorized === undefined) {\n        cfg.main.requireAuthorized = [];\n    }\n    else if (!Array.isArray(cfg.main.requireAuthorized)) {\n        cfg.main.requireAuthorized = [cfg.main.requireAuthorized];\n    }\n\n    if (!Array.isArray(cfg.main.no_starttls_ports)) cfg.main.no_starttls_ports = [];\n\n    this.cfg = cfg;\n\n    if (!opts || opts.role === 'server') {\n        this.applySocketOpts('*');\n        this.load_default_opts();\n    }\n\n    return cfg;\n}\n\nexports.applySocketOpts = name => {\n\n    // https://nodejs.org/api/tls.html#tls_new_tls_tlssocket_socket_options\n    const TLSSocketOptions = [\n        // 'server'        // manually added\n        'isServer', 'requestCert',  'rejectUnauthorized',\n        'NPNProtocols', 'ALPNProtocols', 'session',\n        'requestOCSP',  'secureContext', 'SNICallback'\n    ];\n\n    // https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options\n    const createSecureContextOptions = [\n        'key', 'cert', 'dhparam',\n        'pfx', 'passphrase', 'ca', 'crl', 'ciphers', 'minVersion', 'honorCipherOrder',\n        'ecdhCurve', 'secureProtocol', 'secureOptions', 'sessionIdContext'\n    ];\n\n    for (const opt of [ ...TLSSocketOptions, ...createSecureContextOptions ]) {\n\n        if (this.cfg[name] && this.cfg[name][opt] !== undefined) {\n            // if the setting exists in tls.ini [name]\n            certsByHost.set([name, opt], this.cfg[name][opt])\n        }\n        else if (this.cfg.main[opt] !== undefined) {\n            // save settings in tls.ini [main] to each CN\n            certsByHost.set([name, opt], this.cfg.main[opt])\n        }\n        else {\n            // defaults\n            switch (opt) {\n                case 'sessionIdContext':\n                    certsByHost.set([name, opt], 'haraka')\n                    break;\n                case 'isServer':\n                    certsByHost.set([name, opt], true)\n                    break;\n                case 'key':\n                    certsByHost.set([name, opt], 'tls_key.pem')\n                    break;\n                case 'cert':\n                    certsByHost.set([name, opt], 'tls_cert.pem')\n                    break;\n                case 'dhparam':\n                    certsByHost.set([name, opt], 'dhparams.pem')\n                    break;\n                case 'SNICallback':\n                    certsByHost.set([name, opt], exports.SNICallback)\n                    break;\n            }\n        }\n    }\n}\n\nexports.load_default_opts = () => {\n\n    const cfg = certsByHost['*'];\n\n    if (cfg.dhparam && typeof cfg.dhparam === 'string') {\n        log.debug(`loading dhparams from ${cfg.dhparam}`);\n        certsByHost.set('*.dhparam', this.config.get(cfg.dhparam, 'binary'))\n    }\n\n    if (cfg.ca && typeof cfg.ca === 'string') {\n        log.info(`loading CA certs from ${cfg.ca}`);\n        certsByHost.set('*.ca', this.config.get(cfg.ca, 'binary'))\n    }\n\n    // make non-array key/cert option into Arrays with one entry\n    if (!(Array.isArray(cfg.key ))) cfg.key  = [cfg.key];\n    if (!(Array.isArray(cfg.cert))) cfg.cert = [cfg.cert];\n\n    if (cfg.key.length != cfg.cert.length) {\n        log.error(`number of keys (${cfg.key.length}) not equal to certs (${cfg.cert.length}).`);\n    }\n\n    // if key file has already been loaded, it'll be a Buffer.\n    if (typeof cfg.key[0] === 'string') {\n        // turn key/cert file names into actual key/cert binary data\n        const asArray = cfg.key.map(keyFileName => {\n            if (!keyFileName) return;\n            const key = this.config.get(keyFileName, 'binary');\n            if (!key) {\n                log.error(`tls key ${path.join(this.config.root_path, keyFileName)} could not be loaded.`);\n            }\n            return key;\n        })\n        certsByHost.set('*.key', asArray)\n    }\n\n    if (typeof cfg.cert[0] === 'string') {\n        const asArray = cfg.cert.map(certFileName => {\n            if (!certFileName) return;\n            const cert = this.config.get(certFileName, 'binary');\n            if (!cert) {\n                log.error(`tls cert ${path.join(this.config.root_path, certFileName)} could not be loaded.`);\n            }\n            return cert;\n        })\n        certsByHost.set('*.cert', asArray)\n    }\n\n    if (cfg.cert[0] && cfg.key[0]) {\n        this.tls_valid = true;\n\n        // now that all opts are applied, generate TLS context\n        this.ensureDhparams(() => {\n            ctxByHost['*'] = tls.createSecureContext(cfg);\n        })\n    }\n}\n\nexports.SNICallback = function (servername, sniDone) {\n    log.debug(`SNI servername: ${servername}`);\n\n    sniDone(null, ctxByHost[servername] || ctxByHost['*']);\n}\n\nexports.get_certs_dir = async (tlsDir) => {\n    const r = {}\n    const watcher = async () => {\n        exports.get_certs_dir(tlsDir)\n    }\n    const dirOpts = { type: 'binary', watchCb: watcher }\n\n    const files = await this.config.getDir(tlsDir, dirOpts)\n    for (const file of files) {\n        try {\n            r[file.path] = await exports.parse_x509(file.data.toString());\n        }\n        catch (err) {\n            log.debug(err.message)\n        }\n    }\n\n    log.debug(`found ${Object.keys(r).length} files in config/tls`);\n    if (Object.keys(r).length === 0) return\n\n    const s = {} // certs by name (CN)\n\n    for (const fp in r) {\n\n        if (r[fp].expire && r[fp].expire < new Date()) {\n            log.error(`${fp} expired on ${r[fp].expire}`)\n        }\n\n        // a file with a key and no cert, get name from file\n        if (!r[fp].names) r[fp].names = [ path.parse(fp).name ]\n\n        for (let name of r[fp].names) {\n            if (name[0] === '_') name = name.replace('_', '*') // windows\n            if (s[name] === undefined) s[name] = {}\n            if (!s[name].key && r[fp].keys) s[name].key = r[fp].keys[0]\n            if (!s[name].cert && r[fp].chain) {\n                s[name].cert = r[fp].chain[0]\n                s[name].file = fp\n            }\n        }\n    }\n\n    for (const cn in s) {\n        if (!s[cn].cert || !s[cn].key) {\n            delete s[cn]\n            continue\n        }\n\n        this.applySocketOpts(cn) // from tls.ini\n        certsByHost.set([cn, 'cert'], Buffer.from(s[cn].cert))\n        certsByHost.set([cn, 'key'], Buffer.from(s[cn].key))\n        certsByHost.set([cn, 'dhparam'], certsByHost['*'].dhparam, true);\n\n        // all opts are applied, generate TLS context\n        try {\n            ctxByHost[cn] = tls.createSecureContext(certsByHost.get([cn]));\n        }\n        catch (err) {\n            log.error(`CN '${cn}' loading got: ${err.message}`)\n            delete ctxByHost[cn]\n            delete certsByHost[cn]\n        }\n    }\n\n    log.info(`found ${Object.keys(s).length} TLS certs in config/tls`);\n\n    return certsByHost // used only by tests\n}\n\nfunction openssl (crt, ...params) {\n    return new Promise((resolve) => {\n        let crtTxt = ''\n\n        const o = spawn('openssl', [...params], { timeout: 1000 });\n        o.stdout.on('data', data => {\n            crtTxt += data\n        })\n\n        o.stderr.on('data', data => {\n            log.debug(`err: ${data.toString().trim()}`)\n        })\n\n        o.on('close', code => {\n            if (code !== 0) {\n                if (code) console.error(code)\n            }\n            resolve(crtTxt)\n        })\n\n        o.stdin.write(crt)\n        o.stdin.write('\\n')\n    })\n}\n\nexports.getSocketOpts = async (name) => {\n\n    // startup time, load the config/tls dir\n    if (!certsByHost['*']) this.load_tls_ini();\n\n    try {\n        await this.get_certs_dir('tls')\n    }\n    catch (err) {\n        if (err.code !== 'ENOENT') {\n            console.error(err.messsage)\n            log.error(err)\n        }\n    }\n\n    return certsByHost[name] || certsByHost['*']\n}\n\nfunction pipe (cleartext, socket) {\n    cleartext.socket = socket;\n\n    function onError (e) {\n    }\n\n    function onClose () {\n        socket.removeListener('error', onError);\n        socket.removeListener('close', onClose);\n    }\n\n    socket.on('error', onError);\n    socket.on('close', onClose);\n}\n\nexports.ensureDhparams = done => {\n\n    // empty/missing dhparams file\n    if (certsByHost['*'].dhparam) {\n        return done(null, certsByHost['*'].dhparam);\n    }\n\n    if (cluster.isWorker) return; // only once, on the master process\n\n    const filePath = this.cfg.main.dhparam || 'dhparams.pem';\n    const fpResolved = path.resolve(exports.config.root_path, filePath);\n\n    log.info(`Generating a 2048 bit dhparams file at ${fpResolved}`);\n\n    const o = spawn('openssl', ['dhparam', '-out', `${fpResolved}`, '2048']);\n    o.stdout.on('data', data => {\n        // normally empty output\n        log.debug(data);\n    })\n\n    o.stderr.on('data', data => {\n        // this is the status gibberish `openssl dhparam` spews as it works\n    })\n\n    o.on('close', code => {\n        if (code !== 0) {\n            return done(`Error code: ${code}`);\n        }\n\n        log.info(`Saved to ${fpResolved}`);\n        const content = this.config.get(filePath, 'binary');\n\n        certsByHost.set('*.dhparam', content)\n        done(null, certsByHost['*'].dhparam);\n    });\n}\n\nexports.addOCSP = server => {\n    if (!ocsp) {\n        log.debug(`addOCSP: 'ocsp' not available`);\n        return;\n    }\n\n    if (server.listenerCount('OCSPRequest') > 0) {\n        log.debug('OCSPRequest already listening');\n        return;\n    }\n\n    log.debug('adding OCSPRequest listener');\n    server.on('OCSPRequest', (cert, issuer, ocr_cb) => {\n        log.debug(`OCSPRequest: ${cert}`);\n        ocsp.getOCSPURI(cert, async (err, uri) => {\n            log.debug(`OCSP Request, URI: ${uri}, err=${err}`);\n            if (err) return ocr_cb(err);\n            if (uri === null) return ocr_cb();  // not working OCSP server\n\n            const req = ocsp.request.generate(cert, issuer);\n            const cached = await ocspCache.probe(req.id)\n\n            if (cached) {\n                log.debug(`OCSP cache: ${util.inspect(cached)}`);\n                return ocr_cb(null, cached.response);\n            }\n\n            const options = {\n                url: uri,\n                ocsp: req.data\n            };\n\n            log.debug(`OCSP req:${util.inspect(req)}`);\n            ocspCache.request(req.id, options, ocr_cb);\n        })\n    })\n}\n\nexports.shutdown = () => {\n    if (ocsp) cleanOcspCache();\n}\n\nfunction cleanOcspCache () {\n    log.debug(`Cleaning ocspCache. How many keys? ${Object.keys(ocspCache.cache).length}`);\n    Object.keys(ocspCache.cache).forEach((key) => {\n        clearTimeout(ocspCache.cache[key].timer);\n    });\n}\n\nexports.certsByHost = certsByHost;\nexports.ocsp = ocsp;\n\nexports.get_rejectUnauthorized = (rejectUnauthorized, port, port_list) => {\n    // console.log(`rejectUnauthorized: ${rejectUnauthorized}, port ${port}, list: ${port_list}`)\n\n    if (rejectUnauthorized) return true;\n\n    return !!(port_list.includes(port));\n}\n\nfunction createServer (cb) {\n    const server = net.createServer(cryptoSocket => {\n\n        const socket = new pluggableStream(cryptoSocket);\n\n        exports.addOCSP(server);\n\n        socket.upgrade = cb2 => {\n            log.debug('Upgrading to TLS');\n\n            socket.clean();\n\n            cryptoSocket.removeAllListeners('data');\n\n            const options = Object.assign({}, certsByHost['*']);\n            options.server = server;  // TLSSocket needs server for SNI to work\n\n            options.rejectUnauthorized = exports.get_rejectUnauthorized(options.rejectUnauthorized, cryptoSocket.localPort, exports.cfg.main.requireAuthorized);\n\n            const cleartext = new tls.TLSSocket(cryptoSocket, options);\n\n            pipe(cleartext, cryptoSocket);\n\n            cleartext\n                .on('error', exception => {\n                    exception.source = 'tls';\n                    socket.emit('error', exception);\n                })\n                .on('secure', () => {\n                    log.debug('TLS secured.');\n                    socket.emit('secure');\n                    const cipher = cleartext.getCipher();\n                    cipher.version = cleartext.getProtocol();\n                    if (cb2) cb2(\n                        cleartext.authorized,\n                        cleartext.authorizationError,\n                        cleartext.getPeerCertificate(),\n                        cipher\n                    );\n                })\n\n            socket.cleartext = cleartext;\n\n            if (socket._timeout) {\n                cleartext.setTimeout(socket._timeout);\n            }\n\n            cleartext.setKeepAlive(socket._keepalive);\n\n            socket.attach(socket.cleartext);\n        };\n\n        cb(socket);\n    });\n\n    return server;\n}\n\nfunction getCertFor (host) {\n    if (host && certsByHost[host]) return certsByHost[host];\n    return certsByHost['*'];  // the default TLS cert\n}\n\nfunction connect (conn_options = {}) {\n    // called by outbound/client_pool, smtp_client, plugins/spamassassin,avg,clamd\n\n    const cryptoSocket = net.connect(conn_options);\n    const socket = new pluggableStream(cryptoSocket);\n\n    socket.upgrade = (options, cb2) => {\n        socket.clean();\n        cryptoSocket.removeAllListeners('data');\n\n        if (exports.tls_valid) {\n            const host = conn_options.host\n            if (exports.cfg === undefined) exports.load_tls_ini();\n            if (exports.cfg.mutual_auth_hosts[host]) {\n                options = Object.assign(options, getCertFor(exports.cfg.mutual_auth_hosts[host]));\n            }\n            else if (exports.cfg.mutual_auth_hosts_exclude[host]) {\n                // send no client cert\n            }\n            else if (exports.cfg.main.mutual_tls) {\n                options = Object.assign(options, getCertFor(host));\n            }\n        }\n        options.socket = cryptoSocket;\n\n        const cleartext = new tls.connect(options);\n\n        pipe(cleartext, cryptoSocket);\n\n        cleartext.on('error', err => {\n            if (err.reason) log.error(`client TLS error: ${err}`);\n        })\n\n        cleartext.once('secureConnect', () => {\n            log.debug('client TLS secured.');\n            const cipher = cleartext.getCipher();\n            cipher.version = cleartext.getProtocol();\n            if (cb2) cb2(\n                cleartext.authorized,\n                cleartext.authorizationError,\n                cleartext.getPeerCertificate(),\n                cipher\n            );\n        });\n\n        socket.cleartext = cleartext;\n\n        if (socket._timeout) {\n            cleartext.setTimeout(socket._timeout);\n        }\n\n        cleartext.setKeepAlive(socket._keepalive);\n\n        socket.attach(socket.cleartext);\n\n        log.debug('client TLS upgrade in progress, awaiting secured.');\n    }\n\n    return socket;\n}\n\nexports.connect = connect;\nexports.createConnection = connect;\nexports.Server = createServer;\nexports.createServer = createServer;\n"
        },
        {
          "name": "transaction.js",
          "type": "blob",
          "size": 8.4814453125,
          "content": "'use strict';\n// An SMTP Transaction\n\nconst util   = require('node:util');\n\nconst Notes  = require('haraka-notes');\nconst utils  = require('haraka-utils');\nconst message = require('haraka-email-message')\n\nclass Transaction {\n    constructor (uuid, cfg = {}) {\n        this.uuid = uuid || utils.uuid();\n        this.cfg = cfg;\n        this.mail_from = null;\n        this.rcpt_to = [];\n        this.header_lines = [];\n        this.data_lines = [];\n        this.attachment_start_hooks = [];\n        this.banner = null;\n        this.body_filters = [];\n        this.data_bytes = 0;\n        this.header_pos = 0;\n        this.found_hb_sep = false;\n        this.body = null;\n        this.parse_body = false;\n        this.notes = new Notes();\n        this.notes.skip_plugins = [];\n        this.header = new message.Header();\n        this.message_stream = new message.stream(this.cfg, this.uuid, this.header.header_list);\n        this.discard_data = false;\n        this.resetting = false;\n        this.rcpt_count = {\n            accept: 0,\n            tempfail: 0,\n            reject: 0,\n        }\n        this.msg_status = undefined;\n        this.data_post_start = null;\n        this.data_post_delay = 0;\n        this.encoding = 'utf8';\n        this.mime_part_count = 0;\n    }\n\n    ensure_body () {\n        if (this.body) return;\n\n        this.body = new message.Body(this.header);\n        this.body.on('mime_boundary', m => this.incr_mime_count());\n\n        for (const hook of this.attachment_start_hooks) {\n            this.body.on('attachment_start', hook);\n        }\n\n        if (this.banner) this.body.set_banner(this.banner);\n\n        for (const o of this.body_filters) {\n            this.body.add_filter((ct, enc, buf) => {\n                const re_match = (util.types.isRegExp(o.ct_match) && o.ct_match.test(ct.toLowerCase()));\n                const ct_begins = ct.toLowerCase().indexOf(String(o.ct_match).toLowerCase()) === 0;\n                if (re_match || ct_begins) return o.filter(ct, enc, buf);\n            })\n        }\n    }\n\n    // Removes the CR of a CRLF newline at the end of the buffer.\n    remove_final_cr (data) {\n        if (data.length < 2) return data;\n        if (!Buffer.isBuffer(data)) data = Buffer.from(data);\n\n        if (data[data.length - 2] === 0x0D && data[data.length - 1] === 0x0A) {\n            data[data.length - 2] = 0x0A;\n            return data.slice(0, data.length - 1);\n        }\n        return data;\n    }\n\n    // Duplicates any '.' chars at the beginning of a line (dot-stuffing) and\n    // ensures all newlines are CRLF.\n    add_dot_stuffing_and_ensure_crlf_newlines (data) {\n        if (!data.length) return data;\n        if (!Buffer.isBuffer(data)) data = Buffer.from(data);\n\n        // Make a new buffer big enough to hold two bytes for every one input\n        // byte.  At most, we add one extra character per input byte, so this\n        // is always big enough.  We allocate it \"unsafe\" (i.e. no memset) for\n        // speed because we're about to fill it with data, and the remainder of\n        // the space we don't fill will be sliced away before we return this.\n        const output = Buffer.allocUnsafe(data.length * 2);\n        let output_pos = 0;\n\n        let input_pos = 0;\n        let next_dot = data.indexOf(0x2E);\n        let next_lf = data.indexOf(0x0A);\n        while (next_dot !== -1 || next_lf !== -1) {\n            const run_end = (next_dot !== -1 && (next_lf === -1 || next_dot < next_lf))\n                ? next_dot : next_lf;\n\n            // Copy up till whichever comes first, '.' or '\\n' (but don't\n            // copy the '.' or '\\n' itself).\n            data.copy(output, output_pos, input_pos, run_end);\n            output_pos += run_end - input_pos;\n\n            if (data[run_end] === 0x2E && (run_end === 0 || data[run_end - 1] === 0x0A)) {\n                // Replace /^\\./ with '..'\n                output[output_pos++] = 0x2E;\n            }\n            else if (data[run_end] === 0x0A && (run_end === 0 || data[run_end - 1] !== 0x0D)) {\n                // Replace /\\r?\\n/ with '\\r\\n'\n                output[output_pos++] = 0x0D;\n            }\n            output[output_pos++] = data[run_end];\n\n            input_pos = run_end + 1;\n\n            if (run_end === next_dot) {\n                next_dot = data.indexOf(0x2E, input_pos);\n            }\n            else {\n                next_lf = data.indexOf(0x0A, input_pos);\n            }\n        }\n\n        if (input_pos < data.length) {\n            data.copy(output, output_pos, input_pos);\n            output_pos += data.length - input_pos;\n        }\n\n        return output.slice(0, output_pos);\n    }\n\n    add_data (line) {\n        if (typeof line === 'string') { // This shouldn't ever happen.\n            line = Buffer.from(line, this.encoding);\n        }\n        // is this the end of headers line?\n        if (this.header_pos === 0 &&\n            (line[0] === 0x0A || (line[0] === 0x0D && line[1] === 0x0A))) {\n            this.header.parse(this.header_lines);\n            this.header_pos = this.header_lines.length;\n            this.found_hb_sep = true;\n            if (this.parse_body) this.ensure_body();\n        }\n        else if (this.header_pos === 0) {\n            // Build up headers\n            if (this.header_lines.length < (this.cfg?.headers?.max_lines || 1000)) {\n                if (line[0] === 0x2E) line = line.slice(1); // Strip leading '.'\n                this.header_lines.push(line.toString(this.encoding).replace(/\\r\\n$/, '\\n'));\n            }\n        }\n        else if (this.parse_body) {\n            let new_line = line;\n            if (new_line[0] === 0x2E) new_line = new_line.slice(1); // Strip leading \".\"\n\n            line = this.add_dot_stuffing_and_ensure_crlf_newlines(\n                this.body.parse_more(this.remove_final_cr(new_line))\n            );\n\n            if (!line.length) return; // buffering for banners\n        }\n\n        if (!this.discard_data) this.message_stream.add_line(line);\n    }\n\n    end_data (cb) {\n        if (!this.found_hb_sep && this.header_lines.length) {\n            // Headers not parsed yet - must be a busted email\n            // Strategy: Find the first line that doesn't look like a header.\n            // Treat anything before that as headers, anything after as body.\n            let header_pos = 0;\n            for (let i = 0; i < this.header_lines.length; i++) {\n                // Anything that doesn't match a header or continuation\n                if (!/^(?:([^\\s:]*):\\s*([\\s\\S]*)$|[ \\t])/.test(this.header_lines[i])) {\n                    break;\n                }\n                header_pos = i;\n            }\n            const body_lines = this.header_lines.splice(header_pos + 1);\n            this.header.parse(this.header_lines);\n            this.header_pos = header_pos;\n            if (this.parse_body) {\n                this.ensure_body();\n                for (const bodyLine of body_lines) {\n                    this.body.parse_more(bodyLine);\n                }\n            }\n        }\n        if (this.header_pos && this.parse_body) {\n            const line = this.add_dot_stuffing_and_ensure_crlf_newlines(this.body.parse_end());\n            if (line.length) {\n                this.body.force_end();\n\n                if (!this.discard_data) this.message_stream.add_line(line);\n            }\n        }\n\n        if (this.discard_data) {\n            cb();\n        }\n        else {\n            this.message_stream.add_line_end(cb);\n        }\n    }\n\n    add_header (key, value) {\n        this.header.add_end(key, value);\n        if (this.header_pos > 0) this.reset_headers();\n    }\n\n    add_leading_header (key, value) {\n        this.header.add(key, value);\n        if (this.header_pos > 0) this.reset_headers();\n    }\n\n    reset_headers () {\n        const header_lines = this.header.lines();\n        this.header_pos = header_lines.length;\n    }\n\n    remove_header (key) {\n        this.header.remove(key);\n        if (this.header_pos > 0) this.reset_headers();\n    }\n\n    attachment_hooks (start, data, end) {\n        this.parse_body = true;\n        this.attachment_start_hooks.push(start);\n    }\n\n    set_banner (text, html) {\n        // throw \"transaction.set_banner is currently non-functional\";\n        this.parse_body = true;\n        if (!html) {\n            html = text.replace(/\\n/g, '<br/>\\n');\n        }\n        this.banner = [text, html];\n    }\n\n    add_body_filter (ct_match, filter) {\n        this.parse_body = true;\n        this.body_filters.push({ ct_match, filter });\n    }\n\n    incr_mime_count (line) {\n        this.mime_part_count++;\n    }\n}\n\nexports.Transaction = Transaction;\n\nexports.createTransaction = (uuid, cfg) => {\n    return new Transaction(uuid, cfg);\n}\n"
        }
      ]
    }
  ]
}