{
  "metadata": {
    "timestamp": 1736562908066,
    "page": 498,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jakiestfu/Snap.js",
      "stars": 5986,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.923828125,
          "content": "#################\n## Eclipse\n#################\n\n*.pydevproject\n.project\n.metadata\nbin/\ntmp/\n*.tmp\n*.bak\n*.swp\n*~.nib\nlocal.properties\n.classpath\n.settings/\n.loadpath\n\n# External tool builders\n.externalToolBuilders/\n\n# Locally stored \"Eclipse launch configurations\"\n*.launch\n\n# CDT-specific\n.cproject\n\n# PDT-specific\n.buildpath\n\n\n#################\n## Visual Studio\n#################\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.sln.docstates\n\n# Build results\n[Dd]ebug/\n[Rr]elease/\n*_i.c\n*_p.c\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.vspscc\n.builds\n*.dotCover\n\n## TODO: If you have NuGet Package Restore enabled, uncomment this\n#packages/\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opensdf\n*.sdf\n\n# Visual Studio profiler\n*.psess\n*.vsp\n\n# ReSharper is a .NET coding add-in\n_ReSharper*\n\n# Installshield output folder\n[Ee]xpress\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish\n\n# Others\n[Bb]in\n[Oo]bj\nsql\nTestResults\n*.Cache\nClientBin\nstylecop.*\n~$*\n*.dbmdl\nGenerated_Code #added for RIA/Silverlight projects\n\n# Backup & report files from converting an old project file to a newer\n# Visual Studio version. Backup files are not needed, because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\n\n\n\n############\n## Windows\n############\n\n# Windows image file caches\nThumbs.db\n\n# Folder config file\nDesktop.ini\n\n\n#############\n## Python\n#############\n\n*.py[co]\n\n# Packages\n*.egg\n*.egg-info\ndist\nbuild\neggs\nparts\nbin\nvar\nsdist\ndevelop-eggs\n.installed.cfg\n\n# Installer logs\npip-log.txt\n\n# Unit test / coverage reports\n.coverage\n.tox\n\n#Translations\n*.mo\n\n#Mr Developer\n.mr.developer.cfg\n\n# Mac crap\n.DS_Store\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.5341796875,
          "content": "# Snap.js\nA Library for creating beautiful mobile shelfs in Javascript\n\n<a href=\"http://www.screenr.com/embed/0EJ7\" target=\"_blank\">View Video Preview</a>\n\n<a href=\"http://jakiestfu.github.io/Snap.js/\" target=\"_blank\">View Demos</a>\n\n<a href=\"http://www.screenr.com/embed/0EJ7\" target=\"_blank\"><img src=\"http://i.imgur.com/t3mGcEx.gif\"></a>\n\n* [Features](#features)\n* [Support](#support)\n* [Installation](#installation)\n* [Usage](#usage)\n* [Settings &amp; Defaults](#settings-and-defaults)\n* [Public Methods](#public-methods)\n* [Gotchas](#gotchas)\n* [FAQ's](#faq)\n* [Compliments](#compliments)\n* [Licensing](#licensing)\n* [Extras](#extras)\n\n## Features\n* Library Independent\n* High Customization\n* Flick Support\n* User Intent Detection\n* Disable Hyperextension\n* Event Hooks\n* CSS3 Powered Animations with IE fallbacks\n* Drag Support\n* Drag Handle Support\n* Programatic API\n* \"No-Drag\" Elements\n* Definable Easing Mode\n* Enable/Disable Events\n* Disabled Sides (left or right)\n* Supports [Ratchet](http://maker.github.com/ratchet/) (with templates!)\n\n## Support\n* Firefox 10+\n* Wide Webkit Support (including Android WebKit 2.3.X)\n* IE 10\n* IE 9 Supports Toggling, Dragging but no Transitions\n* IE 7/8 Supports Toggling but no dragging or Transitions\n\n## Installation\n\nAs standalone just include the file in a script tag:\n\n```html\n<script src=\"snap.js\"></script>\n```\n\nAs a <a href=\"http://component.io\" target=\"_blank\">web component</a> do:\n\n```shell\n$ component install jakiestfu/Snap.js\n```\n\n## Usage\n\n```javascript\nvar snapper = new Snap({\n  element: document.getElementById('content')\n});\n```\n\n## Settings and Defaults\n```javascript\nsettings = {\n    element: null,\n    dragger: null,\n    disable: 'none',\n    addBodyClasses: true,\n    hyperextensible: true,\n    resistance: 0.5,\n    flickThreshold: 50,\n    transitionSpeed: 0.3,\n    easing: 'ease',\n    maxPosition: 266,\n    minPosition: -266,\n    tapToClose: true,\n    touchToDrag: true,\n    slideIntent: 40,\n    minDragDistance: 5\n}\n```\n\n* `element`: The element which the user will be sliding side to side\n* `dragger`: The element which the user will be using to slide the target element side to side\n* `disable`: String, set to 'left' or 'right' to disable the respective side\n* `addBodyClasses`: Add classes to the body to signify which side is being opened\n* `hyperextensible`: If false, pane may not be slide past the minPosition and maxPosition\n* `resistance`: The cooeficcient used to slow sliding when user has passed max or min threshold\n* `flickThreshold`: Number of pixels the user needs to swiftly travel to activate a \"flick\" open\n* `transitionSpeed`: The speed at which the pane slides open or closed\n* `easing`: The CSS3 Easing method you want to use for transitions\n* `maxPosition`: Maximum number of pixels the pane may be slid to the right\n* `minPosition`: Maximum number of pixels the pane may be slid to the left\n* `tapToClose`: If true, tapping an open pane will close it\n* `touchToDrag`: If true, dragging the target `settings.element` will open/close the pane\n* `minDragDistance`: The minimum amount of pixels the user needs to drag within the `slideIntent` degrees to move the pane \n* `slideIntent`: The number of degrees the user must initiate sliding in towards the left or right (see diagram below)\n\nNotes on Slide Intent: The slide intent is an int between 0 and 90, and represents the degrees in the first quadrant of a circle that you would like to have mirrored on the X *and* Y axis. For example, if you have 40 set as your `slideIntent` value, the user would only be able to slide the pane by dragging in the blue area in the diagram below. Once intent has been defined, it will not change until the user releases.\n\n<img src=\"http://i.imgur.com/uG2CNR8.png\">\n\n\n## Public Methods\n\n### `open`: Opens the pane to the specified side\n\n```javascript\nsnapper.open('left');\n// OR\nsnapper.open('right');\n```\n\n### `close`: Closes the pane\n\n```javascript\nsnapper.close();\n```\n\n### `expand`: Opens the pane entirely\n\n```javascript\nsnapper.expand('left');\n// OR\nsnapper.expand('right');\n```\n\n### `disable`: Disables sliding events\n\n```javascript\nsnapper.disable();\n```\n\n### `enable`: Enables sliding events after disabling\n\n```javascript\nsnapper.enable();\n```\n\n### `on`: Adds an event hook\n\n```javascript\nsnapper.on('start', function(){\n  // Do Something\n});\n```\nThe available methods to hook into are as follows:\n\n* `start`: Fired when touching down on the draggable pane and it begins to move\n* `drag`: Fired when the pane has been moved or slid\n* `end`: Fired when the pane has been let go of\n* `animating`: Fired when the pane is animating\n* `animated`: Fired when the pane is finished it's animations\n* `ignore`: Fired when trying to drag the pane but ended up dragging on an ignored element\n* `close`: Fired when close is called directly or if tapToClose is set to true\n* `open`: Fired when the menu is opened\n* `expandLeft`: Fired on expand('left')\n* `expandRight`: Fired on expand('right')\n* `enable`: Fired on enable\n* `disable`: Fired on disable\n\n### `off`: Removes an event hook\n\n```javascript\nsnapper.off('drag');\n```\nThe event names listed above apply for the `off` method.\n\n\n### `settings`: Updates the settings for an already instantiated object\n```javascript\nsnapper.settings({yourSettings});\n```\nCurrently, `settings.element`, `settings.touchToDrag` cannot be updated. To update the element, instantiate a new object. To allow listening to a drag, use `snapper.enable()`\n\n### `state`: Returns detailed information about the state of the pane\n\n```javascript\nvar data = snapper.state();\n```\nThe data returned from the `state` method will look like the following:\n\n```javascript\n{\n    state: \"closed\", // State of the Pane\n    info:{\n        opening: \"left\", // Side which user intends to open\n        towards: \"right\", // Direction user is dragging towards\n        hyperExtending: false, // True if user is pulling past predefined bounds\n        halfway: false, // True if pane is at least halfway open\n        flick: false, // True if user has moved pane X amount of pixels in the open/close direction without changing directions\n        translation:{\n            absolute: 20, // Pixels pane has translated\n            relative: 21, // Pixels pane has translated relative to starting translation\n            sinceDirectionChange: 10, // Pixels pane has translated since the direction of the pane has changed\n            percentage: 40.571649 // The percentage that the Pane is open. Good or animating other things\n        }\n    }\n} \n```\n\n## Gotchas\n\n### Layout\nThe layout itself is what most people will have a hard time emulating, so the simplest approach I have found is as follows:\n\nTwo absolute elements, one to represent *all* the content, and another to represent *all* the drawers. The content has a higher z-index than the drawers. Within the drawers element, it's direct children should represent the containers for the drawers, these should be `fixed` or `absolute`. Assigning classes to your drawers to specify which side it is on is recommended. All absolutely positioned elements should have 0 for `top, left, right, bottom` properties, excluding your panes which will have `auto` set to their respective sides and a width assigned. The width of your drawers is usually the same number you want to use for `minPosition` and `maxPosition`\n\n```html\ndiv.drawers {position: absolute;}\n    div.left-drawer  {position: absolute;}\n        [content]\n    div.right-drawer  {position: absolute;}\n        [content]\ndiv#content {position: absolute;}\n    [top-bars]\n    [content] {overflow: auto}\n    [bottom-bars]\n```\n\nA sample layout is found in demo/apps/default.html.\n\n### Independent Scrolling\nSome CSS is required to get some smooth ass scrolling. Utilize the CSS below to apply this to any of your elements:\n```css\n.scrollable{\n    overflow: auto;\n    -webkit-transition-property: top, bottom;\n    transition-property: top, bottom;\n    -webkit-transition-duration: .2s, .2s;\n    transition-duration: .2s, .2s;\n    -webkit-transition-timing-function: linear, linear;\n    transition-timing-function: linear, linear;\n    -webkit-overflow-scrolling: touch;\n}\n```\n\n### Z-Indeces and Display\nBecause of the nature of this code, drawers are just kind of stacked behind the content. To bring the proper drawer to the front, you can hook into Snaps.js' CSS classes:\n\nWith `addBodyClasses` set to `true` in your initialize options, one of the two classess will be added to the body tag: `.snapjs-left` or `.snapjs-right`, depending on which pane is being open, respectively. This being said, you can apply your CSS like the following to show the proper drawers:\n\n```css\n.snapjs-right .left-drawer,\n.snapjs-left .right-drawer {\n    display: none;\n}\n```\n\n## FAQ\n\n### - How do I make a toggle button?\nToggles have been a popular request, but rather than bog the library down with additional methods, you can utilize the powerful API of Snap.js to create your own toggle. Toggles can be done like the following:\n\n```javascript\nmyToggleButton.addEventListener('click', function(){\n\n    if( snapper.state().state==\"left\" ){\n        snapper.close();\n    } else {\n        snapper.open('left');\n    }\n\n});\n```\n\n### - How do I disable Snap.js dragging for my touch slider?\nSnap.js supports cascading cancellation of events via a data attribute `data-snap-ignore`. If you were to use a slider, your markup might look like the following:\n\n```html\n<div class=\"slider\" data-snap-ignore=\"true\">\n    <ul>\n        <li><img src=\"slide.jpg\"></li>\n        <li><img src=\"slide.jpg\"></li>\n        <li><img src=\"slide.jpg\"></li>\n        <li><img src=\"slide.jpg\"></li>\n        <li><img src=\"slide.jpg\"></li>\n    </ul>\n</div>\n```\n\nAll interactions on children elements of the element with the `data-snap-ignore` attribute will have their Snap.js events ignored.\n\n\n### - I am using Push.js from Ratchet, I keep losing my events on my elements, how can I fix this?\nSimple. As wack as Push.js is (yes, it is in desperate need of attention as of v1.0.0), we can still solve this problem with it's only callback, `'push'`.\n\n```javascript\n// The function that will initialize your Snap.js instance\nvar doSnap = function(){\n    if(window.snapper){\n         // Snap.js already exists, we just need to re-bind events\n        window.snapper.enable();\n    } else {\n        // Initialize Snap.js\n        window.snapper = new Snap({\n            element: document.getElementById('content')\n        });\n    } \n};\n\nwindow.addEventListener('push', doSnap);\ndoSnap();\n```\n\n### - Snap.js works on my Android device but i cannot scroll the content in my drawers, what gives?\nOlder Android devices (and iPhone as well) do not have native support for overflow scrolling. To solve this, you may use the wonderful library called [iScroll](https://github.com/cubiq/iscroll)\n\n### - `transform: translate3d()` breaks my fixed child elements, how can I solve this?\n[This is a problem with Chromium](https://code.google.com/p/chromium/issues/detail?id=20574) and should be fixed soon. I would advise not having your direct children element set to fixed, that may possibly solve your problem.\n\n### - I am experiencing a weird flicker when the CSS transform is applied\nTo solve the flicker, apply the following CSS to the element in question\n```css\n#content{\n    backface-visibility:hidden;\n    -webkit-backface-visibility:hidden; /* Chrome and Safari */\n    -moz-backface-visibility:hidden; /* Firefox */\n    -ms-backface-visibility:hidden; /* Internet Explorer 10+ */\n}\n```\n\n## Compliments\n\nThis code attempts to make your webapp's feel more \"native\". These other repos go well with it, too!\n\n* [Snap.js](https://github.com/jakiestfu/Snap.js)\n* [AppScroll.js](https://github.com/jakiestfu/AppScroll)\n* [fastclick](https://github.com/ftlabs/fastclick)\n\n## Licensing\n\nMIT, dawg\n"
        },
        {
          "name": "component.json",
          "type": "blob",
          "size": 0.3642578125,
          "content": "{\n  \"name\": \"Snap.js\",\n  \"description\": \"A Library for creating beautiful mobile shelfs in Javascript (Facebook and Path style side menus)\",\n  \"version\": \"1.9.2\",\n  \"author\": \"Jacob Kelley <jakie8@gmail.com>\",\n  \"keywords\": [\n    \"mobile shelfs\",\n    \"nav\",\n    \"menu\",\n    \"mobile\",\n    \"side menu\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"snap.js\",\n  \"scripts\": [\"snap.js\"]\n}\n"
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "snap.css",
          "type": "blob",
          "size": 1.267578125,
          "content": "html, body {\n  font-family: sans-serif;\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\n.snap-content {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  width: auto;\n  height: auto;\n  z-index: 2;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  -webkit-transform: translate3d(0, 0, 0);\n     -moz-transform: translate3d(0, 0, 0);\n      -ms-transform: translate3d(0, 0, 0);\n       -o-transform: translate3d(0, 0, 0);\n          transform: translate3d(0, 0, 0);\n}\n\n.snap-drawers {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  width: auto;\n  height: auto;\n}\n\n.snap-drawer {\n  position: absolute;\n  top: 0;\n  right: auto;\n  bottom: 0;\n  left: auto;\n  width: 265px;\n  height: auto;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  -webkit-transition: width 0.3s ease;\n     -moz-transition: width 0.3s ease;\n      -ms-transition: width 0.3s ease;\n       -o-transition: width 0.3s ease;\n          transition: width 0.3s ease;\n}\n\n.snap-drawer-left {\n  left: 0;\n  z-index: 1;\n}\n\n.snap-drawer-right {\n  right: 0;\n  z-index: 1;\n}\n\n.snapjs-left .snap-drawer-right,\n.snapjs-right .snap-drawer-left {\n  display: none;\n}\n\n.snapjs-expand-left .snap-drawer-left,\n.snapjs-expand-right .snap-drawer-right {\n  width: 100%;\n}\n"
        },
        {
          "name": "snap.js",
          "type": "blob",
          "size": 25.1279296875,
          "content": "/*\n * Snap.js\n *\n * Copyright 2013, Jacob Kelley - http://jakiestfu.com/\n * Released under the MIT Licence\n * http://opensource.org/licenses/MIT\n *\n * Github:  http://github.com/jakiestfu/Snap.js/\n * Version: 1.9.3\n */\n/*jslint browser: true*/\n/*global define, module, ender*/\n(function(win, doc) {\n    'use strict';\n    var Snap = Snap || function(userOpts) {\n        var settings = {\n            element: null,\n            dragger: null,\n            disable: 'none',\n            addBodyClasses: true,\n            hyperextensible: true,\n            resistance: 0.5,\n            flickThreshold: 50,\n            transitionSpeed: 0.3,\n            easing: 'ease',\n            maxPosition: 266,\n            minPosition: -266,\n            tapToClose: true,\n            touchToDrag: true,\n            slideIntent: 40, // degrees\n            minDragDistance: 5\n        },\n        cache = {\n            simpleStates: {\n                opening: null,\n                towards: null,\n                hyperExtending: null,\n                halfway: null,\n                flick: null,\n                translation: {\n                    absolute: 0,\n                    relative: 0,\n                    sinceDirectionChange: 0,\n                    percentage: 0\n                }\n            }\n        },\n        eventList = {},\n        utils = {\n            hasTouch: ('ontouchstart' in doc.documentElement || win.navigator.msPointerEnabled),\n            eventType: function(action) {\n                var eventTypes = {\n                        down: (utils.hasTouch ? 'touchstart' : 'mousedown'),\n                        move: (utils.hasTouch ? 'touchmove' : 'mousemove'),\n                        up: (utils.hasTouch ? 'touchend' : 'mouseup'),\n                        out: (utils.hasTouch ? 'touchcancel' : 'mouseout')\n                    };\n                return eventTypes[action];\n            },\n            page: function(t, e){\n                return (utils.hasTouch && e.touches.length && e.touches[0]) ? e.touches[0]['page'+t] : e['page'+t];\n            },\n            klass: {\n                has: function(el, name){\n                    return (el.className).indexOf(name) !== -1;\n                },\n                add: function(el, name){\n                    if(!utils.klass.has(el, name) && settings.addBodyClasses){\n                        el.className += \" \"+name;\n                    }\n                },\n                remove: function(el, name){\n                    if(settings.addBodyClasses){\n                        el.className = (el.className).replace(name, \"\").replace(/^\\s+|\\s+$/g, '');\n                    }\n                }\n            },\n            dispatchEvent: function(type) {\n                if (typeof eventList[type] === 'function') {\n                    return eventList[type].call();\n                }\n            },\n            vendor: function(){\n                var tmp = doc.createElement(\"div\"),\n                    prefixes = 'webkit Moz O ms'.split(' '),\n                    i;\n                for (i in prefixes) {\n                    if (typeof tmp.style[prefixes[i] + 'Transition'] !== 'undefined') {\n                        return prefixes[i];\n                    }\n                }\n            },\n            transitionCallback: function(){\n                return (cache.vendor==='Moz' || cache.vendor==='ms') ? 'transitionend' : cache.vendor+'TransitionEnd';\n            },\n            canTransform: function(){\n                return typeof settings.element.style[cache.vendor+'Transform'] !== 'undefined';\n            },\n            deepExtend: function(destination, source) {\n                var property;\n                for (property in source) {\n                    if (source[property] && source[property].constructor && source[property].constructor === Object) {\n                        destination[property] = destination[property] || {};\n                        utils.deepExtend(destination[property], source[property]);\n                    } else {\n                        destination[property] = source[property];\n                    }\n                }\n                return destination;\n            },\n            angleOfDrag: function(x, y) {\n                var degrees, theta;\n                // Calc Theta\n                theta = Math.atan2(-(cache.startDragY - y), (cache.startDragX - x));\n                if (theta < 0) {\n                    theta += 2 * Math.PI;\n                }\n                // Calc Degrees\n                degrees = Math.floor(theta * (180 / Math.PI) - 180);\n                if (degrees < 0 && degrees > -180) {\n                    degrees = 360 - Math.abs(degrees);\n                }\n                return Math.abs(degrees);\n            },\n            events: {\n                addEvent: function addEvent(element, eventName, func) {\n                    if (element.addEventListener) {\n                        return element.addEventListener(eventName, func, false);\n                    } else if (element.attachEvent) {\n                        return element.attachEvent(\"on\" + eventName, func);\n                    }\n                },\n                removeEvent: function addEvent(element, eventName, func) {\n                    if (element.addEventListener) {\n                        return element.removeEventListener(eventName, func, false);\n                    } else if (element.attachEvent) {\n                        return element.detachEvent(\"on\" + eventName, func);\n                    }\n                },\n                prevent: function(e) {\n                    if (e.preventDefault) {\n                        e.preventDefault();\n                    } else {\n                        e.returnValue = false;\n                    }\n                }\n            },\n            parentUntil: function(el, attr) {\n                var isStr = typeof attr === 'string';\n                while (el.parentNode) {\n                    if (isStr && el.getAttribute && el.getAttribute(attr)){\n                        return el;\n                    } else if(!isStr && el === attr){\n                        return el;\n                    }\n                    el = el.parentNode;\n                }\n                return null;\n            }\n        },\n        action = {\n            translate: {\n                get: {\n                    matrix: function(index) {\n\n                        if( !utils.canTransform() ){\n                            return parseInt(settings.element.style.left, 10);\n                        } else {\n                            var matrix = win.getComputedStyle(settings.element)[cache.vendor+'Transform'].match(/\\((.*)\\)/),\n                                ieOffset = 8;\n                            if (matrix) {\n                                matrix = matrix[1].split(',');\n                                if(matrix.length===16){\n                                    index+=ieOffset;\n                                }\n                                return parseInt(matrix[index], 10);\n                            }\n                            return 0;\n                        }\n                    }\n                },\n                easeCallback: function(){\n                    settings.element.style[cache.vendor+'Transition'] = '';\n                    cache.translation = action.translate.get.matrix(4);\n                    cache.easing = false;\n                    clearInterval(cache.animatingInterval);\n\n                    if(cache.easingTo===0){\n                        utils.klass.remove(doc.body, 'snapjs-right');\n                        utils.klass.remove(doc.body, 'snapjs-left');\n                    }\n\n                    utils.dispatchEvent('animated');\n                    utils.events.removeEvent(settings.element, utils.transitionCallback(), action.translate.easeCallback);\n                },\n                easeTo: function(n) {\n\n                    if( !utils.canTransform() ){\n                        cache.translation = n;\n                        action.translate.x(n);\n                    } else {\n                        cache.easing = true;\n                        cache.easingTo = n;\n\n                        settings.element.style[cache.vendor+'Transition'] = 'all ' + settings.transitionSpeed + 's ' + settings.easing;\n\n                        cache.animatingInterval = setInterval(function() {\n                            utils.dispatchEvent('animating');\n                        }, 1);\n                        \n                        utils.events.addEvent(settings.element, utils.transitionCallback(), action.translate.easeCallback);\n                        action.translate.x(n);\n                    }\n                    if(n===0){\n                           settings.element.style[cache.vendor+'Transform'] = '';\n                       }\n                },\n                x: function(n) {\n                    if( (settings.disable==='left' && n>0) ||\n                        (settings.disable==='right' && n<0)\n                    ){ return; }\n                    \n                    if( !settings.hyperextensible ){\n                        if( n===settings.maxPosition || n>settings.maxPosition ){\n                            n=settings.maxPosition;\n                        } else if( n===settings.minPosition || n<settings.minPosition ){\n                            n=settings.minPosition;\n                        }\n                    }\n                    \n                    n = parseInt(n, 10);\n                    if(isNaN(n)){\n                        n = 0;\n                    }\n\n                    if( utils.canTransform() ){\n                        var theTranslate = 'translate3d(' + n + 'px, 0,0)';\n                        settings.element.style[cache.vendor+'Transform'] = theTranslate;\n                    } else {\n                        settings.element.style.width = (win.innerWidth || doc.documentElement.clientWidth)+'px';\n\n                        settings.element.style.left = n+'px';\n                        settings.element.style.right = '';\n                    }\n                }\n            },\n            drag: {\n                listen: function() {\n                    cache.translation = 0;\n                    cache.easing = false;\n                    utils.events.addEvent(settings.element, utils.eventType('down'), action.drag.startDrag);\n                    utils.events.addEvent(settings.element, utils.eventType('move'), action.drag.dragging);\n                    utils.events.addEvent(settings.element, utils.eventType('up'), action.drag.endDrag);\n                },\n                stopListening: function() {\n                    utils.events.removeEvent(settings.element, utils.eventType('down'), action.drag.startDrag);\n                    utils.events.removeEvent(settings.element, utils.eventType('move'), action.drag.dragging);\n                    utils.events.removeEvent(settings.element, utils.eventType('up'), action.drag.endDrag);\n                },\n                startDrag: function(e) {\n                    // No drag on ignored elements\n                    var target = e.target ? e.target : e.srcElement,\n                        ignoreParent = utils.parentUntil(target, 'data-snap-ignore');\n                    \n                    if (ignoreParent) {\n                        utils.dispatchEvent('ignore');\n                        return;\n                    }\n                    \n                    \n                    if(settings.dragger){\n                        var dragParent = utils.parentUntil(target, settings.dragger);\n                        \n                        // Only use dragger if we're in a closed state\n                        if( !dragParent && \n                            (cache.translation !== settings.minPosition && \n                            cache.translation !== settings.maxPosition\n                        )){\n                            return;\n                        }\n                    }\n                    \n                    utils.dispatchEvent('start');\n                    settings.element.style[cache.vendor+'Transition'] = '';\n                    cache.isDragging = true;\n                    cache.hasIntent = null;\n                    cache.intentChecked = false;\n                    cache.startDragX = utils.page('X', e);\n                    cache.startDragY = utils.page('Y', e);\n                    cache.dragWatchers = {\n                        current: 0,\n                        last: 0,\n                        hold: 0,\n                        state: ''\n                    };\n                    cache.simpleStates = {\n                        opening: null,\n                        towards: null,\n                        hyperExtending: null,\n                        halfway: null,\n                        flick: null,\n                        translation: {\n                            absolute: 0,\n                            relative: 0,\n                            sinceDirectionChange: 0,\n                            percentage: 0\n                        }\n                    };\n                },\n                dragging: function(e) {\n                    if (cache.isDragging && settings.touchToDrag) {\n\n                        var thePageX = utils.page('X', e),\n                            thePageY = utils.page('Y', e),\n                            translated = cache.translation,\n                            absoluteTranslation = action.translate.get.matrix(4),\n                            whileDragX = thePageX - cache.startDragX,\n                            openingLeft = absoluteTranslation > 0,\n                            translateTo = whileDragX,\n                            diff;\n\n                        // Shown no intent already\n                        if((cache.intentChecked && !cache.hasIntent)){\n                            return;\n                        }\n\n                        if(settings.addBodyClasses){\n                            if((absoluteTranslation)>0){\n                                utils.klass.add(doc.body, 'snapjs-left');\n                                utils.klass.remove(doc.body, 'snapjs-right');\n                            } else if((absoluteTranslation)<0){\n                                utils.klass.add(doc.body, 'snapjs-right');\n                                utils.klass.remove(doc.body, 'snapjs-left');\n                            }\n                        }\n\n                        if (cache.hasIntent === false || cache.hasIntent === null) {\n                            var deg = utils.angleOfDrag(thePageX, thePageY),\n                                inRightRange = (deg >= 0 && deg <= settings.slideIntent) || (deg <= 360 && deg > (360 - settings.slideIntent)),\n                                inLeftRange = (deg >= 180 && deg <= (180 + settings.slideIntent)) || (deg <= 180 && deg >= (180 - settings.slideIntent));\n                            if (!inLeftRange && !inRightRange) {\n                                cache.hasIntent = false;\n                            } else {\n                                cache.hasIntent = true;\n                            }\n                            cache.intentChecked = true;\n                        }\n\n                        if (\n                            (settings.minDragDistance>=Math.abs(thePageX-cache.startDragX)) || // Has user met minimum drag distance?\n                            (cache.hasIntent === false)\n                        ) {\n                            return;\n                        }\n\n                        utils.events.prevent(e);\n                        utils.dispatchEvent('drag');\n\n                        cache.dragWatchers.current = thePageX;\n                        // Determine which direction we are going\n                        if (cache.dragWatchers.last > thePageX) {\n                            if (cache.dragWatchers.state !== 'left') {\n                                cache.dragWatchers.state = 'left';\n                                cache.dragWatchers.hold = thePageX;\n                            }\n                            cache.dragWatchers.last = thePageX;\n                        } else if (cache.dragWatchers.last < thePageX) {\n                            if (cache.dragWatchers.state !== 'right') {\n                                cache.dragWatchers.state = 'right';\n                                cache.dragWatchers.hold = thePageX;\n                            }\n                            cache.dragWatchers.last = thePageX;\n                        }\n                        if (openingLeft) {\n                            // Pulling too far to the right\n                            if (settings.maxPosition < absoluteTranslation) {\n                                diff = (absoluteTranslation - settings.maxPosition) * settings.resistance;\n                                translateTo = whileDragX - diff;\n                            }\n                            cache.simpleStates = {\n                                opening: 'left',\n                                towards: cache.dragWatchers.state,\n                                hyperExtending: settings.maxPosition < absoluteTranslation,\n                                halfway: absoluteTranslation > (settings.maxPosition / 2),\n                                flick: Math.abs(cache.dragWatchers.current - cache.dragWatchers.hold) > settings.flickThreshold,\n                                translation: {\n                                    absolute: absoluteTranslation,\n                                    relative: whileDragX,\n                                    sinceDirectionChange: (cache.dragWatchers.current - cache.dragWatchers.hold),\n                                    percentage: (absoluteTranslation/settings.maxPosition)*100\n                                }\n                            };\n                        } else {\n                            // Pulling too far to the left\n                            if (settings.minPosition > absoluteTranslation) {\n                                diff = (absoluteTranslation - settings.minPosition) * settings.resistance;\n                                translateTo = whileDragX - diff;\n                            }\n                            cache.simpleStates = {\n                                opening: 'right',\n                                towards: cache.dragWatchers.state,\n                                hyperExtending: settings.minPosition > absoluteTranslation,\n                                halfway: absoluteTranslation < (settings.minPosition / 2),\n                                flick: Math.abs(cache.dragWatchers.current - cache.dragWatchers.hold) > settings.flickThreshold,\n                                translation: {\n                                    absolute: absoluteTranslation,\n                                    relative: whileDragX,\n                                    sinceDirectionChange: (cache.dragWatchers.current - cache.dragWatchers.hold),\n                                    percentage: (absoluteTranslation/settings.minPosition)*100\n                                }\n                            };\n                        }\n                        action.translate.x(translateTo + translated);\n                    }\n                },\n                endDrag: function(e) {\n                    if (cache.isDragging) {\n                        utils.dispatchEvent('end');\n                        var translated = action.translate.get.matrix(4);\n\n                        // Tap Close\n                        if (cache.dragWatchers.current === 0 && translated !== 0 && settings.tapToClose) {\n                            utils.dispatchEvent('close');\n                            utils.events.prevent(e);\n                            action.translate.easeTo(0);\n                            cache.isDragging = false;\n                            cache.startDragX = 0;\n                            return;\n                        }\n\n                        // Revealing Left\n                        if (cache.simpleStates.opening === 'left') {\n                            // Halfway, Flicking, or Too Far Out\n                            if ((cache.simpleStates.halfway || cache.simpleStates.hyperExtending || cache.simpleStates.flick)) {\n                                if (cache.simpleStates.flick && cache.simpleStates.towards === 'left') { // Flicking Closed\n                                    action.translate.easeTo(0);\n                                } else if (\n                                    (cache.simpleStates.flick && cache.simpleStates.towards === 'right') || // Flicking Open OR\n                                    (cache.simpleStates.halfway || cache.simpleStates.hyperExtending) // At least halfway open OR hyperextending\n                                ) {\n                                    action.translate.easeTo(settings.maxPosition); // Open Left\n                                }\n                            } else {\n                                action.translate.easeTo(0); // Close Left\n                            }\n                            // Revealing Right\n                        } else if (cache.simpleStates.opening === 'right') {\n                            // Halfway, Flicking, or Too Far Out\n                            if ((cache.simpleStates.halfway || cache.simpleStates.hyperExtending || cache.simpleStates.flick)) {\n                                if (cache.simpleStates.flick && cache.simpleStates.towards === 'right') { // Flicking Closed\n                                    action.translate.easeTo(0);\n                                } else if (\n                                    (cache.simpleStates.flick && cache.simpleStates.towards === 'left') || // Flicking Open OR\n                                    (cache.simpleStates.halfway || cache.simpleStates.hyperExtending) // At least halfway open OR hyperextending\n                                ) {\n                                    action.translate.easeTo(settings.minPosition); // Open Right\n                                }\n                            } else {\n                                action.translate.easeTo(0); // Close Right\n                            }\n                        }\n                        cache.isDragging = false;\n                        cache.startDragX = utils.page('X', e);\n                    }\n                }\n            }\n        },\n        init = function(opts) {\n            if (opts.element) {\n                utils.deepExtend(settings, opts);\n                cache.vendor = utils.vendor();\n                action.drag.listen();\n            }\n        };\n        /*\n         * Public\n         */\n        this.open = function(side) {\n            utils.dispatchEvent('open');\n            utils.klass.remove(doc.body, 'snapjs-expand-left');\n            utils.klass.remove(doc.body, 'snapjs-expand-right');\n\n            if (side === 'left') {\n                cache.simpleStates.opening = 'left';\n                cache.simpleStates.towards = 'right';\n                utils.klass.add(doc.body, 'snapjs-left');\n                utils.klass.remove(doc.body, 'snapjs-right');\n                action.translate.easeTo(settings.maxPosition);\n            } else if (side === 'right') {\n                cache.simpleStates.opening = 'right';\n                cache.simpleStates.towards = 'left';\n                utils.klass.remove(doc.body, 'snapjs-left');\n                utils.klass.add(doc.body, 'snapjs-right');\n                action.translate.easeTo(settings.minPosition);\n            }\n        };\n        this.close = function() {\n            utils.dispatchEvent('close');\n            action.translate.easeTo(0);\n        };\n        this.expand = function(side){\n            var to = win.innerWidth || doc.documentElement.clientWidth;\n\n            if(side==='left'){\n                utils.dispatchEvent('expandLeft');\n                utils.klass.add(doc.body, 'snapjs-expand-left');\n                utils.klass.remove(doc.body, 'snapjs-expand-right');\n            } else {\n                utils.dispatchEvent('expandRight');\n                utils.klass.add(doc.body, 'snapjs-expand-right');\n                utils.klass.remove(doc.body, 'snapjs-expand-left');\n                to *= -1;\n            }\n            action.translate.easeTo(to);\n        };\n\n        this.on = function(evt, fn) {\n            eventList[evt] = fn;\n            return this;\n        };\n        this.off = function(evt) {\n            if (eventList[evt]) {\n                eventList[evt] = false;\n            }\n        };\n\n        this.enable = function() {\n            utils.dispatchEvent('enable');\n            action.drag.listen();\n        };\n        this.disable = function() {\n            utils.dispatchEvent('disable');\n            action.drag.stopListening();\n        };\n\n        this.settings = function(opts){\n            utils.deepExtend(settings, opts);\n        };\n\n        this.state = function() {\n            var state,\n                fromLeft = action.translate.get.matrix(4);\n            if (fromLeft === settings.maxPosition) {\n                state = 'left';\n            } else if (fromLeft === settings.minPosition) {\n                state = 'right';\n            } else {\n                state = 'closed';\n            }\n            return {\n                state: state,\n                info: cache.simpleStates\n            };\n        };\n        init(userOpts);\n    };\n    if ((typeof module !== 'undefined') && module.exports) {\n        module.exports = Snap;\n    }\n    if (typeof ender === 'undefined') {\n        this.Snap = Snap;\n    }\n    if ((typeof define === \"function\") && define.amd) {\n        define(\"snap\", [], function() {\n            return Snap;\n        });\n    }\n}).call(this, window, document);\n"
        },
        {
          "name": "snap.min.js",
          "type": "blob",
          "size": 9.73046875,
          "content": "/*\n * Snap.js\n *\n * Copyright 2013, Jacob Kelley - http://jakiestfu.com/\n * Released under the MIT Licence\n * http://opensource.org/licenses/MIT\n *\n * Github:  http://github.com/jakiestfu/Snap.js/\n * Version: 1.9.2\n */\n (function(c,b){var a=a||function(k){var f={element:null,dragger:null,disable:\"none\",addBodyClasses:true,hyperextensible:true,resistance:0.5,flickThreshold:50,transitionSpeed:0.3,easing:\"ease\",maxPosition:266,minPosition:-266,tapToClose:true,touchToDrag:true,slideIntent:40,minDragDistance:5},e={simpleStates:{opening:null,towards:null,hyperExtending:null,halfway:null,flick:null,translation:{absolute:0,relative:0,sinceDirectionChange:0,percentage:0}}},h={},d={hasTouch:(b.ontouchstart===null),eventType:function(m){var l={down:(d.hasTouch?\"touchstart\":\"mousedown\"),move:(d.hasTouch?\"touchmove\":\"mousemove\"),up:(d.hasTouch?\"touchend\":\"mouseup\"),out:(d.hasTouch?\"touchcancel\":\"mouseout\")};return l[m]},page:function(l,m){return(d.hasTouch&&m.touches.length&&m.touches[0])?m.touches[0][\"page\"+l]:m[\"page\"+l]},klass:{has:function(m,l){return(m.className).indexOf(l)!==-1},add:function(m,l){if(!d.klass.has(m,l)&&f.addBodyClasses){m.className+=\" \"+l}},remove:function(m,l){if(f.addBodyClasses){m.className=(m.className).replace(l,\"\").replace(/^\\s+|\\s+$/g,\"\")}}},dispatchEvent:function(l){if(typeof h[l]===\"function\"){return h[l].call()}},vendor:function(){var m=b.createElement(\"div\"),n=\"webkit Moz O ms\".split(\" \"),l;for(l in n){if(typeof m.style[n[l]+\"Transition\"]!==\"undefined\"){return n[l]}}},transitionCallback:function(){return(e.vendor===\"Moz\"||e.vendor===\"ms\")?\"transitionend\":e.vendor+\"TransitionEnd\"},canTransform:function(){return typeof f.element.style[e.vendor+\"Transform\"]!==\"undefined\"},deepExtend:function(l,n){var m;for(m in n){if(n[m]&&n[m].constructor&&n[m].constructor===Object){l[m]=l[m]||{};d.deepExtend(l[m],n[m])}else{l[m]=n[m]}}return l},angleOfDrag:function(l,o){var n,m;m=Math.atan2(-(e.startDragY-o),(e.startDragX-l));if(m<0){m+=2*Math.PI}n=Math.floor(m*(180/Math.PI)-180);if(n<0&&n>-180){n=360-Math.abs(n)}return Math.abs(n)},events:{addEvent:function g(m,l,n){if(m.addEventListener){return m.addEventListener(l,n,false)}else{if(m.attachEvent){return m.attachEvent(\"on\"+l,n)}}},removeEvent:function g(m,l,n){if(m.addEventListener){return m.removeEventListener(l,n,false)}else{if(m.attachEvent){return m.detachEvent(\"on\"+l,n)}}},prevent:function(l){if(l.preventDefault){l.preventDefault()}else{l.returnValue=false}}},parentUntil:function(n,l){var m=typeof l===\"string\";while(n.parentNode){if(m&&n.getAttribute&&n.getAttribute(l)){return n}else{if(!m&&n===l){return n}}n=n.parentNode}return null}},i={translate:{get:{matrix:function(n){if(!d.canTransform()){return parseInt(f.element.style.left,10)}else{var m=c.getComputedStyle(f.element)[e.vendor+\"Transform\"].match(/\\((.*)\\)/),l=8;if(m){m=m[1].split(\",\");if(m.length===16){n+=l}return parseInt(m[n],10)}return 0}}},easeCallback:function(){f.element.style[e.vendor+\"Transition\"]=\"\";e.translation=i.translate.get.matrix(4);e.easing=false;clearInterval(e.animatingInterval);if(e.easingTo===0){d.klass.remove(b.body,\"snapjs-right\");d.klass.remove(b.body,\"snapjs-left\")}d.dispatchEvent(\"animated\");d.events.removeEvent(f.element,d.transitionCallback(),i.translate.easeCallback)},easeTo:function(l){if(!d.canTransform()){e.translation=l;i.translate.x(l)}else{e.easing=true;e.easingTo=l;f.element.style[e.vendor+\"Transition\"]=\"all \"+f.transitionSpeed+\"s \"+f.easing;e.animatingInterval=setInterval(function(){d.dispatchEvent(\"animating\")},1);d.events.addEvent(f.element,d.transitionCallback(),i.translate.easeCallback);i.translate.x(l)}if(l===0){f.element.style[e.vendor+\"Transform\"]=\"\"}},x:function(m){if((f.disable===\"left\"&&m>0)||(f.disable===\"right\"&&m<0)){return}if(!f.hyperextensible){if(m===f.maxPosition||m>f.maxPosition){m=f.maxPosition}else{if(m===f.minPosition||m<f.minPosition){m=f.minPosition}}}m=parseInt(m,10);if(isNaN(m)){m=0}if(d.canTransform()){var l=\"translate3d(\"+m+\"px, 0,0)\";f.element.style[e.vendor+\"Transform\"]=l}else{f.element.style.width=(c.innerWidth||b.documentElement.clientWidth)+\"px\";f.element.style.left=m+\"px\";f.element.style.right=\"\"}}},drag:{listen:function(){e.translation=0;e.easing=false;d.events.addEvent(f.element,d.eventType(\"down\"),i.drag.startDrag);d.events.addEvent(f.element,d.eventType(\"move\"),i.drag.dragging);d.events.addEvent(f.element,d.eventType(\"up\"),i.drag.endDrag)},stopListening:function(){d.events.removeEvent(f.element,d.eventType(\"down\"),i.drag.startDrag);d.events.removeEvent(f.element,d.eventType(\"move\"),i.drag.dragging);d.events.removeEvent(f.element,d.eventType(\"up\"),i.drag.endDrag)},startDrag:function(n){var m=n.target?n.target:n.srcElement,l=d.parentUntil(m,\"data-snap-ignore\");if(l){d.dispatchEvent(\"ignore\");return}if(f.dragger){var o=d.parentUntil(m,f.dragger);if(!o&&(e.translation!==f.minPosition&&e.translation!==f.maxPosition)){return}}d.dispatchEvent(\"start\");f.element.style[e.vendor+\"Transition\"]=\"\";e.isDragging=true;e.hasIntent=null;e.intentChecked=false;e.startDragX=d.page(\"X\",n);e.startDragY=d.page(\"Y\",n);e.dragWatchers={current:0,last:0,hold:0,state:\"\"};e.simpleStates={opening:null,towards:null,hyperExtending:null,halfway:null,flick:null,translation:{absolute:0,relative:0,sinceDirectionChange:0,percentage:0}}},dragging:function(s){if(e.isDragging&&f.touchToDrag){var v=d.page(\"X\",s),u=d.page(\"Y\",s),t=e.translation,o=i.translate.get.matrix(4),n=v-e.startDragX,p=o>0,q=n,w;if((e.intentChecked&&!e.hasIntent)){return}if(f.addBodyClasses){if((o)>0){d.klass.add(b.body,\"snapjs-left\");d.klass.remove(b.body,\"snapjs-right\")}else{if((o)<0){d.klass.add(b.body,\"snapjs-right\");d.klass.remove(b.body,\"snapjs-left\")}}}if(e.hasIntent===false||e.hasIntent===null){var m=d.angleOfDrag(v,u),l=(m>=0&&m<=f.slideIntent)||(m<=360&&m>(360-f.slideIntent)),r=(m>=180&&m<=(180+f.slideIntent))||(m<=180&&m>=(180-f.slideIntent));if(!r&&!l){e.hasIntent=false}else{e.hasIntent=true}e.intentChecked=true}if((f.minDragDistance>=Math.abs(v-e.startDragX))||(e.hasIntent===false)){return}d.events.prevent(s);d.dispatchEvent(\"drag\");e.dragWatchers.current=v;if(e.dragWatchers.last>v){if(e.dragWatchers.state!==\"left\"){e.dragWatchers.state=\"left\";e.dragWatchers.hold=v}e.dragWatchers.last=v}else{if(e.dragWatchers.last<v){if(e.dragWatchers.state!==\"right\"){e.dragWatchers.state=\"right\";e.dragWatchers.hold=v}e.dragWatchers.last=v}}if(p){if(f.maxPosition<o){w=(o-f.maxPosition)*f.resistance;q=n-w}e.simpleStates={opening:\"left\",towards:e.dragWatchers.state,hyperExtending:f.maxPosition<o,halfway:o>(f.maxPosition/2),flick:Math.abs(e.dragWatchers.current-e.dragWatchers.hold)>f.flickThreshold,translation:{absolute:o,relative:n,sinceDirectionChange:(e.dragWatchers.current-e.dragWatchers.hold),percentage:(o/f.maxPosition)*100}}}else{if(f.minPosition>o){w=(o-f.minPosition)*f.resistance;q=n-w}e.simpleStates={opening:\"right\",towards:e.dragWatchers.state,hyperExtending:f.minPosition>o,halfway:o<(f.minPosition/2),flick:Math.abs(e.dragWatchers.current-e.dragWatchers.hold)>f.flickThreshold,translation:{absolute:o,relative:n,sinceDirectionChange:(e.dragWatchers.current-e.dragWatchers.hold),percentage:(o/f.minPosition)*100}}}i.translate.x(q+t)}},endDrag:function(m){if(e.isDragging){d.dispatchEvent(\"end\");var l=i.translate.get.matrix(4);if(e.dragWatchers.current===0&&l!==0&&f.tapToClose){d.dispatchEvent(\"close\");d.events.prevent(m);i.translate.easeTo(0);e.isDragging=false;e.startDragX=0;return}if(e.simpleStates.opening===\"left\"){if((e.simpleStates.halfway||e.simpleStates.hyperExtending||e.simpleStates.flick)){if(e.simpleStates.flick&&e.simpleStates.towards===\"left\"){i.translate.easeTo(0)}else{if((e.simpleStates.flick&&e.simpleStates.towards===\"right\")||(e.simpleStates.halfway||e.simpleStates.hyperExtending)){i.translate.easeTo(f.maxPosition)}}}else{i.translate.easeTo(0)}}else{if(e.simpleStates.opening===\"right\"){if((e.simpleStates.halfway||e.simpleStates.hyperExtending||e.simpleStates.flick)){if(e.simpleStates.flick&&e.simpleStates.towards===\"right\"){i.translate.easeTo(0)}else{if((e.simpleStates.flick&&e.simpleStates.towards===\"left\")||(e.simpleStates.halfway||e.simpleStates.hyperExtending)){i.translate.easeTo(f.minPosition)}}}else{i.translate.easeTo(0)}}}e.isDragging=false;e.startDragX=d.page(\"X\",m)}}}},j=function(l){if(l.element){d.deepExtend(f,l);e.vendor=d.vendor();i.drag.listen()}};this.open=function(l){d.dispatchEvent(\"open\");d.klass.remove(b.body,\"snapjs-expand-left\");d.klass.remove(b.body,\"snapjs-expand-right\");if(l===\"left\"){e.simpleStates.opening=\"left\";e.simpleStates.towards=\"right\";d.klass.add(b.body,\"snapjs-left\");d.klass.remove(b.body,\"snapjs-right\");i.translate.easeTo(f.maxPosition)}else{if(l===\"right\"){e.simpleStates.opening=\"right\";e.simpleStates.towards=\"left\";d.klass.remove(b.body,\"snapjs-left\");d.klass.add(b.body,\"snapjs-right\");i.translate.easeTo(f.minPosition)}}};this.close=function(){d.dispatchEvent(\"close\");i.translate.easeTo(0)};this.expand=function(l){var m=c.innerWidth||b.documentElement.clientWidth;if(l===\"left\"){d.dispatchEvent(\"expandLeft\");d.klass.add(b.body,\"snapjs-expand-left\");d.klass.remove(b.body,\"snapjs-expand-right\")}else{d.dispatchEvent(\"expandRight\");d.klass.add(b.body,\"snapjs-expand-right\");d.klass.remove(b.body,\"snapjs-expand-left\");m*=-1}i.translate.easeTo(m)};this.on=function(l,m){h[l]=m;return this};this.off=function(l){if(h[l]){h[l]=false}};this.enable=function(){d.dispatchEvent(\"enable\");i.drag.listen()};this.disable=function(){d.dispatchEvent(\"disable\");i.drag.stopListening()};this.settings=function(l){d.deepExtend(f,l)};this.state=function(){var l,m=i.translate.get.matrix(4);if(m===f.maxPosition){l=\"left\"}else{if(m===f.minPosition){l=\"right\"}else{l=\"closed\"}}return{state:l,info:e.simpleStates}};j(k)};if((typeof module!==\"undefined\")&&module.exports){module.exports=a}if(typeof ender===\"undefined\"){this.Snap=a}if((typeof define===\"function\")&&define.amd){define(\"snap\",[],function(){return a})}}).call(this,window,document);\n"
        }
      ]
    }
  ]
}