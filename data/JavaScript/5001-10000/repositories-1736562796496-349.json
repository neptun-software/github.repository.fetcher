{
  "metadata": {
    "timestamp": 1736562796496,
    "page": 349,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sindresorhus/query-string",
      "stars": 6791,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1708984375,
          "content": "root = true\n\n[*]\nindent_style = tab\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.yml]\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0185546875,
          "content": "* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0224609375,
          "content": "node_modules\nyarn.lock\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": "base.d.ts",
          "type": "blob",
          "size": 18.4189453125,
          "content": "export type ParseOptions = {\n\t/**\n\tDecode the keys and values. URI components are decoded with [`decode-uri-component`](https://github.com/SamVerschueren/decode-uri-component).\n\n\t@default true\n\t*/\n\treadonly decode?: boolean;\n\n\t/**\n\t@default 'none'\n\n\t- `bracket`: Parse arrays with bracket representation:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.parse('foo[]=1&foo[]=2&foo[]=3', {arrayFormat: 'bracket'});\n\t\t//=> {foo: ['1', '2', '3']}\n\t\t```\n\n\t- `index`: Parse arrays with index representation:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.parse('foo[0]=1&foo[1]=2&foo[3]=3', {arrayFormat: 'index'});\n\t\t//=> {foo: ['1', '2', '3']}\n\t\t```\n\n\t- `comma`: Parse arrays with elements separated by comma:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.parse('foo=1,2,3', {arrayFormat: 'comma'});\n\t\t//=> {foo: ['1', '2', '3']}\n\t\t```\n\n\t- `separator`: Parse arrays with elements separated by a custom character:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.parse('foo=1|2|3', {arrayFormat: 'separator', arrayFormatSeparator: '|'});\n\t\t//=> {foo: ['1', '2', '3']}\n\t\t```\n\n\t- `bracket-separator`: Parse arrays (that are explicitly marked with brackets) with elements separated by a custom character:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.parse('foo[]', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> {foo: []}\n\n\t\tqueryString.parse('foo[]=', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> {foo: ['']}\n\n\t\tqueryString.parse('foo[]=1', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t \t//=> {foo: ['1']}\n\n\t\tqueryString.parse('foo[]=1|2|3', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> {foo: ['1', '2', '3']}\n\n\t\tqueryString.parse('foo[]=1||3|||6', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> {foo: ['1', '', 3, '', '', '6']}\n\n\t\tqueryString.parse('foo[]=1|2|3&bar=fluffy&baz[]=4', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> {foo: ['1', '2', '3'], bar: 'fluffy', baz:['4']}\n\t\t```\n\n\t- `colon-list-separator`: Parse arrays with parameter names that are explicitly marked with `:list`:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.parse('foo:list=one&foo:list=two', {arrayFormat: 'colon-list-separator'});\n\t\t//=> {foo: ['one', 'two']}\n\t\t```\n\n\t- `none`: Parse arrays with elements using duplicate keys:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.parse('foo=1&foo=2&foo=3');\n\t\t//=> {foo: ['1', '2', '3']}\n\t\t```\n\t*/\n\treadonly arrayFormat?:\n\t| 'bracket'\n\t| 'index'\n\t| 'comma'\n\t| 'separator'\n\t| 'bracket-separator'\n\t| 'colon-list-separator'\n\t| 'none';\n\n\t/**\n\tThe character used to separate array elements when using `{arrayFormat: 'separator'}`.\n\n\t@default ,\n\t*/\n\treadonly arrayFormatSeparator?: string;\n\n\t/**\n\tSupports both `Function` as a custom sorting function or `false` to disable sorting.\n\n\tIf omitted, keys are sorted using `Array#sort`, which means, converting them to strings and comparing strings in Unicode code point order.\n\n\t@default true\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tconst order = ['c', 'a', 'b'];\n\n\tqueryString.parse('?a=one&b=two&c=three', {\n\t\tsort: (itemLeft, itemRight) => order.indexOf(itemLeft) - order.indexOf(itemRight)\n\t});\n\t//=> {c: 'three', a: 'one', b: 'two'}\n\t```\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.parse('?a=one&c=three&b=two', {sort: false});\n\t//=> {a: 'one', c: 'three', b: 'two'}\n\t```\n\t*/\n\treadonly sort?: ((itemLeft: string, itemRight: string) => number) | false;\n\n\t/**\n\tParse the value as a number type instead of string type if it's a number.\n\n\t@default false\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.parse('foo=1', {parseNumbers: true});\n\t//=> {foo: 1}\n\t```\n\t*/\n\treadonly parseNumbers?: boolean;\n\n\t/**\n\tParse the value as a boolean type instead of string type if it's a boolean.\n\n\t@default false\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.parse('foo=true', {parseBooleans: true});\n\t//=> {foo: true}\n\t```\n\t*/\n\treadonly parseBooleans?: boolean;\n\n\t/**\n\tParse the fragment identifier from the URL and add it to result object.\n\n\t@default false\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.parseUrl('https://foo.bar?foo=bar#xyz', {parseFragmentIdentifier: true});\n\t//=> {url: 'https://foo.bar', query: {foo: 'bar'}, fragmentIdentifier: 'xyz'}\n\t```\n\t*/\n\treadonly parseFragmentIdentifier?: boolean;\n\n\t/**\n\tSpecify a pre-defined schema to be used when parsing values. The types specified will take precedence over options such as: `parseNumber`, `parseBooleans`, and `arrayFormat`.\n\n\tUse this feature to override the type of a value. This can be useful when the type is ambiguous such as a phone number (see example 1 and 2).\n\n\tIt is possible to provide a custom function as the parameter type. The parameter's value will equal the function's return value (see example 4).\n\n\tNOTE: Array types (`string[]` and `number[]`) will have no effect if `arrayFormat` is set to `none` (see example 5).\n\n\t@default {}\n\n\t@example\n\tParse `phoneNumber` as a string, overriding the `parseNumber` option:\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.parse('?phoneNumber=%2B380951234567&id=1', {\n\t\tparseNumbers: true,\n\t\ttypes: {\n\t\t\tphoneNumber: 'string',\n\t\t}\n\t});\n\t//=> {phoneNumber: '+380951234567', id: 1}\n\t```\n\n\t@example\n\tParse `items` as an array of strings, overriding the `parseNumber` option:\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.parse('?age=20&items=1%2C2%2C3', {\n\t\tparseNumber: true,\n\t\ttypes: {\n\t\t\titems: 'string[]',\n\t\t}\n\t});\n\t//=> {age: 20, items: ['1', '2', '3']}\n\t```\n\n\t@example\n\tParse `age` as a number, even when `parseNumber` is false:\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.parse('?age=20&id=01234&zipcode=90210', {\n\t\ttypes: {\n\t\t\tage: 'number',\n\t\t}\n\t});\n\t//=> {age: 20, id: '01234', zipcode: '90210 }\n\t```\n\n\t@example\n\tParse `age` using a custom value parser:\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.parse('?age=20&id=01234&zipcode=90210', {\n\t\ttypes: {\n\t\t\tage: (value) => value * 2,\n\t\t}\n\t});\n\t//=> {age: 40, id: '01234', zipcode: '90210 }\n\t```\n\n\t@example\n\tArray types will have no effect when `arrayFormat` is set to `none`\n\t```\n\tqueryString.parse('ids=001%2C002%2C003&foods=apple%2Corange%2Cmango', {\n\t\tarrayFormat: 'none',\n\t\ttypes: {\n\t\t\tids: 'number[]',\n\t\t\tfoods: 'string[]',\n\t\t},\n\t}\n\t//=> {ids:'001,002,003', foods:'apple,orange,mango'}\n\t```\n\n\t@example\n\tParse a query utilizing all types:\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.parse('?ids=001%2C002%2C003&items=1%2C2%2C3&price=22%2E00&numbers=1%2C2%2C3&double=5&number=20', {\n\t\tarrayFormat: 'comma',\n\t\ttypes: {\n\t\t\tids: 'string',\n\t\t\titems: 'string[]',\n\t\t\tprice: 'string',\n\t\t\tnumbers: 'number[]',\n\t\t\tdouble: (value) => value * 2,\n\t\t\tnumber: 'number',\n\t\t},\n\t});\n\t//=> {ids: '001,002,003', items: ['1', '2', '3'], price: '22.00', numbers: [1, 2, 3], double: 10, number: 20}\n\t```\n\t*/\n\treadonly types?: Record<\n\tstring,\n\t'number' | 'string' | 'string[]' | 'number[]' | ((value: string) => unknown)\n\t>;\n};\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type ParsedQuery<T = string> = Record<string, T | null | Array<T | null>>;\n\n/**\nParse a query string into an object. Leading `?` or `#` are ignored, so you can pass `location.search` or `location.hash` directly.\n\nThe returned object is created with [`Object.create(null)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) and thus does not have a `prototype`.\n\n@param query - The query string to parse.\n*/\nexport function parse(query: string, options: {parseBooleans: true; parseNumbers: true} & ParseOptions): ParsedQuery<string | boolean | number>;\nexport function parse(query: string, options: {parseBooleans: true} & ParseOptions): ParsedQuery<string | boolean>;\nexport function parse(query: string, options: {parseNumbers: true} & ParseOptions): ParsedQuery<string | number>;\nexport function parse(query: string, options?: ParseOptions): ParsedQuery;\n\nexport type ParsedUrl = {\n\treadonly url: string;\n\treadonly query: ParsedQuery;\n\n\t/**\n\tThe fragment identifier of the URL.\n\n\tPresent when the `parseFragmentIdentifier` option is `true`.\n\t*/\n\treadonly fragmentIdentifier?: string;\n};\n\n/**\nExtract the URL and the query string as an object.\n\nIf the `parseFragmentIdentifier` option is `true`, the object will also contain a `fragmentIdentifier` property.\n\n@param url - The URL to parse.\n\n@example\n```\nimport queryString from 'query-string';\n\nqueryString.parseUrl('https://foo.bar?foo=bar');\n//=> {url: 'https://foo.bar', query: {foo: 'bar'}}\n\nqueryString.parseUrl('https://foo.bar?foo=bar#xyz', {parseFragmentIdentifier: true});\n//=> {url: 'https://foo.bar', query: {foo: 'bar'}, fragmentIdentifier: 'xyz'}\n```\n*/\nexport function parseUrl(url: string, options?: ParseOptions): ParsedUrl;\n\nexport type StringifyOptions = {\n\t/**\n\tStrictly encode URI components. It uses [`encodeURIComponent`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) if set to `false`. You probably [don't care](https://github.com/sindresorhus/query-string/issues/42) about this option.\n\n\t@default true\n\t*/\n\treadonly strict?: boolean;\n\n\t/**\n\t[URL encode](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) the keys and values.\n\n\t@default true\n\t*/\n\treadonly encode?: boolean;\n\n\t/**\n\t@default 'none'\n\n\t- `bracket`: Serialize arrays using bracket representation:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'bracket'});\n\t\t//=> 'foo[]=1&foo[]=2&foo[]=3'\n\t\t```\n\n\t- `index`: Serialize arrays using index representation:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'index'});\n\t\t//=> 'foo[0]=1&foo[1]=2&foo[2]=3'\n\t\t```\n\n\t- `comma`: Serialize arrays by separating elements with comma:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'comma'});\n\t\t//=> 'foo=1,2,3'\n\n\t\tqueryString.stringify({foo: [1, null, '']}, {arrayFormat: 'comma'});\n\t\t//=> 'foo=1,,'\n\t\t// Note that typing information for null values is lost\n\t\t// and `.parse('foo=1,,')` would return `{foo: [1, '', '']}`.\n\t\t```\n\n\t- `separator`: Serialize arrays by separating elements with character:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'separator', arrayFormatSeparator: '|'});\n\t\t//=> 'foo=1|2|3'\n\t\t```\n\n\t- `bracket-separator`: Serialize arrays by explicitly post-fixing array names with brackets and separating elements with a custom character:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.stringify({foo: []}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> 'foo[]'\n\n\t\tqueryString.stringify({foo: ['']}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> 'foo[]='\n\n\t\tqueryString.stringify({foo: [1]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> 'foo[]=1'\n\n\t\tqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> 'foo[]=1|2|3'\n\n\t\tqueryString.stringify({foo: [1, '', 3, null, null, 6]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> 'foo[]=1||3|||6'\n\n\t\tqueryString.stringify({foo: [1, '', 3, null, null, 6]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|', skipNull: true});\n\t\t//=> 'foo[]=1||3|6'\n\n\t\tqueryString.stringify({foo: [1, 2, 3], bar: 'fluffy', baz: [4]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n\t\t//=> 'foo[]=1|2|3&bar=fluffy&baz[]=4'\n\t\t```\n\n\t- `colon-list-separator`: Serialize arrays with parameter names that are explicitly marked with `:list`:\n\n\t\t```js\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.stringify({foo: ['one', 'two']}, {arrayFormat: 'colon-list-separator'});\n\t\t//=> 'foo:list=one&foo:list=two'\n\t\t```\n\n\t- `none`: Serialize arrays by using duplicate keys:\n\n\t\t```\n\t\timport queryString from 'query-string';\n\n\t\tqueryString.stringify({foo: [1, 2, 3]});\n\t\t//=> 'foo=1&foo=2&foo=3'\n\t\t```\n\t*/\n\treadonly arrayFormat?: 'bracket' | 'index' | 'comma' | 'separator' | 'bracket-separator' | 'colon-list-separator' | 'none';\n\n\t/**\n\tThe character used to separate array elements when using `{arrayFormat: 'separator'}`.\n\n\t@default ,\n\t*/\n\treadonly arrayFormatSeparator?: string;\n\n\t/**\n\tSupports both `Function` as a custom sorting function or `false` to disable sorting.\n\n\tIf omitted, keys are sorted using `Array#sort`, which means, converting them to strings and comparing strings in Unicode code point order.\n\n\t@default true\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tconst order = ['c', 'a', 'b'];\n\n\tqueryString.stringify({a: 1, b: 2, c: 3}, {\n\t\tsort: (itemLeft, itemRight) => order.indexOf(itemLeft) - order.indexOf(itemRight)\n\t});\n\t//=> 'c=3&a=1&b=2'\n\t```\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.stringify({b: 1, c: 2, a: 3}, {sort: false});\n\t//=> 'b=1&c=2&a=3'\n\t```\n\t*/\n\treadonly sort?: ((itemLeft: string, itemRight: string) => number) | false;\n\n\t/**\n\tSkip keys with `null` as the value.\n\n\tNote that keys with `undefined` as the value are always skipped.\n\n\t@default false\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.stringify({a: 1, b: undefined, c: null, d: 4}, {\n\t\tskipNull: true\n\t});\n\t//=> 'a=1&d=4'\n\n\tqueryString.stringify({a: undefined, b: null}, {\n\t\tskipNull: true\n\t});\n\t//=> ''\n\t```\n\t*/\n\treadonly skipNull?: boolean;\n\n\t/**\n\tSkip keys with an empty string as the value.\n\n\t@default false\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.stringify({a: 1, b: '', c: '', d: 4}, {\n\t\tskipEmptyString: true\n\t});\n\t//=> 'a=1&d=4'\n\t```\n\n\t@example\n\t```\n\timport queryString from 'query-string';\n\n\tqueryString.stringify({a: '', b: ''}, {\n\t\tskipEmptyString: true\n\t});\n\t//=> ''\n\t```\n\t*/\n\treadonly skipEmptyString?: boolean;\n};\n\nexport type Stringifiable = string | boolean | number | bigint | null | undefined; // eslint-disable-line @typescript-eslint/ban-types\n\nexport type StringifiableRecord = Record<\nstring,\nStringifiable | readonly Stringifiable[]\n>;\n\n/**\nStringify an object into a query string and sort the keys.\n*/\nexport function stringify(\n\t// TODO: Use the below instead when the following TS issues are fixed:\n\t// - https://github.com/microsoft/TypeScript/issues/15300\n\t// - https://github.com/microsoft/TypeScript/issues/42021\n\t// Context: https://github.com/sindresorhus/query-string/issues/298\n\t// object: StringifiableRecord,\n\tobject: Record<string, any>,\n\toptions?: StringifyOptions\n): string;\n\n/**\nExtract a query string from a URL that can be passed into `.parse()`.\n\nNote: This behaviour can be changed with the `skipNull` option.\n*/\nexport function extract(url: string): string;\n\nexport type UrlObject = {\n\treadonly url: string;\n\n\t/**\n\tOverrides queries in the `url` property.\n\t*/\n\treadonly query?: StringifiableRecord;\n\n\t/**\n\tOverrides the fragment identifier in the `url` property.\n\t*/\n\treadonly fragmentIdentifier?: string;\n};\n\n/**\nStringify an object into a URL with a query string and sorting the keys. The inverse of [`.parseUrl()`](https://github.com/sindresorhus/query-string#parseurlstring-options)\n\nQuery items in the `query` property overrides queries in the `url` property.\n\nThe `fragmentIdentifier` property overrides the fragment identifier in the `url` property.\n\n@example\n```\nqueryString.stringifyUrl({url: 'https://foo.bar', query: {foo: 'bar'}});\n//=> 'https://foo.bar?foo=bar'\n\nqueryString.stringifyUrl({url: 'https://foo.bar?foo=baz', query: {foo: 'bar'}});\n//=> 'https://foo.bar?foo=bar'\n\nqueryString.stringifyUrl({\n\turl: 'https://foo.bar',\n\tquery: {\n\t\ttop: 'foo'\n\t},\n\tfragmentIdentifier: 'bar'\n});\n//=> 'https://foo.bar?top=foo#bar'\n```\n*/\nexport function stringifyUrl(\n\tobject: UrlObject,\n\toptions?: StringifyOptions\n): string;\n\n/**\nPick query parameters from a URL.\n\n@param url - The URL containing the query parameters to pick.\n@param keys - The names of the query parameters to keep. All other query parameters will be removed from the URL.\n@param filter - A filter predicate that will be provided the name of each query parameter and its value. The `parseNumbers` and `parseBooleans` options also affect `value`.\n\n@returns The URL with the picked query parameters.\n\n@example\n```\nqueryString.pick('https://foo.bar?foo=1&bar=2#hello', ['foo']);\n//=> 'https://foo.bar?foo=1#hello'\n\nqueryString.pick('https://foo.bar?foo=1&bar=2#hello', (name, value) => value === 2, {parseNumbers: true});\n//=> 'https://foo.bar?bar=2#hello'\n```\n*/\nexport function pick(\n\turl: string,\n\tkeys: readonly string[],\n\toptions?: ParseOptions & StringifyOptions\n): string;\nexport function pick(\n\turl: string,\n\tfilter: (key: string, value: string | boolean | number) => boolean,\n\toptions?: {parseBooleans: true; parseNumbers: true} & ParseOptions & StringifyOptions\n): string;\nexport function pick(\n\turl: string,\n\tfilter: (key: string, value: string | boolean) => boolean,\n\toptions?: {parseBooleans: true} & ParseOptions & StringifyOptions\n): string;\nexport function pick(\n\turl: string,\n\tfilter: (key: string, value: string | number) => boolean,\n\toptions?: {parseNumbers: true} & ParseOptions & StringifyOptions\n): string;\n\n/**\nExclude query parameters from a URL. Like `.pick()` but reversed.\n\n@param url - The URL containing the query parameters to exclude.\n@param keys - The names of the query parameters to remove. All other query parameters will remain in the URL.\n@param filter - A filter predicate that will be provided the name of each query parameter and its value. The `parseNumbers` and `parseBooleans` options also affect `value`.\n\n@returns The URL without the excluded the query parameters.\n\n@example\n```\nqueryString.exclude('https://foo.bar?foo=1&bar=2#hello', ['foo']);\n//=> 'https://foo.bar?bar=2#hello'\n\nqueryString.exclude('https://foo.bar?foo=1&bar=2#hello', (name, value) => value === 2, {parseNumbers: true});\n//=> 'https://foo.bar?foo=1#hello'\n```\n*/\nexport function exclude(\n\turl: string,\n\tkeys: readonly string[],\n\toptions?: ParseOptions & StringifyOptions\n): string;\nexport function exclude(\n\turl: string,\n\tfilter: (key: string, value: string | boolean | number) => boolean,\n\toptions?: {parseBooleans: true; parseNumbers: true} & ParseOptions & StringifyOptions\n): string;\nexport function exclude(\n\turl: string,\n\tfilter: (key: string, value: string | boolean) => boolean,\n\toptions?: {parseBooleans: true} & ParseOptions & StringifyOptions\n): string;\nexport function exclude(\n\turl: string,\n\tfilter: (key: string, value: string | number) => boolean,\n\toptions?: {parseNumbers: true} & ParseOptions & StringifyOptions\n): string;\n"
        },
        {
          "name": "base.js",
          "type": "blob",
          "size": 12.3642578125,
          "content": "import decodeComponent from 'decode-uri-component';\nimport {includeKeys} from 'filter-obj';\nimport splitOnFirst from 'split-on-first';\n\nconst isNullOrUndefined = value => value === null || value === undefined;\n\n// eslint-disable-next-line unicorn/prefer-code-point\nconst strictUriEncode = string => encodeURIComponent(string).replaceAll(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n\nconst encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index': {\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t...result, [encode(key, options), '[', index, ']'].join(''),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join(''),\n\t\t\t\t];\n\t\t\t};\n\t\t}\n\n\t\tcase 'bracket': {\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\t[encode(key, options), '[]'].join(''),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[]=', encode(value, options)].join(''),\n\t\t\t\t];\n\t\t\t};\n\t\t}\n\n\t\tcase 'colon-list-separator': {\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\t[encode(key, options), ':list='].join(''),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), ':list=', encode(value, options)].join(''),\n\t\t\t\t];\n\t\t\t};\n\t\t}\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\tcase 'bracket-separator': {\n\t\t\tconst keyValueSeparator = options.arrayFormat === 'bracket-separator'\n\t\t\t\t? '[]='\n\t\t\t\t: '=';\n\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// Translate null to an empty string so that it doesn't serialize as 'null'\n\t\t\t\tvalue = value === null ? '' : value;\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), keyValueSeparator, encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n\t\t\t};\n\t\t}\n\n\t\tdefault: {\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\tencode(key, options),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '=', encode(value, options)].join(''),\n\t\t\t\t];\n\t\t\t};\n\t\t}\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\t\t}\n\n\t\tcase 'bracket': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [...accumulator[key], value];\n\t\t\t};\n\t\t}\n\n\t\tcase 'colon-list-separator': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(:list)$/.exec(key);\n\t\t\t\tkey = key.replace(/:list$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [...accumulator[key], value];\n\t\t\t};\n\t\t}\n\n\t\tcase 'comma':\n\t\tcase 'separator': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);\n\t\t\t\tconst isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));\n\t\t\t\tvalue = isEncodedArray ? decode(value, options) : value;\n\t\t\t\tconst newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : (value === null ? value : decode(value, options));\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\t\t}\n\n\t\tcase 'bracket-separator': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = /(\\[])$/.test(key);\n\t\t\t\tkey = key.replace(/\\[]$/, '');\n\n\t\t\t\tif (!isArray) {\n\t\t\t\t\taccumulator[key] = value ? decode(value, options) : value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst arrayValue = value === null\n\t\t\t\t\t? []\n\t\t\t\t\t: decode(value, options).split(options.arrayFormatSeparator);\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = arrayValue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [...accumulator[key], ...arrayValue];\n\t\t\t};\n\t\t}\n\n\t\tdefault: {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [...[accumulator[key]].flat(), value];\n\t\t\t};\n\t\t}\n\t}\n}\n\nfunction validateArrayFormatSeparator(value) {\n\tif (typeof value !== 'string' || value.length !== 1) {\n\t\tthrow new TypeError('arrayFormatSeparator must be single character string');\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction parseValue(value, options, type) {\n\tif (type === 'string' && typeof value === 'string') {\n\t\treturn value;\n\t}\n\n\tif (typeof type === 'function' && typeof value === 'string') {\n\t\treturn type(value);\n\t}\n\n\tif (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\treturn value.toLowerCase() === 'true';\n\t}\n\n\tif (type === 'number' && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\treturn Number(value);\n\t}\n\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\treturn Number(value);\n\t}\n\n\treturn value;\n}\n\nexport function extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nexport function parse(query, options) {\n\toptions = {\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false,\n\t\ttypes: Object.create(null),\n\t\t...options,\n\t};\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst returnValue = Object.create(null);\n\n\tif (typeof query !== 'string') {\n\t\treturn returnValue;\n\t}\n\n\tquery = query.trim().replace(/^[?#&]/, '');\n\n\tif (!query) {\n\t\treturn returnValue;\n\t}\n\n\tfor (const parameter of query.split('&')) {\n\t\tif (parameter === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parameter_ = options.decode ? parameter.replaceAll('+', ' ') : parameter;\n\n\t\tlet [key, value] = splitOnFirst(parameter_, '=');\n\n\t\tif (key === undefined) {\n\t\t\tkey = parameter_;\n\t\t}\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : (['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options));\n\t\tformatter(decode(key, options), value, returnValue);\n\t}\n\n\tfor (const [key, value] of Object.entries(returnValue)) {\n\t\tif (typeof value === 'object' && value !== null && options.types[key] !== 'string') {\n\t\t\tfor (const [key2, value2] of Object.entries(value)) {\n\t\t\t\tconst type = options.types[key] ? options.types[key].replace('[]', '') : undefined;\n\t\t\t\tvalue[key2] = parseValue(value2, options, type);\n\t\t\t}\n\t\t} else if (typeof value === 'object' && value !== null && options.types[key] === 'string') {\n\t\t\treturnValue[key] = Object.values(value).join(options.arrayFormatSeparator);\n\t\t} else {\n\t\t\treturnValue[key] = parseValue(value, options, options.types[key]);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn returnValue;\n\t}\n\n\t// TODO: Remove the use of `reduce`.\n\t// eslint-disable-next-line unicorn/no-array-reduce\n\treturn (options.sort === true ? Object.keys(returnValue).sort() : Object.keys(returnValue).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = returnValue[key];\n\t\tresult[key] = Boolean(value) && typeof value === 'object' && !Array.isArray(value) ? keysSorter(value) : value;\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexport function stringify(object, options) {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\t...options,\n\t};\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst shouldFilter = key => (\n\t\t(options.skipNull && isNullOrUndefined(object[key]))\n\t\t|| (options.skipEmptyString && object[key] === '')\n\t);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = {};\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tif (!shouldFilter(key)) {\n\t\t\tobjectCopy[key] = value;\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\tif (value.length === 0 && options.arrayFormat === 'bracket-separator') {\n\t\t\t\treturn encode(key, options) + '[]';\n\t\t\t}\n\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n}\n\nexport function parseUrl(url, options) {\n\toptions = {\n\t\tdecode: true,\n\t\t...options,\n\t};\n\n\tlet [url_, hash] = splitOnFirst(url, '#');\n\n\tif (url_ === undefined) {\n\t\turl_ = url;\n\t}\n\n\treturn {\n\t\turl: url_?.split('?')?.[0] ?? '',\n\t\tquery: parse(extract(url), options),\n\t\t...(options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}),\n\t};\n}\n\nexport function stringifyUrl(object, options) {\n\toptions = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\t[encodeFragmentIdentifier]: true,\n\t\t...options,\n\t};\n\n\tconst url = removeHash(object.url).split('?')[0] || '';\n\tconst queryFromUrl = extract(object.url);\n\n\tconst query = {\n\t\t...parse(queryFromUrl, {sort: false}),\n\t\t...object.query,\n\t};\n\n\tlet queryString = stringify(query, options);\n\tqueryString &&= `?${queryString}`;\n\n\tlet hash = getHash(object.url);\n\tif (typeof object.fragmentIdentifier === 'string') {\n\t\tconst urlObjectForFragmentEncode = new URL(url);\n\t\turlObjectForFragmentEncode.hash = object.fragmentIdentifier;\n\t\thash = options[encodeFragmentIdentifier] ? urlObjectForFragmentEncode.hash : `#${object.fragmentIdentifier}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n}\n\nexport function pick(input, filter, options) {\n\toptions = {\n\t\tparseFragmentIdentifier: true,\n\t\t[encodeFragmentIdentifier]: false,\n\t\t...options,\n\t};\n\n\tconst {url, query, fragmentIdentifier} = parseUrl(input, options);\n\n\treturn stringifyUrl({\n\t\turl,\n\t\tquery: includeKeys(query, filter),\n\t\tfragmentIdentifier,\n\t}, options);\n}\n\nexport function exclude(input, filter, options) {\n\tconst exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);\n\n\treturn pick(input, exclusionFilter, options);\n}\n"
        },
        {
          "name": "benchmark.js",
          "type": "blob",
          "size": 2.6181640625,
          "content": "import Benchmark from 'benchmark';\nimport queryString from './index.js';\n\nconst {stringify, stringifyUrl} = queryString;\nconst suite = new Benchmark.Suite();\n\n// Fixtures\nconst TEST_OBJECT = {\n\tgenre: 'Epic fantasy',\n\tauthor: '',\n\tpage: 2,\n\tpublished: true,\n\tsymbols: 'πµ',\n\tchapters: [1, 2, 3],\n\tnone: null,\n};\nconst TEST_HOST = 'https://foo.bar/';\nconst TEST_STRING = stringify(TEST_OBJECT);\nconst TEST_BRACKETS_STRING = stringify(TEST_OBJECT, {arrayFormat: 'bracket'});\nconst TEST_INDEX_STRING = stringify(TEST_OBJECT, {arrayFormat: 'index'});\nconst TEST_COMMA_STRING = stringify(TEST_OBJECT, {arrayFormat: 'comma'});\nconst TEST_BRACKET_SEPARATOR_STRING = stringify(TEST_OBJECT, {arrayFormat: 'bracket-separator'});\nconst TEST_URL = stringifyUrl({url: TEST_HOST, query: TEST_OBJECT});\n\n// Creates a test case and adds it to the suite\nconst defineTestCase = (methodName, input, options) => {\n\tconst function_ = queryString[methodName];\n\tconst label = options ? ` (${stringify(options)})` : '';\n\n\tsuite.add(methodName + label, () => function_(input, options || {}));\n};\n\n// Define all test cases\n\n// Parse\ndefineTestCase('parse', TEST_STRING);\ndefineTestCase('parse', TEST_STRING, {parseNumbers: true});\ndefineTestCase('parse', TEST_STRING, {parseBooleans: true});\ndefineTestCase('parse', TEST_STRING, {sort: false});\ndefineTestCase('parse', TEST_STRING, {decode: false});\ndefineTestCase('parse', TEST_BRACKETS_STRING, {arrayFormat: 'bracket'});\ndefineTestCase('parse', TEST_INDEX_STRING, {arrayFormat: 'index'});\ndefineTestCase('parse', TEST_COMMA_STRING, {arrayFormat: 'comma'});\ndefineTestCase('parse', TEST_BRACKET_SEPARATOR_STRING, {arrayFormat: 'bracket-separator'});\n\n// Stringify\ndefineTestCase('stringify', TEST_OBJECT);\ndefineTestCase('stringify', TEST_OBJECT, {strict: false});\ndefineTestCase('stringify', TEST_OBJECT, {encode: false});\ndefineTestCase('stringify', TEST_OBJECT, {skipNull: true});\ndefineTestCase('stringify', TEST_OBJECT, {skipEmptyString: true});\ndefineTestCase('stringify', TEST_OBJECT, {arrayFormat: 'bracket'});\ndefineTestCase('stringify', TEST_OBJECT, {arrayFormat: 'index'});\ndefineTestCase('stringify', TEST_OBJECT, {arrayFormat: 'comma'});\ndefineTestCase('stringify', TEST_OBJECT, {arrayFormat: 'bracket-separator'});\n\n// Extract\ndefineTestCase('extract', TEST_URL);\n\n// ParseUrl\ndefineTestCase('parseUrl', TEST_URL);\n\n// StringifyUrl\ndefineTestCase('stringifyUrl', {url: TEST_HOST, query: TEST_OBJECT});\n\n// Log/display the results\nsuite.on('cycle', event => {\n\tconst {name, hz} = event.target;\n\tconst opsPerSec = Math.round(hz).toLocaleString();\n\n\tconsole.log(name.padEnd(46, '_') + opsPerSec.padStart(3, '_') + ' ops/s');\n});\n\nsuite.run();\n"
        },
        {
          "name": "index.d.ts",
          "type": "blob",
          "size": 0.3193359375,
          "content": "/// export * as default from './base.js';\n\n// Workaround for TS missing feature.\nimport * as queryString from './base.js';\n\nexport default queryString;\n\nexport {\n\ttype ParseOptions,\n\ttype ParsedQuery,\n\ttype ParsedUrl,\n\ttype StringifyOptions,\n\ttype Stringifiable,\n\ttype StringifiableRecord,\n\ttype UrlObject,\n} from './base.js';\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 0.0693359375,
          "content": "import * as queryString from './base.js';\n\nexport default queryString;\n"
        },
        {
          "name": "index.test-d.ts",
          "type": "blob",
          "size": 3.546875,
          "content": "import {expectType} from 'tsd';\nimport queryString from './index.js';\n\n// Stringify\nexpectType<string>(\n\tqueryString.stringify({\n\t\tstr: 'bar',\n\t\tstrArray: ['baz'],\n\t\tnum: 123,\n\t\tnumArray: [456],\n\t\tbool: true,\n\t\tboolArray: [false],\n\t}),\n);\n\nexpectType<string>(queryString.stringify({foo: 'bar'}, {strict: false}));\nexpectType<string>(queryString.stringify({foo: 'bar'}, {encode: false}));\nexpectType<string>(\n\tqueryString.stringify({foo: 'bar'}, {arrayFormat: 'bracket'}),\n);\nexpectType<string>(queryString.stringify({foo: 'bar'}, {arrayFormat: 'index'}));\nexpectType<string>(queryString.stringify({foo: 'bar'}, {arrayFormat: 'none'}));\nexpectType<string>(queryString.stringify({foo: 'bar'}, {arrayFormat: 'comma'}));\nexpectType<string>(queryString.stringify({foo: 'bar'}, {sort: false}));\nexpectType<string>(queryString.stringify({foo: 'bar'}, {skipNull: true}));\nexpectType<string>(queryString.stringify({foo: 'bar'}, {skipEmptyString: true}));\nconst order = ['c', 'a', 'b'];\nexpectType<string>(\n\tqueryString.stringify(\n\t\t{foo: 'bar'},\n\t\t{\n\t\t\tsort: (itemLeft, itemRight) =>\n\t\t\t\torder.indexOf(itemLeft) - order.indexOf(itemRight),\n\t\t},\n\t),\n);\n\n// Ensure it accepts an `interface`.\ntype Query = {\n\tfoo: string;\n};\n\nconst query: Query = {\n\tfoo: 'bar',\n};\n\nqueryString.stringify(query);\n\n// Parse\nexpectType<queryString.ParsedQuery>(queryString.parse('?foo=bar'));\n\nexpectType<queryString.ParsedQuery>(\n\tqueryString.parse('?foo=bar', {decode: false}),\n);\nexpectType<queryString.ParsedQuery>(\n\tqueryString.parse('?foo=bar', {arrayFormat: 'bracket'}),\n);\nexpectType<queryString.ParsedQuery>(\n\tqueryString.parse('?foo=bar', {arrayFormat: 'index'}),\n);\nexpectType<queryString.ParsedQuery>(\n\tqueryString.parse('?foo=bar', {arrayFormat: 'none'}),\n);\nexpectType<queryString.ParsedQuery>(\n\tqueryString.parse('?foo=bar', {arrayFormat: 'comma'}),\n);\nexpectType<queryString.ParsedQuery<string | number>>(\n\tqueryString.parse('?foo=1', {parseNumbers: true}),\n);\nexpectType<queryString.ParsedQuery<string | boolean>>(\n\tqueryString.parse('?foo=true', {parseBooleans: true}),\n);\nexpectType<queryString.ParsedQuery<string | boolean | number>>(\n\tqueryString.parse('?foo=true', {parseBooleans: true, parseNumbers: true}),\n);\n\n// Parse URL\nexpectType<queryString.ParsedUrl>(queryString.parseUrl('?foo=bar'));\n\nexpectType<queryString.ParsedUrl>(\n\tqueryString.parseUrl('?foo=bar', {decode: false}),\n);\nexpectType<queryString.ParsedUrl>(\n\tqueryString.parseUrl('?foo=bar', {arrayFormat: 'bracket'}),\n);\nexpectType<queryString.ParsedUrl>(\n\tqueryString.parseUrl('?foo=bar', {arrayFormat: 'index'}),\n);\nexpectType<queryString.ParsedUrl>(\n\tqueryString.parseUrl('?foo=bar', {arrayFormat: 'none'}),\n);\nexpectType<queryString.ParsedUrl>(\n\tqueryString.parseUrl('?foo=bar', {arrayFormat: 'comma'}),\n);\nexpectType<queryString.ParsedUrl>(\n\tqueryString.parseUrl('?foo=1', {parseNumbers: true}),\n);\nexpectType<queryString.ParsedUrl>(\n\tqueryString.parseUrl('?foo=true', {parseBooleans: true}),\n);\nexpectType<queryString.ParsedUrl>(\n\tqueryString.parseUrl('?foo=true#bar', {parseFragmentIdentifier: true}),\n);\n\n// Extract\nexpectType<string>(queryString.extract('http://foo.bar/?abc=def&hij=klm'));\n\nexpectType<string>(\n\tqueryString.stringifyUrl({\n\t\turl: 'https://sindresorhus.com',\n\t\tquery: {\n\t\t\tfooMixedArray: [\n\t\t\t\t'a',\n\t\t\t\t1,\n\t\t\t\ttrue,\n\t\t\t\tnull,\n\t\t\t\tundefined,\n\t\t\t],\n\t\t\tfooNumber: 1,\n\t\t\tfooBoolean: true,\n\t\t\tfooNull: null,\n\t\t\tfooUndefined: undefined,\n\t\t\tfooString: 'hi',\n\t\t},\n\t}),\n);\n\n// Pick\nexpectType<string>(queryString.pick('http://foo.bar/?abc=def&hij=klm', ['abc']));\n\n// Exclude\nexpectType<string>(queryString.exclude('http://foo.bar/?abc=def&hij=klm', ['abc']));\n"
        },
        {
          "name": "license",
          "type": "blob",
          "size": 1.0908203125,
          "content": "MIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.150390625,
          "content": "{\n\t\"name\": \"query-string\",\n\t\"version\": \"9.1.1\",\n\t\"description\": \"Parse and stringify URL query strings\",\n\t\"license\": \"MIT\",\n\t\"repository\": \"sindresorhus/query-string\",\n\t\"funding\": \"https://github.com/sponsors/sindresorhus\",\n\t\"author\": {\n\t\t\"name\": \"Sindre Sorhus\",\n\t\t\"email\": \"sindresorhus@gmail.com\",\n\t\t\"url\": \"https://sindresorhus.com\"\n\t},\n\t\"type\": \"module\",\n\t\"exports\": {\n\t\t\"types\": \"./index.d.ts\",\n\t\t\"default\": \"./index.js\"\n\t},\n\t\"sideEffects\": false,\n\t\"engines\": {\n\t\t\"node\": \">=18\"\n\t},\n\t\"scripts\": {\n\t\t\"benchmark\": \"node benchmark.js\",\n\t\t\"test\": \"xo && ava && tsd\"\n\t},\n\t\"files\": [\n\t\t\"index.js\",\n\t\t\"index.d.ts\",\n\t\t\"base.js\",\n\t\t\"base.d.ts\"\n\t],\n\t\"keywords\": [\n\t\t\"browser\",\n\t\t\"querystring\",\n\t\t\"query\",\n\t\t\"string\",\n\t\t\"qs\",\n\t\t\"param\",\n\t\t\"parameter\",\n\t\t\"url\",\n\t\t\"parse\",\n\t\t\"stringify\",\n\t\t\"encode\",\n\t\t\"decode\",\n\t\t\"searchparams\",\n\t\t\"filter\"\n\t],\n\t\"dependencies\": {\n\t\t\"decode-uri-component\": \"^0.4.1\",\n\t\t\"filter-obj\": \"^5.1.0\",\n\t\t\"split-on-first\": \"^3.0.0\"\n\t},\n\t\"devDependencies\": {\n\t\t\"ava\": \"^6.1.1\",\n\t\t\"benchmark\": \"^2.1.4\",\n\t\t\"deep-equal\": \"^2.2.3\",\n\t\t\"fast-check\": \"^3.15.1\",\n\t\t\"tsd\": \"^0.30.7\",\n\t\t\"xo\": \"^0.57.0\"\n\t},\n\t\"tsd\": {\n\t\t\"compilerOptions\": {\n\t\t\t\"module\": \"node16\"\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 16.5673828125,
          "content": "# query-string\n\n> Parse and stringify URL [query strings](https://en.wikipedia.org/wiki/Query_string)\n\n## Install\n\n```sh\nnpm install query-string\n```\n\n> [!WARNING]\n> Remember the hyphen! Do not install the deprecated [`querystring`](https://github.com/Gozala/querystring) package!\n\nFor browser usage, this package targets the latest version of Chrome, Firefox, and Safari.\n\n## Usage\n\n```js\nimport queryString from 'query-string';\n\nconsole.log(location.search);\n//=> '?foo=bar'\n\nconst parsed = queryString.parse(location.search);\nconsole.log(parsed);\n//=> {foo: 'bar'}\n\nconsole.log(location.hash);\n//=> '#token=bada55cafe'\n\nconst parsedHash = queryString.parse(location.hash);\nconsole.log(parsedHash);\n//=> {token: 'bada55cafe'}\n\nparsed.foo = 'unicorn';\nparsed.ilike = 'pizza';\n\nconst stringified = queryString.stringify(parsed);\n//=> 'foo=unicorn&ilike=pizza'\n\nlocation.search = stringified;\n// note that `location.search` automatically prepends a question mark\nconsole.log(location.search);\n//=> '?foo=unicorn&ilike=pizza'\n```\n\n## API\n\n### .parse(string, options?)\n\nParse a query string into an object. Leading `?` or `#` are ignored, so you can pass `location.search` or `location.hash` directly.\n\nThe returned object is created with [`Object.create(null)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) and thus does not have a `prototype`.\n\n#### options\n\nType: `object`\n\n##### decode\n\nType: `boolean`\\\nDefault: `true`\n\nDecode the keys and values. URL components are decoded with [`decode-uri-component`](https://github.com/SamVerschueren/decode-uri-component).\n\n##### arrayFormat\n\nType: `string`\\\nDefault: `'none'`\n\n- `'bracket'`: Parse arrays with bracket representation:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('foo[]=1&foo[]=2&foo[]=3', {arrayFormat: 'bracket'});\n//=> {foo: ['1', '2', '3']}\n```\n\n- `'index'`: Parse arrays with index representation:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('foo[0]=1&foo[1]=2&foo[3]=3', {arrayFormat: 'index'});\n//=> {foo: ['1', '2', '3']}\n```\n\n- `'comma'`: Parse arrays with elements separated by comma:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('foo=1,2,3', {arrayFormat: 'comma'});\n//=> {foo: ['1', '2', '3']}\n```\n\n- `'separator'`: Parse arrays with elements separated by a custom character:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('foo=1|2|3', {arrayFormat: 'separator', arrayFormatSeparator: '|'});\n//=> {foo: ['1', '2', '3']}\n```\n\n- `'bracket-separator'`: Parse arrays (that are explicitly marked with brackets) with elements separated by a custom character:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('foo[]', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> {foo: []}\n\nqueryString.parse('foo[]=', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> {foo: ['']}\n\nqueryString.parse('foo[]=1', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> {foo: ['1']}\n\nqueryString.parse('foo[]=1|2|3', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> {foo: ['1', '2', '3']}\n\nqueryString.parse('foo[]=1||3|||6', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> {foo: ['1', '', 3, '', '', '6']}\n\nqueryString.parse('foo[]=1|2|3&bar=fluffy&baz[]=4', {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> {foo: ['1', '2', '3'], bar: 'fluffy', baz:['4']}\n```\n\n- `'colon-list-separator'`: Parse arrays with parameter names that are explicitly marked with `:list`:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('foo:list=one&foo:list=two', {arrayFormat: 'colon-list-separator'});\n//=> {foo: ['one', 'two']}\n```\n\n- `'none'`: Parse arrays with elements using duplicate keys:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('foo=1&foo=2&foo=3');\n//=> {foo: ['1', '2', '3']}\n```\n\n##### arrayFormatSeparator\n\nType: `string`\\\nDefault: `','`\n\nThe character used to separate array elements when using `{arrayFormat: 'separator'}`.\n\n##### sort\n\nType: `Function | boolean`\\\nDefault: `true`\n\nSupports both `Function` as a custom sorting function or `false` to disable sorting.\n\n##### parseNumbers\n\nType: `boolean`\\\nDefault: `false`\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('foo=1', {parseNumbers: true});\n//=> {foo: 1}\n```\n\nParse the value as a number type instead of string type if it's a number.\n\n##### parseBooleans\n\nType: `boolean`\\\nDefault: `false`\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('foo=true', {parseBooleans: true});\n//=> {foo: true}\n```\n\nParse the value as a boolean type instead of string type if it's a boolean.\n\n##### types\n\nType: `object`\\\nDefault: `{}`\n\nSpecify a pre-defined schema to be used when parsing values. The types specified will take precedence over options such as: `parseNumbers`, `parseBooleans`, and `arrayFormat`.\n\nUse this feature to override the type of a value. This can be useful when the type is ambiguous such as a phone number.\n\nIt is possible to provide a custom function as the parameter type. The parameter's value will equal the function's return value.\n\nSupported Types:\n\n- `'string'`: Parse `phoneNumber` as a string (overriding the `parseNumbers` option):\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('?phoneNumber=%2B380951234567&id=1', {\n\tparseNumbers: true,\n\ttypes: {\n\t\tphoneNumber: 'string',\n\t}\n});\n//=> {phoneNumber: '+380951234567', id: 1}\n```\n\n- `'number'`:  Parse `age` as a number (even when `parseNumbers` is false):\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('?age=20&id=01234&zipcode=90210', {\n\ttypes: {\n\t\tage: 'number',\n\t}\n});\n//=> {age: 20, id: '01234', zipcode: '90210 }\n```\n\n- `'string[]'`:  Parse `items` as an array of strings (overriding the `parseNumbers` option):\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('?age=20&items=1%2C2%2C3', {\n\tparseNumbers: true,\n\ttypes: {\n\t\titems: 'string[]',\n\t}\n});\n//=> {age: 20, items: ['1', '2', '3']}\n```\n\n- `'number[]'`:  Parse `items` as an array of numbers (even when `parseNumbers` is false):\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('?age=20&items=1%2C2%2C3', {\n\ttypes: {\n\t\titems: 'number[]',\n\t}\n});\n//=> {age: '20', items: [1, 2, 3]}\n```\n\n- `'Function'`: Provide a custom function as the parameter type. The parameter's value will equal the function's return value.\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('?age=20&id=01234&zipcode=90210', {\n\ttypes: {\n\t\tage: (value) => value * 2,\n\t}\n});\n//=> {age: 40, id: '01234', zipcode: '90210 }\n```\n\nNOTE: Array types (`string[]` and `number[]`) will have no effect if `arrayFormat` is set to `none`.\n\n```js\nqueryString.parse('ids=001%2C002%2C003&foods=apple%2Corange%2Cmango', {\n\tarrayFormat: 'none',\n\ttypes: {\n\t\tids: 'number[]',\n\t\tfoods: 'string[]',\n\t},\n}\n//=> {ids:'001,002,003', foods:'apple,orange,mango'}\n```\n\n###### Function\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('?age=20&id=01234&zipcode=90210', {\n\ttypes: {\n\t\tage: (value) => value * 2,\n\t}\n});\n//=> {age: 40, id: '01234', zipcode: '90210 }\n```\n\nParse the value as a boolean type instead of string type if it's a boolean.\n\n### .stringify(object, options?)\n\nStringify an object into a query string and sorting the keys.\n\n#### options\n\nType: `object`\n\n##### strict\n\nType: `boolean`\\\nDefault: `true`\n\nStrictly encode URI components. It uses [encodeURIComponent](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) if set to false. You probably [don't care](https://github.com/sindresorhus/query-string/issues/42) about this option.\n\n##### encode\n\nType: `boolean`\\\nDefault: `true`\n\n[URL encode](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) the keys and values.\n\n##### arrayFormat\n\nType: `string`\\\nDefault: `'none'`\n\n- `'bracket'`: Serialize arrays using bracket representation:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'bracket'});\n//=> 'foo[]=1&foo[]=2&foo[]=3'\n```\n\n- `'index'`: Serialize arrays using index representation:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'index'});\n//=> 'foo[0]=1&foo[1]=2&foo[2]=3'\n```\n\n- `'comma'`: Serialize arrays by separating elements with comma:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'comma'});\n//=> 'foo=1,2,3'\n\nqueryString.stringify({foo: [1, null, '']}, {arrayFormat: 'comma'});\n//=> 'foo=1,,'\n// Note that typing information for null values is lost\n// and `.parse('foo=1,,')` would return `{foo: [1, '', '']}`.\n```\n\n- `'separator'`: Serialize arrays by separating elements with a custom character:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'separator', arrayFormatSeparator: '|'});\n//=> 'foo=1|2|3'\n```\n\n- `'bracket-separator'`: Serialize arrays by explicitly post-fixing array names with brackets and separating elements with a custom character:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({foo: []}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> 'foo[]'\n\nqueryString.stringify({foo: ['']}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> 'foo[]='\n\nqueryString.stringify({foo: [1]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> 'foo[]=1'\n\nqueryString.stringify({foo: [1, 2, 3]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> 'foo[]=1|2|3'\n\nqueryString.stringify({foo: [1, '', 3, null, null, 6]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> 'foo[]=1||3|||6'\n\nqueryString.stringify({foo: [1, '', 3, null, null, 6]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|', skipNull: true});\n//=> 'foo[]=1||3|6'\n\nqueryString.stringify({foo: [1, 2, 3], bar: 'fluffy', baz: [4]}, {arrayFormat: 'bracket-separator', arrayFormatSeparator: '|'});\n//=> 'foo[]=1|2|3&bar=fluffy&baz[]=4'\n```\n\n- `'colon-list-separator'`: Serialize arrays with parameter names that are explicitly marked with `:list`:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({foo: ['one', 'two']}, {arrayFormat: 'colon-list-separator'});\n//=> 'foo:list=one&foo:list=two'\n```\n\n- `'none'`: Serialize arrays by using duplicate keys:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({foo: [1, 2, 3]});\n//=> 'foo=1&foo=2&foo=3'\n```\n\n##### arrayFormatSeparator\n\nType: `string`\\\nDefault: `','`\n\nThe character used to separate array elements when using `{arrayFormat: 'separator'}`.\n\n##### sort\n\nType: `Function | boolean`\n\nSupports both `Function` as a custom sorting function or `false` to disable sorting.\n\n```js\nimport queryString from 'query-string';\n\nconst order = ['c', 'a', 'b'];\n\nqueryString.stringify({a: 1, b: 2, c: 3}, {\n\tsort: (a, b) => order.indexOf(a) - order.indexOf(b)\n});\n//=> 'c=3&a=1&b=2'\n```\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({b: 1, c: 2, a: 3}, {sort: false});\n//=> 'b=1&c=2&a=3'\n```\n\nIf omitted, keys are sorted using `Array#sort()`, which means, converting them to strings and comparing strings in Unicode code point order.\n\n##### skipNull\n\nSkip keys with `null` as the value.\n\nNote that keys with `undefined` as the value are always skipped.\n\nType: `boolean`\\\nDefault: `false`\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({a: 1, b: undefined, c: null, d: 4}, {\n\tskipNull: true\n});\n//=> 'a=1&d=4'\n```\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({a: undefined, b: null}, {\n\tskipNull: true\n});\n//=> ''\n```\n\n##### skipEmptyString\n\nSkip keys with an empty string as the value.\n\nType: `boolean`\\\nDefault: `false`\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({a: 1, b: '', c: '', d: 4}, {\n\tskipEmptyString: true\n});\n//=> 'a=1&d=4'\n```\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({a: '', b: ''}, {\n\tskipEmptyString: true\n});\n//=> ''\n```\n\n### .extract(string)\n\nExtract a query string from a URL that can be passed into `.parse()`.\n\nNote: This behaviour can be changed with the `skipNull` option.\n\n### .parseUrl(string, options?)\n\nExtract the URL and the query string as an object.\n\nReturns an object with a `url` and `query` property.\n\nIf the `parseFragmentIdentifier` option is `true`, the object will also contain a `fragmentIdentifier` property.\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parseUrl('https://foo.bar?foo=bar');\n//=> {url: 'https://foo.bar', query: {foo: 'bar'}}\n\nqueryString.parseUrl('https://foo.bar?foo=bar#xyz', {parseFragmentIdentifier: true});\n//=> {url: 'https://foo.bar', query: {foo: 'bar'}, fragmentIdentifier: 'xyz'}\n```\n\n#### options\n\nType: `object`\n\nThe options are the same as for `.parse()`.\n\nExtra options are as below.\n\n##### parseFragmentIdentifier\n\nParse the fragment identifier from the URL.\n\nType: `boolean`\\\nDefault: `false`\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parseUrl('https://foo.bar?foo=bar#xyz', {parseFragmentIdentifier: true});\n//=> {url: 'https://foo.bar', query: {foo: 'bar'}, fragmentIdentifier: 'xyz'}\n```\n\n### .stringifyUrl(object, options?)\n\nStringify an object into a URL with a query string and sorting the keys. The inverse of [`.parseUrl()`](https://github.com/sindresorhus/query-string#parseurlstring-options)\n\nThe `options` are the same as for `.stringify()`.\n\nReturns a string with the URL and a query string.\n\nQuery items in the `query` property overrides queries in the `url` property.\n\nThe `fragmentIdentifier` property overrides the fragment identifier in the `url` property.\n\n```js\nqueryString.stringifyUrl({url: 'https://foo.bar', query: {foo: 'bar'}});\n//=> 'https://foo.bar?foo=bar'\n\nqueryString.stringifyUrl({url: 'https://foo.bar?foo=baz', query: {foo: 'bar'}});\n//=> 'https://foo.bar?foo=bar'\n\nqueryString.stringifyUrl({\n\turl: 'https://foo.bar',\n\tquery: {\n\t\ttop: 'foo'\n\t},\n\tfragmentIdentifier: 'bar'\n});\n//=> 'https://foo.bar?top=foo#bar'\n```\n\n#### object\n\nType: `object`\n\n##### url\n\nType: `string`\n\nThe URL to stringify.\n\n##### query\n\nType: `object`\n\nQuery items to add to the URL.\n\n### .pick(url, keys, options?)\n### .pick(url, filter, options?)\n\nPick query parameters from a URL.\n\nReturns a string with the new URL.\n\n```js\nimport queryString from 'query-string';\n\nqueryString.pick('https://foo.bar?foo=1&bar=2#hello', ['foo']);\n//=> 'https://foo.bar?foo=1#hello'\n\nqueryString.pick('https://foo.bar?foo=1&bar=2#hello', (name, value) => value === 2, {parseNumbers: true});\n//=> 'https://foo.bar?bar=2#hello'\n```\n\n### .exclude(url, keys, options?)\n### .exclude(url, filter, options?)\n\nExclude query parameters from a URL.\n\nReturns a string with the new URL.\n\n```js\nimport queryString from 'query-string';\n\nqueryString.exclude('https://foo.bar?foo=1&bar=2#hello', ['foo']);\n//=> 'https://foo.bar?bar=2#hello'\n\nqueryString.exclude('https://foo.bar?foo=1&bar=2#hello', (name, value) => value === 2, {parseNumbers: true});\n//=> 'https://foo.bar?foo=1#hello'\n```\n\n#### url\n\nType: `string`\n\nThe URL containing the query parameters to filter.\n\n#### keys\n\nType: `string[]`\n\nThe names of the query parameters to filter based on the function used.\n\n#### filter\n\nType: `(key, value) => boolean`\n\nA filter predicate that will be provided the name of each query parameter and its value. The `parseNumbers` and `parseBooleans` options also affect `value`.\n\n#### options\n\nType: `object`\n\n[Parse options](#options) and [stringify options](#options-1).\n\n## Nesting\n\nThis module intentionally doesn't support nesting as it's not spec'd and varies between implementations, which causes a lot of [edge cases](https://github.com/visionmedia/node-querystring/issues).\n\nYou're much better off just converting the object to a JSON string:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({\n\tfoo: 'bar',\n\tnested: JSON.stringify({\n\t\tunicorn: 'cake'\n\t})\n});\n//=> 'foo=bar&nested=%7B%22unicorn%22%3A%22cake%22%7D'\n```\n\nHowever, there is support for multiple instances of the same key:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.parse('likes=cake&name=bob&likes=icecream');\n//=> {likes: ['cake', 'icecream'], name: 'bob'}\n\nqueryString.stringify({color: ['taupe', 'chartreuse'], id: '515'});\n//=> 'color=taupe&color=chartreuse&id=515'\n```\n\n## Falsy values\n\nSometimes you want to unset a key, or maybe just make it present without assigning a value to it. Here is how falsy values are stringified:\n\n```js\nimport queryString from 'query-string';\n\nqueryString.stringify({foo: false});\n//=> 'foo=false'\n\nqueryString.stringify({foo: null});\n//=> 'foo'\n\nqueryString.stringify({foo: undefined});\n//=> ''\n```\n\n## FAQ\n\n### Why is it parsing `+` as a space?\n\nSee [this answer](https://github.com/sindresorhus/query-string/issues/305).\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}