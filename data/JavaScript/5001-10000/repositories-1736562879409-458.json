{
  "metadata": {
    "timestamp": 1736562879409,
    "page": 458,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mafintosh/peerflix",
      "stars": 6199,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": "torrents\nnode_modules\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1044921875,
          "content": "sudo: false\nlanguage: node_js\nnode_js:\n  - \"6\"\n  - \"5\"\n  - \"4\"\n  - \"0.12\"\n  - \"0.11\"\n  - \"0.10\"\n  - \"iojs\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0615234375,
          "content": "Copyright (C) 2013 Mathias Buus Madsen <mathiasbuus@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.9580078125,
          "content": "# peerflix\n\nStreaming torrent client for Node.js\n\n```\nnpm install -g peerflix\n```\n\n[![build status](http://img.shields.io/travis/mafintosh/peerflix.svg?style=flat)](http://travis-ci.org/mafintosh/peerflix)\n\n## Usage\n\nPeerflix can be used with a magnet link or a torrent file.\nTo stream a video with its magnet link use the following command.\n\n```\npeerflix \"magnet:?xt=urn:btih:ef330b39f4801d25b4245212e75a38634bfc856e\" --vlc\n```\n\nRemember to put `\"` around your magnet link since they usually contain `&`.\n`peerflix` will print a terminal interface. The first line contains an address to a http server. The `--vlc` flag ensures vlc is opened when the torrent is ready to stream.\n\n![peerflix](https://raw.github.com/mafintosh/peerflix/master/screenshot.png)\n\nTo stream music with a torrent file use the following command.\n\n```\npeerflix \"http://some-torrent/music.torrent\" -a --vlc\n```\n\nThe `-a` flag ensures that all files in the music repository are played with vlc.\nOtherwise if the torrent contains multiple files, `peerflix` will choose the biggest one.\nTo get a full list of available options run peerflix with the help flag.\n\n```\npeerflix --help\n```\n\nExamples of usage of could be\n\n```\npeerflix magnet-link --list # Select from a list of files to download\npeerflix magnet-link --vlc -- --fullscreen # will pass --fullscreen to vlc\npeerflix magnet-link --mplayer --subtitles subtitle-file.srt # play in mplayer with subtitles\npeerflix magnet-link --connection 200 # set max connection to 200\n```\n\n\n## Programmatic usage\n\nIf you want to build your own app using streaming bittorrent in Node you should checkout [torrent-stream](https://github.com/mafintosh/torrent-stream)\n\n## Chromebook users\n\nChromebooks are set to refuse all incoming connections by default - to change this:  \n\n```\nsudo iptables -P INPUT ACCEPT\n```\n\n## Chromecast\n\nIf you wanna use peerflix on your chromecast checkout [peercast](https://github.com/mafintosh/peercast)\nor [castnow](https://github.com/xat/castnow)\n\n## License\n\nMIT\n"
        },
        {
          "name": "app.js",
          "type": "blob",
          "size": 16.673828125,
          "content": "#!/usr/bin/env node\n\nvar optimist = require('optimist')\nvar rc = require('rc')\nvar clivas = require('clivas')\nvar numeral = require('numeral')\nvar os = require('os')\nvar address = require('network-address')\nvar proc = require('child_process')\nvar peerflix = require('./')\nvar keypress = require('keypress')\nvar openUrl = require('open')\nvar inquirer = require('inquirer')\nvar parsetorrent = require('parse-torrent')\nvar bufferFrom = require('buffer-from')\n\nvar path = require('path')\n\nprocess.title = 'peerflix'\n\nvar argv = rc('peerflix', {}, optimist\n  .usage('Usage: $0 magnet-link-or-torrent [options]')\n  .alias('c', 'connections').describe('c', 'max connected peers').default('c', os.cpus().length > 1 ? 100 : 30)\n  .alias('p', 'port').describe('p', 'change the http port').default('p', 8888)\n  .alias('i', 'index').describe('i', 'changed streamed file (index)')\n  .alias('l', 'list').describe('l', 'list available files with corresponding index').boolean('l')\n  .alias('t', 'subtitles').describe('t', 'load subtitles file')\n  .alias('q', 'quiet').describe('q', 'be quiet').boolean('v')\n  .alias('v', 'vlc').describe('v', 'autoplay in vlc*').boolean('v')\n  .alias('s', 'airplay').describe('s', 'autoplay via AirPlay').boolean('a')\n  .alias('m', 'mplayer').describe('m', 'autoplay in mplayer*').boolean('m')\n  .alias('g', 'smplayer').describe('g', 'autoplay in smplayer*').boolean('g')\n  .describe('mpchc', 'autoplay in MPC-HC player*').boolean('boolean')\n  .describe('potplayer', 'autoplay in Potplayer*').boolean('boolean')\n  .alias('k', 'mpv').describe('k', 'autoplay in mpv*').boolean('k')\n  .alias('o', 'omx').describe('o', 'autoplay in omx**').boolean('o')\n  .alias('w', 'webplay').describe('w', 'autoplay in webplay').boolean('w')\n  .alias('j', 'jack').describe('j', 'autoplay in omx** using the audio jack').boolean('j')\n  .alias('f', 'path').describe('f', 'change buffer file path')\n  .alias('b', 'blocklist').describe('b', 'use the specified blocklist')\n  .alias('n', 'no-quit').describe('n', 'do not quit peerflix on vlc exit').boolean('n')\n  .alias('a', 'all').describe('a', 'select all files in the torrent').boolean('a')\n  .alias('r', 'remove').describe('r', 'remove files on exit').boolean('r')\n  .alias('h', 'hostname').describe('h', 'host name or IP to bind the server to')\n  .alias('e', 'peer').describe('e', 'add peer by ip:port')\n  .alias('x', 'peer-port').describe('x', 'set peer listening port')\n  .alias('d', 'not-on-top').describe('d', 'do not float video on top').boolean('d')\n  .describe('on-downloaded', 'script to call when file is 100% downloaded')\n  .describe('on-listening', 'script to call when server goes live')\n  .describe('version', 'prints current version').boolean('boolean')\n  .argv)\n\nif (argv.version) {\n  console.error(require('./package').version)\n  process.exit(0)\n}\n\nvar filename = argv._[0]\nvar onTop = !argv.d\n\nif (!filename) {\n  optimist.showHelp()\n  console.error('Options passed after -- will be passed to your player')\n  console.error('')\n  console.error('  \"peerflix magnet-link --vlc -- --fullscreen\" will pass --fullscreen to vlc')\n  console.error('')\n  console.error('* Autoplay can take several seconds to start since it needs to wait for the first piece')\n  console.error('** OMX player is the default Raspbian video player\\n')\n  process.exit(1)\n}\n\nvar VLC_ARGS = '-q' + (onTop ? ' --video-on-top' : '') + ' --play-and-exit'\nvar OMX_EXEC = argv.jack ? 'omxplayer -r -o local ' : 'omxplayer -r -o hdmi '\nvar MPLAYER_EXEC = 'mplayer ' + (onTop ? '-ontop' : '') + ' -really-quiet -noidx -loop 0 '\nvar SMPLAYER_EXEC = 'smplayer ' + (onTop ? '-ontop' : '')\nvar MPV_EXEC = 'mpv ' + (onTop ? '--ontop' : '') + ' --really-quiet --loop=no '\nvar MPC_HC_ARGS = '/play'\nvar POTPLAYER_ARGS = ''\n\nvar enc = function (s) {\n  return /\\s/.test(s) ? JSON.stringify(s) : s\n}\n\nif (argv.t) {\n  VLC_ARGS += ' --sub-file=' + (process.platform === 'win32' ? argv.t : enc(argv.t))\n  OMX_EXEC += ' --subtitles ' + enc(argv.t)\n  MPLAYER_EXEC += ' -sub ' + enc(argv.t)\n  SMPLAYER_EXEC += ' -sub ' + enc(argv.t)\n  MPV_EXEC += ' --sub-file=' + enc(argv.t)\n  POTPLAYER_ARGS += ' ' + enc(argv.t)\n}\n\nif (argv._.length > 1) {\n  var _args = argv._\n  _args.shift()\n  var playerArgs = _args.join(' ')\n  VLC_ARGS += ' ' + playerArgs\n  OMX_EXEC += ' ' + playerArgs\n  MPLAYER_EXEC += ' ' + playerArgs\n  SMPLAYER_EXEC += ' ' + playerArgs\n  MPV_EXEC += ' ' + playerArgs\n  MPC_HC_ARGS += ' ' + playerArgs\n  POTPLAYER_ARGS += ' ' + playerArgs\n}\n\nvar watchVerifying = function (engine) {\n  var showVerifying = function (i) {\n    var percentage = Math.round(((i + 1) / engine.torrent.pieces.length) * 100.0)\n    clivas.clear()\n    clivas.line('{yellow:Verifying downloaded:} ' + percentage + '%')\n  }\n\n  var startShowVerifying = function () {\n    showVerifying(-1)\n    engine.on('verify', showVerifying)\n  }\n\n  var stopShowVerifying = function () {\n    clivas.clear()\n    engine.removeListener('verify', showVerifying)\n    engine.removeListener('verifying', startShowVerifying)\n  }\n\n  engine.on('verifying', startShowVerifying)\n  engine.on('ready', stopShowVerifying)\n}\n\nvar ontorrent = function (torrent) {\n  if (argv['peer-port']) argv.peerPort = Number(argv['peer-port'])\n\n  var engine = peerflix(torrent, argv)\n  var hotswaps = 0\n  var verified = 0\n  var invalid = 0\n  var airplayServer = null\n  var downloadedPercentage = 0\n\n  engine.on('verify', function () {\n    verified++\n    downloadedPercentage = Math.floor(verified / engine.torrent.pieces.length * 100)\n  })\n\n  engine.on('invalid-piece', function () {\n    invalid++\n  })\n\n  var bytes = function (num) {\n    return numeral(num).format('0.0b')\n  }\n\n  if (argv.list) {\n    var interactive = process.stdout.isTTY && process.stdin.isTTY && !!process.stdin.setRawMode\n\n    var onready = function () {\n      if (interactive) {\n        var filenamesInOriginalOrder = engine.files.map(file => file.path)\n        inquirer.prompt([{\n          type: 'list',\n          name: 'file',\n          message: 'Choose one file',\n          choices: Array.from(engine.files)\n            .sort((file1, file2) => file1.path.localeCompare(file2.path))\n            .map(function (file, i) {\n              return {\n                name: file.name + ' : ' + bytes(file.length),\n                value: filenamesInOriginalOrder.indexOf(file.path)\n              }\n            })\n        }]).then(function (answers) {\n          argv.index = answers.file\n          delete argv.list\n          ontorrent(torrent)\n        })\n      } else {\n        engine.files.forEach(function (file, i, files) {\n          clivas.line('{3+bold:' + i + '} : {magenta:' + file.name + '} : {blue:' + bytes(file.length) + '}')\n        })\n        process.exit(0)\n      }\n    }\n\n    if (engine.torrent) onready()\n    else {\n      watchVerifying(engine)\n      engine.on('ready', onready)\n    }\n    return\n  }\n\n  engine.on('hotswap', function () {\n    hotswaps++\n  })\n\n  var started = Date.now()\n  var wires = engine.swarm.wires\n  var swarm = engine.swarm\n\n  var active = function (wire) {\n    return !wire.peerChoking\n  }\n\n  var peers = [].concat(argv.peer || [])\n  peers.forEach(function (peer) {\n    engine.connect(peer)\n  })\n\n  if (argv['on-downloaded']) {\n    var downloaded = false\n    engine.on('uninterested', function () {\n      if (!downloaded) proc.exec(argv['on-downloaded'])\n      downloaded = true\n    })\n  }\n\n  engine.server.on('listening', function () {\n    var host = argv.hostname || address()\n    var href = 'http://' + host + ':' + engine.server.address().port + '/'\n    var localHref = 'http://localhost:' + engine.server.address().port + '/'\n    var filename = engine.server.index.name.split('/').pop().replace(/\\{|\\}/g, '')\n    var filelength = engine.server.index.length\n    var player = null\n    var paused = false\n    var timePaused = 0\n    var pausedAt = null\n\n    VLC_ARGS += ' --meta-title=\"' + filename.replace(/\"/g, '\\\\\"') + '\"'\n\n    if (argv.all) {\n      filename = engine.torrent.name\n      filelength = engine.torrent.length\n      href += '.m3u'\n      localHref += '.m3u'\n    }\n\n    var registry = function (hive, key, name, cb) {\n      var Registry = require('winreg')\n      var regKey = new Registry({\n        hive: Registry[hive],\n        key: key\n      })\n      regKey.get(name, cb)\n    }\n\n    if (argv.vlc && process.platform === 'win32') {\n      player = 'vlc'\n      var runVLC = function (regItem) {\n        VLC_ARGS = VLC_ARGS.split(' ')\n        VLC_ARGS.unshift(localHref)\n        proc.execFile(regItem.value + path.sep + 'vlc.exe', VLC_ARGS)\n      }\n      registry('HKLM', '\\\\Software\\\\VideoLAN\\\\VLC', 'InstallDir', function (err, regItem) {\n        if (err) {\n          registry('HKLM', '\\\\Software\\\\WOW6432Node\\\\VideoLAN\\\\VLC', 'InstallDir', function (err, regItem) {\n            if (err) return\n            runVLC(regItem)\n          })\n        } else {\n          runVLC(regItem)\n        }\n      })\n    } else if (argv.mpchc && process.platform === 'win32') {\n      player = 'mph-hc'\n      registry('HKCU', '\\\\Software\\\\MPC-HC\\\\MPC-HC', 'ExePath', function (err, regItem) {\n        if (err) return\n        proc.exec('\"' + regItem.value + '\" \"' + localHref + '\" ' + MPC_HC_ARGS)\n      })\n    } else if (argv.potplayer && process.platform === 'win32') {\n      player = 'potplayer'\n      var runPotPlayer = function (regItem) {\n        proc.exec('\"' + regItem.value + '\" \"' + localHref + '\" ' + POTPLAYER_ARGS)\n      }\n      registry('HKCU', '\\\\Software\\\\DAUM\\\\PotPlayer64', 'ProgramPath', function (err, regItem) {\n        if (err) {\n          registry('HKCU', '\\\\Software\\\\DAUM\\\\PotPlayer', 'ProgramPath', function (err, regItem) {\n            if (err) return\n            runPotPlayer(regItem)\n          })\n        } else {\n          runPotPlayer(regItem)\n        }\n      })\n    } else {\n      if (argv.vlc) {\n        player = 'vlc'\n        var root = '/Applications/VLC.app/Contents/MacOS/VLC'\n        var home = (process.env.HOME || '') + root\n        var vlc = proc.exec('vlc ' + VLC_ARGS + ' ' + localHref + ' || ' + root + ' ' + VLC_ARGS + ' ' + localHref + ' || ' + home + ' ' + VLC_ARGS + ' ' + localHref, function (error, stdout, stderror) {\n          if (error) {\n            process.exit(0)\n          }\n        })\n\n        vlc.on('exit', function () {\n          if (!argv.n && argv.quit !== false) process.exit(0)\n        })\n      }\n    }\n\n    if (argv.omx) {\n      player = 'omx'\n      var omx = proc.exec(OMX_EXEC + ' ' + localHref)\n      omx.on('exit', function () {\n        if (!argv.n && argv.quit !== false) process.exit(0)\n      })\n    }\n    if (argv.mplayer) {\n      player = 'mplayer'\n      var mplayer = proc.exec(MPLAYER_EXEC + ' ' + localHref)\n      mplayer.on('exit', function () {\n        if (!argv.n && argv.quit !== false) process.exit(0)\n      })\n    }\n    if (argv.smplayer) {\n      player = 'smplayer'\n      var smplayer = proc.exec(SMPLAYER_EXEC + ' ' + localHref)\n      smplayer.on('exit', function () {\n        if (!argv.n && argv.quit !== false) process.exit(0)\n      })\n    }\n    if (argv.mpv) {\n      player = 'mpv'\n      var mpv = proc.exec(MPV_EXEC + ' ' + localHref)\n      mpv.on('exit', function () {\n        if (!argv.n && argv.quit !== false) process.exit(0)\n      })\n    }\n    if (argv.webplay) {\n      player = 'webplay'\n      openUrl('https://85d514b3e548d934d8ff7c45a54732e65a3162fe.htmlb.in/#' + localHref)\n    }\n    if (argv.airplay) {\n      var list = require('airplayer')()\n      list.once('update', function (player) {\n        airplayServer = player\n        list.destroy()\n        player.play(href)\n      })\n    }\n\n    if (argv['on-listening']) proc.exec(argv['on-listening'] + ' ' + href)\n\n    if (argv.quiet) return console.log('server is listening on ' + href)\n\n    process.stdout.write(bufferFrom('G1tIG1sySg==', 'base64')) // clear for drawing\n\n    var interactive = !player && process.stdin.isTTY && !!process.stdin.setRawMode\n\n    if (interactive) {\n      keypress(process.stdin)\n      process.stdin.on('keypress', function (ch, key) {\n        if (!key) return\n        if (key.name === 'c' && key.ctrl === true) return process.kill(process.pid, 'SIGINT')\n        if (key.name === 'l' && key.ctrl === true) {\n          var command = 'xdg-open'\n          if (process.platform === 'win32') { command = 'explorer' }\n          if (process.platform === 'darwin') { command = 'open' }\n\n          return proc.exec(command + ' ' + engine.path)\n        }\n        if (key.name !== 'space') return\n\n        if (player) return\n        if (paused === false) {\n          if (!argv.all) {\n            engine.server.index.deselect()\n          } else {\n            engine.files.forEach(function (file) {\n              file.deselect()\n            })\n          }\n          paused = true\n          pausedAt = Date.now()\n          draw()\n          return\n        }\n\n        if (!argv.all) {\n          engine.server.index.select()\n        } else {\n          engine.files.forEach(function (file) {\n            file.select()\n          })\n        }\n\n        paused = false\n        timePaused += Date.now() - pausedAt\n        draw()\n      })\n      process.stdin.setRawMode(true)\n    }\n\n    var draw = function () {\n      var unchoked = engine.swarm.wires.filter(active)\n      var timeCurrentPause = 0\n      if (paused === true) {\n        timeCurrentPause = Date.now() - pausedAt\n      }\n      var runtime = Math.floor((Date.now() - started - timePaused - timeCurrentPause) / 1000)\n      var linesremaining = clivas.height\n      var peerslisted = 0\n\n      clivas.clear()\n      if (argv.airplay) {\n        if (airplayServer) clivas.line('{green:streaming to} {bold:' + airplayServer.name + '} {green:using airplay}')\n        else clivas.line('{green:streaming} {green:using airplay}')\n      } else {\n        clivas.line('{green:open} {bold:' + (player || 'vlc') + '} {green:and enter} {bold:' + href + '} {green:as the network address}')\n      }\n      clivas.line('')\n      clivas.line('{yellow:info} {green:streaming} {bold:' + filename + ' (' + bytes(filelength) + ')} {green:-} {bold:' + bytes(swarm.downloadSpeed()) + '/s} {green:from} {bold:' + unchoked.length + '/' + wires.length + '} {green:peers}    ')\n      clivas.line('{yellow:info} {green:path} {cyan:' + engine.path + '}')\n      clivas.line('{yellow:info} {green:downloaded} {bold:' + bytes(swarm.downloaded) + '} (' + downloadedPercentage + '%) {green:and uploaded }{bold:' + bytes(swarm.uploaded) + '} {green:in }{bold:' + runtime + 's} {green:with} {bold:' + hotswaps + '} {green:hotswaps}     ')\n      clivas.line('{yellow:info} {green:verified} {bold:' + verified + '} {green:pieces and received} {bold:' + invalid + '} {green:invalid pieces}')\n      clivas.line('{yellow:info} {green:peer queue size is} {bold:' + swarm.queued + '}')\n      clivas.line('{80:}')\n\n      if (interactive) {\n        var openLoc = ' or CTRL+L to open download location}'\n        if (paused) clivas.line('{yellow:PAUSED} {green:Press SPACE to continue download' + openLoc)\n        else clivas.line('{50+green:Press SPACE to pause download' + openLoc)\n      }\n\n      clivas.line('')\n      linesremaining -= 9\n\n      wires.every(function (wire) {\n        var tags = []\n        if (wire.peerChoking) tags.push('choked')\n        clivas.line('{25+magenta:' + wire.peerAddress + '} {10:' + bytes(wire.downloaded) + '} {10 + cyan:' + bytes(wire.downloadSpeed()) + '/s} {15 + grey:' + tags.join(', ') + '}   ')\n        peerslisted++\n        return linesremaining - peerslisted > 4\n      })\n      linesremaining -= peerslisted\n\n      if (wires.length > peerslisted) {\n        clivas.line('{80:}')\n        clivas.line('... and ' + (wires.length - peerslisted) + ' more     ')\n      }\n\n      clivas.line('{80:}')\n      clivas.flush()\n    }\n\n    setInterval(draw, 500)\n    draw()\n  })\n\n  engine.server.once('error', function () {\n    engine.server.listen(0, argv.hostname)\n  })\n\n  var onmagnet = function () {\n    clivas.clear()\n    clivas.line('{green:fetching torrent metadata from} {bold:' + engine.swarm.wires.length + '} {green:peers}')\n  }\n\n  if (typeof torrent === 'string' && torrent.indexOf('magnet:') === 0 && !argv.quiet) {\n    onmagnet()\n    engine.swarm.on('wire', onmagnet)\n  }\n\n  engine.on('ready', function () {\n    engine.swarm.removeListener('wire', onmagnet)\n    if (!argv.all) return\n    engine.files.forEach(function (file) {\n      file.select()\n    })\n  })\n\n  var onexit = function () {\n    // we're doing some heavy lifting so it can take some time to exit... let's\n    // better output a status message so the user knows we're working on it :)\n    clivas.line('')\n    clivas.line('{yellow:info} {green:peerflix is exiting...}')\n  }\n\n  watchVerifying(engine)\n\n  if (argv.remove) {\n    var remove = function () {\n      onexit()\n      engine.remove(function () {\n        process.exit()\n      })\n    }\n\n    process.on('SIGINT', remove)\n    process.on('SIGTERM', remove)\n  } else {\n    process.on('SIGINT', function () {\n      onexit()\n      process.exit()\n    })\n  }\n}\n\nparsetorrent.remote(filename, function (err, parsedtorrent) {\n  if (err) {\n    console.error(err.message)\n    process.exit(1)\n  }\n  ontorrent(parsedtorrent)\n})\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 6.0009765625,
          "content": "var torrentStream = require('torrent-stream')\nvar http = require('http')\nvar fs = require('fs')\nvar rangeParser = require('range-parser')\nvar xtend = require('xtend')\nvar url = require('url')\nvar mime = require('mime')\nvar pump = require('pump')\n\nvar parseBlocklist = function (filename) {\n  // TODO: support gzipped files\n  var blocklistData = fs.readFileSync(filename, { encoding: 'utf8' })\n  var blocklist = []\n  blocklistData.split('\\n').forEach(function (line) {\n    var match = null\n    if ((match = /^\\s*[^#].*?\\s*:\\s*([a-f0-9.:]+?)\\s*-\\s*([a-f0-9.:]+?)\\s*$/.exec(line))) {\n      blocklist.push({\n        start: match[1],\n        end: match[2]\n      })\n    }\n  })\n  return blocklist\n}\n\nvar truthy = function () {\n  return true\n}\n\nvar createServer = function (e, opts) {\n  var server = http.createServer()\n  var index = opts.index\n  var getType = opts.type || mime.getType.bind(mime)\n  var filter = opts.filter || truthy\n\n  var onready = function () {\n    if (typeof index !== 'number') {\n      index = e.files.reduce(function (a, b) {\n        return a.length > b.length ? a : b\n      })\n      index = e.files.indexOf(index)\n    }\n\n    e.files[index].select()\n    server.index = e.files[index]\n\n    if (opts.sort) e.files.sort(opts.sort)\n  }\n\n  if (e.torrent) onready()\n  else e.on('ready', onready)\n\n  server.on('request', function (request, response) {\n    var u = url.parse(request.url)\n    var host = request.headers.host || 'localhost'\n\n    var toPlaylist = function () {\n      var toEntry = function (file, i) {\n        return '#EXTINF:-1,' + file.path + '\\n' + 'http://' + host + '/' + i\n      }\n\n      return '#EXTM3U\\n' + e.files.filter(filter).map(toEntry).join('\\n')\n    }\n\n    var toJSON = function () {\n      var totalPeers = e.swarm.wires\n\n      var activePeers = totalPeers.filter(function (wire) {\n        return !wire.peerChoking\n      })\n\n      var totalLength = e.files.reduce(function (prevFileLength, currFile) {\n        return prevFileLength + currFile.length\n      }, 0)\n\n      var toEntry = function (file, i) {\n        return {\n          name: file.name,\n          url: 'http://' + host + '/' + i,\n          length: file.length\n        }\n      }\n\n      var swarmStats = {\n        totalLength: totalLength,\n        downloaded: e.swarm.downloaded,\n        uploaded: e.swarm.uploaded,\n        downloadSpeed: parseInt(e.swarm.downloadSpeed(), 10),\n        uploadSpeed: parseInt(e.swarm.uploadSpeed(), 10),\n        totalPeers: totalPeers.length,\n        activePeers: activePeers.length,\n        files: e.files.filter(filter).map(toEntry)\n      }\n\n      return JSON.stringify(swarmStats, null, '  ')\n    }\n\n    // Allow CORS requests to specify arbitrary headers, e.g. 'Range',\n    // by responding to the OPTIONS preflight request with the specified\n    // origin and requested headers.\n    if (request.method === 'OPTIONS' && request.headers['access-control-request-headers']) {\n      response.setHeader('Access-Control-Allow-Origin', request.headers.origin)\n      response.setHeader('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')\n      response.setHeader(\n          'Access-Control-Allow-Headers',\n          request.headers['access-control-request-headers'])\n      response.setHeader('Access-Control-Max-Age', '1728000')\n\n      response.end()\n      return\n    }\n\n    if (request.headers.origin) response.setHeader('Access-Control-Allow-Origin', request.headers.origin)\n    if (u.pathname === '/') u.pathname = '/' + index\n\n    if (u.pathname === '/favicon.ico') {\n      response.statusCode = 404\n      response.end()\n      return\n    }\n\n    if (u.pathname === '/.json') {\n      var json = toJSON()\n      response.setHeader('Content-Type', 'application/json; charset=utf-8')\n      response.setHeader('Content-Length', Buffer.byteLength(json))\n      response.end(json)\n      return\n    }\n\n    if (u.pathname === '/.m3u') {\n      var playlist = toPlaylist()\n      response.setHeader('Content-Type', 'application/x-mpegurl; charset=utf-8')\n      response.setHeader('Content-Length', Buffer.byteLength(playlist))\n      response.end(playlist)\n      return\n    }\n\n    e.files.forEach(function (file, i) {\n      if (u.pathname.slice(1) === file.name) u.pathname = '/' + i\n    })\n\n    var i = Number(u.pathname.slice(1))\n\n    if (isNaN(i) || i >= e.files.length) {\n      response.statusCode = 404\n      response.end()\n      return\n    }\n\n    var file = e.files[i]\n    var range = request.headers.range\n    range = range && rangeParser(file.length, range)[0]\n    response.setHeader('Accept-Ranges', 'bytes')\n    response.setHeader('Content-Type', getType(file.name))\n    response.setHeader('transferMode.dlna.org', 'Streaming')\n    response.setHeader('contentFeatures.dlna.org', 'DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01700000000000000000000000000000')\n    if (!range) {\n      response.setHeader('Content-Length', file.length)\n      if (request.method === 'HEAD') return response.end()\n      pump(file.createReadStream(), response)\n      return\n    }\n\n    response.statusCode = 206\n    response.setHeader('Content-Length', range.end - range.start + 1)\n    response.setHeader('Content-Range', 'bytes ' + range.start + '-' + range.end + '/' + file.length)\n    if (request.method === 'HEAD') return response.end()\n    pump(file.createReadStream(range), response)\n  })\n\n  server.on('connection', function (socket) {\n    socket.setTimeout(36000000)\n  })\n\n  return server\n}\n\nmodule.exports = function (torrent, opts) {\n  if (!opts) opts = {}\n\n  // Parse blocklist\n  if (opts.blocklist) opts.blocklist = parseBlocklist(opts.blocklist)\n\n  var engine = torrentStream(torrent, xtend(opts, {port: opts.peerPort}))\n\n  // Just want torrent-stream to list files.\n  if (opts.list) return engine\n\n  // Pause/Resume downloading as needed\n  engine.on('uninterested', function () {\n    engine.swarm.pause()\n  })\n\n  engine.on('interested', function () {\n    engine.swarm.resume()\n  })\n\n  engine.server = createServer(engine, opts)\n\n  // Listen when torrent-stream is ready, by default a random port.\n  engine.on('ready', function () {\n    engine.server.listen(opts.port || 0, opts.hostname)\n  })\n\n  engine.listen()\n\n  return engine\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.05078125,
          "content": "{\n  \"name\": \"peerflix\",\n  \"description\": \"Streaming torrent client for Node.js\",\n  \"version\": \"0.39.0\",\n  \"author\": \"Mathias Buus (@mafintosh)\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://github.com/mafintosh/peerflix\",\n  \"main\": \"index.js\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mafintosh/peerflix/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/mafintosh/peerflix.git\"\n  },\n  \"bin\": {\n    \"peerflix\": \"./app.js\"\n  },\n  \"dependencies\": {\n    \"airplayer\": \"^2.0.0\",\n    \"buffer-from\": \"^1.0.0\",\n    \"clivas\": \"^0.2.0\",\n    \"inquirer\": \"^5.0.1\",\n    \"keypress\": \"^0.2.1\",\n    \"mime\": \"^2.2.0\",\n    \"network-address\": \"^1.1.0\",\n    \"numeral\": \"^2.0.6\",\n    \"open\": \"0.0.5\",\n    \"optimist\": \"^0.6.1\",\n    \"parse-torrent\": \"^5.4.0\",\n    \"pump\": \"^2.0.0\",\n    \"range-parser\": \"^1.0.0\",\n    \"rc\": \"^1.1.6\",\n    \"torrent-stream\": \"^1.0.1\",\n    \"winreg\": \"1.2.4\",\n    \"xtend\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^10.0.3\"\n  },\n  \"optionalDependencies\": {\n    \"airplayer\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"standard\"\n  }\n}\n"
        },
        {
          "name": "screenshot.png",
          "type": "blob",
          "size": 27.3193359375,
          "content": null
        }
      ]
    }
  ]
}