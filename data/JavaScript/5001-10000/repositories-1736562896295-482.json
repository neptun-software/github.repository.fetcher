{
  "metadata": {
    "timestamp": 1736562896295,
    "page": 482,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "instantpage/instant.page",
      "stars": 6099,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0185546875,
          "content": "instantpage.min.js\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.041015625,
          "content": "Copyright (C) 2019-2024 Alexandre Dieulot\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.5263671875,
          "content": "# instant.page\n\n**Make your site’s pages instant in 1 minute and improve your conversion rate by 1%.**\n\n:information_source: Info is on [the website](https://instant.page).\n\n:scroll: The source is in [instantpage.js](https://github.com/instantpage/instant.page/blob/master/instantpage.js).\n\n## Tests\n\nWith [Node](https://nodejs.org/), run:\n\n`node test`\n\nAnd access http://127.0.0.1:8000/. Or specify another port with an argument after the filename.\n\n## Minifying\n\nTo minify instantpage.js into instantpage.min.js, run `npm run minify`.\n"
        },
        {
          "name": "instantpage.js",
          "type": "blob",
          "size": 16.314453125,
          "content": "/*! instant.page v5.2.0 - (C) 2019-2024 Alexandre Dieulot - https://instant.page/license */\n\nlet _chromiumMajorVersionInUserAgent = null\n  , _speculationRulesType\n  , _allowQueryString\n  , _allowExternalLinks\n  , _useWhitelist\n  , _delayOnHover = 65\n  , _lastTouchstartEvent\n  , _mouseoverTimer\n  , _preloadedList = new Set()\n\ninit()\n\nfunction init() {\n  const supportCheckRelList = document.createElement('link').relList\n  const isSupported = supportCheckRelList.supports('prefetch')\n    && supportCheckRelList.supports('modulepreload')\n  // instant.page is meant to be loaded with <script type=module>\n  // (though sometimes webmasters load it as a regular script).\n  // So it’s normally executed (and must not cause JavaScript errors) in:\n  // - Chromium 61+\n  // - Gecko in Firefox 60+\n  // - WebKit in Safari 10.1+ (iOS 10.3+, macOS 10.10+)\n  //\n  // The check above used to check for IntersectionObserverEntry.isIntersecting\n  // but module scripts support implies this compatibility — except in Safari\n  // 10.1–12.0, but this prefetch check takes care of it.\n  //\n  // The modulepreload check is used to drop support for Firefox < 115 in order\n  // to lessen maintenance.\n  // This implies Safari 17+ (if it supported prefetch), if we ever support\n  // fetch()-based preloading for Safari we might want to OR that check with\n  // something that Safari 15.4 or 16.4 supports.\n  // Also implies Chromium 66+.\n\n  if (!isSupported) {\n    return\n  }\n\n  const handleVaryAcceptHeader = 'instantVaryAccept' in document.body.dataset || 'Shopify' in window\n  // The `Vary: Accept` header when received in Chromium 79–109 makes prefetches\n  // unusable, as Chromium used to send a different `Accept` header.\n  // It’s applied on all Shopify sites by default, as Shopify is very popular\n  // and is the main source of this problem.\n  // `window.Shopify` only exists on “classic” Shopify sites. Those using\n  // Hydrogen (Remix SPA) aren’t concerned.\n\n  const chromiumUserAgentIndex = navigator.userAgent.indexOf('Chrome/')\n  if (chromiumUserAgentIndex > -1) {\n    _chromiumMajorVersionInUserAgent = parseInt(navigator.userAgent.substring(chromiumUserAgentIndex + 'Chrome/'.length))\n  }\n  // The user agent client hints API is a theoretically more reliable way to\n  // get Chromium’s version… but it’s not available in Samsung Internet 20.\n  // It also requires a secure context, which would make debugging harder,\n  // and is only available in recent Chromium versions.\n  // In practice, Chromium browsers never shy from announcing \"Chrome\" in\n  // their regular user agent string, as that maximizes their compatibility.\n\n  if (handleVaryAcceptHeader && _chromiumMajorVersionInUserAgent && _chromiumMajorVersionInUserAgent < 110) {\n    return\n  }\n\n  _speculationRulesType = 'none'\n  if (HTMLScriptElement.supports && HTMLScriptElement.supports('speculationrules')) {\n    const speculationRulesConfig = document.body.dataset.instantSpecrules\n    if (speculationRulesConfig == 'prerender') {\n      _speculationRulesType = 'prerender'\n    } else if (speculationRulesConfig != 'no') {\n      _speculationRulesType = 'prefetch'\n    }\n  }\n\n  const useMousedownShortcut = 'instantMousedownShortcut' in document.body.dataset\n  _allowQueryString = 'instantAllowQueryString' in document.body.dataset\n  _allowExternalLinks = 'instantAllowExternalLinks' in document.body.dataset\n  _useWhitelist = 'instantWhitelist' in document.body.dataset\n\n  let preloadOnMousedown = false\n  let preloadOnlyOnMousedown = false\n  let preloadWhenVisible = false\n  if ('instantIntensity' in document.body.dataset) {\n    const intensityParameter = document.body.dataset.instantIntensity\n\n    if (intensityParameter == 'mousedown' && !useMousedownShortcut) {\n      preloadOnMousedown = true\n    }\n\n    if (intensityParameter == 'mousedown-only' && !useMousedownShortcut) {\n      preloadOnMousedown = true\n      preloadOnlyOnMousedown = true\n    }\n\n    if (intensityParameter == 'viewport') {\n      const isOnSmallScreen = document.documentElement.clientWidth * document.documentElement.clientHeight < 450000\n      // Smartphones are the most likely to have a slow connection, and\n      // their small screen size limits the number of links (and thus\n      // server load).\n      //\n      // Foldable phones (being expensive as of 2023), tablets and PCs\n      // generally have a decent connection, and a big screen displaying\n      // more links that would put more load on the server.\n      //\n      // iPhone 14 Pro Max (want): 430×932 = 400 760\n      // Samsung Galaxy S22 Ultra with display size set to 80% (want):\n      // 450×965 = 434 250\n      // Small tablet (don’t want): 600×960 = 576 000\n      // Those number are virtual screen size, the viewport (used for\n      // the check above) will be smaller with the browser’s interface.\n\n      const isNavigatorConnectionSaveDataEnabled = navigator.connection && navigator.connection.saveData\n      const isNavigatorConnectionLike2g = navigator.connection && navigator.connection.effectiveType && navigator.connection.effectiveType.includes('2g')\n      const isNavigatorConnectionAdequate = !isNavigatorConnectionSaveDataEnabled && !isNavigatorConnectionLike2g\n\n      if (isOnSmallScreen && isNavigatorConnectionAdequate) {\n        preloadWhenVisible = true\n      }\n    }\n\n    if (intensityParameter == 'viewport-all') {\n      preloadWhenVisible = true\n    }\n\n    const intensityAsInteger = parseInt(intensityParameter)\n    if (!isNaN(intensityAsInteger)) {\n      _delayOnHover = intensityAsInteger\n    }\n  }\n\n  const eventListenersOptions = {\n    capture: true,\n    passive: true,\n  }\n\n  if (preloadOnlyOnMousedown) {\n    document.addEventListener('touchstart', touchstartEmptyListener, eventListenersOptions)\n  }\n  else {\n    document.addEventListener('touchstart', touchstartListener, eventListenersOptions)\n  }\n\n  if (!preloadOnMousedown) {\n    document.addEventListener('mouseover', mouseoverListener, eventListenersOptions)\n  }\n\n  if (preloadOnMousedown) {\n    document.addEventListener('mousedown', mousedownListener, eventListenersOptions)\n  }\n  if (useMousedownShortcut) {\n    document.addEventListener('mousedown', mousedownShortcutListener, eventListenersOptions)\n  }\n\n  if (preloadWhenVisible) {\n    let requestIdleCallbackOrFallback = window.requestIdleCallback\n    // Safari has no support as of 16.3: https://webkit.org/b/164193\n    if (!requestIdleCallbackOrFallback) {\n      requestIdleCallbackOrFallback = (callback) => {\n        callback()\n        // A smarter fallback like setTimeout is not used because devices that\n        // may eventually be eligible to a Safari version supporting prefetch\n        // will be very powerful.\n        // The weakest devices that could be eligible are the 2017 iPad and\n        // the 2016 MacBook.\n      }\n    }\n\n    requestIdleCallbackOrFallback(function observeIntersection() {\n      const intersectionObserver = new IntersectionObserver((entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            const anchorElement = entry.target\n            intersectionObserver.unobserve(anchorElement)\n            preload(anchorElement.href)\n          }\n        })\n      })\n\n      document.querySelectorAll('a').forEach((anchorElement) => {\n        if (isPreloadable(anchorElement)) {\n          intersectionObserver.observe(anchorElement)\n        }\n      })\n    }, {\n      timeout: 1500,\n    })\n  }\n}\n\nfunction touchstartListener(event) {\n  _lastTouchstartEvent = event\n\n  const anchorElement = event.target.closest('a')\n\n  if (!isPreloadable(anchorElement)) {\n    return\n  }\n\n  preload(anchorElement.href, 'high')\n}\n\nfunction touchstartEmptyListener(event) {\n  _lastTouchstartEvent = event\n}\n\nfunction mouseoverListener(event) {\n  if (isEventLikelyTriggeredByTouch(event)) {\n    // This avoids uselessly adding a mouseout event listener and setting a timer.\n    return\n  }\n\n  if (!('closest' in event.target)) {\n    return\n    // Without this check sometimes an error “event.target.closest is not a function” is thrown, for unknown reasons\n    // That error denotes that `event.target` isn’t undefined. My best guess is that it’s the Document.\n    //\n    // Details could be gleaned from throwing such an error:\n    //throw new TypeError(`instant.page non-element event target: timeStamp=${~~event.timeStamp}, type=${event.type}, typeof=${typeof event.target}, nodeType=${event.target.nodeType}, nodeName=${event.target.nodeName}, viewport=${innerWidth}x${innerHeight}, coords=${event.clientX}x${event.clientY}, scroll=${scrollX}x${scrollY}`)\n  }\n  const anchorElement = event.target.closest('a')\n\n  if (!isPreloadable(anchorElement)) {\n    return\n  }\n\n  anchorElement.addEventListener('mouseout', mouseoutListener, {passive: true})\n\n  _mouseoverTimer = setTimeout(() => {\n    preload(anchorElement.href, 'high')\n    _mouseoverTimer = null\n  }, _delayOnHover)\n}\n\nfunction mousedownListener(event) {\n  if (isEventLikelyTriggeredByTouch(event)) {\n    // When preloading only on mousedown, not touch, we need to stop there\n    // because touches send compatibility mouse events including mousedown.\n    //\n    // (When preloading on touchstart, instructions below this block would\n    // have no effect.)\n    return\n  }\n\n  const anchorElement = event.target.closest('a')\n\n  if (!isPreloadable(anchorElement)) {\n    return\n  }\n\n  preload(anchorElement.href, 'high')\n}\n\nfunction mouseoutListener(event) {\n  if (event.relatedTarget && event.target.closest('a') == event.relatedTarget.closest('a')) {\n    return\n  }\n\n  if (_mouseoverTimer) {\n    clearTimeout(_mouseoverTimer)\n    _mouseoverTimer = null\n  }\n}\n\nfunction mousedownShortcutListener(event) {\n  if (isEventLikelyTriggeredByTouch(event)) {\n    // Due to a high potential for complications with this mousedown shortcut\n    // combined with other parties’ JavaScript code, we don’t want it to run\n    // at all on touch devices, even though mousedown and click are triggered\n    // at almost the same time on touch.\n    return\n  }\n\n  const anchorElement = event.target.closest('a')\n\n  if (event.which > 1 || event.metaKey || event.ctrlKey) {\n    return\n  }\n\n  if (!anchorElement) {\n    return\n  }\n\n  anchorElement.addEventListener('click', function (event) {\n    if (event.detail == 1337) {\n      return\n    }\n\n    event.preventDefault()\n  }, {capture: true, passive: false, once: true})\n\n  const customEvent = new MouseEvent('click', {view: window, bubbles: true, cancelable: false, detail: 1337})\n  anchorElement.dispatchEvent(customEvent)\n}\n\nfunction isEventLikelyTriggeredByTouch(event) {\n  // Touch devices fire “mouseover” and “mousedown” (and other) events after\n  // a touch for compatibility reasons.\n  // This function checks if it’s likely that we’re dealing with such an event.\n\n  if (!_lastTouchstartEvent || !event) {\n    return false\n  }\n\n  if (event.target != _lastTouchstartEvent.target) {\n    return false\n  }\n\n  const now = event.timeStamp\n  // Chromium (tested Chrome 95 and 122 on Android) sometimes uses the same\n  // event.timeStamp value in touchstart, mouseover, and mousedown.\n  // Testable in test/extras/delay-not-considered-touch.html\n  // This is okay for our purpose: two equivalent timestamps will be less\n  // than the max duration, which means they’re related events.\n  // TODO: fill/find Chromium bug\n  const durationBetweenLastTouchstartAndNow = now - _lastTouchstartEvent.timeStamp\n\n  const MAX_DURATION_TO_BE_CONSIDERED_TRIGGERED_BY_TOUCHSTART = 2500\n  // How long after a touchstart event can a simulated mouseover/mousedown event fire?\n  // /test/extras/delay-not-considered-touch.html tries to answer that question.\n  // I saw up to 1450 ms on an overwhelmed Samsung Galaxy S2.\n  // On the other hand, how soon can an unrelated mouseover event happen after an unrelated touchstart?\n  // Meaning the user taps a link, then grabs their pointing device and clicks another/the same link.\n  // That scenario could occur if a user taps a link, thinks it hasn’t worked, and thus fall back to their pointing device.\n  // I do that in about 1200 ms on a Chromebook. In which case this function returns a false positive.\n  // False positives are okay, as this function is only used to decide to abort handling mouseover/mousedown/mousedownShortcut.\n  // False negatives could lead to unforeseen state, particularly in mousedownShortcutListener.\n\n  return durationBetweenLastTouchstartAndNow < MAX_DURATION_TO_BE_CONSIDERED_TRIGGERED_BY_TOUCHSTART\n\n  // TODO: Investigate if pointer events could be used.\n  // https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n\n  // TODO: Investigate if InputDeviceCapabilities could be used to make it\n  // less hacky on Chromium browsers.\n  // https://developer.mozilla.org/en-US/docs/Web/API/InputDeviceCapabilities_API\n  // https://wicg.github.io/input-device-capabilities/\n  // Needs careful reading of the spec and tests (notably, what happens with a\n  // mouse connected to an Android or iOS smartphone?) to make sure it’s solid.\n  // Also need to judge if WebKit could implement it differently, as they\n  // don’t mind doing when a spec gives room to interpretation.\n  // It seems to work well on Chrome on ChromeOS.\n\n  // TODO: Consider using event screen position as another heuristic.\n}\n\nfunction isPreloadable(anchorElement) {\n  if (!anchorElement || !anchorElement.href) {\n    return\n  }\n\n  if (_useWhitelist && !('instant' in anchorElement.dataset)) {\n    return\n  }\n\n  if (anchorElement.origin != location.origin) {\n    let allowed = _allowExternalLinks || 'instant' in anchorElement.dataset\n    if (!allowed || !_chromiumMajorVersionInUserAgent) {\n      // Chromium-only: see comment on “restrictive prefetch” and “cross-site speculation rules prefetch”\n      return\n    }\n  }\n\n  if (!['http:', 'https:'].includes(anchorElement.protocol)) {\n    return\n  }\n\n  if (anchorElement.protocol == 'http:' && location.protocol == 'https:') {\n    return\n  }\n\n  if (!_allowQueryString && anchorElement.search && !('instant' in anchorElement.dataset)) {\n    return\n  }\n\n  if (anchorElement.hash && anchorElement.pathname + anchorElement.search == location.pathname + location.search) {\n    return\n  }\n\n  if ('noInstant' in anchorElement.dataset) {\n    return\n  }\n\n  return true\n}\n\nfunction preload(url, fetchPriority = 'auto') {\n  if (_preloadedList.has(url)) {\n    return\n  }\n\n  if (_speculationRulesType != 'none') {\n    preloadUsingSpeculationRules(url)\n  } else {\n    preloadUsingLinkElement(url, fetchPriority)\n  }\n\n  _preloadedList.add(url)\n}\n\nfunction preloadUsingSpeculationRules(url) {\n  const scriptElement = document.createElement('script')\n  scriptElement.type = 'speculationrules'\n\n  scriptElement.textContent = JSON.stringify({\n    [_speculationRulesType]: [{\n      source: 'list',\n      urls: [url]\n    }]\n  })\n\n  // When using speculation rules, cross-site prefetch is supported, but will\n  // only work if the user has no cookies for the destination site. The\n  // prefetch will not be sent, if the user does have such cookies.\n\n  document.head.appendChild(scriptElement)\n}\n\nfunction preloadUsingLinkElement(url, fetchPriority = 'auto') {\n  const linkElement = document.createElement('link')\n  linkElement.rel = 'prefetch'\n  linkElement.href = url\n\n  linkElement.fetchPriority = fetchPriority\n  // By default, a prefetch is loaded with a low priority.\n  // When there’s a fair chance that this prefetch is going to be used in the\n  // near term (= after a touch/mouse event), giving it a high priority helps\n  // make the page load faster in case there are other resources loading.\n  // Prioritizing it implicitly means deprioritizing every other resource\n  // that’s loading on the page. Due to HTML documents usually being much\n  // smaller than other resources (notably images and JavaScript), and\n  // prefetches happening once the initial page is sufficiently loaded,\n  // this theft of bandwidth should rarely be detrimental.\n\n  linkElement.as = 'document'\n  // as=document is Chromium-only and allows cross-origin prefetches to be\n  // usable for navigation. They call it “restrictive prefetch” and intend\n  // to remove it: https://crbug.com/1352371\n  //\n  // This document from the Chrome team dated 2022-08-10\n  // https://docs.google.com/document/d/1x232KJUIwIf-k08vpNfV85sVCRHkAxldfuIA5KOqi6M\n  // claims (I haven’t tested) that data- and battery-saver modes as well as\n  // the setting to disable preloading do not disable restrictive prefetch,\n  // unlike regular prefetch. That’s good for prefetching on a touch/mouse\n  // event, but might be bad when prefetching every link in the viewport.\n\n  document.head.appendChild(linkElement)\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.7578125,
          "content": "{\n  \"name\": \"instant.page\",\n  \"version\": \"5.2.0\",\n  \"description\": \"Make your site’s pages instant in 1 minute and improve your conversion rate by 1%\",\n  \"main\": \"instantpage.js\",\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"minify\": \"npx --yes -- uglify-es ./instantpage.js --compress --mangle --toplevel --comments \\\"/^!/\\\" --output ./instantpage.min.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/instantpage/instant.page.git\"\n  },\n  \"keywords\": [\n    \"instant\",\n    \"performance\"\n  ],\n  \"author\": \"Alexandre Dieulot\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/instantpage/instant.page/issues\"\n  },\n  \"homepage\": \"https://instant.page/\"\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}