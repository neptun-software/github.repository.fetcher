{
  "metadata": {
    "timestamp": 1736563020176,
    "page": 647,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rtfeldman/seamless-immutable",
      "stars": 5368,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6171875,
          "content": "# Logs\nlogs\n*.log\n\n# Runtime data\npids\n*.pid\n*.seed\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n\n# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Compiled binary addons (http://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directory\n# Commenting this out is preferred by some people, see\n# https://www.npmjs.org/doc/misc/npm-faq.html#should-i-check-my-node_modules-folder-into-git-\nnode_modules\n\n# Users Environment Variables\n.lock-wscript\n\ntmp\nhtml-report\nlcov.info\nlcov-report\n.idea\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.6806640625,
          "content": "# Logs\nlogs\n*.log\n\n# Runtime data\npids\n*.pid\n*.seed\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n\n# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Compiled binary addons (http://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directory\n# Commenting this out is preferred by some people, see\n# https://www.npmjs.org/doc/misc/npm-faq.html#should-i-check-my-node_modules-folder-into-git-\nnode_modules\n\n# Users Environment Variables\n.lock-wscript\n\ntmp\nhtml-report\nlcov.info\nlcov-report\n.idea\n\nGruntfile.js\n.travis.yml\nbower.json\n.zuul.yml\nbenchmark.js\ntest\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1083984375,
          "content": "sudo: false\n\nlanguage: node_js\n\nnode_js:\n- '8.11.1'\n\nbefore_script:\n- npm install\n\nscript: npm run travis-test\n"
        },
        {
          "name": ".zuul.yml",
          "type": "blob",
          "size": 0.255859375,
          "content": "ui: mocha-bdd\nbrowsers:\n  - name: chrome\n    version: [\"45\", \"latest\"]\n  - name: ie\n    version: [\"9\", \"10\", \"latest\"]\n  - name: firefox\n    version: [\"36\", \"latest\"]\n  - name: android\n    version: [\"4.0\", \"latest\"]\n  - name: safari\n    version: [\"6\", \"latest\"]\n"
        },
        {
          "name": "Gruntfile.js",
          "type": "blob",
          "size": 1.5322265625,
          "content": "var fs = require(\"fs\");\nvar envify = require(\"envify/custom\");\n\nmodule.exports = function(grunt) {\n  grunt.initConfig({\n    mochaTest: {\n      test: {\n        src: [\"test/*.spec.js\"]\n      }\n    },\n    envify: {\n      dev: {\n        env: {\n          NODE_ENV: \"development\"\n        },\n        input: \"src/seamless-immutable.js\",\n        output: \"seamless-immutable.development.js\"\n      },\n      prod: {\n        env: {\n          NODE_ENV: \"production\"\n        },\n        input: \"src/seamless-immutable.js\",\n        output: \"seamless-immutable.production.min.js\"\n      }\n    },\n    uglify: {\n      options: {\n        banner: '/* (c) 2017, Richard Feldman, github.com/rtfeldman/seamless-immutable/blob/master/LICENSE */'\n      },\n      min: {\n        files: {\n          \"seamless-immutable.development.min.js\": [\"seamless-immutable.development.js\"],\n          \"seamless-immutable.production.min.js\": [\"seamless-immutable.production.min.js\"]\n        }\n      }\n    }\n  });\n\n  grunt.loadNpmTasks(\"grunt-mocha-test\");\n  grunt.loadNpmTasks(\"grunt-contrib-uglify\");\n\n  grunt.registerMultiTask(\"envify\", \"Envifies a source file to a target file\", function() {\n    var inputStream = fs.createReadStream(this.data.input);\n    var outputStream = fs.createWriteStream(this.data.output);\n\n    var done = this.async();\n\n    inputStream\n      .pipe(envify(this.data.env)())\n      .pipe(outputStream)\n      .on(\"finish\", done);\n  });\n\n  grunt.registerTask(\"test\", \"mochaTest\");\n  grunt.registerTask(\"build\", [\"envify\", \"uglify\"]);\n  grunt.registerTask(\"default\", [\"build\", \"test\"]);\n};\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4560546875,
          "content": "Copyright (c) 2016, Richard Feldman\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of seamless-immutable nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.671875,
          "content": "seamless-immutable\n==================\n\nImmutable JS data structures which are backwards-compatible with normal Arrays and Objects.\n\nUse them in `for` loops, pass them to functions expecting vanilla JavaScript data structures, etc.\n\n```javascript\nvar array = Immutable([\"totally\", \"immutable\", {hammer: \"Can’t Touch This\"}]);\n\narray[1] = \"I'm going to mutate you!\"\narray[1] // \"immutable\"\n\narray[2].hammer = \"hm, surely I can mutate this nested object...\"\narray[2].hammer // \"Can’t Touch This\"\n\nfor (var index in array) { console.log(array[index]); }\n// \"totally\"\n// \"immutable\"\n// { hammer: 'Can’t Touch This' }\n\nJSON.stringify(array) // '[\"totally\",\"immutable\",{\"hammer\":\"Can’t Touch This\"}]'\n```\n\nThis level of backwards compatibility requires [ECMAScript 5](http://kangax.github.io/compat-table/es5/) features like [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) and [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) to exist and work correctly, which limits the browsers that can use this library to the ones shown in the test results below. (tl;dr [IE9+](https://saucelabs.com/u/seamless-immutable))\n\n[![build status][1]][2] [![NPM version][3]][4] [![coverage status][5]][6]\n\n## Performance\n\nWhenever you deeply clone large nested objects, it should typically go much faster with `Immutable` data structures. This is because the library reuses the existing nested objects rather than instantiating new ones.\n\nIn the development build, objects are [frozen](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze). (Note that [Safari is relatively slow to iterate over frozen objects](http://jsperf.com/performance-frozen-object/20).) The development build also overrides unsupported methods (methods that ordinarily mutate the underlying data structure) to throw helpful exceptions.\n\nThe production (minified) build does neither of these, which significantly improves performance.\n\nWe generally recommend to use the \"development\" build that enforces immutability (and this is the default in Node.js). Only switch to the production build when you encounter performance problems. (See #50 for how to do that in Node or using a build tool - essentially do explicitely refer to the production build.)\n\n## Intentional Abstraction Leaks\n\nBy popular demand, functions, errors, dates, and [React](https://facebook.github.io/react/)\ncomponents are treated as immutable even though technically they can be mutated.\n(It turns out that trying to make these immutable leads to more bad things\nthan good.) If you call `Immutable()` on any of these, be forewarned: they will\nnot actually be immutable!\n\n## Add-ons\n\nseamless-immutable is tightly focused on the mechanics of turning existing JavaScript data structures into immutable variants.\nAdditional packages are available to build on this capability and enable additional programming models:\n\n|Library|Description|\n|--------|------------|\n|[Cursor](https://github.com/MartinSnyder/seamless-immutable-cursor)|Compact Cursor Library built on top of the excellent seamless-immutable. Cursors can be used to manage transitions and manipulations of immutable structures in an application.|\n|[Mergers](https://github.com/crudh/seamless-immutable-mergers)|A collection of mergers for use with seamless-immutable. Also includes documentation about custom mergers, with examples, for writing your own.|\n\n## API Overview\n\n`Immutable()` returns a backwards-compatible immutable representation of whatever you pass it, so feel free to pass it absolutely anything that can be serialized as JSON. (As is the case with JSON, objects containing circular references are not allowed. Functions are allowed, unlike in JSON, but they will not be touched.)\n\nSince numbers, strings, `undefined`, and `null` are all immutable to begin with, the only unusual things it returns are Immutable Arrays and Immutable Objects. These have the same [ES5 methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) you’re used to seeing on them, but with these important differences:\n\n1. All the methods that would normally mutate the data structures instead throw `ImmutableError`.\n2. All the methods that return a relevant value now return an immutable equivalent of that value.\n3. Attempting to reassign values to their elements (e.g. `foo[5] = bar`) will not work. Browsers other than Internet Explorer will throw a `TypeError` if [use strict](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) is enabled, and in all other cases it will fail silently.\n4. A few additional methods have been added for convenience.\n\nFor example:\n\n```javascript\nImmutable([3, 1, 4]).sort()\n// This will throw an ImmutableError, because sort() is a mutating method.\n\nImmutable([1, 2, 3]).concat([10, 9, 8]).sort()\n// This will also throw ImmutableError, because an Immutable Array's methods\n// (including concat()) are guaranteed to return other immutable values.\n\n[1, 2, 3].concat(Immutable([6, 5, 4])).sort()\n// This will succeed, and will yield a sorted mutable array containing\n// [1, 2, 3, 4, 5, 6], because a vanilla array's concat() method has\n// no knowledge of Immutable.\n\nvar obj = Immutable({all: \"your base\", are: {belong: \"to them\"}});\nImmutable.merge(obj, {are: {belong: \"to us\"}})\n// This will return the following:\n// Immutable({all: \"your base\", are: {belong: \"to us\"}})\n```\n\n## Static or instance syntax\n\nSeamless-immutable supports both static and instance syntaxes:\n\n```javascript\nvar Immutable = require(\"seamless-immutable\").static;\nvar obj = {};\n\nImmutable.setIn(obj, ['key'], data)\n```\n\n```javascript\nvar Immutable = require(\"seamless-immutable\");\nvar obj = {};\n\nobj.setIn(['key'], data)\n```\n\nAlthough the later is shorter and is the current default, it can lead to\ncollisions and some users may dislike polluting object properties when it comes\nto debugging. As such the first syntax is recommended, but both are supported.\n\n## Immutable.from\n\nIf your linter cringes with the use of `Immutable` without a preceding `new`\n(e.g. ESLint's [new-cap](http://eslint.org/docs/rules/new-cap) rule),\nuse `Immutable.from`:\n\n```javascript\nImmutable.from([1, 2, 3]);\n// is functionally the same as calling:\nImmutable([1, 2, 3])\n```\n\n## Immutable Array\n\nLike a regular Array, but immutable! You can construct these by passing\nan array to `Immutable()`:\n\n```javascript\nImmutable([1, 2, 3])\n// An immutable array containing 1, 2, and 3.\n```\n\nBeyond [the usual Array fare](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Accessor_methods), the following methods have been added.\n\n### flatMap\n\n```javascript\nvar array = Immutable([\"here\", \"we\", \"go\"]);\nImmutable.flatMap(array, function(str) {\n  return [str, str, str];\n});\n// returns Immutable([\"here\", \"here\", \"here\", \"we\", \"we\", \"we\", \"go\", \"go\", \"go\"])\n\nvar array = Immutable([\"drop the numbers!\", 3, 2, 1, 0, null, undefined]);\nImmutable.flatMap(array, function(value) {\n  if (typeof value === \"number\") {\n    return [];\n  } else {\n    return value;\n  }\n});\n// returns Immutable([\"drop the numbers!\", null, undefined])\n```\n\nEffectively performs a [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) over the elements in the array, except that whenever the provided\niterator function returns an Array, that Array's elements are each added to the final result.\n\n```javascript\nvar array = Immutable([1,2,3]);\narray.map(value => [value+2, value+4]);\n// returns Immutable([ [ 3, 5 ], [ 4, 6 ], [ 5, 7 ] ])\n\nImmutable.flatMap(array, value => [value+2, value+4]);\n// returns Immutable([ 3, 5, 4, 6, 5, 7 ])\n```\n\n### asObject\n\n```javascript\nvar array = Immutable([\"hey\", \"you\"]);\nImmutable.asObject(array, function(str) {\n  return [str, str.toUpperCase()];\n});\n// returns Immutable({hey: \"HEY\", you: \"YOU\"})\n```\n\nEffectively performs a [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) over the elements in the array, expecting that the iterator function\nwill return an array of two elements - the first representing a key, the other\na value. Then returns an Immutable Object constructed of those keys and values.\n\nYou can also call `.asObject` without passing an iterator, in which case it will proceed assuming the Array\nis already organized as desired.\n\n### asMutable\n\n```javascript\nvar array = Immutable([\"hello\", \"world\"]);\nvar mutableArray = Immutable.asMutable(array);\n\nmutableArray.push(\"!!!\");\n\nmutableArray // [\"hello\", \"world\", \"!!!\"]\n```\n\nReturns a mutable copy of the array. For a deeply mutable copy, in which any instances of `Immutable` contained in nested data structures within the array have been converted back to mutable data structures, call `Immutable.asMutable(obj, {deep: true})` instead.\n\n### isImmutable\n```javascript\nvar array = Immutable([\"hello\", \"world\"]);\nvar mutableArray = [\"hello\", \"world\"];\n\nImmutable.isImmutable(array)\n// returns true\n\nImmutable.isImmutable(mutableArray)\n// returns false\n```\n\nReturns whether an object is immutable or not.\n\n### Additional Methods\nIn addition, Immutable Arrays also provide member functions for the `set`, `setIn`, `update`, `updateIn`, and `getIn` functions (described below).\n```javascript\nvar array = Immutable([\"hello\", \"world\"]);\n\n// Equivalent to Immutable.set(array, 1, \"you\");\nvar mutatedArray = array.set(1, \"you\");\n\nmutatedArray // [\"hello\", \"you\"]\n```\n\n## Immutable Object\n\nLike a regular Object, but immutable! You can construct these by passing an\nobject to `Immutable()`.\n\n```javascript\nImmutable({foo: \"bar\"})\n// An immutable object containing the key \"foo\" and the value \"bar\".\n```\n\nTo construct an Immutable Object with a custom prototype, simply specify the\nprototype in `options` (while useful for preserving prototypes, please note\nthat custom mutator methods will not work as the object will be immutable):\n\n```javascript\nfunction Square(length) { this.length = length };\nSquare.prototype.area = function() { return Math.pow(this.length, 2) };\n\nImmutable(new Square(2), {prototype: Square.prototype}).area();\n// An immutable object, with prototype Square,\n// containing the key \"length\" and method `area()` returning 4\n```\n\nBeyond [the usual Object fare](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#Methods_of_Object_instances), the following methods have been added.\n\n### Stack overflow protection\n\nCurrently you can't construct Immutable from an object with circular references. To protect from ugly stack overflows, we provide a simple protection during development. We stop at a suspiciously deep stack level and [show an error message][deep].\n\nIf your objects are deep, but not circular, you can increase this level from default `64`. For example:\n\n```javascript\nImmutable(deepObject, null, 256);\n```\n\nThis check is not performed in the production build.\n\n[deep]: https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected\n\n### merge\n\n```javascript\nvar obj = Immutable({status: \"good\", hypothesis: \"plausible\", errors: 0});\nImmutable.merge(obj, {status: \"funky\", hypothesis: \"confirmed\"});\n// returns Immutable({status: \"funky\", hypothesis: \"confirmed\", errors: 0})\n\nvar obj = Immutable({status: \"bad\", errors: 37});\nImmutable.merge(obj, [\n  {status: \"funky\", errors: 1}, {status: \"groovy\", errors: 2}, {status: \"sweet\"}]);\n// returns Immutable({status: \"sweet\", errors: 2})\n// because passing an Array is shorthand for\n// invoking a separate merge for each object in turn.\n```\nReturns an Immutable Object containing the properties and values of both\nthis object and the provided object, prioritizing the provided object's\nvalues whenever the same key is present in both objects.\n\nMultiple objects can be provided in an Array in which case more `merge`\ninvocations will be performed using each provided object in turn.\n\nA third argument can be provided to configure the merge. It should be an object with any of the following fields:\n\n```javascript\n{\n  deep: true, // perform a deep merge\n  merger: yourCustomMerger // supply a custom merger\n}\n```\n\nYou can find examples and documentation about custom mergers [here](https://github.com/crudh/seamless-immutable-mergers).\n\n### replace\n\n```javascript\nvar obj1 = Immutable({a: {b: 'test'}, c: 'test'});\nvar obj2 = Immutable.replace(obj1, {a: {b: 'test'}}, {deep: true});\n// returns Immutable({a: {b: 'test'}});\nobj1 === obj2\n// returns false\nobj1.a === obj2.a\n// returns true because child .a objects were identical\n```\n\nReturns an Immutable Object containing the properties and values of the\nsecond object only. With deep merge, all child objects are checked for\nequality and the original immutable object is returned when possible.\n\nA second argument can be provided to perform a deep merge: `{deep: true}`.\n\n### set\n\n```javascript\nvar obj = Immutable({type: \"parrot\", subtype: \"Norwegian Blue\", status: \"alive\"});\nImmutable.set(obj, \"status\", \"dead\");\n// returns Immutable({type: \"parrot\", subtype: \"Norwegian Blue\", status: \"dead\"})\n```\n\nReturns an Immutable Object with a single property set to the provided value.\nBasically a more straightforward way of saying\n```javascript\nvar obj = Immutable({type: \"parrot\", subtype: \"Norwegian Blue\", status: \"alive\"});\nImmutable.merge(obj, {status: \"dead\"});\n```\n(and more convenient with non-literal keys unless you have ES6 ```[computed_property_names]```).\n\nAn additional argument can be provided to perform a deep compare: `{deep: true}`.\n\nWhen called with an Immutable Array, the property parameter is the index to be changed:\n```javascript\nvar array = Immutable([\"hello\", \"world\"]);\nvar mutatedArray = Immutable.set(array, 1, \"you\");\n\nmutatedArray // [\"hello\", \"you\"]\n```\nIf the `{deep: true}` parameter is provided when using an Immutable Array, the object at the provided index will be merged with the provided value using `Immutable.merge()`.\n\n### setIn\n\nLike [set](#set), but accepts a nested path to the property.\n\n```javascript\nvar obj = Immutable({type: {main: \"parrot\", sub: \"Norwegian Blue\"}, status: \"alive\"});\nImmutable.setIn(obj, [\"type\", \"sub\"], \"Norwegian Ridgeback\");\n// returns Immutable({type: {main: \"parrot\", sub: \"Norwegian Ridgeback\"}, status: \"alive\"})\n```\n\nAn additional argument can be provided to perform a deep compare: `{deep: true}`.\n\nWhen called with an Immutable Array, at least the first value in the path should be an index. This also works with nested arrays:\n```javascript\nvar array = Immutable([[\"one fish\", \"two fish\"], [\"red fish\", \"blue fish\"]]);\nvar mutatedArray = Immutable.setIn(array, [1, 1], \"green fish\");\n\nmutatedArray // [[\"one fish\", \"two fish\"], [\"red fish\", \"green fish\"]]\n```\n\n### getIn\n\nReturns the value at the given path. A default value can be provided as a second argument.\n\n```javascript\nvar obj = Immutable({type: {main: \"parrot\", subtype: \"Norwegian Blue\"}, status: \"alive\"});\nImmutable.getIn(obj, [\"type\", \"subtype\"]);\n// returns \"Norwegian Blue\"\nImmutable.getIn(obj, [\"type\", \"class\"], \"Aves\");\n// returns \"Aves\"\n```\n\n### update\n\nReturns an Immutable Object with a single property updated using the provided updater function.\n\n```javascript\nfunction inc (x) { return x + 1 }\nvar obj = Immutable({foo: 1});\nImmutable.update(obj, \"foo\", inc);\n// returns Immutable({foo: 2})\n```\n\nAll additional arguments will be passed to the updater function.\n\n```javascript\nfunction add (x, y) { return x + y }\nvar obj = Immutable({foo: 1});\nImmutable.update(obj, \"foo\", add, 10);\n// returns Immutable({foo: 11})\n```\n\n### updateIn\n\nLike [update](#update), but accepts a nested path to the property.\n\n```javascript\nfunction add (x, y) { return x + y }\nvar obj = Immutable({foo: {bar: 1}});\nImmutable.updateIn(obj, [\"foo\", \"bar\"], add, 10);\n// returns Immutable({foo: {bar: 11}})\n```\n\n### without\n\n```javascript\nvar obj = Immutable({the: \"forests\", will: \"echo\", with: \"laughter\"});\nImmutable.without(obj, \"with\");\n// returns Immutable({the: \"forests\", will: \"echo\"})\n\nvar obj = Immutable({the: \"forests\", will: \"echo\", with: \"laughter\"});\nImmutable.without(obj, [\"will\", \"with\"]);\n// returns Immutable({the: \"forests\"})\n\nvar obj = Immutable({the: \"forests\", will: \"echo\", with: \"laughter\"});\nImmutable.without(obj, \"will\", \"with\");\n// returns Immutable({the: \"forests\"})\n\nvar obj = Immutable({the: \"forests\", will: \"echo\", with: \"laughter\"});\nImmutable.without(obj, (value, key) => key === \"the\" || value === \"echo\");\n// returns Immutable({with: \"laughter\"})\n```\n\nReturns an Immutable Object excluding the given keys or keys/values satisfying\nthe given predicate from the existing object.\n\nMultiple keys can be provided, either in an Array or as extra arguments.\n\n### asMutable\n\n```javascript\nvar obj = Immutable({when: \"the\", levee: \"breaks\"});\nvar mutableObject = Immutable.asMutable(obj);\n\nmutableObject.have = \"no place to go\";\n\nmutableObject // {when: \"the\", levee: \"breaks\", have: \"no place to go\"}\n```\n\nReturns a mutable copy of the object. For a deeply mutable copy, in which any instances of `Immutable` contained in nested data structures within the object have been converted back to mutable data structures, call `Immutable.asMutable(obj, {deep: true})` instead.\n\n### Releases\n\n#### 7.1.4\n\nFixed bug with custom mergers treating all non-truthy values as undefined ([#244](https://github.com/rtfeldman/seamless-immutable/issues/244)).\n\n#### 7.1.3\n\nTreat `Blob` instances as immutable. Use `Array.isArray` over `instanceof`.\n\n#### 7.1.2\n\nTreat `Error` instances as immutable.\n\n#### 7.1.1\n\nFix .npmignore\n\n#### 7.1.0\n\nAdd `getIn` and assumption that Promises are immutable.\n\n#### 7.0.0\n\nAdd `Immutable.static` as the preferred API. Default to development build in webpack.\n\n#### 6.3.0\n\nAdds optional deep compare for `.set`, `.setIn` and `.replace`\n\n#### 6.2.0\n\nAdds static alternatives to methods, e.g. `Immutable.setIn`\n\n#### 6.1.4\n\nFixes [bug with deep merge() on an array argument](https://github.com/rtfeldman/seamless-immutable/pull/140).\n\n#### 6.1.3\n\nFixes bug with setting a new object on an existing leaf array.\n\n#### 6.1.2\n\nFixes bug where on some systems arrays are treated as plain objects.\n\n#### 6.1.1\n\n`without` now handles numeric keys the same way as string keys.\n\n#### 6.1.0\n\nAlias `Immutable.from()` to `Immutable()` for linters.\n\n#### 6.0.1\n\nReact components are now considered immutable.\n\n#### 6.0.0\n\nAdd cycle detection.\n\n#### 5.2.0\n\nAdd `update` and `updateIn`.\n\n#### 5.1.1\n\n`Immutable(Object.create(null))` now works as expected.\n\n#### 5.1.0\n\nAdd predicate support to `without()`\n\n#### 5.0.1\n\nFix missing dev/prod builds for 5.0.0\n\n#### 5.0.0\n\nIn development build, freeze Dates and ban mutating methods. (Note: dev and prod builds were mistakenly\nnot generated for this, so to get this functionality in those builds, use 5.0.1)\n\n#### 4.1.1\n\nMake `setIn` more null safe.\n\n#### 4.1.0\n\nAdds `set` and `setIn`\n\n#### 4.0.1\n\nNow when you `require(\"seamless-immutable\")`, you get the development build by default.\n\n#### 4.0.0\n\n`main` now points to `src/seamless-immutable.js` so you can more easily build with `envify` yourself.\n\n#### 3.0.0\n\nAdd support for optional prototyping.\n\n#### 2.4.2\n\nCalling .asMutable({deep: true}) on an Immutable data structure with a nested Date no longer throws an exception.\n\n#### 2.4.1\n\nArrays with nonstandard prototypes no longer throw exceptions when passed to `Immutable`.\n\n#### 2.4.0\n\nCustom mergers now check for reference equality and abort early if there is no more work needed, allowing improved performance.\n\n#### 2.3.2\n\nFixes a bug where indices passed into iterators for flatMap and asObject were strings instead of numbers.\n\n#### 2.3.1\n\nFixes an IE and Firefox bug related to cloning Dates while preserving their prototypes.\n\n#### 2.3.0\n\nDates now retain their prototypes, the same way Arrays do.\n\n#### 2.2.0\n\nAdds a minified production build with no freezing or defensive unsupported methods, for a ~2x performance boost.\n\n#### 2.1.0\n\nAdds optional `merger` function to `#merge`.\n\n#### 2.0.2\n\nBugfix: `#merge` with `{deep: true}` no longer attempts (unsuccessfully) to deeply merge arrays as though they were regular objects.\n\n#### 2.0.1\n\nMinor documentation typo fix.\n\n#### 2.0.0\n\nBreaking API change: `#merge` now takes exactly one or exactly two arguments. The second is optional and allows specifying `deep: true`.\n\n#### 1.3.0\n\nDon't bother returning a new value from `#merge` if no changes would result.\n\n#### 1.2.0\n\nMake error message for invalid `#asObject` less fancy, resulting in a performance improvement.\n\n#### 1.1.0\n\nAdds `#asMutable`\n\n#### 1.0.0\n\nInitial stable release\n\n## Development\n\nRun `npm install -g grunt-cli`, `npm install` and then `grunt` to build and test it.\n\n[1]: https://travis-ci.org/rtfeldman/seamless-immutable.svg?branch=master\n[2]: https://travis-ci.org/rtfeldman/seamless-immutable\n[3]: https://badge.fury.io/js/seamless-immutable.svg\n[4]: https://badge.fury.io/js/seamless-immutable\n[5]: http://img.shields.io/coveralls/rtfeldman/seamless-immutable.svg\n[6]: https://coveralls.io/r/rtfeldman/seamless-immutable\n"
        },
        {
          "name": "benchmark.js",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.513671875,
          "content": "{\n  \"name\": \"seamless-immutable\",\n  \"main\": \"src/seamless-immutable.js\",\n  \"version\": \"7.1.4\",\n  \"homepage\": \"https://github.com/rtfeldman/seamless-immutable\",\n  \"authors\": [\n    \"Richard Feldman <richard.t.feldman@gmail.com>\"\n  ],\n  \"description\": \"Immutable data structures for JavaScript which are backwards-compatible with normal JS Arrays and Objects.\",\n  \"keywords\": [\n    \"immutable\"\n  ],\n  \"license\": \"BSD-3-Clause\",\n  \"ignore\": [\n    \"**/.*\",\n    \"node_modules\",\n    \"bower_components\",\n    \"test\",\n    \"tests\"\n  ]\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.8779296875,
          "content": "{\n  \"name\": \"seamless-immutable\",\n  \"version\": \"7.1.4\",\n  \"description\": \"Immutable data structures for JavaScript which are backwards-compatible with normal JS Arrays and Objects.\",\n  \"main\": \"src/seamless-immutable.js\",\n  \"browser\": \"seamless-immutable.development.js\",\n  \"react-native\": \"src/seamless-immutable.js\",\n  \"devDependencies\": {\n    \"chai\": \"3.5.0\",\n    \"coveralls\": \"2.11.8\",\n    \"deep-equal\": \"1.0.1\",\n    \"envify\": \"3.4.0\",\n    \"grunt\": \"1.0.2\",\n    \"grunt-contrib-uglify\": \"0.11.1\",\n    \"grunt-mocha-test\": \"0.12.7\",\n    \"istanbul\": \"0.4.2\",\n    \"jscheck\": \"0.2.0\",\n    \"jshint\": \"2.9.5\",\n    \"lodash\": \"3.10.1\",\n    \"mocha\": \"2.4.5\",\n    \"mocha-istanbul\": \"0.2.0\",\n    \"mocha-lcov-reporter\": \"1.2.0\",\n    \"react\": \"^15.0.1\",\n    \"zuul\": \"3.11.1\"\n  },\n  \"scripts\": {\n    \"test\": \"grunt\",\n    \"test-watch\": \"mocha --watch test/*.spec.js\",\n    \"jshint\": \"jshint seamless-immutable.development.js\",\n    \"coverage\": \"export ISTANBUL_REPORTERS=text-summary,html,lcov && rm -rf tmp/ && rm -rf html-report/ && istanbul instrument test/ -o tmp/ && mocha --reporter mocha-istanbul tmp/*.spec.js && echo Open html-report/index.html to view results as HTML.\",\n    \"zuul-local\": \"zuul --local -- test/*.spec.js\",\n    \"travis-test\": \"npm run jshint && npm test && npm run coveralls\",\n    \"coveralls\": \"istanbul cover ./node_modules/mocha/bin/_mocha --report lcovonly -- -R spec && cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js && rm -rf ./coverage\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/rtfeldman/seamless-immutable.git\"\n  },\n  \"keywords\": [\n    \"immutable\"\n  ],\n  \"author\": \"Richard Feldman\",\n  \"license\": \"BSD-3-Clause\",\n  \"bugs\": {\n    \"url\": \"https://github.com/rtfeldman/seamless-immutable/issues\"\n  },\n  \"jshintConfig\": {\n    \"newcap\": false,\n    \"validthis\": true,\n    \"proto\": true\n  },\n  \"homepage\": \"https://github.com/rtfeldman/seamless-immutable\"\n}\n"
        },
        {
          "name": "seamless-immutable.development.js",
          "type": "blob",
          "size": 23.6484375,
          "content": "(function() {\n  \"use strict\";\n\nfunction immutableInit(config) {\n\n  // https://github.com/facebook/react/blob/v15.0.1/src/isomorphic/classic/element/ReactElement.js#L21\n  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element');\n  var REACT_ELEMENT_TYPE_FALLBACK = 0xeac7;\n\n  var globalConfig = {\n    use_static: false\n  };\n  if (isObject(config)) {\n      if (config.use_static !== undefined) {\n          globalConfig.use_static = Boolean(config.use_static);\n      }\n  }\n\n  function isObject(data) {\n    return (\n      typeof data === 'object' &&\n      !Array.isArray(data) &&\n      data !== null\n    );\n  }\n\n  function instantiateEmptyObject(obj) {\n      var prototype = Object.getPrototypeOf(obj);\n      if (!prototype) {\n          return {};\n      } else {\n          return Object.create(prototype);\n      }\n  }\n\n  function addPropertyTo(target, methodName, value) {\n    Object.defineProperty(target, methodName, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: value\n    });\n  }\n\n  function banProperty(target, methodName) {\n    addPropertyTo(target, methodName, function() {\n      throw new ImmutableError(\"The \" + methodName +\n        \" method cannot be invoked on an Immutable data structure.\");\n    });\n  }\n\n  var immutabilityTag = \"__immutable_invariants_hold\";\n\n  function addImmutabilityTag(target) {\n    addPropertyTo(target, immutabilityTag, true);\n  }\n\n  function isImmutable(target) {\n    if (typeof target === \"object\") {\n      return target === null || Boolean(\n        Object.getOwnPropertyDescriptor(target, immutabilityTag)\n      );\n    } else {\n      // In JavaScript, only objects are even potentially mutable.\n      // strings, numbers, null, and undefined are all naturally immutable.\n      return true;\n    }\n  }\n\n  function isEqual(a, b) {\n    // Avoid false positives due to (NaN !== NaN) evaluating to true\n    return (a === b || (a !== a && b !== b));\n  }\n\n  function isMergableObject(target) {\n    return target !== null && typeof target === \"object\" && !(Array.isArray(target)) && !(target instanceof Date);\n  }\n\n  var mutatingObjectMethods = [\n    \"setPrototypeOf\"\n  ];\n\n  var nonMutatingObjectMethods = [\n    \"keys\"\n  ];\n\n  var mutatingArrayMethods = mutatingObjectMethods.concat([\n    \"push\", \"pop\", \"sort\", \"splice\", \"shift\", \"unshift\", \"reverse\"\n  ]);\n\n  var nonMutatingArrayMethods = nonMutatingObjectMethods.concat([\n    \"map\", \"filter\", \"slice\", \"concat\", \"reduce\", \"reduceRight\"\n  ]);\n\n  var mutatingDateMethods = mutatingObjectMethods.concat([\n    \"setDate\", \"setFullYear\", \"setHours\", \"setMilliseconds\", \"setMinutes\", \"setMonth\", \"setSeconds\",\n    \"setTime\", \"setUTCDate\", \"setUTCFullYear\", \"setUTCHours\", \"setUTCMilliseconds\", \"setUTCMinutes\",\n    \"setUTCMonth\", \"setUTCSeconds\", \"setYear\"\n  ]);\n\n  function ImmutableError(message) {\n    this.name = 'MyError';\n    this.message = message;\n    this.stack = (new Error()).stack;\n  }\n  ImmutableError.prototype = new Error();\n  ImmutableError.prototype.constructor = Error;\n\n  function makeImmutable(obj, bannedMethods) {\n    // Tag it so we can quickly tell it's immutable later.\n    addImmutabilityTag(obj);\n\n    if (\"development\" !== \"production\") {\n      // Make all mutating methods throw exceptions.\n      for (var index in bannedMethods) {\n        if (bannedMethods.hasOwnProperty(index)) {\n          banProperty(obj, bannedMethods[index]);\n        }\n      }\n\n      // Freeze it and return it.\n      Object.freeze(obj);\n    }\n\n    return obj;\n  }\n\n  function makeMethodReturnImmutable(obj, methodName) {\n    var currentMethod = obj[methodName];\n\n    addPropertyTo(obj, methodName, function() {\n      return Immutable(currentMethod.apply(obj, arguments));\n    });\n  }\n\n  function arraySet(idx, value, config) {\n    var deep          = config && config.deep;\n\n    if (idx in this) {\n      if (deep && this[idx] !== value && isMergableObject(value) && isMergableObject(this[idx])) {\n        value = Immutable.merge(this[idx], value, {deep: true, mode: 'replace'});\n      }\n      if (isEqual(this[idx], value)) {\n        return this;\n      }\n    }\n\n    var mutable = asMutableArray.call(this);\n    mutable[idx] = Immutable(value);\n    return makeImmutableArray(mutable);\n  }\n\n  var immutableEmptyArray = Immutable([]);\n\n  function arraySetIn(pth, value, config) {\n    var head = pth[0];\n\n    if (pth.length === 1) {\n      return arraySet.call(this, head, value, config);\n    } else {\n      var tail = pth.slice(1);\n      var thisHead = this[head];\n      var newValue;\n\n      if (typeof(thisHead) === \"object\" && thisHead !== null) {\n        // Might (validly) be object or array\n        newValue = Immutable.setIn(thisHead, tail, value);\n      } else {\n        var nextHead = tail[0];\n        // If the next path part is a number, then we are setting into an array, else an object.\n        if (nextHead !== '' && isFinite(nextHead)) {\n          newValue = arraySetIn.call(immutableEmptyArray, tail, value);\n        } else {\n          newValue = objectSetIn.call(immutableEmptyObject, tail, value);\n        }\n      }\n\n      if (head in this && thisHead === newValue) {\n        return this;\n      }\n\n      var mutable = asMutableArray.call(this);\n      mutable[head] = newValue;\n      return makeImmutableArray(mutable);\n    }\n  }\n\n  function makeImmutableArray(array) {\n    // Don't change their implementations, but wrap these functions to make sure\n    // they always return an immutable value.\n    for (var index in nonMutatingArrayMethods) {\n      if (nonMutatingArrayMethods.hasOwnProperty(index)) {\n        var methodName = nonMutatingArrayMethods[index];\n        makeMethodReturnImmutable(array, methodName);\n      }\n    }\n\n    if (!globalConfig.use_static) {\n      addPropertyTo(array, \"flatMap\",  flatMap);\n      addPropertyTo(array, \"asObject\", asObject);\n      addPropertyTo(array, \"asMutable\", asMutableArray);\n      addPropertyTo(array, \"set\", arraySet);\n      addPropertyTo(array, \"setIn\", arraySetIn);\n      addPropertyTo(array, \"update\", update);\n      addPropertyTo(array, \"updateIn\", updateIn);\n      addPropertyTo(array, \"getIn\", getIn);\n    }\n\n    for(var i = 0, length = array.length; i < length; i++) {\n      array[i] = Immutable(array[i]);\n    }\n\n    return makeImmutable(array, mutatingArrayMethods);\n  }\n\n  function makeImmutableDate(date) {\n    if (!globalConfig.use_static) {\n      addPropertyTo(date, \"asMutable\", asMutableDate);\n    }\n\n    return makeImmutable(date, mutatingDateMethods);\n  }\n\n  function asMutableDate() {\n    return new Date(this.getTime());\n  }\n\n  /**\n   * Effectively performs a map() over the elements in the array, using the\n   * provided iterator, except that whenever the iterator returns an array, that\n   * array's elements are added to the final result instead of the array itself.\n   *\n   * @param {function} iterator - The iterator function that will be invoked on each element in the array. It will receive three arguments: the current value, the current index, and the current object.\n   */\n  function flatMap(iterator) {\n    // Calling .flatMap() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\n\n    var result = [],\n        length = this.length,\n        index;\n\n    for (index = 0; index < length; index++) {\n      var iteratorResult = iterator(this[index], index, this);\n\n      if (Array.isArray(iteratorResult)) {\n        // Concatenate Array results into the return value we're building up.\n        result.push.apply(result, iteratorResult);\n      } else {\n        // Handle non-Array results the same way map() does.\n        result.push(iteratorResult);\n      }\n    }\n\n    return makeImmutableArray(result);\n  }\n\n  /**\n   * Returns an Immutable copy of the object without the given keys included.\n   *\n   * @param {array} keysToRemove - A list of strings representing the keys to exclude in the return value. Instead of providing a single array, this method can also be called by passing multiple strings as separate arguments.\n   */\n  function without(remove) {\n    // Calling .without() with no arguments is a no-op. Don't bother cloning.\n    if (typeof remove === \"undefined\" && arguments.length === 0) {\n      return this;\n    }\n\n    if (typeof remove !== \"function\") {\n      // If we weren't given an array, use the arguments list.\n      var keysToRemoveArray = (Array.isArray(remove)) ?\n         remove.slice() : Array.prototype.slice.call(arguments);\n\n      // Convert numeric keys to strings since that's how they'll\n      // come from the enumeration of the object.\n      keysToRemoveArray.forEach(function(el, idx, arr) {\n        if(typeof(el) === \"number\") {\n          arr[idx] = el.toString();\n        }\n      });\n\n      remove = function(val, key) {\n        return keysToRemoveArray.indexOf(key) !== -1;\n      };\n    }\n\n    var result = instantiateEmptyObject(this);\n\n    for (var key in this) {\n      if (this.hasOwnProperty(key) && remove(this[key], key) === false) {\n        result[key] = this[key];\n      }\n    }\n\n    return makeImmutableObject(result);\n  }\n\n  function asMutableArray(opts) {\n    var result = [], i, length;\n\n    if(opts && opts.deep) {\n      for(i = 0, length = this.length; i < length; i++) {\n        result.push(asDeepMutable(this[i]));\n      }\n    } else {\n      for(i = 0, length = this.length; i < length; i++) {\n        result.push(this[i]);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Effectively performs a [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) over the elements in the array, expecting that the iterator function\n   * will return an array of two elements - the first representing a key, the other\n   * a value. Then returns an Immutable Object constructed of those keys and values.\n   *\n   * @param {function} iterator - A function which should return an array of two elements - the first representing the desired key, the other the desired value.\n   */\n  function asObject(iterator) {\n    // If no iterator was provided, assume the identity function\n    // (suggesting this array is already a list of key/value pairs.)\n    if (typeof iterator !== \"function\") {\n      iterator = function(value) { return value; };\n    }\n\n    var result = {},\n        length = this.length,\n        index;\n\n    for (index = 0; index < length; index++) {\n      var pair  = iterator(this[index], index, this),\n          key   = pair[0],\n          value = pair[1];\n\n      result[key] = value;\n    }\n\n    return makeImmutableObject(result);\n  }\n\n  function asDeepMutable(obj) {\n    if (\n      (!obj) ||\n      (typeof obj !== 'object') ||\n      (!Object.getOwnPropertyDescriptor(obj, immutabilityTag)) ||\n      (obj instanceof Date)\n    ) { return obj; }\n    return Immutable.asMutable(obj, {deep: true});\n  }\n\n  function quickCopy(src, dest) {\n    for (var key in src) {\n      if (Object.getOwnPropertyDescriptor(src, key)) {\n        dest[key] = src[key];\n      }\n    }\n\n    return dest;\n  }\n\n  /**\n   * Returns an Immutable Object containing the properties and values of both\n   * this object and the provided object, prioritizing the provided object's\n   * values whenever the same key is present in both objects.\n   *\n   * @param {object} other - The other object to merge. Multiple objects can be passed as an array. In such a case, the later an object appears in that list, the higher its priority.\n   * @param {object} config - Optional config object that contains settings. Supported settings are: {deep: true} for deep merge and {merger: mergerFunc} where mergerFunc is a function\n   *                          that takes a property from both objects. If anything is returned it overrides the normal merge behaviour.\n   */\n  function merge(other, config) {\n    // Calling .merge() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\n\n    if (other === null || (typeof other !== \"object\")) {\n      throw new TypeError(\"Immutable#merge can only be invoked with objects or arrays, not \" + JSON.stringify(other));\n    }\n\n    var receivedArray = (Array.isArray(other)),\n        deep          = config && config.deep,\n        mode          = config && config.mode || 'merge',\n        merger        = config && config.merger,\n        result;\n\n    // Use the given key to extract a value from the given object, then place\n    // that value in the result object under the same key. If that resulted\n    // in a change from this object's value at that key, set anyChanges = true.\n    function addToResult(currentObj, otherObj, key) {\n      var immutableValue = Immutable(otherObj[key]);\n      var mergerResult = merger && merger(currentObj[key], immutableValue, config);\n      var currentValue = currentObj[key];\n\n      if ((result !== undefined) ||\n        (mergerResult !== undefined) ||\n        (!currentObj.hasOwnProperty(key)) ||\n        !isEqual(immutableValue, currentValue)) {\n\n        var newValue;\n\n        if (mergerResult !== undefined) {\n          newValue = mergerResult;\n        } else if (deep && isMergableObject(currentValue) && isMergableObject(immutableValue)) {\n          newValue = Immutable.merge(currentValue, immutableValue, config);\n        } else {\n          newValue = immutableValue;\n        }\n\n        if (!isEqual(currentValue, newValue) || !currentObj.hasOwnProperty(key)) {\n          if (result === undefined) {\n            // Make a shallow clone of the current object.\n            result = quickCopy(currentObj, instantiateEmptyObject(currentObj));\n          }\n\n          result[key] = newValue;\n        }\n      }\n    }\n\n    function clearDroppedKeys(currentObj, otherObj) {\n      for (var key in currentObj) {\n        if (!otherObj.hasOwnProperty(key)) {\n          if (result === undefined) {\n            // Make a shallow clone of the current object.\n            result = quickCopy(currentObj, instantiateEmptyObject(currentObj));\n          }\n          delete result[key];\n        }\n      }\n    }\n\n    var key;\n\n    // Achieve prioritization by overriding previous values that get in the way.\n    if (!receivedArray) {\n      // The most common use case: just merge one object into the existing one.\n      for (key in other) {\n        if (Object.getOwnPropertyDescriptor(other, key)) {\n          addToResult(this, other, key);\n        }\n      }\n      if (mode === 'replace') {\n        clearDroppedKeys(this, other);\n      }\n    } else {\n      // We also accept an Array\n      for (var index = 0, length = other.length; index < length; index++) {\n        var otherFromArray = other[index];\n\n        for (key in otherFromArray) {\n          if (otherFromArray.hasOwnProperty(key)) {\n            addToResult(result !== undefined ? result : this, otherFromArray, key);\n          }\n        }\n      }\n    }\n\n    if (result === undefined) {\n      return this;\n    } else {\n      return makeImmutableObject(result);\n    }\n  }\n\n  function objectReplace(value, config) {\n    var deep          = config && config.deep;\n\n    // Calling .replace() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\n\n    if (value === null || typeof value !== \"object\") {\n      throw new TypeError(\"Immutable#replace can only be invoked with objects or arrays, not \" + JSON.stringify(value));\n    }\n\n    return Immutable.merge(this, value, {deep: deep, mode: 'replace'});\n  }\n\n  var immutableEmptyObject = Immutable({});\n\n  function objectSetIn(path, value, config) {\n    if (!(Array.isArray(path)) || path.length === 0) {\n      throw new TypeError(\"The first argument to Immutable#setIn must be an array containing at least one \\\"key\\\" string.\");\n    }\n\n    var head = path[0];\n    if (path.length === 1) {\n      return objectSet.call(this, head, value, config);\n    }\n\n    var tail = path.slice(1);\n    var newValue;\n    var thisHead = this[head];\n\n    if (this.hasOwnProperty(head) && typeof(thisHead) === \"object\" && thisHead !== null) {\n      // Might (validly) be object or array\n      newValue = Immutable.setIn(thisHead, tail, value);\n    } else {\n      newValue = objectSetIn.call(immutableEmptyObject, tail, value);\n    }\n\n    if (this.hasOwnProperty(head) && thisHead === newValue) {\n      return this;\n    }\n\n    var mutable = quickCopy(this, instantiateEmptyObject(this));\n    mutable[head] = newValue;\n    return makeImmutableObject(mutable);\n  }\n\n  function objectSet(property, value, config) {\n    var deep          = config && config.deep;\n\n    if (this.hasOwnProperty(property)) {\n      if (deep && this[property] !== value && isMergableObject(value) && isMergableObject(this[property])) {\n        value = Immutable.merge(this[property], value, {deep: true, mode: 'replace'});\n      }\n      if (isEqual(this[property], value)) {\n        return this;\n      }\n    }\n\n    var mutable = quickCopy(this, instantiateEmptyObject(this));\n    mutable[property] = Immutable(value);\n    return makeImmutableObject(mutable);\n  }\n\n  function update(property, updater) {\n    var restArgs = Array.prototype.slice.call(arguments, 2);\n    var initialVal = this[property];\n    return Immutable.set(this, property, updater.apply(initialVal, [initialVal].concat(restArgs)));\n  }\n\n  function getInPath(obj, path) {\n    /*jshint eqnull:true */\n    for (var i = 0, l = path.length; obj != null && i < l; i++) {\n      obj = obj[path[i]];\n    }\n\n    return (i && i == l) ? obj : undefined;\n  }\n\n  function updateIn(path, updater) {\n    var restArgs = Array.prototype.slice.call(arguments, 2);\n    var initialVal = getInPath(this, path);\n\n    return Immutable.setIn(this, path, updater.apply(initialVal, [initialVal].concat(restArgs)));\n  }\n\n  function getIn(path, defaultValue) {\n    var value = getInPath(this, path);\n    return value === undefined ? defaultValue : value;\n  }\n\n  function asMutableObject(opts) {\n    var result = instantiateEmptyObject(this), key;\n\n    if(opts && opts.deep) {\n      for (key in this) {\n        if (this.hasOwnProperty(key)) {\n          result[key] = asDeepMutable(this[key]);\n        }\n      }\n    } else {\n      for (key in this) {\n        if (this.hasOwnProperty(key)) {\n          result[key] = this[key];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  // Creates plain object to be used for cloning\n  function instantiatePlainObject() {\n    return {};\n  }\n\n  // Finalizes an object with immutable methods, freezes it, and returns it.\n  function makeImmutableObject(obj) {\n    if (!globalConfig.use_static) {\n      addPropertyTo(obj, \"merge\", merge);\n      addPropertyTo(obj, \"replace\", objectReplace);\n      addPropertyTo(obj, \"without\", without);\n      addPropertyTo(obj, \"asMutable\", asMutableObject);\n      addPropertyTo(obj, \"set\", objectSet);\n      addPropertyTo(obj, \"setIn\", objectSetIn);\n      addPropertyTo(obj, \"update\", update);\n      addPropertyTo(obj, \"updateIn\", updateIn);\n      addPropertyTo(obj, \"getIn\", getIn);\n    }\n\n    return makeImmutable(obj, mutatingObjectMethods);\n  }\n\n  // Returns true if object is a valid react element\n  // https://github.com/facebook/react/blob/v15.0.1/src/isomorphic/classic/element/ReactElement.js#L326\n  function isReactElement(obj) {\n    return typeof obj === 'object' &&\n           obj !== null &&\n           (obj.$$typeof === REACT_ELEMENT_TYPE_FALLBACK || obj.$$typeof === REACT_ELEMENT_TYPE);\n  }\n\n  function isFileObject(obj) {\n    return typeof File !== 'undefined' &&\n           obj instanceof File;\n  }\n\n  function isBlobObject(obj) {\n    return typeof Blob !== 'undefined' &&\n           obj instanceof Blob;\n  }\n\n  function isPromise(obj) {\n    return typeof obj === 'object' &&\n           typeof obj.then === 'function';\n  }\n\n  function isError(obj) {\n    return obj instanceof Error;\n  }\n\n  function Immutable(obj, options, stackRemaining) {\n    if (isImmutable(obj) || isReactElement(obj) || isFileObject(obj) || isBlobObject(obj) || isError(obj)) {\n      return obj;\n    } else if (isPromise(obj)) {\n      return obj.then(Immutable);\n    } else if (Array.isArray(obj)) {\n      return makeImmutableArray(obj.slice());\n    } else if (obj instanceof Date) {\n      return makeImmutableDate(new Date(obj.getTime()));\n    } else {\n      // Don't freeze the object we were given; make a clone and use that.\n      var prototype = options && options.prototype;\n      var instantiateEmptyObject =\n        (!prototype || prototype === Object.prototype) ?\n          instantiatePlainObject : (function() { return Object.create(prototype); });\n      var clone = instantiateEmptyObject();\n\n      if (\"development\" !== \"production\") {\n        /*jshint eqnull:true */\n        if (stackRemaining == null) {\n          stackRemaining = 64;\n        }\n        if (stackRemaining <= 0) {\n          throw new ImmutableError(\"Attempt to construct Immutable from a deeply nested object was detected.\" +\n            \" Have you tried to wrap an object with circular references (e.g. React element)?\" +\n            \" See https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected for details.\");\n        }\n        stackRemaining -= 1;\n      }\n\n      for (var key in obj) {\n        if (Object.getOwnPropertyDescriptor(obj, key)) {\n          clone[key] = Immutable(obj[key], undefined, stackRemaining);\n        }\n      }\n\n      return makeImmutableObject(clone);\n    }\n  }\n\n  // Wrapper to allow the use of object methods as static methods of Immutable.\n  function toStatic(fn) {\n    function staticWrapper() {\n      var args = [].slice.call(arguments);\n      var self = args.shift();\n      return fn.apply(self, args);\n    }\n\n    return staticWrapper;\n  }\n\n  // Wrapper to allow the use of object methods as static methods of Immutable.\n  // with the additional condition of choosing which function to call depending\n  // if argument is an array or an object.\n  function toStaticObjectOrArray(fnObject, fnArray) {\n    function staticWrapper() {\n      var args = [].slice.call(arguments);\n      var self = args.shift();\n      if (Array.isArray(self)) {\n          return fnArray.apply(self, args);\n      } else {\n          return fnObject.apply(self, args);\n      }\n    }\n\n    return staticWrapper;\n  }\n\n  // Wrapper to allow the use of object methods as static methods of Immutable.\n  // with the additional condition of choosing which function to call depending\n  // if argument is an array or an object or a date.\n  function toStaticObjectOrDateOrArray(fnObject, fnArray, fnDate) {\n    function staticWrapper() {\n      var args = [].slice.call(arguments);\n      var self = args.shift();\n      if (Array.isArray(self)) {\n          return fnArray.apply(self, args);\n      } else if (self instanceof Date) {\n          return fnDate.apply(self, args);\n      } else {\n          return fnObject.apply(self, args);\n      }\n    }\n\n    return staticWrapper;\n  }\n\n  // Export the library\n  Immutable.from           = Immutable;\n  Immutable.isImmutable    = isImmutable;\n  Immutable.ImmutableError = ImmutableError;\n  Immutable.merge          = toStatic(merge);\n  Immutable.replace        = toStatic(objectReplace);\n  Immutable.without        = toStatic(without);\n  Immutable.asMutable      = toStaticObjectOrDateOrArray(asMutableObject, asMutableArray, asMutableDate);\n  Immutable.set            = toStaticObjectOrArray(objectSet, arraySet);\n  Immutable.setIn          = toStaticObjectOrArray(objectSetIn, arraySetIn);\n  Immutable.update         = toStatic(update);\n  Immutable.updateIn       = toStatic(updateIn);\n  Immutable.getIn          = toStatic(getIn);\n  Immutable.flatMap        = toStatic(flatMap);\n  Immutable.asObject       = toStatic(asObject);\n  if (!globalConfig.use_static) {\n      Immutable.static = immutableInit({\n          use_static: true\n      });\n  }\n\n  Object.freeze(Immutable);\n\n  return Immutable;\n}\n\n  var Immutable = immutableInit();\n  /* istanbul ignore if */\n  if (typeof define === 'function' && define.amd) {\n    define(function() {\n      return Immutable;\n    });\n  } else if (typeof module === \"object\") {\n    module.exports = Immutable;\n  } else if (typeof exports === \"object\") {\n    exports.Immutable = Immutable;\n  } else if (typeof window === \"object\") {\n    window.Immutable = Immutable;\n  } else if (typeof global === \"object\") {\n    global.Immutable = Immutable;\n  }\n})();\n"
        },
        {
          "name": "seamless-immutable.development.min.js",
          "type": "blob",
          "size": 7.806640625,
          "content": "/* (c) 2017, Richard Feldman, github.com/rtfeldman/seamless-immutable/blob/master/LICENSE */!function(){\"use strict\";function a(b){function c(a){return\"object\"==typeof a&&!Array.isArray(a)&&null!==a}function d(a){var b=Object.getPrototypeOf(a);return b?Object.create(b):{}}function e(a,b,c){Object.defineProperty(a,b,{enumerable:!1,configurable:!1,writable:!1,value:c})}function f(a,b){e(a,b,function(){throw new k(\"The \"+b+\" method cannot be invoked on an Immutable data structure.\")})}function g(a){e(a,V,!0)}function h(a){return\"object\"!=typeof a||(null===a||Boolean(Object.getOwnPropertyDescriptor(a,V)))}function i(a,b){return a===b||a!==a&&b!==b}function j(a){return!(null===a||\"object\"!=typeof a||Array.isArray(a)||a instanceof Date)}function k(a){this.name=\"MyError\",this.message=a,this.stack=(new Error).stack}function l(a,b){g(a);for(var c in b)b.hasOwnProperty(c)&&f(a,b[c]);return Object.freeze(a),a}function m(a,b){var c=a[b];e(a,b,function(){return O(c.apply(a,arguments))})}function n(a,b,c){var d=c&&c.deep;if(a in this&&(d&&this[a]!==b&&j(b)&&j(this[a])&&(b=O.merge(this[a],b,{deep:!0,mode:\"replace\"})),i(this[a],b)))return this;var e=u.call(this);return e[a]=O(b),p(e)}function o(a,b,c){var d=a[0];if(1===a.length)return n.call(this,d,b,c);var e,f=a.slice(1),g=this[d];if(\"object\"==typeof g&&null!==g)e=O.setIn(g,f,b);else{var h=f[0];e=\"\"!==h&&isFinite(h)?o.call(_,f,b):A.call(aa,f,b)}if(d in this&&g===e)return this;var i=u.call(this);return i[d]=e,p(i)}function p(a){for(var b in Z)if(Z.hasOwnProperty(b)){var c=Z[b];m(a,c)}U.use_static||(e(a,\"flatMap\",s),e(a,\"asObject\",v),e(a,\"asMutable\",u),e(a,\"set\",n),e(a,\"setIn\",o),e(a,\"update\",C),e(a,\"updateIn\",E),e(a,\"getIn\",F));for(var d=0,f=a.length;d<f;d++)a[d]=O(a[d]);return l(a,Y)}function q(a){return U.use_static||e(a,\"asMutable\",r),l(a,$)}function r(){return new Date(this.getTime())}function s(a){if(0===arguments.length)return this;var b,c=[],d=this.length;for(b=0;b<d;b++){var e=a(this[b],b,this);Array.isArray(e)?c.push.apply(c,e):c.push(e)}return p(c)}function t(a){if(\"undefined\"==typeof a&&0===arguments.length)return this;if(\"function\"!=typeof a){var b=Array.isArray(a)?a.slice():Array.prototype.slice.call(arguments);b.forEach(function(a,b,c){\"number\"==typeof a&&(c[b]=a.toString())}),a=function(a,c){return b.indexOf(c)!==-1}}var c=d(this);for(var e in this)this.hasOwnProperty(e)&&a(this[e],e)===!1&&(c[e]=this[e]);return I(c)}function u(a){var b,c,d=[];if(a&&a.deep)for(b=0,c=this.length;b<c;b++)d.push(w(this[b]));else for(b=0,c=this.length;b<c;b++)d.push(this[b]);return d}function v(a){\"function\"!=typeof a&&(a=function(a){return a});var b,c={},d=this.length;for(b=0;b<d;b++){var e=a(this[b],b,this),f=e[0],g=e[1];c[f]=g}return I(c)}function w(a){return!a||\"object\"!=typeof a||!Object.getOwnPropertyDescriptor(a,V)||a instanceof Date?a:O.asMutable(a,{deep:!0})}function x(a,b){for(var c in a)Object.getOwnPropertyDescriptor(a,c)&&(b[c]=a[c]);return b}function y(a,b){function c(a,c,e){var g=O(c[e]),h=m&&m(a[e],g,b),l=a[e];if(void 0!==f||void 0!==h||!a.hasOwnProperty(e)||!i(g,l)){var n;n=void 0!==h?h:k&&j(l)&&j(g)?O.merge(l,g,b):g,i(l,n)&&a.hasOwnProperty(e)||(void 0===f&&(f=x(a,d(a))),f[e]=n)}}function e(a,b){for(var c in a)b.hasOwnProperty(c)||(void 0===f&&(f=x(a,d(a))),delete f[c])}if(0===arguments.length)return this;if(null===a||\"object\"!=typeof a)throw new TypeError(\"Immutable#merge can only be invoked with objects or arrays, not \"+JSON.stringify(a));var f,g,h=Array.isArray(a),k=b&&b.deep,l=b&&b.mode||\"merge\",m=b&&b.merger;if(h)for(var n=0,o=a.length;n<o;n++){var p=a[n];for(g in p)p.hasOwnProperty(g)&&c(void 0!==f?f:this,p,g)}else{for(g in a)Object.getOwnPropertyDescriptor(a,g)&&c(this,a,g);\"replace\"===l&&e(this,a)}return void 0===f?this:I(f)}function z(a,b){var c=b&&b.deep;if(0===arguments.length)return this;if(null===a||\"object\"!=typeof a)throw new TypeError(\"Immutable#replace can only be invoked with objects or arrays, not \"+JSON.stringify(a));return O.merge(this,a,{deep:c,mode:\"replace\"})}function A(a,b,c){if(!Array.isArray(a)||0===a.length)throw new TypeError('The first argument to Immutable#setIn must be an array containing at least one \"key\" string.');var e=a[0];if(1===a.length)return B.call(this,e,b,c);var f,g=a.slice(1),h=this[e];if(f=this.hasOwnProperty(e)&&\"object\"==typeof h&&null!==h?O.setIn(h,g,b):A.call(aa,g,b),this.hasOwnProperty(e)&&h===f)return this;var i=x(this,d(this));return i[e]=f,I(i)}function B(a,b,c){var e=c&&c.deep;if(this.hasOwnProperty(a)&&(e&&this[a]!==b&&j(b)&&j(this[a])&&(b=O.merge(this[a],b,{deep:!0,mode:\"replace\"})),i(this[a],b)))return this;var f=x(this,d(this));return f[a]=O(b),I(f)}function C(a,b){var c=Array.prototype.slice.call(arguments,2),d=this[a];return O.set(this,a,b.apply(d,[d].concat(c)))}function D(a,b){for(var c=0,d=b.length;null!=a&&c<d;c++)a=a[b[c]];return c&&c==d?a:void 0}function E(a,b){var c=Array.prototype.slice.call(arguments,2),d=D(this,a);return O.setIn(this,a,b.apply(d,[d].concat(c)))}function F(a,b){var c=D(this,a);return void 0===c?b:c}function G(a){var b,c=d(this);if(a&&a.deep)for(b in this)this.hasOwnProperty(b)&&(c[b]=w(this[b]));else for(b in this)this.hasOwnProperty(b)&&(c[b]=this[b]);return c}function H(){return{}}function I(a){return U.use_static||(e(a,\"merge\",y),e(a,\"replace\",z),e(a,\"without\",t),e(a,\"asMutable\",G),e(a,\"set\",B),e(a,\"setIn\",A),e(a,\"update\",C),e(a,\"updateIn\",E),e(a,\"getIn\",F)),l(a,W)}function J(a){return\"object\"==typeof a&&null!==a&&(a.$$typeof===T||a.$$typeof===S)}function K(a){return\"undefined\"!=typeof File&&a instanceof File}function L(a){return\"undefined\"!=typeof Blob&&a instanceof Blob}function M(a){return\"object\"==typeof a&&\"function\"==typeof a.then}function N(a){return a instanceof Error}function O(a,b,c){if(h(a)||J(a)||K(a)||L(a)||N(a))return a;if(M(a))return a.then(O);if(Array.isArray(a))return p(a.slice());if(a instanceof Date)return q(new Date(a.getTime()));var d=b&&b.prototype,e=d&&d!==Object.prototype?function(){return Object.create(d)}:H,f=e();if(null==c&&(c=64),c<=0)throw new k(\"Attempt to construct Immutable from a deeply nested object was detected. Have you tried to wrap an object with circular references (e.g. React element)? See https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected for details.\");c-=1;for(var g in a)Object.getOwnPropertyDescriptor(a,g)&&(f[g]=O(a[g],void 0,c));return I(f)}function P(a){function b(){var b=[].slice.call(arguments),c=b.shift();return a.apply(c,b)}return b}function Q(a,b){function c(){var c=[].slice.call(arguments),d=c.shift();return Array.isArray(d)?b.apply(d,c):a.apply(d,c)}return c}function R(a,b,c){function d(){var d=[].slice.call(arguments),e=d.shift();return Array.isArray(e)?b.apply(e,d):e instanceof Date?c.apply(e,d):a.apply(e,d)}return d}var S=\"function\"==typeof Symbol&&Symbol[\"for\"]&&Symbol[\"for\"](\"react.element\"),T=60103,U={use_static:!1};c(b)&&void 0!==b.use_static&&(U.use_static=Boolean(b.use_static));var V=\"__immutable_invariants_hold\",W=[\"setPrototypeOf\"],X=[\"keys\"],Y=W.concat([\"push\",\"pop\",\"sort\",\"splice\",\"shift\",\"unshift\",\"reverse\"]),Z=X.concat([\"map\",\"filter\",\"slice\",\"concat\",\"reduce\",\"reduceRight\"]),$=W.concat([\"setDate\",\"setFullYear\",\"setHours\",\"setMilliseconds\",\"setMinutes\",\"setMonth\",\"setSeconds\",\"setTime\",\"setUTCDate\",\"setUTCFullYear\",\"setUTCHours\",\"setUTCMilliseconds\",\"setUTCMinutes\",\"setUTCMonth\",\"setUTCSeconds\",\"setYear\"]);k.prototype=new Error,k.prototype.constructor=Error;var _=O([]),aa=O({});return O.from=O,O.isImmutable=h,O.ImmutableError=k,O.merge=P(y),O.replace=P(z),O.without=P(t),O.asMutable=R(G,u,r),O.set=Q(B,n),O.setIn=Q(A,o),O.update=P(C),O.updateIn=P(E),O.getIn=P(F),O.flatMap=P(s),O.asObject=P(v),U.use_static||(O[\"static\"]=a({use_static:!0})),Object.freeze(O),O}var b=a();\"function\"==typeof define&&define.amd?define(function(){return b}):\"object\"==typeof module?module.exports=b:\"object\"==typeof exports?exports.Immutable=b:\"object\"==typeof window?window.Immutable=b:\"object\"==typeof global&&(global.Immutable=b)}();"
        },
        {
          "name": "seamless-immutable.production.min.js",
          "type": "blob",
          "size": 7.333984375,
          "content": "/* (c) 2017, Richard Feldman, github.com/rtfeldman/seamless-immutable/blob/master/LICENSE */!function(){\"use strict\";function a(b){function c(a){return\"object\"==typeof a&&!Array.isArray(a)&&null!==a}function d(a){var b=Object.getPrototypeOf(a);return b?Object.create(b):{}}function e(a,b,c){Object.defineProperty(a,b,{enumerable:!1,configurable:!1,writable:!1,value:c})}function f(a){e(a,U,!0)}function g(a){return\"object\"!=typeof a||(null===a||Boolean(Object.getOwnPropertyDescriptor(a,U)))}function h(a,b){return a===b||a!==a&&b!==b}function i(a){return!(null===a||\"object\"!=typeof a||Array.isArray(a)||a instanceof Date)}function j(a){this.name=\"MyError\",this.message=a,this.stack=(new Error).stack}function k(a,b){f(a);return a}function l(a,b){var c=a[b];e(a,b,function(){return N(c.apply(a,arguments))})}function m(a,b,c){var d=c&&c.deep;if(a in this&&(d&&this[a]!==b&&i(b)&&i(this[a])&&(b=N.merge(this[a],b,{deep:!0,mode:\"replace\"})),h(this[a],b)))return this;var e=t.call(this);return e[a]=N(b),o(e)}function n(a,b,c){var d=a[0];if(1===a.length)return m.call(this,d,b,c);var e,f=a.slice(1),g=this[d];if(\"object\"==typeof g&&null!==g)e=N.setIn(g,f,b);else{var h=f[0];e=\"\"!==h&&isFinite(h)?n.call($,f,b):z.call(_,f,b)}if(d in this&&g===e)return this;var i=t.call(this);return i[d]=e,o(i)}function o(a){for(var b in Y)if(Y.hasOwnProperty(b)){var c=Y[b];l(a,c)}T.use_static||(e(a,\"flatMap\",r),e(a,\"asObject\",u),e(a,\"asMutable\",t),e(a,\"set\",m),e(a,\"setIn\",n),e(a,\"update\",B),e(a,\"updateIn\",D),e(a,\"getIn\",E));for(var d=0,f=a.length;d<f;d++)a[d]=N(a[d]);return k(a,X)}function p(a){return T.use_static||e(a,\"asMutable\",q),k(a,Z)}function q(){return new Date(this.getTime())}function r(a){if(0===arguments.length)return this;var b,c=[],d=this.length;for(b=0;b<d;b++){var e=a(this[b],b,this);Array.isArray(e)?c.push.apply(c,e):c.push(e)}return o(c)}function s(a){if(\"undefined\"==typeof a&&0===arguments.length)return this;if(\"function\"!=typeof a){var b=Array.isArray(a)?a.slice():Array.prototype.slice.call(arguments);b.forEach(function(a,b,c){\"number\"==typeof a&&(c[b]=a.toString())}),a=function(a,c){return b.indexOf(c)!==-1}}var c=d(this);for(var e in this)this.hasOwnProperty(e)&&a(this[e],e)===!1&&(c[e]=this[e]);return H(c)}function t(a){var b,c,d=[];if(a&&a.deep)for(b=0,c=this.length;b<c;b++)d.push(v(this[b]));else for(b=0,c=this.length;b<c;b++)d.push(this[b]);return d}function u(a){\"function\"!=typeof a&&(a=function(a){return a});var b,c={},d=this.length;for(b=0;b<d;b++){var e=a(this[b],b,this),f=e[0],g=e[1];c[f]=g}return H(c)}function v(a){return!a||\"object\"!=typeof a||!Object.getOwnPropertyDescriptor(a,U)||a instanceof Date?a:N.asMutable(a,{deep:!0})}function w(a,b){for(var c in a)Object.getOwnPropertyDescriptor(a,c)&&(b[c]=a[c]);return b}function x(a,b){function c(a,c,e){var g=N(c[e]),j=m&&m(a[e],g,b),l=a[e];if(void 0!==f||void 0!==j||!a.hasOwnProperty(e)||!h(g,l)){var n;n=void 0!==j?j:k&&i(l)&&i(g)?N.merge(l,g,b):g,h(l,n)&&a.hasOwnProperty(e)||(void 0===f&&(f=w(a,d(a))),f[e]=n)}}function e(a,b){for(var c in a)b.hasOwnProperty(c)||(void 0===f&&(f=w(a,d(a))),delete f[c])}if(0===arguments.length)return this;if(null===a||\"object\"!=typeof a)throw new TypeError(\"Immutable#merge can only be invoked with objects or arrays, not \"+JSON.stringify(a));var f,g,j=Array.isArray(a),k=b&&b.deep,l=b&&b.mode||\"merge\",m=b&&b.merger;if(j)for(var n=0,o=a.length;n<o;n++){var p=a[n];for(g in p)p.hasOwnProperty(g)&&c(void 0!==f?f:this,p,g)}else{for(g in a)Object.getOwnPropertyDescriptor(a,g)&&c(this,a,g);\"replace\"===l&&e(this,a)}return void 0===f?this:H(f)}function y(a,b){var c=b&&b.deep;if(0===arguments.length)return this;if(null===a||\"object\"!=typeof a)throw new TypeError(\"Immutable#replace can only be invoked with objects or arrays, not \"+JSON.stringify(a));return N.merge(this,a,{deep:c,mode:\"replace\"})}function z(a,b,c){if(!Array.isArray(a)||0===a.length)throw new TypeError('The first argument to Immutable#setIn must be an array containing at least one \"key\" string.');var e=a[0];if(1===a.length)return A.call(this,e,b,c);var f,g=a.slice(1),h=this[e];if(f=this.hasOwnProperty(e)&&\"object\"==typeof h&&null!==h?N.setIn(h,g,b):z.call(_,g,b),this.hasOwnProperty(e)&&h===f)return this;var i=w(this,d(this));return i[e]=f,H(i)}function A(a,b,c){var e=c&&c.deep;if(this.hasOwnProperty(a)&&(e&&this[a]!==b&&i(b)&&i(this[a])&&(b=N.merge(this[a],b,{deep:!0,mode:\"replace\"})),h(this[a],b)))return this;var f=w(this,d(this));return f[a]=N(b),H(f)}function B(a,b){var c=Array.prototype.slice.call(arguments,2),d=this[a];return N.set(this,a,b.apply(d,[d].concat(c)))}function C(a,b){for(var c=0,d=b.length;null!=a&&c<d;c++)a=a[b[c]];return c&&c==d?a:void 0}function D(a,b){var c=Array.prototype.slice.call(arguments,2),d=C(this,a);return N.setIn(this,a,b.apply(d,[d].concat(c)))}function E(a,b){var c=C(this,a);return void 0===c?b:c}function F(a){var b,c=d(this);if(a&&a.deep)for(b in this)this.hasOwnProperty(b)&&(c[b]=v(this[b]));else for(b in this)this.hasOwnProperty(b)&&(c[b]=this[b]);return c}function G(){return{}}function H(a){return T.use_static||(e(a,\"merge\",x),e(a,\"replace\",y),e(a,\"without\",s),e(a,\"asMutable\",F),e(a,\"set\",A),e(a,\"setIn\",z),e(a,\"update\",B),e(a,\"updateIn\",D),e(a,\"getIn\",E)),k(a,V)}function I(a){return\"object\"==typeof a&&null!==a&&(a.$$typeof===S||a.$$typeof===R)}function J(a){return\"undefined\"!=typeof File&&a instanceof File}function K(a){return\"undefined\"!=typeof Blob&&a instanceof Blob}function L(a){return\"object\"==typeof a&&\"function\"==typeof a.then}function M(a){return a instanceof Error}function N(a,b,c){if(g(a)||I(a)||J(a)||K(a)||M(a))return a;if(L(a))return a.then(N);if(Array.isArray(a))return o(a.slice());if(a instanceof Date)return p(new Date(a.getTime()));var d=b&&b.prototype,e=d&&d!==Object.prototype?function(){return Object.create(d)}:G,f=e();for(var h in a)Object.getOwnPropertyDescriptor(a,h)&&(f[h]=N(a[h],void 0,c));return H(f)}function O(a){function b(){var b=[].slice.call(arguments),c=b.shift();return a.apply(c,b)}return b}function P(a,b){function c(){var c=[].slice.call(arguments),d=c.shift();return Array.isArray(d)?b.apply(d,c):a.apply(d,c)}return c}function Q(a,b,c){function d(){var d=[].slice.call(arguments),e=d.shift();return Array.isArray(e)?b.apply(e,d):e instanceof Date?c.apply(e,d):a.apply(e,d)}return d}var R=\"function\"==typeof Symbol&&Symbol[\"for\"]&&Symbol[\"for\"](\"react.element\"),S=60103,T={use_static:!1};c(b)&&void 0!==b.use_static&&(T.use_static=Boolean(b.use_static));var U=\"__immutable_invariants_hold\",V=[\"setPrototypeOf\"],W=[\"keys\"],X=V.concat([\"push\",\"pop\",\"sort\",\"splice\",\"shift\",\"unshift\",\"reverse\"]),Y=W.concat([\"map\",\"filter\",\"slice\",\"concat\",\"reduce\",\"reduceRight\"]),Z=V.concat([\"setDate\",\"setFullYear\",\"setHours\",\"setMilliseconds\",\"setMinutes\",\"setMonth\",\"setSeconds\",\"setTime\",\"setUTCDate\",\"setUTCFullYear\",\"setUTCHours\",\"setUTCMilliseconds\",\"setUTCMinutes\",\"setUTCMonth\",\"setUTCSeconds\",\"setYear\"]);j.prototype=new Error,j.prototype.constructor=Error;var $=N([]),_=N({});return N.from=N,N.isImmutable=g,N.ImmutableError=j,N.merge=O(x),N.replace=O(y),N.without=O(s),N.asMutable=Q(F,t,q),N.set=P(A,m),N.setIn=P(z,n),N.update=O(B),N.updateIn=O(D),N.getIn=O(E),N.flatMap=O(r),N.asObject=O(u),T.use_static||(N[\"static\"]=a({use_static:!0})),Object.freeze(N),N}var b=a();\"function\"==typeof define&&define.amd?define(function(){return b}):\"object\"==typeof module?module.exports=b:\"object\"==typeof exports?exports.Immutable=b:\"object\"==typeof window?window.Immutable=b:\"object\"==typeof global&&(global.Immutable=b)}();"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}