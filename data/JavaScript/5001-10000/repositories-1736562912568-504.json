{
  "metadata": {
    "timestamp": 1736562912568,
    "page": 504,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bendc/animateplus",
      "stars": 5954,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017-2018 Benjamin De Cock\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.466796875,
          "content": "# Animate Plus\n\nAnimate Plus is a JavaScript animation library focusing on performance and authoring flexibility. It\naims to deliver a steady 60 FPS and weighs less than 3 KB (minified and compressed), making it particularly well-suited for mobile.\n\n## Getting started\n\n`npm install animateplus` or download `animateplus.js` and start animating things:\n\n```javascript\nimport animate from \"/animateplus.js\";\n\nanimate({\n  elements: \"div\",\n  duration: 2000,\n  delay: index => index * 100,\n  transform: [\"scale(0)\", \"scale(1)\"]\n})\n.then(options => animate({\n  ...options,\n  transform: [\"translate(0%)\", \"translate(500%)\"]\n}));\n```\n\n[Preview this example &#8594;](http://animateplus.com/examples/getting-started/)\n\n## Options\n\n### elements\n\n| Default | Type\n| :---    | :---\n| `null`  | String \\| Element \\| NodeList \\| Array\n\nDetermines the DOM elements to animate. You can either pass it a CSS selector or DOM elements.\n\n```javascript\nanimate({\n  elements: document.body.children,\n  transform: [\"rotate(0turn)\", \"rotate(1turn)\"]\n});\n```\n\n### easing\n\n| Default       | Type\n| :---          | :---\n| `out-elastic` | String\n\nDetermines the acceleration curve of your animation.\n\n| constant | accelerate     | decelerate      | accelerate-decelerate\n| :---     | :---           | :---            | :---\n| linear   | in-cubic       | out-cubic       | in-out-cubic\n|          | in-quartic     | out-quartic     | in-out-quartic\n|          | in-quintic     | out-quintic     | in-out-quintic\n|          | in-exponential | out-exponential | in-out-exponential\n|          | in-circular    | out-circular    | in-out-circular\n|          | in-elastic     | out-elastic     | in-out-elastic\n\nThe amplitude and period of elastic easings can be configured by providing space-separated values.\nAmplitude defaults to `1`, period to `0.4`.\n\n```javascript\n// Increase elasticity\nanimate({\n  elements: \"span\",\n  easing: \"out-elastic 1.4 0.2\",\n  transform: [\"translate(0px)\", \"translate(500px)\"]\n});\n```\n\n### duration\n\n| Default | Type\n| :---    | :---\n| `1000`  | Number \\| Function\n\nDetermines the duration of your animation in milliseconds. By passing it a callback, you can define\na different duration for each element. The callback takes the index of each element as its argument\nand returns a number.\n\n```javascript\n// First element fades out in 1s, second element in 2s, etc.\nanimate({\n  elements: \"span\",\n  easing: \"linear\",\n  duration: index => (index + 1) * 1000,\n  opacity: [1, 0]\n});\n```\n\n### delay\n\n| Default | Type\n| :---    | :---\n| `0`     | Number \\| Function\n\nDetermines the delay of your animation in milliseconds. By passing it a callback, you can define\na different delay for each element. The callback takes the index of each element as its argument\nand returns a number.\n\n```javascript\n// First element fades out after 1s, second element after 2s, etc.\nanimate({\n  elements: \"span\",\n  easing: \"linear\",\n  delay: index => (index + 1) * 1000,\n  opacity: [1, 0]\n});\n```\n\n### loop\n\n| Default | Type\n| :---    | :---\n| `false` | Boolean\n\nDetermines if the animation should repeat.\n\n### direction\n\n| Default  | Type\n| :---     | :---\n| `normal` | String\n\nDetermines the direction of the animation. `reverse` runs the animation backwards, `alternate`\nswitches direction after each iteration if the animation loops.\n\n### speed\n\n| Default | Type\n| :---    | :---\n| `1`     | Number\n\nDetermines the animation playback rate. Useful in the authoring process to speed up some parts of a\nlong sequence (value above 1) or slow down a specific animation to observe it (value below 1).\n\n### optimize\n\n| Default | Type\n| :---    | :---\n| `false` | Boolean\n\nForces hardware acceleration during an animation if set to `true`. Unless you experience performance\nissues, it's recommended to leave it off as hardware acceleration comes with potentially harmful\nside-effects.\n\n### blur\n\n| Default | Type\n| :---    | :---\n| `null`  | Object \\| Function\n\nSimulates a motion blur effect. Takes an object or a function returning an object that specifies the\nstrength of the directional blur on the `x` and `y` axes. A missing axis defaults to `0`, which\ndisables the blur on that axis.\n\n```javascript\nanimate({\n  elements: \"circle\",\n  easing: \"out-exponential\",\n  duration: 2500,\n  loop: true,\n  direction: \"alternate\",\n  blur: {x: 20, y: 2},\n  transform: [\"translate(0%)\", \"translate(80%)\"]\n});\n```\n\n[Preview this example &#8594;](http://animateplus.com/examples/motion-blur/)\n\n### change\n\n| Default | Type\n| :---    | :---\n| `null`  | Function\n\nDefines a callback invoked on every frame of the animation. The callback takes as its argument the\nanimation progress (between 0 and 1) and can be used on its own without being tied to `elements`.\n\n```javascript\n// Linearly outputs the percentage increase during 5s\nanimate({\n  duration: 5000,\n  easing: \"linear\",\n  change: progress =>\n    document.body.textContent = `${Math.round(progress * 100)}%`\n});\n```\n\n## Animations\n\nAnimate Plus lets you animate HTML and SVG elements with any property that takes numeric values,\nincluding hexadecimal colors.\n\n```javascript\n// Animate the radius and fill color of an SVG circle\nanimate({\n  elements: \"circle\",\n  r: [0, 50],\n  fill: [\"#80f\", \"#fc0\"]\n});\n```\n\nEach property you animate needs an array defining the start and end values. For convenience, you can\nomit everything but the numbers in the end values.\n\n```javascript\n// Same as [\"translate(0px)\", \"translate(100px)\"]\nanimate({\n  elements: \"span\",\n  transform: [\"translate(0px)\", 100]\n});\n```\n\nThese arrays can optionally be returned by a callback that takes the index of each element, just\nlike with [duration](#duration) and [delay](#delay).\n\n```javascript\n// First element translates by 100px, second element by 200px, etc.\nanimate({\n  elements: \"span\",\n  transform: index => [\"translate(0px)\", (index + 1) * 100]\n});\n```\n\n## Promise\n\n`animate()` returns a promise which resolves once the animation finishes. The promise resolves to\nthe object initially passed to `animate()`, making animation chaining straightforward and\nconvenient. The [Getting started](#getting-started) section gives you a basic promise example.\n\nSince Animate Plus relies on native promises, you can benefit from all the usual features promises\nprovide, such as `Promise.all`, `Promise.race`, and especially `async/await` which makes animation\ntimelines easy to set up.\n\n```javascript\nconst play = async () => {\n  const options = await animate({\n    elements: \"span\",\n    duration: 3000,\n    transform: [\"translateY(-100vh)\", 0]\n  });\n\n  await animate({\n    ...options,\n    transform: [\"rotate(0turn)\", 1]\n  });\n\n  await animate({\n    ...options,\n    duration: 800,\n    easing: \"in-quintic\",\n    transform: [\"scale(1)\", 0]\n  });\n};\n\nplay();\n```\n\n[Preview this example &#8594;](http://animateplus.com/examples/timeline/)\n\n## Additional functions\n\n### stop\n\nStops the animations on the [elements](#elements) passed as the argument.\n\n```javascript\nimport {stop} from \"/animateplus.js\";\n\nanimate({\n  elements: \"span\",\n  easing: \"linear\",\n  duration: index => 8000 + index * 200,\n  loop: true,\n  transform: [\"rotate(0deg)\", 360]\n});\n\ndocument.addEventListener(\"click\", ({target}) => stop(target));\n```\n\n[Preview this example &#8594;](http://animateplus.com/examples/stop/)\n\n### delay\n\nSets a timer in milliseconds. It differentiates from `setTimeout()` by returning a promise and being\nmore accurate, consistent and battery-friendly. The [delay](#delay) option relies internally on\nthis method.\n\n```javascript\nimport {delay} from \"/animateplus.js\";\n\ndelay(500).then(time => console.log(`${time}ms elapsed`));\n```\n\n## Browser support\n\nAnimate Plus is provided as a native ES2015 module, which means you may need to transpile it\ndepending on your browser support policy. The library works as is using `<script type=module>` in\nthe following browsers:\n\n* Chrome 61\n* Safari 11.1\n* Firefox 60\n\n## Content delivery networks\n\nAnimate Plus is available on [CDNJS](https://cdnjs.com/libraries/animateplus) and [jsDelivr](https://www.jsdelivr.com/package/npm/animateplus).\n\n```javascript\nimport animate from \"https://cdn.jsdelivr.net/npm/animateplus@2/animateplus.js\";\n\nanimate({\n  elements: \"div\",\n  transform: [\"translate(0%)\", 100]\n});\n```\n\n## Best practices\n\nAnimations play a major role in the design of good user interfaces. They help connecting actions to\nconsequences, make the flow of interactions manifest, and greatly improve the polish and perception\nof a product. However, animations can be damaging and detrimental to the user experience if they get\nin the way. Here are a few best practices to keep your animations effective and enjoyable:\n\n* **Speed**: Keep your animations fast. A quick animation makes a software feel more productive and\n  responsive. The optimal duration depends on the effect and animation curve, but in most cases you\nshould likely stay under 500 milliseconds.\n* **Easing**: The animation curve contributes greatly to a well-crafted animation. The ease-out\n  options are usually a safe bet as animations kick off promptly, making them react to user\ninteractions instantaneously.\n* **Performance**: Having no animation is better than animations that stutter. When animating HTML\n  elements, aim for using exclusively `transform` and `opacity` as these are the only properties\nbrowsers can animate cheaply.\n* **Restraint**: Tone down your animations and respect user preferences. Animations can rapidly feel\n  overwhelming and cause motion sickness, so it's important to keep them subtle and to attenuate\nthem even more for users who need reduced motion, for example by using `matchMedia(\"(prefers-reduced-motion)\")` in JavaScript.\n\n## Examples\n\n* [Stress test](http://animateplus.com/examples/stress-test/): 500 elements animated concurrently.\n* [Burst](http://animateplus.com/examples/burst/): Intensive burst animation based on `mousemove`/`touchmove`.\n* [Accordion](http://animateplus.com/examples/accordion/): Animated accordion.\n* [Morphing](http://animateplus.com/examples/clip-path/): CSS polygon morphing using `clip-path`.\n* [Motion path](http://animateplus.com/examples/motion-path/): Animation along a custom path.\n* [Line drawing](http://animateplus.com/examples/line-drawing/): SVG line drawing animation.\n* [Elasticity](http://animateplus.com/examples/elasticity/): SVG circles following your clicks.\n* [External SVG](http://animateplus.com/examples/external-svg/): Animating paths from an external\n  SVG file.\n* [Anchors](http://animateplus.com/examples/anchor-scroll/): Anchor scrolling animation using `change()`.\n* [Progress](http://animateplus.com/examples/progress/): Animation progress using `change()`.\n* [Text](http://animateplus.com/examples/text/): Text splitting animation.\n"
        },
        {
          "name": "animateplus.js",
          "type": "blob",
          "size": 11.1865234375,
          "content": "/*\n * Animate Plus v2.1.1\n * Copyright (c) 2017-2018 Benjamin De Cock\n * http://animateplus.com/license\n */\n\n\n// logic\n// =====\n\nconst first = ([item]) => item;\n\nconst computeValue = (value, index) =>\n  typeof value == \"function\" ? value(index) : value;\n\n\n// dom\n// ===\n\nconst getElements = elements => {\n  if (Array.isArray(elements))\n    return elements;\n  if (!elements || elements.nodeType)\n    return [elements];\n  return Array.from(typeof elements == \"string\" ? document.querySelectorAll(elements) : elements);\n};\n\nconst accelerate = ({style}, keyframes) =>\n  style.willChange = keyframes\n    ? keyframes.map(({property}) => property).join()\n    : \"auto\";\n\nconst createSVG = (element, attributes) =>\n  Object.entries(attributes).reduce((node, [attribute, value]) => {\n    node.setAttribute(attribute, value);\n    return node;\n  }, document.createElementNS(\"http://www.w3.org/2000/svg\", element));\n\n\n// motion blur\n// ===========\n\nconst blurs = {\n  axes: [\"x\", \"y\"],\n  count: 0,\n  add({element, blur}) {\n    const id = `motion-blur-${this.count++}`;\n    const svg = createSVG(\"svg\", {\n      style: \"position: absolute; width: 0; height: 0\"\n    });\n    const filter = createSVG(\"filter\", this.axes.reduce((attributes, axis) => {\n      const offset = blur[axis] * 2;\n      attributes[axis] = `-${offset}%`;\n      attributes[axis == \"x\" ? \"width\" : \"height\"] = `${100 + offset * 2}%`;\n      return attributes;\n    },{\n      id,\n      \"color-interpolation-filters\": \"sRGB\"\n    }));\n    const gaussian = createSVG(\"feGaussianBlur\", {\n      in: \"SourceGraphic\"\n    });\n    filter.append(gaussian);\n    svg.append(filter);\n    element.style.filter = `url(\"#${id}\")`;\n    document.body.prepend(svg);\n    return gaussian;\n  }\n};\n\nconst getDeviation = (blur, {easing}, curve) => {\n  const progress = blur * curve;\n  const out = blur - progress;\n  const deviation = (() => {\n    if (easing == \"linear\")\n      return blur;\n    if (easing.startsWith(\"in-out\"))\n      return (curve < .5 ? progress : out) * 2;\n    if (easing.startsWith(\"in\"))\n      return progress;\n    return out;\n  })();\n  return Math.max(0, deviation);\n};\n\nconst setDeviation = ({blur, gaussian, easing}, curve) => {\n  const values = blurs.axes.map(axis => getDeviation(blur[axis], easing, curve));\n  gaussian.setAttribute(\"stdDeviation\", values.join());\n};\n\nconst normalizeBlur = blur => {\n  const defaults = blurs.axes.reduce((object, axis) => {\n    object[axis] = 0;\n    return object;\n  }, {});\n  return Object.assign(defaults, blur);\n};\n\nconst clearBlur = ({style}, {parentNode: {parentNode: svg}}) => {\n  style.filter = \"none\";\n  svg.remove();\n};\n\n\n// color conversion\n// ================\n\nconst hexPairs = color => {\n  const split = color.split(\"\");\n  const pairs = color.length < 5\n    ? split.map(string => string + string)\n    : split.reduce((array, string, index) => {\n      if (index % 2)\n        array.push(split[index - 1] + string);\n      return array;\n    }, []);\n  if (pairs.length < 4)\n    pairs.push(\"ff\");\n  return pairs;\n};\n\nconst convert = color =>\n  hexPairs(color).map(string => parseInt(string, 16));\n\nconst rgba = hex => {\n  const color = hex.slice(1);\n  const [r, g, b, a] = convert(color);\n  return `rgba(${r}, ${g}, ${b}, ${a / 255})`;\n};\n\n\n// easing equations\n// ================\n\nconst pi2 = Math.PI * 2;\n\nconst getOffset = (strength, period) =>\n  period / pi2 * Math.asin(1 / strength);\n\nconst easings = {\n  \"linear\": progress => progress,\n\n  \"in-cubic\": progress => progress ** 3,\n  \"in-quartic\": progress => progress ** 4,\n  \"in-quintic\": progress => progress ** 5,\n  \"in-exponential\": progress => 1024 ** (progress - 1),\n  \"in-circular\": progress => 1 - Math.sqrt(1 - progress ** 2),\n  \"in-elastic\": (progress, amplitude, period) => {\n    const strength = Math.max(amplitude, 1);\n    const offset = getOffset(strength, period);\n    return -(strength * 2 ** (10 * (progress -= 1)) * Math.sin((progress - offset) * pi2 / period));\n  },\n\n  \"out-cubic\": progress => --progress ** 3 + 1,\n  \"out-quartic\": progress => 1 - --progress ** 4,\n  \"out-quintic\": progress => --progress ** 5 + 1,\n  \"out-exponential\": progress => 1 - 2 ** (-10 * progress),\n  \"out-circular\": progress => Math.sqrt(1 - --progress ** 2),\n  \"out-elastic\": (progress, amplitude, period) => {\n    const strength = Math.max(amplitude, 1);\n    const offset = getOffset(strength, period);\n    return strength * 2 ** (-10 * progress) * Math.sin((progress - offset) * pi2 / period) + 1;\n  },\n\n  \"in-out-cubic\": progress =>\n    (progress *= 2) < 1\n      ? .5 * progress ** 3\n      : .5 * ((progress -= 2) * progress ** 2 + 2),\n  \"in-out-quartic\": progress =>\n    (progress *= 2) < 1\n      ? .5 * progress ** 4\n      : -.5 * ((progress -= 2) * progress ** 3 - 2),\n  \"in-out-quintic\": progress =>\n    (progress *= 2) < 1\n      ? .5 * progress ** 5\n      : .5 * ((progress -= 2) * progress ** 4 + 2),\n  \"in-out-exponential\": progress =>\n    (progress *= 2) < 1\n      ? .5 * 1024 ** (progress - 1)\n      : .5 * (-(2 ** (-10 * (progress - 1))) + 2),\n  \"in-out-circular\": progress =>\n    (progress *= 2) < 1\n      ? -.5 * (Math.sqrt(1 - progress ** 2) - 1)\n      : .5 * (Math.sqrt(1 - (progress -= 2) * progress) + 1),\n  \"in-out-elastic\": (progress, amplitude, period) => {\n    const strength = Math.max(amplitude, 1);\n    const offset = getOffset(strength, period);\n    return (progress *= 2) < 1\n      ? -.5 * (strength * 2 ** (10 * (progress -= 1)) * Math.sin((progress - offset) * pi2 / period))\n      : strength * 2 ** (-10 * (progress -= 1)) * Math.sin((progress - offset) * pi2 / period) * .5 + 1;\n  }\n};\n\nconst decomposeEasing = string => {\n  const [easing, amplitude = 1, period = .4] = string.trim().split(\" \");\n  return {easing, amplitude, period};\n};\n\nconst ease = ({easing, amplitude, period}, progress) =>\n  easings[easing](progress, amplitude, period);\n\n\n// keyframes composition\n// =====================\n\nconst extractRegExp = /-?\\d*\\.?\\d+/g;\n\nconst extractStrings = value =>\n  value.split(extractRegExp);\n\nconst extractNumbers = value =>\n  value.match(extractRegExp).map(Number);\n\nconst sanitize = values =>\n  values.map(value => {\n    const string = String(value);\n    return string.startsWith(\"#\") ? rgba(string) : string;\n  });\n\nconst addPropertyKeyframes = (property, values) => {\n  const animatable = sanitize(values);\n  const strings = extractStrings(first(animatable));\n  const numbers = animatable.map(extractNumbers);\n  const round = first(strings).startsWith(\"rgb\");\n  return {property, strings, numbers, round};\n};\n\nconst createAnimationKeyframes = (keyframes, index) =>\n  Object.entries(keyframes).map(([property, values]) =>\n    addPropertyKeyframes(property, computeValue(values, index)));\n\nconst getCurrentValue = (from, to, easing) =>\n  from + (to - from) * easing;\n\nconst recomposeValue = ([from, to], strings, round, easing) =>\n  strings.reduce((style, string, index) => {\n    const previous = index - 1;\n    const value = getCurrentValue(from[previous], to[previous], easing);\n    return style + (round && index < 4 ? Math.round(value) : value) + string;\n  });\n\nconst createStyles = (keyframes, easing) =>\n  keyframes.reduce((styles, {property, numbers, strings, round}) => {\n    styles[property] = recomposeValue(numbers, strings, round, easing);\n    return styles;\n  }, {});\n\nconst reverseKeyframes = keyframes =>\n  keyframes.forEach(({numbers}) => numbers.reverse());\n\n\n// animation tracking\n// ==================\n\nconst rAF = {\n  all: new Set,\n  add(object) {\n    if (this.all.add(object).size < 2) requestAnimationFrame(tick);\n  }\n};\n\nconst paused = {};\n\nconst trackTime = (timing, now) => {\n  if (!timing.startTime) timing.startTime = now;\n  timing.elapsed = now - timing.startTime;\n};\n\nconst resetTime = object =>\n  object.startTime = 0;\n\nconst getProgress = ({elapsed, duration}) =>\n  duration > 0 ? Math.min(elapsed / duration, 1) : 1;\n\nconst setSpeed = (speed, value, index) =>\n  speed > 0 ? computeValue(value, index) / speed : 0;\n\nconst addAnimations = (options, resolve) => {\n  const {\n    elements = null,\n    easing = \"out-elastic\",\n    duration = 1000,\n    delay: timeout = 0,\n    speed = 1,\n    loop = false,\n    optimize = false,\n    direction = \"normal\",\n    blur = null,\n    change = null,\n    ...rest\n  } = options;\n\n  const last = {\n    totalDuration: -1\n  };\n\n  getElements(elements).forEach(async (element, index) => {\n    const keyframes = createAnimationKeyframes(rest, index);\n    const animation = {\n      element,\n      keyframes,\n      loop,\n      optimize,\n      direction,\n      change,\n      easing: decomposeEasing(easing),\n      duration: setSpeed(speed, duration, index)\n    };\n\n    const animationTimeout = setSpeed(speed, timeout, index);\n    const totalDuration = animationTimeout + animation.duration;\n\n    if (direction != \"normal\")\n      reverseKeyframes(keyframes);\n\n    if (element) {\n      if (optimize)\n        accelerate(element, keyframes);\n\n      if (blur) {\n        animation.blur = normalizeBlur(computeValue(blur, index));\n        animation.gaussian = blurs.add(animation);\n      }\n    }\n\n    if (totalDuration > last.totalDuration) {\n      last.animation = animation;\n      last.totalDuration = totalDuration;\n    }\n\n    if (animationTimeout) await delay(animationTimeout);\n    rAF.add(animation);\n  });\n\n  const {animation} = last;\n  if (!animation) return;\n  animation.end = resolve;\n  animation.options = options;\n};\n\nconst tick = now => {\n  const {all} = rAF;\n  all.forEach(object => {\n    trackTime(object, now);\n    const progress = getProgress(object);\n    const {\n      element,\n      keyframes,\n      loop,\n      optimize,\n      direction,\n      change,\n      easing,\n      duration,\n      gaussian,\n      end,\n      options\n    } = object;\n\n    // object is an animation\n    if (direction) {\n      let curve = progress;\n      switch (progress) {\n        case 0:\n          if (direction == \"alternate\") reverseKeyframes(keyframes);\n          break;\n        case 1:\n          if (loop)\n            resetTime(object);\n          else {\n            all.delete(object);\n            if (optimize && element) accelerate(element);\n            if (gaussian) clearBlur(element, gaussian);\n          }\n          if (end) end(options);\n          break;\n        default:\n          curve = ease(easing, progress);\n      }\n      if (gaussian) setDeviation(object, curve);\n      if (change && end) change(curve);\n      if (element) Object.assign(element.style, createStyles(keyframes, curve));\n      return;\n    }\n\n    // object is a delay\n    if (progress < 1) return;\n    all.delete(object);\n    end(duration);\n  });\n\n  if (all.size) requestAnimationFrame(tick);\n};\n\ndocument.addEventListener(\"visibilitychange\", () => {\n  const now = performance.now();\n\n  if (document.hidden) {\n    const {all} = rAF;\n    paused.time = now;\n    paused.all = new Set(all);\n    all.clear();\n    return;\n  }\n\n  const {all, time} = paused;\n  if (!all) return;\n  const elapsed = now - time;\n  requestAnimationFrame(() =>\n    all.forEach(object => {\n      object.startTime += elapsed;\n      rAF.add(object);\n    }));\n});\n\n\n// exports\n// =======\n\nexport default options =>\n  new Promise(resolve => addAnimations(options, resolve));\n\nexport const delay = duration =>\n  new Promise(resolve => rAF.add({\n    duration,\n    end: resolve\n  }));\n\nexport const stop = elements => {\n  const {all} = rAF;\n  const nodes = getElements(elements);\n  all.forEach(object => {\n    if (nodes.includes(object.element)) all.delete(object);\n  });\n  return nodes;\n};\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.5400390625,
          "content": "{\n  \"name\": \"animateplus\",\n  \"version\": \"2.1.1\",\n  \"description\": \"A+ animation module for the modern web\",\n  \"main\": \"animateplus.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/bendc/animateplus.git\"\n  },\n  \"keywords\": [\n    \"animate\",\n    \"animation\",\n    \"css\",\n    \"svg\",\n    \"javascript\"\n  ],\n  \"author\": \"Benjamin De Cock <ben@deaxon.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/bendc/animateplus/issues\"\n  },\n  \"homepage\": \"https://github.com/bendc/animateplus\",\n  \"files\": [\"animateplus.js\"]\n}\n"
        }
      ]
    }
  ]
}