{
  "metadata": {
    "timestamp": 1736562831747,
    "page": 395,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "madrobby/keymaster",
      "stars": 6527,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.025390625,
          "content": ".DS_Store\nkeymaster.min.js"
        },
        {
          "name": "MIT-LICENSE",
          "type": "blob",
          "size": 1.0361328125,
          "content": "Copyright (c) 2011-2013 Thomas Fuchs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1259765625,
          "content": "# To run this, you'll need to install UglifyJS:\n# npm install uglify-js@1 -g\ndefault:\n\tuglifyjs -o keymaster.min.js keymaster.js\n"
        },
        {
          "name": "README.markdown",
          "type": "blob",
          "size": 6.1435546875,
          "content": "# keymaster.js\n\nKeymaster is a simple micro-library for defining and\ndispatching keyboard shortcuts in web applications.\n\nIt has no dependencies.\n\n*It’s a work in progress (e.g. beta), so spare me your nerdrage and instead\ncontribute! Patches are welcome, but they are not guaranteed to make\nit in.*\n\n## Usage\n\nInclude `keymaster.js` in your web app*, by loading it as usual:\n\n```html\n<script src=\"keymaster.js\"></script>\n```\n\nKeymaster has no dependencies and can be used completely standalone.\nIt should not interfere with any JavaScript libraries or frameworks.\n\n_*Preferably use a minified version that fits your workflow. You can\nrun `make` to have UglifyJS (if you have it installed) create a\n`keymaster.min.js` file for you._\n\n## Defining shortcuts\n\nOne global method is exposed, `key` which defines shortcuts when\ncalled directly.\n\n```javascript\n// define short of 'a'\nkey('a', function(){ alert('you pressed a!') });\n\n// returning false stops the event and prevents default browser events\nkey('ctrl+r', function(){ alert('stopped reload!'); return false });\n\n// multiple shortcuts that do the same thing\nkey('⌘+r, ctrl+r', function(){ });\n```\n\nThe handler method is called with two arguments set, the keydown `event` fired, and\nan object containing, among others, the following two properties:\n\n`shortcut`: a string that contains the shortcut used, e.g. `ctrl+r`\n`scope`: a string describing the scope (or `all`)\n\n```javascript\nkey('⌘+r, ctrl+r', function(event, handler){\n  console.log(handler.shortcut, handler.scope);\n});\n\n// \"ctrl+r\", \"all\"\n```\n\n\n## Supported keys\n\nKeymaster understands the following modifiers:\n`⇧`, `shift`, `option`, `⌥`, `alt`, `ctrl`, `control`, `command`, and `⌘`.\n\nThe following special keys can be used for shortcuts:\n`backspace`, `tab`, `clear`, `enter`, `return`, `esc`, `escape`, `space`,\n`up`, `down`, `left`, `right`, `home`, `end`, `pageup`, `pagedown`, `del`, `delete`\nand `f1` through `f19`.\n\n\n## Modifier key queries\n\nAt any point in time (even in code other than key shortcut handlers),\nyou can query the `key` object for the state of any keys. This\nallows easy implementation of things like shift+click handlers. For example,\n`key.shift` is `true` if the shift key is currently pressed.\n\n```javascript\nif(key.shift) alert('shift is pressed, OMGZ!');\n```\n\n\n## Other key queries\n\nAt any point in time (even in code other than key shortcut handlers),\nyou can query the `key` object for the state of any key. This\nis very helpful for game development using a game loop. For example,\n`key.isPressed(77)` is `true` if the M key is currently pressed.\n\n```javascript\nif(key.isPressed(\"M\")) alert('M key is pressed, can ya believe it!?');\nif(key.isPressed(77)) alert('M key is pressed, can ya believe it!?');\n```\n\nYou can also get these as an array using...\n```javascript\nkey.getPressedKeyCodes() // returns an array of key codes currently pressed\n```\n\n\n## Scopes\n\nIf you want to reuse the same shortcut for separate areas in your single page app,\nKeymaster supports switching between scopes. Use the `key.setScope` method to set scope.\n\n```javascript\n// define shortcuts with a scope\nkey('o, enter', 'issues', function(){ /* do something */ });\nkey('o, enter', 'files', function(){ /* do something else */ });\n\n// set the scope (only 'all' and 'issues' shortcuts will be honored)\nkey.setScope('issues'); // default scope is 'all'\n\n// remove all events that are set in 'issues' scope\nkey.deleteScope('issues');\n\n```\n\n\n## Filter key presses\n\nBy default, when an `INPUT`, `SELECT` or `TEXTAREA` element is focused, Keymaster doesn't process any shortcuts.\n\nYou can change this by overwriting `key.filter` with a new function. This function is called before\nKeymaster processes shortcuts, with the keydown event as argument.\n\nIf your function returns false, then the no shortcuts will be processed.\n\nHere's the default implementation for reference:\n\n```javascript\nfunction filter(event){\n  var tagName = (event.target || event.srcElement).tagName;\n  return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');\n}\n```\n\nIf you only want _some_ shortcuts to work while in an input element, you can change the scope in the\n`key.filter` function. Here's an example implementation, setting the scope to either `'input'` or `'other'`.\nDon't forget to return `true` so the any shortcuts get processed.\n\n```javascript\nkey.filter = function(event){\n  var tagName = (event.target || event.srcElement).tagName;\n  key.setScope(/^(INPUT|TEXTAREA|SELECT)$/.test(tagName) ? 'input' : 'other');\n  return true;\n}\n```\n\nHowever a more robust way to handle this is to use proper\nfocus and blur event handlers on your input element, and change scopes there as you see fit.\n\n\n## noConflict mode\n\nYou can call ```key.noConflict``` to remove the ```key``` function from global scope and restore whatever ```key``` was defined to before Keymaster was loaded. Calling ```key.noConflict``` will return the Keymaster ```key``` function.\n\n```javascript\nvar k = key.noConflict();\nk('a', function() { /* ... */ });\n\nkey()\n// --> TypeError: 'undefined' is not a function\n```\n\n\n## Unbinding shortcuts\n\nSimilar to defining shortcuts, they can be unbound using `key.unbind`.\n\n```javascript\n// unbind 'a' handler\nkey.unbind('a');\n\n// unbind a key only for a single scope\n// when no scope is specified it defaults to the current scope (key.getScope())\nkey.unbind('o, enter', 'issues');\nkey.unbind('o, enter', 'files');\n```\n\n\n## Notes\n\nKeymaster should work with any browser that fires `keyup` and `keydown` events,\nand is tested with IE (6+), Safari, Firefox and Chrome.\n\nSee [http://madrobby.github.com/keymaster/](http://madrobby.github.com/keymaster/) for a live demo.\n\n\n## CoffeeScript\n\nIf you're using CoffeeScript, configuring key shortcuts couldn't be simpler:\n\n```coffeescript\nkey 'a', -> alert('you pressed a!')\n\nkey '⌘+r, ctrl+r', ->\n  alert 'stopped reload!'\n  off\n\nkey 'o, enter', 'issues', ->\n  whatevs()\n\nalert 'shift is pressed, OMGZ!' if key.shift\n```\n\n\n## Contributing\n\nTo contribute, please fork Keymaster, add your patch and tests for it (in the `test/` folder) and\nsubmit a pull request.\n\n## TODOs\n\n* Finish test suite\n\nKeymaster is (c) 2011-2013 Thomas Fuchs and may be freely distributed under the MIT license.\nSee the `MIT-LICENSE` file.\n"
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.505859375,
          "content": "{\n  \"name\": \"keymaster\",\n  \"main\": \"keymaster.js\",\n  \"version\": \"1.6.3\",\n  \"homepage\": \"https://github.com/madrobby/keymaster\",\n  \"authors\": [\n    \"Thomas Fuchs <thomas@slash7.com> (http://mir.aculo.us)\"\n  ],\n  \"description\": \"library for defining and dispatching keyboard shortcuts\",\n  \"moduleType\": [\n    \"es6\",\n    \"globals\"\n  ],\n  \"keywords\": [\n    \"key\",\n    \"keyboard\",\n    \"shortcuts\"\n  ],\n  \"license\": \"MIT\",\n  \"ignore\": [\n    \"**/.*\",\n    \"node_modules\",\n    \"bower_components\",\n    \"test\",\n    \"tests\"\n  ]\n}\n"
        },
        {
          "name": "keymaster.js",
          "type": "blob",
          "size": 8.3779296875,
          "content": "//     keymaster.js\n//     (c) 2011-2013 Thomas Fuchs\n//     keymaster.js may be freely distributed under the MIT license.\n\n;(function(global){\n  var k,\n    _handlers = {},\n    _mods = { 16: false, 18: false, 17: false, 91: false },\n    _scope = 'all',\n    // modifier keys\n    _MODIFIERS = {\n      '⇧': 16, shift: 16,\n      '⌥': 18, alt: 18, option: 18,\n      '⌃': 17, ctrl: 17, control: 17,\n      '⌘': 91, command: 91\n    },\n    // special keys\n    _MAP = {\n      backspace: 8, tab: 9, clear: 12,\n      enter: 13, 'return': 13,\n      esc: 27, escape: 27, space: 32,\n      left: 37, up: 38,\n      right: 39, down: 40,\n      del: 46, 'delete': 46,\n      home: 36, end: 35,\n      pageup: 33, pagedown: 34,\n      ',': 188, '.': 190, '/': 191,\n      '`': 192, '-': 189, '=': 187,\n      ';': 186, '\\'': 222,\n      '[': 219, ']': 221, '\\\\': 220\n    },\n    code = function(x){\n      return _MAP[x] || x.toUpperCase().charCodeAt(0);\n    },\n    _downKeys = [];\n\n  for(k=1;k<20;k++) _MAP['f'+k] = 111+k;\n\n  // IE doesn't support Array#indexOf, so have a simple replacement\n  function index(array, item){\n    var i = array.length;\n    while(i--) if(array[i]===item) return i;\n    return -1;\n  }\n\n  // for comparing mods before unassignment\n  function compareArray(a1, a2) {\n    if (a1.length != a2.length) return false;\n    for (var i = 0; i < a1.length; i++) {\n        if (a1[i] !== a2[i]) return false;\n    }\n    return true;\n  }\n\n  var modifierMap = {\n      16:'shiftKey',\n      18:'altKey',\n      17:'ctrlKey',\n      91:'metaKey'\n  };\n  function updateModifierKey(event) {\n      for(k in _mods) _mods[k] = event[modifierMap[k]];\n  };\n\n  // handle keydown event\n  function dispatch(event) {\n    var key, handler, k, i, modifiersMatch, scope;\n    key = event.keyCode;\n\n    if (index(_downKeys, key) == -1) {\n        _downKeys.push(key);\n    }\n\n    // if a modifier key, set the key.<modifierkeyname> property to true and return\n    if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko\n    if(key in _mods) {\n      _mods[key] = true;\n      // 'assignKey' from inside this closure is exported to window.key\n      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;\n      return;\n    }\n    updateModifierKey(event);\n\n    // see if we need to ignore the keypress (filter() can can be overridden)\n    // by default ignore key presses if a select, textarea, or input is focused\n    if(!assignKey.filter.call(this, event)) return;\n\n    // abort if no potentially matching shortcuts found\n    if (!(key in _handlers)) return;\n\n    scope = getScope();\n\n    // for each potential shortcut\n    for (i = 0; i < _handlers[key].length; i++) {\n      handler = _handlers[key][i];\n\n      // see if it's in the current scope\n      if(handler.scope == scope || handler.scope == 'all'){\n        // check if modifiers match if any\n        modifiersMatch = handler.mods.length > 0;\n        for(k in _mods)\n          if((!_mods[k] && index(handler.mods, +k) > -1) ||\n            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;\n        // call the handler and stop the event if neccessary\n        if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){\n          if(handler.method(event, handler)===false){\n            if(event.preventDefault) event.preventDefault();\n              else event.returnValue = false;\n            if(event.stopPropagation) event.stopPropagation();\n            if(event.cancelBubble) event.cancelBubble = true;\n          }\n        }\n      }\n    }\n  };\n\n  // unset modifier keys on keyup\n  function clearModifier(event){\n    var key = event.keyCode, k,\n        i = index(_downKeys, key);\n\n    // remove key from _downKeys\n    if (i >= 0) {\n        _downKeys.splice(i, 1);\n    }\n\n    if(key == 93 || key == 224) key = 91;\n    if(key in _mods) {\n      _mods[key] = false;\n      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;\n    }\n  };\n\n  function resetModifiers() {\n    for(k in _mods) _mods[k] = false;\n    for(k in _MODIFIERS) assignKey[k] = false;\n  };\n\n  // parse and assign shortcut\n  function assignKey(key, scope, method){\n    var keys, mods;\n    keys = getKeys(key);\n    if (method === undefined) {\n      method = scope;\n      scope = 'all';\n    }\n\n    // for each shortcut\n    for (var i = 0; i < keys.length; i++) {\n      // set modifier keys if any\n      mods = [];\n      key = keys[i].split('+');\n      if (key.length > 1){\n        mods = getMods(key);\n        key = [key[key.length-1]];\n      }\n      // convert to keycode and...\n      key = key[0]\n      key = code(key);\n      // ...store handler\n      if (!(key in _handlers)) _handlers[key] = [];\n      _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });\n    }\n  };\n\n  // unbind all handlers for given key in current scope\n  function unbindKey(key, scope) {\n    var multipleKeys, keys,\n      mods = [],\n      i, j, obj;\n\n    multipleKeys = getKeys(key);\n\n    for (j = 0; j < multipleKeys.length; j++) {\n      keys = multipleKeys[j].split('+');\n\n      if (keys.length > 1) {\n        mods = getMods(keys);\n      }\n\n      key = keys[keys.length - 1];\n      key = code(key);\n\n      if (scope === undefined) {\n        scope = getScope();\n      }\n      if (!_handlers[key]) {\n        return;\n      }\n      for (i = 0; i < _handlers[key].length; i++) {\n        obj = _handlers[key][i];\n        // only clear handlers if correct scope and mods match\n        if (obj.scope === scope && compareArray(obj.mods, mods)) {\n          _handlers[key][i] = {};\n        }\n      }\n    }\n  };\n\n  // Returns true if the key with code 'keyCode' is currently down\n  // Converts strings into key codes.\n  function isPressed(keyCode) {\n      if (typeof(keyCode)=='string') {\n        keyCode = code(keyCode);\n      }\n      return index(_downKeys, keyCode) != -1;\n  }\n\n  function getPressedKeyCodes() {\n      return _downKeys.slice(0);\n  }\n\n  function filter(event){\n    var tagName = (event.target || event.srcElement).tagName;\n    // ignore keypressed in any elements that support keyboard data input\n    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');\n  }\n\n  // initialize key.<modifier> to false\n  for(k in _MODIFIERS) assignKey[k] = false;\n\n  // set current scope (default 'all')\n  function setScope(scope){ _scope = scope || 'all' };\n  function getScope(){ return _scope || 'all' };\n\n  // delete all handlers for a given scope\n  function deleteScope(scope){\n    var key, handlers, i;\n\n    for (key in _handlers) {\n      handlers = _handlers[key];\n      for (i = 0; i < handlers.length; ) {\n        if (handlers[i].scope === scope) handlers.splice(i, 1);\n        else i++;\n      }\n    }\n  };\n\n  // abstract key logic for assign and unassign\n  function getKeys(key) {\n    var keys;\n    key = key.replace(/\\s/g, '');\n    keys = key.split(',');\n    if ((keys[keys.length - 1]) == '') {\n      keys[keys.length - 2] += ',';\n    }\n    return keys;\n  }\n\n  // abstract mods logic for assign and unassign\n  function getMods(key) {\n    var mods = key.slice(0, key.length - 1);\n    for (var mi = 0; mi < mods.length; mi++)\n    mods[mi] = _MODIFIERS[mods[mi]];\n    return mods;\n  }\n\n  // cross-browser events\n  function addEvent(object, event, method) {\n    if (object.addEventListener)\n      object.addEventListener(event, method, false);\n    else if(object.attachEvent)\n      object.attachEvent('on'+event, function(){ method(window.event) });\n  };\n\n  // set the handlers globally on document\n  addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48\n  addEvent(document, 'keyup', clearModifier);\n\n  // reset modifiers to false whenever the window is (re)focused.\n  addEvent(window, 'focus', resetModifiers);\n\n  // store previously defined key\n  var previousKey = global.key;\n\n  // restore previously defined key and return reference to our key object\n  function noConflict() {\n    var k = global.key;\n    global.key = previousKey;\n    return k;\n  }\n\n  // set window.key and window.key.set/get/deleteScope, and the default filter\n  global.key = assignKey;\n  global.key.setScope = setScope;\n  global.key.getScope = getScope;\n  global.key.deleteScope = deleteScope;\n  global.key.filter = filter;\n  global.key.isPressed = isPressed;\n  global.key.getPressedKeyCodes = getPressedKeyCodes;\n  global.key.noConflict = noConflict;\n  global.key.unbind = unbindKey;\n\n  if(typeof module !== 'undefined') module.exports = assignKey;\n\n})(this);\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.3271484375,
          "content": "{\n  \"name\": \"keymaster\",\n  \"description\": \"library for defining and dispatching keyboard shortcuts\",\n  \"version\": \"1.6.3\",\n  \"author\": \"Thomas Fuchs <thomas@slash7.com> (http://mir.aculo.us)\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/madrobby/keymaster\"\n  },\n  \"main\": \"./keymaster.js\",\n  \"license\": \"MIT\"\n}\n"
        },
        {
          "name": "test.html",
          "type": "blob",
          "size": 2.736328125,
          "content": "<html>\n<head>\n  <title>The Keymaster</title>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />\n</head>\n<body>\n  <script src=\"keymaster.js\"></script>\n\n  <h1>\n    The Keymaster\n  </h1>\n\n  <input type=\"text\" placeholder=\"a text input\"/>\n  <select><option></option><option>select</option></select>\n  <textarea placeholder=\"a textarea\"></textarea>\n\n  <ol>\n    <li>Press 'c'. Nothing should be logged on console.</li>\n    <li>Press 'o' or Enter or Cursor &larr;. Console should log function call.</li>\n    <li>Press 'i'. Switches scope to 'issues'.</li>\n    <li>Press 'c'. Console should log function call.</li>\n    <li>Press 'o' or Enter or Cursor &larr;. Console should log function call.</li>\n    <li>Press and hold 'm'. Console should log a message every second.</li>\n    <li>Every second console should log a message listing all the currently pressed keycodes.</li>\n  </ol>\n\n  <p>\n    At any time, try pressing ⌘+right, shift+left or ctrl+shift+alt+d.\n  </p>\n  \n  <p>\n    When a input, a select or a textarea element is focused, key inputs should be ignored.\n  </p>\n\n  <script>\n    key('c', 'issues', function(){\n     console.log('c/issues');\n    });\n\n    key('command+r, ctrl+r', 'issues', function(){\n      console.log('Hijacked Command+R or Ctrl+R, damn!');\n      return false;\n    });\n    \n    key('i', function(){\n      key.setScope('issues');\n      console.log('Switched to \"issues\" scope. Command+R or Ctrl+R is now no longer reloading...');\n    });\n    \n    key('i', function(){\n      console.log('(example of multiple assignment)');\n    });\n\n    key('o, enter, left', function(){\n      console.log('o, enter or left pressed!');\n    });\n\n    key('ctrl+c', function(){\n      console.log('this is not the command line');\n    });\n\n    key('⌘+right,shift+left,ctrl+shift+alt+d', function(event){\n      console.log('command+right, or shift+left, or ctrl+shift+alt+d');\n      console.log('here is the event: ', event);\n      console.log('key.control', key.control);\n      console.log('key.ctrl', key.ctrl);\n      console.log('key.shift', key.shift);\n      console.log('key.alt', key.alt);\n      console.log('key[\"⌘\"]', key[\"⌘\"]);\n      return false; // prevent default && stop propagation\n    });\n\n    key('⌘+x, ctrl+x', function(event, handler){\n      console.log(handler.shortcut, handler.scope);\n      return false;\n    });\n\n    key('/', function(){ console.log('/') });\n    key('shift+]', function(){ console.log('shift+]') });\n\n    setInterval(function () { \n        console.log('All keys currently down: ' + key.getPressedKeyCodes());\n        if (key.isPressed(77)) {\n            console.log('M key is currently down');\n        }\n    }, 1000);\n\n    // document.onkeydown = function(event){\n    //  console.log(event.keyCode);\n    // }\n  </script>\n</body>\n</html>\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}