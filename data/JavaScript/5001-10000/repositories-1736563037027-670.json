{
  "metadata": {
    "timestamp": 1736563037027,
    "page": 670,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "PrismarineJS/mineflayer",
      "stars": 5276,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1826171875,
          "content": "# shared with .npmignore\n# different than .npmignore\nnode_modules\npackage-lock.json\nyarn.lock\n/README.md\nversions/\nserver_jars/\ntest/server_*\n.vscode\n.DS_Store\nlauncher_accounts.json\ndata"
        },
        {
          "name": ".gitpod.yml",
          "type": "blob",
          "size": 0.048828125,
          "content": "tasks:\n- command: npm install && sdk install java\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.056640625,
          "content": "# shared with .gitignore\n# different than .gitignore\ntest\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.037109375,
          "content": "engine-strict=true\npackage-lock=false\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Andrew Kelley\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.d.ts",
          "type": "blob",
          "size": 22.4580078125,
          "content": "import { EventEmitter } from 'events'\nimport TypedEmitter from 'typed-emitter'\nimport { Client, ClientOptions } from 'minecraft-protocol'\nimport { Vec3 } from 'vec3'\nimport { Item } from 'prismarine-item'\nimport { Window } from 'prismarine-windows'\nimport { Recipe } from 'prismarine-recipe'\nimport { Block } from 'prismarine-block'\nimport { Entity } from 'prismarine-entity'\nimport { ChatMessage } from 'prismarine-chat'\nimport { world } from 'prismarine-world'\nimport { Registry } from 'prismarine-registry'\nimport { IndexedData } from 'minecraft-data'\n\nexport function createBot (options: { client: Client } & Partial<BotOptions>): Bot\nexport function createBot (options: BotOptions): Bot\n\nexport interface BotOptions extends ClientOptions {\n  logErrors?: boolean\n  hideErrors?: boolean\n  loadInternalPlugins?: boolean\n  plugins?: PluginOptions\n  chat?: ChatLevel\n  colorsEnabled?: boolean\n  viewDistance?: ViewDistance\n  mainHand?: MainHands\n  difficulty?: number\n  chatLengthLimit?: number\n  physicsEnabled?: boolean\n  /** @default 4 */\n  maxCatchupTicks?: number\n  client?: Client\n  brand?: string\n  defaultChatPatterns?: boolean\n  respawn?: boolean\n}\n\nexport type ChatLevel = 'enabled' | 'commandsOnly' | 'disabled'\nexport type ViewDistance = 'far' | 'normal' | 'short' | 'tiny' | number\nexport type MainHands = 'left' | 'right'\n\nexport interface PluginOptions {\n  [plugin: string]: boolean | Plugin\n}\n\nexport type Plugin = (bot: Bot, options: BotOptions) => void\n\nexport interface BotEvents {\n  chat: (\n    username: string,\n    message: string,\n    translate: string | null,\n    jsonMsg: ChatMessage,\n    matches: string[] | null\n  ) => Promise<void> | void\n  whisper: (\n    username: string,\n    message: string,\n    translate: string | null,\n    jsonMsg: ChatMessage,\n    matches: string[] | null\n  ) => Promise<void> | void\n  actionBar: (jsonMsg: ChatMessage) => Promise<void> | void\n  error: (err: Error) => Promise<void> | void\n  message: (jsonMsg: ChatMessage, position: string) => Promise<void> | void\n  messagestr: (message: string, position: string, jsonMsg: ChatMessage) => Promise<void> | void\n  unmatchedMessage: (stringMsg: string, jsonMsg: ChatMessage) => Promise<void> | void\n  inject_allowed: () => Promise<void> | void\n  login: () => Promise<void> | void\n  /** When `respawn` option is disabled, you can call this method manually to respawn. */\n  spawn: () => Promise<void> | void\n  respawn: () => Promise<void> | void\n  game: () => Promise<void> | void\n  title: (text: string, type: \"subtitle\" | \"title\") => Promise<void> | void\n  rain: () => Promise<void> | void\n  time: () => Promise<void> | void\n  kicked: (reason: string, loggedIn: boolean) => Promise<void> | void\n  end: (reason: string) => Promise<void> | void\n  spawnReset: () => Promise<void> | void\n  death: () => Promise<void> | void\n  health: () => Promise<void> | void\n  breath: () => Promise<void> | void\n  entitySwingArm: (entity: Entity) => Promise<void> | void\n  entityHurt: (entity: Entity) => Promise<void> | void\n  entityDead: (entity: Entity) => Promise<void> | void\n  entityTaming: (entity: Entity) => Promise<void> | void\n  entityTamed: (entity: Entity) => Promise<void> | void\n  entityShakingOffWater: (entity: Entity) => Promise<void> | void\n  entityEatingGrass: (entity: Entity) => Promise<void> | void\n  entityHandSwap: (entity: Entity) => Promise<void> | void\n  entityWake: (entity: Entity) => Promise<void> | void\n  entityEat: (entity: Entity) => Promise<void> | void\n  entityCriticalEffect: (entity: Entity) => Promise<void> | void\n  entityMagicCriticalEffect: (entity: Entity) => Promise<void> | void\n  entityCrouch: (entity: Entity) => Promise<void> | void\n  entityUncrouch: (entity: Entity) => Promise<void> | void\n  entityEquip: (entity: Entity) => Promise<void> | void\n  entitySleep: (entity: Entity) => Promise<void> | void\n  entitySpawn: (entity: Entity) => Promise<void> | void\n  entityElytraFlew: (entity: Entity) => Promise<void> | void\n  usedFirework: () => Promise<void> | void\n  itemDrop: (entity: Entity) => Promise<void> | void\n  playerCollect: (collector: Entity, collected: Entity) => Promise<void> | void\n  entityAttributes: (entity: Entity) => Promise<void> | void\n  entityGone: (entity: Entity) => Promise<void> | void\n  entityMoved: (entity: Entity) => Promise<void> | void\n  entityDetach: (entity: Entity, vehicle: Entity) => Promise<void> | void\n  entityAttach: (entity: Entity, vehicle: Entity) => Promise<void> | void\n  entityUpdate: (entity: Entity) => Promise<void> | void\n  entityEffect: (entity: Entity, effect: Effect) => Promise<void> | void\n  entityEffectEnd: (entity: Entity, effect: Effect) => Promise<void> | void\n  playerJoined: (player: Player) => Promise<void> | void\n  playerUpdated: (player: Player) => Promise<void> | void\n  playerLeft: (entity: Player) => Promise<void> | void\n  blockUpdate: (oldBlock: Block | null, newBlock: Block) => Promise<void> | void\n  'blockUpdate:(x, y, z)': (oldBlock: Block | null, newBlock: Block | null) => Promise<void> | void\n  chunkColumnLoad: (entity: Vec3) => Promise<void> | void\n  chunkColumnUnload: (entity: Vec3) => Promise<void> | void\n  soundEffectHeard: (\n    soundName: string,\n    position: Vec3,\n    volume: number,\n    pitch: number\n  ) => Promise<void> | void\n  hardcodedSoundEffectHeard: (\n    soundId: number,\n    soundCategory: number,\n    position: Vec3,\n    volume: number,\n    pitch: number\n  ) => Promise<void> | void\n  noteHeard: (block: Block, instrument: Instrument, pitch: number) => Promise<void> | void\n  pistonMove: (block: Block, isPulling: number, direction: number) => Promise<void> | void\n  chestLidMove: (block: Block, isOpen: number, block2: Block | null) => Promise<void> | void\n  blockBreakProgressObserved: (block: Block, destroyStage: number) => Promise<void> | void\n  blockBreakProgressEnd: (block: Block) => Promise<void> | void\n  diggingCompleted: (block: Block) => Promise<void> | void\n  diggingAborted: (block: Block) => Promise<void> | void\n  move: (position: Vec3) => Promise<void> | void\n  forcedMove: () => Promise<void> | void\n  mount: () => Promise<void> | void\n  dismount: (vehicle: Entity) => Promise<void> | void\n  windowOpen: (window: Window) => Promise<void> | void\n  windowClose: (window: Window) => Promise<void> | void\n  sleep: () => Promise<void> | void\n  wake: () => Promise<void> | void\n  experience: () => Promise<void> | void\n  physicsTick: () => Promise<void> | void\n  physicTick: () => Promise<void> | void\n  scoreboardCreated: (scoreboard: ScoreBoard) => Promise<void> | void\n  scoreboardDeleted: (scoreboard: ScoreBoard) => Promise<void> | void\n  scoreboardTitleChanged: (scoreboard: ScoreBoard) => Promise<void> | void\n  scoreUpdated: (scoreboard: ScoreBoard, item: number) => Promise<void> | void\n  scoreRemoved: (scoreboard: ScoreBoard, item: number) => Promise<void> | void\n  scoreboardPosition: (position: DisplaySlot, scoreboard: ScoreBoard) => Promise<void> | void\n  teamCreated: (team: Team) => Promise<void> | void\n  teamRemoved: (team: Team) => Promise<void> | void\n  teamUpdated: (team: Team) => Promise<void> | void\n  teamMemberAdded: (team: Team) => Promise<void> | void\n  teamMemberRemoved: (team: Team) => Promise<void> | void\n  bossBarCreated: (bossBar: BossBar) => Promise<void> | void\n  bossBarDeleted: (bossBar: BossBar) => Promise<void> | void\n  bossBarUpdated: (bossBar: BossBar) => Promise<void> | void\n  resourcePack: (url: string, hash?: string, uuid?: string) => Promise<void> | void\n  particle: (particle: Particle) => Promise<void> | void\n}\n\nexport interface CommandBlockOptions {\n  mode: number,\n  trackOutput: boolean,\n  conditional: boolean,\n  alwaysActive: boolean\n}\n\nexport interface Bot extends TypedEmitter<BotEvents> {\n  username: string\n  protocolVersion: string\n  majorVersion: string\n  version: string\n  entity: Entity\n  entities: { [id: string]: Entity }\n  fireworkRocketDuration: number\n  spawnPoint: Vec3\n  game: GameState\n  player: Player\n  players: { [username: string]: Player }\n  isRaining: boolean\n  thunderState: number\n  chatPatterns: ChatPattern[]\n  settings: GameSettings\n  experience: Experience\n  health: number\n  food: number\n  foodSaturation: number\n  oxygenLevel: number\n  physics: PhysicsOptions\n  physicsEnabled: boolean\n  time: Time\n  quickBarSlot: number\n  inventory: Window<StorageEvents>\n  targetDigBlock: Block\n  isSleeping: boolean\n  scoreboards: { [name: string]: ScoreBoard }\n  scoreboard: { [slot in DisplaySlot]: ScoreBoard }\n  teams: { [name: string]: Team }\n  teamMap: { [name: string]: Team }\n  controlState: ControlStateStatus\n  creative: creativeMethods\n  world: world.WorldSync\n  _client: Client\n  heldItem: Item | null\n  usingHeldItem: boolean\n  currentWindow: Window | null\n  simpleClick: simpleClick\n  tablist: Tablist\n  registry: Registry\n\n  connect: (options: BotOptions) => void\n\n  supportFeature: IndexedData['supportFeature']\n\n  end: (reason?: string) => void\n\n  blockAt: (point: Vec3, extraInfos?: boolean) => Block | null\n\n  blockInSight: (maxSteps: number, vectorLength: number) => Block | null\n\n  blockAtCursor: (maxDistance?: number, matcher?: Function) => Block | null\n  blockAtEntityCursor: (entity?: Entity, maxDistance?: number, matcher?: Function) => Block | null\n\n  canSeeBlock: (block: Block) => boolean\n\n  findBlock: (options: FindBlockOptions) => Block | null\n\n  findBlocks: (options: FindBlockOptions) => Vec3[]\n\n  canDigBlock: (block: Block) => boolean\n\n  recipesFor: (\n    itemType: number,\n    metadata: number | null,\n    minResultCount: number | null,\n    craftingTable: Block | boolean | null\n  ) => Recipe[]\n\n  recipesAll: (\n    itemType: number,\n    metadata: number | null,\n    craftingTable: Block | boolean | null\n  ) => Recipe[]\n\n  quit: (reason?: string) => void\n\n  tabComplete: (\n    str: string,\n    assumeCommand?: boolean,\n    sendBlockInSight?: boolean,\n    timeout?: number\n  ) => Promise<string[]>\n\n  chat: (message: string) => void\n\n  whisper: (username: string, message: string) => void\n\n  chatAddPattern: (pattern: RegExp, chatType: string, description?: string) => number\n\n  setSettings: (options: Partial<GameSettings>) => void\n\n  loadPlugin: (plugin: Plugin) => void\n\n  loadPlugins: (plugins: Plugin[]) => void\n\n  hasPlugin: (plugin: Plugin) => boolean\n\n  sleep: (bedBlock: Block) => Promise<void>\n\n  isABed: (bedBlock: Block) => boolean\n\n  wake: () => Promise<void>\n\n  elytraFly: () => Promise<void>\n\n  setControlState: (control: ControlState, state: boolean) => void\n\n  getControlState: (control: ControlState) => boolean\n\n  clearControlStates: () => void\n\n  getExplosionDamages: (targetEntity: Entity, position: Vec3, radius: number, rawDamages?: boolean) => number | null\n\n  lookAt: (point: Vec3, force?: boolean) => Promise<void>\n\n  look: (\n    yaw: number,\n    pitch: number,\n    force?: boolean\n  ) => Promise<void>\n\n  updateSign: (block: Block, text: string, back?: boolean) => void\n\n  equip: (\n    item: Item | number,\n    destination: EquipmentDestination | null\n  ) => Promise<void>\n\n  unequip: (\n    destination: EquipmentDestination | null\n  ) => Promise<void>\n\n  tossStack: (item: Item) => Promise<void>\n\n  toss: (\n    itemType: number,\n    metadata: number | null,\n    count: number | null\n  ) => Promise<void>\n\n  dig: ((block: Block, forceLook?: boolean | 'ignore') => Promise<void>) & ((block: Block, forceLook: boolean | 'ignore', digFace: 'auto' | Vec3 | 'raycast') => Promise<void>)\n\n  stopDigging: () => void\n\n  digTime: (block: Block) => number\n\n  placeBlock: (referenceBlock: Block, faceVector: Vec3) => Promise<void>\n\n  placeEntity: (referenceBlock: Block, faceVector: Vec3) => Promise<Entity>\n\n  activateBlock: (block: Block, direction?: Vec3, cursorPos?: Vec3) => Promise<void>\n\n  activateEntity: (entity: Entity) => Promise<void>\n\n  activateEntityAt: (entity: Entity, position: Vec3) => Promise<void>\n\n  consume: () => Promise<void>\n\n  fish: () => Promise<void>\n\n  activateItem: (offhand?: boolean) => void\n\n  deactivateItem: () => void\n\n  useOn: (targetEntity: Entity) => void\n\n  attack: (entity: Entity) => void\n\n  swingArm: (hand: 'left' | 'right' | undefined, showHand?: boolean) => void\n\n  mount: (entity: Entity) => void\n\n  dismount: () => void\n\n  moveVehicle: (left: number, forward: number) => void\n\n  setQuickBarSlot: (slot: number) => void\n\n  craft: (\n    recipe: Recipe,\n    count?: number,\n    craftingTable?: Block\n  ) => Promise<void>\n\n  writeBook: (\n    slot: number,\n    pages: string[]\n  ) => Promise<void>\n\n  openContainer: (chest: Block | Entity, direction?: Vec3, cursorPos?: Vec3) => Promise<Chest | Dispenser>\n\n  openChest: (chest: Block | Entity, direction?: number, cursorPos?: Vec3) => Promise<Chest>\n\n  openFurnace: (furnace: Block) => Promise<Furnace>\n\n  openDispenser: (dispenser: Block) => Promise<Dispenser>\n\n  openEnchantmentTable: (enchantmentTable: Block) => Promise<EnchantmentTable>\n\n  openAnvil: (anvil: Block) => Promise<Anvil>\n\n  openVillager: (\n    villager: Entity\n  ) => Promise<Villager>\n\n  trade: (\n    villagerInstance: Villager,\n    tradeIndex: string | number,\n    times?: number\n  ) => Promise<void>\n\n  \n  \n  setCommandBlock: (pos: Vec3, command: string, options: CommandBlockOptions) => void\n\n  clickWindow: (\n    slot: number,\n    mouseButton: number,\n    mode: number\n  ) => Promise<void>\n\n  putSelectedItemRange: (\n    start: number,\n    end: number,\n    window: Window,\n    slot: any\n  ) => Promise<void>\n\n  putAway: (slot: number) => Promise<void>\n\n  closeWindow: (window: Window) => void\n\n  transfer: (options: TransferOptions) => Promise<void>\n\n  openBlock: (block: Block, direction?: Vec3, cursorPos?: Vec3) => Promise<Window>\n\n  openEntity: (block: Entity, Class: new () => EventEmitter) => Promise<Window>\n\n  moveSlotItem: (\n    sourceSlot: number,\n    destSlot: number\n  ) => Promise<void>\n\n  updateHeldItem: () => void\n\n  getEquipmentDestSlot: (destination: string) => number\n\n  waitForChunksToLoad: () => Promise<void>\n\n  entityAtCursor: (maxDistance?: number) => Entity | null\n  nearestEntity: (filter?: (entity: Entity) => boolean) => Entity | null\n\n  waitForTicks: (ticks: number) => Promise<void>\n\n  addChatPattern: (name: string, pattern: RegExp, options?: chatPatternOptions) => number\n\n  addChatPatternSet: (name: string, patterns: RegExp[], options?: chatPatternOptions) => number\n\n  removeChatPattern: (name: string | number) => void\n\n  awaitMessage: (...args: string[] | RegExp[]) => Promise<string>\n\n  acceptResourcePack: () => void\n\n  denyResourcePack: () => void\n\n  respawn: () => void\n}\n\nexport interface simpleClick {\n  leftMouse: (slot: number) => Promise<void>\n  rightMouse: (slot: number) => Promise<void>\n}\n\nexport interface Tablist {\n  header: ChatMessage\n  footer: ChatMessage\n}\n\nexport interface chatPatternOptions {\n  repeat: boolean\n  parse: boolean\n}\n\nexport interface GameState {\n  levelType: LevelType\n  gameMode: GameMode\n  hardcore: boolean\n  dimension: Dimension\n  difficulty: Difficulty\n  maxPlayers: number\n  serverBrand: string\n}\n\nexport type LevelType =\n  | 'default'\n  | 'flat'\n  | 'largeBiomes'\n  | 'amplified'\n  | 'customized'\n  | 'buffet'\n  | 'default_1_1'\nexport type GameMode = 'survival' | 'creative' | 'adventure' | 'spectator'\nexport type Dimension = 'the_nether' | 'overworld' | 'the_end'\nexport type Difficulty = 'peaceful' | 'easy' | 'normal' | 'hard'\n\nexport interface Player {\n  uuid: string\n  username: string\n  displayName: ChatMessage\n  gamemode: number\n  ping: number\n  entity: Entity\n  skinData: SkinData | undefined\n  profileKeys?: {\n    publicKey: Buffer\n    signature: Buffer\n  }\n}\n\nexport interface SkinData {\n  url: string\n  model: string | null\n}\n\nexport interface ChatPattern {\n  pattern: RegExp\n  type: string\n  description: string\n}\n\nexport interface SkinParts {\n  showCape: boolean\n  showJacket: boolean\n  showLeftSleeve: boolean\n  showRightSleeve: boolean\n  showLeftPants: boolean\n  showRightPants: boolean\n  showHat: boolean\n}\n\nexport interface GameSettings {\n  chat: ChatLevel\n  colorsEnabled: boolean\n  viewDistance: ViewDistance\n  difficulty: number\n  skinParts: SkinParts\n  mainHand: MainHands\n}\n\nexport interface Experience {\n  level: number\n  points: number\n  progress: number\n}\n\nexport interface PhysicsOptions {\n  maxGroundSpeed: number\n  terminalVelocity: number\n  walkingAcceleration: number\n  gravity: number\n  groundFriction: number\n  playerApothem: number\n  playerHeight: number\n  jumpSpeed: number\n  yawSpeed: number\n  pitchSpeed: number\n  sprintSpeed: number\n  maxGroundSpeedSoulSand: number\n  maxGroundSpeedWater: number\n}\n\nexport interface Time {\n  doDaylightCycle: boolean\n  bigTime: BigInt\n  time: number\n  timeOfDay: number\n  day: number\n  isDay: boolean\n  moonPhase: number\n  bigAge: BigInt\n  age: number\n}\n\nexport interface ControlStateStatus {\n  forward: boolean\n  back: boolean\n  left: boolean\n  right: boolean\n  jump: boolean\n  sprint: boolean\n  sneak: boolean\n}\n\nexport type ControlState =\n  | 'forward'\n  | 'back'\n  | 'left'\n  | 'right'\n  | 'jump'\n  | 'sprint'\n  | 'sneak'\n\nexport interface Effect {\n  id: number\n  amplifier: number\n  duration: number\n}\n\nexport interface Instrument {\n  id: number\n  name: 'harp' | 'doubleBass' | 'snareDrum' | 'sticks' | 'bassDrum'\n}\n\nexport interface FindBlockOptions {\n  point?: Vec3\n  matching: number | number[] | ((block: Block) => boolean)\n  maxDistance?: number\n  count?: number\n  useExtraInfo?: boolean | ((block: Block) => boolean)\n}\n\nexport type EquipmentDestination = 'hand' | 'head' | 'torso' | 'legs' | 'feet' | 'off-hand'\n\nexport interface TransferOptions {\n  window: Window\n  itemType: number\n  metadata: number | null\n  count?: number,\n  sourceStart: number\n  sourceEnd: number\n  destStart: number\n  destEnd: number\n}\n\nexport interface creativeMethods {\n  setInventorySlot: (\n    slot: number,\n    item: Item | null\n  ) => Promise<void>\n\n  clearSlot: (slot: number) => Promise<void>\n\n  clearInventory: () => Promise<void>\n\n  flyTo: (destination: Vec3) => Promise<void>\n\n  startFlying: () => void\n\n  stopFlying: () => void\n}\n\nexport class Location {\n  floored: Vec3\n  blockPoint: Vec3\n  chunkCorner: Vec3\n  blockIndex: number\n  biomeBlockIndex: number\n  chunkYIndex: number\n\n  constructor (absoluteVector: Vec3);\n}\n\nexport class Painting {\n  id: number\n  position: Vec3\n  name: string\n  direction: Vec3\n\n  constructor (id: number, position: Vec3, name: string, direction: Vec3);\n}\n\ninterface StorageEvents {\n  open: () => void\n  close: () => void\n  updateSlot: (slot: number, oldItem: Item | null, newItem: Item | null) => void\n}\n\ninterface FurnaceEvents extends StorageEvents {\n  update: () => void\n}\n\ninterface ConditionalStorageEvents extends StorageEvents {\n  ready: () => void\n}\n\nexport class Chest extends Window<StorageEvents> {\n  constructor ();\n\n  close (): void;\n\n  deposit (\n    itemType: number,\n    metadata: number | null,\n    count: number | null\n  ): Promise<void>;\n\n  withdraw (\n    itemType: number,\n    metadata: number | null,\n    count: number | null\n  ): Promise<void>;\n}\n\nexport class Furnace extends Window<FurnaceEvents> {\n  fuel: number\n  progress: number\n\n  constructor ();\n\n  close (): void;\n\n  takeInput (): Promise<Item>;\n\n  takeFuel (): Promise<Item>;\n\n  takeOutput (): Promise<Item>;\n\n  putInput (\n    itemType: number,\n    metadata: number | null,\n    count: number\n  ): Promise<void>;\n\n  putFuel (\n    itemType: number,\n    metadata: number | null,\n    count: number\n  ): Promise<void>;\n\n  inputItem (): Item;\n\n  fuelItem (): Item;\n\n  outputItem (): Item;\n}\n\nexport class Dispenser extends Window<StorageEvents> {\n  constructor ();\n\n  close (): void;\n\n  deposit (\n    itemType: number,\n    metadata: number | null,\n    count: number | null\n  ): Promise<void>;\n\n  withdraw (\n    itemType: number,\n    metadata: number | null,\n    count: number | null\n  ): Promise<void>;\n}\n\nexport class EnchantmentTable extends Window<ConditionalStorageEvents> {\n  enchantments: Enchantment[]\n\n  constructor ();\n\n  close (): void;\n\n  targetItem (): Item;\n\n  enchant (\n    choice: string | number\n  ): Promise<Item>;\n\n  takeTargetItem (): Promise<Item>;\n\n  putTargetItem (item: Item): Promise<Item>;\n\n  putLapis (item: Item): Promise<Item>;\n}\n\nexport class Anvil {\n  combine (itemOne: Item, itemTwo: Item, name?: string): Promise<void>\n  rename (item: Item, name?: string): Promise<void>\n}\n\nexport interface Enchantment {\n  level: number\n  expected: { enchant: number, level: number }\n}\n\nexport class Villager extends Window<ConditionalStorageEvents> {\n  trades: VillagerTrade[]\n\n  constructor ();\n\n  close (): void;\n}\n\nexport interface VillagerTrade {\n  inputItem1: Item\n  outputItem: Item\n  inputItem2: Item | null\n  hasItem2: boolean\n  tradeDisabled: boolean\n  nbTradeUses: number\n  maximumNbTradeUses: number\n  xp?: number\n  specialPrice?: number\n  priceMultiplier?: number\n  demand?: number\n  realPrice?: number\n}\n\nexport class ScoreBoard {\n  name: string\n  title: string\n  itemsMap: { [name: string]: ScoreBoardItem }\n  items: ScoreBoardItem[]\n\n  constructor (packet: object);\n\n  setTitle (title: string): void;\n\n  add(name: string, value: number): ScoreBoardItem;\n\n  remove (name: string): ScoreBoardItem;\n}\n\nexport interface ScoreBoardItem {\n  name: string\n  displayName: ChatMessage\n  value: number\n}\n\nexport class Team {\n  team: string\n  name: ChatMessage\n  friendlyFire: number\n  nameTagVisibility: string\n  collisionRule: string\n  color: string\n  prefix: ChatMessage\n  suffix: ChatMessage\n  memberMap: { [name: string]: '' }\n  members: string[]\n\n  constructor(team: string, name: string, friendlyFire: boolean, nameTagVisibility: string, collisionRule: string, formatting: number, prefix: string, suffix: string);\n\n  parseMessage (value: string): ChatMessage;\n\n  add (name: string, value: number): void;\n\n  remove (name: string): void;\n\n  update (name: string, friendlyFire: boolean, nameTagVisibility: string, collisionRule: string, formatting: number, prefix: string, suffix: string): void;\n\n  displayName (member: string): ChatMessage;\n}\n\nexport type DisplaySlot =\n  | 'list'\n  | 'sidebar'\n  | 'belowName'\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n\nexport class BossBar {\n  entityUUID: string\n  title: ChatMessage\n  health: number\n  dividers: number\n  color: 'pink' | 'blue' | 'red' | 'green' | 'yellow' | 'purple' | 'white'\n  shouldDarkenSky: boolean\n  isDragonBar: boolean\n  createFog: boolean\n  shouldCreateFog: boolean\n\n  constructor (\n    uuid: string,\n    title: string,\n    health: number,\n    dividers: number,\n    color: number,\n    flags: number\n  );\n}\n\nexport class Particle {\n  id: number\n  position: Vec3\n  offset: Vec3\n  count: number\n  movementSpeed: number\n  longDistanceRender: boolean\n  static fromNetwork(packet: Object): Particle\n\n  constructor(\n    id: number,\n    position: Vec3,\n    offset: Vec3,\n    count?: number,\n    movementSpeed?: number,\n    longDistanceRender?: boolean\n  );\n}\n\nexport let testedVersions: string[]\nexport let latestSupportedVersion: string\nexport let oldestSupportedVersion: string\n\nexport function supportFeature (feature: string, version: string): boolean\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 0.359375,
          "content": "if (typeof process !== 'undefined' && !process.browser && process.platform !== 'browser' && parseInt(process.versions.node.split('.')[0]) < 18) {\n  console.error('Your node version is currently', process.versions.node)\n  console.error('Please update it to a version >= 18.x.x from https://nodejs.org/')\n  process.exit(1)\n}\n\nmodule.exports = require('./lib/loader.js')\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.45703125,
          "content": "{\n  \"name\": \"mineflayer\",\n  \"version\": \"4.25.0\",\n  \"description\": \"create minecraft bots with a stable, high level API\",\n  \"main\": \"index.js\",\n  \"types\": \"index.d.ts\",\n  \"scripts\": {\n    \"mocha_test\": \"mocha --reporter spec --exit\",\n    \"test\": \"npm run mocha_test\",\n    \"pretest\": \"npm run lint\",\n    \"lint\": \"standard && standard-markdown\",\n    \"fix\": \"standard --fix && standard-markdown --fix\",\n    \"prepublishOnly\": \"cp docs/README.md README.md\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/PrismarineJS/mineflayer.git\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"minecraft-data\": \"^3.76.0\",\n    \"minecraft-protocol\": \"^1.51.0\",\n    \"prismarine-biome\": \"^1.1.1\",\n    \"prismarine-block\": \"^1.17.0\",\n    \"prismarine-chat\": \"^1.7.1\",\n    \"prismarine-chunk\": \"^1.36.0\",\n    \"prismarine-entity\": \"^2.3.0\",\n    \"prismarine-item\": \"^1.15.0\",\n    \"prismarine-nbt\": \"^2.0.0\",\n    \"prismarine-physics\": \"^1.9.0\",\n    \"prismarine-recipe\": \"^1.3.0\",\n    \"prismarine-registry\": \"^1.10.0\",\n    \"prismarine-windows\": \"^2.9.0\",\n    \"prismarine-world\": \"^3.6.0\",\n    \"protodef\": \"^1.18.0\",\n    \"typed-emitter\": \"^1.0.0\",\n    \"vec3\": \"^0.1.7\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^22.1.0\",\n    \"doctoc\": \"^2.0.1\",\n    \"minecraft-wrap\": \"^1.3.0\",\n    \"mineflayer\": \"file:\",\n    \"mocha\": \"^11.0.1\",\n    \"protodef-yaml\": \"^1.5.3\",\n    \"standard\": \"^17.0.0\",\n    \"standard-markdown\": \"^7.1.0\",\n    \"typescript\": \"^5.4.5\"\n  }\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tsconfig.json",
          "type": "blob",
          "size": 0.130859375,
          "content": "{\n    \"compilerOptions\": {\n      \"module\": \"commonjs\",\n      \"strictNullChecks\": true\n    },\n    \"files\": [\n      \"index.d.ts\"\n    ]\n}"
        }
      ]
    }
  ]
}