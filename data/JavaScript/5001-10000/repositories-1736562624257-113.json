{
  "metadata": {
    "timestamp": 1736562624257,
    "page": 113,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sxei/chrome-plugin-demo",
      "stars": 8420,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 49.591796875,
          "content": "# 写在前面\n\n我花了将近一个多月的时间断断续续写下这篇博文，并精心写下完整demo，所以转载务必保留 http://blog.haoji.me/chrome-plugin-develop.html 。本文所有涉及到的大部分代码均在这个demo里面：https://github.com/sxei/chrome-plugin-demo ，大家可以直接下载下来运行。\n\n另外，本文图片较多，请耐心等待加载完毕。\n\n本文目录：\n\n![](http://image.liuxianan.com/201707/20170710_222547_735_9922.png)\n\ndemo部分截图：\n\n![](http://image.liuxianan.com/201707/20170710_223150_516_6129.png)\n\n鉴于有很多网友有交流学习Chrome插件的诉求，所以最近建了一个插件开发交流群，仅仅是为了提供一个互相交流学习的平台：\n\n![_W791xH370_](https://img.alicdn.com/tfs/TB1rvUrJpY7gK0jSZKzXXaikpXa-1582-740.png)\n\n## 仓库说明\n\n* `full-chrome-plugin-demo`：大部分demo代码都在这个仓库；\n* `simple-chrome-plugin-demo`：最精简的Chrome仓库模板，当需要快速写一个简单仓库时可以基于这个模板；\n* `page-action-demo`：关于`page-action`部分的demo代码，由于这部分代码和`full-chrome-plugin-demo`冲突，所以单独拿出来；\n\n# 前言\n\n## 什么是Chrome插件\n\n严格来讲，我们正在说的东西应该叫Chrome扩展(`Chrome Extension`)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯，本文也全部采用这种叫法，但读者需深知本文所描述的Chrome插件实际上指的是Chrome扩展。\n\nChrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个[.crx](https://developer.chrome.com/extensions/crx)后缀的压缩包.\n\n个人猜测`crx`可能是`Chrome Extension`如下3个字母的简写：\n\n![](http://image.liuxianan.com/201706/20170619_114836_364_3616.png)\n\n另外，其实不只是前端技术，Chrome插件还可以配合C++编写的dll动态链接库实现一些更底层的功能(NPAPI)，比如全屏幕截图。\n\n![360抢票王插件dll截图](http://image.liuxianan.com/201706/20170626_112802_406_9027.png)\n\n> 由于安全原因，Chrome浏览器42以上版本已经陆续不再支持NPAPI插件，取而代之的是更安全的PPAPI。\n\n## 学习Chrome插件开发有什么意义\n\n增强浏览器功能，轻松实现属于自己的“定制版”浏览器，等等。\n\nChrome插件提供了很多实用API供我们使用，包括但不限于：\n\n* 书签控制；\n* 下载控制；\n* 窗口控制；\n* 标签控制；\n* 网络请求控制，各类事件监听；\n* 自定义原生菜单；\n* 完善的通信机制；\n* 等等；\n\n## 为什么是Chrome插件而不是Firefox插件\n\n1. Chrome占有率更高，更多人用；\n2. 开发更简单；\n3. 应用场景更广泛，Firefox插件只能运行在Firefox上，而Chrome除了Chrome浏览器之外，还可以运行在所有webkit内核的国产浏览器，比如360极速浏览器、360安全浏览器、搜狗浏览器、QQ浏览器等等；\n4. 除此之外，Firefox浏览器也对Chrome插件的运行提供了一定的支持；\n\n# 开发与调试\n\nChrome插件没有严格的项目结构要求，只要保证本目录有一个`manifest.json`即可，也不需要专门的IDE，普通的web开发工具即可。\n\n从右上角菜单->更多工具->扩展程序可以进入 插件管理页面，也可以直接在地址栏输入 [chrome://extensions](chrome://extensions/) 访问。\n\n![](http://image.liuxianan.com/201706/20170620_195047_992_5668.png)\n\n勾选`开发者模式`即可以文件夹的形式直接加载插件，否则只能安装`.crx`格式的文件。Chrome要求插件必须从它的Chrome应用商店安装，其它任何网站下载的都无法直接安装，所以，其实我们可以把`crx`文件解压，然后通过开发者模式直接加载。\n\n开发中，代码有任何改动都必须重新加载插件，只需要在插件管理页按下`Ctrl+R`即可，以防万一最好还把页面刷新一下。\n\n# 核心介绍\n\n## manifest.json\n\n这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，`manifest_version`、`name`、`version`3个是必不可少的，`description`和`icons`是推荐的。\n\n下面给出的是一些常见的配置项，均有中文注释，完整的配置文档请戳[这里](https://developer.chrome.com/extensions/manifest)。\n\n```javascript\n{\n\t// 清单文件的版本，这个必须写，而且必须是2\n\t\"manifest_version\": 2,\n\t// 插件的名称\n\t\"name\": \"demo\",\n\t// 插件的版本\n\t\"version\": \"1.0.0\",\n\t// 插件描述\n\t\"description\": \"简单的Chrome扩展demo\",\n\t// 图标，一般偷懒全部用一个尺寸的也没问题\n\t\"icons\":\n\t{\n\t\t\"16\": \"img/icon.png\",\n\t\t\"48\": \"img/icon.png\",\n\t\t\"128\": \"img/icon.png\"\n\t},\n\t// 会一直常驻的后台JS或后台页面\n\t\"background\":\n\t{\n\t\t// 2种指定方式，如果指定JS，那么会自动生成一个背景页\n\t\t\"page\": \"background.html\"\n\t\t//\"scripts\": [\"js/background.js\"]\n\t},\n\t// 浏览器右上角图标设置，browser_action、page_action、app必须三选一\n\t\"browser_action\": \n\t{\n\t\t\"default_icon\": \"img/icon.png\",\n\t\t// 图标悬停时的标题，可选\n\t\t\"default_title\": \"这是一个示例Chrome插件\",\n\t\t\"default_popup\": \"popup.html\"\n\t},\n\t// 当某些特定页面打开才显示的图标\n\t/*\"page_action\":\n\t{\n\t\t\"default_icon\": \"img/icon.png\",\n\t\t\"default_title\": \"我是pageAction\",\n\t\t\"default_popup\": \"popup.html\"\n\t},*/\n\t// 需要直接注入页面的JS\n\t\"content_scripts\": \n\t[\n\t\t{\n\t\t\t//\"matches\": [\"http://*/*\", \"https://*/*\"],\n\t\t\t// \"<all_urls>\" 表示匹配所有地址\n\t\t\t\"matches\": [\"<all_urls>\"],\n\t\t\t// 多个JS按顺序注入\n\t\t\t\"js\": [\"js/jquery-1.8.3.js\", \"js/content-script.js\"],\n\t\t\t// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式\n\t\t\t\"css\": [\"css/custom.css\"],\n\t\t\t// 代码注入的时间，可选值： \"document_start\", \"document_end\", or \"document_idle\"，最后一个表示页面空闲时，默认document_idle\n\t\t\t\"run_at\": \"document_start\"\n\t\t},\n\t\t// 这里仅仅是为了演示content-script可以配置多个规则\n\t\t{\n\t\t\t\"matches\": [\"*://*/*.png\", \"*://*/*.jpg\", \"*://*/*.gif\", \"*://*/*.bmp\"],\n\t\t\t\"js\": [\"js/show-image-content-size.js\"]\n\t\t}\n\t],\n\t// 权限申请\n\t\"permissions\":\n\t[\n\t\t\"contextMenus\", // 右键菜单\n\t\t\"tabs\", // 标签\n\t\t\"notifications\", // 通知\n\t\t\"webRequest\", // web请求\n\t\t\"webRequestBlocking\",\n\t\t\"storage\", // 插件本地存储\n\t\t\"http://*/*\", // 可以通过executeScript或者insertCSS访问的网站\n\t\t\"https://*/*\" // 可以通过executeScript或者insertCSS访问的网站\n\t],\n\t// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的\n\t\"web_accessible_resources\": [\"js/inject.js\"],\n\t// 插件主页，这个很重要，不要浪费了这个免费广告位\n\t\"homepage_url\": \"https://www.baidu.com\",\n\t// 覆盖浏览器默认页面\n\t\"chrome_url_overrides\":\n\t{\n\t\t// 覆盖浏览器默认的新标签页\n\t\t\"newtab\": \"newtab.html\"\n\t},\n\t// Chrome40以前的插件配置页写法\n\t\"options_page\": \"options.html\",\n\t// Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个\n\t\"options_ui\":\n\t{\n\t\t\"page\": \"options.html\",\n\t\t// 添加一些默认的样式，推荐使用\n\t\t\"chrome_style\": true\n\t},\n\t// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字\n\t\"omnibox\": { \"keyword\" : \"go\" },\n\t// 默认语言\n\t\"default_locale\": \"zh_CN\",\n\t// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件\n\t\"devtools_page\": \"devtools.html\"\n}\n```\n\n## content-scripts\n\n所谓[content-scripts](https://developer.chrome.com/extensions/content_scripts)，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助`content-scripts`我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。\n\n示例配置：\n\n```javascript\n{\n\t// 需要直接注入页面的JS\n\t\"content_scripts\": \n\t[\n\t\t{\n\t\t\t//\"matches\": [\"http://*/*\", \"https://*/*\"],\n\t\t\t// \"<all_urls>\" 表示匹配所有地址\n\t\t\t\"matches\": [\"<all_urls>\"],\n\t\t\t// 多个JS按顺序注入\n\t\t\t\"js\": [\"js/jquery-1.8.3.js\", \"js/content-script.js\"],\n\t\t\t// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式\n\t\t\t\"css\": [\"css/custom.css\"],\n\t\t\t// 代码注入的时间，可选值： \"document_start\", \"document_end\", or \"document_idle\"，最后一个表示页面空闲时，默认document_idle\n\t\t\t\"run_at\": \"document_start\"\n\t\t}\n\t],\n}\n```\n\n特别注意，如果没有主动指定`run_at`为`document_start`（默认为`document_idle`），下面这种代码是不会生效的：\n\n```javascript\ndocument.addEventListener('DOMContentLoaded', function()\n{\n\tconsole.log('我被执行了！');\n});\n```\n\n`content-scripts`和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过`injected js`来实现。`content-scripts`不能访问绝大部分`chrome.xxx.api`，除了下面这4种：\n\n* chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)\n* chrome.i18n\n* chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)\n* chrome.storage\n\n其实看到这里不要悲观，这些API绝大部分时候都够用了，非要调用其它API的话，你还可以通过通信来实现让background来帮你调用（关于通信，后文有详细介绍）。\n\n好了，Chrome插件给我们提供了这么强大的JS注入功能，剩下的就是发挥你的想象力去玩弄浏览器了。\n\n## background\n\n后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。\n\nbackground的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置`CORS`。\n\n> 经过测试，其实不止是background，所有的直接通过`chrome-extension://id/xx.html`这种方式打开的网页都可以无限制跨域。\n\n配置中，`background`可以通过`page`指定一张网页，也可以通过`scripts`直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页：\n\n```javascript\n{\n\t// 会一直常驻的后台JS或后台页面\n\t\"background\":\n\t{\n\t\t// 2种指定方式，如果指定JS，那么会自动生成一个背景页\n\t\t\"page\": \"background.html\"\n\t\t//\"scripts\": [\"js/background.js\"]\n\t},\n}\n```\n\n需要特别说明的是，虽然你可以通过`chrome-extension://xxx/background.html`直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个`background.html`，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。\n\n## event-pages\n\n这里顺带介绍一下[event-pages](https://developer.chrome.com/extensions/event_pages)，它是一个什么东西呢？鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个`event-pages`，在配置文件上，它与background的唯一区别就是多了一个`persistent`参数：\n\n```javascript\n{\n\t\"background\":\n\t{\n\t\t\"scripts\": [\"event-page.js\"],\n\t\t\"persistent\": false\n\t},\n}\n```\n\n它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。\n\n除了配置文件的变化，代码上也有一些细微变化，个人这个简单了解一下就行了，一般情况下background也不会很消耗性能的。\n\n## popup\n\n`popup`是点击`browser_action`或者`page_action`图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。\n\n![博客园网摘插件popup效果](http://image.liuxianan.com/201706/20170619_161102_335_9254.png)\n\n`popup`可以包含任意你想要的HTML内容，并且会自适应大小。可以通过`default_popup`字段来指定popup页面，也可以调用`setPopup()`方法。\n\n配置方式：\n\n```javascript\n{\n\t\"browser_action\":\n\t{\n\t\t\"default_icon\": \"img/icon.png\",\n\t\t// 图标悬停时的标题，可选\n\t\t\"default_title\": \"这是一个示例Chrome插件\",\n\t\t\"default_popup\": \"popup.html\"\n\t}\n}\n```\n\n![](http://image.liuxianan.com/201705/20170531_172243_007_2793.png)\n\n需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。\n\n在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过`chrome.extension.getBackgroundPage()`获取background的window对象。\n\n## injected-script\n\n这里的`injected-script`是我给它取的，指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？\n\n这是因为`content-script`有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用`content-script`中的代码（包括直接写`onclick`和`addEventListener`2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。\n\n在`content-script`中通过DOM方式向页面注入`inject-script`代码示例：\n\n```javascript\n// 向页面注入JS\nfunction injectCustomJs(jsPath)\n{\n\tjsPath = jsPath || 'js/inject.js';\n\tvar temp = document.createElement('script');\n\ttemp.setAttribute('type', 'text/javascript');\n\t// 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js\n\ttemp.src = chrome.extension.getURL(jsPath);\n\ttemp.onload = function()\n\t{\n\t\t// 放在页面不好看，执行完后移除掉\n\t\tthis.parentNode.removeChild(this);\n\t};\n\tdocument.head.appendChild(temp);\n}\n```\n\n你以为这样就行了？执行一下你会看到如下报错：\n\n\tDenying load of chrome-extension://efbllncjkjiijkppagepehoekjojdclc/js/inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.\n\n意思就是你想要在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下：\n\n```javascript\n{\n\t// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的\n\t\"web_accessible_resources\": [\"js/inject.js\"],\n}\n```\n\n至于`inject-script`如何调用`content-script`中的代码，后面我会在专门的一个消息通信章节详细介绍。\n\n## homepage_url\n\n开发者或者插件主页设置，一般会在如下2个地方显示：\n\n![](http://image.liuxianan.com/201705/20170531_105821_586_0442.png)\n\n![](http://image.liuxianan.com/201705/20170531_105907_256_9087.png)\n\n# Chrome插件的8种展示形式\n\n## browserAction(浏览器右上角)\n\n通过配置`browser_action`可以在浏览器的右上角增加一个图标，一个`browser_action`可以拥有一个图标，一个`tooltip`，一个`badge`和一个`popup`。\n\n示例配置如下：\n\n```json\n\"browser_action\":\n{\n\t\"default_icon\": \"img/icon.png\",\n\t\"default_title\": \"这是一个示例Chrome插件\",\n\t\"default_popup\": \"popup.html\"\n}\n```\n\n### 图标\n\n`browser_action`图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中`default_icon`字段配置，也可以调用setIcon()方法。\n\n### tooltip\n\n修改`browser_action`的manifest中`default_title`字段，或者调用`setTitle()`方法。\n\n![](http://image.liuxianan.com/201705/20170531_170829_477_1329.png)\n\n### badge\n\n所谓`badge`就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用`setBadgeText()`和`setBadgeBackgroundColor()`。\n\n```javascript\nchrome.browserAction.setBadgeText({text: 'new'});\nchrome.browserAction.setBadgeBackgroundColor({color: [255, 0, 0, 255]});\n```\n\n效果：\n\n![](http://image.liuxianan.com/201705/20170531_171447_912_1165.png)\n\n## pageAction(地址栏右侧)\n\n所谓`pageAction`，指的是只有当某些特定页面打开才显示的图标，它和`browserAction`最大的区别是一个始终都显示，一个只在特定情况才显示。\n\n需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单：\n\n![](http://image.liuxianan.com/201705/20170531_103311_849_4399.png)\n\n而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项：\n\n![](http://image.liuxianan.com/201705/20170531_104038_208_9352.gif)\n\n> 具体是从哪一版本开始改的没去仔细考究，反正知道v50.0的时候还是前者，v58.0的时候已改为后者。\n\n调整之后的`pageAction`我们可以简单地把它看成是可以置灰的`browserAction`。\n\n* chrome.pageAction.show(tabId) 显示图标；\n* chrome.pageAction.hide(tabId) 隐藏图标；\n\n示例(只有打开百度才显示图标)：\n\n```javascript\n// manifest.json\n{\n\t\"page_action\":\n\t{\n\t\t\"default_icon\": \"img/icon.png\",\n\t\t\"default_title\": \"我是pageAction\",\n\t\t\"default_popup\": \"popup.html\"\n\t},\n\t\"permissions\": [\"declarativeContent\"]\n}\n\n// background.js\nchrome.runtime.onInstalled.addListener(function(){\n\tchrome.declarativeContent.onPageChanged.removeRules(undefined, function(){\n\t\tchrome.declarativeContent.onPageChanged.addRules([\n\t\t\t{\n\t\t\t\tconditions: [\n\t\t\t\t\t// 只有打开百度才显示pageAction\n\t\t\t\t\tnew chrome.declarativeContent.PageStateMatcher({pageUrl: {urlContains: 'baidu.com'}})\n\t\t\t\t],\n\t\t\t\tactions: [new chrome.declarativeContent.ShowPageAction()]\n\t\t\t}\n\t\t]);\n\t});\n});\n```\n\n效果图：\n\n![](http://image.liuxianan.com/201705/20170531_174018_541_0451.gif)\n\n## 右键菜单\n\n通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过`chrome.contextMenus`API实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里，如下：\n\n![](http://image.liuxianan.com/201705/20170531_151134_967_0243.png)\n\n### 最简单的右键菜单示例\n\n```javascript\n// manifest.json\n{\"permissions\": [\"contextMenus\"]}\n\n// background.js\nchrome.contextMenus.create({\n\ttitle: \"测试右键菜单\",\n\tonclick: function(){alert('您点击了右键菜单！');}\n});\n```\n\n效果：\n\n![](http://image.liuxianan.com/201705/20170531_145957_183_0527.png)\n\n### 添加右键百度搜索\n\n```javascript\n// manifest.json\n{\"permissions\": [\"contextMenus\"， \"tabs\"]}\n\n// background.js\nchrome.contextMenus.create({\n\ttitle: '使用度娘搜索：%s', // %s表示选中的文字\n\tcontexts: ['selection'], // 只有当选中文字时才会出现此右键菜单\n\tonclick: function(params)\n\t{\n\t\t// 注意不能使用location.href，因为location是属于background的window对象\n\t\tchrome.tabs.create({url: 'https://www.baidu.com/s?ie=utf-8&wd=' + encodeURI(params.selectionText)});\n\t}\n});\n```\n\n效果如下：\n\n![](http://image.liuxianan.com/201705/20170531_160358_202_7248.png)\n\n### 语法说明\n\n这里只是简单列举一些常用的，完整API参见：https://developer.chrome.com/extensions/contextMenus\n\n```javascript\nchrome.contextMenus.create({\n\ttype: 'normal'， // 类型，可选：[\"normal\", \"checkbox\", \"radio\", \"separator\"]，默认 normal\n\ttitle: '菜单的名字', // 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本\n\tcontexts: ['page'], // 上下文环境，可选：[\"all\", \"page\", \"frame\", \"selection\", \"link\", \"editable\", \"image\", \"video\", \"audio\"]，默认page\n\tonclick: function(){}, // 单击时触发的方法\n\tparentId: 1, // 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单\n\tdocumentUrlPatterns: 'https://*.baidu.com/*' // 只在某些页面显示此右键菜单\n});\n// 删除某一个菜单项\nchrome.contextMenus.remove(menuItemId)；\n// 删除所有自定义右键菜单\nchrome.contextMenus.removeAll();\n// 更新某一个菜单项\nchrome.contextMenus.update(menuItemId, updateProperties);\n```\n\n## override(覆盖特定页面)\n\n使用`override`页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。\n\n扩展可以替代如下页面：\n\n* 历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 [chrome://history](chrome://history)\n* 新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 [chrome://newtab](chrome://newtab)\n* 书签：浏览器的书签，或者直接输入 [chrome://bookmarks](chrome://bookmarks)\n\n注意：\n\n* 一个扩展只能替代一个页面；\n* 不能替代隐身窗口的新标签页；\n* 网页必须设置title，否则用户可能会看到网页的URL，造成困扰；\n\n下面的截图是默认的新标签页和被扩展替换掉的新标签页。\n\n![](http://image.liuxianan.com/201705/20170531_180326_487_3396.png)\n\n代码（注意，一个插件只能替代一个默认页，以下仅为演示）：\n\n```javascript\n\"chrome_url_overrides\":\n{\n\t\"newtab\": \"newtab.html\",\n\t\"history\": \"history.html\",\n\t\"bookmarks\": \"bookmarks.html\"\n}\n```\n\n## devtools(开发者工具)\n\n### 预热\n\n使用过vue的应该见过这种类型的插件：\n\n![](http://image.liuxianan.com/201706/20170605_181456_375_7033.png)\n\n是的，Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在：\n\n* 自定义一个和多个和`Elements`、`Console`、`Sources`等同级别的面板；\n* 自定义侧边栏(sidebar)，目前只能自定义`Elements`面板的侧边栏；\n\n先来看2张简单的demo截图，自定义面板（判断当前页面是否使用了jQuery）：\n\n![](http://image.liuxianan.com/201706/20170613_220126_669_2411.png)\n\n自定义侧边栏（获取当前页面所有图片）：\n\n![](http://image.liuxianan.com/201706/20170605_175952_228_8829.png)\n\n### devtools扩展介绍\n\n主页：https://developer.chrome.com/extensions/devtools\n\n来一张官方图片：\n\n![](http://image.liuxianan.com/201706/20170606_170623_349_6923.png)\n\n每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的`DevTools API`以及有限的扩展API，这组特有的`DevTools API`只有devtools页面才可以访问，background都无权访问，这些API包括：\n\n* `chrome.devtools.panels`：面板相关；\n* `chrome.devtools.inspectedWindow`：获取被审查窗口的有关信息；\n* `chrome.devtools.network`：获取有关网络请求的信息；\n\n大部分扩展API都无法直接被`DevTools`页面调用，但它可以像`content-script`一样直接调用`chrome.extension`和`chrome.runtime`API，同时它也可以像`content-script`一样使用Message交互的方式与background页面进行通信。\n\n### 实例：创建一个devtools扩展\n\n首先，要针对开发者工具开发插件，需要在清单文件声明如下：\n\n```javascript\n{\n\t// 只能指向一个HTML文件，不能是JS文件\n\t\"devtools_page\": \"devtools.html\"\n}\n```\n\n这个`devtools.html`里面一般什么都没有，就引入一个js：\n\n```html\n<!DOCTYPE html>\n<html>\n<head></head>\n<body>\n\t<script type=\"text/javascript\" src=\"js/devtools.js\"></script>\n</body>\n</html>\n```\n\n可以看出来，其实真正代码是`devtools.js`，html文件是“多余”的，所以这里觉得有点坑，`devtools_page`干嘛不允许直接指定JS呢？\n\n再来看devtools.js的代码：\n\n```javascript\n// 创建自定义面板，同一个插件可以创建多个自定义面板\n// 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调\nchrome.devtools.panels.create('MyPanel', 'img/icon.png', 'mypanel.html', function(panel)\n{\n\tconsole.log('自定义面板创建成功！'); // 注意这个log一般看不到\n});\n\n// 创建自定义侧边栏\nchrome.devtools.panels.elements.createSidebarPane(\"Images\", function(sidebar)\n{\n\t// sidebar.setPage('../sidebar.html'); // 指定加载某个页面\n\tsidebar.setExpression('document.querySelectorAll(\"img\")', 'All Images'); // 通过表达式来指定\n\t//sidebar.setObject({aaa: 111, bbb: 'Hello World!'}); // 直接设置显示某个对象\n});\n```\n\nsetPage时的效果：\n\n![](http://image.liuxianan.com/201706/20170613_194023_184_1728.png)\n\n以下截图示例的代码：\n\n![](http://image.liuxianan.com/201706/20170613_220345_133_1766.png)\n\n```javascript\n// 检测jQuery\ndocument.getElementById('check_jquery').addEventListener('click', function()\n{\n\t// 访问被检查的页面DOM需要使用inspectedWindow\n\t// 简单例子：检测被检查页面是否使用了jQuery\n\tchrome.devtools.inspectedWindow.eval(\"jQuery.fn.jquery\", function(result, isException)\n\t{\n\t\tvar html = '';\n\t\tif (isException) html = '当前页面没有使用jQuery。';\n\t\telse html = '当前页面使用了jQuery，版本为：'+result;\n\t\talert(html);\n\t});\n});\n\n// 打开某个资源\ndocument.getElementById('open_resource').addEventListener('click', function()\n{\n\tchrome.devtools.inspectedWindow.eval(\"window.location.href\", function(result, isException)\n\t{\n\t\tchrome.devtools.panels.openResource(result, 20, function()\n\t\t{\n\t\t\tconsole.log('资源打开成功！');\n\t\t});\n\t});\n});\n\n// 审查元素\ndocument.getElementById('test_inspect').addEventListener('click', function()\n{\n\tchrome.devtools.inspectedWindow.eval(\"inspect(document.images[0])\", function(result, isException){});\n});\n\n// 获取所有资源\ndocument.getElementById('get_all_resources').addEventListener('click', function()\n{\n\tchrome.devtools.inspectedWindow.getResources(function(resources)\n\t{\n\t\talert(JSON.stringify(resources));\n\t});\n});\n```\n\n### 调试技巧\n\n修改了devtools页面的代码时，需要先在 chrome://extensions 页面按下`Ctrl+R`重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。\n\n由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 `chrome-extension://extid/devtools.html\"`的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。\n\n## option(选项页)\n\n所谓`options`页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面：\n\n![](http://image.liuxianan.com/201706/20170621_170046_846_5529.png)\n\n![](http://image.liuxianan.com/201706/20170621_115902_196_9130.png)\n\n在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。\n\n我们先看老版的[options](https://developer.chrome.com/extensions/options)：\n\n```javascript\n{\n\t// Chrome40以前的插件配置页写法\n\t\"options_page\": \"options.html\",\n}\n```\n\n这个页面里面的内容就随你自己发挥了，配置之后在插件管理页就会看到一个`选项`按钮入口，点进去就是打开一个网页，没啥好讲的。\n\n效果:\n\n![](http://image.liuxianan.com/201706/20170621_115705_433_5886.png)\n\n再来看新版的[optionsV2](https://developer.chrome.com/extensions/optionsV2)：\n\n```javascript\n{\n\t\"options_ui\":\n\t{\n    \t\"page\": \"options.html\",\n\t\t// 添加一些默认的样式，推荐使用\n    \t\"chrome_style\": true\n\t},\n}\n```\n\n`options.html`的代码我们没有任何改动，只是配置文件改了，之后效果如下：\n\n![](http://image.liuxianan.com/201706/20170621_115809_750_1163.png)\n\n看起来是不是高大上了？\n\n几点注意：\n\n* 为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式；\n* 新版options中不能使用alert；\n* 数据存储建议用chrome.storage，因为会随用户自动同步；\n\n## omnibox\n\n`omnibox`是向用户提供搜索建议的一种方式。先来看个`gif`图以便了解一下这东西到底是个什么鬼：\n\n![](http://image.liuxianan.com/201706/20170621_155455_980_5359.gif)\n\n注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。\n\n首先，配置文件如下：\n\n```javascript\n{\n\t// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字\n\t\"omnibox\": { \"keyword\" : \"go\" },\n}\n```\n\n然后`background.js`中注册监听事件：\n\n```javascript\n// omnibox 演示\nchrome.omnibox.onInputChanged.addListener((text, suggest) => {\n\tconsole.log('inputChanged: ' + text);\n\tif(!text) return;\n\tif(text == '美女') {\n\t\tsuggest([\n\t\t\t{content: '中国' + text, description: '你要找“中国美女”吗？'},\n\t\t\t{content: '日本' + text, description: '你要找“日本美女”吗？'},\n\t\t\t{content: '泰国' + text, description: '你要找“泰国美女或人妖”吗？'},\n\t\t\t{content: '韩国' + text, description: '你要找“韩国美女”吗？'}\n\t\t]);\n\t}\n\telse if(text == '微博') {\n\t\tsuggest([\n\t\t\t{content: '新浪' + text, description: '新浪' + text},\n\t\t\t{content: '腾讯' + text, description: '腾讯' + text},\n\t\t\t{content: '搜狐' + text, description: '搜索' + text},\n\t\t]);\n\t}\n\telse {\n\t\tsuggest([\n\t\t\t{content: '百度搜索 ' + text, description: '百度搜索 ' + text},\n\t\t\t{content: '谷歌搜索 ' + text, description: '谷歌搜索 ' + text},\n\t\t]);\n\t}\n});\n\n// 当用户接收关键字建议时触发\nchrome.omnibox.onInputEntered.addListener((text) => {\n    console.log('inputEntered: ' + text);\n\tif(!text) return;\n\tvar href = '';\n    if(text.endsWith('美女')) href = 'http://image.baidu.com/search/index?tn=baiduimage&ie=utf-8&word=' + text;\n\telse if(text.startsWith('百度搜索')) href = 'https://www.baidu.com/s?ie=UTF-8&wd=' + text.replace('百度搜索 ', '');\n\telse if(text.startsWith('谷歌搜索')) href = 'https://www.google.com.tw/search?q=' + text.replace('谷歌搜索 ', '');\n\telse href = 'https://www.baidu.com/s?ie=UTF-8&wd=' + text;\n\topenUrlCurrentTab(href);\n});\n// 获取当前选项卡ID\nfunction getCurrentTabId(callback)\n{\n\tchrome.tabs.query({active: true, currentWindow: true}, function(tabs)\n\t{\n\t\tif(callback) callback(tabs.length ? tabs[0].id: null);\n\t});\n}\n\n// 当前标签打开某个链接\nfunction openUrlCurrentTab(url)\n{\n\tgetCurrentTabId(tabId => {\n\t\tchrome.tabs.update(tabId, {url: url});\n\t})\n}\n```\n\n\n## 桌面通知\n\nChrome提供了一个`chrome.notifications`API以便插件推送桌面通知，暂未找到`chrome.notifications`和HTML5自带的`Notification`的显著区别及优势。\n\n在后台JS中，无论是使用`chrome.notifications`还是`Notification`都不需要申请权限（HTML5方式需要申请权限），直接使用即可。\n\n最简单的通知：\n\n![](http://image.liuxianan.com/201705/20170531_193633_369_0274.png)\n\n代码：\n\n```javascript\nchrome.notifications.create(null, {\n\ttype: 'basic',\n\ticonUrl: 'img/icon.png',\n\ttitle: '这是标题',\n\tmessage: '您刚才点击了自定义右键菜单！'\n});\n```\n\n通知的样式可以很丰富：\n\n![](http://image.liuxianan.com/201705/20170531_193836_583_4450.png)\n\n这个没有深入研究，有需要的可以去看官方文档。\n\n# 5种类型的JS对比\n\nChrome插件的JS主要可以分为这5类：`injected script`、`content-script`、`popup js`、`background js`和`devtools js`，\n\n## 权限对比\n\n| JS种类  | 可访问的API  | DOM访问情况 | JS访问情况 | 直接跨域 |\n| ------------ | ------------ | -------- | --------- | -------- |\n| injected script  | 和普通JS无任何差别，不能访问任何扩展API  | 可以访问 | 可以访问 | 不可以 |\n| content script  | 只能访问 extension、runtime等部分API  | 可以访问 | 不可以 | 不可以 |\n| popup js | 可访问绝大部分API，除了devtools系列  | 不可直接访问 | 不可以 | 可以 |\n| background js | 可访问绝大部分API，除了devtools系列  | 不可直接访问 | 不可以 | 可以 |\n| devtools js | 只能访问 devtools、extension、runtime等部分API  | 可以 | 可以 | 不可以 |\n\n## 调试方式对比\n\n| JS类型 | 调试方式 | 图片说明 |\n| ------------ | ------------ | ------ |\n| injected script | 直接普通的F12即可  | 懒得截图 |\n| content-script | 打开Console,如图切换 | ![](http://image.liuxianan.com/201612/20161220_105526_629_8533.png) |\n| popup-js | popup页面右键审查元素 | ![](http://image.liuxianan.com/201612/20161220_105716_178_6900.png) |\n| background |  插件管理页点击背景页即可 | ![](http://image.liuxianan.com/201612/20161220_105811_922_5621.png) |\n| devtools-js | 暂未找到有效方法 | - |\n\n\n# 消息通信\n\n通信主页：https://developer.chrome.com/extensions/messaging\n\n前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。\n\n## 互相通信概览\n\n注：`-`表示不存在或者无意义，或者待验证。\n\n|   | injected-script | content-script  | popup-js  | background-js  |\n| ------------ | ------------ | ------------ | ------------ | ------------ |\n| injected-script | - | window.postMessage | - | - |\n| content-script  | window.postMessage | -  | chrome.runtime.sendMessage chrome.runtime.connect  | chrome.runtime.sendMessage chrome.runtime.connect  |\n| popup-js  | - | chrome.tabs.sendMessage chrome.tabs.connect | - | chrome.extension. getBackgroundPage()  |\n| background-js  | - | chrome.tabs.sendMessage chrome.tabs.connect | chrome.extension.getViews | - |\n| devtools-js  | chrome.devtools. inspectedWindow.eval | - | chrome.runtime.sendMessage  | chrome.runtime.sendMessage  |\n\n## 通信详细介绍\n\n### popup和background\n\npopup可以直接调用background中的JS方法，也可以直接访问background的DOM：\n\n```javascript\n// background.js\nfunction test()\n{\n\talert('我是background！');\n}\n\n// popup.js\nvar bg = chrome.extension.getBackgroundPage();\nbg.test(); // 访问bg的函数\nalert(bg.document.body.innerHTML); // 访问bg的DOM\n```\n\n> 小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。\n\n至于`background`访问`popup`如下（前提是`popup`已经打开）：\n\n```javascript\nvar views = chrome.extension.getViews({type:'popup'});\nif(views.length > 0) {\n\tconsole.log(views[0].location.href);\n}\n```\n\n### popup或者bg向content主动发送消息\n\nbackground.js或者popup.js：\n\n```javascript\nfunction sendMessageToContentScript(message, callback)\n{\n\tchrome.tabs.query({active: true, currentWindow: true}, function(tabs)\n\t{\n\t\tchrome.tabs.sendMessage(tabs[0].id, message, function(response)\n\t\t{\n\t\t\tif(callback) callback(response);\n\t\t});\n\t});\n}\nsendMessageToContentScript({cmd:'test', value:'你好，我是popup！'}, function(response)\n{\n\tconsole.log('来自content的回复：'+response);\n});\n```\n\n`content-script.js`接收：\n\n```javascript\nchrome.runtime.onMessage.addListener(function(request, sender, sendResponse)\n{\n\t// console.log(sender.tab ?\"from a content script:\" + sender.tab.url :\"from the extension\");\n\tif(request.cmd == 'test') alert(request.value);\n\tsendResponse('我收到了你的消息！');\n});\n```\n\n双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。\n\n> 网上有些老代码中用的是`chrome.extension.onMessage`，没有完全查清二者的区别(貌似是别名)，但是建议统一使用`chrome.runtime.onMessage`。\n\n### content-script主动发消息给后台\n\ncontent-script.js：\n\n```javascript\nchrome.runtime.sendMessage({greeting: '你好，我是content-script呀，我主动发消息给后台！'}, function(response) {\n\tconsole.log('收到来自后台的回复：' + response);\n});\n```\n\nbackground.js 或者 popup.js：\n\n```javascript\n// 监听来自content-script的消息\nchrome.runtime.onMessage.addListener(function(request, sender, sendResponse)\n{\n\tconsole.log('收到来自content-script的消息：');\n\tconsole.log(request, sender, sendResponse);\n\tsendResponse('我是后台，我已收到你的消息：' + JSON.stringify(request));\n});\n```\n\n注意事项：\n\n* content_scripts向`popup`主动发消息的前提是popup必须打开！否则需要利用background作中转；\n* 如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效；\n\n### injected script和content-script\n\n`content-script`和页面内的脚本（`injected-script`自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯：\n\n1. 可以通过`window.postMessage`和`window.addEventListener`来实现二者消息通讯；\n2. 通过自定义DOM事件来实现；\n\n第一种方法（推荐）：\n\n`injected-script`中：\n\n```javascript\nwindow.postMessage({\"test\": '你好！'}, '*');\n```\n\ncontent script中：\n\n```javascript\nwindow.addEventListener(\"message\", function(e)\n{\n\tconsole.log(e.data);\n}, false);\n```\n\n第二种方法：\n\n`injected-script`中：\n\n```javascript\nvar customEvent = document.createEvent('Event');\ncustomEvent.initEvent('myCustomEvent', true, true);\nfunction fireCustomEvent(data) {\n\thiddenDiv = document.getElementById('myCustomEventDiv');\n\thiddenDiv.innerText = data\n\thiddenDiv.dispatchEvent(customEvent);\n}\nfireCustomEvent('你好，我是普通JS！');\n```\n\n`content-script.js`中：\n\n```javascript\nvar hiddenDiv = document.getElementById('myCustomEventDiv');\nif(!hiddenDiv) {\n\thiddenDiv = document.createElement('div');\n\thiddenDiv.style.display = 'none';\n\tdocument.body.appendChild(hiddenDiv);\n}\nhiddenDiv.addEventListener('myCustomEvent', function() {\n\tvar eventData = document.getElementById('myCustomEventDiv').innerText;\n\tconsole.log('收到自定义事件消息：' + eventData);\n});\n```\n\n## 长连接和短连接\n\n其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（`chrome.tabs.sendMessage`和`chrome.runtime.sendMessage`），一个是长连接（`chrome.tabs.connect`和`chrome.runtime.connect`）。\n\n短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似`WebSocket`会一直建立连接，双方可以随时互发消息。\n\n短连接上面已经有代码示例了，这里只讲一下长连接。\n\npopup.js：\n\n```javascript\ngetCurrentTabId((tabId) => {\n\tvar port = chrome.tabs.connect(tabId, {name: 'test-connect'});\n\tport.postMessage({question: '你是谁啊？'});\n\tport.onMessage.addListener(function(msg) {\n\t\talert('收到消息：'+msg.answer);\n\t\tif(msg.answer && msg.answer.startsWith('我是'))\n\t\t{\n\t\t\tport.postMessage({question: '哦，原来是你啊！'});\n\t\t}\n\t});\n});\n```\n\ncontent-script.js：\n\n```javascript\n// 监听长连接\nchrome.runtime.onConnect.addListener(function(port) {\n\tconsole.log(port);\n\tif(port.name == 'test-connect') {\n\t\tport.onMessage.addListener(function(msg) {\n\t\t\tconsole.log('收到长连接消息：', msg);\n\t\t\tif(msg.question == '你是谁啊？') port.postMessage({answer: '我是你爸！'});\n\t\t});\n\t}\n});\n```\n\n# 其它补充\n\n## 动态注入或执行JS\n\n虽然在`background`和`popup`中无法直接访问页面DOM，但是可以通过`chrome.tabs.executeScript`来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。\n\n示例`manifest.json`配置：\n\n```javascript\n{\n\t\"name\": \"动态JS注入演示\",\n\t...\n\t\"permissions\": [\n\t\t\"tabs\", \"http://*/*\", \"https://*/*\"\n\t],\n\t...\n}\n```\n\nJS：\n\n```javascript\n// 动态执行JS代码\nchrome.tabs.executeScript(tabId, {code: 'document.body.style.backgroundColor=\"red\"'});\n// 动态执行JS文件\nchrome.tabs.executeScript(tabId, {file: 'some-script.js'});\n```\n\n## 动态注入CSS\n\n示例`manifest.json`配置：\n\n```javascript\n{\n\t\"name\": \"动态CSS注入演示\",\n\t...\n\t\"permissions\": [\n\t\t\"tabs\", \"http://*/*\", \"https://*/*\"\n\t],\n\t...\n}\n```\n\nJS代码：\n\n```javascript\n// 动态执行CSS代码，TODO，这里有待验证\nchrome.tabs.insertCSS(tabId, {code: 'xxx'});\n// 动态执行CSS文件\nchrome.tabs.insertCSS(tabId, {file: 'some-style.css'});\n```\n\n\n## 获取当前窗口ID\n\n```javascript\nchrome.windows.getCurrent(function(currentWindow)\n{\n\tconsole.log('当前窗口ID：' + currentWindow.id);\n});\n```\n\n## 获取当前标签页ID\n\n一般有2种方法：\n\n```javascript\n// 获取当前选项卡ID\nfunction getCurrentTabId(callback)\n{\n\tchrome.tabs.query({active: true, currentWindow: true}, function(tabs)\n\t{\n\t\tif(callback) callback(tabs.length ? tabs[0].id: null);\n\t});\n}\n```\n\n获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时）\n```javascript\n// 获取当前选项卡ID\nfunction getCurrentTabId2()\n{\n\tchrome.windows.getCurrent(function(currentWindow)\n\t{\n\t\tchrome.tabs.query({active: true, windowId: currentWindow.id}, function(tabs)\n\t\t{\n\t\t\tif(callback) callback(tabs.length ? tabs[0].id: null);\n\t\t});\n\t});\n}\n```\n\n## 本地存储\n\n本地存储建议用`chrome.storage`而不是普通的`localStorage`，区别有好几点，个人认为最重要的2点区别是：\n\n* `chrome.storage`是针对插件全局的，即使你在`background`中保存的数据，在`content-script`也能获取到；\n* `chrome.storage.sync`可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；\n\n需要声明`storage`权限，有`chrome.storage.sync`和`chrome.storage.local`2种方式可供选择，使用示例如下：\n\n```javascript\n// 读取数据，第一个参数是指定要读取的key以及设置默认值\nchrome.storage.sync.get({color: 'red', age: 18}, function(items) {\n\tconsole.log(items.color, items.age);\n});\n// 保存数据\nchrome.storage.sync.set({color: 'blue'}, function() {\n\tconsole.log('保存成功！');\n});\n```\n\n## webRequest\n\n通过webRequest系列API可以对HTTP请求进行任性地修改、定制，这里通过`beforeRequest`来简单演示一下它的冰山一角：\n\n```javascript\n//manifest.json\n{\n\t// 权限申请\n\t\"permissions\":\n\t[\n\t\t\"webRequest\", // web请求\n\t\t\"webRequestBlocking\", // 阻塞式web请求\n\t\t\"storage\", // 插件本地存储\n\t\t\"http://*/*\", // 可以通过executeScript或者insertCSS访问的网站\n\t\t\"https://*/*\" // 可以通过executeScript或者insertCSS访问的网站\n\t],\n}\n\n\n// background.js\n// 是否显示图片\nvar showImage;\nchrome.storage.sync.get({showImage: true}, function(items) {\n\tshowImage = items.showImage;\n});\n// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlocking\nchrome.webRequest.onBeforeRequest.addListener(details => {\n\t// cancel 表示取消本次请求\n\tif(!showImage && details.type == 'image') return {cancel: true};\n\t// 简单的音视频检测\n\t// 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义\n\tif(details.type == 'media') {\n\t\tchrome.notifications.create(null, {\n\t\t\ttype: 'basic',\n\t\t\ticonUrl: 'img/icon.png',\n\t\t\ttitle: '检测到音视频',\n\t\t\tmessage: '音视频地址：' + details.url,\n\t\t});\n\t}\n}, {urls: [\"<all_urls>\"]}, [\"blocking\"]);\n```\n\n## 国际化\n\n插件根目录新建一个名为`_locales`的文件夹，再在下面新建一些语言的文件夹，如`en`、`zh_CN`、`zh_TW`，然后再在每个文件夹放入一个`messages.json`，同时必须在清单文件中设置`default_locale`。\n\n`_locales\\en\\messages.json`内容：\n\n```javascript\n{\n\t\"pluginDesc\": {\"message\": \"A simple chrome extension demo\"},\n\t\"helloWorld\": {\"message\": \"Hello World!\"}\n}\n```\n\n`_locales\\zh_CN\\messages.json`内容：\n\n```javascript\n{\n\t\"pluginDesc\": {\"message\": \"一个简单的Chrome插件demo\"},\n\t\"helloWorld\": {\"message\": \"你好啊，世界！\"}\n}\n```\n\n在`manifest.json`和`CSS`文件中通过`__MSG_messagename__`引入，如：\n\n```javascript\n{\n\t\"description\": \"__MSG_pluginDesc__\",\n\t// 默认语言\n\t\"default_locale\": \"zh_CN\",\n}\n```\n\nJS中则直接`chrome.i18n.getMessage(\"helloWorld\")`。\n\n测试时，通过给chrome建立一个不同的快捷方式`chrome.exe --lang=en`来切换语言，如：\n\n![](http://image.liuxianan.com/201706/20170621_180606_759_2394.png)\n\n英文效果：\n\n![](http://image.liuxianan.com/201706/20170621_175733_172_5903.png)\n\n中文效果：\n\n![](http://image.liuxianan.com/201706/20170621_175621_269_0466.png)\n\n## API总结\n\n比较常用用的一些API系列：\n\n* chrome.tabs\n* chrome.runtime\n* chrome.webRequest\n* chrome.window\n* chrome.storage\n* chrome.contextMenus\n* chrome.devtools\n* chrome.extension\n\n# 经验总结\n\n## 查看已安装插件路径\n\n已安装的插件源码路径：`C:\\Users\\用户名\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Extensions`，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，看人家的源码是最好的方法了：\n\n![](http://image.liuxianan.com/201706/20170601_100200_647_6507.png)\n\n如何查看某个插件的ID？进入 chrome://extensions ，然后勾线开发者模式即可看到了。\n\n![](http://image.liuxianan.com/201706/20170601_100408_338_3095.png)\n\n## 特别注意background的报错\n\n很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开background的控制台才发现原来某个地方写错了导致代码没生效，正式由于background报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。\n\n## 如何让popup页面不关闭\n\n在对popup页面审查元素的时候popup会被强制打开无法关闭，只有控制台关闭了才可以关闭popup，原因很简单：如果popup关闭了控制台就没用了。这种方法在某些情况下很实用！\n\n## 不支持内联JavaScript的执行\n\n也就是不支持将js直接写在html中，比如：\n\n```html\n<input id=\"btn\" type=\"button\" value=\"收藏\" onclick=\"test()\"/>\n```\n\n报错如下：\n\n\tRefused to execute inline event handler because it violates the following Content Security Policy directive: \"script-src 'self' blob: filesystem: chrome-extension-resource:\". Either the 'unsafe-inline' keyword, a hash ('sha256-...'), or a nonce ('nonce-...') is required to enable inline execution.\n\n解决方法就是用JS绑定事件：\n\n```javascript\n$('#btn').on('click', function(){alert('测试')});\n```\n\n另外，对于A标签，这样写`href=\"javascript:;\"`然后用JS绑定事件虽然控制台会报错，但是不受影响，当然强迫症患者受不了的话只能写成`href=\"#\"`了。\n\n如果这样写：\n\n\t<a href=\"javascript:;\" id=\"get_secret\">请求secret</a>\n\n报错如下：\n\n\tRefused to execute JavaScript URL because it violates the following Content Security Policy directive: \"script-src 'self' blob: filesystem: chrome-extension-resource:\". Either the 'unsafe-inline' keyword, a hash ('sha256-...'), or a nonce ('nonce-...') is required to enable inline execution.\n\n## 注入CSS的时候必须小心\n\n由于通过`content_scripts`注入的CSS优先级非常高，几乎仅次于浏览器默认样式，稍不注意可能就会影响一些网站的展示效果，所以尽量不要写一些影响全局的样式。\n\n之所以强调这个，是因为这个带来的问题非常隐蔽，不太容易找到，可能你正在写某个网页，昨天样式还是好好的，怎么今天就突然不行了？然后你辛辛苦苦找来找去，找了半天才发现竟然是因为插件里面的一个样式影响的！\n\n![](http://image.liuxianan.com/201706/20170620_175530_598_9800.png)\n\n\n# 打包与发布\n\n打包的话直接在插件管理页有一个打包按钮：\n\n![](http://image.liuxianan.com/201706/20170621_181130_362_3360.png)\n\n然后会生成一个`.crx`文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，本人太穷，就懒得亲自验证了，有发布需求的自己去整吧。\n\n![](http://image.liuxianan.com/201707/20170710_221653_875_3099.png)\n\n# 参考\n\n## 官方资料\n\n推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要翻墙）：\n\n* [Chrome插件官方文档主页](https://developer.chrome.com/extensions)\n* [Chrome插件官方示例](https://developer.chrome.com/extensions/samples)\n* [manifest清单文件](https://developer.chrome.com/extensions/manifest)\n* [permissions权限](https://developer.chrome.com/extensions/permissions)\n* [chrome.xxx.api文档](https://developer.chrome.com/extensions/api_index)\n* [模糊匹配规则语法详解](https://developer.chrome.com/extensions/match_patterns)\n\n## 第三方资料\n\n部分中文资料，不是特别推荐：\n\n* [360安全浏览器开发文档](http://open.se.360.cn/open/extension_dev/overview.html)\n* [360极速浏览器Chrome扩展开发文档](http://open.chrome.360.cn/extension_dev/overview.html)\n* [Chrome扩展开发极客系列博客](http://www.cnblogs.com/champagne/p/)\n\n## 附图\n\n附图：Chrome高清png格式logo：\n\n![](http://image.liuxianan.com/201706/20170619_113331_710_1132.png)\n"
        },
        {
          "name": "full-chrome-plugin-demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "page-action-demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "simple-chrome-plugin-demo",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}