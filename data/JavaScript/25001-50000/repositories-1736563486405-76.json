{
  "metadata": {
    "timestamp": 1736563486405,
    "page": 76,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lutzroeder/netron",
      "stars": 29050,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.087890625,
          "content": ".DS_Store\n.DS_Store?\ndist/*\nnode_modules/*\nthird_party/*\npackage-lock.json\nyarn.lock\n*.pyc"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0146484375,
          "content": "loglevel=silent"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.6943359375,
          "content": "# How to Develop Netron\n\n## Debugging\n\nNetron can run as both an [Electron](https://electronjs.org) app or a web app.\n\nTo start the Electron app, install [Node.js](https://nodejs.org) and run: \n\n```bash\nnpm install\nnpm start\n```\n\nTo debug the Electron app, open the folder in [Visual Studio Code](https://code.visualstudio.com) and press <kbd>F5</kbd>. To attach the debugger to the render process select the `Debug` tab and pick `Electron View` before launching.\n\nTo build and launch the web app, pick `Browser` in the `Debug` tab or run this command:\n\n```bash\npython package.py build start --browse\n```\n\n## Validation\n\nTo validate changes run:\n\n```bash\nnpm run lint\nnpm test [format] # e.g. npm test onnx\n```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "MIT License\n\nCopyright (c) Lutz Roeder\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.033203125,
          "content": "<div align=\"center\">\n<img width=\"400px\" height=\"100px\" src=\"https://github.com/lutzroeder/netron/raw/main/.github/logo-light.svg#gh-light-mode-only\">\n<img width=\"400px\" height=\"100px\" src=\"https://github.com/lutzroeder/netron/raw/main/.github/logo-dark.svg#gh-dark-mode-only\">\n</div>\n\nNetron is a viewer for neural network, deep learning and machine learning models.\n\nNetron supports ONNX, TensorFlow Lite, Core ML, Keras, Caffe, Darknet, PyTorch, TensorFlow.js, Safetensors and NumPy.\n\nNetron has experimental support for TorchScript, TensorFlow, MXNet, OpenVINO, RKNN, ML.NET, ncnn, MNN, PaddlePaddle, GGUF and scikit-learn.\n\n<p align='center'><a href='https://www.lutzroeder.com/ai'><img src='.github/screenshot.png' width='800'></a></p>\n\n## Install\n\n**macOS**: [**Download**](https://github.com/lutzroeder/netron/releases/latest) the `.dmg` file or run `brew install --cask netron`\n\n**Linux**: [**Download**](https://github.com/lutzroeder/netron/releases/latest) the `.AppImage` file or run `snap install netron`\n\n**Windows**: [**Download**](https://github.com/lutzroeder/netron/releases/latest) the `.exe` installer or run `winget install -s winget netron`\n\n**Browser**: [**Start**](https://netron.app) the browser version.\n\n**Python**: Run `pip install netron` and `netron [FILE]` or `netron.start('[FILE]')`.\n\n## Models\n\nSample model files to download or open using the browser version:\n\n * **ONNX**: [squeezenet](https://github.com/onnx/models/raw/main/validated/vision/classification/squeezenet/model/squeezenet1.0-3.onnx) [[open](https://netron.app?url=https://github.com/onnx/models/raw/main/validated/vision/classification/squeezenet/model/squeezenet1.0-3.onnx)]\n * **TensorFlow Lite**: [yamnet](https://huggingface.co/thelou1s/yamnet/resolve/main/lite-model_yamnet_tflite_1.tflite) [[open](https://netron.app?url=https://huggingface.co/thelou1s/yamnet/blob/main/lite-model_yamnet_tflite_1.tflite)]\n * **TensorFlow**: [chessbot](https://github.com/srom/chessbot/raw/master/model/chessbot.pb) [[open](https://netron.app?url=https://github.com/srom/chessbot/raw/master/model/chessbot.pb)]\n * **Keras**: [mobilenet](https://github.com/aio-libs/aiohttp-demos/raw/master/demos/imagetagger/tests/data/mobilenet.h5) [[open](https://netron.app?url=https://github.com/aio-libs/aiohttp-demos/raw/master/demos/imagetagger/tests/data/mobilenet.h5)]\n * **TorchScript**: [traced_online_pred_layer](https://github.com/ApolloAuto/apollo/raw/master/modules/prediction/data/traced_online_pred_layer.pt) [[open](https://netron.app?url=https://github.com/ApolloAuto/apollo/raw/master/modules/prediction/data/traced_online_pred_layer.pt)]\n * **Core ML**: [exermote](https://github.com/Lausbert/Exermote/raw/master/ExermoteInference/ExermoteCoreML/ExermoteCoreML/Model/Exermote.mlmodel) [[open](https://netron.app?url=https://github.com/Lausbert/Exermote/raw/master/ExermoteInference/ExermoteCoreML/ExermoteCoreML/Model/Exermote.mlmodel)]\n * **Darknet**: [yolo](https://github.com/AlexeyAB/darknet/raw/master/cfg/yolo.cfg) [[open](https://netron.app?url=https://github.com/AlexeyAB/darknet/raw/master/cfg/yolo.cfg)]\n"
        },
        {
          "name": "package.js",
          "type": "blob",
          "size": 25.30859375,
          "content": "\nimport * as child_process from 'child_process';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs/promises';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as url from 'url';\n\nconst args = process.argv.slice(2);\n\nconst read = (match) => {\n    if (args.length > 0 || (!match || args[0] === match)) {\n        return args.shift();\n    }\n    return null;\n};\n\nlet configuration = null;\n\nconst dirname = (...args) => {\n    const file = url.fileURLToPath(import.meta.url);\n    const dir = path.dirname(file);\n    return path.join(dir, ...args);\n};\n\nconst load = async () => {\n    const file = dirname('package.json');\n    const content = await fs.readFile(file, 'utf-8');\n    configuration = JSON.parse(content);\n};\n\nconst clearLine = () => {\n    if (process.stdout.clearLine) {\n        process.stdout.clearLine();\n    }\n};\n\nconst write = (message) => {\n    if (process.stdout.write) {\n        process.stdout.write(message);\n    }\n};\n\nconst writeLine = (message) => {\n    write(message + os.EOL);\n};\n\nconst access = async (path) => {\n    try {\n        await fs.access(path);\n        return true;\n    } catch {\n        return false;\n    }\n};\n\nconst rm = async (...args) => {\n    const dir = dirname(...args);\n    const exists = await access(dir);\n    if (exists) {\n        const paths = path.join(...args);\n        writeLine(`rm ${paths}`);\n        const options = { recursive: true, force: true };\n        await fs.rm(dir, options);\n    }\n};\n\nconst mkdir = async (...args) => {\n    const dir = dirname(...args);\n    const exists = await access(dir);\n    if (!exists) {\n        const paths = path.join(...args);\n        writeLine(`mkdir ${paths}`);\n        const options = { recursive: true };\n        await fs.mkdir(dir, options);\n    }\n    return dir;\n};\n\nconst copy = async (source, target, filter) => {\n    let files = await fs.readdir(source);\n    files = filter ? files.filter((file) => filter(file)) : files;\n    const promises = files.map((file) => fs.copyFile(path.join(source, file), path.join(target, file)));\n    await Promise.all(promises);\n};\n\nconst unlink = async (dir, filter) => {\n    let files = await fs.readdir(dir);\n    files = filter ? files.filter((file) => filter(file)) : files;\n    const promises = files.map((file) => fs.unlink(path.join(dir, file)));\n    await Promise.all(promises);\n};\n\nconst exec = async (command, encoding, cwd) => {\n    cwd = cwd || dirname();\n    if (encoding) {\n        return child_process.execSync(command, { cwd, encoding });\n    }\n    child_process.execSync(command, { cwd, stdio: [0,1,2] });\n    return '';\n    /*\n    return new Promise((resolve, reject) => {\n        const child = child_process.exec(command, { cwd: dirname() }, (error, stdout, stderr) => {\n            if (error) {\n                stderr = '\\n' + stderr ;\n                if (error.message && error.message.endsWith(stderr)) {\n                    error.message = error.message.slice(0, -stderr.length);\n                }\n                reject(error);\n            } else {\n                resolve(stdout);\n            }\n        });\n        child.stdout.pipe(process.stdout);\n        child.stderr.pipe(process.stderr);\n    });\n    */\n};\n\nconst sleep = (delay) => {\n    return new Promise((resolve) => {\n        setTimeout(resolve, delay);\n    });\n};\n\nconst request = async (url, init, status) => {\n    const response = await fetch(url, init);\n    if (status !== false && !response.ok) {\n        throw new Error(response.status.toString());\n    }\n    if (response.body) {\n        const reader = response.body.getReader();\n        let position = 0;\n        const stream = new ReadableStream({\n            start(controller) {\n                const read = async () => {\n                    try {\n                        const result = await reader.read();\n                        if (result.done) {\n                            clearLine();\n                            controller.close();\n                        } else {\n                            position += result.value.length;\n                            write(`  ${position} bytes\\r`);\n                            controller.enqueue(result.value);\n                            read();\n                        }\n                    } catch (error) {\n                        controller.error(error);\n                    }\n                };\n                read();\n            }\n        });\n        return new Response(stream, {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers\n        });\n    }\n    return response;\n};\n\nconst download = async (url) => {\n    writeLine(`download ${url}`);\n    const response = await request(url);\n    return response.arrayBuffer().then((buffer) => new Uint8Array(buffer));\n};\n\nconst hash = async (url, algorithm) => {\n    const data = await download(url);\n    const hash = crypto.createHash(algorithm);\n    hash.update(data);\n    return hash.digest('hex');\n};\n\nconst fork = async (organization, repository) => {\n    const headers = {\n        Authorization: `Bearer ${process.env.GITHUB_TOKEN}`\n    };\n    writeLine(`github delete ${repository}`);\n    await request(`https://api.github.com/repos/${process.env.GITHUB_USER}/${repository}`, {\n        method: 'DELETE',\n        headers\n    }, false);\n    await sleep(4000);\n    writeLine(`github fork ${repository}`);\n    await request(`https://api.github.com/repos/${organization}/${repository}/forks`, {\n        method: 'POST',\n        headers,\n        body: ''\n    });\n    await sleep(4000);\n    await rm('dist', repository);\n    writeLine(`github clone ${repository}`);\n    await exec(`git clone --depth=2 https://x-access-token:${process.env.GITHUB_TOKEN}@github.com/${process.env.GITHUB_USER}/${repository}.git dist/${repository}`);\n};\n\nconst pullrequest = async (organization, repository, body) => {\n    writeLine(`github push ${repository}`);\n    await exec(`git -C dist/${repository} push`);\n    writeLine(`github pullrequest ${repository}`);\n    const headers = {\n        Authorization: `Bearer ${process.env.GITHUB_TOKEN}`\n    };\n    await request(`https://api.github.com/repos/${organization}/${repository}/pulls`, {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(body)\n    });\n};\n\nconst clean = async () => {\n    await rm('dist');\n    await rm('node_modules');\n    await rm('package-lock.json');\n    await rm('yarn.lock');\n};\n\nconst install = async () => {\n    const node_modules = dirname('node_modules');\n    let exists = await access(node_modules);\n    if (exists) {\n        const dependencies = { ...configuration.dependencies, ...configuration.devDependencies };\n        const matches = await Promise.all(Object.entries(dependencies).map(async ([name, version]) => {\n            const file = path.join('node_modules', name, 'package.json');\n            const exists = await access(file);\n            if (exists) {\n                const content = await fs.readFile(file, 'utf8');\n                const obj = JSON.parse(content);\n                return obj.version === version;\n            }\n            return false;\n        }));\n        exists = matches.every((match) => match);\n        if (!exists) {\n            await clean();\n        }\n    }\n    exists = await access(node_modules);\n    if (!exists) {\n        await exec('npm install');\n    }\n    try {\n        await exec('python --version', 'utf-8');\n        await exec('python -m pip install --upgrade --quiet setuptools pylint');\n    } catch {\n        // continue regardless of error\n    }\n};\n\nconst start = async () => {\n    await install();\n    await exec('npx electron .');\n};\n\nconst purge = async () => {\n    await clean();\n    await rm('third_party', 'bin');\n    await rm('third_party', 'env');\n    await rm('third_party', 'source');\n};\n\nconst build = async (target) => {\n    switch (target || read()) {\n        case 'web': {\n            writeLine('build web');\n            await rm('dist', 'web');\n            await mkdir('dist', 'web');\n            writeLine('cp source/dir dist/dir');\n            const source_dir = dirname('source');\n            const dist_dir = dirname('dist', 'web');\n            const extensions = new Set(['html', 'css', 'js', 'json', 'ico', 'png']);\n            await copy(source_dir, dist_dir, (file) => extensions.has(file.split('.').pop()));\n            await rm('dist', 'web', 'app.js');\n            await rm('dist', 'web', 'electron.js');\n            const contentFile = dirname('dist', 'web', 'index.html');\n            let content = await fs.readFile(contentFile, 'utf-8');\n            content = content.replace(/(<meta\\s*name=\"version\"\\s*content=\")(.*)(\">)/m, (match, p1, p2, p3) => {\n                return p1 + configuration.version + p3;\n            });\n            content = content.replace(/(<meta\\s*name=\"date\"\\s*content=\")(.*)(\">)/m, (match, p1, p2, p3) => {\n                return p1 + configuration.date + p3;\n            });\n            await fs.writeFile(contentFile, content, 'utf-8');\n            break;\n        }\n        case 'electron': {\n            writeLine('build electron');\n            await install();\n            await exec('npx electron-builder install-app-deps');\n            await exec('npx electron-builder --mac --universal --publish never -c.mac.identity=null');\n            await exec('npx electron-builder --win --x64 --arm64 --publish never');\n            await exec('npx electron-builder --linux appimage --x64 --publish never');\n            await exec('npx electron-builder --linux snap --x64 --publish never');\n            break;\n        }\n        case 'python': {\n            writeLine('build python');\n            await exec('python package.py build version');\n            await exec('python -m pip install --user build wheel --quiet');\n            await exec('python -m build --wheel --outdir dist/pypi dist/pypi');\n            if (read('install')) {\n                await exec('python -m pip install --force-reinstall dist/pypi/*.whl');\n            }\n            break;\n        }\n        default: {\n            writeLine('build');\n            await rm('dist');\n            await install();\n            await build('web');\n            await build('electron');\n            await build('python');\n            break;\n        }\n    }\n};\n\nconst publish = async (target) => {\n    const GITHUB_TOKEN = process.env.GITHUB_TOKEN;\n    const GITHUB_USER = process.env.GITHUB_USER;\n    switch (target || read()) {\n        case 'web': {\n            writeLine('publish web');\n            await build('web');\n            await rm('dist', 'gh-pages');\n            const url = `https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_USER}/netron.git`;\n            await exec(`git clone --depth=1 ${url} --branch gh-pages ./dist/gh-pages 2>&1 > /dev/null`);\n            writeLine('cp dist/web dist/gh-pages');\n            const source_dir = dirname('dist', 'web');\n            const target_dir = dirname('dist', 'gh-pages');\n            await unlink(target_dir, (file) => file !== '.git');\n            await copy(source_dir, target_dir);\n            await exec('git -C dist/gh-pages add --all');\n            await exec('git -C dist/gh-pages commit --amend --no-edit');\n            await exec('git -C dist/gh-pages push --force origin gh-pages');\n            break;\n        }\n        case 'electron': {\n            writeLine('publish electron');\n            await install();\n            await exec('npx electron-builder install-app-deps');\n            await exec('npx electron-builder --mac --universal --publish always');\n            await exec('npx electron-builder --win --x64 --arm64 --publish always');\n            await exec('npx electron-builder --linux appimage --x64 --publish always');\n            await exec('npx electron-builder --linux snap --x64 --publish always');\n            break;\n        }\n        case 'python': {\n            writeLine('publish python');\n            await build('python');\n            await exec('python -m pip install --user twine');\n            await exec('python -m twine upload --non-interactive --skip-existing --verbose dist/pypi/*.whl');\n            break;\n        }\n        case 'cask': {\n            writeLine('publish cask');\n            await fork('Homebrew', 'homebrew-cask');\n            const repository = `https://github.com/${configuration.repository}`;\n            const url = `${repository}/releases/download/v#{version}/${configuration.productName}-#{version}-mac.zip`;\n            const sha256 = await hash(url.replace(/#{version}/g, configuration.version), 'sha256');\n            writeLine('update manifest');\n            const dir = await mkdir('dist', 'homebrew-cask', 'Casks', 'n');\n            const file = path.join(dir, 'netron.rb');\n            await fs.writeFile(file, [\n                `cask \"${configuration.name}\" do`,\n                `  version \"${configuration.version}\"`,\n                `  sha256 \"${sha256.toLowerCase()}\"`,\n                '',\n                `  url \"${url}\"`,\n                `  name \"${configuration.productName}\"`,\n                `  desc \"${configuration.description.replace('Visualizer', 'Visualiser')}\"`,\n                `  homepage \"${repository}\"`,\n                '',\n                '  auto_updates true',\n                '',\n                `  app \"${configuration.productName}.app\"`,\n                '',\n                '  zap trash: [',\n                `    \"~/Library/Application Support/${configuration.productName}\",`,\n                `    \"~/Library/Preferences/${configuration.build.appId}.plist\",`,\n                `    \"~/Library/Saved Application State/${configuration.build.appId}.savedState\",`,\n                '  ]',\n                'end',\n                ''\n            ].join('\\n'));\n            writeLine('git push homebrew-cask');\n            await exec('git -C dist/homebrew-cask add --all');\n            await exec(`git -C dist/homebrew-cask commit -m \"${configuration.name} ${configuration.version}\"`);\n            await pullrequest('Homebrew', 'homebrew-cask', {\n                title: `${configuration.name} ${configuration.version}`,\n                body: 'Update version and sha256',\n                head: `${process.env.GITHUB_USER}:master`,\n                base: 'master'\n            });\n            await rm('dist', 'homebrew-cask');\n            break;\n        }\n        case 'winget': {\n            writeLine('publish winget');\n            await fork('microsoft', 'winget-pkgs');\n            const name = configuration.name;\n            const version = configuration.version;\n            const product = configuration.productName;\n            const publisher = configuration.author.name;\n            const identifier = `${publisher.replace(' ', '')}.${product}`;\n            const copyright = `Copyright (c) ${publisher}`;\n            const repository = `https://github.com/${configuration.repository}`;\n            const url = `${repository}/releases/download/v${version}/${product}-Setup-${version}.exe`;\n            const content = await fs.readFile(configuration.build.extends, 'utf-8');\n            const builder = JSON.parse(content);\n            const extensions = builder.fileAssociations.map((entry) => `- ${entry.ext}`).sort().join('\\n');\n            const sha256 = await hash(url, 'sha256');\n            const paths = ['dist', 'winget-pkgs', 'manifests', publisher[0].toLowerCase(), publisher.replace(' ', ''), product, version];\n            await mkdir(...paths);\n            writeLine('update manifest');\n            const manifestFile = dirname(...paths, identifier);\n            await fs.writeFile(`${manifestFile}.yaml`, [\n                '# yaml-language-server: $schema=https://aka.ms/winget-manifest.version.1.6.0.schema.json',\n                `PackageIdentifier: ${identifier}`,\n                `PackageVersion: ${version}`,\n                'DefaultLocale: en-US',\n                'ManifestType: version',\n                'ManifestVersion: 1.6.0',\n                ''\n            ].join('\\n'));\n            await fs.writeFile(`${manifestFile}.installer.yaml`, [\n                '# yaml-language-server: $schema=https://aka.ms/winget-manifest.installer.1.6.0.schema.json',\n                `PackageIdentifier: ${identifier}`,\n                `PackageVersion: ${version}`,\n                'Platform:',\n                '- Windows.Desktop',\n                'InstallModes:',\n                '- silent',\n                '- silentWithProgress',\n                'Installers:',\n                '- Architecture: x86',\n                '  Scope: user',\n                '  InstallerType: nullsoft',\n                `  InstallerUrl: ${url}`,\n                `  InstallerSha256: ${sha256.toUpperCase()}`,\n                '  InstallerLocale: en-US',\n                '  InstallerSwitches:',\n                '    Custom: /NORESTART',\n                '  UpgradeBehavior: install',\n                '- Architecture: arm64',\n                '  Scope: user',\n                '  InstallerType: nullsoft',\n                `  InstallerUrl: ${url}`,\n                `  InstallerSha256: ${sha256.toUpperCase()}`,\n                '  InstallerLocale: en-US',\n                '  InstallerSwitches:',\n                '    Custom: /NORESTART',\n                '  UpgradeBehavior: install',\n                'FileExtensions:',\n                extensions,\n                'ManifestType: installer',\n                'ManifestVersion: 1.6.0',\n                ''\n            ].join('\\n'));\n            await fs.writeFile(`${manifestFile}.locale.en-US.yaml`, [\n                '# yaml-language-server: $schema=https://aka.ms/winget-manifest.defaultLocale.1.6.0.schema.json',\n                `PackageIdentifier: ${identifier}`,\n                `PackageVersion: ${version}`,\n                `PackageName: ${product}`,\n                'PackageLocale: en-US',\n                `PackageUrl: ${repository}`,\n                `Publisher: ${publisher}`,\n                `PublisherUrl: ${repository}`,\n                `PublisherSupportUrl: ${repository}/issues`,\n                `Author: ${publisher}`,\n                `License: ${configuration.license}`,\n                `Copyright: ${copyright}`,\n                `CopyrightUrl: ${repository}/blob/main/LICENSE`,\n                `ShortDescription: ${configuration.description}`,\n                `Description: ${configuration.description}`,\n                `Moniker: ${name}`,\n                'Tags:',\n                '- machine-learning',\n                '- deep-learning',\n                '- neural-network',\n                'ManifestType: defaultLocale',\n                'ManifestVersion: 1.6.0',\n                ''\n            ].join('\\n'));\n            writeLine('git push winget-pkgs');\n            await exec('git -C dist/winget-pkgs add --all');\n            await exec(`git -C dist/winget-pkgs commit -m \"Update ${configuration.name} to ${configuration.version}\"`);\n            await pullrequest('microsoft', 'winget-pkgs', {\n                title: `Update ${configuration.productName} to ${configuration.version}`,\n                body: '',\n                head: `${process.env.GITHUB_USER}:master`,\n                base: 'master'\n            });\n            await rm('dist', 'winget-pkgs');\n            break;\n        }\n        default: {\n            writeLine('publish');\n            await rm('dist');\n            await install();\n            await publish('web');\n            await publish('electron');\n            await publish('python');\n            await publish('cask');\n            await publish('winget');\n            break;\n        }\n    }\n};\n\nconst lint = async () => {\n    await install();\n    writeLine('eslint');\n    await exec('npx eslint --config publish/eslint.config.js *.*js source/*.*js test/*.*js publish/*.*js tools/*.js');\n    writeLine('pylint');\n    await exec('python -m pylint -sn --recursive=y source test publish tools *.py');\n};\n\nconst validate = async() => {\n    writeLine('test');\n    await exec('node test/models.js tag:validation');\n    await lint();\n};\n\nconst update = async () => {\n    const dependencies = { ...configuration.dependencies, ...configuration.devDependencies };\n    for (const name of Object.keys(dependencies)) {\n        writeLine(name);\n        /* eslint-disable no-await-in-loop */\n        await exec(`npm install --quiet --no-progress --silent --save-exact ${name}@latest`);\n        /* eslint-enable no-await-in-loop */\n    }\n    await install();\n    const targets = process.argv.length > 3 ? process.argv.slice(3) : [\n        'armnn',\n        'bigdl',\n        'caffe', 'circle', 'cntk', 'coreml',\n        'dlc', 'dnn',\n        'gguf',\n        'kann', 'keras',\n        'mnn', 'mslite', 'megengine',\n        'nnabla',\n        'onnx', 'om',\n        'paddle', 'pytorch',\n        'rknn',\n        'sentencepiece', 'sklearn',\n        'tf',\n        'uff',\n        'xmodel'\n    ];\n    for (const target of targets) {\n        /* eslint-disable no-await-in-loop */\n        await exec(`tools/${target} sync install schema metadata`);\n        /* eslint-enable no-await-in-loop */\n    }\n};\n\nconst pull = async () => {\n    await exec('git fetch --prune origin \"refs/tags/*:refs/tags/*\"');\n    const before = await exec('git rev-parse HEAD', 'utf-8');\n    try {\n        await exec('git pull --prune --rebase --autostash');\n    } catch (error) {\n        writeLine(error.message);\n    }\n    const after = await exec('git rev-parse HEAD', 'utf-8');\n    if (before.trim() !== after.trim()) {\n        const output = await exec(`git diff --name-only ${before.trim()} ${after.trim()}`, 'utf-8');\n        const files = new Set(output.split('\\n'));\n        if (files.has('package.json')) {\n            await clean();\n            await install();\n        }\n    }\n};\n\nconst coverage = async () => {\n    await rm('dist', 'nyc');\n    await mkdir('dist', 'nyc');\n    await exec('cp package.json dist/nyc');\n    await exec('cp -R source dist/nyc');\n    await exec('nyc instrument --compact false source dist/nyc/source');\n    await exec('nyc --instrument npx electron ./dist/nyc');\n};\n\nconst forge = async() => {\n    const command = read();\n    switch (command) {\n        case 'install': {\n            const packages = [\n                '@electron-forge/cli',\n                '@electron-forge/core',\n                '@electron-forge/maker-snap',\n                '@electron-forge/maker-dmg',\n                '@electron-forge/maker-zip'\n            ];\n            await exec(`npm install ${packages.join(' ')} --no-save`);\n            break;\n        }\n        case 'update': {\n            const cwd = path.join(dirname(), '..', 'forge');\n            const node_modules = path.join(cwd, 'node_modules');\n            const links = path.join(cwd, '.links');\n            const exists = await access(node_modules);\n            if (!exists) {\n                await exec('yarn', null, cwd);\n            }\n            await exec('yarn build', null, cwd);\n            await exec('yarn link:prepare', null, cwd);\n            await exec(`yarn link @electron-forge/core --link-folder=${links}`);\n            break;\n        }\n        case 'build': {\n            await exec('npx electron-forge make');\n            break;\n        }\n        default: {\n            throw new Error(`Unsupported forge command ${command}.`);\n        }\n    }\n};\n\nconst analyze = async () => {\n    const exists = await access('third_party/tools/codeql');\n    if (!exists) {\n        await exec('git clone --depth=1 https://github.com/github/codeql.git third_party/tools/codeql');\n    }\n    await rm('dist', 'codeql');\n    await mkdir('dist', 'codeql', 'netron');\n    await exec('cp -r publish source test tools dist/codeql/netron/');\n    await exec('codeql database create dist/codeql/database --source-root dist/codeql/netron --language=javascript --threads=3');\n    await exec('codeql database analyze dist/codeql/database ./third_party/tools/codeql/javascript/ql/src/codeql-suites/javascript-security-and-quality.qls --format=csv --output=dist/codeql/results.csv --threads=3');\n    await exec('cat dist/codeql/results.csv');\n};\n\nconst version = async () => {\n    await pull();\n    const file = dirname('package.json');\n    let content = await fs.readFile(file, 'utf-8');\n    content = content.replace(/(\\s*\"version\":\\s\")(\\d\\.\\d\\.\\d)(\",)/m, (match, p1, p2, p3) => {\n        const version = Array.from((parseInt(p2.split('.').join(''), 10) + 1).toString()).join('.');\n        return p1 + version + p3;\n    });\n    content = content.replace(/(\\s*\"date\":\\s\")(.*)(\",)/m, (match, p1, p2, p3) => {\n        const date = new Date().toISOString().split('.').shift().split('T').join(' ');\n        return p1 + date + p3;\n    });\n    await fs.writeFile(file, content, 'utf-8');\n    await load();\n    await exec('git add package.json');\n    await exec(`git commit -m \"Update to ${configuration.version}\"`);\n    await exec(`git tag v${configuration.version}`);\n    await exec('git push');\n    await exec('git push --tags');\n};\n\nconst main = async () => {\n    await load();\n    try {\n        const task = read();\n        switch (task) {\n            case 'start': await start(); break;\n            case 'clean': await clean(); break;\n            case 'purge': await purge(); break;\n            case 'install': await install(); break;\n            case 'build': await build(); break;\n            case 'publish': await publish(); break;\n            case 'version': await version(); break;\n            case 'lint': await lint(); break;\n            case 'validate': await validate(); break;\n            case 'update': await update(); break;\n            case 'pull': await pull(); break;\n            case 'analyze': await analyze(); break;\n            case 'coverage': await coverage(); break;\n            case 'forge': await forge(); break;\n            default: throw new Error(`Unsupported task '${task}'.`);\n        }\n    } catch (error) {\n        if (process.stdout.write) {\n            process.stdout.write(error.message + os.EOL);\n        }\n        process.exit(1);\n    }\n};\n\nawait main();\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.623046875,
          "content": "{\n    \"name\": \"netron\",\n    \"productName\": \"Netron\",\n    \"author\": {\n        \"name\": \"Lutz Roeder\",\n        \"email\": \"lutzroeder@users.noreply.github.com\",\n        \"url\": \"https://www.lutzroeder.com\"\n    },\n    \"version\": \"8.0.9\",\n    \"date\": \"2025-01-04 03:34:11\",\n    \"description\": \"Visualizer for neural network, deep learning, and machine learning models\",\n    \"license\": \"MIT\",\n    \"repository\": \"lutzroeder/netron\",\n    \"type\": \"module\",\n    \"main\": \"source/app.js\",\n    \"scripts\": {\n        \"start\": \"node package.js start\",\n        \"server\": \"python package.py build start\",\n        \"test\": \"node test/models.js\",\n        \"lint\": \"node package.js lint\",\n        \"validate\": \"node package.js validate\",\n        \"clean\": \"node package.js clean\",\n        \"purge\": \"node package.js purge\",\n        \"install\": \"node package.js install\",\n        \"build\": \"node package.js build\",\n        \"publish\": \"node package.js publish\",\n        \"version\": \"node package.js version\",\n        \"coverage\": \"node package.js coverage\",\n        \"analyze\": \"node package.js analyze\",\n        \"update\": \"node package.js update\",\n        \"pull\": \"node package.js pull\"\n    },\n    \"dependencies\": {\n        \"electron-updater\": \"6.3.9\"\n    },\n    \"devDependencies\": {\n        \"@electron/notarize\": \"2.5.0\",\n        \"electron\": \"33.3.1\",\n        \"electron-builder\": \"25.1.8\",\n        \"eslint\": \"9.17.0\"\n    },\n    \"build\": {\n        \"extends\": \"publish/electron-builder.json\"\n    },\n    \"config\": {\n        \"forge\": \"publish/forge.config.js\"\n    },\n    \"nyc\": {\n        \"reporter\": \"json\",\n        \"report-dir\": \"dist/nyc/report\",\n        \"temp-dir\": \"dist/nyc/.nyc_output\"\n    }\n}\n"
        },
        {
          "name": "package.py",
          "type": "blob",
          "size": 2.7119140625,
          "content": "''' Python Server publish script '''\n\nimport json\nimport os\nimport re\nimport sys\nimport shutil\nimport subprocess\n\nroot_dir = os.path.dirname(os.path.abspath(__file__))\ndist_dir = os.path.join(root_dir, 'dist')\ndist_pypi_dir = os.path.join(dist_dir, 'pypi')\nsource_dir = os.path.join(root_dir, 'source')\npublish_dir = os.path.join(root_dir, 'publish')\n\ndef _read(path):\n    with open(path, 'r', encoding='utf-8') as file:\n        return file.read()\n\ndef _write(path, content):\n    with open(path, 'w', encoding='utf-8') as file:\n        file.write(content)\n\ndef _update(path, regex, value):\n    content = _read(path)\n    def repl(match):\n        return match.group(1) + value + match.group(3)\n    content = re.sub(regex, repl, content)\n    _write(path, content)\n\ndef _build():\n    ''' Build dist/pypi '''\n    shutil.rmtree(os.path.join(source_dir, '__pycache__'), ignore_errors=True)\n    shutil.rmtree(dist_pypi_dir, ignore_errors=True)\n    shutil.copytree(source_dir, os.path.join(dist_pypi_dir, 'netron'))\n    shutil.copyfile(\n        os.path.join(publish_dir, 'pyproject.toml'),\n        os.path.join(dist_pypi_dir, 'pyproject.toml'))\n    os.remove(os.path.join(dist_pypi_dir, 'netron', 'electron.mjs'))\n    os.remove(os.path.join(dist_pypi_dir, 'netron', 'app.js'))\n\ndef _install():\n    ''' Install dist/pypi '''\n    args = [ 'python', '-m', 'pip', 'install', dist_pypi_dir ]\n    try:\n        subprocess.run(args, check=False)\n    except (KeyboardInterrupt, SystemExit):\n        pass\n\ndef _version():\n    ''' Update version '''\n    package = json.loads(_read('./package.json'))\n    _update('./dist/pypi/pyproject.toml',\n        '(version\\\\s*=\\\\s*\")(.*)(\")',\n        package['version'])\n    _update('./dist/pypi/netron/server.py',\n        \"(__version__ = ')(.*)(')\",\n        package['version'])\n    _update('./dist/pypi/netron/index.html',\n        '(<meta name=\"version\" content=\")(.*)(\">)',\n        package['version'])\n    _update('./dist/pypi/netron/index.html',\n        '(<meta name=\"date\" content=\")(.*)(\">)',\n        package['date'])\n\ndef _start():\n    ''' Start server '''\n    # args = [ sys.executable, '-c', 'import netron; netron.main();' ] + sys.args\n    # try:\n    #     subprocess.run(args, env={ 'PYTHONPATH': './dist/pypi' }, check=False)\n    # except (KeyboardInterrupt, SystemExit):\n    #     pass\n    sys.path.insert(0, os.path.join(root_dir, 'dist', 'pypi'))\n    __import__('netron').main()\n    sys.args = []\n    del sys.argv[1:]\n\ndef main(): # pylint: disable=missing-function-docstring\n    table = { 'build': _build, 'install': _install, 'version': _version, 'start': _start }\n    sys.args = sys.argv[1:]\n    while len(sys.args) > 0:\n        command = sys.args.pop(0)\n        del sys.argv[1]\n        table[command]()\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "publish",
          "type": "tree",
          "content": null
        },
        {
          "name": "source",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}