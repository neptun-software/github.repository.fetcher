{
  "metadata": {
    "timestamp": 1736561862307,
    "page": 531,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "happypoulp/redux-tutorial",
      "stars": 3754,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".babelrc",
          "type": "blob",
          "size": 0.201171875,
          "content": "{\n  \"stage\": 0,\n  /* avoid config inheritance:\n  https://github.com/happypoulp/redux-tutorial/issues/88\n  http://stackoverflow.com/questions/32540598/disable-babelrc-inheritance\n  */\n  \"breakConfig\": true\n}"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0732421875,
          "content": "node_modules\nnpm-debug.log\n.DS_Store\ndist\nnested-dispatch.js\ntest.js\n.idea\n"
        },
        {
          "name": "00_introduction.js",
          "type": "blob",
          "size": 5.888671875,
          "content": "// Tutorial 0 - introduction.js\n\n// Why this tutorial?\n// While trying to learn Redux, I realized that I had accumulated incorrect knowledge about flux through\n// articles I read and personal experience. I don't mean that articles about flux are not well written\n// but I just didn't grasp concepts correctly. In the end, I was just applying documentation of different\n// flux frameworks (Reflux, Flummox, FB Flux) and trying to make them match with the theoretical concept I read\n// about (actions / actions creators, store, dispatcher, etc).\n// Only when I started using Redux did I realize that flux is more simple than I thought. This is all\n// thanks to Redux being very well designed and having removed a lot of \"anti-boilerplate features\" introduced\n// by other frameworks I tried before. I now feel that Redux is a much better way to learn about flux\n// than many other frameworks. That's why I want now to share with everyone, using my own words,\n// flux concepts that I am starting to grasp, focusing on the use of Redux.\n\n// You may have seen this diagram representing the famous unidirectional data flow of a flux application:\n\n/*\n                 _________               ____________               ___________\n                |         |             |            |             |           |\n                | Action  |------------▶| Dispatcher |------------▶| callbacks |\n                |_________|             |____________|             |___________|\n                     ▲                                                   |\n                     |                                                   |\n                     |                                                   |\n _________       ____|_____                                          ____▼____\n|         |◀----|  Action  |                                        |         |\n| Web API |     | Creators |                                        |  Store  |\n|_________|----▶|__________|                                        |_________|\n                     ▲                                                   |\n                     |                                                   |\n                 ____|________           ____________                ____▼____\n                |   User       |         |   React   |              | Change  |\n                | interactions |◀--------|   Views   |◀-------------| events  |\n                |______________|         |___________|              |_________|\n\n*/\n\n// In this tutorial we'll gradually introduce you to concepts of the diagram above. But instead of trying\n// to explain this complete diagram and the overall flow it describes, we'll take each piece separately and try to\n// understand why it exists and what role it plays. In the end you'll see that this diagram makes perfect sense\n// once we understand each of its parts.\n\n// But before we start, let's talk a little bit about why flux exists and why we need it...\n// Let's pretend we're building a web application. What are all web applications made of?\n// 1) Templates / html = View\n// 2) Data that will populate our views = Models\n// 3) Logic to retrieve data, glue all views together and to react accordingly to user events,\n//    data modifications, etc. = Controller\n\n// This is the very classic MVC that we all know about. But it actually looks like concepts of flux,\n// just expressed in a slightly different way:\n// - Models look like stores\n// - user events, data modifications and their handlers look like\n//   \"action creators\" -> action -> dispatcher -> callback\n// - Views look like React views (or anything else as far as flux is concerned)\n\n// So is flux just a matter of new vocabulary? Not exactly. But vocabulary DOES matter, because by introducing\n// these new terms we are now able to express more precisely things that were regrouped under\n// various terminologies... For example, isn't a data fetch an action? Just like a click is also an action?\n// And a change in an input is an action too... Then we're all already used to issuing actions from our\n// applications, we were just calling them differently. And instead of having handlers for those\n// actions directly modify Models or Views, flux ensures all actions go first through something called\n// a dispatcher, then through our stores, and finally all watchers of stores are notified.\n\n// To get more clarity how MVC and flux differ, we'll\n// take a classic use-case in an MVC application:\n// In a classic MVC application you could easily end up with:\n// 1) User clicks on button \"A\"\n// 2) A click handler on button \"A\" triggers a change on Model \"A\"\n// 3) A change handler on Model \"A\" triggers a change on Model \"B\"\n// 4) A change handler on Model \"B\" triggers a change on View \"B\" that re-renders itself\n\n// Finding the source of a bug in such an environment when something goes wrong can become quite challenging\n// very quickly. This is because every View can watch every Model, and every Model can watch other Models, so\n// basically data can arrive from a lot of places and be changed by a lot of sources (any views or any models).\n\n// Whereas when using flux and its unidirectional data flow, the example above could become:\n// 1) user clicks on button \"A\"\n// 2) a handler on button \"A\" triggers an action that is dispatched and produces a change on Store \"A\"\n// 3) since all other stores are also notified about the action, Store B can react to the same action too\n// 4) View \"B\" gets notified by the change in Stores A and B, and re-renders\n\n// See how we avoid directly linking Store A to Store B? Each store can only be\n// modified by an action and nothing else. And once all stores have replied to an action,\n// views can finally update. So in the end, data always flows in one way:\n//     action -> store -> view -> action -> store -> view -> action -> ...\n\n// Just as we started our use case above from an action, let's start our tutorial with\n// actions and action creators.\n\n// Go to next tutorial: 01_simple-action-creator.js\n"
        },
        {
          "name": "01_simple-action-creator.js",
          "type": "blob",
          "size": 1.9541015625,
          "content": "// Tutorial 1 - simple-action-creator.js\n\n// We started to talk a little about actions in the introduction but what exactly are those \"action creators\"\n// and how are they linked to \"actions\"?\n\n// It's actually so simple that a few lines of code can explain it all!\n\n// The action creator is just a function...\nvar actionCreator = function() {\n    // ...that creates an action (yeah, the name action creator is pretty obvious now) and returns it\n    return {\n        type: 'AN_ACTION'\n    }\n}\n\n// So is that all? yes.\n\n// However, one thing to note is the format of the action. This is kind of a convention in flux\n// that the action is an object that contains a \"type\" property. This type allows for further\n// handling of the action. Of course, the action can also contain other properties to\n// pass any data you want.\n\n// We'll also see later that the action creator can actually return something other than an action,\n// like a function. This will be extremely useful for async action handling (more on that\n// in dispatch-async-action.js).\n\n// We can call this action creator and get an action as expected:\nconsole.log(actionCreator())\n// Output: { type: 'AN_ACTION' }\n\n// Ok, this works but it does not go anywhere...\n// What we need is to have this action be sent somewhere so that\n// anyone interested could know that something happened and could act accordingly.\n// We call this process \"Dispatching an action\".\n\n// To dispatch an action we need... a dispatch function (\"Captain obvious\").\n// And to let anyone interested know that an action happened, we need a mechanism to register\n// \"handlers\". Such \"handlers\" to actions in traditional flux application are called stores and\n// we'll see in the next section how they are called in Redux.\n\n// So far here is the flow of our application:\n// ActionCreator -> Action\n\n// Read more about actions and action creators here:\n// http://redux.js.org/docs/recipes/ReducingBoilerplate.html\n\n// Go to next tutorial: 02_about-state-and-meet-redux.js\n"
        },
        {
          "name": "02_about-state-and-meet-redux.js",
          "type": "blob",
          "size": 2.3359375,
          "content": "// Tutorial 02 - about-state-and-meet-redux.js\n\n// Sometimes the actions that we'll handle in our application will not only inform us\n// that something happened but also tell us that data needs to be updated.\n\n// This is actually quite a big challenge in any app.\n// Where do I keep all the data regarding my application along its lifetime?\n// How do I handle modification of such data?\n// How do I propagate modifications to all parts of my application?\n\n// Here comes Redux.\n\n// Redux (https://github.com/reactjs/redux) is a \"predictable state container for JavaScript apps\"\n\n// Let's review the above questions and reply to them with\n// Redux vocabulary (flux vocabulary too for some of them):\n\n// Where do I keep all the data regarding my application along its lifetime?\n//     You keep it the way you want (JS object, array, Immutable structure, ...).\n//     Data of your application will be called state. This makes sense since we're talking about\n//     all the application's data that will evolve over time, it's really the application's state.\n//     But you hand it over to Redux (Redux is a \"state container\", remember?).\n// How do I handle data modifications?\n//     Using reducers (called \"stores\" in traditional flux).\n//     A reducer is a subscriber to actions.\n//     A reducer is just a function that receives the current state of your application, the action,\n//     and returns a new state modified (or reduced as they call it)\n// How do I propagate modifications to all parts of my application?\n//     Using subscribers to state's modifications.\n\n// Redux ties all this together for you.\n// To sum up, Redux will provide you:\n//     1) a place to put your application state\n//     2) a mechanism to dispatch actions to modifiers of your application state, AKA reducers\n//     3) a mechanism to subscribe to state updates\n\n// The Redux instance is called a store and can be created like this:\n/*\n    import { createStore } from 'redux'\n    var store = createStore()\n*/\n\n// But if you run the code above, you'll notice that it throws an error:\n//     Error: Invariant Violation: Expected the reducer to be a function.\n\n// That's because createStore expects a function that will allow it to reduce your state.\n\n// Let's try again\n\nimport { createStore } from 'redux'\n\nvar store = createStore(() => {})\n\n// Seems good for now...\n\n// Go to next tutorial: 03_simple-reducer.js\n"
        },
        {
          "name": "03_simple-reducer.js",
          "type": "blob",
          "size": 1.9443359375,
          "content": "// Tutorial 03 - simple-reducer.js\n\n// Now that we know how to create a Redux instance that will hold the state of our application\n// we will focus on those reducer functions that will allow us to transform this state.\n\n// A word about reducer VS store:\n// As you may have noticed, in the flux diagram shown in the introduction, we had \"Store\", not\n// \"Reducer\" like Redux is expecting. So how exactly do Store and Reducer differ?\n// It's more simple than you could imagine: A Store keeps your data in it while a Reducer doesn't.\n// So in traditional flux, stores hold state in them while in Redux, each time a reducer is\n// called, it is passed the state that needs to be updated. This way, Redux's stores became\n// \"stateless stores\" and were renamed reducers.\n\n// As stated before, when creating a Redux instance you must give it a reducer function...\n\nimport { createStore } from 'redux'\n\nvar store_0 = createStore(() => {})\n\n// ... so that Redux can call this function on your application state each time an action occurs.\n// Giving reducer(s) to createStore is exactly how Redux registers the action \"handlers\" (read reducers) we\n// were talking about in section 01_simple-action-creator.js.\n\n// Let's put some log in our reducer\n\nvar reducer = function (...args) {\n    console.log('Reducer was called with args', args)\n}\n\nvar store_1 = createStore(reducer)\n\n// Output: Reducer was called with args [ undefined, { type: '@@redux/INIT' } ]\n\n// Did you see that? Our reducer is actually called even if we didn't dispatch any action...\n// That's because to initialize the state of the application,\n// Redux actually dispatches an init action ({ type: '@@redux/INIT' })\n\n// When called, a reducer is given those parameters: (state, action)\n// It's then very logical that at an application initialization, the state, not being\n// initialized yet, is \"undefined\"\n\n// But then what is the state of our application after Redux sends its \"init\" action?\n\n// Go to next tutorial: 04_get-state.js\n"
        },
        {
          "name": "04_get-state.js",
          "type": "blob",
          "size": 4.998046875,
          "content": "// Tutorial 04 - get-state.js\n\n// How do we retrieve the state from our Redux instance?\n\nimport { createStore } from 'redux'\n\nvar reducer_0 = function (state, action) {\n    console.log('reducer_0 was called with state', state, 'and action', action)\n}\n\nvar store_0 = createStore(reducer_0)\n// Output: reducer_0 was called with state undefined and action { type: '@@redux/INIT' }\n\n// To get the state that Redux is holding for us, you call getState\n\nconsole.log('store_0 state after initialization:', store_0.getState())\n// Output: store_0 state after initialization: undefined\n\n// So the state of our application is still undefined after the initialization? Well of course it is,\n// our reducer is not doing anything... Remember how we described the expected behavior of a reducer in\n// \"about-state-and-meet-redux\"?\n//     \"A reducer is just a function that receives the current state of your application, the action,\n//     and returns a new state modified (or reduced as they call it)\"\n// Our reducer is not returning anything right now so the state of our application is what\n// reducer() returns, hence \"undefined\".\n\n// Let's try to send an initial state of our application if the state given to reducer is undefined:\n\nvar reducer_1 = function (state, action) {\n    console.log('reducer_1 was called with state', state, 'and action', action)\n    if (typeof state === 'undefined') {\n        return {}\n    }\n\n    return state;\n}\n\nvar store_1 = createStore(reducer_1)\n// Output: reducer_1 was called with state undefined and action { type: '@@redux/INIT' }\n\nconsole.log('store_1 state after initialization:', store_1.getState())\n// Output: store_1 state after initialization: {}\n\n// As expected, the state returned by Redux after initialization is now {}\n\n// There is however a much cleaner way to implement this pattern thanks to ES6:\n\nvar reducer_2 = function (state = {}, action) {\n    console.log('reducer_2 was called with state', state, 'and action', action)\n\n    return state;\n}\n\nvar store_2 = createStore(reducer_2)\n// Output: reducer_2 was called with state {} and action { type: '@@redux/INIT' }\n\nconsole.log('store_2 state after initialization:', store_2.getState())\n// Output: store_2 state after initialization: {}\n\n// You've probably noticed that since we've used the default parameter on state parameter of reducer_2,\n// we no longer get undefined as state's value in our reducer's body.\n\n// Let's now recall that a reducer is only called in response to an action dispatched and\n// let's fake a state modification in response to an action type 'SAY_SOMETHING'\n\nvar reducer_3 = function (state = {}, action) {\n    console.log('reducer_3 was called with state', state, 'and action', action)\n\n    switch (action.type) {\n        case 'SAY_SOMETHING':\n            return {\n                ...state,\n                message: action.value\n            }\n        default:\n            return state;\n    }\n}\n\nvar store_3 = createStore(reducer_3)\n// Output: reducer_3 was called with state {} and action { type: '@@redux/INIT' }\n\nconsole.log('store_3 state after initialization:', store_3.getState())\n// Output: store_3 state after initialization: {}\n\n// Nothing new in our state so far since we did not dispatch any action yet. But there are few\n// important things to pay attention to in the last example:\n//     0) I assumed that our action contains a type and a value property. The type property is mostly\n//        a convention in flux actions and the value property could have been anything else.\n//     1) You'll often see the pattern involving a switch to respond appropriately\n//        to an action received in your reducers\n//     2) When using a switch, NEVER forget to have a \"default: return state\" because\n//        if you don't, you'll end up having your reducer return undefined (and lose your state).\n//     3) Notice how we returned a new state made by merging current state with { message: action.value },\n//        all that thanks to this awesome ES7 notation (Object Spread): { ...state, message: action.value }\n//     4) Note also that this ES7 Object Spread notation suits our example because it's doing a shallow\n//        copy of { message: action.value } over our state (meaning that first level properties of state\n//        are completely overwritten - as opposed to gracefully merged - by first level property of\n//        { message: action.value }). But if we had a more complex / nested data structure, you might choose\n//        to handle your state's updates very differently:\n//        - using Immutable.js (https://facebook.github.io/immutable-js/)\n//        - using Object.assign (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n//        - using manual merge\n//        - or whatever other strategy that suits your needs and the structure of your state since\n//          Redux is absolutely NOT opinionated on this (remember, Redux is a state container).\n\n// Now that we're starting to handle actions in our reducer let's talk about having multiple reducers and\n// combining them.\n\n// Go to next tutorial: 05_combine-reducers.js\n"
        },
        {
          "name": "05_combine-reducers.js",
          "type": "blob",
          "size": 5,
          "content": "// Tutorial 05 - combine-reducers.js\n\n// We're now starting to get a grasp of what a reducer is...\n\nvar reducer_0 = function (state = {}, action) {\n    console.log('reducer_0 was called with state', state, 'and action', action)\n\n    switch (action.type) {\n        case 'SAY_SOMETHING':\n            return {\n                ...state,\n                message: action.value\n            }\n        default:\n            return state;\n    }\n}\n\n// ... but before going further, we should start wondering what our reducer will look like when\n// we'll have tens of actions:\n\nvar reducer_1 = function (state = {}, action) {\n    console.log('reducer_1 was called with state', state, 'and action', action)\n\n    switch (action.type) {\n        case 'SAY_SOMETHING':\n            return {\n                ...state,\n                message: action.value\n            }\n        case 'DO_SOMETHING':\n            // ...\n        case 'LEARN_SOMETHING':\n            // ...\n        case 'HEAR_SOMETHING':\n            // ...\n        case 'GO_SOMEWHERE':\n            // ...\n        // etc.\n        default:\n            return state;\n    }\n}\n\n// It becomes quite evident that a single reducer function cannot hold all our\n// application's actions handling (well it could hold it, but it wouldn't be very maintainable...).\n\n// Luckily for us, Redux doesn't care if we have one reducer or a dozen and it will even help us to\n// combine them if we have many!\n\n// Let's declare 2 reducers\n\nvar userReducer = function (state = {}, action) {\n    console.log('userReducer was called with state', state, 'and action', action)\n\n    switch (action.type) {\n        // etc.\n        default:\n            return state;\n    }\n}\nvar itemsReducer = function (state = [], action) {\n    console.log('itemsReducer was called with state', state, 'and action', action)\n\n    switch (action.type) {\n        // etc.\n        default:\n            return state;\n    }\n}\n\n// I'd like you to pay special attention to the initial state that was actually given to\n// each reducer: userReducer got an initial state in the form of a literal object ({}) while\n// itemsReducer got an initial state in the form of an array ([]). This is just to\n// make clear that a reducer can actually handle any type of data structure. It's really\n// up to you to decide which data structure suits your needs (an object literal, an array,\n// a boolean, a string, an immutable structure, ...).\n\n// With this new multiple reducer approach, we will end up having each reducer handle only\n// a slice of our application state.\n\n// But as we already know, createStore expects just one reducer function.\n\n// So how do we combine our reducers? And how do we tell Redux that each reducer will only handle\n// a slice of our state?\n// It's fairly simple. We use Redux combineReducers helper function. combineReducers takes a hash and\n// returns a function that, when invoked, will call all our reducers, retrieve the new slice of state and\n// reunite them in a state object (a simple hash {}) that Redux is holding.\n// Long story short, here is how you create a Redux instance with multiple reducers:\n\nimport { createStore, combineReducers } from 'redux'\n\nvar reducer = combineReducers({\n    user: userReducer,\n    items: itemsReducer\n})\n// Output:\n// userReducer was called with state {} and action { type: '@@redux/INIT' }\n// userReducer was called with state {} and action { type: '@@redux/PROBE_UNKNOWN_ACTION_9.r.k.r.i.c.n.m.i' }\n// itemsReducer was called with state [] and action { type: '@@redux/INIT' }\n// itemsReducer was called with state [] and action { type: '@@redux/PROBE_UNKNOWN_ACTION_4.f.i.z.l.3.7.s.y.v.i' }\nvar store_0 = createStore(reducer)\n// Output:\n// userReducer was called with state {} and action { type: '@@redux/INIT' }\n// itemsReducer was called with state [] and action { type: '@@redux/INIT' }\n\n// As you can see in the output, each reducer is correctly called with the init action @@redux/INIT.\n// But what is this other action? This is a sanity check implemented in combineReducers\n// to assure that a reducer will always return a state != 'undefined'.\n// Please note also that the first invocation of init actions in combineReducers share the same purpose\n// as random actions (to do a sanity check).\n\nconsole.log('store_0 state after initialization:', store_0.getState())\n// Output:\n// store_0 state after initialization: { user: {}, items: [] }\n\n// It's interesting to note that Redux handles our slices of state correctly,\n// the final state is indeed a simple hash made of the userReducer's slice and the itemsReducer's slice:\n// {\n//     user: {}, // {} is the slice returned by our userReducer\n//     items: [] // [] is the slice returned by our itemsReducer\n// }\n\n// Since we initialized the state of each of our reducers with a specific value ({} for userReducer and\n// [] for itemsReducer) it's no coincidence that those values are found in the final Redux state.\n\n// By now we have a good idea of how reducers will work. It would be nice to have some\n// actions being dispatched and see the impact on our Redux state.\n\n// Go to next tutorial: 06_dispatch-action.js\n"
        },
        {
          "name": "06_dispatch-action.js",
          "type": "blob",
          "size": 3.4326171875,
          "content": "// Tutorial 06 - dispatch-action.js\n\n// So far we've focused on building our reducer(s) and we haven't dispatched any of our own actions.\n// We'll keep the same reducers from our previous tutorial and handle a few actions:\n\nvar userReducer = function (state = {}, action) {\n    console.log('userReducer was called with state', state, 'and action', action)\n\n    switch (action.type) {\n        case 'SET_NAME':\n            return {\n                ...state,\n                name: action.name\n            }\n        default:\n            return state;\n    }\n}\nvar itemsReducer = function (state = [], action) {\n    console.log('itemsReducer was called with state', state, 'and action', action)\n\n    switch (action.type) {\n        case 'ADD_ITEM':\n            return [\n                ...state,\n                action.item\n            ]\n        default:\n            return state;\n    }\n}\n\nimport { createStore, combineReducers } from 'redux'\n\nvar reducer = combineReducers({\n    user: userReducer,\n    items: itemsReducer\n})\nvar store_0 = createStore(reducer)\n\n\nconsole.log(\"\\n\", '### It starts here')\nconsole.log('store_0 state after initialization:', store_0.getState())\n// Output:\n// store_0 state after initialization: { user: {}, items: [] }\n\n// Let's dispatch our first action... Remember in 'simple-action-creator.js' we said:\n//     \"To dispatch an action we need... a dispatch function.\" Captain obvious\n\n// The dispatch function we're looking for is provided by Redux and will propagate our action\n// to all of our reducers! The dispatch function is accessible through the Redux\n// instance property \"dispatch\"\n\n// To dispatch an action, simply call:\n\nstore_0.dispatch({\n    type: 'AN_ACTION'\n})\n// Output:\n// userReducer was called with state {} and action { type: 'AN_ACTION' }\n// itemsReducer was called with state [] and action { type: 'AN_ACTION' }\n\n// Each reducer is effectively called but since none of our reducers care about this action type,\n// the state is left unchanged:\n\nconsole.log('store_0 state after action AN_ACTION:', store_0.getState())\n// Output: store_0 state after action AN_ACTION: { user: {}, items: [] }\n\n// But, wait a minute! Aren't we supposed to use an action creator to send an action? We could indeed\n// use an actionCreator but since all it does is return an action it would not bring anything more to\n// this example. But for the sake of future difficulties let's do it the right way according to\n// flux theory. And let's make this action creator send an action we actually care about:\n\nvar setNameActionCreator = function (name) {\n    return {\n        type: 'SET_NAME',\n        name: name\n    }\n}\n\nstore_0.dispatch(setNameActionCreator('bob'))\n// Output:\n// userReducer was called with state {} and action { type: 'SET_NAME', name: 'bob' }\n// itemsReducer was called with state [] and action { type: 'SET_NAME', name: 'bob' }\n\nconsole.log('store_0 state after action SET_NAME:', store_0.getState())\n// Output:\n// store_0 state after action SET_NAME: { user: { name: 'bob' }, items: [] }\n\n// We just handled our first action and it changed the state of our application!\n\n// But this seems too simple and not close enough to a real use-case. For example,\n// what if we'd like do some async work in our action creator before dispatching\n// the action? We'll talk about that in the next tutorial \"dispatch-async-action.js\"\n\n// So far here is the flow of our application\n// ActionCreator -> Action -> dispatcher -> reducer\n\n// Go to next tutorial: 07_dispatch-async-action-1.js\n"
        },
        {
          "name": "07_dispatch-async-action-1.js",
          "type": "blob",
          "size": 3.435546875,
          "content": "// Tutorial 07 - dispatch-async-action-1.js\n\n// We previously saw how we can dispatch actions and how those actions will modify\n// the state of our application thanks to reducers.\n\n// But so far we've only considered synchronous actions or, more exactly, action creators\n// that produce an action synchronously: when called an action is returned immediately.\n\n// Let's now imagine a simple asynchronous use-case:\n// 1) user clicks on button \"Say Hi in 2 seconds\"\n// 2) When button \"A\" is clicked, we'd like to show message \"Hi\" after 2 seconds have elapsed\n// 3) 2 seconds later, our view is updated with the message \"Hi\"\n\n// Of course this message is part of our application state so we have to save it\n// in Redux store. But what we want is to have our store save the message\n// only 2 seconds after the action creator is called (because if we were to update our state\n// immediately, any subscriber to state's modifications - like our view - would be notified right away\n// and would then react to this update 2 seconds too soon).\n\n// If we were to call an action creator like we did until now...\n\nimport { createStore, combineReducers } from 'redux'\n\nvar reducer = combineReducers({\n    speaker: function (state = {}, action) {\n        console.log('speaker was called with state', state, 'and action', action)\n\n        switch (action.type) {\n            case 'SAY':\n                return {\n                    ...state,\n                    message: action.message\n                }\n            default:\n                return state;\n        }\n    }\n})\nvar store_0 = createStore(reducer)\n\nvar sayActionCreator = function (message) {\n    return {\n        type: 'SAY',\n        message\n    }\n}\n\nconsole.log(\"\\n\", 'Running our normal action creator:', \"\\n\")\n\nconsole.log(new Date());\nstore_0.dispatch(sayActionCreator('Hi'))\n\nconsole.log(new Date());\nconsole.log('store_0 state after action SAY:', store_0.getState())\n// Output (skipping initialization output):\n//     Sun Aug 02 2015 01:03:05 GMT+0200 (CEST)\n//     speaker was called with state {} and action { type: 'SAY', message: 'Hi' }\n//     Sun Aug 02 2015 01:03:05 GMT+0200 (CEST)\n//     store_0 state after action SAY: { speaker: { message: 'Hi' } }\n\n\n// ... then we see that our store is updated immediately.\n\n// What we'd like instead is an action creator that looks a bit like this:\n\nvar asyncSayActionCreator_0 = function (message) {\n    setTimeout(function () {\n        return {\n            type: 'SAY',\n            message\n        }\n    }, 2000)\n}\n\n// But then our action creator would not return an action, it would return \"undefined\". So this is not\n// quite the solution we're looking for.\n\n// Here's the trick: instead of returning an action, we'll return a function. And this function will be the\n// one to dispatch the action when it seems appropriate to do so. But if we want our function to be able to\n// dispatch the action it should be given the dispatch function. Then, this should look like this:\n\nvar asyncSayActionCreator_1 = function (message) {\n    return function (dispatch) {\n        setTimeout(function () {\n            dispatch({\n                type: 'SAY',\n                message\n            })\n        }, 2000)\n    }\n}\n\n// Again you'll notice that our action creator is not returning an action, it is returning a function.\n// So there is a high chance that our reducers won't know what to do with it. But you never know, so let's\n// try it out and find out what happens...\n\n// Go to next tutorial: 08_dispatch-async-action-2.js\n"
        },
        {
          "name": "08_dispatch-async-action-2.js",
          "type": "blob",
          "size": 1.6826171875,
          "content": "// Tutorial 08 - dispatch-async-action-2.js\n\n// Let's try to run the first async action creator that we wrote in dispatch-async-action-1.js.\n\nimport { createStore, combineReducers } from 'redux'\n\nvar reducer = combineReducers({\n    speaker: function (state = {}, action) {\n        console.log('speaker was called with state', state, 'and action', action)\n\n        switch (action.type) {\n            case 'SAY':\n                return {\n                    ...state,\n                    message: action.message\n                }\n            default:\n                return state;\n        }\n    }\n})\nvar store_0 = createStore(reducer)\n\nvar asyncSayActionCreator_1 = function (message) {\n    return function (dispatch) {\n        setTimeout(function () {\n            dispatch({\n                type: 'SAY',\n                message\n            })\n        }, 2000)\n    }\n}\n\nconsole.log(\"\\n\", 'Running our async action creator:', \"\\n\")\nstore_0.dispatch(asyncSayActionCreator_1('Hi'))\n\n// Output:\n//     ...\n//     /Users/classtar/Codes/redux-tutorial/node_modules/redux/node_modules/invariant/invariant.js:51\n//         throw error;\n//               ^\n//     Error: Invariant Violation: Actions must be plain objects. Use custom middleware for async actions.\n//     ...\n\n// It seems that our function didn't even reach our reducers. But Redux has been kind enough to give us a\n// tip: \"Use custom middleware for async actions.\". It looks like we're on the right path but what is this\n// \"middleware\" thing?\n\n// Just to reassure you, our action creator asyncSayActionCreator_1 is well-written and will work as expected\n// as soon as we've figured out what middleware is and how to use it.\n\n// Go to next tutorial: 09_middleware.js\n"
        },
        {
          "name": "09_middleware.js",
          "type": "blob",
          "size": 7.42578125,
          "content": "// Tutorial 09 - middleware.js\n\n// We left dispatch-async-action-2.js with a new concept: \"middleware\". Somehow middleware should help us\n// to solve async action handling. So what exactly is middleware?\n\n// Generally speaking middleware is something that goes between parts A and B of an application to\n// transform what A sends before passing it to B. So instead of having:\n// A -----> B\n// we end up having\n// A ---> middleware 1 ---> middleware 2 ---> middleware 3 --> ... ---> B\n\n// How could middleware help us in the Redux context? Well it seems that the function that we are\n// returning from our async action creator cannot be handled natively by Redux but if we had a\n// middleware between our action creator and our reducers, we could transform this function into something\n// that suits Redux:\n\n// action ---> dispatcher ---> middleware 1 ---> middleware 2 ---> reducers\n\n// Our middleware will be called each time an action (or whatever else, like a function in our\n// async action creator case) is dispatched and it should be able to help our action creator\n// dispatch the real action when it wants to (or do nothing - this is a totally valid and\n// sometimes desired behavior).\n\n// In Redux, middleware are functions that must conform to a very specific signature and follow\n// a strict structure:\n/*\n    var anyMiddleware = function ({ dispatch, getState }) {\n        return function(next) {\n            return function (action) {\n                // your middleware-specific code goes here\n            }\n        }\n    }\n*/\n\n// As you can see above, a middleware is made of 3 nested functions (that will get called sequentially):\n// 1) The first level provides the dispatch function and a getState function (if your\n//     middleware or your action creator needs to read data from state) to the 2 other levels\n// 2) The second level provides the next function that will allow you to explicitly hand over\n//     your transformed input to the next middleware or to Redux (so that Redux can finally call all reducers).\n// 3) the third level provides the action received from the previous middleware or from your dispatch\n//     and can either trigger the next middleware (to let the action continue to flow) or process\n//     the action in any appropriate way.\n\n// Those of you who are trained to functional programming may have recognized above an opportunity\n// to apply a functional pattern: currying (if you aren't, don't worry, skipping the next 10 lines\n// won't affect your Redux understanding). Using currying, you could simplify the above function like that:\n/*\n    // \"curry\" may come from any functional programming library (lodash, ramda, etc.)\n    var thunkMiddleware = curry(\n        ({dispatch, getState}, next, action) => (\n            // your middleware-specific code goes here\n        )\n    );\n*/\n\n// The middleware we have to build for our async action creator is called a thunk middleware and\n// its code is provided here: https://github.com/gaearon/redux-thunk.\n// Here is what it looks like (with function body translated to es5 for readability):\n\nvar thunkMiddleware = function ({ dispatch, getState }) {\n    // console.log('Enter thunkMiddleware');\n    return function(next) {\n        // console.log('Function \"next\" provided:', next);\n        return function (action) {\n            // console.log('Handling action:', action);\n            return typeof action === 'function' ?\n                action(dispatch, getState) :\n                next(action)\n        }\n    }\n}\n\n// To tell Redux that we have one or more middlewares, we must use one of Redux's\n// helper functions: applyMiddleware.\n\n// \"applyMiddleware\" takes all your middlewares as parameters and returns a function to be called\n// with Redux createStore. When this last function is invoked, it will produce \"a higher-order\n// store that applies middleware to a store's dispatch\".\n// (from https://github.com/reactjs/redux/blob/master/src/applyMiddleware.js)\n\n// Here is how you would integrate a middleware into your Redux store:\n\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\n\nconst finalCreateStore = applyMiddleware(thunkMiddleware)(createStore)\n// For multiple middlewares, write: applyMiddleware(middleware1, middleware2, ...)(createStore)\n\nvar reducer = combineReducers({\n    speaker: function (state = {}, action) {\n        console.log('speaker was called with state', state, 'and action', action)\n\n        switch (action.type) {\n            case 'SAY':\n                return {\n                    ...state,\n                    message: action.message\n                }\n            default:\n                return state\n        }\n    }\n})\n\nconst store_0 = finalCreateStore(reducer)\n// Output:\n//     speaker was called with state {} and action { type: '@@redux/INIT' }\n//     speaker was called with state {} and action { type: '@@redux/PROBE_UNKNOWN_ACTION_s.b.4.z.a.x.a.j.o.r' }\n//     speaker was called with state {} and action { type: '@@redux/INIT' }\n\n// Now that we have our middleware-ready store instance, let's try again to dispatch our async action:\n\nvar asyncSayActionCreator_1 = function (message) {\n    return function (dispatch) {\n        setTimeout(function () {\n            console.log(new Date(), 'Dispatch action now:')\n            dispatch({\n                type: 'SAY',\n                message\n            })\n        }, 2000)\n    }\n}\n\nconsole.log(\"\\n\", new Date(), 'Running our async action creator:', \"\\n\")\n\nstore_0.dispatch(asyncSayActionCreator_1('Hi'))\n// Output:\n//     Mon Aug 03 2015 00:01:20 GMT+0200 (CEST) Running our async action creator:\n//     Mon Aug 03 2015 00:01:22 GMT+0200 (CEST) 'Dispatch action now:'\n//     speaker was called with state {} and action { type: 'SAY', message: 'Hi' }\n\n// Our action is correctly dispatched 2 seconds after our call the async action creator!\n\n// Just for your curiosity, here is how a middleware to log all actions that are dispatched, would\n// look like:\n\nfunction logMiddleware ({ dispatch, getState }) {\n    return function(next) {\n        return function (action) {\n            console.log('logMiddleware action received:', action)\n            return next(action)\n        }\n    }\n}\n\n// Same below for a middleware to discard all actions that are dispatched (not very useful as is\n// but with a bit of more logic it could selectively discard a few actions while passing others\n// to next middleware or Redux):\nfunction discardMiddleware ({ dispatch, getState }) {\n    return function(next) {\n        return function (action) {\n            console.log('discardMiddleware action received:', action)\n        }\n    }\n}\n\n// Try to modify finalCreateStore call above by using the logMiddleware and / or the discardMiddleware\n// and see what happens...\n// For example, using:\n//     const finalCreateStore = applyMiddleware(discardMiddleware, thunkMiddleware)(createStore)\n// should make your actions never reach your thunkMiddleware and even less your reducers.\n\n// See http://redux.js.org/docs/introduction/Ecosystem.html#middleware, section Middleware, to\n// see other middleware examples.\n\n// Let's sum up what we've learned so far:\n// 1) We know how to write actions and action creators\n// 2) We know how to dispatch our actions\n// 3) We know how to handle custom actions like asynchronous actions thanks to middlewares\n\n// The only missing piece to close the loop of Flux application is to be notified about\n// state updates in order to react to them (by re-rendering our components for example).\n\n// So how do we subscribe to our Redux store updates?\n\n// Go to next tutorial: 10_state-subscriber.js\n"
        },
        {
          "name": "10_state-subscriber.js",
          "type": "blob",
          "size": 4.1630859375,
          "content": "// Tutorial 10 - state-subscriber.js\n\n// We're close to having a complete Flux loop but we still miss one critical part:\n\n//  _________      _________       ___________\n// |         |    | Change  |     |   React   |\n// |  Store  |----▶ events  |-----▶   Views   |\n// |_________|    |_________|     |___________|\n\n// Without it, we cannot update our views when the store changes.\n\n// Fortunately, there is a very simple way to \"watch\" over our Redux store's updates:\n\n/*\n    store.subscribe(function() {\n        // retrieve latest store state here\n        // Ex:\n        console.log(store.getState());\n    })\n*/\n\n// Yeah... So simple that it almost makes us believe in Santa Claus again.\n\n// Let's try this out:\n\nimport { createStore, combineReducers } from 'redux'\n\nvar itemsReducer = function (state = [], action) {\n    console.log('itemsReducer was called with state', state, 'and action', action)\n\n    switch (action.type) {\n        case 'ADD_ITEM':\n            return [\n                ...state,\n                action.item\n            ]\n        default:\n            return state;\n    }\n}\n\nvar reducer = combineReducers({ items: itemsReducer })\nvar store_0 = createStore(reducer)\n\nstore_0.subscribe(function() {\n    console.log('store_0 has been updated. Latest store state:', store_0.getState());\n    // Update your views here\n})\n\nvar addItemActionCreator = function (item) {\n    return {\n        type: 'ADD_ITEM',\n        item: item\n    }\n}\n\nstore_0.dispatch(addItemActionCreator({ id: 1234, description: 'anything' }))\n\n// Output:\n//     ...\n//     store_0 has been updated. Latest store state: { items: [ { id: 1234, description: 'anything' } ] }\n\n// Our subscribe callback is correctly called and our store now contains the new item that we added.\n\n// Theoretically speaking we could stop here. Our Flux loop is closed, we understood all concepts that make\n// Flux and we saw that it is not that much of a mystery. But to be honest, there is still a lot to talk\n// about and a few things in the last example were intentionally left aside to keep the simplest form of this\n// last Flux concept:\n\n// - Our subscriber callback did not receive the state as a parameter, why?\n// - Since we did not receive our new state, we were bound to exploit our closured store (store_0) so this\n//     solution is not acceptable in a real multi-modules application...\n// - How do we actually update our views?\n// - How do we unsubscribe from store updates?\n// - More generally speaking, how should we integrate Redux with React?\n\n// We're now entering a more \"Redux inside React\" specific domain.\n\n// It is very important to understand that Redux is by no means bound to React. It is really a\n// \"Predictable state container for JavaScript apps\" and you can use it in many ways, a React\n// application just being one of them.\n\n// In that perspective we would be a bit lost if it wasn't for react-redux (https://github.com/reactjs/react-redux).\n// Previously integrated inside Redux (before 1.0.0), this repository holds all the bindings we need to simplify\n// our life when using Redux inside React.\n\n// Back to our \"subscribe\" case... Why exactly do we have this subscribe function that seems so simple but at\n// the same time also seems to not provide enough features?\n\n// Its simplicity is actually its power! Redux, with its current minimalist API (including \"subscribe\") is\n// highly extensible and this allows developers to build some crazy products like the Redux DevTools\n// (https://github.com/gaearon/redux-devtools).\n\n// But in the end we still need a \"better\" API to subscribe to our store changes. That's exactly what react-redux\n// brings us: an API that will allow us to seamlessly fill the gap between the raw Redux subscribing mechanism\n// and our developer expectations. In the end, you won't need to use \"subscribe\" directly. Instead you will\n// use bindings such as \"provide\" or \"connect\" and those will hide from you the \"subscribe\" method.\n\n// So yeah, the \"subscribe\" method will still be used but it will be done through a higher order API that\n// handles access to Redux state for you.\n\n// We'll now cover those bindings and show how simple it is to wire your components to Redux's state.\n\n// Go to next tutorial: 11_Provider-and-connect.js\n"
        },
        {
          "name": "11_Provider-and-connect.js",
          "type": "blob",
          "size": 1.8681640625,
          "content": "// Tutorial 11 - Provider-and-connect.js\n\n// This is the final tutorial and the one that will show you how to bind together Redux and React.\n\n// To run this example, you will need a browser.\n\n// All explanations for this example are inlined in the sources inside ./11_src/src/.\n\n// Once you've read the lines below, start with 11_src/src/server.js.\n\n// To build our React application and serve it to a browser, we'll use:\n// - A very simple node HTTP server (https://nodejs.org/api/http.html)\n// - The awesome Webpack (http://webpack.github.io/) to bundle our application,\n// - The magic Webpack Dev Server (http://webpack.github.io/docs/webpack-dev-server.html)\n//     to serve JS files from a dedicated node server that allows for files watch\n// - The incredible React Hot Loader http://gaearon.github.io/react-hot-loader/ (another awesome\n//     project of Dan Abramov - just in case, he is Redux's author) to have a crazy\n//     DX (Developer experience) by having our components live-reload in the browser\n//     while we're tweaking them in our code editor.\n\n// An important point for those of you who are already using React: this application is built\n// upon React 0.14.\n\n// I won't detail Webpack Dev Server and React Hot Loader setup here since it's done pretty\n// well in React Hot Loader's docs.\nimport webpackDevServer from './11_src/src/webpack-dev-server'\n// We request the main server of our app to start it from this file.\nimport server from './11_src/src/server'\n\n// Change the port below if port 5050 is already in use for you.\n// if port equals X, we'll use X for server's port and X+1 for webpack-dev-server's port\nconst port = 5050\n\n// Start our Webpack dev server...\nwebpackDevServer.listen(port)\n// ... and our main app server.\nserver.listen(port)\n\nconsole.log(`Server is listening on http://127.0.0.1:${port}`)\n\n// Go to 11_src/src/server.js...\n\n// Go to next tutorial: 12_final-words.js\n"
        },
        {
          "name": "11_src",
          "type": "tree",
          "content": null
        },
        {
          "name": "12_final-words.js",
          "type": "blob",
          "size": 0.701171875,
          "content": "// Tutorial 12 - final-words.js\n\n// There is actually more to Redux and react-redux than what we showed you with this tutorial. For example,\n// concerning Redux, you may be interested in bindActionCreators (to produce a hash of action creators\n// already bound to dispatch - http://redux.js.org/docs/api/bindActionCreators.html).\n\n// We hope we've given you the keys to better understand Flux and to see more clearly\n// how Flux implementations differ from one another - especially how Redux stands out ;).\n\n// Where to go from here?\n\n// The official Redux documentation is really awesome and exhaustive so you should not hesitate to\n// refer to it from now on: http://redux.js.org/\n\n// Have fun with React and Redux!\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.25390625,
          "content": "redux-tutorial\n=========================\n\nThis repository contains a step by step tutorial to help grasp flux and more specifically [Redux](https://github.com/reactjs/redux).\n\nThe official and very exhaustive Redux documentation is available [here](http://redux.js.org/) and should be your number one source of truth regarding Redux. The present tutorial will only offer you an introduction to flux concepts through Redux use. For further or more detailed info, please refer to the Redux documentation.\n\n### Prerequisites\nIt is required for you to know a bit of ES6 and ES7 (Object Spread) to correctly understand some of the examples given in this repo. Also be aware that this tutorial targets redux 3.0.2 and react-redux 4.0.0.\n\n### Clone the repository\n`git clone https://github.com/happypoulp/redux-tutorial.git`\n\n### Move into repository\n`cd redux-tutorial`\n\n### Install dependencies\n`npm install`\n\n### Browse the tutorial\n\nThis tutorial is split into a sequence of javascript files that are intended to be read in order. \n\nStart with the first tutorial: [Introduction](00_introduction.js)\n\n### Run an example\n\nBeing real js files, each example can be run to verify that it works as intended or to do your own experiments:\n\n`npm run example 01_simple-action-creator.js`\n\nEnjoy!\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.9228515625,
          "content": "{\n  \"name\": \"redux-tutorial\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Learn how to use redux step by step\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/happypoulp/redux-tutorial.git\"\n  },\n  \"scripts\": {\n    \"example\": \"babel-node\"\n  },\n  \"author\": \"François Bonnefont\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"babel\": \"5.3.1\",\n    \"babel-core\": \"^5.6.15\",\n    \"babel-loader\": \"^5.2.2\",\n    \"bluebird\": \"^2.9.34\",\n    \"css-loader\": \"^0.15.1\",\n    \"file-loader\": \"^0.8.4\",\n    \"node-libs-browser\": \"^0.5.2\",\n    \"react\": \"0.14.2\",\n    \"react-dom\": \"0.14.2\",\n    \"react-redux\": \"4.0.0\",\n    \"redux\": \"v3.0.2\",\n    \"redux-thunk\": \"^0.1.0\",\n    \"style-loader\": \"^0.12.3\",\n    \"url-loader\": \"^0.5.6\",\n    \"webpack\": \"^1.10.0\"\n  },\n  \"devDependencies\": {\n    \"react-hot-loader\": \"^1.2.7\",\n    \"eslint\": \"^1.10.3\",\n    \"babel-eslint\": \"^3.1.9\",\n    \"eslint-plugin-react\": \"^2.3.0\",\n    \"webpack-dev-server\": \"^1.8.2\"\n  }\n}\n"
        }
      ]
    }
  ]
}