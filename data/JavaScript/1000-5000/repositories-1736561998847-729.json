{
  "metadata": {
    "timestamp": 1736561998847,
    "page": 729,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjczMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "binux/qiandao",
      "stars": 3417,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0458984375,
          "content": "*.idea\n*.pyc\ndatabase.db\nmysql\nlocal_config.py\n"
        },
        {
          "name": "Procfile",
          "type": "blob",
          "size": 0.0185546875,
          "content": "web: python run.py\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.8974609375,
          "content": "qiandao\n=======\n\n签到 —— 一个自动签到框架 base on an HAR editor\n\nHAR editor 使用指南：https://github.com/binux/qiandao/blob/master/docs/har-howto.md\n\n## 相关项目\n[qiandao-today/qiandao](https://github.com/qiandao-today/qiandao): 基于本项目发布的新版框架地址, 现由 [@a76yyyy](https://github.com/a76yyyy) 更新维护中\n> 支持旧版数据库直接迁移，请提前做好数据库备份\n\nWeb\n===\n\n需要 python3.11, 虚拟主机无法安装\n\n```\npip install -r requirements.txt\n```\n\n可选 redis, Mysql\n\n```\nmysql < qiandao.sql\n```\n\n启动\n\n```\n./run.py\n```\n\n数据不随项目分发，去 [https://qiandao.today/tpls/public](https://qiandao.today/tpls/public) 查看你需要的模板，点击下载。\n在你自己的主页中 「我的模板+」 点击 + 上传。模板需要发布才会在「公开模板」中展示，你需要管理员权限在「我的发布请求」中审批通过。\n\n\n设置管理员\n\n```\n./chrole.py your@email.address admin\n```\n\n使用Docker部署站点\n==========\n\n可参考 Wiki [Docker部署签到站教程](https://github.com/binux/qiandao/wiki/Docker%E9%83%A8%E7%BD%B2%E7%AD%BE%E5%88%B0%E7%AB%99%E6%95%99%E7%A8%8B)\n\nqiandao.py\n==========\n\n```\npip install -r requirements.txt\n./qiandao.py tpl.har [--key=value]* [env.json]\n```\n\nconfig.py\n=========\n优先用`mailgun`方式发送邮件，如果要用smtp方式发送邮件，请填写mail_smtp, mail_port, mail_ssl, mail_user, mail_password\n```python\nmail_smtp = \"\"      # 邮件smtp地址\nmail_port = 465     # 邮件smtp端口，非SSL默认端口为25\nmail_ssl = True     # 邮件smtp是否使用SSL\nmail_user = \"\"      # 邮件smtp账户\nmail_passowrd = \"\"  # 邮件smtp密码\nmail_domain = \"mail.qiandao.today\"\nmailgun_key = \"\"\n```\n\n鸣谢\n====\n\n+[雪月秋水](https://plus.google.com/u/0/+%E9%9B%AA%E6%9C%88%E7%A7%8B%E6%B0%B4%E9%85%B1) [GetCookies项目](https://github.com/acgotaku/GetCookies)\n\n许可\n====\n\nMIT\n"
        },
        {
          "name": "chrole.py",
          "type": "blob",
          "size": 0.712890625,
          "content": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright © 2017 Binux <roy@binux.me>\n#\n# Distributed under terms of the MIT license.\n\n\"\"\"\nchange the role of user\n\"\"\"\n\nimport sys\nimport config\nif config.db_type == 'sqlite3':\n    import sqlite3_db as db\nelse:\n    import db\nuserdb = db.UserDB()\n\nif not 2 <= len(sys.argv) <= 3:\n    print \"Usage: %s email [role]\" % sys.argv[0]\n    sys.exit(1)\nelse:\n    email = sys.argv[1]\n    role = sys.argv[2] if len(sys.argv) == 3 else ''\n\n    user = userdb.get(email=email, fields=['id'])\n    if not user:\n        print \"Cannot find user: \", email\n        sys.exit(1)\n    userdb.mod(user['id'], role=role)\n    print \"role of %s changed to %s\" % (email, role or '[empty]')\n"
        },
        {
          "name": "config.py",
          "type": "blob",
          "size": 1.6181640625,
          "content": "#!/usr/bin/env python\n# -*- encoding: utf-8 -*-\n# vim: set et sw=4 ts=4 sts=4 ff=unix fenc=utf8:\n# Author: Binux<i@binux.me>\n#         http://binux.me\n# Created on 2014-07-30 12:21:48\n\nimport os\nimport hashlib\nfrom urllib.parse import urlparse\n\ndebug = False\ngzip = True\nbind = '0.0.0.0'\nport = int(os.getenv('PORT', 8923))\nhttps = bool(os.getenv('ENABLE_HTTPS', False))\ncookie_days = 5\nmysql_url = urlparse(os.getenv('JAWSDB_MARIA_URL', ''))\nredis_url = urlparse(os.getenv('REDISCLOUD_URL', ''))\n\nclass mysql(object):\n    host = mysql_url.hostname or 'localhost'\n    port = mysql_url.port or '3306'\n    database = mysql_url.path[1:] or 'qiandao'\n    user = mysql_url.username or 'qiandao'\n    passwd = mysql_url.password or None\n\nclass sqlite3(object):\n    path = './database.db'\n\n# 数据库类型，修改 sqlite3 为 mysql 使用 mysql\ndb_type = os.getenv('DB_TYPE', 'sqlite3')\n\n# redis 连接参数，可选\nclass redis(object):\n    host = redis_url.hostname or 'localhost'\n    port = redis_url.port or 6379\n    passwd = redis_url.password or None\n    db = int(os.getenv('REDIS_DB_INDEX', 1))\nevil = 100\n\npbkdf2_iterations = 400\naes_key = hashlib.sha256(os.getenv('AES_KEY', b'binux')).digest()\ncookie_secret = hashlib.sha256(os.getenv('COOKIE_SECRET', b'binux')).digest()\ncheck_task_loop = 10000\ndownload_size_limit = 1*1024*1024\nproxies = []\n\n# 域名\ndomain = 'qiandao.today'\n\n# mailgun 邮件发送, 域名和 apikey\nmail_smtp = \"\"\nmail_port = 465\nmail_ssl = True\nmail_user = \"\"\nmail_password = \"\"\nmail_domain = \"mail.qiandao.today\"\nmailgun_key = \"\"\n\n# google analytics\nga_key = \"\"\n\ntry:\n    from local_config import *\nexcept ImportError:\n    pass\n"
        },
        {
          "name": "database.mwb",
          "type": "blob",
          "size": 13.8388671875,
          "content": null
        },
        {
          "name": "db",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "libs",
          "type": "tree",
          "content": null
        },
        {
          "name": "qiandao.py",
          "type": "blob",
          "size": 1.6943359375,
          "content": "#!/usr/bin/env python\n# -*- encoding: utf-8 -*-\n# vim: set et sw=4 ts=4 sts=4 ff=unix fenc=utf8:\n# Author: Binux<i@binux.me>\n#         http://binux.me\n# Created on 2014-08-18 12:17:21\n\nimport sys\nimport json\nimport logging\nimport functools\nfrom tornado.ioloop import IOLoop\nfrom libs.fetcher import Fetcher\n\ndef usage():\n    print \"%s tpl.har [--key=value] [env.json]\" % sys.argv[0]\n    sys.exit(1)\n\nif __name__ == '__main__':\n    if len(sys.argv) < 3:\n        usage()\n\n    # load tpl\n    tpl_file = sys.argv[1]\n    try:\n        tpl = json.load(open(tpl_file))\n    except Exception as e:\n        logging.error(e)\n        usage()\n\n    # load env\n    variables = {}\n    env = {}\n    env_file = None\n    for each in sys.argv[2:]:\n        if each.startswith('--'):\n            key, value = each.split('=', 1)\n            key = key.lstrip('--')\n            variables[key] = value\n        else:\n            env_file = each\n    if env_file:\n        try:\n            env = json.load(open(env_file))\n        except Exception as e:\n            logging.error(e)\n            usage()\n    if 'variables' not in env or not isinstance(env['variables'], dict)\\\n            or 'session' not in env:\n        env = {\n                'variables': env,\n                'session': [],\n                }\n    env['variables'].update(variables)\n\n    # do fetch\n    ioloop = IOLoop.instance()\n    def ioloop_stop(x):\n        ioloop.stop()\n\n    fetcher = Fetcher()\n    result = fetcher.do_fetch(tpl, env)\n    ioloop.add_future(result, ioloop_stop)\n    ioloop.start()\n\n    try:\n        result = result.result()\n    except Exception as e:\n        print 'qiandao failed!', e\n    else:\n        print 'qiandao success!', result.get('variables', {}).get('__log__', '')\n"
        },
        {
          "name": "qiandao.sql",
          "type": "blob",
          "size": 4.7197265625,
          "content": "-- MySQL Script generated by MySQL Workbench\n-- Fri Aug 15 23:00:30 2014\n-- Model: New Model    Version: 1.0\nSET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;\nSET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;\nSET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';\n\n-- -----------------------------------------------------\n-- Schema qiandao\n-- -----------------------------------------------------\nCREATE SCHEMA IF NOT EXISTS `qiandao` DEFAULT CHARACTER SET utf8 ;\nUSE `qiandao` ;\n\n-- -----------------------------------------------------\n-- Table `qiandao`.`user`\n-- -----------------------------------------------------\nCREATE TABLE IF NOT EXISTS `qiandao`.`user` (\n  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  `email` VARCHAR(256) CHARACTER SET 'utf8' NOT NULL,\n  `email_verified` TINYINT(1) NOT NULL DEFAULT 0,\n  `password` VARBINARY(128) NOT NULL,\n  `userkey` VARBINARY(128) NOT NULL,\n  `nickname` VARCHAR(64) NULL,\n  `role` VARCHAR(128) NULL,\n  `ctime` INT UNSIGNED NOT NULL,\n  `mtime` INT UNSIGNED NOT NULL,\n  `atime` INT UNSIGNED NOT NULL,\n  `cip` INT UNSIGNED NOT NULL,\n  `mip` INT UNSIGNED NOT NULL,\n  `aip` INT UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE INDEX `email_UNIQUE` (`email` ASC),\n  UNIQUE INDEX `nickname_UNIQUE` (`nickname` ASC))\nENGINE = MyISAM\nDEFAULT CHARACTER SET = utf8;\n\n\n-- -----------------------------------------------------\n-- Table `qiandao`.`tpl`\n-- -----------------------------------------------------\nCREATE TABLE IF NOT EXISTS `qiandao`.`tpl` (\n  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  `userid` INT UNSIGNED NULL,\n  `siteurl` VARCHAR(256) NULL,\n  `sitename` VARCHAR(128) NULL,\n  `banner` VARCHAR(1024) NULL,\n  `disabled` TINYINT(1) NOT NULL DEFAULT 0,\n  `public` TINYINT(1) NOT NULL DEFAULT 0,\n  `lock` TINYINT(1) NOT NULL DEFAULT 0,\n  `fork` INT UNSIGNED NULL,\n  `har` MEDIUMBLOB NULL,\n  `tpl` MEDIUMBLOB NULL,\n  `variables` TEXT NULL,\n  `interval` INT UNSIGNED NULL,\n  `note` VARCHAR(1024) NULL,\n  `success_count` INT UNSIGNED NOT NULL DEFAULT 0,\n  `failed_count` INT UNSIGNED NOT NULL DEFAULT 0,\n  `last_success` INT UNSIGNED NULL,\n  `ctime` INT UNSIGNED NOT NULL,\n  `mtime` INT UNSIGNED NOT NULL,\n  `atime` INT UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`),\n  INDEX `ix_siteurl` (`siteurl` ASC),\n  INDEX `ix_sitename` (`sitename` ASC),\n  INDEX `ix_public` (`public` ASC),\n  INDEX `ix_userid` (`userid`))\nENGINE = MyISAM\nDEFAULT CHARACTER SET = utf8;\n\n\n-- -----------------------------------------------------\n-- Table `qiandao`.`task`\n-- -----------------------------------------------------\nCREATE TABLE IF NOT EXISTS `qiandao`.`task` (\n  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  `tplid` INT UNSIGNED NOT NULL,\n  `userid` INT UNSIGNED NOT NULL,\n  `disabled` TINYINT(1) NOT NULL DEFAULT 0,\n  `init_env` BLOB NULL,\n  `env` BLOB NULL,\n  `session` BLOB NULL,\n  `last_success` INT UNSIGNED NULL,\n  `last_failed` INT UNSIGNED NULL,\n  `success_count` INT UNSIGNED NOT NULL DEFAULT 0,\n  `failed_count` INT UNSIGNED NOT NULL DEFAULT 0,\n  `last_failed_count` INT UNSIGNED NOT NULL DEFAULT 0,\n  `next` INT UNSIGNED NULL DEFAULT NULL,\n  `note` VARCHAR(256) NULL,\n  `ctime` INT UNSIGNED NOT NULL,\n  `mtime` INT UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`),\n  INDEX `ix_userid` (`userid` ASC),\n  INDEX `ix_tplid` (`tplid` ASC))\nENGINE = MyISAM\nDEFAULT CHARACTER SET = utf8\nCOLLATE = utf8_general_ci;\n\n\n-- -----------------------------------------------------\n-- Table `qiandao`.`tasklog`\n-- -----------------------------------------------------\nCREATE TABLE IF NOT EXISTS `qiandao`.`tasklog` (\n  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  `taskid` INT UNSIGNED NOT NULL,\n  `success` TINYINT(1) NOT NULL,\n  `ctime` INT UNSIGNED NOT NULL,\n  `msg` TEXT NULL,\n  PRIMARY KEY (`id`),\n  INDEX `ix_taskid` (`taskid`, `ctime` DESC))\nENGINE = MyISAM;\n\n\n-- -----------------------------------------------------\n-- Table `qiandao`.`push_request`\n-- -----------------------------------------------------\nCREATE TABLE IF NOT EXISTS `qiandao`.`push_request` (\n  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  `from_tplid` INT UNSIGNED NOT NULL,\n  `from_userid` INT UNSIGNED NOT NULL,\n  `to_tplid` INT UNSIGNED NULL,\n  `to_userid` INT UNSIGNED NULL,\n  `status` TINYINT NOT NULL DEFAULT 0,\n  `msg` VARCHAR(1024) NULL,\n  `ctime` INT UNSIGNED NOT NULL,\n  `mtime` INT UNSIGNED NOT NULL,\n  `atime` INT UNSIGNED NOT NULL,\n  PRIMARY KEY (`id`),\n  INDEX `ix_userid` (`to_userid` ASC),\n  INDEX `ix_status` (`status` ASC))\nENGINE = MyISAM;\n\nCREATE USER 'qiandao';\n\nGRANT SELECT, INSERT, TRIGGER ON TABLE `qiandao`.* TO 'qiandao';\nGRANT SELECT ON TABLE `qiandao`.* TO 'qiandao';\nGRANT SELECT, INSERT, TRIGGER, UPDATE, DELETE ON TABLE `qiandao`.* TO 'qiandao';\n\nSET SQL_MODE=@OLD_SQL_MODE;\nSET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;\nSET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.099609375,
          "content": "tornado\nu-msgpack-python\njinja2\nchardet\nrequests\nmysql-connector-python\nredis\npbkdf2\npycryptodome\nsix\n"
        },
        {
          "name": "run.py",
          "type": "blob",
          "size": 1.296875,
          "content": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright © 2016 Binux <roy@binux.me>\n\nimport sys\nimport logging\nimport tornado.log\nfrom tornado.ioloop import IOLoop, PeriodicCallback\nfrom tornado.httpserver import HTTPServer\n\nimport config\nfrom web.app import Application\nfrom worker import MainWorker\n\nif __name__ == \"__main__\":\n    # init logging\n    logger = logging.getLogger()\n    logger.setLevel(logging.DEBUG if config.debug else logging.INFO)\n    channel = logging.StreamHandler(sys.stdout)\n    channel.setFormatter(tornado.log.LogFormatter())\n    logger.addHandler(channel)\n\n    if not config.debug:\n        channel = logging.StreamHandler(sys.stderr)\n        channel.setFormatter(tornado.log.LogFormatter())\n        channel.setLevel(logging.WARNING)\n        logger.addHandler(channel)\n\n    if len(sys.argv) > 2 and sys.argv[1] == '-p' and sys.argv[2].isdigit():\n        port = int(sys.argv[2])\n    else:\n        port = config.port\n\n    http_server = HTTPServer(Application(), xheaders=True)\n    http_server.bind(port, config.bind)\n    http_server.start()\n\n    worker = MainWorker()\n    io_loop = IOLoop.instance()\n    PeriodicCallback(worker, config.check_task_loop, io_loop).start()\n    worker()\n\n    logging.info(\"http server started on %s:%s\", config.bind, port)\n    IOLoop.instance().start()\n"
        },
        {
          "name": "sqlite3_db",
          "type": "tree",
          "content": null
        },
        {
          "name": "web.py",
          "type": "blob",
          "size": 1.1865234375,
          "content": "#!/usr/bin/env python\n# -*- encoding: utf-8 -*-\n# vim: set et sw=4 ts=4 sts=4 ff=unix fenc=utf8:\n# Author: Binux<i@binux.me>\n#         http://binux.me\n# Created on 2014-07-30 12:38:34\n\nimport sys\nimport logging\nimport tornado.log\nfrom tornado.ioloop import IOLoop\nfrom tornado.httpserver import HTTPServer\n\nimport config\nfrom web.app import Application\n\nif __name__ == \"__main__\":\n    # init logging\n    logger = logging.getLogger()\n    logger.setLevel(logging.DEBUG if config.debug else logging.INFO)\n    channel = logging.StreamHandler(sys.stdout)\n    channel.setFormatter(tornado.log.LogFormatter())\n    logger.addHandler(channel)\n\n    if not config.debug:\n        channel = logging.StreamHandler(sys.stderr)\n        channel.setFormatter(tornado.log.LogFormatter())\n        channel.setLevel(logging.WARNING)\n        logger.addHandler(channel)\n\n    if len(sys.argv) > 2 and sys.argv[1] == '-p' and sys.argv[2].isdigit():\n        port = int(sys.argv[2])\n    else:\n        port = config.port\n\n    http_server = HTTPServer(Application(), xheaders=True)\n    http_server.bind(port, config.bind)\n    http_server.start()\n\n    logging.info(\"http server started on %s:%s\", config.bind, port)\n    IOLoop.instance().start()\n"
        },
        {
          "name": "web",
          "type": "tree",
          "content": null
        },
        {
          "name": "worker.py",
          "type": "blob",
          "size": 9.123046875,
          "content": "#!/usr/bin/env python\n# -*- encoding: utf-8 -*-\n# vim: set et sw=4 ts=4 sts=4 ff=unix fenc=utf8:\n# Author: Binux<i@binux.me>\n#         http://binux.me\n# Created on 2014-08-09 14:43:13\n\nimport time\nimport datetime\nimport logging\nimport tornado.log\nimport tornado.ioloop\nfrom tornado import gen\n\nimport config\nfrom libs import utils\nfrom libs.fetcher import Fetcher\n\nlogger = logging.getLogger('qiandao.worker')\nclass MainWorker(object):\n    def __init__(self):\n        self.running = False\n\n        if config.db_type == 'sqlite3':\n            import sqlite3_db as db\n        else:\n            import db\n\n        class DB(object):\n            user = db.UserDB()\n            tpl = db.TPLDB()\n            task = db.TaskDB()\n            tasklog = db.TaskLogDB()\n        self.db = DB\n        self.fetcher = Fetcher()\n\n    def __call__(self):\n        if self.running:\n            return\n        self.running = self.run()\n        def done(future):\n            self.running = None\n            success, failed = future.result()\n            if success or failed:\n                logger.info('%d task done. %d success, %d failed' % (success+failed, success, failed))\n            return\n        self.running.add_done_callback(done)\n\n    @gen.coroutine\n    def run(self):\n        running = []\n        success = 0\n        failed = 0\n        try:\n            for task in self.scan():\n                running.append(self.do(task))\n                if len(running) > 50:\n                    logging.debug('scaned %d task, waiting...', len(running))\n                    result = yield running[:10]\n                    for each in result:\n                        if each:\n                            success += 1\n                        else:\n                            failed += 1\n                    running = running[10:]\n            logging.debug('scaned %d task, waiting...', len(running))\n            result = yield running\n            for each in result:\n                if each:\n                    success += 1\n                else:\n                    failed += 1\n        except Exception as e:\n            logging.exception(e)\n        raise gen.Return((success, failed))\n\n    scan_fields = ('id', 'tplid', 'userid', 'init_env', 'env', 'session', 'last_success', 'last_failed', 'success_count', 'failed_count', 'last_failed_count', 'next', 'disabled', )\n    def scan(self):\n        return self.db.task.scan(fields=self.scan_fields)\n\n    @staticmethod\n    def failed_count_to_time(last_failed_count, interval=None):\n        if last_failed_count == 0:\n            next = 10 * 60\n        elif last_failed_count == 1:\n            next = 110 * 60\n        elif last_failed_count == 2:\n            next = 240 * 60\n        elif last_failed_count == 3:\n            next = 360 * 60\n        elif last_failed_count < 8:\n            next = 11 * 60 * 60\n        else:\n            next = None\n\n        if interval is None:\n            interval = 24 * 60 * 60\n        if next and next > interval / 2:\n            next = interval / 2\n        return next\n\n    @staticmethod\n    def fix_next_time(next, gmt_offset=-8*60):\n        date = datetime.datetime.utcfromtimestamp(next)\n        local_date = date - datetime.timedelta(minutes=gmt_offset)\n        if local_date.hour < 2:\n            next += 2 * 60 * 60\n        if local_date.hour > 21:\n            next -= 3 * 60 * 60\n        return next\n\n    @staticmethod\n    def is_tommorrow(next, gmt_offset=-8*60):\n        date = datetime.datetime.utcfromtimestamp(next)\n        now = datetime.datetime.utcnow()\n        local_date = date - datetime.timedelta(minutes=gmt_offset)\n        local_now = now - datetime.timedelta(minutes=gmt_offset)\n        local_tomorrow = local_now + datetime.timedelta(hours=24)\n\n        if local_date.day == local_tomorrow.day and not now.hour > 22:\n            return True\n        elif local_date.hour > 22:\n            return True\n        else:\n            return False\n\n    @gen.coroutine\n    def do(self, task):\n        user = self.db.user.get(task['userid'], fields=('id', 'email', 'email_verified', 'nickname'))\n        tpl = self.db.tpl.get(task['tplid'], fields=('id', 'userid', 'sitename', 'siteurl', 'tpl',\n            'interval', 'last_success'))\n\n        if task['disabled']:\n            self.db.tasklog.add(task['id'], False, msg='task disabled.')\n            self.db.task.mod(task['id'], next=None, disabled=1)\n            raise gen.Return(False)\n\n        if not user:\n            self.db.tasklog.add(task['id'], False, msg='no such user, disabled.')\n            self.db.task.mod(task['id'], next=None, disabled=1)\n            raise gen.Return(False)\n\n        if not tpl:\n            self.db.tasklog.add(task['id'], False, msg='tpl missing, task disabled.')\n            self.db.task.mod(task['id'], next=None, disabled=1)\n            raise gen.Return(False)\n\n        if tpl['userid'] and tpl['userid'] != user['id']:\n            self.db.tasklog.add(task['id'], False, msg='no permission error, task disabled.')\n            self.db.task.mod(task['id'], next=None, disabled=1)\n            raise gen.Return(False)\n\n        start = time.time()\n        try:\n            fetch_tpl = self.db.user.decrypt(0 if not tpl['userid'] else task['userid'], tpl['tpl'])\n            env = utils.ensure_dict(dict(\n                    variables = self.db.user.decrypt(task['userid'], task['init_env']),\n                    session = [],\n                    ))\n\n            new_env = yield self.fetcher.do_fetch(fetch_tpl, env)\n\n            variables = self.db.user.encrypt(task['userid'], new_env['variables'])\n            session = self.db.user.encrypt(task['userid'],\n                    new_env['session'].to_json() if hasattr(new_env['session'], 'to_json') else new_env['session'])\n\n            # todo next not mid night\n            next = time.time() + max((tpl['interval'] if tpl['interval'] else 24 * 60 * 60), 30*60)\n            if tpl['interval'] is None:\n                next = self.fix_next_time(next)\n\n            # success feedback\n            self.db.tasklog.add(task['id'], success=True, msg=new_env['variables'].get('__log__'))\n            self.db.task.mod(task['id'],\n                    last_success=time.time(),\n                    last_failed_count=0,\n                    success_count=task['success_count']+1,\n                    env=variables,\n                    session=session,\n                    mtime=time.time(),\n                    next=next)\n            self.db.tpl.incr_success(tpl['id'])\n\n            logger.info('taskid:%d tplid:%d successed! %.4fs', task['id'], task['tplid'], time.time()-start)\n        except Exception as e:\n            # failed feedback\n            next_time_delta = self.failed_count_to_time(task['last_failed_count'], tpl['interval'])\n            if next_time_delta:\n                disabled = False\n                next = time.time() + next_time_delta\n            else:\n                disabled = True\n                next = None\n\n            self.db.tasklog.add(task['id'], success=False, msg=str(e))\n            self.db.task.mod(task['id'],\n                    last_failed=time.time(),\n                    failed_count=task['failed_count']+1,\n                    last_failed_count=task['last_failed_count']+1,\n                    disabled = disabled,\n                    mtime = time.time(),\n                    next=next)\n            self.db.tpl.incr_failed(tpl['id'])\n\n            if task['success_count'] and task['last_failed_count'] and user['email_verified'] and user['email']\\\n                    and self.is_tommorrow(next):\n                try:\n                    _ = yield utils.send_mail(to=user['email'], subject=u\"%s - 签到失败%s\" % (\n                        tpl['sitename'], u' 已停止' if disabled else u\"\"),\n                    text=u\"\"\"\n您的 %(sitename)s [ %(siteurl)s ] 签到任务，执行 %(cnt)d次 失败。%(disable)s\n\n下一次重试在一天之后，为防止签到中断，给您发送这份邮件。\n\n访问： http://%(domain)s/task/%(taskid)s/log 查看日志。\n                    \"\"\" % dict(\n                        sitename=tpl['sitename'] or u'未命名',\n                        siteurl=tpl['siteurl'] or u'',\n                        cnt=task['last_failed_count'] + 1,\n                        disable=u\"因连续多次失败，已停止。\" if disabled else u\"\",\n                        domain=config.domain,\n                        taskid=task['id'],\n                        ), async_mode=True)\n                except Exception as e:\n                    logging.error('send mail error: %r', e)\n\n            logger.error('taskid:%d tplid:%d failed! %r %.4fs', task['id'], task['tplid'], e, time.time()-start)\n            raise gen.Return(False)\n        raise gen.Return(True)\n\n    def task_failed(self, task, user, tpl, e):\n        pass\n        #if user['email'] and user['email_verified']:\n            #return utils.send_mail(to=user['email'],\n                    #subject=u\"%s - 签到失败提醒\" % (tpl['sitename']),\n                    #text=u\"\"\"\n                    #您在 签到.today ( http://qiandao.today )\n                    #\"\"\")\n\nif __name__ == '__main__':\n    tornado.log.enable_pretty_logging()\n    worker = MainWorker()\n    io_loop = tornado.ioloop.IOLoop.instance()\n    tornado.ioloop.PeriodicCallback(worker, config.check_task_loop).start()\n    worker()\n    io_loop.start()\n"
        }
      ]
    }
  ]
}