{
  "metadata": {
    "timestamp": 1736561542715,
    "page": 77,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cjb/GitTorrent",
      "stars": 4751,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.013671875,
          "content": "node_modules/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.4150390625,
          "content": "# GitTorrent is an OPEN Open Source Project\n\nIndividuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.\n\n## Rules\n\nThere are a few basic ground-rules for contributors:\n\n1. **No `--force` pushes** or modifying the Git history in any way.\n1. **External API changes and significant modifications** should be subject to a **pull request** to solicit feedback from other contributors.\n1. Pull requests to solicit feedback are *encouraged* for any other non-trivial contribution but left to the discretion of the contributor.\n1. Use a non-`master` branch for ongoing work.\n1. Contributors should attempt to adhere to the prevailing code style.\n1. Run `npm test` locally before submitting your PR to catch easy-to-miss style & testing issues\n\n## Releases\n\nDeclaring formal releases remains the prerogative of the project maintainer.\n\n## Changes to this arrangement\n\nThis is an experiment and feedback is welcome! This document is subject to pull requests or changes by contributors where you believe you have something valuable to add or change.\n\n*Thanks to [Rod Vagg](https://github.com/rvagg) and the [LevelUP](https://github.com/rvagg/node-levelup) project for coming up with this model of open source contribution, and to [Feross Aboukhadijeh](https://github.com/feross) for writing this document.*\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0478515625,
          "content": "The MIT License (MIT)\n\nCopyright (c) Chris Ball \n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.26953125,
          "content": "# [GitTorrent](http://gittorrent.org)\n\n### The Decentralization of GitHub\n\n**GitTorrent** is a peer-to-peer network of Git repositories being shared over BitTorrent. You can read more about the project at [this blog post](http://blog.printf.net/articles/2015/05/29/announcing-gittorrent-a-decentralized-github/).\n\nTo get started:\n```\nsudo npm install --global gittorrent\n```\n(You can avoid `sudo` if you place the gittorrent binaries in your `$PATH`.)\n\nAfter that, you can clone a repo with:\n```\ngit clone gittorrent://github.com/someuser/somerepo\n```\nOr serve your own repos with:\n```\ntouch somerepo/.git/git-daemon-export-ok\ngittorrentd\n```\n\nNote that GitTorrent is not affiliated with the [git project](http://git-scm.com/).\n\n# Design\n\nThe design of GitTorrent has five components:  \n\n1. A \"git transport helper\" that knows how to download and unpack git objects, and can be used by Git itself to perform a fetch/clone/push.  \n1. A distributed hash table that advertises which git commits a node is willing to serve.  \n1. A BitTorrent protocol extension that negotiates sending a packfile with needed objects to a peer  \n1. A key/value store on the distributed hash table, used as a \"user profile\" describing a user's repositories and their latest git hashes.  \n1. A method for registering friendly usernames on Bitcoin's blockchain, so that a written username can be used to find a user instead of an ugly hex string.\n\n## 1. Git Transport Helper\n\nWhen Git is asked to perform a network operation with a URL that starts with e.g. `someprotocol://`, it calls `git-remote-someprotocol` and passes the URL as an argument.  The remote helper binary is responsible for telling Git what capabilities it has, receiving commands from Git, and downloading objects into the `.git/` directory.\n\nIn GitTorrent's case, we could be asked for three styles of URL:\n* `gittorrent://some.git.hosting.site/somerepo` -- we connect over `git://` to find out what the latest commit is, then perform the download using that commit's sha1.  This is kind of like a [CDN](CDN) for a git server; the actual download of objects happens via peers, but the lookup of which objects to download happens in the normal Git way.\n* `gittorrent://<hex sha1>/reponame` -- the sha1 corresponds to a gittorrent user's \"mutable key\" (hash of their public key) on our DHT -- we look up the key, receive JSON describing the user's repositories, and then perform the download using that commit's sha1.  This doesn't use any resources outside of GitTorrent's network.\n* `gittorrent://<username>` -- the username is converted into a mutable key sha1 as above.  The mapping from usernames to sha1s happens on Bitcoin's blockchain in an OP_RETURN transaction.\n\n## 2. Distributed hash table\n\nThe bootstrap server for this DHT runs at `core.gittorrent.org:6881`.  It is a bittorrent mainline DHT.  Git SHA1s are announced by nodes who can create packfiles for them.  The clients on this DHT support dht-store (BEP 44) and use it to store mutable keys.\n\n## 3. Protocol extension\n\nOnce a client has connected to another node, it sends a request for the SHA1 it's looking for as bencoded JSON:\n```\n{gittorrent: ask: \"sha1\"}\n```\nThe node providing the packfile returns:\n```\n{gittorrent: sendTorrent: \"infoHash\"}\n```\n\n## 4. Key/value store\nBEP 44 adds support for *mutable* and *immutable* keys.  Immutable keys are addressed by the hash of their content, but mutable keys are addressed by the hash of a crypto keypair's public key.  The owner of that keypair publishes signed updates to their public key's hash, with a sequence number to ensure the latest value is always propagated by peers.  The hash of the public key here is a GitTorrent user ID, and the value associated with that key is a JSON object describing the user's repositories in a User Profile.\n\n### User Profile JSON format\n* name (string)\n* email (string)\n* repositories (array)\n  * name (string)\n  * refs (array)\n    * name (string)\n    * sha1 (string)\n\n### Mutable key file JSON format\n* pub (string)\n* priv (string)\n\n## Bitcoin username registration\n\n*This feature is not going to work on the live Bitcoin network until the OP_RETURN length is increased from 40 to 80 bytes, which will happen in Bitcoin Core v0.11, currently scheduled for release on July 1 2015.  Until then, we'll use the Bitcoin testnet, but username registrations will be discarded when the move to the live network happens.*\n\nOur DHT can't resolve arguments over which mutable key owns a given username -- we need something capable of distributed consensus (like a blockchain) for that.\n\nThe idea of using OP_RETURN comes from telehash's blockname project, but while blockname registers domain names on the blockchain, we're registering username<->key mappings instead.  The format is:\n```\n@service!username!key\n```\ne.g.\n```\n@gittorrent!cjb!81e24205d4bac8496d3e13282c90ead5045f09ea\n```\n\nNote that OP_RETURN transactions are limited to 80 bytes, which limits usernames in this scheme to 27 bytes.\n\nAs a convenience, this repository will include a database of registered usernames that is updated regularly.  This doesn't make GitTorrent any more centralized -- you can run the same scripts yourself on a downloaded blockchain to make sure that this repository does not lie.  This is just to save everyone from downloading tens of gigabytes of blockchain to process.\n\nBy the way, storing full Bitcoin history is not necessary.  We just need to scan every transaction once, and can discard each transaction after we've scanned it once and determined whether it contained a valid username registration that we record.  We just need to scan through all unprocessed blockchain transactions once, and record where we got up to so that we don't have to look at them again after that.\n\n## Contributing\n\nPlease send pull requests!  Even changes to the design of GitTorrent are welcome and encouraged; nothing is set in stone.\n\n#### JavaScript Standard Style\n\nGitTorrent uses [JavaScript Standard Style](https://github.com/feross/standard).\n\n[![js-standard-style](https://raw.githubusercontent.com/feross/standard/master/badge.png)](https://github.com/feross/standard)\n\n#### Enable debug logs\n\nIn **node**, enable debug logs by setting the `DEBUG` environment variable to the name of the\nmodule you want to debug (e.g. `bittorrent-protocol`, or `*` to print **all logs**).\n\n### License\n\nMIT. Copyright (c) [Chris Ball](http://printf.net).\n"
        },
        {
          "name": "config.js",
          "type": "blob",
          "size": 0.2080078125,
          "content": "module.exports = require('rc')('gittorrent', {\n  dht: {\n    bootstrap: [\n      'dht.gittorrent.org:6881',\n      'core.gittorrent.org:6881'\n    ],\n    listen: 6881,\n    announce: 30000\n  },\n  key: 'ed25519.key'\n})\n"
        },
        {
          "name": "git-remote-gittorrent",
          "type": "blob",
          "size": 5.734375,
          "content": "#!/usr/bin/env node\n\nvar Chalk = require('chalk')\nvar DHT = require('bittorrent-dht')\nvar exec = require('child_process').exec\nvar hat = require('hat')\nvar magnet = require('magnet-uri')\nvar prettyjson = require('prettyjson')\nvar spawn = require('child_process').spawn\nvar Swarm = require('bittorrent-swarm')\nvar ut_gittorrent = require('ut_gittorrent')\nvar WebTorrent = require('webtorrent')\nvar zeroFill = require('zero-fill')\nvar config = require('./config')\nvar git = require('./git')\n\n// BitTorrent client version string (used in peer ID).\n// Generated from package.json major and minor version. For example:\n//   '0.16.1' -> '0016'\n//   '1.2.5' -> '0102'\n//\nvar VERSION = require('./package.json').version\n  .match(/([0-9]+)/g).slice(0, 2).map(zeroFill(2)).join('')\n\nfunction die (error) {\n  console.error(error)\n  process.exit(1)\n}\n\n// Gotta enable color manually because stdout isn't a tty.\nvar chalk = new Chalk.constructor({enabled: true});\n\nvar dht = new DHT({\n  bootstrap: config.dht.bootstrap\n})\n\n// After building a dictionary of references (sha's to branch names), responds\n// to git's \"list\" and \"fetch\" commands.\nfunction talk_to_git (refs) {\n  process.stdin.setEncoding('utf8')\n  var didFetch = false\n  process.stdin.on('readable', function () {\n    var chunk = process.stdin.read()\n    if (chunk === 'capabilities\\n') {\n      process.stdout.write('fetch\\n\\n')\n    } else if (chunk === 'list\\n') {\n      Object.keys(refs).forEach(function (branch, i) {\n        process.stdout.write(refs[branch] + ' ' + branch + '\\n')\n      })\n      process.stdout.write('\\n')\n    } else if (chunk && chunk.search(/^fetch/) !== -1) {\n      didFetch = true\n      chunk.split(/\\n/).forEach(function (line) {\n        if (line === '') {\n          return\n        }\n        // Format: \"fetch sha branch\"\n        line = line.split(/\\s/)\n        get_infohash(line[1], line[2])\n      })\n    } else if (chunk && chunk !== '' && chunk !== '\\n') {\n      console.warn('unhandled command: \"' + chunk + '\"')\n    }\n    if (chunk === '\\n') {\n      process.stdout.write('\\n')\n      if (!didFetch) {\n        // If git already has all the refs it needs, we should exit now.\n        process.exit()\n      }\n      return\n    }\n  })\n  process.stdout.on('error', function () {\n    // stdout was closed\n  })\n}\n\nvar remotename = process.argv[2]\nvar url = process.argv[3]\nvar matches = url.match(/gittorrent:\\/\\/([a-f0-9]{40})\\/(.*)/)\nvar refs = {}  // Maps branch names to sha's.\nif (matches) {\n  var key = matches[1]\n  var reponame = matches[2]\n  if (remotename.search(/^gittorrent:\\/\\//) !== -1) {\n    remotename = key\n  }\n  dht.on('ready', function () {\n    var val = new Buffer(key, 'hex')\n    dht.get(val, function (err, res) {\n      if (err) {\n        return console.error(err)\n      }\n      var json = res.v.toString()\n      var repos = JSON.parse(json)\n      console.warn('\\nMutable key ' + chalk.green(key) + ' returned:\\n' +\n                   prettyjson.render(repos, {keysColor: 'yellow', valuesColor: 'green'}) + '\\n')\n      talk_to_git(repos.repositories[reponame])\n    })\n  })\n} else {\n  url = url.replace(/^gittorrent:/i, 'git:')\n  var ls = git.ls(url, function (sha, branch) {\n    refs[branch] = sha\n  })\n  ls.on('exit', function (err) {\n    if (err) {\n      die(err)\n    }\n    dht.on('ready', function () {\n      talk_to_git(refs)\n    })\n  })\n}\n\nvar fetching = {}  // Maps shas -> {got: <bool>, swarm, branches: [...]}\nvar todo = 0     // The number of sha's we have yet to fetch. We will not exit\n                 // until this equals zero.\ndht.on('peer', function (addr, hash, from) {\n  var goal = fetching[hash]\n  if (!goal.peer) {\n    todo++\n    goal.peer = true\n  }\n  goal.swarm.addPeer(addr)\n})\n\nfunction get_infohash (sha, branch) {\n  branch = branch.replace(/^refs\\/(heads\\/)?/, '')\n  branch = branch.replace(/\\/head$/, '')\n\n  // We use console.warn (stderr) because git ignores our writes to stdout.\n  console.warn('Okay, we want to get ' + chalk.yellow(branch) + ': ' +\n               chalk.green(sha))\n\n  if (sha in fetching) {\n    fetching[sha].branches.push(branch)\n    // Prevent starting a redundant lookup\n    return\n  }\n\n  var info = {got: false, peer: false, swarm: null, branches: [branch]}\n  fetching[sha] = info\n\n  var magnetUri = 'magnet:?xt=urn:btih:' + sha\n  var parsed = magnet(magnetUri)\n  dht.lookup(parsed.infoHash)\n\n  var peerId = new Buffer('-WW' + VERSION + '-' + hat(48), 'utf8')\n  info.swarm = new Swarm(parsed.infoHash, peerId)\n  info.swarm.on('wire', function (wire, addr) {\n    console.warn('\\nAdding swarm peer: ' + chalk.green(addr) + ' for ' +\n                 chalk.green(parsed.infoHash))\n    wire.use(ut_gittorrent())\n    wire.ut_gittorrent.on('handshake', function () {\n      wire.ut_gittorrent.ask(parsed.infoHash)\n    })\n    wire.ut_gittorrent.on('receivedTorrent', function (infoHash) {\n      var client = new WebTorrent({\n        dht: {\n          bootstrap: config.dht.bootstrap\n        },\n        tracker: false\n      })\n      client.download(infoHash, function (torrent) {\n        console.warn('Downloading ' + chalk.green(torrent.files[0].path) +\n                     ' with infohash: ' + chalk.green(infoHash) + '\\n')\n        torrent.on('done', function (done) {\n          console.warn('done downloading: ' + chalk.green(torrent.files[0].path))\n          fetching[sha].got = true\n\n          var stream = torrent.files[0].createReadStream()\n          var unpack = spawn('git', ['index-pack', '--stdin', '-v', '--fix-thin'])\n          stream.pipe(unpack.stdin)\n          unpack.stderr.pipe(process.stderr)\n          unpack.on('exit', function (code) {\n            todo--\n            if (todo <= 0) {\n              // These writes are actually necessary for git to finish\n              // checkout.\n              process.stdout.write('\\n\\n')\n              process.exit()\n            }\n          })\n        })\n      })\n    })\n  })\n}\n"
        },
        {
          "name": "git.js",
          "type": "blob",
          "size": 3.646484375,
          "content": "#!/usr/bin/env node\n\nvar spawn = require('child_process').spawn\n\n// Returns a process running `git ls-remote <url>` that calls `with_ref` on\n// each parsed reference. The url may point to a local repository.\nfunction ls (url, with_ref) {\n  var ls = spawn('git', ['ls-remote', url])\n  ls.stdout.on('data', function (lines) {\n    lines.toString().split('\\n').forEach(function (line) {\n      if (!line || line === '') {\n        return\n      }\n      line = line.split('\\t')\n      var sha = line[0]\n      var branch = line[1]\n      if (sha.length !== 40) {\n        console.warn('[git ls-remote] expected a 40-byte sha: ' + sha + '\\n')\n        console.warn('[git ls-remote] on line: ' + line.join('\\t'))\n      }\n      with_ref(sha, branch)\n    })\n  })\n  return ls\n}\n\nfunction pad4 (num) {\n  num = num.toString(16)\n  while (num.length < 4) {\n    num = '0' + num\n  }\n  return num\n}\n\n// Invokes `$ git-upload-pack --strict <dir>`, communicates haves and wants and\n// emits 'ready' when stdout becomes a pack file stream.\nfunction upload_pack (dir, want, have) {\n  // reference:\n  // https://github.com/git/git/blob/b594c975c7e865be23477989d7f36157ad437dc7/Documentation/technical/pack-protocol.txt#L346-L393\n  var upload = spawn('git-upload-pack', ['--strict', dir])\n  writeln('want ' + want)\n  writeln()\n  if (have) {\n    writeln('have ' + have)\n    writeln()\n  }\n  writeln('done')\n\n  // We want to read git's output one line at a time, and not read any more\n  // than we have to. That way, when we finish discussing wants and haves, we\n  // can pipe the rest of the output to a stream.\n  //\n  // We use `mode` to keep track of state and formulate responses. It returns\n  // `false` when we should stop reading.\n  var mode = list\n  upload.stdout.on('readable', function () {\n    while (true) {\n      var line = getline()\n      if (line === null) {\n        return  // to wait for more output\n      }\n      if (!mode(line)) {\n        upload.stdout.removeAllListeners('readable')\n        upload.emit('ready')\n        return\n      }\n    }\n  })\n\n  var getline_len = null\n  // Extracts exactly one line from the stream. Uses `getline_len` in case the\n  // whole line could not be read.\n  function getline () {\n    // Format: '####line' where '####' represents the length of 'line' in hex.\n    if (!getline_len) {\n      getline_len = upload.stdout.read(4)\n      if (getline_len === null) {\n        return null\n      }\n      getline_len = parseInt(getline_len, 16)\n    }\n\n    if (getline_len === 0) {\n      return ''\n    }\n\n    // Subtract by the four we just read, and the terminating newline.\n    var line = upload.stdout.read(getline_len - 4 - 1)\n    if (!line) {\n      return null\n    }\n    getline_len = null\n    upload.stdout.read(1)  // And discard the newline.\n    return line.toString()\n  }\n\n  // First, the server lists the refs it has, but we already know from\n  // `git ls-remote`, so wait for it to signal the end.\n  function list (line) {\n    if (line === '') {\n      mode = have ? ack_objects_continue : wait_for_nak\n    }\n    return true\n  }\n\n  // If we only gave wants, git should respond with 'NAK', then the pack file.\n  function wait_for_nak (line) {\n    return line !== 'NAK'\n  }\n\n  // With haves, we wait for 'ACK', but only if not ending in 'continue'.\n  function ack_objects_continue (line) {\n    return !(line.search(/^ACK/) !== -1 && line.search(/continue$/) === -1)\n  }\n\n  // Writes one line to stdin so git-upload-pack can understand.\n  function writeln (line) {\n    if (line) {\n      var len = pad4(line.length + 4 + 1)  // Add one for the newline.\n      upload.stdin.write(len + line + '\\n')\n    } else {\n      upload.stdin.write('0000')\n    }\n  }\n\n  return upload\n}\n\nmodule.exports = {ls: ls, upload_pack: upload_pack}\n"
        },
        {
          "name": "gittorrentd",
          "type": "blob",
          "size": 5.3583984375,
          "content": "#!/usr/bin/env node\n\nvar DHT = require('bittorrent-dht')\nvar EC = require('elliptic').ec\nvar ed25519 = new EC('ed25519')\nvar exec = require('child_process').exec\nvar glob = require('glob')\nvar fs = require('fs')\nvar hat = require('hat')\nvar net = require('net')\nvar Protocol = require('bittorrent-protocol')\nvar spawn = require('child_process').spawn\nvar ut_gittorrent = require('ut_gittorrent')\nvar ut_metadata = require('ut_metadata')\nvar WebTorrent = require('webtorrent')\nvar zeroFill = require('zero-fill')\nvar config = require('./config')\nvar git = require('./git')\n\n// BitTorrent client version string (used in peer ID).\n// Generated from package.json major and minor version. For example:\n//   '0.16.1' -> '0016'\n//   '1.2.5' -> '0102'\n//\nvar VERSION = require('./package.json').version\n  .match(/([0-9]+)/g).slice(0, 2).map(zeroFill(2)).join('')\n\nfunction die (error) {\n  console.error(error)\n  process.exit(1)\n}\n\nvar dht = new DHT({\n  bootstrap: config.dht.bootstrap\n})\ndht.listen(config.dht.listen)\n\nvar announcedRefs = {\n}\nvar userProfile = {\n  repositories: {}\n}\n\nvar key = create_or_read_keyfile()\n\nfunction create_or_read_keyfile () {\n  if (!fs.existsSync(config.key)) {\n    var keypair = new EC('ed25519').genKeyPair()\n    fs.writeFileSync(config.key, JSON.stringify({\n      pub: keypair.getPublic('hex'),\n      priv: keypair.getPrivate('hex')\n    }))\n  }\n\n  // Okay, now the file exists, whether created here or not.\n  var key = JSON.parse(fs.readFileSync(config.key).toString())\n  return ed25519.keyPair({\n    priv: key.priv,\n    privEnc: 'hex',\n    pub: key.pub,\n    pubEnc: 'hex'\n  })\n}\n\nfunction bpad (n, buf) {\n  if (buf.length === n) return buf\n  if (buf.length < n) {\n    var b = new Buffer(n)\n    buf.copy(b, n - buf.length)\n    for (var i = 0; i < n - buf.length; i++) b[i] = 0\n    return b\n  }\n}\n\nvar head = ''\n\ndht.on('ready', function () {\n  // Spider all */.git dirs and announce all refs.\n  var repos = glob.sync('*/{,.git/}git-daemon-export-ok', {strict: false})\n  var count = repos.length\n  repos.forEach(function (repo) {\n    console.log('in repo ' + repo)\n    repo = repo.replace(/git-daemon-export-ok$/, '')\n    console.log(repo)\n\n    var reponame = repo.replace(/\\/.git\\/$/, '')\n    userProfile.repositories[reponame] = {}\n\n    var ls = git.ls(repo, function (sha, ref) {\n      // FIXME: Can't pull in too many branches, so only do heads for now.\n      if (ref !== 'HEAD' && !ref.match(/^refs\\/heads\\//)) {\n        return\n      }\n      if (ref === 'refs/heads/master') {\n        head = sha\n      }\n      userProfile.repositories[reponame][ref] = sha\n      if (!announcedRefs[sha]) {\n        console.log('Announcing ' + sha + ' for ' + ref + ' on repo ' + repo)\n        announcedRefs[sha] = repo\n        dht.announce(sha, config.dht.announce, function (err) {\n          if (err !== null) {\n            console.log('Announced ' + sha)\n          }\n        })\n      }\n    })\n    ls.stdout.on('end', function () {\n      count--\n      if (count <= 0) {\n        publish_mutable_key()\n      }\n    })\n    ls.on('exit', function (err) {\n      if (err) {\n        die(err)\n      }\n    })\n  })\n\n  function publish_mutable_key () {\n    var json = JSON.stringify(userProfile)\n    if (json.length > 950) {\n      console.error(\"Can't publish mutable key: doesn't fit in 950 bytes.\")\n      return false\n    }\n    var value = new Buffer(json.length)\n    value.write(json)\n    var sig = key.sign(value)\n    var opts = {\n      k: bpad(32, Buffer(key.getPublic().x.toArray())),\n      seq: 0,\n      v: value,\n      sig: Buffer.concat([\n        bpad(32, Buffer(sig.r.toArray())),\n        bpad(32, Buffer(sig.s.toArray()))\n    ])}\n    console.log(json)\n    dht.put(opts, function (errors, hash) {\n      console.error('errors=', errors)\n      console.log('hash=', hash.toString('hex'))\n    })\n  }\n\n  net.createServer(function (socket) {\n    var wire = new Protocol()\n    wire.use(ut_gittorrent())\n    wire.use(ut_metadata())\n    socket.pipe(wire).pipe(socket)\n    wire.on('handshake', function (infoHash, peerId) {\n      console.log('Received handshake for ' + infoHash.toString('hex'))\n      var myPeerId = new Buffer('-WW' + VERSION + '-' + hat(48), 'utf8')\n      wire.handshake(new Buffer(infoHash), new Buffer(myPeerId))\n    })\n    wire.ut_gittorrent.on('generatePack', function (sha) {\n      console.error('calling git pack-objects for ' + sha)\n      if (!announcedRefs[sha]) {\n        console.error('Asked for an unknown sha: ' + sha)\n        return\n      }\n      var directory = announcedRefs[sha]\n      var have = null\n      if (sha !== head) {\n        have = head\n      }\n      var pack = git.upload_pack(directory, sha, have)\n      pack.stderr.pipe(process.stderr)\n      pack.on('ready', function () {\n        var filename = sha + '.pack'\n        var stream = fs.createWriteStream(filename)\n        pack.stdout.pipe(stream)\n        stream.on('close', function () {\n          console.error('Finished writing ' + filename)\n          var webtorrent = new WebTorrent({\n            dht: {bootstrap: config.dht.bootstrap},\n            tracker: false\n          })\n          webtorrent.seed(filename, function onTorrent (torrent) {\n            console.error(torrent.infoHash)\n            wire.ut_gittorrent.sendTorrent(torrent.infoHash)\n          })\n        })\n      })\n      pack.on('exit', function (code) {\n        if (code !== 0) {\n          console.error('git-upload-pack process exited with code ' + code)\n        }\n      })\n    })\n  }).listen(config.dht.announce)\n})\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.2109375,
          "content": "{\n  \"name\": \"gittorrent\",\n  \"description\": \"Using BitTorrent to share git repositories\",\n  \"version\": \"0.1.9\",\n  \"author\": {\n    \"name\": \"Chris Ball\",\n    \"email\": \"chris@printf.net\",\n    \"url\": \"http://printf.net/\"\n  },\n  \"bin\": {\n    \"git-remote-gittorrent\": \"./git-remote-gittorrent\",\n    \"gittorrentd\": \"./gittorrentd\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/cjb/gittorrent/issues\"\n  },\n  \"dependencies\": {\n    \"bittorrent-dht\": \"git://github.com/cjb/bittorrent-dht#dht-store\",\n    \"bittorrent-protocol\": \"^1.5.7\",\n    \"bittorrent-swarm\": \"^5.0.2\",\n    \"chalk\": \"^1.0.0\",\n    \"elliptic\": \"^3.0.3\",\n    \"glob\": \"^5.0.6\",\n    \"hat\": \"^0.0.3\",\n    \"inherits\": \"^2.0.1\",\n    \"magnet-uri\": \"^4.0.0\",\n    \"prettyjson\": \"^1.1.2\",\n    \"rc\": \"^1.0.3\",\n    \"ut_gittorrent\": \"^0.1.0\",\n    \"ut_metadata\": \"^2.7.3\",\n    \"webtorrent\": \"^0.48.0\",\n    \"zero-fill\": \"^2.2.1\"\n  },\n  \"devDependencies\": {\n    \"standard\": \"^3.1.1\"\n  },\n  \"homepage\": \"http://gittorrent.org\",\n  \"keywords\": [\n    \"torrent\",\n    \"bittorrent\",\n    \"bittorrent client\",\n    \"git\",\n    \"gittorrent\",\n    \"mad science\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"git-remote-gittorrent\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/cjb/gittorrent.git\"\n  }\n}\n"
        }
      ]
    }
  ]
}