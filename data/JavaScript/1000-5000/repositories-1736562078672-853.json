{
  "metadata": {
    "timestamp": 1736562078672,
    "page": 853,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "BorisMoore/jquery-tmpl",
      "stars": 3227,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.064453125,
          "content": "build/dist\ndocs\n.project\n*~\n*.diff\n*.patch\n.DS_Store\nnode_modules\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.6025390625,
          "content": "# jQuery Templates plugin vBeta1.0.0\r\n\r\n_jQuery Templates is no longer in active development, and has been superseded by\r\n<a href=\"http://github.com/borismoore/jsrender\">JsRender</a>_.\r\n\r\nJsRender functionality is a superset of the jQuery Templates feature set,\r\nand brings many improvements. The template tag syntax is similar. Rendering\r\nand compiling performance of JsRender is considerably better than jQuery templates performance.\r\n\r\n----\r\n\r\n_Note: This is the original official jQuery Templates plugin. The project was maintained by the\r\njQuery team as an official jQuery plugin. Since the jQuery team has decided not to take this plugin\r\npast beta, it has been returned to the principal developer's GitHub account (Boris Moore).\r\nFor more information on the history of jQuery Templates, and the roadmap going forward, see\r\n<a  href=\"http://www.borismoore.com/2011/10/jquery-templates-and-jsviews-roadmap.html\">jQuery Templates and JsViews: The Roadmap</a>_\r\n\r\n----\r\n\r\nSee vBeta1.0.0 tag for released beta version. Requires jQuery version 1.4.2.\r\n\r\njQuery templates contain markup with binding expressions ('Template tags'). Templates are applied to data objects or arrays, and rendered into the HTML DOM.\r\n\r\nNote that documentation for the _jQuery Templates_ plugin is **no longer maintained on the jQuery documentation site**. \r\n\r\nAn archive copy of the original documentation (previously at api.jquery.com/category/plugins/templates/) can be found\r\n[here](http://web.archive.org/web/20120920065217/http://api.jquery.com/category/plugins/templates/).\r\n\r\nSee also [http://www.borismoore.com/2010/10/jquery-templates-is-now-official-jquery.html](http://www.borismoore.com/2010/10/jquery-templates-is-now-official-jquery.html)\r\nfor more background.\r\n\r\nLive versions of some of the demos from this repository can be found at\r\n[http://borismoore.github.io/jquery-tmpl/demos/step-by-step.html](http://borismoore.github.io/jquery-tmpl/demos/step-by-step.html).\r\n\r\n<p>The beta1 version of jQuery Templates is available on CDN at:\r\n<ul>\r\n<li><a href=\"http://ajax.microsoft.com/ajax/jquery.templates/beta1/jquery.tmpl.js\">http://ajax.microsoft.com/ajax/jquery.templates/beta1/jquery.tmpl.js</a></li>\r\n<li><a href=\"http://ajax.microsoft.com/ajax/jquery.templates/beta1/jquery.tmpl.min.js\">http://ajax.microsoft.com/ajax/jquery.templates/beta1/jquery.tmpl.min.js</a></li>\r\n</ul></p>\r\n\r\n---\r\n\r\n_The following is a restoration of jQuery's official documentation on tmpl() as it was on 12/28/2012. jQuery is Copyright 2012, John Resig_\r\n\r\n\r\n[Source](http://web.archive.org/web/20121014080309/http://api.jquery.com/jquery.tmpl/ \"Permalink to jQuery.tmpl() ï¿½ jQuery API\")\r\n\r\n# jQuery.tmpl( template \\[, data\\] \\[, options\\] ) Returns: jQuery   \r\n\r\n## Description:\r\n**Render the specified HTML content as a template, using the specified data.**   version added: 1.4.3\r\n\tjQuery.tmpl( template \\[, data\\] \\[, options\\] )\r\n\t\r\n**template** The HTML markup or text to use as a template.\r\n\r\n**data** The data to render. This can be any JavaScript type, including Array or Object.\r\n\r\n**options** An optional map of user-defined key-value pairs. Extends the `tmplItem` data structure, available to the template during rendering. \r\n\r\nThis documentation topic concerns the *jQuery Templates* plugin (jquery-tmpl), which can be downloaded from: http://github.com/jquery/jquery-tmpl.  \r\n\r\nThe `jQuery.tmpl()` method is designed for chaining with `.appendTo`, `.prependTo`, `.insertAfter` or `.insertBefore` as in the following example.\r\n\r\n### Example:\r\n```JavaScript\r\n    $.tmpl( \"<li>${Name}</li>\", { \"Name\" : \"John Doe\" }).appendTo( \"#target\" );\r\n```\r\nThe `template` parameter can be any of the following: \r\n\r\n*   A string containing markup.\r\n*   An HTML element (or jQuery object that wraps an element) whose content is to be used as the template.\r\n*   A string corresponding to the name of a named template (see jQuery.template() and .template()).\r\n*   A compiled-template function (see jQuery.template() and .template()).\r\n\r\nIf `data` is an array, the template is rendered once for each data item in the array. If `data` is an object, or if the `data` parameter is missing or null, a single template item is rendered. \r\n\r\nThe return value is a jQuery collection of elements made up of the rendered template items (one for each data item in the array). If the template contains only one top-level element, then there will be one element for each data item in the array. \r\n\r\nTo insert the rendered template items into the HTML DOM, the returned jQuery collection should not be inserted directly into the DOM, but should be chained with `.appendTo`, `.prependTo`, `.insertAfter` or `.insertBefore`, as in following example: \r\n```JavaScript\r\n    $.tmpl( myTemplate, myData ).appendTo( \"#target\" );\r\n```\r\nSee also .tmpl().\r\n\r\n### Example \r\nThe following example shows how to use `jQuery.tmpl()` to render local data, using a template provided as a string: \r\n```JavaScript\r\n      var movies = [\r\n\t\t  { Name: \"The Red Violin\", ReleaseYear: \"1998\" },\r\n\t\t  { Name: \"Eyes Wide Shut\", ReleaseYear: \"1999\" },\r\n\t\t  { Name: \"The Inheritance\", ReleaseYear: \"1976\" }\r\n\t\t];\r\n    \r\n      var markup = \"<li><b>${Name}</b> (${ReleaseYear})</li>\";\r\n\r\n\t  // Compile the markup as a named template\r\n\t  $.template( \"movieTemplate\", markup );\r\n\r\n\t  // Render the template with the movies data and insert\r\n\t  // the rendered HTML under the \"movieList\" element\r\n\t  $.tmpl( \"movieTemplate\", movies )\r\n\t\t  .appendTo( \"#movieList\" );\r\n```\r\n## Using Remote Data \r\nTypically the data is not local and is instead obtained using an Ajax request to a remote service or page, as in the following example: \r\n```JavaScript\r\n    var markup = \"<li><b>${Name}</b> (${ReleaseYear})</li>\";\r\n\r\n\t// Compile the markup as a named template\r\n\t$.template( \"movieTemplate\", markup );\r\n\r\n\t$.ajax({\r\n\t  dataType: \"jsonp\",\r\n\t  url: moviesServiceUrl,\r\n\t  jsonp: \"$callback\",\r\n\t  success: showMovies\r\n\t});\r\n\r\n\t// Within the callback, use .tmpl() to render the data.\r\n\tfunction showMovies( data ) {\r\n\t  // Render the template with the \"movies\" data and insert\r\n\t  // the rendered HTML under the 'movieList' element\r\n\t  $.tmpl( \"movieTemplate\", data )\r\n\t\t.appendTo( \"#movieList\" );\r\n\t}\r\n```\r\n## The Markup for the Template  \r\nYou can get the markup for the template from inline markup in the page, or from a string (possibly computed, or obtained remotely). For an example of how to use inline markup, see .tmpl().\r\n\r\n## Caching the Template \r\nWhen a template is rendered, the markup is first converted into a compiled-template function. Every time `$.tmpl( markup , myData ).appendTo( \"#target\" )` is called, the template is recompiled. If the same template is to be used more than once for rendering data, you should ensure that the compiled template is cached. To cache the template when using markup that is obtained from a string (rather than from inline markup in the page), use `$.template( name, markup )` to create a named template for reuse. See jQuery.template().\r\n\r\n## Template Tags, Expressions, and Template Variables \r\nTemplate tags such as the `${}` tag can used within jQuery templates in addition to text and HTML markup to enable a number of scenarios such as composition of templates, iteration over hierarchical data, parameterization of template rendering, etc. Template tags can render content based on the values of data item fields or template variables such as `$item` (corresponding to the template item), as well as expressions and function calls. See the documentation topics for each template tag: ${}, {{each}}, {{if}}, {{else}}, {{html}}, {{tmpl}} and {{wrap}}.\r\n\r\n## The `options` Parameter, and Template Items \r\nEach template item (the result of rendering a data item with the template) is associated with a `tmplItem` data structure, which can be accessed using jQuery.tmplItem() and .tmplItem(), or the `$item` template variable. Any fields or anonomyous methods passed in with the `options` parameter of `jQuery.tmpl()` will extend the `tmplItem` data structure, and so be available to the template as in the following example: \r\n```JavaScript\r\n    var markup = \"<li>Some content: ${$item.myMethod()}.<br/>\" \r\n           + \" More content: ${$item.myValue}.</li>\";\r\n\r\n\t// Compile the markup as a named template\r\n\t$.template( \"movieTemplate\", markup );\r\n\r\n\t// Render the template with the movies data\r\n\t$.tmpl( \"movieTemplate\", movies,\r\n\t  { \r\n\t\t  myValue: \"somevalue\", \r\n\t\t  myMethod: function() { \r\n\t\t\t  return \"something\";\r\n\t\t  } \r\n\t  } \r\n\t).appendTo( \"#movieList\" );\r\n```\r\n## Examples:\r\n\r\n### Example: Render local data using jQuery.tmpl().\r\n```html\r\n\t<!DOCTYPE html>\r\n\t<html>\r\n\t<head>\r\n\t  <script src=\"http://code.jquery.com/jquery-latest.min.js\"></script>\r\n\t  <script src=\"http://ajax.microsoft.com/ajax/jquery.templates/beta1/jquery.tmpl.min.js\"></script>\r\n\t</head>\r\n\t<body>\r\n\t  \r\n\t<ul id=\"movieList\"></ul>\r\n\r\n\t<script>\r\n\t  var movies = [\r\n\t  { Name: \"The Red Violin\", ReleaseYear: \"1998\" },\r\n\t  { Name: \"Eyes Wide Shut\", ReleaseYear: \"1999\" },\r\n\t  { Name: \"The Inheritance\", ReleaseYear: \"1976\" }\r\n\t  ];\r\n\r\n\tvar markup = \"<li><b>${Name}</b> (${ReleaseYear})</li>\";\r\n\r\n\t/* Compile the markup as a named template */\r\n\t$.template( \"movieTemplate\", markup );\r\n\r\n\t/* Render the template with the movies data and insert\r\n\t   the rendered HTML under the \"movieList\" element */\r\n\t$.tmpl( \"movieTemplate\", movies )\r\n\t  .appendTo( \"#movieList\" );\r\n\t</script>\r\n\r\n\t</body>\r\n\t</html>\r\n```\r\n### Example: Render data from a remote service, using jQuery.tmpl().\r\n```html\r\n\t<!DOCTYPE html>\r\n\t<html>\r\n\t<head>\r\n\t  <script src=\"http://code.jquery.com/jquery-latest.min.js\"></script>\r\n\t  <script src=\"http://ajax.microsoft.com/ajax/jquery.templates/beta1/jquery.tmpl.min.js\"></script>\r\n\t</head>\r\n\t<body>\r\n\t  \r\n\t<button id=\"cartoonsBtn\">Cartoons</button>\r\n\t<button id=\"dramaBtn\">Drama</button>\r\n\r\n\t<ul id=\"movieList\"></ul>\r\n\r\n\t<script>\r\n\tvar markup = \"<li><b>${Name}</b> (${ReleaseYear})</li>\";\r\n\r\n\t/* Compile the markup as a named template */\r\n\t$.template( \"movieTemplate\", markup );\r\n\r\n\tfunction getMovies( genre, skip, top ) {\r\n\t  $.ajax({\r\n\t\tdataType: \"jsonp\",\r\n\t\turl: \"http://odata.netflix.com/Catalog/Genres('\" + genre\r\n\t\t+ \"')/Titles?$format=json&$skip=\"\r\n\t\t+ skip + \"&$top=\" + top,\r\n\t\tjsonp: \"$callback\",\r\n\t\tsuccess: function( data ) {\r\n\t\t  /* Get the movies array from the data */\r\n\t\t  var movies = data.d;\r\n\r\n\t\t  /* Remove current set of movie template items */\r\n\t\t  $( \"#movieList\" ).empty();\r\n\r\n\t\t  /* Render the template items for each movie\r\n\t\t  and insert the template items into the \"movieList\" */\r\n\t\t  $.tmpl( \"movieTemplate\", movies )\r\n\t\t  .appendTo( \"#movieList\" );\r\n\t\t}\r\n\t  });\r\n\t}\r\n\r\n\t$( \"#cartoonsBtn\" ).click( function() {\r\n\t  getMovies( \"Cartoons\", 0, 6 );\r\n\t});\r\n\r\n\t$( \"#dramaBtn\" ).click( function() {\r\n\t  getMovies( \"Drama\", 0, 6 );\r\n\t});\r\n\r\n\t</script>\r\n\r\n\t</body>\r\n\t</html>\r\n```\r\n"
        },
        {
          "name": "demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "jquery.tmpl.js",
          "type": "blob",
          "size": 18.8701171875,
          "content": "/*!\n * jQuery Templates Plugin 1.0.0pre\n * http://github.com/jquery/jquery-tmpl\n * Requires jQuery 1.4.2\n *\n * Copyright 2011, Software Freedom Conservancy, Inc.\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n */\n(function( factory ) {\n\tif (typeof define === 'function' && define.amd) {\n\t\t// Loading from AMD script loader. Register as an anonymous module.\n\t\tdefine( ['jquery'], factory );\n\t} else {\n\t\t// Browser using plain <script> tag\n\t\tfactory( jQuery );\n\t}\n}(function( jQuery ){\n\tvar oldManip = jQuery.fn.domManip, tmplItmAtt = \"_tmplitem\", htmlExpr = /^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! /,\n\t\tnewTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];\n\n\tfunction newTmplItem( options, parentItem, fn, data ) {\n\t\t// Returns a template item data structure for a new rendered instance of a template (a 'template item').\n\t\t// The content field is a hierarchical array of strings and nested items (to be\n\t\t// removed and replaced by nodes field of dom elements, once inserted in DOM).\n\t\tvar newItem = {\n\t\t\tdata: data || (data === 0 || data === false) ? data : (parentItem ? parentItem.data : {}),\n\t\t\t_wrap: parentItem ? parentItem._wrap : null,\n\t\t\ttmpl: null,\n\t\t\tparent: parentItem || null,\n\t\t\tnodes: [],\n\t\t\tcalls: tiCalls,\n\t\t\tnest: tiNest,\n\t\t\twrap: tiWrap,\n\t\t\thtml: tiHtml,\n\t\t\tupdate: tiUpdate\n\t\t};\n\t\tif ( options ) {\n\t\t\tjQuery.extend( newItem, options, { nodes: [], parent: parentItem });\n\t\t}\n\t\tif ( fn ) {\n\t\t\t// Build the hierarchical content to be used during insertion into DOM\n\t\t\tnewItem.tmpl = fn;\n\t\t\tnewItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );\n\t\t\tnewItem.key = ++itemKey;\n\t\t\t// Keep track of new template item, until it is stored as jQuery Data on DOM element\n\t\t\t(stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;\n\t\t}\n\t\treturn newItem;\n\t}\n\n\t// Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).\n\tjQuery.each({\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function( name, original ) {\n\t\tjQuery.fn[ name ] = function( selector ) {\n\t\t\tvar ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,\n\t\t\t\tparent = this.length === 1 && this[0].parentNode;\n\n\t\t\tappendToTmplItems = newTmplItems || {};\n\t\t\tif ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {\n\t\t\t\tinsert[ original ]( this[0] );\n\t\t\t\tret = this;\n\t\t\t} else {\n\t\t\t\tfor ( i = 0, l = insert.length; i < l; i++ ) {\n\t\t\t\t\tcloneIndex = i;\n\t\t\t\t\telems = (i > 0 ? this.clone(true) : this).get();\n\t\t\t\t\tjQuery( insert[i] )[ original ]( elems );\n\t\t\t\t\tret = ret.concat( elems );\n\t\t\t\t}\n\t\t\t\tcloneIndex = 0;\n\t\t\t\tret = this.pushStack( ret, name, insert.selector );\n\t\t\t}\n\t\t\ttmplItems = appendToTmplItems;\n\t\t\tappendToTmplItems = null;\n\t\t\tjQuery.tmpl.complete( tmplItems );\n\t\t\treturn ret;\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\t\t// Use first wrapped element as template markup.\n\t\t// Return wrapped set of template items, obtained by rendering template against data.\n\t\ttmpl: function( data, options, parentItem ) {\n\t\t\treturn jQuery.tmpl( this[0], data, options, parentItem );\n\t\t},\n\n\t\t// Find which rendered template item the first wrapped DOM element belongs to\n\t\ttmplItem: function() {\n\t\t\treturn jQuery.tmplItem( this[0] );\n\t\t},\n\n\t\t// Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.\n\t\ttemplate: function( name ) {\n\t\t\treturn jQuery.template( name, this[0] );\n\t\t},\n\n\t\tdomManip: function( args, table, callback, options ) {\n\t\t\tif ( args[0] && jQuery.isArray( args[0] )) {\n\t\t\t\tvar dmArgs = jQuery.makeArray( arguments ), elems = args[0], elemsLength = elems.length, i = 0, tmplItem;\n\t\t\t\twhile ( i < elemsLength && !(tmplItem = jQuery.data( elems[i++], \"tmplItem\" ))) {}\n\t\t\t\tif ( tmplItem && cloneIndex ) {\n\t\t\t\t\tdmArgs[2] = function( fragClone ) {\n\t\t\t\t\t\t// Handler called by oldManip when rendered template has been inserted into DOM.\n\t\t\t\t\t\tjQuery.tmpl.afterManip( this, fragClone, callback );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\toldManip.apply( this, dmArgs );\n\t\t\t} else {\n\t\t\t\toldManip.apply( this, arguments );\n\t\t\t}\n\t\t\tcloneIndex = 0;\n\t\t\tif ( !appendToTmplItems ) {\n\t\t\t\tjQuery.tmpl.complete( newTmplItems );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\t// Return wrapped set of template items, obtained by rendering template against data.\n\t\ttmpl: function( tmpl, data, options, parentItem ) {\n\t\t\tvar ret, topLevel = !parentItem;\n\t\t\tif ( topLevel ) {\n\t\t\t\t// This is a top-level tmpl call (not from a nested template using {{tmpl}})\n\t\t\t\tparentItem = topTmplItem;\n\t\t\t\ttmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );\n\t\t\t\twrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level\n\t\t\t} else if ( !tmpl ) {\n\t\t\t\t// The template item is already associated with DOM - this is a refresh.\n\t\t\t\t// Re-evaluate rendered template for the parentItem\n\t\t\t\ttmpl = parentItem.tmpl;\n\t\t\t\tnewTmplItems[parentItem.key] = parentItem;\n\t\t\t\tparentItem.nodes = [];\n\t\t\t\tif ( parentItem.wrapped ) {\n\t\t\t\t\tupdateWrapped( parentItem, parentItem.wrapped );\n\t\t\t\t}\n\t\t\t\t// Rebuild, without creating a new template item\n\t\t\t\treturn jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));\n\t\t\t}\n\t\t\tif ( !tmpl ) {\n\t\t\t\treturn []; // Could throw...\n\t\t\t}\n\t\t\tif ( typeof data === \"function\" ) {\n\t\t\t\tdata = data.call( parentItem || {} );\n\t\t\t}\n\t\t\tif ( options && options.wrapped ) {\n\t\t\t\tupdateWrapped( options, options.wrapped );\n\t\t\t}\n\t\t\tret = jQuery.isArray( data ) ?\n\t\t\t\tjQuery.map( data, function( dataItem ) {\n\t\t\t\t\treturn dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;\n\t\t\t\t}) :\n\t\t\t\t[ newTmplItem( options, parentItem, tmpl, data ) ];\n\t\t\treturn topLevel ? jQuery( build( parentItem, null, ret ) ) : ret;\n\t\t},\n\n\t\t// Return rendered template item for an element.\n\t\ttmplItem: function( elem ) {\n\t\t\tvar tmplItem;\n\t\t\tif ( elem instanceof jQuery ) {\n\t\t\t\telem = elem[0];\n\t\t\t}\n\t\t\twhile ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, \"tmplItem\" )) && (elem = elem.parentNode) ) {}\n\t\t\treturn tmplItem || topTmplItem;\n\t\t},\n\n\t\t// Set:\n\t\t// Use $.template( name, tmpl ) to cache a named template,\n\t\t// where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.\n\t\t// Use $( \"selector\" ).template( name ) to provide access by name to a script block template declaration.\n\n\t\t// Get:\n\t\t// Use $.template( name ) to access a cached template.\n\t\t// Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )\n\t\t// will return the compiled template, without adding a name reference.\n\t\t// If templateString includes at least one HTML tag, $.template( templateString ) is equivalent\n\t\t// to $.template( null, templateString )\n\t\ttemplate: function( name, tmpl ) {\n\t\t\tif (tmpl) {\n\t\t\t\t// Compile template and associate with name\n\t\t\t\tif ( typeof tmpl === \"string\" ) {\n\t\t\t\t\t// This is an HTML string being passed directly in.\n\t\t\t\t\ttmpl = buildTmplFn( tmpl );\n\t\t\t\t} else if ( tmpl instanceof jQuery ) {\n\t\t\t\t\ttmpl = tmpl[0] || {};\n\t\t\t\t}\n\t\t\t\tif ( tmpl.nodeType ) {\n\t\t\t\t\t// If this is a template block, use cached copy, or generate tmpl function and cache.\n\t\t\t\t\ttmpl = jQuery.data( tmpl, \"tmpl\" ) || jQuery.data( tmpl, \"tmpl\", buildTmplFn( tmpl.innerHTML ));\n\t\t\t\t\t// Issue: In IE, if the container element is not a script block, the innerHTML will remove quotes from attribute values whenever the value does not include white space.\n\t\t\t\t\t// This means that foo=\"${x}\" will not work if the value of x includes white space: foo=\"${x}\" -> foo=value of x.\n\t\t\t\t\t// To correct this, include space in tag: foo=\"${ x }\" -> foo=\"value of x\"\n\t\t\t\t}\n\t\t\t\treturn typeof name === \"string\" ? (jQuery.template[name] = tmpl) : tmpl;\n\t\t\t}\n\t\t\t// Return named compiled template\n\t\t\treturn name ? (typeof name !== \"string\" ? jQuery.template( null, name ):\n\t\t\t\t(jQuery.template[name] ||\n\t\t\t\t\t// If not in map, and not containing at least on HTML tag, treat as a selector.\n\t\t\t\t\t// (If integrated with core, use quickExpr.exec)\n\t\t\t\t\tjQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null;\n\t\t},\n\n\t\tencode: function( text ) {\n\t\t\t// Do HTML encoding replacing < > & and ' and \" by corresponding entities.\n\t\t\treturn (\"\" + text).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\");\n\t\t}\n\t});\n\n\tjQuery.extend( jQuery.tmpl, {\n\t\ttag: {\n\t\t\t\"tmpl\": {\n\t\t\t\t_default: { $2: \"null\" },\n\t\t\t\topen: \"if($notnull_1){__=__.concat($item.nest($1,$2));}\"\n\t\t\t\t// tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)\n\t\t\t\t// This means that {{tmpl foo}} treats foo as a template (which IS a function).\n\t\t\t\t// Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.\n\t\t\t},\n\t\t\t\"wrap\": {\n\t\t\t\t_default: { $2: \"null\" },\n\t\t\t\topen: \"$item.calls(__,$1,$2);__=[];\",\n\t\t\t\tclose: \"call=$item.calls();__=call._.concat($item.wrap(call,__));\"\n\t\t\t},\n\t\t\t\"each\": {\n\t\t\t\t_default: { $2: \"$index, $value\" },\n\t\t\t\topen: \"if($notnull_1){$.each($1a,function($2){with(this){\",\n\t\t\t\tclose: \"}});}\"\n\t\t\t},\n\t\t\t\"if\": {\n\t\t\t\topen: \"if(($notnull_1) && $1a){\",\n\t\t\t\tclose: \"}\"\n\t\t\t},\n\t\t\t\"else\": {\n\t\t\t\t_default: { $1: \"true\" },\n\t\t\t\topen: \"}else if(($notnull_1) && $1a){\"\n\t\t\t},\n\t\t\t\"html\": {\n\t\t\t\t// Unecoded expression evaluation.\n\t\t\t\topen: \"if($notnull_1){__.push($1a);}\"\n\t\t\t},\n\t\t\t\"=\": {\n\t\t\t\t// Encoded expression evaluation. Abbreviated form is ${}.\n\t\t\t\t_default: { $1: \"$data\" },\n\t\t\t\topen: \"if($notnull_1){__.push($.encode($1a));}\"\n\t\t\t},\n\t\t\t\"!\": {\n\t\t\t\t// Comment tag. Skipped by parser\n\t\t\t\topen: \"\"\n\t\t\t}\n\t\t},\n\n\t\t// This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events\n\t\tcomplete: function( items ) {\n\t\t\tnewTmplItems = {};\n\t\t},\n\n\t\t// Call this from code which overrides domManip, or equivalent\n\t\t// Manage cloning/storing template items etc.\n\t\tafterManip: function afterManip( elem, fragClone, callback ) {\n\t\t\t// Provides cloned fragment ready for fixup prior to and after insertion into DOM\n\t\t\tvar content = fragClone.nodeType === 11 ?\n\t\t\t\tjQuery.makeArray(fragClone.childNodes) :\n\t\t\t\tfragClone.nodeType === 1 ? [fragClone] : [];\n\n\t\t\t// Return fragment to original caller (e.g. append) for DOM insertion\n\t\t\tcallback.call( elem, fragClone );\n\n\t\t\t// Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.\n\t\t\tstoreTmplItems( content );\n\t\t\tcloneIndex++;\n\t\t}\n\t});\n\n\t//========================== Private helper functions, used by code above ==========================\n\n\tfunction build( tmplItem, nested, content ) {\n\t\t// Convert hierarchical content into flat string array\n\t\t// and finally return array of fragments ready for DOM insertion\n\t\tvar frag, ret = content ? jQuery.map( content, function( item ) {\n\t\t\treturn (typeof item === \"string\") ?\n\t\t\t\t// Insert template item annotations, to be converted to jQuery.data( \"tmplItem\" ) when elems are inserted into DOM.\n\t\t\t\t(tmplItem.key ? item.replace( /(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g, \"$1 \" + tmplItmAtt + \"=\\\"\" + tmplItem.key + \"\\\" $2\" ) : item) :\n\t\t\t\t// This is a child template item. Build nested template.\n\t\t\t\tbuild( item, tmplItem, item._ctnt );\n\t\t}) :\n\t\t// If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.\n\t\ttmplItem;\n\t\tif ( nested ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t// top-level template\n\t\tret = ret.join(\"\");\n\n\t\t// Support templates which have initial or final text nodes, or consist only of text\n\t\t// Also support HTML entities within the HTML markup.\n\t\tret.replace( /^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/, function( all, before, middle, after) {\n\t\t\tfrag = jQuery( middle ).get();\n\n\t\t\tstoreTmplItems( frag );\n\t\t\tif ( before ) {\n\t\t\t\tfrag = unencode( before ).concat(frag);\n\t\t\t}\n\t\t\tif ( after ) {\n\t\t\t\tfrag = frag.concat(unencode( after ));\n\t\t\t}\n\t\t});\n\t\treturn frag ? frag : unencode( ret );\n\t}\n\n\tfunction unencode( text ) {\n\t\t// Use createElement, since createTextNode will not render HTML entities correctly\n\t\tvar el = document.createElement( \"div\" );\n\t\tel.innerHTML = text;\n\t\treturn jQuery.makeArray(el.childNodes);\n\t}\n\n\t// Generate a reusable function that will serve to render a template against data\n\tfunction buildTmplFn( markup ) {\n\t\treturn new Function(\"jQuery\",\"$item\",\n\t\t\t// Use the variable __ to hold a string array while building the compiled template. (See https://github.com/jquery/jquery-tmpl/issues#issue/10).\n\t\t\t\"var $=jQuery,call,__=[],$data=$item.data;\" +\n\n\t\t\t// Introduce the data as local variables using with(){}\n\t\t\t\"with($data){__.push('\" +\n\n\t\t\t// Convert the template into pure JavaScript\n\t\t\tjQuery.trim(markup)\n\t\t\t\t.replace( /([\\\\'])/g, \"\\\\$1\" )\n\t\t\t\t.replace( /[\\r\\t\\n]/g, \" \" )\n\t\t\t\t.replace( /\\$\\{([^\\}]*)\\}/g, \"{{= $1}}\" )\n\t\t\t\t.replace( /\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g,\n\t\t\t\tfunction( all, slash, type, fnargs, target, parens, args ) {\n\t\t\t\t\tvar tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;\n\t\t\t\t\tif ( !tag ) {\n\t\t\t\t\t\tthrow \"Unknown template tag: \" + type;\n\t\t\t\t\t}\n\t\t\t\t\tdef = tag._default || [];\n\t\t\t\t\tif ( parens && !/\\w$/.test(target)) {\n\t\t\t\t\t\ttarget += parens;\n\t\t\t\t\t\tparens = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif ( target ) {\n\t\t\t\t\t\ttarget = unescape( target );\n\t\t\t\t\t\targs = args ? (\",\" + unescape( args ) + \")\") : (parens ? \")\" : \"\");\n\t\t\t\t\t\t// Support for target being things like a.toLowerCase();\n\t\t\t\t\t\t// In that case don't call with template item as 'this' pointer. Just evaluate...\n\t\t\t\t\t\texpr = parens ? (target.indexOf(\".\") > -1 ? target + unescape( parens ) : (\"(\" + target + \").call($item\" + args)) : target;\n\t\t\t\t\t\texprAutoFnDetect = parens ? expr : \"(typeof(\" + target + \")==='function'?(\" + target + \").call($item):(\" + target + \"))\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\texprAutoFnDetect = expr = def.$1 || \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tfnargs = unescape( fnargs );\n\t\t\t\t\treturn \"');\" +\n\t\t\t\t\t\ttag[ slash ? \"close\" : \"open\" ]\n\t\t\t\t\t\t\t.split( \"$notnull_1\" ).join( target ? \"typeof(\" + target + \")!=='undefined' && (\" + target + \")!=null\" : \"true\" )\n\t\t\t\t\t\t\t.split( \"$1a\" ).join( exprAutoFnDetect )\n\t\t\t\t\t\t\t.split( \"$1\" ).join( expr )\n\t\t\t\t\t\t\t.split( \"$2\" ).join( fnargs || def.$2 || \"\" ) +\n\t\t\t\t\t\t\"__.push('\";\n\t\t\t\t}) +\n\t\t\t\"');}return __;\"\n\t\t);\n\t}\n\tfunction updateWrapped( options, wrapped ) {\n\t\t// Build the wrapped content.\n\t\toptions._wrap = build( options, true,\n\t\t\t// Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.\n\t\t\tjQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]\n\t\t).join(\"\");\n\t}\n\n\tfunction unescape( args ) {\n\t\treturn args ? args.replace( /\\\\'/g, \"'\").replace(/\\\\\\\\/g, \"\\\\\" ) : null;\n\t}\n\tfunction outerHtml( elem ) {\n\t\tvar div = document.createElement(\"div\");\n\t\tdiv.appendChild( elem.cloneNode(true) );\n\t\treturn div.innerHTML;\n\t}\n\n\t// Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.\n\tfunction storeTmplItems( content ) {\n\t\tvar keySuffix = \"_\" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;\n\t\tfor ( i = 0, l = content.length; i < l; i++ ) {\n\t\t\tif ( (elem = content[i]).nodeType !== 1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telems = elem.getElementsByTagName(\"*\");\n\t\t\tfor ( m = elems.length - 1; m >= 0; m-- ) {\n\t\t\t\tprocessItemKey( elems[m] );\n\t\t\t}\n\t\t\tprocessItemKey( elem );\n\t\t}\n\t\tfunction processItemKey( el ) {\n\t\t\tvar pntKey, pntNode = el, pntItem, tmplItem, key;\n\t\t\t// Ensure that each rendered template inserted into the DOM has its own template item,\n\t\t\tif ( (key = el.getAttribute( tmplItmAtt ))) {\n\t\t\t\twhile ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }\n\t\t\t\tif ( pntKey !== key ) {\n\t\t\t\t\t// The next ancestor with a _tmplitem expando is on a different key than this one.\n\t\t\t\t\t// So this is a top-level element within this template item\n\t\t\t\t\t// Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.\n\t\t\t\t\tpntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;\n\t\t\t\t\tif ( !(tmplItem = newTmplItems[key]) ) {\n\t\t\t\t\t\t// The item is for wrapped content, and was copied from the temporary parent wrappedItem.\n\t\t\t\t\t\ttmplItem = wrappedItems[key];\n\t\t\t\t\t\ttmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode] );\n\t\t\t\t\t\ttmplItem.key = ++itemKey;\n\t\t\t\t\t\tnewTmplItems[itemKey] = tmplItem;\n\t\t\t\t\t}\n\t\t\t\t\tif ( cloneIndex ) {\n\t\t\t\t\t\tcloneTmplItem( key );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tel.removeAttribute( tmplItmAtt );\n\t\t\t} else if ( cloneIndex && (tmplItem = jQuery.data( el, \"tmplItem\" )) ) {\n\t\t\t\t// This was a rendered element, cloned during append or appendTo etc.\n\t\t\t\t// TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.\n\t\t\t\tcloneTmplItem( tmplItem.key );\n\t\t\t\tnewTmplItems[tmplItem.key] = tmplItem;\n\t\t\t\tpntNode = jQuery.data( el.parentNode, \"tmplItem\" );\n\t\t\t\tpntNode = pntNode ? pntNode.key : 0;\n\t\t\t}\n\t\t\tif ( tmplItem ) {\n\t\t\t\tpntItem = tmplItem;\n\t\t\t\t// Find the template item of the parent element.\n\t\t\t\t// (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)\n\t\t\t\twhile ( pntItem && pntItem.key != pntNode ) {\n\t\t\t\t\t// Add this element as a top-level node for this rendered template item, as well as for any\n\t\t\t\t\t// ancestor items between this item and the item of its parent element\n\t\t\t\t\tpntItem.nodes.push( el );\n\t\t\t\t\tpntItem = pntItem.parent;\n\t\t\t\t}\n\t\t\t\t// Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...\n\t\t\t\tdelete tmplItem._ctnt;\n\t\t\t\tdelete tmplItem._wrap;\n\t\t\t\t// Store template item as jQuery data on the element\n\t\t\t\tjQuery.data( el, \"tmplItem\", tmplItem );\n\t\t\t}\n\t\t\tfunction cloneTmplItem( key ) {\n\t\t\t\tkey = key + keySuffix;\n\t\t\t\ttmplItem = newClonedItems[key] =\n\t\t\t\t\t(newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent ));\n\t\t\t}\n\t\t}\n\t}\n\n\t//---- Helper functions for template item ----\n\n\tfunction tiCalls( content, tmpl, data, options ) {\n\t\tif ( !content ) {\n\t\t\treturn stack.pop();\n\t\t}\n\t\tstack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });\n\t}\n\n\tfunction tiNest( tmpl, data, options ) {\n\t\t// nested template, using {{tmpl}} tag\n\t\treturn jQuery.tmpl( jQuery.template( tmpl ), data, options, this );\n\t}\n\n\tfunction tiWrap( call, wrapped ) {\n\t\t// nested template, using {{wrap}} tag\n\t\tvar options = call.options || {};\n\t\toptions.wrapped = wrapped;\n\t\t// Apply the template, which may incorporate wrapped content,\n\t\treturn jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );\n\t}\n\n\tfunction tiHtml( filter, textOnly ) {\n\t\tvar wrapped = this._wrap;\n\t\treturn jQuery.map(\n\t\t\tjQuery( jQuery.isArray( wrapped ) ? wrapped.join(\"\") : wrapped ).filter( filter || \"*\" ),\n\t\t\tfunction(e) {\n\t\t\t\treturn textOnly ?\n\t\t\t\t\te.innerText || e.textContent :\n\t\t\t\t\te.outerHTML || outerHtml(e);\n\t\t\t});\n\t}\n\n\tfunction tiUpdate() {\n\t\tvar coll = this.nodes;\n\t\tjQuery.tmpl( null, null, null, this).insertBefore( coll[0] );\n\t\tjQuery( coll ).remove();\n\t}\n}));\n"
        },
        {
          "name": "jquery.tmpl.min.js",
          "type": "blob",
          "size": 5.9658203125,
          "content": "/*!\n * jQuery Templates Plugin 1.0.0pre\n * http://github.com/jquery/jquery-tmpl\n * Requires jQuery 1.4.2\n *\n * Copyright 2011, Software Freedom Conservancy, Inc.\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n */\n!function(t){\"function\"==typeof define&&define.amd?define([\"jquery\"],t):t(jQuery)}(function(t){function e(e,n,l,a){var r={data:a||0===a||a===!1?a:n?n.data:{},_wrap:n?n._wrap:null,tmpl:null,parent:n||null,nodes:[],calls:u,nest:c,wrap:f,html:m,update:s};return e&&t.extend(r,e,{nodes:[],parent:n}),l&&(r.tmpl=l,r._ctnt=r._ctnt||r.tmpl(t,r),r.key=++w,(T.length?g:y)[w]=r),r}function n(e,a,r){var i,p=r?t.map(r,function(t){return\"string\"==typeof t?e.key?t.replace(/(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g,\"$1 \"+_+'=\"'+e.key+'\" $2'):t:n(t,e,t._ctnt)}):e;return a?p:(p=p.join(\"\"),p.replace(/^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/,function(e,n,a,r){i=t(a).get(),o(i),n&&(i=l(n).concat(i)),r&&(i=i.concat(l(r)))}),i?i:l(p))}function l(e){var n=document.createElement(\"div\");return n.innerHTML=e,t.makeArray(n.childNodes)}function a(e){return Function(\"jQuery\",\"$item\",\"var $=jQuery,call,__=[],$data=$item.data;with($data){__.push('\"+t.trim(e).replace(/([\\\\'])/g,\"\\\\$1\").replace(/[\\r\\t\\n]/g,\" \").replace(/\\$\\{([^\\}]*)\\}/g,\"{{= $1}}\").replace(/\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g,function(e,n,l,a,r,p,o){var u,c,f,m=t.tmpl.tag[l];if(!m)throw\"Unknown template tag: \"+l;return u=m._default||[],p&&!/\\w$/.test(r)&&(r+=p,p=\"\"),r?(r=i(r),o=o?\",\"+i(o)+\")\":p?\")\":\"\",c=p?r.indexOf(\".\")>-1?r+i(p):\"(\"+r+\").call($item\"+o:r,f=p?c:\"(typeof(\"+r+\")==='function'?(\"+r+\").call($item):(\"+r+\"))\"):f=c=u.$1||\"null\",a=i(a),\"');\"+m[n?\"close\":\"open\"].split(\"$notnull_1\").join(r?\"typeof(\"+r+\")!=='undefined' && (\"+r+\")!=null\":\"true\").split(\"$1a\").join(f).split(\"$1\").join(c).split(\"$2\").join(a||u.$2||\"\")+\"__.push('\"})+\"');}return __;\")}function r(e,l){e._wrap=n(e,!0,t.isArray(l)?l:[h.test(l)?l:t(l).html()]).join(\"\")}function i(t){return t?t.replace(/\\\\'/g,\"'\").replace(/\\\\\\\\/g,\"\\\\\"):null}function p(t){var e=document.createElement(\"div\");return e.appendChild(t.cloneNode(!0)),e.innerHTML}function o(n){function l(n){function l(t){t+=u,i=c[t]=c[t]||e(i,y[i.parent.key+u]||i.parent)}var a,r,i,p,o=n;if(p=n.getAttribute(_)){for(;o.parentNode&&1===(o=o.parentNode).nodeType&&!(a=o.getAttribute(_)););a!==p&&(o=o.parentNode?11===o.nodeType?0:o.getAttribute(_)||0:0,(i=y[p])||(i=g[p],i=e(i,y[o]||g[o]),i.key=++w,y[w]=i),k&&l(p)),n.removeAttribute(_)}else k&&(i=t.data(n,\"tmplItem\"))&&(l(i.key),y[i.key]=i,o=t.data(n.parentNode,\"tmplItem\"),o=o?o.key:0);if(i){for(r=i;r&&r.key!=o;)r.nodes.push(n),r=r.parent;delete i._ctnt,delete i._wrap,t.data(n,\"tmplItem\",i)}}var a,r,i,p,o,u=\"_\"+k,c={};for(i=0,p=n.length;p>i;i++)if(1===(a=n[i]).nodeType){for(r=a.getElementsByTagName(\"*\"),o=r.length-1;o>=0;o--)l(r[o]);l(a)}}function u(t,e,n,l){return t?void T.push({_:t,tmpl:e,item:this,data:n,options:l}):T.pop()}function c(e,n,l){return t.tmpl(t.template(e),n,l,this)}function f(e,n){var l=e.options||{};return l.wrapped=n,t.tmpl(t.template(e.tmpl),e.data,l,e.item)}function m(e,n){var l=this._wrap;return t.map(t(t.isArray(l)?l.join(\"\"):l).filter(e||\"*\"),function(t){return n?t.innerText||t.textContent:t.outerHTML||p(t)})}function s(){var e=this.nodes;t.tmpl(null,null,null,this).insertBefore(e[0]),t(e).remove()}var d,$=t.fn.domManip,_=\"_tmplitem\",h=/^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! /,y={},g={},v={key:0,data:{}},w=0,k=0,T=[];t.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,n){t.fn[e]=function(l){var a,r,i,p,o=[],u=t(l),c=1===this.length&&this[0].parentNode;if(d=y||{},c&&11===c.nodeType&&1===c.childNodes.length&&1===u.length)u[n](this[0]),o=this;else{for(r=0,i=u.length;i>r;r++)k=r,a=(r>0?this.clone(!0):this).get(),t(u[r])[n](a),o=o.concat(a);k=0,o=this.pushStack(o,e,u.selector)}return p=d,d=null,t.tmpl.complete(p),o}}),t.fn.extend({tmpl:function(e,n,l){return t.tmpl(this[0],e,n,l)},tmplItem:function(){return t.tmplItem(this[0])},template:function(e){return t.template(e,this[0])},domManip:function(e,n,l){if(e[0]&&t.isArray(e[0])){for(var a,r=t.makeArray(arguments),i=e[0],p=i.length,o=0;p>o&&!(a=t.data(i[o++],\"tmplItem\")););a&&k&&(r[2]=function(e){t.tmpl.afterManip(this,e,l)}),$.apply(this,r)}else $.apply(this,arguments);return k=0,d||t.tmpl.complete(y),this}}),t.extend({tmpl:function(l,a,i,p){var o,u=!p;if(u)p=v,l=t.template[l]||t.template(null,l),g={};else if(!l)return l=p.tmpl,y[p.key]=p,p.nodes=[],p.wrapped&&r(p,p.wrapped),t(n(p,null,p.tmpl(t,p)));return l?(\"function\"==typeof a&&(a=a.call(p||{})),i&&i.wrapped&&r(i,i.wrapped),o=t.isArray(a)?t.map(a,function(t){return t?e(i,p,l,t):null}):[e(i,p,l,a)],u?t(n(p,null,o)):o):[]},tmplItem:function(e){var n;for(e instanceof t&&(e=e[0]);e&&1===e.nodeType&&!(n=t.data(e,\"tmplItem\"))&&(e=e.parentNode););return n||v},template:function(e,n){return n?(\"string\"==typeof n?n=a(n):n instanceof t&&(n=n[0]||{}),n.nodeType&&(n=t.data(n,\"tmpl\")||t.data(n,\"tmpl\",a(n.innerHTML))),\"string\"==typeof e?t.template[e]=n:n):e?\"string\"!=typeof e?t.template(null,e):t.template[e]||t.template(null,h.test(e)?e:t(e)):null},encode:function(t){return(\"\"+t).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\")}}),t.extend(t.tmpl,{tag:{tmpl:{_default:{$2:\"null\"},open:\"if($notnull_1){__=__.concat($item.nest($1,$2));}\"},wrap:{_default:{$2:\"null\"},open:\"$item.calls(__,$1,$2);__=[];\",close:\"call=$item.calls();__=call._.concat($item.wrap(call,__));\"},each:{_default:{$2:\"$index, $value\"},open:\"if($notnull_1){$.each($1a,function($2){with(this){\",close:\"}});}\"},\"if\":{open:\"if(($notnull_1) && $1a){\",close:\"}\"},\"else\":{_default:{$1:\"true\"},open:\"}else if(($notnull_1) && $1a){\"},html:{open:\"if($notnull_1){__.push($1a);}\"},\"=\":{_default:{$1:\"$data\"},open:\"if($notnull_1){__.push($.encode($1a));}\"},\"!\":{open:\"\"}},complete:function(){y={}},afterManip:function(e,n,l){var a=11===n.nodeType?t.makeArray(n.childNodes):1===n.nodeType?[n]:[];l.call(e,n),o(a),k++}})});"
        },
        {
          "name": "jquery.tmplPlus.js",
          "type": "blob",
          "size": 3.21875,
          "content": "/*!\n * tmplPlus.js: for jQuery Templates Plugin 1.0.0pre\n * Additional templating features or support for more advanced/less common scenarios.\n * Requires jquery.tmpl.js\n * http://github.com/jquery/jquery-tmpl\n *\n * Copyright 2011, Software Freedom Conservancy, Inc.\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n */\n(function( factory ) {\n    if (typeof define === 'function' && define.amd) {\n        // Loading from AMD script loader. Register as an anonymous module.\n        define( ['jquery'], factory );\n    } else {\n        // Browser using plain <script> tag\n        factory( jQuery );\n    }\n}(function( jQuery ){\n\tvar oldComplete = jQuery.tmpl.complete, oldManip = jQuery.fn.domManip;\n\n\t// Override jQuery.tmpl.complete in order to provide rendered event.\n\tjQuery.tmpl.complete = function( tmplItems ) {\n\t\tvar tmplItem;\n\t\toldComplete( tmplItems);\n\t\tfor ( tmplItem in tmplItems ) {\n\t\t\ttmplItem =  tmplItems[tmplItem];\n\t\t\tif ( tmplItem.addedTmplItems && jQuery.inArray( tmplItem, tmplItem.addedTmplItems ) === -1  ) {\n\t\t\t\ttmplItem.addedTmplItems.push( tmplItem );\n\t\t\t}\n\t\t}\n\t\tfor ( tmplItem in tmplItems ) {\n\t\t\ttmplItem =  tmplItems[tmplItem];\n\t\t\t// Raise rendered event\n\t\t\tif ( tmplItem.rendered ) {\n\t\t\t\ttmplItem.rendered( tmplItem );\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.extend({\n\t\ttmplCmd: function( command, data, tmplItems ) {\n\t\t\tvar retTmplItems = [], before;\n\t\t\tfunction find( data, tmplItems ) {\n\t\t\t\tvar found = [], tmplItem, ti, tl = tmplItems.length, dataItem, di = 0, dl = data.length;\n\t\t\t\tfor ( ; di < dl; ) {\n\t\t\t\t\tdataItem = data[di++];\n\t\t\t\t\tfor ( ti = 0; ti < tl; ) {\n\t\t\t\t\t\ttmplItem = tmplItems[ti++];\n\t\t\t\t\t\tif ( tmplItem.data === dataItem ) {\n\t\t\t\t\t\t\tfound.push( tmplItem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn found;\n\t\t\t}\n\n\t\t\tdata = jQuery.isArray( data ) ? data : [ data ];\n\t\t\tswitch ( command ) {\n\t\t\t\tcase \"find\":\n\t\t\t\t\treturn find( data, tmplItems );\n\t\t\t\tcase \"replace\":\n\t\t\t\t\tdata.reverse();\n\t\t\t}\n\t\t\tjQuery.each( tmplItems ? find( data, tmplItems ) : data, function( i, tmplItem ) {\n\t\t\t\tcoll = tmplItem.nodes;\n\t\t\t\tswitch ( command ) {\n\t\t\t\t\tcase \"update\":\n\t\t\t\t\t\ttmplItem.update();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"remove\":\n\t\t\t\t\t\tjQuery( coll ).remove();\n\t\t\t\t\t\tif ( tmplItems ) {\n\t\t\t\t\t\t\ttmplItems.splice( jQuery.inArray( tmplItem, tmplItems ), 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"replace\":\n\t\t\t\t\t\tbefore = before ?\n\t\t\t\t\t\t\tjQuery( coll ).insertBefore( before )[0] :\n\t\t\t\t\t\t\tjQuery( coll ).appendTo( coll[0].parentNode )[0];\n\t\t\t\t\t\tretTmplItems.unshift( tmplItem );\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn retTmplItems;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tdomManip: function (args, table, callback, options) {\n\t\t\tvar data = args[1], tmpl = args[0], dmArgs;\n\t\t\tif ( args.length >= 2 && typeof data === \"object\" && !data.nodeType && !(data instanceof jQuery)) {\n\t\t\t\t// args[1] is data, for a template.\n\t\t\t\tdmArgs = jQuery.makeArray( arguments );\n\n\t\t\t\t// Eval template to obtain fragment to clone and insert\n\t\t\t\tdmArgs[0] = [ jQuery.tmpl( jQuery.template( tmpl ), data, args[2], args[3] ) ];\n\n\t\t\t\tdmArgs[2] = function( fragClone ) {\n\t\t\t\t\t// Handler called by oldManip when rendered template has been inserted into DOM.\n\t\t\t\t\tjQuery.tmpl.afterManip( this, fragClone, callback );\n\t\t\t\t};\n\t\t\t\treturn oldManip.apply( this, dmArgs );\n\t\t\t}\n\t\t\treturn oldManip.apply( this, arguments );\n\t\t}\n\t});\n}));\n"
        },
        {
          "name": "jquery.tmplPlus.min.js",
          "type": "blob",
          "size": 1.439453125,
          "content": "/*!\n * tmplPlus.js: for jQuery Templates Plugin 1.0.0pre\n * Additional templating features or support for more advanced/less common scenarios.\n * Requires jquery.tmpl.js\n * http://github.com/jquery/jquery-tmpl\n *\n * Copyright 2011, Software Freedom Conservancy, Inc.\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n */\n!function(e){\"function\"==typeof define&&define.amd?define([\"jquery\"],e):e(jQuery)}(function(e){var t=e.tmpl.complete,n=e.fn.domManip;e.tmpl.complete=function(n){var r;t(n);for(r in n)r=n[r],r.addedTmplItems&&-1===e.inArray(r,r.addedTmplItems)&&r.addedTmplItems.push(r);for(r in n)r=n[r],r.rendered&&r.rendered(r)},e.extend({tmplCmd:function(t,n,r){function a(e,t){for(var n,r,a,l=[],p=t.length,o=0,i=e.length;i>o;)for(a=e[o++],r=0;p>r;)n=t[r++],n.data===a&&l.push(n);return l}var l,p=[];switch(n=e.isArray(n)?n:[n],t){case\"find\":return a(n,r);case\"replace\":n.reverse()}return e.each(r?a(n,r):n,function(n,a){switch(coll=a.nodes,t){case\"update\":a.update();break;case\"remove\":e(coll).remove(),r&&r.splice(e.inArray(a,r),1);break;case\"replace\":l=l?e(coll).insertBefore(l)[0]:e(coll).appendTo(coll[0].parentNode)[0],p.unshift(a)}}),p}}),e.fn.extend({domManip:function(t,r,a){var l,p=t[1],o=t[0];return t.length<2||\"object\"!=typeof p||p.nodeType||p instanceof e?n.apply(this,arguments):(l=e.makeArray(arguments),l[0]=[e.tmpl(e.template(o),p,t[2],t[3])],l[2]=function(t){e.tmpl.afterManip(this,t,a)},n.apply(this,l))}})});"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}