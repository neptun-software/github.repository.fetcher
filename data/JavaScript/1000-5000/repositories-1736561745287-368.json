{
  "metadata": {
    "timestamp": 1736561745287,
    "page": 368,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "farzher/fuzzysort",
      "stars": 4031,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2018 Stephen Kamenar\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.134765625,
          "content": "<p align=\"center\"><a href=\"https://raw.github.com/farzher/fuzzysort/master/fuzzysort.js\">\n  <img src=\"https://i.imgur.com/axkOMVs.png\" alt=\"fuzzysort\" />\n</a></p>\n\n<p align=\"center\">\n  Fast, Tiny, & Good fuzzy search for JavaScript.\n</p>\n\n<p align=\"center\">\n  <b>Fast:</b> <b>&lt;1ms</b> to search <b>13,000</b> files.\n  <br>\n  <b>Tiny:</b> <b>1 file</b>, <b>0 dependencies</b>, <b>5kb</b>.\n  <br>\n  <b>Good:</b> clean api + sorts results well.\n</p>\n\n\n## [Demo](https://rawgit.com/farzher/fuzzysort/master/test/test.html)\n\nhttps://rawgit.com/farzher/fuzzysort/master/test/test.html\n\n![](https://i.imgur.com/muaw363.gif)\n\n![](https://i.imgur.com/SXC9A3q.png)\n\n![](https://i.imgur.com/fUkJ7G3.png)\n\n![](https://i.imgur.com/CnVXRbf.png)\n\n\n\n\n\n## Installation Node / Bun / Deno\n\n```sh\nnpm i fuzzysort\n```\n```js\nimport fuzzysort from 'fuzzysort'\n```\n```js\nconst fuzzysort = require('fuzzysort')\n```\n\n\n\n## Installation Browser\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/fuzzysort@3.1.0/fuzzysort.min.js\"></script>\n```\n\n\n## Usage\n\n### `fuzzysort.go(search, targets, options=null)`\n\n```js\nconst mystuff = [{file: 'Apple.cpp'}, {file: 'Banana.cpp'}]\nconst results = fuzzysort.go('a', mystuff, {key: 'file'})\n// [{score: 0.81, obj: {file: 'Apple.cpp'}}, {score: 0.59, obj: {file: 'Banana.cpp'}}]\n```\n\n### Options\n\n```js\nfuzzysort.go(search, targets, {\n  threshold: 0,    // Don't return matches worse than this\n  limit: 0,        // Don't return more results than this\n  all: false,      // If true, returns all results for an empty search\n\n  key: null,       // For when targets are objects (see its example usage)\n  keys: null,      // For when targets are objects (see its example usage)\n  scoreFn: null,   // For use with `keys` (see its example usage)\n})\n```\n\n\n\n\n## What's a `result`\n\n```js\nconst result = fuzzysort.single('query', 'some string that contains my query.')\nresult.score       // .80 (1 is a perfect match. 0.5 is a good match. 0 is no match.)\nresult.target      // 'some string that contains my query.'\nresult.obj         // reference to your original obj when using options.key\nresult.indexes     // [29, 30, 31, 32, 33]\n\nresult.highlight('<b>', '</b>')\n// 'some string that contains my <b>query</b>.'\n\nresult.highlight((m, i) => <react key={i}>{m}</react>)\n// ['some string that contains my ', <react key=0>query</react>, '.']\n```\n\n### Advanced Usage\n\nSearch a list of objects, by multiple complex keys, with custom weights.\n\n```js\nlet objects = [{\n  title: 'Liechi Berry',\n  meta: {desc: 'Raises Attack when HP is low.'},\n  tags: ['berries', 'items'],\n  bookmarked: true,\n}, {\n  title: 'Petaya Berry',\n  meta: {desc: 'Raises Special Attack when HP is low.'},\n}]\n\nlet results = fuzzysort.go('attack berry', objects, {\n  keys: ['title', 'meta.desc', obj => obj.tags?.join()],\n  scoreFn: r => r.score * r.obj.bookmarked ? 2 : 1, // if the item is bookmarked, boost its score\n})\n\nvar keysResult = results[0]\n// When using multiple `keys`, results are different. They're indexable to get each normal result\nkeysResult[0].highlight() // 'Liechi <b>Berry</b>'\nkeysResult[1].highlight() // 'Raises <b>Attack</b> when HP is low.'\nkeysResult.score          // .84\nkeysResult.obj.title      // 'Liechi Berry'\n```\n\n\n\n## How To Go Fast · Performance Tips\n\n```js\nlet targets = [{file: 'Monitor.cpp'}, {file: 'MeshRenderer.cpp'}]\n\n// filter out targets that you don't need to search! especially long ones!\ntargets = targets.filter(t => t.file.length < 1000)\n\n// if your targets don't change often, provide prepared targets instead of raw strings!\ntargets.forEach(t => t.filePrepared = fuzzysort.prepare(t.file))\n\n// don't use options.key if you don't need a reference to your original obj\ntargets = targets.map(t => t.filePrepared)\n\nconst options = {\n  limit: 100,    // don't return more results than you need!\n  threshold: .5, // don't return bad results\n}\nfuzzysort.go('gotta', targets, options)\nfuzzysort.go('go',    targets, options)\nfuzzysort.go('fast',  targets, options)\n```\n\n\n### Gotcha\n`result.score` is implemented as a getter/setter and stored different internally\n`r.score = .3; // r.score == 0.30000000000000004`\n\n\n\n\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=farzher/fuzzysort)](https://star-history.com/#farzher/fuzzysort)\n\n\n\n### Changelog\n\n#### v3.1.0\n- Automatically handle diacritics / accents / ligatures\n\n#### v3.0.0\n- Added new behavior when using `keys` and your search contains spaces!\n- Added `options.key` can now be a function `{key: obj => obj.tags.join()}`\n- Removed `fuzzysort.indexes` & Added `result.indexes` (as a getter/setter for GC perf)\n- Removed `fuzzysort.highlight()` & Added `result.highlight()`\n- Changed scoring: score is now a number from 0 to 1 instead of from -Infinity to 0\n- Changed scoring: substring matches are even more relevant\n- Changed scoring: `straw berry` now matches great against `strawberry`\n- Changed scoring: tweaked the scoring quite a bit\n- `result.score` is behind a getter/setter for performance reasons\n- Fixed minor issues\n\n#### v2.0.0\n- Added new behavior when your search contains spaces!\n- Added fuzzysort.min.js\n- Now depends on ES6 features\n- Removed `result.indexes` & Added `fuzzysort.indexes` (improved GC performance)\n- Completely Removed `options.allowTypo`\n- Completely Removed `fuzzysort.goAsync`\n- Completely Removed `fuzzysort.new`\n- Rewrote the demo\n\n#### v1.9.0\n- Even faster\n- Added `options.all`\n- Deprecated/Removed `options.allowTypo`\n- Deprecated/Removed `fuzzysort.goAsync`\n- Changed scoring: boosted substring matches\n- Changed scoring: targets with too many beginning indexes lose points for being a bad target\n- Changed scoring: penality for not starting near the beginning\n- Changed scoring: penality for more groups\n- Fixed \"Exponential backtracking hangs browser\"\n\n#### v1.2.0\n- Added `fuzzysort.highlight(result, callback)`\n\n#### v1.1.0\n- Added `allowTypo` as an option\n\n#### v1.0.0\n\n- Inverted scores; they're now negative instead of positive, so that higher scores are better\n- Added ability to search objects by `key`/`keys` with custom weights\n- Removed the option to automatically highlight and exposed `fuzzysort.highlight`\n- Removed all options from `fuzzysort` and moved them into `fuzzysort.go` optional params\n\n#### v0.x.x\n\n- init\n"
        },
        {
          "name": "fuzzysort.js",
          "type": "blob",
          "size": 26.5927734375,
          "content": "// https://github.com/farzher/fuzzysort v3.0.2\n\n// UMD (Universal Module Definition) for fuzzysort\n;((root, UMD) => {\n  if(typeof define === 'function' && define.amd) define([], UMD)\n  else if(typeof module === 'object' && module.exports) module.exports = UMD()\n  else root['fuzzysort'] = UMD()\n})(this, _ => {\n  'use strict'\n\n  var single = (search, target) => {\n    if(!search || !target) return NULL\n\n    var preparedSearch = getPreparedSearch(search)\n    if(!isPrepared(target)) target = getPrepared(target)\n\n    var searchBitflags = preparedSearch.bitflags\n    if((searchBitflags & target._bitflags) !== searchBitflags) return NULL\n\n    return algorithm(preparedSearch, target)\n  }\n\n  var go = (search, targets, options) => {\n    if(!search) return options?.all ? all(targets, options) : noResults\n\n    var preparedSearch = getPreparedSearch(search)\n    var searchBitflags = preparedSearch.bitflags\n    var containsSpace  = preparedSearch.containsSpace\n\n    var threshold = denormalizeScore( options?.threshold || 0 )\n    var limit     = options?.limit || INFINITY\n\n    var resultsLen = 0; var limitedCount = 0\n    var targetsLen = targets.length\n\n    function push_result(result) {\n      if(resultsLen < limit) { q.add(result); ++resultsLen }\n      else {\n        ++limitedCount\n        if(result._score > q.peek()._score) q.replaceTop(result)\n      }\n    }\n\n    // This code is copy/pasted 3 times for performance reasons [options.key, options.keys, no keys]\n\n    // options.key\n    if(options?.key) {\n      var key = options.key\n      for(var i = 0; i < targetsLen; ++i) { var obj = targets[i]\n        var target = getValue(obj, key)\n        if(!target) continue\n        if(!isPrepared(target)) target = getPrepared(target)\n\n        if((searchBitflags & target._bitflags) !== searchBitflags) continue\n        var result = algorithm(preparedSearch, target)\n        if(result === NULL) continue\n        if(result._score < threshold) continue\n\n        result.obj = obj\n        push_result(result)\n      }\n\n    // options.keys\n    } else if(options?.keys) {\n      var keys = options.keys\n      var keysLen = keys.length\n\n      outer: for(var i = 0; i < targetsLen; ++i) { var obj = targets[i]\n\n        { // early out based on bitflags\n          var keysBitflags = 0\n          for (var keyI = 0; keyI < keysLen; ++keyI) {\n            var key = keys[keyI]\n            var target = getValue(obj, key)\n            if(!target) { tmpTargets[keyI] = noTarget; continue }\n            if(!isPrepared(target)) target = getPrepared(target)\n            tmpTargets[keyI] = target\n\n            keysBitflags |= target._bitflags\n          }\n\n          if((searchBitflags & keysBitflags) !== searchBitflags) continue\n        }\n\n        if(containsSpace) for(let i=0; i<preparedSearch.spaceSearches.length; i++) keysSpacesBestScores[i] = NEGATIVE_INFINITY\n\n        for (var keyI = 0; keyI < keysLen; ++keyI) {\n          target = tmpTargets[keyI]\n          if(target === noTarget) { tmpResults[keyI] = noTarget; continue }\n\n          tmpResults[keyI] = algorithm(preparedSearch, target, /*allowSpaces=*/false, /*allowPartialMatch=*/containsSpace)\n          if(tmpResults[keyI] === NULL) { tmpResults[keyI] = noTarget; continue }\n\n          // todo: this seems weird and wrong. like what if our first match wasn't good. this should just replace it instead of averaging with it\n          // if our second match isn't good we ignore it instead of averaging with it\n          if(containsSpace) for(let i=0; i<preparedSearch.spaceSearches.length; i++) {\n            if(allowPartialMatchScores[i] > -1000) {\n              if(keysSpacesBestScores[i] > NEGATIVE_INFINITY) {\n                var tmp = (keysSpacesBestScores[i] + allowPartialMatchScores[i]) / 4/*bonus score for having multiple matches*/\n                if(tmp > keysSpacesBestScores[i]) keysSpacesBestScores[i] = tmp\n              }\n            }\n            if(allowPartialMatchScores[i] > keysSpacesBestScores[i]) keysSpacesBestScores[i] = allowPartialMatchScores[i]\n          }\n        }\n\n        if(containsSpace) {\n          for(let i=0; i<preparedSearch.spaceSearches.length; i++) { if(keysSpacesBestScores[i] === NEGATIVE_INFINITY) continue outer }\n        } else {\n          var hasAtLeast1Match = false\n          for(let i=0; i < keysLen; i++) { if(tmpResults[i]._score !== NEGATIVE_INFINITY) { hasAtLeast1Match = true; break } }\n          if(!hasAtLeast1Match) continue\n        }\n\n        var objResults = new KeysResult(keysLen)\n        for(let i=0; i < keysLen; i++) { objResults[i] = tmpResults[i] }\n\n        if(containsSpace) {\n          var score = 0\n          for(let i=0; i<preparedSearch.spaceSearches.length; i++) score += keysSpacesBestScores[i]\n        } else {\n          // todo could rewrite this scoring to be more similar to when there's spaces\n          // if we match multiple keys give us bonus points\n          var score = NEGATIVE_INFINITY\n          for(let i=0; i<keysLen; i++) {\n            var result = objResults[i]\n            if(result._score > -1000) {\n              if(score > NEGATIVE_INFINITY) {\n                var tmp = (score + result._score) / 4/*bonus score for having multiple matches*/\n                if(tmp > score) score = tmp\n              }\n            }\n            if(result._score > score) score = result._score\n          }\n        }\n\n        objResults.obj = obj\n        objResults._score = score\n        if(options?.scoreFn) {\n          score = options.scoreFn(objResults)\n          if(!score) continue\n          score = denormalizeScore(score)\n          objResults._score = score\n        }\n\n        if(score < threshold) continue\n        push_result(objResults)\n      }\n\n    // no keys\n    } else {\n      for(var i = 0; i < targetsLen; ++i) { var target = targets[i]\n        if(!target) continue\n        if(!isPrepared(target)) target = getPrepared(target)\n\n        if((searchBitflags & target._bitflags) !== searchBitflags) continue\n        var result = algorithm(preparedSearch, target)\n        if(result === NULL) continue\n        if(result._score < threshold) continue\n\n        push_result(result)\n      }\n    }\n\n    if(resultsLen === 0) return noResults\n    var results = new Array(resultsLen)\n    for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\n    results.total = resultsLen + limitedCount\n    return results\n  }\n\n\n  // this is written as 1 function instead of 2 for minification. perf seems fine ...\n  // except when minified. the perf is very slow\n  var highlight = (result, open='<b>', close='</b>') => {\n    var callback = typeof open === 'function' ? open : undefined\n\n    var target      = result.target\n    var targetLen   = target.length\n    var indexes     = result.indexes\n    var highlighted = ''\n    var matchI      = 0\n    var indexesI    = 0\n    var opened      = false\n    var parts       = []\n\n    for(var i = 0; i < targetLen; ++i) { var char = target[i]\n      if(indexes[indexesI] === i) {\n        ++indexesI\n        if(!opened) { opened = true\n          if(callback) {\n            parts.push(highlighted); highlighted = ''\n          } else {\n            highlighted += open\n          }\n        }\n\n        if(indexesI === indexes.length) {\n          if(callback) {\n            highlighted += char\n            parts.push(callback(highlighted, matchI++)); highlighted = ''\n            parts.push(target.substr(i+1))\n          } else {\n            highlighted += char + close + target.substr(i+1)\n          }\n          break\n        }\n      } else {\n        if(opened) { opened = false\n          if(callback) {\n            parts.push(callback(highlighted, matchI++)); highlighted = ''\n          } else {\n            highlighted += close\n          }\n        }\n      }\n      highlighted += char\n    }\n\n    return callback ? parts : highlighted\n  }\n\n\n  var prepare = (target) => {\n    if(typeof target === 'number') target = ''+target\n    else if(typeof target !== 'string') target = ''\n    var info = prepareLowerInfo(target)\n    return new_result(target, {_targetLower:info._lower, _targetLowerCodes:info.lowerCodes, _bitflags:info.bitflags})\n  }\n\n  var cleanup = () => { preparedCache.clear(); preparedSearchCache.clear() }\n\n\n  // Below this point is only internal code\n  // Below this point is only internal code\n  // Below this point is only internal code\n  // Below this point is only internal code\n\n\n  class Result {\n    get ['indexes']() { return this._indexes.slice(0, this._indexes.len).sort((a,b)=>a-b) }\n    set ['indexes'](indexes) { return this._indexes = indexes }\n    ['highlight'](open, close) { return highlight(this, open, close) }\n    get ['score']() { return normalizeScore(this._score) }\n    set ['score'](score) { this._score = denormalizeScore(score) }\n  }\n\n  class KeysResult extends Array {\n    get ['score']() { return normalizeScore(this._score) }\n    set ['score'](score) { this._score = denormalizeScore(score) }\n  }\n\n  var new_result = (target, options) => {\n    const result = new Result()\n    result['target']             = target\n    result['obj']                = options.obj                   ?? NULL\n    result._score                = options._score                ?? NEGATIVE_INFINITY\n    result._indexes              = options._indexes              ?? []\n    result._targetLower          = options._targetLower          ?? ''\n    result._targetLowerCodes     = options._targetLowerCodes     ?? NULL\n    result._nextBeginningIndexes = options._nextBeginningIndexes ?? NULL\n    result._bitflags             = options._bitflags             ?? 0\n    return result\n  }\n\n\n  var normalizeScore = score => {\n    if(score === NEGATIVE_INFINITY) return 0\n    if(score > 1) return score\n    return Math.E ** ( ((-score + 1)**.04307 - 1) * -2)\n  }\n  var denormalizeScore = normalizedScore => {\n    if(normalizedScore === 0) return NEGATIVE_INFINITY\n    if(normalizedScore > 1) return normalizedScore\n    return 1 - Math.pow((Math.log(normalizedScore) / -2 + 1), 1 / 0.04307)\n  }\n\n\n  var prepareSearch = (search) => {\n    if(typeof search === 'number') search = ''+search\n    else if(typeof search !== 'string') search = ''\n    search = search.trim()\n    var info = prepareLowerInfo(search)\n\n    var spaceSearches = []\n    if(info.containsSpace) {\n      var searches = search.split(/\\s+/)\n      searches = [...new Set(searches)] // distinct\n      for(var i=0; i<searches.length; i++) {\n        if(searches[i] === '') continue\n        var _info = prepareLowerInfo(searches[i])\n        spaceSearches.push({lowerCodes:_info.lowerCodes, _lower:searches[i].toLowerCase(), containsSpace:false})\n      }\n    }\n\n    return {lowerCodes: info.lowerCodes, _lower: info._lower, containsSpace: info.containsSpace, bitflags: info.bitflags, spaceSearches: spaceSearches}\n  }\n\n\n\n  var getPrepared = (target) => {\n    if(target.length > 999) return prepare(target) // don't cache huge targets\n    var targetPrepared = preparedCache.get(target)\n    if(targetPrepared !== undefined) return targetPrepared\n    targetPrepared = prepare(target)\n    preparedCache.set(target, targetPrepared)\n    return targetPrepared\n  }\n  var getPreparedSearch = (search) => {\n    if(search.length > 999) return prepareSearch(search) // don't cache huge searches\n    var searchPrepared = preparedSearchCache.get(search)\n    if(searchPrepared !== undefined) return searchPrepared\n    searchPrepared = prepareSearch(search)\n    preparedSearchCache.set(search, searchPrepared)\n    return searchPrepared\n  }\n\n\n  var all = (targets, options) => {\n    var results = []; results.total = targets.length // this total can be wrong if some targets are skipped\n\n    var limit = options?.limit || INFINITY\n\n    if(options?.key) {\n      for(var i=0;i<targets.length;i++) { var obj = targets[i]\n        var target = getValue(obj, options.key)\n        if(target == NULL) continue\n        if(!isPrepared(target)) target = getPrepared(target)\n        var result = new_result(target.target, {_score: target._score, obj: obj})\n        results.push(result); if(results.length >= limit) return results\n      }\n    } else if(options?.keys) {\n      for(var i=0;i<targets.length;i++) { var obj = targets[i]\n        var objResults = new KeysResult(options.keys.length)\n        for (var keyI = options.keys.length - 1; keyI >= 0; --keyI) {\n          var target = getValue(obj, options.keys[keyI])\n          if(!target) { objResults[keyI] = noTarget; continue }\n          if(!isPrepared(target)) target = getPrepared(target)\n          target._score = NEGATIVE_INFINITY\n          target._indexes.len = 0\n          objResults[keyI] = target\n        }\n        objResults.obj = obj\n        objResults._score = NEGATIVE_INFINITY\n        results.push(objResults); if(results.length >= limit) return results\n      }\n    } else {\n      for(var i=0;i<targets.length;i++) { var target = targets[i]\n        if(target == NULL) continue\n        if(!isPrepared(target)) target = getPrepared(target)\n        target._score = NEGATIVE_INFINITY\n        target._indexes.len = 0\n        results.push(target); if(results.length >= limit) return results\n      }\n    }\n\n    return results\n  }\n\n\n  var algorithm = (preparedSearch, prepared, allowSpaces=false, allowPartialMatch=false) => {\n    if(allowSpaces===false && preparedSearch.containsSpace) return algorithmSpaces(preparedSearch, prepared, allowPartialMatch)\n\n    var searchLower      = preparedSearch._lower\n    var searchLowerCodes = preparedSearch.lowerCodes\n    var searchLowerCode  = searchLowerCodes[0]\n    var targetLowerCodes = prepared._targetLowerCodes\n    var searchLen        = searchLowerCodes.length\n    var targetLen        = targetLowerCodes.length\n    var searchI          = 0 // where we at\n    var targetI          = 0 // where you at\n    var matchesSimpleLen = 0\n\n    // very basic fuzzy match; to remove non-matching targets ASAP!\n    // walk through target. find sequential matches.\n    // if all chars aren't found then exit\n    for(;;) {\n      var isMatch = searchLowerCode === targetLowerCodes[targetI]\n      if(isMatch) {\n        matchesSimple[matchesSimpleLen++] = targetI\n        ++searchI; if(searchI === searchLen) break\n        searchLowerCode = searchLowerCodes[searchI]\n      }\n      ++targetI; if(targetI >= targetLen) return NULL // Failed to find searchI\n    }\n\n    var searchI = 0\n    var successStrict = false\n    var matchesStrictLen = 0\n\n    var nextBeginningIndexes = prepared._nextBeginningIndexes\n    if(nextBeginningIndexes === NULL) nextBeginningIndexes = prepared._nextBeginningIndexes = prepareNextBeginningIndexes(prepared.target)\n    targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\n\n    // Our target string successfully matched all characters in sequence!\n    // Let's try a more advanced and strict test to improve the score\n    // only count it as a match if it's consecutive or a beginning character!\n    var backtrackCount = 0\n    if(targetI !== targetLen) for(;;) {\n      if(targetI >= targetLen) {\n        // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n        if(searchI <= 0) break // We failed to push chars forward for a better match\n\n        ++backtrackCount; if(backtrackCount > 200) break // exponential backtracking is taking too long, just give up and return a bad match\n\n        --searchI\n        var lastMatch = matchesStrict[--matchesStrictLen]\n        targetI = nextBeginningIndexes[lastMatch]\n\n      } else {\n        var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI]\n        if(isMatch) {\n          matchesStrict[matchesStrictLen++] = targetI\n          ++searchI; if(searchI === searchLen) { successStrict = true; break }\n          ++targetI\n        } else {\n          targetI = nextBeginningIndexes[targetI]\n        }\n      }\n    }\n\n    // check if it's a substring match\n    var substringIndex = searchLen <= 1 ? -1 : prepared._targetLower.indexOf(searchLower, matchesSimple[0]) // perf: this is slow\n    var isSubstring = !!~substringIndex\n    var isSubstringBeginning = !isSubstring ? false : substringIndex===0 || prepared._nextBeginningIndexes[substringIndex-1] === substringIndex\n\n    // if it's a substring match but not at a beginning index, let's try to find a substring starting at a beginning index for a better score\n    if(isSubstring && !isSubstringBeginning) {\n      for(var i=0; i<nextBeginningIndexes.length; i=nextBeginningIndexes[i]) {\n        if(i <= substringIndex) continue\n\n        for(var s=0; s<searchLen; s++) if(searchLowerCodes[s] !== prepared._targetLowerCodes[i+s]) break\n        if(s === searchLen) { substringIndex = i; isSubstringBeginning = true; break }\n      }\n    }\n\n    // tally up the score & keep track of matches for highlighting later\n    // if it's a simple match, we'll switch to a substring match if a substring exists\n    // if it's a strict match, we'll switch to a substring match only if that's a better score\n\n    var calculateScore = matches => {\n      var score = 0\n\n      var extraMatchGroupCount = 0\n      for(var i = 1; i < searchLen; ++i) {\n        if(matches[i] - matches[i-1] !== 1) {score -= matches[i]; ++extraMatchGroupCount}\n      }\n      var unmatchedDistance = matches[searchLen-1] - matches[0] - (searchLen-1)\n\n      score -= (12+unmatchedDistance) * extraMatchGroupCount // penality for more groups\n\n      if(matches[0] !== 0) score -= matches[0]*matches[0]*.2 // penality for not starting near the beginning\n\n      if(!successStrict) {\n        score *= 1000\n      } else {\n        // successStrict on a target with too many beginning indexes loses points for being a bad target\n        var uniqueBeginningIndexes = 1\n        for(var i = nextBeginningIndexes[0]; i < targetLen; i=nextBeginningIndexes[i]) ++uniqueBeginningIndexes\n\n        if(uniqueBeginningIndexes > 24) score *= (uniqueBeginningIndexes-24)*10 // quite arbitrary numbers here ...\n      }\n\n      score -= (targetLen - searchLen)/2 // penality for longer targets\n\n      if(isSubstring)          score /= 1+searchLen*searchLen*1 // bonus for being a full substring\n      if(isSubstringBeginning) score /= 1+searchLen*searchLen*1 // bonus for substring starting on a beginningIndex\n\n      score -= (targetLen - searchLen)/2 // penality for longer targets\n\n      return score\n    }\n\n    if(!successStrict) {\n      if(isSubstring) for(var i=0; i<searchLen; ++i) matchesSimple[i] = substringIndex+i // at this point it's safe to overwrite matchehsSimple with substr matches\n      var matchesBest = matchesSimple\n      var score = calculateScore(matchesBest)\n    } else {\n      if(isSubstringBeginning) {\n        for(var i=0; i<searchLen; ++i) matchesSimple[i] = substringIndex+i // at this point it's safe to overwrite matchehsSimple with substr matches\n        var matchesBest = matchesSimple\n        var score = calculateScore(matchesSimple)\n      } else {\n        var matchesBest = matchesStrict\n        var score = calculateScore(matchesStrict)\n      }\n    }\n\n    prepared._score = score\n\n    for(var i = 0; i < searchLen; ++i) prepared._indexes[i] = matchesBest[i]\n    prepared._indexes.len = searchLen\n\n    const result    = new Result()\n    result.target   = prepared.target\n    result._score   = prepared._score\n    result._indexes = prepared._indexes\n    return result\n  }\n  var algorithmSpaces = (preparedSearch, target, allowPartialMatch) => {\n    var seen_indexes = new Set()\n    var score = 0\n    var result = NULL\n\n    var first_seen_index_last_search = 0\n    var searches = preparedSearch.spaceSearches\n    var searchesLen = searches.length\n    var changeslen = 0\n\n    // Return _nextBeginningIndexes back to its normal state\n    var resetNextBeginningIndexes = () => {\n      for(let i=changeslen-1; i>=0; i--) target._nextBeginningIndexes[nextBeginningIndexesChanges[i*2 + 0]] = nextBeginningIndexesChanges[i*2 + 1]\n    }\n\n    var hasAtLeast1Match = false\n    for(var i=0; i<searchesLen; ++i) {\n      allowPartialMatchScores[i] = NEGATIVE_INFINITY\n      var search = searches[i]\n\n      result = algorithm(search, target)\n      if(allowPartialMatch) {\n        if(result === NULL) continue\n        hasAtLeast1Match = true\n      } else {\n        if(result === NULL) {resetNextBeginningIndexes(); return NULL}\n      }\n\n      // if not the last search, we need to mutate _nextBeginningIndexes for the next search\n      var isTheLastSearch = i === searchesLen - 1\n      if(!isTheLastSearch) {\n        var indexes = result._indexes\n\n        var indexesIsConsecutiveSubstring = true\n        for(let i=0; i<indexes.len-1; i++) {\n          if(indexes[i+1] - indexes[i] !== 1) {\n            indexesIsConsecutiveSubstring = false; break;\n          }\n        }\n\n        if(indexesIsConsecutiveSubstring) {\n          var newBeginningIndex = indexes[indexes.len-1] + 1\n          var toReplace = target._nextBeginningIndexes[newBeginningIndex-1]\n          for(let i=newBeginningIndex-1; i>=0; i--) {\n            if(toReplace !== target._nextBeginningIndexes[i]) break\n            target._nextBeginningIndexes[i] = newBeginningIndex\n            nextBeginningIndexesChanges[changeslen*2 + 0] = i\n            nextBeginningIndexesChanges[changeslen*2 + 1] = toReplace\n            changeslen++\n          }\n        }\n      }\n\n      score += result._score / searchesLen\n      allowPartialMatchScores[i] = result._score / searchesLen\n\n      // dock points based on order otherwise \"c man\" returns Manifest.cpp instead of CheatManager.h\n      if(result._indexes[0] < first_seen_index_last_search) {\n        score -= (first_seen_index_last_search - result._indexes[0]) * 2\n      }\n      first_seen_index_last_search = result._indexes[0]\n\n      for(var j=0; j<result._indexes.len; ++j) seen_indexes.add(result._indexes[j])\n    }\n\n    if(allowPartialMatch && !hasAtLeast1Match) return NULL\n\n    resetNextBeginningIndexes()\n\n    // allows a search with spaces that's an exact substring to score well\n    var allowSpacesResult = algorithm(preparedSearch, target, /*allowSpaces=*/true)\n    if(allowSpacesResult !== NULL && allowSpacesResult._score > score) {\n      if(allowPartialMatch) {\n        for(var i=0; i<searchesLen; ++i) {\n          allowPartialMatchScores[i] = allowSpacesResult._score / searchesLen\n        }\n      }\n      return allowSpacesResult\n    }\n\n    if(allowPartialMatch) result = target\n    result._score = score\n\n    var i = 0\n    for (let index of seen_indexes) result._indexes[i++] = index\n    result._indexes.len = i\n\n    return result\n  }\n\n  // we use this instead of just .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') because that screws with japanese characters\n  var remove_accents = (str) => str.replace(/\\p{Script=Latin}+/gu, match => match.normalize('NFD')).replace(/[\\u0300-\\u036f]/g, '')\n\n  var prepareLowerInfo = (str) => {\n    str = remove_accents(str)\n    var strLen = str.length\n    var lower = str.toLowerCase()\n    var lowerCodes = [] // new Array(strLen)    sparse array is too slow\n    var bitflags = 0\n    var containsSpace = false // space isn't stored in bitflags because of how searching with a space works\n\n    for(var i = 0; i < strLen; ++i) {\n      var lowerCode = lowerCodes[i] = lower.charCodeAt(i)\n\n      if(lowerCode === 32) {\n        containsSpace = true\n        continue // it's important that we don't set any bitflags for space\n      }\n\n      var bit = lowerCode>=97&&lowerCode<=122 ? lowerCode-97 // alphabet\n              : lowerCode>=48&&lowerCode<=57  ? 26           // numbers\n                                                             // 3 bits available\n              : lowerCode<=127                ? 30           // other ascii\n              :                                 31           // other utf8\n      bitflags |= 1<<bit\n    }\n\n    return {lowerCodes:lowerCodes, bitflags:bitflags, containsSpace:containsSpace, _lower:lower}\n  }\n  var prepareBeginningIndexes = (target) => {\n    var targetLen = target.length\n    var beginningIndexes = []; var beginningIndexesLen = 0\n    var wasUpper = false\n    var wasAlphanum = false\n    for(var i = 0; i < targetLen; ++i) {\n      var targetCode = target.charCodeAt(i)\n      var isUpper = targetCode>=65&&targetCode<=90\n      var isAlphanum = isUpper || targetCode>=97&&targetCode<=122 || targetCode>=48&&targetCode<=57\n      var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum\n      wasUpper = isUpper\n      wasAlphanum = isAlphanum\n      if(isBeginning) beginningIndexes[beginningIndexesLen++] = i\n    }\n    return beginningIndexes\n  }\n  var prepareNextBeginningIndexes = (target) => {\n    target = remove_accents(target)\n    var targetLen = target.length\n    var beginningIndexes = prepareBeginningIndexes(target)\n    var nextBeginningIndexes = [] // new Array(targetLen)     sparse array is too slow\n    var lastIsBeginning = beginningIndexes[0]\n    var lastIsBeginningI = 0\n    for(var i = 0; i < targetLen; ++i) {\n      if(lastIsBeginning > i) {\n        nextBeginningIndexes[i] = lastIsBeginning\n      } else {\n        lastIsBeginning = beginningIndexes[++lastIsBeginningI]\n        nextBeginningIndexes[i] = lastIsBeginning===undefined ? targetLen : lastIsBeginning\n      }\n    }\n    return nextBeginningIndexes\n  }\n\n  var preparedCache       = new Map()\n  var preparedSearchCache = new Map()\n\n  // the theory behind these being globals is to reduce garbage collection by not making new arrays\n  var matchesSimple = []; var matchesStrict = []\n  var nextBeginningIndexesChanges = [] // allows straw berry to match strawberry well, by modifying the end of a substring to be considered a beginning index for the rest of the search\n  var keysSpacesBestScores = []; var allowPartialMatchScores = []\n  var tmpTargets = []; var tmpResults = []\n\n  // prop = 'key'                  2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n  // prop = 'key1.key2'            10ms\n  // prop = ['key1', 'key2']       27ms\n  // prop = obj => obj.tags.join() ??ms\n  var getValue = (obj, prop) => {\n    var tmp = obj[prop]; if(tmp !== undefined) return tmp\n    if(typeof prop === 'function') return prop(obj) // this should run first. but that makes string props slower\n    var segs = prop\n    if(!Array.isArray(prop)) segs = prop.split('.')\n    var len = segs.length\n    var i = -1\n    while (obj && (++i < len)) obj = obj[segs[i]]\n    return obj\n  }\n\n  var isPrepared = (x) => { return typeof x === 'object' && typeof x._bitflags === 'number' }\n  var INFINITY = Infinity; var NEGATIVE_INFINITY = -INFINITY\n  var noResults = []; noResults.total = 0\n  var NULL = null\n\n  var noTarget = prepare('')\n\n  // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n  var fastpriorityqueue=r=>{var e=[],o=0,a={},v=r=>{for(var a=0,v=e[a],c=1;c<o;){var s=c+1;a=c,s<o&&e[s]._score<e[c]._score&&(a=s),e[a-1>>1]=e[a],c=1+(a<<1)}for(var f=a-1>>1;a>0&&v._score<e[f]._score;f=(a=f)-1>>1)e[a]=e[f];e[a]=v};return a.add=(r=>{var a=o;e[o++]=r;for(var v=a-1>>1;a>0&&r._score<e[v]._score;v=(a=v)-1>>1)e[a]=e[v];e[a]=r}),a.poll=(r=>{if(0!==o){var a=e[0];return e[0]=e[--o],v(),a}}),a.peek=(r=>{if(0!==o)return e[0]}),a.replaceTop=(r=>{e[0]=r,v()}),a}\n  var q = fastpriorityqueue() // reuse this\n\n  // fuzzysort is written this way for minification. all names are mangeled unless quoted\n  return {'single':single, 'go':go, 'prepare':prepare, 'cleanup':cleanup}\n}) // UMD\n"
        },
        {
          "name": "fuzzysort.min.js",
          "type": "blob",
          "size": 6.5009765625,
          "content": "// https://github.com/farzher/fuzzysort v3.1.0\n((r,e)=>{\"function\"==typeof define&&define.amd?define([],e):\"object\"==typeof module&&module.exports?module.exports=e():r.fuzzysort=e()})(this,c=>{var f=r=>{\"number\"==typeof r?r=\"\"+r:\"string\"!=typeof r&&(r=\"\");var e=u(r);return x(r,{t:e.i,o:e.v,u:e.l})};class M{get[\"indexes\"](){return this.p.slice(0,this.p.g).sort((r,e)=>r-e)}set[\"indexes\"](r){return this.p=r}[\"highlight\"](r,e){return((r,e=\"<b>\",f=\"</b>\")=>{for(var t=\"function\"==typeof e?e:void 0,i=r.target,a=i.length,o=r.indexes,n=\"\",v=0,u=0,s=!1,l=[],c=0;c<a;++c){var p=i[c];if(o[u]===c){if(++u,s||(s=!0,t?(l.push(n),n=\"\"):n+=e),u===o.length){t?(l.push(t(n+=p,v++)),n=\"\",l.push(i.substr(c+1))):n+=p+f+i.substr(c+1);break}}else s&&(s=!1,t?(l.push(t(n,v++)),n=\"\"):n+=f);n+=p}return t?l:n})(this,r,e)}get[\"score\"](){return e(this.h)}set[\"score\"](r){this.h=A(r)}}class j extends Array{get[\"score\"](){return e(this.h)}set[\"score\"](r){this.h=A(r)}}var o,n,r,t,x=(r,e)=>{var f=new M;return f.target=r,f.obj=e.obj??Q,f.h=e.h??O,f.p=e.p??[],f.t=e.t??\"\",f.o=e.o??Q,f.k=e.k??Q,f.u=e.u??0,f},e=r=>r===O?0:1<r?r:Math.E**(-2*((1-r)**.04307-1)),A=r=>0===r?O:1<r?r:1-Math.pow(Math.log(r)/-2+1,1/.04307),i=r=>{\"number\"==typeof r?r=\"\"+r:\"string\"!=typeof r&&(r=\"\"),r=r.trim();var e=u(r),f=[];if(e.S)for(var t,i=r.split(/\\s+/),i=[...new Set(i)],a=0;a<i.length;a++)\"\"!==i[a]&&(t=u(i[a]),f.push({v:t.v,i:i[a].toLowerCase(),S:!1}));return{v:e.v,i:e.i,S:e.S,l:e.l,_:f}},L=r=>{var e;return 999<r.length?f(r):(void 0===(e=a.get(r))&&(e=f(r),a.set(r,e)),e)},D=r=>{var e;return 999<r.length?i(r):(void 0===(e=l.get(r))&&(e=i(r),l.set(r,e)),e)},F=(r,e,f=!1,t=!1)=>{if(!1===f&&r.S)return C(r,e,t);for(var f=r.i,i=r.v,a=i[0],o=e.o,n=i.length,v=o.length,u=0,s=0,l=0;;){if(a===o[s]){if(q[l++]=s,++u===n)break;a=i[u]}if(v<=++s)return Q}var u=0,c=!1,p=0,b=e.k,d=(b===Q&&(b=e.k=N(e.target)),0);if((s=0===q[0]?0:b[q[0]-1])!==v)for(;;)if(v<=s){if(u<=0)break;if(200<++d)break;--u;var w=z[--p],s=b[w]}else if(i[u]===o[s]){if(z[p++]=s,++u===n){c=!0;break}++s}else s=b[s];var g=n<=1?-1:e.t.indexOf(f,q[0]),h=!!~g,y=h&&(0===g||e.k[g-1]===g);if(h&&!y)for(var k=0;k<b.length;k=b[k])if(!(k<=g)){for(var S=0;S<n&&i[S]===e.o[k+S];S++);if(S===n){g=k,y=!0;break}}t=r=>{for(var e=0,f=0,t=1;t<n;++t)r[t]-r[t-1]!=1&&(e-=r[t],++f);if(e-=(12+(r[n-1]-r[0]-(n-1)))*f,0!==r[0]&&(e-=r[0]*r[0]*.2),c){for(var i=1,t=b[0];t<v;t=b[t])++i;24<i&&(e*=10*(i-24))}else e*=1e3;return e-=(v-n)/2,h&&(e/=1+n*n*1),y&&(e/=1+n*n*1),e-=(v-n)/2};if(c)if(y){for(k=0;k<n;++k)q[k]=g+k;_=q,m=t(q)}else _=z,m=t(z);else{if(h)for(var k=0;k<n;++k)q[k]=g+k;var _,m=t(_=q)}e.h=m;for(k=0;k<n;++k)e.p[k]=_[k];e.p.g=n;r=new M;return r.target=e.target,r.h=e.h,r.p=e.p,r},C=(r,e,f)=>{for(var t=new Set,i=0,a=Q,o=0,n=r._,v=n.length,u=0,s=()=>{for(let r=u-1;0<=r;r--)e.k[S[2*r+0]]=S[2*r+1]},l=!1,c=0;c<v;++c){E[c]=O;var p=n[c],a=F(p,e);if(f){if(a===Q)continue;l=!0}else if(a===Q)return s(),Q;if(!(c===v-1)){var b=a.p,d=!0;for(let r=0;r<b.g-1;r++)if(b[r+1]-b[r]!=1){d=!1;break}if(d){var w=b[b.g-1]+1,g=e.k[w-1];for(let r=w-1;0<=r&&g===e.k[r];r--)e.k[r]=w,S[2*u+0]=r,S[2*u+1]=g,u++}}i+=a.h/v,E[c]=a.h/v,a.p[0]<o&&(i-=2*(o-a.p[0]));for(var o=a.p[0],h=0;h<a.p.g;++h)t.add(a.p[h])}if(f&&!l)return Q;s();var y=F(r,e,!0);if(y!==Q&&y.h>i){if(f)for(c=0;c<v;++c)E[c]=y.h/v;return y}(a=f?e:a).h=i;var k,c=0;for(k of t)a.p[c++]=k;return a.p.g=c,a},v=r=>r.replace(/\\p{Script=Latin}+/gu,r=>r.normalize(\"NFD\")).replace(/[\\u0300-\\u036f]/g,\"\"),u=r=>{for(var e=(r=v(r)).length,f=r.toLowerCase(),t=[],i=0,a=!1,o=0;o<e;++o){var n=t[o]=f.charCodeAt(o);32===n?a=!0:i|=1<<(97<=n&&n<=122?n-97:48<=n&&n<=57?26:n<=127?30:31)}return{v:t,l:i,S:a,i:f}},s=r=>{for(var e=r.length,f=[],t=0,i=!1,a=!1,o=0;o<e;++o){var n=r.charCodeAt(o),v=65<=n&&n<=90,n=v||97<=n&&n<=122||48<=n&&n<=57,u=v&&!i||!a||!n,i=v,a=n;u&&(f[t++]=o)}return f},N=r=>{for(var e=(r=v(r)).length,f=s(r),t=[],i=f[0],a=0,o=0;o<e;++o)o<i?t[o]=i:(i=f[++a],t[o]=void 0===i?e:i);return t},a=new Map,l=new Map,q=[],z=[],S=[],B=[],E=[],G=[],H=[],I=(r,e)=>{var f=r[e];if(void 0!==f)return f;if(\"function\"==typeof e)return e(r);for(var t=e,i=(t=Array.isArray(e)?t:e.split(\".\")).length,a=-1;r&&++a<i;)r=r[t[a]];return r},J=r=>\"object\"==typeof r&&\"number\"==typeof r.u,K=1/0,O=-K,P=[],Q=(P.total=0,null),R=f(\"\"),T=(o=[],n=0,t=r=>{for(var e=o[i=0],f=1;f<n;){var t=f+1,i=f;t<n&&o[t].h<o[f].h&&(i=t),o[i-1>>1]=o[i],f=1+(i<<1)}for(var a=i-1>>1;0<i&&e.h<o[a].h;a=(i=a)-1>>1)o[i]=o[a];o[i]=e},(r={}).add=r=>{var e=n;o[n++]=r;for(var f=e-1>>1;0<e&&r.h<o[f].h;f=(e=f)-1>>1)o[e]=o[f];o[e]=r},r.m=r=>{var e;if(0!==n)return e=o[0],o[0]=o[--n],t(),e},r.M=r=>{if(0!==n)return o[0]},r.C=r=>{o[0]=r,t()},r);return{single:(r,e)=>{var f;return!r||!e||(r=D(r),J(e)||(e=L(e)),((f=r.l)&e.u)!==f)?Q:F(r,e)},go:(r,e,f)=>{if(!r)return f?.all?((r,e)=>{var f=[],t=(f.total=r.length,e?.limit||K);if(e?.key)for(var i=0;i<r.length;i++){var a=r[i];var o=I(a,e.key);if(o==Q)continue;if(!J(o))o=L(o);var n=x(o.target,{h:o.h,obj:a});f.push(n);if(f.length>=t)return f}else if(e?.keys)for(var i=0;i<r.length;i++){var a=r[i];var v=new j(e.keys.length);for(var u=e.keys.length-1;u>=0;--u){var o=I(a,e.keys[u]);if(!o){v[u]=R;continue}if(!J(o))o=L(o);o.h=O;o.p.g=0;v[u]=o}v.obj=a;v.h=O;f.push(v);if(f.length>=t)return f}else for(var i=0;i<r.length;i++){var o=r[i];if(o==Q)continue;if(!J(o))o=L(o);o.h=O;o.p.g=0;f.push(o);if(f.length>=t)return f}return f})(e,f):P;var t=D(r),i=t.l,a=t.S,o=A(f?.threshold||0),n=f?.limit||K,v=0,u=0,s=e.length;function l(r){v<n?(T.add(r),++v):(++u,r.h>T.M().h&&T.C(r))}if(f?.key)for(var c=f.key,p=0;p<s;++p){var b=e[p];!(m=I(b,c))||(i&(m=J(m)?m:L(m)).u)!==i||(M=F(t,m))===Q||M.h<o||(M.obj=b,l(M))}else if(f?.keys){var d=f.keys,w=d.length;r:for(p=0;p<s;++p){for(var b=e[p],g=0,h=0;h<w;++h){c=d[h];(m=I(b,c))?(J(m)||(m=L(m)),g|=(G[h]=m).u):G[h]=R}if((i&g)===i){if(a)for(let r=0;r<t._.length;r++)B[r]=O;for(h=0;h<w;++h)if((m=G[h])===R)H[h]=R;else if(H[h]=F(t,m,!1,a),H[h]===Q)H[h]=R;else if(a)for(let r=0;r<t._.length;r++)-1e3<E[r]&&B[r]>O&&(_=(B[r]+E[r])/4)>B[r]&&(B[r]=_),E[r]>B[r]&&(B[r]=E[r]);if(a){for(let r=0;r<t._.length;r++)if(B[r]===O)continue r}else{var y=!1;for(let r=0;r<w;r++)if(H[r].h!==O){y=!0;break}if(!y)continue}var k=new j(w);for(let r=0;r<w;r++)k[r]=H[r];if(a){var S=0;for(let r=0;r<t._.length;r++)S+=B[r]}else{var _,S=O;for(let r=0;r<w;r++)(S=-1e3<(M=k[r]).h&&O<S&&S<(_=(S+M.h)/4)?_:S)<M.h&&(S=M.h)}if(k.obj=b,k.h=S,f?.scoreFn){if(!(S=f.scoreFn(k)))continue;S=A(S),k.h=S}S<o||l(k)}}}else for(var m,M,p=0;p<s;++p)!(m=e[p])||(i&(m=J(m)?m:L(m)).u)!==i||(M=F(t,m))===Q||M.h<o||l(M);if(0===v)return P;for(var C=new Array(v),p=v-1;0<=p;--p)C[p]=T.m();return C.total=v+u,C},prepare:f,cleanup:()=>{a.clear(),l.clear()}}});\n"
        },
        {
          "name": "index.d.ts",
          "type": "blob",
          "size": 2.5078125,
          "content": "declare namespace Fuzzysort {\n\n  interface Result {\n    /**\n    * 1 is a perfect match. 0.5 is a good match. 0 is no match. \n    */\n    readonly score: number\n\n    /** Your original target string */\n    readonly target: string\n\n    highlight(highlightOpen?: string, highlightClose?: string): string\n    highlight<T>(callback: HighlightCallback<T>): (string | T)[]\n\n    indexes: ReadonlyArray<number>\n  }\n  interface Results extends ReadonlyArray<Result> {\n    /** Total matches before limit */\n    readonly total: number\n  }\n\n  interface KeyResult<T> extends Result {\n    /** Your original object */\n    readonly obj: T\n  }\n  interface KeyResults<T> extends ReadonlyArray<KeyResult<T>> {\n    /** Total matches before limit */\n    readonly total: number\n  }\n\n  interface KeysResult<T> extends ReadonlyArray<Result> {\n    /**\n    * 1 is a perfect match. 0.5 is a good match. 0 is no match. \n    */\n    readonly score: number\n\n    /** Your original object */\n    readonly obj: T\n  }\n  interface KeysResults<T> extends ReadonlyArray<KeysResult<T>> {\n    /** Total matches before limit */\n    readonly total: number\n  }\n\n\n  interface Prepared {\n    /** Your original target string */\n    readonly target: string\n  }\n\n  interface Options {\n    /** Don't return matches worse than this (higher is faster) */\n    threshold?: number\n\n    /** Don't return more results than this (lower is faster) */\n    limit?: number\n\n    /** If true, returns all results for an empty search */\n    all?: boolean\n  }\n  interface KeyOptions<T> extends Options {\n    key: string | ((obj: T) => string) | ReadonlyArray<string>\n  }\n  interface KeysOptions<T> extends Options {\n    keys: ReadonlyArray<string | ((obj: T) => string) | ReadonlyArray<string>>\n    scoreFn?: (keysResult: KeysResult<T>) => number\n  }\n\n  interface HighlightCallback<T> { (match: string, index: number): T }\n\n  interface Fuzzysort {\n\n    single(search: string, target: string | Prepared): Result | null\n\n    go(search: string, targets: ReadonlyArray<string | Prepared>, options?: Options): Results\n    go<T>(search: string, targets: ReadonlyArray<T>, options: KeyOptions<T>): KeyResults<T>\n    go<T>(search: string, targets: ReadonlyArray<T>, options: KeysOptions<T>): KeysResults<T>\n\n    /**\n    * Help the algorithm go fast by providing prepared targets instead of raw strings\n    */\n    prepare(target: string): Prepared\n\n    /**\n    * Free memory caches if you're done using fuzzysort for now\n    */\n    cleanup(): void\n  }\n}\n\ndeclare module \"fuzzysort\" {\n  const fuzzysort:Fuzzysort.Fuzzysort\n  export = fuzzysort\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.7236328125,
          "content": "{\n\n  \"name\"        : \"fuzzysort\",\n  \"version\"     : \"3.1.0\",\n  \"author\"      : \"farzher\",\n  \"license\"     : \"MIT\",\n  \"description\" : \"Fast SublimeText-like fuzzy search for JavaScript\",\n\n  \"keywords\": [\"fuzzy search\", \"fuzzy\", \"search\", \"filter\", \"javascript\", \"node\", \"fast\", \"sublime\"],\n\n  \"repository\": {\n    \"type\" : \"git\",\n    \"url\"  : \"https://github.com/farzher/fuzzysort.git\"\n  },\n\n  \"main\": \"fuzzysort.js\",\n\n  \"scripts\": {\n    \"test\"     : \"node test/test.js\",\n    \"test-min\" : \"node test/test.js min\",\n\n    \"minify\"   : \"uglifyjs fuzzysort.js -o fuzzysort.min.js -m -c --mangle-props keep_quoted --comments /farzher/\"\n  },\n\n  \"files\": [\n    \"fuzzysort.js\",\n    \"fuzzysort.min.js\",\n    \"index.d.ts\"\n  ],\n\n  \"types\": \"index.d.ts\"\n\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}