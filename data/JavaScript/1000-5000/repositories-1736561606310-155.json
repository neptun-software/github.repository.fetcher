{
  "metadata": {
    "timestamp": 1736561606310,
    "page": 155,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "andrewplummer/Sugar",
      "stars": 4533,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".eslintrc.json",
          "type": "blob",
          "size": 0.6005859375,
          "content": "{\n  \"extends\": \"eslint:recommended\",\n  \"rules\": {\n    \"no-undef\": 0,\n    \"no-cond-assign\": 0,\n    \"no-irregular-whitespace\": 0,\n    \"no-unused-vars\": [2, {\"vars\": \"local\", \"varsIgnorePattern\": \"argLen|prop\", \"args\": \"after-used\"}],\n    \"quotes\": [2, \"single\", \"avoid-escape\"],\n    \"comma-spacing\": 0,\n    \"no-console\": 0,\n    \"camelcase\": [2, {\"properties\": \"never\"}],\n    \"no-multi-spaces\": 0,\n    \"dot-notation\": 0,\n    \"space-before-blocks\": 2,\n    \"linebreak-style\": [2, \"unix\"],\n    \"semi\": [2, \"always\"]\n  },\n  \"globals\": {\n    \"localStorage\": false\n  },\n  \"env\": {\n    \"es6\": true,\n    \"browser\": true\n  }\n}\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1591796875,
          "content": "## MAC OS\n.DS_Store\n\n## TEXTMATE\n*.tmproj\ntmtags\n\n## EMACS\n*~\n\\#*\n.\\#*\n\n## VIM\n*.swp\n\n## PROJECT::GENERAL\ntmp\nnode_modules\n\n## PROJECT::SPECIFIC\npackages\ncoverage\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": "bower.json\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.296875,
          "content": "language: node_js\nnode_js:\n  - \"node\"\n  - \"5\"\n  - \"4\"\nbranches:\n  only:\n    - master\ncache:\n  directories:\n    - node_modules\ngit:\n  depth: 3\ninstall: npm install gulp gulp-util gulp-file yargs@\"~3.15.0\" sinon istanbul coveralls\nbefore_script:\n  - 'gulp build:dev'\nafter_success:\n  - 'npm run coveralls'\n"
        },
        {
          "name": "CAUTION.md",
          "type": "blob",
          "size": 34.791015625,
          "content": "### Caution!\n\nHere you will find points of caution when updating Sugar to a new version.\nThink of it as a pruned Changelog with the most front-facing changes surfaced.\nIf your code breaks on update check here first! Read all the ones that are greater than the version you are migrating from.\n\n\n### Upgrade Script\n\n[upgrade.js](lib/extras/upgrade.js)\n\nWhen upgrading to a new major version, it's hard to know what changes you will be affected by. This document was meant to help, but now there is also the upgrade script! Just include it immediately after Sugar is loaded, and it will log any method calls that may potentially break!\n\nDrop it in before upgrading to get a general idea of what needs to change, or upgrade and fix as you go!\n\n\n### v2.0.0+\n\n- Level: Major\n  - Callbacks for iterating over object properties are now value first, key second. This includes `Object.each` (now renamed to `Object.forEach`), `Object.map`, `Object.every`, `Object.find`, `Object.count`, `Object.none`, `Object.sum`, `Object.average`, `Object.min`, `Object.max`, `Object.least`, `Object.most`, and `Array#groupBy`.\n\n- Level: Major\n  - `String#assign` is now `String#format`, and behaves very closely to Python's method of the same name. Tokens are now zero based, and start with `{0}`. Also, errors will be thrown when tokens cannot be matched. Braces can now be escaped by repeating them. Lastly, multiple objects passed will no longer be merged together. Instead either access with new dot syntax (0.prop) or merge together with Object.merge beforehand.\n\n- Level: Major\n  - `Function#fill` was renamed to `Function#partial`. Additionally, it no longer accepts `null` as a placeholder. Use `undefined` instead.\n\n- Level: Major\n  - `Object.equal` is renamed to `Object.isEqual` in both the static and instance method types.\n\n- Level: Major\n  - `Object.extended` was removed in favor of chainables. The equivalent is now `new Sugar.Object()`, however the result will be wrapped in a property called `.raw`. See the docs for more details.\n\n- Level: Major\n  - `Object.merge` now takes an options object instead of a list of arguments. The 3rd argument is now \"deep\" in the options object, and the 4th is \"resolve\". Resolver functions will now abort the merge (for a single property) if `undefined` is the return value. To tell the resolver function to continue as normal, return the `Sugar` global object instead. Any non-undefined value returned by the function will now resolve the conflict completely and will not continue traversing into it when in \"deep\" mode. To tell the resolver function to continue with the merge, return the Sugar global object instead.\n\n- Level: Major\n  - `String#has` is now removed in favor of `String#includes` to be in compliance with the ES6 spec. The ES6 method only accepts a string as input, however Sugar enhances this method to allow regexes (can be opted-out).\n\n- Level: Major\n  - `Array#include` was removed as it is now identical to `Array#add`.\n\n- Level: Major\n  - `Array#findAll` was replaced with `Array#filterFromIndex` in cases that require a start index. For cases without a start index, simply use native `Array#filter`. Additionally, the \"index\" and \"loop\" arguments now come before the callback.\n\n- Level: Major\n  - `Array#each` was replaced with `Array#forEachFromIndex` in cases that require a start index. For cases without a start index, simply use native `Array#forEach`. Additionally, the \"index\" and \"loop\" arguments now come before the callback. For iterating until a return value is passed, use `Array#some`.\n\n- Level: Major\n  - `Array#findFrom` and `Array#findIndexFrom` are now `Array#findFromIndex` and `Array#findIndexFromIndex` and exist alongside other \"from index\" methods with similar naming. Additionally, the \"index\" and \"loop\" arguments now come before the callback.\n\n- Level: Major\n  - `Object.findAll` was replaced with `Object.filter`, which parallels `Array#filter` by returning a filtered object.\n\n- Level: Major\n  - `Object.each` was renamed as `Object.forEach` to bring it more in line with other object methods. Additionally it no longer allows a return value to break the loop. Use `Object.some` instead for this functionality.\n\n- Level: Major\n  - `String#each` was renamed to `String#forEach` to bring it more in line with other methods.\n\n- Level: Major\n  - `Date#utc` is now `Date#setUTC`, and now requires explicitly passing `true` as the first argument to set the flag to true.\n\n- Level: Major\n  - `Date#format` shortcuts (\"short\", \"long\", \"full\", etc) have significantly changed. See the docs for the new formats. Tokens `f`, `fff`, `izotz`, and `ord`, have been replaced with `S`, `SSS`, `Z`, and `do` to align better with Moment/LDML. `Dow` and `Mon` were previously always 3 characters and uppercased. Both of these are now locale dependent, as certain locales may prefer different casing or abbreviation length. Lowercased formats `dow` and `mon` are also locale-dependent in length, but always lowercased.\n\n- Level: Major\n  - `Array#randomize` was renamed to `Array#shuffle`.\n\n- Level: Major\n  - `Array.create` now only accepts one argument. See the docs for more details or use ES6 method `Array.from` instead. Sugar provides this as a polyfill in the default bundle.\n\n- Level: Major\n  - `Object.watch` was removed. This method was the only part of Sugar that was not 100% compatible in all environments, and was an overly simplistic solution to a difficult problem that others have done better (see discussions around Object.observe and polling). As a quick and dirty solution, this will be made available as a [plugin](https://github.com/andrewplummer/sugar-plugins). Also includes `Object.unwatch`.\n\n- Level: Major\n  - `Function#after` has changed behavior. Previously it would fire every `n` times. Now it will fire after `n` calls. Additionally it will not immediately fire when `0` is passed.\n\n- Level: Major\n  - `Array#add` is now non-destructive. To append to the array in place, use `Array#append`.\n\n- Level: Major\n  - `Object.toQueryString` no longer uses square bracket syntax by default. To enable this pass `deep` in the options object which is now the second argument to the function. `namespace`, which was previously the second argument to this method, is now `prefix` in the same options object.\n\n- Level: Major\n  - `Object.fromQueryString` now performs \"smart\" conversion of numerals, booleans, and multiple keys by default. To turn this off, pass `smart: false` in the options object which is now the second argument to the function. Deep bracket syntax (`[]` in keys) is now off by defualt but can be enabled with `deep` on the options object.\n\n- Level: Major\n  - `RegExp#addFlag` and `RegExp#removeFlag` are now `RegExp#addFlags` and `RegExp#removeFlags` and now work on multiple flags at once.\n\n- Level: Major\n  - `Date.past`, `Date.future`, `Date.utc.create`, `Date.utc.past`, and `Date.utc.future` are all deprecated. Instead, pass an options object as the second argument to `Date.create` with the equivalent properties. For example: `Date.create('March', { future: true, fromUTC: true, locale: 'ja' })`, etc. Additionally, the `utc` parameter is now `fromUTC` and a new parameter `setUTC` has been added to clear up confusion about what the flag was doing. `fromUTC` assumes the input to be UTC but the output is a normal Javascript local date. `setUTC` sets an internal flag which tells Sugar to use utc methods like `getUTCHours`.\n\n- Level: Major\n  - `String#startsWith` and `String#endsWith` are now more in compliance with the ES6 spec. They now no longer accept a RegExp (will throw an error) or a `case` parameter. If you need to do more complex string checking, use `String#match` with standard regexes instead. Also minor differences in the way the starting/ending positions are coerced may also be present.\n\n- Level: Major\n  - `Object.isNaN` was removed in favor of native `Number.isNaN`, which Sugar provides a polyfill for.\n\n- Level: Major\n  - `String#normalize` was removed to comply with the ES6 spec. It was also a brute force approach and most likely overkill for most situations. It will be made available as a [plugin](https://github.com/andrewplummer/sugar-plugins) under the name `String#toAscii`.\n\n- Level: Major\n  - `String#capitalize` will now only capitalize the first letter of a string by default. If you want to downcase the rest of the string, pass true for the 1st argument. Capitalizing all words is now the 2nd argument.\n\n- Level: Major\n  - `String#add` was removed and now exists only as `String#insert`, which it was mainly providing the basis for.\n\n- Level: Major\n  - `Array#all`, `Array#any`, `Object.all`, and `Object.any` aliases were removed to align Sugar more with native methods. If needed, these can still easily be aliased with `Sugar.Array.alias('all', 'every');`.\n\n- Level: Major\n  - `String#paragraphs` was removed.\n\n- Level: Moderate\n  - `Object.keys` and `Object.values` no longer have callbacks as second arguments. Use `Object.forEach` for iteration over an object's properties.\n\n- Level: Moderate\n  - `Number#format` no longer accepts arguments for the thousands separator and decimal point. Instead these can now be set globally using Sugar.Number.thousands() and Sugar.Number.decimal(). These will also be respected by Number#abbr, Number#metric, and Number#bytes as well.\n\n- Level: Moderate\n  - `Number#bytes` now uses powers of 1000 by default instead of powers of 1024. For the old behavior, pass \"true\" as the 2nd argument (after precision). Further, when using the \"binary\" flag, units will be standard binary units (KiB, MiB, etc.). For standard units (KB, MB, etc.) pass 'si' for the 3rd argument.\n\n- Level: Moderate\n  - Alphanumeric array options are now defined on the global object `Sugar` instead of `Array` itself.\n\n- Level: Moderate\n  - `Array#at` and `String#at` now no longer accept enumerated arguments. To get an multiple indexes, pass an array instead.\n\n- Level: Moderate\n  - `Array#at` and `String#at` now have their `loop` argument off by default.\n\n- Level: Moderate\n  - Array natural sort options (`AlphanumericSortOrder`, `AlphanumericSortIgnore`, etc) now no longer have `Alphanumeric` in the name, and are now options that are set by the accessor methods `Sugar.Array.getOption` and `Sugar.Array.setOption`. Lastly, `AlphanumericSort`, which simply exposed Sugar's internal sort algorithm is now `sortCollate`.\n\n- Level: Moderate\n  - `Array#sortBy` will now not clone the array by default. This will prevent unnecessary work when it is not needed, however it means that the method is now destructive. Simply use `clone` or `concat` on the array first for the old behavior.\n\n- Level: Moderate\n  - `Object.select` and `Object.reject` now, when passed an object as a matcher, only check for key existence, not whether values also match or not. To do the \"intersect\" operation that these methods previously performed, `Object.filter`, `Object.remove`, or `Object.exclude` can instead be used.\n\n- Level: Moderate\n  - `Date#reset` now requires one unit higher when resetting units based on a string. For example, d.reset('day') will now \"reset the day\", where it's previous behavior was to shift the date to the beginning of the month. Default is also shifted so no change should be necessary when resetting the time.\n\n- Level: Moderate\n  - `Array#subtract`, `Array#union`, and `Array#intersect` all no longer accept multiple arguments. Simply chain them if more than one argument is needed.\n\n- Level: Moderate\n  - `Array#min`, `Array#max`, `Array#least`, `Array#most`, `Object.min`, `Object.max`, `Object.least`, `Object.most`: The `all` argument is now passed before `map` as an optional argument. This will always put the function callback as the last argument.\n\n- Level: Minor\n  - `Date#relative` arguments `fn` and `localeCode` are now reversed (`localeCode` first). As this method was previously accepting `localeCode` as a single argument anyway, this change will only have have an effect if both arguments are used together.\n\n- Level: Minor\n  - `Array#remove` and `Array#exclude` no longer accept enumerated paramters. To remove multiple elements, depending on the type a regex or function may be used. Otherwise the method must be called multiple times.\n\n- Level: Minor\n  - `Date.create` no longer accepts enumerated parameters (2001, 5, 31, ...). Use the normal date constructor instead.\n\n- Level: Minor\n  - `Number#metric` now uses a \"units\" string instead of the \"limit\" argument, which allows a more flexible, intuitive way to define custom units and min/max ranges. Check the docs for more about this.\n\n- Level: Minor\n  - `Date#set` now rewinds dates that have accidentally traversed into a new month, such as setting `{ month: 1 }` on `January 31st`. This behavior was previously only on `advance` and `rewind`.\n\n- Level: Minor\n  - `Date.SugarNewDate` is now `Sugar.Date.newDateInternal`. This method is always on the `Sugar` global (not `Date`).\n\n- Level: Minor\n  - `Object.map`, `Object.each`, (now `Object.forEach`) and `Object.size` were moved to the Object module from the Array module. If you were using these methods and making custom builds you may have to include the Object module now as well.\n\n- Level: Minor\n  - `Date#unitSince` (`Date#hoursSince`, etc) now assumes that the passed in format is UTC if the context date is also flagged as UTC (if you're using `setUTC`). This behavior can be overriden by passing `{ fromUTC: false }` to these methods.\n\n- Level: Minor\n  - `Object.clone` now clones both non-enumerable properties if they exist and the attribute accessors \"get\" and \"set\".\n\n- Level: Minor\n  - `Array#isEmpty` now does a simple check if the length is zero. To also check if `undefined`, `null`, or `NaN` are present, use `Array#compact` first.\n\n- Level: Minor\n  - `Object.fromQueryString` now returns a plain object. If you want what was previously an extended object, use a chainable on the result with `new Sugar.Object()`.\n\n- Level: Minor\n  - `String#stripTags` and `String#removeTags` no longer accept enumerated arguments. Simply pass an array of tags to remove multiple.\n\n- Level: Minor\n  - `String#titleize` was moved from the Inflections module to String.\n\n- Level: Minor\n  - `String.Inflector` has been removed from the inflections module in favor of the static methods `addAcronym`, `addPlural`, and `addHuman`.\n\n- Level: Minor\n  - `String#upto` and `String#downto` now accept \"step\", which was previously the third argument, as an optional second argument.\n\n- Level: Very Minor\n  - `Array#map`, `Array#unique`, `Array#groupBy`, `Array#min`, `Array#max`, `Array#least`, `Array#most`, `Array#sortBy`: Mapping shortcut strings now accept deep matchers with the dot `.` token. If you have objects that use `.` in the keys and are using these methods, be careful as this now makes the methods try to go deep. Pass a function instead to map as before.\n\n- Level: Very Minor\n  - Some minor behavior changes around the way `String#removeTags` works on malformed html. Unmatched closing tags are removed.\n\n- Level: Very Minor\n  - `String#hankaku` and `String#zenkaku` now don't take multiple arguments for modes. Just mix them together in the first argument as a string. See docs for more.\n\n\n### v1.4.1+\n\n- Level: Minor\n  - `Object.select` and `Object.reject` now will match values when passed an object. This means that if you pass `{foo:'bar'}`, it will no longer match if the value of `foo` in your object is not `bar`. Previously it would match simply if the key existed.\n\n\n### v1.4.0+\n\n- Level: Major\n  - `pad`, `padLeft`, and `padRight` now pad to the exact character. This means that `padLeft(20)` will produce a string exactly 20 characters long, instead of adding 20 characters worth of padding to the left side of the string as before. You can use `String#repeat` for the same effect as the old functionality.\n\n- Level: Major\n  - `Object.fromQueryString` now does not cast values by default. This means that all values in the resulting object are strings, unless `castBoolean` is true, which will cast boolean values of \"true\" and \"false\" only. Digits are no longer cast to numbers at all. Additionally, the \"deep\" argument is now removed. Deep parameters will always be parsed if they can be.\n\n- Level: Major\n  - `Function#lazy` now has different arguments. `limit` is now the third argument with `immediate` taking its place as second. Additionally `immediate` -- which determines whether lazy functions are executed immediately then lock or lock then execute after a timeout -- is now false by default.\n\n- Level: Major\n  - Date range methods `eachDay`, `eachMonth`, etc. are deprecated in favor of the syntax `every(\"day\")`, etc.\n\n- Level: Major\n  - Date range method `duration` is deprecated in favor of `span`. Additionally it will add 1 to the duration to include the starting number itself. In effect for date ranges this means that `duration` will be 1 ms longer.\n\n- Level: Major\n  - `Range#step` alias was removed. Use `Range#every` instead.\n\n- Level: Major\n  - Date formatting tokens `z` and `zz` are now `Z` and `ZZ`. Additionally `zzz` was removed.\n\n- Level: Moderate\n  - `Array#find` now works according to the ES6 spec. This means that it will no longer take a `fromIndex` or `loop` arguments. Instead, the second argument is the context in which the function matcher will be run. If you need the previous functionality, use `Array#findFrom` and `Array#findIndexFrom` instead.\n\n- Level: Moderate\n  - `Array.sortBy` now performs a natural sort by default. This means numbers (any consecutive numbers, so this will include currency formatting, etc.) will sort as numbers, (2 before 100). If you do not want this behavior, set the flag `Array.AlphanumericSortNatural` to `false`.\n\n- Level: Moderate\n  - `Object.clone` now will error if being called on a user-created class instance or host object (DOM Elements, Events, etc). A number of complex issues tie in here, but in the end it is unreliable to call `clone` on an object that is not a standard data types as 1) hidden properties cannot be cloned 2) the original arguments to the constructor cannot be known 3) even if they could be known the issue of whether or not the constructor should actually be called again is not clear.\n\n- Level: Moderate\n  - The `split` argument was removed from `String#truncate`. For truncating without splitting words, use `String#truncateOnWord` instead. Argument position is adjusted accordingly.\n\n- Level: Moderate\n  - Class instances are now internally matched by reference only. This means that `Object.equal(new Person, new Person)` is `false`. This was in fact the original intended behavior but a bug had not been closed here leading to it not actually being `false`. Although a case can be made for matching class instances by value, in the end it is too expensive and tricky to distinguish them from host objects, which should never be matched by value. Instead it is better to check for equality of class instances on a unique identifier or the like.\n\n- Level: Moderate\n  - `Object.isObject` no longer returns true for class instances for the same reasons listed above. This also was intended behavior but was defective.\n\n- Level: Moderate\n  - `String#normalize` is now deprecated, but still available as a separate script in the `lib/plugins` directory.\n\n- Level: Moderate\n  - Date ranges are now their own module (the \"range\" module), and are not dependent on the Date module, and work on numbers and strings as well.\n\n- Level: Minor\n  - Enumerable methods on object will now coerce primitive types. This means that `Object.findAll('foo')` will now treat `'foo'` as `new String('foo')`. This is reversed from the previous behavior which would error on primitive types and coerce objects to primitive types where possible.\n\n- Level: Minor\n  - `String#capitalize` passing the `all` flag now will not capitalize after an apostrophe.\n\n- Level: Very Minor\n  - Date ranges that have an end that is less than the start are now no longer considered invalid, and can be iterated across in exactly the same manner. This means that ranges can now be iterated in reverse and .start and .end are no longer equivalent to .min and .max.\n\n- Level: Very Minor\n  - Removed `Number#upto` and `Number#downto` will now work on inverse ranges. In other words (1).downto(5) if represented as an array will now produce [1,2,3,4,5] even though 1 is less than 5 and the operator was \"downto\". It will also step through the range accordingly.\n\n- Level: Very Minor\n  - Passing a regex to array matching methods like `findAll` will now match it directly against the element in the array, regardless of whether or not the matched element is a string or not. This makes the logic more straightforward but it also means that it will stringify the element before attempting to match. If, for example, you have instances of classes in the array and the regex is /t/, the /t/ will return true for that element as it will match the stringified \"[object Object]\" of the instance, which is likely not what you want, so caution is needed here.\n\n- Level: Very Minor\n  - Passing `null` to `.map` will now have the same effect as `undefined` (or no arguments), that is, no mapping will occur. This will apply to any method making use of the internal `transformArgument`, so `Array#min`, `Array#max`, and `Array#groupBy` are affected as well.\n\n- Level: Very Minor\n  - `String#pad/padLeft/padRight` will now raise an error on padding to a negative number. Conversely, they will no longer raise an error on undefined/null/NaN.\n\n\n### Note about versions < 1.3.9\n\nVersion 1.4.0 improves future-compatibility by ensuring that browser updates do not cause breakages going forward. Upgrading is highly recommended, however as there are also many API changes, [this patch](https://raw.github.com/andrewplummer/Sugar/master/lib/extras/patches/sugar-es6-patch.min.js) was created for older versions. Just drop it in after the main script.\n\n\n### v1.3.9+\n\n- Level: Major\n  - Removed `String#namespace`.\n\n\n### v1.3.8+\n\n- Level: Major\n  - Renamed `Date#getWeek` and `Date#setWeek` to `Date#getISOWeek` and `Date#setISOWeek`.\n\n- Level: Very Minor\n  - Object.clone will now preserve a date's internal utc flag when set.\n\n\n### v1.3.7+\n\n- Level: Major\n  - `String#startsWith` and `String#endsWith` now accept different arguments to better align them with the Harmony proposal of the same name. The second argument is now the \"position\" that limits where the string starts/ends, and the \"case\" flag indicating case sensitivity is now pushed to the 3rd argument.\n\n- Level: Major\n  - Enumerable object methods are now included when using `Object.extend()` making it that much more dangerous, especially as generic methods like `count` are now defined on the Object prototype. If you use this method, make sure you are in the habit of using `hasOwnProperty` when checking for presence inside a hash (probably not a bad idea anyway). Also note that Sugar itself has a number of areas that may exhibit unexpected behavior when this method is applied. Please report if you find any.\n\n- Level: Moderate\n  - Aliases on dates such as `daysAgo` will now count \"past\" an integer instead of rounding. This means that `Date.create('23 hours ago').daysAgo()` will now be `0`. There is however a small margin of error (roughly 0.1%) that will trigger a round up, which is higher for months, which have a more vague definition and a higher margin for error.\n\n\n### v1.3.6+\n\n- Level: Very Minor\n  - Float values should be properly parsed in `Object.fromQueryString`, meaning IP addresses and the like will now parse as strings instead of truncated numbers.\n\n- Level: Very Minor\n  - NaN is no longer true for `isOdd`.\n\n- Level: Very Minor\n  - Date parsing now only allows a maximum of 59 for minutes and seconds.\n\n\n### v1.3.5+\n\n- Level: Very Minor\n  - `Array.create` now properly creates arrays from objects.\n\n\n### v1.3.2+\n\n- Level: Minor\n  - `Date.create` will no longer set the UTC flag on dates created from an ISO string with the \"Z\" flag. This can be considered a bug introduced in the last release. The \"Z\" flag indicates that a date is in UTC time, but should not serve as an indication that the date should further be manipulated as UTC, only as a cue when parsing. If you want the date to actually behave as UTC (internally call UTC methods), then you need to explicitly set with `Date#utc(true)` now.\n\n\n### v1.3.1+\n\n\n- Level: Major\n  - Array methods that allow fuzzy matching on an object (`findAll`, `filter`, `some`, etc.) as well as `unique`, `intersect`, `union`, and `subtract`, will now match by reference unless certain conditions are met. Most notably this means that arrays of functions as well as arrays of host objects (DOM elements, etc.) will now only match elements that are strictly true by reference (`===`). If you are using arrays of host objects or functions (event handlers and the like), use caution upgrading. Other kinds of arrays such as primitives (strings, numbers, etc) as well as object literals and instances of user-defined objects should not be affected.\n\n- Level: Major\n  - `Date#toUTC` deprecated. Previously, this method would subtract the timezone offset of the date, providing a pseudo-utc date. This was a very primitive way of handling the challenge of manipulating utc dates and had drawbacks such as subsequent date manipulations resetting to a localized time. This is now deprecated in favor of `Date#utc`, which simply sets an internal flag that will tell Sugar to use utc-based date methods or not. `Date#utc` will NOT manipulate the time in any way. To create a utc-based date that is set to utc time, a flag has been added to `Date#create`, and other creation methods like `Date#future` and `Date#past` to set the utc flag before parsing out the date.\n\n- Level: Major\n  - `Date#setUTC` deprecated. Instead, simply set the utc flag using `Date#utc` or passing `true` as the third argument to `Date#create`. After this point, utc-based methods will be used internally, making this method unnecessary.\n\n- Level: Major\n  - `Date#setUTCWeek` deprecated. Set the utc flag and use `Date#setWeek` instead.\n\n- Level: Major\n  - `Date#getUTCWeek` deprecated. Set the utc flag and use `Date#getWeek` instead.\n\n- Level: Major\n  - `Date#setUTCWeekday` deprecated. Set the utc flag and use `Date#setWeekday` instead.\n\n- Level: Minor\n  - `Number#times` now returns an array which is the collected return values of the function passed.\n\n- Level: Minor\n  - `Date#clone` will now preserve the utc flag.\n\n- Level: Minor\n  - Array methods matching an empty object `{}` will now return true instead of false against another empty object.\n\n- Level: Very Minor\n  - `Date#setWeekday` now returns a timestamp instead of `undefined`.\n\n\n### v1.3+\n\n\n- Level: Major\n  - Date locales are now moved into a separate module. This means that now with the default download, setting the date locale to anything other than English will throw an error. If you require locales other than English, please include them from [the customize page](http://sugarjs.com/customize).\n\n- Level: Major\n  - `Array#min`, `Array#max`, `Array#least`, and `Array#most` now return a single value instead of an array. If you need to get \"all min\" or \"all max\" values, then pass `true` as the second argument to these methods.\n\n- Level: Major\n  - `Array#has` is deprecated. Use `Array#some` or `Array#any` instead.\n\n- Level: Major\n  - `String#toDate` is deprecated. Use `Date.create` instead.\n\n- Level: Major\n  - `String#add`, `String#insert`, `Array#add`, and `Array#insert` now consider negative indexes to be the same as built-in `Array#slice`. This means that adding 'd' to 'abc' at index -1 now results in 'abdc' instead of 'abcd'.\n\n- Level: Major\n  - Date parsing is now scoped by locale. Previously setting a locale would add all its formats into a common pool that would match from that point on. Now the locale must be either be set beforehand `Date.setLocale('fr')` or explicitly passed `Date.create('...', 'fr')`. The exception to this are numeric formats which are core formats and will parse in any locale.\n\n- Level: Minor\n  - Extended objects that are otherwise identical to non-extended counterparts are now considered equal by `Object.equal`.\n\n- Level: Minor\n  - `Object.isEmpty` will now error when passed a non-object. This includes object versions of primitives like strings, numbers, and booleans.\n\n- Level: Minor\n  - Default date output format `date.format()` now includes the time. Previously this was just the date.\n\n- Level: Minor\n  - `Array#groupBy` no longer returns extended objects. Use `Object.extended` on the result if you need this.\n\n- Level: Minor\n  - Unrecognized locale codes will now simply produce an invalid date instead of throwing an error. Likewise, fully qualified locale codes ('it_IT') will fall back to 2 character codes ('it') before giving up.\n\n- Level: Very Minor\n  - Array methods using fuzzy matching (findAll, remove, etc.) now match instances of classes as well as plain objects.\n\n- Level: Very Minor\n  - `String#capitalize` with the first argument as `true` (capitalize all words) will now capitalize any letter whose previous letter could not be capitalized. Previously only words after spaces were counted.\n\n\n\n### v1.2.5+\n\n- Level: Major\n  - `String#truncate` arguments changed. `ellipsis` (`\"...\"` by default) is now the last argument of four. Second argument is now `split` which is true by default, so the method will behave like standard truncate methods by default. `from` added as the third parameter and determines where to truncate. Can be `\"right\"` (default), `\"left\"`, or `\"middle\"`.\n\n- Level: Major\n  - `Function#debounce` no longer has an argument `wait`. Equivalent function is now `Function#throttle` (no arguments). `fn.debounce(100, false)` is now `fn.throttle(100)`.\n\n- Level: Minor\n  - `Object.isObject` now returns `true` for extended objects.\n\n\n### v1.2.4+\n\n- Level: Minor\n  - Object.equal and its instance method form \"equals\" is now considered \"egal\". This means that, for example, new String('w') will NOT be equal to 'w', etc. Previously equal was nearly egal, but not quite, so this should only affect very small edge cases. This now means that Sugar will match Underscore's _.isEqual method 100% of the time with the only exception being custom \"isEqual\" methods that Underscore checks explicitly.\n\n- Level: Very Minor\n  - Object.merge will now merge properties of non-objects like functions.\n\n\n\n### v1.2.3+\n\n- Level: Major\n  - String#compare, Number#compare, and Date#compare are deprecated\n\n- Level: Major\n  - Object.merge params are swapped. `resolve` is now the 4th parameter and `deep` is now 3rd.\n  - When using extended objects, this are now 2nd and 3rd parameters. `deep` is now false by default.\n\n- Level: Minor\n  - Array#sortBy now exhibits more sensible behavior when sorting on strings.\n\n\n\n### v1.2.2+\n\n- Level: Very Minor\n  - Extended objects now keep their \"Hash\" constructor (which is internal) so they no longer have `Object` as their constructor. If you are doing instanceof checks here this may break (which you shouldn't be doing anyway)\n\n\n\n### v1.2+\n\n- Level: Major\n  - Array methods now use \"fuzzy object matching\" when passing an object. As an example, `arr.find({ foo: 'bar' })` would previously only match an identical object, now it will match any object whose `foo` property is `bar`. Additionally, note that passing regexes and functions will be used to match (regexes match against strings, functions are callbacks that return `true`/`false`), not compared directly. This applies to the following array methods: `every`, `some`, `filter`, `find`, `findAll`, `findIndex`, `remove`, `none`, `count`, and `exclude`.\n\n- Level: Major\n  - Object.sugar renamed to Object.restore. However Object.sugar() equivalent is now Object.extend().\n\n- Level: Minor\n  - Object.merge now also merges undefined properties.\n\n\n\n### v1.1.2+\n\n- Level: Minor\n  - Function#after will now call a method immediately if the passed value is `0`.\n\n- Level: Very minor\n  - Object.isEmpty will now properly report `false` for primitive types like `null` and empty strings.\n\n\n\n### v1.1.1+\n\n- Level: Major\n  - Object.merge no longer merges an arbitrary number of arguments. Use extended objects and chaining instead.\n\n- Level: Minor\n  - Array#remove and Array#exclude now no longer accept an arbitrary number of arguments. Pass only 1 argument to these methods (may be a nested array).\n\n\n\n### v1.1+\n\n- Level: Major\n  - Object.equals renamed to Object.equal.\n\n- Level: Major\n  - Number#format \"thousands\" and \"decimal\" parameters are now pushed to the 2nd and 3rd parameters, adding a \"place\" for the decimal as the 1st.\n\n- Level: Minor\n  - A few tokens were removed from Date#format. See sugarjs.com/dates for a list of currently accepted tokens.\n\n- Level: Minor\n  - Function#lazy now executes, then waits as opposed to waiting, then executing.\n\n- Level: Minor\n  - Array#sortBy is now no longer destructive, so you will need to set the variable explicitly.\n\n\n\n### v1.0+\n\n\n- Level: Major\n  - String#normalize is removed, but now available in the Inflections module, available at sugarjs.com/customize.\n\n- Level: Major\n  - String#is/hasArmenian, is/hasBopomofo, is/hasEthiopic, and is/hasGeorgian deprecated.\n\n- Level: Minor\n  - Passing a second parameter to Date#set now no longer resets only the time, but also any unit less specific than the most specific one set. So if the object `{ hours: 5 }` is passed with the second parameter `true`, minutes, seconds, and milliseconds will be reset.\n\n- Level: Minor\n  - Passing \"relative\" as the format to Date#format is now deprecated, and instead Date#relative.\n\n- Level: Minor\n  - Date.allowVariant deprecated in favor of the locale system. Any locale that is not 'en' or 'en-US' will use variants when ambiguities exist.\n\n- Level: Very minor\n  - Date#format token suffixes \" short\", and \" pad\" deprecated.\n\n- Level: Very minor\n  - When passing a function to Date#format or Date#relative, the \"dir\" parameter is now deprecated. Instead the milliseconds argument has a sign directly on it.\n\n\n\n### v0.9.5+\n\n\n- Level: Major\n  - Array#split deprecated.\n\n- Level: Major\n  - String#toObject is now Object.fromQueryString.\n\n- Level: Major\n  - Function.lazy is now Function#lazy and is called directly on function instances.\n\n- Level: Major\n  - Function#defer is now simply Function#delay with no arguments.\n\n- Level: Moderate\n  - Object.clone is now shallow by default.\n\n\n\n### v0.9.3+\n\n\n- Level: Major\n  - Array#each is no longer an alias of Array#forEach and now has its own behavior including a 2nd parameter for the start index, 3rd parameter for looping from the beginning, returning the array, allowing returning false to break the loop, passing the array as scope to the callback, and support for sparse arrays.\n\n- Level: Major\n  - Array#eachFromIndex deprecated.\n\n- Level: Major\n  - Array#removeAtIndex renamed to Array#removeAt.\n\n- Level: Major\n  - Array#collect deprecated.\n\n- Level: Major\n  - Array#shuffle deprecated.\n\n- Level: Major\n  - String#titleize deprecated. It is now available again as of v1.2 in the Inflections module, available at sugarjs.com/customize.\n\n- Level: Major\n  - String#pad/padLeft/padRight changed argument order to padding first and number second.\n\n- Level: Moderate\n  - Array#indexOf/lastIndexOf now performs a simple `===` equality check instead of a deep recursive property check.\n\n- Level: Minor\n  - String#repeat will now return a blank string on numbers less than 1.\n\n- Level: Minor\n  - String#dasherize and String#underscore now strip whitespace.\n\n\n\n### v0.9.1+\n\n- Level: Major\n  - Object.create changed to Object.extended.\n\n\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 39.9384765625,
          "content": "v2.0.5\n======\n\n- Fixed issue with Angular 6 breaking webpack implementation of global context.\n- Fixed issue with Date#get with past/future options.\n- Fixed issue with parsing of \"Mar-3\".\n- Fixed issue with parsing of \"10:\".\n- Fixed issue with parsing of \"end of year\", etc.\n- Fixed issue with specificity param being incorrectly set.\n- Fixed issue with future option causing a day shift in format \"this week tuesday\".\n- Fixed issue with inconsistency when overshooting certain units in parsing.\n- Fixed issue with Array#max and empty strings.\n- Fixed issue with incorrect order of \"next/last\" in Italian dates.\n- Fixed issues with UTC times being reset and timezone abbreviations.\n- Fixed issue with Finnish period as time separator interfering with date parsing.\n- Fixed issues with Typescript declarations including better handling of generics.\n- Temporary fix for bad parsing of ambiguous ì¼ token for day/Sunday.\n- Restored VERSION property to the core.\n- Fixed issue with future dates.\n\nv2.0.4\n======\n\n- Fixed issue with Typescript declarations not exporting all packages.\n\nv2.0.3\n======\n\n- Updated Typescript declaration files to better handle modules.\n- Added type guards to isString... declarations.\n- Fixed issue with Range date unit methods on invalid ranges.\n\nv2.0.2\n======\n\n- Added Typescript declaration files.\n\n\nv2.0.1\n======\n\n- Fixed issues with locales not being ignored in modularized repos.\n\n\nv2.0.0\n======\n\n### API Changes ###\n\n- Added global objects. All methods will also be defined here.\n- Removed String#escapeRegExp. Use RegExp.escape instead.\n- Changed String#escapeHTML to double-escape entities.\n- `Date#utc` is now `Date#setUTC`.\n- `Date.SugarNewDate` is now an option accessor `Sugar.Date.setOption('newDateInternal', fn)`\n- Modified `String#startsWith` and `String#endsWith` to be more in compliance with ES6. See CAUTION.md for details.\n- Removed `String#has` in favor of `String#includes` to be more in compliance with ES6. See CAUTION.md for details.\n- Added `Number.isNaN` shim. Removed `Object.isNaN` in favor of this.\n- Alphanumeric array options are now on the global object.\n- Moved `Object.map`, `Object.each`, and `Object.size` to the object module.\n- Added `Object.isArguments`.\n- Changed `String#each` (renamed to `String#forEach`) to allow breaking the loop with `false`.\n- Added ability for `String#stripTags` and `Strip#removeTags` to pass a callback.\n- Made `String#stripTags` and `String#removeTags` much more robust.\n- Removed `String#normalize` and will put into its own plugin module as `String#toAscii` later.\n- Updated `Array#sortBy` to handle sorting on multiple properties (Issue #386, thanks to @eric-weiser).\n- Fixed `String#unescapeHTML` to handle HTML (and hex) codes. Also now handling &nbsp;\n- Added a third argument to `Number#bytes` to allow normal SI units.\n- `Object.merge` updated to take an options object. Non-enumerable property support is now an option, as well as property descriptors. Resolver function now will not traverse further into a deep merge if it has been resolved with a function. Sugar global object continues the merge.\n- Allowing a global thousands and decimal marker to be set.\n- `String#hankaku` now makes a hyphen from hyphen-like fullwidth chars in number mode.\n- Fixed issue with the digit `ten` in date creation (Issue #431).\n- Fixed issue with the `Date#[unit]Since` improperly applying error margins.\n- Refactored the `since` and `fromNow` methods to traverse using internal date methods instead of applying an error margin. This makes them much more accurate in dicey situations like DST traversal, leap years, etc.\n- Fixed issue with dates shifting in \"monthsFromNow\" (and consequently \"relative\") when traversing into a month that doesn't have enough days.\n- Fixed issue with advance/rewind using an object with both a \"week\" and \"day\" parameter (Issue #492).\n- Fixed issue `Function#every` not being able to cancel itself (Issue #488).\n- Fixed issue with German dates not allowing abbreviated weekdays with 2 characters.\n- Added `Date#get` allowing date creation with a context date that can be used as a starting point for relative dates.\n- Added `Function#memoize` (Issue #486)\n- Async functions are now synchronous with Sinon.\n- Renamed `Object.equal` and `Object#equals` to `isEqual` for parity.\n- Removed `Date.utc` object as well as `Date.past` and `Date.future` in favor of an options object on `Date#create`.\n- Renamed `Function#fill` to `Function#partial`. Tests from Underscore and Lodash brought in to confirm conformitive behavior.\n- `null` now no longer acts as a placeholder in `Function#partial`. Other bugs fixed around this including using `partial` on constructors.\n- `Date#create` options object now uses `fromUTC` instead of just `utc`. A new option `setUTC` is also added which will set the internal utc flag on creation.\n- `String#assign` refactored and renamed to `String#format`. Tokens are zero based and a few other changes.\n- Added `Object.get` and `Object.set`, allowed them to use dot, bracket, range, and push syntax, and allowed deep object transforms on `Array#map`, and other methods.\n- Fixed many issues with DST and simplified month traversal.\n- Renamed `Array#randomize` to `Array#shuffle`\n- Added `Array#sample` ability to remove sampled elements and performance optimization.\n- Added `String#replaceAll` and `String#removeAll`.\n- Added polyfill for `Array.from` and modified `Array.create` to return a reference by default.\n- Changed behavior of `Function#after` to more closely match that of Underscore/Lodash.\n- Changed behavior of `Number#times` to return an array of return values.\n- Changed `Object.fromQueryString` to return a plain object.\n- Removed `Object.watch` and `Object.unwatch`.\n- Removed ability for `Date.create` to accept enumerated arguments.\n- Modified `Object.toQueryString` to accept an options object.\n- Modified `Object.fromQueryString` to accept an options object.\n- Added support for Sets in `isEqual`.\n- Added `Array#median`.\n- Modified `Number#metric` to use a more flexible system of defining units.\n- Added strf tokens to `Date#format` as well as a number of new standard tokens. Aligned tokens more with moment/ldml and renamed to ldml in the code.\n- Modified `Array#at` and `String#at` to use arrays instead of enumerated arguments.\n- Removed mixed modes for `String#hankaku` and `String#zenkaku`.\n- Modified `String#replaceTags` and `String#stripTags` to simplify argument signature and small performance boost.\n- Added `Array#isEqual`.\n- Renamed `RegExp#addFlag` and `RegExp#removeFlag` to `RegExp#addFlags` and `RegExp#removeFlags`, and ensured they work on multiple flags.\n- Created new module `enumerable`, and split out array methods.\n- Removed `Array#findAll` in favor of `Array#filter` and `Array#filterFromIndex`.\n- Replaced `Object.findAll` with `Object.filter`.\n- `Array#isEmpty` now only checks for zero length.\n- Moved `Object.select` and `Object.reject` to enumerable module and updated to match objects on key existence.\n- Added `Object.remove` and `Object.exclude`.\n- Added `Array#append` to take the place of `Array#add`. `Array#add` now is non-destructive. `Array#insert` now aliases `append` instead of `add`.\n- Removed `Array#include` (now is identical to `Array#add`).\n- Added `Object.invert`.\n- Moved `String#titleize` to String module from Inflections.\n- Modified `Object.has` to allow deep keys. Also added a flag to allow properties in the prototype.\n- Removed `Object.extended` and all trace of Hashes in favor of Sugar chainables.\n- Added date unit methods to ranges.\n- Allowed excepting and allowing entire namespaces.\n- Flipped \"si\" argument to Number#bytes to instead be \"binary\".\n- Modified `String#capitalize` to have an extra parameter for downcasing.\n- Refactored inflections module to have a more straightforward API.\n- Updated `Array#sortBy` to not clone the array by default.\n- Modified `Date#reset` to use higher units to make more semantic sense.\n- Reversed arguments in `Date#relative`.\n- Removed `Array#each` in favor of `Array#forEachFromIndex` in cases where the index is needed.\n- Added `fromIndex` methods. Moved `findFrom` and `findIndexFrom` to be inline with these.\n- Renamed `Object.each` to `Object.forEach` to bring it in line with other methods.\n- Changed `Array#subtract`, `Array#intersect`, and `Array#union` to only accept a single argument to follow other methods more closely.\n- Removed `String#add`, which on its own is largely useless in favor of `String#insert` which was previously an alias.\n- Removed `all` and `any` aliases.\n- Moved the `step` argument in `Number#upto` and `Number#downto` to be an optional 2nd argument.\n- Removed callbacks in `Object.keys` and `Object.values`. `Object.forEach` should be preferred method of iteration.\n- Changed object iteration callbacks to be value first.\n- Renamed `String#each` to `String#forEach`.\n- Changed `min/max/least/most` args to put the callback at the end.\n- Removed `String#paragraphs`.\n- Added `Object.addAll`.\n\n\nv1.4.2\n======\n\n### API Changes ###\n\n- Added ability to pass a single string to `Date.range`\n- Bower.json now points to unminified script (#388)\n- Date.create(null) is now interpeted as a time stamp (#387)\n- Fix for ambiguous years not working with `Date#past/future` (#383)\n- Fix for odd iOS7 bug with `Number#abs` (#400)\n\nv1.4.1\n======\n\n### API Changes ###\n\n- Fix for Object.select/reject not performing value match. (Issue #362)\n- Fix for Object.merge not properly merging when target object isn't an object (Issue #365)\n- Fix for development script not running properly in meteor (Issue #361)\n\n\nv1.4.0\n======\n\n### API Changes ###\n\n- Adding generalized ranges for Numbers and Strings in addition to Dates.\n- Date ranges are now part of the Range module and are no longer dependent on the Date module.\n- Adding `clamp` for ranges and an alias for Number.\n- Adding `cap` for ranges and an alias for Number.\n- Added `String#truncateOnWords`. Part of the `String#truncate` functionality is now here.\n- `Array.create` will understand ranges and can build an array from one.\n- `DateRange#duration` is deprecated in favor of `Range#span`.\n- Fix for relative times with \"4 weeks\" that are actually past the single month threshold.\n- `Number#upto` and `Number#downto` will now work on inverse ranges.\n- `pad`, `padLeft`, and `padRight` now pad to the specified length, instead of simply adding to string.\n- Fuzzy matching methods like `findAll` now directly match regexes against elements, regardless of whether or not they are strings.\n- Instances of classes are now entirely matched by reference only, as originally intended. This means that any equality checking inside Sugar will consider them equal only if they are `===`.\n- `Object.clone` now only works on known object types and does not work on instances of user-created classes.\n- `String#assign` now can be passed an array as well as enumerated arguments.\n- Fixed global variable leak #328\n- Optimization for `Array#removeAt` #324\n- Fix for `isThisWeek` being false when not en locale.\n- Timezone formatting tokens changed to align with Moment.js better.\n- Major performance optimization for date formatting and more.\n- Added `Date#beginningOfISOWeek` and `Date#endOfISOWeek`\n- Fix for `Array#create` not working on argument objects of zero-length (Issue #299).\n- Fix for `String#capitalize` capitalizing after apostrophes (Issue #325).\n- Fix for extended objects `select` and `reject` returning plain objects.\n- Fix for `Object.merge` not merging certain deep objects.\n- Added Date.SugarNewDate to allow customization of internally created dates.\n- Removed `multiMatch` in favor of a cached matcher system.\n- Fix for environments where regexes are functions.\n- Fix for `Function#cancel` not properly clearing all timers (Issue #346).\n- Fix for lazy functions not being able to recursively call themselves.\n- Added option `immediate` to `Function#lazy`, which is now false by default.\n- Added `Function#every`.\n- Exposed `Array.AlphanumericSort` to allow its use in native `Array#sort`.\n- Added `Array.AlphanumericSortNatural` that is on by default and triggers a natural sort.\n- Fixed strings not being coerced into objects in < IE8.\n- `Array.find` now aligns with ES6 spec.\n- Fixed bug with array like objects iterated over with loop = true.\n- Fixed `String#truncate` not returning primitives.\n- `String#repeat` is now aligned more with spec. `String#pad` follows suit.\n- Added `Array#findFrom` and `Array#findIndexFrom`.\n- Removed `Range#step` alias.\n- Removed `deep` argument from `Object.fromQueryString` and replaced with optional boolean casting.\n\n### Performance Enhancements ###\n\n- Object.map: up to 682% faster\n- Date#format: up to 21,400% faster\n- Array#min/max/less/more up to 83% faster\n- Enumerable methods like findAll/findIndex/map/any/count/sum/etc.: up to 11,270% faster\n- isString/isNumber/isBoolean: up to 77% faster\n- isEqual returns up front when === (can be *much* faster). Many methods use this internally as well.\n- Math related functions (and internals that use them): up to 16% faster.\n- getRegExpFlags is up to 1000% faster.\n- Range#every up to 52% faster for dates, 1500% faster for numbers/strings.\n- Array#at and String#at up to 242% faster for single index lookups.\n- String#assign up to 30% faster.\n\n\nv1.3.9\n======\n\n### API Changes ###\n\n- Added `Object.toQueryString`.\n- Fix for timezone offset -0330, etc (Issue #262).\n- Fix for methods like `isToday` not working when using a non-English locale (Issue #264).\n- Removed `Sugar#namespace` to fix conflict with jQuery (Issue #265).\n\n\nv1.3.8\n======\n\n### API Changes ###\n\n- Renamed `Date#getWeek` and `Date#setWeek` to `Date#getISOWeek` and `Date#setISOWeek`.\n- Updating `Date#setWeek` (now `Date#setISOWeek`) to follow ISO-8601 standard.\n- Allowing lazy and throttled functions to return a memoized result, allowing them to double as a caching mechanism.\n- Performance improvement to return early using typeof for type checks.\n- Performance improvement for loops.\n- Fix for Array#sample sometimes returning undefined (Issue #252).\n- Fix for French locales (Issue #249).\n- Fix for conflict with Coffeescript (Issue #248).\n- Fix for Object.clone not preserving date _utc flag (Issue #256).\n\n\nv1.3.7\n======\n\n### API Changes ###\n\n- Added Object.select and Object.reject to help filter keys in objects.\n- String#startsWith and String#endsWith have changed to match the Harmony proposal better.\n- Fix for Date.create not preserving the UTC flag when the source is also a date (Issue #235).\n- Object.clone on arrays with the \"deep\" flag set to true should create a deep clone of the array (Issue #237).\n- Array#min/max should throw an error when comparing to undefined (Issue #232).\n- Fix for dates that fallback to native parsing when forcing UTC flag (Issue #244).\n- Date#since/fromNow aliases will now count \"past\" integers instead of rounding (Issue #236).\n- Adding enumerable methods to `Object.extend()`.\n\n\nv1.3.6\n======\n\n### API Changes ###\n\n- Faster String#repeat (Issue #214 - Thanks to @termi!).\n- Fixed issue with Array#sample skewing randomization (Issue #216).\n- Limiting minute/second parsing to 0-59 (Issue #219).\n- Fixed issue with `addMonths` (Issue #221).\n- Fixed issue with NaN being true for `isOdd` (Issue #220).\n- Fixed issue with HTML escaping (Issue #212).\n- Fixed issue with float values parsing in `Object.fromQueryString` (Issue #225).\n- Internal refactoring of `Object.each`.\n- Fixed issue with `7 July` date format (Issue #227).\n- Added \"'yy\" as a valid year format.\n- Allowing empty strings for thousands separator and decimal in `Number#format` (Issue #229).\n\nv1.3.5\n======\n\n### API Changes ###\n\n- Now allowing \"n days later\" etc. as a parsable format (#199).\n- Added support for \"the nth\" format (#205).\n- Fixed issue with `Array.create` on objects (#195).\n- Fixed am/pm issues with Date parsing (#201).\n- Fixed issues with `Date.future` (#210), zh-CN locale time parsing, (#204).\n- Added support for Finnish locale (#185), Dutch, and Danish.\n- Fixed `Number.random` to have better random distribution (#196).\n- Issue with Date cloning (#200).\n\nv1.3.4\n======\n\n### API Changes ###\n\n- Refactored 3rd utc argument into a separate object for clarity.\n\n\nv1.3.3\n======\n\n### Internal Changes ###\n\n- multiMatch does not treat functions as callbacks when matching against other functions.\n\n\nv1.3.2\n======\n\n### API Changes ###\n\n- `Date#create` on ISO dates no longer sets the utc flag.\n- Fixed implementation of 'Function#bind', which was overriding native method due to an error in the MDN docs.\n\n\nv1.3.1\n======\n\n\n### API Changes ###\n\n- Matching by value in arrays is now opt-in and must meet certain requirements, namely being of class [object Object], and having `hasOwnProperty`. This will notably now exclude functions and host objects such as DOM elements. This means that such excluded objects will be matched by reference only.\n- Fixed issue with Array.create not properly creating arrays #171\n- Empty objects now match themselves in arrays #176\n- Date#setWeekday now returns a timestamp for consistency with Date#setDay #181\n- Date#toUTC deprecated in favor of Date#utc and utc flag in Date#create.\n- Date#setUTC deprecated in favor of direct use of utc flag.\n- Date#setUTCWeek deprecated in favor of direct use of utc flag.\n- Date#getUTCWeek deprecated in favor of direct use of utc flag.\n- Date#setUTCWeekday deprecated in favor of direct use of utc flag.\n- Date#clone now clones the utc flag of the date.\n- Fixed issue with DateRange causing an infinite loop when DST traverses back 1 hour.\n- Better date disambiguation for ambiguous dates (\"Sunday\", etc)\n- Various date parsing fixes.\n- Timers set by delays are now exposed #170\n- Function#debounce debounced function is now canceled instead of original.\n- Internal refactoring of class check handling.\n\n\n\nv1.3\n======\n\n\n### API Changes ###\n\n- Sugar modules are now further split up and can easily be customized and repackaged. Aside from \"core\" there is the \"es5\" module that can be opted out of if <= IE8 support isn't an issue. DateRanges (below) are now their own module, as are inflections.\n- Date locales are now a separate module, only English is included in the base \"date\" module.\n- Enumerable methods are now available as class methods on Object, and instance methods on extended objects. This includes: map, any, all, none, count, sum, average, find, findAll, min, max, least, most, and reduce.\n- Added Object.size (also available to extended objects)\n- Array#min, Array#max, Array#least, and Array#most now return a single element by default with the option to return multiple elements.\n- Object.equals now considers identical objects vs. extended objects to be the same\n- Refactored Object.isEmpty to be an enumerable method in the Array module. This means that it will error on non-objects now.\n- Added \"language\" module.\n- String#normalize moved from Inflections to Language module\n- String#has[Script] moved from String to Language module\n- String#hankaku and String#zenkaku moved from String to Language module\n- String#hiragana and String#katakana moved from String to Language module\n- String#namespace moved from Inflections to String module\n- String#parameterize now checks for normalize and also uses encodeURI for final output\n- String#split patching for regexes is now removed from the String module and is on its own in /lib/extra. It can be dropped in anywhere after Sugar is loaded.\n\n- Array#has is deprecated\n- Array#groupBy no longer returns extended objects\n- Array#groupBy no longer corrupts array length (Issue 142)\n- Enumerable methods now allow fuzzy matching of instances of classes (Issue 157)\n\n- All Math methods are now mapped onto Number and are accessible as instance methods\n\n- String#capitalize all will capitalize any letter after a letter that could not be capitalized.\n- String#insert, and Array#insert now treat negative indexes like String#slice\n- Fixed issue with decodeBase64 shim (Issue 145)\n\n- String#toDate is now deprecated.\n- Date parsing formats are now scoped by locale. This means that if the current locale is set to English, only English formats will be parsed when Date#create does not specify a locale, even if a different locale was initialized previously. Numeric and common formats are available in all locales.\n- Added output formats Date#long and Date#full which now included the time. Date#long (mm dd, yyyy hh:mm) is now the default for Date#format, and the previous default (no time) is now Date#short. Date#full includes milliseconds and weekday.\n- Date format \"just now\" now supported\n- Date#reset now supports resetting a unit based on a string.\n- Date#advance and other advance methods can now reset the time.\n- Date#advance now accepts string input like \"4 days\" (Issue 161)\n- Date.past and Date.future added which allow date parsing that prefers the past or future when the specified date is ambiguous (\"Sunday\", etc.)\n- Date parsing now allows time to be in front of the date string as well\n- Fixed various issues with timezones, DST, and date parsing (Issue 146), (Issue 138)\n- Added \"in 3 days\", etc. as a parsable format\n- Added \"the 2nd Tuesday of November\", etc. as a parsable format\n- Added more parsable formats with weekdays (such as \"last monday\", etc) in various locales\n- Added time parsing in non-English date formats\n- Fully qualified ISO language codes will now match more generic codes. This means passing \"it_IT\" will correctly find \"it\" if the more specific locale is not available.\n- Unknown languages codes will now simply return an invalid date instead of throwing an error.\n- Added support for full kanji numerals in date parsing\n- Added support for time suffixes in Asian time strings (æ™‚ etc)\n- Added support for various relative formats in CKJ dates  (å…ˆé€±æ°´æ›œæ—¥ etc)\n- Fixed inconsistently not allowing spaces before am/pm (Issue 144)\n- Added DateRange, accessed through Date.range\n\n\nv1.2.5\n======\n\n\n### API Changes ###\n\n- String#truncate refactored to split words by default (standard behavior) allow splitting in various positions, and changing argument order.\n- Object.isObject should be true for extended objects as well.\n- Function#throttle added to take the place of Function#debounce with `false` as the `wait` parameter.\n- Date parsing support for hour/minute/second fractions (now take the place of milliseconds).\n- Date parsing support now sees commas in decimals.\n- Date parsing support for .NET dates.\n\n\nv1.2.4\n======\n\n\n### API Changes ###\n\n- Major performance improvement for Array#unique, Array#union, Array#intersect (now On vs. OnÂ²)\n- Array#min, Array#max, Array#most, Array#least also benefit from this.\n- Object.equal(s) is now egal (this should only matter for edge cases) like Underscore.\n- Object.merge will now work on non-objects as well.\n- Custom formats in Date.addFormat will now override built-in formats.\n- Fix for Array#union incorrectly flattening arrays.\n- Fix for isObject not working across iframes.\n- Fix for String#chars incorrectly trimming.\n- Fix for String#each not matching all characters.\n\n### Internal Changes ###\n\n- multiArgs now flatten is opt-in\n\nv1.2.3\n======\n\n\n### API Changes ###\n\n- String#compare, Number#compare, and Date#compare are deprecated.\n- Array#sortBy now makes much more sensible sorting when sorting on strings.\n- Added Array.AlphanumericSortOrder\n- Added Array.AlphanumericSortIgnore\n- Added Array.AlphanumericSortIgnoreCase\n- Added Array.AlphanumericSortEquivalents\n- Object.merge defaults are now more sensible. shallow/deep is 3rd with shallow default and resolve is 4th\n- Added Number#duration to dates module.\n- Bugfix for leaking globals.\n- Bugfix for String#compact (Issue 115)\n\n### Internal Changes ###\n\n- Cleanup for toISOString internal code.\n\n\n\n\nv1.2.2\n======\n\n\n### API Changes ###\n\n- Performance optimization for Object.merge and by extension Object.clone\n- Object.extended now maintains its \"Hash\" constructor and checks against it when cloning.\n- Object.merge now will also clone dates and regexes as well.\n- Reset dates that will be set with UTC methods (fixes issue #98).\n\n### Internal Changes ###\n\n\n- Removed references to isDefined, isNull, and isObjectPrimitive\n\n\n\n\nv1.2.1\n======\n\n\n### API Changes ###\n\n- Added Object.has to fix issue #97. Stand-in for Object#hasOwnProperty.\n- Fixed issue with String#has not escaping regex tokens.\n- Date.setLocale can now overwrite a default locale object.\n- Date locales can now add their own formats.\n- Fix for Ender, which was broken when modularized in 1.2.\n- Workaround for Ender requiring externs.\n\n### Internal Changes ###\n\n- Date optional tokens now start from {0}\n- References to Object.extend and Object.restore now held and allowed to be restored later.\n\n\nv1.2\n====\n\n\n### API Changes ###\n\n- Allowed external libraries to extend natives through a common interface \"extend\".\n- Renamed \"sugar\" to \"restore\" to restore Sugar methods on a given class.\n- Extending Object.prototype functionality is now on \"extend\" instead.\n- Split the date library into its own module that hooks into this new interface.\n- Added a new module: String inflections\n- Object.keys now passes values as part of the callback like array methods.\n- Object.merge now merges undefined properties as well.\n- Array#every now uses fuzzy object matching\n- Array#some now uses fuzzy object matching\n- Array#filter now uses fuzzy object matching\n- Array#find now uses fuzzy object matching\n- Array#findAll now uses fuzzy object matching\n- Array#findIndex now uses fuzzy object matching\n- Array#remove now uses fuzzy object matching\n- Array#none now uses fuzzy object matching\n- Array#count now uses fuzzy object matching\n- Array#exclude now uses fuzzy object matching\n- Array#clone is now no longer based off Array#concat, which will fail on sparse arrays in IE7.\n- Added Number#abbr\n- Added Number#metric\n- Added Number#bytes\n- Added Number#isInteger\n- Fixed issue with Number#ordinalize where 113 would be \"113rd\".\n- String#each will now pass the match into the callback\n- String#toDate will now check for Date.create before hooking into it.\n- String#underscore will now check for acronyms if Inflectors module is present.\n- String#camelize will now check for acronyms if Inflectors module is present.\n- RegExp.escape will now perform a [toString] operation on non-strings (i.e. numbers, etc).\n- Function#fill now uses internal Array#splice to fill in arguments.\n- Added support for JSON date format Date(xxxxxxxxxx).\n- Fixed issues with Date#getWeek.\n- Fixed issues with traversing months before January.\n- String#titleize added to inflections module.\n\n\n### Internal Changes ###\n\n- Reworked \"multiMatch\" to recursively traverse object structures.\n- mergeObject now merges undefined properties as well\n- Created method arrayIntersect to handle both Array#intersect and Array#subtract\n- Array#intersect and Array#subtract will not allow fuzzy object matching\n- Array#indexOf and Array#lastIndexOf polyfills now work off arrayIndexOf\n- Added internal support for other dates that use timestamps.\n- Reworked adding of Date#toISOString and Date#toJSON support.\n\n\n\n\nv1.1.3\n======\n\n### API Changes ###\n\n- Fixed issue with Object.isEmpty where strings with length > 0 will return true.\n\n### Internal Changes ###\n\n- Updated Array#sortBy to use .compare method when available.\n\n\nv1.1.2\n======\n\n### API Changes ###\n\n- Added Array#findIndex.\n- Added Array#sample.\n- Added String#compare.\n- Added Number#compare.\n- Added Date#compare.\n- Fixed issue with floats not properly being recognized in the query string.\n- Fixed issue with Object.isEmpty on non-object types and null.\n- Fixed issue with arrayEach not allowing negative start indexes.\n- Fixed issue with Array#reduce not recognizing 0 as a starting value.\n- Fixed issue with Array#add not allowing negative indexes.\n- Fixed issue with Number.random not recognizing upper limit of 0.\n- Fixed issue with String#dasherize not working on single camel cased letters.\n- Fixed issue with String#assign not working on an empty string or other falsy value.\n- Fixed issues with French and German date months not being correct.\n- Fixed Function#after not calling the method immediately when num is 0.\n\n\n### Internal Changes ###\n\n- Refactored Array#reduce and Array#reduceRight to use the same internal method.\n- Refactored String#camelize to be smaller.\n- Refactored checkMonthTraversal to be more robust in a variety of situations.\n\nv1.1.1\n======\n\n### API Changes ###\n\n- Object.merge now accepts a third parameter that determines what to do in the case of property conflicts. This parameter can be true, false, or a function. This change means that it now no longer accepts an arbitrary number of arguments.\n- Added Object.isNaN\n- Added Object.tap\n- Consolidated the arguments that are passed to mapping functions on methods such as Array#min/max/groupBy/sortBy. All such functions will now be passed the array element, array index, and array object, in that order, to conform to ES5 Array#map behavior.\n- Array#flatten can now accept a level of nesting to flatten to. Default is all levels.\n- Array#remove no longer works like a reverse concat (i.e. no longer flattens arguments passed to it as if they were passed as separate arguments, so removing arrays within arrays should now work properly. This applies to Array#exclude as well.\n- Added Array#zip\n\n### Internal Changes ###\n\n- Refactored way in which type/hash methods are mapped\n- Fixed Date bug \"2 weeks from Monday\"\n\nv1.1\n====\n\n### API Changes ###\n\n- Array#unique can now unique on a function, giving a shortcut to uniquify deep objects\n- Object.equals renamed to Object.equal in its class method only\n- Object.equal now much more robust, can handle cyclic references, etc\n- Number#format now accepts a parameter <place> for the decimal. \"thousands\", and \"decimal\" are pushed to 2nd and 3rd params\n- Date#format now accepts different format tokens. A few counterintuitive ones removed, and others were added to match moment.js including fff, ddd, mmm, etc\n- Function#lazy now executes immediately and locks instead of setting a delay\n- Added RegExp#getFlags\n- Added Function#fill, which allows arguments to be intelligently curried\n- Fixed broken support for SpiderMonkey under CouchDB\n- Fixed sortBy is unintentionally destructive\n- Full Asian date number formats now accepted\n- Array#map/min/max/most/least/groupBy/sortBy no longer errors on undefined, null, etc\n- Fixed a bug with locking on Number#format when passing digits\n\n### Internal Changes ###\n\n- Optimized for Google closure compilers max compression level\n- Minified script dropped about 5kb\n- Intelligently determining if cloned objects are extended\n- transformArgument now just accepts <map> not the arguments object\n- refactored asian digits to be globally replaced\n- Date#toJSON and Date#toISOString now properly fall back to native methods\n- Significantly wrote asynchronous function tests to be more reliable\n\n\n\nv1.0\n====\n\n### API Changes ###\n\n- Object.sugar() now will add all extended object (hash) methods to Object.prototype, letting you opt-in this functionality\n- Object.watch() will observe changes in an object property and fire a callback if it has changed\n- Array.create() quickly creates arrays, most notably from an arguments object\n- Array#groupBy now allows a callback to iterate over each group\n- String#normalize method deprecated, but still available in lib directory\n- String#is/hasArmenian, is/hasBopomofo, is/hasEthiopic, and is/hasGeorgian deprecated\n- String#is/hasLatin added\n- String#toDate now accepts a locale parameter\n- String#spacify added\n- String#assign added\n- Date module completely reworked to allow locales\n- Date#format \" short\" token suffix deprecated\n- Date#format \" pad\" token suffix deprecated\n- Date#format \"dir\" parameter passed to the callback deprecated in favor of using the sign directly on the time itself\n- Date#format locale now passed to the callback instead of the above\n- Date#format passing no arguments now outputs a default simple date format for the current locale\n- Date#relative same treatment as Date#format for callbacks as above\n- Date.allowVariant for ambiguous dates (8/10/03) refactored to use locales instead\n- Date.RFC1123 and Date.RFC1036 fix to not display GMT\n- Date.setLocale will set an available locale or allow extending the Date class with new locales\n- Date.getLocale gets a localization object (current localization by default)\n- Date.addFormat allows additional date formats to be added\n- Date#set passing true for the second param will now reset any units less specific, not just the time\n- Date#isBefore/isAfter/isBetween now uses a straight comparison rather than trying to extend the bounds of the date based on specificity\n- Date#format now accepts a second locale parameter that outputs the date in a specific locale. If no locale is set the current locale is used.\n- Date#format passing \"relative\" as the format is now deprecated. Use Date#relative instead\n- Function#lazy now accepts a \"limit\" parameter that will prevent a lazy function from queueing calls beyond a certain limit\n- Function#debounce now accepts a \"wait\" parameter (default is true) that will allow function execution AFTER the timeout to be turned off so the function is run immediately\n\n\n\n\n### Internal Changes ###\n\n- major docs updates\n- arrayEach will now default to not loop over sparse arrays unless explicitly told to\n- major internal refactoring of the Date module to be more compact, robust, and light\n- date module will be distilled and contained on its own in the repo\n\n\nv0.9.5\n======\n\n### API Changes ###\n\n- .sugar method added to all classes to reinstate Sugar methods conditionally.\n- Object.clone is now shallow by default, with an option for deep cloning\n- Object.merge will now ignore non-objects\n- Object.fromQueryString now takes the place of String#toObject.\n- Nested object/array param parsing now possible with Object.fromQueryString.\n- Array#remove now accepts unlimited parameters\n- Array#exclude now accepts unlimited parameters\n- Array#union now accepts unlimited parameters\n- Array#subtract now accepts unlimited parameters\n- Array#intersect now accepts unlimited parameters\n- Array#split deprecated\n- Array#compact no longer removes functions (bug)\n- Array#compact now accepts flag to compact all falsy values\n- Number#upto and Number#downto now accept a third parameter to traverse in multiples of > 1\n- Number#pad now accepts a third parameter that is the base of the number\n- Number#hex now accepts a parameter to pad the resulting string with a default of 1\n- String#escapeHTML added\n- String#truncate added. Will truncate a string without breaking words.\n- String#toObject now refactored to Object.fromQueryString\n- Function.lazy refactored to Function#lazy\n- Function#lazy functions can now be cancelled via Function#cancel\n- Function#defer deprecated -> use Function#delay instead\n- Function#debounce added\n- Function#after added\n- Function#once added\n\n\n### Internal Changes ###\n\n- extendWithNativeCondition removed. Functionality now contained in extend\n- shuffled and removed some dependencies to make it easier to extract the date module\n- more robust equality comparison:\n- multiArgs added to collect arguments\n- array indexes now checked with hasProperty instead of hasOwnProperty\n- object builders are now going through extend so they can store their references\n- Object.clone refactored to use multiArgs\n- Object.isEmpty now returns false if passed argument itself is falsy\n- String#stripTags refactored to use multiArgs\n- String#removeTags refactored to use multiArgs\n-- \"null\" now taken into consideration for objects\n-- object key length compared\n-- strict equality matches in multiMatch\n\n\nv0.9.4\n======\n\n- Emergency fix for Array#compact incorrectly detecting NaN.\n\nv0.9.3\n======\n\n### API Changes ###\n\n- Array.isArray polyfill added and aliased by Object.isArray (es5)\n- Array#every/some/map/filter now throws a TypeError if no arguments passed (es5)\n- Array#every/some/map/filter now defers to native if available and no arguments passed (es5)\n- Array#none/any/all/has aliases similarly throw TypeErrors if no arguments passed (es5)\n- Array#indexOf/lastIndexOf now performs a simple strict equality check. Added to v0.9.2 but separately here (es5)\n- Array#indexOf/lastIndexOf refactored to defer to String#indexOf/lastIndexOf if a string is passed as the scope (es5)\n- Array#forEach/reduce/reduceRight now all throw a TypeError if callback is not callable (es5)\n- Array#reduce/reduceRight now throw a TypeError if the array is empty and no initial value passed (es5)\n- Array#each is now no longer an alias of forEach and has different behavior:\n - second parameter is the index to start from\n - third parameter is a boolean that runs the loop from the beginning if true\n - returns the array\n - fn returning false will break out of the loop\n - will throw a TypeError if fn is not callable (same as forEach)\n - array is now passed as the scope\n - now detects sparse arrays and switches to a different algorithm to handle them\n- Array#find refactored to use an internal method insted of Array#findAll to avoid collisions\n- Array#find now breaks as soon as it finds an element\n- Array#eachFromIndex removed\n- Array#removeAtIndex renamed to Array#removeAt\n- Array#unique refactored to use an internal method instead of Array#find to avoid collisions\n- Array#subtract/intersect refactored to use an internal method instead of Array#find to avoid collisions\n- Array#subtract/intersect refactored to use Array.isArray instead of Object.isArray\n- Array#union refactored to use an internal method instead of Array#unique to avoid collisions\n- Array#min/max refactored to use an internal method instead of Array#unique to avoid collisions\n- Array#least/most will now throw a TypeError if the first argument exists, but is not a string or function\n- Array#least/most refactored to use an internal method instead of Array#unique to avoid collisions\n- Array#groupBy will now throw a TypeError if the first argument exists, but is not a string or function\n- Array#sortBy will now throw a TypeError if the first argument exists, but is not a string or function\n- Array#compact/flatten now internally uses Array.isArray instead of Object.isArray\n- Array#collect alias removed\n- Array#shuffle alias removed\n- String#hankaku/zenkaku/hiragana/katakana refactored to shift char codes instead of using a hash table\n- String#hankaku/zenkaku refactored to be much more accurate & strictly defined\n- String#shift added\n- String#trim refactored to handle all characters covered in es5/unicode (es5)\n- String#trim refactored to check for support and polyfill as needed (es5)\n- String#titleize removed\n- String#capitalize refactored to allow capitalization of all letters\n- String#pad/padLeft/padRight refactored to accept the number as the second param and padding as the first\n- String#repeat refactored to return a blank string on num < 1\n- String#add refactored to act in parallel with Array#add\n- String#remove added as a reciprocal of String#add and a parallel of Array#remove\n- String#dasherize/underscore refactored to strip whitespace\n- Object.keys refactored to defer to native if < 2 arguments instead of == 1\n- Object.keys will now throw a TypeError if non-object passed (es5)\n- Number.random fixed which had implied globals min & max\n- Date.now polyfill added (es5)\n- Date#toISOString refactored polyfill to check for native browser support (es5)\n- Date#toJSON added as a polyfill alias to Date#toISOString with similar native checks (es5)\n- Date#format/relative refactored to point to an internal method to avoid collisions\n- fixed date methods in ambiguous situations such as \"5 months ago\" when the target month does not have enough days\n- Function#bind refactored to check for native support and behave much more closely to spec (es5)\n- added documentation for unicode block methods\n- added devanagari and ethiopic scripts\n\n\n### Internal Changes ###\n\n- refactored unicode script methods to use .test instead of .match\n- extendWithNativeCondition refactored to allow a \"supported\" flag\n- getMinOrMax refactored to use iterateOverObject\n- getFromIndexes renamed to getAtIndexes\n- toIntegerWithDefault added\n- arrayFind added\n- arrayEach added\n- arrayUnique added\n- isArrayIndex added (es5)\n- toUint32 added (es5)\n- checkCallback added (es5)\n- checkFirstArgumentExists added (es5)\n- buildObject refactored to be less invasive\n\n\n\nv0.9.2\n======\n\n- Emergency fix to alleviate issues with indexOf/lastIndexOf breaking on functions/deep objects\n\n\n\nv0.9.1\n======\n\n- Change Object.create to Object.extended to avoid collision with ES5\n- Use of defineProperty in modern browsers to prevent enumeration in for..in loops.\n- Add test for for..in loop breakage and allowed older browsers to have a \"warning\" message.\n- Object.isArray will now alias native Array.isArray if it is present.\n- Fix collisions with Prototype on Object.clone.\n- Test cleanup.\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0263671875,
          "content": "Copyright Â© Andrew Plummer\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.73046875,
          "content": "# Sugar\n\n[![Build Status](https://travis-ci.org/andrewplummer/Sugar.svg)](http://travis-ci.org/andrewplummer/Sugar)\n[![Coverage Status](https://coveralls.io/repos/andrewplummer/Sugar/badge.svg?branch=master)](https://coveralls.io/r/andrewplummer/Sugar?branch=master)\n\nA Javascript library for working with native objects.\n\n---------------------------------------\n\n- [**Install**](#install)\n- [**Upgrading**](#upgrading)\n- [**Getting Started**](#getting-started)\n- [**Documentation**](#documentation)\n- [**Custom Builds**](#custom-builds)\n- [**Browser**](#browser)\n- [**npm**](#npm)\n- [**Modules**](#modules)\n- [**Date Locales**](#date-locales)\n- [**Timezones**](#timezones)\n- [**Defining Methods**](#defining-methods)\n- [**Plugins**](#plugins)\n- [**Contributing**](#contributing)\n- [**Road Map**](#road-map)\n\n---------------------------------------\n\n\n# v2.0.4\n\n### [sugar.js](https://raw.githubusercontent.com/andrewplummer/Sugar/2.0.4/dist/sugar.js) | [sugar.min.js (24kb gz)](https://raw.githubusercontent.com/andrewplummer/Sugar/2.0.4/dist/sugar.min.js)\n\n\n## Install\n\n#### `npm install sugar`\n#### `bower install sugar`\n\n\n## Upgrading\n\nIf you are upgrading from v1, there is now an upgrade [helper script](https://sugarjs.com/upgrading)\navailable that makes upgrading easier by warning you about breaking changes as\nyour code is run. The [CAUTIONLOG](CAUTION.md) is also available, which is a\nvetted changelog showing breaking changes in order of severity.\n\n\n## Getting Started\n\n#### [https://sugarjs.com/quickstart/](https://sugarjs.com/quickstart/)\n\n\n## Documentation\n\n#### [https://sugarjs.com/docs/](https://sugarjs.com/docs/)\n\n\n## Custom Builds\n\n#### [https://sugarjs.com/download/](https://sugarjs.com/download/)\n\nCustom browser builds can be created on the site download page. In addition,\ntools like Browserify can also be used to create custom builds, as npm packages\nare now fully modular. The main repo also has tasks to create custom builds as\nwell. Simply clone, run `npm install` then `gulp`.\n\n\n## Browser\n\nThe `dist` directory holds builds that are ready to be loaded in the browser.\nThese builds include the `core` module, and so have no dependencies. Bower\npackages at the moment include only this directory. Use the `es5` builds if you\nrequire support for environments that do not support ES5 natively (IE8 and below).\n\n\n## npm\n\nThe `sugar` npm package allows methods as well as entire modules to be required\nindividually. If you are using a build tool like Browserify, this will make it\nsimple to create smaller custom builds without going through the download page.\nAll packages also include pre-built distributions in the `dist/` directory.\n\nIn addition to the main `sugar` package, there are also packages separated by\nSugar module, i.e. `sugar-date`, `sugar-array`, etc.\n\nWhen an entry point is required (the package name or an entire module), it will\nreturn a reference to `Sugar`, which is equivalent to the global object in the\nbrowser. All methods will be defined on this object and can be called as normal.\nRequiring an individual method will define it on `Sugar` and additionally return\na reference to its static form that can be called immediately:\n\n```javascript\n// Require all modules\nvar Sugar = require('sugar');\nSugar.Number.round(3.1415);\n\n// Require the Number module\nvar Sugar = require('sugar/number');\nSugar.Number.round(3.1415);\n\n// Require only the \"round\" method\nvar round = require('sugar/number/round');\nround(3.1415);\n```\n\nAs the npm package is designed with node in mind, polyfills must be explicitly\nrequired (the `sugar` entry point will not include them), and will immediately\napply themselves if the methods they polyfill are missing.\n\n```javascript\n// Require and apply ES6 polyfills\nrequire('sugar/polyfills/es6');\n```\n\nSimilarly, date locales must be explicitly required as well:\n```javascript\n// Require the Japanese date locale\nrequire('sugar/locales/ja');\n// Require all date locales\nrequire('sugar/locales');\n```\n\n\nAll Sugar npm packages are dependent on the `sugar-core` package.\n\n## Modules\n\nAlthough Sugar builds can now be customized at method level, modules are still\nused as an intuitive way of grouping similar methods. Sugar npm packages make\nuse of modules, both in the main `sugar` package as well as individual module\npackages beginning with `sugar-`. The following modules are available:\n\n#### Default:\n\n- [ES6](lib/es6.js) (Polyfills)\n- [ES7](lib/es7.js) (Polyfills)\n- [Array](lib/array.js)\n- [Date](lib/date.js)\n- [Enumerable](lib/enumerable.js) (shared methods on Array and Object)\n- [Function](lib/function.js)\n- [Number](lib/number.js)\n- [Object](lib/object.js)\n- [Range](lib/range.js) (String, Number, and Date ranges)\n- [RegExp](lib/regexp.js)\n- [String](lib/string.js)\n\n#### Non-default:\n\n- [ES5](lib/es5.js) (Polyfills, adds IE6-8 Support)\n- [Language](lib/language.js) (Character conversion and script detection)\n- [Inflections](lib/inflections.js) (Pluralization and string normalization)\n\nNon-default modules are excluded from the main Sugar build, but can be added by\ncreating a [custom build](#custom-builds). The main npm package includes the ES5\nmodule, polyfills are disabled by default and must be explicitly required.\nOther non-default modules can be found individually (i.e. `sugar-language`, etc).\n\n## Date Locales\n\nLocale definition files are in the [locales](lib/locales/) directory. They can be\nsimply included as-is after Sugar is loaded, or built together using\n[custom builds](#custom-builds). English is included by default and required by\nthe Date module. Currently available locales are:\n\n- [Catalan (ca)](lib/locales/ca.js)\n- [Danish (da)](lib/locales/da.js)\n- [Dutch (nl)](lib/locales/nl.js)\n- [Finnish (fi)](lib/locales/fi.js)\n- [French (fr)](lib/locales/fr.js)\n- [German (de)](lib/locales/de.js)\n- [Italian (it)](lib/locales/it.js)\n- [Japanese (ja)](lib/locales/ja.js)\n- [Korean (ko)](lib/locales/ko.js)\n- [Norwegian (no)](lib/locales/no.js)\n- [Polish (pl)](lib/locales/pl.js)\n- [Portuguese (pt)](lib/locales/pt.js)\n- [Russian (ru)](lib/locales/ru.js)\n- [Spanish (es)](lib/locales/es.js)\n- [Swedish (sv)](lib/locales/sv.js)\n- [Simplified Chinese (zh-CN)](lib/locales/zh-CN.js)\n- [Traditional Chinese (zh-TW)](lib/locales/zh-TW.js)\n\n#### Adding/Customizing Locales\n\nIf a locale or format is missing, it can easily be added by modifying or adding\nthe definition. See [here](https://sugarjs.com/docs/#/DateLocales) for more on\nthis. Please consider contributing any changes made back to the community!\n\n\n## Timezones\n\nSugar does not deal with timezone abbreviations (i.e. \"PST\", etc). Timezone\noffsets will be correctly parsed if they are in ISO-8601 format (+09:00, +0900,\nor Z for UTC), however if an abbreviation exists it will be ignored. Sugar\nhowever plays nicely with other libraries that offer full timezone support such\nas [timezone.js](https://github.com/mde/timezone-js).\n\n`Date.create` allows two options for dealing with UTC dates. `fromUTC` will\nparse the string as UTC, but return a normal date. In contrast, `setUTC` tells\nSugar to use methods like `getUTCHours` when handling the date, and is usually\nused when the date needs to be formatted as UTC. Native methods like `getHours`\nstill return local values.\n\n## Defining Methods\n\nSugar now makes it easy to define your own methods. This is aimed at developers\nhoping to release their own plugins with Sugar. After defining methods, they can\nbe extended or used as chainables just like other methods:\n\n```javascript\nSugar.Number.defineStatic('randomish', function () {\n  if (Math.random() > .5) {\n    return Math.random();\n  } else {\n    return 1;\n  }\n});\n\nSugar.Number.defineInstance({\n  'square': function (n) {\n    return n * n;\n  },\n  'cube': function (n) {\n    return n * n * n;\n  }\n});\n\nSugar.Number.square(3);         // 9\nnew Sugar.Number(5).cube().raw; // 125\nSugar.Number.randomish()        // ???\n\nSugar.extend();\n(2).square();       // 4\n(4).cube();         // 64\nNumber.randomish(); // ???\n\n```\n\nSee the [docs](https://sugarjs.com/docs/#/Sugar) for options and other helpers.\n\n## Plugins\n\nIf you are defining methods that are useful to the general public, please consider\nreleasing them as a Sugar plugin! Refer to the\n[plugin boilerplate](https://github.com/andrewplummer/sugar-plugin-boilerplate)\nrepo for an example to get started.\n\n## Contributing\n\nIf you would like to issue a pull request, please first consider adding well\nformed [unit tests](test/tests/). These tests can be run directly in the browser\nfrom the [test/browser/](test/browser/) directory or in node with `npm test`.\n\n## Road Map\n\nProposals for core features or major method changes will be added to the\n[road map](https://github.com/andrewplummer/Sugar/wiki/Road-Map). New methods\nmay or may not be accepted, depending on their utility. Generally, they will\nfirst be delegated to plugins that may eventually be added to the main library\nwhen they reach a certain stage of popularity.\n"
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.625,
          "content": "{\n  \"name\": \"sugar\",\n  \"description\": \"A Javascript utility library for working with native objects.\",\n  \"homepage\": \"https://sugarjs.com/\",\n  \"license\": \"MIT\",\n  \"authors\": [\n    \"Andrew Plummer <plummer.andrew@gmail.com>\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/andrewplummer/Sugar.git\"\n  },\n  \"keywords\": [\n    \"sugar\",\n    \"sugarjs\",\n    \"functional\",\n    \"browser\",\n    \"utility\",\n    \"util\"\n  ],\n  \"main\": \"dist/sugar.js\",\n  \"ignore\": [\n    \"**/*\",\n    \"!dist/*\",\n    \"!dist/locales/*\",\n    \"!CHANGELOG.md\",\n    \"!CAUTION.md\",\n    \"!README.md\",\n    \"!LICENSE\"\n  ],\n  \"moduleType\": [\n    \"globals\"\n  ]\n}\n"
        },
        {
          "name": "dist",
          "type": "tree",
          "content": null
        },
        {
          "name": "gulpfile.js",
          "type": "blob",
          "size": 141.140625,
          "content": "\nvar fs      = require('fs'),\n    gulp    = require('gulp'),\n    path    = require('path'),\n    args    = require('yargs').argv,\n    gutil   = require('gulp-util');\n\n// -------------- Tasks ----------------\n\ngulp.task('default', showTasks);\ngulp.task('help',    showTasks);\ngulp.task('tasks',   showTasks);\ngulp.task('more',    showMore);\n\ngulp.task('build',       buildDefault);\ngulp.task('build:dev',   buildDevelopment);\ngulp.task('build:min',   buildMinified);\n\ngulp.task('build:qml',     buildQml);\ngulp.task('build:locales', buildLocales);\n\ngulp.task('build:packages',       buildPackagesDefault);\ngulp.task('build:packages:core',  buildPackagesCore);\ngulp.task('build:packages:sugar', buildPackagesSugar);\ngulp.task('build:packages:clean', buildPackagesClean);\n\ngulp.task('build:release', buildRelease);\n\ngulp.task('test',     testRunDefault);\ngulp.task('test:npm', testRunNpm);\ngulp.task('test:all', testRunAll);\n\ngulp.task('test:watch',     testWatchDefault);\ngulp.task('test:watch:npm', testWatchNpm);\ngulp.task('test:watch:all', testWatchAll);\n\ngulp.task('json:api',    buildJSONAPI);\ngulp.task('json:docs',   buildJSONDocs);\ngulp.task('json:source', buildJSONSource);\n\ngulp.task('tsd', buildTypescriptDeclarations);\n\n// -------------- Help ----------------\n\nvar MESSAGE_TASKS = `\n\n     # Usage\n\n       |gulp| [TASK] [OPTIONS]\n\n     # Tasks\n\n       |build|                          Create development and minified build.\n       |build:dev|                      Create development build (concatenate files only).\n       |build:min|                      Create minified build (closure compiler).\n\n       |build:packages|                 Builds modularized packages (all by default).\n       |build:packages:core|            Builds the \"sugar-core\" package.\n       |build:packages:sugar|           Builds the \"sugar\" npm package.\n       |build:packages:clean|           Cleans package output directory (\"packages\" by default).\n\n       |build:qml|                      Creates a QML compatible build.\n       |build:locales|                  Exports locale files to \"dist\" directory.\n\n       |build:release|                  Create a release. Requires a version.\n\n       |test|                           Run tests against distributed build (build:dev).\n       |test:npm|                       Run tests against npm packages (build:npm:all).\n       |test:all|                       Run tests against distributed and npm (build:dev, build:packages).\n\n       |test:watch|                     Watch for changes and run \"test\".\n       |test:watch:npm|                 Watch for changes and run \"test:npm\".\n       |test:watch:all|                 Watch for changes and run \"test:all\".\n\n       |json:api|                       Builds API method list as JSON.\n       |json:docs|                      Builds full docs set as JSON.\n       |json:source|                    Builds modularized source as JSON.\n\n       |tsd|                            Builds typescript declarations (sugar.d.ts).\n                                        Run \"gulp more\" for more options.\n\n       |more|                           Show more help details.\n\n     # Options\n\n       |-m, --modules|                  Comma separated modules to include (dev/min tasks).\n                                        Run \"gulp more\" for modules (non-default marked with *).\n\n       |-l, --locales|                  Comma separated date locales to include (dev/min tasks).\n                                        Run \"gulp more\" for locales. English packaged with date module.\n\n       |-p, --packages|                 Comma separated packages to build (\"packages\" tasks).\n                                        Run \"gulp more\" for packages.\n\n       |-o, --output|                   Build output path (default is \"dist/sugar.js\" or \"dist/sugar.min.js\").\n                                        Also output file for JSON tasks.\n\n       |-v, --version|                  Version for \"release\" build.\n\n       |--es5|                          Include ES5 module in build (dev/min tasks).\n\n       |--no-polyfill|                  Exclude ES6/ES7 modules from build (dev/min tasks).\n\n       |--charset|                      Charset flag to pass to the compiler. Note that although \"utf-8\"\n                                        produces smaller output, default build is smaller after gzip.\n\n       |--source-map|                   Compiler source map filename. Default is \"sugar.min.map\".\n\n       |--no-source-map|                Do not output a source map.\n`;\n\nvar MESSAGE_EXTRA = `\n     # Modules\n\n       |es5 *|                          Full ES5 polyfill suite (adds IE6-8 support).\n       |es6|                            Partial ES6 polyfills, mostly for String/Array support.\n       |es7|                            Partial ES7 polyfills. Currently only Array#includes.\n       |date|                           Date parsing, manipulation, formatting, and locale support.\n       |string|                         String encoding, truncating, formatting, and more.\n       |array|                          Array sorting, uniquing, randomizing, and more.\n       |object|                         Object merging, manipulating, type checks, and more.\n       |enumerable|                     Traversing, mapping, finding, etc. Shared by Array and Object.\n       |function|                       Function throttling, memoizing, partial functions, and more.\n       |number|                         Number formatting, rounding, math aliases, and more.\n       |regexp|                         RegExp escaping and flag manipulation methods.\n       |range|                          Date, Number, and String ranges.\n       |language *|                     Script detection, half/full width conversion, kana.\n       |inflections *|                  Pluralizing and special character normalization.\n\n       |* Not included in default builds|\n\n     # Packages\n\n       |sugar-core|                     Core method defining functionality. Dependency for all other packages.\n       |sugar|                          All default modules and optional date locales.\n\n       |sugar-es5|                      ES5 polyfill methods only.\n       |sugar-es6|                      ES6 polyfill methods only.\n       |sugar-es7|                      ES7 polyfill methods only.\n       |sugar-string|                   String module and ES6 polyfills.\n       |sugar-number|                   Number module and ES6 polyfills.\n       |sugar-enumerable|               Enumerable module and ES6/ES7 polyfills.\n       |sugar-date|                     Date module and optional locales.\n       |sugar-array|                    Array module.\n       |sugar-object|                   Object module.\n       |sugar-function|                 Function module.\n       |sugar-regexp|                   RegExp module.\n       |sugar-range|                    Range module.\n       |sugar-language|                 Language module.\n       |sugar-inflections|              Inflections module.\n\n     # Locales\n\n       |Bundled:|\n\n       |en|                             Alias to \"en-US\" (sorry).\n       |en-US: American English|        mm/dd/yyyy preferred, Sunday starts week.\n       |en-GB: British English|         Slightly different output formats.\n       |en-CA: Canadian English|        Slightly different output formats.\n       |en-AU: Australian English|      Alias to \"en-GB\" for now.\n\n       |Optional:|\n\n       LOCALE_LIST\n\n     # Modular Builds\n\n       The npm build tasks split out all methods and dependencies in the\n       source code so that they can be consumed individually. The result\n       of these tasks will be identical to the packages hosted on npm.\n       For more information on how to include them, see the README.\n\n       Bower packages contain only the builds in the \"dist/\" directory.\n       As bower requires a public git endpoint, the result of these tasks\n       will be identical to the modularized repos on Github. This also means\n       that there is no separate \"sugar\" package for bower as it is identical\n       to this repo.\n\n     # Typescript Options\n\n       By default the \"tsd\" task builds Typescript declarations for Sugar in\n       extended mode, but without Object.prototype modifications. The task can\n       be modified to change these defaults, or include/exclude methods or modules:\n\n\n       |--no-extended-mode|             When this flag is present, declarations for extended mode\n                                        (i.e. native objects) are not output.\n\n       |--modules|                      Filter exported methods by module. This argument\n                                        is required for non-default modules. Also accepts\n                                        \"all\" or \"default\".\n                                        --modules=String,Inflections\n\n       |--include|                      Whitelist methods or namespaces to be included:\n                                        --include=Array --include=Array:unique.\n\n       |--exclude|                      Blacklist methods or namespaces to be excluded:\n                                        --exclude=Array --exclude=Array:unique.\n`;\n\nfunction showTasks() {\n  if (args.help) {\n    showMore();\n  } else {\n    showMessage(MESSAGE_TASKS);\n  }\n}\n\nfunction showMore() {\n  showMessage(MESSAGE_TASKS + MESSAGE_EXTRA);\n}\n\nfunction showMessage(message) {\n  var msg = message.replace(/LOCALE_LIST/g, function() {\n      return getAllLocales().map(function(l) {\n        var code = l.match(/([\\w-]+)\\.js$/)[1];\n        var name = readFile(l).match(/\\* (.+) locale definition/i)[1];\n        return gutil.colors.yellow(code + ': ' + name);\n      }).join('\\n       ');\n    })\n    .replace(/\\[\\w+\\]/g, function(match) {\n      return gutil.colors.dim(match);\n    })\n    .replace(/# [\\w ]+$/gm, function(match) {\n      return gutil.colors.underline(match.replace(/^# /g, ''));\n    })\n    .replace(/\\|.+?\\|/g, function(match) {\n      return gutil.colors.yellow(match.replace(/\\|/g, ''));\n    })\n    .replace(/^\\s{30,}/gm, function(match) {\n      return match.slice(2);\n    });\n  console.log(msg);\n}\n\n// -------------- Release ----------------\n\nfunction buildRelease() {\n  var version = getVersion(), run = true;\n  if (!version.match(/^\\d.\\d+\\.\\d+$/)) {\n    warn('Release requires a valid x.x.x version!');\n    run = false;\n  }\n  if (!run) process.exit();\n  return mergeStreams([\n    buildDevelopment(),\n    buildMinified(),\n    buildPackagesDefault()\n  ]);\n}\n\n// -------------- Compiler ----------------\n\nvar COMPILER_JAR_PATH = 'node_modules/google-closure-compiler/compiler.jar';\n\nfunction compileSingle(path) {\n  var compiler = require('closure-compiler-stream');\n  var flags = getDefaultFlags();\n  flags.js_output_file = path;\n  if (args.sourceMap !== false) {\n    flags.create_source_map = args.sourceMap || path.replace(/\\.js/, '.map');\n  }\n  if (args.charset) {\n    flags.charset = args.charset;\n  }\n  return compiler(flags);\n}\n\nfunction getDefaultFlags() {\n  return {\n    jar: COMPILER_JAR_PATH,\n    compilation_level: 'ADVANCED',\n    assume_function_wrapper: true,\n    rewrite_polyfills: false,\n    jscomp_off: ['globalThis', 'checkTypes'],\n    output_wrapper: LICENSE + \"\\n(function(){'use strict';%output%}).call(this);\",\n    externs: 'lib/extras/externs.js'\n  };\n}\n\n// -------------- File Util ----------------\n\nfunction readFile(path) {\n  return fs.readFileSync(path, 'utf-8');\n}\n\nfunction writeFile(outputPath, body) {\n  require('mkdirp').sync(path.dirname(outputPath));\n  fs.writeFileSync(outputPath, body, 'utf-8');\n}\n\nfunction outputJSON(outputPath, obj) {\n  var filename = args.o || args.output || outputPath;\n  writeFile(filename, JSON.stringify(obj));\n  notify('Wrote: ' + filename, false);\n}\n\nfunction cleanDir(dir) {\n  require('rimraf').sync(dir);\n}\n\n// -------------- Stream Util ----------------\n\nfunction getEmptyStream() {\n  return require('merge-stream')();\n}\n\nfunction mergeStreams(streams) {\n  return require('merge-stream')(streams);\n}\n\nfunction addStream(target, src) {\n  if (!src.isEmpty || !src.isEmpty()) {\n    target.add(src);\n  }\n  return target;\n}\n\nfunction onStreamEnd(stream, fn) {\n  if (stream.isEmpty()) {\n    return fn();\n  }\n  return stream.pipe(require('through2').obj(function(file, enc, cb) {\n    fn();\n    cb();\n  }));\n}\n\n// -------------- Logging Util ----------------\n\nfunction notify(text, ellipsis, block) {\n  log(gutil.colors.yellow(text + (ellipsis !== false ? '...' : '')), block);\n}\n\nfunction warn(text, block) {\n  log(gutil.colors.red(text), block);\n}\n\nfunction log(text, block) {\n  if (block) {\n    console.log(text);\n  } else {\n    gutil.log(text);\n  }\n}\n\n// -------------- Core Util ----------------\n\nfunction uniq(arr) {\n  var result = [];\n  arr.forEach(function(el) {\n    if (result.indexOf(el) === -1) {\n      result.push(el);\n    }\n  });\n  return result;\n}\n\nfunction merge(obj1, obj2) {\n  iter(obj2, function(key, val) {\n    obj1[key] = val;\n  });\n}\n\nfunction groupBy(arr, field) {\n  var groups = {};\n  arr.forEach(function(el) {\n    var val = el[field];\n    if (!groups[val]) {\n      groups[val] = [];\n    }\n    groups[val].push(el);\n  });\n  return groups;\n}\n\nfunction compact(arr) {\n  return arr.filter(function(el) {\n    return el;\n  });\n}\n\nfunction iter(obj, fn) {\n  for (var key in obj) {\n    if (!obj.hasOwnProperty(key)) continue;\n      if (fn(key, obj[key]) === false) {\n        break;\n      }\n  }\n}\n\nfunction padNumber(n, place) {\n  var str = String(n);\n  while (str.length < place) {\n    str = '0' + str;\n  }\n  return str;\n}\n\n// Template tag\nfunction block(strings) {\n  var result = strings.concat();\n  for (var i = 1, j = 1; i < arguments.length; i++) {\n    result.splice(j, 0, arguments[i]);\n    j += 2;\n  }\n  return result.join('').replace(/^\\n|\\n$/gm, '');\n}\n\n// -------------- Build ----------------\n\nvar CORE_MIN_VERSION = '^2.0.0';\n\nvar CLOSURE_WRAPPER = block`\n(function() {\n  'use strict';\n$1\n}).call(this);\n`;\n\nvar QML_WRAPPER = block`\n.pragma library\nvar Sugar = (function() {\n  'use strict';\n$1\n  return Sugar;\n}).call(this);\n`;\n\nvar DEFAULT_MODULES = [\n  'es6',\n  'es7',\n  'date',\n  'string',\n  'array',\n  'object',\n  'enumerable',\n  'number',\n  'function',\n  'regexp',\n  'range'\n];\n\nvar ALL_MODULES = [\n  'es5',\n  'es6',\n  'es7',\n  'date',\n  'string',\n  'array',\n  'object',\n  'enumerable',\n  'number',\n  'function',\n  'regexp',\n  'range',\n  'inflections',\n  'language'\n];\n\nvar SPLIT_MODULES = [\n  'es5',\n  'es6',\n  'es7',\n  'range'\n];\n\nvar LICENSE = block`\n/*\n *  Sugar ${getVersion(true)}\n *\n *  Freely distributable and licensed under the MIT-style license.\n *  Copyright (c) Andrew Plummer\n *  https://sugarjs.com/\n *\n * ---------------------------- */\n`;\n\nvar LOCALES_MODULE_COMMENT = block`\n/***\n * @module Locales\n * @description Locale files for the Sugar Date module.\n *\n ***/\n`;\n\nfunction buildDefault() {\n  notify('Exporting: ' + getBuildPath());\n  notify('Minifying: ' + getBuildPath(true));\n  buildLocales();\n  return logBuildResults(mergeStreams([createDevelopmentBuild(), createMinifiedBuild()]));\n}\n\nfunction buildDevelopment() {\n  notify('Exporting: ' + getBuildPath());\n  return logBuildResults(createDevelopmentBuild());\n}\n\nfunction buildMinified() {\n  notify('Minifying: ' + getBuildPath(true));\n  return logBuildResults(createMinifiedBuild());\n}\n\nfunction buildLocales() {\n  copyLocales('all', path.join('dist', 'locales'));\n}\n\nfunction buildQml() {\n  args.qml = true;\n  notify('Creating QML Build: ' + getBuildPath());\n  return logBuildResults(createDevelopmentBuild());\n}\n\nfunction getWrapper(qml) {\n  return qml ? getQmlWrapper() : getStandardWrapper();\n}\n\nfunction getStandardWrapper() {\n  return [LICENSE, CLOSURE_WRAPPER].join('\\n');\n}\n\nfunction getQmlWrapper() {\n  return [LICENSE, QML_WRAPPER].join('\\n');\n}\n\nfunction createDevelopmentBuild(outputPath, modules, locales) {\n\n  var gulpFile = require('gulp-file');\n\n  outputPath = outputPath || getBuildPath();\n  var src = getSource(modules, locales);\n\n\n  return gulpFile(path.basename(outputPath), src, { src: true })\n    .pipe(gulp.dest(path.dirname(outputPath)));\n}\n\nfunction createMinifiedBuild(outputPath, modules, locales) {\n\n  outputPath = outputPath || getBuildPath(true);\n\n  try {\n    fs.lstatSync(COMPILER_JAR_PATH);\n  } catch(e) {\n    gutil.log(gutil.colors.red('Closure compiler missing!'), 'Run', gutil.colors.yellow('npm install'));\n    return;\n  }\n\n  // closure-compiler-stream does not handle direct input,\n  // so need to write a temp file here to pass to compiler args.\n  // Ensure unique path in case multiple streams are compiling\n  // at the same time.\n  var tmpPath = path.join(path.dirname(outputPath), path.basename(outputPath, '.min.js')) +  '.tmp.js';\n  writeFile(tmpPath, stripDocs(getSource(modules, locales)));\n\n  return gulp.src(tmpPath)\n    .pipe(compileSingle(outputPath))\n    .pipe(require('through2').obj(function(file, enc, cb) {\n      fs.unlinkSync(tmpPath);\n      cb();\n    }));\n}\n\nfunction getSource(m, l) {\n\n  // When the source is modularized variables defined in the core\n  // will be lost so they need to be redefined in common, however\n  // these re-defines aren't necessary when the core is bundled\n  // together, so we can strip them out.\n  var CORE_REDEFINES = [\n    'Core utility aliases',\n    'Internal reference to check if an object can be serialized.'\n  ];\n\n  function replaceCoreRedefine(block, comment) {\n    if (CORE_REDEFINES.indexOf(comment) !== -1) {\n      block = '';\n    }\n    return block;\n  }\n\n  var src = '';\n\n  var modulePaths = getModulePaths(m);\n  var localePaths = getLocalePaths(l);\n\n  var namespaceConstraints = getNamespaceConstraints();\n\n  modulePaths.forEach(function(p) {\n    var content = readFile(p);\n    var moduleName = path.basename(p, '.js');\n    var constraints = namespaceConstraints[moduleName];\n    if (moduleName === 'core') {\n      content = content.replace(/\\{VERSION\\}/, getVersion());\n    } else if (constraints) {\n      content = getSplitModule(content, constraints);\n    }\n    src += content;\n  });\n  localePaths.forEach(function(p) {\n    src += readFile(p);\n  });\n\n  src = src.replace(/^'use strict';\\n/gm, '');\n  src = src.replace(/^(?=.)/gm, '  ');\n  src = src.replace(/^([\\s\\S]+)$/m, getWrapper(args.qml));\n  src = src.replace(/^  \\/\\/ ([\\w .]+)[\\s\\S]+?\\n$\\n/gm, replaceCoreRedefine);\n\n  // Allowing namespace constraints such as\n  // ES6:String to only build for that namespace.\n  function getNamespaceConstraints() {\n    var map = {};\n    getModuleNames(m).forEach(function(n) {\n      var split = n.split(':');\n      var moduleName = split[0];\n      var namespaceName = split[1];\n      if (namespaceName) {\n        if (SPLIT_MODULES.indexOf(moduleName) === -1) {\n          warn('Module ' + moduleName + ' is not ready to be split!');\n          warn('Exiting...');\n          process.exit();\n        }\n        var constraints = map[moduleName] || {};\n        constraints[namespaceName] = true;\n        map[moduleName] = constraints;\n      }\n    });\n    return map;\n  }\n\n  // Split the module into namespaces here and match on the allowed one.\n  function getSplitModule(content, constraints) {\n    var src = '', lastIdx = 0, currentNamespace;\n    content.replace(/\\/\\*\\*\\* @namespace (\\w+) \\*\\*\\*\\/\\n|$/g, function(match, nextNamespace, idx) {\n      if (!currentNamespace || constraints[currentNamespace]) {\n        src += content.slice(lastIdx, idx);\n      }\n      currentNamespace = (nextNamespace || '').toLowerCase();\n      lastIdx = idx;\n    });\n    return src;\n  }\n\n  return src;\n}\n\n\n// The closure compiler has issues with non-standard\n// docs so strip all docs out here.\nfunction stripDocs(str) {\n  return str.replace(/\\/\\*\\*\\*[\\s\\S]+?\\*\\*\\*\\//gm, '');\n}\n\nfunction logBuildResults(stream) {\n  stream.on('end', function() {\n    if (args.skipBuildResults) {\n      return;\n    }\n    var moduleNames = getModuleNames();\n    var localeCodes = getLocaleCodes();\n    if (moduleNames.indexOf('date') !== -1) {\n      localeCodes.unshift('en','en-US','en-GB','en-CA','en-AU');\n    }\n    notify('Done! Build info:', false);\n    notify('', false);\n    notify('Modules: ' + moduleNames.join(','), false);\n    if (localeCodes.length) {\n      notify('Locales: ' + localeCodes.join(','), false);\n    }\n    notify('', false);\n  });\n  return stream;\n}\n\nfunction getVersion(v) {\n  var ver = args.v || args.version || 'edge';\n  if (v && ver.match(/^[\\d.]+$/)) {\n    ver = 'v' + ver;\n  }\n  if (buildHasCustomModules() || buildHasCustomLocales()) {\n    var d = new Date();\n    var df = [d.getFullYear(), padNumber(d.getMonth() + 1, 2), padNumber(d.getDate(), 2)].join('.');\n    ver = 'Custom ' + df;\n  }\n  return ver;\n}\n\nfunction getBuildPath(min) {\n  return args.o || args.output || getDefaultBuildPath(min);\n}\n\nfunction getDefaultBuildPath(min) {\n  var names = ['sugar'], dir = '';\n  if (buildHasCustomModules() || buildHasCustomLocales()) {\n    names.push('custom');\n  } else {\n    if (args.es5) {\n      names.push('es5');\n    }\n    dir = 'dist/';\n  }\n  return dir + names.join('-') + (min ? '.min' : '') + '.js';\n}\n\nfunction getModuleNames(m) {\n\n  var moduleNames, sortedModuleNames;\n\n  moduleNames = (m || args.m || args.module || args.modules || 'default').toLowerCase().split(',');\n\n  function alias(name, modules) {\n    var index = moduleNames.indexOf(name);\n    if (index !== -1) {\n      moduleNames.splice.apply(moduleNames, [index, 1].concat(modules));\n    }\n  }\n\n  function nameRank(moduleName) {\n    var rank = moduleIsPolyfill(moduleName) ? 0 : 10;\n    rank += moduleNames.indexOf(moduleName);\n    return rank;\n  }\n\n  alias('all', ALL_MODULES);\n  alias('default', DEFAULT_MODULES);\n\n  if (args.es5) {\n    moduleNames.unshift('es5');\n  }\n\n  if (args.polyfills === false) {\n    moduleNames = moduleNames.filter(function(moduleName) {\n      return !moduleIsPolyfill(moduleName);\n    });\n  }\n\n  // Keeping the names sorted as input except to push\n  // polyfill modules to the top where they need to be.\n  sortedModuleNames = moduleNames.concat();\n\n  sortedModuleNames.sort(function(a, b) {\n    var aRank = nameRank(a);\n    var bRank = nameRank(b);\n    return aRank - bRank;\n  });\n\n  return sortedModuleNames;\n}\n\nfunction getModulePaths(m) {\n\n  var names = getModuleNames(m);\n\n  function getPath(name) {\n    return path.join('lib', name.toLowerCase() + '.js');\n  }\n\n  names = names.map(function(n) {\n\n    var moduleName = n.split(':')[0];\n    try {\n      fs.lstatSync(getPath(moduleName));\n    } catch(e) {\n      warn('Cannot find module ' + moduleName + '!');\n      warn('Exiting...');\n      process.exit();\n    }\n    return moduleName;\n  });\n\n  if (!names.length || names[0] !== 'core') {\n    names.unshift('common');\n  }\n  names.unshift('core');\n\n  return uniq(names).map(getPath);\n}\n\nfunction getLocaleCodes(l) {\n  var names = typeof l === 'string' ? l : args.l || args.locale || args.locales;\n  if (names === 'all') {\n    names = getAllLocales().map(function(p) {\n      return p.match(/([\\w-]+)\\.js/)[1];\n    });\n  } else if (names) {\n    names = names.split(',');\n  }\n  return names || [];\n}\n\nfunction getLocalePaths(l) {\n\n  var codes = getLocaleCodes(l);\n\n  function getPath(l) {\n    return path.join('lib', 'locales', l.toLowerCase() + '.js');\n  }\n\n  codes.forEach(function(n) {\n    try {\n      fs.lstatSync(getPath(n));\n    } catch(e) {\n      warn('Cannot find locale ' + n + '!');\n      warn('Exiting...');\n      process.exit();\n    }\n  });\n\n  return codes.map(getPath);\n}\n\nfunction getAllLocales() {\n  return require('glob').sync('lib/locales/*.js');\n}\n\nfunction buildHasCustomModules() {\n  var moduleNames = getModuleNames().filter(function(n) {\n    // Not counting ES5 module as being custom as it is\n    // also used in the default build.\n    return n !== 'es5';\n  });\n  var hasNonDefault = moduleNames.some(function(n) {\n    return DEFAULT_MODULES.indexOf(n) === -1;\n  });\n  return moduleNames.length !== DEFAULT_MODULES.length || hasNonDefault;\n}\n\nfunction buildHasCustomLocales() {\n  return getLocaleCodes().length !== 0;\n}\n\n// -------------- Package Definitions ----------------\n\nvar PACKAGE_DEFINITIONS = {\n  'sugar': {\n    modules: 'ES5,ES6,ES7,String,Number,Array,Enumerable,Object,Date,Locales,Range,Function,RegExp',\n    keywords: ['date', 'time', 'polyfill']\n  },\n  'sugar-core': {\n    modules: 'Core',\n    description: 'Core module for the Sugar Javascript utility library.'\n  },\n  'sugar-es5': {\n    modules: 'ES5',\n    polyfill: true,\n    description: 'ES5 polyfill module for the Sugar Javascript utility library.',\n    keywords: ['polyfill']\n  },\n  'sugar-es6': {\n    modules: 'ES6',\n    polyfill: true,\n    description: 'ES6 polyfill module for the Sugar Javascript utility library.',\n    keywords: ['polyfill']\n  },\n  'sugar-string': {\n    modules: 'ES6:String,String,Range:String',\n    description: 'String module for the Sugar Javascript utility library.',\n    keywords: ['string']\n  },\n  'sugar-number': {\n    modules: 'ES6:Number,Number,Range:Number',\n    description: 'Number module for the Sugar Javascript utility library.',\n    keywords: ['number']\n  },\n  'sugar-enumerable': {\n    modules: 'ES6:Array,ES6:String,ES7:Array,Enumerable',\n    description: 'Enumerable module for the Sugar Javascript utility library.',\n    keywords: ['array', 'object']\n  },\n  'sugar-array': {\n    modules: 'ES6:Array,ES6:String,ES7:Array,Array',\n    description: 'Array module for the Sugar Javascript utility library.',\n    keywords: ['array']\n  },\n  'sugar-object': {\n    modules: 'Object',\n    extra: 'Object module.',\n    description: 'Object module for the Sugar Javascript utility library.',\n    keywords: ['object']\n  },\n  'sugar-date': {\n    modules: 'Date,Locales,Range:Date',\n    description: 'Date module for the Sugar Javascript utility library.',\n    keywords: ['date','time']\n  },\n  'sugar-range': {\n    modules: 'Range',\n    description: 'Range module for the Sugar Javascript utility library.',\n    keywords: ['range', 'number', 'string', 'date']\n  },\n  'sugar-function': {\n    modules: 'Function',\n    description: 'Function module for the Sugar Javascript utility library.',\n    keywords: ['function']\n  },\n  'sugar-regexp': {\n    modules: 'RegExp',\n    description: 'RegExp module for the Sugar Javascript utility library.',\n    keywords: ['regexp']\n  },\n  'sugar-inflections': {\n    modules: 'Inflections',\n    description: 'Inflections module for the Sugar Javascript utility library.',\n    keywords: ['inflections']\n  },\n  'sugar-language': {\n    modules: 'Language',\n    description: 'Language module for the Sugar Javascript utility library.',\n    keywords: ['language']\n  }\n};\n\n// -------------- Source Package Identities ----------------\n\nvar SOURCE_PACKAGE_LISTED_TYPES = [\n  'static',\n  'instance',\n  'prototype',\n  'accessor',\n  'global',\n  'namespace',\n  'locale',\n  'fix'\n];\n\nvar SOURCE_PACKAGE_DEPENDENCY_TYPES = [\n  'internal',\n  'build',\n  'var'\n];\n\nfunction sourcePackageIsDependency(p) {\n  return SOURCE_PACKAGE_DEPENDENCY_TYPES.indexOf(p.type) !== -1;\n}\n\nfunction sourcePackageIsListed(p) {\n  return SOURCE_PACKAGE_LISTED_TYPES.indexOf(p.type) !== -1;\n}\n\nfunction sourcePackageExportsMethod(p) {\n  return p.type === 'static' || p.type === 'instance' || p.type === 'alias' || p.type === 'accessor';\n}\n\nfunction moduleIsPolyfill(moduleName) {\n  return /^ES[567]/i.test(moduleName);\n}\n\n// -------------- Package Util ----------------\n\nfunction getPackageDefinition(packageName) {\n  var def = PACKAGE_DEFINITIONS[packageName];\n  if (!def) {\n    warn('Cannot find package ' + packageName + '!');\n    warn('Exiting...');\n    process.exit();\n  }\n  return def;\n}\n\nfunction copyPackageMeta(packageName, packageDir) {\n\n  function copyMeta(srcPath) {\n    writeFile(path.join(packageDir, path.basename(srcPath)), readFile(srcPath));\n  }\n\n  if (packageName === 'sugar-core') {\n    copyMeta('lib/extras/core/README.md');\n  } else if (packageName.match(/^sugar-/)) {\n    buildModuleReadme(packageName, packageDir);\n  } else {\n    copyMeta('README.md');\n  }\n\n  if (packageName !== 'sugar-core') {\n    copyMeta('CHANGELOG.md');\n    copyMeta('CAUTION.md');\n  }\n\n  copyMeta('LICENSE');\n  copyMeta('.npmignore');\n}\n\nfunction exportPackageDeclarations(packageName, packageDir) {\n  var allowedModules;\n  switch (packageName) {\n    case 'sugar':\n      allowedModules = 'all';\n      break;\n    case 'sugar-core':\n      allowedModules = 'none';\n      break;\n    default:\n      allowedModules = [packageName.replace(/^sugar-?/, '')];\n  }\n  exportTypescriptDeclarations(packageDir, allowedModules);\n}\n\nfunction copyLocales(l, dir) {\n  require('mkdirp').sync(dir);\n  getLocalePaths(l).forEach(function(src) {\n    writeFile(path.join(dir, path.basename(src)), readFile(src));\n  });\n}\n\nfunction buildPackageDist(packageName, packageDir) {\n\n  var stream     = getEmptyStream();\n  var definition = getPackageDefinition(packageName);\n  var modules    = getPackageModules();\n\n  buildDist(modules);\n  if (!definition.polyfill) {\n    buildDist(modules, true);\n  }\n\n  function getPackageModules() {\n    return definition.modules.split(',').filter(function(m) {\n      if (m === 'Locales') {\n        copyLocales('all', path.join(packageDir, 'locales'));\n        return false;\n      }\n      return true;\n    });\n  }\n\n  function buildDist(modules, es5) {\n    if (es5) {\n      modules = ['ES5'].concat(modules);\n    }\n    modules = modules.join(',');\n    var devFilename = path.join(packageDir, getDistFilename(packageName, es5));\n    var minFilename = path.join(packageDir, getDistFilename(packageName, es5, true));\n    addStream(stream, createDevelopmentBuild(devFilename, modules, ''));\n    addStream(stream, createMinifiedBuild(minFilename, modules, ''));\n    return stream;\n  }\n\n  return stream;\n}\n\nfunction getDistFilename(packageName, es5, min) {\n  return packageName + (es5 ? '-es5' : '') + (min ? '.min' : '') + '.js';\n}\n\nfunction getPackageNames(p) {\n  var packages = [];\n  switch (p) {\n    case 'all':\n      iter(PACKAGE_DEFINITIONS, function(name) {\n        packages.push(name);\n      });\n      break;\n    case 'modular':\n      iter(PACKAGE_DEFINITIONS, function(name) {\n        if (name !== 'sugar-core') {\n          packages.push(name);\n        }\n      });\n      break;\n    default:\n      packages = p.split(',');\n  }\n  return packages;\n}\n\nfunction buildIgnoreFiles(packageName, packageDir) {\n  var paths = ALL_MODULES.map(function(m) {\n    return '/' + m;\n  });\n  paths.push('/common');\n  paths.push('/polyfills');\n  paths.push('/locales');\n  paths.push('/index.js');\n\n  // Ignore the package.json file as well as anything to be checked in to\n  // a modularized repo should be for the sake of bower. Modularized npm\n  // packages are built for now and should not exist in version control.\n  paths.push('/package.json');\n  paths.push('/node_modules');\n  paths.push('/.npmignore');\n\n  writeFile(path.join(packageDir, '.gitignore'), paths.join('\\n'));\n}\n\nfunction buildPackageManagerJson(packageName, packageDir) {\n  exportPackageJson(packageName, packageDir);\n  if (packageName !== 'sugar') {\n    // The npm package should be ignoring bower.json anyway, so this\n    // check should not be necessary, but just a safety guard to make\n    // clear the intent that the modularized \"sugar\" package should\n    // be published only to npm, not bower, as it is the main repo.\n    exportBowerJson(packageName, packageDir);\n  }\n}\n\nfunction cloneJson(file) {\n  var json = JSON.parse(JSON.stringify(require(file))), out = {};\n\n  // This function is simply to get the \"version\", which is dynamically\n  // generated, next to the \"description\" in package.json to make this\n  // file slightly more user friendly.\n  out.name = json.name;\n  out.description = json.description;\n  out.version = json.version;\n\n  for (var key in json) {\n    if (!json.hasOwnProperty(key) || out.hasOwnProperty(key)) continue;\n    out[key] = json[key];\n  };\n  return out;\n}\n\nfunction getCommonJson(file, packageName, def) {\n  var json = cloneJson(file);\n  json.name = packageName;\n  if (def.keywords) {\n    json.keywords = json.keywords.concat(def.keywords);\n  }\n  if (def.description) {\n    json.description = def.description;\n  }\n  delete json.files;\n  delete json.scripts;\n  delete json.devDependencies;\n  return json;\n}\n\nfunction exportPackageJson(packageName, packageDir) {\n  var def = getPackageDefinition(packageName);\n  var json = getCommonJson('./package.json', packageName, def);\n\n  json.version = getVersion();\n\n  // Add sugar-core as a dependency\n  if (packageName === 'sugar-core') {\n    json.main = 'sugar-core.js';\n  } else {\n    json.main = 'index.js';\n    json.dependencies = {\n      'sugar-core': CORE_MIN_VERSION\n    };\n  }\n\n  writeFile(path.join(packageDir, 'package.json'), JSON.stringify(json, null, 2));\n}\n\nfunction exportBowerJson(packageName, packageDir) {\n  var def = getPackageDefinition(packageName);\n  var json = getCommonJson('./bower.json', packageName, def);\n\n  if (packageName === 'sugar-core') {\n    json.main = 'sugar-core.js';\n    json.ignore = [\n      \"**/*\",\n      \"!README.md\",\n      \"!LICENSE\",\n      \"!*.map\",\n      \"!*.js\"\n    ];\n  } else {\n    json.main = path.join('dist', packageName + '.js');\n  }\n\n  writeFile(path.join(packageDir, 'bower.json'), JSON.stringify(json, null, 2));\n}\n\nfunction buildModuleReadme(packageName, packageDir) {\n  var moduleName = packageName.replace(/^sugar-/, '');\n  var moduleCaps = getCapitalizedModuleName(moduleName);\n\n  var src = [\n    '# Sugar',\n    '',\n    '[![Build Status](https://secure.travis-ci.org/andrewplummer/Sugar.png)](http://travis-ci.org/andrewplummer/Sugar)',\n    '',\n    'A Javascript library for working with native objects.',\n    '',\n    '## %MODULE% Module',\n    '',\n    'Note that this build includes only the \"%MODULE_LOWER%\" module. This repo is a modularized build of the main [Sugar](https://github.com/andrewplummer/Sugar) repo. Please post all issues there.',\n    '',\n    '## Install',\n    '',\n    '#### `npm install sugar-%MODULE_LOWER%`',\n    '#### `bower install sugar-%MODULE_LOWER%`',\n    '',\n    '## Getting Started',\n    '',\n    '#### [https://sugarjs.com/quickstart/](https://sugarjs.com/quickstart/)',\n    '',\n    '## Documentation',\n    '',\n    '#### [https://sugarjs.com/docs/](https://sugarjs.com/docs/)'\n  ].join('\\n');\n  src = src.replace(/%MODULE%/g, moduleCaps);\n  src = src.replace(/%MODULE_LOWER%/g, moduleName);\n  writeFile(path.join(packageDir, 'README.md'), src);\n}\n\nfunction getCapitalizedModuleName(moduleName) {\n  if (moduleName.match(/^ES\\d/i)) {\n    return moduleName.toUpperCase();\n  } else if (moduleName === 'regexp') {\n    return 'RegExp';\n  } else {\n    return moduleName.slice(0, 1).toUpperCase() + moduleName.slice(1);\n  }\n}\n\n// ------------ Dependency Tree --------------\n\n/*\n * This function modularizes the source code into packages. These packages are\n * used to create the public npm packages as well as the custom download tool.\n * Source packages consist of top level functions and vars, Sugar methods\n * including polyfills, and \"prototype\" packages for defining methods on other\n * types like Range, which aren't native classes but are modularized as well.\n * In order for modularization to work, the source code follows a few rules:\n *\n * 1. Any function or variable declared in the top scope will become a source\n *    package. Variables declared with the same \"var\" keyword will become a\n *    single package whose name will be taken from the comment node immediately\n *    before it.\n *\n * 2. Sugar methods must be defined using the aliases such as \"defineInstance\",\n *    both on the top level and in build functions (more below).\n *\n * 3. No function may call any Sugar method directly, as this dependency will\n *    not be found. For example a function cannot call Sugar.Array.unique().\n *    If such a dependency is required, instead refactor \"arrayUnique\" into a\n *    top level function and have both functions call that instead. This also\n *    includes modularized prototype methods such as those defined on Range\n *    using \"defineOnPrototype\".\n *\n * 4. No Sugar method may go through the Sugar global in any way, including\n *    using the shortcuts \"sugarNumber\", etc. Refactor any reference to the\n *    Sugar global into a top level function instead.\n *\n * 5. Any function that is also called in the top scope is considered a \"build\"\n *    function. Build functions have one of three purposes. First, they build\n *    up variables that are declared but not assigned in the top scope. Second,\n *    they define methods, either by the Sugar define aliases such as\n *    \"defineInstance\" or using \"defineOnPrototype\" for \"prototype\" methods\n *    (see above). Third, they can be \"set___ChainableConstructor\" which has\n *    a special purpose of mapping the namespace \"create\" method to the chainable\n *    constructor to allow extra functionality. If a build method call is found\n *    it will add itself as a dependency to the build method package. This\n *    ensures that the build method will always be called, however it creates a\n *    circular dependency. See below for more.\n *\n * 6. Build functions that define methods must list out the methods that they\n *    define in the comment block directly before the build function using the\n *    @method or @set keyword. See the source for examples.\n *\n * 7. Any build function ending in \"fix\" allows overriding of behavior based on\n *    feature detects. Unlike normal build methods, which find global variable\n *    assignments and make themselves dependencies of the variable package, \"fix\"\n *    functions will instead take assigned global variables and add them to\n *    \"postAssigns\". The npm tasks can then consume this to override the defined\n *    method after the build function has been called. Note that this will only\n *    work when variables are bundled together in multiple exports, as it needs\n *    to be able to mutate the exported object.\n *\n * 8. Top level variables may never be reassigned, except when they are\n *    declared a single time and assigned later from a build function.\n *\n * 9. Modularized source packages may have circular dependencies! This is not\n *    handled here and should be handled by the final consumer of this function.\n *    For example, npm modules cannot have circular dependencies so they will\n *    bundle them together into a single module where the custom download tool\n *    simply includes all packages in a circular dependency chain.\n *\n */\nfunction getModularSource() {\n\n  var WHITELISTED = ['arguments', 'undefined', 'NaN', 'btoa', 'atob'];\n\n  var sourcePackages = [], modules = [];\n\n  setupFindMethods();\n  parseAllModules();\n  transposeVarDependencies();\n  addLocalePackages();\n  cleanNodes();\n\n  // --- Find Methods ---\n\n  function setupFindMethods() {\n    setupCachedFind('findByVarName', findByVarName);\n    setupCachedFind('findByMethodName', findByMethodName);\n    setupCachedFind('findByDependentPackage', findByDependentPackage);\n    setupCachedFind('findByDependencyName', findByDependencyName);\n  }\n\n  function setupCachedFind(methodName, fn) {\n    var cache = {};\n    sourcePackages[methodName] = function() {\n      var cacheKey = '', args = Array.from(arguments);\n      for (var i = 0; i < args.length; i++) {\n        cacheKey += getTokenForObject(args[i]);\n      }\n      if (cacheKey in cache) {\n        return cache[cacheKey];\n      }\n      return cache[cacheKey] = this.find(function(p) {\n        return fn.apply(null, [p].concat(args));\n      });\n    };\n  }\n\n  function getTokenForObject(obj) {\n    if (typeof obj === 'object' && obj.module && obj.name) {\n      // Assume a source package;\n      obj = obj.module + (obj.namespace || '') + obj.name;\n    }\n    return obj;\n  }\n\n  function findByVarName(p, varName) {\n    return p.vars && p.vars.indexOf(varName) !== -1;\n  }\n\n  function findByDependentPackage(p, dp) {\n    if (dp.type === 'locale') {\n      return p.namespace === 'Date' && p.name === 'addLocale';\n    } else if (dp.alias) {\n      return p.name === dp.alias && p.module === dp.module && p.namespace === dp.namespace;\n    }\n  }\n\n  function findByMethodName(p, methodName, namespaceName, moduleName) {\n    return p.name === methodName && p.namespace === namespaceName && p.module === moduleName;\n  }\n\n  function findByDependencyName(p, dependencyName) {\n    return p.name === dependencyName && sourcePackageIsDependency(p);\n  }\n\n  // --- Parsing ---\n\n  function parseAllModules() {\n    ['common'].concat(ALL_MODULES).forEach(parseModule);\n  }\n\n  function parseModule(moduleLower) {\n\n    var moduleName;\n\n    var commentsByEndLine = {}, namespaceRanges = [], currentNamespaceRange;\n\n    var filePath = 'lib/' + moduleLower + '.js';\n    var source = readFile(filePath);\n\n    parseTopLevelNodes();\n\n\n    // --- Top Level Nodes ---\n\n    function parseTopLevelNodes() {\n      var acorn = require('acorn');\n      var output = acorn.parse(source, {\n        locations: true,\n        sourceFile: filePath,\n        onComment: onComment\n      });\n\n      namespaceBoundary();\n\n      output.body.forEach(function(node) {\n        processTopLevelNode(node);\n      });\n    }\n\n    function processTopLevelNode(node) {\n      switch (true) {\n        case isUseStrict(node):           return;\n        case isMethodBlock(node):         return processMethodBlock(node);\n        case isPolyfillBlock(node):       return processPolyfillBlock(node);\n        case isPrototypeBlock(node):      return processPrototypeBlock(node);\n        case isVariableDeclaration(node): return processVariableDeclaration(node);\n        case isFunctionDeclaration(node): return processFunctionDeclaration(node);\n        case isAliasExpression(node):     return processAliasExpression(node);\n        case isFunctionCall(node):        return processBuildExpression(node);\n        default:\n          console.log(node);\n          throw new Error('Unknown Top Level Node: ' + node.type);\n      }\n    }\n\n    // --- Source Packages ---\n\n    function addSourcePackage(name, node, type, opts) {\n      var comments, sourcePackage;\n      sourcePackage = {\n        node: node,\n        name: name,\n        type: type,\n        body: getNodeBody(node, true),\n        module: moduleName,\n        dependencies: getDependencies(node, name)\n      };\n      merge(sourcePackage, opts);\n      comments = getLastCommentForNode(node, 1);\n      if (comments) {\n        sourcePackage.comments = comments;\n        sourcePackage.bodyWithComments = comments + '\\n' + sourcePackage.body;\n      } else {\n        sourcePackage.bodyWithComments = sourcePackage.body;\n      }\n      sourcePackages.push(sourcePackage);\n      return sourcePackage;\n    }\n\n    function addSugarMethod(name, node, type, deps, opts) {\n      var sp = addSourcePackage(name, node, type, opts);\n\n      sp.namespace    = getNamespaceForNode(node);\n      sp.dependencies = sp.dependencies.concat(deps || []);\n\n      if (sp.comments && !sp.alias) {\n        // Method comments are indented by 3, so just a hack to\n        // make sure the resulting source is the same.\n        sp.comments = '  ' + sp.comments;\n        sp.bodyWithComments = '  ' + sp.bodyWithComments;\n      }\n    }\n\n    function addSugarBuiltMethod(name, buildFn, type, opts) {\n      var sp = addSourcePackage(name, buildFn.node, type, opts);\n\n      sp.namespace = opts.namespace || getNamespaceForNode(buildFn.node);\n\n      sp.dependencies = [buildFn.name];\n\n      // Built methods are essentially null. They don't have any body\n      // or add to the source code. They simply require that the build\n      // function be present and called.\n      sp.body = '';\n      sp.comments = '';\n      sp.bodyWithComments = '';\n    }\n\n    function addSugarFix(name, buildFn) {\n      var sp = addSourcePackage(name, buildFn.node, 'fix');\n\n      var comment = getLastCommentForNode(buildFn.node, 1);\n      sp.description = comment.match(/@short (.+)$/m)[1];\n\n      sp.dependencies = [buildFn.name];\n\n      // Like built methods, fixes are wrappers around build functions,\n      // so they don't have any body themselves, just requiring that the\n      // build function is called.\n      sp.body = '';\n      sp.comments = '';\n      sp.bodyWithComments = '';\n    }\n\n    function addVarPackage(node) {\n      var name = getVarPackageName(node), sp;\n      sp = addSourcePackage(name, node, 'var');\n      sp.assigns = {};\n      sp.vars = node.declarations.map(function(node) {\n        var name = node.id.name;\n        if (node.init) {\n          sp.assigns[name] = getNodeBody(node.init);\n        }\n        return name;\n      });\n      checkPackageForBuiltMethods(sp);\n    }\n\n    function getVarPackageName(node) {\n      var first = node.declarations[0].id.name, comment;\n      if (node.declarations.length === 1) {\n        return first;\n      }\n      comment = getLastCommentForNode(node, 1).replace(/^[\\s\\/]+/, '');\n      if (/^[A-Z]/.test(first)) {\n        // ConstantPackage\n        comment = comment.charAt(0).toUpperCase() + comment.slice(1);\n      } else {\n        // varPackage\n        comment = comment.charAt(0).toLowerCase() + comment.slice(1);\n      }\n      return comment.replace(/\\s(\\w)/g, function(m, letter) {\n        return letter.toUpperCase();\n      }).replace(/\\W/g, '');\n    }\n\n    // --- Namespaces ---\n\n    function namespaceBoundary(namespace, line) {\n      // Demarcate a namespace \"boundary\" to build up an array of namespace line\n      // \"ranges\" to be able to find which namespace a piece of code belongs to.\n      if (currentNamespaceRange) {\n        namespaceRanges.push(currentNamespaceRange);\n      }\n      if (namespace) {\n        currentNamespaceRange = {\n          name: namespace,\n          line: line\n        };\n      }\n    }\n\n    function getNamespaceForNode(node) {\n      var line = node.loc.start.line, namespace;\n      namespaceRanges.forEach(function(r) {\n        if (r.line < line) {\n          namespace = r.name;\n        }\n      });\n      return namespace;\n    }\n\n    // --- Comments ---\n\n    function onComment(block, text, start, stop, startLoc, endLoc) {\n      var match;\n      commentsByEndLine[endLoc.line] = {\n        text: text,\n        block: block\n      };\n      match = text.match(/@module (\\w+)/);\n      if (match) {\n        moduleName = match[1];\n        modules.push({\n          name: moduleName,\n          comment: '/*' + text + '*/\\n'\n        });\n      }\n      // Both @module and @namespace may be defined in the same comment block.\n      match = text.match(/@(namespace|module) \\w+/g);\n      if (match) {\n        if (text.match(/@method/)) {\n          // Don't allow temporary namespace renamings\n          // in method block.\n          return;\n        }\n        var namespace = match[match.length - 1].match(/@(namespace|module) (\\w+)/)[2];\n        namespaceBoundary(namespace, endLoc.line);\n      }\n    }\n\n    function getLastCommentForNode(node, limit) {\n      var line = node.loc.start.line, count = 0, comment;\n      while (!comment && line > 0) {\n        comment = commentsByEndLine[--line];\n        count++;\n        if (limit && count == limit) {\n          break;\n        }\n      }\n      if (comment) {\n        if (!comment.block) {\n          var lines = [comment.text];\n          while (comment = commentsByEndLine[--line]) {\n            if (!comment.block) {\n              lines.unshift(comment.text);\n            }\n          }\n          return lines.map(function(l) {\n            return '\\/\\/' + l;\n          }).join('\\n');\n        } else {\n          if (!comment.text.match(/@(module|namespace)/) || comment.text.match(/@method/)) {\n            return '\\/*' + comment.text + '*\\/';\n          }\n        }\n      }\n      return '';\n    }\n\n    function checkPackageForBuiltMethods(package, type, opts) {\n      var methodBlocks = getMethodBlocksInPreviousComment(package.node);\n\n      if (!methodBlocks.length) {\n        return;\n      }\n\n      opts = opts || {};\n      type = type || 'instance';\n\n      methodBlocks.forEach(function(block) {\n\n        if (block.namespace) {\n          opts.namespace = block.namespace;\n        }\n\n        if (block.static) {\n          type = 'static';\n        } else if (block.accessor) {\n          type = 'accessor';\n        }\n\n        if (block.set) {\n          opts.set     = block.set;\n          opts.setName = block.name;\n          block.set.forEach(function(methodName) {\n            addSugarBuiltMethod(methodName, package, type, opts);\n          });\n        } else {\n          delete opts.set;\n          delete opts.setName;\n          addSugarBuiltMethod(block.name, package, type, opts);\n        }\n      });\n    }\n\n    function getMethodBlocksInPreviousComment(node) {\n      var methodBlocks = [];\n      var comment = getLastCommentForNode(node, 1);\n      var blocks = comment.split('***');\n      blocks.forEach(function(block) {\n        var methodMatch = block.match(/@method ([\\[\\]\\w]+)/);\n        if (methodMatch) {\n          var methodBlock = {\n            name: methodMatch[1],\n            static: /@static/.test(block),\n            accessor: /@accessor/.test(block)\n          };\n          var setMatch = block.match(/@set([^@\\/]+)/);\n          if (setMatch) {\n            methodBlock.set = setMatch[1].replace(/^[\\s*]*|[\\s*]*$/g, '').replace(/[\\s*]+/g, ',').split(',');\n          }\n          var namespaceMatch = block.match(/@namespace (\\w+)/);\n          if (namespaceMatch) {\n            methodBlock.namespace = namespaceMatch[1];\n          }\n          methodBlocks.push(methodBlock);\n        }\n      });\n      return methodBlocks;\n    }\n\n    // --- Nodes ---\n\n    function getNodeBody(node, line) {\n      // Subtract the column to offset the first line's whitespace as well.\n      return node ? source.slice(node.start - (line ? node.loc.start.column : 0), node.end) : '';\n    }\n\n    function isUseStrict(node) {\n      return node.type === 'ExpressionStatement' && node.expression.value === 'use strict';\n    }\n\n    function isVariableDeclaration(node) {\n      return node.type === 'VariableDeclaration';\n    }\n\n    function isFunctionDeclaration(node) {\n      return node.type === 'FunctionDeclaration';\n    }\n\n    function isMethodBlock(node) {\n      return node.type === 'ExpressionStatement' &&\n             node.expression.type === 'CallExpression' &&\n             node.expression.callee.name &&\n             !!node.expression.callee.name.match(/^define(Static|Instance(AndStatic)?)(Similar|WithArguments)?$/);\n    }\n\n    function isPolyfillBlock(node) {\n      return node.type === 'ExpressionStatement' &&\n             node.expression.type === 'CallExpression' &&\n             node.expression.callee.name &&\n             !!node.expression.callee.name.match(/^define(Static|Instance)Polyfill$/);\n    }\n\n    function isPrototypeBlock(node) {\n      return node.type === 'ExpressionStatement' &&\n             node.expression.type === 'CallExpression' &&\n             node.expression.callee.name &&\n             !!node.expression.callee.name.match(/defineOnPrototype/);\n    }\n\n    function isAliasExpression(node) {\n      return node.type === 'ExpressionStatement' &&\n             node.expression.type === 'CallExpression' &&\n             node.expression.callee.name === 'alias';\n    }\n\n    function isFunctionCall(node) {\n      return node.type === 'ExpressionStatement' &&\n             node.expression.type === 'CallExpression';\n    }\n\n    function isVarAssignment(node) {\n      return node.type === 'ExpressionStatement' &&\n             node.expression.type === 'AssignmentExpression' &&\n             node.expression.left.type === 'Identifier';\n    }\n\n    // --- Processing Nodes ---\n\n    function hasStaticToken(str) {\n      return /static/i.test(str);\n    }\n\n    function hasPolyfillToken(str) {\n      return /polyfill/i.test(str);\n    }\n\n    function processFunctionDeclaration(node) {\n      addSourcePackage(node.id.name, node, 'internal');\n    }\n\n    function processVariableDeclaration(node) {\n      addVarPackage(node);\n    }\n\n    function processMethodBlock(node) {\n      processDefineBlock(node);\n    }\n\n    function processPolyfillBlock(node) {\n      processDefineBlock(node);\n    }\n\n    // Define block example: defineInstance(sugarDate, { ... }, [FLAG]);\n    function processDefineBlock(node) {\n      var defineMethod, sugarNamespace, methods, type, deps = [], opts = {};\n\n      function getBlockEnd() {\n        var arg3 = node.expression.arguments[2], end = '}';\n        if (arg3) {\n          deps = deps.concat(getDependencies(arg3));\n          end += ', ' + getNodeBody(arg3);\n        }\n        end += ');';\n        return end;\n      }\n\n      defineMethod   = node.expression.callee.name;\n      sugarNamespace = node.expression.arguments[0].name;\n      methods        = node.expression.arguments[1].properties;\n\n      type = hasStaticToken(defineMethod) ? 'static' : 'instance';\n      opts.polyfill = hasPolyfillToken(defineMethod);\n\n      deps.push(defineMethod);\n      deps.push(sugarNamespace);\n\n      opts.defineMethod = defineMethod;\n      opts.blockStart   = defineMethod + '(' + sugarNamespace + ', {';\n      opts.blockEnd     = getBlockEnd();\n\n      methods.forEach(function(node) {\n        addSugarMethod(node.key.value, node, type, deps, opts);\n      });\n    }\n\n    function processPrototypeBlock(node) {\n      var target, methods, defineMethod, deps = [], opts = {};\n\n      defineMethod = node.expression.callee.name;\n      target       = node.expression.arguments[0].name;\n      methods      = node.expression.arguments[1].properties;\n\n      deps = [defineMethod, target];\n\n      opts.target     = target;\n      opts.blockStart = defineMethod + '(' + target + ', {';\n      opts.blockEnd   = '});';\n\n      methods.forEach(function(node) {\n        addSugarMethod(node.key.value, node, 'prototype', deps, opts);\n      });\n    }\n\n    function processAliasExpression(node) {\n      var methodName, aliasedMethod, namespace, type, opts = {};\n\n      methodName     = node.expression.arguments[1].value;\n      aliasedMethod  = node.expression.arguments[2].value;\n\n      opts.alias = aliasedMethod;\n      opts.methodDependencies = [aliasedMethod];\n\n      namespace = getNamespaceForNode(node);\n      type = sourcePackages.findByMethodName(aliasedMethod, namespace, moduleName).type;\n\n      addSugarMethod(methodName, node, type, [], opts);\n    }\n\n    function processBuildExpression(node) {\n\n      var fnName     = node.expression.callee.name;\n      var fnCallName = fnName + 'Call';\n      var fnPackage  = sourcePackages.findByDependencyName(fnName);\n\n      addSourcePackage(fnCallName, node, 'build');\n\n      bundleVarAssignments();\n      addBuiltMethods();\n      addChainableConstructors();\n      addFixes();\n      transposeDependencies();\n\n      function findVarAssignments(nodes, allowIf, assignments) {\n        assignments = assignments || [];\n        nodes.forEach(function(node) {\n          if (isVarAssignment(node)) {\n            var varName = node.expression.left.name, varPackage;\n            if (fnPackage.dependencies.indexOf(varName) === -1) {\n\n              // Other non-related var assignments may exist,\n              // but if our package doesn't depend on them then ignore.\n              return;\n            }\n            varPackage = sourcePackages.findByVarName(varName);\n            if (varPackage.dependencies.indexOf(fnCallName) === -1) {\n              assignments.push({\n                name: varName,\n                package: varPackage\n              });\n            }\n          } else if (allowIf && node.type === 'IfStatement') {\n            findVarAssignments(node.consequent.body, false, assignments);\n          }\n        });\n        return assignments;\n      }\n\n      function bundleVarAssignments() {\n        findVarAssignments(fnPackage.node.body.body).forEach(function(assignment) {\n          // Add the call method as a dependency of the variable.\n          // Note that this will create circular dependencies:\n          // someVar -> buildFunctionCall -> buildFunction -> someVar\n          // This is acceptable because other circular dependencies\n          // exist and this is not an issue when modularizing for the\n          // sake of re-creating the source, however these need to be\n          // addressed when modularizing for the sake of a package\n          // manager like npm.\n          assignment.package.dependencies.push(fnCallName);\n        });\n      }\n\n      // A build function may define methods which involve complex or\n      // optimized ways of defining sets of methods (date units, etc),\n      // so instead of attempting to analyze the build function, we are\n      // saying that any set methods must be defined in the comment block\n      // directly above the build method.\n      function addBuiltMethods() {\n        var opts = {}, type;\n\n        fnPackage.node.body.body.forEach(function(node) {\n          if (isPrototypeBlock(node)) {\n            type = 'prototype';\n            opts.target = node.expression.arguments[0].name;\n          }\n          if (isMethodBlock(node) && hasStaticToken(node.expression.callee.name)) {\n            type = 'static';\n          }\n        });\n\n        // If no special types were defined, then the\n        // build function is simply defining instance types.\n        if (!type) {\n          type = 'instance';\n        }\n\n        checkPackageForBuiltMethods(fnPackage, type, opts);\n      }\n\n      // set___ChainableConstructor is a special type of build method that\n      // hands the chainable constructor off to a Sugar \"create\" method so\n      // that chainables can have enhanced functionality beyond wrapping a\n      // primitive, for example \"new Sugar.Date('today')\". When modularizing,\n      // the \"create\" method simply needs to know that it depends on this build\n      // so that the link can be created.\n      function addChainableConstructors() {\n        var match = fnPackage.name.match(/^set(\\w+)ChainableConstructor$/);\n        if (match) {\n          var namespace = match[1];\n          var createPackage = sourcePackages.find(function(p) {\n            return p.name === 'create' && p.namespace === namespace;\n          });\n          createPackage.dependencies.push(fnPackage.name);\n        }\n      }\n\n      // Fixes are special types of build methods that fix broken behavior but\n      // are not polyfills or attached to a specific method, so need to be\n      // handled differently.\n      function addFixes() {\n        var match = fnPackage.name.match(/^build(\\w+)Fix$/);\n        if (match) {\n          addSugarFix(match[1], fnPackage);\n          fnPackage.dependencies.push(fnCallName);\n          fnPackage.postAssigns = findVarAssignments(fnPackage.node.body.body, true);\n        }\n      }\n\n      // Step through all source packages and transpose dependencies on the\n      // build function to be dependent on the function call instead, ensuring\n      // that the function is finally called. Although we could simply push the\n      // call body into the build package, this way allows the source to be\n      // faithfully rebuilt no matter where the build call occurs.\n      function transposeDependencies() {\n        sourcePackages.forEach(function(p) {\n          if (p.name === fnCallName) {\n            // Do not transpose the call package itself. After this loop\n            // there should be only one dependency on the build function anymore.\n            return;\n          }\n          var index = p.dependencies.indexOf(fnName);\n          if (index !== -1) {\n            p.dependencies.splice(index, 1, fnCallName);\n          }\n        });\n      }\n\n    }\n\n    // --- Dependencies ---\n\n    function getDependencies(node, name, locals) {\n      var deps = [];\n\n      if (!locals) {\n        locals = [];\n      }\n\n      function log() {\n        if (name === 'xxx') {\n          console.log.apply(null, [name + ':'].concat(Array.prototype.slice.call(arguments, 0)));\n        }\n      }\n\n      function pushLocal(loc) {\n        if (locals.indexOf(loc) === -1) {\n          log('PUSHING LOCAL', loc);\n          locals.push(loc);\n        }\n      }\n\n      function pushDependency(dep) {\n        if (deps.indexOf(dep) === -1) {\n          log('PUSHING DEPENDENCY', dep);\n          deps.push(dep);\n        }\n      }\n\n      function pushDependencies(arr) {\n        arr.forEach(pushDependency);\n      }\n\n      function getLocals(nodes) {\n        return nodes.map(function(id) {\n          return id.name;\n        });\n      }\n\n      function walk(nodes) {\n        if (!nodes) {\n          return;\n        }\n        if (nodes.type) nodes = [nodes];\n        nodes.forEach(processNode);\n      }\n\n      function processNode(node) {\n        log('PROCESSING:', node.type);\n        switch(node.type) {\n          case 'Identifier':\n            pushDependency(node.name);\n            return;\n          case 'VariableDeclarator':\n            pushLocal(node.id.name);\n            walk(node.init);\n            return;\n          case 'FunctionDeclaration':\n            pushLocal(node.id.name);\n            // Recursively get this function's local dependencies.\n            // so that flat locals don't clobber them.\n            pushDependencies(getDependencies(node.body, name, getLocals(node.params)));\n            return;\n          case 'FunctionExpression':\n            // Recursively get this function's local dependencies.\n            // so that flat locals don't clobber them.\n            pushDependencies(getDependencies(node.body, name, getLocals(node.params)));\n            return;\n          case 'CatchClause':\n            pushLocal(node.param);\n            walk(node.body);\n            return;\n          case 'MemberExpression':\n            walk(node.object);\n            // If the MemberExpression is computed syntax (a[b]) then\n            // the property value may be a depencency, so step in.\n            if (node.computed) walk(node.property);\n            return;\n          case 'ExpressionStatement':\n            walk(node.expression);\n            return;\n          case 'SequenceExpression':\n            walk(node.expressions);\n            return;\n          case 'SwitchStatement':\n            walk(node.discriminant);\n            walk(node.cases);\n            return;\n          case 'ObjectExpression':\n            walk(node.properties);\n            return;\n          case 'ArrayExpression':\n            walk(node.elements);\n            return;\n          case 'TryStatement':\n            walk(node.block);\n            walk(node.handler);\n            walk(node.finalizer);\n            return;\n          case 'BlockStatement':\n            walk(node.body);\n            return;\n          case 'ForStatement':\n            walk(node.init);\n            walk(node.test);\n            walk(node.update);\n            walk(node.body);\n            return;\n          case 'ForInStatement':\n            walk(node.left);\n            walk(node.right);\n            walk(node.body);\n            return;\n          case 'WhileStatement':\n            walk(node.test);\n            walk(node.body);\n            return;\n          case 'DoWhileStatement':\n            walk(node.body);\n            walk(node.test);\n            return;\n          case 'VariableDeclaration':\n            walk(node.declarations);\n            return;\n          case 'Property':\n            walk(node.value);\n            return;\n          case 'NewExpression':\n          case 'CallExpression':\n            walk(node.callee);\n            walk(node.arguments);\n            return;\n          case 'SwitchCase':\n          case 'IfStatement':\n          case 'ConditionalExpression':\n            walk(node.test);\n            walk(node.consequent);\n            walk(node.alternate);\n            return;\n          case 'BinaryExpression':\n          case 'LogicalExpression':\n          case 'AssignmentExpression':\n            walk(node.left);\n            walk(node.right);\n            return;\n          case 'ThrowStatement':\n          case 'ReturnStatement':\n          case 'UnaryExpression':\n          case 'UpdateExpression':\n            walk(node.argument);\n            return;\n          case 'Literal':\n          case 'EmptyStatement':\n          case 'ThisExpression':\n          case 'BreakStatement':\n          case 'ContinueStatement':\n            // Pass on literals, {}, this, break, continue\n            return;\n          default:\n            console.log(node);\n            throw new Error('Unknown Node: ' + node.type);\n        }\n      }\n\n      function isValidDependency(d) {\n        // Remove any local variables, whitelisted tokens like \"arguments\" or \"NaN\",\n        // and anything in the global scope. Cheating a bit here by using the node\n        // global scope instead of a ton of whitelisted tokens.\n        return locals.indexOf(d) === -1 && !global[d] && WHITELISTED.indexOf(d) === -1;\n      }\n\n      walk(node);\n      return deps.filter(isValidDependency);\n    }\n\n  }\n\n  // Find packages depending on specific vars and transpose the dependency to\n  // the bundled var package instead. However keep the references as\n  // \"varDependencies\" for later consumption.\n  function transposeVarDependencies() {\n    var map = {};\n    sourcePackages.forEach(function(p) {\n      if (p.vars) {\n        p.vars.forEach(function(v) {\n          map[v] = p.name;\n        });\n      }\n    });\n    sourcePackages.forEach(function(p) {\n      var deps = [];\n      var varDeps = [];\n      p.dependencies.forEach(function(d) {\n        var normalized = map[d] || d;\n        if (deps.indexOf(normalized) === -1) {\n          deps.push(normalized);\n        }\n        if (d in map) {\n          varDeps.push(d);\n        }\n      });\n      p.dependencies = deps;\n      if (varDeps.length) {\n        p.varDependencies = varDeps;\n      }\n    });\n  }\n\n  function cleanNodes() {\n    sourcePackages.forEach(function(p) {\n      delete p.node;\n    });\n  }\n\n  // --- Locales ---\n\n  function addLocalePackages() {\n    var di = modules.findIndex(function(m) {\n      return m.name === 'Date';\n    });\n    modules.splice(di + 1, 0, {\n      name: 'Locales',\n      comment: LOCALES_MODULE_COMMENT\n    });\n    getAllLocales().forEach(function(filePath) {\n      var code = path.basename(filePath, '.js');\n      var body = readFile(filePath);\n      var name = body.match(/\\s+([^*]+) locale definition/)[1];\n      sourcePackages.push({\n        name: name,\n        code: code,\n        body: body,\n        type: 'locale',\n        module: 'Locales',\n        bodyWithComments: body,\n        methodDependencies: ['addLocale']\n      });\n    });\n  }\n\n  return {\n    modules: modules,\n    packages: sourcePackages\n  };\n\n}\n\n// -------------- Packages ----------------\n\n\nfunction buildPackagesDefault() {\n  return buildPackages(args.p || args.package || args.packages || 'all');\n}\n\nfunction buildPackagesCore() {\n  return buildPackages('sugar-core');\n}\n\nfunction buildPackagesSugar() {\n  return buildPackages('sugar');\n}\n\nfunction buildPackagesClean() {\n  cleanDir(args.o || args.output || 'packages');\n}\n\nfunction buildPackages(p, rebuild) {\n\n  var sourcePackages;\n  var baseDir = args.o || args.output || 'packages';\n  var stream = getEmptyStream();\n\n  buildAllPackages(p);\n\n  function buildAllPackages() {\n    getPackageNames(p).forEach(buildPackage);\n  }\n\n  function buildPackage(packageName) {\n    var packageDir = path.join(baseDir, packageName), isModular;\n\n    isModular = packageName !== 'sugar-core';\n\n    cleanDir(path.join(packageDir, '*'));\n\n    if (isModular && !sourcePackages) {\n      notify('Getting source packages');\n      sourcePackages = getModularSource().packages;\n      mergeMethodDependencies();\n      bundleCircularDependencies();\n    }\n\n    notify('Building ' + packageName);\n\n    if (isModular) {\n      buildModularPackage(packageName, packageDir);\n    }\n\n    if (!rebuild) {\n      var distDir = isModular ? path.join(packageDir, 'dist') : packageDir;\n      addStream(stream, buildPackageDist(packageName, distDir));\n      buildPackageManagerJson(packageName, packageDir);\n      buildIgnoreFiles(packageName, packageDir);\n      copyPackageMeta(packageName, packageDir);\n      exportPackageDeclarations(packageName, packageDir);\n    }\n\n  }\n\n  function buildModularPackage(packageName, packageDir) {\n\n    var TAB = '  ';\n    var DTAB = TAB + TAB;\n    var STRICT = \"'use strict';\";\n    var DIRECT_REQUIRES_REG = /(Call|Fix)$/;\n\n    exportAllModules();\n\n    // --- Exporting ---\n\n\n    function getModuleDefinitions(modules) {\n      return modules.split(',').map(function(md) {\n        var split = md.split(':'), name, path, type;\n        name = split[0];\n        path = './' + name.toLowerCase();\n        if (name === 'Locales') {\n          type = 'locales';\n        } else if (moduleIsPolyfill(name)) {\n          type = 'polyfill';\n        } else {\n          type = 'module';\n        }\n        return {\n          name: name,\n          path: path,\n          type: type,\n          namespace: split[1]\n        };\n      });\n    }\n\n    function createPackageEntryPoints(moduleDefinitions, packageDefinition) {\n      createPackageMainEntryPoint(moduleDefinitions, packageDefinition);\n      if (!packageDefinition.polyfill) {\n        createPackagePolyfillEntryPoint(moduleDefinitions, /^ES[567]/, 'polyfills');\n        createPackagePolyfillEntryPoint(moduleDefinitions, /^ES5/, 'polyfills', 'es5');\n        createPackagePolyfillEntryPoint(moduleDefinitions, /^ES6/, 'polyfills', 'es6');\n        createPackagePolyfillEntryPoint(moduleDefinitions, /^ES7/, 'polyfills', 'es7');\n      }\n    }\n\n    function createPackageMainEntryPoint(moduleDefinitions, packageDefinition) {\n      // Filtering out polyfills in main entry point\n      // except for packages that only define polyfills.\n      var paths = moduleDefinitions.filter(function(md) {\n        return md.type === 'module' || (md.type === 'polyfill' && packageDefinition.polyfill);\n      }).map(function(md) {\n        return md.path;\n      });\n      createEntryPoint(paths);\n    }\n\n    function createPackagePolyfillEntryPoint(moduleDefinitions, match, subPath, entryPointName) {\n      var paths = moduleDefinitions.filter(function(md) {\n        return md.type === 'polyfill' && match.test(md.name);\n      }).map(function(md) {\n        return path.join('..', md.path);\n      });\n      if (paths.length) {\n        createEntryPoint(paths, subPath, entryPointName);\n      }\n    }\n\n    function exportAllModules() {\n      var packageDefinition = getPackageDefinition(packageName);\n      var moduleDefinitions = getModuleDefinitions(packageDefinition.modules);\n      moduleDefinitions.forEach(function(m) {\n        exportModule(m.name, m.namespace);\n      });\n      createPackageEntryPoints(moduleDefinitions, packageDefinition);\n    }\n\n    function exportModule(moduleName, restrictedNamespace) {\n      var dependencies = [], methodPaths = [], moduleLower = moduleName.toLowerCase();\n\n      exportPublicPackages();\n      exportDependencies();\n      createEntryPoint(groupBy(methodPaths, 'type'), moduleLower);\n\n      function packageIsNamespaceRestricted(p) {\n        if (p.namespace === 'Range') {\n          // Don't restrict range methods\n          return false;\n        }\n        return restrictedNamespace && p.namespace && p.namespace !== restrictedNamespace;\n      }\n\n      function canExportPublicPackage(p) {\n        return p.module === moduleName &&\n               sourcePackageIsListed(p) &&\n               !packageIsNamespaceRestricted(p);\n      }\n\n      function exportPublicPackages() {\n        sourcePackages.forEach(function(p) {\n          if (canExportPublicPackage(p)) {\n            exportPackage(p);\n            addDependencies(p);\n            methodPaths.push({\n              type: getEntryPointTypeForPackage(p),\n              path: getRelativePath(p.path, moduleLower, true)\n            });\n          }\n        });\n      }\n\n      function exportDependencies() {\n        uniq(dependencies).forEach(function(dep) {\n          if (dep.name !== 'core') {\n            exportPackage(dep);\n          }\n        });\n      }\n\n      function addDependencies(p) {\n        p.dependencies.forEach(function(d) {\n          var dep = findDependency(d, p);\n          if (dep) {\n            dependencies.push(dep);\n            addDependencies(dep);\n          }\n        });\n      }\n\n    }\n\n    function exportPackage(p) {\n      if (!p.compiledBody) {\n        compilePackage(p);\n      }\n      var outputPath = path.join(packageDir, p.path + '.js');\n      var outputBody = p.compiledBody;\n      writeFile(outputPath, outputBody);\n    }\n\n    // --- Compiling ---\n\n    function compilePackage(p) {\n      compileForType(p);\n      p.path = getPackagePath(p);\n      p.compiledBody = compact([\n        STRICT,\n        getRequires(p),\n        getDirectRequires(p),\n        getAssigns(p),\n        p.body,\n        getPostAssigns(p),\n        getExports(p)\n      ]).join('\\n\\n');\n    }\n\n    function compileForType(p) {\n      if (p.alias) {\n        compileAliasedMethod(p);\n        return;\n      }\n      switch(p.type) {\n        case 'static':\n        case 'instance':\n          compileDefinedMethod(p);\n          break;\n        case 'accessor':\n          compileAccessorMethod(p);\n          break;\n        case 'prototype':\n          compilePrototypeMethod(p);\n          break;\n        case 'var':\n          compileVarPackage(p);\n          break;\n        case 'locale':\n          compileLocalePackage(p);\n          break;\n      }\n    }\n\n    function compileAccessorMethod(p) {\n      p.dependencies.push('Sugar');\n    }\n\n    function compileDefinedMethod(p) {\n      p.dependencies.push('Sugar');\n      // Built methods may not have a defineBlock\n      if (p.defineMethod) {\n        // Wrap the naked method definition body with a direct call to the global\n        // define method, and remove dependencies on the definition/namespace aliases.\n        var blockStart = ['Sugar', p.namespace, p.defineMethod].join('.') + '({';\n        removeVarDependency(p, p.defineMethod);\n        removeVarDependency(p, 'sugar' + p.namespace);\n        p.body = compact([blockStart, p.body, p.blockEnd]).join('\\n\\n');\n      }\n    }\n\n    function compileAliasedMethod(p) {\n      p.dependencies.push('Sugar');\n      removeVarDependency(p, 'alias');\n      removeVarDependency(p, 'sugar' + p.namespace);\n      p.body = ['Sugar', p.namespace, 'alias'].join('.') + \"('\" + p.name + \"', '\" + p.alias + \"');\";\n    }\n\n    function compilePrototypeMethod(p) {\n      p.body = compact([p.blockStart, p.body, p.blockEnd]).join('\\n\\n');\n    }\n\n    function compileVarPackage(p) {\n      var varName, varAssigns;\n      for (var i = 0; i < p.vars.length; i++) {\n        varName = p.vars[0];\n        varAssigns = p.assigns[varName];\n        // If any of the variables is declared but not immediately assigned,\n        // or if any of the assigns are spread over multiple lines, then the\n        // package is probably complex, so bail and don't allow direct exports.\n        if (!varAssigns || /\\n/.test(varAssigns)) {\n          return;\n        }\n        p.exportsDirectly = true;\n        p.body = '';\n      }\n    }\n\n    function compileLocalePackage(p) {\n      p.body = p.body.replace(/Sugar\\.Date\\.(?=addLocale)/, '');\n    }\n\n    function removeVarDependency(p, name) {\n      var varPackage = sourcePackages.findByVarName(name);\n      p.dependencies = p.dependencies.filter(function(d) {\n        return d !== varPackage.name;\n      });\n    }\n\n    // --- Compile Helpers ---\n\n    function getPackagePath(p) {\n      if (p.path) {\n        return p.path;\n      } else if (p.polyfill) {\n        return path.join('polyfills', p.namespace.toLowerCase(), p.name);\n      } else if (p.type === 'fix') {\n        return path.join(p.module.toLowerCase(), 'fixes', p.name);\n      } else if (p.type === 'locale') {\n        return path.join(p.module.toLowerCase(), p.code);\n      } else if (sourcePackageIsDependency(p)) {\n        return path.join(p.module.toLowerCase(), p.type, p.name);\n      } else {\n        return path.join(p.namespace.toLowerCase(), p.name);\n      }\n    }\n\n    function getPackageRelativePath(toPackage, fromPackage) {\n      return getRelativePath(getPackagePath(toPackage), getPackagePath(fromPackage));\n    }\n\n    function getRelativePath(toPath, fromPath, index) {\n      if (index) {\n        fromPath += '/index';\n      }\n      var relDir  = path.relative(path.dirname(fromPath), path.dirname(toPath));\n      var relPath = path.join(relDir, path.basename(toPath));\n      if (relPath.charAt(0) !== '.') {\n        relPath = './' + relPath;\n      }\n      return relPath;\n    }\n\n    function getDependencyPath(d, p) {\n      if (d === 'Sugar') {\n        return 'sugar-core';\n      }\n      return getPackageRelativePath(findDependency(d, p), p);\n    }\n\n    function getRequires(p) {\n      if (!p.dependencies.length) {\n        return '';\n      }\n\n      var ALL_CAPS   = /^[A-Z_]+$/;\n      var FIRST_CAPS = /^[A-Z]/;\n\n      function getRequiresSorted() {\n        var deps = p.dependencies.concat().filter(function(d) {\n          return !DIRECT_REQUIRES_REG.test(d);\n        });\n        if (!deps.length) {\n          return '';\n        }\n        deps.sort(function(a, b) {\n          var aRank = getRequireRanking(a);\n          var bRank = getRequireRanking(b);\n          return aRank === bRank ? a.length - b.length : aRank - bRank;\n        });\n\n        var requires = deps.map(function(d) {\n          var path = getDependencyPath(d, p);\n          return d + \" = require('\"+ path +\"')\";\n        });\n        return 'var ' + requires.join(',\\n' + DTAB) + ';';\n      }\n\n      function getRequireRanking(r) {\n        if (r === 'Sugar') {\n          return 0;\n        } else if (ALL_CAPS.test(r)) {\n          return 1;\n        } else if (FIRST_CAPS.test(r)) {\n          return 2;\n        } else {\n          return 3;\n        }\n      }\n\n      return getRequiresSorted();\n    }\n\n    // Any build method calls don't require a reference and can be simply\n    // required directly, so output them here.\n    function getDirectRequires(p) {\n      return p.dependencies.filter(function(d) {\n        return DIRECT_REQUIRES_REG.test(d);\n      }).map(function(d) {\n        return \"require('\"+ getDependencyPath(d, p) +\"');\";\n      }).join('\\n');\n    }\n\n    function getAssigns(p) {\n      var assigns = [];\n      p.dependencies.forEach(function(d) {\n        var dep = findDependency(d, p);\n        if (dep && dep.vars && dep.vars.length > 1) {\n          dep.vars.forEach(function(v) {\n            if (p.varDependencies && p.varDependencies.indexOf(v) !== -1) {\n              assigns.push(v + ' = ' + dep.name + '.' + v);\n            }\n          });\n        }\n      });\n      if (!assigns.length) {\n        return '';\n      }\n      return 'var ' + assigns.join(',\\n' + DTAB) + ';';\n    }\n\n    function getPostAssigns(p) {\n      if (p.postAssigns && p.postAssigns.length) {\n        var assigns = p.postAssigns.map(function(a) {\n          return a.package.name + '.' + a.name + ' = ' + a.name + ';';\n        });\n        return assigns.join('\\n');\n      }\n      return '';\n    }\n\n    function getExports(p) {\n      var exports;\n      if (p.polyfill) {\n        return [\n          '// This package does not export anything as it is mapping a',\n          '// polyfill to '+ p.namespace +'.prototype which cannot be called statically.'\n        ].join('\\n');\n      } else if (p.type === 'prototype') {\n        return [\n          '// This package does not export anything as it is',\n          '// simply defining \"'+ p.name +'\" on '+ p.target +'.prototype.'\n        ].join('\\n');\n      } else if (p.type === 'locale') {\n        return [\n          '// This package does not export anything as it is',\n          '// simply registering the \"'+ p.code +'\" locale.'\n        ].join('\\n');\n      } else if (p.type === 'fix') {\n        return [\n          '// This package does not export anything as it is',\n          '// simply fixing existing behavior.'\n        ].join('\\n');\n      } else if (sourcePackageExportsMethod(p)) {\n        exports = ['Sugar', p.namespace, p.name].join('.');\n      } else if (p.vars && p.vars.length > 1) {\n        var lines = p.vars.map(function(v) {\n          return v + ': ' + (p.exportsDirectly ? p.assigns[v] : v);\n        });\n        exports = ['{', TAB + lines.join(',\\n' + TAB), '}'].join('\\n');\n      } else if (p.exportsDirectly) {\n        // Single line direct export\n        exports = p.assigns[p.vars[0]];\n      } else if (p.type !== 'build') {\n        exports = p.name;\n      }\n      // Build calls do not export themselves, so don't export unless they have\n      // explicit vars (caught above). No comment as this is internal.\n      return exports ? 'module.exports = ' + exports + ';' : '';\n    }\n\n    // --- Entry Point ---\n\n    function createEntryPoint(paths, subPath, name) {\n      var outputPath = path.join(packageDir, subPath || '', (name || 'index') + '.js'), requires;\n      requires = Array.isArray(paths) ? getRequiresForArray(paths) : getRequiresForGroup(paths);\n      var exports = \"module.exports = require('sugar-core');\";\n      var outputBody = [STRICT, requires, exports].join('\\n\\n');\n      writeFile(outputPath, outputBody);\n    }\n\n    function getRequiresForArray(arr) {\n      return arr.map(function(p) {\n        return \"require('\"+ p +\"');\";\n      }).join('\\n');\n    }\n\n    function getRequiresForGroup(group) {\n      var blocks = [];\n      iter(group, function(type, entries) {\n        var comment = getCommentForEntryPointType(type), requires;\n        entries = entries.map(function(entry) {\n          return entry.path;\n        });\n        entries.sort();\n        requires = compact([comment, getRequiresForArray(entries)]).join('\\n');\n        blocks.push({\n          type: type,\n          requires: requires\n        });\n      });\n      blocks.sort(function(a, b) {\n        var aRank = getRankForEntryPointType(a.type);\n        var bRank = getRankForEntryPointType(b.type);\n        return aRank - bRank;\n      });\n      return blocks.map(function(b) {\n        return b.requires;\n      }).join('\\n\\n');\n    }\n\n    function getRankForEntryPointType(type) {\n      switch (type) {\n        case 'polyfill':  return 1;\n        case 'module':    return 2;\n        case 'static':    return 3;\n        case 'instance':  return 4;\n        case 'prototype': return 5;\n        case 'alias':     return 6;\n        case 'accessor':  return 7;\n      }\n    }\n\n    function getCommentForEntryPointType(type) {\n      if (type === 'polyfill') {\n        return '// Polyfills';\n      } else if (type === 'alias') {\n        return '// Aliases';\n      } else if (type === 'accessor') {\n        return '// Accessors';\n      } else if (type === 'fix') {\n        return '// Fixes';\n      } else if (type === 'static') {\n        return '// Static Methods';\n      } else if (type === 'instance') {\n        return '// Instance Methods';\n      } else if (type === 'prototype') {\n        return '// Prototype Methods';\n      } else if (type === 'module') {\n        return '// Modules';\n      }\n    }\n\n    function getEntryPointTypeForPackage(p) {\n      if (p.alias) {\n        return 'alias';\n      } else {\n        return p.type;\n      }\n    }\n\n  }\n\n  function mergeMethodDependencies() {\n    sourcePackages.forEach(function(sp) {\n      var deps = sp.dependencies, mdeps = sp.methodDependencies;\n      sp.dependencies = (deps || []).concat(mdeps || []);\n    });\n  }\n\n  // Circular dependencies are not necessarily a problem for Javascript at\n  // execution time due to having different code paths, however they don't work\n  // for npm packages, so they must be bundled together. This isn't too fancy so\n  // more complicated dependencies should be refactored. First in the source\n  // will be the target package for the bundle.\n  function bundleCircularDependencies() {\n\n    function findCircular(deps, chain) {\n      for (var i = 0, startIndex, c, p; i < deps.length; i++) {\n        // Only top level dependencies will be included in the chain.\n        p = sourcePackages.findByDependencyName(deps[i]);\n        if (!p) {\n          continue;\n        }\n        startIndex = chain.indexOf(p.name);\n        if (startIndex !== -1) {\n          return chain.slice(startIndex);\n        } else {\n          c = findCircular(p.dependencies, chain.concat(p.name));\n          if (c) {\n            return c;\n          }\n        }\n      }\n    }\n\n    function bundleCircular(chain) {\n\n      // Sort the chain so that all packages are\n      // bundled into the first found in the source.\n      chain = sortChain(chain);\n\n      var target = sourcePackages.findByDependencyName(chain[0]);\n      delete target.comments;\n      chain.slice(1).forEach(function(n) {\n        var src = sourcePackages.findByDependencyName(n);\n        target.body += '\\n\\n' + src.body;\n        target.bodyWithComments += '\\n\\n' + src.bodyWithComments;\n        bundleArray(target, src, 'dependencies', true);\n        bundleArray(target, src, 'varDependencies', true);\n        bundleArray(target, src, 'vars');\n        bundleMap(target, src, 'assigns');\n        updateExternalDependencies(src.name, target.name);\n\n        if (src.type === 'build' && (!target.vars || !target.vars.length)) {\n          // A build function that is having it's call block being bundled\n          // into it can also take on the type \"build\". This generally means\n          // that it has no exports. However don't do this if the function is\n          // building up variables, in which case it will have a \"vars\".\n          target.type = 'build';\n        }\n\n        removePackage(src);\n      });\n\n    }\n\n    function sortChain(chain) {\n      return chain.sort(function(a, b) {\n        return getPackageIndexByName(a) - getPackageIndexByName(b);\n      });\n    }\n\n    function getPackageIndexByName(name) {\n      return sourcePackages.findIndex(function(p) {\n        return p.name === name;\n      });\n    }\n\n    // Bundle all dependencies from the source into the target,\n    // but only after removing the circular dependency itself.\n    function bundleArray(target, src, name, notSelf) {\n      var srcValues, targetValues;\n      if (src[name]) {\n        srcValues = src[name] || [];\n        targetValues = target[name] || [];\n        target[name] = uniq(targetValues.concat(srcValues.filter(function(d) {\n          return !notSelf || d !== target.name;\n        })));\n      }\n    }\n\n    function bundleMap(target, src, name) {\n      if (src[name]) {\n        target[name] = target[name] || {};\n        merge(target[name], src[name]);\n      }\n    }\n\n    // Update all packages pointing to the old package.\n    function updateExternalDependencies(oldName, newName) {\n      sourcePackages.forEach(function(p) {\n        var index = p.dependencies.indexOf(oldName);\n        if (index !== -1) {\n          if (p.name === newName || p.dependencies.indexOf(newName) !== -1) {\n            // If the package has the same name as the one we are trying to\n            // update to, then we are trying to update the package to point\n            // to itself as a dependency, which isn't possible so just remove\n            // the old dependency. Alternatively, if the package already has\n            // the new name, then we can simply remove the old one and move on.\n            p.dependencies.splice(index, 1);\n          } else {\n            // If the package is NOT trying to update to itself and does NOT\n            // have the new dependency already, then add it in place of the\n            // old one.\n            p.dependencies.splice(index, 1, newName);\n          }\n        }\n      });\n    }\n\n    function removePackage(p) {\n      var index = sourcePackages.indexOf(p);\n      sourcePackages.splice(index, 1);\n    }\n\n    sourcePackages.forEach(function(p) {\n      var chain = findCircular(p.dependencies, []);\n      if (chain) {\n        bundleCircular(chain);\n      }\n    });\n  }\n\n  // Find a package that is being depended on. Dependencies are usually top level\n  // functions or variables that are in the main scope, however aliases are\n  // dependent on the methods they alias to, so if no top level member is found\n  // then fall back to methods using a second pass. Note that only Sugar methods\n  // as opposed to polyfills are considered dependencies. This effectively means\n  // that alias('all', 'every') will always refer to the Sugar enhanced method,\n  // NOT the polyfill. The reason for this is to prevent confusion if the \"all\"\n  // method's functionality were to suddenly change depending on whether the\n  // enhanced \"every\" method was present or not. Additionally, generally native\n  // functionality should use it's proper name, so aliases should always be\n  // referring to something beyond that.\n  function findDependency(name, p) {\n    return sourcePackages.findByDependencyName(name) || sourcePackages.findByDependentPackage(p);\n  }\n\n  return stream;\n}\n\n// -------------- JSON Docs ----------------\n\nfunction buildJSONAPI() {\n\n  var SINGULAR_UNITS_REG = /^(year|month|week|day|hour|minute|second|millisecond)(?!s)/;\n\n  var docs = getJSONDocs(), data = {};\n\n  data.namespaces = docs.namespaces.map(function(ns) {\n    return {\n      name: ns.name,\n      methods: ns.methods.map(function(m) {\n        var p = {\n          name: m.name,\n          module: m.module\n        };\n        if (m.set) {\n          p.set = m.set.filter(function(name) {\n            return !SINGULAR_UNITS_REG.test(name);\n          });\n        }\n        return p;\n      })\n    };\n  });\n\n  outputJSON('api.json', data);\n}\n\nfunction buildJSONDocs() {\n  outputJSON('docs.json', getJSONDocs());\n}\n\nfunction getJSONDocs() {\n\n  var ALIAS_FIELDS = [\n    'args',\n    'returns',\n    'short',\n    'extra',\n    'callbacks',\n    'examples'\n  ];\n\n  var LINKED_TOKENS = {\n    'MOD': '#/Modules',\n    'default build': '#/Modules',\n    'extending': '#/Extending',\n    'object methods': '#/ObjectMethods',\n    'enhanced matching': '#/ArrayMatching',\n    'enhanced methods': '#/EnhancedMethods',\n    'enhanced method': '#/EnhancedMethods',\n    'enhances': '#/EnhancedMethods',\n    'deep properties': '#/DeepProperties',\n    'deep property': '#/DeepProperties',\n    'date locales': '#/DateLocales',\n    'date parsing': '#/DateParsing',\n    'date formatting': '#/DateFormatting',\n    'polyfill': '#/Polyfills',\n    'extending natives': '/natives',\n    'ranges': '#/Ranges',\n    'sortIgnore': '#/Array/setOption',\n    'exclude': '#/Array/exclude',\n    'remove': '#/Array/remove',\n    'append': '#/Array/append',\n    'insert': '#/Array/insert',\n    'each': '#/Array/each',\n    'add': '#/Array/add',\n    'merge': '#/Object/merge',\n    'create': '#/Date/create',\n    'unitsAgo': '#/Date/unitsAgo',\n    'Date#relative': '#/Date/relative',\n    'unitsFromNow': '#/Date/unitsFromNow',\n    'thousands': '#/Number/thousands',\n    'decimal': '#/Number/decimal',\n    'log': '#/Number/log',\n    'addHuman': '#/String/addHuman',\n    'addPlural': '#/String/addPlural',\n    'removeAll': '#/String/removeAll',\n    'extend': '#/Sugar/extend',\n    'defineStatic': '#/Sugar/defineStatic',\n    'defineInstance': '#/Sugar/defineInstance',\n    'defineInstanceWithArguments': '#/Sugar/defineInstanceWithArguments',\n    'defineStaticWithArguments': '#/Sugar/defineStaticWithArguments'\n  };\n\n  var POLYFILL_HTML = getReplacements('This method is provided as a `polyfill`.');\n  var ENHANCED_HTML = getReplacements('This method is also provided as a `polyfill` in the MOD module.');\n\n  var POLYFILL_REPLACE_REG = /This method is (also )?provided as a .*polyfill.*\\./;\n\n  var JSDOC_PARAM_REG = /\\{([\\w<>|\\[\\]]+)\\} (\\[)?(\\w+)\\]?(?: - (.+))?[\\s\\*]*$/;\n  var JSDOC_SIGNATURE_REG = /([\\w\\[\\]]+)\\((.*)\\)$/m;\n\n  var docs = {\n    namespaces: []\n  };\n\n  var currentNamespace;\n  var currentModuleName;\n  var modules = getModulePaths('all');\n  var modulePathMap = {};\n\n  function getNamespaceForModuleName(name) {\n    if (name === 'Core') {\n      return 'Sugar';\n    }\n    return name.match(/Core|Object|Number|String|Array|Date|RegExp|Function|Range/) ? name : null;\n  }\n\n  function setCurrentNamespace(name) {\n    if (!name) {\n      return;\n    }\n    var namespace = docs.namespaces.find(function(ns) {\n      return ns.name === name;\n    });\n    if (namespace) {\n      currentNamespace = namespace;\n    } else {\n      currentNamespace = {\n        name: name,\n        methods: []\n      };\n      docs.namespaces.push(currentNamespace);\n    }\n  }\n\n  function processModule(block, path) {\n    var match = block.match(/@module (\\w+)/);\n    if (match) {\n      var name = match[1];\n      setCurrentNamespace(getNamespaceForModuleName(name));\n      modulePathMap[path] = { name: name };\n      setAllFields(modulePathMap[path], block);\n      currentModuleName = name;\n    }\n  }\n\n  function processNamespace(block) {\n    var match = block.match(/@namespace (\\w+)/);\n    if (match) {\n      setCurrentNamespace(match[1]);\n    }\n  }\n\n  function setAllFields(obj, block) {\n    block.replace(/@(\\w+)\\s?([\\s\\S]+?)(?=@|$)/g, function(match, field, value) {\n      if (field === 'method' || field === 'module') return;\n      if (!value) {\n        value = true;\n      } else if (field === 'polyfill') {\n        obj['extra'] = (obj['extra'] || '') + getPolyfillNote(obj, getTextField(value));\n        return;\n      } else if (field === 'example') {\n        field = 'examples';\n        value = getExamples(value);\n      } else if (field === 'options') {\n        value = getOptions(value);\n      } else if (field === 'callback') {\n        field = 'callbacks';\n        value = getCallback(value, obj[field]);\n      } else if (field === 'set') {\n        value = getMultiline(value, true);\n      } else if (field === 'param') {\n        mapParamType(value, obj);\n        return;\n      } else if (field === 'callbackParam') {\n        mapCallbackParamType(value, obj);\n        return;\n      } else if (field === 'callbackReturns') {\n        mapCallbackReturnType(value, obj);\n        return;\n      } else if (field === 'option') {\n        mapOptionType(value, obj['options']);\n        return;\n      } else if (field === 'returns') {\n        value = getSingleline(value);\n      } else if (field === 'signature') {\n        field = 'signatures';\n        value = pushSignature(getSingleline(value), obj[field]);\n      } else {\n        value = getTextField(value);\n        if (field === 'extra' && obj[field]) {\n          value += ' ' + obj[field];\n        }\n      }\n      obj[field] = value;\n    });\n  }\n\n  function getPolyfillNote(method, mod) {\n    if (/^ES[567]$/i.test(method.module)) {\n      return POLYFILL_HTML;\n    } else {\n      return ENHANCED_HTML.replace(/MOD/, mod);\n    }\n  }\n\n  function getOptions(str) {\n    var lines = getMultiline(str), lineBuffer = [];\n    var options = [];\n    lines.forEach(function(line) {\n      if (!line && lineBuffer.length) {\n        var buffer = lineBuffer.join(' ');\n        var match = buffer.match(/^(\\w+)\\s+(.+)$/);\n        options.push({\n          name: match[1],\n          description: getReplacements(match[2])\n        });\n        lineBuffer = [];\n      } else if (line) {\n        lineBuffer.push(line);\n      }\n    });\n    return options;\n  }\n\n  function getCallback(str, callbacks) {\n    var callbackName;\n    if (!callbacks) {\n      callbacks = [];\n    }\n    str = str.replace(/(\\w+)$/m, function(all, match) {\n      callbackName = match;\n      return '';\n    });\n    var params = [];\n    getMultiline(str, true).forEach(function(line) {\n      var match = line.match(/^(\\w+)\\s{2,}(.+)$/);\n      if (match) {\n        params.push({\n          name: match[1],\n          description: getReplacements(match[2])\n        });\n      } else {\n        params[params.length - 1].description += ' ' + getReplacements(line);\n      }\n    });\n    callbacks.push({\n      name: callbackName,\n      params: params\n    });\n    return callbacks;\n  }\n\n  function getTextField(str) {\n    var text = getReplacements(getMultiline(str).join('\\n'));\n    return text ? text : true;\n  }\n\n  function getReplacements(str) {\n    return str.replace(/([<\\[])(\\w+?)([>\\]])/g, function(all, open, token) {\n      if (open === '<') {\n        return '<code class=\"docs-required-argument\">' + token + '</code>';\n      } else if (open === '[') {\n        return '<code class=\"docs-optional-argument\">' + token + '</code>';\n      }\n    }).replace(/^#(.+)$/m, '<span class=\"docs-method-body-header\">$1</span>')\n      .replace(/\\n+$/, '')\n      .replace(/\\n+/g, function(nl) {\n        var result = ' ';\n        if (nl.length > 1) {\n          result += new Array(nl.length).join('<br><br>');\n        }\n        return result;\n    }).replace(/`([^`]+)`/g, function(all, token) {\n      if (LINKED_TOKENS[token]) {\n        return '<a jump-link href=\"'+ LINKED_TOKENS[token] +'\">' + token + '</a>';\n      } else {\n        return '<code>' + token + '</code>';\n      }\n    });\n  }\n\n  function getSingleline(str) {\n    return getMultiline(str, true)[0];\n  }\n\n  function getMultiline(str, clean) {\n\n    var lines = str.split('\\n').map(function(line) {\n      return line.replace(/^[\\s*]*|[\\s*]*$/g, '');\n    });\n    if (clean) {\n      lines = lines.join('\\n').replace(/^\\n+|\\n+$/g, '').split('\\n');\n    }\n    return lines;\n  }\n\n  function getParamMatch(str) {\n    var match = str.match(JSDOC_PARAM_REG);\n    return {\n      type: match[1],\n      name: match[3],\n      required: !match[2],\n      description: match[4]\n    };\n  }\n\n  function mapParamType(str, method) {\n\n    var param = getParamMatch(str);\n\n\n    function map(signature) {\n      signature.forEach(function(p) {\n        if (p.name === param.name) {\n          p.type = param.type;\n          p.description = param.description;\n        }\n      });\n    }\n\n    map(method.params);\n    if (method.signatures) {\n      method.signatures.forEach(map);\n    }\n  }\n\n  function mapCallbackParamType(str, method) {\n    var param = getParamMatch(str);\n    method.callbacks.forEach(function(callback) {\n      callback.params.forEach(function(p) {\n        if (p.name === param.name) {\n          p.type = param.type;\n          p.required = param.required;\n        }\n      });\n    });\n  }\n\n  function mapCallbackReturnType(str, method) {\n    var returns = getParamMatch(str);\n    method.callbacks.forEach(function(callback) {\n      if (callback.name === returns.name) {\n        callback.returns = returns.type;\n      }\n    });\n  }\n\n  function pushSignature(str, signatures) {\n    var match = str.match(JSDOC_SIGNATURE_REG);\n    var signature = getParams(match[2]);\n    if (!signatures) {\n      signatures = [];\n    }\n    signatures.push(signature);\n    return signatures;\n  }\n\n  function mapOptionType(str, options) {\n    var match = str.match(JSDOC_PARAM_REG);\n\n    var optionType = match[1];\n    var optionName = match[3];\n    var required  = !match[2];\n\n    var option = options.find(function(o) {\n      return o.name === optionName;\n    });\n    option.type = optionType;\n    option.required = required;\n  }\n\n  function getExamples(str) {\n    var lines = getMultiline(str, true);\n\n    function getLine() {\n      var line = lines.shift();\n      return line ? line.replace(/\\s*->.+$/, '') : '';\n    }\n\n    function groupLines() {\n      for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        var nextLine = lines[i + 1];\n        if (line.match(/{$/)) {\n          break;\n        } else if (line == '') {\n          lines.splice(i, 1);\n          i--;\n          continue;\n        }\n        if (line.match(/^(var )?\\w+ = /) && !line.match(/->/) && nextLine && nextLine.trim()) {\n          while (nextLine) {\n            lines[i] += '\\n' + nextLine;\n            lines.splice(i + 1, 1);\n            nextLine = lines[i + 1];\n          }\n        }\n      }\n    }\n\n    function getLines() {\n      var result = [];\n      for (var line; line = getLine();) {\n        var braceLevel = getBraceLevel(line);\n        while (braceLevel > 0) {\n          var nextLine = getLine();\n          var nextBraceLevel = braceLevel + getBraceLevel(nextLine);\n          var indent = '  '.repeat(nextBraceLevel > braceLevel ? braceLevel : nextBraceLevel);\n          line += '\\n' + indent  + nextLine;\n          braceLevel = nextBraceLevel;\n        }\n        result.push(line);\n      }\n      return result;\n    }\n\n    groupLines();\n\n    return getLines();\n  }\n\n  function getBraceLevel(str) {\n    var open = str.match(/{/g);\n    var close = str.match(/}/g);\n    return (open && open.length || 0) - (close && close.length || 0);\n  }\n\n  function processMethod(block, lines) {\n    var match = block.match(/@method ([\\w\\[\\]]+)\\((.*)\\)$/m);\n    if (match) {\n      var method = {};\n      var name = match[1];\n      var nameClean = match[1].replace(/(\\w*)\\[(\\w+)\\](\\w*)/, function(full, left, mid, right) {\n        method['name_html'] = left + '<span class=\"docs-method__set\">' + mid + '</span>' + right;\n        return left + mid + right;\n      });\n\n      method.name = nameClean;\n      method.module = currentModuleName;\n      method.params = getParams(match[2]);\n\n      setAllFields(method, block);\n\n      method.line = getLineNumber(name, lines);\n      method.type = getMethodType(method);\n\n      checkAlias(method, name);\n      currentNamespace.methods.push(method);\n    }\n  }\n\n  function getParams(str) {\n    var params = str && str.split(', ').filter(function(a) {\n      return !!a;\n    });\n\n    if (!params) {\n      params = [];\n    }\n\n    return params.map(function(p) {\n      var s = p.split(' = ');\n      var m = s[0].match(/(\\[)?(\\w+)\\]?|(\\.\\.\\.)/);\n      var param = {};\n      if (m[2]) {\n        param.name = m[2];\n        param.required = !m[1];\n      }\n      if (m[3]) {\n        param.glob = true;\n        param.name = '...';\n      }\n      if (s[1]) {\n        param.default = s[1];\n      }\n      return param;\n    });\n  }\n\n  function checkAlias(method, name) {\n    if (method.alias && !method.short) {\n      var srcMethod = currentNamespace.methods.find(function(m) {\n        return m.name === method.alias;\n      });\n      var reg = RegExp('\\\\.' + method.alias, 'g');\n      iter(srcMethod, function(field, value) {\n        if (ALIAS_FIELDS.indexOf(field) !== -1) {\n          if (field === 'examples') {\n            value = value.map(function(l) {\n              return l.replace(reg, '.' + name);\n            });\n          } else if (typeof value === 'string') {\n            value = value.replace(reg, '.' + name);\n          }\n          if (field === 'extra') {\n            value = value.replace(POLYFILL_REPLACE_REG, '');\n          }\n          method[field] = value;\n        }\n      });\n      method.short = 'Alias for <code>' + method.alias + '</code>. ' + method.short;\n      delete method.alias;\n    }\n  }\n\n  function getLineNumber(methodName, lines) {\n    var lineNum;\n    var src = methodName.replace(/(\\[|\\])/g, '\\\\$1');\n    var reg = RegExp('@method ' + src);\n    lines.some(function(l, i) {\n      if (l.match(reg)) {\n        lineNum = i + 1;\n        return true;\n      }\n    });\n    return lineNum;\n  }\n\n  modules.forEach(function(p) {\n    var content = fs.readFileSync(p, 'utf-8');\n    var lines = content.split('\\n');\n    content.replace(/\\*\\*\\*[\\s\\S]+?(?=\\*\\*\\*)/gm, function(block) {\n      processModule(block, p);\n      processNamespace(block);\n      processMethod(block, lines);\n    });\n  });\n\n  function sortNamespaces() {\n    docs.namespaces.sort(namespaceCollate);\n  }\n\n  function namespaceCollate(a, b) {\n    var aName = a.name;\n    var bName = b.name;\n    if (aName === 'Sugar') {\n      return 1;\n    }\n    return aName === bName ? 0 : aName < bName ? -1 : 1;\n  }\n\n  function getMethodType(method) {\n    switch (true) {\n      case method.namespace === 'Sugar':          return 'global';\n      case method.namespace === 'SugarNamespace': return 'namespace';\n      case method.static:    return 'static';\n      case method.accessor:  return 'accessor';\n      default:               return 'instance';\n    }\n  }\n\n  sortNamespaces(docs);\n\n  return docs;\n}\n\n// --- JSON Source ---\n\nfunction buildJSONSource() {\n\n  var data = getModularSource();\n\n  addCorePackage();\n  prepareData();\n  outputJSON('source.json', data);\n\n  function addCorePackage() {\n    data.modules.unshift({\n      name: 'Core'\n    });\n    data.packages.unshift({\n      name: 'Sugar',\n      type: 'core',\n      module: 'Core',\n      dependencies: [],\n      bodyWithComments: readFile('lib/core.js').trim()\n    });\n  }\n\n  function bundleSetPackages() {\n    var packages = [], handledSets = {}, p;\n\n    for (var i = 0; i < data.packages.length; i++) {\n      p = data.packages[i];\n      if (p.set) {\n        // If the package has been handled already then just skip.\n        if (!handledSets[p.namespace + p.setName]) {\n          packages.push({\n            setName: p.setName,\n            name: p.setName.replace(/[\\[\\]]/g, ''),\n            sample: p.set.slice(0, 3).concat('...').join(', '),\n            type: p.type,\n            alias: p.alias,\n            module: p.module,\n            namespace: p.namespace,\n            dependencies: p.dependencies,\n            bodyWithComments: p.bodyWithComments\n          });\n          handledSets[p.namespace + p.setName] = true;\n        }\n      } else {\n        packages.push(p);\n      }\n    }\n\n    return packages;\n  }\n\n  function prepareData() {\n    var bundledPackages = bundleSetPackages();\n    data.modules.forEach(function(m) {\n      indentField(m, 'comment');\n    });\n    bundledPackages.forEach(function(p) {\n\n      // Pre-indenting all packages rather than doing it on compile to\n      // save some cycles and also correctly calculate the package size.\n      indentField(p, 'blockStart');\n      indentField(p, 'blockEnd');\n      indentField(p, 'bodyWithComments');\n\n      cleanSourcePackage(p);\n    });\n    data.packages = bundledPackages;\n  }\n\n  function indentField(p, field) {\n    if (p[field]) {\n      p[field] = p[field].replace(/^(?=.)/gm, '  ');\n    }\n  }\n\n  function cleanSourcePackage(p) {\n    if (sourcePackageIsDependency(p)) {\n      delete p.type;\n    }\n    delete p.vars;\n    delete p.target;\n    delete p.body;\n    delete p.path;\n    delete p.assigns;\n    delete p.comments;\n    delete p.defineMethod;\n    delete p.varDependencies;\n    compactField(p, 'bodyWithComments');\n    compactField(p, 'dependencies');\n  }\n\n  function compactField(p, field) {\n    var val = p[field];\n    if (!val || (Array.isArray(val) && !val.length)) {\n      delete p[field];\n    }\n  }\n\n}\n\n// -------------- Typescript Declarations ----------------\n\n\nvar TS_LICENSE = block`\n// Type definitions for Sugar ${getVersion(true)}\n// Project: https://sugarjs.com/\n// Definitions by: Andrew Plummer <plummer.andrew@gmail.com>\n`;\n\nvar TS_EXTENDED_LICENSE = block`\n// Extended type definitions for Sugar ${getVersion(true)}\n// Project: https://sugarjs.com/\n// Definitions by: Andrew Plummer <plummer.andrew@gmail.com>\n`;\n\nfunction buildTypescriptDeclarations() {\n  var basePath = args.o || args.output || '';\n  var moduleNames = getModuleNames();\n  exportTypescriptDeclarations(basePath, moduleNames, args.include, args.exclude);\n}\n\nfunction exportTypescriptDeclarations(basePath, allowedModules, include, exclude) {\n\n  var optionInterfaceNamespaces = {};\n  var moduleCallbackGenerics = {};\n  var moduleOptionsGenerics = {};\n\n  var whitelist = getMethodList(include);\n  var blacklist = getMethodList(exclude);\n\n  var TYPE_REG = /is(Boolean|Number|String|Date|RegExp|Function|Array|Error|Set|Map)$/;\n\n  var TYPE_GUARD_GENERICS = {\n    Array: ['any'],\n    Map: ['any', 'any'],\n    Set: ['any']\n  }\n\n  var CHAINABLE_RAW_TYPE = 'RawValue';\n\n  var CHAINABLE_NATIVE_METHODS = {\n\n    Array: [\n      'toLocaleString(): string;',\n      'push(...items: T[]): number;',\n      'pop(): T | undefined;',\n      'concat(...items: T[][]): T[];',\n      'concat(...items: (T | T[])[]): T[];',\n      'join(separator?: string): string;',\n      'reverse(): T[];',\n      'shift(): T | undefined;',\n      'slice(start?: number, end?: number): T[];',\n      'sort(compareFn?: (a: T, b: T) => number): this;',\n      'splice(start: number): T[];',\n      'splice(start: number, deleteCount: number, ...items: T[]): T[];',\n      'unshift(...items: T[]): number;',\n      'indexOf(searchElement: T, fromIndex?: number): number;',\n      'lastIndexOf(searchElement: T, fromIndex?: number): number;',\n      'every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;',\n      'some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;',\n      'forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;',\n      'map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];',\n      'filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];',\n      'reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;',\n      'reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;',\n      'reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): T;',\n      'reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;',\n\n      // ES6\n      'find(predicate: (value: T, index: number, obj: Array<T>) => boolean, thisArg?: any): T | undefined;',\n      'findIndex(predicate: (value: T, index: number, obj: Array<T>) => boolean, thisArg?: any): number;',\n      'fill(value: T, start?: number, end?: number): this;',\n      'copyWithin(target: number, start: number, end?: number): this;',\n\n    ],\n\n    Date: [\n      'toDateString(): string;',\n      'toTimeString(): string;',\n      'toLocaleString(): string;',\n      'toLocaleDateString(): string;',\n      'toLocaleTimeString(): string;',\n      'getTime(): number;',\n      'getFullYear(): number;',\n      'getUTCFullYear(): number;',\n      'getMonth(): number;',\n      'getUTCMonth(): number;',\n      'getDate(): number;',\n      'getUTCDate(): number;',\n      'getDay(): number;',\n      'getUTCDay(): number;',\n      'getHours(): number;',\n      'getUTCHours(): number;',\n      'getMinutes(): number;',\n      'getUTCMinutes(): number;',\n      'getSeconds(): number;',\n      'getUTCSeconds(): number;',\n      'getMilliseconds(): number;',\n      'getUTCMilliseconds(): number;',\n      'getTimezoneOffset(): number;',\n      'setTime(time: number): number;',\n      'setMilliseconds(ms: number): number;',\n      'setUTCMilliseconds(ms: number): number;',\n      'setSeconds(sec: number, ms?: number): number;',\n      'setUTCSeconds(sec: number, ms?: number): number;',\n      'setMinutes(min: number, sec?: number, ms?: number): number;',\n      'setUTCMinutes(min: number, sec?: number, ms?: number): number;',\n      'setHours(hours: number, min?: number, sec?: number, ms?: number): number;',\n      'setUTCHours(hours: number, min?: number, sec?: number, ms?: number): number;',\n      'setDate(date: number): number;',\n      'setUTCDate(date: number): number;',\n      'setMonth(month: number, date?: number): number;',\n      'setUTCMonth(month: number, date?: number): number;',\n      'setFullYear(year: number, month?: number, date?: number): number;',\n      'setUTCFullYear(year: number, month?: number, date?: number): number;',\n      'toUTCString(): string;',\n      'toISOString(): string;',\n      'toJSON(key?: any): string;',\n\n      // ES6\n      'toLocaleString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;',\n      'toLocaleDateString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;',\n      'toLocaleTimeString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): string;',\n\n    ],\n\n    String: [\n      'charAt(pos: number): string;',\n      'charCodeAt(index: number): number;',\n      'concat(...strings: string[]): string;',\n      'indexOf(searchString: string, position?: number): number;',\n      'lastIndexOf(searchString: string, position?: number): number;',\n      'localeCompare(that: string): number;',\n      'match(regexp: string): RegExpMatchArray | null;',\n      'match(regexp: RegExp): RegExpMatchArray | null;',\n      'replace(searchValue: string, replaceValue: string): string;',\n      'replace(searchValue: string, replacer: (substring: string, ...args: any[]) => string): string;',\n      'replace(searchValue: RegExp, replaceValue: string): string;',\n      'replace(searchValue: RegExp, replacer: (substring: string, ...args: any[]) => string): string;',\n      'search(regexp: string): number;',\n      'search(regexp: RegExp): number;',\n      'slice(start?: number, end?: number): string;',\n      'split(separator: string, limit?: number): string[];',\n      'split(separator: RegExp, limit?: number): string[];',\n      'substring(start: number, end?: number): string;',\n      'toLowerCase(): string;',\n      'toLocaleLowerCase(): string;',\n      'toUpperCase(): string;',\n      'toLocaleUpperCase(): string;',\n      'trim(): string;',\n      'substr(from: number, length?: number): string;',\n\n      // ES6\n      'localeCompare(that: string, locales?: string | string[], options?: Intl.CollatorOptions): number;',\n      'codePointAt(pos: number): number | undefined;',\n      'includes(searchString: string, position?: number): boolean;',\n      'endsWith(searchString: string, endPosition?: number): boolean;',\n      'normalize(form: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): string;',\n      'normalize(form?: string): string;',\n      'repeat(count: number): string;',\n      'startsWith(searchString: string, position?: number): boolean;',\n      'anchor(name: string): string;',\n      'big(): string;',\n      'blink(): string;',\n      'bold(): string;',\n      'fixed(): string;',\n      'fontcolor(color: string): string;',\n      'fontsize(size: number): string;',\n      'fontsize(size: string): string;',\n      'italics(): string;',\n      'link(url: string): string;',\n      'small(): string;',\n      'strike(): string;',\n      'sub(): string;',\n      'sup(): string;',\n    ],\n\n    Number: [\n      'toFixed(fractionDigits?: number): string;',\n      'toExponential(fractionDigits?: number): string;',\n      'toPrecision(precision?: number): string;',\n\n      // ES6\n      'toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): string;',\n    ],\n\n    Function: [\n      'apply(thisArg: any, argArray?: any): any;',\n      'call(thisArg: any, ...argArray: any[]): any;',\n      'bind(thisArg: any, ...argArray: any[]): any;',\n    ],\n\n    RegExp: [\n      'exec(string: string): RegExpExecArray | null;',\n      'test(string: string): boolean;',\n    ]\n\n  };\n\n  var LOCALE_METHODS = [\n    'getMonthName(n: number): string;',\n    'getWeekdayName(n: number): string;',\n    'getDuration(ms: number): string;',\n    'getFirstDayOfWeek(): number;',\n    'getFirstDayOfWeekYear(): number;',\n    'addFormat(src:string, to?: Array<string>): void;'\n  ];\n\n\n  /* ------------ Declared Module -------------- */\n\n  function getDeclaredModuleSource() {\n    var body = [\n      'const Sugar: sugarjs.Sugar;',\n      'export = Sugar;'\n    ].join('\\n');\n    return [\n      'declare module \"sugar\" {',\n        indent(body, 1),\n      '}'\n    ].join('\\n');\n  }\n\n  /* ------------ Declared Namespace -------------- */\n\n  function getDeclaredNamespace(name) {\n    return {\n      name: name,\n      types: [],\n      namespaces: [],\n      interfaces: []\n    }\n  }\n\n  function getDeclaredNamespaceSource(module, top) {\n    var blocks = [];\n\n    function addBlock(arr, sep, map) {\n      if (arr.length) {\n        arr = compact(arr);\n        if (map) {\n          arr = arr.map(map);\n        }\n        blocks.push(indent(arr.join(sep), 1));\n      }\n    }\n\n    function mapType(type) {\n      return 'type ' + type.name + (type.generics || '') + ' = ' + type.type + ';'\n    }\n\n    addBlock(module.types, '\\n'.repeat(top ? 2 : 1), mapType);\n    addBlock(module.interfaces, '\\n\\n');\n    addBlock(module.namespaces, '\\n\\n');\n\n    blocks.unshift((top ? 'declare ' : '') + 'namespace ' + module.name + ' {');\n    blocks.push('}');\n    return blocks.join('\\n\\n');\n  }\n\n  function getInterfaceBlocks(interfaces) {\n    return interfaces.filter(function(interface) {\n      return interface;\n    }).join('\\n\\n');\n  }\n\n  /* ------------ Interfaces -------------- */\n\n  function getConstructorInterface(namespace, module) {\n\n    var methods = [];\n\n\n    // Add the main chainable type.\n\n    var chainableGenerics = getChainableBaseGenerics(namespace.name)\n    var chainableType = 'ChainableBase' + chainableGenerics;\n\n    if (namespace.name !== 'Object') {\n      chainableType += ' & Object.ChainableBase' + getChainableBaseGenerics('Object');\n    }\n    module.types.push({\n      name: 'Chainable' + chainableGenerics,\n      type: chainableType\n    });\n\n\n    // Set up constructor methods.\n\n    var rawType = getRawType(namespace.name);\n\n    var constructorMethod = {\n      name: 'new',\n      type: 'constructor',\n      module: namespace.name,\n      generics: getNamespaceBaseGenerics(namespace.name),\n      returns: 'Chainable' + getChainableInstanceGenerics(namespace.name),\n      params: [{\n        name: 'raw',\n        type: rawType\n      }]\n    };\n\n    var createMethod = namespace.methods.find(function(method) {\n      return method.name === 'create';\n    });\n\n    if (createMethod) {\n      // If the namespace has a \"create\" method, then it will be mapped\n      // to the chainable constructor, so accomodate for that here.\n      constructorMethod.params = createMethod.params;\n      constructorMethod.params[0].required = false;\n    }\n\n    var factoryMethod = clone(constructorMethod);\n    factoryMethod.name = '';\n\n    methods.push(constructorMethod);\n    methods.push(factoryMethod);\n\n\n    // Set up all remaining methods.\n\n    namespace.methods.forEach(function(method) {\n      var instanceParam = {\n        name: 'instance',\n        required: true,\n        type: getInstanceParamType(method, rawType)\n      };\n      var method = clone(method);\n      if (method.type === 'instance') {\n        method.params.unshift(instanceParam);\n        if (method.signatures) {\n          method.signatures.forEach(function(signature) {\n            signature.unshift(instanceParam);\n          });\n        }\n        if (namespace.name === 'Array') {\n          method.generics = ['T'];\n        }\n      }\n      methods.push(method);\n    });\n\n    methods = buildMethods(methods, namespace, 'static');\n    return getInterfaceSource('Constructor', methods.join('\\n'), null, 'SugarNamespace');\n  }\n\n  function getChainableBaseInterface(namespace) {\n    var methods, existing = {};\n\n    // Add native methods that are aliased onto the chainable prototype.\n    methods = getRawMethods(CHAINABLE_NATIVE_METHODS[namespace.name], namespace.name, true);\n\n    // Add all instance methods.\n    namespace.methods.forEach(function(method) {\n      if (method.type === 'instance') {\n        existing[method.name] = true;\n        methods.push(method);\n      }\n    });\n\n    methods = buildMethods(methods, namespace, 'chainable');\n\n    var chainableDefaults = [\n      'raw: ' + CHAINABLE_RAW_TYPE + ';',\n      'valueOf: () => ' + CHAINABLE_RAW_TYPE + ';',\n      'toString: () => string;'\n    ];\n\n    var src = chainableDefaults.concat(methods).join('\\n');\n    return getInterfaceSource('ChainableBase', src, getChainableBaseGenerics(namespace.name));\n  }\n\n  function getExtendedConstructorInterface(namespace) {\n    var methods = getExtendedMethods(namespace, 'static');\n\n    // Add object instance methods as static, i.e.\n    // Object.forEach, etc.\n    if (namespace.name === 'Object') {\n      var objectInstanceMethods = getExtendedMethods(namespace, 'instance');\n      getExtendedMethods(namespace, 'instance').forEach(function(method) {\n        var objectInstanceParam = {\n          name: 'instance',\n          type: getInstanceParamType(method, 'Object'),\n          required: true\n        };\n        method = clone(method);\n        method.params.unshift(objectInstanceParam);\n        if (method.signatures) {\n          method.signatures.forEach(function(signature) {\n            signature.unshift(objectInstanceParam);\n          });\n        }\n        methods.push(method);\n      });\n    }\n\n    methods = buildMethods(methods, namespace, 'extended');\n    return getInterfaceSource(namespace.name + 'Constructor', methods.join('\\n'));\n  }\n\n  function getExtendedInstanceInterface(namespace) {\n    var methods = buildMethods(getExtendedMethods(namespace, 'instance'), namespace, 'extended');\n    var generics = getGenericSource(getNamespaceBaseGenerics(namespace.name));\n    return getInterfaceSource(namespace.name, methods.join('\\n'), generics);\n  }\n\n  function getExtendedMethods(namespace, findType) {\n    return namespace.methods.filter(function(method) {\n      return method.type === findType;\n    });\n  }\n\n  function getSugarInterface(namespace, namespaces) {\n\n    var extendAlias = clone(namespace.methods.find(function(method) {\n      return method.name === 'extend';\n    }));\n    extendAlias.name = '';\n\n    var methods;\n    methods = [extendAlias].concat(namespace.methods);\n    methods = buildMethods(methods, namespace, 'standard');\n\n    namespaces = namespaces.filter(function(namespace) {\n      return !namespace.name.match(/^Sugar/) && namespace.name !== 'Range';\n    }).map(function(namespace) {\n      return namespace.name + ': ' + namespace.name + '.Constructor;';\n    });\n\n    var src = [methods.join('\\n'), namespaces.join('\\n')].join('\\n');\n    return getInterfaceSource(namespace.name, src);\n  }\n\n  function getSugarNamespaceInterface(namespace) {\n    methods = buildMethods(namespace.methods, namespace, 'namespace');\n    return getInterfaceSource(namespace.name, methods.join('\\n'));\n  }\n\n  function getRangeInterface(namespace) {\n    var methods = buildMethods(namespace.methods, namespace, 'extended');\n    return getInterfaceSource('Range', methods.join('\\n'));\n  }\n\n  function getLocaleInterface(namespaces) {\n    var namespace = namespaces.find(function(namespace) {\n      return namespace.name === 'Date';\n    });\n    var methods = buildMethods(getRawMethods(LOCALE_METHODS, 'Date'), namespace);\n    return getInterfaceSource('Locale', methods.join('\\n'));\n  }\n\n  function getInterfaceSource(interfaceName, src, generics, ext) {\n    if (!src) {\n      return '';\n    }\n    ext = ext ? ' extends ' + ext : '';\n    return [\n      'interface ' + interfaceName + (generics || '') + ext + ' {',\n        indent(src, 1),\n      '}'\n    ].join('\\n');\n  }\n\n  /* ------------ Types -------------- */\n\n  function getType(type, method) {\n    var generics = [];\n    switch (type) {\n      case 'Array':\n        type = 'T[]';\n        generics.push('T');\n        break;\n      case 'New Array':\n        type = 'U[]';\n        generics.push('T');\n        generics.push('U');\n        break;\n      case 'ArrayElement':\n        type = 'T';\n        generics.push('T');\n        break;\n      case 'Mixed':\n        type = 'T';\n        generics.push('T');\n        break;\n      case 'Property':\n        type = 'T';\n        generics.push('T');\n        break;\n      case 'NewArrayElement':\n        type = 'U';\n        generics.push('T');\n        generics.push('U');\n        break;\n      case 'NewProperty':\n        type = 'U';\n        generics.push('T');\n        generics.push('U');\n        break;\n      case 'RangeElement':\n        type = 'T';\n        generics.push('T');\n        break;\n      case 'String':\n      case 'Number':\n      case 'Boolean':\n        type = type.toLowerCase();\n        break;\n    }\n    if (method && generics) {\n      addMethodGenerics(method, generics);\n    }\n    return type;\n  }\n\n  function getRawType(nativeName) {\n    var type = nativeName;\n    if (type && type.match(/^(string|number|boolean)$/i)) {\n      type = type.toLowerCase();\n    } else if (type === 'Array') {\n      type = 'T[]';\n    }\n    return type;\n  }\n\n  /* ------------ Generics -------------- */\n\n  function getNamespaceBaseGenerics(namespaceName) {\n    var generics = [];\n    if (namespaceName === 'Array') {\n      generics.push('T');\n    }\n    return generics;\n  }\n\n  function getChainableBaseGenerics(namespaceName, wrappedGeneric, arrayGeneric) {\n    var generics = [wrappedGeneric || CHAINABLE_RAW_TYPE];\n    if (namespaceName === 'Array') {\n      generics.unshift(arrayGeneric || 'T');\n    }\n    return getGenericSource(generics);\n  }\n\n  function getChainableInstanceGenerics(namespaceName) {\n    return getChainableBaseGenerics(namespaceName, getType(namespaceName));\n  }\n\n  function getGenericSource(generic) {\n    if (generic instanceof Array) {\n      generic = getUniqueGenerics(generic).join(', ');\n    }\n    if (!generic) {\n      return '';\n    } else if (generic.charAt(0) !== '<') {\n      return '<' + generic + '>';\n    }\n    return generic;\n  }\n\n  function getUniqueGenerics(generics) {\n    var result = [];\n    generics.forEach(function(g) {\n      if (g === 'any' || result.indexOf(g) === -1) {\n        result.push(g);\n      }\n    });\n    return result;\n  }\n\n  function addMethodGenerics(method, generics) {\n    generics = generics || [];\n    if (typeof generics === 'string') {\n      generics = [generics];\n    }\n\n    // Initialize generics array\n    method.generics = method.generics || [];\n\n    generics.forEach(function(g) {\n      if (method.generics.indexOf(g) === -1) {\n        method.generics.push(g);\n      }\n    });\n  }\n\n  /* ------------ Methods -------------- */\n\n  function isTypeCheck(method) {\n    return method.name.match(TYPE_REG);\n  }\n\n  function getInstanceParamType(method, type) {\n    return isTypeCheck(method) ? 'any' : type;\n  }\n\n  function buildMethods(methods, namespace, mode) {\n    methods.sort(collateMethods);\n    methods = methods.map(function(method) {\n      return getMethod(method, namespace, mode);\n    });\n    return compact(methods);\n  }\n\n  function getParams(params, method, namespace, mode) {\n    var result = [];\n\n    function getFunctionSource(obj) {\n      var returns = getReturns(obj.returns, method, namespace, mode);\n      return '('+  getParams(obj.params, method, namespace, mode) +') => ' + returns;\n    }\n\n    (params || []).forEach(function(param, i) {\n      if (param.glob) {\n        for (var j = i - 1, p; j >= 0; j--) {\n          p = params[j];\n          if (p.name.match(/\\d$/)) {\n            result.splice(j, 1);\n          }\n        }\n        result.push('...args: any[]');\n      } else {\n        var src = param.name + (param.required ? '' : '?') + ': ';\n        if (param.params) {\n          src += getFunctionSource(param);\n        } else {\n          src += (param.type || '').split('|').map(function(type) {\n            type = getType(type, method) || 'undefined';\n            if (type.match(/Fn$/)) {\n              var callback = method.callbacks.find(function(callback) {\n                return callback.name === type;\n              });\n              if (param.type.indexOf('|') === -1) {\n                // If a callback is the ONLY type allowed for this parameter\n                // (no alternates), then it can be inlined directly into the\n                // definition, so do that here. Otherwise it needs to be moved\n                // out into a named type and referenced.\n                type = getFunctionSource(callback);\n              } else {\n                if (mode === 'extended') {\n                  // If we are in extended mode and referencing a callback interface,\n                  // then it needs to have its fully qualified namespace.\n                  type = ['sugarjs', namespace.name, type].join('.');\n                }\n                var generics = moduleCallbackGenerics[namespace.name + ':' + callback.name];\n                if (generics) {\n                  addMethodGenerics(method, generics);\n                  type += getGenericSource(generics);\n                }\n              }\n            } else if (type.match(/Options$/)) {\n              var optionsNamespace = optionInterfaceNamespaces[type];\n              var generics = moduleOptionsGenerics[namespace.name + ':' + type];\n              type += getGenericSource(generics);\n              addMethodGenerics(method, generics);\n              if (mode === 'extended') {\n                // If we are in extended mode and referencing an options inteface,\n                // then it needs to have its fully qualified namespace.\n                type = ['sugarjs', optionsNamespace, type].join('.');\n              } else if (optionsNamespace && optionsNamespace !== namespace.name) {\n                // Options interfaces can be referenced across namespaces, so\n                // qualify them when necessary.\n                type = [optionsNamespace, type].join('.');\n              }\n            } else if (mode === 'extended' && (type === 'Range' || type === 'Locale')) {\n              // Ranges exist inside the sugarjs module, so qualify them\n              // as well when beind referenced in extended mode.\n              type = ['sugarjs', type].join('.');\n            }\n            return type;\n          }).join('|');\n        }\n        result.push(src);\n      }\n    });\n    return result.join(', ');\n  }\n\n  function getReturns(returns, method, namespace, mode) {\n\n    function referencesExternal(src) {\n      return mode === 'extended' &&\n             (src === 'Range' || src === 'Locale');\n    }\n\n    function requiresTypeGuard() {\n      return isTypeCheck(method) &&\n             (mode === 'static' || mode === 'extended');\n    }\n\n    function getTypeGuard(type) {\n      if (type.match(/^String|Number|Boolean$/)) {\n        type = type.toLowerCase();\n      }\n      return 'instance is ' + type;\n    }\n\n    var src = getType(returns, method) || 'void', match;\n    if (src === 'SugarNamespace' && mode === 'constructor') {\n      src = 'Sugar' + namespace.name + 'Constructor';\n    } else if (src === 'SugarNamespace' && mode === 'namespace') {\n      src = 'this';\n    } else if (referencesExternal(src)) {\n      src = ['sugarjs', src].join('.');\n    } else if (mode === 'chainable') {\n      src = 'SugarDefaultChainable<' + src + '>';\n    } else if (requiresTypeGuard()) {\n      var type = method.name.replace(/^is/, '');\n      var generics = TYPE_GUARD_GENERICS[type];\n      if (generics) {\n        type += getGenericSource(generics);\n      }\n      src = getTypeGuard(type);\n    } else if ((match = src.match(/Array<(.+)>/))) {\n      src = 'Array<' + getReturns(match[1], method, namespace, mode) + '>';\n    }\n    return src;\n  }\n\n  function getMethod(method, namespace, mode) {\n\n    if (methodIsBlacklisted(namespace.name, method)) {\n      return;\n    }\n\n    if (method.raw) {\n      return method.raw;\n    }\n\n    function getSignature(signature, returns) {\n      var params = getParams(signature, method, namespace, mode);\n      var generics = getMethodGenerics();\n      return method.name + generics + '(' +  params + '): ' + returns + ';';\n    }\n\n    function getMethodGenerics() {\n      var generics = method.generics;\n      if (mode !== 'static' && method.type === 'instance' && namespace.name === 'Array') {\n        generics = generics.filter(function(g) {\n          return g !== 'T';\n        });\n      }\n      return getGenericSource(generics);\n    }\n\n    var returns = getReturns(method.returns, method, namespace, mode);\n\n    return [method.params].concat(method.signatures || []).map(function(signature) {\n      return getSignature(signature, returns);\n    }).join('\\n');\n\n  }\n\n  function getRawMethods(methods, module, nativeChainable) {\n    return (methods || []).map(function(src) {\n      var match = src.match(/(\\w+)(<.+>)?\\((.*)\\): (.+);$/);\n      var name = match[1];\n      var generic = match[2] || src.match(/\\bU\\b/) ? '<U>' : '';\n      var returns = match[4];\n      if (nativeChainable) {\n        returns = 'SugarDefaultChainable<' + returns + '>';\n      }\n      var raw = name + generic + '(' + match[3] + '): '+ returns + ';';\n      return {\n        raw: raw,\n        name: name,\n        module: module,\n        native: nativeChainable\n      }\n    });\n  }\n\n  /* ------------ Sorting -------------- */\n\n  function collateNamespaces(a, b) {\n    if (a.name === 'Sugar') {\n      return -1;\n    } else if (b.name === 'Sugar') {\n      return 1;\n    }\n    return 0;\n  }\n\n  function collateMethods(a, b) {\n    var aVal = getMethodCollateValue(a);\n    var bVal = getMethodCollateValue(b);\n    return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;\n  }\n\n  function getMethodCollateValue(method) {\n    return getMethodRankForType(method) + method.name;\n  }\n\n  function getMethodRankForType(method) {\n    switch (method.type) {\n      case 'constructor': return 0;\n      case 'namespace':   return 1;\n      case 'static':      return 2;\n      case 'instance':    return 3;\n      case 'accessor':    return 4;\n      default:            return 5;\n    }\n  }\n\n  /* ------------ Util -------------- */\n\n  function indent(str, level) {\n    return str.replace(/^(?=.)/gm, '  '.repeat(level));\n  }\n\n  function clone(src) {\n    var target = src instanceof Array ? [] : {};\n    for (var key in src) {\n      if(src.hasOwnProperty(key)) {\n        var val = src[key];\n        if (val && typeof val === 'object') {\n          val = clone(val);\n        }\n        target[key] = val;\n      }\n    };\n    return target;\n  }\n\n  // Expands method sets and merges declaration supplements.\n  function unpackMethodSets(methods) {\n    var result = [];\n\n    methods.forEach(function(method) {\n      if (method.set) {\n        method.set.forEach(function(name) {\n          var setMethod = clone(method);\n          setMethod.name = name;\n          result.push(setMethod);\n        });\n      } else {\n        result.push(method);\n      }\n    });\n    return result;\n  }\n\n  /* ------------ Options -------------- */\n\n  function getMethodList(obj) {\n    var arr = obj && typeof obj === 'string' ? [obj] : obj, list;\n    if (arr) {\n      list = {};\n      arr.forEach(function(item) {\n        list[item.toLowerCase()] = true;\n      });\n    }\n    return list;\n  }\n\n  function methodIsBlacklisted(namespaceName, method) {\n    var key;\n\n    // Normalize\n    namespaceName = namespaceName.toLowerCase();\n    moduleName    = method.module.toLowerCase();\n    methodName    = method.name.toLowerCase();\n\n    key = namespaceName + ':' + methodName;\n\n    if (namespaceName && namespaceName.match(/^sugar/) || method.native) {\n      // Core methods are always output\n      return false;\n    }\n    if (moduleIsBlacklisted(moduleName)) {\n      return true;\n    }\n    if (whitelist && !whitelist[namespaceName] && !whitelist[key]) {\n      return true;\n    }\n    if (blacklist && (blacklist[namespaceName] || blacklist[key])) {\n      return true;\n    }\n    return false;\n  }\n\n  function moduleIsBlacklisted(moduleName) {\n    if (allowedModules === 'all') {\n      return false;\n    } else if (allowedModules === 'none') {\n      return true;\n    }\n    return !allowedModules.some(function(name) {\n      return name.toLowerCase() === moduleName.toLowerCase();\n    });\n  }\n\n  /* ------------ Exporting -------------- */\n\n  function exportDeclarations() {\n\n    var docs = getJSONDocs();\n    var sugarjs = getDeclaredNamespace('sugarjs');\n\n    var extendedInterfaces = [], nativeNames = [];\n\n    function getNamespaceTypesMerged(num, suffixVal, join, supplementary) {\n      var types = nativeNames.concat(supplementary || []);\n      var indent = ' '.repeat(num);\n      return types.map(function(type) {\n        var suffix = typeof suffixVal === 'function' ? suffixVal(type) : suffixVal;\n        return type + suffix;\n      }).join(' ' + join + '\\n' + indent);\n    }\n\n    function getChainableNameExternal(type) {\n      return '.Chainable' + getChainableBaseGenerics(type, CHAINABLE_RAW_TYPE, 'any');\n    }\n\n    function writeDeclarations(filename, declarations) {\n      declarations = compact(declarations);\n      var hasNoDeclarations = declarations.every(function(dec) {\n        return /^\\/\\//.test(dec);\n      });\n      if (hasNoDeclarations) {\n        return;\n      }\n      writeFile(path.join(basePath || '', filename), compact(declarations).join('\\n\\n'));\n    }\n\n    sugarjs.interfaces.push(getLocaleInterface(docs.namespaces));\n\n    // Sort namespaces for Sugar to come before SugarNamespace\n    // as it has ExtendOptions which are defined first.\n    docs.namespaces.sort(collateNamespaces);\n\n    docs.namespaces.forEach(function(namespace) {\n\n      function addExtras(module) {\n        addCallbackTypes(module);\n        addOptionsInterfaces(module);\n      }\n\n      function addCallbackTypes(module) {\n\n        // If the param has multiple types, then move callbacks into the\n        // module as named types. Only do this if there are multiple\n        // types, otherwise the callback signature can be inlined into\n        // the method declaration.\n        function getAlternateTypes(method) {\n          var types = [];\n\n          function process(arr) {\n            if (arr) {\n              arr.forEach(function(obj) {\n                if (obj.type) {\n                  var split = obj.type.split('|');\n                  if (split.length > 1) {\n                    types = types.concat(split);\n                  }\n                }\n              });\n            }\n          }\n\n          process(method.params);\n          process(method.options);\n\n          return types;\n        }\n\n        function addModuleCallbackType(method, callback) {\n          var typeExists = module.types.some(function(t) {\n            return t.name === callback.name;\n          });\n          if (!typeExists) {\n            var signature = getCallbackSignature(callback, method, namespace);\n            if (method.generics) {\n              moduleCallbackGenerics[namespace.name + ':' + callback.name] = method.generics;\n            }\n            module.types.push({\n              name: callback.name,\n              generics: getGenericSource(callback.generics),\n              type: signature\n            });\n          }\n        }\n\n        namespace.methods.forEach(function(method) {\n          if (!method.callbacks || methodIsBlacklisted(namespace.name, method)) {\n            return;\n          }\n          getAlternateTypes(method).forEach(function(type) {\n            if (type.match(/Fn$/)) {\n              var callback = findMethodCallbackByName(method, type);\n              addModuleCallbackType(method, callback);\n            }\n          });\n        });\n\n      }\n\n      function addOptionsInterfaces(module) {\n        namespace.methods.forEach(function(method) {\n          if (!method.options || methodIsBlacklisted(namespace.name, method)) {\n            return;\n          }\n\n          var params = method.params;\n          (method.signatures || []).forEach(function(signature) {\n            params = params.concat(signature);\n          })\n\n          var optionsParam = params.find(function(param) {\n            return param.type.match(/Options$/);\n          });\n\n          var optionsGenerics = [];\n\n          var src = method.options.map(function(option) {\n            var types = option.type.split('|');\n            types = types.map(function(type) {\n              if (type.match(/Fn$/)) {\n                var callback = findMethodCallbackByName(method, type);\n                if (types.length === 1 && type.match(/Fn$/)) {\n                  // Inline a callback delcaration\n                  type = getCallbackSignature(callback, method, namespace);\n                } else {\n                  // Refer to callback externally\n                  type += getGenericSource(moduleCallbackGenerics[namespace.name + ':' + callback.name]);\n                }\n                optionsGenerics = optionsGenerics.concat(callback.generics);\n              }\n              return type;\n            });\n            return option.name + (option.required ? '' : '?') + ': ' + types.join('|') + ';';\n          }).join('\\n');\n\n          // Store references to the namespaces that option interfaces exist in\n          // so that we can reference them externally later.\n          if (!namespace.name.match(/^Sugar/)) {\n            optionInterfaceNamespaces[optionsParam.type] = namespace.name;\n          }\n\n          moduleOptionsGenerics[namespace.name + ':' + optionsParam.type] = optionsGenerics;\n          var name = optionsParam.type + getGenericSource(optionsGenerics);\n          module.interfaces.push(getInterfaceSource(name, src));\n        });\n      }\n\n      function getCallbackSignature(callback, method, namespace) {\n        var genericsLength = method.generic && method.generics.length || 0, gen;\n        var params = getParams(callback.params, method, namespace);\n        var returns = callback.returns ? getType(callback.returns, method) : 'void';\n        // Slightly convoluted way of getting generics for the callback by\n        // subtracting method generics from what they were previously.\n        callback.generics = method.generics.slice(genericsLength);\n        return '(' + params + ') => ' + returns;\n      }\n\n      function findMethodCallbackByName(method, name) {\n        return method.callbacks.find(function(callback) {\n          return callback.name === name;\n        });\n      }\n\n\n      // Exclude polyfills\n      namespace.methods = namespace.methods.filter(function(method) {\n        return !method.module.match(/ES[5-7]/);\n      });\n\n      // Unpack sets like \"[unit]FromNow\"\n      namespace.methods = unpackMethodSets(namespace.methods);\n\n      if (namespace.name === 'Sugar') {\n        addExtras(sugarjs);\n        sugarjs.interfaces.push(getSugarInterface(namespace, docs.namespaces));\n      } else if (namespace.name === 'SugarNamespace') {\n        // The generic \"SugarNamespace\" interface is required for the\n        // \"createNamespace\" method that needs to return an as-yet undefined\n        // type. For existing namespaces, the methods here will instead be\n        // mixed into each individual interface. This is required, as each\n        // namespace returns a reference to itself, and so (it would appear)\n        // cannot use extend.\n        addExtras(sugarjs);\n        sugarjs.interfaces.push(getSugarNamespaceInterface(namespace));\n      } else if (namespace.name === 'Range') {\n        sugarjs.interfaces.push(getRangeInterface(namespace));\n      } else {\n        var module = getDeclaredNamespace(namespace.name);\n        addExtras(module);\n        module.interfaces.push(getConstructorInterface(namespace, module));\n        module.interfaces.push(getChainableBaseInterface(namespace));\n\n\n        // Export extended interfaces unless opting out.\n        if (args['extended-mode'] !== false) {\n          extendedInterfaces.push(getExtendedConstructorInterface(namespace));\n\n          // Note: due to Typescript quirkiness about incompatible interfaces,\n          // Object.prototype mode cannot be supported here for now.\n          if (namespace.name !== 'Object') {\n            extendedInterfaces.push(getExtendedInstanceInterface(namespace));\n          }\n        }\n\n        sugarjs.namespaces.push(getDeclaredNamespaceSource(module));\n        nativeNames.push(namespace.name);\n      }\n\n    });\n\n    var wrappedGeneric = getGenericSource(CHAINABLE_RAW_TYPE);\n    sugarjs.types.push({\n      name: 'SugarDefaultChainable' + wrappedGeneric,\n      type: getNamespaceTypesMerged(39, getChainableNameExternal, '&'),\n    });\n\n    sugarjs.types.push({\n      name: 'NativeConstructor',\n      type: getNamespaceTypesMerged(25, 'Constructor', '|', ['Boolean', 'Error']),\n    });\n\n\n    var baseDeclarations = [];\n    baseDeclarations.push(TS_LICENSE);\n    baseDeclarations.push(getDeclaredNamespaceSource(sugarjs, true));\n    baseDeclarations.push(getDeclaredModuleSource());\n    baseDeclarations.push('declare var Sugar: sugarjs.Sugar;');\n\n    var extendedDeclarations = [];\n    extendedDeclarations.push(TS_EXTENDED_LICENSE);\n    extendedDeclarations.push('/// <reference path=\"sugar.d.ts\" />');\n    extendedDeclarations.push(getInterfaceBlocks(extendedInterfaces));\n\n    writeDeclarations('sugar.d.ts', baseDeclarations);\n    writeDeclarations('sugar-extended.d.ts', extendedDeclarations);\n  }\n\n  exportDeclarations();\n}\n\n// -------------- Tests ----------------\n\nfunction testWatch(runTests, rebuildDist, rebuildMod) {\n\n  function attemptTestRun() {\n    try {\n      runTests();\n    } catch (e) {\n      warn(e.stack, true);\n    }\n  }\n  args.skipBuildResults = true;\n\n  gulp.watch(['lib/**/*.js'], function() {\n    var stream = getEmptyStream();\n    notify('Rebuilding');\n    if (rebuildDist) {\n      addStream(stream, buildDevelopment());\n    }\n    if (rebuildMod) {\n      addStream(stream, buildPackages('modular', true));\n    }\n    onStreamEnd(stream, function() {\n      attemptTestRun();\n      notify('Waiting');\n    });\n  });\n\n  gulp.watch(['test/**/*.js'], function() {\n    notify('Reloading tests');\n    attemptTestRun();\n    notify('Waiting');\n  });\n\n  setTimeout(function() {\n    notify('Waiting');\n  });\n\n}\n\nfunction testRunDefault() {\n  var path = './test/node';\n  if (args.test) {\n    path += '/' + args.test;\n  }\n  notify('Running tests');\n  require(path);\n}\n\nfunction testRunNpm() {\n  notify('Running npm tests');\n  require('./test/node/npm');\n}\n\nfunction testRunAll() {\n  notify('Running all tests');\n  require('./test/node/all');\n}\n\nfunction testWatchDefault() {\n  testWatch(testRunDefault, true);\n}\n\nfunction testWatchNpm() {\n  testWatch(testRunNpm, false, true);\n}\n\nfunction testWatchAll() {\n  testWatch(testRunAll, true, true);\n}\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.228515625,
          "content": "{\n  \"name\": \"sugar\",\n  \"description\": \"A Javascript utility library for working with native objects.\",\n  \"homepage\": \"https://sugarjs.com/\",\n  \"icon\": \"https://sugarjs.com/icon.svg\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/andrewplummer/Sugar.git\"\n  },\n  \"license\": \"MIT\",\n  \"author\": \"Andrew Plummer <plummer.andrew@gmail.com>\",\n  \"keywords\": [\n    \"sugar\",\n    \"sugarjs\",\n    \"functional\",\n    \"browser\",\n    \"utility\",\n    \"util\"\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/andrewplummer/Sugar/issues\"\n  },\n  \"engines\": {\n    \"node\": \">= 0.8.23\"\n  },\n  \"browser\": {\n    \"buffer\": false\n  },\n  \"scripts\": {\n    \"test\": \"istanbul cover test/node --report=lcovonly\",\n    \"coveralls\": \"cat ./coverage/lcov.info | ./node_modules/.bin/coveralls\"\n  },\n  \"typings\": \"sugar.d.ts\",\n  \"devDependencies\": {\n    \"acorn\": \"^2.7.0\",\n    \"closure-compiler-stream\": \"^0.1.15\",\n    \"coveralls\": \"^2.11.15\",\n    \"glob\": \"^5.0.14\",\n    \"google-closure-compiler\": \"^20180716.0.1\",\n    \"gulp\": \"^3.9.0\",\n    \"gulp-file\": \"^0.3.0\",\n    \"gulp-util\": \"^3.0.6\",\n    \"istanbul\": \"^0.4.5\",\n    \"merge-stream\": \"^0.1.8\",\n    \"mkdirp\": \"^0.5.1\",\n    \"rimraf\": \"^2.4.4\",\n    \"sinon\": \"^1.15.4\",\n    \"through2\": \"^2.0.0\",\n    \"yargs\": \"^3.15.0\"\n  }\n}\n"
        },
        {
          "name": "sugar-extended.d.ts",
          "type": "blob",
          "size": 21.005859375,
          "content": "// Extended type definitions for Sugar edge\n// Project: https://sugarjs.com/\n// Definitions by: Andrew Plummer <plummer.andrew@gmail.com>\n\n/// <reference path=\"sugar.d.ts\" />\n\ninterface ArrayConstructor {\n  construct<T>(n: number, indexMapFn: (i: number) => T): T[];\n  create<T>(obj?: number|ArrayLike<T>, clone?: boolean): T[];\n}\n\ninterface Array<T> {\n  add(item: T|T[], index?: number): T[];\n  append(item: T|T[], index?: number): T[];\n  at(index: number|number[], loop?: boolean): T;\n  average<U>(map?: string|sugarjs.Array.mapFn<T, U>): number;\n  clone(): T[];\n  compact(all?: boolean): T[];\n  count(search: T|sugarjs.Array.searchFn<T>, context?: any): number;\n  every(search: T|sugarjs.Array.searchFn<T>, context?: any): boolean;\n  everyFromIndex(startIndex: number, loop?: boolean, ...args: any[]): T;\n  everyFromIndex(startIndex: number, ...args: any[]): T;\n  exclude(search: T|sugarjs.Array.searchFn<T>): T[];\n  filter(search: T|sugarjs.Array.searchFn<T>, context?: any): T[];\n  filterFromIndex(startIndex: number, loop?: boolean, ...args: any[]): T;\n  filterFromIndex(startIndex: number, ...args: any[]): T;\n  find(search: T|sugarjs.Array.searchFn<T>, context?: any): T;\n  findFromIndex(startIndex: number, loop?: boolean, ...args: any[]): T;\n  findFromIndex(startIndex: number, ...args: any[]): T;\n  findIndex(search: T|sugarjs.Array.searchFn<T>, context?: any): number;\n  findIndexFromIndex(startIndex: number, loop?: boolean, ...args: any[]): T;\n  findIndexFromIndex(startIndex: number, ...args: any[]): T;\n  first(num?: number): T;\n  flatten(limit?: number): T[];\n  forEachFromIndex(startIndex: number, loop?: boolean, ...args: any[]): T;\n  forEachFromIndex(startIndex: number, ...args: any[]): T;\n  from(index: number): T[];\n  groupBy<U>(map: string|sugarjs.Array.mapFn<T, U>, groupFn?: (arr: T[], key: string, obj: Object) => void): Object;\n  inGroups(num: number, padding?: any): T[];\n  inGroupsOf(num: number, padding?: any): T[];\n  insert(item: T|T[], index?: number): T[];\n  intersect(arr: T[]): T[];\n  isEmpty(): boolean;\n  isEqual(arr: T[]): boolean;\n  last(num?: number): T;\n  least<U>(all?: boolean, map?: string|sugarjs.Array.mapFn<T, U>): T[];\n  least<U>(map?: string|sugarjs.Array.mapFn<T, U>): T[];\n  map<U>(map: string|sugarjs.Array.mapFn<T, U>, context?: any): U[];\n  mapFromIndex(startIndex: number, loop?: boolean, ...args: any[]): T;\n  mapFromIndex(startIndex: number, ...args: any[]): T;\n  max<U>(all?: boolean, map?: string|sugarjs.Array.mapFn<T, U>): T;\n  max<U>(map?: string|sugarjs.Array.mapFn<T, U>): T;\n  median<U>(map?: string|sugarjs.Array.mapFn<T, U>): number;\n  min<U>(all?: boolean, map?: string|sugarjs.Array.mapFn<T, U>): T;\n  min<U>(map?: string|sugarjs.Array.mapFn<T, U>): T;\n  most<U>(all?: boolean, map?: string|sugarjs.Array.mapFn<T, U>): T[];\n  most<U>(map?: string|sugarjs.Array.mapFn<T, U>): T[];\n  none(search: T|sugarjs.Array.searchFn<T>, context?: any): boolean;\n  reduceFromIndex(startIndex: number, loop?: boolean, ...args: any[]): T;\n  reduceFromIndex(startIndex: number, ...args: any[]): T;\n  reduceRightFromIndex(startIndex: number, loop?: boolean, ...args: any[]): T;\n  reduceRightFromIndex(startIndex: number, ...args: any[]): T;\n  remove(search: T|sugarjs.Array.searchFn<T>): T[];\n  removeAt(start: number, end?: number): T[];\n  sample(num?: number, remove?: boolean): T;\n  shuffle(): T[];\n  some(search: T|sugarjs.Array.searchFn<T>, context?: any): boolean;\n  someFromIndex(startIndex: number, loop?: boolean, ...args: any[]): T;\n  someFromIndex(startIndex: number, ...args: any[]): T;\n  sortBy<U>(map?: string|sugarjs.Array.sortMapFn<T, U>, desc?: boolean): T[];\n  subtract(item: T|T[]): T[];\n  sum<U>(map?: string|sugarjs.Array.mapFn<T, U>): number;\n  to(index: number): T[];\n  union(arr: T[]): T[];\n  unique<U>(map?: string|sugarjs.Array.mapFn<T, U>): T[];\n  zip(...args: any[]): T[];\n}\n\ninterface DateConstructor {\n  addLocale(localeCode: string, def: Object): sugarjs.Locale;\n  create(d?: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  getAllLocaleCodes(): string[];\n  getAllLocales(): Array<sugarjs.Locale>;\n  getLocale(localeCode?: string): sugarjs.Locale;\n  range(start?: string|Date, end?: string|Date): sugarjs.Range;\n  removeLocale(localeCode: string): sugarjs.Locale;\n  setLocale(localeCode: string): sugarjs.Locale;\n}\n\ninterface Date {\n  addDays(n: number, reset?: boolean): Date;\n  addHours(n: number, reset?: boolean): Date;\n  addMilliseconds(n: number, reset?: boolean): Date;\n  addMinutes(n: number, reset?: boolean): Date;\n  addMonths(n: number, reset?: boolean): Date;\n  addSeconds(n: number, reset?: boolean): Date;\n  addWeeks(n: number, reset?: boolean): Date;\n  addYears(n: number, reset?: boolean): Date;\n  advance(set: string|Object, reset?: boolean): Date;\n  advance(milliseconds: number): Date;\n  advance(year: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millliseconds?: undefined): Date;\n  beginningOfDay(localeCode?: string): Date;\n  beginningOfISOWeek(): Date;\n  beginningOfMonth(localeCode?: string): Date;\n  beginningOfWeek(localeCode?: string): Date;\n  beginningOfYear(localeCode?: string): Date;\n  clone(): Date;\n  daysAgo(): number;\n  daysFromNow(): number;\n  daysInMonth(): number;\n  daysSince(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  daysUntil(d?: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  endOfDay(localeCode?: string): Date;\n  endOfISOWeek(): Date;\n  endOfMonth(localeCode?: string): Date;\n  endOfWeek(localeCode?: string): Date;\n  endOfYear(localeCode?: string): Date;\n  format(f?: string, localeCode?: string): string;\n  full(localeCode?: string): string;\n  get(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  getISOWeek(): number;\n  getUTCOffset(iso?: boolean): string;\n  getUTCWeekday(): number;\n  getWeekday(): number;\n  hoursAgo(): number;\n  hoursFromNow(): number;\n  hoursSince(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  hoursUntil(d?: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  is(d: string|number|Date, margin?: number): boolean;\n  isAfter(d: string|number|Date, margin?: number): boolean;\n  isBefore(d: string|number|Date, margin?: number): boolean;\n  isBetween(d1: string|number|Date, d2: string|number|Date, margin?: number): boolean;\n  isFriday(): boolean;\n  isFuture(): boolean;\n  isLastMonth(localeCode?: string): boolean;\n  isLastWeek(localeCode?: string): boolean;\n  isLastYear(localeCode?: string): boolean;\n  isLeapYear(): boolean;\n  isMonday(): boolean;\n  isNextMonth(localeCode?: string): boolean;\n  isNextWeek(localeCode?: string): boolean;\n  isNextYear(localeCode?: string): boolean;\n  isPast(): boolean;\n  isSaturday(): boolean;\n  isSunday(): boolean;\n  isThisMonth(localeCode?: string): boolean;\n  isThisWeek(localeCode?: string): boolean;\n  isThisYear(localeCode?: string): boolean;\n  isThursday(): boolean;\n  isToday(): boolean;\n  isTomorrow(): boolean;\n  isTuesday(): boolean;\n  isUTC(): boolean;\n  isValid(): boolean;\n  isWednesday(): boolean;\n  isWeekday(): boolean;\n  isWeekend(): boolean;\n  isYesterday(): boolean;\n  iso(): string;\n  long(localeCode?: string): string;\n  medium(localeCode?: string): string;\n  millisecondsAgo(): number;\n  millisecondsFromNow(): number;\n  millisecondsSince(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  millisecondsUntil(d?: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  minutesAgo(): number;\n  minutesFromNow(): number;\n  minutesSince(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  minutesUntil(d?: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  monthsAgo(): number;\n  monthsFromNow(): number;\n  monthsSince(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  monthsUntil(d?: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  relative(localeCode?: string, relativeFn?: (num: number, unit: number, ms: number, loc: sugarjs.Locale) => string): string;\n  relative(relativeFn?: (num: number, unit: number, ms: number, loc: sugarjs.Locale) => string): string;\n  relativeTo(d: string|number|Date, localeCode?: string): string;\n  reset(unit?: string, localeCode?: string): Date;\n  rewind(set: string|Object, reset?: boolean): Date;\n  rewind(milliseconds: number): Date;\n  rewind(year: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millliseconds?: undefined): Date;\n  secondsAgo(): number;\n  secondsFromNow(): number;\n  secondsSince(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  secondsUntil(d?: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  set(set: Object, reset?: boolean): Date;\n  set(milliseconds: number): Date;\n  set(year: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millliseconds?: undefined): Date;\n  setISOWeek(num: number): void;\n  setUTC(on?: boolean): Date;\n  setWeekday(dow: number): void;\n  short(localeCode?: string): string;\n  weeksAgo(): number;\n  weeksFromNow(): number;\n  weeksSince(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  weeksUntil(d?: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  yearsAgo(): number;\n  yearsFromNow(): number;\n  yearsSince(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n  yearsUntil(d?: string|number|Date, options?: sugarjs.Date.DateCreateOptions): number;\n}\n\ninterface Function {\n  after(n: number): Function;\n  cancel(): Function;\n  debounce(ms?: number): Function;\n  delay(ms?: number, ...args: any[]): Function;\n  every(ms?: number, ...args: any[]): Function;\n  lazy(ms?: number, immediate?: boolean, limit?: number): Function;\n  lock(n?: number): Function;\n  memoize(hashFn?: string|Function, limit?: number): Function;\n  once(): Function;\n  partial(...args: any[]): Function;\n  throttle(ms?: number): Function;\n}\n\ninterface NumberConstructor {\n  random(n1?: number, n2?: number): number;\n  range(start?: number, end?: number): sugarjs.Range;\n}\n\ninterface Number {\n  abbr(precision?: number): string;\n  abs(): number;\n  acos(): number;\n  asin(): number;\n  atan(): number;\n  bytes(precision?: number, binary?: boolean, units?: string): string;\n  cap(max?: number): number;\n  ceil(precision?: number): number;\n  chr(): string;\n  clamp(start?: number, end?: number): number;\n  cos(): number;\n  day(): number;\n  dayAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  dayAgo(): Date;\n  dayBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  dayFromNow(): Date;\n  days(): number;\n  daysAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  daysAgo(): Date;\n  daysBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  daysFromNow(): Date;\n  downto<T>(num: number, step?: number, everyFn?: (el: T, i: number, r: sugarjs.Range) => void): T[];\n  downto<T>(num: number, everyFn?: (el: T, i: number, r: sugarjs.Range) => void): T[];\n  duration(localeCode?: string): string;\n  exp(): number;\n  floor(precision?: number): number;\n  format(place?: number): string;\n  hex(pad?: number): string;\n  hour(): number;\n  hourAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  hourAgo(): Date;\n  hourBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  hourFromNow(): Date;\n  hours(): number;\n  hoursAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  hoursAgo(): Date;\n  hoursBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  hoursFromNow(): Date;\n  isEven(): boolean;\n  isInteger(): boolean;\n  isMultipleOf(num: number): boolean;\n  isOdd(): boolean;\n  log(base?: number): number;\n  metric(precision?: number, units?: string): string;\n  millisecond(): number;\n  millisecondAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  millisecondAgo(): Date;\n  millisecondBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  millisecondFromNow(): Date;\n  milliseconds(): number;\n  millisecondsAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  millisecondsAgo(): Date;\n  millisecondsBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  millisecondsFromNow(): Date;\n  minute(): number;\n  minuteAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  minuteAgo(): Date;\n  minuteBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  minuteFromNow(): Date;\n  minutes(): number;\n  minutesAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  minutesAgo(): Date;\n  minutesBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  minutesFromNow(): Date;\n  month(): number;\n  monthAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  monthAgo(): Date;\n  monthBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  monthFromNow(): Date;\n  months(): number;\n  monthsAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  monthsAgo(): Date;\n  monthsBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  monthsFromNow(): Date;\n  ordinalize(): string;\n  pad(place?: number, sign?: boolean, base?: number): string;\n  pow(): number;\n  round(precision?: number): number;\n  second(): number;\n  secondAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  secondAgo(): Date;\n  secondBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  secondFromNow(): Date;\n  seconds(): number;\n  secondsAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  secondsAgo(): Date;\n  secondsBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  secondsFromNow(): Date;\n  sin(): number;\n  sqrt(): number;\n  tan(): number;\n  times<T>(indexMapFn: (i: number) => any): T;\n  toNumber(): number;\n  upto<T>(num: number, step?: number, everyFn?: (el: T, i: number, r: sugarjs.Range) => void): T[];\n  upto<T>(num: number, everyFn?: (el: T, i: number, r: sugarjs.Range) => void): T[];\n  week(): number;\n  weekAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  weekAgo(): Date;\n  weekBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  weekFromNow(): Date;\n  weeks(): number;\n  weeksAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  weeksAgo(): Date;\n  weeksBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  weeksFromNow(): Date;\n  year(): number;\n  yearAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  yearAgo(): Date;\n  yearBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  yearFromNow(): Date;\n  years(): number;\n  yearsAfter(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  yearsAgo(): Date;\n  yearsBefore(d: string|number|Date, options?: sugarjs.Date.DateCreateOptions): Date;\n  yearsFromNow(): Date;\n}\n\ninterface ObjectConstructor {\n  fromQueryString<T, U>(str: string, options?: sugarjs.Object.QueryStringParseOptions<T, U>): Object;\n  add<T>(instance: Object, obj: Object, options?: sugarjs.Object.ObjectMergeOptions<T>): Object;\n  addAll<T>(instance: Object, sources: Array<Object>, options?: sugarjs.Object.ObjectMergeOptions<T>): Object;\n  average<T, U>(instance: Object, map?: string|sugarjs.Object.mapFn<T, U>): number;\n  clone(instance: Object, deep?: boolean): Object;\n  count<T>(instance: Object, search: T|sugarjs.Object.searchFn<T>): number;\n  defaults<T>(instance: Object, sources: Array<Object>, options?: sugarjs.Object.ObjectMergeOptions<T>): Object;\n  every<T>(instance: Object, search: T|sugarjs.Object.searchFn<T>): boolean;\n  exclude<T>(instance: Object, search: T|sugarjs.Object.searchFn<T>): Object;\n  filter<T>(instance: Object, search: T|sugarjs.Object.searchFn<T>): T[];\n  find<T>(instance: Object, search: T|sugarjs.Object.searchFn<T>): boolean;\n  forEach<T>(instance: Object, eachFn: (val: T, key: string, obj: Object) => void): Object;\n  get<T>(instance: Object, key: string, inherited?: boolean): T;\n  has(instance: Object, key: string, inherited?: boolean): boolean;\n  intersect(instance: Object, obj: Object): Object;\n  invert(instance: Object, multi?: boolean): Object;\n  isArguments(instance: Object): boolean;\n  isArray(instance: any): instance is Array<any>;\n  isBoolean(instance: any): instance is boolean;\n  isDate(instance: any): instance is Date;\n  isEmpty(instance: Object): boolean;\n  isEqual(instance: Object, obj: Object): boolean;\n  isError(instance: any): instance is Error;\n  isFunction(instance: any): instance is Function;\n  isMap(instance: any): instance is Map<any, any>;\n  isNumber(instance: any): instance is number;\n  isObject(instance: Object): boolean;\n  isRegExp(instance: any): instance is RegExp;\n  isSet(instance: any): instance is Set<any>;\n  isString(instance: any): instance is string;\n  keys<T>(instance: Object): T[];\n  least<T, U>(instance: Object, all?: boolean, map?: string|sugarjs.Object.mapFn<T, U>): T;\n  least<T, U>(instance: Object, map?: string|sugarjs.Object.mapFn<T, U>): T;\n  map<T, U>(instance: Object, map: string|sugarjs.Object.mapFn<T, U>): Object;\n  max<T, U>(instance: Object, all?: boolean, map?: string|sugarjs.Object.mapFn<T, U>): T;\n  max<T, U>(instance: Object, map?: string|sugarjs.Object.mapFn<T, U>): T;\n  median<T, U>(instance: Object, map?: string|sugarjs.Object.mapFn<T, U>): number;\n  merge<T>(instance: Object, source: Object, options?: sugarjs.Object.ObjectMergeOptions<T>): Object;\n  mergeAll<T>(instance: Object, sources: Array<Object>, options?: sugarjs.Object.ObjectMergeOptions<T>): Object;\n  min<T, U>(instance: Object, all?: boolean, map?: string|sugarjs.Object.mapFn<T, U>): T;\n  min<T, U>(instance: Object, map?: string|sugarjs.Object.mapFn<T, U>): T;\n  most<T, U>(instance: Object, all?: boolean, map?: string|sugarjs.Object.mapFn<T, U>): T;\n  most<T, U>(instance: Object, map?: string|sugarjs.Object.mapFn<T, U>): T;\n  none<T>(instance: Object, search: T|sugarjs.Object.searchFn<T>): boolean;\n  reduce<T>(instance: Object, reduceFn: (acc: T, val: T, key: string, obj: Object) => void, init?: any): T;\n  reject(instance: Object, find: string|RegExp|Array<string>|Object): Object;\n  remove<T>(instance: Object, search: T|sugarjs.Object.searchFn<T>): Object;\n  select(instance: Object, find: string|RegExp|Array<string>|Object): Object;\n  set<T>(instance: Object, key: string, val: T): Object;\n  size(instance: Object): number;\n  some<T>(instance: Object, search: T|sugarjs.Object.searchFn<T>): boolean;\n  subtract(instance: Object, obj: Object): Object;\n  sum<T, U>(instance: Object, map?: string|sugarjs.Object.mapFn<T, U>): number;\n  tap(instance: Object, tapFn: (obj: Object) => any): Object;\n  toQueryString<T, U>(instance: Object, options?: sugarjs.Object.QueryStringOptions<T, U>): Object;\n  values<T>(instance: Object): T[];\n}\n\ninterface RegExpConstructor {\n  escape(str?: string): string;\n}\n\ninterface RegExp {\n  addFlags(flags: string): RegExp;\n  getFlags(): string;\n  removeFlags(flags: string): RegExp;\n  setFlags(flags: string): RegExp;\n}\n\ninterface StringConstructor {\n  range(start?: string, end?: string): sugarjs.Range;\n}\n\ninterface String {\n  at<T>(index: number|Array<number>, loop?: boolean): T;\n  camelize(upper?: boolean): string;\n  capitalize(lower?: boolean, all?: boolean): string;\n  chars<T>(eachCharFn?: (char: string, i: number, arr: Array<string>) => void): T[];\n  codes<T>(eachCodeFn?: (code: number, i: number, str: string) => void): T[];\n  compact(): string;\n  dasherize(): string;\n  decodeBase64(): string;\n  encodeBase64(): string;\n  escapeHTML(): string;\n  escapeURL(param?: boolean): string;\n  first(n?: number): string;\n  forEach<T>(search?: string|RegExp, eachFn?: (match: string, i: number, arr: Array<string>) => void): T[];\n  forEach<T>(eachFn: (match: string, i: number, arr: Array<string>) => void): T[];\n  format(...args: any[]): string;\n  from(index?: number): string;\n  insert(str: string, index?: number): string;\n  isBlank(): boolean;\n  isEmpty(): boolean;\n  last(n?: number): string;\n  lines<T>(eachLineFn?: (line: string, i: number, arr: Array<string>) => void): T[];\n  pad(num: number, padding?: string): string;\n  padLeft(num: number, padding?: string): string;\n  padRight(num: number, padding?: string): string;\n  parameterize(): string;\n  remove(f: string|RegExp): string;\n  removeAll(f: string|RegExp): string;\n  removeTags(tag?: string, replace?: string|sugarjs.String.replaceFn): string;\n  replaceAll(f: string|RegExp, ...args: any[]): string;\n  reverse(): string;\n  shift<T>(n: number): T[];\n  spacify(): string;\n  stripTags(tag?: string, replace?: string|sugarjs.String.replaceFn): string;\n  titleize(): string;\n  to(index?: number): string;\n  toNumber(base?: number): number;\n  trimLeft(): string;\n  trimRight(): string;\n  truncate(length: number, from?: string, ellipsis?: string): string;\n  truncateOnWord(length: number, from?: string, ellipsis?: string): string;\n  underscore(): string;\n  unescapeHTML(): string;\n  unescapeURL(partial?: boolean): string;\n  words<T>(eachWordFn?: (word: string, i: number, arr: Array<string>) => void): T[];\n}"
        },
        {
          "name": "sugar.d.ts",
          "type": "blob",
          "size": 72.3818359375,
          "content": "// Type definitions for Sugar edge\n// Project: https://sugarjs.com/\n// Definitions by: Andrew Plummer <plummer.andrew@gmail.com>\n\ndeclare namespace sugarjs {\n\n  type SugarDefaultChainable<RawValue> = Array.Chainable<any, RawValue> &\n                                         Date.Chainable<RawValue> &\n                                         Function.Chainable<RawValue> &\n                                         Number.Chainable<RawValue> &\n                                         Object.Chainable<RawValue> &\n                                         RegExp.Chainable<RawValue> &\n                                         String.Chainable<RawValue>;\n\n  type NativeConstructor = ArrayConstructor |\n                           DateConstructor |\n                           FunctionConstructor |\n                           NumberConstructor |\n                           ObjectConstructor |\n                           RegExpConstructor |\n                           StringConstructor |\n                           BooleanConstructor |\n                           ErrorConstructor;\n\n  interface Locale {\n    addFormat(src:string, to?: Array<string>): void;\n    getDuration(ms: number): string;\n    getFirstDayOfWeek(): number;\n    getFirstDayOfWeekYear(): number;\n    getMonthName(n: number): string;\n    getWeekdayName(n: number): string;\n  }\n\n  interface ExtendOptions {\n    methods?: Array<string>;\n    except?: Array<string|NativeConstructor>;\n    namespaces?: Array<NativeConstructor>;\n    enhance?: boolean;\n    enhanceString?: boolean;\n    enhanceArray?: boolean;\n    objectPrototype?: boolean;\n  }\n\n  interface Sugar {\n    (opts?: ExtendOptions): Sugar;\n    createNamespace(name: string): SugarNamespace;\n    extend(opts?: ExtendOptions): Sugar;\n    Array: Array.Constructor;\n    Date: Date.Constructor;\n    Function: Function.Constructor;\n    Number: Number.Constructor;\n    Object: Object.Constructor;\n    RegExp: RegExp.Constructor;\n    String: String.Constructor;\n  }\n\n  interface Range {\n    clamp<T>(el: T): T;\n    clone(): sugarjs.Range;\n    contains<T>(el: T): boolean;\n    days(): number;\n    every<T>(amount: string|number, everyFn?: (el: T, i: number, r: sugarjs.Range) => void): T[];\n    hours(): number;\n    intersect(range: sugarjs.Range): sugarjs.Range;\n    isValid(): boolean;\n    milliseconds(): number;\n    minutes(): number;\n    months(): number;\n    seconds(): number;\n    span(): number;\n    toArray<T>(): T[];\n    toString(): string;\n    union(range: sugarjs.Range): sugarjs.Range;\n    weeks(): number;\n    years(): number;\n  }\n\n  interface SugarNamespace {\n    alias(toName: string, from: string|Function): this;\n    alias(toName: string, fn: undefined): this;\n    defineInstance(methods: Object): this;\n    defineInstance(methodName: string, methodFn: Function): this;\n    defineInstanceAndStatic(methods: Object): this;\n    defineInstanceAndStatic(methodName: string, methodFn: Function): this;\n    defineInstancePolyfill(methods: Object): this;\n    defineInstancePolyfill(methodName: string, methodFn: Function): this;\n    defineInstanceWithArguments(methods: Object): this;\n    defineInstanceWithArguments(methodName: string, methodFn: Function): this;\n    defineStatic(methods: Object): this;\n    defineStatic(methodName: string, methodFn: Function): this;\n    defineStaticPolyfill(methods: Object): this;\n    defineStaticPolyfill(methodName: string, methodFn: Function): this;\n    defineStaticWithArguments(methods: Object): this;\n    defineStaticWithArguments(methodName: string, methodFn: Function): this;\n    extend(opts?: ExtendOptions): this;\n  }\n\n  namespace Array {\n\n    type mapFn<T, U> = (el: T, i: number, arr: T[]) => U;\n    type sortMapFn<T, U> = (el: T) => U;\n    type searchFn<T> = (el: T, i: number, arr: T[]) => boolean;\n    type Chainable<T, RawValue> = ChainableBase<T, RawValue> & Object.ChainableBase<RawValue>;\n\n    interface ArrayOptions {\n      sortIgnore?: RegExp;\n      sortIgnoreCase?: boolean;\n      sortNatural?: boolean;\n      sortOrder?: string;\n      sortEquivalents?: Object;\n      sortCollate?: Function;\n    }\n\n    interface Constructor extends SugarNamespace {\n      <T>(obj?: number|ArrayLike<T>, clone?: boolean): Chainable<T, T[]>;\n      new<T>(obj?: number|ArrayLike<T>, clone?: boolean): Chainable<T, T[]>;\n      construct<T>(n: number, indexMapFn: (i: number) => T): T[];\n      create<T>(obj?: number|ArrayLike<T>, clone?: boolean): T[];\n      add<T>(instance: T[], item: T|T[], index?: number): T[];\n      append<T>(instance: T[], item: T|T[], index?: number): T[];\n      at<T>(instance: T[], index: number|number[], loop?: boolean): T;\n      average<T, U>(instance: T[], map?: string|mapFn<T, U>): number;\n      clone<T>(instance: T[]): T[];\n      compact<T>(instance: T[], all?: boolean): T[];\n      count<T>(instance: T[], search: T|searchFn<T>, context?: any): number;\n      every<T>(instance: T[], search: T|searchFn<T>, context?: any): boolean;\n      everyFromIndex<T>(instance: T[], startIndex: number, loop?: boolean, ...args: any[]): T;\n      everyFromIndex<T>(instance: T[], startIndex: number, ...args: any[]): T;\n      exclude<T>(instance: T[], search: T|searchFn<T>): T[];\n      filter<T>(instance: T[], search: T|searchFn<T>, context?: any): T[];\n      filterFromIndex<T>(instance: T[], startIndex: number, loop?: boolean, ...args: any[]): T;\n      filterFromIndex<T>(instance: T[], startIndex: number, ...args: any[]): T;\n      find<T>(instance: T[], search: T|searchFn<T>, context?: any): T;\n      findFromIndex<T>(instance: T[], startIndex: number, loop?: boolean, ...args: any[]): T;\n      findFromIndex<T>(instance: T[], startIndex: number, ...args: any[]): T;\n      findIndex<T>(instance: T[], search: T|searchFn<T>, context?: any): number;\n      findIndexFromIndex<T>(instance: T[], startIndex: number, loop?: boolean, ...args: any[]): T;\n      findIndexFromIndex<T>(instance: T[], startIndex: number, ...args: any[]): T;\n      first<T>(instance: T[], num?: number): T;\n      flatten<T>(instance: T[], limit?: number): T[];\n      forEachFromIndex<T>(instance: T[], startIndex: number, loop?: boolean, ...args: any[]): T;\n      forEachFromIndex<T>(instance: T[], startIndex: number, ...args: any[]): T;\n      from<T>(instance: T[], index: number): T[];\n      groupBy<T, U>(instance: T[], map: string|mapFn<T, U>, groupFn?: (arr: T[], key: string, obj: Object) => void): Object;\n      inGroups<T>(instance: T[], num: number, padding?: any): T[];\n      inGroupsOf<T>(instance: T[], num: number, padding?: any): T[];\n      insert<T>(instance: T[], item: T|T[], index?: number): T[];\n      intersect<T>(instance: T[], arr: T[]): T[];\n      isEmpty<T>(instance: T[]): boolean;\n      isEqual<T>(instance: T[], arr: T[]): boolean;\n      last<T>(instance: T[], num?: number): T;\n      least<T, U>(instance: T[], all?: boolean, map?: string|mapFn<T, U>): T[];\n      least<T, U>(instance: T[], map?: string|mapFn<T, U>): T[];\n      map<T, U>(instance: T[], map: string|mapFn<T, U>, context?: any): U[];\n      mapFromIndex<T>(instance: T[], startIndex: number, loop?: boolean, ...args: any[]): T;\n      mapFromIndex<T>(instance: T[], startIndex: number, ...args: any[]): T;\n      max<T, U>(instance: T[], all?: boolean, map?: string|mapFn<T, U>): T;\n      max<T, U>(instance: T[], map?: string|mapFn<T, U>): T;\n      median<T, U>(instance: T[], map?: string|mapFn<T, U>): number;\n      min<T, U>(instance: T[], all?: boolean, map?: string|mapFn<T, U>): T;\n      min<T, U>(instance: T[], map?: string|mapFn<T, U>): T;\n      most<T, U>(instance: T[], all?: boolean, map?: string|mapFn<T, U>): T[];\n      most<T, U>(instance: T[], map?: string|mapFn<T, U>): T[];\n      none<T>(instance: T[], search: T|searchFn<T>, context?: any): boolean;\n      reduceFromIndex<T>(instance: T[], startIndex: number, loop?: boolean, ...args: any[]): T;\n      reduceFromIndex<T>(instance: T[], startIndex: number, ...args: any[]): T;\n      reduceRightFromIndex<T>(instance: T[], startIndex: number, loop?: boolean, ...args: any[]): T;\n      reduceRightFromIndex<T>(instance: T[], startIndex: number, ...args: any[]): T;\n      remove<T>(instance: T[], search: T|searchFn<T>): T[];\n      removeAt<T>(instance: T[], start: number, end?: number): T[];\n      sample<T>(instance: T[], num?: number, remove?: boolean): T;\n      shuffle<T>(instance: T[]): T[];\n      some<T>(instance: T[], search: T|searchFn<T>, context?: any): boolean;\n      someFromIndex<T>(instance: T[], startIndex: number, loop?: boolean, ...args: any[]): T;\n      someFromIndex<T>(instance: T[], startIndex: number, ...args: any[]): T;\n      sortBy<T, U>(instance: T[], map?: string|sortMapFn<T, U>, desc?: boolean): T[];\n      subtract<T>(instance: T[], item: T|T[]): T[];\n      sum<T, U>(instance: T[], map?: string|mapFn<T, U>): number;\n      to<T>(instance: T[], index: number): T[];\n      union<T>(instance: T[], arr: T[]): T[];\n      unique<T, U>(instance: T[], map?: string|mapFn<T, U>): T[];\n      zip<T>(instance: T[], ...args: any[]): T[];\n      getOption<T>(name: string): T;\n      setOption(name: string, value: any): void;\n      setOption(options: ArrayOptions): void;\n    }\n\n    interface ChainableBase<T, RawValue> {\n      raw: RawValue;\n      valueOf: () => RawValue;\n      toString: () => string;\n      add(item: T|T[], index?: number): SugarDefaultChainable<T[]>;\n      append(item: T|T[], index?: number): SugarDefaultChainable<T[]>;\n      at(index: number|number[], loop?: boolean): SugarDefaultChainable<T>;\n      average<U>(map?: string|mapFn<T, U>): SugarDefaultChainable<number>;\n      clone(): SugarDefaultChainable<T[]>;\n      compact(all?: boolean): SugarDefaultChainable<T[]>;\n      count(search: T|searchFn<T>, context?: any): SugarDefaultChainable<number>;\n      every(search: T|searchFn<T>, context?: any): SugarDefaultChainable<boolean>;\n      everyFromIndex(startIndex: number, loop?: boolean, ...args: any[]): SugarDefaultChainable<T>;\n      everyFromIndex(startIndex: number, ...args: any[]): SugarDefaultChainable<T>;\n      exclude(search: T|searchFn<T>): SugarDefaultChainable<T[]>;\n      filter(search: T|searchFn<T>, context?: any): SugarDefaultChainable<T[]>;\n      filterFromIndex(startIndex: number, loop?: boolean, ...args: any[]): SugarDefaultChainable<T>;\n      filterFromIndex(startIndex: number, ...args: any[]): SugarDefaultChainable<T>;\n      find(search: T|searchFn<T>, context?: any): SugarDefaultChainable<T>;\n      findFromIndex(startIndex: number, loop?: boolean, ...args: any[]): SugarDefaultChainable<T>;\n      findFromIndex(startIndex: number, ...args: any[]): SugarDefaultChainable<T>;\n      findIndex(search: T|searchFn<T>, context?: any): SugarDefaultChainable<number>;\n      findIndexFromIndex(startIndex: number, loop?: boolean, ...args: any[]): SugarDefaultChainable<T>;\n      findIndexFromIndex(startIndex: number, ...args: any[]): SugarDefaultChainable<T>;\n      first(num?: number): SugarDefaultChainable<T>;\n      flatten(limit?: number): SugarDefaultChainable<T[]>;\n      forEachFromIndex(startIndex: number, loop?: boolean, ...args: any[]): SugarDefaultChainable<T>;\n      forEachFromIndex(startIndex: number, ...args: any[]): SugarDefaultChainable<T>;\n      from(index: number): SugarDefaultChainable<T[]>;\n      groupBy<U>(map: string|mapFn<T, U>, groupFn?: (arr: T[], key: string, obj: Object) => SugarDefaultChainable<void>): SugarDefaultChainable<Object>;\n      inGroups(num: number, padding?: any): SugarDefaultChainable<T[]>;\n      inGroupsOf(num: number, padding?: any): SugarDefaultChainable<T[]>;\n      insert(item: T|T[], index?: number): SugarDefaultChainable<T[]>;\n      intersect(arr: T[]): SugarDefaultChainable<T[]>;\n      isEmpty(): SugarDefaultChainable<boolean>;\n      isEqual(arr: T[]): SugarDefaultChainable<boolean>;\n      last(num?: number): SugarDefaultChainable<T>;\n      least<U>(all?: boolean, map?: string|mapFn<T, U>): SugarDefaultChainable<T[]>;\n      least<U>(map?: string|mapFn<T, U>): SugarDefaultChainable<T[]>;\n      map<U>(map: string|mapFn<T, U>, context?: any): SugarDefaultChainable<U[]>;\n      mapFromIndex(startIndex: number, loop?: boolean, ...args: any[]): SugarDefaultChainable<T>;\n      mapFromIndex(startIndex: number, ...args: any[]): SugarDefaultChainable<T>;\n      max<U>(all?: boolean, map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      max<U>(map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      median<U>(map?: string|mapFn<T, U>): SugarDefaultChainable<number>;\n      min<U>(all?: boolean, map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      min<U>(map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      most<U>(all?: boolean, map?: string|mapFn<T, U>): SugarDefaultChainable<T[]>;\n      most<U>(map?: string|mapFn<T, U>): SugarDefaultChainable<T[]>;\n      none(search: T|searchFn<T>, context?: any): SugarDefaultChainable<boolean>;\n      reduceFromIndex(startIndex: number, loop?: boolean, ...args: any[]): SugarDefaultChainable<T>;\n      reduceFromIndex(startIndex: number, ...args: any[]): SugarDefaultChainable<T>;\n      reduceRightFromIndex(startIndex: number, loop?: boolean, ...args: any[]): SugarDefaultChainable<T>;\n      reduceRightFromIndex(startIndex: number, ...args: any[]): SugarDefaultChainable<T>;\n      remove(search: T|searchFn<T>): SugarDefaultChainable<T[]>;\n      removeAt(start: number, end?: number): SugarDefaultChainable<T[]>;\n      sample(num?: number, remove?: boolean): SugarDefaultChainable<T>;\n      shuffle(): SugarDefaultChainable<T[]>;\n      some(search: T|searchFn<T>, context?: any): SugarDefaultChainable<boolean>;\n      someFromIndex(startIndex: number, loop?: boolean, ...args: any[]): SugarDefaultChainable<T>;\n      someFromIndex(startIndex: number, ...args: any[]): SugarDefaultChainable<T>;\n      sortBy<U>(map?: string|sortMapFn<T, U>, desc?: boolean): SugarDefaultChainable<T[]>;\n      subtract(item: T|T[]): SugarDefaultChainable<T[]>;\n      sum<U>(map?: string|mapFn<T, U>): SugarDefaultChainable<number>;\n      to(index: number): SugarDefaultChainable<T[]>;\n      union(arr: T[]): SugarDefaultChainable<T[]>;\n      unique<U>(map?: string|mapFn<T, U>): SugarDefaultChainable<T[]>;\n      zip(...args: any[]): SugarDefaultChainable<T[]>;\n      concat(...items: (T | T[])[]): SugarDefaultChainable<T[]>;\n      concat(...items: T[][]): SugarDefaultChainable<T[]>;\n      copyWithin(target: number, start: number, end?: number): SugarDefaultChainable<this>;\n      every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): SugarDefaultChainable<boolean>;\n      fill(value: T, start?: number, end?: number): SugarDefaultChainable<this>;\n      filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): SugarDefaultChainable<T[]>;\n      find(predicate: (value: T, index: number, obj: Array<T>) => boolean, thisArg?: any): SugarDefaultChainable<T | undefined>;\n      findIndex(predicate: (value: T, index: number, obj: Array<T>) => boolean, thisArg?: any): SugarDefaultChainable<number>;\n      forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): SugarDefaultChainable<void>;\n      indexOf(searchElement: T, fromIndex?: number): SugarDefaultChainable<number>;\n      join(separator?: string): SugarDefaultChainable<string>;\n      lastIndexOf(searchElement: T, fromIndex?: number): SugarDefaultChainable<number>;\n      map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): SugarDefaultChainable<U[]>;\n      pop(): SugarDefaultChainable<T | undefined>;\n      push(...items: T[]): SugarDefaultChainable<number>;\n      reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): SugarDefaultChainable<T>;\n      reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): SugarDefaultChainable<U>;\n      reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue?: T): SugarDefaultChainable<T>;\n      reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): SugarDefaultChainable<U>;\n      reverse(): SugarDefaultChainable<T[]>;\n      shift(): SugarDefaultChainable<T | undefined>;\n      slice(start?: number, end?: number): SugarDefaultChainable<T[]>;\n      some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): SugarDefaultChainable<boolean>;\n      sort(compareFn?: (a: T, b: T) => number): SugarDefaultChainable<this>;\n      splice(start: number): SugarDefaultChainable<T[]>;\n      splice(start: number, deleteCount: number, ...items: T[]): SugarDefaultChainable<T[]>;\n      toLocaleString(): SugarDefaultChainable<string>;\n      unshift(...items: T[]): SugarDefaultChainable<number>;\n    }\n\n  }\n\n  namespace Date {\n\n    type Chainable<RawValue> = ChainableBase<RawValue> & Object.ChainableBase<RawValue>;\n\n    interface DateOptions {\n      newDateInternal: Function;\n    }\n\n    interface DateCreateOptions {\n      locale?: string;\n      past?: boolean;\n      future?: boolean;\n      fromUTC?: boolean;\n      setUTC?: boolean;\n      clone?: boolean;\n      params?: Object;\n    }\n\n    interface Constructor extends SugarNamespace {\n      (d?: string|number|Date, options?: DateCreateOptions): Chainable<Date>;\n      new(d?: string|number|Date, options?: DateCreateOptions): Chainable<Date>;\n      addLocale(localeCode: string, def: Object): Locale;\n      create(d?: string|number|Date, options?: DateCreateOptions): Date;\n      getAllLocaleCodes(): string[];\n      getAllLocales(): Array<Locale>;\n      getLocale(localeCode?: string): Locale;\n      range(start?: string|Date, end?: string|Date): Range;\n      removeLocale(localeCode: string): Locale;\n      setLocale(localeCode: string): Locale;\n      addDays(instance: Date, n: number, reset?: boolean): Date;\n      addHours(instance: Date, n: number, reset?: boolean): Date;\n      addMilliseconds(instance: Date, n: number, reset?: boolean): Date;\n      addMinutes(instance: Date, n: number, reset?: boolean): Date;\n      addMonths(instance: Date, n: number, reset?: boolean): Date;\n      addSeconds(instance: Date, n: number, reset?: boolean): Date;\n      addWeeks(instance: Date, n: number, reset?: boolean): Date;\n      addYears(instance: Date, n: number, reset?: boolean): Date;\n      advance(instance: Date, set: string|Object, reset?: boolean): Date;\n      advance(instance: Date, milliseconds: number): Date;\n      advance(instance: Date, year: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millliseconds?: undefined): Date;\n      beginningOfDay(instance: Date, localeCode?: string): Date;\n      beginningOfISOWeek(instance: Date): Date;\n      beginningOfMonth(instance: Date, localeCode?: string): Date;\n      beginningOfWeek(instance: Date, localeCode?: string): Date;\n      beginningOfYear(instance: Date, localeCode?: string): Date;\n      clone(instance: Date): Date;\n      daysAgo(instance: Date): number;\n      daysFromNow(instance: Date): number;\n      daysInMonth(instance: Date): number;\n      daysSince(instance: Date, d: string|number|Date, options?: DateCreateOptions): number;\n      daysUntil(instance: Date, d?: string|number|Date, options?: DateCreateOptions): number;\n      endOfDay(instance: Date, localeCode?: string): Date;\n      endOfISOWeek(instance: Date): Date;\n      endOfMonth(instance: Date, localeCode?: string): Date;\n      endOfWeek(instance: Date, localeCode?: string): Date;\n      endOfYear(instance: Date, localeCode?: string): Date;\n      format(instance: Date, f?: string, localeCode?: string): string;\n      full(instance: Date, localeCode?: string): string;\n      get(instance: Date, d: string|number|Date, options?: DateCreateOptions): Date;\n      getISOWeek(instance: Date): number;\n      getUTCOffset(instance: Date, iso?: boolean): string;\n      getUTCWeekday(instance: Date): number;\n      getWeekday(instance: Date): number;\n      hoursAgo(instance: Date): number;\n      hoursFromNow(instance: Date): number;\n      hoursSince(instance: Date, d: string|number|Date, options?: DateCreateOptions): number;\n      hoursUntil(instance: Date, d?: string|number|Date, options?: DateCreateOptions): number;\n      is(instance: Date, d: string|number|Date, margin?: number): boolean;\n      isAfter(instance: Date, d: string|number|Date, margin?: number): boolean;\n      isBefore(instance: Date, d: string|number|Date, margin?: number): boolean;\n      isBetween(instance: Date, d1: string|number|Date, d2: string|number|Date, margin?: number): boolean;\n      isFriday(instance: Date): boolean;\n      isFuture(instance: Date): boolean;\n      isLastMonth(instance: Date, localeCode?: string): boolean;\n      isLastWeek(instance: Date, localeCode?: string): boolean;\n      isLastYear(instance: Date, localeCode?: string): boolean;\n      isLeapYear(instance: Date): boolean;\n      isMonday(instance: Date): boolean;\n      isNextMonth(instance: Date, localeCode?: string): boolean;\n      isNextWeek(instance: Date, localeCode?: string): boolean;\n      isNextYear(instance: Date, localeCode?: string): boolean;\n      isPast(instance: Date): boolean;\n      isSaturday(instance: Date): boolean;\n      isSunday(instance: Date): boolean;\n      isThisMonth(instance: Date, localeCode?: string): boolean;\n      isThisWeek(instance: Date, localeCode?: string): boolean;\n      isThisYear(instance: Date, localeCode?: string): boolean;\n      isThursday(instance: Date): boolean;\n      isToday(instance: Date): boolean;\n      isTomorrow(instance: Date): boolean;\n      isTuesday(instance: Date): boolean;\n      isUTC(instance: Date): boolean;\n      isValid(instance: Date): boolean;\n      isWednesday(instance: Date): boolean;\n      isWeekday(instance: Date): boolean;\n      isWeekend(instance: Date): boolean;\n      isYesterday(instance: Date): boolean;\n      iso(instance: Date): string;\n      long(instance: Date, localeCode?: string): string;\n      medium(instance: Date, localeCode?: string): string;\n      millisecondsAgo(instance: Date): number;\n      millisecondsFromNow(instance: Date): number;\n      millisecondsSince(instance: Date, d: string|number|Date, options?: DateCreateOptions): number;\n      millisecondsUntil(instance: Date, d?: string|number|Date, options?: DateCreateOptions): number;\n      minutesAgo(instance: Date): number;\n      minutesFromNow(instance: Date): number;\n      minutesSince(instance: Date, d: string|number|Date, options?: DateCreateOptions): number;\n      minutesUntil(instance: Date, d?: string|number|Date, options?: DateCreateOptions): number;\n      monthsAgo(instance: Date): number;\n      monthsFromNow(instance: Date): number;\n      monthsSince(instance: Date, d: string|number|Date, options?: DateCreateOptions): number;\n      monthsUntil(instance: Date, d?: string|number|Date, options?: DateCreateOptions): number;\n      relative(instance: Date, localeCode?: string, relativeFn?: (num: number, unit: number, ms: number, loc: Locale) => string): string;\n      relative(instance: Date, relativeFn?: (num: number, unit: number, ms: number, loc: Locale) => string): string;\n      relativeTo(instance: Date, d: string|number|Date, localeCode?: string): string;\n      reset(instance: Date, unit?: string, localeCode?: string): Date;\n      rewind(instance: Date, set: string|Object, reset?: boolean): Date;\n      rewind(instance: Date, milliseconds: number): Date;\n      rewind(instance: Date, year: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millliseconds?: undefined): Date;\n      secondsAgo(instance: Date): number;\n      secondsFromNow(instance: Date): number;\n      secondsSince(instance: Date, d: string|number|Date, options?: DateCreateOptions): number;\n      secondsUntil(instance: Date, d?: string|number|Date, options?: DateCreateOptions): number;\n      set(instance: Date, set: Object, reset?: boolean): Date;\n      set(instance: Date, milliseconds: number): Date;\n      set(instance: Date, year: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millliseconds?: undefined): Date;\n      setISOWeek(instance: Date, num: number): void;\n      setUTC(instance: Date, on?: boolean): Date;\n      setWeekday(instance: Date, dow: number): void;\n      short(instance: Date, localeCode?: string): string;\n      weeksAgo(instance: Date): number;\n      weeksFromNow(instance: Date): number;\n      weeksSince(instance: Date, d: string|number|Date, options?: DateCreateOptions): number;\n      weeksUntil(instance: Date, d?: string|number|Date, options?: DateCreateOptions): number;\n      yearsAgo(instance: Date): number;\n      yearsFromNow(instance: Date): number;\n      yearsSince(instance: Date, d: string|number|Date, options?: DateCreateOptions): number;\n      yearsUntil(instance: Date, d?: string|number|Date, options?: DateCreateOptions): number;\n      getOption<T>(name: string): T;\n      setOption(name: string, value: any): void;\n      setOption(options: DateOptions): void;\n    }\n\n    interface ChainableBase<RawValue> {\n      raw: RawValue;\n      valueOf: () => RawValue;\n      toString: () => string;\n      addDays(n: number, reset?: boolean): SugarDefaultChainable<Date>;\n      addHours(n: number, reset?: boolean): SugarDefaultChainable<Date>;\n      addMilliseconds(n: number, reset?: boolean): SugarDefaultChainable<Date>;\n      addMinutes(n: number, reset?: boolean): SugarDefaultChainable<Date>;\n      addMonths(n: number, reset?: boolean): SugarDefaultChainable<Date>;\n      addSeconds(n: number, reset?: boolean): SugarDefaultChainable<Date>;\n      addWeeks(n: number, reset?: boolean): SugarDefaultChainable<Date>;\n      addYears(n: number, reset?: boolean): SugarDefaultChainable<Date>;\n      advance(set: string|Object, reset?: boolean): SugarDefaultChainable<Date>;\n      advance(milliseconds: number): SugarDefaultChainable<Date>;\n      advance(year: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millliseconds?: undefined): SugarDefaultChainable<Date>;\n      beginningOfDay(localeCode?: string): SugarDefaultChainable<Date>;\n      beginningOfISOWeek(): SugarDefaultChainable<Date>;\n      beginningOfMonth(localeCode?: string): SugarDefaultChainable<Date>;\n      beginningOfWeek(localeCode?: string): SugarDefaultChainable<Date>;\n      beginningOfYear(localeCode?: string): SugarDefaultChainable<Date>;\n      clone(): SugarDefaultChainable<Date>;\n      daysAgo(): SugarDefaultChainable<number>;\n      daysFromNow(): SugarDefaultChainable<number>;\n      daysInMonth(): SugarDefaultChainable<number>;\n      daysSince(d: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      daysUntil(d?: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      endOfDay(localeCode?: string): SugarDefaultChainable<Date>;\n      endOfISOWeek(): SugarDefaultChainable<Date>;\n      endOfMonth(localeCode?: string): SugarDefaultChainable<Date>;\n      endOfWeek(localeCode?: string): SugarDefaultChainable<Date>;\n      endOfYear(localeCode?: string): SugarDefaultChainable<Date>;\n      format(f?: string, localeCode?: string): SugarDefaultChainable<string>;\n      full(localeCode?: string): SugarDefaultChainable<string>;\n      get(d: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<Date>;\n      getISOWeek(): SugarDefaultChainable<number>;\n      getUTCOffset(iso?: boolean): SugarDefaultChainable<string>;\n      getUTCWeekday(): SugarDefaultChainable<number>;\n      getWeekday(): SugarDefaultChainable<number>;\n      hoursAgo(): SugarDefaultChainable<number>;\n      hoursFromNow(): SugarDefaultChainable<number>;\n      hoursSince(d: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      hoursUntil(d?: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      is(d: string|number|Date, margin?: number): SugarDefaultChainable<boolean>;\n      isAfter(d: string|number|Date, margin?: number): SugarDefaultChainable<boolean>;\n      isBefore(d: string|number|Date, margin?: number): SugarDefaultChainable<boolean>;\n      isBetween(d1: string|number|Date, d2: string|number|Date, margin?: number): SugarDefaultChainable<boolean>;\n      isFriday(): SugarDefaultChainable<boolean>;\n      isFuture(): SugarDefaultChainable<boolean>;\n      isLastMonth(localeCode?: string): SugarDefaultChainable<boolean>;\n      isLastWeek(localeCode?: string): SugarDefaultChainable<boolean>;\n      isLastYear(localeCode?: string): SugarDefaultChainable<boolean>;\n      isLeapYear(): SugarDefaultChainable<boolean>;\n      isMonday(): SugarDefaultChainable<boolean>;\n      isNextMonth(localeCode?: string): SugarDefaultChainable<boolean>;\n      isNextWeek(localeCode?: string): SugarDefaultChainable<boolean>;\n      isNextYear(localeCode?: string): SugarDefaultChainable<boolean>;\n      isPast(): SugarDefaultChainable<boolean>;\n      isSaturday(): SugarDefaultChainable<boolean>;\n      isSunday(): SugarDefaultChainable<boolean>;\n      isThisMonth(localeCode?: string): SugarDefaultChainable<boolean>;\n      isThisWeek(localeCode?: string): SugarDefaultChainable<boolean>;\n      isThisYear(localeCode?: string): SugarDefaultChainable<boolean>;\n      isThursday(): SugarDefaultChainable<boolean>;\n      isToday(): SugarDefaultChainable<boolean>;\n      isTomorrow(): SugarDefaultChainable<boolean>;\n      isTuesday(): SugarDefaultChainable<boolean>;\n      isUTC(): SugarDefaultChainable<boolean>;\n      isValid(): SugarDefaultChainable<boolean>;\n      isWednesday(): SugarDefaultChainable<boolean>;\n      isWeekday(): SugarDefaultChainable<boolean>;\n      isWeekend(): SugarDefaultChainable<boolean>;\n      isYesterday(): SugarDefaultChainable<boolean>;\n      iso(): SugarDefaultChainable<string>;\n      long(localeCode?: string): SugarDefaultChainable<string>;\n      medium(localeCode?: string): SugarDefaultChainable<string>;\n      millisecondsAgo(): SugarDefaultChainable<number>;\n      millisecondsFromNow(): SugarDefaultChainable<number>;\n      millisecondsSince(d: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      millisecondsUntil(d?: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      minutesAgo(): SugarDefaultChainable<number>;\n      minutesFromNow(): SugarDefaultChainable<number>;\n      minutesSince(d: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      minutesUntil(d?: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      monthsAgo(): SugarDefaultChainable<number>;\n      monthsFromNow(): SugarDefaultChainable<number>;\n      monthsSince(d: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      monthsUntil(d?: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      relative(localeCode?: string, relativeFn?: (num: number, unit: number, ms: number, loc: Locale) => SugarDefaultChainable<string>): SugarDefaultChainable<string>;\n      relative(relativeFn?: (num: number, unit: number, ms: number, loc: Locale) => SugarDefaultChainable<string>): SugarDefaultChainable<string>;\n      relativeTo(d: string|number|Date, localeCode?: string): SugarDefaultChainable<string>;\n      reset(unit?: string, localeCode?: string): SugarDefaultChainable<Date>;\n      rewind(set: string|Object, reset?: boolean): SugarDefaultChainable<Date>;\n      rewind(milliseconds: number): SugarDefaultChainable<Date>;\n      rewind(year: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millliseconds?: undefined): SugarDefaultChainable<Date>;\n      secondsAgo(): SugarDefaultChainable<number>;\n      secondsFromNow(): SugarDefaultChainable<number>;\n      secondsSince(d: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      secondsUntil(d?: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      set(set: Object, reset?: boolean): SugarDefaultChainable<Date>;\n      set(milliseconds: number): SugarDefaultChainable<Date>;\n      set(year: number, month: number, day?: number, hour?: number, minute?: number, second?: number, millliseconds?: undefined): SugarDefaultChainable<Date>;\n      setISOWeek(num: number): SugarDefaultChainable<void>;\n      setUTC(on?: boolean): SugarDefaultChainable<Date>;\n      setWeekday(dow: number): SugarDefaultChainable<void>;\n      short(localeCode?: string): SugarDefaultChainable<string>;\n      weeksAgo(): SugarDefaultChainable<number>;\n      weeksFromNow(): SugarDefaultChainable<number>;\n      weeksSince(d: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      weeksUntil(d?: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      yearsAgo(): SugarDefaultChainable<number>;\n      yearsFromNow(): SugarDefaultChainable<number>;\n      yearsSince(d: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      yearsUntil(d?: string|number|Date, options?: DateCreateOptions): SugarDefaultChainable<number>;\n      getDate(): SugarDefaultChainable<number>;\n      getDay(): SugarDefaultChainable<number>;\n      getFullYear(): SugarDefaultChainable<number>;\n      getHours(): SugarDefaultChainable<number>;\n      getMilliseconds(): SugarDefaultChainable<number>;\n      getMinutes(): SugarDefaultChainable<number>;\n      getMonth(): SugarDefaultChainable<number>;\n      getSeconds(): SugarDefaultChainable<number>;\n      getTime(): SugarDefaultChainable<number>;\n      getTimezoneOffset(): SugarDefaultChainable<number>;\n      getUTCDate(): SugarDefaultChainable<number>;\n      getUTCDay(): SugarDefaultChainable<number>;\n      getUTCFullYear(): SugarDefaultChainable<number>;\n      getUTCHours(): SugarDefaultChainable<number>;\n      getUTCMilliseconds(): SugarDefaultChainable<number>;\n      getUTCMinutes(): SugarDefaultChainable<number>;\n      getUTCMonth(): SugarDefaultChainable<number>;\n      getUTCSeconds(): SugarDefaultChainable<number>;\n      setDate(date: number): SugarDefaultChainable<number>;\n      setFullYear(year: number, month?: number, date?: number): SugarDefaultChainable<number>;\n      setHours(hours: number, min?: number, sec?: number, ms?: number): SugarDefaultChainable<number>;\n      setMilliseconds(ms: number): SugarDefaultChainable<number>;\n      setMinutes(min: number, sec?: number, ms?: number): SugarDefaultChainable<number>;\n      setMonth(month: number, date?: number): SugarDefaultChainable<number>;\n      setSeconds(sec: number, ms?: number): SugarDefaultChainable<number>;\n      setTime(time: number): SugarDefaultChainable<number>;\n      setUTCDate(date: number): SugarDefaultChainable<number>;\n      setUTCFullYear(year: number, month?: number, date?: number): SugarDefaultChainable<number>;\n      setUTCHours(hours: number, min?: number, sec?: number, ms?: number): SugarDefaultChainable<number>;\n      setUTCMilliseconds(ms: number): SugarDefaultChainable<number>;\n      setUTCMinutes(min: number, sec?: number, ms?: number): SugarDefaultChainable<number>;\n      setUTCMonth(month: number, date?: number): SugarDefaultChainable<number>;\n      setUTCSeconds(sec: number, ms?: number): SugarDefaultChainable<number>;\n      toDateString(): SugarDefaultChainable<string>;\n      toISOString(): SugarDefaultChainable<string>;\n      toJSON(key?: any): SugarDefaultChainable<string>;\n      toLocaleDateString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): SugarDefaultChainable<string>;\n      toLocaleDateString(): SugarDefaultChainable<string>;\n      toLocaleString(): SugarDefaultChainable<string>;\n      toLocaleString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): SugarDefaultChainable<string>;\n      toLocaleTimeString(): SugarDefaultChainable<string>;\n      toLocaleTimeString(locales?: string | string[], options?: Intl.DateTimeFormatOptions): SugarDefaultChainable<string>;\n      toTimeString(): SugarDefaultChainable<string>;\n      toUTCString(): SugarDefaultChainable<string>;\n    }\n\n  }\n\n  namespace Function {\n\n    type Chainable<RawValue> = ChainableBase<RawValue> & Object.ChainableBase<RawValue>;\n\n    interface Constructor extends SugarNamespace {\n      (raw?: Function): Chainable<Function>;\n      new(raw?: Function): Chainable<Function>;\n      after(instance: Function, n: number): Function;\n      cancel(instance: Function): Function;\n      debounce(instance: Function, ms?: number): Function;\n      delay(instance: Function, ms?: number, ...args: any[]): Function;\n      every(instance: Function, ms?: number, ...args: any[]): Function;\n      lazy(instance: Function, ms?: number, immediate?: boolean, limit?: number): Function;\n      lock(instance: Function, n?: number): Function;\n      memoize(instance: Function, hashFn?: string|Function, limit?: number): Function;\n      once(instance: Function): Function;\n      partial(instance: Function, ...args: any[]): Function;\n      throttle(instance: Function, ms?: number): Function;\n    }\n\n    interface ChainableBase<RawValue> {\n      raw: RawValue;\n      valueOf: () => RawValue;\n      toString: () => string;\n      after(n: number): SugarDefaultChainable<Function>;\n      cancel(): SugarDefaultChainable<Function>;\n      debounce(ms?: number): SugarDefaultChainable<Function>;\n      delay(ms?: number, ...args: any[]): SugarDefaultChainable<Function>;\n      every(ms?: number, ...args: any[]): SugarDefaultChainable<Function>;\n      lazy(ms?: number, immediate?: boolean, limit?: number): SugarDefaultChainable<Function>;\n      lock(n?: number): SugarDefaultChainable<Function>;\n      memoize(hashFn?: string|Function, limit?: number): SugarDefaultChainable<Function>;\n      once(): SugarDefaultChainable<Function>;\n      partial(...args: any[]): SugarDefaultChainable<Function>;\n      throttle(ms?: number): SugarDefaultChainable<Function>;\n      apply(thisArg: any, argArray?: any): SugarDefaultChainable<any>;\n      bind(thisArg: any, ...argArray: any[]): SugarDefaultChainable<any>;\n      call(thisArg: any, ...argArray: any[]): SugarDefaultChainable<any>;\n    }\n\n  }\n\n  namespace Number {\n\n    type Chainable<RawValue> = ChainableBase<RawValue> & Object.ChainableBase<RawValue>;\n\n    interface NumberOptions {\n      decimal: string;\n      thousands: string;\n    }\n\n    interface Constructor extends SugarNamespace {\n      (raw?: number): Chainable<number>;\n      new(raw?: number): Chainable<number>;\n      random(n1?: number, n2?: number): number;\n      range(start?: number, end?: number): Range;\n      abbr(instance: number, precision?: number): string;\n      abs(instance: number): number;\n      acos(instance: number): number;\n      asin(instance: number): number;\n      atan(instance: number): number;\n      bytes(instance: number, precision?: number, binary?: boolean, units?: string): string;\n      cap(instance: number, max?: number): number;\n      ceil(instance: number, precision?: number): number;\n      chr(instance: number): string;\n      clamp(instance: number, start?: number, end?: number): number;\n      cos(instance: number): number;\n      day(instance: number): number;\n      dayAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      dayAgo(instance: number): Date;\n      dayBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      dayFromNow(instance: number): Date;\n      days(instance: number): number;\n      daysAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      daysAgo(instance: number): Date;\n      daysBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      daysFromNow(instance: number): Date;\n      downto<T>(instance: number, num: number, step?: number, everyFn?: (el: T, i: number, r: Range) => void): T[];\n      downto<T>(instance: number, num: number, everyFn?: (el: T, i: number, r: Range) => void): T[];\n      duration(instance: number, localeCode?: string): string;\n      exp(instance: number): number;\n      floor(instance: number, precision?: number): number;\n      format(instance: number, place?: number): string;\n      hex(instance: number, pad?: number): string;\n      hour(instance: number): number;\n      hourAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      hourAgo(instance: number): Date;\n      hourBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      hourFromNow(instance: number): Date;\n      hours(instance: number): number;\n      hoursAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      hoursAgo(instance: number): Date;\n      hoursBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      hoursFromNow(instance: number): Date;\n      isEven(instance: number): boolean;\n      isInteger(instance: number): boolean;\n      isMultipleOf(instance: number, num: number): boolean;\n      isOdd(instance: number): boolean;\n      log(instance: number, base?: number): number;\n      metric(instance: number, precision?: number, units?: string): string;\n      millisecond(instance: number): number;\n      millisecondAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      millisecondAgo(instance: number): Date;\n      millisecondBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      millisecondFromNow(instance: number): Date;\n      milliseconds(instance: number): number;\n      millisecondsAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      millisecondsAgo(instance: number): Date;\n      millisecondsBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      millisecondsFromNow(instance: number): Date;\n      minute(instance: number): number;\n      minuteAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      minuteAgo(instance: number): Date;\n      minuteBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      minuteFromNow(instance: number): Date;\n      minutes(instance: number): number;\n      minutesAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      minutesAgo(instance: number): Date;\n      minutesBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      minutesFromNow(instance: number): Date;\n      month(instance: number): number;\n      monthAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      monthAgo(instance: number): Date;\n      monthBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      monthFromNow(instance: number): Date;\n      months(instance: number): number;\n      monthsAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      monthsAgo(instance: number): Date;\n      monthsBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      monthsFromNow(instance: number): Date;\n      ordinalize(instance: number): string;\n      pad(instance: number, place?: number, sign?: boolean, base?: number): string;\n      pow(instance: number): number;\n      round(instance: number, precision?: number): number;\n      second(instance: number): number;\n      secondAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      secondAgo(instance: number): Date;\n      secondBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      secondFromNow(instance: number): Date;\n      seconds(instance: number): number;\n      secondsAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      secondsAgo(instance: number): Date;\n      secondsBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      secondsFromNow(instance: number): Date;\n      sin(instance: number): number;\n      sqrt(instance: number): number;\n      tan(instance: number): number;\n      times<T>(instance: number, indexMapFn: (i: number) => any): T;\n      toNumber(instance: number): number;\n      upto<T>(instance: number, num: number, step?: number, everyFn?: (el: T, i: number, r: Range) => void): T[];\n      upto<T>(instance: number, num: number, everyFn?: (el: T, i: number, r: Range) => void): T[];\n      week(instance: number): number;\n      weekAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      weekAgo(instance: number): Date;\n      weekBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      weekFromNow(instance: number): Date;\n      weeks(instance: number): number;\n      weeksAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      weeksAgo(instance: number): Date;\n      weeksBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      weeksFromNow(instance: number): Date;\n      year(instance: number): number;\n      yearAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      yearAgo(instance: number): Date;\n      yearBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      yearFromNow(instance: number): Date;\n      years(instance: number): number;\n      yearsAfter(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      yearsAgo(instance: number): Date;\n      yearsBefore(instance: number, d: string|number|Date, options?: Date.DateCreateOptions): Date;\n      yearsFromNow(instance: number): Date;\n      getOption<T>(name: string): T;\n      setOption(name: string, value: any): void;\n      setOption(options: NumberOptions): void;\n    }\n\n    interface ChainableBase<RawValue> {\n      raw: RawValue;\n      valueOf: () => RawValue;\n      toString: () => string;\n      abbr(precision?: number): SugarDefaultChainable<string>;\n      abs(): SugarDefaultChainable<number>;\n      acos(): SugarDefaultChainable<number>;\n      asin(): SugarDefaultChainable<number>;\n      atan(): SugarDefaultChainable<number>;\n      bytes(precision?: number, binary?: boolean, units?: string): SugarDefaultChainable<string>;\n      cap(max?: number): SugarDefaultChainable<number>;\n      ceil(precision?: number): SugarDefaultChainable<number>;\n      chr(): SugarDefaultChainable<string>;\n      clamp(start?: number, end?: number): SugarDefaultChainable<number>;\n      cos(): SugarDefaultChainable<number>;\n      day(): SugarDefaultChainable<number>;\n      dayAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      dayAgo(): SugarDefaultChainable<Date>;\n      dayBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      dayFromNow(): SugarDefaultChainable<Date>;\n      days(): SugarDefaultChainable<number>;\n      daysAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      daysAgo(): SugarDefaultChainable<Date>;\n      daysBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      daysFromNow(): SugarDefaultChainable<Date>;\n      downto<T>(num: number, step?: number, everyFn?: (el: T, i: number, r: Range) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      downto<T>(num: number, everyFn?: (el: T, i: number, r: Range) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      duration(localeCode?: string): SugarDefaultChainable<string>;\n      exp(): SugarDefaultChainable<number>;\n      floor(precision?: number): SugarDefaultChainable<number>;\n      format(place?: number): SugarDefaultChainable<string>;\n      hex(pad?: number): SugarDefaultChainable<string>;\n      hour(): SugarDefaultChainable<number>;\n      hourAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      hourAgo(): SugarDefaultChainable<Date>;\n      hourBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      hourFromNow(): SugarDefaultChainable<Date>;\n      hours(): SugarDefaultChainable<number>;\n      hoursAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      hoursAgo(): SugarDefaultChainable<Date>;\n      hoursBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      hoursFromNow(): SugarDefaultChainable<Date>;\n      isEven(): SugarDefaultChainable<boolean>;\n      isInteger(): SugarDefaultChainable<boolean>;\n      isMultipleOf(num: number): SugarDefaultChainable<boolean>;\n      isOdd(): SugarDefaultChainable<boolean>;\n      log(base?: number): SugarDefaultChainable<number>;\n      metric(precision?: number, units?: string): SugarDefaultChainable<string>;\n      millisecond(): SugarDefaultChainable<number>;\n      millisecondAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      millisecondAgo(): SugarDefaultChainable<Date>;\n      millisecondBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      millisecondFromNow(): SugarDefaultChainable<Date>;\n      milliseconds(): SugarDefaultChainable<number>;\n      millisecondsAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      millisecondsAgo(): SugarDefaultChainable<Date>;\n      millisecondsBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      millisecondsFromNow(): SugarDefaultChainable<Date>;\n      minute(): SugarDefaultChainable<number>;\n      minuteAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      minuteAgo(): SugarDefaultChainable<Date>;\n      minuteBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      minuteFromNow(): SugarDefaultChainable<Date>;\n      minutes(): SugarDefaultChainable<number>;\n      minutesAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      minutesAgo(): SugarDefaultChainable<Date>;\n      minutesBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      minutesFromNow(): SugarDefaultChainable<Date>;\n      month(): SugarDefaultChainable<number>;\n      monthAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      monthAgo(): SugarDefaultChainable<Date>;\n      monthBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      monthFromNow(): SugarDefaultChainable<Date>;\n      months(): SugarDefaultChainable<number>;\n      monthsAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      monthsAgo(): SugarDefaultChainable<Date>;\n      monthsBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      monthsFromNow(): SugarDefaultChainable<Date>;\n      ordinalize(): SugarDefaultChainable<string>;\n      pad(place?: number, sign?: boolean, base?: number): SugarDefaultChainable<string>;\n      pow(): SugarDefaultChainable<number>;\n      round(precision?: number): SugarDefaultChainable<number>;\n      second(): SugarDefaultChainable<number>;\n      secondAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      secondAgo(): SugarDefaultChainable<Date>;\n      secondBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      secondFromNow(): SugarDefaultChainable<Date>;\n      seconds(): SugarDefaultChainable<number>;\n      secondsAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      secondsAgo(): SugarDefaultChainable<Date>;\n      secondsBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      secondsFromNow(): SugarDefaultChainable<Date>;\n      sin(): SugarDefaultChainable<number>;\n      sqrt(): SugarDefaultChainable<number>;\n      tan(): SugarDefaultChainable<number>;\n      times<T>(indexMapFn: (i: number) => SugarDefaultChainable<any>): SugarDefaultChainable<T>;\n      toNumber(): SugarDefaultChainable<number>;\n      upto<T>(num: number, step?: number, everyFn?: (el: T, i: number, r: Range) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      upto<T>(num: number, everyFn?: (el: T, i: number, r: Range) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      week(): SugarDefaultChainable<number>;\n      weekAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      weekAgo(): SugarDefaultChainable<Date>;\n      weekBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      weekFromNow(): SugarDefaultChainable<Date>;\n      weeks(): SugarDefaultChainable<number>;\n      weeksAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      weeksAgo(): SugarDefaultChainable<Date>;\n      weeksBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      weeksFromNow(): SugarDefaultChainable<Date>;\n      year(): SugarDefaultChainable<number>;\n      yearAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      yearAgo(): SugarDefaultChainable<Date>;\n      yearBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      yearFromNow(): SugarDefaultChainable<Date>;\n      years(): SugarDefaultChainable<number>;\n      yearsAfter(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      yearsAgo(): SugarDefaultChainable<Date>;\n      yearsBefore(d: string|number|Date, options?: Date.DateCreateOptions): SugarDefaultChainable<Date>;\n      yearsFromNow(): SugarDefaultChainable<Date>;\n      toExponential(fractionDigits?: number): SugarDefaultChainable<string>;\n      toFixed(fractionDigits?: number): SugarDefaultChainable<string>;\n      toLocaleString(locales?: string | string[], options?: Intl.NumberFormatOptions): SugarDefaultChainable<string>;\n      toPrecision(precision?: number): SugarDefaultChainable<string>;\n    }\n\n  }\n\n  namespace Object {\n\n    type resolveFn<T> = (key: string, targetVal: T, sourceVal: T, target: Object, source: Object) => boolean;\n    type searchFn<T> = (key: string, val: T, obj: Object) => boolean;\n    type mapFn<T, U> = (val: T, key: string, obj: Object) => U;\n    type Chainable<RawValue> = ChainableBase<RawValue>;\n\n    interface QueryStringParseOptions<T, U> {\n      deep?: boolean;\n      auto?: boolean;\n      transform?: (key: string, val: T, obj: Object) => U;\n      separator?: string;\n    }\n\n    interface QueryStringOptions<T, U> {\n      deep?: boolean;\n      prefix?: string;\n      transform?: (key: string, val: T, obj: Object) => U;\n      separator?: string;\n    }\n\n    interface ObjectMergeOptions<T> {\n      deep?: boolean;\n      hidden?: boolean;\n      descriptor?: boolean;\n      resolve?: boolean|resolveFn<T>;\n    }\n\n    interface Constructor extends SugarNamespace {\n      (raw?: Object): Chainable<Object>;\n      new(raw?: Object): Chainable<Object>;\n      fromQueryString<T, U>(str: string, options?: QueryStringParseOptions<T, U>): Object;\n      add<T>(instance: Object, obj: Object, options?: ObjectMergeOptions<T>): Object;\n      addAll<T>(instance: Object, sources: Array<Object>, options?: ObjectMergeOptions<T>): Object;\n      average<T, U>(instance: Object, map?: string|mapFn<T, U>): number;\n      clone(instance: Object, deep?: boolean): Object;\n      count<T>(instance: Object, search: T|searchFn<T>): number;\n      defaults<T>(instance: Object, sources: Array<Object>, options?: ObjectMergeOptions<T>): Object;\n      every<T>(instance: Object, search: T|searchFn<T>): boolean;\n      exclude<T>(instance: Object, search: T|searchFn<T>): Object;\n      filter<T>(instance: Object, search: T|searchFn<T>): T[];\n      find<T>(instance: Object, search: T|searchFn<T>): boolean;\n      forEach<T>(instance: Object, eachFn: (val: T, key: string, obj: Object) => void): Object;\n      get<T>(instance: Object, key: string, inherited?: boolean): T;\n      has(instance: Object, key: string, inherited?: boolean): boolean;\n      intersect(instance: Object, obj: Object): Object;\n      invert(instance: Object, multi?: boolean): Object;\n      isArguments(instance: Object): boolean;\n      isArray(instance: any): instance is Array<any>;\n      isBoolean(instance: any): instance is boolean;\n      isDate(instance: any): instance is Date;\n      isEmpty(instance: Object): boolean;\n      isEqual(instance: Object, obj: Object): boolean;\n      isError(instance: any): instance is Error;\n      isFunction(instance: any): instance is Function;\n      isMap(instance: any): instance is Map<any, any>;\n      isNumber(instance: any): instance is number;\n      isObject(instance: Object): boolean;\n      isRegExp(instance: any): instance is RegExp;\n      isSet(instance: any): instance is Set<any>;\n      isString(instance: any): instance is string;\n      keys<T>(instance: Object): T[];\n      least<T, U>(instance: Object, all?: boolean, map?: string|mapFn<T, U>): T;\n      least<T, U>(instance: Object, map?: string|mapFn<T, U>): T;\n      map<T, U>(instance: Object, map: string|mapFn<T, U>): Object;\n      max<T, U>(instance: Object, all?: boolean, map?: string|mapFn<T, U>): T;\n      max<T, U>(instance: Object, map?: string|mapFn<T, U>): T;\n      median<T, U>(instance: Object, map?: string|mapFn<T, U>): number;\n      merge<T>(instance: Object, source: Object, options?: ObjectMergeOptions<T>): Object;\n      mergeAll<T>(instance: Object, sources: Array<Object>, options?: ObjectMergeOptions<T>): Object;\n      min<T, U>(instance: Object, all?: boolean, map?: string|mapFn<T, U>): T;\n      min<T, U>(instance: Object, map?: string|mapFn<T, U>): T;\n      most<T, U>(instance: Object, all?: boolean, map?: string|mapFn<T, U>): T;\n      most<T, U>(instance: Object, map?: string|mapFn<T, U>): T;\n      none<T>(instance: Object, search: T|searchFn<T>): boolean;\n      reduce<T>(instance: Object, reduceFn: (acc: T, val: T, key: string, obj: Object) => void, init?: any): T;\n      reject(instance: Object, find: string|RegExp|Array<string>|Object): Object;\n      remove<T>(instance: Object, search: T|searchFn<T>): Object;\n      select(instance: Object, find: string|RegExp|Array<string>|Object): Object;\n      set<T>(instance: Object, key: string, val: T): Object;\n      size(instance: Object): number;\n      some<T>(instance: Object, search: T|searchFn<T>): boolean;\n      subtract(instance: Object, obj: Object): Object;\n      sum<T, U>(instance: Object, map?: string|mapFn<T, U>): number;\n      tap(instance: Object, tapFn: (obj: Object) => any): Object;\n      toQueryString<T, U>(instance: Object, options?: QueryStringOptions<T, U>): Object;\n      values<T>(instance: Object): T[];\n    }\n\n    interface ChainableBase<RawValue> {\n      raw: RawValue;\n      valueOf: () => RawValue;\n      toString: () => string;\n      add<T>(obj: Object, options?: ObjectMergeOptions<T>): SugarDefaultChainable<Object>;\n      addAll<T>(sources: Array<Object>, options?: ObjectMergeOptions<T>): SugarDefaultChainable<Object>;\n      average<T, U>(map?: string|mapFn<T, U>): SugarDefaultChainable<number>;\n      clone(deep?: boolean): SugarDefaultChainable<Object>;\n      count<T>(search: T|searchFn<T>): SugarDefaultChainable<number>;\n      defaults<T>(sources: Array<Object>, options?: ObjectMergeOptions<T>): SugarDefaultChainable<Object>;\n      every<T>(search: T|searchFn<T>): SugarDefaultChainable<boolean>;\n      exclude<T>(search: T|searchFn<T>): SugarDefaultChainable<Object>;\n      filter<T>(search: T|searchFn<T>): SugarDefaultChainable<T[]>;\n      find<T>(search: T|searchFn<T>): SugarDefaultChainable<boolean>;\n      forEach<T>(eachFn: (val: T, key: string, obj: Object) => SugarDefaultChainable<void>): SugarDefaultChainable<Object>;\n      get<T>(key: string, inherited?: boolean): SugarDefaultChainable<T>;\n      has(key: string, inherited?: boolean): SugarDefaultChainable<boolean>;\n      intersect(obj: Object): SugarDefaultChainable<Object>;\n      invert(multi?: boolean): SugarDefaultChainable<Object>;\n      isArguments(): SugarDefaultChainable<boolean>;\n      isArray(): SugarDefaultChainable<boolean>;\n      isBoolean(): SugarDefaultChainable<boolean>;\n      isDate(): SugarDefaultChainable<boolean>;\n      isEmpty(): SugarDefaultChainable<boolean>;\n      isEqual(obj: Object): SugarDefaultChainable<boolean>;\n      isError(): SugarDefaultChainable<boolean>;\n      isFunction(): SugarDefaultChainable<boolean>;\n      isMap(): SugarDefaultChainable<boolean>;\n      isNumber(): SugarDefaultChainable<boolean>;\n      isObject(): SugarDefaultChainable<boolean>;\n      isRegExp(): SugarDefaultChainable<boolean>;\n      isSet(): SugarDefaultChainable<boolean>;\n      isString(): SugarDefaultChainable<boolean>;\n      keys<T>(): SugarDefaultChainable<T[]>;\n      least<T, U>(all?: boolean, map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      least<T, U>(map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      map<T, U>(map: string|mapFn<T, U>): SugarDefaultChainable<Object>;\n      max<T, U>(all?: boolean, map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      max<T, U>(map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      median<T, U>(map?: string|mapFn<T, U>): SugarDefaultChainable<number>;\n      merge<T>(source: Object, options?: ObjectMergeOptions<T>): SugarDefaultChainable<Object>;\n      mergeAll<T>(sources: Array<Object>, options?: ObjectMergeOptions<T>): SugarDefaultChainable<Object>;\n      min<T, U>(all?: boolean, map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      min<T, U>(map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      most<T, U>(all?: boolean, map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      most<T, U>(map?: string|mapFn<T, U>): SugarDefaultChainable<T>;\n      none<T>(search: T|searchFn<T>): SugarDefaultChainable<boolean>;\n      reduce<T>(reduceFn: (acc: T, val: T, key: string, obj: Object) => SugarDefaultChainable<void>, init?: any): SugarDefaultChainable<T>;\n      reject(find: string|RegExp|Array<string>|Object): SugarDefaultChainable<Object>;\n      remove<T>(search: T|searchFn<T>): SugarDefaultChainable<Object>;\n      select(find: string|RegExp|Array<string>|Object): SugarDefaultChainable<Object>;\n      set<T>(key: string, val: T): SugarDefaultChainable<Object>;\n      size(): SugarDefaultChainable<number>;\n      some<T>(search: T|searchFn<T>): SugarDefaultChainable<boolean>;\n      subtract(obj: Object): SugarDefaultChainable<Object>;\n      sum<T, U>(map?: string|mapFn<T, U>): SugarDefaultChainable<number>;\n      tap(tapFn: (obj: Object) => SugarDefaultChainable<any>): SugarDefaultChainable<Object>;\n      toQueryString<T, U>(options?: QueryStringOptions<T, U>): SugarDefaultChainable<Object>;\n      values<T>(): SugarDefaultChainable<T[]>;\n    }\n\n  }\n\n  namespace RegExp {\n\n    type Chainable<RawValue> = ChainableBase<RawValue> & Object.ChainableBase<RawValue>;\n\n    interface Constructor extends SugarNamespace {\n      (raw?: RegExp): Chainable<RegExp>;\n      new(raw?: RegExp): Chainable<RegExp>;\n      escape(str?: string): string;\n      addFlags(instance: RegExp, flags: string): RegExp;\n      getFlags(instance: RegExp): string;\n      removeFlags(instance: RegExp, flags: string): RegExp;\n      setFlags(instance: RegExp, flags: string): RegExp;\n    }\n\n    interface ChainableBase<RawValue> {\n      raw: RawValue;\n      valueOf: () => RawValue;\n      toString: () => string;\n      addFlags(flags: string): SugarDefaultChainable<RegExp>;\n      getFlags(): SugarDefaultChainable<string>;\n      removeFlags(flags: string): SugarDefaultChainable<RegExp>;\n      setFlags(flags: string): SugarDefaultChainable<RegExp>;\n      exec(string: string): SugarDefaultChainable<RegExpExecArray | null>;\n      test(string: string): SugarDefaultChainable<boolean>;\n    }\n\n  }\n\n  namespace String {\n\n    type replaceFn = (tag: string, inner: string, attr: string, outer: string) => string;\n    type Chainable<RawValue> = ChainableBase<RawValue> & Object.ChainableBase<RawValue>;\n\n    interface Constructor extends SugarNamespace {\n      (raw?: string): Chainable<string>;\n      new(raw?: string): Chainable<string>;\n      range(start?: string, end?: string): Range;\n      at<T>(instance: string, index: number|Array<number>, loop?: boolean): T;\n      camelize(instance: string, upper?: boolean): string;\n      capitalize(instance: string, lower?: boolean, all?: boolean): string;\n      chars<T>(instance: string, eachCharFn?: (char: string, i: number, arr: Array<string>) => void): T[];\n      codes<T>(instance: string, eachCodeFn?: (code: number, i: number, str: string) => void): T[];\n      compact(instance: string): string;\n      dasherize(instance: string): string;\n      decodeBase64(instance: string): string;\n      encodeBase64(instance: string): string;\n      escapeHTML(instance: string): string;\n      escapeURL(instance: string, param?: boolean): string;\n      first(instance: string, n?: number): string;\n      forEach<T>(instance: string, search?: string|RegExp, eachFn?: (match: string, i: number, arr: Array<string>) => void): T[];\n      forEach<T>(instance: string, eachFn: (match: string, i: number, arr: Array<string>) => void): T[];\n      format(instance: string, ...args: any[]): string;\n      from(instance: string, index?: number): string;\n      insert(instance: string, str: string, index?: number): string;\n      isBlank(instance: string): boolean;\n      isEmpty(instance: string): boolean;\n      last(instance: string, n?: number): string;\n      lines<T>(instance: string, eachLineFn?: (line: string, i: number, arr: Array<string>) => void): T[];\n      pad(instance: string, num: number, padding?: string): string;\n      padLeft(instance: string, num: number, padding?: string): string;\n      padRight(instance: string, num: number, padding?: string): string;\n      parameterize(instance: string): string;\n      remove(instance: string, f: string|RegExp): string;\n      removeAll(instance: string, f: string|RegExp): string;\n      removeTags(instance: string, tag?: string, replace?: string|replaceFn): string;\n      replaceAll(instance: string, f: string|RegExp, ...args: any[]): string;\n      reverse(instance: string): string;\n      shift<T>(instance: string, n: number): T[];\n      spacify(instance: string): string;\n      stripTags(instance: string, tag?: string, replace?: string|replaceFn): string;\n      titleize(instance: string): string;\n      to(instance: string, index?: number): string;\n      toNumber(instance: string, base?: number): number;\n      trimLeft(instance: string): string;\n      trimRight(instance: string): string;\n      truncate(instance: string, length: number, from?: string, ellipsis?: string): string;\n      truncateOnWord(instance: string, length: number, from?: string, ellipsis?: string): string;\n      underscore(instance: string): string;\n      unescapeHTML(instance: string): string;\n      unescapeURL(instance: string, partial?: boolean): string;\n      words<T>(instance: string, eachWordFn?: (word: string, i: number, arr: Array<string>) => void): T[];\n    }\n\n    interface ChainableBase<RawValue> {\n      raw: RawValue;\n      valueOf: () => RawValue;\n      toString: () => string;\n      at<T>(index: number|Array<number>, loop?: boolean): SugarDefaultChainable<T>;\n      camelize(upper?: boolean): SugarDefaultChainable<string>;\n      capitalize(lower?: boolean, all?: boolean): SugarDefaultChainable<string>;\n      chars<T>(eachCharFn?: (char: string, i: number, arr: Array<string>) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      codes<T>(eachCodeFn?: (code: number, i: number, str: string) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      compact(): SugarDefaultChainable<string>;\n      dasherize(): SugarDefaultChainable<string>;\n      decodeBase64(): SugarDefaultChainable<string>;\n      encodeBase64(): SugarDefaultChainable<string>;\n      escapeHTML(): SugarDefaultChainable<string>;\n      escapeURL(param?: boolean): SugarDefaultChainable<string>;\n      first(n?: number): SugarDefaultChainable<string>;\n      forEach<T>(search?: string|RegExp, eachFn?: (match: string, i: number, arr: Array<string>) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      forEach<T>(eachFn: (match: string, i: number, arr: Array<string>) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      format(...args: any[]): SugarDefaultChainable<string>;\n      from(index?: number): SugarDefaultChainable<string>;\n      insert(str: string, index?: number): SugarDefaultChainable<string>;\n      isBlank(): SugarDefaultChainable<boolean>;\n      isEmpty(): SugarDefaultChainable<boolean>;\n      last(n?: number): SugarDefaultChainable<string>;\n      lines<T>(eachLineFn?: (line: string, i: number, arr: Array<string>) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      pad(num: number, padding?: string): SugarDefaultChainable<string>;\n      padLeft(num: number, padding?: string): SugarDefaultChainable<string>;\n      padRight(num: number, padding?: string): SugarDefaultChainable<string>;\n      parameterize(): SugarDefaultChainable<string>;\n      remove(f: string|RegExp): SugarDefaultChainable<string>;\n      removeAll(f: string|RegExp): SugarDefaultChainable<string>;\n      removeTags(tag?: string, replace?: string|replaceFn): SugarDefaultChainable<string>;\n      replaceAll(f: string|RegExp, ...args: any[]): SugarDefaultChainable<string>;\n      reverse(): SugarDefaultChainable<string>;\n      shift<T>(n: number): SugarDefaultChainable<T[]>;\n      spacify(): SugarDefaultChainable<string>;\n      stripTags(tag?: string, replace?: string|replaceFn): SugarDefaultChainable<string>;\n      titleize(): SugarDefaultChainable<string>;\n      to(index?: number): SugarDefaultChainable<string>;\n      toNumber(base?: number): SugarDefaultChainable<number>;\n      trimLeft(): SugarDefaultChainable<string>;\n      trimRight(): SugarDefaultChainable<string>;\n      truncate(length: number, from?: string, ellipsis?: string): SugarDefaultChainable<string>;\n      truncateOnWord(length: number, from?: string, ellipsis?: string): SugarDefaultChainable<string>;\n      underscore(): SugarDefaultChainable<string>;\n      unescapeHTML(): SugarDefaultChainable<string>;\n      unescapeURL(partial?: boolean): SugarDefaultChainable<string>;\n      words<T>(eachWordFn?: (word: string, i: number, arr: Array<string>) => SugarDefaultChainable<void>): SugarDefaultChainable<T[]>;\n      anchor(name: string): SugarDefaultChainable<string>;\n      big(): SugarDefaultChainable<string>;\n      blink(): SugarDefaultChainable<string>;\n      bold(): SugarDefaultChainable<string>;\n      charAt(pos: number): SugarDefaultChainable<string>;\n      charCodeAt(index: number): SugarDefaultChainable<number>;\n      codePointAt(pos: number): SugarDefaultChainable<number | undefined>;\n      concat(...strings: string[]): SugarDefaultChainable<string>;\n      endsWith(searchString: string, endPosition?: number): SugarDefaultChainable<boolean>;\n      fixed(): SugarDefaultChainable<string>;\n      fontcolor(color: string): SugarDefaultChainable<string>;\n      fontsize(size: number): SugarDefaultChainable<string>;\n      fontsize(size: string): SugarDefaultChainable<string>;\n      includes(searchString: string, position?: number): SugarDefaultChainable<boolean>;\n      indexOf(searchString: string, position?: number): SugarDefaultChainable<number>;\n      italics(): SugarDefaultChainable<string>;\n      lastIndexOf(searchString: string, position?: number): SugarDefaultChainable<number>;\n      link(url: string): SugarDefaultChainable<string>;\n      localeCompare(that: string): SugarDefaultChainable<number>;\n      localeCompare(that: string, locales?: string | string[], options?: Intl.CollatorOptions): SugarDefaultChainable<number>;\n      match(regexp: RegExp): SugarDefaultChainable<RegExpMatchArray | null>;\n      match(regexp: string): SugarDefaultChainable<RegExpMatchArray | null>;\n      normalize(form?: string): SugarDefaultChainable<string>;\n      normalize(form: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): SugarDefaultChainable<string>;\n      repeat(count: number): SugarDefaultChainable<string>;\n      replace(searchValue: string, replaceValue: string): SugarDefaultChainable<string>;\n      replace(searchValue: string, replacer: (substring: string, ...args: any[]) => string): SugarDefaultChainable<string>;\n      replace(searchValue: RegExp, replaceValue: string): SugarDefaultChainable<string>;\n      replace(searchValue: RegExp, replacer: (substring: string, ...args: any[]) => string): SugarDefaultChainable<string>;\n      search(regexp: RegExp): SugarDefaultChainable<number>;\n      search(regexp: string): SugarDefaultChainable<number>;\n      slice(start?: number, end?: number): SugarDefaultChainable<string>;\n      small(): SugarDefaultChainable<string>;\n      split(separator: string, limit?: number): SugarDefaultChainable<string[]>;\n      split(separator: RegExp, limit?: number): SugarDefaultChainable<string[]>;\n      startsWith(searchString: string, position?: number): SugarDefaultChainable<boolean>;\n      strike(): SugarDefaultChainable<string>;\n      sub(): SugarDefaultChainable<string>;\n      substr(from: number, length?: number): SugarDefaultChainable<string>;\n      substring(start: number, end?: number): SugarDefaultChainable<string>;\n      sup(): SugarDefaultChainable<string>;\n      toLocaleLowerCase(): SugarDefaultChainable<string>;\n      toLocaleUpperCase(): SugarDefaultChainable<string>;\n      toLowerCase(): SugarDefaultChainable<string>;\n      toUpperCase(): SugarDefaultChainable<string>;\n      trim(): SugarDefaultChainable<string>;\n    }\n\n  }\n\n}\n\ndeclare module \"sugar\" {\n  const Sugar: sugarjs.Sugar;\n  export = Sugar;\n}\n\ndeclare var Sugar: sugarjs.Sugar;"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}