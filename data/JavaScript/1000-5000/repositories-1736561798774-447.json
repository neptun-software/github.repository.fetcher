{
  "metadata": {
    "timestamp": 1736561798774,
    "page": 447,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "apostrophecms/sanitize-html",
      "stars": 3883,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".eslintignore",
          "type": "blob",
          "size": 0.0126953125,
          "content": "node_modules\n"
        },
        {
          "name": ".eslintrc",
          "type": "blob",
          "size": 0.1474609375,
          "content": "{\n  \"extends\": \"apostrophe\",\n  \"rules\": {\n    \"no-console\": [\n      \"error\",\n      {\n        \"allow\": [\n          \"warn\"\n        ]\n      }\n    ]\n  }\n}\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1103515625,
          "content": "package-lock.json\nnpm-debug.log\n*.DS_Store\nnode_modules\n.idea\n# We do not commit CSS, only LESS\npublic/css/*.css\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 26.4853515625,
          "content": "# Changelog\n\n## 2.14.0 (2024-12-18)\n\n- Fix adding text with `transformTags` in cases where it originally had no text child elements. Thanks to [f0x](https://cthu.lu).\n\n## 2.13.1 (2024-10-03)\n\n- Fix to allow regex in `allowedClasses` wildcard whitelist. Thanks to `anak-dev`.\n\n## 2.13.0 (2024-03-20)\n\n- Documentation update regarding minimum supported TypeScript version.\n\n- Added disallowedTagsMode: `completelyDiscard` option to remove the content also in HTML. Thanks to [Gauav Kumar](https://github.com/gkumar9891) for this addition.\n\n## 2.12.1 (2024-02-22)\n\n- Do not parse sourcemaps in `post-css`. This fixes a vulnerability in which information about the existence or non-existence of files on a server could be disclosed via properly crafted HTML input when the `style` attribute is allowed by the configuration. Thanks to the [Snyk Security team](https://snyk.io/) for the disclosure and to [Dylan Armstrong](https://dylan.is/) for the fix.\n\n## 2.12.0 (2024-02-21)\n\n- Introduced the `allowedEmptyAttributes` option, enabling explicit specification of empty string values for select attributes, with the default attribute set to `alt`. Thanks to [Na](https://github.com/zhna123) for the contribution.\n\n- Clarified the use of SVGs with a new test and changes to documentation. Thanks to [Gauav Kumar](https://github.com/gkumar9891) for the contribution.\n\n- Do not process source maps when processing style tags with PostCSS.\n\n## 2.11.0 (2023-06-21)\n\n- Fix to allow `false` in `allowedClasses` attributes. Thanks to [Kevin Jiang](https://github.com/KevinSJ) for this fix!\n- Upgrade mocha version\n- Apply small linter fixes in tests\n- Add `.idea` temp files to `.gitignore`\n- Thanks to [Vitalii Shpital](https://github.com/VitaliiShpital) for the updates!\n- Show parseStyleAttributes warning in browser only. Thanks to [mog422](https://github.com/mog422) for this update!\n- Remove empty non-boolean attributes via an exhaustive, configurable list of known non-boolean attributes. [Thanks to Dylan Armstrong](https://github.com/dylanarmstrong) for this update!\n\n## 2.10.0 (2023-02-17)\n\n- Fix auto-adding escaped closing tags. In other words, do not add implied closing tags to disallowed tags when `disallowedTagMode` is set to any variant of `escape` -- just escape the disallowed tags that are present. This fixes [issue #464](https://github.com/apostrophecms/sanitize-html/issues/464). Thanks to [Daniel Liebner](https://github.com/dliebner)\n- Add `tagAllowed()` helper function which takes a tag name and checks it against `options.allowedTags` and returns `true` if the tag is allowed and `false` if it is not.\n\n## 2.9.0 (2023-01-27)\n\n- Add option parseStyleAttributes to skip style parsing. This fixes [issue #547](https://github.com/apostrophecms/sanitize-html/issues/547). Thanks to [Bert Verhelst](https://github.com/bertyhell).\n\n## 2.8.1 (2022-12-21)\n\n- If the argument is a number, convert it to a string, for backwards compatibility. Thanks to [Alexander Schranz](https://github.com/alexander-schranz).\n\n## 2.8.0 (2022-12-12)\n\n- Upgrades `htmlparser2` to new major version `^8.0.0`. Thanks to [Kedar Chandrayan](https://github.com/kedarchandrayan) for this contribution.\n\n## 2.7.3 (2022-10-24)\n\n- If allowedTags is falsy but not exactly `false`, then do not assume that all tags are allowed. Rather, allow no tags in this case, to be on the safe side. This matches the existing documentation and fixes [issue #176](https://github.com/apostrophecms/sanitize-html/issues/176). Thanks to [Kedar Chandrayan](https://github.com/kedarchandrayan) for the fix.\n\n## 2.7.2 (2022-09-15)\n\n- Closing tags must agree with opening tags. This fixes [issue #549](https://github.com/apostrophecms/sanitize-html/issues/549), in which closing tags not associated with any permitted opening tag could be passed through. No known exploit exists, but it's better not to permit this. Thanks to \n[Kedar Chandrayan](https://github.com/kedarchandrayan) for the report and the fix.\n\n## 2.7.1 (2022-07-20)\n\n- Protocol-relative URLs are properly supported for script tags. Thanks to [paweljq](https://github.com/paweljq).\n- A denial-of-service vulnerability has been fixed by replacing global regular expression replacement logic for comment removal with a new implementation. Thanks to Nariyoshi Chida of NTT Security Japan for pointing out the issue.\n\n## 2.7.0 (2022-02-04)\n\n- Allows a more sensible set of default attributes on `<img />` tags. Thanks to [Zade Viggers](https://github.com/zadeviggers).\n\n## 2.6.1 (2021-12-08)\n\n- Fixes style filtering to retain `!important` when used.\n- Fixed trailing text bug on `transformTags` options that was reported on [issue #506](https://github.com/apostrophecms/sanitize-html/issues/506). Thanks to [Alex Rantos](https://github.com/alex-rantos).\n\n## 2.6.0 (2021-11-23)\n\n- Support for regular expressions in the `allowedClasses` option. Thanks to [Alex Rantos](https://github.com/alex-rantos).\n\n## 2.5.3 (2021-11-02):\n\n- Fixed bug introduced by klona 2.0.5, by removing klona entirely.\n\n## 2.5.2 (2021-10-13):\n\n- Nullish HTML input now returns an empty string. Nullish value may be explicit `null`, `undefined` or implicit `undefined` when value is not provided. Thanks to Artem Kostiuk for the contribution.\n- Documented that all text content is escaped. Thanks to Siddharth Singh.\n\n## 2.5.1 (2021-09-14):\n- The `allowedScriptHostnames` and `allowedScriptDomains` options now implicitly purge the inline content of all script tags, not just those with `src` attributes. This behavior was already strongly implied by the fact that they purged it in the case where a `src` attribute was actually present, and is necessary for the feature to provide any real security. Thanks to Grigorii Duca for pointing out the issue.\n\n## 2.5.0 (2021-09-08):\n\n- New `allowedScriptHostnames` option, it enables you to specify which hostnames are allowed in a script tag.\n- New `allowedScriptDomains` option, it enables you to specify which domains are allowed in a script tag. Thank you to [Yorick Girard](https://github.com/yorickgirard) for this and the `allowedScriptHostnames` contribution.\n- Updates whitelist to allowlist.\n\n## 2.4.0 (2021-05-19):\n- Added support for class names with wildcards in `allowedClasses`. Thanks to [zhangbenber](https://github.com/zhangbenber) for the contribution.\n\n## 2.3.3 (2021-03-19):\n- Security fix: `allowedSchemes` and related options did not properly block schemes containing a hyphen, plus sign, period or digit, such as `ms-calculator:`. Thanks to Lukas Euler for pointing out the issue.\n- Added a security note about the known risks associated with using the `parser` option, especially `decodeEntities: false`. See the documentation.\n\n## 2.3.2 (2021-01-26):\n\n- Additional fixes for iframe validation exploits. Prevent exploits based on browsers' tolerance of the use of \"\\\" rather than \"/\" and the presence of whitespace at this point in the URL. Thanks to Ron Masas of [Checkmarx](https://www.checkmarx.com/) for pointing out the issue and writing unit tests.\n- Updates README `yarn add` syntax. Thanks to [Tagir Khadshiev](https://github.com/Aspedm) for the contribution.\n\n## 2.3.1 (2021-01-22):\n- Uses the standard WHATWG URL parser to stop IDNA (Internationalized Domain Name) attacks on the iframe hostname validator. Thanks to Ron Masas of [Checkmarx](https://www.checkmarx.com/) for pointing out the issue and suggesting the use of the WHATWG parser.\n\n## 2.3.0 (2020-12-16):\n- Upgrades `htmlparser2` to new major version `^6.0.0`. Thanks to [Bogdan Chadkin](https://github.com/TrySound) for the contribution.\n\n## 2.2.0 (2020-12-02):\n- Adds a note to the README about Typescript support (or the lack-thereof).\n- Adds `tel` to the default `allowedSchemes`. Thanks to [Arne Herbots](https://github.com/aHerbots) for this contribution.\n\n## 2.1.2 (2020-11-04):\n- Fixes typos and inconsistencies in the README. Thanks to [Eric Lefevre-Ardant](https://github.com/elefevre) for this contribution.\n\n## 2.1.1 (2020-10-21):\n- Fixes a bug when using `allowedClasses` with an `'*'` wildcard selector. Thanks to [Clemens Damke](https://github.com/Cortys) for this contribution.\n- Updates mocha to 7.x to resolve security warnings.\n\n## 2.1.0 (2020-10-07):\n- `sup` added to the default allowed tags list. Thanks to [Julian Lam](https://github.com/julianlam) for the contribution.\n- Updates default `allowedTags` README documentation. Thanks to [Marco Arduini](https://github.com/nerfologist) for the contribution.\n\n## 2.0.0 (2020-09-23):\n- `nestingLimit` option added.\n- Updates ESLint config package and fixes warnings.\n- Upgrade `is-plain-object` package with named export. Thanks to [Bogdan Chadkin](https://github.com/TrySound) for the contribution.\n- Upgrade `postcss` package and drop Node 11 and Node 13 support (enforced by postcss).\n\n### Backwards compatibility breaks:\n- There is no build. You should no longer directly link to a sanitize-html file directly in the browser as it is using modern Javascript that is not fully supported by all major browsers (depending on your definition). You should now include sanitize-html in your project build for this purpose if you have one.\n- On the server side, Node.js 10 or higher is required.\n- The default `allowedTags` array was updated significantly. This mostly added HTML tags to be more comprehensive by default. You should review your projects and consider the `allowedTags` defaults if you are not already overriding them.\n\n## 2.0.0-rc.2 (2020-09-09):\n- Always use existing `has` function rather than duplicating it.\n\n## 2.0.0-rc.1 (2020-08-26):\n- Upgrade `klona` package. Thanks to [Bogdan Chadkin](https://github.com/TrySound) for the contribution.\n\n## 2.0.0-beta.2:\n- Add `files` to `package.json` to prevent publishing unnecessary files to npm #392. Thanks to [styfle](https://github.com/styfle) for the contribution.\n- Removes `iframe` and `nl` from default allowed tags. Adds most innocuous tags to the default `allowedTags` array.\n- Fixes a bug when using `transformTags` with out `textFilter`. Thanks to [Andrzej Porebski](https://github.com/andpor) for the help with a failing test.\n\n## 2.0.0-beta:\n- Moves the `index.js` file to the project root and removes all build steps within the package. Going forward, it is up to the developer to include sanitize-html in their project builds as-needed. This removes major points of conflict with project code and frees this module to not worry about myriad build-related questions.\n- Replaces lodash with utility packages: klona, is-plain-object, deepmerge, escape-string-regexp.\n- Makes custom tag transformations less error-prone by escaping frame `innerText`. Thanks to [Mike Samuel](https://github.com/mikesamuel) for the contribution. Prior to this patch, tag transformations which turned an attribute\nvalue into a text node could be vulnerable to code execution.\n- Updates code to use modern features including `const`/`let` variable assignment.\n- ESLint clean up.\n- Updates `is-plain-object` to the 4.x major version.\n- Updates `srcset` to the 3.x major version.\n\nThanks to [Bogdan Chadkin](https://github.com/TrySound) for contributions to this major version update.\n\n## 1.27.5 (2020-09-23):\n- Updates README to include ES modules syntax.\n\n## 1.27.4 (2020-08-26):\n- Fixes an IE11 regression from using `Array.prototype.includes`, replacing it with `Array.prototype.indexOf`.\n\n## 1.27.3 (2020-08-12):\n- Fixes a bug when using `transformTags` with out `textFilter`. Thanks to [Andrzej Porebski](https://github.com/andpor) for the help with a failing test.\n\n## 1.27.2 (2020-07-29):\n- Fixes CHANGELOG links. Thanks to [Alex Mayer](https://github.com/amayer5125) for the contribution.\n- Replaces `srcset` with `parse-srcset`. Thanks to [Massimiliano Mirra](https://github.com/bard) for the contribution.\n\n## 1.27.1 (2020-07-15):\n- Removes the unused chalk dependency.\n- Adds configuration for a Github stale bot.\n- Replace `xtend` package with native `Object.assign`.\n\n## 1.27.0:\n- Adds the `allowedIframeDomains` option. This works similar to `allowedIframeHostnames`, where you would set it to an array of web domains. It would then permit any hostname on those domains to be used in iframe `src` attributes. Thanks to [Stanislav Kravchenko](https://github.com/StanisLove) for the contribution.\n\n## 1.26.0:\n- Adds the `option` element to the default `nonTextTagsArray` of tags with contents that aren't meant to be displayed visually as text. This can be overridden with the `nonTextTags` option.\n\n## 1.25.0:\n- Adds `enforceHtmlBoundary` option to process code bounded by the `html` tag, discarding any code outside of those tags.\n- Migrates to the main lodash package from the per method packages since they are deprecated and cause code duplication. Thanks to [Merceyz](https://github.com/merceyz) for the contribution.\n- Adds a warning when `style` and `script` tags are allowed, as they are inherently vulnerable to being used in XSS attacks. That warning can be disabled by including the option `allowVulnerableTags: true` so this choice is knowing and explicit.\n\n## 1.24.0:\n- Fixes a bug where self-closing tags resulted in deletion with `disallowedTagsMode: 'escape'` set. Thanks to [Thiago Negri](https://github.com/thiago-negri) for the contribution.\n- Adds `abbr` to the default `allowedTags` for better accessibility support. Thanks to [Will Farrell](https://github.com/willfarrell) for the contribution.\n- Adds a `mediaChildren` property to the `frame` object in custom filters. This allows you to check for links or other parent tags that contain self-contained media to prevent collapse, regardless of whether there is also text inside. Thanks to [axdg](https://github.com/axdg) for the initial implementation and [Marco Arduini](https://github.com/nerfologist) for a failing test contribution.\n\n## 1.23.0:\n- Adds eslint configuration and adds eslint to test script.\n- Sets `sideEffects: false` on package.json to allow module bundlers like webpack tree-shake this module and all the dependencies from client build. Thanks to [Egor Voronov](https://github.com/egorvoronov) for the contribution.\n- Adds the `tagName` (HTML element name) as a second parameter passed to `textFilter`. Thanks to [Slava](https://github.com/slavaGanzin) for the contribution.\n\n## 1.22.1:\nncreases the patch version of `lodash.mergewith` to enforce an audit fix.\n\n## 1.22.0:\nbumped `htmlparser2` dependency to the 4.x series. This fixes longstanding bugs and should cause no bc breaks for this module, since the only bc breaks upstream are in regard to features we don't expose in this module.\n\n## 1.21.1:\nfixed issue with bad `main` setting in package.json that broke 1.21.0.\n\n## 1.21.0:\nnew `disallowedTagsMode` option can be set to `escape` to escape disallowed tags rather than discarding them. Any subtags are handled as usual. If you want to recursively escape them too, you can set `disallowedTagsMode` to `recursiveEscape`. Thanks to Yehonatan Zecharia for this contribution.\n\n## 1.20.1:\nFix failing tests, add CircleCI config\n\n## 1.20.0:\nreduced size of npm package via the `files` key; we only need to publish what's in `dist`. Thanks to Steven. There should be zero impact on behavior, minor version bump is precautionary.\n\n## 1.19.3:\nreverted to `postcss` due to a [reported issue with `css-tree` that might or might not have XSS implications](https://github.com/punkave/sanitize-html/issues/269).\n\n## 1.19.2:\n\n* Switched out the heavy `postcss` dependency for the lightweight `css-tree` module. No API changes. Thanks to Justin Braithwaite.\n* Various doc updates. Thanks to Pulkit Aggarwal and Cody Robertson.\n\n## 1.19.1:\n\n* `\"` characters are now entity-escaped only when they appear in attribute values, reducing the verbosity of the resulting markup.\n\n* Fixed a regression introduced in version 1.18.5 in the handling of markup that looks similar to a valid entity, but isn't. The bogus entity was passed through intact, i.e. `&0;` did not become `&amp;0;` as it should have. This fix has been made for the default parser settings only. There is no fix yet for those who wish to enable `decodeEntities: false`. That will require improving the alternative encoder in the `escapeHtml` function to only pass 100% valid entities.\n\n**For those using the default `parser` settings this bug is fixed.** Read on if you are using alternative `parser` settings.\n\nWhen `decodeEntities: true` is in effect (the default), this is not a problem because we only have to encode `& < > \"` and we always encode those things.\n\nThere is currently a commented-out test which verifies one example of the problem when `decodeEntities` is false. However a correct implementation would need to not only pass that simple example but correctly escape all invalid entities, and not escape those that are valid.\n\n## 1.19.0:\n\n* New `allowIframeRelativeUrls` option. It defaults to `true` unless `allowedIframeHostnames` is present, in which case it defaults to false, for backwards compatibility with existing behavior in both cases; however you can now set the option explicitly to allow both certain hostnames and relative URLs. Thanks to Rick Martin.\n\n## 1.18.5:\n\n* Stop double encoding ampersands on HTML entities. Thanks to Will Gibson.\n\n## 1.18.4:\n\n* Removed incorrect `browser` key, restoring frontend build. Thanks to Felix Becker.\n\n## 1.18.3:\n\n* `iframe` is an allowed tag by default, to better facilitate typical use cases and the use of the `allowedIframeHostnames` option.\n* Documentation improvements.\n* More browser packaging improvements.\n* Protocol-relative URLs are properly supported for iframe tags.\n\n## 1.18.2:\n\n* Travis tests passing.\n* Fixed another case issue — and instituted Travis CI testing so this doesn't happen again. Sorry for the hassle.\n\n## 1.18.1:\n\n* A file was required with incorrect case, breaking the library on case sensitive filesystems such as Linux. Fixed.\n\n## 1.18.0:\n\n* The new `allowedSchemesAppliedToAttributes` option. This determines which attributes are validated as URLs, replacing the old hardcoded list of `src` and `href` only. The default list now includes `cite`. Thanks to ml-dublin for this contribution.\n* It is now easy to configure a specific list of allowed values for an attribute. When configuring `allowedAttributes`, rather than listing an attribute name, simply list an object with an attribute `name` property and an allowed `values` array property. You can also add `multiple: true` to allow multiple space-separated allowed values in the attribute, otherwise the attribute must match one and only one of the allowed values. Thanks again to ml-dublin for this contribution.\n* Fixed a bug in the npm test procedure.\n\n## 1.17.0:\nThe new `allowedIframeHostnames` option. If present, this must be an array, and only iframe `src` URLs hostnames (complete hostnames; domain name matches are not enough) that appear on this list are allowed. You must also configure `hostname` as an allowed attribute for `iframe`. Thanks to Ryan Verys for this contribution.\n\n## 1.16.3:\nDon't throw away the browserified versions before publishing them. `prepare` is not a good place to `make clean`, it runs after `prepublish`.\n\n## 1.16.2:\n`sanitize-html` is now compiled with `babel`. An npm `prepublish` script takes care of this at `npm publish` time, so the latest code should always be compiled to operate all the way back to ES5 browsers and earlier versions of Node. Thanks to Ayushya Jaiswal.\n\nPlease note that running `sanitize-html` in the browser is usually a security hole. Are you trusting the browser? Anyone could bypass that using the network panel. Sanitization is almost always best done on servers and that is the primary use case for this module.\n\n## 1.16.1:\nchangelog formatting only.\n\n## 1.16.0:\nsupport for sanitizing inline CSS styles, by specifying the allowed attributes and a regular expression for each. Thanks to Cameron Will and Michael Loschiavo.\n\n## 1.15.0:\nif configured as an allowed attribute (not the default), check for naughty URLs in `srcset` attributes. Thanks to Mike Samuel for the nudge to do this and to Sindre Sorhus for the `srcset` module.\n\n## 1.14.3:\ninadvertent removal of lodash regexp quote dependency in 1.14.2 has been corrected.\n\n## 1.14.2:\nprotocol-relative URL detection must spot URLs starting with `\\\\` rather than `//` due to ages-old tolerance features of web browsers, intended for sleepy Windows developers. Thanks to Martin Bajanik.\n\n## 1.14.1:\ndocumented `allowProtocolRelative` option. No code changes from 1.14.0, released a few moments ago.\n\n## 1.14.0:\nthe new `allowProtocolRelative` option, which is set to `true` by default, allows you to decline to accept URLs that start with `//` and thus point to a different host using the current protocol. If you do **not** want to permit this, set this option to `false`. This is fully backwards compatible because the default behavior is to allow them. Thanks to Luke Bernard.\n\n## 1.13.0:\n`transformTags` can now add text to an element that initially had none. Thanks to Dushyant Singh.\n\n## 1.12.0:\noption to build for browser-side use. Thanks to Michael Blum.\n\n## 1.11.4:\nfixed crash when `__proto__` is a tag name. Now using a safe check for the existence of properties in all cases. Thanks to Andrew Krasichkov.\n\nFixed XSS attack vector via `textarea` tags (when explicitly allowed). Decided that `script` (obviously) and `style` (due to its own XSS vectors) cannot realistically be afforded any XSS protection if allowed, unless we add a full CSS parser. Thanks again to Andrew Krasichkov.\n\n## 1.11.3:\nbumped `htmlparser2` version to address crashing bug in older version. Thanks to e-jigsaw.\n\n## 1.11.2:\nfixed README typo that interfered with readability due to markdown issues. No code changes. Thanks to Mikael Korpela. Also improved code block highlighting in README. Thanks to Alex Siman.\n\n## 1.11.1:\nfixed a regression introduced in 1.11.0 which caused the closing tag of the parent of a `textarea` tag to be lost. Thanks to Stefano Sala, who contributed the missing test.\n\n## 1.11.0:\nadded the `nonTextTags` option, with tests.\n\n## 1.10.1:\ndocumentation cleanup. No code changes. Thanks to Rex Schrader.\n\n## 1.10.0:\n`allowedAttributes` now allows you to allow attributes for all tags by specifying `*` as the tag name. Thanks to Zdravko Georgiev.\n\n## 1.9.0:\n`parser` option allows options to be passed directly to `htmlparser`. Thanks to Danny Scott.\n\n## 1.8.0:\n\n* `transformTags` now accepts the `*` wildcard to transform all tags. Thanks to Jamy Timmermans.\n\n* Text that has been modified by `transformTags` is then passed through `textFilter`. Thanks to Pavlo Yurichuk.\n\n* Content inside `textarea` is discarded if `textarea` is not allowed. I don't know why it took me this long to see that this is just common sense. Thanks to David Frank.\n\n## 1.7.2:\nremoved `array-includes` dependency in favor of `indexOf`, which is a little more verbose but slightly faster and doesn't require a shim. Thanks again to Joseph Dykstra.\n\n## 1.7.1:\nremoved lodash dependency, adding lighter dependencies and polyfills in its place. Thanks to Joseph Dykstra.\n\n## 1.7.0:\nintroduced `allowedSchemesByTag` option. Thanks to Cameron Will.\n\n## 1.6.1:\nthe string `'undefined'` (as opposed to `undefined`) is perfectly valid text and shouldn't be expressly converted to the empty string.\n\n## 1.6.0:\nadded `textFilter` option. Thanks to Csaba Palfi.\n\n## 1.5.3:\ndo not escape special characters inside a script or style element, if they are allowed. This is consistent with the way browsers parse them; nothing closes them except the appropriate closing tag for the entire element. Of course, this only comes into play if you actually choose to allow those tags. Thanks to aletorrado.\n\n## 1.5.2:\nguard checks for allowed attributes correctly to avoid an undefined property error. Thanks to Zeke.\n\n## 1.5.1:\nupdated to htmlparser2 1.8.x. Started using the `decodeEntities` option, which allows us to pass our filter evasion tests without the need to recursively invoke the filter.\n\n## 1.5.0:\nsupport for `*` wildcards in allowedAttributes. With tests. Thanks to Calvin Montgomery.\n\n## 1.4.3:\ninvokes itself recursively until the markup stops changing to guard against [this issue](https://github.com/fb55/htmlparser2/issues/105). Bump to htmlparser2 version 3.7.x.\n\n## 1.4.1, 1.4.2:\nmore tests.\n\n## 1.4.0:\nability to  allow all attributes or tags through by setting `allowedAttributes` and/or `allowedTags` to false. Thanks to Anand Thakker.\n\n## 1.3.0:\n`attribs` now available on frames passed to exclusive filter.\n\n## 1.2.3:\nfixed another possible XSS attack vector; no definitive exploit was found but it looks possible. [See this issue.](https://github.com/punkave/sanitize-html/pull/20) Thanks to Jim O'Brien.\n\n## 1.2.2:\nreject `javascript:` URLs when disguised with an internal comment. This is probably not respected by browsers anyway except when inside an XML data island element, which you almost certainly are not allowing in your `allowedTags`, but we aim to be thorough. Thanks to Jim O'Brien.\n\n## 1.2.1:\nfixed crashing bug when presented with bad markup. The bug was in the `exclusiveFilter` mechanism. Unit test added. Thanks to Ilya Kantor for catching it.\n\n## 1.2.0:\n* The `allowedClasses` option now allows you to permit CSS classes in a fine-grained way.\n\n* Text passed to your `exclusiveFilter` function now includes the text of child elements, making it more useful for identifying elements that truly lack any inner text.\n\n## 1.1.7:\nuse `he` for entity decoding, because it is more actively maintained.\n\n## 1.1.6:\n`allowedSchemes` option for those who want to permit `data` URLs and such.\n\n## 1.1.5:\njust a packaging thing.\n\n## 1.1.4:\ncustom exclusion filter.\n\n## 1.1.3:\nmoved to lodash. 1.1.2 pointed to the wrong version of lodash.\n\n## 1.1.0:\nthe `transformTags` option was added. Thanks to [kl3ryk](https://github.com/kl3ryk).\n\n## 1.0.3:\nfixed several more javascript URL attack vectors after [studying the XSS filter evasion cheat sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet) to better understand my enemy. Whitespace characters (codes from 0 to 32), which browsers ignore in URLs in certain cases allowing the \"javascript\" scheme to be snuck in, are now stripped out when checking for naughty URLs. Thanks again to [pinpickle](https://github.com/pinpickle).\n\n## 1.0.2:\nfixed a javascript URL attack vector. naughtyHref must entity-decode URLs and also check for mixed-case scheme names. Thanks to [pinpickle](https://github.com/pinpickle).\n\n## 1.0.1:\nDoc tweaks.\n\n## 1.0.0:\nIf the style tag is disallowed, then its content should be dumped, so that it doesn't appear as text. We were already doing this for script tags, however in both cases the content is now preserved if the tag is explicitly allowed.\n\nWe're rocking our tests and have been working great in production for months, so: declared 1.0.0 stable.\n\n## 0.1.3:\ndo not double-escape entities in attributes or text. Turns out the \"text\" provided by htmlparser2 is already escaped.\n\n## 0.1.2:\npackaging error meant it wouldn't install properly.\n\n## 0.1.1:\ndiscard the text of script tags.\n\n## 0.1.0:\ninitial release.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "Copyright (c) 2013, 2014, 2015 P'unk Avenue LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 28.05078125,
          "content": "# sanitize-html\n\n<a href=\"https://apostrophecms.com/\"><img src=\"https://raw.githubusercontent.com/apostrophecms/sanitize-html/main/logos/logo-box-madefor.png\" align=\"right\" /></a>\n\nsanitize-html provides a simple HTML sanitizer with a clear API.\n\nsanitize-html is tolerant. It is well suited for cleaning up HTML fragments such as those created by CKEditor and other rich text editors. It is especially handy for removing unwanted CSS when copying and pasting from Word.\n\nsanitize-html allows you to specify the tags you want to permit, and the permitted\nattributes for each of those tags. If an attribute is a known non-boolean value,\nand it is empty, it will be removed. For example `checked` can be empty, but `href`\ncannot.\n\nIf a tag is not permitted, the contents of the tag are not discarded. There are\nsome exceptions to this, discussed below in the \"Discarding the entire contents\nof a disallowed tag\" section.\n\nThe syntax of poorly closed `p` and `img` elements is cleaned up.\n\n`href` attributes are validated to ensure they only contain `http`, `https`, `ftp` and `mailto` URLs. Relative URLs are also allowed. Ditto for `src` attributes.\n\nAllowing particular urls as a `src` to an iframe tag by filtering hostnames is also supported.\n\nHTML comments are not preserved.\nAdditionally, `sanitize-html` escapes _ALL_ text content - this means that ampersands, greater-than, and less-than signs are converted to their equivalent HTML character references (`&` --> `&amp;`, `<` --> `&lt;`, and so on). Additionally, in attribute values, quotation marks are escaped as well (`\"` --> `&quot;`).\n\n## Requirements\n\nsanitize-html is intended for use with Node.js and supports Node 10+. All of its npm dependencies are pure JavaScript. sanitize-html is built on the excellent `htmlparser2` module.\n\n### Regarding TypeScript\n\nsanitize-html is not written in TypeScript and there is no plan to directly support it. There is a community supported typing definition, [`@types/sanitize-html`](https://www.npmjs.com/package/@types/sanitize-html), however.\n```bash\nnpm install -D @types/sanitize-html\n```\nIf `esModuleInterop=true` is not set in your `tsconfig.json` file, you have to import it with:\n\n```javascript\nimport * as sanitizeHtml from 'sanitize-html';\n```\n\nWhen using TypeScript, there is a minimum supported version of >=4.5 because of a dependency on the `htmlparser2` types.\n\nAny questions or problems while using `@types/sanitize-html` should be directed to its maintainers as directed by that project's contribution guidelines.\n\n## How to use\n\n### Browser\n\n*Think first: why do you want to use it in the browser?* Remember, *servers must never trust browsers.* You can't sanitize HTML for saving on the server anywhere else but on the server.\n\nBut, perhaps you'd like to display sanitized HTML immediately in the browser for preview. Or ask the browser to do the sanitization work on every page load. You can if you want to!\n\n* Install the package:\n\n```bash\nnpm install sanitize-html\n```\nor\n```\nyarn add sanitize-html\n```\n\nThe primary change in the 2.x version of sanitize-html is that it no longer includes a build that is ready for browser use. Developers are expected to include sanitize-html in their project builds (e.g., webpack) as they would any other dependency. So while sanitize-html is no longer ready to link to directly in HTML, developers can now more easily process it according to their needs.\n\nOnce built and linked in the browser with other project Javascript, it can be used to sanitize HTML strings in front end code:\n\n```javascript\nimport sanitizeHtml from 'sanitize-html';\n\nconst html = \"<strong>hello world</strong>\";\nconsole.log(sanitizeHtml(html));\nconsole.log(sanitizeHtml(\"<img src=x onerror=alert('img') />\"));\nconsole.log(sanitizeHtml(\"console.log('hello world')\"));\nconsole.log(sanitizeHtml(\"<script>alert('hello world')</script>\"));\n```\n\n### Node (Recommended)\n\nInstall module from console:\n\n```bash\nnpm install sanitize-html\n```\n\nImport the module:\n\n```js\n// In ES modules\nimport sanitizeHtml from 'sanitize-html';\n\n// Or in CommonJS\nconst sanitizeHtml = require('sanitize-html');\n```\n\nUse it in your JavaScript app:\n\n```js\nconst dirty = 'some really tacky HTML';\nconst clean = sanitizeHtml(dirty);\n```\n\nThat will allow our [default list of allowed tags and attributes](#default-options) through. It's a nice set, but probably not quite what you want. So:\n\n```js\n// Allow only a super restricted set of tags and attributes\nconst clean = sanitizeHtml(dirty, {\n  allowedTags: [ 'b', 'i', 'em', 'strong', 'a' ],\n  allowedAttributes: {\n    'a': [ 'href' ]\n  },\n  allowedIframeHostnames: ['www.youtube.com']\n});\n```\n\nBoom!\n\n### Default options\n\n```js\nallowedTags: [\n  \"address\", \"article\", \"aside\", \"footer\", \"header\", \"h1\", \"h2\", \"h3\", \"h4\",\n  \"h5\", \"h6\", \"hgroup\", \"main\", \"nav\", \"section\", \"blockquote\", \"dd\", \"div\",\n  \"dl\", \"dt\", \"figcaption\", \"figure\", \"hr\", \"li\", \"main\", \"ol\", \"p\", \"pre\",\n  \"ul\", \"a\", \"abbr\", \"b\", \"bdi\", \"bdo\", \"br\", \"cite\", \"code\", \"data\", \"dfn\",\n  \"em\", \"i\", \"kbd\", \"mark\", \"q\", \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\",\n  \"small\", \"span\", \"strong\", \"sub\", \"sup\", \"time\", \"u\", \"var\", \"wbr\", \"caption\",\n  \"col\", \"colgroup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"\n],\nnonBooleanAttributes: [\n  'abbr', 'accept', 'accept-charset', 'accesskey', 'action',\n  'allow', 'alt', 'as', 'autocapitalize', 'autocomplete',\n  'blocking', 'charset', 'cite', 'class', 'color', 'cols',\n  'colspan', 'content', 'contenteditable', 'coords', 'crossorigin',\n  'data', 'datetime', 'decoding', 'dir', 'dirname', 'download',\n  'draggable', 'enctype', 'enterkeyhint', 'fetchpriority', 'for',\n  'form', 'formaction', 'formenctype', 'formmethod', 'formtarget',\n  'headers', 'height', 'hidden', 'high', 'href', 'hreflang',\n  'http-equiv', 'id', 'imagesizes', 'imagesrcset', 'inputmode',\n  'integrity', 'is', 'itemid', 'itemprop', 'itemref', 'itemtype',\n  'kind', 'label', 'lang', 'list', 'loading', 'low', 'max',\n  'maxlength', 'media', 'method', 'min', 'minlength', 'name',\n  'nonce', 'optimum', 'pattern', 'ping', 'placeholder', 'popover',\n  'popovertarget', 'popovertargetaction', 'poster', 'preload',\n  'referrerpolicy', 'rel', 'rows', 'rowspan', 'sandbox', 'scope',\n  'shape', 'size', 'sizes', 'slot', 'span', 'spellcheck', 'src',\n  'srcdoc', 'srclang', 'srcset', 'start', 'step', 'style',\n  'tabindex', 'target', 'title', 'translate', 'type', 'usemap',\n  'value', 'width', 'wrap',\n  // Event handlers\n  'onauxclick', 'onafterprint', 'onbeforematch', 'onbeforeprint',\n  'onbeforeunload', 'onbeforetoggle', 'onblur', 'oncancel',\n  'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose',\n  'oncontextlost', 'oncontextmenu', 'oncontextrestored', 'oncopy',\n  'oncuechange', 'oncut', 'ondblclick', 'ondrag', 'ondragend',\n  'ondragenter', 'ondragleave', 'ondragover', 'ondragstart',\n  'ondrop', 'ondurationchange', 'onemptied', 'onended',\n  'onerror', 'onfocus', 'onformdata', 'onhashchange', 'oninput',\n  'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup',\n  'onlanguagechange', 'onload', 'onloadeddata', 'onloadedmetadata',\n  'onloadstart', 'onmessage', 'onmessageerror', 'onmousedown',\n  'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout',\n  'onmouseover', 'onmouseup', 'onoffline', 'ononline', 'onpagehide',\n  'onpageshow', 'onpaste', 'onpause', 'onplay', 'onplaying',\n  'onpopstate', 'onprogress', 'onratechange', 'onreset', 'onresize',\n  'onrejectionhandled', 'onscroll', 'onscrollend',\n  'onsecuritypolicyviolation', 'onseeked', 'onseeking', 'onselect',\n  'onslotchange', 'onstalled', 'onstorage', 'onsubmit', 'onsuspend',\n  'ontimeupdate', 'ontoggle', 'onunhandledrejection', 'onunload',\n  'onvolumechange', 'onwaiting', 'onwheel'\n],\ndisallowedTagsMode: 'discard',\nallowedAttributes: {\n  a: [ 'href', 'name', 'target' ],\n  // We don't currently allow img itself by default, but\n  // these attributes would make sense if we did.\n  img: [ 'src', 'srcset', 'alt', 'title', 'width', 'height', 'loading' ]\n},\n// Lots of these won't come up by default because we don't allow them\nselfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n// URL schemes we permit\nallowedSchemes: [ 'http', 'https', 'ftp', 'mailto', 'tel' ],\nallowedSchemesByTag: {},\nallowedSchemesAppliedToAttributes: [ 'href', 'src', 'cite' ],\nallowProtocolRelative: true,\nenforceHtmlBoundary: false,\nparseStyleAttributes: true\n```\n\n### Common use cases\n\n#### \"I like your set but I want to add one more tag. Is there a convenient way?\"\n\nSure:\n\n```js\nconst clean = sanitizeHtml(dirty, {\n  allowedTags: sanitizeHtml.defaults.allowedTags.concat([ 'img' ])\n});\n```\n\nIf you do not specify `allowedTags` or `allowedAttributes`, our default list is applied. So if you really want an empty list, specify one.\n\n#### \"What if I want to allow all tags or all attributes?\"\n\nSimple! Instead of leaving `allowedTags` or `allowedAttributes` out of the options, set either\none or both to `false`:\n\n```js\nallowedTags: false,\nallowedAttributes: false\n```\n\n#### \"What if I want to allow empty attributes, even for cases like href that normally don't make sense?\"\n\nVery simple! Set `nonBooleanAttributes` to `[]`.\n\n```js\nnonBooleanAttributes: []\n```\n\n#### \"What if I want to remove all empty attributes, including valid ones?\"\n\nAlso very simple! Set `nonBooleanAttributes` to `['*']`.\n\n**Note**: This will break common valid cases like `checked` and `selected`, so this is\nunlikely to be what you want. For most ordinary HTML use, it is best to avoid making\nthis change.\n\n```js\nnonBooleanAttributes: ['*']\n```\n\n#### \"What if I don't want to allow *any* tags?\"\n\nAlso simple!  Set `allowedTags` to `[]` and `allowedAttributes` to `{}`.\n\n```js\nallowedTags: [],\nallowedAttributes: {}\n```\n\n#### \"What if I want disallowed tags to be escaped rather than discarded?\"\n\nIf you set `disallowedTagsMode` to `discard` (the default), disallowed tags are discarded. Any text content or subtags are still included, depending on whether the individual subtags are allowed.\n\nIf you set `disallowedTagsMode` to `completelyDiscard`, disallowed tags and any content they contain are discarded. Any subtags are still included, as long as those individual subtags are allowed.\n\nIf you set `disallowedTagsMode` to `escape`, the disallowed tags are escaped rather than discarded. Any text or subtags are handled normally.\n\nIf you set `disallowedTagsMode` to `recursiveEscape`, the disallowed tags are escaped rather than discarded, and the same treatment is applied to all subtags, whether otherwise allowed or not.\n\n#### \"What if I want to allow only specific values on some attributes?\"\n\nWhen configuring the attribute in `allowedAttributes` simply use an object with attribute `name` and an allowed `values` array. In the following example `sandbox=\"allow-forms allow-modals allow-orientation-lock allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-scripts\"` would become `sandbox=\"allow-popups allow-scripts\"`:\n\n```js\nallowedAttributes: {\n  iframe: [\n    {\n      name: 'sandbox',\n      multiple: true,\n      values: ['allow-popups', 'allow-same-origin', 'allow-scripts']\n    }\n  ]\n}\n```\n\nWith `multiple: true`, several allowed values may appear in the same attribute, separated by spaces. Otherwise the attribute must exactly match one and only one of the allowed values.\n\n#### \"What if I want to maintain the original case for SVG elements and attributes?\"\n\nIf you're incorporating SVG elements like `linearGradient` into your content and notice that they're not rendering as expected due to case sensitivity issues, it's essential to prevent `sanitize-html` from converting element and attribute names to lowercase. This situation often arises when SVGs fail to display correctly because their case-sensitive tags, such as `linearGradient` and attributes like `viewBox`, are inadvertently lowercased.\n\nTo address this, ensure you set `lowerCaseTags: false` and `lowerCaseAttributeNames: false` in the parser options of your sanitize-html configuration. This adjustment stops the library from altering the case of your tags and attributes, preserving the integrity of your SVG content.\n\n```js\nallowedTags: [ 'svg', 'g', 'defs', 'linearGradient', 'stop', 'circle' ],\nallowedAttributes: false,\nparser: {\n  lowerCaseTags: false,\n  lowerCaseAttributeNames: false\n}\n```\n\n### Wildcards for attributes\n\nYou can use the `*` wildcard to allow all attributes with a certain prefix:\n\n```js\nallowedAttributes: {\n  a: [ 'href', 'data-*' ]\n}\n```\n\nAlso you can use the `*` as name for a tag, to allow listed attributes to be valid for any tag:\n\n```js\nallowedAttributes: {\n  '*': [ 'href', 'align', 'alt', 'center', 'bgcolor' ]\n}\n```\n\n## Additional options\n\n### Allowed CSS Classes\n\nIf you wish to allow specific CSS classes on a particular element, you can do so with the `allowedClasses` option. Any other CSS classes are discarded.\n\nThis implies that the `class` attribute is allowed on that element.\n\n```javascript\n// Allow only a restricted set of CSS classes and only on the p tag\nconst clean = sanitizeHtml(dirty, {\n  allowedTags: [ 'p', 'em', 'strong' ],\n  allowedClasses: {\n    'p': [ 'fancy', 'simple' ]\n  }\n});\n```\n\nSimilar to `allowedAttributes`, you can use `*` to allow classes with a certain prefix, or use `*` as a tag name to allow listed classes to be valid for any tag:\n\n```js\nallowedClasses: {\n  'code': [ 'language-*', 'lang-*' ],\n  '*': [ 'fancy', 'simple' ]\n}\n```\n\nFurthermore, regular expressions are supported too:\n\n```js\nallowedClasses: {\n  p: [ /^regex\\d{2}$/ ]\n}\n```\n\nIf `allowedClasses` for a certain tag is `false`, all the classes for this tag will be allowed.\n\n> Note: It is advised that your regular expressions always begin with `^` so that you are requiring a known prefix. A regular expression with neither `^` nor `$` just requires that something appear in the middle.\n\n### Allowed CSS Styles\n\nIf you wish to allow specific CSS _styles_ on a particular element, you can do that with the `allowedStyles` option. Simply declare your desired attributes as regular expression options within an array for the given attribute. Specific elements will inherit allowlisted attributes from the global (`*`) attribute. Any other CSS classes are discarded.\n\n**You must also use `allowedAttributes`** to activate the `style` attribute for the relevant elements. Otherwise this feature will never come into play.\n\n**When constructing regular expressions, don't forget `^` and `$`.** It's not enough to say \"the string should contain this.\" It must also say \"and only this.\"\n\n**URLs in inline styles are NOT filtered by any mechanism other than your regular expression.**\n\n```javascript\nconst clean = sanitizeHtml(dirty, {\n        allowedTags: ['p'],\n        allowedAttributes: {\n          'p': [\"style\"],\n        },\n        allowedStyles: {\n          '*': {\n            // Match HEX and RGB\n            'color': [/^#(0x)?[0-9a-f]+$/i, /^rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/],\n            'text-align': [/^left$/, /^right$/, /^center$/],\n            // Match any number with px, em, or %\n            'font-size': [/^\\d+(?:px|em|%)$/]\n          },\n          'p': {\n            'font-size': [/^\\d+rem$/]\n          }\n        }\n      });\n```\n\n### Discarding text outside of ```<html></html>``` tags\n\nSome text editing applications generate HTML to allow copying over to a web application. These can sometimes include undesirable control characters after terminating `html` tag. By default sanitize-html will not discard these characters, instead returning them in sanitized string. This behaviour can be modified using `enforceHtmlBoundary` option.\n\nSetting this option to true will instruct sanitize-html to discard all characters outside of `html` tag boundaries -- before `<html>` and after `</html>` tags.\n\n```js\nenforceHtmlBoundary: true\n```\n\n### htmlparser2 Options\n\nsanitize-html is built on `htmlparser2`. By default the only option passed down is `decodeEntities: true`. You can set the options to pass by using the parser option.\n\n**Security note: changing the `parser` settings can be risky.** In particular, `decodeEntities: false` has known security concerns and a complete test suite does not exist for every possible combination of settings when used with `sanitize-html`. If security is your goal we recommend you use the defaults rather than changing `parser`, except for the `lowerCaseTags` option.\n\n```javascript\nconst clean = sanitizeHtml(dirty, {\n  allowedTags: ['a'],\n  parser: {\n    lowerCaseTags: true\n  }\n});\n```\nSee the [htmlparser2 wiki](https://github.com/fb55/htmlparser2/wiki/Parser-options) for the full list of possible options.\n\n### Transformations\n\nWhat if you want to add or change an attribute? What if you want to transform one tag to another? No problem, it's simple!\n\nThe easiest way (will change all `ol` tags to `ul` tags):\n\n```js\nconst clean = sanitizeHtml(dirty, {\n  transformTags: {\n    'ol': 'ul',\n  }\n});\n```\n\nThe most advanced usage:\n\n```js\nconst clean = sanitizeHtml(dirty, {\n  transformTags: {\n    'ol': function(tagName, attribs) {\n      // My own custom magic goes here\n      return {\n        tagName: 'ul',\n        attribs: {\n          class: 'foo'\n        }\n      };\n    }\n  }\n});\n```\n\nYou can specify the `*` wildcard instead of a tag name to transform all tags.\n\nThere is also a helper method which should be enough for simple cases in which you want to change the tag and/or add some attributes:\n\n```js\nconst clean = sanitizeHtml(dirty, {\n  transformTags: {\n    'ol': sanitizeHtml.simpleTransform('ul', {class: 'foo'}),\n  }\n});\n```\n\nThe `simpleTransform` helper method has 3 parameters:\n\n```js\nsimpleTransform(newTag, newAttributes, shouldMerge)\n```\n\nThe last parameter (`shouldMerge`) is set to `true` by default. When `true`, `simpleTransform` will merge the current attributes with the new ones (`newAttributes`). When `false`, all existing attributes are discarded.\n\nYou can also add or modify the text contents of a tag:\n\n```js\nconst clean = sanitizeHtml(dirty, {\n  transformTags: {\n    'a': function(tagName, attribs) {\n      return {\n        tagName: 'a',\n        text: 'Some text'\n      };\n    }\n  }\n});\n```\nFor example, you could transform a link element with missing anchor text:\n```js\n<a href=\"http://somelink.com\"></a>\n```\nTo a link with anchor text:\n```js\n<a href=\"http://somelink.com\">Some text</a>\n```\n\n### Filters\n\nYou can provide a filter function to remove unwanted tags. Let's suppose we need to remove empty `a` tags like:\n\n```html\n<a href=\"page.html\"></a>\n```\n\nWe can do that with the following filter:\n\n```js\nsanitizeHtml(\n  '<p>This is <a href=\"http://www.linux.org\"></a><br/>Linux</p>',\n  {\n    exclusiveFilter: function(frame) {\n      return frame.tag === 'a' && !frame.text.trim();\n    }\n  }\n);\n```\n\nThe `frame` object supplied to the callback provides the following attributes:\n\n- `tag`: The tag name, i.e. `'img'`.\n- `attribs`: The tag's attributes, i.e. `{ src: \"/path/to/tux.png\" }`.\n- `text`: The text content of the tag.\n- `mediaChildren`: Immediate child tags that are likely to represent self-contained media (e.g., `img`, `video`, `picture`, `iframe`). See the `mediaTags` variable in `src/index.js` for the full list.\n- `tagPosition`: The index of the tag's position in the result string.\n\nYou can also process all text content with a provided filter function. Let's say we want an ellipsis instead of three dots.\n\n```html\n<p>some text...</p>\n```\n\nWe can do that with the following filter:\n\n```js\nsanitizeHtml(\n  '<p>some text...</p>',\n  {\n    textFilter: function(text, tagName) {\n      if (['a'].indexOf(tagName) > -1) return //Skip anchor tags\n\n      return text.replace(/\\.\\.\\./, '&hellip;');\n    }\n  }\n);\n```\n\nNote that the text passed to the `textFilter` method is already escaped for safe display as HTML. You may add markup and use entity escape sequences in your `textFilter`.\n\n### Iframe Filters\n\nIf you would like to allow iframe tags but want to control the domains that are allowed through, you can provide an array of hostnames and/or array of domains that you would like to allow as iframe sources. This hostname is a property in the options object passed as an argument to the sanitize-html function.\n\nThese arrays will be checked against the html that is passed to the function and return only `src` urls that include the allowed hostnames or domains in the object. The url in the html that is passed must be formatted correctly (valid hostname) as an embedded iframe otherwise the module will strip out the src from the iframe.\n\nMake sure to pass a valid hostname along with the domain you wish to allow, i.e.:\n\n```js\nallowedIframeHostnames: ['www.youtube.com', 'player.vimeo.com'],\nallowedIframeDomains: ['zoom.us']\n```\n\nYou may also specify whether or not to allow relative URLs as iframe sources.\n\n```js\nallowIframeRelativeUrls: true\n```\n\nNote that if unspecified, relative URLs will be allowed by default if no hostname or domain filter is provided but removed by default if a hostname or domain filter is provided.\n\n**Remember that the `iframe` tag must be allowed as well as the `src` attribute.**\n\nFor example:\n\n```javascript\nconst clean = sanitizeHtml('<p><iframe src=\"https://www.youtube.com/embed/nykIhs12345\"></iframe><p>', {\n  allowedTags: [ 'p', 'em', 'strong', 'iframe' ],\n  allowedClasses: {\n    'p': [ 'fancy', 'simple' ],\n  },\n  allowedAttributes: {\n    'iframe': ['src']\n  },\n  allowedIframeHostnames: ['www.youtube.com', 'player.vimeo.com']\n});\n```\n\nwill pass through as safe whereas:\n\n```javascript\nconst clean = sanitizeHtml('<p><iframe src=\"https://www.youtube.net/embed/nykIhs12345\"></iframe><p>', {\n  allowedTags: [ 'p', 'em', 'strong', 'iframe' ],\n  allowedClasses: {\n    'p': [ 'fancy', 'simple' ],\n  },\n  allowedAttributes: {\n    'iframe': ['src']\n  },\n  allowedIframeHostnames: ['www.youtube.com', 'player.vimeo.com']\n});\n```\n\nor\n\n```javascript\nconst clean = sanitizeHtml('<p><iframe src=\"https://www.vimeo/video/12345\"></iframe><p>', {\n  allowedTags: [ 'p', 'em', 'strong', 'iframe' ],\n  allowedClasses: {\n    'p': [ 'fancy', 'simple' ],\n  },\n  allowedAttributes: {\n    'iframe': ['src']\n  },\n  allowedIframeHostnames: ['www.youtube.com', 'player.vimeo.com']\n});\n```\n\nwill return an empty iframe tag.\n\nIf you want to allow any subdomain of any level you can provide the domain in `allowedIframeDomains`\n\n```javascript\n// This iframe markup will pass through as safe.\nconst clean = sanitizeHtml('<p><iframe src=\"https://us02web.zoom.us/embed/12345\"></iframe><p>', {\n  allowedTags: [ 'p', 'em', 'strong', 'iframe' ],\n  allowedClasses: {\n    'p': [ 'fancy', 'simple' ],\n  },\n  allowedAttributes: {\n    'iframe': ['src']\n  },\n  allowedIframeHostnames: ['www.youtube.com', 'player.vimeo.com'],\n  allowedIframeDomains: ['zoom.us']\n});\n```\n\n### Script Filters\n\nSimilarly to iframes you can allow a script tag on a list of allowlisted domains\n\n```js\nconst clean = sanitizeHtml('<script src=\"https://www.safe.authorized.com/lib.js\"></script>', {\n    allowedTags: ['script'],\n    allowedAttributes: {\n        script: ['src']\n    },\n    allowedScriptDomains: ['authorized.com'],\n})\n```\n\nYou can allow a script tag on a list of allowlisted hostnames too\n\n```js\nconst clean = sanitizeHtml('<script src=\"https://www.authorized.com/lib.js\"></script>', {\n    allowedTags: ['script'],\n    allowedAttributes: {\n        script: ['src']\n    },\n    allowedScriptHostnames: [ 'www.authorized.com' ],\n})\n```\n\n### Allowed URL schemes\n\nBy default, we allow the following URL schemes in cases where `href`, `src`, etc. are allowed:\n\n```js\n[ 'http', 'https', 'ftp', 'mailto' ]\n```\n\nYou can override this if you want to:\n\n```js\nsanitizeHtml(\n  // teeny-tiny valid transparent GIF in a data URL\n  '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" />',\n  {\n    allowedTags: [ 'img', 'p' ],\n    allowedSchemes: [ 'data', 'http' ]\n  }\n);\n```\n\nYou can also allow a scheme for a particular tag only:\n\n```js\nallowedSchemes: [ 'http', 'https' ],\nallowedSchemesByTag: {\n  img: [ 'data' ]\n}\n```\n\nAnd you can forbid the use of protocol-relative URLs (starting with `//`) to access another site using the current protocol, which is allowed by default:\n\n```js\nallowProtocolRelative: false\n```\n\n### Discarding the entire contents of a disallowed tag\n\nNormally, with a few exceptions, if a tag is not allowed, all of the text within it is preserved, and so are any allowed tags within it.\n\nThe exceptions are:\n\n`style`, `script`, `textarea`, `option`\n\nIf you wish to replace this list, for instance to discard whatever is found\ninside a `noscript` tag, use the `nonTextTags` option:\n\n```js\nnonTextTags: [ 'style', 'script', 'textarea', 'option', 'noscript' ]\n```\n\nNote that if you use this option you are responsible for stating the entire list. This gives you the power to retain the content of `textarea`, if you want to.\n\nThe content still gets escaped properly, with the exception of the `script` and\n`style` tags. *Allowing either `script` or `style` leaves you open to XSS\nattacks. Don't do that* unless you have good reason to trust their origin.\nsanitize-html will log a warning if these tags are allowed, which can be\ndisabled with the `allowVulnerableTags: true` option.\n\n### Choose what to do with disallowed tags\n\nInstead of discarding, or keeping text only, you may enable escaping of the entire content:\n\n```js\ndisallowedTagsMode: 'escape'\n```\n\nThis will transform `<disallowed>content</disallowed>` to `&lt;disallowed&gt;content&lt;/disallowed&gt;`\n\nValid values are: `'discard'` (default), `'completelyDiscard'` (remove disallowed tag's content), `'escape'` (escape the tag) and `'recursiveEscape'` (to escape the tag and all its content).\n\n#### Discard disallowed but but the inner content of disallowed tags is kept.\n\nIf you set `disallowedTagsMode` to `discard`, disallowed tags are discarded but but the inner content of disallowed tags is kept.\n\n```js\ndisallowedTagsMode: 'discard'\n```\nThis will transform `<disallowed>content</disallowed>` to `content`\n\n#### Discard entire content of a disallowed tag\n\nIf you set `disallowedTagsMode` to `completelyDiscard`, disallowed tags and any content they contain are discarded. Any subtags are still included, as long as those individual subtags are allowed.\n\n```js\ndisallowedTagsMode: 'completelyDiscard'\n```\n\nThis will transform `<disallowed>content <allowed>content</allowed> </disallowed>` to `<allowed>content</allowed>`\n\n#### Escape the disallowed tag and all its children even for allowed tags.\n\nif you set `disallowedTagsMode` to `recursiveEscape`, disallowed tag and its children will be escaped even for allowed tags\n\n```js\ndisallowedTagsMode: `recursiveEscape`\n```\n\nThis will transform `<disallowed>hello<p>world</p></disallowed>` to `&lt;disallowed&gt;hello&lt;p&gt;world&lt;/p&gt;&lt;/disallowed&gt;`\n\n### Ignore style attribute contents\n\nInstead of discarding faulty style attributes, you can allow them by disabling the parsing of style attributes:\n\n```js\nparseStyleAttributes: false\n```\n\nThis will transform `<div style=\"invalid-prop: non-existing-value\">content</div>` to `<div style=\"invalid-prop: non-existing-value\">content</div>` instead of stripping it: `<div>content</div>`\n\nBy default the parseStyleAttributes option is true.\n\nWhen you disable parsing of the style attribute (`parseStyleAttributes: false`) and you pass in options for the allowedStyles property, an error will be thrown. This combination is not permitted.\n\nwe recommend sanitizing content server-side in a Node.js environment, as you cannot trust a browser to sanitize things anyway. Consider what a malicious user could do via the network panel, \nthe browser console, or just by writing scripts that submit content similar to what your JavaScript submits. But if you really need to run it on the client in the browser, \nyou may find you need to disable parseStyleAttributes. This is subject to change as it is [an upstream issue with postcss](https://github.com/postcss/postcss/issues/1727), not sanitize-html itself.\n\n### Restricting deep nesting\n\nYou can limit the depth of HTML tags in the document with the `nestingLimit` option:\n\n```javascript\nnestingLimit: 6\n```\n\nThis will prevent the user from nesting tags more than 6 levels deep. Tags deeper than that are stripped out exactly as if they were disallowed. Note that this means text is preserved in the usual ways where appropriate.\n\n## About ApostropheCMS\n\nsanitize-html was created at [P'unk Avenue](https://punkave.com) for use in [ApostropheCMS](https://apostrophecms.com), an open-source content management system built on Node.js. If you like sanitize-html you should definitely check out ApostropheCMS.\n\n## Support\n\nFeel free to open issues on [github](https://github.com/apostrophecms/sanitize-html).\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 33.2646484375,
          "content": "const htmlparser = require('htmlparser2');\nconst escapeStringRegexp = require('escape-string-regexp');\nconst { isPlainObject } = require('is-plain-object');\nconst deepmerge = require('deepmerge');\nconst parseSrcset = require('parse-srcset');\nconst { parse: postcssParse } = require('postcss');\n// Tags that can conceivably represent stand-alone media.\nconst mediaTags = [\n  'img', 'audio', 'video', 'picture', 'svg',\n  'object', 'map', 'iframe', 'embed'\n];\n// Tags that are inherently vulnerable to being used in XSS attacks.\nconst vulnerableTags = [ 'script', 'style' ];\n\nfunction each(obj, cb) {\n  if (obj) {\n    Object.keys(obj).forEach(function (key) {\n      cb(obj[key], key);\n    });\n  }\n}\n\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n  return ({}).hasOwnProperty.call(obj, key);\n}\n\n// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a, cb) {\n  const n = [];\n  each(a, function(v) {\n    if (cb(v)) {\n      n.push(v);\n    }\n  });\n  return n;\n}\n\nfunction isEmptyObject(obj) {\n  for (const key in obj) {\n    if (has(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction stringifySrcset(parsedSrcset) {\n  return parsedSrcset.map(function(part) {\n    if (!part.url) {\n      throw new Error('URL missing');\n    }\n\n    return (\n      part.url +\n      (part.w ? ` ${part.w}w` : '') +\n      (part.h ? ` ${part.h}h` : '') +\n      (part.d ? ` ${part.d}x` : '')\n    );\n  }).join(', ');\n}\n\nmodule.exports = sanitizeHtml;\n\n// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nconst VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/;\n\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  if (html == null) {\n    return '';\n  }\n  if (typeof html === 'number') {\n    html = html.toString();\n  }\n\n  let result = '';\n  // Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\n  let tempResult = '';\n\n  function Frame(tag, attribs) {\n    const that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n    this.mediaChildren = [];\n\n    this.updateParentNodeText = function() {\n      if (stack.length) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.text += that.text;\n      }\n    };\n\n    this.updateParentNodeMediaChildren = function() {\n      if (stack.length && mediaTags.includes(this.tag)) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.mediaChildren.push(this.tag);\n      }\n    };\n  }\n\n  options = Object.assign({}, sanitizeHtml.defaults, options);\n  options.parser = Object.assign({}, htmlParserDefaults, options.parser);\n\n  const tagAllowed = function (name) {\n    return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;\n  };\n\n  // vulnerableTags\n  vulnerableTags.forEach(function (tag) {\n    if (tagAllowed(tag) && !options.allowVulnerableTags) {\n      console.warn(`\\n\\n⚠️ Your \\`allowedTags\\` option includes, \\`${tag}\\`, which is inherently\\nvulnerable to XSS attacks. Please remove it from \\`allowedTags\\`.\\nOr, to disable this warning, add the \\`allowVulnerableTags\\` option\\nand ensure you are accounting for this risk.\\n\\n`);\n    }\n  });\n\n  // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n  const nonTextTagsArray = options.nonTextTags || [\n    'script',\n    'style',\n    'textarea',\n    'option'\n  ];\n  let allowedAttributesMap;\n  let allowedAttributesGlobMap;\n  if (options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function(attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      const globRegex = [];\n      attributes.forEach(function(obj) {\n        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n          globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(obj);\n        }\n      });\n      if (globRegex.length) {\n        allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n      }\n    });\n  }\n  const allowedClassesMap = {};\n  const allowedClassesGlobMap = {};\n  const allowedClassesRegexMap = {};\n  each(options.allowedClasses, function(classes, tag) {\n    // Implicitly allows the class attribute\n    if (allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n      allowedAttributesMap[tag].push('class');\n    }\n\n    allowedClassesMap[tag] = classes;\n\n    if (Array.isArray(classes)) {\n      const globRegex = [];\n      allowedClassesMap[tag] = [];\n      allowedClassesRegexMap[tag] = [];\n      classes.forEach(function(obj) {\n        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n          globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n        } else if (obj instanceof RegExp) {\n          allowedClassesRegexMap[tag].push(obj);\n        } else {\n          allowedClassesMap[tag].push(obj);\n        }\n      });\n      if (globRegex.length) {\n        allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n      }\n    }\n  });\n\n  const transformTagsMap = {};\n  let transformTagsAll;\n  each(options.transformTags, function(transform, tag) {\n    let transFun;\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === 'string') {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n\n  let depth;\n  let stack;\n  let skipMap;\n  let transformMap;\n  let skipText;\n  let skipTextDepth;\n  let addedText = false;\n\n  initializeState();\n\n  const parser = new htmlparser.Parser({\n    onopentag: function(name, attribs) {\n      // If `enforceHtmlBoundary` is `true` and this has found the opening\n      // `html` tag, reset the state.\n      if (options.enforceHtmlBoundary && name === 'html') {\n        initializeState();\n      }\n\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n      const frame = new Frame(name, attribs);\n      stack.push(frame);\n\n      let skip = false;\n      const hasText = !!frame.text;\n      let transformedTag;\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if (!tagAllowed(name) || (options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap)) || (options.nestingLimit != null && depth >= options.nestingLimit)) {\n        skip = true;\n        skipMap[depth] = true;\n        if (options.disallowedTagsMode === 'discard' || options.disallowedTagsMode === 'completelyDiscard') {\n          if (nonTextTagsArray.indexOf(name) !== -1) {\n            skipText = true;\n            skipTextDepth = 1;\n          }\n        }\n        skipMap[depth] = true;\n      }\n      depth++;\n      if (skip) {\n        if (options.disallowedTagsMode === 'discard' || options.disallowedTagsMode === 'completelyDiscard') {\n          // We want the contents but not this tag\n          if (frame.innerText && !hasText) {\n            const escaped = escapeHtml(frame.innerText);\n            if (options.textFilter) {\n              result += options.textFilter(escaped, name);\n            } else {\n              result += escapeHtml(frame.innerText);\n            }\n            addedText = true;\n          }\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n      result += '<' + name;\n\n      if (name === 'script') {\n        if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n          frame.innerText = '';\n        }\n      }\n\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function(value, a) {\n          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n            // This prevents part of an attribute name in the output from being\n            // interpreted as the end of an attribute, or end of a tag.\n            delete frame.attribs[a];\n            return;\n          }\n          // If the value is empty, check if the attribute is in the allowedEmptyAttributes array.\n          // If it is not in the allowedEmptyAttributes array, and it is a known non-boolean attribute, delete it\n          // List taken from https://html.spec.whatwg.org/multipage/indices.html#attributes-3\n          if (value === '' && (!options.allowedEmptyAttributes.includes(a)) &&\n            (options.nonBooleanAttributes.includes(a) || options.nonBooleanAttributes.includes('*'))) {\n            delete frame.attribs[a];\n            return;\n          }\n          // check allowedAttributesMap for the element and attribute and modify the value\n          // as necessary if there are specific values defined.\n          let passedAllowedAttributesMapCheck = false;\n          if (!allowedAttributesMap ||\n            (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1) ||\n            (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1) ||\n            (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||\n            (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {\n            passedAllowedAttributesMapCheck = true;\n          } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n            for (const o of allowedAttributesMap[name]) {\n              if (isPlainObject(o) && o.name && (o.name === a)) {\n                passedAllowedAttributesMapCheck = true;\n                let newValue = '';\n                if (o.multiple === true) {\n                  // verify the values that are allowed\n                  const splitStrArray = value.split(' ');\n                  for (const s of splitStrArray) {\n                    if (o.values.indexOf(s) !== -1) {\n                      if (newValue === '') {\n                        newValue = s;\n                      } else {\n                        newValue += ' ' + s;\n                      }\n                    }\n                  }\n                } else if (o.values.indexOf(value) >= 0) {\n                  // verified an allowed value matches the entire attribute value\n                  newValue = value;\n                }\n                value = newValue;\n              }\n            }\n          }\n          if (passedAllowedAttributesMapCheck) {\n            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (name === 'script' && a === 'src') {\n\n              let allowed = true;\n\n              try {\n                const parsed = parseUrl(value);\n\n                if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n                  const allowedHostname = (options.allowedScriptHostnames || []).find(function (hostname) {\n                    return hostname === parsed.url.hostname;\n                  });\n                  const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {\n                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                allowed = false;\n              }\n\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (name === 'iframe' && a === 'src') {\n              let allowed = true;\n              try {\n                const parsed = parseUrl(value);\n\n                if (parsed.isRelativeUrl) {\n                  // default value of allowIframeRelativeUrls is true\n                  // unless allowedIframeHostnames or allowedIframeDomains specified\n                  allowed = has(options, 'allowIframeRelativeUrls')\n                    ? options.allowIframeRelativeUrls\n                    : (!options.allowedIframeHostnames && !options.allowedIframeDomains);\n                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {\n                  const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {\n                    return hostname === parsed.url.hostname;\n                  });\n                  const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {\n                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                // Unparseable iframe src\n                allowed = false;\n              }\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'srcset') {\n              try {\n                let parsed = parseSrcset(value);\n                parsed.forEach(function(value) {\n                  if (naughtyHref('srcset', value.url)) {\n                    value.evil = true;\n                  }\n                });\n                parsed = filter(parsed, function(v) {\n                  return !v.evil;\n                });\n                if (!parsed.length) {\n                  delete frame.attribs[a];\n                  return;\n                } else {\n                  value = stringifySrcset(filter(parsed, function(v) {\n                    return !v.evil;\n                  }));\n                  frame.attribs[a] = value;\n                }\n              } catch (e) {\n                // Unparseable srcset\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'class') {\n              const allowedSpecificClasses = allowedClassesMap[name];\n              const allowedWildcardClasses = allowedClassesMap['*'];\n              const allowedSpecificClassesGlob = allowedClassesGlobMap[name];\n              const allowedSpecificClassesRegex = allowedClassesRegexMap[name];\n              const allowedWildcardClassesRegex = allowedClassesRegexMap['*'];\n              const allowedWildcardClassesGlob = allowedClassesGlobMap['*'];\n              const allowedClassesGlobs = [\n                allowedSpecificClassesGlob,\n                allowedWildcardClassesGlob\n              ]\n                .concat(allowedSpecificClassesRegex, allowedWildcardClassesRegex)\n                .filter(function (t) {\n                  return t;\n                });\n              if (allowedSpecificClasses && allowedWildcardClasses) {\n                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);\n              } else {\n                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);\n              }\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'style') {\n              if (options.parseStyleAttributes) {\n                try {\n                  const abstractSyntaxTree = postcssParse(name + ' {' + value + '}', { map: false });\n                  const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n\n                  value = stringifyStyleAttributes(filteredAST);\n\n                  if (value.length === 0) {\n                    delete frame.attribs[a];\n                    return;\n                  }\n                } catch (e) {\n                  if (typeof window !== 'undefined') {\n                    console.warn('Failed to parse \"' + name + ' {' + value + '}' + '\", If you\\'re running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547');\n                  }\n                  delete frame.attribs[a];\n                  return;\n                }\n              } else if (options.allowedStyles) {\n                throw new Error('allowedStyles option cannot be used together with parseStyleAttributes: false.');\n              }\n            }\n            result += ' ' + a;\n            if (value && value.length) {\n              result += '=\"' + escapeHtml(value, true) + '\"';\n            } else if (options.allowedEmptyAttributes.includes(a)) {\n              result += '=\"\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += ' />';\n      } else {\n        result += '>';\n        if (frame.innerText && !hasText && !options.textFilter) {\n          result += escapeHtml(frame.innerText);\n          addedText = true;\n        }\n      }\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n    },\n    ontext: function(text) {\n      if (skipText) {\n        return;\n      }\n      const lastFrame = stack[stack.length - 1];\n      let tag;\n\n      if (lastFrame) {\n        tag = lastFrame.tag;\n        // If inner text was set by transform function then let's use it\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n\n      if (options.disallowedTagsMode === 'completelyDiscard' && !tagAllowed(tag)) {\n        text = '';\n      } else if ((options.disallowedTagsMode === 'discard' || options.disallowedTagsMode === 'completelyDiscard') && ((tag === 'script') || (tag === 'style'))) {\n        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n        // script tags is, by definition, game over for XSS protection, so if that's\n        // your concern, don't allow them. The same is essentially true for style tags\n        // which have their own collection of XSS vectors.\n        result += text;\n      } else {\n        const escaped = escapeHtml(text, false);\n        if (options.textFilter && !addedText) {\n          result += options.textFilter(escaped, tag);\n        } else if (!addedText) {\n          result += escaped;\n        }\n      }\n      if (stack.length) {\n        const frame = stack[stack.length - 1];\n        frame.text += text;\n      }\n    },\n    onclosetag: function(name, isImplied) {\n\n      if (skipText) {\n        skipTextDepth--;\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n\n      const frame = stack.pop();\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n\n      if (frame.tag !== name) {\n        // Another case of bad markup.\n        // Push to stack, so that it will be used in future closing tags.\n        stack.push(frame);\n        return;\n      }\n\n      skipText = options.enforceHtmlBoundary ? name === 'html' : false;\n      depth--;\n      const skip = skipMap[depth];\n      if (skip) {\n        delete skipMap[depth];\n        if (options.disallowedTagsMode === 'discard' || options.disallowedTagsMode === 'completelyDiscard') {\n          frame.updateParentNodeText();\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n        result = result.substr(0, frame.tagPosition);\n        return;\n      }\n\n      frame.updateParentNodeMediaChildren();\n      frame.updateParentNodeText();\n\n      if (\n        // Already output />\n        options.selfClosing.indexOf(name) !== -1 ||\n        // Escaped tag, closing tag is implied\n        (isImplied && !tagAllowed(name) && [ 'escape', 'recursiveEscape' ].indexOf(options.disallowedTagsMode) >= 0)\n      ) {\n        if (skip) {\n          result = tempResult;\n          tempResult = '';\n        }\n        return;\n      }\n\n      result += '</' + name + '>';\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n      addedText = false;\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n\n  return result;\n\n  function initializeState() {\n    result = '';\n    depth = 0;\n    stack = [];\n    skipMap = {};\n    transformMap = {};\n    skipText = false;\n    skipTextDepth = 0;\n  }\n\n  function escapeHtml(s, quote) {\n    if (typeof (s) !== 'string') {\n      s = s + '';\n    }\n    if (options.parser.decodeEntities) {\n      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n      if (quote) {\n        s = s.replace(/\"/g, '&quot;');\n      }\n    }\n    // TODO: this is inadequate because it will pass `&0;`. This approach\n    // will not work, each & must be considered with regard to whether it\n    // is followed by a 100% syntactically valid entity or not, and escaped\n    // if it is not. If this bothers you, don't set parser.decodeEntities\n    // to false. (The default is true.)\n    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n    if (quote) {\n      s = s.replace(/\"/g, '&quot;');\n    }\n    return s;\n  }\n\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    // eslint-disable-next-line no-control-regex\n    href = href.replace(/[\\x00-\\x20]+/g, '');\n    // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n    while (true) {\n      const firstIndex = href.indexOf('<!--');\n      if (firstIndex === -1) {\n        break;\n      }\n      const lastIndex = href.indexOf('-->', firstIndex + 4);\n      if (lastIndex === -1) {\n        break;\n      }\n      href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);\n    }\n    // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    // Allow more characters after the first so we don't get faked\n    // out by certain schemes browsers accept\n    const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\\-+]*):/);\n    if (!matches) {\n      // Protocol-relative URL starting with any combination of '/' and '\\'\n      if (href.match(/^[/\\\\]{2}/)) {\n        return !options.allowProtocolRelative;\n      }\n\n      // No scheme\n      return false;\n    }\n    const scheme = matches[1].toLowerCase();\n\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n\n  function parseUrl(value) {\n    value = value.replace(/^(\\w+:)?\\s*[\\\\/]\\s*[\\\\/]/, '$1//');\n    if (value.startsWith('relative:')) {\n      // An attempt to exploit our workaround for base URLs being\n      // mandatory for relative URL validation in the WHATWG\n      // URL parser, reject it\n      throw new Error('relative: exploit attempt');\n    }\n    // naughtyHref is in charge of whether protocol relative URLs\n    // are cool. Here we are concerned just with allowed hostnames and\n    // whether to allow relative URLs.\n    //\n    // Build a placeholder \"base URL\" against which any reasonable\n    // relative URL may be parsed successfully\n    let base = 'relative://relative-site';\n    for (let i = 0; (i < 100); i++) {\n      base += `/${i}`;\n    }\n\n    const parsed = new URL(value, base);\n\n    const isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';\n    return {\n      isRelativeUrl,\n      url: parsed\n    };\n  }\n  /**\n   * Filters user input css properties by allowlisted regex attributes.\n   * Modifies the abstractSyntaxTree object.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - The modified tree.\n   */\n  function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n\n    const astRules = abstractSyntaxTree.nodes[0];\n    let selectedRule;\n\n    // Merge global and tag-specific styles into new AST.\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = deepmerge(\n        allowedStyles[astRules.selector],\n        allowedStyles['*']\n      );\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n\n    if (selectedRule) {\n      abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n\n    return abstractSyntaxTree;\n  }\n\n  /**\n   * Extracts the style attributes from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center !important;font-family:helvetica;\"\n   */\n  function stringifyStyleAttributes(filteredAST) {\n    return filteredAST.nodes[0].nodes\n      .reduce(function(extractedAttributes, attrObject) {\n        extractedAttributes.push(\n          `${attrObject.prop}:${attrObject.value}${attrObject.important ? ' !important' : ''}`\n        );\n        return extractedAttributes;\n      }, [])\n      .join(';');\n  }\n\n  /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the allowlist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */\n  function filterDeclarations(selectedRule) {\n    return function (allowedDeclarationsList, attributeObject) {\n      // If this property is allowlisted...\n      if (has(selectedRule, attributeObject.prop)) {\n        const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {\n          return regularExpression.test(attributeObject.value);\n        });\n\n        if (matchesRegex) {\n          allowedDeclarationsList.push(attributeObject);\n        }\n      }\n      return allowedDeclarationsList;\n    };\n  }\n\n  function filterClasses(classes, allowed, allowedGlobs) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n    classes = classes.split(/\\s+/);\n    return classes.filter(function(clss) {\n      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {\n        return glob.test(clss);\n      });\n    }).join(' ');\n  }\n}\n\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\nconst htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: [\n    // Sections derived from MDN element categories and limited to the more\n    // benign categories.\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n    // Content sectioning\n    'address', 'article', 'aside', 'footer', 'header',\n    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup',\n    'main', 'nav', 'section',\n    // Text content\n    'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure',\n    'hr', 'li', 'menu', 'ol', 'p', 'pre', 'ul',\n    // Inline text semantics\n    'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn',\n    'em', 'i', 'kbd', 'mark', 'q',\n    'rb', 'rp', 'rt', 'rtc', 'ruby',\n    's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr',\n    // Table content\n    'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th',\n    'thead', 'tr'\n  ],\n  // Tags that cannot be boolean\n  nonBooleanAttributes: [\n    'abbr', 'accept', 'accept-charset', 'accesskey', 'action',\n    'allow', 'alt', 'as', 'autocapitalize', 'autocomplete',\n    'blocking', 'charset', 'cite', 'class', 'color', 'cols',\n    'colspan', 'content', 'contenteditable', 'coords', 'crossorigin',\n    'data', 'datetime', 'decoding', 'dir', 'dirname', 'download',\n    'draggable', 'enctype', 'enterkeyhint', 'fetchpriority', 'for',\n    'form', 'formaction', 'formenctype', 'formmethod', 'formtarget',\n    'headers', 'height', 'hidden', 'high', 'href', 'hreflang',\n    'http-equiv', 'id', 'imagesizes', 'imagesrcset', 'inputmode',\n    'integrity', 'is', 'itemid', 'itemprop', 'itemref', 'itemtype',\n    'kind', 'label', 'lang', 'list', 'loading', 'low', 'max',\n    'maxlength', 'media', 'method', 'min', 'minlength', 'name',\n    'nonce', 'optimum', 'pattern', 'ping', 'placeholder', 'popover',\n    'popovertarget', 'popovertargetaction', 'poster', 'preload',\n    'referrerpolicy', 'rel', 'rows', 'rowspan', 'sandbox', 'scope',\n    'shape', 'size', 'sizes', 'slot', 'span', 'spellcheck', 'src',\n    'srcdoc', 'srclang', 'srcset', 'start', 'step', 'style',\n    'tabindex', 'target', 'title', 'translate', 'type', 'usemap',\n    'value', 'width', 'wrap',\n    // Event handlers\n    'onauxclick', 'onafterprint', 'onbeforematch', 'onbeforeprint',\n    'onbeforeunload', 'onbeforetoggle', 'onblur', 'oncancel',\n    'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose',\n    'oncontextlost', 'oncontextmenu', 'oncontextrestored', 'oncopy',\n    'oncuechange', 'oncut', 'ondblclick', 'ondrag', 'ondragend',\n    'ondragenter', 'ondragleave', 'ondragover', 'ondragstart',\n    'ondrop', 'ondurationchange', 'onemptied', 'onended',\n    'onerror', 'onfocus', 'onformdata', 'onhashchange', 'oninput',\n    'oninvalid', 'onkeydown', 'onkeypress', 'onkeyup',\n    'onlanguagechange', 'onload', 'onloadeddata', 'onloadedmetadata',\n    'onloadstart', 'onmessage', 'onmessageerror', 'onmousedown',\n    'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout',\n    'onmouseover', 'onmouseup', 'onoffline', 'ononline', 'onpagehide',\n    'onpageshow', 'onpaste', 'onpause', 'onplay', 'onplaying',\n    'onpopstate', 'onprogress', 'onratechange', 'onreset', 'onresize',\n    'onrejectionhandled', 'onscroll', 'onscrollend',\n    'onsecuritypolicyviolation', 'onseeked', 'onseeking', 'onselect',\n    'onslotchange', 'onstalled', 'onstorage', 'onsubmit', 'onsuspend',\n    'ontimeupdate', 'ontoggle', 'onunhandledrejection', 'onunload',\n    'onvolumechange', 'onwaiting', 'onwheel'\n  ],\n  disallowedTagsMode: 'discard',\n  allowedAttributes: {\n    a: [ 'href', 'name', 'target' ],\n    // We don't currently allow img itself by default, but\n    // these attributes would make sense if we did.\n    img: [ 'src', 'srcset', 'alt', 'title', 'width', 'height', 'loading' ]\n  },\n  allowedEmptyAttributes: [\n    'alt'\n  ],\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n  // URL schemes we permit\n  allowedSchemes: [ 'http', 'https', 'ftp', 'mailto', 'tel' ],\n  allowedSchemesByTag: {},\n  allowedSchemesAppliedToAttributes: [ 'href', 'src', 'cite' ],\n  allowProtocolRelative: true,\n  enforceHtmlBoundary: false,\n  parseStyleAttributes: true\n};\n\nsanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {\n  merge = (merge === undefined) ? true : merge;\n  newAttribs = newAttribs || {};\n\n  return function(tagName, attribs) {\n    let attrib;\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};\n"
        },
        {
          "name": "logos",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.0986328125,
          "content": "{\n  \"name\": \"sanitize-html\",\n  \"version\": \"2.14.0\",\n  \"description\": \"Clean up user-submitted HTML, preserving allowlisted elements and allowlisted attributes on a per-element basis\",\n  \"sideEffects\": false,\n  \"main\": \"index.js\",\n  \"files\": [\n    \"index.js\"\n  ],\n  \"scripts\": {\n    \"test\": \"npx eslint . && mocha test/test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/apostrophecms/sanitize-html.git\"\n  },\n  \"keywords\": [\n    \"html\",\n    \"parser\",\n    \"sanitizer\",\n    \"sanitize\"\n  ],\n  \"author\": \"Apostrophe Technologies, Inc.\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"deepmerge\": \"^4.2.2\",\n    \"escape-string-regexp\": \"^4.0.0\",\n    \"htmlparser2\": \"^8.0.0\",\n    \"is-plain-object\": \"^5.0.0\",\n    \"parse-srcset\": \"^1.0.2\",\n    \"postcss\": \"^8.3.11\"\n  },\n  \"devDependencies\": {\n    \"eslint\": \"^7.3.1\",\n    \"eslint-config-apostrophe\": \"^3.4.0\",\n    \"eslint-config-standard\": \"^14.1.1\",\n    \"eslint-plugin-import\": \"^2.25.2\",\n    \"eslint-plugin-node\": \"^11.1.0\",\n    \"eslint-plugin-promise\": \"^4.2.1\",\n    \"eslint-plugin-standard\": \"^4.0.1\",\n    \"mocha\": \"^10.2.0\",\n    \"sinon\": \"^9.0.2\"\n  }\n}"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}