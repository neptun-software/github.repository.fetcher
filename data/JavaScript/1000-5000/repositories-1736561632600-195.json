{
  "metadata": {
    "timestamp": 1736561632600,
    "page": 195,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "unconed/TermKit",
      "stars": 4429,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1787109375,
          "content": "# the build\nbuild\nTermKit.app\n\n# temp nibs and swap files\n*~.nib\n*.swp\n\n# OS X folder attributes\n.DS_Store\n\n# user-specific XCode stuff\n*.mode1v3\n*.mode2v3\n*.pbxuser\n*.perspectivev3\n\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.2744140625,
          "content": "[submodule \"Node/node_modules/socket.io-client\"]\n\tpath = Node/node_modules/socket.io-client\n\turl = https://github.com/LearnBoost/socket.io-client\n[submodule \"Node/node_modules/socket.io-node\"]\n\tpath = Node/node_modules/socket.io-node\n\turl = https://github.com/LearnBoost/socket.io\n"
        },
        {
          "name": "Build",
          "type": "tree",
          "content": null
        },
        {
          "name": "Cocoa",
          "type": "tree",
          "content": null
        },
        {
          "name": "HTML",
          "type": "tree",
          "content": null
        },
        {
          "name": "Illustrator",
          "type": "tree",
          "content": null
        },
        {
          "name": "License.txt",
          "type": "blob",
          "size": 1.4033203125,
          "content": "Copyright (c) 2009-2011, Steven Wittens\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nThe names of contributors may not be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "Linux",
          "type": "tree",
          "content": null
        },
        {
          "name": "Mockups",
          "type": "tree",
          "content": null
        },
        {
          "name": "Node-API.md",
          "type": "blob",
          "size": 5.146484375,
          "content": "# How to write a builtin.js-style TermKit command.\n\n## Main\n\n* Make a .js file that exports a `main` function:\n\n```\nexports.main = function (tokens, pipes, exit, environment) {\n\n  exit(true); // Success\n  exit(false); // Error\n  exit(true, { ... }); // Success with meta data.\n  exit(-1); // Success with warnings\n};\n```\n\nThere is no plug-in system yet, so you'll have to:\n\n* Place it in Node/shell/builtin/.\n* Add your command to the list in `Node/shell/builtin/builtin.js`.\n\n### Arguments\n\n`tokens` is an array of strings representing the arguments including the executable itself, i.e. classic 'argv'.\n e.g. [ 'echo', 'Hello world!' ].\n \n`pipes` is an object with the 5 TermKit pipes: Data In/Out, View In/Out, and Error Out.\n\n`exit` is a function to call when ending the process. This call can be nested inside asynchronous closures. Pass `true` for success, `false` for error, -1 for success with warnings. You can pass out additional meta-data in the second argument, though this is currently not used for anything.\n\n`environment` is a read-only object with name-value pairs containing the execution environment.\n\n## Pipes \n\nThe 5 pipes are:\n\n* `dataIn`, `dataOut` correspond to classic stdIn / stdOut. Treat them as a Readable/Writeable stream.\n* `errorOut` corresponds to classic stdError. Treat it as a Writeable stream.\n* `viewIn` is an event emitter that fires 'message' events.\n* `viewOut` is a function that can be called to invoke a method in the front-end view.\n\nHowever, Data In/Out come with one caveat. The streams are prefixed with MIME headers.\n\nWhen generating output, always write the MIME headers once at the beginning of the stream. Only a Content-Type is required, but you are encouraged to provide useful metadata, preferably re-using common web standards like Content-Disposition.\n\nThis is made easy with the built-in meta module. Here is e.g. `echo.js`:\n\n```\nvar meta = require('shell/meta');\n\nexports.main = function (tokens, pipes, exit) {\n\n  // Prepare text.\n  tokens.shift();\n  var data = tokens.join(' ');\n\n  // Write headers.\n  var headers = new meta.headers();\n  headers.set({\n    'Content-Type': [ 'text/plain', { charset: 'utf-8' } ],\n    'Content-Length': data.length,\n  });\n  pipes.dataOut.write(headers.generate());\n\n  // Write data.\n  pipes.dataOut.write(data);\n\n  exit(true);\n};\n```\n\nMeta.headers has a nice getter/setter API for manipulating MIME fields and their parameters:\n\n```\n// Single setters\nset(key, value)\nset(key, param, value)\n\n// Combined value/param setter.\nset(key, [ value, { param: value, param: value } ])\n\n// Multi-value setter.\nset(key, [ value, value, value ])\nset(key, [ [ value, { param: value, param: value } ], [ value, { param: value, param: value } ] ])\n\n// Generic hash syntax.\nset({\n  key: value,\n  key: [ value, { param: value }],\n  key: [ value, value, value ],\n  key: [ [ value, { param: value, param: value } ], [ value, { param: value, param: value } ] ],\n})\n\n// Getterrs\nget('key');\nget('key', 'parameter');\n```\n\nTo handle headers on dataIn, you can use the built-in `reader.js`. To use it, create a handler object with a begin, data and end method. The reader will invoke each method as needed.\n\n```\nvar handler = { ... };\n\n// Attach reader to dataIn pipe.\nvar pipe = new reader.dataReader(pipes.dataIn,\n  function (headers) {\n    // Inspect headers, return appropriate handler\n    return handler;\n  },\n  function () {\n    // Pipe was closed\n    exit(true);\n  });\n```\n\nReader.js has two modes. It can do unbuffered I/O, where data is streamed in immediately. In this case, the begin and end handlers will each fire once, and the data handler will be fired any number of times between them (or not at all).\n\nThe other mode is buffered I/O. In this case, all the data is buffered first, and only then sent to the handler. The begin, data and end handlers will each fire once in sequence.\n\nThe handler should follow the following template:\n\n```\nvar handler = {\n  \n  /**\n   * Pipe open, headers found.\n   */\n  begin: function (headers) {\n    // Inspect headers (meta.js headers object)\n    // Decide on buffered vs unbuffered operation.\n  \n    return true; // Buffered stream.\n    return false; // Unbuffered stream.\n  },\n\n  /**\n   * Pipe data.\n   */\n  data: function (data) {\n    // Process data (Buffer)\n  },\n  \n  /**\n   * Pipe closed.\n   */\n  end: function (exit) {\n    // Cleanup.\n  \n    // Quit.\n    exit();\n  },\n};\n```\n\nIf you wish to provide informational or interactive output, you must interface with viewIn / viewOut. To make this easier, you can use `view.js`.\n\n```\nvar out = new view.bridge(pipes.viewOut);\n\n// Print hello world.\nout.print('Hello world');\n\n// 'Print' a progressbar with ID 'progress', value 0% and range 0-100%.\nvar progressBar = view.progress('progress', 0, 0, 100);\nout.print(progressBar);\n\n// Change progress bar to 50%.\nout.update('progress', { value: 50 });\n\n// Create an empty list with ID 'list' and print it.\nvar list = view.list('list');\nout.print(list);\n\n// Add two images to the list 'list'.\nvar item;\nitem = view.image(null, 'http://example.com/image1.png');\nout.add('list', item);\nitem = view.image(null, 'http://example.com/image2.png');\nout.add('list', item);\n```\n\nSee view/view.js for a full list of available widgets. The current set is incomplete.\n\n"
        },
        {
          "name": "Node",
          "type": "tree",
          "content": null
        },
        {
          "name": "Readme.md",
          "type": "blob",
          "size": 3.1796875,
          "content": "# TermKit\n\n![TermKit Icon](https://github.com/unconed/TermKit/raw/master/Illustrator/TermKit%20Icon%20128.png)\n\n### Goal: next gen terminal / command application\n\nBuilt out of WebKit and Node.js.\n\nRuns as a desktop app on Mac, Windows and Linux, and can be hacked into any WebKit browser (Chrome, Safari).\n\n[Follow TermKit on Twitter](https://twitter.com/TermKit) for the latest news and updates.\n\nFor the background and architecture, please read and comment on:\nhttp://acko.net/blog/on-termkit\n\n![TermKit 0.3 alpha](https://github.com/unconed/TermKit/raw/master/Mockups/Shot-0.3.png)\n![TermKit 0.3 alpha](https://github.com/unconed/TermKit/raw/master/Mockups/Shot-Self-Commit.png)\n![TermKit 0.3 alpha](https://github.com/unconed/TermKit/raw/master/Mockups/Shot-Highlight.png)\n\n### Warning: Alpha version, still under development. Nothing works yet.\n\n## Some cool features\n\n* Smart token-based input with inline autocomplete and automatic escaping\n* Rich output for common tasks and formats, using MIME types + sniffing\n* Asynchronous views for background / parallel tasks\n* Full separation between front/back-end\n\n## TermKit is not a...\n* ...Web application. It runs as a regular desktop app.\n* ...Scripting language like PowerShell or bash. It focuses on executing commands only.\n* ...Full terminal emulator. It does not aim to e.g. host 'vim'.\n* ...Reimplementation of the Unix toolchain. It replaces and/or enhances built-in commands and wraps external tools.\n\n(but you could make it do most of those things with plug-ins)\n\n## How to use:\n\nDetailed instructions are available from these sources:\n\n* [Mac OS X (OS X Daily)](http://osxdaily.com/2011/05/19/termkit-terminal-reimagined-how-to-install/)\n* [Windows (Redpoint blog)](http://blog.redpointsoftware.com.au/termkit/)\n* [Linux, Python GTK](https://github.com/unconed/TermKit/tree/master/Linux)\n* [Linux, Chrome only (Easytech blog)](http://blog.easytech.com.ar/2011/05/21/playing-with-termkit-with-chrome/) \n\nUnfortunately, TermKit currently requires some assembly.\n\n1. Install the Mac development tools (Xcode and friends).\n2. [Install node.js](https://github.com/joyent/node/wiki/Installation).\n3. If not covered in #2, install npm: `curl http://npmjs.org/install.sh | sh`\n4. Install node-mime: `npm install mime`\n5. Clone the TermKit repository: `git clone https://github.com/unconed/TermKit.git --recursive`\n6. Users of older git versions will need to type: `git submodule update --init`\n7. Run the NodeKit daemon: `cd TermKit/Node; node nodekit.js`\n\nMac:\n* Unzip and run the Mac app in Build/TermKit.zip\n\nLinux:\n* See Linux/Readme.txt\n\n*Tip:* Press ⌥⌘C to access the WebKit console.\n\n## API\n\nPreliminary instructions on how to write TermKit native commands can be found here:\nhttps://github.com/unconed/TermKit/blob/master/Node-API.md\n\n## Credits\n\nTermKit by [Steven Wittens](http://acko.net) ([@unconed](https://twitter.com/unconed)).\n\nWindows port by James Rhodes ([@hachque](https://twitter.com/hachque)).\n\nLinux Python/GTK wrapper by [Lucas S. Magalhães](https://github.com/lucassmagal).\n\nIncludes:\n\n* “NSImage+QuickLook” by Matt Gemmell (http://mattgemmell.com/source).\n* SyntaxHighlighter by Alex Gorbatchev (http://alexgorbatchev.com/SyntaxHighlighter/)\n* jQuery and jQuery UI"
        },
        {
          "name": "Shared",
          "type": "tree",
          "content": null
        },
        {
          "name": "Site",
          "type": "tree",
          "content": null
        },
        {
          "name": "sloc.sh",
          "type": "blob",
          "size": 0.458984375,
          "content": "#!/bin/sh\nloc=0\ndirs=\"HTML Node\"\n\nmv HTML/jquery.js .\nmv HTML/socket.io .\nmv Node/socket.io-node .\nmv HTML/external .\n\nfor dir in $dirs; do\n    files=`find $dir -type f | egrep -v \"svn\" | egrep -v \"(DS_Store|pdf|svn|sql|png|txt|swfupload)\"`\n    lines=`wc -l $files | tail -1 | sed \"s/total//g\"`\n    loc=$(($loc + $lines))\ndone\n\nmv socket.io HTML\nmv socket.io-node Node\nmv external HTML\nmv jquery.js HTML\n\necho \"Lines of code: $loc (not including libraries / externals)\"\n"
        },
        {
          "name": "termkit.txt",
          "type": "blob",
          "size": 10.3486328125,
          "content": " TermKit\n+++ -\nGoal: next gen terminal / command application\n\nAddresses following problems:\n1) Monospace character grid with ansi colors is not rich enough to display modern files / media / visualizations / metadata. Cannot effectively handle large output, long/wide tables or direct interaction.\n2) Piping raw/untyped binary or text streams between apps is bad for everyone:\n   * Humans have to suffer syntax, cannot reflow/manipulate output in real-time\n   * Computers have to suffer ambiguities\n3) Synchronous input/output makes you wait. SSH keystroke latency is frustrating.\n4) String-based command line requires arcane syntax, results in mistakes, repeated attempts at escaping, etc.\n5) Unix commands are \"useless by default\", and when asked, will only tell you raw data, not useful facts. e.g. \"rwxr-xr-x\" instead of \"You can't edit this file.\"\n\n+++ -\n\nPrograms / commands\n* Output processor for common cli tools\n* Custom implementation of ls and friends, with support for mimicking classic shell behaviour with a 2.0 twist\n* SQL shell\n\nCool input scenarios:\n* As you type, the command is visually tokenized and highlighted. tokens can display autocomplete suggestions, icons and indicators inline.\n* Instead of quoting and escaping, keys like \" and > just trigger the creation of special tokens which are visually different and represent e.g. a quoted string, an argument, a regular expression. to type the special characters literally, just press them twice. the 'command' is just the concatenation of these tokens, interpreted the same way a shell interprets a command.\n* Man pages are consulted inline with autocomplete options for arguments and (later) required arguments\n\nCool output scenarios:\n* Listings of files, anywhere, show an icon with distinguished typography for filename vs meta. Quicklook integration on the icon.\n* Can complete several tasks at once asynchronously, show real-time progress for all of them together in e.g. a task-list widget.\n* Command output is interactive: has elements which can be focused, selected/unselected, opened, right clicked, dragged and dropped\n\nGood desktop citizen:\n* Dragging a file on the terminal window makes a folder icon appear on the side for dropping it on the CWD. Can also drag the file into the command line to reference it as an argument.\n* Can drag files, snippets, JSON/CSV off the terminal\n* Tear-off tabs/windows\n\n+++ - Roadmap\n\n[0.1] UI prototype - DONE\n  [X] simulated in safari/webkit.app\n  [X] functional input line with tokenization, cursor keys and backspace/delete\n  [X] functional autocomplete on tokens\n  [X] simulated commands\n  [X] simulated output with collapsible sections\n \n[0.2] App prototype - DONE\n  [X] cocoa app\n  [X] webkit in single window view\n  [X] design back-end protocol\n  [X] node JS back-end, running separately\n  [X] connect socket\n  [X] run session worker\n  [X] passive command implementation\n  [X] JS module template, integrated both runtimes.\n  [X] wrap unix executable\n  [X] interactive output\n \n0.3: Command suite\n  [X] Redesign message protocol\n  [X] Viewstream integration\n  [X] 5-pipe command execution\n  [X] fix tokenfield\n  [X] filesystem autocomplete\n  [X] OS X icon loading\n  [X] inline image display\n  [X] json pretty printer\n  [X] json grep\n  [X] pipelined commands\n  [X] unix command execution\n  [X] code syntax highlighting\n  [ ] http get/post data piping\n  [ ] command decoration\n  [ ] interactive execution\n  [ ] inline man-pages tips\n  [ ] version control\n  [ ] termkit:// link handler for executing commands (intra-shell only)\n    (idea: Allan Tan)\n  [ ] interactive quicklook\n    (tip: mikey_p on hackernews)\n    qlmanage -p \"$@\" >& /dev/null\n  [ ] wildcard handling\n  [ ] regexp hinter\n\n0.4: Network & Modularity\n  [ ] SSH tunneling\n  [ ] Stand-alone daemon\n  [ ] network preview / local edit\n  [ ] tabs\n  [ ] split off command processor rules / autocomplete handlers into separable blocks\n  [ ] server-side hook system\n  [ ] add plug-in mechanism with drop-in functionality\n\n0.5: Interactive & Unix Upgrades\n  [ ] widget system\n  [ ] graphing suite\n  [ ] tear off tabs\n  [ ] alt view for LS with usable permissions, dates, etc\n  [ ] active 'top' monitor\n  [ ] gnu parallel integration/clone\n\n0.6: Theming\n  [ ] server-side push css/js / integrated web\n  [ ] themes / stylesheets\n\n+++ Components\n\nNode JS daemon = 'NodeKit'.\n + Fast enough for server work, concurrency/scaling included\n + New JS language features\n + Cross-platform on unix\n + Process / io / everything integration\n + Self-contained binary, can be included in .app\n - separate from UI / front-end, forced layer of indirection makes it unlike web programming\n - no mac-specific APIs or low-level C access\n\n => back-end platform, runs locally, can run remotely, or perhaps tunnel its interaction over SSH\n\nWebKit/Cocoa front-end\n + Rich, stylable display + jQuery\n + New JS language features\n + Intimate OS X access, Obj-C, bridgeable with JS\n\nThe split:\nFront-end = display, formatting, interaction. Always local. Runs in an (enhanced) webview/browser with a websocket to back-end.\nBack-end:\n\n1) Local NodeKit: Start node daemon on startup, connect using direct websocket ws://localhost:2222.\n2) Remote NodeKit SSH: Daemon is running, use ssh to set up tunnel between local rand port # and remote 2222. connect local websocket to tunnel.\n3) Remote NodeKit WSS: Daemon is running, use WSS to connect directly, must authenticate? don't want to replicate OpenSSH, but rudimentary auth could be useful.\n4) Basic remote shell: No nodekit daemon. Only literal commands supported. Enough to execute e.g. \"apt-get install termkit\".\n\n+++ Protocol considerations\n\n\nThe output of a termkit command is split into data and view. The data is the raw information that is piped from one process to the next. \n\nThe view is a stream of dom-like objects and operators on them.\n\nView and data are fundamentally different:\n * Data is a raw binary stream with meta-data annotation, from one process' stdout to another's stdin\n * View is a packetized stream of UI updates and callback events, going directly to the terminal.\n\n\n+++ Command architecture\n\nThe webkit front end is intended to be a view first and foremost. It is an active view that maintains its own contents based on messages to and from the back-end.\n\nproblem: if front-end is agnostic, then how to make commands smarter?\n\n > shell-OS interface is server-side\n > server-side only executes processes/commands, routes streams and provides output.\n > separeate data in/out from ui in/out. datastream vs viewstream\n \n data in/out:\n content-type: unix/pipe\n               application/jsonstream\n ...\n \n \n [ Front-End ]   ----->     [  Back-end ]\n [  WebKit   ]   websocket  [  Node.js  ]\n                                 |   \n                                 |\n                                 v *\n                            [   Shell   ]\n                            [ Worker.js ]\n \n \n Worker sets up process chain:\n \n \n  view in - callbacks / command stream\n  view out - view stream\n  stdin = data in (mime typed)\n  stdout = data out (mime typed)\n  \n                | callbacks         ^ view stream: view updates\n  stdin         v                   |\n  ---->     [   \"command [args...]\"   ]  ---->\n                                            stdout\n\n  View streams are multiplexed and sent to the front-end.\n  Front-end callbacks are routed back to the right process.\n  \n  Each process has its own view, referenced by ID number.\n  Processes cannot break out of their view.\n \n \n+++ Data vs UI glue\n\ne.g.\n get http://.../rss.xml\n content-type: application/xml\n \n -> process streams out xml data\n\n   get | grep\n   Data Stream:  .txt|html|... > .txt|html|...\n   View Stream: file metadata, download progress, grep stats (# hits)\n   Output Formatting:  turn application/xml into dynamic XML tree.\n  \n   get | ungzip | untar\n   Data Stream:  .gz  > .tar  >   nothing\n   View Stream:  file metadata, download progress, unzip progress (# files)\n   Output Formatting: no data output.\n    \n   The output formatter takes a mime-typed blob and turns into a display.\n   - Plain text or HTML\n   - Images\n   - Binary data (hex or escaped)\n   - Url/file reference with icon\n   ...\n   \n   Existing tools are wrapped to provide richer output, either by parsing\n   old school output or by interacting directly with the raw library.\n    \n+++ stream structure\n\n><{\n  termkit: '1'\n}\n\n>{\n  query: 1\n  method: session.open\n  args:\n}\n<{\n  answer: 1\n  success: true\n  args: { \n    session: 1\n  }\n}\n>{\n  query: 2\n  method: shell.environment\n  session: 1\n}\n<{\n  answer: 2,\n  success: true\n  args: { ... }\n}\n>{\n  query: 3\n  method: shell.run\n  session: 1\n  args: {\n    command: ...\n    id: 0\n  }\n}\n<{\n  method: view.allocate,\n  session: 1\n  args: {\n    id: 0\n    views: [0, 1]\n  }\n}\n<{\n  method: view.add,\n  session: 1  \n  args: {\n    view: 0\n    target: null\n    objects: [ ... ]\n  }\n}\n<{\n  method: view.add,\n  session: 1  \n  args: {\n    view: 0\n    target: [ 0 ]\n    objects: [ ... ]\n  }\n}\n>{\n  method: view.callback,\n  session: 1  \n  args: {\n    view: 0,\n    message: { .. }\n  }\n}\n<{\n  method: view.update\n  args: { ... }\n}\n<{\n  answer: 3,\n  success: true,\n  args: {\n    code: 0,\n  }\n}\n\n\nviewstream:\n\n > shell-specific interaction rules are server-side.\n > rich widget lib for display, extensible\n > widgets are streamed to client like termkit-ML. objects are smartly typed and have callback commands defined for them. callbacks can be stateful or stateless. though stateful is only intended to be used for interactive commands.\n\n tableview / listcontainer -> generic, scales from simple list to tabled headers w/ simple syntax\n object references for files and other things. are multi-typed and annotated on server-side.\n\n+++ --\nreferences:\n\ntextmate html output features\nhttp://blog.macromates.com/2005/html-output-for-commands/\n\nbcat: browser cat tool\n\nterminator: java-based terminal++\n\nprotocol:\n fastcgi, json-rpc\n\ncommand output:\n* rich output, consisting of an element tree\n* simple container types (list, table) and various viewers to represent common objects and data types\n\ncurrent widget model:\n* use a viewcontroller for each widget\n* viewcontroller own its own markup\n* simple object instantiation, widgets can create child widgets\n\nmore ideas:\n* autocorrection of mistyped commands\n* unified progress indicator during command\n* autocompleted/predicted history access\n* guard if command is dangerous / doesn't make sense\n\n+++  To read\n\nhttp://ripple.fortytwo.net/\n\nhttp://directwebremoting.org/blog/joe/2009/05/27/command_lines.html\n\nhttp://kkovacs.eu/cool-but-obscure-unix-tools\n"
        },
        {
          "name": "todo.txt",
          "type": "blob",
          "size": 4.2060546875,
          "content": "Tasks:\n[ ] autocomplete history\n[ ] backgrounding / new command trigger\n\n[ ] move escapeUnixText into front-end, unixLegacy widget\n[ ] command aliases\n[ ] async popup / completion keystroke buffering\n[ ] multiple http get\n[ ] command decoration\n[ ] interactive execution\n[ ] inline man-pages tips\n[ ] version control\n[ ] interactive quicklook\n[ ] interactive unix command attempt\n\n\nblog about:\n[ ] type coercion for multiple files: cat A B C, grep A B C\n[ ] ansi coloring / escapes\n[ ] hex viewer: | hex, or hex <file> [file ...]\n\n\nPrototype:\n\n1) UI prototypes\n\n[:] Token field\n  [X] plain text\n  [X] encapsed string\n  [X] token transmutation\n  [X] refactored code into separate files + object literal style\n  [X] design mockup\n  [X] commandstream mockup\n  [X] move validity of selection anchor/focus pos into selection obj, out of caret obj\n  [X] caret left/right with fulltoken input\n  [X] autocomplete popup / edit mode\n  [X] clickable mouse position\n  [X] fix event bindings lost when clicking inside textfield\n  [X] Unify tokenlist and commandlist into collection class, derive from.\n  [X] fix backspacing around edges of tokens\n  [X] add icon/spinner support to tokens\n  [ ] caret positions around allowempty tokens and ^/$\n  [.] | and >> token support\n  [ ] caret.remove() shouldn't need to touch tokenList when pruning empties -> let triggers do it\n  [ ] mouseclick caret is off by ~8px, but only in first token \n  [ ] switch between inline and block tokens -> input vs textarea.\n  [ ] fix wrapping of tokens\n    \n[X] inline autocomplete\n  [X] panel overlayed on token\n  [X] alignment\n  [X] keyboard controls up/down\n  [X] hit enter after autocomplete in empty token -> undefined\n  [X] escape to close popup\n  [X] autocomplete icons\n  \n[:] command view\n  [X] list of collapsible sections\n  [X] host token field\n  [X] context bar by command\n  [X] anchored scrolling\n  [X] host output\n  [X] make outputnode tree changes reflect in DOM transparently\n  [X] fix view.add mid-node insertion\n  [X] auto-expand to fill view\n  [ ] command history\n  [ ] alt-up/down to change focus\n  [ ] tabbed views\n  [ ] add forking the view with tabs and hosted/nested sessions\n\n2) Command/token autocomplete\n  [X] token multi-regexp patterns\n  [X] triggers system, unify with token field triggers a bit?\n  [X] autocomplete a string / command\n  [X] autocomplete empties\n  [X] autocomplete commands\n  [X] autocomplete filesystem\n  [X] autocomplete label / contents / icon\n  [X] autocomplete dir / file distinction\n  [X] badge tokens with icons\n\n3) Smart output with selectable things\n  [X] research FastCGI socket protocol\n  [X] add socket.io to client\n  [X] make socket connection to daemon\n  [X] set up client handling\n  [X] establish controller for stream\n  [X] invoke new session\n  [X] basic message output\n  [X] view parser/tree on client side\n  [X] list of files\n  [X] file icons\n  [X] implement view DOM v2 with path targeting\n  [X] auto-layout mechanism w/ padded max-height on view\n  [ ] unified viewcontroller class w/ self-dom insertion\n  [ ] intercontrol focus / caret, set up global manager\n  [ ] tab, switch between widgets.\n  [ ] working widget callbacks\n  [ ] auto-layout column width (preferred size from widgets + widget variant/style)\n  [ ] make file icons cacheable long-term in webkit cache\n  [ ] stable multi-column layout\n  [ ] smart tab-tabling layout for plain-text\n\n4) NodeKit daemon\n  [X] socket.io listener\n  [X] keep state of sessions\n  [X] export environment\n  [X] allow path navigation\n  [X] worker process\n    [X] refactor processor.js handler/return handling\n    [X] spawn process\n    [X] stream in/out json packets\n    [X] view proxy object on worker side\n    [X] make ls / cd commands\n    [X] simplify message format to raw json\n    [X] viewstream integration\n    [X] data reader\n    [ ] arrange view pipes for command/view for unix processes\n  [X] output formatter\n    [X] full mime header parser/generator\n    [X] smart binary output\n    [ ] handle encodings\n  [ ] backgrounding / new command trigger\n  [ ] command aliases\n  [X] preferences\n  [ ] sudo support (askpass env?)\n\n5) Command Suite\n[X] JSON grep\n[X] code syntax highlighter\n[ ] make a script for git (arguments, file/dir, ...)\n[ ] basic top/w infographs + live update\n[ ] robust unix basics\n[ ] mysql console\n[ ] ssh support\n"
        }
      ]
    }
  ]
}