{
  "metadata": {
    "timestamp": 1736562090884,
    "page": 873,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jofpin/turbit",
      "stars": 3196,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.169921875,
          "content": "# http://editorconfig.org\n\nroot = true\n\n[*]\nindent_style = space\nindent_size = 4\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = false"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.064453125,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.05859375,
          "content": ".DS_Store\n.idea\nnode_modules\nnpm-debug.log\npackage-lock.json"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "MIT License\n\nCopyright (c) 2024 Jose Pino\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.384765625,
          "content": "# Turbit\n\n![turbit](assets/images/gh-cover.png)\n\n## High-speed Multicore Computing\n\n[![npm version](https://img.shields.io/npm/v/turbit.svg)](https://www.npmjs.com/package/turbit)\n\nTurbit is an advanced high-speed multicore computing library in Node.js, designed to optimize performance for computationally intensive operations by leveraging parallel processing across multiple CPU cores.\n\n> Create powerful applications, scripts, and automations with enhanced\n> performance through parallel processing. **Turbit was designed for the multi-core era.**\n\n## Key Applications\n\nTurbit excels at optimizing resource-intensive operations, making it ideal for:\n\n| Application | Description |\n|-------------|-------------|\n| Data Processing and Analysis | Efficiently handle and analyze large volumes of data |\n| Scientific Computations | Accelerate complex scientific calculations and simulations |\n| Batch Processing | Process large datasets quickly and efficiently |\n| Complex Algorithmic Operations | Speed up execution of complex algorithms and mathematical operations |\n\n## Inspiration\n\nAs a researcher, I often struggled to find a truly user-friendly implementation for parallel processing in Node.js. Most existing solutions were not user-friendly, complex, and unwieldy, making it challenging to efficiently harness CPU power for high-performance tasks. This inspired me to create Turbit, a library that simplifies parallel processing in applications and processes, allowing developers to easily tap into the full potential of their hardware without getting bogged down in implementation details. With AI advancements, many people have chosen to exclusively use the GPU to process data and perform complex tasks. However, although the CPU is not always directly compared to the GPU in terms of performance for certain tasks, it also has great potential that should not be underestimated. Turbit facilitates the harnessing of this potential, enabling efficient parallel processing on the CPU.\n\n_*One of my goals when creating things is always to simplify them as much as possible for others and, of course, to make them unique.*_\n\n> The code is art, akin to music and other creative fields. I created Turbit out of passion and love for coding. Writing code is not just a daily habit for me, it's a task of focus and discipline, driven by my lifelong love for technology. During the final stages of developing this library and its two powerful use cases, throughout the code writing process, I constantly listened to some songs that I'd like to share:\n>\n> - [Monaco](https://www.youtube.com/watch?v=_PJvpq8uOZM) - Bad Bunny: \"Dime (dime), dime, ¿esto es lo que tú querías?\"\n> - [Los Pits](https://www.youtube.com/watch?v=yaHf1FwMYA4) - Bad Bunny: \"Te lo dije que me hacía millo antes de los treinta.\"\n> - [1 of 1](https://www.youtube.com/watch?v=21Z0GoTYqkE) - Maluma: \"Mi carrera es una chimba 1 of 1, me voy y vuelvo y los bajo de number one.\"\n> - [Mírame](https://www.youtube.com/watch?v=zcw8NlHljF4) - Blessd: \"No cualquiera puede aguantar mi ritmo.\"\n> - [Vuelve candy b](https://www.youtube.com/watch?v=UBVm40IONzw) - Bad Bunny: \"¿Cómo tú vas a dudar del más cabrón que le mete?\"\n> - [Otra noche en miami](https://www.youtube.com/watch?v=hoQmSA6MRAk) - Bad Bunny: \"Todo es superficial, nada real, nada raro que el dinero no pueda comprar.\"\n> - [Decisions](https://www.youtube.com/watch?v=jQd5OEl1W-Q) - Borgore & Miley Cyrus: \"Decisions, but I want it all.\"\n> - [Si tú supieras](https://www.youtube.com/watch?v=75gaEbTLqpg) - Feid: \"Baby, perdón, pero el tiempo que no estoy contigo es tiempo perdido.\"\n> - [Brickell](https://www.youtube.com/watch?v=2p6O7EmroEs) - Feid: \"Ojalá me hubieras dicho que era la última vez.\"\n> - [Meek Mill](https://www.youtube.com/watch?v=S1gp0m4B5p8) - Drake: \"Playin' with my name, that's lethal, dawg (who you say you was?)\"\n> - [La Jumpa](https://www.youtube.com/watch?v=ubbE6gyBf8k) - Arcangel & Bad Bunny: \"Hoy tú te vas con una leyenda que no va a volver a nacer.\"\n\nAs I reflect on this project, I can't help but wonder: Perhaps these are among the last lines of code written 100% by a human. Regardless, I hope you enjoy this code as much as I enjoyed writing it.\n\n> Always the same creative hacker, but more evolved. - [Jose Pino](https://x.com/jofpin)\n\n## Getting Started\n\nTurbit's only dependency is the built-in `child_process` module in Node.js for managing child processes.\n\nTo use Turbit, you need to have **[Node.js](https://nodejs.org/)** installed. Then, you can install Turbit using npm:\n\n```shell\nnpm install turbit\n```\n\nAfter installation, import it in your code as follows:\n\n```js\nconst Turbit = require(\"turbit\");\n// Create a Turbit instance for parallel processing\nconst turbit = Turbit();\n```\n\n## Usage\n\n#### RUN (Main Function)\n\nTurbit provides a `run` function to execute tasks across multiple cores for parallel processing.\n\n```js\nturbit.run(func, options)\n```\n\n**Parameters**\n\n1. `func` (Function): The function to be executed in parallel. This is the task you want to distribute across multiple cores.\n\n2. `options` (**Object**): Configuration options for the execution.\n   - `type` (**required**, string): Specifies the type of execution. Can be either \"simple\" or \"extended\".\n     - **simple**: Use this when you have a single task that doesn't require input data.\n     - **extended**: Use this when you have a set of data that needs to be processed in parallel. It divides the input data into chunks and distributes them across multiple processes for simultaneous processing.\n   \n   - `data` (**optional**, array): The data to be processed in parallel. This is required for \"extended\" type executions. Each item in this array will be passed as an argument to your function.\n\n   - `args` (**optional**, object): Additional arguments to pass to the function. These will be passed to your function along with the data item (for \"extended\" type).\n   \n   - `power` (**required**, number): Controls the intensity of parallel processing. Values range from 1 to 100 for normal system resource utilization. Values above 100 enable an intentional system overload mode, allowing for more processes than the system would typically handle. Default is 70.\n     - `power: 1-100`: Normal utilization of system resources.\n     - `power: > 100`: Overload mode. Allows generating more processes than the system would normally handle.\n\n     **Note**: Using `power` > 100 can lead to increased RAM usage, significant CPU utilization, and potential system instability. Use this feature with caution and only when necessary for extremely intensive processing tasks. Suitable use cases include:\n     - Processing large datasets in limited time\n     - Complex simulations requiring multiple parallel iterations\n     - High-intensity rendering or scientific calculations\n     - Intensive cryptographic operations and brute-force processes\n\n**Returns**\n- A promise that resolves with the execution results and statistics.\n  - `data` (**Array**): The results of the executed function.\n  - `stats` (**Object**): Performance statistics of the execution.\n    - `timeTakenSeconds`: The total execution time in seconds.\n    - `numProcessesUsed`: The number of processes used for the execution.\n    - `dataProcessed`: The amount of data items processed.\n    - `memoryUsed`: The amount of memory used during execution.\n\n\nThe `stats` object provides valuable insights into the performance of your parallel processing tasks. It allows you to monitor execution time, resource utilization, and processing efficiency, which can be crucial for optimizing your applications.\n\n#### KILL (Function)\n\nTurbit provides a `kill` function to terminate all active child processes and free system resources.\n\n```js\nturbit.kill();\n```\n\n## Architecture\n\nTurbit utilizes a parallel processing architecture based on Node.js `child_process` module. Here's a brief overview of how it works:\n\n1. **Initialization**: Turbit creates a pool of child processes up to the maximum number of available CPU cores when the Turbit instance is created.\n\n2. **Task Distribution**: When `turbit.run()` is called, the library prepares the task for parallel execution. For '**simple**' type, it replicates the task across processes. For '**extended**' type, it divides the input data into chunks for distribution across processes. The number of processes used is determined by the `power` parameter.\n\n3. **Process Management**: Turbit manages the pool of child processes, creating additional processes or terminating excess ones as needed based on the `power` parameter for each `run()` call.\n\n4. **Parallel Execution**: Tasks are distributed across child processes, allowing for simultaneous utilization of multiple CPU cores.\n\n5. **Inter-Process Communication**: Turbit uses Node.js built-in messaging system to send function definitions and arguments to child processes, and to receive results back.\n\n6. **Result Collection**: As child processes complete their tasks, results are gathered and consolidated into a single output.\n\n7. **Performance Tracking**: Turbit monitors and reports execution time, number of processes used, amount of data processed, and memory consumption.\n\n## Examples\n\nHere are some examples of how to use Turbit:\n\n#### Simple Execution\n\n```js\n// Define a simple task function\nconst task = function() {\n    return \"Hello, humans and intelligent machines!\";\n}\n\n// Implement Turbit for parallel processing\nturbit.run(task, { type: \"simple\", power: 100 })\n    .then(result => {\n        console.log(\"Simple execution result:\", result.data);\n        turbit.kill(); // Cleans up child processes after completing the task\n    })\n    .catch(error => {\n        console.error(\"Error in simple execution:\", error);\n        turbit.kill(); // Make sure to call kill even if there's an error\n    });\n```\n\n#### Extended Execution\n\n```js\n// Define a calculation function to be executed in parallel\nfunction calculate(item) {\n    return item * 12;\n}\n\n// Implement Turbit for parallel processing\nturbit.run(calculate, {\n        type: \"extended\",  // Use extended mode for processing an array of data\n        data: [1, 2, 3, 4],  // Input data to be processed in parallel\n        power: 75  // Set processing intensity to 75% of available resources\n    })\n    .then(result => {\n        console.log(\"Extended execution results:\", result.data);\n        turbit.kill(); // Terminate all active child processes\n    })\n    .catch(error => {\n        console.error(\"Error in extended execution:\", error);\n        turbit.kill(); // Ensure termination of child processes in case of error\n    });\n```\n\n#### Turbit Showcase: Parallel Password Security Cracking\n\nThis example demonstrates a more complex use of Turbit in a cybersecurity context by simulating parallel dictionary-based password cracking. Please note that this is an example code, designed and limited to show another Turbit implementation scenario for educational purposes. It's not recommended to use it for real-world password cracking:\n\n```js\n/**\n * Script functionality:\n * - Simulates a user database with passwords\n * - Uses a dictionary to attempt password cracking\n * - Leverages Turbit for parallel processing to enhance cracking speed\n * - Demonstrates efficiency in data-intensive security tasks\n */\n\n// Importing turbit (you must install with 'npm install turbit' in the terminal)\nconst Turbit = require(\"turbit\");\n\n/**\n * Executes a simulated password cracking attempt using Turbit distributed computing.\n */\nconst basicPasswordCracker = {\n  attack: async function({ users, dictionary }) {\n    if (!users || !dictionary) {\n      throw new Error(\"Both users and dictionary must be provided\");\n    }\n\n    // Create a Turbit instance for parallel processing\n    const turbit = Turbit();\n\n    try {\n      // Implement Turbit for parallel processing: Distribute the cracking workload across available resources\n      const result = await turbit.run(\n        (input) => {\n          const { data, args } = input;\n          const { dictionary } = args;\n\n          // Process each user password in parallel\n          return data.map(user => {\n            for (const word of dictionary) {\n              if (word === user.password) {\n                return { ...user, crackedPassword: word, attempts: dictionary.indexOf(word) + 1 };\n              }\n            }\n            return { ...user, crackedPassword: null, attempts: dictionary.length };\n          });\n        },\n        {\n          type: \"extended\", // Use extended type for processing an array of data\n          data: users, // The array of user objects to process\n          args: { dictionary }, // Additional arguments passed to the function\n          power: 100 // Utilize full available computing power\n        }\n      );\n\n      // Compile and format the results\n      const output = {\n        results: result.data.map(user => ({\n          username: user.username,\n          passwordCracked: user.crackedPassword !== null,\n          crackedPassword: user.crackedPassword,\n          attempts: user.attempts\n        })),\n        stats: result.stats // Include performance metrics\n      };\n\n      // Output the results in a readable JSON format\n      console.log(JSON.stringify(output, null, 2));\n    } catch (error) {\n      console.error(\"Error during execution:\", error);\n    } finally {\n      turbit.kill(); // Ensure proper cleanup of Turbit resources\n    }\n  }\n};\n\n// Demonstrating the setup and execution of the password cracker\n(async () => {\n    \n  // Simulated victim user database (for demonstration purposes only)\n  const victims = [\n    { username: \"elonmusk\", password: \"Mars2028@\" },\n    { username: \"stevejobs\", password: \"iThink1Different\" },\n    { username: \"josepino\", password: \"H4ck3r2024\" },\n    { username: \"maxi\", password: \"theNextGeneration\" },\n    { username: \"lucian\", password: \"2024Created\" }\n  ];\n\n  // Sample dictionary for the cracking attempt\n  const dictionary = [\n    \"dreams2027\", \"123456\", \"qwerty\", \"admin\", \"letmein\",\n    \"welcome\", \"rocket\", \"1234\", \"12345\", \"test\", \"pino\", \n    \"medellin\", \"miami\", \"letme1n\", \"abcdef12345\", \"1337\", \n    \"hack1ng\", \"trustno1\", \"thegoat\", \"master\", \"Mars2028@\", \n    \"iThink1Different\", \"H4ck3r2024\", \"theNextGeneration\", \n    \"NextComputer\", \"SpaceX\", \"Tesla\", \"singapur\", \"Neuralink\", \"Apple\",\n    \"iPhone\", \"Macintosh\", \"SiliconValley\", \"Innovation\", \"china\"\n    \"Coding\", \"Ovnis\", \"Dubai\", \"1234567890\", \"jofpin\"\n  ];\n\n  try {\n    await basicPasswordCracker.attack({ victims, dictionary });\n  } catch (error) {\n    console.error(\"Error running password cracker:\", error);\n  }\n})();\n```\n\nCheck out the [examples](examples) directory for more detailed usage examples.\n\n## Benchmarking\n\nTurbit includes a built-in benchmarking tool to measure the performance gains of parallel processing. To run the benchmark, use the following command in your terminal:\n\n```shell\nnode benchmark/speedTest.js\n```\n\nThis tool compares standard sequential processing with Turbit parallel processing, providing:\n\n1. Execution times for each method\n2. Average processing times\n3. Performance improvements (speed increase, time saved)\n4. Practical implications of using Turbit\n\nUse this benchmark to quantify Turbit benefits for your specific use cases and optimize your parallel processing implementations.\n\n#### Custom Benchmarking\n\nYou can also benchmark your own scripts by modifying [`benchmark/speedTest.js`](benchmark/speedTest.js):\n\n```javascript\nSpeedTest.benchmark({\n  standardScript: \"path/standard_script.js\",\n  turbitScript: \"path/turbit_script.js\"\n}); \n```\n\n## Tools Powered by Turbit\n\nI created these two powerful tools with unique interfaces to demonstrate the potential of Turbit through real-world applications:\n\n- [**synthBTC**](https://github.com/jofpin/synthBTC): A tool that leverages advanced Monte Carlo simulations to generate Bitcoin price prediction scenarios.\n- **bitbreak**: A high-performance Bitcoin private key brute-force tool. [IN PROGRESS]\n\n------------\n\n> #### ⚠️ **RECOMMENDATION**\n\n> For optimal performance, consider the size and complexity of your tasks. Very small tasks might not benefit from parallelization due to the overhead of creating and managing child processes.\n\n> #### ℹ️ **TIPS**\n\n> 1. Use the \"extended\" type for data-parallel tasks where you have a large array of items to process.\n> 2. Adjust the `power` option based on your system's capabilities and the nature of your tasks.\n\n## License\n\nThe content of this project itself is licensed under the [Creative Commons Attribution 3.0 license](http://creativecommons.org/licenses/by/3.0/us/deed.en_US), and the underlying source code used to format and display that content is licensed under the [MIT license](LICENSE).\n\nCopyright (c) 2024 by [**Jose Pino**](https://x.com/jofpin)\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.7783203125,
          "content": "{\n  \"name\": \"turbit\",\n  \"version\": \"1.0.0\",\n  \"description\": \"High-speed multicore computing library for optimizing intensive operations through parallel CPU processing.\",\n  \"main\": \"turbit.js\",\n  \"directories\": {\n    \"images\": \"assets/images\",\n    \"example\": \"examples\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jofpin/turbit.git\"\n  },\n  \"keywords\": [\n    \"javascript\",\n    \"nodejs\",\n    \"cpu-booster\",\n    \"multicore\",\n    \"high-performance\",\n    \"multiprocessing\",\n    \"data-processing\",\n    \"multithreading\",\n    \"parallelism\",\n    \"parallel-programming\",\n    \"parallel-computing\"\n  ],\n  \"author\": \"Jose Pino\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/jofpin/turbit/issues\"\n  },\n  \"homepage\": \"https://github.com/jofpin/turbit#readme\"\n}"
        },
        {
          "name": "turbit.js",
          "type": "blob",
          "size": 15.662109375,
          "content": "/**\n * turbit.js\n * High-speed multicore computing library for optimizing intensive operations through parallel CPU processing.\n *\n * @author Jose Pino\n * @contact jose@pino.sh (https://x.com/jofpin)\n * @version 1.0.0\n * @license MIT\n *\n * Find the project on GitHub:\n * https://github.com/jofpin/turbit\n *\n * ===============================\n * Copyright (c) 2024 by Jose Pino\n * ===============================\n *\n * Released on: August 2, 2024\n * Last update: August 2, 2024\n *\n */\nif (typeof process === \"undefined\" || !process.versions || !process.versions.node) {\n    console.error(\"Turbit is developed for Node.js and does not support browsers.\");\n} else {\n    const childProcess = require(\"child_process\");\n    const os = require(\"os\");\n\n    if (process.argv[2] === \"child\") {\n        process.on(\"message\", async (message) => {\n            try {\n                const func = new Function(\"return \" + message.func)();\n                let result;\n                if (Array.isArray(message.args)) {\n                    result = func(...message.args);\n                } else {\n                    result = func(message.args);\n                }\n                process.send({ result });\n            } catch (error) {\n                process.send({ error: error.message });\n            }\n        });\n    } else {\n        /**\n         * Creates a Turbit instance for high-speed multicore computing.\n         */\n        const Turbit = () => {\n            const MAX_PROCESSES = os.cpus().length;\n            let CHILD_PROCESSES = [];\n            /**\n             * core: Manages child processes and task distribution for parallel execution.\n             */\n            const core = {\n                startProcesses: function (numProcesses = MAX_PROCESSES) {\n                    for (let i = CHILD_PROCESSES.length; i < numProcesses; i++) {\n                        try {\n                            const newChildProcess = childProcess.fork(__filename, [\"child\"]);\n                            CHILD_PROCESSES.push(newChildProcess);\n                        } catch (error) {\n                            console.log(`Error: Maintaining current level of child processes due to resource limitation - ${error.message}`);\n                            break;\n                        }\n                    }\n                },\n                killProcesses: function () {\n                    CHILD_PROCESSES.forEach(worker => {\n                        if (!worker.killed) {\n                            worker.kill();\n                            worker.removeAllListeners();\n                        }\n                    });\n\n                    CHILD_PROCESSES = [];\n                },\n                createWorkerPromises: function (tasks, numProcesses) {\n                    return tasks.map((task, index) => {\n                        const worker = CHILD_PROCESSES[index % numProcesses];\n                        return new Promise((resolve, reject) => {\n                            worker.send({\n                                func: task.func.toString(),\n                                args: task.args || []\n                            });\n                            worker.once(\"message\", (message) => {\n                                if (message.error) {\n                                    reject(new Error(message.error));\n                                } else {\n                                    resolve(message.result);\n                                }\n                            });\n                        });\n                    });\n                },\n                calculateNumProcesses: function (power) {\n                    const percentage = Math.max(power, 0) / 100;\n                    return Math.max(Math.round(MAX_PROCESSES * percentage), 1);\n                }\n            };\n            /**\n             * helper: Provides utility functions for system metrics, data formatting, and execution statistics.\n             */\n            const helper = {\n                getCurrentCpuLoad: function () {\n                    return os.loadavg()[0];\n                },\n                getCurrentMemoryUsage: function () {\n                    const totalMemory = os.totalmem();\n                    const freeMemory = os.freemem();\n                    return ((totalMemory - freeMemory) / totalMemory) * 100;\n                },\n                // calculateBytes: Function to calculate the weight of the bytes, extracted from the temcrypt project: https://github.com/jofpin/temcrypt/blob/main/temcrypt.js#L223\n                calculateBytes: function (bytes) {\n                    const units = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\n                    const kbytes = 1024;\n\n                    if (bytes === 0) {\n                        return \"0 Bytes\";\n                    }\n\n                    const index = Math.floor(Math.log(bytes) / Math.log(kbytes));\n                    const convertBytes = bytes / Math.pow(kbytes, index);\n                    const calculateBytes = convertBytes % 1 === 0 ? convertBytes.toFixed(0) : convertBytes.toFixed(2);\n\n                    return `${calculateBytes} ${units[index]}`;\n                },\n                // showStats: You can see performance statistics and the result of consumed resources.\n                showStats: function (startTime, numProcesses, dataLength, initialMemory) {\n                    const endTime = Date.now();\n                    const duration = (endTime - startTime) / 1000;\n                    const totalRAMAfter = os.freemem();\n                    const memoryUsed = initialMemory - totalRAMAfter;\n                    return {\n                        timeTakenSeconds: duration,\n                        numProcessesUsed: numProcesses,\n                        dataProcessed: dataLength,\n                        memoryUsed: this.calculateBytes(memoryUsed)\n                    };\n                }\n            };\n            /**\n             * types: Defines execution strategies (simple and extended) for tasks, leveraging parallel processing capabilities.\n             */\n            const types = {\n                // simpleType: Executes a task using a simple execution strategy, without parallel processing.\n                simpleType: async function (func, numProcesses) {\n                    const initialMemory = os.freemem();\n                    const startTime = Date.now();\n\n                    const tasks = Array(numProcesses).fill({\n                        func,\n                        args: []\n                    });\n\n                    const promises = core.createWorkerPromises(tasks, numProcesses);\n                    const output = await Promise.all(promises);\n                    return {\n                        data: output,\n                        stats: helper.showStats(startTime, numProcesses, output.length, initialMemory)\n                    };\n                },\n                // extendedType: Executes tasks using an extended execution strategy, with parallel processing across multiple CPU cores.\n                extendedType: async function (func, data, numProcesses, args) {\n                    const initialMemory = os.freemem();\n                    const startTime = Date.now();\n\n                    const chunkSize = Math.ceil(data.length / numProcesses);\n                    const dataChunks = [];\n                    for (let i = 0; i < data.length; i += chunkSize) {\n                        dataChunks.push(data.slice(i, i + chunkSize));\n                    }\n                    \n                    const tasks = dataChunks.map(chunk => ({\n                        func,\n                        args: Object.keys(args).length ? { data: chunk, args } : [chunk]\n                    }));\n\n                    const promises = core.createWorkerPromises(tasks, numProcesses);\n                    const output = await Promise.all(promises);\n                    return {\n                        data: output.flat(),\n                        stats: helper.showStats(startTime, numProcesses, data.length, initialMemory)\n                    };\n                }\n            };\n            /**\n             * Initializes child processes up to the maximum available CPU cores. This step is essential for setting up the parallel processing environment before any tasks are submitted for execution. Invoking this method at the start ensures that the system is ready to distribute tasks across multiple processes, optimizing performance and resource utilization from the outset.\n             */\n            core.startProcesses();\n\n            return {\n                /**\n                  * Executes a given function across multiple cores for parallel processing, with the level of parallelism based on the specified execution type and power percentage.\n                  *\n                  * Before using `run`, you must import and initialize `Turbit` as shown below:\n                  * @example\n                  * const Turbit = require('turbit'); // Adjust the path as needed if `turbit` is located in a different directory\n                  * const turbit = Turbit(); // Initialize Turbit to use its methods\n                  *\n                  * @param {Function} func - The function to be executed. This function should be capable of operating on the provided data, if applicable.\n                  * @param {Object} options - The options for execution.\n                  * @param {string} [options.type=\"simple\"] - The type of execution: \"simple\" for execution with a default level of parallel processing, or \"extended\" for customized parallel processing across multiple CPU cores.\n                  * @param {Array} [options.data=[]] - The data to be processed. Required for the \"extended\" type execution to distribute data across processes.\n                  * @param {Array} [options.args={}] - The arguments to be passed to the function. Optional for the \"extended\" type execution to provide extra arguments to the function.\n                  * @param {number} [options.power=50] - The processing power to use, as a percentage of total available CPU cores. Determines the number of child processes spawned for both \"simple\" and \"extended\" type execution.\n                  * @returns {Promise<Object>} - The result of the execution, including any data processed and statistics about the execution, such as time taken and memory used.\n                  *\n                  * - For \"simple\" type:\n                  *   - Executes the function across multiple processes, using a default level of parallel processing determined by the `power` option.\n                  *   - The `data` option is ignored for this type, assuming the function does not require input data or processes static data.\n                  *\n                  * - For \"extended\" type:\n                  *   - Distributes the provided `data` across multiple processes for parallel processing, with the degree of parallelism customized through the `power` option.\n                  *   - The `data` option must be an array of items, which will be processed in chunks across the spawned processes.\n                  *\n                  * \n                  * @example\n                  * // Example usage for simple execution with parallel processing\n                  * function simpleTask() {\n                  *   // This example function performs a simple operation\n                  *   return \"Simple task completed\";\n                  * }\n                  *\n                  * \n                  * turbit.run(simpleTask, { type: \"simple\", power: 100 })\n                  *   .then(result => console.log(\"Simple execution result:\", result))\n                  *   .catch(error => console.error(\"Error in simple execution:\", error));\n                  *\n                  * // Example usage for extended execution with customized parallel processing\n                  * function exampleFunction(item) {\n                  *   // This example function doubles the input\n                  *   return item * 2;\n                  * }\n                  *\n                  * \n                  * turbit.run(exampleFunction, {\n                  *   type: \"extended\",\n                  *   data: [1, 2, 3, 4], // Data to be processed in parallel\n                  *   power: 75 // Use 75% of available CPU cores for enhanced parallel processing\n                  * })\n                  *   .then(result => console.log(\"Extended execution results:\", result.data))\n                  *   .catch(error => console.error(\"Error in extended execution:\", error));\n                  *\n                  * @throws {Error} If the `func` is not a function or if required parameters for the chosen execution type are not provided or are invalid.\n                  */\n                run: async (func, options = {}) => {\n                    let { data = [], args = {}, type = \"simple\", power = 70 } = options;\n                    let numProcesses = core.calculateNumProcesses(power);\n\n                    if (numProcesses > CHILD_PROCESSES.length) {\n                        core.killProcesses();\n                        core.startProcesses(numProcesses);\n                    }\n\n                    const handlers = {\n                        \"simple\": async () => {\n                            if (data.length > 0) {\n                                throw new Error(\"Simple execution type should not include 'data'. Please ensure 'data' is empty or not provided for simple tasks.\");\n                            }\n                            if (typeof func !== \"function\") {\n                                throw new Error(\"For 'simple' execution type, 'func' must be a valid function. Please check that 'func' is defined correctly as a function.\");\n                            }\n                            try {\n                                return await types.simpleType(func, numProcesses);\n                            } catch (e) {\n                                throw new Error(`Error executing 'simple' type with function ${func.name || 'anonymous'}: ${e.message}`);\n                            }\n                        },\n                        \"extended\": async () => {\n                            if (data.length === 0) {\n                                throw new Error(\"Extended execution type requires a non-empty 'data' array. Ensure 'data' is provided and contains elements.\");\n                            }\n                            if (typeof func !== \"function\") {\n                                throw new Error(\"For 'extended' execution type, 'func' must be a valid function. Verify that 'func' is correctly defined as a function.\");\n                            }\n                            try {\n                                return await types.extendedType(func, data, numProcesses, args);\n                            } catch (e) {\n                                throw new Error(`Error executing 'extended' type with function ${func.name || 'anonymous'}: ${e.message}`);\n                            }\n                        }\n                    };\n\n                    if (!handlers[type]) {\n                        throw new Error(`Invalid execution type specified: '${type}'. Valid types are 'simple' and 'extended'.`);\n                    }\n\n                    try {\n                        return await handlers[type]();\n                    } catch (error) {\n                        console.error(\"Error during Turbit execution:\", error.message);\n                    }\n                },\n                /**\n                 * kill: Terminates all active child processes to ensure a clean shutdown and free system resources. This method is crucial for preventing resource leaks and ensuring that the system remains stable and responsive after the completion of parallel tasks. It should be invoked when all parallel processing tasks are completed, or when the Turbit instance is no longer needed.\n                 */\n                kill: core.killProcesses\n            };\n        };\n\n        module.exports = Turbit;\n    }\n}"
        }
      ]
    }
  ]
}