{
  "metadata": {
    "timestamp": 1736562056861,
    "page": 820,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kennethcachia/background-check",
      "stars": 3267,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01171875,
          "content": "node_modules"
        },
        {
          "name": "Gruntfile.js",
          "type": "blob",
          "size": 2.2001953125,
          "content": "\nmodule.exports = function (grunt) {\n\n  grunt.initConfig({\n\n    pkg: grunt.file.readJSON('package.json'),\n\n    watch: {\n      source: {\n        files: ['background-check.js'],\n        tasks: ['clean:source', 'jshint', 'uglify', 'copy']\n      },\n\n      examples: {\n        files: ['examples/src/*/*.*'],\n        tasks: ['clean:examples', 'assemble']\n      },\n\n      examplesJS: {\n        files: ['examples/build/scripts/*.js', '!examples/build/scripts/*.min.js'],\n        tasks: ['jshint']\n      }\n    },\n\n    assemble: {\n      options: {\n        flatten: true,\n        data: 'examples/src/data/*.json',\n        layout: 'examples/src/layouts/default.hbs',\n        partials: ['examples/src/partials/*.hbs']\n      },\n      build: {\n        files: [{\n          src: ['examples/src/pages/*.hbs'],\n          dest: 'examples/build/'\n        }]\n      }\n    },\n\n    jshint: {\n      files: ['background-check.js', 'examples/build/scripts/*.js', '!examples/build/scripts/*.min.js'],\n      options: {\n        'white': true,\n        'indent': 2,\n        'curly': true,\n        'eqnull': true,\n        'latedef': true,\n        'newcap': true,\n        'noarg': true,\n        'eqeqeq': true,\n        'immed': true,\n        'undef': true,\n        'unused': true,\n        'browser': true,\n        'globals': {\n          'console': false,\n          'define': false,\n          'require': false\n        }\n      }\n    },\n\n    clean: {\n      source: ['background-check.min.js', 'examples/build/scripts/background-check.min.js'],\n      examples: ['examples/build/*.html']\n    },\n\n    uglify: {\n      options: {\n        banner: '/* BackgroundCheck\\n   <%= pkg.homepage %>\\n   v<%=pkg.version %> */\\n\\n'\n      },\n      build: {\n        src: 'background-check.js',\n        dest: 'background-check.min.js'\n      }\n    },\n\n    copy: {\n      min: {\n        src: 'background-check.min.js',\n        dest: 'examples/build/scripts/background-check.min.js'\n      }\n    }\n\n  });\n\n  grunt.loadNpmTasks('assemble');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n  grunt.loadNpmTasks('grunt-contrib-jshint');\n  grunt.loadNpmTasks('grunt-contrib-clean');\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  grunt.loadNpmTasks('grunt-contrib-copy');\n\n  grunt.registerTask('default', ['watch']);\n\n};\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Kenneth\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.7333984375,
          "content": "#BackgroundCheck\n\nAutomatically switch to a darker or a lighter version of an element depending on the brightness of images behind it.\n\n**Examples**\n\n+ [Project Page](http://kennethcachia.com/background-check/)\n+ [Slider](http://kennethcachia.com/background-check/slider.html)\n+ [Fixed Nav](http://kennethcachia.com/background-check/fixed-nav.html)\n+ [CSS Backgrounds](http://www.kennethcachia.com/background-check/css-backgrounds.html)\n+ [CSS Backgrounds &mdash; Fullscreen](http://www.kennethcachia.com/background-check/css-backgrounds-fullscreen.html)\n+ [Cross-Origin Request](http://www.kennethcachia.com/background-check/cross-origin.html)\n+ [Cross-Origin Request &mdash; CSS Backgrounds](http://www.kennethcachia.com/background-check/cross-origin-css.html)\n\n**Using BackgroundCheck with other plugins**\n\n+ [FlexSlider &mdash; Slide](http://www.kennethcachia.com/background-check/flexslider.html)\n+ [FlexSlider &mdash; Fade](http://www.kennethcachia.com/background-check/flexslider-fade.html)\n\n##How it works\n\nIf an element overlaps any of the images, either `.background--dark` or `.background--light` is added to it. BackgroundCheck does not change an element's style &mdash; you must do so using CSS.\n\nFor example, if `<p>` has the following default style:\n\n```css\np {\n  color: white;\n}\n```\n\nyou can then add the following:\n\n```css\np.background--light {\n  color: black;\n}\n```\n\nClasses are only added if the element overlaps an image. An element is considered to overlap an image if at least 50% (configurable) of it's area is covering that image.\n\n###Complex backgrounds\n\nThe light and dark classes work well with simple backgrounds, but you might require an additional level of control for elaborate backgrounds. BackgroundCheck adds `.background--complex` to an element if its background exceeds a certain level of complexity.\n\nThis class can be used as an intermediate state:\n\n```css\np.background--light {\n  color: black;\n}\n\np.background--dark {\n  color: white;\n}\n\np.background--complex {\n  color: gray;\n}\n```\n\nor:\n\n```css\np.background--dark.background--complex {\n  color: #ccc;\n}\n\np.background--light.background--complex {\n  color: #aaa;\n}\n```\n\n##How to use\n\n**Initialize**\n\n```javascript\n// Check all elements with a .target class against all images on a page\nBackgroundCheck.init({\n  targets: '.target'\n});\n\n// Specific images\nBackgroundCheck.init({\n  targets: '.target',\n  images: '.thumbnails'\n});\n```\n\n**Reprocess**\n\n```javascript\n// All targets\nBackgroundCheck.refresh();\n\n// Specific target\nBackgroundCheck.refresh(target);\n```\n\n**Setters and getters**\n\n```javascript\n// Get current targets\nBackgroundCheck.get('targets');\n\n// Change targets\nBackgroundCheck.set('targets', '.header');\n```\n\n**Stop**\n\n```javascript\nBackgroundCheck.destroy();\n```\n\n##Attributes\n\nUsed with `.init()`, `.set()` or `.get()`\n\n+ **targets**: Elements to be processed. *Type:* String, Element or Nodelist. *Required*.\n+ **images**: Images to be used. *Type:* String, Element or NodeList. *Default:* All images on page.\n+ **changeParent**: Determines if classes are added to a target or to its parent. *Default:* false.\n+ **threshold**: Midpoint between dark and light. *Default:* 50 (%).\n+ **minComplexity**: Minimum image complexity required before the *complex* class is added to a target. *Default:* 30 (%).\n+ **minOverlap**: Minimum overlap required between an element and any of the images for that element to be processed. *Default:* 50 (%).\n+ **classes**: Classes added to targets. *Default:* `{ dark: 'background--dark', light: 'background--light', complex: 'background--complex' }`\n+ **windowEvents**: Reprocess on window resize and scroll. *Default:* true.\n+ **maxDuration**: Maximum processing time allowed. Killed if it takes longer. *Default:* 500 (ms).\n+ **mask**: Used internally when checking if an element overlaps any of the images. *Default:* `{ r: 0, g: 255, b: 0 }`\n+ **debug**: Enable or disable logs. *Default*: false.\n\n##CSS Backgrounds\n\nBackgroundCheck can also be used on an element that has a `background-image`. For example:\n\n```css\n.thumbnail {\n  background-image: url(image.jpg);\n}\n```\n\n```js\nBackgroundCheck.init({\n  targets: '.target',\n  images: '.thumbnail'\n});\n```\n\n**Background Position and Size**\n\nTested with the following units:\n\n+ `background-size`: cover, contain, auto, inherit, cm, em, px and %\n+ `background-position`: top, left, center, right, bottom, inherit, cm, em, px and %\n\n**Current Limitations**\n\n+ `background-repeat` is not supported and is forced to `no-repeat`\n+ `background-origin` is forced to `padding-box`\n+ Multiple backgrounds are not supported\n+ Four-value syntax can be used if the browser [supports it](https://developer.mozilla.org/en-US/docs/Web/CSS/background-position#Specifications)\n\n##Browser Support\n\nTested on IE 9-11, iOS 6/7 and the latest versions of Chrome, Firefox and Safari."
        },
        {
          "name": "background-check.js",
          "type": "blob",
          "size": 19.4091796875,
          "content": "\n/*\n * BackgroundCheck\n * http://kennethcachia.com/background-check\n *\n * v1.2.2\n */\n\n(function (root, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    root.BackgroundCheck = factory(root);\n  }\n\n}(this, function () {\n\n  'use strict';\n\n  var resizeEvent = window.orientation !== undefined ? 'orientationchange' : 'resize';\n  var supported;\n  var canvas;\n  var context;\n  var throttleDelay;\n  var viewport;\n  var attrs = {};\n\n\n  /*\n   * Initializer\n   */\n  function init(a) {\n\n    if (a === undefined || a.targets === undefined) {\n      throw 'Missing attributes';\n    }\n\n    // Default values\n    attrs.debug         = checkAttr(a.debug, false);\n    attrs.debugOverlay  = checkAttr(a.debugOverlay, false);\n    attrs.targets       = getElements(a.targets);\n    attrs.images        = getElements(a.images || 'img', true);\n    attrs.changeParent  = checkAttr(a.changeParent, false);\n    attrs.threshold     = checkAttr(a.threshold, 50);\n    attrs.minComplexity = checkAttr(a.minComplexity, 30);\n    attrs.minOverlap    = checkAttr(a.minOverlap, 50);\n    attrs.windowEvents  = checkAttr(a.windowEvents, true);\n    attrs.maxDuration   = checkAttr(a.maxDuration, 500);\n\n    attrs.mask = checkAttr(a.mask, {\n      r: 0,\n      g: 255,\n      b: 0\n    });\n\n    attrs.classes = checkAttr(a.classes, {\n      dark: 'background--dark',\n      light: 'background--light',\n      complex: 'background--complex'\n    });\n\n    if (supported === undefined) {\n      checkSupport();\n\n      if (supported) {\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0px';\n        canvas.style.left = '0px';\n        canvas.style.width = '100%';\n        canvas.style.height = '100%';\n\n        window.addEventListener(resizeEvent, throttle.bind(null, function () {\n          resizeCanvas();\n          check();\n        }));\n\n        window.addEventListener('scroll', throttle.bind(null, check));\n\n        resizeCanvas();\n        check();\n      }\n    }\n  }\n\n\n  /*\n   * Destructor\n   */\n  function destroy() {\n    supported = null;\n    canvas = null;\n    context = null;\n    attrs = {};\n\n    if (throttleDelay) {\n      clearTimeout(throttleDelay);\n    }\n  }\n\n\n  /*\n   * Output debug logs\n   */\n  function log(msg) {\n\n    if (get('debug')) {\n      console.log(msg);\n    }\n  }\n\n\n  /*\n   * Get attribute value, use a default\n   * when undefined\n   */\n  function checkAttr(value, def) {\n    checkType(value, typeof def);\n    return (value === undefined) ? def : value;\n  }\n\n\n  /*\n   * Reject unwanted types\n   */\n  function checkType(value, type) {\n\n    if (value !== undefined && typeof value !== type) {\n      throw 'Incorrect attribute type';\n    }\n  }\n\n\n  /*\n   * Convert elements with background-image\n   * to Images\n   */\n  function checkForCSSImages(els) {\n    var el;\n    var url;\n    var list = [];\n\n    for (var e = 0; e < els.length; e++) {\n      el = els[e];\n      list.push(el);\n\n      if (el.tagName !== 'IMG') {\n        url = window.getComputedStyle(el).backgroundImage;\n\n        // Ignore multiple backgrounds\n        if (url.split(/,url|, url/).length > 1) {\n          throw 'Multiple backgrounds are not supported';\n        }\n\n        if (url && url !== 'none') {\n          list[e] = {\n            img: new Image(),\n            el: list[e]\n          };\n\n          url = url.slice(4, -1);\n          url = url.replace(/\"/g, '');\n\n          list[e].img.src = url;\n          log('CSS Image - ' + url);\n        } else {\n          throw 'Element is not an <img> but does not have a background-image';\n        }\n      }\n    }\n\n    return list;\n  }\n\n\n  /*\n   * Check for String, Element or NodeList\n   */\n  function getElements(selector, convertToImages) {\n    var els = selector;\n\n    if (typeof selector === 'string') {\n      els = document.querySelectorAll(selector);\n    } else if (selector && selector.nodeType === 1) {\n      els = [selector];\n    }\n\n    if (!els || els.length === 0 || els.length === undefined) {\n      throw 'Elements not found';\n    } else {\n\n      if (convertToImages) {\n        els = checkForCSSImages(els);\n      }\n\n      els = Array.prototype.slice.call(els);\n    }\n\n    return els;\n  }\n\n\n  /*\n   * Check if browser supports <canvas>\n   */\n  function checkSupport() {\n    canvas = document.createElement('canvas');\n\n    if (canvas && canvas.getContext) {\n      context = canvas.getContext('2d');\n      supported = true;\n    } else {\n      supported = false;\n    }\n\n    showDebugOverlay();\n  }\n\n\n  /*\n   * Show <canvas> on top of page\n   */\n  function showDebugOverlay() {\n\n    if (get('debugOverlay')) {\n      canvas.style.opacity = 0.5;\n      canvas.style.pointerEvents = 'none';\n      document.body.appendChild(canvas);\n    } else {\n\n      // Check if it was previously added\n      if (canvas.parentNode) {\n        canvas.parentNode.removeChild(canvas);\n      }\n    }\n  }\n\n\n  /*\n   * Stop if it's slow\n   */\n  function kill(start) {\n    var duration = new Date().getTime() - start;\n    \n    log('Duration: ' + duration + 'ms');\n\n    if (duration > get('maxDuration')) {\n      // Log a message even when debug is false\n      console.log('BackgroundCheck - Killed');\n      removeClasses();\n      destroy();\n    }\n  }\n\n\n  /*\n   * Set width and height of <canvas>\n   */\n  function resizeCanvas() {\n    viewport = {\n      left: 0,\n      top: 0,\n      right: document.body.clientWidth,\n      bottom: window.innerHeight\n    };\n\n    canvas.width = document.body.clientWidth;\n    canvas.height = window.innerHeight;\n  }\n\n\n  /*\n   * Process px and %, discard anything else\n   */\n  function getValue(css, parent, delta) {\n    var value;\n    var percentage;\n\n    if (css.indexOf('px') !== -1) {\n      value = parseFloat(css);\n    } else if (css.indexOf('%') !== -1) {\n      value = parseFloat(css);\n      percentage = value / 100;\n      value = percentage * parent;\n\n      if (delta) {\n        value -= delta * percentage;\n      }\n    } else {\n      value = parent;\n    }\n\n    return value;\n  }\n\n\n  /*\n   * Calculate top, left, width and height\n   * using the object's CSS\n   */\n  function calculateAreaFromCSS(obj) {\n    var css = window.getComputedStyle(obj.el);\n\n    // Force no-repeat and padding-box\n    obj.el.style.backgroundRepeat = 'no-repeat';\n    obj.el.style.backgroundOrigin = 'padding-box';\n\n    // Background Size\n    var size = css.backgroundSize.split(' ');\n    var width = size[0];\n    var height = size[1] === undefined ? 'auto' : size[1];\n\n    var parentRatio = obj.el.clientWidth / obj.el.clientHeight;\n    var imgRatio = obj.img.naturalWidth / obj.img.naturalHeight;\n\n    if (width === 'cover') {\n\n      if (parentRatio >= imgRatio) {\n        width = '100%';\n        height = 'auto';\n      } else {\n        width = 'auto';\n        size[0] = 'auto';\n        height = '100%';\n      }\n\n    } else if (width === 'contain') {\n\n      if (1 / parentRatio < 1 / imgRatio) {\n        width = 'auto';\n        size[0] = 'auto';\n        height = '100%';\n      } else {\n        width = '100%';\n        height = 'auto';\n      }\n    }\n\n    if (width === 'auto') {\n      width = obj.img.naturalWidth;\n    } else {\n      width = getValue(width, obj.el.clientWidth);\n    }\n\n    if (height === 'auto') {\n      height = (width / obj.img.naturalWidth) * obj.img.naturalHeight;\n    } else {\n      height = getValue(height, obj.el.clientHeight);\n    }\n\n    if (size[0] === 'auto' && size[1] !== 'auto') {\n      width = (height / obj.img.naturalHeight) * obj.img.naturalWidth;\n    }\n\n    var position = css.backgroundPosition;\n\n    // Fix inconsistencies between browsers\n    if (position === 'top') {\n      position = '50% 0%';\n    } else if (position === 'left') {\n      position = '0% 50%';\n    } else if (position === 'right') {\n      position = '100% 50%';\n    } else if (position === 'bottom') {\n      position = '50% 100%';\n    } else if (position === 'center') {\n      position = '50% 50%';\n    }\n\n    position = position.split(' ');\n\n    var x;\n    var y;\n\n    // Two-value syntax vs Four-value syntax\n    if (position.length === 4) {\n      x = position[1];\n      y = position[3];\n    } else {\n      x = position[0];\n      y = position[1];\n    }\n\n    // Use a default value\n    y = y || '50%';\n\n    // Background Position\n    x = getValue(x, obj.el.clientWidth, width);\n    y = getValue(y, obj.el.clientHeight, height);\n\n    // Take care of ex: background-position: right 20px bottom 20px;\n    if (position.length === 4) {\n\n      if (position[0] === 'right') {\n        x = obj.el.clientWidth - obj.img.naturalWidth - x;\n      }\n\n      if (position[2] === 'bottom') {\n        y = obj.el.clientHeight - obj.img.naturalHeight - y;\n      }\n    }\n\n    x += obj.el.getBoundingClientRect().left;\n    y += obj.el.getBoundingClientRect().top;\n\n    return {\n      left: Math.floor(x),\n      right: Math.floor(x + width),\n      top: Math.floor(y),\n      bottom: Math.floor(y + height),\n      width: Math.floor(width),\n      height: Math.floor(height)\n    };\n  }\n\n\n  /*\n   * Get Bounding Client Rect\n   */\n  function getArea(obj) {\n    var area;\n    var image;\n    var parent;\n\n    if (obj.nodeType) {\n      var rect = obj.getBoundingClientRect();\n\n      // Clone ClientRect for modification purposes\n      area = {\n        left: rect.left,\n        right: rect.right,\n        top: rect.top,\n        bottom: rect.bottom,\n        width: rect.width,\n        height: rect.height\n      };\n\n      parent = obj.parentNode;\n      image = obj;\n    } else {\n      area = calculateAreaFromCSS(obj);\n      parent = obj.el;\n      image = obj.img;\n    }\n\n    parent = parent.getBoundingClientRect();\n\n    area.imageTop = 0;\n    area.imageLeft = 0;\n    area.imageWidth = image.naturalWidth;\n    area.imageHeight = image.naturalHeight;\n\n    var ratio = area.imageHeight / area.height;\n    var delta;\n\n    // Stay within the parent's boundary\n    if (area.top < parent.top) {\n      delta = parent.top - area.top;\n      area.imageTop = ratio * delta;\n      area.imageHeight -= ratio * delta;\n      area.top += delta;\n      area.height -= delta;\n    }\n\n    if (area.left < parent.left) {\n      delta = parent.left - area.left;\n      area.imageLeft += ratio * delta;\n      area.imageWidth -= ratio * delta;\n      area.width -= delta;\n      area.left += delta;\n    }\n\n    if (area.bottom > parent.bottom) {\n      delta = area.bottom - parent.bottom;\n      area.imageHeight -= ratio * delta;\n      area.height -= delta;\n    }\n\n    if (area.right > parent.right) {\n      delta = area.right - parent.right;\n      area.imageWidth -= ratio * delta;\n      area.width -= delta;\n    }\n\n    area.imageTop = Math.floor(area.imageTop);\n    area.imageLeft = Math.floor(area.imageLeft);\n    area.imageHeight = Math.floor(area.imageHeight);\n    area.imageWidth = Math.floor(area.imageWidth);\n\n    return area;\n  }\n\n\n  /*\n   * Render image on canvas\n   */\n  function drawImage(image) {\n    var area = getArea(image);\n\n    image = image.nodeType ? image : image.img;\n\n    if (area.imageWidth > 0 && area.imageHeight > 0 && area.width > 0 && area.height > 0) {\n      context.drawImage(image,\n                        area.imageLeft, area.imageTop, area.imageWidth, area.imageHeight,\n                        area.left, area.top, area.width, area.height);\n    } else {\n      log('Skipping image - ' + image.src + ' - area too small');\n    }\n  }\n\n\n  /*\n   * Add/remove classes\n   */\n  function classList(node, name, mode) {\n    var className = node.className;\n\n    switch (mode) {\n    case 'add':\n      className += ' ' + name;\n      break;\n    case 'remove':\n      var pattern = new RegExp('(?:^|\\\\s)' + name + '(?!\\\\S)', 'g');\n      className = className.replace(pattern, '');\n      break;\n    }\n\n    node.className = className.trim();\n  }\n\n\n  /*\n   * Remove classes from element or\n   * their parents, depending on checkParent\n   */\n  function removeClasses(el) {\n    var targets = el ? [el] : get('targets');\n    var target;\n\n    for (var t = 0; t < targets.length; t++) {\n      target = targets[t];\n      target = get('changeParent') ? target.parentNode : target;\n      \n      classList(target, get('classes').light, 'remove');\n      classList(target, get('classes').dark, 'remove');\n      classList(target, get('classes').complex, 'remove');\n    }\n  }\n\n\n  /*\n   * Calculate average pixel brightness of a region \n   * and add 'light' or 'dark' accordingly\n   */\n  function calculatePixelBrightness(target) {\n    var dims = target.getBoundingClientRect();\n    var brightness;\n    var data;\n    var pixels = 0;\n    var delta;\n    var deltaSqr = 0;\n    var mean = 0;\n    var variance;\n    var minOverlap = 0;\n    var mask = get('mask');\n\n    if (dims.width > 0 && dims.height > 0) {\n      removeClasses(target);\n\n      target = get('changeParent') ? target.parentNode : target;\n      data = context.getImageData(dims.left, dims.top, dims.width, dims.height).data;\n\n      for (var p = 0; p < data.length; p += 4) {\n\n        if (data[p] === mask.r && data[p + 1] === mask.g && data[p + 2] === mask.b) {\n          minOverlap++;\n        } else {\n          pixels++;\n          brightness = (0.2126 * data[p]) + (0.7152 * data[p + 1]) + (0.0722 * data[p + 2]);\n          delta = brightness - mean;\n          deltaSqr += delta * delta;\n          mean = mean + delta / pixels;\n        }\n      }\n\n      if (minOverlap <= (data.length / 4) * (1 - (get('minOverlap') / 100))) {\n        variance = Math.sqrt(deltaSqr / pixels) / 255;\n        mean = mean / 255;\n        log('Target: ' + target.className +  ' lum: ' + mean + ' var: ' + variance);\n        classList(target, mean <= (get('threshold') / 100) ? get('classes').dark : get('classes').light, 'add');\n\n        if (variance > get('minComplexity') / 100) {\n          classList(target, get('classes').complex, 'add');\n        }\n      }\n    }\n  }\n\n\n  /*\n   * Test if a is within b's boundary\n   */\n  function isInside(a, b) {\n    a = (a.nodeType ? a : a.el).getBoundingClientRect();\n    b = b === viewport ? b : (b.nodeType ? b : b.el).getBoundingClientRect();\n\n    return !(a.right < b.left || a.left > b.right || a.top > b.bottom || a.bottom < b.top);\n  }\n\n\n  /*\n   * Process all targets (checkTarget is undefined)\n   * or a single target (checkTarget is a previously set target)\n   *\n   * When not all images are loaded, checkTarget is an image\n   * to avoid processing all targets multiple times\n   */\n  function processTargets(checkTarget) {\n    var start = new Date().getTime();\n    var mode = (checkTarget && (checkTarget.tagName === 'IMG' || checkTarget.img)) ? 'image' : 'targets';\n    var found = checkTarget ? false : true;\n    var total = get('targets').length;\n    var target;\n\n    for (var t = 0; t < total; t++) {\n      target = get('targets')[t];\n\n      if (isInside(target, viewport)) {\n        if (mode === 'targets' && (!checkTarget || checkTarget === target)) {\n          found = true;\n          calculatePixelBrightness(target);\n        } else if (mode === 'image' && isInside(target, checkTarget)) {\n          calculatePixelBrightness(target);\n        }\n      }\n    }\n\n    if (mode === 'targets' && !found) {\n      throw checkTarget + ' is not a target';\n    }\n\n    kill(start);\n  }\n\n\n  /*\n   * Find the element's zIndex. Also checks\n   * the zIndex of its parent\n   */\n  function getZIndex(el) {\n    var calculate = function (el) {\n      var zindex = 0;\n\n      if (window.getComputedStyle(el).position !== 'static') {\n        zindex = parseInt(window.getComputedStyle(el).zIndex, 10) || 0;\n\n        // Reserve zindex = 0 for elements with position: static;\n        if (zindex >= 0) {\n          zindex++;\n        }\n      }\n\n      return zindex;\n    };\n\n    var parent = el.parentNode;\n    var zIndexParent = parent ? calculate(parent) : 0;\n    var zIndexEl = calculate(el);\n\n    return (zIndexParent * 100000) + zIndexEl;\n  }\n\n\n  /*\n   * Check zIndexes\n   */\n  function sortImagesByZIndex(images) {\n    var sorted = false;\n\n    images.sort(function (a, b) {\n      a = a.nodeType ? a : a.el;\n      b = b.nodeType ? b : b.el;\n\n      var pos = a.compareDocumentPosition(b);\n      var reverse = 0;\n\n      a = getZIndex(a);\n      b = getZIndex(b);\n\n      if (a > b) {\n        sorted = true;\n      }\n\n      // Reposition if zIndex is the same but the elements are not\n      // sorted according to their document position\n      if (a === b && pos === 2) {\n        reverse = 1;\n      } else if (a === b && pos === 4) {\n        reverse = -1;\n      }\n\n      return reverse || a - b;\n    });\n\n    log('Sorted: ' + sorted);\n\n    if (sorted) {\n      log(images);\n    }\n\n    return sorted;\n  }\n\n\n  /*\n   * Main function\n   */\n  function check(target, avoidClear, imageLoaded) {\n\n    if (supported) {\n      var mask = get('mask');\n\n      log('--- BackgroundCheck ---');\n      log('onLoad event: ' + (imageLoaded && imageLoaded.src));\n\n      if (avoidClear !== true) {\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        context.fillStyle = 'rgb(' + mask.r + ', ' + mask.g + ', ' + mask.b + ')';\n        context.fillRect(0, 0, canvas.width, canvas.height);\n      }\n\n      var processImages = imageLoaded ? [imageLoaded] : get('images');\n      var sorted = sortImagesByZIndex(processImages);\n\n      var image;\n      var imageNode;\n      var loading = false;\n\n      for (var i = 0; i < processImages.length; i++) {\n        image = processImages[i];\n\n        if (isInside(image, viewport)) {\n          imageNode = image.nodeType ? image : image.img;\n\n          if (imageNode.naturalWidth === 0) {\n            loading = true;\n            log('Loading... ' + image.src);\n\n            imageNode.removeEventListener('load', check);\n\n            if (sorted) {\n              // Sorted -- redraw all images\n              imageNode.addEventListener('load', check.bind(null, null, false, null));\n            } else {\n              // Not sorted -- just draw one image\n              imageNode.addEventListener('load', check.bind(null, target, true, image));\n            }\n          } else {\n            log('Drawing: ' + image.src);\n            drawImage(image);\n          }\n        }\n      }\n\n      if (!imageLoaded && !loading) {\n        processTargets(target);\n      } else if (imageLoaded) {\n        processTargets(imageLoaded);\n      }\n    }\n  }\n\n\n  /*\n   * Throttle events\n   */\n  function throttle(callback) {\n\n    if (get('windowEvents') === true) {\n\n      if (throttleDelay) {\n        clearTimeout(throttleDelay);\n      }\n\n      throttleDelay = setTimeout(callback, 200);\n    }\n  }\n\n\n  /*\n   * Setter\n   */\n  function set(property, newValue) {\n\n    if (attrs[property] === undefined) {\n      throw 'Unknown property - ' + property;\n    } else if (newValue === undefined) {\n      throw 'Missing value for ' + property;\n    }\n\n    if (property === 'targets' || property === 'images') {\n\n      try {\n        newValue = getElements(property === 'images' && !newValue ? 'img' : newValue, property === 'images' ? true : false);\n      } catch (err) {\n        newValue = [];\n        throw err;\n      }\n    } else {\n      checkType(newValue, typeof attrs[property]);\n    }\n\n    removeClasses();\n    attrs[property] = newValue;\n    check();\n\n    if (property === 'debugOverlay') {\n      showDebugOverlay();\n    }\n  }\n\n\n  /*\n   * Getter\n   */\n  function get(property) {\n\n    if (attrs[property] === undefined) {\n      throw 'Unknown property - ' + property;\n    }\n\n    return attrs[property];\n  }\n\n\n  /*\n   * Get position and size of all images.\n   * Used for testing purposes\n   */\n  function getImageData() {\n    var images = get('images');\n    var area;\n    var data = [];\n\n    for (var i = 0; i < images.length; i++) {\n      area = getArea(images[i]);\n      data.push(area);\n    }\n\n    return data;\n  }\n\n\n  return {\n    /*\n     * Init and destroy\n     */\n    init: init,\n    destroy: destroy,\n\n    /*\n     * Expose main function\n     */\n    refresh: check,\n\n    /*\n     * Setters and getters\n     */\n    set: set,\n    get: get,\n\n    /*\n     * Return image data\n     */\n    getImageData: getImageData\n  };\n\n}));\n"
        },
        {
          "name": "background-check.min.js",
          "type": "blob",
          "size": 7.7109375,
          "content": "/* BackgroundCheck\n   http://kennethcachia.com/background-check\n   v1.2.2 */\n\n!function(a,b){\"function\"==typeof define&&define.amd?define(b):a.BackgroundCheck=b(a)}(this,function(){\"use strict\";function a(a){if(void 0===a||void 0===a.targets)throw\"Missing attributes\";H.debug=d(a.debug,!1),H.debugOverlay=d(a.debugOverlay,!1),H.targets=g(a.targets),H.images=g(a.images||\"img\",!0),H.changeParent=d(a.changeParent,!1),H.threshold=d(a.threshold,50),H.minComplexity=d(a.minComplexity,30),H.minOverlap=d(a.minOverlap,50),H.windowEvents=d(a.windowEvents,!0),H.maxDuration=d(a.maxDuration,500),H.mask=d(a.mask,{r:0,g:255,b:0}),H.classes=d(a.classes,{dark:\"background--dark\",light:\"background--light\",complex:\"background--complex\"}),void 0===B&&(h(),B&&(C.style.position=\"fixed\",C.style.top=\"0px\",C.style.left=\"0px\",C.style.width=\"100%\",C.style.height=\"100%\",window.addEventListener(G,x.bind(null,function(){k(),w()})),window.addEventListener(\"scroll\",x.bind(null,w)),k(),w()))}function b(){B=null,C=null,D=null,H={},E&&clearTimeout(E)}function c(a){z(\"debug\")&&console.log(a)}function d(a,b){return e(a,typeof b),void 0===a?b:a}function e(a,b){if(void 0!==a&&typeof a!==b)throw\"Incorrect attribute type\"}function f(a){for(var b,d,e=[],f=0;f<a.length;f++)if(b=a[f],e.push(b),\"IMG\"!==b.tagName){if(d=window.getComputedStyle(b).backgroundImage,d.split(/,url|, url/).length>1)throw\"Multiple backgrounds are not supported\";if(!d||\"none\"===d)throw\"Element is not an <img> but does not have a background-image\";e[f]={img:new Image,el:e[f]},d=d.slice(4,-1),d=d.replace(/\"/g,\"\"),e[f].img.src=d,c(\"CSS Image - \"+d)}return e}function g(a,b){var c=a;if(\"string\"==typeof a?c=document.querySelectorAll(a):a&&1===a.nodeType&&(c=[a]),!c||0===c.length||void 0===c.length)throw\"Elements not found\";return b&&(c=f(c)),c=Array.prototype.slice.call(c)}function h(){C=document.createElement(\"canvas\"),C&&C.getContext?(D=C.getContext(\"2d\"),B=!0):B=!1,i()}function i(){z(\"debugOverlay\")?(C.style.opacity=.5,C.style.pointerEvents=\"none\",document.body.appendChild(C)):C.parentNode&&C.parentNode.removeChild(C)}function j(a){var d=(new Date).getTime()-a;c(\"Duration: \"+d+\"ms\"),d>z(\"maxDuration\")&&(console.log(\"BackgroundCheck - Killed\"),q(),b())}function k(){F={left:0,top:0,right:document.body.clientWidth,bottom:window.innerHeight},C.width=document.body.clientWidth,C.height=window.innerHeight}function l(a,b,c){var d,e;return-1!==a.indexOf(\"px\")?d=parseFloat(a):-1!==a.indexOf(\"%\")?(d=parseFloat(a),e=d/100,d=e*b,c&&(d-=c*e)):d=b,d}function m(a){var b=window.getComputedStyle(a.el);a.el.style.backgroundRepeat=\"no-repeat\",a.el.style.backgroundOrigin=\"padding-box\";var c=b.backgroundSize.split(\" \"),d=c[0],e=void 0===c[1]?\"auto\":c[1],f=a.el.clientWidth/a.el.clientHeight,g=a.img.naturalWidth/a.img.naturalHeight;\"cover\"===d?f>=g?(d=\"100%\",e=\"auto\"):(d=\"auto\",c[0]=\"auto\",e=\"100%\"):\"contain\"===d&&(1/g>1/f?(d=\"auto\",c[0]=\"auto\",e=\"100%\"):(d=\"100%\",e=\"auto\")),d=\"auto\"===d?a.img.naturalWidth:l(d,a.el.clientWidth),e=\"auto\"===e?d/a.img.naturalWidth*a.img.naturalHeight:l(e,a.el.clientHeight),\"auto\"===c[0]&&\"auto\"!==c[1]&&(d=e/a.img.naturalHeight*a.img.naturalWidth);var h=b.backgroundPosition;\"top\"===h?h=\"50% 0%\":\"left\"===h?h=\"0% 50%\":\"right\"===h?h=\"100% 50%\":\"bottom\"===h?h=\"50% 100%\":\"center\"===h&&(h=\"50% 50%\"),h=h.split(\" \");var i,j;return 4===h.length?(i=h[1],j=h[3]):(i=h[0],j=h[1]),j=j||\"50%\",i=l(i,a.el.clientWidth,d),j=l(j,a.el.clientHeight,e),4===h.length&&(\"right\"===h[0]&&(i=a.el.clientWidth-a.img.naturalWidth-i),\"bottom\"===h[2]&&(j=a.el.clientHeight-a.img.naturalHeight-j)),i+=a.el.getBoundingClientRect().left,j+=a.el.getBoundingClientRect().top,{left:Math.floor(i),right:Math.floor(i+d),top:Math.floor(j),bottom:Math.floor(j+e),width:Math.floor(d),height:Math.floor(e)}}function n(a){var b,c,d;if(a.nodeType){var e=a.getBoundingClientRect();b={left:e.left,right:e.right,top:e.top,bottom:e.bottom,width:e.width,height:e.height},d=a.parentNode,c=a}else b=m(a),d=a.el,c=a.img;d=d.getBoundingClientRect(),b.imageTop=0,b.imageLeft=0,b.imageWidth=c.naturalWidth,b.imageHeight=c.naturalHeight;var f,g=b.imageHeight/b.height;return b.top<d.top&&(f=d.top-b.top,b.imageTop=g*f,b.imageHeight-=g*f,b.top+=f,b.height-=f),b.left<d.left&&(f=d.left-b.left,b.imageLeft+=g*f,b.imageWidth-=g*f,b.width-=f,b.left+=f),b.bottom>d.bottom&&(f=b.bottom-d.bottom,b.imageHeight-=g*f,b.height-=f),b.right>d.right&&(f=b.right-d.right,b.imageWidth-=g*f,b.width-=f),b.imageTop=Math.floor(b.imageTop),b.imageLeft=Math.floor(b.imageLeft),b.imageHeight=Math.floor(b.imageHeight),b.imageWidth=Math.floor(b.imageWidth),b}function o(a){var b=n(a);a=a.nodeType?a:a.img,b.imageWidth>0&&b.imageHeight>0&&b.width>0&&b.height>0?D.drawImage(a,b.imageLeft,b.imageTop,b.imageWidth,b.imageHeight,b.left,b.top,b.width,b.height):c(\"Skipping image - \"+a.src+\" - area too small\")}function p(a,b,c){var d=a.className;switch(c){case\"add\":d+=\" \"+b;break;case\"remove\":var e=new RegExp(\"(?:^|\\\\s)\"+b+\"(?!\\\\S)\",\"g\");d=d.replace(e,\"\")}a.className=d.trim()}function q(a){for(var b,c=a?[a]:z(\"targets\"),d=0;d<c.length;d++)b=c[d],b=z(\"changeParent\")?b.parentNode:b,p(b,z(\"classes\").light,\"remove\"),p(b,z(\"classes\").dark,\"remove\"),p(b,z(\"classes\").complex,\"remove\")}function r(a){var b,d,e,f,g=a.getBoundingClientRect(),h=0,i=0,j=0,k=0,l=z(\"mask\");if(g.width>0&&g.height>0){q(a),a=z(\"changeParent\")?a.parentNode:a,d=D.getImageData(g.left,g.top,g.width,g.height).data;for(var m=0;m<d.length;m+=4)d[m]===l.r&&d[m+1]===l.g&&d[m+2]===l.b?k++:(h++,b=.2126*d[m]+.7152*d[m+1]+.0722*d[m+2],e=b-j,i+=e*e,j+=e/h);k<=d.length/4*(1-z(\"minOverlap\")/100)&&(f=Math.sqrt(i/h)/255,j/=255,c(\"Target: \"+a.className+\" lum: \"+j+\" var: \"+f),p(a,j<=z(\"threshold\")/100?z(\"classes\").dark:z(\"classes\").light,\"add\"),f>z(\"minComplexity\")/100&&p(a,z(\"classes\").complex,\"add\"))}}function s(a,b){return a=(a.nodeType?a:a.el).getBoundingClientRect(),b=b===F?b:(b.nodeType?b:b.el).getBoundingClientRect(),!(a.right<b.left||a.left>b.right||a.top>b.bottom||a.bottom<b.top)}function t(a){for(var b,c=(new Date).getTime(),d=a&&(\"IMG\"===a.tagName||a.img)?\"image\":\"targets\",e=a?!1:!0,f=z(\"targets\").length,g=0;f>g;g++)b=z(\"targets\")[g],s(b,F)&&(\"targets\"!==d||a&&a!==b?\"image\"===d&&s(b,a)&&r(b):(e=!0,r(b)));if(\"targets\"===d&&!e)throw a+\" is not a target\";j(c)}function u(a){var b=function(a){var b=0;return\"static\"!==window.getComputedStyle(a).position&&(b=parseInt(window.getComputedStyle(a).zIndex,10)||0,b>=0&&b++),b},c=a.parentNode,d=c?b(c):0,e=b(a);return 1e5*d+e}function v(a){var b=!1;return a.sort(function(a,c){a=a.nodeType?a:a.el,c=c.nodeType?c:c.el;var d=a.compareDocumentPosition(c),e=0;return a=u(a),c=u(c),a>c&&(b=!0),a===c&&2===d?e=1:a===c&&4===d&&(e=-1),e||a-c}),c(\"Sorted: \"+b),b&&c(a),b}function w(a,b,d){if(B){var e=z(\"mask\");c(\"--- BackgroundCheck ---\"),c(\"onLoad event: \"+(d&&d.src)),b!==!0&&(D.clearRect(0,0,C.width,C.height),D.fillStyle=\"rgb(\"+e.r+\", \"+e.g+\", \"+e.b+\")\",D.fillRect(0,0,C.width,C.height));for(var f,g,h=d?[d]:z(\"images\"),i=v(h),j=!1,k=0;k<h.length;k++)f=h[k],s(f,F)&&(g=f.nodeType?f:f.img,0===g.naturalWidth?(j=!0,c(\"Loading... \"+f.src),g.removeEventListener(\"load\",w),i?g.addEventListener(\"load\",w.bind(null,null,!1,null)):g.addEventListener(\"load\",w.bind(null,a,!0,f))):(c(\"Drawing: \"+f.src),o(f)));d||j?d&&t(d):t(a)}}function x(a){z(\"windowEvents\")===!0&&(E&&clearTimeout(E),E=setTimeout(a,200))}function y(a,b){if(void 0===H[a])throw\"Unknown property - \"+a;if(void 0===b)throw\"Missing value for \"+a;if(\"targets\"===a||\"images\"===a)try{b=g(\"images\"!==a||b?b:\"img\",\"images\"===a?!0:!1)}catch(c){throw b=[],c}else e(b,typeof H[a]);q(),H[a]=b,w(),\"debugOverlay\"===a&&i()}function z(a){if(void 0===H[a])throw\"Unknown property - \"+a;return H[a]}function A(){for(var a,b=z(\"images\"),c=[],d=0;d<b.length;d++)a=n(b[d]),c.push(a);return c}var B,C,D,E,F,G=void 0!==window.orientation?\"orientationchange\":\"resize\",H={};return{init:a,destroy:b,refresh:w,set:y,get:z,getImageData:A}});"
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.47265625,
          "content": "{\n  \"name\": \"background-check\",\n  \"version\": \"1.2.2\",\n  \"homepage\": \"http://www.kennethcachia.com/background-check/\",\n  \"authors\": [\n    \"Kenneth Cachia\"\n  ],\n  \"description\": \"Automatically switch to a darker or a lighter version of an element depending on the brightness of images behind it.\",\n  \"main\": \"background-check.js\",\n  \"moduleType\": [\n    \"amd\",\n    \"globals\"\n  ],\n  \"license\": \"MIT\",\n  \"ignore\": [\n    \"**/.*\",\n    \"node_modules\",\n    \"bower_components\",\n    \"test\"\n  ]\n}"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.4541015625,
          "content": "{\n  \"name\": \"background-check\",\n  \"version\": \"1.2.2\",\n  \"author\": {\n    \"name\" : \"Kenneth Cachia\",\n    \"url\" : \"http://kennethcachia.com/\"\n  },\n  \"homepage\": \"http://kennethcachia.com/background-check\",\n  \"devDependencies\": {\n    \"grunt\": \"~0.4.1\",\n    \"grunt-contrib-watch\": \"~0.5.1\",\n    \"grunt-contrib-clean\": \"~0.5.0\",\n    \"grunt-contrib-jshint\": \"~0.6.0\",\n    \"grunt-contrib-uglify\": \"~0.2.2\",\n    \"grunt-contrib-copy\": \"~0.4.1\",\n    \"assemble\": \"~0.4.2\"\n  }\n}"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}