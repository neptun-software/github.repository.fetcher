{
  "metadata": {
    "timestamp": 1736561648684,
    "page": 219,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "totaljs/framework",
      "stars": 4361,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2685546875,
          "content": "# http://editorconfig.org/\n\n# Top-most EditorConfig file\nroot = true\n\n[*.js]\nindent_style = tab\nindent_size = 2\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = false\nmax_line_length = 120\n\n[*.json]\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1494140625,
          "content": "*.sublime-project\n*.sublime-workspace\n.DS_Store\n*.log\n.idea\ntest/tmp/*\nnode_modules\ntest/test-framework-debug.js.json\ntest/test-framework-release.js.json"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.189453125,
          "content": "Makefile\nempty-project/\nexamples/\nmerged/\ntools/\nhelpers/\ntest/\n*.markdown\n*.md\n.editorconfig\n.gitingore\n.git*\n*.yml\n*.DS_Store\n*.sublime-project\n*.sublime-workspace\n*.sh\nchanges.txt\nroadmap.txt"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.111328125,
          "content": "language: node_js\ncache:\n  - npm\nnode_js:\n  - \"8.9.1\"\ninstall:\n  - npm install\nscript:\n  - cd test\n  - bash run.sh"
        },
        {
          "name": "503.html",
          "type": "blob",
          "size": 2.03125,
          "content": "<!DOCTYPE html>\n<html>\n<head>\n\t<title>@(Please wait)</title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"format-detection\" content=\"telephone=no\" />\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\" />\n\t<meta name=\"robots\" content=\"all,follow\" />\n\t<style type=\"text/css\">\n\t\t/*auto*/\n\t\thtml,body { font: normal normal 14px Arial; background-color: white; height: 100%; margin: 0; padding: 0; font-smoothing: antialiased; }\n\t\t.table { display: table; width: 100%; height: 100%}\n\t\t.cell { display:table-cell;vertical-align:middle;text-align:center}\n\t\ttable { max-width: 300px; margin: 20px auto; width: 100%; border:1px solid #E0E0E0; border-collapse: collapse; font-size: 12px; }\n\t\ttable td { border: 1px solid #E0E0E0; padding: 6px 8px; text-align: center; }\n\t\ttable td:first-child { text-align: left; width: 85%; }\n\t\t.anim { animation: anim 2s infinite; }\n\t\t.text { color: #A0A0A0; font-size: 10px; margin-bottom: 3px; text-transform: uppercase; }\n\t\t#time { font-size: 60px; font-weight: bold; margin-bottom: 10px; background-color: black; color: white; padding: 3px 10px; min-width: 70px; text-align: center; border-radius: 2px; position: relative; display: inline-block; }\n\n\t\t@keyframes anim {\n\t\t\t0% { transform:scale(1); }\n\t\t\t50%{ transform:scale(1.5) rotate(180deg); color:gray }\n\t\t\t100%{ transform:scale(1); }\n\t\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"table\">\n\t\t<div class=\"cell\">\n\t\t\t<div id=\"time\" style=\"\">10</div>\n\t\t\t<div class=\"text\">@(Please wait)</div>\n\t\t\t<div>\n\t\t\t\t<b>@(Application is starting &hellip;)</b>\n\t\t\t</div>\n\t\t\t<table>\n\t\t\t\t@{foreach m in model}\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>@{m.key}</td>\n\t\t\t\t\t\t<td class=\"anim\">&#10711;</td>\n\t\t\t\t\t</tr>\n\t\t\t\t@{end}\n\t\t\t</table>\n\t\t</div>\n\t</div>\n\n\t<script>\n\t\tvar i = 10;\n\t\tsetInterval(function() {\n\t\t\ti--;\n\t\t\tif (i >= 0) {\n\t\t\t\tvar el = document.getElementById('time');\n\t\t\t\t!i && (el.style.fontSize = '40px');\n\t\t\t\tel.innerHTML = (i === 0 ? '@(REFRESHING)' : i);\n\t\t\t} else if (i === -1) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\twindow.location.reload();\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t}, 1000);\n\t</script>\n\n</body>\n</html>"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "builders.js",
          "type": "blob",
          "size": 157.2626953125,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkBuilders\n * @version 3.4.4\n */\n\n'use strict';\n\nconst REQUIRED = 'The field \"@\" is invalid.';\nconst DEFAULT_SCHEMA = 'default';\nconst SKIP = { $$schema: 1, $$async: 1, $$repository: 1, $$controller: 1, $$workflow: 1, $$parent: 1, $$keys: 1 };\nconst REGEXP_CLEAN_EMAIL = /\\s/g;\nconst REGEXP_CLEAN_PHONE = /\\s|\\.|-|\\(|\\)/g;\nconst REGEXP_NEWOPERATION = /^(async\\s)?function(\\s)?\\([a-zA-Z$\\s]+\\)|^function anonymous\\(\\$|^\\([a-zA-Z$\\s]+\\)|^function\\*\\(\\$|^\\([a-zA-Z$\\s]+\\)/;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst Qs = require('querystring');\nconst MSG_OBSOLETE_NEW = 'You used older declaration of this delegate and you must rewrite it. Read more in docs.';\nconst BOOL = { true: 1, on: 1, '1': 1 };\nconst REGEXP_FILTER = /[a-z0-9-_]+:(\\s)?(\\[)?(String|Number|Boolean|Date)(\\])?/i;\n\nvar schemas = {};\nvar schemasall = {};\nvar schemacache = {};\nvar operations = {};\nvar tasks = {};\nvar transforms = { pagination: {}, error: {}, restbuilder: {} };\nvar restbuilderupgrades = [];\n\nfunction SchemaBuilder(name) {\n\tthis.name = name;\n\tthis.collection = {};\n}\n\nconst SchemaBuilderProto = SchemaBuilder.prototype;\n\nfunction SchemaOptions(error, model, options, callback, controller, name, schema) {\n\tthis.error = error;\n\tthis.value = this.model = model;\n\tthis.options = options || EMPTYOBJECT;\n\tthis.callback = this.next = callback;\n\tthis.controller = (controller instanceof SchemaOptions || controller instanceof OperationOptions) ? controller.controller : controller;\n\tthis.name = name;\n\tthis.schema = schema;\n}\n\nfunction TaskBuilder($) {\n\tvar t = this;\n\tt.value = {};\n\tt.tasks = {};\n\tif ($ instanceof SchemaOptions || $ instanceof OperationOptions) {\n\t\tt.error = $.error;\n\t\tt.controller = $.controller;\n\t} else {\n\t\tif ($ instanceof Controller || $ instanceof WebSocketClient)\n\t\t\tt.controller = $;\n\t\telse if ($ instanceof ErrorBuilder)\n\t\t\tt.error = $;\n\t}\n}\n\nTaskBuilder.prototype = {\n\n\tget user() {\n\t\treturn this.controller ? this.controller.user : null;\n\t},\n\n\tget session() {\n\t\treturn this.controller ? this.controller.session : null;\n\t},\n\n\tget sessionid() {\n\t\treturn this.controller && this.controller ? this.controller.req.sessionid : null;\n\t},\n\n\tget language() {\n\t\treturn (this.controller ? this.controller.language : '') || '';\n\t},\n\n\tget ip() {\n\t\treturn this.controller ? this.controller.ip : null;\n\t},\n\n\tget id() {\n\t\treturn this.controller ? this.controller.id : null;\n\t},\n\n\tget req() {\n\t\treturn this.controller ? this.controller.req : null;\n\t},\n\n\tget res() {\n\t\treturn this.controller ? this.controller.res : null;\n\t},\n\n\tget params() {\n\t\treturn this.controller ? this.controller.params : null;\n\t},\n\n\tget files() {\n\t\treturn this.controller ? this.controller.files : null;\n\t},\n\n\tget body() {\n\t\treturn this.controller ? this.controller.body : null;\n\t},\n\n\tget query() {\n\t\treturn this.controller ? this.controller.query : null;\n\t},\n\n\tget model() {\n\t\treturn this.value;\n\t},\n\n\tset model(val) {\n\t\tthis.value = val;\n\t},\n\n\tget headers() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.headers : null;\n\t},\n\n\tget ua() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.ua : null;\n\t},\n\n\tget filter() {\n\t\tvar ctrl = this.controller;\n\t\tif (ctrl && !ctrl.$filter)\n\t\t\tctrl.$filter = ctrl.$filterschema ? CONVERT(ctrl.query, ctrl.$filterschema) : ctrl.query;\n\t\treturn ctrl ? ctrl.$filter : EMPTYOBJECT;\n\t}\n};\n\nconst TaskBuilderProto = TaskBuilder.prototype;\n\nSchemaOptions.prototype = {\n\n\tget user() {\n\t\treturn this.controller ? this.controller.user : null;\n\t},\n\n\tget session() {\n\t\treturn this.controller ? this.controller.session : null;\n\t},\n\n\tget keys() {\n\t\treturn this.model.$$keys;\n\t},\n\n\tget parent() {\n\t\treturn this.model.$$parent;\n\t},\n\n\tget repo() {\n\t\tif (this.controller)\n\t\t\treturn this.controller.repository;\n\t\tif (!this.model.$$repository)\n\t\t\tthis.model.$$repository = {};\n\t\treturn this.model.$$repository;\n\t},\n\n\tget sessionid() {\n\t\treturn this.controller && this.controller ? this.controller.req.sessionid : null;\n\t},\n\n\tget language() {\n\t\treturn (this.controller ? this.controller.language : '') || '';\n\t},\n\n\tget ip() {\n\t\treturn this.controller ? this.controller.ip : null;\n\t},\n\n\tget id() {\n\t\treturn this.controller ? this.controller.id : null;\n\t},\n\n\tget req() {\n\t\treturn this.controller ? this.controller.req : null;\n\t},\n\n\tget res() {\n\t\treturn this.controller ? this.controller.res : null;\n\t},\n\n\tget params() {\n\t\treturn this.controller ? this.controller.params : null;\n\t},\n\n\tget files() {\n\t\treturn this.controller ? this.controller.files : null;\n\t},\n\n\tget body() {\n\t\treturn this.controller ? this.controller.body : null;\n\t},\n\n\tget query() {\n\t\treturn this.controller ? this.controller.query : null;\n\t},\n\n\tget headers() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.headers : null;\n\t},\n\n\tget ua() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.ua : null;\n\t},\n\n\tget filter() {\n\t\tvar ctrl = this.controller;\n\t\tif (ctrl && !ctrl.$filter)\n\t\t\tctrl.$filter = ctrl.$filterschema ? CONVERT(ctrl.query, ctrl.$filterschema) : ctrl.query;\n\t\treturn ctrl ? ctrl.$filter : EMPTYOBJECT;\n\t}\n};\n\nvar SchemaOptionsProto = SchemaOptions.prototype;\n\nSchemaOptionsProto.cancel = function() {\n\tvar self = this;\n\tself.callback = self.next = null;\n\tself.error = null;\n\tself.controller = null;\n\tself.model = null;\n\tself.options = null;\n\treturn self;\n};\n\nSchemaOptionsProto.extend = function(data) {\n\tvar self = this;\n\tvar ext = self.schema.extensions[self.name];\n\tif (ext) {\n\t\tfor (var i = 0; i < ext.length; i++)\n\t\t\text[i](self, data);\n\t\treturn true;\n\t}\n};\n\nSchemaOptionsProto.redirect = function(url) {\n\tthis.callback(new F.callback_redirect(url));\n\treturn this;\n};\n\nSchemaOptionsProto.clean = function() {\n\treturn this.model.$clean();\n};\n\nSchemaOptionsProto.$async = function(callback, index) {\n\treturn this.model.$async(callback, index);\n};\n\nSchemaOptionsProto.$workflow = function(name, helper, callback, async) {\n\treturn this.model.$workflow(name, helper, callback, async);\n};\n\nSchemaOptionsProto.$transform = function(name, helper, callback, async) {\n\treturn this.model.$transform(name, helper, callback, async);\n};\n\nSchemaOptionsProto.$operation = function(name, helper, callback, async) {\n\treturn this.model.$operation(name, helper, callback, async);\n};\n\nSchemaOptionsProto.$hook = function(name, helper, callback, async) {\n\treturn this.model.$hook(name, helper, callback, async);\n};\n\nSchemaOptionsProto.$save = function(helper, callback, async) {\n\treturn this.model.$save(helper, callback, async);\n};\n\nSchemaOptionsProto.$insert = function(helper, callback, async) {\n\treturn this.model.$insert(helper, callback, async);\n};\n\nSchemaOptionsProto.$update = function(helper, callback, async) {\n\treturn this.model.$update(helper, callback, async);\n};\n\nSchemaOptionsProto.$patch = function(helper, callback, async) {\n\treturn this.model.$patch(helper, callback, async);\n};\n\nSchemaOptionsProto.$query = function(helper, callback, async) {\n\treturn this.model.$query(helper, callback, async);\n};\n\nSchemaOptionsProto.$delete = SchemaOptionsProto.$remove = function(helper, callback, async) {\n\treturn this.model.$remove(helper, callback, async);\n};\n\nSchemaOptionsProto.$get = SchemaOptionsProto.$read = function(helper, callback, async) {\n\treturn this.model.$get(helper, callback, async);\n};\n\nSchemaOptionsProto.push = function(type, name, helper, first) {\n\treturn this.model.$push(type, name, helper, first);\n};\n\nSchemaOptionsProto.next = function(type, name, helper) {\n\treturn this.model.$next(type, name, helper);\n};\n\nSchemaOptionsProto.output = function() {\n\treturn this.model.$output();\n};\n\nSchemaOptionsProto.stop = function() {\n\treturn this.model.$stop();\n};\n\nSchemaOptionsProto.response = function(index) {\n\treturn this.model.$response(index);\n};\n\nSchemaOptionsProto.DB = function() {\n\treturn F.database(this.error);\n};\n\nSchemaOptionsProto.successful = function(callback) {\n\tvar self = this;\n\treturn function(err, a, b, c) {\n\t\tif (err)\n\t\t\tself.invalid(err);\n\t\telse\n\t\t\tcallback.call(self, a, b, c);\n\t};\n};\n\nSchemaOptionsProto.success = function(a, b) {\n\n\tif (a && b === undefined && typeof(a) !== 'boolean') {\n\t\tb = a;\n\t\ta = true;\n\t}\n\n\tthis.callback(SUCCESS(a === undefined ? true : a, b));\n\treturn this;\n};\n\nSchemaOptionsProto.done = function(arg) {\n\tvar self = this;\n\treturn function(err, response) {\n\t\tif (err) {\n\n\t\t\tif (self.error !== err)\n\t\t\t\tself.error.push(err);\n\n\t\t\tself.callback();\n\t\t} else if (arg)\n\t\t\tself.callback(SUCCESS(err == null, arg === true ? response : arg));\n\t\telse\n\t\t\tself.callback(SUCCESS(err == null));\n\t};\n};\n\nSchemaOptionsProto.invalid = function(name, error, path, index) {\n\tvar self = this;\n\n\tif (arguments.length) {\n\t\tself.error.push(name, error, path, index);\n\t\tself.callback();\n\t\treturn self;\n\t}\n\n\treturn function(err) {\n\t\tself.error.push(err);\n\t\tself.callback();\n\t};\n};\n\nSchemaOptionsProto.repository = function(name, value) {\n\treturn this.model && this.model.$repository ? this.model.$repository(name, value) : value;\n};\n\nSchemaOptionsProto.noop = function() {\n\tthis.callback(NoOp);\n\treturn this;\n};\n\n/**\n *\n * Get a schema\n * @param {String} name\n * @return {Object}\n */\nSchemaBuilderProto.get = function(name) {\n\treturn this.collection[name];\n};\n\n/**\n * Create a new schema\n * @alias\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderProto.create = function(name) {\n\tthis.collection[name] = new SchemaBuilderEntity(this, name);\n\treturn this.collection[name];\n};\n\n/**\n * Removes an existing schema or group of schemas\n * @param {String} name Schema name, optional.\n * @return {SchemaBuilder}\n */\nSchemaBuilderProto.remove = function(name) {\n\tif (name) {\n\t\tvar schema = this.collection[name];\n\t\tschema && schema.destroy();\n\t\tschema = null;\n\t\tdelete schemasall[name.toLowerCase()];\n\t\tdelete this.collection[name];\n\t} else {\n\t\texports.remove(this.name);\n\t\tthis.collection = null;\n\t}\n};\n\nSchemaBuilderProto.destroy = function(name) {\n\treturn this.remove(name);\n};\n\nfunction SchemaBuilderEntity(parent, name) {\n\tthis.parent = parent;\n\tthis.name = name;\n\tthis.primary;\n\tthis.trim = true;\n\tthis.schema = {};\n\tthis.meta = {};\n\tthis.properties = [];\n\tthis.inherits = [];\n\tthis.verifications = null;\n\tthis.resourcePrefix;\n\tthis.extensions = {};\n\tthis.resourceName;\n\tthis.transforms;\n\tthis.workflows;\n\tthis.hooks;\n\tthis.operations;\n\tthis.constants;\n\tthis.onPrepare;\n\tthis.$onPrepare; // Array of functions for inherits\n\tthis.onDefault;\n\tthis.$onDefault; // Array of functions for inherits\n\tthis.onValidate = F.onValidate;\n\tthis.onSave;\n\tthis.onInsert;\n\tthis.onUpdate;\n\tthis.onGet;\n\tthis.onRemove;\n\tthis.onQuery;\n\tthis.onError;\n\tthis.gcache = {};\n\tthis.dependencies;\n\tthis.fields;\n\tthis.fields_allow;\n\tthis.CurrentSchemaInstance = function(){};\n\tthis.CurrentSchemaInstance.prototype = new SchemaInstance();\n\tthis.CurrentSchemaInstance.prototype.$$schema = this;\n}\n\nconst SchemaBuilderEntityProto = SchemaBuilderEntity.prototype;\n\nSchemaBuilderEntityProto.allow = function() {\n\tvar self = this;\n\n\tif (!self.fields_allow)\n\t\tself.fields_allow = [];\n\n\tvar arr = arguments;\n\n\tif (arr.length === 1)\n\t\tarr = arr[0].split(',').trim();\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tif (arr[i] instanceof Array)\n\t\t\tarr[i].forEach(item => self.fields_allow.push(item));\n\t\telse\n\t\t\tself.fields_allow.push(arr[i]);\n\t}\n\treturn self;\n};\n\nSchemaBuilderEntityProto.before = function(name, fn) {\n\tvar self = this;\n\tif (!self.preparation)\n\t\tself.preparation = {};\n\tself.preparation[name] = fn;\n\treturn self;\n};\n\nSchemaBuilderEntityProto.required = function(name, fn) {\n\n\tvar self = this;\n\n\tif (!name)\n\t\treturn self;\n\n\tif (name.indexOf(',') !== -1) {\n\t\tvar arr = name.split(',');\n\t\tfor (var i = 0; i < arr.length; i++)\n\t\t\tself.required(arr[i].trim(), fn);\n\t\treturn self;\n\t}\n\n\tif (fn === false) {\n\t\tself.properties && (self.properties = self.properties.remove(name));\n\t\treturn self;\n\t}\n\n\tvar prop = self.schema[name];\n\tif (!prop)\n\t\tthrow new Error('Property \"{0}\" doesn\\'t exist in \"{1}\" schema.'.format(name, self.name));\n\n\tprop.can = typeof(fn) === 'function' ? fn : null;\n\n\tif (!prop.required) {\n\t\tprop.required = true;\n\t\tif (self.properties) {\n\t\t\tself.properties.indexOf(name) === -1 && self.properties.push(name);\n\t\t} else\n\t\t\tself.properties = [name];\n\t}\n\n\treturn self;\n};\n\nSchemaBuilderEntityProto.clear = function() {\n\tvar self = this;\n\n\tself.schema = {};\n\tself.properties = [];\n\tself.fields = [];\n\tself.verifications = null;\n\n\tif (self.preparation)\n\t\tself.preparation = null;\n\n\tif (self.dependencies)\n\t\tself.dependencies = null;\n\n\tif (self.fields_allow)\n\t\tself.fields_allow = null;\n\n\treturn self;\n};\n\nSchemaBuilderEntityProto.middleware = function(fn) {\n\tvar self = this;\n\tif (!self.middlewares)\n\t\tself.middlewares = [];\n\tself.middlewares.push(fn);\n\treturn self;\n};\n\nfunction runmiddleware(opt, schema, callback, index, processor) {\n\n\tif (!index)\n\t\tindex = 0;\n\n\tvar fn = schema.middlewares[index];\n\n\tif (fn == null) {\n\t\tcallback.call(schema, opt);\n\t\treturn;\n\t}\n\n\tif (processor) {\n\t\tfn(opt, processor);\n\t\treturn;\n\t}\n\n\tprocessor = function(stop) {\n\t\tif (!stop)\n\t\t\trunmiddleware(opt, schema, callback, index + 1, processor);\n\t};\n\n\tfn(opt, processor);\n}\n\n/**\n * Define type in schema\n * @param {String|String[]} name\n * @param {Object/String} type\n * @param {Boolean} [required=false] Is required? Default: false.\n * @param {Number|String} [custom] Custom tag for search.\n * @return {SchemaBuilder}\n */\nSchemaBuilderEntityProto.define = function(name, type, required, custom) {\n\n\tif (name instanceof Array) {\n\t\tfor (var i = 0, length = name.length; i < length; i++)\n\t\t\tthis.define(name[i], type, required, custom);\n\t\treturn this;\n\t}\n\n\tvar rt = typeof(required);\n\n\tif (required !== undefined && rt === 'string') {\n\t\tcustom = required;\n\t\trequired = false;\n\t}\n\n\tif (type == null) {\n\t\t// remove\n\t\tdelete this.schema[name];\n\t\tthis.properties = this.properties.remove(name);\n\t\tif (this.dependencies)\n\t\t\tthis.dependencies = this.dependencies.remove(name);\n\t\tthis.fields = Object.keys(this.schema);\n\t\treturn this;\n\t}\n\n\tif (type instanceof SchemaBuilderEntity)\n\t\ttype = type.name;\n\n\tvar a = this.schema[name] = this.$parse(name, type, required, custom);\n\tswitch (this.schema[name].type) {\n\t\tcase 7:\n\t\t\tif (this.dependencies)\n\t\t\t\tthis.dependencies.push(name);\n\t\t\telse\n\t\t\t\tthis.dependencies = [name];\n\t\t\tbreak;\n\t}\n\n\tthis.fields = Object.keys(this.schema);\n\n\tif (a.type === 7)\n\t\trequired = true;\n\n\tif (required)\n\t\tthis.properties.indexOf(name) === -1 && this.properties.push(name);\n\telse\n\t\tthis.properties = this.properties.remove(name);\n\n\treturn function(val) {\n\t\ta.def = val;\n\t\treturn this;\n\t};\n};\n\nSchemaBuilderEntityProto.verify = function(name, fn, cache) {\n\tvar self = this;\n\n\tif (!self.verifications)\n\t\tself.verifications = [];\n\n\tvar cachekey;\n\n\tif (cache)\n\t\tcachekey = self.name + '_verify_' + name + '_';\n\n\tself.verifications.push({ name: name, fn: fn, cache: cache, cachekey: cachekey });\n\treturn self;\n};\n\nSchemaBuilderEntityProto.inherit = function(group, name) {\n\n\tif (!name) {\n\t\tname = group;\n\t\tgroup = DEFAULT_SCHEMA;\n\t}\n\n\tvar self = this;\n\n\texports.getschema(group, name, function(err, schema) {\n\n\t\tif (err)\n\t\t\tthrow err;\n\n\t\tself.primary = schema.primary;\n\t\tself.inherits.push(schema);\n\n\t\tif (!self.resourceName && schema.resourceName)\n\t\t\tself.resourceName = schema.resourceName;\n\n\t\tif (!self.resourcePrefix && schema.resourcePrefix)\n\t\t\tself.resourcePrefix = schema.resourcePrefix;\n\n\t\tcopy_inherit(self, 'schema', schema.schema);\n\t\tcopy_inherit(self, 'meta', schema.meta);\n\t\tcopy_inherit(self, 'transforms', schema.transforms);\n\t\tcopy_inherit(self, 'workflows', schema.workflows);\n\t\tcopy_inherit(self, 'hooks', schema.hooks);\n\t\tcopy_inherit(self, 'operations', schema.operations);\n\t\tcopy_inherit(self, 'constants', schema.constants);\n\n\t\tif (schema.middlewares) {\n\t\t\tself.middlewares = [];\n\t\t\tfor (var i = 0; i < schema.middlewares.length; i++)\n\t\t\t\tself.middlewares.push(schema.middlewares[i]);\n\t\t}\n\n\t\tif (schema.verifications) {\n\t\t\tself.verifications = [];\n\t\t\tfor (var i = 0; i < schema.verifications.length; i++)\n\t\t\t\tself.verifications.push(schema.verifications[i]);\n\t\t}\n\n\t\tschema.properties.forEach(function(item) {\n\t\t\tif (self.properties.indexOf(item) === -1)\n\t\t\t\tself.properties.push(item);\n\t\t});\n\n\t\tif (schema.preparation) {\n\t\t\tself.preparation = {};\n\t\t\tObject.keys(schema.preparation).forEach(function(key) {\n\t\t\t\tself.preparation[key] = schema.preparation[key];\n\t\t\t});\n\t\t}\n\n\t\tif (schema.onPrepare) {\n\t\t\tif (!self.$onPrepare)\n\t\t\t\tself.$onPrepare = [];\n\t\t\tself.$onPrepare.push(schema.onPrepare);\n\t\t}\n\n\t\tif (schema.onDefault) {\n\t\t\tif (!self.$onDefault)\n\t\t\t\tself.$onDefault = [];\n\t\t\tself.$onDefault.push(schema.onDefault);\n\t\t}\n\n\t\tif (self.onValidate === F.onValidate && self.onValidate !== schema.onValidate)\n\t\t\tself.onValidate = schema.onValidate;\n\n\t\tif (!self.onSave && schema.onSave)\n\t\t\tself.onSave = schema.onSave;\n\n\t\tif (!self.onInsert && schema.onInsert)\n\t\t\tself.onInsert = schema.onInsert;\n\n\t\tif (!self.onUpdate && schema.onUpdate)\n\t\t\tself.onUpdate = schema.onUpdate;\n\n\t\tif (!self.onGet && schema.onGet)\n\t\t\tself.onGet = schema.onGet;\n\n\t\tif (!self.onRemove && schema.onRemove)\n\t\t\tself.onRemove = schema.onRemove;\n\n\t\tif (!self.onQuery && schema.onQuery)\n\t\t\tself.onQuery = schema.onQuery;\n\n\t\tif (!self.onError && schema.onError)\n\t\t\tself.onError = schema.onError;\n\n\t\tself.fields = Object.keys(self.schema);\n\t});\n\n\treturn self;\n};\n\nfunction copy_inherit(schema, field, value) {\n\n\tif (!value)\n\t\treturn;\n\n\tif (value && !schema[field]) {\n\t\tschema[field] = framework_utils.clone(value);\n\t\treturn;\n\t}\n\n\tObject.keys(value).forEach(function(key) {\n\t\tif (schema[field][key] === undefined)\n\t\t\tschema[field][key] = framework_utils.clone(value[key]);\n\t});\n}\n\n/**\n * Set primary key\n * @param {String} name\n */\nSchemaBuilderEntityProto.setPrimary = function(name) {\n\tthis.primary = name;\n\treturn this;\n};\n\n/**\n * Filters current names of the schema via custom attribute\n * @param {Number/String} custom\n * @param {Object} model Optional\n * @param {Boolean} reverse Reverse results.\n * @return {Array|Object} Returns Array (with property names) if the model is undefined otherwise returns Object Name/Value.\n */\nSchemaBuilderEntityProto.filter = function(custom, model, reverse) {\n\n\tif (typeof(model) === 'boolean') {\n\t\tvar tmp = reverse;\n\t\treverse = model;\n\t\tmodel = tmp;\n\t}\n\n\tvar output = model === undefined ? [] : {};\n\tvar type = typeof(custom);\n\tvar isSearch = type === 'string' ? custom[0] === '*' || custom[0] === '%' : false;\n\tvar isReg = false;\n\n\tif (isSearch)\n\t\tcustom = custom.substring(1);\n\telse if (type === 'object')\n\t\tisReg = framework_utils.isRegExp(custom);\n\n\tfor (var prop in this.schema) {\n\n\t\tvar schema = this.schema[prop];\n\t\tif (!schema)\n\t\t\tcontinue;\n\n\t\tvar tv = typeof(schema.custom);\n\n\t\tif (isSearch) {\n\t\t\tif (tv === 'string') {\n\t\t\t\tif (schema.custom.indexOf(custom) === -1) {\n\t\t\t\t\tif (!reverse)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (reverse)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t} else if (isReg) {\n\t\t\tif (tv === 'string') {\n\t\t\t\tif (!custom.test(schema.current)) {\n\t\t\t\t\tif (!reverse)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (reverse)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t} else if (schema.custom !== custom) {\n\t\t\tif (!reverse)\n\t\t\t\tcontinue;\n\t\t} else if (reverse)\n\t\t\tcontinue;\n\n\t\tif (model === undefined)\n\t\t\toutput.push(prop);\n\t\telse\n\t\t\toutput[prop] = model[prop];\n\t}\n\n\treturn output;\n};\n\nfunction parseLength(lower, result) {\n\tresult.raw = 'string';\n\tvar beg = lower.indexOf('(');\n\tif (beg !== -1) {\n\t\tresult.length = lower.substring(beg + 1, lower.length - 1).parseInt();\n\t\tresult.raw = lower.substring(0, beg);\n\t}\n\treturn result;\n}\n\nSchemaBuilderEntityProto.$parse = function(name, value, required, custom) {\n\n\tvar type = typeof(value);\n\tvar result = {};\n\n\tresult.raw = value;\n\tresult.type = 0;\n\tresult.length = 0;\n\tresult.required = required ? true : false;\n\tresult.validate = typeof(required) === 'function' ? required : null;\n\tresult.can = null;\n\tresult.isArray = false;\n\tresult.custom = custom || '';\n\n\t//  0 = undefined\n\t//  1 = integer\n\t//  2 = float\n\t//  3 = string\n\t//  4 = boolean\n\t//  5 = date\n\t//  6 = object\n\t//  7 = custom object\n\t//  8 = enum\n\t//  9 = keyvalue\n\t// 10 = custom object type\n\t// 11 = number2\n\t// 12 = object as filter\n\n\tif (value === null)\n\t\treturn result;\n\n\tif (value === '[]') {\n\t\tresult.isArray = true;\n\t\treturn result;\n\t}\n\n\tif (type === 'function') {\n\n\t\tif (value === UID) {\n\t\t\tresult.type = 3;\n\t\t\tresult.length = 20;\n\t\t\tresult.raw = 'string';\n\t\t\tresult.subtype = 'uid';\n\t\t\treturn result;\n\t\t}\n\n\t\tif (value === Number) {\n\t\t\tresult.type = 2;\n\t\t\treturn result;\n\t\t}\n\n\t\tif (value === String) {\n\t\t\tresult.type = 3;\n\t\t\treturn result;\n\t\t}\n\n\t\tif (value === Boolean) {\n\t\t\tresult.type = 4;\n\t\t\treturn result;\n\t\t}\n\n\t\tif (value === Date) {\n\t\t\tresult.type = 5;\n\t\t\treturn result;\n\t\t}\n\n\t\tif (value === Array) {\n\t\t\tresult.isArray = true;\n\t\t\treturn result;\n\t\t}\n\n\t\tif (value === Object) {\n\t\t\tresult.type = 6;\n\t\t\treturn result;\n\t\t}\n\n\t\tif (value instanceof SchemaBuilderEntity)\n\t\t\tresult.type = 7;\n\t\telse {\n\t\t\tresult.type = 10;\n\t\t\tif (!this.asyncfields)\n\t\t\t\tthis.asyncfields = [];\n\t\t\tthis.asyncfields.push(name);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tif (type === 'object') {\n\t\tif (value instanceof Array) {\n\t\t\tresult.type = 8; // enum\n\t\t\tresult.subtype = typeof(value[0]);\n\t\t} else\n\t\t\tresult.type = 9; // keyvalue\n\t\treturn result;\n\t}\n\n\tif (value[0] === '[') {\n\t\tvalue = value.substring(1, value.length - 1);\n\t\tresult.isArray = true;\n\t\tresult.raw = value;\n\t}\n\n\tvar lower = value.toLowerCase();\n\n\tif (lower === 'object') {\n\t\tresult.type = 6;\n\t\treturn result;\n\t}\n\n\tif (lower === 'array') {\n\t\tresult.isArray = true;\n\t\treturn result;\n\t}\n\n\tif (value.indexOf(',') !== -1) {\n\t\t// multiple\n\t\tresult.type = 12;\n\t\treturn result;\n\t}\n\n\tif ((/^(string|text)+(\\(\\d+\\))?$/).test(lower)) {\n\t\tresult.type = 3;\n\t\treturn parseLength(lower, result);\n\t}\n\n\tif ((/^(capitalize2)+(\\(\\d+\\))?$/).test(lower)) {\n\t\tresult.type = 3;\n\t\tresult.subtype = 'capitalize2';\n\t\treturn parseLength(lower, result);\n\t}\n\n\tif ((/^(capitalize|camelcase|camelize)+(\\(\\d+\\))?$/).test(lower)) {\n\t\tresult.type = 3;\n\t\tresult.subtype = 'capitalize';\n\t\treturn parseLength(lower, result);\n\t}\n\n\tif ((/^(lower|lowercase)+(\\(\\d+\\))?$/).test(lower)) {\n\t\tresult.subtype = 'lowercase';\n\t\tresult.type = 3;\n\t\treturn parseLength(lower, result);\n\t}\n\n\tif (lower.indexOf('base64') !== -1) {\n\t\tresult.type = 3;\n\t\tresult.raw = 'string';\n\t\tresult.subtype = 'base64';\n\t\treturn result;\n\t}\n\n\tif ((/^(upper|uppercase)+(\\(\\d+\\))?$/).test(lower)) {\n\t\tresult.subtype = 'uppercase';\n\t\tresult.type = 3;\n\t\treturn parseLength(lower, result);\n\t}\n\n\tif (lower === 'uid') {\n\t\tresult.type = 3;\n\t\tresult.length = 20;\n\t\tresult.raw = 'string';\n\t\tresult.subtype = 'uid';\n\t\treturn result;\n\t}\n\n\tif (lower === 'email') {\n\t\tresult.type = 3;\n\t\tresult.length = 120;\n\t\tresult.raw = 'string';\n\t\tresult.subtype = 'email';\n\t\treturn result;\n\t}\n\n\tif (lower === 'json') {\n\t\tresult.type = 3;\n\t\tresult.raw = 'string';\n\t\tresult.subtype = 'json';\n\t\treturn result;\n\t}\n\n\tif (lower === 'url') {\n\t\tresult.type = 3;\n\t\tresult.length = 500;\n\t\tresult.raw = 'string';\n\t\tresult.subtype = 'url';\n\t\treturn result;\n\t}\n\n\tif (lower === 'zip') {\n\t\tresult.type = 3;\n\t\tresult.length = 10;\n\t\tresult.raw = 'string';\n\t\tresult.subtype = 'zip';\n\t\treturn result;\n\t}\n\n\tif (lower === 'phone') {\n\t\tresult.type = 3;\n\t\tresult.length = 20;\n\t\tresult.raw = 'string';\n\t\tresult.subtype = 'phone';\n\t\treturn result;\n\t}\n\n\tif (lower === 'number2') {\n\t\tresult.type = 11;\n\t\treturn result;\n\t}\n\n\tif (['int', 'integer', 'byte'].indexOf(lower) !== -1) {\n\t\tresult.type = 1;\n\t\treturn result;\n\t}\n\n\tif (['decimal', 'number', 'float', 'double'].indexOf(lower) !== -1) {\n\t\tresult.type = 2;\n\t\treturn result;\n\t}\n\n\tif (['bool', 'boolean'].indexOf(lower) !== -1) {\n\t\tresult.type = 4;\n\t\treturn result;\n\t}\n\n\tif (['date', 'time', 'datetime'].indexOf(lower) !== -1) {\n\t\tresult.type = 5;\n\t\treturn result;\n\t}\n\n\tresult.type = 7;\n\treturn result;\n};\n\nSchemaBuilderEntityProto.getDependencies = function() {\n\tvar dependencies = [];\n\n\tfor (var name in this.schema) {\n\n\t\tvar type = this.schema[name];\n\t\tif (typeof(type) !== 'string')\n\t\t\tcontinue;\n\n\t\tvar isArray = type[0] === ']';\n\t\tif (isArray)\n\t\t\ttype = type.substring(1, type.length - 1);\n\n\t\tvar m = this.parent.get(type);\n\t\tm && dependencies.push({ name: name, isArray: isArray, schema: m });\n\t}\n\n\treturn dependencies;\n};\n\n/**\n * Set schema validation\n * @param {String|Array} properties Properties to validate, optional.\n * @param {Function(propertyName, value, path, entityName, model)} fn A validation function.\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setValidate = function(properties, fn) {\n\n\tif (fn === undefined && properties instanceof Array) {\n\t\tthis.properties = properties;\n\t\treturn this;\n\t}\n\n\tif (typeof(properties) !== 'function') {\n\t\tthis.properties = properties;\n\t\tthis.onValidate = fn;\n\t} else\n\t\tthis.onValidate = properties;\n\n\treturn this;\n};\n\nSchemaBuilderEntityProto.setPrefix = function(prefix) {\n\tthis.resourcePrefix = prefix;\n\treturn this;\n};\n\nSchemaBuilderEntityProto.setResource = function(name) {\n\tthis.resourceName = name;\n\treturn this;\n};\n\n/**\n * Set the default values for schema\n * @param {Function(propertyName, isntPreparing, entityName)} fn\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setDefault = function(fn) {\n\tthis.onDefault = fn;\n\treturn this;\n};\n\n/**\n * Set the prepare\n * @param {Function(name, value)} fn Must return a new value.\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setPrepare = function(fn) {\n\tthis.onPrepare = fn;\n\treturn this;\n};\n\n/**\n * Set save handler\n * @param {Function(error, model, helper, next(value), controller)} fn\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setSave = function(fn, description, filter) {\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\tthis.onSave = fn;\n\tthis.meta.save = description || null;\n\tthis.meta.savefilter = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").setSave()'.format(this.name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.setSaveExtension = function(fn) {\n\tvar key = 'save';\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Set insert handler\n * @param {Function(error, model, helper, next(value), controller)} fn\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setInsert = function(fn, description, filter) {\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\tthis.onInsert = fn;\n\tthis.meta.insert = description || null;\n\tthis.meta.insertfilter = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").setInsert()'.format(this.name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.setInsertExtension = function(fn) {\n\tvar key = 'insert';\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Set update handler\n * @param {Function(error, model, helper, next(value), controller)} fn\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setUpdate = function(fn, description, filter) {\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\tthis.onUpdate = fn;\n\tthis.meta.update = description || null;\n\tthis.meta.updatefilter = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").setUpdate()'.format(this.name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.setUpdateExtension = function(fn) {\n\tvar key = 'update';\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Set patch handler\n * @param {Function(error, model, helper, next(value), controller)} fn\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setPatch = function(fn, description, filter) {\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\tthis.onPatch = fn;\n\tthis.meta.patch = description || null;\n\tthis.meta.patchfilter = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").setPatch()'.format(this.name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.setPatchExtension = function(fn) {\n\tvar key = 'patch';\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Set error handler\n * @param {Function(error)} fn\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setError = function(fn) {\n\tthis.onError = fn;\n\treturn this;\n};\n\n/**\n * Set getter handler\n * @param {Function(error, model, helper, next(value), controller)} fn\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setGet = SchemaBuilderEntityProto.setRead = function(fn, description, filter) {\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\tthis.onGet = fn;\n\tthis.meta.get = this.meta.read = description || null;\n\tthis.meta.getfilter = this.meta.readfilter = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").setGet()'.format(this.name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.setGetExtension = SchemaBuilderEntityProto.setReadExtension = function(fn) {\n\tvar key = 'read';\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Set query handler\n * @param {Function(error, helper, next(value), controller)} fn\n * @param {String} description Optional.\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setQuery = function(fn, description, filter) {\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\tthis.onQuery = fn;\n\tthis.meta.query = description || null;\n\tthis.meta.queryfilter = filter;\n\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").setQuery()'.format(this.name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.setQueryExtension = function(fn) {\n\tvar key = 'query';\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Set remove handler\n * @param {Function(error, helper, next(value), controller)} fn\n * @param {String} description Optional.\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.setRemove = function(fn, description, filter) {\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\tthis.onRemove = fn;\n\tthis.meta.remove = description || null;\n\tthis.meta.removefilter = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").setRemove()'.format(this.name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.setRemoveExtension = function(fn) {\n\tvar key = 'remove';\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Add a new constant for the schema\n * @param {String} name Constant name, optional.\n * @param {Object} value\n * @param {String} description Optional.\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.constant = function(name, value, description) {\n\n\tOBSOLETE('Constants will be removed from schemas.');\n\n\tif (value === undefined)\n\t\treturn this.constants ? this.constants[name] : undefined;\n\n\t!this.constants && (this.constants = {});\n\tthis.constants[name] = value;\n\tthis.meta['constant#' + name] = description || null;\n\treturn this;\n};\n\n/**\n * Add a new transformation for the entity\n * @param {String} name Transform name, optional.\n * @param {Function(errorBuilder, model, helper, next([output]), controller)} fn\n * @param {String} description Optional.\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.addTransform = function(name, fn, description, filter) {\n\n\tif (typeof(name) === 'function') {\n\t\tfn = name;\n\t\tname = 'default';\n\t}\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\t!this.transforms && (this.transforms = {});\n\tthis.transforms[name] = fn;\n\tthis.meta['transform#' + name] = description || null;\n\tthis.meta['transformfilter#' + name] = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").addTransform(\"{1}\")'.format(this.name, name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.addTransformExtension = function(name, fn) {\n\tvar key = 'transform.' + name;\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Add a new operation for the entity\n * @param {String} name Operation name, optional.\n * @param {Function(errorBuilder, [model], helper, next([output]), controller)} fn\n * @param {String} description Optional.\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.addOperation = function(name, fn, description, filter) {\n\n\tif (typeof(name) === 'function') {\n\t\tfn = name;\n\t\tname = 'default';\n\t}\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\t!this.operations && (this.operations = {});\n\tthis.operations[name] = fn;\n\tthis.meta['operation#' + name] = description || null;\n\tthis.meta['operationfilter#' + name] = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").addOperation(\"{1}\")'.format(this.name, name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.addOperationExtension = function(name, fn) {\n\tvar key = 'operation.' + name;\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Add a new workflow for the entity\n * @param {String} name Workflow name, optional.\n * @param {Function(errorBuilder, model, helper, next([output]), controller)} fn\n * @param {String} description Optional.\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.addWorkflow = function(name, fn, description, filter) {\n\n\tif (typeof(name) === 'function') {\n\t\tfn = name;\n\t\tname = 'default';\n\t}\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\t!this.workflows && (this.workflows = {});\n\tthis.workflows[name] = fn;\n\tthis.meta['workflow#' + name] = description || null;\n\tthis.meta['workflowfilter#' + name] = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").addWorkflow(\"{1}\")'.format(this.name, name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.addWorkflowExtension = function(name, fn) {\n\tvar key = 'workflow.' + name;\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\nSchemaBuilderEntityProto.addHook = function(name, fn, description, filter) {\n\n\tif (!this.hooks)\n\t\tthis.hooks = {};\n\n\tif (typeof(description) === 'string' && REGEXP_FILTER.test(description)) {\n\t\tfilter = description;\n\t\tdescription = null;\n\t}\n\n\tfn.$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\t!this.hooks[name] && (this.hooks[name] = []);\n\tthis.hooks[name].push({ owner: F.$owner(), fn: fn });\n\tthis.meta['hook#' + name] = description || null;\n\tthis.meta['hookfilter#' + name] = filter;\n\t!fn.$newversion && OBSOLETE('Schema(\"{0}\").addHook(\"{1}\")'.format(this.name, name), MSG_OBSOLETE_NEW);\n\treturn this;\n};\n\nSchemaBuilderEntityProto.addHookExtension = function(name, fn) {\n\tvar key = 'hook.' + name;\n\tif (this.extensions[key])\n\t\tthis.extensions[key].push(fn);\n\telse\n\t\tthis.extensions[key] = [fn];\n\treturn this;\n};\n\n/**\n * Find an entity in current group\n * @param {String} name\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.find = function(name) {\n\treturn this.parent.get(name);\n};\n\n/**\n * Destroys current entity\n */\nSchemaBuilderEntityProto.destroy = function() {\n\tdelete this.parent.collection[this.name];\n\tdelete this.properties;\n\tdelete this.schema;\n\tdelete this.onDefault;\n\tdelete this.$onDefault;\n\tdelete this.onValidate;\n\tdelete this.onSave;\n\tdelete this.onInsert;\n\tdelete this.onUpdate;\n\tdelete this.onRead;\n\tdelete this.onGet;\n\tdelete this.onRemove;\n\tdelete this.onQuery;\n\tdelete this.workflows;\n\tdelete this.operations;\n\tdelete this.transforms;\n\tdelete this.meta;\n\tdelete this.newversion;\n\tdelete this.properties;\n\tdelete this.hooks;\n\tdelete this.constants;\n\tdelete this.onPrepare;\n\tdelete this.$onPrepare;\n\tdelete this.onError;\n\tdelete this.gcache;\n\tdelete this.dependencies;\n\tdelete this.fields;\n\tdelete this.fields_allow;\n};\n\n/**\n * Execute onSave delegate\n * @param {Object} model\n * @param {Object} options Custom options object, optional\n * @param {Function(err, result)} callback\n * @param {Controller} controller\n * @param {Boolean} skip Skips preparing and validation, optional\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.save = function(model, options, callback, controller, skip) {\n\treturn this.execute('onSave', model, options, callback, controller, skip);\n};\n\n/**\n * Execute onInsert delegate\n * @param {Object} model\n * @param {Object} options Custom options object, optional\n * @param {Function(err, result)} callback\n * @param {Controller} controller\n * @param {Boolean} skip Skips preparing and validation, optional\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.insert = function(model, options, callback, controller, skip) {\n\treturn this.execute('onInsert', model, options, callback, controller, skip);\n};\n\n/**\n * Execute onUpdate delegate\n * @param {Object} model\n * @param {Object} options Custom options object, optional\n * @param {Function(err, result)} callback\n * @param {Controller} controller\n * @param {Boolean} skip Skips preparing and validation, optional\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.update = function(model, options, callback, controller, skip) {\n\treturn this.execute('onUpdate', model, options, callback, controller, skip);\n};\n\nSchemaBuilderEntityProto.patch = function(model, options, callback, controller, skip) {\n\treturn this.execute('onPatch', model, options, callback, controller, skip);\n};\n\nSchemaBuilderEntityProto.execute = function(TYPE, model, options, callback, controller, skip) {\n\n\tif (typeof(callback) === 'boolean') {\n\t\tskip = callback;\n\t\tcallback = options;\n\t\toptions = undefined;\n\t} else if (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tif (typeof(controller) === 'boolean') {\n\t\tvar tmp = skip;\n\t\tskip = controller;\n\t\tcontroller = tmp;\n\t}\n\n\tif (typeof(callback) !== 'function')\n\t\tcallback = function(){};\n\n\tvar self = this;\n\tvar $type;\n\n\tswitch (TYPE) {\n\t\tcase 'onInsert':\n\t\t\t$type = 'insert';\n\t\t\tbreak;\n\t\tcase 'onUpdate':\n\t\t\t$type = 'update';\n\t\t\tbreak;\n\t\tcase 'onPatch':\n\t\t\t$type = 'patch';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t$type = 'save';\n\t\t\tbreak;\n\t}\n\n\tif (!self[TYPE])\n\t\treturn callback(new Error('Operation \"{0}/{1}\" not found'.format(self.name, $type)));\n\n\tself.$prepare(model, function(err, model) {\n\n\t\tif (err) {\n\t\t\tcallback(err, model);\n\t\t\treturn;\n\t\t}\n\n\t\tif (controller instanceof SchemaOptions || controller instanceof OperationOptions)\n\t\t\tcontroller = controller.controller;\n\n\t\tif (model && !controller && model.$$controller)\n\t\t\tcontroller = model.$$controller;\n\n\t\tvar builder = new ErrorBuilder();\n\t\tvar $now;\n\n\t\tif (CONF.logger)\n\t\t\t$now = Date.now();\n\n\t\tself.resourceName && builder.setResource(self.resourceName);\n\t\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\n\t\tif (!isGenerator(self, $type, self[TYPE])) {\n\t\t\tif (self[TYPE].$newversion) {\n\t\t\t\tvar opt = new SchemaOptions(builder, model, options, function(res) {\n\t\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\t\t\t\t\tself.$process(arguments, model, $type, undefined, builder, res, callback, controller);\n\t\t\t\t}, controller, $type, self);\n\n\t\t\t\tif (self.middlewares && self.middlewares.length)\n\t\t\t\t\trunmiddleware(opt, self, self[TYPE]);\n\t\t\t\telse\n\t\t\t\t\tself[TYPE](opt);\n\n\t\t\t} else\n\t\t\t\tself[TYPE](builder, model, options, function(res) {\n\t\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\t\t\t\t\tself.$process(arguments, model, $type, undefined, builder, res, callback, controller);\n\t\t\t\t}, controller, skip !== true);\n\t\t\treturn self;\n\t\t}\n\n\t\tcallback.success = false;\n\n\t\tvar onError = function(err) {\n\t\t\tif (!err || callback.success)\n\t\t\t\treturn;\n\n\t\t\tcallback.success = true;\n\n\t\t\tif (builder !== err)\n\t\t\t\tbuilder.push(err);\n\n\t\t\tself.onError && self.onError(builder, model, $type);\n\t\t\tcallback(builder);\n\t\t};\n\n\t\tvar onCallback = function(res) {\n\n\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\n\t\t\tif (callback.success)\n\t\t\t\treturn;\n\n\t\t\tif (arguments.length === 2 || (res instanceof Error || res instanceof ErrorBuilder)) {\n\t\t\t\tif ((res instanceof Error || res instanceof ErrorBuilder) && builder !== res)\n\t\t\t\t\tbuilder.push(res);\n\t\t\t\tres = arguments[1];\n\t\t\t}\n\n\t\t\tvar has = builder.is;\n\t\t\thas && self.onError && self.onError(builder, model, $type);\n\t\t\tcallback.success = true;\n\t\t\tcallback(has ? builder : null, res === undefined ? model : res);\n\t\t};\n\n\t\tif (self[TYPE].$newversion) {\n\t\t\tvar opt = new SchemaOptions(builder, model, options, onCallback, controller, $type, self);\n\t\t\tif (self.middlewares && self.middlewares.length)\n\t\t\t\trunmiddleware(opt, self, () => async.call(self, self[TYPE])(onError, opt));\n\t\t\telse\n\t\t\t\tasync.call(self, self[TYPE])(onError, opt);\n\t\t} else\n\t\t\tasync.call(self, self[TYPE])(onError, builder, model, options, onCallback, controller, skip !== true);\n\n\t}, controller ? controller.req : null);\n\n\treturn self;\n};\n\n\nfunction isGenerator(obj, name, fn) {\n\treturn obj.gcache[name] ? obj.gcache[name] : obj.gcache[name] = fn.toString().substring(0, 9) === 'function*';\n}\n\n/**\n * Execute onGet delegate\n * @param {Object} options Custom options object, optional\n * @param {Function(err, result)} callback\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.get = SchemaBuilderEntityProto.read = function(options, callback, controller) {\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tif (typeof(callback) !== 'function')\n\t\tcallback = function(){};\n\n\tvar self = this;\n\tvar builder = new ErrorBuilder();\n\tvar $now;\n\n\tself.resourceName && builder.setResource(self.resourceName);\n\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\n\tif (controller instanceof SchemaOptions || controller instanceof OperationOptions)\n\t\tcontroller = controller.controller;\n\n\tif (self.meta.getfilter && controller) {\n\t\tcontroller.$filterschema = self.meta.getfilter;\n\t\tcontroller.$filter = null;\n\t}\n\n\tif (CONF.logger)\n\t\t$now = Date.now();\n\n\tvar output = self.default();\n\tvar $type = 'get';\n\n\tif (!isGenerator(self, $type, self.onGet)) {\n\t\tif (self.onGet.$newversion) {\n\t\t\tvar opt = new SchemaOptions(builder, output, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\t\t\t\tself.$process(arguments, output, $type, undefined, builder, res, callback, controller);\n\t\t\t}, controller, $type, self);\n\n\t\t\tif (self.middlewares && self.middlewares.length)\n\t\t\t\trunmiddleware(opt, self, self.onGet);\n\t\t\telse\n\t\t\t\tself.onGet(opt);\n\t\t} else\n\t\t\tself.onGet(builder, output, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\t\t\t\tself.$process(arguments, output, $type, undefined, builder, res, callback, controller);\n\t\t\t}, controller);\n\t\treturn self;\n\t}\n\n\tcallback.success = false;\n\n\tvar onError = function(err) {\n\t\tif (!err || callback.success)\n\t\t\treturn;\n\t\tcallback.success = true;\n\n\t\tif (builder !== err)\n\t\t\tbuilder.push(err);\n\n\t\tself.onError && self.onError(builder, output, $type);\n\t\tcallback(builder);\n\t};\n\n\tvar onCallback = function(res) {\n\n\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\n\t\tif (callback.success)\n\t\t\treturn;\n\n\t\tif (arguments.length === 2 || (res instanceof Error || res instanceof ErrorBuilder)) {\n\t\t\tif ((res instanceof Error || res instanceof ErrorBuilder) && builder !== res)\n\t\t\t\tbuilder.push(res);\n\t\t\tres = arguments[1];\n\t\t}\n\n\t\tcallback.success = true;\n\t\tvar has = builder.is;\n\t\thas && self.onError && self.onError(builder, output, $type);\n\t\tcallback(has ? builder : null, res === undefined ? output : res);\n\t};\n\n\tif (self.onGet.$newversion) {\n\t\tvar opt = new SchemaOptions(builder, output, options, onCallback, controller, $type, self);\n\t\tif (self.middlewares && self.middlewares.length)\n\t\t\trunmiddleware(opt, self, () => async.call(self, self.onGet)(onError, opt));\n\t\telse\n\t\t\tasync.call(self, self.onGet)(onError, opt);\n\t} else\n\t\tasync.call(self, self.onGet)(onError, builder, output, options, onCallback, controller);\n\n\treturn self;\n};\n\n/**\n * Execute onRemove delegate\n * @param {Object} options Custom options object, optional\n * @param {Function(err, result)} callback\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.remove = function(options, callback, controller) {\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tvar self = this;\n\tvar builder = new ErrorBuilder();\n\tvar $type = 'remove';\n\tvar $now;\n\n\tif (!self.onRemove)\n\t\treturn callback(new Error('Operation \"{0}/{1}\" not found'.format(self.name, $type)));\n\n\tif (controller instanceof SchemaOptions || controller instanceof OperationOptions)\n\t\tcontroller = controller.controller;\n\n\tif (self.meta.removefilter && controller) {\n\t\tcontroller.$filterschema = self.meta.removefilter;\n\t\tcontroller.$filter = null;\n\t}\n\n\tif (CONF.logger)\n\t\t$now = Date.now();\n\n\tself.resourceName && builder.setResource(self.resourceName);\n\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\n\tif (!isGenerator(self, $type, self.onRemove)) {\n\t\tif (self.onRemove.$newversion) {\n\n\t\t\tvar opt = new SchemaOptions(builder, controller ? controller.body : undefined, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\t\t\t\tself.$process(arguments, undefined, $type, undefined, builder, res, callback, controller);\n\t\t\t}, controller, $type, self);\n\n\t\t\tif (self.middlewares && self.middlewares.length)\n\t\t\t\trunmiddleware(opt, self, self.onRemove);\n\t\t\telse\n\t\t\t\tself.onRemove(opt);\n\t\t} else\n\t\t\tself.onRemove(builder, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\t\t\t\tself.$process(arguments, undefined, $type, undefined, builder, res, callback, controller);\n\t\t\t}, controller);\n\t\treturn self;\n\t}\n\n\tcallback.success = false;\n\n\tvar onError = function(err) {\n\t\tif (!err || callback.success)\n\t\t\treturn;\n\t\tcallback.success = true;\n\n\t\tif (builder !== err)\n\t\t\tbuilder.push(err);\n\n\t\tself.onError && self.onError(builder, EMPTYOBJECT, $type);\n\t\tcallback(builder);\n\t};\n\n\tvar onCallback = function(res) {\n\n\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\n\t\tif (callback.success)\n\t\t\treturn;\n\n\t\tif (arguments.length === 2 || (res instanceof Error || res instanceof ErrorBuilder)) {\n\t\t\tif ((res instanceof Error || res instanceof ErrorBuilder) && builder !== res)\n\t\t\t\tbuilder.push(res);\n\t\t\tres = arguments[1];\n\t\t}\n\n\t\tvar has = builder.is;\n\t\thas && self.onError && self.onError(builder, EMPTYOBJECT, $type);\n\t\tcallback.success = true;\n\t\tcallback(has ? builder : null, res === undefined ? options : res);\n\t};\n\n\tif (self.onRemove.$newversion) {\n\t\tvar opt = new SchemaOptions(builder, undefined, options, onCallback, controller, $type, self);\n\t\tif (self.middlewares && self.middlewares.length)\n\t\t\trunmiddleware(opt, self, () => async.call(self, self.onRemove)(onError, opt));\n\t\telse\n\t\t\tasync.call(self, self.onRemove)(onError, opt);\n\t} else\n\t\tasync.call(self, self.onRemove)(onError, builder, options, onCallback, controller);\n\n\treturn self;\n};\n\n/**\n * Execute onQuery delegate\n * @param {Object} options Custom options object, optional\n * @param {Function(err, result)} callback\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.query = function(options, callback, controller) {\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tif (controller instanceof SchemaOptions || controller instanceof OperationOptions)\n\t\tcontroller = controller.controller;\n\n\tvar self = this;\n\tvar builder = new ErrorBuilder();\n\tvar $type = 'query';\n\tvar $now;\n\n\tif (self.meta.queryfilter && controller) {\n\t\tcontroller.$filterschema = self.meta.queryfilter;\n\t\tcontroller.$filter = null;\n\t}\n\n\tself.resourceName && builder.setResource(self.resourceName);\n\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\n\tif (CONF.logger)\n\t\t$now = Date.now();\n\n\tif (!isGenerator(self, $type, self.onQuery)) {\n\t\tif (self.onQuery.$newversion) {\n\t\t\tvar opt = new SchemaOptions(builder, undefined, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\t\t\t\tself.$process(arguments, undefined, $type, undefined, builder, res, callback, controller);\n\t\t\t}, controller, $type, self);\n\n\t\t\tif (self.middlewares && self.middlewares.length)\n\t\t\t\trunmiddleware(opt, self, self.onQuery);\n\t\t\telse\n\t\t\t\tself.onQuery(opt);\n\n\t\t} else\n\t\t\tself.onQuery(builder, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\t\t\t\tself.$process(arguments, undefined, $type, undefined, builder, res, callback, controller);\n\t\t\t}, controller);\n\t\treturn self;\n\t}\n\n\tcallback.success = false;\n\n\tvar onError = function(err) {\n\t\tif (!err || callback.success)\n\t\t\treturn;\n\t\tcallback.success = true;\n\n\t\tif (builder !== err)\n\t\t\tbuilder.push(err);\n\n\t\tself.onError && self.onError(builder, EMPTYOBJECT, $type);\n\t\tcallback(builder);\n\t};\n\n\tvar onCallback = function(res) {\n\n\t\tCONF.logger && F.ilogger(self.getLoggerName($type), controller, $now);\n\n\t\tif (callback.success)\n\t\t\treturn;\n\n\t\tif (arguments.length === 2 || (res instanceof Error || res instanceof ErrorBuilder)) {\n\t\t\tif ((res instanceof Error || res instanceof ErrorBuilder) && builder !== res)\n\t\t\t\tbuilder.push(res);\n\t\t\tres = arguments[1];\n\t\t}\n\n\t\tvar has = builder.is;\n\t\thas && self.onError && self.onError(builder, EMPTYOBJECT, $type);\n\t\tcallback.success = true;\n\t\tcallback(builder.is ? builder : null, res);\n\t};\n\n\tif (self.onQuery.$newversion) {\n\t\tvar opt = new SchemaOptions(builder, undefined, options, onCallback, controller, $type, self);\n\t\tif (self.middlewares && self.middlewares.length)\n\t\t\trunmiddleware(opt, self, () => async.call(self, self.onQuery)(onError, opt));\n\t\telse\n\t\t\tasync.call(self, self.onQuery)(onError, opt);\n\t} else\n\t\tasync.call(self, self.onQuery)(onError, builder, options, onCallback, controller);\n\n\treturn self;\n};\n\n/**\n * Validate a schema\n * @param {Object} model Object to validate.\n * @param {String} resourcePrefix Prefix for resource key.\n * @param {String} resourceName Resource filename.\n * @param {ErrorBuilder} builder ErrorBuilder, INTERNAL.\n * @return {ErrorBuilder}\n */\nSchemaBuilderEntityProto.validate = function(model, resourcePrefix, resourceName, builder, filter, path, index) {\n\n\tvar self = this;\n\n\tif (builder === undefined) {\n\t\tbuilder = new ErrorBuilder();\n\t\tself.resourceName && builder.setResource(self.resourceName);\n\t\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\t}\n\n\tif (self.resourcePrefix)\n\t\tbuilder.resourcePrefix = self.resourcePrefix;\n\n\tif (self.resourceName)\n\t\tbuilder.resourceName = self.resourceName;\n\n\tif (resourceName)\n\t\tbuilder.resourceName = resourceName;\n\n\tif (resourcePrefix)\n\t\tbuilder.resourcePrefix = resourcePrefix;\n\n\tif (filter)\n\t\tfilter = self.filter(filter);\n\n\tif (path)\n\t\tpath += '.';\n\telse\n\t\tpath = '';\n\n\tframework_utils.validate_builder.call(self, model, builder, self, '', index, filter, path);\n\treturn builder;\n};\n\n/**\n * Create a default object according the schema\n * @alias SchemaBuilderEntity.default()\n * @return {Object}\n */\nSchemaBuilderEntityProto.create = function() {\n\treturn this.default();\n};\n\nSchemaBuilderEntityProto.Create = function() {\n\treturn this.default();\n};\n\n/**\n * Makes extensible object\n * @param {Object} obj\n * @return {Object}\n */\nSchemaBuilderEntityProto.$make = function(obj) {\n\treturn obj;\n};\n\nSchemaBuilderEntityProto.$prepare = function(obj, callback) {\n\tif (obj && typeof(obj.$save) === 'function')\n\t\tcallback(null, obj);\n\telse\n\t\tthis.make(obj, (err, model) => callback(err, model));\n\treturn this;\n};\n\n/**\n * Create a default object according the schema\n * @return {SchemaInstance}\n */\nSchemaBuilderEntityProto.default = function() {\n\n\tvar obj = this.schema;\n\tif (obj === null)\n\t\treturn null;\n\n\tvar item = new this.CurrentSchemaInstance();\n\tvar defaults = this.onDefault || this.$onDefault ? true : false;\n\n\tfor (var property in obj) {\n\n\t\tvar type = obj[property];\n\n\t\tif (defaults) {\n\t\t\tvar def = this.$ondefault(property, true, this.name);\n\t\t\tif (def !== undefined) {\n\t\t\t\titem[property] = def;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (type.def !== undefined) {\n\t\t\titem[property] = typeof(type.def) === 'function' ? type.def() : type.def;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (type.type) {\n\t\t\t// undefined\n\t\t\t// object\n\t\t\t// object: convertor\n\t\t\tcase 0:\n\t\t\tcase 6:\n\t\t\tcase 12:\n\t\t\t\titem[property] = type.isArray ? [] : null;\n\t\t\t\tbreak;\n\t\t\t// numbers: integer, float\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\titem[property] = type.isArray ? [] : 0;\n\t\t\t\tbreak;\n\t\t\t// numbers: default \"null\"\n\t\t\tcase 10:\n\t\t\t\titem[property] = type.isArray ? [] : null;\n\t\t\t\tbreak;\n\t\t\t// string\n\t\t\tcase 3:\n\t\t\t\titem[property] = type.isArray ? [] : type.subtype === 'email' ? '@' : '';\n\t\t\t\tbreak;\n\t\t\t// boolean\n\t\t\tcase 4:\n\t\t\t\titem[property] = type.isArray ? [] : false;\n\t\t\t\tbreak;\n\t\t\t// date\n\t\t\tcase 5:\n\t\t\t\titem[property] = type.isArray ? [] : NOW;\n\t\t\t\tbreak;\n\t\t\t// schema\n\t\t\tcase 7:\n\n\t\t\t\tif (type.isArray) {\n\t\t\t\t\titem[property] = [];\n\t\t\t\t} else {\n\t\t\t\t\tvar tmp = this.parent.collection[type.raw] || GETSCHEMA(type.raw);\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\titem[property] = tmp.default();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tF.error(new Error('Schema: \"' + property + '.' + type.raw + '\" not found in \"' + this.parent.name + '\".'));\n\t\t\t\t\t\titem[property] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// enum + keyvalue\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\t\titem[property] = undefined;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn item;\n};\n\nfunction SchemaOptionsVerify(controller, builder) {\n\tvar t = this;\n\tt.controller = (controller instanceof SchemaOptions || controller instanceof OperationOptions) ? controller.controller : controller;\n\tt.callback = t.next = t.success = function(value) {\n\t\tif (value !== undefined)\n\t\t\tt.model[t.name] = value;\n\t\tt.cache && CACHE(t.cachekey, { value: t.model[t.name] }, t.cache);\n\t\tt.$next();\n\t};\n\tt.invalid = function(err) {\n\t\tif (err) {\n\t\t\tbuilder.push(err);\n\t\t\tt.cache && CACHE(t.cachekey, { error: err }, t.cache);\n\t\t}\n\t\tt.model[t.name] = null;\n\t\tt.$next();\n\t};\n}\n\nSchemaOptionsVerify.prototype = {\n\n\tget user() {\n\t\treturn this.controller ? this.controller.user : null;\n\t},\n\n\tget session() {\n\t\treturn this.controller ? this.controller.session : null;\n\t},\n\n\tget sessionid() {\n\t\treturn this.controller && this.controller ? this.controller.req.sessionid : null;\n\t},\n\n\tget language() {\n\t\treturn (this.controller ? this.controller.language : '') || '';\n\t},\n\n\tget ip() {\n\t\treturn this.controller ? this.controller.ip : null;\n\t},\n\n\tget id() {\n\t\treturn this.controller ? this.controller.id : null;\n\t},\n\n\tget req() {\n\t\treturn this.controller ? this.controller.req : null;\n\t},\n\n\tget res() {\n\t\treturn this.controller ? this.controller.res : null;\n\t},\n\n\tget params() {\n\t\treturn this.controller ? this.controller.params : null;\n\t},\n\n\tget files() {\n\t\treturn this.controller ? this.controller.files : null;\n\t},\n\n\tget body() {\n\t\treturn this.controller ? this.controller.body : null;\n\t},\n\n\tget query() {\n\t\treturn this.controller ? this.controller.query : null;\n\t},\n\n\tget headers() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.headers : null;\n\t},\n\n\tget ua() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.ua : null;\n\t}\n};\n\n/**\n * Create schema instance\n * @param {function|object} model\n * @param [filter]\n * @param [callback]\n * @returns {SchemaInstance}\n */\nSchemaBuilderEntityProto.make = function(model, filter, callback, argument, novalidate, workflow, req) {\n\n\tvar self = this;\n\n\tif (typeof(model) === 'function') {\n\t\tmodel.call(self, self);\n\t\treturn self;\n\t}\n\n\tif (typeof(filter) === 'function') {\n\t\tvar tmp = callback;\n\t\tcallback = filter;\n\t\tfilter = tmp;\n\t}\n\n\tvar verifications = [];\n\tvar output = self.prepare(model, null, req, verifications);\n\n\tif (workflow)\n\t\toutput.$$workflow = workflow;\n\n\tif (novalidate) {\n\t\tcallback && callback(null, output, argument);\n\t\treturn output;\n\t}\n\n\tvar builder = self.validate(output, undefined, undefined, undefined, filter);\n\n\tif (builder.is) {\n\t\tself.onError && self.onError(builder, model, 'make');\n\t\tcallback && callback(builder, null, argument);\n\t\treturn output;\n\t} else {\n\n\t\tif (self.verifications)\n\t\t\tverifications.unshift({ model: output, entity: self });\n\n\t\tif (!verifications.length) {\n\t\t\tcallback && callback(null, output, argument);\n\t\t\treturn output;\n\t\t}\n\n\t\tvar options = new SchemaOptionsVerify(req, builder);\n\n\t\tverifications.wait(function(item, next) {\n\n\t\t\titem.entity.verifications.wait(function(verify, resume) {\n\n\t\t\t\toptions.value = item.model[verify.name];\n\n\t\t\t\t// Empty values are skipped\n\t\t\t\tif (options.value == null || options.value === '') {\n\t\t\t\t\tresume();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar cachekey = verify.cachekey;\n\n\t\t\t\tif (cachekey) {\n\t\t\t\t\tcachekey += options.value + '';\n\t\t\t\t\tvar cachevalue = F.cache.get2(cachekey);\n\t\t\t\t\tif (cachevalue) {\n\t\t\t\t\t\tif (cachevalue.error)\n\t\t\t\t\t\t\tbuilder.push(cachevalue.error);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\titem.model[verify.name] = cachevalue.value;\n\t\t\t\t\t\tresume();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toptions.cache = verify.cache;\n\t\t\t\toptions.cachekey = cachekey;\n\t\t\t\toptions.entity = item.entity;\n\t\t\t\toptions.model = item.model;\n\t\t\t\toptions.name = verify.name;\n\t\t\t\toptions.$next = resume;\n\t\t\t\tverify.fn(options);\n\n\t\t\t}, next, 3); // \"3\" means count of imaginary \"threads\" - we will see how it will work\n\n\t\t}, function() {\n\t\t\tif (builder.is) {\n\t\t\t\tself.onError && self.onError(builder, model, 'make');\n\t\t\t\tcallback && callback(builder, null, argument);\n\t\t\t} else\n\t\t\t\tcallback && callback(null, output, argument);\n\t\t});\n\n\t}\n};\n\nSchemaBuilderEntityProto.load = SchemaBuilderEntityProto.make; // Because JSDoc doesn't work with double asserting\n\nfunction autotrim(context, value) {\n\treturn context.trim ? value.trim() : value;\n}\n\nSchemaBuilderEntityProto.$onprepare = function(name, value, index, model, req) {\n\n\tvar val = value;\n\n\tif (this.$onPrepare) {\n\t\tfor (var i = 0, length = this.$onPrepare.length; i < length; i++) {\n\t\t\tvar tmp = this.$onPrepare[i](name, val, index, model, req);\n\t\t\tif (tmp !== undefined)\n\t\t\t\tval = tmp;\n\t\t}\n\t}\n\n\tif (this.onPrepare)\n\t\tval = this.onPrepare(name, val, index, model, req);\n\n\tif (this.preparation && this.preparation[name])\n\t\tval = this.preparation[name](val, model, index, req);\n\n\treturn val === undefined ? value : val;\n};\n\nSchemaBuilderEntityProto.$ondefault = function(property, create, entity) {\n\n\tvar val;\n\n\tif (this.onDefault) {\n\t\tval = this.onDefault(property, create, entity);\n\t\tif (val !== undefined)\n\t\t\treturn val;\n\t}\n\n\tif (this.$onDefault) {\n\t\tfor (var i = 0, length = this.$onDefault.length; i < length; i++) {\n\t\t\tval = this.$onDefault[i](property, create, entity);\n\t\t\tif (val !== undefined)\n\t\t\t\treturn val;\n\t\t}\n\t}\n};\n\n/**\n * Prepare model according to schema\n * @param {Object} model\n * @param {String|Array} [dependencies] INTERNAL.\n * @return {SchemaInstance}\n */\nSchemaBuilderEntityProto.prepare = function(model, dependencies, req, verifications) {\n\n\tvar self = this;\n\tvar obj = self.schema;\n\n\tif (obj === null)\n\t\treturn null;\n\n\tif (model == null)\n\t\treturn self.default();\n\n\tvar tmp;\n\tvar entity;\n\tvar item = new self.CurrentSchemaInstance();\n\tvar defaults = self.onDefault || self.$onDefault ? true : false;\n\tvar keys = req && req.$patch ? [] : null;\n\n\tfor (var property in obj) {\n\n\t\tvar val = model[property];\n\n\t\tif (req && req.$patch && val === undefined) {\n\t\t\tdelete item[property];\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar type = obj[property];\n\t\tkeys && keys.push(property);\n\n\t\t// IS PROTOTYPE? The problem was in e.g. \"search\" property, because search is in String prototypes.\n\t\tif (!hasOwnProperty.call(model, property))\n\t\t\tval = undefined;\n\n\t\tvar def = type.def && typeof(type.def) === 'function';\n\n\t\tif (val === undefined) {\n\t\t\tif (type.def !== undefined)\n\t\t\t\tval = def ? type.def() : type.def;\n\t\t\telse if (defaults)\n\t\t\t\tval = self.$ondefault(property, false, self.name);\n\t\t}\n\n\t\tif (val === undefined)\n\t\t\tval = '';\n\n\t\tvar typeval = typeof(val);\n\n\t\tif (typeval === 'function')\n\t\t\tval = val();\n\n\t\tif (!type.isArray) {\n\n\t\t\tswitch (type.type) {\n\t\t\t\t// undefined\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\t\t\t\t// number: integer\n\t\t\t\tcase 1:\n\t\t\t\t\titem[property] = self.$onprepare(property, framework_utils.parseInt(val, def ? type.def() : type.def), undefined, model, req);\n\t\t\t\t\tbreak;\n\t\t\t\t// number: float\n\t\t\t\tcase 2:\n\t\t\t\t\titem[property] = self.$onprepare(property, framework_utils.parseFloat(val, def ? type.def() : type.def), undefined, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// string\n\t\t\t\tcase 3:\n\n\t\t\t\t\tvar tv = typeof(val);\n\n\t\t\t\t\tif (val == null || tv === 'object')\n\t\t\t\t\t\ttmp = '';\n\t\t\t\t\telse if (tv === 'string')\n\t\t\t\t\t\ttmp = autotrim(self, val);\n\t\t\t\t\telse\n\t\t\t\t\t\ttmp = autotrim(self, val.toString());\n\n\t\t\t\t\tif (type.length && type.length < tmp.length)\n\t\t\t\t\t\ttmp = tmp.substring(0, type.length);\n\n\t\t\t\t\tswitch (type.subtype) {\n\t\t\t\t\t\tcase 'uid':\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isUID())\n\t\t\t\t\t\t\t\ttmp = '';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'email':\n\t\t\t\t\t\t\ttmp = tmp.toLowerCase().replace(REGEXP_CLEAN_EMAIL, '');\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isEmail())\n\t\t\t\t\t\t\t\ttmp = '';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'url':\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isURL())\n\t\t\t\t\t\t\t\ttmp = '';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'zip':\n\t\t\t\t\t\t\ttmp = tmp.replace(REGEXP_CLEAN_EMAIL, '');\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isZIP())\n\t\t\t\t\t\t\t\ttmp = '';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'phone':\n\t\t\t\t\t\t\ttmp = tmp.replace(REGEXP_CLEAN_PHONE, '');\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isPhone())\n\t\t\t\t\t\t\t\ttmp = '';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'capitalize':\n\t\t\t\t\t\t\ttmp = tmp.capitalize();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'capitalize2':\n\t\t\t\t\t\t\ttmp = tmp.capitalize(true);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'lowercase':\n\t\t\t\t\t\t\ttmp = tmp.toLowerCase();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'uppercase':\n\t\t\t\t\t\t\ttmp = tmp.toUpperCase();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isJSON())\n\t\t\t\t\t\t\t\ttmp = '';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'base64':\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isBase64())\n\t\t\t\t\t\t\t\ttmp = '';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!tmp && type.def !== undefined)\n\t\t\t\t\t\ttmp = def ? type.def() : type.def;\n\n\t\t\t\t\titem[property] = self.$onprepare(property, tmp, undefined, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// boolean\n\t\t\t\tcase 4:\n\t\t\t\t\ttmp = val ? val.toString().toLowerCase() : null;\n\t\t\t\t\tif (type.def && (tmp == null || tmp === ''))\n\t\t\t\t\t\ttmp = def ? type.def() : type.def;\n\t\t\t\t\titem[property] = self.$onprepare(property, typeof(tmp) === 'string' ? !!BOOL[tmp] : tmp == null ? false : tmp, undefined, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// date\n\t\t\t\tcase 5:\n\n\t\t\t\t\ttmp = null;\n\n\t\t\t\t\tif (typeval === 'string') {\n\t\t\t\t\t\tif (val)\n\t\t\t\t\t\t\ttmp = val.trim().parseDate();\n\t\t\t\t\t} else if (typeval === 'number')\n\t\t\t\t\t\ttmp = new Date(val);\n\t\t\t\t\telse\n\t\t\t\t\t\ttmp = val;\n\n\t\t\t\t\tif (framework_utils.isDate(tmp))\n\t\t\t\t\t\ttmp = self.$onprepare(property, tmp, undefined, model, req);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (type.def !== undefined)\n\t\t\t\t\t\t\ttmp = def ? type.def() : type.def;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttmp = (defaults ? isUndefined(self.$ondefault(property, false, self.name), null) : null);\n\t\t\t\t\t}\n\n\t\t\t\t\titem[property] = tmp;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// object\n\t\t\t\tcase 6:\n\t\t\t\t\t// item[property] = self.$onprepare(property, model[property], undefined, model, req);\n\t\t\t\t\titem[property] = self.$onprepare(property, val, undefined, model, req);\n\t\t\t\t\tif (item[property] === undefined)\n\t\t\t\t\t\titem[property] = null;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// enum\n\t\t\t\tcase 8:\n\t\t\t\t\t// tmp = self.$onprepare(property, model[property], undefined, model, req);\n\t\t\t\t\ttmp = self.$onprepare(property, val, undefined, model, req);\n\t\t\t\t\tif (type.subtype === 'number' && typeof(tmp) === 'string')\n\t\t\t\t\t\ttmp = tmp.parseFloat(null);\n\t\t\t\t\titem[property] = tmp != null && type.raw.indexOf(tmp) !== -1 ? tmp : undefined;\n\t\t\t\t\tif (item[property] == null && type.def)\n\t\t\t\t\t\titem[property] = type.def;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// keyvalue\n\t\t\t\tcase 9:\n\t\t\t\t\t// tmp = self.$onprepare(property, model[property], undefined, model, req);\n\t\t\t\t\ttmp = self.$onprepare(property, val, undefined, model, req);\n\t\t\t\t\titem[property] = tmp != null ? type.raw[tmp] : undefined;\n\t\t\t\t\tif (item[property] == null && type.def)\n\t\t\t\t\t\titem[property] = type.def;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// schema\n\t\t\t\tcase 7:\n\n\t\t\t\t\tif (!val) {\n\t\t\t\t\t\tval = (type.def === undefined ? defaults ? isUndefined(self.$ondefault(property, false, self.name), null) : null : (def ? type.def() : type.def));\n\t\t\t\t\t\tif (val === null) {\n\t\t\t\t\t\t\titem[property] = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (val && typeof(val.$schema) === 'function') {\n\t\t\t\t\t\ttmp = val.$schema();\n\t\t\t\t\t\tif (tmp && tmp.name && tmp.name === type.raw) {\n\t\t\t\t\t\t\titem[property] = val;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tentity = GETSCHEMA(type.raw);\n\t\t\t\t\tif (entity) {\n\n\t\t\t\t\t\titem[property] = entity.prepare(val, undefined, req, verifications);\n\t\t\t\t\t\titem[property].$$parent = item;\n\t\t\t\t\t\titem[property].$$controller = req;\n\n\t\t\t\t\t\tif (entity.verifications)\n\t\t\t\t\t\t\tverifications.push({ model: item[property], entity: entity });\n\n\t\t\t\t\t\tdependencies && dependencies.push({ name: type.raw, value: self.$onprepare(property, item[property], undefined, model, req) });\n\t\t\t\t\t} else\n\t\t\t\t\t\titem[property] = null;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 10:\n\t\t\t\t\titem[property] = type.raw(val == null ? '' : val.toString());\n\t\t\t\t\tif (item[property] === undefined)\n\t\t\t\t\t\titem[property] = null;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// number: nullable\n\t\t\t\tcase 11:\n\t\t\t\t\titem[property] = self.$onprepare(property, typeval === 'number' ? val : typeval === 'string' ? parseNumber(val) : null, undefined, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// object: convertor\n\t\t\t\tcase 12:\n\t\t\t\t\titem[property] = self.$onprepare(property, val && typeval === 'object' && !(val instanceof Array) ? CONVERT(val, type.raw) : null, undefined, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// ARRAY:\n\t\tif (!(val instanceof Array)) {\n\t\t\titem[property] = (type.def === undefined ? defaults ? isUndefined(self.$ondefault(property, false, self.name), EMPTYARRAY) : [] : (def ? type.def() : type.def));\n\t\t\tcontinue;\n\t\t}\n\n\t\titem[property] = [];\n\t\tfor (var j = 0, sublength = val.length; j < sublength; j++) {\n\n\t\t\t// tmp = model[property][j];\n\t\t\ttmp = val[j];\n\t\t\ttypeval = typeof(tmp);\n\n\t\t\tswitch (type.type) {\n\t\t\t\tcase 0:\n\t\t\t\t\ttmp = self.$onprepare(property, tmp, j, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\ttmp = self.$onprepare(property, framework_utils.parseInt(tmp), j, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\ttmp = self.$onprepare(property, framework_utils.parseFloat(tmp), j, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\n\t\t\t\t\ttmp = tmp == null ? '' : autotrim(self, tmp.toString());\n\t\t\t\t\tif (type.length && tmp.length < tmp.length)\n\t\t\t\t\t\ttmp = tmp.substring(0, type.length);\n\n\t\t\t\t\tswitch (type.subtype) {\n\t\t\t\t\t\tcase 'uid':\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isUID())\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'url':\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isURL())\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'email':\n\t\t\t\t\t\t\ttmp = tmp.toLowerCase().replace(REGEXP_CLEAN_EMAIL, '');\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isEmail())\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'phone':\n\t\t\t\t\t\t\ttmp = tmp.replace(REGEXP_CLEAN_PHONE, '');\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isPhone())\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'capitalize':\n\t\t\t\t\t\t\ttmp = tmp.capitalize();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'capitalize2':\n\t\t\t\t\t\t\ttmp = tmp.capitalize(true);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'lowercase':\n\t\t\t\t\t\t\ttmp = tmp.toLowerCase();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'uppercase':\n\t\t\t\t\t\t\ttmp = tmp.toUpperCase();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isJSON())\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'base64':\n\t\t\t\t\t\t\tif (tmp && !type.required && !tmp.isBase64())\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp = self.$onprepare(property, tmp, j, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t\ttmp = tmp.toString().toLowerCase();\n\t\t\t\t\ttmp = self.$onprepare(property, BOOL[tmp], j, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5:\n\n\t\t\t\t\tif (typeval === 'string') {\n\t\t\t\t\t\tif (tmp)\n\t\t\t\t\t\t\ttmp = tmp.trim().parseDate();\n\t\t\t\t\t} else if (typeval === 'number')\n\t\t\t\t\t\ttmp = new Date(tmp);\n\n\t\t\t\t\tif (framework_utils.isDate(tmp))\n\t\t\t\t\t\ttmp = self.$onprepare(property, tmp, j, model, req);\n\t\t\t\t\telse\n\t\t\t\t\t\ttmp = undefined;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 6:\n\t\t\t\t\ttmp = self.$onprepare(property, tmp, j, model, req);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 7:\n\n\t\t\t\t\tentity = self.parent.collection[type.raw] || GETSCHEMA(type.raw);\n\n\t\t\t\t\tif (entity) {\n\t\t\t\t\t\ttmp = entity.prepare(tmp, dependencies, req, verifications);\n\t\t\t\t\t\ttmp.$$parent = item;\n\t\t\t\t\t\ttmp.$$controller = req;\n\t\t\t\t\t\tdependencies && dependencies.push({ name: type.raw, value: self.$onprepare(property, tmp, j, model, req) });\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Schema \"{0}\" not found'.format(type.raw));\n\n\t\t\t\t\ttmp = self.$onprepare(property, tmp, j, model, req);\n\n\t\t\t\t\tif (entity.verifications && tmp)\n\t\t\t\t\t\tverifications.push({ model: tmp, entity: entity });\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 11:\n\t\t\t\t\ttmp = self.$onprepare(property, typeval === 'number' ? tmp : typeval === 'string' ? parseNumber(tmp) : null, j, model, req);\n\t\t\t\t\tif (tmp == null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 12:\n\t\t\t\t\ttmp = self.$onprepare(property, tmp ? CONVERT(tmp, type.raw) : null, j, model, req);\n\t\t\t\t\tif (tmp == null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tmp !== undefined)\n\t\t\t\titem[property].push(tmp);\n\t\t}\n\t}\n\n\tif (self.fields_allow) {\n\t\tfor (var i = 0, length = self.fields_allow.length; i < length; i++) {\n\t\t\tvar name = self.fields_allow[i];\n\t\t\tvar val = model[name];\n\t\t\tif (val !== undefined) {\n\t\t\t\titem[name] = val;\n\t\t\t\tkeys && keys.push(name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (keys)\n\t\titem.$$keys = keys;\n\n\treturn item;\n};\n\nfunction parseNumber(str) {\n\tif (!str)\n\t\treturn null;\n\tif (str.indexOf(',') !== -1)\n\t\tstr = str.replace(',', '.');\n\tvar num = +str;\n\treturn isNaN(num) ? null : num;\n}\n\n/**\n * Transform an object\n * @param {String} name\n * @param {Object} model\n * @param {Object} options Custom options object, optional.\n * @param {Function(errorBuilder, output, model)} callback\n * @param {Boolean} skip Skips preparing and validation, optional.\n * @param {Object} controller Optional\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.transform = function(name, model, options, callback, skip, controller) {\n\treturn this.$execute('transform', name, model, options, callback, skip, controller);\n};\n\nSchemaBuilderEntityProto.transform2 = function(name, options, callback, controller) {\n\n\tif (typeof(options) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\t!callback && (callback = function(){});\n\treturn this.transform(name, this.create(), options, callback, true, controller);\n};\n\nSchemaBuilderEntityProto.$process = function(arg, model, type, name, builder, response, callback, controller) {\n\n\tvar self = this;\n\n\tif (arg.length > 1 || (response instanceof Error || response instanceof ErrorBuilder)) {\n\t\tif ((response instanceof Error || response instanceof ErrorBuilder || typeof(response) === 'string') && builder !== response)\n\t\t\tbuilder.push(response);\n\t\tresponse = arg[1];\n\t}\n\n\tvar has = builder.is;\n\thas && self.onError && self.onError(builder, model, type, name);\n\n\tif (response !== NoOp) {\n\t\tif (controller && response instanceof SchemaInstance && !response.$$controller)\n\t\t\tresponse.$$controller = controller;\n\t\tcallback(has ? builder : null, response === undefined ? model : response, model);\n\t} else\n\t\tcallback = null;\n\n\treturn self;\n};\n\nSchemaBuilderEntityProto.$process_hook = function(model, type, name, builder, result, callback) {\n\tvar self = this;\n\tvar has = builder.is;\n\thas && self.onError && self.onError(builder, model, type, name);\n\tcallback(has ? builder : null, model, result);\n\treturn self;\n};\n\n/**\n * Run a workflow\n * @param {String} name\n * @param {Object} model\n * @param {Object} options Custom options object, optional.\n * @param {Function(errorBuilder, output, model)} callback\n * @param {Boolean} skip Skips preparing and validation, optional.\n * @param {Object} controller Optional\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.workflow = function(name, model, options, callback, skip, controller) {\n\treturn this.$execute('workflow', name, model, options, callback, skip, controller);\n};\n\nSchemaBuilderEntityProto.workflow2 = function(name, options, callback, controller) {\n\n\tif (typeof(options) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\t!callback && (callback = function(){});\n\treturn this.workflow(name, this.create(), options, callback, true, controller);\n};\n\n/**\n * Run hooks\n * @param {String} name\n * @param {Object} model\n * @param {Object} helper A helper object, optional.\n * @param {Function(errorBuilder, output, model)} callback\n * @param {Boolean} skip Skips preparing and validation, optional.\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.hook = function(name, model, options, callback, skip, controller) {\n\n\tvar self = this;\n\n\tif (typeof(name) !== 'string') {\n\t\tcallback = options;\n\t\toptions = model;\n\t\tmodel = name;\n\t\tname = 'default';\n\t}\n\n\tif (typeof(callback) === 'boolean') {\n\t\tskip = callback;\n\t\tcallback = options;\n\t\toptions = undefined;\n\t} else if (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tif (typeof(callback) !== 'function')\n\t\tcallback = function(){};\n\n\tvar hook = self.hooks ? self.hooks[name] : undefined;\n\n\tif (!hook || !hook.length) {\n\t\tcallback(null, model, EMPTYARRAY);\n\t\treturn self;\n\t}\n\n\tif (controller instanceof SchemaOptions || controller instanceof OperationOptions)\n\t\tcontroller = controller.controller;\n\n\tif (model && !controller && model.$$controller)\n\t\tcontroller = model.$$controller;\n\n\tvar $type = 'hook';\n\n\tif (skip === true || model instanceof SchemaInstance) {\n\n\t\tvar builder = new ErrorBuilder();\n\t\tself.resourceName && builder.setResource(self.resourceName);\n\t\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\n\t\tvar output = [];\n\t\tvar $now;\n\n\t\tif (CONF.logger)\n\t\t\t$now = Date.now();\n\n\t\tasync_wait(hook, function(item, next) {\n\t\t\tif (item.fn.$newversion) {\n\n\t\t\t\tvar opt = new SchemaOptions(builder, model, options, function(result) {\n\t\t\t\t\toutput.push(result == undefined ? model : result);\n\t\t\t\t\tnext();\n\t\t\t\t}, controller, 'hook.' + name, self);\n\n\t\t\t\tif (self.middlewares && self.middlewares.length)\n\t\t\t\t\trunmiddleware(opt, self, item.fn);\n\t\t\t\telse\n\t\t\t\t\titem.fn.call(self, opt);\n\n\t\t\t} else\n\t\t\t\titem.fn.call(self, builder, model, options, function(result) {\n\t\t\t\t\toutput.push(result == undefined ? model : result);\n\t\t\t\t\tnext();\n\t\t\t\t}, controller, skip !== true);\n\t\t}, function() {\n\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\t\t\tself.$process_hook(model, $type, name, builder, output, callback);\n\t\t}, 0);\n\n\t\treturn self;\n\t}\n\n\tself.$prepare(model, function(err, model) {\n\n\t\tif (err) {\n\t\t\tcallback(err, model);\n\t\t\treturn;\n\t\t}\n\n\t\tvar builder = new ErrorBuilder();\n\t\tvar output = [];\n\t\tvar $now;\n\n\t\tself.resourceName && builder.setResource(self.resourceName);\n\t\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\n\t\tif (CONF.logger)\n\t\t\t$now = Date.now();\n\n\t\tasync_wait(hook, function(item, next, index) {\n\n\t\t\tif (!isGenerator(self, 'hook.' + name + '.' + index, item.fn)) {\n\t\t\t\tif (item.fn.$newversion) {\n\t\t\t\t\titem.fn.call(self, new SchemaOptions(builder, model, options, function(res) {\n\t\t\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\t\t\t\t\t\toutput.push(res === undefined ? model : res);\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}, controller, 'hook.' + name, self));\n\t\t\t\t} else {\n\t\t\t\t\titem.fn.call(self, builder, model, options, function(res) {\n\t\t\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\t\t\t\t\t\toutput.push(res === undefined ? model : res);\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}, controller, skip !== true);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallback.success = false;\n\n\t\t\tif (item.fn.$newversion) {\n\t\t\t\tvar opt = new SchemaOptions(builder, model, options, function(res) {\n\t\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\t\t\t\t\toutput.push(res == undefined ? model : res);\n\t\t\t\t\tnext();\n\t\t\t\t}, controller, 'hook.' + name, self);\n\n\t\t\t\tasync.call(self, item.fn)(function(err) {\n\t\t\t\t\tif (!err)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (builder !== err)\n\t\t\t\t\t\tbuilder.push(err);\n\t\t\t\t\tnext();\n\t\t\t\t}, opt);\n\n\t\t\t} else {\n\t\t\t\tasync.call(self, item.fn)(function(err) {\n\t\t\t\t\tif (!err)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (builder !== err)\n\t\t\t\t\t\tbuilder.push(err);\n\t\t\t\t\tnext();\n\t\t\t\t}, builder, model, options, function(res) {\n\t\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\t\t\t\t\toutput.push(res == undefined ? model : res);\n\t\t\t\t\tnext();\n\t\t\t\t}, controller, skip !== true);\n\t\t\t}\n\n\t\t}, () => self.$process_hook(model, $type, name, builder, output, callback), 0);\n\t}, controller ? controller.req : null);\n\n\treturn self;\n};\n\nSchemaBuilderEntityProto.hook2 = function(name, options, callback, controller) {\n\n\tif (typeof(options) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tif (!callback)\n\t\tcallback = function(){};\n\n\treturn this.hook(name, this.create(), options, callback, true, controller);\n};\n\nSchemaBuilderEntityProto.$execute = function(type, name, model, options, callback, skip, controller) {\n\tvar self = this;\n\n\tif (typeof(name) !== 'string') {\n\t\tcallback = options;\n\t\toptions = model;\n\t\tmodel = name;\n\t\tname = 'default';\n\t}\n\n\tif (typeof(callback) === 'boolean') {\n\t\tskip = callback;\n\t\tcallback = options;\n\t\toptions = undefined;\n\t} else if (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tif (typeof(callback) !== 'function')\n\t\tcallback = function(){};\n\n\tvar ref = self[type + 's'];\n\tvar item = ref ? ref[name] : undefined;\n\tvar $now;\n\n\tif (!item) {\n\t\tcallback(new ErrorBuilder().push('', type.capitalize() + ' \"{0}\" not found.'.format(name)));\n\t\treturn self;\n\t}\n\n\tif (CONF.logger)\n\t\t$now = Date.now();\n\n\tif (controller instanceof SchemaOptions || controller instanceof OperationOptions)\n\t\tcontroller = controller.controller;\n\n\tif (model && !controller && model.$$controller)\n\t\tcontroller = model.$$controller;\n\n\tvar opfilter = self.meta[type + 'filter#' + name];\n\tif (opfilter && controller) {\n\t\tcontroller.$filterschema = opfilter;\n\t\tcontroller.$filter = null;\n\t}\n\n\tvar key = type + '.' + name;\n\n\tif (skip === true || model instanceof SchemaInstance) {\n\t\tvar builder = new ErrorBuilder();\n\t\tself.resourceName && builder.setResource(self.resourceName);\n\t\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\t\tif (item.$newversion) {\n\n\t\t\tvar opt = new SchemaOptions(builder, model, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName(type, name), controller, $now);\n\t\t\t\tself.$process(arguments, model, type, name, builder, res, callback, controller);\n\t\t\t}, controller, key, self);\n\n\t\t\tif (self.middlewares && self.middlewares.length)\n\t\t\t\trunmiddleware(opt, self, item);\n\t\t\telse\n\t\t\t\titem.call(self, opt);\n\n\t\t} else\n\t\t\titem.call(self, builder, model, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName(type, name), controller, $now);\n\t\t\t\tself.$process(arguments, model, type, name, builder, res, callback, controller);\n\t\t\t}, controller, skip !== true);\n\t\treturn self;\n\t}\n\n\tself.$prepare(model, function(err, model) {\n\n\t\tif (err) {\n\t\t\tcallback(err, model);\n\t\t\treturn;\n\t\t}\n\n\t\tif (controller && model instanceof SchemaInstance && !model.$$controller)\n\t\t\tmodel.$$controller = controller;\n\n\t\tvar builder = new ErrorBuilder();\n\n\t\tself.resourceName && builder.setResource(self.resourceName);\n\t\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\n\t\tvar key = type + '.' + name;\n\n\t\tif (!isGenerator(self, key, item)) {\n\t\t\tif (item.$newversion) {\n\t\t\t\tvar opt = new SchemaOptions(builder, model, options, function(res) {\n\t\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName(type, name), controller, $now);\n\t\t\t\t\tself.$process(arguments, model, type, name, builder, res, callback, controller);\n\t\t\t\t}, controller, key, self);\n\n\t\t\t\tif (self.middlewares && self.middlewares.length)\n\t\t\t\t\trunmiddleware(opt, self, item);\n\t\t\t\telse\n\t\t\t\t\titem.call(self, opt);\n\n\t\t\t} else\n\t\t\t\titem.call(self, builder, model, options, function(res) {\n\t\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName(type, name), controller, $now);\n\t\t\t\t\tself.$process(arguments, model, type, name, builder, res, callback, controller);\n\t\t\t\t}, controller);\n\t\t\treturn;\n\t\t}\n\n\t\tcallback.success = false;\n\n\t\tvar onError = function(err) {\n\t\t\tif (!err || callback.success)\n\t\t\t\treturn;\n\t\t\tcallback.success = true;\n\t\t\tif (builder !== err)\n\t\t\t\tbuilder.push(err);\n\t\t\tself.onError && self.onError(builder, model, type, name);\n\t\t\tcallback(builder);\n\t\t};\n\n\t\tvar onCallback = function(res) {\n\n\t\t\tCONF.logger && F.ilogger(self.getLoggerName(type, name), controller, $now);\n\n\t\t\tif (callback.success)\n\t\t\t\treturn;\n\n\t\t\tif (arguments.length === 2 || (res instanceof Error || res instanceof ErrorBuilder)) {\n\t\t\t\tif ((res instanceof Error || res instanceof ErrorBuilder) && builder !== res)\n\t\t\t\t\tbuilder.push(res);\n\t\t\t\tres = arguments[1];\n\t\t\t}\n\n\t\t\tvar has = builder.is;\n\t\t\thas && self.onError && self.onError(builder, model, type, name);\n\t\t\tcallback.success = true;\n\t\t\tcallback(has ? builder : null, res === undefined ? model : res);\n\t\t};\n\n\t\tif (item.$newversion) {\n\t\t\tvar opt = new SchemaOptions(builder, model, options, onCallback, controller, key, self);\n\t\t\tif (self.middlewares && self.middlewares.length)\n\t\t\t\trunmiddleware(opt, self, () => async.call(self, item)(onError, opt));\n\t\t\telse\n\t\t\t\tasync.call(self, item)(onError, opt);\n\t\t} else\n\t\t\tasync.call(self, item)(onError, builder, model, options, onCallback, controller);\n\t}, controller ? controller.req : null);\n\n\treturn self;\n};\n\nSchemaBuilderEntityProto.getLoggerName = function(type, name) {\n\treturn this.name + '.' + type + (name ? ('(\\'' + name + '\\')') : '()');\n};\n\n/**\n * Run a workflow\n * @param {String} name\n * @param {Object} model\n * @param {Object} options Custom options object, optional.\n * @param {Function(errorBuilder, output, model)} callback\n * @param {Boolean} skip Skips preparing and validation, optional.\n * @param {Object} controller Optional\n * @return {SchemaBuilderEntity}\n */\nSchemaBuilderEntityProto.operation = function(name, model, options, callback, skip, controller) {\n\n\tvar self = this;\n\n\tvar th = typeof(options);\n\tvar tc = typeof(callback);\n\n\tif (tc === 'undefined') {\n\t\tif (th === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = model;\n\t\t\tmodel = undefined;\n\t\t} else if (th === 'undefined') {\n\t\t\toptions = model;\n\t\t\tmodel = undefined;\n\t\t}\n\t} else if (th === 'undefined') {\n\t\toptions = model;\n\t\tmodel = undefined;\n\t} else if (tc === 'boolean') {\n\t\tskip = callback;\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tif (typeof(callback) !== 'function')\n\t\tcallback = function(){};\n\n\tvar operation = self.operations ? self.operations[name] : undefined;\n\n\tif (!operation) {\n\t\tcallback(new ErrorBuilder().push('', 'Operation \"{0}\" not found.'.format(name)));\n\t\treturn self;\n\t}\n\n\tvar builder = new ErrorBuilder();\n\tvar $type = 'operation';\n\tvar $now;\n\n\tself.resourceName && builder.setResource(self.resourceName);\n\tself.resourcePrefix && builder.setPrefix(self.resourcePrefix);\n\n\tif (controller instanceof SchemaOptions || controller instanceof OperationOptions)\n\t\tcontroller = controller.controller;\n\n\tif (model && !controller && model.$$controller)\n\t\tcontroller = model.$$controller;\n\n\tif (CONF.logger)\n\t\t$now = Date.now();\n\n\tvar key = $type + '.' + name;\n\n\tif (!isGenerator(self, key, operation)) {\n\t\tif (operation.$newversion) {\n\t\t\toperation.call(self, new SchemaOptions(builder, model, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\t\t\t\tself.$process(arguments, model, $type, name, builder, res, callback, controller);\n\t\t\t}, controller, key, self));\n\t\t} else\n\t\t\toperation.call(self, builder, model, options, function(res) {\n\t\t\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\t\t\t\tself.$process(arguments, model, $type, name, builder, res, callback, controller);\n\t\t\t}, controller, skip !== true);\n\t\treturn self;\n\t}\n\n\tcallback.success = false;\n\n\tvar onError = function(err) {\n\t\tif (!err || callback.success)\n\t\t\treturn;\n\t\tcallback.success = true;\n\t\tif (builder !== err)\n\t\t\tbuilder.push(err);\n\t\tself.onError && self.onError(builder, model, $type, name);\n\t\tcallback(builder);\n\t};\n\n\tvar onCallback = function(res) {\n\n\t\tCONF.logger && F.ilogger(self.getLoggerName($type, name), controller, $now);\n\n\t\tif (callback.success)\n\t\t\treturn;\n\n\t\tif (arguments.length === 2 || (res instanceof Error || res instanceof ErrorBuilder)) {\n\t\t\tif ((res instanceof Error || res instanceof ErrorBuilder) && builder !== res)\n\t\t\t\tbuilder.push(res);\n\t\t\tres = arguments[1];\n\t\t}\n\n\t\tvar has = builder.is;\n\t\thas && self.onError && self.onError(builder, model, $type, name);\n\t\tcallback.success = true;\n\t\tcallback(has ? builder : null, res);\n\t};\n\n\tif (operation.$newversion)\n\t\tasync.call(self, operation)(onError, new SchemaOptions(builder, model, options, onCallback, controller, key, self));\n\telse\n\t\tasync.call(self, operation)(onError, builder, model, options, onCallback, controller, skip !== true);\n\n\treturn self;\n};\n\nSchemaBuilderEntityProto.operation2 = function(name, options, callback, controller) {\n\n\tif (typeof(options) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\t!callback && (callback = function(){});\n\treturn this.operation(name, this.create(), options, callback, true, controller);\n};\n\n/**\n * Clean model (remove state of all schemas in model).\n * @param {Object} m Model.\n * @param {Boolean} isCopied Internal argument.\n * @return {Object}\n */\nSchemaBuilderEntityProto.clean = function(m) {\n\treturn clone(m);\n};\n\n// For async operations, because SUCCESS() returns singleton instance everytime\nfunction copy(obj) {\n\treturn F.isSuccess(obj) ? { success: obj.success, value: obj.value } : obj;\n}\n\nfunction clone(obj) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type !== 'object' || obj instanceof Date)\n\t\treturn obj;\n\n\tvar length;\n\tvar o;\n\n\tif (obj instanceof Array) {\n\n\t\tlength = obj.length;\n\t\to = new Array(length);\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\ttype = typeof(obj[i]);\n\t\t\tif (type !== 'object' || obj[i] instanceof Date) {\n\t\t\t\tif (type !== 'function')\n\t\t\t\t\to[i] = obj[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (obj[i] instanceof SchemaInstance)\n\t\t\t\to[i] = obj[i].$clean();\n\t\t\telse\n\t\t\t\to[i] = clone(obj[i]);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\to = {};\n\n\tfor (var m in obj) {\n\n\t\tif (SKIP[m])\n\t\t\tcontinue;\n\n\t\tvar val = obj[m];\n\n\t\tif (val instanceof Array) {\n\t\t\to[m] = clone(val);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (val instanceof SchemaInstance) {\n\t\t\to[m] = val.$clean();\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar type = typeof(val);\n\t\tif (type !== 'object' || val instanceof Date) {\n\t\t\tif (type !== 'function')\n\t\t\t\to[m] = val;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Because here can be a problem with MongoDB.ObjectID\n\t\t// I assume plain/simple model\n\t\tif (val && val.constructor === Object)\n\t\t\to[m] = clone(obj[m]);\n\t\telse\n\t\t\to[m] = val;\n\t}\n\n\treturn o;\n}\n\n/**\n * Returns prototype of instances\n * @returns {Object}\n */\nSchemaBuilderEntityProto.instancePrototype = function() {\n\treturn this.CurrentSchemaInstance.prototype;\n};\n\nSchemaBuilderEntityProto.cl = function(name, value) {\n\tvar o = this.schema[name];\n\tif (o && (o.type === 8 || o.type === 9)) {\n\t\tif (value)\n\t\t\to.raw = value;\n\t\treturn o.raw;\n\t}\n};\n\nSchemaBuilderEntityProto.props = function() {\n\n\tvar self = this;\n\tvar keys = Object.keys(self.schema);\n\tvar prop = {};\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar meta = self.schema[key];\n\t\tvar obj = {};\n\n\t\tif (meta.required)\n\t\t\tobj.required = meta.required;\n\n\t\tif (meta.length)\n\t\t\tobj.length = meta.length;\n\n\t\tif (meta.isArray)\n\t\t\tmeta.array = true;\n\n\t\tswitch (meta.type) {\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\tcase 11:\n\t\t\t\tobj.type = 'number';\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tobj.type = 'string';\n\t\t\t\tswitch (meta.subtype) {\n\t\t\t\t\tcase 'uid':\n\t\t\t\t\t\tobj.type = 'uid';\n\t\t\t\t\t\tdelete obj.length;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tobj.subtype = meta.subtype;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tobj.type = 'boolean';\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tobj.type = 'date';\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tobj.type = 'schema';\n\t\t\t\tobj.name = meta.raw;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tobj.type = 'enum';\n\t\t\t\tobj.items = meta.raw;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\t// obj.type = 'keyvalue';\n\t\t\t\tobj.type = 'enum'; // because it returns keys only\n\t\t\t\tobj.items = Object.keys(meta.raw);\n\t\t\t\tbreak;\n\t\t\t// case 6:\n\t\t\t// case 0:\n\t\t\t// case 10:\n\t\t\tdefault:\n\t\t\t\tobj.type = 'object';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprop[key] = obj;\n\t}\n\n\treturn prop;\n};\n\n/**\n * SchemaInstance\n * @constructor\n */\nfunction SchemaInstance() {\n}\n\n/**\n * @type {SchemaBuilderEntity}\n */\nSchemaInstance.prototype.$$schema = null;\n\nSchemaInstance.prototype.$async = function(callback, index) {\n\tvar self = this;\n\t!callback && (callback = function(){});\n\n\tvar a = self.$$async = {};\n\n\ta.callback = callback;\n\ta.index = index;\n\ta.indexer = 0;\n\ta.response = [];\n\ta.fn = [];\n\ta.op = [];\n\ta.pending = 0;\n\n\ta.next = function() {\n\t\ta.running = true;\n\t\tvar fn = a.fn ? a.fn.shift() : null;\n\t\tif (fn) {\n\t\t\ta.pending++;\n\t\t\tfn.fn(a.done, a.indexer++);\n\t\t\tfn.async && a.next();\n\t\t}\n\t};\n\n\ta.done = function() {\n\t\ta.running = false;\n\t\ta.pending--;\n\t\tif (a.fn.length)\n\t\t\tsetImmediate(a.next);\n\t\telse if (!a.pending && a.callback)\n\t\t\ta.callback(null, a.index != null ? a.response[a.index] : a.response);\n\t};\n\n\tsetImmediate(a.next);\n\treturn self;\n};\n\nfunction async_wait(arr, onItem, onCallback, index) {\n\tvar item = arr[index];\n\tif (item)\n\t\tonItem(item, () => async_wait(arr, onItem, onCallback, index + 1), index);\n\telse\n\t\tonCallback();\n}\n\nObject.defineProperty(SchemaInstance.prototype, '$parent', {\n\tget: function() {\n\t\treturn this.$$parent;\n\t},\n\tset: function(value) {\n\t\tthis.$$parent = value;\n\t}\n});\n\nSchemaInstance.prototype.$response = function(index) {\n\tvar a = this.$$async;\n\tif (a) {\n\n\t\tif (index == null)\n\t\t\treturn a.response;\n\n\t\tif (typeof(index) === 'string') {\n\n\t\t\tif (index === 'prev')\n\t\t\t\treturn a.response[a.response.length - 1];\n\n\t\t\tindex = a.op.indexOf(index);\n\n\t\t\tif (index !== -1)\n\t\t\t\treturn a.response[index];\n\n\t\t} else\n\t\t\treturn a.response[index];\n\t}\n};\n\nSchemaInstance.prototype.$repository = function(name, value) {\n\n\tif (this.$$repository === undefined) {\n\t\tif (value === undefined)\n\t\t\treturn undefined;\n\t\tthis.$$repository = {};\n\t}\n\n\tif (value !== undefined) {\n\t\tthis.$$repository[name] = value;\n\t\treturn value;\n\t}\n\n\treturn this.$$repository[name];\n};\n\nSchemaInstance.prototype.$index = function(index) {\n\tvar a = this.$$async;\n\tif (a) {\n\t\tif (typeof(index) === 'string')\n\t\t\ta.index = (a.index || 0).add(index);\n\t\ta.index = index;\n\t}\n\treturn this;\n};\n\nSchemaInstance.prototype.$callback = function(callback) {\n\tvar a = this.$$async;\n\tif (a)\n\t\ta.callback = callback;\n\treturn this;\n};\n\nSchemaInstance.prototype.$output = function() {\n\tvar a = this.$$async;\n\tif (a)\n\t\ta.index = true;\n\treturn this;\n};\n\nSchemaInstance.prototype.$stop = function() {\n\tthis.async.length = 0;\n\treturn this;\n};\n\nconst PUSHTYPE1 = { save: 1, insert: 1, update: 1, patch: 1 };\nconst PUSHTYPE2 = { query: 1, get: 1, read: 1, remove: 1 };\n\nSchemaInstance.prototype.$push = function(type, name, helper, first, async, callback) {\n\n\tvar self = this;\n\tvar fn;\n\n\tif (PUSHTYPE1[type]) {\n\t\tfn = function(next, indexer) {\n\t\t\tself.$$schema[type](self, helper, function(err, result) {\n\t\t\t\tvar a = self.$$async;\n\t\t\t\ta.response && (a.response[indexer] = err ? null : copy(result));\n\t\t\t\tif (a.index === true)\n\t\t\t\t\ta.index = indexer;\n\t\t\t\tcallback && callback(err, a.response[indexer]);\n\t\t\t\tif (!err)\n\t\t\t\t\treturn next();\n\t\t\t\tnext = null;\n\t\t\t\ta.callback(err, a.response);\n\t\t\t}, self.$$controller);\n\t\t};\n\n\t} else if (PUSHTYPE2[type]) {\n\t\tfn = function(next, indexer) {\n\t\t\tself.$$schema[type](helper, function(err, result) {\n\t\t\t\tvar a = self.$$async;\n\t\t\t\ta.response && (a.response[indexer] = err ? null : copy(result));\n\t\t\t\tif (a.index === true)\n\t\t\t\t\ta.index = indexer;\n\t\t\t\tcallback && callback(err, a.response[indexer]);\n\t\t\t\tif (!err)\n\t\t\t\t\treturn next();\n\t\t\t\tnext = null;\n\t\t\t\ta.callback(err, a.response);\n\t\t\t}, self.$$controller);\n\t\t};\n\t} else {\n\t\tfn = function(next, indexer) {\n\t\t\tself.$$schema[type](name, self, helper, function(err, result) {\n\t\t\t\tvar a = self.$$async;\n\t\t\t\ta.response && (a.response[indexer] = err ? null : copy(result));\n\t\t\t\tif (a.index === true)\n\t\t\t\t\ta.index = indexer;\n\t\t\t\tcallback && callback(err, a.response[indexer]);\n\t\t\t\tif (!err)\n\t\t\t\t\treturn next();\n\t\t\t\tnext = null;\n\t\t\t\ta.callback(err, a.response);\n\t\t\t}, self.$$controller);\n\t\t};\n\t}\n\n\tvar a = self.$$async;\n\tvar obj = { fn: fn, async: async, index: a.length };\n\tvar key = type === 'workflow' || type === 'transform' || type === 'operation' || type === 'hook' ? (type + '.' + name) : type;\n\n\tif (first) {\n\t\ta.fn.unshift(obj);\n\t\ta.op.unshift(key);\n\t} else {\n\t\ta.fn.push(obj);\n\t\ta.op.push(key);\n\t}\n\n\treturn self;\n};\n\nSchemaInstance.prototype.$next = function(type, name, helper, async) {\n\treturn this.$push(type, name, helper, true, async);\n};\n\nSchemaInstance.prototype.$exec = function(name, helper, callback) {\n\n\tif (typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = undefined;\n\t}\n\n\tvar group = this.$$schema.parent.name;\n\tvar key = group !== 'default' ? group + '/' + this.$$schema.name : this.$$schema.name;\n\tvar workflow = F.workflows[key + '#' + name] || F.workflows[name];\n\n\tif (workflow)\n\t\tworkflow(this, helper, callback || NOOP);\n\telse\n\t\tcallback && callback(new ErrorBuilder().push('Workflow \"' + name + '\" not found in workflows.'));\n\n\treturn this;\n};\n\nSchemaInstance.prototype.$controller = function(controller) {\n\tthis.$$controller = controller;\n\treturn this;\n};\n\nSchemaInstance.prototype.$save = function(helper, callback, async) {\n\n\tif (this.$$async && !this.$$async.running) {\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\n\t\tthis.$push('save', null, helper, null, async, callback);\n\n\t} else\n\t\tthis.$$schema.save(this, helper, callback, this.$$controller);\n\treturn this;\n};\n\nSchemaInstance.prototype.$insert = function(helper, callback, async) {\n\n\tif (this.$$async && !this.$$async.running) {\n\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\n\t\tthis.$push('insert', null, helper, null, async, callback);\n\n\t} else\n\t\tthis.$$schema.insert(this, helper, callback, this.$$controller);\n\treturn this;\n};\n\nSchemaInstance.prototype.$update = function(helper, callback, async) {\n\tif (this.$$async && !this.$$async.running) {\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\t\tthis.$push('update', null, helper, null, async, callback);\n\t} else\n\t\tthis.$$schema.update(this, helper, callback, this.$$controller);\n\treturn this;\n};\n\nSchemaInstance.prototype.$patch = function(helper, callback, async) {\n\tif (this.$$async && !this.$$async.running) {\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\t\tthis.$push('patch', null, helper, null, async, callback);\n\t} else\n\t\tthis.$$schema.patch(this, helper, callback, this.$$controller);\n\treturn this;\n};\n\nSchemaInstance.prototype.$query = function(helper, callback, async) {\n\n\tif (this.$$async && !this.$$async.running) {\n\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\n\t\tthis.$push('query', null, helper, null, async, callback);\n\t} else\n\t\tthis.$$schema.query(this, helper, callback, this.$$controller);\n\n\treturn this;\n};\n\nSchemaInstance.prototype.$read = SchemaInstance.prototype.$get = function(helper, callback, async) {\n\n\tif (this.$$async && !this.$$async.running) {\n\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\n\t\tthis.$push('get', null, helper, null, async, callback);\n\t} else\n\t\tthis.$$schema.get(this, helper, callback, this.$$controller);\n\n\treturn this;\n};\n\nSchemaInstance.prototype.$delete = SchemaInstance.prototype.$remove = function(helper, callback, async) {\n\n\tif (this.$$async && !this.$$async.running) {\n\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\n\t\tthis.$push('remove', null, helper, null, async, callback);\n\n\t} else\n\t\tthis.$$schema.remove(helper, callback, this.$$controller);\n\n\treturn this;\n};\n\nSchemaInstance.prototype.$default = function() {\n\treturn this.$$schema.default();\n};\n\nSchemaInstance.prototype.$destroy = function() {\n\treturn this.$$schema.destroy();\n};\n\nSchemaInstance.prototype.$transform = function(name, helper, callback, async) {\n\n\tif (this.$$async && !this.$$async.running) {\n\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\n\t\tthis.$push('transform', name, helper, null, async, callback);\n\n\t} else\n\t\tthis.$$schema.transform(name, this, helper, callback, undefined, this.$$controller);\n\n\treturn this;\n};\n\nSchemaInstance.prototype.$workflow = function(name, helper, callback, async) {\n\n\tif (this.$$async && !this.$$async.running) {\n\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\n\t\tthis.$push('workflow', name, helper, null, async, callback);\n\n\t} else\n\t\tthis.$$schema.workflow(name, this, helper, callback, undefined, this.$$controller);\n\n\treturn this;\n};\n\nSchemaInstance.prototype.$hook = function(name, helper, callback, async) {\n\n\tif (this.$$async && !this.$$async.running) {\n\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\n\t\tthis.$push('hook', name, helper, null, async, callback);\n\n\t} else\n\t\tthis.$$schema.hook(name, this, helper, callback, undefined, this.$$controller);\n\n\treturn this;\n};\n\nSchemaInstance.prototype.$operation = function(name, helper, callback, async) {\n\n\tif (this.$$async && !this.$$async.running) {\n\n\t\tif (typeof(helper) === 'function') {\n\t\t\tasync = callback;\n\t\t\tcallback = helper;\n\t\t\thelper = null;\n\t\t} else if (callback === true) {\n\t\t\tvar a = async;\n\t\t\tasync = true;\n\t\t\tcallback = a;\n\t\t}\n\n\t\tthis.$push('operation', name, helper, null, async, callback);\n\t} else\n\t\tthis.$$schema.operation(name, this, helper, callback, undefined, this.$$controller);\n\n\treturn this;\n};\n\nSchemaInstance.prototype.$clean = SchemaInstance.prototype.$plain = function() {\n\treturn this.$$schema.clean(this);\n};\n\nSchemaInstance.prototype.$clone = function() {\n\treturn framework_utils.extend(new this.$$schema.CurrentSchemaInstance(), this, true);\n};\n\nSchemaInstance.prototype.$prepare = function() {\n\treturn this.$$schema.prepare(this);\n};\n\nSchemaInstance.prototype.$schema = function() {\n\treturn this.$$schema;\n};\n\nSchemaInstance.prototype.$validate = function(resourcePrefix, resourceName, builder) {\n\treturn this.$$schema.validate(this, resourcePrefix, resourceName, builder);\n};\n\nSchemaInstance.prototype.$constant = function(name) {\n\treturn this.$$schema.constant(name);\n};\n\n/**\n * ErrorBuilder\n * @class\n * @classdesc Object validation.\n * @param {ErrorBuilderOnResource} onResource Resource handler.\n * @property {Number} count Count of errors.\n */\nfunction ErrorBuilder(onResource) {\n\n\tthis.items = [];\n\tthis.transformName = transforms.error_default;\n\tthis.onResource = onResource;\n\tthis.resourceName = CONF.default_errorbuilder_resource_name;\n\tthis.resourcePrefix = CONF.default_errorbuilder_resource_prefix || '';\n\tthis.isResourceCustom = false;\n\tthis.count = 0;\n\tthis.replacer = [];\n\tthis.isPrepared = false;\n\tthis.contentType = 'application/json';\n\tthis.status = CONF.default_errorbuilder_status || 200;\n\n\t// Hidden: when the .push() contains a classic Error instance\n\t// this.unexpected;\n\n\t// A default path for .push()\n\t// this.path;\n\n\t!onResource && this._resource();\n}\n\n/**\n * @callback ErrorBuilderOnResource\n * @param {String} name Filename of resource.\n * @param {String} key Resource key.\n * @return {String}\n */\n\n/**\n * UrlBuilder\n * @class\n * @classdesc CRUD parameters in URL.\n */\nfunction UrlBuilder() {\n\tthis.builder = {};\n}\n\nexports.isSchema = function(obj) {\n\treturn obj instanceof SchemaInstance;\n};\n\nglobal.EACHSCHEMA = exports.eachschema = function(group, fn) {\n\n\tif (fn === undefined) {\n\t\tfn = group;\n\t\tgroup = undefined;\n\t}\n\n\tvar groups = group ? [group] : Object.keys(schemas);\n\tfor (var i = 0, length = groups.length; i < length; i++) {\n\t\tvar schema = schemas[groups[i]];\n\t\tif (!schema)\n\t\t\tcontinue;\n\t\tvar collection = Object.keys(schema.collection);\n\t\tfor (var j = 0, jl = collection.length; j < jl; j++)\n\t\t\tfn(schema.name, schema.collection[collection[j]].name, schema.collection[collection[j]]);\n\t}\n};\n\nglobal.$$$ = global.GETSCHEMA = exports.getschema = function(group, name, fn, timeout) {\n\n\tif (!name || typeof(name) === 'function') {\n\t\ttimeout = fn;\n\t\tfn = name;\n\t} else\n\t\tgroup = group + '/' + name;\n\n\tif (schemacache[group])\n\t\tgroup = schemacache[group];\n\telse {\n\t\tif (group.indexOf('/') === -1)\n\t\t\tgroup = DEFAULT_SCHEMA + '/' + group;\n\t\tgroup = schemacache[group] = group.toLowerCase();\n\t}\n\n\tif (fn)\n\t\tframework_utils.wait(() => !!schemasall[group], err => fn(err, schemasall[group]), timeout || 20000);\n\telse\n\t\treturn schemasall[group];\n};\n\nexports.findschema = function(groupname) {\n\treturn schemasall[groupname.toLowerCase()];\n};\n\nexports.newschema = function(group, name) {\n\n\tif (!group)\n\t\tgroup = DEFAULT_SCHEMA;\n\n\tif (!schemas[group])\n\t\tschemas[group] = new SchemaBuilder(group);\n\n\tvar o = schemas[group].create(name);\n\tvar key = group + '/' + name;\n\n\to.owner = F.$owner();\n\tschemasall[key.toLowerCase()] = o;\n\n\treturn o;\n};\n\n/**\n * Remove a schema\n * @param {String} group Optional\n * @param {String} name\n */\nexports.remove = function(group, name) {\n\tif (name) {\n\n\t\tvar g = schemas[group || DEFAULT_SCHEMA];\n\t\tg && g.remove(name);\n\t\tvar key = ((group || DEFAULT_SCHEMA) + '/' + name).toLowerCase();\n\t\tdelete schemasall[key];\n\n\t} else {\n\n\t\tdelete schemas[group];\n\n\t\tvar lower = group.toLowerCase();\n\n\t\tObject.keys(schemasall).forEach(function(key) {\n\t\t\tif (key.substring(0, group.length) === lower)\n\t\t\t\tdelete schemasall[key];\n\t\t});\n\t}\n};\n\nglobal.EACHOPERATION = function(fn) {\n\tvar keys = Object.keys(operations);\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\tfn(keys[i]);\n};\n\n/**\n * Check if property value is joined to other class\n * @private\n * @param {String} value Property value from Schema definition.\n * @return {Boolean}\n */\nexports.isJoin = function(collection, value) {\n\tif (!value)\n\t\treturn false;\n\tif (value[0] === '[')\n\t\treturn true;\n\tif (collection === undefined)\n\t\treturn false;\n\treturn collection[value] !== undefined;\n};\n\n/**\n * Create validation\n * @param {String} name Schema name.\n * @param {Function|Array} fn Validator Handler or Property names as array for validating.\n * @param {String|Array} properties Valid only these properties, optional.\n * @return {Function|Array}\n */\nexports.validation = function(name, properties, fn) {\n\n\tif (schemas[DEFAULT_SCHEMA] === undefined)\n\t\treturn EMPTYARRAY;\n\n\tvar schema = schemas[DEFAULT_SCHEMA].get(name);\n\tif (schema === undefined)\n\t\treturn EMPTYARRAY;\n\n\tif (fn instanceof Array && typeof(properties) === 'function') {\n\t\tvar tmp = fn;\n\t\tfn = properties;\n\t\tproperties = tmp;\n\t}\n\n\tif (typeof(fn) === 'function') {\n\t\tschema.onValidate = fn;\n\t\tif (properties)\n\t\t\tschema.properties = properties;\n\t\telse\n\t\t\tschema.properties = Object.keys(schema.schema);\n\t\treturn true;\n\t}\n\n\tif (!fn) {\n\t\tvar validator = schema.properties;\n\t\tif (validator === undefined)\n\t\t\treturn Object.keys(schema.schema);\n\t\treturn validator || [];\n\t}\n\n\tschema.onValidate = fn;\n\treturn fn;\n};\n\n/**\n * Validate model\n * @param {String} name Schema name.\n * @param {Object} model Object for validating.\n * @return {ErrorBuilder}\n */\nexports.validate = function(name, model, resourcePrefix, resourceName) {\n\tvar schema = schemas[DEFAULT_SCHEMA];\n\tif (schema === undefined)\n\t\treturn null;\n\tschema = schema.get(name);\n\tmodel = schema.prepare(model);\n\treturn schema === undefined ? null : schema.validate(model, resourcePrefix, resourceName);\n};\n\n/**\n * Create default object according to schema\n * @param  {String} name Schema name.\n * @return {Object}\n */\nexports.create = function(name) {\n\treturn exports.defaults(name);\n};\n\n/**\n * Create default object according to schema\n * @param  {String} name Schema name.\n * @return {Object}\n */\nexports.defaults = function(name) {\n\tif (schemas[DEFAULT_SCHEMA] === undefined)\n\t\treturn null;\n\tvar schema = schemas[DEFAULT_SCHEMA].get(name);\n\treturn schema === undefined ? null : schema.default();\n};\n\n/**\n * Prepare object according to schema\n * @param {String} name Schema name.\n * @param {Object} model Object to prepare.\n * @return {Object} Prepared object.\n */\nexports.prepare = function(name, model) {\n\tif (schemas[DEFAULT_SCHEMA] === undefined)\n\t\treturn null;\n\tvar schema = schemas[DEFAULT_SCHEMA].get(name);\n\treturn schema === undefined ? null : schema.prepare(model);\n};\n\nfunction isUndefined(value, def) {\n\treturn value === undefined ? (def === EMPTYARRAY ? [] : def) : value;\n}\n\n// ======================================================\n// PROTOTYPES\n// ======================================================\n\nErrorBuilder.prototype = {\n\n\tget errors() {\n\t\tvar self = this;\n\t\t!self.isPrepared && self.prepare();\n\t\treturn self._transform();\n\t},\n\n\tget error() {\n\t\tvar self = this;\n\t\t!self.isPrepared && self.prepare();\n\t\treturn self._transform();\n\t},\n\n\tget is() {\n\t\treturn this.items.length > 0;\n\t},\n\n\tget length() {\n\t\treturn this.items.length;\n\t}\n};\n\n/**\n * Resource setting\n * @param {String} name Resource name.\n * @param {String} prefix Resource prefix.\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype.resource = function(name, prefix) {\n\tvar self = this;\n\tself.isResourceCustom = true;\n\tself.resourceName = name;\n\tself.resourcePrefix = prefix || '';\n\treturn self._resource();\n};\n\nErrorBuilder.prototype.setContentType = function(type) {\n\tthis.contentType = type;\n\treturn this;\n};\n\nErrorBuilder.prototype.setResource = function(name) {\n\tvar self = this;\n\tself.isResourceCustom = true;\n\tself.resourceName = name;\n\treturn self._resource();\n};\n\nErrorBuilder.prototype.setPrefix = function(name) {\n\tvar self = this;\n\tself.resourcePrefix = name || '';\n\treturn self._resource();\n};\n\n/**\n * Internal: Resource wrapper\n * @private\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype._resource = function() {\n\tvar self = this;\n\tself.onResource = self._resource_handler;\n\treturn self;\n};\n\nErrorBuilder.prototype._resource_handler = function(name) {\n\tvar self = this;\n\treturn global.F ? F.resource(self.resourceName || 'default', name) : '';\n};\n\nErrorBuilder.prototype.exception = function(message) {\n\tthis.items.push({ name: '', error: message });\n\treturn this;\n};\n\n/**\n * Add an error\n * @param {String} name  Property name.\n * @param {String|Error} error Error message.\n * @param {String} path  Current path (in object).\n * @param {Number} index Array Index, optional.\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype.add = function(name, error, path, index) {\n\treturn this.push(name, error, path, index);\n};\n\nconst ERRORBUILDERWHITE = { ' ': 1, ':': 1, ',': 1 };\n\n/**\n * Add an error (@alias for add)\n * @param {String} name  Property name.\n * @param {String or Error} error Error message.\n * @param {String} path  Current path (in object).\n * @param {Number} index Array Index, optional.\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype.push = function(name, error, path, index, prefix) {\n\n\tthis.isPrepared = false;\n\n\tif (name instanceof ErrorBuilder) {\n\t\tif (name !== this && name.is) {\n\t\t\tfor (var i = 0, length = name.items.length; i < length; i++)\n\t\t\t\tthis.items.push(name.items[i]);\n\t\t\tthis.count = this.items.length;\n\t\t}\n\t\treturn this;\n\t}\n\n\tif (name instanceof Array) {\n\t\tfor (var i = 0, length = name.length; i < length; i++)\n\t\t\tthis.push(name[i], undefined, path, index, prefix);\n\t\treturn this;\n\t}\n\n\tif (error instanceof Array) {\n\t\tfor (var i = 0, length = error.length; i < length; i++)\n\t\t\tthis.push(name, error[i], path, index, prefix);\n\t\treturn this;\n\t}\n\n\tif (typeof(name) === 'object') {\n\t\tpath = error;\n\t\terror = name;\n\t\tname = '';\n\t}\n\n\tif (error === null || (!name && !error))\n\t\treturn this;\n\n\t// Status code\n\tif (error > 0) {\n\t\tthis.status = error;\n\t\terror = '@';\n\t} else if (path > 0) {\n\t\tthis.status = path;\n\t\tpath = undefined;\n\t}\n\n\tif (this.path && !path)\n\t\tpath = this.path;\n\n\tif (!error && typeof(name) === 'string') {\n\t\tvar m = name.length;\n\t\tif (m > 15)\n\t\t\tm = 15;\n\n\t\terror = '@';\n\n\t\tfor (var i = 0; i < m; i++) {\n\t\t\tif (ERRORBUILDERWHITE[name[i]]) {\n\t\t\t\terror = name;\n\t\t\t\tname = '';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (error instanceof Error) {\n\t\t// Why? The answer is in controller.callback(); It's a reason for throwing 500 - internal server error\n\t\tthis.unexpected = true;\n\t\terror = error.toString();\n\t}\n\n\tthis.items.push({ name: name, error: typeof(error) === 'string' ? error : error.toString(), path: path, index: index, prefix: prefix });\n\tthis.count = this.items.length;\n\treturn this;\n};\n\nErrorBuilder.assign = function(arr) {\n\tvar builder = new ErrorBuilder();\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (arr[i].error)\n\t\t\tbuilder.items.push(arr[i]);\n\t}\n\tbuilder.count = builder.items.length;\n\treturn builder.count ? builder : null;\n};\n\n/**\n * Remove error\n * @param {String} name Property name.\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype.remove = function(name) {\n\tthis.items = this.items.remove('name', name);\n\tthis.count = this.items.length;\n\treturn this;\n};\n\n/**\n * Has error?\n * @param {String}  name Property name (optional).\n * @return {Boolean}\n */\nErrorBuilder.prototype.hasError = function(name) {\n\treturn name ? this.items.findIndex('name', name) !== -1 : this.items.length > 0;\n};\n\n/**\n * Read an error\n * @param {String} name Property name.\n * @return {String}\n */\nErrorBuilder.prototype.read = function(name) {\n\t!this.isPrepared && this.prepare();\n\tvar error = this.items.findItem('name', name);\n\treturn error ? error.error : null;\n};\n\n/**\n * Clear error collection\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype.clear = function() {\n\tthis.items = [];\n\tthis.count = 0;\n\treturn this;\n};\n\n/**\n * Replace text in message\n * @param {String} search Text to search.\n * @param {String} newvalue Text to replace.\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype.replace = function(search, newvalue) {\n\tthis.isPrepared = false;\n\tthis.replacer[search] = newvalue;\n\treturn this;\n};\n\n/**\n * Serialize ErrorBuilder to JSON\n * @param {Boolean} beautify Beautify JSON.\n * @param {Function(key, value)} replacer JSON replacer.\n * @return {String}\n */\nErrorBuilder.prototype.json = function(beautify, replacer) {\n\tvar items = this.prepare().items;\n\treturn beautify ? JSON.stringify(items, replacer, '\\t') : JSON.stringify(items, replacer);\n};\n\nErrorBuilder.prototype.plain = function() {\n\tvar items = this.prepare().items;\n\tvar output = '';\n\tfor (var i = 0, length = items.length; i < length; i++)\n\t\toutput += (output ? ', ' : '') + items[i].error;\n\treturn output;\n};\n\n/**\n * Serialize ErrorBuilder to JSON\n * @param {Boolean} beautify Beautify JSON.\n * @return {String}\n */\nErrorBuilder.prototype.JSON = function(beautify, replacer) {\n\treturn this.json(beautify, replacer);\n};\n\n/**\n * Internal: Prepare error messages with onResource()\n * @private\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype._prepare = function() {\n\n\tif (!this.onResource)\n\t\treturn this;\n\n\tvar arr = this.items;\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar o = arr[i];\n\n\t\tif (o.error[0] !== '@')\n\t\t\tcontinue;\n\n\t\tif (o.error.length === 1)\n\t\t\to.error = this.onResource(o.prefix ? o.prefix : (this.resourcePrefix + o.name));\n\t\telse\n\t\t\to.error = this.onResource(o.error.substring(1));\n\n\t\tif (!o.error)\n\t\t\to.error = REQUIRED.replace('@', o.name);\n\t}\n\n\treturn this;\n};\n\n/**\n * Execute a transform\n * @private\n * @return {Object}\n */\nErrorBuilder.prototype._transform = function(name) {\n\tvar transformName = name || this.transformName;\n\tif (transformName) {\n\t\tvar current = transforms['error'][transformName];\n\t\treturn current ? current.call(this) : this.items;\n\t}\n\treturn this.items;\n};\n\nErrorBuilder.prototype.output = function(isResponse) {\n\n\tif (!this.transformName)\n\t\treturn isResponse ? this.json() : this.items;\n\n\tvar current = transforms['error'][this.transformName];\n\tif (current) {\n\t\tthis.prepare();\n\t\treturn current.call(this, isResponse);\n\t}\n\n\treturn isResponse ? this.json() : this.items;\n};\n\n/**\n * To string\n * @return {String}\n */\nErrorBuilder.prototype.toString = function() {\n\n\t!this.isPrepared && this.prepare();\n\n\tvar errors = this.items;\n\tvar length = errors.length;\n\tvar builder = [];\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder.push(errors[i].error || errors[i].name);\n\n\treturn builder.join('\\n');\n\n};\n\n/**\n * Set transformation for current ErrorBuilder\n * @param {String} name\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype.setTransform = function(name) {\n\tthis.transformName = name;\n\treturn this;\n};\n\n/**\n * Transform\n * @param {String} name\n * @return {Object}\n */\nErrorBuilder.prototype.transform = function(name) {\n\treturn this.prepare()._transform(name);\n};\n\n/**\n * Internal: Prepare error messages with onResource()\n * @private\n * @return {ErrorBuidler}\n */\nErrorBuilder.prototype._prepareReplace = function() {\n\n\tvar self = this;\n\tvar errors = self.items;\n\tvar lengthBuilder = errors.length;\n\tvar keys = Object.keys(self.replacer);\n\tvar lengthKeys = keys.length;\n\n\tif (!lengthBuilder || !lengthKeys)\n\t\treturn self;\n\n\tfor (var i = 0; i < lengthBuilder; i++) {\n\t\tvar o = errors[i];\n\t\tfor (var j = 0; j < lengthKeys; j++) {\n\t\t\tvar key = keys[j];\n\t\t\to.error = o.error.replace(key, self.replacer[key]);\n\t\t}\n\t}\n\n\treturn self;\n};\n\n/**\n * Internal: Prepare error messages with onResource()\n * @private\n * @return {ErrorBuilder}\n */\nErrorBuilder.prototype.prepare = function() {\n\tif (this.isPrepared)\n\t\treturn this;\n\tthis._prepare()._prepareReplace();\n\tthis.isPrepared = true;\n\treturn this;\n};\n\n/**\n * STATIC: Create transformation\n * @param {String} name\n * @param {Function(ErrorBuilder)} fn\n * @param {Boolean} isDefault Default transformation for all error builders.\n */\nErrorBuilder.addTransform = function(name, fn, isDefault) {\n\ttransforms['error'][name] = fn;\n\tisDefault && ErrorBuilder.setDefaultTransform(name);\n};\n\n/**\n * STATIC: Remove transformation\n * @param {String} name\n */\nErrorBuilder.removeTransform = function(name) {\n\tdelete transforms['error'][name];\n};\n\n/**\n * STATIC: Create transformation\n * @param {String} name\n * @param {Function(errorBuilder)} fn\n */\nErrorBuilder.setDefaultTransform = function(name) {\n\tif (name)\n\t\ttransforms['error_default'] = name;\n\telse\n\t\tdelete transforms['error_default'];\n};\n\n/**\n * Pagination\n * @class\n * @param {Number} items Count of items.\n * @param {Number} page Current page.\n * @param {Number} max Max items on page.\n * @param {String} format URL format for links (next, back, go to). Example: ?page={0} --- {0} = page, {1} = items count, {2} = page count\n * @property {Number} isNext Is next page?\n * @property {Number} isPrev Is previous page?\n * @property {Number} count Page count.\n * @property {Boolean} visible Is more than one page?\n * @property {String} format Format URL. Example: ?page={0} --- {0} = page, {1} = items count, {2} = page count\n */\nfunction Pagination(items, page, max, format) {\n\tthis.isNext = false;\n\tthis.isPrev = false;\n\tthis.isFirst = false;\n\tthis.isLast = false;\n\tthis.nextPage = 0;\n\tthis.prevPage = 0;\n\tthis.lastPage = 0;\n\tthis.firstPage = 0;\n\tthis.items = Math.max(0, +items);\n\tthis.count = 0;\n\tthis.skip = 0;\n\tthis.take = 0;\n\tthis.page = 0;\n\tthis.max = 0;\n\tthis.visible = false;\n\tthis.format = format || '?page={0}';\n\tthis.refresh(items, page, max);\n\tthis.transformName = transforms['pagination_default'];\n}\n\nfunction Page(url, page, selected, enabled) {\n\tthis.url = url;\n\tthis.page = page;\n\tthis.selected = selected;\n\tthis.enabled = enabled;\n}\n\nPage.prototype.html = function(body, cls) {\n\tvar classname = cls ? cls : '';\n\tif (this.selected)\n\t\tclassname += (classname ? ' ' : '') + 'selected';\n\treturn '<a href=\"' + this.url + '\"' + (classname ? (' class=\"' + classname + '\"') : '') + '>' + (body || this.page) + '</a>';\n};\n\n/**\n * STATIC: Create transformation\n * @param {String} name\n * @param {Function(pagination)} fn\n * @param {Boolean} isDefault Default transformation for all paginations.\n */\nPagination.addTransform = function(name, fn, isDefault) {\n\ttransforms['pagination'][name] = fn;\n\tisDefault && Pagination.setDefaultTransform(name);\n};\n\n/**\n * STATIC: Create transformation\n * @param {String} name\n * @param {Function(pagination)} fn\n */\nPagination.setDefaultTransform = function(name) {\n\tif (name)\n\t\ttransforms['pagination_default'] = name;\n\telse\n\t\tdelete transforms['pagination_default'];\n};\n\n/**\n * STATIC: Remove transformation\n * @param {String} name\n */\nPagination.removeTransform = function(name) {\n\tdelete transforms['pagination'][name];\n};\n\n/**\n * Refresh pagination\n * @param {Number} items Count of items.\n * @param {Number} page Current page.\n * @param {Number} max Max items on page.\n * @return {Pagination}\n */\nPagination.prototype.refresh = function(items, page, max) {\n\n\tthis.page = Math.max(1, +page) - 1;\n\n\tif (this.page <= 0)\n\t\tthis.page = 0;\n\n\tthis.items = Math.max(0, +items);\n\tthis.max = Math.max(1, +max);\n\tthis.skip = this.page * this.max;\n\tthis.count = Math.ceil(this.items / this.max);\n\tthis.take = Math.min(this.max, (this.items - this.skip));\n\n\tthis.lastPage = this.count;\n\tthis.firstPage = 1;\n\tthis.prevPage = this.page ? this.page : 1;\n\tthis.nextPage = this.page + 2 < this.count - 1 ? this.page + 2 : this.count;\n\n\tthis.isPrev = this.page > 0;\n\tthis.isNext = this.page < this.count - 1;\n\n\tthis.isFirst = this.page === 0;\n\tthis.isLast = this.page === this.count - 1;\n\n\tthis.visible = this.count > 1;\n\tthis.page++;\n\n\treturn this;\n};\n\n/**\n * Set transformation for current Pagination\n * @param {String} name\n * @return {Pagination}\n */\nPagination.prototype.setTransform = function(name) {\n\tthis._transform = name;\n\treturn this;\n};\n\n/**\n * Execute a transform\n * @private\n * @param {String} name A transformation name.\n * @param {Object} argument1 Optional.\n * @param {Object} argument2 Optional.\n * @param {Object} argument3 Optional.\n * @param {Object} argument4 Optional.\n * @param {Object} argument..n Optional.\n * @return {Object}\n */\nPagination.prototype.transform = function(name) {\n\n\tvar transformName = name || this.transformName;\n\tif (!transformName)\n\t\tthrow new Error('A transformation of Pagination not found.');\n\n\tvar current = transforms['pagination'][transformName];\n\tif (!current)\n\t\treturn this.render();\n\n\tvar param = [];\n\tfor (var i = 1; i < arguments.length; i++)\n\t\tparam.push(arguments[i]);\n\n\treturn current.apply(this, param);\n};\n\n/**\n * Get a previous page\n * @param {String} format Custom format (optional).\n * @return {Object} Example: { url: String, page: Number, selected: Boolean }\n */\nPagination.prototype.prev = function(format) {\n\tvar page = 0;\n\n\tformat = format || this.format;\n\n\tif (this.isPrev)\n\t\tpage = this.page - 1;\n\telse\n\t\tpage = this.count;\n\n\treturn new Page(format.format(page, this.items, this.count), page, false, this.isPrev);\n};\n\n/**\n * Get a next page\n * @param {String} format Custom format (optional).\n * @return {Object} Example: { url: String, page: Number, selected: Boolean }\n */\nPagination.prototype.next = function(format) {\n\tvar page = 0;\n\n\tformat = format || this.format;\n\n\tif (this.isNext)\n\t\tpage = this.page + 1;\n\telse\n\t\tpage = 1;\n\n\treturn new Page(format.format(page, this.items, this.count), page, false, this.isNext);\n};\n\n/**\n * Get a last page\n * @param {String} format Custom format (optional).\n * @return {Object} Example: { url: String, page: Number, selected: Boolean }\n */\nPagination.prototype.last = function(format) {\n\tvar page = this.count;\n\tformat = format || this.format;\n\treturn new Page(format.format(page, this.items, this.count), page, false, this.count > 0);\n};\n\n/**\n * Get a first page\n * @param {String} format Custom format (optional).\n * @return {Object} Example: { url: String, page: Number, selected: Boolean }\n */\nPagination.prototype.first = function(format) {\n\tvar page = 1;\n\tformat = format || this.format;\n\treturn new Page(format.format(page, this.items, this.count), page, false, this.count > 0);\n};\n\n/**\n * Create a pagination object\n * @param {Number} max Max pages in collection (optional).\n * @param {String} format Custom format (optional).\n * @return {Object Array} Example: [{ url: String, page: Number, selected: Boolean }]\n */\nPagination.prototype.prepare = function(max, format, type) {\n\n\tvar self = this;\n\n\tif (self.transformName)\n\t\treturn transforms['pagination'][self.transformName].apply(self, arguments);\n\n\tvar builder = [];\n\tformat = format || self.format;\n\n\tif (typeof(max) === 'string') {\n\t\tvar tmp = format;\n\t\tformat = max;\n\t\tmax = tmp;\n\t}\n\n\tvar isHTML = type === 'html';\n\n\tif (max == null) {\n\t\tfor (var i = 1; i < self.count + 1; i++) {\n\t\t\tvar page = new Page(format.format(i, self.items, self.count), i, i === self.page, true);\n\t\t\tbuilder.push(isHTML ? page.html() : page);\n\t\t}\n\t\treturn builder;\n\t}\n\n\tvar half = Math.floor(max / 2);\n\tvar pages = self.count;\n\n\tvar pageFrom = self.page - half;\n\tvar pageTo = self.page + half;\n\tvar plus = 0;\n\n\tif (pageFrom <= 0) {\n\t\tplus = Math.abs(pageFrom);\n\t\tpageFrom = 1;\n\t\tpageTo += plus;\n\t}\n\n\tif (pageTo >= pages) {\n\t\tpageTo = pages;\n\t\tpageFrom = pages - max;\n\t\tif (pageFrom <= 0)\n\t\t\tpageFrom = 1;\n\t}\n\n\tfor (var i = pageFrom; i < pageTo + 1; i++) {\n\t\tvar page = new Page(format.format(i, self.items, self.count), i, i === self.page, true);\n\t\tbuilder.push(isHTML ? page.html() : page);\n\t}\n\n\treturn builder;\n};\n\nPagination.prototype.render = function(max, format) {\n\treturn this.prepare(max, format);\n};\n\nPagination.prototype.html = function(max, format) {\n\treturn this.prepare(max, format, 'html').join('');\n};\n\nPagination.prototype.json = function(max, format) {\n\treturn JSON.stringify(this.prepare(max, format));\n};\n\nUrlBuilder.make = function(fn) {\n\tvar b = new UrlBuilder();\n\tfn.call(b, b);\n\treturn b;\n};\n\n/**\n * Add parameter\n * @param {String} name\n * @param {Object} value\n * return {UrlBuilder}\n */\nUrlBuilder.prototype.add = function(name, value) {\n\n\tif (typeof(name) !== 'object') {\n\t\tthis.builder[name] = value;\n\t\treturn this;\n\t}\n\n\tvar arr = Object.keys(name);\n\n\tfor (var i = 0, length = arr.length; i < length; i++)\n\t\tthis.builder[arr[i]] = name[arr[i]];\n\n\treturn this;\n};\n\n/**\n * Remove parameter\n * @param {String} name\n * @return {UrlBuilder}\n */\nUrlBuilder.prototype.remove = function(name) {\n\tdelete this.builder[name];\n\treturn this;\n};\n\n/**\n * Read value\n * @param {String} name\n * @return {Object}\n */\nUrlBuilder.prototype.read = function(name) {\n\treturn this.builder[name] || null;\n};\n\n/**\n * Clear parameter collection\n * @return {UrlBuilder}\n */\nUrlBuilder.prototype.clear = function() {\n\tthis.builder = {};\n\treturn this;\n};\n\n/**\n * Create URL\n * @return {String}\n */\nUrlBuilder.prototype.toString = function(url, skipEmpty) {\n\n\tif (typeof(url) === 'boolean') {\n\t\tvar tmp = skipEmpty;\n\t\tskipEmpty = url;\n\t\turl = tmp;\n\t}\n\n\tvar self = this;\n\tvar builder = [];\n\n\tObject.keys(self.builder).forEach(function(o) {\n\n\t\tvar value = self.builder[o];\n\t\tif (value == null)\n\t\t\tvalue = '';\n\t\telse\n\t\t\tvalue = value.toString();\n\n\t\tif (skipEmpty && value === '')\n\t\t\treturn;\n\n\t\tbuilder.push(o + '=' + encodeURIComponent(value));\n\t});\n\n\tif (typeof(url) === 'string') {\n\t\tif (url[url.length - 1] !== '?')\n\t\t\turl += '?';\n\t} else\n\t\turl = '';\n\n\treturn url + builder.join('&');\n};\n\n/**\n * Has these parameters?\n * @param {String Array} keys Keys.\n * @return {Boolean}\n */\nUrlBuilder.prototype.hasValue = function(keys) {\n\n\tif (keys === undefined)\n\t\treturn false;\n\n\tif (typeof(keys) === 'string')\n\t\tkeys = [keys];\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar val = this.builder[keys[i]];\n\t\tif (val == null)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Render parameters\n * @param {String Array} keys Keys.\n * @param {String} delimiter Delimiter (default &).\n * @return {String}\n */\nUrlBuilder.prototype.toOne = function(keys, delimiter) {\n\tvar self = this;\n\tvar builder = [];\n\tkeys.forEach(key => builder.push(self.builder[key] || ''));\n\treturn builder.join(delimiter || '&');\n};\n\nfunction RESTBuilder(url) {\n\n\tthis.$url = url;\n\tthis.$headers = { 'user-agent': 'Total.js/v' + F.version_header, accept: 'application/json, text/plain, text/plain, text/xml' };\n\tthis.$method = 'get';\n\tthis.$timeout = 10000;\n\tthis.$type = 0; // 0 = query, 1 = json, 2 = urlencode, 3 = raw\n\tthis.$schema;\n\tthis.$length = 0;\n\tthis.$transform = transforms['restbuilder_default'];\n\tthis.$files = null;\n\tthis.$persistentcookies = false;\n\n\t// this.$flags;\n\t// this.$data = {};\n\t// this.$nodnscache = true;\n\t// this.$cache_expire;\n\t// this.$cache_nocache;\n\t// this.$redirect\n\n\t// Auto Total.js Error Handling\n\tthis.$errorbuilderhandling = true;\n}\n\nRESTBuilder.make = function(fn) {\n\tvar instance = new RESTBuilder();\n\tfn && fn(instance);\n\treturn instance;\n};\n\nRESTBuilder.url = function(url) {\n\treturn new RESTBuilder(url);\n};\n\nRESTBuilder.GET = function(url, data) {\n\tvar builder = new RESTBuilder(url);\n\tdata && builder.raw(data);\n\treturn builder;\n};\n\nRESTBuilder.POST = function(url, data) {\n\tvar builder = new RESTBuilder(url);\n\tbuilder.$method = 'post';\n\tbuilder.$type = 1;\n\tdata && builder.raw(data);\n\treturn builder;\n};\n\nRESTBuilder.PUT = function(url, data) {\n\tvar builder = new RESTBuilder(url);\n\tbuilder.$method = 'put';\n\tbuilder.$type = 1;\n\tbuilder.put(data);\n\treturn builder;\n};\n\nRESTBuilder.DELETE = function(url, data) {\n\tvar builder = new RESTBuilder(url);\n\tbuilder.$method = 'delete';\n\tbuilder.$type = 1;\n\tdata && builder.raw(data);\n\treturn builder;\n};\n\nRESTBuilder.PATCH = function(url, data) {\n\tvar builder = new RESTBuilder(url);\n\tbuilder.$method = 'patch';\n\tbuilder.$type = 1;\n\tdata && builder.raw(data);\n\treturn builder;\n};\n\nRESTBuilder.HEAD = function(url) {\n\tvar builder = new RESTBuilder(url);\n\tbuilder.$method = 'head';\n\treturn builder;\n};\n\nRESTBuilder.upgrade = function(fn) {\n\trestbuilderupgrades.push(fn);\n};\n\n/**\n * STATIC: Creates a transformation\n * @param {String} name\n * @param {Function} fn\n * @param {Boolean} isDefault Default transformation for all RESTBuilders.\n */\nRESTBuilder.addTransform = function(name, fn, isDefault) {\n\ttransforms['restbuilder'][name] = fn;\n\tisDefault && RESTBuilder.setDefaultTransform(name);\n};\n\nRESTBuilder.setDefaultTransform = function(name) {\n\tif (name)\n\t\ttransforms['restbuilder_default'] = name;\n\telse\n\t\tdelete transforms['restbuilder_default'];\n};\n\nvar RESTP = RESTBuilder.prototype;\n\nRESTP.promise = function(fn) {\n\tvar self = this;\n\treturn new Promise(function(resolve, reject) {\n\t\tself.exec(function(err, result) {\n\t\t\tif (err)\n\t\t\t\treject(err);\n\t\t\telse\n\t\t\t\tresolve(fn == null ? result : fn(result));\n\t\t});\n\t});\n};\n\nRESTP.proxy = function(value) {\n\tthis.$proxy = value;\n\treturn this;\n};\n\nRESTP.setTransform = function(name) {\n\tthis.$transform = name;\n\treturn this;\n};\n\nRESTP.url = function(url) {\n\tif (url === undefined)\n\t\treturn this.$url;\n\tthis.$url = url;\n\treturn this;\n};\n\nRESTP.file = function(name, filename, buffer) {\n\tvar obj = { name: name, filename: filename, buffer: buffer };\n\tif (this.$files)\n\t\tthis.$files.push(obj);\n\telse\n\t\tthis.$files = [obj];\n\treturn this;\n};\n\nRESTP.maketransform = function(obj, data) {\n\tif (this.$transform) {\n\t\tvar fn = transforms['restbuilder'][this.$transform];\n\t\treturn fn ? fn(obj, data) : obj;\n\t}\n\treturn obj;\n};\n\nRESTP.timeout = function(number) {\n\tthis.$timeout = number;\n\treturn this;\n};\n\nRESTP.maxlength = function(number) {\n\tthis.$length = number;\n\tthis.$flags = null;\n\treturn this;\n};\n\nRESTP.auth = function(user, password) {\n\tthis.$headers['authorization'] = 'Basic ' + Buffer.from(user + ':' + password).toString('base64');\n\treturn this;\n};\n\nRESTP.convert = function(convert) {\n\tthis.$convert = convert;\n\treturn this;\n};\n\nRESTP.schema = function(group, name) {\n\tthis.$schema = exports.getschema(group, name);\n\tif (!this.$schema)\n\t\tthrow Error('RESTBuilder: Schema \"{0}\" not found.'.format(name ? (group + '/' + name) : group));\n\treturn this;\n};\n\nRESTP.noDnsCache = function() {\n\tthis.$nodnscache = true;\n\tthis.$flags = null;\n\treturn this;\n};\n\nRESTP.noCache = function() {\n\tthis.$nocache = true;\n\treturn this;\n};\n\nRESTP.make = function(fn) {\n\tfn.call(this, this);\n\treturn this;\n};\n\nRESTP.xhr = function() {\n\tthis.$headers['X-Requested-With'] = 'XMLHttpRequest';\n\treturn this;\n};\n\nRESTP.method = function(method, data) {\n\tthis.$method = method.charCodeAt(0) < 97 ? method.toLowerCase() : method;\n\tthis.$flags = null;\n\tdata && this.raw(data);\n\treturn this;\n};\n\nRESTP.referer = RESTP.referrer = function(value) {\n\tthis.$headers['Referer'] = value;\n\treturn this;\n};\n\nRESTP.origin = function(value) {\n\tthis.$headers['Origin'] = value;\n\treturn this;\n};\n\nRESTP.robot = function() {\n\tif (this.$headers['User-Agent'])\n\t\tthis.$headers['User-Agent'] += ' Bot';\n\telse\n\t\tthis.$headers['User-Agent'] = 'Bot';\n\treturn this;\n};\n\nRESTP.mobile = function() {\n\tif (this.$headers['User-Agent'])\n\t\tthis.$headers['User-Agent'] += ' iPhone';\n\telse\n\t\tthis.$headers['User-Agent'] = 'iPhone';\n\treturn this;\n};\n\nRESTP.put = RESTP.PUT = function(data) {\n\tif (this.$method !== 'put') {\n\t\tthis.$flags = null;\n\t\tthis.$method = 'put';\n\t\tthis.$type = 1;\n\t}\n\tdata && this.raw(data);\n\treturn this;\n};\n\nRESTP.delete = RESTP.DELETE = function(data) {\n\tif (this.$method !== 'delete') {\n\t\tthis.$flags = null;\n\t\tthis.$method = 'delete';\n\t\tthis.$type = 1;\n\t}\n\tdata && this.raw(data);\n\treturn this;\n};\n\nRESTP.get = RESTP.GET = function(data) {\n\tif (this.$method !== 'get') {\n\t\tthis.$flags = null;\n\t\tthis.$method = 'get';\n\t}\n\tdata && this.raw(data);\n\treturn this;\n};\n\nRESTP.post = RESTP.POST = function(data) {\n\tif (this.$method !== 'post') {\n\t\tthis.$flags = null;\n\t\tthis.$method = 'post';\n\t\tthis.$type = 1;\n\t}\n\tdata && this.raw(data);\n\treturn this;\n};\n\nRESTP.head = RESTP.HEAD = function() {\n\tif (this.$method !== 'head') {\n\t\tthis.$flags = null;\n\t\tthis.$method = 'head';\n\t}\n\treturn this;\n};\n\nRESTP.patch = RESTP.PATCH = function(data) {\n\tif (this.$method !== 'patch') {\n\t\tthis.$flags = null;\n\t\tthis.$method = 'patch';\n\t\tthis.$type = 1;\n\t}\n\tdata && this.raw(data);\n\treturn this;\n};\n\nRESTP.json = function(data) {\n\n\tif (this.$type !== 1)\n\t\tthis.$flags = null;\n\n\tdata && this.raw(data);\n\tthis.$type = 1;\n\n\tif (this.$method === 'get')\n\t\tthis.$method = 'post';\n\n\treturn this;\n};\n\nRESTP.urlencoded = function(data) {\n\n\tif (this.$type !== 2)\n\t\tthis.$flags = null;\n\n\tif (this.$method === 'get')\n\t\tthis.$method = 'post';\n\n\tthis.$type = 2;\n\tdata && this.raw(data);\n\treturn this;\n};\n\nRESTP.accept = function(ext) {\n\n\tvar type;\n\n\tif (ext.length > 8)\n\t\ttype = ext;\n\telse\n\t\ttype = framework_utils.getContentType(ext);\n\n\tif (this.$headers.Accept !== type)\n\t\tthis.$flags = null;\n\n\tthis.$flags = null;\n\tthis.$headers.Accept = type;\n\n\treturn this;\n};\n\nRESTP.xml = function(data, replace) {\n\n\tif (this.$type !== 3)\n\t\tthis.$flags = null;\n\n\tif (this.$method === 'get')\n\t\tthis.$method = 'post';\n\n\tthis.$type = 3;\n\n\tif (replace)\n\t\tthis.$replace = true;\n\n\tdata && this.raw(data);\n\treturn this;\n};\n\nRESTP.redirect = function(value) {\n\tthis.$redirect = value;\n\treturn this;\n};\n\nRESTP.raw = function(value) {\n\tthis.$data = value && value.$clean ? value.$clean() : value;\n\treturn this;\n};\n\nRESTP.plain = function() {\n\tthis.$plain = true;\n\treturn this;\n};\n\nRESTP.cook = function(value) {\n\tthis.$flags = null;\n\tthis.$persistentcookies = value !== false;\n\treturn this;\n};\n\nRESTP.cookies = function(obj) {\n\tthis.$cookies = obj;\n\treturn this;\n};\n\nRESTP.cookie = function(name, value) {\n\t!this.$cookies && (this.$cookies = {});\n\tthis.$cookies[name] = value;\n\treturn this;\n};\n\nRESTP.header = function(name, value) {\n\tthis.$headers[name] = value;\n\treturn this;\n};\n\nRESTP.type = function(value) {\n\tthis.$headers['Content-Type'] = value;\n\treturn this;\n};\n\nfunction execrestbuilder(instance, callback) {\n\tinstance.exec(callback);\n}\n\nRESTP.callback = function(callback) {\n\tsetImmediate(execrestbuilder, this, callback);\n\treturn this;\n};\n\nRESTP.cache = function(expire) {\n\tthis.$cache_expire = expire;\n\treturn this;\n};\n\nRESTP.insecure = function() {\n\tthis.$insecure = true;\n\treturn this;\n};\n\nRESTP.set = function(name, value) {\n\tif (!this.$data)\n\t\tthis.$data = {};\n\tif (typeof(name) !== 'object') {\n\t\tthis.$data[name] = value;\n\t} else {\n\t\tvar arr = Object.keys(name);\n\t\tfor (var i = 0, length = arr.length; i < length; i++)\n\t\t\tthis.$data[arr[i]] = name[arr[i]];\n\t}\n\treturn this;\n};\n\nRESTP.rem = function(name) {\n\tif (this.$data && this.$data[name])\n\t\tthis.$data[name] = undefined;\n\treturn this;\n};\n\nRESTP.stream = function(callback) {\n\tvar self = this;\n\tvar flags = self.$flags ? self.$flags : [self.$method];\n\n\tif (!self.$flags) {\n\t\t!self.$nodnscache && flags.push('dnscache');\n\t\tself.$persistentcookies && flags.push('cookies');\n\t\tswitch (self.$type) {\n\t\t\tcase 1:\n\t\t\t\tflags.push('json');\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tflags.push('xml');\n\t\t\t\tbreak;\n\t\t}\n\t\tself.$flags = flags;\n\t}\n\n\treturn U.download(self.$url, flags, self.$data, callback, self.$cookies, self.$headers, undefined, self.$timeout);\n};\n\nRESTP.keepalive = function() {\n\tvar self = this;\n\tself.$keepalive = true;\n\treturn self;\n};\n\nRESTP.flags = function() {\n\tvar self = this;\n\t!self.$flags && (self.$flags = []);\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tself.$flags(arguments[i]);\n\treturn self;\n};\n\nRESTP.exec = function(callback) {\n\n\tif (!callback)\n\t\tcallback = NOOP;\n\n\tvar self = this;\n\n\tif (self.$files && self.$method === 'get')\n\t\tself.$method = 'post';\n\n\tself.$callback = callback;\n\n\tif (restbuilderupgrades.length) {\n\t\tfor (var i = 0; i < restbuilderupgrades.length; i++)\n\t\t\trestbuilderupgrades[i](self);\n\t}\n\n\tvar flags = self.$flags ? self.$flags : [self.$method];\n\tvar key;\n\n\tif (!self.$flags) {\n\n\t\t!self.$nodnscache && flags.push('dnscache');\n\t\tself.$persistentcookies && flags.push('cookies');\n\t\tself.$length && flags.push('<' + self.$length);\n\t\tself.$redirect === false && flags.push('noredirect');\n\t\tself.$proxy && flags.push('proxy ' + self.$proxy);\n\t\tself.$keepalive && flags.push('keepalive');\n\t\tself.$insecure && flags.push('insecure');\n\n\t\tif (self.$files) {\n\t\t\tflags.push('upload');\n\t\t} else {\n\t\t\tswitch (self.$type) {\n\t\t\t\tcase 1:\n\t\t\t\t\tflags.push('json');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tflags.push('xml');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tself.$flags = flags;\n\t}\n\n\tif (self.$cache_expire && !self.$nocache) {\n\t\tkey = '$rest_' + (self.$url + flags.join(',') + (self.$data ? Qs.stringify(self.$data) : '')).hash();\n\t\tvar data = F.cache.read2(key);\n\t\tif (data) {\n\t\t\tvar evt = new framework_utils.EventEmitter2();\n\t\t\tsetImmediate(exec_removelisteners, evt);\n\t\t\tcallback(null, self.maketransform(this.$schema ? this.$schema.make(data.value) : data.value, data), data);\n\t\t\treturn evt;\n\t\t}\n\t}\n\n\tself.$callback_key = key;\n\treturn U.request(self.$url, flags, self.$data, exec_callback, self.$cookies, self.$headers, undefined, self.$timeout, self.$files, self);\n};\n\nfunction exec_callback(err, response, status, headers, hostname, cookies, self) {\n\n\tvar callback = self.$callback;\n\tvar key = self.$callback_key;\n\tvar type = err ? '' : headers['content-type'] || '';\n\tvar output = new RESTBuilderResponse();\n\n\tif (type) {\n\t\tvar index = type.lastIndexOf(';');\n\t\tif (index !== -1)\n\t\t\ttype = type.substring(0, index).trim();\n\t}\n\n\tvar ishead = response === headers;\n\n\tif (ishead)\n\t\tresponse = '';\n\n\tif (ishead) {\n\t\toutput.value = status < 400;\n\t} else if (self.$plain) {\n\t\toutput.value = response;\n\t} else {\n\t\tswitch (type.toLowerCase()) {\n\t\t\tcase 'text/xml':\n\t\t\tcase 'application/xml':\n\t\t\t\toutput.value = response ? response.parseXML(self.$replace ? true : false) : {};\n\t\t\t\tbreak;\n\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\toutput.value = response ? F.onParseQuery(response) : {};\n\t\t\t\tbreak;\n\t\t\tcase 'application/json':\n\t\t\tcase 'text/json':\n\t\t\t\toutput.value = response ? response.parseJSON(true) : null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutput.value = response && response.isJSON() ? response.parseJSON(true) : null;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (output.value == null)\n\t\toutput.value = EMPTYOBJECT;\n\n\toutput.response = response;\n\toutput.status = status;\n\toutput.headers = headers;\n\toutput.hostname = hostname;\n\toutput.cache = false;\n\toutput.datetime = NOW;\n\n\tvar val;\n\n\tif (self.$schema) {\n\n\t\tif (err)\n\t\t\treturn callback(err, EMPTYOBJECT, output);\n\n\t\tval = self.maketransform(output.value, output);\n\n\t\tif (self.$errorbuilderhandling) {\n\t\t\t// Is the response Total.js ErrorBuilder?\n\t\t\tif (val instanceof Array && val.length && val[0] && val[0].error) {\n\t\t\t\terr = ErrorBuilder.assign(val);\n\t\t\t\tif (err)\n\t\t\t\t\tval = EMPTYOBJECT;\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err, EMPTYOBJECT, output);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tself.$schema.make(val, function(err, model) {\n\t\t\t!err && key && output.status === 200 && F.cache.add(key, output, self.$cache_expire);\n\t\t\tcallback(err, err ? EMPTYOBJECT : model, output);\n\t\t\toutput.cache = true;\n\t\t});\n\n\t} else {\n\t\t!err && key && output.status === 200 && F.cache.add(key, output, self.$cache_expire);\n\n\t\tval = self.maketransform(output.value, output);\n\n\t\tif (self.$errorbuilderhandling) {\n\t\t\t// Is the response Total.js ErrorBuilder?\n\t\t\tif (val instanceof Array && val.length && val[0] && val[0].error) {\n\t\t\t\terr = ErrorBuilder.assign(val);\n\t\t\t\tif (err)\n\t\t\t\t\tval = EMPTYOBJECT;\n\t\t\t}\n\t\t}\n\n\t\tif (self.$convert && val && val !== EMPTYOBJECT)\n\t\t\tval = CONVERT(val, self.$convert);\n\n\t\tcallback(err, val, output);\n\t\toutput.cache = true;\n\t}\n}\n\nfunction exec_removelisteners(evt) {\n\tevt.removeAllListeners();\n}\n\nfunction RESTBuilderResponse() {}\n\nRESTBuilderResponse.prototype.cookie = function(name) {\n\tvar self = this;\n\n\tif (self.cookies)\n\t\treturn $decodeURIComponent(self.cookies[name] || '');\n\n\tvar cookie = self.headers['cookie'];\n\tif (!cookie)\n\t\treturn '';\n\n\tself.cookies = {};\n\n\tvar arr = cookie.split(';');\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar line = arr[i].trim();\n\t\tvar index = line.indexOf('=');\n\t\tif (index !== -1)\n\t\t\tself.cookies[line.substring(0, index)] = line.substring(index + 1);\n\t}\n\n\treturn $decodeURIComponent(self.cookies[name] || '');\n};\n\n// Handle errors of decodeURIComponent\nfunction $decodeURIComponent(value) {\n\ttry\n\t{\n\t\treturn decodeURIComponent(value);\n\t} catch (e) {\n\t\treturn value;\n\t}\n}\n\nglobal.NEWTASK = function(name, fn, filter) {\n\tif (fn == null) {\n\t\tdelete tasks[name];\n\t} else {\n\t\ttasks[name] = {};\n\t\ttasks[name].$owner = F.$owner();\n\t\ttasks[name].$filter = filter;\n\t\tvar append = function(key, fn) {\n\t\t\ttasks[name][key] = fn;\n\t\t};\n\t\tfn(append);\n\t}\n};\n\nfunction taskrunner(obj, name, callback) {\n\tobj.exec(name, callback);\n}\n\nglobal.TASK = function(taskname, name, callback, options) {\n\tvar obj = new TaskBuilder(options);\n\tobj.taskname = taskname;\n\n\tif (obj.controller) {\n\t\tobj.controller.$filterschema = null;\n\t\tobj.controller.$filter = null;\n\t}\n\n\tname && setImmediate(taskrunner, obj, name, callback);\n\treturn obj;\n};\n\nglobal.NEWOPERATION = function(name, fn, repeat, stop, binderror, filter) {\n\n\tif (typeof(repeat) === 'string') {\n\t\tfilter = repeat;\n\t\trepeat = null;\n\t}\n\n\tif (typeof(stop) === 'string') {\n\t\tfilter = stop;\n\t\tstop = null;\n\t}\n\n\tif (typeof(binderror) === 'string') {\n\t\tfilter = binderror;\n\t\tbinderror = null;\n\t}\n\n\t// @repeat {Number} How many times will be the operation repeated after error?\n\t// @stop {Boolean} Stop when the error is thrown\n\t// @binderror {Boolean} Binds error when chaining of operations\n\t// @filter {Object}\n\n\t// Remove operation\n\tif (fn == null) {\n\t\tdelete operations[name];\n\t} else {\n\t\toperations[name] = fn;\n\t\toperations[name].$owner = F.$owner();\n\t\toperations[name].$newversion = REGEXP_NEWOPERATION.test(fn.toString());\n\t\toperations[name].$repeat = repeat;\n\t\toperations[name].$stop = stop !== false;\n\t\toperations[name].$binderror = binderror === true;\n\t\toperations[name].$filter = filter;\n\t\tif (!operations[name].$newversion)\n\t\t\tOBSOLETE('NEWOPERATION(\"{0}\")'.format(name), MSG_OBSOLETE_NEW);\n\t}\n};\n\nfunction getLoggerNameOperation(name) {\n\treturn 'OPERATION(\\'' + name + '\\')';\n}\n\nfunction NoOp() {}\n\nglobal.OPERATION = function(name, value, callback, param, controller) {\n\n\tif (typeof(value) === 'function') {\n\t\tcontroller = param;\n\t\tparam = callback;\n\t\tcallback = value;\n\t\tvalue = EMPTYOBJECT;\n\t}\n\n\tif (param instanceof Controller || param instanceof OperationOptions || param instanceof SchemaOptions || param instanceof TaskBuilder || param instanceof AuthOptions || param instanceof WebSocketClient) {\n\t\tcontroller = param;\n\t\tparam = undefined;\n\t}\n\n\tif (controller && controller.controller)\n\t\tcontroller = controller.controller;\n\n\tvar fn = operations[name];\n\n\tvar error = new ErrorBuilder();\n\tvar $now;\n\n\tif (CONF.logger)\n\t\t$now = Date.now();\n\n\tif (fn) {\n\n\t\tif (fn.$filter && controller) {\n\t\t\tcontroller.$filterschema = fn.$filter;\n\t\t\tcontroller.$filter = null;\n\t\t}\n\n\t\tif (fn.$newversion) {\n\t\t\tvar self = new OperationOptions(error, value, param, controller);\n\t\t\tself.$repeat = fn.$repeat;\n\t\t\tself.callback = function(value) {\n\n\t\t\t\tCONF.logger && F.ilogger(getLoggerNameOperation(name), controller, $now);\n\t\t\t\tif (arguments.length > 1) {\n\t\t\t\t\tif (value instanceof Error || (value instanceof ErrorBuilder && value.is)) {\n\t\t\t\t\t\tself.error.push(value);\n\t\t\t\t\t\tvalue = EMPTYOBJECT;\n\t\t\t\t\t} else\n\t\t\t\t\t\tvalue = arguments[1];\n\t\t\t\t} else if (value instanceof Error || (value instanceof ErrorBuilder && value.is)) {\n\t\t\t\t\tself.error.push(value);\n\t\t\t\t\tvalue = EMPTYOBJECT;\n\t\t\t\t}\n\n\t\t\t\tif (self.error.items.length && self.$repeat) {\n\t\t\t\t\tself.error.clear();\n\t\t\t\t\tself.$repeat--;\n\t\t\t\t\tfn(self);\n\t\t\t\t} else {\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tif (value === NoOp)\n\t\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcallback(self.error.is ? self.error : null, value, self.options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn self;\n\t\t\t};\n\t\t\tfn(self);\n\t\t} else\n\t\t\tfn(error, value, function(value) {\n\t\t\t\tCONF.logger && F.ilogger(getLoggerNameOperation(name), controller, $now);\n\t\t\t\tif (callback) {\n\t\t\t\t\tif (value instanceof Error) {\n\t\t\t\t\t\terror.push(value);\n\t\t\t\t\t\tvalue = EMPTYOBJECT;\n\t\t\t\t\t}\n\t\t\t\t\tif (value !== NoOp)\n\t\t\t\t\t\tcallback(error.is ? error : null, value, param);\n\t\t\t\t}\n\t\t\t});\n\t} else {\n\t\terror.push('Operation \"{0}\" not found.'.format(name));\n\t\tcallback && callback(error, EMPTYOBJECT, param);\n\t}\n};\n\nglobal.RUN = function(name, value, callback, param, controller, result) {\n\n\tif (typeof(value) === 'function') {\n\t\tresult = controller;\n\t\tcontroller = param;\n\t\tparam = callback;\n\t\tcallback = value;\n\t\tvalue = EMPTYOBJECT;\n\t}\n\n\tif (param instanceof global.Controller || (param && param.isWebSocket)) {\n\t\tresult = controller;\n\t\tcontroller = param;\n\t\tparam = EMPTYOBJECT;\n\t} else if (param instanceof OperationOptions || param instanceof SchemaOptions || param instanceof TaskBuilder || param instanceof AuthOptions) {\n\t\tresult = controller;\n\t\tcontroller = param.controller;\n\t}\n\n\tif (!result) {\n\t\tif (typeof(param) === 'string') {\n\t\t\tresult = param;\n\t\t\tparam = EMPTYOBJECT;\n\t\t} else if (typeof(controller) === 'string') {\n\t\t\tresult = controller;\n\t\t\tcontroller = null;\n\t\t}\n\t}\n\n\tif (typeof(name) === 'string')\n\t\tname = name.split(',').trim();\n\n\tvar error = new ErrorBuilder();\n\tvar opt = new OperationOptions(error, value, param, controller);\n\n\topt.meta = {};\n\topt.meta.items = name;\n\topt.response = {};\n\topt.errors = error;\n\n\topt.callback = function(value) {\n\n\t\tCONF.logger && F.ilogger(getLoggerNameOperation(opt.name), controller, opt.duration);\n\n\t\tif (arguments.length > 1) {\n\t\t\tif (value instanceof Error || (value instanceof ErrorBuilder && value.is)) {\n\t\t\t\topt.error.push(value);\n\t\t\t\tvalue = EMPTYOBJECT;\n\t\t\t} else\n\t\t\t\tvalue = arguments[1];\n\t\t} else if (value instanceof Error || (value instanceof ErrorBuilder && value.is)) {\n\t\t\topt.error.push(value);\n\t\t\tvalue = EMPTYOBJECT;\n\t\t}\n\n\t\tif (opt.error.items.length && opt.$repeat > 0) {\n\t\t\topt.error.clear();\n\t\t\topt.$repeat--;\n\t\t\topt.repeated++;\n\t\t\tsetImmediate(opt => opt.$current(opt), opt);\n\t\t} else {\n\n\t\t\tif (opt.error.items.length) {\n\t\t\t\tif (opt.$current.$binderror)\n\t\t\t\t\tvalue = opt.error.output(false);\n\t\t\t}\n\n\t\t\tif (opt.error.items.length && opt.$current.$stop) {\n\t\t\t\terror.push(opt.error);\n\t\t\t\tname = null;\n\t\t\t\topt.next = null;\n\t\t\t\tcallback(error, opt.response, opt);\n\t\t\t} else {\n\n\t\t\t\t// Because \"controller_json_workflow_multiple()\" returns error instead of results\n\t\t\t\t// error.push(opt.error);\n\n\t\t\t\tif (result && (result === opt.meta.current || result === opt.name))\n\t\t\t\t\topt.output = value;\n\n\t\t\t\topt.response[opt.name] = value;\n\t\t\t\topt.meta.prev = opt.meta.current;\n\t\t\t\topt.$next();\n\t\t\t}\n\t\t}\n\t};\n\n\tname.wait(function(key, next, index) {\n\n\t\tvar fn = operations[key];\n\t\tif (!fn) {\n\t\t\t// What now?\n\t\t\t// F.error('Operation \"{0}\" not found'.format(key), 'RUN()');\n\t\t\treturn next();\n\t\t}\n\n\t\topt.repeated = 0;\n\t\topt.error = new ErrorBuilder();\n\t\topt.error.path = 'operation: ' + key;\n\t\topt.meta.index = index;\n\t\topt.name = opt.meta.current = key;\n\t\topt.$repeat = fn.$repeat;\n\t\topt.$current = fn;\n\t\topt.$next = next;\n\t\topt.meta.next = name[index];\n\n\t\tif (CONF.logger)\n\t\t\topt.duration = Date.now();\n\n\t\tfn(opt);\n\n\t}, () => callback(error.items.length ? error : null, result ? opt.output : opt.response, opt));\n};\n\nfunction OperationOptions(error, value, options, controller) {\n\n\tif (!controller && options instanceof global.Controller) {\n\t\tcontroller = options;\n\t\toptions = EMPTYOBJECT;\n\t} else if (options === undefined)\n\t\toptions = EMPTYOBJECT;\n\n\tthis.controller = controller;\n\tthis.model = this.value = value;\n\tthis.error = error;\n\tthis.options = options;\n}\n\nOperationOptions.prototype = {\n\n\tget user() {\n\t\treturn this.controller ? this.controller.user : null;\n\t},\n\n\tget session() {\n\t\treturn this.controller ? this.controller.session : null;\n\t},\n\n\tget sessionid() {\n\t\treturn this.controller && this.controller ? this.controller.req.sessionid : null;\n\t},\n\n\tget language() {\n\t\treturn (this.controller ? this.controller.language : '') || '';\n\t},\n\n\tget ip() {\n\t\treturn this.controller ? this.controller.ip : null;\n\t},\n\n\tget id() {\n\t\treturn this.controller ? this.controller.id : null;\n\t},\n\n\tget req() {\n\t\treturn this.controller ? this.controller.req : null;\n\t},\n\n\tget res() {\n\t\treturn this.controller ? this.controller.res : null;\n\t},\n\n\tget params() {\n\t\treturn this.controller ? this.controller.params : null;\n\t},\n\n\tget files() {\n\t\treturn this.controller ? this.controller.files : null;\n\t},\n\n\tget body() {\n\t\treturn this.controller ? this.controller.body : null;\n\t},\n\n\tget query() {\n\t\treturn this.controller ? this.controller.query : null;\n\t},\n\n\tget headers() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.headers : null;\n\t},\n\n\tget ua() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.ua : null;\n\t},\n\n\tget filter() {\n\t\tvar ctrl = this.controller;\n\t\tif (ctrl && !ctrl.$filter)\n\t\t\tctrl.$filter = ctrl.$filterschema ? CONVERT(ctrl.query, ctrl.$filterschema) : ctrl.query;\n\t\treturn ctrl ? ctrl.$filter : EMPTYOBJECT;\n\t}\n\n};\n\nconst OperationOptionsProto = OperationOptions.prototype;\n\nSchemaOptionsProto.tasks = OperationOptionsProto.tasks = function(taskname, name, callback, options) {\n\treturn taskname ? TASK(taskname, name, callback, options || this) : new TaskBuilder(this);\n};\n\nOperationOptionsProto.cancel = function() {\n\tvar self = this;\n\tself.callback = null;\n\tself.error = null;\n\tself.controller = null;\n\tself.options = null;\n\tself.model = self.value = null;\n\treturn self;\n};\n\nOperationOptionsProto.noop = function(nocustomresponse) {\n\tvar self = this;\n\t!nocustomresponse && self.controller && self.controller.custom();\n\tself.callback(NoOp);\n\treturn self;\n};\n\nOperationOptionsProto.successful = function(callback) {\n\tvar self = this;\n\treturn function(err, a, b, c) {\n\t\tif (err)\n\t\t\tself.invalid(err);\n\t\telse\n\t\t\tcallback.call(self, a, b, c);\n\t};\n};\n\nOperationOptionsProto.redirect = function(url) {\n\tthis.callback(new F.callback_redirect(url));\n\treturn this;\n};\n\nOperationOptionsProto.DB = function() {\n\treturn F.database(this.error);\n};\n\nOperationOptionsProto.done = function(arg) {\n\tvar self = this;\n\treturn function(err, response) {\n\t\tif (err) {\n\t\t\tself.error.push(err);\n\t\t\tself.callback();\n\t\t} else {\n\t\t\tif (arg)\n\t\t\t\tself.callback(SUCCESS(err == null, arg === true ? response : arg));\n\t\t\telse\n\t\t\t\tself.callback(SUCCESS(err == null));\n\t\t}\n\t};\n};\n\nOperationOptionsProto.success = function(a, b) {\n\n\tif (a && b === undefined && typeof(a) !== 'boolean') {\n\t\tb = a;\n\t\ta = true;\n\t}\n\n\tthis.callback(SUCCESS(a === undefined ? true : a, b));\n\treturn this;\n};\n\nOperationOptionsProto.invalid = function(name, error, path, index) {\n\n\tvar self = this;\n\n\tif (arguments.length) {\n\t\tself.error.push(name, error, path, index);\n\t\tself.callback();\n\t\treturn self;\n\t}\n\n\treturn function(err) {\n\t\tself.error.push(err);\n\t\tself.callback();\n\t};\n};\n\nfunction AuthOptions(req, res, flags, callback) {\n\tthis.req = req;\n\tthis.res = res;\n\tthis.flags = flags || [];\n\tthis.processed = false;\n\tthis.$callback = callback;\n}\n\nAuthOptions.prototype = {\n\n\tget language() {\n\t\treturn this.req.language || '';\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget params() {\n\t\treturn this.req.params;\n\t},\n\n\tget files() {\n\t\treturn this.req.files;\n\t},\n\n\tget body() {\n\t\treturn this.req.body;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t},\n\n\tget headers() {\n\t\treturn this.req.headers;\n\t},\n\n\tget ua() {\n\t\treturn this.req ? this.req.ua : null;\n\t}\n};\n\nconst AuthOptionsProto = AuthOptions.prototype;\n\nAuthOptionsProto.roles = function() {\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tthis.flags.push('@' + arguments[i]);\n\treturn this;\n};\n\nSchemaOptionsProto.cookie = OperationOptionsProto.cookie = TaskBuilderProto.cookie = AuthOptionsProto.cookie = function(name, value, expire, options) {\n\tvar self = this;\n\tif (value === undefined)\n\t\treturn self.req.cookie(name);\n\tif (value === null)\n\t\texpire = '-1 day';\n\tself.res.cookie(name, value, expire, options);\n\treturn self;\n};\n\nAuthOptionsProto.invalid = function(user) {\n\tthis.next(false, user);\n};\n\nAuthOptionsProto.done = function(response) {\n\tvar self = this;\n\treturn function(is, user) {\n\t\tself.next(is, response ? response : user);\n\t};\n};\n\nAuthOptionsProto.success = function(user) {\n\tthis.next(true, user);\n};\n\nAuthOptionsProto.next = AuthOptionsProto.callback = function(is, user) {\n\n\tif (this.processed)\n\t\treturn;\n\n\t// @is \"null\" for callbacks(err, user)\n\t// @is \"true\"\n\t// @is \"object\" is as user but \"user\" must be \"undefined\"\n\n\tif (is instanceof Error || is instanceof ErrorBuilder) {\n\t\t// Error handling\n\t\tis = false;\n\t} else if (is == null && user) {\n\t\t// A callback error handling\n\t\tis = true;\n\t} else if (user == null && is && is !== true) {\n\t\tuser = is;\n\t\tis = true;\n\t}\n\n\tthis.processed = true;\n\tthis.$callback(is, user, this);\n};\n\nAuthOptions.wrap = function(fn) {\n\tif (REGEXP_NEWOPERATION.test(fn.toString())) {\n\t\tvar fnnew = function(req, res, flags, next) {\n\t\t\tfn(new AuthOptions(req, res, flags, next));\n\t\t};\n\t\tfnnew.$newversion = true;\n\t\treturn fnnew;\n\t}\n\treturn fn;\n};\n\nglobal.CONVERT = function(value, schema) {\n\tvar key = schema;\n\tif (key.length > 50)\n\t\tkey = key.hash();\n\tvar fn = F.convertors2 && F.convertors2[key];\n\treturn fn ? fn(value) : convertorcompile(schema, value, key);\n};\n\nfunction convertorcompile(schema, data, key) {\n\tvar prop = schema.split(',');\n\tvar cache = [];\n\tfor (var i = 0, length = prop.length; i < length; i++) {\n\t\tvar arr = prop[i].split(':');\n\t\tvar obj = {};\n\n\t\tvar type = arr[1].toLowerCase().trim();\n\t\tvar size = 0;\n\t\tvar isarr = type[0] === '[';\n\t\tif (isarr)\n\t\t\ttype = type.substring(1, type.length - 1);\n\n\t\tvar index = type.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tsize = +type.substring(index + 1, type.length - 1).trim();\n\t\t\ttype = type.substring(0, index);\n\t\t}\n\n\t\tobj.name = arr[0].trim();\n\t\tobj.size = size;\n\t\tobj.type = type;\n\t\tobj.array = isarr;\n\n\t\tswitch (type) {\n\t\t\tcase 'string':\n\t\t\t\tobj.fn = $convertstring;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\t\tobj.fn = $convertnumber;\n\t\t\t\tbreak;\n\t\t\tcase 'number2':\n\t\t\t\tobj.fn = $convertnumber2;\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\tobj.fn = $convertboolean;\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\t\tobj.fn = $convertdate;\n\t\t\t\tbreak;\n\t\t\tcase 'uid':\n\t\t\t\tobj.fn = $convertuid;\n\t\t\t\tbreak;\n\t\t\tcase 'upper':\n\t\t\t\tobj.fn = (val, obj) => $convertstring(val, obj).toUpperCase();\n\t\t\t\tbreak;\n\t\t\tcase 'lower':\n\t\t\t\tobj.fn = (val, obj) => $convertstring(val, obj).toLowerCase();\n\t\t\t\tbreak;\n\t\t\tcase 'capitalize':\n\t\t\t\tobj.fn = (val, obj) => $convertstring(val, obj).capitalize();\n\t\t\t\tbreak;\n\t\t\tcase 'capitalize2':\n\t\t\t\tobj.fn = (val, obj) => $convertstring(val, obj).capitalize(true);\n\t\t\t\tbreak;\n\t\t\tcase 'base64':\n\t\t\t\tobj.fn = val => typeof(val) === 'string' ? val.isBase64() ? val : '' : '';\n\t\t\t\tbreak;\n\t\t\tcase 'email':\n\t\t\t\tobj.fn = function(val, obj) {\n\t\t\t\t\tvar tmp = $convertstring(val, obj);\n\t\t\t\t\treturn tmp.isEmail() ? tmp : '';\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'zip':\n\t\t\t\tobj.fn = function(val, obj) {\n\t\t\t\t\tvar tmp = $convertstring(val, obj);\n\t\t\t\t\treturn tmp.isZIP() ? tmp : '';\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'phone':\n\t\t\t\tobj.fn = function(val, obj) {\n\t\t\t\t\tvar tmp = $convertstring(val, obj);\n\t\t\t\t\treturn tmp.isPhone() ? tmp : '';\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'url':\n\t\t\t\tobj.fn = function(val, obj) {\n\t\t\t\t\tvar tmp = $convertstring(val, obj);\n\t\t\t\t\treturn tmp.isURL() ? tmp : '';\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\tobj.fn = function(val, obj) {\n\t\t\t\t\tvar tmp = $convertstring(val, obj);\n\t\t\t\t\treturn tmp.isJSON() ? tmp : '';\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\treturn val => val;\n\t\t\tcase 'search':\n\t\t\t\tobj.fn = (val, obj) => $convertstring(val, obj).toSearch();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tobj.fn = val => val;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (isarr) {\n\t\t\tobj.fn2 = obj.fn;\n\t\t\tobj.fn = function(val, obj) {\n\t\t\t\tif (!(val instanceof Array))\n\t\t\t\t\tval = val == null || val == '' ? [] : [val];\n\t\t\t\tvar output = [];\n\t\t\t\tfor (var i = 0, length = val.length; i < length; i++) {\n\t\t\t\t\tvar o = obj.fn2(val[i], obj);\n\t\t\t\t\tswitch (obj.type) {\n\t\t\t\t\t\tcase 'email':\n\t\t\t\t\t\tcase 'phone':\n\t\t\t\t\t\tcase 'zip':\n\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\tcase 'url':\n\t\t\t\t\t\tcase 'uid':\n\t\t\t\t\t\tcase 'date':\n\t\t\t\t\t\t\to && output.push(o);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\toutput.push(o);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn output;\n\t\t\t};\n\t\t}\n\n\t\tcache.push(obj);\n\t}\n\n\tvar fn = function(data) {\n\t\tvar output = {};\n\t\tfor (var i = 0, length = cache.length; i < length; i++) {\n\t\t\tvar item = cache[i];\n\t\t\toutput[item.name] = item.fn(data[item.name], item);\n\t\t}\n\t\treturn output;\n\t};\n\tif (!F.convertors2)\n\t\tF.convertors2 = {};\n\tF.convertors2[key] = fn;\n\treturn fn(data);\n}\n\nfunction $convertstring(value, obj) {\n\treturn value == null ? '' : typeof(value) !== 'string' ? obj.size ? value.toString().max(obj.size) : value.toString() : obj.size ? value.max(obj.size) : value;\n}\n\nfunction $convertnumber(value) {\n\tif (value == null)\n\t\treturn 0;\n\tif (typeof(value) === 'number')\n\t\treturn value;\n\tvar num = +value.toString().replace(',', '.');\n\treturn isNaN(num) ? 0 : num;\n}\n\nfunction $convertnumber2(value) {\n\tif (value == null)\n\t\treturn null;\n\tif (typeof(value) === 'number')\n\t\treturn value;\n\tvar num = +value.toString().replace(',', '.');\n\treturn isNaN(num) ? null : num;\n}\n\nfunction $convertboolean(value) {\n\treturn value == null ? false : value === true || value == '1' || value === 'true' || value === 'on';\n}\n\nfunction $convertuid(value) {\n\treturn value == null ? '' : typeof(value) === 'string' ? value.isUID() ? value : '' : '';\n}\n\nfunction $convertdate(value) {\n\n\tif (value == null)\n\t\treturn null;\n\n\tif (value instanceof Date)\n\t\treturn value;\n\n\tswitch (typeof(value)) {\n\t\tcase 'string':\n\t\tcase 'number':\n\t\t\treturn value.parseDate();\n\t}\n\n\treturn null;\n}\n\n// ======================================================\n// EXPORTS\n// ======================================================\n\nexports.SchemaBuilder = SchemaBuilder;\nexports.RESTBuilder = RESTBuilder;\nexports.ErrorBuilder = ErrorBuilder;\nexports.Pagination = Pagination;\nexports.Page = Page;\nexports.UrlBuilder = UrlBuilder;\nexports.SchemaOptions = SchemaOptions;\nexports.OperationOptions = OperationOptions;\nexports.RESTBuilderResponse = RESTBuilderResponse;\nexports.AuthOptions = AuthOptions;\nglobal.RESTBuilder = RESTBuilder;\nglobal.RESTBuilderResponse = RESTBuilderResponse;\nglobal.ErrorBuilder = ErrorBuilder;\nglobal.Pagination = Pagination;\nglobal.Page = Page;\nglobal.UrlBuilder = global.URLBuilder = UrlBuilder;\nglobal.SchemaBuilder = SchemaBuilder;\nglobal.TaskBuilder = TaskBuilder;\n\n// Uninstall owners\nexports.uninstall = function(owner) {\n\n\tif (!owner)\n\t\treturn;\n\n\tObject.keys(operations).forEach(function(key) {\n\t\tif (operations[key].$owner === owner)\n\t\t\tdelete operations[key];\n\t});\n\n\texports.eachschema(function(group, name, schema) {\n\t\tschema.owner === owner && schema.destroy();\n\t});\n};\n\nTaskBuilderProto.invalid = function(err, msg) {\n\tvar self = this;\n\tif (!self.$done) {\n\t\t!self.error && (self.error = new ErrorBuilder());\n\t\tself.error.push(err, msg);\n\t\tself.done();\n\t}\n\treturn self;\n};\n\nTaskBuilderProto.push = function(name, fn) {\n\tvar self = this;\n\tself.tasks[name] = fn;\n\treturn self;\n};\n\nTaskBuilderProto.next = function() {\n\tvar self = this;\n\tif (!self.$done) {\n\t\tself.current && self.controller && CONF.logger && F.ilogger((self.name || 'tasks') + '.' + self.current, self.controller, self.$now);\n\t\tself.prev = self.current;\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tself.current = arguments[i];\n\t\t\tvar task = self.tasks[self.current] || (self.taskname ? tasks[self.taskname] && tasks[self.taskname][self.current] : null);\n\t\t\tif (task == null)\n\t\t\t\tcontinue;\n\t\t\telse {\n\t\t\t\ttask.call(self, self);\n\t\t\t\treturn self;\n\t\t\t}\n\t\t}\n\t\tself.done();\n\t}\n\treturn self;\n};\n\nTaskBuilderProto.next2 = function(name) {\n\tvar self = this;\n\treturn function(err) {\n\t\tif (err)\n\t\t\tself.invalid(err);\n\t\telse {\n\t\t\tif (name == null)\n\t\t\t\tself.done();\n\t\t\telse\n\t\t\t\tself.next(name);\n\t\t}\n\t};\n};\n\nTaskBuilderProto.done = function(data) {\n\tvar self = this;\n\tself.$callback && self.$callback(self.error && self.error.is ? self.error : null, data || self.value);\n\tself.$done = true;\n\treturn self;\n};\n\nTaskBuilderProto.done2 = function(send_value) {\n\tvar self = this;\n\treturn function(err, data) {\n\t\tif (err)\n\t\t\tself.invalid(err);\n\t\telse\n\t\t\tself.done(send_value ? data : null);\n\t};\n};\n\nTaskBuilderProto.success = function(data) {\n\treturn this.done(SUCCESS(true, data));\n};\n\nTaskBuilderProto.success2 = function(send_value) {\n\tvar self = this;\n\treturn function(err, data) {\n\t\tif (err)\n\t\t\tself.invalid(err);\n\t\telse\n\t\t\tself.done(SUCCESS(true, send_value ? data : null));\n\t};\n};\n\nTaskBuilderProto.callback = function(fn) {\n\tvar self = this;\n\tself.$callback = fn;\n\treturn self;\n};\n\nTaskBuilderProto.exec = function(name, callback) {\n\tvar self = this;\n\n\tif (callback)\n\t\tself.$callback = callback;\n\n\tif (CONF.logger)\n\t\tself.$now = Date.now();\n\n\tself.next(name);\n\treturn self;\n};"
        },
        {
          "name": "bundles.js",
          "type": "blob",
          "size": 10.025390625,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkBundles\n * @version 3.4.3\n */\n\nrequire('./index');\n\nconst Fs = require('fs');\nconst Path = require('path');\nconst CONSOLE = process.argv.indexOf('restart') === -1;\nconst INTERNAL = { '/sitemap': 1, '/versions': 1, '/workflows': 1, '/dependencies': 1, '/config': 1, '/config-release': 1, '/config-debug': 1 };\nconst isWindows = require('os').platform().substring(0, 3).toLowerCase() === 'win';\nconst REGAPPEND = /\\/--[a-z0-9]+/i;\nconst REGAPPENDREPLACE = /\\/--/g;\nconst REGBK = /(-|_)bk\\.bundle$/i;\nconst META = {};\n\nMETA.version = 1;\nMETA.created = new Date();\nMETA.total = 'v' + F.version_header;\nMETA.node = F.version_node;\nMETA.files = [];\nMETA.skip = false;\nMETA.directories = [];\nMETA.ignore = () => true;\n\nexports.make = function(callback) {\n\n\tvar path = F.path.root();\n\tvar blacklist = {};\n\n\tif (CONSOLE) {\n\t\tconsole.log('--------------------- BUNDLING ---------------------');\n\t\tconsole.time('Done');\n\t}\n\n\tvar isignore = false;\n\n\ttry {\n\t\tMETA.ignore = makeignore(Fs.readFileSync(Path.join(path, '.bundleignore')).toString('utf8').split('\\n'));\n\t\tisignore = true;\n\t} catch (e) {}\n\n\tif (!isignore) {\n\t\ttry {\n\t\t\tMETA.ignore = makeignore(Fs.readFileSync(Path.join(path, '.bundlesignore')).toString('utf8').split('\\n'));\n\t\t} catch (e) {}\n\t}\n\n\tblacklist[CONF.directory_temp] = 1;\n\tblacklist[CONF.directory_bundles] = 1;\n\tblacklist[CONF.directory_src] = 1;\n\tblacklist[CONF.directory_logs] = 1;\n\tblacklist['/node_modules/'] = 1;\n\tblacklist['/debug.pid'] = 1;\n\tblacklist['/package-lock.json'] = 1;\n\n\tvar Files = [];\n\tvar Dirs = [];\n\tvar Merge = [];\n\tvar Length = path.length;\n\tvar async = [];\n\n\tasync.push(cleanFiles);\n\n\tasync.push(function(next) {\n\t\tMETA.skip && (async.length = 0);\n\t\tnext();\n\t});\n\n\tasync.push(function(next) {\n\t\tvar target = F.path.root(CONF.directory_src);\n\t\tU.ls(F.path.root(CONF.directory_bundles), function(files) {\n\t\t\tvar dirs = {};\n\t\t\tfiles.wait(function(filename, resume) {\n\n\t\t\t\tif (!filename.endsWith('.bundle') || REGBK.test(filename))\n\t\t\t\t\treturn resume();\n\n\t\t\t\tif (CONSOLE)\n\t\t\t\t\tconsole.log('-----', U.getName(filename));\n\n\t\t\t\tvar dbpath = CONF.directory_databases;\n\t\t\t\tvar pathupdate = CONF.directory_updates;\n\t\t\t\tvar pathstartup = '/startup';\n\n\t\t\t\tF.restore(filename, target, resume, function(p, dir) {\n\n\t\t\t\t\tif (dir) {\n\t\t\t\t\t\tif (!p.startsWith(dbpath) && META.directories.indexOf(p) === -1)\n\t\t\t\t\t\t\tMETA.directories.push(p);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar dirname = p.substring(0, p.length - U.getName(p).length);\n\t\t\t\t\t\tif (dirname && dirname !== '/')\n\t\t\t\t\t\t\tdirs[dirname] = true;\n\n\t\t\t\t\t\t// handle files in bundle to merge\n\t\t\t\t\t\tvar mergeme = 0;\n\n\t\t\t\t\t\tif (REGAPPEND.test(p)) {\n\t\t\t\t\t\t\tmergeme = 3;\n\t\t\t\t\t\t\tp = p.replace(REGAPPENDREPLACE, '/');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar exists = false;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\texists = Fs.statSync(Path.join(target, p)) != null;\n\t\t\t\t\t\t} catch (e) {}\n\n\t\t\t\t\t\tif ((dirname === pathupdate || dirname === pathstartup) && !exists) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\texists = Fs.statSync(Path.join(target, p + '_bk')) != null;\n\t\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// A specific file like DB file or startup file or update script\n\t\t\t\t\t\tif (exists && (p.startsWith(dbpath) || p.startsWith(pathupdate) || p.startsWith(pathstartup)))\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\tif (INTERNAL[p] || U.getExtension(p) === 'resource' || mergeme) {\n\t\t\t\t\t\t\tvar hash = p.hash(true).toString(16);\n\t\t\t\t\t\t\tMerge.push({ name: p, filename: Path.join(target, p + hash), type: mergeme });\n\t\t\t\t\t\t\tMETA.files.push(p + hash);\n\t\t\t\t\t\t\treturn p + hash;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (META.files.indexOf(p) === -1)\n\t\t\t\t\t\t\tMETA.files.push(p);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}, function() {\n\t\t\t\tdirs = Object.keys(dirs);\n\t\t\t\tdirs.length && Dirs.push.apply(Dirs, dirs);\n\t\t\t\tnext();\n\t\t\t});\n\t\t});\n\t});\n\n\tasync.push(function(next) {\n\t\tif (Merge.length) {\n\t\t\tcopyFiles(Merge, function() {\n\t\t\t\tfor (var i = 0; i < Merge.length; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tFs.unlinkSync(Merge[i].filename);\n\t\t\t\t\t} catch(e) {}\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t} else\n\t\t\tnext();\n\t});\n\n\tasync.push(function(next) {\n\t\tU.ls(path, function(files, dirs) {\n\n\t\t\tfor (var i = 0, length = dirs.length; i < length; i++)\n\t\t\t\tDirs.push(normalize(dirs[i].substring(Length)));\n\n\t\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\t\t\t\tvar file = files[i].substring(Length);\n\t\t\t\tvar type = 0;\n\n\t\t\t\tif (file.startsWith(CONF.directory_databases) || file.startsWith('/flow/') || file.startsWith('/dashboard/'))\n\t\t\t\t\ttype = 1;\n\t\t\t\telse if (REGAPPEND.test(file)) {\n\t\t\t\t\tfile = file.replace(REGAPPENDREPLACE, '/');\n\t\t\t\t\ttype = 3;\n\t\t\t\t} else if (file.startsWith(CONF.directory_public))\n\t\t\t\t\ttype = 2;\n\n\t\t\t\tFiles.push({ name: file, filename: files[i], type: type });\n\t\t\t}\n\n\t\t\tnext();\n\t\t}, function(p) {\n\t\t\tp = normalize(p.substring(Length));\n\t\t\treturn blacklist[p] == null && p.substring(0, 2) !== '/.';\n\t\t});\n\t});\n\n\tasync.push(function(next) {\n\t\tcreateDirectories(Dirs, function() {\n\t\t\tcopyFiles(Files, next);\n\t\t});\n\t});\n\n\tasync.push(function(next) {\n\t\tFs.writeFileSync(Path.join(F.path.root(CONF.directory_src), 'bundle.json'), JSON.stringify(META, null, '\\t'));\n\t\tnext();\n\t});\n\n\tasync.async(function() {\n\t\tCONSOLE && console.timeEnd('Done');\n\t\tcallback();\n\t});\n\n};\n\nfunction makeignore(arr) {\n\n\tvar ext;\n\tvar code = ['var path=P.substring(0,P.lastIndexOf(\\'/\\')+1);', 'var ext=U.getExtension(P);', 'var name=U.getName(P).replace(\\'.\\'+ ext,\\'\\');'];\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar item = arr[i];\n\t\tvar index = item.lastIndexOf('*.');\n\n\t\tif (index !== -1) {\n\t\t\t// only extensions on this path\n\t\t\text = item.substring(index + 2);\n\t\t\titem = item.substring(0, index);\n\t\t\tcode.push('tmp=\\'{0}\\';'.format(item));\n\t\t\tcode.push('if((!tmp||path===tmp)&&ext===\\'{0}\\')return;'.format(ext));\n\t\t\tcontinue;\n\t\t}\n\n\t\text = U.getExtension(item);\n\t\tif (ext) {\n\t\t\t// only filename\n\t\t\tindex = item.lastIndexOf('/');\n\t\t\tcode.push('tmp=\\'{0}\\';'.format(item.substring(0, index + 1)));\n\t\t\tcode.push('if(path===tmp&&U.getName(\\'{0}\\').replace(\\'.{1}\\', \\'\\')===name&&ext===\\'{1}\\')return;'.format(item.substring(index + 1), ext));\n\t\t\tcontinue;\n\t\t}\n\n\t\t// all nested path\n\t\tcode.push('if(path.startsWith(\\'{0}\\'))return;'.format(item.replace('*', '')));\n\t}\n\n\tcode.push('return true');\n\treturn new Function('P', code.join(''));\n}\n\nfunction normalize(path) {\n\treturn isWindows ? path.replace(/\\\\/g, '/') : path;\n}\n\nfunction cleanFiles(callback) {\n\n\tvar path = F.path.root(CONF.directory_src);\n\tvar length = path.length - 1;\n\tvar blacklist = {};\n\n\tblacklist[CONF.directory_public] = 1;\n\tblacklist[CONF.directory_private] = 1;\n\tblacklist[CONF.directory_databases] = 1;\n\n\tvar meta;\n\n\ttry {\n\t\tmeta = U.parseJSON(Fs.readFileSync(Path.join(path, 'bundle.json')).toString('utf8'), true) || {};\n\n\t\tif (CONF.bundling === 'shallow') {\n\t\t\tMETA.skip = true;\n\t\t\tcallback();\n\t\t\treturn;\n\t\t}\n\n\t} catch (e) {\n\t\tmeta = {};\n\t}\n\n\tif (meta.files && meta.files.length) {\n\t\tfor (var i = 0, length = meta.files.length; i < length; i++) {\n\t\t\tvar filename = meta.files[i];\n\t\t\tvar dir = filename.substring(0, filename.indexOf('/', 1) + 1);\n\t\t\tif (!blacklist[dir]) {\n\t\t\t\ttry {\n\t\t\t\t\tF.consoledebug('Remove', filename);\n\t\t\t\t\tFs.unlinkSync(Path.join(path, filename));\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (meta.directories && meta.directories.length) {\n\t\tmeta.directories.quicksort('length', false);\n\t\tfor (var i = 0, length = meta.directories.length; i < length; i++) {\n\t\t\ttry {\n\t\t\t\tif (!blacklist[meta.directories[i]])\n\t\t\t\t\tFs.rmdirSync(Path.join(path, meta.directories[i]));\n\t\t\t} catch (e) {}\n\t\t}\n\t}\n\n\tcallback();\n}\n\nfunction createDirectories(dirs, callback) {\n\n\tvar path = F.path.root(CONF.directory_src);\n\n\ttry {\n\t\tFs.mkdirSync(path);\n\t} catch(e) {}\n\n\tfor (var i = 0, length = dirs.length; i < length; i++) {\n\t\tvar p = normalize(dirs[i]);\n\t\tif (META.directories.indexOf(p) === -1)\n\t\t\tMETA.directories.push(p);\n\t\ttry {\n\t\t\tFs.mkdirSync(Path.join(path, dirs[i]));\n\t\t} catch (e) {}\n\t}\n\n\tcallback();\n}\n\nfunction copyFiles(files, callback) {\n\tvar path = F.path.root(CONF.directory_src);\n\tfiles.wait(function(file, next) {\n\n\t\tif (!META.ignore(file.name))\n\t\t\treturn next();\n\n\t\tvar filename = Path.join(path, file.name);\n\t\tvar exists = false;\n\t\tvar ext = U.getExtension(file.name);\n\t\tvar append = file.type === 3;\n\n\t\ttry {\n\t\t\texists = Fs.statSync(filename) != null;\n\t\t} catch (e) {}\n\n\t\t// DB file\n\t\tif (file.type === 1 && exists) {\n\t\t\tnext();\n\t\t\treturn;\n\t\t}\n\n\t\tvar p = normalize(file.name);\n\n\t\tif (file.type !== 1 && META.files.indexOf(p) === -1)\n\t\t\tMETA.files.push(p);\n\n\t\tif (exists && (ext === 'resource' || (!ext && file.name.substring(1, 7) === 'config') || INTERNAL[file.name]))\n\t\t\tappend = true;\n\n\t\tif (CONSOLE && exists) {\n\t\t\tCONF.allow_debug && F.consoledebug(append ? 'EXT:' : 'REW:', p);\n\t\t} else\n\t\t\tF.consoledebug(append ? 'EXT:' : 'COP:', p);\n\n\t\tif (append) {\n\t\t\tFs.appendFile(filename, '\\n' + Fs.readFileSync(file.filename).toString('utf8'), next);\n\t\t} else\n\t\t\tcopyFile(file.filename, filename, next);\n\n\t\tif (CONSOLE && exists)\n\t\t\tCONF.allow_debug && F.consoledebug('REW:', p);\n\t\telse\n\t\t\tF.consoledebug('COP:', p);\n\n\t}, callback);\n}\n\nfunction copyFile(oldname, newname, callback) {\n\tvar writer = Fs.createWriteStream(newname);\n\twriter.on('finish', callback);\n\tFs.createReadStream(oldname).pipe(writer);\n}\n"
        },
        {
          "name": "changes.txt",
          "type": "blob",
          "size": 142.962890625,
          "content": "======= 3.4.13\n\n- fixed wrong counting of week number in the `Date.format()`\n\n======= 3.4.12\n\n- (critical) fixed WebSocket implementation for Safari +15\n- (critical) fixed extracting packages/bundles\n\n======= 3.4.11\n\n- fixed calling `F.snapshotstats()` #785\n- improved RegExp for validating URL addresses by [yetingli](https://github.com/yetingli)\n\n======= 3.4.10\n\n- fixed CSS variables\n\n======= 3.4.9\n\n- added HTML escaping for meta tags\n- added `insecure` flag into the `U.request()` method\n- added `RESTBuilder.insecure()` method\n- fixed security issue when parsing query arguments (reported by <https://github.com/fl4x>)\n- fixed security in `U.get()` and `U.set()` (reported by Agustin Gianni)\n\n======= 3.4.8\n\n- fixed measuring dimension for `.gif` images\n- fixed potential remote code execution in `U.set()` founded by [Snyk](https://snyk.io/vuln)\n\n======= 3.4.7\n\n- fixed: command injection in `Image.pipe()` and `Image.stream()`\n- fixed `DELETE` method for the schemas (now it works like `PATCH` method)\n- fixed: `controller.transfer()`\n\n======= 3.4.6\n\n- added: a support for Total.js v4 UIDs\n\n- updated: file stats\n- updated: calculating of `usage`\n\n- fixed: applying of `default_root` in static files\n- fixed: routing evaluation\n- fixed: parsing of longer WebSocket messages\n- fixed: mail error handling\n- fixed: `versions` with `default_root`\n\n======= 3.4.5\n\n- fixed: a problem with persistent images\n\n======= 3.4.4\n\n- added: schema options `$.successful(function(response) {})`\n- added: `options.reconnectserver {Boolean}`  to `WEBSOCKETCLIENT`\n- added: `req.snapshot(callback(err, request_body))`\n- added: a new command `CMD('reload_preferences')`\n- added: a new FILESTORAGE mechanism based on `UID`\n- added: `sql` extension to `U.getContentType()`\n- added: `F.stats.performance.usage` which contains percentual usage of the thread\n\n- updated: `SchemaOptions` method `$.response([index/operation_name])`, e.g. `$.response('workflow.NAME')`\n- updated: snapshot `startscript.js.json` contains tabs instead of spaces\n- updated: `DatabaseBuilder.rule(rule, [param])`, supports string declaration of filter function\n- updated: `URL` validation\n\n- fixed: cleaning of NoSQL embedded databases\n- fixed: `String.parseCSV()`, now supports multiline strings\n- fixed: a bug when closing of websocket\n- fixed: `DatabaseBuilder.search()` method\n- fixed: `Error` in `CLONE()` method\n- fixed: `schema.inherit()` by adding `schema.middleware()` and `schema.verify()`\n- fixed: parsing messages in WebSocket\n- fixed: a problem in some commands pre-render in the view compiler\n- fixed: parsing of query strings\n\n======= 3.4.3\n\n- added: `HASH(value, [type])` for creating hash like in jComponent\n- added: `SchemaOptions.repo` as alias to `SchemaInstance.model.$$repository`\n- added: a new type `CONVERT syntax` to `schema.define()` (more in docs)\n- added: `SchemaEntity.verify(name, function($), [cache])` for async verification of values\n- added: `TEMP` variable as a new global variable (it's cleaned every 7 minutes)\n- added: `CONF.allow_persistent_images: true` which allows to reuse resized images in temp directory\n- added: `req.filecache(callback)` as alias for `F.exists()`\n- added: own QueryParser\n- added: `RESTBuilderInstance.convert('name:String,age:Number')` method\n- added: `RESTBuilder.upgrade(fn(restbuilder))` for upgrading of `RESTBuilder`\n- added: `RESTBuilder` parses Total.js Errors in responses as Error\n- added: `String.prototype.env()` replaces all values in the form `[key]` for `CONF.key`\n- added: WebSocket supports a new type - raw `buffer`\n- added: `Number.fixed(decimals)`\n\n- updated: `websocket.send2(message, comparer, replacer, [params])` by adding `params` argument for comparer function\n- updated: `Websocket.encodedecode` can enable/disable easily encoding of messages\n- updated: bundling skips all bundles with `-bk.bundle` in filename\n- updated: bundle filenames are displayed in console\n- updated: `UPDATE()` method by adding `noarchive` argument\n- updated: `TEST()` method supports `[subdomain]` keyword and `METHOD url` in URL address\n- updated: `MODIFY([filename], fn)` by adding `filename` argument\n- updated: background of schedulers by @fgnm\n- updated: `U.download()` by adding `param` argument\n- updated: `U.request()` by adding `param` argument\n- updated: `schema.cl(name, [value])` method by adding `value` argument for replacing of existing code-list\n- updated: Tangular version to `v4.0.0`\n\n- improved: `filename` in modificators (now filenames contain relative paths)\n- improved: performance of `U.request()` (around +10%)\n- improved: performance of `U.download()` (around +10%)\n- improved: performance of `RESTBuilder`\n- improved: CSS minifier by compressing single hex color from e.g. `#000000` to `#000`\n\n- fixed: localization in `totaljs` executable script\n- fixed: phone validation\n- fixed: `DOWNLOAD()`\n- fixed: `Number.VAT()` by Tomas Novak\n- fixed: debugging mode in Node.js v14\n- fixed: `allow_compile_html` in static files\n- fixed: `ROUTE()` method, there was a problem with spaces `GET /*      `\n- fixed: `ACTION()` with json output\n- fixed: controller in `$ACTION()` with used `get` and `query` actions\n- fixed: `PATCH` method in `$ACTION()`\n- fixed: `schema.allow()` in `PATCH` method\n- fixed: image resizing in debug-mode\n\n======= 3.4.1\n\n- added: `SchemaOptions.parent` returns a parent model\n- added: Tangular template engine (experimental)\n- added: `String.makeid()` for creating of unique identifier from string\n- added: a new property called `message.ua` to `FLOWSTREAM()`\n\n- updated: `HttpFile.fs()` by adding `id` argument for updating of existing file\n- updated: default value for `allow_ssc_validation` to `true`\n\n- fixed: `String.parseDate(format)` with defined format\n- fixed: inheriting of controllers between schemas\n- fixed: `MailMessage.attachments()`\n- fixed: calling of `F.snapshotstats` in cache recycle\n- fixed: `controller.success()`\n- fixed: removing of unused files when a bundle is extracting\n- fixed: a processor function in `F.backup()`\n\n- improved: `Date.format()`\n- improved: Total.js translate (supports ErrorBuilder and DBMS)\n\n======= 3.4.0\n\n- added: `date.setTimeZone(timezone)`\n- added: `NOSQL('~absolute_path.nosql')' loads external NoSQL embedded database\n- added: `TABLE('~absolute_path.nosql')' loads external Table\n- added: `(generate)` subtype into the `config` files\n- added: `String.isBase64()`\n- added: new schema type `Base64`\n- added: SchemaEntity supports `schema.addWorkflowExtension(name, fn($, [data]))`\n- added: SchemaEntity supports `schema.addTransformExtension(name, fn($, [data]))`\n- added: SchemaEntity supports `schema.addOperationExtension(name, fn($, [data]))`\n- added: SchemaEntity supports `schema.addHookExtension(name, fn($, [data]))`\n- added: SchemaEntity supports `schema.setSaveExtension(fn($, [data]))`\n- added: SchemaEntity supports `schema.setReadExtension(fn($, [data]))`\n- added: SchemaEntity supports `schema.setQueryExtension(fn($, [data]))`\n- added: SchemaEntity supports `schema.setRemoveExtension(fn($, [data]))`\n- added: SchemaEntity supports `schema.setInsertExtension(fn($, [data]))`\n- added: SchemaEntity supports `schema.setUpdateExtension(fn($, [data]))`\n- added: SchemaEntity supports `schema.setPatchExtension(fn($, [data]))`\n- added: SchemaOptions supports `$.extend([data])` for evaluating of all extensions for the current operation\n- added: `WebSocket.keys` property (it contains all keys with connections)\n- added: `threads` directory for server-less functionality\n- added: a global variable called `THREAD` with a name of current thread\n- added: `require('total.js').http(..., { thread: 'thread_name' })` evaluates only specified thread\n- added: `require('total.js').cluster.http(..., { thread: 'thread_name' })` evaluates only specified thread in cluster\n- added: framework creates a file with app stats in the form `your_init_script_name.js.json`\n- added: a new config key `allow_stats_snapshot`\n- added: view engine `@{import()}` supports auto-merging JS or CSS files: `@{import('default.js + ui.js')}`\n- added: `exports.options` delegate to component in `FLOWSTREAM`\n- added: `DatabaseBuilder.autofill()` from DBMS\n- added: `HttpFile.extension` property\n- added: `HttpFile.size` property alias to `HttpFile.length`\n- added: auto-session cleaner of unused sessions\n- added: `allow_sessions_unused` config key for cleaning of unused sessions\n- added: missing `PATH.schemas`, `PATH.operations` and `PATH.tasks`\n- added: a new method `PATH.updates`\n- added: easy updating of applications via `UPDATE(versions, [callback], [pause_server_message])`\n- added: NOSQL counter `.reset([type], [id], [date], [callback])` method-\n- added: `session.listlive(callback)` returns all live items in session\n- added: `controller.ua` returns parsed User-Agent\n- added: `$.ua` returns parsed User-Agent in Schemas, Operations, TaskBuilder, `MIDDLEWARE()` and `AUTH()`\n- added: support for `.mjs` extensions\n- added: a simple support for DDOS protection `allow_reqlimit : Number` (max. concurent requests by IP just-in-time)\n- added: unit-testing supports colors, added by @dacrhu\n- added: `String.encryptUID()` as alias for `U.encryptUID()`\n- added: `String.decryptUID()` as alias for `U.decryptUID()`\n\n- updated: `WEBSOCKET()` supports `+`, `-` and `ð` as authorization flags\n- updated: `LOAD()` supports `service` type\n- updated: cluster watches `restart` or `restart_NAME_of_THREAD` files for restarting of existing threads\n- updated: cluster supports `auto` mode\n- updated: cluster supports watcher in `debug` mode\n- updated: `*.filefs()`, `*.filenosql()`, `*.imagefs()`, `*.imagenosql()` by adding `checkmeta` argument\n- updated: `$.done([user_instance])` method in `AUTH()`, added a new argument called `user_instance` (optional)\n- updated: GZIP is enabled only for JSON bodies which have more than 4096 bytes\n- updated: `.env` parser supports parsing of `.env-debug` or `.env-release` files according to the mode\n- updated: list of user-agents in `String.parseUA()`\n\n- fixed: `ON('error404')` when the route doens't exist\n- fixed: `filter` in Schema `workflows`, `transformations` and `operations`\n- fixed: `NOSQL()` joins with absolute paths\n- fixed: `TABLE()` joins with absolute paths\n- fixed: `(random)` subtype in `config` files\n- fixed: `(response)` phrase in `ROUTE()` for multiple `OPERATIONS`\n- fixed: a response in `ROUTE()` with mulitple operations if the result contained some error\n- fixed: a security bug with a path traversal vulnerability\n- fixed: `debug` watcher for `themes`\n- fixed: `generators` in schemas with a new declaration\n- fixed: a problem with handling files in 404 action\n- fixed: `startup` directory in bundles\n- fixed: `schema.inherit()` didn't copy `required` fields.\n- fixed: `SUCCESS()` serialization with `SUCCESS()` argument\n- fixed: a critial bug with `UID()` generator\n- fixed: clearing of DNS cache\n\n- improved: `LOGMAIL()` mail format\n- improved: starting logs in console output (added IPv4 local address)\n- improved: performance with JSON serialization in `controller.success()` and `controller.done()`\n\n======= 3.3.2\n\n- fixed: default time zone (`utc` is default time zone)\n\n======= 3.3.1\n\n- added: `RESTBuilder.callback()` which performs `.exec()` automatically\n- added: `FLOWSTREAM()`\n\n- fixed: `AUDIT()` method\n- fixed: error handling in `controller.invalid()`\n- fixed: `req.authorize()`\n- fixed: CSS auto-vendor-prefixes, fixed `opacity` with `!important`\n- fixed: `CONVERT()` a problem with arrays\n\n======= 3.3.0\n\n- added: `NEWTASK(name, declaration)` for creating preddefined `TaskBuilder`\n- added: `TASK(name, taskname, callback, [controller/SchemaOptions/OperationOptions/ErrorBuilder])` for executing preddefined `TaskBuilder`\n- added: a new config key `directory_tasks` for `TaskBuilder`\n- added: a global alias `MODIFY()` for `F.modify()`\n- added: a global alias `VIEWCOMPILE()` for `F.view_compile()`\n- added: `mail.type = 'html'` can be `html` (default) or `plain`\n- added: `$.headers` into the `SchemaOptions`, `OperationOptions` and `TaskBuilder`\n- added: `String.parseCSV([delimiter])` returns `Object Array`\n- added: `String.parseUA([structured])` a simple user-agent parser\n- added: `req.useragent([structured])` returns parsed User-Agent\n- added: a new config key `default_crypto` it can rewrite Total.js crypto mechanism (default: `undefined`)\n- added: a new config key `default_crypto_iv` it's an initialization vector (default: generated from `secret`) or it can contain a custom `hex` value\n- added: a new config key `allow_workers_silent` can enable/disable silent workers (default: `false`)\n- added: a new config sub-type called `random`, example: `secret_key    (random)  : 10` and `10` means a length of value\n- added: a new command `clear_dnscache` for clearing DNS cache\n- added: commands `INSTALL('command', 'command_name', function)` for registering commands and `CMD(name, [a], [b], [c], [d])` for executing commands\n- added: `ENCRYPTREQ(req, val, [key], [strict])` to encrypt value according to the request meta data\n- added: `DECRYPTREQ(req, val, [key])` to decrypt value according to the request meta data\n- added: `controller.nocache()`\n- added: `controller.nocontent()`\n- added: `REPO` as a global variable\n- added: `FUNC` as a global variable\n- added: `MAIN` as a global variable\n- added: `DEF` as a global variable for defining of behaviour for some operations (alternative to `F`)\n- added: `PREF.set(name, [value])` (read+write) or `PREF.propname` (only read) for reading/writing a persistent preferences\n- added: `F.onPrefSave = function(obj)` to write preferences\n- added: `F.onPrefLoad = function(next(obj))` to read preferences\n- added: `RESTBuilder.url(url)` which returns a new instance of `RESTBuilder` for chaining\n- added: `restbuilder.keepalive()` enables a keepalive for `RESTBuilder` instance\n- added: `SESSION()` management, more in docs\n- added: `controller.sessionid` with ID of `SESSION()`\n- added: `AUTH()` supports a new auth declaration with `$` as `AuthOptions` like `SchemaOptions` or `OperationOptions`\n- added: `AuthOptions` to prototypes\n- added: `ErrorBuilder.length` property (alias for `instance.items.length)\n- added: Schemas `prepare` supports `req` argument\n- added: `DEF.currencies.eur = function(val) {}` registers a currency formatter\n- added: `DEF.helpers` registers a new view engine helper (`F.helpers` is alias for for this object)\n- added: `DEF.validators` is alias for for `F.validators`\n- added: usage of currency formatter `Number.currency(currency)`\n- added: new schema type `Number2` with default value is `null`, not zero `0`\n- added: `@{json2(model, elementID, key1, key2, key3)}` can serialize data with keys defined into the `<script type=\"application/json\">`\n- added: schemas supports `PATCH` and `.setPatch()`, only specified field are processed\n- added: `SchemaOptions` supports `$.keys` for `PATCH` method\n- added: `schema.cl(name)` (\"cl\" means codelist) returns `{Array}` a list of values from defined enum/keyvalue\n- added: `schema.props()` returns `{Object}` meta info about all defined properties\n- added: `SchemaOptions`, `OperationOptions` and `TaskOptions` supports `$.req` and `$.res` properties\n- added: `AUDIT(name, $, [type], message)` a method for audit logs\n- added: __obsolete__ message to older declaration of middleware, schemas and operations\n- added: `U.diffarr(prop, arr_A, arr_B)` for comparing of two arrays\n- added: `DIFFARR(prop, arr_A, arr_B)` is a global alias for `U.diffarr()`\n- added: `global.REQUIRE()` for local modules within app directory\n- added: `global.isWORKER` variable which contains `true` (when the process is executed as a worker) or `false`\n- added: `ACTION(url, [data], callback)` can evaluate a route without request creation\n- added: `ROUTE('ð METHOD URL')`, it means that ð adds `authorized` flag\n- added: `ROUTE('+METHOD URL')`, it means that `++` or `+` adds `authorized` flag\n- added: `ROUTE('-METHOD URL')`, it means that `--` or `-` adds `authorized` flag\n- added: `SchemaOptions`, `OperationOptions`, `TaskOptions` supports filtered query arguments via `$.filter`\n- added: `controller.done([value])`\n- added: `SITEMAP()` as alias to `F.sitemap()`\n- added: config key `allow_localize` enables a localization for all `HTML` files\n- added: `controller.breadcrumb` returns all sitemap items\n- added: `PAUSESERVER(name, pause)` pauses web server (alias for `F.wait()`)\n- added: `PROXY(endpoint, hostname, [copypath], [before_fn(uri,req,res)], [after_fn(res)])` makes a direct proxy from webserver\n- added: `schema.middleware(function($, next))` for creating simple middlewares for Schema operations\n- added: `FILE404(fn(req, res))` performs a simple fallback for non-existing files\n- added: `$PATCH(schema, model, [options], callback, [controller])` method\n- added: `.env` parser to `process.env`\n- added: `String.parseENV()` for parsing `.env` syntax\n- added: `$.noop()` for custom responses\n- added: `$ACTION(schemaroute, [model], callback, [controller])` evaluates schema\n- added: `process.send('total:restart')` performs a restart of app when the app is in debug mode\n- added: `NOSQLREADER(filename)` for reading different files of NoSQL embedded databases\n- added: `TABLEREADER(filename)` for reading different files of Table embedded databases\n- added: `Mail.use()` an alias for `F.useSMTP()`\n- added: `F.onAudit(name, data)` delegate for handling audit logs\n- added: Components support a new features called `Parts`, more in docs\n\n- updated: `$.invalid()` without arguments can return a function `function(err)`\n- updated: Mail `unsubscribe` appends new header which enables `unsubscribe` in e.g. iOS\n- updated: `MODIFY`, handler contains a new argument `controller`\n- updated: `headers` argument in `controller.proxy` supports `flags: []` for REQEUST method\n- updated: `.filefs()` and `.filenosql()` supports `download` with `true` or with `(name, type) => 'new_name'` (`filename` will be read from NoSQL binary file)\n- updated: `$.done(arg)` argument `@arg` can be `boolean` (response will be as a value) or object/primitive value (`arg` will be as a value)\n- updated: `String.arg(obj, [encode], [def])` added `encode` (`true`, `json`, `html`) and `def` arguments\n- updated: `AUTH(req, res, flags, next)` and `next` function can handle `callback(err, user)`\n- updated: `REQUEST()` supports `keepalive` flag\n- updated: `bundles` mechanism supports merging files `--filename` between `bundles` files\n- updated: `String.hash(true)` returns unsigned int\n- updated: `CONF:default_image_converter` supports `magick` for new version of ImageMagick\n- updated: `CONF.default_image_consumption` can contain ZERO value which means disabled optimialization of CPU/memory consumption\n- updated: `CONF.default_image_consumption` has changed a default value to `0`\n- updated: `U.parseXML(str, [replace])` and `String.parseXML([replace])` contains a new argument called `replace`\n- updated: `LOAD()` added a callback function\n- updated: components support `encoding=\"utf8\"` attribute for `<file` tag (default: `base64`)\n- updated: `EventEmitter2` supports a new argument `obj`, example: `U.EventEmitter2(obj)` or supports `.extend` method: `U.EventEmitter2.extend(proto)`\n- updated: `UID()` generates new types of `UID` with 100% backward compatibility\n- updated: `FILESTORAGE()` now it works in cluster mode\n\n- fixed: schemas validation\n- fixed: error handling in dynamic schemas\n- fixed: CSS variables\n- fixed: CSS variables with additional `!important` clause\n- fixed: `controller.proxy()` with Gzip/Deflate compression\n- fixed: HTTP status code with `204` in `REQUEST()`\n- fixed: `cookies` in `WEBSOCKETCLIENT`\n- fixed: `REQUEST()` with `json` flag and with `null` and `''` value\n- fixed: rendering components in `layout`\n- fixed: resources, there was a bug with reading of value from `default.resource`\n- fixed: too many open files in `res.image()`\n- fixed: too many open files in `res.filefs()`\n- fixed: Schema `Boolean` parser\n- fixed: renamed `F.stats.request.path` to `F.stats.request.patch`\n- fixed: SMTP sender (a problem with auth mechanism with some mail servers)\n- fixed: filter in `F.backup()`\n- fixed: paths for stored directories in `F.backup()`\n- fixed: uploading files\n- fixed: `U.getExtension()` by @molda\n\n- renamed: `*.routeScript` to `*.public_js`\n- renamed: `*.routeStyle` to `*.public_css`\n- renamed: `*.routeFont` to `*.public_font`\n- renamed: `*.routeVideo` to `*.public_video`\n- renamed: `*.routeImage` to `*.public_image`\n- renamed: `*.routeDownload` to `*.public_download`\n- renamed: `*.routeStatic` to `*.public`\n- renamed: `controller.viewCompile()` to `controller.view_compile()`\n- renamed: event `cache-set` to `cache_set`:\n- renamed: event `controller-render-meta` to `controller_render_meta`\n- renamed: event `request-end` to `request_end`\n- renamed: event `websocket-begin` to `websocket_begin`\n- renamed: event `websocket-end` to `websocket_end`\n- renamed: event `request-begin` to `request_begin`\n- renamed: event `upload-begin` to `upload_begin`\n- renamed: event `upload-end` to `upload_end`\n- renamed: event `cache-expire` to `cache_expired`\n\n- __removed: backward compatibility__ with older version of Node.js < 10\n- removed: `F.hash()`, alternative `String.prototype.hash()`\n- removed: `controller.hash()`, alternative `String.prototype.hash()`\n\n- improved Schemas and error handling\n- improved `res.filefs()` method for nonexistent files\n\n======= 3.2.0\n\n- added: `WORKER()` alias to `F.worker()`\n- added: `WORKER2()` alias to `F.worker2()`\n- added: `F.cluster.https()`\n- added: `TaskBuilder.done2([send_value])` returns `function` with wrapped `.done()`\n- added: `TaskBuilder.success2([send_value])` returns `function` with wrapped `.success()`\n- added: `TaskBuilder.next2(name)` returns `function` with wrapped `.next()`\n- added: new `RESTBuilder` aliases `.DELETE()`, `.PUT()`, `.POST()`, `.PATCH() and `.GET()`\n- added: `schema.before(key, (value, model, index) => value)` is a simple and new alternative to `schema.setPrepare()`\n- added: `SchemaInstance.$parent` returns a parent schema (if the schema is nested schema)\n- added: `SchemaOptions.redirect(url)` can perform a redirect from the schema\n- added: `OperationOptions.redirect(url)` can perform a redirect from the operation\n- added: `.ics` extension as acceptable file for the web server\n\n- updated: `F.worker2()` returns entire `stdout` buffer in the `callback(err, buffer)`\n- updated: `$options()` by adding `disabled` key\n- updated: `String.ROOT()` by adding a support for jComponent `AJAX()` calls\n- updated: `RESTBuilder.method(method, [data])` added `data` argument\n- updated: `String.parseDate([format])` added `format` argument\n- updated: SMTP settings contain `heloid` as `heloidentifier` (manually can be defined `HELO` or `EHLO` command)\n- updated: SMTP hostname is computed from email if SMTP is not specified\n\n- fixed: critical bug with security + improved security\n- fixed: system routing\n- fixed: NoSQL sorting, solved a strange problem\n- fixed: `U.request()` with `GET` method by @khaledkhalil94 (it doesn't send JSON data if `data` is null/undefined)\n- fixed: `F.wait()` in WebSocket\n- fixed: `String.capitalize(true)`\n- fixed: `REQUEST()` uploading of additional multipart/form-data (removed encoding)\n- fixed: view engine conditions defined in `<script>`\n- fixed: auto-redirects in `U.download()`\n- fixed: image streams resizing\n- fixed: `@{'%config_key'}` a problem with rendering a value with `'`\n\n- removed: `X-Powered-By: Total.js`\n\n======= 3.1.0\n\n- added: CSS variables support default values `border-radius: $radius || 10px`\n- added: NoSQL storage `.find(beg, end, [threads])` + `.count(beg, end, [threads])` + '.scalar(beg, end, type, field, [threads])' with multiple thread support\n- added: `U.reader()`\n- added: `bundles` supports merging files between bundle and project, project file must start with e.g. `--name.js`\n- added: `.bundlesignore` support with similiar functionality like `.gitignore`\n- added: support for `SameSite` cookie attribute\n- added: `RUN()` for executing multiple Total.js operations\n- added: a new global alias `CONF` (it's a reference to config) for `F.config`\n- added: a new global alias `FUNC` (it's a reference to functions) for `F.functions`\n- added: `DatabaseBuilder.arg(key, value)` for adding an dynamic argument\n- added: NOSQL/TABLE modify supports `!field` as boolean toggle\n- added: NOSQL/TABLE modify supports a new type `$age: 'js_code'` with some JS code\n- added: NOSQL/TABLE update supports a new type `'js_code'` with some JS code\n- added: a new config item `default-restbuilder-timeout : 10000`\n- added: a new config item `default-cors : https://www.totaljs.com, https://www.componentator.com` which allows originators for `CORS()` method\n- added: a new config item `default-request-maxkeys : 33` for restricting query max. keys\n- added: a new config item `logger : false` which enables logging for Middleware, Schemas and Operations\n- added: a new config item `bundling : shallow` which enables shallow bundling (if `bundle.json` exists then the bundles won't be extracted)\n- added: `SchemaOptions` and `OperationOptions` supports `$.cancel()` method\n- added: `CACHE(name, [value], [expire], [persistent])` alias for `F.cache.get2()` and `F.cache.set()` or `F.cache.set2()`\n- added: encryption of config values\n- added: `F.refresh()` for refreshing of internal cache\n- added: `DatabaseBuilder.each(fn)` for browsing of evaluated records\n- added: Bundles can be downloaded from URL addresses\n- added: `ONCE()` alias to `F.once()`\n- added: `image.define(value)` performs `convert -define 'value'`\n- added: Total.js JS files (+ packages) tarted with `.` (dot) or ended with `-bk` won't be processed\n- added: A new builder called `TaskBuilder` for creating custom tasks in Schemas or Operations\n- added: `WebSocket.send2(message, [comparer(client, message)], [replacer])` a new method for better sending frames\n- addde: `PATH` as a global alias for `F.path`\n\n- updated: `debug` mode creates a `start_name_script.pid` instead of `debug.pid`\n- updated: `NEWOPERATION()` supports `repeat`, `stop` and `binderror` arguments (more in docs)\n- updated: routing, now it supports operations in the form `ROUTE('..  * --> @save_operation @load_operation (response)')`\n- updated: `ROUTE()` supports multiple HTTP method declaration `ROUTE('GET,POST,PUT /something/', action)`\n- updated: `ROUTE()` supports dynamic schemas\n- updated: `REQUEST()` can return binary data if the content-type is not `text/*` or `application/*`\n- updated: NoSQL joins support array values\n- updated: `ROUTING(id:|search, [flags])` method\n- updated: `F.path.mkdir(path, [cache])` can cache a current satte (default: false)\n- updated: `controller.all()` can return `Array` of all WebSocketClient\n- updated: startup info by adding user name\n- updated: `LOCALIZE()` now `url` arg can be a function which replaces `F.onLocale`\n\n- fixed: a critical bug with storing uploaded files via `httpfile.fs()` or `httpfile.nosql()`\n- fixed: a critical bug with JavaScript minificator\n- fixed: a critical bug with NoSQL counter and freezing app\n- fixed: a critical bug with rendering of multiple async components\n- fixed: a critical bug with GZIP compression (sometimes appeared in Safari)\n- fixed: `nosql.update()` and `nosql.modify()` methods if the first argument is a function\n- fixed: `F.wait()` in the test mode\n- fixed: `LOCALIZE()` for nested directories\n- fixed: sending of error handling when WebSocketClient is starting (for example: `unauthorized`)\n- fixed: `versions` and `auto` feature with enabled `F.wait()`\n- fixed: `versions` and `auto` feature with direct link to file\n- fixed: `LOAD('release')` a release mode\n- fixed: `SchemaInstance.$clean()` for nested schemas\n- fixed: extracting `bundles` (added `/flow/` and `/dashboard/`)\n- fixed: subdomain routing for `localhost`\n- fixed: service for database cleaner\n- fixed: rendering group of components\n- fixed: RESTBuilder - JSON request without param sends an empty object\n- fixed: `$MAKE()` with `callback`\n- fixed: `String.slug()` for UTF - Chinese/Japan/Arabic/etc. chars\n- fixed: async rendering of `components`\n- fixed: RESTBuilder cache works only if the response status is `200`\n- fixed: compressing CSS with `\\t` tabs\n- fixed: `controller.autoclear()`\n- fixed: `controller.proxy()`\n- fixed: `repeat` mode in `SCHEDULE()`\n- fixed: `--inspect` argument for Workers by Tema Smirnov\n- fixed: TLS in SMTP mail sender\n- fixed: applying of versions\n- fixed: unit-tests reads only `javascript` files\n- fixed: `controller.invalid()` a problem with ErrorBuilder as a argument\n\n- removed: `F.config.debug`\n- removed: `controller.isDebug`\n\n- improved: NoSQL reader\n- improved: `UID()` -> now it changes a random hash each minute\n- improved: CORS\n- improved: rendering of components\n\n======= 3.0.0\n\n- added: (IMPORTANT) bundles\n- added: (IMPORTANT) Total.js components can have async delegate\n- added: (IMPORTANT) Total.js components support nested public files encoded in base64\n- added: (IMPORTANT) NoSQL worker\n- added: (IMPORTANT) NoSQL embedded storage for smaller big data / IoT\n- added: `debugging` supports live reloading\n- added: new schema operations: `schema.setInsert()` and `schema.setUpdate()`\n- added: `RESTBuilder.patch([data])`\n- added: `RESTBuilder.type(new-content-type)`\n- added: `CONVERT(obj, schema)` for quick converting values like Schema (more in docs.)\n- added: `Capitalize2` schema type which converts only the first char\n- added: `MailMessage.high()` sets `high` priority of the email messsage\n- added: `MailMessage.low()` sets `low` priority of the email messsage\n- added: `MailMessage.confidential()` sets `Sensitivity` header with `confidential` value\n- added: `MailMessage.attachmentnosql(db, id, [name])` sends a file from NoSQL embedded database\n- added: `MailMessage.attachmentfs(storage_name, id, [name])` sends a file from FileStorage\n- added: `SchemaBuilderEntity.$stop()` stops the async list\n- added: `SchemaOptions.stop()` alias to `$.model.$stop()`\n- added: `SchemaOptions.next()` alias to `$.model.$next()`\n- added: `SchemaOptions.output()` alias to `$.model.$output()`\n- added: `SchemaOptions.clean()` alias to `$.model.$clean()`\n- added: `SchemaOptions.response()` alias to `$.model.$response([index])`\n- added: `SchemaOptions.$async(callback, [index])` alias to `$.model.$async()`\n- added: `SchemaOptions.$get([options], [callback])` alias to `$.model.$get()`\n- added: `SchemaOptions.$insert([options], [callback])` alias to `$.model.$insert()`\n- added: `SchemaOptions.$query([options], [callback])` alias to `$.model.$query()`\n- added: `SchemaOptions.$remove([options], [callback])` alias to `$.model.$remove()`\n- added: `SchemaOptions.$save([options], [callback])` alias to `$.model.$save()`\n- added: `SchemaOptions.$update([options], [callback])` alias to `$.model.$update()`\n- added: `SchemaOptions.$workflow(name, [options], [callback])` alias to `$.model.$workflow()`\n- added: `SchemaOptions.$transform(name, [options], [callback])` alias to `$.model.$transform()`\n- added: `SchemaOptions.$operation(name, [options], [callback])` alias to `$.model.$operation()`\n- added: `SchemaOptions.$hook(name, [options], [callback])` alias to `$.model.$hook()`\n- added: `SchemaOptions.stop()` alias to `$.model.$stop()`\n- added: a new route flag type `&group` something like `roles` but groups aren't evaluated\n- added: `route.groups` with defined groups\n- added: NoSQL `database.listing([view])` which generates a listing response\n- added: `DatabaseBuilder.insert(fn(doc))` can modify a document after `update` or `modify` has `insert` mode\n- added: `DatabaseBuilder.query(code)` can contain a raw JS condition in the form e.g. `doc.age > 18 && doc.age < 33`\n- added: `DatabaseBuilder.regexp(name, regexp)` RegExp search in strings\n- added: `DatabaseBuilder.fulltext(name, regexp, [weight])` full text search in strings, more info in docs.\n- added: `DatabaseBuilder.hour(name, [compare], value)` creates a condition for hours\n- added: `DatabaseBuilder.minute(name, [compare], value)` creates a condition for minutes\n- added: `Database.find2()` performs faster and reverse reading of documents (from end to begin of the file)\n- added: `Database.stream(fn, [repository], [callback(err, repository, count)])` for streaming documents\n- added: `Database.lock(callback(next))` locks all internal DB operations\n- added: `Database.ready(callback)` executes a callback when DB is ready to use (only for special cases if you use indexes)\n- added: new directory `schemas` with a new configuration item `directory-schemas'\n- added: new directory `operations` with a new configuration item `directory-operations'\n- added: `String.crc32([unsigned])`\n- added: `U.hash('crc32')` and `U.hash('crc32unsigned')`\n- added: config `nosql-worker' for enabling worker for NoSQL embedded database (default: `false`)\n- added: config `nosql-inmemory' can contain name of databases e.g. (`users, products`) or String Array\n- added: config `nosql-cleaner` for cleaning databases from removed documents (default: `1440` === 24 hours)\n- added: config `nosql-logger` (default `true`) enables simple logs when re-indexing and cleaning\n- added: config `security.txt` for auto-generating security.txt content (more in docs)\n- added: config `default-proxy` for default web proxy server\n- added: config `allow-cache-cluster` (default `true`) allow/disallow cache synchronization\n- added: `GUID()` a global alias for `U.GUID()`\n- added: `VIEW()` a global alias for `F.view()`\n- added: `SchemaBuilderEntity.$response([index])` returns a specific response from an operation in `async` queue\n- added: `$SAVE(schema, model, [options], [callback], [controller])` performs `schema.save()`\n- added: `$INSERT(schema, model, [options], [callback], [controller])` performs `schema.insert()`\n- added: `$UPDATE(schema, model, [options], [callback], [controller])` performs `schema.update()`\n- added: `$REMOVE(schema, [options], [callback], [controller])` performs `schema.remove()`\n- added: `U.streamer2()` same functionality as `U.streamer()` but it returns `Buffer` instead of `String`\n- added: `Number.round([precision])`\n- added: `UID([type])` supports custom types, e.g. `UID('users')` or `UID('orders')`\n- added: `REQUEST()` global method, it's alias to `U.request()`\n- added: `NOW` global property, it's alias to `F.datetime`\n- added: `DatabaseBuilder.promise()`\n- added: `RESTBuilder.promise()`\n- added: `RESTBuilder.plain()` it returns a raw string from the response body\n- added: `versions` file supports `auto` value for generating auto-checksum of files\n- added: `F.load()` supports `test`\n- added: NoSQL binary supports `custom` small data attributes\n- added: CSS and JS supports a simple View Engine markup (config + resources + F.global)\n- added: `controller.split` alias to `controller.req.split`\n- added: nicer error response messages\n- added: `RESTBuilder.proxy(proxy)` for HTTP proxy\n- added: `U.request()` supports a new flag `proxy`, for example `proxy 127.0.0.1:8080`\n- added: NoSQL database a new event `change`, more in docs\n- added: `schema.define()(DEFAULT_VALUE)` added `DEFAULT_VALUE`\n- added: `TESTUSER([user])` for faking of `F.onAuthorize` delegate, targeted for unit-testing only\n- added: `G` as a global alias for `F.global`\n- added: `ERROR([name])` is an improved `F.error()` without arguments\n- added: a simple support for `.heic` and `.heif` image format\n- added: `controller.sitemap_url2()`\n- added: `controller.sitemap_name2()`\n- added: `@{sitemap_url2()}`\n- added: `@{sitemap_name2()}`\n- added: `F.syshash` contains a simple MD5 hash with OS info\n- added: `SchemaEntity.clear()` for removing all current definition\n- added: new view engine markup `@{#}` for simulating of root URL\n- added: new view engine command `@{root}` for getting sub-root path\n- added: `String.ROOT()` for replacing `@{#}` markup in strings\n- added: `U.decryptUID(value, key)` for encrypting number/string values\n- added: `U.encryptUID(value, key)` for decrypting of number/string values\n- added: `F.config['secret-uid']` as a hidden secret for encrypting/decrypting values\n- added: `F.dir(path)` for changing of root directory\n- added: `NOSQL()/TABLE().memory(count, [size])` for memory consumption, more in docs\n- added: `HttpFile.fs(storage_name, [custom], [callback])` saves a file into the FileStorage\n- added: `HttpFile.nosql(db_name, [custom], [callback])` saves a file into the FileStorage\n- added: `res.filefs(storage_name, id, [download], [headers], [callback])` returns file from FileStorage\n- added: `res.filenosql(db_name, id, [download], [headers], [callback])` returns file from NoSQL binary\n- added: `res.imagefs(storage_name, id, image_make_fn, [headers], [callback])` returns file from FileStorage\n- added: `res.imagenosql(db_name, id, image_make_fn, [headers], [callback])` returns file from NoSQL binary\n- added: new stats `F.stats.performance` contains count of `request` and `file` per minute\n- added: new method `controller.operation(name, value, [callback], [options])` for evaluating of operation\n\n- updated: (IMPORTANT) NoSQL binary divides files to independent directories for 1000 files per directory\n- updated: `GROUP()` by adding a new argument `url_prefix`\n- updated: `NEWSCHEMA()` supports `NEWSCHEMA('group/name')`\n- updated: `ROUTE()`, extended syntax for schemas, for example: `Schema -->Â @name` (more in docs.)\n- updated: `ROUTE()` supports a new HTTP method definition `ROUTE('GET /api/users/')`, `ROUTE('POST /api/users/')`, etc.\n- updated: `ROUTE()` supports a schema definition directly in the URL `ROUTE('GET /api/users/ *User --> @save')`, etc.\n- updated: `tpm` supports a new command called `bundle`, for example: `tpm bundle cms`\n- updated: `F.restore()` filter can return a new filename (for files only)\n- updated: `@{import('livereload')}` or `@{import('livereload wss://mywebsite.com')}` supports `livereload` value and it's rendered in `debug` mode only\n- updated: information after the framework is started\n- updated: `schema.define('name', null)` removes a schema field\n- updated: Chunker supports `compression`, default `true`\n- updated: Chunker supports `autoremove` processed files in `each()` or `read()` method, default `true`\n- updated: `String.parseConfig(def, [onError])` can handle errors better\n- updated: `middleware`, now Total.js supports new declaration `F.middleware(function($) {})`\n- updated: `F.wait()` HTML template\n- updated: JavaScript compressor, now optimizes multiple `var` declarations\n- updated: `CORS()` without arguments for all routes, methods and origins\n- updated: `CORS()` tries to join multiple same preferences to one\n- updated: `CORS(path)` without additional arguments allows all HTTP methods\n- updated: `U.keywords()` for Chinese/Japan characters\n- updated: `@{import()}` by adding `manifest` value linked to `/manifest.json`\n- updated: `F.use()` supports `function` instead of `middleware` name\n- updated: improved crypto algorithm\n- updated: decreased a maximum count of keys to `33` from `69` when the query string is parsing\n- updated: extended `schema.required(name, (model, workflow) => workflow.update)`, more in docs.\n- updated: `$MAKE(schema, model, [filter/workflows], ...)` supports `workflows` (array or object) instead of filter for `schema.required()`\n- updated: `OPERATION()` by adding `controller`\n\n- fixed: mail attachments\n- fixed: mail `message.manually()`\n- fixed: WebSocket comparing of `origin` header\n- fixed: uninstalling CORS routes\n- fixed: cache for `favicon`\n- fixed: `Date.extend()`\n- fixed: `String.isJSON()` validator\n- fixed: `String.parseDate()` now it parses date to UTC correctly\n- fixed: `Date.format()` now it formats a date as UTC correctly\n- fixed: HTML compressor with `\\r\\n` (Windows line endings)\n- fixed: schema validation\n- fixed: `U.atob()`\n- fixed: `U.btoa()`\n- fixed: schema field can be changed dynamically\n- fixed: `String.arg()`\n- fixed: `controller.href()` with Array values\n- fixed: `U.get()` a problem with path with `-`\n- fixed: `U.set()` a problem with path with `-`\n- fixed: `F.path.mkdir()` in Windows and Linux\n\n- replaced: config `disable-clear-temporary-directory` to `allow-clear-temp : true|false`\n- replaced: config `disable-strict-server-certificate-validation` to `allow-ssc-validation : true|false`\n- replaced: config `default-websocket-request-length` to `default-websocket-maxlength`\n- replaced: config `default-request-length` to `default-request-maxlength`\n- replaced: config `default-maximum-file-descriptors` to `default-maxopenfiles`\n- replaced: `controller.proxy()` functionality (the name remains) via `controller.proxy2()` functionality\n\n- removed: `F.responseFile()`\n- removed: `F.responsePipe()`\n- removed: `F.responseImage()`\n- removed: `F.responseImageWithoutCache()`\n- removed: `F.responseStream()`\n- removed: `F.responseBinary()`\n- removed: `F.responseContent()`\n- removed: `F.responseRedirect()`\n- removed: `F.response400()`\n- removed: `F.response401()`\n- removed: `F.response404()`\n- removed: `F.response408()`\n- removed: `F.response431()`\n- removed: `F.response500()`\n- removed: `F.response501()`\n- removed: `F.responseStatic()`\n- removed: `F.setModified()`\n- removed: `F.notModified()`\n- removed: `F.responseCode()`\n- removed: `F.noCache()`\n- removed: `controller.$modified()`\n- removed: `controller.$etag()`\n\n- improved: `debug` mode timing with improved consumption\n- improved: performance (+20%) NoSQL embedded database\n- improved: reading performance (+5%) in `U.streamer()`\n- improved: CSS compressor\n- improved: CORS processing\n- improved: internal encryption/decryption mechanism\n\n======= 2.9.4 (HOTFIX)\n\n- fixed: mail attachments\n- fixed: comparing `origin` header in WebSocket\n- fixed: unit-testing\n\n======= 2.9.3 (HOTFIX)\n\n- added: `String.arg(obj)` for a simple templating `Hello {variable}!`\n- added: new event `ON('@controllername', function() {})` -> is executed if the controller is evaluated\n\n- updated: RESTBuilder default headers are lower-case\n- updated: `content-disposition` header by adding `utf-8` according to [RFC 5987](https://tools.ietf.org/html/rfc5987#section-3.2.2)\n\n- fixed: a missing property `controller.params` in WebSocket controller\n- fixed: `$ASYNC()` execution in some cases\n- fixed: `SCRIPT()` code with comments\n- fixed: a callback reference in `OPERATION()`\n- fixed: cache after route is removed\n- fixed: `409` system route\n- fixed: requests with `range` header and bad values\n- fixed: `clearSchedule()`\n- fixed: `Date.extend()` problem with months\n- fixed: NoSQL counter reading stats\n\n======= 2.9.2\n\n- added: `controller.html(body, [headers])`\n- added: `F.cluster.master(name, [data])` - for child processes, this method emits an event in master process\n- added: `F.cluster.on(name, callback(data))` - master event listener\n- added: `LOGMAIL()` global alias for `F.logmail()`\n- added: `MAIL()` global alias for `F.mail()`\n- added: own implementation of `onFinished`\n- added: `RESTBuilder.cookies(obj)` can set cookies as raw object\n- added: `RESTBuilder.cook([true/false])` enables persistent cookies\n- added: `SchemaOptions.params` which returns dynamic params from the controller's action\n- added: `SchemaOptions.done([arg])` as a callback (contains wrapped SUCCESS())\n- added: `SchemaOptions.DB()` which returns `DB(this.error)` instance (for SQL Agent)\n- added: `OperationOptions.done([arg])` as a callback (contains wrapped SUCCESS())\n- added: `OperationOptions.DB()` which returns `DB(this.error)` instance (for SQL Agent)\n- added: static method `Image.measure(type, buffer)` for measuring width/height of image\n- added: `EACHOPERATION(function(name) {})` for obtaining all registered operations\n- added: `controller.params` which returns dynamic params from the action\n\n- updated: `F.load()`, now supports `string` for `debug` or `release` mode\n- updated: `F.cluster.request()` can be executed from master process\n- updated: `Image.miniature()` change a default filter from `Box` to `Hamming`\n- updated: `U.request()` supports a new flag `cookies` which enables a parsing cookies from response\n\n- fixed: schema validation (problem with Arrays)\n- fixed: determines `x-forwarded-proto`\n- fixed: nested schema validation\n- fixed: themes static routing\n- fixed: NoSQL reader\n- fixed: NoSQL counter (sorting while reading stats)\n- fixed: loading dependencies\n- fixed: uninstalling middleware\n- fixed: reading/updating sitemap in controller\n\n- removed: max. sort `string` length\n- removed: `auto` appending `.css` and `.js` extension in view engine\n- removed: experimental `defer` feature\n\n- improved: GZIP compression\n- improved: code\n\n======= 2.9.1 (HOTFIX)\n\n- added: `controller.throw409()`, `req.throw409()`\n- added: new view aliases: `@{R.something}` for `repository`, `@{M.something}` for `model` and `@{G.something}` for `global`\n\n- updated: `ErrorBuilder.push()` supports `.push(name, status_code)` or `.push(name, error, status_code)`\n\n- fixed: sitemap language auto-setting\n- fixed: NoSQL: `builder.paginate()` a problem with zero limit (default limit will be `maxlimit`)\n- fixed: NoSQL number filtering\n- fixed: localization of ErrorBuilder in controllers\n\n======= 2.9.0\n\n- added: `WebSocketClient`\n- added: `$ASYNC(schema, callback, [index], [controlller])` alias to `SchemaBuilderEntity.$async()`\n- added: `ArrayBuffer.prototype.toBuffer()`\n- added: `AUTH(fn)` is an alias to `F.onAuthorize = fn`\n- added: `controller.success()` alias to `controller.json(SUCCESS(value))`\n- added: `CORS()` alias to `F.cors()`\n- added: `DatabaseBuilder.paginate(page, limit)`\n- added: `F.config['allow-compile']` can disable the whole compilation of static files\n- added: `F.config['default-dependency-timeout']` it's a timeout for module dependencies\n- added: `F.path.rmdir(directory/directories, callback)`\n- added: `F.path.unlink(file/files, callback)`\n- added: `LOCALIZE()` a new global alias to `F.localize()`\n- added: `MAP()` a new global alias to `F.map()`\n- added: `MERGE()` a new global alias to `F.merge()`\n- added: `MIDDLEWARE()` a new global alias to `F.middleware()`\n- added: `NOSQL('users').backups([filter(doc)], callback(err, response))` returns all backups\n- added: `SchemaOptions.invalid(name, [value], [path], [index])` alias to `$.errors.push() + callback()`\n- added: `SchemaOptions.success()` alias to `callback(SUCCESS(value))`\n- added: `controller.sitemapid` contains a sitemap identifier\n- added: `controller.sitemap_add(parent, name, url)` appends a new item into the sitemap per request\n- added: `@{sitemap_add(parent, name, url)}` appends a new item into the sitemap per request\n- added: `SchemaEntity.required('fieldname', boolean/function(model))` which can disable/enable validation for this field\n\n- updated: `sitemap` routing can contain an additional path, e.g. `#sitemapid/path/`\n- updated: `F.localize()` supports sitemap routing\n- updated: `F.merge()` supports sitemap routing\n- updated: `F.map()` supports sitemap routing\n- updated: `F.http(mode, [options], [middleware(listen)])` added a new argument `middleware`\n- updated: `debug.js` now reads directories according to the config (author: @luoage)\n- updated: config parser supports `config` sub-type\n- updated: `controller.$exec()` --> `callback` is by default `controller.callback()`\n- updated: `F.localize()` has enabled `compression` by default\n- updated: HTTP server is listening after the framework is completely loaded\n- updated: (IMPORTANT) HTTP cache in dynamic content and static files\n- updated: `F.prototypes()` by adding `OperationOptions`\n- updated: ErrorHandling in schemas (supports inline validation and advanced conditions)\n- updated: `F.noCache()` is obsolete\n\n- renamed: `allow-handle-static-files` to `allow-static-files`\n\n- fixed: (IMPORTANT) `DatabaseBuilder.in()`\n- fixed: (IMPORTANT) `U.ls2()`\n- fixed: (IMPORTANT) `WebSocket` implementation (author: @jozefgula)\n- fixed: `ArrayBuffer` in webosocket\n- fixed: `F.path.mkdir()` on Windows (author: @molda)\n- fixed: `F.restore()` on Windows (author: @molda)\n- fixed: `F.rmdir` removes all files and directories\n- fixed: `JSON` type in Total.js schemas\n- fixed: `MODEL()`, `MODULE()`, `INCLUDE()` now are direct aliases\n- fixed: a check for maximum length of request data\n- fixed: Date formatting with `a` value\n- fixed: empty localization in view engine e.g. `@()`\n- fixed: external static routing in view engine on Windows\n- fixed: NoSQL filtering with `or`\n- fixed: NoSQL multiple updates\n- fixed: NoSQL sorting of boolean values in larger dataset\n- fixed: responding on `range` header\n- fixed: unit testing (author: @ckpiggy)\n- fixed: `schema.setPrefix()` in nested schemas\n- fixed: sitemap localization\n- fixed: CORS custom headers\n- fixed: NoSQL date filtering\n\n- improved: performance and security\n\n======= 2.8.0\n\n- added: `NOSQL().restore()` restores a database (its package)\n- added: Mail options support a new property `xoauth2` (it needs to contain a `BASE64` value) for sending emails via OAuth 2.0 tokens (more in docs)\n- added: `F.path.mkdir(path)` creates all directories according to the path\n- added: `MailMessage.send2([callback])` sends a message according to the framework configuration\n- added: a new filter for NoSQL embedded `DatabaseBuilder.contains(name)`\n- added: a new filter for NoSQL embedded `DatabaseBuilder.empty(name)`\n- added: (IMPORTANT) NoSQL counter supports daily stats (NoSQL counter files will be upgraded automatically and backwards incompatible)\n- added: (IMPORTANT) NoSQL database and counter can read data from URL\n- added: NoSQL counter `db.counter.daily_sum([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.daily_max([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.daily_min([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.monthly_sum([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.monthly_max([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.monthly_min([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.yearly_sum([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.yearly_max([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.yearly_min([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.stats_sum(top, [year], [month], [day], callback)` for reading stats\n- added: NoSQL counter `db.counter.stats_max(top, [year], [month], [day], callback)` for reading stats\n- added: NoSQL counter `db.counter.stats_min(top, [year], [month], [day], callback)` for reading stats\n- added: NoSQL counter `db.counter.minimum([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.maximum([id], callback)` for reading stats\n- added: NoSQL counter `db.counter.min(id, value)` for writing stats\n- added: NoSQL counter `db.counter.max(id, value)` for writing stats\n- added: NoSQL counter `db.counter.sum(id, value)` for writing stats (alias for `db.counter.hit()`)\n- added: NoSQL counter: a new event `stats` when the stats are changed\n- added: NoSQL logging in `DatabaseBuilder.log(msg, [user])`\n- added: NoSQL backuping documents while they are updating/removing in `DatabaseBuilder.backup([user])`\n- added: `CLONE(obj)` alias for `U.clone()`\n- added: `GROUP(flags, fn)` alias for `F.group()`\n- added: `F.cache.set2()` it creates a persistent cache (persistent items are stored in a file)\n- added: new View Engine command `@{'%config'}` which reads a value from config directly\n- added: `F.config['allow-filter-errors']` for filtering network unhandled errors\n- added: `REDIRECT()` alias for `F.redirect()`\n\n- updated: (IMPORTANT) packages compress/decompress function supports streaming data\n- updated: (IMPORTANT) `NOSQL().backup()` !!! was changed !!!!\n- updated: `controller.view(name/url, [model], [headers], [partial])` can render a view from URL address\n- updated: `F.backup()` argument `path` can contain `String Array` file list\n- updated: `controller.viewCompile(body, model, [headers], [partial], [cacheKey])` add a cache key\n- updated: `image.command(arg, value, [priority], [escape])` a `priority` argument can be `escape` when it contains `boolean` value\n- updated: `U.getExtension()` returns lower-case extensions\n- updated: `total.js/debug` watchs `/workflows` file\n- updated: file `/workflows` supports custom `options`, more in docs\n- updated: `Array.random()` algorithm (+70% faster than older)\n- updated: `RESTBuilder.file(name, filetarget, [filename])` can contain `filename` instead of buffer\n- updated: `U.streamer(beg, [end], onItem(item, index), [skip], [stream])` added a new argument `stream` for flushing buffer\n- updated: `ErrorBuilder.addTransform(name, callback(isResponse))` by adding new argument `isresponse`\n- updated: `sorting` (framework + NoSQL embedded), now supports `internationalization`\n- updated: `total.js/debugger` by adding a new option `options.watch = ['directory']`\n- updated: `U.streamer()` supports \"cancelation\", just return `false`\n- updated: CSS auto-prefixer, added: `repeating-linear-gradient`, `radial-gradient`, `repeating-radial-gradient` and removed `-o` prefix\n\n- fixed: (IMPORTANT) long messages in WebSocket\n- fixed: (IMPORTANT) `controller` param in schemas\n- fixed: moved executing of `MailMessage.callback()` to better place\n- fixed: mail auth when `options.user` and `options.password` are blank\n- fixed: JS/CSS/HTML blocks\n- fixed: `F.prototypes()`\n- fixed: `F.decrypt()` a problem with parsing JSON and date formats\n- fided: `debug.js` sometimes was created a problem with output informations\n\n- improved: Date formatting (+50%)\n- improved: NoSQL performance (around 60% in some cases)\n\n======= 2.7.0\n\n- added: __IMPORTANT__ new unit-testing mechanism\n- added: __IMPORTANT__ `F.prototypes(function(proto) {})` for extending all internal prototypes\n- added: `HttpFile` is set in `global` for extending of prototype\n- added: `file.move()` a new alias for `file.rename()`\n- added: `SchemaBuilderEntity.$controller(new_controller)`\n- added: `EMPTYCONTROLLER` is a global variable\n- added: new alias `NOSQL.set()` and `NOSQL.get()` for `NOSQL.meta()`\n- added: `RESTBuilder.file(name, filename, [buffer])` supports uploading files\n- added: `RESTBuilder.mobile()` adds `iPhone` phrase into the `User-Agent` header\n- added: `RESTBuilder.robot()` adds `Bot` phrase into the `User-Agent` header\n- added: a small protection for multipart data\n- added: a new global aliases `ROUTE()` --> `F.route()`, `FILE()` --> `F.file()` and `WEBSOCKET()` --> `F.websocket()`\n\n- updated: __IMPORTANT__ components (framework can render css/js from specific group)\n- updated: `F.cluster` each operation checks whether cluster is activated\n- updated: default IP to `0.0.0.0`\n- updated: `Date.prototype.format()` with `ddd` renders name of day with 2 capital letters\n\n- fixed: new schemas with defined callback `function($)`\n- fixed: loading of `config-test` file (added rewriting of existing values)\n- fixed: Total.js version in `debug.js`\n- fixed: cluster initialization\n\n- improved: `cors` in `F.restful()` and `F.restful2()`\n- improved: `auto-vendor-prefixes`\n- improved: parsing files from multipart data\n\n======= 2.6.2 (HOTFIX)\n\n- fixed: a critical bug with `debug.js`\n- fixed: `try/catch` block from parsing of WebSocket message\n\n======= 2.6.1 (HOTFIX)\n\n- fixed: timeout in `RESTBuilder` and `U.request()`\n- fixed: `F.merge()` a problem with `.js` or `.css` extension in some directory\n\n======= 2.6.0\n\n- added: `F.config['default-errorbuilder-status']` a default HTTP status for all error builders default `200`\n- added: `F.config['default-listenpath']` starts a UNIX socket server listening for connections on the given path\n- added: `F.listenpath` contains `default-listenpath` location\n- added: `F.custom(mode, http, request_prototype, response_prototype, options)` a new mode for overwriting default HTTP server\n- added: `schema.inherit([group], name)` can inherit all values from another schema\n- added: NoSQL synchronization for cluster (more in docs)\n- added: cache synchronization for cluster (more in docs)\n- added: `F.cluster` (more in docs)\n- added: Total.js `debug` script `require('total.js/debug')` instead of `debug.js` file\n- added: a support for `async` attribute when `<script async src=\"` tag is generating, e.g. `@{import('async default.js')}`\n\n- updated: `F.http(type, options)` supports `options.listenpath` for HTTP server (a direct shortcut for `default-listenpath`)\n- updated: `F.script` returns error if compilation fails\n- updated: `debug.js` supports `inspector`\n- updated: NoSQL embedded database sorting (increased read performance about 30%)\n- updated: RESTBuilder parsers JSON date string as `Date` object\n- updated: `favicon()` generates `<link rel=\"icon\"` instead of `<link rel=\"shortcut icon\"`\n\n- fixed: `controller.send()` bad declaration of `connection.id` for `id` and `blacklist` arguments\n- fixed: `totaljs --translate` problem with `node_modules` and `.git` directory\n- fixed: a waiting mode in `GETSCHEMA()`\n- fixed: cache `instance.cache()` in RESTBuilder\n- fixed: NoSQL filtering (critical)\n- fixed: a bug ImageMagick/GraphicsMagick when the path contains spaces (critical)\n- fixed: `controller.memorize()` didn't work (critical)\n- fixed: dynamic params when `controller.transfer()` is performed\n\n======= 2.5.0\n\n- added: a missing property for WebSocket controller `controller.mobile`\n- added: `EMIT()` alias for `F.emit()`\n- added: `ON()` alias for `F.on()`\n- added: `OFF()` alias for `F.removeListener(eventName, listener)` or `F.removeAllListeners([eventName])`\n- added: `controller.components()` adds script/css tag into the head\n- added: `@{components([group], [settings])}` renders all components together from selected group\n- added: a new alias `WAIT()` alias for `U.wait()`\n- added: `res.status(code)` for express middleware\n- added: `F.clearSchedule(id)` for removing existing schedules\n- added: a support for WebSocket compression\n- added: removing `.package` files from `tmp` directory\n- added: a new schema implementation (more in docs)\n- added: `F.restful2()` has simplified route mechanism (it doesn't use \"{id}\" param for insert(POST)/update(POST)/delete(DELETE) method with except \"GET\" method)\n- added: `res.binary(buffer, contentType, [type], [download], [headers])`\n- added: a new route flag `novalidate` (a prevention for Schema validation)\n- added: `U.upload(files, url, [callback], [cookies], [headers], [method], [timeout])` for multiple uploading files\n- added: `RESTBuilder.redirect(true/false)` enables/disables auto-redirect (default: enabled)\n- added: new schema aliases (`$QUERY()`, `$GET()`, `$WORKFLOW()`, '$TRANSFORM()' and `$OPERATION()`)\n- added: `allow-head` (default: false) adds `head` method into the each route automatically\n- added: `F.config['allow-defer']` enables deferring functions with `DEFER` keyword (default: false)\n- added: `DEFER` feature\n- added: `F.config['allow-debug']` starts a mini debugger\n- added: `res.image_nocache()` alternative to `F.responseImageWithoutCache`\n- added: `req.localize()` performs localization (executes `F.onLocale`)\n- added: `image.limit(type, value)` creates a memory/map/disk/etc. limitation for GM or IM\n- added: `default-image-consumption` for GM/IM memory limitation (default value `30%`)\n- added: `F.useSMTP(smtp, [options], [callback(err)])` rewrites current SMTP settings\n\n- updated: `F.http('debug/release/test', { debug: true })` can start a mini debugger\n- updated: `F.route()`, `F.websocket()` and `F.file()` --> now returns `FrameworkRoute` instance instead of `Framework` instance (more in docs)\n- updated: `F.load(debug, [types], [path])` supports a new type `service` which enables `F.on('service')`\n- updated: Components (now doesn't have to has `html` body)\n- updated: A component implementation can contain `exports.group = 'name';`\n- updated: framework loads all dependencies in order\n- updated: routes (web/websockets/files) can have an identifier in this form `F.route('/', ['id:custom_dentificator']);\n- updated: `UNINSTALL(type, url/id/fn)` supports new types `web`, `websocket` and `file`, e.g. `UNINSTALL('web', 'id:custom_identifier')`\n- updated: `U.request()`, added a new flag: `raw` (sends raw data)\n- updated: `F.schedule()` returns an identifier\n- updated: `U.clone()` supports `buffer` properties\n- updated: `setTimeout2(name, fn(param), timeout, [limit], [param])` added a new argument `limit` and `param`\n- updated: `F.script()` --> `now` argument (in the script body) is function `now()` which it still returns `new Date()`\n- updated: `F.script(body, value, callback(err, response, param), [param])` --> `param` argument is a helper\n- updated: middleware `next(false)` cancels calling of next middleware and controller\n- updated: `OPERATION(name, value, [callback(err, response, param)], [param])` added a new (helper) argument `param`\n- updated: Mail error handling (added Message instance)\n- updated: `U.request()` add a new flag `noredirect`\n- updated: `F.exists(req, res, [max], callback(next, filename, req, res))` added a new arguments into the callback `req` and `res`\n- updated: `F.memorize()` uses `themeName` as a part of the cache key\n- updated: `debug.js` (missing `startup` directory)\n\n- renamed: configuration `mail.address.from` for `mail-address-form`\n- renamed: configuration `mail.address.reply` for `mail-address-reply`\n- renamed: configuration `mail.address.copy` for `mail-address-copy`\n- renamed: configuration `mail.smtp` for `mail-smtp`\n- renamed: configuration `mail.smtp-options` for `mail-smtp-options`\n\n- fixed: config `static-accepts` (it didn't work)\n- fixed: routing with `upload` flag\n- fixed: workers timeout\n- fixed: modificators by George Okojie Davis\n- fixed: NoSQL comparing dates `equal` in `where` condition\n- fixed: a problem with `booting` packages if are used custom paths (by @harry-stot)\n- fixed: JavaScript compression\n- fixed: `allow-compile-style` for inline CSS in views\n\n- improved: events\n- improved: parsing data from requests\n- improved: mechanism of components\n- improved: performance\n- improved: responding\n- improved: mail attachments\n\n======= 2.4.0\n\n- added: `components` more in docs\n- added: `X-Powered-By` header again with option to change/remove it in the framework config `default-xpoweredby   : Total.js`\n- added: `UPTODATE(type, url, [options], interval, [callback(err)])` more in docs\n- added: `F.on('uptodate', function(type, name) {})` new event for up-to-date dependencies\n- added: `F.stats.other.mail` with a count of sent emails\n- added: `F.stats.response.errorBuilder` with count of sent ErrorBuilders\n- added: `F.stats.response.image` with count of processed images via GM or IM\n- added: `F.stats.request.schema` with count of request to SchemaBuilder\n- added: `String.prototype.parseTerminal([fields], fn(values, index, count, realIndex), [skipLines], [takeLines])`\n- added: `TRACE(message, [name], [url], [ip])` is an alias for `F.trace()`\n- added: `F.config['trace-console']` (default: `true`) shows tracing on the console\n- added: `F.convert(name, type/function(val))` registers a new convertor (convertors uses QueryParser (GET/POST))\n- added: `F.convert(obj)` performs convertor for an object\n- added: `F.download(url, filename, [callback])` a new alias for `F.snapshot()`\n- added: `$$$([group], name)` for `GETSCHEMA([group], name)`\n- added: configuration files supports options for all dependencies `module#mymodulename    (Object)   : { name: 'A custom options for dependency' }`\n- added: `U.chunker()` added a new property `chunker.pages` with count of all stored pages\n- added: `U.chunker()` added a new property `chunker.count` with count of all stored items\n- added: `NEWOPERATION(name, fn(error, callback(response), value))` - registers a new operation (same as schemas)\n- added: `OPERATION('name', function(err, response))` - executes an operation (same as schemas)\n- added: `.flac` file extensions\n- added: a new method for `MailMessage` object `message.unsubscribe('your URL or email address')`\n\n- updated: new error message `The field \"@\" is invalid.`\n- updated: `NOSQL().insert(doc, [unique])`\n- updated: `quicksort` algorithm has been replaced for `shellsort` (increased performance of sorting about 10-15%)\n- updated: `NOSQL().counter.monthly(true, ...)` shows all stats by ID\n- updated: `NOSQL().counter.yearly(true, ...)` shows all stats by ID\n- updated: `dependencies` supports up-to-date features e.g. `module (1 day)   : https://......js`\n- updated: `F.findConnections([path])` a `path` argument is optional\n- updated: `U.streamer(beg, [end], function, [skip])` add a new argument `skip`\n- updated: deprecated methods in Node.js v7\n- updated: `String.parseJSON([date])` added `date` argument (date fields will be converted to `datetime`)\n- updated: `F.script()` can compile code to function e.g.: `F.script('next(a + b)')` returns a compiled function\n- updated: `String.captialize([onlyFirst])` add a new argument `onlyFirst`\n- updated: `F.onParseQuery(value, req)` add a new argument `req`\n- updated: `F.onParseXML(value, req)` add a new argument `req`\n- updated: `F.onParseJSON(value, req)` add a new argument `req`\n- updated: `RESTBuilder.url()` without argument returns a current URL\n- updated: `RESTBuilder.exec(function(err, value, response))` when the `error` exists the `value` is still `EMPTYOBJECT`\n- updated: addded a new argument `replacer` to `controller.send(message, [id], [blacklist], [replacer])` and `client.send(message, [raw], [replacer])`\n\n- removed: behaviours\n- removed: restrictions\n- removed: `TransformBuilder`\n- removed: `F.config['allow-compatibility']` (not used)\n- removed: `controller.date()` method has been useless\n- removed: dynamic view compilation through `.view()` method\n- removed: `contorller.proxy()` in WebSocket controller\n\n- fixed: JS minificator\n- fixed: global alias `I` for isomorphic code\n- fixed: streaming files in `debug` mode (removed cache)\n- fixed: (critical) a bug with authorization in WebSocket\n- fixed: `nosql_builder.join()` a problem with using `nosql_builder.first()` by @yexing (Xing Ye)\n- fixed: `String.parseInt2()` - a possible NaN value\n- fixed: `String.parseFloat2()` - a possible NaN value\n- fixed: `F.snapshot()`\n- fixed: HTML compression (a fixed problem with HTML comments)\n- fixed: restarting framework (missing cleaning of `F.temporary`)\n- fixed: `U.isDate()` a problem with older dates than 1970, reported by @docgit\n\n- improved: code\n- improved: memory consumption for static files\n- improved: CSS compression\n- improved: CPU and memory consumption\n- improved: performance\n- improved: updating of `F.datetime`\n- improved: `uninstall` dependencies\n- improved: installing 3rd-party dependencies (framework compares same contents)\n\n======= 2.3.0\n\n- added: support for `/workflows` file (more in documentation)\n- added: `ShcemaBuilderEntity.$exec(name, callback)` (more in documentation)\n- added: `SchemaBuilder` supports new types `enum` and `keyvalue`\n- added: `controller.$exec(name, [options], [callback])` (more in documentation)\n- added: a new argument `description` to each SchemaBuilder `set` + `add` method e.g. `.setSave()`, `.addWorkflow()`, etc..\n- added: `SchemaBuilder.meta` contains all registered handlers with their descriptions\n- added: a property `controller.schema`\n- added: `F.viewCompile(body, [model], [layout], [repository], [language])` - dynamic views\n- added: `controller.viewCompile(body, [model], [headers], [partial])` - dynamic views\n- added: `{viewCompile(body, [model])}` - dynamic views\n- added: `Controller` is a global variable for extending prototype\n- added: `F.validators` with Regular Expressions\n- added: View Engine supports `@{continue}` and `@{break}` command for looping\n- added: `URLBuilder.make(fn)`\n- added: `NOSQLMEMORY(dbName, [viewName])` enables in-memory database collection\n- added: NoSQL `nosql.upsert(doc)` inserts a new document where document doesn't exist in DB\n- added: NoSQL `nosql.release()` for releasing of in-memory DB (framework clears unused in-memory databases automatically)\n- added: NoSQL `nosql.scalar(type, dbName, [view])` performs scalar operation by type: `sum`, `min`, `max`, `avg`, `count` or `group`\n- added: NoSQL `nosql.binary.all(callback)` browses all stored files\n- added: NoSQL `nosql.binary.clear(callback)`removes all stored files\n- added: NoSQL `DatabaseBuilder.random()`\n- added: NoSQL `DatabaseBuilder.join(field, dbName, [view])` returns `DatabaseBuilder` with updated `.where(field_JoinedDB, field_currentdb)` method (it supports `.fields()` too)\n- added: NoSQL `DatabaseBuilder.join()` supports scalar operation too, e.g. `nosql.join(...).scalar('count')`\n- added: NoSQL `DatabaseBuilder.scalar(type, [field])` - types: `sum`, `min`, `max`, `avg`, `count` or `group`\n- added: NoSQL `DatabaseBuilder.month(field, [operator], value)` filters `Date` fields according its month number\n- added: NoSQL `DatabaseBuilder.year(field, [operator], value)` filters `Date` fields according its year number\n- added: NoSQL `DatabaseBuilder.day(field, [operator], value)` filters `Date` fields according its day number\n- added: NoSQL events (documents): `insert`, `update`, `modify` and `remove`\n- added: NoSQL events (binary): `insert`, `remove` and `clear`\n- added: NoSQL events (counter): `hit`, `remove` and `clear`\n- added: a new alias `NOBIN(dbName)` witch it returns `NOSQL(dbName).binary` (a binary instance)\n- added: a new alias `NOCOUNTER(dbName)` witch it returns `NOSQL(dbName).counter` (a counter instance)\n- added: `F.kill(signal)` for killing an instance of the framework\n- added: `I` alias for `isomorphic code on server-side and client-side together by hhhaker6@gmail.com <https://github.com/Creeplays>\n- added: `F.script(body, value, callback(err, value))` evaluates script securly in safe scope (more in documentation)\n- added: new alias `SCRIPT()` for `F.script()`\n- added: `HttpFile.rename(filename, [callback(err)])` moves file to another directory\n\n- updated: `F.on('exit', function(signal) {})` added a signal code\n- updated: SchemaBuilderEntity contains new argument `controller`, e.g. `.setSave(function(error, model, options, callback, controller) { ..`\n- updated: removed all validators of email addresses from FrameworkMail\n- updated: `GETSCHEMA([group], name, [callback(err, schema)])` can wait for a schema\n- updated: `F.localize()` supports modificators as `static` type\n- updated: `F.modify()` supports a new type `static`, it's group of `.html`, `.txt` and `.md` files\n- updated: `U.trim(obj, [clean])` supports a new argument `clean` (default `false`) and when it's `true` and a value is `''` then it sets the value to `undefined`\n- updated: `nosql.update(docToUpdate, [docToInsert])` when the document for updating doesn't exist then database performs insert\n- updated: `nosql.modify(docToUpdate, [docToInsert])` when the document for updating doesn't exist then database performs insert\n- updated: `nosql.binary` stores a creation date as meta info\n\n- fixed: Image.stream()\n- fixed: global variable `Image` (in a single library)\n- fixed: JavaScript compressor (problem with Regular Expressions)\n- fixed: custom paths in `F.model()` and `F.source()`\n- fixed: NoSQL removing documents (problem with different filters in one queue)\n- fixed: fix view compiler error message\n- fixed: `String.prototype.capitalize`\n\n- removed: `nosql` doesn't support cache (`DatabaseBuilder.cache` is obsolete)\n- removed: `F.refresh()` the method was useless\n\n- replaced: `Array.randomize()` for `Array.random()`\n\n- improved: code\n\n======= 2.2.0\n\n- added: `controller.proxy2(url, [callback], [headers], [timeout])` creates a proxy between current request and new URL\n- added: `Image.watermark(filename, [x], [y], [width], [height])` creates a watermark\n- added: hidden hack `res.noCompress = true` disables compilation of `.js` or `.css`\n- added: `RESTBuilder` for creating REST requests (more in docs)\n- added: new config item `allow-cache-snapshot` - to prevent cache when the framework is restarted\n\n- updated: `SINGLETON(name, [def = {}])` about `def` argument\n- updated: `debug.js` adds timestamps\n- updated: `F.redirect()` can contain a relative URL of file\n- updated: NoSQL embedded parser, dates are parsed as date object\n- updated: `Pagination.next()`, `Pagination.prev()`, `Pagination.last()` and `Pagination.first()` supports new arguments `.html([link_inner_html], [class_name])`\n- updated: `F.worker()` supports packages `F.worker('@eshop/myworker-script')`\n- updated: `FrameworkImage` when the instance contains no command then `.minify()` method is performed automatically for preventing of empty response\n- updated: `F.config['static-accepts']` removed dots from all extensions\n\n- improved: `@{href(key, value)}` performance\n- improved: Total Package Manager `$ tpm --help`\n- improved: FrameworkImage command building\n\n- fixed: (critical) NoSQL `nosql.modify()` and problem with updating `undefined` values\n- fixed: (critical) security with GM and IM --> 10000x thanks for Luis Figueiredo <luisf@hexasoftware.com>\n- fixed: `Image.stream()` and `Image.pipe()`\n\n- renamed: `F.onLocate` renamed to __`F.onLocale`__\n\n======= 2.1.0\n\n- added: `F.sitemap_add(string)` for adding entries to sitemap by Martin Smola <https://github.com/molda>\n- added: SchemaBuilderEntity `schema.addHook(name, fn(error, model, options, callback))`\n- added: SchemaBuilderEntity `schema.hook(name, model, [helper], callback)`\n- added: `controller.$hook(name, [helper], callback)`\n- added: `String.parseInt2()` the method searchs number and converts it to integer\n- added: `String.parseFloat2()` the method searchs number and converts it to float\n- added: `@{title2('this content will be added to end of current title')}`\n- added: `String.parseInt2()` the method searchs number and converts it to integer\n- added: `String.parseFloat2()` the method searchs number and converts it to float\n- added: `@{absolute(url, [hostname])}` for importing links with absolute URL by George Okojie Davis <https://github.com/binarygeotech>\n- added: `sitemap_replace(name, title, url)` can change sitemap `title` and `url` onetime\n- added: new JavaScript minificator algorithm because of Douglas Crockford \"Good, not Evil\"\n- added: NoSQL supports counter for e.g. views or downloads, etc., more in documentation\n- added: new routing mechanism `F.mmr(url, action)` for streaming `multipart/x-mixed-replace` types (client-->server)\n- added: `controller.mmr(filename, [stream], callback)` for streaming `multipart/x-mixed-replace` (server-->client)\n- added: `setTimeout2(key, fn, timeout)` resets old and creates a new `setTimeout` according to the `key`\n- added: `clearTimeou2(key)` resets existing timeout\n- added: `dnscache` into the `controller.pipe()` and `F.responsePipe()`\n- added: `CREATE([group], name)` the methods create an empty object according to the schema\n- added: `F.group(flags, fn)` for extending routes (web, websocket, file) flags\n- added: `Number.prototype.filesize([decimals], [type])` formatting file sizes\n- added: `binary` importing CSV `-csv`\n- added: `controller.autodestroy([callback])` only for websocket\n\n- updated: `framework.view()`, `controller.view()` and `@{view()}` supports `=theme/viewname`\n- updated: sitemap routing supports localization\n- updated: `F.cache.fn(name, fnCache, fnCallback(value, isFromCache))` - added argument `isFromCache`\n- updated: `F.use(name, url, types, [first])` - `first` (default: `false`) argument adds a new middleware to the beginning of a route middleware\n- updated: `String.toSearch()` - removes duplicates characters + better performance\n- updated: `String.decode()` - improves decoding by Tom Spaccialbelli <https://github.com/harry-stot>\n\n- fixed: (critical) NoSQL views\n- fixed: (critical) view compilation in release mode (problem with just-in-time rendering)\n- fixed: (critical) `F.eval()`\n- fixed: (critical) parsing Date instance as Date instance in SchemaBuilder\n- fixed: `F.resize()` additional path `~`\n- fixed: `controller.memorize()` threw a timeout when the action contains some error in the memorize scope\n- fixed: `F.sitemap()` fixed problem with `me` argument\n- fixed: SchemaBuilderEntity preparing and validation\n- fixed: QuickSort algorithm (problem with dates)\n- fixed: `TRY()` scope\n- fixed: problem with resources in views\n- fixed: CSS compressor\n- fixed: CORS\n- fixed: problem with SUCCESS() and async schemas\n- fixed: killing the process\n- fixed: HTML compressor in views\n\n======= 2.0.1\n\n- added: binary supports webserver `totaljs 8000` starts webserver on 8000 port and the current directory will be a public directory\n- added: configuration supports new subtype (`env` or `environment`) for binding values from `process.env`\n- added: `SchemaBuilderEntity.$next(type, [name], helper)` --> adds a new operation (type: `workflow`, `transform`, `operation`, `save`, `read`, `query`, `remove`) to async list as next step\n- added: `SchemaBuilderEntity.$push(type, [name], helper)` --> adds a new operation (type: `workflow`, `transform`, `operation`, `save`, `read`, `query`, `remove`) to async list as last step\n- added: `SchemaBuilderEntity.$index(index)` can changed `obj.$async()` index (the index can be string e.g. `+1` or `-1`)\n- added: `SchemaBuilderEntity.$callback(fn)` can changed `obj.$async()` callback\n- added: `SchemaBuilderEntity.$repository(name, [value])` can get / set temporary value\n\n- added: `SchemaBuilderEntity.$output()` sets the current `callback(value)` as output/result for `obj.$async(function(err, output))`\n\n- updated: when the config contains `directory-temp` with empty value then the framework uses system temporary directory\n- updated: `U.reduce()` supports array\n\n- fixed: binary `totaljs`, fixed problem with creating localized texts\n- fixed: `F.responseFile()` problem with cached filename, extension was broken when the framework reads the file from cache\n- fixed: preparing values with subtype for array in SchemaBuilder\n- fixed: generation UID\n- fixed: problem with uninstalling middleware\n- fixed: email validation, a problem with e.g. `blabla@somedomain.business` by @VarunBatraIT\n\n- improved: view engine rendering\n- improved: view engine memory consumption\n\n======= 2.0.0\n\n- added: new NoSQL version v4.0.0 is fully optimized for total.js\n- added: `controller.invalid([status])` creates the ErrorBuilder instance and it responds in the next tick\n- added: `controller.sitemap_url([id])` returns an URL from the sitemap\n- added: `controller.sitemap_name([id])` returns a name/title from the sitemap\n- added: `controller.sitemap_change(id, property, newvalue)` can change a current value in the sitemap\n- added: `controller.sitemap_navigation([parent], [langauge])` can get list of all items according to the parent\n- added: `@{sitemap_url([id], [arg1], [arg2], [argN])}` returns an URL from the sitemap\n- added: `@{sitemap_name([id], [arg1], [arg2], [argN])}` returns a name/title from the sitemap\n- added: `@{sitemap_change(id, property, newvalue)}` can change a current value in the sitemap\n- added: `@{sitemap_navigation([parent], [language])` can get list of all items according to the parent\n- added: `/startup/` all scripts in this directory are executed only one (then are renamed automatically)\n- added: `F.route()` supports a new flag: `cors` (creates a cors route) and `credentials` (enables cookies for cors)\n- added: `ErrorBuilder.plain()` returns all errors as a simple string\n- added: `Array.findItem()` alias to `Array.find()`\n- added: `Number.async(fn(index, next), callback)` for asynchronous operations\n- added: `UID()` for generating unique identifiers (contains minimum 18 chars)\n- added: `F.restart()` for restarting app\n- added: `F.on('restart')`\n- added: quicksort algorithm for sorting arrays\n- added: `Array.quicksort(property_name, [asc], [maxlength])` for sorting arrays\n- added: `String.removeTags()` by @harry-stot\n- added: F.nosql(name) + NOSQL(name) --> alias for NoSQL embedded database (it can be used with e.g. SQL Agent)\n- added: modificators can handle `INSTALL('view', ...)`\n- added: `String.isPhone()` for phone number validation\n- added: `String.isUID()` for UID() validation\n- added: `String.isZIP()`\n- added: `Pagination.html(max, format)` returns `String`\n- added: `Pagination.json(max, format)` returns `String`\n- added: new schemabuilder types `Email` (string, maxlength 120), `Phone` (string, maxlength 20), `Zip` (string, maxlength 10), `Capitalize` (string), `Lowerize` (string), `Upperize` (string), `UID` (string, minlength 18, maxlength 20), `Url` (string, maxlength 500), `JSON` (string)\n- added: `SchemaBuilderEntity.fields` and it contains all field names in array.\n- added: `Mail.send(smtp, options, messages, [callback])` messages must be array\n- added: `Mail.send2(messages, [callback])` sends messages according to the framework configuration\n- added: `Mail.try(smtp, options, callback)` tries to open a SMTP\n- added: `F.datetime` contains current datetime and each 1 minute is the value increased\n- added: `F.stats.other.restart` contains a new property with count of restarting\n- added: `F.config.trace` for enable/disable tracing, `Boolean`, in a debug mode: `true`, release mode: `false`\n- added: `F.trace(message, [name], [uri], [ip])`\n- added: `controller.trace(message)`\n- added: `req.split` contains splitted url\n- added: `F.touch(url/req)` for clearing internal cache of cached static files (it works only in release mode)\n- added: `F.path.exists(path, callback(exist, size, isFile))` for check of existing file\n- added: `U.chunker(name, [max])` creates the chunker (for streaming some items)\n- added: `F.worker2(name, [args], [callback], [timeout])`\n- added: `SchemaBuilderEntity.allow('fieldname1', 'fieldnameN')` - allows other keys out of defined fields\n- added: `global.EMPTYOBJECT`\n- added: `global.EMPTYARRAY`\n- added: `global.SINGLETON(name)` returns a singleton object instance\n- added: `controller.referrer` returns a value from `req.headers['referer']`\n- added: `controller.author(value)` can change `<meta name=\"author\"`\n- added: `@{author(value)}` can change `<meta name=\"author\"`\n- added: view engine supports looping with objectsÂ `@{foreach m in model} key: @{m.key} and value: @{m.value} @{end}`\n\n- updated: subdomain routing supports wildcard routing `F.route('[*]/', 'homepage')` (`F.websocket()` is supported too)\n- updated: `F.route(url, ...)` - `url`can be String Array with multiple relative paths by @Harry-Stot\n- updated: `F.file()` supports flags instead of middleware and the flags supports extensions `['.jpg', '.png']`. The `name` argument has been removed.\n- updated: `F.localize()` supports flags and the `name` argument has been removed\n- updated: `F.sitemap()` returns object with a new field: `wildcard: {Boolean}`\n- updated: `F.problem()`, `F.change()`, `controller.problem()` and `controller.change()` write logs to the file\n- updated: `F.mail()` and `controller.mail()` subject is translated according to the language\n- updated: `F.file(fnValidation/relative_path, fnExecute, [flags])` the file routing is completely changed\n- updated: `export.booting` can contain `root` attribute for `package` applications\n- updated: `Array.orderBy()` added quicksort algorithm\n- updated: `Date.format()` supports day names `ddd` (short) and `dddd` (full)\n- updated: `String.removeDiacritics()` supports multiple languages (by @Harry-Slot)\n- updated: (IMPORTANT) `U.getExtension(filename)` --> returns extension without `.` dot\n- updated: (IMPORTANT) `F.resize(url, action(image), [flags])` new resize routing\n- updated: `F.resize()` flags can contain http/https `path` e.g. `F.resize('/img/*.*', (image) => image.minify(), ['https://www.totaljs.com/img/']);`\n- updated: `U.GUID()` supports better charset by Guy Fraser\n- updated: `Date.add(number)` supports number increase/decrease in milliseconds\n- updated: `U.send(name, stream, url, callback, [cookies], [headers], [method], [timeout])` supports cookies and timeout\n- updated: `U.request()` supports a new flag `< 200` (kB), it means that the method stores a content with maxixmum size 200 kB.\n- updated: `ErrorBuilder` instance contains a new property `instance.unexpected` when is `instance.push()` a classic Error's instance.\n- updated: configuration files + resources support types like String, Number, Array, Date, etc. via `key (type) : value`\n- updated: `F.use(name, [url], [types])` - now supports new attributes `url`, and `types`\n\n- fixed: `Websocket.destroy()`\n- fixed: Too many open files with `F.log()` and `F.logger()`\n- fixed: `String.isJSON()` the problem with `\\n` character\n- fixed: `FrameworkImage.save()` problem with streams\n- fixed: `CLEANUP(stream)` method\n- fixed: `controller.memorize()` problem with `controller.content()`\n- fixed: `multipart/form-data` parser\n- fixed: `Array.async()` without arguments\n- fixed: view inline helpers\n- fixed: `FrameworkImage.save()` doens't work when it doesn't contain any operation\n- fixed: Windows paths\n- fixed: problem with `websocket.destroy()`\n- fixed: `F.cors()`\n- fixed: WebSocket initialization (critical)\n- fixed: Mail sender (problem with ZOHO SMTP)\n- fixed: `Number.add()` problem with percentage\n- fixed: `U.isDate()` by Guy Fraser\n- fixed: `U.parseXML` problem with `CDATA`\n- fixed: `U.join()` problem with Windows path by Martin Smola\n- fixed: uploading files (problem with unexpected closed requests)\n- fixed: `F.assert()` a problem with external URL address\n\n- renamed: event `route-add` to `route`\n- renamed: `F.versionNode` to `F.version_node`\n\n- removed: (IMPORTANT) `X-Powered-By` header\n- removed: `SCHEMA()`\n- removed: composer from `SchemaBuilderEntity`\n- removed: rules from `SchemaBuilderEntity`\n- removed: obsolete code\n- removed: `controller.async()`\n- removed: `framework.async()`\n- removed: `Utils.validate()`\n- removed: `Utils.isEmail()`\n- removed: `Utils.isURL()`\n- removed: `Utils.isValid()`\n- removed: `Utils.isNullOrEmpty()`\n- removed: `controller.global` property by Guy Fraser (a problem with referrencing)\n- removed: `controller.database()`, use `F.database()`\n- removed: `controller.functions()`\n- removed: `controller.models()`\n\n- improved: Controller initialization by Guy Fraser\n- improved: SMTP sender\n- improved: redirecting\n- improved: Array.orderBy(), added quicksort algorithm\n- improved: ErrorBuilder\n- improved: `WebSocket.send()` for JSON communication\n- improved: code (a lot)\n- improved: preparing `SchemaBuilderEntity`\n- improved: performance\n- improved: a lot of code by Guy Fraser\n\n======= 1.9.7\n\n- added: `F.web()` --> alias to F.route()\n- added: `F.cors(url, flags, credentials)`\n- added: `config['default-response-maxage']`, default value `11111111`\n- added: `U.get(obj, path)` reads a value from `obj` by path\n- added: `U.set(obj, path, value)` sets a value into `obj` by path\n- added: (IMPORTANT) `config['default-root']` can replace root relative path\n- added: `FrameworkImage` --> `instance.make(function(image) {})`\n- added: `FrameworkImage` supports middleware `FrameworkImage.middleware(extension, fn)`\n- added: `controller.$get([helper], callback)` or alias `controller.$read([helper], callback)` - schema must be defined in the route\n- added: `controller.$remove([helper], callback)` - schema must be defined in the route\n- added: `controller.$save([helper], callback)` - schema must be defined in the route\n- added: `controller.$query([helper], callback)` - schema must be defined in the route\n- added: `controller.$transform(name, [helper], callback)` - schema must be defined in the route\n- added: `controller.$workflow([name, [helper], callback)` - schema must be defined in the route\n- added: `controller.$operation(name, [helper], callback)` - schema must be defined in the route\n- added: `controller.$async(callback, [index])` - schema must be defined in the route\n- added: new `F.route()` flag `binary` (works only with `raw` flag)\n- added: `U.ls2()` --> returns additional information about files (stat Object);\n- added: `Pagination` is a global variable\n- added: `SchemaBuilder.workflow2(name, options, callback)` skips preparing and validation\n- added: `SchemaBuilder.transform2(name, options, callback)` skips preparing and validation\n- added: `SchemaBuilder.operation2(name, options, callback)` skips preparing and validation\n- added: `ErrorBuilder.exception(message)` - adds a new exception message\n- added: `F.findConnection()` finds a websocket connection\n- added: `F.findConnections()` finds websocket connections\n\n- updated: (IMPORTANT) Array.async([NEW: threadCount (Number)], [callback]) supports `threads`\n- updated: (IMPORTANT) Array.wait(onItem(item, index), [callback], [threadCount]) supports `threads`\n- updated: (IMPORTANT) U.streamer(beg, [end], callback) --> supports \"end\" delimiter\n- updated: Date.format(format, [resource_name]) supports name of months via `MMM` (short) and `MMMM` (full)\n- updated: Resources support months e.g. `January     : JanuÃ¡r`\n- updated: `F.merge()` supports directories, e.g. `F.merge('app.js', '/js/*.js')`\n- updated: NoSQL embeddded version\n- updated: `U.ls()` --> [filter] can be `string` or `RegExp`\n- updated: `@{meta(title, [description], [keywords], [image])}` and `@{keywords(value)}` keywords can be String Array\n- updated:Â `@{section name}` can be used in the view more times\n- updated: `U.request()` flags supports `number` for timeout and encoding `utf8`, `ascii`, etc.\n- updated: `F.restfull()` each action support SchemaBuilder\n\n- fixed: (IMPORTANT) Expires headers - problem with Russian timezone, reported by [ÐÐ½Ð´ÑÐµÐ¹ ÐÐ»Ð°Ð´Ð¸Ð¼Ð¸ÑÐ¾Ð²Ð¸Ñ](https://github.com/anddesigner)\n- fixed: (IMPORTANT) SchemaBuilder validation\n- fixed: (IMPORTANT) view caching\n- fixed: (IMPORTANT) U.keywords()\n- fixed: @{checkbox} value binding\n- fixed: dynamic views translator caching\n- fixed: URL search string in `F.redirect()` (doesn't work on local relative address)\n- fixed: binary / executable for Windows\n- fixed: SUCCESS()\n- fixed: Schema Validation is performed after F.onAuthorize().\n- fixed: checking of maximum request length\n- fixed: regexp routing\n- fixed: F.restrictions.allow()\n- fixed: `U.request()` and fixed `head` method, callback returns headers when is `head` method used\n- fixed: Pagination by DusanDragula\n- fixed: View inline helpers - reported by [ÐÐ½Ð´ÑÐµÐ¹ ÐÐ»Ð°Ð´Ð¸Ð¼Ð¸ÑÐ¾Ð²Ð¸Ñ](https://github.com/anddesigner)\n- fixed: `Array.findIndex` - reported by [Liao San-Kai](https://github.com/liaosankai)\n- fixed: `WebSocket.send()` problem with `[id]` and `[blacklist]`\n\n- improved: performance in `Expires Header`\n\n======= 1.9.6\n\n- added: MailMessage.manually() and removes auto-sending mail --> works only with `F.mail()` and `controller.Mail()`.\n- added: view engine supports now `@{'route-to-static-file.jpg'}`\n- added: `U.clone(obj, [skip])`\n- added: `U.parseTheme(path)` --> parses theme name\n- added: `@{href}` or `@{href(obj)}` or `@{href(key, value)}` --> query string manipulation (more in documentation)\n- added: `.jsx` content-type\n- added: `robot` flag into the routing (for search engines)\n- added: property `req.robot`\n- added: property `controller.robot`\n- added: property `controller.mobile`\n- added: support for default theme name, e.g. `=?/index` (the framework replaces `?` for `default-theme`)\n- added: String.localeCompare2(value) --> same as localeCompare() but this method works with diacritics\n- added: F.register(filename); --> the methods registers new e.g. resource (it solves the problem with resources in packages)\n\n- updated: (IMPORTANT) controller.isSecure was renamed to controller.secured\n- updated: (IMPORTANT) req.isSecure was renamed to req.secured\n- updated: (IMPORTANT) Array.wait(onItem, onCallback, [NEW: threadCount (Number) or removeItemFromArray (Boolean)]) supports `threads`\n- updated: `F.mail()` supports themes with view nema like this `=default/someview'`\n- updated: `@{import()}` supports movies and images\n- updated: `@{import()}` can contain schema name in the path like this `=YOURTHEME/somefile.js`\n- updated: `F.route('/', '=themeName/viewname')` supports inline themes\n- updated: `F.resize()` added new options parameter --> `direction` (top, center or bottom)\n- updated: SUCCESS(), now supports function as first argument and the method returns wrapped function too\n\n- fixed: problem with views path (`./some/path/in/hdd/` routed view anywhere)\n- fixed: static file routing (`@{import()}`,Â `@{routeScript}`, etc..)\n- fixed: miss `Sec-WebSocket-Protocol` by Liao San-Kai\n- fixed: `MailMessage.send()` --> `options` argument is optional\n- fixed: problem with UTF8 in U.request() by Ivan Marchukov\n- fixed: WebSocket parser\n- fixed: WebSocket closing message (problem with UTF8)\n- fixed: U.getExtension()\n- fixed: problem with WebSocket `destroy`\n- fixed: sync2() doesn't work\n- fixed: problem with themes in controller.memorize()\n- fixed: problem with timeout in controller.memorize()\n- fixed: fixed unitialized memory block in `mail` (by ChALkeR)\n- fixed: problem with static files (directories with extensions)\n\n- removed: all `controller.current...()` methods\n- removed: all `@{current...()}` methods\n- removed: (IMPORTANT) `framework.fs`\n- removed: (IMPORTANT) `controller.fs`\n\n- improved: (IMPORTANT) SchemaBuilder by Ivan Marchukov\n- improved: (IMPORTANT) ViewEngine performance about 15%\n- improved: request cookie parsing\n\n======= 1.9.5\n\nI had to skip v1.9.4 version because of NPM (my mistake).\n\n- added: (IMPORTANT) new feature: THEMES\n- added: `@{theme}` --> return String\n- added: `F.onTheme` delegate\n- added: `controller.theme(theme_name)` --> select theme;\n- added: `config['default-theme']`\n- added: `U.keywords(content, [forSearch], [alternative(true|false|soundex)], [max_count(200)], [max_length(20)], [min_length(2)]);`\n- added: `String.prototype.keywords([forSearch], [alternative(true|false|soundex)], [max_count(200)], [max_length(20)], [min_length(2)])`\n- added: `String.prototype.soundex()`\n- added: `F.wait(name, [enable])` the server waits for pending task and it responds via 503 status code\n- added: `U.parseQuery()` and `String.parseQuery()`\n- added: `U.join(path1, path2, path3)`\n- added: `U.getName(path)`\n- added: `F.on('error400')`\n- added: `F.on('error401')`\n- added: `F.on('error403')`\n- added: `F.on('error404')`\n- added: `F.on('error408')`\n- added: `F.on('error431')`\n\n- updated: (IMPORTANT) F.onAuthorization() was renamed to F.onAuthorize()\n- updated: `Date.format()` supports `w` and `ww` for week number\n- updated: `Date.add()` supports `w`, `ww`, `week`, `weeks`\n- updated: MailMessage supports display name `mail.from('Name <vali@demail>');`\n- updated: MailMessage supports display name `mail.to('Name <vali@demail>');`\n- updated: MailMessage supports display name `mail.to(email, [name], [clear]);`\n- updated: MailMessage supports display name `mail.cc('Name <vali@demail>');`\n- updated: MailMessage supports display name `mail.cc(email, [name], [clear]);`\n- updated: U.resolve(url, [callback]) --> `callback` is optional\n\n- fixed: HTTP cache for HTML 5 offline manifest files\n- fixed: async() error handling\n- fixed: NoSQL embedded paths\n- fixed: problem with empty SMTP options\n- fixed: ErrorBuilder default transformation to JSON\n- fixed: Error handling\n- fixed: SchemaBuilder request auto-validation\n- fixed: String.isJSON()\n- fixed: F.responsePipe() --> problem with transmitted headers\n- fixed: evaluating of @{helpers.helper_name()}\n- fixed: HTML minification of UTF8 characters\n- fixed: U.isEqual()\n- fixed: FrameworkImage.save() in Windows by LiaoTzukai\n- fixed: SchemaBuilder prefix by DuÅ¡an Dragula\n\n- improved performance of the response\n- improved total performance\n- improved view engine performance\n\n======= 1.9.3\n\n- added: (IMPORTANT) merging supports BLOCKS (.js,.css), e.g. F.merge('merge.js', 'fileA.js#management,common', 'fileB.js#management')\n- added: (IMPORTANT) a route with schema binding can contain filter e.g. `*Schema#update` or `*Group/Schema#create` --> the framework validates only fields by filter\n- added: TRANSFORM([transform], obj)\n- added: NEWTRANSFORM(name, fn, [isDefault]) --> alias for TransformBuilder.addTransform()\n- added: packages can be stored as directories (recommended for debug mode only)\n- added: F.localize(name, url, [middleware], [options], [minify]) --> minify argument\n- added: email supports calendar (.ics) request sending\n- added: SchemaBuilderEntity.make(function(schema))\n- added: F.install() supports packages mapping\n- added: Support for unicode routing\n- added: Packages can be loaded in framework structure (/controllers/, /modules/) `exports.booting = true`\n- added: route flags can contains object --> the object is an additional options for middleware\n- added: Utils.btoa(str) --> returns base64\n- added: Utils.atob(str) --> returns binary\n- added: global.TRY(fnScope, [fnError]) --> creates safe scope (more in documentation)\n- added: Utils.getExtension(filename)\n- added: @{head} can be imported as @{import('head')}\n- added: @{meta} can be imported as @{import('meta')}\n- added: controller.cookie('KEY') --> for reading\n- added: controller.cookie('KEY', 'VALUE', expire, [options]) --> for writting\n- added: framework.onParseQuery(function(value)) --> for parsing values from the requests\n- added: framework.onParseXML(function(value)) --> for parsing values from the requests\n- added: framework.onParseJSON(function(value)) --> for parsing values from the requests\n\n- updated: (IMPORTANT) F.onValidation() was renamed to F.onValidate()\n- updated: (IMPORTANT) SchemaBuilderEntity.onValidation() was renamed to SchemaBuilderEntity.onValidate()\n- updated: (IMPORTANT) SchemaBuilderEntity.setValidation() was renamed to SchemaBuilderEntity.setValidate()\n- updated: CSS compressor removes comments\n- updated: F.restrictions.allow('IP') --> does not have to be full IP\n- updated: F.restrictions.disallow('IP') --> does not have to be full IP\n- updated: String.startsWith() and String.endsWith() according to ES6 but with the backward compatibility\n- updated: String.parseDate() supports JSON format and classic date serialization\n- updated: U.request() --> response always returns string\n- updated: debug.js --> now watchs packages\n\n- fixed: framework starting path (fixed problem with PM2 module)\n- fixed: controller.memorize() - prevention for multiple requests\n- fixed: routing (POST request without content-type is considered as `application/x-www-form-urlencoded`)\n- fixed: sync2()\n- fixed: U.minifyHTML() - now compresses JS and CSS in HTML\n- fixed: Async.cancel()\n- fixed: email attachments\n- fixed: throwing error in global middleware\n- fixed: Pagination.last()\n- fixed: CSS auto-vendor-prefixes\n- fixed: `tpm` binary (bug in creating packages on Windows)\n- fixed: controller generators\n- fixed: F.install() --> problem with names via URL import\n- fixed: F.map() on Windows (problem with paths)\n- fixed: HTML compression in views\n- fixed: U.Async() object (problem with waitingFor)\n- fixed: F.map(), problem in Windows\n- fixed: CLEANUP(stream, [callback]);\n- fixed: HTTP CACHE\n\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/blocks\n\n======= 1.9.2 (HOTFIX)\n\n- added: support for node +v4.0.0\n\n- updated: F.load(.., ..., [path]) path arguments supports '..' for parent directory\n- updated: PageBuilder (+added properties: `nextPage`, `prevPage`, `firstPage`, `lastPage`) by [Liao San-Kai](https://github.com/liaosankai)\n- updated: NoSQL\n\n- fixed: U.request() --> `DELETE` method has `application/x-www-form-urlencoded` as default content type\n- fixed: routing with `delete` flag\n- fixed: F.worker()\n- fixed: WebSocket event handlers\n- fixed: sync2()\n- fixed: @{place}\n- fixed: @{section}\n- fixed: controller.memorize() - problem with different layouts\n\n- improve: routing performance with F.onAuthorization()\n\n======= 1.9.1 (HOTFIX)\n\n- added: new sitemap system\n- added: a default schema validator is F.onValidation()\n- added: ErrorBuilder.setContentType() --> default application/json\n- added: View engine supports `else if`\n- added: U.parseBoolean(val, [def])\n- added: F.backup(filename, path, [callback], [filter]) --> backup some path to one file\n- added: F.restore(filename, target, [callback], [filter]) --> restore backup file (but not evaluating)\n- added: MailMessage supports custom headers `message.headers = { key: 'value' }`\n- added: @{notranslate} --> disables view translation\n- added: F.mode('debug') or F.mode('release') --> changes a mode of the framework\n- added: EACHSCHEMA([group], prepare(group, name, schema))\n\n- updated: MailMessage.bcc(email, [clear]) --> added clear\n- updated: MailMessage.cc(email, [clear]) --> added clear\n- updated: MailMessage.reply(email, [clear]) --> added clear\n\n- fixed: uploading files\n- fixed: prevention for mail double callback calling (by Andrea Sessa)\n- fixed: worker messaging\n- fixed: problem with schema parser (by Andrea Sessa)\n- fixed: F.load() --> \"versions\" is configurable\n- fixed: \"raw\" receiving of data\n- fixed: U.request(), the problem with default method\n- fixed: F.exists() - problem with URL query string\n- fixed: framework startup path\n- fixed: Date.format()\n- fixed: Assertion Testing\n\n======= 1.9.0\n\n- added: (IMPORTANT) ISOMORPHIC using\n- added: (IMPORTANT) new flag `mobile` (mobile routing), you can create a route to mobile device\n- added: (IMPORTANT) new flag `delay` for long time operations (it removes timeout)\n- added: readonly `req.mobile` -> returns `boolean`\n- added: new view tag: @{mobile} â> returns `boolean`\n- added: new view tag: @{isomorphic} â> returns `Object` with isomorphic objects\n- added: `config['disable-clear-temporary-directory'] = false` (after start)\n- added: `config['allow-compatibility'] = false` - a backward compatibility mode\n- added: `config['default-timezone']`\n- added: `config['directory-isomorphic']`\n- added: `config['directory-private']`\n- added: `F.path.private([filename])`\n- added: `F.path.isomorphic([filename])`\n- added: `Controller.ping()` for WebSocket\n- added: `global.DB()` --> same as `global.DATABASE()`\n- added: `global.isomorphic` --> returns `framework.isomorphic` --> returns isomorphic objects\n- added: `global.is_client` and `global.is_server` for isomorphic\n- added: cache for HTTP routing\n- added: RegExp routing `F.route('/{/^\\\\d+$/}', ...)`\n- added: `F.responseBinary(req, res, contentType, buffer, [type], [download], [headers])`\n- added: `SchemaBuilderEntity.filter(custom, [model], [reverse])`\n- added: `SchemaBuilderEntity.trim = true`(enable/disable trim strings (default: true))\n- added: `Number.prototype.add(value, [decimals])` -> supports percentage\n- added: `Date.prototype.toUTC([ticksOnly])`\n- added: `Date.prototype.extend()` -> extend current datetime about new date or time (more in documentation)\n- added: `F.stats.request.mobile`, `F.stats.request.desktop`\n- added: `res.setHeader('Vary', 'Accept-Encoding, User-Agent')` for same url addresses and different devices (desktop vs mobile)\n- added: binary - `total --translatecsv`\n- added: controller.jsonp(method_name, obj, [headers], [beautify], [replacer]);\n- added: CSS variables likes sass, example: `$color: red;`\n- added: CSS nesting\n- added: modificators for dynamic modification before compilation: views, styles and scripts\n- added: TransformBuilder\n- added: F.load(debug, load_types, [path]);\n- added: F.isWorker (is true when is called F.load())\n- added: F.isCluster (is true when the framework is running in the cluster)\n- added: F.logmail(address, [subject], body, [callback]) --> send e-mail message as plain text\n- added: Array.unique([property]) by Andrea Sessa\n- added: Array.pair(array, property, fn(itemA, itemB), [remove]) - pair arrays\n- added: String.base64ToBuffer();\n- added: terminal -> `tpm unpack [package_name] [optional: target_directory]`\n- added: versions is applied to raw HTML\n- added: versions supports auto-mapping\n- added: sync2(), e.g. sync2(fn), diff with v1: sync(fn)() and v2: sync2(fn)\n- added: \"dependencies\" file for installing dependencies (modules, packages, etc.)\n- added: @{nocompress html}, @{nocompress js}, @{nocompress css}, @{nocompress all}\n- added: req.authorize(callback(err, userprofile, isAuthorized))\n- added: res.content(code, body, type, [compress]) -> alias for F.responseContent()\n- added: F.localize(name, path, [middleware], [options]) - auto translating static files\n- added: F.listener(req, res) -> for multiple server listeners\n- added: F.restful(url, flags, onQuery, onGet, onSave, onDelete) -> creates routing\n- added: F.onSchema(req, group, name, callback(err, body)) -> for custom schemas\n- added: @{import(filename1, filename2, filenameN)}\n- added: SchemaBuilderEntity.setError(function(error, model, type, name));\n- added: F.snapshot(url, filename, [callback]);\n- added: CLEANUP(stream, [callback]) - clean up readable streams\n- added: configs directory\n- added: F.behaviour(url, flags);\n- added: behaviour: disable-measuring (default: false)\n- added: behaviour: disable-middleware (default: false)\n\n- updated: (IMPORTANT) routing: `json` flag is not required for receiving incomming data as JSON\n- updated: `F.mail(address, subject, view, [model], [callback], [language])` added language\n- updated: `F.view(name, model, [layout], [repository], [language])` added language\n- updated: `F.route(url, ...)`, `F.websocket(url, ...)` --> URL can be function(url, req, [flags])\n- updated: `versions` affects F.map() and F.merge()\n- updated: `controller.mail(address, subject, view, [model], [callback], [language])` added language\n- updated: `config['allow-performance']` is set to true\n- updated: (IMPORTANT) `F.map(url, filename/directory, [filter])` supports mapping directories\n- updated: (IMPORTANT) arguments order `SchemaBuilderEntity.setValidate(function(name, value, path, model, schema){})`\n- updated: (IMPORTANT) `U.extend(target, source, [rewrite]);` --> rewrite is by default: __true__\n- updated: `SchemaBuilderEntity.setPrepare(function(name, value, index, model){})` --> __model__ is new\n- updated: `SchemaBuilderEntity.define(name, value, required, [custom])` --> __custom__ is new\n- updated: HTML compressor\n- updated: favicon `(removed rel=\"icon\")`\n- updated: binary `tpm create [package] [directory]` (added argument [package], [directory])\n- updated: better handling middleware errors and added prevention of \"memory leak\"\n- updated: (IMPORTANT): Websocket ping is set to 3 minutes\n- updated: framework responds for bad requests with HTTP 403\n- updated: Mail (added support for Office365)\n- updated: Date.prototype.add() supports e.g. Date.prototype.add('25 days')\n- updated: String.prototype.params() -> supports double \"{{\"\n- updated: F.schedule(date, [repeat], fn) --> added [repeat]\n- updated: `F.responseStream()` and `controller.stream()` added [nocompress] argument\n- updated: binary `tpm` supports install package from different URL\n\n- removed: XSS check\n\n- fixed: `controller.binary(buffer, contentType, [download], [headers])`\n- fixed: routing `DELETE`\n- fixed: `binary` (creating empty-project, bad record with smtp options)\n- fixed: calling generator action\n- fixed: `binary --translate` (filenames)\n- fixed: SchemaBuilderEntity prepare (problem with nullable Boolean)\n- fixed: (IMPORTANT) 431 system route\n- fixed: F.log(), F.logger() â> problem with objects, reported by Nikita Shmidt\n- fixed: Number formatting (problem with negative numbers)\n\n- improved: performance +15%\n- improved: code optimalization\n- improved: Date.prototype.format()\n- improved: String.prototype.format()\n- improved: Number.prototype.pluralize()\n- improved: view debugging\n\n__IMPORTANT:__\n`exports.install = function(framework) {}` framework variable is removed but with backward compatibility (`config['allow-compatibility']`).\n\n======= 1.8.0\n\nsource-code: \"tabs\" instead of \"spaces\"\n\n- added: SchemaBuilderEntity->setPrepare(function(name, value, index))\n- added: SchemaBuilderEntityâ>setPrefix(prefix)\n- added: SchemaBuilderEntity->setResource(resourcename)\n- added: auto-trim strings in SchemaBuilderEntity\n- added: Controller.route;\n- added: ErrorBuilder is a global class\n- added: F.on('upload-begin', function(req, file) {})\n- added: F.on('upload-end', function(req, file) {})\n- added: config['static-accepts']: woff2\n- added: F.logger(filename, arg1, ...), controller.logger(...), @{logger(...)}\n- added: (IMPORTANT) F.exists(req, res, callback(next, filename))\n- added: callback: F.responseFile(), controller.file(), response.file()\n- added: callback: F.responseImage(), controller.image(), response.image()\n- added: callback: F.responseImageWithoutCache()\n- added: callback: F.responseStream(), controller.stream(), response.stream()\n- added: callback: F.responseStatic(), response.continue()\n- added: Array.prototype.findIndex(cb, [value]) returns Number\n- added: Array.prototype.toObject([name]) returns Object\n- added: Array.prototype.limit(max, fn(items, next), [callback])\n- added: Array.prototype.compare(propName, arr, comparer)\n- added: Image.geometry(w, h, options)\n- added: Image.thumbnail(w, h, options)\n- added: Image.filter(type)\n- added: `config['default-maximum-file-descriptors'] = 0` (0 = the watcher is disabled)\n- added: `config['default-interval-clear-dnscache'] = 2880` for clearing DNS cache of Utils.request(), Utils.download()\n- added: Utils.resolve(url, callback(err, uri)) DNS cache\n- added: Utils.clearDNS() clears DNS cache\n- added: Utils.isObject()\n- added: String.prototype.parseJSON()\n- added: Date.prototype.diff([date], type)\n- added: framework.onCompileView(name, content, model)\n- added: framework.on('cache-set', function(name, value, expire))\n- added: `@{compile handlerbars}CONTENT TO COMPILE@{end}`\n- added: `@{compile}CONTENT TO COMPILE@{end}`\n- added: Utils.streamer(delimiter, function(value, index)) returns function\n- added: HEAD method support for (controller.json(), .view(), .plain(), .file(), .stream())\n- added: global.NEWSCHEMA([group], name) for creating new schemas (more in docs)\n- added: global.GETSCHEMA([group], name) for getting new schemas (more in docs)\n- added: global.FINISHED(res/stream, callback) --> real end of the stream\n- added: global.DESTROY(stream) --> destroys the stream\n- added: (IMPORTANT) node.js generators for the routes\n\n- updated: (IMPORTANT): for evaluation multiple roles in routing (@role) framework validates only one role\n- updated: GZIP compression for static files (added .md, .json)\n- updated: request schema parser and XML parser -> better handling errors\n- updated: wrapped decodeURIComponent for prevention of parsing\n- updated: removed HTTP cache in DEBUG mode\n- updated: Image.miniature(w,h,color,[filter]) --> added filter\n- updated: binary supports translation files `--translate my-localization.txt`\n- updated: framework.mail() --> returns MailMessage\n- updated: controller.mail() --> returns MailMessage\n- updated: SchemaBuilderEntity.$async(callback, [return-only-this-index])\n- updated: translation @(#KEY) (direct reading) or @(TEXT TO TRANSLATE) (hash reading)\n- updated: Utils.request(), Utils.download() supports `dnscache` flag for caching host IP\n- updated: SchemaBuilderEntity.validation()\n- updated: F.cache.set(key, value, expire, [sync])\n- updated: NoSQL\n- updated: (IMPORTANT): Websocket ping is disabled by default\n\n- fixed: Image.resize()\n- fixed: F.usage() --> fixed queue pendings\n- fixed: (CRITICAL) SchemaBuilderEntity preparing (problem with prototypes)\n- fixed: (CRITICAL) a package or module installation from the URL address\n- fixed: (CRITICAL) response content-length\n- fixed: framework.redirect()\n- fixed: HTTP cache (added longer time)\n- fixed: auto JSON parsing in `json` request\n- fixed: Pagination.last() (Nikita Shmidt)\n- fixed: loading packages\n- fixed: callback error in MailMessage\n- fixed: TPM restore package\n- fixed: Utils.request() --> double calling of callback()\n- fixed: routing with `get` and `json` flag together\n\n- replaced: (IMPORTANT) `uri` to `url` in F.problems, F.changes, F.errors (saves memory)\n\n- improved: U.removeDiacritics() -> increase about 30%\n- improved: handling files\n- improved: auto-image-resizer (routes)\n- improved: Image.miniature() -> increase about 50%\n- improved: U.queue()\n- improved: (IMPORTANT) SchemaBuilder validation and preparation\n\n__GENERATORS__:\n\n- added: Image.$$save(filename, [writer])\n- added: Image.$$measure();\n- added: Image.$$identify();\n- added: Utils.$$request();\n- added: Utils.$$download();\n- added: Utils.$$send();\n- added: Utils.$$wait();\n- added: Utils.$$resolve();\n- added: HttpFile.$$copy()\n- added: HttpFile.$$read()\n- added: HttpFile.$$md5()\n\n======= 1.7.2\n\n- added: Array.prototype.extend(obj, [rewrite])\n- added: SchemaBuilderEntity->constant(name, [value])\n- added: Utils.minifyHTML(value);\n- added: Utils.minifyScript(value);\n- added: Utils.minifyStyle(value);\n- added: FrameworkImage.measureSVG(buffer);\n- added: auto-parsing SVG width/height\n- added: framework.translator([language], text);\n- added: TRANSLATOR\n- added: SUCCESS(boolean, [value]) returns { success: boolean, value: [value] }\n- added: framework.onLocate(req, res) --> this method sets the current localization\n- added: new installation event framework.on('module#name');\n- added: new installation event framework.on('controller#name');\n- added: new installation event framework.on('model#name');\n- added: new installation event framework.on('definition#name');\n- added: new installation event framework.on('config#name');\n\n- updated: CSS compressor (better compression)\n- updated: Utils.Request() supports head method\n\n- fixed: binary `total --diff`\n- fixed: debug.js (fixed port)\n- fixed: F.onCompileStyle and F.onCompileJavaScript (problem with filename)\n- fixed: Number.prototype.pluralize()\n- fixed: WebSocket message parsing\n- fixed: (CRITICAL) mail sender (problem with CRLF in BASE64)\n- fixed: (CRITICAL) `../src/node_http_parser.cc, line 392.`\n- fixed: the framework duplicates width/height in upload auto-parser\n- fixed: JPG width/height auto-parser\n\n======= 1.7.1 (HOTFIX)\n\nThis version will work on `io.js` without problems.\n\n- added: framework.schedule(date/string/number, fn);\n- added: (IMPORTANT) a prevention for the HeaderSent exception\n- added: new option `sleep` for framework.http() & framework.https()\n- added: request.ip caching\n- added: framework.useConfig(filename-configuration)\n\n- updated: String.toSearch() removes non-word characters\n- updated: Utils.trim() supports arrays\n\n- fixed: framework.versionNode (updated for io.js)\n- fixed: (CRITICAL) if the controller middleware does not exist framework throws exception correctly\n- fixed: Utils.validation() (for Arrays)\n- fixed: authorization routing\n- fixed: (CRITICAL) request with multipart content-type (+fixed problem XSS)\n- fixed: (CRITICAL) controller.memorize() in JSON output\n- fixed: (CRITICAL) uploading files, problem with the filename/name field (if it contained `;`)\n\n- removed: mmr\n\n======= 1.7.0\n\nFramework supports a backward compatibility.\nFramework supports: one file only (all libraries in one JS file)\nFramework loads modules, packages, models, definitions, controllers\n\n- added: SCHEMA(name), returns group of schemas\n- added: Builders.Schema() - schema supports onGet, onSave, onRemove, onQuery\n- added: Builders.Schema() - schema supports workflows\n- added: Builders.Schema() - schema supports composer\n- added: Builders.Schema() - schema supports transformations\n- added: Builders.Schema() - schema supports grouping `Builders.schema('group').get('schema_name)`\n- added: Builders.Schema() - schema supports rules\n- added: Builders.Schema().make(obj, callback(err, model)) - make object with $save, $remove, $compose, etc.\n- added: framework.mail() - is alias for controller.mail()\n- added: framework.view(name, [model], [layout], [repository]) - is alias for controller.view()\n- added: validate handler contains new parameter model -> (name, value, path, schema, model)\n- added: String.prototype.replaceAt(index, character)\n- added: String.prototype.parseXML()\n- added: String.prototype.toSearch()\n- added: async queue - Utils.queue(name, maximumCalls, fn) (for e.g. EMFILE, too many open files)\n- added: Utils.isEqual(obj1, obj2, [properties])\n- added: ErrorBuilder.prototype.push()\n- added: ErrorBuilder.prototype.transform()\n- added: ErrorBuilder.prototype.output()\n- added: ErrorBuilder.prototype.setTransform(name) - set default transform\n- added: ErrorBuilder.addTransform(name, fn, [isDefault]) - add transform\n- added: ErrorBuilder.setDefaultTransform() for all ErrorBuilders\n- added: Pagination.addTransform(name, fn, [isDefault]) - add transform\n- added: Pagination.setDefaultTransform(name) for all Paginations\n- added: Pagination.prototype.transform()\n- added: Pagination.prototype.setTransform(name) - set default transform\n- added: Pagination.prototype.first()\n- added: Pagination.prototype.last()\n- added: Pagination.prototype.isFirst\n- added: Pagination.prototype.isLast\n- added: framework.config['allow-custom-titles'] - (default: false)\n- added: new option into Mail: rejectUnauthorized (for TLS)\n- added: @{log()} and @{LOG()} into views\n- added: @{console} (.log, .info, etc.) into views\n- added: framework.on('controller-render-head', function(controller) {})\n- added: framework.on('controller-render-meta', function(controller) {})\n- added: framework.on('init')\n- added: framework.merge('/merge.js', '/js/file1.js', '/js/file2.js')\n- added: framework supports X-Forwarded-Protocol header\n- added: FrameworkImage supports buffer\n- added: auto-vendor-prefixes: box-sizing\n- added: new flag `noxhr` or `-xhr` because all route contains +xhr as default\n- added: config['default-errorbuilder-resource-name']\n- added: config['default-errorbuilder-resource-prefix']\n- added: config['allow-handle-static-files']\n- added: FrameworkCache.get() alias for FrameworkCache.read()\n- added: supports creating route without action (framework wraps action)\n- added: .md (markdown) into static-accepts\n- added: (modules, models, sources and controllers) exports.id instead of export.name\n- added: framework.map(url, new_filename)\n- added: framework.config['directory-packages'] for packages\n- added: (IMPORTANT) PACKAGES (same as modules but package can contain many files in one file)\n- added: framework.stats.request.request (requests count)\n- added: FrameworkImage.miniature(w, h, bgColor)\n- added: Array.first([def])\n- added: Array.last([def])\n- added: framework.routing(name)\n- added: global --> ROUTING(name)\n- added: global --> NOOP() empty function (exists: noop(), Utils.noop())\n- added: global --> DEBUG boolean property (is the framework in debug mode?)\n- added: global --> RELEASE boolean property (is the framework in release mode?)\n- added: global --> TEST boolean property (is the framework in test mode?)\n- added: global --> F object property (is alias for \"framework\")\n- added: routing supports schemas `*custom-schema/User` and we can define it in flags\n- added: String.prototype.parseBool()\n- added: String.prototype.parseJSON()\n- added: framework.responseImagePrepare(req, res, fnPrepare, fnProcess, [headers])\n- added: response.throw400([problem])\n- added: response.throw401([problem])\n- added: response.throw403([problem])\n- added: response.throw404([problem])\n- added: response.throw408([problem])\n- added: response.throw431([problem])\n- added: response.throw500([error])\n- added: response.throw501([problem])\n- added: response.redirect(url, [permanent])\n- added: view supports localization\n- added: assertion testing --> framework sets global.assert = require('assert')\n- added: module/controller supports dependencies --> exports.dependencies = ['moduleA', 'moduleB'];\n- added: framework.dependencies (this object contains all installed total.js dependencies)\n- added: controller.translate([text]);\n- added: framework.translate([language], text)\n- added: @{body.} instead of @{post.}\n- added: @{query.} instead of @{get.}\n- added: @{files} uploaded files\n- added: .manifest to accept list\n- added: BINARY added --diff for creating difference between two resources\n\n- updated: framework.resize(), added: options.cache (true/false, default: true)\n- updated: the route flag can contian number (TIMEOUT for current route)\n- updated: (IMPORTANT) framework doesn't remove subdirectories with files in temporary directory\n- updated: (IMPORTANT) all models are loaded after is the framework loaded\n- updated: framework.redirect(url, redirectTo, [permanent]) supports relative redirects\n- updated: Utils.request(), timeout is possible to add as cookie, headers or encoding\n- updated: Utils.request() returns EventEmitter (begin, end, data(chunk, percentage))\n- updated: Utils.request() supports auto-redirect if response status code is 301\n- updated: Utils.download() returns EventEmitter (begin, end, data(chunk, percentage))\n- updated: Controller.proxy() - returns EventEmitter (begin, end, data(chunk, percentage))\n- updated: Array.wait(fnItem, fnCallback, removeItems) - default: function doesn't remove items\n- updated: Builders.UrlBuilder() -> toString([skipEmpty])\n- updated: Number.format([decimals], [separator], [decimalSeparator])\n- updated: Date.format([format]) - format is optional, function returns ISO format without \"Z\"\n- updated: response.send(), response.json() - supports ErrorBuilder\n- updated: framework.error() (returns a wrapped delegate if error is undefined)\n- updated: controller.baa([message]) - read documentation\n- updated: Array.where(), Array.find(), Array.remove() - added a new functionality\n- updated: @{view(name, [model], [expire], [expire-key])}\n- updated: @{cookie(name)} --> read cookie\n- updated: framework.mail(address, subject, view, model, callback, replyTo) - added: replyTo\n- updated: controller.view(name) can execute without name (controller.viewname contains name according to URL)\n- updated: @{post} is deprecated\n- updated: @{get} is deprecated\n- updated: String.encode(), String.decode()\n- updated: (IMPORTANT) changed the arguments in callback for workflow, compose, transform\n- updated: BINARY total --translate SOME TEXT create translate identifier\n\n- renamed: config['directory-angular'] to config['directory-public-virtual']\n- renamed: config['allow-compress-html'] to config['allow-compile-html']\n- renamed: (IMPORTANT) default view layout from `_layout` to `layout`\n- renamed: Utils.parseDateExpire() -> Utils.parseDateExpiration()\n\n- removed: JS CSS\n- removed: (IMPORTANT) view markup for Angular.js from the core (it will be a module)\n- removed: Controller.fileAsync()\n- removed: Controller.await()\n- removed: Controller.wait()\n- removed: Controller.run()\n- removed: Controller.complete()\n- removed: Controller.jsonAsync()\n- removed: Controller.viewAsync()\n- removed: Controller.redirectAsync()\n- removed: framework.run()\n\n- fixed: LOG()\n- fixed: view engine rendering (fixed problem with undefined and null values)\n- fixed: buffer exceeded if a framework receives a data\n- fixed: if path starts '/' then is view loaded directly from /views/ directory\n- fixed: xml parser\n- fixed: problem with parsing a bad JSON datas - framework.decrypt();\n- fixed: String.prototype.parseDate()\n- fixed: path in framework.resize()\n- fixed: framework.responseImageWithoutCache()\n- fixed: appending .js or .css through @{head()}\n- fixed: WebSocket authorization\n- fixed: WebSocketClient.req\n- fixed: routing (+ asterix routing)\n- fixed: controller.cancel() (after framework.emit('controller', ...))\n- fixed: view helpers (calling without arguments)\n- fixed: dynamic cache of views\n- fixed: mail sending\n- fixed: clearing temporary directory\n- fixed: parse JSON by the JSON route\n- fixed: paths in Windows\n- fixed: subject encoding in mail (supports UTF-8)\n- fixed: sender name encoding in mail (supports UTF-8)\n- fixed: Utils.trim()\n- fixed: Utils.validation() (problem with schema array)\n- fixed: Response.cookie()\n- fixed: String.prototype.format() --> null/undefined --> returns empty string\n- fixed: Utils.request() problem with unicode\n- fixed: framework.assert() problem with unicode\n- fixed: XML parsing\n\n- improvements: routing performance\n\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/static-file-merge\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/framework-schema-and-validation\n\n======= 1.6.2 (HOTFIX)\n\n- updated: obtaining `req.xhr` before middleware\n\n======= 1.6.1 (HOTFIX)\n\n- added: `ErrorBuilder.errors` list of errors\n- added: transform-style, perspective, backface-visibility into the CSS auto-vendor-prefixes\n- added: WebSocket supports global middleware\n- added: WebSocketClient.isWebSocket (for middleware instead of Response)\n\n- updated: assertion testing (author: @toshipon)\n\n- fixed: controller.callback([view_name]), supports NoSQL Embeded Database\n- fixed: WebSocket auto-ping\n- fixed: (debug mode) caching of static files\n- fixed: global middleware (fixed exception in exception)\n- fixed: Mail (problem with secure option, author: @asessa)\n- fixed: binary (if debug.pid exists then is deleted and created again)\n\n- improvements: framework (comparison of undefined)\n\n======= 1.6.0\n\n- added: framework.http(mode, [options]) - mode: test, debug or development, release or production\n- added: framework.https(mode, [options]) - I recommend to use NGINX as HTTPS proxy\n- added: middleware delegate: function(req, res, next, [options], [controller]) { next(); }\n- added: middleware to framework.websocket(url, funcInitialize, [flags], [protocols], [allow], [maximumSize], [middleware])\n- added: middleware to framework.file([name], [fnValidation], [fnExecute], [middleware])\n- added: middleware to framework.use(name), this is global middleware\n- added: middleware can add as flag: '#middleware1', '#middleware2'\n- added: Response.controller, link to the current controller (if exists)\n- added: Response.send([code], body, [contentType])\n- added: Response.json(obj);\n- added: Response.file(filename, [downloadName], [headers])\n- added: Response.stream(contentType, stream, [downloadName], [headers])\n- added: Response.continue();\n- added: Response.req (current request)\n- added: Request.query;\n- added: Request.body;\n- added: Request.files;\n- added: controller.middleware(names, [options], [callback])\n- added: controller.body --> is same as Controller.post\n- added: controller.query --> is same as Controller.get\n- added: controller.isController (for middleware)\n- added: controller.json(obj, [beautify], [replacer]) and ErrorBuilder.json([beautify], [replacer]), author: bir <https://github.com/bir>\n- added: utils.wait(fnValid, fnCallback, [timeout(default: 5000 ms)], [interval(default: 500 ms)])\n- added: new flag: 'xml' in controller.route()\n- added: new flag: 'xml' in utils.request()\n- added: new flag: 'xml' in framework.assert()\n- added: assertion testing: exports.usage = function() {} for custom results of test\n- added: assertion testing: exports.disabled = true for disabling current test\n- added: assertion testing: priority (example: exports.priority = 1)\n- added: routing supports multiple HTTP-VERBS/METHODS together (author: bir <https://github.com/bir>)\n- added: routing supports options for middleware, author: bir <https://github.com/bir>\n- added: config-test (new config file)\n- added: config['default-interval-clear-resources'], default 20 (minutes)\n- added: config['default-interval-clear-temporary'], default 3 (minutes)\n- added: config['default-interval-precompile-views'], default 61 (minutes)\n- added: config['default-interval-websocket-ping'], default 1 (minutes)\n- added: config['disable-strict-server-certificate-validation'], default true\n- added: create automatically a ping message for websocket clients\n- added: global INSTALL(type, name, declaration/url/function, [options], [callback]);\n- added: global UNINSTALL(type, name, [options]);\n- added: global CONTROLLER(name);\n- added: framework.install(type, name, declaration/url/function, [options], [callback]);\n- added: framework.uninstall(type, name, [options]);\n- added: framework.on('install', function(type, name) {});\n- added: framework.on('uninstall', function(type, name) {});\n- added: framework.on('route-add', function(type, route) {})\n- added: module/model/source/controller: exports.name = 'name ';\n- added: module/model/source/controller: exports.version = 'version';\n- added: model/source: exports.install = function(framework, options, name) {}\n- added: module/model/source/controller: exports.uninstall = function(framework, options) {}\n- added: String.prototype.parseDateExpire() - parse expiration date, example: '1 minute', '1 year'\n- added: String.parseConfig([default]);\n- added: framework.fs.create.database()\n- added: framework.fs.rm.database()\n- added: controller.isTransfer\n- added: Date.compare(date) - for instance of date;\n- added: Date.compare(d1, d2);\n- added: Controller.date(type, date)\n- added: Controller.callback([viewName])\n- added: HttpFile.type (HttpFile.contentType is deprecated)\n- added: controller.section(name, [value]);\n\n- updated: NoSQL v2.0.8\n- updated: String.parseDate('yyyy-MM-dd HH:mm:ss') - time is optional\n- updated: module: exports.install = function(framework, options) {};\n- updated: (IMPORTANT) INCLUDE(name, [options]), SOURCE(name, [options]) â> object\n- updated: (IMPORTANT) SOURCE(name, [options]), framework.source(name, [options]) â> object\n- updated: framework.controller(name) - definition was removed (use: framework.install())\n- updated: framework.run([http], config, [port], [ip], [options])\n- updated: utils.validate(), Builders.validate() â> prepare function (added: schemaName): function(name, value, path, schemaName)\n- updated: framework.assert() supports \"data\" as function (for future data)\n- updated: empty-project\n- updated: request.signature([key]) - added key param\n- updated: middleware function to: function(req, res, next) {}\n- update: expiration supports string (framework.cache, response.cookie), example: '1 minute'\n- updated: $view(name, model, [expire]), $viewToggle(name, model, [expire]) - added expiration {String}\n- updated: controller.validate('schema_name', model);\n- updated: Angular.js version\n- updated: @{css()} and @{js()} supports multiple values\n- updated: @{place()} doesn't add `<script>` tag automatically\n\n- renamed: framework.on('expire') -> framework.on('cache-expire')\n- renamed: framework.accepts(extension, [contentType]) -> framework.accept(extension, [contentType])\n\n- fixed: controller.custom()\n- fixed: utils.validate()\n- fixed: long messages in WebSocket by Andrea Sessa <https://plus.google.com/u/0/104713619368072403016>\n- fixed: view engine parser (reported by @tohachan)\n- fixed: Builders.prepare()\n- fixed: Builders.validate()\n- fixed: framework.responseFile()\n- fixed: framework.onCompileStatic()\n- fixed: framework configuration\n- fixed: JS CSS\n- fixed: Auto vendor prefixer (CSS)\n- fixed: Image.command()\n\n- removed: (IMPORTANT) COMPONENTS()\n- removed: (IMPORTANT) prefixes + framework.onPrefix()\n- removed: (IMPORTANT) controller.framework (use: framework. instead of self.framework)\n- removed: (IMPORTANT) global middleware from controllers\n- removed: (IMPORTANT) global module #\n- removed: (IMPORTANT) Request.data.get\n- removed: (IMPORTANT) Request.data.post\n- removed: (IMPORTANT) Request.data.files\n- removed: (IMPORTANT) view engine: templates were changed to views\n- removed: (IMPORTANT) `@{content()}`\n- removed: (IMPORTANT) framework.injectModel() -> framework.install()\n- removed: (IMPORTANT) framework.injectModule() -> framework.install()\n- removed: (IMPORTANT) framework.injectSource() -> framework.install()\n- removed: (IMPORTANT) framework.injectDefinition() -> framework.install()\n- removed: (IMPORTANT) framework.injectController() -> framework.install()\n- removed: (IMPORTANT) framework.onRoute() - TIP: use middleware\n- removed: (IMPORTANT) framework.onRequest() - TIP: use middleware\n- removed: (IMPORTANT) controller & module -> exports.request()\n\n- clean code\n- improvements: framework\n\n======= 1.5.3 (HOTFIX)\n\n- added: request.query (alias for request.data.get)\n\n- (IMPORTANT) renamed: framework.partial() to framework.middleware()\n\n- fixed: exit code in assertion testing (bug with lowest priority)\n- (CRITICAL) fixed: WebSocket event\n\n======= 1.5.2 (HOTFIX)\n\n- added: CONFIG(name) - returns a value from the config file\n- added: RESOURCE(name, key) - returns a value from the resource file\n- added: utils.parseXML(xml)\n- added: config['static-accept'] += '.json'\n- added: String.prototype.slug([max])\n- added: Array.prototype.orderBy([name], [asc])\n- added: framework.on('request', function(req, res) {})\n- added: framework.on('websocket', function(req, socket) {})\n\n- updated: assertion testing\n\n- fixed: WebSocket in IE\n- fixed: calling global helpers like this: @{someHelper('some-argument')}\n- fixed: controller.proxy()\n- fixed: request.signature()\n- fixed: cache.read() - problem with exact expiration\n- fixed: \"options\" route flag\n- fixed: configuration (fixer: @peterkc)\n- fixed: schemas\n- fixed: assertion testing\n- fixed: view @{foreach ....}\n\n======= 1.5.0 & 1.5.1\n\n- added: TOTAL.JS PACKAGE MANAGER (new binary: tpm === [t]otal.js [p]ackage [m]anager)\n- added: JS CSS (important: removed LESS)\n- added: framework.noCache(req, [res])\n- added: request.noCache()\n- added: response.noCache()\n- added: new config file (this file is loaded in a debug and in a release mode): /some-app/config\n- added: String.prototype.startsWith(text, [ignoreCase]);\n- added: String.prototype.endsWith(text, [ignoreCase]);\n- added: picture auto resizer: framework.resize(url, [width], [height], [extensions], [path], [options])\n- added: .webm into the config['static-accepts']\n- added: in views - into the repository, model, user, session, get, post, global, config can assign some value: @{repository.name = 'total.js'}\n- added: in views - supports @{foreach [property] in [array]} ... @{end}\n- added: in views - supports nested conditions\n- added: in views - supports inline helpers\n- added: in views - supports sections\n- added: controller.throw400([problem])\n- added: controller.throw401([problem])\n- added: controller.throw403([problem])\n- added: controller.throw404([problem])\n- added: controller.throw500(error)\n- added: controller.throw501([problem])\n- added: request.signature()\n- added: Builders.create(schemaName)\n- added: controller.exception\n- added: framework.onMail(address, subject, body, callback)\n- added: controller.mail(address, subject, viewName, [model], [callback])\n- added: controller.transfer(url, [flags])\n\n- updated: config['default-websocket-encodedecode'] - default: true\n- updated: @{options(array/object)} - supports Object\n- updated: utils.request(url, flags, [data], callback, cookies, headers, encoding, timeout)\n- updated: utils.download(url, flags, [data], callback, cookies, headers, encoding, timeout)\n- updated: framework.eval(string/url/function) - this function supports eval code from another URL\n- updated: assertion testing (new features)\n- updated: framework.isProcessed(filename or request)\n- updated: framework.isProcessing(filename or request)\n- updated: binary (some changes and improvements)\n- updated: template engine\n- updated: ErrorBuidler.toString([delimiter])\n\n- renamed: ErrorBuilder.length -> ErrorBuilder.count\n\n- fixed: framework.isProcessed()\n- fixed: binary (test.js in empty-project)\n- fixed: @{ngCommon()}\n- fixed: @{ngStyle()}\n- fixed: measure JPG - extended buffer\n- fixed: utils.validate()\n- fixed: Mail sender (problem with TLS)\n\n- removed: IMPORTANT: old template engine was removed from templates\n- removed: IMPORTANT: LESS CSS\n\n- improvements: views\n- improvements: templates\n\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/controller-transfer\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/controller-mail\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/css-jscss\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/routing-resize\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/views-place-sections\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/views\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/views-custom-helper\n\n======= 1.4.0\n\n- added: new global methods: INCLUDE() - framework.source(), SOURCE() - framework.source(), MODEL(name) -> framework.model(), MODULE(name) -> framework.module(), DATABASE() -> framework.database()\n- added: unauthorize flag\n- added: config['allow-compress-html'] (default: true)\n- added: controller.language (read from request.language)\n- added: framework sets response['Content-Length'] for some static files\n\n- updated: debug.js (added \"source\")\n\n- fixed: View not found (message includes full filename)\n- fixed: @{ngFilter()}\n- fixed: routing priority\n- fixed: config['allow-gzip']\n- fixed: utils.decode()\n- fixed: utils.request()\n\n- renamed: String.prototype.link([max]) to -> String.prototype.linker([max])\n\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/font-awesome\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/websocket\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/angularjs-websocket\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/config-debug-release\n\n- MODULES (NEW): https://github.com/totaljs/modules/tree/master/twitter\n\n======= 1.3.1 (HOTFIX)\n\n- updated: angular.js version (v1.2.15)\n\n- fixed: partial views rendering in the layout\n- fixed: internally utils\n\n======= 1.3.0\n\n- added: supports CoffeeScript\n- added: framework.isWindows (readonly, boolean)\n- added: framework.isCoffee (readonly, boolean)\n- added: framework.config['directory-source'], great for business logic\n- added: framework.injectSource(name)\n- added: framework.source(name), call a business logic\n- added: new global methods include() and source() are linked into the config['directory-source']\n- added: config['default-websocket-encodedecode'] - encodeURIComponent && decodeURIComponent (IMPORTANT: default: false)\n- added: Builders.ErrorBuilder.resource(filename, prefix) - can change resource filename or prefix\n- added: new global variables - Builders, Mail, Utils\n- added: Builders.validate(schemaName, model) - returns ErrorBuilder from everywhere (uses framework.resource)\n- added: allowed controllers in subdirectories\n- added: utils.assign(obj, path, value/function) - read more in documentation\n\n- updated: Builders.schema(name, obj, [defaults], [validator]) - validator is new\n- updated: Builders.validation(name, [arr] or [function])\n- updated: controller.find(id or function)\n- updated: utils.copy(source, [target]);\n- updated: WebSocket.close([id], [message], [code]);\n- updated: WebSocketClient.close([message], [code]);\n\n- fixed: Controller properties on the WebSocket connections\n- fixed: binary\n- fixed: utils.validation()\n- fixed: multipart upload (problem with multiple values)\n- fixed: layout in partial views (from the controller)\n- fixed: Windows path\n\nIMPORTANT:\nrewritten: WebSocket + WebSocket supports: text, JSON, binary, ping + pong\n\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/angularjs-bootstrap\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/bootstrap\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/framework-schema-validation\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/webrtc (unfinished but for an idea)\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/framework-business-logic-source\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/framework-inject-business-logic-source\n\n======= 1.2.3-1 (HOTFIX)\n\nIMPORTANT:\n- fixed: [authorize] flag\n- updated: utils.copy(source, target), previous: utils.copy(target, source);\n\n======= 1.2.3\n\n- added: view @{helper('name', [arg1], [arg2], ...)}\n- added: controller.helper(name, [arg1], [arg2], ...)\n- added: controller.change(message)\n- added: new markup /*auto*/ for auto-vendor-prefixes\n- added: [authorize] flag\n- added: @{ng(name)}\n- added: @{ngTemplate(name, [id])}\n- added: @{ngController(name)}\n- added: @{ngFilter(name)}\n- added: @{ngService(name)}\n- added: @{ngDirective(name)}\n- added: @{ngResource(name)}\n- added: @{ngCommon(name)}\n- added: @{ngInclude(name)}\n- added: @{ngStyle(name)}\n- added: @{ngLocale(name)}\n- added: @{helper(helperName, [param1], [param2], ...)}\n- added: config['directory-angular']\n- added: config['angular-version']\n- added: config['angular-i18n-version']\n- added: binary: total -angular [or] total -a\n- added: framework.change(message, [name], [uri], [ip]);\n- added: framework.changes;\n- added: framework.on('change', message, [name], [uri], [ip]);\n\nIMPORTANT:\n- added: routing with asterix, example: framework.route('/subpage/*', ...);\n\nIMPORTANT:\n- updated: [logged] flag is obsolete, new flag: authorize\n- updated: [unlogged] flag is obsolete (without flag)\n\n- fixed: helpers\n- fixed: static files caching in debug mode\n\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/angularjs\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/angularjs-websocket\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/angularjs-common\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/angularjs-mongodb-rest-resources\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/angularjs-routing\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/changes\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/routing\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/problems\n\n======= 1.2.1-1 (NPM problem)\n======= 1.2.1   (NPM problem)\n======= 1.2.0\n\n- new: NEW TEMPLATE ENGINE 2.0\n\n- added: route to website, route to file and route to websocket is possible everywhere\n- added: node harmony functions (see example)\n- added: gc() into framework.on('service')\n- added: config['allow-performance'] true/false (default, false)\n- added: config['default-image-converter'] (default \"gm\" - GraphicsMagick, another possibility: \"im\" - ImageMagick)\n- added: new views/templates/contents cache\n- added: framework.problem(message, [name], [uri], [ip]);\n- added: framework.on('problem', message, [name], [uri], [ip])\n- added: framework.problems;\n- added: req.language;\n- added: controller.title()\n- added: controller.description()\n- added: controller.keywords()\n- added: controller.problem(message)\n- added: controller.memorize(key, expire, fnTo, [fnFrom]) - cache for controller.view(), controller.json(), controller.plain()\n- added: Array.prototype.trim()\n- added: Array.prototype.wait()\n- added: Array.prototype.async()\n- added: String.prototype.hash([type])\n- added: Pagination.next([format]), Pagination.prev([format])\n- added: utils.isRegExp(obj)\n\n- updated: license\n- updated: parsing of configuration: # and // is a comment\n- updated: auto-vendor-prefixes (updated linear-gradient prioraty according to w3schools.com)\n- updated: websocket.send(message, [id], [blacklist]), id and blacklist can be a function\n- updated: controller.view400([problem])\n- updated: controller.view403([problem])\n- updated: controller.view404([problem])\n- updated: controller.view501([problem])\n- updated: controller.plain(contentBody, [headers]) - added JSON serialized for objects\n- updated: controller.json(obj, [header], [beaufity]);\n- updated: framework.usage([detailed]) - returns OBJECT\n- updated: FrameworkCache.removeAll(search or regexp-pattern)\n- updated: @{sitemap} is currently: @{sitemap()}\n- updated: PageBuilder\n- updated: @{template()} and controller.template() - default repository is controller repository\n\n- removed: border-radius and box-shadow from auto-vendor-prefixes\n\n- obsolete: Array.prototype.waiting()\n\n- fixed: controller.view500()\n- fixed: controller.proxy(), utils.request(), utils.download() - problem with NGINX, missing Content-Length header\n- fixed: WebSocket skips throwing error (socket close, EPIPE)\n- fixed: mail (SPAM fixes)\n- fixed: buffer.write (new node => 0.11.11)\n- fixed: IP and heroku deploy\n\n- rewritten: view engine\n- rewritten: template engine (according to view engine)\n\n- improvements: views\n- improvements: templates\n- improvements: partial routing\n\nIMPORTANT: framework.usage() returns OBJECT\nIMPORTANT: markup of template is OBSOLETE. Templates support only view markup.\n\n- EXAMPLE (NEW): https://github.com/totaljs/demo\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/heroku\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/controller-memorize\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/generators\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/routing-inline\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/problems\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/mongoose\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/pagination\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/templates\n\n======= 1.1.0\n\n- added: new feature COMPONENTS\n- added: new feature MODELS\n- added: framework.id\n- added: framework.isDebug\n- added: framework.isTest\n- added: framework.model(name)\n- added: framework.controller(name, definition)\n- added: framework.functions\n- added: framework.assert(name, callback)\n- added: framework.assert(name, url, callback, method, data, headers, xhr)\n- added: framework.injectComponent(name, url)\n- added: framework.injectModel(name, url)\n- added: framework.path.components([filename])\n- added: framework.path.models([filename])\n- added: controller.model(name)\n- added: controller.$model - (property contains current model)\n- added: flag: OPTIONS\n\n- updated: framework.usage([detailed])\n- updated: BINARY\n- updated: WebSocket skips throwing error (ECONNRESET)\n\n- fixed: framework.controller(name)\n- fixed: // char in views and templates\n- fixed: assertion testing\n- fixed: mail attachment (fixed: line too long)\n- fixed: \"@charset\" keyword in CSS\n- fixed: cache-control header\n- fixed: HTML conditional comments in views\n- fixed: controller.cors(), fixed problem with preflight\n- fixed: controller.empty() -> added 204 http status code\n\nimprovements: views (in release mode)\n\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/components\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/models\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/minimal\n- EXAMPLE (NEW): https://github.com/totaljs/examples/tree/master/framework-functions\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/cors\n- EXAMPLE (UPD): https://github.com/totaljs/examples/tree/master/cluster\n\n======= 1.0.2 (HOTFIX)\n\n- fixed: mail message (problem with diacritics in OUTLOOK)\n\n======= 1.0.1 (HOTFIX)\n\n- added: advanced template conditions\n\n- fixed: builders.prepare()\n- fixed: binary (command-line tools)\n- fixed: views conditions\n"
        },
        {
          "name": "cluster.js",
          "type": "blob",
          "size": 11.466796875,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkCluster\n * @version 3.4.0\n */\n\nconst Fs = require('fs');\nconst Cluster = require('cluster');\nconst CLUSTER_REQ = { TYPE: 'req' };\nconst CLUSTER_RES = { TYPE: 'res' };\nconst CLUSTER_EMIT = { TYPE: 'emit' };\nconst CLUSTER_MASTER = { TYPE: 'master' };\nconst MAXTHREADLATENCY = 70;\nconst FORKS = [];\n\nvar OPERATIONS = {};\nvar CALLBACKS = {};\nvar OPTIONS = {};\nvar THREADS = 0;\nvar MASTER = null;\nvar CONTINUE = false;\nvar STATS = [];\nvar TIMEOUTS = {};\n\nexports.on = function(name, callback) {\n\t!MASTER && (MASTER = {});\n\tif (MASTER[name])\n\t\tMASTER.push(callback);\n\telse\n\t\tMASTER[name] = [callback];\n\treturn F;\n};\n\nexports.emit = function(name, a, b, c, d, e) {\n\n\tCLUSTER_EMIT.name = name;\n\tCLUSTER_EMIT.a = a;\n\tCLUSTER_EMIT.b = b;\n\tCLUSTER_EMIT.c = c;\n\tCLUSTER_EMIT.d = d;\n\tCLUSTER_EMIT.e = e;\n\n\tif (Cluster.isMaster)\n\t\tmessage(CLUSTER_EMIT);\n\telse if (F.isCluster)\n\t\tprocess.send(CLUSTER_EMIT);\n\n\treturn F;\n};\n\nexports.master = function(name, a, b, c, d, e) {\n\tif (F.isCluster) {\n\t\tCLUSTER_MASTER.name = name;\n\t\tCLUSTER_MASTER.a = a;\n\t\tCLUSTER_MASTER.b = b;\n\t\tCLUSTER_MASTER.c = c;\n\t\tCLUSTER_MASTER.d = d;\n\t\tCLUSTER_MASTER.e = e;\n\t\tprocess.send(CLUSTER_MASTER);\n\t}\n\treturn F;\n};\n\nexports.request = function(name, data, callback, timeout) {\n\n\tif (typeof(data) === 'function') {\n\t\ttimeout = callback;\n\t\tcallback = data;\n\t\tdata = null;\n\t}\n\n\tCLUSTER_REQ.name = name;\n\tCLUSTER_REQ.data = data;\n\tCLUSTER_REQ.callback = (Math.random()).toString(32).substring(3);\n\tvar obj = CALLBACKS[CLUSTER_REQ.callback] = { fn: callback, response: [], id: CLUSTER_REQ.callback };\n\n\tobj.timeout = setTimeout(function(obj) {\n\t\tdelete CALLBACKS[obj.id];\n\t\tobj.fn && obj.fn(new Error('Timeout.'), obj.response);\n\t}, timeout || 3000, obj);\n\n\tif (Cluster.isMaster)\n\t\tmastersend(CLUSTER_REQ);\n\telse\n\t\tprocess.send(CLUSTER_REQ);\n\treturn F;\n};\n\nexports.response = function(name, callback) {\n\tOPERATIONS[name] = callback;\n\treturn F;\n};\n\nexports.req = function(message) {\n\n\tif (!F.isCluster)\n\t\treturn F;\n\n\t// message.id\n\t// message.name\n\t// message.data\n\t// message.callback\n\n\tif (OPERATIONS[message.name]) {\n\t\tOPERATIONS[message.name](message.data, function(response) {\n\t\t\tCLUSTER_RES.data = response;\n\t\t\tCLUSTER_RES.target = message.id;\n\t\t\tCLUSTER_RES.callback = message.callback;\n\t\t\tprocess.send(CLUSTER_RES);\n\t\t}, message.id);\n\t} else {\n\t\tCLUSTER_RES.target = message.id;\n\t\tCLUSTER_RES.data = undefined;\n\t\tCLUSTER_RES.callback = message.callback;\n\t\tprocess.send(CLUSTER_RES);\n\t}\n\n\treturn F;\n};\n\nexports.res = function(message) {\n\tvar callback = CALLBACKS[message.callback];\n\tcallback.fn && callback.response.push(message.data);\n\n\tvar count = message.target === 'master' ? THREADS : THREADS - 1;\n\tif (callback.response.length >= count) {\n\t\tdelete CALLBACKS[callback.id];\n\t\tclearTimeout(callback.timeout);\n\t\tcallback.fn && callback.fn(null, callback.response);\n\t}\n};\n\nexports.http = function(count, mode, options, callback) {\n\t// Fork will obtain options automatically via event\n\tif (Cluster.isMaster) {\n\t\tCLUSTER_REQ.id = 'master';\n\t\tCLUSTER_RES.id = 'master';\n\t\tCLUSTER_EMIT.id = 'master';\n\t\tmaster(count, mode, options, callback);\n\t} else\n\t\tfork();\n};\n\nexports.https = function(count, mode, options, callback) {\n\t// Fork will obtain options automatically via event\n\tif (Cluster.isMaster) {\n\t\tCLUSTER_REQ.id = 'master';\n\t\tCLUSTER_RES.id = 'master';\n\t\tCLUSTER_EMIT.id = 'master';\n\t\tmaster(count, mode, options, callback, true);\n\t} else\n\t\tfork();\n};\n\nexports.restart = function(index) {\n\tif (index === undefined) {\n\t\tfor (var i = 0; i < THREADS; i++)\n\t\t\tsetTimeout(index => exports.restart(index), i * 2000, i);\n\t} else {\n\t\tvar fork = FORKS[index];\n\t\tif (fork) {\n\t\t\tfork.$ready = false;\n\t\t\tfork.removeAllListeners();\n\t\t\tfork.disconnect();\n\t\t\texec(index);\n\t\t} else\n\t\t\texec(index);\n\n\t\tRELEASE && console.log('======= ' + (new Date().format('yyyy-MM-dd HH:mm:ss')) + ': restarted thread with index \"{0}\"'.format(index));\n\t}\n};\n\nfunction master(count, mode, options, callback, https) {\n\n\tif (count == null)\n\t\tcount = require('os').cpus().length;\n\n\tOPTIONS.auto = count === 'auto';\n\n\tif (OPTIONS.auto)\n\t\tcount = 1;\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = {};\n\t}  else if (!options)\n\t\toptions = {};\n\n\tOPTIONS.count = count;\n\tOPTIONS.mode = mode;\n\tOPTIONS.options = options;\n\n\tvar Os = require('os');\n\trequire('./utils');\n\n\tconsole.log('==================== CLUSTER =======================');\n\tconsole.log('PID         : ' + process.pid);\n\tconsole.log('Node.js     : ' + process.version);\n\tconsole.log('OS          : ' + Os.platform() + ' ' + Os.release());\n\tconsole.log('Threads     : {0}'.format(OPTIONS.auto ? 'auto' : (count + 'x')));\n\tconsole.log('====================================================');\n\tconsole.log('Date        : ' + new Date().format('yyyy-MM-dd HH:mm:ss'));\n\tconsole.log('Mode        : ' + mode);\n\toptions.thread && console.log('Thread      : ' + options.thread);\n\tconsole.log('====================================================\\n');\n\n\tif (options.thread)\n\t\tglobal.THREAD = options.thread;\n\n\tif (mode === 'debug') {\n\t\trequire('./debug').watcher(function(changes) {\n\t\t\tvar can = false;\n\t\t\tif (options.thread) {\n\t\t\t\tfor (var i = 0; i < changes.length; i++) {\n\t\t\t\t\tvar change = changes[i];\n\t\t\t\t\tif (change.indexOf('/threads/') !== -1) {\n\t\t\t\t\t\tif (change.indexOf('/threads/' + options.thread + '/') !== -1) {\n\t\t\t\t\t\t\tcan = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcan = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan = true;\n\t\t\tcan && exports.restart();\n\t\t});\n\t}\n\n\t// Remove all DB locks\n\tFs.readdir(F.path.databases(), function(err, files) {\n\t\tif (!err) {\n\t\t\tvar reglock = /(\\.nosql-lock|\\.table-lock|\\.nosql-counter2-lock)$/;\n\t\t\tfor (var i = 0; i < files.length; i++) {\n\t\t\t\tvar file = files[i];\n\t\t\t\treglock.test(file) && Fs.unlinkSync(F.path.databases(file));\n\t\t\t}\n\t\t}\n\t});\n\n\tTHREADS = count;\n\n\tvar can = function(cb) {\n\t\tif (CONTINUE)\n\t\t\tcb();\n\t\telse\n\t\t\tsetTimeout(can, 500, cb);\n\t};\n\n\tcount.async(function(i, next) {\n\t\texec(Math.abs(i - THREADS), https);\n\t\tcan(next);\n\t}, function() {\n\t\tcallback && callback(FORKS);\n\t});\n\n\tprocess.title = 'total: cluster';\n\n\tvar filename = require('path').join(process.cwd(), 'restart' + (options.thread ? ('_' + options.thread) : ''));\n\tvar restartthreads = function(err) {\n\t\tif (!err) {\n\t\t\tFs.unlink(filename, NOOP);\n\t\t\tif (!F.restarting) {\n\t\t\t\texports.restart();\n\t\t\t\tF.restarting = true;\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tF.restarting = false;\n\t\t\t\t}, 30000);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar killme = function(fork) {\n\t\tfork.kill();\n\t};\n\n\tvar counter = 0;\n\tvar main = {};\n\tmain.pid = process.pid;\n\tmain.version = {};\n\tmain.version.node = process.version;\n\tmain.version.total = F.version_header;\n\tmain.version.app = CONF.version;\n\tmain.thread = options.thread;\n\n\tsetInterval(function() {\n\n\t\tcounter++;\n\n\t\tif (counter % 10 === 0) {\n\t\t\tmain.date = new Date();\n\t\t\tmain.threads = THREADS;\n\t\t\tvar memory = process.memoryUsage();\n\t\t\tmain.memory = (memory.heapUsed / 1024 / 1024).floor(2);\n\t\t\tmain.stats = STATS;\n\t\t\tFs.writeFile(process.mainModule.filename + '.json', JSON.stringify(main, null, '  '), NOOP);\n\t\t}\n\n\t\tFs.stat(filename, restartthreads);\n\n\t\t// Ping\n\t\tif (!OPTIONS.auto)\n\t\t\treturn;\n\n\t\tvar isfree = false;\n\t\tvar isempty = false;\n\n\t\t// Auto-ping\n\t\tfor (var i = 0; i < FORKS.length; i++) {\n\t\t\tvar fork = FORKS[i];\n\t\t\tif (fork) {\n\t\t\t\tif (fork.$ping) {\n\t\t\t\t\tif (fork.$ping < MAXTHREADLATENCY)\n\t\t\t\t\t\tisfree = true;\n\t\t\t\t} else\n\t\t\t\t\tisempty = true;\n\n\t\t\t\tfork.$ping_beg = Date.now();\n\t\t\t\tfork.send('total:ping');\n\t\t\t}\n\t\t}\n\n\t\tif (isfree || isempty) {\n\t\t\tif (!isempty && THREADS > 1) {\n\t\t\t\t// try to remove last\n\t\t\t\tvar lastindex = FORKS.length - 1;\n\t\t\t\tvar last = FORKS[lastindex];\n\t\t\t\tif (last == null) {\n\t\t\t\t\tTIMEOUTS[lastindex] && clearTimeout(TIMEOUTS[lastindex]);\n\t\t\t\t\tFORKS.splice(lastindex, 1);\n\t\t\t\t\tSTATS.splice(lastindex, 1);\n\t\t\t\t\tTHREADS = FORKS.length;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < STATS.length; i++) {\n\t\t\t\t\tif (STATS[i].id === last.$id) {\n\t\t\t\t\t\tif (STATS[i].pending < 2) {\n\t\t\t\t\t\t\t// nothing pending\n\t\t\t\t\t\t\tfork.$ready = false;\n\t\t\t\t\t\t\tfork.removeAllListeners();\n\t\t\t\t\t\t\tfork.disconnect();\n\t\t\t\t\t\t\tsetTimeout(killme, 1000, fork);\n\t\t\t\t\t\t\tFORKS.splice(lastindex, 1);\n\t\t\t\t\t\t\tSTATS.splice(lastindex, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTHREADS = FORKS.length;\n\t\t\t}\n\t\t} else if (!options.max || THREADS < options.max)\n\t\t\texec(THREADS++, https);\n\n\t}, 5000);\n}\n\nfunction message(m) {\n\n\tif (m === 'total:ready') {\n\t\tCONTINUE = true;\n\t\tthis.$ready = true;\n\t\treturn;\n\t}\n\n\tif (m === 'total:ping') {\n\t\tthis.$ping = Date.now() - this.$ping_beg;\n\t\treturn;\n\t}\n\n\tif (m === 'total:update') {\n\t\tfor (var i = 1, length = FORKS.length; i < length; i++)\n\t\t\tFORKS[i] && FORKS[i].$ready && FORKS[i].send(m);\n\t\treturn;\n\t}\n\n\tif (m.TYPE === 'master') {\n\t\tif (MASTER && MASTER[m.name]) {\n\t\t\tfor (var i = 0, length = MASTER[m.name].length; i < length; i++)\n\t\t\t\tMASTER[m.name][i](m.a, m.b, m.c, m.d, m.e);\n\t\t}\n\t} else if (m.TYPE === 'snapshot') {\n\t\tvar is = false;\n\t\tSTATS[i];\n\t\tfor (var i = 0; i < STATS.length; i++) {\n\t\t\tif (STATS[i].id === m.data.id) {\n\t\t\t\tm.data.ping = this.$ping;\n\t\t\t\tSTATS[i] = m.data;\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t!is && STATS.push(m.data);\n\t} else {\n\n\t\tif (m.target === 'master') {\n\t\t\texports.res(m);\n\t\t} else {\n\t\t\tfor (var i = 0, length = FORKS.length; i < length; i++)\n\t\t\t\tFORKS[i] && FORKS[i].$ready && FORKS[i].send(m);\n\t\t}\n\t}\n}\n\nfunction mastersend(m) {\n\tfor (var i = 0, length = FORKS.length; i < length; i++)\n\t\tFORKS[i] && FORKS[i].send(m);\n}\n\nfunction exec(index, https) {\n\n\tif (TIMEOUTS[index]) {\n\t\tclearTimeout(TIMEOUTS[index]);\n\t\tdelete TIMEOUTS[index];\n\t}\n\n\tvar fork = Cluster.fork();\n\tfork.$id = index.toString();\n\tfork.on('message', message);\n\tfork.on('exit', function() {\n\t\tFORKS[index] = null;\n\t\tTIMEOUTS[index] = setTimeout(exports.restart, 1000, index);\n\t});\n\n\tif (FORKS[index] === undefined)\n\t\tFORKS.push(fork);\n\telse\n\t\tFORKS[index] = fork;\n\n\t(function(fork) {\n\t\tsetTimeout(function() {\n\t\t\tOPTIONS.options.id = fork.$id;\n\t\t\tfork.send({ TYPE: 'init', bundling: !CONTINUE, id: fork.$id, mode: OPTIONS.mode, options: OPTIONS.options, threads: OPTIONS.count, index: index, https: https });\n\t\t}, fork.$id * 500);\n\t})(fork);\n}\n\nfunction fork() {\n\trequire('./index');\n\tF.on('message', on_init);\n}\n\nfunction on_init(msg) {\n\tswitch (msg.TYPE) {\n\t\tcase 'init':\n\t\t\tCLUSTER_EMIT.id = msg.id;\n\t\t\tCLUSTER_REQ.id = msg.id;\n\t\t\tCLUSTER_RES.id = msg.id;\n\t\t\tTHREADS = msg.threads;\n\t\t\tmsg.options.bundling = msg.bundling;\n\t\t\tif (msg.https)\n\t\t\t\tF.https(msg.mode, msg.options);\n\t\t\telse\n\t\t\t\tF.http(msg.mode, msg.options);\n\t\t\tF.isCluster = true;\n\t\t\tF.removeListener(msg.TYPE, on_init);\n\t\t\tbreak;\n\t}\n}"
        },
        {
          "name": "debug.js",
          "type": "blob",
          "size": 12.4443359375,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkDebug\n * @version 3.4.3\n */\n\nconst Path = require('path');\nconst Fs = require('fs');\nconst debugging = process.argv.indexOf('debugging') !== -1;\nconst Os = require('os');\nconst isWindows = Os.platform().substring(0, 3).toLowerCase() === 'win';\n\nvar first = process.argv.indexOf('restart') === -1;\nvar options = null;\nvar initdelay;\nvar watchercallback;\n\nmodule.exports = function(opt) {\n\toptions = opt;\n\t// options.ip = '127.0.0.1';\n\t// options.port = parseInt(process.argv[2]);\n\t// options.config = { name: 'Total.js' };\n\t// options.https = { key: Fs.readFileSync('keys/agent2-key.pem'), cert: Fs.readFileSync('keys/agent2-cert.pem')};\n\t// options.sleep = 3000;\n\t// options.inspector = 9229;\n\t// options.debugger = 40894;\n\t// options.watch = ['adminer'];\n\t// options.livereload = true;\n};\n\nmodule.exports.watcher = function(callback) {\n\tinitdelay && clearTimeout(initdelay);\n\tinitdelay = null;\n\twatchercallback = callback;\n\trunwatching();\n};\n\nfunction runapp() {\n\n\t!options && (options = {});\n\trequire('total.js');\n\n\tvar port = parseInt(process.argv[process.argv.length - 1]);\n\n\tif (!isNaN(port))\n\t\toptions.port = port;\n\n\tif (port > 0 && !options.port)\n\t\toptions.port = port || 8000;\n\n\tif (options.https)\n\t\tF.https('debug', options);\n\telse\n\t\tF.http('debug', options);\n\n\tif (first)\n\t\tEMIT('debug-start');\n\telse\n\t\tEMIT('debug-restart');\n}\n\nfunction runwatching() {\n\n\t!options && (options = {});\n\trequire('./index');\n\n\tconst FILENAME = U.getName(process.argv[1] || 'debug.js');\n\tconst directory = process.cwd();\n\tconst VERSION = F.version_header;\n\tconst REG_CONFIGS = /configs\\//g;\n\tconst REG_FILES = /config-debug|config-release|config|versions|workflows|sitemap|dependencies|\\.js$|\\.resource$/i;\n\tconst REG_THEMES = /\\/themes\\//i;\n\tconst REG_PUBLIC = /\\/public\\//i;\n\tconst REG_COMPONENTS = /components\\/.*?\\.html|\\.package\\/.*?$/i;\n\tconst REG_THEMES_INDEX = /themes(\\/|\\\\)?[a-z0-9_.-]+(\\/|\\\\)?index\\.js$/i;\n\tconst REG_EXTENSION = /\\.(js|resource|package|bundle)$/i;\n\tconst REG_RELOAD = /\\.(js|css|html|htm|jpg|png|gif|ico|svg|resource)$/i;\n\tconst isRELOAD = !!options.livereload;\n\tconst SPEED = isRELOAD ? 1000 : 1500;\n\tconst ARGV = CLONE(process.argv);\n\tconst PIDNAME = FILENAME.replace(/\\.js$/, '.pid');\n\n\tfunction copyFile(oldname, newname, callback) {\n\t\tvar writer = Fs.createWriteStream(newname);\n\t\tcallback && writer.on('finish', callback);\n\t\tFs.createReadStream(oldname).pipe(writer);\n\t}\n\n\tfunction app() {\n\n\t\tif (!watchercallback) {\n\t\t\tglobal.OBSOLETE = NOOP;\n\t\t\tF.config.allow_ssc_validation = true;\n\t\t\tF.$configure_configs();\n\t\t}\n\n\t\tF.directory = directory;\n\n\t\tconst fork = require('child_process').fork;\n\t\tconst directories = [\n\t\t\tU.combine(CONF.directory_components),\n\t\t\tU.combine(CONF.directory_controllers),\n\t\t\tU.combine(CONF.directory_definitions),\n\t\t\tU.combine(CONF.directory_operations),\n\t\t\tU.combine(CONF.directory_isomorphic),\n\t\t\tU.combine(CONF.directory_modules),\n\t\t\tU.combine(CONF.directory_models),\n\t\t\tU.combine(CONF.directory_schemas),\n\t\t\tU.combine(CONF.directory_tasks),\n\t\t\tU.combine(CONF.directory_resources),\n\t\t\tU.combine(CONF.directory_source),\n\t\t\tU.combine(CONF.directory_workers),\n\t\t\tU.combine(CONF.directory_packages),\n\t\t\tU.combine(CONF.directory_themes),\n\t\t\tU.combine(CONF.directory_configs),\n\t\t\tU.combine(CONF.directory_bundles),\n\t\t\tU.combine('/startup/'),\n\t\t\tU.combine('/plugins/')\n\t\t];\n\n\t\tif (global.THREAD)\n\t\t\tdirectories.push(U.combine('/threads/' + global.THREAD + '/'));\n\n\t\tconst SRC = U.combine(CONF.directory_src);\n\t\tconst prefix = '--------> ';\n\n\t\toptions.watch && options.watch.forEach(function(item) {\n\t\t\tif (item[0] === '/')\n\t\t\t\titem = item.substring(1);\n\t\t\tif (item[item.length - 1] === '/')\n\t\t\t\titem = item.substring(0, item.length - 1);\n\t\t\tdirectories.push(U.combine(item));\n\t\t});\n\n\t\tvar files = {};\n\t\tvar force = false;\n\t\tvar changes = [];\n\t\tvar app = null;\n\t\tvar status = watchercallback ? 1 : 0;\n\t\tvar pid = '';\n\t\tvar isLoaded = false;\n\t\tvar isSkip = false;\n\t\tvar isBUNDLE = false;\n\t\tvar blacklist = {};\n\t\tvar counter = 0;\n\t\tvar WS = null;\n\t\tvar speed = isRELOAD ? 1000 : 4000;\n\n\t\tblacklist['/' + PIDNAME] = 1;\n\t\tblacklist['/debug.pid'] = 1;\n\t\tblacklist['/debug.js'] = 1;\n\t\tblacklist['/bundle.json'] = 1;\n\t\tblacklist['/package.json'] = 1;\n\t\tblacklist['/readme.md'] = 1;\n\n\t\tif (isRELOAD && !watchercallback) {\n\t\t\tvar tmppath = Path.join(Os.tmpdir(), 'totaljslivereload');\n\t\t\tFs.mkdir(tmppath, function() {\n\t\t\t\tF.console = NOOP;\n\t\t\t\tF.websocket('/', function() {\n\t\t\t\t\tvar self = this;\n\t\t\t\t\tself.autodestroy(function() {\n\t\t\t\t\t\tWS = null;\n\t\t\t\t\t});\n\t\t\t\t\tWS = self;\n\t\t\t\t});\n\t\t\t\tF.http('release', { port: typeof(options.livereload) === 'number' ? options.livereload : 35729, directory: tmppath });\n\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tFs.statSync(F.path.root(CONF.directory_bundles));\n\t\t\tisBUNDLE = true;\n\t\t} catch(e) {}\n\n\t\tif (isBUNDLE || isRELOAD) {\n\t\t\tdirectories.push(U.combine(CONF.directory_public));\n\t\t\tdirectories.push(U.combine(CONF.directory_views));\n\t\t}\n\n\t\tfunction onFilter(path, isDirectory) {\n\t\t\tif (isBUNDLE)\n\t\t\t\treturn isDirectory ? SRC !== path : !blacklist[path.substring(directory.length)];\n\t\t\tif (isRELOAD)\n\t\t\t\treturn isDirectory ? true : REG_RELOAD.test(path);\n\t\t\treturn isDirectory && REG_THEMES.test(path) ? true : isDirectory ? true : !REG_PUBLIC.test(path) && (REG_EXTENSION.test(path) || REG_COMPONENTS.test(path) || REG_CONFIGS.test(path) || REG_THEMES_INDEX.test(path));\n\t\t}\n\n\t\tfunction onComplete(f) {\n\n\t\t\tFs.readdir(directory, function(err, arr) {\n\n\t\t\t\tvar length = arr.length;\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tvar name = arr[i];\n\t\t\t\t\tname !== FILENAME && REG_FILES.test(name) && f.push(name);\n\t\t\t\t}\n\n\t\t\t\tlength = f.length;\n\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tvar name = f[i];\n\t\t\t\t\tif (files[name] === undefined)\n\t\t\t\t\t\tfiles[name] = isLoaded ? 0 : null;\n\t\t\t\t}\n\t\t\t\trefresh();\n\t\t\t});\n\t\t}\n\n\t\tfunction livereload() {\n\t\t\tisRELOAD && setTimeout2('livereload', () => WS && WS.send('reload'), 500);\n\t\t}\n\n\t\tfunction isViewPublic(filename) {\n\n\t\t\tif (!isBUNDLE && !isRELOAD)\n\t\t\t\treturn false;\n\n\t\t\tvar fn = filename.substring(directory.length);\n\t\t\tvar index = fn.indexOf('/', 1);\n\t\t\tvar dir = fn.substring(0, index + 1);\n\n\t\t\tif (dir === CONF.directory_themes) {\n\t\t\t\tindex = fn.indexOf('/', index + 1);\n\t\t\t\tdir = fn.substring(index, fn.indexOf('/', index + 1) + 1);\n\t\t\t}\n\n\t\t\treturn CONF.directory_views === dir || CONF.directory_public === dir ? fn : '';\n\t\t}\n\n\t\tfunction makestamp() {\n\t\t\treturn '--- # --- [ ' + new Date().format('yyyy-MM-dd HH:mm:ss') + ' ] ';\n\t\t}\n\n\t\tfunction refresh() {\n\t\t\tvar reload = false;\n\t\t\tObject.keys(files).wait(function(filename, next) {\n\t\t\t\tFs.stat(filename, function(err, stat) {\n\n\t\t\t\t\tvar stamp = makestamp();\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tdelete files[filename];\n\t\t\t\t\t\tvar tmp = isViewPublic(filename);\n\t\t\t\t\t\tvar log = stamp.replace('#', 'REM') + prefix + normalize(filename.replace(directory, ''));\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\tif (isBUNDLE) {\n\t\t\t\t\t\t\t\tFs.unlinkSync(Path.join(SRC, tmp));\n\t\t\t\t\t\t\t\tconsole.log(log);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treload = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchanges.push(log);\n\t\t\t\t\t\t\tforce = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar ticks = stat.mtime.getTime();\n\n\t\t\t\t\t\tif (files[filename] != null && files[filename] !== ticks) {\n\n\t\t\t\t\t\t\tif (filename.endsWith('.bundle') && files[filename.replace(/\\.bundle$/, '.url')]) {\n\t\t\t\t\t\t\t\t// Bundle from URL address\n\t\t\t\t\t\t\t\tfiles[filename] = ticks;\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar log = stamp.replace('#', files[filename] === 0 ? 'ADD' : 'UPD') + prefix + normalize(filename.replace(directory, ''));\n\t\t\t\t\t\t\tif (files[filename]) {\n\t\t\t\t\t\t\t\tvar tmp = isViewPublic(filename);\n\t\t\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\t\t\tvar skip = true;\n\t\t\t\t\t\t\t\t\tif (isBUNDLE) {\n\t\t\t\t\t\t\t\t\t\tif (filename.lastIndexOf('--') === -1)\n\t\t\t\t\t\t\t\t\t\t\tcopyFile(filename, Path.join(SRC, tmp));\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (skip) {\n\t\t\t\t\t\t\t\t\t\tfiles[filename] = ticks;\n\t\t\t\t\t\t\t\t\t\treload = true;\n\t\t\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tchanges.push(log);\n\t\t\t\t\t\t\tforce = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfiles[filename] = ticks;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext();\n\t\t\t\t});\n\t\t\t}, function() {\n\n\t\t\t\tisLoaded = true;\n\n\t\t\t\tif (status !== 1 || !force) {\n\t\t\t\t\treload && livereload();\n\t\t\t\t\tif (counter % 150 === 0)\n\t\t\t\t\t\tspeed = isRELOAD ? 3000 : 6000;\n\t\t\t\t\tsetTimeout(refresh_directory, speed);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\trestart();\n\t\t\t\tcounter = 0;\n\t\t\t\tspeed = SPEED;\n\t\t\t\tsetTimeout(refresh_directory, speed);\n\n\t\t\t\tvar length = changes.length;\n\t\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\t\tconsole.log(changes[i]);\n\n\t\t\t\tchanges = [];\n\t\t\t\tforce = false;\n\t\t\t}, 3);\n\t\t}\n\n\t\tfunction refresh_directory() {\n\t\t\tcounter++;\n\t\t\tU.ls(directories, onComplete, onFilter);\n\t\t}\n\n\t\tfunction restart() {\n\n\t\t\tif (watchercallback) {\n\t\t\t\tif (first)\n\t\t\t\t\tfirst = false;\n\t\t\t\telse\n\t\t\t\t\twatchercallback(changes);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (app !== null) {\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tisSkip = true;\n\t\t\t\t\tprocess.kill(app.pid);\n\t\t\t\t\tif (options.inspector) {\n\t\t\t\t\t\tsetTimeout(restart, 1000);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {}\n\t\t\t\tapp = null;\n\t\t\t}\n\n\t\t\tvar arr = ARGV.slice(2);\n\n\t\t\tvar port = arr.pop();\n\n\t\t\tif (process.execArgv.indexOf('--debug') !== -1 || options.debugger) {\n\t\t\t\tvar key = '--debug=' + (options.debugger || 40894);\n\t\t\t\tprocess.execArgv.indexOf(key) === -1 && process.execArgv.push(key);\n\t\t\t}\n\n\t\t\tif (process.execArgv.indexOf('--inspect') !== -1 || options.inspector) {\n\t\t\t\tvar key = '--inspect=' + (options.inspector || 9229);\n\t\t\t\tprocess.execArgv.indexOf(key) === -1 && process.execArgv.push(key);\n\t\t\t}\n\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\tarr.push('restart');\n\n\t\t\tarr.push('debugging');\n\t\t\tport && arr.push(port);\n\n\t\t\tapp = fork(Path.join(directory, FILENAME), arr);\n\n\t\t\tapp.on('message', function(msg) {\n\t\t\t\tswitch (msg) {\n\t\t\t\t\tcase 'total:eaddrinuse':\n\t\t\t\t\t\tprocess.exit(1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'total:restart':\n\t\t\t\t\t\tconsole.log(makestamp().replace('#', 'RES'));\n\t\t\t\t\t\trestart();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'total:ready':\n\t\t\t\t\t\tif (status === 0) {\n\t\t\t\t\t\t\tapp.send('total:debug');\n\t\t\t\t\t\t\tstatus = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlivereload();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tapp.on('exit', function() {\n\n\t\t\t\t// checks unexpected exit\n\t\t\t\tif (isSkip === false) {\n\t\t\t\t\tapp = null;\n\t\t\t\t\tprocess.exit(1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tisSkip = false;\n\t\t\t\tif (status === 255)\n\t\t\t\t\tapp = null;\n\t\t\t});\n\t\t}\n\n\t\tprocess.on('SIGTERM', end);\n\t\tprocess.on('SIGINT', end);\n\t\tprocess.on('exit', end);\n\n\t\tfunction end() {\n\n\t\t\tif (process.isending)\n\t\t\t\treturn;\n\n\t\t\tprocess.isending = true;\n\t\t\tFs.unlink(pid, noop);\n\n\t\t\tif (app === null) {\n\t\t\t\tprocess.exit(0);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisSkip = true;\n\t\t\tprocess.kill(app.pid);\n\t\t\tapp = null;\n\t\t\tprocess.exit(0);\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\tif (process.pid > 0) {\n\n\t\t\t!watchercallback && console.log(prefix.substring(8) + 'DEBUG PID: ' + process.pid + ' (v' + VERSION + ')');\n\n\t\t\tpid = Path.join(directory, PIDNAME);\n\t\t\tFs.writeFileSync(pid, process.pid + '');\n\n\t\t\tsetInterval(function() {\n\t\t\t\tFs.stat(pid, function(err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tFs.unlink(pid, noop);\n\t\t\t\t\t\tif (app !== null) {\n\t\t\t\t\t\t\tisSkip = true;\n\t\t\t\t\t\t\tprocess.kill(app.pid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprocess.exit(0);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, 4000);\n\t\t}\n\n\t\trestart();\n\t\trefresh_directory();\n\t}\n\n\tvar filename = Path.join(directory, PIDNAME);\n\tif (Fs.existsSync(filename)) {\n\t\tFs.unlinkSync(filename);\n\t\tsetTimeout(app, 3500);\n\t} else\n\t\tapp();\n}\n\nfunction normalize(path) {\n\treturn isWindows ? path.replace(/\\\\/g, '/') : path;\n}\n\nfunction init() {\n\n\tprocess.on('uncaughtException', e => e.toString().indexOf('ESRCH') == -1 && console.log(e));\n\tprocess.title = 'total: debug';\n\n\tif (debugging)\n\t\tsetImmediate(runapp);\n\telse\n\t\tsetImmediate(runwatching);\n}\n\ninitdelay = setTimeout(init, 100);\n"
        },
        {
          "name": "error.html",
          "type": "blob",
          "size": 1.794921875,
          "content": "<!DOCTYPE html>\n<html>\n<head>\n\t<title>@{model.code}: @{model.status}</title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"format-detection\" content=\"telephone=no\" />\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\" />\n\t<meta name=\"robots\" content=\"all,follow\" />\n\t<style type=\"text/css\">\n\t\t/*auto*/\n\t\thtml,body { height: 100%; width: 100%; overflow: hidden; font-family: Arial; font-smoothing:antialiased; background-color: white; margin: 0; padding: 0; color: black; }\n\t\t.table { display: table; width: 100%; height: 100%; table-layout: fixed; }\n\t\t.body { padding: 20px; }\n\t\t.cell { display: table-cell; vertical-align: middle; text-align: center; width: 100%; height: 100%; font-size: 40px; }\n\t\t.cell b { font-size: 60px; background-color: black; color: white; position: relative; display: inline-block; padding: 5px 10px; border-radius: 2px; margin-bottom: 5px; animation: anim 0.5s forwards 2s; }\n\t\t.error { font-size: 11px; color: gray; width: 90%; max-width: 800px; margin: 20px auto; background-color: #F0F0F0; padding: 10px; border-radius: 2px; text-align: left; font-family: monospace; overflow: auto; }\n\t\t#url { font-size: 12px; color: gray; }\n\n\t\t@keyframes anim {\n\t\t\t0% { transform: rotate(0deg); }\n\t\t\t50% { transform: rotate(3deg) scale(1.3); }\n\t\t\t100% { transform: rotate(5deg) scale(1); }\n\t\t}\n\n\t\t@media(max-width: 768px) {\n\t\t\t.cell b { margin-bottom: 10px; }\n\t\t\t.cell { font-size: 25px; }\n\t\t}\n\t</style>\n</head>\n<body>\n\t<div class=\"table\">\n\t\t<div class=\"cell\">\n\t\t\t<div class=\"body\">\n\t\t\t\t<b>@{model.code}</b>\n\t\t\t\t<div class=\"status\">@{model.status}</div>\n\t\t\t\t<div id=\"url\"></div>\n\t\t\t\t@{if model.error}<div class=\"error\">@{model.error.replace(/\\n/g, '<br>')}</div>@{fi}\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<script>\n\t\tdocument.getElementById('url').innerHTML = location.href;\n\t</script>\n\n</body>\n</html>"
        },
        {
          "name": "flow.js",
          "type": "blob",
          "size": 11.328125,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkFlowStream\n * @version 3.4.0\n */\n\nif (!global.framework_utils)\n\tglobal.framework_utils = require('./utils');\n\nconst D = '__';\n\nfunction Message() {}\n\nMessage.prototype = {\n\n\tget user() {\n\t\treturn this.controller ? this.controller.user : null;\n\t},\n\n\tget session() {\n\t\treturn this.controller ? this.controller.session : null;\n\t},\n\n\tget sessionid() {\n\t\treturn this.controller && this.controller ? this.controller.req.sessionid : null;\n\t},\n\n\tget language() {\n\t\treturn (this.controller ? this.controller.language : '') || '';\n\t},\n\n\tget ip() {\n\t\treturn this.controller ? this.controller.ip : null;\n\t},\n\n\tget id() {\n\t\treturn this.controller ? this.controller.id : null;\n\t},\n\n\tget req() {\n\t\treturn this.controller ? this.controller.req : null;\n\t},\n\n\tget res() {\n\t\treturn this.controller ? this.controller.res : null;\n\t},\n\n\tget params() {\n\t\treturn this.controller ? this.controller.params : null;\n\t},\n\n\tget files() {\n\t\treturn this.controller ? this.controller.files : null;\n\t},\n\n\tget body() {\n\t\treturn this.controller ? this.controller.body : null;\n\t},\n\n\tget query() {\n\t\treturn this.controller ? this.controller.query : null;\n\t},\n\n\tget headers() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.headers : null;\n\t},\n\n\tget ua() {\n\t\treturn this.controller && this.controller.req ? this.controller.req.ua : null;\n\t}\n};\n\nvar MP = Message.prototype;\n\nMP.emit = function(name, a, b, c, d, e, f, g) {\n\n\tvar self = this;\n\n\tif (!self.$events)\n\t\treturn self;\n\n\tvar evt = self.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(self, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tself.$events[name] = evt.length ? evt : undefined;\n\t\t}\n\t}\n\treturn self;\n};\n\nMP.on = function(name, fn) {\n\tvar self = this;\n\tif (!self.$events)\n\t\tself.$events = {};\n\tif (self.$events[name])\n\t\tself.$events[name].push(fn);\n\telse\n\t\tself.$events[name] = [fn];\n\treturn self;\n};\n\nMP.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nMP.removeListener = function(name, fn) {\n\tvar self = this;\n\tif (self.$events) {\n\t\tvar evt = self.$events[name];\n\t\tif (evt) {\n\t\t\tevt = evt.remove(n => n === fn);\n\t\t\tself.$events[name] = evt.length ? evt : undefined;\n\t\t}\n\t}\n\treturn self;\n};\n\nMP.removeAllListeners = function(name) {\n\tif (this.$events) {\n\t\tif (name === true)\n\t\t\tthis.$events = {};\n\t\telse if (name)\n\t\t\tthis.$events[name] = undefined;\n\t\telse\n\t\t\tthis.$events = {};\n\t}\n\treturn this;\n};\n\nMP.clone = function() {\n\tvar self = this;\n\tvar obj = new Message();\n\tobj.$events = self.$events;\n\tobj.duration = self.duration;\n\tobj.repo = self.repo;\n\tobj.main = self.main;\n\tobj.count = self.count;\n\tobj.data = self.data;\n\tobj.used = self.used;\n\tobj.processed = 0;\n\treturn obj;\n};\n\nMP.send = function(outputindex) {\n\n\tvar self = this;\n\tvar outputs;\n\tvar count = 0;\n\n\tif (outputindex == null) {\n\t\tif (self.schema.connections) {\n\t\t\toutputs = Object.keys(self.schema.connections);\n\t\t\tfor (var i = 0; i < outputs.length; i++)\n\t\t\t\tcount += self.send(outputs[i]);\n\t\t}\n\t\treturn count;\n\t}\n\n\tvar meta = self.main.meta;\n\tvar now = Date.now();\n\n\toutputs = self.schema.connections ? (self.schema.connections[outputindex] || EMPTYARRAY) : EMPTYARRAY;\n\n\tif (self.processed === 0) {\n\t\tself.processed = 1;\n\t\tself.schema.stats.pending--;\n\t\tself.schema.stats.output++;\n\t\tself.schema.stats.duration = now - self.duration2;\n\t}\n\n\tif (!self.main.$can(false, self.toid, outputindex))\n\t\treturn count;\n\n\tfor (var i = 0; i < outputs.length; i++) {\n\t\tvar output = outputs[i];\n\n\t\tif (output.disabled || output.paused)\n\t\t\tcontinue;\n\n\t\tvar schema = meta.flow[output.id];\n\t\tif (schema && schema.component && self.main.$can(true, output.id, output.index)) {\n\t\t\tvar next = meta.components[schema.component];\n\t\t\tif (next && next.message) {\n\t\t\t\tvar inputindex = output.index;\n\t\t\t\tvar message = self.clone();\n\t\t\t\tmessage.used++;\n\t\t\t\tmessage.from = self.to;\n\t\t\t\tmessage.fromid = self.toid;\n\t\t\t\tmessage.fromindex = outputindex;\n\t\t\t\tmessage.fromcomponent = self.schema.component;\n\t\t\t\tmessage.fromschema = self.toschema;\n\t\t\t\tmessage.to = next;\n\t\t\t\tmessage.toid = output.id;\n\t\t\t\tmessage.toindex = inputindex;\n\t\t\t\tmessage.tocomponent = schema.component;\n\t\t\t\tmessage.toschema = message.schema = schema;\n\t\t\t\tmessage.cache = schema.cache;\n\t\t\t\tmessage.options = schema.options;\n\t\t\t\tmessage.duration2 = now;\n\t\t\t\tschema.stats.input++;\n\t\t\t\tschema.stats.pending++;\n\t\t\t\tself.$events.message && self.emit('message', message);\n\t\t\t\tself.main.$events.message && self.main.emit('message', message);\n\t\t\t\tsetImmediate(sendmessage, next, message);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n};\n\nMP.replace = function(data) {\n\tthis.data = data;\n\treturn this;\n};\n\nMP.destroy = function() {\n\n\tvar self = this;\n\n\tif (self.processed === 0) {\n\t\tself.processed = 1;\n\t\tself.schema.stats.pending--;\n\t\tself.schema.stats.output++;\n\t\tself.schema.stats.duration = Date.now() - self.duration2;\n\t}\n\n\tself.$events.end && self.emit('end', self);\n\tself.main.$events.end && self.main.emit('end', self);\n\n\tself.repo = null;\n\tself.main = null;\n\tself.from = null;\n\tself.to = null;\n\tself.fromschema = null;\n\tself.toschema = null;\n\tself.data = null;\n\tself.options = null;\n\tself.duration = null;\n\tself.duration2 = null;\n\tself.$events = null;\n};\n\nfunction Flow(name) {\n\tvar t = this;\n\tt.name = name;\n\tt.meta = {};\n\tt.meta.components = {};\n\tt.meta.messages = 0;\n\tt.meta.flow = {};\n\tt.meta.cache = {};\n\tt.$events = {};\n\tnew framework_utils.EventEmitter2(t);\n}\n\nvar FP = Flow.prototype;\n\nFP.register = function(name, declaration) {\n\tvar self = this;\n\n\tif (typeof(declaration) === 'string')\n\t\tdeclaration = new Function('instance', declaration);\n\n\tvar cache;\n\tvar prev = self.meta.components[name];\n\tif (prev) {\n\t\tcache = prev.cache;\n\t\tprev.connected = false;\n\t\tprev.disabled = true;\n\t\tprev.destroy = null;\n\t\tprev.disconnect && prev.disconnect();\n\t}\n\n\tvar curr = { id: name, main: self, connected: true, disabled: false, cache: cache || {} };\n\tdeclaration(curr);\n\tself.meta.components[name] = curr;\n\tself.$events.register && self.emit('register', name, curr);\n\tcurr.install && !prev && curr.install();\n\tcurr.connect && curr.connect();\n\tcurr.destroy = function() {\n\t\tself.unregister(name);\n\t};\n\treturn self;\n};\n\nFP.destroy = function() {\n\tvar self = this;\n\tself.unregister();\n\tsetTimeout(function() {\n\t\tself.emit('destroy');\n\t\tself.meta = null;\n\t\tself.$events = null;\n\t}, 500);\n\tdelete F.flows[self.name];\n};\n\nFP.unregister = function(name) {\n\n\tvar self = this;\n\n\tif (name == null) {\n\t\tvar keys = Object.keys(self.meta.components);\n\t\tfor (var i = 0; i < keys.length; i++)\n\t\t\tself.unregister(self.meta.components[keys[i]]);\n\t\treturn self;\n\t}\n\n\tvar curr = self.meta.components[name];\n\tif (curr) {\n\t\tself.$events.unregister && self.emit('unregister', name, curr);\n\t\tcurr.connected = false;\n\t\tcurr.disabled = true;\n\t\tcurr.destroy = null;\n\t\tcurr.cache = null;\n\t\tcurr.disconnect && curr.disconnect();\n\t\tcurr.uninstall && curr.uninstall();\n\t\tdelete self.meta.components[name];\n\t}\n\treturn self;\n};\n\nFP.use = function(schema, callback) {\n\tvar self = this;\n\n\tif (typeof(schema) === 'string')\n\t\tschema = schema.parseJSON(true);\n\n\t// schema.COMPONENT_ID.component = 'condition';\n\t// schema.COMPONENT_ID.options = {};\n\t// schema.COMPONENT_ID.connections = { '0': [{ id: 'COMPONENT_ID', index: '2' }] }\n\n\tvar err = new ErrorBuilder();\n\n\tif (schema) {\n\n\t\tvar keys = Object.keys(schema);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (key === 'paused')\n\t\t\t\tcontinue;\n\n\t\t\tvar instance = schema[key];\n\t\t\tif (!instance.component)\n\t\t\t\tcontinue;\n\n\t\t\tvar component = self.meta.components[instance.component];\n\t\t\tschema[key].stats = { pending: 0, input: 0, output: 0, duration: 0 };\n\t\t\tschema[key].cache = {};\n\n\t\t\tif (!component)\n\t\t\t\terr.push(key, '\"' + instance.component + '\" component not found.');\n\n\t\t\tcomponent.options && component.options.call(schema[key], schema[key].options);\n\t\t}\n\n\t\tself.meta.flow = schema;\n\t} else\n\t\terr.push('schema', 'Flow schema is invalid.');\n\n\tself.$events.schema && self.emit('schema', schema);\n\tcallback && callback(err.length ? err : null);\n\treturn self;\n};\n\nfunction sendmessage(instance, message, event) {\n\n\tif (event) {\n\t\tmessage.$events.message && message.emit('message', message);\n\t\tmessage.main.$events.message && message.main.emit('message', message);\n\t}\n\n\tinstance.message(message);\n}\n\nFP.$can = function(isinput, id, index) {\n\tvar self = this;\n\tif (!self.meta.flow.paused)\n\t\treturn true;\n\tvar key = (isinput ? 'input' : 'output') + D + id + D + index;\n\tif (!self.meta.flow.paused[key])\n\t\treturn true;\n};\n\n// path = ID__INPUTINDEX\nFP.trigger = function(path, data, controller, events) {\n\tpath = path.split(D);\n\tvar self = this;\n\tvar inputindex = path.length === 1 ? 0 : path[1];\n\tvar schema = self.meta.flow[path[0]];\n\tif (schema && schema.component) {\n\t\tvar instance = self.meta.components[schema.component];\n\t\tif (instance && instance.message && self.$can(true, path[0], path[1])) {\n\n\t\t\tvar message = new Message();\n\n\t\t\tmessage.$events = events || {};\n\t\t\tmessage.duration = message.duration2 = Date.now();\n\t\t\tmessage.controller = controller;\n\n\t\t\tmessage.used = 1;\n\t\t\tmessage.repo = {};\n\t\t\tmessage.main = self;\n\t\t\tmessage.data = data;\n\t\t\tmessage.count = self.meta.messages++;\n\n\t\t\tmessage.from = null;\n\t\t\tmessage.fromid = null;\n\t\t\tmessage.fromindex = null;\n\t\t\tmessage.fromcomponent = null;\n\t\t\tmessage.fromschema = null;\n\n\t\t\tmessage.to = instance;\n\t\t\tmessage.toid = path[0];\n\t\t\tmessage.toindex = inputindex;\n\t\t\tmessage.tocomponent = instance.id;\n\t\t\tmessage.toschema = message.schema = schema;\n\t\t\tmessage.cache = instance.cache;\n\n\t\t\tmessage.options = schema.options;\n\t\t\tmessage.processed = 0;\n\n\t\t\tschema.stats.input++;\n\t\t\tschema.stats.pending++;\n\t\t\tsetImmediate(sendmessage, instance, message, true);\n\t\t\treturn message;\n\t\t}\n\t}\n};\n\nFP.trigger2 = function(path, data, controller) {\n\tvar self = this;\n\tvar keys = Object.keys(self.meta.flow);\n\tvar events = {};\n\tvar obj;\n\n\tpath = path.split(D);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar flow = self.meta.flow[key];\n\t\tif (flow.component === path[0])\n\t\t\tobj = self.trigger(key + D + (path.length === 1 ? 0 : path[1]), data, controller, events);\n\t}\n\n\treturn obj;\n};\n\nFP.clear = function() {\n\tvar self = this;\n\tself.meta.flow = {};\n\treturn self;\n};\n\nFP.make = function(fn) {\n\tvar self = this;\n\tfn.call(self, self);\n\treturn self;\n};\n\nexports.make = function(name) {\n\treturn new Flow(name);\n};"
        },
        {
          "name": "graphdb.js",
          "type": "blob",
          "size": 64.482421875,
          "content": "// Copyright 2012-2018 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkGraphDB\n * @version 1.0.0\n */\n\nconst Fs = require('fs');\nconst Zlib = require('zlib');\n\nconst ZLIBOPTIONS = { level: Zlib.constants.Z_FULL_FLUSH, memLevel: Zlib.constants.Z_BEST_COMPRESSION, strategy: Zlib.constants.Z_DEFAULT_STRATEGY };\nconst VERSION = 1;\nconst DOCUMENTSIZE = 1000;\nconst PAGESIZE = 20;\nconst PAGELIMIT = 50;\nconst DATAOFFSET = 17;\nconst EMPTYBUFFER = U.createBufferSize(1);\nconst HEADERSIZE = 7000;\nconst DELAY = 100;\nconst REGTUNESCAPE = /%7C|%0D|%0A/g;\nconst REGTESCAPETEST = /\\||\\n|\\r/;\nconst REGTESCAPE = /\\||\\n|\\r/g;\nconst BOOLEAN = { '1': 1, 'true': 1, 'on': 1 };\nconst DatabaseBuilder = framework_nosql.DatabaseBuilder;\n\n// STATES\nconst STATE_UNCOMPRESSED = 1;\nconst STATE_COMPRESSED = 2;\nconst STATE_REMOVED = 255;\n\n// META\nconst META_PAGE_ADD = 100;\nconst META_CLASSESRELATIONS = 101;\nconst META_PAGE_ADD3 = 102;\nconst META_RELATIONPAGEINDEX = 103;\n\n// OPERATIONS\nconst NEXT_READY = 1;\nconst NEXT_INSERT = 2;\nconst NEXT_RELATION = 3;\nconst NEXT_UPDATE = 4;\nconst NEXT_FIND = 5;\nconst NEXT_REMOVE = 6;\nconst NEXT_RESIZE = 7;\nconst NEXT_CONTINUE = 100;\n\n// TYPES\nconst TYPE_CLASS = 1;\nconst TYPE_RELATION = 2;\nconst TYPE_RELATION_DOCUMENT = 3;\n\nvar IMPORTATOPERATIONS = 0;\n\nfunction GraphDB(name) {\n\n\tF.path.verify('databases');\n\n\tvar self = this;\n\tself.name = name;\n\tself.filename = F.path.databases(name + '.gdb');\n\tself.filenameBackup = self.filename.replace(/\\.gdb$/, '.gdp-backup');\n\tself.ready = false;\n\n\tself.$classes = {};\n\tself.$relations = {};\n\tself.$events = {};\n\n\tself.header = {};\n\n\tself.pending = {};\n\tself.pending.insert = [];\n\tself.pending.find = [];\n\tself.pending.update = [];\n\tself.pending.remove = [];\n\tself.pending.relation = [];\n\tself.pending.meta = [];\n\n\tself.states = {};\n\tself.states.resize = false;\n\tself.states.insert = false;\n\tself.states.read = false;\n\tself.states.remove = false;\n\tself.states.update = false;\n\n\tF.path.verify('databases');\n\t// t.open();\n\n\tself.cb_error = function(err) {\n\t\terr && console.log(err);\n\t};\n\n\tself.cb_next = function(value) {\n\t\tself.next(value);\n\t};\n\n\tF.grapdbinstance = true;\n\tself.open();\n}\n\nvar GP = GraphDB.prototype;\n\n// ==== DB:HEADER (7000b)\n// name (30b)             = from: 0\n// version (1b)           = from: 30\n// pages (4b)             = from: 31\n// pagesize (2b)          = from: 35\n// pagelimit (2b)         = from: 37\n// documents (4b)         = from: 39\n// documentsize (2b)      = from: 43\n// classindex (1b)        = from: 45\n// relationindex (1b)     = from: 46\n// relationnodeindex      = from: 47\n// classes + relations    = from: 51\n\n// ==== DB:PAGE (20b)\n// type (1b)              = from: 0\n// index (1b)             = from: 1\n// documents (2b)         = from: 2\n// freeslots (1b)         = from: 4\n// parentindex (4b)       = from: 5\n\n// ==== DB:DOCUMENT (SIZE)\n// type (1b)              = from: 0\n// index (1b)             = from: 1\n// state (1b)             = from: 2\n// pageindex (4b)         = from: 3\n// relationindex (4b)     = from: 7  (it's for relations between two documents in TYPE_RELATION page)\n// parentindex (4b)       = from: 11\n// size/count (2b)        = from: 15\n// data                   = from: 17\n\n// Creates new page\nfunction addPage(self, type, index, parentindex, callback) {\n\n\t// @type\n\t// 1: classes\n\t// 2: relations\n\t// 3: relations private\n\n\t// @index\n\t// index of value\n\n\t// Add a new page\n\tself.header.pages++;\n\n\tvar indexer = self.header.pages;\n\tvar buffer = [];\n\tvar page = U.createBufferSize(self.header.pagesize);\n\n\t// console.log('CREATING PAGE:', TYPES[type], indexer, type, index);\n\n\tpage.writeUInt8(type, 0);             // type (1:class, 2:relation, 3:private)\n\tpage.writeUInt8(index, 1);            // index\n\tpage.writeUInt16LE(0, 2);             // documents\n\tpage.writeUInt8(0, 4);                // freeslots\n\tpage.writeUInt32LE(parentindex, 5);   // parentindex\n\n\tbuffer.push(page);\n\n\tfor (var i = 0; i < self.header.pagelimit; i++) {\n\t\tvar doc = U.createBufferSize(self.header.documentsize);\n\t\tdoc.writeUInt8(type, 0);\n\t\tdoc.writeUInt8(index, 1);\n\t\tdoc.writeUInt8(STATE_REMOVED, 2);\n\t\tdoc.writeUInt32LE(self.header.pages, 3);\n\t\tdoc.writeUInt32LE(0, 7);    // continuerindex\n\t\tdoc.writeUInt32LE(0, 11);   // parentindex\n\t\tdoc.writeUInt16LE(0, 15);   // size/count\n\t\tbuffer.push(doc);\n\t}\n\n\tbuffer = Buffer.concat(buffer);\n\n\tvar offset = offsetPage(self, indexer);\n\n\tFs.write(self.fd, buffer, 0, buffer.length, offset, function(err) {\n\t\terr && self.error(err, 'createPage.write');\n\t\t!err && updMeta(self, type === TYPE_RELATION_DOCUMENT ? META_PAGE_ADD3 : META_PAGE_ADD);\n\t\tcallback && callback(err, indexer);\n\t});\n\n\treturn indexer;\n}\n\nfunction addNodeFree(self, meta, callback) {\n\n\tif (!meta.type.findfreeslots) {\n\t\taddNode(self, meta, callback);\n\t\treturn;\n\t}\n\n\tfindDocumentFree(self, meta.type.pageindex, function(err, documentindex, pageindex) {\n\n\t\tif (!documentindex) {\n\t\t\tmeta.type.findfreeslots = false;\n\t\t\taddNode(self, meta, callback);\n\t\t\treturn;\n\t\t}\n\n\t\tvar buffer = U.createBufferSize(self.header.documentsize);\n\t\tbuffer.writeUInt8(meta.typeid, 0);                       // type\n\t\tbuffer.writeUInt8(meta.type.index, 1);                   // index\n\t\tbuffer.writeUInt32LE(pageindex, 3);                      // pageindex\n\t\tbuffer.writeUInt8(meta.state || STATE_UNCOMPRESSED, 2);  // state\n\t\tbuffer.writeUInt32LE(meta.relationindex || 0, 7);        // relationindex\n\t\tbuffer.writeUInt32LE(meta.parentindex || 0, 11);         // parentindex\n\t\tbuffer.writeUInt16LE(meta.size, 15);\n\t\tmeta.data && meta.data.copy(buffer, DATAOFFSET);\n\n\t\tFs.write(self.fd, buffer, 0, buffer.length, offsetDocument(self, documentindex), function() {\n\t\t\tmeta.type.locked = false;\n\t\t\tcallback(null, documentindex, pageindex);\n\t\t});\n\t});\n}\n\nfunction addNode(self, meta, callback) {\n\n\t// meta.typeid (1 CLASS, 2 RELATION)\n\t// meta.type (link to type class/relation)\n\t// meta.state\n\t// meta.parentindex\n\t// meta.relationindex\n\t// meta.size\n\t// meta.buffer\n\n\tvar buf = U.createBufferSize(self.header.pagesize);\n\tvar offset = offsetPage(self, meta.type.pageindex);\n\n\tmeta.type.locked = true;\n\n\tFs.read(self.fd, buf, 0, buf.length, offset, function(err) {\n\n\t\tif (err)\n\t\t\tthrow err;\n\n\t\tif (buf[0] !== meta.typeid)\n\t\t\tthrow new Error('Not a class page');\n\n\t\tif (!meta.type.private && buf[1] !== meta.type.index)\n\t\t\tthrow new Error('Not same class type');\n\n\t\t// type          : buf[0]\n\t\t// index         : buf[1]\n\t\t// documents     : buf.readUInt16LE(2)\n\t\t// freeslots     : buf[4]\n\t\t// parentindex   : readUInt32LE(5)\n\n\t\tvar buffer = U.createBufferSize(self.header.documentsize);\n\t\tbuffer.writeUInt8(buf[0], 0);                      // type\n\t\tbuffer.writeUInt8(meta.type.index, 1);             // index\n\t\tbuffer.writeUInt32LE(meta.type.pageindex, 3);      // pageindex\n\t\tbuffer.writeUInt8(meta.state || STATE_UNCOMPRESSED, 2);  // state\n\t\tbuffer.writeUInt32LE(meta.relationindex || 0, 7);  // relationindex\n\t\tbuffer.writeUInt32LE(meta.parentindex || 0, 11);   // parentindex\n\t\tbuffer.writeUInt16LE(meta.size, 15);\n\t\tmeta.data && meta.data.copy(buffer, DATAOFFSET);\n\n\t\tvar documents = buf.readUInt16LE(2);\n\t\tvar documentsbuf = U.createBufferSize(2);\n\n\t\tdocuments++;\n\t\tdocumentsbuf.writeUInt16LE(documents);\n\n\t\tFs.write(self.fd, documentsbuf, 0, documentsbuf.length, offset + 2, function(err) {\n\n\t\t\terr && console.log('addNode.write.meta', err);\n\t\t\tFs.write(self.fd, buffer, 0, buffer.length, offset + self.header.pagesize + ((documents - 1) * self.header.documentsize), function(err) {\n\n\t\t\t\terr && console.log('addNode.write.data', err);\n\n\t\t\t\t// type (1b)              = from: 0\n\t\t\t\t// index (1b)             = from: 1\n\t\t\t\t// state (1b)             = from: 2\n\t\t\t\t// pageindex (4b)         = from: 3\n\t\t\t\t// continuerindex (4b)    = from: 7\n\t\t\t\t// parentindex (4b)       = from: 11\n\t\t\t\t// size/count (2b)        = from: 15\n\t\t\t\t// data                   = from: 17\n\n\t\t\t\t// We must create a new page\n\t\t\t\tif (documents + 1 > self.header.pagelimit) {\n\t\t\t\t\taddPage(self, meta.typeid, meta.type.index, meta.type.pageindex, function(err, index) {\n\n\t\t\t\t\t\tvar documentindex = getDocumentIndex(self, meta.type.pageindex, documents);\n\t\t\t\t\t\tmeta.type.documentindex = documentindex;\n\t\t\t\t\t\tmeta.type.pageindex = index;\n\t\t\t\t\t\tmeta.type.locked = false;\n\n\t\t\t\t\t\t// Problem with classes\n\t\t\t\t\t\t// meta.type.index = 0;\n\n\t\t\t\t\t\tif (meta.type.private)\n\t\t\t\t\t\t\tself.header.relationpageindex = index;\n\n\t\t\t\t\t\tupdMeta(self, meta.type.private ? META_RELATIONPAGEINDEX : META_CLASSESRELATIONS);\n\t\t\t\t\t\tcallback(null, documentindex, index);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar documentindex = getDocumentIndex(self, meta.type.pageindex, documents);\n\t\t\t\t\tmeta.type.locked = false;\n\t\t\t\t\tmeta.type.documentindex = documentindex;\n\t\t\t\t\tcallback(null, documentindex, meta.type.pageindex);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction addDocument(self, cls, value, callback) {\n\n\t// meta.typeid (1 CLASS, 2 RELATION)\n\t// meta.type (link to type class/relation)\n\t// meta.state\n\t// meta.parentindex\n\t// meta.relationindex\n\t// meta.size\n\t// meta.data\n\n\tvar meta = {};\n\tmeta.type = cls;\n\tmeta.typeid = TYPE_CLASS;\n\tmeta.state = 1;\n\tmeta.parentindex = 0;\n\tmeta.relationindex = 0;\n\tmeta.data = U.createBuffer(stringifyData(cls.schema, value));\n\tmeta.size = meta.data.length;\n\n\tvar limit = self.header.documentsize - DATAOFFSET;\n\n\tif (meta.data.length > limit) {\n\t\tZlib.deflate(meta.data, ZLIBOPTIONS, function(err, buf) {\n\t\t\tif (err || buf.length > limit)\n\t\t\t\tcallback(new Error('GraphDB: Data too long'), 0);\n\t\t\telse {\n\t\t\t\tmeta.state = STATE_COMPRESSED;\n\t\t\t\tmeta.data = buf;\n\t\t\t\tmeta.size = buf.length;\n\t\t\t\taddNodeFree(self, meta, callback);\n\t\t\t}\n\t\t});\n\t} else\n\t\taddNodeFree(self, meta, callback);\n}\n\nfunction addRelation(self, relation, indexA, indexB, callback) {\n\n\t// Workflow:\n\t// Has \"A\" relation nodes?\n\t// Has \"B\" relation nodes?\n\t// Create \"A\" relation with \"B\"\n\t// Create \"B\" relation with \"A\"\n\t// Register relation to global relations\n\n\tvar tasks = [];\n\tvar relA = null;\n\tvar relB = null;\n\n\tvar tmprelation = { index: relation.index, pageindex: 0, documentindex: 0, locked: false, private: true };\n\n\ttasks.push(function(next) {\n\t\tself.read(indexA, function(err, doc, relid) {\n\t\t\tif (doc) {\n\t\t\t\trelA = relid;\n\t\t\t\tnext();\n\t\t\t} else {\n\t\t\t\ttasks = null;\n\t\t\t\tnext = null;\n\t\t\t\tcallback(new Error('GraphDB: Node (A) \"{0}\" not exists.'.format(indexA)));\n\t\t\t}\n\t\t});\n\t});\n\n\ttasks.push(function(next) {\n\t\tself.read(indexB, function(err, doc, relid) {\n\t\t\tif (doc) {\n\t\t\t\trelB = relid;\n\t\t\t\tnext();\n\t\t\t} else {\n\t\t\t\ttasks = null;\n\t\t\t\tnext = null;\n\t\t\t\tcallback(new Error('GraphDB: Node (B) \"{0}\" not exists.'.format(indexB)));\n\t\t\t}\n\t\t});\n\t});\n\n\ttasks.push(function(next) {\n\n\t\tif (relA == 0) {\n\t\t\tnext();\n\t\t\treturn;\n\t\t}\n\n\t\tcheckRelation(self, relation, relA, indexB, function(err, is) {\n\t\t\tif (is) {\n\t\t\t\ttasks = null;\n\t\t\t\tnext = null;\n\t\t\t\tcallback(new Error('GraphDB: Same relation already exists between nodes (A) \"{0}\" and (B) \"{1}\".'.format(indexA, indexB)));\n\t\t\t} else\n\t\t\t\tnext();\n\t\t});\n\t});\n\n\t// Obtaining indexA a relation document\n\ttasks.push(function(next) {\n\n\t\tif (F.isKilled)\n\t\t\treturn;\n\n\t\tIMPORTATOPERATIONS++;\n\n\t\tif (relA)\n\t\t\tnext();\n\t\telse {\n\t\t\taddRelationDocument(self, relation, indexA, function(err, index) {\n\t\t\t\trelA = index;\n\t\t\t\tnext();\n\t\t\t}, true);\n\t\t}\n\t});\n\n\t// Obtaining indexB a relation document\n\ttasks.push(function(next) {\n\n\t\tif (F.isKilled)\n\t\t\treturn;\n\n\t\tif (relB)\n\t\t\tnext();\n\t\telse {\n\t\t\taddRelationDocument(self, relation, indexB, function(err, index) {\n\t\t\t\trelB = index;\n\t\t\t\tnext();\n\t\t\t}, true);\n\t\t}\n\t});\n\n\t// Push \"indexB\" relation to \"indexA\"\n\ttasks.push(function(next) {\n\t\ttmprelation.documentindex = relA;\n\t\ttmprelation.pageindex = self.header.relationpageindex;\n\t\tpushRelationDocument(self, relA, tmprelation, indexB, true, function(err, index) {\n\t\t\t// Updated relation, document was full\n\t\t\tif (relA !== index) {\n\t\t\t\trelA = index;\n\t\t\t\tupdDocumentRelation(self, indexA, relA, next);\n\t\t\t} else\n\t\t\t\tnext();\n\t\t}, true);\n\t});\n\n\ttasks.push(function(next) {\n\t\ttmprelation.documentindex = relB;\n\t\ttmprelation.pageindex = self.header.relationpageindex;\n\t\tpushRelationDocument(self, relB, tmprelation, indexA, false, function(err, index) {\n\t\t\t// Updated relation, document was full\n\t\t\tif (relB !== index) {\n\t\t\t\trelB = index;\n\t\t\t\tupdDocumentRelation(self, indexB, relB, next);\n\t\t\t} else\n\t\t\t\tnext();\n\t\t}, true);\n\t});\n\n\ttasks.push(function(next) {\n\t\t// console.log('PUSH COMMON', relation.documentindex, indexA);\n\t\tpushRelationDocument(self, relation.documentindex, relation, indexA, true, next);\n\t});\n\n\ttasks.async(function() {\n\t\tIMPORTATOPERATIONS--;\n\t\t// console.log('REL ====', relA, relB);\n\t\tcallback(null, true);\n\t});\n}\n\nfunction remRelation(self, relation, indexA, indexB, callback) {\n\n\tvar tasks = [];\n\tvar relA = null;\n\tvar relB = null;\n\n\ttasks.push(function(next) {\n\t\tself.read(indexA, function(err, doc, relid) {\n\t\t\tif (doc) {\n\t\t\t\trelA = relid;\n\t\t\t\tnext();\n\t\t\t} else {\n\t\t\t\ttasks = null;\n\t\t\t\tnext = null;\n\t\t\t\tcallback(new Error('GraphDB: Node (A) \"{0}\" not exists.'.format(indexA)));\n\t\t\t}\n\t\t});\n\t});\n\n\ttasks.push(function(next) {\n\t\tself.read(indexB, function(err, doc, relid) {\n\t\t\tif (doc) {\n\t\t\t\trelB = relid;\n\t\t\t\tnext();\n\t\t\t} else {\n\t\t\t\ttasks = null;\n\t\t\t\tnext = null;\n\t\t\t\tcallback(new Error('GraphDB: Node (B) \"{0}\" not exists.'.format(indexB)));\n\t\t\t}\n\t\t});\n\t});\n\n\ttasks.async(function() {\n\n\t\tif (F.isKilled)\n\t\t\treturn;\n\n\t\tIMPORTATOPERATIONS++;\n\t\tremRelationLink(self, relA, indexB, function(err, countA) {\n\t\t\tremRelationLink(self, relB, indexA, function(err, countB) {\n\t\t\t\tremRelationLink(self, relation.documentindex, indexA, function(err, countC) {\n\t\t\t\t\tIMPORTATOPERATIONS--;\n\t\t\t\t\tcallback(null, (countA + countB + countC) > 1);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction remRelationLink(self, index, documentindex, callback, nochild, counter) {\n\n\tvar buf = U.createBufferSize(self.header.documentsize);\n\tvar offset = offsetDocument(self, index);\n\n\t!counter && (counter = 0);\n\n\tFs.read(self.fd, buf, 0, buf.length, offset, function() {\n\n\t\t// type (1b)              = from: 0\n\t\t// index (1b)             = from: 1\n\t\t// state (1b)             = from: 2\n\t\t// pageindex (4b)         = from: 3\n\t\t// relationindex (4b)     = from: 7  (it's for relations between two documents in TYPE_RELATION page)\n\t\t// parentindex (4b)       = from: 11\n\t\t// size/count (2b)        = from: 15\n\t\t// data                   = from: 17\n\n\t\tif ((buf[0] !== TYPE_RELATION && buf[0] !== TYPE_RELATION_DOCUMENT) || (buf[2] === STATE_REMOVED)) {\n\t\t\tcallback(null, counter);\n\t\t\treturn;\n\t\t}\n\n\t\tvar relid = buf.readUInt32LE(7);\n\t\tvar count = buf.readUInt16LE(15);\n\t\tvar arr = [];\n\t\tvar is = false;\n\n\t\tfor (var i = 0; i < count; i++) {\n\t\t\tvar off = DATAOFFSET + (i * 6);\n\t\t\tvar obj = {};\n\t\t\tobj.INDEX = buf[off];\n\t\t\tobj.INIT = buf[off + 1];\n\t\t\tobj.ID = buf.readUInt32LE(off + 2);\n\t\t\tif (obj.ID === documentindex && obj.INIT === 1)\n\t\t\t\tis = true;\n\t\t\telse\n\t\t\t\tarr.push(obj);\n\t\t}\n\n\t\tif (is) {\n\t\t\tcount = arr.length;\n\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\tvar off = DATAOFFSET + (i * 6);\n\t\t\t\tvar obj = arr[i];\n\t\t\t\tbuf.writeUInt8(obj.INDEX, off);\n\t\t\t\tbuf.writeUInt8(obj.INIT, off + 1);\n\t\t\t\tbuf.writeUInt32LE(obj.ID, off + 2);\n\t\t\t}\n\t\t\tbuf.writeUInt16LE(count, 15);\n\t\t\tbuf.fill(EMPTYBUFFER, DATAOFFSET + ((count + 1) * 6));\n\t\t\tFs.write(self.fd, buf, 0, buf.length, offset, function() {\n\t\t\t\tcounter++;\n\t\t\t\tif (relid && !nochild)\n\t\t\t\t\tsetImmediate(remRelationLink, self, relid, documentindex, callback, null, counter);\n\t\t\t\telse\n\t\t\t\t\tcallback(null, counter);\n\t\t\t});\n\t\t} else if (relid && !nochild)\n\t\t\tsetImmediate(remRelationLink, self, relid, documentindex, callback, null, counter);\n\t\telse\n\t\t\tcallback(null, counter);\n\t});\n}\n\n// Traverses all RELATIONS documents and remove specific \"documentindex\"\nfunction remRelationAll(self, index, documentindex, callback, counter) {\n\n\tvar buf = U.createBufferSize(self.header.pagelimit * self.header.documentsize);\n\tvar offset = offsetDocument(self, index);\n\n\t!counter && (counter = 0);\n\n\tFs.read(self.fd, buf, 0, buf.length, offset, function(err, size) {\n\n\t\tif (err || !size) {\n\t\t\tcallback(null, counter);\n\t\t\treturn;\n\t\t}\n\n\t\t// type (1b)              = from: 0\n\t\t// index (1b)             = from: 1\n\t\t// state (1b)             = from: 2\n\t\t// pageindex (4b)         = from: 3\n\t\t// relationindex (4b)     = from: 7  (it's for relations between two documents in TYPE_RELATION page)\n\t\t// parentindex (4b)       = from: 11\n\t\t// size/count (2b)        = from: 15\n\t\t// data                   = from: 17\n\n\t\tvar removed = [];\n\n\t\twhile (true) {\n\n\t\t\tif (!buf.length)\n\t\t\t\tbreak;\n\n\t\t\tindex++;\n\n\t\t\tvar data = buf.slice(0, self.header.documentsize);\n\n\t\t\tif ((data[0] !== TYPE_RELATION && data[0] !== TYPE_RELATION_DOCUMENT) || (data[2] === STATE_REMOVED)) {\n\t\t\t\tbuf = buf.slice(self.header.documentsize);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar count = data.readUInt16LE(15);\n\t\t\tvar arr = [];\n\t\t\tvar is = false;\n\n\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\tvar off = DATAOFFSET + (i * 6);\n\t\t\t\tvar obj = {};\n\t\t\t\tobj.INDEX = data[off];\n\t\t\t\tobj.INIT = data[off + 1];\n\t\t\t\tobj.ID = data.readUInt32LE(off + 2);\n\t\t\t\tif (obj.ID === documentindex)\n\t\t\t\t\tis = true;\n\t\t\t\telse\n\t\t\t\t\tarr.push(obj);\n\t\t\t}\n\n\t\t\tif (is) {\n\n\t\t\t\tvar newcount = arr.length;\n\n\t\t\t\tfor (var i = 0; i < newcount; i++) {\n\t\t\t\t\tvar off = DATAOFFSET + (i * 6);\n\t\t\t\t\tvar obj = arr[i];\n\t\t\t\t\tdata.writeUInt8(obj.INDEX, off);\n\t\t\t\t\tdata.writeUInt8(obj.INIT, off + 1);\n\t\t\t\t\tdata.writeUInt32LE(obj.ID, off + 2);\n\t\t\t\t}\n\n\t\t\t\tdata.writeUInt16LE(newcount, 15);\n\t\t\t\tdata.fill(EMPTYBUFFER, DATAOFFSET + ((newcount + 1) * 6));\n\n\t\t\t\tremoved.push({ index: index - 1, buf: data });\n\t\t\t}\n\n\t\t\tbuf = buf.slice(self.header.documentsize);\n\t\t}\n\n\t\tif (!removed.length) {\n\t\t\tsetImmediate(remRelationAll, self, index, documentindex, callback, counter);\n\t\t\treturn;\n\t\t}\n\n\t\tcounter += removed.length;\n\t\tremoved.wait(function(item, next) {\n\t\t\tFs.write(self.fd, item.buf, 0, item.buf.length, offsetDocument(self, item.index), next);\n\t\t}, function() {\n\t\t\tsetImmediate(remRelationAll, self, index, documentindex, callback, counter);\n\t\t});\n\n\t});\n}\n\nfunction addRelationDocument(self, relation, index, callback, between) {\n\n\t// meta.typeid (1 CLASS, 2 RELATION, 3 PRIVATE RELATION)\n\t// meta.type (link to type class/relation)\n\t// meta.state\n\t// meta.parentindex\n\t// meta.relationindex\n\t// meta.size\n\t// meta.data\n\n\tvar meta = {};\n\tmeta.typeid = between ? TYPE_RELATION_DOCUMENT : TYPE_RELATION;\n\tmeta.type = between ? { index: 0, pageindex: self.header.relationpageindex, documentindex: index, locked: false, private: true } : relation;\n\tmeta.state = 1;\n\tmeta.parentindex = 0;\n\tmeta.relationindex = 0;\n\tmeta.size = 0;\n\n\t// Creates a new node\n\taddNode(self, meta, function(err, relationindex) {\n\n\t\t// Updates exiting document by updating relation index\n\t\tupdDocumentRelation(self, index, relationindex, function(err) {\n\t\t\t// Returns a new relation index\n\t\t\tcallback(err, relationindex);\n\t\t});\n\t});\n}\n\nfunction findDocumentFree(self, pageindex, callback, ready) {\n\n\tvar offset = offsetPage(self, pageindex);\n\tvar buf = U.createBufferSize(self.header.pagesize);\n\n\tFs.read(self.fd, buf, 0, buf.length, offset, function() {\n\n\t\t// ==== DB:PAGE (20b)\n\t\t// type (1b)              = from: 0\n\t\t// index (1b)             = from: 1\n\t\t// documents (2b)         = from: 2\n\t\t// freeslots (1b)         = from: 4\n\t\t// parentindex (4b)       = from: 5\n\n\t\tvar relid = buf.readUInt32LE(5);\n\t\tif (!relid) {\n\t\t\tif (!ready) {\n\t\t\t\tcallback(null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// First page is the last page saved in meta therefore is needed to perform recursive with \"ready\"\n\t\tif (!ready) {\n\t\t\tfindDocumentFree(self, relid, callback, true);\n\t\t\treturn;\n\t\t}\n\n\t\tvar documents = buf.readUInt16LE(2);\n\t\tif (documents >= self.header.pagelimit) {\n\t\t\t// Finds in parent if exists\n\t\t\tif (relid)\n\t\t\t\tfindDocumentFree(self, relid, callback, true);\n\t\t\telse\n\t\t\t\tcallback(null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t// Finds a free document slot\n\t\tvar index = getDocumentIndex(self, pageindex) - 1;\n\t\tvar buffer = U.createBufferSize(self.header.pagelimit * self.header.documentsize);\n\n\t\tFs.read(self.fd, buffer, 0, buffer.length, offset + self.header.pagesize, function() {\n\t\t\twhile (true) {\n\t\t\t\tindex++;\n\t\t\t\tvar data = buffer.slice(0, self.header.documentsize);\n\t\t\t\tif (!data.length)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (data[2] === STATE_REMOVED) {\n\n\t\t\t\t\tif (F.isKilled)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tupdPageMeta(self, pageindex, function(err, buf) {\n\t\t\t\t\t\tbuf.writeUInt16LE(documents + 1, 2);\n\t\t\t\t\t\tsetImmediate(callback, null, index, pageindex);\n\t\t\t\t\t});\n\t\t\t\t\tbuffer = buffer.slice(self.header.documentsize);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (relid)\n\t\t\t\tfindDocumentFree(self, relid, callback, true);\n\t\t\telse\n\t\t\t\tcallback(null, 0);\n\n\t\t});\n\t});\n}\n\n// Finds a free space for new relation in \"pushRelationDocument\"\nfunction findRelationDocument(self, relid, callback) {\n\n\tif (!relid) {\n\t\tcallback(null, 0);\n\t\treturn;\n\t}\n\n\tvar offset = offsetDocument(self, relid);\n\tvar buf = U.createBufferSize(self.header.documentsize);\n\n\tFs.read(self.fd, buf, 0, buf.length, offset, function(err, size) {\n\n\t\tif (err || !size) {\n\t\t\tcallback(err, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tvar count = buf.readUInt16LE(15);\n\t\tif (count + 1 > self.header.relationlimit) {\n\t\t\t// Checks if the relation index has next relation\n\n\t\t\tif (relid === buf.readUInt32LE(7))\n\t\t\t\treturn;\n\n\t\t\trelid = buf.readUInt32LE(7);\n\t\t\tif (relid)\n\t\t\t\tsetImmediate(findRelationDocument, self, relid, callback);\n\t\t\telse\n\t\t\t\tcallback(null, 0);\n\t\t} else {\n\t\t\t// Free space for this relation\n\t\t\tcallback(null, relid);\n\t\t}\n\t});\n}\n\n// Pushs \"documentindex\" to \"index\" document (document with all relations)\nfunction pushRelationDocument(self, index, relation, documentindex, initializator, callback, between, recovered) {\n\n\tvar offset = offsetDocument(self, index);\n\tvar buf = U.createBufferSize(self.header.documentsize);\n\n\tFs.read(self.fd, buf, 0, buf.length, offset, function() {\n\n\t\t// type (1b)              = from: 0\n\t\t// index (1b)             = from: 1\n\t\t// state (1b)             = from: 2\n\t\t// pageindex (4b)         = from: 3\n\t\t// relationindex (4b)     = from: 7  (it's for relations between two documents in TYPE_RELATION page)\n\t\t// parentindex (4b)       = from: 11\n\t\t// size/count (2b)        = from: 15\n\t\t// data                   = from: 17\n\n\t\tvar count = buf.readUInt16LE(15);\n\t\tif (count + 1 > self.header.relationlimit) {\n\t\t\tfindRelationDocument(self, buf.readUInt32LE(7), function(err, newindex) {\n\n\t\t\t\t// Is some relation document exist?\n\t\t\t\tif (newindex && !recovered) {\n\t\t\t\t\tpushRelationDocument(self, newindex, relation, documentindex, initializator, callback, between, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// meta.typeid (1 CLASS, 2 RELATION)\n\t\t\t\t// meta.type (link to type class/relation)\n\t\t\t\t// meta.state\n\t\t\t\t// meta.parentindex\n\t\t\t\t// meta.relationindex\n\t\t\t\t// meta.size\n\t\t\t\t// meta.buffer\n\n\t\t\t\tvar meta = {};\n\t\t\t\tmeta.typeid = relation.private ? TYPE_RELATION_DOCUMENT : TYPE_RELATION;\n\t\t\t\tmeta.type = relation;\n\t\t\t\tmeta.state = STATE_UNCOMPRESSED;\n\t\t\t\tmeta.parentindex = 0;\n\t\t\t\tmeta.relationindex = index;\n\t\t\t\tmeta.size = 0;\n\n\t\t\t\taddNode(self, meta, function(err, docindex, pageindex) {\n\t\t\t\t\trelation.pageindex = pageindex;\n\t\t\t\t\trelation.documentindex = docindex;\n\t\t\t\t\tupdDocumentRelation(self, relation.documentindex, index, function() {\n\t\t\t\t\t\tupdDocumentParent(self, index, relation.documentindex, function() {\n\t\t\t\t\t\t\tpushRelationDocument(self, relation.documentindex, relation, documentindex, initializator, callback, between);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t} else {\n\n\t\t\tvar buffer = U.createBufferSize(6);\n\t\t\tbuffer.writeUInt8(relation.index, 0);\n\t\t\tbuffer.writeUInt8(initializator ? 1 : 0, 1);\n\t\t\tbuffer.writeUInt32LE(documentindex, 2);\n\t\t\tbuffer.copy(buf, DATAOFFSET + (count * 6));\n\t\t\tbuf.writeUInt16LE(count + 1, 15);\n\n\t\t\tif (buf[2] === STATE_REMOVED) {\n\t\t\t\t// We must update counts of documents in the page meta\n\t\t\t\tvar pageindex = Math.ceil(index / self.header.pagelimit);\n\t\t\t\tupdPageMeta(self, pageindex, function(err, buf) {\n\n\t\t\t\t\t// type (1b)              = from: 0\n\t\t\t\t\t// index (1b)             = from: 1\n\t\t\t\t\t// documents (2b)         = from: 2\n\t\t\t\t\t// freeslots (1b)         = from: 4\n\t\t\t\t\t// parentindex (4b)       = from: 5\n\n\t\t\t\t\tbuf.writeUInt16LE(buf.readUInt16LE(2) + 1, 2);\n\t\t\t\t\tsetImmediate(function() {\n\t\t\t\t\t\tFs.write(self.fd, buf, 0, buf.length, offset, function(err) {\n\t\t\t\t\t\t\terr && self.error(err, 'pushRelationDocument.read.write');\n\t\t\t\t\t\t\tcallback(null, index);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tbuf.writeUInt8(STATE_UNCOMPRESSED, 2);\n\n\t\t\t} else {\n\t\t\t\t// DONE\n\t\t\t\tFs.write(self.fd, buf, 0, buf.length, offset, function(err) {\n\t\t\t\t\terr && self.error(err, 'pushRelationDocument.read.write');\n\t\t\t\t\tcallback(null, index);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t});\n}\n\nfunction updDocumentRelation(self, index, relationindex, callback) {\n\n\tif (index === relationindex)\n\t\tthrow new Error('FET');\n\n\tvar offset = offsetDocument(self, index);\n\tvar buf = U.createBufferSize(4);\n\tbuf.writeUInt32LE(relationindex);\n\tFs.write(self.fd, buf, 0, buf.length, offset + 7, callback);\n}\n\nfunction updDocumentParent(self, index, parentindex, callback) {\n\tvar offset = offsetDocument(self, index);\n\tvar buf = U.createBufferSize(4);\n\tbuf.writeUInt32LE(parentindex);\n\tFs.write(self.fd, buf, 0, buf.length, offset + 11, callback);\n}\n\nfunction updPageMeta(self, index, fn) {\n\tvar offset = offsetPage(self, index);\n\tvar buf = U.createBufferSize(self.header.pagesize);\n\tFs.read(self.fd, buf, 0, buf.length, offset, function() {\n\t\tfn(null, buf);\n\t\tFs.write(self.fd, buf, 0, buf.length, offset, self.cb_error);\n\t});\n}\n\nfunction remDocument(self) {\n\tif (!self.ready || self.states.remove || !self.pending.remove.length || F.isKilled)\n\t\treturn;\n\tself.states.remove = true;\n\tvar doc = self.pending.remove.shift();\n\tIMPORTATOPERATIONS++;\n\tremRelationAll(self, doc.id, doc.id, function() {\n\t\tremDocumentAll(self, doc.id, function(err, count) {\n\t\t\tIMPORTATOPERATIONS--;\n\t\t\tself.states.remove = false;\n\t\t\tdoc.callback && doc.callback(err, count);\n\t\t\tsetImmediate(self.cb_next, NEXT_REMOVE);\n\t\t});\n\t});\n}\n\nfunction remDocumentAll(self, index, callback, count) {\n\n\tvar offset = offsetDocument(self, index);\n\tvar buf = U.createBufferSize(17);\n\n\t// type (1b)              = from: 0\n\t// index (1b)             = from: 1\n\t// state (1b)             = from: 2\n\t// pageindex (4b)         = from: 3\n\t// relationindex (4b)     = from: 7  (it's for relations between two documents in TYPE_RELATION page)\n\t// parentindex (4b)       = from: 11\n\t// size/count (2b)        = from: 15\n\t// data                   = from: 17\n\n\tif (!count)\n\t\tcount = 0;\n\n\tFs.read(self.fd, buf, 0, buf.length, offset, function() {\n\n\t\tvar relid = buf.readUInt32LE(7);\n\n\t\tif (buf[2] === STATE_REMOVED) {\n\t\t\tif (relid)\n\t\t\t\tremDocumentAll(self, relid, callback, count);\n\t\t\telse\n\t\t\t\tcallback(null, count);\n\t\t\treturn;\n\t\t}\n\n\t\tbuf.writeUInt8(STATE_REMOVED, 2);\n\t\tbuf.writeUInt16LE(0, 15);\n\n\t\tif (buf[0] === TYPE_CLASS)\n\t\t\tself.$classes[buf[1]].findfreeslots = true;\n\n\t\tvar pageindex = buf.readUInt32LE(3);\n\n\t\tFs.write(self.fd, buf, 0, buf.length, offset, function() {\n\n\t\t\t// Updates \"documents\" in the current page\n\t\t\tupdPageMeta(self, pageindex, function(err, buf) {\n\n\t\t\t\t// type (1b)              = from: 0\n\t\t\t\t// index (1b)             = from: 1\n\t\t\t\t// documents (2b)         = from: 2\n\t\t\t\t// freeslots (1b)         = from: 4\n\t\t\t\t// parentindex (4b)       = from: 5\n\n\t\t\t\tvar documents = buf.readUInt16LE(2);\n\t\t\t\tbuf.writeUInt16LE(documents > 0 ? documents - 1 : documents, 2);\n\t\t\t\tcount++;\n\n\t\t\t\tsetImmediate(function() {\n\t\t\t\t\tif (relid)\n\t\t\t\t\t\tremDocumentAll(self, relid, callback, count);\n\t\t\t\t\telse\n\t\t\t\t\t\tcallback(null, count);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction offsetPage(self, index) {\n\treturn HEADERSIZE + ((index - 1) * (self.header.pagesize + (self.header.pagelimit * self.header.documentsize)));\n}\n\nfunction offsetDocument(self, index) {\n\tvar page = Math.ceil(index / self.header.pagelimit);\n\tvar offset = page * self.header.pagesize;\n\treturn HEADERSIZE + offset + ((index - 1) * self.header.documentsize);\n}\n\nfunction getIndexPage(self, offset) {\n\treturn ((offset - HEADERSIZE) / (self.header.pagesize + (self.header.pagelimit * self.header.documentsize)));\n}\n\nfunction getDocumentIndex(self, pageindex, count) {\n\treturn ((pageindex - 1) * self.header.pagelimit) + (count || 1);\n}\n\nfunction checkRelation(self, relation, indexA, indexB, callback) {\n\n\tself.read(indexA, function(err, docs, relid) {\n\n\t\tif (docs) {\n\t\t\tfor (var i = 0; i < docs.length; i++) {\n\t\t\t\tvar doc = docs[i];\n\t\t\t\tif (doc.ID === indexB && (relation.both || doc.INIT)) {\n\t\t\t\t\tcallback(null, true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (relid)\n\t\t\tsetImmediate(checkRelation, self, relation, relid, indexB, callback);\n\t\telse\n\t\t\tcallback(null, false);\n\t});\n}\n\nfunction updMeta(self, type) {\n\tvar buf;\n\tswitch (type) {\n\n\t\tcase META_PAGE_ADD:\n\t\t\tbuf = U.createBufferSize(4);\n\t\t\tbuf.writeUInt32LE(self.header.pages);\n\t\t\tFs.write(self.fd, buf, 0, buf.length, 31, self.cb_error);\n\t\t\tbreak;\n\n\t\tcase META_PAGE_ADD3:\n\t\t\tbuf = U.createBufferSize(4);\n\t\t\tbuf.writeUInt32LE(self.header.pages, 0);\n\t\t\tFs.write(self.fd, buf, 0, buf.length, 31, function() {\n\t\t\t\tbuf.writeUInt32LE(self.header.relationpageindex, 0);\n\t\t\t\tFs.write(self.fd, buf, 0, buf.length, 47, self.cb_error);\n\t\t\t});\n\t\t\tbreak;\n\n\t\tcase META_RELATIONPAGEINDEX:\n\t\t\tbuf = U.createBufferSize(4);\n\t\t\tbuf.writeUInt32LE(self.header.relationpageindex, 0);\n\t\t\tFs.write(self.fd, buf, 0, buf.length, 47, self.cb_error);\n\t\t\tbreak;\n\n\t\tcase META_CLASSESRELATIONS:\n\n\t\t\tvar obj = {};\n\t\t\tobj.c = []; // classes\n\t\t\tobj.r = []; // relations\n\n\t\t\tfor (var i = 0; i < self.header.classindex; i++) {\n\t\t\t\tvar item = self.$classes[i + 1];\n\t\t\t\tobj.c.push({ n: item.name, i: item.index, p: item.pageindex, r: item.schema.raw, d: item.documentindex });\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < self.header.relationindex; i++) {\n\t\t\t\tvar item = self.$relations[i + 1];\n\t\t\t\tobj.r.push({ n: item.name, i: item.index, p: item.pageindex, b: item.both ? 1 :0, d: item.documentindex });\n\t\t\t}\n\n\t\t\tbuf = U.createBufferSize(HEADERSIZE - 45);\n\t\t\tbuf.writeUInt8(self.header.classindex, 0);\n\t\t\tbuf.writeUInt8(self.header.relationindex, 1);\n\t\t\tbuf.writeUInt32LE(self.header.relationpageindex, 2);\n\t\t\tbuf.write(JSON.stringify(obj), 6);\n\t\t\tFs.write(self.fd, buf, 0, buf.length, 45, self.cb_error);\n\t\t\tbreak;\n\t}\n}\n\nfunction insDocument(self) {\n\n\tif (!self.ready || self.states.insert || !self.pending.insert.length || F.isKilled)\n\t\treturn;\n\n\tvar doc = self.pending.insert.shift();\n\tif (doc) {\n\n\t\tvar cls = self.$classes[doc.name];\n\t\tif (cls == null) {\n\t\t\tdoc.callback(new Error('GraphDB: Class \"{0}\" not found.'.format(doc.name)));\n\t\t\treturn;\n\t\t}\n\n\t\tif (cls.locked || !cls.ready) {\n\t\t\tself.pending.insert.push(doc);\n\t\t\tsetTimeout(self.cb_next, DELAY, NEXT_INSERT);\n\t\t\treturn;\n\t\t}\n\n\t\tself.states.insert = true;\n\n\t\taddDocument(self, cls, doc.value, function(err, id) {\n\t\t\t// setTimeout(insDocument, 100, self);\n\t\t\tself.states.insert = false;\n\t\t\tsetImmediate(insDocument, self);\n\t\t\tdoc.callback(err, id);\n\t\t});\n\t}\n}\n\nfunction updDocument(self) {\n\n\tif (!self.ready || self.states.update || !self.pending.update.length || F.isKilled)\n\t\treturn;\n\n\tvar upd = self.pending.update.shift();\n\tif (upd) {\n\t\tself.states.update = true;\n\n\t\tvar offset = offsetDocument(self, upd.id);\n\t\tvar buf = U.createBufferSize(self.header.documentsize);\n\n\t\tFs.read(self.fd, buf, 0, buf.length, offset, function(err, size) {\n\n\t\t\tif (err) {\n\t\t\t\tself.states.update = false;\n\t\t\t\tupd.callback(err);\n\t\t\t\tsetImmediate(self.cb_next, NEXT_UPDATE);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!size) {\n\t\t\t\tupd.callback(null, 0);\n\t\t\t\tself.states.update = false;\n\t\t\t\tsetImmediate(self.cb_next, NEXT_UPDATE);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar save = function(err) {\n\t\t\t\tself.states.update = false;\n\t\t\t\t!err && Fs.write(self.fd, buf, 0, buf.length, offset, self.cb_error);\n\t\t\t\tupd.callback(err, err ? 0 : 1);\n\t\t\t\tsetImmediate(self.cb_next, NEXT_UPDATE);\n\t\t\t};\n\n\t\t\tvar data = buf.slice(DATAOFFSET, buf.readUInt16LE(15) + DATAOFFSET);\n\t\t\tvar limit = self.header.documentsize - DATAOFFSET;\n\t\t\tvar schema = self.$classes[buf[1]].schema;\n\t\t\tvar doc;\n\n\t\t\tif (buf[2] === STATE_COMPRESSED) {\n\t\t\t\tZlib.inflate(data, ZLIBOPTIONS, function(err, buffer) {\n\t\t\t\t\tdoc = parseData(schema, buffer.toString('utf8').split('|'));\n\t\t\t\t\tbuffer = U.createBuffer(stringifyData(schema, upd.fn(doc, upd.value)));\n\t\t\t\t\tif (buffer.length > limit) {\n\t\t\t\t\t\tZlib.deflate(buffer, ZLIBOPTIONS, function(err, buffer) {\n\t\t\t\t\t\t\tif (buffer.length <= limit) {\n\t\t\t\t\t\t\t\tbuf.writeUInt16LE(buffer.length, 15);\n\t\t\t\t\t\t\t\tbuf.writeUInt8(STATE_COMPRESSED, 2);\n\t\t\t\t\t\t\t\tbuffer.copy(buf, DATAOFFSET);\n\t\t\t\t\t\t\t\tsave();\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tsave(new Error('GraphDB: Data too long'));\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf.writeUInt16LE(buffer.length, 15);\n\t\t\t\t\t\tbuf.writeUInt8(STATE_UNCOMPRESSED, 2);\n\t\t\t\t\t\tbuffer.copy(buf, DATAOFFSET);\n\t\t\t\t\t\tsave();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdoc = parseData(schema, data.toString('utf8').split('|'));\n\t\t\t\tvar o = stringifyData(schema, upd.fn(doc, upd.value));\n\t\t\t\tvar buffer = U.createBuffer(o);\n\t\t\t\tif (buffer.length > limit) {\n\t\t\t\t\tZlib.deflate(buffer, ZLIBOPTIONS, function(err, buffer) {\n\t\t\t\t\t\tif (buffer.length <= limit) {\n\t\t\t\t\t\t\tbuf.writeUInt16LE(buffer.length, 15);\n\t\t\t\t\t\t\tbuf.writeUInt8(STATE_COMPRESSED, 2);\n\t\t\t\t\t\t\tbuffer.copy(buf, DATAOFFSET);\n\t\t\t\t\t\t\tsave();\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tsave(new Error('GraphDB: Data too long'));\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tbuf.writeUInt16LE(buffer.length, 15);\n\t\t\t\t\tbuf.writeUInt8(STATE_UNCOMPRESSED, 2);\n\t\t\t\t\tbuffer.copy(buf, DATAOFFSET);\n\t\t\t\t\tsave();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction insRelation(self) {\n\n\tif (!self.ready || self.states.relation)\n\t\treturn;\n\n\tvar doc = self.pending.relation.shift();\n\tif (doc) {\n\n\t\tvar rel = self.$relations[doc.name];\n\t\tif (rel == null) {\n\t\t\tdoc.callback(new Error('GraphDB: Relation \"{0}\" not found.'.format(doc.name)));\n\t\t\treturn;\n\t\t}\n\n\t\tif (rel.locked || !rel.ready) {\n\t\t\tself.pending.relation.push(doc);\n\t\t\tsetTimeout(insRelation, DELAY, self);\n\t\t\treturn;\n\t\t}\n\n\t\tself.states.relation = true;\n\n\t\tif (doc.connect) {\n\t\t\taddRelation(self, rel, doc.indexA, doc.indexB, function(err, id) {\n\t\t\t\tself.states.relation = false;\n\t\t\t\tdoc.callback(err, id);\n\t\t\t\tsetImmediate(insRelation, self);\n\t\t\t});\n\t\t} else {\n\t\t\tremRelation(self, rel, doc.indexA, doc.indexB, function(err, id) {\n\t\t\t\tself.states.relation = false;\n\t\t\t\tdoc.callback(err, id);\n\t\t\t\tsetImmediate(insRelation, self);\n\t\t\t});\n\t\t}\n\t}\n}\n\nGP.create = function(filename, documentsize, callback) {\n\tvar self = this;\n\tFs.unlink(filename, function() {\n\t\tvar buf = U.createBufferSize(HEADERSIZE);\n\t\tbuf.write('Total.js GraphDB embedded', 0);\n\t\tbuf.writeUInt8(VERSION, 30);          // version\n\t\tbuf.writeUInt32LE(0, 31);             // pages\n\t\tbuf.writeUInt16LE(PAGESIZE, 35);      // pagesize\n\t\tbuf.writeUInt16LE(PAGELIMIT, 37);     // pagelimit\n\t\tbuf.writeUInt32LE(0, 39);             // documents\n\t\tbuf.writeUInt16LE(documentsize, 43);  // documentsize\n\t\tbuf.writeUInt8(0, 45);                // classindex\n\t\tbuf.writeUInt8(0, 46);                // relationindex\n\t\tbuf.writeUInt8(0, 47);                // relationpageindex\n\t\tbuf.write('{\"c\":[],\"r\":[]}', 51);     // classes and relations\n\t\tFs.open(filename, 'w', function(err, fd) {\n\t\t\tFs.write(fd, buf, 0, buf.length, 0, function(err) {\n\t\t\t\terr && self.error(err, 'create');\n\t\t\t\tFs.close(fd, function() {\n\t\t\t\t\tcallback && callback();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\treturn self;\n};\n\nGP.open = function() {\n\tvar self = this;\n\tFs.stat(self.filename, function(err, stat) {\n\t\tif (err) {\n\t\t\t// file not found\n\t\t\tself.create(self.filename, DOCUMENTSIZE, () => self.open());\n\t\t} else {\n\t\t\tself.header.size = stat.size;\n\t\t\tFs.open(self.filename, 'r+', function(err, fd) {\n\t\t\t\tself.fd = fd;\n\t\t\t\terr && self.error(err, 'open');\n\t\t\t\tvar buf = U.createBufferSize(HEADERSIZE);\n\t\t\t\tFs.read(self.fd, buf, 0, buf.length, 0, function() {\n\n\t\t\t\t\tself.header.pages = buf.readUInt32LE(31);\n\t\t\t\t\tself.header.pagesize = buf.readUInt16LE(35);\n\t\t\t\t\tself.header.pagelimit = buf.readUInt16LE(37);\n\t\t\t\t\tself.header.documents = buf.readUInt32LE(39);\n\t\t\t\t\tself.header.documentsize = buf.readUInt16LE(43);\n\n\t\t\t\t\tvar size = F.config['graphdb.' + self.name] || DOCUMENTSIZE;\n\t\t\t\t\tif (size > self.header.documentsize) {\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tself.next(NEXT_RESIZE);\n\t\t\t\t\t\t}, DELAY);\n\t\t\t\t\t}\n\n\t\t\t\t\tself.header.relationlimit = ((self.header.documentsize - DATAOFFSET) / 6) >> 0;\n\t\t\t\t\tself.header.classindex = buf[45];\n\t\t\t\t\tself.header.relationindex = buf[46];\n\t\t\t\t\tself.header.relationpageindex = buf.readUInt32LE(47);\n\n\t\t\t\t\tvar data = buf.slice(51, buf.indexOf(EMPTYBUFFER, 51)).toString('utf8');\n\t\t\t\t\tvar meta = data.parseJSON(true);\n\n\t\t\t\t\tfor (var i = 0; i < meta.c.length; i++) {\n\t\t\t\t\t\tvar item = meta.c[i];\n\t\t\t\t\t\tself.class(item.n, item.r, item);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < meta.r.length; i++) {\n\t\t\t\t\t\tvar item = meta.r[i];\n\t\t\t\t\t\tself.relation(item.n, item.b === 1, item);\n\t\t\t\t\t}\n\n\t\t\t\t\t!self.header.relationpageindex && addPage(self, TYPE_RELATION_DOCUMENT, 0, 0, function(err, index) {\n\t\t\t\t\t\tself.header.relationpageindex = index;\n\t\t\t\t\t});\n\n\t\t\t\t\tself.ready = true;\n\t\t\t\t\tself.next(NEXT_READY);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t});\n\treturn self;\n};\n\nGP.next = function(type) {\n\n\tvar self = this;\n\tvar tmp;\n\n\tswitch (type) {\n\t\tcase NEXT_READY:\n\t\t\tfor (var i = 0; i < self.pending.meta.length; i++) {\n\t\t\t\ttmp = self.pending.meta[i];\n\t\t\t\tif (tmp.type === TYPE_CLASS)\n\t\t\t\t\tself.class(tmp.name, tmp.data);\n\t\t\t\telse\n\t\t\t\t\tself.relation(tmp.name, tmp.data);\n\t\t\t}\n\t\t\tself.emit('ready');\n\t\t\tbreak;\n\n\t\tcase NEXT_RESIZE:\n\n\t\t\tclearTimeout(self.$resizedelay);\n\t\t\tself.$resizedelay = setTimeout(function() {\n\t\t\t\tif (!self.states.resize) {\n\t\t\t\t\tself.ready = false;\n\t\t\t\t\tself.states.resize = true;\n\t\t\t\t\tvar size = (F.config['graphdb.' + self.name] || DOCUMENTSIZE);\n\t\t\t\t\tvar meta = { documentsize: size > self.header.documentsize ? size : self.header.documentsize };\n\t\t\t\t\tvar keys = Object.keys(self.$classes);\n\n\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\t\tvar cls = self.$classes[key];\n\t\t\t\t\t\tif (cls.$resize) {\n\t\t\t\t\t\t\t!meta.classes && (meta.classes = {});\n\t\t\t\t\t\t\tmeta.classes[cls.index] = cls.$resize;\n\t\t\t\t\t\t\tcls.$resize = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tself.resize(meta, function() {\n\t\t\t\t\t\tself.states.resize = false;\n\t\t\t\t\t\tself.ready = true;\n\t\t\t\t\t\tsetImmediate(self.cb_next, NEXT_CONTINUE);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, DELAY);\n\n\t\t\tbreak;\n\n\t\tcase NEXT_INSERT:\n\t\t\tinsDocument(self);\n\t\t\tbreak;\n\t\tcase NEXT_RELATION:\n\t\t\tinsRelation(self);\n\t\t\tbreak;\n\t\tcase NEXT_UPDATE:\n\t\t\tupdDocument(self);\n\t\t\tbreak;\n\t\tcase NEXT_REMOVE:\n\t\t\tremDocument(self);\n\t\t\tbreak;\n\t\tcase NEXT_FIND:\n\t\t\tif (self.pending.find.length) {\n\t\t\t\ttmp = self.pending.find.shift();\n\t\t\t\t$find(self, tmp.name, tmp.builder, tmp.reverse);\n\t\t\t}\n\t\t\tbreak;\n\t}\n};\n\nGP.class = function(name, meta, data) {\n\n\tvar self = this;\n\n\tif (!self.ready && !data) {\n\t\tself.pending.meta.push({ name: name, data: meta, type: 1 });\n\t\treturn self;\n\t}\n\n\tvar item = self.$classes[name];\n\tvar save = false;\n\n\tif (item == null) {\n\n\t\titem = {};\n\t\titem.locked = false;\n\n\t\tif (data) {\n\t\t\titem.ready = true;\n\t\t\titem.name = name;\n\t\t\titem.index = data.i;\n\t\t\titem.pageindex = data.p;\n\t\t\titem.documentindex = data.d;\n\t\t\titem.findfreeslots = true;\n\t\t} else {\n\t\t\tself.header.classindex++;\n\t\t\titem.name = name;\n\t\t\titem.index = self.header.classindex;\n\t\t\titem.ready = false;\n\t\t\titem.pageindex = addPage(self, TYPE_CLASS, item.index, 0, function() {\n\t\t\t\titem.ready = true;\n\t\t\t});\n\t\t\titem.documentindex = getDocumentIndex(self, item.pageindex);\n\t\t\tsave = true;\n\t\t}\n\n\t\titem.schema = parseSchema(meta);\n\t\tself.$classes[item.name] = self.$classes[item.index] = item;\n\n\t} else {\n\t\tvar newschema = parseSchema(meta);\n\t\tvar raw = item.schema.raw;\n\t\tif (raw !== newschema.raw) {\n\t\t\titem.$resize = newschema;\n\t\t\tself.next(NEXT_RESIZE);\n\t\t}\n\t}\n\n\tsave && updMeta(self, META_CLASSESRELATIONS);\n\treturn self;\n};\n\nGP.relation = function(name, both, data) {\n\n\tvar self = this;\n\n\tif (!self.ready && !data) {\n\t\tself.pending.meta.push({ name: name, data: both, type: 2 });\n\t\treturn self;\n\t}\n\n\tvar self = this;\n\tvar item = self.$relations[name];\n\tvar save = false;\n\n\tif (item == null) {\n\n\t\titem = {};\n\t\titem.ready = true;\n\t\titem.locked = false;\n\n\t\tif (data) {\n\t\t\titem.name = name;\n\t\t\titem.index = data.i;\n\t\t\titem.pageindex = data.p;\n\t\t\titem.documentindex = data.d;\n\t\t\titem.both = both;\n\t\t} else {\n\t\t\tself.header.relationindex++;\n\t\t\titem.name = name;\n\t\t\titem.index = self.header.relationindex;\n\t\t\titem.ready = false;\n\t\t\titem.both = both;\n\t\t\titem.pageindex = addPage(self, TYPE_RELATION, item.index, 0, function() {\n\t\t\t\titem.ready = true;\n\t\t\t});\n\t\t\titem.documentindex = getDocumentIndex(self, item.pageindex);\n\t\t\tsave = true;\n\t\t}\n\n\t\tself.$relations[item.name] = self.$relations[item.index] = item;\n\n\t} else {\n\t\t// compare\n\t}\n\n\tsave && updMeta(self, META_CLASSESRELATIONS);\n\treturn self;\n};\n\nGP.emit = function(name, a, b, c, d, e, f, g) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nGP.on = function(name, fn) {\n\tif (this.$ready && (name === 'ready' || name === 'load')) {\n\t\tfn();\n\t\treturn this;\n\t}\n\tif (!fn.$once)\n\t\tthis.$free = false;\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nGP.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nGP.removeListener = function(name, fn) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tthis.$events[name] = evt;\n\t\telse\n\t\t\tthis.$events[name] = undefined;\n\t}\n\treturn this;\n};\n\nGP.removeAllListeners = function(name) {\n\tif (name === true)\n\t\tthis.$events = EMPTYOBJECT;\n\telse if (name)\n\t\tthis.$events[name] = undefined;\n\telse\n\t\tthis.$events[name] = {};\n\treturn this;\n};\n\nGP.resize = function(meta, callback) {\n\n\t// meta.documentsize\n\t// meta.classes\n\n\tvar self = this;\n\tvar filename = self.filename + '-tmp';\n\n\tself.create(filename, meta.documentsize, function(err) {\n\n\t\tif (err)\n\t\t\tthrow err;\n\n\t\tFs.open(filename, 'r+', function(err, fd) {\n\n\t\t\tvar offset = HEADERSIZE;\n\t\t\tvar newoffset = HEADERSIZE;\n\t\t\tvar size = self.header.pagesize + (self.header.pagelimit * self.header.documentsize);\n\t\t\tvar newsize = self.header.pagesize + (self.header.pagelimit * meta.documentsize);\n\t\t\tvar pageindex = 0;\n\t\t\tvar totaldocuments = 0;\n\n\t\t\tvar finish = function() {\n\n\t\t\t\tvar buf = U.createBufferSize(HEADERSIZE);\n\t\t\t\tFs.read(fd, buf, 0, buf.length, 0, function() {\n\n\t\t\t\t\t// ==== DB:HEADER (7000b)\n\t\t\t\t\t// name (30b)             = from: 0\n\t\t\t\t\t// version (1b)           = from: 30\n\t\t\t\t\t// pages (4b)             = from: 31\n\t\t\t\t\t// pagesize (2b)          = from: 35\n\t\t\t\t\t// pagelimit (2b)         = from: 37\n\t\t\t\t\t// documents (4b)         = from: 39\n\t\t\t\t\t// documentsize (2b)      = from: 43\n\t\t\t\t\t// classindex (1b)        = from: 45\n\t\t\t\t\t// relationindex (1b)     = from: 46\n\t\t\t\t\t// relationnodeindex      = from: 47\n\t\t\t\t\t// classes + relations    = from: 51\n\n\t\t\t\t\t// buf.\n\n\t\t\t\t\tbuf.writeUInt32LE(pageindex > 0 ? (pageindex - 1) : 0, 31);\n\t\t\t\t\tbuf.writeUInt32LE(totaldocuments, 39);\n\t\t\t\t\tbuf.writeUInt16LE(meta.documentsize, 43);\n\n\t\t\t\t\tvar obj = {};\n\t\t\t\t\tobj.c = []; // classes\n\t\t\t\t\tobj.r = []; // relations\n\n\t\t\t\t\tfor (var i = 0; i < self.header.classindex; i++) {\n\t\t\t\t\t\tvar item = self.$classes[i + 1];\n\t\t\t\t\t\tvar schema = meta.classes[i + 1];\n\t\t\t\t\t\tobj.c.push({ n: item.name, i: item.index, p: item.pageindex, r: schema ? schema.raw : item.schema.raw, d: item.documentindex });\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < self.header.relationindex; i++) {\n\t\t\t\t\t\tvar item = self.$relations[i + 1];\n\t\t\t\t\t\tobj.r.push({ n: item.name, i: item.index, p: item.pageindex, b: item.both ? 1 :0, d: item.documentindex });\n\t\t\t\t\t}\n\n\t\t\t\t\tbuf.writeUInt8(self.header.classindex, 45);\n\t\t\t\t\tbuf.writeUInt8(self.header.relationindex, 46);\n\t\t\t\t\tbuf.writeUInt32LE(self.header.relationpageindex, 47);\n\t\t\t\t\tbuf.write(JSON.stringify(obj), 51);\n\n\t\t\t\t\tFs.write(fd, buf, 0, buf.length, 0, function() {\n\t\t\t\t\t\t// console.log(pageindex, meta.documentsize, totaldocuments);\n\t\t\t\t\t\tFs.close(fd, function() {\n\t\t\t\t\t\t\tFs.close(self.fd, function() {\n\t\t\t\t\t\t\t\tFs.copyFile(self.filename, self.filename.replace(/\\.gdb$/, NOW.format('_yyyyMMddHHmm') + '.gdp'), function() {\n\t\t\t\t\t\t\t\t\tFs.rename(self.filename + '-tmp', self.filename, function() {\n\t\t\t\t\t\t\t\t\t\tcallback(null);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tvar readvalue = function(docbuf, callback) {\n\t\t\t\tvar data = docbuf.slice(DATAOFFSET, docbuf.readUInt16LE(15) + DATAOFFSET);\n\t\t\t\tif (docbuf[2] === STATE_COMPRESSED)\n\t\t\t\t\tZlib.inflate(data, ZLIBOPTIONS, (err, data) => callback(data ? data.toString('utf8') : ''));\n\t\t\t\telse\n\t\t\t\t\tcallback(data.toString('utf8'));\n\t\t\t};\n\n\t\t\tvar writevalue = function(value, callback) {\n\t\t\t\tvar maxsize = meta.documentsize - DATAOFFSET;\n\t\t\t\tvar data = U.createBuffer(value);\n\t\t\t\tif (data.length > maxsize) {\n\t\t\t\t\tZlib.deflate(data, ZLIBOPTIONS, (err, data) => callback((!data || data.length > maxsize) ? EMPTYBUFFER : data));\n\t\t\t\t} else\n\t\t\t\t\tcallback(data);\n\t\t\t};\n\n\t\t\tvar process = function() {\n\n\t\t\t\tpageindex++;\n\n\t\t\t\t// ==== DB:PAGE (20b)\n\t\t\t\t// type (1b)              = from: 0\n\t\t\t\t// index (1b)             = from: 1\n\t\t\t\t// documents (2b)         = from: 2\n\t\t\t\t// freeslots (1b)         = from: 4\n\t\t\t\t// parentindex (4b)       = from: 5\n\n\t\t\t\t// ==== DB:DOCUMENT (SIZE)\n\t\t\t\t// type (1b)              = from: 0\n\t\t\t\t// index (1b)             = from: 1\n\t\t\t\t// state (1b)             = from: 2\n\t\t\t\t// pageindex (4b)         = from: 3\n\t\t\t\t// relationindex (4b)     = from: 7  (it's for relations between two documents in TYPE_RELATION page)\n\t\t\t\t// parentindex (4b)       = from: 11\n\t\t\t\t// size/count (2b)        = from: 15\n\t\t\t\t// data                   = from: 17\n\n\t\t\t\tvar buf = U.createBufferSize(size);\n\n\t\t\t\tFs.read(self.fd, buf, 0, buf.length, offset, function(err, size) {\n\n\t\t\t\t\tif (!size) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar newbuf = U.createBufferSize(newsize);\n\n\t\t\t\t\t// Copies page info\n\t\t\t\t\tnewbuf.fill(buf, 0, self.header.pagesize);\n\t\t\t\t\tbuf = buf.slice(self.header.pagesize);\n\n\t\t\t\t\tvar index = self.header.pagesize;\n\t\t\t\t\tvar documents = 0;\n\n\t\t\t\t\t(self.header.pagelimit).async(function(i, next) {\n\n\t\t\t\t\t\t// Unexpected problem\n\t\t\t\t\t\tif (!buf.length) {\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar docbuf = buf.slice(0, self.header.documentsize);\n\t\t\t\t\t\tvar typeid = docbuf[0];\n\t\t\t\t\t\tvar indexid = docbuf[1];\n\n\t\t\t\t\t\tif (docbuf[2] !== STATE_REMOVED) {\n\t\t\t\t\t\t\ttotaldocuments++;\n\t\t\t\t\t\t\tdocuments++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (docbuf[2] !== STATE_REMOVED && meta.classes && typeid === TYPE_CLASS && meta.classes[indexid]) {\n\t\t\t\t\t\t\treadvalue(docbuf, function(value) {\n\n\t\t\t\t\t\t\t\t// parseData\n\t\t\t\t\t\t\t\t// stringifyData\n\t\t\t\t\t\t\t\tvalue = stringifyData(meta.classes[indexid], parseData(self.$classes[indexid].schema, value.split('|')));\n\n\t\t\t\t\t\t\t\twritevalue(value, function(value) {\n\n\t\t\t\t\t\t\t\t\tif (value === EMPTYBUFFER) {\n\t\t\t\t\t\t\t\t\t\t// BIG PROBLEM\n\t\t\t\t\t\t\t\t\t\tdocbuf.writeUInt16LE(0, 15);\n\t\t\t\t\t\t\t\t\t\tdocbuf.writeUInt8(STATE_REMOVED, 2);\n\t\t\t\t\t\t\t\t\t\tdocuments--;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdocbuf.writeUInt16LE(value.length, 15);\n\t\t\t\t\t\t\t\t\t\tdocbuf.fill(value, DATAOFFSET, DATAOFFSET + value.length);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewbuf.fill(docbuf, index, index + self.header.documentsize);\n\t\t\t\t\t\t\t\t\tindex += meta.documentsize;\n\t\t\t\t\t\t\t\t\tbuf = buf.slice(self.header.documentsize);\n\t\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewbuf.fill(docbuf, index, index + self.header.documentsize);\n\t\t\t\t\t\t\tindex += meta.documentsize;\n\t\t\t\t\t\t\tbuf = buf.slice(self.header.documentsize);\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, function() {\n\n\t\t\t\t\t\t// Update count of documents\n\t\t\t\t\t\tif (newbuf.readUInt16LE(2) !== documents)\n\t\t\t\t\t\t\tnewbuf.writeUInt16LE(documents, 2);\n\n\t\t\t\t\t\tFs.write(fd, newbuf, 0, newbuf.length, newoffset, function() {\n\t\t\t\t\t\t\toffset += size;\n\t\t\t\t\t\t\tnewoffset += newsize;\n\t\t\t\t\t\t\tsetImmediate(process);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tprocess();\n\t\t});\n\t});\n\treturn self;\n};\n\n\nfunction $update(doc, value) {\n\treturn value;\n}\n\nfunction $modify(doc, value) {\n\tvar keys = Object.keys(value);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\n\t\tswitch (key[0]) {\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase '*':\n\t\t\tcase '/':\n\t\t\t\tvar tmp = key.substring(1);\n\t\t\t\tif (typeof(doc[tmp]) === 'number') {\n\t\t\t\t\tif (key[0] === '+')\n\t\t\t\t\t\tdoc[tmp] += value[key];\n\t\t\t\t\telse if (key[0] === '-')\n\t\t\t\t\t\tdoc[tmp] -= value[key];\n\t\t\t\t\telse if (key[0] === '*')\n\t\t\t\t\t\tdoc[tmp] *= value[key];\n\t\t\t\t\telse if (key[0] === '/')\n\t\t\t\t\t\tdoc[tmp] = doc[tmp] / value[key];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (doc[key] != undefined)\n\t\t\t\t\tdoc[key] = value[key];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn doc;\n}\n\nGP.remove = function(id, callback) {\n\tvar self = this;\n\tvar rem = { id: id, callback: callback || NOOP };\n\tself.pending.remove.push(rem);\n\tself.next(NEXT_REMOVE);\n\treturn self;\n};\n\nGP.update = function(id, value, callback) {\n\tvar self = this;\n\tvar upd = { id: id, value: value, fn: typeof(value) === 'function' ? value : $update, callback: callback || NOOP };\n\tself.pending.update.push(upd);\n\tself.next(NEXT_UPDATE);\n\treturn self;\n};\n\nGP.modify = function(id, value, callback) {\n\tvar self = this;\n\tvar upd = { id: id, value: value, fn: $modify, callback: callback || NOOP };\n\tself.pending.update.push(upd);\n\tself.next(NEXT_UPDATE);\n\treturn self;\n};\n\nGP.insert = function(name, value, callback) {\n\tvar self = this;\n\tself.pending.insert.push({ name: name, value: value, callback: callback || NOOP });\n\tself.next(NEXT_INSERT);\n\treturn self;\n};\n\nGP.cursor = function(type, name, callback) {\n\n\tvar self = this;\n\tvar index;\n\tvar tmp;\n\n\tswitch (type) {\n\t\tcase TYPE_CLASS:\n\t\t\ttmp = self.$classes[name];\n\t\t\tindex = tmp.pageindex;\n\t\t\tbreak;\n\t\tcase TYPE_RELATION:\n\t\t\ttmp = self.$relations[name];\n\t\t\tindex = tmp.pageindex;\n\t\t\tbreak;\n\t}\n\n\tvar offset = offsetPage(self, index);\n\tvar buf = U.createBufferSize(PAGESIZE);\n\n\tFs.read(self.fd, buf, 0, buf.length, offset, function(err) {\n\n\t\tif (err) {\n\t\t\tcallback(err);\n\t\t\treturn;\n\t\t}\n\n\t\tif (buf[0] !== TYPE_CLASS) {\n\t\t\tcallback(new Error('Invalid page type'));\n\t\t\treturn;\n\t\t}\n\n\t\tif (buf[1] !== tmp.index) {\n\t\t\tcallback(new Error('Invalid type index'));\n\t\t\treturn;\n\t\t}\n\n\t\tvar data = {};\n\t\tdata.count = buf.readUInt16LE(2);\n\t\tdata.parent = buf.readUInt32LE(5);\n\t\tdata.offset = offset;\n\t\tdata.type = buf[0];\n\t\tdata.index = buf[1];\n\t\tdata.freeslots = buf[4];\n\n\t\tdata.next = function(callback) {\n\n\t\t\tif (data.parent == 0) {\n\t\t\t\tcallback(new Error('This is the last page'), data);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\toffset = offsetPage(self, data.parent);\n\t\t\tFs.read(self.fd, buf, 0, buf.length, offset, function(err) {\n\t\t\t\tdata.count = buf.readUInt16LE(2);\n\t\t\t\tdata.parent = buf.readUInt32LE(5);\n\t\t\t\tdata.offset = offset;\n\t\t\t\tdata.type = buf[0];\n\t\t\t\tdata.index = buf[1];\n\t\t\t\tdata.freeslots = buf[4];\n\t\t\t\tdata.INDEX = getIndexPage(self, offset) + 1;\n\t\t\t\tcallback(err, data);\n\t\t\t});\n\t\t};\n\n\t\tdata.documents = function(callback) {\n\n\t\t\tif (!data.count) {\n\t\t\t\tcallback(null, EMPTYARRAY);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar index = getIndexPage(self, data.offset) * self.header.pagelimit;\n\t\t\tvar buffer = U.createBufferSize(self.header.pagelimit * self.header.documentsize);\n\t\t\tvar offset = data.offset + self.header.pagesize;\n\t\t\tvar decompress = [];\n\n\t\t\tindex += self.header.pagelimit + 1;\n\n\t\t\tFs.read(self.fd, buffer, 0, buffer.length, offset, function(err) {\n\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err, EMPTYARRAY);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar arr = [];\n\t\t\t\twhile (true) {\n\n\t\t\t\t\tif (!buffer.length)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tindex--;\n\t\t\t\t\tvar data = buffer.slice(buffer.length - self.header.documentsize);\n\t\t\t\t\t// index++;\n\t\t\t\t\t// var data = buffer.slice(0, self.header.documentsize);\n\t\t\t\t\tif (!data.length)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// type (1b)              = from: 0\n\t\t\t\t\t// index (1b)             = from: 1\n\t\t\t\t\t// state (1b)             = from: 2\n\t\t\t\t\t// pageindex (4b)         = from: 3\n\t\t\t\t\t// continuerindex (4b)    = from: 7\n\t\t\t\t\t// parentindex (4b)       = from: 11\n\t\t\t\t\t// size/count (2b)        = from: 15\n\t\t\t\t\t// data                   = from: 17\n\n\t\t\t\t\tif (data[2] !== STATE_REMOVED) {\n\t\t\t\t\t\tvar raw = data.slice(DATAOFFSET, data.readUInt16LE(15) + DATAOFFSET);\n\t\t\t\t\t\tif (type === TYPE_CLASS) {\n\t\t\t\t\t\t\t// Document is compressed\n\t\t\t\t\t\t\tif (data[2] === STATE_COMPRESSED) {\n\t\t\t\t\t\t\t\tvar obj = {};\n\t\t\t\t\t\t\t\tobj.CLASS = tmp.name;\n\t\t\t\t\t\t\t\tobj.ID = index;\n\t\t\t\t\t\t\t\tobj.BUFFER = raw;\n\t\t\t\t\t\t\t\tdecompress.push({ CLASS: tmp, ID: index, BUFFER: raw, index: arr.push(null) });\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar obj = parseData(tmp.schema, raw.toString('utf8').split('|'));\n\t\t\t\t\t\t\t\tobj.CLASS = tmp.name;\n\t\t\t\t\t\t\t\tobj.ID = index;\n\t\t\t\t\t\t\t\tarr.push(obj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbuffer = buffer.slice(0, buffer.length - self.header.documentsize);\n\t\t\t\t\t// buffer = buffer.slice(self.header.documentsize);\n\t\t\t\t}\n\n\t\t\t\tif (decompress.length) {\n\t\t\t\t\tdecompress.wait(function(item, next) {\n\t\t\t\t\t\tZlib.inflate(item.BUFFER, ZLIBOPTIONS, function(err, data) {\n\t\t\t\t\t\t\tvar obj = parseData(item.CLASS.schema, data.toString('utf8').split('|'));\n\t\t\t\t\t\t\tobj.CLASS = item.CLASS.name;\n\t\t\t\t\t\t\tobj.ID = item.ID;\n\t\t\t\t\t\t\tarr[item.index] = obj;\n\t\t\t\t\t\t\tsetImmediate(next);\n\t\t\t\t\t\t});\n\t\t\t\t\t}, () => callback(null, arr));\n\t\t\t\t} else\n\t\t\t\t\tcallback(null, arr);\n\t\t\t});\n\t\t};\n\n\t\tcallback(null, data);\n\t});\n};\n\nGP.read = function(index, callback) {\n\tvar self = this;\n\tvar buf = U.createBufferSize(self.header.documentsize);\n\tFs.read(self.fd, buf, 0, buf.length, offsetDocument(self, index), function(err) {\n\n\t\tif (err) {\n\t\t\tcallback(err);\n\t\t\treturn;\n\t\t}\n\n\t\tif (buf[2] === STATE_REMOVED) {\n\t\t\tcallback(null, buf[0] === TYPE_CLASS ? null : EMPTYARRAY);\n\t\t\treturn;\n\t\t}\n\n\t\tvar tmp;\n\n\t\tswitch(buf[0]) {\n\t\t\tcase TYPE_CLASS:\n\t\t\t\ttmp = self.$classes[buf[1]];\n\t\t\t\tif (tmp) {\n\t\t\t\t\tvar data = buf.slice(DATAOFFSET, buf.readUInt16LE(15) + DATAOFFSET);\n\t\t\t\t\tif (buf[2] === STATE_COMPRESSED) {\n\t\t\t\t\t\tZlib.inflate(data, ZLIBOPTIONS, function(err, data) {\n\t\t\t\t\t\t\tdata = parseData(tmp.schema, data.toString('utf8').split('|'));\n\t\t\t\t\t\t\tdata.ID = index;\n\t\t\t\t\t\t\tdata.CLASS = tmp.name;\n\t\t\t\t\t\t\tcallback(null, data, buf.readUInt32LE(7), buf.readUInt32LE(11));\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata = parseData(tmp.schema, data.toString('utf8').split('|'));\n\t\t\t\t\t\tdata.ID = index;\n\t\t\t\t\t\tdata.CLASS = tmp.name;\n\t\t\t\t\t\tcallback(null, data, buf.readUInt32LE(7), buf.readUInt32LE(11));\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tcallback(new Error('GraphDB: invalid document'), null);\n\t\t\t\tbreak;\n\t\t\tcase TYPE_RELATION:\n\t\t\t\ttmp = self.$relations[buf[1]];\n\t\t\t\tif (tmp) {\n\n\t\t\t\t\tvar count = buf.readUInt16LE(15);\n\t\t\t\t\tvar arr = [];\n\t\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\t\tvar off = DATAOFFSET + (i * 6);\n\t\t\t\t\t\tarr.push({ RELATION: tmp.name, ID: buf.readUInt32LE(off + 2), INIT: buf[1], INDEX: i });\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback(null, arr, buf.readUInt32LE(7), buf.readUInt32LE(11), 'RELATION');\n\n\t\t\t\t} else\n\t\t\t\t\tcallback(new Error('GraphDB: invalid document'), null);\n\t\t\t\tbreak;\n\n\t\t\tcase TYPE_RELATION_DOCUMENT:\n\n\t\t\t\tvar count = buf.readUInt16LE(15);\n\t\t\t\tvar arr = [];\n\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar off = DATAOFFSET + (i * 6);\n\t\t\t\t\ttmp = self.$relations[buf[off]];\n\t\t\t\t\tarr.push({ RELATION: tmp.name, ID: buf.readUInt32LE(off + 2), INIT: buf[off + 1], INDEX: i });\n\t\t\t\t}\n\n\t\t\t\tcallback(null, arr, buf.readUInt32LE(7), buf.readUInt32LE(11), 'PRIVATE');\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tcallback(null, null);\n\t\t\t\tbreak;\n\t\t}\n\t});\n};\n\nGP.connect = function(name, indexA, indexB, callback) {\n\tvar self = this;\n\tself.pending.relation.push({ name: name, indexA: indexA, indexB: indexB, callback: callback, connect: true });\n\tself.next(NEXT_RELATION);\n\treturn self;\n};\n\nGP.disconnect = function(name, indexA, indexB, callback) {\n\tvar self = this;\n\tself.pending.relation.push({ name: name, indexA: indexA, indexB: indexB, callback: callback });\n\tself.next(NEXT_RELATION);\n\treturn self;\n};\n\nGP.find = function(cls) {\n\tvar self = this;\n\tvar builder = new DatabaseBuilder(self);\n\tself.pending.find.push({ name: cls, builder: builder });\n\tsetImmediate(self.cb_next, NEXT_FIND);\n\treturn builder;\n};\n\nGP.find2 = function(cls) {\n\tvar self = this;\n\tvar builder = new DatabaseBuilder(self);\n\tself.pending.find.push({ name: cls, builder: builder, reverse: true });\n\tsetImmediate(self.cb_next, NEXT_FIND);\n\treturn builder;\n};\n\nGP.scalar = function(cls, type, field) {\n\tvar self = this;\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.scalar(type, field);\n\tself.pending.find.push({ name: cls, builder: builder });\n\tsetImmediate(self.cb_next, NEXT_FIND);\n\treturn builder;\n};\n\nGP.count = function(cls) {\n\treturn this.scalar(cls, 'count', 'ID');\n};\n\nfunction GraphDBFilter(db) {\n\tvar t = this;\n\tt.db = db;\n\tt.levels = null;\n}\n\nGraphDBFilter.prototype.level = function(num) {\n\tvar self = this;\n\tif (self.levels == null)\n\t\tself.levels = {};\n\treturn self.levels[num] = new DatabaseBuilder(self.db);\n};\n\nGraphDBFilter.prototype.prepare = function() {\n\n\tvar self = this;\n\n\tif (!self.levels)\n\t\treturn self;\n\n\tvar arr = Object.keys(self.levels);\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar key = arr[i];\n\t\tvar builder = self.levels[key];\n\t\tvar filter = {};\n\t\tfilter.builder = builder;\n\t\tfilter.scalarcount = 0;\n\t\tfilter.filter = builder.makefilter();\n\t\tfilter.compare = builder.compile();\n\t\tfilter.index = 0;\n\t\tfilter.count = 0;\n\t\tfilter.counter = 0;\n\t\tfilter.first = builder.$options.first && !builder.$options.sort;\n\t\tself.levels[key] = filter;\n\t}\n\n\treturn self;\n};\n\nGP.graph = function(id, options, callback, filter) {\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = EMPTYOBJECT;\n\t} else if (!options)\n\t\toptions = EMPTYOBJECT;\n\n\tvar self = this;\n\n\tif (!filter)\n\t\tfilter = new GraphDBFilter(self);\n\n\n\tself.read(id, function(err, doc, linkid) {\n\n\t\tif (err || !doc) {\n\t\t\tcallback(err, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\t// options.depth (Int)\n\t\t// options.relation (String or String Array)\n\t\t// options.class (String or String Array)\n\n\t\tvar relations = null;\n\t\tvar classes = null;\n\n\t\tif (options.relation) {\n\n\t\t\tvar rel;\n\t\t\trelations = {};\n\n\t\t\tif (options.relation instanceof Array) {\n\t\t\t\tfor (var i = 0; i < options.relation.length; i++) {\n\t\t\t\t\trel = self.$relations[options.relation[i]];\n\t\t\t\t\tif (rel)\n\t\t\t\t\t\trelations[rel.name] = rel.both ? 1 : 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trel = self.$relations[options.relation];\n\t\t\t\tif (rel)\n\t\t\t\t\trelations[rel.name] = rel.both ? 1 : 0;\n\t\t\t}\n\t\t}\n\n\t\tif (options.class) {\n\n\t\t\tvar clstmp;\n\t\t\tclasses = {};\n\n\t\t\tif (options.class instanceof Array) {\n\t\t\t\tfor (var i = 0; i < options.class.length; i++) {\n\t\t\t\t\tclstmp = self.$classes[options.class[i]];\n\t\t\t\t\tif (clstmp)\n\t\t\t\t\t\tclasses[clstmp.name] = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tclstmp = self.$classes[options.class];\n\t\t\t\tif (clstmp)\n\t\t\t\t\tclasses[clstmp.name] = clstmp.index + 1;\n\t\t\t}\n\t\t}\n\n\t\tfilter.prepare();\n\n\t\tvar pending = [];\n\t\tvar tmp = {};\n\t\tvar count = 1;\n\t\tvar sort = false;\n\n\t\ttmp[id] = 1;\n\n\t\tdoc.INDEX = 0;\n\t\tdoc.LEVEL = 0;\n\t\tdoc.NODES = [];\n\n\t\tvar reader = function(parent, id, depth) {\n\n\t\t\tif ((options.depth && depth >= options.depth) || (tmp[id])) {\n\t\t\t\tprocess();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttmp[id] = 1;\n\n\t\t\tself.read(id, function(err, links, linkid) {\n\n\t\t\t\tif (linkid && !tmp[linkid]) {\n\t\t\t\t\tpending.push({ id: linkid, parent: parent, depth: depth });\n\t\t\t\t\tsort = true;\n\t\t\t\t}\n\n\t\t\t\t// because of seeking on HDD\n\t\t\t\tlinks.quicksort('ID');\n\n\t\t\t\tvar fil;\n\n\t\t\t\tlinks.wait(function(item, next) {\n\n\t\t\t\t\tvar key = item.ID + '-' + item.RELATION;\n\n\t\t\t\t\tif (tmp[key] || (relations && relations[item.RELATION] == null) || (!options.all && !item.INIT && !relations) || (relations && relations[item.RELATION] === item.TYPE))\n\t\t\t\t\t\treturn next();\n\n\t\t\t\t\ttmp[key] = 1;\n\n\t\t\t\t\tself.read(item.ID, function(err, doc, linkid) {\n\n\t\t\t\t\t\tif (doc && (!classes || classes[doc.CLASS])) {\n\n\t\t\t\t\t\t\tcount++;\n\n\t\t\t\t\t\t\tdoc.INDEX = item.INDEX;\n\t\t\t\t\t\t\tdoc.LEVEL = depth + 1;\n\t\t\t\t\t\t\tdoc.NODES = [];\n\n\t\t\t\t\t\t\tvar rel = self.$relations[item.RELATION];\n\n\t\t\t\t\t\t\tif (rel) {\n\t\t\t\t\t\t\t\t// doc.RELATION = rel.relation;\n\t\t\t\t\t\t\t\tdoc.RELATION = rel.name;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfil = filter.levels ? filter.levels[depth + 1] : null;\n\n\t\t\t\t\t\t\tif (fil) {\n\t\t\t\t\t\t\t\t!fil.response && (fil.response = parent.NODES);\n\t\t\t\t\t\t\t\tif (!framework_nosql.compare(fil, doc))\n\t\t\t\t\t\t\t\t\tlinkid = null;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tparent.NODES.push(doc);\n\n\t\t\t\t\t\t\tif (linkid && !tmp[linkid]) {\n\t\t\t\t\t\t\t\tpending.push({ id: linkid, parent: doc, depth: depth + 1 });\n\t\t\t\t\t\t\t\tsort = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\n\t\t\t\t}, process);\n\t\t\t});\n\t\t};\n\n\t\tvar process = function() {\n\n\t\t\tif (pending.length) {\n\n\t\t\t\t// because of seeking on HDD\n\t\t\t\tif (sort && pending.length > 1) {\n\t\t\t\t\tpending.quicksort('id');\n\t\t\t\t\tsort = false;\n\t\t\t\t}\n\n\t\t\t\tvar item = pending.shift();\n\t\t\t\treader(item.parent, item.id, item.depth);\n\n\t\t\t} else {\n\n\t\t\t\tif (filter.levels) {\n\t\t\t\t\tvar keys = Object.keys(filter.levels);\n\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\tvar f = filter.levels[keys[i]];\n\t\t\t\t\t\tframework_nosql.callback(f);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback(null, doc, count);\n\t\t\t}\n\t\t};\n\n\t\tlinkid && pending.push({ id: linkid, parent: doc, depth: 0 });\n\t\tprocess();\n\n\t}, options.type);\n\n\treturn filter;\n};\n\nfunction $find(self, cls, builder, reverse) {\n\n\tvar filter = {};\n\n\tfilter.builder = builder;\n\tfilter.scalarcount = 0;\n\tfilter.filter = builder.makefilter();\n\tfilter.compare = builder.compile();\n\tfilter.index = 0;\n\tfilter.count = 0;\n\tfilter.counter = 0;\n\tfilter.first = builder.$options.first && !builder.$options.sort;\n\n\tvar tmp = self.$classes[cls];\n\tif (!tmp) {\n\t\tframework_nosql.callback(filter, 'GraphDB: Class \"{0}\" is not registered.'.format(cls));\n\t\tsetImmediate(self.cb_next, NEXT_FIND);\n\t\treturn;\n\t}\n\n\tvar read = function(err, data) {\n\n\t\tif (err || (!data.count && !data.parent)) {\n\t\t\tframework_nosql.callback(filter);\n\t\t\treturn;\n\t\t}\n\n\t\tdata.documents(function(err, docs) {\n\t\t\tfor (var i = 0; i < docs.length; i++) {\n\t\t\t\tvar doc = docs[i];\n\t\t\t\tfilter.index++;\n\t\t\t\tif ((doc && framework_nosql.compare(filter, doc) === false) || (reverse && filter.done)) {\n\t\t\t\t\tframework_nosql.callback(filter);\n\t\t\t\t\tdata.next = null;\n\t\t\t\t\tdata.documents = null;\n\t\t\t\t\tdata = null;\n\t\t\t\t\tsetImmediate(self.cb_next, NEXT_FIND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata.next(read);\n\t\t});\n\t};\n\n\tself.cursor(1, tmp.name, read);\n}\n\nfunction parseSchema(schema) {\n\n\tvar obj = {};\n\tvar arr = schema.split('|').trim();\n\n\tobj.meta = {};\n\tobj.keys = [];\n\tobj.raw = schema;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar arg = arr[i].split(':');\n\t\tvar type = 0;\n\t\tswitch ((arg[1] || '').toLowerCase().trim()) {\n\t\t\tcase 'number':\n\t\t\t\ttype = 2;\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\tcase 'bool':\n\t\t\t\ttype = 3;\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\t\ttype = 4;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\ttype = 5;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\tdefault:\n\t\t\t\ttype = 1;\n\t\t\t\tbreak;\n\t\t}\n\t\tvar name = arg[0].trim();\n\t\tobj.meta[name] = { type: type, pos: i };\n\t\tobj.keys.push(name);\n\t}\n\n\treturn obj;\n}\n\nfunction stringifyData(schema, doc) {\n\n\tvar output = '';\n\tvar esc = false;\n\tvar size = 0;\n\n\tfor (var i = 0; i < schema.keys.length; i++) {\n\t\tvar key = schema.keys[i];\n\t\tvar meta = schema.meta[key];\n\t\tvar val = doc[key];\n\n\t\tswitch (meta.type) {\n\t\t\tcase 1: // String\n\t\t\t\tval = val ? val : '';\n\t\t\t\tsize += 4;\n\t\t\t\tbreak;\n\t\t\tcase 2: // Number\n\t\t\t\tval = (val || 0);\n\t\t\t\tsize += 2;\n\t\t\t\tbreak;\n\t\t\tcase 3: // Boolean\n\t\t\t\tval = (val == true ? '1' : '0');\n\t\t\t\tbreak;\n\t\t\tcase 4: // Date\n\t\t\t\t// val = val ? val.toISOString() : '';\n\t\t\t\tval = val ? val.getTime() : '';\n\t\t\t\t!val && (size += 13);\n\t\t\t\tbreak;\n\t\t\tcase 5: // Object\n\t\t\t\tval = val ? JSON.stringify(val) : '';\n\t\t\t\tsize += 4;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!esc && (meta.type === 1 || meta.type === 5)) {\n\t\t\tval += '';\n\t\t\tif (REGTESCAPETEST.test(val)) {\n\t\t\t\tesc = true;\n\t\t\t\tval = val.replace(REGTESCAPE, regtescape);\n\t\t\t}\n\t\t}\n\n\t\toutput += '|' + val;\n\t}\n\n\treturn (esc ? '*' : '+') + output;\n}\n\nfunction parseData(schema, lines, cache) {\n\n\tvar obj = {};\n\tvar esc = lines === '*';\n\tvar val;\n\n\tfor (var i = 0; i < schema.keys.length; i++) {\n\t\tvar key = schema.keys[i];\n\n\t\tif (cache && cache !== EMPTYOBJECT && cache[key] != null) {\n\t\t\tobj[key] = cache[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar meta = schema.meta[key];\n\t\tif (meta == null)\n\t\t\tcontinue;\n\n\t\tvar pos = meta.pos + 1;\n\n\t\tswitch (meta.type) {\n\t\t\tcase 1: // String\n\t\t\t\tobj[key] = lines[pos];\n\t\t\t\tif (esc && obj[key])\n\t\t\t\t\tobj[key] = obj[key].replace(REGTUNESCAPE, regtescapereverse);\n\t\t\t\tbreak;\n\t\t\tcase 2: // Number\n\t\t\t\tval = +lines[pos];\n\t\t\t\tobj[key] = val < 0 || val > 0 ? val : 0;\n\t\t\t\tbreak;\n\t\t\tcase 3: // Boolean\n\t\t\t\tval = lines[pos];\n\t\t\t\tobj[key] = BOOLEAN[val] == 1;\n\t\t\t\tbreak;\n\t\t\tcase 4: // Date\n\t\t\t\tval = lines[pos];\n\t\t\t\tobj[key] = val ? new Date(val[10] === 'T' ? val : +val) : null;\n\t\t\t\tbreak;\n\t\t\tcase 5: // Object\n\t\t\t\tval = lines[pos];\n\t\t\t\tif (esc && val)\n\t\t\t\t\tval = val.replace(REGTUNESCAPE, regtescapereverse);\n\t\t\t\tobj[key] = val ? val.parseJSON(true) : null;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn obj;\n}\n\nfunction regtescapereverse(c) {\n\tswitch (c) {\n\t\tcase '%0A':\n\t\t\treturn '\\n';\n\t\tcase '%0D':\n\t\t\treturn '\\r';\n\t\tcase '%7C':\n\t\t\treturn '|';\n\t}\n\treturn c;\n}\n\nfunction regtescape(c) {\n\tswitch (c) {\n\t\tcase '\\n':\n\t\t\treturn '%0A';\n\t\tcase '\\r':\n\t\t\treturn '%0D';\n\t\tcase '|':\n\t\t\treturn '%7C';\n\t}\n\treturn c;\n}\n\nexports.load = function(name, size) {\n\treturn new GraphDB(name, size);\n};\n\nexports.getImportantOperations = function() {\n\treturn IMPORTATOPERATIONS;\n};"
        },
        {
          "name": "helpers",
          "type": "tree",
          "content": null
        },
        {
          "name": "image.js",
          "type": "blob",
          "size": 17.1806640625,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkImage\n * @version 3.3.0\n */\n\n'use strict';\n\nconst sof = { 0xc0: true, 0xc1: true, 0xc2: true, 0xc3: true, 0xc5: true, 0xc6: true, 0xc7: true, 0xc9: true, 0xca: true, 0xcb: true, 0xcd: true, 0xce: true, 0xcf: true };\nconst child = require('child_process');\nconst exec = child.exec;\nconst spawn = child.spawn;\nconst Fs = require('fs');\nconst REGEXP_SVG = /(width=\"\\d+\")+|(height=\"\\d+\")+/g;\nconst REGEXP_PATH = /\\//g;\nconst REGEXP_ESCAPE = /'/g;\nconst SPAWN_OPT = { shell: true };\nconst D = require('os').platform().substring(0, 3).toLowerCase() === 'win' ? '\"' : '\\'';\nconst CMD_CONVERT = { gm: 'gm', im: 'convert', magick: 'magick' };\nconst CMD_CONVERT2 = { gm: 'gm convert', im: 'convert', magick: 'magick' };\nconst SUPPORTEDIMAGES = { jpg: 1, png: 1, gif: 1, apng: 1, jpeg: 1, heif: 1, heic: 1, webp: 1, ico: 1 };\n\nvar CACHE = {};\nvar middlewares = {};\n\nif (!global.framework_utils)\n\tglobal.framework_utils = require('./utils');\n\nfunction u16(buf, o) {\n\treturn buf[o] << 8 | buf[o + 1];\n}\n\nfunction u32(buf, o) {\n\treturn buf[o] << 24 | buf[o + 1] << 16 | buf[o + 2] << 8 | buf[o + 3];\n}\n\nexports.measureGIF = function(buffer) {\n\treturn { width: buffer.readInt16LE(6), height: buffer.readInt16LE(8) };\n};\n\n// MIT\n// Written by TJ Holowaychuk\n// visionmedia\nexports.measureJPG = function(buffer) {\n\n\tvar len = buffer.length;\n\tvar o = 0;\n\n\tvar jpeg = 0xff == buffer[0] && 0xd8 == buffer[1];\n\tif (jpeg) {\n\t\to += 2;\n\t\twhile (o < len) {\n\t\t\twhile (0xff != buffer[o]) o++;\n\t\t\twhile (0xff == buffer[o]) o++;\n\t\t\tif (sof[buffer[o]])\n\t\t\t\treturn { width: u16(buffer, o + 6), height: u16(buffer, o + 4) };\n\t\t\telse\n\t\t\t\to += u16(buffer, ++o);\n\n\t\t}\n\t}\n\n\treturn null;\n};\n\n// MIT\n// Written by TJ Holowaychuk\n// visionmedia\nexports.measurePNG = function(buffer) {\n\treturn { width: u32(buffer, 16), height: u32(buffer, 16 + 4) };\n};\n\nexports.measureSVG = function(buffer) {\n\n\tvar match = buffer.toString('utf8').match(REGEXP_SVG);\n\tif (!match)\n\t\treturn;\n\n\tvar width = 0;\n\tvar height = 0;\n\n\tfor (var i = 0, length = match.length; i < length; i++) {\n\t\tvar value = match[i];\n\n\t\tif (width > 0 && height > 0)\n\t\t\tbreak;\n\n\t\tif (!width && value.startsWith('width=\"'))\n\t\t\twidth = value.parseInt2();\n\n\t\tif (!height && value.startsWith('height=\"'))\n\t\t\theight = value.parseInt2();\n\t}\n\n\treturn { width: width, height: height };\n};\n\nexports.measure = function(type, buffer) {\n\tswitch (type) {\n\t\tcase '.jpg':\n\t\tcase '.jpeg':\n\t\tcase 'jpg':\n\t\tcase 'jpeg':\n\t\tcase 'image/jpeg':\n\t\t\treturn exports.measureJPG(buffer);\n\t\tcase '.gif':\n\t\tcase 'gif':\n\t\tcase 'image/gif':\n\t\t\treturn exports.measureGIF(buffer);\n\t\tcase '.png':\n\t\tcase 'png':\n\t\tcase 'image/png':\n\t\t\treturn exports.measurePNG(buffer);\n\t\tcase '.svg':\n\t\tcase 'svg':\n\t\tcase 'image/svg+xml':\n\t\t\treturn exports.measureSVG(buffer);\n\t}\n};\n\nfunction Image(filename, cmd, width, height) {\n\tvar type = typeof(filename);\n\tthis.width = width;\n\tthis.height = height;\n\tthis.builder = [];\n\tthis.filename = type === 'string' ? filename : null;\n\tthis.currentStream = type === 'object' ? filename : null;\n\tthis.outputType = type === 'string' ? framework_utils.getExtension(filename) : 'jpg';\n\tthis.islimit = false;\n\tthis.cmdarg = cmd || CONF.default_image_converter;\n}\n\nvar ImageProto = Image.prototype;\n\nImageProto.clear = function() {\n\tvar self = this;\n\tself.builder = [];\n\treturn self;\n};\n\nImageProto.measure = function(callback) {\n\n\tvar self = this;\n\tvar index = self.filename.lastIndexOf('.');\n\n\tif (!self.filename) {\n\t\tcallback(new Error('Measure does not support stream.'));\n\t\treturn;\n\t}\n\n\tif (index === -1) {\n\t\tcallback(new Error('This type of file is not supported.'));\n\t\treturn;\n\t}\n\n\tF.stats.performance.open++;\n\tvar extension = self.filename.substring(index).toLowerCase();\n\tvar stream = require('fs').createReadStream(self.filename, { start: 0, end: extension === '.jpg' ? 40000 : 24 });\n\n\tstream.on('data', function(buffer) {\n\n\t\tswitch (extension) {\n\t\t\tcase '.jpg':\n\t\t\t\tcallback(null, exports.measureJPG(buffer));\n\t\t\t\treturn;\n\t\t\tcase '.gif':\n\t\t\t\tcallback(null, exports.measureGIF(buffer));\n\t\t\t\treturn;\n\t\t\tcase '.png':\n\t\t\t\tcallback(null, exports.measurePNG(buffer));\n\t\t\t\treturn;\n\t\t}\n\n\t\tcallback(new Error('This type of file is not supported.'));\n\t});\n\n\tstream.on('error', callback);\n\treturn self;\n};\n\nImageProto.$$measure = function() {\n\tvar self = this;\n\treturn function(callback) {\n\t\tself.measure(callback);\n\t};\n};\n\n/**\n * Execute commands\n * @param {String} filename\n * @param {Function(err, filename)} callback Optional.\n * @param {Function(stream)} writer A custom stream writer, optional.\n * @return {Image}\n */\nImageProto.save = function(filename, callback, writer) {\n\n\tvar self = this;\n\n\tif (typeof(filename) === 'function') {\n\t\tcallback = filename;\n\t\tfilename = null;\n\t}\n\n\t!self.builder.length && self.minify();\n\tfilename = filename || self.filename || '';\n\n\tvar command = self.cmd(self.filename ? self.filename : '-', filename);\n\n\tif (F.isWindows)\n\t\tcommand = command.replace(REGEXP_PATH, '\\\\');\n\n\tvar cmd = exec(command, function(err) {\n\n\t\t// clean up\n\t\tcmd.kill();\n\t\tcmd = null;\n\n\t\tself.clear();\n\n\t\tif (!callback)\n\t\t\treturn;\n\n\t\tif (err) {\n\t\t\tcallback(err, false);\n\t\t\treturn;\n\t\t}\n\n\t\tvar middleware = middlewares[self.outputType];\n\t\tif (!middleware)\n\t\t\treturn callback(null, true);\n\n\t\tF.stats.performance.open++;\n\t\tvar reader = Fs.createReadStream(filename);\n\t\tvar writer = Fs.createWriteStream(filename + '_');\n\n\t\treader.pipe(middleware()).pipe(writer);\n\t\twriter.on('finish', () => Fs.rename(filename + '_', filename, () => callback(null, true)));\n\t});\n\n\tif (self.currentStream) {\n\t\tif (self.currentStream instanceof Buffer)\n\t\t\tcmd.stdin.end(self.currentStream);\n\t\telse\n\t\t\tself.currentStream.pipe(cmd.stdin);\n\t}\n\n\tCLEANUP(cmd.stdin);\n\twriter && writer(cmd.stdin);\n\treturn self;\n};\n\nImageProto.$$save = function(filename, writer) {\n\tvar self = this;\n\treturn function(callback) {\n\t\tself.save(filename, callback, writer);\n\t};\n};\n\nImageProto.pipe = function(stream, type, options) {\n\n\tvar self = this;\n\n\tif (typeof(type) === 'object') {\n\t\toptions = type;\n\t\ttype = null;\n\t}\n\n\t!self.builder.length && self.minify();\n\n\tif (!type || !SUPPORTEDIMAGES[type])\n\t\ttype = self.outputType;\n\n\tF.stats.performance.open++;\n\tvar cmd = spawn(CMD_CONVERT[self.cmdarg], self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-'), SPAWN_OPT);\n\tcmd.stderr.on('data', stream.emit.bind(stream, 'error'));\n\tcmd.stdout.on('data', stream.emit.bind(stream, 'data'));\n\tcmd.stdout.on('end', stream.emit.bind(stream, 'end'));\n\tcmd.on('error', stream.emit.bind(stream, 'error'));\n\n\tvar middleware = middlewares[type];\n\tif (middleware)\n\t\tcmd.stdout.pipe(middleware()).pipe(stream, options);\n\telse\n\t\tcmd.stdout.pipe(stream, options);\n\n\tif (self.currentStream) {\n\t\tif (self.currentStream instanceof Buffer)\n\t\t\tcmd.stdin.end(self.currentStream);\n\t\telse\n\t\t\tself.currentStream.pipe(cmd.stdin);\n\t}\n\n\treturn self;\n};\n\n/**\n * Create a stream\n * @param {String} type File type (png, jpg, gif)\n * @param {Function(stream)} writer A custom stream writer.\n * @return {ReadStream}\n */\nImageProto.stream = function(type, writer) {\n\n\tvar self = this;\n\n\t!self.builder.length && self.minify();\n\n\tif (!type || !SUPPORTEDIMAGES[type])\n\t\ttype = self.outputType;\n\n\tF.stats.performance.open++;\n\tvar cmd = spawn(CMD_CONVERT[self.cmdarg], self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-'), SPAWN_OPT);\n\tif (self.currentStream) {\n\t\tif (self.currentStream instanceof Buffer)\n\t\t\tcmd.stdin.end(self.currentStream);\n\t\telse\n\t\t\tself.currentStream.pipe(cmd.stdin);\n\t}\n\n\twriter && writer(cmd.stdin);\n\tvar middleware = middlewares[type];\n\treturn middleware ? cmd.stdout.pipe(middleware()) : cmd.stdout;\n};\n\nImageProto.cmd = function(filenameFrom, filenameTo) {\n\n\tvar self = this;\n\tvar cmd = '';\n\n\tif (!self.islimit) {\n\t\tvar tmp = CONF.default_image_consumption;\n\t\tif (tmp) {\n\t\t\tself.limit('memory', (1500 / 100) * tmp);\n\t\t\tself.limit('map', (3000 / 100) * tmp);\n\t\t}\n\t}\n\n\tself.builder.sort(sort);\n\n\tvar length = self.builder.length;\n\tfor (var i = 0; i < length; i++)\n\t\tcmd += (cmd ? ' ' : '') + self.builder[i].cmd;\n\n\treturn CMD_CONVERT2[self.cmdarg] + wrap(filenameFrom, true) + ' ' + cmd + wrap(filenameTo, true);\n};\n\nfunction sort(a, b) {\n\treturn a.priority > b.priority ? 1 : -1;\n}\n\nImageProto.arg = function(first, last) {\n\n\tvar self = this;\n\tvar arr = [];\n\n\tif (self.cmdarg === 'gm')\n\t\tarr.push('convert');\n\n\tfirst && arr.push(first);\n\n\tif (!self.islimit) {\n\t\tvar tmp = CONF.default_image_consumption;\n\t\tif (tmp) {\n\t\t\tself.limit('memory', (1500 / 100) * tmp);\n\t\t\tself.limit('map', (3000 / 100) * tmp);\n\t\t}\n\t}\n\n\tself.builder.sort(sort);\n\n\tvar length = self.builder.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar o = self.builder[i];\n\t\tvar index = o.cmd.indexOf(' ');\n\t\tif (index === -1)\n\t\t\tarr.push(o.cmd);\n\t\telse {\n\t\t\tarr.push(o.cmd.substring(0, index));\n\t\t\tarr.push(o.cmd.substring(index + 1).replace(/\"/g, ''));\n\t\t}\n\t}\n\n\tlast && arr.push(last);\n\treturn arr;\n};\n\nImageProto.identify = function(callback) {\n\tvar self = this;\n\tF.stats.performance.open++;\n\texec((self.cmdarg === 'gm' ? 'gm ' : '') + 'identify' + wrap(self.filename, true), function(err, stdout) {\n\n\t\tif (err) {\n\t\t\tcallback(err, null);\n\t\t\treturn;\n\t\t}\n\n\t\tvar arr = stdout.split(' ');\n\t\tvar size = arr[2].split('x');\n\t\tvar obj = { type: arr[1], width: framework_utils.parseInt(size[0]), height: framework_utils.parseInt(size[1]) };\n\t\tcallback(null, obj);\n\t});\n\n\treturn self;\n};\n\nImageProto.$$identify = function() {\n\tvar self = this;\n\treturn function(callback) {\n\t\tself.identify(callback);\n\t};\n};\n\nImageProto.push = function(key, value, priority, encode) {\n\tvar self = this;\n\tvar cmd = key;\n\n\tif (value != null) {\n\t\tif (encode && typeof(value) === 'string')\n\t\t\tcmd += ' ' + D + value.replace(REGEXP_ESCAPE, '') + D;\n\t\telse\n\t\t\tcmd += ' ' + value;\n\t}\n\n\tvar obj = CACHE[cmd];\n\tif (obj) {\n\t\tobj.priority = priority;\n\t\tself.builder.push(obj);\n\t} else {\n\t\tCACHE[cmd] = { cmd: cmd, priority: priority };\n\t\tself.builder.push(CACHE[cmd]);\n\t}\n\n\treturn self;\n};\n\nImageProto.output = function(type) {\n\tvar self = this;\n\tif (type[0] === '.')\n\t\ttype = type.substring(1);\n\tself.outputType = type;\n\treturn self;\n};\n\nImageProto.resize = function(w, h, options) {\n\toptions = options || '';\n\n\tvar self = this;\n\tvar size = '';\n\n\tif (w && h)\n\t\tsize = w + 'x' + h;\n\telse if (w && !h)\n\t\tsize = w + 'x';\n\telse if (!w && h)\n\t\tsize = 'x' + h;\n\n\treturn self.push('-resize', size + options, 1, true);\n};\n\nImageProto.thumbnail = function(w, h, options) {\n\toptions = options || '';\n\n\tvar self = this;\n\tvar size = '';\n\n\tif (w && h)\n\t\tsize = w + 'x' + h;\n\telse if (w && !h)\n\t\tsize = w;\n\telse if (!w && h)\n\t\tsize = 'x' + h;\n\n\treturn self.push('-thumbnail', size + options, 1, true);\n};\n\nImageProto.geometry = function(w, h, options) {\n\toptions = options || '';\n\n\tvar self = this;\n\tvar size = '';\n\n\tif (w && h)\n\t\tsize = w + 'x' + h;\n\telse if (w && !h)\n\t\tsize = w;\n\telse if (!w && h)\n\t\tsize = 'x' + h;\n\n\treturn self.push('-geometry', size + options, 1, true);\n};\n\n\nImageProto.filter = function(type) {\n\treturn this.push('-filter', type, 1, true);\n};\n\nImageProto.trim = function() {\n\treturn this.push('-trim +repage', 1);\n};\n\nImageProto.limit = function(type, value) {\n\tthis.islimit = true;\n\treturn this.push('-limit', type + ' ' + value, 1);\n};\n\nImageProto.extent = function(w, h, x, y) {\n\n\tvar self = this;\n\tvar size = '';\n\n\tif (w && h)\n\t\tsize = w + 'x' + h;\n\telse if (w && !h)\n\t\tsize = w;\n\telse if (!w && h)\n\t\tsize = 'x' + h;\n\n\tif (x || y) {\n\t\t!x && (x = 0);\n\t\t!y && (y = 0);\n\t\tsize += (x >= 0 ? '+' : '') + x + (y >= 0 ? '+' : '') + y;\n\t}\n\n\treturn self.push('-extent', size, 4, true);\n};\n\n/**\n * Resize picture to miniature (full picture)\n * @param {Number} w\n * @param {Number} h\n * @param {String} color Optional, background color.\n * @param {String} filter Optional, resize filter (default: Box)\n * @return {Image}\n */\nImageProto.miniature = function(w, h, color, filter) {\n\treturn this.filter(filter || 'Hamming').thumbnail(w, h).background(color ? color : 'white').align('center').extent(w, h);\n};\n\n/**\n * Resize picture to center\n * @param {Number} w\n * @param {Number} h\n * @param {String} color Optional, background color.\n * @return {Image}\n */\nImageProto.resizeCenter = ImageProto.resize_center = function(w, h, color) {\n\treturn this.resize(w, h, '^').background(color ? color : 'white').align('center').crop(w, h);\n};\n\n/**\n * Resize picture to align\n * @param {Number} w\n * @param {Number} h\n * @param {String} align (top, center, bottom)\n * @param {String} color Optional, background color.\n * @return {Image}\n */\nImageProto.resizeAlign = ImageProto.resize_align = function(w, h, align, color) {\n\treturn this.resize(w, h, '^').background(color ? color : 'white').align(align || 'center').crop(w, h);\n};\n\nImageProto.scale = function(w, h, options) {\n\toptions = options || '';\n\n\tvar self = this;\n\tvar size = '';\n\n\tif (w && h)\n\t\tsize = w + 'x' + h;\n\telse if (w && !h)\n\t\tsize = w;\n\telse if (!w && h)\n\t\tsize = 'x' + h;\n\n\treturn self.push('-scale', size + options, 1, true);\n};\n\nImageProto.crop = function(w, h, x, y) {\n\treturn this.push('-crop', w + 'x' + h + '+' + (x || 0) + '+' + (y || 0), 4, true);\n};\n\nImageProto.quality = function(percentage) {\n\treturn this.push('-quality', percentage || 80, 5, true);\n};\n\nImageProto.align = function(type) {\n\n\tvar output;\n\n\tswitch (type) {\n\t\tcase 'left top':\n\t\tcase 'top left':\n\t\t\toutput = 'NorthWest';\n\t\t\tbreak;\n\t\tcase 'left bottom':\n\t\tcase 'bottom left':\n\t\t\toutput = 'SouthWest';\n\t\t\tbreak;\n\t\tcase 'right top':\n\t\tcase 'top right':\n\t\t\toutput = 'NorthEast';\n\t\t\tbreak;\n\t\tcase 'right bottom':\n\t\tcase 'bottom right':\n\t\t\toutput = 'SouthEast';\n\t\t\tbreak;\n\t\tcase 'left center':\n\t\tcase 'center left':\n\t\tcase 'left':\n\t\t\toutput = 'West';\n\t\t\tbreak;\n\t\tcase 'right center':\n\t\tcase 'center right':\n\t\tcase 'right':\n\t\t\toutput = 'East';\n\t\t\tbreak;\n\t\tcase 'bottom center':\n\t\tcase 'center bottom':\n\t\tcase 'bottom':\n\t\t\toutput = 'South';\n\t\t\tbreak;\n\t\tcase 'top center':\n\t\tcase 'center top':\n\t\tcase 'top':\n\t\t\toutput = 'North';\n\t\t\tbreak;\n\t\tcase 'center center':\n\t\tcase 'center':\n\t\tcase 'middle':\n\t\t\toutput = 'Center';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutput = type;\n\t\t\tbreak;\n\t}\n\n\toutput && this.push('-gravity', output, 3, true);\n\treturn this;\n};\n\nImageProto.gravity = function(type) {\n\treturn this.align(type);\n};\n\nImageProto.blur = function(radius) {\n\treturn this.push('-blur', radius, 10, true);\n};\n\nImageProto.normalize = function() {\n\treturn this.push('-normalize', null, 10);\n};\n\nImageProto.rotate = function(deg) {\n\treturn this.push('-rotate', deg || 0, 8, true);\n};\n\nImageProto.flip = function() {\n\treturn this.push('-flip', null, 10);\n};\n\nImageProto.flop = function() {\n\treturn this.push('-flop', null, 10);\n};\n\nImageProto.define = function(value) {\n\treturn this.push('-define', value, 10, true);\n};\n\nImageProto.minify = function() {\n\treturn this.push('+profile', '*', null, 10, true);\n};\n\nImageProto.grayscale = function() {\n\treturn this.push('-colorspace', 'Gray', 10, true);\n};\n\nImageProto.bitdepth = function(value) {\n\treturn this.push('-depth', value, 10, true);\n};\n\nImageProto.colors = function(value) {\n\treturn this.push('-colors', value, 10, true);\n};\n\nImageProto.background = function(color) {\n\treturn this.push('-background', color, 2, true).push('-extent 0x0', null, 2);\n};\n\nImageProto.fill = function(color) {\n\treturn this.push('-fill', color, 2, true);\n};\n\nImageProto.sepia = function() {\n\treturn this.push('-modulate', '115,0,100', 4).push('-colorize', '7,21,50', 5);\n};\n\nImageProto.watermark = function(filename, x, y, w, h) {\n\treturn this.push('-draw', 'image over {1},{2} {3},{4} {5}{0}{5}'.format(filename, x || 0, y || 0, w || 0, h || 0, D), 6, true);\n};\n\nImageProto.make = function(fn) {\n\tfn.call(this, this);\n\treturn this;\n};\n\nImageProto.command = function(key, value, priority, esc) {\n\n\tif (priority === true) {\n\t\tpriority = 0;\n\t\tesc = true;\n\t}\n\n\treturn this.push(key, value, priority || 10, esc);\n};\n\nfunction wrap(command, empty) {\n\treturn (empty ? ' ' : '') + (command === '-' ? command : (D + command.replace(REGEXP_ESCAPE, '') + D));\n}\n\nexports.Image = Image;\nexports.Picture = Image;\n\nexports.init = function(filename, cmd, width, height) {\n\treturn new Image(filename, cmd, width, height);\n};\n\nexports.load = function(filename, cmd, width, height) {\n\treturn new Image(filename, cmd, width, height);\n};\n\nexports.middleware = function(type, fn) {\n\tif (type[0] === '.')\n\t\ttype = type.substring(1);\n\tmiddlewares[type] = fn;\n};\n\n// Clears cache with commands\nexports.clear = function() {\n\tCACHE = {};\n};\n\nglobal.Image = exports;\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 484.9267578125,
          "content": "// Copyright 2012-2021 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module Framework\n * @version 3.4.13\n */\n\n'use strict';\n\nconst Qs = require('querystring');\nconst Os = require('os');\nconst Fs = require('fs');\nconst Zlib = require('zlib');\nconst Path = require('path');\nconst Crypto = require('crypto');\nconst Parser = require('url');\nconst Child = require('child_process');\nconst Util = require('util');\nconst http = require('http');\n\nconst ENCODING = 'utf8';\nconst HEADER_CACHE = 'Cache-Control';\nconst HEADER_TYPE = 'Content-Type';\nconst HEADER_LENGTH = 'Content-Length';\nconst CT_TEXT = 'text/plain';\nconst CT_HTML = 'text/html';\nconst CT_JSON = 'application/json';\nconst COMPRESSION = { 'text/plain': true, 'text/javascript': true, 'text/css': true, 'text/jsx': true, 'application/javascript': true, 'application/x-javascript': true, 'application/json': true, 'text/xml': true, 'image/svg+xml': true, 'text/x-markdown': true, 'text/html': true };\nconst COMPRESSIONSPECIAL = { js: 1, css: 1, mjs: 1 };\nconst RESPONSENOCACHE = { zip: 1, rar: 1 };\nconst REG_TEMPORARY = /\\//g;\nconst REG_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|Tablet/i;\nconst REG_ROBOT = /search|agent|bot|crawler|spider/i;\nconst REG_VERSIONS = /(href|src)=\"[a-zA-Z0-9/:\\-._]+\\.(jpg|js|css|png|apng|gif|svg|html|ico|json|less|sass|scss|swf|txt|webp|heif|heic|jpeg|woff|woff2|xls|xlsx|xml|xsl|xslt|zip|rar|csv|doc|docx|eps|gzip|jpe|jpeg|manifest|mov|mp3|flac|mp4|ogg|package|pdf)\"/gi;\nconst REG_COMPILECSS = /url\\(.*?\\)/g;\nconst REG_ROUTESTATIC = /^(\\/\\/|https:|http:)+/;\nconst REG_NEWIMPL = /^(async\\s)?function(\\s)?([a-zA-Z$][a-zA-Z0-9$]+)?(\\s)?\\([a-zA-Z0-9$]+\\)|^function anonymous\\(\\$/;\nconst REG_RANGE = /bytes=/;\nconst REG_EMPTY = /\\s/g;\nconst REG_ACCEPTCLEANER = /\\s|\\./g;\nconst REG_SANITIZE_BACKSLASH = /\\/\\//g;\nconst REG_WEBSOCKET_ERROR = /ECONNRESET|EHOSTUNREACH|EPIPE|is closed/i;\nconst REG_WINDOWSPATH = /\\\\/g;\nconst REG_SCRIPTCONTENT = /<|>|;/;\nconst REG_HTTPHTTPS = /^(\\/)?(http|https):\\/\\//i;\nconst REG_NOCOMPRESS = /[.|-]+min(@[a-z0-9]*)?\\.(css|js)$/i;\nconst REG_WWW = /^www\\./i;\nconst REG_TEXTAPPLICATION = /text|application/;\nconst REG_ENCODINGCLEANER = /[;\\s]charset=utf-8/g;\nconst REG_SKIPERROR = /epipe|invalid\\sdistance/i;\nconst REG_OLDCONF = /-/g;\nconst REG_UTF8 = /[^\\x20-\\x7E]+/;\nconst REG_ENCODEDSPACE = /\\+/g;\nconst FLAGS_INSTALL = ['get'];\nconst FLAGS_DOWNLOAD = ['get', 'dnscache'];\nconst QUERYPARSEROPTIONS = { maxKeys: 33 };\nconst EMPTYARRAY = [];\nconst EMPTYOBJECT = {};\nconst EMPTYREQUEST = { uri: {} };\nconst SINGLETONS = {};\nconst REPOSITORY_HEAD = '$head';\nconst REPOSITORY_META_TITLE = '$title';\nconst REPOSITORY_META_DESCRIPTION = '$description';\nconst REPOSITORY_META_KEYWORDS = '$keywords';\nconst REPOSITORY_META_AUTHOR = '$author';\nconst REPOSITORY_META_IMAGE = '$image';\nconst REPOSITORY_PLACE = '$place';\nconst REPOSITORY_SITEMAP = '$sitemap';\nconst REPOSITORY_COMPONENTS = '$components';\nconst ATTR_END = '\"';\nconst ETAG = '858';\nconst CONCAT = [null, null];\nconst CLUSTER_CACHE_SET = { TYPE: 'cache', method: 'set' };\nconst CLUSTER_CACHE_REMOVE = { TYPE: 'cache', method: 'remove' };\nconst CLUSTER_CACHE_REMOVEALL = { TYPE: 'cache', method: 'removeAll' };\nconst CLUSTER_CACHE_CLEAR = { TYPE: 'cache', method: 'clear' };\nconst CLUSTER_SNAPSHOT = { TYPE: 'snapshot' };\nconst GZIPFILE = { memLevel: 9 };\nconst GZIPSTREAM = { memLevel: 1 };\nconst MODELERROR = {};\nconst IMAGES = { jpg: 1, png: 1, gif: 1, apng: 1, jpeg: 1, heif: 1, heic: 1, webp: 1 };\nconst KEYSLOCALIZE = { html: 1, htm: 1 };\nconst PROXYOPTIONS = { end: true };\nconst PROXYKEEPALIVE = new http.Agent({ keepAlive: true, timeout: 60000 });\nconst JSFILES = { js: 1, mjs: 1 };\nvar PREFFILE = 'preferences.json';\n\nvar PATHMODULES = require.resolve('./index');\nPATHMODULES = PATHMODULES.substring(0, PATHMODULES.length - 8);\n\nObject.freeze(EMPTYOBJECT);\nObject.freeze(EMPTYARRAY);\nObject.freeze(EMPTYREQUEST);\n\nglobal.EMPTYOBJECT = EMPTYOBJECT;\nglobal.EMPTYARRAY = EMPTYARRAY;\nglobal.NOW = new Date();\nglobal.THREAD = '';\nglobal.isWORKER = false;\nglobal.REQUIRE = function(path) {\n\treturn require(F.directory + '/' + path);\n};\n\nfunction flowwrapper(name) {\n\tif (!name)\n\t\tname = 'default';\n\tif (F.flows[name])\n\t\treturn F.flows[name];\n\tvar flow = new framework_flow.make(name);\n\treturn F.flows[name] = flow;\n}\n\nglobal.FLOWSTREAM = function(name) {\n\tglobal.framework_flow = require('./flow');\n\tglobal.FLOW = flowwrapper;\n\treturn flowwrapper(name);\n};\n\nvar DEF = global.DEF = {};\n\nDEF.currencies = {};\n\nvar PROTORES, PROTOREQ;\n\nvar RANGE = { start: 0, end: 0 };\nvar HEADERS = {};\nvar SUCCESSHELPER = { success: true };\n\n// Cached headers for repeated usage\nHEADERS.responseCode = {};\nHEADERS.responseCode[HEADER_TYPE] = CT_TEXT;\nHEADERS.redirect = {};\nHEADERS.redirect[HEADER_TYPE] = CT_HTML + '; charset=utf-8';\nHEADERS.redirect[HEADER_LENGTH] = '0';\nHEADERS.sse = {};\nHEADERS.sse[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.sse['Pragma'] = 'no-cache';\nHEADERS.sse['Expires'] = '-1';\nHEADERS.sse[HEADER_TYPE] = 'text/event-stream';\nHEADERS.sse['X-Powered-By'] = 'Total.js';\nHEADERS.file_lastmodified = {};\nHEADERS.file_lastmodified['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_lastmodified[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_lastmodified['X-Powered-By'] = 'Total.js';\nHEADERS.file_release_compress = {};\nHEADERS.file_release_compress[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_compress['Vary'] = 'Accept-Encoding';\nHEADERS.file_release_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release_compress['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_compress['Content-Encoding'] = 'gzip';\nHEADERS.file_release_compress['X-Powered-By'] = 'Total.js';\nHEADERS.file_release_compress_range = {};\nHEADERS.file_release_compress_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_release_compress_range[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_compress_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_release_compress_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release_compress_range['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_compress_range['Content-Encoding'] = 'gzip';\nHEADERS.file_release_compress_range[HEADER_LENGTH] = '0';\nHEADERS.file_release_compress_range['Content-Range'] = '';\nHEADERS.file_release_compress_range['X-Powered-By'] = 'Total.js';\nHEADERS.file_release = {};\nHEADERS.file_release[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release['Vary'] = 'Accept-Encoding';\nHEADERS.file_release['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release['X-Powered-By'] = 'Total.js';\nHEADERS.file_release_range = {};\nHEADERS.file_release_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_release_range[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.file_release_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_release_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_release_range['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\nHEADERS.file_release_range[HEADER_LENGTH] = '0';\nHEADERS.file_release_range['Content-Range'] = '';\nHEADERS.file_release_range['X-Powered-By'] = 'Total.js';\nHEADERS.file_debug_compress = {};\nHEADERS.file_debug_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug_compress['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_compress['Pragma'] = 'no-cache';\nHEADERS.file_debug_compress['Expires'] = '-1';\nHEADERS.file_debug_compress['Content-Encoding'] = 'gzip';\nHEADERS.file_debug_compress['X-Powered-By'] = 'Total.js';\nHEADERS.file_debug_compress_range = {};\nHEADERS.file_debug_compress_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_debug_compress_range[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug_compress_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug_compress_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_compress_range['Content-Encoding'] = 'gzip';\nHEADERS.file_debug_compress_range['Pragma'] = 'no-cache';\nHEADERS.file_debug_compress_range['Expires'] = '-1';\nHEADERS.file_debug_compress_range[HEADER_LENGTH] = '0';\nHEADERS.file_debug_compress_range['Content-Range'] = '';\nHEADERS.file_debug_compress_range['X-Powered-By'] = 'Total.js';\nHEADERS.file_debug = {};\nHEADERS.file_debug[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug['Pragma'] = 'no-cache';\nHEADERS.file_debug['Expires'] = '-1';\nHEADERS.file_debug['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug['X-Powered-By'] = 'Total.js';\nHEADERS.file_debug_range = {};\nHEADERS.file_debug_range['Accept-Ranges'] = 'bytes';\nHEADERS.file_debug_range[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.file_debug_range['Vary'] = 'Accept-Encoding';\nHEADERS.file_debug_range['Access-Control-Allow-Origin'] = '*';\nHEADERS.file_debug_range['Pragma'] = 'no-cache';\nHEADERS.file_debug_range['Expires'] = '-1';\nHEADERS.file_debug_range[HEADER_LENGTH] = '0';\nHEADERS.file_debug_range['Content-Range'] = '';\nHEADERS.file_debug_range['X-Powered-By'] = 'Total.js';\nHEADERS.content_mobile_release = {};\nHEADERS.content_mobile_release[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content_mobile_release['Vary'] = 'Accept-Encoding, User-Agent';\nHEADERS.content_mobile_release['Content-Encoding'] = 'gzip';\nHEADERS.content_mobile_release['Expires'] = '-1';\nHEADERS.content_mobile_release['X-Powered-By'] = 'Total.js';\nHEADERS.content_mobile = {};\nHEADERS.content_mobile[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content_mobile['Vary'] = 'Accept-Encoding, User-Agent';\nHEADERS.content_mobile['Expires'] = '-1';\nHEADERS.content_mobile['X-Powered-By'] = 'Total.js';\nHEADERS.content_compress = {};\nHEADERS.content_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content_compress['Vary'] = 'Accept-Encoding';\nHEADERS.content_compress['Content-Encoding'] = 'gzip';\nHEADERS.content_compress['Expires'] = '-1';\nHEADERS.content_compress['X-Powered-By'] = 'Total.js';\nHEADERS.content = {};\nHEADERS.content[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.content['Vary'] = 'Accept-Encoding';\nHEADERS.content['Expires'] = '-1';\nHEADERS.content['X-Powered-By'] = 'Total.js';\nHEADERS.stream_release_compress = {};\nHEADERS.stream_release_compress[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.stream_release_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_release_compress['Content-Encoding'] = 'gzip';\nHEADERS.stream_release_compress['X-Powered-By'] = 'Total.js';\nHEADERS.stream_release = {};\nHEADERS.stream_release[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.stream_release['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_release['X-Powered-By'] = 'Total.js';\nHEADERS.stream_debug_compress = {};\nHEADERS.stream_debug_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.stream_debug_compress['Pragma'] = 'no-cache';\nHEADERS.stream_debug_compress['Expires'] = '-1';\nHEADERS.stream_debug_compress['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_debug_compress['Content-Encoding'] = 'gzip';\nHEADERS.stream_debug_compress['X-Powered-By'] = 'Total.js';\nHEADERS.stream_debug = {};\nHEADERS.stream_debug[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.stream_debug['Pragma'] = 'no-cache';\nHEADERS.stream_debug['Expires'] = '-1';\nHEADERS.stream_debug['Access-Control-Allow-Origin'] = '*';\nHEADERS.stream_debug['X-Powered-By'] = 'Total.js';\nHEADERS.binary_compress = {};\nHEADERS.binary_compress[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.binary_compress['Content-Encoding'] = 'gzip';\nHEADERS.binary_compress['X-Powered-By'] = 'Total.js';\nHEADERS.binary = {};\nHEADERS.binary[HEADER_CACHE] = 'public';\nHEADERS.binary['X-Powered-By'] = 'Total.js';\nHEADERS.authorization = { user: '', password: '', empty: true };\nHEADERS.fsStreamRead = { flags: 'r', mode: '0666', autoClose: true };\nHEADERS.fsStreamReadRange = { flags: 'r', mode: '0666', autoClose: true, start: 0, end: 0 };\nHEADERS.responseLocalize = {};\nHEADERS.responseLocalize['Access-Control-Allow-Origin'] = '*';\nHEADERS.responseNotModified = {};\nHEADERS.responseNotModified[HEADER_CACHE] = 'public, max-age=11111111';\nHEADERS.responseNotModified['X-Powered-By'] = 'Total.js';\nHEADERS.response503 = {};\nHEADERS.response503[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.response503[HEADER_TYPE] = CT_HTML;\nHEADERS.response503['X-Powered-By'] = 'Total.js';\nHEADERS.response503ddos = {};\nHEADERS.response503ddos[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\nHEADERS.response503ddos[HEADER_TYPE] = CT_TEXT;\nHEADERS.response503ddos['X-Powered-By'] = 'Total.js';\n\nObject.freeze(HEADERS.authorization);\n\nvar _controller = '';\nvar _owner = '';\nvar _flags;\nvar _prefix;\n\n// GO ONLINE MODE\n!global.framework_internal && (global.framework_internal = require('./internal'));\n!global.framework_builders && (global.framework_builders = require('./builders'));\n!global.framework_utils && (global.framework_utils = require('./utils'));\n!global.framework_mail && (global.framework_mail = require('./mail'));\n!global.framework_image && (global.framework_image = require('./image'));\n!global.framework_session && (global.framework_session = require('./session'));\n\nrequire('./tangular');\n\nfunction sessionwrapper(name) {\n\tif (!name)\n\t\tname = 'default';\n\tif (F.sessions[name])\n\t\treturn F.sessions[name];\n\tvar session = new framework_session.Session(name);\n\tsession.load();\n\tif (F.sessionscount)\n\t\tF.sessionscount++;\n\telse\n\t\tF.sessionscount = 1;\n\treturn F.sessions[name] = session;\n}\n\nglobal.SESSION = function(name) {\n\tglobal.framework_session = require('./session');\n\tglobal.SESSION = sessionwrapper;\n\treturn sessionwrapper(name);\n};\n\nvar TMPENV = framework_utils.copy(process.env);\nTMPENV.istotaljsworker = true;\n\nHEADERS.workers = { cwd: '', silent: false, env: TMPENV };\nHEADERS.workers2 = { cwd: '', silent: true, env: TMPENV };\n\nglobal.Builders = framework_builders;\nvar U = global.Utils = global.utils = global.U = global.framework_utils;\nglobal.Mail = framework_mail;\n\nglobal.WTF = (message, name, uri) => F.problem(message, name, uri);\nglobal.NOBIN = global.NOSQLBINARY = (name) => F.nosql(name).binary;\nglobal.NOSQLSTORAGE = (name) => F.nosql(name).storage;\nglobal.NOCOUNTER = global.NOSQLCOUNTER = (name) => F.nosql(name).counter;\n\nfunction nomemwrapper(name) {\n\treturn global.framework_nosql.inmemory(name);\n}\n\nglobal.NOMEM = global.NOSQLMEMORY = function(name) {\n\tif (!global.framework_nosql)\n\t\tglobal.framework_nosql = require('./nosql');\n\tglobal.NOMEM = global.NOSQLMEMORY = global.framework_nosql.inmemory;\n\treturn nomemwrapper(name);\n};\n\nglobal.CONFIG = function(name, val) {\n\treturn arguments.length === 1 ? CONF[name] : (CONF[name] = val);\n};\n\nvar prefid;\n\nglobal.PREF = {};\nglobal.PREF.set = function(name, value) {\n\n\tif (value === undefined)\n\t\treturn F.pref[name];\n\n\tif (value === null) {\n\t\tdelete F.pref[name];\n\t} else\n\t\tF.pref[name] = global.PREF[name] = value;\n\n\tprefid && clearTimeout(prefid);\n\tprefid = setTimeout(F.onPrefSave, 1000, F.pref);\n};\n\nglobal.CACHE = function(name, value, expire, persistent) {\n\treturn arguments.length === 1 ? F.cache.get2(name) : F.cache.set(name, value, expire, persistent);\n};\n\nglobal.CREATE = (group, name) => framework_builders.getschema(group, name).default();\nglobal.SINGLETON = (name, def) => SINGLETONS[name] || (SINGLETONS[name] = (new Function('return ' + (def || '{}')))());\nglobal.FUNCTION = (name) => F.functions[name] || NOOP;\nglobal.FINISHED = framework_internal.onFinished;\nglobal.DESTROY = framework_internal.destroyStream;\n\nfunction filestoragewrapper(name) {\n\tvar key = 'storage_' + name;\n\treturn F.databases[key] ? F.databases[key] : (F.databases[key] = new framework_nosql.DatabaseBinary({ name: name }, F.path.databases('fs-' + name + '/'), '.file'));\n}\n\nglobal.FILESTORAGE = function(name) {\n\tif (!global.framework_nosql)\n\t\tglobal.framework_nosql = require('./nosql');\n\tglobal.FILESTORAGE = filestoragewrapper;\n\treturn filestoragewrapper(name);\n};\n\nglobal.UID16 = function(type) {\n\tvar index;\n\tif (type) {\n\t\tif (UIDGENERATOR.types[type])\n\t\t\tindex = UIDGENERATOR.types[type] = UIDGENERATOR.types[type] + 1;\n\t\telse {\n\t\t\tUIDGENERATOR.multiple = true;\n\t\t\tindex = UIDGENERATOR.types[type] = 1;\n\t\t}\n\t} else\n\t\tindex = UIDGENERATOR.index++;\n\treturn UIDGENERATOR.date16 + index.padLeft(3, '0') + UIDGENERATOR.instance + UIDGENERATOR.date16.length + (index % 2 ? 1 : 0) + 'c'; // \"c\" version\n};\n\nglobal.UID = function(type) {\n\tvar index;\n\tif (type) {\n\t\tif (UIDGENERATOR.types[type])\n\t\t\tindex = UIDGENERATOR.types[type] = UIDGENERATOR.types[type] + 1;\n\t\telse {\n\t\t\tUIDGENERATOR.multiple = true;\n\t\t\tindex = UIDGENERATOR.types[type] = 1;\n\t\t}\n\t} else\n\t\tindex = UIDGENERATOR.index++;\n\treturn UIDGENERATOR.date + index.padLeft(3, '0') + UIDGENERATOR.instance + UIDGENERATOR.date.length + (index % 2 ? 1 : 0) + 'b'; // \"b\" version\n};\n\nglobal.UIDF = function(type) {\n\n\tvar index;\n\n\tif (type) {\n\t\tif (UIDGENERATOR.typesnumber[type])\n\t\t\tindex = UIDGENERATOR.typesnumber[type] = UIDGENERATOR.typesnumber[type] + 1;\n\t\telse {\n\t\t\tUIDGENERATOR.multiplenumber = true;\n\t\t\tindex = UIDGENERATOR.typesnumber[type] = 1;\n\t\t}\n\t} else\n\t\tindex = UIDGENERATOR.indexnumber++;\n\n\tvar div = index > 1000 ? 10000 : 1000;\n\treturn (UIDGENERATOR.datenumber + (index / div));\n};\n\nglobal.ERROR = function(name) {\n\treturn name == null ? F.errorcallback : function(err) {\n\t\terr && F.error(err, name);\n\t};\n};\n\nglobal.AUTH = function(fn) {\n\tF.onAuthorize = framework_builders.AuthOptions.wrap(fn);\n};\n\nglobal.WEBSOCKETCLIENT = function(callback) {\n\tvar ws = require('./websocketclient').create();\n\tcallback && callback.call(ws, ws);\n\treturn ws;\n};\n\nglobal.$CREATE = function(schema) {\n\tvar o = framework_builders.getschema(schema);\n\treturn o ? o.default() : null;\n};\n\nglobal.$MAKE = function(schema, model, filter, callback, novalidate, argument) {\n\n\tvar o = framework_builders.getschema(schema);\n\tvar w = null;\n\n\tif (typeof(filter) === 'function') {\n\t\tvar tmp = callback;\n\t\tcallback = filter;\n\t\tfilter = tmp;\n\t}\n\n\tif (filter instanceof Array) {\n\t\tw = {};\n\t\tfor (var i = 0; i < filter.length; i++)\n\t\t\tw[filter[i]] = i + 1;\n\t\tfilter = null;\n\t} else if (filter instanceof Object) {\n\t\tif (!(filter instanceof RegExp)) {\n\t\t\tfilter = null;\n\t\t\tw = filter;\n\t\t}\n\t}\n\n\treturn o ? o.make(model, filter, callback, argument, novalidate, w) : undefined;\n};\n\nglobal.$QUERY = function(schema, options, callback, controller) {\n\tvar o = framework_builders.getschema(schema);\n\tif (o)\n\t\to.query(options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$GET = global.$READ = function(schema, options, callback, controller) {\n\tvar o = framework_builders.getschema(schema);\n\tif (o)\n\t\to.get(options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$WORKFLOW = function(schema, name, options, callback, controller) {\n\tvar o = framework_builders.getschema(schema);\n\tif (o)\n\t\to.workflow2(name, options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$TRANSFORM = function(schema, name, options, callback, controller) {\n\tvar o = framework_builders.getschema(schema);\n\tif (o)\n\t\to.transform2(name, options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$REMOVE = function(schema, options, callback, controller) {\n\tvar o = framework_builders.getschema(schema);\n\n\tif (typeof(options) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = EMPTYOBJECT;\n\t}\n\n\tif (o)\n\t\to.remove(options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.$SAVE = function(schema, model, options, callback, controller, novalidate) {\n\treturn performschema('$save', schema, model, options, callback, controller, novalidate);\n};\n\nglobal.$INSERT = function(schema, model, options, callback, controller, novalidate) {\n\treturn performschema('$insert', schema, model, options, callback, controller, novalidate);\n};\n\nglobal.$UPDATE = function(schema, model, options, callback, controller, novalidate) {\n\treturn performschema('$update', schema, model, options, callback, controller, novalidate);\n};\n\nglobal.$PATCH = function(schema, model, options, callback, controller, novalidate) {\n\treturn performschema('$patch', schema, model, options, callback, controller, novalidate);\n};\n\n// GET Users/Neviem  --> @query @workflow\nglobal.$ACTION = function(schema, model, callback, controller) {\n\n\tif (typeof(model) === 'function') {\n\t\tcontroller = callback;\n\t\tcallback = model;\n\t\tmodel = null;\n\t}\n\n\tvar meta = F.temporary.other[schema];\n\tvar tmp, index;\n\n\tif (!meta) {\n\n\t\tindex = schema.indexOf('-->');\n\n\t\tvar op = (schema.substring(index + 3).trim().trim() + ' ').split(/\\s@/).trim();\n\t\ttmp = schema.substring(0, index).split(/\\s|\\t/).trim();\n\n\t\tif (tmp.length !== 2) {\n\t\t\tcallback('Invalid \"{0}\" type.'.format(schema));\n\t\t\treturn;\n\t\t}\n\n\t\tmeta = {};\n\t\tmeta.method = tmp[0].toUpperCase();\n\t\tmeta.schema = tmp[1];\n\n\t\tif (meta.schema[0] === '*')\n\t\t\tmeta.schema = meta.schema.substring(1);\n\n\t\tmeta.op = [];\n\t\tmeta.opcallbackindex = -1;\n\n\t\tvar name = meta.schema.split('/');\n\t\tvar o = GETSCHEMA(name[0], name[1]);\n\t\tif (!o) {\n\t\t\tcallback(new ErrorBuilder().push('', 'Schema \"{0}\" not found'.format(meta.schema)));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0; i < op.length; i++) {\n\n\t\t\ttmp = {};\n\n\t\t\tvar item = op[i];\n\t\t\tif (item[0] === '@')\n\t\t\t\titem = item.substring(1);\n\n\t\t\tindex = item.indexOf('(');\n\n\t\t\tif (index !== -1) {\n\t\t\t\tmeta.opcallbackindex = i;\n\t\t\t\ttmp.response = true;\n\t\t\t\titem = item.substring(0, index).trim();\n\t\t\t}\n\n\t\t\ttmp.name = item;\n\t\t\ttmp.name2 = '$' + tmp.name;\n\n\t\t\tif (o.meta[item] === undefined) {\n\t\t\t\tif (o.meta['workflow#' + item] !== undefined)\n\t\t\t\t\ttmp.type = '$workflow';\n\t\t\t\telse if (o.meta['transform#' + item] !== undefined)\n\t\t\t\t\ttmp.type = '$transform';\n\t\t\t\telse if (o.meta['operation#' + item] !== undefined)\n\t\t\t\t\ttmp.type = '$operation';\n\t\t\t\telse if (o.meta['hook#' + item] !== undefined)\n\t\t\t\t\ttmp.type = '$hook';\n\t\t\t\telse {\n\t\t\t\t\tcallback(new ErrorBuilder().push('', 'Schema \"{0}\" doesn\\'t contain \"{1}\" operation.'.format(meta.schema, item)));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tmp.type)\n\t\t\t\ttmp.type2 = tmp.type.substring(1);\n\n\t\t\tmeta.op.push(tmp);\n\t\t}\n\n\t\tmeta.multiple = meta.op.length > 1;\n\t\tmeta.schema = o;\n\t\tmeta.validate = meta.method !== 'GET';\n\t\tF.temporary.other[schema] = meta;\n\t}\n\n\tif (meta.validate) {\n\n\t\tvar req = controller ? controller.req : null;\n\t\tif (meta.method === 'PATCH' || meta.method === 'DELETE') {\n\t\t\tif (!req)\n\t\t\t\treq = {};\n\t\t\treq.$patch = true;\n\t\t}\n\n\t\tvar data = {};\n\t\tdata.meta = meta;\n\t\tdata.callback = callback;\n\t\tdata.controller = controller;\n\t\tmeta.schema.make(model, null, performsschemaaction_async, data, null, null, req);\n\t} else\n\t\tperformsschemaaction(meta, null, callback, controller);\n\n};\n\nfunction performsschemaaction_async(err, response, data) {\n\tif (err)\n\t\tdata.callback(err);\n\telse\n\t\tperformsschemaaction(data.meta, response, data.callback, data.controller);\n}\n\nfunction performsschemaaction(meta, model, callback, controller) {\n\n\tif (meta.multiple) {\n\n\t\tif (!model)\n\t\t\tmodel = meta.schema.default();\n\n\t\tmodel.$$controller = controller;\n\t\tvar async = model.$async(callback, meta.opcallbackindex === - 1 ? null : meta.opcallbackindex);\n\n\t\tfor (var i = 0; i < meta.op.length; i++) {\n\t\t\tvar op = meta.op[i];\n\t\t\tif (op.type)\n\t\t\t\tasync[op.type](op.name);\n\t\t\telse\n\t\t\t\tasync[op.name2]();\n\t\t}\n\n\t} else {\n\n\t\tvar op = meta.op[0];\n\n\t\tif (model) {\n\t\t\tmodel.$$controller = controller;\n\t\t\tif (op.type)\n\t\t\t\tmodel[op.type](op.name, EMPTYOBJECT, callback);\n\t\t\telse\n\t\t\t\tmodel[op.name2](EMPTYOBJECT, callback);\n\t\t} else {\n\t\t\tif (op.type)\n\t\t\t\tmeta.schema[op.type2 + '2'](op.name, EMPTYOBJECT, callback, controller);\n\t\t\telse\n\t\t\t\tmeta.schema[op.name](EMPTYOBJECT, callback, controller);\n\t\t}\n\t}\n}\n\n// type, schema, model, options, callback, controller\nfunction performschema(type, schema, model, options, callback, controller, novalidate) {\n\n\tif (typeof(options) === 'function') {\n\t\tnovalidate = controller;\n\t\tcontroller = callback;\n\t\tcallback = options;\n\t\toptions = null;\n\t}\n\n\tvar o = framework_builders.getschema(schema);\n\n\tif (!o) {\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\t\treturn false;\n\t}\n\n\tvar workflow = {};\n\tworkflow[type.substring(1)] = 1;\n\n\tvar req = controller ? controller.req : null;\n\tvar keys;\n\n\tif (type === '$patch') {\n\t\tkeys = Object.keys(model);\n\t\tif (req)\n\t\t\treq.$patch = true;\n\t\telse\n\t\t\treq = { $patch: true };\n\t}\n\n\to.make(model, null, function(err, model) {\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t} else {\n\t\t\tmodel.$$keys = keys;\n\t\t\tmodel.$$controller = controller;\n\t\t\tmodel[type](options, callback);\n\t\t\tif (req && req.$patch && req.method && (req.method !== 'PATCH' & req.method !== 'DELETE'))\n\t\t\t\tdelete req.$patch;\n\t\t}\n\t}, null, novalidate, workflow, req);\n\n\treturn !!o;\n}\n\nglobal.$ASYNC = function(schema, callback, index, controller) {\n\n\tif (index && typeof(index) === 'object') {\n\t\tcontroller = index;\n\t\tindex = undefined;\n\t}\n\n\tvar o = framework_builders.getschema(schema).default();\n\n\tif (!o) {\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\t\treturn EMPTYOBJECT;\n\t}\n\n\tcontroller && (o.$$controller = controller);\n\treturn o.$async(callback, index);\n};\n\nglobal.$OPERATION = function(schema, name, options, callback, controller) {\n\tvar o = framework_builders.getschema(schema);\n\tif (o)\n\t\to.operation2(name, options, callback, controller);\n\telse\n\t\tcallback && callback(new Error('Schema \"{0}\" not found.'.format(getSchemaName(schema))));\n\treturn !!o;\n};\n\nglobal.DB = global.DATABASE = function(a, b, c, d) {\n\treturn typeof(F.database) === 'object' ? F.database : F.database(a, b, c, d);\n};\n\nglobal.OFF = function() {\n\treturn arguments.length > 1 ? F.removeListener.apply(F, arguments) : F.removeAllListeners.apply(F, arguments);\n};\n\nglobal.NEWSCHEMA = function(group, name, make) {\n\n\tif (typeof(name) === 'function') {\n\t\tmake = name;\n\t\tname = undefined;\n\t}\n\n\tif (!name) {\n\t\tvar arr = group.split('/');\n\t\tif (arr.length === 2) {\n\t\t\tname = arr[1];\n\t\t\tgroup = arr[0];\n\t\t} else {\n\t\t\tname = group;\n\t\t\tgroup = 'default';\n\t\t}\n\t}\n\n\tvar schema = framework_builders.newschema(group, name);\n\tmake && make.call(schema, schema);\n\treturn schema;\n};\n\nglobal.CLEANUP = function(stream, callback) {\n\tFINISHED(stream, function() {\n\t\tDESTROY(stream);\n\t\tif (callback) {\n\t\t\tcallback();\n\t\t\tcallback = null;\n\t\t}\n\t});\n};\n\nglobal.SUCCESS = function(success, value) {\n\n\tif (typeof(success) === 'function') {\n\t\treturn function(err, value) {\n\t\t\tsuccess(err, SUCCESS(err, value));\n\t\t};\n\t}\n\n\tvar err;\n\n\tif (success instanceof Error) {\n\t\terr = success.toString();\n\t\tsuccess = false;\n\t} else if (success instanceof framework_builders.ErrorBuilder) {\n\t\tif (success.hasError()) {\n\t\t\terr = success.output();\n\t\t\tsuccess = false;\n\t\t} else\n\t\t\tsuccess = true;\n\t} else if (success == null)\n\t\tsuccess = true;\n\n\tSUCCESSHELPER.success = !!success;\n\tSUCCESSHELPER.value = value === SUCCESSHELPER ? value.value : value == null ? undefined : (value && value.$$schema ? value.$clean() : value);\n\tSUCCESSHELPER.error = err ? err : undefined;\n\treturn SUCCESSHELPER;\n};\n\nglobal.TRY = function(fn, err) {\n\ttry {\n\t\tfn();\n\t\treturn true;\n\t} catch (e) {\n\t\terr && err(e);\n\t\treturn false;\n\t}\n};\n\nglobal.OBSOLETE = function(name, message) {\n\n\tif (F.config.nowarnings)\n\t\treturn;\n\n\tconsole.log(NOW.format('yyyy-MM-dd HH:mm:ss') + ' :: OBSOLETE / IMPORTANT ---> \"' + name + '\"', message);\n\tif (global.F)\n\t\tF.stats.other.obsolete++;\n};\n\nglobal.DEBUG = false;\nglobal.TEST = false;\nglobal.RELEASE = false;\nglobal.is_client = false;\nglobal.is_server = true;\n\nvar directory = U.$normalize(require.main ? Path.dirname(require.main.filename) : process.cwd());\n\n// F.service() changes the values below:\nvar DATE_EXPIRES = new Date().add('y', 1).toUTCString();\n\nconst _randomstring = 'abcdefghijklmnoprstuwxy'.split('');\n\nfunction random2string() {\n\treturn _randomstring[(Math.random() * _randomstring.length) >> 0] + _randomstring[(Math.random() * _randomstring.length) >> 0];\n}\n\nconst WEBSOCKET_COMPRESS = Buffer.from([0x00, 0x00, 0xFF, 0xFF]);\nconst WEBSOCKET_COMPRESS_OPTIONS = { windowBits: Zlib.Z_DEFAULT_WINDOWBITS };\nconst UIDGENERATOR = { types: {}, typesnumber: {} };\n\nfunction UIDGENERATOR_REFRESH() {\n\n\tvar ticks = NOW.getTime();\n\tvar dt = Math.round(((ticks - 1580511600000) / 1000 / 60));\n\n\tUIDGENERATOR.date = dt + '';\n\tUIDGENERATOR.date16 = dt.toString(16);\n\n\tvar seconds = ((NOW.getSeconds() / 60) + '').substring(2, 4);\n\tUIDGENERATOR.datenumber = +((((ticks - 1580511600000) / 1000 / 60) >> 0) + seconds); // 1580511600000 means 1.1.2020\n\tUIDGENERATOR.indexnumber = 1;\n\tUIDGENERATOR.index = 1;\n\tUIDGENERATOR.instance = random2string();\n\n\tvar keys;\n\n\tif (UIDGENERATOR.multiple) {\n\t\tkeys = Object.keys(UIDGENERATOR.types);\n\t\tfor (var i = 0; i < keys.length; i++)\n\t\t\tUIDGENERATOR.types[keys[i]] = 0;\n\t}\n\n\tif (UIDGENERATOR.multiplenumber) {\n\t\tkeys = Object.keys(UIDGENERATOR.typesnumber);\n\t\tfor (var i = 0; i < keys.length; i++)\n\t\t\tUIDGENERATOR.typesnumber[keys[i]] = 0;\n\t}\n}\n\nUIDGENERATOR_REFRESH();\n\nconst EMPTYBUFFER = Buffer.alloc(0);\nglobal.EMPTYBUFFER = EMPTYBUFFER;\n\nconst controller_error_status = function(controller, status, problem) {\n\n\tif (status !== 500 && problem)\n\t\tcontroller.problem(problem);\n\n\tif (controller.res.success || controller.res.headersSent || !controller.isConnected)\n\t\treturn controller;\n\n\tcontroller.precache && controller.precache(null, null, null);\n\tcontroller.req.path = EMPTYARRAY;\n\tcontroller.req.$total_success();\n\tcontroller.req.$total_route = F.lookup(controller.req, '#' + status, EMPTYARRAY, 0);\n\tcontroller.req.$total_exception = problem;\n\tcontroller.req.$total_execute(status, true);\n\n\treturn controller;\n};\n\nvar PERF = {};\n\nfunction Framework() {\n\n\tvar self = this;\n\n\tself.$id = null; // F.id ==> property\n\tself.version = 3413;\n\tself.version_header = '3.4.13';\n\tself.version_node = process.version.toString();\n\tself.syshash = (__dirname + '-' + Os.hostname() + '-' + Os.platform() + '-' + Os.arch() + '-' + Os.release() + '-' + Os.tmpdir() + JSON.stringify(process.versions)).md5();\n\tself.pref = global.PREF;\n\tglobal.CONF = self.config = {\n\n\t\tdebug: true,\n\t\ttrace: true,\n\t\ttrace_console: true,\n\n\t\t//nowarnings: process.argv.indexOf('restart') !== -1,\n\t\tnowarnings: true,\n\t\tname: 'Total.js',\n\t\tversion: '1.0.0',\n\t\tauthor: '',\n\t\tsecret: self.syshash,\n\t\tsecret_uid: self.syshash.substring(10),\n\n\t\t'security.txt': 'Contact: mailto:support@totaljs.com\\nContact: https://www.totaljs.com/contact/',\n\t\tetag_version: '',\n\t\tdirectory_src: '/.src/',\n\t\tdirectory_bundles: '/bundles/',\n\t\tdirectory_controllers: '/controllers/',\n\t\tdirectory_components: '/components/',\n\t\tdirectory_views: '/views/',\n\t\tdirectory_definitions: '/definitions/',\n\t\tdirectory_temp: '/tmp/',\n\t\tdirectory_models: '/models/',\n\t\tdirectory_schemas: '/schemas/',\n\t\tdirectory_operations: '/operations/',\n\t\tdirectory_resources: '/resources/',\n\t\tdirectory_public: '/public/',\n\t\tdirectory_public_virtual: '/app/',\n\t\tdirectory_modules: '/modules/',\n\t\tdirectory_source: '/source/',\n\t\tdirectory_logs: '/logs/',\n\t\tdirectory_tests: '/tests/',\n\t\tdirectory_databases: '/databases/',\n\t\tdirectory_workers: '/workers/',\n\t\tdirectory_packages: '/packages/',\n\t\tdirectory_private: '/private/',\n\t\tdirectory_isomorphic: '/isomorphic/',\n\t\tdirectory_configs: '/configs/',\n\t\tdirectory_services: '/services/',\n\t\tdirectory_themes: '/themes/',\n\t\tdirectory_tasks: '/tasks/',\n\t\tdirectory_updates: '/updates/',\n\n\t\t// all HTTP static request are routed to directory-public\n\t\tstatic_url: '',\n\t\tstatic_url_script: '/js/',\n\t\tstatic_url_style: '/css/',\n\t\tstatic_url_image: '/img/',\n\t\tstatic_url_video: '/video/',\n\t\tstatic_url_font: '/fonts/',\n\t\tstatic_url_download: '/download/',\n\t\tstatic_url_components: '/components.',\n\t\tstatic_accepts: { flac: true, jpg: true, jpeg: true, png: true, gif: true, ico: true, js: true, mjs: true, css: true, txt: true, xml: true, woff: true, woff2: true, otf: true, ttf: true, eot: true, svg: true, zip: true, rar: true, pdf: true, docx: true, xlsx: true, doc: true, xls: true, html: true, htm: true, appcache: true, manifest: true, map: true, ogv: true, ogg: true, mp4: true, mp3: true, webp: true, webm: true, swf: true, package: true, json: true, md: true, m4v: true, jsx: true, heif: true, heic: true, ics: true },\n\n\t\t// 'static-accepts-custom': [],\n\t\tdefault_crypto_iv: Buffer.from(self.syshash).slice(0, 16),\n\t\tdefault_xpoweredby: 'Total.js',\n\t\tdefault_layout: 'layout',\n\t\tdefault_theme: '',\n\t\tdefault_proxy: '',\n\t\tdefault_request_maxkeys: 33,\n\t\tdefault_request_maxkey: 25,\n\n\t\t// default maximum request size / length\n\t\t// default 10 kB\n\t\tdefault_request_maxlength: 10,\n\t\tdefault_websocket_maxlength: 2,\n\t\tdefault_websocket_encodedecode: true,\n\t\tdefault_maxopenfiles: 100,\n\t\tdefault_timezone: 'utc',\n\t\tdefault_root: '',\n\t\tdefault_response_maxage: '11111111',\n\t\tdefault_errorbuilder_status: 200,\n\n\t\t// Default originators\n\t\tdefault_cors: null,\n\n\t\t// Seconds (2 minutes)\n\t\tdefault_cors_maxage: 120,\n\n\t\t// in milliseconds\n\t\tdefault_request_timeout: 3000,\n\t\tdefault_dependency_timeout: 1500,\n\t\tdefault_restbuilder_timeout: 10000,\n\n\t\t// otherwise is used ImageMagick (Heroku supports ImageMagick)\n\t\t// gm = graphicsmagick or im = imagemagick or magick (new version of ImageMagick)\n\t\tdefault_image_converter: 'gm', // command-line name\n\t\tdefault_image_quality: 93,\n\t\tdefault_image_consumption: 0, // disabled because e.g. GM v1.3.32 throws some error about the memory\n\n\t\tallow_static_files: true,\n\t\tallow_gzip: true,\n\t\tallow_websocket: true,\n\t\tallow_websocket_compression: true,\n\t\tallow_compile: true,\n\t\tallow_compile_script: true,\n\t\tallow_compile_style: true,\n\t\tallow_compile_html: true,\n\t\tallow_localize: true,\n\t\tallow_stats_snapshot: true,\n\t\tallow_performance: false,\n\t\tallow_custom_titles: false,\n\t\tallow_cache_snapshot: false,\n\t\tallow_cache_cluster: false,\n\t\tallow_debug: false,\n\t\tallow_head: false,\n\t\tallow_filter_errors: true,\n\t\tallow_clear_temp: true,\n\t\tallow_ssc_validation: true,\n\t\tallow_workers_silent: false,\n\t\tallow_sessions_unused: '-20 minutes',\n\t\tallow_reqlimit: 0,\n\t\tallow_persistent_images: false,\n\n\t\tnosql_worker: false,\n\t\tnosql_inmemory: null, // String Array\n\t\tnosql_cleaner: 1440,\n\t\tnosql_logger: true,\n\t\tlogger: false,\n\n\t\t// Used in F.service()\n\t\t// All values are in minutes\n\t\tdefault_interval_clear_resources: 20,\n\t\tdefault_interval_clear_cache: 10,\n\t\tdefault_interval_clear_dnscache: 30,\n\t\tdefault_interval_precompile_views: 61,\n\t\tdefault_interval_websocket_ping: 3,\n\t\tdefault_interval_uptodate: 5,\n\n\t\tset ['mail-smtp'] (val) {\n\t\t\tCONF['mail_smtp'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-smtp-options'] (val) {\n\t\t\tCONF['mail_smtp_options'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-address-reply'] (val) {\n\t\t\tCONF['mail_address_reply'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-address-from'] (val) {\n\t\t\tCONF['mail_address_from'] = val;\n\t\t\treturn null;\n\t\t},\n\n\t\tset ['mail-address-copy'] (val) {\n\t\t\tCONF['mail_address_copy'] = val;\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tglobal.REPO = global.G = self.global = {};\n\tglobal.MAIN = {};\n\tglobal.TEMP = {};\n\n\tself.$bundling = true;\n\tself.resources = {};\n\tself.connections = {};\n\tglobal.FUNC = self.functions = {};\n\tself.themes = {};\n\tself.versions = null;\n\tself.workflows = {};\n\tself.uptodates = null;\n\tself.schedules = {};\n\n\tself.isDebug = true;\n\tself.isTest = false;\n\tself.isLoaded = false;\n\tself.isWorker = true;\n\tself.isCluster = process.env.PASSENGER_APP_ENV ? false : require('cluster').isWorker;\n\n\tself.routes = {\n\t\tsitemap: null,\n\t\tweb: [],\n\t\tsystem: {},\n\t\tfiles: [],\n\t\tfilesfallback: null,\n\t\tcors: [],\n\t\tcorsall: false,\n\t\twebsockets: [],\n\t\tmiddleware: {},\n\t\tredirects: {},\n\t\tresize: {},\n\t\trequest: [],\n\t\tviews: {},\n\t\tmerge: {},\n\t\tmapping: {},\n\t\tpackages: {},\n\t\tblocks: {},\n\t\tproxies: [],\n\t\tresources: {}\n\t};\n\n\tself.owners = [];\n\tself.modificators = null;\n\tself.modificators2 = null;\n\tDEF.helpers = self.helpers = {};\n\tself.modules = {};\n\tself.models = {};\n\tself.sources = {};\n\tself.controllers = {};\n\tself.dependencies = {};\n\tself.isomorphic = {};\n\tself.components = { has: false, css: false, js: false, views: {}, instances: {}, version: null, links: '', groups: {}, files: {} };\n\tself.convertors = [];\n\tself.convertors2 = null;\n\tself.tests = [];\n\tself.errors = [];\n\tself.timeouts = [];\n\tself.problems = [];\n\tself.changes = [];\n\tself.server = null;\n\tself.port = 0;\n\tself.ip = '';\n\n\tDEF.validators = self.validators = {\n\t\temail: new RegExp('^[a-zA-Z0-9-_.+]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$'),\n\t\turl: /^http(s)?:\\/\\/[^,{}\\\\]*$/i,\n\t\tphone: /^[+]?[(]?[0-9]{3}[)]?[-\\s.]?[0-9]{3}[-\\s.]?[0-9]{4,8}$/im,\n\t\tzip: /^[0-9a-z\\-\\s]{3,20}$/i,\n\t\tuid: /^\\d{14,}[a-z]{3}[01]{1}|^\\d{9,14}[a-z]{2}[01]{1}a|^\\d{4,18}[a-z]{2}\\d{1}[01]{1}b|^[0-9a-f]{4,18}[a-z]{2}\\d{1}[01]{1}c|^[0-9a-z]{4,18}[a-z]{2}\\d{1}[01]{1}d$/\n\t};\n\n\tself.workers = {};\n\tself.sessions = {};\n\tself.flows = {};\n\tself.databases = {};\n\tself.databasescleaner = {};\n\tself.directory = HEADERS.workers2.cwd = HEADERS.workers.cwd = directory;\n\tself.isLE = Os.endianness ? Os.endianness() === 'LE' : true;\n\tself.isHTTPS = false;\n\n\t// Fix for workers crash (port in use) when debugging main process with --inspect or --debug\n\t// See: https://github.com/nodejs/node/issues/14325 and https://github.com/nodejs/node/issues/9435\n\tfor (var i = 0; i < process.execArgv.length; i++) {\n\t\t// Setting inspect/debug port to random unused\n\t\tif ((/inspect|debug/).test(process.execArgv[i])) {\n\t\t\tprocess.execArgv[i] = '--inspect=0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tHEADERS.workers.execArgv = process.execArgv;\n\n\t// It's hidden\n\t// self.waits = {};\n\n\tself.temporary = {\n\t\tpath: {},\n\t\tshortcache: {},\n\t\tnotfound: {},\n\t\tprocessing: {},\n\t\trange: {},\n\t\tviews: {},\n\t\tversions: {},\n\t\tdependencies: {}, // temporary for module dependencies\n\t\tother: {},\n\t\tkeys: {}, // for crypto keys\n\t\tinternal: {}, // controllers/modules names for the routing\n\t\towners: {},\n\t\tready: {},\n\t\tddos: {},\n\t\tservice: { redirect: 0, request: 0, file: 0, usage: 0 }\n\t};\n\n\tself.stats = {\n\n\t\terror: 0,\n\n\t\tperformance: {\n\t\t\trequest: 0,\n\t\t\tmessage: 0,\n\t\t\texternal: 0,\n\t\t\tfile: 0,\n\t\t\topen: 0,\n\t\t\tdbrm: 0,\n\t\t\tdbwm: 0,\n\t\t\tonline: 0,\n\t\t\tusage: 0,\n\t\t\tmail: 0\n\t\t},\n\n\t\tother: {\n\t\t\twebsocketPing: 0,\n\t\t\twebsocketCleaner: 0,\n\t\t\tobsolete: 0,\n\t\t\tmail: 0\n\t\t},\n\n\t\trequest: {\n\t\t\trequest: 0,\n\t\t\tpending: 0,\n\t\t\tweb: 0,\n\t\t\txhr: 0,\n\t\t\tfile: 0,\n\t\t\twebsocket: 0,\n\t\t\tget: 0,\n\t\t\toptions: 0,\n\t\t\thead: 0,\n\t\t\tpost: 0,\n\t\t\tput: 0,\n\t\t\tpatch: 0,\n\t\t\tupload: 0,\n\t\t\tschema: 0,\n\t\t\toperation: 0,\n\t\t\tblocked: 0,\n\t\t\t'delete': 0,\n\t\t\tmobile: 0,\n\t\t\tdesktop: 0\n\t\t},\n\t\tresponse: {\n\t\t\tddos: 0,\n\t\t\tview: 0,\n\t\t\tjson: 0,\n\t\t\twebsocket: 0,\n\t\t\ttimeout: 0,\n\t\t\tcustom: 0,\n\t\t\tbinary: 0,\n\t\t\tpipe: 0,\n\t\t\tfile: 0,\n\t\t\timage: 0,\n\t\t\tdestroy: 0,\n\t\t\tstream: 0,\n\t\t\tstreaming: 0,\n\t\t\tplain: 0,\n\t\t\tempty: 0,\n\t\t\tredirect: 0,\n\t\t\tforward: 0,\n\t\t\tproxy: 0,\n\t\t\tnotModified: 0,\n\t\t\tsse: 0,\n\t\t\terrorBuilder: 0,\n\t\t\terror400: 0,\n\t\t\terror401: 0,\n\t\t\terror403: 0,\n\t\t\terror404: 0,\n\t\t\terror408: 0,\n\t\t\terror409: 0,\n\t\t\terror431: 0,\n\t\t\terror500: 0,\n\t\t\terror501: 0,\n\t\t\terror503: 0\n\t\t}\n\t};\n\n\t// intialize cache\n\tself.cache = new FrameworkCache();\n\tself.path = global.PATH = new FrameworkPath();\n\n\tself._request_check_redirect = false;\n\tself._request_check_referer = false;\n\tself._request_check_POST = false;\n\tself._request_check_robot = false;\n\tself._request_check_mobile = false;\n\tself._request_check_proxy = false;\n\tself._length_middleware = 0;\n\tself._length_request_middleware = 0;\n\tself._length_files = 0;\n\tself._length_wait = 0;\n\tself._length_themes = 0;\n\tself._length_cors = 0;\n\tself._length_subdomain_web = 0;\n\tself._length_subdomain_websocket = 0;\n\tself._length_convertors = 0;\n\n\tself.isVirtualDirectory = false;\n\tself.isTheme = false;\n\tself.isWindows = Os.platform().substring(0, 3).toLowerCase() === 'win';\n\n\tself.$events = {};\n\tself.commands = { reload_preferences: [loadpreferences] };\n}\n\n// ======================================================\n// PROTOTYPES\n// ======================================================\n\nFramework.prototype = {\n\tget datetime() {\n\t\treturn global.NOW;\n\t},\n\tset datetime(val) {\n\t\tglobal.NOW = val;\n\t},\n\tget cluster() {\n\t\treturn require('./cluster');\n\t},\n\tget id() {\n\t\treturn F.$id;\n\t},\n\tset id(value) {\n\t\tCLUSTER_CACHE_SET.ID = value;\n\t\tCLUSTER_CACHE_REMOVE.ID = value;\n\t\tCLUSTER_CACHE_REMOVEALL.ID = value;\n\t\tCLUSTER_CACHE_CLEAR.ID = value;\n\t\tF.$id = value;\n\t\treturn F.$id;\n\t}\n};\n\nvar framework = new Framework();\nglobal.framework = global.F = module.exports = framework;\n\nglobal.CMD = function(key, a, b, c, d) {\n\tif (F.commands[key]) {\n\t\tfor (var i = 0; i < F.commands[key].length; i++)\n\t\t\tF.commands[key][i](a, b, c, d);\n\t}\n};\n\nF.callback_redirect = function(url) {\n\tthis.url = url;\n};\n\nF.dir = function(path) {\n\tF.directory = path;\n\tdirectory = path;\n};\n\nF.refresh = function() {\n\n\tNOW = new Date();\n\n\tF.$events.clear && EMIT('clear', 'temporary', F.temporary);\n\tF.temporary.path = {};\n\tF.temporary.range = {};\n\tF.temporary.views = {};\n\tF.temporary.other = {};\n\tF.temporary.keys = {};\n\tglobal.$VIEWCACHE && global.$VIEWCACHE.length && (global.$VIEWCACHE = []);\n\n\t// Clears command cache\n\tImage.clear();\n\n\tCONF.allow_debug && F.consoledebug('clear temporary cache');\n\n\tvar keys = Object.keys(F.temporary.internal);\n\tfor (var i = 0; i < keys.length; i++)\n\t\tif (!F.temporary.internal[keys[i]])\n\t\t\tdelete F.temporary.internal[keys[i]];\n\n\tF.$events.clear && EMIT('clear', 'resources');\n\tF.resources = {};\n\tCONF.allow_debug && F.consoledebug('clear resources');\n\n\tF.$events.clear && EMIT('clear', 'dns');\n\tCMD('clear_dnscache');\n\tCONF.allow_debug && F.consoledebug('clear DNS cache');\n\n\treturn F;\n};\n\nF.prototypes = function(fn) {\n\n\tif (!global.framework_nosql)\n\t\tglobal.framework_nosql = require('./nosql');\n\n\tvar proto = {};\n\tproto.Chunker = framework_utils.Chunker.prototype;\n\tproto.Controller = Controller.prototype;\n\tproto.Database = framework_nosql.Database.prototype;\n\tproto.DatabaseBinary = framework_nosql.DatabaseBinary.prototype;\n\tproto.DatabaseBuilder = framework_nosql.DatabaseBuilder.prototype;\n\tproto.DatabaseBuilder2 = framework_nosql.DatabaseBuilder2.prototype;\n\tproto.DatabaseCounter = framework_nosql.DatabaseCounter.prototype;\n\tproto.DatabaseStorage = framework_nosql.DatabaseStorage.prototype;\n\tproto.DatabaseTable = framework_nosql.DatabaseTable.prototype;\n\tproto.ErrorBuilder = framework_builders.ErrorBuilder.prototype;\n\tproto.HttpFile = framework_internal.HttpFile.prototype;\n\tproto.HttpRequest = PROTOREQ;\n\tproto.HttpResponse = PROTORES;\n\tproto.Image = framework_image.Image.prototype;\n\tproto.Message = Mail.Message.prototype;\n\tproto.MiddlewareOptions = MiddlewareOptions.prototype;\n\tproto.OperationOptions = framework_builders.OperationOptions.prototype;\n\tproto.Page = framework_builders.Page.prototype;\n\tproto.Pagination = framework_builders.Pagination.prototype;\n\tproto.RESTBuilder = framework_builders.RESTBuilder.prototype;\n\tproto.RESTBuilderResponse = framework_builders.RESTBuilderResponse.prototype;\n\tproto.SchemaBuilder = framework_builders.SchemaBuilder.prototype;\n\tproto.SchemaOptions = framework_builders.SchemaOptions.prototype;\n\tproto.UrlBuilder = framework_builders.UrlBuilder.prototype;\n\tproto.WebSocket = WebSocket.prototype;\n\tproto.WebSocketClient = WebSocketClient.prototype;\n\tproto.AuthOptions = framework_builders.AuthOptions.prototype;\n\tfn.call(proto, proto);\n\treturn F;\n};\n\nglobal.ON = F.on = function(name, fn) {\n\n\tif (name === 'init' || name === 'ready' || name === 'load') {\n\t\tif (F.isLoaded) {\n\t\t\tfn.call(F);\n\t\t\treturn;\n\t\t}\n\t} else if (name.indexOf('#') !== -1) {\n\t\tvar arr = name.split('#');\n\t\tswitch (arr[0]) {\n\t\t\tcase 'middleware':\n\t\t\t\tF.temporary.ready[name] && fn.call(F);\n\t\t\t\tbreak;\n\t\t\tcase 'component':\n\t\t\t\tF.temporary.ready[name] && fn.call(F);\n\t\t\t\tbreak;\n\t\t\tcase 'model':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.models[arr[1]]);\n\t\t\t\tbreak;\n\t\t\tcase 'source':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.sources[arr[1]]);\n\t\t\t\tbreak;\n\t\t\tcase 'package':\n\t\t\tcase 'module':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.modules[arr[1]]);\n\t\t\t\tbreak;\n\t\t\tcase 'controller':\n\t\t\t\tF.temporary.ready[name] && fn.call(F, F.controllers[arr[1]]);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (name) {\n\t\tcase 'cache-set':\n\t\tcase 'controller-render-meta':\n\t\tcase 'request-end':\n\t\tcase 'websocket-begin':\n\t\tcase 'websocket-end':\n\t\tcase 'request-begin':\n\t\tcase 'upload-begin':\n\t\tcase 'upload-end':\n\t\t\tOBSOLETE(name, 'Name of event has been replaced to \"{0}\"'.format(name.replace(/-/g, '_')));\n\t\t\tbreak;\n\t\tcase 'cache-expire':\n\t\t\tOBSOLETE(name, 'Name of event has been replaced to \"cache_expired\"');\n\t\t\tbreak;\n\t}\n\n\tif (isWORKER && name === 'service' && !F.cache.interval)\n\t\tF.cache.init_timer();\n\n\tif (F.$events[name])\n\t\tF.$events[name].push(fn);\n\telse\n\t\tF.$events[name] = [fn];\n\n\treturn F;\n};\n\nglobal.EMIT = F.emit = function(name, a, b, c, d, e, f, g) {\n\n\tvar evt = F.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(F, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tF.$events[name] = evt;\n\t\t\telse\n\t\t\t\tF.$events[name] = undefined;\n\t\t}\n\t}\n\treturn F;\n};\n\nglobal.ONCE = F.once = function(name, fn) {\n\tfn.$once = true;\n\treturn F.on(name, fn);\n};\n\nF.removeListener = function(name, fn) {\n\tvar evt = F.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tF.$events[name] = evt;\n\t\telse\n\t\t\tF.$events[name] = undefined;\n\t}\n\treturn F;\n};\n\nF.removeAllListeners = function(name) {\n\tif (name)\n\t\tF.$events[name] = undefined;\n\telse\n\t\tF.$events = {};\n\treturn F;\n};\n\n/**\n * Internal function\n * @return {String} Returns current (dependency type and name) owner.\n */\nF.$owner = function() {\n\treturn _owner;\n};\n\nF.isSuccess = function(obj) {\n\treturn obj === SUCCESSHELPER;\n};\n\nF.convert = function(value, convertor) {\n\n\tif (convertor) {\n\n\t\tif (F.convertors.findIndex('name', value) !== -1) {\n\t\t\tif (convertor == null)\n\t\t\t\tF.convertors = F.convertors.remove('name', value);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (convertor === Number)\n\t\t\tconvertor = U.parseFloat;\n\t\telse if (convertor === Boolean)\n\t\t\tconvertor = U.parseBoolean;\n\t\telse if (typeof(convertor) === 'string') {\n\t\t\tswitch (convertor.toLowerCase()) {\n\t\t\t\tcase 'json':\n\t\t\t\t\tconvertor = U.parseJSON;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'float':\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'double':\n\t\t\t\t\tconvertor = U.parseFloat;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'integer':\n\t\t\t\t\tconvertor = U.parseInt2;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn console.log('Unknown convertor type:', convertor);\n\t\t\t}\n\t\t}\n\n\t\tF.convertors.push({ name: value, convertor: convertor });\n\t\tF._length_convertors = F.convertors.length;\n\t\treturn true;\n\t}\n\n\tif (value) {\n\t\tfor (var i = 0, length = F.convertors.length; i < length; i++) {\n\t\t\tif (value[F.convertors[i].name] != null)\n\t\t\t\tvalue[F.convertors[i].name] = F.convertors[i].convertor(value[F.convertors[i].name]);\n\t\t}\n\t}\n\n\treturn value;\n};\n\n/**\n * Get a controller\n * @param {String} name\n * @return {Object}\n */\nF.controller = function(name) {\n\treturn F.controllers[name] || null;\n};\n\n/**\n * Use configuration\n * @param {String} filename\n * @return {Framework}\n */\nF.useConfig = function(name) {\n\tOBSOLETE('F.useConfig', 'F.useConfig will be moreved in Total.js v4');\n\treturn F.$configure_configs(name, true);\n};\n\nMail.use = function(smtp, options, callback) {\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tMail.try(smtp, options, function(err) {\n\n\t\tif (!err) {\n\t\t\tdelete F.temporary.mail_settings;\n\t\t\tCONF.mail_smtp = smtp;\n\t\t\tCONF.mail_smtp_options = options;\n\t\t}\n\n\t\tif (callback)\n\t\t\tcallback(err);\n\t\telse if (err)\n\t\t\tF.error(err, 'F.useSMTP()', null);\n\t});\n};\n\nF.useSMTP = function(smtp, options, callback) {\n\tOBSOLETE('F.useSMTP', 'Use `Mail.use() instead of F.useSMTP()');\n\tMail.use(smtp, options, callback);\n\treturn F;\n};\n\n/**\n * Sort all routes\n * @return {Framework}\n */\nF.$routesSort = function(type) {\n\n\tF.routes.web.sort((a, b) => a.priority > b.priority ? -1 : a.priority < b.priority ? 1 : 0);\n\tF.routes.websockets.sort((a, b) => a.priority > b.priority ? -1 : a.priority < b.priority ? 1 : 0);\n\n\tvar cache = {};\n\tvar length = F.routes.web.length;\n\tvar url;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar route = F.routes.web[i];\n\t\tvar name = F.temporary.internal[route.controller];\n\t\tif (name)\n\t\t\troute.controller = name;\n\t\tif (!route.isMOBILE || route.isUPLOAD || route.isXHR || route.isJSON || route.isSYSTEM || route.isXML || route.flags.indexOf('get') === -1)\n\t\t\tcontinue;\n\t\turl = route.url.join('/');\n\t\tcache[url] = true;\n\t}\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar route = F.routes.web[i];\n\t\tif (route.isMOBILE || route.isUPLOAD || route.isXHR || route.isJSON || route.isSYSTEM || route.isXML || route.flags.indexOf('get') === -1)\n\t\t\tcontinue;\n\t\turl = route.url.join('/');\n\t\troute.isMOBILE_VARY = cache[url] === true;\n\t}\n\n\t(!type || type === 1) && F.routes.web.forEach(function(route) {\n\t\tvar tmp = F.routes.web.findItem(item => item.hash === route.hash && item !== route);\n\t\troute.isUNIQUE = tmp == null;\n\t});\n\n\t// Clears cache\n\tObject.keys(F.temporary.other).forEach(function(key) {\n\t\tif (key[0] === '1')\n\t\t\tF.temporary.other[key] = undefined;\n\t});\n\n\treturn F;\n};\n\nF.parseComponent = parseComponent;\n\nglobal.SCRIPT = F.script = function(body, value, callback, param) {\n\n\tvar fn;\n\tvar compilation = value === undefined && callback === undefined;\n\tvar err;\n\n\ttry {\n\t\tfn = new Function('next', 'value', 'now', 'var model=value;var global,require,process,GLOBAL,root,clearImmediate,clearInterval,clearTimeout,setImmediate,setInterval,setTimeout,console,$STRING,$VIEWCACHE,framework_internal,TransformBuilder,Pagination,Page,URLBuilder,UrlBuilder,SchemaBuilder,framework_builders,framework_utils,framework_mail,Image,framework_image,framework_nosql,Builders,U,utils,Utils,Mail,WTF,SOURCE,INCLUDE,MODULE,NOSQL,NOBIN,NOCOUNTER,NOSQLMEMORY,NOMEM,DATABASE,DB,CONFIG,INSTALL,UNINSTALL,RESOURCE,TRANSLATOR,LOG,LOGGER,MODEL,GETSCHEMA,CREATE,UID,TRANSFORM,MAKE,SINGLETON,NEWTRANSFORM,NEWSCHEMA,EACHSCHEMA,FUNCTION,ROUTING,SCHEDULE,OBSOLETE,DEBUG,TEST,RELEASE,is_client,is_server,F,framework,Controller,setTimeout2,clearTimeout2,String,Number,Boolean,Object,Function,Date,isomorphic,I,eval;UPTODATE,NEWOPERATION,OPERATION,$$$,EMIT,ON,$QUERY,$GET,$WORKFLOW,$TRANSFORM,$OPERATION,$MAKE,$CREATE,HttpFile;EMPTYCONTROLLER,ROUTE,FILE,TEST,WEBSOCKET,MAIL,LOGMAIL,FUNC,REPO,FILESTORAGE;try{' + body + ';\\n}catch(e){next(e)}');\n\t} catch(e) {\n\t\terr = e;\n\t}\n\n\tif (err) {\n\t\tcallback && callback(err);\n\t\treturn compilation ? err : F;\n\t}\n\n\tif (compilation) {\n\t\treturn (function() {\n\t\t\treturn function(model, callback, param) {\n\t\t\t\treturn fn.call(EMPTYOBJECT, function(value) {\n\t\t\t\t\tif (value instanceof Error)\n\t\t\t\t\t\tcallback(value, undefined, param);\n\t\t\t\t\telse\n\t\t\t\t\t\tcallback(null, value, param);\n\t\t\t\t}, model, scriptNow);\n\t\t\t};\n\t\t})();\n\t}\n\n\tfn.call(EMPTYOBJECT, function(value) {\n\n\t\tif (!callback)\n\t\t\treturn;\n\n\t\tif (value instanceof Error)\n\t\t\tcallback(value);\n\t\telse\n\t\t\tcallback(null, value);\n\n\t}, value, scriptNow, param);\n\n\treturn F;\n};\n\nfunction scriptNow() {\n\treturn new Date();\n}\n\nfunction nosqlwrapper(name) {\n\tvar db = F.databases[name];\n\tif (db)\n\t\treturn db;\n\n\t// absolute\n\tif (name[0] === '~') {\n\t\tdb = framework_nosql.load(U.getName(name), name.substring(1), true);\n\t} else {\n\t\tvar is = name.substring(0, 6);\n\t\tif (is === 'http:/' || is === 'https:')\n\t\t\tdb = framework_nosql.load(U.getName(name), name);\n\t\telse {\n\t\t\tF.path.verify('databases');\n\t\t\tdb = framework_nosql.load(name, F.path.databases(name));\n\t\t}\n\t}\n\n\tF.databases[name] = db;\n\treturn db;\n}\n\nF.database = global.NOSQL = F.nosql = function(name) {\n\tif (!global.framework_nosql)\n\t\tglobal.framework_nosql = require('./nosql');\n\t// Someone rewrites F.database\n\tif (F.database !== F.nosql)\n\t\tglobal.NOSQL = F.nosql = nosqlwrapper;\n\telse\n\t\tF.database = nosqlwrapper;\n\n\treturn nosqlwrapper(name);\n};\n\nfunction tablewrapper(name) {\n\tvar db = F.databases['$' + name];\n\tif (db)\n\t\treturn db;\n\n\tif (name[0] === '~') {\n\t\tdb = framework_nosql.load(U.getName(name), name.substring(1), true);\n\t} else {\n\t\tF.path.verify('databases');\n\t\tdb = framework_nosql.table(name, F.path.databases(name));\n\t}\n\n\tF.databases['$' + name] = db;\n\treturn db;\n}\n\nglobal.TABLE = function(name) {\n\tif (!global.framework_nosql)\n\t\tglobal.framework_nosql = require('./nosql');\n\tglobal.TABLE = tablewrapper;\n\treturn tablewrapper(name);\n};\n\nF.stop = F.kill = function(signal) {\n\n\tif (F.isKilled)\n\t\treturn F;\n\n\tF.isKilled = true;\n\n\tif (!signal)\n\t\tsignal = 'SIGTERM';\n\n\tfor (var m in F.workers) {\n\t\tvar worker = F.workers[m];\n\t\tTRY(() => worker && worker.kill && worker.kill(signal));\n\t}\n\n\tglobal.framework_nosql && global.framework_nosql.kill(signal);\n\n\tEMIT('exit', signal);\n\n\tif (!F.isWorker && process.send && process.connected)\n\t\tTRY(() => process.send('total:stop'));\n\n\tF.cache.stop();\n\n\tif (F.server) {\n\t\tF.server.setTimeout(1);\n\t\tF.server.close();\n\t}\n\n\t// var extenddelay = F.grapdbinstance && require('./graphdb').getImportantOperations() > 0;\n\t// setTimeout(() => process.exit(signal), global.TEST || extenddelay ? 2000 : 300);\n\tsetTimeout(() => process.exit(1), global.TEST ? 2000 : 300);\n\treturn F;\n};\n\n\nglobal.PROXY = F.proxy = function(url, target, copypath, before, after) {\n\n\tif (typeof(copypath) == 'function') {\n\t\tafter = before;\n\t\tbefore = copypath;\n\t\tcopypath = false;\n\t}\n\n\tvar obj = { url: url, uri: require('url').parse(target), before: before, after: after, copypath: copypath };\n\tF.routes.proxies.push(obj);\n\tF._request_check_proxy = true;\n};\n\nglobal.REDIRECT = F.redirect = function(host, newHost, withPath, permanent) {\n\n\tvar external = host.startsWith('http://') || host.startsWith('https');\n\tif (external) {\n\n\t\tif (host[host.length - 1] === '/')\n\t\t\thost = host.substring(0, host.length - 1);\n\n\t\tif (newHost[newHost.length - 1] === '/')\n\t\t\tnewHost = newHost.substring(0, newHost.length - 1);\n\n\t\tF.routes.redirects[host] = { url: newHost, path: withPath, permanent: permanent };\n\t\tF._request_check_redirect = true;\n\t\tF.owners.push({ type: 'redirects', owner: _owner, id: host });\n\t\treturn F;\n\t}\n\n\tif (host[0] !== '/')\n\t\thost = '/' + host;\n\n\tvar flags;\n\n\tif (withPath instanceof Array) {\n\t\tflags = withPath;\n\t\twithPath = permanent === true;\n\t} else if (permanent instanceof Array) {\n\t\tflags = permanent;\n\t\twithPath = withPath === true;\n\t} else\n\t\twithPath = withPath === true;\n\n\tpermanent = withPath;\n\n\tif (U.isStaticFile(host)) {\n\t\tF.file(host, function(req, res) {\n\t\t\tif (newHost.startsWith('http://') || newHost.startsWith('https://'))\n\t\t\t\tres.redirect(newHost, permanent);\n\t\t\telse\n\t\t\t\tres.redirect(newHost[0] !== '/' ? '/' + newHost : newHost, permanent);\n\t\t});\n\t\treturn F;\n\t}\n\n\tF.route(host, function() {\n\n\t\tif (newHost.startsWith('http://') || newHost.startsWith('https://')) {\n\t\t\tthis.redirect(newHost + this.href(), permanent);\n\t\t\treturn;\n\t\t}\n\n\t\tif (newHost[0] !== '/')\n\t\t\tnewHost = '/' + newHost;\n\n\t\tthis.redirect(newHost + this.href(), permanent);\n\t}, flags);\n\n\treturn F;\n};\n\n/**\n * Schedule job\n * @param {Date or String} date\n * @param {Boolean} repeat Repeat schedule\n * @param {Function} fn\n * @return {Framework}\n */\nglobal.SCHEDULE = F.schedule = function(date, repeat, fn) {\n\n\tif (fn === undefined) {\n\t\tfn = repeat;\n\t\trepeat = false;\n\t}\n\n\tvar type = typeof(date);\n\n\tif (type === 'string') {\n\t\tdate = date.parseDate().toUTC();\n\t\trepeat && date < NOW && (date = date.add(repeat));\n\t} else if (type === 'number')\n\t\tdate = new Date(date);\n\n\tvar sum = date.getTime();\n\trepeat && (repeat = repeat.replace('each', '1'));\n\tvar id = U.GUID(5);\n\tF.schedules[id] = { expire: sum, fn: fn, repeat: repeat, owner: _owner };\n\treturn id;\n};\n\nF.clearSchedule = function(id) {\n\tdelete F.schedules[id];\n\treturn F;\n};\n\n/**\n * Auto resize picture according the path\n * @param {String} url Relative path.\n * @param {Function(image)} fn Processing.\n * @param {String Array} flags Optional, can contains extensions `.jpg`, `.gif' or watching path `/img/gallery/`\n * @return {Framework}\n */\nglobal.RESIZE = F.resize = function(url, fn, flags) {\n\n\tvar extensions = {};\n\tvar cache = true;\n\n\tif (typeof(flags) === 'function') {\n\t\tvar tmp = flags;\n\t\tflags = fn;\n\t\tfn = tmp;\n\t}\n\n\tvar ext = url.match(/\\*.\\*$|\\*?\\.(jpg|png|gif|jpeg|heif|heic|apng)$/gi);\n\tif (ext) {\n\t\turl = url.replace(ext, '');\n\t\tswitch (ext.toString().toLowerCase()) {\n\t\t\tcase '*.*':\n\t\t\t\textensions['*'] = true;\n\t\t\t\tbreak;\n\t\t\tcase '*.jpg':\n\t\t\tcase '*.gif':\n\t\t\tcase '*.png':\n\t\t\tcase '*.heif':\n\t\t\tcase '*.heic':\n\t\t\tcase '*.apng':\n\t\t\tcase '*.jpeg':\n\t\t\t\textensions[ext.toString().toLowerCase().replace(/\\*/g, '').substring(1)] = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar path = url;\n\n\tif (flags && flags.length) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\t\t\tvar flag = flags[i];\n\t\t\tif (flag[0] === '.')\n\t\t\t\textensions[flag.substring(1)] = true;\n\t\t\telse if (flag[0] === '~' || flag[0] === '/' || flag.match(/^http:|https:/gi))\n\t\t\t\tpath = flag;\n\t\t\telse if (flag === 'nocache')\n\t\t\t\tcache = false;\n\t\t}\n\t}\n\n\tif (!extensions.length) {\n\t\textensions['jpg'] = true;\n\t\textensions['jpeg'] = true;\n\t\textensions['png'] = true;\n\t\textensions['gif'] = true;\n\t\textensions['heic'] = true;\n\t\textensions['heif'] = true;\n\t\textensions['apng'] = true;\n\t}\n\n\tif (extensions['jpg'] && !extensions['jpeg'])\n\t\textensions['jpeg'] = true;\n\telse if (extensions['jpeg'] && !extensions['jpg'])\n\t\textensions['jpg'] = true;\n\n\tF.routes.resize[url] = { fn: fn, path: U.path(path || url), ishttp: path.match(/http:|https:/gi) ? true : false, extension: extensions, cache: cache };\n\tF.owners.push({ type: 'resize', owner: _owner, id: url });\n\treturn F;\n};\n\n/**\n * RESTful routing\n * @param {String} url A relative url.\n * @param {String Array} flags\n * @param {Function} onQuery\n * @param {Function(id)} onGet\n * @param {Function([id])} onSave\n * @param {Function(id)} onDelete\n * @return {Framework}\n */\nF.restful = function(url, flags, onQuery, onGet, onSave, onDelete) {\n\n\tOBSOLETE('F.restful()', 'This method will be removed in v4.');\n\n\tvar tmp;\n\tvar index = flags ? flags.indexOf('cors') : -1;\n\tvar cors = {};\n\n\tif (index !== -1)\n\t\tflags.splice(index, 1);\n\n\tif (onQuery) {\n\t\ttmp = [];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onQuery);\n\t\tcors['get'] = true;\n\t}\n\n\tvar restful = U.path(url) + '{id}';\n\n\tif (onGet) {\n\t\tcors['get'] = true;\n\t\ttmp = [];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(restful, tmp, onGet);\n\t}\n\n\tif (onSave) {\n\t\tcors['post'] = true;\n\t\ttmp = ['post'];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onSave);\n\t\ttmp = ['put'];\n\t\tcors['put'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(restful, tmp, onSave);\n\t}\n\n\tif (onDelete) {\n\t\tcors['delete'] = true;\n\t\ttmp = ['delete'];\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(restful, tmp, onDelete);\n\t}\n\n\tif (index !== -1)\n\t\tF.cors(U.path(url) + '*', Object.keys(cors), flags.indexOf('authorize') === -1);\n\n\treturn F;\n};\n\n// This version of RESTful doesn't create advanced routing for insert/update/delete and all URL address of all operations are without \"{id}\" param because they expect some identificator in request body\nF.restful2 = function(url, flags, onQuery, onGet, onSave, onDelete) {\n\n\tOBSOLETE('F.restful2()', 'This method will be removed in v4.');\n\n\tvar tmp;\n\tvar index = flags ? flags.indexOf('cors') : -1;\n\tvar cors = {};\n\n\tif (index !== -1)\n\t\tflags.splice(index, 1);\n\n\tif (onQuery) {\n\t\ttmp = [];\n\t\tcors['get'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onQuery);\n\t}\n\n\tif (onGet) {\n\t\ttmp = [];\n\t\tcors['get'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(U.path(url) + '{id}', tmp, onGet);\n\t}\n\n\tif (onSave) {\n\t\ttmp = ['post'];\n\t\tcors['post'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onSave);\n\t}\n\n\tif (onDelete) {\n\t\ttmp = ['delete'];\n\t\tcors['delete'] = true;\n\t\tflags && tmp.push.apply(tmp, flags);\n\t\tF.route(url, tmp, onDelete);\n\t}\n\n\tif (index !== -1)\n\t\tF.cors(U.path(url) + '*', Object.keys(cors), flags.indexOf('authorize') === -1);\n\n\treturn F;\n};\n\n/**\n * Register cors\n * @param {String} url\n * @param {String Array or String} origin\n * @param {String Array or String} methods\n * @param {String Array or String} headers\n * @param {Boolean} credentials\n * @return {Framework}\n */\nglobal.CORS = F.cors = function(url, flags, credentials) {\n\n\tif (!arguments.length) {\n\t\tF.routes.corsall = true;\n\t\tPERF.OPTIONS = true;\n\t\treturn F;\n\t}\n\n\tif (flags === true) {\n\t\tcredentials = true;\n\t\tflags = null;\n\t}\n\n\tvar route = {};\n\tvar origin = [];\n\tvar methods = [];\n\tvar headers = [];\n\tvar age;\n\tvar id;\n\n\tif (flags instanceof Array) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\t\t\tvar flag = flags[i];\n\t\t\tvar type = typeof(flag);\n\n\t\t\tif (type === 'string')\n\t\t\t\tflag = flag.toLowerCase();\n\t\t\telse if (type === 'number') {\n\t\t\t\tage = flag;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type === 'boolean' || flag.startsWith('credential')) {\n\t\t\t\tcredentials = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flag.substring(0, 2) === '//') {\n\t\t\t\torigin.push(flag.substring(2));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flag.startsWith('http://') || flag.startsWith('https://')) {\n\t\t\t\torigin.push(flag.substring(flag.indexOf('/') + 2));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flag.substring(0, 3) === 'id:') {\n\t\t\t\tid = flag.substring(3);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (flag) {\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'put':\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'options':\n\t\t\t\tcase 'patch':\n\t\t\t\tcase 'head':\n\t\t\t\tcase 'get':\n\t\t\t\t\tmethods.push(flag.toUpperCase());\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\theaders.push(flags[i].toLowerCase());\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!methods.length)\n\t\tmethods = 'POST,PUT,GET,DELETE,PATCH,GET,HEAD'.split(',');\n\n\tif (!origin.length && CONF.default_cors)\n\t\torigin = CONF.default_cors;\n\n\troute.isWILDCARD = url.lastIndexOf('*') !== -1;\n\n\tvar index = url.indexOf('{');\n\tif (index !== -1) {\n\t\troute.isWILDCARD = true;\n\t\turl = url.substring(0, index);\n\t}\n\n\tif (route.isWILDCARD)\n\t\turl = url.replace('*', '');\n\n\tif (url[url.length - 1] !== '/')\n\t\turl += '/';\n\n\turl = framework_internal.preparePath(framework_internal.encodeUnicodeURL(url.trim()));\n\troute.hash = url.hash();\n\troute.owner = _owner;\n\troute.url = framework_internal.routeSplitCreate(url);\n\troute.origin = origin.length ? origin : null;\n\troute.methods = methods.length ? methods : null;\n\troute.headers = headers.length ? headers : null;\n\troute.credentials = credentials;\n\troute.age = age || CONF.default_cors_maxage;\n\n\tvar e = F.routes.cors.findItem(function(item) {\n\t\treturn item.hash === route.hash;\n\t});\n\n\tif (e) {\n\n\t\t// Extends existing\n\t\tif (route.origin && e.origin)\n\t\t\tcorsextend(route.origin, e.origin);\n\t\telse if (e.origin && !route.origin)\n\t\t\te.origin = null;\n\n\t\tif (route.methods && e.methods)\n\t\t\tcorsextend(route.methods, e.methods);\n\n\t\tif (route.headers && e.headers)\n\t\t\tcorsextend(route.headers, e.headers);\n\n\t\tif (route.credentials && !e.credentials)\n\t\t\te.credentials = true;\n\n\t\tif (route.isWILDCARD && !e.isWILDCARD)\n\t\t\te.isWILDCARD = true;\n\n\t} else {\n\t\tF.routes.cors.push(route);\n\t\troute.id = id;\n\t}\n\n\tF._length_cors = F.routes.cors.length;\n\n\tF.routes.cors.sort(function(a, b) {\n\t\tvar al = a.url.length;\n\t\tvar bl = b.url.length;\n\t\treturn al > bl ? - 1 : al < bl ? 1 : a.isWILDCARD && b.isWILDCARD ? 1 : 0;\n\t});\n\n\tPERF.OPTIONS = true;\n\treturn F;\n};\n\nfunction corsextend(a, b) {\n\tfor (var i = 0; i < a.length; i++)\n\t\tb.indexOf(a[i]) === -1 && b.push(a[i]);\n}\n\nglobal.GROUP = F.group = function() {\n\n\tvar fn = null;\n\n\t_flags = null;\n\t_prefix = null;\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar o = arguments[i];\n\n\t\tif (o instanceof Array) {\n\t\t\t_flags = o;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (typeof(o)) {\n\t\t\tcase 'string':\n\t\t\t\tif (o.indexOf('/') === -1) {\n\t\t\t\t\t// flags\n\t\t\t\t\t_flags = o.split(',').trim();\n\t\t\t\t} else {\n\t\t\t\t\tif (o.endsWith('/'))\n\t\t\t\t\t\to = o.substring(0, o.length - 1);\n\t\t\t\t\t_prefix = o;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'function':\n\t\t\t\tfn = o;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfn && fn.call(F);\n\t_prefix = undefined;\n\t_flags = undefined;\n\treturn F;\n};\n\nglobal.ROUTE = F.web = F.route = function(url, funcExecute, flags, length, language) {\n\n\tvar name;\n\tvar tmp;\n\tvar viewname;\n\tvar sitemap;\n\n\tif (url instanceof Array) {\n\t\turl.forEach(url => F.route(url, funcExecute, flags, length));\n\t\treturn F;\n\t}\n\n\tif (typeof(flags) === 'number') {\n\t\tlength = flags;\n\t\tflags = null;\n\t}\n\n\tvar type = typeof(funcExecute);\n\n\tif (funcExecute instanceof Array) {\n\t\ttmp = funcExecute;\n\t\tfuncExecute = flags;\n\t\tflags = tmp;\n\t}\n\n\tvar search = (typeof(url) === 'string' ? url.toLowerCase().replace(/\\s{2,}/g, ' ') : '') + (flags ? (' ' + flags.where(n => typeof(n) === 'string' && n.substring(0, 2) !== '//' && n[2] !== ':').join(' ')).toLowerCase() : '');\n\tvar method = '';\n\tvar CUSTOM = typeof(url) === 'function' ? url : null;\n\tif (CUSTOM)\n\t\turl = '/';\n\n\tif (url) {\n\n\t\turl = url.replace(/\\t/g, ' ').trim();\n\n\t\tvar first = url.substring(0, 1);\n\t\tif (first === '+' || first === '-' || url.substring(0, 2) === 'ð') {\n\t\t\t// auth/unauth\n\t\t\turl = url.replace(/^(\\+|-|ð)+/g, '').trim();\n\t\t\t!flags && (flags = []);\n\t\t\tflags.push(first === '-' ? 'unauthorized' : 'authorized');\n\t\t}\n\n\t\turl = url.replace(/(^|\\s?)\\*([{}a-z0-9}]|\\s).*?$/i, function(text) {\n\t\t\t!flags && (flags = []);\n\t\t\tflags.push(text.trim());\n\t\t\treturn '';\n\t\t}).trim();\n\n\t\tvar index = url.indexOf(' ');\n\t\tif (index !== -1) {\n\t\t\tmethod = url.substring(0, index).toLowerCase().trim();\n\t\t\turl = url.substring(index + 1).trim();\n\t\t}\n\n\t\tif (method.indexOf(',') !== -1) {\n\t\t\t!flags && (flags = []);\n\t\t\tmethod.split(',').forEach(m => flags.push(m.trim()));\n\t\t\tmethod = '';\n\t\t}\n\t}\n\n\tif (url[0] === '#') {\n\t\turl = url.substring(1);\n\t\tif (url !== '400' && url !== '401' && url !== '403' && url !== '404' && url !== '408' && url !== '409' && url !== '431' && url !== '500' && url !== '501') {\n\n\t\t\tvar sitemapflags = funcExecute instanceof Array ? funcExecute : flags;\n\t\t\tif (!(sitemapflags instanceof Array))\n\t\t\t\tsitemapflags = EMPTYARRAY;\n\n\t\t\tvar index = url.indexOf('/');\n\t\t\tif (index !== -1) {\n\t\t\t\ttmp = url.substring(index);\n\t\t\t\turl = url.substring(0, index);\n\t\t\t} else\n\t\t\t\ttmp = '';\n\n\t\t\tsitemap = F.sitemap(url, true, language);\n\n\t\t\tif (sitemap) {\n\n\t\t\t\tname = url;\n\t\t\t\turl = sitemap.url;\n\n\t\t\t\tif (sitemap.localizeUrl && language === undefined) {\n\t\t\t\t\tvar sitemaproutes = {};\n\t\t\t\t\tF.temporary.internal.resources.forEach(function(language) {\n\t\t\t\t\t\tvar item = F.sitemap(sitemap.id, true, language);\n\t\t\t\t\t\tif (item.url && item.url !== url)\n\t\t\t\t\t\t\tsitemaproutes[item.url] = { name: sitemap.id, language: language };\n\t\t\t\t\t});\n\t\t\t\t\tObject.keys(sitemaproutes).forEach(key => F.route('#' + sitemap.id, funcExecute, flags, length, sitemaproutes[key].language));\n\t\t\t\t}\n\n\t\t\t\tif (tmp)\n\t\t\t\t\turl += url[url.length - 1] === '/' ? tmp.substring(1) : tmp;\n\t\t\t\telse if (sitemap.wildcard)\n\t\t\t\t\turl += '*';\n\t\t\t} else\n\t\t\t\tthrow new Error('Sitemap item \"' + url + '\" not found.');\n\t\t} else\n\t\t\turl = '#' + url;\n\t}\n\n\tif (!url)\n\t\turl = '/';\n\n\tif (url[0] !== '[' && url[0] !== '/')\n\t\turl = '/' + url;\n\n\tif (_prefix)\n\t\turl = _prefix + url;\n\n\tif (url.endsWith('/'))\n\t\turl = url.substring(0, url.length - 1);\n\n\turl = framework_internal.encodeUnicodeURL(url);\n\n\tvar urlcache = url;\n\n\tif (!name)\n\t\tname = url;\n\n\tif (method) {\n\t\t!flags && (flags = []);\n\t\tflags.push(method);\n\t\tmethod = '';\n\t}\n\n\tvar priority = 0;\n\tvar subdomain = null;\n\n\tpriority = url.count('/');\n\n\tif (url[0] === '[') {\n\t\tindex = url.indexOf(']');\n\t\tif (index > 0) {\n\t\t\tsubdomain = url.substring(1, index).trim().toLowerCase().split(',');\n\t\t\turl = url.substring(index + 1);\n\t\t\tpriority += subdomain.indexOf('*') !== -1 ? 50 : 100;\n\t\t}\n\t}\n\n\tvar isWILDCARD = url.indexOf('*') !== -1;\n\tif (isWILDCARD) {\n\t\turl = url.replace('*', '').replace('//', '/');\n\t\tpriority = priority - 100;\n\t}\n\n\tvar isRaw = false;\n\tvar isNOXHR = false;\n\tvar schema;\n\tvar workflow;\n\tvar isMOBILE = false;\n\tvar isJSON = false;\n\tvar isDELAY = false;\n\tvar isROBOT = false;\n\tvar isBINARY = false;\n\tvar isCORS = false;\n\tvar isROLE = false;\n\tvar novalidate = false;\n\tvar middleware = null;\n\tvar timeout;\n\tvar options;\n\tvar corsflags = [];\n\tvar membertype = 0;\n\tvar isGENERATOR = false;\n\tvar isDYNAMICSCHEMA = false;\n\tvar description;\n\tvar id = null;\n\tvar groups = [];\n\n\tif (_flags) {\n\t\t!flags && (flags = []);\n\t\t_flags.forEach(flag => flags.indexOf(flag) === -1 && flags.push(flag));\n\t}\n\n\tif (flags) {\n\n\t\ttmp = [];\n\t\tvar count = 0;\n\n\t\tfor (var i = 0; i < flags.length; i++) {\n\n\t\t\tvar tt = typeof(flags[i]);\n\n\t\t\tif (tt === 'number') {\n\t\t\t\ttimeout = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (tt === 'object') {\n\t\t\t\toptions = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tflags[i] = flags[i].replace(/\\t/g, ' ');\n\n\t\t\tvar first = flags[i][0];\n\t\t\tif (first === '&') {\n\t\t\t\tgroups.push(flags[i].substring(1).trim());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// ROUTE identificator\n\t\t\tif (flags[i].substring(0, 3) === 'id:') {\n\t\t\t\tid = flags[i].substring(3).trim();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first === '#') {\n\t\t\t\t!middleware && (middleware = []);\n\t\t\t\tmiddleware.push(flags[i].substring(1).trim());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (first === '*') {\n\n\t\t\t\tworkflow = flags[i].trim().substring(1);\n\t\t\t\tindex = workflow.indexOf('-->');\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tschema = workflow.substring(0, index).trim();\n\t\t\t\t\tworkflow = workflow.substring(index + 3).trim();\n\t\t\t\t} else {\n\t\t\t\t\tschema = workflow;\n\t\t\t\t\tworkflow = null;\n\t\t\t\t}\n\n\t\t\t\tschema = schema.replace(/\\\\/g, '/').split('/').trim();\n\n\t\t\t\tif (schema.length) {\n\n\t\t\t\t\tif (schema.length === 1) {\n\t\t\t\t\t\tschema[1] = schema[0];\n\t\t\t\t\t\tschema[0] = 'default';\n\t\t\t\t\t}\n\n\t\t\t\t\t// Is dynamic schema?\n\t\t\t\t\tif (schema[0][0] === '{') {\n\t\t\t\t\t\tisDYNAMICSCHEMA = true;\n\t\t\t\t\t\tschema[0] = schema[0].substring(1).trim();\n\t\t\t\t\t\tschema[1] = schema[1].substring(0, schema[1].length - 1).trim();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (schema[1][0] === '{') {\n\t\t\t\t\t\tisDYNAMICSCHEMA = true;\n\t\t\t\t\t\tschema[1] = schema[1].substring(1, schema[1].length - 1).trim();\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = schema[1].indexOf('#');\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tschema[2] = schema[1].substring(index + 1).trim();\n\t\t\t\t\t\tschema[1] = schema[1].substring(0, index).trim();\n\t\t\t\t\t\t(schema[2] && schema[2][0] !== '*') && (schema[2] = '*' + schema[2]);\n\t\t\t\t\t}\n\n\t\t\t\t} // else it's an operation\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Comment\n\t\t\tif (flags[i].substring(0, 3) === '// ') {\n\t\t\t\tdescription = flags[i].substring(3).trim();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar flag = flags[i].toString().toLowerCase();\n\t\t\tif (flag.startsWith('http://') || flag.startsWith('https://')) {\n\t\t\t\tcorsflags.push(flag);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tswitch (flag) {\n\n\t\t\t\tcase 'json':\n\t\t\t\t\tisJSON = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'delay':\n\t\t\t\t\tcount--;\n\t\t\t\t\tisDELAY = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'binary':\n\t\t\t\t\tisBINARY = true;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'cors':\n\t\t\t\t\tisCORS = true;\n\t\t\t\t\tcount--;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'credential':\n\t\t\t\tcase 'credentials':\n\t\t\t\t\tcorsflags.push(flag);\n\t\t\t\t\tcount--;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'sync':\n\t\t\t\tcase 'yield':\n\t\t\t\tcase 'synchronize':\n\t\t\t\t\tisGENERATOR = true;\n\t\t\t\t\tcount--;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase 'novalidate':\n\t\t\t\t\tnovalidate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'noxhr':\n\t\t\t\tcase '-xhr':\n\t\t\t\t\tisNOXHR = true;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'raw':\n\t\t\t\t\tisRaw = true;\n\t\t\t\t\ttmp.push(flag);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mobile':\n\t\t\t\t\tisMOBILE = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'robot':\n\t\t\t\t\tisROBOT = true;\n\t\t\t\t\tF._request_check_robot = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'authorize':\n\t\t\t\tcase 'authorized':\n\t\t\t\tcase 'logged':\n\t\t\t\t\tmembertype = 1;\n\t\t\t\t\tpriority += 2;\n\t\t\t\t\ttmp.push('authorize');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'unauthorize':\n\t\t\t\tcase 'unauthorized':\n\t\t\t\tcase 'unlogged':\n\t\t\t\t\tmembertype = 2;\n\t\t\t\t\tpriority += 2;\n\t\t\t\t\ttmp.push('unauthorize');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'referer':\n\t\t\t\tcase 'referrer':\n\t\t\t\t\ttmp.push('referer');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'get':\n\t\t\t\tcase 'head':\n\t\t\t\tcase 'options':\n\t\t\t\tcase 'patch':\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'propfind':\n\t\t\t\tcase 'put':\n\t\t\t\tcase 'trace':\n\t\t\t\t\ttmp.push(flag);\n\t\t\t\t\tmethod += (method ? ',' : '') + flag;\n\t\t\t\t\tcorsflags.push(flag);\n\t\t\t\t\tPERF[flag.toUpperCase()] = true;\n\t\t\t\t\tPERF[flag] = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (flag[0] === '@')\n\t\t\t\t\t\tisROLE = true;\n\t\t\t\t\ttmp.push(flag);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flag === 'get')\n\t\t\t\tpriority -= 2;\n\n\t\t}\n\n\t\tif (isROLE && !membertype) {\n\t\t\ttmp.push('authorize');\n\t\t\tpriority += 2;\n\t\t\tmembertype = 1;\n\t\t\tcount++;\n\t\t}\n\n\t\tflags = tmp;\n\t\tpriority += (count * 2);\n\t} else {\n\t\tflags = ['get'];\n\t\tmethod = 'get';\n\t}\n\n\tif (workflow && workflow[0] === '@') {\n\t\tvar tmpa = workflow.replace(/,/g, ' ').split('@').trim();\n\t\tvar rindex = null;\n\t\tfor (var i = 0; i < tmpa.length; i++) {\n\t\t\tvar a = tmpa[i].split(' ');\n\t\t\tif (a[1] && (/response|res/i).test(a[1]))\n\t\t\t\trindex = i;\n\t\t\ttmpa[i] = a[0];\n\t\t}\n\t\tworkflow = { id: tmpa.length > 1 ? tmpa : tmpa[0], index: rindex };\n\t}\n\n\tif (type === 'string') {\n\t\tviewname = funcExecute;\n\t\tfuncExecute = (function(name, sitemap, language, workflow) {\n\t\t\tvar themeName = U.parseTheme(name);\n\t\t\tif (themeName)\n\t\t\t\tname = prepare_viewname(name);\n\t\t\treturn function(id) {\n\t\t\t\tif (language && !this.language)\n\t\t\t\t\tthis.language = language;\n\t\t\t\tsitemap && this.sitemap(sitemap.id, language);\n\t\t\t\tif (name[0] === '~')\n\t\t\t\t\tthis.themeName = '';\n\t\t\t\telse if (themeName)\n\t\t\t\t\tthis.themeName = themeName;\n\t\t\t\tif (!this.route.workflow)\n\t\t\t\t\treturn this.view(name);\n\n\t\t\t\tvar self = this;\n\t\t\t\tif (this.route.workflow instanceof Object) {\n\t\t\t\t\tworkflow.view = name;\n\t\t\t\t\tif (workflow.id instanceof Array)\n\t\t\t\t\t\tcontroller_json_workflow_multiple.call(self, id);\n\t\t\t\t\telse\n\t\t\t\t\t\tcontroller_json_workflow.call(self, id);\n\t\t\t\t} else {\n\t\t\t\t\tthis.$exec(this.route.workflow, null, function(err, response) {\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tself.content(err);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tself.view(name, response);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t})(viewname, sitemap, language, workflow);\n\t} else if (typeof(funcExecute) !== 'function') {\n\n\t\tviewname = (sitemap && sitemap.url !== '/' ? sitemap.id : workflow ? '' : url) || '';\n\t\tif (!workflow || (!viewname && !workflow)) {\n\t\t\tif (viewname.endsWith('/'))\n\t\t\t\tviewname = viewname.substring(0, viewname.length - 1);\n\n\t\t\tindex = viewname.lastIndexOf('/');\n\t\t\tif (index !== -1)\n\t\t\t\tviewname = viewname.substring(index + 1);\n\n\t\t\tif (!viewname || viewname === '/')\n\t\t\t\tviewname = 'index';\n\n\t\t\tfuncExecute = (function(name, sitemap, language) {\n\t\t\t\treturn function(id) {\n\t\t\t\t\tvar self = this;\n\n\t\t\t\t\tif (language && !self.language)\n\t\t\t\t\t\tself.language = language;\n\n\t\t\t\t\tsitemap && self.sitemap(sitemap.id, language);\n\n\t\t\t\t\tif (name[0] === '~')\n\t\t\t\t\t\tself.themeName = '';\n\n\t\t\t\t\tif (!self.route.workflow)\n\t\t\t\t\t\treturn self.view(name);\n\n\t\t\t\t\tif (self.route.workflow instanceof Object) {\n\t\t\t\t\t\tworkflow.view = name;\n\t\t\t\t\t\tif (workflow.id instanceof Array)\n\t\t\t\t\t\t\tcontroller_json_workflow_multiple.call(self, id);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontroller_json_workflow.call(self, id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.$exec(self.route.workflow, null, function(err, response) {\n\t\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\t\tself.content(err);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tself.view(name, response);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t})(viewname, sitemap, language);\n\t\t} else if (workflow)\n\t\t\tfuncExecute = workflow.id instanceof Array ? controller_json_workflow_multiple : controller_json_workflow;\n\t}\n\n\tif (!isGENERATOR)\n\t\tisGENERATOR = (funcExecute.constructor.name === 'GeneratorFunction' || funcExecute.toString().indexOf('function*') === 0);\n\n\tvar url2 = framework_internal.preparePath(url.trim());\n\tvar urlraw = U.path(url2) + (isWILDCARD ? '*' : '');\n\tvar hash = url2.hash();\n\tvar routeURL = framework_internal.routeSplitCreate(url2);\n\tvar arr = [];\n\tvar params = [];\n\tvar reg = null;\n\tvar regIndex = null;\n\tvar dynamicidindex = -1;\n\n\tif (url.indexOf('{') !== -1) {\n\t\trouteURL.forEach(function(o, i) {\n\t\t\tif (o.substring(0, 1) !== '{')\n\t\t\t\treturn;\n\n\t\t\tarr.push(i);\n\n\t\t\tvar sub = o.substring(1, o.length - 1);\n\t\t\tvar name = o.substring(1, o.length - 1).trim();\n\n\t\t\tif (name === 'id')\n\t\t\t\tdynamicidindex = i;\n\n\t\t\tparams.push(name);\n\n\t\t\tif (sub[0] !== '/')\n\t\t\t\treturn;\n\n\t\t\tvar index = sub.lastIndexOf('/');\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\tif (!reg) {\n\t\t\t\treg = {};\n\t\t\t\tregIndex = [];\n\t\t\t}\n\n\t\t\tparams[params.length - 1] = 'regexp' + (regIndex.length + 1);\n\t\t\treg[i] = new RegExp(sub.substring(1, index), sub.substring(index + 1));\n\t\t\tregIndex.push(i);\n\t\t});\n\n\t\tpriority -= arr.length + 1;\n\t}\n\n\tif (url.indexOf('#') !== -1)\n\t\tpriority -= 100;\n\n\tif ((isJSON || flags.indexOf('xml') !== -1 || isRaw) && (flags.indexOf('delete') === -1 && flags.indexOf('post') === -1 && flags.indexOf('put') === -1) && flags.indexOf('patch') === -1) {\n\t\tflags.push('post');\n\t\tmethod += (method ? ',' : '') + 'post';\n\t\tpriority++;\n\t}\n\n\tif (flags.indexOf('upload') !== -1) {\n\t\tif (flags.indexOf('post') === -1 && flags.indexOf('put') === -1) {\n\t\t\tflags.push('post');\n\t\t\tmethod += (method ? ',' : '') + 'post';\n\t\t}\n\t}\n\n\tif (flags.indexOf('get') === -1 && flags.indexOf('options') === -1 && flags.indexOf('post') === -1 && flags.indexOf('delete') === -1 && flags.indexOf('put') === -1 && flags.indexOf('upload') === -1 && flags.indexOf('head') === -1 && flags.indexOf('trace') === -1 && flags.indexOf('patch') === -1 && flags.indexOf('propfind') === -1) {\n\t\tflags.push('get');\n\t\tmethod += (method ? ',' : '') + 'get';\n\t}\n\n\tif (CONF.allow_head && flags.indexOf('get') !== -1) {\n\t\tflags.append('head');\n\t\tmethod += (method ? ',' : '') + 'head';\n\t}\n\n\tif (flags.indexOf('referer') !== -1)\n\t\tF._request_check_referer = true;\n\n\tif (!F._request_check_POST && (flags.indexOf('delete') !== -1 || flags.indexOf('post') !== -1 || flags.indexOf('put') !== -1 || flags.indexOf('upload') !== -1 || flags.indexOf('json') !== -1 || flags.indexOf('patch') !== -1 || flags.indexOf('options') !== -1))\n\t\tF._request_check_POST = true;\n\n\tvar isMULTIPLE = false;\n\n\tif (method.indexOf(',') !== -1)\n\t\tisMULTIPLE = true;\n\n\tif (method.indexOf(',') !== -1 || method === '')\n\t\tmethod = undefined;\n\telse\n\t\tmethod = method.toUpperCase();\n\n\tif (name[1] === '#')\n\t\tname = name.substring(1);\n\n\tif (isBINARY && !isRaw) {\n\t\tisBINARY = false;\n\t\tconsole.warn('F.route() skips \"binary\" flag because the \"raw\" flag is not defined.');\n\t}\n\n\tif (workflow && workflow.id) {\n\t\tworkflow.meta = {};\n\t\tif (workflow.id instanceof Array) {\n\t\t\tfor (var i = 0; i < workflow.id.length; i++)\n\t\t\t\tworkflow.meta[workflow.id[i]] = i + 1;\n\t\t} else\n\t\t\tworkflow.meta[workflow.id] = 1;\n\t}\n\n\tif (subdomain)\n\t\tF._length_subdomain_web++;\n\n\tvar instance = new FrameworkRoute();\n\tvar r = instance.route;\n\tr.hash = hash;\n\tr.search = search.split(' ');\n\tr.id = id;\n\tr.name = name.trim();\n\tr.groups = flags_to_object(groups);\n\tr.priority = priority;\n\tr.sitemap = sitemap ? sitemap.id : '';\n\tr.schema = schema;\n\tr.novalidate = novalidate;\n\tr.workflow = workflow;\n\tr.subdomain = subdomain;\n\tr.description = description;\n\tr.controller = _controller ? _controller : 'unknown';\n\tr.owner = _owner;\n\tr.urlraw = urlraw;\n\tr.url = routeURL;\n\tr.param = arr;\n\tr.paramidindex = isDYNAMICSCHEMA ? dynamicidindex : -1;\n\tr.paramnames = params.length ? params : null;\n\tr.flags = flags || EMPTYARRAY;\n\tr.flags2 = flags_to_object(flags);\n\tr.method = method;\n\tr.execute = funcExecute;\n\tr.length = (length || CONF.default_request_maxlength) * 1024;\n\tr.middleware = middleware;\n\tr.timeout = timeout === undefined ? (isDELAY ? 0 : CONF.default_request_timeout) : timeout;\n\tr.isGET = flags.indexOf('get') !== -1;\n\tr.isMULTIPLE = isMULTIPLE;\n\tr.isJSON = isJSON;\n\tr.isXML = flags.indexOf('xml') !== -1;\n\tr.isRAW = isRaw;\n\tr.isBINARY = isBINARY;\n\tr.isMOBILE = isMOBILE;\n\tr.isROBOT = isROBOT;\n\tr.isMOBILE_VARY = isMOBILE;\n\tr.isGENERATOR = isGENERATOR;\n\tr.MEMBER = membertype;\n\tr.isWILDCARD = isWILDCARD;\n\tr.isROLE = isROLE;\n\tr.isREFERER = flags.indexOf('referer') !== -1;\n\tr.isHTTPS = flags.indexOf('https') !== -1;\n\tr.isHTTP = flags.indexOf('http') !== -1;\n\tr.isDEBUG = flags.indexOf('debug') !== -1;\n\tr.isRELEASE = flags.indexOf('release') !== -1;\n\tr.isBOTH = isNOXHR ? false : true;\n\tr.isXHR = flags.indexOf('xhr') !== -1;\n\tr.isUPLOAD = flags.indexOf('upload') !== -1;\n\tr.isSYSTEM = url.startsWith('/#');\n\tr.isCACHE = !url.startsWith('/#') && !CUSTOM && !arr.length && !isWILDCARD;\n\tr.isPARAM = arr.length > 0;\n\tr.isDELAY = isDELAY;\n\tr.isDYNAMICSCHEMA = isDYNAMICSCHEMA;\n\tr.CUSTOM = CUSTOM;\n\tr.options = options;\n\tr.regexp = reg;\n\tr.regexpIndexer = regIndex;\n\tr.type = 'web';\n\tr.remove = remove_route_web;\n\n\tif (r.isUPLOAD)\n\t\tPERF.upload = true;\n\tif (r.isJSON)\n\t\tPERF.json = true;\n\tif (r.isXML)\n\t\tPERF.xml = true;\n\tif (r.isBINARY)\n\t\tPERF.binary = true;\n\tif (r.MEMBER === 1)\n\t\tPERF.auth = true;\n\tif (r.MEMBER === 2)\n\t\tPERF.unauth = true;\n\n\tvar arr = method ? method.split(',') : EMPTYARRAY;\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tPERF[arr[i]] = true;\n\t\tPERF[arr[i].toLowerCase()] = true;\n\t}\n\n\tif (r.isSYSTEM)\n\t\tF.routes.system[url.substring(1)] = r;\n\telse {\n\t\tF.routes.web.push(r);\n\n\t\t// Appends cors route\n\t\tisCORS && F.cors(urlcache, corsflags);\n\t\t!_controller && F.$routesSort(1);\n\t}\n\n\tif (isMOBILE)\n\t\tF._request_check_mobile = true;\n\n\tEMIT('route', 'web', instance);\n\treturn instance;\n};\n\nfunction flags_to_object(flags) {\n\tvar obj = {};\n\tflags.forEach(flag => obj[flag] = true);\n\treturn obj;\n}\n\nfunction remove_route_web() {\n\n\tif (this.isSYSTEM) {\n\t\tvar keys = Object.keys(F.routes.system);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tif (F.routes.system[keys[i]] === this) {\n\t\t\t\tdelete F.routes.system[keys];\n\t\t\t\tF.temporary.other = {};\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar index = F.routes.web.indexOf(this);\n\tif (index !== -1) {\n\t\tF.routes.web.splice(index, 1);\n\t\tF.$routesSort();\n\t\tF.temporary.other = {};\n\t}\n}\n\n/**\n * Get routing by name\n * @param {String} name\n * @return {Object}\n */\nglobal.ROUTING = F.routing = function(name, flags) {\n\n\tvar id = name.substring(0, 3) === 'id:' ? name.substring(3) : null;\n\tif (id)\n\t\tname = null;\n\n\tvar search = id ? null : (name.toLowerCase().replace(/\\s{2,}/g, ' ') + (flags ? (' ' + flags.where(n => typeof(n) === 'string' && n.substring(0, 2) !== '//' && n[2] !== ':').join(' ')).toLowerCase() : '')).split(' ');\n\n\tfor (var i = 0, length = F.routes.web.length; i < length; i++) {\n\t\tvar route = F.routes.web[i];\n\t\tvar is = true;\n\t\tif (id && route.id !== id)\n\t\t\tis = false;\n\t\telse if (search) {\n\t\t\tfor (var j = 0; j < search.length; j++) {\n\t\t\t\tif (route.search.indexOf(search[j]) === -1) {\n\t\t\t\t\tis = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!is)\n\t\t\tcontinue;\n\n\t\tvar url = U.path(route.url.join('/'));\n\t\tif (url[0] !== '/')\n\t\t\turl = '/' + url;\n\n\t\treturn route;\n\t}\n};\n\n/**\n * Merge files\n * @param {String} url Relative URL.\n * @param {String/String Array} file1 Filename or URL.\n * @param {String/String Array} file2 Filename or URL.\n * @param {String/String Array} file3 Filename or URL.\n * @param {String/String Array} fileN Filename or URL.\n * @return {Framework}\n */\nglobal.MERGE = F.merge = function(url) {\n\n\tF.temporary.other['merge_' + url] = 1;\n\n\tif (url[0] === '#')\n\t\turl = sitemapurl(url.substring(1));\n\n\turl = F.$version(framework_internal.preparePath(url));\n\n\tif (url === 'auto') {\n\t\t// auto-generating\n\t\tvar arg = arguments;\n\t\tsetTimeout(function(arg) {\n\t\t\tF.merge.apply(F, arg);\n\t\t}, 500, arg);\n\t\treturn F;\n\t}\n\n\tvar arr = [];\n\n\tfor (var i = 1, length = arguments.length; i < length; i++) {\n\n\t\tvar items = arguments[i];\n\t\tif (!(items instanceof Array))\n\t\t\titems = [items];\n\n\t\tfor (var j = 0, lengthsub = items.length; j < lengthsub; j++) {\n\t\t\tvar fn = items[j];\n\t\t\tvar c = fn[0];\n\t\t\tif (c === '@')\n\t\t\t\tfn = '~' + F.path.package(fn.substring(1));\n\t\t\telse if (c === '=')\n\t\t\t\tfn = '~' + F.path.themes(fn.substring(1));\n\t\t\telse if (c === '#')\n\t\t\t\tfn = '~' + F.path.temp('isomorphic_' + fn.substring(1) + '.min.js');\n\t\t\tarr.push(fn);\n\t\t}\n\t}\n\n\tif (url[0] !== '/')\n\t\turl = '/' + url;\n\n\tvar key = createTemporaryKey(url);\n\tvar filename = F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'merged_' + key);\n\tF.routes.merge[url] = { filename: filename.replace(/\\.(js|css)$/g, ext => '.min' + ext), files: arr };\n\tFs.unlink(F.routes.merge[url].filename, NOOP);\n\tF.owners.push({ type: 'merge', owner: _owner, id: url });\n\tdelete F.temporary.notfound[key];\n\treturn F;\n};\n\nF.mapping = function() {\n\treturn F.map.apply(F, arguments);\n};\n\n/**\n * Send message\n * @param  {Object} message\n * @param  {Object} handle\n * @return {Framework}\n */\nF.send = function(message, handle) {\n\tprocess.send(message, handle);\n\treturn F;\n};\n\n/**\n * Mapping of static file\n * @param {String} url\n * @param {String} filename\tFilename or Directory.\n * @param {Function(filename) or String Array} filter\n * @return {Framework}\n */\nglobal.MAP = F.map = function(url, filename, filter) {\n\n\tif (url[0] === '#')\n\t\turl = sitemapurl(url.substring(1));\n\n\tif (url[0] !== '/')\n\t\turl = '/' + url;\n\n\tvar isPackage = false;\n\n\tfilename = U.$normalize(filename);\n\turl = framework_internal.preparePath(F.$version(url));\n\n\t// isomorphic\n\tif (filename[0] === '#') {\n\t\tF.owners.push({ type: 'mapping', owner: _owner, id: url });\n\t\tF.routes.mapping[url] = F.path.temp('isomorphic_' + filename.substring(1) + '.min.js');\n\t\treturn F;\n\t}\n\n\tvar index = filename.indexOf('#');\n\tvar block;\n\n\tif (index !== -1) {\n\t\tvar tmp = filename.split('#');\n\t\tfilename = tmp[0];\n\t\tblock = tmp[1];\n\t}\n\n\tvar c = filename[0];\n\n\t// package\n\tif (c === '@') {\n\t\tfilename = F.path.package(filename.substring(1));\n\t\tisPackage = true;\n\t} else if (c === '=') {\n\t\tif (F.isWindows)\n\t\t\tfilename = U.combine(CONF.directory_themes, filename.substring(1));\n\t\telse\n\t\t\tfilename = F.path.themes(filename.substring(1));\n\t\tisPackage = true;\n\t}\n\n\tvar isFile = U.getExtension(filename).length > 0;\n\n\t// Checks if the directory exists\n\tif (!isPackage && !filename.startsWith(directory)) {\n\t\tvar tmp = filename[0] === '~' ? F.path.root(filename.substring(1)) : F.path.public(filename);\n\t\tif (existsSync(tmp))\n\t\t\tfilename = tmp;\n\t}\n\n\tif (isFile) {\n\t\tF.routes.mapping[url] = filename;\n\t\tF.owners.push({ type: 'mapping', owner: _owner, id: url });\n\t\tif (block) {\n\t\t\tF.owners.push({ type: 'blocks', owner: _owner, id: url });\n\t\t\tF.routes.blocks[url] = block;\n\t\t}\n\t\treturn F;\n\t}\n\n\turl = U.path(url);\n\tfilename = U.path(filename);\n\n\tvar replace = filename;\n\tvar plus = '';\n\tvar isRoot = false;\n\n\tif (replace[0] === '/')\n\t\tisRoot = true;\n\n\tif (replace[0] === '~') {\n\t\tplus += '~';\n\t\treplace = replace.substring(1);\n\t}\n\n\tif (replace[0] === '.') {\n\t\tplus += '.';\n\t\treplace = replace.substring(1);\n\t}\n\n\tif (!isRoot && replace[0] === '/') {\n\t\tplus += '/';\n\t\treplace = replace.substring(1);\n\t}\n\n\tif (filter instanceof Array) {\n\t\tfor (var i = 0, length = filter.length; i < length; i++) {\n\t\t\tif (filter[i][0] === '.')\n\t\t\t\tfilter[i] = filter[i].substring(1);\n\t\t\tfilter[i] = filter[i].toLowerCase();\n\t\t}\n\t}\n\n\tsetTimeout(function() {\n\t\tU.ls(F.isWindows ? filename.replace(/\\//g, '\\\\') : filename, function(files) {\n\t\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\n\t\t\t\tif (F.isWindows)\n\t\t\t\t\tfiles[i] = files[i].replace(filename, '').replace(/\\\\/g, '/');\n\n\t\t\t\tvar file = files[i].replace(replace, '');\n\n\t\t\t\tif (filter) {\n\t\t\t\t\tif (typeof(filter) === 'function') {\n\t\t\t\t\t\tif (!filter(file))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (filter.indexOf(U.getExtension(file)) === -1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (file[0] === '/')\n\t\t\t\t\tfile = file.substring(1);\n\n\t\t\t\tvar key = url + file;\n\t\t\t\tF.routes.mapping[key] = plus + files[i];\n\t\t\t\tF.owners.push({ type: 'mapping', owner: _owner, id: key });\n\n\t\t\t\tif (block) {\n\t\t\t\t\tF.owners.push({ type: 'blocks', owner: _owner, id: key });\n\t\t\t\t\tF.routes.blocks[key] = block;\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t}, isPackage ? 500 : 1);\n\n\treturn F;\n};\n\n/**\n * Add a middleware\n * @param {String} name\n * @param {Function(req, res, next, options)} funcExecute\n * @return {Framework}\n */\nglobal.MIDDLEWARE = F.middleware = function(name, funcExecute) {\n\tF.install('middleware', name, funcExecute);\n\t_owner && F.owners.push({ type: 'middleware', owner: _owner, id: name });\n\treturn F;\n};\n\n/**\n * Uses middleware\n * @name {String or String Array} name\n * @url {String} url A url address (optional)\n * @types {String Array} It can be `web`, `file` or `websocket`\n * @first {Boolean} Optional, add a middleware as first\n * @return {Framework}\n */\nF.use = function(name, url, types, first) {\n\n\tif (typeof(name) === 'function') {\n\t\tvar tmp = 'mid' + GUID(5);\n\t\tMIDDLEWARE(tmp, name);\n\t\tname = tmp;\n\t}\n\n\tif (!url && !types) {\n\t\tif (name instanceof Array) {\n\t\t\tfor (var i = 0; i < name.length; i++)\n\t\t\t\tF.routes.request.push(name[i]);\n\t\t} else\n\t\t\tF.routes.request.push(name);\n\t\tF._length_request_middleware = F.routes.request.length;\n\t\treturn F;\n\t}\n\n\tif (url instanceof Array) {\n\t\ttypes = url;\n\t\turl = null;\n\t}\n\n\tif (url === '*')\n\t\turl = null;\n\n\tvar route;\n\n\tif (url)\n\t\turl = framework_internal.routeSplitCreate(framework_internal.preparePath(url.trim())).join('/');\n\n\tif (!types || types.indexOf('web') !== -1) {\n\t\tfor (var i = 0, length = F.routes.web.length; i < length; i++) {\n\t\t\troute = F.routes.web[i];\n\t\t\tif (url && !route.url.join('/').startsWith(url))\n\t\t\t\tcontinue;\n\t\t\t!route.middleware && (route.middleware = []);\n\t\t\tmerge_middleware(route.middleware, name, first);\n\t\t}\n\t}\n\n\tif (!types || types.indexOf('file') !== -1 || types.indexOf('files') !== -1) {\n\t\tfor (var i = 0, length = F.routes.files.length; i < length; i++) {\n\t\t\troute = F.routes.files[i];\n\t\t\tif (url && !route.url.join('/').startsWith(url))\n\t\t\t\tcontinue;\n\t\t\t!route.middleware && (route.middleware = []);\n\t\t\tmerge_middleware(route.middleware, name, first);\n\t\t}\n\t}\n\n\tif (!types || types.indexOf('websocket') !== -1 || types.indexOf('websockets') !== -1) {\n\t\tfor (var i = 0, length = F.routes.websockets.length; i < length; i++) {\n\t\t\troute = F.routes.websockets[i];\n\t\t\tif (url && !route.url.join('/').startsWith(url))\n\t\t\t\tcontinue;\n\t\t\t!route.middleware && (route.middleware = []);\n\t\t\tmerge_middleware(route.middleware, name, first);\n\t\t}\n\t}\n\n\treturn F;\n};\n\nfunction merge_middleware(a, b, first) {\n\n\tif (typeof(b) === 'string')\n\t\tb = [b];\n\n\tfor (var i = 0, length = b.length; i < length; i++) {\n\t\tvar index = a.indexOf(b[i]);\n\t\tif (index === -1) {\n\t\t\tif (first)\n\t\t\t\ta.unshift(b[i]);\n\t\t\telse\n\t\t\t\ta.push(b[i]);\n\t\t}\n\t}\n\n\treturn a;\n}\n\n/**\n * Add a new websocket route\n * @param {String} url\n * @param {Function()} funcInitialize\n * @param {String Array} flags Optional.\n * @param {String Array} protocols Optional, framework compares this array with request protocol (http or https)\n * @param {String Array} allow Optional, framework compares this array with \"origin\" request header\n * @param {Number} length Optional, maximum message length.\n * @param {String Array} middleware Optional, middlewares.\n * @param {Object} options Optional, additional options for middleware.\n * @return {Framework}\n */\nglobal.WEBSOCKET = F.websocket = function(url, funcInitialize, flags, length) {\n\n\tvar tmp;\n\n\tvar CUSTOM = typeof(url) === 'function' ? url : null;\n\tif (CUSTOM)\n\t\turl = '/';\n\n\tif (url[0] === '#') {\n\n\t\tvar index = url.indexOf('/');\n\t\tif (index !== -1) {\n\t\t\ttmp = url.substring(index);\n\t\t\turl = url.substring(0, index);\n\t\t}\n\n\t\turl = url.substring(1);\n\t\tvar sitemap = F.sitemap(url, true);\n\t\tif (sitemap) {\n\t\t\turl = sitemap.url;\n\t\t\tif (tmp)\n\t\t\t\turl += url[url.length - 1] === '/' ? tmp.substring(1) : tmp;\n\t\t\telse if (sitemap.wildcard)\n\t\t\t\turl += '*';\n\t\t} else\n\t\t\tthrow new Error('Sitemap item \"' + url + '\" not found.');\n\t}\n\n\tvar first = url.substring(0, 1);\n\tif (first === '+' || first === '-' || url.substring(0, 2) === 'ð') {\n\t\t// auth/unauth\n\t\turl = url.replace(/^(\\+|-|ð)+/g, '').trim();\n\t\t!flags && (flags = []);\n\t\tflags.push(first === '-' ? 'unauthorized' : 'authorized');\n\t}\n\n\tvar index = url.substring(0, 7).indexOf(' ');\n\tif (index !== -1)\n\t\turl = url.substring(index + 1).trim();\n\n\tif (url === '')\n\t\turl = '/';\n\n\t// Unicode encoding\n\turl = framework_internal.encodeUnicodeURL(url);\n\n\tvar priority = 0;\n\tvar index = url.indexOf(']');\n\tvar subdomain = null;\n\tvar middleware;\n\tvar allow;\n\tvar options;\n\tvar protocols;\n\tvar id;\n\tvar groups = [];\n\n\tpriority = url.count('/');\n\n\tif (index > 0) {\n\t\tsubdomain = url.substring(1, index).trim().toLowerCase().split(',');\n\t\turl = url.substring(index + 1);\n\t\tpriority += subdomain.indexOf('*') !== -1 ? 50 : 100;\n\t}\n\n\tvar isWILDCARD = url.indexOf('*') !== -1;\n\tif (isWILDCARD) {\n\t\turl = url.replace('*', '').replace('//', '/');\n\t\tpriority = (-10) - priority;\n\t}\n\n\tvar url2 = framework_internal.preparePath(url.trim());\n\tvar routeURL = framework_internal.routeSplitCreate(url2);\n\tvar arr = [];\n\tvar reg = null;\n\tvar regIndex = null;\n\tvar hash = url2.hash();\n\tvar urlraw = U.path(url2) + (isWILDCARD ? '*' : '');\n\tvar params = [];\n\n\tif (url.indexOf('{') !== -1) {\n\t\trouteURL.forEach(function(o, i) {\n\n\t\t\tif (o.substring(0, 1) !== '{')\n\t\t\t\treturn;\n\n\t\t\tarr.push(i);\n\n\t\t\tvar sub = o.substring(1, o.length - 1);\n\t\t\tvar name = o.substring(1, o.length - 1).trim();\n\n\t\t\tparams.push(name);\n\n\t\t\tif (sub[0] !== '/')\n\t\t\t\treturn;\n\n\t\t\tvar index = sub.lastIndexOf('/');\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\tif (!reg) {\n\t\t\t\treg = {};\n\t\t\t\tregIndex = [];\n\t\t\t}\n\n\t\t\tparams[params.length - 1] = 'regexp' + (regIndex.length + 1);\n\t\t\treg[i] = new RegExp(sub.substring(1, index), sub.substring(index + 1));\n\t\t\tregIndex.push(i);\n\t\t});\n\t}\n\n\tif (typeof(allow) === 'string')\n\t\tallow = allow[allow];\n\n\tif (typeof(protocols) === 'string')\n\t\tprotocols = protocols[protocols];\n\n\ttmp = [];\n\n\tvar isJSON = false;\n\tvar isBINARY = false;\n\tvar isROLE = false;\n\tvar isBUFFER = false;\n\tvar count = 0;\n\tvar membertype = 0;\n\n\t!flags && (flags = []);\n\t_flags && _flags.forEach(flag => flags.indexOf(flag) === -1 && flags.push(flag));\n\n\tfor (var i = 0; i < flags.length; i++) {\n\n\t\tvar flag = flags[i];\n\t\tvar type = typeof(flag);\n\n\t\t// Middleware options\n\t\tif (type === 'object') {\n\t\t\toptions = flag;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Length\n\t\tif (type === 'number') {\n\t\t\tlength = flag;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (flag.substring(0, 3) === 'id:') {\n\t\t\tid = flag.substring(3).trim();\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Groups\n\t\tif (flag[0] === '&') {\n\t\t\tgroups.push(flag.substring(1).trim());\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Middleware\n\t\tif (flag[0] === '#') {\n\t\t\t!middleware && (middleware = []);\n\t\t\tmiddleware.push(flag.substring(1).trim());\n\t\t\tcontinue;\n\t\t}\n\n\t\tflag = flag.toString().toLowerCase();\n\n\t\t// Origin\n\t\tif (flag.startsWith('http://') || flag.startsWith('https://')) {\n\t\t\t!allow && (allow = []);\n\t\t\tallow.push(flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount++;\n\n\t\tif (flag === 'json')\n\t\t\tisJSON = true;\n\n\t\tif (flag === 'binary')\n\t\t\tisBINARY = true;\n\n\t\tif (flag === 'raw') {\n\t\t\tisBINARY = false;\n\t\t\tisJSON = false;\n\t\t}\n\n\t\tif (flag === 'buffer')\n\t\t\tisBUFFER = true;\n\n\t\tif (flag[0] === '@') {\n\t\t\tisROLE = true;\n\t\t\ttmp.push(flag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (flag === 'json' || flag === 'binary' || flag === 'raw')\n\t\t\tcontinue;\n\n\t\tswitch (flag) {\n\t\t\tcase 'authorize':\n\t\t\tcase 'authorized':\n\t\t\tcase 'logged':\n\t\t\t\tmembertype = 1;\n\t\t\t\tpriority++;\n\t\t\t\ttmp.push('authorize');\n\t\t\t\tbreak;\n\t\t\tcase 'unauthorize':\n\t\t\tcase 'unauthorized':\n\t\t\tcase 'unlogged':\n\t\t\t\tmembertype = 2;\n\t\t\t\tpriority++;\n\t\t\t\ttmp.push('unauthorize');\n\t\t\t\tbreak;\n\t\t\tcase 'get':\n\t\t\tcase 'http':\n\t\t\tcase 'https':\n\t\t\tcase 'debug':\n\t\t\tcase 'release':\n\t\t\t\ttmp.push(flag);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t!protocols && (protocols = []);\n\t\t\t\tprotocols.push(flag);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isROLE && !membertype) {\n\t\ttmp.push('authorize');\n\t\tmembertype = 1;\n\t\tpriority++;\n\t\tcount++;\n\t}\n\n\tflags = tmp;\n\n\tflags.indexOf('get') === -1 && flags.unshift('get');\n\tpriority += (count * 2);\n\n\tif (subdomain)\n\t\tF._length_subdomain_websocket++;\n\n\tvar instance = new FrameworkRoute();\n\tvar r = instance.route;\n\tr.id = id;\n\tr.urlraw = urlraw;\n\tr.hash = hash;\n\tr.groups = flags_to_object(groups);\n\tr.controller = _controller ? _controller : 'unknown';\n\tr.owner = _owner;\n\tr.url = routeURL;\n\tr.paramnames = params.length ? params : null;\n\tr.param = arr;\n\tr.subdomain = subdomain;\n\tr.priority = priority;\n\tr.flags = flags || EMPTYARRAY;\n\tr.flags2 = flags_to_object(flags);\n\tr.onInitialize = funcInitialize;\n\tr.protocols = protocols || EMPTYARRAY;\n\tr.allow = allow || [];\n\tr.length = (length || CONF.default_websocket_maxlength) * 1024;\n\tr.isWEBSOCKET = true;\n\tr.MEMBER = membertype;\n\tr.isJSON = isJSON;\n\tr.isBUFFER = isBUFFER;\n\tr.isBINARY = isBINARY;\n\tr.isROLE = isROLE;\n\tr.isWILDCARD = isWILDCARD;\n\tr.isHTTPS = flags.indexOf('https');\n\tr.isHTTP = flags.indexOf('http');\n\tr.isDEBUG = flags.indexOf('debug');\n\tr.isRELEASE = flags.indexOf('release');\n\tr.CUSTOM = CUSTOM;\n\tr.middleware = middleware ? middleware : null;\n\tr.options = options;\n\tr.isPARAM = arr.length > 0;\n\tr.regexp = reg;\n\tr.regexpIndexer = regIndex;\n\tr.type = 'websocket';\n\tF.routes.websockets.push(r);\n\tF.initwebsocket && F.initwebsocket();\n\tEMIT('route', 'websocket', r);\n\t!_controller && F.$routesSort(2);\n\treturn instance;\n};\n\nF.initwebsocket = function() {\n\tif (F.routes.websockets.length && CONF.allow_websocket && F.server) {\n\t\tF.server.on('upgrade', F.$upgrade);\n\t\tF.initwebsocket = null;\n\t}\n};\n\n/**\n * Create a file route\n * @param {String} name\n * @param {Function} funcValidation\n * @param {Function} fnExecute\n * @param {String Array} middleware\n * @return {Framework}\n */\nglobal.FILE = F.file = function(fnValidation, fnExecute, flags) {\n\n\tvar a;\n\n\tif (fnValidation instanceof Array) {\n\t\ta = fnExecute;\n\t\tvar b = flags;\n\t\tflags = fnValidation;\n\t\tfnValidation = a;\n\t\tfnExecute = b;\n\t} else if (fnExecute instanceof Array) {\n\t\ta = fnExecute;\n\t\tfnExecute = flags;\n\t\tflags = a;\n\t}\n\n\tif (!fnExecute && fnValidation) {\n\t\tfnExecute = fnValidation;\n\t\tfnValidation = undefined;\n\t}\n\n\tvar extensions;\n\tvar middleware;\n\tvar options;\n\tvar url;\n\tvar wildcard = false;\n\tvar fixedfile = false;\n\tvar id = null;\n\tvar urlraw = fnValidation;\n\tvar groups = [];\n\n\tif (_flags) {\n\t\t!flags && (flags = []);\n\t\t_flags.forEach(flag => flags.indexOf(flag) === -1 && flags.push(flag));\n\t}\n\n\tif (flags) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\t\t\tvar flag = flags[i];\n\t\t\tif (typeof(flag) === 'object')\n\t\t\t\toptions = flag;\n\t\t\telse if (flag[0] === '&')\n\t\t\t\tgroups.push(flag.substring(1).trim());\n\t\t\telse if (flag[0] === '#') {\n\t\t\t\t!middleware && (middleware = []);\n\t\t\t\tmiddleware.push(flag.substring(1).trim());\n\t\t\t} else if (flag[0] === '.') {\n\t\t\t\tflag = flag.substring(1).toLowerCase().trim();\n\t\t\t\t!extensions && (extensions = {});\n\t\t\t\textensions[flag] = true;\n\t\t\t} else if (flag.substring(0, 3) === 'id:')\n\t\t\t\tid = flag.substring(3).trim();\n\t\t}\n\t}\n\n\tif (typeof(fnValidation) === 'string') {\n\n\t\tif (fnValidation === '/')\n\t\t\tfnValidation = '';\n\n\t\turl = fnValidation ? framework_internal.routeSplitCreate(fnValidation) : EMPTYARRAY;\n\t\tfnValidation = undefined;\n\t\ta = url.last();\n\t\tif (a === '*.*') {\n\t\t\twildcard = true;\n\t\t\turl.splice(url.length - 1, 1);\n\t\t} else if (a) {\n\t\t\tvar index = a.indexOf('*.');\n\t\t\tif (index !== -1) {\n\t\t\t\textensions = {};\n\t\t\t\textensions[a.substring(index + 2).trim()] = true;\n\t\t\t\twildcard = false;\n\t\t\t\turl.splice(url.length - 1, 1);\n\t\t\t} else if (a === '*') {\n\t\t\t\twildcard = true;\n\t\t\t\turl.splice(url.length - 1, 1);\n\t\t\t} else if (U.getExtension(a)) {\n\t\t\t\tfixedfile = true;\n\t\t\t\twildcard = false;\n\t\t\t}\n\t\t}\n\t} else if (!extensions && !fnValidation)\n\t\tfnValidation = fnExecute;\n\n\tvar instance = new FrameworkRoute();\n\tvar r = instance.route;\n\tr.id = id;\n\tr.urlraw = urlraw;\n\tr.groups = flags_to_object(groups);\n\tr.controller = _controller ? _controller : 'unknown';\n\tr.owner = _owner;\n\tr.url = url;\n\tr.fixedfile = fixedfile;\n\tr.wildcard = wildcard;\n\tr.extensions = extensions;\n\tr.onValidate = fnValidation;\n\tr.execute = fnExecute;\n\tr.middleware = middleware;\n\tr.options = options;\n\tr.type = 'file';\n\n\tF.routes.files.push(r);\n\tF.routes.files.sort((a, b) => !a.url ? -1 : !b.url ? 1 : a.url.length > b.url.length ? -1 : 1);\n\tEMIT('route', 'file', r);\n\tF._length_files = F.routes.files.length;\n\treturn F;\n};\n\nglobal.FILE404 = function(fn) {\n\tF.routes.filesfallback = fn;\n};\n\nfunction sitemapurl(url) {\n\n\tvar index = url.indexOf('/');\n\tvar tmp;\n\n\tif (index !== -1) {\n\t\ttmp = url.substring(index);\n\t\turl = url.substring(0, index);\n\t}\n\n\tvar sitemap = F.sitemap(url, true, '');\n\tif (sitemap) {\n\t\turl = sitemap.url;\n\t\tif (tmp) {\n\t\t\tif (url[url.length - 1] === '/')\n\t\t\t\turl += tmp.substring(1);\n\t\t\telse\n\t\t\t\turl += tmp;\n\t\t}\n\t}\n\n\treturn url;\n}\n\nglobal.LOCALIZE = F.localize = function(url, flags, minify) {\n\n\tif (typeof(url) === 'function') {\n\t\tF.onLocale = url;\n\t\treturn;\n\t}\n\n\tif (url[0] === '#')\n\t\turl = sitemapurl(url.substring(1));\n\n\turl = url.replace('*.*', '');\n\n\tif (minify == null)\n\t\tminify = true;\n\n\tif (flags === true) {\n\t\tflags = [];\n\t\tminify = true;\n\t} else if (!flags)\n\t\tflags = [];\n\n\tvar index;\n\tvar ext = false;\n\n\tflags = flags.remove(function(item) {\n\t\titem = item.toLowerCase();\n\t\tif (item === 'nocompress')\n\t\t\tminify = false;\n\t\tif (item[0] === '.')\n\t\t\text = true;\n\t\treturn item === 'compress' || item === 'nocompress' || item === 'minify';\n\t});\n\n\tvar index = url.lastIndexOf('.');\n\n\tif (!ext) {\n\t\tif (index === -1)\n\t\t\tflags.push('.html', '.htm', '.md', '.txt');\n\t\telse {\n\t\t\tflags.push(url.substring(index).toLowerCase());\n\t\t\turl = url.substring(0, index).replace('*', '');\n\t\t}\n\t}\n\n\turl = framework_internal.preparePath(url.replace('.*', ''));\n\n\tif (minify)\n\t\tF.file(url, F.$filelocalize, flags);\n\telse\n\t\tF.file(url, filelocalize_nominify, flags);\n};\n\nfunction filelocalize_nominify(req, res) {\n\tF.$filelocalize(req, res, true);\n}\n\nF.$filelocalize = function(req, res, nominify) {\n\n\t// options.filename\n\t// options.code\n\t// options.callback\n\t// options.headers\n\t// options.download\n\n\tF.onLocale && (req.$language = F.onLocale(req, res, req.isStaticFile));\n\n\tvar key = 'locate_' + (req.$language ? req.$language : 'default') + '_' + (req.$key || req.url);\n\tvar output = F.temporary.other[key];\n\n\tif (output) {\n\t\tif (!F.$notModified(req, res, output.$mtime)) {\n\t\t\tHEADERS.responseLocalize['Last-Modified'] = output.$mtime;\n\t\t\tres.options.body = output;\n\t\t\tres.options.type = U.getContentType(req.extension);\n\t\t\tres.$text();\n\t\t}\n\t\treturn;\n\t}\n\n\tvar filename = (res.options ? res.options.filename : null) || F.onMapping(req.uri.pathname, req.uri.pathname, true, true);\n\n\tFs.readFile(filename, function(err, content) {\n\n\t\tif (err) {\n\t\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(req, res))\n\t\t\t\tres.throw404();\n\t\t\treturn;\n\t\t}\n\n\t\tcontent = framework_internal.markup(F.translator(req.$language, framework_internal.modificators(content.toString(ENCODING), filename, 'static')), filename);\n\n\t\tFs.lstat(filename, function(err, stats) {\n\n\t\t\tvar mtime = stats.mtime.toUTCString();\n\n\t\t\tif (CONF.allow_compile_html && CONF.allow_compile && !nominify && (req.extension === 'html' || req.extension === 'htm'))\n\t\t\t\tcontent = framework_internal.compile_html(content, filename, true);\n\n\t\t\tif (RELEASE) {\n\t\t\t\tF.temporary.other[key] = Buffer.from(content);\n\t\t\t\tF.temporary.other[key].$mtime = mtime;\n\t\t\t\tif (F.$notModified(req, res, mtime))\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tHEADERS.responseLocalize['Last-Modified'] = mtime;\n\t\t\tres.options.body = content;\n\t\t\tres.options.type = U.getContentType(req.extension);\n\t\t\tres.options.headers = HEADERS.responseLocalize;\n\t\t\tres.$text();\n\t\t});\n\t});\n};\n\nF.$notModified = function(req, res, date) {\n\tif (date === req.headers['if-modified-since']) {\n\t\tHEADERS.responseNotModified['Last-Modified'] = date;\n\t\tres.success = true;\n\t\tres.writeHead(304, HEADERS.responseNotModified);\n\t\tres.end();\n\t\tF.stats.response.notModified++;\n\t\tF.reqstats(false, req.isStaticFile);\n\t\treturn true;\n\t}\n};\n\n/**\n * Error caller\n * @param {Error} err\n * @param {String} name Controller or Script name.\n * @param {Object} uri\n * @return {Framework}\n */\nF.error = function(err, name, uri) {\n\n\tif (!arguments.length)\n\t\treturn F.errorcallback;\n\n\tif (!err)\n\t\treturn F;\n\n\tif (F.errors) {\n\t\tF.stats.error++;\n\t\tNOW = new Date();\n\t\tF.errors.push({ error: err.stack ? err.stack : err, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, date: NOW });\n\t\tF.errors.length > 50 && F.errors.shift();\n\t}\n\n\tF.onError(err, name, uri);\n\treturn F;\n};\n\nF.errorcallback = function(err) {\n\terr && F.error(err);\n};\n\n/**\n * Registers a new problem\n * @param {String} message\n * @param {String} name A controller name.\n * @param {String} uri\n * @param {String} ip\n * @return {Framework}\n */\nF.problem = F.wtf = function(message, name, uri, ip) {\n\n\t// OBSOLETE('F.problem()', 'This method will be removed in v4');\n\n\tF.$events.problem && EMIT('problem', message, name, uri, ip);\n\n\tif (message instanceof framework_builders.ErrorBuilder)\n\t\tmessage = message.plain();\n\telse if (typeof(message) === 'object')\n\t\tmessage = JSON.stringify(message);\n\n\tvar obj = { message: message, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, ip: ip };\n\tF.logger('problems', obj.message, 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tif (F.problems) {\n\t\tF.problems.push(obj);\n\t\tF.problems.length > 50 && F.problems.shift();\n\t}\n\n\treturn F;\n};\n\nglobal.PRINTLN = function(msg) {\n\tconsole.log('------>', '[' + new Date().format('yyyy-MM-dd HH:mm:ss') + ']', msg);\n};\n\n/**\n * Registers a new change\n * @param {String} message\n * @param {String} name A source name.\n * @param {String} uri\n * @param {String} ip\n * @return {Framework}\n */\nF.change = function(message, name, uri, ip) {\n\n\tOBSOLETE('F.change()', 'This method will be removed in v4.');\n\n\tF.$events.change && EMIT('change', message, name, uri, ip);\n\n\tif (message instanceof framework_builders.ErrorBuilder)\n\t\tmessage = message.plain();\n\telse if (typeof(message) === 'object')\n\t\tmessage = JSON.stringify(message);\n\n\tvar obj = { message: message, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, ip: ip };\n\tF.logger('changes', obj.message, 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tif (F.changes) {\n\t\tF.changes.push(obj);\n\t\tF.changes.length > 50 && F.changes.shift();\n\t}\n\n\treturn F;\n};\n\n/**\n * Trace\n * @param {String} message\n * @param {String} name A controller name.\n * @param {String} uri\n * @param {String} ip\n * @return {Framework}\n */\nglobal.TRACE = F.trace = function(message, name, uri, ip) {\n\n\tOBSOLETE('TRACE()', 'This method will be removed in v4.');\n\n\tif (!CONF.trace)\n\t\treturn F;\n\n\tF.$events.trace && EMIT('trace', message, name, uri, ip);\n\n\tif (message instanceof framework_builders.ErrorBuilder)\n\t\tmessage = message.plain();\n\telse if (typeof(message) === 'object')\n\t\tmessage = JSON.stringify(message);\n\n\tNOW = new Date();\n\tvar obj = { message: message, name: name, url: uri ? typeof(uri) === 'string' ? uri : Parser.format(uri) : undefined, ip: ip, date: NOW };\n\tF.logger('traces', obj.message, 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tCONF.trace_console && console.log(NOW.format('yyyy-MM-dd HH:mm:ss'), '[trace]', message, '|', 'url: ' + obj.url, 'source: ' + obj.name, 'ip: ' + obj.ip);\n\n\tif (F.traces) {\n\t\tF.traces.push(obj);\n\t\tF.traces.length > 50 && F.traces.shift();\n\t}\n\n\treturn F;\n};\n\n/**\n * Get a module\n * @param {String} name\n * @return {Object}\n */\nglobal.MODULE = F.module = function(name) {\n\treturn F.modules[name] || null;\n};\n\n/**\n * Add a new modificator\n * @param {Function(type, filename, content)} fn The `fn` must return modified value.\n * @return {Framework}\n */\nglobal.MODIFY = F.modify = function(filename, fn) {\n\n\tif (typeof(filename) === 'function') {\n\t\tfn = filename;\n\t\tfilename = null;\n\t}\n\n\tif (filename) {\n\t\tif (!F.modificators2)\n\t\t\tF.modificators2 = {};\n\t\tif (F.modificators2[filename])\n\t\t\tF.modificators2[filename].push(fn);\n\t\telse\n\t\t\tF.modificators2[filename] = [fn];\n\t} else {\n\t\tif (!F.modificators)\n\t\t\tF.modificators = [];\n\t\tF.modificators.push(fn);\n\t}\n\n\tfn.$owner = _owner;\n\treturn F;\n};\n\nF.$bundle = function(callback) {\n\n\tvar bundledir = F.path.root(CONF.directory_bundles);\n\n\tvar makebundle = function() {\n\n\t\tvar arr = Fs.readdirSync(bundledir);\n\t\tvar url = [];\n\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i].endsWith('.url'))\n\t\t\t\turl.push(arr[i]);\n\t\t}\n\n\t\turl.wait(function(item, next) {\n\n\t\t\tvar filename = F.path.root(CONF.directory_bundles) + item.replace('.url', '.bundle');\n\t\t\tvar link = Fs.readFileSync(F.path.root(CONF.directory_bundles) + item).toString('utf8');\n\n\t\t\tF.consoledebug('Download bundle: ' + link);\n\n\t\t\tU.download(link, FLAGS_INSTALL, function(err, response) {\n\n\t\t\t\tif (err) {\n\t\t\t\t\tF.error(err, 'Bundle: ' + link);\n\t\t\t\t\tnext();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar stream = Fs.createWriteStream(filename);\n\n\t\t\t\tresponse.pipe(stream);\n\t\t\t\tresponse.on('error', function(err) {\n\t\t\t\t\tF.error(err, 'Bundle: ' + link);\n\t\t\t\t\tnext();\n\t\t\t\t});\n\n\t\t\t\tCLEANUP(stream, next);\n\t\t\t});\n\n\t\t}, function() {\n\t\t\trequire('./bundles').make(function() {\n\t\t\t\tF.directory = HEADERS.workers.cwd = directory = F.path.root(CONF.directory_src);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t});\n\t};\n\n\ttry {\n\t\tFs.statSync(bundledir);\n\t\tif (F.$bundling) {\n\t\t\tmakebundle();\n\t\t\treturn;\n\t\t} else\n\t\t\tF.directory = HEADERS.workers.cwd = directory = F.path.root(CONF.directory_src);\n\t} catch(e) {}\n\tcallback();\n};\n\nF.$load = function(types, targetdirectory, callback, packageName) {\n\n\tvar arr = [];\n\tvar dir = '';\n\n\tif (!targetdirectory)\n\t\ttargetdirectory = directory;\n\n\ttargetdirectory = '~' + targetdirectory;\n\n\tfunction listing(directory, level, output, extension, isTheme) {\n\n\t\tif (!existsSync(dir))\n\t\t\treturn;\n\n\t\tif (!extension)\n\t\t\textension = '.js';\n\n\t\tFs.readdirSync(directory).forEach(function(o) {\n\t\t\tvar isDirectory = Fs.statSync(Path.join(directory, o)).isDirectory();\n\n\t\t\tif (isDirectory && isTheme) {\n\t\t\t\toutput.push({ name: o });\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isDirectory) {\n\n\t\t\t\tif (extension === '.package' && o.endsWith(extension)) {\n\t\t\t\t\tvar name = o.substring(0, o.length - extension.length);\n\t\t\t\t\toutput.push({ name: name[0] === '/' ? name.substring(1) : name, filename: Path.join(dir, o), is: true });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlevel++;\n\t\t\t\tlisting(Path.join(directory, o), level, output, extension);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar ext = U.getExtension(o);\n\t\t\tif (ext)\n\t\t\t\text = '.' + ext;\n\t\t\tif (ext !== extension || o[0] === '.' || o.endsWith('-bk' + extension) || o.endsWith('_bk' + extension))\n\t\t\t\treturn;\n\n\t\t\tvar name = (level ? U.$normalize(directory).replace(dir, '') + '/' : '') + o.substring(0, o.length - ext.length);\n\t\t\toutput.push({ name: name[0] === '/' ? name.substring(1) : name, filename: Path.join(dir, name) + extension });\n\t\t});\n\t}\n\n\ttry {\n\t\t// Reads name of resources\n\t\tF.temporary.internal.resources = Fs.readdirSync(F.path.resources()).map(n => n.substring(0, n.lastIndexOf('.')));\n\t} catch (e) {\n\t\tF.temporary.internal.resources = [];\n\t}\n\n\tvar dependencies = [];\n\tvar operations = [];\n\tvar isPackage = targetdirectory.indexOf('.package') !== -1;\n\tvar isNo = true;\n\n\tif (types) {\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tif (types[i].substring(0, 2) !== 'no') {\n\t\t\t\tisNo = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar can = function(type) {\n\t\tif (!types)\n\t\t\treturn true;\n\t\tif (types.indexOf('no' + type) !== -1)\n\t\t\treturn false;\n\t\treturn isNo ? true : types.indexOf(type) !== -1;\n\t};\n\n\tif (can('modules')) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/modules/' : CONF.directory_modules);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr, '.js');\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('module', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('isomorphic')) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/isomorphic/' : CONF.directory_isomorphic);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr, '.js');\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('isomorphic', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('packages')) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/packages/' : CONF.directory_packages);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr, '.package');\n\t\t\tvar dirtmp = U.$normalize(dir);\n\n\t\t\tarr.wait(function(item, next2) {\n\n\t\t\t\tif (!item.is) {\n\t\t\t\t\tdependencies.push(next => F.install('package', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName));\n\t\t\t\t\treturn next2();\n\t\t\t\t}\n\n\t\t\t\tU.ls(item.filename, function(files, directories) {\n\t\t\t\t\tvar dir = F.path.temp(item.name) + '.package';\n\t\t\t\t\t!existsSync(dir) && Fs.mkdirSync(dir);\n\n\t\t\t\t\tfor (var i = 0, length = directories.length; i < length; i++) {\n\t\t\t\t\t\tvar target = F.path.temp(U.$normalize(directories[i]).replace(dirtmp, '') + '/');\n\t\t\t\t\t\t!existsSync(target) && Fs.mkdirSync(target);\n\t\t\t\t\t}\n\n\t\t\t\t\tfiles.wait(function(filename, next) {\n\n\t\t\t\t\t\tif (F.$bundling) {\n\t\t\t\t\t\t\tvar stream = Fs.createReadStream(filename);\n\t\t\t\t\t\t\tvar writer = Fs.createWriteStream(Path.join(dir, filename.replace(item.filename, '').replace(/\\.package$/i, '')));\n\t\t\t\t\t\t\tstream.pipe(writer);\n\t\t\t\t\t\t\twriter.on('finish', next);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tnext();\n\n\t\t\t\t\t}, function() {\n\n\t\t\t\t\t\t// Windows sometimes doesn't load package and this delay solves the problem.\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tdependencies.push(next => F.install('package2', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName));\n\t\t\t\t\t\t\tnext2();\n\t\t\t\t\t\t}, 50);\n\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}, resume);\n\t\t});\n\t}\n\n\tif (can('models')) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/models/' : CONF.directory_models);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('model', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('schemas')) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/schemas/' : CONF.directory_schemas);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('schema', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('tasks')) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/tasks/' : CONF.directory_tasks);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('task', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('operations')) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/operations/' : CONF.directory_operations);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('operation', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('themes')) {\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/themes/' : CONF.directory_themes);\n\t\t\tlisting(dir, 0, arr, undefined, true);\n\t\t\tarr.forEach(function(item) {\n\t\t\t\tvar themeName = item.name;\n\t\t\t\tvar themeDirectory = Path.join(dir, themeName);\n\t\t\t\tvar filename = Path.join(themeDirectory, 'index.js');\n\t\t\t\tF.themes[item.name] = U.path(themeDirectory);\n\t\t\t\tF._length_themes++;\n\t\t\t\texistsSync(filename) && dependencies.push(next => F.install('theme', item.name, filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName));\n\t\t\t});\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('definitions')) {\n\t\toperations.push(function(resume) {\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/definitions/' : CONF.directory_definitions);\n\t\t\tarr = [];\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('definition', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('controllers')) {\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/controllers/' : CONF.directory_controllers);\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('controller', item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('components')) {\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = U.combine(targetdirectory, isPackage ? '/components/' : CONF.directory_components);\n\t\t\tlisting(dir, 0, arr, '.html');\n\t\t\tarr.forEach((item) => dependencies.push(next => F.install('component', item.name, item.filename, undefined, undefined, undefined, undefined, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tvar thread = global.THREAD;\n\tif (thread) {\n\n\t\t// Updates PREF file\n\t\tPREFFILE = PREFFILE.replace('.json', '_' + thread + '.json');\n\n\t\toperations.push(function(resume) {\n\t\t\tarr = [];\n\t\t\tdir = '/threads/' + thread;\n\t\t\tF.$configure_env(dir + '/.env');\n\t\t\tF.$configure_env(dir + '/.env-' + (DEBUG ? 'debug' : 'release'));\n\t\t\tF.$configure_configs(dir + '/config');\n\t\t\tF.$configure_configs(dir + '/config-' + (DEBUG ? 'debug' : 'release'));\n\t\t\tdir = U.combine(targetdirectory, '/threads/' + thread);\n\t\t\tlisting(dir, 0, arr);\n\t\t\tarr.forEach(item => dependencies.push(next => F.install('module', 'threads/' + item.name, item.filename, undefined, undefined, undefined, true, undefined, undefined, next, packageName)));\n\t\t\tresume();\n\t\t});\n\t}\n\n\tif (can('preferences')) {\n\t\toperations.push(function(resume) {\n\t\t\tif (F.onPrefLoad)\n\t\t\t\tloadpreferences(resume);\n\t\t\telse\n\t\t\t\tresume();\n\t\t});\n\t}\n\n\toperations.async(function() {\n\t\tvar count = dependencies.length;\n\t\tF.consoledebug('load dependencies ' + count + 'x');\n\t\tdependencies.async(function() {\n\t\t\ttypes && types.indexOf('service') === -1 && F.cache.stop();\n\t\t\tF.$routesSort();\n\t\t\t(!types || types.indexOf('dependencies') !== -1) && F.$configure_dependencies();\n\t\t\tF.consoledebug('load dependencies {0}x (done)'.format(count));\n\t\t\tcallback && callback();\n\t\t});\n\t});\n\n\treturn F;\n};\n\nfunction loadpreferences(callback) {\n\tF.onPrefLoad(function(value) {\n\t\tif (value) {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tF.pref[key] = global.PREF[key] = value[key];\n\t\t\t}\n\t\t}\n\t\tcallback && callback();\n\t});\n}\n\nF.$startup = function(callback) {\n\n\tvar dir = Path.join(directory, '/startup/');\n\n\tif (!existsSync(dir))\n\t\treturn callback();\n\n\tvar run = [];\n\n\tFs.readdirSync(dir).forEach(function(o) {\n\t\tvar extension = U.getExtension(o);\n\t\tif (JSFILES[extension])\n\t\t\trun.push(o);\n\t});\n\n\tif (!run.length)\n\t\treturn callback();\n\n\trun.wait(function(filename, next) {\n\t\tvar fn = dir + filename + '_bk';\n\t\tFs.renameSync(dir + filename, fn);\n\t\tvar fork = Child.fork(fn, [], { cwd: directory });\n\t\tfork.on('exit', function() {\n\t\t\tfork = null;\n\t\t\tnext();\n\t\t});\n\t}, callback);\n\n\treturn F;\n};\n\nglobal.UPTODATE = F.uptodate = function(type, url, options, interval, callback, next) {\n\n\tif (typeof(options) === 'string' && typeof(interval) !== 'string') {\n\t\tinterval = options;\n\t\toptions = null;\n\t}\n\n\tOBSOLETE('UPTODATE()', 'This method is deprecated and it will be removed in v4.');\n\n\tvar obj = { type: type, name: '', url: url, interval: interval, options: options, count: 0, updated: NOW, errors: [], callback: callback };\n\n\tif (!F.uptodates)\n\t\tF.uptodates = [];\n\n\tF.uptodates.push(obj);\n\tF.install(type, url, options, function(err, name) {\n\t\terr && obj.errors.push(err);\n\t\tobj.name = name;\n\t\tobj.callback && obj.callback(err, name);\n\t}, undefined, undefined, undefined, undefined, next);\n\treturn F;\n};\n\n/**\n * Install type with its declaration\n * @param {String} type Available types: model, module, controller, source.\n * @param {String} name Default name (optional).\n * @param {String or Function} declaration\n * @param {Object} options Custom options, optional.\n * @param {Object} internal Internal/Temporary options, optional.\n * @param {Boolean} useRequired Internal, optional.\n * @param {Boolean} skipEmit Internal, optional.\n * @param {String} uptodateName Internal, optional.\n * @param {Function} next Internal, optional.\n * @param {String} packageName Internal, optional.\n * @return {Framework}\n */\nglobal.INSTALL = F.install = function(type, name, declaration, options, callback, internal, useRequired, skipEmit, uptodateName, next, packageName) {\n\n\tvar obj = null;\n\n\tif (type !== 'config' && type !== 'version' && typeof(name) === 'string') {\n\t\tif (name.startsWith('http://') || name.startsWith('https://')) {\n\t\t\tif (typeof(declaration) === 'object') {\n\t\t\t\tcallback = options;\n\t\t\t\toptions = declaration;\n\t\t\t\tdeclaration = name;\n\t\t\t\tname = '';\n\t\t\t}\n\t\t} else if (name[0] === '@') {\n\t\t\tdeclaration = F.path.package(name.substring(1));\n\t\t\tname = Path.basename(name).replace(/\\.js$/i, '');\n\t\t\tif (useRequired === undefined)\n\t\t\t\tuseRequired = true;\n\t\t}\n\t}\n\n\tvar t = typeof(declaration);\n\tvar key = '';\n\tvar tmp;\n\tvar content;\n\tvar err;\n\n\tNOW = new Date();\n\n\tif (t === 'object') {\n\t\tt = typeof(options);\n\t\tif (t === 'function')\n\t\t\tcallback = options;\n\t\toptions = declaration;\n\t\tdeclaration = undefined;\n\t}\n\n\tif (declaration === undefined) {\n\t\tdeclaration = name;\n\t\tname = '';\n\t}\n\n\tif (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tif (type === 'command') {\n\t\tif (typeof(declaration) === 'function') {\n\t\t\tif (F.commands[name])\n\t\t\t\tF.commands[name].push(declaration);\n\t\t\telse\n\t\t\t\tF.commands[name] = [declaration];\n\t\t}\n\t\treturn F;\n\t}\n\n\t// Check if declaration is a valid URL address\n\tif (type !== 'eval' && typeof(declaration) === 'string') {\n\n\t\tif (declaration.startsWith('http://') || declaration.startsWith('https://')) {\n\t\t\tif (type === 'package') {\n\t\t\t\tF.consoledebug('download', type, declaration);\n\t\t\t\tU.download(declaration, FLAGS_INSTALL, function(err, response) {\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tF.error(err, 'F.install(\\'{0}\\', \\'{1}\\')'.format(type, declaration), null);\n\t\t\t\t\t\tnext && next();\n\t\t\t\t\t\tcallback && callback(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar id = Path.basename(declaration, '.package');\n\t\t\t\t\tvar filename = F.path.temp(id + '.download');\n\t\t\t\t\tvar stream = Fs.createWriteStream(filename);\n\t\t\t\t\tvar md5 = Crypto.createHash('md5');\n\n\t\t\t\t\tresponse.on('data', (buffer) => md5.update(buffer));\n\t\t\t\t\tresponse.pipe(stream);\n\n\t\t\t\t\tstream.on('finish', function() {\n\t\t\t\t\t\tvar hash = md5.digest('hex');\n\n\t\t\t\t\t\tif (F.temporary.versions[declaration] === hash) {\n\t\t\t\t\t\t\tnext && next();\n\t\t\t\t\t\t\tcallback && callback(null, uptodateName || name, true);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tF.temporary.versions[declaration] = hash;\n\t\t\t\t\t\tF.install(type, id, filename, options, callback, undefined, undefined, true, uptodateName, next);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\treturn F;\n\t\t\t}\n\n\t\t\tF.consoledebug('download', type, declaration);\n\t\t\tU.request(declaration, FLAGS_INSTALL, function(err, data, code) {\n\n\t\t\t\tif (code !== 200 && !err)\n\t\t\t\t\terr = new Error(data);\n\n\t\t\t\tif (err) {\n\t\t\t\t\tF.error(err, 'F.install(\\'{0}\\', \\'{1}\\')'.format(type, declaration), null);\n\t\t\t\t\tnext && next();\n\t\t\t\t\tcallback && callback(err);\n\t\t\t\t} else {\n\n\t\t\t\t\tvar hash = data.hash('md5');\n\n\t\t\t\t\tif (F.temporary.versions[declaration] === hash) {\n\t\t\t\t\t\tnext && next();\n\t\t\t\t\t\tcallback && callback(null, uptodateName || name, true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tF.temporary.versions[declaration] = hash;\n\t\t\t\t\tF.install(type, name, data, options, callback, declaration, undefined, undefined, uptodateName, next);\n\t\t\t\t}\n\n\t\t\t});\n\t\t\treturn F;\n\t\t} else {\n\t\t\tif (declaration[0] === '~')\n\t\t\t\tdeclaration = declaration.substring(1);\n\t\t\tif (type !== 'config' && type !== 'resource' && type !== 'package' && type !== 'component' && !REG_SCRIPTCONTENT.test(declaration)) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tif (!existsSync(declaration))\n\t\t\t\t\tthrow new Error('The ' + type + ': ' + declaration + ' doesn\\'t exist.');\n\t\t\t\tuseRequired = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (type === 'middleware') {\n\n\t\tF.routes.middleware[name] = typeof(declaration) === 'function' ? declaration : eval(declaration);\n\t\tF._length_middleware = Object.keys(F.routes.middleware).length;\n\n\t\tif (REG_NEWIMPL.test(F.routes.middleware[name].toString()))\n\t\t\tF.routes.middleware[name].$newversion = true;\n\t\telse\n\t\t\tOBSOLETE('MIDDLEWARE(\"{0}\")'.format(name), 'You used older declaration of this delegate and you must rewrite it. Read more in docs.');\n\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\tkey = type + '.' + name;\n\n\t\tif (F.dependencies[key]) {\n\t\t\tF.dependencies[key].updated = NOW;\n\t\t} else {\n\t\t\tF.dependencies[key] = { name: name, type: type, installed: NOW, updated: null, count: 0 };\n\t\t\tif (internal)\n\t\t\t\tF.dependencies[key].url = internal;\n\t\t}\n\n\t\tF.dependencies[key].count++;\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'config' || type === 'configuration' || type === 'settings') {\n\t\tF.$configure_configs(declaration instanceof Array ? declaration : declaration.toString().split('\\n'), true);\n\t\tsetTimeout(function() {\n\t\t\tdelete F.temporary.mail_settings;\n\t\t\tEMIT(type + '#' + name, CONF);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'version' || type === 'versions') {\n\n\t\tF.$configure_versions(declaration.toString().split('\\n'));\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'workflow' || type === 'workflows') {\n\n\t\tF.$configure_workflows(declaration.toString().split('\\n'));\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t\tF.consoledebug('install', type + '#' + name);\n\t\t}, 500);\n\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'sitemap') {\n\n\t\tF.$configure_sitemap(declaration.toString().split('\\n'));\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t\tF.consoledebug('install', type + '#' + name);\n\t\t}, 500);\n\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'component') {\n\n\t\tif (!name && internal)\n\t\t\tname = U.getName(internal).replace(/\\.html/gi, '').trim();\n\n\t\tF.uninstall(type, uptodateName || name, uptodateName ? 'uptodate' : undefined);\n\n\t\tvar hash = '\\n/*' + name.crc32(true) + '*/\\n';\n\t\tvar temporary = (F.id ? 'i-' + F.id + '_' : '') + 'components';\n\n\t\tcontent = parseComponent(internal ? declaration : Fs.readFileSync(declaration).toString(ENCODING), name);\n\n\t\tif (F.$bundling) {\n\t\t\tcontent.js && Fs.appendFileSync(F.path.temp(temporary + '.js'), hash + (DEBUG ? component_debug(name, content.js, 'js') : content.js) + hash.substring(0, hash.length - 1));\n\t\t\tcontent.css && Fs.appendFileSync(F.path.temp(temporary + '.css'), hash + (DEBUG ? component_debug(name, content.css, 'css') : content.css) + hash.substring(0, hash.length - 1));\n\t\t}\n\n\t\tif (!Object.keys(content.parts).length)\n\t\t\tcontent.parts = null;\n\n\t\tif (content.js)\n\t\t\tF.components.js = true;\n\n\t\tif (content.css)\n\t\t\tF.components.css = true;\n\n\t\tif (content.files)\n\t\t\tF.components.files[name] = content.files;\n\t\telse\n\t\t\tdelete F.components.files[name];\n\n\t\tif (content.body) {\n\t\t\tF.components.views[name] = '.' + F.path.temp('component_' + name);\n\t\t\tF.$bundling && Fs.writeFile(F.components.views[name].substring(1) + '.html', U.minifyHTML(content.body), NOOP);\n\t\t} else\n\t\t\tdelete F.components.views[name];\n\n\t\tF.components.has = true;\n\n\t\tvar link = CONF.static_url_components;\n\t\tF.components.version = NOW.getTime();\n\t\tF.components.links = (F.components.js ? '<script src=\"{0}js?version={1}\"></script>'.format(link, F.components.version) : '') + (F.components.css ? '<link type=\"text/css\" rel=\"stylesheet\" href=\"{0}css?version={1}\" />'.format(link, F.components.version) : '');\n\n\t\tif (content.install) {\n\t\t\ttry {\n\t\t\t\tvar filecomponent = F.path.temp('component-' + name + '.js');\n\t\t\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\t\t\tFs.writeFileSync(filecomponent, content.install.trim());\n\t\t\t\tobj = require(filecomponent);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(filecomponent));\n\t\t\t\tobj.$owner = _owner;\n\t\t\t\tF.temporary.owners[_owner] = true;\n\t\t\t\t_controller = '';\n\t\t\t\tobj.name = name;\n\t\t\t\tobj.parts = content.parts;\n\t\t\t\tF.components.instances[name] = obj;\n\t\t\t\tobj && typeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\t\t\t} catch(e) {\n\t\t\t\tF.error(e, 'F.install(\\'component\\', \\'{0}\\')'.format(name));\n\t\t\t}\n\t\t} else if (!internal) {\n\t\t\tvar js = declaration.replace(/\\.html$/i, '.js');\n\t\t\tif (existsSync(js)) {\n\t\t\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\t\t\tF.temporary.owners[_owner] = true;\n\t\t\t\tobj = require(js);\n\t\t\t\tobj.name = name;\n\t\t\t\tobj.parts = content.parts;\n\t\t\t\tobj.$owner = _owner;\n\t\t\t\t_controller = '';\n\t\t\t\tF.components.instances[name] = obj;\n\t\t\t\ttypeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t}\n\n\t\tif (obj) {\n\n\t\t\tif (!obj.group)\n\t\t\t\tobj.group = 'default';\n\n\t\t\tkey = obj.group.crc32(true);\n\t\t\ttemporary += '_g' + key;\n\t\t\ttmp = F.components.groups[obj.group];\n\t\t\tif (!tmp)\n\t\t\t\ttmp = F.components.groups[obj.group] = {};\n\n\t\t\tif (content.js) {\n\t\t\t\tFs.appendFileSync(F.path.temp(temporary + '.js'), hash + (DEBUG ? component_debug(name, content.js, 'js') : content.js) + hash.substring(0, hash.length - 1));\n\t\t\t\ttmp.js = true;\n\t\t\t}\n\n\t\t\tif (content.css) {\n\t\t\t\tFs.appendFileSync(F.path.temp(temporary + '.css'), hash + (DEBUG ? component_debug(name, content.css, 'css') : content.css) + hash.substring(0, hash.length - 1));\n\t\t\t\ttmp.css = true;\n\t\t\t}\n\n\t\t\ttmp.version = GUID(5);\n\t\t\ttmp.links = (tmp.js ? '<script src=\"{0}js?group={2}_{1}\"></script>'.format(link, tmp.version, key) : '') + (tmp.css ? '<link type=\"text/css\" rel=\"stylesheet\" href=\"{0}css?group={2}_{1}\" />'.format(link, tmp.version, key) : '');\n\t\t}\n\n\t\t!skipEmit && setTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'package') {\n\n\t\tvar id = Path.basename(declaration, '.' + U.getExtension(declaration));\n\t\tvar dir = CONF.directory_temp[0] === '~' ? Path.join(CONF.directory_temp.substring(1), id + '.package') : Path.join(F.path.root(), CONF.directory_temp, id + '.package');\n\n\t\tF.routes.packages[id] = dir;\n\n\t\tvar restorecb = function() {\n\t\t\tvar filename = Path.join(dir, 'index.js');\n\t\t\tif (!existsSync(filename)) {\n\t\t\t\tnext && next();\n\t\t\t\tcallback && callback(null, name);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tF.install('module', id, filename, options || CONF['package#' + name], function(err) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tEMIT('module#' + name);\n\t\t\t\t\tEMIT(type + '#' + name);\n\t\t\t\t\tEMIT('install', 'module', name);\n\t\t\t\t\tEMIT('install', type, name);\n\t\t\t\t\tF.temporary.ready['package#' + name] = NOW;\n\t\t\t\t\tF.temporary.ready['module#' + name] = NOW;\n\t\t\t\t}, 500);\n\t\t\t\tF.consoledebug('install', 'package#' + name);\n\t\t\t\tcallback && callback(err, name);\n\t\t\t}, internal, useRequired, true, undefined);\n\t\t\tnext && next();\n\t\t};\n\n\t\tif (F.$bundling)\n\t\t\tF.restore(declaration, dir, restorecb);\n\t\telse\n\t\t\trestorecb();\n\n\t\treturn F;\n\t}\n\n\tif (type === 'theme') {\n\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tobj = require(declaration);\n\t\tobj.$owner = _owner;\n\t\tF.temporary.owners[_owner] = true;\n\n\t\ttypeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\n\t\t!skipEmit && setTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\t(function(name) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tdelete require.cache[name];\n\t\t\t}, 1000);\n\t\t})(require.resolve(declaration));\n\t\treturn F;\n\t}\n\n\tif (type === 'package2') {\n\t\ttype = type.substring(0, type.length - 1);\n\t\tvar id = U.getName(declaration, '.package');\n\t\tvar dir = CONF.directory_temp[0] === '~' ? Path.join(CONF.directory_temp.substring(1), id) : Path.join(F.path.root(), CONF.directory_temp, id);\n\t\tvar filename = Path.join(dir, 'index.js');\n\t\tF.install('module', id.replace(/\\.package$/i, ''), filename, options || CONF['package#' + name], function(err) {\n\t\t\tsetTimeout(function() {\n\t\t\t\tEMIT('module#' + name);\n\t\t\t\tEMIT(type + '#' + name);\n\t\t\t\tEMIT('install', type, name);\n\t\t\t\tEMIT('install', 'module', name);\n\t\t\t\tF.temporary.ready['package#' + name] = NOW;\n\t\t\t\tF.temporary.ready['module#' + name] = NOW;\n\t\t\t}, 500);\n\t\t\tF.consoledebug('install', 'package#' + name);\n\t\t\tcallback && callback(err, name);\n\t\t}, internal, useRequired, true);\n\t\tnext && next();\n\t\treturn F;\n\t}\n\n\tvar plus = F.id ? 'i-' + F.id + '_' : '';\n\tif (type === 'view') {\n\n\t\tvar item = F.routes.views[name];\n\t\tkey = type + '.' + name;\n\n\t\tif (item === undefined) {\n\t\t\titem = {};\n\t\t\titem.filename = F.path.temporary(plus + 'installed-view-' + U.GUID(10) + '.tmp');\n\t\t\titem.url = internal;\n\t\t\titem.count = 0;\n\t\t\tF.routes.views[name] = item;\n\t\t}\n\n\t\titem.count++;\n\t\tFs.writeFileSync(item.filename, framework_internal.modificators(declaration, name));\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'definition' || type === 'eval' || type === 'schema' || type === 'operation' || type === 'task') {\n\n\t\t_controller = '';\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tF.temporary.owners[_owner] = true;\n\t\terr = null;\n\n\t\ttry {\n\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tdelete require.cache[require.resolve(declaration)];\n\t\t\t\tobj = require(declaration);\n\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(() => delete require.cache[name], 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t} else\n\t\t\t\tobj = typeof(declaration) === 'function' ? eval('(' + declaration.toString() + ')()') : eval(declaration);\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tF.consoledebug('install', type + '#' + (name || '::undefined::'));\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name);\n\t\t\tEMIT('install', type, name);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\treturn F;\n\t}\n\n\tif (type === 'isomorphic') {\n\n\t\tcontent = '';\n\t\terr = null;\n\n\t\tOBSOLETE('isomorphic', 'Isomorphic scripts will be removed in v4.');\n\n\t\ttry {\n\n\t\t\tif (!name && typeof(internal) === 'string') {\n\t\t\t\tvar tmp = internal.match(/[a-z0-9]+\\.js$/i);\n\t\t\t\tif (tmp)\n\t\t\t\t\tname = tmp.toString().replace(/\\.js/i, '');\n\t\t\t}\n\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tdelete require.cache[require.resolve(declaration)];\n\t\t\t\tobj = require(declaration);\n\t\t\t\tcontent = Fs.readFileSync(declaration).toString(ENCODING);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(() => delete require.cache[name], 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobj = typeof(declaration) === 'function' ? eval('(' + declaration.toString() + ')()') : eval(declaration);\n\t\t\t\tcontent = declaration.toString();\n\t\t\t}\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tif (typeof(obj.id) === 'string')\n\t\t\tname = obj.id;\n\t\telse if (typeof(obj.name) === 'string')\n\t\t\tname = obj.name;\n\n\t\tif (obj.url) {\n\t\t\tif (obj.url[0] !== '/')\n\t\t\t\tobj.url = '/' + obj.url;\n\t\t} else\n\t\t\tobj.url = '/' + name + '.js';\n\n\t\ttmp = F.path.temp('isomorphic_' + name + '.min.js');\n\t\tF.map(framework_internal.preparePath(obj.url), tmp);\n\t\tF.isomorphic[name] = obj;\n\n\t\tF.$bundling && Fs.writeFileSync(tmp, prepare_isomorphic(name, framework_internal.compile_javascript(content, '#' + name)));\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name, obj);\n\t\t\tEMIT('install', type, name, obj);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\treturn F;\n\t}\n\n\tif (type === 'model' || type === 'source') {\n\n\t\t_controller = '';\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tF.temporary.owners[_owner] = true;\n\t\terr = null;\n\n\t\ttry {\n\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tobj = require(declaration);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(() => delete require.cache[name], 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (typeof(declaration) !== 'string')\n\t\t\t\t\tdeclaration = declaration.toString();\n\n\t\t\t\tif (!name && typeof(internal) === 'string') {\n\t\t\t\t\tvar tmp = internal.match(/[a-z0-9]+\\.js$/i);\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t\tname = tmp.toString().replace(/\\.js/i, '');\n\t\t\t\t}\n\n\t\t\t\tvar filename = F.path.temporary(plus + 'installed-' + type + '-' + U.GUID(10) + '.js');\n\t\t\t\tFs.writeFileSync(filename, declaration);\n\t\t\t\tobj = require(filename);\n\n\t\t\t\t(function(name, filename) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tFs.unlinkSync(filename);\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(filename), filename);\n\t\t\t}\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\', \\'' + name + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tif (typeof(obj.id) === 'string')\n\t\t\tname = obj.id;\n\t\telse if (typeof(obj.name) === 'string')\n\t\t\tname = obj.name;\n\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tobj.$owner = _owner;\n\n\t\tif (!name)\n\t\t\tname = (Math.random() * 10000) >> 0;\n\n\t\tkey = type + '.' + name;\n\t\ttmp = F.dependencies[key];\n\n\t\tF.uninstall(type, uptodateName || name, uptodateName ? 'uptodate' : undefined);\n\t\tF.temporary.owners[_owner] = true;\n\n\t\tif (tmp) {\n\t\t\tF.dependencies[key] = tmp;\n\t\t\tF.dependencies[key].updated = NOW;\n\t\t}\n\t\telse {\n\t\t\tF.dependencies[key] = { name: name, type: type, installed: NOW, updated: null, count: 0 };\n\t\t\tif (internal)\n\t\t\t\tF.dependencies[key].url = internal;\n\t\t}\n\n\t\tF.dependencies[key].count++;\n\n\t\tif (obj.reinstall)\n\t\t\tF.dependencies[key].reinstall = obj.reinstall.toString().parseDateExpiration();\n\t\telse\n\t\t\tdelete F.dependencies[key];\n\n\t\tif (type === 'model')\n\t\t\tF.models[name] = obj;\n\t\telse\n\t\t\tF.sources[name] = obj;\n\n\t\ttypeof(obj.install) === 'function' && obj.install(options || CONF[type + '#' + name], name);\n\n\t\t!skipEmit && setTimeout(function() {\n\t\t\tEMIT(type + '#' + name, obj);\n\t\t\tEMIT('install', type, name, obj);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\n\t\tF.consoledebug('install', type + '#' + name);\n\t\tnext && next();\n\t\tcallback && callback(null, name);\n\t\treturn F;\n\t}\n\n\tif (type === 'module' || type === 'controller') {\n\n\t\t// for inline routes\n\t\tvar _ID = _controller = 'TMP' + U.random(10000);\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\terr = null;\n\n\t\ttry {\n\t\t\tif (useRequired) {\n\t\t\t\tvar relative = F.path.root(declaration);\n\t\t\t\tif (existsSync(relative))\n\t\t\t\t\tdeclaration = relative;\n\t\t\t\tobj = require(declaration);\n\t\t\t\t(function(name) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(declaration));\n\t\t\t} else {\n\n\t\t\t\tif (typeof(declaration) !== 'string')\n\t\t\t\t\tdeclaration = declaration.toString();\n\n\t\t\t\tif (!name && typeof(internal) === 'string') {\n\t\t\t\t\tvar tmp = internal.match(/[a-z0-9]+\\.js$/i);\n\t\t\t\t\tif (tmp)\n\t\t\t\t\t\tname = tmp.toString().replace(/\\.js/i, '');\n\t\t\t\t}\n\n\t\t\t\tfilename = F.path.temporary(plus + 'installed-' + type + '-' + U.GUID(10) + '.js');\n\t\t\t\tFs.writeFileSync(filename, declaration);\n\t\t\t\tobj = require(filename);\n\t\t\t\t(function(name, filename) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tFs.unlinkSync(filename);\n\t\t\t\t\t\tdelete require.cache[name];\n\t\t\t\t\t}, 1000);\n\t\t\t\t})(require.resolve(filename), filename);\n\t\t\t}\n\n\t\t} catch (ex) {\n\t\t\terr = ex;\n\t\t}\n\n\t\tif (err) {\n\t\t\tF.error(err, 'F.install(\\'' + type + '\\', \\'' + (name ? '' : internal) + '\\')', null);\n\t\t\tnext && next();\n\t\t\tcallback && callback(err, name);\n\t\t\treturn F;\n\t\t}\n\n\t\tif (typeof(obj.id) === 'string')\n\t\t\tname = obj.id;\n\t\telse if (typeof(obj.name) === 'string')\n\t\t\tname = obj.name;\n\n\t\tif (!name)\n\t\t\tname = (Math.random() * 10000) >> 0;\n\n\t\t_owner = (packageName ? packageName + '@' : '') + type + '#' + name;\n\t\tobj.$owner = _owner;\n\n\t\tobj.booting && setTimeout(function() {\n\n\t\t\tvar tmpdir = F.path.temp(name + (U.getExtension(name) === 'package' ? '' : '.package/'));\n\n\t\t\tif (obj.booting === 'root') {\n\t\t\t\tF.directory = directory = tmpdir;\n\t\t\t\tF.temporary.path = {};\n\t\t\t\tF.temporary.notfound = {};\n\t\t\t\tF.$configure_env();\n\t\t\t\tF.$configure_configs();\n\t\t\t\tF.$configure_versions();\n\t\t\t\tF.$configure_dependencies();\n\t\t\t\tF.$configure_sitemap();\n\t\t\t\tF.$configure_workflows();\n\t\t\t} else {\n\t\t\t\tF.$configure_env('@' + name + '/.env');\n\t\t\t\tF.$configure_env('@' + name + '/.env-' + (DEBUG ? 'debug' : 'release'));\n\t\t\t\tF.$configure_configs('@' + name + '/config');\n\t\t\t\tF.$configure_configs('@' + name + '/config-' + (DEBUG ? 'debug' : 'release'));\n\t\t\t\tF.isTest && F.$configure_configs('@' + name + '/config-test');\n\t\t\t\tF.$configure_versions('@' + name + '/versions');\n\t\t\t\tF.$configure_dependencies('@' + name + '/dependencies');\n\t\t\t\tF.$configure_sitemap('@' + name + '/sitemap');\n\t\t\t\tF.$configure_workflows('@' + name + '/workflows');\n\t\t\t}\n\n\t\t\tF.$bundle(() => F.$load(undefined, tmpdir, undefined, name));\n\t\t}, 100);\n\n\t\tkey = type + '.' + name;\n\t\ttmp = F.dependencies[key];\n\n\t\tF.uninstall(type, uptodateName || name, uptodateName ? 'uptodate' : undefined, undefined, packageName);\n\t\tF.temporary.owners[_owner] = true;\n\n\t\tif (tmp) {\n\t\t\tF.dependencies[key] = tmp;\n\t\t\tF.dependencies[key].updated = NOW;\n\t\t}\n\t\telse {\n\t\t\tF.dependencies[key] = { name: name, type: type, installed: NOW, updated: null, count: 0, _id: _ID };\n\t\t\tif (internal)\n\t\t\t\tF.dependencies[key].url = internal;\n\t\t}\n\n\t\tF.dependencies[key].dependencies = obj.dependencies;\n\t\tF.dependencies[key].count++;\n\t\tF.dependencies[key].processed = false;\n\n\t\tif (obj.reinstall)\n\t\t\tF.dependencies[key].reinstall = obj.reinstall.toString().parseDateExpiration();\n\t\telse\n\t\t\tdelete F.dependencies[key].reinstall;\n\n\t\t_controller = _ID;\n\n\t\tif (obj.dependencies instanceof Array) {\n\t\t\tfor (var i = 0, length = obj.dependencies.length; i < length; i++) {\n\t\t\t\tif (!F.dependencies[type + '.' + obj.dependencies[i]]) {\n\t\t\t\t\tF.temporary.dependencies[key] = { obj: obj, options: options, callback: callback, skipEmit: skipEmit };\n\t\t\t\t\tnext && next();\n\t\t\t\t\treturn F;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tF.install_make(key, name, obj, options, callback, skipEmit, type);\n\n\t\tif (type === 'module')\n\t\t\tF.modules[name] = obj;\n\t\telse\n\t\t\tF.controllers[name] = obj;\n\n\t\tF.install_prepare();\n\t\tnext && next();\n\t}\n\n\treturn F;\n};\n\nF.install_prepare = function(noRecursive) {\n\n\tvar keys = Object.keys(F.temporary.dependencies);\n\tif (!keys.length)\n\t\treturn;\n\n\tOBSOLETE('exports.dependencies()', 'Module dependencies will be removed in v4: \"' + keys.join(', ') + '\"');\n\n\t// check dependencies\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\n\t\tvar k = keys[i];\n\t\tvar a = F.temporary.dependencies[k];\n\t\tvar b = F.dependencies[k];\n\t\tvar skip = false;\n\n\t\tif (b.processed)\n\t\t\tcontinue;\n\n\t\tfor (var j = 0, jl = b.dependencies.length; j < jl; j++) {\n\t\t\tvar d = F.dependencies['module.' + b.dependencies[j]];\n\t\t\tif (!d || !d.processed) {\n\t\t\t\tskip = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tdelete F.temporary.dependencies[k];\n\n\t\tif (b.type === 'module')\n\t\t\tF.modules[b.name] = a.obj;\n\t\telse\n\t\t\tF.controllers[b.name] = a.obj;\n\n\t\tF.install_make(k, b.name, a.obj, a.options, a.callback, a.skipEmit, b.type);\n\t}\n\n\tkeys = Object.keys(F.temporary.dependencies);\n\n\tclearTimeout(F.temporary.other.dependencies);\n\tF.temporary.other.dependencies = setTimeout(function() {\n\t\tvar keys = Object.keys(F.temporary.dependencies);\n\t\tif (keys.length)\n\t\t\tthrow new Error('Dependency exception, missing dependencies for: ' + keys.join(', ').trim());\n\t\tdelete F.temporary.other.dependencies;\n\t}, CONF.default_dependency_timeout);\n\n\tif (!keys.length || noRecursive)\n\t\treturn F;\n\n\tF.install_prepare(true);\n\treturn F;\n};\n\nF.install_make = function(key, name, obj, options, callback, skipEmit, type) {\n\n\tvar me = F.dependencies[key];\n\tvar routeID = me._id;\n\tvar type = me.type;\n\n\tF.temporary.internal[me._id] = name;\n\t_controller = routeID;\n\t_owner = type + '#' + name.replace(/\\.package$/gi, '');\n\n\ttypeof(obj.install) === 'function' && obj.install(options || CONF[_owner], name);\n\tme.processed = true;\n\n\tvar id = (type === 'module' ? '#' : '') + name;\n\tvar length = F.routes.web.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.web[i].controller === routeID)\n\t\t\tF.routes.web[i].controller = id;\n\t}\n\n\tvar tmp = Object.keys(F.routes.system);\n\tlength = tmp.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.system[tmp[i]].controller === routeID)\n\t\t\tF.routes.system[tmp[i]].controller = id;\n\t}\n\n\tlength = F.routes.websockets.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.websockets[i].controller === routeID)\n\t\t\tF.routes.websockets[i].controller = id;\n\t}\n\n\tlength = F.routes.files.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (F.routes.files[i].controller === routeID)\n\t\t\tF.routes.files[i].controller = id;\n\t}\n\n\tF.$routesSort();\n\t_controller = '';\n\tname = name.replace(/\\.package$/gi, '');\n\n\tif (!skipEmit) {\n\t\tsetTimeout(function() {\n\t\t\tEMIT(type + '#' + name, obj);\n\t\t\tEMIT('install', type, name, obj);\n\t\t\tF.temporary.ready[type + '#' + name] = NOW;\n\t\t}, 500);\n\t}\n\n\tF.consoledebug('install', type + '#' + name);\n\tcallback && callback(null, name);\n\treturn F;\n};\n\n/**\n * Uninstall type\n * @param {String} type Available types: model, module, controller, source.\n * @param {String} name\n * @param {Object} options Custom options, optional.\n * @param {Object} skipEmit Internal, optional.\n * @return {Framework}\n */\nglobal.UNINSTALL = F.uninstall = function(type, name, options, skipEmit, packageName) {\n\n\tvar obj = null;\n\tvar k, v, tmp;\n\n\tif (type === 'route' || type === 'web') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'urlraw' : 'execute';\n\t\tv = k === 'execute' ? name : k === 'id' ? name.substring(3).trim() : name;\n\t\tif (k === 'urlraw' && v[0] === '#')\n\t\t\tdelete F.routes.system[v];\n\t\telse\n\t\t\tF.routes.web = F.routes.web.remove(k, v);\n\t\tF.$routesSort();\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\tF.temporary.other = {};\n\t\treturn F;\n\t}\n\n\tif (type === 'cors') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'hash' : 'hash';\n\t\tv = k === 'id' ? name.substring(3).trim() : name;\n\t\tif (k !== 'id')\n\t\t\tv = framework_internal.preparePath(framework_internal.encodeUnicodeURL(v.replace('*', '').trim()));\n\t\tF.routes.cors = F.routes.cors.remove(k, v);\n\t\tF._length_cors = F.routes.cors.length;\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'operation') {\n\t\tNEWOPERATION(name, null);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'convertor') {\n\t\tF.convertor(name, null);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'schedule') {\n\t\tF.clearSchedule(name);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tvar id = (packageName ? packageName + '@' : '') +  type + '#' + name;\n\n\tif (type === 'websocket') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'urlraw' : 'onInitialize';\n\t\tv = k === 'onInitialize' ? name : k === 'id' ? name.substring(3).trim() : name;\n\t\tF.routes.websockets = F.routes.websockets.remove(k, v);\n\t\tF.$routesSort();\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'file') {\n\t\tk = typeof(name) === 'string' ? name.substring(0, 3) === 'id:' ? 'id' : 'urlraw' : 'execute';\n\t\tv = k === 'execute' ? name : k === 'id' ? name.substring(3).trim() : name;\n\t\tF.routes.files = F.routes.files.remove(k, v);\n\t\tF._length_files = F.routes.files.length;\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t}\n\n\tif (type === 'schema') {\n\t\ttmp = name.split('/');\n\t\ttmp.length === 2 ? framework_builders.remove(tmp[0], tmp[1]) : framework_builders.remove(undefined, tmp[0]);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t} else if (type === 'mapping') {\n\t\tdelete F.routes.mapping[name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t} else if (type === 'isomorphic') {\n\t\tvar obj = F.isomorphic[name];\n\t\tif (obj.url)\n\t\t\tdelete F.routes.mapping[F.$version(obj.url)];\n\t\tdelete F.isomorphic[name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t} else if (type === 'middleware') {\n\n\t\tif (!F.routes.middleware[name])\n\t\t\treturn F;\n\n\t\tdelete F.routes.middleware[name];\n\t\tdelete F.dependencies[type + '.' + name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF._length_middleware = Object.keys(F.routes.middleware).length;\n\n\t\tfor (var i = 0, length = F.routes.web.length; i < length; i++) {\n\t\t\ttmp = F.routes.web[i];\n\t\t\tif (tmp.middleware && tmp.middleware.length)\n\t\t\t\ttmp.middleware = tmp.middleware.remove(name);\n\t\t}\n\n\t\tfor (var i = 0, length = F.routes.websockets.length; i < length; i++) {\n\t\t\ttmp = F.routes.websockets[i];\n\t\t\tif (tmp.middleware && tmp.middleware.length)\n\t\t\t\ttmp.middleware = tmp.middleware.remove(name);\n\t\t}\n\n\t\tfor (var i = 0, length = F.routes.files.length; i < length; i++) {\n\t\t\ttmp = F.routes.files[i];\n\t\t\tif (tmp.middleware && tmp.middleware.length)\n\t\t\t\ttmp.middleware = tmp.middleware.remove(name);\n\t\t}\n\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\n\t} else if (type === 'package') {\n\t\tdelete F.routes.packages[name];\n\t\tdelete F.temporary.ready['package#' + name];\n\t\tF.uninstall('module', name, options, true);\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\treturn F;\n\t} else if (type === 'view' || type === 'precompile') {\n\n\t\tobj = F.routes.views[name];\n\n\t\tif (!obj)\n\t\t\treturn F;\n\n\t\tdelete F.routes.views[name];\n\t\tdelete F.dependencies[type + '.' + name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\n\t\tfsFileExists(obj.filename, function(e) {\n\t\t\te && Fs.unlink(obj.filename, NOOP);\n\t\t\tF.consoledebug('uninstall', type + '#' + name);\n\t\t});\n\n\t} else if (type === 'model' || type === 'source') {\n\n\t\tobj = type === 'model' ? F.models[name] : F.sources[name];\n\n\t\tif (!obj)\n\t\t\treturn F;\n\n\t\tF.$uninstall(id);\n\t\ttypeof(obj.uninstall) === 'function' && obj.uninstall(options, name);\n\n\t\tif (type === 'model')\n\t\t\tdelete F.models[name];\n\t\telse\n\t\t\tdelete F.sources[name];\n\n\t\tdelete F.dependencies[type + '.' + name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\n\t} else if (type === 'module' || type === 'controller') {\n\n\t\tvar isModule = type === 'module';\n\t\tobj = isModule ? F.modules[name] : F.controllers[name];\n\n\t\tif (!obj)\n\t\t\treturn F;\n\n\t\tF.$uninstall(id, packageName ? '' : ((isModule ? '#' : '') + name));\n\t\tdelete F.temporary.ready[type + '#' + name];\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\n\t\tif (obj) {\n\t\t\tobj.uninstall && obj.uninstall(options, name);\n\t\t\tif (isModule)\n\t\t\t\tdelete F.modules[name];\n\t\t\telse\n\t\t\t\tdelete F.controllers[name];\n\t\t}\n\n\t} else if (type === 'component') {\n\n\t\tif (!F.components.instances[name])\n\t\t\treturn F;\n\n\t\tobj = F.components.instances[name];\n\n\t\tif (obj) {\n\t\t\tF.$uninstall(id);\n\t\t\tobj.uninstall && obj.uninstall(options, name);\n\t\t\tdelete F.components.instances[name];\n\t\t}\n\n\t\tdelete F.components.instances[name];\n\t\tdelete F.components.views[name];\n\t\tdelete F.components.files[name];\n\t\tdelete F.temporary.ready[type + '#' + name];\n\n\t\tvar temporary = (F.id ? 'i-' + F.id + '_' : '') + 'components';\n\t\tvar data;\n\t\tvar index;\n\t\tvar beg = '\\n/*' + name.hash() + '*/\\n';\n\t\tvar end = beg.substring(0, beg.length - 1);\n\t\tvar is = false;\n\n\t\tif (F.components.js) {\n\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.js')).toString('utf-8');\n\t\t\tindex = data.indexOf(beg);\n\t\t\tif (index !== -1) {\n\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.js'), data);\n\t\t\t\tis = true;\n\t\t\t}\n\t\t}\n\n\t\tif (F.components.css) {\n\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.css')).toString('utf-8');\n\t\t\tindex = data.indexOf(beg);\n\t\t\tif (index !== -1) {\n\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.css'), data);\n\t\t\t\tis = true;\n\t\t\t}\n\t\t}\n\n\t\tif (obj.group) {\n\t\t\ttemporary += '_g' + obj.group.hash();\n\t\t\ttmp = F.components.groups[obj.group];\n\t\t\tif (tmp) {\n\n\t\t\t\tif (tmp.js) {\n\t\t\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.js')).toString('utf-8');\n\t\t\t\t\tindex = data.indexOf(beg);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.js'), data);\n\t\t\t\t\t\tis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (tmp.css) {\n\t\t\t\t\tdata = Fs.readFileSync(F.path.temp(temporary + '.css')).toString('utf-8');\n\t\t\t\t\tindex = data.indexOf(beg);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tdata = data.substring(0, index) + data.substring(data.indexOf(end, index + end.length) + end.length);\n\t\t\t\t\t\tFs.writeFileSync(F.path.temp(temporary + '.css'), data);\n\t\t\t\t\t\tis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttmp.version = NOW.getTime();\n\t\t\t}\n\t\t}\n\n\t\tif (is)\n\t\t\tF.components.version = NOW.getTime();\n\n\t\tF.consoledebug('uninstall', type + '#' + name);\n\t}\n\n\t!skipEmit && EMIT('uninstall', type, name);\n\treturn F;\n};\n\nF.$uninstall = function(owner, controller) {\n\n\tif (!F.temporary.owners[owner])\n\t\treturn F;\n\n\tif (controller) {\n\t\tF.routes.web = F.routes.web.remove('controller', controller);\n\t\tF.routes.files = F.routes.files.remove('controller', controller);\n\t\tF.routes.websockets = F.routes.websockets.remove('controller', controller);\n\t}\n\n\tF.routes.web = F.routes.web.remove('owner', owner);\n\tF.routes.files = F.routes.files.remove('owner', owner);\n\tF.routes.websockets = F.routes.websockets.remove('owner', owner);\n\tF.routes.cors = F.routes.cors.remove('owner', owner);\n\n\tvar keys = Object.keys(F.schedules);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tif (F.schedules[key].owner == owner)\n\t\t\tdelete F.schedules[key];\n\t}\n\n\tif (F.modificators)\n\t\tF.modificators = F.modificators.remove('$owner', owner);\n\n\tframework_builders.uninstall(owner);\n\n\tvar owners = [];\n\tvar redirects = false;\n\n\tfor (var i = 0, length = F.owners.length; i < length; i++) {\n\n\t\tvar m = F.owners[i];\n\t\tif (m.owner !== owner) {\n\t\t\towners.push(m);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (m.type) {\n\t\t\tcase 'redirects':\n\t\t\t\tdelete F.routes.redirects[m.id];\n\t\t\t\tredirects = true;\n\t\t\t\tbreak;\n\t\t\tcase 'resize':\n\t\t\t\tdelete F.routes.resize[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'merge':\n\t\t\t\tdelete F.routes.merge[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'mapping':\n\t\t\t\tdelete F.routes.mapping[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'blocks':\n\t\t\t\tdelete F.routes.blocks[m.id];\n\t\t\t\tbreak;\n\t\t\tcase 'middleware':\n\t\t\t\tUNINSTALL('middleware', m.id);\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (redirects)\n\t\tF._request_check_redirect = Object.keys(F.routes.redirects).length > 0;\n\n\tF.owners = owners;\n\tF.$routesSort();\n\tdelete F.temporary.owners[owner];\n\n\treturn F;\n};\n\n/**\n * Register internal mapping (e.g. Resource)\n * @param {String} path\n * @return {Framework}\n */\nF.register = function(path) {\n\n\tvar key;\n\tvar extension = '.' + U.getExtension(path);\n\tvar name = U.getName(path);\n\tvar c = path[0];\n\n\tif (c === '@')\n\t\tpath = F.path.package(path.substring(1));\n\telse if (c === '=') {\n\t\tif (path[1] === '?')\n\t\t\tF.path.themes(CONF.default_theme + path.substring(2));\n\t\telse\n\t\t\tpath = F.path.themes(path.substring(1));\n\t}\n\n\tswitch (extension) {\n\t\tcase '.resource':\n\t\t\tkey = name.replace(extension, '');\n\t\t\tif (F.routes.resources[key])\n\t\t\t\tF.routes.resources[key].push(path);\n\t\t\telse\n\t\t\t\tF.routes.resources[key] = [path];\n\t\t\t// clears cache\n\t\t\tdelete F.resources[key];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error('Not supported registration type \"' + extension + '\".');\n\t}\n\n\treturn F;\n};\n\n/**\n * Run code\n * @param {String or Function} script Function to eval or Code or URL address.\n * @return {Framework}\n */\nF.eval = function(script) {\n\treturn F.install('eval', script);\n};\n\n/**\n * Error handler\n * @param {Error} err\n * @param {String} name\n * @param {Object} uri URI address, optional.\n * @return {Framework}\n */\nF.onError = function(err, name, uri) {\n\tNOW = new Date();\n\tconsole.log('======= ' + (NOW.format('yyyy-MM-dd HH:mm:ss')) + ': ' + (name ? name + ' ---> ' : '') + err.toString() + (uri ? ' (' + Parser.format(uri) + ')' : ''), err.stack);\n\treturn F;\n};\n\n/*\n\tAuthorization handler\n\t@req {Request}\n\t@res {Response} OR {WebSocketClient}\n\t@flags {String array}\n\t@callback {Function} - @callback(Boolean), true is [authorize]d and false is [unauthorize]d\n*/\nF.onAuthorize = null;\n\n/*\n\tSets the current language for the current request\n\t@req {Request}\n\t@res {Response} OR {WebSocketClient}\n\t@return {String}\n*/\nF.onLocale = null;\n// OLD: F.onLocate = null;\n\n/**\n * Sets theme to controller\n * @controller {Controller}\n * @return {String}\n */\nF.onTheme = null;\n\n/*\n\tVersioning static files (this delegate call LESS CSS by the background property)\n\t@name {String} :: name of static file (style.css or script.js)\n\treturn {String} :: return new name of static file (style-new.css or script-new.js)\n*/\nF.onVersion = null;\n\n/**\n * On mapping static files\n * @param {String} url\n * @param {String} def Default value.\n * @return {String}\n */\nF.onMapping = function(url, def, ispublic, encode) {\n\n\tif (url[0] !== '/')\n\t\turl = '/' + url;\n\n\tvar tmp = url;\n\tif (CONF.default_root)\n\t\ttmp = tmp.substring(CONF.default_root.length - 1);\n\n\t// component files\n\tif (tmp[1] === '~') {\n\t\tvar index = tmp.indexOf('/', 2);\n\t\tvar name = tmp.substring(2, index);\n\t\treturn F.components.files[name] && F.components.files[name][tmp.substring(index + 1)] ? (F.path.temp() + tmp.substring(1)) : null;\n\t}\n\n\tif (F.routes.mapping[url])\n\t\treturn F.routes.mapping[url];\n\n\tif (F._length_themes) {\n\t\tvar index = tmp.indexOf('/', 2);\n\t\tif (index !== -1) {\n\t\t\tvar themeName = tmp.substring(1, index);\n\t\t\tif (F.themes[themeName])\n\t\t\t\treturn F.themes[themeName] + 'public' + tmp.substring(index);\n\t\t}\n\t}\n\n\tdef = framework_internal.preparePath(def, true);\n\n\tif (encode)\n\t\tdef = $decodeURIComponent(def);\n\n\tif (ispublic)\n\t\tdef = F.path.public_cache(def);\n\telse\n\t\tdef = def[0] === '~' ? def.substring(1) : def[0] === '.' ? def : F.path.public_cache(def);\n\n\treturn def;\n};\n\nglobal.DOWNLOAD = F.download = F.snapshot = function(url, filename, callback) {\n\n\tif (!F.isLoaded && url[0] === '/') {\n\t\tsetTimeout(F.download, 200, url, filename, callback);\n\t\treturn F;\n\t}\n\n\turl = framework_internal.preparePath(url);\n\n\tif (!REG_HTTPHTTPS.test(url)) {\n\t\tif (url[0] !== '/')\n\t\t\turl = '/' + url;\n\t\tif (F.isWorker)\n\t\t\tthrow new Error('Worker can\\'t create a snapshot from the relative URL address \"{0}\".'.format(url));\n\t\turl = 'http://' + (F.ip === 'auto' ? '0.0.0.0' : F.ip) + ':' + F.port + url;\n\t}\n\n\tU.download(url, FLAGS_DOWNLOAD, function(err, response) {\n\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t\tcallback = null;\n\t\t\treturn;\n\t\t}\n\n\t\tvar stream = Fs.createWriteStream(filename);\n\n\t\tvar done = function(err) {\n\t\t\tif (callback) {\n\t\t\t\tcallback(err);\n\t\t\t\tcallback = null;\n\t\t\t}\n\t\t};\n\n\t\tresponse.pipe(stream);\n\t\tresponse.on('error', done);\n\t\tstream.on('error', done);\n\t\tCLEANUP(stream, done);\n\t});\n\n\treturn F;\n};\n\n/**\n * Find WebSocket connection\n * @param {String/RegExp} path\n * @return {WebSocket}\n */\nF.findConnection = function(path) {\n\tvar arr = Object.keys(F.connections);\n\tvar is = U.isRegExp(path);\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar key = arr[i];\n\t\tif (is) {\n\t\t\tif (path.test(key))\n\t\t\t\treturn F.connections[key];\n\t\t} else {\n\t\t\tif (key.indexOf(path) !== -1)\n\t\t\t\treturn F.connections[key];\n\t\t}\n\t}\n};\n\n/**\n * Find WebSocket connections\n * @param {String/RegExp} path\n * @return {WebSocket Array}\n */\nF.findConnections = function(path) {\n\tvar arr = Object.keys(F.connections);\n\tvar is = U.isRegExp(path);\n\tvar output = [];\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar key = arr[i];\n\t\tif (!path)\n\t\t\toutput.push(F.connections[key]);\n\t\telse if (is)\n\t\t\tpath.test(key) && output.push(F.connections[key]);\n\t\telse\n\t\t\tkey.indexOf(path) !== -1 && output.push(F.connections[key]);\n\t}\n\treturn output;\n};\n\n/**\n * Global validation\n * @param {Function(name, value)} delegate\n * @type {Boolean or StringErrorMessage}\n */\nF.onValidate = null;\n\n/**\n * Global XML parsing\n * @param {String} value\n * @return {Object}\n */\nF.onParseXML = function(value, replace) {\n\tvar val = U.parseXML(value, replace);\n\tF._length_convertors && F.convert(val);\n\treturn val;\n};\nF.onParseXML.$def = true;\n\nF.$onParseXML = function(req) {\n\tif (F.onParseXML.$def) {\n\t\treq.body = U.parseXML(req.buffer_data);\n\t\tF._length_convertors && F.convert(req.body);\n\t} else\n\t\treq.body = F.onParseXML(req.buffer_data);\n};\n\n/**\n * Global JSON parsing\n * @param {String} value\n * @return {Object}\n */\nF.onParseJSON = function(value) {\n\tif (value) {\n\t\ttry {\n\t\t\treturn JSON.parse(value);\n\t\t} catch (e) {}\n\t}\n};\nF.onParseJSON.$def = true;\n\nF.$onParseJSON = function(req) {\n\treq.body = F.onParseJSON.$def ? JSON.parse(req.buffer_data) : F.onParseJSON(req.buffer_data);\n};\n\nfunction parseQueryArgumentsDecode(val) {\n\ttry {\n\t\treturn decodeURIComponent(val);\n\t} catch (e) {\n\t\treturn '';\n\t}\n}\n\nconst QUERY_ALLOWED = { '45': 1, '95': 1, 46: 1, '91': 1, '92': 1 };\n\nfunction parseQueryArguments(str) {\n\n\tvar obj = {};\n\tvar key = '';\n\tvar val = '';\n\tvar is = false;\n\tvar decodev = false;\n\tvar decodek = false;\n\tvar count = 0;\n\tvar pos = 0;\n\n\tstr += '&';\n\n\tfor (var i = 0; i < str.length; i++) {\n\t\tvar n = str.charCodeAt(i);\n\n\t\tif (n === 38) {\n\n\t\t\tif (key) {\n\t\t\t\tif (pos < i)\n\t\t\t\t\tval += str.substring(pos, i);\n\n\t\t\t\tif (decodev)\n\t\t\t\t\tval = parseQueryArgumentsDecode(val);\n\n\t\t\t\tif (decodek)\n\t\t\t\t\tkey = parseQueryArgumentsDecode(key);\n\n\t\t\t\tobj[key] = val;\n\t\t\t}\n\n\t\t\tif (key)\n\t\t\t\tkey = '';\n\n\t\t\tif (val)\n\t\t\t\tval = '';\n\n\t\t\tpos = i + 1;\n\t\t\tis = false;\n\t\t\tdecodek = false;\n\t\t\tdecodev = false;\n\n\t\t\tif ((count++) >= QUERYPARSEROPTIONS.maxKeys)\n\t\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\tif (n === 61) {\n\t\t\t\tif ((i - pos) > CONF.default_request_maxkey)\n\t\t\t\t\tkey = '';\n\t\t\t\telse {\n\t\t\t\t\tif (pos < i)\n\t\t\t\t\t\tkey += str.substring(pos, i);\n\t\t\t\t\tpos = i + 1;\n\t\t\t\t\tis = true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!is) {\n\n\t\t\t\tvar can = false;\n\n\t\t\t\tif (n > 47 && n < 58)\n\t\t\t\t\tcan = true;\n\t\t\t\telse if ((n > 64 && n < 91) || (n > 96 && n < 123))\n\t\t\t\t\tcan = true;\n\t\t\t\telse if (QUERY_ALLOWED[n])\n\t\t\t\t\tcan = true;\n\n\t\t\t\tif (!can)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (n === 43) {\n\t\t\t\tif (is)\n\t\t\t\t\tval += str.substring(pos, i) + ' ';\n\t\t\t\telse\n\t\t\t\t\tkey += str.substring(pos, i) + ' ';\n\t\t\t\tpos = i + 1;\n\t\t\t}\n\n\t\t\tif (n === 37) {\n\t\t\t\tif (str.charCodeAt(i + 1) === 48 && str.charCodeAt(i + 2) === 48)\n\t\t\t\t\tpos = i + 3;\n\t\t\t\telse if (is) {\n\t\t\t\t\tif (!decodev)\n\t\t\t\t\t\tdecodev = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!decodev)\n\t\t\t\t\t\tdecodek = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj;\n}\n\n/**\n * Global JSON parsing\n * @param {String} value\n * @return {Object}\n */\nF.onParseQuery = function(value) {\n\tif (value) {\n\t\t// var val = Qs.parse(value, null, null, QUERYPARSEROPTIONS);\n\t\tvar val = parseQueryArguments(value);\n\t\tF._length_convertors && F.convert(val);\n\t\treturn val;\n\t}\n\treturn {};\n};\nF.onParseQuery.$def = true;\n\nF.$onParseQueryBody = function(req) {\n\tif (F.onParseQuery.$def) {\n\t\tif (req.buffer_data) {\n\t\t\t// req.body = Qs.parse(req.buffer_data, null, null, QUERYPARSEROPTIONS);\n\t\t\treq.body = parseQueryArguments(req.buffer_data);\n\t\t\tF._length_convertors && F.convert(req.body);\n\t\t} else\n\t\t\treq.body = {};\n\t} else\n\t\treq.body = F.onParseQuery(req.buffer_data, req);\n};\n\nF.$onParseQueryUrl = function(req) {\n\tif (F.onParseQuery.$def) {\n\t\tif (req.uri.query) {\n\t\t\t// req._querydata = Qs.parse(req.uri.query, null, null, QUERYPARSEROPTIONS);\n\t\t\treq._querydata = parseQueryArguments(req.uri.query);\n\t\t\tF._length_convertors && F.convert(req._querydata);\n\t\t} else\n\t\t\treq._querydata = {};\n\t} else\n\t\treq._querydata = F.onParseQuery(req.uri.query, req);\n};\n\n/**\n * Schema parser delegate\n * @param {Request} req\n * @param {String} group\n * @param {String} name\n * @param {Function(err, body)} callback\n */\nF.onSchema = function(req, route, callback) {\n\n\tvar schema;\n\n\tif (route.isDYNAMICSCHEMA) {\n\t\tvar index = route.param[route.paramnames.indexOf(route.schema[1])];\n\t\treq.$schemaname = route.schema[0] + '/' + req.split[index];\n\t\tschema = framework_builders.findschema(req.$schemaname);\n\t} else\n\t\tschema = GETSCHEMA(route.schema[0], route.schema[1]);\n\n\tif (req.method === 'PATCH' || req.method === 'DELETE')\n\t\treq.$patch = true;\n\n\tif (schema)\n\t\tschema.make(req.body, route.schema[2], onSchema_callback, callback, route.novalidate, route.workflow ? route.workflow.meta : null, req);\n\telse\n\t\tcallback('Schema \"' + (route.isDYNAMICSCHEMA ? req.$schemaname : (route.schema[0] + '/' + route.schema[1])) + '\" not found.');\n};\n\nfunction onSchema_callback(err, res, callback) {\n\tif (err)\n\t\tcallback(err);\n\telse\n\t\tcallback(null, res);\n}\n\nvar onmailsendforce = (cb, message) => message.send2(cb);\n\n/**\n * Mail delegate\n * @param {String or Array String} address\n * @param {String} subject\n * @param {String} body\n * @param {Function(err)} callback\n * @param {String} replyTo\n * @return {MailMessage}\n */\nF.onMail = function(address, subject, body, callback, replyTo) {\n\n\tvar tmp;\n\n\tif (typeof(callback) === 'string') {\n\t\ttmp = replyTo;\n\t\treplyTo = callback;\n\t\tcallback = tmp;\n\t}\n\n\tvar message = Mail.create(subject, body);\n\n\tif (address instanceof Array) {\n\t\tfor (var i = 0, length = address.length; i < length; i++)\n\t\t\tmessage.to(address[i]);\n\t} else\n\t\tmessage.to(address);\n\n\tmessage.from(CONF.mail_address_from || '', CONF.name);\n\n\tif (replyTo)\n\t\tmessage.reply(replyTo);\n\telse {\n\t\ttmp = CONF.mail_address_reply;\n\t\ttmp && tmp.length > 3 && message.reply(tmp);\n\t}\n\n\ttmp = CONF.mail_address_copy;\n\ttmp && tmp.length > 3 && message.bcc(tmp);\n\n\tmessage.$sending = setImmediate(onmailsendforce, callback, message);\n\treturn message;\n};\n\nF.onMeta = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\tvar self = this;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar arg = U.encode(arguments[i]);\n\t\tif (arg == null || !arg.length)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tbuilder += '<title>' + (arg + (F.url !== '/' && !CONF.allow_custom_titles ? ' - ' + CONF.name : '')) + '</title>';\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuilder += '<meta name=\"description\" content=\"' + arg + '\" />';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuilder += '<meta name=\"keywords\" content=\"' + arg + '\" />';\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tvar tmp = arg.substring(0, 6);\n\t\t\t\tvar img = tmp === 'http:/' || tmp === 'https:' || arg.substring(0, 2) === '//' ? arg : self.hostname(self.public_image(arg));\n\t\t\t\tbuilder += '<meta property=\"og:image\" content=\"' + img + '\" /><meta name=\"twitter:image\" content=\"' + img + '\" />';\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn builder;\n};\n\nglobal.AUDIT = function(name, $, type, message) {\n\n\tif (message == null) {\n\t\tmessage = type;\n\t\ttype = null;\n\t}\n\n\tvar data = {};\n\n\tif ($.user) {\n\t\tdata.userid = $.user.id;\n\t\tdata.username = $.user.name || $.user.nick || $.user.alias;\n\t}\n\n\tif ($.req) {\n\t\tif ($.req.sessionid)\n\t\t\tdata.sessionid = $.req.sessionid;\n\t\tdata.ua = $.req.ua;\n\t\tdata.ip = $.ip;\n\t}\n\n\tif (type)\n\t\tdata.type = type;\n\n\tif ($.name)\n\t\tdata.caller = ($.schema ? ($.schema.name + '/') : '') + $.name;\n\n\tif (F.id)\n\t\tdata.instance = F.id;\n\n\tdata.created = NOW = new Date();\n\n\tif (message)\n\t\tdata.message = message;\n\n\tDEF.onAudit(name, data);\n};\n\nglobal.NOSQLREADER = function(filename) {\n\tif (!global.framework_nosql)\n\t\tglobal.framework_nosql = require('./nosql');\n\treturn new framework_nosql.Database('readonlynosql', filename, true);\n};\n\nglobal.TABLEREADER = function(filename) {\n\tif (!global.framework_nosql)\n\t\tglobal.framework_nosql = require('./nosql');\n\treturn new framework_nosql.Table('readonlytable', filename, true);\n};\n\n// @arguments {Object params}\nglobal.LOG = F.log = function() {\n\n\tNOW = new Date();\n\tvar filename = NOW.getFullYear() + '-' + (NOW.getMonth() + 1).toString().padLeft(2, '0') + '-' + NOW.getDate().toString().padLeft(2, '0');\n\tvar time = NOW.getHours().toString().padLeft(2, '0') + ':' + NOW.getMinutes().toString().padLeft(2, '0') + ':' + NOW.getSeconds().toString().padLeft(2, '0');\n\tvar str = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar val = arguments[i];\n\t\tif (val === undefined)\n\t\t\tval = 'undefined';\n\t\telse if (val === null)\n\t\t\tval = 'null';\n\t\telse if (typeof(val) === 'object')\n\t\t\tval = Util.inspect(val);\n\t\tstr += (str ? ' ' : '') + val;\n\t}\n\n\tF.path.verify('logs');\n\tU.queue('F.log', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, filename + '.log'), time + ' | ' + str + '\\n', next));\n\treturn F;\n};\n\nglobal.LOGGER = F.logger = function() {\n\tNOW = new Date();\n\tvar dt = NOW.getFullYear() + '-' + (NOW.getMonth() + 1).toString().padLeft(2, '0') + '-' + NOW.getDate().toString().padLeft(2, '0') + ' ' + NOW.getHours().toString().padLeft(2, '0') + ':' + NOW.getMinutes().toString().padLeft(2, '0') + ':' + NOW.getSeconds().toString().padLeft(2, '0');\n\tvar str = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 1; i < length; i++) {\n\t\tvar val = arguments[i];\n\t\tif (val === undefined)\n\t\t\tval = 'undefined';\n\t\telse if (val === null)\n\t\t\tval = 'null';\n\t\telse if (typeof(val) === 'object')\n\t\t\tval = Util.inspect(val);\n\t\tstr += (str ? ' ' : '') + val;\n\t}\n\n\tF.path.verify('logs');\n\tU.queue('F.logger', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, arguments[0] + '.log'), dt + ' | ' + str + '\\n', next));\n\treturn F;\n};\n\nglobal.LOGMAIL = F.logmail = function(address, subject, body, callback) {\n\n\tif (typeof(body) === FUNCTION) {\n\t\tcallback = body;\n\t\tbody = subject;\n\t\tsubject = null;\n\t} else if (body === undefined) {\n\t\tbody = subject;\n\t\tsubject = null;\n\t}\n\n\tif (!subject)\n\t\tsubject = CONF.name + ' v' + CONF.version;\n\n\tvar body = '<!DOCTYPE html><html><head><title>' + subject + '</title><meta charset=\"utf-8\" /></head><body><pre style=\"max-width:600px;font-size:13px;line-height:16px;white-space:pre-line\">' + (typeof(body) === 'object' ? JSON.stringify(body).escape() : body) + '</pre></body></html>';\n\treturn F.onMail(address, subject, body, callback);\n};\n\nF.usage = function(detailed) {\n\n\tvar memory = process.memoryUsage();\n\tvar cache = Object.keys(F.cache.items);\n\tvar resources = Object.keys(F.resources);\n\tvar controllers = Object.keys(F.controllers);\n\tvar connections = Object.keys(F.connections);\n\tvar schedules = Object.keys(F.schedules);\n\tvar workers = Object.keys(F.workers);\n\tvar modules = Object.keys(F.modules);\n\tvar isomorphic = Object.keys(F.isomorphic);\n\tvar models = Object.keys(F.models);\n\tvar helpers = Object.keys(F.helpers);\n\tvar staticFiles = Object.keys(F.temporary.path);\n\tvar staticNotfound = Object.keys(F.temporary.notfound);\n\tvar staticRange = Object.keys(F.temporary.range);\n\tvar redirects = Object.keys(F.routes.redirects);\n\tvar commands = Object.keys(F.commands);\n\tvar output = {};\n\tvar nosqlcleaner = Object.keys(F.databasescleaner);\n\tvar sessions = Object.keys(F.sessions);\n\tvar shortcache = Object.keys(F.temporary.shortcache);\n\n\toutput.framework = {\n\t\tid: F.id,\n\t\tdatetime: NOW,\n\t\tpid: process.pid,\n\t\tnode: process.version,\n\t\tversion: 'v' + F.version_header,\n\t\tplatform: process.platform,\n\t\tprocessor: process.arch,\n\t\tuptime: Math.floor(process.uptime() / 60),\n\t\tmemoryTotal: (memory.heapTotal / 1024 / 1024).floor(2),\n\t\tmemoryUsage: (memory.heapUsed / 1024 / 1024).floor(2),\n\t\tmemoryRss: (memory.rss / 1024 / 1024).floor(2),\n\t\tmode: DEBUG,\n\t\tport: F.port,\n\t\tip: F.ip,\n\t\tdirectory: process.cwd()\n\t};\n\n\tif (CONF.nosql_worker && global.framework_nosql)\n\t\toutput.framework.pidnosql = framework_nosql.pid();\n\n\tvar keys = Object.keys(U.queuecache);\n\tvar pending = 0;\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\tpending += U.queuecache[keys[i]].pending.length;\n\n\toutput.counter = {\n\t\tresource: resources.length,\n\t\tcontroller: controllers.length,\n\t\tmodule: modules.length,\n\t\tisomorphic: isomorphic.length,\n\t\tcache: cache.length,\n\t\tworker: workers.length,\n\t\tconnection: connections.length,\n\t\tschedule: schedules.length,\n\t\thelpers: helpers.length,\n\t\terror: F.errors.length,\n\t\tproblem: F.problems.length,\n\t\tqueue: pending,\n\t\tfiles: staticFiles.length,\n\t\tnotfound: staticNotfound.length,\n\t\tstreaming: staticRange.length,\n\t\tmodificator:  F.modificators ? F.modificators.length : 0,\n\t\tviewphrases: $VIEWCACHE.length,\n\t\tuptodates: F.uptodates ? F.uptodates.length : 0,\n\t\tnosqlcleaner: nosqlcleaner.length,\n\t\tcommands: commands.length,\n\t\tsessions: sessions.length,\n\t\tshortcache: shortcache.length\n\t};\n\n\toutput.routing = {\n\t\twebpage: F.routes.web.length,\n\t\tsitemap: F.routes.sitemap ? Object.keys(F.routes.sitemap).length : 0,\n\t\twebsocket: F.routes.websockets.length,\n\t\tfile: F.routes.files.length,\n\t\tmiddleware: Object.keys(F.routes.middleware).length,\n\t\tredirect: redirects.length\n\t};\n\n\toutput.stats = F.stats;\n\toutput.redirects = redirects;\n\n\tif (!detailed)\n\t\treturn output;\n\n\toutput.controllers = [];\n\tfor (var i = 0, length = controllers.length; i < length; i++) {\n\t\tvar key = controllers[i];\n\t\tvar item = F.controllers[key];\n\t\toutput.controllers.push({ name: key, usage: item.usage ? item.usage() : null });\n\t}\n\n\toutput.connections = [];\n\tfor (var i = 0, length = connections.length; i < length; i++) {\n\t\tvar key = connections[i];\n\t\toutput.connections.push({ name: key, online: F.connections[key].online });\n\t}\n\n\toutput.modules = [];\n\tfor (var i = 0, length = modules.length; i < length; i++) {\n\t\tvar key = modules[i];\n\t\tvar item = F.modules[key];\n\t\toutput.modules.push({ name: key, usage: item.usage ? item.usage() : null });\n\t}\n\n\toutput.models = [];\n\tfor (var i = 0, length = models.length; i < length; i++) {\n\t\tvar key = models[i];\n\t\tvar item = F.models[key];\n\t\toutput.models.push({ name: key, usage: item.usage ? item.usage() : null });\n\t}\n\n\toutput.sessions = [];\n\n\tfor (var i = 0, length = sessions.length; i < length; i++) {\n\t\tvar key = sessions[i];\n\t\tvar item = F.sessions[key];\n\t\toutput.sessions.push({ name: key, usage: item.usage() });\n\t}\n\n\toutput.cache = cache;\n\toutput.changes = F.changes;\n\toutput.errors = F.errors;\n\toutput.files = staticFiles;\n\toutput.helpers = helpers;\n\toutput.nosqlcleaner = nosqlcleaner;\n\toutput.other = Object.keys(F.temporary.other);\n\toutput.problems = F.problems;\n\toutput.resources = resources;\n\toutput.commands = commands;\n\toutput.streaming = staticRange;\n\toutput.traces = F.traces;\n\toutput.uptodates = F.uptodates;\n\toutput.shortcache = shortcache;\n\n\treturn output;\n};\n\nF.onPrefSave = function(val) {\n\tFs.writeFile(F.path.databases(PREFFILE), JSON.stringify(val), ERROR('F.onPrefSave'));\n};\n\nF.onPrefLoad = function(next) {\n\tFs.readFile(U.combine(CONF.directory_databases, PREFFILE), function(err, data) {\n\t\tif (data)\n\t\t\tnext(data.toString('utf8').parseJSON(true));\n\t\telse\n\t\t\tnext();\n\t});\n};\n\nDEF.onAudit = F.onAudit = function(name, data) {\n\tF.path.verify('logs');\n\tU.queue('F.logger', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, name + '.log'), JSON.stringify(data) + '\\n', next));\n};\n\n/**\n * Compiles content in the view @{compile}...@{end}. The function has controller context, this === controler.\n * @param {String} name\n * @param {String} html HTML content to compile\n * @param {Object} model\n * @return {String}\n */\n// name, html, model\nF.onCompileView = function(name, html) {\n\treturn html;\n};\n\n/*\n\t3rd CSS compiler (Sync)\n\t@filename {String}\n\t@content {String} :: Content of CSS file\n\treturn {String}\n*/\nF.onCompileStyle = null;\n\n/*\n\t3rd JavaScript compiler (Sync)\n\t@filename {String}\n\t@content {String} :: Content of JavaScript file\n\treturn {String}\n*/\nF.onCompileScript = null;\n\nfunction compile_file(res) {\n\tfsFileRead(res.options.filename, function(err, buffer) {\n\n\t\tvar req = res.req;\n\t\tvar uri = req.uri;\n\n\t\tif (err) {\n\t\t\tF.error(err, res.options.filename, uri);\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t\treturn;\n\t\t}\n\n\t\tvar file = F.path.temp((F.id ? 'i-' + F.id + '_' : '') + createTemporaryKey(uri.pathname));\n\t\tF.path.verify('temp');\n\t\tFs.writeFileSync(file, compile_content(req.extension, framework_internal.parseBlock(F.routes.blocks[uri.pathname], buffer.toString(ENCODING)), res.options.filename), ENCODING);\n\t\tvar stats = Fs.statSync(file);\n\t\tvar tmp = [file, stats.size, stats.mtime.toUTCString()];\n\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t});\n\t});\n}\n\nfunction compile_merge(res, repeated) {\n\n\tvar req = res.req;\n\tvar uri = req.uri;\n\n\tvar merge = F.routes.merge[uri.pathname];\n\tvar filename = merge.filename;\n\n\tif (!DEBUG && existsSync(filename)) {\n\t\tvar stats = Fs.statSync(filename);\n\t\tvar tmp = [filename, stats.size, stats.mtime.toUTCString()];\n\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tres.$file();\n\t\t});\n\t\treturn;\n\t}\n\n\tvar writer = Fs.createWriteStream(filename);\n\tvar index = 0;\n\tvar remove = null;\n\n\tmerge.files.wait(function(filename, next) {\n\n\t\tvar block;\n\n\t\t// Skip isomorphic\n\t\tif (filename[0] !== '#') {\n\t\t\tvar blocks = filename.split('#');\n\t\t\tblock = blocks[1];\n\t\t\tblock && (filename = blocks[0]);\n\t\t}\n\n\t\tif (filename.startsWith('http://') || filename.startsWith('https://')) {\n\t\t\tU.request(filename, FLAGS_DOWNLOAD, function(err, data) {\n\n\t\t\t\tvar output = compile_content(req.extension, framework_internal.parseBlock(block, data), filename);\n\n\t\t\t\tif (JSFILES[req.extension]) {\n\t\t\t\t\tif (output[output.length - 1] !== ';')\n\t\t\t\t\t\toutput += ';';\n\t\t\t\t} else if (req.extension === 'html') {\n\t\t\t\t\tif (output[output.length - 1] !== NEWLINE)\n\t\t\t\t\t\toutput += NEWLINE;\n\t\t\t\t}\n\n\t\t\t\tDEBUG && merge_debug_writer(writer, filename, req.extension, index++, block);\n\t\t\t\twriter.write(output);\n\t\t\t\tnext();\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tif (filename[0] !== '~') {\n\t\t\tvar tmp = F.path.public(filename);\n\t\t\tif (F.isVirtualDirectory && !existsSync(tmp))\n\t\t\t\ttmp = F.path.virtual(filename);\n\t\t\tfilename = tmp;\n\t\t} else\n\t\t\tfilename = filename.substring(1);\n\n\t\tvar indexer = filename.indexOf('*');\n\t\tif (indexer !== -1) {\n\n\t\t\tvar tmp = filename.substring(indexer + 1).toLowerCase();\n\t\t\tvar len = tmp.length;\n\t\t\t!remove && (remove = []);\n\n\t\t\t// Remove directory for all future requests\n\t\t\tremove.push(arguments[0]);\n\n\t\t\tU.ls(filename.substring(0, indexer), function(files) {\n\t\t\t\tfor (var j = 0, l = files.length; j < l; j++)\n\t\t\t\t\tmerge.files.push('~' + files[j]);\n\t\t\t\tnext();\n\t\t\t}, (path, isDirectory) => isDirectory ? true : path.substring(path.length - len).toLowerCase() === tmp);\n\t\t\treturn;\n\t\t}\n\n\t\tfsFileRead(filename, function(err, buffer) {\n\n\t\t\tif (err) {\n\t\t\t\tF.error(err, merge.filename, uri);\n\t\t\t\tnext();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar output = compile_content(req.extension, framework_internal.parseBlock(block, buffer.toString(ENCODING)), filename);\n\t\t\tif (JSFILES[req.extension]) {\n\t\t\t\tif (output[output.length - 1] !== ';')\n\t\t\t\t\toutput += ';' + NEWLINE;\n\t\t\t} else if (req.extension === 'html') {\n\t\t\t\tif (output[output.length - 1] !== NEWLINE)\n\t\t\t\t\toutput += NEWLINE;\n\t\t\t}\n\n\t\t\tDEBUG && merge_debug_writer(writer, filename, req.extension, index++, block);\n\t\t\twriter.write(output);\n\t\t\tnext();\n\t\t});\n\n\t}, function() {\n\n\t\tCLEANUP(writer, function() {\n\n\t\t\tvar stats;\n\n\t\t\ttry {\n\t\t\t\tstats = Fs.statSync(filename);\n\t\t\t} catch (e) {\n\n\t\t\t\te && F.error(e, 'compile_merge' + (repeated ? ' - repeated' : ''), req.url);\n\n\t\t\t\t// Try it again\n\t\t\t\tif (repeated) {\n\t\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(req, res))\n\t\t\t\t\t\tres.throw404();\n\t\t\t\t} else\n\t\t\t\t\tcompile_merge(res, true);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tmp = [filename, stats.size, stats.mtime.toUTCString()];\n\t\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t\tres.$file();\n\t\t\t});\n\t\t});\n\n\t\twriter.end();\n\n\t\t// Removes all directories from merge list (because the files are added into the queue)\n\t\tif (remove) {\n\t\t\tfor (var i = 0, length = remove.length; i < length; i++)\n\t\t\t\tmerge.files.splice(merge.files.indexOf(remove[i]), 1);\n\t\t}\n\t});\n\n\treturn F;\n}\n\nfunction merge_debug_writer(writer, filename, extension, index, block) {\n\tvar plus = '===========================================================================================';\n\tvar beg = JSFILES[extension] ? '/*\\n' : extension === 'css' ? '/*!\\n' : '<!--\\n';\n\tvar end = JSFILES[extension] || extension === 'css' ? '\\n */' : '\\n-->';\n\tvar mid = extension !== 'html' ? ' * ' : ' ';\n\twriter.write((index > 0 ? '\\n\\n' : '') + beg + mid + plus + '\\n' + mid + 'MERGED: ' + filename + '\\n' + (block ? mid + 'BLOCKS: ' + block + '\\n' : '') + mid + plus + end + '\\n\\n', ENCODING);\n}\n\nfunction component_debug(filename, value, extension) {\n\tvar plus = '===========================================================================================';\n\tvar beg = JSFILES[extension] ? '/*\\n' : extension === 'css' ? '/*!\\n' : '<!--\\n';\n\tvar end = JSFILES[extension] || extension === 'css' ? '\\n */' : '\\n-->';\n\tvar mid = extension !== 'html' ? ' * ' : ' ';\n\treturn beg + mid + plus + '\\n' + mid + 'COMPONENT: ' + filename + '\\n' + mid + plus + end + '\\n\\n' + value;\n}\n\nF.compile_virtual = function(res) {\n\n\tvar req = res.req;\n\tvar tmpname = res.options.filename.replace(CONF.directory_public, CONF.directory_public_virtual);\n\n\tif (tmpname === res.options.filename) {\n\t\tF.temporary.notfound[req.$key] = true;\n\t\tdelete F.temporary.processing[req.$key];\n\t\tres.$file();\n\t\treturn;\n\t}\n\n\tfsFileExists(tmpname, function(e, size, sfile, stats) {\n\n\t\tif (!e) {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!res.noCompress && COMPRESSIONSPECIAL[req.extension] && CONF.allow_compile && !REG_NOCOMPRESS.test(res.options.filename)) {\n\t\t\tres.options.filename = tmpname;\n\t\t\treturn compile_file(res);\n\t\t}\n\n\t\tvar tmp = [tmpname, size, stats.mtime.toUTCString()];\n\t\tif (CONF.allow_gzip && COMPRESSION[U.getContentType(req.extension)]) {\n\t\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t\tres.$file();\n\t\t\t});\n\t\t} else {\n\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t}\n\t});\n\n\treturn;\n};\n\nfunction compile_check(res) {\n\n\tvar req = res.req;\n\tvar uri = req.uri;\n\n\tif (F.routes.merge[uri.pathname]) {\n\t\tcompile_merge(res);\n\t\treturn;\n\t}\n\n\tfsFileExists(res.options.filename, function(e, size, sfile, stats) {\n\n\t\tif (e) {\n\n\t\t\tif (!res.noCompress && COMPRESSIONSPECIAL[req.extension] && CONF.allow_compile && !REG_NOCOMPRESS.test(res.options.filename))\n\t\t\t\treturn compile_file(res);\n\n\t\t\tvar tmp = [res.options.filename, size, stats.mtime.toUTCString()];\n\t\t\tif (CONF.allow_gzip && COMPRESSION[U.getContentType(req.extension)]) {\n\t\t\t\tcompile_gzip(tmp, function(tmp) {\n\t\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\t\tres.$file();\n\t\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tF.temporary.path[req.$key] = tmp;\n\t\t\t\tres.$file();\n\t\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\t}\n\n\t\t} else if (F.isVirtualDirectory)\n\t\t\tF.compile_virtual(res);\n\t\telse {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tdelete F.temporary.processing[req.$key];\n\t\t\tres.$file();\n\t\t}\n\t});\n}\n\nfunction compile_gzip(arr, callback) {\n\n\t// GZIP compression\n\n\tvar filename = F.path.temp('file' + arr[0].hash().toString().replace('-', '0') + '.gz');\n\tarr.push(filename);\n\n\tF.stats.performance.open++;\n\tvar reader = Fs.createReadStream(arr[0]);\n\tvar writer = Fs.createWriteStream(filename);\n\n\tCLEANUP(writer, function() {\n\t\tfsFileExists(filename, function(e, size) {\n\t\t\tarr.push(size);\n\t\t\tcallback(arr);\n\t\t});\n\t});\n\n\treader.pipe(Zlib.createGzip(GZIPFILE)).pipe(writer);\n\tCLEANUP(reader);\n}\n\nfunction compile_content(extension, content, filename) {\n\n\tif (filename && REG_NOCOMPRESS.test(filename))\n\t\treturn content;\n\n\tswitch (extension) {\n\t\tcase 'js':\n\t\tcase 'mjs':\n\t\t\treturn CONF.allow_compile_script ? framework_internal.compile_javascript(content, filename) : content;\n\n\t\tcase 'css':\n\t\t\tcontent = CONF.allow_compile_style ? framework_internal.compile_css(content, filename) : content;\n\t\t\tvar matches = content.match(REG_COMPILECSS);\n\t\t\tif (matches) {\n\t\t\t\tfor (var i = 0, length = matches.length; i < length; i++) {\n\t\t\t\t\tvar key = matches[i];\n\t\t\t\t\tvar url = key.substring(4, key.length - 1);\n\t\t\t\t\tcontent = content.replace(key, 'url(' + F.$version(url, true) + ')');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn content;\n\t}\n\n\treturn content;\n}\n\nF.restore = function(filename, target, callback, filter) {\n\n\tvar buffer_key = Buffer.from(':');\n\tvar buffer_new = Buffer.from('\\n');\n\tvar buffer_dir = Buffer.from('#');\n\tvar cache = {};\n\tvar data = null;\n\tvar type = 0;\n\tvar item = null;\n\tvar stream = Fs.createReadStream(filename);\n\tvar index = 0;\n\tvar parser = {};\n\tvar open = {};\n\tvar pending = 0;\n\tvar end = false;\n\tvar output = {};\n\n\toutput.count = 0;\n\toutput.path = target;\n\n\tparser.parse_key = function() {\n\n\t\tindex = data.indexOf(buffer_key);\n\t\tif (index === -1)\n\t\t\treturn;\n\n\t\tindex++;\n\t\titem = data.slice(0, index - 1).toString('utf8').trim();\n\t\tdata = data.slice(index + (data[index] === 32 ? 1 : 0));\n\t\ttype = 1;\n\t\tparser.next();\n\t};\n\n\tparser.parse_meta = function() {\n\t\tvar path = Path.join(target, item);\n\n\t\t// Is directory?\n\t\tif (data[0] === buffer_dir[0]) {\n\t\t\tif (!cache[path]) {\n\t\t\t\tcache[path] = true;\n\t\t\t\tif (!filter || filter(item, true) !== false)\n\t\t\t\t\tF.path.mkdir(path);\n\t\t\t}\n\t\t\ttype = 3;\n\t\t\tparser.next();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!cache[path]) {\n\t\t\tcache[path] = true;\n\n\t\t\tvar npath = path.substring(0, path.lastIndexOf(F.isWindows ? '\\\\' : '/'));\n\n\t\t\tvar filename = filter && filter(item, false);\n\n\t\t\tif (!filter || filename || filename == null)\n\t\t\t\tF.path.mkdir(npath);\n\t\t\telse {\n\t\t\t\ttype = 5; // skip\n\t\t\t\tparser.next();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(filename) === 'string')\n\t\t\tpath = Path.join(target, filename);\n\n\t\t// File\n\t\ttype = 2;\n\t\tvar tmp = open[item] = {};\n\t\ttmp.path = path;\n\t\ttmp.name = item;\n\t\ttmp.writer = Fs.createWriteStream(path);\n\t\ttmp.zlib = Zlib.createGunzip();\n\t\ttmp.zlib.$self = tmp;\n\t\tpending++;\n\n\t\toutput.count++;\n\n\t\ttmp.zlib.on('error', function(e) {\n\t\t\tpending--;\n\t\t\tvar tmp = this.$self;\n\t\t\ttmp.writer.end();\n\t\t\ttmp.writer = null;\n\t\t\ttmp.zlib = null;\n\t\t\tdelete open[tmp.name];\n\t\t\tF.error(e, 'bundling', path);\n\t\t});\n\n\t\ttmp.zlib.on('data', function(chunk) {\n\t\t\tthis.$self.writer.write(chunk);\n\t\t});\n\n\t\ttmp.zlib.on('end', function() {\n\t\t\tpending--;\n\t\t\tvar tmp = this.$self;\n\t\t\ttmp.writer.end();\n\t\t\ttmp.writer = null;\n\t\t\ttmp.zlib = null;\n\t\t\tdelete open[tmp.name];\n\t\t});\n\n\t\tparser.next();\n\t};\n\n\tparser.parse_dir = function() {\n\t\tindex = data.indexOf(buffer_new);\n\t\tif (index !== -1) {\n\t\t\tdata = data.slice(index + 1);\n\t\t\ttype = 0;\n\t\t}\n\t\tparser.next();\n\t};\n\n\tparser.parse_data = function() {\n\n\t\tindex = data.indexOf(buffer_new);\n\n\t\tvar skip = false;\n\n\t\tif (index !== -1)\n\t\t\ttype = 0;\n\n\t\tif (type) {\n\t\t\tvar remaining = data.length % 4;\n\t\t\tif (remaining) {\n\t\t\t\topen[item].zlib.write(Buffer.from(data.slice(0, data.length - remaining).toString('ascii'), 'base64'));\n\t\t\t\tdata = data.slice(data.length - remaining);\n\t\t\t\tskip = true;\n\t\t\t} else {\n\t\t\t\topen[item].zlib.write(Buffer.from(data.toString('ascii'), 'base64'));\n\t\t\t\tdata = null;\n\t\t\t}\n\t\t} else {\n\t\t\topen[item].zlib.end(Buffer.from(data.slice(0, index).toString('ascii'), 'base64'));\n\t\t\tdata = data.slice(index + 1);\n\t\t}\n\n\t\t!skip && data && data.length && parser.next();\n\t};\n\n\tparser.next = function() {\n\t\tswitch (type) {\n\t\t\tcase 0:\n\t\t\t\tparser.parse_key();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tparser.parse_meta();\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tparser.parse_data();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tparser.parse_dir();\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tindex = data.indexOf(buffer_new);\n\t\t\t\tif (index === -1)\n\t\t\t\t\tdata = null;\n\t\t\t\telse {\n\t\t\t\t\tdata = data.slice(index + 1);\n\t\t\t\t\ttype = 0;\n\t\t\t\t\tparser.next();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tend && !data.length && callback && callback(null, output);\n\t};\n\n\tparser.end = function() {\n\t\tif (callback) {\n\t\t\tif (pending)\n\t\t\t\tsetTimeout(parser.end, 100);\n\t\t\telse if (end && !data.length)\n\t\t\t\tcallback(null, output);\n\t\t}\n\t};\n\n\tstream.on('data', function(chunk) {\n\n\t\tif (data) {\n\t\t\tCONCAT[0] = data;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tdata = Buffer.concat(CONCAT);\n\t\t} else\n\t\t\tdata = chunk;\n\n\t\tparser.next();\n\t});\n\n\tCLEANUP(stream, function() {\n\t\tend = true;\n\t\tparser.end();\n\t});\n\n\treturn F;\n};\n\nF.backup = function(filename, filelist, callback, filter) {\n\n\tvar padding = 100;\n\tvar path = filelist instanceof Array ? F.path.root() : filelist;\n\n\tif (!(filelist instanceof Array))\n\t\tfilelist = [''];\n\n\tvar counter = 0;\n\n\tFs.unlink(filename, function() {\n\n\t\tfilelist.sort(function(a, b) {\n\t\t\tvar ac = a.split('/');\n\t\t\tvar bc = b.split('/');\n\t\t\tif (ac.length < bc.length)\n\t\t\t\treturn -1;\n\t\t\telse if (ac.length > bc.length)\n\t\t\t\treturn 1;\n\t\t\treturn a.localeCompare(b);\n\t\t});\n\n\t\tvar clean = function(path, files) {\n\t\t\tvar index = 0;\n\t\t\twhile (true) {\n\t\t\t\tvar filename = files[index];\n\t\t\t\tif (!filename)\n\t\t\t\t\tbreak;\n\t\t\t\tif (filename.substring(0, path.length) === path) {\n\t\t\t\t\tfiles.splice(index, 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else\n\t\t\t\t\tindex++;\n\t\t\t}\n\t\t};\n\n\t\tvar writer = Fs.createWriteStream(filename);\n\n\t\twriter.on('finish', function() {\n\t\t\tcallback && Fs.stat(filename, (e, stat) => callback(null, { filename: filename, files: counter, size: stat.size }));\n\t\t});\n\n\t\tfilelist.wait(function(item, next) {\n\n\t\t\tvar file = Path.join(path, item);\n\n\t\t\tif (F.isWindows)\n\t\t\t\titem = item.replace(/\\\\/g, '/');\n\n\t\t\tif (item[0] !== '/')\n\t\t\t\titem = '/' + item;\n\n\t\t\tFs.stat(file, function(err, stats) {\n\n\t\t\t\tif (err) {\n\t\t\t\t\tF.error(err, 'F.backup()', filename);\n\t\t\t\t\treturn next();\n\t\t\t\t}\n\n\t\t\t\tif (stats.isDirectory()) {\n\t\t\t\t\tvar dir = item.replace(/\\\\/g, '/');\n\n\t\t\t\t\tif (dir[dir.length - 1] !== '/')\n\t\t\t\t\t\tdir += '/';\n\n\t\t\t\t\tif (filter && !filter(dir, true))\n\t\t\t\t\t\treturn next();\n\n\t\t\t\t\tU.ls(file, function(f, d) {\n\n\t\t\t\t\t\tvar length = path.length;\n\t\t\t\t\t\tif (path[path.length - 1] === '/')\n\t\t\t\t\t\t\tlength--;\n\n\t\t\t\t\t\td.wait(function(item, next) {\n\n\t\t\t\t\t\t\tif (filter && !filter(item.substring(length), true)) {\n\t\t\t\t\t\t\t\tclean(item, f);\n\t\t\t\t\t\t\t\treturn next();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twriter.write(item.substring(length).padRight(padding) + ':#\\n', 'utf8');\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t}, function() {\n\t\t\t\t\t\t\tfor (var i = 0; i < f.length; i++)\n\t\t\t\t\t\t\t\tfilelist.push(f[i].substring(length));\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (filter && !filter(file.substring(path.length - 1), false))\n\t\t\t\t\treturn next();\n\n\t\t\t\tvar data = Buffer.alloc(0);\n\t\t\t\twriter.write(item.padRight(padding) + ':');\n\t\t\t\tFs.createReadStream(file).pipe(Zlib.createGzip(GZIPFILE)).on('data', function(chunk) {\n\n\t\t\t\t\tCONCAT[0] = data;\n\t\t\t\t\tCONCAT[1] = chunk;\n\t\t\t\t\tdata = Buffer.concat(CONCAT);\n\n\t\t\t\t\tvar remaining = data.length % 3;\n\t\t\t\t\tif (remaining) {\n\t\t\t\t\t\twriter.write(data.slice(0, data.length - remaining).toString('base64'));\n\t\t\t\t\t\tdata = data.slice(data.length - remaining);\n\t\t\t\t\t}\n\n\t\t\t\t}).on('end', function() {\n\t\t\t\t\tdata.length && writer.write(data.toString('base64'));\n\t\t\t\t\twriter.write('\\n', 'utf8');\n\t\t\t\t\tcounter++;\n\t\t\t\t\tsetImmediate(next);\n\t\t\t\t});\n\n\t\t\t});\n\t\t}, () => writer.end());\n\t});\n\n\treturn F;\n};\n\nF.exists = function(req, res, max, callback) {\n\n\tif (typeof(max) === 'function') {\n\t\tcallback = max;\n\t\tmax = 10;\n\t}\n\n\tvar name = req.$key = createTemporaryKey(req);\n\tvar filename = F.path.temp(name);\n\tvar httpcachevalid = RELEASE && (req.headers['if-none-match'] === (ETAG + CONF.etag_version));\n\n\tif (F.isProcessed(name) || httpcachevalid) {\n\t\tres.options.filename = filename;\n\t\tres.$file();\n\t\treturn F;\n\t}\n\n\tU.queue('F.exists', max, function(next) {\n\t\tfsFileExists(filename, function(e) {\n\t\t\tif (e) {\n\t\t\t\tres.options.filename = filename;\n\t\t\t\tres.options.callback = next;\n\t\t\t\tres.$file();\n\t\t\t} else\n\t\t\t\tcallback(next, filename, req, res);\n\t\t});\n\t});\n\n\treturn F;\n};\n\n/**\n * Is processed static file?\n * @param {String / Request} filename Filename or Request object.\n * @return {Boolean}\n */\nF.isProcessed = function(filename) {\n\n\tif (filename.url) {\n\t\tvar name = filename.url;\n\t\tvar index = name.indexOf('?');\n\t\tif (index !== -1)\n\t\t\tname = name.substring(0, index);\n\t\tfilename = F.path.public($decodeURIComponent(name));\n\t}\n\n\treturn !F.temporary.notfound[filename] && F.temporary.path[filename] !== undefined;\n};\n\n/**\n * Processing\n * @param {String / Request} filename Filename or Request object.\n * @return {Boolean}\n */\nF.isProcessing = function(filename) {\n\n\tif (!filename.url)\n\t\treturn !!F.temporary.processing[filename];\n\n\tvar name = filename.url;\n\tvar index = name.indexOf('?');\n\n\tif (index !== -1)\n\t\tname = name.substring(0, index);\n\n\tfilename = U.combine(CONF.directory_public, $decodeURIComponent(name));\n\treturn !!F.temporary.processing[filename];\n};\n\n/**\n * Clears file information in release mode\n * @param {String/Request} url\n * @return {Framework}\n */\nF.touch = function(url) {\n\tif (url) {\n\t\tvar key = createTemporaryKey(url);\n\t\tdelete F.temporary.path[key];\n\t\tdelete F.temporary.notfound[key];\n\t} else {\n\t\tF.temporary.path = {};\n\t\tF.temporary.notfound = {};\n\t}\n\treturn F;\n};\n\nF.response503 = function(req, res) {\n\tres.options.code = 503;\n\tres.options.headers = HEADERS.response503;\n\tres.options.body = VIEW('.' + PATHMODULES + res.options.code, F.waits);\n\tres.$text();\n\treturn F;\n};\n\nglobal.LOAD = F.load = function(debug, types, pwd, ready) {\n\n\tif (typeof(types) === 'function') {\n\t\tready = types;\n\t\ttypes = null;\n\t}\n\n\tif (typeof(pwd) === 'function') {\n\t\tready = pwd;\n\t\tpwd = null;\n\t}\n\n\tif (!types)\n\t\ttypes = ['nobundles', 'nopackages', 'nocomponents', 'nothemes'];\n\n\tif (pwd && pwd[0] === '.' && pwd.length < 4)\n\t\tF.directory = directory = U.$normalize(Path.normalize(directory + '/..'));\n\telse if (pwd)\n\t\tF.directory = directory = U.$normalize(pwd);\n\telse if (process.env.istotaljsworker)\n\t\tF.directory = process.cwd();\n\telse if ((/\\/scripts\\/.*?.js/).test(process.argv[1]))\n\t\tF.directory = directory = U.$normalize(Path.normalize(directory + '/..'));\n\n\tif (typeof(debug) === 'string') {\n\t\tswitch (debug.toLowerCase().replace(/\\.|\\s/g, '-')) {\n\t\t\tcase 'release':\n\t\t\tcase 'production':\n\t\t\t\tdebug = false;\n\t\t\t\tbreak;\n\n\t\t\tcase 'debug':\n\t\t\tcase 'develop':\n\t\t\tcase 'development':\n\t\t\t\tdebug = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'test-debug':\n\t\t\tcase 'debug-test':\n\t\t\tcase 'testing-debug':\n\t\t\t\tdebug = true;\n\t\t\t\tF.isTest = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'test':\n\t\t\tcase 'testing':\n\t\t\tcase 'test-release':\n\t\t\tcase 'release-test':\n\t\t\tcase 'testing-release':\n\t\t\tcase 'test-production':\n\t\t\tcase 'testing-production':\n\t\t\t\tdebug = false;\n\t\t\t\tF.isTest = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tF.isWorker = true;\n\tF.isDebug = debug;\n\n\tglobal.isWORKER = true;\n\tglobal.DEBUG = debug;\n\tglobal.RELEASE = !debug;\n\tglobal.I = global.isomorphic = F.isomorphic;\n\n\tvar isNo = true;\n\n\tif (types) {\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tif (types[i].substring(0, 2) !== 'no') {\n\t\t\t\tisNo = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar can = function(type) {\n\t\tif (!types)\n\t\t\treturn true;\n\t\tif (types.indexOf('no' + type) !== -1)\n\t\t\treturn false;\n\t\treturn isNo ? true : types.indexOf(type) !== -1;\n\t};\n\n\tF.$bundle(function() {\n\t\tF.consoledebug('startup');\n\t\tF.$startup(function() {\n\n\t\t\tF.consoledebug('startup (done)');\n\t\t\tF.$configure_env();\n\t\t\tF.$configure_configs();\n\n\t\t\tif (can('versions'))\n\t\t\t\tF.$configure_versions();\n\n\t\t\tif (can('workflows'))\n\t\t\t\tF.$configure_workflows();\n\n\t\t\tif (can('sitemap'))\n\t\t\t\tF.$configure_sitemap();\n\n\t\t\tF.consoledebug('init');\n\n\t\t\tvar noservice = true;\n\n\t\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\t\tswitch(types[i]) {\n\t\t\t\t\tcase 'service':\n\t\t\t\t\tcase 'services':\n\t\t\t\t\t\tnoservice = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!noservice)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tF.cache.init(noservice);\n\t\t\tEMIT('init');\n\n\t\t\tF.$load(types, directory, function() {\n\n\t\t\t\tF.isLoaded = true;\n\n\t\t\t\tprocess.send && process.send('total:ready');\n\n\t\t\t\tsetTimeout(function() {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tEMIT('load');\n\t\t\t\t\t\tEMIT('ready');\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tF.error(err, 'ON(\"load/ready\")');\n\t\t\t\t\t}\n\n\t\t\t\t\tready && ready();\n\n\t\t\t\t\tF.removeAllListeners('load');\n\t\t\t\t\tF.removeAllListeners('ready');\n\n\t\t\t\t\tif (F.isTest) {\n\t\t\t\t\t\tF.console();\n\t\t\t\t\t\tF.test();\n\t\t\t\t\t\treturn F;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Because this is worker\n\t\t\t\t\t// setTimeout(function() {\n\t\t\t\t\t// \tif (!F.isTest)\n\t\t\t\t\t// \t\tdelete F.test;\n\t\t\t\t\t// }, 5000);\n\n\t\t\t\t}, 500);\n\n\t\t\t\tif (CONF.allow_debug) {\n\t\t\t\t\tF.consoledebug('done');\n\t\t\t\t\tF.usagesnapshot();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}, can('bundles'));\n\n\treturn F;\n};\n\n/**\n * Initialize framework\n * @param  {Object} http\n * @param  {Boolean} debug\n * @param  {Object} options\n * @return {Framework}\n */\nF.initialize = function(http, debug, options) {\n\n\tif (!options)\n\t\toptions = {};\n\n\tvar port = options.port;\n\tvar ip = options.ip;\n\tvar listenpath = options.listenpath;\n\n\tif (options.thread)\n\t\tglobal.THREAD = options.thread;\n\n\toptions.config && U.extend_headers2(CONF, options.config);\n\n\tif (options.debug || options['allow-debug'] || options.allow_debug)\n\t\tCONF.allow_debug = true;\n\n\tF.isHTTPS = http.STATUS_CODES === undefined;\n\n\tif (isNaN(port) && typeof(port) !== 'string')\n\t\tport = null;\n\n\tif (options.id)\n\t\tF.id = options.id;\n\n\tF.isDebug = debug;\n\n\tif (options.bundling != null)\n\t\tF.$bundling = options.bundling == true;\n\n\tglobal.DEBUG = debug;\n\tglobal.RELEASE = !debug;\n\tglobal.I = global.isomorphic = F.isomorphic;\n\n\tif (options.tests) {\n\t\tF.testlist = options.tests;\n\t\tfor (var i = 0; i < F.testlist.length; i++)\n\t\t\tF.testlist[i] = F.testlist[i].replace(/\\.js$/, '');\n\t}\n\n\tF.$bundle(function() {\n\n\t\tF.$configure_env();\n\t\tF.$configure_configs();\n\t\tF.$configure_versions();\n\t\tF.$configure_workflows();\n\t\tF.$configure_sitemap();\n\t\tF.isTest && F.$configure_configs('config-test', true);\n\t\tF.cache.init();\n\t\tF.consoledebug('init');\n\t\tEMIT('init');\n\n\t\tif (!port) {\n\t\t\tif (CONF.default_port === 'auto') {\n\t\t\t\tvar envPort = +(process.env.PORT || '');\n\t\t\t\tif (!isNaN(envPort))\n\t\t\t\t\tport = envPort;\n\t\t\t} else\n\t\t\t\tport = CONF.default_port;\n\t\t}\n\n\t\tF.port = port || 8000;\n\n\t\tif (ip !== null) {\n\t\t\tF.ip = ip || CONF.default_ip || '0.0.0.0';\n\t\t\tif (F.ip === 'null' || F.ip === 'undefined' || F.ip === 'auto')\n\t\t\t\tF.ip = null;\n\t\t} else\n\t\t\tF.ip = undefined;\n\n\t\tif (F.ip == null)\n\t\t\tF.ip = '0.0.0.0';\n\n\t\t!listenpath && (listenpath = CONF.default_listenpath);\n\t\tF.listenpath = listenpath;\n\n\t\tif (F.server) {\n\t\t\tF.server.removeAllListeners();\n\t\t\tObject.keys(F.connections).forEach(function(key) {\n\t\t\t\tvar item = F.connections[key];\n\t\t\t\tif (item) {\n\t\t\t\t\titem.removeAllListeners();\n\t\t\t\t\titem.close();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tF.server.close();\n\t\t}\n\n\t\tvar listen = function() {\n\n\t\t\tif (options.https) {\n\n\t\t\t\tvar meta = options.https;\n\n\t\t\t\tif (typeof(meta.key) === 'string') {\n\t\t\t\t\tif (meta.key.indexOf('.') === -1)\n\t\t\t\t\t\tmeta.key = Buffer.from(meta.key, 'base64');\n\t\t\t\t\telse\n\t\t\t\t\t\tmeta.key = Fs.readFileSync(meta.key);\n\t\t\t\t}\n\n\t\t\t\tif (typeof(meta.cert) === 'string') {\n\t\t\t\t\tif (meta.cert.indexOf('.') === -1)\n\t\t\t\t\t\tmeta.cert = Buffer.from(meta.cert, 'base64');\n\t\t\t\t\telse\n\t\t\t\t\t\tmeta.cert = Fs.readFileSync(meta.cert);\n\t\t\t\t}\n\n\t\t\t\tF.server = http.createServer(meta, F.listener);\n\n\t\t\t} else\n\t\t\t\tF.server = http.createServer(F.listener);\n\n\t\t\tCONF.allow_performance && F.server.on('connection', connection_tunning);\n\t\t\tF.initwebsocket && F.initwebsocket();\n\t\t\tF.consoledebug('HTTP listening');\n\n\t\t\tif (listenpath)\n\t\t\t\tF.server.listen(listenpath);\n\t\t\telse\n\t\t\t\tF.server.listen(F.port, F.ip);\n\t\t};\n\n\t\t// clears static files\n\t\tF.consoledebug('clear temporary');\n\t\tF.clear(function() {\n\n\t\t\tF.consoledebug('clear temporary (done)');\n\t\t\tF.$load(undefined, directory, function() {\n\n\t\t\t\tF.isLoaded = true;\n\t\t\t\tprocess.send && process.send('total:ready');\n\n\t\t\t\tif (options.middleware)\n\t\t\t\t\toptions.middleware(listen);\n\t\t\t\telse\n\t\t\t\t\tlisten();\n\n\t\t\t\tif (CONF.allow_debug) {\n\t\t\t\t\tF.consoledebug('done');\n\t\t\t\t\tF.usagesnapshot();\n\t\t\t\t}\n\n\t\t\t\tif (!process.connected)\n\t\t\t\t\tF.console();\n\n\t\t\t\tsetTimeout(function() {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tEMIT('load');\n\t\t\t\t\t\tEMIT('ready');\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tF.error(err, 'ON(\"load/ready\")');\n\t\t\t\t\t}\n\n\t\t\t\t\tF.removeAllListeners('load');\n\t\t\t\t\tF.removeAllListeners('ready');\n\t\t\t\t\toptions.package && INSTALL('package', options.package);\n\t\t\t\t\trunsnapshot();\n\t\t\t\t}, 500);\n\n\t\t\t\tif (F.isTest) {\n\t\t\t\t\tvar sleep = options.sleep || options.delay || 1000;\n\t\t\t\t\tsetTimeout(F.test, sleep);\n\t\t\t\t\treturn F;\n\t\t\t\t}\n\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tif (!F.isTest)\n\t\t\t\t\t\tdelete F.test;\n\t\t\t\t}, 5000);\n\t\t\t});\n\t\t}, true);\n\t});\n\n\treturn F;\n};\n\nfunction connection_tunning(socket) {\n\tsocket.setNoDelay(true);\n\tsocket.setKeepAlive(true, 10);\n}\n\n/**\n * Run framework â> HTTP\n * @param  {String} mode Framework mode.\n * @param  {Object} options Framework settings.\n * @param {Function(listen)} middleware A middleware for manual calling of HTTP listener\n * @return {Framework}\n */\nF.http = function(mode, options, middleware) {\n\tF.consoledebug('begin');\n\n\tif (typeof(options) === 'function') {\n\t\tmiddleware = options;\n\t\toptions = null;\n\t}\n\n\toptions == null && (options = {});\n\t!options.port && (options.port = +process.argv[2]);\n\n\tif (options.port && isNaN(options.port))\n\t\toptions.port = 0;\n\n\tif (typeof(middleware) === 'function')\n\t\toptions.middleware = middleware;\n\n\tif (options.bundling != null)\n\t\tF.$bundling = options.bundling;\n\n\tvar http = require('http');\n\textend_request(http.IncomingMessage.prototype);\n\textend_response(http.ServerResponse.prototype);\n\treturn F.mode(http, mode, options);\n};\n\n/**\n * Run framework â> HTTPS\n * @param {String} mode Framework mode.\n * @param {Object} options Framework settings.\n * @param {Function(listen)} middleware A middleware for manual calling of HTTP listener\n * @return {Framework}\n */\nF.https = function(mode, options, middleware) {\n\tF.consoledebug('begin');\n\tvar http = require('http');\n\n\tif (typeof(options) === 'function') {\n\t\tmiddleware = options;\n\t\toptions = null;\n\t}\n\n\toptions == null && (options = {});\n\t!options.port && (options.port = +process.argv[2]);\n\n\tif (options.port && isNaN(options.port))\n\t\toptions.port = 0;\n\n\tif (typeof(middleware) === 'function')\n\t\toptions.middleware = middleware;\n\n\textend_request(http.IncomingMessage.prototype);\n\textend_response(http.ServerResponse.prototype);\n\treturn F.mode(require('https'), mode, options);\n};\n\nF.mode = function(http, name, options) {\n\n\tvar debug = false;\n\n\tif (options.directory)\n\t\tF.directory = directory = options.directory;\n\n\tif (typeof(http) === 'string') {\n\t\tswitch (http) {\n\t\t\tcase 'debug':\n\t\t\tcase 'development':\n\t\t\t\tdebug = true;\n\t\t\t\tbreak;\n\t\t}\n\t\tDEBUG = debug;\n\t\tCONF.trace = debug;\n\t\tF.isDebug = debug;\n\t\tglobal.DEBUG = debug;\n\t\tglobal.RELEASE = !debug;\n\t\treturn F;\n\t}\n\n\tF.isWorker = false;\n\n\tswitch (name.toLowerCase().replace(/\\.|\\s/g, '-')) {\n\t\tcase 'release':\n\t\tcase 'production':\n\t\t\tbreak;\n\n\t\tcase 'debug':\n\t\tcase 'develop':\n\t\tcase 'development':\n\t\t\tdebug = true;\n\t\t\tbreak;\n\n\t\tcase 'test-debug':\n\t\tcase 'debug-test':\n\t\tcase 'testing-debug':\n\t\t\tdebug = true;\n\t\t\tF.isTest = true;\n\t\t\tbreak;\n\n\t\tcase 'test':\n\t\tcase 'testing':\n\t\tcase 'test-release':\n\t\tcase 'release-test':\n\t\tcase 'testing-release':\n\t\tcase 'test-production':\n\t\tcase 'testing-production':\n\t\t\tdebug = false;\n\t\t\tF.isTest = true;\n\t\t\tbreak;\n\t}\n\n\tCONF.trace = debug;\n\tF.consoledebug('startup');\n\tF.$startup(function() {\n\t\tF.consoledebug('startup (done)');\n\t\tF.initialize(http, debug, options);\n\t});\n\treturn F;\n};\n\nF.custom = function(mode, http, request, response, options) {\n\tvar debug = false;\n\n\tif (options.directory)\n\t\tF.directory = directory = options.directory;\n\n\tF.consoledebug('begin');\n\n\textend_request(request);\n\textend_response(response);\n\n\tswitch (mode.toLowerCase().replace(/\\.|\\s/g, '-')) {\n\t\tcase 'release':\n\t\tcase 'production':\n\t\t\tbreak;\n\n\t\tcase 'debug':\n\t\tcase 'develop':\n\t\tcase 'development':\n\t\t\tdebug = true;\n\t\t\tbreak;\n\n\t\tcase 'test':\n\t\tcase 'testing':\n\t\tcase 'test-debug':\n\t\tcase 'debug-test':\n\t\tcase 'testing-debug':\n\t\t\tdebug = true;\n\t\t\tF.isTest = true;\n\t\t\tbreak;\n\n\t\tcase 'test-release':\n\t\tcase 'release-test':\n\t\tcase 'testing-release':\n\t\tcase 'test-production':\n\t\tcase 'testing-production':\n\t\t\tdebug = false;\n\t\t\tbreak;\n\t}\n\n\tCONF.trace = debug;\n\tF.consoledebug('startup');\n\tF.$startup(function() {\n\t\tF.consoledebug('startup (done)');\n\t\tF.initialize(http, debug, options);\n\t});\n\n\treturn F;\n};\n\nF.console = function() {\n\tvar memory = process.memoryUsage();\n\tconsole.log('====================================================');\n\tconsole.log('PID           : ' + process.pid);\n\tconsole.log('Node.js       : ' + process.version);\n\tconsole.log('Total.js      : v' + F.version_header);\n\tconsole.log('OS            : ' + Os.platform() + ' ' + Os.release());\n\n\t// Removed worker in v4\n\tCONF.nosql_worker && global.framework_nosql && console.log('NoSQL PID     : ' + global.framework_nosql.pid());\n\n\tconsole.log('Memory        : ' + memory.heapUsed.filesize(2) + ' / ' + memory.heapTotal.filesize(2));\n\tconsole.log('User          : ' + Os.userInfo().username);\n\tconsole.log('====================================================');\n\tconsole.log('Name          : ' + CONF.name);\n\tconsole.log('Version       : ' + CONF.version);\n\tCONF.author && console.log('Author        : ' + CONF.author);\n\tconsole.log('Date          : ' + NOW.format('yyyy-MM-dd HH:mm:ss'));\n\tconsole.log('Mode          : ' + (DEBUG ? 'debug' : 'release'));\n\tglobal.THREAD && console.log('Thread        : ' + global.THREAD);\n\tconsole.log('====================================================');\n\tCONF.default_root && console.log('Root          : ' + F.config.default_root);\n\tconsole.log('Directory     : ' + process.cwd());\n\tconsole.log('node_modules  : ' + PATHMODULES);\n\tconsole.log('====================================================\\n');\n\n\tif (!F.isWorker) {\n\n\t\tvar hostname = '{2}://{0}:{1}/'.format(F.ip, F.port, F.isHTTPS ? 'https' : 'http');\n\n\t\tif (F.ip === '0.0.0.0') {\n\t\t\tvar ni = Os.networkInterfaces();\n\t\t\tif (ni.en0) {\n\t\t\t\tfor (var i = 0; i < ni.en0.length; i++) {\n\t\t\t\t\tvar nii = ni.en0[i];\n\t\t\t\t\t// nii.family === 'IPv6' ||\n\t\t\t\t\tif (nii.family === 'IPv4') {\n\t\t\t\t\t\thostname += '\\n{2}://{0}:{1}/'.format(nii.address, F.port, F.isHTTPS ? 'https' : 'http');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(hostname);\n\t\tconsole.log('');\n\t}\n};\n\nF.usagesnapshot = function(filename) {\n\tFs.writeFile(filename || F.path.root('usage' + (F.id ? ('-' + F.id) : '') + '.log'), JSON.stringify(F.usage(true), null, '\\t'), NOOP);\n\treturn F;\n};\n\nF.consoledebug = function() {\n\n\tif (!CONF.allow_debug)\n\t\treturn F;\n\n\tvar arr = [new Date().format('yyyy-MM-dd HH:mm:ss'), '--------->'];\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tarr.push(arguments[i]);\n\tconsole.log.apply(console, arr);\n\treturn F;\n};\n\n/**\n * Re-connect server\n * @return {Framework}\n */\nF.reconnect = function() {\n\tif (CONF.default_port !== undefined)\n\t\tF.port = CONF.default_port;\n\tif (CONF.default_ip !== undefined)\n\t\tF.ip = CONF.default_ip;\n\tF.server.close(() => F.server.listen(F.port, F.ip));\n\treturn F;\n};\n\n/**\n * Internal service\n * @private\n * @param {Number} count Run count.\n * @return {Framework}\n */\nF.service = function(count) {\n\n\tUIDGENERATOR_REFRESH();\n\n\tvar keys;\n\tvar releasegc = false;\n\n\tF.temporary.service.request = F.stats.performance.request;\n\tF.temporary.service.file = F.stats.performance.file;\n\tF.temporary.service.message = F.stats.performance.message;\n\tF.temporary.service.mail = F.stats.performance.mail;\n\tF.temporary.service.open = F.stats.performance.open;\n\tF.temporary.service.dbrm = F.stats.performance.dbrm;\n\tF.temporary.service.dbwm = F.stats.performance.dbwm;\n\tF.temporary.service.external = F.stats.performance.external;\n\n\tF.stats.performance.external = 0;\n\tF.stats.performance.dbrm = 0;\n\tF.stats.performance.dbwm = 0;\n\tF.stats.performance.request = 0;\n\tF.stats.performance.file = 0;\n\tF.stats.performance.message = 0;\n\tF.stats.performance.mail = 0;\n\tF.stats.performance.open = 0;\n\n\t// clears short cahce temporary cache\n\tF.temporary.shortcache = {};\n\n\t// clears temporary memory for non-exist files\n\tF.temporary.notfound = {};\n\n\tif (CONF.allow_reqlimit)\n\t\tF.temporary.ddos = {};\n\n\t// every 10 minutes (default) service clears static cache\n\tif (count % CONF.default_interval_clear_cache === 0) {\n\t\tF.$events.clear && EMIT('clear', 'temporary', F.temporary);\n\t\tF.temporary.path = {};\n\t\tF.temporary.range = {};\n\t\tF.temporary.views = {};\n\t\tF.temporary.other = {};\n\n\t\tglobal.TEMP = {};\n\t\tglobal.$VIEWCACHE && global.$VIEWCACHE.length && (global.$VIEWCACHE = []);\n\n\t\t// Clears command cache\n\t\tImage.clear();\n\n\t\tvar dt = NOW.add('-5 minutes');\n\t\tfor (var key in F.databases)\n\t\t\tF.databases[key] && F.databases[key].inmemorylastusage < dt && F.databases[key].release();\n\n\t\treleasegc = true;\n\t\tCONF.allow_debug && F.consoledebug('clear temporary cache');\n\n\t\tkeys = Object.keys(F.temporary.internal);\n\t\tfor (var i = 0; i < keys.length; i++)\n\t\t\tif (!F.temporary.internal[keys[i]])\n\t\t\t\tdelete F.temporary.internal[keys[i]];\n\n\t\t// Clears released sessions\n\t\tkeys = Object.keys(F.sessions);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (F.sessions[key]) {\n\t\t\t\tF.sessions[key].clean();\n\t\t\t\tCONF.allow_sessions_unused && F.sessions[key].releaseunused(CONF.allow_sessions_unused);\n\t\t\t}\n\t\t}\n\t}\n\n\t// every 61 minutes (default) services precompile all (installed) views\n\tif (count % CONF.default_interval_precompile_views === 0) {\n\t\tfor (var key in F.routes.views) {\n\t\t\tvar item = F.routes.views[key];\n\t\t\tF.install('view', key, item.url, null);\n\t\t}\n\t}\n\n\tif (count % CONF.default_interval_clear_dnscache === 0) {\n\t\tF.$events.clear && EMIT('clear', 'dns');\n\t\tCMD('clear_dnscache');\n\t\tCONF.allow_debug && F.consoledebug('clear DNS cache');\n\t}\n\n\tvar ping = CONF.default_interval_websocket_ping;\n\tif (ping > 0 && count % ping === 0) {\n\t\tvar has = false;\n\t\tfor (var item in F.connections) {\n\t\t\tvar conn = F.connections[item];\n\t\t\tif (conn) {\n\t\t\t\tconn.check();\n\t\t\t\tconn.ping();\n\t\t\t\thas = true;\n\t\t\t}\n\t\t}\n\t\thas && CONF.allow_debug && F.consoledebug('ping websocket connections');\n\t}\n\n\t// OBSOLETE, it will be deleted in v4\n\tif (F.uptodates && (count % CONF.default_interval_uptodate === 0) && F.uptodates.length) {\n\t\tvar hasUpdate = false;\n\t\tF.uptodates.wait(function(item, next) {\n\n\t\t\tif (item.updated.add(item.interval) > NOW)\n\t\t\t\treturn next();\n\n\t\t\titem.updated = NOW;\n\t\t\titem.count++;\n\n\t\t\tsetTimeout(function() {\n\t\t\t\tCONF.allow_debug && F.consoledebug('uptodate', item.type + '#' + item.url);\n\t\t\t\tF.install(item.type, item.url, item.options, function(err, name, skip) {\n\n\t\t\t\t\tCONF.allow_debug && F.consoledebug('uptodate', item.type + '#' + item.url + ' (done)');\n\n\t\t\t\t\tif (skip)\n\t\t\t\t\t\treturn next();\n\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\titem.errors.push(err);\n\t\t\t\t\t\titem.errors.length > 50 && F.errors.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\thasUpdate = true;\n\t\t\t\t\t\titem.name = name;\n\t\t\t\t\t\tF.$events.uptodate && EMIT('uptodate', item.type, name);\n\t\t\t\t\t}\n\n\t\t\t\t\titem.callback && item.callback(err, name);\n\t\t\t\t\tnext();\n\n\t\t\t\t}, undefined, undefined, undefined, undefined, item.name);\n\n\t\t\t}, item.name ? 500 : 1);\n\n\t\t}, function() {\n\t\t\tif (hasUpdate) {\n\t\t\t\tF.temporary.path = {};\n\t\t\t\tF.temporary.range = {};\n\t\t\t\tF.temporary.views = {};\n\t\t\t\tF.temporary.other = {};\n\t\t\t\tglobal.$VIEWCACHE && global.$VIEWCACHE.length && (global.$VIEWCACHE = []);\n\t\t\t}\n\t\t});\n\t}\n\n\t// every 20 minutes (default) service clears resources\n\tif (count % CONF.default_interval_clear_resources === 0) {\n\t\tF.$events.clear && EMIT('clear', 'resources');\n\t\tF.resources = {};\n\t\treleasegc = true;\n\t\tCONF.allow_debug && F.consoledebug('clear resources');\n\t}\n\n\t// Session DDOS cleaner\n\tif (F.sessionscount && count % 15 === 0) {\n\t\tkeys = Object.keys(F.sessions);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar session = F.sessions[keys[i]];\n\t\t\tif (session.ddosis) {\n\t\t\t\tsession.ddos = {};\n\t\t\t\tsession.ddosis = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update expires date\n\tcount % 1000 === 0 && (DATE_EXPIRES = NOW.add('y', 1).toUTCString());\n\n\tif (count % CONF.nosql_cleaner === 0 && CONF.nosql_cleaner) {\n\t\tkeys = Object.keys(F.databasescleaner);\n\t\tkeys.wait(function(item, next) {\n\t\t\tif (item[0] === '$')\n\t\t\t\tTABLE(item.substring(1)).clean(next);\n\t\t\telse\n\t\t\t\tNOSQL(item).clean(next);\n\t\t});\n\t}\n\n\tF.$events.service && EMIT('service', count);\n\n\tif (CONF.allow_debug) {\n\t\tF.consoledebug('service ({0}x)'.format(count));\n\t\tF.usagesnapshot();\n\t}\n\n\treleasegc && global.gc && setTimeout(function() {\n\t\tglobal.gc();\n\t\tCONF.allow_debug && F.consoledebug('gc()');\n\t}, 1000);\n\n\tif (WORKERID > 9999999999)\n\t\tWORKERID = 0;\n\n\t// Run schedules\n\tkeys = Object.keys(F.schedules);\n\n\tif (!keys.length)\n\t\treturn F;\n\n\tvar expire = NOW.getTime();\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar schedule = F.schedules[key];\n\t\tif (schedule.expire <= expire) {\n\t\t\tif (schedule.repeat)\n\t\t\t\tschedule.expire = NOW.add(schedule.repeat);\n\t\t\telse\n\t\t\t\tdelete F.schedules[key];\n\t\t\tCONF.allow_debug && F.consoledebug('schedule', key);\n\t\t\tschedule.fn.call(F);\n\t\t}\n\t}\n\n\treturn F;\n};\n\n/**\n * Request processing\n * @private\n * @param {Request} req\n * @param {Response} res\n */\nF.listener = function(req, res) {\n\n\treq.options = res.options = {};\n\tres.req = req;\n\treq.res = res;\n\n\tif (F._length_wait)\n\t\treturn F.response503(req, res);\n\telse if (!req.host) // HTTP 1.0 without host\n\t\treturn res.throw400();\n\n\tif (CONF.allow_reqlimit) {\n\t\tvar ip = req.ip;\n\t\tif (F.temporary.ddos[ip] > CONF.allow_reqlimit) {\n\t\t\tF.stats.response.ddos++;\n\t\t\tres.options.code = 503;\n\t\t\tres.options.headers = HEADERS.response503ddos;\n\t\t\tres.options.body = '503 Service Unavailable';\n\t\t\tres.$text();\n\t\t\treturn;\n\t\t}\n\t\tif (F.temporary.ddos[ip])\n\t\t\tF.temporary.ddos[ip]++;\n\t\telse\n\t\t\tF.temporary.ddos[ip] = 1;\n\t}\n\n\tif (F._request_check_proxy) {\n\t\tfor (var i = 0; i < F.routes.proxies.length; i++) {\n\t\t\tvar proxy = F.routes.proxies[i];\n\t\t\tif (req.url.substring(0, proxy.url.length) === proxy.url) {\n\t\t\t\tF.stats.response.proxy++;\n\t\t\t\tmakeproxy(proxy, req, res);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar headers = req.headers;\n\treq.$protocol = ((req.connection && req.connection.encrypted) || ((headers['x-forwarded-proto'] || ['x-forwarded-protocol']) === 'https')) ? 'https' : 'http';\n\treq.uri = framework_internal.parseURI(req);\n\n\tF.stats.request.request++;\n\tF.$events.request && EMIT('request', req, res);\n\n\tif (F._request_check_redirect) {\n\t\tvar redirect = F.routes.redirects[req.$protocol + '://' + req.host];\n\t\tif (redirect) {\n\t\t\tF.stats.response.forward++;\n\t\t\tres.options.url = redirect.url + (redirect.path ? req.url : '');\n\t\t\tres.options.permanent = redirect.permanent;\n\t\t\tres.$redirect();\n\t\t\treturn;\n\t\t}\n\t}\n\n\treq.path = framework_internal.routeSplit(req.uri.pathname);\n\n\treq.processing = 0;\n\treq.isAuthorized = true;\n\treq.xhr = headers['x-requested-with'] === 'XMLHttpRequest';\n\tres.success = false;\n\treq.user = req.session = null;\n\treq.isStaticFile = CONF.allow_static_files && U.isStaticFile(req.uri.pathname);\n\n\tif (req.isStaticFile)\n\t\treq.extension = U.getExtension(req.uri.pathname);\n\telse if (F.onLocale)\n\t\treq.$language = F.onLocale(req, res, req.isStaticFile);\n\n\treq.on('aborted', onrequesterror);\n\tF.reqstats(true, true);\n\n\tif (F._length_request_middleware)\n\t\tasync_middleware(0, req, res, F.routes.request, requestcontinue_middleware);\n\telse\n\t\tF.$requestcontinue(req, res, headers);\n};\n\nfunction onrequesterror() {\n\tF.reqstats(false);\n\tthis.success = true;\n\tif (this.res)\n\t\tthis.res.$aborted = true;\n}\n\nfunction requestcontinue_middleware(req, res)  {\n\tif (req.$total_middleware)\n\t\treq.$total_middleware = null;\n\tF.$requestcontinue(req, res, req.headers);\n}\n\nfunction makeproxy(proxy, req, res) {\n\n\tvar secured = proxy.uri.protocol === 'https:';\n\tvar uri = proxy.uri;\n\turi.headers = req.headers;\n\turi.method = req.method;\n\n\tif (proxy.copypath)\n\t\turi.path = req.url;\n\n\tif (!secured)\n\t\turi.agent = PROXYKEEPALIVE;\n\n\tproxy.before && proxy.before(uri, req, res);\n\turi.headers.host = uri.host;\n\n\tvar request;\n\tif (secured) {\n\t\tvar https = require('https');\n\t\tif (uri.method === 'GET')\n\t\t\trequest = https.get(uri, makeproxycallback);\n\t\telse\n\t\t\trequest = https.request(uri, makeproxycallback);\n\t} else {\n\t\tif (uri.method === 'GET')\n\t\t\trequest = http.get(uri, makeproxycallback);\n\t\telse\n\t\t\trequest = http.request(uri, makeproxycallback);\n\t}\n\n\tF.stats.performance.external++;\n\n\trequest.on('error', makeproxyerror);\n\trequest.$res = res;\n\trequest.$proxy = proxy;\n\treq.pipe(request, PROXYOPTIONS);\n}\n\nfunction makeproxyerror(err) {\n\tMODELERROR.code = 503;\n\tMODELERROR.status = U.httpStatus(503, false);\n\tMODELERROR.error = err.toString();\n\tthis.$res.writeHead(503, HEADERS.response503);\n\tthis.$res.end(VIEW('.' + PATHMODULES + 'error', MODELERROR));\n}\n\nfunction makeproxycallback(response) {\n\tthis.$proxy.after && this.proxy.after(response);\n\tthis.$res.writeHead(response.statusCode, response.headers);\n\tresponse.pipe(this.$res, PROXYOPTIONS);\n}\n\n\nconst TRAVELCHARS = { e: 1, E: 1 };\n\n/**\n * Continue to process\n * @private\n * @param {Request} req\n * @param {Response} res\n * @param {Object} headers\n * @param {String} protocol [description]\n * @return {Framework}\n */\nF.$requestcontinue = function(req, res, headers) {\n\n\tif (!req || !res || res.headersSent || res.success)\n\t\treturn;\n\n\tvar tmp;\n\n\t// Validates if this request is the file (static file)\n\tif (req.isStaticFile) {\n\n\t\tF.stats.performance.file++;\n\t\ttmp = F.temporary.shortcache[req.uri.pathname];\n\n\t\tif (!tmp) {\n\t\t\t// Stops path travelsation outside of \"public\" directory\n\t\t\t// A potential security issue\n\t\t\tfor (var i = 0; i < req.uri.pathname.length - 1; i++) {\n\t\t\t\tvar c = req.uri.pathname[i];\n\t\t\t\tvar n = req.uri.pathname[i + 1];\n\t\t\t\tif ((c === '.' && (n === '/' || n === '%')) || (c === '%' && n === '2' && TRAVELCHARS[req.uri.pathname[i + 2]])) {\n\t\t\t\t\tF.temporary.shortcache[req.uri.pathname] = 2;\n\t\t\t\t\treq.$total_status(404);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tF.temporary.shortcache[req.uri.pathname] = 1;\n\t\t} else if (tmp === 2) {\n\t\t\treq.$total_status(404);\n\t\t\treturn;\n\t\t}\n\n\t\tF.stats.request.file++;\n\n\t\tif (F._length_files)\n\t\t\treq.$total_file();\n\t\telse\n\t\t\tres.continue();\n\n\t\treturn;\n\t}\n\n\tF.stats.performance.request++;\n\n\tif (!PERF[req.method]) {\n\t\treq.$total_status(404);\n\t\treturn;\n\t}\n\n\tif (req.uri.search) {\n\t\ttmp = F.temporary.shortcache[req.uri.search];\n\n\t\tif (!tmp) {\n\t\t\ttmp = 1;\n\t\t\tfor (var i = 1; i < req.uri.search.length - 2; i++) {\n\t\t\t\tif (req.uri.search[i] === '%' && req.uri.search[i + 1] === '0' && req.uri.search[i + 2] === '0') {\n\t\t\t\t\ttmp = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tF.temporary.shortcache[req.uri.search] = tmp;\n\t\t}\n\n\t\tif (tmp === 2) {\n\t\t\treq.$total_status(404);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tF.stats.request.web++;\n\treq.body = EMPTYOBJECT;\n\treq.files = EMPTYARRAY;\n\treq.buffer_exceeded = false;\n\treq.buffer_has = false;\n\treq.$flags = req.method[0] + req.method[1];\n\n\tvar flags = [req.method.toLowerCase()];\n\tvar multipart;\n\n\tif (F._request_check_mobile && req.mobile) {\n\t\treq.$flags += 'a';\n\t\tF.stats.request.mobile++;\n\t} else\n\t\tF.stats.request.desktop++;\n\n\treq.$protocol[5] && (req.$flags += req.$protocol[5]);\n\treq.$type = 0;\n\tflags.push(req.$protocol);\n\n\tvar method = req.method;\n\tvar first = method[0];\n\n\tif (first === 'P' || first === 'D') {\n\t\tmultipart = req.headers['content-type'] || '';\n\t\treq.buffer_data = Buffer.alloc(0);\n\t\tvar index = multipart.indexOf(';', 6);\n\t\tvar tmp = multipart;\n\t\tif (index !== -1)\n\t\t\ttmp = tmp.substring(0, index);\n\n\t\tswitch (tmp.substring(tmp.length - 4)) {\n\t\t\tcase 'json':\n\t\t\t\treq.$flags += 'b';\n\t\t\t\tflags.push('json');\n\t\t\t\treq.$type = 1;\n\t\t\t\tmultipart = '';\n\t\t\t\tbreak;\n\t\t\tcase 'oded':\n\t\t\t\treq.$type = 3;\n\t\t\t\tmultipart = '';\n\t\t\t\tbreak;\n\t\t\tcase 'data':\n\t\t\t\treq.$flags += 'c';\n\t\t\t\treq.$upload = true;\n\t\t\t\tflags.push('upload');\n\t\t\t\tbreak;\n\t\t\tcase '/xml':\n\t\t\t\treq.$flags += 'd';\n\t\t\t\tflags.push('xml');\n\t\t\t\treq.$type = 2;\n\t\t\t\tmultipart = '';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (multipart) {\n\t\t\t\t\t// 'undefined' DATA\n\t\t\t\t\tmultipart = '';\n\t\t\t\t\tflags.push('raw');\n\t\t\t\t} else {\n\t\t\t\t\treq.$type = 3;\n\t\t\t\t\tmultipart = '';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (headers.accept === 'text/event-stream') {\n\t\treq.$flags += 'g';\n\t\tflags.push('sse');\n\t}\n\n\tif (DEBUG) {\n\t\treq.$flags += 'h';\n\t\tflags.push('debug');\n\t}\n\n\tif (req.xhr) {\n\t\tF.stats.request.xhr++;\n\t\treq.$flags += 'i';\n\t\tflags.push('xhr');\n\t}\n\n\tif (F._request_check_robot && req.robot)\n\t\treq.$flags += 'j';\n\n\tif (F._request_check_referer) {\n\t\tvar referer = headers['referer'];\n\t\tif (referer && referer.indexOf(headers['host']) !== -1) {\n\t\t\treq.$flags += 'k';\n\t\t\tflags.push('referer');\n\t\t}\n\t}\n\n\treq.flags = flags;\n\n\tF.$events['request-begin'] && EMIT('request-begin', req, res);\n\tF.$events.request_begin && EMIT('request_begin', req, res);\n\n\tvar isCORS = (F._length_cors || F.routes.corsall) && req.headers.origin != null;\n\n\tswitch (first) {\n\t\tcase 'G':\n\t\t\tF.stats.request.get++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback0);\n\t\t\telse\n\t\t\t\treq.$total_end();\n\t\t\treturn;\n\n\t\tcase 'O':\n\t\t\tF.stats.request.options++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback0);\n\t\t\telse\n\t\t\t\treq.$total_end();\n\t\t\treturn;\n\n\t\tcase 'H':\n\t\t\tF.stats.request.head++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback0);\n\t\t\telse\n\t\t\t\treq.$total_end();\n\t\t\treturn;\n\n\t\tcase 'D':\n\t\t\tF.stats.request['delete']++;\n\t\t\tif (isCORS)\n\t\t\t\tF.$cors(req, res, cors_callback1);\n\t\t\telse\n\t\t\t\treq.$total_urlencoded();\n\t\t\treturn;\n\n\t\tcase 'P':\n\t\t\tif (F._request_check_POST) {\n\t\t\t\tif (multipart) {\n\t\t\t\t\tif (isCORS)\n\t\t\t\t\t\tF.$cors(req, res, cors_callback_multipart, multipart);\n\t\t\t\t\telse\n\t\t\t\t\t\treq.$total_multipart(multipart);\n\t\t\t\t} else {\n\t\t\t\t\tif (method === 'PUT')\n\t\t\t\t\t\tF.stats.request.put++;\n\t\t\t\t\telse if (method === 'PATCH')\n\t\t\t\t\t\tF.stats.request.patch++;\n\t\t\t\t\telse\n\t\t\t\t\t\tF.stats.request.post++;\n\t\t\t\t\tif (isCORS)\n\t\t\t\t\t\tF.$cors(req, res, cors_callback1);\n\t\t\t\t\telse\n\t\t\t\t\t\treq.$total_urlencoded();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treq.$total_status(404);\n};\n\nfunction cors_callback0(req) {\n\treq.$total_end();\n}\n\nfunction cors_callback1(req) {\n\treq.$total_urlencoded();\n}\n\nfunction cors_callback_multipart(req, res, multipart) {\n\treq.$total_multipart(multipart);\n}\n\nF.$cors = function(req, res, fn, arg) {\n\n\tvar isAllowed = F.routes.corsall;\n\tvar cors, origin;\n\tvar headers = req.headers;\n\tvar key;\n\n\tif (!isAllowed) {\n\n\t\tfor (var i = 0; i < F._length_cors; i++) {\n\t\t\tcors = F.routes.cors[i];\n\t\t\tif (framework_internal.routeCompare(req.path, cors.url, false, cors.isWILDCARD)) {\n\t\t\t\tisAllowed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!isAllowed)\n\t\t\treturn fn(req, res, arg);\n\n\t\tvar stop = false;\n\n\t\tkey = 'cors' + cors.hash + '_' + headers.origin;\n\n\t\tif (F.temporary.other[key]) {\n\t\t\tstop = F.temporary.other[key] === 2;\n\t\t} else {\n\n\t\t\tisAllowed = false;\n\n\t\t\tif (cors.headers) {\n\t\t\t\tisAllowed = false;\n\t\t\t\tfor (var i = 0, length = cors.headers.length; i < length; i++) {\n\t\t\t\t\tif (headers[cors.headers[i]]) {\n\t\t\t\t\t\tisAllowed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isAllowed)\n\t\t\t\t\tstop = true;\n\t\t\t}\n\n\t\t\tif (!stop && cors.methods) {\n\t\t\t\tisAllowed = false;\n\t\t\t\tvar current = headers['access-control-request-method'] || req.method;\n\t\t\t\tif (current !== 'OPTIONS') {\n\t\t\t\t\tfor (var i = 0, length = cors.methods.length; i < length; i++) {\n\t\t\t\t\t\tif (current === cors.methods[i]) {\n\t\t\t\t\t\t\tisAllowed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!isAllowed)\n\t\t\t\t\t\tstop = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!stop && cors.origin) {\n\t\t\t\torigin = headers.origin.toLowerCase().substring(headers.origin.indexOf('/') + 2);\n\t\t\t\tif (origin !== headers.host) {\n\t\t\t\t\tisAllowed = false;\n\t\t\t\t\tfor (var i = 0, length = cors.origin.length; i < length; i++) {\n\t\t\t\t\t\tif (cors.origin[i].indexOf(origin) !== -1) {\n\t\t\t\t\t\t\tisAllowed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!isAllowed)\n\t\t\t\t\t\tstop = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tF.temporary.other[key] = stop ? 2 : 1;\n\t\t}\n\t} else if (CONF.default_cors) {\n\t\tkey = headers.origin;\n\t\tif (F.temporary.other[key]) {\n\t\t\tstop = F.temporary.other[key] === 2;\n\t\t} else {\n\t\t\torigin = key.toLowerCase().substring(key.indexOf('/') + 2);\n\t\t\tstop = origin !== headers.host && CONF.default_cors.indexOf(origin) === -1;\n\t\t\tF.temporary.other[key] = stop ? 2 : 1;\n\t\t}\n\t}\n\n\tif (stop)\n\t\torigin = 'null';\n\telse\n\t\torigin = headers.origin;\n\n\tres.setHeader('Access-Control-Allow-Origin', origin);\n\n\tif (!cors || cors.credentials)\n\t\tres.setHeader('Access-Control-Allow-Credentials', 'true');\n\n\tvar name = 'Access-Control-Allow-Methods';\n\tvar isOPTIONS = req.method === 'OPTIONS';\n\n\tif (cors && cors.methods)\n\t\tres.setHeader(name, cors.methods.join(', '));\n\telse\n\t\tres.setHeader(name, isOPTIONS ? headers['access-control-request-method'] || '*' : req.method);\n\n\tname = 'Access-Control-Allow-Headers';\n\n\tif (cors && cors.headers)\n\t\tres.setHeader(name, cors.headers.join(', '));\n\telse\n\t\tres.setHeader(name, headers['access-control-request-headers'] || '*');\n\n\tcors && cors.age && res.setHeader('Access-Control-Max-Age', cors.age);\n\n\tif (stop) {\n\t\tfn = null;\n\t\tF.$events['request-end'] && EMIT('request-end', req, res);\n\t\tF.$events.request_end && EMIT('request_end', req, res);\n\t\tF.reqstats(false, false);\n\t\tF.stats.request.blocked++;\n\t\tres.writeHead(404);\n\t\tres.end();\n\t\treturn;\n\t}\n\n\tif (!isOPTIONS)\n\t\treturn fn(req, res, arg);\n\n\tfn = null;\n\tF.$events['request-end'] && EMIT('request-end', req, res);\n\tF.$events.request_end && EMIT('request_end', req, res);\n\tF.reqstats(false, false);\n\tres.writeHead(200);\n\tres.end();\n\treturn F;\n};\n\n/**\n * Upgrade HTTP (WebSocket)\n * @param {HttpRequest} req\n * @param {Socket} socket\n * @param {Buffer} head\n */\nconst REGWS = /websocket/i;\nF.$upgrade = function(req, socket, head) {\n\n\tif (!REGWS.test(req.headers.upgrade || '') || F._length_wait)\n\t\treturn;\n\n\t// disables timeout\n\tsocket.setTimeout(0);\n\tsocket.on('error', NOOP);\n\n\tvar headers = req.headers;\n\treq.$protocol = req.connection.encrypted || headers['x-forwarded-protocol'] === 'https' ? 'https' : 'http';\n\n\treq.uri = framework_internal.parseURI(req);\n\n\tF.$events.websocket && EMIT('websocket', req, socket, head);\n\tF.stats.request.websocket++;\n\n\treq.session = null;\n\treq.user = null;\n\treq.flags = [req.secured ? 'https' : 'http', 'get'];\n\n\treq.$wspath = U.path(req.uri.pathname);\n\tvar websocket = new WebSocketClient(req, socket, head);\n\n\treq.path = framework_internal.routeSplit(req.uri.pathname);\n\treq.websocket = websocket;\n\n\tif (F.onLocale)\n\t\treq.$language = F.onLocale(req, socket);\n\n\tif (F._length_request_middleware)\n\t\tasync_middleware(0, req, req.websocket, F.routes.request, websocketcontinue_middleware);\n\telse\n\t\tF.$websocketcontinue(req, req.$wspath, headers);\n};\n\nfunction websocketcontinue_middleware(req) {\n\tif (req.$total_middleware)\n\t\treq.$total_middleware = null;\n\tF.$websocketcontinue(req, req.$wspath, req.headers);\n}\n\nfunction websocketcontinue_authnew(isAuthorized, user, $) {\n\n\t// @isAuthorized \"null\" for callbacks(err, user)\n\t// @isAuthorized \"true\"\n\t// @isAuthorized \"object\" is as user but \"user\" must be \"undefined\"\n\n\tif (isAuthorized instanceof Error || isAuthorized instanceof ErrorBuilder) {\n\t\t// Error handling\n\t\tisAuthorized = false;\n\t} else if (isAuthorized == null && user) {\n\t\t// A callback error handling\n\t\tisAuthorized = true;\n\t} else if (user == null && isAuthorized && isAuthorized !== true) {\n\t\tuser = isAuthorized;\n\t\tisAuthorized = true;\n\t}\n\n\tvar req = $.req;\n\tif (user)\n\t\treq.user = user;\n\tvar route = F.lookup_websocket(req, req.websocket.uri.pathname, isAuthorized ? 1 : 2);\n\tif (route) {\n\t\tF.$websocketcontinue_process(route, req, req.websocketpath);\n\t} else\n\t\treq.websocket.$close(4001, '401: unauthorized');\n}\n\nF.$websocketcontinue = function(req, path) {\n\treq.websocketpath = path;\n\tif (F.onAuthorize) {\n\t\tif (F.onAuthorize.$newversion) {\n\t\t\tF.onAuthorize(req, req.websocket, req.flags, websocketcontinue_authnew);\n\t\t} else {\n\t\t\t// @TODO: remove in v4\n\t\t\tF.onAuthorize.call(F, req, req.websocket, req.flags, function(isAuthorized, user) {\n\n\t\t\t\tif (!F.onAuthorize.isobsolete) {\n\t\t\t\t\tF.onAuthorize.isobsolete = 1;\n\t\t\t\t\tOBSOLETE('F.onAuthorize', 'You need to use a new authorization declaration: \"AUTH(function($) {})\"');\n\t\t\t\t}\n\n\t\t\t\t// @isAuthorized \"null\" for callbacks(err, user)\n\t\t\t\t// @isAuthorized \"true\"\n\t\t\t\t// @isAuthorized \"object\" is as user but \"user\" must be \"undefined\"\n\n\t\t\t\tif (isAuthorized instanceof Error || isAuthorized instanceof ErrorBuilder) {\n\t\t\t\t\t// Error handling\n\t\t\t\t\tisAuthorized = false;\n\t\t\t\t} else if (isAuthorized == null && user) {\n\t\t\t\t\t// A callback error handling\n\t\t\t\t\tisAuthorized = true;\n\t\t\t\t} else if (user == null && isAuthorized && isAuthorized !== true) {\n\t\t\t\t\tuser = isAuthorized;\n\t\t\t\t\tisAuthorized = true;\n\t\t\t\t}\n\n\t\t\t\tif (user)\n\t\t\t\t\treq.user = user;\n\t\t\t\tvar route = F.lookup_websocket(req, req.websocket.uri.pathname, isAuthorized ? 1 : 2);\n\t\t\t\tif (route) {\n\t\t\t\t\tF.$websocketcontinue_process(route, req, path);\n\t\t\t\t} else\n\t\t\t\t\treq.websocket.$close(4001, '401: unauthorized');\n\t\t\t});\n\t\t}\n\t} else {\n\t\tvar route = F.lookup_websocket(req, req.websocket.uri.pathname, 0);\n\t\tif (route) {\n\t\t\tF.$websocketcontinue_process(route, req, path);\n\t\t} else\n\t\t\treq.websocket.$close(4004, '404: not found');\n\t}\n};\n\nF.$websocketcontinue_process = function(route, req, path) {\n\n\tvar socket = req.websocket;\n\n\tif (!socket.prepare(route.flags, route.protocols, route.allow, route.length)) {\n\t\tsocket.$close(4001, '401: unauthorized');\n\t\treturn;\n\t}\n\n\tvar id = path + (route.flags.length ? '#' + route.flags.join('-') : '');\n\n\tif (route.isBINARY)\n\t\tsocket.type = 1;\n\telse if (route.isJSON)\n\t\tsocket.type = 3;\n\n\tif (route.isBUFFER)\n\t\tsocket.typebuffer = true;\n\n\tvar next = function() {\n\n\t\tif (req.$total_middleware)\n\t\t\treq.$total_middleware = null;\n\n\t\tif (F.connections[id]) {\n\t\t\tsocket.upgrade(F.connections[id]);\n\t\t\treturn;\n\t\t}\n\n\t\tvar connection = new WebSocket(path, route.controller, id);\n\t\tconnection.encodedecode = CONF.default_websocket_encodedecode === true;\n\t\tconnection.route = route;\n\t\tconnection.options = route.options;\n\t\tF.connections[id] = connection;\n\t\troute.onInitialize.apply(connection, framework_internal.routeParam(route.param.length ? req.split : req.path, route));\n\t\tsetImmediate(next_upgrade_continue, socket, connection);\n\t};\n\n\tif (route.middleware)\n\t\tasync_middleware(0, req, req.websocket, route.middleware, next, route.options);\n\telse\n\t\tnext();\n};\n\nfunction next_upgrade_continue(socket, connection) {\n\tsocket.upgrade(connection);\n}\n\n/**\n * Request statistics writer\n * @private\n * @param {Boolean} beg\n * @param {Boolean} isStaticFile\n * @return {Framework}\n */\nF.reqstats = function(beg) {\n\n\tif (beg)\n\t\tF.stats.request.pending++;\n\telse\n\t\tF.stats.request.pending--;\n\n\tif (F.stats.request.pending < 0)\n\t\tF.stats.request.pending = 0;\n\n\treturn F;\n};\n\n/**\n * Get a model\n * @param {String} name\n * @return {Object}\n */\nglobal.MODEL = F.model = function(name) {\n\tvar obj = F.models[name];\n\tif (obj || obj === null)\n\t\treturn obj;\n\tvar filename = U.combine(CONF.directory_models, name + '.js');\n\texistsSync(filename) && F.install('model', name, filename, undefined, undefined, undefined, true);\n\treturn F.models[name] || null;\n};\n\n/**\n * Load a source code\n * @param {String} name\n * @param {Object} options Custom initial options, optional.\n * @return {Object}\n */\nglobal.INCLUDE = global.SOURCE = F.source = function(name, options, callback) {\n\tvar obj = F.sources[name];\n\tif (obj || obj === null)\n\t\treturn obj;\n\tvar filename = U.combine(CONF.directory_source, name + '.js');\n\texistsSync(filename) && F.install('source', name, filename, options, callback, undefined, true);\n\treturn F.sources[name] || null;\n};\n\n/**\n * Load a source code (alias for F.source())\n * @param {String} name\n * @param {Object} options Custom initial options, optional.\n * @return {Object}\n */\nF.include = function(name, options, callback) {\n\treturn F.source(name, options, callback);\n};\n\n/**\n * Send e-mail\n * @param {String or Array} address E-mail address.\n * @param {String} subject E-mail subject.\n * @param {String} view View name.\n * @param {Object} model Optional.\n * @param {Function(err)} callback Optional.\n * @param {String} language Optional.\n * @return {MailMessage}\n */\nglobal.MAIL = F.mail = function(address, subject, view, model, callback, language) {\n\n\tif (typeof(callback) === 'string') {\n\t\tvar tmp = language;\n\t\tlanguage = callback;\n\t\tcallback = tmp;\n\t}\n\n\tvar controller = EMPTYCONTROLLER;\n\tcontroller.layoutName = '';\n\tcontroller.themeName = U.parseTheme(view);\n\n\tif (controller.themeName)\n\t\tview = prepare_viewname(view);\n\telse if (F.onTheme)\n\t\tcontroller.themeName = F.onTheme(controller);\n\telse\n\t\tcontroller.themeName = '';\n\n\tvar replyTo;\n\n\t// Translation\n\tif (typeof(language) === 'string') {\n\t\tsubject = subject.indexOf('@(') === -1 ? F.translate(language, subject) : F.translator(language, subject);\n\t\tcontroller.language = language;\n\t}\n\n\tvar mail = controller.mail(address, subject, view, model, callback, replyTo);\n\n\tif (language != null)\n\t\tmail.language = language;\n\n\treturn mail;\n};\n\n/**\n * Renders view\n * @param {String} name View name.\n * @param {Object} model Model.\n * @param {String} layout Layout for the view, optional. Default without layout.\n * @param {Object} repository A repository object, optional. Default empty.\n * @param {String} language Optional.\n * @return {String}\n */\nglobal.VIEW = function(name, model, layout, repository, language) {\n\n\tvar controller = EMPTYCONTROLLER;\n\n\tif (typeof(layout) === 'object') {\n\t\tvar tmp = repository;\n\t\trepository = layout;\n\t\tlayout = tmp;\n\t}\n\n\tcontroller.layoutName = layout || '';\n\tcontroller.language = language || '';\n\tcontroller.repository = typeof(repository) === 'object' && repository ? repository : EMPTYOBJECT;\n\n\tvar theme = U.parseTheme(name);\n\tif (theme) {\n\t\tcontroller.themeName = theme;\n\t\tname = prepare_viewname(name);\n\t} else if (F.onTheme)\n\t\tcontroller.themeName = F.onTheme(controller);\n\telse\n\t\tcontroller.themeName = undefined;\n\n\treturn controller.view(name, model, true);\n};\n\nF.view = function(name, model, layout, repository, language) {\n\tOBSOLETE('F.view()', 'Instead of F.view() use VIEW()');\n\treturn VIEW(name, model, layout, repository, language);\n};\n\n/**\n * Compiles and renders view\n * @param {String} body HTML body.\n * @param {Object} model Model.\n * @param {String} layout Layout for the view, optional. Default without layout.\n * @param {Object} repository A repository object, optional. Default empty.\n * @param {String} language Optional.\n * @return {String}\n */\nglobal.VIEWCOMPILE = function(body, model, layout, repository, language) {\n\n\tvar controller = EMPTYCONTROLLER;\n\n\tif (typeof(layout) === 'object') {\n\t\tvar tmp = repository;\n\t\trepository = layout;\n\t\tlayout = tmp;\n\t}\n\n\tcontroller.layoutName = layout || '';\n\tcontroller.language = language || '';\n\tcontroller.themeName = undefined;\n\tcontroller.repository = typeof(repository) === 'object' && repository ? repository : EMPTYOBJECT;\n\n\treturn controller.view_compile(body, model, true);\n};\n\nF.viewCompile = function(body, model, layout, repository, language) {\n\tOBSOLETE('F.viewCompile()', 'Instead of F.viewCompile() use VIEWCOMPILE()');\n\treturn VIEWCOMPILE(body, model, layout, repository, language);\n};\n\n/**\n * Load tests\n * @private\n * @param {Boolean} stop Stop framework after end.\n * @param {String Array} names Test names, optional.\n * @param {Function()} cb\n * @return {Framework}\n */\nF.test = function() {\n\tF.isTest = true;\n\tF.$configure_configs('config-test', true);\n\trequire('./test').load();\n\treturn F;\n};\n\n/**\n * Clear temporary directory\n * @param {Function} callback\n * @param {Boolean} isInit Private argument.\n * @return {Framework}\n */\nF.clear = function(callback, isInit) {\n\n\tvar dir = F.path.temp();\n\tvar plus = F.id ? 'i-' + F.id + '_' : '';\n\n\tif (isInit) {\n\t\tif (!CONF.allow_clear_temp) {\n\t\t\tif (F.$bundling) {\n\t\t\t\t// clears only JS and CSS files\n\t\t\t\tU.ls(dir, function(files) {\n\t\t\t\t\tF.unlink(files, function() {\n\t\t\t\t\t\tcallback && callback();\n\t\t\t\t\t});\n\t\t\t\t}, function(filename, folder) {\n\t\t\t\t\tif (folder || (plus && !filename.substring(dir.length).startsWith(plus)))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (filename.indexOf('.package') !== -1)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tvar ext = U.getExtension(filename);\n\t\t\t\t\treturn JSFILES[ext]  || ext === 'css' || ext === 'tmp' || ext === 'upload' || ext === 'html' || ext === 'htm';\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn F;\n\t\t}\n\t}\n\n\tif (!existsSync(dir) || !F.$bundling) {\n\t\tcallback && callback();\n\t\treturn F;\n\t}\n\n\tU.ls(dir, function(files, directories) {\n\n\t\tif (isInit) {\n\t\t\tvar arr = [];\n\t\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\t\t\t\tvar filename = files[i].substring(dir.length);\n\t\t\t\tif (plus && !filename.startsWith(plus))\n\t\t\t\t\tcontinue;\n\t\t\t\t(filename.indexOf('/') === -1 || filename.indexOf('.package/') !== -1) && !filename.endsWith('.jsoncache') && arr.push(files[i]);\n\t\t\t}\n\n\t\t\tfiles = arr;\n\t\t\tdirectories = directories.remove(function(name) {\n\t\t\t\tname = U.getName(name);\n\n\t\t\t\tif (name[0] === '~')\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (name.endsWith('.package'))\n\t\t\t\t\treturn false;\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tF.unlink(files, () => F.rmdir(directories, callback));\n\t});\n\n\tif (!isInit) {\n\t\t// clear static cache\n\t\tF.temporary.path = {};\n\t\tF.temporary.range = {};\n\t\tF.temporary.notfound = {};\n\t}\n\n\treturn F;\n};\n\n/**\n * Remove files in array\n * @param {String Array} arr File list.\n * @param {Function} callback\n * @return {Framework}\n */\nF.unlink = F.path.unlink = function(arr, callback) {\n\n\tif (typeof(arr) === 'string')\n\t\tarr = [arr];\n\n\tif (!arr.length) {\n\t\tcallback && callback();\n\t\treturn F;\n\t}\n\n\tvar filename = arr.shift();\n\tif (filename)\n\t\tFs.unlink(filename, () => F.unlink(arr, callback));\n\telse\n\t\tcallback && callback();\n\n\treturn F;\n};\n\n/**\n * Remove directories in array\n * @param {String Array} arr\n * @param {Function} callback\n * @return {Framework}\n */\nF.rmdir = F.path.rmdir = function(arr, callback) {\n\tif (typeof(arr) === 'string')\n\t\tarr = [arr];\n\n\tif (!arr.length) {\n\t\tcallback && callback();\n\t\treturn F;\n\t}\n\n\tvar path = arr.shift();\n\tif (path) {\n\t\tU.ls(path, function(files, directories) {\n\t\t\tdirectories.reverse();\n\t\t\tdirectories.push(path);\n\t\t\tfiles.wait((item, next) => Fs.unlink(item, next), function() {\n\t\t\t\tdirectories.wait(function(item, next) {\n\t\t\t\t\tFs.rmdir(item, next);\n\t\t\t\t}, () => F.rmdir(arr, callback));\n\t\t\t});\n\t\t});\n\t} else\n\t\tcallback && callback();\n\n\treturn F;\n};\n\n/**\n * Cryptography (encrypt)\n * @param {String} value\n * @param {String} key Encrypt key.\n * @param {Boolean} isUnique Optional, default true.\n * @return {String}\n */\nglobal.ENCRYPT = F.encrypt = function(value, key, isUnique) {\n\n\tif (value == null)\n\t\treturn '';\n\n\tvar type = typeof(value);\n\n\tif (typeof(key) === 'boolean') {\n\t\tvar tmp = isUnique;\n\t\tisUnique = key;\n\t\tkey = tmp;\n\t}\n\n\tif (type === 'function')\n\t\tvalue = value();\n\telse if (type === 'number')\n\t\tvalue = value.toString();\n\telse if (type === 'object')\n\t\tvalue = JSON.stringify(value);\n\n\tif (CONF.default_crypto) {\n\t\tkey = (key || '') + CONF.secret;\n\n\t\tif (key.length < 32)\n\t\t\tkey += ''.padLeft(32 - key.length, '0');\n\n\t\tif (key.length > 32)\n\t\t\tkey = key.substring(0, 32);\n\n\t\tif (!F.temporary.keys[key])\n\t\t\tF.temporary.keys[key] = Buffer.from(key);\n\n\t\tvar cipher = Crypto.createCipheriv(CONF.default_crypto, F.temporary.keys[key], CONF.default_crypto_iv);\n\t\tCONCAT[0] = cipher.update(value);\n\t\tCONCAT[1] = cipher.final();\n\t\treturn Buffer.concat(CONCAT).toString('hex');\n\t}\n\n\treturn value.encrypt(CONF.secret + '=' + key, isUnique);\n};\n\n/**\n * Cryptography (decrypt)\n * @param {String} value\n * @param {String} key Decrypt key.\n * @param {Boolean} jsonConvert Optional, default true.\n * @return {Object or String}\n */\nglobal.DECRYPT = F.decrypt = function(value, key, jsonConvert) {\n\n\tif (typeof(key) === 'boolean') {\n\t\tvar tmp = jsonConvert;\n\t\tjsonConvert = key;\n\t\tkey = tmp;\n\t}\n\n\tif (typeof(jsonConvert) !== 'boolean')\n\t\tjsonConvert = true;\n\n\tvar response;\n\n\tif (CONF.default_crypto) {\n\n\t\tkey = (key || '') + CONF.secret;\n\n\t\tif (key.length < 32)\n\t\t\tkey += ''.padLeft(32 - key.length, '0');\n\n\t\tif (key.length > 32)\n\t\t\tkey = key.substring(0, 32);\n\n\t\tif (!F.temporary.keys[key])\n\t\t\tF.temporary.keys[key] = Buffer.from(key);\n\n\t\tvar decipher = Crypto.createDecipheriv(CONF.default_crypto, F.temporary.keys[key], CONF.default_crypto_iv);\n\t\ttry {\n\t\t\tCONCAT[0] = decipher.update(Buffer.from(value || '', 'hex'));\n\t\t\tCONCAT[1] = decipher.final();\n\t\t\tresponse = Buffer.concat(CONCAT).toString('utf8');\n\t\t} catch (e) {\n\t\t\tresponse = null;\n\t\t}\n\t} else\n\t\tresponse = (value || '').decrypt(CONF.secret + '=' + key);\n\n\treturn response ? (jsonConvert ? (response.isJSON() ? response.parseJSON(true) : null) : response) : null;\n};\n\nglobal.ENCRYPTREQ = function(req, val, key, strict) {\n\n\tif (req instanceof Controller)\n\t\treq = req.req;\n\n\tvar obj = {};\n\tobj.ua = req.ua;\n\tif (strict)\n\t\tobj.ip = req.ip;\n\tobj.data = val;\n\treturn F.encrypt(obj, key);\n};\n\nglobal.DECRYPTREQ = function(req, val, key) {\n\tif (!val)\n\t\treturn;\n\tif (req instanceof Controller)\n\t\treq = req.req;\n\tvar obj = F.decrypt(val, key || '', true);\n\tif (!obj || (obj.ip && obj.ip !== req.ip) || (obj.ua !== req.ua))\n\t\treturn;\n\treturn obj.data;\n};\n\n/**\n * Create hash\n * @param {String} type Type (md5, sha1, sha256, etc.)\n * @param {String} value\n * @param {String} salt Optional, default false.\n * @return {String}\n */\nF.hash = function(type, value, salt) {\n\n\tOBSOLETE('F.hash()', 'Use String.prototype.hash()');\n\n\tvar hash = Crypto.createHash(type);\n\tvar plus = '';\n\n\tif (typeof(salt) === 'string')\n\t\tplus = salt;\n\telse if (salt !== false)\n\t\tplus = (CONF.secret || '');\n\n\thash.update(value.toString() + plus, ENCODING);\n\treturn hash.digest('hex');\n};\n\n/**\n * Resource reader\n * @param {String} name Optional, resource file name. Default: \"default\".\n * @param {String} key Resource key.\n * @return {String} String\n */\n\nconst DEFNAME = 'default';\n\nglobal.RESOURCE = F.resource = function(name, key) {\n\n\tif (!key) {\n\t\tkey = name;\n\t\tname = null;\n\t}\n\n\tif (!name)\n\t\tname = DEFNAME;\n\n\tvar res = F.resources[name];\n\tif (res) {\n\t\tif (res.$empty && res[key] == null && name !== DEFNAME)\n\t\t\treturn res[key] = F.resource(DEFNAME, key); // tries to load a value from \"default.resource\"\n\t\treturn res[key] == null ? '' : res[key];\n\t}\n\n\tvar routes = F.routes.resources[name];\n\tvar body = '';\n\tvar filename;\n\tif (routes) {\n\t\tfor (var i = 0, length = routes.length; i < length; i++) {\n\t\t\tfilename = routes[i];\n\t\t\tif (existsSync(filename))\n\t\t\t\tbody += (body ? '\\n' : '') + Fs.readFileSync(filename).toString(ENCODING);\n\t\t}\n\t}\n\n\tvar filename = U.combine(CONF.directory_resources, name + '.resource');\n\tvar empty = false;\n\tif (existsSync(filename))\n\t\tbody += (body ? '\\n' : '') + Fs.readFileSync(filename).toString(ENCODING);\n\telse\n\t\tempty = true;\n\n\tvar obj = body.parseConfig();\n\tF.resources[name] = obj;\n\tobj.$empty = empty;\n\treturn obj[key] == null ? name == DEFNAME ? '' : obj[key] = F.resource(DEFNAME, key) : obj[key];\n};\n\n/**\n * Translates text\n * @param {String} language A resource filename, optional.\n * @param {String} text\n * @return {String}\n */\n\n// var obsolete_translate = false;\nglobal.TRANSLATE = F.translate = function(language, text) {\n\n\tif (!text) {\n\t\ttext = language;\n\t\tlanguage = undefined;\n\t}\n\n\tif (text[0] === '#' && text[1] !== ' ')\n\t\treturn F.resource(language, text.substring(1));\n\n\t/*\n\tvar value = F.resource(language, 'T' + text.hash(true).toString(16));\n\tif (!value) {\n\t\tvalue = F.resources[language]['T' + text.hash()];\n\t\tif (value && !obsolete_translate) {\n\t\t\tobsolete_translate = true;\n\t\t\tOBSOLETE(language + '.resource', 'A resource file contains older keys with localization, please regenerate localization.');\n\t\t}\n\t}*/\n\tvar value = F.resource(language, 'T' + text.hash());\n\treturn value ? value : text;\n};\n\n/**\n * The translator for the text from the View Engine @(TEXT TO TRANSLATE)\n * @param {String} language A resource filename, optional.\n * @param {String} text\n * @return {String}\n */\nglobal.TRANSLATOR = F.translator = function(language, text) {\n\treturn framework_internal.parseLocalization(text, language);\n};\n\nF.$configure_sitemap = function(arr, clean) {\n\n\tif (!arr || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'sitemap');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (!arr || !arr.length)\n\t\treturn F;\n\n\tif (clean || !F.routes.sitemap)\n\t\tF.routes.sitemap = {};\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar str = arr[i];\n\t\tif (!str || str[0] === '#' || str.substring(0, 3) === '// ')\n\t\t\tcontinue;\n\n\t\tvar index = str.indexOf(' :');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tvar key = str.substring(0, index).trim();\n\t\tvar val = str.substring(index + 2).trim();\n\t\tvar a = val.split('-->');\n\t\tvar url = a[1].trim();\n\t\tvar wildcard = false;\n\n\t\tif (url.endsWith('*')) {\n\t\t\twildcard = true;\n\t\t\turl = url.substring(0, url.length - 1);\n\t\t} else if (url.endsWith('*)')) {\n\t\t\t// localization\n\t\t\twildcard = true;\n\t\t\turl = url.substring(0, url.length - 2);\n\t\t}\n\n\t\tvar name = a[0].trim();\n\t\tvar localizeName = name.startsWith('@(');\n\t\tvar localizeUrl = url.startsWith('@(');\n\n\t\tif (localizeName)\n\t\t\tname = name.substring(2, name.length - 1).trim();\n\n\t\tif (localizeUrl)\n\t\t\turl = url.substring(2, url.length - 1).trim();\n\n\t\tF.routes.sitemap[key] = { name: name, url: url, parent: a[2] ? a[2].trim() : null, wildcard: wildcard, formatName: name.indexOf('{') !== -1, formatUrl: url.indexOf('{') !== -1, localizeName: localizeName, localizeUrl: localizeUrl };\n\t}\n\n\treturn F;\n};\n\nglobal.SITEMAP = F.sitemap = function(name, me, language) {\n\n\tif (!F.routes.sitemap)\n\t\treturn me ? null : EMPTYARRAY;\n\n\tif (typeof(me) === 'string') {\n\t\tlanguage = me;\n\t\tme = false;\n\t}\n\n\tvar key = REPOSITORY_SITEMAP + name + '$' + (me ? '1' : '0') + '$' + (language || '');\n\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tvar sitemap;\n\tvar id = name;\n\tvar url;\n\tvar title;\n\n\tif (me === true) {\n\t\tsitemap = F.routes.sitemap[name];\n\t\tvar item = { sitemap: id, id: '', name: '', url: '', last: true, selected: true, index: 0, wildcard: false, formatName: false, formatUrl: false };\n\t\tif (!sitemap)\n\t\t\treturn item;\n\n\t\ttitle = sitemap.name;\n\t\tif (sitemap.localizeName)\n\t\t\ttitle = F.translate(language, title);\n\n\t\turl = sitemap.url;\n\t\tvar wildcard = sitemap.wildcard;\n\n\t\tif (sitemap.localizeUrl) {\n\t\t\tif (sitemap.wildcard) {\n\t\t\t\tif (url[url.length - 1] !== '/')\n\t\t\t\t\turl += '/';\n\t\t\t\turl += '*';\n\t\t\t}\n\n\t\t\turl = F.translate(language, url);\n\n\t\t\tif (url.endsWith('*')) {\n\t\t\t\turl = url.substring(0, url.length - 1);\n\t\t\t\twildcard = true;\n\t\t\t} else\n\t\t\t\twildcard = false;\n\t\t}\n\n\t\titem.sitemap = id;\n\t\titem.id = name;\n\t\titem.formatName = sitemap.formatName;\n\t\titem.formatUrl = sitemap.formatUrl;\n\t\titem.localizeUrl = sitemap.localizeUrl;\n\t\titem.localizeName = sitemap.localizeName;\n\t\titem.name = title;\n\t\titem.url = url;\n\t\titem.wildcard = wildcard;\n\t\tF.temporary.other[key] = item;\n\t\treturn item;\n\t}\n\n\tvar arr = [];\n\tvar index = 0;\n\n\twhile (true) {\n\t\tsitemap = F.routes.sitemap[name];\n\t\tif (!sitemap)\n\t\t\tbreak;\n\n\t\ttitle = sitemap.name;\n\t\turl = sitemap.url;\n\n\t\tvar wildcard = sitemap.wildcard;\n\n\t\tif (sitemap.localizeName)\n\t\t\ttitle = F.translate(language, sitemap.name);\n\n\t\tif (sitemap.localizeUrl) {\n\t\t\tif (sitemap.wildcard) {\n\t\t\t\tif (url[url.length - 1] !== '/')\n\t\t\t\t\turl += '/';\n\t\t\t\turl += '*';\n\t\t\t}\n\t\t\turl = F.translate(language, url);\n\n\t\t\tif (url.endsWith('*')) {\n\t\t\t\turl = url.substring(0, url.length - 1);\n\t\t\t\twildcard = true;\n\t\t\t} else\n\t\t\t\twildcard = false;\n\t\t}\n\n\t\tarr.push({ sitemap: id, id: name, name: title, url: url, last: index === 0, first: sitemap.parent ? false : true, selected: index === 0, index: index, wildcard: wildcard, formatName: sitemap.formatName, formatUrl: sitemap.formatUrl, localizeName: sitemap.localizeName, localizeUrl: sitemap.localizeUrl });\n\t\tindex++;\n\t\tname = sitemap.parent;\n\t\tif (!name)\n\t\t\tbreak;\n\t}\n\n\tarr.reverse();\n\tF.temporary.other[key] = arr;\n\treturn arr;\n};\n\n/**\n * Gets a list of all items in sitemap\n * @param {String} parent\n * @param {String} language Optional, language\n * @return {Array}\n */\nF.sitemap_navigation = function(parent, language) {\n\n\tvar key = REPOSITORY_SITEMAP + '_n_' + (parent || '') + '$' + (language || '');\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tvar keys = Object.keys(F.routes.sitemap);\n\tvar arr = [];\n\tvar index = 0;\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tvar item = F.routes.sitemap[keys[i]];\n\t\tif ((parent && item.parent !== parent) || (!parent && item.parent))\n\t\t\tcontinue;\n\n\t\tvar title = item.name;\n\t\tvar url = item.url;\n\n\t\tif (item.localizeName)\n\t\t\ttitle = F.translate(language, title);\n\n\t\tif (item.localizeUrl)\n\t\t\turl = F.translate(language, url);\n\n\t\tarr.push({ id: parent || '', name: title, url: url, last: index === 0, first: item.parent ? false : true, selected: index === 0, index: index, wildcard: item.wildcard, formatName: item.formatName, formatUrl: item.formatUrl });\n\t\tindex++;\n\t}\n\n\tarr.quicksort('name');\n\tF.temporary.other[key] = arr;\n\treturn arr;\n};\n\n/**\n * Adds an item(s) to sitemap\n * @param {String|Array} obj - 'ID : Title ---> URL --> [Parent]' parent is optional\n * @return {framework}\n */\nF.sitemap_add = function (obj) {\n\tF.$configure_sitemap(obj instanceof Array ? obj : [obj]);\n\treturn F;\n};\n\nF.$configure_dependencies = function(arr, callback) {\n\n\tif (!arr || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'dependencies');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (!arr || !arr.length)\n\t\treturn F;\n\n\tOBSOLETE('/dependencies', 'File \"/dependencies\" are deprecated and they will be removed in v4.');\n\n\tvar type;\n\tvar options;\n\tvar interval;\n\tvar dependencies = [];\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar str = arr[i];\n\n\t\tif (!str || str[0] === '#' || str.substring(0, 3) === '// ')\n\t\t\tcontinue;\n\n\t\tvar index = str.indexOf(' :');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tvar key = str.substring(0, index).trim();\n\t\tvar url = str.substring(index + 2).trim();\n\t\tvar priority = 0;\n\n\t\toptions = undefined;\n\t\tinterval = undefined;\n\n\t\tindex = key.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tinterval = key.substring(index, key.indexOf(')', index)).replace(/\\(|\\)/g, '').trim();\n\t\t\tkey = key.substring(0, index).trim();\n\t\t}\n\n\t\tindex = url.indexOf('-->');\n\t\tif (index !== -1) {\n\t\t\tvar opt = url.substring(index + 3).trim();\n\t\t\tif (opt.isJSON())\n\t\t\t\toptions = opt.parseJSON(true);\n\t\t\turl = url.substring(0, index).trim();\n\t\t}\n\n\t\tswitch (key) {\n\t\t\tcase 'package':\n\t\t\tcase 'packages':\n\t\t\tcase 'pkg':\n\t\t\t\ttype = 'package';\n\t\t\t\tpriority = 9;\n\t\t\t\tbreak;\n\t\t\tcase 'module':\n\t\t\tcase 'modules':\n\t\t\t\ttype = 'module';\n\t\t\t\tpriority = 10;\n\t\t\t\tbreak;\n\t\t\tcase 'model':\n\t\t\tcase 'models':\n\t\t\t\ttype = 'model';\n\t\t\t\tpriority = 8;\n\t\t\t\tbreak;\n\t\t\tcase 'source':\n\t\t\tcase 'sources':\n\t\t\t\ttype = 'source';\n\t\t\t\tpriority = 3;\n\t\t\t\tbreak;\n\t\t\tcase 'controller':\n\t\t\tcase 'controllers':\n\t\t\t\ttype = 'controller';\n\t\t\t\tpriority = 4;\n\t\t\t\tbreak;\n\t\t\tcase 'view':\n\t\t\tcase 'views':\n\t\t\t\tpriority = 3;\n\t\t\t\ttype = 'view';\n\t\t\t\tbreak;\n\t\t\tcase 'version':\n\t\t\tcase 'versions':\n\t\t\t\tpriority = 3;\n\t\t\t\ttype = 'version';\n\t\t\t\tbreak;\n\t\t\tcase 'config':\n\t\t\tcase 'configuration':\n\t\t\t\tpriority = 11;\n\t\t\t\ttype = 'config';\n\t\t\t\tbreak;\n\t\t\tcase 'isomorphic':\n\t\t\tcase 'isomorphics':\n\t\t\t\tpriority = 6;\n\t\t\t\ttype = 'isomorphic';\n\t\t\t\tbreak;\n\t\t\tcase 'definition':\n\t\t\tcase 'definitions':\n\t\t\t\tpriority = 5;\n\t\t\t\ttype = 'definition';\n\t\t\t\tbreak;\n\t\t\tcase 'middleware':\n\t\t\tcase 'middlewares':\n\t\t\t\ttype = 'middleware';\n\t\t\t\tpriority = 4;\n\t\t\t\tbreak;\n\t\t\tcase 'component':\n\t\t\tcase 'components':\n\t\t\t\tpriority = 7;\n\t\t\t\ttype = 'component';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (type) {\n\t\t\t(function(type, url, options, interval) {\n\t\t\t\tif (interval)\n\t\t\t\t\tdependencies.push({ priority: priority, fn: next => F.uptodate(type, url, options, interval, next) });\n\t\t\t\telse\n\t\t\t\t\tdependencies.push({ priority: priority, fn: next => F.install(type, url, options, undefined, undefined, undefined, undefined, undefined, undefined, next) });\n\t\t\t})(type, url, options, interval);\n\t\t}\n\t}\n\n\tdependencies.quicksort('priority', false);\n\tdependencies.wait(function(item, next) {\n\t\titem.fn(next);\n\t}, callback);\n\treturn F;\n};\n\nF.$configure_workflows = function(arr, clean) {\n\n\tif (arr === undefined || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'workflows');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (clean)\n\t\tF.workflows = {};\n\n\tif (!arr || !arr.length)\n\t\treturn F;\n\n\tOBSOLETE('/workflows', 'File \"/workflows\" are deprecated and they will be removed in v4.');\n\n\tarr.forEach(function(line) {\n\t\tline = line.trim();\n\t\tif (line.startsWith('//'))\n\t\t\treturn;\n\t\tvar index = line.indexOf(':');\n\t\tif (index === -1)\n\t\t\treturn;\n\n\t\tvar key = line.substring(0, index).trim();\n\t\tvar response = -1;\n\t\tvar builder = [];\n\n\t\t// sub-type\n\t\tvar subindex = key.indexOf('(');\n\t\tif (subindex !== -1) {\n\t\t\tvar type = key.substring(subindex + 1, key.indexOf(')', subindex + 1)).trim();\n\t\t\tkey = key.substring(0, subindex).trim();\n\t\t\ttype = type.replace(/^default\\//gi, '');\n\t\t\tkey = type + '#' + key;\n\t\t}\n\n\t\tline.substring(index + 1).split('-->').forEach(function(operation, index) {\n\n\t\t\tvar options = 'options||EMPTYOBJECT';\n\t\t\toperation = operation.trim().replace(/\"/g, '\\'');\n\n\t\t\tvar oindex = operation.indexOf('{');\n\t\t\tif (oindex !== -1) {\n\t\t\t\toptions = operation.substring(oindex, operation.lastIndexOf('}') + 1);\n\t\t\t\toperation = operation.replace(options, '').trim();\n\t\t\t\toptions = 'options||' + options;\n\t\t\t}\n\n\t\t\tif (operation.endsWith('(response)')) {\n\t\t\t\tresponse = index;\n\t\t\t\toperation = operation.replace('(response)', '').trim();\n\t\t\t}\n\n\t\t\tvar what = operation.split(':');\n\t\t\tif (what.length === 2)\n\t\t\t\tbuilder.push('$' + what[0].trim() + '(' + what[1].trim() + ', {0})'.format(options));\n\t\t\telse\n\t\t\t\tbuilder.push('$' + what[0] + '({0})'.format(options));\n\n\t\t});\n\n\t\tF.workflows[key] = new Function('model', 'options', 'callback', 'return model.$async(callback' + (response === -1 ? '' : ', ' + response) + ').' + builder.join('.') + ';');\n\t});\n\n\treturn F;\n};\n\nF.$configure_versions = function(arr, clean) {\n\n\tif (arr === undefined || typeof(arr) === 'string') {\n\t\tvar filename = prepare_filename(arr || 'versions');\n\t\tif (existsSync(filename, true))\n\t\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t\telse\n\t\t\tarr = null;\n\t}\n\n\tif (!arr) {\n\t\tif (clean)\n\t\t\tF.versions = null;\n\t\treturn F;\n\t}\n\n\tif (!clean)\n\t\tF.versions = {};\n\n\tif (!F.versions)\n\t\tF.versions = {};\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\n\t\tvar str = arr[i];\n\n\t\tif (!str || str[0] === '#' || str.substring(0, 3) === '// ')\n\t\t\tcontinue;\n\n\t\tif (str[0] !== '/')\n\t\t\tstr = '/' + str;\n\n\t\tvar index = str.indexOf(' :');\n\t\tvar ismap = false;\n\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1) {\n\t\t\t\tindex = str.indexOf('-->');\n\t\t\t\tif (index === -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tismap = true;\n\t\t\t}\n\t\t}\n\n\t\tvar len = ismap ? 3 : 2;\n\t\tvar key = str.substring(0, index).trim();\n\t\tvar filename = str.substring(index + len).trim();\n\n\t\tif (CONF.default_root)\n\t\t\tkey = U.join(CONF.default_root, key);\n\n\t\tif (filename === 'auto') {\n\n\t\t\tif (ismap)\n\t\t\t\tthrow new Error('/versions: \"auto\" value can\\'t be used with mapping');\n\n\t\t\tF.versions[key] = filename;\n\n\t\t\t(function(key, filename) {\n\t\t\t\tON('ready', function() {\n\t\t\t\t\tF.consoledebug('\"versions\" is getting checksum of ' + key);\n\t\t\t\t\tmakehash(key, function(hash) {\n\n\t\t\t\t\t\tF.consoledebug('\"versions\" is getting checksum of ' + key + ' (done)');\n\n\t\t\t\t\t\tif (hash) {\n\t\t\t\t\t\t\tvar index = key.lastIndexOf('.');\n\t\t\t\t\t\t\tfilename = key.substring(0, index) + '-' + hash + key.substring(index);\n\n\t\t\t\t\t\t\tF.versions[key] = filename;\n\n\t\t\t\t\t\t\tif (!F.routes.merge[key] && !F.temporary.other['merge_' + key]) {\n\t\t\t\t\t\t\t\tvar index = key.indexOf('/', 1);\n\t\t\t\t\t\t\t\tvar theme = index === -1 ? null : key.substring(1, index);\n\t\t\t\t\t\t\t\tif (theme) {\n\t\t\t\t\t\t\t\t\tif (F.themes[theme])\n\t\t\t\t\t\t\t\t\t\tkey = F.themes[theme] + 'public' + key.substring(index);\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tkey = F.path.public(key);\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\tkey = F.path.public(key);\n\t\t\t\t\t\t\t\tF.map(filename, key);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tF.temporary.views = {};\n\t\t\t\t\t\t\tF.temporary.other = {};\n\t\t\t\t\t\t\tglobal.$VIEWCACHE = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})(key, filename);\n\n\t\t} else {\n\t\t\tF.versions[key] = filename;\n\t\t\tismap && F.map(filename, F.path.public(key));\n\t\t}\n\t}\n\n\treturn F;\n};\n\nfunction makehash(url, callback, count) {\n\tvar target = 'http://' + (F.ip === 'auto' ? '0.0.0.0' : F.ip) + ':' + F.port + url;\n\tU.download(target, ['get'], function(err, stream, status) {\n\n\t\t// Maybe F.wait()\n\t\tif (status === 503) {\n\t\t\t// Unhandled problem\n\t\t\tif (count > 60)\n\t\t\t\tcallback('');\n\t\t\telse\n\t\t\t\tsetTimeout((url, callback, count) => makehash(url, callback, (count || 1) + 1), 1000, url, callback, count);\n\t\t\treturn;\n\t\t}\n\n\t\tif (status !== 200) {\n\t\t\tcallback('');\n\t\t\treturn;\n\t\t}\n\n\t\tvar hash = Crypto.createHash('md5');\n\t\thash.setEncoding('hex');\n\t\tstream.pipe(hash);\n\t\tstream.on('end', function() {\n\t\t\thash.end();\n\t\t\tcallback(hash.read().crc32(true));\n\t\t});\n\n\t\tstream.on('error', () => callback(''));\n\t});\n}\n\nF.$configure_env = function(filename) {\n\n\tvar data;\n\n\tif (filename) {\n\t\tfilename = prepare_filename(filename);\n\t\tif (!existsSync(filename, true))\n\t\t\treturn F;\n\t\tdata = Fs.readFileSync(filename).toString(ENCODING);\n\t}\n\n\tvar filename2 = null;\n\n\tif (!filename) {\n\t\tfilename = U.combine('/', '.env');\n\t\tfilename2 = '.env-' + (DEBUG ? 'debug' : 'release');\n\t\tif (!existsSync(filename, true)) {\n\t\t\tF.$configure_env(filename2);\n\t\t\treturn F;\n\t\t}\n\t\tdata = Fs.readFileSync(filename).toString(ENCODING);\n\t}\n\n\tdata = data.parseENV();\n\tvar keys = Object.keys(data);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tif (!process.env.hasOwnProperty(key))\n\t\t\tprocess.env[key] = data[key];\n\t}\n\n\tfilename2 && F.$configure_env(filename2);\n\treturn F;\n};\n\nF.$configure_configs = function(arr, rewrite) {\n\n\tvar type = typeof(arr);\n\tif (type === 'string') {\n\t\tvar filename = prepare_filename(arr);\n\t\tif (!existsSync(filename, true))\n\t\t\treturn F;\n\t\tarr = Fs.readFileSync(filename).toString(ENCODING).split('\\n');\n\t}\n\n\tif (!arr) {\n\n\t\tvar filenameA = U.combine('/', 'config');\n\t\tvar filenameB = U.combine('/', 'config-' + (DEBUG ? 'debug' : 'release'));\n\t\tarr = [];\n\n\t\t// read all files from \"configs\" directory\n\t\tvar configs = PATH.configs();\n\t\tif (existsSync(configs)) {\n\t\t\tvar tmp = Fs.readdirSync(configs);\n\t\t\tfor (var i = 0, length = tmp.length; i < length; i++) {\n\t\t\t\tvar skip = tmp[i].match(/-(debug|release|test)$/i);\n\t\t\t\tif (skip) {\n\t\t\t\t\tskip = skip[0].toString().toLowerCase();\n\t\t\t\t\tif (skip === '-debug' && !F.isDebug)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (skip === '-release' && F.isDebug)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (skip === '-test' && !F.isTest)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tarr = arr.concat(Fs.readFileSync(configs + tmp[i]).toString(ENCODING).split('\\n'));\n\t\t\t}\n\t\t}\n\n\t\tif (existsSync(filenameA) && Fs.lstatSync(filenameA).isFile())\n\t\t\tarr = arr.concat(Fs.readFileSync(filenameA).toString(ENCODING).split('\\n'));\n\n\t\tif (existsSync(filenameB) && Fs.lstatSync(filenameB).isFile())\n\t\t\tarr = arr.concat(Fs.readFileSync(filenameB).toString(ENCODING).split('\\n'));\n\t}\n\n\tvar done = function() {\n\t\tprocess.title = 'total: ' + CONF.name.removeDiacritics().toLowerCase().replace(REG_EMPTY, '-').substring(0, 8);\n\t\tF.isVirtualDirectory = existsSync(U.combine(CONF.directory_public_virtual));\n\t};\n\n\tif (!(arr instanceof Array) || !arr.length) {\n\t\tdone();\n\t\treturn F;\n\t}\n\n\tif (rewrite === undefined)\n\t\trewrite = true;\n\n\tvar obj = {};\n\tvar accepts = null;\n\tvar length = arr.length;\n\tvar tmp;\n\tvar subtype;\n\tvar value;\n\tvar generated = [];\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar str = arr[i];\n\n\t\tif (!str || str[0] === '#' || (str[0] === '/' || str[1] === '/'))\n\t\t\tcontinue;\n\n\t\tvar index = str.indexOf(':');\n\t\tif (index === -1)\n\t\t\tcontinue;\n\n\t\tvar name = str.substring(0, index).trim();\n\t\tif (name === 'debug' || name === 'resources')\n\t\t\tcontinue;\n\n\t\tvalue = str.substring(index + 1).trim();\n\t\tindex = name.indexOf('(');\n\n\t\tif (value.substring(0, 7) === 'base64 ' && value.length > 8)\n\t\t\tvalue = Buffer.from(value.substring(7).trim(), 'base64').toString('utf8');\n\t\telse if (value.substring(0, 4) === 'hex ' && value.length > 6)\n\t\t\tvalue = Buffer.from(value.substring(4).trim(), 'hex').toString('utf8');\n\n\t\tif (index !== -1) {\n\t\t\tsubtype = name.substring(index + 1, name.indexOf(')')).trim().toLowerCase();\n\t\t\tname = name.substring(0, index).trim();\n\t\t} else\n\t\t\tsubtype = '';\n\n\t\tswitch (name) {\n\t\t\tcase 'secret':\n\t\t\tcase 'secret-uid':\n\t\t\tcase 'secret_uid':\n\t\t\t\tname = name.replace(REG_OLDCONF, '_');\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t\tcase 'default-request-length':\n\t\t\t\tOBSOLETE(name, 'You need to use \"default_request_maxlength\"');\n\t\t\t\tobj.default_request_maxlength = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-websocket-request-length':\n\t\t\t\tOBSOLETE(name, 'You need to use \"default_websocket_maxlength\"');\n\t\t\t\tobj.default_websocket_maxlength = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-maximum-file-descriptors':\n\t\t\t\tOBSOLETE(name, 'You need to use \"default_maxopenfiles\"');\n\t\t\t\tobj.default_maxopenfiles = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-cors-maxage': // old\n\t\t\tcase 'default-request-timeout': // old\n\t\t\tcase 'default-request-maxlength': // old\n\t\t\tcase 'default-request-maxkeys': // old\n\t\t\tcase 'default-websocket-maxlength': // old\n\t\t\tcase 'default-interval-clear-cache': // old\n\t\t\tcase 'default-interval-clear-resources': // old\n\t\t\tcase 'default-interval-precompile-views': // old\n\t\t\tcase 'default-interval-uptodate': // old\n\t\t\tcase 'default-interval-websocket-ping': // old\n\t\t\tcase 'default-interval-clear-dnscache': // old\n\t\t\tcase 'default-dependency-timeout': // old\n\t\t\tcase 'default-restbuilder-timeout': // old\n\t\t\tcase 'nosql-cleaner': // old\n\t\t\tcase 'default-errorbuilder-status': // old\n\t\t\tcase 'default-maxopenfiles': // old\n\t\t\tcase 'default_maxopenfiles':\n\t\t\tcase 'default_errorbuilder_status':\n\t\t\tcase 'default_cors_maxage':\n\t\t\tcase 'default_request_timeout':\n\t\t\tcase 'default_request_maxlength':\n\t\t\tcase 'default_request_maxkeys':\n\t\t\tcase 'default_websocket_maxlength':\n\t\t\tcase 'default_interval_clear_cache':\n\t\t\tcase 'default_interval_clear_resources':\n\t\t\tcase 'default_interval_precompile_views':\n\t\t\tcase 'default_interval_uptodate':\n\t\t\tcase 'default_interval_websocket_ping':\n\t\t\tcase 'default_interval_clear_dnscache':\n\t\t\tcase 'default_dependency_timeout':\n\t\t\tcase 'default_restbuilder_timeout':\n\t\t\tcase 'nosql_cleaner':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = U.parseInt(value);\n\t\t\t\tbreak;\n\t\t\tcase 'default-image-consumption': // old\n\t\t\tcase 'default-image-quality': // old\n\t\t\tcase 'default_image_consumption':\n\t\t\tcase 'default_image_quality':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = U.parseInt(value.replace(/%|\\s/g, ''));\n\t\t\t\tbreak;\n\n\t\t\tcase 'static-accepts-custom': // old\n\t\t\tcase 'static_accepts_custom':\n\t\t\t\taccepts = value.replace(REG_ACCEPTCLEANER, '').split(',');\n\t\t\t\tbreak;\n\n\t\t\tcase 'default-root': // old\n\t\t\tcase 'default_root':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tif (value)\n\t\t\t\t\tobj[name] = U.path(value);\n\t\t\t\tbreak;\n\n\t\t\tcase 'static-accepts': // old\n\t\t\tcase 'static_accepts':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = {};\n\t\t\t\ttmp = value.replace(REG_ACCEPTCLEANER, '').split(',');\n\t\t\t\tfor (var j = 0; j < tmp.length; j++)\n\t\t\t\t\tobj[name][tmp[j]] = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'mail.smtp':\n\t\t\tcase 'mail.smtp.options':\n\t\t\tcase 'mail.address.from':\n\t\t\tcase 'mail.address.copy':\n\t\t\tcase 'mail.address.bcc':\n\t\t\tcase 'mail.address.reply':\n\n\t\t\t\tif (name === 'mail.address.bcc')\n\t\t\t\t\ttmp = 'mail_address_copy';\n\t\t\t\telse\n\t\t\t\t\ttmp = name.replace(/\\./g, '-');\n\n\t\t\t\tOBSOLETE(name, 'is renamed to \"' + tmp + '\"');\n\t\t\t\tobj[tmp] = value;\n\t\t\t\tbreak;\n\n\t\t\tcase 'default-cors': // old\n\t\t\tcase 'default_cors':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tvalue = value.replace(/,/g, ' ').split(' ');\n\t\t\t\ttmp = [];\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\t\tvar co = (value[j] || '').trim();\n\t\t\t\t\tif (co) {\n\t\t\t\t\t\tco = co.toLowerCase();\n\t\t\t\t\t\tif (co.substring(0, 2) === '//') {\n\t\t\t\t\t\t\ttmp.push(co);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\ttmp.push(co.substring(co.indexOf('/') + 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobj[name] = tmp.length ? tmp : null;\n\t\t\t\tbreak;\n\n\t\t\tcase 'allow-handle-static-files':\n\t\t\t\tOBSOLETE('config[\"allow-handle-static-files\"]', 'The key has been renamed to \"allow_static_files\"');\n\t\t\t\tobj.allow_static_files = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'disable-clear-temporary-directory':\n\t\t\t\tOBSOLETE('disable-clear-temporary-directory', 'You need to use \"allow_clear_temp : true|false\"');\n\t\t\t\tobj.allow_clear_temp = !(value.toLowerCase() === 'true' || value === '1' || value === 'on');\n\t\t\t\tbreak;\n\n\t\t\tcase 'disable-strict-server-certificate-validation':\n\t\t\t\tOBSOLETE('disable-strict-server-certificate-validation', 'You need to use \"allow_ssc_validation : true|false\"');\n\t\t\t\tobj.allow_ssc_validation = !(value.toLowerCase() === 'true' || value === '1' || value === 'on');\n\t\t\t\tbreak;\n\n\t\t\tcase 'allow-compile': // old\n\t\t\tcase 'allow-compile-html': // old\n\t\t\tcase 'allow-compile-script': // old\n\t\t\tcase 'allow-compile-style': // old\n\t\t\tcase 'allow-ssc-validation': // old\n\t\t\tcase 'allow-debug': // old\n\t\t\tcase 'allow-gzip': // old\n\t\t\tcase 'allow-head': // old\n\t\t\tcase 'allow-performance': // old\n\t\t\tcase 'allow-static-files': // old\n\t\t\tcase 'allow-websocket': // old\n\t\t\tcase 'allow-websocket-compression': // old\n\t\t\tcase 'allow-clear-temp': // old\n\t\t\tcase 'allow-cache-snapshot': // old\n\t\t\tcase 'allow-cache-cluster': // old\n\t\t\tcase 'allow-custom-titles': // old\n\t\t\tcase 'nosql-worker': // old\n\t\t\tcase 'nosql-logger': // old\n\t\t\tcase 'allow-filter-errors': // old\n\t\t\tcase 'default-websocket-encodedecode': // old\n\t\t\tcase 'allow_compile':\n\t\t\tcase 'allow_compile_html':\n\t\t\tcase 'allow_compile_script':\n\t\t\tcase 'allow_compile_style':\n\t\t\tcase 'allow_ssc_validation':\n\t\t\tcase 'allow_debug':\n\t\t\tcase 'allow_gzip':\n\t\t\tcase 'allow_head':\n\t\t\tcase 'allow_performance':\n\t\t\tcase 'allow_static_files':\n\t\t\tcase 'allow_websocket':\n\t\t\tcase 'allow_websocket_compression':\n\t\t\tcase 'allow_clear_temp':\n\t\t\tcase 'allow_cache_snapshot':\n\t\t\tcase 'allow_cache_cluster':\n\t\t\tcase 'allow_filter_errors':\n\t\t\tcase 'allow_custom_titles':\n\t\t\tcase 'trace':\n\t\t\tcase 'nosql_worker':\n\t\t\tcase 'nosql_logger':\n\t\t\tcase 'default_websocket_encodedecode':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = value.toLowerCase() === 'true' || value === '1' || value === 'on';\n\t\t\t\tbreak;\n\n\t\t\tcase 'nosql-inmemory': // old\n\t\t\tcase 'nosql_inmemory':\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = typeof(value) === 'string' ? value.split(',').trim() : value instanceof Array ? value : null;\n\t\t\t\tbreak;\n\n\t\t\tcase 'allow-compress-html':\n\t\t\t\tobj.allow_compile_html = value.toLowerCase() === 'true' || value === '1' || value === 'on';\n\t\t\t\tbreak;\n\n\t\t\tcase 'version':\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\n\t\t\tcase 'security.txt':\n\t\t\t\tobj[name] = value ? value.split(',').trim().join('\\n') : '';\n\t\t\t\tbreak;\n\n\t\t\tcase 'default_crypto_iv':\n\t\t\t\tobj[name] = typeof(value) === 'string' ? Buffer.from(value, 'hex') : value;\n\t\t\t\tbreak;\n\t\t\tcase 'allow_workers_silent':\n\t\t\t\tobj[name] = HEADERS.workers.silent = value;\n\t\t\t\tbreak;\n\n\t\t\t// backward compatibility\n\t\t\tcase 'mail-smtp': // old\n\t\t\tcase 'mail-smtp-options': // old\n\t\t\tcase 'mail-address-from': // old\n\t\t\tcase 'mail-address-copy': // old\n\t\t\tcase 'mail-address-bcc': // old\n\t\t\tcase 'mail-address-reply': // old\n\t\t\tcase 'default-image-converter': // old\n\t\t\tcase 'static-url': // old\n\t\t\tcase 'static-url-script': // old\n\t\t\tcase 'static-url-style': // old\n\t\t\tcase 'static-url-image': // old\n\t\t\tcase 'static-url-video': // old\n\t\t\tcase 'static-url-font': // old\n\t\t\tcase 'static-url-download': // old\n\t\t\tcase 'static-url-components': // old\n\t\t\tcase 'default-xpoweredby': // old\n\t\t\tcase 'default-layout': // old\n\t\t\tcase 'default-theme': // old\n\t\t\tcase 'default-proxy': // old\n\t\t\tcase 'default-timezone': // old\n\t\t\tcase 'default-response-maxage': // old\n\t\t\tcase 'default-errorbuilder-resource-name': // old\n\t\t\tcase 'default-errorbuilder-resource-prefix': // old\n\t\t\t\tname = obsolete_config(name);\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif (subtype === 'string')\n\t\t\t\t\tobj[name] = value;\n\t\t\t\telse if (subtype === 'number' || subtype === 'currency' || subtype === 'float' || subtype === 'double')\n\t\t\t\t\tobj[name] = value.isNumber(true) ? value.parseFloat2() : value.parseInt2();\n\t\t\t\telse if (subtype === 'boolean' || subtype === 'bool')\n\t\t\t\t\tobj[name] = (/true|on|1|enabled/i).test(value);\n\t\t\t\telse if (subtype === 'eval' || subtype === 'object' || subtype === 'array') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tobj[name] = new Function('return ' + value)();\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tF.error(e, 'F.configure(' + name + ')');\n\t\t\t\t\t}\n\t\t\t\t} else if (subtype === 'json')\n\t\t\t\t\tobj[name] = value.parseJSON();\n\t\t\t\telse if (subtype === 'date' || subtype === 'datetime' || subtype === 'time')\n\t\t\t\t\tobj[name] = value.parseDate();\n\t\t\t\telse if (subtype === 'env' || subtype === 'environment')\n\t\t\t\t\tobj[name] = process.env[value];\n\t\t\t\telse if (subtype === 'random')\n\t\t\t\t\tobj[name] = GUID(value || 10);\n\t\t\t\telse if (subtype === 'generate') {\n\t\t\t\t\tobj[name] = GUID(value || 10);\n\t\t\t\t\tgenerated.push(name);\n\t\t\t\t} else {\n\t\t\t\t\tif (value.isNumber()) {\n\t\t\t\t\t\tobj[name] = value[0] !== '0' ? U.parseInt(value) : value;\n\t\t\t\t\t} else if (value.isNumber(true))\n\t\t\t\t\t\tobj[name] = value.indexOf(',') === -1 && !(/^0{2,}/).test(value) ? U.parseFloat(value) : value;\n\t\t\t\t\telse\n\t\t\t\t\t\tobj[name] = value.isBoolean() ? value.toLowerCase() === 'true' : value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Cache for generated passwords\n\tif (generated && generated.length) {\n\t\tvar filenameC = U.combine('/databases/', 'config{0}.json'.format(global.THREAD ? ('_' + global.THREAD) : ''));\n\t\tvar gdata;\n\n\t\tif (existsSync(filenameC)) {\n\t\t\tgdata = Fs.readFileSync(filenameC).toString('utf8').parseJSON(true);\n\t\t\tfor (var i = 0; i < generated.length; i++) {\n\t\t\t\tif (gdata[generated[i]] != null)\n\t\t\t\t\tobj[generated[i]] = gdata[generated[i]];\n\t\t\t}\n\t\t}\n\n\t\ttmp = {};\n\t\tfor (var i = 0; i < generated.length; i++)\n\t\t\ttmp[generated[i]] = obj[generated[i]];\n\n\t\tPATH.verify('databases');\n\t\tFs.writeFileSync(filenameC, JSON.stringify(tmp), NOOP);\n\t}\n\n\tU.extend(CONF, obj, rewrite);\n\n\tif (!CONF.secret_uid)\n\t\tCONF.secret_uid = (CONF.name).crc32(true).toString();\n\n\ttmp = CONF.mail_smtp_options;\n\tif (typeof(tmp) === 'string' && tmp) {\n\t\ttmp = new Function('return ' + tmp)();\n\t\tCONF.mail_smtp_options = tmp;\n\t}\n\n\tprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = CONF.allow_ssc_validation === false ? '0' : '1';\n\n\tif (!CONF.directory_temp)\n\t\tCONF.directory_temp = '~' + U.path(Path.join(Os.tmpdir(), 'totaljs' + F.directory.hash()));\n\n\tif (!CONF.etag_version)\n\t\tCONF.etag_version = CONF.version.replace(/\\.|\\s/g, '');\n\n\tif (CONF.default_timezone)\n\t\tprocess.env.TZ = CONF.default_timezone;\n\n\tCONF.nosql_worker && framework_nosql.worker();\n\tCONF.nosql_inmemory && CONF.nosql_inmemory.forEach(framework_nosql.inmemory);\n\taccepts && accepts.length && accepts.forEach(accept => CONF.static_accepts[accept] = true);\n\n\tif (CONF.allow_performance)\n\t\thttp.globalAgent.maxSockets = 9999;\n\n\tQUERYPARSEROPTIONS.maxKeys = CONF.default_request_maxkeys || 33;\n\n\tvar xpowered = CONF.default_xpoweredby;\n\n\tObject.keys(HEADERS).forEach(function(key) {\n\t\tObject.keys(HEADERS[key]).forEach(function(subkey) {\n\t\t\tif (RELEASE && subkey === 'Cache-Control')\n\t\t\t\tHEADERS[key][subkey] = HEADERS[key][subkey].replace(/max-age=\\d+/, 'max-age=' + CONF.default_response_maxage);\n\t\t\tif (subkey === 'X-Powered-By') {\n\t\t\t\tif (xpowered)\n\t\t\t\t\tHEADERS[key][subkey] = xpowered;\n\t\t\t\telse\n\t\t\t\t\tdelete HEADERS[key][subkey];\n\t\t\t}\n\t\t});\n\t});\n\n\tdone();\n\tEMIT('configure', CONF);\n\treturn F;\n};\n\nfunction obsolete_config(name) {\n\tif (name.indexOf('-') === -1)\n\t\treturn name;\n\tvar n = name.replace(REG_OLDCONF, '_');\n\tOBSOLETE('config[\\'' + name + '\\']', 'Replace key \"{0}\" to \"{1}\" in your config file'.format(name, n));\n\treturn n;\n}\n\n/**\n * Create URL: JavaScript (according to config['static-url-script'])\n * @param {String} name\n * @return {String}\n */\nF.routeScript = function(name, theme) {\n\tOBSOLETE('F.routeScript()', 'Renamed to F.public_js');\n\treturn F.$public(name, CONF.static_url_script, theme);\n};\n\n/**\n * Create URL: CSS (according to config['static-url-style'])\n * @param {String} name\n * @return {String}\n */\nF.routeStyle = function(name, theme) {\n\tOBSOLETE('F.routeStyle()', 'Renamed to F.public_css');\n\treturn F.$public(name, CONF.static_url_style, theme);\n};\n\nF.routeImage = function(name, theme) {\n\tOBSOLETE('F.routeImage()', 'Renamed to F.public_image');\n\treturn F.$public(name, CONF.static_url_image, theme);\n};\n\nF.routeVideo = function(name, theme) {\n\tOBSOLETE('F.routeVideo()', 'Renamed to F.public_video');\n\treturn F.$public(name, CONF.static_url_video, theme);\n};\n\nF.routeFont = function(name, theme) {\n\tOBSOLETE('F.routeFont()', 'Renamed to F.public_font');\n\treturn F.$public(name, CONF.static_url_font, theme);\n};\n\nF.routeDownload = function(name, theme) {\n\tOBSOLETE('F.routeDownload()', 'Renamed to F.public_download');\n\treturn F.$public(name, CONF.static_url_download, theme);\n};\n\nF.routeStatic = function(name, theme) {\n\tOBSOLETE('F.routeStatic()', 'Renamed to F.public');\n\treturn F.$public(name, CONF.static_url, theme);\n};\n\nF.public_js = function(name, theme) {\n\treturn F.$public(name, CONF.static_url_script, theme);\n};\n\nF.public_css = function(name, theme) {\n\treturn F.$public(name, CONF.static_url_style, theme);\n};\n\nF.public_image = function(name, theme) {\n\treturn F.$public(name, CONF.static_url_image, theme);\n};\n\nF.public_video = function(name, theme) {\n\treturn F.$public(name, CONF.static_url_video, theme);\n};\n\nF.public_font = function(name, theme) {\n\treturn F.$public(name, CONF.static_url_font, theme);\n};\n\nF.public_download = function(name, theme) {\n\treturn F.$public(name, CONF.static_url_download, theme);\n};\n\nF.public = function(name, theme) {\n\treturn F.$public(name, CONF.static_url, theme);\n};\n\nF.$public = function(name, directory, theme) {\n\tvar key = name + directory + '$' + theme;\n\tvar val = F.temporary.other[key];\n\tif (RELEASE && val)\n\t\treturn val;\n\n\n\tif (name[0] === '~') {\n\t\tname = name.substring(name[1] === '~' ? 2 : 1);\n\t\ttheme = '';\n\t} else if (name[0] === '=') {\n\t\t// theme\n\t\tvar index = name.indexOf('/');\n\t\tif (index !== -1) {\n\t\t\ttheme = name.substring(1, index);\n\t\t\tif (theme === '?') {\n\t\t\t\ttheme = CONF.default_theme;\n\t\t\t\tname = name.substring(index);\n\t\t\t} else\n\t\t\t\tname = name.substring(index + 1);\n\t\t}\n\t}\n\n\tvar filename;\n\n\tif (REG_ROUTESTATIC.test(name))\n\t\tfilename = name;\n\telse if (name[0] === '/')\n\t\tfilename = U.join(theme, F.$version(name, true));\n\telse {\n\t\tfilename = U.join(theme, directory, F.$version(name, true));\n\t\tif (REG_HTTPHTTPS.test(filename) && filename[0] === '/')\n\t\t\tfilename = filename.substring(1);\n\t}\n\n\treturn F.temporary.other[key] = F.$version(framework_internal.preparePath(filename), true);\n};\n\nF.$version = function(name, def) {\n\tvar tmp;\n\n\tif (F.versions)\n\t\ttmp = F.versions[name] || name;\n\n\tif (F.onVersion)\n\t\ttmp = F.onVersion(name) || name;\n\n\treturn tmp === 'auto' && def ? name : (tmp || name);\n};\n\nF.$versionprepare = function(html) {\n\tvar match = html.match(REG_VERSIONS);\n\tif (!match)\n\t\treturn html;\n\n\tfor (var i = 0, length = match.length; i < length; i++) {\n\n\t\tvar src = match[i].toString();\n\t\tvar end = 5;\n\n\t\t// href\n\t\tif (src[0] === 'h')\n\t\t\tend = 6;\n\n\t\tvar name = src.substring(end, src.length - 1);\n\t\thtml = html.replace(match[i], src.substring(0, end) + F.$version(name, true) + '\"');\n\t}\n\n\treturn html;\n};\n\n/**\n * Lookup for the route\n * @param {HttpRequest} req\n * @param {String} url URL address.\n * @param {String Array} flags\n * @param {Boolean} membertype Not defined = 0, Authorized = 1, Unauthorized = 2\n * @return {Object}\n */\nF.lookup = function(req, url, flags, membertype) {\n\n\tvar isSystem = url[0] === '#';\n\tvar subdomain = F._length_subdomain_web && req.subdomain ? req.subdomain.join('.') : null;\n\n\tif (isSystem)\n\t\treturn F.routes.system[url];\n\n\tif (isSystem)\n\t\treq.path = [url];\n\n\tvar key;\n\n\t// helper for 401 http status\n\treq.$isAuthorized = true;\n\n\tif (!isSystem) {\n\t\tkey = '1' + url + '$' + membertype + req.$flags + (subdomain ? '$' + subdomain : '') + (req.$roles ? 'R' : '');\n\t\tif (F.temporary.other[key])\n\t\t\treturn F.temporary.other[key];\n\t}\n\n\tfor (var i = 0; i < F.routes.web.length; i++) {\n\t\tvar route = F.routes.web[i];\n\n\t\tif (route.CUSTOM) {\n\t\t\tif (!route.CUSTOM(url, req, flags))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (F._length_subdomain_web && !framework_internal.routeCompareSubdomain(subdomain, route.subdomain))\n\t\t\t\tcontinue;\n\t\t\tif (route.isWILDCARD) {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, isSystem, true))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, isSystem))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (isSystem) {\n\t\t\tif (route.isSYSTEM)\n\t\t\t\treturn route;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.isPARAM && route.regexp) {\n\t\t\tvar skip = false;\n\t\t\tfor (var j = 0, l = route.regexpIndexer.length; j < l; j++) {\n\n\t\t\t\tvar p = req.path[route.regexpIndexer[j]];\n\t\t\t\tif (p === undefined) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!route.regexp[route.regexpIndexer[j]].test(p)) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.flags && route.flags.length) {\n\t\t\tvar result = framework_internal.routeCompareFlags2(req, route, membertype);\n\t\t\tif (result === -1)\n\t\t\t\treq.$isAuthorized = false; // request is not authorized\n\t\t\tif (result < 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (key && route.isCACHE && (req.$isAuthorized || membertype === 1))\n\t\t\tF.temporary.other[key] = route;\n\n\t\treturn route;\n\t}\n\n\treturn null;\n};\n\nF.lookupaction = function(req, url) {\n\n\tvar isSystem = url[0] === '#';\n\tif (isSystem)\n\t\treturn F.routes.system[url];\n\n\tvar length = F.routes.web.length;\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar route = F.routes.web[i];\n\t\tif (route.method !== req.method)\n\t\t\tcontinue;\n\n\t\tif (route.CUSTOM) {\n\t\t\tif (!route.CUSTOM(url, req))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (route.isWILDCARD) {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, isSystem, true))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, isSystem))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (isSystem) {\n\t\t\tif (route.isSYSTEM)\n\t\t\t\treturn route;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.isPARAM && route.regexp) {\n\t\t\tvar skip = false;\n\t\t\tfor (var j = 0, l = route.regexpIndexer.length; j < l; j++) {\n\t\t\t\tvar p = req.path[route.regexpIndexer[j]];\n\t\t\t\tif (p === undefined || !route.regexp[route.regexpIndexer[j]].test(p)) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skip)\n\t\t\t\tcontinue;\n\t\t}\n\t\treturn route;\n\t}\n};\n\n\nF.lookup_websocket = function(req, url, membertype) {\n\n\tvar subdomain = F._length_subdomain_websocket && req.subdomain ? req.subdomain.join('.') : null;\n\tvar length = F.routes.websockets.length;\n\n\treq.$isAuthorized = true;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar route = F.routes.websockets[i];\n\n\t\tif (route.CUSTOM) {\n\t\t\tif (!route.CUSTOM(url, req))\n\t\t\t\tcontinue;\n\t\t} else {\n\n\t\t\tif (F._length_subdomain_websocket && !framework_internal.routeCompareSubdomain(subdomain, route.subdomain))\n\t\t\t\tcontinue;\n\t\t\tif (route.isWILDCARD) {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, false, true))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!framework_internal.routeCompare(req.path, route.url, false))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (route.isPARAM && route.regexp) {\n\t\t\tvar skip = false;\n\t\t\tfor (var j = 0, l = route.regexpIndexer.length; j < l; j++) {\n\n\t\t\t\tvar p = req.path[route.regexpIndexer[j]];\n\t\t\t\tif (p === undefined) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!route.regexp[route.regexpIndexer[j]].test(p)) {\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skip)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (route.flags && route.flags.length) {\n\t\t\tvar result = framework_internal.routeCompareFlags2(req, route, membertype);\n\t\t\tif (result === -1)\n\t\t\t\treq.$isAuthorized = false;\n\t\t\tif (result < 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn route;\n\t}\n\n\treturn null;\n};\n\n/**\n * Accept file type\n * @param {String} extension\n * @param {String} contentType Content-Type for file extension, optional.\n * @return {Framework}\n */\nF.accept = function(extension, contentType) {\n\tif (extension[0] === '.')\n\t\textension = extension.substring(1);\n\tCONF.static_accepts[extension] = true;\n\tcontentType && U.setContentType(extension, contentType);\n\treturn F;\n};\n\n// A temporary variable for generating Worker ID\n// It's faster than Date.now()\nvar WORKERID = 0;\n\n/**\n * Run worker\n * @param {String} name\n * @param {String} id Worker id, optional.\n * @param {Number} timeout Timeout, optional.\n * @param {Array} args Additional arguments, optional.\n * @return {ChildProcess}\n */\nglobal.WORKER = F.worker = function(name, id, timeout, args, special) {\n\n\tvar fork = null;\n\tvar type = typeof(id);\n\n\tif (type === 'number' && timeout === undefined) {\n\t\ttimeout = id;\n\t\tid = null;\n\t\ttype = 'undefined';\n\t}\n\n\tif (type === 'string')\n\t\tfork = F.workers[id];\n\n\tif (id instanceof Array) {\n\t\targs = id;\n\t\tid = null;\n\t\ttimeout = undefined;\n\t}\n\n\tif (timeout instanceof Array) {\n\t\targs = timeout;\n\t\ttimeout = undefined;\n\t}\n\n\tif (fork)\n\t\treturn fork;\n\n\tvar filename = name[0] === '@' ? F.path.package(name.substring(1)) : U.combine(CONF.directory_workers, name);\n\n\tif (!args)\n\t\targs = EMPTYARRAY;\n\n\tfork = Child.fork(filename[filename.length - 3] === '.' ? filename : filename + '.js', args, special ? HEADERS.workers2 : HEADERS.workers);\n\n\tif (!id)\n\t\tid = name + '_' + (WORKERID++);\n\n\tfork.__id = id;\n\tF.workers[id] = fork;\n\n\tfork.on('exit', function() {\n\t\tvar self = this;\n\t\tself.__timeout && clearTimeout(self.__timeout);\n\t\tdelete F.workers[self.__id];\n\t\tif (fork) {\n\t\t\tfork.removeAllListeners();\n\t\t\tfork = null;\n\t\t}\n\t});\n\n\tif (typeof(timeout) !== 'number')\n\t\treturn fork;\n\n\tfork.__timeout = setTimeout(function() {\n\t\tfork && fork.kill('SIGKILL');\n\t}, timeout);\n\n\treturn fork;\n};\n\nglobal.WORKER2 = F.worker2 = function(name, args, callback, timeout) {\n\n\tif (typeof(args) === 'function') {\n\t\ttimeout = callback;\n\t\tcallback = args;\n\t\targs = undefined;\n\t} else if (typeof(callback) === 'number') {\n\t\tvar tmp = timeout;\n\t\ttimeout = callback;\n\t\tcallback = tmp;\n\t}\n\n\tif (args && !(args instanceof Array))\n\t\targs = [args];\n\n\tvar fork = F.worker(name, null, timeout, args, true);\n\tif (fork.__worker2)\n\t\treturn fork;\n\n\tvar output = Buffer.alloc(0);\n\n\tfork.__worker2 = true;\n\tfork.on('error', function(e) {\n\t\tcallback && callback(e, output);\n\t\tcallback = null;\n\t});\n\n\tfork.stdout.on('data', function(data) {\n\t\tCONCAT[0] = output;\n\t\tCONCAT[1] = data;\n\t\toutput = Buffer.concat(CONCAT);\n\t});\n\n\tfork.on('exit', function() {\n\t\tcallback && callback(null, output);\n\t\tcallback = null;\n\t});\n\n\treturn fork;\n};\n\n/**\n * This method suspends\n * @param {String} name Operation name.\n * @param {Boolean} enable Enable waiting (optional, default: by the current state).\n * @return {Boolean}\n */\nglobal.PAUSESERVER = F.wait = function(name, enable) {\n\n\tif (!F.waits)\n\t\tF.waits = {};\n\n\tif (enable !== undefined) {\n\t\tif (enable)\n\t\t\tF.waits[name] = true;\n\t\telse\n\t\t\tdelete F.waits[name];\n\t\tF._length_wait = Object.keys(F.waits).length;\n\t\treturn enable;\n\t}\n\n\tif (F.waits[name])\n\t\tdelete F.waits[name];\n\telse {\n\t\tF.waits[name] = true;\n\t\tenable = true;\n\t}\n\n\tF._length_wait = Object.keys(F.waits).length;\n\treturn enable === true;\n};\n\nglobal.UPDATE = function(versions, callback, pauseserver, noarchive) {\n\n\tif (typeof(version) === 'function') {\n\t\tcallback = versions;\n\t\tversions = CONF.version;\n\t}\n\n\tif (typeof(callback) === 'string') {\n\t\tpauseserver = callback;\n\t\tcallback = null;\n\t}\n\n\tif (!(versions instanceof Array))\n\t\tversions = [versions];\n\n\tpauseserver && PAUSESERVER(pauseserver);\n\n\tif (F.id && F.id !== '0') {\n\t\tif (callback || pauseserver) {\n\t\t\tONCE('update', function() {\n\t\t\t\tcallback && callback();\n\t\t\t\tpauseserver && PAUSESERVER(pauseserver);\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tvar errorbuilder = new ErrorBuilder();\n\n\tversions.wait(function(version, next) {\n\n\t\tvar filename = PATH.updates(version + '.js');\n\t\tvar response;\n\n\t\ttry {\n\t\t\tresponse = Fs.readFileSync(filename);\n\t\t} catch (e) {\n\t\t\tnext();\n\t\t\treturn;\n\t\t}\n\n\t\tvar opt = {};\n\t\topt.version = version;\n\t\topt.callback = function(err) {\n\t\t\terr && errorbuilder.push(err);\n\n\t\t\tif (!noarchive)\n\t\t\t\tFs.renameSync(filename, filename + '_bk');\n\n\t\t\tnext();\n\t\t};\n\n\t\topt.done = function(arg) {\n\t\t\treturn function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\topt.callback(err);\n\t\t\t\t} else if (arg)\n\t\t\t\t\topt.callback();\n\t\t\t\telse\n\t\t\t\t\topt.callback();\n\t\t\t};\n\t\t};\n\n\t\topt.success = function() {\n\t\t\topt.callback(null);\n\t\t};\n\n\t\topt.invalid = function(err) {\n\t\t\topt.callback(err);\n\t\t};\n\n\t\tvar fn = new Function('$', response);\n\t\tfn(opt, response.toString('utf8'));\n\n\t}, function() {\n\t\tvar err = errorbuilder.length ? errorbuilder : null;\n\t\tcallback && callback(err);\n\t\tif (F.isCluster && F.id && F.id !== '0')\n\t\t\tprocess.send('total:update');\n\t\tpauseserver && PAUSESERVER(pauseserver);\n\t\tEMIT('update', err);\n\t});\n};\n\n// =================================================================================\n// Framework route\n// =================================================================================\n\nfunction FrameworkRoute() {\n\tthis.route = {};\n}\n\nFrameworkRoute.prototype = {\n\tget id() {\n\t\treturn this.route.id;\n\t},\n\tset id(value) {\n\t\tthis.route.id = value;\n\t},\n\tget description() {\n\t\treturn this.route.description;\n\t},\n\tset description(value) {\n\t\tthis.route.description = value;\n\t},\n\tget maxlength() {\n\t\treturn this.route.length;\n\t},\n\tset maxlength(value) {\n\t\tthis.route.length = value;\n\t},\n\tget options() {\n\t\treturn this.route.options;\n\t},\n\tset options(value) {\n\t\tthis.route.options = value;\n\t},\n\tget url() {\n\t\treturn this.route.urlraw;\n\t},\n\tget flags() {\n\t\treturn this.route.flags || EMPTYARRAY;\n\t},\n\tset groups(value) {\n\t\tthis.route.groups = value;\n\t},\n\tget groups() {\n\t\treturn this.route.groups;\n\t}\n};\n\nconst FrameworkRouteProto = FrameworkRoute.prototype;\n\nFrameworkRouteProto.make = function(fn) {\n\tfn && fn.call(this, this);\n\treturn this;\n};\n\nFrameworkRouteProto.setId = function(value) {\n\tthis.route.id = value;\n\treturn this;\n};\n\nFrameworkRouteProto.setDecription = function(value) {\n\tthis.route.description = value;\n\treturn this;\n};\n\nFrameworkRouteProto.setTimeout = function(value) {\n\tthis.route.timeout = value;\n\treturn this;\n};\n\nFrameworkRouteProto.setMaxLength = function(value) {\n\tthis.route.length = value;\n\treturn this;\n};\n\nFrameworkRouteProto.setOptions = function(value) {\n\tthis.route.options = value;\n\treturn this;\n};\n\n// =================================================================================\n// Framework path\n// =================================================================================\n\nfunction FrameworkPath() {}\nconst FrameworkPathProto = FrameworkPath.prototype;\n\nFrameworkPathProto.verify = function(name) {\n\tvar prop = '$directory-' + name;\n\tif (F.temporary.path[prop])\n\t\treturn F;\n\tvar directory = CONF['directory_' + name] || name;\n\tvar dir = U.combine(directory);\n\ttry {\n\t\t!existsSync(dir) && Fs.mkdirSync(dir);\n\t} catch (e) {}\n\tF.temporary.path[prop] = true;\n\treturn F;\n};\n\nFrameworkPathProto.mkdir = function(p, cache) {\n\n\tvar key = '$directory-' + p;\n\n\tif (cache && F.temporary.path[key])\n\t\treturn F;\n\n\tF.temporary.path[key] = true;\n\n\tvar is = F.isWindows;\n\tvar s = '';\n\n\tif (p[0] === '/') {\n\t\ts = is ? '\\\\' : '/';\n\t\tp = p.substring(1);\n\t}\n\n\tvar l = p.length - 1;\n\tvar beg = 0;\n\n\tif (is) {\n\t\tif (p[l] === '\\\\')\n\t\t\tp = p.substring(0, l);\n\n\t\tif (p[1] === ':')\n\t\t\tbeg = 1;\n\n\t} else {\n\t\tif (p[l] === '/')\n\t\t\tp = p.substring(0, l);\n\t}\n\n\tif (existsSync(p))\n\t\treturn F;\n\n\tvar arr = is ? p.replace(/\\//g, '\\\\').split('\\\\') : p.split('/');\n\tvar directory = s;\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar name = arr[i];\n\t\tif (is)\n\t\t\tdirectory += (i && directory ? '\\\\' : '') + name;\n\t\telse\n\t\t\tdirectory += (i && directory ? '/' : '') + name;\n\n\t\tif (i >= beg && !existsSync(directory))\n\t\t\tFs.mkdirSync(directory);\n\t}\n\n\treturn F;\n};\n\nFrameworkPathProto.exists = function(path, callback) {\n\tFs.lstat(path, (err, stats) => callback(err ? false : true, stats ? stats.size : 0, stats ? stats.isFile() : false));\n\treturn F;\n};\n\nFrameworkPathProto.public = function(filename) {\n\treturn U.combine(CONF.directory_public, filename);\n};\n\nFrameworkPathProto.public_cache = function(filename) {\n\tvar key = 'public_' + filename;\n\tvar item = F.temporary.other[key];\n\treturn item ? item : F.temporary.other[key] = U.combine(CONF.directory_public, filename);\n};\n\nFrameworkPathProto.private = function(filename) {\n\treturn U.combine(CONF.directory_private, filename);\n};\n\nFrameworkPathProto.isomorphic = function(filename) {\n\treturn U.combine(CONF.directory_isomorphic, filename);\n};\n\nFrameworkPathProto.configs = function(filename) {\n\treturn U.combine(CONF.directory_configs, filename);\n};\n\nFrameworkPathProto.virtual = function(filename) {\n\treturn U.combine(CONF.directory_public_virtual, filename);\n};\n\nFrameworkPathProto.logs = function(filename) {\n\tthis.verify('logs');\n\treturn U.combine(CONF.directory_logs, filename);\n};\n\nFrameworkPathProto.models = function(filename) {\n\treturn U.combine(CONF.directory_models, filename);\n};\n\nFrameworkPathProto.temp = function(filename) {\n\tthis.verify('temp');\n\treturn U.combine(CONF.directory_temp, filename);\n};\n\nFrameworkPathProto.temporary = function(filename) {\n\treturn this.temp(filename);\n};\n\nFrameworkPathProto.views = function(filename) {\n\treturn U.combine(CONF.directory_views, filename);\n};\n\nFrameworkPathProto.updates = function(filename) {\n\treturn U.combine(CONF.directory_updates, filename);\n};\n\nFrameworkPathProto.workers = function(filename) {\n\treturn U.combine(CONF.directory_workers, filename);\n};\n\nFrameworkPathProto.databases = function(filename) {\n\tthis.verify('databases');\n\treturn U.combine(CONF.directory_databases, filename);\n};\n\nFrameworkPathProto.modules = function(filename) {\n\treturn U.combine(CONF.directory_modules, filename);\n};\n\nFrameworkPathProto.schemas = function(filename) {\n\treturn U.combine(CONF.directory_schemas, filename);\n};\n\nFrameworkPathProto.operations = function(filename) {\n\treturn U.combine(CONF.directory_operations, filename);\n};\n\nFrameworkPathProto.tasks = function(filename) {\n\treturn U.combine(CONF.directory_tasks, filename);\n};\n\nFrameworkPathProto.controllers = function(filename) {\n\treturn U.combine(CONF.directory_controllers, filename);\n};\n\nFrameworkPathProto.definitions = function(filename) {\n\treturn U.combine(CONF.directory_definitions, filename);\n};\n\nFrameworkPathProto.tests = function(filename) {\n\treturn U.combine(CONF.directory_tests, filename);\n};\n\nFrameworkPathProto.resources = function(filename) {\n\treturn U.combine(CONF.directory_resources, filename);\n};\n\nFrameworkPathProto.services = function(filename) {\n\treturn U.combine(CONF.directory_services, filename);\n};\n\nFrameworkPathProto.packages = function(filename) {\n\treturn U.combine(CONF.directory_packages, filename);\n};\n\nFrameworkPathProto.themes = function(filename) {\n\treturn U.combine(CONF.directory_themes, filename);\n};\n\nFrameworkPathProto.components = function(filename) {\n\treturn U.combine(CONF.directory_components, filename);\n};\n\nFrameworkPathProto.root = function(filename) {\n\tvar p = Path.join(directory, filename || '');\n\treturn F.isWindows ? p.replace(/\\\\/g, '/') : p;\n};\n\nFrameworkPathProto.package = function(name, filename) {\n\n\tif (filename === undefined) {\n\t\tvar index = name.indexOf('/');\n\t\tif (index !== -1) {\n\t\t\tfilename = name.substring(index + 1);\n\t\t\tname = name.substring(0, index);\n\t\t}\n\t}\n\n\tvar tmp = CONF.directory_temp;\n\tvar p = tmp[0] === '~' ? Path.join(tmp.substring(1), name + '.package', filename || '') : Path.join(directory, tmp, name + '.package', filename || '');\n\treturn F.isWindows ? p.replace(REG_WINDOWSPATH, '/') : p;\n};\n\n// =================================================================================\n// Cache declaration\n// =================================================================================\n\nfunction FrameworkCache() {\n\tthis.items = {};\n\tthis.count = 1;\n\tthis.interval;\n\tthis.$sync = true;\n}\n\nconst FrameworkCacheProto = FrameworkCache.prototype;\n\nFrameworkCacheProto.init = function(notimer) {\n\tvar self = this;\n\n\tif (!notimer)\n\t\tself.init_timer();\n\n\tif (CONF.allow_cache_snapshot)\n\t\tself.load(() => self.loadpersistent());\n\telse\n\t\tself.loadpersistent();\n\n\treturn self;\n};\n\nFrameworkCacheProto.init_timer = function() {\n\tvar self = this;\n\tself.interval && clearInterval(self.interval);\n\tself.interval = setInterval(() => F.cache.recycle(), 1000 * 60);\n\treturn self;\n};\n\nFrameworkCacheProto.save = function() {\n\tFs.writeFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachesnapshot.jsoncache'), JSON.stringify(this.items), NOOP);\n\treturn this;\n};\n\nFrameworkCacheProto.load = function(callback) {\n\tvar self = this;\n\tFs.readFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachesnapshot.jsoncache'), function(err, data) {\n\t\tif (!err) {\n\t\t\ttry {\n\t\t\t\tdata = JSON.parse(data.toString('utf8'), (key, value) => typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value);\n\t\t\t\tself.items = data;\n\t\t\t} catch (e) {}\n\t\t}\n\t\tcallback && callback();\n\t});\n\treturn self;\n};\n\nFrameworkCacheProto.savepersistent = function() {\n\tsetTimeout2('framework_cachepersist', function(self) {\n\t\tvar keys = Object.keys(self.items);\n\t\tvar obj = {};\n\n\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tvar item = self.items[key];\n\t\t\tif (item && item.persist)\n\t\t\t\tobj[key] = item;\n\t\t}\n\n\t\tFs.writeFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachepersist.jsoncache'), JSON.stringify(obj), NOOP);\n\t}, 1000, 50, this);\n\treturn this;\n};\n\nFrameworkCacheProto.loadpersistent = function(callback) {\n\tvar self = this;\n\tFs.readFile(F.path.temp((F.id ? 'i-' + F.id + '_' : '') + 'framework_cachepersist.jsoncache'), function(err, data) {\n\t\tif (!err) {\n\t\t\ttry {\n\t\t\t\tdata = JSON.parse(data.toString('utf8'), (key, value) => typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value);\n\t\t\t\tvar keys = Object.keys(data);\n\t\t\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\tvar item = data[key];\n\t\t\t\t\tif (item.expire >= NOW)\n\t\t\t\t\t\tself.items[key] = item;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t\tcallback && callback();\n\t});\n\treturn self;\n};\n\nFrameworkCacheProto.stop = function() {\n\tclearInterval(this.interval);\n\treturn this;\n};\n\nFrameworkCacheProto.clear = function() {\n\tthis.items = {};\n\tF.isCluster && CONF.allow_cache_cluster && process.send(CLUSTER_CACHE_CLEAR);\n\tthis.savepersistent();\n\treturn this;\n};\n\nFrameworkCacheProto.recycle = function() {\n\n\tvar items = this.items;\n\tvar persistent = false;\n\n\tNOW = new Date();\n\tthis.count++;\n\n\tfor (var o in items) {\n\t\tvar value = items[o];\n\t\tif (!value)\n\t\t\tdelete items[o];\n\t\telse if (value.expire < NOW) {\n\t\t\tif (value.persist)\n\t\t\t\tpersistent = true;\n\t\t\tF.$events['cache-expire'] && EMIT('cache-expire', o, value.value);\n\t\t\tF.$events.cache_expired && EMIT('cache_expired', o, value.value);\n\t\t\tdelete items[o];\n\t\t}\n\t}\n\n\tpersistent && this.savepersistent();\n\tCONF.allow_cache_snapshot && this.save();\n\tF.service(this.count);\n\tCONF.allow_stats_snapshot && F.snapshotstats && F.snapshotstats();\n\tF.temporary.service.usage = 0;\n\tmeasure_usage();\n\treturn this;\n};\n\nFrameworkCacheProto.set2 = function(name, value, expire) {\n\treturn this.set(name, value, expire, true);\n};\n\nFrameworkCacheProto.set = FrameworkCacheProto.add = function(name, value, expire, persist) {\n\n\tif (F.isCluster && CONF.allow_cache_cluster && this.$sync) {\n\t\tCLUSTER_CACHE_SET.name = name;\n\t\tCLUSTER_CACHE_SET.value = value;\n\t\tCLUSTER_CACHE_SET.expire = expire;\n\t\tprocess.send(CLUSTER_CACHE_SET);\n\t}\n\n\tswitch (typeof(expire)) {\n\t\tcase 'string':\n\t\t\texpire = expire.parseDateExpiration();\n\t\t\tbreak;\n\t\tcase 'undefined':\n\t\t\texpire = NOW.add('m', 5);\n\t\t\tbreak;\n\t}\n\n\tvar obj = { value: value, expire: expire };\n\n\tif (persist) {\n\t\tobj.persist = true;\n\t\tthis.savepersistent();\n\t}\n\n\tthis.items[name] = obj;\n\tF.$events['cache-set'] && EMIT('cache-set', name, value, expire, this.$sync);\n\tF.$events.cache_set && EMIT('cache_set', name, value, expire, this.$sync);\n\treturn value;\n};\n\nFrameworkCacheProto.read = FrameworkCacheProto.get = function(key, def) {\n\n\tvar value = this.items[key];\n\tif (!value)\n\t\treturn def;\n\n\tNOW = new Date();\n\n\tif (value.expire < NOW) {\n\t\tthis.items[key] = undefined;\n\t\tF.$events['cache-expire'] && EMIT('cache-expire', key, value.value);\n\t\tF.$events.cache_expired && EMIT('cache_expired', key, value.value);\n\t\treturn def;\n\t}\n\n\treturn value.value;\n};\n\nFrameworkCacheProto.read2 = FrameworkCacheProto.get2 = function(key, def) {\n\tvar value = this.items[key];\n\n\tif (!value)\n\t\treturn def;\n\n\tif (value.expire < NOW) {\n\t\tthis.items[key] = undefined;\n\t\tF.$events['cache-expire'] && EMIT('cache-expire', key, value.value);\n\t\tF.$events.cache_expired && EMIT('cache_expired', key, value.value);\n\t\treturn def;\n\t}\n\n\treturn value.value;\n};\n\nFrameworkCacheProto.setExpire = function(name, expire) {\n\tvar obj = this.items[name];\n\tif (obj)\n\t\tobj.expire = typeof(expire) === 'string' ? expire.parseDateExpiration() : expire;\n\treturn this;\n};\n\nFrameworkCacheProto.remove = function(name) {\n\tvar value = this.items[name];\n\n\tif (value) {\n\t\tthis.items[name].persist && this.savepersistent();\n\t\tthis.items[name] = undefined;\n\t}\n\n\tif (F.isCluster && CONF.allow_cache_cluster && this.$sync) {\n\t\tCLUSTER_CACHE_REMOVE.name = name;\n\t\tprocess.send(CLUSTER_CACHE_REMOVE);\n\t}\n\n\treturn value;\n};\n\nFrameworkCacheProto.removeAll = function(search) {\n\tvar count = 0;\n\tvar isReg = typeof(search) === 'object';\n\n\tfor (var key in this.items) {\n\n\t\tif (isReg) {\n\t\t\tif (!search.test(key))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (key.indexOf(search) === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tthis.remove(key);\n\t\tcount++;\n\t}\n\n\tif (F.isCluster && CONF.allow_cache_cluster && this.$sync) {\n\t\tCLUSTER_CACHE_REMOVEALL.search = search;\n\t\tprocess.send(CLUSTER_CACHE_REMOVEALL);\n\t}\n\n\treturn count;\n};\n\nFrameworkCacheProto.fn = function(name, fnCache, fnCallback, options) {\n\n\tvar self = this;\n\tvar value = self.read2(name);\n\n\tif (value) {\n\t\tfnCallback && fnCallback(value, true, options);\n\t\treturn self;\n\t}\n\n\tfnCache(function(value, expire) {\n\t\tself.add(name, value, expire);\n\t\tfnCallback && fnCallback(value, false, options);\n\t}, options);\n\n\treturn self;\n};\n\nfunction subscribe_timeout(req) {\n\treq.controller && req.controller.precache && req.controller.precache(null, null, null);\n\treq.$total_cancel();\n}\n\nfunction subscribe_timeout_middleware(req) {\n\tif (req.$total_middleware)\n\t\treq.$total_middleware = null;\n\treq.$total_execute2();\n}\n\nfunction subscribe_validate_callback(req, code) {\n\treq.$total_execute(code);\n}\n\n/**\n * FrameworkController\n * @class\n * @param {String} name Controller name.\n * @param {Request} req\n * @param {Response} res\n * @param {FrameworkSubscribe} subscribe\n */\nfunction Controller(name, req, res, currentView) {\n\n\tthis.name = name;\n\t// this.exception;\n\n\t// Sets the default language\n\tif (req) {\n\t\tthis.language = req.$language;\n\t\tthis.req = req;\n\t\tthis.route = req.$total_route;\n\t} else\n\t\tthis.req = EMPTYREQUEST;\n\n\t// controller.type === 0 - classic\n\t// controller.type === 1 - server sent events\n\t// this.type = 0;\n\n\t// this.layoutName =CONF.default_layout;\n\t// this.themeName =CONF.default_theme;\n\t// this.status = 200;\n\n\t// this.isLayout = false;\n\t// this.isCanceled = false;\n\t// this.isTimeout = false;\n\t// this.isTransfer = false;\n\n\tthis.isConnected = true;\n\tthis.isController = true;\n\n\t// render output\n\t// this.output = null;\n\t// this.outputPartial = null;\n\t// this.$model = null;\n\n\tthis._currentView = currentView;\n\n\tif (res) {\n\t\tthis.res = res;\n\t\tthis.req.controller = this.res.controller = this;\n\t} else\n\t\tthis.res = EMPTYOBJECT;\n}\n\nController.prototype = {\n\n\tget breadcrumb() {\n\t\treturn this.repository[REPOSITORY_SITEMAP];\n\t},\n\n\tget repository() {\n\t\tif (this.$repository)\n\t\t\treturn this.$repository;\n\t\telse\n\t\t\treturn this.$repository ? this.$repository : (this.$repository = {});\n\t},\n\n\tset repository(val) {\n\t\tthis.$repository = val;\n\t},\n\n\tget schema() {\n\t\treturn this.route.schema ? this.route.schema[0] === 'default' ? this.route.schema[1] : this.route.schema.join('/') : '';\n\t},\n\n\tget workflow() {\n\t\treturn this.route.schema_workflow;\n\t},\n\n\tget sseID() {\n\t\treturn this.req.headers['last-event-id'] || null;\n\t},\n\n\tget options() {\n\t\treturn this.route.options;\n\t},\n\n\tget split() {\n\t\treturn this.req.split;\n\t},\n\n\tget flags() {\n\t\treturn this.route.flags;\n\t},\n\n\tget path() {\n\t\tOBSOLETE('controller.path', 'Use: PATH');\n\t\treturn F.path;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t},\n\n\tset query(val) {\n\t\tthis.req.query = val;\n\t},\n\n\tget body() {\n\t\treturn this.req.body;\n\t},\n\n\tset body(val) {\n\t\tthis.req.body = val;\n\t},\n\n\tget files() {\n\t\treturn this.req.files;\n\t},\n\n\tget subdomain() {\n\t\treturn this.req.subdomain;\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget xhr() {\n\t\treturn this.req.xhr;\n\t},\n\n\tset xhr(val) {\n\t\tthis.req.xhr = val;\n\t},\n\n\tget url() {\n\t\treturn U.path(this.req.uri.pathname);\n\t},\n\n\tget uri() {\n\t\treturn this.req.uri;\n\t},\n\n\tget headers() {\n\t\treturn this.req.headers;\n\t},\n\n\tget cache() {\n\t\tOBSOLETE('controller.cache', 'Use: F.cache or CACHE()');\n\t\treturn F.cache;\n\t},\n\n\tget config() {\n\t\tOBSOLETE('controller.config', 'Use: CONF');\n\t\treturn CONF;\n\t},\n\n\tget controllers() {\n\t\tOBSOLETE('controller.controllers', 'This property will be removed in v4.');\n\t\treturn F.controllers;\n\t},\n\n\tget isTest() {\n\t\tOBSOLETE('controller.isTest', 'Use: F.isTest');\n\t\treturn this.req.headers['x-assertion-testing'] === '1';\n\t},\n\n\tget isSecure() {\n\t\tOBSOLETE('controller.isSecure', 'Use: controller.secured');\n\t\treturn this.req.isSecure;\n\t},\n\n\tget secured() {\n\t\treturn this.req.secured;\n\t},\n\n\tget session() {\n\t\treturn this.req.session;\n\t},\n\n\tset session(value) {\n\t\tthis.req.session = value;\n\t},\n\n\tget user() {\n\t\treturn this.req.user;\n\t},\n\n\tget referrer() {\n\t\treturn this.req.headers['referer'] || '';\n\t},\n\n\tset user(value) {\n\t\tthis.req.user = value;\n\t},\n\n\tget mobile() {\n\t\treturn this.req.mobile;\n\t},\n\n\tset mobile(val) {\n\t\tthis.req.mobile = val;\n\t},\n\n\tget robot() {\n\t\treturn this.req.robot;\n\t},\n\n\tget sessionid() {\n\t\treturn this.req.sessionid;\n\t},\n\n\tset sessionid(val) {\n\t\tthis.req.sessionid = val;\n\t},\n\n\tget viewname() {\n\t\tvar name = this.req.path[this.req.path.length - 1];\n\t\treturn !name || name === '/' ? 'index' : name;\n\t},\n\n\tget sitemapid() {\n\t\treturn this.$sitemapid || this.route.sitemap;\n\t},\n\n\tget params() {\n\t\tif (this.$params)\n\t\t\treturn this.$params;\n\t\tvar route = this.route;\n\t\tvar names = route.paramnames;\n\t\tif (names) {\n\t\t\tvar obj = {};\n\t\t\tfor (var i = 0; i < names.length; i++)\n\t\t\t\tobj[names[i]] = this.req.split[route.param[i]];\n\t\t\tthis.$params = obj;\n\t\t\treturn obj;\n\t\t} else {\n\t\t\t// Because in some cases are overwritten\n\t\t\treturn this.$params = {};\n\t\t}\n\t},\n\n\tset params(val) {\n\t\tthis.$params = val;\n\t},\n\n\tget ua() {\n\t\treturn this.req ? this.req.ua : null;\n\t}\n};\n\n// ======================================================\n// PROTOTYPES\n// ======================================================\n\nconst ControllerProto = Controller.prototype;\n\nControllerProto.$get = ControllerProto.$read = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tthis.getSchema().get(helper, callback, this);\n\treturn this;\n};\n\nControllerProto.$query = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tthis.getSchema().query(helper, callback, this);\n\treturn this;\n};\n\nControllerProto.$save = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$save(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$save(helper, callback);\n\t}\n\treturn self;\n};\n\nControllerProto.$insert = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$insert(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$insert(helper, callback);\n\t}\n\treturn self;\n};\n\nControllerProto.$update = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$update(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$update(helper, callback);\n\t}\n\treturn self;\n};\n\nControllerProto.$patch = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$patch(helper, callback);\n\t} else {\n\t\tvar model = self.getSchema().default();\n\t\tmodel.$$controller = self;\n\t\tmodel.$patch(helper, callback);\n\t}\n\treturn self;\n};\n\nControllerProto.$remove = function(helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tself.getSchema().remove(helper, callback, self);\n\treturn this;\n};\n\nControllerProto.$workflow = function(name, helper, callback) {\n\tvar self = this;\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$workflow(name, helper, callback);\n\t} else\n\t\tself.getSchema().workflow2(name, helper, callback, self);\n\treturn self;\n};\n\nControllerProto.$workflow2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = null;\n\t}\n\n\tvar self = this;\n\tself.getSchema().workflow2(name, helper, callback, self);\n\treturn self;\n};\n\nControllerProto.$hook = function(name, helper, callback) {\n\tvar self = this;\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$hook(name, helper, callback);\n\t} else\n\t\tself.getSchema().hook2(name, helper, callback, self);\n\n\treturn self;\n};\n\nControllerProto.$hook2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tself.getSchema().hook2(name, helper, callback, self);\n\treturn self;\n};\n\nControllerProto.$transform = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$transform(name, helper, callback);\n\t} else\n\t\tself.getSchema().transform2(name, helper, callback, self);\n\treturn self;\n};\n\nControllerProto.$transform2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tself.getSchema().transform2(name, helper, callback, self);\n\treturn self;\n};\n\nControllerProto.$operation = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$operation(name, helper, callback);\n\t} else\n\t\tself.getSchema().operation2(name, helper, callback, self);\n\treturn self;\n};\n\nControllerProto.operation = function(name, value, callback, options) {\n\tOPERATION(name, value, callback, options, this);\n\treturn this;\n};\n\nControllerProto.tasks = function() {\n\tvar tb = new TaskBuilder(this);\n\t// tb.callback(this.callback());\n\treturn tb;\n};\n\nControllerProto.$operation2 = function(name, helper, callback) {\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tvar self = this;\n\tself.getSchema().operation2(name, helper, callback, self);\n\treturn self;\n};\n\nControllerProto.$exec = function(name, helper, callback) {\n\tvar self = this;\n\n\tif (callback == null && typeof(helper) === 'function') {\n\t\tcallback = helper;\n\t\thelper = EMPTYOBJECT;\n\t}\n\n\tif (callback == null)\n\t\tcallback = self.callback();\n\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\tself.body.$exec(name, helper, callback);\n\t\treturn self;\n\t}\n\n\tvar tmp = self.getSchema().create();\n\ttmp.$$controller = self;\n\ttmp.$exec(name, helper, callback);\n\treturn self;\n};\n\nControllerProto.$async = function(callback, index) {\n\tvar self = this;\n\n\tif (self.body && self.body.$$schema) {\n\t\tself.body.$$controller = self;\n\t\treturn self.body.$async(callback, index);\n\t}\n\n\tvar model = self.getSchema().default();\n\tmodel.$$controller = self;\n\treturn model.$async(callback, index);\n};\n\nControllerProto.getSchema = function() {\n\tvar route = this.route;\n\tif (!route.schema || !route.schema[1])\n\t\tthrow new Error('The controller\\'s route does not define any schema.');\n\tvar schema = route.isDYNAMICSCHEMA ? framework_builders.findschema(route.schema[0] + '/' + this.params[route.schema[1]]) : GETSCHEMA(route.schema[0], route.schema[1]);\n\tif (schema)\n\t\treturn schema;\n\tthrow new Error('Schema \"{0}\" does not exist.'.format(route.schema[1]));\n};\n\n/**\n * Renders component\n * @param {String} name A component name\n * @param {Object} settings Optional, settings.\n * @model {Object} settings Optional, model for the component.\n * @return {String}\n */\nControllerProto.component = function(name, settings, model) {\n\tvar filename = F.components.views[name];\n\tif (filename) {\n\t\tvar self = this;\n\t\tvar generator = framework_internal.viewEngine(name, filename, self, true);\n\t\tif (generator) {\n\t\t\tif (generator.components.length) {\n\t\t\t\tif (!self.repository[REPOSITORY_COMPONENTS])\n\t\t\t\t\tself.repository[REPOSITORY_COMPONENTS] = {};\n\t\t\t\tfor (var i = 0; i < generator.components.length; i++)\n\t\t\t\t\tself.repository[REPOSITORY_COMPONENTS][generator.components[i]] = 1;\n\t\t\t}\n\t\t\treturn generator.call(self, self, self.repository, model || self.$model, self.session, self.query, self.body, self.url, F.global, F.helpers, self.user, CONF, F.functions, 0, self.outputPartial, self.req.files, self.req.mobile, settings || EMPTYOBJECT);\n\t\t}\n\t}\n\treturn '';\n};\n\nControllerProto.$components = function(group, settings) {\n\n\tif (group) {\n\t\tvar keys = Object.keys(F.components.instances);\n\t\tvar output = [];\n\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\tvar component = F.components.instances[keys[i]];\n\t\t\tif (component.group === group) {\n\t\t\t\tif (component.render) {\n\t\t\t\t\t!this.$viewasync && (this.$viewasync = []);\n\t\t\t\t\t$VIEWASYNC++;\n\t\t\t\t\tvar name = '@{-' + $VIEWASYNC + '-}';\n\t\t\t\t\tthis.$viewasync.push({ replace: name, name: component.name, settings: settings });\n\t\t\t\t\toutput.push(name);\n\t\t\t\t} else {\n\t\t\t\t\tvar tmp = this.component(keys[i], settings);\n\t\t\t\t\ttmp && output.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn output.join('\\n');\n\t}\n\n\treturn '';\n};\n\n/**\n * Reads / Writes cookie\n * @param {String} name\n * @param {String} value\n * @param {String/Date} expires\n * @param {Object} options\n * @return {String/Controller}\n */\nControllerProto.cookie = function(name, value, expires, options) {\n\tvar self = this;\n\tif (value === undefined)\n\t\treturn self.req.cookie(name);\n\tself.res.cookie(name, value, expires, options);\n\treturn self;\n};\n\n/**\n * Clears uploaded files\n * @return {Controller}\n */\nControllerProto.clear = function() {\n\tvar self = this;\n\tself.req.clear();\n\treturn self;\n};\n\n/**\n * Translates text\n * @param {String} text\n * @return {String}\n */\nControllerProto.translate = function(language, text) {\n\n\tif (!text) {\n\t\ttext = language;\n\t\tlanguage = this.language;\n\t}\n\n\treturn F.translate(language, text);\n};\n\n/**\n * Exec middleware\n * @param {String Array} names Middleware name.\n * @param {Object} options Custom options for middleware.\n * @param {Function} callback\n * @return {Controller}\n */\nControllerProto.middleware = function(names, options, callback) {\n\n\tif (typeof(names) === 'string')\n\t\tnames = [names];\n\n\tif (typeof(options) === 'function') {\n\t\tvar tmp = callback;\n\t\tcallback = options;\n\t\toptions = tmp;\n\t}\n\n\tif (!options)\n\t\toptions = EMPTYOBJECT;\n\n\tvar self = this;\n\n\tif (self.req.$total_middleware)\n\t\tself.req.$total_middleware = null;\n\n\tasync_middleware(0, self.req, self.res, names, () => callback && callback(), options, self);\n\treturn self;\n};\n\nControllerProto.nocache = function() {\n\tthis.req.nocache();\n\treturn this;\n};\n\n/**\n * Creates a pipe between the current request and target URL\n * @param {String} url\n * @param {Object} headers Optional, custom headers.\n * @param {Function(err)} callback Optional.\n * @return {Controller}\n */\nControllerProto.pipe = function(url, headers, callback) {\n\tthis.res.proxy(url, headers, null, callback);\n\treturn this;\n};\n\nControllerProto.encrypt = function() {\n\treturn F.encrypt.apply(framework, arguments);\n};\n\nControllerProto.decrypt = function() {\n\treturn F.decrypt.apply(framework, arguments);\n};\n\n/**\n * Creates a hash (alias for F.hash())\n * @return {Controller}\n */\nControllerProto.hash = function() {\n\tOBSOLETE('controller.hash()', 'Use String.prototype.hash()');\n\treturn F.hash.apply(framework, arguments);\n};\n\n/**\n * Sets a response header\n * @param {String} name\n * @param {String} value\n * @return {Controller}\n */\nControllerProto.header = function(name, value) {\n\tthis.res.setHeader(name, value);\n\treturn this;\n};\n\n/**\n * Gets a hostname\n * @param {String} path\n * @return {Controller}\n */\nControllerProto.host = function(path) {\n\treturn this.req.hostname(path);\n};\n\nControllerProto.hostname = function(path) {\n\treturn this.req.hostname(path);\n};\n\nControllerProto.resource = function(name, key) {\n\treturn F.resource(name, key);\n};\n\n/**\n * Error caller\n * @param {Error/String} err\n * @return {Controller/Function}\n */\nControllerProto.error = function(err) {\n\tvar self = this;\n\n\t// Custom errors\n\tif (err instanceof ErrorBuilder) {\n\t\tself.content(err);\n\t\treturn self;\n\t}\n\n\tvar result = F.error(typeof(err) === 'string' ? new Error(err) : err, self.name, self.uri);\n\tif (err === undefined)\n\t\treturn result;\n\n\tself.req.$total_exception = err;\n\tself.exception = err;\n\treturn self;\n};\n\nControllerProto.invalid = function(status) {\n\n\tvar self = this;\n\n\tif (status instanceof ErrorBuilder) {\n\t\tsetImmediate(next_controller_invalid, self, status);\n\t\treturn status;\n\t}\n\n\tvar type = typeof(status);\n\n\tif (type === 'number')\n\t\tself.status = status;\n\n\tvar builder = new ErrorBuilder();\n\n\tif (type === 'string')\n\t\tbuilder.push(status);\n\telse if (status instanceof Error)\n\t\tbuilder.push(status);\n\n\tsetImmediate(next_controller_invalid, self, builder);\n\treturn builder;\n};\n\nfunction next_controller_invalid(self, builder) {\n\tself.content(builder);\n}\n\n/**\n * Registers a new problem\n * @param {String} message\n * @return {Controller}\n */\nControllerProto.wtf = ControllerProto.problem = function(message) {\n\tF.problem(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * Registers a new change\n * @param {String} message\n * @return {Controller}\n */\nControllerProto.change = function(message) {\n\tF.change(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * Trace\n * @param {String} message\n * @return {Controller}\n */\nControllerProto.trace = function(message) {\n\tF.trace(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * Transfer to new route\n * @param {String} url Relative URL.\n * @param {String Array} flags Route flags (optional).\n * @return {Boolean}\n */\nControllerProto.transfer = function(url, flags) {\n\n\tvar self = this;\n\tvar length = F.routes.web.length;\n\tvar path = framework_internal.routeSplit(url.trim());\n\n\tvar isSystem = url[0] === '#';\n\tvar noFlag = !flags || flags.length === 0 ? true : false;\n\tvar selected = null;\n\n\tself.req.$isAuthorized = true;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar route = F.routes.web[i];\n\n\t\tif (route.isWILDCARD) {\n\t\t\tif (!framework_internal.routeCompare(path, route.url, isSystem, true))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!framework_internal.routeCompare(path, route.url, isSystem))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (noFlag) {\n\t\t\tselected = route;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (route.flags && route.flags.length) {\n\t\t\tvar result = framework_internal.routeCompareFlags(route.flags, flags, true);\n\t\t\tif (result === -1)\n\t\t\t\tself.req.$isAuthorized = false;\n\t\t\tif (result < 1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tselected = route;\n\t\tbreak;\n\t}\n\n\tif (!selected)\n\t\treturn false;\n\n\tself.cancel();\n\tself.req.path = EMPTYARRAY;\n\tself.req.$total_transfer = true;\n\tself.req.$total_success();\n\n\t// Because of dynamic params\n\t// Hidden variable\n\tself.req.$path = framework_internal.routeSplit(url, true);\n\n\tself.route = self.req.$total_route = selected;\n\tself.req.$total_execute(404);\n\treturn true;\n};\n\nControllerProto.cancel = function() {\n\tthis.isCanceled = true;\n\treturn this;\n};\n\nControllerProto.log = function() {\n\tF.log.apply(F, arguments);\n\treturn this;\n};\n\nControllerProto.logger = function() {\n\tF.logger.apply(F, arguments);\n\treturn this;\n};\n\nControllerProto.meta = function() {\n\tvar self = this;\n\n\tif (arguments[0])\n\t\tself.repository[REPOSITORY_META_TITLE] = arguments[0].encode();\n\n\tif (arguments[1])\n\t\tself.repository[REPOSITORY_META_DESCRIPTION] = arguments[1].encode();\n\n\tif (arguments[2] && arguments[2].length)\n\t\tself.repository[REPOSITORY_META_KEYWORDS] = (arguments[2] instanceof Array ? arguments[2].join(', ') : arguments[2]);\n\n\tif (arguments[3])\n\t\tself.repository[REPOSITORY_META_IMAGE] = arguments[3];\n\n\treturn self;\n};\n\nControllerProto.$dns = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder += '<link rel=\"dns-prefetch\" href=\"' + this._preparehostname(arguments[i]) + '\" />';\n\n\tthis.head(builder);\n\treturn '';\n};\n\nControllerProto.$prefetch = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder += '<link rel=\"prefetch\" href=\"' + this._preparehostname(arguments[i]) + '\" />';\n\n\tthis.head(builder);\n\treturn '';\n};\n\nControllerProto.$prerender = function() {\n\n\tvar builder = '';\n\tvar length = arguments.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tbuilder += '<link rel=\"prerender\" href=\"' + this._preparehostname(arguments[i]) + '\" />';\n\n\tthis.head(builder);\n\treturn '';\n};\n\nControllerProto.$next = function(value) {\n\tthis.head('<link rel=\"next\" href=\"' + this._preparehostname(value) + '\" />');\n\treturn '';\n};\n\nControllerProto.$prev = function(value) {\n\tthis.head('<link rel=\"prev\" href=\"' + this._preparehostname(value) + '\" />');\n\treturn '';\n};\n\nControllerProto.$canonical = function(value) {\n\tthis.head('<link rel=\"canonical\" href=\"' + this._preparehostname(value) + '\" />');\n\treturn '';\n};\n\nControllerProto.$meta = function() {\n\tvar self = this;\n\n\tif (arguments.length) {\n\t\tself.meta.apply(self, arguments);\n\t\treturn '';\n\t}\n\n\tF.$events['controller-render-meta'] && EMIT('controller-render-meta', self);\n\tF.$events.controller_render_meta && EMIT('controller_render_meta', self);\n\tvar repository = self.repository;\n\treturn F.onMeta.call(self, repository[REPOSITORY_META_TITLE], repository[REPOSITORY_META_DESCRIPTION], repository[REPOSITORY_META_KEYWORDS], repository[REPOSITORY_META_IMAGE]);\n};\n\nControllerProto.title = function(value) {\n\tthis.$title(value);\n\treturn this;\n};\n\nControllerProto.description = function(value) {\n\tthis.$description(value);\n\treturn this;\n};\n\nControllerProto.keywords = function(value) {\n\tthis.$keywords(value);\n\treturn this;\n};\n\nControllerProto.author = function(value) {\n\tthis.$author(value);\n\treturn this;\n};\n\nControllerProto.$title = function(value) {\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_TITLE] = value.encode();\n\treturn '';\n};\n\nControllerProto.$title2 = function(value) {\n\tvar current = this.repository[REPOSITORY_META_TITLE];\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_TITLE] = (current ? current : '') + value.encode();\n\treturn '';\n};\n\nControllerProto.$description = function(value) {\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_DESCRIPTION] = value.encode();\n\treturn '';\n};\n\nControllerProto.$keywords = function(value) {\n\tif (value && value.length)\n\t\tthis.repository[REPOSITORY_META_KEYWORDS] = (value instanceof Array ? value.join(', ') : value).encode();\n\treturn '';\n};\n\nControllerProto.$author = function(value) {\n\tif (value)\n\t\tthis.repository[REPOSITORY_META_AUTHOR] = value.encode();\n\treturn '';\n};\n\nControllerProto.sitemap_navigation = function(name, language) {\n\treturn F.sitemap_navigation(name || this.sitemapid, language || this.language);\n};\n\nControllerProto.sitemap_url = function(name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, this.language);\n\treturn item ? item.url.format(a, b, c, d, e, f) : '';\n};\n\nControllerProto.sitemap_name = function(name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, this.language);\n\treturn item ? item.name.format(a, b, c, d, e, f) : '';\n};\n\nControllerProto.sitemap_url2 = function(language, name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, language);\n\treturn item ? item.url.format(a, b, c, d, e, f) : '';\n};\n\nControllerProto.sitemap_name2 = function(language, name, a, b, c, d, e, f) {\n\tvar item = F.sitemap(name || this.sitemapid, true, language);\n\treturn item ? item.name.format(a, b, c, d, e, f) : '';\n};\n\nControllerProto.sitemap_add = function(parent, name, url) {\n\n\tvar self = this;\n\tvar sitemap = self.repository[REPOSITORY_SITEMAP];\n\n\tif (!sitemap) {\n\t\tsitemap = self.sitemap(self.sitemapid || name);\n\t\tif (!sitemap)\n\t\t\treturn EMPTYARRAY;\n\t}\n\n\tvar index = sitemap.findIndex('id', parent);\n\tif (index === -1)\n\t\treturn sitemap;\n\n\tvar obj = { sitemap: '', id: '', name: name, url: url, last: false, first: false, index: index, wildcard: false, formatName: false, formatUrl: false, localizeName: false, localizeUrl: false };\n\n\tsitemap.splice(index + 1, 0, obj);\n\n\tif (index) {\n\t\tvar tmp = index;\n\t\tfor (var i = index + 1; i > -1; i--)\n\t\t\tsitemap[i].index = tmp++;\n\t}\n\n\treturn sitemap;\n};\n\nControllerProto.sitemap_change = function(name, type, a, b, c, d, e, f) {\n\n\tvar self = this;\n\tvar sitemap = self.repository[REPOSITORY_SITEMAP];\n\n\tif (!sitemap) {\n\t\tsitemap = self.sitemap(self.sitemapid || name);\n\t\tif (!sitemap)\n\t\t\treturn EMPTYARRAY;\n\t}\n\n\tif (!sitemap.$cloned) {\n\t\tsitemap = U.clone(sitemap);\n\t\tsitemap.$cloned = true;\n\t\tself.repository[REPOSITORY_SITEMAP] = sitemap;\n\t}\n\n\tvar isFn = typeof(a) === 'function';\n\n\tfor (var i = 0, length = sitemap.length; i < length; i++) {\n\n\t\tvar item = sitemap[i];\n\t\tif (item.id !== name)\n\t\t\tcontinue;\n\n\t\tvar tmp = item[type];\n\n\t\tif (isFn)\n\t\t\titem[type] = a(item[type]);\n\t\telse if (type === 'name')\n\t\t\titem[type] = item.formatName ? item[type].format(a, b, c, d, e, f) : a;\n\t\telse if (type === 'url')\n\t\t\titem[type] = item.formatUrl ? item[type].format(a, b, c, d, e, f) : a;\n\t\telse\n\t\t\titem[type] = a;\n\n\t\tif (type === 'name' && self.repository[REPOSITORY_META_TITLE] === tmp)\n\t\t\tself.repository[REPOSITORY_META_TITLE] = item[type];\n\n\t\treturn sitemap;\n\t}\n\n\treturn sitemap;\n};\n\nControllerProto.sitemap_replace = function(name, title, url) {\n\n\tvar self = this;\n\tvar sitemap = self.repository[REPOSITORY_SITEMAP];\n\n\tif (!sitemap) {\n\t\tsitemap = self.sitemap(self.sitemapid || name);\n\t\tif (!sitemap)\n\t\t\treturn EMPTYARRAY;\n\t}\n\n\tif (!sitemap.$cloned) {\n\t\tsitemap = U.clone(sitemap);\n\t\tsitemap.$cloned = true;\n\t\tself.repository[REPOSITORY_SITEMAP] = sitemap;\n\t}\n\n\tfor (var i = 0, length = sitemap.length; i < length; i++) {\n\t\tvar item = sitemap[i];\n\t\tif (item.id !== name)\n\t\t\tcontinue;\n\n\t\tvar is = self.repository[REPOSITORY_META_TITLE] === item.name;\n\n\t\tif (title)\n\t\t\titem.name = typeof(title) === 'function' ? title(item.name) : item.formatName ? item.name.format(title) : title;\n\n\t\tif (url)\n\t\t\titem.url = typeof(url) === 'function' ? url(item.url) : item.formatUrl ? item.url.format(url) : url;\n\n\t\tif (is)\n\t\t\tself.repository[REPOSITORY_META_TITLE] = item.name;\n\n\t\treturn sitemap;\n\t}\n\n\treturn sitemap;\n};\n\n// Arguments: parent, name, url\nControllerProto.$sitemap_add = function(parent, name, url) {\n\tthis.sitemap_add(parent, name, url);\n\treturn '';\n};\n\n// Arguments: name, type, value, format\nControllerProto.$sitemap_change = function(a, b, c, d, e, f, g, h) {\n\tthis.sitemap_change(a, b, c, d, e, f, g, h);\n\treturn '';\n};\n\n// Arguments: name, title, url\nControllerProto.$sitemap_replace =function(a, b, c) {\n\tthis.sitemap_replace(a, b, c);\n\treturn '';\n};\n\nControllerProto.sitemap = function(name) {\n\tvar self = this;\n\tvar sitemap;\n\n\tif (!name) {\n\t\tsitemap = self.repository[REPOSITORY_SITEMAP];\n\t\tif (!sitemap && (self.$sitemapid || self.route.sitemap))\n\t\t\treturn self.sitemap(self.$sitemapid || self.route.sitemap);\n\t\treturn sitemap ? sitemap : self.repository.sitemap || EMPTYARRAY;\n\t}\n\n\tif (name instanceof Array) {\n\t\tself.repository[REPOSITORY_SITEMAP] = name;\n\t\treturn self;\n\t}\n\n\tself.$sitemapid = name;\n\tsitemap = U.clone(F.sitemap(name, false, self.language));\n\tsitemap.$cloned = true;\n\n\tself.repository[REPOSITORY_SITEMAP] = sitemap;\n\n\tif (!self.repository[REPOSITORY_META_TITLE]) {\n\t\tsitemap = sitemap[sitemap.length - 1];\n\t\tif (sitemap)\n\t\t\tself.repository[REPOSITORY_META_TITLE] = sitemap.name;\n\t}\n\n\treturn self.repository[REPOSITORY_SITEMAP];\n};\n\n// Arguments: name\nControllerProto.$sitemap = function(name) {\n\tvar self = this;\n\tself.sitemap(name);\n\treturn '';\n};\n\nControllerProto.module = function(name) {\n\treturn F.module(name);\n};\n\nControllerProto.layout = function(name) {\n\tvar self = this;\n\tself.layoutName = name;\n\treturn self;\n};\n\nControllerProto.theme = function(name) {\n\tvar self = this;\n\tself.themeName = name;\n\treturn self;\n};\n\n/**\n * Layout setter for views\n * @param {String} name Layout name\n * @return {String}\n */\nControllerProto.$layout = function(name) {\n\tvar self = this;\n\tself.layoutName = name;\n\treturn '';\n};\n\nControllerProto.model = function(name) {\n\treturn F.model(name);\n};\n\n/**\n * Send e-mail\n * @param {String or Array} address E-mail address.\n * @param {String} subject E-mail subject.\n * @param {String} view View name.\n * @param {Object} model Optional.\n * @param {Function(err)} callback Optional.\n * @return {MailMessage}\n */\nControllerProto.mail = function(address, subject, view, model, callback) {\n\n\tif (typeof(model) === 'function') {\n\t\tcallback = model;\n\t\tmodel = null;\n\t}\n\n\tvar self = this;\n\n\tif (typeof(self.language) === 'string')\n\t\tsubject = subject.indexOf('@(') === -1 ? F.translate(self.language, subject) : F.translator(self.language, subject);\n\n\t// Backup layout\n\tvar layoutName = self.layoutName;\n\tvar body = self.view(view, model, true);\n\n\tvar message;\n\n\tif (body instanceof Function) {\n\t\tmessage = F.onMail(address, subject, '');\n\t\tmessage.manually();\n\t\tbody(function(err, body) {\n\t\t\tmessage.body = body;\n\t\t\tmessage.send2(callback);\n\t\t});\n\t} else {\n\t\tmessage = F.onMail(address, subject, body, callback);\n\t\tself.layoutName = layoutName;\n\t}\n\n\treturn message;\n};\n\nControllerProto.$template = function(name, model, expire, key) {\n\tOBSOLETE('@{template()}', 'The method will be removed in v4');\n\treturn this.$viewToggle(true, name, model, expire, key);\n};\n\nControllerProto.$templateToggle = function(visible, name, model, expire, key) {\n\tOBSOLETE('@{templateToggle()}', 'The method will be removed in v4');\n\treturn this.$viewToggle(visible, name, model, expire, key);\n};\n\nControllerProto.$view = function(name, model, expire, key) {\n\n\tvar self = this;\n\tvar cache;\n\n\tif (expire) {\n\t\tcache = '$view.' + name + '.' + (key || '');\n\t\tvar output = F.cache.read2(cache);\n\t\tif (output)\n\t\t\treturn output.body;\n\t}\n\n\tvar value = self.view(name, model, null, true, true, cache);\n\tif (!value)\n\t\treturn '';\n\n\texpire && F.cache.add(cache, { components: value instanceof Function, body: value instanceof Function ? '' : value }, expire, false);\n\treturn value;\n};\n\nControllerProto.$viewCompile = function(body, model, key) {\n\tOBSOLETE('@{viewCompile()}', 'Was renamed to @{view_compile()}.');\n\treturn this.$view_compile(body, model, key);\n};\n\nControllerProto.$view_compile = function(body, model, key) {\n\tvar self = this;\n\tvar layout = self.layoutName;\n\tself.layoutName = '';\n\tvar value = self.view_compile(body, model, null, true, key);\n\tself.layoutName = layout;\n\treturn value || '';\n};\n\nControllerProto.$viewToggle = function(visible, name, model, expire, key, async) {\n\tOBSOLETE('@{viewToggle()}', 'The method will be removed in v4');\n\treturn visible ? this.$view(name, model, expire, key, async) : '';\n};\n\n/**\n * Adds a place into the places.\n * @param {String} name A place name.\n * @param {String} arg1 A content 1, optional\n * @param {String} arg2 A content 2, optional\n * @param {String} argN A content 2, optional\n * @return {String/Controller} String is returned when the method contains only `name` argument\n */\nControllerProto.place = function(name) {\n\n\tvar key = REPOSITORY_PLACE + '_' + name;\n\tvar length = arguments.length;\n\n\tif (length === 1)\n\t\treturn this.repository[key] || '';\n\n\tvar output = '';\n\tfor (var i = 1; i < length; i++) {\n\t\tvar val = arguments[i];\n\n\t\tif (val)\n\t\t\tval = val.toString();\n\t\telse\n\t\t\tval = '';\n\n\t\tswitch (U.getExtension(val)) {\n\t\t\tcase 'js':\n\t\t\tcase 'mjs':\n\t\t\t\tval = '<script src=\"' + val + '\"></script>';\n\t\t\t\tbreak;\n\t\t\tcase 'css':\n\t\t\t\tval = '<link rel=\"stylesheet\" href=\"' + val + '\" />';\n\t\t\t\tbreak;\n\t\t}\n\n\t\toutput += val;\n\t}\n\n\tthis.repository[key] = (this.repository[key] || '') + output;\n\treturn this;\n};\n\n/**\n * Adds a content into the section\n * @param {String} name A section name.\n * @param {String} value A content.\n * @param {Boolean} replace Optional, default `false` otherwise concats contents.\n * @return {String/Controller} String is returned when the method contains only `name` argument\n */\nControllerProto.section = function(name, value, replace) {\n\n\tvar key = '$section_' + name;\n\n\tif (value === undefined)\n\t\treturn this.repository[key];\n\n\tif (replace) {\n\t\tthis.repository[key] = value;\n\t\treturn this;\n\t}\n\n\tif (this.repository[key])\n\t\tthis.repository[key] += value;\n\telse\n\t\tthis.repository[key] = value;\n\n\treturn this;\n};\n\nControllerProto.$place = function() {\n\tvar self = this;\n\tif (arguments.length === 1)\n\t\treturn self.place.apply(self, arguments);\n\tself.place.apply(self, arguments);\n\treturn '';\n};\n\nControllerProto.$url = function(host) {\n\treturn host ? this.req.hostname(this.url) : this.url;\n};\n\n// Argument: name\nControllerProto.$helper = function() {\n\treturn this.helper.apply(this, arguments);\n};\n\nfunction querystring_encode(value, def, key) {\n\n\tif (value instanceof Array) {\n\t\tvar tmp = '';\n\t\tfor (var i = 1; i < value.length; i++)\n\t\t\ttmp += (tmp ? '&' : '') + key + '=' + querystring_encode(value[i], def);\n\t\treturn querystring_encode(value[0], def) + (tmp ? tmp : '');\n\t}\n\n\treturn value != null ? value instanceof Date ? encodeURIComponent(value.format()) : typeof(value) === 'string' ? encodeURIComponent(value) : (value + '') : def || '';\n}\n\n// @{href({ key1: 1, key2: 2 })}\n// @{href('key', 'value')}\nControllerProto.href = function(key, value) {\n\tvar self = this;\n\n\tif (!arguments.length) {\n\t\tvar val = Qs.stringify(self.query);\n\t\treturn val ? '?' + val : '';\n\t}\n\n\tvar type = typeof(key);\n\tvar obj;\n\n\tif (type === 'string') {\n\n\t\tvar cachekey = '$href' + key;\n\t\tvar str = self[cachekey] || '';\n\n\t\tif (!str) {\n\n\t\t\tobj = U.copy(self.query);\n\n\t\t\tfor (var i = 2; i < arguments.length; i++)\n\t\t\t\tobj[arguments[i]] = undefined;\n\n\t\t\tobj[key] = '\\0';\n\n\t\t\tfor (var k in obj) {\n\t\t\t\tvar val = obj[k];\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\tif (val instanceof Array) {\n\t\t\t\t\t\tfor (var j = 0; j < val.length; j++)\n\t\t\t\t\t\t\tstr += (str ? '&' : '') + k + '=' + (key === k ? '\\0' : querystring_encode(val[j]));\n\t\t\t\t\t} else\n\t\t\t\t\t\tstr += (str ? '&' : '') + k + '=' + (key === k ? '\\0' : querystring_encode(val));\n\t\t\t\t}\n\t\t\t}\n\t\t\tself[cachekey] = str;\n\t\t}\n\n\t\tstr = str.replace('\\0', querystring_encode(value, self.query[key], key));\n\n\t\tfor (var i = 2; i < arguments.length; i++) {\n\t\t\tvar beg = str.indexOf(arguments[i] + '=');\n\t\t\tif (beg === -1)\n\t\t\t\tcontinue;\n\t\t\tvar end = str.indexOf('&', beg);\n\t\t\tstr = str.substring(0, beg) + str.substring(end === -1 ? str.length : end + 1);\n\t\t}\n\n\t\treturn str ? '?' + str : '';\n\t}\n\n\tif (value) {\n\t\tobj = U.copy(self.query);\n\t\tU.extend(obj, value);\n\t}\n\n\tif (value != null)\n\t\tobj[key] = value;\n\n\tobj = Qs.stringify(obj);\n\n\tif (value === undefined && type === 'string')\n\t\tobj += (obj ? '&' : '') + key;\n\n\treturn self.url + (obj ? '?' + obj : '');\n};\n\nControllerProto.$checked = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'checked=\"checked\"');\n};\n\nControllerProto.$disabled = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'disabled=\"disabled\"');\n};\n\nControllerProto.$selected = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'selected=\"selected\"');\n};\n\n/**\n * Fake function for assign value\n * @private\n * @param {Object} value Value to eval.\n * return {String} Returns empty string.\n */\n// Argument: value\nControllerProto.$set = function() {\n\treturn '';\n};\n\nControllerProto.$readonly = function(bool, charBeg, charEnd) {\n\treturn this.$isValue(bool, charBeg, charEnd, 'readonly=\"readonly\"');\n};\n\nControllerProto.$header = function(name, value) {\n\tthis.header(name, value);\n\treturn '';\n};\n\nControllerProto.$text = function(model, name, attr) {\n\treturn this.$input(model, 'text', name, attr);\n};\n\nControllerProto.$password = function(model, name, attr) {\n\treturn this.$input(model, 'password', name, attr);\n};\n\nControllerProto.$hidden = function(model, name, attr) {\n\treturn this.$input(model, 'hidden', name, attr);\n};\n\nControllerProto.$radio = function(model, name, value, attr) {\n\n\tif (typeof(attr) === 'string') {\n\t\tvar label = attr;\n\t\tattr = SINGLETON('!$radio');\n\t\tattr.label = label;\n\t}\n\n\tattr.value = value;\n\treturn this.$input(model, 'radio', name, attr);\n};\n\nControllerProto.$checkbox = function(model, name, attr) {\n\n\tif (typeof(attr) === 'string') {\n\t\tvar label = attr;\n\t\tattr = SINGLETON('!$checkbox');\n\t\tattr.label = label;\n\t}\n\n\treturn this.$input(model, 'checkbox', name, attr);\n};\n\nControllerProto.$textarea = function(model, name, attr) {\n\n\tvar builder = '<textarea';\n\n\tif (typeof(attr) !== 'object')\n\t\tattr = EMPTYOBJECT;\n\n\tbuilder += ' name=\"' + name + '\" id=\"' + (attr.id || name) + ATTR_END;\n\n\tfor (var key in attr) {\n\t\tswitch (key) {\n\t\t\tcase 'name':\n\t\t\tcase 'id':\n\t\t\t\tbreak;\n\t\t\tcase 'required':\n\t\t\tcase 'disabled':\n\t\t\tcase 'readonly':\n\t\t\tcase 'value':\n\t\t\t\tbuilder += ' ' + key + '=\"' + key + ATTR_END;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilder += ' ' + key + '=\"' + attr[key].toString().encode() + ATTR_END;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (model === undefined)\n\t\treturn builder + '></textarea>';\n\n\treturn builder + '>' + ((model[name] || attr.value) || '') + '</textarea>';\n};\n\nControllerProto.$input = function(model, type, name, attr) {\n\n\tvar builder = ['<input'];\n\n\tif (typeof(attr) !== 'object')\n\t\tattr = EMPTYOBJECT;\n\n\tvar val = attr.value || '';\n\n\tbuilder += ' type=\"' + type + ATTR_END;\n\n\tif (type === 'radio')\n\t\tbuilder += ' name=\"' + name + ATTR_END;\n\telse\n\t\tbuilder += ' name=\"' + name + '\" id=\"' + (attr.id || name) + ATTR_END;\n\n\tif (attr.autocomplete) {\n\t\tif (attr.autocomplete === true || attr.autocomplete === 'on')\n\t\t\tbuilder += ' autocomplete=\"on\"';\n\t\telse\n\t\t\tbuilder += ' autocomplete=\"off\"';\n\t}\n\n\tfor (var key in attr) {\n\t\tswitch (key) {\n\t\t\tcase 'name':\n\t\t\tcase 'id':\n\t\t\tcase 'type':\n\t\t\tcase 'autocomplete':\n\t\t\tcase 'checked':\n\t\t\tcase 'value':\n\t\t\tcase 'label':\n\t\t\t\tbreak;\n\t\t\tcase 'required':\n\t\t\tcase 'disabled':\n\t\t\tcase 'readonly':\n\t\t\tcase 'autofocus':\n\t\t\t\tbuilder += ' ' + key + '=\"' + key + ATTR_END;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilder += ' ' + key + '=\"' + attr[key].toString().encode() + ATTR_END;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar value = '';\n\n\tif (model !== undefined) {\n\t\tvalue = model[name];\n\n\t\tif (type === 'checkbox') {\n\t\t\tif (value == '1' || value === 'true' || value === true || value === 'on')\n\t\t\t\tbuilder += ' checked=\"checked\"';\n\t\t\tvalue = val || '1';\n\t\t}\n\n\t\tif (type === 'radio') {\n\n\t\t\tval = (val || '').toString();\n\n\t\t\tif (value.toString() === val)\n\t\t\t\tbuilder += ' checked=\"checked\"';\n\n\t\t\tvalue = val || '';\n\t\t}\n\t}\n\n\tif (value === undefined)\n\t\tbuilder += ' value=\"' + (attr.value || '').toString().encode() + ATTR_END;\n\telse\n\t\tbuilder += ' value=\"' + (value || '').toString().encode() + ATTR_END;\n\n\tbuilder += ' />';\n\treturn attr.label ? ('<label>' + builder + ' <span>' + attr.label + '</span></label>') : builder;\n};\n\nControllerProto._preparehostname = function(value) {\n\tif (!value)\n\t\treturn value;\n\tvar tmp = value.substring(0, 5);\n\treturn tmp !== 'http:' && tmp !== 'https' && (tmp[0] !== '/' || tmp[1] !== '/') ? this.host(value) : value;\n};\n\nControllerProto.head = function() {\n\n\tvar self = this;\n\n\tif (!arguments.length) {\n\t\tvar author = self.repository[REPOSITORY_META_AUTHOR] || CONF.author;\n\t\tvar plus = '';\n\t\tvar components = self.repository[REPOSITORY_COMPONENTS];\n\t\tif (components) {\n\t\t\tvar keys = Object.keys(components);\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar com = F.components.groups[keys[i]];\n\t\t\t\tif (com)\n\t\t\t\t\tplus += com.links;\n\t\t\t}\n\t\t\t// Cleans cache\n\t\t\tself.repository[REPOSITORY_COMPONENTS] = null;\n\t\t}\n\t\treturn (author ? '<meta name=\"author\" content=\"' + author + '\" />' : '') + (self.repository[REPOSITORY_HEAD] || '') + plus;\n\t}\n\n\tvar header = (self.repository[REPOSITORY_HEAD] || '');\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\n\t\tvar val = arguments[i];\n\t\tvar key = '$head-' + val;\n\n\t\tif (self.repository[key])\n\t\t\tcontinue;\n\n\t\tself.repository[key] = true;\n\n\t\tif (val[0] === '<') {\n\t\t\theader += val;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar tmp = val.substring(0, 7);\n\t\tvar is = (tmp[0] !== '/' && tmp[1] !== '/') && tmp !== 'http://' && tmp !== 'https:/';\n\t\tvar ext = U.getExtension(val);\n\t\tif (ext === 'css')\n\t\t\theader += '<link type=\"text/css\" rel=\"stylesheet\" href=\"' + (is ? self.public_css(val) : val) + '\" />';\n\t\telse if (JSFILES[ext])\n\t\t\theader += '<script src=\"' + (is ? self.public_js(val) : val) + '\"></script>';\n\t}\n\n\tself.repository[REPOSITORY_HEAD] = header;\n\treturn self;\n};\n\nControllerProto.$head = function() {\n\tthis.head.apply(this, arguments);\n\treturn '';\n};\n\nControllerProto.$isValue = function(bool, charBeg, charEnd, value) {\n\tif (!bool)\n\t\treturn '';\n\tcharBeg = charBeg || ' ';\n\tcharEnd = charEnd || '';\n\treturn charBeg + value + charEnd;\n};\n\nControllerProto.$options = function(arr, selected, name, value, disabled) {\n\n\tvar type = typeof(arr);\n\tif (!arr)\n\t\treturn '';\n\n\tvar isObject = false;\n\tvar tmp = null;\n\n\tif (!(arr instanceof Array) && type === 'object') {\n\t\tisObject = true;\n\t\ttmp = arr;\n\t\tarr = Object.keys(arr);\n\t}\n\n\tif (!(arr instanceof Array))\n\t\tarr = [arr];\n\n\tselected = selected || '';\n\n\tvar options = '';\n\n\tif (!isObject) {\n\t\tif (value == null)\n\t\t\tvalue = value || name || 'value';\n\t\tif (name == null)\n\t\t\tname = 'name';\n\t\tif (disabled == null)\n\t\t\tdisabled = 'disabled';\n\t}\n\n\tvar isSelected = false;\n\tvar length = 0;\n\n\tlength = arr.length;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar o = arr[i];\n\t\tvar type = typeof(o);\n\t\tvar text = '';\n\t\tvar val = '';\n\t\tvar sel = false;\n\t\tvar dis = false;\n\n\t\tif (isObject) {\n\t\t\tif (name === true) {\n\t\t\t\tval = tmp[o];\n\t\t\t\ttext = o;\n\t\t\t\tif (!value)\n\t\t\t\t\tvalue = '';\n\t\t\t} else {\n\t\t\t\tval = o;\n\t\t\t\ttext = tmp[o];\n\t\t\t\tif (!text)\n\t\t\t\t\ttext = '';\n\t\t\t}\n\n\t\t} else if (type === 'object') {\n\n\t\t\ttext = (o[name] || '');\n\t\t\tval = (o[value] || '');\n\n\t\t\tif (typeof(text) === 'function')\n\t\t\t\ttext = text(i);\n\n\t\t\tif (typeof(val) === 'function')\n\t\t\t\tval = val(i, text);\n\n\t\t\tdis = o[disabled];\n\n\t\t\tif (typeof(disabled) === 'function')\n\t\t\t\tdis = disabled(i, val, text);\n\t\t\telse\n\t\t\t\tdis = dis ? true : false;\n\n\t\t} else {\n\t\t\ttext = o;\n\t\t\tval = o;\n\t\t}\n\n\t\tif (!isSelected) {\n\t\t\tsel = val == selected;\n\t\t\tisSelected = sel;\n\t\t}\n\n\t\toptions += '<option value=\"' + val.toString().encode() + '\"' + (sel ? ' selected=\"selected\"' : '') + (dis ? ' disabled=\"disabled\"' : '') + '>' + text.toString().encode() + '</option>';\n\t}\n\n\treturn options;\n};\n\n/**\n * Append <script> TAG\n * @private\n * @return {String}\n */\nControllerProto.$script = function() {\n\treturn arguments.length === 1 ? this.$js(arguments[0]) : this.$js.apply(this, arguments);\n};\n\n/**\n * Append <script> TAG\n * @private\n * @return {String}\n */\nControllerProto.$js = function() {\n\tvar self = this;\n\tvar builder = '';\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tbuilder += self.public_js(arguments[i], true);\n\treturn builder;\n};\n\n/**\n * Append <script> or <style> TAG\n * @private\n * @return {String}\n */\nControllerProto.$absolute = function(files, base) {\n\n\tvar self = this;\n\tvar builder;\n\tvar ftype;\n\n\tif (!base)\n\t\tbase = self.hostname();\n\n\tif (files instanceof Array) {\n\n\t\tftype = U.getExtension(files[0]);\n\t\tbuilder = '';\n\n\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\t\t\tswitch (ftype) {\n\t\t\t\tcase 'js':\n\t\t\t\tcase 'mjs':\n\t\t\t\t\tbuilder += self.public_js(files[i], true, base);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'css':\n\t\t\t\t\tbuilder += self.public_css(files[i], true, base);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbuilder += self.public(files[i], base);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn builder;\n\t}\n\n\tftype = U.getExtension(files);\n\n\tswitch (ftype) {\n\t\tcase 'js':\n\t\tcase 'mjs':\n\t\t\treturn self.public_js(files, true, base);\n\t\tcase 'css':\n\t\t\treturn self.public_css(files, true, base);\n\t}\n\n\treturn self.public(files, base);\n};\n\nvar $importmergecache = {};\n\nControllerProto.$import = function() {\n\n\tvar self = this;\n\tvar builder = '';\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar filename = arguments[i];\n\n\t\tif (filename === 'head') {\n\t\t\tbuilder += self.head();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'meta') {\n\t\t\tbuilder += self.$meta();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'components' && F.components.has) {\n\t\t\t// Generated in controller.head()\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'manifest' || filename === 'manifest.json') {\n\t\t\tbuilder += '<link rel=\"manifest\" href=\"' + F.$version('/manifest.json') + '\">';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename === 'favicon.ico' || filename === 'favicon.png') {\n\t\t\tbuilder += self.$favicon(filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filename[0] === 'l' && filename[9] === 'd' && filename.substring(0, 10) === 'livereload') {\n\t\t\tif (DEBUG) {\n\t\t\t\tvar url = filename.substring(11).trim();\n\t\t\t\tbuilder += '<script src=\"//cdn.totaljs.com/livereload.js\"' + (url ? (' data-url=\"' + url + '\"') : '') + '></script>';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar k = 'import#' + (self.themeName || '') + filename;\n\n\t\tif (F.temporary.other[k]) {\n\t\t\tbuilder += F.temporary.other[k];\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar ext;\n\n\t\tif (filename.indexOf('+') !== -1) {\n\n\t\t\t// MERGE\n\t\t\tvar merge = filename.split('+');\n\t\t\tvar hash = 'merge' + filename.hash(true);\n\n\t\t\tif ($importmergecache[hash]) {\n\t\t\t\tbuilder += F.temporary.other[k] = $importmergecache[hash];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmerge[0] = merge[0].trim();\n\t\t\tvar index = merge[0].lastIndexOf('.');\n\t\t\tvar mergename = merge[0];\n\t\t\tvar crc = 0;\n\n\t\t\text = U.getExtension(merge[0]);\n\t\t\tmerge[0] = ext === 'css' ? self.public_css(merge[0]) : self.public_js(merge[0]);\n\n\t\t\tfor (var j = 1; j < merge.length; j++) {\n\t\t\t\tmerge[j] = merge[j].trim();\n\t\t\t\tmerge[j] = ext === 'css' ? self.public_css(merge[j]) : self.public_js(merge[j]);\n\t\t\t\tcrc += merge[j].crc32(true);\n\t\t\t}\n\n\t\t\tvar outputname = mergename.substring(0, index) + crc + mergename.substring(index);\n\t\t\toutputname = ext === 'css' ? self.public_css(outputname) : self.public_js(outputname);\n\n\t\t\tvar tmp = ext === 'css' ? self.public_css(outputname, true) : self.public_js(outputname, true);\n\t\t\t$importmergecache[hash] = F.temporary.other[k] = tmp;\n\n\t\t\tmerge.unshift(outputname);\n\t\t\tMERGE.apply(global, merge);\n\t\t\tbuilder += tmp;\n\t\t\tcontinue;\n\t\t}\n\n\t\text = filename.substring(filename.lastIndexOf('.'));\n\t\tvar tag = filename[0] !== '!';\n\t\tif (!tag)\n\t\t\tfilename = filename.substring(1);\n\n\t\tif (filename[0] === '#')\n\t\t\text = '.js';\n\n\t\tswitch (ext) {\n\t\t\tcase '.js':\n\t\t\t\tbuilder += F.temporary.other[k] = self.public_js(filename, tag);\n\t\t\t\tbreak;\n\t\t\tcase '.css':\n\t\t\t\tbuilder += F.temporary.other[k] = self.public_css(filename, tag);\n\t\t\t\tbreak;\n\t\t\tcase '.ico':\n\t\t\t\tbuilder += F.temporary.other[k] = self.$favicon(filename);\n\t\t\t\tbreak;\n\t\t\tcase '.jpg':\n\t\t\tcase '.gif':\n\t\t\tcase '.svg':\n\t\t\tcase '.png':\n\t\t\tcase '.jpeg':\n\t\t\tcase '.heif':\n\t\t\tcase '.webp':\n\t\t\tcase '.heic':\n\t\t\tcase '.apng':\n\t\t\t\tbuilder += F.temporary.other[k] = self.public_image(filename);\n\t\t\t\tbreak;\n\t\t\tcase '.mp4':\n\t\t\tcase '.avi':\n\t\t\tcase '.ogv':\n\t\t\tcase '.webm':\n\t\t\tcase '.mov':\n\t\t\tcase '.mpg':\n\t\t\tcase '.mpe':\n\t\t\tcase '.mpeg':\n\t\t\tcase '.m4v':\n\t\t\t\tbuilder += F.temporary.other[k] = self.public_video(filename);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilder += F.temporary.other[k] = self.public(filename);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn builder;\n};\n\n/**\n * Append <link> TAG\n * @private\n * @return {String}\n */\nControllerProto.$css = function() {\n\n\tvar self = this;\n\tvar builder = '';\n\n\tfor (var i = 0; i < arguments.length; i++)\n\t\tbuilder += self.public_css(arguments[i], true);\n\n\treturn builder;\n};\n\nControllerProto.$image = function(name, width, height, alt, className) {\n\n\tvar style = '';\n\n\tif (typeof(width) === 'object') {\n\t\theight = width.height;\n\t\talt = width.alt;\n\t\tclassName = width.class;\n\t\tstyle = width.style;\n\t\twidth = width.width;\n\t}\n\n\tvar builder = '<img src=\"' + this.public_image(name) + ATTR_END;\n\n\tif (width > 0)\n\t\tbuilder += ' width=\"' + width + ATTR_END;\n\n\tif (height > 0)\n\t\tbuilder += ' height=\"' + height + ATTR_END;\n\n\tif (alt)\n\t\tbuilder += ' alt=\"' + alt.encode() + ATTR_END;\n\n\tif (className)\n\t\tbuilder += ' class=\"' + className + ATTR_END;\n\n\tif (style)\n\t\tbuilder += ' style=\"' + style + ATTR_END;\n\n\treturn builder + ' border=\"0\" />';\n};\n\n/**\n * Create URL: DOWNLOAD (<a href=\"...\" download=\"...\")\n * @private\n * @param {String} filename\n * @param {String} innerHTML\n * @param {String} downloadName Optional.\n * @param {String} className Optional.\n * @return {String}\n */\nControllerProto.$download = function(filename, innerHTML, downloadName, className) {\n\tvar builder = '<a href=\"' + F.public_download(filename) + ATTR_END;\n\n\tif (downloadName)\n\t\tbuilder += ' download=\"' + downloadName + ATTR_END;\n\n\tif (className)\n\t\tbuilder += ' class=\"' + className + ATTR_END;\n\n\treturn builder + '>' + (innerHTML || filename) + '</a>';\n};\n\n/**\n * Serialize object into the JSON\n * @private\n * @param {Object} obj\n * @param {String} id Optional.\n * @param {Boolean} beautify Optional.\n * @return {String}\n */\nControllerProto.$json = function(obj, id, beautify, replacer) {\n\n\tif (typeof(id) === 'boolean') {\n\t\treplacer = beautify;\n\t\tbeautify = id;\n\t\tid = null;\n\t}\n\n\tif (typeof(beautify) === 'function') {\n\t\treplacer = beautify;\n\t\tbeautify = false;\n\t}\n\n\tif (obj && obj.$$schema)\n\t\tobj = obj.$clean();\n\n\tvar value = beautify ? JSON.stringify(obj, replacer, 4) : JSON.stringify(obj, replacer);\n\treturn id ? ('<script type=\"application/json\" id=\"' + id + '\">' + value + '</script>') : value;\n};\n\n/**\n * Serialize object into the JSON\n * @private\n * @param {Object} obj\n * @param {String} id Optional.\n * @param {Boolean} beautify Optional.\n * @return {String}\n */\nControllerProto.$json2 = function(obj, id) {\n\n\tif (obj && obj.$$schema)\n\t\tobj = obj.$clean();\n\n\tvar data = {};\n\n\tfor (var i = 2; i < arguments.length; i++) {\n\t\tvar key = arguments[i];\n\t\tdata[key] = obj[key];\n\t}\n\n\treturn '<script type=\"application/json\" id=\"' + id + '\">' + JSON.stringify(data) + '</script>';\n};\n\n/**\n * Append FAVICON tag\n * @private\n * @param {String} name\n * @return {String}\n */\nControllerProto.$favicon = function(name) {\n\n\tvar contentType = 'image/x-icon';\n\n\tif (!name)\n\t\tname = 'favicon.ico';\n\n\tvar key = 'favicon#' + name;\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tif (name.lastIndexOf('.png') !== -1)\n\t\tcontentType = 'image/png';\n\telse if (name.lastIndexOf('.gif') !== -1)\n\t\tcontentType = 'image/gif';\n\n\treturn F.temporary.other[key] = '<link rel=\"icon\" href=\"' + F.public('/' + name) + '\" type=\"' + contentType + '\" />';\n};\n\n/**\n * Route static file helper\n * @private\n * @param {String} current\n * @param {String} name\n * @param {Function} fn\n * @return {String}\n */\nControllerProto.$static = function(name, fn) {\n\treturn fn.call(framework, prepare_staticurl(name, false), this.themeName);\n};\n\nControllerProto.routeScript = function(name, tag, path) {\n\tOBSOLETE('controller.routeScript()', 'Was renamed to \"controller.public_js()\"');\n\treturn this.public_js(name, tag, path);\n};\n\nControllerProto.public_js = function(name, tag, path) {\n\n\tif (name === undefined)\n\t\tname = 'default.js';\n\n\tvar async = false;\n\tvar url;\n\n\t// Checks \"async \"\n\tif (tag && name[0] === 'a' && name[5] === ' ') {\n\t\tasync = true;\n\t\tname = name.substring(6);\n\t}\n\n\t// Isomorphic\n\tif (name[0] === '#') {\n\t\tvar tmp = F.isomorphic[name.substring(1)];\n\t\tif (tmp)\n\t\t\turl = tmp.url;\n\t\telse {\n\t\t\tF.error('Isomorphic library {0} doesn\\'t exist.'.format(name.substring(1)));\n\t\t\treturn '';\n\t\t}\n\t} else {\n\t\turl = this.$static(name, F.public_js);\n\t\tif (path && U.isRelative(url))\n\t\t\turl = F.isWindows ? U.join(path, url) : U.join(path, url).substring(1);\n\t}\n\n\treturn tag ? ('<script src=\"' + url + '\"' + (async ? ' async' : '') + '></script>') : url;\n};\n\nControllerProto.routeStyle = function(name, tag, path) {\n\tOBSOLETE('controller.routeStyle()', 'Was renamed to \"controller.public_css()\"');\n\treturn this.public_css(name, tag, path);\n};\n\nControllerProto.public_css = function(name, tag, path) {\n\n\tvar self = this;\n\n\tif (name === undefined)\n\t\tname = 'default.css';\n\n\tvar url = self.$static(name, F.public_css);\n\tif (path && U.isRelative(url))\n\t\turl = F.isWindows ? U.join(path, url) : U.join(path, url).substring(1);\n\n\treturn tag ? '<link type=\"text/css\" rel=\"stylesheet\" href=\"' + url + '\" />' : url;\n};\n\nControllerProto.routeImage = function(name) {\n\tOBSOLETE('controller.routeImage()', 'Was renamed to \"controller.public_image()\"');\n\treturn this.public_image(name);\n};\n\nControllerProto.public_image = function(name) {\n\treturn this.$static(name, F.public_image);\n};\n\nControllerProto.routeVideo = function(name) {\n\tOBSOLETE('controller.routeVideo()', 'Was renamed to \"controller.public_video()\"');\n\treturn this.public_video(name);\n};\n\nControllerProto.public_video = function(name) {\n\treturn this.$static(name, F.public_video);\n};\n\nControllerProto.routeFont = function(name) {\n\tOBSOLETE('controller.routeFont()', 'Was renamed to \"controller.public_font()\"');\n\treturn this.public_font(name);\n};\n\nControllerProto.public_font = function(name) {\n\treturn F.public_font(name);\n};\n\nControllerProto.routeDownload = function(name) {\n\tOBSOLETE('controller.routeDownload()', 'Was renamed to \"controller.public_download()\"');\n\treturn this.public_download(name);\n};\n\nControllerProto.public_download = function(name) {\n\treturn this.$static(name, F.public_download);\n};\n\nControllerProto.routeStatic = function(name, path) {\n\tOBSOLETE('controller.routeStatic()', 'Was renamed to \"controller.public()\"');\n\treturn this.public(name, path);\n};\n\nControllerProto.public = function(name, path) {\n\tvar url = this.$static(name, F.public);\n\tif (path && U.isRelative(url))\n\t\treturn F.isWindows ? U.join(path, url) : U.join(path, url).substring(1);\n\treturn url;\n};\n\n/**\n * Creates a string from the view\n * @param {String} name A view name without `.html` extension.\n * @param {Object} model A model, optional.\n * @return {String}\n */\nControllerProto.template = function(name, model) {\n\tOBSOLETE('controller.template()', 'This method will be removed in v4.');\n\treturn this.view(name, model, true);\n};\n\n/**\n * Renders a custom helper to a string\n * @param {String} name A helper name.\n * @return {String}\n */\nControllerProto.helper = function(name) {\n\tvar helper = F.helpers[name];\n\tif (!helper)\n\t\treturn '';\n\n\tvar params = [];\n\tfor (var i = 1; i < arguments.length; i++)\n\t\tparams.push(arguments[i]);\n\n\treturn helper.apply(this, params);\n};\n\n/**\n * Response JSON\n * @param {Object} obj\n * @param {Object} headers Custom headers, optional.\n * @param {Boolean} beautify Beautify JSON.\n * @param {Function(key, value)} replacer JSON replacer.\n * @return {Controller}\n */\nControllerProto.json = function(obj, headers, beautify, replacer) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (typeof(headers) === 'boolean') {\n\t\treplacer = beautify;\n\t\tbeautify = headers;\n\t}\n\n\tres.options.code = self.status || 200;\n\tres.options.type = CT_JSON;\n\tres.options.headers = headers;\n\n\t// Checks the HEAD method\n\tif (self.req.method === 'HEAD') {\n\t\tres.options.body = EMPTYBUFFER;\n\t\tres.options.type = CT_JSON;\n\t\tres.$text();\n\t\tF.stats.response.json++;\n\t\treturn self;\n\t}\n\n\tif (self.$evalroutecallback) {\n\t\tvar err = obj instanceof framework_builders.ErrorBuilder ? obj : null;\n\t\tself.$evalroutecallback(err, err ? null : obj);\n\t\treturn self;\n\t}\n\n\tif (obj instanceof framework_builders.ErrorBuilder) {\n\t\tself.req.$language && !obj.isResourceCustom && obj.setResource(self.req.$language);\n\n\t\tvar json = obj.output(true);\n\n\t\tif (obj.contentType)\n\t\t\tres.options.type = obj.contentType;\n\t\telse\n\t\t\tres.options.type = CT_JSON;\n\n\t\tif (obj.status !== 200)\n\t\t\tres.options.code = obj.status;\n\n\t\tobj = json;\n\t\tF.stats.response.errorBuilder++;\n\t} else {\n\n\t\tif (obj && obj.$$schema)\n\t\t\tobj = obj.$clean();\n\n\t\tif (beautify)\n\t\t\tobj = JSON.stringify(obj, replacer, 4);\n\t\telse\n\t\t\tobj = JSON.stringify(obj, replacer);\n\t}\n\n\tF.stats.response.json++;\n\tres.options.body = obj;\n\tres.options.compress = obj.length > 4096;\n\tres.$text();\n\tself.precache && self.precache(obj, res.options.type, headers);\n\treturn self;\n};\n\nControllerProto.success = function(is, value) {\n\tvar t = typeof(is);\n\tif (value === undefined && (is == null || t === 'boolean')) {\n\t\tF.stats.response.json++;\n\t\tvar res = this.res;\n\t\tres.options.body = '{\"success\":' + (is == null ? 'true' : is) + '}';\n\t\tres.options.type = CT_JSON;\n\t\tres.options.compress = false;\n\t\tres.$text();\n\t} else {\n\t\tif (t && t !== 'boolean') {\n\t\t\tvalue = t;\n\t\t\tt = true;\n\t\t}\n\t\tthis.json(SUCCESS(is == null ? true : is, value));\n\t}\n\n\treturn this;\n};\n\nControllerProto.done = function(arg) {\n\tvar self = this;\n\treturn function(err, response) {\n\t\tif (err) {\n\t\t\tself.invalid(err);\n\t\t} else if (arg)\n\t\t\tself.json(SUCCESS(err == null, arg === true ? response : arg));\n\t\telse {\n\t\t\tvar res = self.res;\n\t\t\tres.options.body = '{\"success\":' + (err == null) + '}';\n\t\t\tres.options.type = CT_JSON;\n\t\t\tres.options.compress = false;\n\t\t\tres.$text();\n\t\t}\n\t};\n};\n\n/**\n * Responds with JSONP\n * @param {String} name A method name.\n * @param {Object} obj Object to serialize.\n * @param {Object} headers A custom headers.\n * @param {Boolean} beautify Should be the JSON prettified? Optional, default `false`\n * @param {Function} replacer Optional, the JSON replacer.\n * @return {Controller}\n */\nControllerProto.jsonp = function(name, obj, headers, beautify, replacer) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (typeof(headers) === 'boolean') {\n\t\treplacer = beautify;\n\t\tbeautify = headers;\n\t}\n\n\tres.options.code = self.status || 200;\n\tres.options.headers = headers;\n\tres.options.type = 'application/x-javascript';\n\n\t// Checks the HEAD method\n\tif (self.req.method === 'HEAD') {\n\t\tres.options.body = EMPTYBUFFER;\n\t\tres.$text();\n\t\tF.stats.response.json++;\n\t\treturn self;\n\t}\n\n\t!name && (name = 'callback');\n\n\tif (obj instanceof framework_builders.ErrorBuilder) {\n\t\tself.req.$language && !obj.isResourceCustom && obj.setResource(self.req.$language);\n\t\tobj = obj.json(beautify);\n\t\tif (obj.status !== 200)\n\t\t\tres.options.code = obj.status;\n\t\tF.stats.response.errorBuilder++;\n\t} else {\n\n\t\tif (obj && obj.$$schema)\n\t\t\tobj = obj.$clean();\n\n\t\tif (beautify)\n\t\t\tobj = JSON.stringify(obj, replacer, 4);\n\t\telse\n\t\t\tobj = JSON.stringify(obj, replacer);\n\t}\n\n\tres.options.body = name + '(' + obj + ')';\n\tres.$text();\n\n\tF.stats.response.json++;\n\tself.precache && self.precache(name + '(' + obj + ')', res.options.type, headers);\n\treturn self;\n};\n\n/**\n * Creates View or JSON callback\n * @param {String} view Optional, undefined or null returns JSON.\n * @return {Function}\n */\nControllerProto.callback = function(view) {\n\tvar self = this;\n\treturn function(err, data) {\n\n\t\tCONF.logger && self.req.$logger && F.ilogger(null, self.req);\n\n\t\tif (self.res && self.res.success)\n\t\t\treturn;\n\n\t\tvar is = err instanceof framework_builders.ErrorBuilder;\n\n\t\t// NoSQL embedded database\n\t\tif (data === undefined && (err && !err.stack) && !is) {\n\t\t\tdata = err;\n\t\t\terr = null;\n\t\t}\n\n\t\tif (err) {\n\t\t\tif (is && !view) {\n\t\t\t\tself.req.$language && !err.isResourceCustom && err.setResource(self.req.$language);\n\t\t\t\treturn self.content(err);\n\t\t\t}\n\t\t\treturn is && err.unexpected ? self.view500(err) : self.view404(err);\n\t\t}\n\n\t\t// Hack for schemas\n\t\tif (data instanceof F.callback_redirect)\n\t\t\treturn self.redirect(data.url);\n\n\t\tif (typeof(view) === 'string')\n\t\t\tself.view(view, data);\n\t\telse if (data === SUCCESSHELPER && data.value === undefined) {\n\t\t\tif (self.$evalroutecallback) {\n\t\t\t\tself.$evalroutecallback(null, data);\n\t\t\t} else {\n\t\t\t\tF.stats.response.json++;\n\t\t\t\tvar res = self.res;\n\t\t\t\tres.options.compress = false;\n\t\t\t\tres.options.body = '{\"success\":' + (data.success == null ? 'true' : data.success) + '}';\n\t\t\t\tres.options.type = CT_JSON;\n\t\t\t\tres.$text();\n\t\t\t}\n\t\t} else\n\t\t\tself.json(data);\n\t};\n};\n\nControllerProto.custom = function() {\n\tif (this.res.success)\n\t\treturn false;\n\tthis.res.$custom();\n\treturn true;\n};\n\n/**\n * Prevents cleaning uploaded files (need to call `controller.clear()` manually).\n * @param {Boolean} enable Optional, default `true`.\n * @return {Controller}\n */\nControllerProto.noClear = function(enable) {\n\tOBSOLETE('controller.noClear()', 'You need to use controller.autoclear(false)');\n\tthis.req._manual = enable === undefined ? true : enable;\n\treturn this;\n};\n\nControllerProto.autoclear = function(enable) {\n\tthis.req._manual = enable === false;\n\treturn this;\n};\n\nControllerProto.html = function(body, headers) {\n\treturn this.content(body, 'text/html', headers);\n};\n\nControllerProto.content = function(body, type, headers) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tres.options.headers = headers;\n\tres.options.code = self.status || 200;\n\n\tif (self.$evalroutecallback) {\n\t\tvar err = body instanceof ErrorBuilder ? body : null;\n\t\tself.$evalroutecallback(err, err ? null : body);\n\t\treturn self;\n\t}\n\n\tif (body instanceof ErrorBuilder) {\n\n\t\tif (self.language && !body.resourceName)\n\t\t\tbody.resourceName = self.language;\n\n\t\tvar tmp = body.output(true);\n\t\tif (body.contentType)\n\t\t\tres.options.type = body.contentType;\n\t\telse\n\t\t\tres.options.type = CT_JSON;\n\n\t\tif (body.status !== 200)\n\t\t\tres.options.code = body.status;\n\n\t\tbody = tmp;\n\t\tF.stats.response.errorBuilder++;\n\t} else\n\t\tres.options.type = type || CT_TEXT;\n\n\tres.options.body = body;\n\tres.options.compress = body.length > 4096;\n\tres.$text();\n\n\tif (self.precache && (!self.status || self.status === 200)) {\n\t\tself.layout('');\n\t\tself.precache(body, res.options.type, headers, true);\n\t}\n\n\treturn self;\n};\n\n/**\n * Responds with plain/text body\n * @param {String} body A response body (object is serialized into the JSON automatically).\n * @param {Boolean} headers A custom headers.\n * @return {Controller}\n */\nControllerProto.plain = function(body, headers) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tres.options.code = self.status || 200;\n\tres.options.headers = headers;\n\tres.options.type = CT_TEXT;\n\n\t// Checks the HEAD method\n\tif (self.req.method === 'HEAD') {\n\t\tres.options.body = EMPTYBUFFER;\n\t\tres.$text();\n\t\tF.stats.response.plain++;\n\t\treturn self;\n\t}\n\n\tvar type = typeof(body);\n\n\tif (body == null)\n\t\tbody = '';\n\telse if (type === 'object') {\n\t\tif (body && body.$$schema)\n\t\t\tbody = body.$clean();\n\t\tbody = body ? JSON.stringify(body, null, 4) : '';\n\t} else\n\t\tbody = body ? body.toString() : '';\n\n\tres.options.body = body;\n\tres.$text();\n\tF.stats.response.plain++;\n\tself.precache && self.precache(body, res.options.type, headers);\n\treturn self;\n};\n\n/**\n * Creates an empty response\n * @param {Object/Number} headers A custom headers or a custom HTTP status.\n * @return {Controller}\n */\nControllerProto.empty = function(headers) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (typeof(headers) === 'number') {\n\t\tself.status = headers;\n\t\theaders = null;\n\t}\n\n\tres.options.code = self.status || 200;\n\tres.options.headers = headers;\n\tres.options.body = EMPTYBUFFER;\n\tres.options.type = CT_TEXT;\n\tres.options.compress = false;\n\tres.$text();\n\tF.stats.response.empty++;\n\treturn self;\n};\n\n/**\n * Creates an empty response with 204\n * @param {Object/Number} headers A custom headers or a custom HTTP status.\n * @return {Controller}\n */\nControllerProto.nocontent = function(headers) {\n\tvar self = this;\n\tvar res = self.res;\n\tres.writeHead(204, headers);\n\tres.end();\n\tF.stats.response.empty++;\n\tresponse_end(res);\n\treturn self;\n};\n\n/**\n * Destroys a request (closes it)\n * @param {String} problem Optional.\n * @return {Controller}\n */\nControllerProto.destroy = function(problem) {\n\tvar self = this;\n\n\tproblem && self.problem(problem);\n\tif (self.res.success || self.res.headersSent || !self.isConnected)\n\t\treturn self;\n\n\tself.req.$total_success();\n\tself.req.connection && self.req.connection.destroy();\n\tF.stats.response.destroy++;\n\treturn self;\n};\n\n/**\n * Responds with a file\n * @param {String} filename\n * @param {String} download Optional, a download name.\n * @param {Object} headers Optional, additional headers.\n * @param {Function} done Optinoal, callback.\n * @return {Controller}\n */\nControllerProto.file = function(filename, download, headers, done) {\n\n\tif (filename[0] === '~')\n\t\tfilename = filename.substring(1);\n\telse\n\t\tfilename = F.path.public_cache(filename);\n\n\tvar res = this.res;\n\tres.options.filename = filename;\n\tres.options.download = download;\n\tres.options.headers = headers;\n\tres.options.callback = done;\n\n\tres.$file();\n\treturn this;\n};\n\nControllerProto.filefs = function(name, id, download, headers, callback, checkmeta) {\n\tvar self = this;\n\tvar options = {};\n\toptions.id = id;\n\toptions.download = download;\n\toptions.headers = headers;\n\toptions.done = callback;\n\tFILESTORAGE(name).res(self.res, options, checkmeta, $file_notmodified);\n\treturn self;\n};\n\nControllerProto.filenosql = function(name, id, download, headers, callback, checkmeta) {\n\tvar self = this;\n\tvar options = {};\n\toptions.id = id;\n\toptions.download = download;\n\toptions.headers = headers;\n\toptions.done = callback;\n\tNOSQL(name).binary.res(self.res, options, checkmeta, $file_notmodified);\n\treturn self;\n};\n\nControllerProto.imagefs = function(name, id, make, headers, callback, checkmeta) {\n\tvar self = this;\n\tvar options = {};\n\toptions.id = id;\n\toptions.image = true;\n\toptions.make = make;\n\toptions.headers = headers;\n\toptions.done = callback;\n\tFILESTORAGE(name).res(self.res, options, checkmeta, $file_notmodified);\n\treturn self;\n};\n\nControllerProto.imagenosql = function(name, id, make, headers, callback, checkmeta) {\n\tvar self = this;\n\tvar options = {};\n\toptions.id = id;\n\toptions.image = true;\n\toptions.make = make;\n\toptions.headers = headers;\n\toptions.done = callback;\n\tNOSQL(name).binary.res(self.res, options, checkmeta, $file_notmodified);\n\treturn self;\n};\n\n/**\n * Responds with an image\n * @param {String or Stream} filename\n * @param {Function(image)} fnProcess\n * @param {Object} headers Optional, additional headers.\n * @param {Function} done Optional, callback.\n * @return {Controller}\n */\nControllerProto.image = function(filename, make, headers, done) {\n\n\tvar res = this.res;\n\n\tif (typeof(filename) === 'string') {\n\t\tif (filename[0] === '~')\n\t\t\tfilename = filename.substring(1);\n\t\telse\n\t\t\tfilename = F.path.public_cache(filename);\n\n\t\tres.options.filename = filename;\n\t} else\n\t\tres.options.stream = filename;\n\n\tres.options.make = make;\n\theaders && (res.options.headers = headers);\n\tdone && (res.options.callback = done);\n\tres.$image();\n\treturn this;\n};\n\n/**\n * Responds with a stream\n * @param {String} contentType\n * @param {Stream} stream\n * @param {String} download Optional, a download name.\n * @param {Object} headers Optional, additional headers.\n * @param {Function} done Optinoal, callback.\n * @return {Controller}\n */\nControllerProto.stream = function(type, stream, download, headers, done, nocompress) {\n\tvar res = this.res;\n\tres.options.type = type;\n\tres.options.stream = stream;\n\tres.options.download = download;\n\tres.options.headers = headers;\n\tres.options.done = done;\n\tres.options.compress = nocompress ? false : true;\n\tres.$stream();\n\treturn this;\n};\n\n/**\n * Throw 400 - Bad request.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nControllerProto.throw400 = ControllerProto.view400 = function(problem) {\n\treturn controller_error_status(this, 400, problem);\n};\n\n/**\n * Throw 401 - Unauthorized.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nControllerProto.throw401 = ControllerProto.view401 = function(problem) {\n\treturn controller_error_status(this, 401, problem);\n};\n\n/**\n * Throw 403 - Forbidden.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nControllerProto.throw403 = ControllerProto.view403 = function(problem) {\n\treturn controller_error_status(this, 403, problem);\n};\n\n/**\n * Throw 404 - Not found.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nControllerProto.throw404 = ControllerProto.view404 = function(problem) {\n\treturn controller_error_status(this, 404, problem);\n};\n\n/**\n * Throw 409 - Conflict.\n * @param  {String} problem Description of problem (optional)\n * @return {Controller}\n */\nControllerProto.throw409 = ControllerProto.view409 = function(problem) {\n\treturn controller_error_status(this, 409, problem);\n};\n\n/**\n * Throw 500 - Internal Server Error.\n * @param {Error} error\n * @return {Controller}\n */\nControllerProto.throw500 = ControllerProto.view500 = function(error) {\n\tvar self = this;\n\tF.error(error instanceof Error ? error : new Error((error || '').toString()), self.name, self.req.uri);\n\treturn controller_error_status(self, 500, error);\n};\n\n/**\n * Throw 501 - Not implemented\n * @param  {String} problem Description of the problem (optional)\n * @return {Controller}\n */\nControllerProto.throw501 = ControllerProto.view501 = function(problem) {\n\treturn controller_error_status(this, 501, problem);\n};\n\n/**\n * Throw 503 - Service unavailable\n * @param  {String} problem Description of the problem (optional)\n * @return {Controller}\n */\nControllerProto.throw503 = ControllerProto.view503 = function(problem) {\n\treturn controller_error_status(this, 503, problem);\n};\n\n/**\n * Creates a redirect\n * @param {String} url\n * @param {Boolean} permanent Is permanent? Default: `false`\n * @return {Controller}\n */\nControllerProto.redirect = function(url, permanent) {\n\tthis.precache && this.precache(null, null, null);\n\tvar res = this.res;\n\tres.options.url = url;\n\tres.options.permanent = permanent;\n\tres.$redirect();\n\treturn this;\n};\n\n/**\n * A binary response\n * @param {Buffer} buffer\n * @param {String} type\n * @param {String} encoding Transformation type: `binary`, `utf8`, `ascii`.\n * @param {String} download Optional, download name.\n * @param {Object} headers Optional, additional headers.\n * @return {Controller}\n */\nControllerProto.binary = function(buffer, type, encoding, download, headers) {\n\n\tvar res = this.res;\n\n\tif (typeof(encoding) === 'object') {\n\t\tvar tmp = encoding;\n\t\tencoding = download;\n\t\tdownload = headers;\n\t\theaders = tmp;\n\t}\n\n\tif (typeof(download) === 'object') {\n\t\theaders = download;\n\t\tdownload = headers;\n\t}\n\n\tres.options.body = buffer;\n\tres.options.type = type;\n\tres.options.download = download;\n\tres.options.headers = headers;\n\tres.options.encoding = encoding;\n\tres.$binary();\n\treturn this;\n};\n\n/**\n * Basic access authentication (baa)\n * @param {String} label\n * @return {Object}\n */\nControllerProto.baa = function(label) {\n\n\tvar self = this;\n\tself.precache && self.precache(null, null, null);\n\n\tif (label === undefined)\n\t\treturn self.req.authorization();\n\n\tvar res = self.res;\n\tvar headers = SINGLETON('!controller.baa');\n\n\theaders['WWW-Authenticate'] = 'Basic realm=\"' + (label || 'Administration') + '\"';\n\n\tres.options.code = 401;\n\tres.options.body = '401: NOT AUTHORIZED';\n\tres.options.compress = false;\n\tres.options.headers = headers;\n\tres.options.type = CT_TEXT;\n\tres.$text();\n\tself.cancel();\n\treturn null;\n};\n\n/**\n * Sends server-sent event message\n * @param {String/Object} data\n * @param {String} eventname Optional, an event name.\n * @param {String} id Optional, a custom ID.\n * @param {Number} retry A reconnection timeout in milliseconds when is an unexpected problem.\n * @return {Controller}\n */\nControllerProto.sse = function(data, eventname, id, retry) {\n\n\tvar self = this;\n\tvar res = self.res;\n\n\tif (!self.isConnected)\n\t\treturn self;\n\n\tif (!self.type && res.success)\n\t\tthrow new Error('Response was sent.');\n\n\tif (self.type > 0 && self.type !== 1)\n\t\tthrow new Error('Response was used.');\n\n\tif (!self.type) {\n\n\t\tself.type = 1;\n\n\t\tif (retry === undefined)\n\t\t\tretry = self.route.timeout;\n\n\t\tself.req.$total_success();\n\t\tself.req.on('close', () => self.close());\n\t\tres.success = true;\n\t\tres.writeHead(self.status || 200, HEADERS.sse);\n\t}\n\n\tif (typeof(data) === 'object')\n\t\tdata = JSON.stringify(data);\n\telse\n\t\tdata = data.replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n\n\tvar newline = '\\n';\n\tvar builder = '';\n\n\tif (eventname)\n\t\tbuilder = 'event: ' + eventname + newline;\n\n\tbuilder += 'data: ' + data + newline;\n\n\tif (id)\n\t\tbuilder += 'id: ' + id + newline;\n\n\tif (retry > 0)\n\t\tbuilder += 'retry: ' + retry + newline;\n\n\tbuilder += newline;\n\tres.write(builder);\n\tF.stats.response.sse++;\n\treturn self;\n};\n\n/**\n * Close a response\n * @param {Boolean} end\n * @return {Controller}\n */\nControllerProto.close = function(end) {\n\tvar self = this;\n\n\tif (end === undefined)\n\t\tend = true;\n\n\tif (!self.isConnected)\n\t\treturn self;\n\n\tif (self.type) {\n\t\tself.isConnected = false;\n\t\tself.res.success = true;\n\t\tF.reqstats(false, false);\n\t\tF.$events['request-end'] && EMIT('request-end', self.req, self.res);\n\t\tF.$events.request_end && EMIT('request_end', self.req, self.res);\n\t\tself.type = 0;\n\t\tend && self.res.end();\n\t\tself.req.clear(true);\n\t\treturn self;\n\t}\n\n\tself.isConnected = false;\n\n\tif (self.res.success)\n\t\treturn self;\n\n\tself.res.success = true;\n\tF.reqstats(false, false);\n\tF.$events['request-end'] && EMIT('request-end', self.req, self.res);\n\tF.$events.request_end && EMIT('request_end', self.req, self.res);\n\tend && self.res.end();\n\tself.req.clear(true);\n\treturn self;\n};\n\n/**\n * Creates a proxy between current request and new URL\n * @param {String} url\n * @param {Function(err, response, headers)} callback Optional.\n * @param {Object} headers Optional, additional headers.\n * @param {Number} timeout Optional, timeout (default: 10000)\n * @return {EventEmitter}\n */\nControllerProto.proxy = ControllerProto.proxy2 = function(url, callback, headers, timeout) {\n\n\tif (typeof(callback) === 'object') {\n\t\ttimeout = headers;\n\t\theaders = callback;\n\t\tcallback = undefined;\n\t}\n\n\tvar self = this;\n\tvar flags = [];\n\tvar req = self.req;\n\tvar type = req.headers['content-type'];\n\tvar h = {};\n\n\tflags.push(req.method);\n\tflags.push('dnscache');\n\n\tif ((/\\/json/i).test(type))\n\t\tflags.push('json');\n\n\tvar tmp;\n\n\tif (url.indexOf('?') === -1) {\n\t\ttmp = Qs.stringify(self.query);\n\t\tif (tmp)\n\t\t\turl += '?' + tmp;\n\t}\n\n\tvar keys = Object.keys(req.headers);\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tswitch (keys[i]) {\n\t\t\tcase 'x-forwarded-for':\n\t\t\tcase 'x-forwarded-protocol':\n\t\t\tcase 'x-nginx-proxy':\n\t\t\tcase 'connection':\n\t\t\tcase 'content-type':\n\t\t\tcase 'host':\n\t\t\tcase 'accept-encoding':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\th[keys[i]] = req.headers[keys[i]];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (headers) {\n\n\t\tif (headers.flags) {\n\t\t\tif (typeof(headers.flags) === 'string')\n\t\t\t\theaders.flags = headers.flags.split(',');\n\t\t\tfor (var i = 0; i < headers.flags.length; i++)\n\t\t\t\tflags.push(headers.flags[i]);\n\t\t\theaders.flags = undefined;\n\t\t}\n\n\t\tkeys = Object.keys(headers);\n\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\tif (headers[keys[i]])\n\t\t\t\th[keys[i]] = headers[keys[i]];\n\t\t}\n\t}\n\n\treturn U.request(url, flags, self.body, function(err, data, code, headers) {\n\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t\tself.invalid().push(err);\n\t\t} else {\n\t\t\tself.status = code;\n\t\t\tcallback && callback(err, data, code, headers);\n\t\t\tvar ct = (headers['content-type'] || 'text/plain').replace(REG_ENCODINGCLEANER, '');\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tself.binary(data, ct);\n\t\t\telse\n\t\t\t\tself.content(data, ct);\n\t\t}\n\n\t}, null, h, ENCODING, timeout || 10000);\n};\n\n/**\n * Renders view to response\n * @param {String} name View name without `.html` extension.\n * @param {Object} model A model, optional default: `undefined`.\n * @param {Object} headers A custom headers, optional.\n * @param {Boolean} isPartial When is `true` the method returns rendered HTML as `String`\n * @return {Controller/String}\n */\nControllerProto.view = function(name, model, headers, partial, noasync, cachekey) {\n\n\tvar self = this;\n\n\tif (typeof(name) !== 'string') {\n\t\tpartial = headers;\n\t\theaders = model;\n\t\tmodel = name;\n\t\tname = self.viewname;\n\t} else if (partial === undefined && typeof(headers) === 'boolean') {\n\t\tpartial = headers;\n\t\theaders = null;\n\t}\n\n\tif (!partial && self.res && self.res.success)\n\t\treturn self;\n\n\tif (self.layoutName === undefined)\n\t\tself.layoutName = CONF.default_layout;\n\tif (self.themeName === undefined)\n\t\tself.themeName = CONF.default_theme;\n\n\t// theme root `~some_view`\n\t// views root `~~some_view`\n\t// package    `@some_view`\n\t// theme      `=theme/view`\n\n\tvar key = 'view#=' + this.themeName + '/' + self._currentView + '/' + name;\n\tvar filename = F.temporary.other[key];\n\tvar isLayout = self.isLayout;\n\n\tself.isLayout = false;\n\n\t// A small cache\n\tif (!filename) {\n\n\t\t// ~   --> routed into the root of views (if the controller uses a theme then is routed into the root views of the theme)\n\t\t// ~~  --> routed into the root of views (if the controller contains theme)\n\t\t// /   --> routed into the views (skipped)\n\t\t// @   --> routed into the packages\n\t\t// .   --> routed into the opened path\n\t\t// =   --> routed into the theme\n\n\t\tvar c = name[0];\n\t\tvar skip = c === '/' ? 1 : c === '~' && name[1] === '~' ? 4 : c === '~' ? 2 : c === '@' ? 3 : c === '.' ? 5 : c === '=' ? 6 : 0;\n\t\tvar isTheme = false;\n\n\t\tif (REG_HTTPHTTPS.test(name))\n\t\t\tskip = 7;\n\n\t\tfilename = name;\n\n\t\tif (self.themeName && skip < 3) {\n\t\t\tfilename = '.' + F.path.themes(self.themeName + '/views/' + (isLayout || skip ? '' : self._currentView.substring(1)) + (skip ? name.substring(1) : name)).replace(REG_SANITIZE_BACKSLASH, '/');\n\t\t\tisTheme = true;\n\t\t}\n\n\t\tif (skip === 4) {\n\t\t\tfilename = filename.substring(1);\n\t\t\tname = name.substring(1);\n\t\t\tskip = 2;\n\t\t}\n\n\t\tif (!isTheme && !isLayout && !skip && self._currentView)\n\t\t\tfilename = self._currentView + name;\n\n\t\tif (!isTheme && (skip === 2 || skip === 3))\n\t\t\tfilename = name.substring(1);\n\n\t\tif (skip === 3)\n\t\t\tfilename = '.' + F.path.package(filename);\n\n\t\tif (skip === 6) {\n\t\t\tc = U.parseTheme(filename);\n\t\t\tname = name.substring(name.indexOf('/') + 1);\n\t\t\tfilename = '.' + F.path.themes(c + '/views/' + name).replace(REG_SANITIZE_BACKSLASH, '/');\n\t\t}\n\n\t\tif (skip === 7) {\n\n\t\t\tif (F.temporary.other[key] === 0) {\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tself.view(name, model, headers, partial);\n\t\t\t\t}, 100, self);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfilename = F.path.temp('view' + name.hash() + '.html');\n\t\t\tF.temporary.other[key] = 0;\n\n\t\t\tvar done = { callback: NOOP };\n\n\t\t\tF.download(name, filename, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tF.temporary.other[key] = undefined;\n\t\t\t\t\tif (done.callback === NOOP)\n\t\t\t\t\t\tF.throw500(err);\n\t\t\t\t\telse\n\t\t\t\t\t\tdone.callback(err);\n\t\t\t\t} else {\n\t\t\t\t\tF.temporary.other[key] = '.' + filename.substring(0, filename.length - 5);\n\t\t\t\t\tdone.callback(null, self.view(name, model, headers, partial));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn function(cb) {\n\t\t\t\tdone.callback = cb;\n\t\t\t};\n\t\t}\n\t}\n\n\treturn self.$viewrender(filename, framework_internal.viewEngine(name, filename, self), model, headers, partial, isLayout, noasync, cachekey);\n};\n\nControllerProto.viewCompile = function(body, model, headers, partial, key) {\n\tOBSOLETE('controller.viewCompile()', 'Was renamed to `controller.view_compile()`.');\n\treturn this.view_compile(body, model, headers, partial, key);\n};\n\nControllerProto.view_compile = function(body, model, headers, partial, key) {\n\n\tif (headers === true) {\n\t\tkey = partial;\n\t\tpartial = true;\n\t\theaders = undefined;\n\t} else if (typeof(headers) === 'string') {\n\t\tkey = headers;\n\t\theaders = undefined;\n\t} else if (typeof(partial) === 'string') {\n\t\tkey = partial;\n\t\tpartial = undefined;\n\t}\n\n\treturn this.$viewrender('[dynamic view]', framework_internal.viewEngineCompile(body, this.language, this, key), model, headers, partial);\n};\n\nControllerProto.$viewrender = function(filename, generator, model, headers, partial, isLayout, noasync, cachekey) {\n\n\tvar self = this;\n\tvar err;\n\n\tif (!generator) {\n\n\t\terr = new Error('View \"' + filename + '\" not found.');\n\n\t\tif (partial) {\n\t\t\tF.error(err, self.name, self.uri);\n\t\t\treturn self.outputPartial;\n\t\t}\n\n\t\tif (isLayout) {\n\t\t\tself.res.throw500(err);\n\t\t\treturn self;\n\t\t}\n\n\t\tself.view500(err);\n\t\treturn self;\n\t}\n\n\tvar value = '';\n\tself.$model = model;\n\n\tif (isLayout)\n\t\tself._currentView = self._defaultView || '';\n\n\tvar helpers = F.helpers;\n\n\ttry {\n\n\t\tif (generator.components.length) {\n\t\t\tif (!self.repository[REPOSITORY_COMPONENTS])\n\t\t\t\tself.repository[REPOSITORY_COMPONENTS] = {};\n\t\t\tfor (var i = 0; i < generator.components.length; i++)\n\t\t\t\tself.repository[REPOSITORY_COMPONENTS][generator.components[i]] = 1;\n\t\t}\n\n\t\tvalue = generator.call(self, self, self.repository, model, self.session, self.query, self.body, self.url, F.global, helpers, self.user, CONF, F.functions, 0, partial ? self.outputPartial : self.output, self.req.files, self.req.mobile, EMPTYOBJECT);\n\n\t} catch (ex) {\n\n\t\terr = new Error('View \"' + filename + '\": ' + ex.message);\n\n\t\tif (!partial) {\n\t\t\tself.view500(err);\n\t\t\treturn self;\n\t\t}\n\n\t\tself.error(err);\n\n\t\tif (self.partial)\n\t\t\tself.outputPartial = '';\n\t\telse\n\t\t\tself.output = '';\n\n\t\tisLayout = false;\n\t\treturn value;\n\t}\n\n\t// noasync = true --> rendered inline view in view\n\n\tif (self.$viewasync && self.$viewasync.length) {\n\n\t\tvar can = ((isLayout || !self.layoutName) && noasync !== true) || !!cachekey;\n\t\tif (can) {\n\t\t\tvar done = {};\n\t\t\tvar obj = {};\n\n\t\t\tobj.repository = self.repository;\n\t\t\tobj.model = self.$model;\n\t\t\tobj.user = self.user;\n\t\t\tobj.session = self.session;\n\t\t\tobj.controller = self;\n\t\t\tobj.query = self.query;\n\t\t\tobj.body = self.body;\n\t\t\tobj.files = self.files;\n\n\t\t\tself.$viewasync.waitFor(function(item, next) {\n\n\t\t\t\tif (item.value) {\n\t\t\t\t\tvalue = value.replace(item.replace, item.value);\n\t\t\t\t\tif (isLayout && self.precache)\n\t\t\t\t\t\tself.output = self.output.replace(item.replace, item.value);\n\t\t\t\t\treturn next();\n\t\t\t\t}\n\n\t\t\t\tobj.options = obj.settings = item.settings;\n\t\t\t\tobj.next = obj.callback = function(model) {\n\t\t\t\t\tif (arguments.length > 1)\n\t\t\t\t\t\tmodel = arguments[1];\n\t\t\t\t\titem.value = self.component(item.name, item.settings, model);\n\t\t\t\t\tvalue = value.replace(item.replace, item.value);\n\t\t\t\t\tif (isLayout && self.precache)\n\t\t\t\t\t\tself.output = self.output.replace(item.replace, item.value);\n\t\t\t\t\tnext();\n\t\t\t\t};\n\n\t\t\t\tF.components.instances[item.name].render(obj);\n\n\t\t\t}, function() {\n\n\t\t\t\tif (cachekey && F.cache.items[cachekey]) {\n\t\t\t\t\tvar cache = F.cache.items[cachekey].value;\n\t\t\t\t\tcache.body = value;\n\t\t\t\t\tcache.components = true;\n\t\t\t\t}\n\n\t\t\t\tif (isLayout && self.precache && (!self.status || self.status === 200) && !partial)\n\t\t\t\t\tself.precache(self.output, CT_HTML, headers, true);\n\n\t\t\t\tif (isLayout || !self.layoutName) {\n\n\t\t\t\t\tself.outputPartial = '';\n\t\t\t\t\tself.output = '';\n\t\t\t\t\tisLayout = false;\n\n\t\t\t\t\tif (partial) {\n\t\t\t\t\t\tdone.callback && done.callback(null, value);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tself.req.$total_success();\n\n\t\t\t\t\tif (!self.isConnected)\n\t\t\t\t\t\treturn self;\n\n\t\t\t\t\tvar res = self.res;\n\t\t\t\t\tres.options.body = value;\n\t\t\t\t\tres.options.code = self.status || 200;\n\t\t\t\t\tres.options.type = CT_HTML;\n\t\t\t\t\tres.options.headers = headers;\n\t\t\t\t\tres.$text();\n\t\t\t\t\tF.stats.response.view++;\n\t\t\t\t\treturn self;\n\t\t\t\t}\n\n\t\t\t\tif (partial)\n\t\t\t\t\tself.outputPartial = value;\n\t\t\t\telse\n\t\t\t\t\tself.output = value;\n\n\t\t\t\tif (!cachekey && !noasync) {\n\t\t\t\t\tself.isLayout = true;\n\t\t\t\t\tvalue = self.view(self.layoutName, self.$model, headers, partial);\n\t\t\t\t}\n\n\t\t\t\t// Async\n\t\t\t\tif (partial) {\n\t\t\t\t\tself.outputPartial = '';\n\t\t\t\t\tself.isLayout = false;\n\t\t\t\t\tdone.callback && done.callback(null, value);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\treturn cachekey ? value : (partial ? (fn => done.callback = fn) : self);\n\t\t}\n\t}\n\n\tif (!isLayout && self.precache && (!self.status || self.status === 200) && !partial && !self.$viewasync)\n\t\tself.precache(value, CT_HTML, headers, true);\n\n\tif (isLayout || !self.layoutName) {\n\n\t\tself.outputPartial = '';\n\t\tself.output = '';\n\t\tisLayout = false;\n\n\t\tif (partial)\n\t\t\treturn value;\n\n\t\tself.req.$total_success();\n\n\t\tif (!self.isConnected)\n\t\t\treturn self;\n\n\t\tvar components = self.repository[REPOSITORY_COMPONENTS];\n\t\tif (components) {\n\t\t\tvar keys = Object.keys(components);\n\t\t\tvar plus = '';\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar com = F.components.groups[keys[i]];\n\t\t\t\tif (com)\n\t\t\t\t\tplus += com.links;\n\t\t\t}\n\t\t\t// Cleans cache\n\t\t\tself.repository[REPOSITORY_COMPONENTS] = null;\n\t\t\tvalue = value.replace('</head>', plus + '</head>');\n\t\t}\n\n\t\tvar res = self.res;\n\t\tres.options.body = value;\n\t\tres.options.code = self.status || 200;\n\t\tres.options.type = CT_HTML;\n\t\tres.options.headers = headers;\n\t\tres.$text();\n\t\tF.stats.response.view++;\n\t\treturn self;\n\t}\n\n\tif (partial)\n\t\tself.outputPartial = value;\n\telse\n\t\tself.output = value;\n\n\tif (!cachekey && !noasync) {\n\t\tself.isLayout = true;\n\t\tvalue = self.view(self.layoutName, self.$model, headers, partial);\n\t}\n\n\t// Async\n\tif (partial) {\n\t\tself.outputPartial = '';\n\t\tself.isLayout = false;\n\t\treturn value;\n\t}\n\n\treturn self;\n};\n\n/**\n * Creates a cache for the response without caching layout\n * @param {String} key\n * @param {String} expires Expiration, e.g. `1 minute`\n * @param {Boolean} disabled Disables a caching, optional (e.g. for debug mode you can disable a cache), default: `false`\n * @param {Function()} fnTo This method is executed when the content is prepared for the cache.\n * @param {Function()} fnFrom This method is executed when the content is readed from the cache.\n * @return {Controller}\n */\nControllerProto.memorize = function(key, expires, disabled, fnTo, fnFrom) {\n\n\tvar self = this;\n\n\tif (disabled === true) {\n\t\tfnTo.call(self);\n\t\treturn self;\n\t}\n\n\tself.themeName && (key += '#' + self.themeName);\n\n\tvar output = F.cache.read2(key);\n\tif (!output)\n\t\treturn self.$memorize_prepare(key, expires, disabled, fnTo, fnFrom);\n\n\tif (typeof(disabled) === 'function') {\n\t\tvar tmp = fnTo;\n\t\tfnTo = disabled;\n\t\tfnFrom = tmp;\n\t}\n\n\tself.layoutName = output.layout;\n\tself.themeName = output.theme;\n\n\tvar res = self.res;\n\n\tres.options.code = self.status || 200;\n\tres.options.type = output.type;\n\tres.options.headers = output.headers;\n\tres.options.body = output.content;\n\n\tif (output.type !== CT_HTML) {\n\t\tfnFrom && fnFrom.call(self);\n\t\tres.$text();\n\t\treturn;\n\t}\n\n\tswitch (output.type) {\n\t\tcase CT_TEXT:\n\t\t\tF.stats.response.plain++;\n\t\t\treturn self;\n\t\tcase CT_JSON:\n\t\t\tF.stats.response.json++;\n\t\t\treturn self;\n\t\tcase CT_HTML:\n\t\t\tF.stats.response.view++;\n\t\t\tbreak;\n\t}\n\n\tvar length = output.repository.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tvar key = output.repository[i].key;\n\t\tif (self.repository[key] === undefined)\n\t\t\tself.repository[key] = output.repository[i].value;\n\t}\n\n\tfnFrom && fnFrom.call(self);\n\n\tif (self.layoutName) {\n\t\tself.output = Buffer.from(output.content);\n\t\tself.isLayout = true;\n\t\tself.view(self.layoutName, null);\n\t} else {\n\t\tself.req.$total_success();\n\t\tres.$text();\n\t}\n\n\treturn self;\n};\n\nControllerProto.$memorize_prepare = function(key, expires, disabled, fnTo, fnFrom) {\n\n\tvar self = this;\n\tvar pk = '$memorize' + key;\n\n\tif (F.temporary.processing[pk]) {\n\t\tsetTimeout(function() {\n\t\t\t!self.req.$total_canceled && self.memorize(key, expires, disabled, fnTo, fnFrom);\n\t\t}, 500);\n\t\treturn self;\n\t}\n\n\tself.precache = function(value, contentType, headers, isView) {\n\n\t\tif (!value && !contentType && !headers) {\n\t\t\tdelete F.temporary.processing[pk];\n\t\t\tself.precache = null;\n\t\t\treturn;\n\t\t}\n\n\t\tvar options = { content: value, type: contentType || CT_TEXT, layout: self.layoutName, theme: self.themeName };\n\t\tif (headers)\n\t\t\toptions.headers = headers;\n\n\t\tif (isView) {\n\t\t\toptions.repository = [];\n\t\t\tfor (var name in self.repository) {\n\t\t\t\tvar value = self.repository[name];\n\t\t\t\tvalue !== undefined && options.repository.push({ key: name, value: value });\n\t\t\t}\n\t\t}\n\n\t\tF.cache.add(key, options, expires, false);\n\t\tself.precache = null;\n\t\tdelete F.temporary.processing[pk];\n\t};\n\n\tif (typeof(disabled) === 'function')\n\t\tfnTo = disabled;\n\n\tF.temporary.processing[pk] = true;\n\tfnTo.call(self);\n\treturn self;\n};\n\n// *********************************************************************************\n// =================================================================================\n// F.WebSocket\n// =================================================================================\n// *********************************************************************************\n\nconst NEWLINE = '\\r\\n';\nconst SOCKET_RESPONSE = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\n\\r\\n';\nconst SOCKET_RESPONSE_COMPRESS = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\nSec-WebSocket-Extensions: permessage-deflate\\r\\n\\r\\n';\nconst SOCKET_RESPONSE_PROTOCOL = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\nSec-WebSocket-Protocol: {1}\\r\\n\\r\\n';\nconst SOCKET_RESPONSE_PROTOCOL_COMPRESS = 'HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSec-WebSocket-Accept: {0}\\r\\nSec-WebSocket-Protocol: {1}\\r\\nSec-WebSocket-Extensions: permessage-deflate\\r\\n\\r\\n';\nconst SOCKET_HASH = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\nconst SOCKET_ALLOW_VERSION = [13];\n\nfunction WebSocket(path, name, id) {\n\tthis._keys = [];\n\tthis.id = id;\n\tthis.online = 0;\n\tthis.connections = {};\n\tthis.name = name;\n\tthis.isController = true;\n\tthis.url = U.path(path);\n\tthis.route = null;\n\tthis.$events = {};\n\n\t// on('open', function(client) {});\n\t// on('close', function(client) {});\n\t// on('message', function(client, message) {});\n\t// on('error', function(error, client) {});\n\t// Events.EventEmitter.call(this);\n}\n\nWebSocket.prototype = {\n\n\tget repository() {\n\t\tif (this.$repository)\n\t\t\treturn this.$repository;\n\t\telse\n\t\t\treturn this.$repository ? this.$repository : (this.$repository = {});\n\t},\n\n\tget global() {\n\t\tOBSOLETE('controller.global', 'Use: G');\n\t\treturn F.global;\n\t},\n\n\tget config() {\n\t\tOBSOLETE('controller.config', 'Use: CONF');\n\t\treturn CONF;\n\t},\n\n\tget cache() {\n\t\tOBSOLETE('controller.cache', 'Use: F.cache or CACHE()');\n\t\treturn F.cache;\n\t},\n\n\tget isDebug() {\n\t\tOBSOLETE('controller.isDebug', 'Use: DEBUG');\n\t\treturn DEBUG;\n\t},\n\n\tget path() {\n\t\tOBSOLETE('controller.path', 'Use: PATH');\n\t\treturn F.path;\n\t},\n\n\tget isSecure() {\n\t\tOBSOLETE('controller.isSecure', 'Use: controller.secured');\n\t\treturn this.req.isSecure;\n\t},\n\n\tget secured() {\n\t\treturn this.req.secured;\n\t},\n\n\tget params() {\n\t\tif (this.$params)\n\t\t\treturn this.$params;\n\t\tvar split = framework_internal.routeSplit(this.url, true);\n\t\tvar names = this.route.paramnames;\n\t\tif (names) {\n\t\t\tvar obj = {};\n\t\t\tfor (var i = 0; i < names.length; i++)\n\t\t\t\tobj[names[i]] = split[this.route.param[i]];\n\t\t\tthis.$params = obj;\n\t\t\treturn obj;\n\t\t} else {\n\t\t\tthis.$params = EMPTYOBJECT;\n\t\t\treturn EMPTYOBJECT;\n\t\t}\n\t},\n\n\tget keys() {\n\t\treturn this._keys;\n\t}\n};\n\n\nconst WebSocketProto = WebSocket.prototype;\n\nWebSocketProto.operation = function(name, value, callback, options) {\n\tOPERATION(name, value, callback, options, this);\n\treturn this;\n};\n\nWebSocketProto.emit = function(name, a, b, c, d, e, f, g) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nWebSocketProto.on = function(name, fn) {\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nWebSocketProto.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nWebSocketProto.removeListener = function(name, fn) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tthis.$events[name] = evt;\n\t\telse\n\t\t\tthis.$events[name] = undefined;\n\t}\n\treturn this;\n};\n\nWebSocketProto.removeAllListeners = function(name) {\n\tif (name === true)\n\t\tthis.$events = EMPTYOBJECT;\n\telse if (name)\n\t\tthis.$events[name] = undefined;\n\telse\n\t\tthis.$events = {};\n\treturn this;\n};\n\n/**\n * Sends a message\n * @param {String} message\n * @param {String Array or Function(id, client)} id (optional)\n * @param {String Array or Function(id, client)} blacklist (optional)\n * @param {Function(key, value)} replacer for JSON (optional)\n * @return {WebSocket}\n */\nWebSocketProto.send = function(message, id, blacklist, replacer) {\n\n\tvar self = this;\n\tvar keys = self._keys;\n\n\tif (!keys || !keys.length || message === undefined)\n\t\treturn self;\n\n\tvar data;\n\tvar raw = false;\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\n\t\tvar conn = self.connections[keys[i]];\n\n\t\tif (id) {\n\t\t\tif (id instanceof Array) {\n\t\t\t\tif (!websocket_valid_array(conn.id, id))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (id instanceof Function) {\n\t\t\t\tif (!websocket_valid_fn(conn.id, conn, id, message))\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tthrow new Error('Invalid \"id\" argument.');\n\t\t}\n\n\t\tif (blacklist) {\n\t\t\tif (blacklist instanceof Array) {\n\t\t\t\tif (websocket_valid_array(conn.id, blacklist))\n\t\t\t\t\tcontinue;\n\t\t\t} else if (blacklist instanceof Function) {\n\t\t\t\tif (websocket_valid_fn(conn.id, conn, blacklist, message))\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tthrow new Error('Invalid \"blacklist\" argument.');\n\t\t}\n\n\t\tif (data === undefined) {\n\t\t\tif (conn.type === 3) {\n\t\t\t\traw = true;\n\t\t\t\tdata = JSON.stringify(message, replacer);\n\t\t\t} else\n\t\t\t\tdata = message;\n\t\t}\n\n\t\tconn.send(data, raw);\n\t\tF.stats.response.websocket++;\n\t}\n\n\treturn self;\n};\n\nWebSocketProto.send2 = function(message, comparer, replacer, params) {\n\n\tvar self = this;\n\tvar keys = self._keys;\n\tif (!keys || !keys.length || message === undefined)\n\t\treturn self;\n\n\tif (!params && replacer != null && typeof(replacer) !== 'function') {\n\t\tparams = replacer;\n\t\treplacer = null;\n\t}\n\n\tvar data;\n\tvar raw = false;\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\n\t\tvar conn = self.connections[keys[i]];\n\n\t\tif (data === undefined) {\n\t\t\tif (conn.type === 3) {\n\t\t\t\traw = true;\n\t\t\t\tdata = JSON.stringify(message, replacer);\n\t\t\t} else\n\t\t\t\tdata = message;\n\t\t}\n\n\t\tif (comparer && !comparer(conn, message, params))\n\t\t\tcontinue;\n\n\t\tconn.send(data, raw);\n\t\tF.stats.response.websocket++;\n\t}\n\n\treturn self;\n};\n\nfunction websocket_valid_array(id, arr) {\n\treturn arr.indexOf(id) !== -1;\n}\n\nfunction websocket_valid_fn(id, client, fn, msg) {\n\treturn fn && fn(id, client, msg) ? true : false;\n}\n\n/**\n * Sends a ping message\n * @return {WebSocket}\n */\nWebSocketProto.ping = function() {\n\n\tvar keys = this._keys;\n\tif (!keys)\n\t\treturn this;\n\n\tvar length = keys.length;\n\tif (length) {\n\t\tthis.$ping = true;\n\t\tF.stats.other.websocketPing++;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tthis.connections[keys[i]].ping();\n\t}\n\n\treturn this;\n};\n\n/**\n * Closes a connection\n * @param {String Array} id Client id, optional, default `null`.\n * @param {String} message A message for the browser.\n * @param {Number} code Optional default 1000.\n * @return {Websocket}\n */\nWebSocketProto.close = function(id, message, code) {\n\n\tvar keys = this._keys;\n\n\tif (!keys)\n\t\treturn this;\n\n\tif (typeof(id) === 'string') {\n\t\tcode = message;\n\t\tmessage = id;\n\t\tid = null;\n\t}\n\n\tvar length = keys.length;\n\tif (!length)\n\t\treturn this;\n\n\tif (!id || !id.length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar _id = keys[i];\n\t\t\tthis.connections[_id].close(message, code);\n\t\t\tthis.$remove(_id);\n\t\t}\n\t\tthis.$refresh();\n\t\treturn this;\n\t}\n\n\tvar is = id instanceof Array;\n\tvar fn = typeof(id) === 'function' ? id : null;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar _id = keys[i];\n\t\tif (is && id.indexOf(_id) === -1)\n\t\t\tcontinue;\n\n\t\tvar conn = this.connections[_id];\n\t\tif (fn && !fn.call(this, _id, conn))\n\t\t\tcontinue;\n\n\t\tconn.close(message, code);\n\t\tthis.$remove(_id);\n\t}\n\n\tthis.$refresh();\n\treturn this;\n};\n\n/**\n * Error caller\n * @param {Error/String} err\n * @return {WebSocket/Function}\n */\nWebSocketProto.error = function(err) {\n\tvar result = F.error(typeof(err) === 'string' ? new Error(err) : err, this.name, this.path);\n\treturn err ? this : result;\n};\n\n/**\n * Creates a problem\n * @param {String} message\n * @return {WebSocket}\n */\nWebSocketProto.wtf = WebSocketProto.problem = function(message) {\n\tF.problem(message, this.name, this.uri);\n\treturn this;\n};\n\n/**\n * Creates a change\n * @param {String} message\n * @return {WebSocket}\n */\nWebSocketProto.change = function(message) {\n\tF.change(message, this.name, this.uri, this.ip);\n\treturn this;\n};\n\n/**\n * The method executes a provided function once per client.\n * @param {Function(connection, index)} fn\n * @return {WebSocket}\n */\nWebSocketProto.all = function(fn) {\n\tvar arr = fn == null || fn == true ? [] : null;\n\tvar self = this;\n\tif (self._keys) {\n\t\tfor (var i = 0, length = self._keys.length; i < length; i++) {\n\t\t\tif (arr)\n\t\t\t\tarr.push(self.connections[self._keys[i]]);\n\t\t\telse\n\t\t\t\tfn(self.connections[self._keys[i]], i);\n\t\t}\n\t}\n\treturn arr ? arr : self;\n};\n\n/**\n * Finds a connection\n * @param {String} id\n * @return {WebSocketClient}\n */\nWebSocketProto.find = function(id) {\n\tvar self = this;\n\n\tif (!self._keys)\n\t\treturn self;\n\n\tvar length = self._keys.length;\n\tvar isFn = typeof(id) === 'function';\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar connection = self.connections[self._keys[i]];\n\t\tif (isFn) {\n\t\t\tif (id(connection, connection.id))\n\t\t\t\treturn connection;\n\t\t} else if (connection.id === id)\n\t\t\treturn connection;\n\t}\n\treturn null;\n};\n\n/**\n * Destroys a WebSocket controller\n * @param {String} problem Optional.\n * @return {WebSocket}\n */\nWebSocketProto.destroy = function(problem) {\n\tvar self = this;\n\n\tproblem && self.problem(problem);\n\tif (!self.connections && !self._keys)\n\t\treturn self;\n\n\tself.close();\n\tself.$events.destroy && self.emit('destroy');\n\n\tsetTimeout(function() {\n\n\t\tfor (var i = 0; i < self._keys.length; i++) {\n\t\t\tvar key = self._keys[i];\n\t\t\tvar conn = self.connections[key];\n\t\t\tif (conn) {\n\t\t\t\tconn._isClosed = true;\n\t\t\t\tconn.socket.removeAllListeners();\n\t\t\t}\n\t\t}\n\n\t\tself.connections = null;\n\t\tself._keys = null;\n\t\tself.route = null;\n\t\tself.buffer = null;\n\t\tdelete F.connections[self.id];\n\t\tself.removeAllListeners();\n\n\t}, 1000);\n\n\treturn self;\n};\n\n/**\n * Enables auto-destroy websocket controller when any user is not online\n * @param {Function} callback\n * @return {WebSocket]\n */\nWebSocketProto.autodestroy = function(callback) {\n\tvar self = this;\n\tvar key = 'websocket:' + self.id;\n\tself.on('open', () => clearTimeout2(key));\n\tself.on('close', function() {\n\t\t!self.online && setTimeout2(key, function() {\n\t\t\tcallback && callback.call(self);\n\t\t\tself.destroy();\n\t\t}, 5000);\n\t});\n\treturn self;\n};\n\n/**\n * Internal function\n * @return {WebSocket}\n */\nWebSocketProto.$refresh = function() {\n\tif (this.connections) {\n\t\tthis._keys = Object.keys(this.connections);\n\t\tthis.online = this._keys.length;\n\t} else\n\t\tthis.online = 0;\n\treturn this;\n};\n\n/**\n * Internal function\n * @param {String} id\n * @return {WebSocket}\n */\nWebSocketProto.$remove = function(id) {\n\tif (this.connections)\n\t\tdelete this.connections[id];\n\treturn this;\n};\n\n/**\n * Internal function\n * @param {WebSocketClient} client\n * @return {WebSocket}\n */\nWebSocketProto.$add = function(client) {\n\tthis.connections[client._id] = client;\n\treturn this;\n};\n\n/**\n * A resource header\n * @param {String} name A resource name.\n * @param {String} key A resource key.\n * @return {String}\n */\nWebSocketProto.resource = function(name, key) {\n\treturn F.resource(name, key);\n};\n\nWebSocketProto.log = function() {\n\tF.log.apply(framework, arguments);\n\treturn this;\n};\n\nWebSocketProto.logger = function() {\n\tF.logger.apply(framework, arguments);\n\treturn this;\n};\n\nWebSocketProto.check = function() {\n\tthis.$ping && this.all(websocketcheck_ping);\n\treturn this;\n};\n\nfunction websocketcheck_ping(client) {\n\tif (!client.$ping) {\n\t\tclient.close();\n\t\tF.stats.other.websocketCleaner++;\n\t}\n}\n\n/**\n * WebSocket controller\n * @param {Request} req\n * @param {Socket} socket\n */\nfunction WebSocketClient(req, socket) {\n\tthis.$ping = true;\n\tthis.container;\n\tthis._id;\n\tthis.id = '';\n\tthis.socket = socket;\n\tthis.req = req;\n\n\t// this.isClosed = false;\n\tthis.errors = 0;\n\tthis.length = 0;\n\tthis.current = {};\n\n\t// 1 = raw - not implemented\n\t// 2 = plain\n\t// 3 = JSON\n\n\tthis.type = 2;\n\t// this._isClosed = false;\n}\n\nWebSocketClient.prototype = {\n\n\tget protocol() {\n\t\treturn (this.req.headers['sec-websocket-protocol'] || '').replace(REG_EMPTY, '').split(',');\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget get() {\n\t\treturn this.req.query;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t},\n\n\tget headers() {\n\t\treturn this.req.headers;\n\t},\n\n\tget uri() {\n\t\treturn this.req.uri;\n\t},\n\n\tget config() {\n\t\tOBSOLETE('controller.config', 'Use: CONF');\n\t\treturn this.container.config;\n\t},\n\n\tget global() {\n\t\tOBSOLETE('controller.global', 'Use: G');\n\t\treturn this.container.global;\n\t},\n\n\tget sessionid() {\n\t\treturn this.req.sessionid;\n\t},\n\n\tget session() {\n\t\treturn this.req.session;\n\t},\n\n\tset session(value) {\n\t\tthis.req.session = value;\n\t},\n\n\tget user() {\n\t\treturn this.req.user;\n\t},\n\n\tset user(value) {\n\t\tthis.req.user = value;\n\t},\n\n\tget mobile() {\n\t\treturn this.req.mobile;\n\t}\n};\n\nconst WebSocketClientProto = WebSocketClient.prototype;\n\nWebSocketClientProto.isWebSocket = true;\n\nWebSocketClientProto.cookie = function(name) {\n\treturn this.req.cookie(name);\n};\n\nWebSocketClientProto.$close = function(code, message) {\n\n\tvar self = this;\n\n\tif ((self.req.headers['user-agent'] || '').indexOf('Total.js') !== -1) {\n\t\tself.close();\n\t\treturn;\n\t}\n\n\tvar header = SOCKET_RESPONSE.format(self.$websocket_key(self.req));\n\tself.socket.write(Buffer.from(header, 'binary'));\n\tself.ready = true;\n\tself.close(message, code);\n\n\tsetTimeout(function(self) {\n\t\tself.req = null;\n\t\tself.socket = null;\n\t}, 1000, self);\n\n\treturn self;\n};\n\nWebSocketClientProto.prepare = function(flags, protocols, allow, length) {\n\n\tflags = flags || EMPTYARRAY;\n\tprotocols = protocols || EMPTYARRAY;\n\tallow = allow || EMPTYARRAY;\n\n\tvar self = this;\n\n\tif (SOCKET_ALLOW_VERSION.indexOf(U.parseInt(self.req.headers['sec-websocket-version'])) === -1)\n\t\treturn false;\n\n\tself.length = length;\n\n\tvar origin = self.req.headers.origin || '';\n\tvar length = allow.length;\n\n\tif (length && allow.indexOf('*') === -1) {\n\t\tvar is = false;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (origin.indexOf(allow[i]) !== -1) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\treturn false;\n\t}\n\n\tlength = protocols.length;\n\tif (length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (self.protocol.indexOf(protocols[i]) === -1)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tvar compress = (CONF.allow_websocket_compression && self.req.headers['sec-websocket-extensions'] || '').indexOf('permessage-deflate') !== -1;\n\tvar header = protocols.length ? (compress ? SOCKET_RESPONSE_PROTOCOL_COMPRESS : SOCKET_RESPONSE_PROTOCOL).format(self.$websocket_key(self.req), protocols.join(', ')) : (compress ? SOCKET_RESPONSE_COMPRESS : SOCKET_RESPONSE).format(self.$websocket_key(self.req));\n\n\tself.socket.write(Buffer.from(header, 'binary'));\n\tself.ready = true;\n\n\tif (compress) {\n\t\tself.inflatepending = [];\n\t\tself.inflatelock = false;\n\t\tself.inflate = Zlib.createInflateRaw(WEBSOCKET_COMPRESS_OPTIONS);\n\t\tself.inflate.$websocket = self;\n\t\tself.inflate.on('error', function() {\n\t\t\tif (!self.$uerror) {\n\t\t\t\tself.$uerror = true;\n\t\t\t\tself.close('Invalid data', 1003);\n\t\t\t}\n\t\t});\n\t\tself.inflate.on('data', websocket_inflate);\n\n\t\tself.deflatepending = [];\n\t\tself.deflatelock = false;\n\t\tself.deflate = Zlib.createDeflateRaw(WEBSOCKET_COMPRESS_OPTIONS);\n\t\tself.deflate.$websocket = self;\n\t\tself.deflate.on('error', function() {\n\t\t\tif (!self.$uerror) {\n\t\t\t\tself.$uerror = true;\n\t\t\t\tself.close('Invalid data', 1003);\n\t\t\t}\n\t\t});\n\t\tself.deflate.on('data', websocket_deflate);\n\t}\n\n\tself._id = Date.now() + U.GUID(5);\n\tself.id = self._id;\n\treturn true;\n};\n\nfunction websocket_inflate(data) {\n\tvar ws = this.$websocket;\n\tif (ws && ws.inflatechunks) {\n\t\tws.inflatechunks.push(data);\n\t\tws.inflatechunkslength += data.length;\n\t}\n}\n\nfunction websocket_deflate(data) {\n\tvar ws = this.$websocket;\n\tif (ws && ws.deflatechunks) {\n\t\tws.deflatechunks.push(data);\n\t\tws.deflatechunkslength += data.length;\n\t}\n}\n\n/**\n * Add a container to client\n * @param {WebSocket} container\n * @return {WebSocketClient}\n */\nWebSocketClientProto.upgrade = function(container) {\n\tvar self = this;\n\tself.req.on('error', websocket_onerror);\n\tself.container = container;\n\tself.socket.$websocket = this;\n\tself.socket.on('data', websocket_ondata);\n\tself.socket.on('error', websocket_onerror);\n\tself.socket.on('close', websocket_close);\n\tself.socket.on('end', websocket_close);\n\tself.container.$add(self);\n\tself.container.$refresh();\n\tF.$events['websocket-begin'] && EMIT('websocket-begin', self.container, self);\n\tF.$events.websocket_begin && EMIT('websocket_begin', self.container, self);\n\tself.container.$events.open && self.container.emit('open', self);\n\tF.stats.performance.online++;\n\treturn self;\n};\n\nfunction websocket_ondata(chunk) {\n\tthis.$websocket.$ondata(chunk);\n}\n\nfunction websocket_onerror(e) {\n\tthis.destroy && this.destroy();\n\tthis.$websocket.$onerror(e);\n}\n\nfunction websocket_close() {\n\tthis.destroy && this.destroy();\n\tthis.$websocket.$onclose();\n}\n\nWebSocketClientProto.$ondata = function(data) {\n\n\tvar self = this;\n\n\tif (self.isClosed)\n\t\treturn;\n\n\tvar current = self.current;\n\n\tif (data) {\n\t\tif (current.buffer) {\n\t\t\tCONCAT[0] = current.buffer;\n\t\t\tCONCAT[1] = data;\n\t\t\tcurrent.buffer = Buffer.concat(CONCAT);\n\t\t} else\n\t\t\tcurrent.buffer = data;\n\t}\n\n\tif (!self.$parse())\n\t\treturn;\n\n\tif (!current.final && current.type !== 0x00)\n\t\tcurrent.type2 = current.type;\n\n\tvar decompress = current.compressed && self.inflate;\n\tvar tmp;\n\n\tswitch (current.type === 0x00 ? current.type2 : current.type) {\n\t\tcase 0x01:\n\n\t\t\t// text\n\t\t\tif (decompress) {\n\t\t\t\tcurrent.final && self.parseInflate();\n\t\t\t} else {\n\t\t\t\ttmp = self.$readbody();\n\t\t\t\tif (current.body) {\n\t\t\t\t\tCONCAT[0] = current.body;\n\t\t\t\t\tCONCAT[1] = tmp;\n\t\t\t\t\tcurrent.body = Buffer.concat(CONCAT);\n\t\t\t\t} else\n\t\t\t\t\tcurrent.body = tmp;\n\t\t\t\tcurrent.final && self.$decode();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x02:\n\n\t\t\t// binary\n\t\t\tif (decompress) {\n\t\t\t\tcurrent.final && self.parseInflate();\n\t\t\t} else {\n\t\t\t\ttmp = self.$readbody();\n\t\t\t\tif (current.body) {\n\t\t\t\t\tCONCAT[0] = current.body;\n\t\t\t\t\tCONCAT[1] = tmp;\n\t\t\t\t\tcurrent.body = Buffer.concat(CONCAT);\n\t\t\t\t} else\n\t\t\t\t\tcurrent.body = tmp;\n\t\t\t\tcurrent.final && self.$decode();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\t\t\t// close\n\t\t\tself.closemessage = current.buffer.slice(4).toString('utf8');\n\t\t\tself.closecode = current.buffer[2] << 8 | current.buffer[3];\n\n\t\t\tif (self.closemessage && self.container.encodedecode)\n\t\t\t\tself.closemessage = $decodeURIComponent(self.closemessage);\n\n\t\t\tself.close();\n\t\t\tbreak;\n\n\t\tcase 0x09:\n\t\t\t// ping, response pong\n\t\t\tself.socket.write(U.getWebSocketFrame(0, 'PONG', 0x0A));\n\t\t\tcurrent.buffer = null;\n\t\t\tcurrent.inflatedata = null;\n\t\t\tself.$ping = true;\n\t\t\tbreak;\n\n\t\tcase 0x0a:\n\t\t\t// pong\n\t\t\tself.$ping = true;\n\t\t\tcurrent.buffer = null;\n\t\t\tcurrent.inflatedata = null;\n\t\t\tbreak;\n\t}\n\n\tif (current.buffer) {\n\t\tcurrent.buffer = current.buffer.slice(current.length, current.buffer.length);\n\t\tcurrent.buffer.length && self.$ondata();\n\t}\n};\n\nfunction buffer_concat(buffers, length) {\n\tvar buffer = Buffer.alloc(length);\n\tvar offset = 0;\n\tfor (var i = 0, n = buffers.length; i < n; i++) {\n\t\tbuffers[i].copy(buffer, offset);\n\t\toffset += buffers[i].length;\n\t}\n\treturn buffer;\n}\n\n// MIT\n// Written by Jozef Gula\n// Optimized by Peter Sirka\nWebSocketClientProto.$parse = function() {\n\n\tvar self = this;\n\tvar current = self.current;\n\n\t// check end message\n\n\t// Long messages doesn't work because 0x80 still returns 0\n\t// if (!current.buffer || current.buffer.length <= 2 || ((current.buffer[0] & 0x80) >> 7) !== 1)\n\tif (!current.buffer || current.buffer.length <= 2)\n\t\treturn;\n\n\t// WebSocket - Opcode\n\tcurrent.type = current.buffer[0] & 0x0f;\n\tcurrent.compressed = (current.buffer[0] & 0x40) === 0x40;\n\n\t// is final message?\n\tcurrent.final = ((current.buffer[0] & 0x80) >> 7) === 0x01;\n\n\t// does frame contain mask?\n\tcurrent.isMask = ((current.buffer[1] & 0xfe) >> 7) === 0x01;\n\n\t// data length\n\tvar length = U.getMessageLength(current.buffer, F.isLE);\n\t// index for data\n\n\t// Solving a problem with The value \"-1\" is invalid for option \"size\"\n\tif (length <= 0)\n\t\treturn;\n\n\tvar index = current.buffer[1] & 0x7f;\n\tindex = ((index === 126) ? 4 : (index === 127 ? 10 : 2)) + (current.isMask ? 4 : 0);\n\n\t// total message length (data + header)\n\tvar mlength = index + length;\n\n\tif (mlength > this.length) {\n\t\tthis.close('Frame is too large', 1009);\n\t\treturn;\n\t}\n\n\t// Check length of data\n\tif (current.buffer.length < mlength)\n\t\treturn;\n\n\tcurrent.length = mlength;\n\n\t// Not Ping & Pong\n\tif (current.type !== 0x09 && current.type !== 0x0A) {\n\n\t\t// does frame contain mask?\n\t\tif (current.isMask) {\n\t\t\tcurrent.mask = Buffer.alloc(4);\n\t\t\tcurrent.buffer.copy(current.mask, 0, index - 4, index);\n\t\t}\n\n\t\tif (current.compressed && this.inflate) {\n\n\t\t\tvar buf = Buffer.alloc(length);\n\t\t\tcurrent.buffer.copy(buf, 0, index, mlength);\n\n\t\t\t// does frame contain mask?\n\t\t\tif (current.isMask) {\n\t\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\t\tbuf[i] = buf[i] ^ current.mask[i % 4];\n\t\t\t}\n\n\t\t\t// Does the buffer continue?\n\t\t\tbuf.$continue = current.final === false;\n\t\t\tthis.inflatepending.push(buf);\n\t\t} else {\n\t\t\tcurrent.data = Buffer.alloc(length);\n\t\t\tcurrent.buffer.copy(current.data, 0, index, mlength);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nWebSocketClientProto.$readbody = function() {\n\tvar current = this.current;\n\tvar length = current.data.length;\n\tvar buf = Buffer.alloc(length);\n\tfor (var i = 0; i < length; i++) {\n\t\t// does frame contain mask?\n\t\tif (current.isMask)\n\t\t\tbuf[i] = current.data[i] ^ current.mask[i % 4];\n\t\telse\n\t\t\tbuf[i] = current.data[i];\n\t}\n\treturn buf;\n};\n\nWebSocketClientProto.$decode = function() {\n\n\tvar data = this.current.body;\n\tF.stats.performance.message++;\n\n\t// Buffer\n\tif (this.typebuffer) {\n\t\tthis.container.emit('message', this, data);\n\t\treturn;\n\t}\n\n\tswitch (this.type) {\n\n\t\tcase 1: // BINARY\n\t\t\t// this.container.emit('message', this, new Uint8Array(data).buffer);\n\t\t\tthis.container.emit('message', this, data);\n\t\t\tbreak;\n\n\t\tcase 3: // JSON\n\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tdata = data.toString(ENCODING);\n\n\t\t\tif (this.container.encodedecode === true)\n\t\t\t\tdata = $decodeURIComponent(data);\n\n\t\t\tif (data.isJSON()) {\n\t\t\t\tvar tmp = F.onParseJSON(data, this.req);\n\t\t\t\tif (tmp !== undefined)\n\t\t\t\t\tthis.container.emit('message', this, tmp);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault: // TEXT\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tdata = data.toString(ENCODING);\n\t\t\tthis.container.emit('message', this, this.container.encodedecode === true ? $decodeURIComponent(data) : data);\n\t\t\tbreak;\n\t}\n\n\tthis.current.body = null;\n};\n\nWebSocketClientProto.parseInflate = function() {\n\tvar self = this;\n\n\tif (self.inflatelock)\n\t\treturn;\n\n\tvar buf = self.inflatepending.shift();\n\tif (buf) {\n\t\tself.inflatechunks = [];\n\t\tself.inflatechunkslength = 0;\n\t\tself.inflatelock = true;\n\t\tself.inflate.write(buf);\n\t\t!buf.$continue && self.inflate.write(Buffer.from(WEBSOCKET_COMPRESS));\n\t\tself.inflate.flush(function() {\n\n\t\t\tif (!self.inflatechunks)\n\t\t\t\treturn;\n\n\t\t\tvar data = buffer_concat(self.inflatechunks, self.inflatechunkslength);\n\n\t\t\tself.inflatechunks = null;\n\t\t\tself.inflatelock = false;\n\n\t\t\tif (data.length > self.length) {\n\t\t\t\tself.close('Frame is too large', 1009);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (self.current.body) {\n\t\t\t\tCONCAT[0] = self.current.body;\n\t\t\t\tCONCAT[1] = data;\n\t\t\t\tself.current.body = Buffer.concat(CONCAT);\n\t\t\t} else\n\t\t\t\tself.current.body = data;\n\n\t\t\t!buf.$continue && self.$decode();\n\t\t\tself.parseInflate();\n\t\t});\n\t}\n};\n\nWebSocketClientProto.$onerror = function(err) {\n\n\tif (this.isClosed)\n\t\treturn;\n\n\tif (REG_WEBSOCKET_ERROR.test(err.stack)) {\n\t\tthis.isClosed = true;\n\t\tthis.$onclose();\n\t} else\n\t\tthis.container.$events.error && this.container.emit('error', err, this);\n};\n\nWebSocketClientProto.$onclose = function() {\n\n\tif (this._isClosed)\n\t\treturn;\n\n\tF.stats.performance.online--;\n\tthis.isClosed = true;\n\tthis._isClosed = true;\n\n\tif (this.inflate) {\n\t\tthis.inflate.removeAllListeners();\n\t\tthis.inflate = null;\n\t\tthis.inflatechunks = null;\n\t}\n\n\tif (this.deflate) {\n\t\tthis.deflate.removeAllListeners();\n\t\tthis.deflate = null;\n\t\tthis.deflatechunks = null;\n\t}\n\n\tthis.container.$remove(this._id);\n\tthis.container.$refresh();\n\tthis.container.$events.close && this.container.emit('close', this, this.closecode, this.closemessage);\n\tthis.socket.removeAllListeners();\n\tF.$events['websocket-end'] && EMIT('websocket-end', this.container, this);\n\tF.$events.websocket_end && EMIT('websocket_end', this.container, this);\n};\n\n/**\n * Sends a message\n * @param {String/Object} message\n * @param {Boolean} raw The message won't be converted e.g. to JSON.\n * @return {WebSocketClient}\n */\nWebSocketClientProto.send = function(message, raw, replacer) {\n\n\tvar self = this;\n\n\tif (self.isClosed)\n\t\treturn self;\n\n\tif (self.type !== 1) {\n\t\tvar data = self.type === 3 ? (raw ? message : JSON.stringify(message, replacer)) : typeof(message) === 'object' ? JSON.stringify(message, replacer) : message.toString();\n\t\tif (self.container.encodedecode === true && data)\n\t\t\tdata = encodeURIComponent(data);\n\t\tif (self.deflate) {\n\t\t\tself.deflatepending.push(Buffer.from(data));\n\t\t\tself.sendDeflate();\n\t\t} else\n\t\t\tself.socket.write(U.getWebSocketFrame(0, data, 0x01));\n\t} else if (message) {\n\t\tif (self.deflate) {\n\t\t\tself.deflatepending.push(Buffer.from(message));\n\t\t\tself.sendDeflate();\n\t\t} else\n\t\t\tself.socket.write(U.getWebSocketFrame(0, new Int8Array(message), 0x02));\n\t}\n\n\treturn self;\n};\n\nWebSocketClientProto.sendDeflate = function() {\n\tvar self = this;\n\n\tif (self.deflatelock)\n\t\treturn;\n\n\tvar buf = self.deflatepending.shift();\n\tif (buf) {\n\t\tself.deflatechunks = [];\n\t\tself.deflatechunkslength = 0;\n\t\tself.deflatelock = true;\n\t\tself.deflate.write(buf);\n\t\tself.deflate.flush(function() {\n\t\t\tif (self.deflatechunks) {\n\t\t\t\tvar data = buffer_concat(self.deflatechunks, self.deflatechunkslength);\n\t\t\t\tdata = data.slice(0, data.length - 4);\n\t\t\t\tself.deflatelock = false;\n\t\t\t\tself.deflatechunks = null;\n\t\t\t\tself.socket.write(U.getWebSocketFrame(0, data, self.type === 1 ? 0x02 : 0x01, true));\n\t\t\t\tself.sendDeflate();\n\t\t\t}\n\t\t});\n\t}\n};\n\n/**\n * Ping message\n * @return {WebSocketClient}\n */\nWebSocketClientProto.ping = function() {\n\tif (!this.isClosed) {\n\t\tthis.socket.write(U.getWebSocketFrame(0, 'PING', 0x09));\n\t\tthis.$ping = false;\n\t}\n\treturn this;\n};\n\n/**\n * Close connection\n * @param {String} message Message.\n * @param {Number} code WebSocket code.\n * @return {WebSocketClient}\n */\nWebSocketClientProto.close = function(message, code) {\n\tvar self = this;\n\tif (!self.isClosed) {\n\t\tself.isClosed = true;\n\t\tif (self.ready) {\n\t\t\tif (message && self.container && self.container.encodedecode)\n\t\t\t\tmessage = encodeURIComponent(message);\n\t\t\tself.socket.end(U.getWebSocketFrame(code || 1000, message || '', 0x08));\n\t\t} else\n\t\t\tself.socket.end();\n\t\tself.req.connection.destroy();\n\t}\n\treturn self;\n};\n\n/**\n * Create a signature for the WebSocket\n * @param {Request} req\n * @return {String}\n */\nWebSocketClientProto.$websocket_key = function(req) {\n\tvar sha1 = Crypto.createHash('sha1');\n\tsha1.update((req.headers['sec-websocket-key'] || '') + SOCKET_HASH);\n\treturn sha1.digest('base64');\n};\n\n// *********************************************************************************\n// =================================================================================\n// Prototypes\n// =================================================================================\n// *********************************************************************************\n\nfunction req_authorizecallback(isAuthorized, user, $) {\n\n\t// @isAuthorized \"null\" for callbacks(err, user)\n\t// @isAuthorized \"true\"\n\t// @isAuthorized \"object\" is as user but \"user\" must be \"undefined\"\n\n\tif (isAuthorized instanceof Error || isAuthorized instanceof ErrorBuilder) {\n\t\t// Error handling\n\t\tisAuthorized = false;\n\t} else if (isAuthorized == null && user) {\n\t\t// A callback error handling\n\t\tisAuthorized = true;\n\t} else if (user == null && isAuthorized && isAuthorized !== true) {\n\t\tuser = isAuthorized;\n\t\tisAuthorized = true;\n\t}\n\n\t$.req.isAuthorized = isAuthorized;\n\t$.req.authorizecallback(null, user, isAuthorized);\n\t$.req.authorizecallback = null;\n}\n\nfunction req_authorizetotal(isAuthorized, user, $) {\n\n\t// @isAuthorized \"null\" for callbacks(err, user)\n\t// @isAuthorized \"true\"\n\t// @isAuthorized \"object\" is as user but \"user\" must be \"undefined\"\n\n\tvar req = $.req;\n\tvar roles = req.flagslength !== req.flags.length;\n\n\tif (roles) {\n\t\treq.$flags += req.flags.slice(req.flagslength).join('');\n\t\treq.$roles = true;\n\t}\n\n\treq.flagslength = undefined;\n\n\tif (isAuthorized instanceof Error || isAuthorized instanceof ErrorBuilder) {\n\t\t// Error handling\n\t\tisAuthorized = false;\n\t} else if (isAuthorized == null && user) {\n\t\t// A callback error handling\n\t\tisAuthorized = true;\n\t} else if (user == null && isAuthorized && isAuthorized !== true) {\n\t\tuser = isAuthorized;\n\t\tisAuthorized = true;\n\t}\n\n\treq.isAuthorized = isAuthorized;\n\treq.$total_authorize(isAuthorized, user, roles);\n}\n\nfunction extend_request(PROTO) {\n\n\tPROTOREQ = PROTO;\n\n\tObject.defineProperty(PROTO, 'ip', {\n\t\tget: function() {\n\t\t\tif (this._ip)\n\t\t\t\treturn this._ip;\n\n\t\t\t//  x-forwarded-for: client, proxy1, proxy2, ...\n\t\t\tvar proxy = this.headers['x-forwarded-for'];\n\t\t\tif (proxy)\n\t\t\t\tthis._ip = proxy.split(',', 1)[0] || this.connection.remoteAddress;\n\t\t\telse if (!this._ip)\n\t\t\t\tthis._ip = this.connection.remoteAddress;\n\n\t\t\treturn this._ip;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'query', {\n\t\tget: function() {\n\t\t\t!this._querydata && F.$onParseQueryUrl(this);\n\t\t\treturn this._querydata;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis._querydata = value;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'subdomain', {\n\t\tget: function() {\n\t\t\tif (this._subdomain)\n\t\t\t\treturn this._subdomain;\n\t\t\tvar subdomain = this.uri.hostname.toLowerCase().replace(REG_WWW, '').split('.');\n\t\t\tif (subdomain.length > 2) // example: [subdomain].domain.com\n\t\t\t\tthis._subdomain = subdomain.slice(0, subdomain.length - 2);\n\t\t\telse if (subdomain.length > 1 && subdomain[subdomain.length - 1] === 'localhost') // example: [subdomain].localhost\n\t\t\t\tthis._subdomain = subdomain.slice(0, subdomain.length - 1);\n\t\t\telse\n\t\t\t\tthis._subdomain = null;\n\t\t\treturn this._subdomain;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'host', {\n\t\tget: function() {\n\t\t\treturn this.headers['host'];\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'split', {\n\t\tget: function() {\n\t\t\treturn this.$path ? this.$path : this.$path = framework_internal.routeSplit(this.uri.pathname, true);\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'secured', {\n\t\tget: function() {\n\t\t\treturn this.uri.protocol === 'https:' || this.uri.protocol === 'wss:';\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'language', {\n\t\tget: function() {\n\t\t\tif (!this.$language)\n\t\t\t\tthis.$language = (((this.headers['accept-language'] || '').split(';')[0] || '').split(',')[0] || '').toLowerCase();\n\t\t\treturn this.$language;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.$language = value;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'ua', {\n\t\tget: function() {\n\t\t\tif (this.$ua === undefined)\n\t\t\t\tthis.$ua = (this.headers['user-agent'] || '').parseUA();\n\t\t\treturn this.$ua;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'mobile', {\n\t\tget: function() {\n\t\t\tif (this.$mobile === undefined)\n\t\t\t\tthis.$mobile = REG_MOBILE.test(this.headers['user-agent']);\n\t\t\treturn this.$mobile;\n\t\t}\n\t});\n\n\tObject.defineProperty(PROTO, 'robot', {\n\t\tget: function() {\n\t\t\tif (this.$robot === undefined)\n\t\t\t\tthis.$robot = REG_ROBOT.test(this.headers['user-agent']);\n\t\t\treturn this.$robot;\n\t\t}\n\t});\n\n\t/**\n\t * Signature request (user-agent + ip + referer + current URL + custom key)\n\t * @param {String} key Custom key.\n\t * @return {Request}\n\t */\n\tPROTO.signature = function(key) {\n\t\treturn F.encrypt((this.headers['user-agent'] || '') + '#' + this.ip + '#' + this.url + '#' + (key || ''), 'request-signature', false);\n\t};\n\n\tPROTO.localize = function() {\n\t\tF.onLocale && (this.$language = F.onLocale(this, this.res, this.isStaticFile));\n\t\treturn this.$language;\n\t};\n\n\t/**\n\t * Disable HTTP cache for current request\n\t * @return {Request}\n\t */\n\tPROTO.noCache = PROTO.nocache = function() {\n\t\tthis.res && this.res.noCache();\n\t\treturn this;\n\t};\n\n\tPROTO.useragent = function(structured) {\n\t\tvar key = structured ? '$ua2' : '$ua';\n\t\treturn this[key] ? this[key] : this[key] = (this.headers['user-agent'] || '').parseUA(structured);\n\t};\n\n\t/**\n\t * Read a cookie from current request\n\t * @param {String} name Cookie name.\n\t * @return {String} Cookie value (default: '')\n\t */\n\tPROTO.cookie = function(name) {\n\n\t\tif (this.cookies)\n\t\t\treturn $decodeURIComponent(this.cookies[name] || '');\n\n\t\tvar cookie = this.headers['cookie'];\n\t\tif (!cookie)\n\t\t\treturn '';\n\n\t\tthis.cookies = {};\n\n\t\tvar arr = cookie.split(';');\n\n\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\tvar line = arr[i].trim();\n\t\t\tvar index = line.indexOf('=');\n\t\t\tif (index !== -1)\n\t\t\t\tthis.cookies[line.substring(0, index)] = line.substring(index + 1);\n\t\t}\n\n\t\treturn $decodeURIComponent(this.cookies[name] || '');\n\t};\n\n\t/**\n\t * Read authorization header\n\t * @return {Object}\n\t */\n\tPROTO.authorization = function() {\n\n\t\tvar authorization = this.headers['authorization'];\n\t\tif (!authorization)\n\t\t\treturn HEADERS.authorization;\n\n\t\tvar result = { user: '', password: '', empty: true };\n\n\t\ttry {\n\t\t\tvar arr = Buffer.from(authorization.replace('Basic ', '').trim(), 'base64').toString(ENCODING).split(':');\n\t\t\tresult.user = arr[0] || '';\n\t\t\tresult.password = arr[1] || '';\n\t\t\tresult.empty = !result.user || !result.password;\n\t\t} catch (e) {}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * Authorization for custom delegates\n\t * @param  {Function(err, userprofile, isAuthorized)} callback\n\t * @return {Request}\n\t */\n\tPROTO.authorize = function(callback) {\n\n\t\tvar req = this;\n\n\t\tif (!F.onAuthorize) {\n\t\t\tcallback(null, null, false);\n\t\t\treturn req;\n\t\t}\n\n\t\tif (F.onAuthorize.$newversion) {\n\t\t\treq.authorizecallback = callback;\n\t\t\tF.onAuthorize(req, req.res, req.flags, req_authorizecallback);\n\t\t\treturn req;\n\t\t}\n\n\t\tF.onAuthorize(req, req.res, req.flags || [], function(isAuthorized, user) {\n\n\t\t\tif (!F.onAuthorize.isobsolete) {\n\t\t\t\tF.onAuthorize.isobsolete = 1;\n\t\t\t\tOBSOLETE('F.onAuthorize', 'You need to use a new authorization declaration: \"AUTH(function($) {})\"');\n\t\t\t}\n\n\t\t\t// @isAuthorized \"null\" for callbacks(err, user)\n\t\t\t// @isAuthorized \"true\"\n\t\t\t// @isAuthorized \"object\" is as user but \"user\" must be \"undefined\"\n\n\t\t\tif (isAuthorized instanceof Error || isAuthorized instanceof ErrorBuilder) {\n\t\t\t\t// Error handling\n\t\t\t\tisAuthorized = false;\n\t\t\t} else if (isAuthorized == null && user) {\n\t\t\t\t// A callback error handling\n\t\t\t\tisAuthorized = true;\n\t\t\t} else if (user == null && isAuthorized && isAuthorized !== true) {\n\t\t\t\tuser = isAuthorized;\n\t\t\t\tisAuthorized = true;\n\t\t\t}\n\n\t\t\treq.isAuthorized = isAuthorized;\n\t\t\tcallback(null, user, isAuthorized);\n\t\t});\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Clear all uplaoded files\n\t * @private\n\t * @param {Boolean} isAuto\n\t * @return {Request}\n\t */\n\tPROTO.clear = function(isAuto) {\n\n\t\tvar self = this;\n\t\tvar files = self.files;\n\n\t\tif (!files || (isAuto && self._manual))\n\t\t\treturn self;\n\n\t\tself.body = null;\n\t\tself.query = null;\n\t\tself.cookies = null;\n\n\t\tvar length = files.length;\n\t\tif (!length)\n\t\t\treturn self;\n\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tfiles[i].rem && arr.push(files[i].path);\n\n\t\tF.unlink(arr);\n\t\tself.files = null;\n\t\treturn self;\n\t};\n\n\t/**\n\t * Get host name from URL\n\t * @param {String} path Additional path.\n\t * @return {String}\n\t */\n\tPROTO.hostname = function(path) {\n\n\t\tvar self = this;\n\t\tvar uri = self.uri;\n\n\t\tif (path && path[0] !== '/')\n\t\t\tpath = '/' + path;\n\n\t\treturn uri.protocol + '//' + uri.hostname + (uri.port && uri.port !== 80 ? ':' + uri.port : '') + (path || '');\n\t};\n\n\tPROTO.filecache = function(callback) {\n\t\tF.exists(this, this.res, 20, callback);\n\t};\n\n\tPROTO.$total_success = function() {\n\t\tthis.$total_timeout && clearTimeout(this.$total_timeout);\n\t\tthis.$total_canceled = true;\n\t\tif (this.controller) {\n\t\t\tthis.controller.res.controller = null;\n\t\t\tthis.controller = null;\n\t\t}\n\t};\n\n\tPROTO.$total_file = function() {\n\t\tvar h = this.method[0];\n\t\tif (h === 'G' || h === 'H')\n\t\t\tthis.$total_endfile();\n\t\telse\n\t\t\tthis.on('end', this.$total_endfile);\n\t};\n\n\tPROTO.$total_multipart = function(header) {\n\t\tF.stats.request.upload++;\n\t\tthis.$total_route = F.lookup(this, this.uri.pathname, this.flags, 0);\n\t\tthis.$total_header = header;\n\t\tif (this.$total_route) {\n\t\t\tF.path.verify('temp');\n\t\t\tframework_internal.parseMULTIPART(this, header, this.$total_route, CONF.directory_temp);\n\t\t} else\n\t\t\tthis.$total_status(404);\n\t};\n\n\tPROTO.$total_urlencoded = function() {\n\t\tthis.$total_route = F.lookup(this, this.uri.pathname, this.flags, 0);\n\t\tif (this.$total_route) {\n\t\t\tthis.buffer_has = true;\n\t\t\tthis.buffer_exceeded = false;\n\t\t\tthis.on('data', this.$total_parsebody);\n\t\t\tthis.$total_end();\n\t\t} else\n\t\t\tthis.$total_status(404);\n\t};\n\n\tPROTO.$total_status = function(status) {\n\n\t\tif (status == null)\n\t\t\tF.stats.request.blocked++;\n\t\telse\n\t\t\tF.stats.request['error' + status]++;\n\n\t\tF.reqstats(false, false);\n\t\tthis.res.writeHead(status);\n\t\tthis.res.end(U.httpStatus(status));\n\t\tF.$events['request-end'] && EMIT('request-end', this, this.res);\n\t\tF.$events.request_end && EMIT('request_end', this, this.res);\n\t\tthis.clear(true);\n\t};\n\n\tPROTO.$total_end = function() {\n\t\tvar h = this.method[0];\n\t\tif (h === 'G' || h === 'H' || h === 'O') {\n\t\t\tif (this.$total_route && this.$total_route.schema)\n\t\t\t\tthis.$total_schema = true;\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_prepare();\n\t\t} else\n\t\t\tthis.on('end', this.$total_end2);\n\t};\n\n\tPROTO.$total_execute = function(status, isError) {\n\n\t\tvar route = this.$total_route;\n\t\tvar res = this.res;\n\n\t\tif (isError || !route) {\n\t\t\tvar key = 'error' + status;\n\t\t\tF.stats.response[key]++;\n\t\t\tstatus !== 500 && F.$events.error && EMIT('error', this, res, this.$total_exception);\n\n\t\t\tif (status === 408) {\n\t\t\t\tif (F.timeouts.push((NOW = new Date()).toJSON() + ' ' + this.url) > 5)\n\t\t\t\t\tF.timeouts.shift();\n\t\t\t}\n\n\t\t\tF.$events[key] && EMIT(key, this, res, this.$total_exception);\n\t\t}\n\n\t\tif (!route) {\n\t\t\tif (status === 400 && this.$total_exception instanceof framework_builders.ErrorBuilder) {\n\t\t\t\tF.stats.response.errorBuilder++;\n\t\t\t\tthis.$language && this.$total_exception.setResource(this.$language);\n\t\t\t\tres.options.body = this.$total_exception.output(true);\n\t\t\t\tres.options.code = this.$total_exception.status;\n\t\t\t\tres.options.type = this.$total_exception.contentType;\n\t\t\t\tres.$text();\n\t\t\t} else {\n\n\t\t\t\tMODELERROR.code = status;\n\t\t\t\tMODELERROR.status = U.httpStatus(status, false);\n\t\t\t\tMODELERROR.error = this.$total_exception ? prepare_error(this.$total_exception) : null;\n\n\t\t\t\tres.options.body = VIEW('.' + PATHMODULES + 'error', MODELERROR);\n\t\t\t\tres.options.type = CT_HTML;\n\t\t\t\tres.options.code = status || 404;\n\t\t\t\tres.$text();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar name = route.controller;\n\n\t\tif (route.isMOBILE_VARY)\n\t\t\tthis.$mobile = true;\n\n\t\tif (route.currentViewDirectory === undefined)\n\t\t\troute.currentViewDirectory = name && name[0] !== '#' && name !== 'default' && name !== 'unknown' ? '/' + name + '/' : '';\n\n\t\tvar controller = new Controller(name, this, res, route.currentViewDirectory);\n\n\t\tcontroller.isTransfer = this.$total_transfer;\n\t\tcontroller.exception = this.$total_exception;\n\t\tthis.controller = controller;\n\n\t\tif (!this.$total_canceled && route.timeout) {\n\t\t\tthis.$total_timeout && clearTimeout(this.$total_timeout);\n\t\t\tthis.$total_timeout = setTimeout(subscribe_timeout, route.timeout, this);\n\t\t}\n\n\t\troute.isDELAY && res.writeContinue();\n\n\t\tif (this.$total_schema)\n\t\t\tthis.body.$$controller = controller;\n\n\t\tif (route.middleware)\n\t\t\tasync_middleware(0, this, res, route.middleware, subscribe_timeout_middleware, route.options, controller);\n\t\telse\n\t\t\tthis.$total_execute2();\n\t};\n\n\tPROTO.$total_execute2 = function() {\n\n\t\tvar name = this.$total_route.controller;\n\t\tvar controller = this.controller;\n\n\t\ttry {\n\n\t\t\tif (F.onTheme)\n\t\t\t\tcontroller.themeName = F.onTheme(controller);\n\n\t\t\tif (controller.isCanceled)\n\t\t\t\treturn;\n\n\t\t\tvar ctrlname = '@' + name;\n\t\t\tF.$events.controller && EMIT('controller', controller, name, this.$total_route.options);\n\t\t\tF.$events[ctrlname] && EMIT(ctrlname, controller, name, this.$total_route.options);\n\n\t\t\tif (controller.isCanceled)\n\t\t\t\treturn;\n\n\t\t\tif (!controller.isTransfer && this.$total_route.isCACHE && !F.temporary.other[this.uri.pathname])\n\t\t\t\tF.temporary.other[this.uri.pathname] = this.path;\n\n\t\t\tif (this.$total_route.isGENERATOR)\n\t\t\t\tasync.call(controller, this.$total_route.execute, true)(controller, framework_internal.routeParam(this.$total_route.param.length ? this.split : this.path, this.$total_route));\n\t\t\telse {\n\t\t\t\tif (this.$total_route.param.length) {\n\t\t\t\t\tvar params = framework_internal.routeParam(this.split, this.$total_route);\n\t\t\t\t\tcontroller.id = params[0];\n\t\t\t\t\tthis.$total_route.execute.apply(controller, params);\n\t\t\t\t} else\n\t\t\t\t\tthis.$total_route.execute.call(controller);\n\t\t\t}\n\n\t\t} catch (err) {\n\t\t\tF.error(err, name, this.uri);\n\t\t\tthis.$total_exception = err;\n\t\t\tthis.$total_route = F.lookup(this, '#500', EMPTYARRAY, 0);\n\t\t\tthis.$total_execute(500, true);\n\t\t}\n\t};\n\n\tPROTO.$total_parsebody = function(chunk) {\n\n\t\tif (this.buffer_exceeded)\n\t\t\treturn;\n\n\t\tif (!this.buffer_exceeded) {\n\t\t\tCONCAT[0] = this.buffer_data;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tthis.buffer_data = Buffer.concat(CONCAT);\n\t\t}\n\n\t\tif ((this.buffer_data.length / 1024) < this.$total_route.length)\n\t\t\treturn;\n\n\t\tthis.buffer_exceeded = true;\n\t\tthis.buffer_data = Buffer.alloc(0);\n\t};\n\n\tPROTO.$total_cancel = function() {\n\t\tF.stats.response.timeout++;\n\t\tclearTimeout(this.$total_timeout);\n\t\tif (!this.controller)\n\t\t\treturn;\n\t\tthis.controller.isTimeout = true;\n\t\tthis.controller.isCanceled = true;\n\t\tthis.$total_route = F.lookup(this, '#408', EMPTYARRAY, 0);\n\t\tthis.$total_execute(408, true);\n\t};\n\n\tPROTO.$total_validate = function(route, next, code) {\n\n\t\tvar self = this;\n\t\tself.$total_schema = false;\n\n\t\tif (!self.$total_route.schema)\n\t\t\treturn next(self, code);\n\n\t\tif (!self.$total_route.schema[1]) {\n\t\t\tF.stats.request.operation++;\n\t\t\treturn next(self, code);\n\t\t}\n\n\t\tF.onSchema(self, self.$total_route, function(err, body) {\n\t\t\tif (err) {\n\t\t\t\tself.$total_400(err);\n\t\t\t\tnext = null;\n\t\t\t} else {\n\t\t\t\tF.stats.request.schema++;\n\t\t\t\tself.body = body;\n\t\t\t\tself.$total_schema = true;\n\t\t\t\tnext(self, code);\n\t\t\t}\n\t\t});\n\t};\n\n\tPROTO.$total_authorize = function(isLogged, user, roles) {\n\n\t\tvar membertype = isLogged ? 1 : 2;\n\t\tvar code = this.buffer_exceeded ? 431 : 401;\n\n\t\tthis.$flags += membertype;\n\t\tuser && (this.user = user);\n\n\t\tif (this.$total_route && this.$total_route.isUNIQUE && !roles && (!this.$total_route.MEMBER || this.$total_route.MEMBER === membertype)) {\n\t\t\tif (code === 401 && this.$total_schema)\n\t\t\t\tthis.$total_validate(this.$total_route, subscribe_validate_callback, code);\n\t\t\telse\n\t\t\t\tthis.$total_execute(code, true);\n\t\t} else {\n\t\t\tvar route = F.lookup(this, this.buffer_exceeded ? '#431' : this.uri.pathname, this.flags, this.buffer_exceeded ? 0 : membertype);\n\t\t\tvar status = this.$isAuthorized ? 404 : 401;\n\t\t\tvar code = this.buffer_exceeded ? 431 : status;\n\t\t\t!route && (route = F.lookup(this, '#' + status, EMPTYARRAY, 0));\n\n\t\t\tthis.$total_route = route;\n\n\t\t\tif (this.$total_route && this.$total_schema)\n\t\t\t\tthis.$total_validate(this.$total_route, subscribe_validate_callback, code);\n\t\t\telse\n\t\t\t\tthis.$total_execute(code);\n\t\t}\n\t};\n\n\tPROTO.$total_end2 = function() {\n\n\t\tvar route = this.$total_route;\n\n\t\tif (this.buffer_exceeded) {\n\t\t\troute = F.lookup(this, '#431', EMPTYARRAY, 0);\n\t\t\tthis.buffer_data = null;\n\t\t\tif (route) {\n\t\t\t\tthis.$total_route = route;\n\t\t\t\tthis.$total_execute(431, true);\n\t\t\t} else\n\t\t\t\tthis.res.throw431();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.buffer_data && (!route || !route.isBINARY))\n\t\t\tthis.buffer_data = this.buffer_data.toString(ENCODING);\n\n\t\tif (!this.buffer_data) {\n\t\t\tif (route && route.schema)\n\t\t\t\tthis.$total_schema = true;\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_prepare();\n\t\t\treturn;\n\t\t}\n\n\t\tif (route.isXML) {\n\n\t\t\tif (this.$type !== 2) {\n\t\t\t\tthis.$total_400('Invalid \"Content-Type\".');\n\t\t\t\tthis.buffer_data = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tF.$onParseXML(this);\n\t\t\t\tthis.buffer_data = null;\n\t\t\t\tthis.$total_prepare();\n\t\t\t} catch (err) {\n\t\t\t\tF.error(err, null, this.uri);\n\t\t\t\tthis.$total_500(err);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (route.isRAW) {\n\t\t\tthis.body = this.buffer_data;\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_prepare();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.$type) {\n\t\t\tthis.buffer_data = null;\n\t\t\tthis.$total_400('Invalid \"Content-Type\".');\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.$type === 1) {\n\t\t\ttry {\n\t\t\t\tF.$onParseJSON(this);\n\t\t\t\tthis.buffer_data = null;\n\t\t\t} catch (e) {\n\t\t\t\tthis.$total_400('Invalid JSON data.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\tfor (var i = 0; i < this.buffer_data.length - 2; i++) {\n\t\t\t\tif (this.buffer_data[i] === '%' && this.buffer_data[i + 1] === '0' && this.buffer_data[i + 2] === '0') {\n\t\t\t\t\tthis.buffer_data = null;\n\t\t\t\t\tthis.$total_400('Not allowed chars in the request body.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tF.$onParseQueryBody(this);\n\t\t}\n\n\t\troute.schema && (this.$total_schema = true);\n\t\tthis.buffer_data = null;\n\t\tthis.$total_prepare();\n\t};\n\n\tPROTO.$total_endfile = function() {\n\n\t\tvar req = this;\n\t\tvar res = this.res;\n\n\t\tif (!F._length_files)\n\t\t\treturn res.continue();\n\n\t\tfor (var i = 0; i < F.routes.files.length; i++) {\n\n\t\t\tvar file = F.routes.files[i];\n\t\t\t// try {\n\n\t\t\tif (file.extensions && !file.extensions[req.extension])\n\t\t\t\tcontinue;\n\n\t\t\tif (file.url) {\n\t\t\t\tvar skip = false;\n\t\t\t\tvar length = file.url.length;\n\n\t\t\t\tif (!file.wildcard && !file.fixedfile && length !== req.path.length - 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tif (file.url[j] === req.path[j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (skip)\n\t\t\t\t\tcontinue;\n\n\t\t\t} else if (file.onValidate && !file.onValidate(req, res, true))\n\t\t\t\tcontinue;\n\n\t\t\tif (file.middleware)\n\t\t\t\treq.$total_endfilemiddleware(file);\n\t\t\telse\n\t\t\t\tfile.execute(req, res, false);\n\n\t\t\treturn;\n\t\t}\n\n\t\tres.continue();\n\t};\n\n\tPROTO.$total_endfilemiddleware = function(file) {\n\t\tthis.$total_filemiddleware = file;\n\t\tasync_middleware(0, this, this.res, file.middleware, total_endmiddleware, file.options);\n\t};\n\n\tPROTO.$total_400 = function(problem) {\n\t\tthis.$total_route = F.lookup(this, '#400', EMPTYARRAY, 0);\n\t\tthis.$total_exception = problem;\n\t\tthis.$total_execute(400, true);\n\t};\n\n\tPROTO.$total_404 = function(problem) {\n\t\tthis.$total_route = F.lookup(this, '#404', EMPTYARRAY, 0);\n\t\tthis.$total_exception = problem;\n\t\tthis.$total_execute(404, true);\n\t};\n\n\tPROTO.$total_500 = function(problem) {\n\t\tthis.$total_route = F.lookup(this, '#500', EMPTYARRAY, 0);\n\t\tthis.$total_exception = problem;\n\t\tthis.$total_execute(500, true);\n\t};\n\n\tPROTO.$total_prepare = function() {\n\t\tvar req = this;\n\t\tvar length = req.flags.length;\n\t\tif (F.onAuthorize) {\n\n\t\t\tif (F.onAuthorize.$newversion) {\n\t\t\t\treq.flagslength = length;\n\t\t\t\tF.onAuthorize(req, req.res, req.flags, req_authorizetotal);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tF.onAuthorize(req, req.res, req.flags, function(isAuthorized, user) {\n\n\t\t\t\tif (!F.onAuthorize.isobsolete) {\n\t\t\t\t\tF.onAuthorize.isobsolete = 1;\n\t\t\t\t\tOBSOLETE('F.onAuthorize', 'You need to use a new authorization declaration: \"AUTH(function($) {})\"');\n\t\t\t\t}\n\n\t\t\t\t// @isAuthorized \"null\" for callbacks(err, user)\n\t\t\t\t// @isAuthorized \"true\"\n\t\t\t\t// @isAuthorized \"object\" is as user but \"user\" must be \"undefined\"\n\n\t\t\t\tvar roles = length !== req.flags.length;\n\n\t\t\t\tif (roles) {\n\t\t\t\t\treq.$flags += req.flags.slice(length).join('');\n\t\t\t\t\treq.$roles = true;\n\t\t\t\t}\n\n\t\t\t\tif (isAuthorized instanceof Error || isAuthorized instanceof ErrorBuilder) {\n\t\t\t\t\t// Error handling\n\t\t\t\t\tisAuthorized = false;\n\t\t\t\t} else if (isAuthorized == null && user) {\n\t\t\t\t\t// A callback error handling\n\t\t\t\t\tisAuthorized = true;\n\t\t\t\t} else if (user == null && isAuthorized && isAuthorized !== true) {\n\t\t\t\t\tuser = isAuthorized;\n\t\t\t\t\tisAuthorized = true;\n\t\t\t\t}\n\n\t\t\t\treq.isAuthorized = isAuthorized;\n\t\t\t\treq.$total_authorize(isAuthorized, user, roles);\n\t\t\t});\n\n\t\t} else {\n\t\t\tif (!req.$total_route)\n\t\t\t\treq.$total_route = F.lookup(req, req.buffer_exceeded ? '#431' : req.uri.pathname, req.flags, 0);\n\t\t\tif (!req.$total_route)\n\t\t\t\treq.$total_route = F.lookup(req, '#404', EMPTYARRAY, 0);\n\t\t\tvar code = req.buffer_exceeded ? 431 : 404;\n\t\t\tif (!req.$total_schema || !req.$total_route)\n\t\t\t\treq.$total_execute(code, code);\n\t\t\telse\n\t\t\t\treq.$total_validate(req.$total_route, subscribe_validate_callback, code);\n\t\t}\n\t};\n\n\tPROTO.snapshot = function(callback) {\n\n\t\tvar req = this;\n\t\tvar builder = [];\n\t\tvar keys = Object.keys(req.headers);\n\t\tvar max = 0;\n\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar length = keys[i].length;\n\t\t\tif (length > max)\n\t\t\t\tmax = length;\n\t\t}\n\n\t\tbuilder.push('url'.padRight(max + 1) + ': ' + req.method.toUpperCase() + ' ' + req.url);\n\n\t\tfor (var i = 0; i < keys.length; i++)\n\t\t\tbuilder.push(keys[i].padRight(max + 1) + ': ' + req.headers[keys[i]]);\n\n\t\tbuilder.push('');\n\n\t\tvar data = [];\n\t\treq.on('data', chunk => data.push(chunk));\n\t\treq.on('end', function() {\n\t\t\tbuilder.push(Buffer.concat(data).toString('utf8'));\n\t\t\tcallback(null, builder.join('\\n'));\n\t\t});\n\t};\n}\n\nfunction total_endmiddleware(req) {\n\n\tif (req.total_middleware)\n\t\treq.total_middleware = null;\n\n\ttry {\n\t\treq.$total_filemiddleware.execute(req, req.res, false);\n\t} catch (err) {\n\t\tF.error(err, req.$total_filemiddleware.controller + ' :: ' + req.$total_filemiddleware.name, req.uri);\n\t\treq.res.throw500();\n\t}\n}\n\nfunction extend_response(PROTO) {\n\n\tPROTORES = PROTO;\n\n\t/**\n\t * Add a cookie into the response\n\t * @param {String} name\n\t * @param {Object} value\n\t * @param {Date/String} expires\n\t * @param {Object} options Additional options.\n\t * @return {Response}\n\t */\n\tPROTO.cookie = function(name, value, expires, options) {\n\n\t\tvar self = this;\n\n\t\tif (self.headersSent || self.success)\n\t\t\treturn;\n\n\t\tvar cookiename = name + '=';\n\t\tvar builder = [cookiename + value];\n\t\tvar type = typeof(expires);\n\n\t\tif (expires && !U.isDate(expires) && type === 'object') {\n\t\t\toptions = expires;\n\t\t\texpires = options.expires || options.expire || null;\n\t\t}\n\n\t\tif (type === 'string')\n\t\t\texpires = expires.parseDateExpiration();\n\n\t\tif (!options)\n\t\t\toptions = {};\n\n\t\toptions.path = options.path || '/';\n\t\texpires && builder.push('Expires=' + expires.toUTCString());\n\t\toptions.domain && builder.push('Domain=' + options.domain);\n\t\toptions.path && builder.push('Path=' + options.path);\n\t\toptions.secure && builder.push('Secure');\n\n\t\tif (options.httpOnly || options.httponly || options.HttpOnly)\n\t\t\tbuilder.push('HttpOnly');\n\n\t\tvar same = options.security || options.samesite || options.sameSite;\n\t\tif (same) {\n\t\t\tswitch (same) {\n\t\t\t\tcase 1:\n\t\t\t\t\tsame = 'lax';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsame = 'strict';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuilder.push('SameSite=' + same);\n\t\t}\n\n\t\tvar arr = self.getHeader('set-cookie') || [];\n\n\t\t// Cookie, already, can be in array, resulting in duplicate 'set-cookie' header\n\t\tif (arr.length) {\n\t\t\tvar l = cookiename.length;\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tif (arr[i].substring(0, l) === cookiename) {\n\t\t\t\t\tarr.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tarr.push(builder.join('; '));\n\t\tself.setHeader('Set-Cookie', arr);\n\t\treturn self;\n\t};\n\n\t/**\n\t * Disable HTTP cache for current response\n\t * @return {Response}\n\t */\n\tPROTO.noCache = PROTO.nocache = function() {\n\t\tvar self = this;\n\n\t\tif (self.$nocache)\n\t\t\treturn self;\n\n\t\tif (self.req) {\n\t\t\tdelete self.req.headers['if-none-match'];\n\t\t\tdelete self.req.headers['if-modified-since'];\n\t\t}\n\n\t\tif (self.getHeader(HEADER_CACHE)) {\n\t\t\tself.removeHeader(HEADER_CACHE);\n\t\t\tself.removeHeader('Expires');\n\t\t\tself.removeHeader('Etag');\n\t\t\tself.removeHeader('Last-Modified');\n\t\t\tself.setHeader(HEADER_CACHE, 'private, no-cache, no-store, max-age=0');\n\t\t\tself.setHeader('Expires', -1);\n\t\t}\n\n\t\tself.$nocache = true;\n\t\treturn self;\n\t};\n\n\t// For express middleware\n\tPROTO.status = function(code) {\n\t\tthis.options.code = code;\n\t\treturn this;\n\t};\n\n\t// For express middleware\n\tPROTO.send = function(code, body, type) {\n\n\t\tif (this.headersSent)\n\t\t\treturn this;\n\n\t\tthis.controller && this.req.$total_success();\n\n\t\tif (code instanceof Buffer) {\n\t\t\t// express.js static file\n\t\t\tif (!body && !type) {\n\t\t\t\tthis.end(code);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\tvar res = this;\n\t\tvar req = this.req;\n\t\tvar contentType = type;\n\t\tvar isHEAD = req.method === 'HEAD';\n\n\t\tif (body === undefined) {\n\t\t\tbody = code;\n\t\t\tcode = res.$statuscode || 200;\n\t\t}\n\n\t\tswitch (typeof(body)) {\n\t\t\tcase 'string':\n\t\t\t\tif (!contentType)\n\t\t\t\t\tcontentType = 'text/html';\n\t\t\t\tbreak;\n\n\t\t\tcase 'number':\n\t\t\t\tif (!contentType)\n\t\t\t\t\tcontentType = 'text/plain';\n\t\t\t\tbody = U.httpStatus(body);\n\t\t\t\tbreak;\n\n\t\t\tcase 'boolean':\n\t\t\tcase 'object':\n\t\t\t\tif (!isHEAD) {\n\t\t\t\t\tif (body instanceof framework_builders.ErrorBuilder) {\n\t\t\t\t\t\tvar json = body.output(true);\n\t\t\t\t\t\tif (body.status !== 200)\n\t\t\t\t\t\t\tres.options.code = body.status;\n\t\t\t\t\t\tif (body.contentType)\n\t\t\t\t\t\t\tcontentType = body.contentType;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcontentType = CT_JSON;\n\t\t\t\t\t\tbody = json;\n\t\t\t\t\t\tF.stats.response.errorBuilder++;\n\t\t\t\t\t} else\n\t\t\t\t\t\tbody = JSON.stringify(body);\n\t\t\t\t\t!contentType && (contentType = CT_JSON);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\tvar headers = {};\n\n\t\theaders[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\n\t\theaders['Vary'] = 'Accept-Encoding' + (req.$mobile ? ', User-Agent' : '');\n\n\t\tif ((/text|application/).test(contentType))\n\t\t\tcontentType += '; charset=utf-8';\n\n\t\theaders[HEADER_TYPE] = contentType;\n\t\tres.$custom();\n\n\t\tif (!accept && isGZIP(req))\n\t\t\taccept = 'gzip';\n\n\t\tvar compress = CONF.allow_gzip && accept.indexOf('gzip') !== -1;\n\t\tif (isHEAD) {\n\t\t\tcompress && (headers['Content-Encoding'] = 'gzip');\n\t\t\tres.writeHead(200, headers);\n\t\t\tres.end();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (!compress) {\n\t\t\tres.writeHead(code, headers);\n\t\t\tres.end(body, ENCODING);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar buffer = Buffer.from(body);\n\t\tZlib.gzip(buffer, function(err, data) {\n\n\t\t\tif (err) {\n\t\t\t\tres.writeHead(code, headers);\n\t\t\t\tres.end(body, ENCODING);\n\t\t\t} else {\n\t\t\t\theaders['Content-Encoding'] = 'gzip';\n\t\t\t\tres.writeHead(code, headers);\n\t\t\t\tres.end(data, ENCODING);\n\t\t\t}\n\t\t});\n\n\t\treturn res;\n\t};\n\n\t/**\n\t * Response a custom content\n\t * @param {Number} code\n\t * @param {String} body\n\t * @param {String} type\n\t * @param {Boolean} compress Disallows GZIP compression. Optional, default: true.\n\t * @param {Object} headers Optional, additional headers.\n\t * @return {Response}\n\t */\n\tPROTO.content = function(code, body, type, compress, headers) {\n\n\t\tif (typeof(compress) === 'object') {\n\t\t\tvar tmp = headers;\n\t\t\theaders = compress;\n\t\t\tcompress = tmp;\n\t\t}\n\n\t\tvar res = this;\n\t\tres.options.code = code;\n\t\tres.options.compress = compress === undefined || compress === true;\n\t\tres.options.body = body;\n\t\tres.options.type = type;\n\t\tres.options.compress = body.length > 4096;\n\t\theaders && (res.options.headers = headers);\n\t\tres.$text();\n\t\treturn res;\n\t};\n\n\t/**\n\t * Response redirect\n\t * @param {String} url\n\t * @param {Boolean} permanent Optional, default: false.\n\t * @return {Framework}\n\t */\n\tPROTO.redirect = function(url, permanent) {\n\t\tthis.options.url = url;\n\t\tpermanent && (this.options.permanent = permanent);\n\t\tthis.$redirect();\n\t\treturn this;\n\t};\n\n\t/**\n\t * Responds with a file\n\t * @param {String} filename\n\t * @param {String} download Optional, a download name.\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} done Optional, callback.\n\t * @return {Framework}\n\t */\n\tPROTO.file = function(filename, download, headers, callback) {\n\t\tthis.options.filename = filename;\n\t\theaders && (this.options.headers = headers);\n\t\tcallback && (this.options.callback = callback);\n\t\tdownload && (this.options.download = download);\n\t\treturn this.$file();\n\t};\n\n\t/**\n\t * Responds with a file from FileStorage\n\t * @param {String} name A name of FileStorage\n\t * @param {String/Number} id\n\t * @param {String} download Optional, a download name.\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} done Optional, callback.\n\t * @return {Framework}\n\t */\n\tPROTO.filefs = function(name, id, download, headers, callback, checkmeta) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.download = download;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tFILESTORAGE(name).res(self, options, checkmeta, $file_notmodified);\n\t\treturn self;\n\t};\n\n\tPROTO.filenosql = function(name, id, download, headers, callback, checkmeta) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.download = download;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tNOSQL(name).binary.res(self, options, checkmeta, $file_notmodified);\n\t\treturn self;\n\t};\n\n\tPROTO.imagefs = function(name, id, make, headers, callback, checkmeta) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.image = true;\n\t\toptions.make = make;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tFILESTORAGE(name).res(self, options, checkmeta, $file_notmodified);\n\t\treturn self;\n\t};\n\n\tPROTO.imagenosql = function(name, id, make, headers, callback, checkmeta) {\n\t\tvar self = this;\n\t\tvar options = {};\n\t\toptions.id = id;\n\t\toptions.image = true;\n\t\toptions.make = make;\n\t\toptions.headers = headers;\n\t\toptions.done = callback;\n\t\tNOSQL(name).binary.res(self, options, checkmeta, $file_notmodified);\n\t\treturn self;\n\t};\n\n\t/**\n\t * Responds with a stream\n\t * @param {String} contentType\n\t * @param {Stream} stream\n\t * @param {String} download Optional, a download name.\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} done Optional, callback.\n\t * @return {Framework}\n\t */\n\tPROTO.stream = function(type, stream, download, headers, callback, nocompress) {\n\t\tvar res = this;\n\t\tres.options.type = type;\n\t\tres.options.stream = stream;\n\t\tdownload && (res.options.download = download);\n\t\theaders && (res.options.headers = headers);\n\t\tcallback && (res.options.callback = callback);\n\t\tres.options.compress = nocompress ? false : true;\n\t\tres.$stream();\n\t\treturn res;\n\t};\n\n\tPROTO.binary = function(body, type, encoding, download, headers) {\n\n\t\tif (typeof(encoding) === 'object') {\n\t\t\tvar tmp = encoding;\n\t\t\tencoding = download;\n\t\t\tdownload = headers;\n\t\t\theaders = tmp;\n\t\t}\n\n\t\tif (typeof(download) === 'object') {\n\t\t\theaders = download;\n\t\t\tdownload = headers;\n\t\t}\n\n\t\tthis.options.type = type;\n\t\tthis.options.body = body;\n\t\tthis.options.encoding = encoding;\n\t\tdownload && (this.options.download = download);\n\t\theaders && (this.options.headers = headers);\n\t\tthis.$binary();\n\t\treturn this;\n\t};\n\n\tPROTO.proxy = function(url, headers, timeout, callback) {\n\n\t\tOBSOLETE('res.proxy()', 'You need to use controller.proxy()');\n\n\t\tvar res = this;\n\n\t\tif (res.success || res.headersSent)\n\t\t\treturn res;\n\n\t\tcallback && (res.options.callback = callback);\n\t\theaders && (res.options.headers = headers);\n\t\ttimeout && (res.options.timeout = timeout);\n\n\t\tU.resolve(url, function(err, uri) {\n\n\t\t\tvar headers = {};\n\n\t\t\theaders[HEADER_CACHE] = 'private, no-cache, no-store, max-age=0';\n\t\t\tres.options.headers && U.extend_headers2(headers, res.options.headers);\n\n\t\t\tvar options = { protocol: uri.protocol, auth: uri.auth, method: 'GET', hostname: uri.hostname, port: uri.port, path: uri.path, agent: false, headers: headers };\n\t\t\tvar connection = options.protocol === 'https:' ? require('https') : http;\n\t\t\tvar gzip = CONF.allow_gzip && (res.req.headers['accept-encoding'] || '').lastIndexOf('gzip') !== -1;\n\n\t\t\tvar client = connection.get(options, function(response) {\n\n\t\t\t\tif (res.success || res.headersSent)\n\t\t\t\t\treturn;\n\n\t\t\t\tvar contentType = response.headers['content-type'];\n\t\t\t\tvar isGZIP = (response.headers['content-encoding'] || '').lastIndexOf('gzip') !== -1;\n\t\t\t\tvar compress = !isGZIP && gzip && (contentType.indexOf('text/') !== -1 || contentType.lastIndexOf('javascript') !== -1 || contentType.lastIndexOf('json') !== -1);\n\t\t\t\tvar attachment = response.headers['content-disposition'] || '';\n\n\t\t\t\tattachment && res.setHeader('Content-Disposition', attachment);\n\t\t\t\tres.setHeader(HEADER_TYPE, contentType);\n\t\t\t\tres.setHeader('Vary', 'Accept-Encoding' + (res.req.$mobile ? ', User-Agent' : ''));\n\n\t\t\t\tres.on('error', function() {\n\t\t\t\t\tresponse.close();\n\t\t\t\t\tresponse_end(res);\n\t\t\t\t});\n\n\t\t\t\tif (compress) {\n\t\t\t\t\tres.setHeader('Content-Encoding', 'gzip');\n\t\t\t\t\tresponse.pipe(Zlib.createGzip(GZIPSTREAM)).pipe(res);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isGZIP && !gzip)\n\t\t\t\t\tresponse.pipe(Zlib.createGunzip()).pipe(res);\n\t\t\t\telse\n\t\t\t\t\tresponse.pipe(res);\n\t\t\t});\n\n\t\t\ttimeout && client.setTimeout(timeout, function() {\n\t\t\t\tres.throw408();\n\t\t\t});\n\n\t\t\tclient.on('close', function() {\n\t\t\t\tif (!res.success) {\n\t\t\t\t\tF.stats.response.pipe++;\n\t\t\t\t\tresponse_end(res);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn res;\n\t};\n\n\t/**\n\t * Responds with an image\n\t * @param {String or Stream} filename\n\t * @param {String} make\n\t * @param {Object} headers Optional, additional headers.\n\t * @param {Function} callback Optional.\n\t * @return {Framework}\n\t */\n\tPROTO.image = function(filename, make, headers, callback, persistent) {\n\n\t\tvar res = this;\n\n\t\tres.options.make = make;\n\n\t\tif (persistent === true || (persistent == null && CONF.allow_persistent_images === true))\n\t\t\tres.options.persistent = true;\n\n\t\theaders && (res.options.headers = headers);\n\t\tcallback && (res.options.callback = callback);\n\n\t\tif (typeof(filename) === 'object')\n\t\t\tres.options.stream = filename;\n\t\telse\n\t\t\tres.options.filename = filename;\n\n\t\tres.$image();\n\t\treturn res;\n\t};\n\n\tPROTO.image_nocache = function(filename, make, headers, callback) {\n\t\tthis.options.cache = false;\n\t\treturn this.image(filename, make, headers, callback);\n\t};\n\n\t/**\n\t * Response JSON\n\t * @param {Object} obj\n\t * @return {Response}\n\t */\n\tPROTO.json = function(obj) {\n\t\tvar res = this;\n\t\tF.stats.response.json++;\n\t\tif (obj && obj.$$schema)\n\t\t\tobj = obj.$clean();\n\t\tres.options.body = JSON.stringify(obj);\n\t\tres.options.compress = res.options.body.length > 4096;\n\t\tres.options.type = CT_JSON;\n\t\treturn res.$text();\n\t};\n\n\tconst SECURITYTXT = { '/security.txt': 1, '/.well-known/security.txt': 1 };\n\n\tPROTO.continue = function(callback) {\n\n\t\tvar res = this;\n\t\tvar req = res.req;\n\n\t\tcallback && (res.options.callback = callback);\n\n\t\tif (res.success || res.headersSent)\n\t\t\treturn res;\n\n\t\tif (!CONF.static_accepts[req.extension]) {\n\t\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(req, res))\n\t\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (SECURITYTXT[req.url] && CONF['security.txt']) {\n\t\t\tres.send(200, CONF['security.txt'], 'text/plain');\n\t\t\treturn;\n\t\t}\n\n\t\treq.$key = createTemporaryKey(req);\n\n\t\tif (F.temporary.notfound[req.$key]) {\n\t\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(req, res))\n\t\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tvar canresize = false;\n\t\tvar filename = null;\n\t\tvar name = req.uri.pathname;\n\n\t\tif (IMAGES[req.extension]) {\n\t\t\tvar index = name.lastIndexOf('/');\n\t\t\tvar resizer = F.routes.resize[name.substring(0, index + 1)];\n\t\t\tif (resizer) {\n\t\t\t\tname = name.substring(index + 1);\n\t\t\t\tcanresize = resizer.extension['*'] || resizer.extension[req.extension];\n\t\t\t\tif (canresize) {\n\t\t\t\t\tname = resizer.path + $decodeURIComponent(name);\n\t\t\t\t\tfilename = F.onMapping(name, name, false, false);\n\t\t\t\t} else\n\t\t\t\t\tfilename = F.onMapping(name, name, true, true);\n\t\t\t} else\n\t\t\t\tfilename = F.onMapping(name, name, true, true);\n\t\t} else\n\t\t\tfilename = F.onMapping(name, name, true, true);\n\n\t\tif (!filename) {\n\t\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(req, res))\n\t\t\t\tres.throw404();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!canresize) {\n\n\t\t\tif (F.components.has && F.components[req.extension] && req.uri.pathname === CONF.static_url_components + req.extension) {\n\t\t\t\tres.noCompress = true;\n\t\t\t\tres.options.components = true;\n\t\t\t\tvar g = req.query.group ? req.query.group.substring(0, req.query.group.length - 6) : '';\n\t\t\t\tfilename = F.path.temp('components' + (g ? '_g' + g : '') + '.' + req.extension);\n\t\t\t\tif (g)\n\t\t\t\t\treq.$key = 'components_' + g + '.' + req.extension;\n\t\t\t\telse\n\t\t\t\t\treq.$key = 'components.' + req.extension;\n\t\t\t}\n\n\t\t\tres.options.filename = filename;\n\t\t\tres.$file();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (!resizer.ishttp) {\n\t\t\tres.options.cache = resizer.cache;\n\t\t\tres.options.make = resizer.fn;\n\t\t\tres.options.filename = filename;\n\t\t\tres.$image();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (F.temporary.processing[req.uri.pathname]) {\n\t\t\tsetTimeout($continue_timeout, 500, res);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar tmp = F.path.temp(req.$key);\n\t\tif (F.temporary.path[req.$key]) {\n\t\t\tres.options.filename = req.uri.pathname;\n\t\t\tres.$file();\n\t\t\treturn res;\n\t\t}\n\n\t\tF.temporary.processing[req.uri.pathname] = true;\n\n\t\tU.download(name, FLAGS_DOWNLOAD, function(err, response) {\n\t\t\tvar writer = Fs.createWriteStream(tmp);\n\t\t\tresponse.pipe(writer);\n\t\t\tCLEANUP(writer, function() {\n\n\t\t\t\tdelete F.temporary.processing[req.uri.pathname];\n\t\t\t\tvar contentType = response.headers['content-type'];\n\n\t\t\t\tif (response.statusCode !== 200 || !contentType || !contentType.startsWith('image/')) {\n\t\t\t\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(req, res))\n\t\t\t\t\t\tres.throw404();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tres.options.cache = resizer.cache;\n\t\t\t\tres.options.filename = tmp;\n\t\t\t\tres.options.maker = resizer.fn;\n\t\t\t\tres.$image();\n\t\t\t});\n\t\t});\n\n\t\treturn res;\n\t};\n\n\tPROTO.$file = function() {\n\n\t\t// res.options.filename\n\t\t// res.options.code\n\t\t// res.options.callback\n\t\t// res.options.headers\n\t\t// res.options.download\n\n\t\tvar res = this;\n\t\tvar options = res.options;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tvar req = this.req;\n\n\t\t// Localization\n\t\tif (CONF.allow_localize && KEYSLOCALIZE[req.extension]) {\n\n\t\t\t// Is package?\n\t\t\tif (options.filename && options.filename[0] === '@')\n\t\t\t\toptions.filename = F.path.package(options.filename.substring(1));\n\n\t\t\tF.$filelocalize(req, res, false, options);\n\t\t\treturn;\n\t\t}\n\n\t\t!req.$key && (req.$key = createTemporaryKey(req));\n\n\t\t// \"$keyskip\" solves a problem with handling files in 404 state\n\t\tif (!req.$keyskip) {\n\t\t\tif (F.temporary.notfound[req.$key]) {\n\t\t\t\treq.$keyskip = true;\n\t\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(req, res))\n\t\t\t\t\tres.throw404();\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\t// Is package?\n\t\tif (options.filename && options.filename[0] === '@')\n\t\t\toptions.filename = F.path.package(options.filename.substring(1));\n\n\t\tvar name = F.temporary.path[req.$key];\n\t\tvar index;\n\n\t\tif (!req.extension) {\n\t\t\treq.$key && (req.extension = U.getExtension(req.$key));\n\t\t\tif (!req.extension && name) {\n\t\t\t\treq.extension = U.getExtension(name);\n\t\t\t\tindex = req.extension.lastIndexOf(';');\n\t\t\t\tindex !== -1 && (req.extension = req.extension.substring(0, index));\n\t\t\t}\n\t\t\t!req.extension && options.filename && (req.extension = U.getExtension(options.filename));\n\t\t}\n\n\t\tif (name && RELEASE && !res.$nocache && req.headers['if-modified-since'] === name[2]) {\n\t\t\t$file_notmodified(res, name);\n\t\t\treturn res;\n\t\t}\n\n\t\tif (name === undefined) {\n\n\t\t\tif (F.temporary.processing[req.$key]) {\n\t\t\t\tif (req.processing > CONF.default_request_timeout) {\n\t\t\t\t\tres.throw408();\n\t\t\t\t} else {\n\t\t\t\t\treq.processing += 500;\n\t\t\t\t\tsetTimeout($file_processing, 500, res);\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\t// waiting\n\t\t\tF.temporary.processing[req.$key] = true;\n\t\t\tcompile_check(res);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar contentType = U.getContentType(req.extension);\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\tvar headers;\n\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar compress = CONF.allow_gzip && COMPRESSION[contentType] && accept.indexOf('gzip') !== -1 && name.length > 2;\n\t\tvar range = req.headers.range;\n\t\tvar canCache = !res.$nocache && RELEASE && contentType !== 'text/cache-manifest' && !RESPONSENOCACHE[req.extension];\n\n\t\tif (canCache) {\n\t\t\tif (compress)\n\t\t\t\theaders = range ? HEADERS.file_release_compress_range : HEADERS.file_release_compress;\n\t\t\telse\n\t\t\t\theaders = range ? HEADERS.file_release_range : HEADERS.file_release;\n\t\t} else {\n\t\t\tif (compress)\n\t\t\t\theaders = range ? HEADERS.file_debug_compress_range : HEADERS.file_debug_compress;\n\t\t\telse\n\t\t\t\theaders = range ? HEADERS.file_debug_range : HEADERS.file_debug;\n\t\t}\n\n\t\tif (req.$mobile)\n\t\t\theaders.Vary = 'Accept-Encoding, User-Agent';\n\t\telse\n\t\t\theaders.Vary = 'Accept-Encoding';\n\n\t\theaders[HEADER_TYPE] = contentType;\n\t\tif (REG_TEXTAPPLICATION.test(contentType))\n\t\t\theaders[HEADER_TYPE] += '; charset=utf-8';\n\n\t\tif (canCache && !res.getHeader('Expires')) {\n\t\t\theaders.Expires = DATE_EXPIRES;\n\t\t} else if (headers.Expires && RELEASE)\n\t\t\tdelete headers.Expires;\n\n\t\tif (res.options.headers)\n\t\t\theaders = U.extend_headers(headers, res.options.headers);\n\n\t\tif (res.options.download) {\n\t\t\tvar encoded = encodeURIComponent(res.options.download);\n\t\t\theaders['Content-Disposition'] = 'attachment; ' + (REG_UTF8.test(res.options.download) ? 'filename*=utf-8\\'\\'' + encoded : ('filename=\"' + encoded + '\"'));\n\t\t} else if (headers['Content-Disposition'])\n\t\t\tdelete headers['Content-Disposition'];\n\n\t\tif (res.getHeader('Last-Modified'))\n\t\t\tdelete headers['Last-Modified'];\n\t\telse if (!res.options.lastmodified)\n\t\t\theaders['Last-Modified'] = name[2];\n\n\t\theaders.Etag = ETAG + CONF.etag_version;\n\n\t\tif (range) {\n\t\t\t$file_range(name[0], range, headers, res);\n\t\t\treturn res;\n\t\t}\n\n\t\t// (DEBUG && !res.options.make) --> because of image convertor\n\t\tif (!res.options.components && ((DEBUG && !res.options.make) || res.$nocache))\n\t\t\tF.isProcessed(req.$key) && (F.temporary.path[req.$key] = undefined);\n\n\t\tif (name[1] && !compress)\n\t\t\theaders[HEADER_LENGTH] = name[1];\n\t\telse if (compress && name[4])\n\t\t\theaders[HEADER_LENGTH] = name[4];\n\t\telse if (headers[HEADER_LENGTH])\n\t\t\tdelete headers[HEADER_LENGTH];\n\n\t\tF.stats.response.file++;\n\t\toptions.stream && DESTROY(options.stream);\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(res.options.code || 200, headers);\n\t\t\tres.end();\n\t\t\tresponse_end(res);\n\t\t} else if (compress) {\n\n\t\t\tif (name[4])\n\t\t\t\theaders[HEADER_LENGTH] = name[4];\n\t\t\telse\n\t\t\t\tdelete headers[HEADER_LENGTH];\n\n\t\t\tres.writeHead(res.options.code || 200, headers);\n\t\t\tfsStreamRead(name[3], undefined, $file_nocompress, res);\n\t\t} else {\n\t\t\tres.writeHead(res.options.code || 200, headers);\n\t\t\tfsStreamRead(name[0], undefined, $file_nocompress, res);\n\t\t}\n\t};\n\n\tPROTO.$redirect = function() {\n\n\t\t// res.options.permanent\n\t\t// res.options.url\n\n\t\tvar res = this;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tHEADERS.redirect.Location = res.options.url;\n\t\tres.writeHead(res.options.permanent ? 301 : 302, HEADERS.redirect);\n\t\tres.end();\n\t\tresponse_end(res);\n\t\tF.stats.response.redirect++;\n\t\treturn res;\n\t};\n\n\tPROTO.$binary = function() {\n\n\t\t// res.options.callback\n\t\t// res.options.code\n\t\t// res.options.encoding\n\t\t// res.options.download\n\t\t// res.options.type\n\t\t// res.options.body\n\t\t// res.options.headers\n\n\t\tvar res = this;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tvar req = res.req;\n\t\tvar options = res.options;\n\n\t\t/*\n\t\tif (options.type.lastIndexOf('/') === -1)\n\t\t\toptions.type = U.getContentType(options.type);\n\t\t*/\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar compress = CONF.allow_gzip && COMPRESSION[options.type] && accept.indexOf('gzip') !== -1;\n\t\tvar headers = compress ? HEADERS.binary_compress : HEADERS.binary;\n\n\t\theaders['Vary'] = 'Accept-Encoding' + (req.$mobile ? ', User-Agent' : '');\n\n\t\tif (options.download)\n\t\t\theaders['Content-Disposition'] = 'attachment; filename=' + encodeURIComponent(options.download);\n\t\telse if (headers['Content-Disposition'])\n\t\t\tdelete headers['Content-Disposition'];\n\n\t\theaders[HEADER_TYPE] = options.type;\n\n\t\tif (options.headers)\n\t\t\theaders = U.extend_headers(headers, options.headers);\n\n\t\tF.stats.response.binary++;\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end();\n\t\t\tresponse_end(res);\n\t\t} else if (compress) {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tZlib.gzip(!options.encoding || options.encoding === 'binary' ? options.body : options.body.toString(options.encoding), (err, buffer) => res.end(buffer));\n\t\t\tresponse_end(res);\n\t\t} else {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end(!options.encoding || options.encoding === 'binary' ? options.body : options.body.toString(options.encoding));\n\t\t\tresponse_end(res);\n\t\t}\n\n\t\treturn res;\n\t};\n\n\tPROTO.$stream = function() {\n\n\t\t// res.options.filename\n\t\t// res.options.options\n\t\t// res.options.callback\n\t\t// res.options.code\n\t\t// res.options.stream\n\t\t// res.options.type\n\t\t// res.options.compress\n\n\t\tvar res = this;\n\t\tvar req = res.req;\n\t\tvar options = res.options;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\t/*\n\t\tif (options.type.lastIndexOf('/') === -1)\n\t\t\toptions.type = U.getContentType(options.type);\n\t\t*/\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar compress = (options.compress === undefined || options.compress) && CONF.allow_gzip && COMPRESSION[options.type] && accept.indexOf('gzip') !== -1;\n\t\tvar headers;\n\n\t\tif (RELEASE) {\n\t\t\tif (compress)\n\t\t\t\theaders = HEADERS.stream_release_compress;\n\t\t\telse\n\t\t\t\theaders = HEADERS.stream_release;\n\t\t} else {\n\t\t\tif (compress)\n\t\t\t\theaders = HEADERS.stream_debug_compress;\n\t\t\telse\n\t\t\t\theaders = HEADERS.stream_debug;\n\t\t}\n\n\t\theaders.Vary = 'Accept-Encoding' + (req.$mobile ? ', User-Agent' : '');\n\n\t\tif (RELEASE) {\n\t\t\theaders.Expires = DATE_EXPIRES;\n\t\t\theaders['Last-Modified'] = 'Mon, 01 Jan 2001 08:00:00 GMT';\n\t\t}\n\n\t\tif (options.download)\n\t\t\theaders['Content-Disposition'] = 'attachment; filename=' + encodeURIComponent(options.download);\n\t\telse if (headers['Content-Disposition'])\n\t\t\tdelete headers['Content-Disposition'];\n\n\t\theaders[HEADER_TYPE] = options.type;\n\n\t\tif (options.headers)\n\t\t\theaders = U.extend_headers(headers, options.headers);\n\n\t\tF.stats.response.stream++;\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end();\n\t\t\toptions.stream && framework_internal.onFinished(res, () => framework_internal.destroyStream(options.stream));\n\t\t\tresponse_end(res);\n\t\t\treturn res;\n\t\t}\n\n\t\tif (compress) {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.on('error', () => options.stream.close());\n\t\t\toptions.stream.pipe(Zlib.createGzip(GZIPSTREAM)).pipe(res);\n\t\t\tframework_internal.onFinished(res, () => framework_internal.destroyStream(options.stream));\n\t\t\tresponse_end(res);\n\t\t} else {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tframework_internal.onFinished(res, () => framework_internal.destroyStream(options.stream));\n\t\t\toptions.stream.pipe(res);\n\t\t\tresponse_end(res);\n\t\t}\n\n\t\treturn res;\n\t};\n\n\tPROTO.$image = function() {\n\n\t\t// res.options.filename\n\t\t// res.options.stream\n\t\t// res.options.options\n\t\t// res.options.callback\n\t\t// res.options.code\n\t\t// res.options.cache\n\t\t// res.options.headers\n\t\t// res.options.make = function(image, res)\n\t\t// res.options.persistent\n\n\t\tvar res = this;\n\t\tvar options = res.options;\n\n\t\tif (options.cache === false)\n\t\t\treturn $image_nocache(res);\n\n\t\tvar req = this.req;\n\t\tif (!req.$key)\n\t\t\treq.$key = createTemporaryKey(req);\n\n\t\tvar key = req.$key;\n\n\t\tif (F.temporary.notfound[key]) {\n\t\t\tDEBUG && (F.temporary.notfound[key] = undefined);\n\t\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(req, res))\n\t\t\t\tres.throw404();\n\t\t\treturn res;\n\t\t}\n\n\t\tvar name = F.temporary.path[key];\n\n\t\tif (options.filename && options.filename[0] === '@')\n\t\t\toptions.filename = F.path.package(options.filename.substring(1));\n\n\t\tif (name !== undefined) {\n\t\t\tres.$file();\n\t\t\treturn res;\n\t\t}\n\n\t\tif (F.temporary.processing[key]) {\n\t\t\tif (req.processing > CONF.default_request_timeout) {\n\t\t\t\tres.throw408();\n\t\t\t} else {\n\t\t\t\treq.processing += 500;\n\t\t\t\tsetTimeout($image_processing, 500, res);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvar plus = F.id ? 'i-' + F.id + '_' : '';\n\n\t\toptions.name = F.path.temp((options.persistent ? 'timg_' : '') + plus + key);\n\n\t\tif (options.persistent) {\n\t\t\tfsFileExists(options.name, $image_persistent, res);\n\t\t\treturn;\n\t\t}\n\n\t\tF.temporary.processing[key] = true;\n\n\t\tif (options.stream)\n\t\t\tfsFileExists(options.name, $image_stream, res);\n\t\telse\n\t\t\tfsFileExists(options.filename, $image_filename, res);\n\n\t\treturn res;\n\t};\n\n\tPROTO.$custom = function() {\n\t\tF.stats.response.custom++;\n\t\tresponse_end(this);\n\t\treturn this;\n\t};\n\n\tPROTO.$text = function() {\n\n\t\t// res.options.type\n\t\t// res.options.body\n\t\t// res.options.code\n\t\t// res.options.headers\n\t\t// res.options.callback\n\t\t// res.options.compress\n\t\t// res.options.encoding\n\n\t\tvar res = this;\n\t\tvar req = res.req;\n\t\tvar options = res.options;\n\n\t\tif (res.headersSent)\n\t\t\treturn res;\n\n\t\tif (res.$evalroutecallback) {\n\t\t\tres.headersSent = true;\n\t\t\tres.$evalroutecallback(null, options.body, res.options.encoding || ENCODING);\n\t\t\treturn res;\n\t\t}\n\n\t\tvar accept = req.headers['accept-encoding'] || '';\n\t\t!accept && isGZIP(req) && (accept = 'gzip');\n\n\t\tvar gzip = CONF.allow_gzip && (options.compress === undefined || options.compress) ? accept.indexOf('gzip') !== -1 : false;\n\t\tvar headers;\n\n\t\tif (req.$mobile)\n\t\t\theaders = gzip ? HEADERS.content_mobile_release : HEADERS.content_mobile;\n\t\telse\n\t\t\theaders = gzip ? HEADERS.content_compress : HEADERS.content;\n\n\t\tif (REG_TEXTAPPLICATION.test(options.type))\n\t\t\toptions.type += '; charset=utf-8';\n\n\t\theaders[HEADER_TYPE] = options.type;\n\n\t\tif (options.headers)\n\t\t\theaders = U.extend_headers(headers, options.headers);\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\tres.end();\n\t\t} else {\n\t\t\tif (gzip) {\n\t\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\t\tZlib.gzip(options.body instanceof Buffer ? options.body : Buffer.from(options.body), (err, data) => res.end(data, res.options.encoding || ENCODING));\n\t\t\t} else {\n\t\t\t\tres.writeHead(options.code || 200, headers);\n\t\t\t\tres.end(options.body, res.options.encoding || ENCODING);\n\t\t\t}\n\t\t}\n\n\t\tresponse_end(res);\n\t\treturn res;\n\t};\n\n\tPROTO.throw400 = function(problem) {\n\t\tthis.options.code = 400;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw401 = function(problem) {\n\t\tthis.options.code = 401;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw403 = function(problem) {\n\t\tthis.options.code = 403;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw404 = function(problem) {\n\t\tthis.options.code = 404;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw408 = function(problem) {\n\t\tthis.options.code = 408;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw409 = function(problem) {\n\t\tthis.options.code = 409;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw431 = function(problem) {\n\t\tthis.options.code = 431;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw500 = function(error) {\n\t\terror && F.error(error, null, this.req.uri);\n\t\tthis.options.code = 500;\n\t\tthis.options.body = U.httpStatus(500) + error ? prepare_error(error) : '';\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.throw501 = function(problem) {\n\t\tthis.options.code = 501;\n\t\tproblem && (this.options.problem = problem);\n\t\treturn this.$throw();\n\t};\n\n\tPROTO.$throw = function() {\n\n\t\t// res.options.code\n\t\t// res.options.body\n\t\t// res.options.problem\n\n\t\tvar res = this;\n\n\t\tif (res.success || res.headersSent)\n\t\t\treturn res;\n\n\t\tvar req = res.req;\n\t\tvar key = 'error' + res.options.code;\n\n\t\tres.options.problem && F.problem(res.options.problem, 'response' + res.options.code + '()', req.uri, req.ip);\n\n\t\tif (req.method === 'HEAD') {\n\t\t\tres.writeHead(res.options.code || 501, res.options.headers || HEADERS.responseCode);\n\t\t\tres.end();\n\t\t\tF.stats.response[key]++;\n\t\t\tresponse_end(res);\n\t\t} else {\n\t\t\treq.$total_route = F.lookup(req, '#' + res.options.code, EMPTYARRAY, 0);\n\t\t\treq.$total_exception = res.options.problem;\n\t\t\treq.$total_execute(res.options.code, true);\n\t\t}\n\n\t\tF.$events[key] && EMIT(key, req, res, res.options.problem);\n\t\treturn res;\n\t};\n}\n\nfunction $image_persistent(exists, size, isFile, stats, res) {\n\tif (exists) {\n\t\tdelete F.temporary.processing[res.req.$key];\n\t\tF.temporary.path[res.req.$key] = [res.options.name, stats.size, stats.mtime.toUTCString()];\n\t\tres.options.filename = res.options.name;\n\t\tres.$file();\n\t} else {\n\t\tF.temporary.processing[res.req.$key] = true;\n\t\tif (res.options.stream)\n\t\t\tfsFileExists(res.options.name, $image_stream, res);\n\t\telse\n\t\t\tfsFileExists(res.options.filename, $image_filename, res);\n\t}\n}\n\nfunction $continue_timeout(res) {\n\tres.continue();\n}\n\nfunction $file_processing(res) {\n\tres.$file();\n}\n\nfunction $file_notmodified(res, name) {\n\tvar req = res.req;\n\tvar headers = HEADERS.file_lastmodified;\n\n\tif (res.getHeader('Last-Modified'))\n\t\tdelete headers['Last-Modified'];\n\telse\n\t\theaders['Last-Modified'] = name instanceof Array ? name[2] : name;\n\n\tif (res.getHeader('Expires'))\n\t\tdelete headers.Expires;\n\telse\n\t\theaders.Expires = DATE_EXPIRES;\n\n\tif (res.getHeader('ETag'))\n\t\tdelete headers.Etag;\n\telse\n\t\theaders.Etag = ETAG + CONF.etag_version;\n\n\theaders[HEADER_TYPE] = U.getContentType(req.extension);\n\tres.writeHead(304, headers);\n\tres.end();\n\tF.stats.response.notModified++;\n\tresponse_end(res);\n}\n\nfunction $file_nocompress(stream, next, res) {\n\n\tstream.pipe(res);\n\n\tframework_internal.onFinished(res, function() {\n\t\tnext();\n\t\tframework_internal.destroyStream(stream);\n\t});\n\n\tresponse_end(res);\n}\n\nfunction $file_range(name, range, headers, res) {\n\n\tvar arr = range.replace(REG_RANGE, '').split('-');\n\tvar beg = +arr[0] || 0;\n\tvar end = +arr[1] || 0;\n\tvar total = F.temporary.range[name];\n\n\tif (!total) {\n\t\ttotal = Fs.statSync(name).size;\n\t\tRELEASE && (F.temporary.range[name] = total);\n\t}\n\n\tif (end === 0)\n\t\tend = total - 1;\n\n\tif (beg > end) {\n\t\tbeg = 0;\n\t\tend = total - 1;\n\t}\n\n\tif (end > total)\n\t\tend = total - 1;\n\n\tvar length = (end - beg) + 1;\n\n\theaders[HEADER_LENGTH] = length;\n\theaders['Content-Range'] = 'bytes ' + beg + '-' + end + '/' + total;\n\n\tvar req = res;\n\tF.stats.response.streaming++;\n\n\tif (req.method === 'HEAD') {\n\t\tres.writeHead(206, headers);\n\t\tres.end();\n\t\tresponse_end(res);\n\t\treturn F;\n\t}\n\n\tres.writeHead(206, headers);\n\tRANGE.start = beg;\n\tRANGE.end = end;\n\tfsStreamRead(name, RANGE, $file_range_callback, res);\n\treturn F;\n}\n\nfunction $file_range_callback(stream, next, res) {\n\tframework_internal.onFinished(res, function() {\n\t\tframework_internal.destroyStream(stream);\n\t\tnext();\n\t});\n\tstream.pipe(res);\n\tresponse_end(res);\n}\n\nfunction $image_nocache(res) {\n\n\tvar options = res.options;\n\n\t// STREAM\n\tif (options.stream) {\n\t\tvar image = framework_image.load(options.stream);\n\t\toptions.make.call(image, image, res);\n\t\toptions.type = U.getContentType(image.outputType);\n\t\toptions.stream = image;\n\t\tF.stats.response.image++;\n\t\tres.$stream();\n\t\treturn F;\n\t}\n\n\t// FILENAME\n\tfsFileExists(options.filename, function(e) {\n\n\t\tif (e) {\n\t\t\tF.path.verify('temp');\n\t\t\tvar image = framework_image.load(options.filename);\n\t\t\toptions.make.call(image, image, res);\n\t\t\tF.stats.response.image++;\n\t\t\toptions.type = U.getContentType(image.outputType);\n\t\t\toptions.stream = image;\n\t\t\tres.$stream();\n\t\t} else {\n\t\t\toptions.headers = null;\n\t\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(res.req, res))\n\t\t\t\tres.throw404();\n\t\t}\n\t});\n}\n\nfunction $image_processing(res) {\n\tres.$image();\n}\n\nfunction $image_stream(exists, size, isFile, stats, res) {\n\n\tvar req = res.req;\n\tvar options = res.options;\n\n\tif (exists) {\n\t\tdelete F.temporary.processing[req.$key];\n\t\tF.temporary.path[req.$key] = [options.name, stats.size, stats.mtime.toUTCString()];\n\t\tres.options.filename = options.name;\n\n\t\tif (options.stream) {\n\t\t\toptions.stream.once('error', NOOP); // sometimes is throwed: Bad description\n\t\t\tDESTROY(options.stream);\n\t\t\toptions.stream = null;\n\t\t}\n\n\t\tres.$file();\n\t\tDEBUG && (F.temporary.path[req.$key] = undefined);\n\t\treturn;\n\t}\n\n\tF.path.verify('temp');\n\n\tvar image = framework_image.load(options.stream);\n\toptions.make.call(image, image, res);\n\treq.extension = U.getExtension(options.name);\n\n\tif (req.extension !== image.outputType) {\n\t\tvar index = options.name.lastIndexOf('.' + req.extension);\n\t\tif (index !== -1)\n\t\t\toptions.name = options.name.substring(0, index) + '.' + image.outputType;\n\t\telse\n\t\t\toptions.name += '.' + image.outputType;\n\t}\n\n\tF.stats.response.image++;\n\timage.save(options.name, function(err) {\n\n\t\tif (options.stream) {\n\t\t\toptions.stream.once('error', NOOP); // sometimes is throwed: Bad description\n\t\t\tDESTROY(options.stream);\n\t\t\toptions.stream = null;\n\t\t}\n\n\t\tdelete F.temporary.processing[req.$key];\n\t\tif (err) {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tres.throw500(err);\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t} else {\n\t\t\tvar stats = Fs.statSync(options.name);\n\t\t\tF.temporary.path[req.$key] = [options.name, stats.size, stats.mtime.toUTCString()];\n\t\t\toptions.filename = options.name;\n\t\t\tres.$file();\n\t\t}\n\t});\n}\n\nfunction $image_filename(exists, size, isFile, stats, res) {\n\n\tvar req = res.req;\n\tvar options = res.options;\n\n\tif (!exists) {\n\t\tdelete F.temporary.processing[req.$key];\n\t\tF.temporary.notfound[req.$key] = true;\n\t\tif (!F.routes.filesfallback || !F.routes.filesfallback(req, res))\n\t\t\tres.throw404();\n\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\treturn;\n\t}\n\n\tF.path.verify('temp');\n\n\tvar image = framework_image.load(options.filename);\n\toptions.make.call(image, image, res);\n\treq.extension = U.getExtension(options.name);\n\n\tif (req.extension !== image.outputType) {\n\t\tvar index = options.name.lastIndexOf('.' + req.extension);\n\t\tif (index === -1)\n\t\t\toptions.name += '.' + image.outputType;\n\t\telse\n\t\t\toptions.name = options.name.substring(0, index) + '.' + image.outputType;\n\t}\n\n\tF.stats.response.image++;\n\n\timage.save(options.name, function(err) {\n\n\t\tdelete F.temporary.processing[req.$key];\n\n\t\tif (err) {\n\t\t\tF.temporary.notfound[req.$key] = true;\n\t\t\tres.throw500(err);\n\t\t\tDEBUG && (F.temporary.notfound[req.$key] = undefined);\n\t\t} else {\n\t\t\tvar stats = Fs.statSync(options.name);\n\t\t\tF.temporary.path[req.$key] = [options.name, stats.size, stats.mtime.toUTCString()];\n\t\t\tres.options.filename = options.name;\n\t\t\tres.$file();\n\t\t}\n\t});\n}\n\nfunction response_end(res) {\n\n\tF.reqstats(false, res.req.isStaticFile);\n\tres.success = true;\n\n\tif (CONF.allow_reqlimit && F.temporary.ddos[res.req.ip])\n\t\tF.temporary.ddos[res.req.ip]--;\n\n\tif (!res.req.isStaticFile) {\n\t\tF.$events['request-end'] && EMIT('request-end', res.req, res);\n\t\tF.$events.request_end && EMIT('request_end', res.req, res);\n\t}\n\n\tres.req.clear(true);\n\tres.controller && res.req.$total_success();\n\n\tif (res.options.callback) {\n\t\tres.options.callback();\n\t\tres.options.callback = null;\n\t}\n\n\tif (res.options.done) {\n\t\tres.options.done();\n\t\tres.options.done = null;\n\t}\n\n\t// res.options = EMPTYOBJECT;\n\tres.controller = null;\n}\n\n// Handle errors of decodeURIComponent\nfunction $decodeURIComponent(value) {\n\ttry\n\t{\n\t\treturn decodeURIComponent(value);\n\t} catch (e) {\n\t\treturn value;\n\t}\n}\n\nglobal.Controller = Controller;\nglobal.WebSocketClient = WebSocketClient;\n\nprocess.on('unhandledRejection', function(e) {\n\tF.error(e, '', null);\n});\n\nprocess.on('uncaughtException', function(e) {\n\n\tvar err = e.toString();\n\n\tif (err.indexOf('listen EADDRINUSE') !== -1) {\n\t\tprocess.send && process.send('total:eaddrinuse');\n\t\tconsole.log('\\nThe IP address and the PORT is already in use.\\nYou must change the PORT\\'s number or IP address.\\n');\n\t\tprocess.exit(1);\n\t\treturn;\n\t} else if (CONF.allow_filter_errors && REG_SKIPERROR.test(err))\n\t\treturn;\n\n\tF.error(e, '', null);\n});\n\nfunction fsFileRead(filename, callback, a, b, c) {\n\tU.queue('F.files', CONF.default_maxopenfiles, function(next) {\n\t\tF.stats.performance.open++;\n\t\tFs.readFile(filename, function(err, result) {\n\t\t\tnext();\n\t\t\tcallback(err, result, a, b, c);\n\t\t});\n\t});\n}\n\nfunction fsFileExists(filename, callback, a, b, c) {\n\tU.queue('F.files', CONF.default_maxopenfiles, function(next) {\n\t\tF.stats.performance.open++;\n\t\tFs.lstat(filename, function(err, stats) {\n\t\t\tnext();\n\t\t\tcallback(!err && stats.isFile(), stats ? stats.size : 0, stats ? stats.isFile() : false, stats, a, b, c);\n\t\t});\n\t});\n}\n\nfunction fsStreamRead(filename, options, callback, res) {\n\n\tif (!callback) {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\tvar opt;\n\n\tif (options) {\n\n\t\topt = HEADERS.fsStreamReadRange;\n\t\topt.start = options.start;\n\t\topt.end = options.end;\n\n\t\tif (opt.start > opt.end)\n\t\t\tdelete opt.end;\n\n\t} else\n\t\topt = HEADERS.fsStreamRead;\n\n\tU.queue('F.files', CONF.default_maxopenfiles, function(next) {\n\t\tF.stats.performance.open++;\n\t\tvar stream = Fs.createReadStream(filename, opt);\n\t\tstream.on('error', NOOP);\n\t\tcallback(stream, next, res);\n\t}, filename);\n}\n\n/**\n * Prepare URL address to temporary key (for caching)\n * @param {ServerRequest or String} req\n * @return {String}\n */\nfunction createTemporaryKey(req) {\n\treturn (req.uri ? req.uri.pathname : req).replace(REG_TEMPORARY, '_').substring(1);\n}\n\nF.createTemporaryKey = createTemporaryKey;\n\nfunction MiddlewareOptions() {}\n\nMiddlewareOptions.prototype = {\n\n\tget user() {\n\t\treturn this.req.user;\n\t},\n\n\tget session() {\n\t\treturn this.req.session;\n\t},\n\n\tget language() {\n\t\treturn this.req.$language;\n\t},\n\n\tget ip() {\n\t\treturn this.req.ip;\n\t},\n\n\tget headers() {\n\t\treturn this.req.headers;\n\t},\n\n\tget ua() {\n\t\treturn this.req ? this.req.ua : null;\n\t},\n\n\tget sessionid() {\n\t\treturn this.req.sessionid;\n\t},\n\n\tget id() {\n\t\treturn this.controller ? this.controller.id : null;\n\t},\n\n\tget params() {\n\t\treturn this.controller ? this.controller.params : null;\n\t},\n\n\tget files() {\n\t\treturn this.req.files;\n\t},\n\n\tget body() {\n\t\treturn this.req.body;\n\t},\n\n\tget query() {\n\t\treturn this.req.query;\n\t}\n};\n\nconst MiddlewareOptionsProto = MiddlewareOptions.prototype;\n\nMiddlewareOptionsProto.callback = function() {\n\tthis.next();\n\treturn this;\n};\n\nMiddlewareOptionsProto.cancel = function() {\n\tthis.next(false);\n\treturn this;\n};\n\nfunction forcestop() {\n\tF.stop();\n}\n\nprocess.on('SIGTERM', forcestop);\nprocess.on('SIGINT', forcestop);\nprocess.on('exit', forcestop);\n\nfunction process_ping() {\n\tprocess.connected && process.send('total:ping');\n}\n\nprocess.on('message', function(msg, h) {\n\tif (msg === 'total:debug') {\n\t\tU.wait(() => F.isLoaded, function() {\n\t\t\tF.isLoaded = undefined;\n\t\t\tF.console();\n\t\t}, 10000, 500);\n\t} else if (msg === 'reconnect')\n\t\tF.reconnect();\n\telse if (msg === 'total:ping')\n\t\tsetImmediate(process_ping);\n\telse if (msg === 'total:update')\n\t\tEMIT('update');\n\telse if (msg === 'reset')\n\t\tF.cache.clear();\n\telse if (msg === 'stop' || msg === 'exit' || msg === 'kill')\n\t\tF.stop();\n\telse if (msg && msg.TYPE && msg.ID !== F.id) {\n\t\tif (msg.TYPE === 'req')\n\t\t\tF.cluster.req(msg);\n\t\telse if (msg.TYPE === 'res')\n\t\t\tmsg.target === F.id && F.cluster.res(msg);\n\t\telse if (msg.TYPE === 'emit')\n\t\t\tF.$events[msg.name] && EMIT(msg.name, msg.a, msg.b, msg.c, msg.d, msg.e);\n\t\telse if (msg.TYPE === 'nosql-meta')\n\t\t\tNOSQL(msg.name).meta(msg.key, msg.value, true);\n\t\telse if (msg.TYPE === 'table-meta')\n\t\t\tTABLE(msg.name).meta(msg.key, msg.value, true);\n\t\telse if (msg.TYPE === 'session') {\n\t\t\tvar session = SESSION(msg.NAME);\n\t\t\tswitch (msg.method) {\n\t\t\t\tcase 'remove':\n\t\t\t\t\tsession.$sync = false;\n\t\t\t\t\tsession.remove(msg.sessionid);\n\t\t\t\t\tsession.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'remove2':\n\t\t\t\t\tsession.$sync = false;\n\t\t\t\t\tsession.remove2(msg.id);\n\t\t\t\t\tsession.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'set2':\n\t\t\t\t\tsession.$sync = false;\n\t\t\t\t\tsession.set2(msg.id, msg.data, msg.expire, msg.note, msg.settings);\n\t\t\t\t\tsession.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'set':\n\t\t\t\t\tsession.$sync = false;\n\t\t\t\t\tsession.set(msg.sessionid, msg.id, msg.data, msg.expire, msg.note, msg.settings);\n\t\t\t\t\tsession.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'update2':\n\t\t\t\t\tsession.$sync = false;\n\t\t\t\t\tsession.update2(msg.id, msg.data, msg.expire, msg.note, msg.settings);\n\t\t\t\t\tsession.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'update':\n\t\t\t\t\tsession.$sync = false;\n\t\t\t\t\tsession.update(msg.sessionid, msg.data, msg.expire, msg.note, msg.settings);\n\t\t\t\t\tsession.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'clear':\n\t\t\t\t\tsession.$sync = false;\n\t\t\t\t\tsession.clear(msg.lastusage);\n\t\t\t\t\tsession.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'clean':\n\t\t\t\t\tsession.$sync = false;\n\t\t\t\t\tsession.clean();\n\t\t\t\t\tsession.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (msg.TYPE === 'cache') {\n\t\t\tswitch (msg.method) {\n\t\t\t\tcase 'set':\n\t\t\t\t\tF.cache.$sync = false;\n\t\t\t\t\tF.cache.set(msg.name, msg.value, msg.expire);\n\t\t\t\t\tF.cache.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'remove':\n\t\t\t\t\tF.cache.$sync = false;\n\t\t\t\t\tF.cache.remove(msg.name);\n\t\t\t\t\tF.cache.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'clear':\n\t\t\t\t\tF.cache.$sync = false;\n\t\t\t\t\tF.cache.clear();\n\t\t\t\t\tF.cache.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'removeAll':\n\t\t\t\t\tF.cache.$sync = false;\n\t\t\t\t\tF.cache.removeAll(msg.search);\n\t\t\t\t\tF.cache.$sync = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (msg.TYPE === 'filestorage') {\n\t\t\tvar fs = F.databases['storage_' + msg.NAME];\n\t\t\tif (fs) {\n\t\t\t\tswitch (msg.method) {\n\t\t\t\t\tcase 'add':\n\t\t\t\t\t\tfs.meta.index = msg.index;\n\t\t\t\t\t\tfs.meta.count = msg.count;\n\t\t\t\t\t\tif (F.id === '0')\n\t\t\t\t\t\t\tfs.$save();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'remove':\n\t\t\t\t\t\tfs.meta.count = msg.count;\n\t\t\t\t\t\tif (F.id === '0' && msg.id) {\n\t\t\t\t\t\t\tfs.meta.free.push(msg.id);\n\t\t\t\t\t\t\tfs.$save();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'refresh':\n\t\t\t\t\t\tfs.$refresh();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tF.$events.message && EMIT('message', msg, h);\n});\n\nfunction prepare_error(e) {\n\tif (!e)\n\t\treturn '';\n\telse if (e instanceof ErrorBuilder)\n\t\treturn e.plain();\n\telse if (DEBUG)\n\t\treturn e.stack ? e.stack : e.toString();\n}\n\nfunction prepare_filename(name) {\n\treturn name[0] === '@' ? (F.isWindows ? U.combine(CONF.directory_temp, name.substring(1)) : F.path.package(name.substring(1))) : U.combine('/', name);\n}\n\nfunction prepare_staticurl(url, isDirectory) {\n\tif (!url)\n\t\treturn url;\n\tif (url[0] === '~') {\n\t\tif (isDirectory)\n\t\t\treturn U.path(url.substring(1));\n\t} else if (url.substring(0, 2) === '//' || url.substring(0, 6) === 'http:/' || url.substring(0, 7) === 'https:/')\n\t\treturn url;\n\treturn url;\n}\n\nfunction prepare_isomorphic(name, value) {\n\treturn 'if(window[\"isomorphic\"]===undefined)window.isomorphic=window.I={};isomorphic[\"' + name.replace(/\\.js$/i, '') + '\"]=(function(framework,F,U,utils,Utils,is_client,is_server){var module={},exports=module.exports={};' + value + ';return exports;})(null,null,null,null,null,true,false)';\n}\n\nfunction isGZIP(req) {\n\tvar ua = req.headers['user-agent'];\n\treturn ua && ua.lastIndexOf('Firefox') !== -1;\n}\n\nfunction prepare_viewname(value) {\n\t// Cleans theme name\n\treturn value.substring(value.indexOf('/', 2) + 1);\n}\n\nfunction existsSync(filename, file) {\n\ttry {\n\t\tvar val = Fs.statSync(filename);\n\t\treturn val ? (file ? val.isFile() : true) : false;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nfunction getLoggerMiddleware(name) {\n\treturn 'MIDDLEWARE(\"' + name + '\")';\n}\n\nfunction async_middleware(index, req, res, middleware, callback, options, controller) {\n\n\tif (res.success || res.headersSent || res.finished) {\n\t\treq.$total_route && req.$total_success();\n\t\tcallback = null;\n\t\treturn;\n\t}\n\n\tvar name = middleware[index++];\n\tif (!name)\n\t\treturn callback && callback(req, res);\n\n\tvar item = F.routes.middleware[name];\n\tif (!item) {\n\t\tF.error('Middleware not found: ' + name, null, req.uri);\n\t\treturn async_middleware(index, req, res, middleware, callback, options, controller);\n\t}\n\n\tvar output;\n\tvar $now;\n\n\tif (CONF.logger)\n\t\t$now = Date.now();\n\n\tif (item.$newversion) {\n\t\tvar opt = req.$total_middleware;\n\t\tif (!index || !opt) {\n\t\t\topt = req.$total_middleware = new MiddlewareOptions();\n\t\t\topt.req = req;\n\t\t\topt.res = res;\n\t\t\topt.middleware = middleware;\n\t\t\topt.options = options || EMPTYOBJECT;\n\t\t\topt.controller = controller;\n\t\t\topt.callback2 = callback;\n\t\t\topt.next = function(err) {\n\t\t\t\tCONF.logger && F.ilogger(getLoggerMiddleware(name), req, $now);\n\t\t\t\tvar mid = req.$total_middleware;\n\t\t\t\tif (err === false) {\n\t\t\t\t\treq.$total_route && req.$total_success();\n\t\t\t\t\treq.$total_middleware = null;\n\t\t\t\t\tcallback = null;\n\t\t\t\t} else if (err instanceof Error || err instanceof ErrorBuilder) {\n\t\t\t\t\tres.throw500(err);\n\t\t\t\t\treq.$total_middleware = null;\n\t\t\t\t\tcallback = null;\n\t\t\t\t} else\n\t\t\t\t\tasync_middleware(mid.index, mid.req, mid.res, mid.middleware, mid.callback2, mid.options, mid.controller);\n\t\t\t};\n\t\t}\n\n\t\topt.index = index;\n\t\toutput = item(opt);\n\n\t} else {\n\t\toutput = item.call(framework, req, res, function(err) {\n\t\t\tCONF.logger && F.ilogger(getLoggerMiddleware(name), req, $now);\n\t\t\tif (err === false) {\n\t\t\t\treq.$total_route && req.$total_success();\n\t\t\t\tcallback = null;\n\t\t\t} else if (err instanceof Error || err instanceof ErrorBuilder) {\n\t\t\t\tres.throw500(err);\n\t\t\t\tcallback = null;\n\t\t\t} else\n\t\t\t\tasync_middleware(index, req, res, middleware, callback, options, controller);\n\t\t}, options, controller);\n\t}\n\n\tif (res.headersSent || res.finished) {\n\t\treq.$total_route && req.$total_success();\n\t\tcallback = null;\n\t\treturn;\n\t} else if (output !== false)\n\t\treturn;\n\n\treq.$total_route && req.$total_success();\n\tcallback = null;\n}\n\nglobal.setTimeout2 = function(name, fn, timeout, limit, param) {\n\tvar key = ':' + name;\n\tvar internal = F.temporary.internal;\n\n\tif (limit > 0) {\n\n\t\tvar key2 = key + '_limit';\n\t\tvar key3 = key + '_fn';\n\n\t\tif (internal[key2] >= limit) {\n\t\t\tinternal[key] && clearTimeout(internal[key]);\n\t\t\tinternal[key] = internal[key2] = internal[key3] = undefined;\n\t\t\tfn();\n\t\t\treturn;\n\t\t}\n\n\t\tinternal[key] && clearTimeout(internal[key]);\n\t\tinternal[key2] = (internal[key2] || 0) + 1;\n\n\t\treturn internal[key] = setTimeout(function(param, key) {\n\t\t\tF.temporary.internal[key] = F.temporary.internal[key + '_limit'] = F.temporary.internal[key + '_fn'] = undefined;\n\t\t\tfn && fn(param);\n\t\t}, timeout, param, key);\n\t}\n\n\tif (internal[key]) {\n\t\tclearTimeout(internal[key]);\n\t\tinternal[key] = undefined;\n\t}\n\n\treturn internal[key] = setTimeout(fn, timeout, param);\n};\n\nglobal.clearTimeout2 = function(name) {\n\tvar key = ':' + name;\n\n\tif (F.temporary.internal[key]) {\n\t\tclearTimeout(F.temporary.internal[key]);\n\t\tF.temporary.internal[key] = undefined;\n\t\tF.temporary.internal[key + ':limit'] && (F.temporary.internal[key + ':limit'] = undefined);\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nfunction parseComponent(body, filename) {\n\n\tvar response = {};\n\tresponse.css = '';\n\tresponse.js = '';\n\tresponse.install = '';\n\tresponse.files = {};\n\tresponse.parts = {};\n\n\tvar beg = 0;\n\tvar end = 0;\n\tvar comname = U.getName(filename);\n\n\t// Files\n\twhile (true) {\n\t\tbeg = body.indexOf('<file ');\n\t\tif (beg === -1)\n\t\t\tbreak;\n\n\t\tend = body.indexOf('</file>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\n\t\tvar data = body.substring(beg, end);\n\t\tbody = body.substring(0, beg) + body.substring(end + 7);\n\n\t\t// Creates directory\n\t\tvar p = F.path.temp() + '~' + comname;\n\t\ttry {\n\t\t\tFs.mkdirSync(p);\n\t\t} catch (e) {}\n\n\t\tvar tmp = data.indexOf('>');\n\t\tbeg = data.lastIndexOf('name=\"', tmp);\n\t\tvar name = data.substring(beg + 6, data.indexOf('\"', beg + 7));\n\t\tvar encoding;\n\n\t\tbeg = data.lastIndexOf('encoding=\"', tmp);\n\t\tif (beg !== -1)\n\t\t\tencoding = data.substring(beg + 10, data.indexOf('\"', beg + 11));\n\n\t\tdata = data.substring(tmp + 1);\n\t\tF.$bundling && Fs.writeFile(U.join(p, name), data.trim(), encoding || 'base64', NOOP);\n\t\tresponse.files[name] = 1;\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('@{part');\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = body.indexOf('@{end}', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tvar tmp = body.substring(beg, end);\n\t\tvar tmpend = tmp.indexOf('}', 4);\n\t\tresponse.parts[tmp.substring(tmp.indexOf(' '), tmpend).trim()] = body.substring(beg + tmpend + 1, end).trim();\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 8).trim();\n\t\tend += 5;\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('<script type=\"text/totaljs\">');\n\t\tif (beg === -1) {\n\t\t\tbeg = body.indexOf('<script total>');\n\t\t\tif (beg === -1)\n\t\t\t\tbeg = body.indexOf('<script totaljs>');\n\t\t\tif (beg === -1)\n\t\t\t\tbreak;\n\t\t}\n\t\tend = body.indexOf('</script>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tresponse.install += (response.install ? '\\n' : '') + body.substring(beg, end).replace(/<(\\/)?script.*?>/g, '');\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 9).trim();\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('<style');\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = body.indexOf('</style>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tresponse.css += (response.css ? '\\n' : '') + body.substring(beg, end).replace(/<(\\/)?style.*?>/g, '');\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 8).trim();\n\t}\n\n\twhile (true) {\n\t\tbeg = body.indexOf('<script>');\n\t\tif (beg === -1) {\n\t\t\tbeg = body.indexOf('<script type=\"text/javascript\">');\n\t\t\tif (beg === -1)\n\t\t\t\tbreak;\n\t\t}\n\t\tend = body.indexOf('</script>', beg);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tresponse.js += (response.js ? '\\n' : '') + body.substring(beg, end).replace(/<(\\/)?script.*?>/g, '');\n\t\tbody = body.substring(0, beg).trim() + body.substring(end + 9).trim();\n\t}\n\n\tif (response.js)\n\t\tresponse.js = framework_internal.compile_javascript(response.js, filename);\n\n\tif (response.css)\n\t\tresponse.css = framework_internal.compile_css(response.css, filename);\n\n\tresponse.body = body;\n\treturn response;\n}\n\nfunction getSchemaName(schema, params) {\n\tif (!(schema instanceof Array))\n\t\tschema = schema.split('/');\n\treturn schema[0] === 'default' ? (params ? params[schema[1]] : schema[1]) : (schema.length > 1 ? (schema[0] + '/' + schema[1]) : schema[0]);\n}\n\n// Default action for workflow routing\nfunction controller_json_workflow(id) {\n\tvar self = this;\n\tvar w = self.route.workflow;\n\n\tself.id = self.route.paramidindex === -1 ? id : self.req.split[self.route.paramidindex];\n\n\tCONF.logger && (self.req.$logger = []);\n\n\tif (w instanceof Object) {\n\n\t\tif (!w.type) {\n\n\t\t\t// IS IT AN OPERATION?\n\t\t\tif (!self.route.schema.length) {\n\t\t\t\tOPERATION(w.id, self.body, w.view ? self.callback(w.view) : self.callback(), self);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar schema = self.route.isDYNAMICSCHEMA ? framework_builders.findschema(self.req.$schemaname || (self.route.schema[0] + '/' + self.params[self.route.schema[1]])) : GETSCHEMA(self.route.schema[0], self.route.schema[1]);\n\t\t\tif (!schema) {\n\t\t\t\tvar err = 'Schema \"{0}\" not found.'.format(getSchemaName(self.route.schema, self.route.isDYNAMICSCHEMA ? self.params : null));\n\t\t\t\tif (self.route.isDYNAMICSCHEMA)\n\t\t\t\t\tself.throw404(err);\n\t\t\t\telse\n\t\t\t\t\tself.throw500(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (schema.meta[w.id] !== undefined) {\n\t\t\t\tw.type = '$' + w.id;\n\t\t\t} else if (schema.meta['workflow#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$workflow';\n\t\t\t\tw.name = w.id;\n\t\t\t} else if (schema.meta['transform#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$transform';\n\t\t\t\tw.name = w.id;\n\t\t\t} else if (schema.meta['operation#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$operation';\n\t\t\t\tw.name = w.id;\n\t\t\t} else if (schema.meta['hook#' + w.id] !== undefined) {\n\t\t\t\tw.type = '$hook';\n\t\t\t\tw.name = w.id;\n\t\t\t}\n\t\t}\n\n\t\tif (w.name)\n\t\t\tself[w.type](w.name, self.callback(w.view));\n\t\telse {\n\n\t\t\tif (w.type)\n\t\t\t\tself[w.type](self.callback(w.view));\n\t\t\telse {\n\t\t\t\tvar err = 'Schema \"{0}\" does not contain \"{1}\" operation.'.format(schema.name, w.id);\n\t\t\t\tif (self.route.isDYNAMICSCHEMA)\n\t\t\t\t\tself.throw404(err);\n\t\t\t\telse\n\t\t\t\t\tself.throw500(err);\n\t\t\t}\n\t\t}\n\n\t\tif (self.route.isDYNAMICSCHEMA)\n\t\t\tw.type = '';\n\n\t} else\n\t\tself.$exec(w, null, self.callback(w.view));\n}\n\n// Default action for workflow routing\nfunction controller_json_workflow_multiple(id) {\n\n\tvar self = this;\n\tvar w = self.route.workflow;\n\n\tself.id = self.route.paramidindex === -1 ? id : self.req.split[self.route.paramidindex];\n\tCONF.logger && (self.req.$logger = []);\n\n\tif (w instanceof Object) {\n\t\tif (!w.type) {\n\n\t\t\t// IS IT AN OPERATION?\n\t\t\tif (!self.route.schema.length) {\n\t\t\t\tRUN(w.id, self.body, w.view ? self.callback(w.view) : self.callback(), null, self, w.index != null ? w.id[w.index] : null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar schema = self.route.isDYNAMICSCHEMA ? framework_builders.findschema(self.route.schema[0] + '/' + self.params[self.route.schema[1]]) : GETSCHEMA(self.route.schema[0], self.route.schema[1]);\n\t\t\tif (!schema) {\n\t\t\t\tself.throw500('Schema \"{0}\" not found.'.format(getSchemaName(self.route.schema, self.isDYNAMICSCHEMA ? self.params : null)));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar op = [];\n\t\t\tfor (var i = 0; i < w.id.length; i++) {\n\t\t\t\tvar id = w.id[i];\n\t\t\t\tif (schema.meta[id] !== undefined) {\n\t\t\t\t\top.push({ name: '$' + id });\n\t\t\t\t} else if (schema.meta['workflow#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$workflow', id: id });\n\t\t\t\t} else if (schema.meta['transform#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$transform', id: id });\n\t\t\t\t} else if (schema.meta['operation#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$operation', id: id });\n\t\t\t\t} else if (schema.meta['hook#' + id] !== undefined) {\n\t\t\t\t\top.push({ name: '$hook', id: id });\n\t\t\t\t} else {\n\t\t\t\t\t// not found\n\t\t\t\t\tself.throw500('Schema \"{0}\" does not contain \"{1}\" operation.'.format(schema.name, id));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tw.async = op;\n\t\t}\n\n\t\tvar async = self.$async(self.callback(w.view), w.index);\n\t\tfor (var i = 0; i < w.async.length; i++) {\n\t\t\tvar a = w.async[i];\n\t\t\tif (a.id)\n\t\t\t\tasync[a.name](a.id);\n\t\t\telse\n\t\t\t\tasync[a.name]();\n\t\t}\n\t} else\n\t\tself.$exec(w, null, self.callback(w.view));\n}\n\nfunction ilogger(body) {\n\tF.path.verify('logs');\n\tU.queue('F.ilogger', 5, (next) => Fs.appendFile(U.combine(CONF.directory_logs, 'logger.log'), body, next));\n}\n\nF.ilogger = function(name, req, ts) {\n\n\tif (req && req instanceof Controller)\n\t\treq = req.req;\n\n\tvar isc = CONF.logger === 'console';\n\tvar divider = '';\n\n\tfor (var i = 0; i < (isc ? 64 : 220); i++)\n\t\tdivider += '-';\n\n\tvar msg;\n\n\tif (req && !name && req.$logger && req.$logger.length) {\n\n\t\tmsg = req.method + ' ' + req.url;\n\n\t\treq.$logger.unshift(msg);\n\t\treq.$logger.push(divider);\n\n\t\tif (isc)\n\t\t\tconsole.log(req.$logger.join('\\n'));\n\t\telse {\n\t\t\treq.$logger.push('');\n\t\t\tilogger(req.$logger.join('\\n'));\n\t\t}\n\n\t\treq.$logger = null;\n\t\treturn;\n\t}\n\n\tif (!name)\n\t\treturn;\n\n\tvar dt = new Date();\n\n\tmsg = dt.format('yyyy-MM-dd HH:mm:ss') + ' | ' + name.padRight(40, ' ') + ' | ' + (((dt.getTime() - ts) / 1000).format(3) + ' sec.').padRight(12) + ' | ' + (req ? (req.method + ' ' + req.url).max(70) : '').padRight(70);\n\n\tif (isc) {\n\t\tif (req && req.$logger)\n\t\t\treq.$logger.push(msg);\n\t\telse\n\t\t\tconsole.log(msg + '\\n' + divider);\n\t} else {\n\t\tmsg = msg + ' | ' + (req ? (req.ip || '') : '').padRight(20) + ' | ' + (req && req.headers ? (req.headers['user-agent'] || '') : '');\n\t\tif (req && req.$logger)\n\t\t\treq.$logger.push(msg);\n\t\telse\n\t\t\tilogger(msg + '\\n' + divider + '\\n');\n\t}\n};\n\nfunction evalroutehandleraction(controller) {\n\tif (controller.route.isPARAM)\n\t\tcontroller.route.execute.apply(controller, framework_internal.routeParam(controller.req.split, controller.route));\n\telse\n\t\tcontroller.route.execute.call(controller);\n}\n\nfunction evalroutehandler(controller) {\n\tif (!controller.route.schema || !controller.route.schema[1] || controller.req.method === 'DELETE' || controller.req.method === 'GET')\n\t\treturn evalroutehandleraction(controller);\n\n\tF.onSchema(controller.req, controller.route, function(err, body) {\n\t\tif (err) {\n\t\t\tcontroller.$evalroutecallback(err, body);\n\t\t} else {\n\t\t\tcontroller.body = body;\n\t\t\tevalroutehandleraction(controller);\n\t\t}\n\t});\n}\n\nglobal.ACTION = function(url, data, callback) {\n\n\tif (typeof(data) === 'function') {\n\t\tcallback = data;\n\t\tdata = null;\n\t}\n\n\tvar index = url.indexOf(' ');\n\tvar method = url.substring(0, index);\n\tvar params = '';\n\tvar route;\n\n\turl = url.substring(index + 1);\n\tindex = url.indexOf('?');\n\n\tif (index !== -1) {\n\t\tparams = url.substring(index + 1);\n\t\turl = url.substring(0, index);\n\t}\n\n\turl = url.trim();\n\tvar routeurl = url;\n\n\tif (routeurl.endsWith('/'))\n\t\trouteurl = routeurl.substring(0, routeurl.length - 1);\n\n\tvar req = {};\n\tvar res = {};\n\n\treq.res = res;\n\treq.$protocol = 'http';\n\treq.url = url;\n\treq.ip = F.ip || '127.0.0.1';\n\treq.host = req.ip + ':' + (F.port || 8000);\n\treq.headers = { 'user-agent': 'Total.js/v' + F.version_header };\n\treq.uri = framework_internal.parseURI(req);\n\treq.path = framework_internal.routeSplit(req.uri.pathname);\n\treq.body = data || {};\n\treq.query = params ? F.onParseQuery(params) : {};\n\treq.files = EMPTYARRAY;\n\treq.method = method;\n\tres.options = req.options = {};\n\n\tvar route = F.lookupaction(req, url);\n\tif (!route)\n\t\treturn;\n\n\tif (route.isPARAM)\n\t\treq.split = framework_internal.routeSplit(req.uri.pathname, true);\n\telse\n\t\treq.split = EMPTYARRAY;\n\n\tvar controller = new Controller(route.controller, null, null, route.currentViewDirectory);\n\tcontroller.route = route;\n\tcontroller.req = req;\n\tcontroller.res = res;\n\n\tres.$evalroutecallback = controller.$evalroutecallback = callback || NOOP;\n\tsetImmediate(evalroutehandler, controller);\n\treturn controller;\n};\n\nfunction runsnapshot() {\n\n\tvar main = {};\n\tvar stats = {};\n\tvar lastwarning = 0;\n\n\tstats.id = F.id;\n\tstats.version = {};\n\tstats.version.node = process.version;\n\tstats.version.total = F.version_header;\n\tstats.version.app = CONF.version;\n\tstats.pid = process.pid;\n\tstats.thread = global.THREAD;\n\tstats.mode = DEBUG ? 'debug' : 'release';\n\tstats.overload = 0;\n\n\tmain.pid = process.pid;\n\tmain.stats = [stats];\n\n\tF.snapshotstats = function() {\n\n\t\tvar memory = process.memoryUsage();\n\t\tstats.date = NOW;\n\t\tstats.memory = (memory.heapUsed / 1024 / 1024).floor(2);\n\t\tstats.rm = F.temporary.service.request || 0;      // request min\n\t\tstats.fm = F.temporary.service.file || 0;         // files min\n\t\tstats.wm = F.temporary.service.message || 0;      // websocket messages min\n\t\tstats.mm = F.temporary.service.mail || 0;         // mail min\n\t\tstats.om = F.temporary.service.open || 0;         // mail min\n\t\tstats.em = F.temporary.service.external || 0;     // external requests min\n\t\tstats.dbrm = F.temporary.service.dbrm || 0;       // DB read min\n\t\tstats.dbwm = F.temporary.service.dbwm || 0;       // DB write min\n\t\tstats.usage = F.temporary.service.usage.floor(2); // app usage in %\n\t\tstats.requests = F.stats.request.request;\n\t\tstats.pending = F.stats.request.pending;\n\t\tstats.errors = F.stats.error;\n\t\tstats.timeouts = F.stats.response.error408;\n\t\tstats.uptime = F.cache.count;\n\t\tstats.online = F.stats.performance.online;\n\n\t\tvar err = F.errors[F.errors.length - 1];\n\t\tvar timeout = F.timeouts[F.timeouts.length - 1];\n\n\t\tstats.lasterror = err ? (err.date.toJSON() + ' ' + (err.error ? err.error : err)) : undefined;\n\t\tstats.lasttimeout = timeout;\n\n\t\tif ((stats.usage > 80 || stats.memory > 600 || stats.pending > 1000) && lastwarning !== NOW.getHours()) {\n\t\t\tlastwarning = NOW.getHours();\n\t\t\tstats.overload++;\n\t\t}\n\n\t\tif (F.isCluster) {\n\t\t\tif (process.connected) {\n\t\t\t\tCLUSTER_SNAPSHOT.data = stats;\n\t\t\t\tprocess.send(CLUSTER_SNAPSHOT);\n\t\t\t}\n\t\t} else\n\t\t\tFs.writeFile(process.mainModule.filename + '.json', JSON.stringify(main, null, '  '), NOOP);\n\t};\n}\n\nvar lastusagedate;\n\nfunction measure_usage_response() {\n\tvar diff = (Date.now() - lastusagedate) - 60;\n\tif (diff > 50)\n\t\tdiff = 50;\n\tvar val = diff < 0 ? 0 : (diff / 50) * 100;\n\tif (F.temporary.service.usage < val)\n\t\tF.temporary.service.usage = val;\n\tF.stats.performance.usage = val;\n}\n\nfunction measure_usage() {\n\tlastusagedate = Date.now();\n\tsetTimeout(measure_usage_response, 50);\n}\n\n// Because of controller prototypes\n// It's used in VIEW() and VIEWCOMPILE()\nconst EMPTYCONTROLLER = new Controller('', null, null, '');\nEMPTYCONTROLLER.isConnected = false;\nEMPTYCONTROLLER.req = {};\nEMPTYCONTROLLER.req.url = '';\nEMPTYCONTROLLER.req.uri = EMPTYOBJECT;\nEMPTYCONTROLLER.req.query = EMPTYOBJECT;\nEMPTYCONTROLLER.req.body = EMPTYOBJECT;\nEMPTYCONTROLLER.req.files = EMPTYARRAY;\nglobal.EMPTYCONTROLLER = EMPTYCONTROLLER;\n"
        },
        {
          "name": "internal.js",
          "type": "blob",
          "size": 80.505859375,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkInternal\n * @version 3.4.3\n */\n\n'use strict';\n\nconst Crypto = require('crypto');\nconst Fs = require('fs');\nconst ReadStream = Fs.ReadStream;\nconst Stream = require('stream');\nconst ENCODING = 'utf8';\nconst EMPTYARRAY = [];\nconst EMPTYOBJECT = {};\nconst CONCAT = [null, null];\n\nif (!global.framework_utils)\n\tglobal.framework_utils = require('./utils');\n\nObject.freeze(EMPTYOBJECT);\nObject.freeze(EMPTYARRAY);\n\nconst REG_1 = /[\\n\\r\\t]+/g;\nconst REG_2 = /\\s{2,}/g;\nconst REG_4 = /\\n\\s{2,}./g;\nconst REG_5 = />\\n\\s{1,}</g;\nconst REG_6 = /[<\\w\"\\u0080-\\u07ff\\u0400-\\u04FF]+\\s{2,}[\\w\\u0080-\\u07ff\\u0400-\\u04FF>]+/;\nconst REG_7 = /\\\\/g;\nconst REG_8 = /'/g;\nconst REG_9 = />\\n\\s+/g;\nconst REG_10 = /(\\w|\\W)\\n\\s+</g;\nconst REG_WIN = /\\r/g;\nconst REG_BLOCK_BEG = /@\\{block.*?\\}/i;\nconst REG_BLOCK_END = /@\\{end\\}/i;\nconst REG_SKIP_1 = /\\('|\"/;\nconst REG_SKIP_2 = /,(\\s)?\\w+/;\nconst REG_COMPONENTS_GROUP = /('|\")[a-z0-9_]+('|\")/i;\nconst HTTPVERBS = { 'get': true, 'post': true, 'options': true, 'put': true, 'delete': true, 'patch': true, 'upload': true, 'head': true, 'trace': true, 'propfind': true };\nconst RENDERNOW = ['self.$import(', 'self.route', 'self.$js(', 'self.$css(', 'self.$favicon(', 'self.$script(', '$STRING(self.resource(', '$STRING(RESOURCE(', 'self.translate(', 'language', 'self.sitemap_url(', 'self.sitemap_name(', '$STRING(CONFIG(', '$STRING(config.', '$STRING(config[', '$STRING(CONF.', '$STRING(CONF[', '$STRING(config('];\nconst REG_NOTRANSLATE = /@\\{notranslate\\}/gi;\nconst REG_NOCOMPRESS = /@\\{nocompress\\s\\w+}/gi;\nconst REG_TAGREMOVE = /[^>](\\r)\\n\\s{1,}$/;\nconst REG_HELPERS = /helpers\\.[a-z0-9A-Z_$]+\\(.*?\\)+/g;\nconst REG_SITEMAP = /\\s+(sitemap_navigation\\(|sitemap\\()+/g;\nconst REG_CSS_0 = /\\s{2,}|\\t/g;\nconst REG_CSS_1 = /\\n/g;\nconst REG_CSS_2 = /\\s?\\{\\s{1,}/g;\nconst REG_CSS_3 = /\\s?\\}\\s{1,}/g;\nconst REG_CSS_4 = /\\s?:\\s{1,}/g;\nconst REG_CSS_5 = /\\s?;\\s{1,}/g;\nconst REG_CSS_6 = /,\\s{1,}/g;\nconst REG_CSS_7 = /\\s\\}/g;\nconst REG_CSS_8 = /\\s\\{/g;\nconst REG_CSS_9 = /;\\}/g;\nconst REG_CSS_10 = /\\$[a-z0-9-_]+(\\s)*:.*?;/gi;\nconst REG_CSS_11 = /\\$.*?(\\s|;|\\}|!)/gi;\nconst REG_CSS_12 = /(margin|padding):.*?(;|})/g;\nconst REG_CSS_13 = /#(0{6}|1{6}|2{6}|3{6}|4{6}|5{6}|6{6}|7{6}|8{6}|9{6}|0{6}|A{6}|B{6}|C{6}|D{6}|E{6}|F{6})/gi;\nconst REG_VIEW_PART = /\\/\\*PART.*?\\*\\//g;\nconst AUTOVENDOR = ['filter', 'appearance', 'column-count', 'column-gap', 'column-rule', 'display', 'transform', 'transform-style', 'transform-origin', 'transition', 'user-select', 'animation', 'perspective', 'animation-name', 'animation-duration', 'animation-timing-function', 'animation-delay', 'animation-iteration-count', 'animation-direction', 'animation-play-state', 'opacity', 'background', 'background-image', 'font-smoothing', 'text-size-adjust', 'backface-visibility', 'box-sizing', 'overflow-scrolling'];\nconst WRITESTREAM = { flags: 'w' };\nconst ALLOWEDMARKUP = { G: 1, M: 1, R: 1, repository: 1, model: 1, CONF: 1, config: 1, global: 1, resource: 1, RESOURCE: 1, CONFIG: 1, author: 1, root: 1, functions: 1, NOW: 1, F: 1 };\n\nvar INDEXFILE = 0;\n\nglobal.$STRING = function(value) {\n\treturn value != null ? value.toString() : '';\n};\n\nglobal.$VIEWCACHE = [];\nglobal.$VIEWASYNC = 0;\n\nexports.parseMULTIPART = function(req, contentType, route, tmpDirectory) {\n\n\tvar beg = contentType.indexOf('boundary=');\n\tif (beg === -1) {\n\t\tF.reqstats(false, false);\n\t\tF.stats.request.error400++;\n\t\treq.res.writeHead(400);\n\t\treq.res.end();\n\t\treturn;\n\t}\n\n\tvar end = contentType.length;\n\n\tfor (var i = (beg + 10); i < end; i++) {\n\t\tif (contentType[i] === ';' || contentType[i] === ' ') {\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar boundary = contentType.substring(beg + 9, end);\n\n\t// For unexpected closing\n\treq.once('close', () => !req.$upload && req.clear());\n\n\tvar parser = new MultipartParser();\n\tvar size = 0;\n\tvar maximumSize = route.length;\n\tvar close = 0;\n\tvar stream;\n\tvar tmp;\n\tvar rm;\n\tvar fn_close = function() {\n\t\tclose--;\n\t};\n\n\t// Replaces the EMPTYARRAY and EMPTYOBJECT in index.js\n\treq.files = [];\n\treq.body = {};\n\n\tvar path = framework_utils.combine(tmpDirectory, (F.id ? 'i-' + F.id + '_' : '') + 'uploadedfile-');\n\n\treq.buffer_exceeded = false;\n\treq.buffer_has = true;\n\treq.buffer_parser = parser;\n\tparser.initWithBoundary(boundary);\n\n\tparser.onPartBegin = function() {\n\n\t\tif (req.buffer_exceeded)\n\t\t\treturn;\n\n\t\t// Temporary data\n\t\ttmp = new HttpFile();\n\t\ttmp.$data = Buffer.alloc(0);\n\t\ttmp.$step = 0;\n\t\ttmp.$is = false;\n\t\ttmp.length = 0;\n\t};\n\n\tparser.onHeaderValue = function(buffer, start, end) {\n\n\t\tif (req.buffer_exceeded)\n\t\t\treturn;\n\n\t\tvar header = buffer.slice(start, end).toString(ENCODING);\n\n\t\tif (tmp.$step === 1) {\n\t\t\tvar index = header.indexOf(';');\n\t\t\tif (index === -1)\n\t\t\t\ttmp.type = header.trim();\n\t\t\telse\n\t\t\t\ttmp.type = header.substring(0, index).trim();\n\n\t\t\ttmp.$step = 2;\n\t\t\treturn;\n\t\t}\n\n\t\tif (tmp.$step !== 0)\n\t\t\treturn;\n\n\t\t// UNKNOWN ERROR, maybe attack\n\t\tif (header.indexOf('form-data; ') === -1) {\n\t\t\treq.buffer_exceeded = true;\n\t\t\t!tmp.$is && destroyStream(stream);\n\t\t\treturn;\n\t\t}\n\n\t\theader = parse_multipart_header(header);\n\t\ttmp.$step = 1;\n\t\ttmp.$is = header[1] !== null;\n\t\ttmp.name = header[0];\n\n\t\tif (!tmp.$is) {\n\t\t\tdestroyStream(stream);\n\t\t\treturn;\n\t\t}\n\n\t\ttmp.filename = header[1];\n\n\t\t// IE9 sends absolute filename\n\t\tvar index = tmp.filename.lastIndexOf('\\\\');\n\n\t\t// For Unix like senders\n\t\tif (index === -1)\n\t\t\tindex = tmp.filename.lastIndexOf('/');\n\n\t\tif (index !== -1)\n\t\t\ttmp.filename = tmp.filename.substring(index + 1);\n\n\t\ttmp.path = path + (INDEXFILE++) + '.bin';\n\t};\n\n\tparser.onPartData = function(buffer, start, end) {\n\n\t\tif (req.buffer_exceeded)\n\t\t\treturn;\n\n\t\tvar data = buffer.slice(start, end);\n\t\tvar length = data.length;\n\n\t\tsize += length;\n\n\t\tif (size >= maximumSize) {\n\t\t\treq.buffer_exceeded = true;\n\t\t\tif (rm)\n\t\t\t\trm.push(tmp.path);\n\t\t\telse\n\t\t\t\trm = [tmp.path];\n\t\t\treturn;\n\t\t}\n\n\t\tif (!tmp.$is) {\n\t\t\tCONCAT[0] = tmp.$data;\n\t\t\tCONCAT[1] = data;\n\t\t\ttmp.$data = Buffer.concat(CONCAT);\n\t\t\treturn;\n\t\t}\n\n\t\tif (tmp.length) {\n\t\t\tstream.write(data);\n\t\t\ttmp.length += length;\n\t\t\treturn;\n\t\t}\n\n\t\tvar wh = null;\n\n\t\tswitch (tmp.type) {\n\t\t\tcase 'image/jpeg':\n\t\t\t\twh = framework_image.measureJPG(buffer.slice(start));\n\t\t\t\tbreak;\n\t\t\tcase 'image/gif':\n\t\t\t\twh = framework_image.measureGIF(data);\n\t\t\t\tbreak;\n\t\t\tcase 'image/png':\n\t\t\t\twh = framework_image.measurePNG(data);\n\t\t\t\tbreak;\n\t\t\tcase 'image/svg+xml':\n\t\t\t\twh = framework_image.measureSVG(data);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (wh) {\n\t\t\ttmp.width = wh.width;\n\t\t\ttmp.height = wh.height;\n\t\t} else {\n\t\t\ttmp.width = 0;\n\t\t\ttmp.height = 0;\n\t\t}\n\n\t\treq.files.push(tmp);\n\t\tF.$events['upload-begin'] && EMIT('upload-begin', req, tmp);\n\t\tF.$events.upload_begin && EMIT('upload_begin', req, tmp);\n\t\tclose++;\n\t\tstream = Fs.createWriteStream(tmp.path, WRITESTREAM);\n\t\tstream.once('close', fn_close);\n\t\tstream.once('error', fn_close);\n\t\tstream.write(data);\n\t\ttmp.length += length;\n\t};\n\n\tparser.onPartEnd = function() {\n\n\t\tif (stream) {\n\t\t\tstream.end();\n\t\t\tstream = null;\n\t\t}\n\n\t\tif (req.buffer_exceeded)\n\t\t\treturn;\n\n\t\tif (tmp == null)\n\t\t\treturn;\n\n\t\tif (tmp.$is) {\n\t\t\ttmp.$data = undefined;\n\t\t\ttmp.$is = undefined;\n\t\t\ttmp.$step = undefined;\n\t\t\tF.$events['upload-end'] && F.emit('upload-end', req, tmp);\n\t\t\tF.$events.upload_end && F.emit('upload_end', req, tmp);\n\t\t\treturn;\n\t\t}\n\n\t\ttmp.$data = tmp.$data.toString(ENCODING);\n\n\t\tvar temporary = req.body[tmp.name];\n\t\tif (temporary === undefined) {\n\t\t\treq.body[tmp.name] = tmp.$data;\n\t\t} else if (temporary instanceof Array) {\n\t\t\treq.body[tmp.name].push(tmp.$data);\n\t\t} else {\n\t\t\ttemporary = [temporary];\n\t\t\ttemporary.push(tmp.$data);\n\t\t\treq.body[tmp.name] = temporary;\n\t\t}\n\t};\n\n\tparser.onEnd = function() {\n\n\t\tif (close) {\n\t\t\tsetImmediate(parser.onEnd);\n\t\t} else {\n\t\t\trm && F.unlink(rm);\n\t\t\treq.$total_end2();\n\t\t}\n\t};\n\n\treq.on('data', uploadparser);\n\treq.on('end', uploadparser_done);\n};\n\nfunction uploadparser(chunk) {\n\tthis.buffer_parser.write(chunk);\n}\n\nfunction uploadparser_done() {\n\t!this.buffer_exceeded && (this.$upload = true);\n\tthis.buffer_parser.end();\n}\n\nfunction parse_multipart_header(header) {\n\n\tvar arr = new Array(2);\n\tvar find = ' name=\"';\n\tvar length = find.length;\n\tvar beg = header.indexOf(find);\n\tvar tmp = '';\n\n\tif (beg !== -1)\n\t\ttmp = header.substring(beg + length, header.indexOf('\"', beg + length));\n\n\tif (tmp)\n\t\tarr[0] = tmp;\n\telse\n\t\tarr[0] = 'undefined_' + (Math.floor(Math.random() * 100000)).toString();\n\n\tfind = ' filename=\"';\n\tlength = find.length;\n\tbeg = header.indexOf(find);\n\ttmp = '';\n\n\tif (beg !== -1)\n\t\ttmp = header.substring(beg + length, header.indexOf('\"', beg + length));\n\n\tif (tmp)\n\t\tarr[1] = tmp;\n\telse\n\t\tarr[1] = null;\n\n\treturn arr;\n}\n\nexports.routeSplit = function(url, noLower) {\n\n\tvar arr;\n\n\tif (!noLower) {\n\t\tarr = F.temporary.other[url];\n\t\tif (arr)\n\t\t\treturn arr;\n\t}\n\n\tif (!url || url === '/') {\n\t\tarr = ['/'];\n\t\treturn arr;\n\t}\n\n\tvar prev = false;\n\tvar key = '';\n\tvar count = 0;\n\n\tarr = [];\n\n\tfor (var i = 0, length = url.length; i < length; i++) {\n\t\tvar c = url[i];\n\n\t\tif (c === '/') {\n\t\t\tif (key && !prev) {\n\t\t\t\tarr.push(key);\n\t\t\t\tcount++;\n\t\t\t\tkey = '';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey += noLower ? c : c.toLowerCase();\n\t\tprev = c === '/';\n\t}\n\n\tif (key)\n\t\tarr.push(key);\n\telse if (!count)\n\t\tarr.push('/');\n\n\treturn arr;\n};\n\nexports.routeSplitCreate = function(url, noLower) {\n\n\tif (!noLower)\n\t\turl = url.toLowerCase();\n\n\tif (url[0] === '/')\n\t\turl = url.substring(1);\n\n\tif (url[url.length - 1] === '/')\n\t\turl = url.substring(0, url.length - 1);\n\n\tvar count = 0;\n\tvar end = 0;\n\tvar arr = [];\n\n\tfor (var i = 0, length = url.length; i < length; i++) {\n\t\tswitch (url[i]) {\n\t\t\tcase '/':\n\t\t\t\tif (count !== 0)\n\t\t\t\t\tbreak;\n\t\t\t\tarr.push(url.substring(end + (arr.length ? 1 : 0), i));\n\t\t\t\tend = i;\n\t\t\t\tbreak;\n\n\t\t\tcase '{':\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\n\t\t\tcase '}':\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t!count && arr.push(url.substring(end + (arr.length ? 1 : 0), url.length));\n\n\tif (arr.length === 1 && !arr[0])\n\t\tarr[0] = '/';\n\n\treturn arr;\n};\n\nexports.routeCompare = function(url, route, isSystem, isWildcard) {\n\n\tvar length = url.length;\n\tvar lengthRoute = route.length;\n\n\tif ((lengthRoute !== length && !isWildcard) || (isWildcard && length < lengthRoute))\n\t\treturn false;\n\n\tif (isWildcard && lengthRoute === 1 && route[0] === '/')\n\t\treturn true;\n\n\tvar skip = length === 1 && url[0] === '/';\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar value = route[i];\n\n\t\tif (!isSystem && isWildcard && value === undefined)\n\t\t\treturn true;\n\n\t\tif (!isSystem && (!skip && value[0] === '{'))\n\t\t\tcontinue;\n\n\t\tif (url[i] !== value)\n\t\t\treturn isSystem ? false : isWildcard ? i >= lengthRoute : false;\n\t}\n\n\treturn true;\n};\n\nexports.routeCompareSubdomain = function(subdomain, arr) {\n\tif ((!subdomain && !arr) || (subdomain && !arr))\n\t\treturn true;\n\tif (!subdomain && arr)\n\t\treturn false;\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tif (arr[i] === '*')\n\t\t\treturn true;\n\t\tvar index = arr[i].lastIndexOf('*');\n\t\tif (index === -1) {\n\t\t\tif (arr[i] === subdomain)\n\t\t\t\treturn true;\n\t\t} else if (subdomain.indexOf(arr[i].replace('*', '')) !== -1)\n\t\t\treturn true;\n\t}\n\treturn false;\n};\n\nexports.routeCompareFlags = function(arr1, arr2, membertype) {\n\n\tvar hasVerb = false;\n\tvar a1 = arr1;\n\tvar a2 = arr2;\n\tvar l1 = arr1.length;\n\tvar l2 = arr2.length;\n\tvar select = l1 > l2 ? a1 : a2;\n\tvar compare = l1 > l2 ? a2 : a1;\n\tvar length = Math.max(l1, l2);\n\n\tvar AUTHORIZE = 'authorize';\n\tvar UNAUTHORIZE = 'unauthorize';\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar value = select[i];\n\t\tvar c = value[0];\n\n\t\tif (c === '!' || c === '#' || c === '$' || c === '@' || c === '+') // ignore roles\n\t\t\tcontinue;\n\n\t\tif (!membertype && (value === AUTHORIZE || value === UNAUTHORIZE))\n\t\t\tcontinue;\n\n\t\tvar index = compare.indexOf(value);\n\t\tif (index === -1 && !HTTPVERBS[value])\n\t\t\treturn value === AUTHORIZE || value === UNAUTHORIZE ? -1 : 0;\n\n\t\thasVerb = hasVerb || (index !== -1 && HTTPVERBS[value]);\n\t}\n\n\treturn hasVerb ? 1 : 0;\n};\n\nexports.routeCompareFlags2 = function(req, route, membertype) {\n\n\t// membertype 0 -> not specified\n\t// membertype 1 -> auth\n\t// membertype 2 -> unauth\n\n\t// 1. upload --> 0\n\t// 2. doAuth --> 1 or 2\n\n\t// if (membertype && ((membertype !== 1 && route.MEMBER === 1) || (membertype !== 2 && route.MEMBER === 2)))\n\tif (membertype && route.MEMBER && membertype !== route.MEMBER)\n\t\treturn -1;\n\n\tif (!route.isWEBSOCKET) {\n\t\tif ((route.isXHR && !req.xhr) || (route.isMOBILE && !req.mobile) || (route.isROBOT && !req.robot) || (route.isUPLOAD && !req.$upload))\n\t\t\treturn 0;\n\t\tvar method = req.method;\n\t\tif (route.method) {\n\t\t\tif (route.method !== method)\n\t\t\t\treturn 0;\n\t\t} else if (!route.flags2[method.toLowerCase()])\n\t\t\treturn 0;\n\t\tif ((route.isREFERER && req.flags.indexOf('referer') === -1) || (!route.isMULTIPLE && route.isJSON && req.flags.indexOf('json') === -1))\n\t\t\treturn 0;\n\t\tif (route.isROLE && !req.$roles && membertype)\n\t\t\treturn -1;\n\t}\n\n\tvar isRole = false;\n\tvar hasRoles = false;\n\n\tfor (var i = 0, length = req.flags.length; i < length; i++) {\n\n\t\tvar flag = req.flags[i];\n\t\tswitch (flag) {\n\t\t\tcase 'json':\n\t\t\t\tcontinue;\n\t\t\tcase 'xml':\n\t\t\t\tif (route.isRAW || route.isXML)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn 0;\n\n\t\t\tcase 'debug':\n\t\t\t\tif (!route.isDEBUG && route.isRELEASE)\n\t\t\t\t\treturn 0;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'release':\n\t\t\t\tif (!route.isRELEASE && route.isDEBUG)\n\t\t\t\t\treturn 0;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'referer':\n\t\t\t\tcontinue;\n\n\t\t\tcase 'upload':\n\t\t\t\tif (!route.isUPLOAD)\n\t\t\t\t\treturn 0;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'https':\n\t\t\t\tif (!route.isHTTPS && route.isHTTP)\n\t\t\t\t\treturn 0;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'http':\n\t\t\t\tif (!route.isHTTP && route.isHTTPS)\n\t\t\t\t\treturn 0;\n\t\t\t\tcontinue;\n\n\t\t\tcase 'xhr':\n\t\t\tcase '+xhr':\n\t\t\t\tif (!route.isBOTH && !route.isXHR)\n\t\t\t\t\treturn 0;\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tvar role = flag[0] === '@';\n\n\t\tif (membertype !== 1 && route.MEMBER !== 1) {\n\t\t\tif ((!route.isGET && !role && !route.flags2[flag]) || (route.isROLE && role && !route.flags2[flag]) || (route.isROLE && !role))\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Is some role verified?\n\t\tif (role && isRole && !route.isROLE)\n\t\t\tcontinue;\n\n\t\tif (!role && !route.flags2[flag])\n\t\t\treturn 0;\n\n\t\tif (role) {\n\t\t\tif (route.flags2[flag])\n\t\t\t\tisRole = true;\n\t\t\thasRoles = true;\n\t\t}\n\t}\n\n\treturn (route.isROLE && hasRoles) ? isRole ? 1 : -1 : 1;\n};\n\n/**\n * Create arguments for controller's action\n * @param {String Array} routeUrl\n * @param {Object} route\n * @return {String Array}\n */\nexports.routeParam = function(routeUrl, route) {\n\n\tif (!route || !routeUrl || !route.param.length)\n\t\treturn EMPTYARRAY;\n\n\tvar arr = [];\n\n\tfor (var i = 0, length = route.param.length; i < length; i++) {\n\t\tvar value = routeUrl[route.param[i]];\n\t\tarr.push(value === '/' ? '' : value);\n\t}\n\n\treturn arr;\n};\n\nfunction HttpFile() {\n\tthis.name;\n\tthis.filename;\n\tthis.type;\n\tthis.path;\n\tthis.length = 0;\n\tthis.width = 0;\n\tthis.height = 0;\n\tthis.rem = true;\n}\n\nHttpFile.prototype = {\n\tget size() {\n\t\treturn this.length;\n\t},\n\tget extension() {\n\t\tif (!this.$extension)\n\t\t\tthis.$extension = framework_utils.getExtension(this.filename);\n\t\treturn this.$extension;\n\t},\n\tset extension(val) {\n\t\tthis.$extension = val;\n\t}\n};\n\nvar HFP = HttpFile.prototype;\n\nHFP.rename = HFP.move = function(filename, callback) {\n\tvar self = this;\n\tFs.rename(self.path, filename, function(err) {\n\n\t\tif (!err) {\n\t\t\tself.path = filename;\n\t\t\tself.rem = false;\n\t\t}\n\n\t\tcallback && callback(err);\n\t});\n\treturn self;\n};\n\nHFP.copy = function(filename, callback) {\n\n\tvar self = this;\n\n\tif (!callback) {\n\t\tFs.createReadStream(self.path).pipe(Fs.createWriteStream(filename));\n\t\treturn;\n\t}\n\n\tvar reader = Fs.createReadStream(self.path);\n\tvar writer = Fs.createWriteStream(filename);\n\n\treader.on('close', callback);\n\treader.pipe(writer);\n\treturn self;\n};\n\nHFP.$$rename = HFP.$$move = function(filename) {\n\tvar self = this;\n\treturn function(callback) {\n\t\treturn self.rename(filename, callback);\n\t};\n};\n\nHFP.$$copy = function(filename) {\n\tvar self = this;\n\treturn function(callback) {\n\t\treturn self.copy(filename, callback);\n\t};\n};\n\nHFP.readSync = function() {\n\treturn Fs.readFileSync(this.path);\n};\n\nHFP.read = function(callback) {\n\tvar self = this;\n\tF.stats.performance.open++;\n\tFs.readFile(self.path, callback);\n\treturn self;\n};\n\nHFP.$$read = function() {\n\tvar self = this;\n\treturn function(callback) {\n\t\tself.read(callback);\n\t};\n};\n\nHFP.md5 = function(callback) {\n\tvar self = this;\n\tvar md5 = Crypto.createHash('md5');\n\tvar stream = Fs.createReadStream(self.path);\n\n\tstream.on('data', (buffer) => md5.update(buffer));\n\tstream.on('error', function(error) {\n\t\tif (callback) {\n\t\t\tcallback(error, null);\n\t\t\tcallback = null;\n\t\t}\n\t});\n\n\tonFinished(stream, function() {\n\t\tdestroyStream(stream);\n\t\tif (callback) {\n\t\t\tcallback(null, md5.digest('hex'));\n\t\t\tcallback = null;\n\t\t}\n\t});\n\n\treturn self;\n};\n\nHFP.$$md5 = function() {\n\tvar self = this;\n\treturn function(callback) {\n\t\tself.md5(callback);\n\t};\n};\n\nHFP.stream = function(options) {\n\treturn Fs.createReadStream(this.path, options);\n};\n\nHFP.pipe = function(stream, options) {\n\treturn Fs.createReadStream(this.path, options).pipe(stream, options);\n};\n\nHFP.isImage = function() {\n\treturn this.type.indexOf('image/') !== -1;\n};\n\nHFP.isVideo = function() {\n\treturn this.type.indexOf('video/') !== -1;\n};\n\nHFP.isAudio = function() {\n\treturn this.type.indexOf('audio/') !== -1;\n};\n\nHFP.image = function(im) {\n\tif (im === undefined)\n\t\tim = CONF.default_image_converter === 'im';\n\treturn framework_image.init(this.path, im, this.width, this.height);\n};\n\nHFP.fs = function(storagename, custom, callback, id) {\n\tif (typeof(custom) === 'function') {\n\t\tid = callback;\n\t\tcallback = custom;\n\t\tcustom = null;\n\t}\n\tvar storage = FILESTORAGE(storagename);\n\tvar stream = Fs.createReadStream(this.path);\n\treturn id ? storage.update(id, this.filename, stream, custom, callback) : storage.insert(this.filename, stream, custom, callback);\n};\n\nHFP.nosql = function(name, custom, callback, id) {\n\tif (typeof(custom) === 'function') {\n\t\tid = callback;\n\t\tcallback = custom;\n\t\tcustom = null;\n\t}\n\tvar storage = NOSQL(name).binary;\n\tvar stream = Fs.createReadStream(this.path);\n\treturn id ? storage.update(id, this.filename, stream, custom, callback) : storage.insert(this.filename, stream, custom, callback);\n};\n\n// *********************************************************************************\n// =================================================================================\n// JS CSS + AUTO-VENDOR-PREFIXES\n// =================================================================================\n// *********************************************************************************\n\nfunction compile_autovendor(css) {\n\tvar avp = '/*auto*/';\n\tvar isAuto = css.substring(0, 100).indexOf(avp) !== -1;\n\tif (isAuto)\n\t\tcss = autoprefixer(css.replace(avp, ''));\n\treturn css.replace(REG_CSS_0, ' ').replace(REG_CSS_1, '').replace(REG_CSS_2, '{').replace(REG_CSS_3, '}').replace(REG_CSS_4, ':').replace(REG_CSS_5, ';').replace(REG_CSS_6, function(search, index, text) {\n\t\tfor (var i = index; i > 0; i--) {\n\t\t\tif ((text[i] === '\\'' || text[i] === '\"') && (text[i - 1] === ':'))\n\t\t\t\treturn search;\n\t\t}\n\t\treturn ',';\n\t}).replace(REG_CSS_7, '}').replace(REG_CSS_8, '{').replace(REG_CSS_9, '}').replace(REG_CSS_12, cssmarginpadding).replace(REG_CSS_13, csscolors).trim();\n}\n\nfunction csscolors(text) {\n\treturn text.substring(0, 4);\n}\n\nfunction cssmarginpadding(text) {\n\n\t// margin\n\t// padding\n\n\tvar prop = '';\n\tvar val;\n\tvar l = text.length - 1;\n\tvar last = text[l];\n\n\tif (text[0] === 'm') {\n\t\tprop = 'margin:';\n\t\tval = text.substring(7, l);\n\t} else {\n\t\tprop = 'padding:';\n\t\tval = text.substring(8, l);\n\t}\n\n\tvar a = val.split(' ');\n\n\tfor (var i = 0; i < a.length; i++) {\n\t\tif (a[i][0] === '0' && a[i].charCodeAt(1) > 58)\n\t\t\ta[i] = '0';\n\t}\n\n\t// 0 0 0 0 --> 0\n\tif (a[0] === '0' && a[1] === '0' && a[2] === '0' && a[3] === '0')\n\t\treturn prop + '0' + last;\n\n\t// 20px 0 0 0 --> 20px 0 0\n\tif (a[0] !== '0' && a[1] === '0' && a[2] === '0' && a[3] === '0')\n\t\treturn prop + a[0] + ' 0 0' + last;\n\n\t// 20px 30px 20px 30px --> 20px 30px\n\tif (a[1] && a[2] && a[3] && a[0] === a[2] && a[1] === a[3])\n\t\treturn prop + a[0] + ' ' + a[1] + last;\n\n\t// 20px 30px 10px 30px --> 20px 30px 10px\n\tif (a[2] && a[3] && a[1] === a[3] && a[0] !== a[2])\n\t\treturn prop + a[0] + ' ' + a[1] + ' ' + a[2] + last;\n\n\treturn text;\n}\n\nfunction autoprefixer(value) {\n\n\tvalue = autoprefixer_keyframes(value);\n\n\tvar builder = [];\n\tvar index = 0;\n\tvar property;\n\n\t// properties\n\tfor (var i = 0, length = AUTOVENDOR.length; i < length; i++) {\n\n\t\tproperty = AUTOVENDOR[i];\n\t\tindex = 0;\n\n\t\twhile (index !== -1) {\n\n\t\t\tindex = value.indexOf(property, index + 1);\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\n\t\t\tvar a = value.indexOf(';', index);\n\t\t\tvar b = value.indexOf('}', index);\n\n\t\t\tvar end = Math.min(a, b);\n\t\t\tif (end === -1)\n\t\t\t\tend = Math.max(a, b);\n\n\t\t\tif (end === -1)\n\t\t\t\tcontinue;\n\n\t\t\t// text-transform\n\t\t\tvar before = value.substring(index - 1, index);\n\t\t\tvar isPrefix = before === '-';\n\t\t\tif (isPrefix)\n\t\t\t\tcontinue;\n\n\t\t\tvar css = value.substring(index, end);\n\t\t\tend = css.indexOf(':');\n\n\t\t\tif (end === -1 || css.substring(0, end + 1).replace(/\\s/g, '') !== property + ':')\n\t\t\t\tcontinue;\n\n\t\t\tbuilder.push({ name: property, property: before + css, css: css });\n\t\t}\n\t}\n\n\tvar output = [];\n\tvar length = builder.length;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar name = builder[i].name;\n\t\tvar replace = builder[i].property;\n\t\tvar before = replace[0];\n\n\t\tproperty = builder[i].css.trim();\n\n\t\tvar plus = property;\n\t\tvar delimiter = ';';\n\t\tvar updated = plus + delimiter;\n\n\t\tif (name === 'opacity') {\n\t\t\tvar opacity = plus.replace('opacity', '').replace(':', '').replace(/\\s/g, '');\n\t\t\tindex = opacity.indexOf('!');\n\t\t\topacity = index === -1 ? (+opacity) : (+opacity.substring(0, index));\n\t\t\tif (!isNaN(opacity)) {\n\t\t\t\tupdated += 'filter:alpha(opacity=' + Math.floor(opacity * 100) + ')' + (index !== -1 ? ' !important' : '');\n\t\t\t\tvalue = value.replacer(replace, before + '@[[' + output.length + ']]');\n\t\t\t\toutput.push(updated);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (name === 'font-smoothing') {\n\t\t\tupdated = plus + delimiter;\n\t\t\tupdated += plus.replacer('font-smoothing', '-webkit-font-smoothing') + delimiter;\n\t\t\tupdated += plus.replacer('font-smoothing', '-moz-osx-font-smoothing');\n\t\t\tvalue = value.replacer(replace, before + '@[[' + output.length + ']]');\n\t\t\toutput.push(updated);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (name === 'background' || name === 'background-image') {\n\t\t\tif (property.indexOf('repeating-linear-gradient') !== -1) {\n\t\t\t\tupdated = plus.replacer('repeating-linear-', '-webkit-repeating-linear-') + delimiter;\n\t\t\t\tupdated += plus.replacer('repeating-linear-', '-moz-repeating-linear-') + delimiter;\n\t\t\t\tupdated += plus.replacer('repeating-linear-', '-ms-repeating-linear-') + delimiter;\n\t\t\t\tupdated += plus;\n\t\t\t\tvalue = value.replacer(replace, before + '@[[' + output.length + ']]');\n\t\t\t\toutput.push(updated);\n\t\t\t} else if (property.indexOf('repeating-radial-gradient') !== -1) {\n\t\t\t\tupdated = plus.replacer('repeating-radial-', '-webkit-repeating-radial-') + delimiter;\n\t\t\t\tupdated += plus.replacer('repeating-radial-', '-moz-repeating-radial-') + delimiter;\n\t\t\t\tupdated += plus.replacer('repeating-radial-', '-ms-repeating-radial-') + delimiter;\n\t\t\t\tupdated += plus;\n\t\t\t\tvalue = value.replacer(replace, before + '@[[' + output.length + ']]');\n\t\t\t\toutput.push(updated);\n\t\t\t} else if (property.indexOf('linear-gradient') !== -1) {\n\t\t\t\tupdated = plus.replacer('linear-', '-webkit-linear-') + delimiter;\n\t\t\t\tupdated += plus.replacer('linear-', '-moz-linear-') + delimiter;\n\t\t\t\tupdated += plus.replacer('linear-', '-ms-linear-') + delimiter;\n\t\t\t\tupdated += plus;\n\t\t\t\tvalue = value.replacer(replace, before + '@[[' + output.length + ']]');\n\t\t\t\toutput.push(updated);\n\t\t\t} else if (property.indexOf('radial-gradient') !== -1) {\n\t\t\t\tupdated = plus.replacer('radial-', '-webkit-radial-') + delimiter;\n\t\t\t\tupdated += plus.replacer('radial-', '-moz-radial-') + delimiter;\n\t\t\t\tupdated += plus.replacer('radial-', '-ms-radial-') + delimiter;\n\t\t\t\tupdated += plus;\n\t\t\t\tvalue = value.replacer(replace, before + '@[[' + output.length + ']]');\n\t\t\t\toutput.push(updated);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (name === 'text-overflow') {\n\t\t\tupdated = plus + delimiter;\n\t\t\tupdated += plus.replacer('text-overflow', '-ms-text-overflow');\n\t\t\tvalue = value.replacer(replace, before + '@[[' + output.length + ']]');\n\t\t\toutput.push(updated);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (name === 'display') {\n\t\t\tif (property.indexOf('box') !== -1) {\n\t\t\t\tupdated = plus + delimiter;\n\t\t\t\tupdated += plus.replacer('box', '-webkit-box') + delimiter;\n\t\t\t\tupdated += plus.replacer('box', '-moz-box');\n\t\t\t\tvalue = value.replacer(replace, before + '@[[' + output.length + ']]');\n\t\t\t\toutput.push(updated);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tupdated += '-webkit-' + plus + delimiter;\n\t\tupdated += '-moz-' + plus;\n\n\t\tif (name.indexOf('animation') === -1)\n\t\t\tupdated += delimiter + '-ms-' + plus;\n\n\t\tvalue = value.replacer(replace, before + '@[[' + output.length + ']]');\n\t\toutput.push(updated);\n\t}\n\n\tlength = output.length;\n\tfor (var i = 0; i < length; i++)\n\t\tvalue = value.replacer('@[[' + i + ']]', output[i]);\n\n\toutput = null;\n\tbuilder = null;\n\treturn value;\n}\n\nfunction autoprefixer_keyframes(value) {\n\n\tvar builder = [];\n\tvar index = 0;\n\n\twhile (index !== -1) {\n\n\t\tindex = value.indexOf('@keyframes', index + 1);\n\t\tif (index === -1)\n\t\t\tcontinue;\n\n\t\tvar counter = 0;\n\t\tvar end = -1;\n\n\t\tfor (var indexer = index + 10; indexer < value.length; indexer++) {\n\n\t\t\tif (value[indexer] === '{')\n\t\t\t\tcounter++;\n\n\t\t\tif (value[indexer] !== '}')\n\t\t\t\tcontinue;\n\n\t\t\tif (counter > 1) {\n\t\t\t\tcounter--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tend = indexer;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (end === -1)\n\t\t\tcontinue;\n\n\t\tvar css = value.substring(index, end + 1);\n\t\tbuilder.push({ name: 'keyframes', property: css });\n\t}\n\n\tvar output = [];\n\tvar length = builder.length;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar name = builder[i].name;\n\t\tvar property = builder[i].property;\n\n\t\tif (name !== 'keyframes')\n\t\t\tcontinue;\n\n\t\tvar plus = property.substring(1);\n\t\tvar delimiter = '\\n';\n\n\t\tvar updated = '@' + plus + delimiter;\n\n\t\tupdated += '@-webkit-' + plus + delimiter;\n\t\tupdated += '@-moz-' + plus + delimiter;\n\t\tupdated += '@-o-' + plus + delimiter;\n\n\t\tvalue = value.replacer(property, '@[[' + output.length + ']]');\n\t\toutput.push(updated);\n\t}\n\n\tlength = output.length;\n\n\tfor (var i = 0; i < length; i++)\n\t\tvalue = value.replace('@[[' + i + ']]', output[i]);\n\n\treturn value;\n}\n\nfunction minify_javascript(data) {\n\n\tvar index = 0;\n\tvar output = [];\n\tvar isCS = false;\n\tvar isCI = false;\n\tvar alpha = /[0-9a-z$]/i;\n\tvar white = /\\W/;\n\tvar skip = { '$': true, '_': true };\n\tvar newlines = { '\\n': 1, '\\r': 1 };\n\tvar regexp = false;\n\tvar scope, prev, next, last;\n\tvar vtmp = false;\n\tvar regvar = /^(\\s)*var /;\n\tvar vindex = 0;\n\n\twhile (true) {\n\n\t\tvar c = data[index];\n\t\tvar prev = data[index - 1];\n\t\tvar next = data[index + 1];\n\n\t\tindex++;\n\n\t\tif (c === undefined)\n\t\t\tbreak;\n\n\t\tif (!scope) {\n\n\t\t\tif (!regexp) {\n\t\t\t\tif (c === '/' && next === '*') {\n\t\t\t\t\tisCS = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (c === '*' && next === '/') {\n\t\t\t\t\tisCS = false;\n\t\t\t\t\tindex++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (isCS)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (c === '/' && next === '/') {\n\t\t\t\t\tisCI = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (isCI && newlines[c]) {\n\t\t\t\t\tisCI = false;\n\t\t\t\t\talpha.test(last) && output.push(' ');\n\t\t\t\t\tlast = '';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (isCI)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c === '\\t' || newlines[c]) {\n\t\t\t\tif (!last || !alpha.test(last))\n\t\t\t\t\tcontinue;\n\t\t\t\toutput.push(' ');\n\t\t\t\tlast = '';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!regexp && (c === ' ' && (white.test(prev) || white.test(next)))) {\n\t\t\t\t// if (!skip[prev] && !skip[next])\n\t\t\t\tif (!skip[prev]) {\n\t\t\t\t\tif (!skip[next] || !alpha.test(prev))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (regexp) {\n\t\t\t\tif ((last !== '\\\\' && c === '/') || (last === '\\\\' && c === '/' && output[output.length - 2] === '\\\\'))\n\t\t\t\t\tregexp = false;\n\t\t\t} else\n\t\t\t\tregexp = (last === '=' || last === '(' || last === ':' || last === '{' || last === '[' || last === '?') && (c === '/');\n\t\t}\n\n\t\tif (scope && c === '\\\\') {\n\t\t\toutput.push(c);\n\t\t\toutput.push(next);\n\t\t\tindex++;\n\t\t\tlast = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!regexp && (c === '\"' || c === '\\'' || c === '`')) {\n\n\t\t\tif (scope && scope !== c) {\n\t\t\t\toutput.push(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c === scope)\n\t\t\t\tscope = 0;\n\t\t\telse\n\t\t\t\tscope = c;\n\t\t}\n\n\t\t// var\n\t\tif (!scope && c === 'v' && next === 'a') {\n\t\t\tvar v = c + data[index] + data[index + 1] + data[index + 2];\n\t\t\tif (v === 'var ') {\n\t\t\t\tif (vtmp && output[output.length - 1] === ';') {\n\t\t\t\t\toutput.pop();\n\t\t\t\t\toutput.push(',');\n\t\t\t\t} else\n\t\t\t\t\toutput.push('var ');\n\t\t\t\tindex += 3;\n\t\t\t\tvtmp = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (vtmp) {\n\t\t\t\tvindex = index + 1;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!data[vindex] || !white.test(data[vindex]))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tvindex++;\n\t\t\t\t}\n\t\t\t\tif (c === '(' || c === ')' || (c === ';' && !regvar.test(data.substring(vindex, vindex + 20))))\n\t\t\t\t\tvtmp = false;\n\t\t\t}\n\t\t}\n\n\t\tif ((c === '+' || c === '-') && next === ' ') {\n\t\t\tif (data[index + 1] === c) {\n\t\t\t\tindex += 2;\n\t\t\t\toutput.push(c);\n\t\t\t\toutput.push(' ');\n\t\t\t\toutput.push(c);\n\t\t\t\tlast = c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((c === '}' && last === ';') || ((c === '}' || c === ']') && output[output.length - 1] === ' ' && alpha.test(output[output.length - 2])))\n\t\t\toutput.pop();\n\n\t\toutput.push(c);\n\t\tlast = c;\n\t}\n\n\treturn output.join('').trim();\n}\n\nexports.compile_css = function(value, filename, nomarkup) {\n\n\t// Internal markup\n\tif (!nomarkup)\n\t\tvalue = markup(value, filename);\n\n\tif (global.F) {\n\t\tvalue = modificators(value, filename, 'style');\n\t\tif (F.onCompileStyle)\n\t\t\treturn F.onCompileStyle(filename, value);\n\t}\n\n\ttry {\n\n\t\tvar isVariable = false;\n\n\t\tvalue = nested(value, '', () => isVariable = true);\n\t\tvalue = compile_autovendor(value);\n\n\t\tif (isVariable)\n\t\t\tvalue = variablesCSS(value);\n\n\t\treturn value;\n\t} catch (ex) {\n\t\tF.error(new Error('CSS compiler error: ' + ex.message));\n\t\treturn '';\n\t}\n};\n\nexports.compile_javascript = function(source, filename, nomarkup) {\n\n\t// Internal markup\n\tif (!nomarkup)\n\t\tsource = markup(source, filename);\n\n\tif (global.F) {\n\t\tsource = modificators(source, filename, 'script');\n\t\tif (F.onCompileScript)\n\t\t\treturn F.onCompileScript(filename, source).trim();\n\t}\n\n\treturn minify_javascript(source);\n};\n\nexports.compile_html = function(source, filename, nomarkup) {\n\treturn compressCSS(compressJS(compressHTML(source, true), 0, filename, nomarkup), 0, filename, nomarkup);\n};\n\n// *********************************************************************************\n// =================================================================================\n// MULTIPART PARSER\n// =================================================================================\n// *********************************************************************************\n\n// Copyright (c) 2010 Hongli Lai\n// Copyright (c) Felix GeisendÃ¶rfer -> https://github.com/felixge/node-formidable\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer,\n\ts = 0,\n\tS = {\n\t\tPARSER_UNINITIALIZED: s++,\n\t\tSTART: s++,\n\t\tSTART_BOUNDARY: s++,\n\t\tHEADER_FIELD_START: s++,\n\t\tHEADER_FIELD: s++,\n\t\tHEADER_VALUE_START: s++,\n\t\tHEADER_VALUE: s++,\n\t\tHEADER_VALUE_ALMOST_DONE: s++,\n\t\tHEADERS_ALMOST_DONE: s++,\n\t\tPART_DATA_START: s++,\n\t\tPART_DATA: s++,\n\t\tPART_END: s++,\n\t\tEND: s++\n\t},\n\n\tf = 1,\n\tFB = {\n\t\tPART_BOUNDARY: f,\n\t\tLAST_BOUNDARY: f *= 2\n\t},\n\n\tLF = 10,\n\tCR = 13,\n\tSPACE = 32,\n\tHYPHEN = 45,\n\tCOLON = 58,\n\tA = 97,\n\tZ = 122,\n\n\tlower = function(c) {\n\t\treturn c | 0x20;\n\t};\n\nfor (s in S) {\n\texports[s] = S[s];\n}\n\nfunction MultipartParser() {\n\tthis.boundary = null;\n\tthis.boundaryChars = null;\n\tthis.lookbehind = null;\n\tthis.state = S.PARSER_UNINITIALIZED;\n\tthis.index = null;\n\tthis.flags = 0;\n}\n\nexports.MultipartParser = MultipartParser;\nconst MultipartParserProto = MultipartParser.prototype;\n\nMultipartParser.stateToString = function(stateNumber) {\n\tfor (var state in S) {\n\t\tvar number = S[state];\n\t\tif (number === stateNumber) return state;\n\t}\n};\n\nMultipartParserProto.initWithBoundary = function(str) {\n\tvar self = this;\n\tself.boundary = Buffer.alloc(str.length + 4);\n\tself.boundary.write('\\r\\n--', 0, 'ascii');\n\tself.boundary.write(str, 4, 'ascii');\n\tself.lookbehind = Buffer.alloc(self.boundary.length + 8);\n\tself.state = S.START;\n\tself.boundaryChars = {};\n\tfor (var i = 0; i < self.boundary.length; i++)\n\t\tself.boundaryChars[self.boundary[i]] = true;\n};\n\nMultipartParserProto.write = function(buffer) {\n\tvar self = this,\n\t\ti = 0,\n\t\tlen = buffer.length,\n\t\tprevIndex = self.index,\n\t\tindex = self.index,\n\t\tstate = self.state,\n\t\tflags = self.flags,\n\t\tlookbehind = self.lookbehind,\n\t\tboundary = self.boundary,\n\t\tboundaryChars = self.boundaryChars,\n\t\tboundaryLength = self.boundary.length,\n\t\tboundaryEnd = boundaryLength - 1,\n\t\tbufferLength = buffer.length,\n\t\tc,\n\t\tcl,\n\t\tmark = function(name) {\n\t\t\tself[name + 'Mark'] = i;\n\t\t},\n\t\tclear = function(name) {\n\t\t\tdelete self[name + 'Mark'];\n\t\t},\n\t\tcallback = function(name, buffer, start, end) {\n\t\t\tif (start !== undefined && start === end)\n\t\t\t\treturn;\n\t\t\tvar callbackSymbol = 'on' + name.substr(0, 1).toUpperCase() + name.substr(1);\n\t\t\tif (callbackSymbol in self)\n\t\t\t\tself[callbackSymbol](buffer, start, end);\n\t\t},\n\t\tdataCallback = function(name, clear) {\n\t\t\tvar markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in self))\n\t\t\t\treturn;\n\t\t\tif (!clear) {\n\t\t\t\tcallback(name, buffer, self[markSymbol], buffer.length);\n\t\t\t\tself[markSymbol] = 0;\n\t\t\t} else {\n\t\t\t\tcallback(name, buffer, self[markSymbol], i);\n\t\t\t\tdelete self[markSymbol];\n\t\t\t}\n\t\t};\n\n\tfor (i = 0; i < len; i++) {\n\t\tc = buffer[i];\n\t\tswitch (state) {\n\n\t\t\tcase S.PARSER_UNINITIALIZED:\n\t\t\t\treturn i;\n\n\t\t\tcase S.START:\n\t\t\t\tindex = 0;\n\t\t\t\tstate = S.START_BOUNDARY;\n\n\t\t\tcase S.START_BOUNDARY:\n\t\t\t\tif (index == boundary.length - 2) {\n\t\t\t\t\tif (c === HYPHEN)\n\t\t\t\t\t\tflags |= FB.LAST_BOUNDARY;\n\t\t\t\t\telse if (c !== CR)\n\t\t\t\t\t\treturn i;\n\t\t\t\t\tindex++;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\tif (flags & FB.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\tcallback('end');\n\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t} else if (!(flags & FB.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\tcallback('partBegin');\n\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t} else\n\t\t\t\t\t\treturn i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (c !== boundary[index + 2])\n\t\t\t\t\tindex = -2;\n\t\t\t\tif (c === boundary[index + 2])\n\t\t\t\t\tindex++;\n\t\t\t\tbreak;\n\n\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\tmark('headerField');\n\t\t\t\tindex = 0;\n\n\t\t\tcase S.HEADER_FIELD:\n\t\t\t\tif (c === CR) {\n\t\t\t\t\tclear('headerField');\n\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\t\t\t\tif (c === HYPHEN)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (c === COLON) {\n\t\t\t\t\t// empty header field\n\t\t\t\t\tif (index === 1)\n\t\t\t\t\t\treturn i;\n\t\t\t\t\tdataCallback('headerField', true);\n\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcl = lower(c);\n\t\t\t\tif (cl < A || cl > Z)\n\t\t\t\t\treturn i;\n\n\t\t\t\tbreak;\n\n\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\tif (c === SPACE)\n\t\t\t\t\tbreak;\n\t\t\t\tmark('headerValue');\n\t\t\t\tstate = S.HEADER_VALUE;\n\n\t\t\tcase S.HEADER_VALUE:\n\t\t\t\tif (c === CR) {\n\t\t\t\t\tdataCallback('headerValue', true);\n\t\t\t\t\tcallback('headerEnd');\n\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\tif (c !== LF)\n\t\t\t\t\treturn i;\n\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\tbreak;\n\n\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\tif (c !== LF)\n\t\t\t\t\treturn i;\n\t\t\t\tcallback('headersEnd');\n\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\tbreak;\n\n\t\t\tcase S.PART_DATA_START:\n\t\t\t\tstate = S.PART_DATA;\n\t\t\t\tmark('partData');\n\n\t\t\tcase S.PART_DATA:\n\t\t\t\tprevIndex = index;\n\t\t\t\tif (!index) {\n\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\twhile (i < bufferLength && !(buffer[i] in boundaryChars))\n\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\tc = buffer[i];\n\t\t\t\t}\n\n\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\tif (!index)\n\t\t\t\t\t\t\tdataCallback('partData', true);\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\tflags |= FB.PART_BOUNDARY;\n\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\tflags |= FB.LAST_BOUNDARY;\n\t\t\t\t\t} else\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\tif (flags & FB.PART_BOUNDARY) {\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\tflags &= ~FB.PART_BOUNDARY;\n\t\t\t\t\t\t\tcallback('partEnd');\n\t\t\t\t\t\t\tcallback('partBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (flags & FB.LAST_BOUNDARY) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tcallback('partEnd');\n\t\t\t\t\t\t\tcallback('end');\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t} else\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\n\t\t\t\tif (index) {\n\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t} else if (prevIndex) {\n\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t// belongs to partData\n\t\t\t\t\tcallback('partData', lookbehind, 0, prevIndex);\n\t\t\t\t\tprevIndex = 0;\n\t\t\t\t\tmark('partData');\n\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase S.END:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\tdataCallback('headerField');\n\tdataCallback('headerValue');\n\tdataCallback('partData');\n\n\tself.index = index;\n\tself.state = state;\n\tself.flags = flags;\n\n\treturn len;\n};\n\nMultipartParserProto.end = function() {\n\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) || (this.state === S.PART_DATA && this.index == this.boundary.length)) {\n\t\tthis.onPartEnd && this.onPartEnd();\n\t\tthis.onEnd && this.onEnd();\n\t} else if (this.state != S.END) {\n\t\tthis.onPartEnd && this.onPartEnd();\n\t\tthis.onEnd && this.onEnd();\n\t\treturn new Error('MultipartParser.end(): stream ended unexpectedly: ' + this.explain());\n\t}\n};\n\nMultipartParserProto.explain = function() {\n\treturn 'state = ' + MultipartParser.stateToString(this.state);\n};\n\n// *********************************************************************************\n// =================================================================================\n// VIEW ENGINE\n// =================================================================================\n// *********************************************************************************\n\nfunction view_parse_localization(content, language) {\n\n\tvar is = false;\n\n\tcontent = content.replace(REG_NOTRANSLATE, function() {\n\t\tis = true;\n\t\treturn '';\n\t}).trim();\n\n\tif (is)\n\t\treturn content;\n\n\tvar command = view_find_localization(content, 0);\n\tvar output = '';\n\tvar end = 0;\n\n\tif (!command)\n\t\treturn content;\n\n\twhile (command) {\n\n\t\tif (command)\n\t\t\toutput += content.substring(end ? end + 1 : 0, command.beg) + (command.command ? localize(language, command) : '');\n\n\t\tend = command.end;\n\t\tcommand = view_find_localization(content, command.end);\n\t}\n\n\toutput += content.substring(end + 1);\n\treturn output;\n}\n\n// Escaping \", ' and ` chars\nfunction localize(language, command) {\n\n\t!language && (language = 'default');\n\n\tif (F.resources[language] && F.resources[language].$empty)\n\t\treturn command.command;\n\n\tvar output = F.translate(language, command.command);\n\n\tif (command.escape) {\n\t\tvar index = 0;\n\t\twhile (true) {\n\t\t\tindex = output.indexOf(command.escape, index);\n\t\t\tif (index === -1)\n\t\t\t\tbreak;\n\t\t\tvar c = output[index - 1];\n\t\t\tif (c !== '\\\\') {\n\t\t\t\toutput = output.substring(0, index) + '\\\\' + output.substring(index);\n\t\t\t\tindex++;\n\t\t\t} else\n\t\t\t\tindex += 2;\n\t\t}\n\t}\n\n\treturn output;\n}\n\nvar VIEW_IF = { 'if ': 1, 'if(': 1 };\n\nfunction view_parse(content, minify, filename, controller) {\n\n\tcontent = removeComments(content).ROOT();\n\n\tvar nocompressHTML = false;\n\tvar nocompressJS = false;\n\tvar nocompressCSS = false;\n\n\tcontent = content.replace(REG_NOCOMPRESS, function(text) {\n\n\t\tvar index = text.lastIndexOf(' ');\n\t\tif (index === -1)\n\t\t\treturn '';\n\n\t\tswitch (text.substring(index, text.length - 1).trim()) {\n\t\t\tcase 'all':\n\t\t\t\tnocompressHTML = true;\n\t\t\t\tnocompressJS = true;\n\t\t\t\tnocompressCSS = true;\n\t\t\t\tbreak;\n\t\t\tcase 'html':\n\t\t\t\tnocompressHTML = true;\n\t\t\t\tbreak;\n\t\t\tcase 'js':\n\t\t\tcase 'script':\n\t\t\tcase 'javascript':\n\t\t\t\tnocompressJS = true;\n\t\t\t\tbreak;\n\t\t\tcase 'css':\n\t\t\tcase 'style':\n\t\t\t\tnocompressCSS = true;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn '';\n\t}).trim();\n\n\tif (!nocompressJS)\n\t\tcontent = compressJS(content, 0, filename, true);\n\n\tif (!nocompressCSS)\n\t\tcontent = compressCSS(content, 0, filename, true);\n\n\tcontent = F.$versionprepare(content);\n\n\tif (!nocompressHTML)\n\t\tcontent = compressView(content, minify, filename);\n\n\tvar DELIMITER = '\\'';\n\tvar SPACE = ' ';\n\tvar builder = 'var $EMPTY=\\'\\';var $length=0;var $source=null;var $tmp=index;var $output=$EMPTY';\n\tvar command = view_find_command(content, 0);\n\tvar isFirst = false;\n\tvar txtindex = -1;\n\tvar index = 0;\n\tvar isCookie = false;\n\n\tfunction escaper(value) {\n\n\t\tvar is = REG_TAGREMOVE.test(value);\n\n\t\tif (!nocompressHTML) {\n\t\t//\tvalue = compressHTML(value, minify, true);\n\t\t} else if (!isFirst) {\n\t\t\tisFirst = true;\n\t\t\tvalue = value.replace(/^\\s+/, '');\n\t\t}\n\n\t\tif (!value)\n\t\t\treturn '$EMPTY';\n\n\t\tif (!nocompressHTML && is)\n\t\t\tvalue += ' ';\n\n\t\ttxtindex = $VIEWCACHE.indexOf(value);\n\n\t\tif (txtindex === -1) {\n\t\t\ttxtindex = $VIEWCACHE.length;\n\t\t\t$VIEWCACHE.push(value);\n\t\t}\n\n\t\treturn '$VIEWCACHE[' + txtindex + ']';\n\t}\n\n\tif (!command)\n\t\tbuilder += '+' + escaper(content);\n\n\tindex = 0;\n\n\tvar old = null;\n\tvar newCommand = '';\n\tvar tmp = '';\n\tvar counter = 0;\n\tvar functions = [];\n\tvar functionsName = [];\n\tvar isFN = false;\n\tvar isSECTION = false;\n\tvar isCOMPILATION = false;\n\tvar builderTMP = '';\n\tvar sectionName = '';\n\tvar components = {};\n\tvar text;\n\n\twhile (command) {\n\n\t\tif (!isCookie && command.command.indexOf('cookie') !== -1)\n\t\t\tisCookie = true;\n\n\t\tif (old) {\n\t\t\ttext = content.substring(old.end + 1, command.beg);\n\t\t\tif (text) {\n\t\t\t\tif (view_parse_plus(builder))\n\t\t\t\t\tbuilder += '+';\n\t\t\t\tbuilder += escaper(text);\n\t\t\t}\n\t\t} else {\n\t\t\ttext = content.substring(0, command.beg);\n\t\t\tif (text) {\n\t\t\t\tif (view_parse_plus(builder))\n\t\t\t\t\tbuilder += '+';\n\t\t\t\tbuilder += escaper(text);\n\t\t\t}\n\t\t}\n\n\t\tvar cmd = content.substring(command.beg + 2, command.end).trim();\n\n\t\tvar cmd8 = cmd.substring(0, 8);\n\t\tvar cmd7 = cmd.substring(0, 7);\n\n\t\tif (cmd === 'continue' || cmd === 'break') {\n\t\t\tbuilder += ';' + cmd + ';';\n\t\t\told = command;\n\t\t\tcommand = view_find_command(content, command.end);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// cmd = cmd.replace\n\t\tcommand.command = command.command.replace(REG_HELPERS, function(text) {\n\t\t\tvar index = text.indexOf('(');\n\t\t\treturn index === - 1 ? text : text.substring(0, index) + '.call(self' + (text.endsWith('()') ? ')' : ',' + text.substring(index + 1));\n\t\t});\n\n\t\tif (cmd[0] === '\\'' || cmd[0] === '\"') {\n\t\t\tif (cmd[1] === '%') {\n\t\t\t\tvar t = CONF[cmd.substring(2, cmd.length - 1)];\n\t\t\t\tif (t != null)\n\t\t\t\t\tbuilder += '+' + DELIMITER + (t.toString()).replace(/'/g, \"\\\\'\") + DELIMITER;\n\t\t\t} else\n\t\t\t\tbuilder += '+' + DELIMITER + (new Function('self', 'return self.$import(' + cmd[0] + '!' + cmd.substring(1) + ')'))(controller) + DELIMITER;\n\t\t} else if (cmd7 === 'compile' && cmd.lastIndexOf(')') === -1) {\n\n\t\t\tbuilderTMP = builder + '+(F.onCompileView.call(self,\\'' + (cmd8[7] === ' ' ? cmd.substring(8).trim() : '') + '\\',';\n\t\t\tbuilder = '';\n\t\t\tsectionName = cmd.substring(8);\n\t\t\tisCOMPILATION = true;\n\t\t\tisFN = true;\n\n\t\t} else if (cmd8 === 'section ' && cmd.lastIndexOf(')') === -1) {\n\n\t\t\tbuilderTMP = builder;\n\t\t\tbuilder = '+(function(){var $output=$EMPTY';\n\t\t\tsectionName = cmd.substring(8);\n\t\t\tisSECTION = true;\n\t\t\tisFN = true;\n\t\t} else if (cmd7 === 'helper ') {\n\n\t\t\tbuilderTMP = builder;\n\t\t\tbuilder = 'function ' + cmd.substring(7).trim() + '{var $output=$EMPTY';\n\t\t\tisFN = true;\n\t\t\tfunctionsName.push(cmd.substring(7, cmd.indexOf('(', 7)).trim());\n\n\t\t} else if (cmd8 === 'foreach ') {\n\n\t\t\tcounter++;\n\n\t\t\tif (cmd.indexOf('foreach var ') !== -1)\n\t\t\t\tcmd = cmd.replace(' var ', SPACE);\n\n\t\t\tcmd = view_prepare_keywords(cmd);\n\t\t\tnewCommand = (cmd.substring(8, cmd.indexOf(SPACE, 8)) || '').trim();\n\t\t\tindex = cmd.trim().indexOf(SPACE, newCommand.length + 10);\n\n\t\t\tif (index === -1)\n\t\t\t\tindex = cmd.indexOf('[', newCommand.length + 10);\n\n\t\t\tbuilder += '+(function(){var $source=' + cmd.substring(index).trim() + ';if(!($source instanceof Array))$source=framework_utils.ObjectToArray($source);if(!$source.length)return $EMPTY;var $length=$source.length;var $output=$EMPTY;var index=0;for(var $i=0;$i<$length;$i++){index=$i;var ' + newCommand + '=$source[$i];$output+=$EMPTY';\n\t\t} else if (cmd === 'end') {\n\n\t\t\tif (isFN && counter <= 0) {\n\t\t\t\tcounter = 0;\n\n\t\t\t\tif (isCOMPILATION) {\n\t\t\t\t\tbuilder = builderTMP + 'unescape($EMPTY' + builder + '),model) || $EMPTY)';\n\t\t\t\t\tbuilderTMP = '';\n\t\t\t\t} else if (isSECTION) {\n\t\t\t\t\tbuilder = builderTMP + builder + ';repository[\\'$section_' + sectionName + '\\']=repository[\\'$section_' + sectionName + '\\']?repository[\\'$section_' + sectionName + '\\']+$output:$output;return $EMPTY})()';\n\t\t\t\t\tbuilderTMP = '';\n\t\t\t\t} else {\n\t\t\t\t\tbuilder += ';return $output;}';\n\t\t\t\t\tfunctions.push(builder);\n\t\t\t\t\tbuilder = builderTMP;\n\t\t\t\t\tbuilderTMP = '';\n\t\t\t\t}\n\n\t\t\t\tisSECTION = false;\n\t\t\t\tisCOMPILATION = false;\n\t\t\t\tisFN = false;\n\n\t\t\t} else {\n\t\t\t\tcounter--;\n\t\t\t\tbuilder += '}return $output})()';\n\t\t\t\tnewCommand = '';\n\t\t\t}\n\n\t\t} else if (VIEW_IF[cmd.substring(0, 3)]) {\n\t\t\tbuilder += ';if (' + (cmd.substring(2, 3) === '(' ? '(' : '') + view_prepare_keywords(cmd).substring(3) + '){$output+=$EMPTY';\n\t\t} else if (cmd7 === 'else if') {\n\t\t\tbuilder += '} else if (' + view_prepare_keywords(cmd).substring(7) + ') {$output+=$EMPTY';\n\t\t} else if (cmd === 'else') {\n\t\t\tbuilder += '} else {$output+=$EMPTY';\n\t\t} else if (cmd === 'endif' || cmd === 'fi') {\n\t\t\tbuilder += '}$output+=$EMPTY';\n\t\t} else {\n\n\t\t\ttmp = view_prepare(command.command, newCommand, functionsName, controller, components);\n\t\t\tvar can = false;\n\n\t\t\t// Inline rendering is supported only in release mode\n\t\t\tif (RELEASE && tmp.indexOf('+') === -1 && REG_SKIP_1.test(tmp) && !REG_SKIP_2.test(tmp)) {\n\t\t\t\tfor (var a = 0, al = RENDERNOW.length; a < al; a++) {\n\t\t\t\t\tif (tmp.startsWith(RENDERNOW[a])) {\n\t\t\t\t\t\tif (!a) {\n\t\t\t\t\t\t\tvar isMeta = tmp.indexOf('\\'meta\\'') !== -1;\n\t\t\t\t\t\t\tvar isHead = tmp.indexOf('\\'head\\'') !== -1;\n\t\t\t\t\t\t\ttmp = tmp.replace(/(\\s)?'(meta|head)'(\\s|,)?/g, '').replace(/(,,|,\\)|\\s{2,})/g, '');\n\t\t\t\t\t\t\tif (isMeta || isHead) {\n\t\t\t\t\t\t\t\tvar tmpimp = '';\n\t\t\t\t\t\t\t\tif (isMeta)\n\t\t\t\t\t\t\t\t\ttmpimp += (isMeta ? '\\'meta\\'' : '');\n\t\t\t\t\t\t\t\tif (isHead)\n\t\t\t\t\t\t\t\t\ttmpimp += (tmpimp ? ',' : '') + (isHead ? '\\'head\\'' : '');\n\t\t\t\t\t\t\t\tif (tmpimp)\n\t\t\t\t\t\t\t\t\tbuilder += '+self.$import(' + tmpimp + ')';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tmp !== 'self.$import()')\n\t\t\t\t\t\t\tcan = true;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (can && !counter) {\n\t\t\t\ttry {\n\n\t\t\t\t\tif (tmp.lastIndexOf(')') === -1)\n\t\t\t\t\t\ttmp += ')';\n\n\t\t\t\t\tvar r = (new Function('self', 'config', 'return ' + tmp))(controller, CONF).replace(REG_7, '\\\\\\\\').replace(REG_8, '\\\\\\'');\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\ttxtindex = $VIEWCACHE.indexOf(r);\n\t\t\t\t\t\tif (txtindex === -1) {\n\t\t\t\t\t\t\ttxtindex = $VIEWCACHE.length;\n\t\t\t\t\t\t\t$VIEWCACHE.push(r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuilder += '+$VIEWCACHE[' + txtindex + ']';\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tconsole.log('A view compilation error --->', filename, e, tmp);\n\t\t\t\t\tF.errors.push({ error: e.stack, name: filename, url: null, date: new Date() });\n\n\t\t\t\t\tif (view_parse_plus(builder))\n\t\t\t\t\t\tbuilder += '+';\n\t\t\t\t\tbuilder += wrapTryCatch(tmp, command.command, command.line);\n\t\t\t\t}\n\t\t\t} else if (tmp) {\n\t\t\t\tif (view_parse_plus(builder))\n\t\t\t\t\tbuilder += '+';\n\t\t\t\tif (tmp.substring(1, 4) !== '@{-' && tmp.substring(0, 11) !== 'self.$view')\n\t\t\t\t\tbuilder += wrapTryCatch(tmp, command.command, command.line);\n\t\t\t\telse\n\t\t\t\t\tbuilder += tmp;\n\t\t\t}\n\t\t}\n\n\t\told = command;\n\t\tcommand = view_find_command(content, command.end);\n\t}\n\n\tif (old) {\n\t\ttext = content.substring(old.end + 1);\n\t\tif (text)\n\t\t\tbuilder += '+' + escaper(text);\n\t}\n\n\tif (RELEASE)\n\t\tbuilder = builder.replace(/(\\+\\$EMPTY\\+)/g, '+').replace(/(\\$output=\\$EMPTY\\+)/g, '$output=').replace(/(\\$output\\+=\\$EMPTY\\+)/g, '$output+=').replace(/(\\}\\$output\\+=\\$EMPTY)/g, '}').replace(/(\\{\\$output\\+=\\$EMPTY;)/g, '{').replace(/(\\+\\$EMPTY\\+)/g, '+').replace(/(>'\\+'<)/g, '><').replace(/'\\+'/g, '');\n\n\tvar keys = Object.keys(components);\n\n\tbuilder = builder.replace(REG_VIEW_PART, function(text) {\n\t\tvar data = [];\n\t\tvar comkeys = Object.keys(F.components.instances);\n\t\tvar key = text.substring(6, text.length - 2);\n\t\tfor (var i = 0; i < comkeys.length; i++) {\n\t\t\tvar com = F.components.instances[comkeys[i]];\n\t\t\tif (com.parts && com.group && components[com.group] && com.parts[key])\n\t\t\t\tdata.push(com.parts[key]);\n\t\t}\n\n\t\tif (!data.length)\n\t\t\treturn '$EMPTY';\n\n\t\tdata = data.join('');\n\t\tvar index = $VIEWCACHE.indexOf(data);\n\t\tif (index === -1)\n\t\t\tindex = $VIEWCACHE.push(data) - 1;\n\t\treturn '$VIEWCACHE[' + index + ']';\n\t});\n\n\tvar fn = ('(function(self,repository,model,session,query,body,url,global,helpers,user,config,functions,index,output,files,mobile,settings){var G=F.global;var R=this.repository;var M=model;var theme=this.themeName;var language=this.language;var sitemap=this.repository.$sitemap;' + (isCookie ? 'var cookie=function(name){return self.req.cookie(name)};' : '') + (functions.length ? functions.join('') + ';' : '') + 'var controller=self;' + builder + ';return $output;})');\n\ttry {\n\t\tfn = eval(fn);\n\t\tfn.components = keys;\n\t} catch (e) {\n\t\tthrow new Error(filename + ': ' + e.message.toString());\n\t}\n\treturn fn;\n}\n\nfunction view_prepare_keywords(cmd) {\n\treturn cmd.replace(REG_SITEMAP, text => ' self.' + text.trim());\n}\n\nfunction wrapTryCatch(value, command, line) {\n\treturn F.isDebug ? ('(function(){try{return ' + value + '}catch(e){throw new Error(unescape(\\'' + escape(command) + '\\') + \\' - Line: ' + line + ' - \\' + e.message.toString());}return $EMPTY})()') : value;\n}\n\nfunction view_parse_plus(builder) {\n\tvar c = builder[builder.length - 1];\n\treturn c !== '!' && c !== '?' && c !== '+' && c !== '.' && c !== ':';\n}\n\nfunction view_prepare(command, dynamicCommand, functions, controller, components) {\n\n\tvar a = command.indexOf('.');\n\tvar b = command.indexOf('(');\n\tvar c = command.indexOf('[');\n\n\tvar max = [];\n\tvar tmp = 0;\n\n\tif (a !== -1)\n\t\tmax.push(a);\n\n\tif (b !== -1)\n\t\tmax.push(b);\n\n\tif (c !== -1)\n\t\tmax.push(c);\n\n\tvar index = Math.min.apply(this, max);\n\n\tif (index === -1)\n\t\tindex = command.length;\n\n\tvar name = command.substring(0, index);\n\tif (name === dynamicCommand)\n\t\treturn '$STRING(' + command + ').encode()';\n\n\tif (name[0] === '!' && name.substring(1) === dynamicCommand)\n\t\treturn '$STRING(' + command.substring(1) + ')';\n\n\tswitch (name) {\n\n\t\tcase 'foreach':\n\t\tcase 'end':\n\t\t\treturn '';\n\n\t\tcase 'part':\n\t\t\ttmp = command.indexOf('(');\n\t\t\treturn '/*PART{0}*/'.format(command.substring(tmp + 2, command.length - 2));\n\n\t\tcase 'section':\n\t\t\ttmp = command.indexOf('(');\n\t\t\treturn tmp === -1 ? '' : '(repository[\\'$section_' + command.substring(tmp + 1, command.length - 1).replace(/'|\"/g, '') + '\\'] || \\'\\')';\n\n\t\tcase 'log':\n\t\tcase 'LOG':\n\t\t\treturn '(' + (name === 'log' ? 'F.' : '') + command + '?$EMPTY:$EMPTY)';\n\n\t\tcase 'logger':\n\t\tcase 'LOGGER':\n\t\t\treturn '(' + (name === 'logger' ? 'F.' : '') + command + '?$EMPTY:$EMPTY)';\n\n\t\tcase 'console':\n\t\t\treturn '(' + command + '?$EMPTY:$EMPTY)';\n\n\t\tcase '!cookie':\n\t\t\treturn '$STRING(' + command + ')';\n\t\tcase '!isomorphic':\n\t\t\treturn '$STRING(' + command + ')';\n\n\t\tcase 'root':\n\t\t\tvar r = CONF.default_root;\n\t\t\treturn '\\'' + (r ? r.substring(0, r.length - 1) : r) + '\\'';\n\n\t\tcase 'M':\n\t\tcase 'R':\n\t\tcase 'G':\n\t\tcase 'model':\n\t\tcase 'repository':\n\t\tcase 'query':\n\t\tcase 'global':\n\t\tcase 'MAIN':\n\t\tcase 'session':\n\t\tcase 'user':\n\t\tcase 'config':\n\t\tcase 'CONF':\n\t\tcase 'REPO':\n\t\tcase 'controller':\n\t\t\treturn view_is_assign(command) ? ('self.$set(' + command + ')') : ('$STRING(' + command + ').encode()');\n\n\t\tcase 'body':\n\t\t\treturn view_is_assign(command) ? ('self.$set(' + command + ')') : command.lastIndexOf('.') === -1 ? 'output' : ('$STRING(' + command + ').encode()');\n\n\t\tcase 'files':\n\t\tcase 'mobile':\n\t\tcase 'continue':\n\t\tcase 'break':\n\t\tcase 'language':\n\t\tcase 'TRANSLATE':\n\t\tcase 'helpers':\n\t\t\treturn command;\n\n\t\tcase 'cookie':\n\t\tcase 'isomorphic':\n\t\tcase 'settings':\n\t\tcase 'CONFIG':\n\t\tcase 'FUNC':\n\t\tcase 'function':\n\t\tcase 'MODEL':\n\t\tcase 'SCHEMA':\n\t\tcase 'MODULE':\n\t\tcase 'functions':\n\t\t\treturn '$STRING(' + command + ').encode()';\n\n\t\tcase '!M':\n\t\tcase '!R':\n\t\tcase '!G':\n\t\tcase '!controller':\n\t\tcase '!repository':\n\t\tcase '!get':\n\t\tcase '!post':\n\t\tcase '!body':\n\t\tcase '!query':\n\t\tcase '!global':\n\t\tcase '!session':\n\t\tcase '!user':\n\t\tcase '!config':\n\t\tcase '!CONF':\n\t\tcase '!functions':\n\t\tcase '!model':\n\t\tcase '!CONFIG':\n\t\tcase '!SCHEMA':\n\t\tcase '!function':\n\t\tcase '!MODEL':\n\t\tcase '!MODULE':\n\t\t\treturn '$STRING(' + command.substring(1) + ')';\n\n\t\tcase 'resource':\n\t\t\treturn '$STRING(self.' + command + ').encode()';\n\t\tcase 'RESOURCE':\n\t\t\treturn '$STRING(' + command + ').encode()';\n\n\t\tcase '!resource':\n\t\t\treturn '$STRING(self.' + command.substring(1) + ')';\n\t\tcase '!RESOURCE':\n\t\t\treturn '$STRING(' + command.substring(1) + ')';\n\n\t\tcase 'host':\n\t\tcase 'hostname':\n\t\t\treturn command.indexOf('(') === -1 ? 'self.host()' : 'self.' + command;\n\n\t\tcase 'href':\n\t\t\treturn command.indexOf('(') === -1 ? 'self.href()' : 'self.' + command;\n\n\t\tcase 'url':\n\t\t\treturn command.indexOf('(') === -1 ? 'self.' + command : 'self.$' + command;\n\n\t\tcase 'title':\n\t\tcase 'description':\n\t\tcase 'keywords':\n\t\tcase 'author':\n\t\t\treturn command.indexOf('(') === -1 ? '(repository[\\'$' + command + '\\'] || \\'\\').toString().encode()' : 'self.$' + command;\n\n\t\tcase 'title2':\n\t\t\treturn 'self.$' + command;\n\n\t\tcase '!title':\n\t\tcase '!description':\n\t\tcase '!keywords':\n\t\tcase '!author':\n\t\t\treturn '(repository[\\'$' + command.substring(1) + '\\'] || \\'\\')';\n\n\t\tcase 'head':\n\t\t\treturn command.indexOf('(') === -1 ? 'self.' + command + '()' : 'self.$' + command;\n\n\t\tcase 'sitemap_url':\n\t\tcase 'sitemap_name':\n\t\tcase 'sitemap_navigation':\n\t\tcase 'sitemap_url2':\n\t\tcase 'sitemap_name2':\n\t\t\treturn 'self.' + command;\n\t\tcase 'breadcrumb_url':\n\t\tcase 'breadcrumb_name':\n\t\tcase 'breadcrumb_url2':\n\t\tcase 'breadcrumb_name2':\n\t\tcase 'breadcrumb_navigation':\n\t\t\treturn 'self.sitemap_' + command.substring(10);\n\n\t\tcase 'sitemap':\n\t\tcase 'breadcrumb':\n\t\tcase 'place':\n\t\t\tif (name === 'breadcrumb')\n\t\t\t\tname = 'sitemap';\n\t\t\treturn command.indexOf('(') === -1 ? '(repository[\\'$' + command + '\\'] || \\'\\')' : 'self.$' + command;\n\n\t\tcase 'meta':\n\t\t\treturn command.indexOf('(') === -1 ? 'self.$meta()' : 'self.$' + command;\n\n\t\tcase 'import':\n\t\tcase 'favicon':\n\t\tcase 'js':\n\t\tcase 'css':\n\t\tcase 'script':\n\t\tcase 'absolute':\n\t\t\treturn 'self.$' + command + (command.indexOf('(') === -1 ? '()' : '');\n\n\t\tcase 'components':\n\n\t\t\tvar group = command.match(REG_COMPONENTS_GROUP);\n\t\t\tif (group && group.length) {\n\t\t\t\tgroup = group[0].toString().replace(/'|\"'/g, '');\n\t\t\t\tcomponents[group] = 1;\n\t\t\t}\n\n\t\t\treturn 'self.$' + command + (command.indexOf('(') === -1 ? '()' : '');\n\n\t\tcase 'index':\n\t\t\treturn '(' + command + ')';\n\n\t\tcase 'component':\n\n\t\t\ttmp = command.indexOf('\\'');\n\n\t\t\tvar is = false;\n\t\t\tif (tmp !== -1) {\n\t\t\t\tname = command.substring(tmp + 1, command.indexOf('\\'', tmp + 1));\n\t\t\t\ttmp = F.components.instances[name];\n\t\t\t\tif (tmp && tmp.render)\n\t\t\t\t\tis = true;\n\t\t\t} else {\n\t\t\t\ttmp = command.indexOf('\"');\n\t\t\t\tname = command.substring(tmp + 1, command.indexOf('\"', tmp + 1));\n\t\t\t\ttmp = F.components.instances[name];\n\t\t\t\tif (tmp && tmp.render)\n\t\t\t\t\tis = true;\n\t\t\t}\n\n\t\t\tif (tmp)\n\t\t\t\tcomponents[tmp.group] = 1;\n\n\t\t\tif (is) {\n\n\t\t\t\tvar settings = command.substring(11 + name.length + 2, command.length - 1).trim();\n\t\t\t\tif (settings === ')')\n\t\t\t\t\tsettings = '';\n\n\t\t\t\t$VIEWASYNC++;\n\t\t\t\treturn '\\'@{-{0}-}\\'+(function(index){!controller.$viewasync&&(controller.$viewasync=[]);controller.$viewasync.push({replace:\\'@{-{0}-}\\',name:\\'{1}\\',settings:{2}});return $EMPTY})({0})'.format($VIEWASYNC, name, settings || 'null');\n\t\t\t}\n\n\t\t\treturn 'self.' + command;\n\n\t\tcase 'routeJS':\n\t\tcase 'routeScript':\n\t\tcase 'routeCSS':\n\t\tcase 'routeStyle':\n\t\tcase 'routeImage':\n\t\tcase 'routeFont':\n\t\tcase 'routeDownload':\n\t\tcase 'routeStatic':\n\t\tcase 'routeVideo':\n\t\tcase 'public_js':\n\t\tcase 'public_css':\n\t\tcase 'public_image':\n\t\tcase 'public_font':\n\t\tcase 'public_download':\n\t\tcase 'public_video':\n\t\tcase 'public':\n\t\tcase 'translate':\n\t\t\treturn 'self.' + command;\n\t\tcase 'json':\n\t\tcase 'json2':\n\t\tcase 'sitemap_change':\n\t\tcase 'sitemap_replace':\n\t\tcase 'sitemap_add':\n\t\tcase 'helper':\n\t\tcase 'view':\n\t\tcase 'layout':\n\t\tcase 'image':\n\t\tcase 'template':\n\t\tcase 'templateToggle':\n\t\tcase 'viewCompile':\n\t\tcase 'view_compile':\n\t\tcase 'viewToggle':\n\t\tcase 'download':\n\t\tcase 'selected':\n\t\tcase 'disabled':\n\t\tcase 'checked':\n\t\tcase 'header':\n\t\tcase 'options':\n\t\tcase 'readonly':\n\t\tcase 'canonical':\n\t\tcase 'dns':\n\t\tcase 'next':\n\t\tcase 'prefetch':\n\t\tcase 'prerender':\n\t\tcase 'prev':\n\t\t\treturn 'self.$' + command;\n\n\t\tcase 'now':\n\t\t\treturn '(new Date()' + command.substring(3) + ')';\n\n\t\tcase 'radio':\n\t\tcase 'text':\n\t\tcase 'checkbox':\n\t\tcase 'hidden':\n\t\tcase 'textarea':\n\t\tcase 'password':\n\t\t\treturn 'self.$' + appendModel(command);\n\n\t\tdefault:\n\t\t\treturn F.helpers[name] ? ('helpers.' + view_insert_call(command)) : ('$STRING(' + (functions.indexOf(name) === -1 ? command[0] === '!' ? command.substring(1) + ')' : command + ').encode()' : command + ')'));\n\t}\n}\n\nfunction view_insert_call(command) {\n\n\tvar beg = command.indexOf('(');\n\tif (beg === -1)\n\t\treturn command;\n\n\tvar length = command.length;\n\tvar count = 0;\n\n\tfor (var i = beg + 1; i < length; i++) {\n\n\t\tvar c = command[i];\n\n\t\tif (c !== '(' && c !== ')')\n\t\t\tcontinue;\n\n\t\tif (c === '(') {\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar arg = command.substring(beg + 1);\n\t\treturn command.substring(0, beg) + '.call(self' + (arg.length > 1 ? ',' + arg : ')');\n\t}\n\n\treturn command;\n}\n\nfunction view_is_assign(value) {\n\n\tvar length = value.length;\n\tvar skip = 0;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar c = value[i];\n\n\t\tif (c === '[') {\n\t\t\tskip++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c === ']') {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar next = value[i + 1] || '';\n\n\t\tif (c === '+' && (next === '+' || next === '=')) {\n\t\t\tif (!skip)\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif (c === '-' && (next === '-' || next === '=')) {\n\t\t\tif (!skip)\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif (c === '*' && (next === '*' || next === '=')) {\n\t\t\tif (!skip)\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif (c === '=') {\n\t\t\tif (!skip)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction view_find_command(content, index, entire) {\n\n\tindex = content.indexOf('@{', index);\n\tif (index === -1)\n\t\treturn null;\n\n\tvar length = content.length;\n\tvar count = 0;\n\n\tfor (var i = index + 2; i < length; i++) {\n\t\tvar c = content[i];\n\n\t\tif (c === '{') {\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c !== '}')\n\t\t\tcontinue;\n\t\telse if (count > 0) {\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar command = content.substring(index + 2, i).trim();\n\n\t\t// @{{ SKIP }}\n\t\tif (command[0] === '{')\n\t\t\treturn view_find_command(content, index + 1);\n\n\t\tvar obj = { beg: index, end: i, line: view_line_counter(content.substr(0, index)), command: command };\n\n\t\tif (entire)\n\t\t\tobj.phrase = content.substring(index, i + 1);\n\n\t\treturn obj;\n\t}\n\n\treturn null;\n}\n\nfunction view_line_counter(value) {\n\tvar count = value.match(/\\n/g);\n\treturn count ? count.length : 0;\n}\n\nfunction view_find_localization(content, index) {\n\n\tindex = content.indexOf('@(', index);\n\tif (index === -1)\n\t\treturn null;\n\n\tvar length = content.length;\n\tvar count = 0;\n\tvar beg = content[index - 1];\n\tvar esc = '';\n\n\tfor (var i = index + 2; i < length; i++) {\n\t\tvar c = content[i];\n\n\t\tif (c === '(') {\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c !== ')')\n\t\t\tcontinue;\n\t\telse if (count) {\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar end = content.substring(i + 1, i + 2);\n\t\tif (beg === end && beg === '\"' || beg === '\\'' || beg === '`')\n\t\t\tesc = beg;\n\t\treturn { beg: index, end: i, command: content.substring(index + 2, i).trim(), escape: esc };\n\t}\n\n\treturn null;\n}\n\nfunction removeComments(html) {\n\tvar tagBeg = '<!--';\n\tvar tagEnd = '-->';\n\tvar beg = html.indexOf(tagBeg);\n\tvar end = 0;\n\n\twhile (beg !== -1) {\n\t\tend = html.indexOf(tagEnd, beg + 4);\n\n\t\tif (end === -1)\n\t\t\tbreak;\n\n\t\tvar comment = html.substring(beg, end + 3);\n\t\tif (comment.indexOf('[if') !== -1 || comment.indexOf('[endif') !== -1) {\n\t\t\tbeg = html.indexOf(tagBeg, end + 3);\n\t\t} else {\n\t\t\thtml = html.replacer(comment, '');\n\t\t\tbeg = html.indexOf(tagBeg, beg);\n\t\t}\n\t}\n\n\treturn html;\n}\n\nfunction compressView(html, minify) {\n\n\tvar cache = [];\n\tvar beg = 0;\n\tvar end;\n\n\twhile (true) {\n\t\tbeg = html.indexOf('@{compile ', beg - 1);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = html.indexOf('@{end}', beg + 6);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tcache.push(html.substring(beg, end + 6));\n\t\thtml = html.substring(0, beg) + '#@' + (cache.length - 1) + '#' + html.substring(end + 6);\n\t}\n\n\twhile (true) {\n\t\tbeg = html.indexOf('@{', beg);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = html.indexOf('}', beg + 2);\n\t\tif (end === -1)\n\t\t\tbreak;\n\t\tcache.push(html.substring(beg, end + 1));\n\t\thtml = html.substring(0, beg) + '#@' + (cache.length - 1) + '#' + html.substring(end + 1);\n\t}\n\n\thtml = compressHTML(html, minify, false);\n\n\treturn html.replace(/#@\\d+#/g, function(text) {\n\t\treturn cache[+text.substring(2, text.length - 1)];\n\t});\n}\n\n/**\n * Inline JS compressor\n * @private\n * @param  {String} html HTML.\n * @param  {Number} index Last index.\n * @return {String}\n */\nfunction compressJS(html, index, filename, nomarkup) {\n\n\tif (!CONF.allow_compile_script)\n\t\treturn html;\n\n\tvar strFrom = '<script type=\"text/javascript\">';\n\tvar strTo = '</script>';\n\n\tvar indexBeg = html.indexOf(strFrom, index || 0);\n\tif (indexBeg === -1) {\n\t\tstrFrom = '<script>';\n\t\tindexBeg = html.indexOf(strFrom, index || 0);\n\t\tif (indexBeg === -1)\n\t\t\treturn html;\n\t}\n\n\tvar indexEnd = html.indexOf(strTo, indexBeg + strFrom.length);\n\tif (indexEnd === -1)\n\t\treturn html;\n\n\tvar js = html.substring(indexBeg, indexEnd + strTo.length).trim();\n\tvar beg = html.indexOf(js);\n\tif (beg === -1)\n\t\treturn html;\n\n\tvar val = js.substring(strFrom.length, js.length - strTo.length).trim();\n\tvar compiled = exports.compile_javascript(val, filename, nomarkup);\n\thtml = html.replacer(js, strFrom + compiled.trim() + strTo.trim());\n\treturn compressJS(html, indexBeg + compiled.length + 9, filename, nomarkup);\n}\n\nfunction compressCSS(html, index, filename, nomarkup) {\n\n\tif (!CONF.allow_compile_style)\n\t\treturn html;\n\n\tvar strFrom = '<style type=\"text/css\">';\n\tvar strTo = '</style>';\n\n\tvar indexBeg = html.indexOf(strFrom, index || 0);\n\tif (indexBeg === -1) {\n\t\tstrFrom = '<style>';\n\t\tindexBeg = html.indexOf(strFrom, index || 0);\n\t\tif (indexBeg === -1)\n\t\t\treturn html;\n\t}\n\n\tvar indexEnd = html.indexOf(strTo, indexBeg + strFrom.length);\n\tif (indexEnd === -1)\n\t\treturn html;\n\n\tvar css = html.substring(indexBeg, indexEnd + strTo.length);\n\tvar val = css.substring(strFrom.length, css.length - strTo.length).trim();\n\tvar compiled = exports.compile_css(val, filename, nomarkup);\n\thtml = html.replacer(css, (strFrom + compiled.trim() + strTo).trim());\n\treturn compressCSS(html, indexBeg + compiled.length + 8, filename, nomarkup);\n}\n\nfunction variablesCSS(content) {\n\n\tif (!content)\n\t\treturn content;\n\n\tvar variables = {};\n\n\tcontent = content.replace(REG_CSS_10, function(text) {\n\t\tvar index = text.indexOf(':');\n\t\tif (index === -1)\n\t\t\treturn text;\n\t\tvar key = text.substring(0, index).trim();\n\t\tvariables[key] = text.substring(index + 1, text.length - 1).trim();\n\t\treturn '';\n\t});\n\n\tcontent = content.replace(REG_CSS_11, function(text) {\n\n\t\tvar index = text.indexOf('||');\n\t\tvar variable = '';\n\t\tvar last = text[text.length - 1];\n\t\tvar len = text.length;\n\n\t\tif (last === ';' || last === '}' || last === '!' || last === ' ')\n\t\t\tlen = len - 1;\n\t\telse\n\t\t\tlast = '';\n\n\t\tif (index !== -1)\n\t\t\tvariable = variables[text.substring(0, index).trim()] || text.substring(index + 2, len).trim();\n\t\telse\n\t\t\tvariable = variables[text.substring(0, len).trim()];\n\n\t\treturn variable ? (variable + last) : text;\n\t}).trim();\n\n\treturn content;\n}\n\nfunction nested(css, id, variable) {\n\n\tif (!css)\n\t\treturn css;\n\n\tvar index = 0;\n\tvar output = '';\n\tvar A = false;\n\tvar count = 0;\n\tvar beg;\n\tvar begAt;\n\tvar valid = false;\n\tvar plus = '';\n\tvar skip = false;\n\tvar skipImport = '';\n\tvar isComment = false;\n\tvar comment = '';\n\tvar skipView = false;\n\tvar skipType;\n\n\twhile (true) {\n\n\t\tvar a = css[index++];\n\t\tif (!a)\n\t\t\tbreak;\n\n\t\tif (a === '/' && css[index] === '*') {\n\t\t\tisComment = true;\n\t\t\tindex++;\n\t\t\tcomment = '';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isComment) {\n\t\t\tcomment += a;\n\t\t\tif (a === '*' && css[index] === '/') {\n\t\t\t\tisComment = false;\n\t\t\t\tindex++;\n\t\t\t\tif (comment === 'auto*')\n\t\t\t\t\toutput += '/*auto*/';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (a === '\\n' || a === '\\r')\n\t\t\tcontinue;\n\n\t\tif (a === '$' && variable)\n\t\t\tvariable();\n\n\t\tif (a === '@' && css[index] === '{')\n\t\t\tskipView = true;\n\n\t\tif (skipView) {\n\t\t\tplus += a;\n\t\t\tif (a === '}')\n\t\t\t\tskipView = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (a === '\\'' || a === '\"') {\n\t\t\tif (a === skipType && css[index] !== '\\\\')\n\t\t\t\tskipType = '';\n\t\t\telse if (!skipType) {\n\t\t\t\tskipType = a;\n\t\t\t}\n\t\t}\n\n\t\tif (skipType) {\n\t\t\tplus += a;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (a === '@') {\n\t\t\tbegAt = index;\n\t\t\tskip = true;\n\t\t}\n\n\t\tif (skip && !skipImport && (a === ';' || a === '{')) {\n\t\t\tskipImport = a;\n\t\t\tif (a === ';') {\n\t\t\t\toutput += css.substring(begAt - 1, index);\n\t\t\t\tskip = false;\n\t\t\t\tplus = '';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tplus += a;\n\n\t\tif (a === '{') {\n\n\t\t\tif (A) {\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tA = true;\n\t\t\tcount = 0;\n\t\t\tbeg = index;\n\t\t\tvalid = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (a === '}') {\n\n\t\t\tif (count > 0) {\n\t\t\t\tcount--;\n\t\t\t\tvalid = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!valid) {\n\t\t\t\toutput += plus;\n\t\t\t\tplus = '';\n\t\t\t\tA = false;\n\t\t\t\tskip = false;\n\t\t\t\tskipImport = '';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (skip) {\n\n\t\t\t\tif (plus.indexOf('@keyframes') !== -1) {\n\t\t\t\t\toutput += plus;\n\t\t\t\t} else {\n\t\t\t\t\tbegAt = plus.indexOf('{');\n\t\t\t\t\toutput += plus.substring(0, begAt + 1) + process_nested(plus.substring(begAt), id).trim() + '}';\n\t\t\t\t}\n\n\t\t\t\tA = false;\n\t\t\t\tskip = false;\n\t\t\t\tskipImport = '';\n\t\t\t\tplus = '';\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar ni = beg - 1;\n\t\t\tvar name = '';\n\n\t\t\twhile (true) {\n\t\t\t\tvar b = css[ni--];\n\t\t\t\tif (b === '{')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (b === '}' || b === '\\n' || b === '\\r' || b === undefined || (skipImport && skipImport === b))\n\t\t\t\t\tbreak;\n\t\t\t\tname = b + name;\n\t\t\t}\n\n\t\t\tA = false;\n\t\t\tskip = false;\n\t\t\tskipImport = '';\n\t\t\tplus = '';\n\t\t\toutput += process_nested(css.substring(beg - 1, index), (id || '') + name.trim());\n\t\t}\n\t}\n\n\treturn output + plus;\n}\n\nfunction process_nested(css, name) {\n\tcss = css.trim();\n\tcss = make_nested(css.substring(1, css.length - 1), name);\n\treturn nested(css, name);\n}\n\nfunction make_nested(css, name) {\n\n\tvar index = 0;\n\tvar plus = '';\n\tvar output = '';\n\tvar count = 0;\n\tvar A = false;\n\tvar valid = false;\n\n\twhile (true) {\n\t\tvar a = css[index++];\n\n\t\tif (!a)\n\t\t\tbreak;\n\n\t\tif (a === '\\n' || a === '\\r')\n\t\t\tcontinue;\n\n\t\tif (a !== ' ' || plus[plus.length -1] !== ' ')\n\t\t\tplus += a;\n\n\t\tif (a === '{') {\n\n\t\t\tif (A) {\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tA = true;\n\t\t\tcount = 0;\n\t\t\tvalid = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (a === '}') {\n\n\t\t\tif (count > 0) {\n\t\t\t\tcount--;\n\t\t\t\tvalid = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!valid) {\n\t\t\t\toutput += name + ' ' + plus.trim();\n\t\t\t\tplus = '';\n\t\t\t\tA = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\toutput += plus;\n\t\t}\n\t}\n\n\treturn output;\n}\n\nfunction compressHTML(html, minify, isChunk) {\n\n\tif (!html || !minify)\n\t\treturn html;\n\n\thtml = removeComments(html.replace(REG_WIN, ''));\n\n\tvar tags = ['script', 'textarea', 'pre', 'code'];\n\tvar id = '[' + new Date().getTime() + ']#';\n\tvar cache = {};\n\tvar indexer = 0;\n\tvar length = tags.length;\n\tvar chars = 65;\n\tvar tagBeg, tagEnd, beg, end, len, key, value;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar o = tags[i];\n\n\t\ttagBeg = '<' + o;\n\t\ttagEnd = '</' + o;\n\n\t\tbeg = html.indexOf(tagBeg);\n\t\tend = 0;\n\t\tlen = tagEnd.length;\n\n\t\twhile (beg !== -1) {\n\n\t\t\tend = html.indexOf(tagEnd, beg + 3);\n\t\t\tif (end === -1) {\n\t\t\t\tif (isChunk)\n\t\t\t\t\tend = html.length;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkey = id + (indexer++) + String.fromCharCode(chars++);\n\t\t\tif (chars > 90)\n\t\t\t\tchars = 65;\n\n\t\t\tvalue = html.substring(beg, end + len);\n\n\t\t\tif (!i) {\n\t\t\t\tend = value.indexOf('>');\n\t\t\t\tlen = value.indexOf('type=\"text/template\"');\n\n\t\t\t\tif (len < end && len !== -1) {\n\t\t\t\t\tbeg = html.indexOf(tagBeg, beg + tagBeg.length);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlen = value.indexOf('type=\"text/html\"');\n\n\t\t\t\tif (len < end && len !== -1) {\n\t\t\t\t\tbeg = html.indexOf(tagBeg, beg + tagBeg.length);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlen = value.indexOf('type=\"text/ng-template\"');\n\n\t\t\t\tif (len < end && len !== -1) {\n\t\t\t\t\tbeg = html.indexOf(tagBeg, beg + tagBeg.length);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcache[key] = value;\n\t\t\thtml = html.replacer(value, key);\n\t\t\tbeg = html.indexOf(tagBeg, beg + tagBeg.length);\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tif (!REG_6.test(html))\n\t\t\tbreak;\n\t\thtml = html.replace(REG_6, text => text.replace(/\\s+/g, ' '));\n\t}\n\n\thtml = html.replace(REG_9, '>').replace(REG_10, function(text) {\n\t\treturn text.trim().replace(/\\s/g, '');\n\t}).replace(REG_5, '><').replace(REG_4, function(text) {\n\t\tvar c = text[text.length - 1];\n\t\treturn c === '<' ? c : ' ' + c;\n\t}).replace(REG_1, '').replace(REG_2, '');\n\n\tfor (var key in cache)\n\t\thtml = html.replacer(key, cache[key]);\n\n\treturn html;\n}\n\n/**\n * Read file\n * @param {String} path\n * @return {Object}\n */\nfunction viewengine_read(path, controller) {\n\tvar config = CONF;\n\tvar out = path[0] === '.';\n\tvar filename = out ? path.substring(1) : F.path.views(path);\n\tvar key;\n\n\tif (RELEASE) {\n\t\tkey = '404/' + path;\n\t\tvar is = F.temporary.other[key];\n\t\tif (is !== undefined)\n\t\t\treturn null;\n\t}\n\n\tif (existsSync(filename))\n\t\treturn view_parse(view_parse_localization(modificators(Fs.readFileSync(filename).toString('utf8'), filename, 'view', controller), controller.language), config.allow_compile_html, filename, controller);\n\n\tvar index;\n\n\tif (out) {\n\n\t\tif (controller.themeName) {\n\t\t\tindex = filename.lastIndexOf('/');\n\t\t\tif (index !== -1) {\n\t\t\t\tfilename = filename.substring(0, filename.lastIndexOf('/', index - 1)) + filename.substring(index);\n\t\t\t\tif (existsSync(filename))\n\t\t\t\t\treturn view_parse(view_parse_localization(modificators(Fs.readFileSync(filename).toString('utf8'), filename, 'view', controller), controller.language), config.allow_compile_html, filename, controller);\n\t\t\t}\n\t\t}\n\n\t\tif (RELEASE)\n\t\t\tF.temporary.other[key] = null;\n\n\t\treturn null;\n\t}\n\n\tindex = path.lastIndexOf('/');\n\tif (index === -1) {\n\t\tif (RELEASE)\n\t\t\tF.temporary.other[key] = null;\n\t\treturn null;\n\t}\n\n\tfilename = F.path.views(path.substring(index + 1));\n\n\tif (existsSync(filename))\n\t\treturn view_parse(view_parse_localization(modificators(Fs.readFileSync(filename).toString('utf8'), filename, 'view', controller), controller.language), config.allow_compile_html, filename, controller);\n\n\tif (RELEASE)\n\t\tF.temporary.other[key] = null;\n\n\treturn null;\n}\n\nfunction modificators(value, filename, type, controller) {\n\n\tif (filename) {\n\t\tvar length = F.directory.length;\n\t\tif (filename.substring(0, length) === F.directory) {\n\t\t\tfilename = filename.substring(length);\n\t\t\tif (filename[0] !== '/')\n\t\t\t\tfilename = '/' + filename;\n\t\t}\n\n\t\tif (F.modificators2) {\n\t\t\tvar arr = F.modificators2[filename];\n\t\t\tif (arr) {\n\t\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\t\tvar output = arr[i](type || 'view', filename, value, controller);\n\t\t\t\t\tif (output)\n\t\t\t\t\t\tvalue = output;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!F.modificators)\n\t\treturn value;\n\n\tfor (var i = 0; i < F.modificators.length; i++) {\n\t\tvar output = F.modificators[i](type || 'view', filename, value, controller);\n\t\tif (output)\n\t\t\tvalue = output;\n\t}\n\n\treturn value;\n}\n\nfunction viewengine_load(name, filename, controller, component) {\n\n\tvar precompiled = F.routes.views[name];\n\tif (precompiled)\n\t\tfilename = '.' + precompiled.filename;\n\telse\n\t\tfilename += '.html';\n\n\tvar key = 'view#' + filename + (controller.language || '');\n\n\tvar generator = F.temporary.views[key];\n\tif (generator)\n\t\treturn generator;\n\n\tgenerator = viewengine_read(filename, controller);\n\n\tif (component || !F.isDebug)\n\t\tF.temporary.views[key] = generator;\n\n\treturn generator;\n}\n\nfunction viewengine_dynamic(content, language, controller, cachekey) {\n\n\tvar generator = cachekey ? (F.temporary.views[cachekey] || null) : null;\n\tif (generator)\n\t\treturn generator;\n\n\tgenerator = view_parse(view_parse_localization(modificators(content, '', 'view', controller), language), CONF.allow_compile_html, null, controller);\n\n\tif (cachekey && !F.isDebug)\n\t\tF.temporary.views[cachekey] = generator;\n\n\treturn generator;\n}\n\nfunction appendModel(str) {\n\tvar index = str.indexOf('(');\n\tif (index === -1)\n\t\treturn str;\n\tvar end = str.substring(index + 1);\n\treturn str.substring(0, index) + '(model' + (end[0] === ')' ? end : ',' + end);\n}\n\nfunction cleanURL(url, index) {\n\tvar o = url.substring(0, index);\n\tvar prev;\n\tvar skip = false;\n\n\tfor (var i = index, length = url.length; i < length; i++) {\n\t\tvar c = url[i];\n\t\tif (c === '/' && prev === '/' && !skip)\n\t\t\tcontinue;\n\t\tprev = c;\n\t\to += c;\n\t}\n\n\treturn o;\n}\n\nexports.preparePath = function(path, remove) {\n\tvar root = CONF.default_root;\n\tif (!root)\n\t\treturn path;\n\tvar is = path[0] === '/';\n\tif ((is && path[1] === '/') || path[4] === ':' || path[5] === ':')\n\t\treturn path;\n\treturn remove ? path.substring(root.length - 1) : (root + (is ? path.substring(1) : path));\n};\n\nexports.parseURI = function(req) {\n\n\tvar cache = F.temporary.other[req.host];\n\tvar port;\n\tvar hostname;\n\n\tif (cache) {\n\t\tport = cache.port;\n\t\thostname = cache.hostname;\n\t} else {\n\t\tport = req.host.lastIndexOf(':');\n\t\tif (port === -1) {\n\t\t\tport = null;\n\t\t\thostname = req.host;\n\t\t} else {\n\t\t\thostname = req.host.substring(0, port);\n\t\t\tport = req.host.substring(port + 1);\n\t\t}\n\t\tF.temporary.other[req.host] = { port: port, hostname: hostname };\n\t}\n\n\tvar search = req.url.indexOf('?', 1);\n\tvar query = null;\n\tvar pathname;\n\n\tif (search === -1) {\n\t\tsearch = null;\n\t\tpathname = req.url;\n\t} else {\n\t\tpathname = req.url.substring(0, search);\n\t\tsearch = req.url.substring(search);\n\t\tquery = search.substring(1);\n\t}\n\n\tvar index = pathname.indexOf('//');\n\tif (index !== -1) {\n\t\tpathname = cleanURL(pathname, index);\n\t\treq.url = pathname;\n\t\tif (search)\n\t\t\treq.url += search;\n\t}\n\n\treturn { auth: null, hash: null, host: req.host, hostname: hostname, href: req.$protocol + '://' + req.host + req.url, path: req.url, pathname: pathname, port: port, protocol: req.$protocol + ':', query: query, search: search, slashes: true };\n};\n\n/**\n * Destroy the stream\n * @param {Stream} stream\n * @return {Stream}\n * @author Jonathan Ong <me@jongleberry.com>\n * @license MIT\n * @see {@link https://github.com/stream-utils/destroy}\n */\nfunction destroyStream(stream) {\n\tif (stream instanceof ReadStream) {\n\t\tstream.destroy();\n\t\ttypeof(stream.close) === 'function' && stream.on('open', function() {\n\t\t\ttypeof(this.fd) === 'number' && this.close();\n\t\t});\n\t} else if (stream instanceof Stream)\n\t\ttypeof(stream.destroy) === 'function' && stream.destroy();\n\treturn stream;\n}\n\nfunction isFinished(stream) {\n\n\t// Response & Request\n\tif (stream.socket) {\n\t\tif (stream.writable && (!stream.socket._writableState || stream.socket._writableState.finished || stream.socket._writableState.destroyed))\n\t\t\treturn true;\n\t\tif (stream.readable && (!stream.socket._readableState|| stream.socket._writableState.ended || stream.socket._readableState.destroyed))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tif (stream._readableState && (stream._readableState.ended || stream._readableState.destroyed))\n\t\treturn true;\n\n\tif (stream._writableState && (stream._writableState.finished || stream._writableState.destroyed))\n\t\treturn true;\n\n\treturn false;\n}\n\nfunction onFinished(stream, fn) {\n\n\tif (stream.$onFinished) {\n\t\tfn && fn();\n\t\tfn = null;\n\t\treturn;\n\t}\n\n\tif (stream.$onFinishedQueue) {\n\t\tif (stream.$onFinishedQueue instanceof Array)\n\t\t\tstream.$onFinishedQueue.push(fn);\n\t\telse\n\t\t\tstream.$onFinishedQueue = [stream.$onFinishedQueue, fn];\n\t\treturn;\n\t} else\n\t\tstream.$onFinishedQueue = fn;\n\n\tvar callback = function() {\n\t\t!stream.$onFinished && (stream.$onFinished = true);\n\t\tif (stream.$onFinishedQueue instanceof Array) {\n\t\t\twhile (stream.$onFinishedQueue.length)\n\t\t\t\tstream.$onFinishedQueue.shift()();\n\t\t\tstream.$onFinishedQueue = null;\n\t\t} else if (stream.$onFinishedQueue) {\n\t\t\tstream.$onFinishedQueue();\n\t\t\tstream.$onFinishedQueue = null;\n\t\t}\n\t};\n\n\tif (isFinished(stream)) {\n\t\tsetImmediate(callback);\n\t} else {\n\n\t\tif (stream.socket) {\n\t\t\tif (!stream.socket.$totalstream) {\n\t\t\t\tstream.socket.$totalstream = stream;\n\t\t\t\tif (stream.socket.prependListener) {\n\t\t\t\t\tstream.socket.prependListener('error', callback);\n\t\t\t\t\tstream.socket.prependListener('close', callback);\n\t\t\t\t} else {\n\t\t\t\t\tstream.socket.on('error', callback);\n\t\t\t\t\tstream.socket.on('close', callback);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (stream.prependListener) {\n\t\t\tstream.prependListener('error', callback);\n\t\t\tstream.prependListener('end', callback);\n\t\t\tstream.prependListener('close', callback);\n\t\t\tstream.prependListener('aborted', callback);\n\t\t\tstream.prependListener('finish', callback);\n\t\t} else {\n\t\t\tstream.on('error', callback);\n\t\t\tstream.on('end', callback);\n\t\t\tstream.on('close', callback);\n\t\t\tstream.on('aborted', callback);\n\t\t\tstream.on('finish', callback);\n\t\t}\n\n\t\t//stream.uri --> determines ServerRespone\n\t\t// stream.uri && stream.prependListener('aborted', callback);\n\t\t// (stream._writableState || stream.uri) && stream.prependListener('finish', callback);\n\t}\n}\n\nexports.encodeUnicodeURL = function(url) {\n\tvar output = url;\n\tfor (var i = 0, length = url.length; i < length; i++) {\n\t\tvar code = url.charCodeAt(i);\n\t\tif (code > 127)\n\t\t\toutput = output.replace(url[i], encodeURIComponent(url[i]));\n\t}\n\treturn output;\n};\n\nexports.parseBlock = function(name, content) {\n\n\t// @{block name}\n\t//\n\t// @{end}\n\n\tif (!REG_BLOCK_BEG.test(content))\n\t\treturn content;\n\n\tvar newline = '\\n';\n\tvar lines = content.split(newline);\n\tvar is = false;\n\tvar skip = false;\n\tvar builder = '';\n\n\tname = (name || '').replace(/\\s/g, '').split(',');\n\n\tfor (var i = 0, length = lines.length; i < length; i++) {\n\n\t\tvar line = lines[i];\n\n\t\tif (!line)\n\t\t\tcontinue;\n\n\t\tif (REG_BLOCK_END.test(line)) {\n\t\t\tis = false;\n\t\t\tskip = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is) {\n\t\t\tif (skip)\n\t\t\t\tcontinue;\n\t\t\tbuilder += line + newline;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar index = line.search(REG_BLOCK_BEG);\n\t\tif (index === -1) {\n\t\t\tbuilder += line + newline;\n\t\t\tcontinue;\n\t\t}\n\n\t\tis = true;\n\t\tskip = true;\n\n\t\tvar block = line.substring(index + 8, line.indexOf('}', index)).replace(/\\|\\|/g, ',').replace(/\\s/g, '').split(',');\n\t\tfor (var j = 0, jl = block.length; j < jl; j++) {\n\t\t\tif (name.indexOf(block[j]) === -1)\n\t\t\t\tcontinue;\n\t\t\tskip = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn builder.trim();\n};\n\nfunction existsSync(filename) {\n\ttry {\n\t\treturn !!Fs.statSync(filename);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nfunction markup(body, filename) {\n\tbody = body.ROOT();\n\tvar command = view_find_command(body, 0, true);\n\tif (!command)\n\t\treturn body;\n\n\tvar G = F.global;\n\tvar config = CONF;\n\tvar resource = F.resource;\n\tvar M = EMPTYOBJECT;\n\tvar R = EMPTYOBJECT;\n\tvar model = EMPTYOBJECT;\n\tvar repository = EMPTYOBJECT;\n\tvar r = [];\n\n\twhile (command) {\n\n\t\tvar cmd = command.command;\n\t\tvar name = cmd;\n\n\t\tif (name.substring(0, 2) === '\\'%') {\n\t\t\tname = 'config';\n\t\t\tcmd = 'config[\\'' + cmd.substring(2) + ']';\n\t\t} else {\n\t\t\tvar index = name.indexOf('.');\n\t\t\tif (index !== -1)\n\t\t\t\tname = name.substring(0, index);\n\t\t\telse {\n\t\t\t\tindex = name.indexOf('(');\n\t\t\t\tif (index !== -1)\n\t\t\t\t\tname = name.substring(0, index);\n\t\t\t}\n\t\t}\n\n\t\tif (ALLOWEDMARKUP[name]) {\n\t\t\tswitch (cmd) {\n\t\t\t\tcase 'author':\n\t\t\t\t\tcmd = 'CONF.author';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'root':\n\t\t\t\t\tcmd = 'CONF.default_root';\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tr.push({ cmd: command.phrase, value: eval('(' + cmd + ')') });\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log('A markup compilation error -->', cmd, e, '\"' + body.trim().max(0, 150) + '\"', filename);\n\t\t\t}\n\t\t}\n\n\t\tcommand = view_find_command(body, command.end, true);\n\t}\n\n\tfor (var i = 0; i < r.length; i++)\n\t\tbody = body.replace(r[i].cmd, r[i].value);\n\n\treturn body;\n}\n\nglobal.HttpFile = HttpFile;\nexports.HttpFile = HttpFile;\nexports.viewEngineCompile = viewengine_dynamic;\nexports.viewEngine = viewengine_load;\nexports.parseLocalization = view_parse_localization;\nexports.findLocalization = view_find_localization;\nexports.destroyStream = destroyStream;\nexports.onFinished = onFinished;\nexports.modificators = modificators;\nexports.markup = markup;"
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 9.0556640625,
          "content": "The MIT License\nCopyright 2012-2021 (c) Peter Å irka <petersirka@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n\n=== Encrypt & Decrypt (index.js)\n\nThe MIT License (MIT)\nCopyright (c) 2011 Jozef Gula <gula.jozef@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n\n=== WebSocket encode/decode (index.js, utils.js)\n\nThe MIT License (MIT)\nCopyright (c) 2014 Jozef Gula <gula.jozef@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n\n=== node-formidable (internal.js)\n\nThe MIT License (MIT)\nCopyright (c) 2010 Hongli Lai\nCopyright (c) Felix GeisendÃ¶rfer -> https://github.com/felixge/node-formidable\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n=== Get PNG/JPG image size (internal.js)\n\nThe MIT License (MIT)\nCopyright (c) 2012 TJ Holowaychuk, visionmedia (http://tjholowaychuk.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n\n=== EE First (internal.js)\n\nThe MIT License (MIT)\nCopyright (c) 2014 Jonathan Ong me@jongleberry.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n=== on-finished (internal.js)\n\nThe MIT License (MIT)\nCopyright (c) 2013 Jonathan Ong <me@jongleberry.com>\nCopyright (c) 2014 Douglas Christopher Wilson <doug@somethingdoug.com>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n=== Shellsort algorithm (utils.js)\n\nSource: https://www.khanacademy.org/computer-programming/sort-algorithms/6199294078746624\n\nThe MIT License (MIT)\nCopyright (c) 2014 Sean McCarren\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "mail.js",
          "type": "blob",
          "size": 25.0703125,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkMail\n * @version 3.4.3\n */\n\n'use strict';\n\nconst Net = require('net');\nconst Tls = require('tls');\nconst Fs = require('fs');\n\nconst CRLF = '\\r\\n';\nconst REG_ESMTP = /\\besmtp\\b/i;\nconst REG_STATE = /\\d+/;\nconst REG_WINLINE = /\\r\\n/g;\nconst REG_NEWLINE = /\\n/g;\nconst REG_AUTH = /(AUTH LOGIN|AUTH PLAIN|PLAIN LOGIN)/i;\nconst REG_TLS = /TLS/;\nconst REG_STARTTLS = /STARTTLS/;\n// const REG_PREVIEW = /<body>/i;\nconst EMPTYARRAY = [];\n\nvar INDEXSENDER = 0;\nvar INDEXATTACHMENT = 0;\n\nif (!global.framework_utils)\n\tglobal.framework_utils = require('./utils');\n\nconst BUF_CRLF = Buffer.from(CRLF);\nconst CONCAT = [null, null];\n\n/**\n * Mailer\n * @class\n * @property {Boolean} debug Debug mode (true/false).\n */\nfunction Mailer() {\n\tthis.debug = false;\n\tthis.Message = Message;\n\tthis.Mail = Message;\n\tthis.connections = {};\n\tthis.$events = {};\n}\n\nMailer.prototype.emit = function(name, a, b, c, d, e, f, g) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nMailer.prototype.on = function(name, fn) {\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nMailer.prototype.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nMailer.prototype.removeListener = function(name, fn) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tthis.$events[name] = evt;\n\t\telse\n\t\t\tthis.$events[name] = undefined;\n\t}\n\treturn this;\n};\n\nMailer.prototype.removeAllListeners = function(name) {\n\tif (name)\n\t\tthis.$events[name] = undefined;\n\telse\n\t\tthis.$events = {};\n\treturn this;\n};\n\n/**\n * Create Mail Message\n * @param {String} subject\n * @param {String} body\n * @return {MailMessage}\n */\nMailer.prototype.create = function(subject, body) {\n\treturn new Message(subject, body);\n};\n\n/**\n * Message send callback\n * @callback ResolveMxCallback\n * @param {Error} err Error handling.\n * @param {Socket} socket Net socket.\n */\n\n/**\n * Mail Message\n * @param {String} subject\n * @param {String} body\n * @property {String} subject\n * @property {String} body\n */\nfunction Message(subject, body) {\n\tvar t = this;\n\tt.subject = subject || '';\n\tt.body = body || '';\n\tt.type = 'html';\n\tt.files;\n\tt.addressTo = [];\n\tt.addressReply;\n\tt.addressCC;\n\tt.addressBCC;\n\tt.addressFrom = { name: '', address: '' };\n\tt.closed = false;\n\tt.tls = false;\n\tt.$callback;\n\t// Supports (but it's hidden):\n\t// t.headers;\n\t// t.$unsubscribe;\n}\n\nMessage.prototype.preview = function(val) {\n\tthis.$preview = val;\n\treturn this;\n};\n\nMessage.prototype.unsubscribe = function(url) {\n\tvar tmp = url.substring(0, 6);\n\tthis.$unsubscribe = url ? (tmp === 'http:/' || tmp === 'https:' ? '<' + url + '>' : '<mailto:' + url + '>') : null;\n\treturn this;\n};\n\nMessage.prototype.callback = function(fn) {\n\tthis.$callback = fn;\n\treturn this;\n};\n\nMessage.prototype.sender = function(address, name) {\n\treturn this.from(address, name);\n};\n\nMessage.prototype.from = function(address, name) {\n\n\tif (address[address.length - 1] === '>') {\n\t\tvar index = address.indexOf('<');\n\t\tname = address.substring(0, index - 1);\n\t\taddress = address.substring(index + 1, address.length - 1);\n\t}\n\n\tthis.addressFrom.name = name || '';\n\tthis.addressFrom.address = address;\n\treturn this;\n};\n\nMessage.prototype.high = function() {\n\tthis.$priority = 1;\n\treturn this;\n};\n\nMessage.prototype.low = function() {\n\tthis.$priority = 5;\n\treturn this;\n};\n\nMessage.prototype.confidential = function() {\n\tthis.$confidential = true;\n\treturn this;\n};\n\nMessage.prototype.to = function(address, name, clear) {\n\n\tif (typeof(name) === 'boolean') {\n\t\tclear = name;\n\t\tname = undefined;\n\t}\n\n\tif (address[address.length - 1] === '>') {\n\t\tvar index = address.indexOf('<');\n\t\tname = address.substring(0, index - 1);\n\t\taddress = address.substring(index + 1, address.length - 1);\n\t}\n\n\tif (clear)\n\t\tthis.addressTo = [];\n\n\tif (name)\n\t\tthis.addressTo.push({ email: address, name: name });\n\telse\n\t\tthis.addressTo.push(address);\n\n\treturn this;\n};\n\nMessage.prototype.cc = function(address, name, clear) {\n\n\tif (typeof(name) === 'boolean') {\n\t\tclear = name;\n\t\tname = undefined;\n\t}\n\n\tif (address[address.length - 1] === '>') {\n\t\tvar index = address.indexOf('<');\n\t\tname = address.substring(0, index - 1);\n\t\taddress = address.substring(index + 1, address.length - 1);\n\t}\n\n\tif (clear || !this.addressCC)\n\t\tthis.addressCC = [];\n\n\tif (name)\n\t\tthis.addressCC.push({ email: address, name: name });\n\telse\n\t\tthis.addressCC.push(address);\n\n\treturn this;\n};\n\nMessage.prototype.bcc = function(address, clear) {\n\tif (clear || !this.addressBCC)\n\t\tthis.addressBCC = [];\n\tthis.addressBCC.push(address);\n\treturn this;\n};\n\nMessage.prototype.reply = function(address, clear) {\n\tif (clear || !this.addressReply)\n\t\tthis.addressReply = [];\n\tthis.addressReply.push(address);\n\treturn this;\n};\n\nMessage.prototype.attachment = function(filename, name) {\n\t!name && (name = framework_utils.getName(filename));\n\tvar extension = framework_utils.getExtension(name);\n\t!this.files && (this.files = []);\n\tthis.files.push({ name: name, filename: filename, type: framework_utils.getContentType(extension), extension: extension });\n\treturn this;\n};\n\nMessage.prototype.attachmentfs = function(storagename, id, name) {\n\n\tvar extension;\n\tvar type;\n\n\tif (name) {\n\t\textension = framework_utils.getExtension(name);\n\t\ttype = framework_utils.getContentType(extension);\n\t}\n\n\t!this.files && (this.files = []);\n\tthis.files.push({ storage: storagename, name: name, filename: id, type: type, extension: extension });\n\treturn this;\n};\n\nMessage.prototype.attachmentnosql = function(db, id, name) {\n\n\tvar extension;\n\tvar type;\n\n\tif (name) {\n\t\textension = framework_utils.getExtension(name);\n\t\ttype = framework_utils.getContentType(extension);\n\t}\n\n\t!this.files && (this.files = []);\n\tthis.files.push({ nosql: db, name: name, filename: id, type: type, extension: extension });\n\treturn this;\n};\n\n/**\n * Clears a timeout for sending emails (if the email is sent through the F.onMail)\n * @return {Message}\n */\nMessage.prototype.manually = function() {\n\tthis.$sending && clearImmediate(this.$sending);\n\treturn this;\n};\n\n/**\n * Adds an inline attachment.\n * Inline attachments are exactly like normal attachments except that they are represented with the 'Content-ID' (cid)\n * which can be referenced in the email's html body. For example an inline attachments (image) with a contentId of 'AB435BH'\n * can be used inside the html body as \"<img src='cid:AB435BH'>\". An enabled web client then can render and show the embedded image.\n *\n * @param {String} filename Filename with extension (e.g. '/local/path/123.jpg')\n * @param {String} name the optional filename (e.g. '123.jpg')\n * @param {String} contentId the Content-ID (e.g. 'AB435BH'), must be unique across the email\n * @returns {Message}\n */\nMessage.prototype.attachmentInline = Message.prototype.attachmentinline = function(filename, name, contentId) {\n\t!name && (name = framework_utils.getName(filename));\n\t!this.files && (this.files = []);\n\tvar extension = framework_utils.getExtension(name);\n\tthis.files.push({ name: name, filename: filename, type: framework_utils.getContentType(extension), disposition: 'inline', contentId: contentId, extension: extension });\n\treturn this;\n};\n\nMessage.prototype.send2 = function(callback) {\n\tvar opt =  F.temporary.mail_settings;\n\tif (!opt) {\n\t\tvar config = CONF.mail_smtp_options;\n\t\tconfig && (opt = config);\n\t\tF.temporary.mail_settings = opt || {};\n\t}\n\n\t// Computes a hostname\n\tif (!CONF.mail_smtp) {\n\t\tvar ea = (this.addressFrom.address || this.addressFrom) || '';\n\t\tea = ea.substring(ea.lastIndexOf('@') + 1);\n\t\tif (ea)\n\t\t\tea = 'smtp.' + ea;\n\t\tCONF.mail_smtp = ea;\n\t}\n\n\tmailer.send(CONF.mail_smtp, opt, this, callback);\n\treturn this;\n};\n\nMessage.prototype.send = function(smtp, options, callback) {\n\tmailer.send(smtp, options, this, callback);\n\treturn this;\n};\n\nMailer.prototype.switchToTLS = function(obj, options) {\n\n\tvar self = this;\n\n\tobj.tls = true;\n\tobj.socket.removeAllListeners();\n\n\tvar opt = framework_utils.copy(options.tls, { socket: obj.socket, host: obj.socket.$host, ciphers: 'SSLv3' });\n\tobj.socket2 = Tls.connect(opt, () => self.$send(obj, options, true));\n\n\tobj.socket2.on('error', function(err) {\n\t\tmailer.destroy(obj);\n\t\tself.closed = true;\n\t\tself.callback && self.callback(err);\n\t\tself.callback = null;\n\t\tif (obj.try || err.stack.indexOf('ECONNRESET') !== -1)\n\t\t\treturn;\n\t\tmailer.$events.error && mailer.emit('error', err, obj);\n\t});\n\n\tobj.socket2.on('clientError', function(err) {\n\t\tmailer.destroy(obj);\n\t\tself.callback && self.callback(err);\n\t\tself.callback = null;\n\t\tmailer.$events.error && !obj.try && mailer.emit('error', err, obj);\n\t});\n\n\tobj.socket2.on('connect', () => !options.secure && self.$send(obj, options));\n};\n\nMailer.prototype.destroy = function(obj) {\n\n\tif (obj.destroyed)\n\t\treturn this;\n\n\tobj.destroyed = true;\n\tobj.closed = true;\n\n\tif (obj.socket) {\n\t\tobj.socket.removeAllListeners();\n\t\tobj.socket.end();\n\t\tobj.socket.destroy();\n\t\tobj.socket = null;\n\t}\n\n\tif (obj.socket2) {\n\t\tobj.socket2.removeAllListeners();\n\t\tobj.socket2.end();\n\t\tobj.socket2.destroy();\n\t\tobj.socket2 = null;\n\t}\n\n\tdelete this.connections[obj.id];\n\treturn this;\n};\n\nconst ATTACHMENT_SO = { encoding: 'base64' };\n\nMailer.prototype.$writeattachment = function(obj) {\n\n\tvar attachment = obj.files ? obj.files.shift() : false;\n\tif (!attachment) {\n\t\tmailer.$writeline(obj, '--' + obj.boundary + '--', '', '.');\n\t\tobj.messagecallback && obj.messagecallback(null, obj.instance);\n\t\tobj.messagecallback = null;\n\t\treturn this;\n\t}\n\n\tvar stream;\n\n\tif (attachment.storage) {\n\t\tFILESTORAGE(attachment.storage).readbase64(attachment.filename, function(err, stream, meta) {\n\t\t\tif (err) {\n\t\t\t\tF.error(err, 'Mail.filestorage()', attachment.filename);\n\t\t\t\tmailer.$writeattachment(obj);\n\t\t\t} else {\n\n\t\t\t\tif (!attachment.name) {\n\t\t\t\t\tattachment.name = meta.name;\n\t\t\t\t\tattachment.type = meta.type;\n\t\t\t\t\tattachment.extension = U.getExtension(meta.name);\n\t\t\t\t}\n\n\t\t\t\twriteattachemnt_stream(attachment, obj, stream);\n\t\t\t}\n\t\t});\n\t} else if (attachment.nosql) {\n\t\tNOSQL(attachment.nosql).binary.readbase64(attachment.filename, function(err, stream, meta) {\n\t\t\tif (err) {\n\t\t\t\tF.error(err, 'Mail.attachmentnosql()', attachment.filename);\n\t\t\t\tmailer.$writeattachment(obj);\n\t\t\t} else {\n\n\t\t\t\tif (!attachment.name) {\n\t\t\t\t\tattachment.name = meta.name;\n\t\t\t\t\tattachment.type = meta.type;\n\t\t\t\t\tattachment.extension = U.getExtension(meta.name);\n\t\t\t\t}\n\n\t\t\t\twriteattachemnt_stream(attachment, obj, stream);\n\t\t\t}\n\t\t});\n\t} else {\n\t\tF.stats.performance.open++;\n\t\tstream = Fs.createReadStream(attachment.filename, ATTACHMENT_SO);\n\t\twriteattachemnt_stream(attachment, obj, stream);\n\t}\n\n\treturn this;\n};\n\nfunction writeattachemnt_stream(attachment, obj, stream) {\n\n\tvar name = attachment.name;\n\tvar isCalendar = attachment.extension === 'ics';\n\tvar message = [];\n\n\tmessage.push('--' + obj.boundary);\n\n\tif (!isCalendar) {\n\t\tif (attachment.contentId) {\n\t\t\tmessage.push('Content-Disposition: inline; filename=\"' + name + '\"');\n\t\t\tmessage.push('Content-ID: <' + attachment.contentId + '>');\n\t\t} else\n\t\t\tmessage.push('Content-Disposition: attachment; filename=\"' + name + '\"');\n\t}\n\n\tmessage.push('Content-Type: ' + attachment.type + ';' + (isCalendar ? ' charset=\"utf-8\"; method=REQUEST' : ''));\n\tmessage.push('Content-Transfer-Encoding: base64');\n\tmessage.push(CRLF);\n\tmailer.$writeline(obj, message.join(CRLF));\n\n\tstream.$mailer = mailer;\n\tstream.$mailerobj = obj;\n\tstream.on('data', writeattachment_data);\n\n\tCLEANUP(stream, function() {\n\t\tmailer.$writeline(obj, CRLF);\n\t\tmailer.$writeattachment(obj);\n\t});\n\n}\n\nfunction writeattachment_data(chunk) {\n\n\tvar length = chunk.length;\n\tvar count = 0;\n\tvar beg = 0;\n\n\twhile (count < length) {\n\n\t\tcount += 68;\n\n\t\tif (count > length)\n\t\t\tcount = length;\n\n\t\tthis.$mailer.$writeline(this.$mailerobj, chunk.slice(beg, count).toString('base64'));\n\t\tbeg = count;\n\t}\n}\n\nMailer.prototype.try = function(smtp, options, callback) {\n\treturn this.send(smtp, options, undefined, callback);\n};\n\nMailer.prototype.send2 = function(messages, callback) {\n\n\tvar opt = F.temporary.mail_settings;\n\n\tif (!opt) {\n\t\tvar config = CONF.mail_smtp_options;\n\t\tif (config) {\n\t\t\tif (typeof(config) === 'object')\n\t\t\t\topt = config;\n\t\t\telse\n\t\t\t\topt = config.toString().parseJSON();\n\t\t}\n\n\t\tif (!opt)\n\t\t\topt = {};\n\n\t\tF.temporary.mail_settings = opt;\n\t}\n\n\treturn this.send(CONF.mail_smtp, opt, messages, callback);\n};\n\nMailer.prototype.send = function(smtp, options, messages, callback) {\n\n\tif (options instanceof Array) {\n\t\tcallback = messages;\n\t\tmessages = options;\n\t\toptions = {};\n\t} else if (typeof(options) === 'function') {\n\t\tcallback = options;\n\t\toptions = {};\n\t}\n\n\tvar self = this;\n\tvar id = 'abcdefghijkl' + (INDEXSENDER++);\n\n\tself.connections[id] = {};\n\tvar obj = self.connections[id];\n\n\tobj.id = id;\n\tobj.try = messages === undefined;\n\tobj.messages = obj.try ? EMPTYARRAY : messages instanceof Array ? messages : [messages];\n\n\tF.stats.performance.mail += obj.messages.length;\n\n\tobj.callback = callback;\n\tobj.closed = false;\n\tobj.message = null;\n\tobj.files = null;\n\tobj.count = 0;\n\tobj.socket;\n\tobj.tls = false;\n\tobj.date = global.NOW ? global.NOW : new Date();\n\n\tsmtp = smtp || null;\n\n\tif (options && options.secure && !options.port)\n\t\toptions.port = 465;\n\n\toptions = framework_utils.copy(options, { secure: false, port: 25, user: '', password: '', timeout: 10000, tls: null });\n\n\tif (options.secure) {\n\t\tvar internal = framework_utils.copy(options);\n\t\tinternal.host = smtp;\n\t\tobj.socket = Tls.connect(internal, () => mailer.$send(obj, options));\n\t} else\n\t\tobj.socket = Net.createConnection(options.port, smtp);\n\n\tif (!smtp)  {\n\t\tvar err = new Error('No SMTP server configuration. Mail message won\\'t be sent.');\n\t\tcallback && callback(err);\n\t\tF.error(err, 'mail_smtp');\n\t\treturn self;\n\t}\n\n\tobj.smtpoptions = options;\n\tobj.socket.$host = smtp;\n\tobj.host = smtp.substring(smtp.lastIndexOf('.', smtp.lastIndexOf('.') - 1) + 1);\n\tobj.socket.on('error', function(err) {\n\t\tmailer.destroy(obj);\n\t\tvar is = obj.callback ? true : false;\n\t\tobj.callback && obj.callback(err);\n\t\tobj.callback = null;\n\t\tif (obj.try || err.stack.indexOf('ECONNRESET') !== -1)\n\t\t\treturn;\n\t\t!obj.try && !is && F.error(err, 'mail-smtp', smtp);\n\t\tmailer.$events.error && mailer.emit('error', err, obj);\n\t});\n\n\tobj.socket.on('clientError', function(err) {\n\t\tmailer.destroy(obj);\n\t\t!obj.try && !obj.callback && F.error(err, 'mail-smtp', smtp);\n\t\tobj.callback && obj.callback(err);\n\t\tobj.callback = null;\n\t\tmailer.$events.error && !obj.try && mailer.emit('error', err, obj);\n\t});\n\n\tobj.socket.setTimeout(options.timeout || 8000, function() {\n\t\tvar err = new Error(framework_utils.httpStatus(408));\n\t\tmailer.destroy(obj);\n\t\t!obj.try && !obj.callback && F.error(err, 'mail-smtp', smtp);\n\t\tobj.callback && obj.callback(err);\n\t\tobj.callback = null;\n\t\tmailer.$events.error && !obj.try && mailer.emit('error', err, obj);\n\t});\n\n\tobj.socket.on('connect', () => !options.secure && mailer.$send(obj, options));\n\treturn self;\n};\n\nMailer.prototype.$writemessage = function(obj, buffer) {\n\n\tvar self = this;\n\tvar msg = obj.messages.shift();\n\tvar message = [];\n\n\tF.stats.performance.mail++;\n\n\tif (global.F)\n\t\tglobal.F.stats.other.mail++;\n\n\tobj.boundary = '--totaljs' + obj.date.getTime() + obj.count;\n\tobj.files = msg.files;\n\tobj.count++;\n\n\tmessage.push('MIME-Version: 1.0');\n\tbuffer.push('MAIL FROM: <' + msg.addressFrom.address + '>');\n\tmessage.push('Message-ID: <total' + (INDEXATTACHMENT++) + '@WIN-t' + (INDEXATTACHMENT) + '>');\n\n\tself.$priority && message.push('X-Priority: ' + self.$priority);\n\tself.$confidential && message.push('Sensitivity: Company-Confidential');\n\n\tmessage.push('From: ' + (msg.addressFrom.name ? unicode_encode(msg.addressFrom.name) + ' <' + msg.addressFrom.address + '>' : msg.addressFrom.address));\n\n\tvar length;\n\n\tif (msg.headers) {\n\t\tvar headers = Object.keys(msg.headers);\n\t\tfor (var i = 0, length = headers.length; i < length; i++)\n\t\t\tmessage.push(headers[i] + ': ' + msg.headers[headers[i]]);\n\t}\n\n\tlength = msg.addressTo.length;\n\n\tvar builder = '';\n\tvar mail;\n\tvar item;\n\n\tif (length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\titem = msg.addressTo[i];\n\t\t\tif (item instanceof Object)\n\t\t\t\tmail = '<' + item.email + '>';\n\t\t\telse\n\t\t\t\tmail = '<' + item + '>';\n\t\t\tbuffer.push('RCPT TO: ' + mail);\n\t\t\tbuilder += (builder ? ', ' : '') + (item instanceof Object ? unicode_encode(item.name) + ' ' : '') + mail;\n\t\t}\n\t\tmessage.push('To: ' + builder);\n\t\tbuilder = '';\n\t}\n\n\tif (msg.addressCC) {\n\t\tlength = msg.addressCC.length;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\titem = msg.addressCC[i];\n\t\t\tif (item instanceof Object)\n\t\t\t\tmail = '<' + item.email  + '>';\n\t\t\telse\n\t\t\t\tmail = '<' + item + '>';\n\t\t\tbuffer.push('RCPT TO: ' + mail);\n\t\t\tbuilder += (builder ? ', ' : '') + (item instanceof Object ? unicode_encode(item.name) + ' ' : '') + mail;\n\t\t}\n\t\tmessage.push('Cc: ' + builder);\n\t\tbuilder = '';\n\t}\n\n\tif (msg.addressBCC) {\n\t\tlength = msg.addressBCC.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tbuffer.push('RCPT TO: <' + msg.addressBCC[i] + '>');\n\t}\n\n\t// if (msg.$preview)\n\t// \tmsg.body = msg.body.replace(REG_PREVIEW, '<body><div style=\"display:none;font-size:1px;color:#333333;line-height:1px;max-height:0px;max-width:0px;opacity:0;overflow:hidden\">' + (msg.language == null ? msg.$preview : F.translator(msg.language, msg.$preview)) + '</div>');\n\n\tbuffer.push('DATA');\n\tbuffer.push('');\n\n\tmessage.push('Date: ' + obj.date.toUTCString());\n\tmessage.push('Subject: ' + unicode_encode(msg.subject));\n\n\tif (msg.$unsubscribe) {\n\t\tmessage.push('List-Unsubscribe: ' + msg.$unsubscribe);\n\t\tmessage.push('List-Unsubscribe-Post: List-Unsubscribe=One-Click');\n\t}\n\n\tif (msg.addressReply) {\n\t\tlength = msg.addressReply.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tbuilder += (builder !== '' ? ', ' : '') + '<' + msg.addressReply[i] + '>';\n\t\tmessage.push('Reply-To: ' + builder);\n\t\tbuilder = '';\n\t}\n\n\tmessage.push('Content-Type: multipart/mixed; boundary=\"' + obj.boundary + '\"');\n\tmessage.push('');\n\n\tmessage.push('--' + obj.boundary);\n\tmessage.push('Content-Type: text/' + msg.type + '; charset=\"utf-8\"');\n\tmessage.push('Content-Transfer-Encoding: base64');\n\tmessage.push('');\n\tmessage.push(prepareBASE64(Buffer.from(msg.body.replace(REG_WINLINE, '\\n').replace(REG_NEWLINE, CRLF)).toString('base64')));\n\n\t// if (msg.type === 'html' && msg.$preview) {\n\t// \tmessage.push('--' + obj.boundary);\n\t// \tmessage.push('Content-Type: text/plain; charset=\"utf-8\"; format=\"fixed\"');\n\t// \tmessage.push('Content-Transfer-Encoding: base64');\n\t// \tmessage.push('');\n\t// \tmessage.push(prepareBASE64(Buffer.from(msg.$preview.replace(REG_WINLINE, '\\n').replace(REG_NEWLINE, CRLF)).toString('base64')));\n\t// }\n\n\tobj.message = message.join(CRLF);\n\tobj.messagecallback = msg.$callback;\n\tobj.instance = msg;\n\n\tmessage = null;\n\treturn self;\n};\n\nMailer.prototype.$writeline = function(obj) {\n\n\tif (obj.closed)\n\t\treturn false;\n\n\tvar socket = obj.socket2 ? obj.socket2 : obj.socket;\n\n\tfor (var i = 1; i < arguments.length; i++) {\n\t\tvar line = arguments[i];\n\t\tif (line) {\n\t\t\tmailer.debug && console.log('SEND', line);\n\t\t\tsocket.write(line + CRLF);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nMailer.prototype.$send = function(obj, options, autosend) {\n\n\tvar self = this;\n\tvar buffer = [];\n\tvar isAuthorized = false;\n\tvar isAuthorization = false;\n\tvar command = '';\n\tvar auth = [];\n\tvar socket = obj.socket2 ? obj.socket2 : obj.socket;\n\tvar host = obj.host;\n\tvar line = null;\n\tvar isAttach = !options.tls || (obj.tls && options.tls);\n\n\tisAttach && mailer.$events.send && mailer.emit('send', obj);\n\tsocket.setEncoding('utf8');\n\n\tsocket.on('end', function() {\n\t\tmailer.destroy(obj);\n\t\tobj.callback && obj.callback();\n\t\tobj.callback = null;\n\t\tline = null;\n\t});\n\n\tsocket.on('data', function(data) {\n\n\t\tif (obj.closed)\n\t\t\treturn;\n\n\t\twhile (true) {\n\n\t\t\tvar index = data.indexOf(BUF_CRLF);\n\t\t\tif (index === -1) {\n\t\t\t\tif (line) {\n\t\t\t\t\tCONCAT[0] = line;\n\t\t\t\t\tCONCAT[1] = data;\n\t\t\t\t\tline = Buffer.concat(CONCAT);\n\t\t\t\t} else\n\t\t\t\t\tline = data;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar tmp = data.slice(0, index).toString('utf8');\n\t\t\tdata = data.slice(index + BUF_CRLF.length);\n\t\t\ttmp && socket && socket.emit('line', tmp);\n\t\t}\n\t});\n\n\tsocket.on('line', function(line) {\n\n\t\tline = line.toUpperCase();\n\t\tmailer.debug && console.log('<---', line);\n\n\t\tvar code = +line.match(REG_STATE)[0];\n\n\t\tif (code === 250 && !isAuthorization) {\n\t\t\tif (REG_AUTH.test(line) && ((options.user && options.password) || options.xoauth2)) {\n\t\t\t\tisAuthorization = true;\n\t\t\t\tif (options.xoauth2 && line.indexOf('XOAUTH2') !== -1)\n\t\t\t\t\tauth.push('AUTH XOAUTH2 ' + options.xoauth2);\n\t\t\t\telse if (line.lastIndexOf('XOAUTH') === -1) {\n\t\t\t\t\tauth.push('AUTH LOGIN');\n\t\t\t\t\tauth.push(Buffer.from(options.user).toString('base64'));\n\t\t\t\t\tauth.push(Buffer.from(options.password).toString('base64'));\n\t\t\t\t} else\n\t\t\t\t\tauth.push('AUTH PLAIN ' + Buffer.from('\\0'+ options.user + '\\0' + options.password).toString('base64'));\n\t\t\t}\n\t\t}\n\n\t\t// help\n\t\tif (line.substring(3, 4) === '-')\n\t\t\treturn;\n\n\t\tif (!isAuthorized && isAuthorization) {\n\t\t\tisAuthorized = true;\n\t\t\tcode = 334;\n\t\t}\n\n\t\tswitch (code) {\n\t\t\tcase 220:\n\n\t\t\t\tif (obj.isTLS || REG_TLS.test(line)) {\n\t\t\t\t\tmailer.switchToTLS(obj, options);\n\t\t\t\t} else {\n\t\t\t\t\tobj.secured = REG_ESMTP.test(line);\n\t\t\t\t\tcommand = options.heloid ? options.heloid : (obj.isTLS || (options.user && options.password) || obj.secured ? 'EHLO' : 'HELO');\n\t\t\t\t\tmailer.$writeline(obj, command + ' ' + host);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\n\t\t\tcase 250: // OPERATION\n\t\t\tcase 251: // FORWARD\n\t\t\tcase 235: // VERIFY\n\t\t\tcase 999: // Total.js again\n\n\t\t\t\tif (obj.secured && !obj.isTLS && !obj.logged && obj.smtpoptions.user && obj.smtpoptions.password) {\n\t\t\t\t\t// maybe TLS\n\t\t\t\t\tobj.isTLS = true;\n\t\t\t\t\tmailer.$writeline(obj, 'STARTTLS');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tmailer.$writeline(obj, buffer.shift());\n\n\t\t\t\tif (buffer.length)\n\t\t\t\t\treturn;\n\n\t\t\t\t// NEW MESSAGE\n\t\t\t\tif (obj.messages.length) {\n\t\t\t\t\tmailer.$writemessage(obj, buffer);\n\t\t\t\t\tmailer.$writeline(obj, buffer.shift());\n\t\t\t\t} else {\n\t\t\t\t\t// end\n\t\t\t\t\tmailer.$writeline(obj, 'QUIT');\n\t\t\t\t}\n\n\t\t\t\treturn;\n\n\t\t\tcase 221: // BYE\n\t\t\t\tmailer.destroy(obj);\n\t\t\t\tobj.callback && obj.callback(null, obj.try ? true : obj.count);\n\t\t\t\tobj.callback = null;\n\t\t\t\treturn;\n\n\t\t\tcase 334: // LOGIN\n\n\t\t\t\tif (!self.tls && !obj.isTLS && options.tls) {\n\t\t\t\t\tobj.isTLS = true;\n\t\t\t\t\tmailer.$writeline(obj, 'STARTTLS');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar value = auth.shift();\n\t\t\t\tif (value) {\n\t\t\t\t\tobj.logged = true;\n\t\t\t\t\tmailer.$writeline(obj, value);\n\t\t\t\t} else {\n\t\t\t\t\tvar err = new Error('Forbidden.');\n\t\t\t\t\tmailer.destroy(obj);\n\t\t\t\t\tobj.callback && obj.callback(err);\n\t\t\t\t\tobj.callback = null;\n\t\t\t\t\tmailer.$events.error && !obj.try && mailer.emit('error', err, obj);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\n\t\t\tcase 354:\n\t\t\t\tmailer.$writeline(obj, obj.message);\n\t\t\t\tmailer.$writeattachment(obj);\n\t\t\t\tobj.message = null;\n\t\t\t\treturn;\n\n\t\t\tdefault:\n\n\t\t\t\tif (code < 400)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (!obj.isTLS && code === 530 && REG_STARTTLS.test(line)) {\n\t\t\t\t\tobj.isTLS = true;\n\t\t\t\t\tmailer.$writeline(obj, 'STARTTLS');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar err = new Error(line);\n\n\t\t\t\tmailer.$events.error && !obj.try && mailer.emit('error', err, obj);\n\t\t\t\tobj.messagecallback && obj.messagecallback(err, obj.instance);\n\t\t\t\tobj.messagecallback = null;\n\n\t\t\t\tif (obj.messages.length) {\n\t\t\t\t\t// a problem\n\t\t\t\t\tbuffer = [];\n\t\t\t\t\tobj.count--;\n\t\t\t\t\tsocket.emit('line', '999 TRY NEXT MESSAGE');\n\t\t\t\t} else {\n\t\t\t\t\tmailer.destroy(obj);\n\t\t\t\t\tobj.callback && obj.callback(err);\n\t\t\t\t\tobj.callback = null;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t}\n\t});\n\n\tautosend && self.$writeline(obj, 'EHLO ' + host);\n};\n\nMailer.prototype.restart = function() {\n\tvar self = this;\n\tself.removeAllListeners();\n\tself.debug = false;\n\tINDEXSENDER = 0;\n\tINDEXATTACHMENT = 0;\n};\n\n// Split Base64 to lines with 68 characters\nfunction prepareBASE64(value) {\n\n\tvar index = 0;\n\tvar output = '';\n\tvar length = value.length;\n\n\twhile (index < length) {\n\t\tvar max = index + 68;\n\t\tif (max > length)\n\t\t\tmax = length;\n\t\toutput += value.substring(index, max) + CRLF;\n\t\tindex = max;\n\t}\n\n\treturn output;\n}\n\nfunction unicode_encode(val) {\n\treturn val ? '=?utf-8?B?' + Buffer.from(val.toString()).toString('base64') + '?=' : '';\n}\n\n// ======================================================\n// EXPORTS\n// ======================================================\n\nvar mailer = new Mailer();\nmodule.exports = mailer;"
        },
        {
          "name": "merged",
          "type": "tree",
          "content": null
        },
        {
          "name": "nosql.js",
          "type": "blob",
          "size": 177.3291015625,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module NoSQL\n * @version 3.4.4\n */\n\n'use strict';\n\nconst Readable = require('stream').Readable;\nconst Fs = require('fs');\nconst Path = require('path');\nconst NoSQLStream = require('./nosqlstream');\nconst REG_FIELDS_CLEANER = /\"|`|\\||'|\\s/g;\n\nif (!global.framework_utils)\n\tglobal.framework_utils = require('./utils');\n\nif (!global.framework_image)\n\tglobal.framework_image = require('./image');\n\nif (!global.framework_nosql)\n\tglobal.framework_nosql = exports;\n\nif (!global.framework_builders)\n\tglobal.framework_builders = require('./builders');\n\nconst EXTENSION = '.nosql';\nconst EXTENSION_TABLE = '.table';\nconst EXTENSION_TABLE_BACKUP = '.table-backup';\nconst EXTENSION_BINARY = '.nosql-binary';\nconst EXTENSION_LOG = '.nosql-log';\nconst EXTENSION_MAPREDUCE = '.nosql-mapreduce';\nconst EXTENSION_BACKUP = '.nosql-backup';\nconst EXTENSION_META = '.meta';\nconst EXTENSION_COUNTER = '-counter2';\nconst BINARY_HEADER_LENGTH = 2000;\nconst COUNTER_MMA = [0, 0];\nconst DIRECTORYLENGTH = 9;\nconst FLAGS_READ = ['get'];\nconst INMEMORY = {};\nconst JSONBOOL = '\":true ';\nconst NEWLINE = '\\n';\nconst REGBOOL = /\":true/g; // for updates of boolean types\nconst REGCHINA = /[\\u3400-\\u9FBF]/;\nconst REGCLEAN = /^[\\s]+|[\\s]+$/g;\nconst REGTESCAPE = /\\||\\n|\\r/g;\nconst REGTUNESCAPE = /%7C|%0D|%0A/g;\nconst REGTESCAPETEST = /\\||\\n|\\r/;\nconst IMAGES = { gif: 1, jpg: 1, jpeg: 1, png: 1, svg: 1 };\nconst BINARYREADDATA = { start: BINARY_HEADER_LENGTH };\nconst BINARYREADDATABASE64 = { start: BINARY_HEADER_LENGTH, encoding: 'base64' };\nconst BINARYREADMETA = { start: 0, end: BINARY_HEADER_LENGTH - 1, encoding: 'binary' };\nconst BOOLEAN = { '1': 1, 'true': 1, 'on': 1 };\nconst TABLERECORD = { '+': 1, '-': 1, '*': 1 };\nconst CLUSTERMETA = {};\nconst UNKNOWN = 'unknown';\nconst MKDIR = { recursive: true };\n\nconst COMPARER = global.Intl ? global.Intl.Collator().compare : function(a, b) {\n\treturn a.removeDiacritics().localeCompare(b.removeDiacritics());\n};\n\nconst NEWLINEBUF = Buffer.from('\\n', 'utf8');\nconst CACHE = {};\n\nvar JSONBUFFER = process.argv.findIndex(n => n.endsWith('nosqlworker.js')) === -1 ? 20 : 40;\nvar FORK;\nvar FORKCALLBACKS;\n\nfunction clusterlock(db, method) {\n\tFs.open(db.filenameLock, 'wx', function(err, fd) {\n\n\t\tif (err) {\n\t\t\tsetTimeout(clusterlock, 100, db, method);\n\t\t\treturn;\n\t\t}\n\n\t\tFs.write(fd, F.id.toString(), function(err) {\n\t\t\terr && F.error('NoSQLStream.lock.write()', err);\n\t\t\tFs.close(fd, function(err) {\n\t\t\t\terr && F.error('NoSQLStream.lock.close()', err);\n\t\t\t\tdb.locked = true;\n\t\t\t\tdb[method]();\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction clusterunlock(db) {\n\tif (db.locked) {\n\t\tdb.locked = false;\n\t\tFs.unlink(db.filenameLock, NOOP);\n\t}\n}\n\nfunction promise(fn) {\n\tvar self = this;\n\treturn new Promise(function(resolve, reject) {\n\t\tself.callback(function(err, result) {\n\t\t\tif (err)\n\t\t\t\treject(err);\n\t\t\telse\n\t\t\t\tresolve(fn == null ? result : fn(result));\n\t\t});\n\t});\n}\n\nexports.kill = function(signal) {\n\tFORK && TRY(() => FORK && FORK.kill && FORK.kill(signal || 'SIGTERM'));\n};\n\nexports.pid = function() {\n\treturn FORK ? FORK.pid : 0;\n};\n\nexports.worker = function() {\n\n\tif (FORK || F.isCluster)\n\t\treturn;\n\n\t// Clears unhandled callbacks\n\tON('service', function() {\n\n\t\tvar keys = Object.keys(FORKCALLBACKS);\n\t\tif (!keys.length)\n\t\t\treturn;\n\n\t\tvar time = Date.now();\n\n\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tvar item = FORKCALLBACKS[key];\n\t\t\tif (item && item.time) {\n\t\t\t\tvar diff = time - item.time;\n\t\t\t\tif (diff >= 60000) {\n\t\t\t\t\tdelete FORKCALLBACKS[key];\n\t\t\t\t\tvar err = new Error('NoSQL worker timeout.');\n\t\t\t\t\tswitch (item.type) {\n\t\t\t\t\t\tcase 'find':\n\t\t\t\t\t\t\titem.builder && item.builder.$callback2(err, EMPTYARRAY, 0, EMPTYOBJECT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'count':\n\t\t\t\t\t\t\titem.builder && item.builder.$callback2(err, EMPTYOBJECT, 0, EMPTYOBJECT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'insert':\n\t\t\t\t\t\tcase 'update':\n\t\t\t\t\t\tcase 'remove':\n\t\t\t\t\t\t\titem.builder && item.builder.$callback && item.builder.$callback(err, EMPTYOBJECT, EMPTYOBJECT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'clean':\n\t\t\t\t\t\tcase 'clear':\n\t\t\t\t\t\t\titem.callback && item.callback(err);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'stream':\n\t\t\t\t\t\t\titem.callback && item.callback(err, EMPTYOBJECT, 0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\titem.callback && item.callback(err, EMPTYOBJECT, EMPTYOBJECT);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tFORKCALLBACKS = {};\n\tFORK = require('child_process').fork(module.filename.replace(/\\.js$/, '') + 'worker.js', [], { cwd: F.directory });\n\tFORK.send({ TYPE: 'init', directory: F.path.root() });\n\tFORK.on('message', function(msg) {\n\t\tswitch (msg.TYPE) {\n\t\t\tcase 'find':\n\t\t\t\tvar obj = FORKCALLBACKS[msg.id];\n\t\t\t\tobj && obj.builder.$callback2(msg.err, msg.response, msg.count, msg.repository);\n\t\t\t\tbreak;\n\t\t\tcase 'count':\n\t\t\t\tvar obj = FORKCALLBACKS[msg.id];\n\t\t\t\tobj && obj.builder.$callback2(msg.err, msg.response, msg.count, msg.repository);\n\t\t\t\tbreak;\n\t\t\tcase 'insert':\n\t\t\t\tvar obj = FORKCALLBACKS[msg.id];\n\t\t\t\tobj && obj.builder.$callback && obj.builder.$callback(msg.err, msg.response, msg.repository);\n\t\t\t\tbreak;\n\t\t\tcase 'update':\n\t\t\t\tvar obj = FORKCALLBACKS[msg.id];\n\t\t\t\tobj && obj.builder.$callback && obj.builder.$callback(msg.err, msg.response, msg.repository);\n\t\t\t\tbreak;\n\t\t\tcase 'remove':\n\t\t\t\tvar obj = FORKCALLBACKS[msg.id];\n\t\t\t\tobj && obj.builder.$callback && obj.builder.$callback(msg.err, msg.response, msg.repository);\n\t\t\t\tbreak;\n\t\t\tcase 'backup':\n\t\t\tcase 'restore':\n\t\t\tcase 'counter.read':\n\t\t\tcase 'counter.stats':\n\t\t\tcase 'counter.clear':\n\t\t\tcase 'storage.stats':\n\t\t\tcase 'storage.clear':\n\t\t\t\tvar obj = FORKCALLBACKS[msg.id];\n\t\t\t\tobj && obj.callback && obj.callback(msg.err, msg.response);\n\t\t\t\tbreak;\n\t\t\tcase 'stream':\n\t\t\t\tvar obj = FORKCALLBACKS[msg.id];\n\t\t\t\tobj && obj.callback && obj.callback(msg.err, msg.repository || {}, msg.count);\n\t\t\t\tbreak;\n\t\t\tcase 'storage.scan':\n\t\t\t\tvar obj = FORKCALLBACKS[msg.id];\n\t\t\t\tobj && obj.callback && obj.callback(msg.err, msg.response, msg.repository);\n\t\t\t\tbreak;\n\t\t\tcase 'callback':\n\t\t\t\tvar obj = FORKCALLBACKS[msg.id];\n\t\t\t\tobj && obj.callback && obj.callback(msg.err);\n\t\t\t\tbreak;\n\n\t\t}\n\t\tdelete FORKCALLBACKS[msg.id];\n\t});\n\n\tvar CMD = {};\n\n\tfunction send(instance, type) {\n\t\tvar obj = {};\n\t\tobj.type = type;\n\t\tobj.name = instance.name;\n\t\tobj.time = Date.now();\n\t\tobj.t = instance instanceof Table;\n\n\t\tif (arguments.length > 2) {\n\t\t\tobj.arg = [];\n\t\t\tfor (var i = 2; i < arguments.length; i++)\n\t\t\t\tobj.arg.push(arguments[i]);\n\t\t}\n\t\tsetImmediate(send2, obj);\n\t\treturn obj;\n\t}\n\n\tfunction notify(instance, type) {\n\t\tvar obj = {};\n\t\tobj.type = type;\n\t\tobj.name = instance.name;\n\t\tobj.time = Date.now();\n\t\tobj.t = instance instanceof Table;\n\n\t\tif (arguments.length > 2) {\n\t\t\tobj.arg = [];\n\t\t\tfor (var i = 2; i < arguments.length; i++)\n\t\t\t\tobj.arg.push(arguments[i]);\n\t\t}\n\t\tsetImmediate(send2, obj, false);\n\t\treturn obj;\n\t}\n\n\tfunction send2(obj, callback) {\n\t\tCMD.TYPE = obj.type;\n\t\tCMD.arg = obj.arg;\n\t\tCMD.data = obj.builder ? obj.builder.stringify() : null;\n\t\tCMD.name = obj.name;\n\t\tCMD.t = obj.t;\n\t\tif (callback !== false) {\n\t\t\tCMD.id = Math.random().toString(32).substring(2);\n\t\t\tFORKCALLBACKS[CMD.id] = obj;\n\t\t}\n\t\tFORK.send(CMD);\n\t}\n\n\tvar DP = Database.prototype;\n\tvar CP = Counter.prototype;\n\tvar SP = Storage.prototype;\n\n\tTP.once = TP.on = TP.emit = TP.removeListener = TP.removeAllListeners = DP.once = DP.on = DP.emit = DP.removeListener = DP.removeAllListeners = CP.on = CP.once = CP.emit = CP.removeListener = CP.removeAllListeners = function() {\n\t\tPRINTLN('ERROR --> NoSQL events are not supported in fork mode.');\n\t};\n\n\tTP.listing = TP.list = DP.listing = DP.list = function(builder) {\n\t\tif (builder instanceof DatabaseBuilder)\n\t\t\tbuilder.db = this;\n\t\telse\n\t\t\tbuilder = new DatabaseBuilder(this);\n\t\tbuilder.$options.listing = true;\n\t\tbuilder.$take = builder.$options.take = 100;\n\t\treturn send(this, 'find').builder = builder;\n\t};\n\n\tTP.find = DP.find = function(builder) {\n\t\tif (builder instanceof DatabaseBuilder)\n\t\t\tbuilder.db = this;\n\t\telse\n\t\t\tbuilder = new DatabaseBuilder(this);\n\t\treturn send(this, 'find').builder = builder;\n\t};\n\n\tTP.find2 = DP.find2 = function(builder) {\n\t\tif (builder instanceof DatabaseBuilder)\n\t\t\tbuilder.db = this;\n\t\telse\n\t\t\tbuilder = new DatabaseBuilder(this);\n\t\treturn send(this, 'find2').builder = builder;\n\t};\n\n\tTP.top = DP.top = function(max) {\n\t\tvar builder = new DatabaseBuilder(this);\n\t\tbuilder.take(max);\n\t\treturn send(this, 'find').builder = builder;\n\t};\n\n\tTP.one = DP.one = function() {\n\t\tvar builder = new DatabaseBuilder(this);\n\t\tbuilder.first();\n\t\treturn send(this, 'one').builder = builder;\n\t};\n\n\tTP.insert = DP.insert = function(doc, unique) {\n\n\t\tvar self = this;\n\t\tvar builder;\n\n\t\tif (doc.$$schema)\n\t\t\tdoc = doc.$clean();\n\n\t\tif (unique) {\n\t\t\tbuilder = self.one();\n\n\t\t\tvar callback;\n\n\t\t\tbuilder.callback(function(err, d) {\n\t\t\t\tif (d)\n\t\t\t\t\tcallback && callback(null, 0);\n\t\t\t\telse {\n\t\t\t\t\tvar tmp = self.insert(doc);\n\t\t\t\t\ttmp.callback(callback);\n\t\t\t\t\ttmp.$options.log = builder.$options.log;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tbuilder.callback = function(fn) {\n\t\t\t\tcallback = fn;\n\t\t\t\treturn builder;\n\t\t\t};\n\n\t\t\treturn builder;\n\t\t}\n\n\t\treturn send(self, 'insert', doc).builder = new DatabaseBuilder2(self);\n\t};\n\n\tTP.count = DP.count = function() {\n\t\tvar builder = new DatabaseBuilder(this);\n\t\treturn send(this, 'count').builder = builder;\n\t};\n\n\tDP.view = function() {\n\t\tthrow new Error('NoSQL Views are not supported.');\n\t};\n\n\tTP.update = DP.update = function(doc, insert) {\n\t\tvar val = doc.$$schema ? doc.$clean() : doc;\n\t\tif (typeof(val) === 'function')\n\t\t\tval = val.toString();\n\t\treturn send(this, 'update', val, insert).builder = new DatabaseBuilder(this);\n\t};\n\n\tTP.modify = DP.modify = function(doc, insert) {\n\t\tvar val = doc.$$schema ? doc.$clean() : doc;\n\t\tif (typeof(val) === 'function')\n\t\t\tval = val.toString();\n\t\treturn send(this, 'modify', val, insert).builder = new DatabaseBuilder(this);\n\t};\n\n\tDP.restore = function(filename, callback) {\n\t\tvar obj = send(this, 'restore', filename);\n\t\tobj.callback = callback;\n\t\treturn this;\n\t};\n\n\tDP.backup = function(filename, callback) {\n\t\tvar obj = send(this, 'backup', filename);\n\t\tobj.callback = callback;\n\t\treturn this;\n\t};\n\n\tDP.refresh = function() {\n\t\treturn this;\n\t};\n\n\tDP.drop = function() {\n\t\tnotify(this, 'drop');\n\t\treturn this;\n\t};\n\n\tTP.clear = DP.clear = function(callback) {\n\t\tsend(this, 'clear').callback = callback;\n\t\treturn this;\n\t};\n\n\tTP.clean = DP.clean = function(callback) {\n\t\tsend(this, 'clean').callback = callback;\n\t\treturn this;\n\t};\n\n\tTP.ready = DP.ready = function(callback) {\n\t\tcallback && callback();\n\t\treturn this;\n\t};\n\n\tTP.remove = DP.remove = function(filename) {\n\t\treturn send(this, 'remove', filename).builder = new DatabaseBuilder(this);\n\t};\n\n\tTP.stream = DP.stream = function(fn, repository, callback) {\n\n\t\tif (typeof(repository) === 'function')  {\n\t\t\tcallback = repository;\n\t\t\trepository = undefined;\n\t\t}\n\n\t\tsend(this, 'stream', fn.toString(), repository).callback = callback;\n\t\treturn this;\n\t};\n\n\tCP.min = function(id, count) {\n\t\tnotify(this.db, 'counter.min', id, count);\n\t\treturn this;\n\t};\n\n\tCP.max = function(id, count) {\n\t\tnotify(this.db, 'counter.max', id, count);\n\t\treturn this;\n\t};\n\n\tCP.sum = CP.inc = CP.hit = function(id, count) {\n\t\tnotify(this.db, 'counter.hit', id, count);\n\t\treturn this;\n\t};\n\n\tCP.remove = function(id) {\n\t\tnotify(this.db, 'counter.remove', id);\n\t\treturn this;\n\t};\n\n\tCP.read = function(options, callback) {\n\t\tsend(this.db, 'counter.read', options).callback = callback;\n\t\treturn this;\n\t};\n\n\tCP.stats = CP.stats_sum = function(top, year, month, day, type, callback) {\n\n\t\tif (typeof(day) == 'function') {\n\t\t\tcallback = day;\n\t\t\tday = null;\n\t\t} else if (typeof(month) == 'function') {\n\t\t\tcallback = month;\n\t\t\tmonth = null;\n\t\t} else if (typeof(year) === 'function') {\n\t\t\tcallback = year;\n\t\t\tyear = month = null;\n\t\t}\n\n\t\tsend(this.db, 'counter.stats', top, year, month, day, type).callback = callback;\n\t\treturn this;\n\t};\n\n\tCP.clear = function(callback) {\n\t\tsend(this.db, 'counter.clear').callback = callback;\n\t\treturn this;\n\t};\n\n\tSP.insert = function(doc) {\n\t\tnotify(this.db, 'storage.insert', doc.$$schema ? doc.$clean() : doc);\n\t\treturn this;\n\t};\n\n\tSP.scan = function(beg, end, mapreduce, callback) {\n\n\t\tif (typeof(beg) === 'function') {\n\t\t\tmapreduce = beg;\n\t\t\tcallback = end;\n\t\t\tbeg = null;\n\t\t\tend = null;\n\t\t} else if (typeof(end) === 'function') {\n\t\t\tcallback = mapreduce;\n\t\t\tmapreduce = end;\n\t\t\tend = null;\n\t\t}\n\n\t\tsend(this.db, 'storage.scan', beg, end, mapreduce.toString()).callback = callback;\n\t\treturn this;\n\t};\n\n\tSP.mapreduce = function(name, fn) {\n\t\tsend(this.db, 'storage.mapreduce', name, fn);\n\t\treturn this;\n\t};\n\n\tSP.stats = function(name, callback) {\n\n\t\tif (typeof(name) === 'function') {\n\t\t\tcallback = name;\n\t\t\tname = undefined;\n\t\t}\n\n\t\tsend(this.db, 'storage.stats', name).callback = callback;\n\t\treturn this;\n\t};\n\n\tSP.clear = function(beg, end, callback) {\n\n\t\tif (typeof(beg) === 'function') {\n\t\t\tcallback = end;\n\t\t\tbeg = null;\n\t\t\tend = null;\n\t\t} else if (typeof(end) === 'function') {\n\t\t\tcallback = end;\n\t\t\tend = null;\n\t\t}\n\n\t\tsend(this.db, 'storage.clear', beg, end).callback = callback;\n\t\treturn this;\n\t};\n};\n\nfunction Table(name, filename, readonly, specific) {\n\tvar t = this;\n\tt.filename = readonly ? filename : filename + (specific ? '' : EXTENSION_TABLE);\n\tt.filenameBackup = readonly ? '' : filename + EXTENSION_TABLE_BACKUP;\n\tt.filenameCounter = readonly ? '' : filename + (specific ? '' : EXTENSION_TABLE) + EXTENSION_COUNTER;\n\tt.filenameMeta = readonly ? '' : filename + (specific ? '' : EXTENSION_TABLE) + '-meta';\n\tt.directory = Path.dirname(filename);\n\tt.filenameLock = t.filename + '-lock';\n\tt.name = name;\n\tt.$name = '$' + name;\n\tt.pending_reader = [];\n\tt.pending_reader2 = [];\n\tt.pending_update = [];\n\tt.pending_append = [];\n\tt.pending_reader = [];\n\tt.pending_remove = [];\n\tt.pending_streamer = [];\n\tt.pending_clean = [];\n\tt.pending_clear = [];\n\tt.pending_locks = [];\n\tt.$events = {};\n\n\tt.step = 0;\n\tt.ready = false;\n\tt.$free = true;\n\tt.$writting = false;\n\tt.$reading = false;\n\tt.$allocations = true;\n\n\tt.counter = readonly ? null : new Counter(t);\n\tt.$meta();\n\n\tvar schema = CONF['table_' + name] || CONF['table.' + name];\n\n\tFs.createReadStream(t.filename, { end: 1200 }).once('data', function(chunk) {\n\n\t\tif (schema) {\n\t\t\tt.parseSchema(schema.replace(/;|,/g, '|').trim().split('|'));\n\t\t\tschema = t.stringifySchema();\n\t\t}\n\n\t\tt.parseSchema(chunk.toString('utf8').split('\\n', 1)[0].split('|'));\n\t\tt.ready = true;\n\n\t\tif (schema && t.stringifySchema() !== schema) {\n\t\t\tt.$header = Buffer.byteLength(t.stringifySchema()) + 1;\n\t\t\tt.extend(schema);\n\t\t} else\n\t\t\tt.$header = Buffer.byteLength(schema ? schema : t.stringifySchema()) + 1;\n\n\t\tt.next(0);\n\n\t}).on('error', function(e) {\n\t\tif (schema) {\n\t\t\tt.parseSchema(schema.replace(/;|,/g, '|').trim().split('|'));\n\t\t\tvar bschema = t.stringifySchema();\n\t\t\tt.$header = Buffer.byteLength(bschema) + 1;\n\t\t\tFs.writeFileSync(t.filename, bschema + NEWLINE, 'utf8');\n\t\t\tt.ready = true;\n\t\t\tt.next(0);\n\t\t} else {\n\t\t\tt.readonly = true;\n\t\t\tt.pending_reader.length && (t.pending_reader = []);\n\t\t\tt.pending_update.length && (t.pending_update = []);\n\t\t\tt.pending_append.length && (t.pending_append = []);\n\t\t\tt.pending_reader.length && (t.pending_reader = []);\n\t\t\tt.pending_remove.length && (t.pending_remove = []);\n\t\t\tt.pending_streamer.length && (t.pending_streamer = []);\n\t\t\tt.pending_locks.length && (t.pending_locks = []);\n\t\t\tt.pending_clean.length && (t.pending_clean = []);\n\t\t\tt.pending_clear.length && (t.pending_clear = []);\n\t\t\tt.throwReadonly(e);\n\t\t}\n\t});\n}\n\nfunction Database(name, filename, readonly, specific) {\n\n\tvar self = this;\n\tvar http = filename.substring(0, 6);\n\tself.readonly = http === 'http:/' || http === 'https:';\n\tself.filename = self.readonly ? filename.format('') : readonly ? filename : filename + (specific ? '' : EXTENSION);\n\tself.directory = Path.dirname(filename);\n\n\tif (!readonly) {\n\t\tself.filenameLock = self.filename + '-lock';\n\t\tself.filenameCounter = self.readonly ? filename.format('counter', '-') : filename + (specific ? '' : EXTENSION) + EXTENSION_COUNTER;\n\t\tself.filenameLog = self.readonly || readonly ? '' : filename + EXTENSION_LOG;\n\t\tself.filenameBackup = self.readonly || readonly ? '' : filename + EXTENSION_BACKUP;\n\t\tself.filenameStorage = self.readonly || readonly ? '' : filename + '-storage/{0}' + (specific ? '' : EXTENSION);\n\t\tself.filenameMeta = filename + EXTENSION_META;\n\t\tself.filenameBackup2 = framework_utils.join(self.directory, name + '_backup' + (specific ? '' : EXTENSION));\n\t\tself.inmemory = {};\n\t\tself.inmemorylastusage;\n\t\t// self.metadata;\n\t\tself.$meta();\n\t}\n\n\tself.name = name;\n\tself.pending_update = [];\n\tself.pending_append = [];\n\tself.pending_reader = [];\n\tself.pending_remove = [];\n\tself.pending_reader2 = [];\n\tself.pending_streamer = [];\n\tself.pending_clean = [];\n\tself.pending_clear = [];\n\tself.pending_locks = [];\n\tself.step = 0;\n\tself.pending_drops = false;\n\tself.pending_reindex = false;\n\tself.binary = self.readonly || readonly ? null : new Binary(self, self.directory + '/' + self.name + '-binary/');\n\tself.storage = self.readonly || readonly ? null : new Storage(self, self.directory + '/' + self.name + '-storage/');\n\tself.counter = readonly ? null : new Counter(self);\n\tself.$timeoutmeta;\n\tself.$events = {};\n\tself.$free = true;\n\tself.$writting = false;\n\tself.$reading = false;\n}\n\nconst TP = Table.prototype;\nconst DP = Database.prototype;\n\nTP.memory = DP.memory = function(count, size) {\n\tvar self = this;\n\tcount && (self.buffercount = count + 1);      // def: 15 - count of stored documents in memory while reading/writing\n\tsize && (self.buffersize = size * 1024);      // def: 32 - size of buffer in kB\n\treturn self;\n};\n\nTP.view = DP.view = function() {\n\tthrow new Error('NoSQL Views are not supported in this version.');\n};\n\nTP.emit = DP.emit = function(name, a, b, c, d, e, f, g) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nTP.on = DP.on = function(name, fn) {\n\n\tif (!fn.$once)\n\t\tthis.$free = false;\n\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nTP.once = DP.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nTP.removeListener = DP.removeListener = function(name, fn) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tthis.$events[name] = evt;\n\t\telse\n\t\t\tthis.$events[name] = undefined;\n\t}\n\treturn this;\n};\n\nTP.removeAllListeners = DP.removeAllListeners = function(name) {\n\tif (name === true)\n\t\tthis.$events = EMPTYOBJECT;\n\telse if (name)\n\t\tthis.$events[name] = undefined;\n\telse\n\t\tthis.$events[name] = {};\n\treturn this;\n};\n\nexports.Database = Database;\nexports.DatabaseBuilder = DatabaseBuilder;\nexports.DatabaseBuilder2 = DatabaseBuilder2;\nexports.DatabaseCounter = Counter;\nexports.DatabaseBinary = Binary;\nexports.DatabaseStorage = Storage;\nexports.DatabaseTable = Table;\n\nexports.load = function(name, filename, specific) {\n\treturn new Database(name, filename, undefined, specific);\n};\n\nexports.table = function(name, filename, specific) {\n\treturn new Table(name, filename, undefined, specific);\n};\n\nexports.memory = exports.inmemory = function(name) {\n\treturn INMEMORY[name] = true;\n};\n\nTP.get = DP.get = function(name) {\n\treturn this.meta(name);\n};\n\nTP.set = DP.set = function(name, value) {\n\treturn this.meta(name, value);\n};\n\nTP.meta = DP.meta = function(name, value, nosave) {\n\tvar self = this;\n\n\tif (value === undefined)\n\t\treturn self.metadata ? self.metadata[name] : undefined;\n\n\tif (!self.metadata)\n\t\tself.metadata = {};\n\n\tself.metadata[name] = value;\n\tclearTimeout(self.timeoutmeta);\n\n\tif (!nosave)\n\t\tself.timeoutmeta = setTimeout(() => self.$meta(true), 500);\n\n\tif (F.isCluster && !nosave) {\n\t\tCLUSTERMETA.ID = F.id;\n\t\tCLUSTERMETA.TYPE = (self instanceof Table ? 'table' : 'nosql') + '-meta';\n\t\tCLUSTERMETA.name = self.name;\n\t\tCLUSTERMETA.key = name;\n\t\tCLUSTERMETA.value = value;\n\t\tprocess.send(CLUSTERMETA);\n\t}\n\n\treturn self;\n};\n\nTP.backups = DP.backups = function(filter, callback) {\n\n\tif (callback === undefined) {\n\t\tcallback = filter;\n\t\tfilter = null;\n\t}\n\n\tvar self = this;\n\tvar isTable = self instanceof Table;\n\n\tif (isTable && !self.ready) {\n\t\tsetTimeout((self, filter, callback) => self.backups(filter, callback), 500, self, filter, callback);\n\t\treturn self;\n\t}\n\n\tvar stream = Fs.createReadStream(self.filenameBackup);\n\tvar output = [];\n\tvar tmp = {};\n\n\ttmp.keys = self.$keys;\n\n\tstream.on('data', U.streamer(NEWLINEBUF, function(item, index) {\n\t\tvar end = item.indexOf('|', item.indexOf('|') + 2);\n\t\tvar meta = item.substring(0, end);\n\t\tvar arr = meta.split('|');\n\t\tvar dv = arr[0].trim().replace(' ', 'T') + ':00.000Z';\n\t\ttmp.line = item.substring(end + 1).trim();\n\t\tif (isTable)\n\t\t\ttmp.line = tmp.line.split('|');\n\t\tvar obj = { id: index + 1, date: dv.parseDate(), user: arr[1].trim(), data: self instanceof Table ? self.parseData(tmp) : tmp.line.parseJSON(true) };\n\t\tif (!filter || filter(obj))\n\t\t\toutput.push(obj);\n\t}), stream);\n\n\tCLEANUP(stream, () => callback(null, output));\n\n\treturn self;\n};\n\nfunction next_operation(self, type) {\n\tself.next(type);\n}\n\nDP.ready = function(fn) {\n\tvar self = this;\n\tfn.call(self);\n\treturn self;\n};\n\nDP.insert = function(doc, unique) {\n\n\tvar self = this;\n\tvar builder;\n\n\tself.readonly && self.throwReadonly();\n\n\tif (unique) {\n\t\tbuilder = self.one();\n\t\tvar callback;\n\n\t\tbuilder.callback(function(err, d) {\n\t\t\tif (d)\n\t\t\t\tcallback && callback(null, 0);\n\t\t\telse\n\t\t\t\tself.insert(doc).callback(callback);\n\t\t});\n\n\t\tbuilder.callback = function(fn) {\n\t\t\tcallback = fn;\n\t\t\treturn builder;\n\t\t};\n\n\t\treturn builder;\n\t}\n\n\tbuilder = new DatabaseBuilder2(self);\n\tvar json = doc.$$schema ? doc.$clean() : doc;\n\tself.pending_append.push({ doc: JSON.stringify(json).replace(REGBOOL, JSONBOOL), raw: doc, builder: builder });\n\tsetImmediate(next_operation, self, 1);\n\tself.$events.insert && self.emit('insert', json);\n\treturn builder;\n};\n\nDP.upsert = function(doc) {\n\treturn this.insert(doc, true);\n};\n\nDP.update = function(doc, insert) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tvar data = doc.$$schema ? doc.$clean() : doc;\n\tbuilder.$options.readertype = 1;\n\tif (typeof(data) === 'string')\n\t\tdata = new Function('doc', 'repository', 'arg', data.indexOf('return ') === -1 ? ('return (' + data + ')') : data);\n\tself.pending_update.push({ builder: builder, doc: data, insert: insert === true ? data : insert });\n\tsetImmediate(next_operation, self, 2);\n\treturn builder;\n};\n\nDP.modify = function(doc, insert) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tvar data = doc.$$schema ? doc.$clean() : doc;\n\tvar keys = Object.keys(data);\n\tvar inc = null;\n\n\tbuilder.$options.readertype = 1;\n\n\tif (keys.length) {\n\t\tvar tmp;\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tswitch (key[0]) {\n\t\t\t\tcase '!':\n\t\t\t\tcase '+':\n\t\t\t\tcase '-':\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\t\t!inc && (inc = {});\n\t\t\t\t\ttmp = key.substring(1);\n\t\t\t\t\tinc[tmp] = key[0];\n\t\t\t\t\tdoc[tmp] = doc[key];\n\t\t\t\t\tdoc[key] = undefined;\n\t\t\t\t\tkeys[i] = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$':\n\t\t\t\t\ttmp = key.substring(1);\n\t\t\t\t\tdoc[tmp] = new Function('val', 'doc', 'repository', 'arg', doc[key].indexOf('return ') === -1 ? ('return (' + doc[key] + ')') : doc[key]);\n\t\t\t\t\tdoc[key] = undefined;\n\t\t\t\t\tkeys[i] = tmp;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tself.pending_update.push({ builder: builder, doc: data, keys: keys, inc: inc, insert: insert === true ? data : insert });\n\t\tsetImmediate(next_operation, self, 2);\n\t}\n\n\treturn builder;\n};\n\nDP.restore = function(filename, callback) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tU.wait(() => !self.type, function(err) {\n\n\t\tif (err)\n\t\t\tthrow new Error('Database can\\'t be restored because it\\'s busy.');\n\n\t\tself.type = 9;\n\n\t\tF.restore(filename, F.path.root(), function(err, response) {\n\t\t\tself.type = 0;\n\t\t\tif (!err) {\n\t\t\t\tself.$meta();\n\t\t\t\tself.binary.$refresh();\n\t\t\t\tself.refresh();\n\t\t\t\tself.storage && self.storage.refresh();\n\t\t\t}\n\t\t\tself.$events.change && self.emit('change', 'restore');\n\t\t\tcallback && callback(err, response);\n\t\t});\n\n\t});\n\treturn self;\n};\n\nDP.backup = function(filename, callback) {\n\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\n\tvar list = [];\n\tvar pending = [];\n\n\tpending.push(function(next) {\n\t\tF.path.exists(self.filename, function(e) {\n\t\t\te && list.push(Path.join(CONF.directory_databases, self.name + EXTENSION));\n\t\t\tnext();\n\t\t});\n\t});\n\n\tpending.push(function(next) {\n\t\tF.path.exists(F.path.databases(self.name + EXTENSION_META), function(e) {\n\t\t\te && list.push(Path.join(CONF.directory_databases, self.name + EXTENSION_META));\n\t\t\tnext();\n\t\t});\n\t});\n\n\tpending.push(function(next) {\n\t\tF.path.exists(self.filenameBackup, function(e) {\n\t\t\te && list.push(Path.join(CONF.directory_databases, self.name + EXTENSION_BACKUP));\n\t\t\tnext();\n\t\t});\n\t});\n\n\tpending.push(function(next) {\n\t\tF.path.exists(self.filenameCounter, function(e) {\n\t\t\te && list.push(Path.join(CONF.directory_databases, self.name + EXTENSION + EXTENSION_COUNTER));\n\t\t\tnext();\n\t\t});\n\t});\n\n\tpending.push(function(next) {\n\t\tF.path.exists(self.filenameLog, function(e) {\n\t\t\te && list.push(Path.join(CONF.directory_databases, self.name + EXTENSION_LOG));\n\t\t\tnext();\n\t\t});\n\t});\n\n\tpending.push(function(next) {\n\t\tF.path.exists(F.path.databases(self.name + '-binary'), function(e, size, file) {\n\t\t\te && !file && list.push(Path.join(CONF.directory_databases, self.name + '-binary'));\n\t\t\tnext();\n\t\t});\n\t});\n\n\tpending.push(function(next) {\n\t\tF.path.exists(F.path.databases(self.name + '-storage'), function(e, size, file) {\n\t\t\te && !file && list.push(Path.join(CONF.directory_databases, self.name + '-storage'));\n\t\t\tnext();\n\t\t});\n\t});\n\n\tpending.push(function(next) {\n\t\tvar filename = Path.join(CONF.directory_databases, self.name + EXTENSION_MAPREDUCE);\n\t\tF.path.exists(F.path.root(filename), function(e) {\n\t\t\te && list.push(filename);\n\t\t\tnext();\n\t\t});\n\t});\n\n\tpending.async(function() {\n\t\tif (list.length)\n\t\t\tF.backup(filename, list, callback);\n\t\telse\n\t\t\tcallback(new Error('No files for backuping.'));\n\t});\n\n\treturn self;\n};\n\nDP.backup2 = function(filename, remove) {\n\n\tif (typeof(filename) === 'boolean') {\n\t\tremove = filename;\n\t\tfilename = '';\n\t}\n\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\n\tif (remove)\n\t\treturn self.remove(filename || '');\n\n\tvar builder = new DatabaseBuilder2(self);\n\tvar stream = Fs.createReadStream(self.filename);\n\n\tstream.pipe(Fs.createWriteStream(filename || self.filenameBackup2));\n\n\tstream.on('error', function(err) {\n\t\tbuilder.$options.log && builder.log();\n\t\tbuilder.$callback && builder.$callback(errorhandling(err, builder));\n\t\tbuilder.$callback = null;\n\t});\n\n\tstream.on('end', function() {\n\t\tbuilder.$options.log && builder.log();\n\t\tbuilder.$callback && builder.$callback(errorhandling(null, builder, true), true);\n\t\tbuilder.$callback = null;\n\t});\n\n\treturn builder;\n};\n\nDP.drop = function() {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tself.pending_drops = true;\n\tsetImmediate(next_operation, self, 7);\n\treturn self;\n};\n\nDP.free = function(force) {\n\tvar self = this;\n\tif (!force && !self.$free)\n\t\treturn self;\n\tself.counter.removeAllListeners(true);\n\tself.binary.removeAllListeners(true);\n\tself.removeAllListeners(true);\n\tself.binary = null;\n\tself.counter = null;\n\tdelete F.databases[self.name];\n\treturn self;\n};\n\nDP.release = function() {\n\tvar self = this;\n\tself.inmemory = {};\n\tself.inmemorylastusage = undefined;\n\treturn self;\n};\n\nTP.clear = DP.clear = function(callback) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tself.pending_clear.push(callback || NOOP);\n\tsetImmediate(next_operation, self, 12);\n\treturn self;\n};\n\nTP.clean = DP.clean = function(callback) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tself.pending_clean.push(callback || NOOP);\n\tsetImmediate(next_operation, self, 13);\n\treturn self;\n};\n\nTP.lock = DP.lock = function(callback) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tself.pending_locks.push(callback || NOOP);\n\tsetImmediate(next_operation, self, 14);\n\treturn self;\n};\n\nDP.remove = function() {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tself.pending_remove.push(builder);\n\tbuilder.$options.readertype = 1;\n\tsetImmediate(next_operation, self, 3);\n\treturn builder;\n};\n\nDP.listing = DP.list = function(builder) {\n\tvar self = this;\n\tif (builder)\n\t\tbuilder.db = self;\n\telse\n\t\tbuilder = new DatabaseBuilder(self);\n\tbuilder.$options.listing = true;\n\tbuilder.$take = builder.$options.take = 100;\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\nDP.find = function(builder) {\n\tvar self = this;\n\tif (builder instanceof DatabaseBuilder)\n\t\tbuilder.db = self;\n\telse\n\t\tbuilder = new DatabaseBuilder(self);\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\nDP.find2 = function(builder) {\n\tvar self = this;\n\tif (builder instanceof DatabaseBuilder)\n\t\tbuilder.db = self;\n\telse {\n\t\tbuilder = new DatabaseBuilder(self);\n\t\tbuilder.$options.notall = true;\n\t}\n\n\tif (self.readonly)\n\t\treturn self.find(builder);\n\tself.pending_reader2.push(builder);\n\tsetImmediate(next_operation, self, 11);\n\treturn builder;\n};\n\nDP.stream = function(fn, repository, callback) {\n\tvar self = this;\n\n\tif (typeof(repository) === 'function') {\n\t\tcallback = repository;\n\t\trepository = null;\n\t}\n\n\tself.pending_streamer.push({ fn: fn, callback: callback, repository: repository || {} });\n\tsetImmediate(next_operation, self, 10);\n\treturn self;\n};\n\nDP.throwReadonly = function(e) {\n\tthrow new Error('Database \"{0}\" is readonly.'.format(this.name) + (e ? '\\n' + e.toString() : ''));\n};\n\nDP.scalar = function(type, field) {\n\treturn this.find().scalar(type, field);\n};\n\nDP.count = function() {\n\tvar self = this;\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.$options.readertype = 1;\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\nDP.one = DP.read = function() {\n\tvar self = this;\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.first();\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\nDP.one2 = DP.read2 = function() {\n\tvar self = this;\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.first();\n\tself.pending_reader2.push(builder);\n\tsetImmediate(next_operation, self, 11);\n\treturn builder;\n};\n\nDP.top = function(max) {\n\tvar self = this;\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.take(max);\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\n//  1 append\n//  2 update\n//  3 remove\n//  4 reader\n//  5 views\n//  6 reader views\n//  7 drop\n//  8 backup\n//  9 restore\n// 10 streamer\n// 11 reader reverse\n// 12 clear\n// 13 clean\n// 14 locks\n\nconst NEXTWAIT = { 7: true, 8: true, 9: true, 12: true, 13: true, 14: true };\n\nDP.next = function(type) {\n\n\tif (type && NEXTWAIT[this.step])\n\t\treturn;\n\n\tif (F.isCluster && type === 0 && this.locked)\n\t\tclusterunlock(this);\n\n\tif (!this.$writting && !this.$reading) {\n\n\t\tif (this.step !== 12 && this.pending_clear.length) {\n\t\t\tif (!this.readonly && F.isCluster)\n\t\t\t\tclusterlock(this, '$clear');\n\t\t\telse if (INMEMORY[this.name])\n\t\t\t\tthis.$clear_inmemory();\n\t\t\telse\n\t\t\t\tthis.$clear();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 13 && this.pending_clean.length) {\n\t\t\tif (!this.readonly && F.isCluster)\n\t\t\t\tclusterlock(this, '$clean');\n\t\t\telse\n\t\t\t\tthis.$clean();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 7 && !this.pending_reindex && this.pending_drops) {\n\t\t\tthis.$drop();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 14 && this.pending_locks.length) {\n\t\t\tthis.$lock();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!this.$writting) {\n\n\t\tif (this.step !== 1 && !this.pending_reindex && this.pending_append.length) {\n\t\t\tif (INMEMORY[this.name])\n\t\t\t\tthis.$append_inmemory();\n\t\t\telse\n\t\t\t\tthis.$append();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 2 && !this.$writting && this.pending_update.length) {\n\t\t\tif (!this.readonly && F.isCluster)\n\t\t\t\tclusterlock(this, '$update');\n\t\t\telse if (INMEMORY[this.name])\n\t\t\t\tthis.$update_inmemory();\n\t\t\telse\n\t\t\t\tthis.$update();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 3 && !this.$writting && this.pending_remove.length) {\n\t\t\tif (!this.readonly && F.isCluster)\n\t\t\t\tclusterlock(this, '$remove');\n\t\t\tif (INMEMORY[this.name])\n\t\t\t\tthis.$remove_inmemory();\n\t\t\telse\n\t\t\t\tthis.$remove();\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\tif (!this.$reading) {\n\n\t\tif (this.step !== 4 && this.pending_reader.length) {\n\t\t\tthis.$reader();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 11 && this.pending_reader2.length) {\n\t\t\tthis.$reader3();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 10 && this.pending_streamer.length) {\n\t\t\tthis.$streamer();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (this.step !== type) {\n\t\tthis.step = 0;\n\t\tsetImmediate(next_operation, this, 0);\n\t}\n};\n\n// ======================================================================\n// FILE OPERATIONS\n// ======================================================================\n\n// InMemory saving\nDP.$save = function() {\n\tvar self = this;\n\tsetTimeout2('nosql.' + self.name, function() {\n\t\tvar data = self.inmemory['#'] || EMPTYARRAY;\n\t\tvar builder = [];\n\t\tfor (var i = 0, length = data.length; i < length; i++)\n\t\t\tbuilder.push(JSON.stringify(data[i]).replace(REGBOOL, JSONBOOL));\n\t\tFs.writeFile(self.filename, builder.join(NEWLINE) + NEWLINE, F.errorcallback);\n\t}, 50, 100);\n\treturn self;\n};\n\nDP.$inmemory = function(callback) {\n\n\tvar self = this;\n\tvar view = '#';\n\n\tself.readonly && self.throwReadonly();\n\n\t// Last usage\n\tself.inmemorylastusage = global.F ? global.NOW : undefined;\n\n\tif (self.inmemory[view])\n\t\treturn callback();\n\n\tvar filename = self.filename;\n\tif (view !== '#')\n\t\tfilename = filename.replace(/\\.nosql/, '#' + view + '.nosql');\n\n\tself.inmemory[view] = [];\n\n\tFs.readFile(filename, function(err, data) {\n\t\tif (err)\n\t\t\treturn callback();\n\t\tvar arr = data.toString('utf8').split('\\n');\n\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\tvar item = arr[i];\n\t\t\tif (item) {\n\t\t\t\ttry {\n\t\t\t\t\titem = JSON.parse(item.trim(), jsonparser);\n\t\t\t\t\titem && self.inmemory[view].push(item);\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\t\t}\n\n\t\tcallback();\n\t});\n\n\treturn self;\n};\n\nTP.$meta = DP.$meta = function(write) {\n\n\tvar self = this;\n\n\tif (write) {\n\t\tself.readonly && self.throwReadonly();\n\t\tFs.writeFile(self.filenameMeta, JSON.stringify(self.metadata), F.errorcallback);\n\t\treturn self;\n\t}\n\n\tif (self.readonly)\n\t\treturn self;\n\n\ttry {\n\t\tself.metadata = JSON.parse(Fs.readFileSync(self.filenameMeta).toString('utf8'), jsonparser);\n\t} catch (err) {}\n\n\treturn self;\n};\n\nDP.$append = function() {\n\tvar self = this;\n\tself.step = 1;\n\n\tif (!self.pending_append.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tself.$writting = true;\n\n\tself.pending_append.splice(0).limit(JSONBUFFER, function(items, next) {\n\n\t\tvar json = '';\n\t\tfor (var i = 0, length = items.length; i < length; i++) {\n\t\t\tjson += items[i].doc + NEWLINE;\n\t\t}\n\n\t\tFs.appendFile(self.filename, json, function(err) {\n\n\t\t\terr && F.error(err, 'NoSQL insert: ' + self.name);\n\n\t\t\tfor (var i = 0, length = items.length; i < length; i++) {\n\t\t\t\titems[i].builder.$options.log && items[i].builder.log();\n\t\t\t\tvar callback = items[i].builder.$callback;\n\t\t\t\tcallback && callback(err, 1);\n\t\t\t}\n\n\t\t\tnext();\n\t\t});\n\n\t}, () => setImmediate(next_append, self));\n};\n\nfunction next_append(self) {\n\tself.$writting = false;\n\tself.next(0);\n\tself.$events.change && self.emit('change', 'insert');\n}\n\nDP.$append_inmemory = function() {\n\tvar self = this;\n\tself.step = 1;\n\n\tif (!self.pending_append.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tvar items = self.pending_append.splice(0);\n\n\treturn self.$inmemory(function() {\n\n\t\tfor (var i = 0, length = items.length; i < length; i++) {\n\t\t\tself.inmemory['#'].push(JSON.parse(items[i].doc, jsonparser));\n\t\t\titems[i].builder.$options.log && items[i].builder.log();\n\t\t\tvar callback = items[i].builder.$callback;\n\t\t\tcallback && callback(null, 1);\n\t\t}\n\n\t\tself.$save();\n\t\tsetImmediate(next_append, self);\n\t});\n};\n\nDP.$update = function() {\n\n\tvar self = this;\n\tself.step = 2;\n\n\tif (!self.pending_update.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tself.$writting = true;\n\n\tvar filter = self.pending_update.splice(0);\n\tvar filters = new NoSQLReader();\n\tvar fs = new NoSQLStream(self.filename);\n\tvar change = false;\n\n\tfor (var i = 0; i < filter.length; i++)\n\t\tfilters.add(filter[i].builder, true);\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tvar update = function(docs, doc, dindex, f, findex) {\n\n\t\tvar rec = fs.docsbuffer[dindex];\n\t\tvar fil = filter[findex];\n\t\tvar e = fil.keys ? 'modify' : 'update';\n\t\tvar old = self.$events[e] ? CLONE(doc) : 0;\n\n\t\tif (f.first)\n\t\t\tf.canceled = true;\n\n\t\tif (fil.keys) {\n\t\t\tfor (var j = 0; j < fil.keys.length; j++) {\n\t\t\t\tvar key = fil.keys[j];\n\t\t\t\tvar val = fil.doc[key];\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\tif (typeof(val) === 'function')\n\t\t\t\t\t\tdoc[key] = val(doc[key], doc, f.filter.repository, f.filter.arg);\n\t\t\t\t\telse if (fil.inc && fil.inc[key]) {\n\t\t\t\t\t\tswitch (fil.inc[key]) {\n\t\t\t\t\t\t\tcase '!':\n\t\t\t\t\t\t\t\tdoc[key] = !doc[key];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) + val;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) - val;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) + val;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) / val;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdoc[key] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tdocs[dindex] = typeof(fil.doc) === 'function' ? (fil.doc(doc, f.filter.repository, f.filter.arg) || doc) : fil.doc;\n\n\t\tself.$events[e] && self.emit(e, doc, old);\n\t\tf.builder.$options.backup && f.builder.$backupdoc(rec.doc);\n\t};\n\n\tvar updateflush = function(docs, doc, dindex) {\n\n\t\tdoc = docs[dindex];\n\n\t\tvar rec = fs.docsbuffer[dindex];\n\t\tvar upd = JSON.stringify(doc).replace(REGBOOL, JSONBOOL);\n\t\tif (upd === rec.doc)\n\t\t\treturn;\n\n\t\t!change && (change = true);\n\t\tvar was = true;\n\n\t\tif (rec.doc.length === upd.length) {\n\t\t\tvar b = Buffer.byteLength(upd);\n\t\t\tif (rec.length === b) {\n\t\t\t\tfs.write(upd + NEWLINE, rec.position);\n\t\t\t\twas = false;\n\t\t\t}\n\t\t}\n\n\t\tif (was) {\n\t\t\tvar tmp = fs.remchar + rec.doc.substring(1) + NEWLINE;\n\t\t\tfs.write(tmp, rec.position);\n\t\t\tfs.write2(upd + NEWLINE);\n\t\t}\n\t};\n\n\tfs.ondocuments = function() {\n\t\tfilters.compare2(JSON.parse('[' + fs.docs + ']', jsonparser), update, updateflush);\n\t};\n\n\tfs.$callback = function() {\n\n\t\tfs = null;\n\t\tself.$writting = false;\n\t\tself.next(0);\n\n\t\tfor (var i = 0; i < filters.builders.length; i++) {\n\t\t\tvar item = filters.builders[i];\n\t\t\tvar fil = filter[i];\n\t\t\tif (fil.insert && !item.counter) {\n\t\t\t\titem.builder.$insertcallback && item.builder.$insertcallback(fil.insert, item.filter ? item.filter.repository : EMPTYOBJECT);\n\t\t\t\tvar tmp = self.insert(fil.insert);\n\t\t\t\ttmp.$callback = item.builder.$callback;\n\t\t\t\ttmp.$options.log = item.builder.$options.log;\n\t\t\t\titem.builder.$callback = null;\n\t\t\t} else {\n\t\t\t\titem.builder.$options.log && item.builder.log();\n\t\t\t\titem.builder.$callback && item.builder.$callback(errorhandling(null, item.builder, item.counter), item.counter, item.count, item.filter ? item.filter.repository : EMPTYOBJECT);\n\t\t\t}\n\t\t}\n\n\t\tif (change) {\n\t\t\tself.$events.change && self.emit('change', 'update');\n\t\t\t!F.databasescleaner[self.name] && (F.databasescleaner[self.name] = 1);\n\t\t}\n\t};\n\n\tfs.openupdate();\n\treturn self;\n};\n\nDP.$update_inmemory = function() {\n\n\tvar self = this;\n\tself.step = 2;\n\n\tif (!self.pending_update.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tvar filter = self.pending_update.splice(0);\n\tvar change = false;\n\tvar filters = new NoSQLReader();\n\n\tfor (var i = 0; i < filter.length; i++)\n\t\tfilters.add(filter[i].builder, true);\n\n\treturn self.$inmemory(function() {\n\n\t\tvar old;\n\n\t\tvar update = function(docs, doc, dindex, f, findex) {\n\n\t\t\tvar fil = filter[findex];\n\t\t\tvar e = fil.keys ? 'modify' : 'update';\n\n\t\t\tif (!old)\n\t\t\t\told = self.$events[e] ? CLONE(doc) : 0;\n\n\t\t\tif (f.first)\n\t\t\t\tf.canceled = true;\n\n\t\t\tif (fil.keys) {\n\t\t\t\tfor (var j = 0; j < fil.keys.length; j++) {\n\t\t\t\t\tvar key = fil.keys[j];\n\t\t\t\t\tvar val = fil.doc[key];\n\t\t\t\t\tif (val !== undefined) {\n\t\t\t\t\t\tif (typeof(val) === 'function')\n\t\t\t\t\t\t\tdoc[key] = val(doc[key], doc);\n\t\t\t\t\t\telse if (fil.inc && fil.inc[key]) {\n\t\t\t\t\t\t\tswitch (fil.inc[key]) {\n\t\t\t\t\t\t\t\tcase '!':\n\t\t\t\t\t\t\t\t\tdoc[key] = !doc[key];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) + val;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) - val;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) + val;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) / val;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tdoc[key] = val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tdocs[dindex] = typeof(fil.doc) === 'function' ? fil.doc(doc, f.filter.repository) : fil.doc;\n\n\t\t\tself.$events[e] && self.emit(e, doc, old);\n\t\t\tf.builder.$options.backup && f.builder.$backupdoc(old);\n\t\t\treturn 1;\n\t\t};\n\n\t\tvar updateflush = function(docs, doc) {\n\t\t\t!change && (change = true);\n\t\t\tself.$events.update && self.emit('update', doc, old);\n\t\t\told = null;\n\t\t};\n\n\t\tfilters.compare2(self.inmemory['#'], update, updateflush);\n\n\t\tchange && self.$save();\n\n\t\tfor (var i = 0; i < filters.builders.length; i++) {\n\t\t\tvar item = filters.builders[i];\n\t\t\tif (item.insert && !item.counter) {\n\t\t\t\titem.builder.$insertcallback && item.builder.$insertcallback(item.insert, item.filter.repository || EMPTYOBJECT);\n\t\t\t\tvar tmp = self.insert(item.insert);\n\t\t\t\ttmp.$callback = item.builder.$callback;\n\t\t\t\ttmp.$options.log = item.builder.$options.log;\n\t\t\t\titem.builder.$callback = null;\n\t\t\t} else {\n\t\t\t\titem.builder.$options.log && item.builder.log();\n\t\t\t\titem.builder.$callback && item.builder.$callback(errorhandling(null, item.builder, item.counter), item.counter, item.count, item.filter.repository);\n\t\t\t}\n\t\t}\n\n\t\tsetImmediate(function() {\n\t\t\tself.next(0);\n\t\t\tchange && self.$events.change && self.emit('change', 'update');\n\t\t});\n\t});\n};\n\nDP.$reader = function() {\n\n\tvar self = this;\n\tself.step = 4;\n\n\tif (!self.pending_reader.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tvar list = self.pending_reader.splice(0);\n\tif (INMEMORY[self.name]) {\n\t\tself.$reader2_inmemory(list, () => self.next(0));\n\t} else {\n\t\tself.$reading = true;\n\t\tself.$reader2(self.filename, list, function() {\n\t\t\tself.$reading = false;\n\t\t\tself.next(0);\n\t\t});\n\t}\n\n\treturn self;\n};\n\nfunction listing(builder, item) {\n\tvar skip = builder.$options.skip || 0;\n\tvar take = builder.$options.take || 0;\n\treturn { page: ((skip / take) + 1), pages: item.count ? Math.ceil(item.count / take) : 0, limit: take, count: item.count, items: item.response || [] };\n}\n\nDP.$reader2 = function(filename, items, callback, reader) {\n\n\tvar self = this;\n\n\tif (self.readonly) {\n\t\tif (reader === undefined) {\n\t\t\tU.download(filename, FLAGS_READ, function(err, response) {\n\t\t\t\terr && F.error(err, 'NoSQL database download: ' + self.name);\n\t\t\t\tself.$reader2(filename, items, callback, err ? null : response);\n\t\t\t});\n\t\t\treturn self;\n\t\t}\n\t}\n\n\tvar fs = new NoSQLStream(self.filename);\n\tvar filters = new NoSQLReader(items);\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tfs.ondocuments = function() {\n\t\treturn filters.compare(JSON.parse('[' + fs.docs + ']', jsonparser));\n\t};\n\n\tfs.$callback = function() {\n\t\tfilters.done();\n\t\tfs = null;\n\t\tcallback();\n\t};\n\n\tif (reader)\n\t\tfs.openstream(reader);\n\telse\n\t\tfs.openread();\n\n\treturn self;\n};\n\nDP.$reader3 = function() {\n\n\tvar self = this;\n\tself.step = 11;\n\n\tif (!self.pending_reader2.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tself.$reading = true;\n\n\tvar fs = new NoSQLStream(self.filename);\n\tvar filters = new NoSQLReader(self.pending_reader2.splice(0));\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tfs.ondocuments = function() {\n\t\treturn filters.compare(JSON.parse('[' + fs.docs + ']', jsonparser));\n\t};\n\n\tfs.$callback = function() {\n\t\tfilters.done();\n\t\tself.$reading = false;\n\t\tfs = null;\n\t\tself.next(0);\n\t};\n\n\tfs.openreadreverse();\n\treturn self;\n};\n\nDP.$streamer = function() {\n\n\tvar self = this;\n\tself.step = 10;\n\n\tif (!self.pending_streamer.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tself.$reading = true;\n\n\tvar filter = self.pending_streamer.splice(0);\n\tvar length = filter.length;\n\tvar count = 0;\n\tvar fs = new NoSQLStream(self.filename);\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tfs.ondocuments = function() {\n\t\tvar docs = JSON.parse('[' + fs.docs + ']', jsonparser);\n\t\tfor (var j = 0; j < docs.length; j++) {\n\t\t\tvar json = docs[j];\n\t\t\tcount++;\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tfilter[i].fn(json, filter[i].repository, count);\n\t\t}\n\t};\n\n\tfs.$callback = function() {\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tfilter[i].callback && filter[i].callback(null, filter[i].repository, count);\n\t\tself.$reading = false;\n\t\tself.next(0);\n\t\tfs = null;\n\t};\n\n\tfs.openread();\n\treturn self;\n};\n\nfunction nosqlinlinesorter(item, builder, doc) {\n\n\tif (!item.response) {\n\t\titem.response = [doc];\n\t\treturn;\n\t}\n\n\tvar length = item.response.length;\n\tif (length < builder.$limit) {\n\t\titem.response.push(doc);\n\t\tlength + 1 >= builder.$limit && item.response.quicksort(builder.$options.sort.name, builder.$options.sort.asc);\n\t} else\n\t\tnosqlresort(item.response, builder, doc);\n}\n\nfunction nosqlsortvalue(a, b, sorter) {\n\tvar type = typeof(a);\n\tif (type === 'number')\n\t\treturn sorter.asc ? a > b : a < b;\n\telse if (type === 'string') {\n\t\tvar c = COMPARER(a, b);\n\t\treturn sorter.asc ? c === 1 : c === -1;\n\t} else if (type === 'boolean')\n\t\t// return sorter.asc ? a > b : a < b;\n\t\treturn sorter.asc ? (a && !b) : (!a && b);\n\telse if (a instanceof Date)\n\t\treturn sorter.asc ? a > b : a < b;\n\treturn false;\n}\n\nfunction nosqlresort(arr, builder, doc) {\n\tvar b = doc[builder.$options.sort.name];\n\tvar beg = 0;\n\tvar length = arr.length;\n\tvar tmp = length - 1;\n\n\tvar sort = nosqlsortvalue(arr[tmp][builder.$options.sort.name], b, builder.$options.sort);\n\tif (!sort)\n\t\treturn;\n\n\ttmp = arr.length / 2 >> 0;\n\tsort = nosqlsortvalue(arr[tmp][builder.$options.sort.name], b, builder.$options.sort);\n\tif (!sort)\n\t\tbeg = tmp + 1;\n\n\tfor (var i = beg; i < length; i++) {\n\t\tvar item = arr[i];\n\t\tvar sort = nosqlsortvalue(item[builder.$options.sort.name], b, builder.$options.sort);\n\t\tif (!sort)\n\t\t\tcontinue;\n\t\tfor (var j = length - 1; j > i; j--)\n\t\t\tarr[j] = arr[j - 1];\n\t\tarr[i] = doc;\n\t\treturn;\n\t}\n}\n\nDP.$reader2_inmemory = function(items, callback) {\n\tvar self = this;\n\treturn self.$inmemory(function() {\n\t\tvar filters = new NoSQLReader(items);\n\t\tfilters.clone = true;\n\t\tfilters.compare(self.inmemory['#']);\n\t\tfilters.done();\n\t\tcallback();\n\t});\n};\n\nDP.$remove = function() {\n\n\tvar self = this;\n\tself.step = 3;\n\n\tif (!self.pending_remove.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tself.$writting = true;\n\n\tvar fs = new NoSQLStream(self.filename);\n\tvar filter = self.pending_remove.splice(0);\n\tvar filters = new NoSQLReader(filter);\n\tvar change = false;\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tvar remove = function(docs, d, dindex, f) {\n\t\tvar rec = fs.docsbuffer[dindex];\n\t\tf.builder.$options.backup && f.builder.$backupdoc(rec.doc);\n\t\treturn 1;\n\t};\n\n\tvar removeflush = function(docs, d, dindex) {\n\t\tvar rec = fs.docsbuffer[dindex];\n\t\t!change && (change = true);\n\t\tself.$events.remove && self.emit('remove', d);\n\t\tfs.write(fs.remchar + rec.doc.substring(1) + NEWLINE, rec.position);\n\t};\n\n\tfs.ondocuments = function() {\n\t\tfilters.compare2(JSON.parse('[' + fs.docs + ']', jsonparser), remove, removeflush);\n\t};\n\n\tfs.$callback = function() {\n\t\tfilters.done();\n\t\tfs = null;\n\t\tself.$writting = false;\n\t\tself.next(0);\n\t\tif (change) {\n\t\t\tself.$events.change && self.emit('change', 'remove');\n\t\t\t!F.databasescleaner[self.name] && (F.databasescleaner[self.name] = 1);\n\t\t}\n\t};\n\n\tfs.openupdate();\n};\n\nDP.$clear = function() {\n\n\tvar self = this;\n\tself.step = 12;\n\n\tif (!self.pending_clear.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tvar filter = self.pending_clear.splice(0);\n\tFs.unlink(self.filename, function() {\n\t\tfor (var i = 0; i < filter.length; i++)\n\t\t\tfilter[i]();\n\t\tself.$events.change && self.emit('change', 'clear');\n\t\tself.next(0);\n\t});\n};\n\nDP.$clean = function() {\n\n\tvar self = this;\n\tself.step = 13;\n\n\tif (!self.pending_clean.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tvar filter = self.pending_clean.splice(0);\n\tvar length = filter.length;\n\tvar now = Date.now();\n\n\tF.databasescleaner[self.name] = undefined;\n\tCONF.nosql_logger && PRINTLN('NoSQL embedded \"{0}\" cleaning (beg)'.format(self.name));\n\n\tvar fs = new NoSQLStream(self.filename);\n\tvar writer = Fs.createWriteStream(self.filename + '-tmp');\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tfs.divider = NEWLINE;\n\n\tfs.ondocuments = function() {\n\t\tfs.docs && writer.write(fs.docs + NEWLINE);\n\t};\n\n\tfs.$callback = function() {\n\t\twriter.end();\n\t};\n\n\twriter.on('finish', function() {\n\t\tFs.rename(self.filename + '-tmp', self.filename, function() {\n\t\t\tCONF.nosql_logger && PRINTLN('NoSQL embedded \"{0}\" cleaning (end, {1}s)'.format(self.name, (((Date.now() - now) / 1000) >> 0)));\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tfilter[i]();\n\t\t\tself.$events.clean && self.emit('clean');\n\t\t\tself.next(0);\n\t\t\tfs = null;\n\t\t});\n\t});\n\n\tfs.openread();\n};\n\nDP.$lock = function() {\n\n\tvar self = this;\n\tself.step = 14;\n\n\tif (!self.pending_locks.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tvar filter = self.pending_locks.splice(0);\n\tfilter.wait(function(fn, next) {\n\t\tfn.call(self, next);\n\t}, function() {\n\t\tself.next(0);\n\t});\n};\n\nDP.$remove_inmemory = function() {\n\n\tvar self = this;\n\tself.step = 3;\n\n\tif (!self.pending_remove.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tvar change = false;\n\tvar filters = new NoSQLReader(self.pending_remove.splice(0));\n\n\treturn self.$inmemory(function() {\n\t\tvar cache = self.inmemory['#'].slice(0);\n\n\t\tvar remove = function(docs, d, dindex, f) {\n\t\t\tf.builder.$options.backup && f.builder.$backupdoc(d);\n\t\t\treturn 1;\n\t\t};\n\n\t\tvar removeflush = function(docs, d) {\n\t\t\t!change && (change = true);\n\t\t\tself.$events.remove && self.emit('remove', d);\n\t\t\tvar data = self.inmemory['#'];\n\t\t\tvar index = data.indexOf(d);\n\t\t\tif (index !== -1)\n\t\t\t\tself.inmemory['#'].splice(index, index + 1);\n\t\t};\n\n\t\tfilters.compare2(cache, remove, removeflush);\n\t\tchange && self.$save();\n\t\tfilters.done();\n\t\tself.next(0);\n\t\tchange && self.$events.change && self.emit('change', 'remove');\n\t});\n};\n\nDP.$clear_inmemory = function() {\n\n\tvar self = this;\n\tself.step = 12;\n\n\tif (!self.pending_clear.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tvar filter = self.pending_clear.splice(0);\n\treturn self.$inmemory(function() {\n\t\tself.inmemory['#'] = [];\n\t\tself.$save();\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tfilter[i](null);\n\t\tself.next(0);\n\t});\n};\n\nDP.$drop = function() {\n\tvar self = this;\n\tself.step = 7;\n\n\tif (!self.pending_drops) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tself.pending_drops = false;\n\tvar remove = [self.filename];\n\n\ttry {\n\t\tFs.readdirSync(self.binary.directory).forEach(function(filename) {\n\t\t\tfilename.startsWith(self.name + '#') && filename.endsWith(EXTENSION_BINARY) && remove.push(framework_utils.join(self.binary.directory, filename));\n\t\t});\n\t} catch (e) {}\n\n\tremove.wait((filename, next) => Fs.unlink(filename, next), function() {\n\t\tself.next(0);\n\t\tself.free(true);\n\t\tself.$events.change && self.emit('change', 'drop');\n\t}, 5);\n\n\tObject.keys(self.inmemory).forEach(function(key) {\n\t\tself.inmemory[key] = undefined;\n\t});\n};\n\nfunction DatabaseBuilder2(db) {\n\tthis.$callback = NOOP;\n\tthis.db = db;\n\tthis.$options = {};\n}\n\nDatabaseBuilder2.prototype.promise = promise;\n\nDatabaseBuilder2.prototype.log = function(msg, user) {\n\tvar self = this;\n\tif (msg) {\n\t\tNOW = new Date();\n\t\tself.$options.log = (self.$options.log ? self.$options.log : '') + NOW.toUTC().format('yyyy-MM-dd HH:mm:ss') + ' | ' + (user ? user.padRight(20) + ' | ' : '') + msg + NEWLINE;\n\t} else if (self.$options.log) {\n\t\tself.db.filenameLog && Fs.appendFile(self.db.filenameLog, self.$options.log, F.errorcallback);\n\t\tself.$options.log = '';\n\t}\n\treturn self;\n};\n\nDatabaseBuilder2.prototype.callback = function(fn, emptyerror) {\n\n\tif (typeof(fn) === 'string') {\n\t\tvar tmp = emptyerror;\n\t\temptyerror = fn;\n\t\tfn = tmp;\n\t}\n\n\tthis.$callback = fn;\n\tthis.$callback_emptyerror = emptyerror;\n\treturn this;\n};\n\nfunction DatabaseBuilder(db) {\n\tthis.db = db;\n\tthis.$take = 0;\n\tthis.$skip = 0;\n\tthis.$filter = [];\n\tthis.$first = false;\n\tthis.$scope = 0;\n\tthis.$callback = NOOP;\n\tthis.$code = [];\n\tthis.$args = {};\n\tthis.$options = {};\n\tthis.$repository = {};\n\tthis.$counter = 0;\n\tthis.$keys = [];\n}\n\nDatabaseBuilder.prototype.promise = promise;\n\nDatabaseBuilder.prototype.reset = function() {\n\tvar self = this;\n\tvar reader = self.$nosqlreader;\n\tif (reader) {\n\t\tfor (var i = 0; i < reader.builders.length; i++) {\n\t\t\tvar item = reader.builders[i];\n\t\t\tif (item.builder === self) {\n\t\t\t\titem.response = null;\n\t\t\t\titem.scalar = null;\n\t\t\t\titem.counter = 0;\n\t\t\t\titem.count = 0;\n\t\t\t\titem.scalarcount = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.makefilter = function() {\n\treturn { repository: this.$repository, options: this.$options, arg: this.$args, fn: this.$functions };\n};\n\nDatabaseBuilder.prototype.id = function(id) {\n\tthis.$options.id = id;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.insert = function(fn) {\n\tthis.$insertcallback = fn;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.log = function(msg, user) {\n\tvar self = this;\n\tif (msg) {\n\t\tNOW = new Date();\n\t\tself.$options.log = (self.$options.log ? self.$options.log : '') + NOW.toUTC().format('yyyy-MM-dd HH:mm:ss') + ' | ' + (user ? user.padRight(20) + ' | ' : '') + msg + NEWLINE;\n\t} else if (self.$options.log) {\n\t\tself.db.filenameLog && Fs.appendFile(self.db.filenameLog, self.$options.log, F.errorcallback);\n\t\tself.$options.log = '';\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.$callbackjoin = function(callback) {\n\tvar self = this;\n\tObject.keys(self.$join).wait(function(key, next) {\n\n\t\tvar join = self.$join[key];\n\t\tvar response = self.$response;\n\t\tvar unique = new Set();\n\n\t\tif (response instanceof Array && response.length) {\n\t\t\tfor (var i = 0; i < response.length; i++) {\n\t\t\t\tvar item = response[i];\n\t\t\t\tvar val = item[join.b];\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\tif (val instanceof Array) {\n\t\t\t\t\t\tfor (var j = 0; j < val.length; j++)\n\t\t\t\t\t\t\tunique.add(val[j]);\n\t\t\t\t\t} else\n\t\t\t\t\t\tunique.add(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (response) {\n\t\t\tvar val = response[join.b];\n\t\t\tif (val !== undefined)\n\t\t\t\tunique.add(val);\n\t\t}\n\n\t\tvar db = join.instance ? join.instance : (self.db instanceof Table ? TABLE(join.name) : NOSQL(join.name));\n\n\t\tif (join.scalartype) {\n\t\t\tjoin.items = [];\n\t\t\tjoin.count = unique.size;\n\t\t\tfor (var m of unique.values()) {\n\t\t\t\t(function(val) {\n\t\t\t\t\tvar builder = db.scalar(join.scalartype, join.scalarfield).callback(function(err, response) {\n\t\t\t\t\t\tjoin.items.push({ id: val, response: response });\n\t\t\t\t\t\tjoin.count--;\n\t\t\t\t\t\tif (join.count === 0) {\n\t\t\t\t\t\t\tjoin.count = -1;\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif (join.builder.$counter) {\n\t\t\t\t\t\tbuilder.$counter = join.builder.$counter;\n\t\t\t\t\t\tbuilder.$code = join.builder.$code.slice(0);\n\t\t\t\t\t\tU.extend_headers2(builder.$options, join.builder.$options);\n\t\t\t\t\t\tbuilder.$repository = join.builder.$repository;\n\t\t\t\t\t\tbuilder.$args = CLONE(join.builder.$args);\n\t\t\t\t\t}\n\n\t\t\t\t\tbuilder.$take = join.builder.$take;\n\t\t\t\t\tbuilder.$skip = join.builder.$skip;\n\t\t\t\t\tbuilder.$filter = join.builder.$filter;\n\t\t\t\t\tbuilder.$scope = join.builder.$scope;\n\t\t\t\t\tbuilder.where(join.a, val);\n\n\t\t\t\t})(m);\n\t\t\t}\n\t\t} else {\n\n\t\t\tif (unique.size) {\n\n\t\t\t\tjoin.builder.$options.fields && join.builder.$options.fields.push(join.a);\n\t\t\t\tjoin.builder.$callback = function(err, docs) {\n\t\t\t\t\tjoin.items = docs;\n\t\t\t\t\tnext();\n\t\t\t\t};\n\n\t\t\t\tdb.find(join.builder).in(join.a, Array.from(unique));\n\n\t\t\t} else {\n\t\t\t\tjoin.items = join.builder.$options.first ? null : [];\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\n\t}, callback, 2);\n\n\treturn self;\n};\n\nDatabaseBuilder.prototype.$callback2 = function(err, response, count, repository) {\n\tvar self = this;\n\n\tif (err || !self.$join) {\n\t\tself.$options.log && self.log();\n\t\tself.$done && setImmediate(self.$done);\n\t\tself.$callback && self.$callback(err, response, count, repository);\n\t\treturn;\n\t}\n\n\tself.$response = response;\n\tself.$callbackjoin(function() {\n\n\t\tvar keys = Object.keys(self.$join);\n\t\tvar jl = keys.length;\n\n\t\tif (response instanceof Array) {\n\t\t\tfor (var i = 0, length = response.length; i < length; i++) {\n\t\t\t\tvar item = response[i];\n\t\t\t\tfor (var j = 0; j < jl; j++) {\n\t\t\t\t\tvar join = self.$join[keys[j]];\n\t\t\t\t\titem[join.field] = join.scalartype ? findScalar(join.items, item[join.b]) : join.first ? findItem(join.items, join.a, item[join.b]) : findItems(join.items, join.a, item[join.b]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (response) {\n\t\t\tfor (var j = 0; j < jl; j++) {\n\t\t\t\tvar join = self.$join[keys[j]];\n\t\t\t\tresponse[join.field] = join.scalartype ? findScalar(join.items, item[join.b]) : join.first ? findItem(join.items, join.a, response[join.b]) : findItems(join.items, join.a, response[join.b]);\n\t\t\t}\n\t\t}\n\n\t\tself.$options.log && self.log();\n\t\tself.$done && setImmediate(self.$done);\n\t\tself.$callback && self.$callback(err, response, count, repository);\n\t});\n\n\treturn self;\n};\n\nfunction findItem(items, field, value) {\n\tfor (var i = 0, length = items.length; i < length; i++) {\n\t\tif (value instanceof Array) {\n\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\tif (items[i][field] === value[j])\n\t\t\t\t\treturn items[i];\n\t\t\t}\n\t\t} else if (items[i][field] === value)\n\t\t\treturn items[i];\n\t}\n}\n\nfunction findScalar(items, value) {\n\tvar sum = null;\n\tfor (var i = 0, length = items.length; i < length; i++) {\n\t\tvar item = items[i];\n\t\tif (value instanceof Array) {\n\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\tif (item.id === value[j]) {\n\t\t\t\t\tsum = sum == null ? item.response : (sum + item.response);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (item.id === value)\n\t\t\tsum = sum == null ? item.response : (sum + item.response);\n\t}\n\treturn sum;\n}\n\nfunction findItems(items, field, value) {\n\tvar arr = [];\n\tfor (var i = 0, length = items.length; i < length; i++) {\n\t\tif (value instanceof Array) {\n\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\tif (items[i][field] === value[j]) {\n\t\t\t\t\tarr.push(items[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (items[i][field] === value)\n\t\t\tarr.push(items[i]);\n\t}\n\treturn arr;\n}\n\nDatabaseBuilder.prototype.join = function(field, name) {\n\tvar self = this;\n\n\tif (!self.$join)\n\t\tself.$join = {};\n\n\tvar table = self.db instanceof Table;\n\tvar instance;\n\n\tif (name instanceof Database) {\n\t\tinstance = name;\n\t\tname = name.name;\n\t\ttable = false;\n\t} else if (name instanceof Table) {\n\t\tinstance = name;\n\t\ttable = true;\n\t\tname = name.name;\n\t}\n\n\tvar key = name + '.' + field;\n\tvar join = self.$join[key];\n\tif (join)\n\t\treturn join;\n\n\tvar item = self.$join[key] = {};\n\titem.field = field;\n\titem.name = name;\n\titem.table = table;\n\titem.instance = instance;\n\titem.builder = join = new DatabaseBuilder(self.db);\n\n\tjoin.on = function(a, b) {\n\n\t\tif (self.$options.fields)\n\t\t\tself.$options.fields.push(b);\n\n\t\tself.$join[key].a = a;\n\t\tself.$join[key].b = b;\n\n\t\tself.$keys && self.$keys.push(b);\n\t\treturn join;\n\t};\n\n\tjoin.first = function() {\n\t\titem.first = true;\n\t\treturn join;\n\t};\n\n\tjoin.scalar = function(type, field) {\n\t\titem.scalartype = type;\n\t\titem.scalarfield = field;\n\t\treturn join;\n\t};\n\n\tjoin.callback = function(a, b) {\n\t\tself.callback(a, b);\n\t\treturn join;\n\t};\n\n\treturn join;\n};\n\nDatabaseBuilder.prototype.first = function() {\n\tthis.$options.first = true;\n\treturn this.take(1);\n};\n\nDatabaseBuilder.prototype.make = function(fn, id) {\n\tif (id) {\n\t\tthis.$options.id = id;\n\t\tthis.$iscache = !!CACHE[this.db.name + '_' + id];\n\t}\n\tfn.call(this, this);\n\treturn this;\n};\n\nDatabaseBuilder.prototype.rule = function(rule, params) {\n\tvar self = this;\n\n\tif (typeof(rule) === 'string') {\n\t\tvar fn = CACHE[self.$rule];\n\t\tif (!fn)\n\t\t\tfn = CACHE[self.$rule] = new Function('doc', 'param', 'return ' + rule);\n\t\tself.$rule = fn;\n\t} else\n\t\tself.$rule = rule;\n\n\tself.$params = params;\n\treturn self;\n};\n\nDatabaseBuilder.prototype.filter = function(fn) {\n\tvar self = this;\n\n\tif (!self.$functions)\n\t\tself.$functions = [];\n\n\tvar index = self.$functions.push(fn) - 1;\n\n\tif (!self.$iscache) {\n\t\tvar code = '$is=!!fn[{0}].call($F,doc,index,repository);'.format(index);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\tself.$counter++;\n\treturn self;\n};\n\nDatabaseBuilder.prototype.scalar = function(type, name) {\n\tvar self = this;\n\tvar opt = self.$options;\n\topt.scalar = type;\n\topt.scalarfield = name;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.contains = function(name) {\n\tvar self = this;\n\n\tif (!self.$iscache) {\n\t\tvar code = '$is=doc.{0} instanceof Array?!!doc.{0}.length:!!doc.{0};'.format(name);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\tself.$counter++;\n\treturn self;\n};\n\nDatabaseBuilder.prototype.empty = function(name) {\n\tvar self = this;\n\n\tif (!self.$iscache) {\n\t\tvar code = '$is=doc.{0} instanceof Array?!doc.{0}.length:!doc.{0};'.format(name);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\tself.$counter++;\n\treturn self;\n};\n\nDatabaseBuilder.prototype.map = function(name, code) {\n\tvar self = this;\n\tif (!self.$iscache) {\n\t\tvar data = { name: name, code: code };\n\t\tif (self.$options.mappers)\n\t\t\tself.$options.mappers.push(data);\n\t\telse\n\t\t\tself.$options.mappers = [data];\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.backup = function(user) {\n\tif (this.db.filenameBackup)\n\t\tthis.$options.backup = typeof(user) === 'string' ? user : UNKNOWN;\n\telse\n\t\tthis.$options.backup = null;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.$backupdoc = function(doc) {\n\tthis.db.filenameBackup && Fs.appendFile(this.db.filenameBackup, NOW.toUTC().format('yyyy-MM-dd HH:mm') + ' | ' + this.$options.backup.padRight(20) + ' | ' + (typeof(doc) === 'string' ? doc : JSON.stringify(doc)) + NEWLINE, F.errorcallback);\n\treturn this;\n};\n\nDatabaseBuilder.prototype.where = function(name, operator, value) {\n\n\tvar self = this;\n\tvar key = 'w' + (self.$counter++);\n\tvar code;\n\n\tif (value === undefined) {\n\t\tvalue = operator;\n\t\toperator = '=';\n\t}\n\n\tvar date = framework_utils.isDate(value);\n\tself.$args[key] = date ? value.getTime() : value;\n\n\tif (!self.$iscache) {\n\t\tswitch (operator) {\n\t\t\tcase '=':\n\t\t\t\toperator = '==';\n\t\t\t\tbreak;\n\t\t\tcase '<>':\n\t\t\t\toperator = '!=';\n\t\t\t\tbreak;\n\t\t}\n\t\tcode = (date ? '$is=(doc.{0} instanceof Date?doc.{0}:new Date(doc.{0})).getTime(){2}arg.{1};' : '$is=doc.{0}{2}arg.{1};');\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code.format(name, key, operator));\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\treturn self;\n};\n\nDatabaseBuilder.prototype.query = function(code) {\n\tvar self = this;\n\tif (!self.$iscache) {\n\t\tcode = '$is=(' + code + ');';\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\tself.$counter++;\n\treturn self;\n};\n\nDatabaseBuilder.prototype.arg = function(key, value) {\n\tthis.$args[key] = value;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.month = function(name, operator, value) {\n\tvar self = this;\n\tvar key = 'dm' + (self.$counter++);\n\n\tif (value === undefined) {\n\t\tvalue = operator;\n\t\toperator = '=';\n\t}\n\n\tself.$args[key] = value;\n\n\tif (!self.$iscache) {\n\t\tvar code = compare_datetype('month', name, key, operator);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.day = function(name, operator, value) {\n\tvar self = this;\n\tvar key = 'dd' + (self.$counter++);\n\n\tif (value === undefined) {\n\t\tvalue = operator;\n\t\toperator = '=';\n\t}\n\n\tself.$args[key] = value;\n\n\tif (!self.$iscache) {\n\t\tvar code = compare_datetype('day', name, key, operator);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.year = function(name, operator, value) {\n\tvar self = this;\n\tvar key = 'dy' + (self.$counter++);\n\n\tif (value === undefined) {\n\t\tvalue = operator;\n\t\toperator = '=';\n\t}\n\n\tself.$args[key] = value;\n\n\tif (!self.$iscache) {\n\t\tvar code = compare_datetype('year', name, key, operator);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\treturn self;\n};\n\nDatabaseBuilder.prototype.hour = function(name, operator, value) {\n\tvar self = this;\n\tvar key = 'dh' + (self.$counter++);\n\n\tif (value === undefined) {\n\t\tvalue = operator;\n\t\toperator = '=';\n\t}\n\n\tself.$args[key] = value;\n\n\tif (!self.$iscache) {\n\t\tvar code = compare_datetype('hour', name, key, operator);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\treturn self;\n};\n\nDatabaseBuilder.prototype.minute = function(name, operator, value) {\n\tvar self = this;\n\tvar key = 'dh' + (self.$counter++);\n\n\tif (value === undefined) {\n\t\tvalue = operator;\n\t\toperator = '=';\n\t}\n\n\tself.$args[key] = value;\n\n\tif (!self.$iscache) {\n\t\tvar code = compare_datetype('minute', name, key, operator);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\treturn self;\n};\n\nDatabaseBuilder.prototype.like = DatabaseBuilder.prototype.search = function(name, value, where) {\n\n\tvar self = this;\n\tvar code;\n\tvar key = 'l' + (self.$counter++);\n\n\tif (!self.$iscache) {\n\t\tif (!where)\n\t\t\twhere = '*';\n\n\t\tswitch (where) {\n\t\t\tcase 'beg':\n\t\t\t\tcode = '$is=doc.{0}?doc.{0}.startsWith(arg.{1}):false;';\n\t\t\t\tbreak;\n\t\t\tcase 'end':\n\t\t\t\tcode = '$is=doc.{0}?doc.{0}.endsWith(arg.{1}):false;';\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tcode = '$is=false;if(doc.{0}){if(doc.{0} instanceof Array){for(var $i=0;$i<doc.{0}.length;$i++){if(doc.{0}[$i].toLowerCase().indexOf(arg.{1})!==-1){$is=true;break;}}}else{$is=doc&&doc.{0}?(doc.{0} + \\'\\').toLowerCase().indexOf(arg.{1})!==-1:false}}';\n\t\t\t\tif (value instanceof Array)\n\t\t\t\t\tvalue = value.join(' ');\n\t\t\t\tvalue = value.toLowerCase();\n\t\t\t\tbreak;\n\t\t}\n\n\t\tself.$args[key] = value;\n\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\n\t\tself.$code.push(code.format(name, key));\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t} else {\n\t\tif (!where || where === '*') {\n\t\t\tif (value instanceof Array)\n\t\t\t\tvalue = value.join(' ');\n\t\t\tvalue = value.toLowerCase();\n\t\t}\n\t\tself.$args[key] = value;\n\t}\n\n\treturn self;\n};\n\nDatabaseBuilder.prototype.regexp = function(name, value) {\n\tvar self = this;\n\tif (!self.$iscache) {\n\t\tvar code = '$is=false;if(doc.{0}&&doc.{0}.toLowerCase){$is=({1}).test(doc.{0})}';\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code.format(name, value.toString()));\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.fulltext = function(name, value, weight) {\n\n\tvar self = this;\n\tvar key = 'l' + (self.$counter++);\n\tvar key2 = 'l' + (self.$counter++);\n\n\tif (value instanceof Array) {\n\t\tfor (var i = 0; i < value.length; i++)\n\t\t\tvalue[i] = value[i].toLowerCase();\n\t} else {\n\t\tif (REGCHINA.test(value))\n\t\t\tvalue = value.split('');\n\t\telse\n\t\t\tvalue = value.toLowerCase().split(' ');\n\t}\n\n\tself.$args[key] = value;\n\n\tvar count = 1;\n\n\tif (weight)\n\t\tcount = ((value.length / 100) * weight) >> 0;\n\n\tself.$args[key2] = count || 1;\n\n\tif (!self.$iscache) {\n\t\tvar code = '$is=false;if(doc.{0}&&doc.{0}.toLowerCase){var $a=arg.{2},$b=doc.{0}.toLowerCase();for(var $i=0;$i<arg.{1}.length;$i++){if($b.indexOf(arg.{1}[$i])!==-1){$a--;if(!$a){$is=true;break}}}}';\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code.format(name, key, key2));\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\treturn self;\n};\n\nDatabaseBuilder2.prototype.stringify = DatabaseBuilder.prototype.stringify = function() {\n\n\tvar self = this;\n\tvar obj = {};\n\n\tobj.options = self.$options;\n\tobj.code = self.$code;\n\tobj.args = self.$args;\n\tobj.insert = self.$insertcallback ? self.$insertcallback.toString() : null;\n\n\tif (self.$functions) {\n\t\tobj.functions = [];\n\t\tfor (var i = 0; i < self.$functions.length; i++)\n\t\t\tobj.functions.push(self.$functions[i].toString());\n\t}\n\n\tif (self.$repository)\n\t\tobj.repository = self.$repository;\n\n\treturn JSON.stringify(obj);\n};\n\nDatabaseBuilder2.prototype.parse = DatabaseBuilder.prototype.parse = function(data) {\n\n\tdata = JSON.parse(data, jsonparser);\n\tthis.$options = data.options;\n\tthis.$code = data.code;\n\tthis.$args = data.args;\n\tthis.$take = data.options.take;\n\tthis.$skip = data.options.skip;\n\tthis.$repository = data.repository;\n\tthis.$insertcallback = data.insert ? eval('(' + data.insert + ')') : null;\n\n\tif (data.functions) {\n\t\tfor (var i = 0; i < data.functions.length; i++)\n\t\t\tdata.functions[i] = eval('(' + data.functions[i] + ')');\n\t\tthis.$functions = data.functions;\n\t}\n\n\treturn this;\n};\n\nDatabaseBuilder.prototype.take = function(count) {\n\tthis.$take = this.$options.take = count;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.limit = function(count) {\n\tthis.$take = this.$options.take = count;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.page = function(page, limit) {\n\tif (limit)\n\t\tthis.$take = this.$options.take = limit;\n\tthis.$skip = this.$options.skip = page * this.$take;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.paginate = function(page, limit, maxlimit) {\n\n\tvar limit2 = +(limit || 0);\n\tvar page2 = (+(page || 0)) - 1;\n\n\tif (page2 < 0)\n\t\tpage2 = 0;\n\n\tif (maxlimit && limit2 > maxlimit)\n\t\tlimit2 = maxlimit;\n\n\tif (!limit2)\n\t\tlimit2 = maxlimit;\n\n\tthis.$skip = this.$options.skip = page2 * limit2;\n\tthis.$take = this.$options.take = limit2;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.skip = function(count) {\n\tthis.$take = this.$options.skip = count;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.callback = function(fn, emptyerror) {\n\n\tif (typeof(fn) === 'string') {\n\t\tvar tmp = emptyerror;\n\t\temptyerror = fn;\n\t\tfn = tmp;\n\t}\n\n\tthis.$callback = fn;\n\tthis.$callback_emptyerror = emptyerror;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.random = function() {\n\tthis.$options.sort = null;\n\treturn this;\n};\n\nDatabaseBuilder.prototype.sort = function(name, desc) {\n\tvar self = this;\n\tself.$options.sort = { name: name, asc: desc ? false : true };\n\treturn self;\n};\n\nDatabaseBuilder.prototype.repository = function(key, value) {\n\tvar self = this;\n\tif (key === undefined)\n\t\treturn self.$repository;\n\tif (value === undefined)\n\t\treturn self.$repository[key];\n\tself.$repository[key] = value;\n\treturn self;\n};\n\nDatabaseBuilder.prototype.compile = function(noTrimmer) {\n\n\tvar self = this;\n\tvar opt = self.$options;\n\tvar key = opt.id ? (self.db ? self.db.name : UNKNOWN) + '_' + opt.id : null;\n\tvar cache = key ? CACHE[key] : null;\n\n\tself.$inlinesort = !!(opt.take && opt.sort && opt.sort !== null);\n\tself.$limit = (opt.take || 0) + (opt.skip || 0);\n\n\tif (key && cache) {\n\t\tself.$mappers = cache.mitems;\n\t\tself.$mappersexec = cache.mexec;\n\t\treturn cache.filter;\n\t}\n\n\tvar raw = self.$code.join('');\n\tvar code = 'var R=repository=$F.repository,options=$F.options,arg=$F.arg,fn=$F.fn,$is=false,$tmp;' + raw + (self.$code.length && raw.substring(raw.length - 7) !== 'return;' ? 'if(!$is)return;' : '') + (noTrimmer ? 'return doc' : 'if(options.fields){var $doc={};for(var $i=0;$i<options.fields.length;$i++){var prop=options.fields[$i];$doc[prop]=doc[prop]}if(options.sort)$doc[options.sort.name]=doc[options.sort.name];return $doc}else if(options.fields2){var $doc={};var $keys=Object.keys(doc);for(var $i=0;$i<$keys.length;$i++){var prop=$keys[$i];!options.fields2[prop]&&($doc[prop]=doc[prop])}return $doc}else{return doc}');\n\n\tif (!key) {\n\t\tkey = (self.db ? self.db.name : UNKNOWN) + '_' + raw.hash();\n\t\tcache = CACHE[key];\n\t\tif (cache) {\n\t\t\tself.$mappers = cache.mitems;\n\t\t\tself.$mappersexec = cache.mexec;\n\t\t\tself.$each = cache.each;\n\t\t\treturn cache.filter;\n\t\t}\n\t}\n\n\tif (opt.mappers) {\n\t\tvar tmp = '';\n\t\tself.$mappers = [];\n\t\tfor (var i = 0; i < opt.mappers.length; i++) {\n\t\t\tvar m = opt.mappers[i];\n\t\t\ttmp += ('doc.{0}=item.builder.$mappers[{1}](doc,item.filter.repository,item.filter.repository);'.format(m.name, i));\n\t\t\topt.fields && opt.fields.push(m.name);\n\t\t\tself.$mappers.push(new Function('doc', 'repository', 'R', m.code.lastIndexOf('return ') === -1 ? ('return ' + m.code) : m.code));\n\t\t}\n\t\tself.$mappersexec = new Function('doc', 'item', tmp);\n\t}\n\n\tif (opt.each)\n\t\tself.$each = new Function('item', 'doc', 'repository', 'R', opt.each.join(''));\n\n\tvar cache = {};\n\tcache.rule = self.$rule;\n\tcache.params = self.$params;\n\tcache.filter = new Function('doc', '$F', 'index', code);\n\tcache.mexec = self.$mappersexec;\n\tcache.mitems = self.$mappers;\n\tcache.each = self.$each;\n\tCACHE[key] = cache;\n\treturn cache.filter;\n};\n\nDatabaseBuilder.prototype.in = function(name, value) {\n\tvar self = this;\n\tvar key = 'in' + (self.$counter++);\n\tself.$args[key] = value instanceof Array ? value : [value];\n\tif (!self.$iscache) {\n\t\tvar code = 'if($is)$is=false;$tmp=doc.{0};if($tmp instanceof Array){for(var $i=0;$i<$tmp.length;$i++){if(arg.{1}.indexOf($tmp[$i])!==-1){$is=true;break}}}else{if(arg.{1}.indexOf($tmp)!==-1)$is=true}'.format(name, key);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.notin = function(name, value) {\n\tvar self = this;\n\tvar key = 'in' + (self.$counter++);\n\tself.$args[key] = value instanceof Array ? value : [value];\n\tif (!self.$iscache) {\n\t\tvar code = '$is=true;$tmp=doc.{0};if($tmp instanceof Array){for(var $i=0;$i<$tmp.length;$i++){if(arg.{1}.indexOf($tmp[$i])!==-1){$is=false;break}}}else{if(arg.{1}.indexOf($tmp)!==-1)$is=false}'.format(name, key);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.between = function(name, a, b) {\n\tvar self = this;\n\tvar keya = 'ba' + (self.$counter++);\n\tvar keyb = 'bb' + (self.$counter++);\n\n\tself.$args[keya] = a;\n\tself.$args[keyb] = b;\n\n\tif (!self.$iscache) {\n\t\tvar code = '$is=doc.{0}>=arg.{1}&&doc.{0}<=arg.{2};'.format(name, keya, keyb);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.or = function() {\n\tvar self = this;\n\tif (!self.$iscache) {\n\t\tself.$code.push('$is=false;');\n\t\tself.$scope = 1;\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.end = function() {\n\tvar self = this;\n\tif (!self.$iscache) {\n\t\tself.$scope = 0;\n\t\tself.$code.push('if(!$is)return;');\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.and = function() {\n\tvar self = this;\n\tif (!self.$iscache) {\n\t\tself.$code.push('$is=false;');\n\t\tself.$scope = 0;\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.done = function() {\n\tthis.$options = {};\n\tthis.$code = [];\n\treturn this;\n};\n\nDatabaseBuilder.prototype.fields = function() {\n\tvar self = this;\n\tvar opt = self.$options;\n\tvar arr = arguments.length === 1 ? arguments[0].split(',') : arguments;\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar name = arr[i];\n\t\tif (name[0] === '-') {\n\t\t\t!opt.fields2 && (opt.fields2 = {});\n\t\t\topt.fields2[name.substring(1)] = 1;\n\t\t} else {\n\t\t\t!opt.fields && (opt.fields = []);\n\t\t\topt.fields.push(name);\n\t\t}\n\t}\n\treturn self;\n};\n\nDatabaseBuilder.prototype.prepare = function(fn) {\n\tvar self = this;\n\n\tif (!self.$functions)\n\t\tself.$functions = [];\n\n\tvar index = self.$functions.push(fn) - 1;\n\n\tif (!self.$iscache) {\n\t\tvar code = '$tmp=fn[{0}].call($F,U.clone(doc),index,repository);if(typeof($tmp)==\\'boolean\\'){$is=$tmp}else{doc=$tmp;$is=$tmp!=null}'.format(index);\n\t\tif (self.$scope)\n\t\t\tcode = 'if(!$is){' + code + '}';\n\t\tself.$code.push(code);\n\t\t!self.$scope && self.$code.push('if(!$is)return;');\n\t}\n\n\treturn self;\n};\n\nDatabaseBuilder.prototype.each = function(fn) {\n\tvar self = this;\n\n\tif (!self.$functions)\n\t\tself.$functions = [];\n\n\tvar index = self.$functions.push(fn) - 1;\n\n\tif (!self.$iscache) {\n\t\tvar code = 'item.filter.fn[{0}].call(item,doc,item.filter.repository,item.filter.repository);'.format(index);\n\t\tif (self.$options.each)\n\t\t\tself.$options.each.push(code);\n\t\telse\n\t\t\tself.$options.each = [code];\n\t}\n\n\treturn self;\n};\n\nfunction Counter(db) {\n\tvar t = this;\n\tt.TIMEOUT = 30000;\n\tt.db = db;\n\tt.cache;\n\tt.filenameLock = db.filenameCounter + '-lock';\n\tt.key = (db instanceof Table ? 'table' : 'nosql') + db.name.hash();\n\tt.type = 0; // 1 === saving, 2 === reading\n\tt.$events = {};\n\tt.$cb_save = function() {\n\t\tt.tid = undefined;\n\t\tif (F.isCluster)\n\t\t\tclusterlock(t, '$save');\n\t\telse\n\t\t\tt.$save();\n\t};\n}\n\nconst CP = Counter.prototype;\n\nCP.emit = function(name, a, b, c, d, e, f, g) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nCP.on = function(name, fn) {\n\n\tif (!fn.$once)\n\t\tthis.db.$free = false;\n\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\n\treturn this;\n};\n\nCP.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nCP.removeListener = function(name, fn) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tthis.$events[name] = evt;\n\t\telse\n\t\t\tthis.$events[name] = undefined;\n\t}\n\treturn this;\n};\n\nCP.removeAllListeners = function(name) {\n\tif (name === true)\n\t\tthis.$events = EMPTYOBJECT;\n\telse if (name)\n\t\tthis.$events[name] = undefined;\n\telse\n\t\tthis.$events = {};\n\treturn this;\n};\n\nCP.empty = function(key, value) {\n\tvar self = this;\n\t!self.cache && (self.cache = {});\n\n\t// key[2] = su[m]\n\t// max\n\t// min\n\t// mma\n\t// avg\n\n\tself.cache[key] = key[2] === 'm' ? value : [value, value];\n\treturn self;\n};\n\nCP.min = function(id, count) {\n\n\tvar self = this;\n\n\tif (id instanceof Array) {\n\t\tfor (var i = 0, length = id.length; i < length; i++)\n\t\t\tself.min(id[i], count);\n\t\treturn self;\n\t}\n\n\tvar key = 'mma' + NOW.getFullYear() + '' + id;\n\n\tif (self.cache && self.cache[key]) {\n\t\tvar arr = self.cache[key];\n\t\tif (arr[0] > count) // min\n\t\t\tarr[0] = count;\n\t\tif (arr[1] < count) // max\n\t\t\tarr[1] = count;\n\t} else\n\t\tself.empty(key, count);\n\n\tself.save();\n\tthis.$events.min && self.emit('min', id, count || 1);\n\treturn self;\n};\n\nCP.max = function(id, count) {\n\n\tvar self = this;\n\n\tif (id instanceof Array) {\n\t\tfor (var i = 0, length = id.length; i < length; i++)\n\t\t\tself.min(id[i], count);\n\t\treturn self;\n\t}\n\n\tvar key = 'mma' + NOW.getFullYear() + '' + id;\n\tif (self.cache && self.cache[key]) {\n\t\tvar arr = self.cache[key];\n\t\tif (arr[0] > count) // min\n\t\t\tarr[0] = count;\n\t\tif (arr[1] < count) // max\n\t\t\tarr[1] = count;\n\t} else\n\t\tself.empty(key, count);\n\n\n\tself.save();\n\tself.$events.max && self.emit('max', id, count || 1);\n\treturn self;\n};\n\nCP.inc = CP.hit = function(id, count) {\n\n\tvar self = this;\n\n\tif (id instanceof Array) {\n\t\tfor (var i = 0, length = id.length; i < length; i++)\n\t\t\tself.min(id[i], count);\n\t\treturn self;\n\t}\n\n\tvar key = 'sum' + NOW.getFullYear() + '' + id;\n\tif (self.cache && self.cache[key])\n\t\tself.cache[key] += count || 1;\n\telse\n\t\tself.empty(key, count || 1);\n\n\tself.save();\n\tthis.$events.sum && self.emit('sum', id, count || 1);\n\tthis.$events.hits && self.emit('hit', id, count || 1);\n\treturn self;\n};\n\nCP.remove = function(id) {\n\tvar self = this;\n\n\t!self.cache && (self.cache = {});\n\n\tif (id instanceof Array)\n\t\tid.forEach(n => self.cache[n] = null);\n\telse\n\t\tself.cache[id] = null;\n\n\tself.save();\n\tself.emit('remove', id);\n\treturn self;\n};\n\nCP.count = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 0;\n\toptions.id = id;\n\toptions.type = 'sum';\n\treturn this.read(options, callback);\n};\n\nCP.maximum = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 0;\n\toptions.id = id;\n\toptions.type = 'mma';\n\toptions.type2 = 'max';\n\treturn this.read(options, callback);\n};\n\nCP.minimum = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 0;\n\toptions.id = id;\n\toptions.type = 'mma';\n\toptions.type2 = 'min';\n\treturn this.read(options, callback);\n};\n\nCP.yearly = CP.yearly_sum = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 1;\n\toptions.id = id;\n\toptions.type = 'sum';\n\treturn this.read(options, callback);\n};\n\nCP.monthly = CP.monthly_sum = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 2;\n\toptions.id = id;\n\toptions.type = 'sum';\n\treturn this.read(options, callback);\n};\n\nCP.daily = CP.daily_sum = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 3;\n\toptions.id = id;\n\toptions.type = 'sum';\n\treturn this.read(options, callback);\n};\n\nCP.yearly_max = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 1;\n\toptions.id = id;\n\toptions.type = 'mma';\n\toptions.type2 = 'max';\n\treturn this.read(options, callback);\n};\n\nCP.monthly_max = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 2;\n\toptions.id = id;\n\toptions.type = 'mma';\n\toptions.type2 = 'max';\n\treturn this.read(options, callback);\n};\n\nCP.daily_max = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 3;\n\toptions.id = id;\n\toptions.type = 'mma';\n\toptions.type2 = 'max';\n\treturn this.read(options, callback);\n};\n\nCP.yearly_min = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 1;\n\toptions.id = id;\n\toptions.type = 'mma';\n\toptions.type2 = 'min';\n\treturn this.read(options, callback);\n};\n\nCP.monthly_min = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 2;\n\toptions.id = id;\n\toptions.type = 'mma';\n\toptions.type2 = 'min';\n\treturn this.read(options, callback);\n};\n\nCP.daily_min = function(id, callback) {\n\n\tif (typeof(id) === 'function') {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar options = {};\n\toptions.subtype = 3;\n\toptions.id = id;\n\toptions.type = 'mma';\n\toptions.type2 = 'min';\n\treturn this.read(options, callback);\n};\n\nCP.read = function(options, callback, reader) {\n\n\tvar self = this;\n\n\tif (self.type && reader === undefined) {\n\t\tsetTimeout(() => self.read(options, callback), 200);\n\t\treturn self;\n\t}\n\n\tself.type = 2;\n\n\tif (self.db.readonly) {\n\t\tif (reader === undefined) {\n\t\t\tU.download(self.db.filenameCounter, FLAGS_READ, function(err, response) {\n\t\t\t\tself.read(options, callback, err ? null : response);\n\t\t\t});\n\t\t\treturn self;\n\t\t}\n\t} else {\n\t\tF.stats.performance.open++;\n\t\treader = Fs.createReadStream(self.db.filenameCounter);\n\t}\n\n\t// 0 == options.subtype: summarize\n\t// 1 == options.subtype: full\n\n\tvar keys = {};\n\tvar single = false;\n\tvar all = options.id ? false : true;\n\tvar output = all && !options.subtype ? null : {};\n\n\tif (typeof(options.id) === 'string') {\n\t\toptions.id = [options.id];\n\t\tsingle = true;\n\t}\n\n\tif (options.id) {\n\t\tfor (var i = 0, length = options.id.length; i < length; i++)\n\t\t\tkeys[options.type + options.id[i]] = true;\n\t}\n\n\tif (reader) {\n\n\t\treader.on('error', function() {\n\t\t\tself.type = 0;\n\t\t\tcallback(null, single ? (options.subtype ? EMPTYARRAY : 0) : (all ? EMPTYARRAY : output));\n\t\t});\n\n\t\treader.on('data', framework_utils.streamer(NEWLINEBUF, function(value, index) {\n\n\t\t\tvar index = value.indexOf('=');\n\t\t\tvar key = value.substring(7, index);\n\t\t\tvar type = value.substring(0, 3);\n\n\t\t\tif (options.type !== type)\n\t\t\t\treturn;\n\n\t\t\tvar tmp;\n\t\t\tvar year = value.substring(3, 7);\n\n\t\t\tif (all || options.id === true || keys[type + key]) {\n\t\t\t\tswitch (options.subtype) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tvar val = value.substring(index + 1, value.indexOf(';'));\n\t\t\t\t\t\tswitch (options.type2 || options.type) {\n\t\t\t\t\t\t\tcase 'max':\n\t\t\t\t\t\t\t\tvar a = counter_minmax(options, val);\n\t\t\t\t\t\t\t\tif (all) {\n\t\t\t\t\t\t\t\t\tif (output == null)\n\t\t\t\t\t\t\t\t\t\toutput = a;\n\t\t\t\t\t\t\t\t\telse if (output < a)\n\t\t\t\t\t\t\t\t\t\toutput = a;\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\toutput[key] = a;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'min':\n\t\t\t\t\t\t\t\tvar a = counter_minmax(options, val);\n\t\t\t\t\t\t\t\tif (all) {\n\t\t\t\t\t\t\t\t\tif (output == null)\n\t\t\t\t\t\t\t\t\t\toutput = a;\n\t\t\t\t\t\t\t\t\telse if (output > a)\n\t\t\t\t\t\t\t\t\t\toutput = a;\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\toutput[key] = a;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'sum':\n\t\t\t\t\t\t\t\tif (all)\n\t\t\t\t\t\t\t\t\toutput = (output || 0) + (+val);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\toutput[key] = +val;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (all)\n\t\t\t\t\t\t\tcounter_parse_years_all(output, value, year, options);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp = counter_parse_years(value, year, options);\n\t\t\t\t\t\t\tif (output[key])\n\t\t\t\t\t\t\t\toutput[key].push.apply(output[key], tmp);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\toutput[key] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tif (all)\n\t\t\t\t\t\t\tcounter_parse_months_all(output, value, year, options);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp = counter_parse_months(value, year, options);\n\t\t\t\t\t\t\tif (output[key])\n\t\t\t\t\t\t\t\toutput[key].push.apply(output[key], tmp);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\toutput[key] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tif (all)\n\t\t\t\t\t\t\tcounter_parse_days_all(output, value, year, options);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp = counter_parse_days(value, year, options);\n\t\t\t\t\t\t\tif (output[key])\n\t\t\t\t\t\t\t\toutput[key].push.apply(output[key], tmp);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\toutput[key] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}\n\n\tvar finish = function() {\n\t\tself.type = 0;\n\t\t// Array conversation\n\t\tif (all && options.subtype) {\n\t\t\tvar tmp = [];\n\t\t\tvar keys;\n\t\t\tswitch (options.subtype) {\n\t\t\t\tcase 3: // daily\n\t\t\t\t\tkeys = Object.keys(output);\n\t\t\t\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\t\ttmp.push({ id: key, year: +key.substring(0, 4), month: +key.substring(4, 6), day: +key.substring(6, 8), value: output[key] });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2: // monthly\n\t\t\t\t\tkeys = Object.keys(output);\n\t\t\t\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\t\ttmp.push({ id: key, year: +key.substring(0, 4), month: +key.substring(4, 6), value: output[key] });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: // yearly\n\t\t\t\t\tkeys = Object.keys(output);\n\t\t\t\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\t\ttmp.push({ id: key, year: +key.substring(0, 4), value: output[key] });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutput = tmp;\n\t\t}\n\n\t\tcallback(null, single ? (options.subtype ? output[options.id[0]] || EMPTYARRAY : output[options.id[0]] || 0) : output);\n\t};\n\n\tif (reader)\n\t\treader.on('end', finish);\n\telse\n\t\tfinish();\n\n\treturn self;\n};\n\nCP.stats_max = function(top, year, month, day, callback) {\n\treturn this.stats(top, year, month, day, 'max', callback);\n};\n\nCP.stats_min = function(top, year, month, day, callback) {\n\treturn this.stats(top, year, month, day, 'min', callback);\n};\n\nCP.stats = CP.stats_sum = function(top, year, month, day, type, callback, reader) {\n\n\tvar self = this;\n\n\tif (self.type && reader === undefined) {\n\t\tsetTimeout(() => self.stats(top, year, month, day, type, callback), 200);\n\t\treturn self;\n\t}\n\n\tself.type = 3;\n\n\tif (self.db.readonly) {\n\t\tif (reader === undefined) {\n\t\t\tU.download(self.db.filenameCounter, FLAGS_READ, function(err, response) {\n\t\t\t\tif (err) {\n\t\t\t\t\tself.type = 0;\n\t\t\t\t\tcallback && callback(err, []);\n\t\t\t\t} else\n\t\t\t\t\tself.stats(top, year, month, day, type, callback, response);\n\t\t\t});\n\t\t\treturn self;\n\t\t}\n\t} else {\n\t\tF.stats.performance.open++;\n\t\treader = Fs.createReadStream(self.db.filenameCounter);\n\t}\n\n\tif (typeof(day) == 'function') {\n\t\tcallback = day;\n\t\tday = null;\n\t} else if (typeof(month) == 'function') {\n\t\tcallback = month;\n\t\tmonth = null;\n\t} else if (typeof(year) === 'function') {\n\t\tcallback = year;\n\t\tyear = month = null;\n\t}\n\n\tvar date = null;\n\tvar output = [];\n\n\tif (!type)\n\t\ttype = 'sum';\n\n\tif (year) {\n\t\tif (day) {\n\t\t\tdate = month.padLeft(2, '0') + day.padLeft(2, '0');\n\t\t\tdate = new RegExp(';' + date + '=[0-9X\\\\.]+', 'g');\n\t\t} else if (month) {\n\t\t\tdate = month.padLeft(2, '0') + '\\\\d{2}';\n\t\t\tdate = new RegExp(';' + date + '=[0-9X\\\\.]+', 'g');\n\t\t}\n\t}\n\n\treader.on('error', function() {\n\t\tself.type = 0;\n\t\tcallback && callback(null, output);\n\t});\n\n\tif (year > 0)\n\t\tyear = year.toString();\n\n\tvar opt = {};\n\n\tif (type !== 'sum') {\n\t\topt.type = 'mma';\n\t\topt.type2 = type;\n\t} else\n\t\topt.type = type;\n\n\treader.on('data', framework_utils.streamer(NEWLINEBUF, function(value, index) {\n\n\t\tvar index = value.indexOf('=');\n\t\tif (value.substring(0, 3) !== opt.type || (year && value.substring(3, 7) !== year))\n\t\t\treturn;\n\n\t\tvar count = null;\n\n\t\tif (date) {\n\t\t\tvar matches = value.match(date);\n\t\t\tif (!matches)\n\t\t\t\treturn;\n\t\t\tcount = counter_parse_stats(matches, opt);\n\t\t} else {\n\t\t\tvar val = value.substring(index + 1, value.indexOf(';', index));\n\t\t\tcount = opt.type2 ? counter_minmax(opt, val) : +val;\n\t\t}\n\n\t\tcount != null && counter_parse_stats_avg(output, top, value.substring(7, index), count, type, undefined, year == null && month == null && day == null);\n\t}));\n\n\treader.on('end', function() {\n\t\tself.type = 0;\n\t\toutput.sort(counter_sort_sum);\n\t\tcallback && callback(null, output);\n\t});\n\n\treturn self;\n};\n\nfunction counter_sort_sum(a, b) {\n\treturn a.count > b.count ? -1 : a.count === b.count ? 0 : 1;\n}\n\nfunction counter_sort_min(a, b) {\n\treturn a.count > b.count ? 1 : a.count === b.count ? 0 : -1;\n}\n\nfunction counter_parse_stats_avg(group, top, key, count, opt) {\n\n\tvar length = group.length;\n\n\tif (length < top) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (group[i].id === key) {\n\t\t\t\tgroup[i].count += count;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tgroup.push({ id: key, count: count });\n\t\tif (group.length === top) {\n\t\t\tswitch (opt.type2 || opt.type) {\n\t\t\t\tcase 'max':\n\t\t\t\tcase 'sum':\n\t\t\t\t\tgroup.sort(counter_sort_sum);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'min':\n\t\t\t\t\tgroup.sort(counter_sort_min);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (var i = 0; i < length; i++) {\n\t\tif (group[i].id === key) {\n\t\t\tgroup[i].count += count;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar item = group[i];\n\n\t\tif (opt.type === 'min') {\n\t\t\tif (item.count < count)\n\t\t\t\tcontinue;\n\t\t} else if (item.count > count)\n\t\t\tcontinue;\n\n\t\tfor (var j = length - 1; j > i; j--) {\n\t\t\tgroup[j].id = group[j - 1].id;\n\t\t\tgroup[j].count = group[j - 1].count;\n\t\t}\n\n\t\titem.id = key;\n\t\titem.count = count;\n\t\treturn;\n\t}\n}\n\nfunction counter_parse_stats(matches, opt) {\n\n\tvar value = null;\n\n\tfor (var i = 0, length = matches.length; i < length; i++) {\n\t\tvar item = matches[i];\n\t\tvar val = item.substring(item.indexOf('=', 3) + 1);\n\n\t\tswitch (opt.type2 || opt.type) {\n\t\t\tcase 'max':\n\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\tif (value == null)\n\t\t\t\t\tvalue = a;\n\t\t\t\telse if (value < a)\n\t\t\t\t\tvalue = a;\n\t\t\t\tbreak;\n\t\t\tcase 'min':\n\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\tif (value == null)\n\t\t\t\t\tvalue = a;\n\t\t\t\telse if (value > a)\n\t\t\t\t\tvalue = a;\n\t\t\t\tbreak;\n\t\t\tcase 'sum':\n\t\t\t\tvalue += +val;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn value;\n}\n\nfunction counter_minmax(opt, val) {\n\tvar index = val.indexOf('X');\n\tswitch (opt.type2) {\n\t\tcase 'min':\n\t\t\treturn +val.substring(0, index);\n\t\tcase 'max':\n\t\t\treturn +val.substring(index + 1);\n\t\tcase 'avg':\n\t\t\treturn ((+val.substring(0, index)) + (+val.substring(index + 1))) / 2;\n\t}\n}\n\nfunction counter_parse_years(value, year, opt) {\n\n\tvar arr = value.trim().split(';');\n\tvar tmp = {};\n\n\tfor (var i = 1, length = arr.length; i < length; i++) {\n\t\tvar val = arr[i].substring(5);\n\t\tif (tmp[year]) {\n\t\t\tswitch (opt.type2 || opt.type) {\n\t\t\t\tcase 'max':\n\t\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\t\tif (tmp[year].value < a)\n\t\t\t\t\t\ttmp[year].value = a;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'min':\n\t\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\t\tif (tmp[year].value > a)\n\t\t\t\t\t\ttmp[year].value = a;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sum':\n\t\t\t\t\ttmp[year].value += +val;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\ttmp[year] = { id: year, year: +year, value: opt.type2 ? counter_minmax(opt, val) : +val };\n\t}\n\n\tvar output = [];\n\tvar keys = Object.keys(tmp);\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\toutput.push(tmp[keys[i]]);\n\n\treturn output;\n}\n\nfunction counter_parse_months(value, year, opt) {\n\n\tvar arr = value.trim().split(';');\n\tvar tmp = {};\n\n\tfor (var i = 1, length = arr.length; i < length; i++) {\n\t\tvar val = arr[i].substring(5);\n\t\tvar key = year + arr[i].substring(0, 2);\n\n\t\tif (tmp[key]) {\n\t\t\tswitch (opt.type2 || opt.type) {\n\t\t\t\tcase 'max':\n\t\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\t\tif (tmp[key].value < a)\n\t\t\t\t\t\ttmp[key].value = a;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'min':\n\t\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\t\tif (tmp[key].value > a)\n\t\t\t\t\t\ttmp[key].value = a;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sum':\n\t\t\t\t\ttmp[key].value += +val;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\ttmp[key] = { id: key, year: +year, month: +key.substring(4), value: opt.type2 ? counter_minmax(opt, val) : +val };\n\t}\n\n\tvar output = [];\n\tvar keys = Object.keys(tmp);\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\toutput.push(tmp[keys[i]]);\n\n\treturn output;\n}\n\nfunction counter_parse_days(value, year, opt) {\n\n\tvar arr = value.trim().split(';');\n\tvar tmp = {};\n\n\tfor (var i = 1, length = arr.length; i < length; i++) {\n\t\tvar val = arr[i].substring(5);\n\t\tvar key = year + arr[i].substring(0, 4);\n\n\t\tif (tmp[key]) {\n\t\t\tswitch (opt.type2 || opt.type) {\n\t\t\t\tcase 'max':\n\t\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\t\tif (tmp[key].value < a)\n\t\t\t\t\t\ttmp[key].value = a;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'min':\n\t\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\t\tif (tmp[key].value > a)\n\t\t\t\t\t\ttmp[key].value = a;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sum':\n\t\t\t\t\ttmp[key].value += +val;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\ttmp[key] = { id: key, year: +year, month: +key.substring(4, 6), day: +key.substring(6), value: opt.type2 ? counter_minmax(opt, val) : +val };\n\t}\n\n\tvar output = [];\n\tvar keys = Object.keys(tmp);\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\toutput.push(tmp[keys[i]]);\n\treturn output;\n}\n\nfunction counter_parse_years_all(output, value, year, opt) {\n\tvar arr = value.trim().split(';');\n\tfor (var i = 1, length = arr.length; i < length; i++) {\n\n\t\tvar val = arr[i].substring(5);\n\n\t\tif (!output[year]) {\n\t\t\toutput[year] = opt.type2 ? counter_minmax(opt, val) : +val;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (opt.type2 || opt.type) {\n\t\t\tcase 'max':\n\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\tif (output[year] < a)\n\t\t\t\t\toutput[year] = a;\n\t\t\t\tbreak;\n\t\t\tcase 'min':\n\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\tif (output[year] > a)\n\t\t\t\t\toutput[year] = a;\n\t\t\t\tbreak;\n\t\t\tcase 'sum':\n\t\t\t\toutput[year] += +val;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction counter_parse_months_all(output, value, year, opt) {\n\tvar arr = value.trim().split(';');\n\n\tfor (var i = 1, length = arr.length; i < length; i++) {\n\t\tvar val = arr[i].substring(5);\n\t\tvar key = year + arr[i].substring(0, 2);\n\n\t\tif (!output[key]) {\n\t\t\toutput[key] = opt.type2 ? counter_minmax(opt, val) : +val;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (opt.type2 || opt.type) {\n\t\t\tcase 'max':\n\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\tif (output[year] < a)\n\t\t\t\t\toutput[year] = a;\n\t\t\t\tbreak;\n\t\t\tcase 'min':\n\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\tif (output[year] > a)\n\t\t\t\t\toutput[year] = a;\n\t\t\t\tbreak;\n\t\t\tcase 'sum':\n\t\t\t\toutput[key] += +val;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction counter_parse_days_all(output, value, year, opt) {\n\tvar arr = value.trim().split(';');\n\tfor (var i = 1, length = arr.length; i < length; i++) {\n\t\tvar val = arr[i].substring(5);\n\t\tvar key = year + arr[i].substring(0, 4);\n\n\t\tif (!output[key]) {\n\t\t\toutput[key] = opt.type2 ? counter_minmax(opt, val) : +val;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (opt.type2 || opt.type) {\n\t\t\tcase 'max':\n\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\tif (output[year] < a)\n\t\t\t\t\toutput[year] = a;\n\t\t\t\tbreak;\n\t\t\tcase 'min':\n\t\t\t\tvar a = counter_minmax(opt, val);\n\t\t\t\tif (output[year] > a)\n\t\t\t\t\toutput[year] = a;\n\t\t\t\tbreak;\n\t\t\tcase 'sum':\n\t\t\t\toutput[key] += +val;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nCP.save = function() {\n\tvar self = this;\n\t!self.tid && (self.tid = setTimeout(self.$cb_save, self.TIMEOUT));\n\treturn self;\n};\n\nCP.reset = function(countertype, counterid, date, callback) {\n\n\tvar self = this;\n\n\tif (self.type) {\n\t\tsetTimeout((countertype, counterid, date, callback) => self.reset(countertype, counterid, date, callback), 200, countertype, counterid, date, callback);\n\t\treturn self;\n\t}\n\n\tif (date)\n\t\tdate = date.split('-');\n\n\tvar allow = null;\n\n\tif (countertype) {\n\t\tif (!(countertype instanceof Array))\n\t\t\tcountertype = [countertype];\n\t\tallow = {};\n\t\tfor (var i = 0; i < countertype.length; i++)\n\t\t\tallow[countertype[i]] = 1;\n\t}\n\n\tself.db.readonly && self.db.throwReadonly();\n\tF.stats.performance.open++;\n\n\tvar filename = self.db.filenameCounter;\n\tvar reader = Fs.createReadStream(filename);\n\tvar writer = Fs.createWriteStream(filename + '-tmp');\n\tvar counter = 0;\n\n\tself.type = 4;\n\n\treader.on('data', framework_utils.streamer(NEWLINEBUF, function(value) {\n\n\t\tvar id = value.substring(0, value.indexOf('='));\n\t\t// 0 === typeYEARid=COUNT\n\t\t// N === MMdd=COUNT\n\n\t\tvar arr = value.trim().split(';');\n\t\tvar type = id.substring(0, 3);\n\t\tvar year = id.substring(3, 7);\n\n\t\tif (counterid && counterid !== id.substring(7)) {\n\t\t\twriter.write(arr.join(';') + NEWLINE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (allow && !allow[type]) {\n\t\t\tif (type === 'mma' && !allow.min && !allow.max) {\n\t\t\t\twriter.write(arr.join(';') + NEWLINE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (date) {\n\t\t\tif (date[0] !== year) {\n\t\t\t\twriter.write(arr.join(';') + NEWLINE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tvar values = [];\n\n\t\tfor (var i = 1; i < arr.length; i++) {\n\n\t\t\tvar stat = arr[i].split('=');\n\t\t\tvar statcount;\n\n\t\t\tif (type === 'mma') {\n\t\t\t\tstatcount = stat[1].split('X');\n\t\t\t\tstatcount[0] = +statcount[0];\n\t\t\t\tstatcount[1] = +statcount[1];\n\t\t\t} else\n\t\t\t\tstatcount = +stat[1];\n\n\t\t\tif (date && ((date[1] && stat[0].substring(0, 2) !== date[1]) || (date[2] && stat[0].substring(2, 4) !== date[2]))) {\n\t\t\t\tif (type === 'mma')\n\t\t\t\t\tvalues.push(statcount[0], statcount[1]);\n\t\t\t\telse\n\t\t\t\t\tvalues.push(statcount);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (allow && type === 'mma') {\n\t\t\t\tif (allow.min) {\n\t\t\t\t\tstat[1] = '0X' + statcount[1];\n\t\t\t\t\tarr[i] = stat.join('=');\n\t\t\t\t\tvalues.push(statcount[1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (allow.max) {\n\t\t\t\t\tstat[1] = statcount[0] + 'X0';\n\t\t\t\t\tarr[i] = stat.join('=');\n\t\t\t\t\tvalues.push(statcount[0]);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// reset entire mma\n\t\t\t\t\tvalues.push(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstat[1] = type === 'mma' ? '0X0' : '0';\n\n\t\t\tif (stat[1] === '0X0' || stat[1] === '0') {\n\t\t\t\tarr.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t} else\n\t\t\t\tarr[i] = stat.join('=');\n\t\t}\n\n\t\tvar min = null;\n\t\tvar max = null;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\tvar val = values[i];\n\n\t\t\tif (min == null)\n\t\t\t\tmin = val;\n\t\t\telse if (min > val)\n\t\t\t\tmin = val;\n\n\t\t\tif (max == null)\n\t\t\t\tmax = val;\n\t\t\telse if (max < val)\n\t\t\t\tmax = val;\n\n\t\t\tsum += val;\n\t\t}\n\n\t\tvar tmp = arr[0].split('=');\n\t\ttmp[1] = (type === 'mma' ? ((min || 0) + 'X' + (max || 0)) : ((sum || 0) + ''));\n\t\tarr[0] = tmp.join('=');\n\n\t\tif (arr.length > 1)\n\t\t\twriter.write(arr.join(';') + NEWLINE);\n\n\t\tcounter++;\n\t}));\n\n\tvar flush = () => writer.end();\n\n\treader.on('error', flush);\n\treader.on('end', flush);\n\n\tCLEANUP(writer, function() {\n\t\tFs.rename(filename + '-tmp', filename, function() {\n\t\t\tF.isCluster && clusterunlock(self);\n\t\t\tclearTimeout(self.timeout);\n\t\t\tself.timeout = 0;\n\t\t\tself.type = 0;\n\t\t\tcounter && self.$events.stats && setImmediate(() => self.emit('stats', counter));\n\t\t\tcallback && callback(null, counter);\n\t\t});\n\t});\n\n\treturn self;\n};\n\nCP.$save = function() {\n\n\tvar self = this;\n\n\tself.tid && clearTimeout(self.tid);\n\tself.db.readonly && self.db.throwReadonly();\n\n\tif (self.type) {\n\t\tsetTimeout(() => self.save(), 200);\n\t\treturn self;\n\t}\n\n\tF.stats.performance.open++;\n\n\tvar filename = self.db.filenameCounter;\n\tvar reader = Fs.createReadStream(filename);\n\tvar writer = Fs.createWriteStream(filename + '-tmp');\n\tvar dt = NOW.format('MMdd') + '=';\n\tvar cache = self.cache;\n\tvar counter = 0;\n\n\tself.cache = null;\n\tself.type = 1;\n\n\tvar flush = function() {\n\t\tvar keys = Object.keys(cache);\n\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\tvar item = cache[keys[i]];\n\t\t\tif (item != null) {\n\t\t\t\tvar val = (item instanceof Array ? (item[0] + 'X' + item[1]) : item);\n\t\t\t\twriter.write(keys[i] + '=' + val + ';' + dt + val + NEWLINE);\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\twriter.end();\n\t};\n\n\treader.on('data', framework_utils.streamer(NEWLINEBUF, function(value) {\n\n\t\tvar id = value.substring(0, value.indexOf('='));\n\t\tvar count = cache[id];\n\n\t\tif (count === null)\n\t\t\treturn;\n\n\t\tif (count === undefined) {\n\t\t\twriter.write(value);\n\t\t\treturn;\n\t\t}\n\n\t\t// 0 === typeYEARid=COUNT\n\t\t// N === MMdd=COUNT\n\n\t\tvar arr = value.trim().split(';');\n\t\tvar is = false;\n\t\tvar index = arr[0].indexOf('=');\n\t\tvar type = id.substring(0, 3);\n\n\t\t// Update summarization\n\t\tswitch (type) {\n\t\t\tcase 'mma': // min, max, avg\n\t\t\t\tvar tmp = arr[0].substring(index + 1);\n\t\t\t\tvar tmpi = tmp.indexOf('X');\n\t\t\t\tCOUNTER_MMA[0] = +tmp.substring(0, tmpi);\n\t\t\t\tCOUNTER_MMA[1] = +tmp.substring(tmpi + 1);\n\t\t\t\tif (COUNTER_MMA[0] > count[0]) // min\n\t\t\t\t\tCOUNTER_MMA[0] = count[0];\n\t\t\t\tif (COUNTER_MMA[1] < count[1]) // max\n\t\t\t\t\tCOUNTER_MMA[1] = count[1];\n\t\t\t\tarr[0] = arr[0].substring(0, index + 1) + COUNTER_MMA[0] + 'X' + COUNTER_MMA[1];\n\t\t\t\tbreak;\n\t\t\tcase 'max':\n\t\t\t\tarr[0] = arr[0].substring(0, index + 1) + Math.max(+arr[0].substring(index + 1), count);\n\t\t\t\tbreak;\n\t\t\tcase 'min':\n\t\t\t\tarr[0] = arr[0].substring(0, index + 1) + Math.min(+arr[0].substring(index + 1), count);\n\t\t\t\tbreak;\n\t\t\tcase 'sum':\n\t\t\t\tarr[0] = arr[0].substring(0, index + 1) + (+arr[0].substring(index + 1) + count);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfor (var i = 1, length = arr.length; i < length; i++) {\n\n\t\t\tvar item = arr[i];\n\t\t\tvar curr = item.substring(0, 5); // MMdd\n\n\t\t\tif (curr === dt) {\n\t\t\t\tis = true;\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'mma':\n\t\t\t\t\t\tvar tmp = item.substring(5);\n\t\t\t\t\t\tvar tmpi = tmp.indexOf('X');\n\t\t\t\t\t\tCOUNTER_MMA[0] = +tmp.substring(0, tmpi);\n\t\t\t\t\t\tCOUNTER_MMA[1] = +tmp.substring(tmpi + 1);\n\t\t\t\t\t\tif (COUNTER_MMA[0] > count[0]) // min\n\t\t\t\t\t\t\tCOUNTER_MMA[0] = count[0];\n\t\t\t\t\t\tif (COUNTER_MMA[1] < count[1]) // max\n\t\t\t\t\t\t\tCOUNTER_MMA[1] = count[1];\n\t\t\t\t\t\tarr[i] = curr + COUNTER_MMA[0] + 'X' + COUNTER_MMA[1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'sum':\n\t\t\t\t\t\tarr[i] = curr + (+item.substring(5) + count);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcache[id] = undefined;\n\t\t!is && arr.push(dt + (count instanceof Array ? (count[0] + 'X' + count[1]) : count));\n\t\twriter.write(arr.join(';') + NEWLINE);\n\t\tcounter++;\n\t}));\n\n\treader.on('error', flush);\n\treader.on('end', flush);\n\n\tCLEANUP(writer, function() {\n\t\tFs.rename(filename + '-tmp', filename, function() {\n\t\t\tF.isCluster && clusterunlock(self);\n\t\t\tclearTimeout(self.timeout);\n\t\t\tself.timeout = 0;\n\t\t\tself.type = 0;\n\t\t\tcounter && self.$events.stats && setImmediate(() => self.emit('stats', counter));\n\t\t});\n\t});\n\n\treturn self;\n};\n\nCP.clear = function(callback) {\n\tvar self = this;\n\n\tif (self.type) {\n\t\tsetTimeout(() => self.clear(callback), 200);\n\t\treturn self;\n\t}\n\n\tself.type = 3;\n\n\tFs.unlink(self.db.filename + EXTENSION_COUNTER, function() {\n\t\tself.type = 0;\n\t\tself.emit('clear');\n\t\tcallback && callback();\n\t});\n\n\treturn self;\n};\n\nfunction Binary(db, directory, ext) {\n\tvar t = this;\n\tt.db = db;\n\tt.ext = ext || EXTENSION_BINARY;\n\tt.directory = directory;\n\tt.$events = {};\n\tt.metafile = directory + 'meta.json';\n\tt.meta = { $version: 1, updated: NOW };\n\tt.cachekey = 'nobin_' + db.name + '_';\n\tt.logger = directory + '/files.log';\n\tt.$refresh();\n}\n\nBinary.prototype.$refresh = function() {\n\tthis.meta.index = 0;\n\tthis.meta.count = 0;\n\tthis.meta.free = [];\n\ttry {\n\t\tvar json = Fs.readFileSync(this.metafile, 'utf8').toString();\n\t\tif (json.length) {\n\t\t\tvar config = JSON.parse(json, jsonparser);\n\t\t\tthis.meta.index = config.index;\n\t\t\tthis.meta.count = config.count;\n\t\t\tthis.meta.free = config.free || [];\n\t\t\tthis.meta.updated = config.updated || NOW;\n\t\t}\n\t} catch(e) {}\n};\n\nBinary.prototype.$save = function() {\n\tvar self = this;\n\tself.check();\n\tself.meta.updated = NOW;\n\tFs.writeFile(self.metafile, JSON.stringify(self.meta), F.error());\n\treturn self;\n};\n\nBinary.prototype.$directoryindex = function(index) {\n\treturn Math.floor(index / 1000) + 1;\n};\n\nBinary.prototype.$directory = function(index, dir) {\n\tvar self = this;\n\tvar id = (dir ? index : self.$directoryindex(index)).toString().padLeft(DIRECTORYLENGTH, '0');\n\tvar length = id.length;\n\tvar directory = '';\n\n\tfor (var i = 0; i < length; i++)\n\t\tdirectory += (i % 3 === 0 && i > 0 ? '-' : '') + id[i];\n\n\treturn Path.join(self.directory, directory);\n};\n\nBinary.prototype.emit = function(name, a, b, c, d, e, f, g) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nBinary.prototype.on = function(name, fn) {\n\n\tif (!fn.$once)\n\t\tthis.db.$free = false;\n\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nBinary.prototype.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nBinary.prototype.removeListener = function(name, fn) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tthis.$events[name] = evt;\n\t\telse\n\t\t\tthis.$events[name] = undefined;\n\t}\n\treturn this;\n};\n\nBinary.prototype.removeAllListeners = function(name) {\n\tif (name === true)\n\t\tthis.$events = EMPTYOBJECT;\n\telse if (name)\n\t\tthis.$events[name] = undefined;\n\telse\n\t\tthis.$events = {};\n\treturn this;\n};\n\nBinary.prototype.insert = function(name, buffer, custom, callback) {\n\n\tvar self = this;\n\tvar type = framework_utils.getContentType(framework_utils.getExtension(name));\n\n\tif (buffer && !(buffer instanceof Buffer)) {\n\t\tif (typeof(buffer) === 'function') {\n\t\t\tcallback = buffer;\n\t\t\tbuffer = custom = null;\n\t\t} else if (!buffer.resume) {\n\t\t\tcallback = custom;\n\t\t\tcustom = buffer;\n\t\t\tbuffer = null;\n\t\t}\n\n\t\tif (typeof(custom) === 'function') {\n\t\t\tcallback = custom;\n\t\t\tcustom = null;\n\t\t}\n\n\t} else if (typeof(custom) === 'function') {\n\t\tcallback = custom;\n\t\tcustom = null;\n\t}\n\n\tif (name.length > 80)\n\t\tname = name.substring(0, 80) + name.substring(name.lastIndexOf('.'));\n\n\tif (!buffer) {\n\t\tF.stats.performance.open++;\n\t\tvar reader = Fs.createReadStream(name);\n\t\tCLEANUP(reader);\n\t\treturn self.insertstream(null, framework_utils.getName(name), type, reader, callback, custom);\n\t}\n\n\tif (typeof(buffer) === 'string')\n\t\tbuffer = Buffer.from(buffer, 'base64');\n\telse if (buffer.resume)\n\t\treturn self.insertstream(null, name, type, buffer, callback, custom);\n\n\tvar size = buffer.length;\n\tvar dimension;\n\tvar ext = framework_utils.getExtension(name);\n\n\tswitch (ext) {\n\t\tcase 'gif':\n\t\t\tdimension = framework_image.measureGIF(buffer);\n\t\t\tbreak;\n\t\tcase 'png':\n\t\t\tdimension = framework_image.measurePNG(buffer);\n\t\t\tbreak;\n\t\tcase 'jpg':\n\t\tcase 'jpeg':\n\t\t\tdimension = framework_image.measureJPG(buffer);\n\t\t\tbreak;\n\t\tcase 'svg':\n\t\t\tdimension = framework_image.measureSVG(buffer);\n\t\t\tbreak;\n\t}\n\n\tvar time = NOW.format('yyyyMMdd');\n\tvar h = { name: name, size: size, type: type, date: time };\n\n\tif (custom)\n\t\th.custom = custom;\n\n\tif (dimension) {\n\t\tif (dimension.width)\n\t\t\th.width = dimension.width;\n\n\t\tif (dimension.height)\n\t\t\th.height = dimension.height;\n\t}\n\n\tvar header = Buffer.alloc(BINARY_HEADER_LENGTH);\n\theader.fill(' ');\n\theader.write(JSON.stringify(h));\n\n\tvar id;\n\n\tif (self.meta.free.length && (!F.id || F.id === '0')) {\n\t\tid = self.meta.free.shift();\n\t} else {\n\t\tself.meta.index++;\n\t\tid = self.meta.index;\n\t}\n\n\tself.meta.count++;\n\tF.isCluster && cluster_send({ TYPE: 'filestorage', NAME: self.db.name, method: 'add', index: self.meta.index, count: self.meta.count });\n\n\tvar path = self.$directory(id);\n\tself.check(path);\n\n\tif (!F.id || F.id === '0')\n\t\tself.$save();\n\n\tvar filename = id.toString().padLeft(DIRECTORYLENGTH, '0');\n\tvar stream = Fs.createWriteStream(Path.join(path, filename + self.ext));\n\n\tstream.write(header, 'binary');\n\tstream.end(buffer);\n\tCLEANUP(stream);\n\n\tid = 'B' + time + 'T' + filename;\n\tcallback && callback(null, id, h);\n\tself.$events.insert && self.emit('insert', id, h);\n\treturn id;\n};\n\nBinary.prototype.insertstream = function(id, name, type, stream, callback, custom) {\n\n\tvar self = this;\n\tvar time = NOW.format('yyyyMMdd');\n\tvar h = { name: name, size: 0, type: type, date: time };\n\n\tif (custom)\n\t\th.custom = custom;\n\n\tvar header = Buffer.alloc(BINARY_HEADER_LENGTH);\n\n\theader.fill(' ');\n\theader.write(JSON.stringify(h));\n\n\tvar isnew = false;\n\tvar cacheid = id;\n\n\tif (id) {\n\t\t// check if it's new implementation\n\t\tif (id > 0) {\n\t\t\tisnew = true;\n\t\t} else if (id[0] === 'B' || id[0] === 'b') {\n\t\t\tisnew = true;\n\t\t\tid = +id.substring(id.length - DIRECTORYLENGTH);\n\t\t}\n\t} else {\n\t\tisnew = true;\n\t\tif (self.meta.free.length && (!F.id || F.id === '0')) {\n\t\t\tid = self.meta.free.shift();\n\t\t} else {\n\t\t\tself.meta.index++;\n\t\t\tid = self.meta.index;\n\t\t}\n\t\tself.meta.count++;\n\t\tF.isCluster && cluster_send({ TYPE: 'filestorage', NAME: self.db.name, method: 'add', index: self.meta.index, count: self.meta.count });\n\t\tif (!F.id || F.id === '0')\n\t\t\tself.$save();\n\t}\n\n\tvar filepath;\n\tvar filename;\n\n\tif (isnew) {\n\t\tvar path = self.$directory(id);\n\t\tself.check(path);\n\t\tfilename = id.toString().padLeft(DIRECTORYLENGTH, '0');\n\t\tfilepath = Path.join(path, filename + self.ext);\n\t} else\n\t\tfilepath = framework_utils.join(self.directory, self.db.name + '#' + id + self.ext);\n\n\tvar writer = Fs.createWriteStream(filepath);\n\twriter.write(header, 'binary');\n\n\tvar ext = framework_utils.getExtension(name);\n\tvar dimension = null;\n\n\tIMAGES[ext] && stream.once('data', function(buffer) {\n\t\tswitch (ext) {\n\t\t\tcase 'gif':\n\t\t\t\tdimension = framework_image.measureGIF(buffer);\n\t\t\t\tbreak;\n\t\t\tcase 'png':\n\t\t\t\tdimension = framework_image.measurePNG(buffer);\n\t\t\t\tbreak;\n\t\t\tcase 'jpg':\n\t\t\tcase 'jpeg':\n\t\t\t\tdimension = framework_image.measureJPG(buffer);\n\t\t\t\tbreak;\n\t\t\tcase 'svg':\n\t\t\t\tdimension = framework_image.measureSVG(buffer);\n\t\t\t\tbreak;\n\t\t}\n\t});\n\n\tstream.pipe(writer);\n\n\tif (isnew)\n\t\tid = 'B' + time + 'T' + filename;\n\n\tCLEANUP(writer, function() {\n\n\t\tif (dimension) {\n\t\t\tif (dimension.width)\n\t\t\t\th.width = dimension.width;\n\t\t\tif (dimension.height)\n\t\t\t\th.height = dimension.height;\n\t\t}\n\n\t\th.size = writer.bytesWritten;\n\n\t\tFs.open(filepath, 'r+', function(err, fd) {\n\t\t\tif (!err) {\n\t\t\t\tvar header = Buffer.alloc(BINARY_HEADER_LENGTH);\n\t\t\t\theader.fill(' ');\n\t\t\t\theader.write(JSON.stringify(h));\n\t\t\t\tFs.write(fd, header, 0, header.length, 0, () => Fs.close(fd, NOOP));\n\t\t\t}\n\t\t});\n\n\t\tcallback && callback(null, cacheid || id, h);\n\t\tself.$events.insert && self.emit('insert', cacheid || id, h);\n\t});\n\n\treturn cacheid || id;\n};\n\nBinary.prototype.makedirectory = function(id) {\n\n\tvar val = (HASH(id, true) % 10000) + '';\n\tvar diff = 4 - val.length;\n\n\tif (diff > 0) {\n\t\tfor (var i = 0; i < diff; i++)\n\t\t\tval = '0' + val;\n\t}\n\n\tif (diff.length > 4)\n\t\tval = val.substring(0, 4);\n\n\treturn Path.join(this.directory, val);\n};\n\nBinary.prototype.append = Binary.prototype.save = function(id, name, filename, callback, custom) {\n\n\tif (typeof(filename) === 'function' || filename == null) {\n\t\tcustom = callback;\n\t\tcallback = filename;\n\t\tfilename = name;\n\t\tname = U.getName(filename);\n\t}\n\n\tvar self = this;\n\tvar directory = self.makedirectory(id);\n\tvar filenameto = Path.join(directory, id + '.file');\n\tvar cachekey = self.cachekey + directory;\n\n\tvar index = name.lastIndexOf('/');\n\tif (index !== -1)\n\t\tname = name.substring(index + 1);\n\n\tif (F.temporary.other[cachekey]) {\n\t\tself.saveforce(id, name, filename, filenameto, callback, custom);\n\t} else {\n\t\tFs.mkdir(directory, MKDIR, function(err) {\n\t\t\tif (err)\n\t\t\t\tcallback(err);\n\t\t\telse {\n\t\t\t\tF.temporary.other[cachekey] = 1;\n\t\t\t\tself.saveforce(id, name, filename, filenameto, callback, custom);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn self;\n};\n\nBinary.prototype.saveforce = function(id, name, filename, filenameto, callback, custom) {\n\n\tif (!callback)\n\t\tcallback = NOOP;\n\n\tF.stats.performance.open++;\n\tvar isbuffer = filename instanceof Buffer;\n\tvar self = this;\n\tvar header = Buffer.alloc(BINARY_HEADER_LENGTH, ' ');\n\tvar reader = isbuffer ? null : filename instanceof Readable ? filename : Fs.createReadStream(filename);\n\tvar writer = Fs.createWriteStream(filenameto);\n\n\tvar ext = U.getExtension(name);\n\tvar meta = { name: name, size: 0, width: 0, height: 0, ext: ext, custom: custom, type: U.getContentType(ext) };\n\tvar tmp;\n\n\twriter.write(header, 'binary');\n\n\tif (IMAGES[meta.ext]) {\n\t\treader.once('data', function(buffer) {\n\t\t\tswitch (meta.ext) {\n\t\t\t\tcase 'gif':\n\t\t\t\t\ttmp = framework_image.measureGIF(buffer);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'png':\n\t\t\t\t\ttmp = framework_image.measurePNG(buffer);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'jpg':\n\t\t\t\tcase 'jpeg':\n\t\t\t\t\ttmp = framework_image.measureJPG(buffer);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'svg':\n\t\t\t\t\ttmp = framework_image.measureSVG(buffer);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tif (isbuffer)\n\t\twriter.end(filename);\n\telse\n\t\treader.pipe(writer);\n\n\tCLEANUP(writer, function() {\n\n\t\tFs.open(filenameto, 'r+', function(err, fd) {\n\n\t\t\tif (err) {\n\t\t\t\t// Unhandled error\n\t\t\t\tcallback(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (tmp) {\n\t\t\t\tmeta.width = tmp.width;\n\t\t\t\tmeta.height = tmp.height;\n\t\t\t}\n\n\t\t\tmeta.size = writer.bytesWritten - BINARY_HEADER_LENGTH;\n\n\t\t\tself.total++;\n\t\t\tself.size += meta.size;\n\n\t\t\tif (meta.name.length > 250)\n\t\t\t\tmeta.name = meta.name.substring(0, 250);\n\n\t\t\theader.write(JSON.stringify(meta));\n\n\t\t\t// Update header\n\t\t\tFs.write(fd, header, 0, header.length, 0, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t\tFs.close(fd, NOOP);\n\t\t\t\t} else {\n\t\t\t\t\tmeta.id = id;\n\t\t\t\t\tmeta.date = NOW = new Date();\n\t\t\t\t\tmeta.type = 'save';\n\t\t\t\t\tFs.appendFile(self.logger, JSON.stringify(meta) + '\\n', NOOP);\n\t\t\t\t\tFs.close(fd, () => callback(null, meta));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n};\n\nBinary.prototype.update = function(id, name, buffer, custom, callback) {\n\n\tvar type = framework_utils.getContentType(framework_utils.getExtension(name));\n\tvar self = this;\n\tvar isfn = typeof(buffer) === 'function';\n\n\tif (buffer && !(buffer instanceof Buffer)) {\n\t\tif (typeof(buffer) === 'function') {\n\t\t\tcallback = buffer;\n\t\t\tbuffer = custom = null;\n\t\t} else if (!buffer.resume) {\n\t\t\tcallback = custom;\n\t\t\tcustom = buffer;\n\t\t\tbuffer = null;\n\t\t}\n\t} else if (typeof(custom) === 'function') {\n\t\tcallback = custom;\n\t\tcustom = null;\n\t}\n\n\tif (name.length > 80)\n\t\tname = name.substring(0, 80) + name.substring(name.lastIndexOf('.'));\n\n\tif (!buffer) {\n\n\t\tif (isfn) {\n\t\t\tcallback = buffer;\n\t\t\tbuffer = undefined;\n\t\t}\n\n\t\tF.stats.performance.open++;\n\t\tvar reader = Fs.createReadStream(name);\n\t\tCLEANUP(reader);\n\t\treturn self.insertstream(id, framework_utils.getName(name), type, reader, callback, custom);\n\t}\n\n\tif (typeof(buffer) === 'string')\n\t\tbuffer = Buffer.from(buffer, 'base64');\n\n\tif (buffer.resume)\n\t\treturn self.insertstream(id, name, type, buffer, callback, custom);\n\n\tvar isnew = false;\n\tvar time = NOW.format('yyyyMMdd');\n\tvar size = buffer.length;\n\tvar ext = framework_utils.getExtension(name);\n\tvar dimension;\n\tvar filepath;\n\tvar filename;\n\tvar cacheid = id;\n\n\t// check if it's new implementation\n\tif (id > 0)\n\t\tisnew = true;\n\telse if (id[0] === 'B' || id[0] === 'b') {\n\t\tisnew = true;\n\t\tid = +id.substring(id.length - DIRECTORYLENGTH);\n\t}\n\n\tif (isnew) {\n\t\tvar path = self.$directory(id);\n\t\tself.check(path);\n\t\tfilename = id.toString().padLeft(DIRECTORYLENGTH, '0');\n\t\tfilepath = Path.join(path, filename + self.ext);\n\t} else {\n\t\tself.check();\n\t\tfilepath = framework_utils.join(self.directory, self.db.name + '#' + id + self.ext);\n\t}\n\n\tswitch (ext) {\n\t\tcase 'gif':\n\t\t\tdimension = framework_image.measureGIF(buffer);\n\t\t\tbreak;\n\t\tcase 'png':\n\t\t\tdimension = framework_image.measurePNG(buffer);\n\t\t\tbreak;\n\t\tcase 'jpg':\n\t\tcase 'jpeg':\n\t\t\tdimension = framework_image.measureJPG(buffer);\n\t\t\tbreak;\n\t\tcase 'svg':\n\t\t\tdimension = framework_image.measureSVG(buffer);\n\t\t\tbreak;\n\t}\n\n\tvar h = { name: name, size: size, type: type, date: time };\n\n\tif (custom)\n\t\th.custom = custom;\n\n\tif (dimension) {\n\t\tif (dimension.width)\n\t\t\th.width = dimension.width;\n\n\t\tif (dimension.height)\n\t\t\th.height = dimension.height;\n\t}\n\n\tvar header = Buffer.alloc(BINARY_HEADER_LENGTH);\n\n\theader.fill(' ');\n\theader.write(JSON.stringify(h));\n\n\tvar stream = Fs.createWriteStream(filepath);\n\tstream.write(header, 'binary');\n\tstream.end(buffer);\n\tCLEANUP(stream);\n\tcallback && callback(null, cacheid, h);\n\tself.$events.insert && self.emit('insert', cacheid, h);\n\treturn cacheid;\n};\n\nBinary.prototype.readmeta = function(id, callback, count) {\n\n\tvar self = this;\n\n\tif (count > 3) {\n\t\tcallback(new Error('File not found.'));\n\t\treturn self;\n\t}\n\n\tvar version = 0;\n\n\tif (id > 0)\n\t\tversion = 1;\n\telse if (id[0] === 'B' || id[0] === 'b') {\n\t\tid = +id.substring(id.length - DIRECTORYLENGTH);\n\t\tversion = 1;\n\t} else if (self.ext === '.file')\n\t\tversion = 2;\n\telse if (id.indexOf('#') === -1)\n\t\tid = self.db.name + '#' + id;\n\n\tvar filename;\n\n\tif (version === 1)\n\t\tfilename = Path.join(self.$directory(id), id.toString().padLeft(DIRECTORYLENGTH, '0') + self.ext);\n\telse if (version === 2)\n\t\tfilename = Path.join(self.makedirectory(id), id + self.ext);\n\telse\n\t\tfilename = framework_utils.join(self.directory, id + self.ext);\n\n\tF.stats.performance.open++;\n\tvar stream = Fs.createReadStream(filename, BINARYREADMETA);\n\tstream.on('error', err => callback(err));\n\tstream.on('data', function(buffer) {\n\t\tvar json = buffer.toString('utf8').replace(REGCLEAN, '');\n\t\tif (json) {\n\t\t\tcallback(null, JSON.parse(json, jsonparser));\n\t\t\tCLEANUP(stream);\n\t\t} else\n\t\t\tsetTimeout(readfileattempt, 100, self, id, callback, count || 1);\n\t});\n\n\treturn self;\n};\n\nBinary.prototype.res = function(res, options, checkcustom, notmodified) {\n\n\tvar self = this;\n\tvar req = res.req;\n\n\tif (RELEASE && req.$key && F.temporary.notfound[req.$key] !== undefined) {\n\t\tres.throw404();\n\t\treturn res;\n\t}\n\n\tvar version = 0;\n\tvar id = options.id || '';\n\n\tif (id > 0)\n\t\tversion = 1;\n\telse if (id[0] === 'B' || id[0] === 'b') {\n\t\tid = +id.substring(id.length - DIRECTORYLENGTH);\n\t\tversion = 1;\n\t} else if (self.ext === '.file')\n\t\tversion = 2;\n\telse if (id.indexOf('#') === -1)\n\t\tid = self.db.name + '#' + id;\n\n\tvar filename;\n\n\tif (version === 1)\n\t\tfilename = Path.join(self.$directory(id), id.toString().padLeft(DIRECTORYLENGTH, '0') + self.ext);\n\telse if (version === 2)\n\t\tfilename = Path.join(self.makedirectory(id), id + self.ext);\n\telse\n\t\tfilename = framework_utils.join(self.directory, id + self.ext);\n\n\tF.stats.performance.open++;\n\tvar stream = Fs.createReadStream(filename, BINARYREADMETA);\n\n\tstream.on('error', function() {\n\t\tif (RELEASE)\n\t\t\tF.temporary.notfound[F.createTemporaryKey(req)] = true;\n\t\tres.throw404();\n\t});\n\n\tstream.on('data', function(buffer) {\n\t\tvar json = buffer.toString('utf8').replace(REGCLEAN, '');\n\t\tif (json) {\n\n\t\t\tvar obj;\n\n\t\t\ttry {\n\t\t\t\tobj = JSON.parse(json, jsonparser);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log('FileStorage Error:', filename, e);\n\t\t\t\tif (RELEASE)\n\t\t\t\t\tF.temporary.notfound[F.createTemporaryKey(req)] = true;\n\t\t\t\tres.throw404();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (checkcustom && checkcustom(obj) == false) {\n\t\t\t\tif (RELEASE)\n\t\t\t\t\tF.temporary.notfound[F.createTemporaryKey(req)] = true;\n\t\t\t\tres.throw404();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar utc = obj.date ? new Date(+obj.date.substring(0, 4), +obj.date.substring(4, 6), +obj.date.substring(6, 8)).toUTCString() : '';\n\n\t\t\tif (!options.download && req.headers['if-modified-since'] === utc) {\n\t\t\t\tres.extention = U.getExtension(obj.name);\n\t\t\t\tnotmodified(res, utc);\n\t\t\t} else {\n\n\t\t\t\tif (RELEASE && req.$key && F.temporary.path[req.$key]) {\n\t\t\t\t\tres.$file();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\n\t\t\t\tres.options.type = obj.type;\n\t\t\t\tres.options.stream = Fs.createReadStream(filename, BINARYREADDATA);\n\t\t\t\tres.options.lastmodified = true;\n\n\t\t\t\tif (options.download) {\n\t\t\t\t\tres.options.download = options.download === true ? obj.name : typeof(options.download) === 'function' ? options.download(obj.name, obj.type) : options.download;\n\t\t\t\t} else {\n\t\t\t\t\t!options.headers && (options.headers = {});\n\t\t\t\t\toptions.headers['Last-Modified'] = utc;\n\t\t\t\t}\n\n\t\t\t\tres.options.headers = options.headers;\n\t\t\t\tres.options.done = options.done;\n\n\t\t\t\tif (options.image) {\n\t\t\t\t\tres.options.make = options.make;\n\t\t\t\t\tres.options.cache = options.cache !== false;\n\t\t\t\t\tres.$image();\n\t\t\t\t} else {\n\t\t\t\t\tres.options.compress = options.nocompress ? false : true;\n\t\t\t\t\tres.$stream();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (RELEASE)\n\t\t\t\tF.temporary.notfound[F.createTemporaryKey(req)] = true;\n\t\t\tres.throw404();\n\t\t}\n\t});\n};\n\nBinary.prototype.read = function(id, callback, count) {\n\n\tvar self = this;\n\n\tif (count > 3) {\n\t\tcallback(new Error('File not found.'));\n\t\treturn self;\n\t}\n\n\tvar version = 0;\n\n\tif (id > 0)\n\t\tversion = 1;\n\telse if (id[0] === 'B' || id[0] === 'b') {\n\t\tid = +id.substring(id.length - DIRECTORYLENGTH);\n\t\tversion = 1;\n\t} else if (self.ext === '.file')\n\t\tversion = 2;\n\telse if (id.indexOf('#') === -1)\n\t\tid = self.db.name + '#' + id;\n\n\tvar filename;\n\n\tif (version === 1)\n\t\tfilename = Path.join(self.$directory(id), id.toString().padLeft(DIRECTORYLENGTH, '0') + self.ext);\n\telse if (version === 2)\n\t\tfilename = Path.join(self.makedirectory(id), id + self.ext);\n\telse\n\t\tfilename = framework_utils.join(self.directory, id + self.ext);\n\n\tF.stats.performance.open++;\n\tvar stream = Fs.createReadStream(filename, BINARYREADMETA);\n\tstream.on('error', err => callback(err));\n\tstream.on('data', function(buffer) {\n\t\tvar json = buffer.toString('utf8').replace(REGCLEAN, '');\n\t\tif (json) {\n\t\t\tvar meta = JSON.parse(json, jsonparser);\n\t\t\tstream = Fs.createReadStream(filename, BINARYREADDATA);\n\t\t\tcallback(null, stream, meta);\n\t\t\tCLEANUP(stream);\n\t\t} else\n\t\t\tsetTimeout(readfileattempt, 100, self, id, callback, count || 1);\n\t});\n\n\treturn self;\n};\n\nBinary.prototype.readbase64 = function(id, callback, count) {\n\n\tvar self = this;\n\n\tif (count > 3) {\n\t\tcallback(new Error('File not found.'));\n\t\treturn self;\n\t}\n\n\tvar version = 0;\n\n\tif (id > 0)\n\t\tversion = 1;\n\telse if (id[0] === 'B' || id[0] === 'b') {\n\t\tid = +id.substring(id.length - DIRECTORYLENGTH);\n\t\tversion = 1;\n\t} else if (self.ext === '.file')\n\t\tversion = 2;\n\telse if (id.indexOf('#') === -1)\n\t\tid = self.db.name + '#' + id;\n\n\tvar filename;\n\n\tif (version === 1)\n\t\tfilename = Path.join(self.$directory(id), id.toString().padLeft(DIRECTORYLENGTH, '0') + self.ext);\n\telse if (version === 2)\n\t\tfilename = Path.join(self.makedirectory(id), id + self.ext);\n\telse\n\t\tfilename = framework_utils.join(self.directory, id + self.ext);\n\n\tF.stats.performance.open++;\n\tvar stream = Fs.createReadStream(filename, BINARYREADMETA);\n\tstream.on('error', err => callback(err));\n\tstream.on('data', function(buffer) {\n\t\tvar json = buffer.toString('utf8').replace(REGCLEAN, '');\n\t\tif (json) {\n\t\t\tvar meta = JSON.parse(json, jsonparser);\n\t\t\tstream = Fs.createReadStream(filename, BINARYREADDATABASE64);\n\t\t\tcallback(null, stream, meta);\n\t\t\tCLEANUP(stream);\n\t\t} else\n\t\t\tsetTimeout(readfileattempt, 100, self, id, callback, count || 1);\n\t});\n\n\treturn self;\n};\n\nfunction readfileattempt(self, id, callback, count) {\n\tself.read(id, callback, count + 1);\n}\n\nBinary.prototype.remove = function(id, callback) {\n\n\tvar self = this;\n\tvar cacheid = id;\n\tvar version = 0;\n\tvar filename;\n\n\tif (id > 0)\n\t\tversion = 1;\n\telse if (id[0] === 'B' || id[0] === 'b') {\n\t\tversion = 1;\n\t\tid = +id.substring(id.length - DIRECTORYLENGTH);\n\t} else if (self.ext === '.file')\n\t\tversion = 2;\n\telse if (id.indexOf('#') === -1)\n\t\tid = self.db.name + '#' + id;\n\n\tif (version === 1) {\n\t\tvar path = self.$directory(id);\n\t\tfilename = Path.join(path, id.toString().padLeft(DIRECTORYLENGTH, '0') + self.ext);\n\t} else if (version === 2)\n\t\tfilename = Path.join(self.makedirectory(id), id + self.ext);\n\telse\n\t\tfilename = framework_utils.join(self.directory, id + self.ext);\n\n\tFs.unlink(filename, function(err) {\n\n\t\tif (version === 1 && !err) {\n\n\t\t\tself.meta.count--;\n\n\t\t\tF.isCluster && cluster_send({ TYPE: 'filestorage', NAME: self.db.name, method: 'remove', count: self.meta.count, id: id });\n\n\t\t\tif (!F.id || F.id === '0') {\n\t\t\t\tself.meta.free.push(id);\n\t\t\t\tself.$save();\n\t\t\t}\n\t\t}\n\n\t\tif (!err && version === 2)\n\t\t\tFs.appendFile(self.logger, JSON.stringify({ type: 'remove', id: id, date: new Date() }) + '\\n', NOOP);\n\n\t\tcallback && callback(null, err ? false : true);\n\t});\n\n\tself.$events.remove && self.emit('remove', cacheid);\n\treturn self;\n};\n\nBinary.prototype.check = function(path) {\n\n\tvar self = this;\n\tvar key = self.cachekey + (path == null ? 'root' : path.substring(path.length - (DIRECTORYLENGTH + 2)));\n\n\tif (F.temporary.other[key])\n\t\treturn self;\n\n\tif (path != null && !F.temporary.other[self.cachekey + 'root'])\n\t\tself.check();\n\n\tF.temporary.other[key] = true;\n\n\ttry {\n\t\tFs.mkdirSync(path ? path : self.directory);\n\t} catch (err) {}\n\n\treturn self;\n};\n\nBinary.prototype.clear = function(callback) {\n\n\tvar self = this;\n\n\tFs.readdir(self.directory, function(err, response) {\n\n\t\tif (err)\n\t\t\treturn callback(err);\n\n\t\tvar pending = [];\n\t\tvar directories =[];\n\t\tvar key = self.db.name + '#';\n\t\tvar l = key.length;\n\t\tvar target = framework_utils.join(self.directory);\n\n\t\tfor (var i = 0, length = response.length; i < length; i++) {\n\t\t\tvar p = response[i];\n\t\t\tif (p.substring(0, l) === key)\n\t\t\t\tpending.push(target + '/' + p);\n\t\t\telse if (p[3] === '-' && p[7] === '-')\n\t\t\t\tdirectories.push(target + '/' + p);\n\t\t}\n\n\t\tpending.push(target + '/meta.json');\n\t\tpending.push(self.logger);\n\t\tself.$events.clear && self.emit('clear', pending.length);\n\t\tpending.length && F.unlink(pending, F.errorhandling);\n\t\tdirectories.wait(function(path, next) {\n\t\t\tFs.readdir(path, function(err, files) {\n\t\t\t\tfor (var i = 0; i < files.length; i++)\n\t\t\t\t\tfiles[i] = path + '/' + files[i];\n\t\t\t\tF.unlink(files, () => Fs.unlink(path, next));\n\t\t\t});\n\t\t}, function() {\n\t\t\tF.isCluster && cluster_send({ TYPE: 'filestorage', NAME: self.db.name, method: 'refresh' });\n\t\t\tcallback && callback();\n\t\t});\n\t});\n\n\treturn self;\n};\n\nBinary.prototype.browse = function(directory, callback) {\n\tvar self = this;\n\n\tif (typeof(directory) === 'function') {\n\t\tFs.readdir(self.directory, function(err, files) {\n\t\t\tvar dirs = [];\n\t\t\tif (files && files.length) {\n\t\t\t\tfor (var i = 0; i < files.length; i++) {\n\t\t\t\t\tvar p = files[i];\n\t\t\t\t\tif (p[3] === '-' && p[7] === '-' || p.length === 4)\n\t\t\t\t\t\tdirs.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdirectory(null, dirs);\n\t\t});\n\t} else {\n\n\t\tvar version = directory.length === 4 ? 2 : 1;\n\n\t\tFs.readdir(Path.join(self.directory, directory), function(err, response) {\n\n\t\t\tvar target = framework_utils.join(self.directory, directory);\n\t\t\tvar output = [];\n\t\t\tvar le = self.ext.length;\n\n\t\t\tresponse.wait(function(item, next) {\n\n\t\t\t\tFs.stat(target + '/' + item, function(err, stat) {\n\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn next();\n\n\t\t\t\t\tF.stats.performance.open++;\n\t\t\t\t\tvar stream = Fs.createReadStream(target + '/' + item, BINARYREADMETA);\n\n\t\t\t\t\tstream.on('data', function(buffer) {\n\t\t\t\t\t\tvar json = Buffer.from(buffer, 'binary').toString('utf8').replace(REGCLEAN, '').parseJSON(true);\n\t\t\t\t\t\tif (json) {\n\t\t\t\t\t\t\tvar id = item.substring(0, item.length - le);\n\t\t\t\t\t\t\tif (version === 2) {\n\t\t\t\t\t\t\t\tjson.id = id;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjson.id = 'B' + json.date + 'T' + id;\n\t\t\t\t\t\t\t\tjson.index = +id.substring(id.length - DIRECTORYLENGTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjson.ctime = stat.ctime;\n\t\t\t\t\t\t\tjson.mtime = stat.mtime;\n\t\t\t\t\t\t\toutput.push(json);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tCLEANUP(stream, next);\n\n\t\t\t\t});\n\n\t\t\t}, () => callback(null, output), 2);\n\n\t\t});\n\t}\n\n\treturn self;\n};\n\nBinary.prototype.all = function(callback) {\n\tvar self = this;\n\n\tself.check();\n\n\tFs.readdir(self.directory, function(err, response) {\n\n\t\tif (err)\n\t\t\treturn callback(err, EMPTYARRAY);\n\n\t\tvar pending = [];\n\t\tvar key = self.db.name + '#';\n\t\tvar l = key.length;\n\n\t\tfor (var i = 0, length = response.length; i < length; i++)\n\t\t\tresponse[i].substring(0, l) === key && pending.push(response[i]);\n\n\t\tvar target = framework_utils.join(self.directory);\n\t\tvar output = [];\n\t\tvar le = self.ext.length;\n\n\t\tpending.wait(function(item, next) {\n\t\t\tFs.stat(target + '/' + item, function(err, stat) {\n\n\t\t\t\tif (err)\n\t\t\t\t\treturn next();\n\n\t\t\t\tF.stats.performance.open++;\n\t\t\t\tvar stream = Fs.createReadStream(target + '/' + item, BINARYREADMETA);\n\t\t\t\tstream.on('data', function(buffer) {\n\t\t\t\t\tvar json = Buffer.from(buffer, 'binary').toString('utf8').replace(REGCLEAN, '').parseJSON(true);\n\t\t\t\t\tif (json) {\n\t\t\t\t\t\tjson.id = item.substring(l, item.length - le);\n\t\t\t\t\t\tjson.ctime = stat.ctime;\n\t\t\t\t\t\tjson.mtime = stat.mtime;\n\t\t\t\t\t\toutput.push(json);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tCLEANUP(stream, next);\n\n\t\t\t});\n\n\t\t}, function() {\n\t\t\tif (self.meta.count) {\n\t\t\t\tself.browse(function(err, directories) {\n\t\t\t\t\tdirectories.wait(function(item, next) {\n\t\t\t\t\t\tself.browse(item, function(err, files) {\n\t\t\t\t\t\t\tfiles.length && output.push.apply(output, files);\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t});\n\t\t\t\t\t}, () => callback(null, output));\n\t\t\t\t});\n\t\t\t} else\n\t\t\t\tcallback(null, output);\n\t\t}, 2);\n\t});\n\n\treturn self;\n};\n\nfunction Storage(db, directory) {\n\tvar t = this;\n\tt.db = db;\n\tt.directory = directory;\n\tt.pending = [];\n\tt.locked_writer = 0;\n\tt.locked_reader = false;\n\tt.exists = false;\n\tif (!FORK) {\n\t\tt.$mapreducefile = Path.join(db.directory, db.name + EXTENSION_MAPREDUCE);\n\t\tt.$mapreduce = [];\n\t\tt.refresh();\n\t}\n}\n\nconst SP = Storage.prototype;\n\nSP.refresh = function() {\n\ttry {\n\t\tthis.$mapreduce = Fs.readFileSync(this.$mapreducefile).toString('utf8').parseJSON(true);\n\t} catch (e) {}\n\treturn this;\n};\n\nSP.check = function() {\n\n\tvar self = this;\n\tif (self.exists)\n\t\treturn self;\n\n\tself.exists = true;\n\n\ttry {\n\t\tFs.mkdirSync(self.directory);\n\t} catch (err) {}\n\n\treturn self;\n};\n\nSP.insert = function(doc) {\n\n\tvar self = this;\n\n\tif (doc == null) {\n\t\tif (self.pending.length) {\n\t\t\tvar dt = NOW.format('yyyyMMdd');\n\t\t\tself.locked_reader = true;\n\t\t\tself.check();\n\t\t\tFs.appendFile(self.db.filenameStorage.format(dt), self.pending.join(NEWLINE) + NEWLINE, function(err) {\n\t\t\t\terr && F.error(err, 'NoSQL storage insert: ' + self.db.name);\n\t\t\t\tself.locked_reader = false;\n\t\t\t});\n\t\t\tself.pending = [];\n\t\t}\n\t\treturn self;\n\t}\n\n\tif (framework_builders.isSchema(doc))\n\t\tdoc = doc.$clean();\n\n\tself.locked_reader = true;\n\n\tif (self.$mapreduce.length) {\n\t\tfor (var i = 0, length = self.$mapreduce.length; i < length; i++) {\n\t\t\tvar mr = self.$mapreduce[i];\n\t\t\tmr.ready && mr.reduce(doc, mr.repository);\n\t\t}\n\t\tself.$mapreducesave();\n\t}\n\n\tif (self.locked_writer) {\n\t\tself.pending.push(JSON.stringify(doc));\n\t\treturn self;\n\t}\n\n\tself.check();\n\tself.locked_writer = true;\n\tFs.appendFile(self.db.filenameStorage.format(NOW.format('yyyyMMdd')), JSON.stringify(doc) + NEWLINE, function(err) {\n\t\tself.locked_writer = false;\n\t\tself.locked_reader = false;\n\t\tself.pending.length && self.insert();\n\t\terr && F.error(err, 'NoSQL storage insert: ' + self.db.name);\n\t});\n\n\treturn self;\n};\n\nSP.stats = function(name, fn) {\n\tif (fn == null) {\n\t\tvar obj = {};\n\t\tfor (var i = 0; i < this.$mapreduce.length; i++) {\n\t\t\tvar item = this.$mapreduce[i];\n\t\t\tobj[item.name] = FORK ? item.repository : U.clone(item.repository);\n\t\t}\n\t\tname(null, obj);\n\t} else {\n\t\tvar item = this.$mapreduce.findItem('name', name);\n\t\tfn(item ? null : new Error('Stats of MapReduce \"{0}\" not found.'.format(name)), item ? (FORK ? item.repository : CLONE(item.repository)) : null);\n\t}\n\treturn this;\n};\n\nSP.mapreduce = function(name, fn, def) {\n\n\tvar self = this;\n\n\tif (!self.$mapreduce)\n\t\tself.$mapreduce = [];\n\n\tvar item = self.$mapreduce.findItem('name', name);\n\n\tif (item) {\n\t\titem.reduce = fn;\n\t} else {\n\t\titem = {};\n\t\titem.name = name;\n\t\titem.repository = def || {};\n\t\titem.reduce = fn;\n\t\titem.ready = false;\n\t\tself.$mapreduce.push(item);\n\t}\n\n\t// Scan storage for this new mapreduce record\n\t!item.ready && self.scan(item.reduce, function(err, repository) {\n\t\titem.repository = repository;\n\t\titem.ready = true;\n\t\tself.$mapreducesave();\n\t}, true);\n\n\treturn self;\n};\n\nSP.$mapreducesave = function() {\n\tvar self = this;\n\tFs.writeFile(self.$mapreducefile, JSON.stringify(self.$mapreduce, (k, v) => k !== 'reduce' ? v : undefined), F.errorcallback);\n\treturn self;\n};\n\nSP.listing = function(beg, end, callback) {\n\n\tvar tmp;\n\tif (beg) {\n\n\t\tif (typeof(beg) === 'string') {\n\t\t\tbeg = beg.toString().split('-');\n\t\t\tif (beg[1] && beg[1].length < 2)\n\t\t\t\tbeg[1] = '0' + beg[1];\n\t\t\tif (beg[2] && beg[2].length < 2)\n\t\t\t\tbeg[2] = '0' + beg[2];\n\t\t\tbeg = +beg.join('');\n\t\t}\n\n\t\ttmp = beg.toString().length;\n\t\tif (tmp === 4)\n\t\t\tbeg *= 10000;\n\t\telse if (tmp === 6)\n\t\t\tbeg *= 100;\n\t}\n\n\tif (end) {\n\n\t\tif (typeof(end) === 'string') {\n\t\t\tend = end.toString().split('-');\n\t\t\tif (end[1] && end[1].length < 2)\n\t\t\t\tend[1] = '0' + end[1];\n\t\t\tif (end[2] && end[2].length < 2)\n\t\t\t\tend[2] = '0' + end[2];\n\t\t\tend = +end.join('');\n\t\t}\n\n\t\ttmp = end.toString().length;\n\t\tif (tmp === 4)\n\t\t\tend *= 10000;\n\t\telse if (tmp === 6)\n\t\t\tend *= 100;\n\t}\n\n\tvar self = this;\n\n\tU.ls(self.directory, function(files) {\n\t\tvar storage = [];\n\t\tfor (var i = 0, length = files.length; i < length; i++) {\n\t\t\tvar item = files[i];\n\t\t\tvar skip = item.length - EXTENSION.length;\n\t\t\tvar date = +item.substring(skip - 8, skip);\n\t\t\tif ((beg && beg > date) || (end && end < date))\n\t\t\t\tcontinue;\n\t\t\tstorage.push({ filename: item, date: date });\n\t\t}\n\t\tcallback(null, storage);\n\t}, (path, is) => is ? false : path.endsWith(EXTENSION));\n\n\treturn self;\n};\n\nSP.find = function(beg, end, threads) {\n\tvar self = this;\n\n\tif (!threads)\n\t\tthreads = 1;\n\n\tvar builder = new DatabaseBuilder(self);\n\n\tself.listing(beg, end, function(err, storage) {\n\n\t\tvar filters = new NoSQLReader([builder]);\n\t\tvar count = (storage.length / threads) >> 0;\n\t\tvar opt = { cwd: F.directory };\n\t\tvar filename = module.filename.replace(/\\.js$/, '') + 'crawler.js';\n\t\tvar counter = 0;\n\t\tvar finish = threads;\n\n\t\tfor (var i = 0; i < threads; i++) {\n\t\t\tvar fork = require('child_process').fork(filename, EMPTYARRAY, opt);\n\t\t\tvar files = (i === threads - 1) ? storage : storage.splice(0, count);\n\t\t\tfork.send({ TYPE: 'init', files: files, builder: builder.stringify() });\n\t\t\tfork.on('message', function(msg) {\n\t\t\t\tcounter += msg.count;\n\t\t\t\tmsg.response && msg.response.length && filters.compare(msg.response);\n\t\t\t\tfinish--;\n\t\t\t\tif (finish === 0) {\n\t\t\t\t\tfilters.builders[0].count = counter;\n\t\t\t\t\tfilters.done();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\treturn builder;\n};\n\nSP.count = function(beg, end, threads) {\n\tvar builder = this.find(beg, end, threads);\n\tbuilder.$options.readertype = 1;\n\treturn builder;\n};\n\nSP.scalar = function(beg, end, type, field, threads) {\n\treturn this.find(beg, end, threads).scalar(type, field);\n};\n\nSP.scan = function(beg, end, mapreduce, callback, reverse) {\n\tvar self = this;\n\n\tif (typeof(beg) === 'function') {\n\t\treverse = mapreduce;\n\t\tmapreduce = beg;\n\t\tcallback = end;\n\t\tbeg = null;\n\t\tend = null;\n\t} else if (typeof(end) === 'function') {\n\t\treverse = callback;\n\t\tcallback = mapreduce;\n\t\tmapreduce = end;\n\t\tend = null;\n\t}\n\n\tif (typeof(callback) === 'boolean') {\n\t\treverse = callback;\n\t\tcallback = null;\n\t}\n\n\tself.listing(beg, end, function(err, storage) {\n\n\t\tvar repository = {};\n\t\tvar stats = {};\n\n\t\t// Desc\n\t\tstorage.quicksort('date', reverse == true);\n\n\t\tstats.files = storage.length;\n\t\tstats.documents = 0;\n\t\tstats.duration = Date.now();\n\t\tstats.processed = 0;\n\t\tstats.canceled = false;\n\n\t\tvar today = +NOW.format('yyyyMMdd');\n\t\tvar process = function(item, next, index) {\n\n\t\t\tif (self.locked_read) {\n\t\t\t\tsetTimeout(process, 100, item, next, index);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar reader = new NoSQLStream(item.filename);\n\t\t\tstats.current = item.date;\n\t\t\tstats.index = index;\n\n\t\t\tif (self.buffersize)\n\t\t\t\treader.buffersize = self.buffersize;\n\n\t\t\tif (self.buffercount)\n\t\t\t\treader.buffercount = self.buffercount;\n\n\t\t\treader.ondocuments = function() {\n\t\t\t\tvar docs = JSON.parse('[' + reader.docs + ']', jsonparser);\n\t\t\t\tfor (var j = 0; j < docs.length; j++) {\n\t\t\t\t\tstats.documents++;\n\t\t\t\t\tvar json = docs[j];\n\t\t\t\t\tvar end = mapreduce(json, repository, stats) === false;\n\t\t\t\t\tif (end) {\n\t\t\t\t\t\tstats.canceled = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treader.$callback = function() {\n\t\t\t\tstats.processed++;\n\t\t\t\tif (item.date === today) {\n\t\t\t\t\tself.locked_writer--;\n\t\t\t\t\tif (self.locked_writer <= 0 && self.pending.length)\n\t\t\t\t\t\tself.insert();\n\t\t\t\t}\n\t\t\t\tsetImmediate(next);\n\t\t\t};\n\n\t\t\treader.openread();\n\t\t};\n\n\t\tstorage.wait(function(item, next, index) {\n\t\t\tif (stats.canceled) {\n\t\t\t\tsetImmediate(next);\n\t\t\t} else {\n\n\t\t\t\tif (item.date === today) {\n\t\t\t\t\tif (self.locked_read) {\n\t\t\t\t\t\tsetTimeout(process, 100, item, next, index);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (item.date === today)\n\t\t\t\t\tself.locked_writer++;\n\n\t\t\t\tprocess(item, next, index);\n\t\t\t}\n\t\t}, function() {\n\t\t\tstats.duration = Date.now() - stats.duration;\n\t\t\tcallback && callback(null, repository, stats);\n\t\t});\n\n\t});\n\n\treturn self;\n};\n\nSP.clear = function(beg, end, callback) {\n\tvar self = this;\n\n\tif (typeof(beg) === 'function') {\n\t\tcallback = end;\n\t\tbeg = null;\n\t\tend = null;\n\t} else if (typeof(end) === 'function') {\n\t\tcallback = end;\n\t\tend = null;\n\t}\n\n\tself.listing(beg, end, function(err, files) {\n\n\t\tvar count = 0;\n\n\t\tvar remove = function(filename, callback, attemp) {\n\t\t\tFs.unlink(filename, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.toString().indexOf('no such file') === -1) {\n\t\t\t\t\t\tif (attemp > 5)\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsetTimeout(() => remove(filename, callback, (attemp || 0) + 1), 100);\n\t\t\t\t\t} else\n\t\t\t\t\t\tcallback();\n\t\t\t\t} else {\n\t\t\t\t\tcount++;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tfiles.wait((item, next) => remove(item.filename, next), function() {\n\t\t\tremove(self.$mapreducefile, () => callback && callback(null, count));\n\t\t});\n\n\t});\n\treturn self;\n};\n\nTP.ready = function(fn) {\n\tvar self = this;\n\tif (self.ready)\n\t\tfn.call(self);\n\telse {\n\t\tsetTimeout(function(self, fn) {\n\t\t\tself.ready(fn);\n\t\t}, 100, self, fn);\n\t}\n\treturn self;\n};\n\nTP.insert = function(doc, unique) {\n\n\tvar self = this;\n\tvar builder;\n\n\tif (framework_builders.isSchema(doc))\n\t\tdoc = doc.$clean();\n\n\tself.readonly && self.throwReadonly();\n\n\tif (unique) {\n\n\t\tbuilder = self.one();\n\t\tvar callback;\n\n\t\tbuilder.callback(function(err, d) {\n\t\t\tif (d)\n\t\t\t\tcallback && callback(null, 0);\n\t\t\telse\n\t\t\t\tself.insert(doc).callback(callback);\n\t\t});\n\n\t\tbuilder.callback = function(fn) {\n\t\t\tcallback = fn;\n\t\t\treturn builder;\n\t\t};\n\n\t\treturn builder;\n\t}\n\n\tbuilder = new DatabaseBuilder2(self);\n\tself.pending_append.push({ doc: doc, builder: builder });\n\tsetImmediate(next_operation, self, 1);\n\tself.$events.insert && self.emit('insert', doc);\n\treturn builder;\n};\n\nTP.update = function(doc, insert) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.$options.readertype = 1;\n\tif (typeof(doc) === 'string')\n\t\tdoc = new Function('doc', 'repository', 'arg', doc.indexOf('return ') === -1 ? ('return (' + doc + ')') : doc);\n\tself.pending_update.push({ builder: builder, doc: doc, count: 0, insert: insert === true ? doc : insert });\n\tsetImmediate(next_operation, self, 2);\n\treturn builder;\n};\n\nTP.modify = function(doc, insert) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tvar data = framework_builders.isSchema(doc) ? doc.$clean() : doc;\n\tvar keys = Object.keys(data);\n\tif (keys.length) {\n\t\tvar inc = null;\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tswitch (key[0]) {\n\t\t\t\tcase '!':\n\t\t\t\tcase '+':\n\t\t\t\tcase '-':\n\t\t\t\tcase '*':\n\t\t\t\tcase '/':\n\t\t\t\t\t!inc && (inc = {});\n\t\t\t\t\tvar tmp = key.substring(1);\n\t\t\t\t\tinc[tmp] = key[0];\n\t\t\t\t\tdoc[tmp] = doc[key];\n\t\t\t\t\tdoc[key] = undefined;\n\t\t\t\t\tkeys[i] = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$':\n\t\t\t\t\ttmp = key.substring(1);\n\t\t\t\t\tdoc[tmp] = new Function('value', 'doc', 'repository', 'arg', doc[key].indexOf('return ') === -1 ? ('return (' + doc[key] + ')') : doc[key]);\n\t\t\t\t\tdoc[key] = undefined;\n\t\t\t\t\tkeys[i] = tmp;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbuilder.$options.readertype = 1;\n\t\tself.pending_update.push({ builder: builder, doc: data, count: 0, keys: keys, inc: inc, insert: insert === true ? data : insert });\n\t\tsetImmediate(next_operation, self, 2);\n\t}\n\treturn builder;\n};\n\nTP.remove = function() {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tself.pending_remove.push(builder);\n\tbuilder.$options.readertype = 1;\n\tsetImmediate(next_operation, self, 3);\n\treturn builder;\n};\n\nTP.listing = TP.list = function(builder) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tif (builder)\n\t\tbuilder.db = self;\n\telse\n\t\tbuilder = new DatabaseBuilder(self);\n\tbuilder.$options.listing = true;\n\tbuilder.$take = builder.$options.take = 100;\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\nTP.find = function(builder) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tif (builder)\n\t\tbuilder.db = self;\n\telse\n\t\tbuilder = new DatabaseBuilder(self);\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\nTP.find2 = function(builder) {\n\tvar self = this;\n\tif (builder)\n\t\tbuilder.db = self;\n\telse {\n\t\tbuilder = new DatabaseBuilder(self);\n\t\tbuilder.$options.notall = true;\n\t}\n\n\tself.pending_reader2.push(builder);\n\tsetImmediate(next_operation, self, 11);\n\treturn builder;\n};\n\nTP.stream = function(fn, repository, callback) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\n\tif (typeof(repository) === 'function') {\n\t\tcallback = repository;\n\t\trepository = null;\n\t}\n\n\tself.pending_streamer.push({ fn: fn, callback: callback, repository: repository || {} });\n\tsetImmediate(next_operation, self, 10);\n\treturn self;\n};\n\nTP.extend = function(schema, callback) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tself.lock(function(next) {\n\n\t\tvar olds = self.$schema;\n\t\tvar oldk = self.$keys;\n\t\tvar oldl = self.$size;\n\t\tvar oldh = Buffer.byteLength(self.stringifySchema() + NEWLINE);\n\n\t\tself.parseSchema(schema.replace(/;|,/g, '|').trim().split('|'));\n\n\t\tvar meta = self.stringifySchema() + NEWLINE;\n\t\tvar news = self.$schema;\n\t\tvar newk = self.$keys;\n\t\tself.$schema = olds;\n\t\tself.$keys = oldk;\n\n\t\tvar count = 0;\n\t\tvar fs = new NoSQLStream(self.filename);\n\t\tvar data = {};\n\t\tvar tmp = self.filename + '-tmp';\n\t\tvar writer = Fs.createWriteStream(tmp);\n\n\t\tif (self.buffersize)\n\t\t\tfs.buffersize = self.buffersize;\n\n\t\tif (self.buffercount)\n\t\t\tfs.buffercount = self.buffercount;\n\n\t\twriter.write(meta, 'utf8');\n\t\twriter.on('finish', function() {\n\t\t\tFs.rename(tmp, self.filename, function() {\n\t\t\t\tnext();\n\t\t\t\tcallback && callback();\n\t\t\t});\n\t\t});\n\n\t\tdata.keys = self.$keys;\n\t\tfs.start = oldh;\n\t\tfs.divider = '\\n';\n\n\t\tif (oldl)\n\t\t\tself.linesize = oldl;\n\n\t\tvar size = self.$size;\n\n\t\tfs.ondocuments = function() {\n\n\t\t\tvar lines = fs.docs.split(fs.divider);\n\t\t\tvar items = [];\n\n\t\t\tself.$schema = olds;\n\t\t\tself.$keys = oldk;\n\t\t\tself.$size = oldl;\n\n\t\t\tfor (var a = 0; a < lines.length; a++) {\n\t\t\t\tdata.line = lines[a].split('|');\n\t\t\t\tdata.index = count++;\n\t\t\t\tvar doc = self.parseData(data);\n\t\t\t\titems.push(doc);\n\t\t\t}\n\n\t\t\tself.$schema = news;\n\t\t\tself.$keys = newk;\n\n\t\t\tself.$size = size;\n\t\t\tvar buffer = '';\n\t\t\tfor (var i = 0; i < items.length; i++)\n\t\t\t\tbuffer += self.stringify(items[i], true) + NEWLINE;\n\t\t\tbuffer && writer.write(buffer, 'utf8');\n\t\t};\n\n\t\tfs.$callback = function() {\n\t\t\tself.$schema = news;\n\t\t\tself.$keys = newk;\n\t\t\tself.$header = Buffer.byteLength(meta);\n\t\t\twriter.end();\n\t\t\tfs = null;\n\t\t};\n\n\t\tfs.openread();\n\t});\n\n\treturn self;\n};\n\n\nTP.throwReadonly = function() {\n\tthrow new Error('Table \"{0}\" doesn\\'t contain any schema'.format(this.name));\n};\n\nTP.scalar = function(type, field) {\n\treturn this.find().scalar(type, field);\n};\n\nTP.count = function() {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.$options.readertype = 1;\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\nTP.one = TP.read = function() {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.first();\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\nTP.one2 = TP.read2 = function() {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.first();\n\tself.pending_reader2.push(builder);\n\tsetImmediate(next_operation, self, 11);\n\treturn builder;\n};\n\nTP.top = function(max) {\n\tvar self = this;\n\tself.readonly && self.throwReadonly();\n\tvar builder = new DatabaseBuilder(self);\n\tbuilder.take(max);\n\tself.pending_reader.push(builder);\n\tsetImmediate(next_operation, self, 4);\n\treturn builder;\n};\n\nTP.next = function(type) {\n\n\tif (!this.ready || (type && NEXTWAIT[this.step]))\n\t\treturn;\n\n\tif (F.isCluster && type === 0 && this.locked)\n\t\tclusterunlock(this);\n\n\tif (!this.$writting && !this.$reading) {\n\n\t\tif (this.step !== 12 && this.pending_clear.length) {\n\t\t\tif (!this.readonly && F.isCluster)\n\t\t\t\tclusterlock(this, '$clear');\n\t\t\telse\n\t\t\t\tthis.$clear();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 13 && this.pending_clean.length) {\n\t\t\tif (!this.readonly && F.isCluster)\n\t\t\t\tclusterlock(this, '$clean');\n\t\t\telse\n\t\t\t\tthis.$clean();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 7 && !this.pending_reindex && this.pending_drops) {\n\t\t\tthis.$drop();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 14 && this.pending_locks.length) {\n\t\t\tthis.$lock();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!this.$writting) {\n\n\t\tif (this.step !== 1 && !this.pending_reindex && this.pending_append.length) {\n\t\t\tthis.$append();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 2 && !this.$writting && this.pending_update.length) {\n\t\t\tif (!this.readonly && F.isCluster)\n\t\t\t\tclusterlock(this, '$update');\n\t\t\telse\n\t\t\t\tthis.$update();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 3 && !this.$writting && this.pending_remove.length) {\n\t\t\tif (!this.readonly && F.isCluster)\n\t\t\t\tclusterlock(this, '$remove');\n\t\t\telse\n\t\t\t\tthis.$remove();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!this.$reading) {\n\n\t\tif (this.step !== 4 && this.pending_reader.length) {\n\t\t\tthis.$reader();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 11 && this.pending_reader2.length) {\n\t\t\tthis.$reader3();\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.step !== 10 && this.pending_streamer.length) {\n\t\t\tthis.$streamer();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (this.step !== type) {\n\t\tthis.step = 0;\n\t\tsetImmediate(next_operation, this, 0);\n\t}\n};\n\nTP.$append = function() {\n\tvar self = this;\n\tself.step = 1;\n\n\tif (!self.pending_append.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tself.$writting = true;\n\n\tself.pending_append.splice(0).limit(JSONBUFFER, function(items, next) {\n\n\t\tvar data = '';\n\n\t\tfor (var i = 0, length = items.length; i < length; i++)\n\t\t\tdata += self.stringify(items[i].doc, true) + NEWLINE;\n\n\t\tFs.appendFile(self.filename, data, function(err) {\n\t\t\terr && F.error(err, 'Table insert: ' + self.name);\n\t\t\tfor (var i = 0, length = items.length; i < length; i++) {\n\t\t\t\titems[i].builder.$options.log && items[i].builder.log();\n\t\t\t\tvar callback = items[i].builder.$callback;\n\t\t\t\tcallback && callback(err, 1);\n\t\t\t}\n\t\t\tnext();\n\t\t});\n\n\t}, () => setImmediate(next_append, self));\n};\n\nTP.$reader = function() {\n\n\tvar self = this;\n\n\tself.step = 4;\n\n\tif (!self.pending_reader.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tself.$reading = true;\n\n\tvar fs = new NoSQLStream(self.filename);\n\tvar filters = new NoSQLReader(self.pending_reader.splice(0));\n\tvar data = {};\n\tvar indexer = 0;\n\n\tfs.array = true;\n\tfs.start = self.$header;\n\tfs.linesize = self.$size;\n\tfs.divider = '\\n';\n\n\tdata.keys = self.$keys;\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tfs.ondocuments = function() {\n\n\t\tvar lines = fs.docs;\n\t\tvar arr = [];\n\n\t\tfor (var j = 0; j < lines.length; j++) {\n\t\t\tdata.line = lines[j].split('|');\n\t\t\tdata.index = indexer++;\n\t\t\tarr.push(self.parseData(data));\n\t\t}\n\n\t\treturn filters.compare(arr);\n\t};\n\n\tfs.$callback = function() {\n\t\tfilters.done();\n\t\tfs = null;\n\t\tself.$reading = false;\n\t\tself.next(0);\n\t};\n\n\tfs.openread();\n\treturn self;\n};\n\nTP.$reader3 = function() {\n\n\tvar self = this;\n\n\tself.step = 11;\n\n\tif (!self.pending_reader2.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tself.$reading = true;\n\n\tvar fs = new NoSQLStream(self.filename);\n\tvar filters = new NoSQLReader(self.pending_reader2.splice(0));\n\tvar data = {};\n\tvar indexer = 0;\n\n\tfs.array = true;\n\tfs.start = self.$header;\n\tfs.linesize = self.$size;\n\tfs.divider = '\\n';\n\tdata.keys = self.$keys;\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tfs.ondocuments = function() {\n\n\t\tvar lines = fs.docs;\n\t\tvar arr = [];\n\n\t\tfor (var j = 0; j < lines.length; j++) {\n\t\t\tdata.line = lines[j].split('|');\n\t\t\tif (TABLERECORD[data.line[0]]) {\n\t\t\t\tdata.index = indexer++;\n\t\t\t\tarr.push(self.parseData(data));\n\t\t\t}\n\t\t}\n\n\t\treturn filters.compare(arr);\n\t};\n\n\tfs.$callback = function() {\n\t\tfilters.done();\n\t\tfs = null;\n\t\tself.$reading = false;\n\t\tself.next(0);\n\t};\n\n\tfs.openreadreverse();\n\treturn self;\n};\n\nTP.$update = function() {\n\n\tvar self = this;\n\tself.step = 2;\n\n\tif (!self.pending_update.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tself.$writting = true;\n\n\tvar fs = new NoSQLStream(self.filename);\n\tvar filter = self.pending_update.splice(0);\n\tvar filters = new NoSQLReader();\n\tvar change = false;\n\tvar indexer = 0;\n\tvar data = { keys: self.$keys };\n\n\tfor (var i = 0; i < filter.length; i++)\n\t\tfilters.add(filter[i].builder, true);\n\n\tfs.array = true;\n\tfs.start = self.$header;\n\tfs.linesize = self.$size;\n\tfs.divider = '\\n';\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tvar update = function(docs, doc, dindex, f, findex) {\n\n\t\tvar rec = fs.docsbuffer[dindex];\n\t\tvar fil = filter[findex];\n\t\tvar e = fil.keys ? 'modify' : 'update';\n\t\tvar old = self.$events[e] ? CLONE(doc) : 0;\n\n\t\tif (f.first)\n\t\t\tf.canceled = true;\n\n\t\tif (fil.keys) {\n\t\t\tfor (var j = 0; j < fil.keys.length; j++) {\n\t\t\t\tvar key = fil.keys[j];\n\t\t\t\tvar val = fil.doc[key];\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\tif (typeof(val) === 'function')\n\t\t\t\t\t\tdoc[key] = val(doc[key], doc, f.filter.repository, f.filter.arg);\n\t\t\t\t\telse if (fil.inc && fil.inc[key]) {\n\t\t\t\t\t\tswitch (fil.inc[key]) {\n\t\t\t\t\t\t\tcase '!':\n\t\t\t\t\t\t\t\tdoc[key] = doc[key] == null ? true : !doc[key];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '+':\n\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) + val;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '-':\n\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) - val;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) + val;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase '/':\n\t\t\t\t\t\t\t\tdoc[key] = (doc[key] || 0) / val;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdoc[key] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tdocs[dindex] = typeof(fil.doc) === 'function' ? (fil.doc(doc, f.filter.repository, f.filter.arg) || doc) : fil.doc;\n\n\t\tself.$events[e] && self.emit(e, doc, old);\n\t\tf.builder.$options.backup && f.builder.$backupdoc(rec.doc);\n\t};\n\n\tvar updateflush = function(docs, doc, dindex) {\n\n\t\tdoc = docs[dindex];\n\n\t\tvar rec = fs.docsbuffer[dindex];\n\t\tvar upd = self.stringify(doc, null, rec.length);\n\n\t\tif (upd === rec.doc)\n\t\t\treturn;\n\n\t\t!change && (change = true);\n\n\t\tvar b = Buffer.byteLength(upd);\n\t\tif (rec.length === b) {\n\t\t\tfs.write(upd + NEWLINE, rec.position);\n\t\t} else {\n\t\t\tvar tmp = fs.remchar + rec.doc.substring(1) + NEWLINE;\n\t\t\tfs.write(tmp, rec.position);\n\t\t\tfs.write2(upd + NEWLINE);\n\t\t}\n\t};\n\n\tfs.ondocuments = function() {\n\n\t\tvar lines = fs.docs;\n\t\tvar arr = [];\n\n\t\tfor (var a = 0; a < lines.length; a++) {\n\t\t\tdata.line = lines[a].split('|');\n\t\t\tdata.length = lines[a].length;\n\t\t\tdata.index = indexer++;\n\t\t\tarr.push(self.parseData(data, EMPTYOBJECT));\n\t\t}\n\n\t\tfilters.compare2(arr, update, updateflush);\n\t};\n\n\tfs.$callback = function() {\n\n\t\tfs = null;\n\t\tself.$writting = false;\n\t\tself.next(0);\n\n\t\tfor (var i = 0; i < filters.builders.length; i++) {\n\t\t\tvar item = filters.builders[i];\n\t\t\tvar fil = filter[i];\n\t\t\tif (fil.insert && !item.count) {\n\t\t\t\titem.builder.$insertcallback && item.builder.$insertcallback(fil.insert, item.filter ? item.filter.repository : EMPTYOBJECT);\n\t\t\t\tvar tmp = self.insert(fil.insert);\n\t\t\t\ttmp.$callback = item.builder.$callback;\n\t\t\t\ttmp.$options.log = item.builder.$options.log;\n\t\t\t\titem.builder.$callback = null;\n\t\t\t} else {\n\t\t\t\titem.builder.$options.log && item.builder.log();\n\t\t\t\titem.builder.$callback && item.builder.$callback(errorhandling(null, item.builder, item.counter), item.counter, item.count, item.filter ? item.filter.repository : EMPTYOBJECT);\n\t\t\t}\n\t\t}\n\n\t\tif (change) {\n\t\t\tself.$events.change && self.emit('change', 'update');\n\t\t\t!F.databasescleaner[self.$name] && (F.databasescleaner[self.$name] = 1);\n\t\t}\n\t};\n\n\tfs.openupdate();\n\treturn self;\n};\n\nTP.$remove = function() {\n\n\tvar self = this;\n\tself.step = 3;\n\n\tif (!self.pending_remove.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tself.$writting = true;\n\n\tvar fs = new NoSQLStream(self.filename);\n\tvar filter = self.pending_remove.splice(0);\n\tvar filters = new NoSQLReader(filter);\n\tvar change = false;\n\tvar indexer = 0;\n\n\tfs.array = true;\n\tfs.start = self.$header;\n\tfs.linesize = self.$size;\n\tfs.divider = '\\n';\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tvar data = { keys: self.$keys };\n\n\tvar remove = function(docs, d, dindex, f) {\n\t\tvar rec = fs.docsbuffer[dindex];\n\t\tf.builder.$options.backup && f.builder.$backupdoc(rec.doc);\n\t\treturn 1;\n\t};\n\n\tvar removeflush = function(docs, d, dindex) {\n\t\tvar rec = fs.docsbuffer[dindex];\n\t\t!change && (change = true);\n\t\tself.$events.remove && self.emit('remove', d);\n\t\tfs.write(fs.remchar + rec.doc.substring(1) + NEWLINE, rec.position);\n\t};\n\n\tfs.ondocuments = function() {\n\n\t\tvar lines = fs.docs;\n\t\tvar arr = [];\n\n\t\tfor (var a = 0; a < lines.length; a++) {\n\t\t\tdata.line = lines[a].split('|');\n\t\t\tdata.index = indexer++;\n\t\t\tarr.push(self.parseData(data));\n\t\t}\n\n\t\tfilters.compare2(arr, remove, removeflush);\n\t};\n\n\tfs.$callback = function() {\n\t\tfilters.done();\n\t\tfs = null;\n\t\tself.$writting = false;\n\t\tself.next(0);\n\t\tif (change) {\n\t\t\tself.$events.change && self.emit('change', 'remove');\n\t\t\t!F.databasescleaner[self.$name] && (F.databasescleaner[self.$name] = 1);\n\t\t}\n\t};\n\n\tfs.openupdate();\n};\n\nTP.$clean = function() {\n\n\tvar self = this;\n\tself.step = 13;\n\n\tif (!self.pending_clean.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tvar filter = self.pending_clean.splice(0);\n\tvar length = filter.length;\n\tvar now = Date.now();\n\n\tF.databasescleaner[self.$name] = undefined;\n\tCONF.nosql_logger && PRINTLN('NoSQL Table \"{0}\" cleaning (beg)'.format(self.name));\n\n\tvar fs = new NoSQLStream(self.filename);\n\tvar writer = Fs.createWriteStream(self.filename + '-tmp');\n\n\twriter.write(self.stringifySchema() + NEWLINE);\n\n\tfs.start = self.$header;\n\tfs.linesize = self.$size;\n\tfs.divider = NEWLINE;\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tfs.ondocuments = function() {\n\t\tfs.docs && writer.write(fs.docs + NEWLINE);\n\t};\n\n\tfs.$callback = function() {\n\t\twriter.end();\n\t};\n\n\twriter.on('finish', function() {\n\t\tFs.rename(self.filename + '-tmp', self.filename, function() {\n\t\t\tCONF.nosql_logger && PRINTLN('NoSQL Table \"{0}\" cleaning (end, {1}s)'.format(self.name, (((Date.now() - now) / 1000) >> 0)));\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tfilter[i]();\n\t\t\tself.$events.clean && self.emit('clean');\n\t\t\tself.next(0);\n\t\t\tfs = null;\n\t\t});\n\t});\n\n\tfs.openread();\n};\n\nTP.$clear = function() {\n\n\tvar self = this;\n\tself.step = 12;\n\n\tif (!self.pending_clear.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tvar filter = self.pending_clear.splice(0);\n\tFs.unlink(self.filename, function() {\n\t\tfor (var i = 0; i < filter.length; i++)\n\t\t\tfilter[i]();\n\n\t\tFs.appendFile(self.filename, self.stringifySchema() + NEWLINE, function() {\n\t\t\tself.$events.change && self.emit('change', 'clear');\n\t\t\tself.next(0);\n\t\t});\n\t});\n};\n\nTP.$lock = function() {\n\n\tvar self = this;\n\tself.step = 14;\n\n\tif (!self.pending_locks.length) {\n\t\tself.next(0);\n\t\treturn;\n\t}\n\n\tvar filter = self.pending_locks.splice(0);\n\tfilter.wait(function(fn, next) {\n\t\tfn.call(self, next);\n\t}, function() {\n\t\tself.next(0);\n\t});\n};\n\nTP.$streamer = function() {\n\n\tvar self = this;\n\tself.step = 10;\n\n\tif (!self.pending_streamer.length) {\n\t\tself.next(0);\n\t\treturn self;\n\t}\n\n\tself.$reading = true;\n\n\tvar filter = self.pending_streamer.splice(0);\n\tvar length = filter.length;\n\tvar count = 0;\n\tvar fs = new NoSQLStream(self.filename);\n\tvar data = {};\n\n\tdata.keys = self.$keys;\n\n\tfs.array = true;\n\tfs.start = self.$header;\n\tfs.divider = '\\n';\n\n\tif (self.buffersize)\n\t\tfs.buffersize = self.buffersize;\n\n\tif (self.buffercount)\n\t\tfs.buffercount = self.buffercount;\n\n\tfs.ondocuments = function() {\n\t\tvar lines = fs.docs;\n\t\tfor (var a = 0; a < lines.length; a++) {\n\t\t\tdata.line = lines[a].split('|');\n\t\t\tdata.index = count++;\n\t\t\tvar doc = self.parseData(data);\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tfilter[i].fn(doc, filter[i].repository, count);\n\t\t}\n\t};\n\n\tfs.$callback = function() {\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tfilter[i].callback && filter[i].callback(null, filter[i].repository, count);\n\t\tself.$reading = false;\n\t\tself.next(0);\n\t\tfs = null;\n\t};\n\n\tfs.openread();\n\treturn self;\n};\n\nTP.allocations = function(enable) {\n\tthis.$allocations = enable;\n\treturn this;\n};\n\nTP.parseSchema = function() {\n\tvar self = this;\n\tvar arr = arguments[0] instanceof Array ? arguments[0] : arguments;\n\tvar sized = true;\n\n\tself.$schema = {};\n\tself.$keys = [];\n\tself.$size = 2;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar arg = arr[i].split(':');\n\t\tvar type = 0;\n\t\tvar T = (arg[1] || '').toLowerCase().trim();\n\t\tvar size = 0;\n\n\t\tvar index = T.indexOf('(');\n\t\tif (index != -1) {\n\t\t\tsize = +T.substring(index + 1, T.lastIndexOf(')'));\n\t\t\tT = T.substring(0, index);\n\t\t}\n\n\t\tswitch (T) {\n\t\t\tcase 'number':\n\t\t\t\ttype = 2;\n\t\t\t\t!size && (size = 16);\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\tcase 'bool':\n\t\t\t\ttype = 3;\n\t\t\t\tsize = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\t\ttype = 4;\n\t\t\t\tsize = 13;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\ttype = 5;\n\t\t\t\tsize = 0;\n\t\t\t\tsized = false;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\tdefault:\n\t\t\t\ttype = 1;\n\t\t\t\tif (!size)\n\t\t\t\t\tsized = false;\n\t\t\t\tbreak;\n\t\t}\n\t\tvar name = arg[0].trim();\n\t\tself.$schema[name] = { type: type, pos: i, size: size };\n\t\tself.$keys.push(name);\n\t\tself.$size += size + 1;\n\t}\n\n\tif (sized) {\n\t\tself.$allocations = false;\n\t\tself.$size++; // newline\n\t} else\n\t\tself.$size = 0;\n\n\treturn self;\n};\n\nTP.stringifySchema = function() {\n\n\tvar self = this;\n\tvar data = [];\n\n\tfor (var i = 0; i < self.$keys.length; i++) {\n\n\t\tvar key = self.$keys[i];\n\t\tvar meta = self.$schema[key];\n\t\tvar type = 'string';\n\n\t\tswitch (meta.type) {\n\t\t\tcase 2:\n\n\t\t\t\ttype = 'number';\n\n\t\t\t\t// string\n\t\t\t\tif (self.$size && meta.size !== 16)\n\t\t\t\t\ttype += '(' + (meta.size) + ')';\n\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\ttype = 'boolean';\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\ttype = 'date';\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\ttype = 'object';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// string\n\t\t\t\tif (meta.size)\n\t\t\t\t\ttype += '(' + (meta.size) + ')';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdata.push(key + ':' + type);\n\t}\n\n\treturn data.join('|');\n};\n\nTP.parseData = function(data, cache) {\n\n\tvar self = this;\n\tvar obj = {};\n\tvar esc = data.line[0] === '*';\n\tvar val, alloc;\n\n\tif (cache && !self.$size && data.keys.length === data.line.length - 2)\n\t\talloc = data.line[data.line.length - 1].length;\n\n\tfor (var i = 0; i < data.keys.length; i++) {\n\t\tvar key = data.keys[i];\n\n\t\tif (cache && cache !== EMPTYOBJECT && cache[key] != null) {\n\t\t\tobj[key] = cache[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar meta = self.$schema[key];\n\t\tif (meta == null)\n\t\t\tcontinue;\n\n\t\tvar pos = meta.pos + 1;\n\t\tvar line = data.line[pos];\n\n\t\tif (self.$size) {\n\t\t\tfor (var j = line.length - 1; j > -1; j--) {\n\t\t\t\tif (line[j] !== ' ') {\n\t\t\t\t\tline = line.substring(0, j + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch (meta.type) {\n\t\t\tcase 1: // String\n\t\t\t\tobj[key] = line;\n\t\t\t\tif (esc && obj[key])\n\t\t\t\t\tobj[key] = obj[key].replace(REGTUNESCAPE, regtescapereverse);\n\t\t\t\tif (self.$size && obj[key].indexOf('\\\\u') !== -1)\n\t\t\t\t\tobj[key] = obj[key].fromUnicode();\n\t\t\t\tbreak;\n\t\t\tcase 2: // Number\n\t\t\t\tval = +line;\n\t\t\t\tobj[key] = val < 0 || val > 0 ? val : 0;\n\t\t\t\tbreak;\n\t\t\tcase 3: // Boolean\n\t\t\t\tval = line;\n\t\t\t\tobj[key] = BOOLEAN[val] == 1;\n\t\t\t\tbreak;\n\t\t\tcase 4: // Date\n\t\t\t\tval = line;\n\t\t\t\tobj[key] = val ? new Date(val[10] === 'T' ? val : +val) : null;\n\t\t\t\tbreak;\n\t\t\tcase 5: // Object\n\t\t\t\tval = line;\n\t\t\t\tif (esc && val)\n\t\t\t\t\tval = val.replace(REGTUNESCAPE, regtescapereverse);\n\t\t\t\tif (self.$size && obj[key].indexOf('\\\\u') !== -1)\n\t\t\t\t\tobj[key] = obj[key].fromUnicode();\n\t\t\t\tobj[key] = val ? val.parseJSON(true) : null;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\talloc >= 0 && (obj.$$alloc = { size: alloc, length: data.length });\n\treturn obj;\n};\n\nTP.stringify = function(doc, insert, byteslen) {\n\n\tvar self = this;\n\tvar output = '';\n\tvar esc = false;\n\tvar size = 0;\n\n\tfor (var i = 0; i < self.$keys.length; i++) {\n\t\tvar key = self.$keys[i];\n\t\tvar meta = self.$schema[key];\n\t\tvar val = doc[key];\n\n\t\tswitch (meta.type) {\n\t\t\tcase 1: // String\n\n\t\t\t\tif (self.$size) {\n\t\t\t\t\tswitch (typeof(val)) {\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tval = val + '';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\t\tval = val ? '1' : '0';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'object':\n\t\t\t\t\t\t\tvar is = !!val;\n\t\t\t\t\t\t\tval = JSON.stringify(val);\n\t\t\t\t\t\t\tif (!is)\n\t\t\t\t\t\t\t\tval = val.toUnicode();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'string':\n\t\t\t\t\t\t\tval = val.toUnicode();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (val.length > meta.size)\n\t\t\t\t\t\tval = val.substring(0, meta.size);\n\t\t\t\t\telse\n\t\t\t\t\t\tval = val.padRight(meta.size, ' ');\n\n\t\t\t\t\t// bytes\n\t\t\t\t\tvar diff = meta.size - Buffer.byteLength(val);\n\t\t\t\t\tif (diff > 0) {\n\t\t\t\t\t\tfor (var j = 0; j < diff; j++)\n\t\t\t\t\t\t\tval += ' ';\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tval = val ? val : '';\n\t\t\t\t\tif (meta.size && val.length > meta.sized)\n\t\t\t\t\t\tval = val.substring(0, meta.size);\n\t\t\t\t\tsize += 4;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 2: // Number\n\t\t\t\tval = (val || 0) + '';\n\t\t\t\tif (self.$size) {\n\t\t\t\t\tif (val.length < meta.size)\n\t\t\t\t\t\tval = val.padRight(meta.size, ' ');\n\t\t\t\t} else\n\t\t\t\t\tsize += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase 3: // Boolean\n\t\t\t\tval = (val == true ? '1' : '0');\n\t\t\t\tbreak;\n\n\t\t\tcase 4: // Date\n\t\t\t\tval = val ? val instanceof Date ? val.getTime() : val : '';\n\t\t\t\tif (self.$size)\n\t\t\t\t\tval = (val + '').padRight(meta.size, ' ');\n\t\t\t\telse if (!val)\n\t\t\t\t\tsize += 10;\n\t\t\t\tbreak;\n\n\t\t\tcase 5: // Object\n\t\t\t\tval = val ? JSON.stringify(val) : '';\n\t\t\t\tsize += 4;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!esc && (meta.type === 1 || meta.type === 5)) {\n\t\t\tval += '';\n\t\t\tif (REGTESCAPETEST.test(val)) {\n\t\t\t\tesc = true;\n\t\t\t\tval = val.replace(REGTESCAPE, regtescape);\n\t\t\t}\n\t\t}\n\n\t\toutput += '|' + val;\n\t}\n\n\tif (self.$size && (insert || byteslen)) {\n\t\toutput += '|';\n\t} else if (doc.$$alloc) {\n\t\tvar l = output.length;\n\t\tvar a = doc.$$alloc;\n\t\tif (l <= a.length) {\n\t\t\tvar s = (a.length - l) - 1;\n\t\t\tif (s > 0) {\n\t\t\t\toutput += '|'.padRight(s, '.');\n\t\t\t\tif (byteslen) {\n\t\t\t\t\tvar b = byteslen - Buffer.byteLength(output);\n\t\t\t\t\tif (b > 0) {\n\t\t\t\t\t\tb--;\n\t\t\t\t\t\tfor (var i = 0; i < b; i++)\n\t\t\t\t\t\t\toutput += '.';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar c = s - b;\n\t\t\t\t\t\tif (c > 0)\n\t\t\t\t\t\t\toutput = output.substring(0, (output.length + b) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (s === 0)\n\t\t\t\toutput += '|';\n\t\t\telse\n\t\t\t\tinsert = true;\n\t\t} else\n\t\t\tinsert = true;\n\t} else\n\t\tinsert = true;\n\n\tif (insert && size && self.$allocations)\n\t\toutput += '|'.padRight(size, '.');\n\n\treturn (esc ? '*' : '+') + output;\n};\n\nfunction regtescapereverse(c) {\n\tswitch (c) {\n\t\tcase '%0A':\n\t\t\treturn '\\n';\n\t\tcase '%0D':\n\t\t\treturn '\\r';\n\t\tcase '%7C':\n\t\t\treturn '|';\n\t}\n\treturn c;\n}\n\nfunction regtescape(c) {\n\tswitch (c) {\n\t\tcase '\\n':\n\t\t\treturn '%0A';\n\t\tcase '\\r':\n\t\t\treturn '%0D';\n\t\tcase '|':\n\t\t\treturn '%7C';\n\t}\n\treturn c;\n}\n\nTP.free = function(force) {\n\tvar self = this;\n\tif (!force && !self.$free)\n\t\treturn self;\n\tself.removeAllListeners(true);\n\tdelete F.databases[self.$name];\n\treturn self;\n};\n\n// ======================================================\n// Helper functions\n// ======================================================\n\nfunction compare_datetype(type, key, arg, operator) {\n\n\t// 0 doc\n\t// 1 arg\n\t// 2 operator\n\t// 3 type\n\n\tkey = 'doc.' + key;\n\targ = 'arg.' + arg;\n\n\tswitch (operator) {\n\t\tcase '=':\n\t\t\toperator = '==';\n\t\t\tbreak;\n\t\tcase '<>':\n\t\t\toperator = '!=';\n\t\t\tbreak;\n\t}\n\n\tswitch (type) {\n\t\tcase 'day':\n\t\t\ttype = 'getDate()';\n\t\t\tbreak;\n\t\tcase 'month':\n\t\t\ttype = 'getMonth()+1';\n\t\t\tbreak;\n\t\tcase 'year':\n\t\t\ttype = 'getFullYear()';\n\t\t\tbreak;\n\t\tcase 'hour':\n\t\t\ttype = 'getHour()';\n\t\t\tbreak;\n\t\tcase 'minute':\n\t\t\ttype = 'getMinute()';\n\t\t\tbreak;\n\t}\n\n\treturn '$is=false;$tmp={0};if($tmp){if(!$tmp.getTime){$tmp=new Date($tmp);if(isNaN($tmp))$tmp=0;}if($tmp)$is=($tmp.{3}){2}{1};}'.format(key, arg, operator, type);\n}\n\nfunction errorhandling(err, builder, response) {\n\tif (err)\n\t\treturn err;\n\tvar is = response instanceof Array;\n\tif (!response || (is && !response.length))\n\t\treturn builder.$callback_emptyerror ? new ErrorBuilder().push(builder.$callback_emptyerror) : null;\n\treturn null;\n}\n\nfunction jsonparser(key, value) {\n\treturn typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value;\n}\n\nfunction NoSQLReader(builder) {\n\tvar self = this;\n\tself.builders = [];\n\tself.canceled = 0;\n\tbuilder && self.add(builder);\n}\n\nNoSQLReader.prototype.add = function(builder, noTrimmer) {\n\tvar self = this;\n\tif (builder instanceof Array) {\n\t\tfor (var i = 0; i < builder.length; i++)\n\t\t\tself.add(builder[i]);\n\t} else {\n\t\tvar item = {};\n\t\titem.scalarcount = 0;\n\t\titem.all = 0;\n\t\titem.count = 0;\n\t\titem.counter = 0;\n\t\titem.builder = builder;\n\n\t\tif (builder.$rule) {\n\t\t\tbuilder.$inlinesort = !!(builder.$options.take && builder.$options.sort && builder.$options.sort !== null);\n\t\t\tbuilder.$limit = (builder.$options.take || 0) + (builder.$options.skip || 0);\n\t\t\titem.rule = builder.$rule;\n\t\t\titem.params = builder.$params;\n\t\t\titem.fields = builder.$options.fields;\n\t\t\titem.fields2 = builder.$options.fields2 ? Object.keys(builder.$options.fields2) : null;\n\t\t\titem.sort = builder.$options.sort;\n\t\t} else {\n\t\t\titem.filter = builder.makefilter();\n\t\t\titem.compare = builder.compile(noTrimmer);\n\t\t}\n\n\t\titem.first = builder.$options.first && !builder.$options.sort;\n\n\t\tbuilder.$nosqlreader = self;\n\t\tself.builders.push(item);\n\t}\n\treturn self;\n};\n\nNoSQLReader.prototype.compare2 = function(docs, custom, done) {\n\tvar self = this;\n\n\tfor (var i = 0; i < docs.length; i++) {\n\n\t\tvar doc = docs[i];\n\t\tif (doc === EMPTYOBJECT)\n\t\t\tcontinue;\n\n\t\tif (self.builders.length === self.canceled)\n\t\t\treturn false;\n\n\t\tvar is = false;\n\n\t\tfor (var j = 0; j < self.builders.length; j++) {\n\n\t\t\tvar item = self.builders[j];\n\t\t\tif (item.canceled)\n\t\t\t\tcontinue;\n\n\t\t\tvar output = item.compare ? item.compare(doc, item.filter, item.all++) : (item.rule(doc, item.params, item.all++) ? doc : null);\n\t\t\tif (!output)\n\t\t\t\tcontinue;\n\n\t\t\tif (item.rule) {\n\t\t\t\tif (item.fields) {\n\n\t\t\t\t\tvar clean = {};\n\n\t\t\t\t\tfor (var $i = 0; $i < item.fields.length; $i++) {\n\t\t\t\t\t\tvar prop = item.fields[$i];\n\t\t\t\t\t\tclean[prop] = output[prop];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.sort)\n\t\t\t\t\t\tclean[item.sort.name] = output[item.sort.name];\n\n\t\t\t\t\toutput = clean;\n\t\t\t\t} else if (item.fields2) {\n\t\t\t\t\tfor (var $i = 0; $i < item.fields2.length; $i++)\n\t\t\t\t\t\tdelete output[item.fields2[$i]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// WTF?\n\t\t\t// item.is = false;\n\n\t\t\titem.count++;\n\n\t\t\tif ((item.builder.$options.skip && item.builder.$options.skip >= item.count) || (item.builder.$options.take && item.builder.$options.take <= item.counter))\n\t\t\t\tcontinue;\n\n\t\t\t!is && (is = true);\n\n\t\t\titem.counter++;\n\t\t\titem.builder.$each && item.builder.$each(item, doc);\n\n\t\t\tvar canceled = item.canceled;\n\t\t\tvar c = custom(docs, output, i, item, j);\n\n\t\t\tif (item.first) {\n\t\t\t\titem.canceled = true;\n\t\t\t\tself.canceled++;\n\t\t\t} else if (!canceled && item.canceled)\n\t\t\t\tself.canceled++;\n\n\t\t\tif (c === 1)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tis && done && done(docs, doc, i, self.builders);\n\t}\n};\n\nNoSQLReader.prototype.compare = function(docs) {\n\n\tvar self = this;\n\n\tfor (var i = 0; i < docs.length; i++) {\n\n\t\tvar doc = self.clone ? U.clone(docs[i]) : docs[i];\n\n\t\tif (self.builders.length === self.canceled)\n\t\t\treturn false;\n\n\t\tfor (var j = 0; j < self.builders.length; j++) {\n\n\t\t\tvar item = self.builders[j];\n\t\t\tif (item.canceled)\n\t\t\t\tcontinue;\n\n\t\t\tvar output = item.compare ? item.compare(doc, item.filter, item.all++) : (item.rule(doc, item.params, item.all++) ? doc : null);\n\t\t\tif (!output)\n\t\t\t\tcontinue;\n\n\t\t\tif (item.rule) {\n\t\t\t\tif (item.fields) {\n\n\t\t\t\t\tvar clean = {};\n\n\t\t\t\t\tfor(var $i = 0; $i < item.fields.length; $i++) {\n\t\t\t\t\t\tvar prop = item.fields[$i];\n\t\t\t\t\t\tclean[prop] = output[prop];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.sort)\n\t\t\t\t\t\tclean[item.sort.name] = output[item.sort.name];\n\n\t\t\t\t\toutput = clean;\n\t\t\t\t} else if (item.fields2) {\n\t\t\t\t\tfor (var $i = 0; $i < item.fields2.length; $i++)\n\t\t\t\t\t\tdelete output[item.fields2[$i]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar b = item.builder;\n\t\t\titem.count++;\n\n\t\t\tif (!b.$inlinesort && ((b.$options.skip && b.$options.skip >= item.count) || (b.$options.take && b.$options.take <= item.counter)))\n\t\t\t\tcontinue;\n\n\t\t\titem.counter++;\n\n\t\t\tif (b.$options.notall && !b.$inlinesort && !item.done)\n\t\t\t\titem.done = b.$options.take && b.$options.take <= item.counter;\n\n\t\t\tif (b.$options.readertype)\n\t\t\t\tcontinue;\n\n\t\t\tb.$each && b.$each(item, output);\n\t\t\tb.$mappersexec && b.$mappersexec(output, item);\n\n\t\t\tvar val;\n\n\t\t\tswitch (b.$options.scalar) {\n\t\t\t\tcase 'count':\n\t\t\t\t\titem.scalar = item.scalar ? item.scalar + 1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sum':\n\t\t\t\t\tval = output[b.$options.scalarfield] || 0;\n\t\t\t\t\titem.scalar = item.scalar ? item.scalar + val : val;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'min':\n\t\t\t\t\tval = output[b.$options.scalarfield] || 0;\n\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\tif (item.scalar) {\n\t\t\t\t\t\t\tif (item.scalar > val)\n\t\t\t\t\t\t\t\titem.scalar = val;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\titem.scalar = val;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'max':\n\t\t\t\t\tval = output[b.$options.scalarfield];\n\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\tif (item.scalar) {\n\t\t\t\t\t\t\tif (item.scalar < val)\n\t\t\t\t\t\t\t\titem.scalar = val;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\titem.scalar = val;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'avg':\n\t\t\t\t\tval = output[b.$options.scalarfield];\n\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\titem.scalar = item.scalar ? item.scalar + val : val;\n\t\t\t\t\t\titem.scalarcount++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'group':\n\t\t\t\t\t!item.scalar && (item.scalar = {});\n\t\t\t\t\tval = output[b.$options.scalarfield];\n\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\tif (item.scalar[val])\n\t\t\t\t\t\t\titem.scalar[val]++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\titem.scalar[val] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (b.$inlinesort)\n\t\t\t\t\t\tnosqlinlinesorter(item, b, output);\n\t\t\t\t\telse if (item.response)\n\t\t\t\t\t\titem.response.push(output);\n\t\t\t\t\telse\n\t\t\t\t\t\titem.response = [output];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (item.first || item.done) {\n\t\t\t\titem.canceled = true;\n\t\t\t\tself.canceled++;\n\t\t\t}\n\t\t}\n\t}\n};\n\nNoSQLReader.prototype.reset = function() {\n\tvar self = this;\n\tfor (var i = 0; i < self.builders.length; i++) {\n\t\tvar item = self.builders[i];\n\t\titem.canceled = false;\n\t\titem.response = null;\n\t\titem.scalar = null;\n\t\titem.counter = 0;\n\t\titem.count = 0;\n\t\titem.scalarcount = 0;\n\t}\n\tself.canceled = 0;\n\treturn self;\n};\n\nNoSQLReader.prototype.callback = function(item) {\n\n\tvar self = this;\n\tvar builder = item.builder;\n\tvar output;\n\tvar opt = builder.$options;\n\n\tif (item.canceled) {\n\t\titem.canceled = false;\n\t\tif (self.canceled)\n\t\t\tself.canceled--;\n\t}\n\n\tif (opt.scalar || !opt.sort) {\n\t\tif (opt.scalar)\n\t\t\toutput = opt.scalar === 'avg' ? item.scalar / item.scalarcount : item.scalar;\n\t\telse if (opt.first)\n\t\t\toutput = item.response ? item.response[0] : undefined;\n\t\telse if (opt.listing)\n\t\t\toutput = listing(builder, item);\n\t\telse\n\t\t\toutput = item.response || [];\n\n\t\tbuilder.$callback2(errorhandling(null, builder, output), opt.readertype === 1 ? item.counter : output, item.count, item.filter ? item.filter.repository : item.params);\n\t\treturn self;\n\t}\n\n\tif (item.count) {\n\n\t\tif (opt.sort === null)\n\t\t\titem.response.random();\n\t\telse if (opt.sort.name) {\n\t\t\tif (!builder.$inlinesort || opt.take !== item.response.length)\n\t\t\t\titem.response.quicksort(opt.sort.name, opt.sort.asc);\n\t\t}\n\n\t\tif (opt.skip && opt.take)\n\t\t\titem.response = item.response.splice(opt.skip, opt.take);\n\t\telse if (opt.skip)\n\t\t\titem.response = item.response.splice(opt.skip);\n\t\telse if (!builder.$inlinesort && opt.take)\n\t\t\titem.response = item.response.splice(0, opt.take);\n\t}\n\n\tif (opt.first)\n\t\toutput = item.response ? item.response[0] : undefined;\n\telse if (opt.listing)\n\t\toutput = listing(builder, item);\n\telse\n\t\toutput = item.response || [];\n\n\tbuilder.$callback2(errorhandling(null, builder, output), opt.readertype === 1 ? item.counter : output, item.count, item.filter ? item.filter.repository : item.params);\n\treturn self;\n};\n\nNoSQLReader.prototype.done = function() {\n\tvar self = this;\n\tfor (var i = 0; i < self.builders.length; i++)\n\t\tself.callback(self.builders[i]);\n\tself.canceled = 0;\n\treturn self;\n};\n\n// Converting values\nvar convert = function(value, type) {\n\n\tif (type === undefined || type === String)\n\t\treturn value;\n\n\tif (type === Number)\n\t\treturn value.trim().parseFloat();\n\n\tif (type === Date) {\n\t\tvalue = value.trim();\n\t\tif (value.indexOf(' ') !== -1)\n\t\t\treturn NOW.add('-' + value);\n\t\tif (value.length < 8) {\n\t\t\tvar tmp;\n\t\t\tvar index = value.indexOf('-');\n\t\t\tif (index !== -1) {\n\t\t\t\ttmp = value.split('-');\n\t\t\t\tvalue = NOW.getFullYear() + '-' + (tmp[0].length > 1 ? '' : '0') + tmp[0] + '-' + (tmp[1].length > 1 ? '' : '0') + tmp[1];\n\t\t\t} else {\n\t\t\t\tindex = value.indexOf('.');\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\ttmp = value.split('.');\n\t\t\t\t\tvalue = NOW.getFullYear() + '-' + (tmp[1].length > 1 ? '' : '0') + tmp[0] + '-' + (tmp[0].length > 1 ? '' : '0') + tmp[1];\n\t\t\t\t} else {\n\t\t\t\t\tindex = value.indexOf(':');\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t// hours\n\t\t\t\t\t} else if (value.length <= 4) {\n\t\t\t\t\t\tvalue = +value;\n\t\t\t\t\t\treturn value || 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value.trim().parseDate();\n\t}\n\n\tif (type === Boolean)\n\t\treturn value.trim().parseBoolean();\n\n\treturn value;\n};\n\nDatabaseBuilder.prototype.gridfields = function(fields, allowed) {\n\n\tvar self = this;\n\n\tif (typeof(fields) !== 'string') {\n\t\tif (allowed)\n\t\t\tself.options.fields = allowed.slice(0);\n\t\treturn self;\n\t}\n\n\tfields = fields.replace(REG_FIELDS_CLEANER, '').split(',');\n\n\tif (!self.options.fields)\n\t\tself.options.fields = [];\n\n\tvar count = 0;\n\n\tfor (var i = 0; i < fields.length; i++) {\n\t\tvar field = fields[i];\n\t\tvar can = !allowed;\n\t\tif (!can) {\n\t\t\tfor (var j = 0; j < allowed.length; j++) {\n\t\t\t\tif (allowed[j] === field) {\n\t\t\t\t\tcan = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (can) {\n\t\t\tself.options.fields.push(self.options.dbname === 'pg' ? ('\"' + fields[i] + '\"') : fields[i]);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (!count)\n\t\tself.options.fields = allowed.slice(0);\n\n\treturn self;\n};\n\n// Grid filtering\nDatabaseBuilder.prototype.gridfilter = function(name, obj, type, key) {\n\n\tvar builder = this;\n\tvar value = obj[name];\n\tvar arr, val;\n\n\tif (!key)\n\t\tkey = name;\n\n\t// Between\n\tvar index = value.indexOf(' - ');\n\tif (index !== -1) {\n\n\t\tarr = value.split(' - ');\n\n\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\tvar item = arr[i].trim();\n\t\t\tarr[i] = convert(item, type);\n\t\t}\n\n\t\tif (type === Date) {\n\t\t\tif (typeof(arr[0]) === 'number') {\n\t\t\t\tarr[0] = new Date(arr[0], 1, 1, 0, 0, 0);\n\t\t\t\tarr[1] = new Date(arr[1], 11, 31, 23, 59, 59);\n\t\t\t} else\n\t\t\t\tarr[1] = arr[1].extend('23:59:59');\n\t\t}\n\n\t\treturn builder.between(key, arr[0], arr[1]);\n\t}\n\n\t// Multiple values\n\tindex = value.indexOf(',');\n\tif (index !== -1) {\n\n\t\tvar arr = value.split(',');\n\n\t\tif (type === undefined || type === String) {\n\t\t\tbuilder.or();\n\t\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\t\tvar item = arr[i].trim();\n\t\t\t\tbuilder.search(key, item);\n\t\t\t}\n\t\t\tbuilder.end();\n\t\t\treturn builder;\n\t\t}\n\n\t\tfor (var i = 0, length = arr.length; i < length; i++)\n\t\t\tarr[i] = convert(arr[i], type);\n\n\t\treturn builder.in(key, arr);\n\t}\n\n\tif (type === undefined || type === String)\n\t\treturn builder.search(key, value);\n\n\tif (type === Date) {\n\n\t\tif (value === 'yesterday')\n\t\t\tval = NOW.add('-1 day');\n\t\telse if (value === 'today')\n\t\t\tval = NOW;\n\t\telse\n\t\t\tval = convert(value, type);\n\n\t\tif (typeof(val) === 'number') {\n\t\t\tif (val > 1000)\n\t\t\t\treturn builder.year(key, val);\n\t\t\telse\n\t\t\t\treturn builder.month(key, val);\n\t\t}\n\n\t\tif (!(val instanceof Date) || !val.getTime())\n\t\t\tval = NOW;\n\n\t\treturn builder.between(key, val.extend('00:00:00'), val.extend('23:59:59'));\n\t}\n\n\treturn builder.where(key, convert(value, type));\n};\n\n// Grid sorting\nDatabaseBuilder.prototype.gridsort = function(sort) {\n\tvar builder = this;\n\tvar index = sort.lastIndexOf('_');\n\tif (index === -1)\n\t\tindex = sort.lastIndexOf(' ');\n\tbuilder.sort(sort.substring(0, index), sort[index + 1] === 'd');\n\treturn builder;\n};\n\nDatabaseBuilder.prototype.autofill = function($, allowedfields, skipfilter, defsort, maxlimit, localized) {\n\n\tif (typeof(defsort) === 'number') {\n\t\tmaxlimit = defsort;\n\t\tdefsort = null;\n\t}\n\n\tvar self = this;\n\tvar query = $.query || $.options;\n\tvar schema = $.schema;\n\tvar skipped;\n\tvar allowed;\n\tvar key;\n\tvar tmp;\n\n\tif (skipfilter) {\n\t\tkey = 'NDB_' + skipfilter;\n\t\tskipped = CACHE[key];\n\t\tif (!skipped) {\n\t\t\ttmp = skipfilter.split(',').trim();\n\t\t\tvar obj = {};\n\t\t\tfor (var i = 0; i < tmp.length; i++)\n\t\t\t\tobj[tmp[i]] = 1;\n\t\t\tskipped = CACHE[key] = obj;\n\t\t}\n\t}\n\n\tif (allowedfields) {\n\t\tkey = 'NDB_' + allowedfields;\n\t\tallowed = CACHE[key];\n\t\tif (!allowed) {\n\t\t\tvar obj = {};\n\t\t\tvar arr = [];\n\t\t\tvar filter = [];\n\n\t\t\tif (localized)\n\t\t\t\tlocalized = localized.split(',');\n\n\t\t\ttmp = allowedfields.split(',').trim();\n\t\t\tfor (var i = 0; i < tmp.length; i++) {\n\t\t\t\tvar k = tmp[i].split(':').trim();\n\t\t\t\tobj[k[0]] = 1;\n\n\t\t\t\tif (localized && localized.indexOf(k[0]) !== -1)\n\t\t\t\t\tarr.push(k[0] + 'Â§');\n\t\t\t\telse\n\t\t\t\t\tarr.push(k[0]);\n\n\t\t\t\tk[1] && filter.push({ name: k[0], type: (k[1] || '').toLowerCase() });\n\t\t\t}\n\t\t\tallowed = CACHE[key] = { keys: arr, meta: obj, filter: filter };\n\t\t}\n\t}\n\n\tvar fields = query.fields;\n\tvar fieldscount = 0;\n\tvar opt = self.$options;\n\n\tif (!opt.fields)\n\t\topt.fields = [];\n\n\tif (fields) {\n\t\tfields = fields.replace(REG_FIELDS_CLEANER, '').split(',');\n\t\tfor (var i = 0; i < fields.length; i++) {\n\t\t\tvar field = fields[i];\n\t\t\tif (allowed && allowed.meta[field]) {\n\t\t\t\topt.fields.push(fields[i]);\n\t\t\t\tfieldscount++;\n\t\t\t} else if (schema.schema[field]) {\n\t\t\t\tif (skipped && skipped[field])\n\t\t\t\t\tcontinue;\n\t\t\t\topt.fields.push(field);\n\t\t\t\tfieldscount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!fieldscount) {\n\t\tif (allowed) {\n\t\t\tfor (var i = 0; i < allowed.keys.length; i++)\n\t\t\t\topt.fields.push(allowed.keys[i]);\n\t\t}\n\t\tif (schema.fields) {\n\t\t\tfor (var i = 0; i < schema.fields.length; i++) {\n\t\t\t\tif (skipped && skipped[schema.fields[i]])\n\t\t\t\t\tcontinue;\n\t\t\t\topt.fields.push(schema.fields[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (allowed && allowed.filter) {\n\t\tfor (var i = 0; i < allowed.filter.length; i++) {\n\t\t\ttmp = allowed.filter[i];\n\t\t\tself.gridfilter(tmp.name, query, tmp.type);\n\t\t}\n\t}\n\n\tif (schema.fields) {\n\t\tfor (var i = 0; i < schema.fields.length; i++) {\n\t\t\tvar name = schema.fields[i];\n\t\t\tif ((!skipped || !skipped[name]) && query[name]) {\n\t\t\t\tvar field = schema.schema[name];\n\t\t\t\tvar type = 'string';\n\t\t\t\tswitch (field.type) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\ttype = 'number';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\ttype = 'boolean';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\ttype = 'date';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tself.gridfilter(name, query, type);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (query.sort) {\n\t\tvar index = query.sort.lastIndexOf('_');\n\t\tif (index !== -1) {\n\t\t\tvar name = query.sort.substring(0, index);\n\t\t\tvar can = true;\n\n\t\t\tif (skipped && skipped[name])\n\t\t\t\tcan = false;\n\n\t\t\tif (can && allowed && !allowed.meta[name])\n\t\t\t\tcan = false;\n\n\t\t\tif (can && !allowed) {\n\t\t\t\tif (!schema.schema[name])\n\t\t\t\t\tcan = false;\n\t\t\t} else if (!can)\n\t\t\t\tcan = !!schema.schema[name];\n\n\t\t\tif (can)\n\t\t\t\tself.sort(name, query.sort[index + 1] === 'd');\n\t\t\telse if (defsort)\n\t\t\t\tself.gridsort(defsort);\n\n\t\t} else if (defsort)\n\t\t\tself.gridsort(defsort);\n\n\t} else if (defsort)\n\t\tself.gridsort(defsort);\n\n\tmaxlimit && self.paginate(query.page, query.limit, maxlimit || 50);\n\treturn self;\n};\n\nfunction cluster_send(obj) {\n\tobj.ID = F.id;\n\tprocess.send(obj);\n}\n\nexports.NoSQLReader = NoSQLReader;"
        },
        {
          "name": "nosqlcrawler.js",
          "type": "blob",
          "size": 2.4267578125,
          "content": "// Copyright 2018-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module NoSQL Crawler\n * @version 1.0.0\n */\n\nvar filename = module.filename.replace(/nosqlcrawler\\.js$/, '');\n\nrequire(filename + 'index.js');\nconst NoSQLStream = require(filename + 'nosqlstream.js');\n\nglobal.NOW = global.DATETIME = new Date();\n\nfunction killprocess() {\n\tprocess.exit(0);\n}\n\nsetInterval(function() {\n\tglobal.NOW = global.DATETIME = new Date();\n}, 30000);\n\nprocess.on('disconnect', killprocess);\nprocess.on('close', killprocess);\nprocess.on('exit', killprocess);\nprocess.on('message', function(msg) {\n\n\t// msg.builder;\n\t// msg.filename or msg.data\n\n\tvar builder = new framework_nosql.DatabaseBuilder();\n\tbuilder.parse(msg.builder);\n\n\tvar filters = new framework_nosql.NoSQLReader([builder]);\n\n\tmsg.files.wait(function(item, next) {\n\t\tfind(item.filename, filters, next);\n\t}, function() {\n\t\tvar item = filters.builders[0];\n\t\tprocess.send({ response: item.response, count: item.count });\n\t\tsetTimeout(() => killprocess(), 1000);\n\t});\n\n});\n\nfunction find(filename, filters, next) {\n\n\tvar fs = new NoSQLStream(filename);\n\n\tfs.ondocuments = function() {\n\t\treturn filters.compare(JSON.parse('[' + fs.docs + ']', jsonparser));\n\t};\n\n\tfs.$callback = function() {\n\t\tfs = null;\n\t\tnext();\n\t};\n\n\tfs.openread();\n}\n\nfunction jsonparser(key, value) {\n\treturn typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value;\n}\n"
        },
        {
          "name": "nosqlstream.js",
          "type": "blob",
          "size": 15.58203125,
          "content": "// Copyright 2018-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module NoSQL Stream\n * @version 1.2.0\n */\n\nrequire('./index');\n\nconst Fs = require('fs');\nconst BUFFERSIZE = 1024 * 32;\nconst BUFFERDOCS = 15;\nconst NEWLINEBUFFER = Buffer.from('\\n', 'utf8');\nconst DEFSTATS = { size: 0 };\n\nfunction NoSQLStream(filename) {\n\tthis.filename = filename;\n\tthis.fd = null;\n\tthis.stats = DEFSTATS;\n\tthis.type = null;\n\tthis.bytesread = 0;\n\tthis.ticks = 0;\n\tthis.position = 0;\n\tthis.cache = [null, null];\n\tthis.buffer = null;\n\tthis.divider = ',';\n\tthis.remchar = '-';\n\tthis.buffercount = BUFFERDOCS;\n\tthis.buffersize = BUFFERSIZE;\n\tthis.linesize = 0;\n\tthis.start = 0;\n\tthis.indexer = 0;\n\t// this.canceled = false;\n\t// this.docs = '';\n\t// this.docscount = 0;\n}\n\nconst NoSQLStreamProto = NoSQLStream.prototype;\n\n// Because of performance\nNoSQLStreamProto.readhelpers = function() {\n\n\tvar self = this;\n\n\tself.cb_read = function() {\n\t\tself.read();\n\t};\n\n\tself.cb_readbuffer = function(err, size, chunk) {\n\n\t\tself.position += size;\n\n\t\tvar beg = 0;\n\n\t\tif (self.buffer) {\n\t\t\tself.cache[0] = self.buffer;\n\t\t\tself.cache[1] = chunk;\n\n\t\t\tbeg = self.buffer.length - 1;\n\n\t\t\tif (beg < 0)\n\t\t\t\tbeg = 0;\n\n\t\t\tself.buffer = Buffer.concat(self.cache);\n\n\t\t} else\n\t\t\tself.buffer = chunk;\n\n\t\tvar index = self.buffer.lastIndexOf(NEWLINEBUFFER);\n\t\tif (index === -1) {\n\t\t\tself.read();\n\t\t\treturn;\n\t\t}\n\n\t\tvar tmp = self.buffer.toString('utf8', 0, index).split('\\n');\n\t\tfor (var i = 0; i < tmp.length; i++) {\n\t\t\tif (tmp[i][0] !== self.remchar) {\n\t\t\t\tif (self.array)\n\t\t\t\t\tself.docs.push(tmp[i]);\n\t\t\t\telse\n\t\t\t\t\tself.docs += (self.docs ? self.divider : '') + tmp[i];\n\t\t\t\tself.docscount++;\n\t\t\t\tself.indexer++;\n\t\t\t}\n\t\t}\n\n\t\tself.buffer = self.buffer.slice(index + 1);\n\n\t\tif (self.ondocuments() === false)\n\t\t\tself.canceled = true;\n\n\t\tself.docs = self.array ? [] : '';\n\t\tself.docscount = 0;\n\t\tself.ticks++;\n\n\t\tif (self.ticks % 5 === 0)\n\t\t\tsetImmediate(self.cb_readticks);\n\t\telse\n\t\t\tself.read();\n\t};\n\n\tself.cb_readticks = function() {\n\t\tself.read();\n\t};\n\n\tself.cb_readreverse = function() {\n\t\tself.readreverse2();\n\t};\n\n\tself.cb_readreversebuffer = function(err, size, chunk) {\n\n\t\tself.bytesread += size;\n\n\t\tif (self.buffer) {\n\t\t\tself.cache[0] = chunk;\n\t\t\tself.cache[1] = self.buffer;\n\t\t\tself.buffer = Buffer.concat(self.cache);\n\t\t} else\n\t\t\tself.buffer = chunk;\n\n\t\tvar index = self.buffer.indexOf(NEWLINEBUFFER);\n\t\tif (index === -1) {\n\t\t\tself.readreverse2();\n\t\t\treturn;\n\t\t}\n\n\t\tvar tmp = self.buffer.toString('utf8', index).trim().split('\\n');\n\t\tfor (var i = 0; i < tmp.length; i++) {\n\t\t\tif (tmp[i][0] !== self.remchar) {\n\t\t\t\tif (self.array)\n\t\t\t\t\tself.docs.push(tmp[i]);\n\t\t\t\telse\n\t\t\t\t\tself.docs += (self.docs ? self.divider : '') + tmp[i];\n\t\t\t\tself.docscount++;\n\t\t\t\tself.indexer++;\n\t\t\t}\n\t\t}\n\n\t\tif (self.ondocuments() === false)\n\t\t\tself.canceled = true;\n\n\t\t// self.buffer = self.buffer.slice(0, index + 1);\n\t\tself.buffer = self.buffer.slice(0, index + 1);\n\t\tself.docs = self.array ? [] : '';\n\t\tself.docscount = 0;\n\t\tself.ticks++;\n\n\t\tif (self.ticks % 5 === 0)\n\t\t\tsetImmediate(self.cb_readreverseticks);\n\t\telse\n\t\t\tself.readreverse2();\n\t};\n\n\tself.cb_readreverseticks = function() {\n\t\tself.readreverse2();\n\t};\n\n\tself.cb_readstream = function(chunk) {\n\n\t\tif (self.canceled)\n\t\t\treturn;\n\n\t\tvar beg = 0;\n\n\t\tif (self.buffer) {\n\n\t\t\tself.cache[0] = self.buffer;\n\t\t\tself.cache[1] = chunk;\n\t\t\tself.buffer = Buffer.concat(self.cache);\n\t\t\tbeg = self.cache[0].length - 1;\n\n\t\t\tif (beg < 0)\n\t\t\t\tbeg = 0;\n\t\t} else\n\t\t\tself.buffer = chunk;\n\n\t\tvar index = self.buffer.lastIndexOf(NEWLINEBUFFER);\n\t\tif (index === -1)\n\t\t\treturn;\n\n\t\tvar tmp = self.buffer.toString('utf8', 0, index).split('\\n');\n\t\tfor (var i = 0; i < tmp.length; i++) {\n\t\t\tif (tmp[i][0] !== self.remchar) {\n\t\t\t\tif (self.array)\n\t\t\t\t\tself.docs.push(tmp[i]);\n\t\t\t\telse\n\t\t\t\t\tself.docs += (self.docs ? self.divider : '') + tmp[i];\n\t\t\t\tself.docscount++;\n\t\t\t\tself.indexer++;\n\t\t\t}\n\t\t}\n\n\t\tself.buffer = self.buffer.slice(index + 1);\n\n\t\tif (self.ondocuments() === false)\n\t\t\tself.canceled = true;\n\n\t\tif (self.canceled) {\n\t\t\tself.stream.destroy && self.stream.destroy();\n\t\t} else {\n\t\t\tself.docs = self.array ? [] : '';\n\t\t\tself.docscount = 0;\n\t\t\tself.ticks++;\n\t\t}\n\t};\n\n};\n\n// Because of performance\nNoSQLStreamProto.writehelpers = function() {\n\n\tvar self = this;\n\n\tself.cb_writeAddUpdAdd = function(err, size) {\n\t\tif (err) {\n\t\t\tconsole.log('ERROR --> NoSQLstream.writer (add)', err);\n\t\t\tself.canceled = true;\n\t\t\tself.bufferstacknew.length = 0;\n\t\t\tself.bufferstack.length = 0;\n\t\t\tself.writing = false;\n\t\t} else {\n\t\t\tself.positionappend += size;\n\t\t\tvar item = self.bufferstack.shift();\n\t\t\tFs.write(self.fd, item.data, item.position, 'utf8', self.cb_writeAddUpdUpd);\n\t\t}\n\t};\n\n\tself.cb_writeAddUpdUpd = function(err) {\n\n\t\tself.writing = false;\n\n\t\tif (err) {\n\t\t\tconsole.log('ERROR --> NoSQLstream.writer (upd)', err);\n\t\t\tself.canceled = true;\n\t\t\tself.bufferstack.length = 0;\n\t\t\tself.bufferstacknew.length = 0;\n\t\t} else\n\t\t\tself.$write();\n\t};\n\n\tself.cb_writeAdd = function(err, size) {\n\n\t\tself.writing = false;\n\t\tself.positionappend += size;\n\n\t\tif (err) {\n\t\t\tconsole.log('ERROR --> NoSQLstream.writer (add)', err);\n\t\t\tself.canceled = true;\n\t\t} else\n\t\t\tself.$write();\n\t};\n\n\tself.cb_writeUpd = function(err) {\n\n\t\tself.writing = false;\n\n\t\tif (err) {\n\t\t\tconsole.log('ERROR --> NoSQLstream.writer (upd)', err);\n\t\t\tself.canceled = true;\n\t\t} else\n\t\t\tself.$write();\n\t};\n\n\tself.cb_flush = function() {\n\t\tself.flush();\n\t};\n\n\tself.cb_readwritebuffer2 = function(err, size, chunk) {\n\n\t\tself.position += size;\n\n\t\tvar beg = 0;\n\t\tvar index;\n\n\t\tif (self.buffer) {\n\t\t\tself.cache[0] = self.buffer;\n\t\t\tself.cache[1] = chunk;\n\n\t\t\tbeg = self.buffer.length - 1;\n\n\t\t\tif (beg < 0)\n\t\t\t\tbeg = 0;\n\n\t\t\tself.buffer = Buffer.concat(self.cache);\n\t\t} else\n\t\t\tself.buffer = chunk;\n\n\t\tif (self.linesize) {\n\t\t\twhile (self.buffer.length >= self.linesize) {\n\n\t\t\t\tvar tmp = self.buffer.toString('utf8', 0, self.linesize - 1);\n\n\t\t\t\tif (self.array)\n\t\t\t\t\tself.docs.push(tmp);\n\t\t\t\telse\n\t\t\t\t\tself.docs += (self.docs ? self.divider : '') + tmp;\n\n\t\t\t\tself.docsbuffer.push({ length: self.linesize - 1, doc: tmp, position: self.positionupdate });\n\t\t\t\tself.docscount++;\n\n\t\t\t\tif (self.docsbuffer.length >= self.buffercount) {\n\n\t\t\t\t\tif (self.ondocuments() === false)\n\t\t\t\t\t\tself.canceled = true;\n\n\t\t\t\t\tself.docsbuffer = [];\n\t\t\t\t\tself.docs = self.array ? [] : '';\n\n\t\t\t\t\tif (self.canceled)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tself.positionupdate += self.linesize;\n\t\t\t\tself.buffer = self.buffer.slice(self.linesize);\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tindex = self.buffer.indexOf(NEWLINEBUFFER, beg);\n\t\t\twhile (index !== -1) {\n\t\t\t\tvar tmp = self.buffer.toString('utf8', 0, index);\n\n\t\t\t\tif (tmp[0] !== self.remchar) {\n\n\t\t\t\t\tif (self.array)\n\t\t\t\t\t\tself.docs.push(tmp);\n\t\t\t\t\telse\n\t\t\t\t\t\tself.docs += (self.docs ? self.divider : '') + tmp;\n\n\t\t\t\t\tself.docsbuffer.push({ length: index, doc: tmp, position: self.positionupdate });\n\t\t\t\t\tself.docscount++;\n\t\t\t\t\tif (self.docsbuffer.length >= self.buffercount) {\n\t\t\t\t\t\tif (self.ondocuments() === false)\n\t\t\t\t\t\t\tself.canceled = true;\n\t\t\t\t\t\tself.docsbuffer = [];\n\t\t\t\t\t\tself.docs = self.array ? [] : '';\n\t\t\t\t\t\tif (self.canceled)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tself.positionupdate += Buffer.byteLength(tmp, 'utf8') + 1;\n\t\t\t\tself.buffer = self.buffer.slice(index + 1);\n\t\t\t\tindex = self.buffer.indexOf(NEWLINEBUFFER);\n\t\t\t\tif (index === -1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (self.bufferstack.length || self.bufferstacknew.length)\n\t\t\tsetImmediate(self.cb_writeticks);\n\t\telse\n\t\t\tself.readupdate();\n\t};\n\n\tself.cb_readwritebuffer = function(err, size, chunk) {\n\n\t\tself.position += size;\n\n\t\tvar beg = 0;\n\t\tvar index;\n\n\t\tif (self.buffer) {\n\t\t\tself.cache[0] = self.buffer;\n\t\t\tself.cache[1] = chunk;\n\t\t\tbeg = self.buffer.length - 1;\n\t\t\tif (beg < 0)\n\t\t\t\tbeg = 0;\n\t\t\tself.buffer = Buffer.concat(self.cache);\n\t\t} else\n\t\t\tself.buffer = chunk;\n\n\n\t\tvar index = self.buffer.lastIndexOf(NEWLINEBUFFER);\n\t\tif (index === -1) {\n\t\t\tself.readupdate();\n\t\t\treturn;\n\t\t}\n\n\t\tvar tmp = self.buffer.toString('utf8', 0, index).split('\\n');\n\t\tfor (var i = 0; i < tmp.length; i++) {\n\t\t\tvar size = Buffer.byteLength(tmp[i], 'utf8');\n\t\t\tif (tmp[i][0] !== self.remchar) {\n\t\t\t\tif (self.array)\n\t\t\t\t\tself.docs.push(tmp[i]);\n\t\t\t\telse\n\t\t\t\t\tself.docs += (self.docs ? self.divider : '') + tmp[i];\n\t\t\t\tself.docsbuffer.push({ length: size, doc: tmp[i], position: self.positionupdate });\n\t\t\t\tself.docscount++;\n\t\t\t\tself.indexer++;\n\t\t\t}\n\t\t\tself.positionupdate += size + 1;\n\t\t}\n\n\t\tif (self.ondocuments() === false)\n\t\t\tself.canceled = true;\n\n\t\tself.docsbuffer = [];\n\t\tself.docs = self.array ? [] : '';\n\t\tself.buffer = self.buffer.slice(index + 1);\n\n\t\tif (self.bufferstack.length || self.bufferstacknew.length)\n\t\t\tsetImmediate(self.cb_writeticks);\n\t\telse\n\t\t\tself.readupdate();\n\t};\n\n\tself.cb_writeticks = function() {\n\t\tif (self.bufferstack.length || self.bufferstacknew.length)\n\t\t\tsetImmediate(self.cb_writeticks);\n\t\telse\n\t\t\tself.readupdate();\n\t};\n};\n\nNoSQLStreamProto.openread = function() {\n\tvar self = this;\n\tself.type = 'r';\n\tself.position = self.start;\n\tself.open();\n\treturn self;\n};\n\nNoSQLStreamProto.openreadreverse = function() {\n\tvar self = this;\n\tself.type = 'r';\n\tself.position = self.start;\n\tself.$reverse = true;\n\tself.open();\n\treturn self;\n};\n\nNoSQLStreamProto.openupdate = function() {\n\tvar self = this;\n\tself.type = 'r+';\n\tF.stats.performance.open++;\n\tFs.open(self.filename, self.type, function(err, fd) {\n\n\t\tif (err) {\n\t\t\tself.$callback(err);\n\t\t\treturn;\n\t\t}\n\n\t\tFs.fstat(fd, function(err, stats) {\n\n\t\t\tself.docs = self.array ? [] : '';\n\t\t\tself.docscount = 0;\n\n\t\t\tif (err) {\n\t\t\t\tFs.close(fd, NOOP);\n\t\t\t\tself.$callback(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tself.docs = self.array ? [] : '';\n\t\t\tself.docscount = 0;\n\t\t\tself.fd = fd;\n\t\t\tself.stats = stats;\n\t\t\tself.position = self.start;\n\t\t\tself.positionappend = self.stats.size;\n\t\t\tself.positionupdate = self.start;\n\t\t\tself.bufferstack = [];\n\t\t\tself.bufferstacknew = [];\n\t\t\tself.docsbuffer = [];\n\t\t\tself.writehelpers();\n\t\t\tself.readupdate();\n\t\t});\n\t});\n\n\treturn self;\n};\n\n// For e.g. files on URL address\nNoSQLStreamProto.openstream = function(stream) {\n\n\tvar self = this;\n\n\tvar close = function() {\n\t\tif (self.docscount) {\n\t\t\tself.ondocuments();\n\t\t\tself.docscount = 0;\n\t\t\tself.docs = self.array ? [] : '';\n\t\t}\n\t\tself.$callback && self.$callback();\n\t\tself.$callback = null;\n\t};\n\n\tself.docs = self.array ? [] : '';\n\tself.docscount = 0;\n\tself.readhelpers();\n\tself.stream = stream;\n\tself.stream.on('error', close);\n\tself.stream.on('end', close);\n\tself.stream.on('data', self.cb_readstream);\n\treturn self;\n};\n\nNoSQLStreamProto.open = function() {\n\tvar self = this;\n\tF.stats.performance.open++;\n\tFs.open(self.filename, self.type, function(err, fd) {\n\n\t\tif (err) {\n\t\t\tself.$callback(err);\n\t\t\treturn;\n\t\t}\n\n\t\tFs.fstat(fd, function(err, stats) {\n\t\t\tself.docs = self.array ? [] : '';\n\t\t\tself.docscount = 0;\n\t\t\tself.fd = fd;\n\t\t\tself.stats = stats;\n\t\t\tself.position = self.start;\n\n\t\t\tif (err) {\n\t\t\t\tFs.close(fd, NOOP);\n\t\t\t\tself.$callback(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tself.readhelpers();\n\n\t\t\tif (self.$reverse)\n\t\t\t\tself.readreverse();\n\t\t\telse\n\t\t\t\tself.read();\n\t\t});\n\t});\n};\n\nNoSQLStreamProto.close = function() {\n\n\tvar self = this;\n\n\tif (self.fd) {\n\n\t\tself.stream = null;\n\n\t\tFs.close(self.fd, function(err) {\n\t\t\terr && F.error(err);\n\t\t\tself.$callback && self.$callback();\n\t\t});\n\n\t\tif (self.buffer) {\n\t\t\tself.buffer = null;\n\t\t\tself.cache[0] = null;\n\t\t\tself.cache[1] = null;\n\t\t\tself.bytesread = 0;\n\t\t}\n\n\t\tself.canceled = false;\n\t\tself.fd = null;\n\t\tself.type = null;\n\t\tself.docscache = null;\n\t\tself.docs = null;\n\n\t} else if (self.$callback)\n\t\tself.$callback && self.$callback();\n\n\treturn self;\n};\n\nNoSQLStreamProto.write = function(doc, position) {\n\tvar self = this;\n\tself.bufferstack.push({ position: position, data: doc });\n\t!self.writing && self.$write();\n\treturn self;\n};\n\nNoSQLStreamProto.write2 = function(doc) {\n\tvar self = this;\n\tself.bufferstacknew.push(Buffer.from(doc));\n\t!self.writing && self.$write();\n\treturn self;\n};\n\nNoSQLStreamProto.$write = function() {\n\tvar self = this;\n\tif (self.bufferstacknew.length && self.bufferstack.length) {\n\t\tself.writing = true;\n\t\tvar buf = self.bufferstacknew.splice(0, 5);\n\t\tbuf = buf.length > 1 ? Buffer.concat(buf) : buf[0];\n\t\tFs.write(self.fd, buf, 0, buf.length, self.positionappend, self.cb_writeAddUpdAdd);\n\t} else if (self.bufferstacknew.length) {\n\t\tself.writing = true;\n\t\tvar buf = self.bufferstacknew.splice(0, 5);\n\t\tbuf = buf.length > 1 ? Buffer.concat(buf) : buf[0];\n\t\tFs.write(self.fd, buf, 0, buf.length, self.positionappend, self.cb_writeAdd);\n\t} else if (self.bufferstack.length) {\n\t\tself.writing = true;\n\t\tvar item = self.bufferstack.shift();\n\t\tFs.write(self.fd, item.data, item.position, 'utf8', self.cb_writeUpd);\n\t}\n};\n\nNoSQLStreamProto.flush = function() {\n\tvar self = this;\n\tif (self.writing)\n\t\tsetTimeout(self.cb_flush, 100);\n\telse\n\t\tself.close();\n\treturn self;\n};\n\nNoSQLStreamProto.read = function() {\n\n\tvar self = this;\n\tvar size = self.stats.size - self.position;\n\n\n\tif (!self.fd || size <= 0 || self.canceled) {\n\n\t\tif (!self.canceled && self.buffer && self.buffer.length) {\n\t\t\tself.cb_readbuffer(null, 1, NEWLINEBUFFER);\n\t\t\tself.buffer = Buffer.alloc(0);\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.docscount) {\n\t\t\tself.ondocuments();\n\t\t\tself.docscount = 0;\n\t\t\tself.docs = self.array ? [] : '';\n\t\t}\n\n\t\tself.close();\n\n\t} else {\n\t\tsize = size < self.buffersize ? size : self.buffersize;\n\t\tvar buffer = Buffer.alloc(size);\n\t\tFs.read(self.fd, buffer, 0, size, self.position, self.cb_readbuffer);\n\t}\n};\n\nNoSQLStreamProto.readreverse = function() {\n\tvar self = this;\n\tself.position = self.stats.size;\n\tself.readreverse2();\n\treturn self;\n};\n\nNoSQLStreamProto.readreverse2 = function() {\n\tvar self = this;\n\n\tif (!self.fd || self.position <= self.start || self.canceled) {\n\n\t\tif (!self.canceled && self.buffer && self.buffer.length) {\n\t\t\tself.cb_readreversebuffer(null, 1, NEWLINEBUFFER);\n\t\t\tself.buffer = Buffer.alloc(0);\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.docscount) {\n\t\t\tself.ondocuments();\n\t\t\tself.docs = self.array ? [] : '';\n\t\t\tself.docscount = 0;\n\t\t}\n\n\t\tself.close();\n\n\t} else {\n\t\tvar size = self.stats.size - self.bytesread;\n\t\tsize = size < self.buffersize ? size : self.buffersize;\n\t\tself.position -= size;\n\t\tvar buffer = Buffer.alloc(size);\n\t\tFs.read(self.fd, buffer, 0, size, self.position, self.cb_readreversebuffer);\n\t}\n};\n\nNoSQLStreamProto.readupdate = function() {\n\n\tvar self = this;\n\tvar size = self.stats.size - self.position;\n\n\tif (!self.fd || size <= 0 || self.canceled) {\n\n\t\tif (!self.canceled && self.buffer && self.buffer.length) {\n\t\t\tself.positionappend++;\n\t\t\tself.cb_readwritebuffer(null, 1, NEWLINEBUFFER);\n\t\t\tself.buffer = Buffer.alloc(0);\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.docsbuffer.length) {\n\t\t\tself.ondocuments();\n\t\t\tself.docsbuffer = [];\n\t\t\tself.docs = self.array ? [] : '';\n\t\t}\n\n\t\tself.flush();\n\t} else {\n\t\tsize = size < self.buffersize ? size : self.buffersize;\n\t\tvar buffer = Buffer.alloc(size);\n\t\tFs.read(self.fd, buffer, 0, size, self.position, self.cb_readwritebuffer);\n\t}\n};\n\nmodule.exports = NoSQLStream;"
        },
        {
          "name": "nosqlworker.js",
          "type": "blob",
          "size": 7.953125,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module NoSQL Worker\n * @version 1.0.0\n */\n\nrequire(module.filename.replace(/nosqlworker\\.js$/, 'index.js'));\n\nconst RESFIND = { TYPE: 'find' };\nconst RESINSERT = { TYPE: 'insert' };\nconst RESCOUNT = { TYPE: 'count' };\nconst RESUPDATE = { TYPE: 'update' };\nconst RESBACKUP = { TYPE: 'backup' };\nconst RESRESTORE = { TYPE: 'restore' };\nconst RESREMOVE = { TYPE: 'remove' };\nconst RESCALLBACK = { TYPE: 'callback' };\nconst RESCOUNTERREAD = { TYPE: 'counter.read' };\nconst RESCOUNTERSTATS = { TYPE: 'counter.stats' };\nconst RESCOUNTERCLEAR = { TYPE: 'counter.clear' };\nconst RESTORAGESCAN = { TYPE: 'storage.scan' };\nconst RESTORAGESTATS = { TYPE: 'storage.stats' };\nconst RESSTORAGECLEAR = { TYPE: 'storage.clear' };\nconst RESSTREAM = { TYPE: 'stream' };\n\nglobal.NOW = global.DATETIME = new Date();\n\nfunction killprocess() {\n\tprocess.exit(0);\n}\n\nsetInterval(function() {\n\tglobal.NOW = global.DATETIME = new Date();\n}, 30000);\n\n// One day cleaner\nsetInterval(function() {\n\tvar keys = Object.keys(F.databasescleaner);\n\tkeys.length && keys.wait(function(item, next) {\n\t\tNOSQL(item).clean(next);\n\t});\n}, 60000 * 60 * 24);\n\nprocess.on('disconnect', killprocess);\nprocess.on('close', killprocess);\nprocess.on('exit', killprocess);\nprocess.on('message', function(msg) {\n\n\tif (msg.TYPE === 'init') {\n\t\tF.directory = msg.directory;\n\t\treturn;\n\t}\n\n\tvar db = msg.t ? TABLE(msg.name) : NOSQL(msg.name);\n\n\tswitch (msg.TYPE) {\n\t\tcase 'find':\n\t\t\tdb.find().parse(msg.data).callback(function(err, response, count, repository) {\n\t\t\t\tRESFIND.err = err;\n\t\t\t\tRESFIND.response = response;\n\t\t\t\tRESFIND.count = count;\n\t\t\t\tRESFIND.repository = repository;\n\t\t\t\tRESFIND.id = msg.id;\n\t\t\t\tprocess.send(RESFIND);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'find2':\n\t\t\tdb.find2().parse(msg.data).callback(function(err, response, count, repository) {\n\t\t\t\tRESFIND.err = err;\n\t\t\t\tRESFIND.response = response;\n\t\t\t\tRESFIND.count = count;\n\t\t\t\tRESFIND.repository = repository;\n\t\t\t\tRESFIND.id = msg.id;\n\t\t\t\tprocess.send(RESFIND);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'top':\n\t\t\tdb.top().parse(msg.data).callback(function(err, response, count, repository) {\n\t\t\t\tRESFIND.err = err;\n\t\t\t\tRESFIND.response = response;\n\t\t\t\tRESFIND.count = count;\n\t\t\t\tRESFIND.repository = repository;\n\t\t\t\tRESFIND.id = msg.id;\n\t\t\t\tprocess.send(RESFIND);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'one':\n\t\t\tdb.one().parse(msg.data).callback(function(err, response, count, repository) {\n\t\t\t\tRESFIND.err = err;\n\t\t\t\tRESFIND.response = response;\n\t\t\t\tRESFIND.count = count;\n\t\t\t\tRESFIND.repository = repository;\n\t\t\t\tRESFIND.id = msg.id;\n\t\t\t\tprocess.send(RESFIND);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'insert':\n\t\t\tdb.insert(msg.arg[0], msg.arg[1]).parse(msg.data).callback(function(err, response) {\n\t\t\t\tRESINSERT.err = err;\n\t\t\t\tRESINSERT.response = response;\n\t\t\t\tRESINSERT.id = msg.id;\n\t\t\t\tprocess.send(RESINSERT);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'update':\n\n\t\t\tif (typeof(msg.arg[0]) === 'string')\n\t\t\t\tmsg.arg[0] = eval('(' + msg.arg[0] + ')');\n\n\t\t\tdb.update(msg.arg[0], msg.arg[1]).parse(msg.data).callback(function(err, response, repository) {\n\t\t\t\tRESUPDATE.err = err;\n\t\t\t\tRESUPDATE.response = response;\n\t\t\t\tRESUPDATE.id = msg.id;\n\t\t\t\tRESUPDATE.repository = repository;\n\t\t\t\tprocess.send(RESUPDATE);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'modify':\n\n\t\t\tif (typeof(msg.arg[0]) === 'string')\n\t\t\t\tmsg.arg[0] = eval('(' + msg.arg[0] + ')');\n\n\t\t\tdb.modify(msg.arg[0], msg.arg[1]).parse(msg.data).callback(function(err, response, repository) {\n\t\t\t\tRESUPDATE.err = err;\n\t\t\t\tRESUPDATE.response = response;\n\t\t\t\tRESUPDATE.id = msg.id;\n\t\t\t\tRESUPDATE.repository = repository;\n\t\t\t\tprocess.send(RESUPDATE);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'count':\n\t\t\tdb.count().parse(msg.data).callback(function(err, response, count, repository) {\n\t\t\t\tRESCOUNT.err = err;\n\t\t\t\tRESCOUNT.response = response;\n\t\t\t\tRESCOUNT.count = count;\n\t\t\t\tRESCOUNT.repository = repository;\n\t\t\t\tRESCOUNT.id = msg.id;\n\t\t\t\tprocess.send(RESCOUNT);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'remove':\n\t\t\tdb.remove(msg.arg ? msg.arg[0] : undefined).parse(msg.data).callback(function(err, response, repository) {\n\t\t\t\tRESREMOVE.err = err;\n\t\t\t\tRESREMOVE.response = response;\n\t\t\t\tRESREMOVE.repository = repository;\n\t\t\t\tRESREMOVE.id = msg.id;\n\t\t\t\tprocess.send(RESREMOVE);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'backup':\n\t\t\tdb.backup(msg.arg[0], function(err, response) {\n\t\t\t\tRESBACKUP.id = msg.id;\n\t\t\t\tRESBACKUP.err = err;\n\t\t\t\tRESBACKUP.response = response;\n\t\t\t\tprocess.send(RESBACKUP);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'restore':\n\t\t\tdb.restore(msg.arg[0], function(err, response) {\n\t\t\t\tRESRESTORE.id = msg.id;\n\t\t\t\tRESRESTORE.err = err;\n\t\t\t\tRESRESTORE.response = response;\n\t\t\t\tprocess.send(RESRESTORE);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'refresh':\n\t\t\tdb.refresh();\n\t\t\tbreak;\n\t\tcase 'drop':\n\t\t\tdb.drop();\n\t\t\tbreak;\n\t\tcase 'counter.min':\n\t\t\tdb.counter.min(msg.arg[0], msg.arg[1]);\n\t\t\tbreak;\n\t\tcase 'counter.max':\n\t\t\tdb.counter.max(msg.arg[0], msg.arg[1]);\n\t\t\tbreak;\n\t\tcase 'counter.hit':\n\t\t\tdb.counter.hit(msg.arg[0], msg.arg[1]);\n\t\t\tbreak;\n\t\tcase 'counter.remove':\n\t\t\tdb.counter.remove(msg.arg ? msg.arg[0] : undefined);\n\t\t\tbreak;\n\t\tcase 'counter.read':\n\t\t\tdb.counter.read(msg.arg[0], function(err, response) {\n\t\t\t\tRESCOUNTERREAD.id = msg.id;\n\t\t\t\tRESCOUNTERREAD.err = err;\n\t\t\t\tRESCOUNTERREAD.response = response;\n\t\t\t\tprocess.send(RESCOUNTERREAD);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'counter.stats':\n\t\t\tdb.counter.stats(msg.arg[0], msg.arg[1], msg.arg[2], msg.arg[3], msg.arg[4], function(err, response) {\n\t\t\t\tRESCOUNTERSTATS.id = msg.id;\n\t\t\t\tRESCOUNTERSTATS.err = err;\n\t\t\t\tRESCOUNTERSTATS.response = response;\n\t\t\t\tprocess.send(RESCOUNTERSTATS);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'counter.clear':\n\t\t\tdb.counter.clear(function(err) {\n\t\t\t\tRESCOUNTERCLEAR.id = msg.id;\n\t\t\t\tRESCOUNTERCLEAR.err = err;\n\t\t\t\tprocess.send(RESCOUNTERCLEAR);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'storage.insert':\n\t\t\tdb.storage.insert(msg.arg[0]);\n\t\t\tbreak;\n\t\tcase 'storage.stats':\n\t\t\tdb.storage.stats(msg.arg[0], function(err, response) {\n\t\t\t\tRESTORAGESTATS.id = msg.id;\n\t\t\t\tRESTORAGESTATS.response = response;\n\t\t\t\tRESTORAGESTATS.err = err;\n\t\t\t\tprocess.send(RESTORAGESTATS);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'storage.scan':\n\t\t\tdb.storage.scan(msg.arg[0], msg.arg[1], eval('(' + msg.arg[2] + ')'), function(err, response, repository) {\n\t\t\t\tRESTORAGESCAN.id = msg.id;\n\t\t\t\tRESTORAGESCAN.response = response;\n\t\t\t\tRESTORAGESCAN.repository = repository;\n\t\t\t\tRESTORAGESCAN.err = err;\n\t\t\t\tprocess.send(RESTORAGESCAN);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'storage.clear':\n\t\t\tdb.storage.clear(msg.arg[0], msg.arg[1], function(err, response) {\n\t\t\t\tRESSTORAGECLEAR.id = msg.id;\n\t\t\t\tRESSTORAGECLEAR.response = response;\n\t\t\t\tRESSTORAGECLEAR.err = err;\n\t\t\t\tprocess.send(RESSTORAGECLEAR);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'stream':\n\t\t\tdb[msg.TYPE](eval('(' + msg.arg[0] + ')'), msg.arg[1], function(err, repository, count) {\n\t\t\t\tRESSTREAM.id = msg.id;\n\t\t\t\tRESSTREAM.err = err;\n\t\t\t\tRESSTREAM.repository = repository;\n\t\t\t\tRESSTREAM.count = count;\n\t\t\t\tprocess.send(RESSTREAM);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'clean':\n\t\tcase 'clear':\n\t\tcase 'ready':\n\t\t\tdb[msg.TYPE](function(err) {\n\t\t\t\tRESCALLBACK.id = msg.id;\n\t\t\t\tRESCALLBACK.err = err;\n\t\t\t\tprocess.send(RESCALLBACK);\n\t\t\t});\n\t\t\tbreak;\n\t}\n});"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 2.1708984375,
          "content": "{\n    \"_from\": \"total.js\",\n    \"author\": {\n        \"name\": \"Peter Sirka\",\n        \"email\": \"petersirka@gmail.com\",\n        \"url\": \"http://www.petersirka.com\"\n    },\n    \"bin\": {\n        \"total\": \"./bin/totaljs\",\n        \"total.js\": \"./bin/totaljs\",\n        \"totaljs\": \"./bin/totaljs\",\n        \"tpm\": \"./bin/tpm\",\n        \"totalpackage\": \"./bin/tpm\"\n    },\n    \"description\": \"MVC framework for Node.js\",\n    \"devDependencies\": {},\n    \"directories\": {\n        \"test\": \"test\"\n    },\n    \"engines\": {\n        \"node\": \">=8.0.0\"\n    },\n    \"keywords\": [\"total\", \"iot\", \"framework\", \"web\", \"websocket\", \"mvc\", \"controller\", \"view\", \"angular.js\", \"upload\", \"picture\", \"graphicsmagick\", \"imagemagick\", \"eshop\", \"blog\", \"forum\", \"chat\", \"game\", \"nosql\", \"database\", \"streaming\", \"live\", \"server sent events\", \"sse\", \"multipart\", \"x-mixed-replace\"],\n    \"license\": \"MIT\",\n    \"main\": \"./index.js\",\n    \"name\": \"total.js\",\n    \"readmeFilename\": \"readme.md\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/totaljs/framework.git\"\n    },\n    \"scripts\": {\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n    },\n    \"contributors\": [{\n        \"name\": \"Peter Å irka\",\n        \"email\": \"petersirka@gmail.com\"\n    }, {\n        \"name\": \"Radek / rsmogura\",\n        \"email\": \"\"\n    },{\n        \"name\": \"Liao San-Kai\",\n        \"email\": \"liaosankai@gmail.com\"\n    },{\n        \"name\": \"Marchukov Ivan\",\n        \"email\": \"marchukov.ivan@gmail.com\"\n    },{\n        \"name\": \"Martin Smola\",\n        \"email\": \"smola.martin@gmail.com\"\n    },{\n        \"name\": \"Denis Granec\",\n        \"email\": \"danis1999@gmail.com\"\n    },{\n        \"name\": \"Chao Tang Chang\",\n        \"email\": \"mrgmp2004@hotmail.com\"\n    },{\n        \"name\": \"luoage\",\n        \"email\": \"luoage@msn.cn\"\n    },{\n        \"name\": \"Tema Smirnov\",\n        \"email\": \"github.tema@smirnov.one\"\n    }, {\n        \"name\": \"Jeroen van Hilst\",\n        \"email\": \"frunjik@gmail.com\"\n    }, {\n        \"name\": \"Sarp Aykent\",\n        \"email\": \"shackhers@gmail.com\"\n    }],\n    \"version\": \"3.4.13\",\n    \"homepage\": \"http://www.totaljs.com\",\n    \"bugs\": {\n        \"url\": \"https://github.com/totaljs/framework/issues\",\n        \"email\": \"petersirka@gmail.com\"\n    }\n}\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 4.7080078125,
          "content": "Node.js framework\n=================\n\n[![Made in EU](https://cdn.componentator.com/eu-small.png)](https://european-union.europa.eu/)\n\n__Total.js framework__ is a framework for Node.js platfrom written in `pure` JavaScript similar to PHP's Laravel or Python's Django or ASP.NET MVC. It can be used as web, desktop, service or IoT application.\n\n__IMPORTANT__: [New version __Total.js 4__](https://github.com/totaljs/framework4)\n\n```bash\n$ npm install -g total.js\n```\n\n- [Total.js Code editor](http://www.totaljs.com/code/)\n- [Total.js CMS](http://www.totaljs.com/cms/)\n- [Total.js Eshop](http://www.totaljs.com/eshop/)\n- [Total.js Wiki](https://www.totaljs.com/wiki/)\n- [Total.js Flow](https://www.totaljs.com/flow/)\n- [Total.js Flowboard](https://www.totaljs.com/flowboard/)\n- [Total.js Messenger](https://www.totaljs.com/messenger/)\n- [Total.js Dashboard](https://www.totaljs.com/dashboard/)\n- [Total.js BlogEngine](https://www.totaljs.com/blogengine/)\n- [Total.js SuperAdmin](https://www.totaljs.com/superadmin/)\n- [Total.js HelpDesk](https://www.totaljs.com/helpdesk/)\n- [Total.js OpenPlatform](https://www.totaljs.com/openplatform/)\n- [Total.js +100 examples](https://github.com/totaljs/examples)\n- [NoSQL embedded database explorer](https://www.totaljs.com/nosql/)\n- [Download +200 UI components for free](https://componentator.com)\n- [Download +100 CMS widgets for free](https://componentator.com/widgets/)\n\n---\n\n- [Website](http://www.totaljs.com)\n- [__Get Started__](http://www.totaljs.com/get-started/)\n- [__Documentation__](http://docs.totaljs.com)\n- [__Wiki for Total.js products__](http://wiki.totaljs.com)\n- [__Live chat with professional support__](https://platform.totaljs.com?app=messenger)\n- [__Total.js Blog__](https://blog.totaljs.com)\n- [__Membership__](https://platform.totaljs.com)\n- [Changelog](https://github.com/totaljs/framework/blob/master/changes.txt)\n\n## Official support\n\n- [Support form](http://www.totaljs.com/support/)\n- Support e-mail: <support@totaljs.com>\n\n| Top features |\n|------|\n| [__Offline documentation__](http://docs.totaljs.com) |\n| __Backward compatibility__ |\n| HMVC architecture |\n| Clean directory structure |\n| Fully asynchronous |\n| Full web server with serving of static files |\n| Supports IP restrictions |\n| Supports redirections |\n| Supports reusable components |\n| Supports just-in-time JS, CSS (variables and nesting) and HTML compressor |\n| Supports just-in-time merging of static files (JavaScripts, CSS or HTML) |\n| Supports just-in-time mapping of files |\n| Supports media streaming (e.g. videos) |\n| Supports modules and packages |\n| Built-in image processing engine via ImageMagick or GraphicsMagick |\n| Supports WebSockets (__RFC 6455__) and Server-Sent events |\n| __NEW__ Supports WebSockets client |\n| Supports `multipart/x-mixed-replace` (IP camera streaming) uploading and sending |\n| Supports RESTful routing |\n| Supports middleware (like express.js) with custom options |\n| Supports unit testing |\n| Supports workers for heavy CPU operations |\n| Supports 4x config files (common, debug, release and test) |\n| Mailer with templating (Gmail, Outlook or classic SMTP servers with auth and TLS) |\n| Built-in view engine (layouts, nested views, conditions, loops, inline helpers, etc.) |\n| Localization with diff tool and CSV export |\n| Supports cache mechanism |\n| Supports schemas for creating business objects with validations, workflows, etc. |\n| Supports injecting scripts, packages and views from URL |\n| Supports String, Date, Number and Array prototypes |\n| Supports additional utilities (e.g. create request, XML parsing, etc.) |\n| Supports themes |\n| Supports scripting |\n| Possibility to rewrite existing functionality |\n| NoSQL embedded database\n\n## Social networks\n\nPlease support the framework on social networks.\n\n- [Follow Total.js on Gitter](https://gitter.im/totaljs/framework)\n- [Follow Total.js on GitHub](https://github.com/totaljs/framework)\n- [Follow Total.js on Twitter - __@totalframework__](https://twitter.com/totalframework)\n- [Follow Total.js on Facebook](https://www.facebook.com/totaljs.web.framework)\n- [Follow Total.js on LinkedIn](https://www.linkedin.com/groups/totaljs-8109884)\n\n## Contact\n\n- (c) 2012-2021 by Peter Å irka - <petersirka@gmail.com>\n- contact form <https://www.totaljs.com/contact/>\n- <info@totaljs.com>\n\n[license-image]: https://img.shields.io/badge/license-MIT-blue.svg?style=flat\n[license-url]: license.txt\n\n[npm-url]: https://npmjs.org/package/total.js\n[npm-version-image]: https://img.shields.io/npm/v/total.js.svg?style=flat\n[npm-downloads-image]: https://img.shields.io/npm/dm/total.js.svg?style=flat\n[npm-quality]: http://npm.packagequality.com/shield/total.js.svg\n\n[travis-url]: https://travis-ci.org/totaljs/framework\n[travis-image]: https://img.shields.io/travis/totaljs/framework.svg?style=flat\n"
        },
        {
          "name": "session.js",
          "type": "blob",
          "size": 19.796875,
          "content": "// Copyright 2019-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkSession\n * @version 3.4.0\n */\n\nrequire('./index');\n\nconst COOKIEOPTIONS = { httponly: true, security: 'lax' };\nconst Fs = require('fs');\nconst filename = 'sessions{0}.txt';\n\nfunction Session(name, ondata) {\n\n\tif (typeof(name) === 'function') {\n\t\tondata = name;\n\t\tname = null;\n\t}\n\n\tvar t = this;\n\tvar timeoutsave = null;\n\n\tt.name = name || '';\n\tt.items = new Map();\n\tt.$sync = true;\n\tt.$savecallback = ERROR('session.save');\n\tt.ondata = ondata;\n\tt.pending = {};\n\tt.ddos = {};\n\tt.ddosis = false;\n\n\t// t.onremove = function(item)\n\t// t.onrelease = function(item)\n\t// t.ondata = function(item, next(err, data))\n\n\tt.$save = function() {\n\t\ttimeoutsave && clearTimeout(timeoutsave);\n\t\ttimeoutsave = setTimeout(t.$saveforce, 1000 * 10); // 10 seconds\n\t};\n\n\tt.$saveforce = function() {\n\t\tvar storage = [];\n\t\tfor (var m of t.items.values()) {\n\t\t\tif (m.expire > NOW)\n\t\t\t\tstorage.push(encodeURIComponent(m.sessionid) + ';' + (m.id ? encodeURIComponent(m.id) : '') + ';' + m.expire.getTime() + ';' + (m.used ? m.used.getTime() : '') + ';' + (m.created ? m.created.getTime() : '') + ';' + (m.note ? encodeURIComponent(m.note) : '') + ';' + (m.settings ? encodeURIComponent(m.settings) : ''));\n\t\t\telse {\n\t\t\t\tt.onremove && t.onremove(m);\n\t\t\t\tt.items.delete(m.sessionid);\n\t\t\t}\n\t\t}\n\t\tFs.writeFile(PATH.databases(filename.format((t.name && t.name !== 'default' ? ('_' + t.name) : ''))), storage.join('\\n'), t.$savecallback);\n\t\ttimeoutsave = null;\n\t};\n}\n\nconst SessionProto = Session.prototype;\n\nSessionProto.listlive = function(callback) {\n\n\tvar self = this;\n\tvar arr = [];\n\n\tfor (var m of self.items.values()) {\n\t\tif (m && !m.released && m.data && m.expire >= NOW)\n\t\t\tarr.push(m);\n\t}\n\n\tcallback(null, arr);\n};\n\nSessionProto.list = function(id, callback) {\n\n\tvar self = this;\n\tvar arr = [];\n\n\tfor (var m of self.items.values()) {\n\t\tif (m && m.expire >= NOW) {\n\t\t\tif (m.id === id)\n\t\t\t\tarr.push(m);\n\t\t} else {\n\t\t\tself.onremove && self.onremove(m);\n\t\t\tself.items.delete(m.sessionid);\n\n\t\t\tif (F.isCluster && self.$sync)\n\t\t\t\tcluster_send({ method: 'remove', NAME: self.name, sessionid: m.sessionid });\n\n\t\t\tif (!F.id || F.id === '0')\n\t\t\t\tself.$save();\n\t\t}\n\t}\n\n\tcallback(null, arr);\n};\n\nSessionProto.has = function(sessionid, callback) {\n\tcallback(null, this.items.has(sessionid));\n};\n\nSessionProto.has2 = function(id, callback) {\n\tfor (var m of this.items.values()) {\n\t\tif (m && m.expire >= NOW && m.id === id) {\n\t\t\tcallback(null, true);\n\t\t\treturn;\n\t\t}\n\t}\n\tcallback(null, false);\n};\n\nSessionProto.contains = function(sessionid, callback) {\n\tvar self = this;\n\tvar item = self.items.get(sessionid);\n\tif (item && item.expire >= NOW && item.data && !item.released)\n\t\tcallback(null, item.data, item);\n\telse\n\t\tcallback();\n};\n\nSessionProto.contains2 = function(id, callback) {\n\tfor (var m of this.items.values()) {\n\t\tif (m && m.expire >= NOW && m.id === id && m.data && !m.released) {\n\t\t\tcallback(null, m.data, m);\n\t\t\treturn;\n\t\t}\n\t}\n\tcallback(null);\n};\n\nSessionProto.getcookie = function(req, opt, callback, param) {\n\n\t// opt.name {String} A cookie name\n\t// opt.expire {String} Expiration\n\t// opt.key {String} Encrypt key\n\t// opt.extendcookie {Boolean} Extends cookie expiration (default: true)\n\t// opt.removecookie {Boolean} Removes cookie if isn't valid (default: true)\n\t// opt.options {Object} A cookie options (default: undefined)\n\t// opt.ddos {Number} Enable DDOS attempts\n\n\tif (req.req)\n\t\treq = req.req;\n\n\tvar self = this;\n\n\t// DDOS Protection\n\tif (opt.ddos && self.ddos[req.ip] > opt.ddos) {\n\t\tcallback(null, null, null, null, param);\n\t\treturn;\n\t}\n\n\tvar token = req.cookie(opt.name);\n\tif (!token || token.length < 20) {\n\n\t\t// remove cookies\n\t\tif (token && opt.removecookie !== false)\n\t\t\treq.res.cookie(opt.name, '', '-1 day');\n\n\t\tcallback(null, null, null, null, param);\n\t\treturn;\n\t}\n\n\t// IMPORTANT: \"req.res\" can be null cause of WebSocket\n\tvar value = DECRYPTREQ(req, token, opt.key);\n\tif (value && typeof(value) === 'string') {\n\t\tvalue = value.split(';');\n\t\tif (req.res && opt.expire && opt.extendcookie !== false)\n\t\t\treq.res.cookie(opt.name, token, opt.expire, opt.options || COOKIEOPTIONS);\n\t\tself.get(value[0], opt.expire, function(err, data, meta, init) {\n\t\t\tif ((err || !data)) {\n\n\t\t\t\tif (opt.ddos) {\n\t\t\t\t\tif (self.ddos[req.ip])\n\t\t\t\t\t\tself.ddos[req.ip]++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tself.ddos[req.ip] = 1;\n\t\t\t\t\t\tself.ddosis = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (req.res && opt.removecookie !== false)\n\t\t\t\t\treq.res.cookie(opt.name, '', '-1 day');\n\n\t\t\t} else\n\t\t\t\treq.sessionid = meta.sessionid;\n\t\t\tcallback(err, data, meta, init, param);\n\t\t});\n\t} else {\n\t\t// remove cookies\n\t\tif (req.res && opt.removecookie !== false)\n\t\t\treq.res.cookie(opt.name, '', '-1 day');\n\n\t\tif (opt.ddos) {\n\t\t\tif (self.ddos[req.ip])\n\t\t\t\tself.ddos[req.ip]++;\n\t\t\telse {\n\t\t\t\tself.ddos[req.ip] = 1;\n\t\t\t\tself.ddosis = true;\n\t\t\t}\n\t\t}\n\n\t\tcallback(null, null, null, null, param);\n\t}\n};\n\nSessionProto.gettoken = function(req, opt, callback, param) {\n\n\t// opt.token {String} a token\n\t// opt.expire {String} Expiration\n\t// opt.key {String} Encrypt key\n\t// opt.ddos {Number} Enable DDOS attempts\n\n\tvar self = this;\n\n\tif (req.req)\n\t\treq = req.req;\n\n\t// DDOS Protection\n\tif (opt.ddos && self.ddos[req.ip] > opt.ddos) {\n\t\tcallback(null, null, null, null, param);\n\t\treturn;\n\t}\n\n\tvar token = opt.token;\n\tif (!token || token.length < 20) {\n\t\tcallback(null, null, null, null, param);\n\t\treturn;\n\t}\n\n\t// IMPORTANT: \"req.res\" can be null cause of WebSocket\n\tvar value = DECRYPTREQ(req, token, opt.key);\n\tif (value && typeof(value) === 'string') {\n\t\tvalue = value.split(';');\n\t\tself.get(value[0], opt.expire, function(err, data, meta, init) {\n\t\t\tif (!err && data)\n\t\t\t\treq.sessionid = meta.sessionid;\n\t\t\telse if (opt.ddos) {\n\t\t\t\tif (self.ddos[req.ip])\n\t\t\t\t\tself.ddos[req.ip]++;\n\t\t\t\telse {\n\t\t\t\t\tself.ddos[req.ip] = 1;\n\t\t\t\t\tself.ddosis = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback(err, data, meta, init, param);\n\t\t});\n\t} else {\n\t\tif (opt.ddos) {\n\t\t\tif (self.ddos[req.ip])\n\t\t\t\tself.ddos[req.ip]++;\n\t\t\telse {\n\t\t\t\tself.ddos[req.ip] = 1;\n\t\t\t\tself.ddosis = true;\n\t\t\t}\n\t\t}\n\t\tcallback(null, null, null, null, param);\n\t}\n};\n\nSessionProto.usage = function() {\n\tvar o = {};\n\to.used = 0;\n\to.free = 0;\n\tfor (var m of this.items.values()) {\n\t\tif (m.data)\n\t\t\to.used++;\n\t\telse\n\t\t\to.free++;\n\t}\n\to.count = o.used + o.free;\n\treturn o;\n};\n\nSessionProto.release = function(sessionid, expire, callback) {\n\n\tif (sessionid && sessionid.sessionid)\n\t\tsessionid = sessionid.sessionid;\n\n\tif (typeof(expire) === 'function') {\n\t\tcallback = expire;\n\t\texpire = null;\n\t}\n\n\tvar self = this;\n\n\t// We can't release data when the session doesn't have \".ondata\" delegate implemented\n\tif (!self.ondata)\n\t\treturn;\n\n\tif (F.isCluster && F.id !== '0' && self.$sync)\n\t\tcluster_send({ NAME: self.name, type: 'release', sessionid: sessionid, expire: expire });\n\n\t// refreshes all\n\tif (sessionid == null) {\n\t\tvar count = 0;\n\t\tfor (var m of self.items.values()) {\n\t\t\tif (m.data) {\n\t\t\t\tm.released = true;\n\t\t\t\tself.onrelease && self.onrelease(m);\n\t\t\t\tm.data = null;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcallback && callback(null, count);\n\t\treturn;\n\t}\n\n\tvar item = self.items.get(sessionid);\n\tif (item) {\n\t\titem.released = true;\n\t\tself.onrelease && self.onrelease(item);\n\t\titem.data = null;\n\t}\n\n\tif (callback) {\n\t\t// @TODO: WTF? Why is \"get\" used when the item is released???\n\t\t// if (item)\n\t\t// \tself.get(sessionid, expire, callback);\n\t\t// else\n\t\tcallback(null, item ? 1 : 0);\n\t}\n};\n\nSessionProto.release2 = function(id, expire, callback) {\n\n\tif (typeof(expire) === 'function') {\n\t\tcallback = expire;\n\t\texpire = null;\n\t}\n\n\tvar self = this;\n\n\t// We can't release data when the session doesn't have \".ondata\" delegate implemented\n\tif (!self.ondata)\n\t\treturn;\n\n\tvar count = 0;\n\tvar exiration = expire ? NOW.add(expire) : null;\n\n\tfor (var m of self.items.values()) {\n\t\tif (m && m.id === id && m.data) {\n\t\t\tm.released = true;\n\t\t\tself.onrelease && self.onrelease(m);\n\t\t\tm.data = null;\n\t\t\tcount++;\n\t\t\tif (exiration)\n\t\t\t\tm.expire = exiration;\n\t\t}\n\t}\n\n\tif (F.isCluster && F.id !== '0' && self.$sync)\n\t\tcluster_send({ NAME: self.name, type: 'release2', id: id, expire: expire });\n\n\tcallback && callback(null, count);\n};\n\nSessionProto.releaseunused = function(lastusage, callback) {\n\n\tvar self = this;\n\tvar count = 0;\n\n\tvar lu = NOW.add(lastusage[0] === '-' ? lastusage : ('-' + lastusage));\n\tfor (var m of self.items.values()) {\n\t\tif (m.data && (!m.used || m.used <= lu)) {\n\t\t\tm.released = true;\n\t\t\tself.onrelease && self.onrelease(m);\n\t\t\tm.data = null;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (F.isCluster && F.id !== '0')\n\t\tself.$sync && cluster_send({ NAME: self.name, type: 'releaseunused', lastusage: lastusage });\n\n\tcallback && callback(null, count);\n};\n\nSessionProto.setcookie = function(res, opt, callback) {\n\n\t// opt.name {String} A cookie name\n\t// opt.sessionid {String} A unique session ID\n\t// opt.id {String} Optional, custom ID\n\t// opt.expire {String} Expiration\n\t// opt.strict {Boolean} Strict comparing of cookie according to IP (default: false)\n\t// opt.key {String} Encrypt key\n\t// opt.data {Object} A session data\n\t// opt.note {String} A simple note for this session\n\t// opt.settings {String} Settings data for the session\n\t// opt.options {Object} A cookie options (default: undefined)\n\n\tif (res.res)\n\t\tres = res.res;\n\n\tif (!opt.sessionid)\n\t\topt.sessionid = UID();\n\n\tthis.set(opt.sessionid, opt.id, opt.data, opt.expire, opt.note, opt.settings, function(err, item, meta) {\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t} else {\n\t\t\tvar data = opt.sessionid + ';' + (opt.id || '');\n\t\t\tvar token = ENCRYPTREQ(res.req, data, opt.key, opt.strict);\n\t\t\tres.cookie(opt.name, token, opt.expire, opt.options || COOKIEOPTIONS);\n\t\t\tres.req.sessionid = opt.sessionid;\n\t\t\tcallback && callback(null, item, meta);\n\t\t}\n\t});\n};\n\nSessionProto.settoken = function(res, opt, callback) {\n\n\t// opt.name {String} A cookie name\n\t// opt.sessionid {String} A unique session ID\n\t// opt.id {String} Optional, custom ID\n\t// opt.expire {String} Expiration\n\t// opt.strict {Boolean} Strict comparing of cookie according to IP (default: false)\n\t// opt.key {String} Encrypt key\n\t// opt.data {Object} A session data\n\t// opt.note {String} A simple note for this session\n\t// opt.settings {String} Settings data for the session\n\n\tif (res.res)\n\t\tres = res.res;\n\n\tif (!opt.sessionid)\n\t\topt.sessionid = UID();\n\n\tthis.set(opt.sessionid, opt.id, opt.data, opt.expire, opt.note, opt.settings, function(err, item, meta) {\n\t\tif (err) {\n\t\t\tcallback && callback(err);\n\t\t} else {\n\t\t\tvar data = opt.sessionid + ';' + (opt.id || '');\n\t\t\tvar token = ENCRYPTREQ(res.req, data, opt.key, opt.strict);\n\t\t\tres.req.sessionid = opt.sessionid;\n\t\t\tcallback && callback(null, token, item, meta);\n\t\t}\n\t});\n};\n\nSessionProto.set2 = function(id, data, expire, note, settings, callback) {\n\n\tif (typeof(expire) === 'function') {\n\t\tcallback = expire;\n\t\texpire = '';\n\t} else if (typeof(note) === 'function') {\n\t\tcallback = note;\n\t\tnote = null;\n\t} else if (typeof(settings) === 'function') {\n\t\tcallback = settings;\n\t\tsettings = null;\n\t}\n\n\tvar self = this;\n\tvar updated = 0;\n\n\tfor (var m of self.items.values()) {\n\t\tif (m && m.id === id && m.data) {\n\t\t\tm.data = data;\n\t\t\tif (expire)\n\t\t\t\tm.expire = NOW.add(expire);\n\t\t\tif (note != null)\n\t\t\t\tm.note = note;\n\t\t\tif (settings != null)\n\t\t\t\tm.settings = settings;\n\t\t\tupdated++;\n\t\t}\n\t}\n\n\tcallback && callback(null, updated);\n\n\tif (F.isCluster && self.$sync)\n\t\tcluster_send({ method: 'set2', NAME: self.name, id: id, data: data, expire: expire, note: note, settings: settings });\n\n\tif (updated && (!F.id || F.id === '0'))\n\t\tself.$save();\n};\n\nSessionProto.set = function(sessionid, id, data, expire, note, settings, callback) {\n\n\tif (typeof(id) === 'object') {\n\t\tcallback = settings;\n\t\tsettings = note;\n\t\tnote = expire;\n\t\texpire = data;\n\t\tdata = id;\n\t\tid = '';\n\t}\n\n\tif (typeof(note) === 'function') {\n\t\tcallback = note;\n\t\tnote = null;\n\t} else if (typeof(settings) === 'function') {\n\t\tcallback = settings;\n\t\tsettings = null;\n\t}\n\n\tvar self = this;\n\tvar obj = {};\n\tobj.sessionid = sessionid;\n\tobj.id = id == null ? '' : (id + '');\n\tobj.expire = NOW.add(expire);\n\tobj.data = data;\n\tobj.note = note || '';\n\tobj.created = NOW;\n\tobj.settings = settings || '';\n\tself.items.set(sessionid, obj);\n\n\tif (F.isCluster && self.$sync)\n\t\tcluster_send({ method: 'set', NAME: self.name, sessionid: sessionid, id: obj.id, data: data, expire: expire, note: note, settings: settings });\n\n\tif (!F.id || F.id === '0')\n\t\tself.$save();\n\n\tcallback && callback(null, data, obj);\n};\n\nSessionProto.get2 = function(id, callback) {\n\tvar self = this;\n\tvar output = [];\n\tfor (var m of self.items.values()) {\n\t\tif (m && m.id === id && m.expire >= NOW) {\n\t\t\tm.used = NOW;\n\t\t\toutput.push(m);\n\t\t}\n\t}\n\tcallback && callback(null, output);\n};\n\nSessionProto.get = function(sessionid, expire, callback) {\n\n\tif (typeof(expire) === 'function') {\n\t\tcallback = expire;\n\t\texpire = null;\n\t}\n\n\tvar self = this;\n\tvar item = self.items.get(sessionid);\n\tif (item) {\n\t\tif (item.expire < NOW) {\n\t\t\tself.onremove && self.onremove(item);\n\t\t\tself.items.delete(sessionid);\n\t\t\titem = null;\n\n\t\t\tif (F.isCluster && self.$sync)\n\t\t\t\tcluster_send({ method: 'remove', NAME: self.name, sessionid: sessionid });\n\n\t\t\tif (!F.id || F.id === '0')\n\t\t\t\tself.$save();\n\n\t\t} else if (expire)\n\t\t\titem.expire = NOW.add(expire);\n\t}\n\n\t// we need to load data\n\tif (item) {\n\t\tif (item.data == null && self.ondata) {\n\n\t\t\tif (self.pending[item.id]) {\n\t\t\t\tself.pending[item.id].push(callback);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tself.pending[item.id] = [];\n\t\t\tself.ondata(item, function(err, data) {\n\n\t\t\t\tif (item.released)\n\t\t\t\t\titem.released = false;\n\n\t\t\t\titem.data = data;\n\t\t\t\tcallback(err, data, item, true);\n\t\t\t\titem.used = NOW;\n\t\t\t\tvar pending = self.pending[item.id];\n\t\t\t\tfor (var i = 0; i < pending.length; i++)\n\t\t\t\t\tpending[i](err, data, item);\n\t\t\t\tdelete self.pending[item.id];\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcallback(null, item ? item.data : null, item);\n\n\tif (item)\n\t\titem.used = NOW;\n};\n\nSessionProto.update2 = function(id, data, expire, note, settings, callback) {\n\n\tif (typeof(expire) === 'function') {\n\t\tcallback = expire;\n\t\texpire = null;\n\t} else if (typeof(note) === 'function') {\n\t\tcallback = note;\n\t\tnote = null;\n\t} else if (typeof(settings) === 'function') {\n\t\tcallback = settings;\n\t\tsettings = null;\n\t}\n\n\tvar self = this;\n\tvar updated = 0;\n\n\tif (expire)\n\t\texpire = NOW.add(expire);\n\n\tfor (var m of self.items.values()) {\n\t\tif (m && m.id === id) {\n\t\t\tif (m.data)\n\t\t\t\tm.data = data;\n\t\t\tif (note != null)\n\t\t\t\tm.note = note;\n\t\t\tif (settings != null)\n\t\t\t\tm.settings = settings;\n\t\t\tif (expire)\n\t\t\t\tm.expire = expire;\n\t\t\tif (m.data || expire)\n\t\t\t\tupdated++;\n\t\t}\n\t}\n\n\tif (F.isCluster && self.$sync)\n\t\tcluster_send({ method: 'update2', NAME: self.name, id: id, data: data, expire: expire, note: note, settings: settings });\n\n\tif (updated && (!F.id || F.id === '0'))\n\t\tself.$save();\n\n\tcallback && callback(null, updated);\n};\n\nSessionProto.update = function(sessionid, data, expire, note, settings, callback) {\n\n\tif (typeof(expire) === 'function') {\n\t\tcallback = expire;\n\t\texpire = null;\n\t} else if (typeof(note) === 'function') {\n\t\tcallback = note;\n\t\tnote = null;\n\t} else if (typeof(settings) === 'function') {\n\t\tcallback = settings;\n\t\tsettings = null;\n\t}\n\n\tvar self = this;\n\tvar item = self.items.get(sessionid);\n\tif (item) {\n\n\t\tif (item.data)\n\t\t\titem.data = data;\n\n\t\tif (note != null)\n\t\t\titem.note = note;\n\n\t\tif (settings != null)\n\t\t\titem.settings = settings;\n\n\t\tif (expire)\n\t\t\titem.expire = NOW.add(expire);\n\n\t\tif (F.isCluster && self.$sync)\n\t\t\tcluster_send({ method: 'update', NAME: self.name, sessionid: sessionid, data: data, expire: expire, note: note, settings: settings });\n\n\t\tif ((item.data || expire) && (!F.id || F.id === '0'))\n\t\t\tself.$save();\n\n\t\tif (callback) {\n\t\t\tif (item.data)\n\t\t\t\tcallback(null, data, item);\n\t\t\telse\n\t\t\t\tcallback();\n\t\t}\n\n\t} else if (callback)\n\t\tcallback();\n};\n\nSessionProto.count = function(id, callback) {\n\n\tif (!callback) {\n\t\tcallback = id;\n\t\tid = null;\n\t}\n\n\tvar o = {};\n\to.used = 0;\n\to.free = 0;\n\n\tfor (var m of this.items.values()) {\n\t\tif (id && m.id !== id)\n\t\t\tcontinue;\n\t\tif (m.data)\n\t\t\to.used++;\n\t\telse\n\t\t\to.free++;\n\t}\n\n\to.count = o.used + o.free;\n\tcallback(null, o);\n};\n\nSessionProto.remove2 = function(id, callback) {\n\tvar self = this;\n\tvar count = 0;\n\n\tfor (var m of self.items.values()) {\n\t\tif (m && m.id === id) {\n\t\t\tself.onremove && self.onremove(m);\n\t\t\tself.items.delete(m.sessionid);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (F.isCluster && self.$sync)\n\t\tcluster_send({ method: 'remove2', NAME: self.name, id: id });\n\n\tif (!F.id || F.id === '0')\n\t\tself.$save();\n\n\tcallback && callback(null, count);\n};\n\nSessionProto.remove = function(sessionid, callback) {\n\n\tif (sessionid && sessionid.sessionid)\n\t\tsessionid = sessionid.sessionid;\n\n\tvar self = this;\n\tvar item = self.items.get(sessionid);\n\n\tif (item) {\n\t\tself.items.delete(sessionid);\n\n\t\tif (F.isCluster && self.$sync)\n\t\t\tcluster_send({ method: 'remove', NAME: self.name, sessionid: sessionid });\n\n\t\tif (!F.id || F.id === '0')\n\t\t\tself.$save();\n\t}\n\n\tcallback && callback(null, item);\n\tself.onremove && self.onremove(item);\n};\n\nSessionProto.clear = function(lastusage, callback) {\n\n\tif (typeof(lastusage) === 'function') {\n\t\tcallback = lastusage;\n\t\tlastusage = null;\n\t}\n\n\tvar self = this;\n\tvar count = 0;\n\n\tif (lastusage) {\n\t\tvar lu = NOW.add(lastusage[0] === '-' ? lastusage : ('-' + lastusage));\n\t\tfor (var m of self.items.values()) {\n\t\t\tif (!m.used || m.used <= lu) {\n\t\t\t\tself.onremove && self.onremove(m);\n\t\t\t\tself.items.delete(m.sessionid);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcount = self.items.length;\n\t\tif (self.onremove) {\n\t\t\tfor (var m of self.items.values())\n\t\t\t\tself.onremove(m);\n\t\t}\n\t\tself.items.clear();\n\t}\n\n\tif (F.isCluster && self.$sync)\n\t\tcluster_send({ method: 'clear', NAME: self.name, lastusage: lastusage });\n\n\tif (!F.id || F.id === '0')\n\t\tself.$save();\n\n\tcallback && callback(null, count);\n};\n\nSessionProto.clean = function() {\n\tvar self = this;\n\tvar is = false;\n\tfor (var m of self.items.values()) {\n\t\tif (m.expire < NOW) {\n\t\t\tself.onremove && self.onremove(m);\n\t\t\tself.items.delete(m.sessionid);\n\t\t\tis = true;\n\t\t}\n\t}\n\n\tif (is) {\n\t\tif (F.isCluster && self.$sync)\n\t\t\tcluster_send({ method: 'clean', NAME: self.name });\n\n\t\tif (!F.id || F.id === '0')\n\t\t\tself.$save();\n\t}\n};\n\nSessionProto.load = function(callback) {\n\n\tvar self = this;\n\tvar removed = 0;\n\tvar data = [];\n\n\ttry {\n\t\tdata = Fs.readFileSync(PATH.databases(filename.format((self.name && self.name !== 'default' ? ('_' + self.name) : '')))).toString('utf8').split('\\n');\n\t} catch (e) {}\n\n\tfor (var i = 0; i < data.length; i++) {\n\t\tvar item = data[i].split(';');\n\t\tvar obj = {};\n\t\tobj.sessionid = decodeURIComponent(item[0]);\n\t\tobj.id = item[1] ? decodeURIComponent(item[1]) : '';\n\t\tobj.expire = new Date(+item[2]);\n\t\tobj.used = item[3] ? new Date(+item[3]) : null;\n\t\tobj.created = item[4] ? new Date(+item[4]) : null;\n\t\tobj.note = item[5] ? decodeURIComponent(item[5]) : '';\n\t\tobj.settings = item[6] ? decodeURIComponent(item[6]) : '';\n\t\tobj.data = null;\n\t\tif (obj.expire > NOW)\n\t\t\tself.items.set(obj.sessionid, obj);\n\t\telse\n\t\t\tremoved++;\n\t}\n\n\tif (removed && (!F.id || F.id === '0'))\n\t\tself.$save();\n\n\tcallback && callback();\n};\n\nfunction cluster_send(obj) {\n\tobj.TYPE = 'session';\n\tobj.ID = F.id;\n\tprocess.send(obj);\n}\n\nexports.Session = Session;"
        },
        {
          "name": "tangular.js",
          "type": "blob",
          "size": 9.6982421875,
          "content": "(function(W) {\n\n\tif (W.Tangular)\n\t\treturn;\n\n\tvar Tangular = {};\n\tvar Thelpers = Tangular.helpers = {};\n\tTangular.version = 'v4.0.0';\n\tTangular.cache = {};\n\tTangular.debug = false;\n\n\tW.Tangular = Tangular;\n\tW.Thelpers = Thelpers;\n\n\tvar SKIP = { 'null': true, 'undefined': true, 'true': true, 'false': true, 'Object': 1, 'String': 1, 'Number': 1, 'Boolean': 1, 'Date': 1, 'Array': 1, 'window': 1, 'global': 1, 'arguments': 1, 'eval': 1, 'Function': 1, 'function': 1, 'var': 1, 'let': 1, 'const': 1, 'delete': 1 };\n\tvar REG_CMDFIND = /\\{\\{.*?\\}\\}/g;\n\tvar REG_CMDCLEAN = /\\{\\{|\\}\\}/g;\n\tvar REG_ENCODE = /[<>&\"]/g;\n\tvar REG_TRIM = /\\n$/g;\n\n\tfunction parseInlineVariables(line, blacklist) {\n\n\t\tvar tmp = '';\n\t\tvar variables = [];\n\t\tvar skip = 0;\n\n\t\tfor (var i = 0; i < line.length; i++) {\n\t\t\tvar c = line.charCodeAt(i);\n\n\t\t\tif (!skip) {\n\n\t\t\t\tif ((tmp && c > 47 && c < 58) || (c > 64 && c < 91) || (c > 96 && c < 123) || (c === 95 || c === 36)) {\n\t\t\t\t\ttmp += line.charAt(i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (tmp) {\n\t\t\t\t\tif (!SKIP[tmp] && variables.indexOf(tmp) === -1 && (!blacklist || blacklist.indexOf(tmp) === -1))\n\t\t\t\t\t\tvariables.push(tmp);\n\t\t\t\t\ttmp = '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (c === 46 || c === 124) { // \".\" or \"|\"\n\t\t\t\tskip = c;\n\t\t\t} else if ((skip === 46 || skip === 124) && c === 40) { // (\".\" or \"|\") and \"(\"\n\t\t\t\tskip = 0;\n\t\t\t} else if (c === 96 || c === 34 || c === 39) { // \"`\" or \"'\" or \"\\\"\"\n\t\t\t\tif (c === skip)\n\t\t\t\t\tskip = 0;\n\t\t\t\telse\n\t\t\t\t\tskip = c;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp && !SKIP[tmp] && variables.indexOf(tmp) === -1 && (!blacklist || blacklist.indexOf(tmp) === -1))\n\t\t\tvariables.push(tmp);\n\n\t\treturn variables;\n\t}\n\n\tTangular.toArray = function(obj) {\n\t\tvar keys = Object.keys(obj);\n\t\tvar arr = [];\n\t\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\t\tarr.push({ key: keys[i], value: obj[keys[i]] });\n\t\treturn arr;\n\t};\n\n\tfunction Template() {\n\t\tthis.commands;\n\t\tthis.variables;\n\t\tthis.builder;\n\t\tthis.split = '\\0';\n\t}\n\n\tTemplate.prototype.compile = function(template) {\n\n\t\tvar self = this;\n\t\tvar ifcount = 0;\n\t\tvar loopcount = 0;\n\t\tvar tmp;\n\t\tvar loops = [];\n\n\t\tself.variables = {};\n\t\tself.commands = [];\n\n\t\tself.builder = template.replace(REG_CMDFIND, function(text) {\n\n\t\t\tvar cmd = text.replace(REG_CMDCLEAN, '').trim();\n\t\t\tvar variable = null;\n\t\t\tvar helpers = null;\n\t\t\tvar index;\n\t\t\tvar isif = false;\n\t\t\tvar isloop = false;\n\t\t\tvar iscode = true;\n\n\t\t\tif (cmd === 'fi') {\n\t\t\t\tifcount--;\n\t\t\t\t// end of condition\n\t\t\t} else if (cmd === 'end') {\n\t\t\t\tloopcount--;\n\t\t\t\t// end of loop\n\t\t\t\tloops.pop();\n\t\t\t} else if (cmd.substring(0, 3) === 'if ') {\n\t\t\t\t// condition\n\t\t\t\tifcount++;\n\t\t\t\tvariable = parseInlineVariables(cmd.substring(3), loops);\n\t\t\t\tif (variable.length) {\n\t\t\t\t\tfor (var i = 0; i < variable.length; i++) {\n\t\t\t\t\t\tvar name = variable[i];\n\t\t\t\t\t\tif (self.variables[name])\n\t\t\t\t\t\t\tself.variables[name]++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tself.variables[name] = 1;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tvariable = null;\n\t\t\t\tisif = true;\n\t\t\t\tiscode = true;\n\t\t\t} else if (cmd.substring(0, 8) === 'foreach ') {\n\n\t\t\t\tloopcount++;\n\t\t\t\t// loop\n\n\t\t\t\ttmp = cmd.substring(8).split(' ');\n\t\t\t\tloops.push(tmp[0].trim());\n\n\t\t\t\tindex = tmp[2].indexOf('.');\n\t\t\t\tif (index !== -1)\n\t\t\t\t\ttmp[2] = tmp[2].substring(0, index);\n\n\t\t\t\tvariable = tmp[2].trim();\n\n\t\t\t\tif (loops.indexOf(variable) === -1) {\n\t\t\t\t\tif (self.variables[variable])\n\t\t\t\t\t\tself.variables[variable]++;\n\t\t\t\t\telse\n\t\t\t\t\t\tself.variables[variable] = 1;\n\t\t\t\t\tvariable = [variable];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tvariable = null;\n\n\t\t\t\tisloop = true;\n\t\t\t} else if (cmd.substring(0, 8) === 'else if ') {\n\t\t\t\t// else if\n\t\t\t\tvariable = parseInlineVariables(cmd.substring(8), loops);\n\t\t\t\tif (variable.length) {\n\t\t\t\t\tfor (var i = 0; i < variable.length; i++) {\n\t\t\t\t\t\tvar name = variable[i];\n\t\t\t\t\t\tif (self.variables[name])\n\t\t\t\t\t\t\tself.variables[name]++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tself.variables[name] = 1;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tvariable = null;\n\t\t\t\tisif = true;\n\t\t\t} else if (cmd !== 'continue' && cmd !== 'break' && cmd !== 'else') {\n\n\t\t\t\tvariable = parseInlineVariables(cmd);\n\t\t\t\tfor (var i = 0; i < variable.length; i++) {\n\t\t\t\t\tvar v = variable[i];\n\t\t\t\t\tif (self.variables[v])\n\t\t\t\t\t\tself.variables[v]++;\n\t\t\t\t\telse\n\t\t\t\t\t\tself.variables[v] = 1;\n\t\t\t\t}\n\n\t\t\t\tif (!variable.length)\n\t\t\t\t\tvariable = null;\n\n\t\t\t\tif (cmd.indexOf('|') === -1)\n\t\t\t\t\tcmd += ' | encode';\n\n\t\t\t\thelpers = cmd.split('|');\n\t\t\t\tcmd = helpers[0];\n\t\t\t\thelpers = helpers.slice(1);\n\t\t\t\tif (helpers.length) {\n\t\t\t\t\tfor (var i = 0; i < helpers.length; i++) {\n\t\t\t\t\t\tvar helper = helpers[i].trim();\n\t\t\t\t\t\tindex = helper.indexOf('(');\n\t\t\t\t\t\tif (index === -1) {\n\t\t\t\t\t\t\thelper = 'Thelpers.$execute(model,\\'' + helper + '\\',\\7)';\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\thelper = 'Thelpers.$execute(model,\\'' + helper.substring(0, index) + '\\',\\7,' + helper.substring(index + 1);\n\t\t\t\t\t\thelpers[i] = helper;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\thelpers = null;\n\n\t\t\t\tcmd = self.safe(cmd.trim() || 'model');\n\t\t\t\tiscode = false;\n\t\t\t}\n\n\t\t\tself.commands.push({ index: self.commands.length, cmd: cmd, ifcount: ifcount, loopcount: loopcount, variable: variable, helpers: helpers, isloop: isloop, isif: isif, iscode: iscode });\n\t\t\treturn self.split;\n\n\t\t}).split(self.split);\n\n\t\tfor (var i = 0; i < self.builder.length; i++) {\n\t\t\tvar m = self.builder[i];\n\t\t\tself.builder[i] = m ? m.replace(REG_TRIM, '') : m;\n\t\t}\n\n\t\treturn self.make();\n\t};\n\n\tTemplate.prototype.safe = function(cmd) {\n\n\t\tvar arr = cmd.split('.');\n\t\tvar output = [];\n\n\t\tfor (var i = 1; i < arr.length; i++) {\n\t\t\tvar k = arr.slice(0, i).join('.');\n\t\t\toutput.push(k + '==null?\\'\\':');\n\t\t}\n\t\treturn output.join('') + arr.join('.');\n\t};\n\n\tTemplate.prototype.make = function() {\n\n\t\tvar self = this;\n\t\tvar builder = ['var $output=$text[0];var $tmp;var $index=0;'];\n\n\t\tfor (var i = 0, length = self.commands.length; i < length; i++) {\n\n\t\t\tvar cmd = self.commands[i];\n\t\t\tvar tmp;\n\n\t\t\ti && builder.push('$output+=$text[' + i + '];');\n\n\t\t\tif (cmd.iscode) {\n\n\t\t\t\tif (cmd.isloop) {\n\n\t\t\t\t\tvar name = '$i' + Math.random().toString(16).substring(3, 6);\n\t\t\t\t\tvar namea = name + 'a';\n\t\t\t\t\ttmp = cmd.cmd.substring(cmd.cmd.lastIndexOf(' in ') + 4).trim();\n\t\t\t\t\ttmp = namea + '=' + self.safe(tmp) + ';if(!(' + namea + ' instanceof Array)){if(' + namea + '&&typeof(' + namea + ')===\\'object\\')' + namea + '=Tangular.toArray(' + namea + ')}if(' + namea + ' instanceof Array&&' + namea + '.length){for(var ' + name + '=0,' + name + 'l=' + namea + '.length;' + name + '<' + name + 'l;' + name + '++){$index=' + name + ';var ' + cmd.cmd.split(' ')[1] + '=' + namea + '[' + name + '];';\n\t\t\t\t\tbuilder.push(tmp);\n\n\t\t\t\t} else if (cmd.isif) {\n\t\t\t\t\tif (cmd.cmd.substring(0, 8) === 'else if ')\n\t\t\t\t\t\tbuilder.push('}' + cmd.cmd.substring(0, 8).trim() + '(' + cmd.cmd.substring(8).trim() + '){');\n\t\t\t\t\telse\n\t\t\t\t\t\tbuilder.push(cmd.cmd.substring(0, 3).trim() + '(' + cmd.cmd.substring(3).trim() + '){');\n\t\t\t\t} else {\n\t\t\t\t\tswitch (cmd.cmd) {\n\t\t\t\t\t\tcase 'else':\n\t\t\t\t\t\t\tbuilder.push('}else{');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'end':\n\t\t\t\t\t\t\tbuilder.push('}}');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'fi':\n\t\t\t\t\t\t\tbuilder.push('}');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'break':\n\t\t\t\t\t\t\tbuilder.push('break;');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'continue':\n\t\t\t\t\t\t\tbuilder.push('continue;');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (cmd.helpers) {\n\t\t\t\t\tvar str = '';\n\t\t\t\t\tfor (var j = 0; j < cmd.helpers.length; j++) {\n\t\t\t\t\t\tvar helper = cmd.helpers[j];\n\t\t\t\t\t\tif (j === 0)\n\t\t\t\t\t\t\tstr = helper.replace('\\7', cmd.cmd.trim()).trim();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstr = helper.replace('\\7', str.trim());\n\t\t\t\t\t}\n\t\t\t\t\tbuilder.push('$tmp=' + str + ';if($tmp!=null)$output+=$tmp;');\n\t\t\t\t} else\n\t\t\t\t\tbuilder.push('if(' + cmd.cmd + '!=null)$output+=' + cmd.cmd + ';');\n\t\t\t}\n\t\t}\n\n\t\tbuilder.push((length ? ('$output+=$text[' + length + '];') : '') + 'return $output.charAt(0) === \\'\\\\n\\'?$output.substring(1):$output;');\n\t\tdelete self.variables.$;\n\t\tvar variables = Object.keys(self.variables);\n\t\tvar names = ['$ || {}', 'model'];\n\n\t\tfor (var i = 0; i < variables.length; i++)\n\t\t\tnames.push('model.' + variables[i]);\n\n\t\tvar code = 'var tangular=function($,model' + (variables.length ? (',' + variables.join(',')) : '') + '){' + builder.join('') + '};return function(model,$){return tangular(' + names.join(',') + ');}';\n\t\treturn (new Function('$text', code))(self.builder);\n\t};\n\n\tThelpers.$execute = function(model, name, a, b, c, d, e, f, g, h) {\n\n\t\tif (Thelpers[name] == null) {\n\t\t\tconsole && console.warn('Tangular: missing helper', '\"' + name + '\"');\n\t\t\treturn a;\n\t\t}\n\n\t\treturn Thelpers[name].call(model, a, b, c, d, e, f, g, h);\n\t};\n\n\tThelpers.encode = function(value) {\n\t\treturn value == null ? '' : (value + '').replace(REG_ENCODE, function(c) {\n\t\t\tswitch (c) {\n\t\t\t\tcase '&': return '&amp;';\n\t\t\t\tcase '<': return '&lt;';\n\t\t\t\tcase '>': return '&gt;';\n\t\t\t\tcase '\"': return '&quot;';\n\t\t\t}\n\t\t\treturn c;\n\t\t});\n\t};\n\n\tThelpers.raw = function(value) {\n\t\treturn value;\n\t};\n\n\tTangular.render = function(template, model, repository) {\n\t\treturn new Template().compile(template)(model == null ? {} : model, repository);\n\t};\n\n\tTangular.compile = function(template) {\n\t\treturn new Template().compile(template);\n\t};\n\n\tTangular.register = function(name, fn) {\n\t\tThelpers[name] = fn;\n\t\treturn Tangular;\n\t};\n\n\tThelpers.pluralize = function(r,e,t,a,n){ return r||(r=0),'number'!=typeof r&&(r=parseFloat(r.toString().replace(/\\s/g,'').replace(',','.'))),r.pluralize(e,t,a,n); };\n\tThelpers.format=function(r,e,t,a){var n=typeof r;if(r==0||r==null)return'';if('number'===n||r instanceof Date)return r.format(e==null?null:e,t,a);'string'!==n&&(r=r.toString()),r=r.trim();for(var i=!1,o=0,f=0,u=0,l=r.length;l>u;u++){var g=r.charCodeAt(u);if(58===g||32===g||84===g){i=!0;break;}if(45===g){if(o++,1===o)continue;i=!0;break;}if(46===g){if(f++,1===f)continue;i=!0;break;}}return i?r.parseDate().format(e||'dd.MM.yyyy'):r.parseFloat().format(e,t,a);};\n\tThelpers.def=function(e,n){return e?Thelpers.encode(e):n||'---';};\n\tThelpers.currency=function(e,t){switch(typeof e){case'number':return e.currency(t);case'string':return e.parseFloat().currency(t);default:return'';}};\n\n})(global);"
        },
        {
          "name": "test.js",
          "type": "blob",
          "size": 5.9931640625,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkTest\n * @version 3.4.0\n */\n\nvar T = F.tests = {};\nT.countok = 0;\nT.countno = 0;\nT.count = 0;\nT.tests = [];\nT.current = null;\nT.results = [];\nT.running = false;\nT.immediate = null;\nT.color = {\n\tgreen: '',\n\tred: '',\n\treset: ''\n};\n\nprocess.argv.forEach(function (val, index) {\n\tif (index > 1) {\n\t\tswitch(val) {\n\t\t\tcase '-c':\n\t\t\t\tT.color.green = '\\x1b[1m\\x1b[32m';\n\t\t\t\tT.color.red = '\\x1b[1m\\x1b[31m';\n\t\t\t\tT.color.reset = '\\x1b[0m';\n\t\t\t\tbreak;\n\t\t}\n\t}\n});\n\nfunction NEXT() {\n\n\tT.immediate && clearImmediate(T.immediate);\n\tT.immediate = null;\n\n\tvar fn = T.current ? T.current.items.shift() : null;\n\n\tif (fn != null) {\n\t\tfn();\n\t\treturn;\n\t}\n\n\tif (T.current) {\n\t\tT.results.push(T.current);\n\t\tconsole.log('');\n\t}\n\n\tvar test = F.tests.tests.shift();\n\tif (test == null) {\n\n\t\tconsole.log('===================== RESULTS ======================');\n\t\tconsole.log('');\n\t\tconsole.log('> Passed .........', T.countok + '/' + T.count);\n\t\tconsole.log('> Failed ' + (T.countno ? '[x] .....' : '.........'), T.countno + '/' + T.count);\n\t\tconsole.log('');\n\n\t\tF.isTest = false;\n\t\tF.emit('test-end', T);\n\n\t\t// DONE\n\t\tsetTimeout(function() {\n\t\t\tF.kill(T.countno ? 1 : 0);\n\t\t}, 1000);\n\n\t} else {\n\n\t\tT.current = test;\n\t\tT.current.results = [];\n\n\t\tconsole.log('[ TEST: ' + test.filename.substring(F.path.tests().length) + (T.current.priority ? ' ({0}) ]'.format(T.current.priority) : ' ]'));\n\t\tconsole.log('');\n\n\t\tNEXT();\n\t}\n}\n\nglobal.TEST = function(name, url, scope) {\n\n\tif (typeof(url) === 'function') {\n\n\t\tvar fn = function() {\n\t\t\tT.now = Date.now();\n\t\t\tT.currentname = name;\n\t\t\tT.current.count++;\n\t\t\turl(NEXT);\n\t\t};\n\n\t\tif (T.running)\n\t\t\tT.current.items.unshift(fn);\n\t\telse\n\t\t\tT.current.items.push(fn);\n\n\t\treturn;\n\t}\n\n\tvar subdomain;\n\tvar method;\n\tvar index = url.indexOf(' ');\n\n\tif (index !== -1) {\n\t\tmethod = url.substring(0, index);\n\t\turl = url.substring(index + 1).trim();\n\t}\n\n\turl = url.replace(/\\[.*?]/g, function(text) {\n\t\tsubdomain = text.replace(/\\[|\\]/g, '').trim();\n\t\treturn '';\n\t});\n\n\tif (!url.startsWith('http://', true) && !url.startsWith('https://', true))\n\t\turl = 'http://' + (subdomain ? (subdomain + '.') : '') + F.ip + ':' + F.port + (url[0] !== '/' ? '/' : '') + url;\n\n\tvar fn = function() {\n\t\tT.now = Date.now();\n\t\tT.currentname = name;\n\t\tT.current.count++;\n\t\tvar builder = new RESTBuilder(url);\n\t\tmethod && builder.method(method);\n\t\tbuilder.header('X-Assertion-Testing', '1');\n\t\tscope.call(builder, builder);\n\t};\n\n\tif (T.running)\n\t\tT.current.items.unshift(fn);\n\telse\n\t\tT.current.items.push(fn);\n};\n\nglobal.FAIL = function(is, description) {\n\tif (arguments.length) {\n\t\tlogger(is ? true : false, T.currentname, description);\n\t\tT.immediate && clearImmediate(T.immediate);\n\t\tT.immediate = setImmediate(NEXT);\n\t} else {\n\t\treturn function(err) {\n\t\t\tFAIL(err == null);\n\t\t};\n\t}\n};\n\nglobal.OK = function(is, description) {\n\tif (arguments.length) {\n\t\tlogger(is ? false : true, T.currentname, description);\n\t\tT.immediate && clearImmediate(T.immediate);\n\t\tT.immediate = setImmediate(NEXT);\n\t} else {\n\t\treturn function(err) {\n\t\t\tOK(err == null);\n\t\t};\n\t}\n};\n\nglobal.TESTUSER = function(user, flags) {\n\n\tif (!T.auth)\n\t\tT.auth = F.onAuthorize;\n\n\tT.user = user;\n\tT.flags = flags;\n\n\tif (user) {\n\t\tAUTH(function($) {\n\n\t\t\tif (T.flags && T.flags.length) {\n\t\t\t\tfor (var i = 0; i < T.flags.length; i++) {\n\t\t\t\t\tvar f = T.flags[i];\n\t\t\t\t\tif (f[0] !== '@')\n\t\t\t\t\t\tf = '@' + f;\n\t\t\t\t\t$.flags.push(f);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$.success(F.tests.user);\n\t\t});\n\t} else\n\t\tF.onAuthorize = T.auth;\n};\n\nexports.load = function() {\n\tvar dir = F.path.tests();\n\tU.ls(dir, function(files) {\n\t\tfiles.waitFor(function(filename, next) {\n\n\t\t\tif (F.testlist) {\n\t\t\t\tvar tn = filename.replace(dir, '').replace(/\\.js$/, '');\n\t\t\t\tif (F.testlist.indexOf(tn) === -1)\n\t\t\t\t\treturn next();\n\t\t\t}\n\n\t\t\tif (U.getExtension(filename) !== 'js')\n\t\t\t\treturn next();\n\n\t\t\tT.current = { filename: filename, items: [] };\n\t\t\tvar m = require(filename);\n\t\t\tT.current.module = m;\n\t\t\tT.current.countok = 0;\n\t\t\tT.current.countno = 0;\n\t\t\tT.current.count = 0;\n\t\t\tT.current.priority = m.priority || 0;\n\t\t\tT.current.items.length && T.tests.push(T.current);\n\t\t\tT.current = null;\n\t\t\tnext();\n\t\t}, function() {\n\t\t\tU.wait(function() {\n\t\t\t\treturn F._length_wait === 0;\n\t\t\t}, function() {\n\t\t\t\tT.tests.quicksort('priority');\n\t\t\t\tF.emit('test-begin', T);\n\t\t\t\tconsole.log('===================== TESTING ======================');\n\t\t\t\tconsole.log('');\n\t\t\t\tT.running = true;\n\t\t\t\tT.start = Date.now();\n\t\t\t\tNEXT();\n\t\t\t});\n\t\t});\n\t});\n};\n\nfunction logger(fail, name, description) {\n\tvar time = Math.floor(Date.now() - T.now) + ' ms';\n\tT.count++;\n\tif (fail) {\n\t\tT.countno++;\n\t\tT.current.countno++;\n\t\tconsole.error(T.color.red + 'Failed [x]' + T.color.reset + ' '.padRight(20, '.') + ' ' + name + (description ? (' <' + description + '>') : '') + ' [' + time + ']');\n\t} else {\n\t\tT.countok++;\n\t\tT.current.countok++;\n\t\tconsole.info(T.color.green + 'Passed' + T.color.reset + ' '.padRight(20, '.') + ' ' + name + (description ? (' <' + description + '>') : '') + ' [' + time + ']');\n\t}\n}"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.js",
          "type": "blob",
          "size": 161.1083984375,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module FrameworkUtils\n * @version 3.4.4\n */\n\n'use strict';\n\nconst Dns = require('dns');\nconst Url = require('url');\nconst Qs = require('querystring');\nconst Http = require('http');\nconst Https = require('https');\nconst Path = require('path');\nconst Fs = require('fs');\nconst Events = require('events');\nconst Crypto = require('crypto');\nconst Zlib = require('zlib');\nconst Tls = require('tls');\nconst KeepAlive = new Http.Agent({ keepAlive: true, timeout: 60000 });\n\nconst COMPRESS = { gzip: 1, deflate: 1 };\nconst CONCAT = [null, null];\nconst COMPARER = global.Intl ? global.Intl.Collator().compare : function(a, b) {\n\treturn a.removeDiacritics().localeCompare(b.removeDiacritics());\n};\n\nif (!global.framework_utils)\n\tglobal.framework_utils = exports;\n\nconst Internal = require('./internal');\nvar regexpSTATIC = /\\.\\w{2,8}($|\\?)+/;\nconst regexpTRIM = /^[\\s]+|[\\s]+$/g;\nconst regexpDATE = /(\\d{1,2}\\.\\d{1,2}\\.\\d{4})|(\\d{4}-\\d{1,2}-\\d{1,2})|(\\d{1,2}:\\d{1,2}(:\\d{1,2})?)/g;\nconst regexpDATEFORMAT = /YYYY|yyyy|YY|yy|MMMM|MMM|MM|M|dddd|DDDD|DDD|ddd|DD|dd|D|d|HH|H|hh|h|mm|m|ss|s|a|ww|w/g;\nconst regexpSTRINGFORMAT = /\\{\\d+\\}/g;\nconst regexpPATH = /\\\\/g;\nconst regexpTags = /<\\/?[^>]+(>|$)/g;\nconst regexpDiacritics = /[^\\u0000-\\u007e]/g;\nconst regexpUA = /[a-z]+/gi;\nconst regexpXML = /\\w+=\".*?\"/g;\nconst regexpDECODE = /&#?[a-z0-9]+;/g;\nconst regexpPARAM = /\\{{2}[^}\\n]*\\}{2}/g;\nconst regexpARG = /\\{{1,2}[a-z0-9_.-\\s]+\\}{1,2}/gi;\nconst regexpINTEGER = /(^-|\\s-)?[0-9]+/g;\nconst regexpFLOAT = /(^-|\\s-)?[0-9.,]+/g;\nconst regexpALPHA = /^[A-Za-z0-9]+$/;\nconst regexpSEARCH = /[^a-zA-ZÃ¡-Å¾Ã-Å½\\d\\s:]/g;\nconst regexpTERMINAL = /[\\w\\S]+/g;\nconst regexpCONFIGURE = /\\[\\w+\\]/g;\nconst regexpY = /y/g;\nconst regexpN = /\\n/g;\nconst regexpCHARS = /\\W|_/g;\nconst regexpCHINA = /[\\u3400-\\u9FBF]/;\nconst regexpLINES = /\\n|\\r|\\r\\n/;\nconst regexpBASE64 = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/;\nconst SOUNDEX = { a: '', e: '', i: '', o: '', u: '', b: 1, f: 1, p: 1, v: 1, c: 2, g: 2, j: 2, k: 2, q: 2, s: 2, x: 2, z: 2, d: 3, t: 3, l: 4, m: 5, n: 5, r: 6 };\nconst ENCODING = 'utf8';\nconst NEWLINE = '\\r\\n';\nconst isWindows = require('os').platform().substring(0, 3).toLowerCase() === 'win';\nconst DIACRITICSMAP = {};\nconst STREAM_READONLY = { flags: 'r' };\nconst STREAM_END = { end: false };\nconst ALPHA_INDEX = { '&lt': '<', '&gt': '>', '&quot': '\"', '&apos': '\\'', '&amp': '&', '&lt;': '<', '&gt;': '>', '&quot;': '\"', '&apos;': '\\'', '&amp;': '&' };\nconst NODEVERSION = parseFloat(process.version.toString().replace('v', '').replace(/\\./g, ''));\nconst STREAMPIPE = { end: false };\nconst CT = 'Content-Type';\nconst CRC32TABLE = '00000000,77073096,EE0E612C,990951BA,076DC419,706AF48F,E963A535,9E6495A3,0EDB8832,79DCB8A4,E0D5E91E,97D2D988,09B64C2B,7EB17CBD,E7B82D07,90BF1D91,1DB71064,6AB020F2,F3B97148,84BE41DE,1ADAD47D,6DDDE4EB,F4D4B551,83D385C7,136C9856,646BA8C0,FD62F97A,8A65C9EC,14015C4F,63066CD9,FA0F3D63,8D080DF5,3B6E20C8,4C69105E,D56041E4,A2677172,3C03E4D1,4B04D447,D20D85FD,A50AB56B,35B5A8FA,42B2986C,DBBBC9D6,ACBCF940,32D86CE3,45DF5C75,DCD60DCF,ABD13D59,26D930AC,51DE003A,C8D75180,BFD06116,21B4F4B5,56B3C423,CFBA9599,B8BDA50F,2802B89E,5F058808,C60CD9B2,B10BE924,2F6F7C87,58684C11,C1611DAB,B6662D3D,76DC4190,01DB7106,98D220BC,EFD5102A,71B18589,06B6B51F,9FBFE4A5,E8B8D433,7807C9A2,0F00F934,9609A88E,E10E9818,7F6A0DBB,086D3D2D,91646C97,E6635C01,6B6B51F4,1C6C6162,856530D8,F262004E,6C0695ED,1B01A57B,8208F4C1,F50FC457,65B0D9C6,12B7E950,8BBEB8EA,FCB9887C,62DD1DDF,15DA2D49,8CD37CF3,FBD44C65,4DB26158,3AB551CE,A3BC0074,D4BB30E2,4ADFA541,3DD895D7,A4D1C46D,D3D6F4FB,4369E96A,346ED9FC,AD678846,DA60B8D0,44042D73,33031DE5,AA0A4C5F,DD0D7CC9,5005713C,270241AA,BE0B1010,C90C2086,5768B525,206F85B3,B966D409,CE61E49F,5EDEF90E,29D9C998,B0D09822,C7D7A8B4,59B33D17,2EB40D81,B7BD5C3B,C0BA6CAD,EDB88320,9ABFB3B6,03B6E20C,74B1D29A,EAD54739,9DD277AF,04DB2615,73DC1683,E3630B12,94643B84,0D6D6A3E,7A6A5AA8,E40ECF0B,9309FF9D,0A00AE27,7D079EB1,F00F9344,8708A3D2,1E01F268,6906C2FE,F762575D,806567CB,196C3671,6E6B06E7,FED41B76,89D32BE0,10DA7A5A,67DD4ACC,F9B9DF6F,8EBEEFF9,17B7BE43,60B08ED5,D6D6A3E8,A1D1937E,38D8C2C4,4FDFF252,D1BB67F1,A6BC5767,3FB506DD,48B2364B,D80D2BDA,AF0A1B4C,36034AF6,41047A60,DF60EFC3,A867DF55,316E8EEF,4669BE79,CB61B38C,BC66831A,256FD2A0,5268E236,CC0C7795,BB0B4703,220216B9,5505262F,C5BA3BBE,B2BD0B28,2BB45A92,5CB36A04,C2D7FFA7,B5D0CF31,2CD99E8B,5BDEAE1D,9B64C2B0,EC63F226,756AA39C,026D930A,9C0906A9,EB0E363F,72076785,05005713,95BF4A82,E2B87A14,7BB12BAE,0CB61B38,92D28E9B,E5D5BE0D,7CDCEFB7,0BDBDF21,86D3D2D4,F1D4E242,68DDB3F8,1FDA836E,81BE16CD,F6B9265B,6FB077E1,18B74777,88085AE6,FF0F6A70,66063BCA,11010B5C,8F659EFF,F862AE69,616BFFD3,166CCF45,A00AE278,D70DD2EE,4E048354,3903B3C2,A7672661,D06016F7,4969474D,3E6E77DB,AED16A4A,D9D65ADC,40DF0B66,37D83BF0,A9BCAE53,DEBB9EC5,47B2CF7F,30B5FFE9,BDBDF21C,CABAC28A,53B39330,24B4A3A6,BAD03605,CDD70693,54DE5729,23D967BF,B3667A2E,C4614AB8,5D681B02,2A6F2B94,B40BBE37,C30C8EA1,5A05DF1B,2D02EF8D'.split(',').map(s => parseInt(s, 16));\nconst REGISARR = /\\[\\d+\\]|\\[\\]$/;\nconst REGREPLACEARR = /\\[\\]/g;\nconst PROXYBLACKLIST = { 'localhost': 1, '127.0.0.1': 1, '0.0.0.0': 1 };\nconst PROXYOPTIONS = { headers: {}, method: 'CONNECT', agent: false };\nconst PROXYTLS = { headers: {}};\nconst PROXYOPTIONSHTTP = {};\nconst REG_ROOT = /@\\{#\\}(\\/)?/g;\nconst REG_NOREMAP = /@\\{noremap\\}(\\n)?/g;\nconst REG_REMAP = /href=\".*?\"|src=\".*?\"/gi;\nconst REG_AJAX = /('|\")+(!)?(GET|POST|PUT|DELETE|PATCH)\\s(\\(.*?\\)\\s)?\\//g;\nconst REG_URLEXT = /(https|http|wss|ws|file):\\/\\/|\\/\\/[a-z0-9]|[a-z]:/i;\nconst REG_TEXTAPPLICATION = /text|application/i;\nconst REG_TIME = /am|pm/i;\nconst REG_XMLKEY = /\\[|\\]|:|\\.|_/g;\n\nexports.MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nexports.DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\nvar DIACRITICS=[{b:' ',c:'\\u00a0'},{b:'0',c:'\\u07c0'},{b:'A',c:'\\u24b6\\uff21\\u00c0\\u00c1\\u00c2\\u1ea6\\u1ea4\\u1eaa\\u1ea8\\u00c3\\u0100\\u0102\\u1eb0\\u1eae\\u1eb4\\u1eb2\\u0226\\u01e0\\u00c4\\u01de\\u1ea2\\u00c5\\u01fa\\u01cd\\u0200\\u0202\\u1ea0\\u1eac\\u1eb6\\u1e00\\u0104\\u023a\\u2c6f'},{b:'AA',c:'\\ua732'},{b:'AE',c:'\\u00c6\\u01fc\\u01e2'},{b:'AO',c:'\\ua734'},{b:'AU',c:'\\ua736'},{b:'AV',c:'\\ua738\\ua73a'},{b:'AY',c:'\\ua73c'},{b:'B',c:'\\u24b7\\uff22\\u1e02\\u1e04\\u1e06\\u0243\\u0181'},{b:'C',c:'\\u24b8\\uff23\\ua73e\\u1e08\\u0106C\\u0108\\u010a\\u010c\\u00c7\\u0187\\u023b'},{b:'D',c:'\\u24b9\\uff24\\u1e0a\\u010e\\u1e0c\\u1e10\\u1e12\\u1e0e\\u0110\\u018a\\u0189\\u1d05\\ua779'},{b:'Dh',c:'\\u00d0'},{b:'DZ',c:'\\u01f1\\u01c4'},{b:'Dz',c:'\\u01f2\\u01c5'},{b:'E',c:'\\u025b\\u24ba\\uff25\\u00c8\\u00c9\\u00ca\\u1ec0\\u1ebe\\u1ec4\\u1ec2\\u1ebc\\u0112\\u1e14\\u1e16\\u0114\\u0116\\u00cb\\u1eba\\u011a\\u0204\\u0206\\u1eb8\\u1ec6\\u0228\\u1e1c\\u0118\\u1e18\\u1e1a\\u0190\\u018e\\u1d07'},{b:'F',c:'\\ua77c\\u24bb\\uff26\\u1e1e\\u0191\\ua77b'}, {b:'G',c:'\\u24bc\\uff27\\u01f4\\u011c\\u1e20\\u011e\\u0120\\u01e6\\u0122\\u01e4\\u0193\\ua7a0\\ua77d\\ua77e\\u0262'},{b:'H',c:'\\u24bd\\uff28\\u0124\\u1e22\\u1e26\\u021e\\u1e24\\u1e28\\u1e2a\\u0126\\u2c67\\u2c75\\ua78d'},{b:'I',c:'\\u24be\\uff29\\u00cc\\u00cd\\u00ce\\u0128\\u012a\\u012c\\u0130\\u00cf\\u1e2e\\u1ec8\\u01cf\\u0208\\u020a\\u1eca\\u012e\\u1e2c\\u0197'},{b:'J',c:'\\u24bf\\uff2a\\u0134\\u0248\\u0237'},{b:'K',c:'\\u24c0\\uff2b\\u1e30\\u01e8\\u1e32\\u0136\\u1e34\\u0198\\u2c69\\ua740\\ua742\\ua744\\ua7a2'},{b:'L',c:'\\u24c1\\uff2c\\u013f\\u0139\\u013d\\u1e36\\u1e38\\u013b\\u1e3c\\u1e3a\\u0141\\u023d\\u2c62\\u2c60\\ua748\\ua746\\ua780'}, {b:'LJ',c:'\\u01c7'},{b:'Lj',c:'\\u01c8'},{b:'M',c:'\\u24c2\\uff2d\\u1e3e\\u1e40\\u1e42\\u2c6e\\u019c\\u03fb'},{b:'N',c:'\\ua7a4\\u0220\\u24c3\\uff2e\\u01f8\\u0143\\u00d1\\u1e44\\u0147\\u1e46\\u0145\\u1e4a\\u1e48\\u019d\\ua790\\u1d0e'},{b:'NJ',c:'\\u01ca'},{b:'Nj',c:'\\u01cb'},{b:'O',c:'\\u24c4\\uff2f\\u00d2\\u00d3\\u00d4\\u1ed2\\u1ed0\\u1ed6\\u1ed4\\u00d5\\u1e4c\\u022c\\u1e4e\\u014c\\u1e50\\u1e52\\u014e\\u022e\\u0230\\u00d6\\u022a\\u1ece\\u0150\\u01d1\\u020c\\u020e\\u01a0\\u1edc\\u1eda\\u1ee0\\u1ede\\u1ee2\\u1ecc\\u1ed8\\u01ea\\u01ec\\u00d8\\u01fe\\u0186\\u019f\\ua74a\\ua74c'}, {b:'OE',c:'\\u0152'},{b:'OI',c:'\\u01a2'},{b:'OO',c:'\\ua74e'},{b:'OU',c:'\\u0222'},{b:'P',c:'\\u24c5\\uff30\\u1e54\\u1e56\\u01a4\\u2c63\\ua750\\ua752\\ua754'},{b:'Q',c:'\\u24c6\\uff31\\ua756\\ua758\\u024a'},{b:'R',c:'\\u24c7\\uff32\\u0154\\u1e58\\u0158\\u0210\\u0212\\u1e5a\\u1e5c\\u0156\\u1e5e\\u024c\\u2c64\\ua75a\\ua7a6\\ua782'},{b:'S',c:'\\u24c8\\uff33\\u1e9e\\u015a\\u1e64\\u015c\\u1e60\\u0160\\u1e66\\u1e62\\u1e68\\u0218\\u015e\\u2c7e\\ua7a8\\ua784'},{b:'T',c:'\\u24c9\\uff34\\u1e6a\\u0164\\u1e6c\\u021a\\u0162\\u1e70\\u1e6e\\u0166\\u01ac\\u01ae\\u023e\\ua786'}, {b:'Th',c:'\\u00de'},{b:'TZ',c:'\\ua728'},{b:'U',c:'\\u24ca\\uff35\\u00d9\\u00da\\u00db\\u0168\\u1e78\\u016a\\u1e7a\\u016c\\u00dc\\u01db\\u01d7\\u01d5\\u01d9\\u1ee6\\u016e\\u0170\\u01d3\\u0214\\u0216\\u01af\\u1eea\\u1ee8\\u1eee\\u1eec\\u1ef0\\u1ee4\\u1e72\\u0172\\u1e76\\u1e74\\u0244'},{b:'V',c:'\\u24cb\\uff36\\u1e7c\\u1e7e\\u01b2\\ua75e\\u0245'},{b:'VY',c:'\\ua760'},{b:'W',c:'\\u24cc\\uff37\\u1e80\\u1e82\\u0174\\u1e86\\u1e84\\u1e88\\u2c72'},{b:'X',c:'\\u24cd\\uff38\\u1e8a\\u1e8c'},{b:'Y',c:'\\u24ce\\uff39\\u1ef2\\u00dd\\u0176\\u1ef8\\u0232\\u1e8e\\u0178\\u1ef6\\u1ef4\\u01b3\\u024e\\u1efe'}, {b:'Z',c:'\\u24cf\\uff3a\\u0179\\u1e90\\u017b\\u017d\\u1e92\\u1e94\\u01b5\\u0224\\u2c7f\\u2c6b\\ua762'},{b:'a',c:'\\u24d0\\uff41\\u1e9a\\u00e0\\u00e1\\u00e2\\u1ea7\\u1ea5\\u1eab\\u1ea9\\u00e3\\u0101\\u0103\\u1eb1\\u1eaf\\u1eb5\\u1eb3\\u0227\\u01e1\\u00e4\\u01df\\u1ea3\\u00e5\\u01fb\\u01ce\\u0201\\u0203\\u1ea1\\u1ead\\u1eb7\\u1e01\\u0105\\u2c65\\u0250\\u0251'},{b:'aa',c:'\\ua733'},{b:'ae',c:'\\u00e6\\u01fd\\u01e3'},{b:'ao',c:'\\ua735'},{b:'au',c:'\\ua737'},{b:'av',c:'\\ua739\\ua73b'},{b:'ay',c:'\\ua73d'}, {b:'b',c:'\\u24d1\\uff42\\u1e03\\u1e05\\u1e07\\u0180\\u0183\\u0253\\u0182'},{b:'c',c:'\\uff43\\u24d2\\u0107\\u0109\\u010b\\u010d\\u00e7\\u1e09\\u0188\\u023c\\ua73f\\u2184'},{b:'d',c:'\\u24d3\\uff44\\u1e0b\\u010f\\u1e0d\\u1e11\\u1e13\\u1e0f\\u0111\\u018c\\u0256\\u0257\\u018b\\u13e7\\u0501\\ua7aa'},{b:'dh',c:'\\u00f0'},{b:'dz',c:'\\u01f3\\u01c6'},{b:'e',c:'\\u24d4\\uff45\\u00e8\\u00e9\\u00ea\\u1ec1\\u1ebf\\u1ec5\\u1ec3\\u1ebd\\u0113\\u1e15\\u1e17\\u0115\\u0117\\u00eb\\u1ebb\\u011b\\u0205\\u0207\\u1eb9\\u1ec7\\u0229\\u1e1d\\u0119\\u1e19\\u1e1b\\u0247\\u01dd'}, {b:'f',c:'\\u24d5\\uff46\\u1e1f\\u0192'},{b:'ff',c:'\\ufb00'},{b:'fi',c:'\\ufb01'},{b:'fl',c:'\\ufb02'},{b:'ffi',c:'\\ufb03'},{b:'ffl',c:'\\ufb04'},{b:'g',c:'\\u24d6\\uff47\\u01f5\\u011d\\u1e21\\u011f\\u0121\\u01e7\\u0123\\u01e5\\u0260\\ua7a1\\ua77f\\u1d79'},{b:'h',c:'\\u24d7\\uff48\\u0125\\u1e23\\u1e27\\u021f\\u1e25\\u1e29\\u1e2b\\u1e96\\u0127\\u2c68\\u2c76\\u0265'},{b:'hv',c:'\\u0195'},{b:'i',c:'\\u24d8\\uff49\\u00ec\\u00ed\\u00ee\\u0129\\u012b\\u012d\\u00ef\\u1e2f\\u1ec9\\u01d0\\u0209\\u020b\\u1ecb\\u012f\\u1e2d\\u0268\\u0131'}, {b:'j',c:'\\u24d9\\uff4a\\u0135\\u01f0\\u0249'},{b:'k',c:'\\u24da\\uff4b\\u1e31\\u01e9\\u1e33\\u0137\\u1e35\\u0199\\u2c6a\\ua741\\ua743\\ua745\\ua7a3'},{b:'l',c:'\\u24db\\uff4c\\u0140\\u013a\\u013e\\u1e37\\u1e39\\u013c\\u1e3d\\u1e3b\\u017f\\u0142\\u019a\\u026b\\u2c61\\ua749\\ua781\\ua747\\u026d'},{b:'lj',c:'\\u01c9'},{b:'m',c:'\\u24dc\\uff4d\\u1e3f\\u1e41\\u1e43\\u0271\\u026f'},{b:'n',c:'\\u24dd\\uff4e\\u01f9\\u0144\\u00f1\\u1e45\\u0148\\u1e47\\u0146\\u1e4b\\u1e49\\u019e\\u0272\\u0149\\ua791\\ua7a5\\u043b\\u0509'},{b:'nj', c:'\\u01cc'},{b:'o',c:'\\u24de\\uff4f\\u00f2\\u00f3\\u00f4\\u1ed3\\u1ed1\\u1ed7\\u1ed5\\u00f5\\u1e4d\\u022d\\u1e4f\\u014d\\u1e51\\u1e53\\u014f\\u022f\\u0231\\u00f6\\u022b\\u1ecf\\u0151\\u01d2\\u020d\\u020f\\u01a1\\u1edd\\u1edb\\u1ee1\\u1edf\\u1ee3\\u1ecd\\u1ed9\\u01eb\\u01ed\\u00f8\\u01ff\\ua74b\\ua74d\\u0275\\u0254\\u1d11'},{b:'oe',c:'\\u0153'},{b:'oi',c:'\\u01a3'},{b:'oo',c:'\\ua74f'},{b:'ou',c:'\\u0223'},{b:'p',c:'\\u24df\\uff50\\u1e55\\u1e57\\u01a5\\u1d7d\\ua751\\ua753\\ua755\\u03c1'},{b:'q',c:'\\u24e0\\uff51\\u024b\\ua757\\ua759'}, {b:'r',c:'\\u24e1\\uff52\\u0155\\u1e59\\u0159\\u0211\\u0213\\u1e5b\\u1e5d\\u0157\\u1e5f\\u024d\\u027d\\ua75b\\ua7a7\\ua783'},{b:'s',c:'\\u24e2\\uff53\\u015b\\u1e65\\u015d\\u1e61\\u0161\\u1e67\\u1e63\\u1e69\\u0219\\u015f\\u023f\\ua7a9\\ua785\\u1e9b\\u0282'},{b:'ss',c:'\\u00df'},{b:'t',c:'\\u24e3\\uff54\\u1e6b\\u1e97\\u0165\\u1e6d\\u021b\\u0163\\u1e71\\u1e6f\\u0167\\u01ad\\u0288\\u2c66\\ua787'},{b:'th',c:'\\u00fe'},{b:'tz',c:'\\ua729'},{b:'u',c:'\\u24e4\\uff55\\u00f9\\u00fa\\u00fb\\u0169\\u1e79\\u016b\\u1e7b\\u016d\\u00fc\\u01dc\\u01d8\\u01d6\\u01da\\u1ee7\\u016f\\u0171\\u01d4\\u0215\\u0217\\u01b0\\u1eeb\\u1ee9\\u1eef\\u1eed\\u1ef1\\u1ee5\\u1e73\\u0173\\u1e77\\u1e75\\u0289'}, {b:'v',c:'\\u24e5\\uff56\\u1e7d\\u1e7f\\u028b\\ua75f\\u028c'},{b:'vy',c:'\\ua761'},{b:'w',c:'\\u24e6\\uff57\\u1e81\\u1e83\\u0175\\u1e87\\u1e85\\u1e98\\u1e89\\u2c73'},{b:'x',c:'\\u24e7\\uff58\\u1e8b\\u1e8d'},{b:'y',c:'\\u24e8\\uff59\\u1ef3\\u00fd\\u0177\\u1ef9\\u0233\\u1e8f\\u00ff\\u1ef7\\u1e99\\u1ef5\\u01b4\\u024f\\u1eff'},{b:'z',c:'\\u24e9\\uff5a\\u017a\\u1e91\\u017c\\u017e\\u1e93\\u1e95\\u01b6\\u0225\\u0240\\u2c6c\\ua763'}];\n\nfor (var i=0; i <DIACRITICS.length; i+=1)\n\tfor (var chars=DIACRITICS[i].c,j=0;j<chars.length;j+=1)\n\t\tDIACRITICSMAP[chars[j]]=DIACRITICS[i].b;\n\nconst DP = Date.prototype;\nconst SP = String.prototype;\nconst NP = Number.prototype;\n\nDIACRITICS = null;\n\nvar CONTENTTYPES = {\n\taac: 'audio/aac',\n\tai: 'application/postscript',\n\tappcache: 'text/cache-manifest',\n\tavi: 'video/avi',\n\tbin: 'application/octet-stream',\n\tbmp: 'image/bmp',\n\tcoffee: 'text/coffeescript',\n\tcss: 'text/css',\n\tcsv: 'text/csv',\n\tdoc: 'application/msword',\n\tdocx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\tdtd: 'application/xml-dtd',\n\teps: 'application/postscript',\n\texe: 'application/octet-stream',\n\tflac: 'audio/x-flac',\n\tgeojson: 'application/json',\n\tgif: 'image/gif',\n\tgzip: 'application/x-gzip',\n\theic: 'image/heic',\n\theif: 'image/heif',\n\thtm: 'text/html',\n\thtml: 'text/html',\n\tico: 'image/x-icon',\n\tics: 'text/calendar',\n\tifb: 'text/calendar',\n\tjpe: 'image/jpeg',\n\tjpeg: 'image/jpeg',\n\tjpg: 'image/jpeg',\n\tjs: 'text/javascript',\n\tjson: 'application/json',\n\tjsx: 'text/jsx',\n\tless: 'text/css',\n\tm4a: 'audio/mp4a-latm',\n\tm4v: 'video/x-m4v',\n\tmanifest: 'text/cache-manifest',\n\tmd: 'text/x-markdown',\n\tmid: 'audio/midi',\n\tmidi: 'audio/midi',\n\tmjs: 'text/javascript',\n\tmov: 'video/quicktime',\n\tmp3: 'audio/mpeg',\n\tmp4: 'video/mp4',\n\tmpe: 'video/mpeg',\n\tmpeg: 'video/mpeg',\n\tmpg: 'video/mpeg',\n\tmpga: 'audio/mpeg',\n\tmtl: 'text/plain',\n\tmv4: 'video/mv4',\n\tobj: 'text/plain',\n\togg: 'application/ogg',\n\togv: 'video/ogg',\n\tpackage: 'text/plain',\n\tpdf: 'application/pdf',\n\tpng: 'image/png',\n\tppt: 'application/vnd.ms-powerpoint',\n\tpptx: 'application/vnd.ms-powerpoint',\n\tps: 'application/postscript',\n\trar: 'application/x-rar-compressed',\n\trtf: 'text/rtf',\n\tsass: 'text/css',\n\tscss: 'text/css',\n\tsh: 'application/x-sh',\n\tstl: 'application/sla',\n\tsvg: 'image/svg+xml',\n\tswf: 'application/x-shockwave-flash',\n\ttar: 'application/x-tar',\n\ttif: 'image/tiff',\n\ttiff: 'image/tiff',\n\ttxt: 'text/plain',\n\tsql: 'text/plain',\n\twav: 'audio/x-wav',\n\twebm: 'video/webm',\n\twebp: 'image/webp',\n\twoff: 'application/font-woff',\n\twoff2: 'application/font-woff2',\n\txht: 'application/xhtml+xml',\n\txhtml: 'application/xhtml+xml',\n\txls: 'application/vnd.ms-excel',\n\txlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\txml: 'application/xml',\n\txpm: 'image/x-xpixmap',\n\txsl: 'application/xml',\n\txslt: 'application/xslt+xml',\n\tzip: 'application/zip'\n};\n\nvar dnscache = {};\nvar datetimeformat = {};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nglobal.DIFFARR = exports.diffarr = function(prop, db, form) {\n\n\tvar an = [];\n\tvar au = [];\n\tvar ar = [];\n\tvar is, oa, ob;\n\n\tfor (var i = 0; i < db.length; i++) {\n\t\toa = db[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < form.length; j++) {\n\t\t\tob = form[j];\n\t\t\tif (oa[prop] == ob[prop]) {\n\t\t\t\tau.push({ db: oa, form: ob });\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tar.push(oa[prop]);\n\t}\n\n\tfor (var i = 0; i < form.length; i++) {\n\t\tob = form[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < db.length; j++) {\n\t\t\toa = db[j];\n\t\t\tif (ob[prop] == oa[prop]) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tan.push(ob);\n\t}\n\n\tvar obj = {};\n\tobj.add = an;\n\tobj.upd = au;\n\tobj.rem = ar;\n\treturn obj;\n};\n\n/**\n * Checks if is object empty\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isEmpty = function(obj) {\n\n\tif (!obj || obj instanceof Array)\n\t\treturn true;\n\n\tfor (var key in obj) {\n\t\tif (hasOwnProperty.call(obj, key))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Compare objects\n * @param {Object} obj1\n * @param {Object} obj2\n * @return {Boolean}\n */\nexports.isEqual = function(obj1, obj2, properties) {\n\n\tvar keys = properties ? properties : Object.keys(obj1);\n\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tvar key = keys[i];\n\t\tvar a = obj1[key];\n\t\tvar b = obj2[key];\n\t\tvar ta = typeof(a);\n\t\tvar tb = typeof(b);\n\n\t\tif (ta !== tb)\n\t\t\treturn false;\n\n\t\tif (a === b)\n\t\t\tcontinue;\n\n\t\tif (a instanceof Date && b instanceof Date) {\n\t\t\tif (a.getTime() === b.getTime())\n\t\t\t\tcontinue;\n\t\t\treturn false;\n\t\t} else if (a instanceof Array && b instanceof Array) {\n\t\t\tif (JSON.stringify(a) === JSON.stringify(b))\n\t\t\t\tcontinue;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (ta === 'object' && tb === 'object') {\n\t\t\tif (exports.isEqual(a, b))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Function checks a valid function and waits for it positive result\n * @param {Function} fnValid\n * @param {Function(err, success)} fnCallback\n * @param {Number} timeout  Timeout, optional (default: 5000)\n * @param {Number} interval Refresh interval, optional (default: 500)\n */\nexports.wait = function(fnValid, fnCallback, timeout, interval) {\n\n\tif (fnValid() === true)\n\t\treturn fnCallback(null, true);\n\n\tvar id_timeout = null;\n\tvar id_interval = setInterval(function() {\n\n\t\tif (fnValid() === true) {\n\t\t\tclearInterval(id_interval);\n\t\t\tclearTimeout(id_timeout);\n\t\t\tfnCallback && fnCallback(null, true);\n\t\t}\n\n\t}, interval || 500);\n\n\tid_timeout = setTimeout(function() {\n\t\tclearInterval(id_interval);\n\t\tfnCallback && fnCallback(new Error('Timeout.'), false);\n\t}, timeout || 5000);\n};\n\nexports.$$wait = function(fnValid, timeout, interval) {\n\treturn function(callback) {\n\t\texports.wait(fnValid, callback, timeout, interval);\n\t};\n};\n\n/**\n * Resolves an IP from the URL address\n * @param {String} url\n * @param {Function(err, uri)} callback\n */\nexports.resolve = function(url, callback, param) {\n\n\tvar uri = Url.parse(url);\n\n\n\tif (!callback)\n\t\treturn dnscache[uri.host];\n\n\tif (dnscache[uri.host]) {\n\t\turi.host = dnscache[uri.host];\n\t\tcallback(null, uri, param);\n\t\treturn;\n\t}\n\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (e)\n\t\t\tsetImmediate(dnsresolve_callback, uri, callback, param);\n\t\telse {\n\t\t\tdnscache[uri.host] = addresses[0];\n\t\t\turi.host = addresses[0];\n\t\t\tcallback(null, uri, param);\n\t\t}\n\t});\n};\n\nfunction dnsresolve_callback(uri, callback, param) {\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (addresses && addresses.length) {\n\t\t\tdnscache[uri.host] = addresses[0];\n\t\t\turi.host = addresses[0];\n\t\t}\n\t\tcallback(e, uri, param);\n\t});\n}\n\nexports.$$resolve = function(url) {\n\treturn function(callback) {\n\t\treturn exports.resolve(url, callback);\n\t};\n};\n\n/**\n * Clears DNS cache\n */\nexports.clearDNS = function() {\n\tOBSOLETE('U.clearDNS()', 'Use CMD(\\'clear_dnscache\\')');\n\tCMD('clear_dnscache');\n};\n\nsetImmediate(function() {\n\tif (global.F) {\n\t\tF.install('command', 'clear_dnscache', function() {\n\t\t\tdnscache = {};\n\t\t});\n\t}\n});\n\n\nexports.keywords = function(content, forSearch, alternative, max_count, max_length, min_length) {\n\n\tif (forSearch === undefined)\n\t\tforSearch = true;\n\n\tmin_length = min_length || 2;\n\tmax_count = max_count || 200;\n\tmax_length = max_length || 20;\n\n\tvar words = [];\n\tvar isSoundex = alternative === 'soundex';\n\n\tif (content instanceof Array) {\n\t\tfor (var i = 0, length = content.length; i < length; i++) {\n\t\t\tif (!content[i])\n\t\t\t\tcontinue;\n\t\t\tvar tmp = (forSearch ? content[i].removeDiacritics().toLowerCase().replace(regexpY, 'i') : content[i].toLowerCase()).replace(regexpN, ' ').split(' ');\n\t\t\tif (!tmp || !tmp.length)\n\t\t\t\tcontinue;\n\t\t\tfor (var j = 0, jl = tmp.length; j < jl; j++)\n\t\t\t\twords.push(tmp[j]);\n\t\t}\n\t} else\n\t\twords = (forSearch ? content.removeDiacritics().toLowerCase().replace(regexpY, 'i') : content.toLowerCase()).replace(regexpN, ' ').split(' ');\n\n\tif (!words)\n\t\twords = [];\n\n\tvar dic = {};\n\tvar counter = 0;\n\n\tfor (var i = 0, length = words.length; i < length; i++) {\n\n\t\tvar word = words[i].trim().replace(regexpCHARS, keywordscleaner);\n\n\t\tif (regexpCHINA.test(word)) {\n\n\t\t\tvar tmpw = word.split('', max_count);\n\n\t\t\tfor (var j = 0; j < tmpw.length; j++) {\n\t\t\t\tword = tmpw[j];\n\t\t\t\tif (dic[word])\n\t\t\t\t\tdic[word]++;\n\t\t\t\telse\n\t\t\t\t\tdic[word] = 1;\n\t\t\t\tcounter++;\n\t\t\t}\n\n\t\t\tif (counter >= max_count)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (word.length < min_length)\n\t\t\tcontinue;\n\n\t\tif (counter >= max_count)\n\t\t\tbreak;\n\n\t\t// Gets 80% length of word\n\t\tif (alternative) {\n\t\t\tif (isSoundex)\n\t\t\t\tword = word.soundex();\n\t\t\telse {\n\t\t\t\tvar size = (word.length / 100) * 80;\n\t\t\t\tif (size > min_length + 1)\n\t\t\t\t\tword = word.substring(0, size);\n\t\t\t}\n\t\t}\n\n\t\tif (word.length < min_length || word.length > max_length)\n\t\t\tcontinue;\n\n\t\tif (dic[word])\n\t\t\tdic[word]++;\n\t\telse\n\t\t\tdic[word] = 1;\n\n\t\tcounter++;\n\t}\n\n\tvar keys = Object.keys(dic);\n\n\tkeys.sort(function(a, b) {\n\t\tvar countA = dic[a];\n\t\tvar countB = dic[b];\n\t\treturn countA > countB ? -1 : countA < countB ? 1 : 0;\n\t});\n\n\treturn keys;\n};\n\nfunction keywordscleaner(c) {\n\treturn c.charCodeAt(0) < 200 ? '' : c;\n}\n\nfunction parseProxy(p) {\n\tvar key = 'proxy_' + p;\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tif (p.indexOf('://') === -1)\n\t\tp = 'http://' + p;\n\n\tvar obj = Url.parse(p);\n\n\tif (obj.auth)\n\t\tobj._auth = 'Basic ' + Buffer.from(obj.auth).toString('base64');\n\n\tobj.port = +obj.port;\n\treturn F.temporary.other[key] = obj;\n}\n\n/**\n * Create a request to a specific URL\n * @param  {String} url URL address.\n * @param  {String Array} flags Request flags.\n * @param  {String or Object} data Request data (optional).\n * @param  {Function(error, content, statusCode, headers)} callback Callback.\n * @param  {Object} headers Custom cookies (optional, default: null).\n * @param  {Object} headers Custom headers (optional, default: null).\n * @param  {String} encoding Encoding (optional, default: UTF8)\n * @param  {Number} timeout Request timeout.\n * return {Boolean}\n */\n\nconst NOBODY = { GET: 1, OPTIONS: 1, HEAD: 1 };\n\nglobal.REQUEST = exports.request = function(url, flags, data, callback, cookies, headers, encoding, timeout, files, param) {\n\n\t// No data (data is optional argument)\n\tif (typeof(data) === 'function') {\n\t\tencoding = headers;\n\t\theaders = cookies;\n\t\tcookies = callback;\n\t\tcallback = data;\n\t\tdata = '';\n\t} else if (!data)\n\t\tdata = '';\n\n\tif (callback === NOOP)\n\t\tcallback = null;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tvar options = { length: 0, timeout: timeout || CONF.default_restbuilder_timeout, evt: new EventEmitter2(), encoding: typeof(encoding) !== 'string' ? ENCODING : encoding, callback: callback, post: false, redirect: 0 };\n\tvar method;\n\tvar type = 0;\n\tvar isCookies = false;\n\tvar def;\n\tvar proxy;\n\n\tif (headers) {\n\t\theaders = exports.extend({}, headers);\n\t\tdef = headers[CT];\n\t} else\n\t\theaders = {};\n\n\tif (flags instanceof Array) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\n\t\t\t// timeout\n\t\t\tif (flags[i] > 0) {\n\t\t\t\toptions.timeout = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === '<') {\n\t\t\t\toptions.max = flags[i].substring(1).trim().parseInt() * 1024; // kB\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === 'p' && flags[i][4] === 'y') {\n\t\t\t\tproxy = parseProxy(flags[i].substring(6));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (flags[i].toLowerCase()) {\n\t\t\t\tcase 'insecure':\n\t\t\t\t\toptions.insecure = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'utf8':\n\t\t\t\tcase 'ascii':\n\t\t\t\tcase 'base64':\n\t\t\t\tcase 'binary':\n\t\t\t\tcase 'hex':\n\t\t\t\t\toptions.encoding = flags[i];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'xhr':\n\t\t\t\t\theaders['X-Requested-With'] = 'XMLHttpRequest';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'plain':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'text/plain';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'text/html';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'raw':\n\t\t\t\t\ttype = 3;\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'application/octet-stream';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'json':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'application/json';\n\t\t\t\t\t!method && (method = 'POST');\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'xml':\n\t\t\t\t\tif (!def)\n\t\t\t\t\t\theaders[CT] = 'text/xml';\n\t\t\t\t\t!method && (method = 'POST');\n\t\t\t\t\ttype = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'get':\n\t\t\t\tcase 'options':\n\t\t\t\tcase 'head':\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'noredirect':\n\t\t\t\t\toptions.noredirect = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'upload':\n\t\t\t\t\ttype = 4;\n\t\t\t\t\toptions.upload = true;\n\t\t\t\t\toptions.files = files || EMPTYARRAY;\n\t\t\t\t\toptions.boundary = '----totaljs' + Math.random().toString(16).substring(2);\n\t\t\t\t\theaders[CT] = 'multipart/form-data; boundary=' + options.boundary;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'put':\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'patch':\n\t\t\t\t\tmethod = flags[i].toUpperCase();\n\t\t\t\t\t!def && !headers[CT] && (headers[CT] = 'application/x-www-form-urlencoded');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'dnscache':\n\t\t\t\t\toptions.resolve = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'keepalive':\n\t\t\t\t\toptions.keepalive = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'cookies':\n\t\t\t\t\tisCookies = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Fallback for methods (e.g. CalDAV)\n\t\t\t\t\tif (!method)\n\t\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (method)\n\t\toptions.post = !NOBODY[method];\n\telse\n\t\tmethod = 'GET';\n\n\tif (type < 3) {\n\n\t\tif (typeof(data) !== 'string')\n\t\t\tdata = type === 1 ? JSON.stringify(data) : Qs.stringify(data);\n\t\telse if (data[0] === '?')\n\t\t\tdata = data.substring(1);\n\n\t\tif (!options.post) {\n\t\t\tif (data.length) {\n\t\t\t\tif (url.indexOf('?') === -1)\n\t\t\t\t\turl += '?' + data;\n\t\t\t\telse\n\t\t\t\t\turl += '&' + data;\n\t\t\t}\n\t\t\tdata = '';\n\t\t}\n\n\t\t// \"null\" or \"empty string\" is valid JSON value too\n\t\tif (type === 1 && (data === EMPTYOBJECT || data === undefined) && options.post)\n\t\t\tdata = BUFEMPTYJSON;\n\t}\n\n\tif (data && type !== 4) {\n\t\toptions.data = data instanceof Buffer ? data : Buffer.from(data, ENCODING);\n\t\theaders['Content-Length'] = options.data.length;\n\t} else\n\t\toptions.data = data;\n\n\tif (cookies) {\n\t\tif (isCookies)\n\t\t\toptions.cookies = cookies;\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tif (builder)\n\t\t\theaders['Cookie'] = builder;\n\t}\n\n\tvar uri = Url.parse(url);\n\n\tif (!uri.hostname || !uri.host) {\n\t\tcallback && callback(new Error('URL doesn\\'t contain a hostname'), '', 0);\n\t\treturn;\n\t}\n\n\turi.method = method;\n\turi.headers = headers;\n\toptions.uri = uri;\n\n\tif (options.insecure) {\n\t\turi.rejectUnauthorized = false;\n\t\turi.requestCert = true;\n\t}\n\n\tif (options.resolve && (uri.hostname === 'localhost' || uri.hostname.charCodeAt(0) < 64))\n\t\toptions.resolve = null;\n\n\tif (CONF.default_proxy && !proxy && !PROXYBLACKLIST[uri.hostname])\n\t\tproxy = parseProxy(CONF.default_proxy);\n\n\tif (proxy && (uri.hostname === 'localhost' || uri.hostname === '127.0.0.1'))\n\t\tproxy = null;\n\n\toptions.proxy = proxy;\n\toptions.param = param;\n\n\tif (proxy && uri.protocol === 'https:') {\n\t\tproxy.tls = true;\n\t\turi.agent = new ProxyAgent(options);\n\t\turi.agent.request = Http.request;\n\t\turi.agent.createSocket = createSecureSocket;\n\t\turi.agent.defaultPort = 443;\n\t}\n\n\tif (options.keepalive && !options.proxy && uri.protocol !== 'https:')\n\t\turi.agent = KeepAlive;\n\n\tif (proxy)\n\t\trequest_call(uri, options);\n\telse if (options.resolve)\n\t\texports.resolve(url, request_resolve, options);\n\telse\n\t\trequest_call(uri, options);\n\n\treturn options.evt;\n};\n\nfunction request_resolve(err, uri, options) {\n\tif (!err)\n\t\toptions.uri.host = uri.host;\n\trequest_call(options.uri, options);\n}\n\nfunction ProxyAgent(options) {\n\tvar self = this;\n\tself.options = options;\n\tself.maxSockets = Http.Agent.defaultMaxSockets;\n\tself.requests = [];\n}\n\nconst PAP = ProxyAgent.prototype;\n\nPAP.createConnection = function(pending) {\n\tvar self = this;\n\tself.createSocket(pending, function(socket) {\n\t\tpending.request.onSocket(socket);\n\t});\n};\n\nPAP.createSocket = function(options, callback) {\n\n\tvar self = this;\n\tvar proxy = self.options.proxy;\n\tvar uri = self.options.uri;\n\n\tPROXYOPTIONS.host = proxy.hostname;\n\tPROXYOPTIONS.port = proxy.port;\n\tPROXYOPTIONS.path = PROXYOPTIONS.headers.host = uri.hostname + ':' + (uri.port || '443');\n\n\tif (proxy._auth)\n\t\tPROXYOPTIONS.headers['Proxy-Authorization'] = proxy._auth;\n\n\tvar req = self.request(PROXYOPTIONS);\n\treq.setTimeout(10000);\n\treq.on('response', proxyagent_response);\n\treq.on('connect', function(res, socket) {\n\n\t\tif (res.statusCode === 200) {\n\t\t\tsocket.$req = req;\n\t\t\tcallback(socket);\n\t\t} else {\n\t\t\tvar err = new Error('Proxy could not be established (maybe a problem in auth), code: ' + res.statusCode);\n\t\t\terr.code = 'ECONNRESET';\n\t\t\toptions.request.emit('error', err);\n\t\t\treq.destroy && req.destroy();\n\t\t\treq = null;\n\t\t\tself.requests = null;\n\t\t\tself.options = null;\n\t\t}\n\t});\n\n\treq.on('error', function(err) {\n\t\tvar e = new Error('Request Proxy \"proxy {0} --> target {1}\": {2}'.format(PROXYOPTIONS.host + ':' + proxy.port, PROXYOPTIONS.path, err.toString()));\n\t\te.code = err.code;\n\t\toptions.request.emit('error', e);\n\t\treq.destroy && req.destroy();\n\t\treq = null;\n\t\tself.requests = null;\n\t\tself.options = null;\n\t});\n\n\treq.end();\n};\n\nfunction proxyagent_response(res) {\n\tres.upgrade = true;\n}\n\nPAP.addRequest = function(req, options) {\n\tthis.createConnection({ host: options.host, port: options.port, request: req });\n};\n\nfunction createSecureSocket(options, callback) {\n\tvar self = this;\n\tPAP.createSocket.call(self, options, function(socket) {\n\t\tPROXYTLS.servername = self.options.uri.hostname;\n\t\tPROXYTLS.headers = self.options.uri.headers;\n\t\tPROXYTLS.socket = socket;\n\t\tvar tls = Tls.connect(0, PROXYTLS);\n\t\tcallback(tls);\n\t});\n}\n\nfunction request_call(uri, options) {\n\n\tvar opt;\n\n\tif (options.proxy && !options.proxy.tls) {\n\t\topt = PROXYOPTIONSHTTP;\n\t\topt.port = options.proxy.port;\n\t\topt.host = options.proxy.hostname;\n\t\topt.path = uri.href;\n\t\topt.headers = uri.headers;\n\t\topt.method = uri.method;\n\t\topt.headers.host = uri.host;\n\n\t\tif (options.insecure) {\n\t\t\topt.rejectUnauthorized = false;\n\t\t\topt.requestCert = true;\n\t\t}\n\n\t\tif (options.proxy._auth)\n\t\t\topt.headers['Proxy-Authorization'] = options.proxy._auth;\n\t} else\n\t\topt = uri;\n\n\tvar connection = uri.protocol === 'https:' ? Https : Http;\n\tvar req = options.post ? connection.request(opt, request_response) : connection.get(opt, request_response);\n\n\treq.$options = options;\n\treq.$uri = uri;\n\n\tif (!options.callback) {\n\t\treq.on('error', NOOP);\n\t\treturn;\n\t}\n\n\treq.on('error', request_process_error);\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.timeoutid = setTimeout(request_process_timeout, options.timeout, req);\n\n\t// req.on('response', (response) => response.req = req);\n\treq.on('response', request_assign_res);\n\n\tif (options.upload) {\n\t\toptions.first = true;\n\t\toptions.files.wait(function(file, next) {\n\t\t\trequest_writefile(req, options, file, next);\n\t\t}, function() {\n\t\t\tvar keys = Object.keys(options.data);\n\t\t\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\t\t\tvar value = options.data[keys[i]];\n\t\t\t\tif (value != null) {\n\t\t\t\t\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + keys[i] + '\"' + NEWLINE + NEWLINE + value.toString());\n\t\t\t\t\tif (options.first)\n\t\t\t\t\t\toptions.first = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treq.end(NEWLINE + '--' + options.boundary + '--');\n\t\t});\n\t} else\n\t\treq.end(options.data);\n}\n\nfunction request_process_error(err) {\n\tvar options = this.$options;\n\tif (options.callback && !options.done) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\toptions.canceled = true;\n\t\toptions.callback(err, '', 0, undefined, this.$uri.host, EMPTYOBJECT, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n}\n\nfunction request_process_timeout(req) {\n\tvar options = req.$options;\n\tif (options.callback) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\treq.socket.destroy();\n\t\treq.socket.end();\n\t\treq.abort();\n\t\toptions.canceled = true;\n\t\toptions.callback(new Error(exports.httpStatus(408)), '', 0, undefined, req.$uri.host, EMPTYOBJECT, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n}\n\nfunction request_assign_res(response) {\n\tresponse.req = this;\n}\n\nfunction request_writefile(req, options, file, next) {\n\n\tvar type = typeof(file.buffer);\n\tvar filename = (type === 'string' ? file.buffer : exports.getName(file.filename));\n\n\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + file.name + '\"; filename=\"' + filename + '\"' + NEWLINE + 'Content-Type: ' + exports.getContentType(exports.getExtension(filename)) + NEWLINE + NEWLINE);\n\n\tif (options.first)\n\t\toptions.first = false;\n\n\t// Is Buffer\n\tif (file.buffer && type === 'object') {\n\t\treq.write(file.buffer);\n\t\tnext();\n\t} else {\n\t\tvar stream = Fs.createReadStream(file.filename);\n\t\tstream.once('close', next);\n\t\tstream.pipe(req, STREAMPIPE);\n\t}\n}\n\nfunction request_response(res) {\n\n\tvar options = this.$options;\n\tvar uri = this.$uri;\n\n\tres._buffer = null;\n\tres._bufferlength = 0;\n\n\t// We have redirect\n\tif (res.statusCode === 301 || res.statusCode === 302) {\n\n\t\tif (options.noredirect) {\n\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\n\t\t\tif (options.callback) {\n\t\t\t\toptions.callback(null, '', res.statusCode, res.headers, uri.host, EMPTYOBJECT, options.param);\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tif (options.evt) {\n\t\t\t\toptions.evt.removeAllListeners();\n\t\t\t\toptions.evt = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.redirect > 3) {\n\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\n\t\t\tif (options.callback) {\n\t\t\t\toptions.callback(new Error('Too many redirects.'), '', 0, undefined, uri.host, EMPTYOBJECT, options.param);\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tif (options.evt) {\n\t\t\t\toptions.evt.removeAllListeners();\n\t\t\t\toptions.evt = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\toptions.redirect++;\n\n\t\tvar loc = res.headers['location'];\n\t\tvar proto = loc.substring(0, 6);\n\n\t\tif (proto !== 'http:/' && proto !== 'https:')\n\t\t\tloc = uri.protocol + '//' + uri.hostname + loc;\n\n\t\tvar tmp = Url.parse(loc);\n\t\ttmp.headers = uri.headers;\n\t\t// tmp.agent = false;\n\t\ttmp.method = uri.method;\n\n\t\tres.req.removeAllListeners();\n\t\tres.req = null;\n\n\t\tif (options.proxy && tmp.protocol === 'https:') {\n\t\t\t// TLS?\n\t\t\toptions.proxy.tls = true;\n\t\t\toptions.uri = tmp;\n\t\t\toptions.uri.agent = new ProxyAgent(options);\n\t\t\toptions.uri.agent.request = Http.request;\n\t\t\toptions.uri.agent.createSocket = createSecureSocket;\n\t\t\toptions.uri.agent.defaultPort = 443;\n\t\t}\n\n\t\tif (!options.resolve) {\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn request_call(tmp, options);\n\t\t}\n\n\t\texports.resolve(tmp, function(err, u) {\n\t\t\tif (!err)\n\t\t\t\ttmp.host = u.host;\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\trequest_call(tmp, options);\n\t\t});\n\n\t\treturn;\n\t}\n\n\toptions.length = +res.headers['content-length'] || 0;\n\toptions.evt && options.evt.$events.begin && options.evt.emit('begin', options.length);\n\n\t// Shared cookies\n\tif (options.cookies) {\n\t\tvar arr = (res.headers['set-cookie'] || '');\n\n\t\t// Only the one value\n\t\tif (arr && !(arr instanceof Array))\n\t\t\tarr = [arr];\n\n\t\tif (arr instanceof Array) {\n\t\t\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\t\t\tvar line = arr[i];\n\t\t\t\tvar end = line.indexOf(';');\n\t\t\t\tif (end === -1)\n\t\t\t\t\tend = line.length;\n\t\t\t\tline = line.substring(0, end);\n\t\t\t\tvar index = line.indexOf('=');\n\t\t\t\tif (index !== -1)\n\t\t\t\t\toptions.cookies[line.substring(0, index)] = decodeURIComponent(line.substring(index + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res.statusCode === 204) {\n\t\toptions.done = true;\n\t\trequest_process_end.call(res);\n\t\treturn;\n\t}\n\n\tvar encoding = res.headers['content-encoding'] || '';\n\tif (encoding)\n\t\tencoding = encoding.split(',')[0];\n\n\tif (COMPRESS[encoding]) {\n\t\tvar zlib = encoding === 'gzip' ? Zlib.createGunzip() : Zlib.createInflate();\n\t\tzlib._buffer = res.buffer;\n\t\tzlib.headers = res.headers;\n\t\tzlib.statusCode = res.statusCode;\n\t\tzlib.res = res;\n\t\tzlib.on('data', request_process_data);\n\t\tzlib.on('end', request_process_end);\n\t\tres.pipe(zlib);\n\t} else {\n\t\tres.on('data', request_process_data);\n\t\tres.on('end', request_process_end);\n\t}\n\n\tres.resume();\n}\n\nfunction request_process_data(chunk) {\n\tvar self = this;\n\n\t// Is Zlib\n\tif (!self.req)\n\t\tself = self.res;\n\n\tvar options = self.req.$options;\n\tif (options.canceled || (options.max && self._bufferlength > options.max))\n\t\treturn;\n\tif (self._buffer) {\n\t\tCONCAT[0] = self._buffer;\n\t\tCONCAT[1] = chunk;\n\t\tself._buffer = Buffer.concat(CONCAT);\n\t} else\n\t\tself._buffer = chunk;\n\tself._bufferlength += chunk.length;\n\toptions.evt && options.evt.$events.data && options.evt.emit('data', chunk, options.length ? (self._bufferlength / options.length) * 100 : 0);\n}\n\nfunction request_process_end() {\n\n\tvar res = this;\n\n\t// Is Zlib\n\tif (!res.req)\n\t\tres = res.res;\n\n\tvar self = res;\n\tvar options = self.req.$options;\n\tvar uri = self.req.$uri;\n\tvar data;\n\n\toptions.socket && options.uri.agent.destroy();\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\n\tif (options.canceled)\n\t\treturn;\n\n\tvar ct = self.headers['content-type'];\n\n\tif (!ct || REG_TEXTAPPLICATION.test(ct))\n\t\tdata = self._buffer ? (options.encoding === 'binary' ? self._buffer : self._buffer.toString(options.encoding)) : '';\n\telse\n\t\tdata = self._buffer;\n\n\toptions.canceled = true;\n\n\tself._buffer = undefined;\n\n\tif (options.evt) {\n\t\toptions.evt.$events.end && options.evt.emit('end', data, self.statusCode, self.headers, uri.host, options.cookies, options.param);\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n\n\tif (options.callback) {\n\t\toptions.callback(null, uri.method === 'HEAD' ? self.headers : data, self.statusCode, self.headers, uri.host, options.cookies, options.param);\n\t\toptions.callback = null;\n\t}\n\n\tif (res.statusCode !== 204) {\n\t\tres.req && res.req.removeAllListeners();\n\t\tres.removeAllListeners();\n\t}\n}\n\nexports.$$request = function(url, flags, data, cookies, headers, encoding, timeout) {\n\treturn function(callback) {\n\t\texports.request(url, flags, data, callback, cookies, headers, encoding, timeout);\n\t};\n};\n\nexports.btoa = function(str) {\n\treturn (str instanceof Buffer) ? str.toString('base64') : Buffer.from(str.toString(), 'utf8').toString('base64');\n};\n\nexports.atob = function(str) {\n\treturn Buffer.from(str, 'base64').toString('utf8');\n};\n\n/**\n * Create a request to a specific URL\n * @param {String} url URL address.\n * @param {String Array} flags Request flags.\n * @param {String or Object} data Request data (optional).\n * @param {Function(error, response)} callback Callback.\n * @param {Object} cookies Custom cookies (optional, default: null).\n * @param {Object} headers Custom headers (optional, default: null).\n * @param {String} encoding Encoding (optional, default: UTF8)\n * @param {Number} timeout Request timeout.\n * return {Boolean}\n */\nexports.download = function(url, flags, data, callback, cookies, headers, encoding, timeout, param) {\n\n\t// No data (data is optional argument)\n\tif (typeof(data) === 'function') {\n\t\ttimeout = encoding;\n\t\tencoding = headers;\n\t\theaders = cookies;\n\t\tcookies = callback;\n\t\tcallback = data;\n\t\tdata = '';\n\t}\n\n\tif (typeof(cookies) === 'number') {\n\t\tcookies = null;\n\t\ttimeout = cookies;\n\t}\n\n\tif (typeof(headers) === 'number') {\n\t\theaders = null;\n\t\ttimeout = headers;\n\t}\n\n\tif (typeof(encoding) === 'number') {\n\t\tencoding = null;\n\t\ttimeout = encoding;\n\t}\n\n\tif (typeof(encoding) !== 'string')\n\t\tencoding = ENCODING;\n\n\tvar proxy, type = 0;\n\tvar method = 'GET';\n\tvar options = { callback: callback, resolve: false, length: 0, evt: new EventEmitter2(), timeout: timeout || 60000, post: false, encoding: encoding };\n\n\tif (headers)\n\t\theaders = exports.extend({}, headers);\n\telse\n\t\theaders = {};\n\n\tif (data === null)\n\t\tdata = '';\n\n\tif (flags instanceof Array) {\n\t\tfor (var i = 0, length = flags.length; i < length; i++) {\n\n\t\t\t// timeout\n\t\t\tif (flags[i] > 0) {\n\t\t\t\toptions.timeout = flags[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === '<') {\n\t\t\t\t// max length is not supported\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (flags[i][0] === 'p' && flags[i][4] === 'y') {\n\t\t\t\tproxy = parseProxy(flags[i].substring(6));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (flags[i].toLowerCase()) {\n\n\t\t\t\tcase 'utf8':\n\t\t\t\tcase 'ascii':\n\t\t\t\tcase 'base64':\n\t\t\t\tcase 'binary':\n\t\t\t\tcase 'hex':\n\t\t\t\t\toptions.encoding = flags[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'xhr':\n\t\t\t\t\theaders['X-Requested-With'] = 'XMLHttpRequest';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'plain':\n\t\t\t\t\theaders['Content-Type'] = 'text/plain';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\theaders['Content-Type'] = 'text/html';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'json':\n\t\t\t\t\theaders['Content-Type'] = 'application/json';\n\t\t\t\t\ttype = 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'xml':\n\t\t\t\t\theaders['Content-Type'] = 'text/xml';\n\t\t\t\t\ttype = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'get':\n\t\t\t\tcase 'head':\n\t\t\t\tcase 'options':\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'upload':\n\t\t\t\t\theaders['Content-Type'] = 'multipart/form-data';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post':\n\t\t\t\tcase 'patch':\n\t\t\t\tcase 'delete':\n\t\t\t\tcase 'put':\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tif (!headers['Content-Type'])\n\t\t\t\t\t\theaders['Content-Type'] = 'application/x-www-form-urlencoded';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'dnscache':\n\t\t\t\t\toptions.resolve = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'keepalive':\n\t\t\t\t\toptions.keepalive = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Fallback for methods (e.g. CalDAV)\n\t\t\t\t\tmethod = flags[i].charCodeAt(0) > 96 ? flags[i].toUpperCase() : flags[i];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!method)\n\t\tmethod = 'GET';\n\n\toptions.post = !NOBODY[method];\n\n\tif (typeof(data) !== 'string')\n\t\tdata = type === 1 ? JSON.stringify(data) : Qs.stringify(data);\n\telse if (data[0] === '?')\n\t\tdata = data.substring(1);\n\n\tif (!options.post) {\n\t\tif (data.length && url.indexOf('?') === -1)\n\t\t\turl += '?' + data;\n\t\tdata = '';\n\t}\n\n\tif (cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tif (builder)\n\t\t\theaders['Cookie'] = builder;\n\t}\n\n\tvar uri = Url.parse(url);\n\turi.method = method;\n\t// uri.agent = false;\n\turi.headers = headers;\n\toptions.uri = uri;\n\toptions.param = param;\n\n\tif (options.resolve && (uri.hostname === 'localhost' || uri.hostname.charCodeAt(0) < 64))\n\t\toptions.resolve = null;\n\n\tif (data.length) {\n\t\toptions.data = Buffer.from(data, ENCODING);\n\t\theaders['Content-Length'] = options.data.length;\n\t}\n\n\tif (CONF.default_proxy && !proxy && !PROXYBLACKLIST[uri.hostname])\n\t\tproxy = parseProxy(CONF.default_proxy);\n\n\toptions.proxy = proxy;\n\n\tif (proxy && uri.protocol === 'https:') {\n\t\tproxy.tls = true;\n\t\turi.agent = new ProxyAgent(options);\n\t\turi.agent.request = Http.request;\n\t\turi.agent.createSocket = createSecureSocket;\n\t\turi.agent.defaultPort = 443;\n\t}\n\n\tif (options.keepalive && !options.proxy && uri.protocol !== 'https:')\n\t\turi.agent = KeepAlive;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tif (proxy)\n\t\tdownload_call(uri, options);\n\telse if (options.resolve)\n\t\texports.resolve(url, download_resolve, options);\n\telse\n\t\tdownload_call(uri, options);\n\n\treturn options.evt;\n};\n\nfunction download_resolve(err, uri, options) {\n\tif (!err)\n\t\toptions.uri.host = uri.host;\n\tdownload_call(options.uri, options);\n}\n\nfunction download_call(uri, options) {\n\n\tvar opt;\n\toptions.length = 0;\n\n\tif (options.proxy && !options.proxy.tls) {\n\t\topt = PROXYOPTIONSHTTP;\n\t\topt.port = options.proxy.port;\n\t\topt.host = options.proxy.hostname;\n\t\topt.path = uri.href;\n\t\topt.headers = uri.headers;\n\t\topt.method = uri.method;\n\t\tif (options.proxy._auth)\n\t\t\topt.headers['Proxy-Authorization'] = options.proxy._auth;\n\t} else\n\t\topt = uri;\n\n\tvar connection = uri.protocol === 'https:' ? Https : Http;\n\tvar req = options.post ? connection.request(opt, download_response) : connection.get(opt, download_response);\n\n\treq.$options = options;\n\treq.$uri = uri;\n\n\tif (!options.callback) {\n\t\treq.on('error', NOOP);\n\t\treturn;\n\t}\n\n\treq.on('error', download_process_error);\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.timeoutid = setTimeout(download_process_timeout, options.timeout);\n\treq.on('response', download_assign_res);\n\treq.end(options.data);\n}\n\nfunction download_assign_res(response) {\n\tresponse.req = this;\n\tvar options = this.$options;\n\toptions.length = +response.headers['content-length'] || 0;\n\toptions.evt && options.evt.$events.begin && options.evt.emit('begin', options.length);\n}\n\nfunction download_process_timeout(req) {\n\tvar options = req.$options;\n\tif (options.callback) {\n\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\toptions.timeoutid = null;\n\t\treq.abort();\n\t\toptions.callback(new Error(exports.httpStatus(408)), null, null, null, null, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t\toptions.canceled = true;\n\t}\n}\n\nfunction download_process_error(err) {\n\tvar options = this.$options;\n\tif (options.callback && !options.done) {\n\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\toptions.timeoutid = null;\n\t\toptions.callback(err, null, null, null, null, options.param);\n\t\toptions.callback = null;\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t\toptions.canceled = true;\n\t}\n}\n\nfunction download_response(res) {\n\n\tvar options = this.$options;\n\tvar uri = this.$uri;\n\n\tres._bufferlength = 0;\n\n\t// We have redirect\n\tif (res.statusCode === 301 || res.statusCode === 302) {\n\n\t\tif (options.redirect > 3) {\n\t\t\toptions.canceled = true;\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.callback && options.callback(new Error('Too many redirects.'), null, null, null, null, options.param);\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\toptions.redirect++;\n\n\t\tvar loc = res.headers['location'];\n\t\tvar proto = loc.substring(0, 6);\n\n\t\tif (proto !== 'http:/' && proto !== 'https:')\n\t\t\tloc = uri.protocol + '//' + uri.hostname + loc;\n\n\t\tvar tmp = Url.parse(loc);\n\t\ttmp.headers = uri.headers;\n\t\t// tmp.agent = false;\n\t\ttmp.method = uri.method;\n\t\tres.req.removeAllListeners();\n\t\tres.req = null;\n\n\t\tif (options.proxy && tmp.protocol === 'https:') {\n\t\t\t// TLS?\n\t\t\toptions.uri = tmp;\n\t\t\tdownload_call(options, request_call);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!options.resolve) {\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn download_call(tmp, options);\n\t\t}\n\n\t\texports.resolve(loc, function(err, u) {\n\t\t\tif (!err)\n\t\t\t\ttmp.host = u.host;\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\tdownload_call(tmp, options);\n\t\t});\n\n\t\treturn;\n\t}\n\n\tres.on('data', download_process_data);\n\tres.on('end', download_process_end);\n\n\tres.resume();\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.callback && options.callback(null, res, res.statusCode, res.headers, uri.host, options.param);\n}\n\nexports.$$download = function(url, flags, data, cookies, headers, encoding, timeout) {\n\treturn function(callback) {\n\t\texports.download(url, flags, data, callback, cookies, headers, encoding, timeout);\n\t};\n};\n\nfunction download_process_end() {\n\n\tvar res = this;\n\tvar self = this;\n\tvar options = self.req.$options;\n\tvar uri = self.req.$uri;\n\n\tif (!options.canceled) {\n\t\tvar str = self._buffer ? self._buffer.toString(options.encoding) : '';\n\t\tself._buffer = undefined;\n\t\toptions.evt && options.evt.$events.end && options.evt.emit('end', str, self.statusCode, self.headers, uri.host);\n\t}\n\n\tif (options.evt) {\n\t\toptions.evt.removeAllListeners();\n\t\toptions.evt = null;\n\t}\n\n\tres.req && res.req.removeAllListeners();\n\tres.removeAllListeners();\n}\n\nfunction download_process_data(chunk) {\n\tvar self = this;\n\tvar options = self.req.$options;\n\tif (!options.canceled) {\n\t\tself._bufferlength += chunk.length;\n\t\tif (options.evt) {\n\t\t\toptions.evt.$events.data && options.evt.emit('data', chunk, options.length ? (self._bufferlength / options.length) * 100 : 0);\n\t\t\toptions.evt.$events.progress && options.evt.emit('progress', options.length ? (self._bufferlength / options.length) * 100 : 0);\n\t\t}\n\t}\n}\n\n/**\n * Upload a stream through HTTP\n * @param {String} name Filename with extension.\n * @param {Stream} stream Stream.\n * @param {String} url A valid URL address.\n * @param {Function} callback Callback.\n * @param {Object} headers Custom headers (optional).\n * @param {String} method HTTP method (optional, default POST).\n * @param {Number} timeout Request timeout, default: 60000 (1 minute)\n */\nexports.send = function(name, stream, url, callback, cookies, headers, method, timeout) {\n\n\tOBSOLETE('U.send()', 'Use U.upload() instead of U.send().');\n\n\tif (typeof(stream) === 'string')\n\t\tstream = Fs.createReadStream(stream, STREAM_READONLY);\n\n\tvar BOUNDARY = '----totaljs' + Math.random().toString(16).substring(2);\n\tvar h = {};\n\n\tif (headers)\n\t\texports.extend(h, headers);\n\n\tif (cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tif (builder)\n\t\t\th['Cookie'] = builder;\n\t}\n\n\tname = exports.getName(name);\n\n\th['Cache-Control'] = 'max-age=0';\n\th['Content-Type'] = 'multipart/form-data; boundary=' + BOUNDARY;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tvar e = new EventEmitter2();\n\tvar uri = Url.parse(url);\n\tvar options = { protocol: uri.protocol, auth: uri.auth, method: method || 'POST', hostname: uri.hostname, port: uri.port, path: uri.path, agent: false, headers: h };\n\tvar responseLength = 0;\n\n\tvar response = function(res) {\n\n\t\tres.body = Buffer.alloc(0);\n\t\tres._bufferlength = 0;\n\n\t\tres.on('data', function(chunk) {\n\t\t\tCONCAT[0] = res.body;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tres.body = Buffer.concat(CONCAT);\n\t\t\tres._bufferlength += chunk.length;\n\t\t\te.$events.data && e.emit('data', chunk, responseLength ? (res._bufferlength / responseLength) * 100 : 0);\n\t\t});\n\n\t\tres.on('end', function() {\n\t\t\tvar self = this;\n\t\t\te.$events.end && e.emit('end', self.statusCode, self.headers);\n\t\t\te.removeAllListeners();\n\t\t\te = null;\n\t\t\tcallback && callback(null, self.body.toString('utf8'), self.statusCode, self.headers, uri.host);\n\t\t\tself.body = null;\n\t\t});\n\t};\n\n\tvar connection = options.protocol === 'https:' ? Https : Http;\n\tvar req = connection.request(options, response);\n\n\treq.on('response', function(response) {\n\t\tresponseLength = +response.headers['content-length'] || 0;\n\t\te.$events.begin && e.emit('begin', responseLength);\n\t});\n\n\treq.setTimeout(timeout || 60000, function() {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t\te.removeAllListeners();\n\t\te = null;\n\t\tcallback && callback(new Error(exports.httpStatus(408)), '', 408, undefined, uri.host);\n\t});\n\n\treq.on('error', function(err) {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t\te.removeAllListeners();\n\t\te = null;\n\t\tcallback && callback(err, '', 0, undefined, uri.host);\n\t});\n\n\treq.on('close', function() {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t});\n\n\tvar header = NEWLINE + NEWLINE + '--' + BOUNDARY + NEWLINE + 'Content-Disposition: form-data; name=\"File\"; filename=\"' + name + '\"' + NEWLINE + 'Content-Type: ' + exports.getContentType(exports.getExtension(name)) + NEWLINE + NEWLINE;\n\treq.write(header);\n\n\t// Is Buffer\n\tif (stream.length) {\n\t\treq.write(stream);\n\t\treq.end(NEWLINE + NEWLINE + '--' + BOUNDARY + '--');\n\t\treturn e;\n\t}\n\n\tstream.on('end', () => req.end(NEWLINE + NEWLINE + '--' + BOUNDARY + '--'));\n\tstream.pipe(req, STREAM_END);\n\treturn e;\n};\n\nexports.$$send = function(name, stream, url, cookies, headers, method, timeout) {\n\treturn function(callback) {\n\t\texports.send(name, stream, url, callback, cookies, headers, method, timeout);\n\t};\n};\n\nexports.upload = function(files, url, callback, cookies, headers, method, timeout) {\n\n\tvar BOUNDARY = '----totaljs' + Math.random().toString(16).substring(2);\n\tvar h = {};\n\n\theaders && exports.extend_headers2(h, headers);\n\n\tif (cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + cookies[m];\n\t\tbuilder && (h['Cookie'] = builder);\n\t}\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\th['Cache-Control'] = 'max-age=0';\n\th['Content-Type'] = 'multipart/form-data; boundary=' + BOUNDARY;\n\n\tvar e = new EventEmitter2();\n\tvar uri = Url.parse(url);\n\tvar options = { protocol: uri.protocol, auth: uri.auth, method: method || 'POST', hostname: uri.hostname, port: uri.port, path: uri.path, agent: false, headers: h };\n\tvar responseLength = 0;\n\tvar timeoutid;\n\tvar done = false;\n\n\tvar response = function(res) {\n\n\t\tres.body = Buffer.alloc(0);\n\t\tres._bufferlength = 0;\n\n\t\tres.on('data', function(chunk) {\n\t\t\tif (!done) {\n\t\t\t\tCONCAT[0] = res.body;\n\t\t\t\tCONCAT[1] = chunk;\n\t\t\t\tres.body = Buffer.concat(CONCAT);\n\t\t\t\tres._bufferlength += chunk.length;\n\t\t\t\te.$events.data && e.emit('data', chunk, responseLength ? (res._bufferlength / responseLength) * 100 : 0);\n\t\t\t}\n\t\t});\n\n\t\tres.on('end', function() {\n\t\t\tif (!done) {\n\t\t\t\tvar self = this;\n\t\t\t\te.$events.end && e.emit('end', self.statusCode, self.headers);\n\t\t\t\te.removeAllListeners();\n\t\t\t\tcallback && callback(null, self.body.toString('utf8'), self.statusCode, self.headers, uri.host);\n\t\t\t\ttimeoutid && clearTimeout(timeoutid);\n\t\t\t\tself.body = null;\n\t\t\t\te = null;\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t});\n\t};\n\n\tvar connection = options.protocol === 'https:' ? Https : Http;\n\tvar req = connection.request(options, response);\n\n\treq.on('response', function(response) {\n\t\tresponseLength = +response.headers['content-length'] || 0;\n\t\te.$events.begin && e.emit('begin', responseLength);\n\t});\n\n\tvar timeoutcallback = function() {\n\t\tif (!done) {\n\t\t\treq.removeAllListeners();\n\t\t\te.removeAllListeners();\n\t\t\tcallback && callback(new Error(exports.httpStatus(408)), '', 408, undefined, uri.host);\n\t\t\ttimeoutid && clearTimeout(timeoutid);\n\t\t\treq = null;\n\t\t\te = null;\n\t\t\tdone = true;\n\t\t}\n\t};\n\n\tif (timeout)\n\t\ttimeoutid = setTimeout(timeoutcallback, timeout);\n\n\treq.setTimeout(timeout || 60000, timeoutcallback);\n\n\treq.on('error', function(err) {\n\t\tdone = true;\n\t\treq.removeAllListeners();\n\t\te.removeAllListeners();\n\t\tcallback && callback(err, '', 0, undefined, uri.host);\n\t\ttimeoutid && clearTimeout(timeoutid);\n\t\treq = null;\n\t\te = null;\n\t});\n\n\treq.on('close', function() {\n\t\treq.removeAllListeners();\n\t\treq = null;\n\t});\n\n\tvar header = NEWLINE + NEWLINE + '--' + BOUNDARY + NEWLINE + 'Content-Disposition: form-data; name=\"{0}\"; filename=\"{1}\"' + NEWLINE + 'Content-Type: {2}' + NEWLINE + NEWLINE;\n\n\tfiles.wait(function(item, next) {\n\n\t\t// item.name;\n\t\t// item.filename;\n\t\t// item.stream (optional) or item.buffer (optional)\n\n\t\treq.write(header.format(item.name, U.getName(item.filename), exports.getContentType(exports.getExtension(item.filename))));\n\n\t\tif (item.buffer) {\n\t\t\treq.write(item.buffer);\n\t\t\treturn next();\n\t\t}\n\n\t\t!item.stream && (item.stream = Fs.createReadStream(item.filename));\n\t\titem.stream.pipe(req, STREAM_END);\n\t\titem.stream.on('error', next);\n\t\titem.stream.on('end', next);\n\n\t}, () => req.end(NEWLINE + NEWLINE + '--' + BOUNDARY + '--'));\n\treturn e;\n};\n\nexports.$$upload = function(files, url, cookies, headers, method, timeout) {\n\treturn function(callback) {\n\t\texports.upload(files, url, callback, cookies, headers, method, timeout);\n\t};\n};\n\n/**\n * Trim string properties\n * @param {Object} obj\n * @return {Object}\n */\nexports.trim = function(obj, clean) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type === 'string') {\n\t\tobj = obj.trim();\n\t\treturn clean && !obj ? undefined : obj;\n\t}\n\n\tif (obj instanceof Array) {\n\t\tfor (var i = 0, length = obj.length; i < length; i++) {\n\n\t\t\tvar item = obj[i];\n\t\t\ttype = typeof(item);\n\n\t\t\tif (type === 'object') {\n\t\t\t\texports.trim(item, clean);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type !== 'string')\n\t\t\t\tcontinue;\n\n\t\t\tobj[i] = item.trim();\n\t\t\tif (clean && !obj[i])\n\t\t\t\tobj[i] = undefined;\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\tif (type !== 'object')\n\t\treturn obj;\n\n\tvar keys = Object.keys(obj);\n\tfor (var i = 0, length = keys.length; i < length; i++) {\n\t\tvar val = obj[keys[i]];\n\t\tvar type = typeof(val);\n\t\tif (type === 'object') {\n\t\t\texports.trim(val, clean);\n\t\t\tcontinue;\n\t\t} else if (type !== 'string')\n\t\t\tcontinue;\n\t\tobj[keys[i]] = val.trim();\n\t\tif (clean && !obj[keys[i]])\n\t\t\tobj[keys[i]] = undefined;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Noop function\n * @return {Function} Empty function.\n */\nexports.noop = global.noop = global.NOOP = function() {};\n\n/**\n * Read HTTP status\n * @param  {Number} code HTTP code status.\n * @param  {Boolean} addCode Add code number to HTTP status.\n * @return {String}\n */\nexports.httpStatus = function(code, addCode) {\n\tif (addCode === undefined)\n\t\taddCode = true;\n\treturn (addCode ? code + ': ' : '') + Http.STATUS_CODES[code];\n};\n\n/**\n * Extend object\n * @param {Object} target Target object.\n * @param {Object} source Source object.\n * @param {Boolean} rewrite Rewrite exists values (optional, default true).\n * @return {Object} Modified object.\n */\nexports.extend = function(target, source, rewrite) {\n\n\tif (!target || !source)\n\t\treturn target;\n\n\tif (typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tif (rewrite === undefined)\n\t\trewrite = true;\n\n\tvar keys = Object.keys(source);\n\tvar i = keys.length;\n\n\twhile (i--) {\n\t\tvar key = keys[i];\n\t\tif (rewrite || target[key] === undefined)\n\t\t\ttarget[key] = exports.clone(source[key]);\n\t}\n\n\treturn target;\n};\n\nexports.extend_headers = function(first, second) {\n\tvar keys = Object.keys(first);\n\tvar headers = {};\n\n\tvar i = keys.length;\n\twhile (i--)\n\t\theaders[keys[i]] = first[keys[i]];\n\n\tkeys = Object.keys(second);\n\ti = keys.length;\n\n\twhile (i--)\n\t\theaders[keys[i]] = second[keys[i]];\n\n\treturn headers;\n};\n\nexports.extend_headers2 = function(first, second) {\n\tvar keys = Object.keys(second);\n\tvar i = keys.length;\n\twhile (i--)\n\t\tfirst[keys[i]] = second[keys[i]];\n\treturn first;\n};\n\n/**\n * Clones object\n * @param {Object} obj\n * @param {Object} skip Optional, can be only object e.g. { name: true, age: true }.\n * @param {Boolean} skipFunctions It doesn't clone functions, optional --> default false.\n * @return {Object}\n */\nglobal.CLONE = exports.clone = function(obj, skip, skipFunctions) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type !== 'object' || obj instanceof Date || obj instanceof Error)\n\t\treturn obj;\n\n\tvar length;\n\tvar o;\n\n\tif (obj instanceof Array) {\n\n\t\tlength = obj.length;\n\t\to = new Array(length);\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\ttype = typeof(obj[i]);\n\t\t\tif (type !== 'object' || obj[i] instanceof Date || obj[i] instanceof Error) {\n\t\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\t\tcontinue;\n\t\t\t\to[i] = obj[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\to[i] = exports.clone(obj[i], skip, skipFunctions);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\to = {};\n\n\tfor (var m in obj) {\n\n\t\tif (skip && skip[m])\n\t\t\tcontinue;\n\n\t\tvar val = obj[m];\n\n\t\tif (val instanceof Buffer) {\n\t\t\tvar copy = Buffer.alloc(val.length);\n\t\t\tval.copy(copy);\n\t\t\to[m] = copy;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar type = typeof(val);\n\t\tif (type !== 'object' || val instanceof Date || val instanceof Error) {\n\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\tcontinue;\n\t\t\to[m] = val;\n\t\t\tcontinue;\n\t\t}\n\n\t\to[m] = exports.clone(obj[m], skip, skipFunctions);\n\t}\n\n\treturn o;\n};\n\n/**\n * Copy values from object to object\n * @param {Object} source Object source\n * @param {Object} target Object target (optional)\n * @return {Object} Modified object.\n */\nexports.copy = function(source, target) {\n\n\tif (target === undefined)\n\t\treturn exports.extend({}, source, true);\n\n\tif (!target || !source || typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tvar keys = Object.keys(source);\n\tvar i = keys.length;\n\n\twhile (i--) {\n\t\tvar key = keys[i];\n\t\ttarget[key] !== undefined && (target[key] = exports.clone(source[key]));\n\t}\n\n\treturn target;\n};\n\n/**\n * Reduce an object\n * @param {Object} source Source object.\n * @param {String Array or Object} prop Other properties than these ones will be removed.\n * @param {Boolean} reverse Reverse reducing (prop will be removed), default: false.\n * @return {Object}\n */\nexports.reduce = function(source, prop, reverse) {\n\n\tif (!(prop instanceof Array)) {\n\t\tif (typeof(prop) === 'object')\n\t\t\treturn exports.reduce(source, Object.keys(prop), reverse);\n\t}\n\n\tif (source instanceof Array) {\n\t\tvar arr = [];\n\t\tfor (var i = 0, length = source.length; i < length; i++)\n\t\t\tarr.push(exports.reduce(source[i], prop, reverse));\n\t\treturn arr;\n\t}\n\n\tvar output = {};\n\n\tvar keys = Object.keys(source);\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar o = keys[i];\n\t\tif (reverse) {\n\t\t\tif (prop.indexOf(o) === -1)\n\t\t\t\toutput[o] = source[o];\n\t\t} else {\n\t\t\tif (prop.indexOf(o) !== -1)\n\t\t\t\toutput[o] = source[o];\n\t\t}\n\t}\n\n\treturn output;\n};\n\n/**\n * Assign value to an object according to a path\n * @param {Object} obj Source object.\n * @param {String} path Path to the update.\n * @param {Object or Function} fn Value or Function to update.\n * @return {Object}\n */\n// @TODO: deprecated, it will be removed in v4\nexports.assign = function(obj, path, fn) {\n\n\tif (obj == null)\n\t\treturn obj;\n\n\tvar arr = path.split('.');\n\tvar model = obj[arr[0]];\n\n\tfor (var i = 1; i < arr.length - 1; i++)\n\t\tmodel = model[arr[i]];\n\n\tmodel[arr[arr.length - 1]] = typeof (fn) === 'function' ? fn(model[arr[arr.length - 1]]) : fn;\n\treturn obj;\n};\n\n/**\n * Checks if is relative url\n * @param {String} url\n * @return {Boolean}\n */\nexports.isRelative = function(url) {\n\treturn !(url.substring(0, 2) === '//' || url.indexOf('http://') !== -1 || url.indexOf('https://') !== -1);\n};\n\n/**\n * Streamer method\n * @param {String/Buffer} beg\n * @param {String/Buffer} end\n * @param {Function(value, index)} callback\n */\nexports.streamer = function(beg, end, callback, skip, stream, raw) {\n\n\tif (typeof(end) === 'function') {\n\t\tstream = skip;\n\t\tskip = callback;\n\t\tcallback = end;\n\t\tend = undefined;\n\t}\n\n\tif (typeof(skip) === 'object') {\n\t\tstream = skip;\n\t\tskip = 0;\n\t}\n\n\tvar indexer = 0;\n\tvar buffer = Buffer.alloc(0);\n\tvar canceled = false;\n\tvar fn;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\n\tif (!(beg instanceof Buffer))\n\t\tbeg = Buffer.from(beg, 'utf8');\n\n\tif (end && !(end instanceof Buffer))\n\t\tend = Buffer.from(end, 'utf8');\n\n\tif (!end) {\n\t\tvar length = beg.length;\n\t\tfn = function(chunk) {\n\n\t\t\tif (!chunk || canceled)\n\t\t\t\treturn;\n\n\t\t\tCONCAT[0] = buffer;\n\t\t\tCONCAT[1] = chunk;\n\n\t\t\tvar f = 0;\n\n\t\t\tif (buffer.length) {\n\t\t\t\tf = buffer.length - beg.length;\n\t\t\t\tif (f < 0)\n\t\t\t\t\tf = 0;\n\t\t\t}\n\n\t\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\t\tvar index = buffer.indexOf(beg, f);\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\twhile (index !== -1) {\n\n\t\t\t\tif (skip)\n\t\t\t\t\tskip--;\n\t\t\t\telse {\n\t\t\t\t\tif (callback(raw ? buffer.slice(0, index + length) : buffer.toString('utf8', 0, index + length), indexer++) === false)\n\t\t\t\t\t\tcanceled = true;\n\t\t\t\t}\n\n\t\t\t\tif (canceled)\n\t\t\t\t\treturn;\n\n\t\t\t\tbuffer = buffer.slice(index + length);\n\t\t\t\tindex = buffer.indexOf(beg);\n\t\t\t\tif (index === -1)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\n\t\tstream && stream.on('end', () => fn(beg));\n\t\treturn fn;\n\t}\n\n\tvar blength = beg.length;\n\tvar elength = end.length;\n\tvar bi = -1;\n\tvar ei = -1;\n\tvar is = false;\n\n\tfn = function(chunk) {\n\n\t\tif (!chunk || canceled)\n\t\t\treturn;\n\n\t\tCONCAT[0] = buffer;\n\t\tCONCAT[1] = chunk;\n\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\tif (!is) {\n\t\t\tvar f = CONCAT[0].length - beg.length;\n\t\t\tif (f < 0)\n\t\t\t\tf = 0;\n\t\t\tbi = buffer.indexOf(beg, f);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t}\n\n\t\tif (is) {\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\n\t\twhile (bi !== -1) {\n\n\t\t\tif (skip)\n\t\t\t\tskip--;\n\t\t\telse {\n\t\t\t\tif (callback(raw ? buffer.slice(bi, ei + elength) : buffer.toString('utf8', bi, ei + elength), indexer++) === false)\n\t\t\t\t\tcanceled = true;\n\t\t\t}\n\n\t\t\tif (canceled)\n\t\t\t\treturn;\n\n\t\t\tbuffer = buffer.slice(ei + elength);\n\t\t\tis = false;\n\t\t\tbi = buffer.indexOf(beg);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\t};\n\n\tstream && stream.on('end', () => fn(end));\n\treturn fn;\n};\n\nexports.streamer2 = function(beg, end, callback, skip, stream) {\n\treturn exports.streamer(beg, end, callback, skip, stream, true);\n};\n\n/**\n * HTML encode string\n * @param {String} str\n * @return {String}\n */\nexports.encode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.encode();\n};\n\n/**\n * HTML decode string\n * @param {String} str\n * @return {String}\n */\nexports.decode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.decode();\n};\n\n/**\n * Checks if URL contains file extension.\n * @param {String} url\n * @return {Boolean}\n */\nexports.isStaticFile = function(url) {\n\treturn regexpSTATIC.test(url);\n};\n\n/**\n * Converts Value to number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseInt = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseInt(def);\n};\n\nexports.parseBool = exports.parseBoolean = function(obj, def) {\n\tif (obj == null)\n\t\treturn def === undefined ? false : def;\n\tvar type = typeof(obj);\n\treturn type === 'boolean' ? obj : type === 'number' ? obj > 0 : (type !== 'string' ? obj.toString() : obj).parseBool(def);\n};\n\n/**\n * Converts Value to float number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseFloat = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseFloat(def);\n};\n\n/**\n * Check if the object is Array.\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isArray = function(obj) {\n\treturn obj instanceof Array;\n};\n\n/**\n * Check if the object is RegExp\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isRegExp = function(obj) {\n\treturn obj && typeof(obj.test) === 'function' ? true : false;\n};\n\n/**\n * Check if the object is Date\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isDate = function(obj) {\n\treturn obj instanceof Date && !isNaN(obj.getTime()) ? true : false;\n};\n\n/**\n * Check if the object is Date\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isError = function(obj) {\n\treturn (obj && obj.stack) ? true : false;\n};\n\n/**\n * Check if the value is object\n * @param {Object} value\n * @return {Boolean}\n */\nexports.isObject = function(value) {\n\ttry {\n\t\treturn (value && Object.getPrototypeOf(value) === Object.prototype) ? true : false;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n/**\n * Get ContentType from file extension.\n * @param {String} ext File extension.\n * @return {String}\n */\nexports.getContentType = function(ext) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\treturn CONTENTTYPES[ext] || 'application/octet-stream';\n};\n\n/**\n * Get extension from filename\n * @param {String} filename\n * @return {String}\n */\nexports.getExtension = function(filename, raw) {\n\tvar end = filename.length;\n\tfor (var i = filename.length - 1; i > 0; i--) {\n\t\tvar c = filename[i];\n\t\tif (c === ' ' || c === '?')\n\t\t\tend = i;\n\t\telse if (c === '.') {\n\t\t\tc = filename.substring(i + 1, end);\n\t\t\treturn raw ? c : c.toLowerCase();\n\t\t}\n\t\telse if (c === '/' || c === '\\\\')\n\t\t\treturn '';\n\t}\n\treturn '';\n};\n\n/**\n * Get base name from path\n * @param {String} path\n * @return {String}\n */\nexports.getName = function(path) {\n\tvar l = path.length - 1;\n\tvar c = path[l];\n\tif (c === '/' || c === '\\\\')\n\t\tpath = path.substring(0, l);\n\tvar index = path.lastIndexOf('/');\n\tif (index !== -1)\n\t\treturn path.substring(index + 1);\n\tindex = path.lastIndexOf('\\\\');\n\treturn index === -1 ? path : path.substring(index + 1);\n};\n\n/**\n * Add a new content type to content types\n * @param {String} ext File extension.\n * @param {String} type Content type (example: application/json).\n */\nexports.setContentType = function(ext, type) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\n\tif (ext.length > 8) {\n\t\tvar tmp = regexpSTATIC.toString().replace(/,\\d+\\}/, ',' + ext.length + '}').substring(1);\n\t\tregexpSTATIC = new RegExp(tmp.substring(0, tmp.length - 1));\n\t}\n\n\tCONTENTTYPES[ext] = type;\n\treturn true;\n};\n\nexports.path = function(path, delimiter) {\n\tif (!path)\n\t\tpath = '';\n\tdelimiter = delimiter || '/';\n\treturn path[path.length - 1] === delimiter ? path : path + delimiter;\n};\n\nexports.join = function() {\n\tvar path = [''];\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar current = arguments[i];\n\t\tif (!current)\n\t\t\tcontinue;\n\t\tif (current[0] === '/')\n\t\t\tcurrent = current.substring(1);\n\t\tvar l = current.length - 1;\n\t\tif (current[l] === '/')\n\t\t\tcurrent = current.substring(0, l);\n\t\tpath.push(current);\n\t}\n\n\tpath = path.join('/');\n\treturn !isWindows ? path : path.indexOf(':') > -1 ? path.substring(1) : path;\n};\n\n/**\n * Prepares Windows path to UNIX like format\n * @internal\n * @param {String} path\n * @return {String}\n */\nexports.$normalize = function(path) {\n\treturn isWindows ? path.replace(regexpPATH, '/') : path;\n};\n\nexports.random = function(max, min) {\n\tmax = (max || 100000);\n\tmin = (min || 0);\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nfunction rnd() {\n\treturn Math.floor(Math.random() * 65536).toString(36);\n}\n\nglobal.GUID = exports.GUID = function(max) {\n\tmax = max || 40;\n\tvar str = '';\n\tfor (var i = 0; i < (max / 3) + 1; i++)\n\t\tstr += rnd();\n\treturn str.substring(0, max);\n};\n\nfunction validate_builder_default(name, value, entity) {\n\n\tvar type = typeof(value);\n\n\tif (entity.type === 12)\n\t\treturn value != null && type === 'object' && !(value instanceof Array);\n\n\tif (entity.type === 11)\n\t\treturn type === 'number';\n\n\t// Enum + KeyValue + Custom (8+9+10)\n\tif (entity.type > 7)\n\t\treturn value !== undefined;\n\n\tswitch (entity.subtype) {\n\t\tcase 'uid':\n\t\t\treturn value.isUID();\n\t\tcase 'zip':\n\t\t\treturn value.isZIP();\n\t\tcase 'email':\n\t\t\treturn value.isEmail();\n\t\tcase 'json':\n\t\t\treturn value.isJSON();\n\t\tcase 'url':\n\t\t\treturn value.isURL();\n\t\tcase 'phone':\n\t\t\treturn value.isPhone();\n\t\tcase 'base64':\n\t\t\treturn value.isBase64();\n\t}\n\n\tif (type === 'number')\n\t\treturn value > 0;\n\n\tif (type === 'string' || value instanceof Array)\n\t\treturn value.length > 0;\n\n\tif (type === 'boolean')\n\t\treturn value === true;\n\n\tif (value == null)\n\t\treturn false;\n\n\tif (value instanceof Date)\n\t\treturn value.toString()[0] !== 'I'; // Invalid Date\n\n\treturn true;\n}\n\nexports.validate_builder = function(model, error, schema, path, index, fields, pluspath) {\n\n\tvar prepare = schema.onValidate || F.onValidate || NOOP;\n\tvar current = path ? path + '.' : '';\n\tvar properties = model && model.$$keys ? model.$$keys : schema.properties;\n\tvar result;\n\n\tif (!pluspath)\n\t\tpluspath = '';\n\n\tif (model == null)\n\t\tmodel = {};\n\n\tfor (var i = 0; i < properties.length; i++) {\n\n\t\tvar name = properties[i];\n\n\t\tif (fields && fields.indexOf(name) === -1)\n\t\t\tcontinue;\n\n\t\tvar TYPE = schema.schema[name];\n\t\tif (!TYPE)\n\t\t\tcontinue;\n\n\t\tif (TYPE.can && !TYPE.can(model, model.$$workflow || EMPTYOBJECT))\n\t\t\tcontinue;\n\n\t\tvar value = model[name];\n\t\tvar type = typeof(value);\n\t\tvar prefix = schema.resourcePrefix ? (schema.resourcePrefix + name) : name;\n\n\t\tif (value === undefined) {\n\t\t\terror.push(pluspath + name, '@', current + name, undefined, prefix);\n\t\t\tcontinue;\n\t\t} else if (type === 'function')\n\t\t\tvalue = model[name]();\n\n\t\tif (TYPE.isArray) {\n\t\t\tif (TYPE.type === 7 && value instanceof Array && value.length) {\n\t\t\t\tvar nestedschema = schema.parent.collection[TYPE.raw] || GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema) {\n\t\t\t\t\tfor (var j = 0, jl = value.length; j < jl; j++)\n\t\t\t\t\t\texports.validate_builder(value[j], error, nestedschema, current + name + '[' + j + ']', j, undefined, pluspath);\n\t\t\t\t} else\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\n\t\t\t\tif (!TYPE.required)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : prepare(name, value, current + name, model, schema.name, TYPE);\n\t\t\t\tif (result == null) {\n\t\t\t\t\tresult = value instanceof Array ? value.length > 0 : false;\n\t\t\t\t\tif (result == null || result === true)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, '@', current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean') {\n\t\t\t\t\t!result && error.push(pluspath + name, '@', current + name, index, prefix);\n\t\t\t\t} else if (result.isValid === false)\n\t\t\t\t\terror.push(pluspath + name, result.error, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (TYPE.type === 7) {\n\n\t\t\tif (!value && !TYPE.required)\n\t\t\t\tcontinue;\n\n\t\t\t// Another schema\n\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : null;\n\n\t\t\tif (result == null) {\n\t\t\t\tvar nestedschema = schema.parent.collection[TYPE.raw] || GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema)\n\t\t\t\t\texports.validate_builder(value, error, nestedschema, current + name, undefined, undefined, pluspath);\n\t\t\t\telse\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, '@', current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean') {\n\t\t\t\t\t!result && error.push(pluspath + name, '@', current + name, index, prefix);\n\t\t\t\t} else if (result.isValid === false)\n\t\t\t\t\terror.push(pluspath + name, result.error, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!TYPE.required)\n\t\t\tcontinue;\n\n\t\tresult = TYPE.validate ? TYPE.validate(value, model) : prepare(name, value, current + name, model, schema.name, TYPE);\n\t\tif (result == null) {\n\t\t\tresult = validate_builder_default(name, value, TYPE);\n\t\t\tif (result == null || result === true)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttype = typeof(result);\n\n\t\tif (type === 'string') {\n\t\t\tif (result[0] === '@')\n\t\t\t\terror.push(pluspath + name, '@', current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\telse\n\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t} else if (type === 'boolean') {\n\t\t\t!result && error.push(pluspath + name, '@', current + name, index, prefix);\n\t\t} else if (result.isValid === false)\n\t\t\terror.push(pluspath + name, result.error, current + name, index, prefix);\n\t}\n\n\treturn error;\n};\n\n/**\n * Combine paths\n * @return {String}\n */\nexports.combine = function() {\n\n\tvar p = F.directory;\n\n\tfor (var i = 0, length = arguments.length; i < length; i++) {\n\t\tvar v = arguments[i];\n\t\tif (!v)\n\t\t\tcontinue;\n\t\tif (v[0] === '/')\n\t\t\tv = v.substring(1);\n\n\t\tif (v[0] === '~')\n\t\t\tp = v.substring(1);\n\t\telse\n\t\t\tp += (p[p.length - 1] !== '/' ? '/' : '') + v;\n\t}\n\treturn exports.$normalize(p);\n};\n\n/**\n * Remove diacritics\n * @param {String} str\n * @return {String}\n */\nexports.removeDiacritics = function(str) {\n\treturn str.replace(regexpDiacritics, c => DIACRITICSMAP[c] || c);\n};\n\n/**\n * Simple XML parser\n * @param {String} xml\n * @return {Object}\n */\nexports.parseXML = function(xml, replace) {\n\n\tvar beg = -1;\n\tvar end = 0;\n\tvar tmp = 0;\n\tvar current = [];\n\tvar obj = {};\n\tvar from = -1;\n\n\twhile (true) {\n\t\tbeg = xml.indexOf('<![CDATA[', beg);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = xml.indexOf(']]>', beg + 9);\n\t\txml = xml.substring(0, beg) + xml.substring(beg + 9, end).trim().encode() + xml.substring(end + 3);\n\t\tbeg += 9;\n\t}\n\n\tbeg = -1;\n\tend = 0;\n\n\twhile (true) {\n\n\t\tbeg = xml.indexOf('<', beg + 1);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\n\t\tend = xml.indexOf('>', beg + 1);\n\t\tif (end === -1)\n\t\t\tbreak;\n\n\t\tvar el = xml.substring(beg, end + 1);\n\t\tvar c = el[1];\n\n\t\tif (c === '?' || c === '/') {\n\n\t\t\tvar o = current.pop();\n\n\t\t\tif (from === -1 || o !== el.substring(2, el.length - 1))\n\t\t\t\tcontinue;\n\n\t\t\tvar path = (current.length ? current.join('.') + '.' : '') + o;\n\t\t\tvar value = xml.substring(from, beg).decode();\n\n\t\t\tif (replace)\n\t\t\t\tpath = path.replace(REG_XMLKEY, '_');\n\n\t\t\tif (obj[path] === undefined)\n\t\t\t\tobj[path] = value;\n\t\t\telse if (obj[path] instanceof Array)\n\t\t\t\tobj[path].push(value);\n\t\t\telse\n\t\t\t\tobj[path] = [obj[path], value];\n\n\t\t\tfrom = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = el.indexOf(' ');\n\t\tvar hasAttributes = true;\n\n\t\tif (tmp === -1) {\n\t\t\ttmp = el.length - 1;\n\t\t\thasAttributes = false;\n\t\t}\n\n\t\tfrom = beg + el.length;\n\n\t\tvar isSingle = el[el.length - 2] === '/';\n\t\tvar name = el.substring(1, tmp);\n\n\t\tif (!isSingle)\n\t\t\tcurrent.push(name);\n\n\t\tif (!hasAttributes)\n\t\t\tcontinue;\n\n\t\tvar match = el.match(regexpXML);\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tvar attr = {};\n\t\tvar length = match.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar index = match[i].indexOf('\"');\n\t\t\tattr[match[i].substring(0, index - 1)] = match[i].substring(index + 1, match[i].length - 1).decode();\n\t\t}\n\n\t\tvar k = current.join('.') + (isSingle ? '.' + name : '') + '[]';\n\t\tif (replace)\n\t\t\tk = k.replace(REG_XMLKEY, '_');\n\t\tobj[k] = attr;\n\t}\n\n\treturn obj;\n};\n\nexports.parseJSON = function(value, date) {\n\ttry {\n\t\treturn JSON.parse(value, date ? jsonparser : undefined);\n\t} catch(e) {\n\t}\n};\n\nexports.parseQuery = function(value) {\n\treturn F.onParseQuery(value);\n};\n\nfunction jsonparser(key, value) {\n\treturn typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value;\n}\n\n/**\n * Get WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param {Number} code\n * @param {Buffer or String} message\n * @param {Hexa} type\n * @return {Buffer}\n */\nexports.getWebSocketFrame = function(code, message, type, compress) {\n\tvar messageBuffer = getWebSocketFrameMessageBytes(code, message);\n\tvar lengthBuffer = getWebSocketFrameLengthBytes(messageBuffer.length);\n\tvar frameBuffer = Buffer.alloc(1 + lengthBuffer.length + messageBuffer.length);\n\tframeBuffer[0] = 0x80 | type;\n\tcompress && (frameBuffer[0] |= 0x40);\n\tlengthBuffer.copy(frameBuffer, 1, 0, lengthBuffer.length);\n\tmessageBuffer.copy(frameBuffer, lengthBuffer.length + 1, 0, messageBuffer.length);\n\treturn frameBuffer;\n};\n\n/**\n * Get bytes of WebSocket frame message\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} code\n * @param  {Buffer or String} message\n * @return {Buffer}\n */\nfunction getWebSocketFrameMessageBytes(code, message) {\n\n\tvar index = code ? 2 : 0;\n\tvar binary = message instanceof Int8Array || message instanceof Buffer;\n\tvar length = message.length;\n\n\tvar messageBuffer = Buffer.alloc(length + index);\n\n\tfor (var i = 0; i < length; i++) {\n\t\tif (binary)\n\t\t\tmessageBuffer[i + index] = message[i];\n\t\telse\n\t\t\tmessageBuffer[i + index] = message.charCodeAt(i);\n\t}\n\n\tif (code) {\n\t\tmessageBuffer[0] = code >> 8;\n\t\tmessageBuffer[1] = code;\n\t}\n\n\treturn messageBuffer;\n}\n\n/**\n * Get length of WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} length\n * @return {Number}\n */\nfunction getWebSocketFrameLengthBytes(length) {\n\tvar lengthBuffer = null;\n\n\tif (length <= 125) {\n\t\tlengthBuffer = Buffer.alloc(1);\n\t\tlengthBuffer[0] = length;\n\t\treturn lengthBuffer;\n\t}\n\n\tif (length <= 65535) {\n\t\tlengthBuffer = Buffer.alloc(3);\n\t\tlengthBuffer[0] = 126;\n\t\tlengthBuffer[1] = (length >> 8) & 255;\n\t\tlengthBuffer[2] = (length) & 255;\n\t\treturn lengthBuffer;\n\t}\n\n\tlengthBuffer = Buffer.alloc(9);\n\n\tlengthBuffer[0] = 127;\n\tlengthBuffer[1] = 0x00;\n\tlengthBuffer[2] = 0x00;\n\tlengthBuffer[3] = 0x00;\n\tlengthBuffer[4] = 0x00;\n\tlengthBuffer[5] = (length >> 24) & 255;\n\tlengthBuffer[6] = (length >> 16) & 255;\n\tlengthBuffer[7] = (length >> 8) & 255;\n\tlengthBuffer[8] = (length) & 255;\n\n\treturn lengthBuffer;\n}\n\n/**\n * GPS distance in KM\n * @param  {Number} lat1\n * @param  {Number} lon1\n * @param  {Number} lat2\n * @param  {Number} lon2\n * @return {Number}\n */\nexports.distance = function(lat1, lon1, lat2, lon2) {\n\tvar R = 6371;\n\tvar dLat = (lat2 - lat1).toRad();\n\tvar dLon = (lon2 - lon1).toRad();\n\tvar a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1.toRad()) * Math.cos(lat2.toRad()) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn (R * c).floor(3);\n};\n\nfunction ls(path, callback, advanced, filter) {\n\tvar filelist = new FileList();\n\tvar tmp;\n\n\tfilelist.advanced = advanced;\n\tfilelist.onComplete = callback;\n\n\tif (typeof(filter) === 'string') {\n\t\ttmp = filter.toLowerCase();\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : filename.toLowerCase().indexOf(tmp) !== -1;\n\t\t};\n\t} else if (exports.isRegExp(filter)) {\n\t\ttmp = filter;\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : tmp.test(filename);\n\t\t};\n\t} else\n\t\tfilelist.onFilter = filter || null;\n\n\tfilelist.walk(path);\n}\n\n/**\n * Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename, isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls = function(path, callback, filter) {\n\tls(path, callback, false, filter);\n};\n\n/**\n * Advanced Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename ,isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls2 = function(path, callback, filter) {\n\tls(path, callback, true, filter);\n};\n\nDP.setTimeZone = function(timezone) {\n\tvar dt = this.toLocaleString('en-US', { timeZone: timezone, hour12: false, dateStyle: 'short', timeStyle: 'short' });\n\treturn new Date(Date.parse(dt));\n};\n\nDP.add = function(type, value) {\n\n\tvar self = this;\n\n\tif (type.constructor === Number)\n\t\treturn new Date(self.getTime() + (type - type % 1));\n\n\tif (value === undefined) {\n\t\tvar arr = type.split(' ');\n\t\ttype = arr[1];\n\t\tvalue = exports.parseInt(arr[0]);\n\t}\n\n\tvar dt = new Date(self.getTime());\n\n\tswitch(type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'sec':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\tdt.setUTCSeconds(dt.getUTCSeconds() + value);\n\t\t\treturn dt;\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'min':\n\t\tcase 'minutes':\n\t\t\tdt.setUTCMinutes(dt.getUTCMinutes() + value);\n\t\t\treturn dt;\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\tdt.setUTCHours(dt.getUTCHours() + value);\n\t\t\treturn dt;\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + value);\n\t\t\treturn dt;\n\t\tcase 'w':\n\t\tcase 'ww':\n\t\tcase 'week':\n\t\tcase 'weeks':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + (value * 7));\n\t\t\treturn dt;\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\tdt.setUTCMonth(dt.getUTCMonth() + value);\n\t\t\treturn dt;\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\tdt.setUTCFullYear(dt.getUTCFullYear() + value);\n\t\t\treturn dt;\n\t}\n\treturn dt;\n};\n\n/**\n * Date difference\n * @param  {Date/Number/String} date Optional.\n * @param  {String} type Date type: minutes, seconds, hours, days, months, years\n * @return {Number}\n */\nDP.diff = function(date, type) {\n\n\tif (arguments.length === 1) {\n\t\ttype = date;\n\t\tdate = Date.now();\n\t} else {\n\t\tvar to = typeof(date);\n\t\tif (to === 'string')\n\t\t\tdate = Date.parse(date);\n\t\telse if (exports.isDate(date))\n\t\t\tdate = date.getTime();\n\t}\n\n\tvar r = this.getTime() - date;\n\n\tswitch (type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\treturn Math.ceil(r / 1000);\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'minutes':\n\t\t\treturn Math.ceil((r / 1000) / 60);\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\treturn Math.ceil(((r / 1000) / 60) / 60);\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / 24);\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28));\n\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28 * 12));\n\t}\n\n\treturn NaN;\n};\n\nDP.extend = function(date) {\n\tvar dt = new Date(this);\n\tvar match = date.match(regexpDATE);\n\n\tif (!match)\n\t\treturn dt;\n\n\tfor (var i = 0, length = match.length; i < length; i++) {\n\t\tvar m = match[i];\n\t\tvar arr, tmp;\n\n\t\tif (m.indexOf(':') !== -1) {\n\n\t\t\tarr = m.split(':');\n\t\t\ttmp = +arr[0];\n\t\t\ttmp >= 0 && dt.setUTCHours(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMinutes(tmp);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCSeconds(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('-') !== -1) {\n\t\t\tarr = m.split('-');\n\n\t\t\ttmp = +arr[0];\n\t\t\ttmp && dt.setUTCFullYear(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCDate(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('.') !== -1) {\n\t\t\tarr = m.split('.');\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\t!isNaN(tmp) && dt.setUTCFullYear(tmp);\n\t\t\t}\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\t!isNaN(tmp) && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\ttmp = +arr[0];\n\t\t\t!isNaN(tmp) && dt.setUTCDate(tmp);\n\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn dt;\n};\n\n/**\n * Compare dates\n * @param {Date} date\n * @return {Number} Results: -1 = current date is earlier than @date, 0 = current date is same as @date, 1 = current date is later than @date\n */\nDP.compare = function(date) {\n\n\tvar self = this;\n\tvar r = self.getTime() - date.getTime();\n\n\tif (r === 0)\n\t\treturn 0;\n\n\tif (r < 0)\n\t\treturn -1;\n\n\treturn 1;\n};\n\n/**\n * Compare two dates\n * @param {String or Date} d1\n * @param {String or Date} d2\n * @return {Number} Results: -1 = @d1 is earlier than @d2, 0 = @d1 is same as @d2, 1 = @d1 is later than @d2\n */\nDate.compare = function(d1, d2) {\n\n\tif (typeof(d1) === 'string')\n\t\td1 = d1.parseDate();\n\n\tif (typeof(d2) === 'string')\n\t\td2 = d2.parseDate();\n\n\treturn d1.compare(d2);\n};\n\n/**\n * Format datetime\n * @param {String} format\n * @return {String}\n */\nDP.format = function(format, resource) {\n\n\tif (!format)\n\t\treturn this.getUTCFullYear() + '-' + (this.getUTCMonth() + 1).toString().padLeft(2, '0') + '-' + this.getUTCDate().toString().padLeft(2, '0') + 'T' + this.getUTCHours().toString().padLeft(2, '0') + ':' + this.getUTCMinutes().toString().padLeft(2, '0') + ':' + this.getUTCSeconds().toString().padLeft(2, '0') + '.' + this.getUTCMilliseconds().toString().padLeft(3, '0') + 'Z';\n\n\tif (datetimeformat[format])\n\t\treturn datetimeformat[format](this, resource);\n\n\tvar key = format;\n\tvar half = false;\n\n\tif (format && format[0] === '!') {\n\t\thalf = true;\n\t\tformat = format.substring(1);\n\t}\n\n\tvar beg = '\\'+';\n\tvar end = '+\\'';\n\tvar before = [];\n\n\tvar ismm = false;\n\tvar isdd = false;\n\tvar isww = false;\n\n\tformat = format.replace(regexpDATEFORMAT, function(key) {\n\t\tswitch (key) {\n\t\t\tcase 'yyyy':\n\t\t\tcase 'YYYY':\n\t\t\t\treturn beg + 'd.getFullYear()' + end;\n\t\t\tcase 'yy':\n\t\t\tcase 'YY':\n\t\t\t\treturn beg + 'd.getFullYear().toString().substring(2)' + end;\n\t\t\tcase 'MMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(F.resource(resource, mm) || mm).substring(0, 3)' + end;\n\t\t\tcase 'MMMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(F.resource(resource, mm) || mm)' + end;\n\t\t\tcase 'MM':\n\t\t\t\treturn beg + '(d.getMonth() + 1).toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'M':\n\t\t\t\treturn beg + '(d.getMonth() + 1)' + end;\n\t\t\tcase 'ddd':\n\t\t\tcase 'DDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(F.resource(resource, dd) || dd).substring(0, 2).toUpperCase()' + end;\n\t\t\tcase 'dddd':\n\t\t\tcase 'DDDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(F.resource(resource, dd) || dd)' + end;\n\t\t\tcase 'dd':\n\t\t\tcase 'DD':\n\t\t\t\treturn beg + 'd.getDate().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\treturn beg + 'd.getDate()' + end;\n\t\t\tcase 'HH':\n\t\t\tcase 'hh':\n\t\t\t\treturn beg + (half ? 'framework_utils.$pmam(d.getHours()).toString().padLeft(2, \\'0\\')' : 'd.getHours().toString().padLeft(2, \\'0\\')') + end;\n\t\t\tcase 'H':\n\t\t\tcase 'h':\n\t\t\t\treturn beg + (half ? 'framework_utils(d.getHours())' : 'd.getHours()') + end;\n\t\t\tcase 'mm':\n\t\t\t\treturn beg + 'd.getMinutes().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'm':\n\t\t\t\treturn beg + 'd.getMinutes()' + end;\n\t\t\tcase 'ss':\n\t\t\t\treturn beg + 'd.getSeconds().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 's':\n\t\t\t\treturn beg + 'd.getSeconds()' + end;\n\t\t\tcase 'w':\n\t\t\tcase 'ww':\n\t\t\t\tisww = true;\n\t\t\t\treturn beg + (key === 'ww' ? 'ww.toString().padLeft(2, \\'0\\')' : 'ww') + end;\n\t\t\tcase 'a':\n\t\t\t\tvar b = \"'PM':'AM'\";\n\t\t\t\treturn beg + '(d.getHours() >= 12 ? ' + b + ')' + end;\n\t\t}\n\t});\n\n\tismm && before.push('var mm = framework_utils.MONTHS[d.getMonth()];');\n\tisdd && before.push('var dd = framework_utils.DAYS[d.getDay()];');\n\tisww && before.push('var ww = new Date(+d);ww.setHours(0,0,0,0);ww.setDate(ww.getDate()+3-(ww.getDay()+6)%7);var ww1=new Date(ww.getFullYear(),0,4);ww=1+Math.round(((ww.getTime()-ww1.getTime())/86400000-3+(ww1.getDay()+6)%7)/7);');\n\n\tdatetimeformat[key] = new Function('d', 'resource', before.join('\\n') + 'return \\'' + format + '\\';');\n\treturn datetimeformat[key](this, resource);\n};\n\nexports.$pmam = function(value) {\n\treturn value >= 12 ? value - 12 : value;\n};\n\nDP.toUTC = function(ticks) {\n\tvar dt = this.getTime() + this.getTimezoneOffset() * 60000;\n\treturn ticks ? dt : new Date(dt);\n};\n\n// +v2.2.0 parses JSON dates as dates and this is the fallback for backward compatibility\nDP.parseDate = function() {\n\treturn this;\n};\n\nSP.isJSONDate = function() {\n\tvar l = this.length - 1;\n\treturn l > 22 && l < 30 && this[l] === 'Z' && this[10] === 'T' && this[4] === '-' && this[13] === ':' && this[16] === ':';\n};\n\nSP.ROOT = function(noremap) {\n\n\tvar str = this;\n\n\tstr = str.replace(REG_NOREMAP, function() {\n\t\tnoremap = true;\n\t\treturn '';\n\t}).replace(REG_ROOT, $urlmaker);\n\n\tif (!noremap && CONF.default_root)\n\t\tstr = str.replace(REG_REMAP, $urlremap).replace(REG_AJAX, $urlajax);\n\n\treturn str;\n};\n\nfunction $urlremap(text) {\n\tvar pos = text[0] === 'h' ? 6 : 5;\n\treturn REG_URLEXT.test(text) ? text : ((text[0] === 'h' ? 'href' : 'src') + '=\"' + CONF.default_root + (text[pos] === '/' ? text.substring(pos + 1) : text));\n}\n\nfunction $urlajax(text) {\n\treturn text.substring(0, text.length - 1) + CONF.default_root;\n}\n\nfunction $urlmaker(text) {\n\tvar c = text[4];\n\treturn CONF.default_root ? CONF.default_root : (c || '');\n}\n\nif (!SP.trim) {\n\tSP.trim = function() {\n\t\treturn this.replace(regexpTRIM, '');\n\t};\n}\n\nif (!SP.replaceAt) {\n\tSP.replaceAt = function(index, character) {\n\t\treturn this.substr(0, index) + character + this.substr(index + character.length);\n\t};\n}\n\n/**\n * Checks if the string starts with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.startsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.startsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(0, length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr(ignoreCase, length);\n\telse\n\t\ttmp = self.substring(0, length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\n/**\n * Checks if the string ends with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.endsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.endsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(self.length - length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr((self.length - ignoreCase) - length, length);\n\telse\n\t\ttmp = self.substring(self.length - length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\nSP.replacer = function(find, text) {\n\tvar self = this;\n\tvar beg = self.indexOf(find);\n\treturn beg === -1 ? self : (self.substring(0, beg) + text + self.substring(beg + find.length));\n};\n\n/**\n * Hash string\n * @param {String} type Hash type.\n * @param {String} salt Optional, salt.\n * @return {String}\n */\nSP.hash = function(type, salt) {\n\tvar str = salt ? this + salt : this;\n\tswitch (type) {\n\t\tcase 'md5':\n\t\t\treturn str.md5();\n\t\tcase 'sha1':\n\t\t\treturn str.sha1();\n\t\tcase 'sha256':\n\t\t\treturn str.sha256();\n\t\tcase 'sha512':\n\t\t\treturn str.sha512();\n\t\tcase 'crc32':\n\t\t\treturn str.crc32();\n\t\tcase 'crc32unsigned':\n\t\t\treturn str.crc32(true);\n\t\tdefault:\n\t\t\tvar val = string_hash(str);\n\t\t\treturn type === true ? val >>> 0 : val;\n\t}\n};\n\nglobal.HASH = function(value, type) {\n\treturn value.hash(type ? type : true);\n};\n\nSP.makeid = function() {\n\treturn this.hash(true).toString(16);\n};\n\nSP.crc32 = function(unsigned) {\n\tvar crc = -1;\n\tfor (var i = 0, length = this.length; i < length; i++)\n\t\tcrc = (crc >>> 8) ^ CRC32TABLE[(crc ^ this.charCodeAt(i)) & 0xFF];\n\tvar val = crc ^ (-1);\n\treturn unsigned ? val >>> 0 : val;\n};\n\nfunction string_hash(s, convert) {\n\tvar hash = 0;\n\tif (s.length === 0)\n\t\treturn convert ? '' : hash;\n\tfor (var i = 0, l = s.length; i < l; i++) {\n\t\tvar char = s.charCodeAt(i);\n\t\thash = ((hash << 5) - hash) + char;\n\t\thash |= 0;\n\t}\n\treturn hash;\n}\n\nSP.count = function(text) {\n\tvar index = 0;\n\tvar count = 0;\n\tdo {\n\t\tindex = this.indexOf(text, index + text.length);\n\t\tif (index > 0)\n\t\t\tcount++;\n\t} while (index > 0);\n\treturn count;\n};\n\nSP.parseXML = function(replace) {\n\treturn F.onParseXML(this, replace);\n};\n\nSP.parseJSON = function(date) {\n\treturn exports.parseJSON(this, date);\n};\n\nSP.parseQuery = function() {\n\treturn exports.parseQuery(this);\n};\n\nSP.parseUA = function(structured) {\n\n\tvar ua = this;\n\n\tif (!ua)\n\t\treturn '';\n\n\tvar arr = ua.match(regexpUA);\n\tvar uid = '';\n\n\tif (arr) {\n\n\t\tvar data = {};\n\n\t\tfor (var i = 0; i < arr.length; i++) {\n\n\t\t\tif (arr[i] === 'like' && arr[i + 1] === 'Gecko') {\n\t\t\t\ti += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar key = arr[i].toLowerCase();\n\t\t\tif (key === 'like')\n\t\t\t\tbreak;\n\n\t\t\tswitch (key) {\n\t\t\t\tcase 'linux':\n\t\t\t\tcase 'windows':\n\t\t\t\tcase 'mac':\n\t\t\t\tcase 'symbian':\n\t\t\t\tcase 'symbos':\n\t\t\t\tcase 'tizen':\n\t\t\t\tcase 'android':\n\t\t\t\t\tdata[arr[i]] = 2;\n\t\t\t\t\tif (key === 'tizen' || key === 'android')\n\t\t\t\t\t\tdata.Mobile = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'webos':\n\t\t\t\t\tdata.WebOS = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'media':\n\t\t\t\tcase 'center':\n\t\t\t\tcase 'tv':\n\t\t\t\tcase 'smarttv':\n\t\t\t\tcase 'smart':\n\t\t\t\t\tdata[arr[i]] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'iemobile':\n\t\t\t\tcase 'mobile':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ipad':\n\t\t\t\tcase 'ipod':\n\t\t\t\tcase 'iphone':\n\t\t\t\t\tdata.iOS = 2;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tif (key === 'ipad')\n\t\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'phone':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tizenbrowser':\n\t\t\t\tcase 'blackberry':\n\t\t\t\tcase 'mini':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'samsungbrowser':\n\t\t\t\tcase 'chrome':\n\t\t\t\tcase 'firefox':\n\t\t\t\tcase 'msie':\n\t\t\t\tcase 'opera':\n\t\t\t\tcase 'brave':\n\t\t\t\tcase 'vivaldi':\n\t\t\t\tcase 'outlook':\n\t\t\t\tcase 'safari':\n\t\t\t\tcase 'mail':\n\t\t\t\tcase 'edge':\n\t\t\t\tcase 'maxthon':\n\t\t\t\tcase 'electron':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'trident':\n\t\t\t\t\tdata.MSIE = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'opr':\n\t\t\t\t\tdata.Opera = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tablet':\n\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (data.MSIE) {\n\t\t\tdata.IE = 1;\n\t\t\tdelete data.MSIE;\n\t\t}\n\n\t\tif (data.WebOS || data.Android)\n\t\t\tdelete data.Linux;\n\n\t\tif (data.IEMobile) {\n\t\t\tif (data.Android)\n\t\t\t\tdelete data.Android;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t} else if (data.MSIE) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Edge) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Opera || data.Electron) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Chrome) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.SamsungBrowser)\n\t\t\t\tdelete data.SamsungBrowser;\n\t\t} else if (data.SamsungBrowser) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t}\n\n\t\tif (structured) {\n\t\t\tvar keys = Object.keys(data);\n\t\t\tvar output = { os: '', browser: '', device: 'desktop' };\n\n\t\t\tif (data.Tablet)\n\t\t\t\toutput.device = 'tablet';\n\t\t\telse if (data.Mobile)\n\t\t\t\toutput.device = 'mobile';\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar val = data[keys[i]];\n\t\t\t\tswitch (val) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\toutput.browser += (output.browser ? ' ' : '') + keys[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\toutput.os += (output.os ? ' ' : '') + keys[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\toutput.device = 'tv';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\tuid = Object.keys(data).join(' ');\n\t}\n\n\treturn uid;\n};\n\nSP.parseCSV = function(delimiter) {\n\n\tif (!delimiter)\n\t\tdelimiter = ',';\n\n\tvar delimiterstring = '\"';\n\tvar t = this;\n\tvar scope;\n\tvar tmp = {};\n\tvar index = 1;\n\tvar data = [];\n\tvar current = 'a';\n\n\tfor (var i = 0; i < t.length; i++) {\n\t\tvar c = t[i];\n\n\t\tif (!scope) {\n\n\t\t\tif (c === '\\n' || c === '\\r') {\n\t\t\t\ttmp && data.push(tmp);\n\t\t\t\tindex = 1;\n\t\t\t\tcurrent = 'a';\n\t\t\t\ttmp = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c === delimiter) {\n\t\t\t\tcurrent = String.fromCharCode(97 + index);\n\t\t\t\tindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (c === delimiterstring) {\n\t\t\t// Check escaped quotes\n\t\t\tif (scope && t[i + 1] === delimiterstring) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tscope = c === scope ? '' : c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!tmp)\n\t\t\ttmp = {};\n\n\t\tif (tmp[current])\n\t\t\ttmp[current] += c;\n\t\telse\n\t\t\ttmp[current] = c;\n\t}\n\n\ttmp && data.push(tmp);\n\treturn data;\n};\n\nSP.parseTerminal = function(fields, fn, skip, take) {\n\n\tvar lines = this.split('\\n');\n\n\tif (typeof(fields) === 'function') {\n\t\ttake = skip;\n\t\tskip = fn;\n\t\tfn = fields;\n\t\tparseTerminal2(lines, fn, skip, take);\n\t\treturn this;\n\t}\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tvar headers = [];\n\tvar indexer = 0;\n\tvar line = lines[0];\n\n\tif (!line) {\n\t\tline = lines[1];\n\t\tskip++;\n\t}\n\n\tif (!line) {\n\t\tline = lines[2];\n\t\tskip++;\n\t}\n\n\tif (!line)\n\t\treturn this;\n\n\tvar fieldslength = fields.length;\n\tvar tmp;\n\n\tfor (var i = 0, length = fieldslength; i < length; i++) {\n\t\tvar field = fields[i];\n\n\t\tvar beg = -1;\n\t\tvar end = -1;\n\t\tvar type = typeof(field);\n\n\t\tif (type === 'object' && field.test) {\n\t\t\ttmp = line.match(field);\n\t\t\tif (tmp) {\n\t\t\t\tbeg = tmp.index;\n\t\t\t\tend = beg + tmp.toString().length;\n\t\t\t} else {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t}\n\t\t} else if (type === 'string') {\n\t\t\ttmp = line.indexOf(field);\n\t\t\tif (tmp === -1) {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t} else {\n\t\t\t\tbeg = tmp;\n\t\t\t\tend = line.indexOf(' ', beg + field.length);\n\t\t\t}\n\t\t}\n\n\t\theaders.push({ beg: beg, end: end });\n\t}\n\n\tfor (var i = skip + 1, length = skip + 1 + take; i < length; i++) {\n\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\n\t\tvar arr = [];\n\t\tvar is = false;\n\t\tvar beg;\n\n\t\tfor (var j = 0; j < fieldslength; j++) {\n\t\t\tvar header = headers[j];\n\t\t\tif (header.beg !== -1) {\n\t\t\t\tis = true;\n\t\t\t\tbeg = 0;\n\n\t\t\t\tfor (var k = header.beg; k > -1; k--) {\n\t\t\t\t\tif (line[k] === ' ') {\n\t\t\t\t\t\tbeg = k + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tarr.push(line.substring(beg, header.end === -1 ? undefined : header.end).trim());\n\t\t\t} else\n\t\t\t\tarr.push('');\n\t\t}\n\n\t\tis && fn(arr, indexer++, length, i);\n\t}\n\n\treturn this;\n};\n\nfunction parseTerminal2(lines, fn, skip, take) {\n\tvar indexer = 0;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tfor (var i = skip, length = skip + take; i < length; i++) {\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\t\tvar m = line.match(regexpTERMINAL);\n\t\tm && fn(m, indexer++, length, i);\n\t}\n}\n\nfunction parseDateFormat(format, val) {\n\n\tvar tmp = [];\n\tvar tmpformat = [];\n\tvar prev = '';\n\tvar prevformat = '';\n\tvar allowed = { y: 1, Y: 1, M: 1, m: 1, d: 1, D: 1, H: 1, s: 1, a: 1, w: 1 };\n\n\tfor (var i = 0; i < format.length; i++) {\n\n\t\tvar c = format[i];\n\n\t\tif (!allowed[c])\n\t\t\tcontinue;\n\n\t\tif (prev !== c) {\n\t\t\tprevformat && tmpformat.push(prevformat);\n\t\t\tprevformat = c;\n\t\t\tprev = c;\n\t\t} else\n\t\t\tprevformat += c;\n\t}\n\n\tprev = '';\n\n\tfor (var i = 0; i < val.length; i++) {\n\t\tvar code = val.charCodeAt(i);\n\t\tif (code >= 48 && code <= 57)\n\t\t\tprev += val[i];\n\t}\n\n\tprevformat && tmpformat.push(prevformat);\n\n\tvar f = 0;\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar l = tmpformat[i].length;\n\t\ttmp.push(prev.substring(f, f + l));\n\t\tf += l;\n\t}\n\n\tvar dt = {};\n\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar type = tmpformat[i];\n\t\tif (tmp[i])\n\t\t\tdt[type[0]] = +tmp[i];\n\t}\n\n\tvar h = dt.h || dt.H;\n\n\tif (h != null) {\n\t\tvar ampm = val.match(REG_TIME);\n\t\tif (ampm && ampm[0].toLowerCase() === 'pm')\n\t\t\th += 12;\n\t}\n\n\treturn new Date((dt.y || dt.Y) || 0, (dt.M || 1) - 1, dt.d || dt.D || 0, h || 0, dt.m || 0, dt.s || 0);\n}\n\nSP.parseDate = function(format) {\n\n\tif (format)\n\t\treturn parseDateFormat(format, this);\n\n\tvar self = this.trim();\n\tvar lc = self.charCodeAt(self.length - 1);\n\n\t// Classic date\n\tif (lc === 41)\n\t\treturn new Date(self);\n\n\t// JSON format\n\tif (lc === 90)\n\t\treturn new Date(Date.parse(self));\n\n\tvar arr = self.indexOf(' ') === -1 ? self.split('T') : self.split(' ');\n\tvar index = arr[0].indexOf(':');\n\tvar length = arr[0].length;\n\n\tif (index !== -1) {\n\t\tvar tmp = arr[1];\n\t\tarr[1] = arr[0];\n\t\tarr[0] = tmp;\n\t}\n\n\tif (arr[0] === undefined)\n\t\tarr[0] = '';\n\n\tvar noTime = arr[1] === undefined ? true : arr[1].length === 0;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = arr[0].charCodeAt(i);\n\t\tif (c === 45 || c === 46 || (c > 47 && c < 58))\n\t\t\tcontinue;\n\t\tif (noTime)\n\t\t\treturn new Date(self);\n\t}\n\n\tif (arr[1] === undefined)\n\t\tarr[1] = '00:00:00';\n\n\tvar firstDay = arr[0].indexOf('-') === -1;\n\n\tvar date = (arr[0] || '').split(firstDay ? '.' : '-');\n\tvar time = (arr[1] || '').split(':');\n\tvar parsed = [];\n\n\tif (date.length < 4 && time.length < 2)\n\t\treturn new Date(self);\n\n\tindex = (time[2] || '').indexOf('.');\n\n\t// milliseconds\n\tif (index !== -1) {\n\t\ttime[3] = time[2].substring(index + 1);\n\t\ttime[2] = time[2].substring(0, index);\n\t} else\n\t\ttime[3] = '0';\n\n\tparsed.push(+date[firstDay ? 2 : 0]); // year\n\tparsed.push(+date[1]); // month\n\tparsed.push(+date[firstDay ? 0 : 2]); // day\n\tparsed.push(+time[0]); // hours\n\tparsed.push(+time[1]); // minutes\n\tparsed.push(+time[2]); // seconds\n\tparsed.push(+time[3]); // miliseconds\n\n\tvar def = new Date();\n\n\tfor (var i = 0, length = parsed.length; i < length; i++) {\n\t\tif (isNaN(parsed[i]))\n\t\t\tparsed[i] = 0;\n\n\t\tvar value = parsed[i];\n\t\tif (value !== 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getFullYear();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getMonth() + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getDate();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn new Date(parsed[0], parsed[1] - 1, parsed[2], parsed[3], parsed[4] - NOW.getTimezoneOffset(), parsed[5]);\n};\n\nSP.parseDateExpiration = function() {\n\tvar self = this;\n\n\tvar arr = self.split(' ');\n\tvar dt = new Date();\n\tvar length = arr.length;\n\n\tfor (var i = 0; i < length; i += 2) {\n\t\tvar num = arr[i].parseInt();\n\t\tif (num === 0)\n\t\t\tcontinue;\n\t\tvar type = arr[i + 1];\n\t\tif (type)\n\t\t\tdt = dt.add(type, num);\n\t}\n\n\treturn dt;\n};\n\nSP.contains = function(value, mustAll) {\n\tvar str = this;\n\n\tif (typeof(value) === 'string')\n\t\treturn str.indexOf(value, typeof(mustAll) === 'number' ? mustAll : 0) !== -1;\n\n\tfor (var i = 0, length = value.length; i < length; i++) {\n\t\tvar exists = str.indexOf(value[i]) !== -1;\n\t\tif (mustAll) {\n\t\t\tif (!exists)\n\t\t\t\treturn false;\n\t\t} else if (exists)\n\t\t\treturn true;\n\t}\n\n\treturn mustAll;\n};\n\n/**\n * Same functionality as as String.localeCompare() but this method works with latin.\n * @param {String} value\n * @return {Number}\n */\nSP.localeCompare2 = function(value) {\n\treturn COMPARER(this, value);\n};\n\nvar configurereplace = function(text) {\n\tvar val = CONF[text.substring(1, text.length - 1)];\n\treturn val == null ? '' : val;\n};\n\nSP.env = function() {\n\treturn this.replace(regexpCONFIGURE, configurereplace);\n};\n\n/**\n * Parse configuration from a string\n * @param {Object} def\n * @onerr {Function} error handling\n * @return {Object}\n */\nSP.parseConfig = function(def, onerr) {\n\n\tif (typeof(def) === 'function') {\n\t\tonerr = def;\n\t\tdef = null;\n\t}\n\n\tvar arr = this.split('\\n');\n\tvar length = arr.length;\n\tvar obj = def ? exports.extend({}, def) : {};\n\tvar subtype;\n\tvar name;\n\tvar index;\n\tvar value;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar str = arr[i];\n\t\tif (!str || str[0] === '#' || str.substring(0, 2) === '//')\n\t\t\tcontinue;\n\n\t\tindex = str.indexOf(':');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tname = str.substring(0, index).trim();\n\t\tvalue = str.substring(index + 2).trim();\n\n\t\tindex = name.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tsubtype = name.substring(index + 1, name.indexOf(')')).trim().toLowerCase();\n\t\t\tname = name.substring(0, index).trim();\n\t\t} else\n\t\t\tsubtype = '';\n\n\t\tswitch (subtype) {\n\t\t\tcase 'string':\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'float':\n\t\t\tcase 'double':\n\t\t\tcase 'currency':\n\t\t\t\tobj[name] = value.isNumber(true) ? value.parseFloat2() : value.parseInt2();\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\tcase 'bool':\n\t\t\t\tobj[name] = (/true|on|1|enabled/i).test(value);\n\t\t\t\tbreak;\n\t\t\tcase 'config':\n\t\t\t\tobj[name] = CONF[value];\n\t\t\t\tbreak;\n\t\t\tcase 'eval':\n\t\t\tcase 'object':\n\t\t\tcase 'array':\n\t\t\t\ttry {\n\t\t\t\t\tobj[name] = new Function('return ' + value)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onerr)\n\t\t\t\t\t\tonerr(e, arr[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new Error('A value of \"{0}\" can\\'t be converted to \"{1}\": '.format(name, subtype) + e.toString());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\tobj[name] = value.parseJSON(true);\n\t\t\t\tbreak;\n\t\t\tcase 'env':\n\t\t\tcase 'environment':\n\t\t\t\tobj[name] = process.env[value];\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\tcase 'time':\n\t\t\tcase 'datetime':\n\t\t\t\tobj[name] = value.parseDate();\n\t\t\t\tbreak;\n\t\t\tcase 'random':\n\t\t\t\tobj[name] = GUID((value || '0').parseInt() || 10);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nSP.format = function() {\n\tvar arg = arguments;\n\treturn this.replace(regexpSTRINGFORMAT, function(text) {\n\t\tvar value = arg[+text.substring(1, text.length - 1)];\n\t\treturn value == null ? '' : value;\n\t});\n};\n\nSP.encryptUID = function(key) {\n\treturn exports.encryptUID(this, key);\n};\n\nSP.decryptUID = function(key) {\n\treturn exports.decryptUID(this, key);\n};\n\nSP.encode = function() {\n\tvar output = '';\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i];\n\t\tswitch (c) {\n\t\t\tcase '<':\n\t\t\t\toutput += '&lt;';\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\toutput += '&gt;';\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\toutput += '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\t\toutput += '&apos;';\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\toutput += '&amp;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutput += c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn output;\n};\n\nSP.decode = function() {\n\treturn this.replace(regexpDECODE, function(s) {\n\t\tif (s.charAt(1) !== '#')\n\t\t\treturn ALPHA_INDEX[s] || s;\n\t\tvar code = s[2].toLowerCase() === 'x' ? parseInt(s.substr(3), 16) : parseInt(s.substr(2));\n\t\treturn !code || code < -32768 || code > 65535 ? '' : String.fromCharCode(code);\n\t});\n};\n\nSP.urlEncode = function() {\n\treturn encodeURIComponent(this);\n};\n\nSP.urlDecode = function() {\n\treturn decodeURIComponent(this);\n};\n\nSP.arg = function(obj, encode, def) {\n\tif (typeof(encode) === 'string')\n\t\tdef = encode;\n\treturn this.replace(regexpARG, function(text) {\n\t\t// Is double?\n\t\tvar l = text[1] === '{' ? 2 : 1;\n\t\tvar val = obj[text.substring(l, text.length - l).trim()];\n\t\tif (encode && encode === 'json')\n\t\t\treturn JSON.stringify(val);\n\t\treturn val == null ? (def == null ? text : def) : encode ? encode === 'html' ? (val + '').encode() : encodeURIComponent(val + '') : val;\n\t});\n};\n\nSP.params = function(obj) {\n\n\tOBSOLETE('String.params()', 'The method is deprecated instead of it use F.viewCompile() or String.format().');\n\n\tvar formatted = this;\n\tif (obj == null)\n\t\treturn formatted;\n\n\treturn formatted.replace(regexpPARAM, function(prop) {\n\n\t\tvar isEncode = false;\n\t\tvar name = prop.substring(2, prop.length - 2).trim();\n\n\t\tvar format = '';\n\t\tvar index = name.indexOf('|');\n\n\t\tif (index !== -1) {\n\t\t\tformat = name.substring(index + 1, name.length).trim();\n\t\t\tname = name.substring(0, index).trim();\n\t\t}\n\n\t\tif (name[0] === '!')\n\t\t\tname = name.substring(1);\n\t\telse\n\t\t\tisEncode = true;\n\n\t\tvar val;\n\n\t\tif (name.indexOf('.') !== -1) {\n\t\t\tvar arr = name.split('.');\n\t\t\tif (arr.length === 2) {\n\t\t\t\tif (obj[arr[0]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]];\n\t\t\t} else if (arr.length === 3) {\n\t\t\t\tif (obj[arr[0]] && obj[arr[0]][arr[1]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]][arr[2]];\n\t\t\t} else if (arr.length === 4) {\n\t\t\t\tif (obj[arr[0]] && obj[arr[0]][arr[1]] && obj[arr[0]][arr[1]][arr[2]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]][arr[2]][arr[3]];\n\t\t\t} else if (arr.length === 5) {\n\t\t\t\tif (obj[arr[0]] && obj[arr[0]][arr[1]] && obj[arr[0]][arr[1]][arr[2]] && obj[arr[0]][arr[1]][arr[2]][arr[3]])\n\t\t\t\t\tval = obj[arr[0]][arr[1]][arr[2]][arr[3]][arr[4]];\n\t\t\t}\n\t\t} else\n\t\t\tval = name.length ? obj[name] : obj;\n\n\t\tif (typeof(val) === 'function')\n\t\t\tval = val(index);\n\n\t\tif (val === undefined)\n\t\t\treturn prop;\n\n\t\tif (format.length) {\n\t\t\tvar type = typeof(val);\n\t\t\tif (type === 'string') {\n\t\t\t\tvar max = +format;\n\t\t\t\tif (!isNaN(max))\n\t\t\t\t\tval = val.max(max + 3, '...');\n\n\t\t\t} else if (type === 'number' || exports.isDate(val)) {\n\t\t\t\tif (format.isNumber())\n\t\t\t\t\tformat = +format;\n\t\t\t\tval = val.format(format);\n\t\t\t}\n\t\t}\n\n\t\tval = val.toString();\n\t\treturn isEncode ? exports.encode(val) : val;\n\t});\n};\n\nSP.max = function(length, chars) {\n\tvar str = this;\n\tif (typeof(chars) !== 'string')\n\t\tchars = '...';\n\treturn str.length > length ? str.substring(0, length - chars.length) + chars : str;\n};\n\nSP.isJSON = function() {\n\tvar self = this;\n\tif (self.length <= 1)\n\t\treturn false;\n\n\tvar l = self.length - 1;\n\tvar a;\n\tvar b;\n\tvar i = 0;\n\n\twhile (true) {\n\t\ta = self[i++];\n\t\tif (a === ' ' || a === '\\n' || a === '\\r' || a === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\twhile (true) {\n\t\tb = self[l--];\n\t\tif (b === ' ' || b === '\\n' || b === '\\r' || b === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\treturn (a === '\"' && b === '\"') || (a === '[' && b === ']') || (a === '{' && b === '}') || (a.charCodeAt(0) > 47 && b.charCodeAt(0) < 57);\n};\n\nSP.isURL = function() {\n\treturn this.length <= 7 ? false : F.validators.url.test(this);\n};\n\nSP.isZIP = function() {\n\treturn F.validators.zip.test(this);\n};\n\nSP.isEmail = function() {\n\treturn this.length <= 4 ? false : F.validators.email.test(this);\n};\n\nSP.isPhone = function() {\n\treturn this.length < 6 ? false : F.validators.phone.test(this);\n};\n\nSP.isBase64 = function() {\n\tvar str = this;\n\treturn str.length % 4 === 0 && regexpBASE64.test(str);\n};\n\nSP.isUID = function() {\n\tvar str = this;\n\n\tif (str.length < 12)\n\t\treturn false;\n\n\tvar is = DEF.validators.uid.test(str);\n\tif (is) {\n\n\t\tvar sum;\n\t\tvar beg;\n\t\tvar end;\n\t\tvar e = str[str.length - 1];\n\n\t\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = +str[str.length - 3];\n\t\t\tend = str.length - 5;\n\t\t\tvar tmp = e === 'c' || e === 'd' ? (+str.substring(beg, end)) : parseInt(str.substring(beg, end), 16);\n\t\t\treturn sum === (tmp % 2 ? '1' : '0');\n\t\t} else if (e === 'a') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = 6;\n\t\t\tend = str.length - 4;\n\t\t} else {\n\t\t\tsum = str[str.length - 1];\n\t\t\tbeg = 10;\n\t\t\tend = str.length - 4;\n\t\t}\n\n\t\twhile (beg++ < end) {\n\t\t\tif (str[beg] !== '0') {\n\t\t\t\tif (((+str.substring(beg, end)) % 2 ? '1' : '0') === sum)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\nSP.parseUID = function() {\n\tvar self = this;\n\tvar obj = {};\n\tvar hash;\n\tvar e = self[self.length - 1];\n\n\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\tend = +self[self.length - 3];\n\t\tvar ticks = ((e === 'b' ? (+self.substring(0, end)) : parseInt(self.substring(0, end), e=== 'd' ? 36 : 16)) * 1000 * 60) + 1580511600000; // 1.1.2020\n\t\tobj.date = new Date(ticks);\n\t\tbeg = end;\n\t\tend = self.length - 5;\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else if (e === 'a') {\n\t\tvar ticks = ((+self.substring(0, 6)) * 1000 * 60) + 1548975600000; // old 1.1.2019\n\t\tobj.date = new Date(ticks);\n\t\tbeg = 7;\n\t\tend = self.length - 4;\n\t\thash = +self.substring(end + 2, end + 3);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else {\n\t\tvar y = self.substring(0, 2);\n\t\tvar M = self.substring(2, 4);\n\t\tvar d = self.substring(4, 6);\n\t\tvar H = self.substring(6, 8);\n\t\tvar m = self.substring(8, 10);\n\n\t\tobj.date = new Date(+('20' + y), (+M) - 1, +d, +H, +m, 0);\n\n\t\tvar beg = 0;\n\t\tvar end = 0;\n\t\tvar index = 10;\n\n\t\twhile (true) {\n\n\t\t\tvar c = self[index];\n\n\t\t\tif (!c)\n\t\t\t\tbreak;\n\n\t\t\tif (!beg && c !== '0')\n\t\t\t\tbeg = index;\n\n\t\t\tif (c.charCodeAt(0) > 96) {\n\t\t\t\tend = index;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tindex++;\n\t\t}\n\n\t\tobj.century = self.substring(end + 4);\n\n\t\tif (obj.century) {\n\t\t\tobj.century = 20 + (+obj.century);\n\t\t\tobj.date.setYear(obj.date.getFullYear() + 100);\n\t\t} else\n\t\t\tobj.century = 21;\n\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.hash = self.substring(end, end + 3);\n\t}\n\n\tobj.index = +self.substring(beg, end);\n\tobj.valid = (obj.index % 2 ? 1 : 0) === hash;\n\treturn obj;\n};\n\nSP.parseENV = function() {\n\n\tvar arr = this.split(regexpLINES);\n\tvar obj = {};\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar line = arr[i];\n\t\tif (!line || line.substring(0, 2) === '//' || line[0] === '#')\n\t\t\tcontinue;\n\n\t\tvar index = line.indexOf('=');\n\t\tif (index === -1)\n\t\t\tcontinue;\n\n\t\tvar key = line.substring(0, index);\n\t\tvar val = line.substring(index + 1).replace(/\\\\n/g, '\\n');\n\t\tvar end = val.length - 1;\n\n\t\tif ((val[0] === '\"' && val[end] === '\"') || (val[0] === '\\'' && val[end] === '\\''))\n\t\t\tval = val.substring(1, end);\n\t\telse\n\t\t\tval = val.trim();\n\n\t\tobj[key] = val;\n\t}\n\n\treturn obj;\n};\n\nSP.parseInt = function(def) {\n\tvar str = this.trim();\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.parseInt2 = function(def) {\n\tvar num = this.match(regexpINTEGER);\n\treturn num ? +num[0] : (def === undefined ? 0 : def);\n};\n\nSP.parseFloat2 = function(def) {\n\tvar num = this.match(regexpFLOAT);\n\treturn num ? +num[0].toString().replace(/,/g, '.') : (def === undefined ? 0 : def);\n};\n\nSP.parseBool = SP.parseBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn self === 'true' || self === '1' || self === 'on';\n};\n\nSP.parseFloat = function(def) {\n\tvar str = this.trim();\n\tif (str.indexOf(',') !== -1)\n\t\tstr = str.replace(',', '.');\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.capitalize = function(first) {\n\n\tif (first)\n\t\treturn (this[0] || '').toUpperCase() + this.substring(1);\n\n\tvar builder = '';\n\tvar c;\n\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i - 1];\n\t\tif (!c || (c === ' ' || c === '\\t' || c === '\\n'))\n\t\t\tc = this[i].toUpperCase();\n\t\telse\n\t\t\tc = this[i];\n\t\tbuilder += c;\n\t}\n\n\treturn builder;\n};\n\nSP.toUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tvar c = this[i].charCodeAt(0);\n\t\tif(c > 126 || c < 32)\n\t\t\toutput += '\\\\u' + ('000' + c.toString(16)).substr(-4);\n\t\telse\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.fromUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tif (this[i] === '\\\\' && this[i + 1] === 'u') {\n\t\t\toutput += String.fromCharCode(parseInt(this[i + 2] + this[i + 3] + this[i + 4] + this[i + 5], 16));\n\t\t\ti += 5;\n\t\t} else\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.sha1 = function(salt) {\n\tvar hash = Crypto.createHash('sha1');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha256 = function(salt) {\n\tvar hash = Crypto.createHash('sha256');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha512 = function(salt) {\n\tvar hash = Crypto.createHash('sha512');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.md5 = function(salt) {\n\tvar hash = Crypto.createHash('md5');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.toSearch = function() {\n\tvar str = this.replace(regexpSEARCH, '').trim().toLowerCase().removeDiacritics();\n\tvar buf = [];\n\tvar prev = '';\n\tfor (var i = 0, length = str.length; i < length; i++) {\n\t\tvar c = str[i];\n\t\tif (c === 'y')\n\t\t\tc = 'i';\n\t\tif (c === prev)\n\t\t\tcontinue;\n\t\tprev = c;\n\t\tbuf.push(c);\n\t}\n\n\treturn buf.join('');\n};\n\nSP.toKeywords = SP.keywords = function(forSearch, alternative, max_count, max_length, min_length) {\n\treturn exports.keywords(this, forSearch, alternative, max_count, max_length, min_length);\n};\n\nfunction checksum(val) {\n\tvar sum = 0;\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\treturn sum;\n}\n\nSP.encrypt = function(key, isUnique, secret) {\n\tvar str = '0' + this;\n\tvar data_count = str.length;\n\tvar key_count = key.length;\n\tvar random = isUnique ? exports.random(120) + 40 : 65;\n\tvar count = data_count + (random % key_count);\n\tvar values = [];\n\tvar index = 0;\n\n\tvalues[0] = String.fromCharCode(random);\n\n\tvar counter = this.length + key.length;\n\n\tfor (var i = count - 1; i > 0; i--) {\n\t\tindex = str.charCodeAt(i % data_count);\n\t\tvalues[i] = String.fromCharCode(index ^ (key.charCodeAt(i % key_count) ^ random));\n\t}\n\n\tstr = Buffer.from(counter + '=' + values.join(''), ENCODING).toString('hex');\n\tvar sum = 0;\n\n\tfor (var i = 0; i < str.length; i++)\n\t\tsum += str.charCodeAt(i);\n\n\treturn (sum + checksum((secret || CONF.secret) + key)) + '-' + str;\n};\n\nSP.decrypt = function(key, secret) {\n\n\tvar index = this.indexOf('-');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar cs = +this.substring(0, index);\n\tif (!cs || isNaN(cs))\n\t\treturn null;\n\n\tvar hash = this.substring(index + 1);\n\tvar sum = checksum((secret || CONF.secret) + key);\n\tfor (var i = 0; i < hash.length; i++)\n\t\tsum += hash.charCodeAt(i);\n\n\tif (sum !== cs)\n\t\treturn null;\n\n\tvar values = Buffer.from(hash, 'hex').toString(ENCODING);\n\tvar index = values.indexOf('=');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar counter = +values.substring(0, index);\n\tif (isNaN(counter))\n\t\treturn null;\n\n\tvalues = values.substring(index + 1);\n\n\tvar count = values.length;\n\tvar random = values.charCodeAt(0);\n\tvar key_count = key.length;\n\tvar data_count = count - (random % key_count);\n\tvar decrypt_data = [];\n\n\tfor (var i = data_count - 1; i > 0; i--) {\n\t\tindex = values.charCodeAt(i) ^ (random ^ key.charCodeAt(i % key_count));\n\t\tdecrypt_data[i] = String.fromCharCode(index);\n\t}\n\n\tvar val = decrypt_data.join('');\n\treturn counter !== (val.length + key.length) ? null : val;\n};\n\nexports.encryptUID = function(val, key) {\n\n\tvar num = typeof(val) === 'number';\n\tvar sum = 0;\n\n\tif (!key)\n\t\tkey = CONF.secret;\n\n\tval = val + '';\n\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\n\tfor (var i = 0; i < key.length; i++)\n\t\tsum += key.charCodeAt(i);\n\n\treturn (num ? 'n' : 'x') + (CONF.secret_uid + val + sum + key).crc32(true).toString(16) + 'x' + val;\n};\n\nexports.decryptUID = function(val, key) {\n\tvar num = val[0] === 'n';\n\tvar raw = val.substring(val.indexOf('x', 1) + 1);\n\n\tif (num)\n\t\traw = +raw;\n\n\treturn exports.encryptUID(raw, key) === val ? raw : null;\n};\n\nSP.base64ToFile = function(filename, callback) {\n\tvar self = this;\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\tFs.writeFile(filename, self.substring(index), 'base64', callback || exports.noop);\n\treturn this;\n};\n\nSP.base64ToBuffer = function() {\n\tvar self = this;\n\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\n\treturn Buffer.from(self.substring(index), 'base64');\n};\n\nSP.base64ContentType = function() {\n\tvar self = this;\n\tvar index = self.indexOf(';');\n\treturn index === -1 ? '' : self.substring(5, index);\n};\n\nSP.removeDiacritics = function() {\n\treturn exports.removeDiacritics(this);\n};\n\nSP.indent = function(max, c) {\n\tvar plus = '';\n\tif (c === undefined)\n\t\tc = ' ';\n\twhile (max--)\n\t\tplus += c;\n\treturn plus + this;\n};\n\nSP.isNumber = function(isDecimal) {\n\n\tvar self = this;\n\tvar length = self.length;\n\n\tif (!length)\n\t\treturn false;\n\n\tisDecimal = isDecimal || false;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar ascii = self.charCodeAt(i);\n\n\t\tif (isDecimal) {\n\t\t\tif (ascii === 44 || ascii === 46) {\n\t\t\t\tisDecimal = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ascii < 48 || ascii > 57)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nif (!SP.padLeft) {\n\tSP.padLeft = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself = c + self;\n\t\treturn self;\n\t};\n}\n\n\nif (!SP.padRight) {\n\tSP.padRight = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself += c;\n\t\treturn self;\n\t};\n}\n\nSP.insert = function(index, value) {\n\tvar str = this;\n\tvar a = str.substring(0, index);\n\tvar b = value.toString() + str.substring(index);\n\treturn a + b;\n};\n\n/**\n * Create a link from String\n * @param  {Number} max A maximum length, default: 60 and optional.\n * @return {String}\n */\nSP.slug = SP.toSlug = SP.toLinker = SP.linker = function(max) {\n\tmax = max || 60;\n\n\tvar self = this.trim().toLowerCase().removeDiacritics();\n\tvar builder = '';\n\tvar length = self.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = self[i];\n\t\tvar code = self.charCodeAt(i);\n\n\t\tif (code > 540){\n\t\t\tbuilder = '';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (builder.length >= max)\n\t\t\tbreak;\n\n\t\tif (code > 31 && code < 48) {\n\t\t\tif (builder[builder.length - 1] !== '-')\n\t\t\t\tbuilder += '-';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((code > 47 && code < 58) || (code > 94 && code < 123))\n\t\t\tbuilder += c;\n\t}\n\n\tif (builder.length > 1) {\n\t\tlength = builder.length - 1;\n\t\treturn builder[length] === '-' ? builder.substring(0, length) : builder;\n\t} else if (!length)\n\t\treturn '';\n\n\tlength = self.length;\n\tself = self.replace(/\\s/g, '');\n\tbuilder = self.crc32(true).toString(36) + '';\n\treturn self[0].charCodeAt(0).toString(32) + builder + self[self.length - 1].charCodeAt(0).toString(32) + length;\n};\n\nSP.pluralize = function(zero, one, few, other) {\n\treturn this.parseInt().pluralize(zero, one, few, other);\n};\n\nSP.isBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn (self === 'true' || self === 'false') ? true : false;\n};\n\n/**\n * Check if the string contains only letters and numbers.\n * @return {Boolean}\n */\nSP.isAlphaNumeric = function() {\n\treturn regexpALPHA.test(this);\n};\n\nSP.soundex = function() {\n\n\tvar arr = this.toLowerCase().split('');\n\tvar first = arr.shift();\n\tvar builder = first.toUpperCase();\n\n\tfor (var i = 0, length = arr.length; i < length; i++) {\n\t\tvar v = SOUNDEX[arr[i]];\n\t\tif (v === undefined)\n\t\t\tcontinue;\n\t\tif (i) {\n\t\t\tif (v !== arr[i - 1])\n\t\t\t\tbuilder += v;\n\t\t} else if (v !== SOUNDEX[first])\n\t\t\tbuilder += v;\n\t}\n\n\treturn (builder + '000').substring(0, 4);\n};\n\n/**\n* Remove all Html Tags from a string\n* @return {string}\n*/\nSP.removeTags = function() {\n\treturn this.replace(regexpTags, '');\n};\n\nNP.floor = function(decimals) {\n\treturn Math.floor(this * Math.pow(10, decimals)) / Math.pow(10, decimals);\n};\n\nNP.fixed = function(decimals) {\n\treturn +this.toFixed(decimals);\n};\n\nNP.padLeft = function(max, c) {\n\treturn this.toString().padLeft(max, c || '0');\n};\n\nNP.padRight = function(max, c) {\n\treturn this.toString().padRight(max, c || '0');\n};\n\nNP.round = function(precision) {\n\tvar m = Math.pow(10, precision) || 1;\n\treturn Math.round(this * m) / m;\n};\n\nNP.currency = function(currency, a, b, c) {\n\tvar curr = DEF.currencies[currency];\n\treturn curr ? curr(this, a, b, c) : this.format(2);\n};\n\n/**\n * Async decrements\n * @param {Function(index, next)} fn\n * @param {Function} callback\n * @return {Number}\n */\nNP.async = function(fn, callback) {\n\tvar number = this;\n\tif (number)\n\t\tfn(number--, () => setImmediate(() => number.async(fn, callback)));\n\telse\n\t\tcallback && callback();\n\treturn number;\n};\n\n/**\n * Format number\n * @param {Number} decimals Maximum decimal numbers\n * @param {String} separator Number separator, default ' '\n * @param {String} separatorDecimal Decimal separator, default '.' if number separator is ',' or ' '.\n * @return {String}\n */\nNP.format = function(decimals, separator, separatorDecimal) {\n\n\tvar self = this;\n\n\tif (typeof(decimals) === 'string')\n\t\treturn self.format2(decimals);\n\n\tvar num = self.toString();\n\tvar dec = '';\n\tvar output = '';\n\tvar minus = num[0] === '-' ? '-' : '';\n\tif (minus)\n\t\tnum = num.substring(1);\n\n\tvar index = num.indexOf('.');\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = separator;\n\t\tseparator = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tif (separator === undefined)\n\t\tseparator = ' ';\n\n\tif (index !== -1) {\n\t\tdec = num.substring(index + 1);\n\t\tnum = num.substring(0, index);\n\t}\n\n\tindex = -1;\n\tfor (var i = num.length - 1; i >= 0; i--) {\n\t\tindex++;\n\t\tif (index > 0 && index % 3 === 0)\n\t\t\toutput = separator + output;\n\t\toutput = num[i] + output;\n\t}\n\n\tif (decimals || dec.length) {\n\t\tif (dec.length > decimals)\n\t\t\tdec = dec.substring(0, decimals || 0);\n\t\telse\n\t\t\tdec = dec.padRight(decimals || 0, '0');\n\t}\n\n\tif (dec.length && separatorDecimal === undefined)\n\t\tseparatorDecimal = separator === '.' ? ',' : '.';\n\n\treturn minus + output + (dec.length ? separatorDecimal + dec : '');\n};\n\nNP.add = function(value, decimals) {\n\n\tif (value == null)\n\t\treturn this;\n\n\tif (typeof(value) === 'number')\n\t\treturn this + value;\n\n\tvar first = value.charCodeAt(0);\n\tvar is = false;\n\n\tif (first < 48 || first > 57) {\n\t\tis = true;\n\t\tvalue = value.substring(1);\n\t}\n\n\tvar length = value.length;\n\tvar num;\n\n\tif (value[length - 1] === '%') {\n\t\tvalue = value.substring(0, length - 1);\n\t\tif (is) {\n\t\t\tvar val = value.parseFloat();\n\t\t\tswitch (first) {\n\t\t\t\tcase 42:\n\t\t\t\t\tnum = this * ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 43:\n\t\t\t\t\tnum = this + ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 45:\n\t\t\t\t\tnum = this - ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 47:\n\t\t\t\t\tnum = this / ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t} else {\n\t\t\tnum = (this / 100) * value.parseFloat();\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t}\n\n\t} else\n\t\tnum = value.parseFloat();\n\n\tswitch (first) {\n\t\tcase 42:\n\t\t\tnum = this * num;\n\t\t\tbreak;\n\t\tcase 43:\n\t\t\tnum = this + num;\n\t\t\tbreak;\n\t\tcase 45:\n\t\t\tnum = this - num;\n\t\t\tbreak;\n\t\tcase 47:\n\t\t\tnum = this / num;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnum = this;\n\t\t\tbreak;\n\t}\n\n\tif (decimals !== undefined)\n\t\treturn num.floor(decimals);\n\n\treturn num;\n};\n\nNP.format2 = function(format) {\n\tvar index = 0;\n\tvar num = this.toString();\n\tvar beg = 0;\n\tvar end = 0;\n\tvar max = 0;\n\tvar output = '';\n\tvar length = 0;\n\n\tif (typeof(format) === 'string') {\n\n\t\tvar d = false;\n\t\tlength = format.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar c = format[i];\n\t\t\tif (c === '#') {\n\t\t\t\tif (d)\n\t\t\t\t\tend++;\n\t\t\t\telse\n\t\t\t\t\tbeg++;\n\t\t\t}\n\n\t\t\tif (c === '.')\n\t\t\t\td = true;\n\t\t}\n\n\t\tvar strBeg = num;\n\t\tvar strEnd = '';\n\n\t\tindex = num.indexOf('.');\n\n\t\tif (index !== -1) {\n\t\t\tstrBeg = num.substring(0, index);\n\t\t\tstrEnd = num.substring(index + 1);\n\t\t}\n\n\t\tif (strBeg.length > beg) {\n\t\t\tmax = strBeg.length - beg;\n\t\t\tvar tmp = '';\n\t\t\tfor (var i = 0; i < max; i++)\n\t\t\t\ttmp += '#';\n\n\t\t\tformat = tmp + format;\n\t\t}\n\n\t\tif (strBeg.length < beg)\n\t\t\tstrBeg = strBeg.padLeft(beg, ' ');\n\n\t\tif (strEnd.length < end)\n\t\t\tstrEnd = strEnd.padRight(end, '0');\n\n\t\tif (strEnd.length > end)\n\t\t\tstrEnd = strEnd.substring(0, end);\n\n\t\td = false;\n\t\tindex = 0;\n\n\t\tvar skip = true;\n\t\tlength = format.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\n\t\t\tvar c = format[i];\n\n\t\t\tif (c !== '#') {\n\n\t\t\t\tif (skip)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (c === '.') {\n\t\t\t\t\td = true;\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\n\t\t\t\toutput += c;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar value = d ? strEnd[index] : strBeg[index];\n\n\t\t\tif (skip)\n\t\t\t\tskip = [',', ' '].indexOf(value) !== -1;\n\n\t\t\tif (!skip)\n\t\t\t\toutput += value;\n\n\t\t\tindex++;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\toutput = '### ### ###';\n\tbeg = num.indexOf('.');\n\tmax = format || 0;\n\n\tif (max === 0 && beg !== -1)\n\t\tmax = num.length - (beg + 1);\n\n\tif (max > 0) {\n\t\toutput += '.';\n\t\tfor (var i = 0; i < max; i++)\n\t\t\toutput += '#';\n\t}\n\n\treturn this.format(output);\n};\n\nNP.pluralize = function(zero, one, few, other) {\n\n\tvar num = this;\n\tvar value = '';\n\n\tif (num == 0)\n\t\tvalue = zero || '';\n\telse if (num == 1)\n\t\tvalue = one || '';\n\telse if (num > 1 && num < 5)\n\t\tvalue = few || '';\n\telse\n\t\tvalue = other;\n\n\tvar beg = value.indexOf('#');\n\tif (beg === -1)\n\t\treturn value;\n\n\tvar end = value.lastIndexOf('#');\n\tvar format = value.substring(beg, end + 1);\n\treturn num.format(format) + value.replace(format, '');\n};\n\nNP.hex = function(length) {\n\tvar str = this.toString(16).toUpperCase();\n\twhile(str.length < length)\n\t\tstr = '0' + str;\n\treturn str;\n};\n\nNP.VAT = function(percentage, decimals, includedVAT) {\n\tvar num = this;\n\tvar type = typeof(decimals);\n\n\tif (type === 'boolean') {\n\t\tvar tmp = includedVAT;\n\t\tincludedVAT = decimals;\n\t\tdecimals = tmp;\n\t\ttype = typeof(decimals);\n\t}\n\n\tif (type === 'undefined')\n\t\tdecimals = 2;\n\n\tif (includedVAT === undefined)\n\t\tincludedVAT = true;\n\n\tif (!percentage || !num)\n\t\treturn num;\n\treturn includedVAT ? (num / ((percentage / 100) + 1)).round(decimals) : (num * ((percentage / 100) + 1)).round(decimals);\n};\n\nNP.discount = function(percentage, decimals) {\n\tvar num = this;\n\tif (decimals === undefined)\n\t\tdecimals = 2;\n\treturn (num - (num / 100) * percentage).floor(decimals);\n};\n\nNP.parseDate = function(plus) {\n\treturn new Date(this + (plus || 0));\n};\n\nif (!NP.toRad) {\n\tNP.toRad = function () {\n\t\treturn this * Math.PI / 180;\n\t};\n}\n\n\nNP.filesize = function(decimals, type) {\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = type;\n\t\ttype = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tvar value;\n\n\t// this === bytes\n\tswitch (type) {\n\t\tcase 'bytes':\n\t\t\tvalue = this;\n\t\t\tbreak;\n\t\tcase 'KB':\n\t\t\tvalue = this / 1024;\n\t\t\tbreak;\n\t\tcase 'MB':\n\t\t\tvalue = filesizehelper(this, 2);\n\t\t\tbreak;\n\t\tcase 'GB':\n\t\t\tvalue = filesizehelper(this, 3);\n\t\t\tbreak;\n\t\tcase 'TB':\n\t\t\tvalue = filesizehelper(this, 4);\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\ttype = 'bytes';\n\t\t\tvalue = this;\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'KB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'MB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'GB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'TB';\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\ttype = ' ' + type;\n\treturn (decimals === undefined ? value.format(2).replace('.00', '') : value.format(decimals)) + type;\n};\n\nfunction filesizehelper(number, count) {\n\twhile (count--) {\n\t\tnumber = number / 1024;\n\t\tif (number.toFixed(3) === '0.000')\n\t\t\treturn 0;\n\t}\n\treturn number;\n}\n\nvar AP = Array.prototype;\n\n/**\n * Take items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.take = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tvar length = self.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tarr.push(self[i]);\n\t\tif (arr.length >= count)\n\t\t\treturn arr;\n\t}\n\treturn arr;\n};\n\n/**\n * Extend objects in Array\n * @param {Object} obj\n * @param {Boolean} rewrite Default: false.\n * @return {Array} Returns self\n */\nAP.extend = function(obj, rewrite) {\n\tvar isFn = typeof(obj) === 'function';\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tif (isFn)\n\t\t\tthis[i] = obj(this[i], i);\n\t\telse\n\t\t\tthis[i] = exports.extend(this[i], obj, rewrite);\n\t}\n\treturn this;\n};\n\n/**\n * First item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.first = function(def) {\n\tvar item = this[0];\n\treturn item === undefined ? def : item;\n};\n\n/**\n * Create object from Array\n * @param {String} name Optional, property name.\n * @return {Object}\n */\nAP.toObject = function(name) {\n\n\tvar self = this;\n\tvar obj = {};\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tvar item = self[i];\n\t\tif (name)\n\t\t\tobj[item[name]] = item;\n\t\telse\n\t\t\tobj[item] = true;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Compare two arrays\n * @param {String} id An identificator.\n * @param {Array} b Second array.\n * @param {Function(itemA, itemB, indexA, indexB)} executor\n */\nAP.compare = function(id, b, executor) {\n\n\tvar a = this;\n\tvar ak = {};\n\tvar bk = {};\n\tvar al = a.length;\n\tvar bl = b.length;\n\tvar tl = Math.max(al, bl);\n\tvar processed = {};\n\n\tfor (var i = 0; i < tl; i++) {\n\t\tvar av = a[i];\n\t\tif (av)\n\t\t\tak[av[id]] = i;\n\t\tvar bv = b[i];\n\t\tif (bv)\n\t\t\tbk[bv[id]] = i;\n\t}\n\n\tvar index = -1;\n\n\tfor (var i = 0; i < tl; i++) {\n\n\t\tvar av = a[i];\n\t\tvar bv = b[i];\n\t\tvar akk;\n\t\tvar bkk;\n\n\t\tif (av) {\n\t\t\takk = av[id];\n\t\t\tif (processed[akk])\n\t\t\t\tcontinue;\n\t\t\tprocessed[akk] = true;\n\t\t\tindex = bk[akk];\n\t\t\tif (index === undefined)\n\t\t\t\texecutor(av, undefined, i, -1);\n\t\t\telse\n\t\t\t\texecutor(av, b[index], i, index);\n\t\t}\n\n\t\tif (bv) {\n\t\t\tbkk = bv[id];\n\t\t\tif (processed[bkk])\n\t\t\t\tcontinue;\n\t\t\tprocessed[bkk] = true;\n\t\t\tindex = ak[bkk];\n\t\t\tif (index === undefined)\n\t\t\t\texecutor(undefined, bv, -1, i);\n\t\t\telse\n\t\t\t\texecutor(a[index], bv, index, i);\n\t\t}\n\t}\n\n\tOBSOLETE('Array.compare()', 'Use U.diff() insteadof Array.compare()');\n};\n\n/**\n * Pair arrays\n * @param {Array} arr\n * @param {String} property\n * @param {Function(itemA, itemB)} fn Paired items (itemA == this, itemB == arr)\n * @param {Boolean} remove Optional, remove item from this array if the item doesn't exist int arr (default: false).\n * @return {Array}\n */\nAP.pair = function(property, arr, fn, remove) {\n\n\tif (property instanceof Array) {\n\t\tvar tmp = property;\n\t\tproperty = arr;\n\t\tarr = tmp;\n\t}\n\n\tif (!arr)\n\t\tarr = new Array(0);\n\n\tvar length = arr.length;\n\tvar index = 0;\n\n\twhile (true) {\n\t\tvar item = this[index++];\n\t\tif (!item)\n\t\t\tbreak;\n\n\t\tvar is = false;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tif (item[property] !== arr[i][property])\n\t\t\t\tcontinue;\n\t\t\tfn(item, arr[i]);\n\t\t\tis = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is || !remove)\n\t\t\tcontinue;\n\n\t\tindex--;\n\t\tthis.splice(index, 1);\n\t}\n\n\tOBSOLETE('Array.pair()', 'The method will be removed in Total.js v4');\n\treturn this;\n};\n\n/**\n * Last item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.last = function(def) {\n\tvar item = this[this.length - 1];\n\treturn item === undefined ? def : item;\n};\n\nAP.quicksort = AP.orderBy = function(name, asc) {\n\n\tvar length = this.length;\n\tif (!length || length === 1)\n\t\treturn this;\n\n\tif (typeof(name) === 'boolean') {\n\t\tasc = name;\n\t\tname = undefined;\n\t} else if (asc === undefined)\n\t\tasc = true;\n\telse {\n\t\tswitch (asc) {\n\t\t\tcase 'asc':\n\t\t\tcase 'ASC':\n\t\t\t\tasc = true;\n\t\t\t\tbreak;\n\t\t\tcase 'desc':\n\t\t\tcase 'DESC':\n\t\t\t\tasc = false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvar self = this;\n\tvar type = 0;\n\tvar field = name ? self[0][name] : self[0];\n\n\tswitch (typeof(field)) {\n\t\tcase 'string':\n\t\t\tif (field.isJSONDate())\n\t\t\t\ttype = 4;\n\t\t\telse\n\t\t\t\ttype = 1;\n\t\t\tbreak;\n\t\tcase 'number':\n\t\t\ttype = 2;\n\t\t\tbreak;\n\t\tcase 'boolean':\n\t\t\ttype = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!exports.isDate(field))\n\t\t\t\treturn self;\n\t\t\ttype = 4;\n\t\t\tbreak;\n\t}\n\n\tshellsort(self, function(a, b) {\n\n\t\tvar va = name ? a[name] : a;\n\t\tvar vb = name ? b[name] : b;\n\n\t\t// String\n\t\tif (type === 1) {\n\t\t\treturn va && vb ? (asc ? COMPARER(va, vb) : COMPARER(vb, va)) : 0;\n\t\t} else if (type === 2) {\n\t\t\treturn va > vb ? (asc ? 1 : -1) : va < vb ? (asc ? -1 : 1) : 0;\n\t\t} else if (type === 3) {\n\t\t\treturn va === true && vb === false ? (asc ? 1 : -1) : va === false && vb === true ? (asc ? -1 : 1) : 0;\n\t\t} else if (type === 4) {\n\t\t\tif (!va || !vb)\n\t\t\t\treturn 0;\n\t\t\tif (!va.getTime)\n\t\t\t\tva = new Date(va);\n\t\t\tif (!vb.getTime)\n\t\t\t\tvb = new Date(vb);\n\t\t\tvar at = va.getTime();\n\t\t\tvar bt = vb.getTime();\n\t\t\treturn at > bt ? (asc ? 1 : -1) : at < bt ? (asc ? -1 : 1) : 0;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn self;\n};\n\nAP.trim = function() {\n\tvar self = this;\n\tvar output = [];\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tif (typeof(self[i]) === 'string')\n\t\t\tself[i] = self[i].trim();\n\t\tself[i] && output.push(self[i]);\n\t}\n\treturn output;\n};\n\n/**\n * Skip items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.skip = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tvar length = self.length;\n\tfor (var i = 0; i < length; i++)\n\t\ti >= count && arr.push(self[i]);\n\treturn arr;\n};\n\n/**\n * Find items in Array\n * @param {Function(item, index) or String/Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.where = AP.findAll = function(cb, value) {\n\n\tvar self = this;\n\tvar selected = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tcb.call(self, self[i], i) && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] === value && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] === cb && selected.push(self[i]);\n\t}\n\n\treturn selected;\n};\n\n/**\n * Find item in Array\n * @param {Function(item, index) or String/Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.findItem = function(cb, value) {\n\tvar self = this;\n\tvar index = self.findIndex(cb, value);\n\tif (index === -1)\n\t\treturn null;\n\treturn self[index];\n};\n\nvar arrfindobsolete;\n\nAP.find = function(cb, value) {\n\n\tif (!arrfindobsolete) {\n\t\tarrfindobsolete = true;\n\t\tOBSOLETE('Array.prototype.find()', 'will be removed in v4, use alternative \"Array.prototype.findItem()\"');\n\t}\n\n\tvar self = this;\n\tvar index = self.findIndex(cb, value);\n\tif (index === -1)\n\t\treturn null;\n\treturn self[index];\n};\n\nAP.findIndex = function(cb, value) {\n\n\tvar self = this;\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tif (cb.call(self, self[i], i))\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tif (self[i] && self[i][cb] === value)\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (self[i] === cb)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n};\n\n/**\n * Remove items from Array\n * @param {Function(item, index) or Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.remove = function(cb, value) {\n\n\tvar self = this;\n\tvar arr = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\t!cb.call(self, self[i], i) && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] !== value && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] !== cb && arr.push(self[i]);\n\t}\n\treturn arr;\n};\n\nAP.wait = AP.waitFor = function(onItem, callback, thread, tmp) {\n\n\tvar self = this;\n\tvar init = false;\n\n\t// INIT\n\tif (!tmp) {\n\n\t\tif (typeof(callback) !== 'function') {\n\t\t\tthread = callback;\n\t\t\tcallback = null;\n\t\t}\n\n\t\ttmp = {};\n\t\ttmp.pending = 0;\n\t\ttmp.index = 0;\n\t\ttmp.thread = thread;\n\n\t\t// thread === Boolean then array has to be removed item by item\n\n\t\tinit = true;\n\t}\n\n\tvar item = thread === true ? self.shift() : self[tmp.index++];\n\tif (item === undefined) {\n\t\tif (!tmp.pending) {\n\t\t\tcallback && callback();\n\t\t\ttmp.cancel = true;\n\t\t}\n\t\treturn self;\n\t}\n\n\ttmp.pending++;\n\tonItem.call(self, item, () => setImmediate(next_wait, self, onItem, callback, thread, tmp), tmp.index);\n\n\tif (!init || tmp.thread === 1)\n\t\treturn self;\n\n\tfor (var i = 1; i < tmp.thread; i++)\n\t\tself.wait(onItem, callback, 1, tmp);\n\n\treturn self;\n};\n\nfunction next_wait(self, onItem, callback, thread, tmp) {\n\ttmp.pending--;\n\tself.wait(onItem, callback, thread, tmp);\n}\n\n/**\n * Creates a function async list\n * @param {Function} callback Optional\n * @return {Array}\n */\nAP.async = function(thread, callback, pending) {\n\n\tvar self = this;\n\n\tif (typeof(thread) === 'function') {\n\t\tcallback = thread;\n\t\tthread = 1;\n\t} else if (thread === undefined)\n\t\tthread = 1;\n\n\tif (pending === undefined)\n\t\tpending = 0;\n\n\tvar item = self.shift();\n\tif (item === undefined) {\n\t\tif (!pending) {\n\t\t\tpending = undefined;\n\t\t\tcallback && callback();\n\t\t}\n\t\treturn self;\n\t}\n\n\tfor (var i = 0; i < thread; i++) {\n\n\t\tif (i)\n\t\t\titem = self.shift();\n\n\t\tpending++;\n\t\titem(function() {\n\t\t\tsetImmediate(function() {\n\t\t\t\tpending--;\n\t\t\t\tself.async(1, callback, pending);\n\t\t\t});\n\t\t});\n\t}\n\n\treturn self;\n};\n\nAP.randomize = function() {\n\tOBSOLETE('Array.randomize()', 'Use Array.random().');\n\treturn this.random();\n};\n\n// Fisher-Yates shuffle\nAP.random = function() {\n\tfor (var i = this.length - 1; i > 0; i--) {\n\t\tvar j = Math.floor(Math.random() * (i + 1));\n\t\tvar temp = this[i];\n\t\tthis[i] = this[j];\n\t\tthis[j] = temp;\n\t}\n\treturn this;\n};\n\nAP.limit = function(max, fn, callback, index) {\n\n\tif (index === undefined)\n\t\tindex = 0;\n\n\tvar current = [];\n\tvar self = this;\n\tvar length = index + max;\n\n\tfor (var i = index; i < length; i++) {\n\t\tvar item = self[i];\n\n\t\tif (item !== undefined) {\n\t\t\tcurrent.push(item);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!current.length) {\n\t\t\tcallback && callback();\n\t\t\treturn self;\n\t\t}\n\n\t\tfn(current, () => callback && callback(), index, index + max);\n\t\treturn self;\n\t}\n\n\tif (!current.length) {\n\t\tcallback && callback();\n\t\treturn self;\n\t}\n\n\tfn(current, function() {\n\t\tif (length < self.length)\n\t\t\tself.limit(max, fn, callback, length);\n\t\telse\n\t\t\tcallback && callback();\n\t}, index, index + max);\n\n\treturn self;\n};\n\n/**\n * Get unique elements from Array\n * @return {[type]} [description]\n */\nAP.unique = function(property) {\n\n\tvar self = this;\n\tvar result = [];\n\tvar sublength = 0;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tvar value = self[i];\n\n\t\tif (!property) {\n\t\t\tresult.indexOf(value) === -1 && result.push(value);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sublength === 0) {\n\t\t\tresult.push(value);\n\t\t\tsublength++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar is = true;\n\t\tfor (var j = 0; j < sublength; j++) {\n\t\t\tif (result[j][property] === value[property]) {\n\t\t\t\tis = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (is) {\n\t\t\tresult.push(value);\n\t\t\tsublength++;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nArrayBuffer.prototype.toBuffer = function() {\n\tvar buf = new Buffer(this.byteLength);\n\tvar view = new Uint8Array(this);\n\tfor (var i = 0, length = buf.length; i < length; ++i)\n\t\tbuf[i] = view[i];\n\treturn buf;\n};\n\nfunction AsyncTask(owner, name, fn, cb, waiting) {\n\tthis.isRunning = 0;\n\tthis.owner = owner;\n\tthis.name = name;\n\tthis.fn = fn;\n\tthis.cb = cb;\n\tthis.waiting = waiting;\n\tthis.interval = null;\n\tthis.isCanceled = false;\n}\n\nAsyncTask.prototype.run = function() {\n\tvar self = this;\n\ttry\n\t{\n\n\t\tif (self.isCanceled) {\n\t\t\tself.complete();\n\t\t\treturn self;\n\t\t}\n\n\t\tself.isRunning = 1;\n\t\tself.owner.tasksWaiting[self.name] = true;\n\t\tself.owner.emit('begin', self.name);\n\n\t\tvar timeout = self.owner.tasksTimeout[self.name];\n\t\tif (timeout > 0)\n\t\t\tself.interval = setTimeout(function() { self.timeout(); }, timeout);\n\n\t\tself.fn(function() {\n\t\t\tsetImmediate(() => self.complete());\n\t\t});\n\n\t} catch (ex) {\n\t\tself.owner.emit('error', self.name, ex);\n\t\tself.complete();\n\t}\n\treturn self;\n};\n\nAsyncTask.prototype.timeout = function(timeout) {\n\n\tvar self = this;\n\n\tif (timeout > 0) {\n\t\tclearTimeout(self.interval);\n\t\tsetTimeout(function() { self.timeout(); }, timeout);\n\t\treturn self;\n\t}\n\n\tif (timeout <= 0) {\n\t\tclearTimeout(self.interval);\n\t\tsetTimeout(function() { self.timeout(); }, timeout);\n\t\treturn self;\n\t}\n\n\tsetImmediate(() => self.cancel(true));\n\treturn self;\n};\n\nAsyncTask.prototype.cancel = function(isTimeout) {\n\tvar self = this;\n\n\tself.isCanceled = true;\n\n\tif (isTimeout)\n\t\tself.owner.emit('timeout', self.name);\n\telse\n\t\tself.owner.emit('cancel', self.name);\n\n\tself.fn = null;\n\tself.cb = null;\n\tself.complete();\n\treturn self;\n};\n\nAsyncTask.prototype.complete = function() {\n\n\tvar item = this;\n\tvar self = item.owner;\n\n\titem.isRunning = 2;\n\n\tdelete self.tasksPending[item.name];\n\tdelete self.tasksWaiting[item.name];\n\n\tif (!item.isCanceled) {\n\t\ttry\n\t\t{\n\t\t\tself.emit('end', item.name);\n\t\t\titem.cb && item.cb();\n\t\t} catch (ex) {\n\t\t\tself.emit('error', ex, item.name);\n\t\t}\n\t}\n\n\tsetImmediate(function() {\n\t\tself.reload();\n\t\tself.refresh();\n\t});\n\n\treturn self;\n};\n\nfunction Async(owner) {\n\n\tthis._max = 0;\n\tthis._count = 0;\n\tthis._isRunning = false;\n\tthis._isEnd = false;\n\n\tthis.owner = owner;\n\tthis.onComplete = [];\n\n\tthis.tasksPending = {};\n\tthis.tasksWaiting = {};\n\tthis.tasksAll = [];\n\tthis.tasksTimeout = {};\n\tthis.isCanceled = false;\n\n\tEvents.EventEmitter.call(this);\n}\n\nAsync.prototype = {\n\tget count() {\n\t\treturn this._count;\n\t},\n\n\tget percentage() {\n\t\tvar p = 100 - Math.floor((this._count * 100) / this._max);\n\t\treturn p ? p : 0;\n\t}\n};\n\nconst ACP = Async.prototype;\n\nACP.__proto__ = Object.create(Events.EventEmitter.prototype, {\n\tconstructor: {\n\t\tvalue: Async,\n\t\tenumberable: false\n\t}\n});\n\nACP.reload = function() {\n\tvar self = this;\n\tself.tasksAll = Object.keys(self.tasksPending);\n\tself.emit('percentage', self.percentage);\n\treturn self;\n};\n\nACP.cancel = function(name) {\n\n\tvar self = this;\n\n\tif (name === undefined) {\n\t\tself.isCanceled = true;\n\t\tfor (var i = 0; i < self._count; i++)\n\t\t\tself.cancel(self.tasksAll[i]);\n\t\treturn true;\n\t}\n\n\tvar task = self.tasksPending[name];\n\tif (!task)\n\t\treturn false;\n\n\tdelete self.tasksPending[name];\n\tdelete self.tasksWaiting[name];\n\n\ttask.cancel();\n\ttask = null;\n\tself.reload();\n\tself.refresh();\n\n\treturn true;\n};\n\nACP.await = function(name, fn, cb) {\n\n\tvar self = this;\n\n\tif (self.isCanceled)\n\t\treturn false;\n\n\tif (typeof(name) === 'function') {\n\t\tcb = fn;\n\t\tfn = name;\n\t\tname = exports.GUID(6);\n\t}\n\n\tif (self.tasksPending[name])\n\t\treturn false;\n\n\tself.tasksPending[name] = new AsyncTask(self, name, fn, cb, null);\n\tself._max++;\n\tself.reload();\n\tself.refresh();\n\treturn true;\n};\n\nACP.wait = function(name, waitingFor, fn, cb) {\n\n\tvar self = this;\n\n\tif (self.isCanceled)\n\t\treturn false;\n\n\tif (typeof(waitingFor) === 'function') {\n\t\tcb = fn;\n\t\tfn = waitingFor;\n\t\twaitingFor = null;\n\t}\n\n\tif (self.tasksPending[name])\n\t\treturn false;\n\n\tself.tasksPending[name] = new AsyncTask(self, name, fn, cb, waitingFor);\n\tself._max++;\n\tself.reload();\n\tself.refresh();\n\treturn true;\n};\n\nACP.complete = function(fn) {\n\treturn this.run(fn);\n};\n\nACP.run = function(fn) {\n\tthis._isRunning = true;\n\tfn && this.onComplete.push(fn);\n\tthis.refresh();\n\treturn this;\n};\n\nACP.isRunning = function(name) {\n\tif (!name)\n\t\treturn this._isRunning;\n\tvar task = this.tasksPending[name];\n\treturn task ? task.isRunning === 1 : false;\n};\n\nACP.isWaiting = function(name) {\n\tvar task = this.tasksPending[name];\n\treturn task ? task.isRunning === 0 : false;\n};\n\nACP.isPending = function(name) {\n\treturn this.tasksPending[name] ? true : false;\n};\n\nACP.timeout = function(name, timeout) {\n\tif (timeout)\n\t\tthis.tasksTimeout[name] = timeout;\n\telse\n\t\tthis.tasksTimeout[name] = undefined;\n\treturn this;\n};\n\nACP.refresh = function(name) {\n\n\tvar self = this;\n\n\tif (!self._isRunning || self._isEnd)\n\t\treturn self;\n\n\tself._count = self.tasksAll.length;\n\tvar index = 0;\n\n\twhile (true) {\n\t\tvar name = self.tasksAll[index++];\n\t\tif (!name)\n\t\t\tbreak;\n\n\t\tvar task = self.tasksPending[name];\n\t\tif (!task)\n\t\t\tbreak;\n\n\t\tif (self.isCanceled || task.isCanceled) {\n\t\t\tdelete self.tasksPending[name];\n\t\t\tdelete self.tasksWaiting[name];\n\t\t\tself.tasksAll.splice(index, 1);\n\t\t\tself._count = self.tasksAll.length;\n\t\t\tindex--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (task.isRunning !== 0 || (task.waiting && self.tasksPending[task.waiting]))\n\t\t\tcontinue;\n\n\t\ttask.run();\n\t}\n\n\tif (self._count === 0) {\n\t\tself._isRunning = false;\n\t\tself._isEnd = true;\n\t\tself.emit('complete');\n\t\tself.emit('percentage', 100);\n\t\tself._max = 0;\n\t\tvar complete = self.onComplete;\n\t\tvar length = complete.length;\n\t\tself.onComplete = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcomplete[i]();\n\t\t\t} catch (ex) {\n\t\t\t\tself.emit('error', ex);\n\t\t\t}\n\t\t}\n\t\tsetImmediate(() => self._isEnd = false);\n\t}\n\n\treturn self;\n};\n\nfunction FileList() {\n\tthis.pending = [];\n\tthis.pendingDirectory = [];\n\tthis.directory = [];\n\tthis.file = [];\n\tthis.onComplete = null;\n\tthis.onFilter = null;\n\tthis.advanced = false;\n}\n\nconst FLP = FileList.prototype;\n\nFLP.reset = function() {\n\tthis.file.length = 0;\n\tthis.directory.length = 0;\n\tthis.pendingDirectory.length = 0;\n\treturn this;\n};\n\nFLP.walk = function(directory) {\n\n\tvar self = this;\n\n\tif (directory instanceof Array) {\n\t\tvar length = directory.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pendingDirectory.push(directory[i]);\n\t\tself.next();\n\t\treturn;\n\t}\n\n\tFs.readdir(directory, function(err, arr) {\n\t\tif (err)\n\t\t\treturn self.next();\n\t\tvar length = arr.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pending.push(Path.join(directory, arr[i]));\n\t\tself.next();\n\t});\n};\n\nFLP.stat = function(path) {\n\tvar self = this;\n\n\tFs.stat(path, function(err, stats) {\n\n\t\tif (err)\n\t\t\treturn self.next();\n\n\t\tif (stats.isDirectory()) {\n\t\t\tpath = self.clean(path);\n\t\t\tif (!self.onFilter || self.onFilter(path, true)) {\n\t\t\t\tself.directory.push(path);\n\t\t\t\tself.pendingDirectory.push(path);\n\t\t\t}\n\t\t} else if (!self.onFilter || self.onFilter(path, false))\n\t\t\tself.file.push(self.advanced ? { filename: path, stats: stats } : path);\n\n\t\tself.next();\n\t});\n};\n\nFLP.clean = function(path) {\n\treturn path[path.length - 1] === Path.sep ? path : path + Path.sep;\n};\n\nFLP.next = function() {\n\tvar self = this;\n\n\tif (self.pending.length) {\n\t\tvar item = self.pending.shift();\n\t\tself.stat(item);\n\t\treturn;\n\t}\n\n\tif (self.pendingDirectory.length) {\n\t\tvar directory = self.pendingDirectory.shift();\n\t\tself.walk(directory);\n\t\treturn;\n\t}\n\n\tself.onComplete(self.file, self.directory);\n};\n\nexports.Async = Async;\n\nexports.sync = function(fn, owner) {\n\treturn function() {\n\n\t\tvar args = [].slice.call(arguments);\n\t\tvar params;\n\t\tvar callback;\n\t\tvar executed = false;\n\t\tvar self = owner || this;\n\n\t\targs.push(function() {\n\t\t\tparams = arguments;\n\t\t\tif (!executed && callback) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t});\n\n\t\tfn.apply(self, args);\n\n\t\treturn function(cb) {\n\t\t\tcallback = cb;\n\t\t\tif (!executed && params) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t};\n\t};\n};\n\nexports.sync2 = function(fn, owner) {\n\treturn (function() {\n\n\t\tvar params;\n\t\tvar callback;\n\t\tvar executed = false;\n\t\tvar self = owner || this;\n\t\tvar args = [].slice.call(arguments);\n\n\t\targs.push(function() {\n\t\t\tparams = arguments;\n\t\t\tif (!executed && callback) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t});\n\n\t\tfn.apply(self, args);\n\n\t\treturn function(cb) {\n\t\t\tcallback = cb;\n\t\t\tif (!executed && params) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t};\n\t})();\n};\n\nexports.async = function(fn, isApply) {\n\tvar context = this;\n\treturn function(complete) {\n\n\t\tvar self = this;\n\t\tvar argv;\n\n\t\tif (arguments.length) {\n\n\t\t\tif (isApply) {\n\t\t\t\t// index.js/Subscribe.prototype.doExecute\n\t\t\t\targv = arguments[1];\n\t\t\t} else {\n\t\t\t\targv = [];\n\t\t\t\tfor (var i = 1; i < arguments.length; i++)\n\t\t\t\t\targv.push(arguments[i]);\n\t\t\t}\n\t\t} else\n\t\t\targv = new Array(0);\n\n\t\tvar generator = fn.apply(context, argv);\n\t\tnext(null);\n\n\t\tfunction next(err, result) {\n\n\t\t\tvar g, type;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar can = err ? false : true;\n\t\t\t\tswitch (can) {\n\t\t\t\t\tcase true:\n\t\t\t\t\t\tg = generator.next(result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\tg = generator.throw(err);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\n\t\t\t\tif (!complete)\n\t\t\t\t\treturn;\n\n\t\t\t\ttype = typeof(complete);\n\n\t\t\t\tif (type === 'object' && complete.isController) {\n\t\t\t\t\tif (e instanceof ErrorBuilder)\n\t\t\t\t\t\tcomplete.content(e);\n\t\t\t\t\telse\n\t\t\t\t\t\tcomplete.view500(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttype === 'function' && setImmediate(() => complete(e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (g.done) {\n\t\t\t\ttypeof(complete) === 'function' && complete(null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar promise = g.value instanceof Promise;\n\n\t\t\tif (typeof(g.value) !== 'function' && !promise) {\n\t\t\t\tnext.call(self, null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (promise) {\n\t\t\t\t\tg.value.then((value) => next.call(self, null, value));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tg.value.call(self, function() {\n\t\t\t\t\tnext.apply(self, arguments);\n\t\t\t\t});\n\n\t\t\t} catch (e) {\n\t\t\t\tsetImmediate(() => next.call(self, e));\n\t\t\t}\n\t\t}\n\n\t\treturn generator.value;\n\t};\n};\n\n// MIT\n// Written by Jozef Gula\n// Optimized by Peter Sirka\nconst CACHE_GML1 = [null, null, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\nconst CACHE_GML2 = [null, null, null, null, null, null, null, null];\nexports.getMessageLength = function(data, isLE) {\n\n\tvar length = data[1] & 0x7f;\n\n\tif (length === 126) {\n\t\tif (data.length < 4)\n\t\t\treturn -1;\n\t\tCACHE_GML1[0] = data[3];\n\t\tCACHE_GML1[1] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML1, 0, isLE);\n\t}\n\n\tif (length === 127) {\n\t\tif (data.Length < 10)\n\t\t\treturn -1;\n\t\tCACHE_GML2[0] = data[9];\n\t\tCACHE_GML2[1] = data[8];\n\t\tCACHE_GML2[2] = data[7];\n\t\tCACHE_GML2[3] = data[6];\n\t\tCACHE_GML2[4] = data[5];\n\t\tCACHE_GML2[5] = data[4];\n\t\tCACHE_GML2[6] = data[3];\n\t\tCACHE_GML2[7] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML2, 0, isLE);\n\t}\n\n\treturn length;\n};\n\n// MIT\n// Written by Jozef Gula\nfunction converBytesToInt64(data, startIndex, isLE) {\n\treturn isLE ? (data[startIndex] | (data[startIndex + 1] << 0x08) | (data[startIndex + 2] << 0x10) | (data[startIndex + 3] << 0x18) | (data[startIndex + 4] << 0x20) | (data[startIndex + 5] << 0x28) | (data[startIndex + 6] << 0x30) | (data[startIndex + 7] << 0x38)) : ((data[startIndex + 7] << 0x20) | (data[startIndex + 6] << 0x28) | (data[startIndex + 5] << 0x30) | (data[startIndex + 4] << 0x38) | (data[startIndex + 3]) | (data[startIndex + 2] << 0x08) | (data[startIndex + 1] << 0x10) | (data[startIndex] << 0x18));\n}\n\nexports.queuecache = {};\n\nfunction queue_next(name) {\n\n\tvar item = exports.queuecache[name];\n\tif (!item)\n\t\treturn;\n\n\titem.running--;\n\n\tif (item.running < 0)\n\t\titem.running = 0;\n\n\tif (item.pending.length) {\n\t\tvar fn = item.pending.shift();\n\t\tif (fn) {\n\t\t\titem.running++;\n\t\t\tsetImmediate(queue_next_callback, fn, name);\n\t\t} else\n\t\t\titem.running = 0;\n\t}\n}\n\nfunction queue_next_callback(fn, name) {\n\tfn(() => queue_next(name));\n}\n\n/**\n * Queue list\n * @param {String} name\n * @param {Number} max Maximum stack.\n * @param {Function(next)} fn\n */\nexports.queue = function(name, max, fn) {\n\n\tif (!fn)\n\t\treturn false;\n\n\tif (!max) {\n\t\tfn(NOOP);\n\t\treturn true;\n\t}\n\n\tif (!exports.queuecache[name])\n\t\texports.queuecache[name] = { limit: max, running: 0, pending: [] };\n\n\tvar item = exports.queuecache[name];\n\tif (item.running >= item.limit) {\n\t\titem.pending.push(fn);\n\t\treturn false;\n\t}\n\n\titem.running++;\n\tsetImmediate(queue_next_callback, fn, name);\n\treturn true;\n};\n\nexports.minifyStyle = function(val) {\n\treturn Internal.compile_css(val);\n};\n\nexports.minifyScript = function(val) {\n\treturn Internal.compile_javascript(val);\n};\n\nexports.minifyHTML = function(val) {\n\treturn Internal.compile_html(val);\n};\n\nexports.parseTheme = function(value) {\n\tif (value[0] !== '=')\n\t\treturn '';\n\tvar index = value.indexOf('/', 2);\n\tif (index === -1)\n\t\treturn '';\n\tvalue = value.substring(1, index);\n\treturn value === '?' ? CONF.default_theme : value;\n};\n\n\nexports.set = function(obj, path, value) {\n\tvar cachekey = 'S+' + path;\n\n\tif (F.temporary.other[cachekey])\n\t\treturn F.temporary.other[cachekey](obj, value);\n\n\tif ((/__proto__|constructor|prototype|eval|function|\\*|\\+|;|\\s|\\(|\\)|!/).test(path))\n\t\treturn value;\n\n\tvar arr = parsepath(path);\n\tvar builder = [];\n\n\tfor (var i = 0; i < arr.length - 1; i++) {\n\t\tvar type = arr[i + 1] ? (REGISARR.test(arr[i + 1]) ? '[]' : '{}') : '{}';\n\t\tvar p = 'w' + (arr[i][0] === '[' ? '' : '.') + arr[i];\n\t\tbuilder.push('if(typeof(' + p + ')!==\\'object\\'||' + p + '==null)' + p + '=' + type + ';');\n\t}\n\n\tvar v = arr[arr.length - 1];\n\tvar ispush = v.lastIndexOf('[]') !== -1;\n\tvar a = builder.join(';') + ';var v=typeof(a)===\\'function\\'?a(U.get(b)):a;w' + (v[0] === '[' ? '' : '.') + (ispush ? v.replace(REGREPLACEARR, '.push(v)') : (v + '=v')) + ';return v';\n\n\tvar fn = new Function('w', 'a', 'b', a);\n\tF.temporary.other[cachekey] = fn;\n\treturn fn(obj, value, path);\n};\n\nexports.get = function(obj, path) {\n\n\tvar cachekey = 'G=' + path;\n\n\tif (F.temporary.other[cachekey])\n\t\treturn F.temporary.other[cachekey](obj);\n\n\tif ((/__proto__|constructor|prototype|eval|function|\\*|\\+|;|\\s|\\(|\\)|!/).test(path))\n\t\treturn;\n\n\tvar arr = parsepath(path);\n\tvar builder = [];\n\n\tfor (var i = 0, length = arr.length - 1; i < length; i++)\n\t\tbuilder.push('if(!w' + (!arr[i] || arr[i][0] === '[' ? '' : '.') + arr[i] + ')return');\n\n\tvar v = arr[arr.length - 1];\n\tvar fn = (new Function('w', builder.join(';') + ';return w' + (v[0] === '[' ? '' : '.') + v));\n\tF.temporary.other[cachekey] = fn;\n\treturn fn(obj);\n};\n\nfunction parsepath(path) {\n\n\tvar arr = path.split('.');\n\tvar builder = [];\n\tvar all = [];\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar p = arr[i];\n\t\tvar index = p.indexOf('[');\n\t\tif (index === -1) {\n\t\t\tif (p.indexOf('-') === -1) {\n\t\t\t\tall.push(p);\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t} else {\n\t\t\t\tvar a = all.splice(all.length - 1);\n\t\t\t\tall.push(a + '[\\'' + p + '\\']');\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t}\n\t\t} else {\n\t\t\tif (p.indexOf('-') === -1) {\n\t\t\t\tall.push(p.substring(0, index));\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t\tall.splice(all.length - 1);\n\t\t\t\tall.push(p);\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t} else {\n\t\t\t\tall.push('[\\'' + p.substring(0, index) + '\\']');\n\t\t\t\tbuilder.push(all.join(''));\n\t\t\t\tall.push(p.substring(index));\n\t\t\t\tbuilder.push(all.join(''));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn builder;\n}\n\nglobal.Async = global.async = exports.async;\nglobal.sync = global.SYNCHRONIZE = exports.sync;\nglobal.sync2 = exports.sync2;\n\n// =============================================\n// SHELL SORT IMPLEMENTATION OF ALGORITHM\n// =============================================\n\nfunction _shellInsertionSort(list, length, gapSize, fn) {\n\tvar temp, i, j;\n\tfor (i = gapSize; i < length; i += gapSize ) {\n\t\tj = i;\n\t\twhile(j > 0 && fn(list[j - gapSize], list[j]) === 1) {\n\t\t\ttemp = list[j];\n\t\t\tlist[j] = list[j - gapSize];\n\t\t\tlist[j - gapSize] = temp;\n\t\t\tj -= gapSize;\n\t\t}\n\t}\n}\n\nfunction shellsort(arr, fn) {\n\tvar length = arr.length;\n\tvar gapSize = Math.floor(length / 2);\n\twhile(gapSize) {\n\t\t_shellInsertionSort(arr, length, gapSize, fn);\n\t\tgapSize = Math.floor(gapSize / 2);\n\t}\n\treturn arr;\n}\n\nfunction EventEmitter2(obj) {\n\tif (obj) {\n\t\t!obj.emit && EventEmitter2.extend(obj);\n\t\treturn obj;\n\t} else\n\t\tthis.$events = {};\n}\n\nconst EE2P = EventEmitter2.prototype;\n\nEE2P.emit = function(name, a, b, c, d, e, f, g) {\n\n\tif (!this.$events)\n\t\treturn this;\n\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.on = function(name, fn) {\n\tif (!this.$events)\n\t\tthis.$events = {};\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nEE2P.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nEE2P.removeListener = function(name, fn) {\n\tif (this.$events) {\n\t\tvar evt = this.$events[name];\n\t\tif (evt) {\n\t\t\tevt = evt.remove(n => n === fn);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.removeAllListeners = function(name) {\n\tif (this.$events) {\n\t\tif (name === true)\n\t\t\tthis.$events = EMPTYOBJECT;\n\t\telse if (name)\n\t\t\tthis.$events[name] = undefined;\n\t\telse\n\t\t\tthis.$events = {};\n\t}\n\treturn this;\n};\n\nEventEmitter2.extend = function(obj) {\n\tobj.emit = EE2P.emit;\n\tobj.on = EE2P.on;\n\tobj.once = EE2P.once;\n\tobj.removeListener = EE2P.removeListener;\n\tobj.removeAllListeners = EE2P.removeAllListeners;\n};\n\nexports.EventEmitter2 = EventEmitter2;\n\nfunction Chunker(name, max) {\n\tthis.name = name;\n\tthis.max = max || 50;\n\tthis.index = 0;\n\tthis.filename = '{0}-'.format(name);\n\tthis.stack = [];\n\tthis.flushing = 0;\n\tthis.pages = 0;\n\tthis.count = 0;\n\tthis.percentage = 0;\n\tthis.autoremove = true;\n\tthis.compress = true;\n\tthis.filename = F.path.temp(this.filename);\n}\n\nconst CHP = Chunker.prototype;\n\nCHP.append = CHP.write = function(obj) {\n\tvar self = this;\n\n\tself.stack.push(obj);\n\n\tvar tmp = self.stack.length;\n\n\tif (tmp >= self.max) {\n\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.end = function() {\n\tvar self = this;\n\tvar tmp = self.stack.length;\n\tif (tmp) {\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.each = function(onItem, onEnd, indexer) {\n\n\tvar self = this;\n\n\tif (indexer == null) {\n\t\tself.percentage = 0;\n\t\tindexer = 0;\n\t}\n\n\tif (indexer >= self.index)\n\t\treturn onEnd && onEnd();\n\n\tself.read(indexer++, function(err, items) {\n\t\tself.percentage = Math.ceil((indexer / self.pages) * 100);\n\t\tonItem(items, () => self.each(onItem, onEnd, indexer), indexer - 1);\n\t});\n\n\treturn self;\n};\n\nCHP.read = function(index, callback) {\n\tvar self = this;\n\n\tif (self.flushing) {\n\t\tself.flushing_timeout = setTimeout(() => self.read(index, callback), 300);\n\t\treturn;\n\t}\n\n\tvar filename = self.filename + index + '.chunker';\n\n\tFs.readFile(filename, function(err, data) {\n\n\t\tif (err) {\n\t\t\tcallback(null, EMPTYARRAY);\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.compress) {\n\t\t\tZlib.inflate(data, function(err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(null, EMPTYARRAY);\n\t\t\t\t} else {\n\t\t\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t}\n\t});\n\n\treturn self;\n};\n\nCHP.clear = function() {\n\tvar files = [];\n\tfor (var i = 0; i < this.index; i++)\n\t\tfiles.push(this.filename + i + '.chunker');\n\tfiles.wait((filename, next) => Fs.unlink(filename, next));\n\treturn this;\n};\n\nCHP.destroy = function() {\n\tthis.clear();\n\tthis.indexer = 0;\n\tthis.flushing = 0;\n\tclearTimeout(this.flushing_timeout);\n\tthis.stack = null;\n\treturn this;\n};\n\nexports.chunker = function(name, max) {\n\treturn new Chunker(name, max);\n};\n\nexports.Chunker = Chunker;\n\nexports.ObjectToArray = function(obj) {\n\tif (obj == null)\n\t\treturn EMPTYARRAY;\n\tvar keys = Object.keys(obj);\n\tvar output = [];\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\toutput.push({ key: keys[i], value: obj[keys[i]]});\n\treturn output;\n};\n\nif (NODEVERSION > 699) {\n\texports.createBufferSize = (size) => Buffer.alloc(size || 0);\n\texports.createBuffer = (val, type) => Buffer.from(val || '', type);\n} else {\n\texports.createBufferSize = (size) => new Buffer(size || 0);\n\texports.createBuffer = (val, type) => new Buffer(val || '', type);\n}\n\nfunction Callback(count, callback) {\n\tthis.pending = count;\n\tthis.$callback = callback;\n}\nconst CP = Callback.prototype;\n\nCP.done = function(callback) {\n\tthis.$callback = callback;\n\treturn this;\n};\n\nCP.next = function() {\n\tvar self = this;\n\tself.pending--;\n\tif (!self.pending && self.$callback) {\n\t\tself.$callback();\n\t\tself.$callback = null;\n\t}\n\treturn self;\n};\n\nglobal.Callback = Callback;\n\nexports.Callback = function(count, callback) {\n\treturn new Callback(count, callback);\n};\n\nfunction Reader() {\n\tvar t = this;\n\tt.$add = function(builder) {\n\t\tif (t.reader)\n\t\t\tt.reader.add(builder);\n\t\telse\n\t\t\tt.reader = new framework_nosql.NoSQLReader(builder);\n\t};\n}\nconst RP = Reader.prototype;\n\nRP.done = function() {\n\tvar self = this;\n\tself.reader.done();\n\treturn self;\n};\n\nRP.reset = function() {\n\tvar self = this;\n\tself.reader.reset();\n\treturn self;\n};\n\nRP.push = function(data) {\n\tif (data == null)\n\t\tthis.reader.done();\n\telse\n\t\tthis.reader.compare(data instanceof Array ? data : [data]);\n\treturn this;\n};\n\nRP.find = function() {\n\tvar self = this;\n\tvar builder = new framework_nosql.DatabaseBuilder();\n\tsetImmediate(self.$add, builder);\n\treturn builder;\n};\n\nRP.count = function() {\n\tvar builder = this.find();\n\tbuilder.$options.readertype = 1;\n\treturn builder;\n};\n\nRP.scalar = function(type, field) {\n\treturn this.find().scalar(type, field);\n};\n\nexports.reader = function() {\n\treturn new Reader();\n};\n\nconst BUFEMPTYJSON = Buffer.from('{}');\n\nglobal.WAIT = exports.wait;\n!global.F && require('./index');\n"
        },
        {
          "name": "websocketclient.js",
          "type": "blob",
          "size": 16.7177734375,
          "content": "// Copyright 2012-2020 (c) Peter Å irka <petersirka@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/**\n * @module WebSocketClient\n * @version 3.4.4\n */\n\nif (!global.framework_utils)\n\tglobal.framework_utils = require('./utils');\n\nconst Crypto = require('crypto');\nconst Https = require('https');\nconst Http = require('http');\nconst Url = require('url');\nconst Zlib = require('zlib');\nconst ENCODING = 'utf8';\nconst WEBSOCKET_COMPRESS = Buffer.from([0x00, 0x00, 0xFF, 0xFF]);\nconst WEBSOCKET_COMPRESS_OPTIONS = { windowBits: Zlib.Z_DEFAULT_WINDOWBITS };\nconst CONCAT = [null, null];\n\nfunction WebSocketClient() {\n\tthis.current = {};\n\tthis.$events = {};\n\tthis.pending = [];\n\tthis.reconnect = 0;\n\tthis.closed = true;\n\n\t// type: json, text, binary\n\tthis.options = { type: 'json', compress: true, reconnect: 3000, encodedecode: true };\n\tthis.cookies = {};\n\tthis.headers = {};\n}\n\nconst WebSocketClientProto = WebSocketClient.prototype;\n\nWebSocketClientProto.connect = function(url, protocol, origin) {\n\n\tvar self = this;\n\tvar options = {};\n\tvar key = Crypto.randomBytes(16).toString('base64');\n\n\tself.url = url;\n\tself.origin = origin;\n\tself.protocol = protocol;\n\n\turl = Url.parse(url);\n\n\tvar isSecure = url.protocol === 'wss:';\n\n\toptions.port = url.port || (isSecure ? 443 : 80);\n\toptions.host = url.hostname;\n\toptions.path = url.path;\n\toptions.query = url.query;\n\toptions.headers = {};\n\toptions.headers['User-Agent'] = 'Total.js/v' + F.version_header;\n\toptions.headers['Sec-WebSocket-Version'] = '13';\n\toptions.headers['Sec-WebSocket-Key'] = key;\n\toptions.headers['Sec-Websocket-Extensions'] = (self.options.compress ? 'permessage-deflate, ' : '') + 'client_max_window_bits';\n\tprotocol && (options.headers['Sec-WebSocket-Protocol'] = protocol);\n\torigin && (options.headers['Sec-WebSocket-Origin'] = origin);\n\toptions.headers.Connection = 'Upgrade';\n\toptions.headers.Upgrade = 'websocket';\n\n\tvar keys = Object.keys(self.headers);\n\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\toptions.headers[keys[i]] = self.headers[keys[i]];\n\n\tkeys = Object.keys(self.cookies);\n\tif (keys.length) {\n\t\tvar tmp = [];\n\t\tfor (var i = 0, length = keys.length; i < length; i++)\n\t\t\ttmp.push(keys[i] + '=' + self.cookies[keys[i]]);\n\t\toptions.headers['Cookie'] = tmp.join(', ');\n\t}\n\n\tself.req = (isSecure ? Https : Http).get(options);\n\tself.req.$main = self;\n\tF.stats.performance.online++;\n\n\tself.req.on('error', function(e) {\n\t\tself.$events.error && self.emit('error', e);\n\t});\n\n\tself.req.on('response', function() {\n\t\tself.$events.error && self.emit('error', new Error('Unexpected server response.'));\n\t\tif (self.options.reconnectserver)\n\t\t\tself.connect(url, protocol, origin);\n\t\telse\n\t\t\tself.free();\n\t});\n\n\tself.req.on('upgrade', function(response, socket) {\n\n\t\tself.socket = socket;\n\t\tself.socket.$websocket = self;\n\n\t\tvar compress = (response.headers['sec-websocket-extensions'] || '').indexOf('-deflate') !== -1;\n\t\tvar digest = Crypto.createHash('sha1').update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11', 'binary').digest('base64');\n\n\t\tif (response.headers['sec-websocket-accept'] !== digest) {\n\t\t\tsocket.destroy();\n\t\t\tself.closed = true;\n\t\t\tself.$events.error && self.emit('error', new Error('Invalid server key.'));\n\t\t\tself.free();\n\t\t\treturn;\n\t\t}\n\n\t\tself.closed = false;\n\t\tself.socket.setTimeout(0);\n\t\tself.socket.setNoDelay();\n\t\tself.socket.on('data', websocket_ondata);\n\t\tself.socket.on('error', websocket_onerror);\n\t\tself.socket.on('close', websocket_close);\n\t\tself.socket.on('end', websocket_close);\n\n\t\tif (compress) {\n\t\t\tself.inflatepending = [];\n\t\t\tself.inflatelock = false;\n\t\t\tself.inflate = Zlib.createInflateRaw(WEBSOCKET_COMPRESS_OPTIONS);\n\t\t\tself.inflate.$websocket = self;\n\t\t\tself.inflate.on('error', F.error());\n\t\t\tself.inflate.on('data', websocket_inflate);\n\t\t\tself.deflatepending = [];\n\t\t\tself.deflatelock = false;\n\t\t\tself.deflate = Zlib.createDeflateRaw(WEBSOCKET_COMPRESS_OPTIONS);\n\t\t\tself.deflate.$websocket = self;\n\t\t\tself.deflate.on('error', F.error());\n\t\t\tself.deflate.on('data', websocket_deflate);\n\t\t}\n\n\t\tself.$events.open && self.emit('open');\n\t});\n};\n\nfunction websocket_ondata(chunk) {\n\tthis.$websocket.$ondata(chunk);\n}\n\nfunction websocket_onerror(e) {\n\tthis.$websocket.$onerror(e);\n}\n\nfunction websocket_close() {\n\tvar ws = this.$websocket;\n\tws.closed = true;\n\tws.$onclose();\n\tF.stats.performance.online--;\n\tws.options.reconnect && setTimeout(function(ws) {\n\t\tws.isClosed = false;\n\t\tws._isClosed = false;\n\t\tws.reconnect++;\n\t\tws.connect(ws.url, ws.protocol, ws.origin);\n\t}, ws.options.reconnect, ws);\n}\n\nWebSocketClientProto.emit = function(name, a, b, c, d, e, f, g) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nWebSocketClientProto.on = function(name, fn) {\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nWebSocketClientProto.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nWebSocketClientProto.removeListener = function(name, fn) {\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tevt = evt.remove(n => n === fn);\n\t\tif (evt.length)\n\t\t\tthis.$events[name] = evt;\n\t\telse\n\t\t\tthis.$events[name] = undefined;\n\t}\n\treturn this;\n};\n\nWebSocketClientProto.removeAllListeners = function(name) {\n\tif (name === true)\n\t\tthis.$events = EMPTYOBJECT;\n\telse if (name)\n\t\tthis.$events[name] = undefined;\n\telse\n\t\tthis.$events = {};\n\treturn this;\n};\n\nWebSocketClientProto.free = function() {\n\tvar self = this;\n\tself.socket && self.socket.destroy();\n\tself.socket = null;\n\tself.req && self.req.abort();\n\tself.req = null;\n\treturn self;\n};\n\n/**\n * Internal handler written by Jozef Gula\n * @param {Buffer} data\n * @return {Framework}\n */\nWebSocketClientProto.$ondata = function(data) {\n\n\tif (this.isClosed)\n\t\treturn;\n\n\tvar current = this.current;\n\tif (data) {\n\t\tif (current.buffer) {\n\t\t\tCONCAT[0] = current.buffer;\n\t\t\tCONCAT[1] = data;\n\t\t\tcurrent.buffer = Buffer.concat(CONCAT);\n\t\t} else\n\t\t\tcurrent.buffer = data;\n\t}\n\n\tif (!this.$parse())\n\t\treturn;\n\n\tif (!current.final && current.type !== 0x00)\n\t\tcurrent.type2 = current.type;\n\n\tvar tmp;\n\tvar decompress = current.compressed && this.inflate;\n\n\tswitch (current.type === 0x00 ? current.type2 : current.type) {\n\t\tcase 0x01:\n\n\t\t\t// text\n\t\t\tif (decompress) {\n\t\t\t\tcurrent.final && this.parseInflate();\n\t\t\t} else {\n\t\t\t\ttmp = this.$readbody();\n\t\t\t\tif (current.body)\n\t\t\t\t\tcurrent.body += tmp;\n\t\t\t\telse\n\t\t\t\t\tcurrent.body = tmp;\n\t\t\t\tcurrent.final && this.$decode();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x02:\n\t\t\t// binary\n\t\t\tif (decompress) {\n\t\t\t\tcurrent.final && this.parseInflate();\n\t\t\t} else {\n\t\t\t\ttmp = this.$readbody();\n\t\t\t\tif (current.body) {\n\t\t\t\t\tCONCAT[0] = current.body;\n\t\t\t\t\tCONCAT[1] = tmp;\n\t\t\t\t\tcurrent.body = Buffer.concat(CONCAT);\n\t\t\t\t} else\n\t\t\t\t\tcurrent.body = tmp;\n\t\t\t\tcurrent.final && this.$decode();\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\t\t\tthis.closemessage = current.buffer.slice(4).toString('utf8');\n\t\t\tthis.closecode = current.buffer[2] << 8 | current.buffer[3];\n\n\t\t\tif (this.closemessage && this.options.encodedecode)\n\t\t\t\tthis.closemessage = $decodeURIComponent(this.closemessage);\n\n\t\t\tthis.close(true);\n\t\t\tbreak;\n\n\t\tcase 0x09:\n\t\t\t// ping, response pong\n\t\t\tthis.socket.write(U.getWebSocketFrame(0, 'PONG', 0x0A));\n\t\t\tcurrent.buffer = null;\n\t\t\tcurrent.inflatedata = null;\n\t\t\tbreak;\n\n\t\tcase 0x0A:\n\t\t\t// pong\n\t\t\tcurrent.buffer = null;\n\t\t\tcurrent.inflatedata = null;\n\t\t\tbreak;\n\t}\n\n\tif (current.buffer) {\n\t\tcurrent.buffer = current.buffer.slice(current.length, current.buffer.length);\n\t\tcurrent.buffer.length && this.$ondata();\n\t}\n};\n\nfunction buffer_concat(buffers, length) {\n\tvar buffer = Buffer.alloc(length);\n\tvar offset = 0;\n\tfor (var i = 0, n = buffers.length; i < n; i++) {\n\t\tbuffers[i].copy(buffer, offset);\n\t\toffset += buffers[i].length;\n\t}\n\treturn buffer;\n}\n\n// MIT\n// Written by Jozef Gula\n// Optimized by Peter Sirka\nWebSocketClientProto.$parse = function() {\n\n\tvar self = this;\n\tvar current = self.current;\n\n\t// check end message\n\tif (!current.buffer || current.buffer.length <= 2 || ((current.buffer[0] & 0x80) >> 7) !== 1)\n\t\treturn;\n\n\t// WebSocket - Opcode\n\tcurrent.type = current.buffer[0] & 0x0f;\n\tcurrent.compressed = (current.buffer[0] & 0x40) === 0x40;\n\n\t// is final message?\n\tcurrent.final = ((current.buffer[0] & 0x80) >> 7) === 0x01;\n\n\t// does frame contain mask?\n\tcurrent.isMask = ((current.buffer[1] & 0xfe) >> 7) === 0x01;\n\n\t// data length\n\tvar length = U.getMessageLength(current.buffer, F.isLE);\n\t// index for data\n\n\tvar index = current.buffer[1] & 0x7f;\n\tindex = ((index === 126) ? 4 : (index === 127 ? 10 : 2)) + (current.isMask ? 4 : 0);\n\n\t// total message length (data + header)\n\tvar mlength = index + length;\n\n\t// Check length of data\n\tif (current.buffer.length < mlength)\n\t\treturn;\n\n\tcurrent.length = mlength;\n\n\t// Not Ping & Pong\n\tif (current.type !== 0x09 && current.type !== 0x0A) {\n\n\t\t// does frame contain mask?\n\t\tif (current.isMask) {\n\t\t\tcurrent.mask = Buffer.alloc(4);\n\t\t\tcurrent.buffer.copy(current.mask, 0, index - 4, index);\n\t\t}\n\n\t\tif (current.compressed && this.inflate) {\n\n\t\t\tvar buf = Buffer.alloc(length);\n\t\t\tcurrent.buffer.copy(buf, 0, index, mlength);\n\n\t\t\t// does frame contain mask?\n\t\t\tif (current.isMask) {\n\t\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\t\tbuf[i] = buf[i] ^ current.mask[i % 4];\n\t\t\t}\n\n\t\t\t// Does the buffer continue?\n\t\t\tbuf.$continue = current.final === false;\n\t\t\tthis.inflatepending.push(buf);\n\t\t} else {\n\t\t\tcurrent.data = Buffer.alloc(length);\n\t\t\tcurrent.buffer.copy(current.data, 0, index, mlength);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nWebSocketClientProto.$readbody = function() {\n\n\tvar current = this.current;\n\tvar length = current.data.length;\n\tvar buf;\n\n\tif (current.type === 1) {\n\n\t\tbuf = Buffer.alloc(length);\n\t\tfor (var i = 0; i < length; i++)  {\n\t\t\tif (current.isMask)\n\t\t\t\tbuf[i] = current.data[i] ^ current.mask[i % 4];\n\t\t\telse\n\t\t\t\tbuf[i] = current.data[i];\n\t\t}\n\n\t\treturn buf.toString('utf8');\n\n\t} else {\n\n\t\tbuf = Buffer.alloc(length);\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\t// does frame contain mask?\n\t\t\tif (current.isMask)\n\t\t\t\tbuf[i] = current.data[i] ^ current.mask[i % 4];\n\t\t\telse\n\t\t\t\tbuf[i] = current.data[i];\n\t\t}\n\t\treturn buf;\n\t}\n\n};\n\nWebSocketClientProto.$decode = function() {\n\tvar data = this.current.body;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.message++;\n\n\tswitch (this.options.type) {\n\n\t\tcase 'buffer': // Buffer\n\t\tcase 'binary': // Binary\n\t\t\t// this.emit('message', Buffer.from(new Uint8Array(data)));\n\t\t\t// break;\n\t\t\tthis.emit('message', data);\n\t\t\tbreak;\n\n\t\tcase 'json': // JSON\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tdata = data.toString(ENCODING);\n\t\t\tthis.options.encodedecode && (data = $decodeURIComponent(data));\n\t\t\tdata.isJSON() && this.emit('message', F.onParseJSON(data, this.req));\n\t\t\tbreak;\n\n\t\tdefault: // TEXT\n\t\t\tif (data instanceof Buffer)\n\t\t\t\tdata = data.toString(ENCODING);\n\t\t\tthis.emit('message', this.options.encodedecode ? $decodeURIComponent(data) : data);\n\t\t\tbreak;\n\t}\n\n\tthis.current.body = null;\n};\n\nWebSocketClientProto.parseInflate = function() {\n\tvar self = this;\n\n\tif (self.inflatelock)\n\t\treturn;\n\n\tvar buf = self.inflatepending.shift();\n\tif (buf) {\n\t\tself.inflatechunks = [];\n\t\tself.inflatechunkslength = 0;\n\t\tself.inflatelock = true;\n\t\tself.inflate.write(buf);\n\t\t!buf.$continue && self.inflate.write(Buffer.from(WEBSOCKET_COMPRESS));\n\t\tself.inflate.flush(function() {\n\n\t\t\tif (!self.inflatechunks)\n\t\t\t\treturn;\n\n\t\t\tvar data = buffer_concat(self.inflatechunks, self.inflatechunkslength);\n\n\t\t\tself.inflatechunks = null;\n\t\t\tself.inflatelock = false;\n\n\t\t\tif (self.current.body) {\n\t\t\t\tCONCAT[0] = self.current.body;\n\t\t\t\tCONCAT[1] = data;\n\t\t\t\tself.current.body = Buffer.concat(CONCAT);\n\t\t\t} else\n\t\t\t\tself.current.body = data;\n\n\t\t\t!buf.$continue && self.$decode();\n\t\t\tself.parseInflate();\n\t\t});\n\t}\n};\n\nWebSocketClientProto.$onerror = function(err) {\n\tthis.$events.error && this.emit('error', err);\n\tif (!this.isClosed) {\n\t\tthis.isClosed = true;\n\t\tthis.$onclose();\n\t}\n};\n\nWebSocketClientProto.$onclose = function() {\n\n\tif (this._isClosed)\n\t\treturn;\n\n\tthis.isClosed = true;\n\tthis._isClosed = true;\n\n\tif (this.inflate) {\n\t\tthis.inflate.removeAllListeners();\n\t\tthis.inflate = null;\n\t\tthis.inflatechunks = null;\n\t}\n\n\tif (this.deflate) {\n\t\tthis.deflate.removeAllListeners();\n\t\tthis.deflate = null;\n\t\tthis.deflatechunks = null;\n\t}\n\n\tthis.$events.close && this.emit('close', this.closecode, this.closemessage);\n\tthis.socket && this.socket.removeAllListeners();\n};\n\n/**\n * Sends a message\n * @param {String/Object} message\n * @param {Boolean} raw The message won't be converted e.g. to JSON.\n * @return {WebSocketClient}\n */\nWebSocketClientProto.send = function(message, raw, replacer) {\n\n\tif (this.isClosed)\n\t\treturn this;\n\n\tvar t = this.options.type;\n\n\tif (t !== 'binary' && t !== 'buffer') {\n\t\tvar data = t === 'json' ? (raw ? message : JSON.stringify(message, replacer)) : ((message == null ? '' : message) + '');\n\n\t\tif (this.options.encodedecode && data)\n\t\t\tdata = encodeURIComponent(data);\n\n\t\tif (this.deflate) {\n\t\t\tthis.deflatepending.push(Buffer.from(data, ENCODING));\n\t\t\tthis.sendDeflate();\n\t\t} else\n\t\t\tthis.socket.write(U.getWebSocketFrame(0, data, 0x01));\n\n\t} else if (message) {\n\t\tif (this.deflate) {\n\t\t\tthis.deflatepending.push(message);\n\t\t\tthis.sendDeflate();\n\t\t} else\n\t\t\tthis.socket.write(U.getWebSocketFrame(0, message, 0x02));\n\t}\n\n\treturn this;\n};\n\n/**\n * Sends a message\n * @param {String/Object} message\n * @param {Boolean} raw The message won't be converted e.g. to JSON.\n * @return {WebSocketClient}\n */\nWebSocketClientProto.sendcustom = function(type, message) {\n\n\tif (this.isClosed)\n\t\treturn this;\n\n\tif (type === 'binary' || type === 'buffer') {\n\t\tif (this.deflate) {\n\t\t\tthis.deflatepending.push(message);\n\t\t\tthis.sendDeflate();\n\t\t} else\n\t\t\tthis.socket.write(U.getWebSocketFrame(0, message, 0x02));\n\t} else {\n\t\tvar data = (message == null ? '' : message) + '';\n\t\tif (this.options.encodedecode && data)\n\t\t\tdata = encodeURIComponent(data);\n\t\tif (this.deflate) {\n\t\t\tthis.deflatepending.push(Buffer.from(data));\n\t\t\tthis.sendDeflate();\n\t\t} else\n\t\t\tthis.socket.write(U.getWebSocketFrame(0, data, 0x01));\n\t}\n\n\treturn this;\n};\n\nWebSocketClientProto.sendDeflate = function() {\n\tvar self = this;\n\n\tif (self.deflatelock)\n\t\treturn;\n\n\tvar buf = self.deflatepending.shift();\n\tif (buf) {\n\t\tself.deflatechunks = [];\n\t\tself.deflatechunkslength = 0;\n\t\tself.deflatelock = true;\n\t\tself.deflate.write(buf);\n\t\tself.deflate.flush(function() {\n\t\t\tif (self.deflatechunks) {\n\t\t\t\tvar data = buffer_concat(self.deflatechunks, self.deflatechunkslength);\n\t\t\t\tdata = data.slice(0, data.length - 4);\n\t\t\t\tself.deflatelock = false;\n\t\t\t\tself.deflatechunks = null;\n\t\t\t\tself.socket.write(U.getWebSocketFrame(0, data, self.type === 1 ? 0x02 : 0x01, true));\n\t\t\t\tself.sendDeflate();\n\t\t\t}\n\t\t});\n\t}\n};\n\n/**\n * Ping message\n * @return {WebSocketClient}\n */\nWebSocketClientProto.ping = function() {\n\tif (!this.isClosed) {\n\t\tthis.socket.write(U.getWebSocketFrame(0, '', 0x09));\n\t\tthis.$ping = false;\n\t}\n\treturn this;\n};\n\nfunction websocket_inflate(data) {\n\tthis.$websocket.inflatechunks.push(data);\n\tthis.$websocket.inflatechunkslength += data.length;\n}\n\nfunction websocket_deflate(data) {\n\tthis.$websocket.deflatechunks.push(data);\n\tthis.$websocket.deflatechunkslength += data.length;\n}\n\n/**\n * Close connection\n * @param {String} message Message.\n * @param {Number} code WebSocket code.\n * @return {WebSocketClient}\n */\nWebSocketClientProto.close = function(message, code) {\n\n\tif (message !== true) {\n\t\tthis.options.reconnect = 0;\n\t} else\n\t\tmessage = undefined;\n\n\tif (!this.isClosed) {\n\t\tthis.isClosed = true;\n\t\tthis.socket.end(U.getWebSocketFrame(code || 1000,  message ? (this.options.encodedecode ? encodeURIComponent(message) : message) : '', 0x08));\n\t}\n\treturn this;\n};\n\nfunction $decodeURIComponent(value) {\n\ttry\n\t{\n\t\treturn decodeURIComponent(value);\n\t} catch (e) {\n\t\treturn value;\n\t}\n}\n\nexports.create = function() {\n\treturn new WebSocketClient();\n};"
        }
      ]
    }
  ]
}