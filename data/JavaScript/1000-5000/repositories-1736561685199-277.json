{
  "metadata": {
    "timestamp": 1736561685199,
    "page": 277,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bendc/sprint",
      "stars": 4219,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": "*.swp\n.DS_Store\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014-2015 Benjamin De Cock\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.4609375,
          "content": "# Sprint.js\n\nSprint is a high-performance, 5KB (gzipped) DOM library for modern browsers. Sprint notably shines on bandwidth and resource constrained devices such as phones and tablets.\n\nSprint has a familiar, jQuery-like chainable API:\n\n```javascript\n$(\"div\").addClass(\"new\").append(\"<p>Hi Sprint</p>\");\n```\n\n## Philosophy\n\nSprint is an alternative—not a replacement—for jQuery. jQuery offers more features, handles more edge cases and supports more browsers. Sprint is just a thin layer making the DOM friendlier without sacrificing on performance.\n\n## Performance\n\nSprint relies on newer APIs supported by modern browsers (read: IE10+) and  optimizes a bunch of other things in order to provide you with fast DOM operations.\n\nHere are a few performance tests of some popular methods (Chrome 42, OS X 10.10.3) :\n\n### .add()\n\n![jsperf results](http://sprintjs.com/perf-tests/add.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-add)\n\n### .attr()\n\n![jsperf results](http://sprintjs.com/perf-tests/attr.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-attr)\n\n### .css()\n\n![jsperf results](http://sprintjs.com/perf-tests/css.png)\n\n[→ View on jsperf](http://jsperf.com/sprintjs-css)\n\n### .has()\n\n![jsperf results](http://sprintjs.com/perf-tests/has.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-has)\n\n### .map()\n\n![jsperf results](http://sprintjs.com/perf-tests/map.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-map)\n\n### .next()\n\n![jsperf results](http://sprintjs.com/perf-tests/next.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-next)\n\n### .not()\n\n![jsperf results](http://sprintjs.com/perf-tests/not.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-not)\n\n### .parents()\n\n![jsperf results](http://sprintjs.com/perf-tests/parents.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-parents)\n\n### .position()\n\n![jsperf results](http://sprintjs.com/perf-tests/position.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-position)\n\n### .slice()\n\n![jsperf results](http://sprintjs.com/perf-tests/slice.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-slice)\n\n### .text()\n\n![jsperf results](http://sprintjs.com/perf-tests/text.png)\n\n[→ View on jsperf](http://jsperf.com/sprint-js-text)\n\nThanks to its reduced feature set, Sprint is also a lot faster to parse and execute (about 40 times faster than jQuery).\n\n## API\n\nThe methods supported by Sprint are, for the most part, identical to jQuery's. The few small differences with jQuery are explained below. If nothing is mentioned, you can assume jQuery's documentation applies.\n\n* [add](http://api.jquery.com/add/)\n* [addClass](http://api.jquery.com/addClass/)\n* [after](http://api.jquery.com/after/)\n* [append](http://api.jquery.com/append/)\n* [appendTo](http://api.jquery.com/appendTo/)\n* [attr](http://api.jquery.com/attr/)\n* [before](http://api.jquery.com/before/)\n* [children](http://api.jquery.com/children/)\n* [clone](http://api.jquery.com/clone/)\n* [closest](http://api.jquery.com/closest/)\n* [css](http://api.jquery.com/css/)\n* [detach](http://api.jquery.com/detach/)\n* [each](http://api.jquery.com/each/)\n* [empty](http://api.jquery.com/empty/)\n* [eq](http://api.jquery.com/eq/)\n* [filter](http://api.jquery.com/filter/)\n* [find](http://api.jquery.com/find/)\n* [first](http://api.jquery.com/first/)\n* [get](http://api.jquery.com/get/)\n* [has](http://api.jquery.com/has/)\n* [hasClass](http://api.jquery.com/hasClass/)\n* [height](http://api.jquery.com/height/)\n* [html](http://api.jquery.com/html/)\n* [index](http://api.jquery.com/index/)\n* [insertAfter](http://api.jquery.com/insertAfter/)\n* [insertBefore](http://api.jquery.com/insertBefore/)\n* [is](http://api.jquery.com/is/)\n* [last](http://api.jquery.com/last/)\n* [map](http://api.jquery.com/map/)\n* [next](http://api.jquery.com/next/)\n* [nextAll](http://api.jquery.com/nextAll/)\n* [nextUntil](http://api.jquery.com/nextUntil/)\n* [not](http://api.jquery.com/not/)\n* [off](http://api.jquery.com/off/) - _no support for selector_\n* [offset](http://api.jquery.com/offset/)\n* [offsetParent](http://api.jquery.com/offsetParent/)\n* [on](http://api.jquery.com/on/) - _no support for selector and data_\n* [parent](http://api.jquery.com/parent/)\n* [parents](http://api.jquery.com/parents/)\n* [position](http://api.jquery.com/position/)\n* [prop](http://api.jquery.com/prop/)\n* [prepend](http://api.jquery.com/prepend/)\n* [prependTo](http://api.jquery.com/prependTo/)\n* [prev](http://api.jquery.com/prev/)\n* [prevAll](http://api.jquery.com/prevAll/)\n* [prevUntil](http://api.jquery.com/prevUntil/)\n* [ready](http://api.jquery.com/ready/)\n* [remove](http://api.jquery.com/remove/)\n* [removeAttr](http://api.jquery.com/removeAttr/)\n* [removeClass](http://api.jquery.com/removeClass/)\n* [removeProp](http://api.jquery.com/removeProp/)\n* [replaceAll](http://api.jquery.com/replaceAll/)\n* [replaceWith](http://api.jquery.com/replaceWith/)\n* [scrollLeft](http://api.jquery.com/scrollLeft/)\n* [scrollTop](http://api.jquery.com/scrollTop/)\n* [siblings](http://api.jquery.com/siblings/)\n* [size](http://api.jquery.com/size/)\n* [slice](http://api.jquery.com/slice/)\n* [text](http://api.jquery.com/text/)\n* [toggleClass](http://api.jquery.com/toggleClass/) - _no support for .toggleClass([switch])_\n* [trigger](http://api.jquery.com/trigger/) - _no support for Event object and extraParameters_\n* [unwrap](http://api.jquery.com/unwrap/)\n* [val](http://api.jquery.com/val/)\n* [width](http://api.jquery.com/width/)\n* [wrap](http://api.jquery.com/wrap/)\n* [wrapAll](http://api.jquery.com/wrapAll/)\n* [wrapInner](http://api.jquery.com/wrapInner/)\n"
        },
        {
          "name": "sprint.js",
          "type": "blob",
          "size": 39.8525390625,
          "content": "/*\n * Sprint JavaScript Library v0.9.2\n * http://sprintjs.com\n *\n * Copyright (c) 2014, 2015 Benjamin De Cock\n * Released under the MIT license\n * http://sprintjs.com/license\n */\n\nvar Sprint;\n\n(function() {\n  \"use strict\";\n\n  var addEventListeners = function(listeners, el) {\n    var sprintClone = Sprint(el)\n    var events = Object.keys(listeners)\n    var eventsLen = events.length\n\n    for (var i = 0; i < eventsLen; i++) {\n      var event = events[i]\n      var handlers = listeners[event]\n      var handlersLen = handlers.length\n\n      for (var j = 0; j < handlersLen; j++) {\n        sprintClone.on(event, handlers[j])\n      }\n    }\n  }\n\n  var addPx = (function() {\n    var noPx = [\n      \"animation-iteration-count\",\n      \"column-count\",\n      \"flex-grow\",\n      \"flex-shrink\",\n      \"font-weight\",\n      \"line-height\",\n      \"opacity\",\n      \"order\",\n      \"orphans\",\n      \"widows\",\n      \"z-index\"\n    ]\n    return function addPx(cssProperty, value) {\n      if (inArray(cssProperty, noPx)) return value\n      var stringValue = typeof value == \"string\" ? value : value.toString()\n      if (value && !/\\D/.test(stringValue)) {\n        stringValue += \"px\"\n      }\n      return stringValue\n    }\n  }())\n\n  var createDOM = function(HTMLString) {\n    var tmp = document.createElement(\"div\")\n    var tag = /[\\w:-]+/.exec(HTMLString)[0]\n    var inMap = wrapMap[tag]\n    var validHTML = HTMLString.trim()\n    if (inMap) {\n      validHTML = inMap.intro + validHTML + inMap.outro\n    }\n    tmp.insertAdjacentHTML(\"afterbegin\", validHTML)\n    var node = tmp.lastChild\n    if (inMap) {\n      var i = inMap.outro.match(/</g).length\n      while (i--) {\n        node = node.lastChild\n      }\n    }\n    // prevent tmp to be node's parentNode\n    tmp.textContent = \"\"\n    return node\n  }\n\n  var domMethods = {\n    afterbegin: function(el) {\n      this.insertBefore(el, this.firstChild)\n    },\n    afterend: function(el) {\n      var parent = this.parentElement\n      parent && parent.insertBefore(el, this.nextSibling)\n    },\n    beforebegin: function(el) {\n      var parent = this.parentElement\n      parent && parent.insertBefore(el, this)\n    },\n    beforeend: function(el) {\n      this.appendChild(el)\n    }\n  }\n\n  var duplicateEventListeners = function(el, clone) {\n    // Element nodes only\n    if (el.nodeType > 1) return\n\n    // Duplicate event listeners for the parent element...\n    var listeners = getEvents(el)\n    listeners && addEventListeners(listeners, clone)\n\n    // ... and its descendants.\n    var descendants = selectElements(\"*\", el)\n    var descendantsLen = descendants.length\n\n    // cloneDescendants is defined later to avoid calling selectElements() if not needed\n    var cloneDescendants\n\n    for (var i = 0; i < descendantsLen; i++) {\n      var listeners = getEvents(descendants[i])\n      if (!listeners) continue\n      if (!cloneDescendants) {\n        cloneDescendants = selectElements(\"*\", clone)\n      }\n      addEventListeners(listeners, cloneDescendants[i])\n    }\n  }\n\n  var findAncestors = function(startAtParent, limitToParent, limitToFirstMatch, selector, context) {\n    var dom = []\n    var self = this\n    this.each(function() {\n      var prt = startAtParent ? this.parentElement : this\n      while (prt) {\n        if (context && context == prt) break\n        if (!selector || self.is(selector, prt)) {\n          dom.push(prt)\n          if (limitToFirstMatch) break\n        }\n        if (limitToParent) break\n        prt = prt.parentElement\n      }\n    })\n    return Sprint(removeDuplicates(dom))\n  }\n\n  var getEventFromNamespace = function(event) {\n    return splitNamespaces(event)[0]\n  }\n\n  var getEvents = function(domElement) {\n    return domElement.sprintEventListeners\n  }\n\n  var getEventsToRemove = function(domElement, event) {\n    /*\n     * Returns an array with the sprintEventListeners events matching potentially\n     * incomplete event names passed to .off().\n     * Example: .off(\"click.myPlugin\") and .off(\"click.simple\") would both remove a\n     * \"click.myPlugin.simple\" event.\n     */\n    return Object.keys(getEvents(domElement)).filter(function(prop) {\n      return splitNamespaces(event).every(function(name) {\n        return inArray(name, splitNamespaces(prop))\n      })\n    })\n  }\n\n  var getSetDimension = function(obj, prop, value) {\n    // get\n    if (value == null) {\n      var el = obj.get(0)\n      if (!el || el.nodeType > 1) return\n      var capitalizedProp = prop[0].toUpperCase() + prop.substring(1)\n      // dimension of HTML document\n      if (el == document) {\n        var offset = root[\"offset\" + capitalizedProp]\n        var inner = window[\"inner\" + capitalizedProp]\n        return offset > inner ? offset : inner\n      }\n      // dimension of viewport\n      if (el == window) {\n        return window[\"inner\" + capitalizedProp]\n      }\n      // dimension of element\n      return el.getBoundingClientRect()[prop]\n    }\n\n    // set\n    var isFunction = typeof value == \"function\"\n    var stringValue = isFunction ? \"\" : addPx(prop, value)\n    return obj.each(function(index) {\n      if (this == document || this == window || this.nodeType > 1) return\n      if (isFunction) {\n        stringValue = addPx(prop, value.call(this, index, Sprint(this)[prop]()))\n      }\n      this.style[prop] = stringValue\n    })\n  }\n\n  var insertHTML = function(position, args) {\n    var argsLen = args.length\n    var contents = args\n\n    // reverse argument list for afterbegin and afterend\n    if (argsLen > 1 && position.indexOf(\"after\") > -1) {\n      contents = []\n      var i = argsLen\n      while (i--) {\n        contents.push(args[i])\n      }\n    }\n\n    for (var i = 0; i < argsLen; i++) {\n      var content = contents[i]\n      if (typeof content == \"string\" || typeof content == \"number\") {\n        this.each(function() {\n          this.insertAdjacentHTML(position, content)\n        })\n      }\n      else if (typeof content == \"function\") {\n        this.each(function(index) {\n          var callbackValue = content.call(this, index, this.innerHTML)\n          insertHTML.call(Sprint(this), position, [callbackValue])\n        })\n      }\n      else {\n        var isSprintObj = content instanceof Init\n        var clonedElements = []\n        var elementsToInsert = (function() {\n          if (isSprintObj) {\n            return content.get()\n          }\n          if (Array.isArray(content)) {\n            return sanitize(content, true, true)\n          }\n          // DOM node\n          if (content.nodeType) {\n            return [content]\n          }\n          // getElementsByTagName, getElementsByClassName, querySelectorAll\n          return toArray(content)\n        }())\n        var elementsToInsertLen = elementsToInsert.length\n\n        this.each(function(index) {\n          /*\n           * The fragment serves multiple purposes:\n           * 1) It significantly boosts perf when multiple elements are added.\n           * 2) It avoids the need for elementsToInsert.reverse() for afterbegin and afterend\n           * 3) It removes an element from its original position before adding it back, which is\n           * especially useful for elements not part of the DOM tree. That means it's important even\n           * when elementsToInsertLen == 1.\n           */\n          var fragment = document.createDocumentFragment()\n          for (var i = 0; i < elementsToInsertLen; i++) {\n            var element = elementsToInsert[i]\n            var elementToInsert\n            if (index) {\n              elementToInsert = element.cloneNode(true)\n              duplicateEventListeners(element, elementToInsert)\n            }\n            else {\n              elementToInsert = element\n            }\n            fragment.appendChild(elementToInsert)\n            clonedElements.push(elementToInsert)\n          }\n          domMethods[position].call(this, fragment)\n        })\n\n        if (isSprintObj) {\n          content.dom = clonedElements\n          content.length = clonedElements.length\n        }\n        if (i < argsLen-1) continue\n        return clonedElements\n      }\n    }\n  }\n\n  var inArray = function(el, arr) {\n    var i = arr.length\n    while (i--) {\n      if (arr[i] === el) return true\n    }\n    return false\n  }\n\n  var isNamespaced = function(event) {\n    return /\\./.test(event)\n  }\n\n  var manipulateClass = function(method, className, bool) {\n    if (className == null) {\n      if (method == \"add\") {\n        return this\n      }\n      return this.removeAttr(\"class\")\n    }\n\n    var isString\n    var classNames\n    var classNamesLen\n\n    if (typeof className == \"string\") {\n      isString = true\n      classNames = className.trim().split(\" \")\n      classNamesLen = classNames.length\n    }\n\n    return this.each(function(i, el) {\n      if (this.nodeType > 1) return\n      if (!isString) {\n        // className is a function\n        var callbackValue = className.call(el, i, el.className)\n        if (!callbackValue) return\n        classNames = callbackValue.trim().split(\" \")\n        classNamesLen = classNames.length\n      }\n      for (var j = 0; j < classNamesLen; j++) {\n        var name = classNames[j]\n        if (!name) continue\n        bool == null\n          ? el.classList[method](name)\n          : el.classList.toggle(name, bool)\n      }\n    })\n  }\n\n  var matches = (function() {\n    var names = [\n      \"mozMatchesSelector\",\n      \"webkitMatchesSelector\",\n      \"msMatchesSelector\",\n      \"matches\"\n    ]\n    var i = names.length\n    while (i--) {\n      var name = names[i]\n      if (!Element.prototype[name]) continue\n      return name\n    }\n  }())\n\n  var removeDuplicates = function(arr) {\n    var clean = []\n    var cleanLen = 0\n    var arrLen = arr.length\n\n    for (var i = 0; i < arrLen; i++) {\n      var el = arr[i]\n      var duplicate = false\n\n      for (var j = 0; j < cleanLen; j++) {\n        if (el !== clean[j]) continue\n        duplicate = true\n        break\n      }\n\n      if (duplicate) continue\n      clean[cleanLen++] = el\n    }\n\n    return clean\n  }\n\n  var removeEvent = (function() {\n    var isHandlerShared = function(el, event, registeredHandler) {\n      var similarEventsHandlers = Object.keys(getEvents(el)).filter(function(prop) {\n        return getEventFromNamespace(event) === getEventFromNamespace(prop)\n      }).map(function(ev) {\n        return getEvents(el)[ev]\n      }).reduce(function(a, b) {\n        return a.concat(b)\n      }).filter(function(handler) {\n        return handler === registeredHandler\n      })\n      if (similarEventsHandlers.length < 2) return false\n      return true\n    }\n    var removeListener = function(el, event, namedHandler) {\n      return function(registeredHandler) {\n        if (namedHandler && namedHandler !== registeredHandler) return\n        el.removeEventListener(event, registeredHandler)\n        if (!isNamespaced(event) || isHandlerShared(el, event, registeredHandler)) return\n        el.removeEventListener(getEventFromNamespace(event), registeredHandler)\n      }\n    }\n    var clearRegisteredHandlers = function(registeredHandlers, namedHandler) {\n      return registeredHandlers.filter(function(handler) {\n        return namedHandler && namedHandler !== handler\n      })\n    }\n    return function(el, namedHandler) {\n      return function(event) {\n        getEvents(el)[event].forEach(removeListener(el, event, namedHandler))\n        getEvents(el)[event] = clearRegisteredHandlers(getEvents(el)[event], namedHandler)\n      }\n    }\n  }())\n\n  var removeMatchedEvents = function(el, namedHandler) {\n    return function(event) {\n      getEventsToRemove(el, event).forEach(removeEvent(el, namedHandler))\n    }\n  }\n\n  var root = document.documentElement\n\n  var sanitize = function(arr, flattenObjects, requireDomNodes) {\n    /*\n     * Remove null's from array. Optionally, flatten Sprint objects and convert strings and numbers\n     * to DOM text nodes.\n     */\n    var arrLen = arr.length\n    var i = arrLen\n\n    // Check if arr needs to be sanitized first (significant perf boost for the most common case)\n    while (i--) {\n      // arr needs to be sanitized\n      if ( (!arr[i] && arr[i] !== 0)\n        || (flattenObjects && arr[i] instanceof Init)\n        || (requireDomNodes && (typeof arr[i] == \"string\" || typeof arr[i] == \"number\"))\n      ) {\n        var sanitized = []\n        for (var j = 0; j < arrLen; j++) {\n          var el = arr[j]\n          if (!el && el !== 0) continue\n          if (flattenObjects && el instanceof Init) {\n            for (var k = 0; k < el.length; k++) {\n              sanitized.push(el.get(k))\n            }\n            continue\n          }\n          if (requireDomNodes && (typeof el == \"string\" || typeof el == \"number\")) {\n            sanitized.push(document.createTextNode(el))\n            continue\n          }\n          sanitized.push(el)\n        }\n        return sanitized\n      }\n    }\n\n    // arr didn't need to be sanitized, return it\n    return arr\n  }\n\n  var scroll = (function() {\n    var scrollRoot\n    return function(sprintObj, method, value) {\n      // define scroll root element on first run\n      if (!scrollRoot) {\n        var initialScrollPos = root.scrollTop\n        root.scrollTop = initialScrollPos + 1\n        var updatedScrollPos = root.scrollTop\n        root.scrollTop = initialScrollPos\n        scrollRoot = updatedScrollPos > initialScrollPos\n          ? root // spec-compliant browsers (like FF34 and IE11)\n          : document.body // naughty boys (like Chrome 39 and Safari 8)\n      }\n\n      // get scroll position\n      if (value == null) {\n        var el = sprintObj.get(0)\n        if (!el) return\n        if (el == window || el == document) {\n          el = scrollRoot\n        }\n        return el[method]\n      }\n\n      // set scroll position\n      return sprintObj.each(function() {\n        var el = this\n        if (el == window || el == document) {\n          el = scrollRoot\n        }\n        el[method] = value\n      })\n    }\n  }())\n\n  var selectAdjacentSiblings = function(sprintObj, direction, selector, until) {\n    var dom = []\n    var prop = direction + \"ElementSibling\"\n    sprintObj.each(function() {\n      var el = this\n      while (el = el[prop]) {\n        if (until && sprintObj.is(until, el)) break\n        if (selector && !sprintObj.is(selector, el)) continue\n        dom.push(el)\n      }\n    })\n    return Sprint(removeDuplicates(dom))\n  }\n\n  var selectImmediateAdjacentSibling = function(sprintObj, direction, selector) {\n    var prop = direction + \"ElementSibling\"\n    return sprintObj.map(function() {\n      var el = this[prop]\n      if (!el || (selector && !sprintObj.is(selector, el))) return\n      return el\n    }, false)\n  }\n\n  var selectElements = function(selector, context) {\n    context = context || document\n    // class, id, tag name or universal selector\n    if (/^[\\#.]?[\\w-]+$/.test(selector)) {\n      var firstChar = selector[0]\n      if (firstChar == \".\") {\n        return toArray(context.getElementsByClassName(selector.slice(1)))\n      }\n      if (firstChar == \"#\") {\n        var el = context.getElementById(selector.slice(1))\n        return el ? [el] : []\n      }\n      if (selector == \"body\") {\n        return [document.body]\n      }\n      return toArray(context.getElementsByTagName(selector))\n    }\n    return toArray(context.querySelectorAll(selector))\n  }\n\n  var splitNamespaces = function(event) {\n    return sanitize(event.split(\".\"))\n  }\n\n  var toArray = function(obj) {\n    var arr = []\n    var i = obj.length\n    while (i--) {\n      arr[i] = obj[i]\n    }\n    return arr\n  }\n\n  var wrap = (function() {\n    var callback = function(wrappingElement, variant) {\n      var wrap = Sprint(wrappingElement).clone(true).get(0)\n      var innerWrap = wrap\n      if (!wrap || this.nodeType > 1) return\n      while (innerWrap.firstChild) {\n        innerWrap = innerWrap.firstChild\n      }\n      if (variant == \"inner\") {\n        while (this.firstChild) {\n          innerWrap.appendChild(this.firstChild)\n        }\n        this.appendChild(wrap)\n      }\n      else {\n        var el = variant == \"all\" ? this.get(0) : this\n        var prt = el.parentNode\n        var next = el.nextSibling\n        variant == \"all\"\n          ? this.each(function() { innerWrap.appendChild(this) })\n          : innerWrap.appendChild(el)\n        prt.insertBefore(wrap, next)\n      }\n    }\n    return function(wrappingElement, variant) {\n      if (typeof wrappingElement == \"function\") {\n        this.each(function(i) {\n          Sprint(this)[variant == \"inner\" ? \"wrapInner\" : \"wrap\"](wrappingElement.call(this, i))\n        })\n      }\n      else {\n        variant == \"all\"\n          ? callback.call(this, wrappingElement, variant)\n          : this.each(function() { callback.call(this, wrappingElement, variant) })\n      }\n      return this\n    }\n  }())\n\n  var wrapMap = {\n    legend: {\n      intro: \"<fieldset>\",\n      outro: \"</fieldset>\"\n    },\n    area: {\n      intro: \"<map>\",\n      outro: \"</map>\"\n    },\n    param: {\n      intro: \"<object>\",\n      outro: \"</object>\"\n    },\n    thead: {\n      intro: \"<table>\",\n      outro: \"</table>\"\n    },\n    tr: {\n      intro: \"<table><tbody>\",\n      outro: \"</tbody></table>\"\n    },\n    col: {\n      intro: \"<table><tbody></tbody><colgroup>\",\n      outro: \"</colgroup></table>\"\n    },\n    td: {\n      intro: \"<table><tbody><tr>\",\n      outro: \"</tr></tbody></table>\"\n    }\n  };\n  // elements needing a construct already defined by other elements\n  [\"tbody\", \"tfoot\", \"colgroup\", \"caption\"].forEach(function(tag) {\n    wrapMap[tag] = wrapMap.thead\n  })\n  wrapMap.th = wrapMap.td\n\n  // constructor\n\n  var Init = function(selector, context) {\n    if (typeof selector == \"string\") {\n      // create DOM element\n      if (selector[0] == \"<\") {\n        this.dom = [createDOM(selector)]\n      }\n      // select DOM elements\n      else {\n        this.dom = context && context instanceof Init\n          ? context.find(selector).get()\n          : selectElements(selector, context)\n      }\n    }\n    else if (Array.isArray(selector)) {\n      this.dom = sanitize(selector)\n    }\n    else if (\n      selector instanceof NodeList ||\n      selector instanceof HTMLCollection\n    ) {\n      this.dom = toArray(selector)\n    }\n    else if (selector instanceof Init) {\n      return selector\n    }\n    else if (typeof selector == \"function\") {\n      return this.ready(selector)\n    }\n    else {\n      // assume DOM node\n      this.dom = selector ? [selector] : []\n    }\n    this.length = this.dom.length\n  }\n\n  Init.prototype = {\n    add: function(selector) {\n      var dom = this.get()\n      var objToAdd = Sprint(selector)\n      var domToAdd = objToAdd.get()\n      for (var i = 0; i < objToAdd.length; i++) {\n        dom.push(domToAdd[i])\n      }\n      return Sprint(removeDuplicates(dom))\n    },\n    addClass: function(className) {\n      return manipulateClass.call(this, \"add\", className)\n    },\n    after: function() {\n      insertHTML.call(this, \"afterend\", arguments)\n      return this\n    },\n    append: function() {\n      insertHTML.call(this, \"beforeend\", arguments)\n      return this\n    },\n    appendTo: function(target) {\n      return Sprint(insertHTML.call(Sprint(target), \"beforeend\", [this]))\n    },\n    attr: function(name, value) {\n      var isFunc = typeof value == \"function\"\n      if (typeof value == \"string\" || typeof value == \"number\" || isFunc) {\n        return this.each(function(i) {\n          if (this.nodeType > 1) return\n          this.setAttribute(\n            name, isFunc ? value.call(this, i, this.getAttribute(name)) : value\n          )\n        })\n      }\n      if (typeof name == \"object\") {\n        var attrNames = Object.keys(name)\n        var attrNamesLen = attrNames.length\n        return this.each(function() {\n          if (this.nodeType > 1) return\n          for (var i = 0; i < attrNamesLen; i++) {\n            var attribute = attrNames[i]\n            this.setAttribute(attribute, name[attribute])\n          }\n        })\n      }\n      var el = this.get(0)\n      if (!el || el.nodeType > 1) return\n      var attrValue = el.getAttribute(name)\n      if (attrValue == null) {\n        return undefined\n      }\n      if (!attrValue) {\n        return name\n      }\n      return attrValue\n    },\n    before: function() {\n      insertHTML.call(this, \"beforebegin\", arguments)\n      return this\n    },\n    children: function(selector) {\n      var dom = []\n      var self = this\n      this.each(function() {\n        if (this.nodeType > 1) return\n        var nodes = this.children\n        var nodesLen = nodes.length\n        for (var i = 0; i < nodesLen; i++) {\n          var node = nodes[i]\n          if (!selector || self.is(selector, node)) {\n            dom.push(node)\n          }\n        }\n      })\n      return Sprint(dom)\n    },\n    clone: function(withEvents) {\n      return this.map(function() {\n        if (!this) return\n        var clone = this.cloneNode(true)\n        withEvents && duplicateEventListeners(this, clone)\n        return clone\n      }, false)\n    },\n    closest: function(selector, context) {\n      return findAncestors.call(this, false, false, true, selector, context)\n    },\n    css: function(property, value) {\n      var valueType = typeof value\n      var isString = valueType == \"string\"\n\n      // set\n      if (isString || valueType == \"number\") {\n        var isRelativeValue = isString && /=/.test(value)\n        if (isRelativeValue) {\n          var relativeValue = parseInt(value[0] + value.slice(2))\n        }\n        return this.each(function() {\n          if (this.nodeType > 1) return\n          if (isRelativeValue) {\n            var current = parseInt(getComputedStyle(this).getPropertyValue(property))\n            var result = current + relativeValue\n          }\n          this.style[property] = addPx(property, isRelativeValue ? result : value)\n        })\n      }\n      // set\n      if (valueType == \"function\") {\n        return this.each(function(index) {\n          if (this.nodeType > 1) return\n          var oldValue = getComputedStyle(this).getPropertyValue(property)\n          this.style[property] = value.call(this, index, oldValue)\n        })\n      }\n      // read\n      if (typeof property == \"string\") {\n        var el = this.get(0)\n        if (!el || el.nodeType > 1) return\n        return getComputedStyle(el).getPropertyValue(property)\n      }\n      // read\n      if (Array.isArray(property)) {\n        var el = this.get(0)\n        if (!el || el.nodeType > 1) return\n        var o = {}\n        var styles = getComputedStyle(el)\n        var propertyLen = property.length\n        for (var i = 0; i < propertyLen; i++) {\n          var prop = property[i]\n          o[prop] = styles.getPropertyValue(prop)\n        }\n        return o\n      }\n      // set\n      var properties = Object.keys(property)\n      var propertiesLen = properties.length\n      return this.each(function() {\n        if (this.nodeType > 1) return\n        for (var i = 0; i < propertiesLen; i++) {\n          var prop = properties[i]\n          this.style[prop] = addPx(prop, property[prop])\n        }\n      })\n    },\n    detach: function() {\n      return this.map(function() {\n        var parent = this.parentElement\n        if (!parent) return\n        parent.removeChild(this)\n        return this\n      }, false)\n    },\n    each: function(callback) {\n      // callback(index, element) where element == this\n      var dom = this.dom\n      var len = this.length\n      for (var i = 0; i < len; i++) {\n        var node = dom[i]\n        callback.call(node, i, node)\n      }\n      return this\n    },\n    empty: function() {\n      return this.each(function() {\n        this.innerHTML = \"\"\n      })\n    },\n    eq: function(index) {\n      return Sprint(this.get(index))\n    },\n    filter: function(selector) {\n      var isFunc = typeof selector == \"function\"\n      var self = this\n      return this.map(function(i) {\n        if ( this.nodeType > 1\n          || (!isFunc && !self.is(selector, this))\n          || (isFunc && !selector.call(this, i, this))\n        ) return\n        return this\n      }, false)\n    },\n    find: function(selector) {\n      // .find(selector)\n      if (typeof selector == \"string\") {\n        var dom = []\n        this.each(function() {\n          if (this.nodeType > 1) return\n          var elements = selectElements(selector, this)\n          var elementsLen = elements.length\n          for (var i = 0; i < elementsLen; i++) {\n            dom.push(elements[i])\n          }\n        })\n        return Sprint(removeDuplicates(dom))\n      }\n\n      // .find(element)\n      var elementsToFind = selector.nodeType ? [selector] : selector.get()\n      var elementsToFindLen = elementsToFind.length\n      var elementsFound = []\n      var elementsFoundLen = 0\n\n      for (var i = 0; i < this.length; i++) {\n        var el = this.get(i)\n        if (el.nodeType > 1) continue\n        // check if each element in `this` contains the elements to find\n        for (var j = 0; j < elementsToFindLen; j++) {\n          var elementToFind = elementsToFind[j]\n          if (!el.contains(elementToFind)) continue\n          elementsFound[elementsFoundLen++] = elementToFind\n          if (elementsFoundLen < elementsToFindLen) continue\n          // everything has been found, return results\n          return Sprint(elementsFound)\n        }\n      }\n\n      // some elements in elementsToFind weren't descendants of `this`\n      return Sprint(elementsFound)\n    },\n    first: function() {\n      return this.eq(0)\n    },\n    get: function(index) {\n      if (index == null) {\n        return this.dom\n      }\n      if (index < 0) {\n        index += this.length\n      }\n      return this.dom[index]\n    },\n    has: function(selector) {\n      // .has(selector)\n      if (typeof selector == \"string\") {\n        return this.map(function() {\n          if (this.nodeType > 1 || !selectElements(selector, this)[0]) return\n          return this\n        }, false)\n      }\n\n      // .has(contained)\n      var result = []\n      var i = this.length\n      while (i--) {\n        var el = this.get(i)\n        if (!el.contains(selector)) continue\n        result.push(el)\n        break\n      }\n      return Sprint(result)\n    },\n    hasClass: function(name) {\n      var i = this.length\n      while (i--) {\n        var el = this.get(i)\n        if (el.nodeType > 1) return\n        if (el.classList.contains(name)) {\n          return true\n        }\n      }\n      return false\n    },\n    height: function(value) {\n      return getSetDimension(this, \"height\", value)\n    },\n    html: function(htmlString) {\n      if (htmlString == null) {\n        var el = this.get(0)\n        if (!el) return\n        return el.innerHTML\n      }\n      if (typeof htmlString == \"function\") {\n        return this.each(function(i) {\n          var content = htmlString.call(this, i, this.innerHTML)\n          Sprint(this).html(content)\n        })\n      }\n      return this.each(function() {\n        this.innerHTML = htmlString\n      })\n    },\n    index: function(el) {\n      if (!this.length) return\n      var toFind\n      var sprintElements\n      if (!el) {\n        toFind = this.get(0)\n        sprintElements = this.first().parent().children()\n      }\n      else if (typeof el == \"string\") {\n        toFind = this.get(0)\n        sprintElements = Sprint(el)\n      }\n      else {\n        toFind = el instanceof Init ? el.get(0) : el\n        sprintElements = this\n      }\n      var elements = sprintElements.get()\n      var i = elements.length\n      while (i--) {\n        if (elements[i] == toFind) {\n          return i\n        }\n      }\n      return -1\n    },\n    insertAfter: function(target) {\n      Sprint(target).after(this)\n      return this\n    },\n    insertBefore: function(target) {\n      Sprint(target).before(this)\n      return this\n    },\n    is: function(selector, element) {\n      // element is undocumented, internal-use only.\n      // It gives better perfs as it prevents the creation of many objects in internal methods.\n      var set = element ? [element] : this.get()\n      var setLen = set.length\n\n      if (typeof selector == \"string\") {\n        for (var i = 0; i < setLen; i++) {\n          var el = set[i]\n          if (el.nodeType > 1) continue\n          if (el[matches](selector)) {\n            return true\n          }\n        }\n        return false\n      }\n      if (typeof selector == \"object\") {\n        // Sprint object or DOM element(s)\n        var obj\n        if (selector instanceof Init) {\n          obj = selector.get()\n        }\n        else {\n          obj = selector.length ? selector : [selector]\n        }\n        var objLen = obj.length\n        for (var i = 0; i < setLen; i++) {\n          for (var j = 0; j < objLen; j++) {\n            if (set[i] === obj[j]) {\n              return true\n            }\n          }\n        }\n        return false\n      }\n      if (typeof selector == \"function\") {\n        for (var i = 0; i < setLen; i++) {\n          if (selector.call(this, i, this)) {\n            return true\n          }\n        }\n        return false\n      }\n    },\n    last: function() {\n      return this.eq(-1)\n    },\n    map: function(callback, flattenArrays) {\n      /*\n       * flattenArrays (bool, true by default) is for internal usage only (although it might be\n       * interesting to document it publicly).\n       * Many methods rely on map(), thus being able to avoid the unnecessary Array.isArray() check\n       * on each element is a significant perf boost.\n       */\n      if (flattenArrays == null) {\n        flattenArrays = true\n      }\n\n      var dom = this.get()\n      var len = this.length\n      var values = []\n\n      for (var i = 0; i < len; i++) {\n        var el = dom[i]\n        var val = callback.call(el, i, el)\n\n        if (flattenArrays && Array.isArray(val)) {\n          var valLen = val.length\n          for (var j = 0; j < valLen; j++) {\n            values.push(val[j])\n          }\n          continue\n        }\n\n        values.push(val)\n      }\n\n      return Sprint(values)\n    },\n    next: function(selector) {\n      return selectImmediateAdjacentSibling(this, \"next\", selector)\n    },\n    nextAll: function(selector) {\n      return selectAdjacentSiblings(this, \"next\", selector)\n    },\n    nextUntil: function(selector, filter) {\n      return selectAdjacentSiblings(this, \"next\", filter, selector)\n    },\n    not: function(selector) {\n      var isFunc = typeof selector == \"function\"\n      var self = this\n      return this.map(function(i) {\n        if (isFunc) {\n          if (selector.call(this, i, this)) return\n        }\n        else {\n          if (self.is(selector, this)) return\n        }\n        return this\n      }, false)\n    },\n    off: function(events, handler) {\n      if (typeof events == \"object\") {\n        Object.keys(events).forEach(function(event) {\n          this.off(event, events[event])\n        }, this)\n        return this\n      }\n      if (events) {\n        events = events.trim().split(\" \")\n      }\n      return this.each(function() {\n        if (!getEvents(this)) return\n        if (events) {\n          events.forEach(removeMatchedEvents(this, handler))\n          return\n        }\n        Object.keys(getEvents(this)).forEach(removeEvent(this))\n      })\n    },\n    offset: function(coordinates) {\n      if (!coordinates) {\n        var el = this.get(0)\n        if (!el || el.nodeType > 1) return\n        var pos = el.getBoundingClientRect()\n        return {\n          top: pos.top,\n          left: pos.left\n        }\n      }\n      if (typeof coordinates == \"object\") {\n        return this.each(function() {\n          if (this.nodeType > 1) return\n          var $this = Sprint(this)\n          $this.css(\"position\") == \"static\"\n            ? $this.css(\"position\", \"relative\")\n            : $this.css({\n              top: 0,\n              left: 0\n            })\n          var pos = $this.offset()\n          $this.css({\n            top: coordinates.top - pos.top + \"px\",\n            left: coordinates.left - pos.left + \"px\"\n          })\n        })\n      }\n      if (typeof coordinates == \"function\") {\n        return this.each(function(i) {\n          var $this = Sprint(this)\n          var posObj = coordinates.call(this, i, $this.offset())\n          $this.offset(posObj)\n        })\n      }\n    },\n    offsetParent: function() {\n      var dom = []\n      this.each(function() {\n        if (this.nodeType > 1) return\n        var prt = this\n        while (prt != root) {\n          prt = prt.parentNode\n          var pos = getComputedStyle(prt).getPropertyValue(\"position\")\n          if (!pos) break\n          if (pos != \"static\") {\n            dom.push(prt)\n            return\n          }\n        }\n        dom.push(root)\n      })\n      return Sprint(dom)\n    },\n    on: function(events, handler) {\n      // .on(events, handler)\n      if (handler) {\n        var eventsArr = events.trim().split(\" \")\n\n        return this.each(function() {\n          if (!getEvents(this)) {\n            this.sprintEventListeners = {}\n          }\n          eventsArr.forEach(function(event) {\n            if (!getEvents(this)[event]) {\n              getEvents(this)[event] = []\n            }\n            getEvents(this)[event].push(handler)\n\n            // Ensure we add both the standard event (eg: \"click\") and the full event\n            // (eg: \"click.foo\") in order to be able to trigger them manually and programmatically.\n            this.addEventListener(event, handler)\n            if (!isNamespaced(event)) return\n            this.addEventListener(getEventFromNamespace(event), handler)\n          }, this)\n        })\n      }\n\n      // .on({ event: handler })\n      Object.keys(events).forEach(function(event) {\n        this.on(event, events[event])\n      }, this)\n      return this\n    },\n    parent: function(selector) {\n      return findAncestors.call(this, true, true, false, selector)\n    },\n    parents: function(selector) {\n      /* Differences with jQuery:\n       * 1. $(\"html\").parent() and $(\"html\").parents() return an empty set.\n       * 2. The returned set won't be in reverse order.\n       */\n      return findAncestors.call(this, true, false, false, selector)\n    },\n    position: function() {\n      var pos = {\n        first: this.offset(),\n        prt: this.parent().offset()\n      }\n      if (!pos.first) return\n      return {\n        top: pos.first.top - pos.prt.top,\n        left: pos.first.left - pos.prt.left\n      }\n    },\n    prop: function(propertyName, value) {\n      if (typeof propertyName == \"object\") {\n        var props = Object.keys(propertyName)\n        var propsLen = props.length\n        return this.each(function() {\n          for (var i = 0; i < propsLen; i++) {\n            var prop = props[i]\n            this[prop] = propertyName[prop]\n          }\n        })\n      }\n      if (value == null) {\n        var el = this.get(0)\n        if (!el) return\n        return el[propertyName]\n      }\n      var isFunc = typeof value == \"function\"\n      return this.each(function(i) {\n        this[propertyName] = isFunc ? value.call(this, i, this[propertyName]) : value\n      })\n    },\n    prepend: function() {\n      insertHTML.call(this, \"afterbegin\", arguments)\n      return this\n    },\n    prependTo: function(target) {\n      return Sprint(insertHTML.call(Sprint(target), \"afterbegin\", [this]))\n    },\n    prev: function(selector) {\n      return selectImmediateAdjacentSibling(this, \"previous\", selector)\n    },\n    prevAll: function(selector) {\n      return selectAdjacentSiblings(this, \"previous\", selector)\n    },\n    prevUntil: function(selector, filter) {\n      return selectAdjacentSiblings(this, \"previous\", filter, selector)\n    },\n    ready: function(handler) {\n      this.dom = [document]\n      this.length = 1\n      return this.on(\"DOMContentLoaded\", handler)\n    },\n    remove: function(selector) {\n      var self = this\n      return this.each(function() {\n        var parent = this.parentElement\n        if (!parent) return\n        if (!selector || self.is(selector, this)) {\n          parent.removeChild(this)\n        }\n      })\n    },\n    removeAttr: function(attributeName) {\n      if (attributeName) {\n        var attributes = attributeName.trim().split(\" \")\n        var attributesLen = attributes.length\n        this.each(function() {\n          if (this.nodeType > 1) return\n          for (var i = 0; i < attributesLen; i++) {\n            this.removeAttribute(attributes[i])\n          }\n        })\n      }\n      return this\n    },\n    removeClass: function(className) {\n      return manipulateClass.call(this, \"remove\", className)\n    },\n    removeProp: function(propertyName) {\n      return this.each(function() {\n        this[propertyName] = undefined\n      })\n    },\n    replaceAll: function(target) {\n      Sprint(target).replaceWith(this)\n      return this\n    },\n    replaceWith: function(newContent) {\n      if (typeof newContent == \"function\") {\n        return this.each(function(i) {\n          Sprint(this).replaceWith(newContent.call(this, i, this))\n        })\n      }\n      return this.before(newContent).remove()\n    },\n    scrollLeft: function(value) {\n      return scroll(this, \"scrollLeft\", value)\n    },\n    scrollTop: function(value) {\n      return scroll(this, \"scrollTop\", value)\n    },\n    siblings: function(selector) {\n      var siblings = []\n      var self = this\n      this.each(function(i, el) {\n        Sprint(this).parent().children().each(function() {\n          if (this == el || (selector && !self.is(selector, this))) return\n          siblings.push(this)\n        })\n      })\n      return Sprint(siblings)\n    },\n    size: function() {\n      return this.length\n    },\n    slice: function(start, end) {\n      var dom = this.get()\n      var range = []\n      var i = start >= 0 ? start : start + this.length\n      var l = this.length\n      if (end < 0) {\n        l += end\n      }\n      else if (end >= 0) {\n        l = end > this.length ? this.length : end\n      }\n      for (; i < l; i++) {\n        range.push(dom[i])\n      }\n      return Sprint(range)\n    },\n    text: function(content) {\n      if (content == null) {\n        var textContents = []\n        this.each(function() {\n          textContents.push(this.textContent)\n        })\n        return textContents.join(\"\")\n      }\n      var isFunc = typeof content == \"function\"\n      return this.each(function(i) {\n        this.textContent = isFunc ? content.call(this, i, this.textContent) : content\n      })\n    },\n    toggleClass: function(className, bool) {\n      return manipulateClass.call(this, \"toggle\", className, bool)\n    },\n    trigger: function(event) {\n      // IE polyfill\n      if (!window.CustomEvent || typeof window.CustomEvent !== \"function\") {\n        var CustomEvent = function(event, params) {\n          var evt\n          params = params || {\n            bubbles: false,\n            cancelable: false,\n            detail: undefined\n          }\n          evt = document.createEvent(\"CustomEvent\")\n          evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\n          return evt\n        }\n        CustomEvent.prototype = window.Event.prototype\n        window.CustomEvent = CustomEvent\n      }\n      return this.each(function() {\n        getEventsToRemove(this, event).forEach(function(matchedEvent) {\n          this.dispatchEvent(new CustomEvent(matchedEvent, {\n            bubbles: true,\n            cancelable: true\n          }))\n        }, this)\n      })\n    },\n    unwrap: function() {\n      this.parent().each(function() {\n        if (this == document.body || this == root) return\n        Sprint(this).replaceWith(this.childNodes)\n      })\n      return this\n    },\n    val: function(value) {\n      if (value == null) {\n        var el = this.get(0)\n        if (!el) return\n        if (el.multiple) {\n          var values = []\n          this.first().children(\":checked\").each(function() {\n            values.push(this.value)\n          })\n          return values\n        }\n        return el.value\n      }\n      if (Array.isArray(value)) {\n        var self = this\n        return this.each(function() {\n          if (this.multiple) {\n            self.children().each(function() {\n              this.selected = inArray(this.value, value)\n            })\n            return\n          }\n          this.checked = inArray(this.value, value)\n        })\n      }\n      if (typeof value == \"function\") {\n        return this.each(function(i) {\n          Sprint(this).val(value.call(this, i, this.value))\n        })\n      }\n      return this.each(function() {\n        this.value = value\n      })\n    },\n    width: function(value) {\n      return getSetDimension(this, \"width\", value)\n    },\n    wrap: function(wrappingElement) {\n      return wrap.call(this, wrappingElement)\n    },\n    wrapAll: function(wrappingElement) {\n      return wrap.call(this, wrappingElement, \"all\")\n    },\n    wrapInner: function(wrappingElement) {\n      return wrap.call(this, wrappingElement, \"inner\")\n    }\n  }\n\n  // public\n\n  Sprint = function(selector, context) {\n    return new Init(selector, context)\n  }\n\n  if (window.$ == null) {\n    window.$ = Sprint\n  }\n}());\n"
        },
        {
          "name": "sprint.min.js",
          "type": "blob",
          "size": 16.3544921875,
          "content": "// Sprint v0.9.2 - sprintjs.com/license\nvar Sprint;\n(function(){var D=function(a,b){for(var c=Sprint(b),d=Object.keys(a),e=d.length,f=0;f<e;f++)for(var g=d[f],h=a[g],k=h.length,l=0;l<k;l++)c.on(g,h[l])},w=function(){var a=\"animation-iteration-count column-count flex-grow flex-shrink font-weight line-height opacity order orphans widows z-index\".split(\" \");return function(b,c){if(v(b,a))return c;var d=\"string\"==typeof c?c:c.toString();c&&!/\\D/.test(d)&&(d+=\"px\");return d}}(),K={afterbegin:function(a){this.insertBefore(a,this.firstChild)},afterend:function(a){var b=\nthis.parentElement;b&&b.insertBefore(a,this.nextSibling)},beforebegin:function(a){var b=this.parentElement;b&&b.insertBefore(a,this)},beforeend:function(a){this.appendChild(a)}},E=function(a,b){if(!(1<a.nodeType)){var c=a.sprintEventListeners;c&&D(c,b);for(var d=r(\"*\",a),e=d.length,f,g=0;g<e;g++)if(c=d[g].sprintEventListeners)f||(f=r(\"*\",b)),D(c,f[g])}},z=function(a,b,c,d,e){var f=[],g=this;this.each(function(){for(var h=a?this.parentElement:this;h&&(!e||e!=h);){if(!d||g.is(d,h))if(f.push(h),c)break;\nif(b)break;h=h.parentElement}});return Sprint(x(f))},F=function(a,b){return Object.keys(a.sprintEventListeners).filter(function(a){return q(b).every(function(b){return v(b,q(a))})})},G=function(a,b,c){if(null==c){var d=a.get(0);if(!d||1<d.nodeType)return;a=b[0].toUpperCase()+b.substring(1);return d==document?(d=m[\"offset\"+a],a=window[\"inner\"+a],d>a?d:a):d==window?window[\"inner\"+a]:d.getBoundingClientRect()[b]}var e=\"function\"==typeof c,f=e?\"\":w(b,c);return a.each(function(a){this==document||this==\nwindow||1<this.nodeType||(e&&(f=w(b,c.call(this,a,Sprint(this)[b]()))),this.style[b]=f)})},p=function(a,b){var c=b.length,d=b;if(1<c&&-1<a.indexOf(\"after\"))for(var d=[],e=c;e--;)d.push(b[e]);for(e=0;e<c;e++){var f=d[e];if(\"string\"==typeof f||\"number\"==typeof f)this.each(function(){this.insertAdjacentHTML(a,f)});else if(\"function\"==typeof f)this.each(function(b){b=f.call(this,b,this.innerHTML);p.call(Sprint(this),a,[b])});else{var g=f instanceof n,h=[],k=g?f.get():Array.isArray(f)?A(f,!0,!0):f.nodeType?\n[f]:t(f),l=k.length;this.each(function(b){for(var c=document.createDocumentFragment(),d=0;d<l;d++){var e=k[d],f;b?(f=e.cloneNode(!0),E(e,f)):f=e;c.appendChild(f);h.push(f)}K[a].call(this,c)});g&&(f.dom=h,f.length=h.length);if(!(e<c-1))return h}}},v=function(a,b){for(var c=b.length;c--;)if(b[c]===a)return!0;return!1},B=function(a,b,c){if(null==b)return\"add\"==a?this:this.removeAttr(\"class\");var d,e,f;\"string\"==typeof b&&(d=!0,e=b.trim().split(\" \"),f=e.length);return this.each(function(g,h){if(!(1<this.nodeType)){if(!d){var k=\nb.call(h,g,h.className);if(!k)return;e=k.trim().split(\" \");f=e.length}for(k=0;k<f;k++){var l=e[k];l&&(null==c?h.classList[a](l):h.classList.toggle(l,c))}}})},L=function(){for(var a=[\"mozMatchesSelector\",\"webkitMatchesSelector\",\"msMatchesSelector\",\"matches\"],b=a.length;b--;){var c=a[b];if(Element.prototype[c])return c}}(),x=function(a){for(var b=[],c=0,d=a.length,e=0;e<d;e++){for(var f=a[e],g=!1,h=0;h<c;h++)if(f===b[h]){g=!0;break}g||(b[c++]=f)}return b},H=function(){var a=function(a,b,c){return 2>\nObject.keys(a.sprintEventListeners).filter(function(a){return q(b)[0]===q(a)[0]}).map(function(b){return a.sprintEventListeners[b]}).reduce(function(a,b){return a.concat(b)}).filter(function(a){return a===c}).length?!1:!0},b=function(b,c,f){return function(g){f&&f!==g||(b.removeEventListener(c,g),/\\./.test(c)&&!a(b,c,g)&&b.removeEventListener(q(c)[0],g))}},c=function(a,b){return a.filter(function(a){return b&&b!==a})};return function(a,e){return function(f){a.sprintEventListeners[f].forEach(b(a,f,\ne));a.sprintEventListeners[f]=c(a.sprintEventListeners[f],e)}}}(),M=function(a,b){return function(c){F(a,c).forEach(H(a,b))}},m=document.documentElement,A=function(a,b,c){for(var d=a.length,e=d;e--;)if(!a[e]&&0!==a[e]||b&&a[e]instanceof n||c&&(\"string\"==typeof a[e]||\"number\"==typeof a[e])){for(var e=[],f=0;f<d;f++){var g=a[f];if(g||0===g)if(b&&g instanceof n)for(var h=0;h<g.length;h++)e.push(g.get(h));else!c||\"string\"!=typeof g&&\"number\"!=typeof g?e.push(g):e.push(document.createTextNode(g))}return e}return a},\nI=function(){var a;return function(b,c,d){if(!a){var e=m.scrollTop;m.scrollTop=e+1;var f=m.scrollTop;m.scrollTop=e;a=f>e?m:document.body}if(null==d){b=b.get(0);if(!b)return;if(b==window||b==document)b=a;return b[c]}return b.each(function(){var b=this;if(b==window||b==document)b=a;b[c]=d})}}(),y=function(a,b,c,d){var e=[],f=b+\"ElementSibling\";a.each(function(){for(var b=this;(b=b[f])&&(!d||!a.is(d,b));)c&&!a.is(c,b)||e.push(b)});return Sprint(x(e))},J=function(a,b,c){var d=b+\"ElementSibling\";return a.map(function(){var b=\nthis[d];if(b&&(!c||a.is(c,b)))return b},!1)},r=function(a,b){b=b||document;if(/^[\\#.]?[\\w-]+$/.test(a)){var c=a[0];return\".\"==c?t(b.getElementsByClassName(a.slice(1))):\"#\"==c?(c=b.getElementById(a.slice(1)))?[c]:[]:\"body\"==a?[document.body]:t(b.getElementsByTagName(a))}return t(b.querySelectorAll(a))},q=function(a){return A(a.split(\".\"))},t=function(a){for(var b=[],c=a.length;c--;)b[c]=a[c];return b},C=function(){var a=function(a,c){var d=Sprint(a).clone(!0).get(0),e=d;if(d&&!(1<this.nodeType)){for(;e.firstChild;)e=\ne.firstChild;if(\"inner\"==c){for(;this.firstChild;)e.appendChild(this.firstChild);this.appendChild(d)}else{var f=\"all\"==c?this.get(0):this,g=f.parentNode,h=f.nextSibling;\"all\"==c?this.each(function(){e.appendChild(this)}):e.appendChild(f);g.insertBefore(d,h)}}};return function(b,c){\"function\"==typeof b?this.each(function(a){Sprint(this)[\"inner\"==c?\"wrapInner\":\"wrap\"](b.call(this,a))}):\"all\"==c?a.call(this,b,c):this.each(function(){a.call(this,b,c)});return this}}(),u={legend:{intro:\"<fieldset>\",outro:\"</fieldset>\"},\narea:{intro:\"<map>\",outro:\"</map>\"},param:{intro:\"<object>\",outro:\"</object>\"},thead:{intro:\"<table>\",outro:\"</table>\"},tr:{intro:\"<table><tbody>\",outro:\"</tbody></table>\"},col:{intro:\"<table><tbody></tbody><colgroup>\",outro:\"</colgroup></table>\"},td:{intro:\"<table><tbody><tr>\",outro:\"</tr></tbody></table>\"}};[\"tbody\",\"tfoot\",\"colgroup\",\"caption\"].forEach(function(a){u[a]=u.thead});u.th=u.td;var n=function(a,b){if(\"string\"==typeof a)if(\"<\"==a[0]){var c=document.createElement(\"div\"),d=/[\\w:-]+/.exec(a)[0],\nd=u[d],e=a.trim();d&&(e=d.intro+e+d.outro);c.insertAdjacentHTML(\"afterbegin\",e);e=c.lastChild;if(d)for(d=d.outro.match(/</g).length;d--;)e=e.lastChild;c.textContent=\"\";this.dom=[e]}else this.dom=b&&b instanceof n?b.find(a).get():r(a,b);else if(Array.isArray(a))this.dom=A(a);else if(a instanceof NodeList||a instanceof HTMLCollection)this.dom=t(a);else{if(a instanceof n)return a;if(\"function\"==typeof a)return this.ready(a);this.dom=a?[a]:[]}this.length=this.dom.length};n.prototype={add:function(a){var b=\nthis.get();a=Sprint(a);for(var c=a.get(),d=0;d<a.length;d++)b.push(c[d]);return Sprint(x(b))},addClass:function(a){return B.call(this,\"add\",a)},after:function(){p.call(this,\"afterend\",arguments);return this},append:function(){p.call(this,\"beforeend\",arguments);return this},appendTo:function(a){return Sprint(p.call(Sprint(a),\"beforeend\",[this]))},attr:function(a,b){var c=\"function\"==typeof b;if(\"string\"==typeof b||\"number\"==typeof b||c)return this.each(function(d){1<this.nodeType||this.setAttribute(a,\nc?b.call(this,d,this.getAttribute(a)):b)});if(\"object\"==typeof a){var d=Object.keys(a),e=d.length;return this.each(function(){if(!(1<this.nodeType))for(var b=0;b<e;b++){var c=d[b];this.setAttribute(c,a[c])}})}var f=this.get(0);if(f&&!(1<f.nodeType))return f=f.getAttribute(a),null==f?void 0:f?f:a},before:function(){p.call(this,\"beforebegin\",arguments);return this},children:function(a){var b=[],c=this;this.each(function(){if(!(1<this.nodeType))for(var d=this.children,e=d.length,f=0;f<e;f++){var g=d[f];\na&&!c.is(a,g)||b.push(g)}});return Sprint(b)},clone:function(a){return this.map(function(){if(this){var b=this.cloneNode(!0);a&&E(this,b);return b}},!1)},closest:function(a,b){return z.call(this,!1,!1,!0,a,b)},css:function(a,b){var c=typeof b,d=\"string\"==c;if(d||\"number\"==c){var e=d&&/=/.test(b);if(e)var f=parseInt(b[0]+b.slice(2));return this.each(function(){if(!(1<this.nodeType)){if(e)var c=parseInt(getComputedStyle(this).getPropertyValue(a))+f;this.style[a]=w(a,e?c:b)}})}if(\"function\"==c)return this.each(function(c){if(!(1<\nthis.nodeType)){var d=getComputedStyle(this).getPropertyValue(a);this.style[a]=b.call(this,c,d)}});if(\"string\"==typeof a)return d=this.get(0),!d||1<d.nodeType?void 0:getComputedStyle(d).getPropertyValue(a);if(Array.isArray(a)){d=this.get(0);if(!d||1<d.nodeType)return;for(var c={},d=getComputedStyle(d),g=a.length,h=0;h<g;h++){var k=a[h];c[k]=d.getPropertyValue(k)}return c}var l=Object.keys(a),m=l.length;return this.each(function(){if(!(1<this.nodeType))for(var b=0;b<m;b++){var c=l[b];this.style[c]=\nw(c,a[c])}})},detach:function(){return this.map(function(){var a=this.parentElement;if(a)return a.removeChild(this),this},!1)},each:function(a){for(var b=this.dom,c=this.length,d=0;d<c;d++){var e=b[d];a.call(e,d,e)}return this},empty:function(){return this.each(function(){this.innerHTML=\"\"})},eq:function(a){return Sprint(this.get(a))},filter:function(a){var b=\"function\"==typeof a,c=this;return this.map(function(d){if(!(1<this.nodeType||!b&&!c.is(a,this)||b&&!a.call(this,d,this)))return this},!1)},\nfind:function(a){if(\"string\"==typeof a){var b=[];this.each(function(){if(!(1<this.nodeType))for(var c=r(a,this),d=c.length,e=0;e<d;e++)b.push(c[e])});return Sprint(x(b))}for(var c=a.nodeType?[a]:a.get(),d=c.length,e=[],f=0,g=0;g<this.length;g++){var h=this.get(g);if(!(1<h.nodeType))for(var k=0;k<d;k++){var l=c[k];if(h.contains(l)&&(e[f++]=l,!(f<d)))return Sprint(e)}}return Sprint(e)},first:function(){return this.eq(0)},get:function(a){if(null==a)return this.dom;0>a&&(a+=this.length);return this.dom[a]},\nhas:function(a){if(\"string\"==typeof a)return this.map(function(){if(!(1<this.nodeType)&&r(a,this)[0])return this},!1);for(var b=[],c=this.length;c--;){var d=this.get(c);if(d.contains(a)){b.push(d);break}}return Sprint(b)},hasClass:function(a){for(var b=this.length;b--;){var c=this.get(b);if(1<c.nodeType)return;if(c.classList.contains(a))return!0}return!1},height:function(a){return G(this,\"height\",a)},html:function(a){if(null==a){var b=this.get(0);return b?b.innerHTML:void 0}return\"function\"==typeof a?\nthis.each(function(b){b=a.call(this,b,this.innerHTML);Sprint(this).html(b)}):this.each(function(){this.innerHTML=a})},index:function(a){if(this.length){var b;a?\"string\"==typeof a?(b=this.get(0),a=Sprint(a)):(b=a instanceof n?a.get(0):a,a=this):(b=this.get(0),a=this.first().parent().children());a=a.get();for(var c=a.length;c--;)if(a[c]==b)return c;return-1}},insertAfter:function(a){Sprint(a).after(this);return this},insertBefore:function(a){Sprint(a).before(this);return this},is:function(a,b){var c=\nb?[b]:this.get(),d=c.length;if(\"string\"==typeof a){for(var e=0;e<d;e++){var f=c[e];if(!(1<f.nodeType)&&f[L](a))return!0}return!1}if(\"object\"==typeof a){for(var f=a instanceof n?a.get():a.length?a:[a],g=f.length,e=0;e<d;e++)for(var h=0;h<g;h++)if(c[e]===f[h])return!0;return!1}if(\"function\"==typeof a){for(e=0;e<d;e++)if(a.call(this,e,this))return!0;return!1}},last:function(){return this.eq(-1)},map:function(a,b){null==b&&(b=!0);for(var c=this.get(),d=this.length,e=[],f=0;f<d;f++){var g=c[f],g=a.call(g,\nf,g);if(b&&Array.isArray(g))for(var h=g.length,k=0;k<h;k++)e.push(g[k]);else e.push(g)}return Sprint(e)},next:function(a){return J(this,\"next\",a)},nextAll:function(a){return y(this,\"next\",a)},nextUntil:function(a,b){return y(this,\"next\",b,a)},not:function(a){var b=\"function\"==typeof a,c=this;return this.map(function(d){if(b){if(a.call(this,d,this))return}else if(c.is(a,this))return;return this},!1)},off:function(a,b){if(\"object\"==typeof a)return Object.keys(a).forEach(function(b){this.off(b,a[b])},\nthis),this;a&&(a=a.trim().split(\" \"));return this.each(function(){this.sprintEventListeners&&(a?a.forEach(M(this,b)):Object.keys(this.sprintEventListeners).forEach(H(this)))})},offset:function(a){if(!a){var b=this.get(0);if(!b||1<b.nodeType)return;b=b.getBoundingClientRect();return{top:b.top,left:b.left}}if(\"object\"==typeof a)return this.each(function(){if(!(1<this.nodeType)){var b=Sprint(this);\"static\"==b.css(\"position\")?b.css(\"position\",\"relative\"):b.css({top:0,left:0});var d=b.offset();b.css({top:a.top-\nd.top+\"px\",left:a.left-d.left+\"px\"})}});if(\"function\"==typeof a)return this.each(function(b){var d=Sprint(this);b=a.call(this,b,d.offset());d.offset(b)})},offsetParent:function(){var a=[];this.each(function(){if(!(1<this.nodeType)){for(var b=this;b!=m;){var b=b.parentNode,c=getComputedStyle(b).getPropertyValue(\"position\");if(!c)break;if(\"static\"!=c){a.push(b);return}}a.push(m)}});return Sprint(a)},on:function(a,b){if(b){var c=a.trim().split(\" \");return this.each(function(){this.sprintEventListeners||\n(this.sprintEventListeners={});c.forEach(function(a){this.sprintEventListeners[a]||(this.sprintEventListeners[a]=[]);this.sprintEventListeners[a].push(b);this.addEventListener(a,b);/\\./.test(a)&&this.addEventListener(q(a)[0],b)},this)})}Object.keys(a).forEach(function(b){this.on(b,a[b])},this);return this},parent:function(a){return z.call(this,!0,!0,!1,a)},parents:function(a){return z.call(this,!0,!1,!1,a)},position:function(){var a=this.offset(),b=this.parent().offset();if(a)return{top:a.top-b.top,\nleft:a.left-b.left}},prop:function(a,b){if(\"object\"==typeof a){var c=Object.keys(a),d=c.length;return this.each(function(){for(var b=0;b<d;b++){var e=c[b];this[e]=a[e]}})}if(null==b){var e=this.get(0);return e?e[a]:void 0}var f=\"function\"==typeof b;return this.each(function(c){this[a]=f?b.call(this,c,this[a]):b})},prepend:function(){p.call(this,\"afterbegin\",arguments);return this},prependTo:function(a){return Sprint(p.call(Sprint(a),\"afterbegin\",[this]))},prev:function(a){return J(this,\"previous\",\na)},prevAll:function(a){return y(this,\"previous\",a)},prevUntil:function(a,b){return y(this,\"previous\",b,a)},ready:function(a){this.dom=[document];this.length=1;return this.on(\"DOMContentLoaded\",a)},remove:function(a){var b=this;return this.each(function(){var c=this.parentElement;c&&(a&&!b.is(a,this)||c.removeChild(this))})},removeAttr:function(a){if(a){var b=a.trim().split(\" \"),c=b.length;this.each(function(){if(!(1<this.nodeType))for(var a=0;a<c;a++)this.removeAttribute(b[a])})}return this},removeClass:function(a){return B.call(this,\n\"remove\",a)},removeProp:function(a){return this.each(function(){this[a]=void 0})},replaceAll:function(a){Sprint(a).replaceWith(this);return this},replaceWith:function(a){return\"function\"==typeof a?this.each(function(b){Sprint(this).replaceWith(a.call(this,b,this))}):this.before(a).remove()},scrollLeft:function(a){return I(this,\"scrollLeft\",a)},scrollTop:function(a){return I(this,\"scrollTop\",a)},siblings:function(a){var b=[],c=this;this.each(function(d,e){Sprint(this).parent().children().each(function(){this==\ne||a&&!c.is(a,this)||b.push(this)})});return Sprint(b)},size:function(){return this.length},slice:function(a,b){var c=this.get(),d=[],e=0<=a?a:a+this.length,f=this.length;for(0>b?f+=b:0<=b&&(f=b>this.length?this.length:b);e<f;e++)d.push(c[e]);return Sprint(d)},text:function(a){if(null==a){var b=[];this.each(function(){b.push(this.textContent)});return b.join(\"\")}var c=\"function\"==typeof a;return this.each(function(b){this.textContent=c?a.call(this,b,this.textContent):a})},toggleClass:function(a,b){return B.call(this,\n\"toggle\",a,b)},trigger:function(a){if(!window.CustomEvent||\"function\"!==typeof window.CustomEvent){var b=function(a,b){var e;b=b||{bubbles:!1,cancelable:!1,detail:void 0};e=document.createEvent(\"CustomEvent\");e.initCustomEvent(a,b.bubbles,b.cancelable,b.detail);return e};b.prototype=window.Event.prototype;window.CustomEvent=b}return this.each(function(){F(this,a).forEach(function(a){this.dispatchEvent(new b(a,{bubbles:!0,cancelable:!0}))},this)})},unwrap:function(){this.parent().each(function(){this!=\ndocument.body&&this!=m&&Sprint(this).replaceWith(this.childNodes)});return this},val:function(a){if(null==a){var b=this.get(0);if(!b)return;if(b.multiple){var c=[];this.first().children(\":checked\").each(function(){c.push(this.value)});return c}return b.value}if(Array.isArray(a)){var d=this;return this.each(function(){this.multiple?d.children().each(function(){this.selected=v(this.value,a)}):this.checked=v(this.value,a)})}return\"function\"==typeof a?this.each(function(b){Sprint(this).val(a.call(this,\nb,this.value))}):this.each(function(){this.value=a})},width:function(a){return G(this,\"width\",a)},wrap:function(a){return C.call(this,a)},wrapAll:function(a){return C.call(this,a,\"all\")},wrapInner:function(a){return C.call(this,a,\"inner\")}};Sprint=function(a,b){return new n(a,b)};null==window.$&&(window.$=Sprint)})();\n"
        }
      ]
    }
  ]
}