{
  "metadata": {
    "timestamp": 1736561991295,
    "page": 717,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cujojs/when",
      "stars": 3435,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.0517578125,
          "content": "root = true\n\n[*]\nindent_style = tab\nend_of_line = LF\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.087890625,
          "content": ".idea/\nexperiments/\nnode_modules/\nbuild/when.js\ndist/\ntest/browser/*.js\nbower_components/\n"
        },
        {
          "name": ".jshintignore",
          "type": "blob",
          "size": 0.11328125,
          "content": "node_modules/\n.git/\n.idea/\nexperiments/\ntest/monitor/\ntest/browser/\nes6-shim/\nbuild/when.js\nbower_components/\ndist/\n"
        },
        {
          "name": ".jshintrc",
          "type": "blob",
          "size": 0.4609375,
          "content": "{\n\t\"browser\": true,\n\t\"node\": true,\n\n\t\"predef\": [\n        \"define\",\n        \"module\",\n        \"system\"\n    ],\n\n\t\"boss\": true,\n\t\"curly\": true,\n    \"elision\": true,\n    \"eqnull\": true,\n\t\"expr\": true,\n\t\"globalstrict\": false,\n\t\"laxbreak\": true,\n\t\"newcap\": true,\n\t\"noarg\": true,\n\t\"noempty\": true,\n\t\"nonew\": true,\n\t\"quotmark\": \"single\",\n\t\"smarttabs\": true,\n\t\"strict\": false,\n\t\"sub\": true,\n\t\"trailing\": true,\n\t\"undef\": true,\n\t\"unused\": true,\n\n\t\"maxdepth\": 3,\n\t\"maxcomplexity\": 5\n}"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.080078125,
          "content": "test/\nbenchmark/\nexperiments/\ndocs/\nbuild/\n*.md\n.*\n*~\nbower.json\nbower_components/"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3486328125,
          "content": "language: node_js\nnode_js:\n  - '0.10'\n  - '0.12'\n  - '4'\n  - '5'\nsudo: false\nscript: npm run ci\nbranches:\n  only:\n    - dev\n    - master\naddons:\n  apt:\n    sources:\n      - ubuntu-toolchain-r-test\n    packages:\n      - g++-4.8\nenv:\n  global:\n    - SAUCE_USERNAME=\"cujojs-when\"\n    - SAUCE_ACCESS_KEY=\"e5d3d1a5-bc49-4607-8a7e-702a512c7f60\"\n    - CXX=g++-4.8\n"
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 25.7431640625,
          "content": "### 3.7.7\n\n* Fix browserify\n\n### 3.7.6\n\n* Add browser dist version to npm package\n\n### 3.7.5\n\n* Improve unhandled rejection formatting in ie8\n\n### 3.7.4\n\n* Add `when/keys settle`, for settling a hash of promises.\n* Use `poly` from npm instead of a git link in package.json. No need for git to be available to npm install when.\n* Various community-contributed documentation updates. Thanks!\n\n### 3.7.3\n\n* Fix console.log check when using `monitor/console` in IE8.\n* Fix issues with webpack environment and fake timers.\n* Several community-contributed doc fixes.  Thanks!\n\n### 3.7.2\n\n* Republish 3.7.1 npm package: for some reason, `npm publish` did not include the file `poll.js` when publishing 3.7.1\n* No functional changes\n\n### 3.7.1\n\n* Fix `when.settle` unhandled rejection reporting case.\n\n### 3.7.0\n\n* Add [`process` and `window` unhandled rejection events](#docs/debug-api.md) for cross-library debugging tools.\n* Improve internal task queueing performance and memory usage.\n* Stabilize handler ordering in the face of multiple promise implementations.\n\n### 3.6.4\n\n* Fix handling of `null` errors in unhandled rejection reporting\n* Add [examples of supporting both promise and node style callbacks](docs/api.md#support-promises-and-node-style-callback-functions) in the same API\n\n### 3.6.3\n\n* Fix regression in `when/callbacks` introduced in 3.6.1\n\n### 3.6.2\n\n* Work around [v8 optimizing compiler bug](https://code.google.com/p/v8/issues/detail?id=3692) with some *truly amazing* help from community members. Thank you [@anodynos](https://github.com/anodynos), [@jefflage](https://github.com/jefflage), [@pbarnes](https://github.com/pbarnes), [@spion](https://github.com/spion), [@tsouza](https://github.com/tsouza).\n* Fix regressions in `when.filter` and `when.reduce` (which also affected `when/sequence`).\n\n### 3.6.1\n\n* Significant improvements to `when.try`, and `when.lift`.\n* Additional improvements to array functions: `when.reduce`, `when.any`, and `when.some`.\n* Improved handling of early bail-out cases in `when.all`, `when.map`, and `when.any`.\n\n### 3.6.0\n\n* Significant performance improvements:\n\t* 10x or more for `when.map`, especially for large arrays\n\t* ~2x for `when.reduce` and `promise.fold`\n\t* ~1.5-2x for generators using `when/generator` `lift`, `call`, and/or `apply`.\n* Memory use reductions for `when.reduce` and `promise.fold`.\n\n### 3.5.2\n\n* Prevent minifiers from clobbering unhandled rejection reporting if they remove `console.*` calls.  Unhandled rejections will be reported even when using Uglify `drop_console`.\n* `when/function.apply` now handles passing an Arguments object directly, e.g. `fn.apply(f, arguments);`. Use with care: v8 will deoptimize any function where you pass `arguments` to another function.\n\n### 3.5.1\n\n* `when.race` & `Promise.race` now reject with a `TypeError` if you pass something that is not iterable.\n* Improve scheduler compatibility with MutationObserver shims\n* Simplify checks for vert.x environment\n\n### 3.5.0\n\n* Improve `when.race` & `Promise.race` performance.\n* Internal changes to start paving the way toward 4.0.0.\n* Deprecate `when.iterate` and `when.unfold`.  Use [cujoJS/most](https://github.com/cujojs/most) for streaming asynchronous values.\n* Deprecate progress events. See [the docs for more information](docs/api.md#progress-events-are-deprecated) and [tips on refactoring](docs/api.md#refactoring-progress) code that uses promise progress.\n\n### 3.4.6\n\n* Fix webpack compatibility by excluding `vertx` from browser bundles\n\n### 3.4.5\n\n* Fixes for edge cases for unhandled rejection reporting\n\n### 3.4.4\n\n* Workaround for node 0.10.30 setTimeout bug. See [this issue](https://github.com/joyent/node/issues/8167)\n\n### 3.4.3\n\n* Improve error handling for [predicate catch](docs/api.md#promisecatch)\n* Simplify internals and reduce code size\n\n### 3.4.2\n\n* Fix for rare false negative in [unhandled rejection reporting](docs/api.md#debugging-promises).\n\n### 3.4.1\n\n* Fix for `promise.finally` not waiting on returned promises.\n\n### 3.4.0\n\n* New [`when.filter`](docs/api.md#whenfilter) for filtering arrays of promises.\n* [`when.map`](docs/api.md#whenmap) and [`when.filter`](docs/api.md#whenfilter) now provide the array index as the second param to their mapping and filtering functions.\n* [`when/keys.map`](docs/api.md#whenkeys-map) now provides the associated key to its mapping function.\n* Smaller ES6 shim.\n\n### 3.3.1\n\n* Fix argument ordering bug in `when/node` introduced in 3.3.0.\n\n### 3.3.0\n\n* Promote [`when.race`](docs/api.md#whenrace) to public API.\n* `when.any` and `when.some` now reject with a `RangeError` if the race is obviously unwinnable, for example: `when.some([1,2,3], 4)`.  See the [`when.any`](docs/api.md#whenany) and [`when.some`](docs/api.md#whensome) docs for more info.\n\n### 3.2.3\n\n* Updated [debugging docs](docs/api.md#debugging-promises)\n* Report when previously unhandled rejections become handled, with an ID to correlate the two messages.\n* Improve unhandled rejection reporting for cases where multiple different promise implementations interleave.\n\n### 3.2.2\n\n* More mem and perf improvements\n* Improvements to unhandled rejection reporting\n\n### 3.2.1\n\n* Minor mem and perf tweaks for `when.all`\n* Defend against `JSON.stringify` exceptions when formatting unhandled rejection output.\n\n### 3.2.0\n\n* Potentially unhandled rejections are now logged to `console.error` by default, even without using `done` or `when/monitor/console`.  As before, enabling `when/monitor/console` still adds long async stack traces, and using `done` still makes errors fatal. See [Debugging Promises](docs/api.md#debugging-promises) for more info.\n* [`promise.timeout`](docs/api.md#promisetimeout) now rejects with a [`TimeoutError`](docs/api.md#timeouterror) by default (unless you specify a custom reason) for better pattern matching with [`promise.catch`](docs/api.md#promisecatch).\n* Performance improvements across the board, especially to `when.all` (and `Promise.all` in the [ES6-shim](docs/es6-promise-shim.md)) and `node.lift`: lifted functions and lift*ing* are faster now.\n* New [`promise.fold`](docs/api.md#promisefold) for combining two promises to generate a new promise.\n* Deprecated:\n\t* Using `when/node.lift`, `when/function.lift`, and `when/callbacks.lift` to provide partial arguments\n\t* `promise.then`'s 3rd argument, and `when()`'s 4th argument. Use the dedicated [`promise.progress`](docs/api.md#promiseprogress) API to listen to promise progress events.\n\t* `when.some`. See https://github.com/cujojs/when/issues/288\n\t* `when/callbacks.promisify` See https://github.com/cujojs/when/issues/318\n\n### 3.1.0\n\n* Added [optional `reason` param to `promise.timeout`](docs/api.md#promisetimeout) to specify your own timeout value.\n* Another significant speed bump for `when.all` (and es6-shim `Promise.all`)\n* More `when/monitor/console` long stack trace improvements. Traces can track nested async functions [even if you forget to return a promise](docs/api.md#whenmonitorconsole).\n* Clean up bower and npm installs by ignoring more markdown files\n\n### 3.0.1\n\n* [API doc](docs/api.md) updates and fixes\n* Improvements to unhandled rejection long stack trace filtering\n* Internal performance improvements\n\n### 3.0.0\n\n* New internal architecture with significant performance improvements and memory efficiency\n* New APIs\n\t* [`when.try`](docs/api.md#whentry), [`when.lift`](docs/api.md#whenlift), [`when.reduceRight`](docs/api.md#whenreduceRight), [`when.iterate`](docs/api.md#wheniterate), [`when.unfold`](docs/api.md#whenunfold), [`when.race`](docs/api.md#whenrace)\n\t* [`promise.with`](docs/api.md#promisewith), [`promise.else`](docs/api.md#promiseelse), [`promise.delay`](docs/api.md#promisedelay), [`promise.timeout`](docs/api.md#promisetimeout), [`promise.progress`](docs/api.md#promiseprogress)\n* New liftAll variants for lifting all of an object's functions in one shot, eg. `var promisedFs = node.liftAll(require('fs'))`\n\t* [`fn.liftAll`](docs/api.md#fnliftall), [`node.liftAll`](docs/api.md#nodeliftall), [`callbacks.liftAll`](docs/api.md#callbacksliftall)\n* `when.Promise` public, inheritance-friendly, Promise constructor\n* New [ES6 Promise shim](docs/es6-promise-shim.md)\n* Check out the [tips for upgrading to 3.0 from 2.x](docs/api.md#upgrading-to-30-from-2x)\n\n### 2.8.0\n\n* Experimental [ES6 generator support](docs/api.md#es6-generators) via new `when/generator` module, with `lift`, `call`, `apply`.\n\n### 2.7.1\n\n* Internal changes to reduce overall memory usage, along with minor performance improvements.\n\n### 2.7.0\n\n* Added [`promise.catch`](docs/api.md#catch) and [`promise.finally`](docs/api.md#finally) as synonyms for `promise.otherwise` and `promise.ensure`. (#212)\n* New [browserify build](../README.md#legacy-environments-via-browserify) for those using globals. (#209)\n* Added [ender](http://ender.jit.su) support to `package.json`. (#223)\n* Fix compatibility with [PhantomJS](http://phantomjs.org)'s CommonJS module support. (#226)\n* Fix [Sauce Labs](https://saucelabs.com) tests for pull requests. (#216)\n* Added `bower.json` `ignore` to trim files installed via bower. (#193)\n\n### 2.6.0\n\n* New [`promise.done`](docs/api.md#done) allows consuming the ultimate value at the end of a promise chain while ensuring that any errors are thrown to the host environment so you get loud stack traces.\n* `when/node/function` [`bindCallback`](docs/api.md#nodefn-bindcallback) and [`liftCallback`](docs/api.md#nodefn-liftcallback) now behave more like standard node-style APIs in that they allow exceptions to propagate to the host environment for loud stack traces.\n\n### 2.5.1\n\n* `ensure` now ignores non-functions, [like `then` does](http://promisesaplus.com/#point-25), for consistency. (#207)\n\n### 2.5.0\n\n* [Promises/A+ 1.1](http://promisesaplus.com) compliant.  Passes version 2.0.0 of the [Promises/A+ test suite](https://github.com/promises-aplus/promises-tests).\n\n### 2.4.1\n\n* New `MutationObserver` scheduler further reduces \"time-to-first-handler\" in modern browsers. (#198)\n\t* Also, this works around a horrible IE10 bug (desktop and mobile) that renders `setImmediate`, `MessageChannel`, and `postMessage` unusable as fast task schedulers.  Many thanks to @plaa and @calvinmetcalf for their help in discovering the problem and working out a solution. (#197)\n\n### 2.4.0\n\n* Experimental support for [vert.x 2.x](http://vertx.io). Should now run in vert.x >= 1.1.0.\n* New `when.isPromiseLike` as the more accurately-named synonym for `when.isPromise`.\n* **DEPRECATED**: `when.isPromise`. It can only tell you that something is \"promise-like\" (aka \"thenable\") anyway. Use the new, more accurately-named `when.isPromiseLike` instead.\n* Fix for promise monitor reporting extra unhandled rejections for `when.all` and `when.map`.\n\n### 2.3.0\n\n* New [`promise.tap`](docs/api.md#tap) for adding side effects to a promise chain.\n* New `MessageChannel` scheduler reduces \"time-to-first\" handler, in environments that support it.\n* Performance optimizations for promise resolution.\n* Internal architecture improvements to pave the way for when.js 3.0.0.\n\n### 2.2.1\n\n* Fix for `when.defer().reject()` bypassing the unhandled rejection monitor. (#166)\n* Fix for `when/function`, `when/callbacks`, and `when/node/function` not preserving `thisArg`. (#162)\n* Doc clarifications for [`promise.yield`](docs/api.md#yield). (#164)\n\n### 2.2.0\n\n* New experimental [promise monitoring and debugging](docs.md#debugging-promises) via `when/monitor/console`.\n* New [`when.promise(resolver)`](docs/api.md#whenpromise) promise creation API. A lighter alternative to the heavier `when.defer()`\n* New `bindCallback` and `liftCallback` in `when/node/function` for more integration options with node-style callbacks.\n\n### 2.1.1\n\n* Quote internal usages of `promise.yield` to workaround .NET minifier tools that don't yet understand ES5 identifier-as-property rules.  See [#157](https://github.com/cujojs/when/issues/157)\n\n### 2.1.0\n\n* New [`when.settle`](docs/api.md#whensettle) that settles an array of promises, regardless of whether the fulfill or reject.\n* New [`when/guard`](docs/api.md#whenguard) generalized concurrency guarding and limiting\n* New [`promise.inspect`](docs/api.md#inspect) for synchronously getting a snapshot of a promise's state at a particular instant.\n* Significant performance improvements when resolving promises with non-primitives (Arrays, Objects, etc.)\n* Experimental [vert.x](http://vertx.io) support\n* **DEPRECATED**: `onFulfilled`, `onRejected`, `onProgress` handler arguments to `when.all`, `when.any`, `when.some`.  Use the returned promise's `then()` (or `otherwise()`, `ensure()`, etc) to register handlers instead.\n\t* For example, do this: `when.all(array).then(onFulfilled, onRejected)` instead of this: `when.all(array, onFulfilled, onRejected)`.  The functionality is equivalent.\n\n### 2.0.1\n\n* Account for the fact that Mocha creates a global named `process`. Thanks [Narsul](https://github.com/cujojs/when/pull/136)\n\n### 2.0.0\n\n* Fully asynchronous resolutions.\n* [Promises/A+](http://promises-aplus.github.com/promises-spec) compliance.\n* New [`when/keys`](docs/api.md#object-keys) module with `all()` and `map()` for object keys/values.\n* New [`promise.ensure`](docs/api.md#ensure) as a better, and safer, replacement for `promise.always`.  [See discussion](https://github.com/cujojs/when/issues/103) as to why `promise.always` is mistake-prone.\n\t* **DEPRECATED:** `promise.always`\n* `lift()` is now the preferred name for what was `bind()` in [when/function](docs/api.md#synchronous-functions), [when/node/function](docs/api.md#node-style-asynchronous-functions), and [when/callbacks](docs/api.md#asynchronous-functions).\n\t* **DEPRECATED:** `bind()` in `when/function`, `when/node/function`, and `when/callbacks`.  Use `lift()` instead.\n\n### 1.8.1\n\n* Last 1.x.x release before 2.0.0 barring critical fixes.\n\t* To prepare for 2.0.0, [test your code against the dev-200 branch](https://github.com/cujojs/when/tree/dev-200). It is fully API compatible, but has fully asynchronous resolutions.\n* Performance improvements for [when/function](docs/api.md#synchronous-functions).\n* [Documentation](docs/api.md) updates and fixes. Thanks, [@unscriptable](https://github.com/unscriptable)!\n* **DEPRECATED:** `deferred.progress` and `deferred.resolver.progress`. Use [`deferred.notify`](docs/api.md#progress-events) and [`deferred.resolver.notify`](docs/api.md#progress-events) instead.\n* **DEPRECATED:** [`when.chain`](docs/api.md#whenchain). Use [`resolver.resolve(promise)`](docs/api.md#resolver) or `resolver.resolve(promise.yield)` ([see `promise.yield`](docs/api.md#yield)) instead.\n* **DEPRECATED:** `when/timed` module.  Use [`when/delay`](docs/api.md#whendelay) and [`when/timeout`](docs/api.md#whentimeout) modules instead.\n\n### 1.8.0\n\n* New [when/function](docs/api.md#synchronous-functions), [when/node/function](docs/api.md#node-style-asynchronous-functions), and [when/callbacks](docs/api.md#asynchronous-functions) with functional programming goodness, and adapters for turning callback-based APIs into promise-based APIs. Kudos [@riccieri](https://github.com/riccieri)!\n* New [when/unfold](docs/api.md#whenunfold), and [when/unfold/list](docs/api.md#whenunfoldlist) promise-aware anamorphic unfolds that can be used to generate and/or process unbounded lists.\n* New [when/poll](docs/api.md#whenpoll) promise-based periodic polling and task execution. Kudos [@scothis](https://github.com/scothis)!\n\n### 1.7.1\n\n* Removed leftover internal usages of `deferred.then`.\n* [when/debug](https://github.com/cujojs/when/wiki/when-debug) allows configuring the set of \"fatal\" error types that will be rethrown to the host env.\n\n### 1.7.0\n\n* **DEPRECATED:** `deferred.then` [is deprecated](docs/api.md#deferred) and will be removed in an upcoming release.  Use `deferred.promise.then` instead.\n* [promise.yield](docs/api.md#yield)(promiseOrValue) convenience API for substituting a new value into a promise chain.\n* [promise.spread](docs/api.md#spread)(variadicFunction) convenience API for spreading an array onto a fulfill handler that accepts variadic arguments. [Mmmm, buttery](http://s.shld.net/is/image/Sears/033W048977110001_20100422100331516?hei=1600&wid=1600&op_sharpen=1&resMode=sharp&op_usm=0.9,0.5,0,0)\n* Doc improvements:\n\t* [when()](docs/api.md#when) and [promise.then()](docs/api.md#main-promise-api) have more info about callbacks and chaining behavior.\n\t* More info and clarifications about the roles of [Deferred](docs/api.md#deferred) and [Resolver](docs/api.md#resolver)\n\t* Several minor clarifications for various APIs\n* Internal improvements to assimilation and interoperability with other promise implementations.\n\n### 1.6.1\n\n* Fix for accidental coercion of non-promises. See [#62](https://github.com/cujojs/when/issues/60).\n\n### 1.6.0\n\n* New [when.join](docs/api.md#whenjoin) - Joins 2 or more promises together into a single promise.\n* [when.some](docs/api.md#whensome) and [when.any](docs/api.md#whenany) now act like competitive races, and have generally more useful behavior.  [Read the discussion in #60](https://github.com/cujojs/when/issues/60).\n* *Experimental* progress event propagation.  Progress events will propagate through promise chains. [Read the details here](docs/api.md#progress-events).\n* *Temporarily* removed calls to `Object.freeze`. Promises are no longer frozen due to a horrendous v8 performance penalty.  [Read discussion here](https://groups.google.com/d/topic/cujojs/w_olYqorbsY/discussion).\n    * **IMPORTANT:** Continue to treat promises as if they are frozen, since `freeze()` will be reintroduced once v8 performance improves.\n* [when/debug](https://github.com/cujojs/when/wiki/when-debug) now allows setting global a debugging callback for rejected promises.\n\n### 1.5.2\n\n* Integrate @domenic's [Promises/A Test Suite](https://github.com/domenic/promise-tests). Runs via `npm test`.\n* No functional change\n\n### 1.5.1\n\n* Performance optimization for [when.defer](docs/api.md#whendefer), up to 1.5x in some cases.\n* [when/debug](docs/api.md#whendebug) can now log exceptions and rejections in deeper promise chains, in some cases, even when the promises involved aren't when.js promises.\n\n### 1.5.0\n\n* New task execution and concurrency management: [when/sequence](docs/api.md#whensequence), [when/pipeline](docs/api.md#whenpipeline), and [when/parallel](docs/api.md#whenparallel).\n* Performance optimizations for [when.all](docs/api.md#whenall) and [when.map](docs/api.md#whenmap), up to 2x in some cases.\n* Options for disabling [paranoid mode](docs/api.md#paranoid-mode) that provides a significant performance gain in v8 (e.g. Node and Chrome). See this [v8 performance problem with Object.freeze](http://stackoverflow.com/questions/8435080/any-performance-benefit-to-locking-down-javascript-objects) for more info.\n* **Important:** `deferred` and `deferred.resolver` no longer throw when resolved/rejected multiple times.  They will return silently as if the they had succeeded.  This prevents parties to whom *only* the `resolver` has been given from using `try/catch` to determine the state of the associated promise.\n    * For debugging, you can use the [when/debug](https://github.com/cujojs/when/wiki/when-debug) module, which will still throw when a deferred is resolved/rejected multiple times.\n\n### 1.4.4\n\n* Change UMD boilerplate to check for `exports` to avoid a problem with QUnit.  See [#54](https://github.com/cujojs/when/issues/54) for more info.\n\n### 1.4.3\n\n* Fix for infinite promise coercion between when.js and Q (See [#50](https://github.com/cujojs/when/issues/50)). Thanks [@kriskowal](https://github.com/kriskowal) and [@domenic](https://github.com/domenic)\n\n### 1.4.2\n\n* Fix for IE8 infinite recursion (See [#49](https://github.com/cujojs/when/issues/49))\n\n### 1.4.1\n\n* Code and unit test cleanup and streamlining--no functional changes.\n\n### 1.4.0\n\n* Create a resolved promise: `when.resolve(value)` creates a resolved promise for `value`. See [API docs](docs/api.md#whenresolve).\n* Resolve/reject return something useful: `deferred.resolve` and `deferred.reject` now return a promise for the fulfilled or rejected value.\n* Resolve a deferred with another promise: `deferred.resolve(promise)` - when `promise` resolves or rejects, so will `deferred`.\n\n### 1.3.0\n\n* Fixed a deviation from the Promises/A spec where returning undefined from a callback or errback would cause the previous value to be forwarded.  See [#31](https://github.com/cujojs/when/issues/31)\n\t* *This could be a breaking change* if you depended on this behavior.  If you encounter problems, the solution is to ensure that your promise callbacks (registered either with `when()` or `.then()`) return what you intend, keeping in mind that not returning something is equivalent to returning `undefined`.\n* This change also restores compatibility with the promises returned by `jQuery.get()`, which seem to reject with themselves as the rejection value.  See [issue #41](https://github.com/cujojs/when/issues/43) for more information and discussion.  Thanks to [@KidkArolis](https://github.com/KidkArolis) for raising the issue.\n\n### 1.2.0\n\n* `promise.otherwise(errback)` as a shortcut for `promise.then(null, errback)`. See discussion [here](https://github.com/cujojs/when/issues/13) and [here](https://github.com/cujojs/when/issues/29). Thanks to [@jonnyreeves](https://github.com/jonnyreeves/) for suggesting the name \"otherwise\".\n* [when/debug](https://github.com/cujojs/when/wiki/when-debug) now detects exceptions that typically represent coding errors, such as SyntaxError, ReferenceError, etc. and propagates them to the host environment.  In other words, you'll get a very loud stack trace.\n\n### 1.1.1\n\n* Updated [wiki](https://github.com/cujojs/when/wiki) map/reduce examples, and added simple promise forwarding example\n* Fix for calling `when.any()` without a callback ([#33](https://github.com/cujojs/when/issues/33))\n* Fix version number in `when.js` source ([#36](https://github.com/cujojs/when/issues/36))\n\n### 1.1.0\n\n* `when.all/any/some/map/reduce` can all now accept a promise for an array in addition to an actual array as input.  This allows composing functions to do interesting things like `when.reduce(when.map(...))`\n* `when.reject(promiseOrValue)` that returns a new, rejected promise.\n* `promise.always(callback)` as a shortcut for `promise.then(callback, callback)`\n* **Highly experimental** [when/debug](https://github.com/cujojs/when/wiki/when-debug) module: a drop-in replacement for the main `when` module that enables debug logging for promises created or consumed by when.js\n\n### 1.0.4\n\n* [Travis CI](http://travis-ci.org/cujojs/when) integration\n* Fix for cancelable deferred not invoking progress callbacks. ([#24](https://github.com/cujojs/when/pull/24) Thanks [@scothis](https://github.com/scothis))\n* The promise returned by `when.chain` now rejects when the input promise rejects.\n\n### 1.0.3\n\n* Fix for specific situation where `null` could incorrectly be used as a promise resolution value ([#23](https://github.com/cujojs/when/pull/23))\n\n### 1.0.2\n\n* Updated README for running unit tests in both Node and Browsers.  See **Running the Unit Tests** below.\n* Set package name to 'when' in package.json\n\n### 1.0.1\n\n* Fix for rejections propagating in some cases when they shouldn't have been ([#19](https://github.com/cujojs/when/issues/19))\n* Using [buster.js](http://busterjs.org/) for unit tests now.\n\n### 1.0.0\n\n* First official when.js release as a part of [cujojs](https://github.com/cujojs).\n* Added [when/cancelable](https://github.com/cujojs/when/wiki/when-cancelable) decorator for creating cancelable deferreds\n* Added [when/delay](https://github.com/cujojs/when/wiki/when-delay) and [when/timeout](https://github.com/cujojs/when/wiki/when-timeout) helpers for creating delayed promises and promises that timeout and reject if not resolved first.\n\n### 0.11.1\n\n* Added [when/apply](https://github.com/cujojs/when/wiki/when-apply) helper module for using arguments-based and variadic callbacks with `when.all`, `when.some`, `when.map`, or any promise that resolves to an array. ([#14](https://github.com/cujojs/when/issues/14))\n* `.then()`, `when()`, and all other methods that accept callback/errback/progress handlers will throw if you pass something that's not a function. ([#15](https://github.com/cujojs/when/issues/15))\n\n### 0.11.0\n\n* `when.js` now *assimilates* thenables that pass the [Promises/A duck-type test](http://wiki.commonjs.org/wiki/Promises/A), but which may not be fully Promises/A compliant, such as [jQuery's Deferred](http://api.jquery.com/category/deferred-object/) and [curl's global API](https://github.com/cujojs/curl) (See the **API at a glance** section)\n    * `when()`, and `when.all/some/any/map/reduce/chain()` are all now guaranteed to return a fully Promises/A compliant promise, even when their input is not compliant.\n    * Any non-compliant thenable returned by a callback or errback will also be assimilated to protect subsequent promises and callbacks in a promise chain, and preserve Promises/A forwarding guarantees.\n\n\n### 0.10.4\n\n* **Important Fix for some AMD build/optimizer tools**: Switching back to more verbose, builder-friendly boilerplate\n    * If you are using when.js 0.10.3 with the dojo or RequireJS build tools, you should update to v.10.4 as soon as possible.\n\n### 0.10.3\n\n**Warning**: This version will not work with most AMD build tools.  You should update to 0.10.4 as soon as possible.\n\n* Minor `package.json` updates\n* Slightly smaller module boilerplate\n\n### 0.10.2\n\n* Performance optimizations for `when.map()` (thanks @[smitranic](https://github.com/smitranic)), especially for large arrays where the `mapFunc` is also async (i.e. returns a promise)\n* `when.all/some/any/map/reduce` handle sparse arrays (thanks @[rwaldrn](https://github.com/rwldrn/))\n* Other minor performance optimizations\n\n### 0.10.1\n\n* Minor tweaks (thanks @[johan](https://github.com/johan))\n\t* Add missing semis that WebStorm didn't catch\n\t* Fix DOH submodule ref, and update README with info for running unit tests\n\n### 0.10.0\n\n* `when.map` and `when.reduce` - just like Array.map and Array.reduce, but they operate on promises and arrays of promises\n* Lots of internal size and performance optimizations\n* Still only 1k!\n\n### 0.9.4\n\n* Important fix for break in promise chains\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.455078125,
          "content": "# Contributing\n\nThank you for helping out with when.js! We really appreciate you investing your time in the project. Below, find information and guides on the best way to contribute.\n\nOpening Issues\n--------------\n\nNo software is truly without bugs, and if you find one we would love it if you let us know so we can patch it up for you. When opening an issue, make sure to use a clear, short title along with a thorough description of the problem so we can best understand it. It's extremely helpful if you provide concrete steps on how to replicate the issue so that we can isolate it and figure it out more quickly.\n\nPull Requests\n-------------\n\nThere's nothing better than a great pull request. To ensure that yours gets accepted as quickly and smoothly as possible, make sure the following steps have been taken:\n\n- Good clean commit messages. [This guide](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html) should help.\n- A thorough description of what your code does in the description field\n- Tests written for any features that have been added.\n\nRunning the Tests\n-----------------\n\n#### Node\n\nNote that when.js includes the [Promises/A+ Test Suite](https://github.com/promises-aplus/promise-tests).  Running unit tests in Node will run both when.js's own test suite, and the Promises/A+ Test Suite.\n\n1. `npm install`\n2. `npm test`\n\n#### Browsers\n\n1. `npm install`\n2. `npm run browser-test`\n3. Point browsers at <buster server url>, e.g. `http://localhost:8080/`\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.1279296875,
          "content": "Open Source Initiative OSI - The MIT License\n\nhttp://www.opensource.org/licenses/mit-license.php\n\nCopyright (c) 2011 Brian Cavalier\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.6142578125,
          "content": "<a href=\"http://promises-aplus.github.com/promises-spec\"><img src=\"http://promises-aplus.github.com/promises-spec/assets/logo-small.png\" alt=\"Promises/A+ logo\" align=\"right\" /></a>\n\n[![Build Status](https://travis-ci.org/cujojs/when.svg?branch=master)](https://travis-ci.org/cujojs/when)\n[![Inline docs](http://inch-ci.org/github/cujojs/when.svg?branch=master)](http://inch-ci.org/github/cujojs/when)\n\nwhen.js\n=======\n\nWhen.js is a rock solid, battle-tested [Promises/A+](http://promises-aplus.github.com/promises-spec) and `when()` implementation, including a complete [ES6 Promise shim](docs/es6-promise-shim.md).  It's a powerful combination of small size, high performance, debuggability, and rich features:\n\n* Resolve arrays and hashes of promises, as well as infinite promise sequences\n* Execute tasks in parallel or sequentially\n* Transform Node-style and other callback-based APIs into promise-based APIs\n\nWhen.js is one of the many stand-alone components of [cujoJS](http://cujojs.com), the JavaScript Architectural Toolkit.\n\nCheck it out:\n\n- [What's new](CHANGES.md)\n- [API docs](docs/api.md#api)\n- Read more about how [promises simplify async programming](http://know.cujojs.com/tutorials/async/simplifying-async-with-promises)\n\nInstallation\n------------\n\n#### AMD\n\nAvailable as `when` through [bower](http://bower.io), or just clone the repo and load `when.js` from the root.\n\n```\nbower install --save when\n```\n\n#### CommonJS/Node\n\n```\nnpm install --save when\n```\n\n[More help & other environments &raquo;](docs/installation.md)\n\nUsage\n-----\n\nPromises can be used to help manage complex and/or nested callback flows in a simple manner. To get a better handle on how promise flows look and how they can be helpful, there are a couple examples below (using commonjs).\n\nThis first example will print `\"hello world!!!!\"` if all went well, or `\"drat!\"` if there was a problem. It also uses [rest](https://github.com/cujojs/rest) to make an ajax request to a (fictional) external service.\n\n```js\nvar rest = require('rest');\n\nfetchRemoteGreeting()\n    .then(addExclamation)\n    .catch(handleError)\n    .done(function(greeting) {\n        console.log(greeting);\n    });\n\nfunction fetchRemoteGreeting() {\n    // convert native Promise to a when.js promise for 'hello world'\n    var result = rest('http://example.com/greeting');\n    return when(result)\n}\n\nfunction addExclamation(greeting) {\n    return greeting + '!!!!'\n}\n\nfunction handleError(e) {\n    return 'drat!';\n}\n```\n\nThe second example shows off the power that comes with when's promise logic. Here, we get an array of numbers from a remote source and reduce them. The example will print `150` if all went well, and if there was a problem will print a full stack trace.\n\n```js\nvar when = require('when');\nvar rest = require('rest');\n\nwhen.reduce(when.map(getRemoteNumberList(), times10), sum)\n    .done(function(result) {\n        console.log(result);\n    });\n\nfunction getRemoteNumberList() {\n    // Get a remote array [1, 2, 3, 4, 5]\n    return rest('http://example.com/numbers').then(JSON.parse);\n}\n\nfunction sum(x, y) { return x + y; }\nfunction times10(x) {return x * 10; }\n```\n\nLicense\n-------\n\nLicensed under MIT. [Full license here &raquo;](LICENSE.txt)\n\nContributing\n------------\n\nPlease see the [contributing guide](CONTRIBUTING.md) for more information on running tests, opening issues, and contributing code to the project.\n\nReferences\n----------\n\nMuch of this code was inspired by the async innards of [wire.js](https://github.com/cujojs/wire), and has been influenced by the great work in [Q](https://github.com/kriskowal/q), [Dojo's Deferred](https://github.com/dojo/dojo), and [uber.js](https://github.com/phiggins42/uber.js).\n"
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.5810546875,
          "content": "{\n  \"name\": \"when\",\n  \"main\": \"when.js\",\n  \"moduleType\": [\"amd\", \"node\"],\n  \"description\": \"A lightweight Promises/A+ and when() implementation, plus other async goodies.\",\n  \"keywords\": [\"Promises/A+\", \"promises-aplus\", \"promise\", \"promises\", \"deferred\", \"deferreds\", \"when\", \"async\", \"asynchronous\", \"cujo\"],\n  \"homepage\": \"https://github.com/cujojs/when\",\n  \"authors\": [\n    \"Brian Cavalier <brian@hovercraftstudios.com>\"\n  ],\n  \"license\": \"MIT\",\n  \"ignore\": [\n    \"**/.*\",\n    \"**/*.md\",\n    \"docs\",\n    \"benchmark\",\n    \"node_modules\",\n    \"bower_components\",\n    \"test\",\n    \"build\"\n  ]\n}\n"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "callbacks.js",
          "type": "blob",
          "size": 8.2119140625,
          "content": "/** @license MIT License (c) copyright 2013-2014 original author or authors */\n\n/**\n * Collection of helper functions for interacting with 'traditional',\n * callback-taking functions using a promise interface.\n *\n * @author Renato Zannon\n * @contributor Brian Cavalier\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar Promise = when.Promise;\n\tvar _liftAll = require('./lib/liftAll');\n\tvar slice = Array.prototype.slice;\n\n\tvar makeApply = require('./lib/apply');\n\tvar _apply = makeApply(Promise, dispatch);\n\n\treturn {\n\t\tlift: lift,\n\t\tliftAll: liftAll,\n\t\tapply: apply,\n\t\tcall: call,\n\t\tpromisify: promisify\n\t};\n\n\t/**\n\t * Takes a `traditional` callback-taking function and returns a promise for its\n\t * result, accepting an optional array of arguments (that might be values or\n\t * promises). It assumes that the function takes its callback and errback as\n\t * the last two arguments. The resolution of the promise depends on whether the\n\t * function will call its callback or its errback.\n\t *\n\t * @example\n\t *    var domIsLoaded = callbacks.apply($);\n\t *    domIsLoaded.then(function() {\n\t *\t\tdoMyDomStuff();\n\t *\t});\n\t *\n\t * @example\n\t *    function existingAjaxyFunction(url, callback, errback) {\n\t *\t\t// Complex logic you'd rather not change\n\t *\t}\n\t *\n\t *    var promise = callbacks.apply(existingAjaxyFunction, [\"/movies.json\"]);\n\t *\n\t *    promise.then(function(movies) {\n\t *\t\t// Work with movies\n\t *\t}, function(reason) {\n\t *\t\t// Handle error\n\t *\t});\n\t *\n\t * @param {function} asyncFunction function to be called\n\t * @param {Array} [extraAsyncArgs] array of arguments to asyncFunction\n\t * @returns {Promise} promise for the callback value of asyncFunction\n\t */\n\tfunction apply(asyncFunction, extraAsyncArgs) {\n\t\treturn _apply(asyncFunction, this, extraAsyncArgs || []);\n\t}\n\n\t/**\n\t * Apply helper that allows specifying thisArg\n\t * @private\n\t */\n\tfunction dispatch(f, thisArg, args, h) {\n\t\targs.push(alwaysUnary(h.resolve, h), alwaysUnary(h.reject, h));\n\t\ttryCatchResolve(f, thisArg, args, h);\n\t}\n\n\tfunction tryCatchResolve(f, thisArg, args, resolver) {\n\t\ttry {\n\t\t\tf.apply(thisArg, args);\n\t\t} catch(e) {\n\t\t\tresolver.reject(e);\n\t\t}\n\t}\n\n\t/**\n\t * Works as `callbacks.apply` does, with the difference that the arguments to\n\t * the function are passed individually, instead of as an array.\n\t *\n\t * @example\n\t *    function sumInFiveSeconds(a, b, callback) {\n\t *\t\tsetTimeout(function() {\n\t *\t\t\tcallback(a + b);\n\t *\t\t}, 5000);\n\t *\t}\n\t *\n\t *    var sumPromise = callbacks.call(sumInFiveSeconds, 5, 10);\n\t *\n\t *    // Logs '15' 5 seconds later\n\t *    sumPromise.then(console.log);\n\t *\n\t * @param {function} asyncFunction function to be called\n\t * @param {...*} args arguments that will be forwarded to the function\n\t * @returns {Promise} promise for the callback value of asyncFunction\n\t */\n\tfunction call(asyncFunction/*, arg1, arg2...*/) {\n\t\treturn _apply(asyncFunction, this, slice.call(arguments, 1));\n\t}\n\n\t/**\n\t * Takes a 'traditional' callback/errback-taking function and returns a function\n\t * that returns a promise instead. The resolution/rejection of the promise\n\t * depends on whether the original function will call its callback or its\n\t * errback.\n\t *\n\t * If additional arguments are passed to the `lift` call, they will be prepended\n\t * on the calls to the original function, much like `Function.prototype.bind`.\n\t *\n\t * The resulting function is also \"promise-aware\", in the sense that, if given\n\t * promises as arguments, it will wait for their resolution before executing.\n\t *\n\t * @example\n\t *    function traditionalAjax(method, url, callback, errback) {\n\t *\t\tvar xhr = new XMLHttpRequest();\n\t *\t\txhr.open(method, url);\n\t *\n\t *\t\txhr.onload = callback;\n\t *\t\txhr.onerror = errback;\n\t *\n\t *\t\txhr.send();\n\t *\t}\n\t *\n\t *    var promiseAjax = callbacks.lift(traditionalAjax);\n\t *    promiseAjax(\"GET\", \"/movies.json\").then(console.log, console.error);\n\t *\n\t *    var promiseAjaxGet = callbacks.lift(traditionalAjax, \"GET\");\n\t *    promiseAjaxGet(\"/movies.json\").then(console.log, console.error);\n\t *\n\t * @param {Function} f traditional async function to be decorated\n\t * @param {...*} [args] arguments to be prepended for the new function @deprecated\n\t * @returns {Function} a promise-returning function\n\t */\n\tfunction lift(f/*, args...*/) {\n\t\tvar args = arguments.length > 1 ? slice.call(arguments, 1) : [];\n\t\treturn function() {\n\t\t\treturn _apply(f, this, args.concat(slice.call(arguments)));\n\t\t};\n\t}\n\n\t/**\n\t * Lift all the functions/methods on src\n\t * @param {object|function} src source whose functions will be lifted\n\t * @param {function?} combine optional function for customizing the lifting\n\t *  process. It is passed dst, the lifted function, and the property name of\n\t *  the original function on src.\n\t * @param {(object|function)?} dst option destination host onto which to place lifted\n\t *  functions. If not provided, liftAll returns a new object.\n\t * @returns {*} If dst is provided, returns dst with lifted functions as\n\t *  properties.  If dst not provided, returns a new object with lifted functions.\n\t */\n\tfunction liftAll(src, combine, dst) {\n\t\treturn _liftAll(lift, combine, dst, src);\n\t}\n\n\t/**\n\t * `promisify` is a version of `lift` that allows fine-grained control over the\n\t * arguments that passed to the underlying function. It is intended to handle\n\t * functions that don't follow the common callback and errback positions.\n\t *\n\t * The control is done by passing an object whose 'callback' and/or 'errback'\n\t * keys, whose values are the corresponding 0-based indexes of the arguments on\n\t * the function. Negative values are interpreted as being relative to the end\n\t * of the arguments array.\n\t *\n\t * If arguments are given on the call to the 'promisified' function, they are\n\t * intermingled with the callback and errback. If a promise is given among them,\n\t * the execution of the function will only occur after its resolution.\n\t *\n\t * @example\n\t *    var delay = callbacks.promisify(setTimeout, {\n\t *\t\tcallback: 0\n\t *\t});\n\t *\n\t *    delay(100).then(function() {\n\t *\t\tconsole.log(\"This happens 100ms afterwards\");\n\t *\t});\n\t *\n\t * @example\n\t *    function callbackAsLast(errback, followsStandards, callback) {\n\t *\t\tif(followsStandards) {\n\t *\t\t\tcallback(\"well done!\");\n\t *\t\t} else {\n\t *\t\t\terrback(\"some programmers just want to watch the world burn\");\n\t *\t\t}\n\t *\t}\n\t *\n\t *    var promisified = callbacks.promisify(callbackAsLast, {\n\t *\t\tcallback: -1,\n\t *\t\terrback:   0,\n\t *\t});\n\t *\n\t *    promisified(true).then(console.log, console.error);\n\t *    promisified(false).then(console.log, console.error);\n\t *\n\t * @param {Function} asyncFunction traditional function to be decorated\n\t * @param {object} positions\n\t * @param {number} [positions.callback] index at which asyncFunction expects to\n\t *  receive a success callback\n\t * @param {number} [positions.errback] index at which asyncFunction expects to\n\t *  receive an error callback\n\t *  @returns {function} promisified function that accepts\n\t *\n\t * @deprecated\n\t */\n\tfunction promisify(asyncFunction, positions) {\n\n\t\treturn function() {\n\t\t\tvar thisArg = this;\n\t\t\treturn Promise.all(arguments).then(function(args) {\n\t\t\t\tvar p = Promise._defer();\n\n\t\t\t\tvar callbackPos, errbackPos;\n\n\t\t\t\tif(typeof positions.callback === 'number') {\n\t\t\t\t\tcallbackPos = normalizePosition(args, positions.callback);\n\t\t\t\t}\n\n\t\t\t\tif(typeof positions.errback === 'number') {\n\t\t\t\t\terrbackPos = normalizePosition(args, positions.errback);\n\t\t\t\t}\n\n\t\t\t\tif(errbackPos < callbackPos) {\n\t\t\t\t\tinsertCallback(args, errbackPos, p._handler.reject, p._handler);\n\t\t\t\t\tinsertCallback(args, callbackPos, p._handler.resolve, p._handler);\n\t\t\t\t} else {\n\t\t\t\t\tinsertCallback(args, callbackPos, p._handler.resolve, p._handler);\n\t\t\t\t\tinsertCallback(args, errbackPos, p._handler.reject, p._handler);\n\t\t\t\t}\n\n\t\t\t\tasyncFunction.apply(thisArg, args);\n\n\t\t\t\treturn p;\n\t\t\t});\n\t\t};\n\t}\n\n\tfunction normalizePosition(args, pos) {\n\t\treturn pos < 0 ? (args.length + pos + 2) : pos;\n\t}\n\n\tfunction insertCallback(args, pos, callback, thisArg) {\n\t\tif(typeof pos === 'number') {\n\t\t\targs.splice(pos, 0, alwaysUnary(callback, thisArg));\n\t\t}\n\t}\n\n\tfunction alwaysUnary(fn, thisArg) {\n\t\treturn function() {\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tfn.call(thisArg, slice.call(arguments));\n\t\t\t} else {\n\t\t\t\tfn.apply(thisArg, arguments);\n\t\t\t}\n\t\t};\n\t}\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n"
        },
        {
          "name": "cancelable.js",
          "type": "blob",
          "size": 1.6240234375,
          "content": "/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * cancelable.js\n * @deprecated\n *\n * Decorator that makes a deferred \"cancelable\".  It adds a cancel() method that\n * will call a special cancel handler function and then reject the deferred.  The\n * cancel handler can be used to do resource cleanup, or anything else that should\n * be done before any other rejection handlers are executed.\n *\n * Usage:\n *\n * var cancelableDeferred = cancelable(when.defer(), myCancelHandler);\n *\n * @author brian@hovercraftstudios.com\n */\n\n(function(define) {\ndefine(function() {\n\n    /**\n     * Makes deferred cancelable, adding a cancel() method.\n\t * @deprecated\n     *\n     * @param deferred {Deferred} the {@link Deferred} to make cancelable\n     * @param canceler {Function} cancel handler function to execute when this deferred\n\t * is canceled.  This is guaranteed to run before all other rejection handlers.\n\t * The canceler will NOT be executed if the deferred is rejected in the standard\n\t * way, i.e. deferred.reject().  It ONLY executes if the deferred is canceled,\n\t * i.e. deferred.cancel()\n     *\n     * @returns deferred, with an added cancel() method.\n     */\n    return function(deferred, canceler) {\n        // Add a cancel method to the deferred to reject the delegate\n        // with the special canceled indicator.\n        deferred.cancel = function() {\n\t\t\ttry {\n\t\t\t\tdeferred.reject(canceler(deferred));\n\t\t\t} catch(e) {\n\t\t\t\tdeferred.reject(e);\n\t\t\t}\n\n\t\t\treturn deferred.promise;\n        };\n\n        return deferred;\n    };\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); });\n\n\n"
        },
        {
          "name": "delay.js",
          "type": "blob",
          "size": 0.546875,
          "content": "/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * delay.js\n *\n * Helper that returns a promise that resolves after a delay.\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\n    /**\n\t * @deprecated Use when(value).delay(ms)\n     */\n    return function delay(msec, value) {\n\t\treturn when(value).delay(msec);\n    };\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "es6-shim",
          "type": "tree",
          "content": null
        },
        {
          "name": "function.js",
          "type": "blob",
          "size": 3.7490234375,
          "content": "/** @license MIT License (c) copyright 2013-2014 original author or authors */\n\n/**\n * Collection of helper functions for wrapping and executing 'traditional'\n * synchronous functions in a promise interface.\n *\n * @author Brian Cavalier\n * @contributor Renato Zannon\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar attempt = when['try'];\n\tvar _liftAll = require('./lib/liftAll');\n\tvar _apply = require('./lib/apply')(when.Promise);\n\tvar slice = Array.prototype.slice;\n\n\treturn {\n\t\tlift: lift,\n\t\tliftAll: liftAll,\n\t\tcall: attempt,\n\t\tapply: apply,\n\t\tcompose: compose\n\t};\n\n\t/**\n\t * Takes a function and an optional array of arguments (that might be promises),\n\t * and calls the function. The return value is a promise whose resolution\n\t * depends on the value returned by the function.\n\t * @param {function} f function to be called\n\t * @param {Array} [args] array of arguments to func\n\t * @returns {Promise} promise for the return value of func\n\t */\n\tfunction apply(f, args) {\n\t\t// slice args just in case the caller passed an Arguments instance\n\t\treturn _apply(f, this, args == null ? [] : slice.call(args));\n\t}\n\n\t/**\n\t * Takes a 'regular' function and returns a version of that function that\n\t * returns a promise instead of a plain value, and handles thrown errors by\n\t * returning a rejected promise. Also accepts a list of arguments to be\n\t * prepended to the new function, as does Function.prototype.bind.\n\t *\n\t * The resulting function is promise-aware, in the sense that it accepts\n\t * promise arguments, and waits for their resolution.\n\t * @param {Function} f function to be bound\n\t * @param {...*} [args] arguments to be prepended for the new function @deprecated\n\t * @returns {Function} a promise-returning function\n\t */\n\tfunction lift(f /*, args... */) {\n\t\tvar args = arguments.length > 1 ? slice.call(arguments, 1) : [];\n\t\treturn function() {\n\t\t\treturn _apply(f, this, args.concat(slice.call(arguments)));\n\t\t};\n\t}\n\n\t/**\n\t * Lift all the functions/methods on src\n\t * @param {object|function} src source whose functions will be lifted\n\t * @param {function?} combine optional function for customizing the lifting\n\t *  process. It is passed dst, the lifted function, and the property name of\n\t *  the original function on src.\n\t * @param {(object|function)?} dst option destination host onto which to place lifted\n\t *  functions. If not provided, liftAll returns a new object.\n\t * @returns {*} If dst is provided, returns dst with lifted functions as\n\t *  properties.  If dst not provided, returns a new object with lifted functions.\n\t */\n\tfunction liftAll(src, combine, dst) {\n\t\treturn _liftAll(lift, combine, dst, src);\n\t}\n\n\t/**\n\t * Composes multiple functions by piping their return values. It is\n\t * transparent to whether the functions return 'regular' values or promises:\n\t * the piped argument is always a resolved value. If one of the functions\n\t * throws or returns a rejected promise, the composed promise will be also\n\t * rejected.\n\t *\n\t * The arguments (or promises to arguments) given to the returned function (if\n\t * any), are passed directly to the first function on the 'pipeline'.\n\t * @param {Function} f the function to which the arguments will be passed\n\t * @param {...Function} [funcs] functions that will be composed, in order\n\t * @returns {Function} a promise-returning composition of the functions\n\t */\n\tfunction compose(f /*, funcs... */) {\n\t\tvar funcs = slice.call(arguments, 1);\n\n\t\treturn function() {\n\t\t\tvar thisArg = this;\n\t\t\tvar args = slice.call(arguments);\n\t\t\tvar firstPromise = attempt.apply(thisArg, [f].concat(args));\n\n\t\t\treturn when.reduce(funcs, function(arg, func) {\n\t\t\t\treturn func.call(thisArg, arg);\n\t\t\t}, firstPromise);\n\t\t};\n\t}\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n"
        },
        {
          "name": "generator.js",
          "type": "blob",
          "size": 2.5283203125,
          "content": "/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar slice = Array.prototype.slice;\n\tvar Promise = when.Promise;\n\tvar reject = Promise.reject;\n\n\t/**\n\t * Lift a generator to create a function that can suspend and\n\t * resume using the `yield` keyword to await promises.\n\t * @param {function} generator\n\t * @return {function}\n\t */\n\tfunction lift(generator) {\n\t\treturn function() {\n\t\t\treturn run(generator, this, arguments);\n\t\t};\n\t}\n\n\t/**\n\t * Immediately call a generator as a promise-aware coroutine\n\t * that can suspend and resume using the `yield` keyword to\n\t * await promises.  Additional arguments after the first will\n\t * be passed through to the generator.\n\t * @param {function} generator\n\t * @returns {Promise} promise for the ultimate value returned\n\t *  from the generator.\n\t */\n\tfunction call(generator /*x, y, z...*/) {\n\t\t/*jshint validthis:true*/\n\t\treturn run(generator, this, slice.call(arguments, 1));\n\t}\n\n\t/**\n\t * Immediately apply a generator, with the supplied args array,\n\t * as a promise-aware coroutine that can suspend and resume\n\t * using the `yield` keyword to await promises.\n\t * @param {function} generator\n\t * @param {Array} args arguments with which to initialize the generator\n\t * @returns {Promise} promise for the ultimate value returned\n\t *  from the generator.\n\t */\n\tfunction apply(generator, args) {\n\t\t/*jshint validthis:true*/\n\t\treturn run(generator, this, args || []);\n\t}\n\n\t/**\n\t * Helper to initiate the provided generator as a coroutine\n\t * @returns {*}\n\t */\n\tfunction run(generator, thisArg, args) {\n\t\treturn runNext(void 0, generator.apply(thisArg, args));\n\t}\n\n\tfunction runNext(x, iterator) {\n\t\ttry {\n\t\t\treturn handle(iterator.next(x), iterator);\n\t\t} catch(e) {\n\t\t\treturn reject(e);\n\t\t}\n\t}\n\n\tfunction next(x) {\n\t\t/*jshint validthis:true*/\n\t\treturn runNext(x, this);\n\t}\n\n\tfunction error(e) {\n\t\t/*jshint validthis:true*/\n\t\ttry {\n\t\t\treturn handle(this.throw(e), this);\n\t\t} catch(e) {\n\t\t\treturn reject(e);\n\t\t}\n\t}\n\n\tfunction handle(result, iterator) {\n\t\tif(result.done) {\n\t\t\treturn result.value;\n\t\t}\n\n\t\tvar h = Promise._handler(result.value);\n\t\tif(h.state() > 0) {\n\t\t\treturn runNext(h.value, iterator);\n\t\t}\n\n\t\tvar p = Promise._defer();\n\t\th.chain(p._handler, iterator, next, error);\n\t\treturn p;\n\t}\n\n\treturn {\n\t\tlift: lift,\n\t\tcall: call,\n\t\tapply: apply\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n"
        },
        {
          "name": "guard.js",
          "type": "blob",
          "size": 1.853515625,
          "content": "/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * Generalized promise concurrency guard\n * Adapted from original concept by Sakari Jokinen (Rocket Pack, Ltd.)\n *\n * @author Brian Cavalier\n * @author John Hann\n * @contributor Sakari Jokinen\n */\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar slice = Array.prototype.slice;\n\n\tguard.n = n;\n\n\treturn guard;\n\n\t/**\n\t * Creates a guarded version of f that can only be entered when the supplied\n\t * condition allows.\n\t * @param {function} condition represents a critical section that may only\n\t *  be entered when allowed by the condition\n\t * @param {function} f function to guard\n\t * @returns {function} guarded version of f\n\t */\n\tfunction guard(condition, f) {\n\t\treturn function() {\n\t\t\tvar args = slice.call(arguments);\n\n\t\t\treturn when(condition()).withThis(this).then(function(exit) {\n\t\t\t\treturn when(f.apply(this, args))['finally'](exit);\n\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t * Creates a condition that allows only n simultaneous executions\n\t * of a guarded function\n\t * @param {number} allowed number of allowed simultaneous executions\n\t * @returns {function} condition function which returns a promise that\n\t *  fulfills when the critical section may be entered.  The fulfillment\n\t *  value is a function (\"notifyExit\") that must be called when the critical\n\t *  section has been exited.\n\t */\n\tfunction n(allowed) {\n\t\tvar count = 0;\n\t\tvar waiting = [];\n\n\t\treturn function enter() {\n\t\t\treturn when.promise(function(resolve) {\n\t\t\t\tif(count < allowed) {\n\t\t\t\t\tresolve(exit);\n\t\t\t\t} else {\n\t\t\t\t\twaiting.push(resolve);\n\t\t\t\t}\n\t\t\t\tcount += 1;\n\t\t\t});\n\t\t};\n\n\t\tfunction exit() {\n\t\t\tcount = Math.max(count - 1, 0);\n\t\t\tif(waiting.length > 0) {\n\t\t\t\twaiting.shift()(exit);\n\t\t\t}\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n"
        },
        {
          "name": "keys.js",
          "type": "blob",
          "size": 2.857421875,
          "content": "/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar Promise = when.Promise;\n\tvar toPromise = when.resolve;\n\n\treturn {\n\t\tall: when.lift(all),\n\t\tmap: map,\n\t\tsettle: settle\n\t};\n\n\t/**\n\t * Resolve all the key-value pairs in the supplied object or promise\n\t * for an object.\n\t * @param {Promise|object} object or promise for object whose key-value pairs\n\t *  will be resolved\n\t * @returns {Promise} promise for an object with the fully resolved key-value pairs\n\t */\n\tfunction all(object) {\n\t\tvar p = Promise._defer();\n\t\tvar resolver = Promise._handler(p);\n\n\t\tvar results = {};\n\t\tvar keys = Object.keys(object);\n\t\tvar pending = keys.length;\n\n\t\tfor(var i=0, k; i<keys.length; ++i) {\n\t\t\tk = keys[i];\n\t\t\tPromise._handler(object[k]).fold(settleKey, k, results, resolver);\n\t\t}\n\n\t\tif(pending === 0) {\n\t\t\tresolver.resolve(results);\n\t\t}\n\n\t\treturn p;\n\n\t\tfunction settleKey(k, x, resolver) {\n\t\t\t/*jshint validthis:true*/\n\t\t\tthis[k] = x;\n\t\t\tif(--pending === 0) {\n\t\t\t\tresolver.resolve(results);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Map values in the supplied object's keys\n\t * @param {Promise|object} object or promise for object whose key-value pairs\n\t *  will be reduced\n\t * @param {function(value:*, key:String):*} f mapping function which may\n\t *  return either a promise or a value\n\t * @returns {Promise} promise for an object with the mapped and fully\n\t *  resolved key-value pairs\n\t */\n\tfunction map(object, f) {\n\t\treturn toPromise(object).then(function(object) {\n\t\t\treturn all(Object.keys(object).reduce(function(o, k) {\n\t\t\t\to[k] = toPromise(object[k]).fold(mapWithKey, k);\n\t\t\t\treturn o;\n\t\t\t}, {}));\n\t\t});\n\n\t\tfunction mapWithKey(k, x) {\n\t\t\treturn f(x, k);\n\t\t}\n\t}\n\n\t/**\n\t * Resolve all key-value pairs in the supplied object and return a promise\n\t * that will always fulfill with the outcome states of all input promises.\n\t * @param {object} object whose key-value pairs will be settled\n\t * @returns {Promise} promise for an object with the mapped and fully\n\t *  settled key-value pairs\n\t */\n\tfunction settle(object) {\n\t\tvar keys = Object.keys(object);\n\t\tvar results = {};\n\n\t\tif(keys.length === 0) {\n\t\t\treturn toPromise(results);\n\t\t}\n\n\t\tvar p = Promise._defer();\n\t\tvar resolver = Promise._handler(p);\n\t\tvar promises = keys.map(function(k) { return object[k]; });\n\n\t\twhen.settle(promises).then(function(states) {\n\t\t\tpopulateResults(keys, states, results, resolver);\n\t\t});\n\n\t\treturn p;\n\t}\n\n\tfunction populateResults(keys, states, results, resolver) {\n\t\tfor(var i=0; i<keys.length; i++) {\n\t\t\tresults[keys[i]] = states[i];\n\t\t}\n\t\tresolver.resolve(results);\n\t}\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "monitor.js",
          "type": "blob",
          "size": 0.564453125,
          "content": "/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar PromiseMonitor = require('./monitor/PromiseMonitor');\n\tvar ConsoleReporter = require('./monitor/ConsoleReporter');\n\n\tvar promiseMonitor = new PromiseMonitor(new ConsoleReporter());\n\n\treturn function(Promise) {\n\t\treturn promiseMonitor.monitor(Promise);\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n"
        },
        {
          "name": "monitor",
          "type": "tree",
          "content": null
        },
        {
          "name": "node.js",
          "type": "blob",
          "size": 8.193359375,
          "content": "/** @license MIT License (c) copyright 2013 original author or authors */\n\n/**\n * Collection of helpers for interfacing with node-style asynchronous functions\n * using promises.\n *\n * @author Brian Cavalier\n * @contributor Renato Zannon\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar _liftAll = require('./lib/liftAll');\n\tvar setTimer = require('./lib/env').setTimer;\n\tvar slice = Array.prototype.slice;\n\n\tvar _apply = require('./lib/apply')(when.Promise, dispatch);\n\n\treturn {\n\t\tlift: lift,\n\t\tliftAll: liftAll,\n\t\tapply: apply,\n\t\tcall: call,\n\t\tcreateCallback: createCallback,\n\t\tbindCallback: bindCallback,\n\t\tliftCallback: liftCallback\n\t};\n\n\t/**\n\t * Takes a node-style async function and calls it immediately (with an optional\n\t * array of arguments or promises for arguments). It returns a promise whose\n\t * resolution depends on whether the async functions calls its callback with the\n\t * conventional error argument or not.\n\t *\n\t * With this it becomes possible to leverage existing APIs while still reaping\n\t * the benefits of promises.\n\t *\n\t * @example\n\t *    function onlySmallNumbers(n, callback) {\n\t *\t\tif(n < 10) {\n\t *\t\t\tcallback(null, n + 10);\n\t *\t\t} else {\n\t *\t\t\tcallback(new Error(\"Calculation failed\"));\n\t *\t\t}\n\t *\t}\n\t *\n\t *    var nodefn = require(\"when/node/function\");\n\t *\n\t *    // Logs '15'\n\t *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);\n\t *\n\t *    // Logs 'Calculation failed'\n\t *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);\n\t *\n\t * @param {function} f node-style function that will be called\n\t * @param {Array} [args] array of arguments to func\n\t * @returns {Promise} promise for the value func passes to its callback\n\t */\n\tfunction apply(f, args) {\n\t\treturn _apply(f, this, args || []);\n\t}\n\n\tfunction dispatch(f, thisArg, args, h) {\n\t\tvar cb = createCallback(h);\n\t\ttry {\n\t\t\tswitch(args.length) {\n\t\t\t\tcase 2: f.call(thisArg, args[0], args[1], cb); break;\n\t\t\t\tcase 1: f.call(thisArg, args[0], cb); break;\n\t\t\t\tcase 0: f.call(thisArg, cb); break;\n\t\t\t\tdefault:\n\t\t\t\t\targs.push(cb);\n\t\t\t\t\tf.apply(thisArg, args);\n\t\t\t}\n\t\t} catch(e) {\n\t\t\th.reject(e);\n\t\t}\n\t}\n\n\t/**\n\t * Has the same behavior that {@link apply} has, with the difference that the\n\t * arguments to the function are provided individually, while {@link apply} accepts\n\t * a single array.\n\t *\n\t * @example\n\t *    function sumSmallNumbers(x, y, callback) {\n\t *\t\tvar result = x + y;\n\t *\t\tif(result < 10) {\n\t *\t\t\tcallback(null, result);\n\t *\t\t} else {\n\t *\t\t\tcallback(new Error(\"Calculation failed\"));\n\t *\t\t}\n\t *\t}\n\t *\n\t *    // Logs '5'\n\t *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);\n\t *\n\t *    // Logs 'Calculation failed'\n\t *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);\n\t *\n\t * @param {function} f node-style function that will be called\n\t * @param {...*} [args] arguments that will be forwarded to the function\n\t * @returns {Promise} promise for the value func passes to its callback\n\t */\n\tfunction call(f /*, args... */) {\n\t\treturn _apply(f, this, slice.call(arguments, 1));\n\t}\n\n\t/**\n\t * Takes a node-style function and returns new function that wraps the\n\t * original and, instead of taking a callback, returns a promise. Also, it\n\t * knows how to handle promises given as arguments, waiting for their\n\t * resolution before executing.\n\t *\n\t * Upon execution, the original function is executed as well. If it passes\n\t * a truthy value as the first argument to the callback, it will be\n\t * interpreted as an error condition, and the promise will be rejected\n\t * with it. Otherwise, the call is considered a resolution, and the promise\n\t * is resolved with the callback's second argument.\n\t *\n\t * @example\n\t *    var fs = require(\"fs\"), nodefn = require(\"when/node/function\");\n\t *\n\t *    var promiseRead = nodefn.lift(fs.readFile);\n\t *\n\t *    // The promise is resolved with the contents of the file if everything\n\t *    // goes ok\n\t *    promiseRead('exists.txt').then(console.log, console.error);\n\t *\n\t *    // And will be rejected if something doesn't work out\n\t *    // (e.g. the files does not exist)\n\t *    promiseRead('doesnt_exist.txt').then(console.log, console.error);\n\t *\n\t *\n\t * @param {Function} f node-style function to be lifted\n\t * @param {...*} [args] arguments to be prepended for the new function @deprecated\n\t * @returns {Function} a promise-returning function\n\t */\n\tfunction lift(f /*, args... */) {\n\t\tvar args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];\n\t\treturn function() {\n\t\t\t// TODO: Simplify once partialing has been removed\n\t\t\tvar l = args1.length;\n\t\t\tvar al = arguments.length;\n\t\t\tvar args = new Array(al + l);\n\t\t\tvar i;\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\targs[i] = args1[i];\n\t\t\t}\n\t\t\tfor(i=0; i<al; ++i) {\n\t\t\t\targs[i+l] = arguments[i];\n\t\t\t}\n\t\t\treturn _apply(f, this, args);\n\t\t};\n\t}\n\n\t/**\n\t * Lift all the functions/methods on src\n\t * @param {object|function} src source whose functions will be lifted\n\t * @param {function?} combine optional function for customizing the lifting\n\t *  process. It is passed dst, the lifted function, and the property name of\n\t *  the original function on src.\n\t * @param {(object|function)?} dst option destination host onto which to place lifted\n\t *  functions. If not provided, liftAll returns a new object.\n\t * @returns {*} If dst is provided, returns dst with lifted functions as\n\t *  properties.  If dst not provided, returns a new object with lifted functions.\n\t */\n\tfunction liftAll(src, combine, dst) {\n\t\treturn _liftAll(lift, combine, dst, src);\n\t}\n\n\t/**\n\t * Takes an object that responds to the resolver interface, and returns\n\t * a function that will resolve or reject it depending on how it is called.\n\t *\n\t * @example\n\t *\tfunction callbackTakingFunction(callback) {\n\t *\t\tif(somethingWrongHappened) {\n\t *\t\t\tcallback(error);\n\t *\t\t} else {\n\t *\t\t\tcallback(null, interestingValue);\n\t *\t\t}\n\t *\t}\n\t *\n\t *\tvar when = require('when'), nodefn = require('when/node/function');\n\t *\n\t *\tvar deferred = when.defer();\n\t *\tcallbackTakingFunction(nodefn.createCallback(deferred.resolver));\n\t *\n\t *\tdeferred.promise.then(function(interestingValue) {\n\t *\t\t// Use interestingValue\n\t *\t});\n\t *\n\t * @param {Resolver} resolver that will be 'attached' to the callback\n\t * @returns {Function} a node-style callback function\n\t */\n\tfunction createCallback(resolver) {\n\t\treturn function(err, value) {\n\t\t\tif(err) {\n\t\t\t\tresolver.reject(err);\n\t\t\t} else if(arguments.length > 2) {\n\t\t\t\tresolver.resolve(slice.call(arguments, 1));\n\t\t\t} else {\n\t\t\t\tresolver.resolve(value);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Attaches a node-style callback to a promise, ensuring the callback is\n\t * called for either fulfillment or rejection. Returns a promise with the same\n\t * state as the passed-in promise.\n\t *\n\t * @example\n\t *\tvar deferred = when.defer();\n\t *\n\t *\tfunction callback(err, value) {\n\t *\t\t// Handle err or use value\n\t *\t}\n\t *\n\t *\tbindCallback(deferred.promise, callback);\n\t *\n\t *\tdeferred.resolve('interesting value');\n\t *\n\t * @param {Promise} promise The promise to be attached to.\n\t * @param {Function} callback The node-style callback to attach.\n\t * @returns {Promise} A promise with the same state as the passed-in promise.\n\t */\n\tfunction bindCallback(promise, callback) {\n\t\tpromise = when(promise);\n\n\t\tif (callback) {\n\t\t\tpromise.then(success, wrapped);\n\t\t}\n\n\t\treturn promise;\n\n\t\tfunction success(value) {\n\t\t\twrapped(null, value);\n\t\t}\n\n\t\tfunction wrapped(err, value) {\n\t\t\tsetTimer(function () {\n\t\t\t\tcallback(err, value);\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\t/**\n\t * Takes a node-style callback and returns new function that accepts a\n\t * promise, calling the original callback when the promise is either\n\t * fulfilled or rejected with the appropriate arguments.\n\t *\n\t * @example\n\t *\tvar deferred = when.defer();\n\t *\n\t *\tfunction callback(err, value) {\n\t *\t\t// Handle err or use value\n\t *\t}\n\t *\n\t *\tvar wrapped = liftCallback(callback);\n\t *\n\t *\t// `wrapped` can now be passed around at will\n\t *\twrapped(deferred.promise);\n\t *\n\t *\tdeferred.resolve('interesting value');\n\t *\n\t * @param {Function} callback The node-style callback to wrap.\n\t * @returns {Function} The lifted, promise-accepting function.\n\t */\n\tfunction liftCallback(callback) {\n\t\treturn function(promise) {\n\t\t\treturn bindCallback(promise, callback);\n\t\t};\n\t}\n});\n\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n\n"
        },
        {
          "name": "node",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 2.9267578125,
          "content": "{\n  \"name\": \"when\",\n  \"version\": \"3.7.8\",\n  \"description\": \"A lightweight Promises/A+ and when() implementation, plus other async goodies.\",\n  \"keywords\": [\n    \"cujo\",\n    \"Promises/A+\",\n    \"promises-aplus\",\n    \"promise\",\n    \"promises\",\n    \"deferred\",\n    \"deferreds\",\n    \"when\",\n    \"async\",\n    \"asynchronous\",\n    \"ender\"\n  ],\n  \"homepage\": \"http://cujojs.com\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/cujojs/when\"\n  },\n  \"bugs\": \"https://github.com/cujojs/when/issues\",\n  \"maintainers\": [\n    {\n      \"name\": \"Brian Cavalier\",\n      \"web\": \"http://hovercraftstudios.com\"\n    },\n    {\n      \"name\": \"John Hann\",\n      \"web\": \"http://unscriptable.com\"\n    }\n  ],\n  \"contributors\": [\n    {\n      \"name\": \"Brian Cavalier\",\n      \"web\": \"http://hovercraftstudios.com\"\n    },\n    {\n      \"name\": \"John Hann\",\n      \"web\": \"http://unscriptable.com\"\n    },\n    {\n      \"name\": \"Scott Andrews\"\n    }\n  ],\n  \"devDependencies\": {\n    \"benchmark\": \"~1\",\n    \"browserify\": \"~2\",\n    \"buster\": \"~0.7\",\n    \"exorcist\": \"~0.4\",\n    \"glob\": \"^7.1.1\",\n    \"jshint\": \"~2\",\n    \"json5\": \"~0.2\",\n    \"microtime\": \"~2\",\n    \"mkdirp\": \"^0.5.1\",\n    \"optimist\": \"~0.6\",\n    \"poly\": \"^0.6.1\",\n    \"promises-aplus-tests\": \"~2\",\n    \"rest\": \"1.1.x\",\n    \"sauce-connect-launcher\": \"~0.4\",\n    \"uglify-js\": \"~2\",\n    \"wd\": \"~0.2\"\n  },\n  \"main\": \"when.js\",\n  \"ender\": {\n    \"files\": [\n      \"*.js\",\n      \"lib/*.js\",\n      \"node/*.js\",\n      \"unfold/*.js\",\n      \"monitor/*.js\",\n      \"lib/decorators/*.js\"\n    ]\n  },\n  \"browser\": {\n    \"when\": \"./dist/browser/when.js\",\n    \"vertx\": false\n  },\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"test\": \"jshint . && buster-test -e node && promises-aplus-tests test/promises-aplus-adapter.js\",\n    \"build-browser-test\": \"browserify ./node_modules/poly/es5.js -o test/browser/es5.js && node scripts/browserify-tests\",\n    \"browser-test\": \"npm run build-browser-test && buster-static -e browser -p 8080\",\n    \"ci\": \"npm test && node test/sauce.js\",\n    \"tunnel\": \"node test/sauce.js -m\",\n    \"start\": \"buster-static -e browser\",\n    \"benchmark\": \"node benchmark/promise && node benchmark/map\",\n    \"prepublish\": \"npm run browserify && npm run uglify\",\n    \"preversion\": \"npm run browserify && npm run uglify\",\n    \"browserify\": \"npm run browserify-es6 && npm run browserify-when && npm run browserify-debug\",\n    \"browserify-es6\": \"node scripts/browserify.js es6\",\n    \"browserify-when\": \"node scripts/browserify.js when\",\n    \"browserify-debug\": \"node scripts/browserify.js debug\",\n    \"uglify\": \"npm run uglify-es6 && npm run uglify-when\",\n    \"uglify-es6\": \"uglifyjs es6-shim/Promise.js --compress --mangle  --in-source-map es6-shim/Promise.js.map --source-map es6-shim/Promise.min.js.map -o es6-shim/Promise.min.js\",\n    \"uglify-when\": \"uglifyjs dist/browser/when.js --compress --mangle  --in-source-map dist/browser/when.js.map --source-map dist/browser/when.min.js.map -o dist/browser/when.min.js\"\n  }\n}\n"
        },
        {
          "name": "parallel.js",
          "type": "blob",
          "size": 1.03515625,
          "content": "/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * parallel.js\n *\n * Run a set of task functions in parallel.  All tasks will\n * receive the same args\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar all = when.Promise.all;\n\tvar slice = Array.prototype.slice;\n\n\t/**\n\t * Run array of tasks in parallel\n\t * @param tasks {Array|Promise} array or promiseForArray of task functions\n\t * @param [args] {*} arguments to be passed to all tasks\n\t * @return {Promise} promise for array containing the\n\t * result of each task in the array position corresponding\n\t * to position of the task in the tasks array\n\t */\n\treturn function parallel(tasks /*, args... */) {\n\t\treturn all(slice.call(arguments, 1)).then(function(args) {\n\t\t\treturn when.map(tasks, function(task) {\n\t\t\t\treturn task.apply(void 0, args);\n\t\t\t});\n\t\t});\n\t};\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n"
        },
        {
          "name": "pipeline.js",
          "type": "blob",
          "size": 1.47265625,
          "content": "/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * pipeline.js\n *\n * Run a set of task functions in sequence, passing the result\n * of the previous as an argument to the next.  Like a shell\n * pipeline, e.g. `cat file.txt | grep 'foo' | sed -e 's/foo/bar/g'\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar all = when.Promise.all;\n\tvar slice = Array.prototype.slice;\n\n\t/**\n\t * Run array of tasks in a pipeline where the next\n\t * tasks receives the result of the previous.  The first task\n\t * will receive the initialArgs as its argument list.\n\t * @param tasks {Array|Promise} array or promise for array of task functions\n\t * @param [initialArgs...] {*} arguments to be passed to the first task\n\t * @return {Promise} promise for return value of the final task\n\t */\n\treturn function pipeline(tasks /* initialArgs... */) {\n\t\t// Self-optimizing function to run first task with multiple\n\t\t// args using apply, but subsequence tasks via direct invocation\n\t\tvar runTask = function(args, task) {\n\t\t\trunTask = function(arg, task) {\n\t\t\t\treturn task(arg);\n\t\t\t};\n\n\t\t\treturn task.apply(null, args);\n\t\t};\n\n\t\treturn all(slice.call(arguments, 1)).then(function(args) {\n\t\t\treturn when.reduce(tasks, function(arg, task) {\n\t\t\t\treturn runTask(arg, task);\n\t\t\t}, args);\n\t\t});\n\t};\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n"
        },
        {
          "name": "poll.js",
          "type": "blob",
          "size": 3.09765625,
          "content": "/** @license MIT License (c) copyright 2012-2013 original author or authors */\n\n/**\n * poll.js\n *\n * Helper that polls until cancelled or for a condition to become true.\n *\n * @author Scott Andrews\n */\n\n(function (define) { 'use strict';\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar attempt = when['try'];\n\tvar cancelable = require('./cancelable');\n\n\t/**\n\t * Periodically execute the task function on the msec delay. The result of\n\t * the task may be verified by watching for a condition to become true. The\n\t * returned deferred is cancellable if the polling needs to be cancelled\n\t * externally before reaching a resolved state.\n\t *\n\t * The next vote is scheduled after the results of the current vote are\n\t * verified and rejected.\n\t *\n\t * Polling may be terminated by the verifier returning a truthy value,\n\t * invoking cancel() on the returned promise, or the task function returning\n\t * a rejected promise.\n\t *\n\t * Usage:\n\t *\n\t * var count = 0;\n\t * function doSomething() { return count++ }\n\t *\n\t * // poll until cancelled\n\t * var p = poll(doSomething, 1000);\n\t * ...\n\t * p.cancel();\n\t *\n\t * // poll until condition is met\n\t * poll(doSomething, 1000, function(result) { return result > 10 })\n\t *     .then(function(result) { assert result == 10 });\n\t *\n\t * // delay first vote\n\t * poll(doSomething, 1000, anyFunc, true);\n\t *\n\t * @param task {Function} function that is executed after every timeout\n\t * @param interval {number|Function} timeout in milliseconds\n\t * @param [verifier] {Function} function to evaluate the result of the vote.\n\t *     May return a {Promise} or a {Boolean}. Rejecting the promise or a\n\t *     falsey value will schedule the next vote.\n\t * @param [delayInitialTask] {boolean} if truthy, the first vote is scheduled\n\t *     instead of immediate\n\t *\n\t * @returns {Promise}\n\t */\n\treturn function poll(task, interval, verifier, delayInitialTask) {\n\t\tvar deferred, canceled, reject;\n\n\t\tcanceled = false;\n\t\tdeferred = cancelable(when.defer(), function () { canceled = true; });\n\t\treject = deferred.reject;\n\n\t\tverifier = verifier || function () { return false; };\n\n\t\tif (typeof interval !== 'function') {\n\t\t\tinterval = (function (interval) {\n\t\t\t\treturn function () { return when().delay(interval); };\n\t\t\t})(interval);\n\t\t}\n\n\t\tfunction certify(result) {\n\t\t\tdeferred.resolve(result);\n\t\t}\n\n\t\tfunction schedule(result) {\n\t\t\tattempt(interval).then(vote, reject);\n\t\t\tif (result !== void 0) {\n\t\t\t\tdeferred.notify(result);\n\t\t\t}\n\t\t}\n\n\t\tfunction vote() {\n\t\t\tif (canceled) { return; }\n\t\t\twhen(task(),\n\t\t\t\tfunction (result) {\n\t\t\t\t\twhen(verifier(result),\n\t\t\t\t\t\tfunction (verification) {\n\t\t\t\t\t\t\treturn verification ? certify(result) : schedule(result);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction () { schedule(result); }\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\treject\n\t\t\t);\n\t\t}\n\n\t\tif (delayInitialTask) {\n\t\t\tschedule();\n\t\t} else {\n\t\t\t// if task() is blocking, vote will also block\n\t\t\tvote();\n\t\t}\n\n\t\t// make the promise cancelable\n\t\tdeferred.promise = Object.create(deferred.promise);\n\t\tdeferred.promise.cancel = deferred.cancel;\n\n\t\treturn deferred.promise;\n\t};\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "sequence.js",
          "type": "blob",
          "size": 1.1904296875,
          "content": "/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * sequence.js\n *\n * Run a set of task functions in sequence.  All tasks will\n * receive the same args.\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar all = when.Promise.all;\n\tvar slice = Array.prototype.slice;\n\n\t/**\n\t * Run array of tasks in sequence with no overlap\n\t * @param tasks {Array|Promise} array or promiseForArray of task functions\n\t * @param [args] {*} arguments to be passed to all tasks\n\t * @return {Promise} promise for an array containing\n\t * the result of each task in the array position corresponding\n\t * to position of the task in the tasks array\n\t */\n\treturn function sequence(tasks /*, args... */) {\n\t\tvar results = [];\n\n\t\treturn all(slice.call(arguments, 1)).then(function(args) {\n\t\t\treturn when.reduce(tasks, function(results, task) {\n\t\t\t\treturn when(task.apply(void 0, args), addResult);\n\t\t\t}, results);\n\t\t});\n\n\t\tfunction addResult(result) {\n\t\t\tresults.push(result);\n\t\t\treturn results;\n\t\t}\n\t};\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "timeout.js",
          "type": "blob",
          "size": 0.6240234375,
          "content": "/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * timeout.js\n *\n * Helper that returns a promise that rejects after a specified timeout,\n * if not explicitly resolved or rejected before that.\n *\n * @author Brian Cavalier\n * @author John Hann\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\n    /**\n\t * @deprecated Use when(trigger).timeout(ms)\n     */\n    return function timeout(msec, trigger) {\n\t\treturn when(trigger).timeout(msec);\n    };\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n"
        },
        {
          "name": "unfold.js",
          "type": "blob",
          "size": 0.3603515625,
          "content": "/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * unfold\n * @author: brian@hovercraftstudios.com\n */\n(function(define) {\ndefine(function(require) {\n\n\t/**\n\t * @deprecated Use when.unfold\n\t */\n\treturn require('./when').unfold;\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); } );\n\n"
        },
        {
          "name": "unfold",
          "type": "tree",
          "content": null
        },
        {
          "name": "when.js",
          "type": "blob",
          "size": 7.9501953125,
          "content": "/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * Promises/A+ and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n */\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar timed = require('./lib/decorators/timed');\n\tvar array = require('./lib/decorators/array');\n\tvar flow = require('./lib/decorators/flow');\n\tvar fold = require('./lib/decorators/fold');\n\tvar inspect = require('./lib/decorators/inspect');\n\tvar generate = require('./lib/decorators/iterate');\n\tvar progress = require('./lib/decorators/progress');\n\tvar withThis = require('./lib/decorators/with');\n\tvar unhandledRejection = require('./lib/decorators/unhandledRejection');\n\tvar TimeoutError = require('./lib/TimeoutError');\n\n\tvar Promise = [array, flow, fold, generate, progress,\n\t\tinspect, withThis, timed, unhandledRejection]\n\t\t.reduce(function(Promise, feature) {\n\t\t\treturn feature(Promise);\n\t\t}, require('./lib/Promise'));\n\n\tvar apply = require('./lib/apply')(Promise);\n\n\t// Public API\n\n\twhen.promise     = promise;              // Create a pending promise\n\twhen.resolve     = Promise.resolve;      // Create a resolved promise\n\twhen.reject      = Promise.reject;       // Create a rejected promise\n\n\twhen.lift        = lift;                 // lift a function to return promises\n\twhen['try']      = attempt;              // call a function and return a promise\n\twhen.attempt     = attempt;              // alias for when.try\n\n\twhen.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\twhen.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\n\twhen.join        = join;                 // Join 2 or more promises\n\n\twhen.all         = all;                  // Resolve a list of promises\n\twhen.settle      = settle;               // Settle a list of promises\n\n\twhen.any         = lift(Promise.any);    // One-winner race\n\twhen.some        = lift(Promise.some);   // Multi-winner race\n\twhen.race        = lift(Promise.race);   // First-to-settle race\n\n\twhen.map         = map;                  // Array.map() for promises\n\twhen.filter      = filter;               // Array.filter() for promises\n\twhen.reduce      = lift(Promise.reduce);       // Array.reduce() for promises\n\twhen.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises\n\n\twhen.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable\n\n\twhen.Promise     = Promise;              // Promise constructor\n\twhen.defer       = defer;                // Create a {promise, resolve, reject} tuple\n\n\t// Error types\n\n\twhen.TimeoutError = TimeoutError;\n\n\t/**\n\t * Get a trusted promise for x, or by transforming x with onFulfilled\n\t *\n\t * @param {*} x\n\t * @param {function?} onFulfilled callback to be called when x is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} onRejected callback to be called when x is\n\t *   rejected.\n\t * @param {function?} onProgress callback to be called when progress updates\n\t *   are issued for x. @deprecated\n\t * @returns {Promise} a new promise that will fulfill with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(x, onFulfilled, onRejected, onProgress) {\n\t\tvar p = Promise.resolve(x);\n\t\tif (arguments.length < 2) {\n\t\t\treturn p;\n\t\t}\n\n\t\treturn p.then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn new Promise(resolver);\n\t}\n\n\t/**\n\t * Lift the supplied function, creating a version of f that returns\n\t * promises, and accepts promises as arguments.\n\t * @param {function} f\n\t * @returns {Function} version of f that returns promises\n\t */\n\tfunction lift(f) {\n\t\treturn function() {\n\t\t\tfor(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {\n\t\t\t\ta[i] = arguments[i];\n\t\t\t}\n\t\t\treturn apply(f, this, a);\n\t\t};\n\t}\n\n\t/**\n\t * Call f in a future turn, with the supplied args, and return a promise\n\t * for the result.\n\t * @param {function} f\n\t * @returns {Promise}\n\t */\n\tfunction attempt(f /*, args... */) {\n\t\t/*jshint validthis:true */\n\t\tfor(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {\n\t\t\ta[i] = arguments[i+1];\n\t\t}\n\t\treturn apply(f, this, a);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n\t */\n\tfunction defer() {\n\t\treturn new Deferred();\n\t}\n\n\tfunction Deferred() {\n\t\tvar p = Promise._defer();\n\n\t\tfunction resolve(x) { p._handler.resolve(x); }\n\t\tfunction reject(x) { p._handler.reject(x); }\n\t\tfunction notify(x) { p._handler.notify(x); }\n\n\t\tthis.promise = p;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t\tthis.notify = notify;\n\t\tthis.resolver = { resolve: resolve, reject: reject, notify: notify };\n\t}\n\n\t/**\n\t * Determines if x is promise-like, i.e. a thenable object\n\t * NOTE: Will return true for *any thenable object*, and isn't truly\n\t * safe, since it may attempt to access the `then` property of x (i.e.\n\t *  clever/malicious getters may do weird things)\n\t * @param {*} x anything\n\t * @returns {boolean} true if x is promise-like\n\t */\n\tfunction isPromiseLike(x) {\n\t\treturn x && typeof x.then === 'function';\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied arguments\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the arguments.\n\t * @param {...*} arguments may be a mix of promises and values\n\t * @returns {Promise}\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn Promise.all(arguments);\n\t}\n\n\t/**\n\t * Return a promise that will fulfill once all input promises have\n\t * fulfilled, or reject when any one input promise rejects.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise}\n\t */\n\tfunction all(promises) {\n\t\treturn when(promises, Promise.all);\n\t}\n\n\t/**\n\t * Return a promise that will always fulfill with an array containing\n\t * the outcome states of all input promises.  The returned promise\n\t * will only reject if `promises` itself is a rejected promise.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise} promise for array of settled state descriptors\n\t */\n\tfunction settle(promises) {\n\t\treturn when(promises, Promise.settle);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} promises array of anything, may contain promises and values\n\t * @param {function(x:*, index:Number):*} mapFunc map function which may\n\t *  return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(promises, mapFunc) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.map(promises, mapFunc);\n\t\t});\n\t}\n\n\t/**\n\t * Filter the provided array of promises using the provided predicate.  Input may\n\t * contain promises and values\n\t * @param {Array|Promise} promises array of promises and values\n\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t *  Must return truthy (or promise for truthy) for items to retain.\n\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t *  for which predicate returned truthy.\n\t */\n\tfunction filter(promises, predicate) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.filter(promises, predicate);\n\t\t});\n\t}\n\n\treturn when;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n"
        }
      ]
    }
  ]
}