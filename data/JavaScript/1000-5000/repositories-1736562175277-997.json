{
  "metadata": {
    "timestamp": 1736562175277,
    "page": 997,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjEwMDA=",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sanctuary-js/sanctuary",
      "stars": 3046,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".config",
          "type": "blob",
          "size": 0.1123046875,
          "content": "repo-owner = sanctuary-js\nrepo-name = sanctuary\ncontributing-file = .github/CONTRIBUTING.md\nmodule-type = commonjs\n"
        },
        {
          "name": ".eslintrc.json",
          "type": "blob",
          "size": 0.5302734375,
          "content": "{\n  \"root\": true,\n  \"extends\": [\"./node_modules/sanctuary-style/eslint.json\"],\n  \"overrides\": [\n    {\n      \"files\": [\"index.js\"],\n      \"globals\": {\"__doctest\": \"readonly\", \"define\": \"readonly\", \"module\": \"readonly\", \"process\": \"readonly\", \"require\": \"readonly\", \"self\": \"readonly\"},\n      \"rules\": {\n        \"max-len\": [\"error\", {\"code\": 79, \"ignoreUrls\": true, \"ignoreTemplateLiterals\": true, \"ignorePattern\": \"^ *//(# |  .* :: |[.] > |[.] // |[.] \\\\[.*\\\\]: |[.] .* Function x )\"}],\n        \"no-param-reassign\": [\"off\"]\n      }\n    }\n  ]\n}\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.025390625,
          "content": "/coverage/\n/node_modules/\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.09375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2020 Sanctuary\nCopyright (c) 2016 Plaid Technologies, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 98.388671875,
          "content": "# <span id=\"section:sanctuary\">❑ Sanctuary</span>\n\n[![npm](https://img.shields.io/npm/v/sanctuary.svg)](https://www.npmjs.com/package/sanctuary)\n[![CircleCI](https://img.shields.io/circleci/project/github/sanctuary-js/sanctuary/main.svg)](https://app.circleci.com/pipelines/github/sanctuary-js/sanctuary?branch=main)\n[![Gitter](https://img.shields.io/gitter/room/badges/shields.svg)](https://gitter.im/sanctuary-js/sanctuary)\n\nSanctuary is a JavaScript functional programming library inspired by\n[Haskell][] and [PureScript][]. It's stricter than [Ramda][], and\nprovides a similar suite of functions.\n\nSanctuary promotes programs composed of simple, pure functions. Such\nprograms are easier to comprehend, test, and maintain &ndash; they are\nalso a pleasure to write.\n\nSanctuary provides two data types, [Maybe][] and [Either][], both of\nwhich are compatible with [Fantasy Land][]. Thanks to these data types\neven Sanctuary functions that may fail, such as [`head`](#head), are\ncomposable.\n\nSanctuary makes it possible to write safe code without null checks.\nIn JavaScript it's trivial to introduce a possible run-time type error:\n\n    words[0].toUpperCase()\n\nIf `words` is `[]` we'll get a familiar error at run-time:\n\n    TypeError: Cannot read property 'toUpperCase' of undefined\n\nSanctuary gives us a fighting chance of avoiding such errors. We might\nwrite:\n\n    S.map (S.toUpper) (S.head (words))\n\nSanctuary is designed to work in Node.js and in ES5-compatible browsers.\n\n## <span id=\"section:folktale\">❑ Folktale</span>\n\n[Folktale][], like Sanctuary, is a standard library for functional\nprogramming in JavaScript. It is well designed and well documented.\nWhereas Sanctuary treats JavaScript as a member of the ML language\nfamily, Folktale embraces JavaScript's object-oriented programming\nmodel. Programming with Folktale resembles programming with Scala.\n\n## <span id=\"section:ramda\">❑ Ramda</span>\n\n[Ramda][] provides several functions that return problematic values\nsuch as `undefined`, `Infinity`, or `NaN` when applied to unsuitable\ninputs. These are known as [partial functions][]. Partial functions\nnecessitate the use of guards or null checks. In order to safely use\n`R.head`, for example, one must ensure that the array is non-empty:\n\n    if (R.isEmpty (xs)) {\n      // ...\n    } else {\n      return f (R.head (xs));\n    }\n\nUsing the Maybe type renders such guards (and null checks) unnecessary.\nChanging functions such as `R.head` to return Maybe values was proposed\nin [ramda/ramda#683][], but was considered too much of a stretch for\nJavaScript programmers. Sanctuary was released the following month,\nin January 2015, as a companion library to Ramda.\n\nIn addition to broadening in scope in the years since its release,\nSanctuary's philosophy has diverged from Ramda's in several respects.\n\n### <span id=\"section:totality\">❑ Totality</span>\n\nEvery Sanctuary function is defined for every value that is a member of\nthe function's input type. Such functions are known as [total functions][].\nRamda, on the other hand, contains a number of [partial functions][].\n\n### <span id=\"section:information-preservation\">❑ Information preservation</span>\n\nCertain Sanctuary functions preserve more information than their Ramda\ncounterparts. Examples:\n\n    |> R.tail ([])                      |> S.tail ([])\n    []                                  Nothing\n\n    |> R.tail (['foo'])                 |> S.tail (['foo'])\n    []                                  Just ([])\n\n    |> R.replace (/^x/) ('') ('abc')    |> S.stripPrefix ('x') ('abc')\n    'abc'                               Nothing\n\n    |> R.replace (/^x/) ('') ('xabc')   |> S.stripPrefix ('x') ('xabc')\n    'abc'                               Just ('abc')\n\n### <span id=\"section:invariants\">❑ Invariants</span>\n\nSanctuary performs rigorous [type checking][] of inputs and outputs, and\nthrows a descriptive error if a type error is encountered. This allows bugs\nto be caught and fixed early in the development cycle.\n\nRamda operates on the [garbage in, garbage out][GIGO] principle. Functions\nare documented to take arguments of particular types, but these invariants\nare not enforced. The problem with this approach in a language as\npermissive as JavaScript is that there's no guarantee that garbage input\nwill produce garbage output ([ramda/ramda#1413][]). Ramda performs ad hoc\ntype checking in some such cases ([ramda/ramda#1419][]).\n\nSanctuary can be configured to operate in garbage in, garbage out mode.\nRamda cannot be configured to enforce its invariants.\n\n### <span id=\"section:currying\">❑ Currying</span>\n\nSanctuary functions are curried. There is, for example, exactly one way to\napply `S.reduce` to `S.add`, `0`, and `xs`:\n\n  - `S.reduce (S.add) (0) (xs)`\n\nRamda functions are also curried, but in a complex manner. There are four\nways to apply `R.reduce` to `R.add`, `0`, and `xs`:\n\n  - `R.reduce (R.add) (0) (xs)`\n  - `R.reduce (R.add) (0, xs)`\n  - `R.reduce (R.add, 0) (xs)`\n  - `R.reduce (R.add, 0, xs)`\n\nRamda supports all these forms because curried functions enable partial\napplication, one of the library's tenets, but `f(x)(y)(z)` is considered\ntoo unfamiliar and too unattractive to appeal to JavaScript programmers.\n\nSanctuary's developers prefer a simple, unfamiliar construct to a complex,\nfamiliar one. Familiarity can be acquired; complexity is intrinsic.\n\nThe lack of breathing room in `f(x)(y)(z)` impairs readability. The simple\nsolution to this problem, proposed in [#438][], is to include a space when\napplying a function: `f (x) (y) (z)`.\n\nRamda also provides a special placeholder value, [`R.__`][], that removes\nthe restriction that a function must be applied to its arguments in order.\nThe following expressions are equivalent:\n\n  - `R.reduce (R.__, 0, xs) (R.add)`\n  - `R.reduce (R.add, R.__, xs) (0)`\n  - `R.reduce (R.__, 0) (R.add) (xs)`\n  - `R.reduce (R.__, 0) (R.add, xs)`\n  - `R.reduce (R.__, R.__, xs) (R.add) (0)`\n  - `R.reduce (R.__, R.__, xs) (R.add, 0)`\n\n### <span id=\"section:variadic-functions\">❑ Variadic functions</span>\n\nRamda provides several functions that take any number of arguments. These\nare known as [variadic functions][]. Additionally, Ramda provides several\nfunctions that take variadic functions as arguments. Although natural in\na dynamically typed language, variadic functions are at odds with the type\nnotation Ramda and Sanctuary both use, leading to some indecipherable type\nsignatures such as this one:\n\n    R.lift :: (*... -> *...) -> ([*]... -> [*])\n\nSanctuary has no variadic functions, nor any functions that take variadic\nfunctions as arguments. Sanctuary provides two \"lift\" functions, each with\na helpful type signature:\n\n    S.lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c\n    S.lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n\n### <span id=\"section:implicit-context\">❑ Implicit context</span>\n\nRamda provides [`R.bind`][] and [`R.invoker`][] for working with methods.\nAdditionally, many Ramda functions use `Function#call` or `Function#apply`\nto preserve context. Sanctuary makes no allowances for `this`.\n\n### <span id=\"section:transducers\">❑ Transducers</span>\n\nSeveral Ramda functions act as transducers. Sanctuary provides no support\nfor transducers.\n\n### <span id=\"section:modularity\">❑ Modularity</span>\n\nWhereas Ramda has no dependencies, Sanctuary has a modular design:\n[sanctuary-def][] provides type checking, [sanctuary-type-classes][]\nprovides Fantasy Land functions and type classes, [sanctuary-show][]\nprovides string representations, and algebraic data types are provided\nby [sanctuary-either][], [sanctuary-maybe][], and [sanctuary-pair][].\nNot only does this approach reduce the complexity of Sanctuary itself,\nbut it allows these components to be reused in other contexts.\n\n## <span id=\"section:types\">❑ Types</span>\n\nSanctuary uses Haskell-like type signatures to describe the types of\nvalues, including functions. `'foo'`, for example, is a member of `String`;\n`[1, 2, 3]` is a member of `Array Number`. The double colon (`::`) is used\nto mean \"is a member of\", so one could write:\n\n    'foo' :: String\n    [1, 2, 3] :: Array Number\n\nAn identifier may appear to the left of the double colon:\n\n    Math.PI :: Number\n\nThe arrow (`->`) is used to express a function's type:\n\n    Math.abs :: Number -> Number\n\nThat states that `Math.abs` is a unary function that takes an argument\nof type `Number` and returns a value of type `Number`.\n\nSome functions are parametrically polymorphic: their types are not fixed.\nType variables are used in the representations of such functions:\n\n    S.I :: a -> a\n\n`a` is a type variable. Type variables are not capitalized, so they\nare differentiable from type identifiers (which are always capitalized).\nBy convention type variables have single-character names. The signature\nabove states that `S.I` takes a value of any type and returns a value of\nthe same type. Some signatures feature multiple type variables:\n\n    S.K :: a -> b -> a\n\nIt must be possible to replace all occurrences of `a` with a concrete type.\nThe same applies for each other type variable. For the function above, the\ntypes with which `a` and `b` are replaced may be different, but needn't be.\n\nSince all Sanctuary functions are curried (they accept their arguments\none at a time), a binary function is represented as a unary function that\nreturns a unary function: `* -> * -> *`. This aligns neatly with Haskell,\nwhich uses curried functions exclusively. In JavaScript, though, we may\nwish to represent the types of functions with arities less than or greater\nthan one. The general form is `(<input-types>) -> <output-type>`, where\n`<input-types>` comprises zero or more comma–space (<code>, </code>)\n-separated type representations:\n\n  - `() -> String`\n  - `(a, b) -> a`\n  - `(a, b, c) -> d`\n\n`Number -> Number` can thus be seen as shorthand for `(Number) -> Number`.\n\nSanctuary embraces types. JavaScript doesn't support algebraic data types,\nbut these can be simulated by providing a group of data constructors that\nreturn values with the same set of methods. A value of the Either type, for\nexample, is created via the Left constructor or the Right constructor.\n\nIt's necessary to extend Haskell's notation to describe implicit arguments\nto the *methods* provided by Sanctuary's types. In `x.map(y)`, for example,\nthe `map` method takes an implicit argument `x` in addition to the explicit\nargument `y`. The type of the value upon which a method is invoked appears\nat the beginning of the signature, separated from the arguments and return\nvalue by a squiggly arrow (`~>`). The type of the `fantasy-land/map` method\nof the Maybe type is written `Maybe a ~> (a -> b) -> Maybe b`. One could\nread this as:\n\n_When the `fantasy-land/map` method is invoked on a value of type `Maybe a`\n(for any type `a`) with an argument of type `a -> b` (for any type `b`),\nit returns a value of type `Maybe b`._\n\nThe squiggly arrow is also used when representing non-function properties.\n`Maybe a ~> Boolean`, for example, represents a Boolean property of a value\nof type `Maybe a`.\n\nSanctuary supports type classes: constraints on type variables. Whereas\n`a -> a` implicitly supports every type, `Functor f => (a -> b) -> f a ->\nf b` requires that `f` be a type that satisfies the requirements of the\nFunctor type class. Type-class constraints appear at the beginning of a\ntype signature, separated from the rest of the signature by a fat arrow\n(`=>`).\n\n## <span id=\"section:type-checking\">❑ Type checking</span>\n\nSanctuary functions are defined via [sanctuary-def][] to provide run-time\ntype checking. This is tremendously useful during development: type errors\nare reported immediately, avoiding circuitous stack traces (at best) and\nsilent failures due to type coercion (at worst). For example:\n\n```javascript\nS.add (2) (true);\n// ! TypeError: Invalid value\n//\n//   add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n//                          ^^^^^^^^^^^^\n//                               1\n//\n//   1)  true :: Boolean\n//\n//   The value at position 1 is not a member of ‘FiniteNumber’.\n//\n//   See https://github.com/sanctuary-js/sanctuary-def/tree/v0.22.0#FiniteNumber for information about the FiniteNumber type.\n```\n\nCompare this to the behaviour of Ramda's unchecked equivalent:\n\n```javascript\nR.add (2) (true);\n// => 3\n```\n\nThere is a performance cost to run-time type checking. Type checking is\ndisabled by default if `process.env.NODE_ENV` is `'production'`. If this\nrule is unsuitable for a given program, one may use [`create`](#create)\nto create a Sanctuary module based on a different rule. For example:\n\n```javascript\nconst S = sanctuary.create ({\n  checkTypes: localStorage.getItem ('SANCTUARY_CHECK_TYPES') === 'true',\n  env: sanctuary.env,\n});\n```\n\nOccasionally one may wish to perform an operation that is not type safe,\nsuch as mapping over an object with heterogeneous values. This is possible\nvia selective use of [`unchecked`](#unchecked) functions.\n\n## <span id=\"section:installation\">❑ Installation</span>\n\n`npm install sanctuary` will install Sanctuary for use in Node.js.\n\nTo add Sanctuary to a website, add the following `<script>` element,\nreplacing `X.Y.Z` with a version number greater than or equal to `2.0.2`:\n\n```html\n<script src=\"https://cdn.jsdelivr.net/gh/sanctuary-js/sanctuary@X.Y.Z/dist/bundle.js\"></script>\n```\n\nOptionally, define aliases for various modules:\n\n```javascript\nconst S = window.sanctuary;\nconst $ = window.sanctuaryDef;\n// ...\n```\n\n## <span id=\"section:api\">❑ API</span>\n\n### <span id=\"section:configure\">❑ Configure</span>\n\n#### <a name=\"create\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L506\">`create :: { checkTypes :: Boolean, env :: Array Type } -⁠> Module`</a>\n\nTakes an options record and returns a Sanctuary module. `checkTypes`\nspecifies whether to enable type checking. The module's polymorphic\nfunctions (such as [`I`](#I)) require each value associated with a\ntype variable to be a member of at least one type in the environment.\n\nA well-typed application of a Sanctuary function will produce the same\nresult regardless of whether type checking is enabled. If type checking\nis enabled, a badly typed application will produce an exception with a\ndescriptive error message.\n\nThe following snippet demonstrates defining a custom type and using\n`create` to produce a Sanctuary module that is aware of that type:\n\n```javascript\nconst {create, env} = require ('sanctuary');\nconst $ = require ('sanctuary-def');\nconst type = require ('sanctuary-type-identifiers');\n\n//    Identity :: a -> Identity a\nconst Identity = x => {\n  const identity = Object.create (Identity$prototype);\n  identity.value = x;\n  return identity;\n};\n\n//    identityTypeIdent :: String\nconst identityTypeIdent = 'my-package/Identity@1';\n\nconst Identity$prototype = {\n  '@@type': identityTypeIdent,\n  '@@show': function() { return `Identity (${S.show (this.value)})`; },\n  'fantasy-land/map': function(f) { return Identity (f (this.value)); },\n};\n\n//    IdentityType :: Type -> Type\nconst IdentityType = $.UnaryType\n  ('Identity')\n  ('http://example.com/my-package#Identity')\n  ([])\n  (x => type (x) === identityTypeIdent)\n  (identity => [identity.value]);\n\nconst S = create ({\n  checkTypes: process.env.NODE_ENV !== 'production',\n  env: env.concat ([IdentityType ($.Unknown)]),\n});\n\nS.map (S.sub (1)) (Identity (43));\n// => Identity (42)\n```\n\nSee also [`env`](#env).\n\n#### <a name=\"env\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L582\">`env :: Array Type`</a>\n\nThe Sanctuary module's environment (`(S.create ({checkTypes, env})).env`\nis a reference to `env`). Useful in conjunction with [`create`](#create).\n\n```javascript\n> S.env\n[ $.AnyFunction,\n. $.Arguments,\n. $.Array ($.Unknown),\n. $.Array2 ($.Unknown) ($.Unknown),\n. $.Boolean,\n. $.Buffer,\n. $.Date,\n. $.Descending ($.Unknown),\n. $.Either ($.Unknown) ($.Unknown),\n. $.Error,\n. $.Fn ($.Unknown) ($.Unknown),\n. $.HtmlElement,\n. $.Identity ($.Unknown),\n. $.JsMap ($.Unknown) ($.Unknown),\n. $.JsSet ($.Unknown),\n. $.Maybe ($.Unknown),\n. $.Module,\n. $.Null,\n. $.Number,\n. $.Object,\n. $.Pair ($.Unknown) ($.Unknown),\n. $.RegExp,\n. $.StrMap ($.Unknown),\n. $.String,\n. $.Symbol,\n. $.Type,\n. $.TypeClass,\n. $.Undefined ]\n```\n\n#### <a name=\"unchecked\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L619\">`unchecked :: Module`</a>\n\nA complete Sanctuary module that performs no type checking. This is\nuseful as it permits operations that Sanctuary's type checking would\ndisallow, such as mapping over an object with heterogeneous values.\n\nSee also [`create`](#create).\n\n```javascript\n> S.unchecked.map (S.show) ({x: 'foo', y: true, z: 42})\n{x: '\"foo\"', y: 'true', z: '42'}\n```\n\nOpting out of type checking may cause type errors to go unnoticed.\n\n```javascript\n> S.unchecked.add (2) ('2')\n'22'\n```\n\n### <span id=\"section:classify\">❑ Classify</span>\n\n#### <a name=\"type\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L641\">`type :: Any -⁠> { namespace :: Maybe String, name :: String, version :: NonNegativeInteger }`</a>\n\nReturns the result of parsing the [type identifier][] of the given value.\n\n```javascript\n> S.type (S.Just (42))\n{namespace: Just ('sanctuary-maybe'), name: 'Maybe', version: 1}\n\n> S.type ([1, 2, 3])\n{namespace: Nothing, name: 'Array', version: 0}\n```\n\n#### <a name=\"is\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L666\">`is :: Type -⁠> Any -⁠> Boolean`</a>\n\nReturns `true` [iff][] the given value is a member of the specified type.\nSee [`$.test`][] for details.\n\n```javascript\n> S.is ($.Array ($.Integer)) ([1, 2, 3])\ntrue\n\n> S.is ($.Array ($.Integer)) ([1, 2, 3.14])\nfalse\n```\n\n### <span id=\"section:showable\">❑ Showable</span>\n\n#### <a name=\"show\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L681\">`show :: Any -⁠> String`</a>\n\nAlias of [`show`][].\n\n```javascript\n> S.show (-0)\n'-0'\n\n> S.show (['foo', 'bar', 'baz'])\n'[\"foo\", \"bar\", \"baz\"]'\n\n> S.show ({x: 1, y: 2, z: 3})\n'{\"x\": 1, \"y\": 2, \"z\": 3}'\n\n> S.show (S.Left (S.Right (S.Just (S.Nothing))))\n'Left (Right (Just (Nothing)))'\n```\n\n### <span id=\"section:fantasy-land\">❑ Fantasy Land</span>\n\nSanctuary is compatible with the [Fantasy Land][] specification.\n\n#### <a name=\"equals\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L708\">`equals :: Setoid a => a -⁠> a -⁠> Boolean`</a>\n\nCurried version of [`Z.equals`][] that requires two arguments of the\nsame type.\n\nTo compare values of different types first use [`create`](#create) to\ncreate a Sanctuary module with type checking disabled, then use that\nmodule's `equals` function.\n\n```javascript\n> S.equals (0) (-0)\ntrue\n\n> S.equals (NaN) (NaN)\ntrue\n\n> S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 3]))\ntrue\n\n> S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 4]))\nfalse\n```\n\n#### <a name=\"lt\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L741\">`lt :: Ord a => a -⁠> a -⁠> Boolean`</a>\n\nReturns `true` [iff][] the *second* argument is less than the first\naccording to [`Z.lt`][].\n\n```javascript\n> S.filter (S.lt (3)) ([1, 2, 3, 4, 5])\n[1, 2]\n```\n\n#### <a name=\"lte\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L761\">`lte :: Ord a => a -⁠> a -⁠> Boolean`</a>\n\nReturns `true` [iff][] the *second* argument is less than or equal to\nthe first according to [`Z.lte`][].\n\n```javascript\n> S.filter (S.lte (3)) ([1, 2, 3, 4, 5])\n[1, 2, 3]\n```\n\n#### <a name=\"gt\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L781\">`gt :: Ord a => a -⁠> a -⁠> Boolean`</a>\n\nReturns `true` [iff][] the *second* argument is greater than the first\naccording to [`Z.gt`][].\n\n```javascript\n> S.filter (S.gt (3)) ([1, 2, 3, 4, 5])\n[4, 5]\n```\n\n#### <a name=\"gte\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L801\">`gte :: Ord a => a -⁠> a -⁠> Boolean`</a>\n\nReturns `true` [iff][] the *second* argument is greater than or equal\nto the first according to [`Z.gte`][].\n\n```javascript\n> S.filter (S.gte (3)) ([1, 2, 3, 4, 5])\n[3, 4, 5]\n```\n\n#### <a name=\"min\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L821\">`min :: Ord a => a -⁠> a -⁠> a`</a>\n\nReturns the smaller of its two arguments (according to [`Z.lte`][]).\n\nSee also [`max`](#max).\n\n```javascript\n> S.min (10) (2)\n2\n\n> S.min (new Date ('1999-12-31')) (new Date ('2000-01-01'))\nnew Date ('1999-12-31')\n\n> S.min ('10') ('2')\n'10'\n```\n\n#### <a name=\"max\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L843\">`max :: Ord a => a -⁠> a -⁠> a`</a>\n\nReturns the larger of its two arguments (according to [`Z.lte`][]).\n\nSee also [`min`](#min).\n\n```javascript\n> S.max (10) (2)\n10\n\n> S.max (new Date ('1999-12-31')) (new Date ('2000-01-01'))\nnew Date ('2000-01-01')\n\n> S.max ('10') ('2')\n'2'\n```\n\n#### <a name=\"clamp\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L865\">`clamp :: Ord a => a -⁠> a -⁠> a -⁠> a`</a>\n\nTakes a lower bound, an upper bound, and a value of the same type.\nReturns the value if it is within the bounds; the nearer bound otherwise.\n\nSee also [`min`](#min) and [`max`](#max).\n\n```javascript\n> S.clamp (0) (100) (42)\n42\n\n> S.clamp (0) (100) (-1)\n0\n\n> S.clamp ('A') ('Z') ('~')\n'Z'\n```\n\n#### <a name=\"id\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L888\">`id :: Category c => TypeRep c -⁠> c`</a>\n\n[Type-safe][sanctuary-def] version of [`Z.id`][].\n\n```javascript\n> S.id (Function) (42)\n42\n```\n\n#### <a name=\"concat\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L902\">`concat :: Semigroup a => a -⁠> a -⁠> a`</a>\n\nCurried version of [`Z.concat`][].\n\n```javascript\n> S.concat ('abc') ('def')\n'abcdef'\n\n> S.concat ([1, 2, 3]) ([4, 5, 6])\n[1, 2, 3, 4, 5, 6]\n\n> S.concat ({x: 1, y: 2}) ({y: 3, z: 4})\n{x: 1, y: 3, z: 4}\n\n> S.concat (S.Just ([1, 2, 3])) (S.Just ([4, 5, 6]))\nJust ([1, 2, 3, 4, 5, 6])\n\n> S.concat (Sum (18)) (Sum (24))\nSum (42)\n```\n\n#### <a name=\"empty\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L928\">`empty :: Monoid a => TypeRep a -⁠> a`</a>\n\n[Type-safe][sanctuary-def] version of [`Z.empty`][].\n\n```javascript\n> S.empty (String)\n''\n\n> S.empty (Array)\n[]\n\n> S.empty (Object)\n{}\n\n> S.empty (Sum)\nSum (0)\n```\n\n#### <a name=\"invert\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L951\">`invert :: Group g => g -⁠> g`</a>\n\n[Type-safe][sanctuary-def] version of [`Z.invert`][].\n\n```javascript\n> S.invert (Sum (5))\nSum (-5)\n```\n\n#### <a name=\"filter\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L965\">`filter :: Filterable f => (a -⁠> Boolean) -⁠> f a -⁠> f a`</a>\n\nCurried version of [`Z.filter`][]. Discards every element that does not\nsatisfy the predicate.\n\nSee also [`reject`](#reject).\n\n```javascript\n> S.filter (S.odd) ([1, 2, 3])\n[1, 3]\n\n> S.filter (S.odd) ({x: 1, y: 2, z: 3})\n{x: 1, z: 3}\n\n> S.filter (S.odd) (S.Nothing)\nNothing\n\n> S.filter (S.odd) (S.Just (0))\nNothing\n\n> S.filter (S.odd) (S.Just (1))\nJust (1)\n```\n\n#### <a name=\"reject\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L999\">`reject :: Filterable f => (a -⁠> Boolean) -⁠> f a -⁠> f a`</a>\n\nCurried version of [`Z.reject`][]. Discards every element that satisfies\nthe predicate.\n\nSee also [`filter`](#filter).\n\n```javascript\n> S.reject (S.odd) ([1, 2, 3])\n[2]\n\n> S.reject (S.odd) ({x: 1, y: 2, z: 3})\n{y: 2}\n\n> S.reject (S.odd) (S.Nothing)\nNothing\n\n> S.reject (S.odd) (S.Just (0))\nJust (0)\n\n> S.reject (S.odd) (S.Just (1))\nNothing\n```\n\n#### <a name=\"map\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1033\">`map :: Functor f => (a -⁠> b) -⁠> f a -⁠> f b`</a>\n\nCurried version of [`Z.map`][].\n\n```javascript\n> S.map (Math.sqrt) ([1, 4, 9])\n[1, 2, 3]\n\n> S.map (Math.sqrt) ({x: 1, y: 4, z: 9})\n{x: 1, y: 2, z: 3}\n\n> S.map (Math.sqrt) (S.Just (9))\nJust (3)\n\n> S.map (Math.sqrt) (S.Right (9))\nRight (3)\n\n> S.map (Math.sqrt) (S.Pair (99980001) (99980001))\nPair (99980001) (9999)\n```\n\nReplacing `Functor f => f` with `Function x` produces the B combinator\nfrom combinatory logic (i.e. [`compose`](#compose)):\n\n    Functor f => (a -> b) -> f a -> f b\n    (a -> b) -> Function x a -> Function x b\n    (a -> c) -> Function x a -> Function x c\n    (b -> c) -> Function x b -> Function x c\n    (b -> c) -> Function a b -> Function a c\n    (b -> c) -> (a -> b) -> (a -> c)\n\n```javascript\n> S.map (Math.sqrt) (S.add (1)) (99)\n10\n```\n\n#### <a name=\"flip\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1079\">`flip :: Functor f => f (a -⁠> b) -⁠> a -⁠> f b`</a>\n\nCurried version of [`Z.flip`][]. Maps over the given functions, applying\neach to the given value.\n\nReplacing `Functor f => f` with `Function x` produces the C combinator\nfrom combinatory logic:\n\n    Functor f => f (a -> b) -> a -> f b\n    Function x (a -> b) -> a -> Function x b\n    Function x (a -> c) -> a -> Function x c\n    Function x (b -> c) -> b -> Function x c\n    Function a (b -> c) -> b -> Function a c\n    (a -> b -> c) -> b -> a -> c\n\n```javascript\n> S.flip (S.concat) ('!') ('foo')\n'foo!'\n\n> S.flip ([Math.floor, Math.ceil]) (1.5)\n[1, 2]\n\n> S.flip ({floor: Math.floor, ceil: Math.ceil}) (1.5)\n{floor: 1, ceil: 2}\n\n> S.flip (Cons (Math.floor) (Cons (Math.ceil) (Nil))) (1.5)\nCons (1) (Cons (2) (Nil))\n```\n\n#### <a name=\"bimap\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1118\">`bimap :: Bifunctor f => (a -⁠> b) -⁠> (c -⁠> d) -⁠> f a c -⁠> f b d`</a>\n\nCurried version of [`Z.bimap`][].\n\n```javascript\n> S.bimap (S.toUpper) (Math.sqrt) (S.Pair ('foo') (64))\nPair ('FOO') (8)\n\n> S.bimap (S.toUpper) (Math.sqrt) (S.Left ('foo'))\nLeft ('FOO')\n\n> S.bimap (S.toUpper) (Math.sqrt) (S.Right (64))\nRight (8)\n```\n\n#### <a name=\"mapLeft\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1138\">`mapLeft :: Bifunctor f => (a -⁠> b) -⁠> f a c -⁠> f b c`</a>\n\nCurried version of [`Z.mapLeft`][]. Maps the given function over the left\nside of a Bifunctor.\n\n```javascript\n> S.mapLeft (S.toUpper) (S.Pair ('foo') (64))\nPair ('FOO') (64)\n\n> S.mapLeft (S.toUpper) (S.Left ('foo'))\nLeft ('FOO')\n\n> S.mapLeft (S.toUpper) (S.Right (64))\nRight (64)\n```\n\n#### <a name=\"promap\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1159\">`promap :: Profunctor p => (a -⁠> b) -⁠> (c -⁠> d) -⁠> p b c -⁠> p a d`</a>\n\nCurried version of [`Z.promap`][].\n\n```javascript\n> S.promap (Math.abs) (S.add (1)) (Math.sqrt) (-100)\n11\n```\n\n#### <a name=\"alt\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1173\">`alt :: Alt f => f a -⁠> f a -⁠> f a`</a>\n\nCurried version of [`Z.alt`][] with arguments flipped to facilitate\npartial application.\n\n```javascript\n> S.alt (S.Just ('default')) (S.Nothing)\nJust ('default')\n\n> S.alt (S.Just ('default')) (S.Just ('hello'))\nJust ('hello')\n\n> S.alt (S.Right (0)) (S.Left ('X'))\nRight (0)\n\n> S.alt (S.Right (0)) (S.Right (1))\nRight (1)\n```\n\n#### <a name=\"zero\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1202\">`zero :: Plus f => TypeRep f -⁠> f a`</a>\n\n[Type-safe][sanctuary-def] version of [`Z.zero`][].\n\n```javascript\n> S.zero (Array)\n[]\n\n> S.zero (Object)\n{}\n\n> S.zero (S.Maybe)\nNothing\n```\n\n#### <a name=\"reduce\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1222\">`reduce :: Foldable f => (b -⁠> a -⁠> b) -⁠> b -⁠> f a -⁠> b`</a>\n\nTakes a curried binary function, an initial value, and a [Foldable][],\nand applies the function to the initial value and the Foldable's first\nvalue, then applies the function to the result of the previous\napplication and the Foldable's second value. Repeats this process\nuntil each of the Foldable's values has been used. Returns the initial\nvalue if the Foldable is empty; the result of the final application\notherwise.\n\nSee also [`reduce_`](#reduce_).\n\n```javascript\n> S.reduce (S.add) (0) ([1, 2, 3, 4, 5])\n15\n\n> S.reduce (xs => x => S.prepend (x) (xs)) ([]) ([1, 2, 3, 4, 5])\n[5, 4, 3, 2, 1]\n```\n\n#### <a name=\"reduce_\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1256\">`reduce_ :: Foldable f => (a -⁠> b -⁠> b) -⁠> b -⁠> f a -⁠> b`</a>\n\nVariant of [`reduce`](#reduce) that takes a reducing function with\narguments flipped.\n\n```javascript\n> S.reduce_ (S.append) ([]) (Cons (1) (Cons (2) (Cons (3) (Nil))))\n[1, 2, 3]\n\n> S.reduce_ (S.prepend) ([]) (Cons (1) (Cons (2) (Cons (3) (Nil))))\n[3, 2, 1]\n```\n\n#### <a name=\"traverse\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1274\">`traverse :: (Applicative f, Traversable t) => TypeRep f -⁠> (a -⁠> f b) -⁠> t a -⁠> f (t b)`</a>\n\nCurried version of [`Z.traverse`][].\n\n```javascript\n> S.traverse (Array) (S.words) (S.Just ('foo bar baz'))\n[Just ('foo'), Just ('bar'), Just ('baz')]\n\n> S.traverse (Array) (S.words) (S.Nothing)\n[Nothing]\n\n> S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C'])\nJust ([10, 11, 12])\n\n> S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C', 'X'])\nNothing\n\n> S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C'})\nJust ({a: 10, b: 11, c: 12})\n\n> S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C', x: 'X'})\nNothing\n```\n\n#### <a name=\"sequence\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1303\">`sequence :: (Applicative f, Traversable t) => TypeRep f -⁠> t (f a) -⁠> f (t a)`</a>\n\nCurried version of [`Z.sequence`][]. Inverts the given `t (f a)`\nto produce an `f (t a)`.\n\n```javascript\n> S.sequence (Array) (S.Just ([1, 2, 3]))\n[Just (1), Just (2), Just (3)]\n\n> S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Just (3)])\nJust ([1, 2, 3])\n\n> S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Nothing])\nNothing\n\n> S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Just (3)})\nJust ({a: 1, b: 2, c: 3})\n\n> S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Nothing})\nNothing\n```\n\n#### <a name=\"ap\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1330\">`ap :: Apply f => f (a -⁠> b) -⁠> f a -⁠> f b`</a>\n\nCurried version of [`Z.ap`][].\n\n```javascript\n> S.ap ([Math.sqrt, x => x * x]) ([1, 4, 9, 16, 25])\n[1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n\n> S.ap ({x: Math.sqrt, y: S.add (1), z: S.sub (1)}) ({w: 4, x: 4, y: 4})\n{x: 2, y: 5}\n\n> S.ap (S.Just (Math.sqrt)) (S.Just (64))\nJust (8)\n```\n\nReplacing `Apply f => f` with `Function x` produces the S combinator\nfrom combinatory logic:\n\n    Apply f => f (a -> b) -> f a -> f b\n    Function x (a -> b) -> Function x a -> Function x b\n    Function x (a -> c) -> Function x a -> Function x c\n    Function x (b -> c) -> Function x b -> Function x c\n    Function a (b -> c) -> Function a b -> Function a c\n    (a -> b -> c) -> (a -> b) -> (a -> c)\n\n```javascript\n> S.ap (s => n => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('Haskell')\n'Hask'\n```\n\n#### <a name=\"lift2\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1365\">`lift2 :: Apply f => (a -⁠> b -⁠> c) -⁠> f a -⁠> f b -⁠> f c`</a>\n\nPromotes a curried binary function to a function that operates on two\n[Apply][]s.\n\n```javascript\n> S.lift2 (S.add) (S.Just (2)) (S.Just (3))\nJust (5)\n\n> S.lift2 (S.add) (S.Just (2)) (S.Nothing)\nNothing\n\n> S.lift2 (S.and) (S.Just (true)) (S.Just (true))\nJust (true)\n\n> S.lift2 (S.and) (S.Just (true)) (S.Just (false))\nJust (false)\n```\n\n#### <a name=\"lift3\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1389\">`lift3 :: Apply f => (a -⁠> b -⁠> c -⁠> d) -⁠> f a -⁠> f b -⁠> f c -⁠> f d`</a>\n\nPromotes a curried ternary function to a function that operates on three\n[Apply][]s.\n\n```javascript\n> S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Just ([1, 2, 3]))\nJust (6)\n\n> S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Nothing)\nNothing\n```\n\n#### <a name=\"apFirst\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1407\">`apFirst :: Apply f => f a -⁠> f b -⁠> f a`</a>\n\nCurried version of [`Z.apFirst`][]. Combines two effectful actions,\nkeeping only the result of the first. Equivalent to Haskell's `(<*)`\nfunction.\n\nSee also [`apSecond`](#apSecond).\n\n```javascript\n> S.apFirst ([1, 2]) ([3, 4])\n[1, 1, 2, 2]\n\n> S.apFirst (S.Just (1)) (S.Just (2))\nJust (1)\n```\n\n#### <a name=\"apSecond\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1428\">`apSecond :: Apply f => f a -⁠> f b -⁠> f b`</a>\n\nCurried version of [`Z.apSecond`][]. Combines two effectful actions,\nkeeping only the result of the second. Equivalent to Haskell's `(*>)`\nfunction.\n\nSee also [`apFirst`](#apFirst).\n\n```javascript\n> S.apSecond ([1, 2]) ([3, 4])\n[3, 4, 3, 4]\n\n> S.apSecond (S.Just (1)) (S.Just (2))\nJust (2)\n```\n\n#### <a name=\"of\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1449\">`of :: Applicative f => TypeRep f -⁠> a -⁠> f a`</a>\n\nCurried version of [`Z.of`][].\n\n```javascript\n> S.of (Array) (42)\n[42]\n\n> S.of (Function) (42) (null)\n42\n\n> S.of (S.Maybe) (42)\nJust (42)\n\n> S.of (S.Either) (42)\nRight (42)\n```\n\n#### <a name=\"chain\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1477\">`chain :: Chain m => (a -⁠> m b) -⁠> m a -⁠> m b`</a>\n\nCurried version of [`Z.chain`][].\n\n```javascript\n> S.chain (x => [x, x]) ([1, 2, 3])\n[1, 1, 2, 2, 3, 3]\n\n> S.chain (n => s => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('slice')\n'sli'\n\n> S.chain (S.parseInt (10)) (S.Just ('123'))\nJust (123)\n\n> S.chain (S.parseInt (10)) (S.Just ('XXX'))\nNothing\n```\n\n#### <a name=\"join\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1500\">`join :: Chain m => m (m a) -⁠> m a`</a>\n\n[Type-safe][sanctuary-def] version of [`Z.join`][].\nRemoves one level of nesting from a nested monadic structure.\n\n```javascript\n> S.join ([[1], [2], [3]])\n[1, 2, 3]\n\n> S.join ([[[1, 2, 3]]])\n[[1, 2, 3]]\n\n> S.join (S.Just (S.Just (1)))\nJust (1)\n\n> S.join (S.Pair ('foo') (S.Pair ('bar') ('baz')))\nPair ('foobar') ('baz')\n```\n\nReplacing `Chain m => m` with `Function x` produces the W combinator\nfrom combinatory logic:\n\n    Chain m => m (m a) -> m a\n    Function x (Function x a) -> Function x a\n    (x -> x -> a) -> (x -> a)\n\n```javascript\n> S.join (S.concat) ('abc')\n'abcabc'\n```\n\n#### <a name=\"chainRec\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1536\">`chainRec :: ChainRec m => TypeRep m -⁠> (a -⁠> m (Either a b)) -⁠> a -⁠> m b`</a>\n\nPerforms a [`chain`](#chain)-like computation with constant stack usage.\nSimilar to [`Z.chainRec`][], but curried and more convenient due to the\nuse of the Either type to indicate completion (via a Right).\n\n```javascript\n> S.chainRec (Array)\n.            (s => s.length === 2 ? S.map (S.Right) ([s + '!', s + '?'])\n.                                 : S.map (S.Left) ([s + 'o', s + 'n']))\n.            ('')\n['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n```\n\n#### <a name=\"extend\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1565\">`extend :: Extend w => (w a -⁠> b) -⁠> w a -⁠> w b`</a>\n\nCurried version of [`Z.extend`][].\n\n```javascript\n> S.extend (S.joinWith ('')) (['x', 'y', 'z'])\n['xyz', 'yz', 'z']\n\n> S.extend (f => f ([3, 4])) (S.reverse) ([1, 2])\n[4, 3, 2, 1]\n```\n\n#### <a name=\"duplicate\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1582\">`duplicate :: Extend w => w a -⁠> w (w a)`</a>\n\n[Type-safe][sanctuary-def] version of [`Z.duplicate`][].\nAdds one level of nesting to a comonadic structure.\n\n```javascript\n> S.duplicate (S.Just (1))\nJust (Just (1))\n\n> S.duplicate ([1])\n[[1]]\n\n> S.duplicate ([1, 2, 3])\n[[1, 2, 3], [2, 3], [3]]\n\n> S.duplicate (S.reverse) ([1, 2]) ([3, 4])\n[4, 3, 2, 1]\n```\n\n#### <a name=\"extract\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1606\">`extract :: Comonad w => w a -⁠> a`</a>\n\n[Type-safe][sanctuary-def] version of [`Z.extract`][].\n\n```javascript\n> S.extract (S.Pair ('foo') ('bar'))\n'bar'\n```\n\n#### <a name=\"contramap\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1620\">`contramap :: Contravariant f => (b -⁠> a) -⁠> f a -⁠> f b`</a>\n\n[Type-safe][sanctuary-def] version of [`Z.contramap`][].\n\n```javascript\n> S.contramap (s => s.length) (Math.sqrt) ('Sanctuary')\n3\n```\n\n### <span id=\"section:combinator\">❑ Combinator</span>\n\n#### <a name=\"I\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1636\">`I :: a -⁠> a`</a>\n\nThe I combinator. Returns its argument. Equivalent to Haskell's `id`\nfunction.\n\n```javascript\n> S.I ('foo')\n'foo'\n```\n\n#### <a name=\"K\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1654\">`K :: a -⁠> b -⁠> a`</a>\n\nThe K combinator. Takes two values and returns the first. Equivalent to\nHaskell's `const` function.\n\n```javascript\n> S.K ('foo') ('bar')\n'foo'\n\n> S.map (S.K (42)) (S.range (0) (5))\n[42, 42, 42, 42, 42]\n```\n\n#### <a name=\"T\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1677\">`T :: a -⁠> (a -⁠> b) -⁠> b`</a>\n\nThe T ([thrush][]) combinator. Takes a value and a function, and returns\nthe result of applying the function to the value. Equivalent to Haskell's\n`(&)` function.\n\n```javascript\n> S.T (42) (S.add (1))\n43\n\n> S.map (S.T (100)) ([S.add (1), Math.sqrt])\n[101, 10]\n```\n\n### <span id=\"section:function\">❑ Function</span>\n\n#### <a name=\"curry2\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1703\">`curry2 :: ((a, b) -⁠> c) -⁠> a -⁠> b -⁠> c`</a>\n\nCurries the given binary function.\n\n```javascript\n> S.map (S.curry2 (Math.pow) (10)) ([1, 2, 3])\n[10, 100, 1000]\n```\n\n#### <a name=\"curry3\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1724\">`curry3 :: ((a, b, c) -⁠> d) -⁠> a -⁠> b -⁠> c -⁠> d`</a>\n\nCurries the given ternary function.\n\n```javascript\n> const replaceString = S.curry3 ((what, replacement, string) =>\n.   string.replace (what, replacement)\n. )\n\n> replaceString ('banana') ('orange') ('banana icecream')\n'orange icecream'\n```\n\n#### <a name=\"curry4\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1751\">`curry4 :: ((a, b, c, d) -⁠> e) -⁠> a -⁠> b -⁠> c -⁠> d -⁠> e`</a>\n\nCurries the given quaternary function.\n\n```javascript\n> const createRect = S.curry4 ((x, y, width, height) =>\n.   ({x, y, width, height})\n. )\n\n> createRect (0) (0) (10) (10)\n{x: 0, y: 0, width: 10, height: 10}\n```\n\n#### <a name=\"curry5\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1780\">`curry5 :: ((a, b, c, d, e) -⁠> f) -⁠> a -⁠> b -⁠> c -⁠> d -⁠> e -⁠> f`</a>\n\nCurries the given quinary function.\n\n```javascript\n> const toUrl = S.curry5 ((protocol, creds, hostname, port, pathname) =>\n.   protocol + '//' +\n.   S.maybe ('') (S.flip (S.concat) ('@')) (creds) +\n.   hostname +\n.   S.maybe ('') (S.concat (':')) (port) +\n.   pathname\n. )\n\n> toUrl ('https:') (S.Nothing) ('example.com') (S.Just ('443')) ('/foo/bar')\n'https://example.com:443/foo/bar'\n```\n\n### <span id=\"section:composition\">❑ Composition</span>\n\n#### <a name=\"compose\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1817\">`compose :: Semigroupoid s => s b c -⁠> s a b -⁠> s a c`</a>\n\nCurried version of [`Z.compose`][].\n\nWhen specialized to Function, `compose` composes two unary functions,\nfrom right to left (this is the B combinator from combinatory logic).\n\nThe generalized type signature indicates that `compose` is compatible\nwith any [Semigroupoid][].\n\nSee also [`pipe`](#pipe).\n\n```javascript\n> S.compose (Math.sqrt) (S.add (1)) (99)\n10\n```\n\n#### <a name=\"pipe\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1839\">`pipe :: Foldable f => f (Any -⁠> Any) -⁠> a -⁠> b`</a>\n\nTakes a sequence of functions assumed to be unary and a value of any\ntype, and returns the result of applying the sequence of transformations\nto the initial value.\n\nIn general terms, `pipe` performs left-to-right composition of a sequence\nof functions. `pipe ([f, g, h]) (x)` is equivalent to `h (g (f (x)))`.\n\n```javascript\n> S.pipe ([S.add (1), Math.sqrt, S.sub (1)]) (99)\n9\n```\n\n#### <a name=\"pipeK\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1863\">`pipeK :: (Foldable f, Chain m) => f (Any -⁠> m Any) -⁠> m a -⁠> m b`</a>\n\nTakes a sequence of functions assumed to be unary that return values\nwith a [Chain][], and a value of that Chain, and returns the result\nof applying the sequence of transformations to the initial value.\n\nIn general terms, `pipeK` performs left-to-right [Kleisli][] composition\nof an sequence of functions. `pipeK ([f, g, h]) (x)` is equivalent to\n`chain (h) (chain (g) (chain (f) (x)))`.\n\n```javascript\n> S.pipeK ([S.tail, S.tail, S.head]) (S.Just ([1, 2, 3, 4]))\nJust (3)\n```\n\n#### <a name=\"on\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1888\">`on :: (b -⁠> b -⁠> c) -⁠> (a -⁠> b) -⁠> a -⁠> a -⁠> c`</a>\n\nTakes a binary function `f`, a unary function `g`, and two\nvalues `x` and `y`. Returns `f (g (x)) (g (y))`.\n\nThis is the P combinator from combinatory logic.\n\n```javascript\n> S.on (S.concat) (S.reverse) ([1, 2, 3]) ([4, 5, 6])\n[3, 2, 1, 6, 5, 4]\n```\n\n### <span id=\"section:pair\">❑ Pair</span>\n\nPair is the canonical product type: a value of type `Pair a b` always\ncontains exactly two values: one of type `a`; one of type `b`.\n\nThe implementation is provided by [sanctuary-pair][].\n\n#### <a name=\"Pair\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1921\">`Pair :: a -⁠> b -⁠> Pair a b`</a>\n\nPair's sole data constructor. Additionally, it serves as the\nPair [type representative][].\n\n```javascript\n> S.Pair ('foo') (42)\nPair ('foo') (42)\n```\n\n#### <a name=\"pair\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1936\">`pair :: (a -⁠> b -⁠> c) -⁠> Pair a b -⁠> c`</a>\n\nCase analysis for the `Pair a b` type.\n\n```javascript\n> S.pair (S.concat) (S.Pair ('foo') ('bar'))\n'foobar'\n```\n\n#### <a name=\"fst\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1955\">`fst :: Pair a b -⁠> a`</a>\n\n`fst (Pair (x) (y))` is equivalent to `x`.\n\n```javascript\n> S.fst (S.Pair ('foo') (42))\n'foo'\n```\n\n#### <a name=\"snd\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1969\">`snd :: Pair a b -⁠> b`</a>\n\n`snd (Pair (x) (y))` is equivalent to `y`.\n\n```javascript\n> S.snd (S.Pair ('foo') (42))\n42\n```\n\n#### <a name=\"swap\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L1983\">`swap :: Pair a b -⁠> Pair b a`</a>\n\n`swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.\n\n```javascript\n> S.swap (S.Pair ('foo') (42))\nPair (42) ('foo')\n```\n\n### <span id=\"section:maybe\">❑ Maybe</span>\n\nThe Maybe type represents optional values: a value of type `Maybe a` is\neither Nothing (the empty value) or a Just whose value is of type `a`.\n\nThe implementation is provided by [sanctuary-maybe][].\n\n#### <a name=\"Maybe\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2004\">`Maybe :: TypeRep Maybe`</a>\n\nMaybe [type representative][].\n\n#### <a name=\"Nothing\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2008\">`Nothing :: Maybe a`</a>\n\nThe empty value of type `Maybe a`.\n\n```javascript\n> S.Nothing\nNothing\n```\n\n#### <a name=\"Just\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2017\">`Just :: a -⁠> Maybe a`</a>\n\nConstructs a value of type `Maybe a` from a value of type `a`.\n\n```javascript\n> S.Just (42)\nJust (42)\n```\n\n#### <a name=\"isNothing\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2031\">`isNothing :: Maybe a -⁠> Boolean`</a>\n\nReturns `true` if the given Maybe is Nothing; `false` if it is a Just.\n\n```javascript\n> S.isNothing (S.Nothing)\ntrue\n\n> S.isNothing (S.Just (42))\nfalse\n```\n\n#### <a name=\"isJust\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2051\">`isJust :: Maybe a -⁠> Boolean`</a>\n\nReturns `true` if the given Maybe is a Just; `false` if it is Nothing.\n\n```javascript\n> S.isJust (S.Just (42))\ntrue\n\n> S.isJust (S.Nothing)\nfalse\n```\n\n#### <a name=\"maybe\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2071\">`maybe :: b -⁠> (a -⁠> b) -⁠> Maybe a -⁠> b`</a>\n\nTakes a value of any type, a function, and a Maybe. If the Maybe is\na Just, the return value is the result of applying the function to\nthe Just's value. Otherwise, the first argument is returned.\n\nSee also [`maybe_`](#maybe_) and [`fromMaybe`](#fromMaybe).\n\n```javascript\n> S.maybe (0) (S.prop ('length')) (S.Just ('refuge'))\n6\n\n> S.maybe (0) (S.prop ('length')) (S.Nothing)\n0\n```\n\n#### <a name=\"maybe_\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2099\">`maybe_ :: (() -⁠> b) -⁠> (a -⁠> b) -⁠> Maybe a -⁠> b`</a>\n\nVariant of [`maybe`](#maybe) that takes a thunk so the default value\nis only computed if required.\n\n```javascript\n> function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }\n\n> S.maybe_ (() => fib (30)) (Math.sqrt) (S.Just (1000000))\n1000\n\n> S.maybe_ (() => fib (30)) (Math.sqrt) (S.Nothing)\n832040\n```\n\n#### <a name=\"fromMaybe\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2126\">`fromMaybe :: a -⁠> Maybe a -⁠> a`</a>\n\nTakes a default value and a Maybe, and returns the Maybe's value\nif the Maybe is a Just; the default value otherwise.\n\nSee also [`maybe`](#maybe), [`fromMaybe_`](#fromMaybe_), and\n[`maybeToNullable`](#maybeToNullable).\n\n```javascript\n> S.fromMaybe (0) (S.Just (42))\n42\n\n> S.fromMaybe (0) (S.Nothing)\n0\n```\n\n#### <a name=\"fromMaybe_\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2147\">`fromMaybe_ :: (() -⁠> a) -⁠> Maybe a -⁠> a`</a>\n\nVariant of [`fromMaybe`](#fromMaybe) that takes a thunk so the default\nvalue is only computed if required.\n\n```javascript\n> function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }\n\n> S.fromMaybe_ (() => fib (30)) (S.Just (1000000))\n1000000\n\n> S.fromMaybe_ (() => fib (30)) (S.Nothing)\n832040\n```\n\n#### <a name=\"justs\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2167\">`justs :: (Filterable f, Functor f) => f (Maybe a) -⁠> f a`</a>\n\nDiscards each element that is Nothing, and unwraps each element that is\na Just. Related to Haskell's `catMaybes` function.\n\nSee also [`lefts`](#lefts) and [`rights`](#rights).\n\n```javascript\n> S.justs ([S.Just ('foo'), S.Nothing, S.Just ('baz')])\n['foo', 'baz']\n```\n\n#### <a name=\"mapMaybe\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2187\">`mapMaybe :: (Filterable f, Functor f) => (a -⁠> Maybe b) -⁠> f a -⁠> f b`</a>\n\nTakes a function and a structure, applies the function to each element\nof the structure, and returns the \"successful\" results. If the result of\napplying the function to an element is Nothing, the result is discarded;\nif the result is a Just, the Just's value is included.\n\n```javascript\n> S.mapMaybe (S.head) ([[], [1, 2, 3], [], [4, 5, 6], []])\n[1, 4]\n\n> S.mapMaybe (S.head) ({x: [1, 2, 3], y: [], z: [4, 5, 6]})\n{x: 1, z: 4}\n```\n\n#### <a name=\"maybeToNullable\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2207\">`maybeToNullable :: Maybe a -⁠> Nullable a`</a>\n\nReturns the given Maybe's value if the Maybe is a Just; `null` otherwise.\n[Nullable][] is defined in [sanctuary-def][].\n\nSee also [`fromMaybe`](#fromMaybe).\n\n```javascript\n> S.maybeToNullable (S.Just (42))\n42\n\n> S.maybeToNullable (S.Nothing)\nnull\n```\n\n#### <a name=\"maybeToEither\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2230\">`maybeToEither :: a -⁠> Maybe b -⁠> Either a b`</a>\n\nConverts a Maybe to an Either. Nothing becomes a Left (containing the\nfirst argument); a Just becomes a Right.\n\nSee also [`eitherToMaybe`](#eitherToMaybe).\n\n```javascript\n> S.maybeToEither ('Expecting an integer') (S.parseInt (10) ('xyz'))\nLeft ('Expecting an integer')\n\n> S.maybeToEither ('Expecting an integer') (S.parseInt (10) ('42'))\nRight (42)\n```\n\n### <span id=\"section:either\">❑ Either</span>\n\nThe Either type represents values with two possibilities: a value of type\n`Either a b` is either a Left whose value is of type `a` or a Right whose\nvalue is of type `b`.\n\nThe implementation is provided by [sanctuary-either][].\n\n#### <a name=\"Either\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2261\">`Either :: TypeRep Either`</a>\n\nEither [type representative][].\n\n#### <a name=\"Left\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2265\">`Left :: a -⁠> Either a b`</a>\n\nConstructs a value of type `Either a b` from a value of type `a`.\n\n```javascript\n> S.Left ('Cannot divide by zero')\nLeft ('Cannot divide by zero')\n```\n\n#### <a name=\"Right\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2279\">`Right :: b -⁠> Either a b`</a>\n\nConstructs a value of type `Either a b` from a value of type `b`.\n\n```javascript\n> S.Right (42)\nRight (42)\n```\n\n#### <a name=\"isLeft\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2293\">`isLeft :: Either a b -⁠> Boolean`</a>\n\nReturns `true` if the given Either is a Left; `false` if it is a Right.\n\n```javascript\n> S.isLeft (S.Left ('Cannot divide by zero'))\ntrue\n\n> S.isLeft (S.Right (42))\nfalse\n```\n\n#### <a name=\"isRight\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2313\">`isRight :: Either a b -⁠> Boolean`</a>\n\nReturns `true` if the given Either is a Right; `false` if it is a Left.\n\n```javascript\n> S.isRight (S.Right (42))\ntrue\n\n> S.isRight (S.Left ('Cannot divide by zero'))\nfalse\n```\n\n#### <a name=\"either\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2333\">`either :: (a -⁠> c) -⁠> (b -⁠> c) -⁠> Either a b -⁠> c`</a>\n\nTakes two functions and an Either, and returns the result of\napplying the first function to the Left's value, if the Either\nis a Left, or the result of applying the second function to the\nRight's value, if the Either is a Right.\n\nSee also [`fromLeft`](#fromLeft) and [`fromRight`](#fromRight).\n\n```javascript\n> S.either (S.toUpper) (S.show) (S.Left ('Cannot divide by zero'))\n'CANNOT DIVIDE BY ZERO'\n\n> S.either (S.toUpper) (S.show) (S.Right (42))\n'42'\n```\n\n#### <a name=\"fromLeft\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2362\">`fromLeft :: a -⁠> Either a b -⁠> a`</a>\n\nTakes a default value and an Either, and returns the Left value\nif the Either is a Left; the default value otherwise.\n\nSee also [`either`](#either) and [`fromRight`](#fromRight).\n\n```javascript\n> S.fromLeft ('abc') (S.Left ('xyz'))\n'xyz'\n\n> S.fromLeft ('abc') (S.Right (123))\n'abc'\n```\n\n#### <a name=\"fromRight\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2385\">`fromRight :: b -⁠> Either a b -⁠> b`</a>\n\nTakes a default value and an Either, and returns the Right value\nif the Either is a Right; the default value otherwise.\n\nSee also [`either`](#either) and [`fromLeft`](#fromLeft).\n\n```javascript\n> S.fromRight (123) (S.Right (789))\n789\n\n> S.fromRight (123) (S.Left ('abc'))\n123\n```\n\n#### <a name=\"fromEither\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2408\">`fromEither :: b -⁠> Either a b -⁠> b`</a>\n\nTakes a default value and an Either, and returns the Right value\nif the Either is a Right; the default value otherwise.\n\nThe behaviour of `fromEither` is likely to change in a future release.\nPlease use [`fromRight`](#fromRight) instead.\n\n```javascript\n> S.fromEither (0) (S.Right (42))\n42\n\n> S.fromEither (0) (S.Left (42))\n0\n```\n\n#### <a name=\"lefts\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2432\">`lefts :: (Filterable f, Functor f) => f (Either a b) -⁠> f a`</a>\n\nDiscards each element that is a Right, and unwraps each element that is\na Left.\n\nSee also [`rights`](#rights).\n\n```javascript\n> S.lefts ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])\n['foo', 'bar']\n```\n\n#### <a name=\"rights\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2449\">`rights :: (Filterable f, Functor f) => f (Either a b) -⁠> f b`</a>\n\nDiscards each element that is a Left, and unwraps each element that is\na Right.\n\nSee also [`lefts`](#lefts).\n\n```javascript\n> S.rights ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])\n[20, 10]\n```\n\n#### <a name=\"tagBy\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2466\">`tagBy :: (a -⁠> Boolean) -⁠> a -⁠> Either a a`</a>\n\nTakes a predicate and a value, and returns a Right of the value if it\nsatisfies the predicate; a Left of the value otherwise.\n\n```javascript\n> S.tagBy (S.odd) (0)\nLeft (0)\n\n> S.tagBy (S.odd) (1)\nRight (1)\n```\n\n#### <a name=\"encase\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2487\">`encase :: Throwing e a b -⁠> a -⁠> Either e b`</a>\n\nTakes a function that may throw and returns a pure function.\n\n```javascript\n> S.encase (JSON.parse) ('[\"foo\",\"bar\",\"baz\"]')\nRight (['foo', 'bar', 'baz'])\n\n> S.encase (JSON.parse) ('[')\nLeft (new SyntaxError ('Unexpected end of JSON input'))\n```\n\n#### <a name=\"eitherToMaybe\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2513\">`eitherToMaybe :: Either a b -⁠> Maybe b`</a>\n\nConverts an Either to a Maybe. A Left becomes Nothing; a Right becomes\na Just.\n\nSee also [`maybeToEither`](#maybeToEither).\n\n```javascript\n> S.eitherToMaybe (S.Left ('Cannot divide by zero'))\nNothing\n\n> S.eitherToMaybe (S.Right (42))\nJust (42)\n```\n\n### <span id=\"section:logic\">❑ Logic</span>\n\n#### <a name=\"and\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2538\">`and :: Boolean -⁠> Boolean -⁠> Boolean`</a>\n\nBoolean \"and\".\n\n```javascript\n> S.and (false) (false)\nfalse\n\n> S.and (false) (true)\nfalse\n\n> S.and (true) (false)\nfalse\n\n> S.and (true) (true)\ntrue\n```\n\n#### <a name=\"or\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2566\">`or :: Boolean -⁠> Boolean -⁠> Boolean`</a>\n\nBoolean \"or\".\n\n```javascript\n> S.or (false) (false)\nfalse\n\n> S.or (false) (true)\ntrue\n\n> S.or (true) (false)\ntrue\n\n> S.or (true) (true)\ntrue\n```\n\n#### <a name=\"not\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2594\">`not :: Boolean -⁠> Boolean`</a>\n\nBoolean \"not\".\n\nSee also [`complement`](#complement).\n\n```javascript\n> S.not (false)\ntrue\n\n> S.not (true)\nfalse\n```\n\n#### <a name=\"complement\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2616\">`complement :: (a -⁠> Boolean) -⁠> a -⁠> Boolean`</a>\n\nTakes a unary predicate and a value of any type, and returns the logical\nnegation of applying the predicate to the value.\n\nSee also [`not`](#not).\n\n```javascript\n> Number.isInteger (42)\ntrue\n\n> S.complement (Number.isInteger) (42)\nfalse\n```\n\n#### <a name=\"boolean\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2636\">`boolean :: a -⁠> a -⁠> Boolean -⁠> a`</a>\n\nCase analysis for the `Boolean` type. `boolean (x) (y) (b)` evaluates\nto `x` if `b` is `false`; to `y` if `b` is `true`.\n\n```javascript\n> S.boolean ('no') ('yes') (false)\n'no'\n\n> S.boolean ('no') ('yes') (true)\n'yes'\n```\n\n#### <a name=\"ifElse\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2661\">`ifElse :: (a -⁠> Boolean) -⁠> (a -⁠> b) -⁠> (a -⁠> b) -⁠> a -⁠> b`</a>\n\nTakes a unary predicate, a unary \"if\" function, a unary \"else\"\nfunction, and a value of any type, and returns the result of\napplying the \"if\" function to the value if the value satisfies\nthe predicate; the result of applying the \"else\" function to the\nvalue otherwise.\n\nSee also [`when`](#when) and [`unless`](#unless).\n\n```javascript\n> S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (-1)\n1\n\n> S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (16)\n4\n```\n\n#### <a name=\"when\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2693\">`when :: (a -⁠> Boolean) -⁠> (a -⁠> a) -⁠> a -⁠> a`</a>\n\nTakes a unary predicate, a unary function, and a value of any type, and\nreturns the result of applying the function to the value if the value\nsatisfies the predicate; the value otherwise.\n\nSee also [`unless`](#unless) and [`ifElse`](#ifElse).\n\n```javascript\n> S.when (x => x >= 0) (Math.sqrt) (16)\n4\n\n> S.when (x => x >= 0) (Math.sqrt) (-1)\n-1\n```\n\n#### <a name=\"unless\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2717\">`unless :: (a -⁠> Boolean) -⁠> (a -⁠> a) -⁠> a -⁠> a`</a>\n\nTakes a unary predicate, a unary function, and a value of any type, and\nreturns the result of applying the function to the value if the value\ndoes not satisfy the predicate; the value otherwise.\n\nSee also [`when`](#when) and [`ifElse`](#ifElse).\n\n```javascript\n> S.unless (x => x < 0) (Math.sqrt) (16)\n4\n\n> S.unless (x => x < 0) (Math.sqrt) (-1)\n-1\n```\n\n### <span id=\"section:array\">❑ Array</span>\n\n#### <a name=\"array\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2743\">`array :: b -⁠> (a -⁠> Array a -⁠> b) -⁠> Array a -⁠> b`</a>\n\nCase analysis for the `Array a` type.\n\n```javascript\n> S.array (S.Nothing) (head => tail => S.Just (head)) ([])\nNothing\n\n> S.array (S.Nothing) (head => tail => S.Just (head)) ([1, 2, 3])\nJust (1)\n\n> S.array (S.Nothing) (head => tail => S.Just (tail)) ([])\nNothing\n\n> S.array (S.Nothing) (head => tail => S.Just (tail)) ([1, 2, 3])\nJust ([2, 3])\n```\n\n#### <a name=\"head\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2773\">`head :: Foldable f => f a -⁠> Maybe a`</a>\n\nReturns Just the first element of the given structure if the structure\ncontains at least one element; Nothing otherwise.\n\n```javascript\n> S.head ([1, 2, 3])\nJust (1)\n\n> S.head ([])\nNothing\n\n> S.head (Cons (1) (Cons (2) (Cons (3) (Nil))))\nJust (1)\n\n> S.head (Nil)\nNothing\n```\n\n#### <a name=\"last\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2806\">`last :: Foldable f => f a -⁠> Maybe a`</a>\n\nReturns Just the last element of the given structure if the structure\ncontains at least one element; Nothing otherwise.\n\n```javascript\n> S.last ([1, 2, 3])\nJust (3)\n\n> S.last ([])\nNothing\n\n> S.last (Cons (1) (Cons (2) (Cons (3) (Nil))))\nJust (3)\n\n> S.last (Nil)\nNothing\n```\n\n#### <a name=\"tail\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2838\">`tail :: (Applicative f, Foldable f, Monoid (f a)) => f a -⁠> Maybe (f a)`</a>\n\nReturns Just all but the first of the given structure's elements if the\nstructure contains at least one element; Nothing otherwise.\n\n```javascript\n> S.tail ([1, 2, 3])\nJust ([2, 3])\n\n> S.tail ([])\nNothing\n\n> S.tail (Cons (1) (Cons (2) (Cons (3) (Nil))))\nJust (Cons (2) (Cons (3) (Nil)))\n\n> S.tail (Nil)\nNothing\n```\n\n#### <a name=\"init\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2872\">`init :: (Applicative f, Foldable f, Monoid (f a)) => f a -⁠> Maybe (f a)`</a>\n\nReturns Just all but the last of the given structure's elements if the\nstructure contains at least one element; Nothing otherwise.\n\n```javascript\n> S.init ([1, 2, 3])\nJust ([1, 2])\n\n> S.init ([])\nNothing\n\n> S.init (Cons (1) (Cons (2) (Cons (3) (Nil))))\nJust (Cons (1) (Cons (2) (Nil)))\n\n> S.init (Nil)\nNothing\n```\n\n#### <a name=\"take\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2906\">`take :: (Applicative f, Foldable f, Monoid (f a)) => Integer -⁠> f a -⁠> Maybe (f a)`</a>\n\nReturns Just the first N elements of the given structure if N is\nnon-negative and less than or equal to the size of the structure;\nNothing otherwise.\n\n```javascript\n> S.take (0) (['foo', 'bar'])\nJust ([])\n\n> S.take (1) (['foo', 'bar'])\nJust (['foo'])\n\n> S.take (2) (['foo', 'bar'])\nJust (['foo', 'bar'])\n\n> S.take (3) (['foo', 'bar'])\nNothing\n\n> S.take (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Cons (5) (Nil))))))\nJust (Cons (1) (Cons (2) (Cons (3) (Nil))))\n```\n\n#### <a name=\"drop\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2961\">`drop :: (Applicative f, Foldable f, Monoid (f a)) => Integer -⁠> f a -⁠> Maybe (f a)`</a>\n\nReturns Just all but the first N elements of the given structure if\nN is non-negative and less than or equal to the size of the structure;\nNothing otherwise.\n\n```javascript\n> S.drop (0) (['foo', 'bar'])\nJust (['foo', 'bar'])\n\n> S.drop (1) (['foo', 'bar'])\nJust (['bar'])\n\n> S.drop (2) (['foo', 'bar'])\nJust ([])\n\n> S.drop (3) (['foo', 'bar'])\nNothing\n\n> S.drop (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Cons (5) (Nil))))))\nJust (Cons (4) (Cons (5) (Nil)))\n```\n\n#### <a name=\"takeLast\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L2993\">`takeLast :: (Applicative f, Foldable f, Monoid (f a)) => Integer -⁠> f a -⁠> Maybe (f a)`</a>\n\nReturns Just the last N elements of the given structure if N is\nnon-negative and less than or equal to the size of the structure;\nNothing otherwise.\n\n```javascript\n> S.takeLast (0) (['foo', 'bar'])\nJust ([])\n\n> S.takeLast (1) (['foo', 'bar'])\nJust (['bar'])\n\n> S.takeLast (2) (['foo', 'bar'])\nJust (['foo', 'bar'])\n\n> S.takeLast (3) (['foo', 'bar'])\nNothing\n\n> S.takeLast (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Nil)))))\nJust (Cons (2) (Cons (3) (Cons (4) (Nil))))\n```\n\n#### <a name=\"dropLast\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3026\">`dropLast :: (Applicative f, Foldable f, Monoid (f a)) => Integer -⁠> f a -⁠> Maybe (f a)`</a>\n\nReturns Just all but the last N elements of the given structure if\nN is non-negative and less than or equal to the size of the structure;\nNothing otherwise.\n\n```javascript\n> S.dropLast (0) (['foo', 'bar'])\nJust (['foo', 'bar'])\n\n> S.dropLast (1) (['foo', 'bar'])\nJust (['foo'])\n\n> S.dropLast (2) (['foo', 'bar'])\nJust ([])\n\n> S.dropLast (3) (['foo', 'bar'])\nNothing\n\n> S.dropLast (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Nil)))))\nJust (Cons (1) (Nil))\n```\n\n#### <a name=\"takeWhile\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3059\">`takeWhile :: (a -⁠> Boolean) -⁠> Array a -⁠> Array a`</a>\n\nDiscards the first element that does not satisfy the predicate,\nand all subsequent elements.\n\nSee also [`dropWhile`](#dropWhile).\n\n```javascript\n> S.takeWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])\n[3, 3, 3, 7]\n\n> S.takeWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])\n[]\n```\n\n#### <a name=\"dropWhile\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3086\">`dropWhile :: (a -⁠> Boolean) -⁠> Array a -⁠> Array a`</a>\n\nRetains the first element that does not satisfy the predicate,\nand all subsequent elements.\n\nSee also [`takeWhile`](#takeWhile).\n\n```javascript\n> S.dropWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])\n[6, 3, 5, 4]\n\n> S.dropWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])\n[3, 3, 3, 7, 6, 3, 5, 4]\n```\n\n#### <a name=\"size\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3113\">`size :: Foldable f => f a -⁠> NonNegativeInteger`</a>\n\nReturns the number of elements of the given structure.\n\n```javascript\n> S.size ([])\n0\n\n> S.size (['foo', 'bar', 'baz'])\n3\n\n> S.size (Nil)\n0\n\n> S.size (Cons ('foo') (Cons ('bar') (Cons ('baz') (Nil))))\n3\n\n> S.size (S.Nothing)\n0\n\n> S.size (S.Just ('quux'))\n1\n\n> S.size (S.Pair ('ignored!') ('counted!'))\n1\n```\n\n#### <a name=\"all\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3145\">`all :: Foldable f => (a -⁠> Boolean) -⁠> f a -⁠> Boolean`</a>\n\nReturns `true` [iff][] all the elements of the structure satisfy the\npredicate.\n\nSee also [`any`](#any) and [`none`](#none).\n\n```javascript\n> S.all (S.odd) ([])\ntrue\n\n> S.all (S.odd) ([1, 3, 5])\ntrue\n\n> S.all (S.odd) ([1, 2, 3])\nfalse\n```\n\n#### <a name=\"any\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3168\">`any :: Foldable f => (a -⁠> Boolean) -⁠> f a -⁠> Boolean`</a>\n\nReturns `true` [iff][] any element of the structure satisfies the\npredicate.\n\nSee also [`all`](#all) and [`none`](#none).\n\n```javascript\n> S.any (S.odd) ([])\nfalse\n\n> S.any (S.odd) ([2, 4, 6])\nfalse\n\n> S.any (S.odd) ([1, 2, 3])\ntrue\n```\n\n#### <a name=\"none\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3191\">`none :: Foldable f => (a -⁠> Boolean) -⁠> f a -⁠> Boolean`</a>\n\nReturns `true` [iff][] none of the elements of the structure satisfies\nthe predicate.\n\nProperties:\n\n  - `forall p :: a -> Boolean, xs :: Foldable f => f a.\n     S.none (p) (xs) = S.not (S.any (p) (xs))`\n\n  - `forall p :: a -> Boolean, xs :: Foldable f => f a.\n     S.none (p) (xs) = S.all (S.complement (p)) (xs)`\n\nSee also [`all`](#all) and [`any`](#any).\n\n```javascript\n> S.none (S.odd) ([])\ntrue\n\n> S.none (S.odd) ([2, 4, 6])\ntrue\n\n> S.none (S.odd) ([1, 2, 3])\nfalse\n```\n\n#### <a name=\"append\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3222\">`append :: (Applicative f, Semigroup (f a)) => a -⁠> f a -⁠> f a`</a>\n\nReturns the result of appending the first argument to the second.\n\nSee also [`prepend`](#prepend).\n\n```javascript\n> S.append (3) ([1, 2])\n[1, 2, 3]\n\n> S.append (3) (Cons (1) (Cons (2) (Nil)))\nCons (1) (Cons (2) (Cons (3) (Nil)))\n\n> S.append ([1]) (S.Nothing)\nJust ([1])\n\n> S.append ([3]) (S.Just ([1, 2]))\nJust ([1, 2, 3])\n```\n\n#### <a name=\"prepend\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3252\">`prepend :: (Applicative f, Semigroup (f a)) => a -⁠> f a -⁠> f a`</a>\n\nReturns the result of prepending the first argument to the second.\n\nSee also [`append`](#append).\n\n```javascript\n> S.prepend (1) ([2, 3])\n[1, 2, 3]\n\n> S.prepend (1) (Cons (2) (Cons (3) (Nil)))\nCons (1) (Cons (2) (Cons (3) (Nil)))\n\n> S.prepend ([1]) (S.Nothing)\nJust ([1])\n\n> S.prepend ([1]) (S.Just ([2, 3]))\nJust ([1, 2, 3])\n```\n\n#### <a name=\"joinWith\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3277\">`joinWith :: String -⁠> Array String -⁠> String`</a>\n\nJoins the strings of the second argument separated by the first argument.\n\nProperties:\n\n  - `forall s :: String, t :: String.\n     S.joinWith (s) (S.splitOn (s) (t)) = t`\n\nSee also [`splitOn`](#splitOn) and [`intercalate`](#intercalate).\n\n```javascript\n> S.joinWith (':') (['foo', 'bar', 'baz'])\n'foo:bar:baz'\n```\n\n#### <a name=\"elem\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3298\">`elem :: (Setoid a, Foldable f) => a -⁠> f a -⁠> Boolean`</a>\n\nTakes a value and a structure and returns `true` [iff][] the value is an\nelement of the structure.\n\nSee also [`find`](#find).\n\n```javascript\n> S.elem ('c') (['a', 'b', 'c'])\ntrue\n\n> S.elem ('x') (['a', 'b', 'c'])\nfalse\n\n> S.elem (3) ({x: 1, y: 2, z: 3})\ntrue\n\n> S.elem (8) ({x: 1, y: 2, z: 3})\nfalse\n\n> S.elem (0) (S.Just (0))\ntrue\n\n> S.elem (0) (S.Just (1))\nfalse\n\n> S.elem (0) (S.Nothing)\nfalse\n```\n\n#### <a name=\"find\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3333\">`find :: Foldable f => (a -⁠> Boolean) -⁠> f a -⁠> Maybe a`</a>\n\nTakes a predicate and a structure and returns Just the leftmost element\nof the structure that satisfies the predicate; Nothing if there is no\nsuch element.\n\nSee also [`elem`](#elem).\n\n```javascript\n> S.find (S.lt (0)) ([1, -2, 3, -4, 5])\nJust (-2)\n\n> S.find (S.lt (0)) ([1, 2, 3, 4, 5])\nNothing\n```\n\n#### <a name=\"intercalate\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3365\">`intercalate :: (Monoid m, Foldable f) => m -⁠> f m -⁠> m`</a>\n\nCurried version of [`Z.intercalate`][]. Concatenates the elements of\nthe given structure, separating each pair of adjacent elements with\nthe given separator.\n\nSee also [`joinWith`](#joinWith).\n\n```javascript\n> S.intercalate (', ') ([])\n''\n\n> S.intercalate (', ') (['foo', 'bar', 'baz'])\n'foo, bar, baz'\n\n> S.intercalate (', ') (Nil)\n''\n\n> S.intercalate (', ') (Cons ('foo') (Cons ('bar') (Cons ('baz') (Nil))))\n'foo, bar, baz'\n\n> S.intercalate ([0, 0, 0]) ([])\n[]\n\n> S.intercalate ([0, 0, 0]) ([[1], [2, 3], [4, 5, 6], [7, 8], [9]])\n[1, 0, 0, 0, 2, 3, 0, 0, 0, 4, 5, 6, 0, 0, 0, 7, 8, 0, 0, 0, 9]\n```\n\n#### <a name=\"foldMap\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3398\">`foldMap :: (Monoid m, Foldable f) => TypeRep m -⁠> (a -⁠> m) -⁠> f a -⁠> m`</a>\n\nCurried version of [`Z.foldMap`][]. Deconstructs a foldable by mapping\nevery element to a monoid and concatenating the results.\n\n```javascript\n> S.foldMap (String) (f => f.name) ([Math.sin, Math.cos, Math.tan])\n'sincostan'\n\n> S.foldMap (Array) (x => [x + 1, x + 2]) ([10, 20, 30])\n[11, 12, 21, 22, 31, 32]\n```\n\n#### <a name=\"unfoldr\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3416\">`unfoldr :: (b -⁠> Maybe (Pair a b)) -⁠> b -⁠> Array a`</a>\n\nTakes a function and a seed value, and returns an array generated by\napplying the function repeatedly. The array is initially empty. The\nfunction is initially applied to the seed value. Each application\nof the function should result in either:\n\n  - Nothing, in which case the array is returned; or\n\n  - Just a pair, in which case the first element is appended to\n    the array and the function is applied to the second element.\n\n```javascript\n> S.unfoldr (n => n < 1000 ? S.Just (S.Pair (n) (2 * n)) : S.Nothing) (1)\n[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n```\n\n#### <a name=\"range\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3447\">`range :: Integer -⁠> Integer -⁠> Array Integer`</a>\n\nReturns an array of consecutive integers starting with the first argument\nand ending with the second argument minus one. Returns `[]` if the second\nargument is less than or equal to the first argument.\n\n```javascript\n> S.range (0) (10)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n> S.range (-5) (0)\n[-5, -4, -3, -2, -1]\n\n> S.range (0) (-5)\n[]\n```\n\n#### <a name=\"groupBy\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3476\">`groupBy :: (a -⁠> a -⁠> Boolean) -⁠> Array a -⁠> Array (Array a)`</a>\n\nSplits its array argument into an array of arrays of equal,\nadjacent elements. Equality is determined by the function\nprovided as the first argument. Its behaviour can be surprising\nfor functions that aren't reflexive, transitive, and symmetric\n(see [equivalence][] relation).\n\nProperties:\n\n  - `forall f :: a -> a -> Boolean, xs :: Array a.\n     S.join (S.groupBy (f) (xs)) = xs`\n\n```javascript\n> S.groupBy (S.equals) ([1, 1, 2, 1, 1])\n[[1, 1], [2], [1, 1]]\n\n> S.groupBy (x => y => x + y === 0) ([2, -3, 3, 3, 3, 4, -4, 4])\n[[2], [-3, 3, 3, 3], [4, -4], [4]]\n```\n\n#### <a name=\"reverse\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3515\">`reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -⁠> f a`</a>\n\nReverses the elements of the given structure.\n\n```javascript\n> S.reverse ([1, 2, 3])\n[3, 2, 1]\n\n> S.reverse (Cons (1) (Cons (2) (Cons (3) (Nil))))\nCons (3) (Cons (2) (Cons (1) (Nil)))\n\n> S.pipe ([S.splitOn (''), S.reverse, S.joinWith ('')]) ('abc')\n'cba'\n```\n\n#### <a name=\"sort\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3535\">`sort :: (Ord a, Applicative m, Foldable m, Monoid (m a)) => m a -⁠> m a`</a>\n\nPerforms a [stable sort][] of the elements of the given structure, using\n[`Z.lte`][] for comparisons.\n\nProperties:\n\n  - `S.sort (S.sort (m)) = S.sort (m)` (idempotence)\n\nSee also [`sortBy`](#sortBy).\n\n```javascript\n> S.sort (['foo', 'bar', 'baz'])\n['bar', 'baz', 'foo']\n\n> S.sort ([S.Left (4), S.Right (3), S.Left (2), S.Right (1)])\n[Left (2), Left (4), Right (1), Right (3)]\n```\n\n#### <a name=\"sortBy\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3559\">`sortBy :: (Ord b, Applicative m, Foldable m, Monoid (m a)) => (a -⁠> b) -⁠> m a -⁠> m a`</a>\n\nPerforms a [stable sort][] of the elements of the given structure, using\n[`Z.lte`][] to compare the values produced by applying the given function\nto each element of the structure.\n\nProperties:\n\n  - `S.sortBy (f) (S.sortBy (f) (m)) = S.sortBy (f) (m)` (idempotence)\n\nSee also [`sort`](#sort).\n\n```javascript\n> S.sortBy (S.prop ('rank')) ([\n.   {rank: 7, suit: 'spades'},\n.   {rank: 5, suit: 'hearts'},\n.   {rank: 2, suit: 'hearts'},\n.   {rank: 5, suit: 'spades'},\n. ])\n[ {rank: 2, suit: 'hearts'},\n. {rank: 5, suit: 'hearts'},\n. {rank: 5, suit: 'spades'},\n. {rank: 7, suit: 'spades'} ]\n\n> S.sortBy (S.prop ('suit')) ([\n.   {rank: 7, suit: 'spades'},\n.   {rank: 5, suit: 'hearts'},\n.   {rank: 2, suit: 'hearts'},\n.   {rank: 5, suit: 'spades'},\n. ])\n[ {rank: 5, suit: 'hearts'},\n. {rank: 2, suit: 'hearts'},\n. {rank: 7, suit: 'spades'},\n. {rank: 5, suit: 'spades'} ]\n```\n\nIf descending order is desired, one may use [`Descending`][]:\n\n```javascript\n> S.sortBy (Descending) ([83, 97, 110, 99, 116, 117, 97, 114, 121])\n[121, 117, 116, 114, 110, 99, 97, 97, 83]\n```\n\n#### <a name=\"zip\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3607\">`zip :: Array a -⁠> Array b -⁠> Array (Pair a b)`</a>\n\nReturns an array of pairs of corresponding elements from the given\narrays. The length of the resulting array is equal to the length of\nthe shorter input array.\n\nSee also [`zipWith`](#zipWith).\n\n```javascript\n> S.zip (['a', 'b']) (['x', 'y', 'z'])\n[Pair ('a') ('x'), Pair ('b') ('y')]\n\n> S.zip ([1, 3, 5]) ([2, 4])\n[Pair (1) (2), Pair (3) (4)]\n```\n\n#### <a name=\"zipWith\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3628\">`zipWith :: (a -⁠> b -⁠> c) -⁠> Array a -⁠> Array b -⁠> Array c`</a>\n\nReturns the result of combining, pairwise, the given arrays using the\ngiven binary function. The length of the resulting array is equal to the\nlength of the shorter input array.\n\nSee also [`zip`](#zip).\n\n```javascript\n> S.zipWith (a => b => a + b) (['a', 'b']) (['x', 'y', 'z'])\n['ax', 'by']\n\n> S.zipWith (a => b => [a, b]) ([1, 3, 5]) ([2, 4])\n[[1, 2], [3, 4]]\n```\n\n### <span id=\"section:object\">❑ Object</span>\n\n#### <a name=\"prop\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3663\">`prop :: String -⁠> a -⁠> b`</a>\n\nTakes a property name and an object with known properties and returns\nthe value of the specified property. If for some reason the object\nlacks the specified property, a type error is thrown.\n\nFor accessing properties of uncertain objects, use [`get`](#get) instead.\nFor accessing string map values by key, use [`value`](#value) instead.\n\n```javascript\n> S.prop ('a') ({a: 1, b: 2})\n1\n```\n\n#### <a name=\"props\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3690\">`props :: Array String -⁠> a -⁠> b`</a>\n\nTakes a property path (an array of property names) and an object with\nknown structure and returns the value at the given path. If for some\nreason the path does not exist, a type error is thrown.\n\nFor accessing property paths of uncertain objects, use [`gets`](#gets)\ninstead.\n\n```javascript\n> S.props (['a', 'b', 'c']) ({a: {b: {c: 1}}})\n1\n```\n\n#### <a name=\"get\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3719\">`get :: (Any -⁠> Boolean) -⁠> String -⁠> a -⁠> Maybe b`</a>\n\nTakes a predicate, a property name, and an object and returns Just the\nvalue of the specified object property if it exists and the value\nsatisfies the given predicate; Nothing otherwise.\n\nSee also [`gets`](#gets), [`prop`](#prop), and [`value`](#value).\n\n```javascript\n> S.get (S.is ($.Number)) ('x') ({x: 1, y: 2})\nJust (1)\n\n> S.get (S.is ($.Number)) ('x') ({x: '1', y: '2'})\nNothing\n\n> S.get (S.is ($.Number)) ('x') ({})\nNothing\n\n> S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3]})\nJust ([1, 2, 3])\n\n> S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3, null]})\nNothing\n```\n\n#### <a name=\"gets\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3752\">`gets :: (Any -⁠> Boolean) -⁠> Array String -⁠> a -⁠> Maybe b`</a>\n\nTakes a predicate, a property path (an array of property names), and\nan object and returns Just the value at the given path if such a path\nexists and the value satisfies the given predicate; Nothing otherwise.\n\nSee also [`get`](#get).\n\n```javascript\n> S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: 42}}})\nJust (42)\n\n> S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: '42'}}})\nNothing\n\n> S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({})\nNothing\n```\n\n### <span id=\"section:strmap\">❑ StrMap</span>\n\nStrMap is an abbreviation of _string map_. A string map is an object,\nsuch as `{foo: 1, bar: 2, baz: 3}`, whose values are all members of\nthe same type. Formally, a value is a member of type `StrMap a` if its\n[type identifier][] is `'Object'` and the values of its enumerable own\nproperties are all members of type `a`.\n\n#### <a name=\"value\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3793\">`value :: String -⁠> StrMap a -⁠> Maybe a`</a>\n\nRetrieve the value associated with the given key in the given string map.\n\nFormally, `value (k) (m)` evaluates to `Just (m[k])` if `k` is an\nenumerable own property of `m`; `Nothing` otherwise.\n\nSee also [`prop`](#prop) and [`get`](#get).\n\n```javascript\n> S.value ('foo') ({foo: 1, bar: 2})\nJust (1)\n\n> S.value ('bar') ({foo: 1, bar: 2})\nJust (2)\n\n> S.value ('baz') ({foo: 1, bar: 2})\nNothing\n```\n\n#### <a name=\"singleton\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3825\">`singleton :: String -⁠> a -⁠> StrMap a`</a>\n\nTakes a string and a value of any type, and returns a string map with\na single entry (mapping the key to the value).\n\n```javascript\n> S.singleton ('foo') (42)\n{foo: 42}\n```\n\n#### <a name=\"insert\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3847\">`insert :: String -⁠> a -⁠> StrMap a -⁠> StrMap a`</a>\n\nTakes a string, a value of any type, and a string map, and returns a\nstring map comprising all the entries of the given string map plus the\nentry specified by the first two arguments (which takes precedence).\n\nEquivalent to Haskell's `insert` function. Similar to Clojure's `assoc`\nfunction.\n\n```javascript\n> S.insert ('c') (3) ({a: 1, b: 2})\n{a: 1, b: 2, c: 3}\n\n> S.insert ('a') (4) ({a: 1, b: 2})\n{a: 4, b: 2}\n```\n\n#### <a name=\"remove\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3876\">`remove :: String -⁠> StrMap a -⁠> StrMap a`</a>\n\nTakes a string and a string map, and returns a string map comprising all\nthe entries of the given string map except the one whose key matches the\ngiven string (if such a key exists).\n\nEquivalent to Haskell's `delete` function. Similar to Clojure's `dissoc`\nfunction.\n\n```javascript\n> S.remove ('c') ({a: 1, b: 2, c: 3})\n{a: 1, b: 2}\n\n> S.remove ('c') ({})\n{}\n```\n\n#### <a name=\"keys\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3905\">`keys :: StrMap a -⁠> Array String`</a>\n\nReturns the keys of the given string map, in arbitrary order.\n\n```javascript\n> S.sort (S.keys ({b: 2, c: 3, a: 1}))\n['a', 'b', 'c']\n```\n\n#### <a name=\"values\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3919\">`values :: StrMap a -⁠> Array a`</a>\n\nReturns the values of the given string map, in arbitrary order.\n\n```javascript\n> S.sort (S.values ({a: 1, c: 3, b: 2}))\n[1, 2, 3]\n```\n\n#### <a name=\"pairs\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3936\">`pairs :: StrMap a -⁠> Array (Pair String a)`</a>\n\nReturns the key–value pairs of the given string map, in arbitrary order.\n\n```javascript\n> S.sort (S.pairs ({b: 2, a: 1, c: 3}))\n[Pair ('a') (1), Pair ('b') (2), Pair ('c') (3)]\n```\n\n#### <a name=\"fromPairs\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3954\">`fromPairs :: Foldable f => f (Pair String a) -⁠> StrMap a`</a>\n\nReturns a string map containing the key–value pairs specified by the\ngiven [Foldable][]. If a key appears in multiple pairs, the rightmost\npair takes precedence.\n\n```javascript\n> S.fromPairs ([S.Pair ('a') (1), S.Pair ('b') (2), S.Pair ('c') (3)])\n{a: 1, b: 2, c: 3}\n\n> S.fromPairs ([S.Pair ('x') (1), S.Pair ('x') (2)])\n{x: 2}\n```\n\n### <span id=\"section:number\">❑ Number</span>\n\n#### <a name=\"negate\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L3981\">`negate :: ValidNumber -⁠> ValidNumber`</a>\n\nNegates its argument.\n\n```javascript\n> S.negate (12.5)\n-12.5\n\n> S.negate (-42)\n42\n```\n\n#### <a name=\"add\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4001\">`add :: FiniteNumber -⁠> FiniteNumber -⁠> FiniteNumber`</a>\n\nReturns the sum of two (finite) numbers.\n\n```javascript\n> S.add (1) (1)\n2\n```\n\n#### <a name=\"sum\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4020\">`sum :: Foldable f => f FiniteNumber -⁠> FiniteNumber`</a>\n\nReturns the sum of the given array of (finite) numbers.\n\n```javascript\n> S.sum ([1, 2, 3, 4, 5])\n15\n\n> S.sum ([])\n0\n\n> S.sum (S.Just (42))\n42\n\n> S.sum (S.Nothing)\n0\n```\n\n#### <a name=\"sub\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4043\">`sub :: FiniteNumber -⁠> FiniteNumber -⁠> FiniteNumber`</a>\n\nTakes a finite number `n` and returns the _subtract `n`_ function.\n\n```javascript\n> S.map (S.sub (1)) ([1, 2, 3])\n[0, 1, 2]\n```\n\n#### <a name=\"mult\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4062\">`mult :: FiniteNumber -⁠> FiniteNumber -⁠> FiniteNumber`</a>\n\nReturns the product of two (finite) numbers.\n\n```javascript\n> S.mult (4) (2)\n8\n```\n\n#### <a name=\"product\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4081\">`product :: Foldable f => f FiniteNumber -⁠> FiniteNumber`</a>\n\nReturns the product of the given array of (finite) numbers.\n\n```javascript\n> S.product ([1, 2, 3, 4, 5])\n120\n\n> S.product ([])\n1\n\n> S.product (S.Just (42))\n42\n\n> S.product (S.Nothing)\n1\n```\n\n#### <a name=\"div\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4104\">`div :: NonZeroFiniteNumber -⁠> FiniteNumber -⁠> FiniteNumber`</a>\n\nTakes a non-zero finite number `n` and returns the _divide by `n`_\nfunction.\n\n```javascript\n> S.map (S.div (2)) ([0, 1, 2, 3])\n[0, 0.5, 1, 1.5]\n```\n\n#### <a name=\"pow\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4124\">`pow :: FiniteNumber -⁠> FiniteNumber -⁠> FiniteNumber`</a>\n\nTakes a finite number `n` and returns the _power of `n`_ function.\n\n```javascript\n> S.map (S.pow (2)) ([-3, -2, -1, 0, 1, 2, 3])\n[9, 4, 1, 0, 1, 4, 9]\n\n> S.map (S.pow (0.5)) ([1, 4, 9, 16, 25])\n[1, 2, 3, 4, 5]\n```\n\n#### <a name=\"mean\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4146\">`mean :: Foldable f => f FiniteNumber -⁠> Maybe FiniteNumber`</a>\n\nReturns the mean of the given array of (finite) numbers.\n\n```javascript\n> S.mean ([1, 2, 3, 4, 5])\nJust (3)\n\n> S.mean ([])\nNothing\n\n> S.mean (S.Just (42))\nJust (42)\n\n> S.mean (S.Nothing)\nNothing\n```\n\n### <span id=\"section:integer\">❑ Integer</span>\n\n#### <a name=\"even\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4183\">`even :: Integer -⁠> Boolean`</a>\n\nReturns `true` if the given integer is even; `false` if it is odd.\n\n```javascript\n> S.even (42)\ntrue\n\n> S.even (99)\nfalse\n```\n\n#### <a name=\"odd\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4203\">`odd :: Integer -⁠> Boolean`</a>\n\nReturns `true` if the given integer is odd; `false` if it is even.\n\n```javascript\n> S.odd (99)\ntrue\n\n> S.odd (42)\nfalse\n```\n\n### <span id=\"section:parse\">❑ Parse</span>\n\n#### <a name=\"parseDate\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4225\">`parseDate :: String -⁠> Maybe ValidDate`</a>\n\nTakes a string `s` and returns `Just (new Date (s))` if `new Date (s)`\nevaluates to a [`ValidDate`][ValidDate] value; Nothing otherwise.\n\nAs noted in [#488][], this function's behaviour is unspecified for some\ninputs! [MDN][date parsing] warns against using the `Date` constructor\nto parse date strings:\n\n> __Note:__ parsing of date strings with the `Date` constructor […] is\n> strongly discouraged due to browser differences and inconsistencies.\n> Support for RFC 2822 format strings is by convention only. Support for\n> ISO 8601 formats differs in that date-only strings (e.g. \"1970-01-01\")\n> are treated as UTC, not local.\n\n```javascript\n> S.parseDate ('2011-01-19T17:40:00Z')\nJust (new Date ('2011-01-19T17:40:00.000Z'))\n\n> S.parseDate ('today')\nNothing\n```\n\n#### <a name=\"parseFloat\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4291\">`parseFloat :: String -⁠> Maybe Number`</a>\n\nTakes a string and returns Just the number represented by the string\nif it does in fact represent a number; Nothing otherwise.\n\n```javascript\n> S.parseFloat ('-123.45')\nJust (-123.45)\n\n> S.parseFloat ('foo.bar')\nNothing\n```\n\n#### <a name=\"parseInt\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4319\">`parseInt :: Radix -⁠> String -⁠> Maybe Integer`</a>\n\nTakes a radix (an integer between 2 and 36 inclusive) and a string,\nand returns Just the number represented by the string if it does in\nfact represent a number in the base specified by the radix; Nothing\notherwise.\n\nThis function is stricter than [`parseInt`][parseInt]: a string\nis considered to represent an integer only if all its non-prefix\ncharacters are members of the character set specified by the radix.\n\n```javascript\n> S.parseInt (10) ('-42')\nJust (-42)\n\n> S.parseInt (16) ('0xFF')\nJust (255)\n\n> S.parseInt (16) ('0xGG')\nNothing\n```\n\n#### <a name=\"parseJson\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4359\">`parseJson :: (Any -⁠> Boolean) -⁠> String -⁠> Maybe a`</a>\n\nTakes a predicate and a string that may or may not be valid JSON, and\nreturns Just the result of applying `JSON.parse` to the string *if* the\nresult satisfies the predicate; Nothing otherwise.\n\n```javascript\n> S.parseJson (S.is ($.Array ($.Integer))) ('[')\nNothing\n\n> S.parseJson (S.is ($.Array ($.Integer))) ('[\"1\",\"2\",\"3\"]')\nNothing\n\n> S.parseJson (S.is ($.Array ($.Integer))) ('[0,1.5,3,4.5]')\nNothing\n\n> S.parseJson (S.is ($.Array ($.Integer))) ('[1,2,3]')\nJust ([1, 2, 3])\n```\n\n### <span id=\"section:regexp\">❑ RegExp</span>\n\n#### <a name=\"regex\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4411\">`regex :: RegexFlags -⁠> String -⁠> RegExp`</a>\n\nTakes a [RegexFlags][] and a pattern, and returns a RegExp.\n\n```javascript\n> S.regex ('g') (':\\\\d+:')\n/:\\d+:/g\n```\n\n#### <a name=\"regexEscape\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4430\">`regexEscape :: String -⁠> String`</a>\n\nTakes a string that may contain regular expression metacharacters,\nand returns a string with those metacharacters escaped.\n\nProperties:\n\n  - `forall s :: String.\n     S.test (S.regex ('') (S.regexEscape (s))) (s) = true`\n\n```javascript\n> S.regexEscape ('-=*{XYZ}*=-')\n'\\\\-=\\\\*\\\\{XYZ\\\\}\\\\*=\\\\-'\n```\n\n#### <a name=\"test\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4453\">`test :: RegExp -⁠> String -⁠> Boolean`</a>\n\nTakes a pattern and a string, and returns `true` [iff][] the pattern\nmatches the string.\n\n```javascript\n> S.test (/^a/) ('abacus')\ntrue\n\n> S.test (/^a/) ('banana')\nfalse\n```\n\n#### <a name=\"match\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4476\">`match :: NonGlobalRegExp -⁠> String -⁠> Maybe { match :: String, groups :: Array (Maybe String) }`</a>\n\nTakes a pattern and a string, and returns Just a match record if the\npattern matches the string; Nothing otherwise.\n\n`groups :: Array (Maybe String)` acknowledges the existence of optional\ncapturing groups.\n\nProperties:\n\n  - `forall p :: Pattern, s :: String.\n     S.head (S.matchAll (S.regex ('g') (p)) (s))\n     = S.match (S.regex ('') (p)) (s)`\n\nSee also [`matchAll`](#matchAll).\n\n```javascript\n> S.match (/(good)?bye/) ('goodbye')\nJust ({match: 'goodbye', groups: [Just ('good')]})\n\n> S.match (/(good)?bye/) ('bye')\nJust ({match: 'bye', groups: [Nothing]})\n```\n\n#### <a name=\"matchAll\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4511\">`matchAll :: GlobalRegExp -⁠> String -⁠> Array { match :: String, groups :: Array (Maybe String) }`</a>\n\nTakes a pattern and a string, and returns an array of match records.\n\n`groups :: Array (Maybe String)` acknowledges the existence of optional\ncapturing groups.\n\nSee also [`match`](#match).\n\n```javascript\n> S.matchAll (/@([a-z]+)/g) ('Hello, world!')\n[]\n\n> S.matchAll (/@([a-z]+)/g) ('Hello, @foo! Hello, @bar! Hello, @baz!')\n[ {match: '@foo', groups: [Just ('foo')]},\n. {match: '@bar', groups: [Just ('bar')]},\n. {match: '@baz', groups: [Just ('baz')]} ]\n```\n\n### <span id=\"section:string\">❑ String</span>\n\n#### <a name=\"toUpper\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4548\">`toUpper :: String -⁠> String`</a>\n\nReturns the upper-case equivalent of its argument.\n\nSee also [`toLower`](#toLower).\n\n```javascript\n> S.toUpper ('ABC def 123')\n'ABC DEF 123'\n```\n\n#### <a name=\"toLower\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4564\">`toLower :: String -⁠> String`</a>\n\nReturns the lower-case equivalent of its argument.\n\nSee also [`toUpper`](#toUpper).\n\n```javascript\n> S.toLower ('ABC def 123')\n'abc def 123'\n```\n\n#### <a name=\"trim\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4580\">`trim :: String -⁠> String`</a>\n\nStrips leading and trailing whitespace characters.\n\n```javascript\n> S.trim ('\\t\\t foo bar \\n')\n'foo bar'\n```\n\n#### <a name=\"stripPrefix\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4594\">`stripPrefix :: String -⁠> String -⁠> Maybe String`</a>\n\nReturns Just the portion of the given string (the second argument) left\nafter removing the given prefix (the first argument) if the string starts\nwith the prefix; Nothing otherwise.\n\nSee also [`stripSuffix`](#stripSuffix).\n\n```javascript\n> S.stripPrefix ('https://') ('https://sanctuary.js.org')\nJust ('sanctuary.js.org')\n\n> S.stripPrefix ('https://') ('http://sanctuary.js.org')\nNothing\n```\n\n#### <a name=\"stripSuffix\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4621\">`stripSuffix :: String -⁠> String -⁠> Maybe String`</a>\n\nReturns Just the portion of the given string (the second argument) left\nafter removing the given suffix (the first argument) if the string ends\nwith the suffix; Nothing otherwise.\n\nSee also [`stripPrefix`](#stripPrefix).\n\n```javascript\n> S.stripSuffix ('.md') ('README.md')\nJust ('README')\n\n> S.stripSuffix ('.md') ('README')\nNothing\n```\n\n#### <a name=\"words\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4648\">`words :: String -⁠> Array String`</a>\n\nTakes a string and returns the array of words the string contains\n(words are delimited by whitespace characters).\n\nSee also [`unwords`](#unwords).\n\n```javascript\n> S.words (' foo bar baz ')\n['foo', 'bar', 'baz']\n```\n\n#### <a name=\"unwords\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4671\">`unwords :: Array String -⁠> String`</a>\n\nTakes an array of words and returns the result of joining the words\nwith separating spaces.\n\nSee also [`words`](#words).\n\n```javascript\n> S.unwords (['foo', 'bar', 'baz'])\n'foo bar baz'\n```\n\n#### <a name=\"lines\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4688\">`lines :: String -⁠> Array String`</a>\n\nTakes a string and returns the array of lines the string contains\n(lines are delimited by newlines: `'\\n'` or `'\\r\\n'` or `'\\r'`).\nThe resulting strings do not contain newlines.\n\nSee also [`unlines`](#unlines).\n\n```javascript\n> S.lines ('foo\\nbar\\nbaz\\n')\n['foo', 'bar', 'baz']\n```\n\n#### <a name=\"unlines\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4710\">`unlines :: Array String -⁠> String`</a>\n\nTakes an array of lines and returns the result of joining the lines\nafter appending a terminating line feed (`'\\n'`) to each.\n\nSee also [`lines`](#lines).\n\n```javascript\n> S.unlines (['foo', 'bar', 'baz'])\n'foo\\nbar\\nbaz\\n'\n```\n\n#### <a name=\"splitOn\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4730\">`splitOn :: String -⁠> String -⁠> Array String`</a>\n\nReturns the substrings of its second argument separated by occurrences\nof its first argument.\n\nSee also [`joinWith`](#joinWith) and [`splitOnRegex`](#splitOnRegex).\n\n```javascript\n> S.splitOn ('::') ('foo::bar::baz')\n['foo', 'bar', 'baz']\n```\n\n#### <a name=\"splitOnRegex\" href=\"https://github.com/sanctuary-js/sanctuary/blob/v3.1.0/index.js#L4747\">`splitOnRegex :: GlobalRegExp -⁠> String -⁠> Array String`</a>\n\nTakes a pattern and a string, and returns the result of splitting the\nstring at every non-overlapping occurrence of the pattern.\n\nProperties:\n\n  - `forall s :: String, t :: String.\n     S.joinWith (s)\n                (S.splitOnRegex (S.regex ('g') (S.regexEscape (s))) (t))\n     = t`\n\nSee also [`splitOn`](#splitOn).\n\n```javascript\n> S.splitOnRegex (/[,;][ ]*/g) ('foo, bar, baz')\n['foo', 'bar', 'baz']\n\n> S.splitOnRegex (/[,;][ ]*/g) ('foo;bar;baz')\n['foo', 'bar', 'baz']\n```\n\n[#438]:                     https://github.com/sanctuary-js/sanctuary/issues/438\n[#488]:                     https://github.com/sanctuary-js/sanctuary/issues/488\n[Apply]:                    https://github.com/fantasyland/fantasy-land/tree/v4.0.1#apply\n[Chain]:                    https://github.com/fantasyland/fantasy-land/tree/v4.0.1#chain\n[Either]:                   #section:either\n[Fantasy Land]:             https://github.com/fantasyland/fantasy-land/tree/v4.0.1\n[Foldable]:                 https://github.com/fantasyland/fantasy-land/tree/v4.0.1#foldable\n[Folktale]:                 https://folktale.origamitower.com/\n[GIGO]:                     https://en.wikipedia.org/wiki/Garbage_in,_garbage_out\n[Haskell]:                  https://www.haskell.org/\n[Kleisli]:                  https://en.wikipedia.org/wiki/Kleisli_category\n[Maybe]:                    #section:maybe\n[Nullable]:                 https://github.com/sanctuary-js/sanctuary-def/tree/v0.22.0#Nullable\n[PureScript]:               http://www.purescript.org/\n[Ramda]:                    https://ramdajs.com/\n[RegexFlags]:               https://github.com/sanctuary-js/sanctuary-def/tree/v0.22.0#RegexFlags\n[Semigroupoid]:             https://github.com/fantasyland/fantasy-land/tree/v4.0.1#semigroupoid\n[ValidDate]:                https://github.com/sanctuary-js/sanctuary-def/tree/v0.22.0#ValidDate\n[`$.test`]:                 https://github.com/sanctuary-js/sanctuary-def/tree/v0.22.0#test\n[`Descending`]:             https://github.com/sanctuary-js/sanctuary-descending/tree/v2.1.0#Descending\n[`R.__`]:                   https://ramdajs.com/docs/#__\n[`R.bind`]:                 https://ramdajs.com/docs/#bind\n[`R.invoker`]:              https://ramdajs.com/docs/#invoker\n[`Z.alt`]:                  https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#alt\n[`Z.ap`]:                   https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#ap\n[`Z.apFirst`]:              https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#apFirst\n[`Z.apSecond`]:             https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#apSecond\n[`Z.bimap`]:                https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#bimap\n[`Z.chain`]:                https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#chain\n[`Z.chainRec`]:             https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#chainRec\n[`Z.compose`]:              https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#compose\n[`Z.concat`]:               https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#concat\n[`Z.contramap`]:            https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#contramap\n[`Z.duplicate`]:            https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#duplicate\n[`Z.empty`]:                https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#empty\n[`Z.equals`]:               https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#equals\n[`Z.extend`]:               https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#extend\n[`Z.extract`]:              https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#extract\n[`Z.filter`]:               https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#filter\n[`Z.flip`]:                 https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#flip\n[`Z.foldMap`]:              https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#foldMap\n[`Z.gt`]:                   https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#gt\n[`Z.gte`]:                  https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#gte\n[`Z.id`]:                   https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#id\n[`Z.intercalate`]:          https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#intercalate\n[`Z.invert`]:               https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#invert\n[`Z.join`]:                 https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#join\n[`Z.lt`]:                   https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#lt\n[`Z.lte`]:                  https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#lte\n[`Z.map`]:                  https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#map\n[`Z.mapLeft`]:              https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#mapLeft\n[`Z.of`]:                   https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#of\n[`Z.promap`]:               https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#promap\n[`Z.reject`]:               https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#reject\n[`Z.sequence`]:             https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#sequence\n[`Z.traverse`]:             https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#traverse\n[`Z.zero`]:                 https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0#zero\n[`show`]:                   https://github.com/sanctuary-js/sanctuary-show/tree/v2.0.0#show\n[date parsing]:             https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n[equivalence]:              https://en.wikipedia.org/wiki/Equivalence_relation\n[iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n[parseInt]:                 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n[partial functions]:        https://en.wikipedia.org/wiki/Partial_function\n[ramda/ramda#683]:          https://github.com/ramda/ramda/issues/683\n[ramda/ramda#1413]:         https://github.com/ramda/ramda/issues/1413\n[ramda/ramda#1419]:         https://github.com/ramda/ramda/pull/1419\n[sanctuary-def]:            https://github.com/sanctuary-js/sanctuary-def/tree/v0.22.0\n[sanctuary-either]:         https://github.com/sanctuary-js/sanctuary-either/tree/v2.1.0\n[sanctuary-maybe]:          https://github.com/sanctuary-js/sanctuary-maybe/tree/v2.1.0\n[sanctuary-pair]:           https://github.com/sanctuary-js/sanctuary-pair/tree/v2.1.0\n[sanctuary-show]:           https://github.com/sanctuary-js/sanctuary-show/tree/v2.0.0\n[sanctuary-type-classes]:   https://github.com/sanctuary-js/sanctuary-type-classes/tree/v12.1.0\n[stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n[thrush]:                   https://github.com/raganwald-deprecated/homoiconic/blob/master/2008-10-30/thrush.markdown\n[total functions]:          https://en.wikipedia.org/wiki/Partial_function#Total_function\n[type checking]:            #section:type-checking\n[type identifier]:          https://github.com/sanctuary-js/sanctuary-type-identifiers/tree/v3.0.0\n[type representative]:      https://github.com/fantasyland/fantasy-land/tree/v4.0.1#type-representatives\n[variadic functions]:       https://en.wikipedia.org/wiki/Variadic_function\n"
        },
        {
          "name": "dist",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 128.6181640625,
          "content": "/*    #######\n   ####     ####\n ####   ###   ####\n#####   ###########   sanctuary\n########   ########   noun\n###########   #####   1 [ mass noun ] refuge from unsafe JavaScript\n ####   ###   ####\n   ####     ####\n      #######    */\n\n//. # Sanctuary\n//.\n//. [![npm](https://img.shields.io/npm/v/sanctuary.svg)](https://www.npmjs.com/package/sanctuary)\n//. [![CircleCI](https://img.shields.io/circleci/project/github/sanctuary-js/sanctuary/main.svg)](https://app.circleci.com/pipelines/github/sanctuary-js/sanctuary?branch=main)\n//. [![Gitter](https://img.shields.io/gitter/room/badges/shields.svg)](https://gitter.im/sanctuary-js/sanctuary)\n//.\n//. Sanctuary is a JavaScript functional programming library inspired by\n//. [Haskell][] and [PureScript][]. It's stricter than [Ramda][], and\n//. provides a similar suite of functions.\n//.\n//. Sanctuary promotes programs composed of simple, pure functions. Such\n//. programs are easier to comprehend, test, and maintain &ndash; they are\n//. also a pleasure to write.\n//.\n//. Sanctuary provides two data types, [Maybe][] and [Either][], both of\n//. which are compatible with [Fantasy Land][]. Thanks to these data types\n//. even Sanctuary functions that may fail, such as [`head`](#head), are\n//. composable.\n//.\n//. Sanctuary makes it possible to write safe code without null checks.\n//. In JavaScript it's trivial to introduce a possible run-time type error:\n//.\n//.     words[0].toUpperCase()\n//.\n//. If `words` is `[]` we'll get a familiar error at run-time:\n//.\n//.     TypeError: Cannot read property 'toUpperCase' of undefined\n//.\n//. Sanctuary gives us a fighting chance of avoiding such errors. We might\n//. write:\n//.\n//.     S.map (S.toUpper) (S.head (words))\n//.\n//. Sanctuary is designed to work in Node.js and in ES5-compatible browsers.\n//.\n//. ## Folktale\n//.\n//. [Folktale][], like Sanctuary, is a standard library for functional\n//. programming in JavaScript. It is well designed and well documented.\n//. Whereas Sanctuary treats JavaScript as a member of the ML language\n//. family, Folktale embraces JavaScript's object-oriented programming\n//. model. Programming with Folktale resembles programming with Scala.\n//.\n//. ## Ramda\n//.\n//. [Ramda][] provides several functions that return problematic values\n//. such as `undefined`, `Infinity`, or `NaN` when applied to unsuitable\n//. inputs. These are known as [partial functions][]. Partial functions\n//. necessitate the use of guards or null checks. In order to safely use\n//. `R.head`, for example, one must ensure that the array is non-empty:\n//.\n//.     if (R.isEmpty (xs)) {\n//.       // ...\n//.     } else {\n//.       return f (R.head (xs));\n//.     }\n//.\n//. Using the Maybe type renders such guards (and null checks) unnecessary.\n//. Changing functions such as `R.head` to return Maybe values was proposed\n//. in [ramda/ramda#683][], but was considered too much of a stretch for\n//. JavaScript programmers. Sanctuary was released the following month,\n//. in January 2015, as a companion library to Ramda.\n//.\n//. In addition to broadening in scope in the years since its release,\n//. Sanctuary's philosophy has diverged from Ramda's in several respects.\n//.\n//. ### Totality\n//.\n//. Every Sanctuary function is defined for every value that is a member of\n//. the function's input type. Such functions are known as [total functions][].\n//. Ramda, on the other hand, contains a number of [partial functions][].\n//.\n//. ### Information preservation\n//.\n//. Certain Sanctuary functions preserve more information than their Ramda\n//. counterparts. Examples:\n//.\n//.     |> R.tail ([])                      |> S.tail ([])\n//.     []                                  Nothing\n//.\n//.     |> R.tail (['foo'])                 |> S.tail (['foo'])\n//.     []                                  Just ([])\n//.\n//.     |> R.replace (/^x/) ('') ('abc')    |> S.stripPrefix ('x') ('abc')\n//.     'abc'                               Nothing\n//.\n//.     |> R.replace (/^x/) ('') ('xabc')   |> S.stripPrefix ('x') ('xabc')\n//.     'abc'                               Just ('abc')\n//.\n//. ### Invariants\n//.\n//. Sanctuary performs rigorous [type checking][] of inputs and outputs, and\n//. throws a descriptive error if a type error is encountered. This allows bugs\n//. to be caught and fixed early in the development cycle.\n//.\n//. Ramda operates on the [garbage in, garbage out][GIGO] principle. Functions\n//. are documented to take arguments of particular types, but these invariants\n//. are not enforced. The problem with this approach in a language as\n//. permissive as JavaScript is that there's no guarantee that garbage input\n//. will produce garbage output ([ramda/ramda#1413][]). Ramda performs ad hoc\n//. type checking in some such cases ([ramda/ramda#1419][]).\n//.\n//. Sanctuary can be configured to operate in garbage in, garbage out mode.\n//. Ramda cannot be configured to enforce its invariants.\n//.\n//. ### Currying\n//.\n//. Sanctuary functions are curried. There is, for example, exactly one way to\n//. apply `S.reduce` to `S.add`, `0`, and `xs`:\n//.\n//.   - `S.reduce (S.add) (0) (xs)`\n//.\n//. Ramda functions are also curried, but in a complex manner. There are four\n//. ways to apply `R.reduce` to `R.add`, `0`, and `xs`:\n//.\n//.   - `R.reduce (R.add) (0) (xs)`\n//.   - `R.reduce (R.add) (0, xs)`\n//.   - `R.reduce (R.add, 0) (xs)`\n//.   - `R.reduce (R.add, 0, xs)`\n//.\n//. Ramda supports all these forms because curried functions enable partial\n//. application, one of the library's tenets, but `f(x)(y)(z)` is considered\n//. too unfamiliar and too unattractive to appeal to JavaScript programmers.\n//.\n//. Sanctuary's developers prefer a simple, unfamiliar construct to a complex,\n//. familiar one. Familiarity can be acquired; complexity is intrinsic.\n//.\n//. The lack of breathing room in `f(x)(y)(z)` impairs readability. The simple\n//. solution to this problem, proposed in [#438][], is to include a space when\n//. applying a function: `f (x) (y) (z)`.\n//.\n//. Ramda also provides a special placeholder value, [`R.__`][], that removes\n//. the restriction that a function must be applied to its arguments in order.\n//. The following expressions are equivalent:\n//.\n//.   - `R.reduce (R.__, 0, xs) (R.add)`\n//.   - `R.reduce (R.add, R.__, xs) (0)`\n//.   - `R.reduce (R.__, 0) (R.add) (xs)`\n//.   - `R.reduce (R.__, 0) (R.add, xs)`\n//.   - `R.reduce (R.__, R.__, xs) (R.add) (0)`\n//.   - `R.reduce (R.__, R.__, xs) (R.add, 0)`\n//.\n//. ### Variadic functions\n//.\n//. Ramda provides several functions that take any number of arguments. These\n//. are known as [variadic functions][]. Additionally, Ramda provides several\n//. functions that take variadic functions as arguments. Although natural in\n//. a dynamically typed language, variadic functions are at odds with the type\n//. notation Ramda and Sanctuary both use, leading to some indecipherable type\n//. signatures such as this one:\n//.\n//.     R.lift :: (*... -> *...) -> ([*]... -> [*])\n//.\n//. Sanctuary has no variadic functions, nor any functions that take variadic\n//. functions as arguments. Sanctuary provides two \"lift\" functions, each with\n//. a helpful type signature:\n//.\n//.     S.lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c\n//.     S.lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n//.\n//. ### Implicit context\n//.\n//. Ramda provides [`R.bind`][] and [`R.invoker`][] for working with methods.\n//. Additionally, many Ramda functions use `Function#call` or `Function#apply`\n//. to preserve context. Sanctuary makes no allowances for `this`.\n//.\n//. ### Transducers\n//.\n//. Several Ramda functions act as transducers. Sanctuary provides no support\n//. for transducers.\n//.\n//. ### Modularity\n//.\n//. Whereas Ramda has no dependencies, Sanctuary has a modular design:\n//. [sanctuary-def][] provides type checking, [sanctuary-type-classes][]\n//. provides Fantasy Land functions and type classes, [sanctuary-show][]\n//. provides string representations, and algebraic data types are provided\n//. by [sanctuary-either][], [sanctuary-maybe][], and [sanctuary-pair][].\n//. Not only does this approach reduce the complexity of Sanctuary itself,\n//. but it allows these components to be reused in other contexts.\n//.\n//. ## Types\n//.\n//. Sanctuary uses Haskell-like type signatures to describe the types of\n//. values, including functions. `'foo'`, for example, is a member of `String`;\n//. `[1, 2, 3]` is a member of `Array Number`. The double colon (`::`) is used\n//. to mean \"is a member of\", so one could write:\n//.\n//.     'foo' :: String\n//.     [1, 2, 3] :: Array Number\n//.\n//. An identifier may appear to the left of the double colon:\n//.\n//.     Math.PI :: Number\n//.\n//. The arrow (`->`) is used to express a function's type:\n//.\n//.     Math.abs :: Number -> Number\n//.\n//. That states that `Math.abs` is a unary function that takes an argument\n//. of type `Number` and returns a value of type `Number`.\n//.\n//. Some functions are parametrically polymorphic: their types are not fixed.\n//. Type variables are used in the representations of such functions:\n//.\n//.     S.I :: a -> a\n//.\n//. `a` is a type variable. Type variables are not capitalized, so they\n//. are differentiable from type identifiers (which are always capitalized).\n//. By convention type variables have single-character names. The signature\n//. above states that `S.I` takes a value of any type and returns a value of\n//. the same type. Some signatures feature multiple type variables:\n//.\n//.     S.K :: a -> b -> a\n//.\n//. It must be possible to replace all occurrences of `a` with a concrete type.\n//. The same applies for each other type variable. For the function above, the\n//. types with which `a` and `b` are replaced may be different, but needn't be.\n//.\n//. Since all Sanctuary functions are curried (they accept their arguments\n//. one at a time), a binary function is represented as a unary function that\n//. returns a unary function: `* -> * -> *`. This aligns neatly with Haskell,\n//. which uses curried functions exclusively. In JavaScript, though, we may\n//. wish to represent the types of functions with arities less than or greater\n//. than one. The general form is `(<input-types>) -> <output-type>`, where\n//. `<input-types>` comprises zero or more comma–space (<code>, </code>)\n//. -separated type representations:\n//.\n//.   - `() -> String`\n//.   - `(a, b) -> a`\n//.   - `(a, b, c) -> d`\n//.\n//. `Number -> Number` can thus be seen as shorthand for `(Number) -> Number`.\n//.\n//. Sanctuary embraces types. JavaScript doesn't support algebraic data types,\n//. but these can be simulated by providing a group of data constructors that\n//. return values with the same set of methods. A value of the Either type, for\n//. example, is created via the Left constructor or the Right constructor.\n//.\n//. It's necessary to extend Haskell's notation to describe implicit arguments\n//. to the *methods* provided by Sanctuary's types. In `x.map(y)`, for example,\n//. the `map` method takes an implicit argument `x` in addition to the explicit\n//. argument `y`. The type of the value upon which a method is invoked appears\n//. at the beginning of the signature, separated from the arguments and return\n//. value by a squiggly arrow (`~>`). The type of the `fantasy-land/map` method\n//. of the Maybe type is written `Maybe a ~> (a -> b) -> Maybe b`. One could\n//. read this as:\n//.\n//. _When the `fantasy-land/map` method is invoked on a value of type `Maybe a`\n//. (for any type `a`) with an argument of type `a -> b` (for any type `b`),\n//. it returns a value of type `Maybe b`._\n//.\n//. The squiggly arrow is also used when representing non-function properties.\n//. `Maybe a ~> Boolean`, for example, represents a Boolean property of a value\n//. of type `Maybe a`.\n//.\n//. Sanctuary supports type classes: constraints on type variables. Whereas\n//. `a -> a` implicitly supports every type, `Functor f => (a -> b) -> f a ->\n//. f b` requires that `f` be a type that satisfies the requirements of the\n//. Functor type class. Type-class constraints appear at the beginning of a\n//. type signature, separated from the rest of the signature by a fat arrow\n//. (`=>`).\n//.\n//. ## Type checking\n//.\n//. Sanctuary functions are defined via [sanctuary-def][] to provide run-time\n//. type checking. This is tremendously useful during development: type errors\n//. are reported immediately, avoiding circuitous stack traces (at best) and\n//. silent failures due to type coercion (at worst). For example:\n//.\n//. ```javascript\n//. S.add (2) (true);\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n//. //                          ^^^^^^^^^^^^\n//. //                               1\n//. //\n//. //   1)  true :: Boolean\n//. //\n//. //   The value at position 1 is not a member of ‘FiniteNumber’.\n//. //\n//. //   See v:sanctuary-js/sanctuary-def#FiniteNumber for information about the FiniteNumber type.\n//. ```\n//.\n//. Compare this to the behaviour of Ramda's unchecked equivalent:\n//.\n//. ```javascript\n//. R.add (2) (true);\n//. // => 3\n//. ```\n//.\n//. There is a performance cost to run-time type checking. Type checking is\n//. disabled by default if `process.env.NODE_ENV` is `'production'`. If this\n//. rule is unsuitable for a given program, one may use [`create`](#create)\n//. to create a Sanctuary module based on a different rule. For example:\n//.\n//. ```javascript\n//. const S = sanctuary.create ({\n//.   checkTypes: localStorage.getItem ('SANCTUARY_CHECK_TYPES') === 'true',\n//.   env: sanctuary.env,\n//. });\n//. ```\n//.\n//. Occasionally one may wish to perform an operation that is not type safe,\n//. such as mapping over an object with heterogeneous values. This is possible\n//. via selective use of [`unchecked`](#unchecked) functions.\n//.\n//. ## Installation\n//.\n//. `npm install sanctuary` will install Sanctuary for use in Node.js.\n//.\n//. To add Sanctuary to a website, add the following `<script>` element,\n//. replacing `X.Y.Z` with a version number greater than or equal to `2.0.2`:\n//.\n//. ```html\n//. <script src=\"https://cdn.jsdelivr.net/gh/sanctuary-js/sanctuary@X.Y.Z/dist/bundle.js\"></script>\n//. ```\n//.\n//. Optionally, define aliases for various modules:\n//.\n//. ```javascript\n//. const S = window.sanctuary;\n//. const $ = window.sanctuaryDef;\n//. // ...\n//. ```\n//.\n//. ## API\n\n(f => {\n\n  'use strict';\n\n  /* c8 ignore start */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f (require ('sanctuary-def'),\n                        require ('sanctuary-either'),\n                        require ('sanctuary-maybe'),\n                        require ('sanctuary-pair'),\n                        require ('sanctuary-show'),\n                        require ('sanctuary-type-classes'),\n                        require ('sanctuary-type-identifiers'));\n  } else if (typeof define === 'function' && define.amd != null) {\n    define (['sanctuary-def',\n             'sanctuary-either',\n             'sanctuary-maybe',\n             'sanctuary-pair',\n             'sanctuary-show',\n             'sanctuary-type-classes',\n             'sanctuary-type-identifiers'],\n            f);\n  } else {\n    self.sanctuary = f (self.sanctuaryDef,\n                        self.sanctuaryEither,\n                        self.sanctuaryMaybe,\n                        self.sanctuaryPair,\n                        self.sanctuaryShow,\n                        self.sanctuaryTypeClasses,\n                        self.sanctuaryTypeIdentifiers);\n  }\n  /* c8 ignore end */\n\n}) (($, Either, Maybe, Pair, show, Z, type) => {\n\n  'use strict';\n\n  const {\n    Left,\n    Right,\n  } = Either;\n\n  const {\n    Nothing,\n    Just,\n  } = Maybe;\n\n  const {\n    fst,\n    snd,\n    swap,\n  } = Pair;\n\n  let Descending, Nil, Cons, Sum, S;\n  if (typeof __doctest !== 'undefined') {\n    const dirname = __dirname;  // eslint-disable-line no-undef\n    const {create, env} = __doctest.require (dirname);\n    const List = __doctest.require (`${dirname}/test/internal/List.cjs`);\n    Descending = __doctest.require ('sanctuary-descending');\n    ({Nil, Cons} = List);\n    Sum = __doctest.require (`${dirname}/test/internal/Sum.cjs`);\n    S = Object.assign (\n      create ({\n        checkTypes: true,\n        env: env.concat ([List.Type ($.Unknown), Sum.Type]),\n      }),\n      {env}  // see S.env doctest\n    );\n    [Descending, Nil, Cons, Sum, S];  // referenced in doctests\n  }\n\n  const curry2 = f => a => b => f (a, b);\n  const curry3 = f => a => b => c => f (a, b, c);\n  const curry4 = f => a => b => c => d => f (a, b, c, d);\n\n  //  invoke0 :: String -> a -> b\n  const invoke0 = name => target => target[name] ();\n\n  //  invoke1 :: String -> a -> b -> c\n  const invoke1 = name => x => target => target[name] (x);\n\n  //  :: Type\n  const a = $.TypeVariable ('a');\n  const b = $.TypeVariable ('b');\n  const c = $.TypeVariable ('c');\n  const d = $.TypeVariable ('d');\n  const e = $.TypeVariable ('e');\n  const g = $.TypeVariable ('g');\n\n  //  :: Type -> Type\n  const f = $.UnaryTypeVariable ('f');\n  const m = $.UnaryTypeVariable ('m');\n  const t = $.UnaryTypeVariable ('t');\n  const w = $.UnaryTypeVariable ('w');\n\n  //  :: Type -> Type -> Type\n  const p = $.BinaryTypeVariable ('p');\n  const s = $.BinaryTypeVariable ('s');\n\n  //  Throwing :: Type -> Type -> Type -> Type\n  //\n  //  `Throwing e a b` is the type of functions from `a` to `b` that may\n  //  throw values of type `e`.\n  const Throwing = E => A => B => {\n    const T = $.Fn (A) (B);\n    T.format = (outer, inner) => (\n      outer ('Throwing ' + show (E)) +\n      outer (' ') + inner ('$1') (show (A)) +\n      outer (' ') + inner ('$2') (show (B))\n    );\n    return T;\n  };\n\n  //  TypeRep :: Type -> Type\n  const TypeRep = $.UnaryType\n    ('TypeRep')\n    ('https://github.com/fantasyland/fantasy-land#type-representatives')\n    ([])\n    (_ => true)\n    (_ => []);\n\n  //  Options :: Type\n  const Options = $.RecordType ({checkTypes: $.Boolean, env: $.Array ($.Any)});\n\n  const _ = {};\n\n  //. ### Configure\n\n  //# create :: { checkTypes :: Boolean, env :: Array Type } -> Module\n  //.\n  //. Takes an options record and returns a Sanctuary module. `checkTypes`\n  //. specifies whether to enable type checking. The module's polymorphic\n  //. functions (such as [`I`](#I)) require each value associated with a\n  //. type variable to be a member of at least one type in the environment.\n  //.\n  //. A well-typed application of a Sanctuary function will produce the same\n  //. result regardless of whether type checking is enabled. If type checking\n  //. is enabled, a badly typed application will produce an exception with a\n  //. descriptive error message.\n  //.\n  //. The following snippet demonstrates defining a custom type and using\n  //. `create` to produce a Sanctuary module that is aware of that type:\n  //.\n  //. ```javascript\n  //. const {create, env} = require ('sanctuary');\n  //. const $ = require ('sanctuary-def');\n  //. const type = require ('sanctuary-type-identifiers');\n  //.\n  //. //    Identity :: a -> Identity a\n  //. const Identity = x => {\n  //.   const identity = Object.create (Identity$prototype);\n  //.   identity.value = x;\n  //.   return identity;\n  //. };\n  //.\n  //. //    identityTypeIdent :: String\n  //. const identityTypeIdent = 'my-package/Identity@1';\n  //.\n  //. const Identity$prototype = {\n  //.   '@@type': identityTypeIdent,\n  //.   '@@show': function() { return `Identity (${S.show (this.value)})`; },\n  //.   'fantasy-land/map': function(f) { return Identity (f (this.value)); },\n  //. };\n  //.\n  //. //    IdentityType :: Type -> Type\n  //. const IdentityType = $.UnaryType\n  //.   ('Identity')\n  //.   ('http://example.com/my-package#Identity')\n  //.   ([])\n  //.   (x => type (x) === identityTypeIdent)\n  //.   (identity => [identity.value]);\n  //.\n  //. const S = create ({\n  //.   checkTypes: process.env.NODE_ENV !== 'production',\n  //.   env: env.concat ([IdentityType ($.Unknown)]),\n  //. });\n  //.\n  //. S.map (S.sub (1)) (Identity (43));\n  //. // => Identity (42)\n  //. ```\n  //.\n  //. See also [`env`](#env).\n  const create = ({checkTypes, env}) => {\n    const def = $.create ({checkTypes, env});\n    const S = {};\n    for (const [name, {consts, types, impl}] of Object.entries (_)) {\n      S[name] = def (name) (consts) (types) (impl);\n    }\n    S.env = env;\n    S.is = def ('is') ({}) ([$.Type, $.Any, $.Boolean]) ($.test (env));\n    S.Maybe = Maybe;\n    S.Nothing = Nothing;\n    S.Either = Either;\n    S.unchecked = checkTypes ? create ({checkTypes: false, env}) : S;\n    return S;\n  };\n  _.create = {\n    consts: {},\n    types: [Options, $.Object],\n    impl: create,\n  };\n\n  //# env :: Array Type\n  //.\n  //. The Sanctuary module's environment (`(S.create ({checkTypes, env})).env`\n  //. is a reference to `env`). Useful in conjunction with [`create`](#create).\n  //.\n  //. ```javascript\n  //. > S.env\n  //. [ $.AnyFunction,\n  //. . $.Arguments,\n  //. . $.Array ($.Unknown),\n  //. . $.Array2 ($.Unknown) ($.Unknown),\n  //. . $.Boolean,\n  //. . $.Buffer,\n  //. . $.Date,\n  //. . $.Descending ($.Unknown),\n  //. . $.Either ($.Unknown) ($.Unknown),\n  //. . $.Error,\n  //. . $.Fn ($.Unknown) ($.Unknown),\n  //. . $.HtmlElement,\n  //. . $.Identity ($.Unknown),\n  //. . $.JsMap ($.Unknown) ($.Unknown),\n  //. . $.JsSet ($.Unknown),\n  //. . $.Maybe ($.Unknown),\n  //. . $.Module,\n  //. . $.Null,\n  //. . $.Number,\n  //. . $.Object,\n  //. . $.Pair ($.Unknown) ($.Unknown),\n  //. . $.RegExp,\n  //. . $.StrMap ($.Unknown),\n  //. . $.String,\n  //. . $.Symbol,\n  //. . $.Type,\n  //. . $.TypeClass,\n  //. . $.Undefined ]\n  //. ```\n\n  //# unchecked :: Module\n  //.\n  //. A complete Sanctuary module that performs no type checking. This is\n  //. useful as it permits operations that Sanctuary's type checking would\n  //. disallow, such as mapping over an object with heterogeneous values.\n  //.\n  //. See also [`create`](#create).\n  //.\n  //. ```javascript\n  //. > S.unchecked.map (S.show) ({x: 'foo', y: true, z: 42})\n  //. {x: '\"foo\"', y: 'true', z: '42'}\n  //. ```\n  //.\n  //. Opting out of type checking may cause type errors to go unnoticed.\n  //.\n  //. ```javascript\n  //. > S.unchecked.add (2) ('2')\n  //. '22'\n  //. ```\n\n  //. ### Classify\n\n  //# type :: Any -> { namespace :: Maybe String, name :: String, version :: NonNegativeInteger }\n  //.\n  //. Returns the result of parsing the [type identifier][] of the given value.\n  //.\n  //. ```javascript\n  //. > S.type (S.Just (42))\n  //. {namespace: Just ('sanctuary-maybe'), name: 'Maybe', version: 1}\n  //.\n  //. > S.type ([1, 2, 3])\n  //. {namespace: Nothing, name: 'Array', version: 0}\n  //. ```\n  const type_ = x => {\n    const {\n      namespace,\n      name,\n      version,\n    } = type.parse (type (x));\n    return {\n      namespace: namespace == null ? Nothing : Just (namespace),\n      name,\n      version,\n    };\n  };\n  _.type = {\n    consts: {},\n    types: [$.Any,\n            $.RecordType ({namespace: $.Maybe ($.String),\n                           name: $.String,\n                           version: $.NonNegativeInteger})],\n    impl: type_,\n  };\n\n  //# is :: Type -> Any -> Boolean\n  //.\n  //. Returns `true` [iff][] the given value is a member of the specified type.\n  //. See [`$.test`][] for details.\n  //.\n  //. ```javascript\n  //. > S.is ($.Array ($.Integer)) ([1, 2, 3])\n  //. true\n  //.\n  //. > S.is ($.Array ($.Integer)) ([1, 2, 3.14])\n  //. false\n  //. ```\n\n  //. ### Showable\n\n  //# show :: Any -> String\n  //.\n  //. Alias of [`show`][].\n  //.\n  //. ```javascript\n  //. > S.show (-0)\n  //. '-0'\n  //.\n  //. > S.show (['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > S.show ({x: 1, y: 2, z: 3})\n  //. '{\"x\": 1, \"y\": 2, \"z\": 3}'\n  //.\n  //. > S.show (S.Left (S.Right (S.Just (S.Nothing))))\n  //. 'Left (Right (Just (Nothing)))'\n  //. ```\n  _.show = {\n    consts: {},\n    types: [$.Any, $.String],\n    impl: show,\n  };\n\n  //. ### Fantasy Land\n  //.\n  //. Sanctuary is compatible with the [Fantasy Land][] specification.\n\n  //# equals :: Setoid a => a -> a -> Boolean\n  //.\n  //. Curried version of [`Z.equals`][] that requires two arguments of the\n  //. same type.\n  //.\n  //. To compare values of different types first use [`create`](#create) to\n  //. create a Sanctuary module with type checking disabled, then use that\n  //. module's `equals` function.\n  //.\n  //. ```javascript\n  //. > S.equals (0) (-0)\n  //. true\n  //.\n  //. > S.equals (NaN) (NaN)\n  //. true\n  //.\n  //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 4]))\n  //. false\n  //. ```\n  _.equals = {\n    consts: {a: [Z.Setoid]},\n    types: [a, a, $.Boolean],\n    impl: curry2 (Z.equals),\n  };\n\n  //# lt :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than the first\n  //. according to [`Z.lt`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.lt (3)) ([1, 2, 3, 4, 5])\n  //. [1, 2]\n  //. ```\n  const lt = y => x => Z.lt (x, y);\n  _.lt = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: lt,\n  };\n\n  //# lte :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than or equal to\n  //. the first according to [`Z.lte`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.lte (3)) ([1, 2, 3, 4, 5])\n  //. [1, 2, 3]\n  //. ```\n  const lte = y => x => Z.lte (x, y);\n  _.lte = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: lte,\n  };\n\n  //# gt :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than the first\n  //. according to [`Z.gt`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.gt (3)) ([1, 2, 3, 4, 5])\n  //. [4, 5]\n  //. ```\n  const gt = y => x => Z.gt (x, y);\n  _.gt = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: gt,\n  };\n\n  //# gte :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than or equal\n  //. to the first according to [`Z.gte`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.gte (3)) ([1, 2, 3, 4, 5])\n  //. [3, 4, 5]\n  //. ```\n  const gte = y => x => Z.gte (x, y);\n  _.gte = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: gte,\n  };\n\n  //# min :: Ord a => a -> a -> a\n  //.\n  //. Returns the smaller of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > S.min (10) (2)\n  //. 2\n  //.\n  //. > S.min (new Date ('1999-12-31')) (new Date ('2000-01-01'))\n  //. new Date ('1999-12-31')\n  //.\n  //. > S.min ('10') ('2')\n  //. '10'\n  //. ```\n  _.min = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, a],\n    impl: curry2 (Z.min),\n  };\n\n  //# max :: Ord a => a -> a -> a\n  //.\n  //. Returns the larger of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > S.max (10) (2)\n  //. 10\n  //.\n  //. > S.max (new Date ('1999-12-31')) (new Date ('2000-01-01'))\n  //. new Date ('2000-01-01')\n  //.\n  //. > S.max ('10') ('2')\n  //. '2'\n  //. ```\n  _.max = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, a],\n    impl: curry2 (Z.max),\n  };\n\n  //# clamp :: Ord a => a -> a -> a -> a\n  //.\n  //. Takes a lower bound, an upper bound, and a value of the same type.\n  //. Returns the value if it is within the bounds; the nearer bound otherwise.\n  //.\n  //. See also [`min`](#min) and [`max`](#max).\n  //.\n  //. ```javascript\n  //. > S.clamp (0) (100) (42)\n  //. 42\n  //.\n  //. > S.clamp (0) (100) (-1)\n  //. 0\n  //.\n  //. > S.clamp ('A') ('Z') ('~')\n  //. 'Z'\n  //. ```\n  _.clamp = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, a, a],\n    impl: curry3 (Z.clamp),\n  };\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.id`][].\n  //.\n  //. ```javascript\n  //. > S.id (Function) (42)\n  //. 42\n  //. ```\n  _.id = {\n    consts: {c: [Z.Category]},\n    types: [TypeRep (c), c],\n    impl: Z.id,\n  };\n\n  //# concat :: Semigroup a => a -> a -> a\n  //.\n  //. Curried version of [`Z.concat`][].\n  //.\n  //. ```javascript\n  //. > S.concat ('abc') ('def')\n  //. 'abcdef'\n  //.\n  //. > S.concat ([1, 2, 3]) ([4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > S.concat ({x: 1, y: 2}) ({y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > S.concat (S.Just ([1, 2, 3])) (S.Just ([4, 5, 6]))\n  //. Just ([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat (Sum (18)) (Sum (24))\n  //. Sum (42)\n  //. ```\n  _.concat = {\n    consts: {a: [Z.Semigroup]},\n    types: [a, a, a],\n    impl: curry2 (Z.concat),\n  };\n\n  //# empty :: Monoid a => TypeRep a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.empty`][].\n  //.\n  //. ```javascript\n  //. > S.empty (String)\n  //. ''\n  //.\n  //. > S.empty (Array)\n  //. []\n  //.\n  //. > S.empty (Object)\n  //. {}\n  //.\n  //. > S.empty (Sum)\n  //. Sum (0)\n  //. ```\n  _.empty = {\n    consts: {a: [Z.Monoid]},\n    types: [TypeRep (a), a],\n    impl: Z.empty,\n  };\n\n  //# invert :: Group g => g -> g\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.invert`][].\n  //.\n  //. ```javascript\n  //. > S.invert (Sum (5))\n  //. Sum (-5)\n  //. ```\n  _.invert = {\n    consts: {g: [Z.Group]},\n    types: [g, g],\n    impl: Z.invert,\n  };\n\n  //# filter :: Filterable f => (a -> Boolean) -> f a -> f a\n  //.\n  //. Curried version of [`Z.filter`][]. Discards every element that does not\n  //. satisfy the predicate.\n  //.\n  //. See also [`reject`](#reject).\n  //.\n  //. ```javascript\n  //. > S.filter (S.odd) ([1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > S.filter (S.odd) ({x: 1, y: 2, z: 3})\n  //. {x: 1, z: 3}\n  //.\n  //. > S.filter (S.odd) (S.Nothing)\n  //. Nothing\n  //.\n  //. > S.filter (S.odd) (S.Just (0))\n  //. Nothing\n  //.\n  //. > S.filter (S.odd) (S.Just (1))\n  //. Just (1)\n  //. ```\n  _.filter = {\n    consts: {f: [Z.Filterable]},\n    types: [$.Predicate (a), f (a), f (a)],\n    impl: curry2 (Z.filter),\n  };\n\n  //# reject :: Filterable f => (a -> Boolean) -> f a -> f a\n  //.\n  //. Curried version of [`Z.reject`][]. Discards every element that satisfies\n  //. the predicate.\n  //.\n  //. See also [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > S.reject (S.odd) ([1, 2, 3])\n  //. [2]\n  //.\n  //. > S.reject (S.odd) ({x: 1, y: 2, z: 3})\n  //. {y: 2}\n  //.\n  //. > S.reject (S.odd) (S.Nothing)\n  //. Nothing\n  //.\n  //. > S.reject (S.odd) (S.Just (0))\n  //. Just (0)\n  //.\n  //. > S.reject (S.odd) (S.Just (1))\n  //. Nothing\n  //. ```\n  _.reject = {\n    consts: {f: [Z.Filterable]},\n    types: [$.Predicate (a), f (a), f (a)],\n    impl: curry2 (Z.reject),\n  };\n\n  //# map :: Functor f => (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.map`][].\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) ([1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > S.map (Math.sqrt) ({x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > S.map (Math.sqrt) (S.Just (9))\n  //. Just (3)\n  //.\n  //. > S.map (Math.sqrt) (S.Right (9))\n  //. Right (3)\n  //.\n  //. > S.map (Math.sqrt) (S.Pair (99980001) (99980001))\n  //. Pair (99980001) (9999)\n  //. ```\n  //.\n  //. Replacing `Functor f => f` with `Function x` produces the B combinator\n  //. from combinatory logic (i.e. [`compose`](#compose)):\n  //.\n  //.     Functor f => (a -> b) -> f a -> f b\n  //.     (a -> b) -> Function x a -> Function x b\n  //.     (a -> b) -> (x -> a) -> (x -> b)\n  //.     (a -> b) -> (x -> a) -> x -> b\n  //.     (b -> c) -> (a -> b) -> a -> c\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) (S.add (1)) (99)\n  //. 10\n  //. ```\n  _.map = {\n    consts: {f: [Z.Functor]},\n    types: [$.Fn (a) (b), f (a), f (b)],\n    impl: curry2 (Z.map),\n  };\n\n  //# flip :: Functor f => f (a -> b) -> a -> f b\n  //.\n  //. Curried version of [`Z.flip`][]. Maps over the given functions, applying\n  //. each to the given value.\n  //.\n  //. Replacing `Functor f => f` with `Function x` produces the C combinator\n  //. from combinatory logic:\n  //.\n  //.     Functor f => f (a -> b) -> a -> f b\n  //.     Function x (a -> b) -> a -> Function x b\n  //.     (x -> (a -> b)) -> a -> (x -> b)\n  //.     (x -> a -> b) -> a -> x -> b\n  //.     (a -> b -> c) -> b -> a -> c\n  //.\n  //. ```javascript\n  //. > S.flip (S.concat) ('!') ('foo')\n  //. 'foo!'\n  //.\n  //. > S.flip ([Math.floor, Math.ceil]) (1.5)\n  //. [1, 2]\n  //.\n  //. > S.flip ({floor: Math.floor, ceil: Math.ceil}) (1.5)\n  //. {floor: 1, ceil: 2}\n  //.\n  //. > S.flip (Cons (Math.floor) (Cons (Math.ceil) (Nil))) (1.5)\n  //. Cons (1) (Cons (2) (Nil))\n  //. ```\n  _.flip = {\n    consts: {f: [Z.Functor]},\n    types: [f ($.Fn (a) (b)), a, f (b)],\n    impl: curry2 (Z.flip),\n  };\n\n  //# bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a c -> f b d\n  //.\n  //. Curried version of [`Z.bimap`][].\n  //.\n  //. ```javascript\n  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Pair ('foo') (64))\n  //. Pair ('FOO') (8)\n  //.\n  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Left ('foo'))\n  //. Left ('FOO')\n  //.\n  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Right (64))\n  //. Right (8)\n  //. ```\n  _.bimap = {\n    consts: {p: [Z.Bifunctor]},\n    types: [$.Fn (a) (b), $.Fn (c) (d), p (a) (c), p (b) (d)],\n    impl: curry3 (Z.bimap),\n  };\n\n  //# mapLeft :: Bifunctor f => (a -> b) -> f a c -> f b c\n  //.\n  //. Curried version of [`Z.mapLeft`][]. Maps the given function over the left\n  //. side of a Bifunctor.\n  //.\n  //. ```javascript\n  //. > S.mapLeft (S.toUpper) (S.Pair ('foo') (64))\n  //. Pair ('FOO') (64)\n  //.\n  //. > S.mapLeft (S.toUpper) (S.Left ('foo'))\n  //. Left ('FOO')\n  //.\n  //. > S.mapLeft (S.toUpper) (S.Right (64))\n  //. Right (64)\n  //. ```\n  _.mapLeft = {\n    consts: {p: [Z.Bifunctor]},\n    types: [$.Fn (a) (b), p (a) (c), p (b) (c)],\n    impl: curry2 (Z.mapLeft),\n  };\n\n  //# promap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d\n  //.\n  //. Curried version of [`Z.promap`][].\n  //.\n  //. ```javascript\n  //. > S.promap (Math.abs) (S.add (1)) (Math.sqrt) (-100)\n  //. 11\n  //. ```\n  _.promap = {\n    consts: {p: [Z.Profunctor]},\n    types: [$.Fn (a) (b), $.Fn (c) (d), p (b) (c), p (a) (d)],\n    impl: curry3 (Z.promap),\n  };\n\n  //# alt :: Alt f => f a -> f a -> f a\n  //.\n  //. Curried version of [`Z.alt`][] with arguments flipped to facilitate\n  //. partial application.\n  //.\n  //. ```javascript\n  //. > S.alt (S.Just ('default')) (S.Nothing)\n  //. Just ('default')\n  //.\n  //. > S.alt (S.Just ('default')) (S.Just ('hello'))\n  //. Just ('hello')\n  //.\n  //. > S.alt (S.Right (0)) (S.Left ('X'))\n  //. Right (0)\n  //.\n  //. > S.alt (S.Right (0)) (S.Right (1))\n  //. Right (1)\n  //. ```\n  const alt = y => x => Z.alt (x, y);\n  _.alt = {\n    consts: {f: [Z.Alt]},\n    types: [f (a), f (a), f (a)],\n    impl: alt,\n  };\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.zero`][].\n  //.\n  //. ```javascript\n  //. > S.zero (Array)\n  //. []\n  //.\n  //. > S.zero (Object)\n  //. {}\n  //.\n  //. > S.zero (S.Maybe)\n  //. Nothing\n  //. ```\n  _.zero = {\n    consts: {f: [Z.Plus]},\n    types: [TypeRep (f (a)), f (a)],\n    impl: Z.zero,\n  };\n\n  //# reduce :: Foldable f => (b -> a -> b) -> b -> f a -> b\n  //.\n  //. Takes a curried binary function, an initial value, and a [Foldable][],\n  //. and applies the function to the initial value and the Foldable's first\n  //. value, then applies the function to the result of the previous\n  //. application and the Foldable's second value. Repeats this process\n  //. until each of the Foldable's values has been used. Returns the initial\n  //. value if the Foldable is empty; the result of the final application\n  //. otherwise.\n  //.\n  //. See also [`reduce_`](#reduce_).\n  //.\n  //. ```javascript\n  //. > S.reduce (S.add) (0) ([1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.reduce (xs => x => S.prepend (x) (xs)) ([]) ([1, 2, 3, 4, 5])\n  //. [5, 4, 3, 2, 1]\n  //. ```\n  const reduce = f => initial => foldable => (\n    Z.reduce ((y, x) => f (y) (x), initial, foldable)\n  );\n  _.reduce = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Fn (b) ($.Fn (a) (b)), b, f (a), b],\n    impl: reduce,\n  };\n\n  //# reduce_ :: Foldable f => (a -> b -> b) -> b -> f a -> b\n  //.\n  //. Variant of [`reduce`](#reduce) that takes a reducing function with\n  //. arguments flipped.\n  //.\n  //. ```javascript\n  //. > S.reduce_ (S.append) ([]) (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. [1, 2, 3]\n  //.\n  //. > S.reduce_ (S.prepend) ([]) (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. [3, 2, 1]\n  //. ```\n  const reduce_ = f => initial => foldable => (\n    Z.reduce ((y, x) => f (x) (y), initial, foldable)\n  );\n  _.reduce_ = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Fn (a) ($.Fn (b) (b)), b, f (a), b],\n    impl: reduce_,\n  };\n\n  //# traverse :: (Applicative f, Traversable t) => TypeRep f -> (a -> f b) -> t a -> f (t b)\n  //.\n  //. Curried version of [`Z.traverse`][].\n  //.\n  //. ```javascript\n  //. > S.traverse (Array) (S.words) (S.Just ('foo bar baz'))\n  //. [Just ('foo'), Just ('bar'), Just ('baz')]\n  //.\n  //. > S.traverse (Array) (S.words) (S.Nothing)\n  //. [Nothing]\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C'])\n  //. Just ([10, 11, 12])\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C', 'X'])\n  //. Nothing\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C'})\n  //. Just ({a: 10, b: 11, c: 12})\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C', x: 'X'})\n  //. Nothing\n  //. ```\n  _.traverse = {\n    consts: {f: [Z.Applicative], t: [Z.Traversable]},\n    types: [TypeRep (f (b)), $.Fn (a) (f (b)), t (a), f (t (b))],\n    impl: curry3 (Z.traverse),\n  };\n\n  //# sequence :: (Applicative f, Traversable t) => TypeRep f -> t (f a) -> f (t a)\n  //.\n  //. Curried version of [`Z.sequence`][]. Inverts the given `t (f a)`\n  //. to produce an `f (t a)`.\n  //.\n  //. ```javascript\n  //. > S.sequence (Array) (S.Just ([1, 2, 3]))\n  //. [Just (1), Just (2), Just (3)]\n  //.\n  //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Just (3)])\n  //. Just ([1, 2, 3])\n  //.\n  //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Nothing])\n  //. Nothing\n  //.\n  //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Just (3)})\n  //. Just ({a: 1, b: 2, c: 3})\n  //.\n  //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Nothing})\n  //. Nothing\n  //. ```\n  _.sequence = {\n    consts: {f: [Z.Applicative], t: [Z.Traversable]},\n    types: [TypeRep (f (a)), t (f (a)), f (t (a))],\n    impl: curry2 (Z.sequence),\n  };\n\n  //# ap :: Apply f => f (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.ap`][].\n  //.\n  //. ```javascript\n  //. > S.ap ([Math.sqrt, x => x * x]) ([1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > S.ap ({x: Math.sqrt, y: S.add (1), z: S.sub (1)}) ({w: 4, x: 4, y: 4})\n  //. {x: 2, y: 5}\n  //.\n  //. > S.ap (S.Just (Math.sqrt)) (S.Just (64))\n  //. Just (8)\n  //. ```\n  //.\n  //. Replacing `Apply f => f` with `Function x` produces the S combinator\n  //. from combinatory logic:\n  //.\n  //.     Apply f => f (a -> b) -> f a -> f b\n  //.     Function x (a -> b) -> Function x a -> Function x b\n  //.     (x -> (a -> b)) -> (x -> a) -> (x -> b)\n  //.     (x -> a -> b) -> (x -> a) -> x -> b\n  //.     (a -> b -> c) -> (a -> b) -> a -> c\n  //.\n  //. ```javascript\n  //. > S.ap (s => n => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('Haskell')\n  //. 'Hask'\n  //. ```\n  _.ap = {\n    consts: {f: [Z.Apply]},\n    types: [f ($.Fn (a) (b)), f (a), f (b)],\n    impl: curry2 (Z.ap),\n  };\n\n  //# lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c\n  //.\n  //. Promotes a curried binary function to a function that operates on two\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift2 (S.add) (S.Just (2)) (S.Just (3))\n  //. Just (5)\n  //.\n  //. > S.lift2 (S.add) (S.Just (2)) (S.Nothing)\n  //. Nothing\n  //.\n  //. > S.lift2 (S.and) (S.Just (true)) (S.Just (true))\n  //. Just (true)\n  //.\n  //. > S.lift2 (S.and) (S.Just (true)) (S.Just (false))\n  //. Just (false)\n  //. ```\n  //.\n  //. Replacing `Apply f => f` with `Function x` produces a combinator known\n  //. by various names including [`apply2way`][] and [`converge`][]:\n  //.\n  //.     Apply f => (a -> b -> c) -> f a -> f b -> f c\n  //.     (a -> b -> c) -> Function x a -> Function x b -> Function x c\n  //.     (a -> b -> c) -> (x -> a) -> (x -> b) -> (x -> c)\n  //.     (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c\n  //.     (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\n  //.\n  //. ```javascript\n  //. > S.lift2 (x => y => ({x, y}))\n  //. .         (s => s + '.')\n  //. .         (s => s + '?')\n  //. .         ('Hello')\n  //. {x: 'Hello.', y: 'Hello?'}\n  //. ```\n  _.lift2 = {\n    consts: {f: [Z.Apply]},\n    types: [$.Fn (a) ($.Fn (b) (c)), f (a), f (b), f (c)],\n    impl: curry3 (Z.lift2),\n  };\n\n  //# lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n  //.\n  //. Promotes a curried ternary function to a function that operates on three\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Just ([1, 2, 3]))\n  //. Just (6)\n  //.\n  //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Nothing)\n  //. Nothing\n  //. ```\n  //.\n  //. Replacing `Apply f => f` with `Function x` produces a combinator that\n  //. applies the three given unary functions to the given input value, then\n  //. applies the given ternary function to the three intermediate results\n  //. to determine the final result:\n  //.\n  //.     Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n  //.     (a -> b -> c -> d) -> Function x a -> Function x b -> Function x c -> Function x d\n  //.     (a -> b -> c -> d) -> (x -> a) -> (x -> b) -> (x -> c) -> (x -> d)\n  //.     (a -> b -> c -> d) -> (x -> a) -> (x -> b) -> (x -> c) -> x -> d\n  //.     (b -> c -> d -> e) -> (a -> b) -> (a -> c) -> (a -> d) -> a -> e\n  //.\n  //. ```javascript\n  //. > S.lift3 (x => y => z => ({x, y, z}))\n  //. .         (s => s + '.')\n  //. .         (s => s + '?')\n  //. .         (s => s + '!')\n  //. .         ('Hello')\n  //. {x: 'Hello.', y: 'Hello?', z: 'Hello!'}\n  //. ```\n  _.lift3 = {\n    consts: {f: [Z.Apply]},\n    types: [$.Fn (a) ($.Fn (b) ($.Fn (c) (d))), f (a), f (b), f (c), f (d)],\n    impl: curry4 (Z.lift3),\n  };\n\n  //# apFirst :: Apply f => f a -> f b -> f a\n  //.\n  //. Curried version of [`Z.apFirst`][]. Combines two effectful actions,\n  //. keeping only the result of the first. Equivalent to Haskell's `(<*)`\n  //. function.\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > S.apFirst ([1, 2]) ([3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > S.apFirst (S.Just (1)) (S.Just (2))\n  //. Just (1)\n  //. ```\n  _.apFirst = {\n    consts: {f: [Z.Apply]},\n    types: [f (a), f (b), f (a)],\n    impl: curry2 (Z.apFirst),\n  };\n\n  //# apSecond :: Apply f => f a -> f b -> f b\n  //.\n  //. Curried version of [`Z.apSecond`][]. Combines two effectful actions,\n  //. keeping only the result of the second. Equivalent to Haskell's `(*>)`\n  //. function.\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > S.apSecond ([1, 2]) ([3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > S.apSecond (S.Just (1)) (S.Just (2))\n  //. Just (2)\n  //. ```\n  _.apSecond = {\n    consts: {f: [Z.Apply]},\n    types: [f (a), f (b), f (b)],\n    impl: curry2 (Z.apSecond),\n  };\n\n  //# of :: Applicative f => TypeRep f -> a -> f a\n  //.\n  //. Curried version of [`Z.of`][].\n  //.\n  //. ```javascript\n  //. > S.of (Array) (42)\n  //. [42]\n  //.\n  //. > S.of (Function) (42) (null)\n  //. 42\n  //.\n  //. > S.of (S.Maybe) (42)\n  //. Just (42)\n  //.\n  //. > S.of (S.Either) (42)\n  //. Right (42)\n  //. ```\n  _.of = {\n    consts: {f: [Z.Applicative]},\n    types: [TypeRep (f (a)), a, f (a)],\n    impl: curry2 (Z.of),\n  };\n\n  //# chain :: Chain m => (a -> m b) -> m a -> m b\n  //.\n  //. Curried version of [`Z.chain`][].\n  //.\n  //. ```javascript\n  //. > S.chain (x => [x, x]) ([1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > S.chain (n => s => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('slice')\n  //. 'sli'\n  //.\n  //. > S.chain (S.parseInt (10)) (S.Just ('123'))\n  //. Just (123)\n  //.\n  //. > S.chain (S.parseInt (10)) (S.Just ('XXX'))\n  //. Nothing\n  //. ```\n  _.chain = {\n    consts: {m: [Z.Chain]},\n    types: [$.Fn (a) (m (b)), m (a), m (b)],\n    impl: curry2 (Z.chain),\n  };\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.join`][].\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. ```javascript\n  //. > S.join ([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > S.join ([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > S.join (S.Just (S.Just (1)))\n  //. Just (1)\n  //.\n  //. > S.join (S.Pair ('foo') (S.Pair ('bar') ('baz')))\n  //. Pair ('foobar') ('baz')\n  //. ```\n  //.\n  //. Replacing `Chain m => m` with `Function x` produces the W combinator\n  //. from combinatory logic:\n  //.\n  //.     Chain m => m (m a) -> m a\n  //.     Function x (Function x a) -> Function x a\n  //.     (x -> (x -> a)) -> (x -> a)\n  //.     (x -> x -> a) -> x -> a\n  //.     (a -> a -> b) -> a -> b\n  //.\n  //. ```javascript\n  //. > S.join (S.concat) ('abc')\n  //. 'abcabc'\n  //. ```\n  _.join = {\n    consts: {m: [Z.Chain]},\n    types: [m (m (a)), m (a)],\n    impl: Z.join,\n  };\n\n  //# chainRec :: ChainRec m => TypeRep m -> (a -> m (Either a b)) -> a -> m b\n  //.\n  //. Performs a [`chain`](#chain)-like computation with constant stack usage.\n  //. Similar to [`Z.chainRec`][], but curried and more convenient due to the\n  //. use of the Either type to indicate completion (via a Right).\n  //.\n  //. ```javascript\n  //. > S.chainRec (Array)\n  //. .            (s => s.length === 2 ? S.map (S.Right) ([s + '!', s + '?'])\n  //. .                                 : S.map (S.Left) ([s + 'o', s + 'n']))\n  //. .            ('')\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  const chainRec = typeRep => f => {\n    const step = (next, done, x) => Z.map (either (next) (done), f (x));\n    return x => Z.chainRec (typeRep, step, x);\n  };\n  _.chainRec = {\n    consts: {m: [Z.ChainRec]},\n    types: [TypeRep (m (b)), $.Fn (a) (m ($.Either (a) (b))), a, m (b)],\n    impl: chainRec,\n  };\n\n  //# extend :: Extend w => (w a -> b) -> w a -> w b\n  //.\n  //. Curried version of [`Z.extend`][].\n  //.\n  //. ```javascript\n  //. > S.extend (S.joinWith ('')) (['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //.\n  //. > S.extend (f => f ([3, 4])) (S.reverse) ([1, 2])\n  //. [4, 3, 2, 1]\n  //. ```\n  _.extend = {\n    consts: {w: [Z.Extend]},\n    types: [$.Fn (w (a)) (b), w (a), w (b)],\n    impl: curry2 (Z.extend),\n  };\n\n  //# duplicate :: Extend w => w a -> w (w a)\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.duplicate`][].\n  //. Adds one level of nesting to a comonadic structure.\n  //.\n  //. ```javascript\n  //. > S.duplicate (S.Just (1))\n  //. Just (Just (1))\n  //.\n  //. > S.duplicate ([1])\n  //. [[1]]\n  //.\n  //. > S.duplicate ([1, 2, 3])\n  //. [[1, 2, 3], [2, 3], [3]]\n  //.\n  //. > S.duplicate (S.reverse) ([1, 2]) ([3, 4])\n  //. [4, 3, 2, 1]\n  //. ```\n  _.duplicate = {\n    consts: {w: [Z.Extend]},\n    types: [w (a), w (w (a))],\n    impl: Z.duplicate,\n  };\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.extract`][].\n  //.\n  //. ```javascript\n  //. > S.extract (S.Pair ('foo') ('bar'))\n  //. 'bar'\n  //. ```\n  _.extract = {\n    consts: {w: [Z.Comonad]},\n    types: [w (a), a],\n    impl: Z.extract,\n  };\n\n  //# contramap :: Contravariant f => (b -> a) -> f a -> f b\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.contramap`][].\n  //.\n  //. ```javascript\n  //. > S.contramap (s => s.length) (Math.sqrt) ('Sanctuary')\n  //. 3\n  //. ```\n  _.contramap = {\n    consts: {f: [Z.Contravariant]},\n    types: [$.Fn (b) (a), f (a), f (b)],\n    impl: curry2 (Z.contramap),\n  };\n\n  //. ### Combinator\n\n  //# I :: a -> a\n  //.\n  //. The I combinator. Returns its argument. Equivalent to Haskell's `id`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.I ('foo')\n  //. 'foo'\n  //. ```\n  const I = x => x;\n  _.I = {\n    consts: {},\n    types: [a, a],\n    impl: I,\n  };\n\n  //# K :: a -> b -> a\n  //.\n  //. The K combinator. Takes two values and returns the first. Equivalent to\n  //. Haskell's `const` function.\n  //.\n  //. ```javascript\n  //. > S.K ('foo') ('bar')\n  //. 'foo'\n  //.\n  //. > S.map (S.K (42)) (S.range (0) (5))\n  //. [42, 42, 42, 42, 42]\n  //. ```\n  const K = x => y => x;\n  _.K = {\n    consts: {},\n    types: [a, b, a],\n    impl: K,\n  };\n\n  //# T :: a -> (a -> b) -> b\n  //.\n  //. The T ([thrush][]) combinator. Takes a value and a function, and returns\n  //. the result of applying the function to the value. Equivalent to Haskell's\n  //. `(&)` function.\n  //.\n  //. ```javascript\n  //. > S.T (42) (S.add (1))\n  //. 43\n  //.\n  //. > S.map (S.T (100)) ([S.add (1), Math.sqrt])\n  //. [101, 10]\n  //. ```\n  const T = x => f => f (x);\n  _.T = {\n    consts: {},\n    types: [a, $.Fn (a) (b), b],\n    impl: T,\n  };\n\n  //. ### Composition\n\n  //# compose :: Semigroupoid s => s b c -> s a b -> s a c\n  //.\n  //. Curried version of [`Z.compose`][].\n  //.\n  //. When specialized to Function, `compose` composes two unary functions,\n  //. from right to left (this is the B combinator from combinatory logic).\n  //.\n  //. The generalized type signature indicates that `compose` is compatible\n  //. with any [Semigroupoid][].\n  //.\n  //. See also [`pipe`](#pipe).\n  //.\n  //. ```javascript\n  //. > S.compose (Math.sqrt) (S.add (1)) (99)\n  //. 10\n  //. ```\n  _.compose = {\n    consts: {s: [Z.Semigroupoid]},\n    types: [s (b) (c), s (a) (b), s (a) (c)],\n    impl: curry2 (Z.compose),\n  };\n\n  //# pipe :: Foldable f => f (Any -> Any) -> a -> b\n  //.\n  //. Takes a sequence of functions assumed to be unary and a value of any\n  //. type, and returns the result of applying the sequence of transformations\n  //. to the initial value.\n  //.\n  //. In general terms, `pipe` performs left-to-right composition of a sequence\n  //. of functions. `pipe ([f, g, h]) (x)` is equivalent to `h (g (f (x)))`.\n  //.\n  //. ```javascript\n  //. > S.pipe ([S.add (1), Math.sqrt, S.sub (1)]) (99)\n  //. 9\n  //. ```\n  const pipe = fs => x => Z.reduce ((x, f) => f (x), x, fs);\n  _.pipe = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.Fn ($.Any) ($.Any)), a, b],\n    impl: pipe,\n  };\n\n  //# pipeK :: (Foldable f, Chain m) => f (Any -> m Any) -> m a -> m b\n  //.\n  //. Takes a sequence of functions assumed to be unary that return values\n  //. with a [Chain][], and a value of that Chain, and returns the result\n  //. of applying the sequence of transformations to the initial value.\n  //.\n  //. In general terms, `pipeK` performs left-to-right [Kleisli][] composition\n  //. of an sequence of functions. `pipeK ([f, g, h]) (x)` is equivalent to\n  //. `chain (h) (chain (g) (chain (f) (x)))`.\n  //.\n  //. ```javascript\n  //. > S.pipeK ([S.tail, S.tail, S.head]) (S.Just ([1, 2, 3, 4]))\n  //. Just (3)\n  //. ```\n  const pipeK = fs => x => Z.reduce ((x, f) => Z.chain (f, x), x, fs);\n  _.pipeK = {\n    consts: {f: [Z.Foldable], m: [Z.Chain]},\n    types: [f ($.Fn ($.Any) (m ($.Any))), m (a), m (b)],\n    impl: pipeK,\n  };\n\n  //# on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\n  //.\n  //. Takes a binary function `f`, a unary function `g`, and two\n  //. values `x` and `y`. Returns `f (g (x)) (g (y))`.\n  //.\n  //. This is the P combinator from combinatory logic.\n  //.\n  //. ```javascript\n  //. > S.on (S.concat) (S.reverse) ([1, 2, 3]) ([4, 5, 6])\n  //. [3, 2, 1, 6, 5, 4]\n  //. ```\n  const on = f => g => x => y => f (g (x)) (g (y));\n  _.on = {\n    consts: {},\n    types: [$.Fn (b) ($.Fn (b) (c)), $.Fn (a) (b), a, a, c],\n    impl: on,\n  };\n\n  //. ### Pair\n  //.\n  //. Pair is the canonical product type: a value of type `Pair a b` always\n  //. contains exactly two values: one of type `a`; one of type `b`.\n  //.\n  //. The implementation is provided by [sanctuary-pair][].\n\n  //# Pair :: a -> b -> Pair a b\n  //.\n  //. Pair's sole data constructor. Additionally, it serves as the\n  //. Pair [type representative][].\n  //.\n  //. ```javascript\n  //. > S.Pair ('foo') (42)\n  //. Pair ('foo') (42)\n  //. ```\n  _.Pair = {\n    consts: {},\n    types: [a, b, $.Pair (a) (b)],\n    impl: Pair,\n  };\n\n  //# pair :: (a -> b -> c) -> Pair a b -> c\n  //.\n  //. Case analysis for the `Pair a b` type.\n  //.\n  //. ```javascript\n  //. > S.pair (S.concat) (S.Pair ('foo') ('bar'))\n  //. 'foobar'\n  //. ```\n  const pair = pair => ([fst, snd]) => pair (fst) (snd);\n  _.pair = {\n    consts: {},\n    types: [$.Fn (a) ($.Fn (b) (c)), $.Pair (a) (b), c],\n    impl: pair,\n  };\n\n  //# fst :: Pair a b -> a\n  //.\n  //. `fst (Pair (x) (y))` is equivalent to `x`.\n  //.\n  //. ```javascript\n  //. > S.fst (S.Pair ('foo') (42))\n  //. 'foo'\n  //. ```\n  _.fst = {\n    consts: {},\n    types: [$.Pair (a) (b), a],\n    impl: fst,\n  };\n\n  //# snd :: Pair a b -> b\n  //.\n  //. `snd (Pair (x) (y))` is equivalent to `y`.\n  //.\n  //. ```javascript\n  //. > S.snd (S.Pair ('foo') (42))\n  //. 42\n  //. ```\n  _.snd = {\n    consts: {},\n    types: [$.Pair (a) (b), b],\n    impl: snd,\n  };\n\n  //# swap :: Pair a b -> Pair b a\n  //.\n  //. `swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.\n  //.\n  //. ```javascript\n  //. > S.swap (S.Pair ('foo') (42))\n  //. Pair (42) ('foo')\n  //. ```\n  _.swap = {\n    consts: {},\n    types: [$.Pair (a) (b), $.Pair (b) (a)],\n    impl: swap,\n  };\n\n  //. ### Maybe\n  //.\n  //. The Maybe type represents optional values: a value of type `Maybe a` is\n  //. either Nothing (the empty value) or a Just whose value is of type `a`.\n  //.\n  //. The implementation is provided by [sanctuary-maybe][].\n\n  //# Maybe :: TypeRep Maybe\n  //.\n  //. Maybe [type representative][].\n\n  //# Nothing :: Maybe a\n  //.\n  //. The empty value of type `Maybe a`.\n  //.\n  //. ```javascript\n  //. > S.Nothing\n  //. Nothing\n  //. ```\n\n  //# Just :: a -> Maybe a\n  //.\n  //. Constructs a value of type `Maybe a` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > S.Just (42)\n  //. Just (42)\n  //. ```\n  _.Just = {\n    consts: {},\n    types: [a, $.Maybe (a)],\n    impl: Just,\n  };\n\n  //# isNothing :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is Nothing; `false` if it is a Just.\n  //.\n  //. ```javascript\n  //. > S.isNothing (S.Nothing)\n  //. true\n  //.\n  //. > S.isNothing (S.Just (42))\n  //. false\n  //. ```\n  const isNothing = maybe => maybe.isNothing;\n  _.isNothing = {\n    consts: {},\n    types: [$.Maybe (a), $.Boolean],\n    impl: isNothing,\n  };\n\n  //# isJust :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is a Just; `false` if it is Nothing.\n  //.\n  //. ```javascript\n  //. > S.isJust (S.Just (42))\n  //. true\n  //.\n  //. > S.isJust (S.Nothing)\n  //. false\n  //. ```\n  const isJust = maybe => maybe.isJust;\n  _.isJust = {\n    consts: {},\n    types: [$.Maybe (a), $.Boolean],\n    impl: isJust,\n  };\n\n  //# maybe :: b -> (a -> b) -> Maybe a -> b\n  //.\n  //. Takes a value of any type, a function, and a Maybe. If the Maybe is\n  //. a Just, the return value is the result of applying the function to\n  //. the Just's value. Otherwise, the first argument is returned.\n  //.\n  //. See also [`maybe_`](#maybe_) and [`fromMaybe`](#fromMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybe (0) (S.prop ('length')) (S.Just ('refuge'))\n  //. 6\n  //.\n  //. > S.maybe (0) (S.prop ('length')) (S.Nothing)\n  //. 0\n  //. ```\n  const maybe = nothing => just => maybe => (\n    maybe.isJust ? just (maybe.value) : nothing\n  );\n  _.maybe = {\n    consts: {},\n    types: [b, $.Fn (a) (b), $.Maybe (a), b],\n    impl: maybe,\n  };\n\n  //# maybe_ :: (() -> b) -> (a -> b) -> Maybe a -> b\n  //.\n  //. Variant of [`maybe`](#maybe) that takes a thunk so the default value\n  //. is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }\n  //.\n  //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Just (1000000))\n  //. 1000\n  //.\n  //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Nothing)\n  //. 832040\n  //. ```\n  const maybe_ = nothing => just => maybe => (\n    maybe.isJust ? just (maybe.value) : nothing ()\n  );\n  _.maybe_ = {\n    consts: {},\n    types: [$.Thunk (b), $.Fn (a) (b), $.Maybe (a), b],\n    impl: maybe_,\n  };\n\n  //# fromMaybe :: a -> Maybe a -> a\n  //.\n  //. Takes a default value and a Maybe, and returns the Maybe's value\n  //. if the Maybe is a Just; the default value otherwise.\n  //.\n  //. See also [`maybe`](#maybe), [`fromMaybe_`](#fromMaybe_), and\n  //. [`maybeToNullable`](#maybeToNullable).\n  //.\n  //. ```javascript\n  //. > S.fromMaybe (0) (S.Just (42))\n  //. 42\n  //.\n  //. > S.fromMaybe (0) (S.Nothing)\n  //. 0\n  //. ```\n  const fromMaybe = nothing => maybe => (\n    maybe.isJust ? maybe.value : nothing\n  );\n  _.fromMaybe = {\n    consts: {},\n    types: [a, $.Maybe (a), a],\n    impl: fromMaybe,\n  };\n\n  //# fromMaybe_ :: (() -> a) -> Maybe a -> a\n  //.\n  //. Variant of [`fromMaybe`](#fromMaybe) that takes a thunk so the default\n  //. value is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }\n  //.\n  //. > S.fromMaybe_ (() => fib (30)) (S.Just (1000000))\n  //. 1000000\n  //.\n  //. > S.fromMaybe_ (() => fib (30)) (S.Nothing)\n  //. 832040\n  //. ```\n  const fromMaybe_ = nothing => maybe => (\n    maybe.isJust ? maybe.value : nothing ()\n  );\n  _.fromMaybe_ = {\n    consts: {},\n    types: [$.Thunk (a), $.Maybe (a), a],\n    impl: fromMaybe_,\n  };\n\n  //# justs :: (Filterable f, Functor f) => f (Maybe a) -> f a\n  //.\n  //. Discards each element that is Nothing, and unwraps each element that is\n  //. a Just. Related to Haskell's `catMaybes` function.\n  //.\n  //. See also [`lefts`](#lefts) and [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.justs ([S.Just ('foo'), S.Nothing, S.Just ('baz')])\n  //. ['foo', 'baz']\n  //. ```\n  const justs = maybes => (\n    Z.map (just => just.value, Z.filter (isJust, maybes))\n  );\n  _.justs = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [f ($.Maybe (a)), f (a)],\n    impl: justs,\n  };\n\n  //# mapMaybe :: (Filterable f, Functor f) => (a -> Maybe b) -> f a -> f b\n  //.\n  //. Takes a function and a structure, applies the function to each element\n  //. of the structure, and returns the \"successful\" results. If the result of\n  //. applying the function to an element is Nothing, the result is discarded;\n  //. if the result is a Just, the Just's value is included.\n  //.\n  //. ```javascript\n  //. > S.mapMaybe (S.head) ([[], [1, 2, 3], [], [4, 5, 6], []])\n  //. [1, 4]\n  //.\n  //. > S.mapMaybe (S.head) ({x: [1, 2, 3], y: [], z: [4, 5, 6]})\n  //. {x: 1, z: 4}\n  //. ```\n  const mapMaybe = f => m => justs (Z.map (f, m));\n  _.mapMaybe = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [$.Fn (a) ($.Maybe (b)), f (a), f (b)],\n    impl: mapMaybe,\n  };\n\n  //# maybeToNullable :: Maybe a -> Nullable a\n  //.\n  //. Returns the given Maybe's value if the Maybe is a Just; `null` otherwise.\n  //. [Nullable][] is defined in [sanctuary-def][].\n  //.\n  //. See also [`fromMaybe`](#fromMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybeToNullable (S.Just (42))\n  //. 42\n  //.\n  //. > S.maybeToNullable (S.Nothing)\n  //. null\n  //. ```\n  const maybeToNullable = maybe => maybe.isJust ? maybe.value : null;\n  _.maybeToNullable = {\n    consts: {},\n    types: [$.Maybe (a), $.Nullable (a)],\n    impl: maybeToNullable,\n  };\n\n  //. ### Either\n  //.\n  //. The Either type represents values with two possibilities: a value of type\n  //. `Either a b` is either a Left whose value is of type `a` or a Right whose\n  //. value is of type `b`.\n  //.\n  //. The implementation is provided by [sanctuary-either][].\n\n  //# Either :: TypeRep Either\n  //.\n  //. Either [type representative][].\n\n  //# Left :: a -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > S.Left ('Cannot divide by zero')\n  //. Left ('Cannot divide by zero')\n  //. ```\n  _.Left = {\n    consts: {},\n    types: [a, $.Either (a) (b)],\n    impl: Left,\n  };\n\n  //# Right :: b -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `b`.\n  //.\n  //. ```javascript\n  //. > S.Right (42)\n  //. Right (42)\n  //. ```\n  _.Right = {\n    consts: {},\n    types: [b, $.Either (a) (b)],\n    impl: Right,\n  };\n\n  //# isLeft :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Left; `false` if it is a Right.\n  //.\n  //. ```javascript\n  //. > S.isLeft (S.Left ('Cannot divide by zero'))\n  //. true\n  //.\n  //. > S.isLeft (S.Right (42))\n  //. false\n  //. ```\n  const isLeft = either => either.isLeft;\n  _.isLeft = {\n    consts: {},\n    types: [$.Either (a) (b), $.Boolean],\n    impl: isLeft,\n  };\n\n  //# isRight :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Right; `false` if it is a Left.\n  //.\n  //. ```javascript\n  //. > S.isRight (S.Right (42))\n  //. true\n  //.\n  //. > S.isRight (S.Left ('Cannot divide by zero'))\n  //. false\n  //. ```\n  const isRight = either => either.isRight;\n  _.isRight = {\n    consts: {},\n    types: [$.Either (a) (b), $.Boolean],\n    impl: isRight,\n  };\n\n  //# either :: (a -> c) -> (b -> c) -> Either a b -> c\n  //.\n  //. Takes two functions and an Either, and returns the result of\n  //. applying the first function to the Left's value, if the Either\n  //. is a Left, or the result of applying the second function to the\n  //. Right's value, if the Either is a Right.\n  //.\n  //. See also [`fromLeft`](#fromLeft) and [`fromRight`](#fromRight).\n  //.\n  //. ```javascript\n  //. > S.either (S.toUpper) (S.show) (S.Left ('Cannot divide by zero'))\n  //. 'CANNOT DIVIDE BY ZERO'\n  //.\n  //. > S.either (S.toUpper) (S.show) (S.Right (42))\n  //. '42'\n  //. ```\n  const either = left => right => either => (\n    either.isLeft ? left (either.value) : right (either.value)\n  );\n  _.either = {\n    consts: {},\n    types: [$.Fn (a) (c), $.Fn (b) (c), $.Either (a) (b), c],\n    impl: either,\n  };\n\n  //# fromLeft :: a -> Either a b -> a\n  //.\n  //. Takes a default value and an Either, and returns the Left value\n  //. if the Either is a Left; the default value otherwise.\n  //.\n  //. See also [`either`](#either) and [`fromRight`](#fromRight).\n  //.\n  //. ```javascript\n  //. > S.fromLeft ('abc') (S.Left ('xyz'))\n  //. 'xyz'\n  //.\n  //. > S.fromLeft ('abc') (S.Right (123))\n  //. 'abc'\n  //. ```\n  const fromLeft = right => either => either.isLeft ? either.value : right;\n  _.fromLeft = {\n    consts: {},\n    types: [a, $.Either (a) (b), a],\n    impl: fromLeft,\n  };\n\n  //# fromRight :: b -> Either a b -> b\n  //.\n  //. Takes a default value and an Either, and returns the Right value\n  //. if the Either is a Right; the default value otherwise.\n  //.\n  //. See also [`either`](#either) and [`fromLeft`](#fromLeft).\n  //.\n  //. ```javascript\n  //. > S.fromRight (123) (S.Right (789))\n  //. 789\n  //.\n  //. > S.fromRight (123) (S.Left ('abc'))\n  //. 123\n  //. ```\n  const fromRight = left => either => either.isRight ? either.value : left;\n  _.fromRight = {\n    consts: {},\n    types: [b, $.Either (a) (b), b],\n    impl: fromRight,\n  };\n\n  //# fromEither :: Either a a -> a\n  //.\n  //. Takes an Either with the same type on the Left and on the Right\n  //. and returns whichever value exists.\n  //.\n  //. The inverse of [`tagBy`](#tagBy).\n  //.\n  //. ```javascript\n  //. > S.fromEither (S.Left (42))\n  //. 42\n  //.\n  //. > S.fromEither (S.Right (42))\n  //. 42\n  //. ```\n  const fromEither = either => either.value;\n  _.fromEither = {\n    consts: {},\n    types: [$.Either (a) (a), a],\n    impl: fromEither,\n  };\n\n  //# lefts :: (Filterable f, Functor f) => f (Either a b) -> f a\n  //.\n  //. Discards each element that is a Right, and unwraps each element that is\n  //. a Left.\n  //.\n  //. See also [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.lefts ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])\n  //. ['foo', 'bar']\n  //. ```\n  const lefts = eithers => (\n    Z.map (left => left.value, Z.filter (isLeft, eithers))\n  );\n  _.lefts = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [f ($.Either (a) (b)), f (a)],\n    impl: lefts,\n  };\n\n  //# rights :: (Filterable f, Functor f) => f (Either a b) -> f b\n  //.\n  //. Discards each element that is a Left, and unwraps each element that is\n  //. a Right.\n  //.\n  //. See also [`lefts`](#lefts).\n  //.\n  //. ```javascript\n  //. > S.rights ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])\n  //. [20, 10]\n  //. ```\n  const rights = eithers => (\n    Z.map (right => right.value, Z.filter (isRight, eithers))\n  );\n  _.rights = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [f ($.Either (a) (b)), f (b)],\n    impl: rights,\n  };\n\n  //# tagBy :: (a -> Boolean) -> a -> Either a a\n  //.\n  //. Takes a predicate and a value, and returns a Right of the value if it\n  //. satisfies the predicate; a Left of the value otherwise.\n  //.\n  //. ```javascript\n  //. > S.tagBy (S.odd) (0)\n  //. Left (0)\n  //\n  //. > S.tagBy (S.odd) (1)\n  //. Right (1)\n  //. ```\n  const tagBy = pred => x => pred (x) ? Right (x) : Left (x);\n  _.tagBy = {\n    consts: {},\n    types: [$.Predicate (a), a, $.Either (a) (a)],\n    impl: tagBy,\n  };\n\n  //# encase :: Throwing e a b -> a -> Either e b\n  //.\n  //. Takes a function that may throw and returns a pure function.\n  //.\n  //. ```javascript\n  //. > S.encase (JSON.parse) ('[\"foo\",\"bar\",\"baz\"]')\n  //. Right (['foo', 'bar', 'baz'])\n  //.\n  //. > S.encase (JSON.parse) ('[')\n  //. Left (new SyntaxError ('Unexpected end of JSON input'))\n  //. ```\n  const encase = f => x => {\n    try {\n      return Right (f (x));\n    } catch (err) {\n      return Left (err);\n    }\n  };\n  _.encase = {\n    consts: {},\n    types: [Throwing (e) (a) (b), a, $.Either (e) (b)],\n    impl: encase,\n  };\n\n  //. ### Logic\n\n  //# and :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"and\".\n  //.\n  //. ```javascript\n  //. > S.and (false) (false)\n  //. false\n  //.\n  //. > S.and (false) (true)\n  //. false\n  //.\n  //. > S.and (true) (false)\n  //. false\n  //.\n  //. > S.and (true) (true)\n  //. true\n  //. ```\n  const and = x => y => x && y;\n  _.and = {\n    consts: {},\n    types: [$.Boolean, $.Boolean, $.Boolean],\n    impl: and,\n  };\n\n  //# or :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"or\".\n  //.\n  //. ```javascript\n  //. > S.or (false) (false)\n  //. false\n  //.\n  //. > S.or (false) (true)\n  //. true\n  //.\n  //. > S.or (true) (false)\n  //. true\n  //.\n  //. > S.or (true) (true)\n  //. true\n  //. ```\n  const or = x => y => x || y;\n  _.or = {\n    consts: {},\n    types: [$.Boolean, $.Boolean, $.Boolean],\n    impl: or,\n  };\n\n  //# not :: Boolean -> Boolean\n  //.\n  //. Boolean \"not\".\n  //.\n  //. See also [`complement`](#complement).\n  //.\n  //. ```javascript\n  //. > S.not (false)\n  //. true\n  //.\n  //. > S.not (true)\n  //. false\n  //. ```\n  const not = x => !x;\n  _.not = {\n    consts: {},\n    types: [$.Boolean, $.Boolean],\n    impl: not,\n  };\n\n  //# complement :: (a -> Boolean) -> a -> Boolean\n  //.\n  //. Takes a unary predicate and a value of any type, and returns the logical\n  //. negation of applying the predicate to the value.\n  //.\n  //. See also [`not`](#not).\n  //.\n  //. ```javascript\n  //. > Number.isInteger (42)\n  //. true\n  //.\n  //. > S.complement (Number.isInteger) (42)\n  //. false\n  //. ```\n  const complement = pred => x => !(pred (x));\n  _.complement = {\n    consts: {},\n    types: [$.Predicate (a), a, $.Boolean],\n    impl: complement,\n  };\n\n  //# boolean :: a -> a -> Boolean -> a\n  //.\n  //. Case analysis for the `Boolean` type. `boolean (x) (y) (b)` evaluates\n  //. to `x` if `b` is `false`; to `y` if `b` is `true`.\n  //.\n  //. ```javascript\n  //. > S.boolean ('no') ('yes') (false)\n  //. 'no'\n  //.\n  //. > S.boolean ('no') ('yes') (true)\n  //. 'yes'\n  //. ```\n  const boolean = false_ => true_ => boolean => boolean ? true_ : false_;\n  _.boolean = {\n    consts: {},\n    types: [a, a, $.Boolean, a],\n    impl: boolean,\n  };\n\n  //# ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b\n  //.\n  //. Takes a unary predicate, a unary \"if\" function, a unary \"else\"\n  //. function, and a value of any type, and returns the result of\n  //. applying the \"if\" function to the value if the value satisfies\n  //. the predicate; the result of applying the \"else\" function to the\n  //. value otherwise.\n  //.\n  //. See also [`when`](#when) and [`unless`](#unless).\n  //.\n  //. ```javascript\n  //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (-1)\n  //. 1\n  //.\n  //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (16)\n  //. 4\n  //. ```\n  const ifElse = pred => f => g => x => pred (x) ? f (x) : g (x);\n  _.ifElse = {\n    consts: {},\n    types: [$.Predicate (a), $.Fn (a) (b), $.Fn (a) (b), a, b],\n    impl: ifElse,\n  };\n\n  //# when :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. satisfies the predicate; the value otherwise.\n  //.\n  //. See also [`unless`](#unless) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.when (x => x >= 0) (Math.sqrt) (16)\n  //. 4\n  //.\n  //. > S.when (x => x >= 0) (Math.sqrt) (-1)\n  //. -1\n  //. ```\n  const when = pred => f => x => pred (x) ? f (x) : x;\n  _.when = {\n    consts: {},\n    types: [$.Predicate (a), $.Fn (a) (a), a, a],\n    impl: when,\n  };\n\n  //# unless :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. does not satisfy the predicate; the value otherwise.\n  //.\n  //. See also [`when`](#when) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.unless (x => x < 0) (Math.sqrt) (16)\n  //. 4\n  //.\n  //. > S.unless (x => x < 0) (Math.sqrt) (-1)\n  //. -1\n  //. ```\n  const unless = pred => f => x => pred (x) ? x : f (x);\n  _.unless = {\n    consts: {},\n    types: [$.Predicate (a), $.Fn (a) (a), a, a],\n    impl: unless,\n  };\n\n  //. ### Array\n\n  //# array :: b -> (a -> Array a -> b) -> Array a -> b\n  //.\n  //. Case analysis for the `Array a` type.\n  //.\n  //. ```javascript\n  //. > S.array (S.Nothing) (head => tail => S.Just (head)) ([])\n  //. Nothing\n  //.\n  //. > S.array (S.Nothing) (head => tail => S.Just (head)) ([1, 2, 3])\n  //. Just (1)\n  //.\n  //. > S.array (S.Nothing) (head => tail => S.Just (tail)) ([])\n  //. Nothing\n  //.\n  //. > S.array (S.Nothing) (head => tail => S.Just (tail)) ([1, 2, 3])\n  //. Just ([2, 3])\n  //. ```\n  const array = empty => nonEmpty => array => (\n    array.length === 0 ? empty : nonEmpty (array[0]) (array.slice (1))\n  );\n  _.array = {\n    consts: {},\n    types: [b, $.Fn (a) ($.Fn ($.Array (a)) (b)), $.Array (a), b],\n    impl: array,\n  };\n\n  //# head :: Foldable f => f a -> Maybe a\n  //.\n  //. Returns Just the first element of the given structure if the structure\n  //. contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.head ([1, 2, 3])\n  //. Just (1)\n  //.\n  //. > S.head ([])\n  //. Nothing\n  //.\n  //. > S.head (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (1)\n  //.\n  //. > S.head (Nil)\n  //. Nothing\n  //. ```\n  const head = foldable => {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable[0]) : Nothing;\n    }\n    return Z.reduce ((m, x) => m.isJust ? m : Just (x), Nothing, foldable);\n  };\n  _.head = {\n    consts: {f: [Z.Foldable]},\n    types: [f (a), $.Maybe (a)],\n    impl: head,\n  };\n\n  //# last :: Foldable f => f a -> Maybe a\n  //.\n  //. Returns Just the last element of the given structure if the structure\n  //. contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.last ([1, 2, 3])\n  //. Just (3)\n  //.\n  //. > S.last ([])\n  //. Nothing\n  //.\n  //. > S.last (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (3)\n  //.\n  //. > S.last (Nil)\n  //. Nothing\n  //. ```\n  const last = foldable => {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable[foldable.length - 1])\n                                 : Nothing;\n    }\n    return Z.reduce ((_, x) => Just (x), Nothing, foldable);\n  };\n  _.last = {\n    consts: {f: [Z.Foldable]},\n    types: [f (a), $.Maybe (a)],\n    impl: last,\n  };\n\n  //# tail :: (Applicative f, Foldable f, Monoid (f a)) => f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the first of the given structure's elements if the\n  //. structure contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.tail ([1, 2, 3])\n  //. Just ([2, 3])\n  //.\n  //. > S.tail ([])\n  //. Nothing\n  //.\n  //. > S.tail (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (Cons (2) (Cons (3) (Nil)))\n  //\n  //. > S.tail (Nil)\n  //. Nothing\n  //. ```\n  const tail = foldable => {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable.slice (1)) : Nothing;\n    }\n    const empty = Z.empty (foldable.constructor);\n    const reducer = (m, x) => (\n      Just (m.isNothing ? empty : Z.append (x, m.value))\n    );\n    return Z.reduce (reducer, Nothing, foldable);\n  };\n  _.tail = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [f (a), $.Maybe (f (a))],\n    impl: tail,\n  };\n\n  //# init :: (Applicative f, Foldable f, Monoid (f a)) => f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the last of the given structure's elements if the\n  //. structure contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.init ([1, 2, 3])\n  //. Just ([1, 2])\n  //.\n  //. > S.init ([])\n  //. Nothing\n  //.\n  //. > S.init (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (Cons (1) (Cons (2) (Nil)))\n  //.\n  //. > S.init (Nil)\n  //. Nothing\n  //. ```\n  const init = foldable => {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable.slice (0, -1)) : Nothing;\n    }\n    const empty = Z.empty (foldable.constructor);\n    const reducer = (m, x) => (\n      Just ([m.isNothing ? empty : Z.append (m.value[1], m.value[0]), x])\n    );\n    return Z.map (([init]) => init, Z.reduce (reducer, Nothing, foldable));\n  };\n  _.init = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [f (a), $.Maybe (f (a))],\n    impl: init,\n  };\n\n  //# take :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just the first N elements of the given structure if N is\n  //. non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.take (0) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.take (1) (['foo', 'bar'])\n  //. Just (['foo'])\n  //.\n  //. > S.take (2) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.take (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.take (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Cons (5) (Nil))))))\n  //. Just (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. ```\n  const take = n => xs => {\n    if (n < 0) return Nothing;\n    //  Fast path for arrays.\n    if (Array.isArray (xs)) {\n      return n <= xs.length ? Just (xs.slice (0, n)) : Nothing;\n    }\n    const r = Z.reduce (\n      (r, x) => r.n < n ? (r.n += 1, r.xs = Z.append (x, r.xs), r) : r,\n      {n: 0, xs: Z.empty (xs.constructor)},\n      xs\n    );\n    return r.n < n ? Nothing : Just (r.xs);\n  };\n  _.take = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: take,\n  };\n\n  //# drop :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the first N elements of the given structure if\n  //. N is non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.drop (0) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.drop (1) (['foo', 'bar'])\n  //. Just (['bar'])\n  //.\n  //. > S.drop (2) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.drop (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.drop (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Cons (5) (Nil))))))\n  //. Just (Cons (4) (Cons (5) (Nil)))\n  //. ```\n  const drop = n => xs => {\n    if (n < 0) return Nothing;\n    //  Fast path for arrays.\n    if (Array.isArray (xs)) {\n      return n <= xs.length ? Just (xs.slice (n)) : Nothing;\n    }\n    const r = Z.reduce (\n      (r, x) => r.n < n ? (r.n += 1, r) : (r.xs = Z.append (x, r.xs), r),\n      {n: 0, xs: Z.empty (xs.constructor)},\n      xs\n    );\n    return r.n < n ? Nothing : Just (r.xs);\n  };\n  _.drop = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: drop,\n  };\n\n  //# takeLast :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just the last N elements of the given structure if N is\n  //. non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.takeLast (0) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.takeLast (1) (['foo', 'bar'])\n  //. Just (['bar'])\n  //.\n  //. > S.takeLast (2) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.takeLast (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.takeLast (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Nil)))))\n  //. Just (Cons (2) (Cons (3) (Cons (4) (Nil))))\n  //. ```\n  const takeLast = n => xs => Z.map (Z.reverse, take (n) (Z.reverse (xs)));\n  _.takeLast = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: takeLast,\n  };\n\n  //# dropLast :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the last N elements of the given structure if\n  //. N is non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.dropLast (0) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.dropLast (1) (['foo', 'bar'])\n  //. Just (['foo'])\n  //.\n  //. > S.dropLast (2) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.dropLast (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.dropLast (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Nil)))))\n  //. Just (Cons (1) (Nil))\n  //. ```\n  const dropLast = n => xs => Z.map (Z.reverse, drop (n) (Z.reverse (xs)));\n  _.dropLast = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: dropLast,\n  };\n\n  //# takeWhile :: (a -> Boolean) -> Array a -> Array a\n  //.\n  //. Discards the first element that does not satisfy the predicate,\n  //. and all subsequent elements.\n  //.\n  //. See also [`dropWhile`](#dropWhile).\n  //.\n  //. ```javascript\n  //. > S.takeWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7]\n  //.\n  //. > S.takeWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. []\n  //. ```\n  const takeWhile = pred => xs => {\n    let idx = 0;\n    while (idx < xs.length && pred (xs[idx])) idx += 1;\n    return xs.slice (0, idx);\n  };\n  _.takeWhile = {\n    consts: {},\n    types: [$.Predicate (a), $.Array (a), $.Array (a)],\n    impl: takeWhile,\n  };\n\n  //# dropWhile :: (a -> Boolean) -> Array a -> Array a\n  //.\n  //. Retains the first element that does not satisfy the predicate,\n  //. and all subsequent elements.\n  //.\n  //. See also [`takeWhile`](#takeWhile).\n  //.\n  //. ```javascript\n  //. > S.dropWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. [6, 3, 5, 4]\n  //.\n  //. > S.dropWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7, 6, 3, 5, 4]\n  //. ```\n  const dropWhile = pred => xs => {\n    let idx = 0;\n    while (idx < xs.length && pred (xs[idx])) idx += 1;\n    return xs.slice (idx);\n  };\n  _.dropWhile = {\n    consts: {},\n    types: [$.Predicate (a), $.Array (a), $.Array (a)],\n    impl: dropWhile,\n  };\n\n  //# size :: Foldable f => f a -> NonNegativeInteger\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.size ([])\n  //. 0\n  //.\n  //. > S.size (['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > S.size (Nil)\n  //. 0\n  //.\n  //. > S.size (Cons ('foo') (Cons ('bar') (Cons ('baz') (Nil))))\n  //. 3\n  //.\n  //. > S.size (S.Nothing)\n  //. 0\n  //.\n  //. > S.size (S.Just ('quux'))\n  //. 1\n  //.\n  //. > S.size (S.Pair ('ignored!') ('counted!'))\n  //. 1\n  //. ```\n  _.size = {\n    consts: {f: [Z.Foldable]},\n    types: [f (a), $.NonNegativeInteger],\n    impl: Z.size,\n  };\n\n  //# all :: Foldable f => (a -> Boolean) -> f a -> Boolean\n  //.\n  //. Returns `true` [iff][] all the elements of the structure satisfy the\n  //. predicate.\n  //.\n  //. See also [`any`](#any) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > S.all (S.odd) ([])\n  //. true\n  //.\n  //. > S.all (S.odd) ([1, 3, 5])\n  //. true\n  //.\n  //. > S.all (S.odd) ([1, 2, 3])\n  //. false\n  //. ```\n  _.all = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Boolean],\n    impl: curry2 (Z.all),\n  };\n\n  //# any :: Foldable f => (a -> Boolean) -> f a -> Boolean\n  //.\n  //. Returns `true` [iff][] any element of the structure satisfies the\n  //. predicate.\n  //.\n  //. See also [`all`](#all) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > S.any (S.odd) ([])\n  //. false\n  //.\n  //. > S.any (S.odd) ([2, 4, 6])\n  //. false\n  //.\n  //. > S.any (S.odd) ([1, 2, 3])\n  //. true\n  //. ```\n  _.any = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Boolean],\n    impl: curry2 (Z.any),\n  };\n\n  //# none :: Foldable f => (a -> Boolean) -> f a -> Boolean\n  //.\n  //. Returns `true` [iff][] none of the elements of the structure satisfies\n  //. the predicate.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall p :: a -> Boolean, xs :: Foldable f => f a.\n  //.      S.none (p) (xs) = S.not (S.any (p) (xs))`\n  //.\n  //.   - `forall p :: a -> Boolean, xs :: Foldable f => f a.\n  //.      S.none (p) (xs) = S.all (S.complement (p)) (xs)`\n  //.\n  //. See also [`all`](#all) and [`any`](#any).\n  //.\n  //. ```javascript\n  //. > S.none (S.odd) ([])\n  //. true\n  //.\n  //. > S.none (S.odd) ([2, 4, 6])\n  //. true\n  //.\n  //. > S.none (S.odd) ([1, 2, 3])\n  //. false\n  //. ```\n  _.none = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Boolean],\n    impl: curry2 (Z.none),\n  };\n\n  //# append :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > S.append (3) ([1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > S.append (3) (Cons (1) (Cons (2) (Nil)))\n  //. Cons (1) (Cons (2) (Cons (3) (Nil)))\n  //.\n  //. > S.append ([1]) (S.Nothing)\n  //. Just ([1])\n  //.\n  //. > S.append ([3]) (S.Just ([1, 2]))\n  //. Just ([1, 2, 3])\n  //. ```\n  _.append = {\n    consts: {f: [Z.Applicative, Z.Semigroup]},\n    types: [a, f (a), f (a)],\n    impl: curry2 (Z.append),\n  };\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > S.prepend (1) ([2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > S.prepend (1) (Cons (2) (Cons (3) (Nil)))\n  //. Cons (1) (Cons (2) (Cons (3) (Nil)))\n  //.\n  //. > S.prepend ([1]) (S.Nothing)\n  //. Just ([1])\n  //.\n  //. > S.prepend ([1]) (S.Just ([2, 3]))\n  //. Just ([1, 2, 3])\n  //. ```\n  _.prepend = {\n    consts: {f: [Z.Applicative, Z.Semigroup]},\n    types: [a, f (a), f (a)],\n    impl: curry2 (Z.prepend),\n  };\n\n  //# joinWith :: String -> Array String -> String\n  //.\n  //. Joins the strings of the second argument separated by the first argument.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String.\n  //.      S.joinWith (s) (S.splitOn (s) (t)) = t`\n  //.\n  //. See also [`splitOn`](#splitOn) and [`intercalate`](#intercalate).\n  //.\n  //. ```javascript\n  //. > S.joinWith (':') (['foo', 'bar', 'baz'])\n  //. 'foo:bar:baz'\n  //. ```\n  _.joinWith = {\n    consts: {},\n    types: [$.String, $.Array ($.String), $.String],\n    impl: invoke1 ('join'),\n  };\n\n  //# elem :: (Setoid a, Foldable f) => a -> f a -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` [iff][] the value is an\n  //. element of the structure.\n  //.\n  //. See also [`elem_`](#elem_) and [`find`](#find).\n  //.\n  //. ```javascript\n  //. > S.elem ('c') (['a', 'b', 'c'])\n  //. true\n  //.\n  //. > S.elem ('x') (['a', 'b', 'c'])\n  //. false\n  //.\n  //. > S.elem (3) ({x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > S.elem (8) ({x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > S.elem (0) (S.Just (0))\n  //. true\n  //.\n  //. > S.elem (0) (S.Just (1))\n  //. false\n  //.\n  //. > S.elem (0) (S.Nothing)\n  //. false\n  //. ```\n  _.elem = {\n    consts: {a: [Z.Setoid], f: [Z.Foldable]},\n    types: [a, f (a), $.Boolean],\n    impl: curry2 (Z.elem),\n  };\n\n  //# elem_ :: (Setoid a, Foldable f) => f a -> a -> Boolean\n  //.\n  //. Variant of [`elem`](#elem) with arguments flipped.\n  //.\n  //. ```javascript\n  //. > S.filter (S.elem_ (['yes', 'oui', 'ja'])) (['yes', 'no'])\n  //. ['yes']\n  //.\n  //. > S.filter (S.elem_ (['yes', 'oui', 'ja'])) (['oui', 'non'])\n  //. ['oui']\n  //.\n  //. > S.filter (S.elem_ (['yes', 'oui', 'ja'])) (['ja', 'nein'])\n  //. ['ja']\n  //. ```\n  const elem_ = foldable => x => Z.elem (x, foldable);\n  _.elem_ = {\n    consts: {a: [Z.Setoid], f: [Z.Foldable]},\n    types: [f (a), a, $.Boolean],\n    impl: elem_,\n  };\n\n  //# find :: Foldable f => (a -> Boolean) -> f a -> Maybe a\n  //.\n  //. Takes a predicate and a structure and returns Just the leftmost element\n  //. of the structure that satisfies the predicate; Nothing if there is no\n  //. such element.\n  //.\n  //. See also [`findMap`](#findMap) and [`elem`](#elem).\n  //.\n  //. ```javascript\n  //. > S.find (S.lt (0)) ([1, -2, 3, -4, 5])\n  //. Just (-2)\n  //.\n  //. > S.find (S.lt (0)) ([1, 2, 3, 4, 5])\n  //. Nothing\n  //. ```\n  const find = pred => findMap (x => pred (x) ? Just (x) : Nothing);\n  _.find = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Maybe (a)],\n    impl: find,\n  };\n\n  //# findMap :: Foldable f => (a -> Maybe b) -> f a -> Maybe b\n  //.\n  //. Finds the leftmost element of the given structure for which the given\n  //. function returns a Just, and returns that Just (or Nothing if none of\n  //. the elements matches).\n  //.\n  //. More flexible than [`find`](#find), and more convenient in situations\n  //. in which the result of a successful computation can be reused.\n  //.\n  //. ```javascript\n  //. > S.findMap (S.parseInt (16)) ([])\n  //. Nothing\n  //.\n  //. > S.findMap (S.parseInt (16)) (['X', 'Y', 'Z'])\n  //. Nothing\n  //.\n  //. > S.findMap (S.parseInt (16)) (['A', 'B', 'C'])\n  //. Just (10)\n  //. ```\n  const findMap = f => xs => (\n    Z.reduce ((m, x) => m.isJust ? m : f (x), Nothing, xs)\n  );\n  _.findMap = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Fn (a) ($.Maybe (b)), f (a), $.Maybe (b)],\n    impl: findMap,\n  };\n\n  //# intercalate :: (Monoid m, Foldable f) => m -> f m -> m\n  //.\n  //. Curried version of [`Z.intercalate`][]. Concatenates the elements of\n  //. the given structure, separating each pair of adjacent elements with\n  //. the given separator.\n  //.\n  //. See also [`joinWith`](#joinWith).\n  //.\n  //. ```javascript\n  //. > S.intercalate (', ') ([])\n  //. ''\n  //.\n  //. > S.intercalate (', ') (['foo', 'bar', 'baz'])\n  //. 'foo, bar, baz'\n  //.\n  //. > S.intercalate (', ') (Nil)\n  //. ''\n  //.\n  //. > S.intercalate (', ') (Cons ('foo') (Cons ('bar') (Cons ('baz') (Nil))))\n  //. 'foo, bar, baz'\n  //.\n  //. > S.intercalate ([0, 0, 0]) ([])\n  //. []\n  //.\n  //. > S.intercalate ([0, 0, 0]) ([[1], [2, 3], [4, 5, 6], [7, 8], [9]])\n  //. [1, 0, 0, 0, 2, 3, 0, 0, 0, 4, 5, 6, 0, 0, 0, 7, 8, 0, 0, 0, 9]\n  //. ```\n  _.intercalate = {\n    consts: {a: [Z.Monoid], f: [Z.Foldable]},\n    types: [a, f (a), a],\n    impl: curry2 (Z.intercalate),\n  };\n\n  //# foldMap :: (Monoid m, Foldable f) => TypeRep m -> (a -> m) -> f a -> m\n  //.\n  //. Curried version of [`Z.foldMap`][]. Deconstructs a foldable by mapping\n  //. every element to a monoid and concatenating the results.\n  //.\n  //. ```javascript\n  //. > S.foldMap (String) (f => f.name) ([Math.sin, Math.cos, Math.tan])\n  //. 'sincostan'\n  //.\n  //. > S.foldMap (Array) (x => [x + 1, x + 2]) ([10, 20, 30])\n  //. [11, 12, 21, 22, 31, 32]\n  //. ```\n  _.foldMap = {\n    consts: {b: [Z.Monoid], f: [Z.Foldable]},\n    types: [TypeRep (b), $.Fn (a) (b), f (a), b],\n    impl: curry3 (Z.foldMap),\n  };\n\n  //# unfold :: (b -> Maybe (Pair a b)) -> b -> Array a\n  //.\n  //. Takes a function and a seed value, and returns an array generated by\n  //. applying the function repeatedly. The array is initially empty. The\n  //. function is initially applied to the seed value. Each application\n  //. of the function should result in either:\n  //.\n  //.   - Nothing, in which case the array is returned; or\n  //.\n  //.   - Just a pair, in which case the first element is appended to\n  //.     the array and the function is applied to the second element.\n  //.\n  //. ```javascript\n  //. > S.unfold (n => n < 1000 ? S.Just (S.Pair (n) (2 * n)) : S.Nothing) (1)\n  //. [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n  //. ```\n  const unfold = f => x => {\n    const result = [];\n    while (true) {\n      const m = f (x);\n      if (m.isNothing) return result;\n      [result[result.length], x] = m.value;\n    }\n  };\n  _.unfold = {\n    consts: {},\n    types: [$.Fn (b) ($.Maybe ($.Pair (a) (b))), b, $.Array (a)],\n    impl: unfold,\n  };\n\n  //# range :: Integer -> Integer -> Array Integer\n  //.\n  //. Returns an array of consecutive integers starting with the first argument\n  //. and ending with the second argument minus one. Returns `[]` if the second\n  //. argument is less than or equal to the first argument.\n  //.\n  //. ```javascript\n  //. > S.range (0) (10)\n  //. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  //.\n  //. > S.range (-5) (0)\n  //. [-5, -4, -3, -2, -1]\n  //.\n  //. > S.range (0) (-5)\n  //. []\n  //. ```\n  const range = from => to => {\n    const result = [];\n    for (let n = from; n < to; n += 1) result.push (n);\n    return result;\n  };\n  _.range = {\n    consts: {},\n    types: [$.Integer, $.Integer, $.Array ($.Integer)],\n    impl: range,\n  };\n\n  //# groupBy :: (a -> a -> Boolean) -> Array a -> Array (Array a)\n  //.\n  //. Splits its array argument into an array of arrays of equal,\n  //. adjacent elements. Equality is determined by the function\n  //. provided as the first argument. Its behaviour can be surprising\n  //. for functions that aren't reflexive, transitive, and symmetric\n  //. (see [equivalence][] relation).\n  //.\n  //. Properties:\n  //.\n  //.   - `forall f :: a -> a -> Boolean, xs :: Array a.\n  //.      S.join (S.groupBy (f) (xs)) = xs`\n  //.\n  //. ```javascript\n  //. > S.groupBy (S.equals) ([1, 1, 2, 1, 1])\n  //. [[1, 1], [2], [1, 1]]\n  //.\n  //. > S.groupBy (x => y => x + y === 0) ([2, -3, 3, 3, 3, 4, -4, 4])\n  //. [[2], [-3, 3, 3, 3], [4, -4], [4]]\n  //. ```\n  const groupBy = f => xs => {\n    if (xs.length === 0) return [];\n    let x0 = xs[0];           // :: a\n    let active = [x0];        // :: Array a\n    const result = [active];  // :: Array (Array a)\n    for (let idx = 1; idx < xs.length; idx += 1) {\n      const x = xs[idx];\n      if (f (x0) (x)) active.push (x); else result.push (active = [x0 = x]);\n    }\n    return result;\n  };\n  _.groupBy = {\n    consts: {},\n    types: [$.Fn (a) ($.Predicate (a)), $.Array (a), $.Array ($.Array (a))],\n    impl: groupBy,\n  };\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.reverse ([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > S.reverse (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Cons (3) (Cons (2) (Cons (1) (Nil)))\n  //.\n  //. > S.pipe ([S.splitOn (''), S.reverse, S.joinWith ('')]) ('abc')\n  //. 'cba'\n  //. ```\n  _.reverse = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [f (a), f (a)],\n    impl: Z.reverse,\n  };\n\n  //# sort :: (Ord a, Applicative m, Foldable m, Monoid (m a)) => m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] for comparisons.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sort (S.sort (m)) = S.sort (m)` (idempotence)\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > S.sort (['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > S.sort ([S.Left (4), S.Right (3), S.Left (2), S.Right (1)])\n  //. [Left (2), Left (4), Right (1), Right (3)]\n  //. ```\n  _.sort = {\n    consts: {a: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [m (a), m (a)],\n    impl: Z.sort,\n  };\n\n  //# sortBy :: (Ord b, Applicative m, Foldable m, Monoid (m a)) => (a -> b) -> m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] to compare the values produced by applying the given function\n  //. to each element of the structure.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sortBy (f) (S.sortBy (f) (m)) = S.sortBy (f) (m)` (idempotence)\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > S.sortBy (S.prop ('rank')) ([\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 2, suit: 'hearts'},\n  //. . {rank: 5, suit: 'hearts'},\n  //. . {rank: 5, suit: 'spades'},\n  //. . {rank: 7, suit: 'spades'} ]\n  //.\n  //. > S.sortBy (S.prop ('suit')) ([\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 5, suit: 'hearts'},\n  //. . {rank: 2, suit: 'hearts'},\n  //. . {rank: 7, suit: 'spades'},\n  //. . {rank: 5, suit: 'spades'} ]\n  //. ```\n  //.\n  //. If descending order is desired, one may use [`Descending`][]:\n  //.\n  //. ```javascript\n  //. > S.sortBy (Descending) ([83, 97, 110, 99, 116, 117, 97, 114, 121])\n  //. [121, 117, 116, 114, 110, 99, 97, 97, 83]\n  //. ```\n  _.sortBy = {\n    consts: {b: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Fn (a) (b), m (a), m (a)],\n    impl: curry2 (Z.sortBy),\n  };\n\n  //# zip :: Array a -> Array b -> Array (Pair a b)\n  //.\n  //. Returns an array of pairs of corresponding elements from the given\n  //. arrays. The length of the resulting array is equal to the length of\n  //. the shorter input array.\n  //.\n  //. See also [`zipWith`](#zipWith).\n  //.\n  //. ```javascript\n  //. > S.zip (['a', 'b']) (['x', 'y', 'z'])\n  //. [Pair ('a') ('x'), Pair ('b') ('y')]\n  //.\n  //. > S.zip ([1, 3, 5]) ([2, 4])\n  //. [Pair (1) (2), Pair (3) (4)]\n  //. ```\n  const zip = xs => zipWith (Pair) (xs);\n  _.zip = {\n    consts: {},\n    types: [$.Array (a), $.Array (b), $.Array ($.Pair (a) (b))],\n    impl: zip,\n  };\n\n  //# zipWith :: (a -> b -> c) -> Array a -> Array b -> Array c\n  //.\n  //. Returns the result of combining, pairwise, the given arrays using the\n  //. given binary function. The length of the resulting array is equal to the\n  //. length of the shorter input array.\n  //.\n  //. See also [`zip`](#zip).\n  //.\n  //. ```javascript\n  //. > S.zipWith (a => b => a + b) (['a', 'b']) (['x', 'y', 'z'])\n  //. ['ax', 'by']\n  //.\n  //. > S.zipWith (a => b => [a, b]) ([1, 3, 5]) ([2, 4])\n  //. [[1, 2], [3, 4]]\n  //. ```\n  const zipWith = f => xs => ys => {\n    const result = new Array (Math.min (xs.length, ys.length));\n    for (let idx = 0; idx < result.length; idx += 1) {\n      result[idx] = f (xs[idx]) (ys[idx]);\n    }\n    return result;\n  };\n  _.zipWith = {\n    consts: {},\n    types: [$.Fn (a) ($.Fn (b) (c)), $.Array (a), $.Array (b), $.Array (c)],\n    impl: zipWith,\n  };\n\n  //. ### Object\n\n  //# prop :: String -> a -> b\n  //.\n  //. Takes a property name and an object with known properties and returns\n  //. the value of the specified property. If for some reason the object\n  //. lacks the specified property, a type error is thrown.\n  //.\n  //. For accessing properties of uncertain objects, use [`get`](#get) instead.\n  //. For accessing string map values by key, use [`value`](#value) instead.\n  //.\n  //. ```javascript\n  //. > S.prop ('a') ({a: 1, b: 2})\n  //. 1\n  //. ```\n  const prop = key => x => {\n    if (x != null) {\n      const obj = Object (x);\n      if (key in obj) return obj[key];\n    }\n    throw new TypeError (\n      `‘prop’ expected object to have a property named ‘${key}’; ${show (x)} does not`\n    );\n  };\n  _.prop = {\n    consts: {},\n    types: [$.String, a, b],\n    impl: prop,\n  };\n\n  //# props :: Array String -> a -> b\n  //.\n  //. Takes a property path (an array of property names) and an object with\n  //. known structure and returns the value at the given path. If for some\n  //. reason the path does not exist, a type error is thrown.\n  //.\n  //. For accessing property paths of uncertain objects, use [`gets`](#gets)\n  //. instead.\n  //.\n  //. ```javascript\n  //. > S.props (['a', 'b', 'c']) ({a: {b: {c: 1}}})\n  //. 1\n  //. ```\n  const props = path => x => (\n    path.reduce ((x, key) => {\n      if (x != null) {\n        const obj = Object (x);\n        if (key in obj) return obj[key];\n      }\n      throw new TypeError (\n        `‘props’ expected object to have a property at ${show (path)}; ${show (x)} does not`\n      );\n    }, x)\n  );\n  _.props = {\n    consts: {},\n    types: [$.Array ($.String), a, b],\n    impl: props,\n  };\n\n  //# get :: (Any -> Boolean) -> String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property name, and an object and returns Just the\n  //. value of the specified object property if it exists and the value\n  //. satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`gets`](#gets), [`prop`](#prop), and [`value`](#value).\n  //.\n  //. ```javascript\n  //. > S.get (S.is ($.Number)) ('x') ({x: 1, y: 2})\n  //. Just (1)\n  //.\n  //. > S.get (S.is ($.Number)) ('x') ({x: '1', y: '2'})\n  //. Nothing\n  //.\n  //. > S.get (S.is ($.Number)) ('x') ({})\n  //. Nothing\n  //.\n  //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3]})\n  //. Just ([1, 2, 3])\n  //.\n  //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3, null]})\n  //. Nothing\n  //. ```\n  const get = pred => key => x => {\n    if (x != null) {\n      const obj = Object (x);\n      if (key in obj) {\n        const val = obj[key];\n        if (pred (val)) {\n          return Just (val);\n        }\n      }\n    }\n    return Nothing;\n  };\n  _.get = {\n    consts: {},\n    types: [$.Predicate ($.Any), $.String, a, $.Maybe (b)],\n    impl: get,\n  };\n\n  //# gets :: (Any -> Boolean) -> Array String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property path (an array of property names), and\n  //. an object and returns Just the value at the given path if such a path\n  //. exists and the value satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`get`](#get).\n  //.\n  //. ```javascript\n  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: 42}}})\n  //. Just (42)\n  //.\n  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: '42'}}})\n  //. Nothing\n  //.\n  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({})\n  //. Nothing\n  //. ```\n  const gets = pred => keys => x => (\n    Z.filter (pred, keys.reduce ((maybe, key) => {\n      if (maybe.isJust && maybe.value != null) {\n        const obj = Object (maybe.value);\n        if (key in obj) return Just (obj[key]);\n      }\n      return Nothing;\n    }, Just (x)))\n  );\n  _.gets = {\n    consts: {},\n    types: [$.Predicate ($.Any), $.Array ($.String), a, $.Maybe (b)],\n    impl: gets,\n  };\n\n  //. ### StrMap\n  //.\n  //. StrMap is an abbreviation of _string map_. A string map is an object,\n  //. such as `{foo: 1, bar: 2, baz: 3}`, whose values are all members of\n  //. the same type. Formally, a value is a member of type `StrMap a` if its\n  //. [type identifier][] is `'Object'` and the values of its enumerable own\n  //. properties are all members of type `a`.\n\n  //# value :: String -> StrMap a -> Maybe a\n  //.\n  //. Retrieve the value associated with the given key in the given string map.\n  //.\n  //. Formally, `value (k) (m)` evaluates to `Just (m[k])` if `k` is an\n  //. enumerable own property of `m`; `Nothing` otherwise.\n  //.\n  //. See also [`prop`](#prop) and [`get`](#get).\n  //.\n  //. ```javascript\n  //. > S.value ('foo') ({foo: 1, bar: 2})\n  //. Just (1)\n  //.\n  //. > S.value ('bar') ({foo: 1, bar: 2})\n  //. Just (2)\n  //.\n  //. > S.value ('baz') ({foo: 1, bar: 2})\n  //. Nothing\n  //. ```\n  const value = key => strMap => (\n    Object.prototype.propertyIsEnumerable.call (strMap, key) ?\n    Just (strMap[key]) :\n    Nothing\n  );\n  _.value = {\n    consts: {},\n    types: [$.String, $.StrMap (a), $.Maybe (a)],\n    impl: value,\n  };\n\n  //# singleton :: String -> a -> StrMap a\n  //.\n  //. Takes a string and a value of any type, and returns a string map with\n  //. a single entry (mapping the key to the value).\n  //.\n  //. ```javascript\n  //. > S.singleton ('foo') (42)\n  //. {foo: 42}\n  //. ```\n  const singleton = key => val => ({[key]: val});\n  _.singleton = {\n    consts: {},\n    types: [$.String, a, $.StrMap (a)],\n    impl: singleton,\n  };\n\n  //# insert :: String -> a -> StrMap a -> StrMap a\n  //.\n  //. Takes a string, a value of any type, and a string map, and returns a\n  //. string map comprising all the entries of the given string map plus the\n  //. entry specified by the first two arguments (which takes precedence).\n  //.\n  //. Equivalent to Haskell's `insert` function. Similar to Clojure's `assoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.insert ('c') (3) ({a: 1, b: 2})\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.insert ('a') (4) ({a: 1, b: 2})\n  //. {a: 4, b: 2}\n  //. ```\n  const insert = key => val => strMap => Z.concat (strMap, {[key]: val});\n  _.insert = {\n    consts: {},\n    types: [$.String, a, $.StrMap (a), $.StrMap (a)],\n    impl: insert,\n  };\n\n  //# remove :: String -> StrMap a -> StrMap a\n  //.\n  //. Takes a string and a string map, and returns a string map comprising all\n  //. the entries of the given string map except the one whose key matches the\n  //. given string (if such a key exists).\n  //.\n  //. Equivalent to Haskell's `delete` function. Similar to Clojure's `dissoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.remove ('c') ({a: 1, b: 2, c: 3})\n  //. {a: 1, b: 2}\n  //.\n  //. > S.remove ('c') ({})\n  //. {}\n  //. ```\n  const remove = key => strMap => {\n    const result = Z.concat (strMap, {});\n    delete result[key];\n    return result;\n  };\n  _.remove = {\n    consts: {},\n    types: [$.String, $.StrMap (a), $.StrMap (a)],\n    impl: remove,\n  };\n\n  //# keys :: StrMap a -> Array String\n  //.\n  //. Returns the keys of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.sort (S.keys ({b: 2, c: 3, a: 1}))\n  //. ['a', 'b', 'c']\n  //. ```\n  _.keys = {\n    consts: {},\n    types: [$.StrMap (a), $.Array ($.String)],\n    impl: Object.keys,\n  };\n\n  //# values :: StrMap a -> Array a\n  //.\n  //. Returns the values of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.sort (S.values ({a: 1, c: 3, b: 2}))\n  //. [1, 2, 3]\n  //. ```\n  _.values = {\n    consts: {},\n    types: [$.StrMap (a), $.Array (a)],\n    impl: Object.values,\n  };\n\n  //# pairs :: StrMap a -> Array (Pair String a)\n  //.\n  //. Returns the key–value pairs of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.sort (S.pairs ({b: 2, a: 1, c: 3}))\n  //. [Pair ('a') (1), Pair ('b') (2), Pair ('c') (3)]\n  //. ```\n  const pairs = strMap => (\n    (Object.entries (strMap)).map (([key, val]) => Pair (key) (val))\n  );\n  _.pairs = {\n    consts: {},\n    types: [$.StrMap (a), $.Array ($.Pair ($.String) (a))],\n    impl: pairs,\n  };\n\n  //# fromPairs :: Foldable f => f (Pair String a) -> StrMap a\n  //.\n  //. Returns a string map containing the key–value pairs specified by the\n  //. given [Foldable][]. If a key appears in multiple pairs, the rightmost\n  //. pair takes precedence.\n  //.\n  //. ```javascript\n  //. > S.fromPairs ([S.Pair ('a') (1), S.Pair ('b') (2), S.Pair ('c') (3)])\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.fromPairs ([S.Pair ('x') (1), S.Pair ('x') (2)])\n  //. {x: 2}\n  //. ```\n  const fromPairs = pairs => Z.reduce (\n    (strMap, [key, val]) => ((strMap[key] = val, strMap)),\n    {},\n    pairs\n  );\n  _.fromPairs = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.Pair ($.String) (a)), $.StrMap (a)],\n    impl: fromPairs,\n  };\n\n  //. ### Number\n\n  //# negate :: ValidNumber -> ValidNumber\n  //.\n  //. Negates its argument.\n  //.\n  //. ```javascript\n  //. > S.negate (12.5)\n  //. -12.5\n  //.\n  //. > S.negate (-42)\n  //. 42\n  //. ```\n  const negate = n => -n;\n  _.negate = {\n    consts: {},\n    types: [$.ValidNumber, $.ValidNumber],\n    impl: negate,\n  };\n\n  //# add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.add (1) (1)\n  //. 2\n  //. ```\n  const add = x => y => x + y;\n  _.add = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: add,\n  };\n\n  //# sum :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.sum ([1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.sum ([])\n  //. 0\n  //.\n  //. > S.sum (S.Just (42))\n  //. 42\n  //.\n  //. > S.sum (S.Nothing)\n  //. 0\n  //. ```\n  _.sum = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.FiniteNumber), $.FiniteNumber],\n    impl: reduce (add) (0),\n  };\n\n  //# sub :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Takes a finite number `n` and returns the _subtract `n`_ function.\n  //.\n  //. ```javascript\n  //. > S.map (S.sub (1)) ([1, 2, 3])\n  //. [0, 1, 2]\n  //. ```\n  const sub = y => x => x - y;\n  _.sub = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: sub,\n  };\n\n  //# mult :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.mult (4) (2)\n  //. 8\n  //. ```\n  const mult = x => y => x * y;\n  _.mult = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: mult,\n  };\n\n  //# product :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.product ([1, 2, 3, 4, 5])\n  //. 120\n  //.\n  //. > S.product ([])\n  //. 1\n  //.\n  //. > S.product (S.Just (42))\n  //. 42\n  //.\n  //. > S.product (S.Nothing)\n  //. 1\n  //. ```\n  _.product = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.FiniteNumber), $.FiniteNumber],\n    impl: reduce (mult) (1),\n  };\n\n  //# div :: NonZeroFiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Takes a non-zero finite number `n` and returns the _divide by `n`_\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.map (S.div (2)) ([0, 1, 2, 3])\n  //. [0, 0.5, 1, 1.5]\n  //. ```\n  const div = y => x => x / y;\n  _.div = {\n    consts: {},\n    types: [$.NonZeroFiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: div,\n  };\n\n  //# pow :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Takes a finite number `n` and returns the _power of `n`_ function.\n  //.\n  //. ```javascript\n  //. > S.map (S.pow (2)) ([-3, -2, -1, 0, 1, 2, 3])\n  //. [9, 4, 1, 0, 1, 4, 9]\n  //.\n  //. > S.map (S.pow (0.5)) ([1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5]\n  //. ```\n  const pow = exp => base => Math.pow (base, exp);\n  _.pow = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: pow,\n  };\n\n  //. ### Integer\n\n  //# even :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is even; `false` if it is odd.\n  //.\n  //. ```javascript\n  //. > S.even (42)\n  //. true\n  //.\n  //. > S.even (99)\n  //. false\n  //. ```\n  const even = n => n % 2 === 0;\n  _.even = {\n    consts: {},\n    types: [$.Integer, $.Boolean],\n    impl: even,\n  };\n\n  //# odd :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is odd; `false` if it is even.\n  //.\n  //. ```javascript\n  //. > S.odd (99)\n  //. true\n  //.\n  //. > S.odd (42)\n  //. false\n  //. ```\n  const odd = n => n % 2 !== 0;\n  _.odd = {\n    consts: {},\n    types: [$.Integer, $.Boolean],\n    impl: odd,\n  };\n\n  //. ### Parse\n\n  //# parseDate :: String -> Maybe ValidDate\n  //.\n  //. Takes a string `s` and returns `Just (new Date (s))` if `new Date (s)`\n  //. evaluates to a [`ValidDate`][ValidDate] value; Nothing otherwise.\n  //.\n  //. As noted in [#488][], this function's behaviour is unspecified for some\n  //. inputs! [MDN][date parsing] warns against using the `Date` constructor\n  //. to parse date strings:\n  //.\n  //. > __Note:__ parsing of date strings with the `Date` constructor […] is\n  //. > strongly discouraged due to browser differences and inconsistencies.\n  //. > Support for RFC 2822 format strings is by convention only. Support for\n  //. > ISO 8601 formats differs in that date-only strings (e.g. \"1970-01-01\")\n  //. > are treated as UTC, not local.\n  //.\n  //. ```javascript\n  //. > S.parseDate ('2011-01-19T17:40:00Z')\n  //. Just (new Date ('2011-01-19T17:40:00.000Z'))\n  //.\n  //. > S.parseDate ('today')\n  //. Nothing\n  //. ```\n  const parseDate = s => {\n    const date = new Date (s);\n    return isNaN (date.valueOf ()) ? Nothing : Just (date);\n  };\n  _.parseDate = {\n    consts: {},\n    types: [$.String, $.Maybe ($.ValidDate)],\n    impl: parseDate,\n  };\n\n  //  requiredNonCapturingGroup :: Array String -> String\n  const requiredNonCapturingGroup = xs => (\n    '(?:' + xs.join ('|') + ')'\n  );\n\n  //  optionalNonCapturingGroup :: Array String -> String\n  const optionalNonCapturingGroup = xs => (\n    requiredNonCapturingGroup (xs) + '?'\n  );\n\n  //  validFloatRepr :: RegExp\n  const validFloatRepr = new RegExp (\n    '^' +                     // start-of-string anchor\n    '\\\\s*' +                  // any number of leading whitespace characters\n    '[+-]?' +                 // optional sign\n    requiredNonCapturingGroup ([\n      'Infinity',             // \"Infinity\"\n      'NaN',                  // \"NaN\"\n      requiredNonCapturingGroup ([\n        '[0-9]+',             // number\n        '[0-9]+[.][0-9]+',    // number with interior decimal point\n        '[0-9]+[.]',          // number with trailing decimal point\n        '[.][0-9]+',          // number with leading decimal point\n      ]) +\n      optionalNonCapturingGroup ([\n        '[Ee]' +              // \"E\" or \"e\"\n        '[+-]?' +             // optional sign\n        '[0-9]+',             // exponent\n      ]),\n    ]) +\n    '\\\\s*' +                  // any number of trailing whitespace characters\n    '$'                       // end-of-string anchor\n  );\n\n  //# parseFloat :: String -> Maybe Number\n  //.\n  //. Takes a string and returns Just the number represented by the string\n  //. if it does in fact represent a number; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseFloat ('-123.45')\n  //. Just (-123.45)\n  //.\n  //. > S.parseFloat ('foo.bar')\n  //. Nothing\n  //. ```\n  const parseFloat_ = s => (\n    validFloatRepr.test (s) ? Just (parseFloat (s)) : Nothing\n  );\n  _.parseFloat = {\n    consts: {},\n    types: [$.String, $.Maybe ($.Number)],\n    impl: parseFloat_,\n  };\n\n  //  Radix :: Type\n  const Radix = $.NullaryType\n    ('Radix')\n    ('')\n    ([$.Integer])\n    (x => x >= 2 && x <= 36);\n\n  //# parseInt :: Radix -> String -> Maybe Integer\n  //.\n  //. Takes a radix (an integer between 2 and 36 inclusive) and a string,\n  //. and returns Just the number represented by the string if it does in\n  //. fact represent a number in the base specified by the radix; Nothing\n  //. otherwise.\n  //.\n  //. This function is stricter than [`parseInt`][parseInt]: a string\n  //. is considered to represent an integer only if all its non-prefix\n  //. characters are members of the character set specified by the radix.\n  //.\n  //. ```javascript\n  //. > S.parseInt (10) ('-42')\n  //. Just (-42)\n  //.\n  //. > S.parseInt (16) ('0xFF')\n  //. Just (255)\n  //.\n  //. > S.parseInt (16) ('0xGG')\n  //. Nothing\n  //. ```\n  const parseInt_ = radix => s => {\n    const charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice (0, radix);\n    const pattern = new RegExp ('^[' + charset + ']+$', 'i');\n\n    const t = s.replace (/^[+-]/, '');\n    if (pattern.test (radix === 16 ? t.replace (/^0x/i, '') : t)) {\n      const n = parseInt (s, radix);\n      if ($.test ([]) ($.Integer) (n)) return Just (n);\n    }\n    return Nothing;\n  };\n  _.parseInt = {\n    consts: {},\n    types: [Radix, $.String, $.Maybe ($.Integer)],\n    impl: parseInt_,\n  };\n\n  //# parseJson :: (Any -> Boolean) -> String -> Maybe a\n  //.\n  //. Takes a predicate and a string that may or may not be valid JSON, and\n  //. returns Just the result of applying `JSON.parse` to the string *if* the\n  //. result satisfies the predicate; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[')\n  //. Nothing\n  //.\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[\"1\",\"2\",\"3\"]')\n  //. Nothing\n  //.\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[0,1.5,3,4.5]')\n  //. Nothing\n  //.\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[1,2,3]')\n  //. Just ([1, 2, 3])\n  //. ```\n  const parseJson = pred => s => {\n    let x;\n    try {\n      x = JSON.parse (s);\n    } catch (_) {\n      return Nothing;\n    }\n    return pred (x) ? Just (x) : Nothing;\n  };\n  _.parseJson = {\n    consts: {},\n    types: [$.Predicate ($.Any), $.String, $.Maybe (a)],\n    impl: parseJson,\n  };\n\n  //. ### RegExp\n\n  //# regex :: RegexFlags -> String -> RegExp\n  //.\n  //. Takes a [RegexFlags][] and a pattern, and returns a RegExp.\n  //.\n  //. ```javascript\n  //. > S.regex ('g') (':\\\\d+:')\n  //. /:\\d+:/g\n  //. ```\n  const regex = flags => source => new RegExp (source, flags);\n  _.regex = {\n    consts: {},\n    types: [$.RegexFlags, $.String, $.RegExp],\n    impl: regex,\n  };\n\n  //# regexEscape :: String -> String\n  //.\n  //. Takes a string that may contain regular expression metacharacters,\n  //. and returns a string with those metacharacters escaped.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String.\n  //.      S.test (S.regex ('') (S.regexEscape (s))) (s) = true`\n  //.\n  //. ```javascript\n  //. > S.regexEscape ('-=*{XYZ}*=-')\n  //. '\\\\-=\\\\*\\\\{XYZ\\\\}\\\\*=\\\\-'\n  //. ```\n  const regexEscape = s => s.replace (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n  _.regexEscape = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: regexEscape,\n  };\n\n  //# test :: RegExp -> String -> Boolean\n  //.\n  //. Takes a pattern and a string, and returns `true` [iff][] the pattern\n  //. matches the string.\n  //.\n  //. ```javascript\n  //. > S.test (/^a/) ('abacus')\n  //. true\n  //.\n  //. > S.test (/^a/) ('banana')\n  //. false\n  //. ```\n  const test = pattern => s => {\n    const lastIndex = pattern.lastIndex;\n    const result = pattern.test (s);\n    pattern.lastIndex = lastIndex;\n    return result;\n  };\n  _.test = {\n    consts: {},\n    types: [$.RegExp, $.String, $.Boolean],\n    impl: test,\n  };\n\n  //# match :: NonGlobalRegExp -> String -> Maybe (Array (Maybe String))\n  //.\n  //. Takes a pattern and a string, and returns Just an array of captured\n  //. values if the pattern matches the string; Nothing otherwise.\n  //.\n  //. `Maybe String` acknowledges the existence of optional capturing groups.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall p :: Pattern, s :: String.\n  //.      S.head (S.matchAll (S.regex ('g') (p)) (s))\n  //.      = S.match (S.regex ('') (p)) (s)`\n  //.\n  //. See also [`matchAll`](#matchAll).\n  //.\n  //. ```javascript\n  //. > S.match (/^(.+[.].+?)(?::(.+))?$/) ('XXX')\n  //. Nothing\n  //.\n  //. > S.match (/^(.+[.].+?)(?::(.+))?$/) ('example.com')\n  //. Just ([Just ('example.com'), Nothing])\n  //.\n  //. > S.match (/^(.+[.].+?)(?::(.+))?$/) ('example.com:8888')\n  //. Just ([Just ('example.com'), Just ('8888')])\n  //. ```\n  const match = pattern => s => {\n    const match = s.match (pattern);\n    if (match == null) return Nothing;\n    const groups = new Array (match.length - 1);\n    for (let idx = 0; idx < groups.length; idx += 1) {\n      const group = match[idx + 1];\n      groups[idx] = group == null ? Nothing : Just (group);\n    }\n    return Just (groups);\n  };\n  _.match = {\n    consts: {},\n    types: [$.NonGlobalRegExp,\n            $.String,\n            $.Maybe ($.Array ($.Maybe ($.String)))],\n    impl: match,\n  };\n\n  //# matchAll :: GlobalRegExp -> String -> Array (Array (Maybe String))\n  //.\n  //. Takes a pattern and a string, and returns an array of arrays of captured\n  //. values.\n  //.\n  //. `Maybe String` acknowledges the existence of optional capturing groups.\n  //.\n  //. See also [`match`](#match).\n  //.\n  //. ```javascript\n  //. > S.matchAll (/@([a-z]+)/g) ('Hello, world!')\n  //. []\n  //.\n  //. > S.matchAll (/@([a-z]+)/g) ('Hello, @foo! Hello, @bar! Hello, @baz!')\n  //. [[Just ('foo')], [Just ('bar')], [Just ('baz')]]\n  //. ```\n  const matchAll = pattern => s => {\n    const lastIndex = pattern.lastIndex;\n    const result = [];\n    while (true) {\n      const match = pattern.exec (s);\n      if (match == null) {\n        pattern.lastIndex = lastIndex;\n        return result;\n      }\n      const groups = result[result.length] = new Array (match.length - 1);\n      for (let idx = 0; idx < groups.length; idx += 1) {\n        const group = match[idx + 1];\n        groups[idx] = group == null ? Nothing : Just (group);\n      }\n    }\n  };\n  _.matchAll = {\n    consts: {},\n    types: [$.GlobalRegExp, $.String, $.Array ($.Array ($.Maybe ($.String)))],\n    impl: matchAll,\n  };\n\n  //# replace :: (Array (Maybe String) -> String) -> RegExp -> String -> String\n  //.\n  //. Replaces occurrences of the given pattern within the given string\n  //. in accordance with the given replacement function, which receives an\n  //. array of captured values. Replaces all occurrences of the pattern if\n  //. its `g` flag is set; just the first occurrence otherwise.\n  //.\n  //. ```javascript\n  //. > S.replace (([$1]) => S.maybe ('') (S.toUpper) ($1)) (/(\\w)/) ('foo')\n  //. 'Foo'\n  //.\n  //. > S.replace (([$1]) => S.maybe ('') (S.toUpper) ($1)) (/(\\w)/g) ('foo')\n  //. 'FOO'\n  //.\n  //. > S.replace (S.show) (/(foo)(bar)?/) ('<>')\n  //. '<>'\n  //.\n  //. > S.replace (S.show) (/(foo)(bar)?/) ('<foo>')\n  //. '<[Just (\"foo\"), Nothing]>'\n  //.\n  //. > S.replace (S.show) (/(foo)(bar)?/) ('<foobar>')\n  //. '<[Just (\"foo\"), Just (\"bar\")]>'\n  //. ```\n  const replace = substitute => pattern => text => (\n    text.replace (pattern, (...args) => {\n      const groups = [];\n      for (let idx = 1; ; idx += 1) {\n        const arg = args[idx];\n        if (typeof arg === 'number') break;\n        groups.push (arg == null ? Nothing : Just (arg));\n      }\n      return substitute (groups);\n    })\n  );\n  _.replace = {\n    consts: {},\n    types: [$.Fn ($.Array ($.Maybe ($.String))) ($.String),\n            $.RegExp,\n            $.String,\n            $.String],\n    impl: replace,\n  };\n\n  //. ### String\n\n  //# toUpper :: String -> String\n  //.\n  //. Returns the upper-case equivalent of its argument.\n  //.\n  //. See also [`toLower`](#toLower).\n  //.\n  //. ```javascript\n  //. > S.toUpper ('ABC def 123')\n  //. 'ABC DEF 123'\n  //. ```\n  _.toUpper = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: invoke0 ('toUpperCase'),\n  };\n\n  //# toLower :: String -> String\n  //.\n  //. Returns the lower-case equivalent of its argument.\n  //.\n  //. See also [`toUpper`](#toUpper).\n  //.\n  //. ```javascript\n  //. > S.toLower ('ABC def 123')\n  //. 'abc def 123'\n  //. ```\n  _.toLower = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: invoke0 ('toLowerCase'),\n  };\n\n  //# trim :: String -> String\n  //.\n  //. Strips leading and trailing whitespace characters.\n  //.\n  //. ```javascript\n  //. > S.trim ('\\t\\t foo bar \\n')\n  //. 'foo bar'\n  //. ```\n  _.trim = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: invoke0 ('trim'),\n  };\n\n  //# stripPrefix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given prefix (the first argument) if the string starts\n  //. with the prefix; Nothing otherwise.\n  //.\n  //. See also [`stripSuffix`](#stripSuffix).\n  //.\n  //. ```javascript\n  //. > S.stripPrefix ('https://') ('https://sanctuary.js.org')\n  //. Just ('sanctuary.js.org')\n  //.\n  //. > S.stripPrefix ('https://') ('http://sanctuary.js.org')\n  //. Nothing\n  //. ```\n  const stripPrefix = prefix => s => (\n    s.startsWith (prefix) ?\n    Just (s.slice (prefix.length)) :\n    Nothing\n  );\n  _.stripPrefix = {\n    consts: {},\n    types: [$.String, $.String, $.Maybe ($.String)],\n    impl: stripPrefix,\n  };\n\n  //# stripSuffix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given suffix (the first argument) if the string ends\n  //. with the suffix; Nothing otherwise.\n  //.\n  //. See also [`stripPrefix`](#stripPrefix).\n  //.\n  //. ```javascript\n  //. > S.stripSuffix ('.md') ('README.md')\n  //. Just ('README')\n  //.\n  //. > S.stripSuffix ('.md') ('README')\n  //. Nothing\n  //. ```\n  const stripSuffix = suffix => s => (\n    s.endsWith (suffix) ?\n    Just (s.slice (0, s.length - suffix.length)) :\n    Nothing\n  );\n  _.stripSuffix = {\n    consts: {},\n    types: [$.String, $.String, $.Maybe ($.String)],\n    impl: stripSuffix,\n  };\n\n  //# words :: String -> Array String\n  //.\n  //. Takes a string and returns the array of words the string contains\n  //. (words are delimited by whitespace characters).\n  //.\n  //. See also [`unwords`](#unwords).\n  //.\n  //. ```javascript\n  //. > S.words (' foo bar baz ')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  const words = s => {\n    const words = s.split (/\\s+/);\n    const len = words.length;\n    return words.slice (words[0] === '' ? 1 : 0,\n                        words[len - 1] === '' ? len - 1 : len);\n  };\n  _.words = {\n    consts: {},\n    types: [$.String, $.Array ($.String)],\n    impl: words,\n  };\n\n  //# unwords :: Array String -> String\n  //.\n  //. Takes an array of words and returns the result of joining the words\n  //. with separating spaces.\n  //.\n  //. See also [`words`](#words).\n  //.\n  //. ```javascript\n  //. > S.unwords (['foo', 'bar', 'baz'])\n  //. 'foo bar baz'\n  //. ```\n  _.unwords = {\n    consts: {},\n    types: [$.Array ($.String), $.String],\n    impl: invoke1 ('join') (' '),\n  };\n\n  //# lines :: String -> Array String\n  //.\n  //. Takes a string and returns the array of lines the string contains\n  //. (lines are delimited by newlines: `'\\n'` or `'\\r\\n'` or `'\\r'`).\n  //. The resulting strings do not contain newlines.\n  //.\n  //. See also [`unlines`](#unlines).\n  //.\n  //. ```javascript\n  //. > S.lines ('foo\\nbar\\nbaz\\n')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  const lines = s => (\n    s === '' ? [] : (s.replace (/\\r\\n?/g, '\\n')).match (/^(?=[\\s\\S]).*/gm)\n  );\n  _.lines = {\n    consts: {},\n    types: [$.String, $.Array ($.String)],\n    impl: lines,\n  };\n\n  //# unlines :: Array String -> String\n  //.\n  //. Takes an array of lines and returns the result of joining the lines\n  //. after appending a terminating line feed (`'\\n'`) to each.\n  //.\n  //. See also [`lines`](#lines).\n  //.\n  //. ```javascript\n  //. > S.unlines (['foo', 'bar', 'baz'])\n  //. 'foo\\nbar\\nbaz\\n'\n  //. ```\n  const unlines = xs => xs.reduce ((s, x) => s + x + '\\n', '');\n  _.unlines = {\n    consts: {},\n    types: [$.Array ($.String), $.String],\n    impl: unlines,\n  };\n\n  //# splitOn :: String -> String -> Array String\n  //.\n  //. Returns the substrings of its second argument separated by occurrences\n  //. of its first argument.\n  //.\n  //. See also [`joinWith`](#joinWith) and [`splitOnRegex`](#splitOnRegex).\n  //.\n  //. ```javascript\n  //. > S.splitOn ('::') ('foo::bar::baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  _.splitOn = {\n    consts: {},\n    types: [$.String, $.String, $.Array ($.String)],\n    impl: invoke1 ('split'),\n  };\n\n  //# splitOnRegex :: GlobalRegExp -> String -> Array String\n  //.\n  //. Takes a pattern and a string, and returns the result of splitting the\n  //. string at every non-overlapping occurrence of the pattern.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String.\n  //.      S.joinWith (s)\n  //.                 (S.splitOnRegex (S.regex ('g') (S.regexEscape (s))) (t))\n  //.      = t`\n  //.\n  //. See also [`splitOn`](#splitOn).\n  //.\n  //. ```javascript\n  //. > S.splitOnRegex (/[,;][ ]*/g) ('foo, bar, baz')\n  //. ['foo', 'bar', 'baz']\n  //.\n  //. > S.splitOnRegex (/[,;][ ]*/g) ('foo;bar;baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  const splitOnRegex = pattern => s => {\n    const lastIndex = pattern.lastIndex;\n    const result = [];\n    let idx = 0;\n    while (true) {\n      const match = pattern.exec (s);\n      if (match == null) {\n        result.push (s.slice (idx));\n        break;\n      }\n      if (pattern.lastIndex === idx && match[0] === '') {\n        if (pattern.lastIndex === s.length) break;\n        pattern.lastIndex += 1;\n        continue;\n      }\n      result.push (s.slice (idx, match.index));\n      idx = match.index + match[0].length;\n    }\n    pattern.lastIndex = lastIndex;\n    return result;\n  };\n  _.splitOnRegex = {\n    consts: {},\n    types: [$.GlobalRegExp, $.String, $.Array ($.String)],\n    impl: splitOnRegex,\n  };\n\n  return create ({\n    checkTypes: typeof process === 'undefined'\n                || process == null\n                || process.env == null\n                || process.env.NODE_ENV !== 'production',\n    env: $.env,\n  });\n\n});\n\n//. [#438]:                     https://github.com/sanctuary-js/sanctuary/issues/438\n//. [#488]:                     https://github.com/sanctuary-js/sanctuary/issues/488\n//. [Apply]:                    v:fantasyland/fantasy-land#apply\n//. [Chain]:                    v:fantasyland/fantasy-land#chain\n//. [Either]:                   #section:either\n//. [Fantasy Land]:             v:fantasyland/fantasy-land\n//. [Foldable]:                 v:fantasyland/fantasy-land#foldable\n//. [Folktale]:                 https://folktale.origamitower.com/\n//. [GIGO]:                     https://en.wikipedia.org/wiki/Garbage_in,_garbage_out\n//. [Haskell]:                  https://www.haskell.org/\n//. [Kleisli]:                  https://en.wikipedia.org/wiki/Kleisli_category\n//. [Maybe]:                    #section:maybe\n//. [Nullable]:                 v:sanctuary-js/sanctuary-def#Nullable\n//. [PureScript]:               http://www.purescript.org/\n//. [Ramda]:                    https://ramdajs.com/\n//. [RegexFlags]:               v:sanctuary-js/sanctuary-def#RegexFlags\n//. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid\n//. [ValidDate]:                v:sanctuary-js/sanctuary-def#ValidDate\n//. [`$.test`]:                 v:sanctuary-js/sanctuary-def#test\n//. [`Descending`]:             v:sanctuary-js/sanctuary-descending#Descending\n//. [`R.__`]:                   https://ramdajs.com/docs/#__\n//. [`R.bind`]:                 https://ramdajs.com/docs/#bind\n//. [`R.invoker`]:              https://ramdajs.com/docs/#invoker\n//. [`Z.alt`]:                  v:sanctuary-js/sanctuary-type-classes#alt\n//. [`Z.ap`]:                   v:sanctuary-js/sanctuary-type-classes#ap\n//. [`Z.apFirst`]:              v:sanctuary-js/sanctuary-type-classes#apFirst\n//. [`Z.apSecond`]:             v:sanctuary-js/sanctuary-type-classes#apSecond\n//. [`Z.bimap`]:                v:sanctuary-js/sanctuary-type-classes#bimap\n//. [`Z.chain`]:                v:sanctuary-js/sanctuary-type-classes#chain\n//. [`Z.chainRec`]:             v:sanctuary-js/sanctuary-type-classes#chainRec\n//. [`Z.compose`]:              v:sanctuary-js/sanctuary-type-classes#compose\n//. [`Z.concat`]:               v:sanctuary-js/sanctuary-type-classes#concat\n//. [`Z.contramap`]:            v:sanctuary-js/sanctuary-type-classes#contramap\n//. [`Z.duplicate`]:            v:sanctuary-js/sanctuary-type-classes#duplicate\n//. [`Z.empty`]:                v:sanctuary-js/sanctuary-type-classes#empty\n//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.extend`]:               v:sanctuary-js/sanctuary-type-classes#extend\n//. [`Z.extract`]:              v:sanctuary-js/sanctuary-type-classes#extract\n//. [`Z.filter`]:               v:sanctuary-js/sanctuary-type-classes#filter\n//. [`Z.flip`]:                 v:sanctuary-js/sanctuary-type-classes#flip\n//. [`Z.foldMap`]:              v:sanctuary-js/sanctuary-type-classes#foldMap\n//. [`Z.gt`]:                   v:sanctuary-js/sanctuary-type-classes#gt\n//. [`Z.gte`]:                  v:sanctuary-js/sanctuary-type-classes#gte\n//. [`Z.id`]:                   v:sanctuary-js/sanctuary-type-classes#id\n//. [`Z.intercalate`]:          v:sanctuary-js/sanctuary-type-classes#intercalate\n//. [`Z.invert`]:               v:sanctuary-js/sanctuary-type-classes#invert\n//. [`Z.join`]:                 v:sanctuary-js/sanctuary-type-classes#join\n//. [`Z.lt`]:                   v:sanctuary-js/sanctuary-type-classes#lt\n//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte\n//. [`Z.map`]:                  v:sanctuary-js/sanctuary-type-classes#map\n//. [`Z.mapLeft`]:              v:sanctuary-js/sanctuary-type-classes#mapLeft\n//. [`Z.of`]:                   v:sanctuary-js/sanctuary-type-classes#of\n//. [`Z.promap`]:               v:sanctuary-js/sanctuary-type-classes#promap\n//. [`Z.reject`]:               v:sanctuary-js/sanctuary-type-classes#reject\n//. [`Z.sequence`]:             v:sanctuary-js/sanctuary-type-classes#sequence\n//. [`Z.traverse`]:             v:sanctuary-js/sanctuary-type-classes#traverse\n//. [`Z.zero`]:                 v:sanctuary-js/sanctuary-type-classes#zero\n//. [`apply2way`]:              https://hackage.haskell.org/package/yjtools-0.9.18/docs/Data-Function-Tools.html#v:apply2way\n//. [`converge`]:               https://ramdajs.com/docs/#converge\n//. [`show`]:                   v:sanctuary-js/sanctuary-show#show\n//. [date parsing]:             https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n//. [equivalence]:              https://en.wikipedia.org/wiki/Equivalence_relation\n//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n//. [parseInt]:                 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n//. [partial functions]:        https://en.wikipedia.org/wiki/Partial_function\n//. [ramda/ramda#683]:          https://github.com/ramda/ramda/issues/683\n//. [ramda/ramda#1413]:         https://github.com/ramda/ramda/issues/1413\n//. [ramda/ramda#1419]:         https://github.com/ramda/ramda/pull/1419\n//. [sanctuary-def]:            v:sanctuary-js/sanctuary-def\n//. [sanctuary-either]:         v:sanctuary-js/sanctuary-either\n//. [sanctuary-maybe]:          v:sanctuary-js/sanctuary-maybe\n//. [sanctuary-pair]:           v:sanctuary-js/sanctuary-pair\n//. [sanctuary-show]:           v:sanctuary-js/sanctuary-show\n//. [sanctuary-type-classes]:   v:sanctuary-js/sanctuary-type-classes\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [thrush]:                   https://github.com/raganwald-deprecated/homoiconic/blob/master/2008-10-30/thrush.markdown\n//. [total functions]:          https://en.wikipedia.org/wiki/Partial_function#Total_function\n//. [type checking]:            #section:type-checking\n//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers\n//. [type representative]:      v:fantasyland/fantasy-land#type-representatives\n//. [variadic functions]:       https://en.wikipedia.org/wiki/Variadic_function\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.921875,
          "content": "{\n  \"name\": \"sanctuary\",\n  \"version\": \"3.1.0\",\n  \"description\": \"Refuge from unsafe JavaScript\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/sanctuary-js/sanctuary.git\"\n  },\n  \"scripts\": {\n    \"doctest\": \"sanctuary-doctest\",\n    \"lint\": \"sanctuary-lint\",\n    \"release\": \"sanctuary-release\",\n    \"test\": \"npm run lint && sanctuary-test && npm run doctest\"\n  },\n  \"dependencies\": {\n    \"sanctuary-def\": \"0.22.0\",\n    \"sanctuary-either\": \"2.1.0\",\n    \"sanctuary-maybe\": \"2.1.0\",\n    \"sanctuary-pair\": \"2.1.0\",\n    \"sanctuary-show\": \"2.0.0\",\n    \"sanctuary-type-classes\": \"12.1.0\",\n    \"sanctuary-type-identifiers\": \"3.0.0\"\n  },\n  \"devDependencies\": {\n    \"fantasy-land\": \"5.0.0\",\n    \"jsverify\": \"0.8.x\",\n    \"sanctuary-descending\": \"2.1.0\",\n    \"sanctuary-identity\": \"2.1.0\",\n    \"sanctuary-scripts\": \"7.0.x\"\n  },\n  \"files\": [\n    \"/LICENSE\",\n    \"/README.md\",\n    \"/index.js\",\n    \"/package.json\"\n  ]\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}