{
  "metadata": {
    "timestamp": 1736561620180,
    "page": 175,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "primus/primus",
      "stars": 4471,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1015625,
          "content": "node_modules\n.tern-port\nnpm-debug.log\ntest/primus.save.async.js\ntest/primus.save.sync.js\n.DS_Store\ndist\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.08203125,
          "content": "node_modules/\nexamples/\nissues/\ntest/\ntransformers/*/*\n!transformers/*/*.js\n*.md\n.*\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 11.33203125,
          "content": "# Contributing\n\nWe welcome and encourage community contributions to our projects. This document\nspecifies the guidelines for contributing to the projects that are created under\nthe **primus** organization. We've split this document in smaller sections:\n\n- [Feature Requests](#feature-requests)\n- [Questions](#questions)\n- [Issues](#issues)\n  - [Outline of a good bug report](#outline-of-a-good-bug-report)\n  - [Labels](#labels)\n- [Code](#code)\n  - [The Boy Scout Rule](#the-boy-scout-rule)\n  - [Developer's Certificate of Origin](#developers-certificate-of-origin)\n- [Code of Conduct](#code-of-conduct)\n\nThere are always many ways you can help out this project besides contributing\nto the code:\n\n- Writing and improving our documentation.\n- Helping people out in our [IRC][irc] room.\n- Searching for potential memory leaks, event loops blocks and de-optimized\n  code.\n- Preforming security audits on the code base. Please check our\n  [SECURITY.md][security] for the Security Guidelines.\n- Filing bugs.\n\nAnd that list goes on and on. No matter what you choose we are thankful for your\ninterest and for the fact that you want to contribute to our projects. They are\nbuild and maintained with love and we hope to share some of that love with you.\n\n## Feature Requests\n\nYes! Make them! We would love to hear your idea(s) and what we can do to continue\nto move this project forward. Changes, big or small, are always welcomed. If the\nfeature requested is not in line with our roadmap we will work with you to\nensure that you can build it yourself on top of our project.\n\n## Questions\n\nWhen you're first starting out, you're bound to have questions about this\nproject. We hope that our documentation in the [README.md][readme] provides\nanswers to all your questions. In rare cases when the documentation does not\nanswer your question you could:\n\n1. Join our [IRC][irc] room and ask the question there. The authors,\n   contributors and users of this project usually hang around there.\n2. Create an issue on GitHub thoroughly explaining your issue. The more\n   information you provide us with, the better we can help you.\n\nWe will do our best to answer your questions in a timely manner. Please note\nthat if you create a new issue and put everything in the title with no\nexplanation in the body, it will be closed and locked immediately and you'll\nbe prompted to follow the instructions contained in this file.\n\n## Issues\n\n**If you have a security related issue, please review [Security\nGuidelines][security] first.**\n\nBefore creating an issue make sure that you are using the latest version of the\nmodule as the issue you report could be already resolved. If you are using the\nlatest version please use the Github search feature to check if the issue is\nalready known. If you've found an issue that is:\n\n- **closed:** Check if the issue provides a solution for your issue. If it's\n  already fixed using a commit it could be that there have been a regression in\n  the code. In this case it's best to open a new issue. For all other cases it\n  might make more sense to just add comment to the closed issue explaining that\n  you're still affected by this.\n- **open:** Try to provide more details to the issue. If you can reproduce the\n  issue in a different way than the one used by the original author, please add\n  this. The more ways we have to reproduce the bug, the more are the chances to\n  get it fixed fast.\n- **missing:** Please open a new issue, we would love to hear more about it.\n\n### Outline of a good bug report\n\nWhen reporting new issues for the project please use the following issue\ntemplate so you know what kind of data you need to supply and we can resolve it\nas quickly as possible. If some of these fields do not apply to your issue feel\nfree to leave them empty or remove them completely:\n\n```\n**Version:**\n\n**Environment:**\n  - **Operating system**:\n  - **browser**:\n  - **Nodejs**:\n  - **npm**:\n\n**Expected result:**\n\n**Actual result:**\n\n**Steps to reproduce:**\n\n1. Step 1.\n2. Step 2.\n3. Things are broken.\n```\n\nHere is a small explanation of the fields and what kind of information could be\npresent in them.\n\n- **Version:** The version number of the module that you're currently using. If\n  you don't know the current version number you can check it by running `npm ls`\n  in your terminal.\n- **Environment:** This allows us to narrow down the issue to a potential platform\n  or version if we cannot reproduce it on our own machines. If you don't know\n  your npm and node.js version you can run `npm version` in your terminal and it\n  will output all the information you need. If you are reporting a node.js\n  specific bug you can omit the browser field unless it requires a browser to\n  reproduce it.\n- **Expected result:** What did you expect would happen.\n- **Actual result:** What actually happened when you executed the code.\n- **Steps to reproduce:** Every step to fully reproduce the issue is described\n  here, no matter how small. You cannot be specific enough. It's better to have\n  too much details than too few here.\n\nA complete example of this would be:\n\n```\nVersion: 0.0.1\nEnvironment:\n  - Operating System: Mac OSX 10.10.1 (14B25)\n  - Node: 0.10.31\n  - npm: 1.4.28\n  - browser: Google Chrome, Version 39.0.2171.71 (64-bit)\n\nExpected result: A `console.log` message in the terminal.\n\nActual result: An empty console without any log messages.\n\nSteps to reproduce:\n\n1. Open Chrome.\n2. Open the Developer tools panel.\n3. Type `console.log('message')`.\n4. Press enter to execute the code.\n```\n\nWhen adding code to your example please use [code fencing][fencing] to ensure\nthat your snippet is highlighted correctly. This greatly improves the\nreadability of the issue.\n\n### Labels\n\nWe try to label all created issues to facilitate the identification of the\nissue scope. We also label all issues with a `★`. The more stars an issue has\nthe more important it is. We currently have three different levels of\nimportance:\n\n- **`★★★`**: High priority issue, should be addressed as soon as possible. We\n  will do our best to include this in the next release. This however does not\n  mean that no issue is closed or fixed before these high priority issues.\n- **`★★`**: Medium priority, this should be fixed but it might not make the next\n  release.\n- **`★`**: Low priority issue, don't expect this to be resolved soon. These bugs\n  are generally fixed on a rainy or boring day. These bugs are also great\n  for first time contributors who are looking for something to fix.\n\n## Code\n\nUnless you are fixing a known bug we **strongly** encourage to discuss your\nfeature with the core team via a GitHub issue or [IRC][irc]. Before getting\nstarted ensure that your work will not rejected.\n\nAll contributions must be made via pull requests. After a pull request is made\nother contributors will either provide feedback or merge it directly depending\non:\n\n- Addition of new tests and passing of the test suite.\n- Code coverage.\n- The severity of the bug that the code is addressing.\n- The overall quality of patch.\n\nWe expect that every bug fix comes with new tests for our test suite. This is\nimportant to prevent regression in the future as our current set of tests did\nnot trigger the code path.\n\n### The Boy Scout Rule\n\nWhen working with the code try to follow the rule that The Boy Scouts have:\n\n> Always leave the campground cleaner than you found it.\n\nIf you find a mess on the ground, you clean it up regardless of who might have\nmade the mess. You intentionally improve the environment for the next group of\ncampers. Working with code should not be an exception to this. If you find\na mess in the code, clean it up no matter who the original author was.\n\n### Developer's Certificate of Origin\n\nAll contributors must agree to the [Developers Certificate of Origin][dco]:\n\n```\nDeveloper Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n660 York Street, Suite 102,\nSan Francisco, CA 94110 USA\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n```\n\nTo accept the DCO, add the following line to each commit message with your name\nand email address:\n\n```\nSigned-off-by: Joe Longpolland <joe@example.com>\n```\n\nYou can automate this process by simply committing your code using the `-s`\noption:\n\n```\ngit commit -s\n```\n\nFor legal reasons we cannot accept anonymous, pseudonymous or nick names. If\nthis is an issue please contact us directly through [IRC][irc].\n\n## Code of Conduct\n\n- We are committed to providing a friendly, safe and welcoming environment for\n  all, regardless of gender, sexual orientation, disability, ethnicity, religion,\n  or similar personal characteristic.\n- Please avoid using overtly sexual nicknames or other nicknames that might\n  detract from a friendly, safe and welcoming environment for all.\n- Please be kind and courteous. There's no need to be mean or rude.\n- Respect that people have differences of opinion and that every design or\n  implementation choice carries a trade-off and numerous costs. There is seldom a\n  right answer.\n- Please keep unstructured critique to a minimum. If you have solid ideas you\n  want to experiment with, make a fork and see how it works.\n- We will exclude you from interaction if you insult, demean or harass anyone.\n  That is not welcome behaviour. We interpret the term \"harassment\" as including\n  the definition in the Citizen Code of Conduct; if you have any lack of clarity\n  about what might be included in that concept, please read their definition. In\n  particular, we don't tolerate behavior that excludes people in socially\n  marginalized groups.\n- Private harassment is also unacceptable. No matter who you are, if you feel\n  you have been or are being harassed or made uncomfortable by a community\n  member, please contact one of the channel ops or any of the core contributors\n  immediately with a capture (log, photo, email) of the harassment if possible.\n  Whether you're a regular contributor or a newcomer, we care about making this\n  community a safe place for you and we've got your back.\n- Likewise any spamming, trolling, flaming, baiting or other attention-stealing\n  behaviour is not welcome.\n\n[dco]: http://elinux.org/Developer_Certificate_Of_Origin\n[irc]: https://webchat.freenode.net/?channels=primus\n[fencing]: https://help.github.com/articles/github-flavored-markdown/#fenced-code-blocks\n[security]: SECURITY.md\n[readme]: README.md\n"
        },
        {
          "name": "HEALTH.md",
          "type": "blob",
          "size": 17.8154296875,
          "content": "# Health\n\nThese are the projects that we're currently supporting under the **primus**\norganization. This is a good indication about the scope of this undertaking and\nthe state/health of the various projects.\n\nProject                              | Version                                                            |Build status                                                               | Coverage\n-------------------------------------|--------------------------------------------------------------------|---------------------------------------------------------------------------|---------------------------------------------------------------------------------\n[primus][primus]                     | [![Version npm][npm-primus-badge]][npm-primus]                     | [![Build Status][ci-primus-badge]][ci-primus]                     | [![Coverage Status][coverage-primus-badge]][coverage-primus]\n[access-control][access-control]     | [![Version npm][npm-access-control-badge]][npm-access-control]     | [![Build Status][ci-access-control-badge]][ci-access-control]     | [![Coverage Status][coverage-access-control-badge]][coverage-access-control]\n[asyncemit][asyncemit]               | [![Version npm][npm-asyncemit-badge]][npm-asyncemit]               | [![Build Status][ci-asyncemit-badge]][ci-asyncemit]               | [![Coverage Status][coverage-asyncemit-badge]][coverage-asyncemit]\n[binary-pack][binary-pack]           | [![Version npm][npm-binary-pack-badge]][npm-binary-pack]           | [![Build Status][ci-binary-pack-badge]][ci-binary-pack]           | [![Coverage Status][coverage-binary-pack-badge]][coverage-binary-pack]\n[condenseify][condenseify]           | [![Version npm][npm-condenseify-badge]][npm-condenseify]           | [![Build Status][ci-condenseify-badge]][ci-condenseify]           | [![Coverage Status][coverage-condenseify-badge]][coverage-condenseify]\n[create-server][create-server]       | [![Version npm][npm-create-server-badge]][npm-create-server]       | [![Build Status][ci-create-server-badge]][ci-create-server]       | [![Coverage Status][coverage-create-server-badge]][coverage-create-server]\n[deumdify][deumdify]                 | [![Version npm][npm-deumdify-badge]][npm-deumdify]                 | [![Build Status][ci-deumdify-badge]][ci-deumdify]                 | [![Coverage Status][coverage-deumdify-badge]][coverage-deumdify]\n[ejson][ejson]                       | [![Version npm][npm-ejson-badge]][npm-ejson]                       | [![Build Status][ci-ejson-badge]][ci-ejson]                       | [![Coverage Status][coverage-ejson-badge]][coverage-ejson]\n[emits][emits]                       | [![Version npm][npm-emits-badge]][npm-emits]                       | [![Build Status][ci-emits-badge]][ci-emits]                       | [![Coverage Status][coverage-emits-badge]][coverage-emits]\n[eventemitter3][eventemitter3]       | [![Version npm][npm-eventemitter3-badge]][npm-eventemitter3]       | [![Build Status][ci-eventemitter3-badge]][ci-eventemitter3]       | [![Coverage Status][coverage-eventemitter3-badge]][coverage-eventemitter3]\n[fortress-maximus][fortress-maximus] | [![Version npm][npm-fortress-maximus-badge]][npm-fortress-maximus] | [![Build Status][ci-fortress-maximus-badge]][ci-fortress-maximus] | [![Coverage Status][coverage-fortress-maximus-badge]][coverage-fortress-maximus]\n[forwarded-for][forwarded-for]       | [![Version npm][npm-forwarded-for-badge]][npm-forwarded-for]       | [![Build Status][ci-forwarded-for-badge]][ci-forwarded-for]       | [![Coverage Status][coverage-forwarded-for-badge]][coverage-forwarded-for]\n[metroplex][metroplex]               | [![Version npm][npm-metroplex-badge]][npm-metroplex]               | [![Build Status][ci-metroplex-badge]][ci-metroplex]               | [![Coverage Status][coverage-metroplex-badge]][coverage-metroplex]\n[mirage][mirage]                     | [![Version npm][npm-mirage-badge]][npm-mirage]                     | [![Build Status][ci-mirage-badge]][ci-mirage]                     | [![Coverage Status][coverage-mirage-badge]][coverage-mirage]\n[omega-supreme][omega-supreme]       | [![Version npm][npm-omega-supreme-badge]][npm-omega-supreme]       | [![Build Status][ci-omega-supreme-badge]][ci-omega-supreme]       | [![Coverage Status][coverage-omega-supreme-badge]][coverage-omega-supreme]\n[primacron][primacron]               | [![Version npm][npm-primacron-badge]][npm-primacron]               | [![Build Status][ci-primacron-badge]][ci-primacron]               | [![Coverage Status][coverage-primacron-badge]][coverage-primacron]\n[primus-analytics][primus-analytics] | [![Version npm][npm-primus-analytics-badge]][npm-primus-analytics] | [![Build Status][ci-primus-analytics-badge]][ci-primus-analytics] | [![Coverage Status][coverage-primus-analytics-badge]][coverage-primus-analytics]\n[primus-emit][primus-emit]           | [![Version npm][npm-primus-emit-badge]][npm-primus-emit]           | [![Build Status][ci-primus-emit-badge]][ci-primus-emit]           | [![Coverage Status][coverage-primus-emit-badge]][coverage-primus-emit]\n[primus-msgpack][primus-msgpack]     | [![Version npm][npm-primus-msgpack-badge]][npm-primus-msgpack]     | [![Build Status][ci-primus-msgpack-badge]][ci-primus-msgpack]     | [![Coverage Status][coverage-primus-msgpack-badge]][coverage-primus-msgpack]\n[substream][substream]               | [![Version npm][npm-substream-badge]][npm-substream]               | [![Build Status][ci-substream-badge]][ci-substream]               | [![Coverage Status][coverage-substream-badge]][coverage-substream]\n\n[primus]: https://github.com/primus/primus\n[npm-primus-badge]: https://img.shields.io/npm/v/primus.svg?style=flat-square\n[npm-primus]: https://www.npmjs.com/package/primus\n[ci-primus-badge]: https://img.shields.io/github/actions/workflow/status/primus/primus/ci.yml?branch=master&label=CI&style=flat-square\n[ci-primus]: https://github.com/primus/primus/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-primus-badge]: https://img.shields.io/coveralls/primus/primus/master.svg?style=flat-square\n[coverage-primus]: https://coveralls.io/r/primus/primus?branch=master\n\n[access-control]: https://github.com/primus/access-control\n[npm-access-control-badge]: https://img.shields.io/npm/v/access-control.svg?style=flat-square\n[npm-access-control]: https://www.npmjs.com/package/access-control\n[ci-access-control-badge]: https://img.shields.io/github/actions/workflow/status/primus/access-control/ci.yml?branch=master&label=CI&style=flat-square\n[ci-access-control]: https://github.com/primus/access-control/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-access-control-badge]: https://img.shields.io/coveralls/primus/access-control/master.svg?style=flat-square\n[coverage-access-control]: https://coveralls.io/r/primus/access-control?branch=master\n\n[asyncemit]: https://github.com/primus/asyncemit\n[npm-asyncemit-badge]: https://img.shields.io/npm/v/asyncemit.svg?style=flat-square\n[npm-asyncemit]: https://www.npmjs.com/package/asyncemit\n[ci-asyncemit-badge]: https://img.shields.io/github/actions/workflow/status/primus/asyncemit/ci.yml?branch=master&label=CI&style=flat-square\n[ci-asyncemit]: https://github.com/primus/asyncemit/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-asyncemit-badge]: https://img.shields.io/coveralls/primus/asyncemit/master.svg?style=flat-square\n[coverage-asyncemit]: https://coveralls.io/r/primus/asyncemit?branch=master\n\n[binary-pack]: https://github.com/primus/binary-pack\n[npm-binary-pack-badge]: https://img.shields.io/npm/v/binary-pack.svg?style=flat-square\n[npm-binary-pack]: https://www.npmjs.com/package/binary-pack\n[ci-binary-pack-badge]: https://img.shields.io/github/actions/workflow/status/primus/binary-pack/ci.yml?branch=master&label=CI&style=flat-square\n[ci-binary-pack]: https://github.com/primus/binary-pack/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-binary-pack-badge]: https://img.shields.io/coveralls/primus/binary-pack/master.svg?style=flat-square\n[coverage-binary-pack]: https://coveralls.io/r/primus/binary-pack?branch=master\n\n[condenseify]: https://github.com/primus/condenseify\n[npm-condenseify-badge]: https://img.shields.io/npm/v/condenseify.svg?style=flat-square\n[npm-condenseify]: https://www.npmjs.com/package/condenseify\n[ci-condenseify-badge]: https://img.shields.io/github/actions/workflow/status/primus/condenseify/ci.yml?branch=master&label=CI&style=flat-square\n[ci-condenseify]: https://github.com/primus/condenseify/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-condenseify-badge]: https://img.shields.io/coveralls/primus/condenseify/master.svg?style=flat-square\n[coverage-condenseify]: https://coveralls.io/r/primus/condenseify?branch=master\n\n[create-server]: https://github.com/primus/create-server\n[npm-create-server-badge]: https://img.shields.io/npm/v/create-server.svg?style=flat-square\n[npm-create-server]: https://www.npmjs.com/package/create-server\n[ci-create-server-badge]: https://img.shields.io/github/actions/workflow/status/primus/create-server/ci.yml?branch=master&label=CI&style=flat-square\n[ci-create-server]: https://github.com/primus/create-server/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-create-server-badge]: https://img.shields.io/coveralls/primus/create-server/master.svg?style=flat-square\n[coverage-create-server]: https://coveralls.io/r/primus/create-server?branch=master\n\n[deumdify]: https://github.com/primus/deumdify\n[npm-deumdify-badge]: https://img.shields.io/npm/v/deumdify.svg?style=flat-square\n[npm-deumdify]: https://www.npmjs.com/package/deumdify\n[ci-deumdify-badge]: https://img.shields.io/github/actions/workflow/status/primus/deumdify/ci.yml?branch=master&label=CI&style=flat-square\n[ci-deumdify]: https://github.com/primus/deumdify/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-deumdify-badge]: https://img.shields.io/coveralls/primus/deumdify/master.svg?style=flat-square\n[coverage-deumdify]: https://coveralls.io/r/primus/deumdify?branch=master\n\n[ejson]: https://github.com/primus/ejson\n[npm-ejson-badge]: https://img.shields.io/npm/v/ejson.svg?style=flat-square\n[npm-ejson]: https://www.npmjs.com/package/ejson\n[ci-ejson-badge]: https://img.shields.io/github/actions/workflow/status/primus/ejson/ci.yml?branch=master&label=CI&style=flat-square\n[ci-ejson]: https://github.com/primus/ejson/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-ejson-badge]: https://img.shields.io/coveralls/primus/ejson/master.svg?style=flat-square\n[coverage-ejson]: https://coveralls.io/r/primus/ejson?branch=master\n\n[emits]: https://github.com/primus/emits\n[npm-emits-badge]: https://img.shields.io/npm/v/emits.svg?style=flat-square\n[npm-emits]: https://www.npmjs.com/package/emits\n[ci-emits-badge]: https://img.shields.io/github/actions/workflow/status/primus/emits/ci.yml?branch=master&label=CI&style=flat-square\n[ci-emits]: https://github.com/primus/emits/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-emits-badge]: https://img.shields.io/coveralls/primus/emits/master.svg?style=flat-square\n[coverage-emits]: https://coveralls.io/r/primus/emits?branch=master\n\n[eventemitter3]: https://github.com/primus/eventemitter3\n[npm-eventemitter3-badge]: https://img.shields.io/npm/v/eventemitter3.svg?style=flat-square\n[npm-eventemitter3]: https://www.npmjs.com/package/eventemitter3\n[ci-eventemitter3-badge]: https://img.shields.io/github/actions/workflow/status/primus/eventemitter3/ci.yml?branch=master&label=CI&style=flat-square\n[ci-eventemitter3]: https://github.com/primus/eventemitter3/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-eventemitter3-badge]: https://img.shields.io/coveralls/primus/eventemitter3/master.svg?style=flat-square\n[coverage-eventemitter3]: https://coveralls.io/r/primus/eventemitter3?branch=master\n\n[fortress-maximus]: https://github.com/primus/fortress-maximus\n[npm-fortress-maximus-badge]: https://img.shields.io/npm/v/fortress-maximus.svg?style=flat-square\n[npm-fortress-maximus]: https://www.npmjs.com/package/fortress-maximus\n[ci-fortress-maximus-badge]: https://img.shields.io/github/actions/workflow/status/primus/fortress-maximus/ci.yml?branch=master&label=CI&style=flat-square\n[ci-fortress-maximus]: https://github.com/primus/fortress-maximus/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-fortress-maximus-badge]: https://img.shields.io/coveralls/primus/fortress-maximus/master.svg?style=flat-square\n[coverage-fortress-maximus]: https://coveralls.io/r/primus/fortress-maximus?branch=master\n\n[forwarded-for]: https://github.com/primus/forwarded-for\n[npm-forwarded-for-badge]: https://img.shields.io/npm/v/forwarded-for.svg?style=flat-square\n[npm-forwarded-for]: https://www.npmjs.com/package/forwarded-for\n[ci-forwarded-for-badge]: https://img.shields.io/github/actions/workflow/status/primus/forwarded-for/ci.yml?branch=master&label=CI&style=flat-square\n[ci-forwarded-for]: https://github.com/primus/forwarded-for/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-forwarded-for-badge]: https://img.shields.io/coveralls/primus/forwarded-for/master.svg?style=flat-square\n[coverage-forwarded-for]: https://coveralls.io/r/primus/forwarded-for?branch=master\n\n[metroplex]: https://github.com/primus/metroplex\n[npm-metroplex-badge]: https://img.shields.io/npm/v/metroplex.svg?style=flat-square\n[npm-metroplex]: https://www.npmjs.com/package/metroplex\n[ci-metroplex-badge]: https://img.shields.io/github/actions/workflow/status/primus/metroplex/ci.yml?branch=master&label=CI&style=flat-square\n[ci-metroplex]: https://github.com/primus/metroplex/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-metroplex-badge]: https://img.shields.io/coveralls/primus/metroplex/master.svg?style=flat-square\n[coverage-metroplex]: https://coveralls.io/r/primus/metroplex?branch=master\n\n[mirage]: https://github.com/primus/mirage\n[npm-mirage-badge]: https://img.shields.io/npm/v/mirage.svg?style=flat-square\n[npm-mirage]: https://www.npmjs.com/package/mirage\n[ci-mirage-badge]: https://img.shields.io/github/actions/workflow/status/primus/mirage/ci.yml?branch=master&label=CI&style=flat-square\n[ci-mirage]: https://github.com/primus/mirage/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-mirage-badge]: https://img.shields.io/coveralls/primus/mirage/master.svg?style=flat-square\n[coverage-mirage]: https://coveralls.io/r/primus/mirage?branch=master\n\n[omega-supreme]: https://github.com/primus/omega-supreme\n[npm-omega-supreme-badge]: https://img.shields.io/npm/v/omega-supreme.svg?style=flat-square\n[npm-omega-supreme]: https://www.npmjs.com/package/omega-supreme\n[ci-omega-supreme-badge]: https://img.shields.io/github/actions/workflow/status/primus/omega-supreme/ci.yml?branch=master&label=CI&style=flat-square\n[ci-omega-supreme]: https://github.com/primus/omega-supreme/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-omega-supreme-badge]: https://img.shields.io/coveralls/primus/omega-supreme/master.svg?style=flat-square\n[coverage-omega-supreme]: https://coveralls.io/r/primus/omega-supreme?branch=master\n\n[primacron]: https://github.com/primus/primacron\n[npm-primacron-badge]: https://img.shields.io/npm/v/primacron.svg?style=flat-square\n[npm-primacron]: https://www.npmjs.com/package/primacron\n[ci-primacron-badge]: https://img.shields.io/github/actions/workflow/status/primus/primacron/ci.yml?branch=master&label=CI&style=flat-square\n[ci-primacron]: https://github.com/primus/primacron/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-primacron-badge]: https://img.shields.io/coveralls/primus/primacron/master.svg?style=flat-square\n[coverage-primacron]: https://coveralls.io/r/primus/primacron?branch=master\n\n[primus-analytics]: https://github.com/primus/primus-analytics\n[npm-primus-analytics-badge]: https://img.shields.io/npm/v/primus-analytics.svg?style=flat-square\n[npm-primus-analytics]: https://www.npmjs.com/package/primus-analytics\n[ci-primus-analytics-badge]: https://img.shields.io/github/actions/workflow/status/primus/primus-analytics/ci.yml?branch=master&label=CI&style=flat-square\n[ci-primus-analytics]: https://github.com/primus/primus-analytics/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-primus-analytics-badge]: https://img.shields.io/coveralls/primus/primus-analytics/master.svg?style=flat-square\n[coverage-primus-analytics]: https://coveralls.io/r/primus/primus-analytics?branch=master\n\n[primus-emit]: https://github.com/primus/primus-emit\n[npm-primus-emit-badge]: https://img.shields.io/npm/v/primus-emit.svg?style=flat-square\n[npm-primus-emit]: https://www.npmjs.com/package/primus-emit\n[ci-primus-emit-badge]: https://img.shields.io/github/actions/workflow/status/primus/primus-emit/ci.yml?branch=master&label=CI&style=flat-square\n[ci-primus-emit]: https://github.com/primus/primus-emit/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-primus-emit-badge]: https://img.shields.io/coveralls/primus/primus-emit/master.svg?style=flat-square\n[coverage-primus-emit]: https://coveralls.io/r/primus/primus-emit?branch=master\n\n[primus-msgpack]: https://github.com/primus/primus-msgpack\n[npm-primus-msgpack-badge]: https://img.shields.io/npm/v/primus-msgpack.svg?style=flat-square\n[npm-primus-msgpack]: https://www.npmjs.com/package/primus-msgpack\n[ci-primus-msgpack-badge]: https://img.shields.io/github/actions/workflow/status/primus/primus-msgpack/ci.yml?branch=master&label=CI&style=flat-square\n[ci-primus-msgpack]: https://github.com/primus/primus-msgpack/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-primus-msgpack-badge]: https://img.shields.io/coveralls/primus/primus-msgpack/master.svg?style=flat-square\n[coverage-primus-msgpack]: https://coveralls.io/r/primus/primus-msgpack?branch=master\n\n[substream]: https://github.com/primus/substream\n[npm-substream-badge]: https://img.shields.io/npm/v/substream.svg?style=flat-square\n[npm-substream]: https://www.npmjs.com/package/substream\n[ci-substream-badge]: https://img.shields.io/github/actions/workflow/status/primus/substream/ci.yml?branch=master&label=CI&style=flat-square\n[ci-substream]: https://github.com/primus/substream/actions?query=workflow%3ACI+branch%3Amaster\n[coverage-substream-badge]: https://img.shields.io/coveralls/primus/substream/master.svg?style=flat-square\n[coverage-substream]: https://coveralls.io/r/primus/substream?branch=master\n"
        },
        {
          "name": "ISSUE_TEMPLATE.md",
          "type": "blob",
          "size": 0.154296875,
          "content": "**Version:**\n\n**Environment:**\n  - **Operating system:**\n  - **Browser:**\n  - **Node.js:**\n\n**Expected result:**\n\n**Actual result:**\n\n**Steps to reproduce:**\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.076171875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Arnout Kazemier, the Contributors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 79.021484375,
          "content": "# Primus\n\n[![Version npm](https://img.shields.io/npm/v/primus.svg?style=flat-square)](https://www.npmjs.com/package/primus)[![CI](https://img.shields.io/github/actions/workflow/status/primus/primus/ci.yml?branch=master&label=CI&style=flat-square)](https://github.com/primus/primus/actions?query=workflow%3ACI+branch%3Amaster)[![Coverage Status](https://img.shields.io/coveralls/primus/primus/master.svg?style=flat-square)](https://coveralls.io/r/primus/primus?branch=master)\n\nPrimus, the creator god of transformers but now also known as universal wrapper\nfor real-time frameworks. There are a lot of real-time frameworks available for\nNode.js and they all have different opinions on how real-time should be done.\nPrimus provides a common low level interface to communicate in real-time using\nvarious real-time frameworks.\n\n### Advantages\n\n1. Effortless switching between real-time frameworks by changing one single line\n   of code. No more API rewrites needed when your project requirements change,\n   the framework gets abandoned or simply breaks down.\n2. Built-in reconnect, it just works. The reconnect is controlled by a\n   randomised exponential back-off algorithm to reduce server stress.\n3. Offline detection, Primus is smart enough to detect when users drop their\n   internet connection (switching WIFI points/cell towers for example) and\n   reconnects when they are back online.\n4. Automatically encodes and decodes messages using custom parsers. Can be\n   easily switched for binary encoding for example.\n5. A clean, stream-compatible interface for the client and server. You can\n   just `stream#pipe` data around. In addition to that, the client works on\n   Node.js as well, write once, run it everywhere.\n6. Fixes various of bugs in the supported frameworks and additional stability\n   patches to improve real-time communication.\n8. Comes with an amazing plugin interface to keep the core library as fast and\n   lean as possible while still allowing the server and the client to be\n   extended.\n9. Last but not least, Primus is built with love, passion and dedication to the\n   real-time web.\n\n### Installation\n\nPrimus is released on `npm` and can be installed using:\n\n```\nnpm install primus --save\n```\n\n### Before Starting\n\nIf you deploy your application behind a reverse proxy (Nginx, HAProxy, etc.) you\nmight need to add WebSocket specific settings to its configuration files. If\nyou intend to use WebSockets, please ensure that these settings have been added.\nThere are some example configuration files available in the\n[observing/balancerbattle](https://github.com/observing/balancerbattle)\nrepository.\n\n### Table of Contents\n\n- [Introduction](#primus)\n  - [Advantages](#advantages)\n- [Installation](#installation)\n- [Getting started](#getting-started)\n  - [Client library](#client-library)\n- [Connecting from the browser](#connecting-from-the-browser)\n- [Connecting from the server](#connecting-from-the-server)\n- [Authorization](#authorization)\n- [Broadcasting](#broadcasting)\n- [Destruction](#destruction)\n- [Events](#events)\n- [Heartbeats and latency](#heartbeats-and-latency)\n- [Supported real-time frameworks](#supported-real-time-frameworks)\n  - [BrowserChannel](#browserchannel)\n  - [Engine.IO](#engineio)\n  - [Faye](#faye)\n  - [SockJS](#sockjs)\n  - [uws](#uws)\n  - [WebSockets](#websockets)\n- [Transformer inconsistencies](#transformer-inconsistencies)\n- [Parsers](#parsers)\n- [Middleware](#middleware)\n- [Plugins](#plugins)\n  - [Extending the Spark / Socket](#extending-the-spark--socket)\n  - [Transforming and intercepting messages](#transforming-and-intercepting-messages)\n  - [Primus project plugins](#primus-project-plugins)\n  - [Community plugins](#community-plugins)\n- [Community](#community)\n- [FAQ](#FAQ)\n  - [Scaling](#what-is-the-best-way-to-scale-primus)\n  - [Cluster](#can-i-use-cluster)\n  - [Express](#how-do-i-use-primus-with-express)\n  - [RequireJS](#is-requirejs-supported)\n  - [Custom headers](#can-i-send-custom-headers-to-the-server)\n- [Versioning](#versioning)\n  - [History](#history)\n  - [Convention](#convention)\n  - [Release cycle](#release-cycle)\n- [Other languages](#other-languages)\n  - [Protocol](#protocol)\n- [License](#license)\n\n### Getting started\n\nPrimus doesn't ship with real-time frameworks as dependencies, it assumes that\nyou as user add them yourself as a dependency. This is done to keep the module\nas lightweight as possible. This works because `require` in will walk through\nyour directories searching for `node_module` folders that have these matching\ndependencies.\n\nPrimus needs to be \"attached\" to a HTTP compatible server. These includes the\nbuilt-in `http` and `https` servers but also the `spdy` module as it has the\nsame API as node servers. Creating a new Primus instance is relatively\nstraightforward:\n\n```js\n'use strict';\n\nvar Primus = require('primus')\n  , http = require('http');\n\nvar server = http.createServer(/* request handler */)\n  , primus = new Primus(server, {/* options */});\n```\nThe following options can be provided:\n\nName                | Description                               | Default\n--------------------|-------------------------------------------|---------------\nauthorization       | Authorization handler                     | `null`\npathname            | The URL namespace that Primus can own     | `/primus`\nparser              | Message encoder for all communication     | `JSON`\ntransformer         | The transformer we should use internally  | `websockets`\nplugin              | The plugins that should be applied        | `{}`\npingInterval        | Interval at which heartbeats are sent     | `30000`\nglobal              | Set a custom client class / global name   | `Primus`\ncompression         | Use permessage-deflate / HTTP compression | `false`\nmaxLength           | Maximum allowed packet size, in bytes     | `10485760`\ntransport           | Transformer specific configuration        | `{}`\nidGenerator         | Custom spark id generator function        | `undefined`\norigins             | **cors** List of origins                  | `*`\nmethods             | **cors** List of accepted HTTP methods    | `GET,HEAD,PUT,POST,DELETE,OPTIONS`\ncredentials         | **cors** Allow sending of credentials     | `true`\nmaxAge              | **cors** Cache duration of CORS preflight | `30 days`\nheaders             | **cors** Allowed headers                  | `false`\nexposed             | **cors** Headers exposed to the client    | `false`\n\nThe options that are prefixed with **cors** are supplied to our\n[access-control](https://github.com/primus/access-control) module which handles\nHTTP Access Control (CORS), so for a more detailed explanation of these options\ncheck it out.\n\nThe `transport` option allows you to use any configuration option supported by\nthe underlying real-time framework. Its use is discouraged as these options\nare framework specific and no longer work if you change transformer. Our advise\nis to use it only if you know what you are doing and if you need fine-grained\ncontrol over the real-time framework. Please also keep in mind that some of\nthese options are overriden by Primus.\n\nThe `pingInterval` option specifies the interval at which heartbeats are\ntransmitted. It is possible to completely disable the heartbeats by setting the\nvalue of the `pingInterval` option to `false`.\n\nThe `idGenerator` option can be used to define a function which will be called\nto set each [`spark.id`](#sparkid). The generator function should return\na unique string each time it is invoked. If `idGenerator` is not defined, Primus\nwill try to use ids provided by the transformer. If the transformer does not\nprovide ids, Primus will use [nanoid](https://github.com/ai/nanoid) to generate\n`Spark` ids.\n\nIf you don't have a pre-existing server where you want or can attach your Primus\nserver to you can also use the `Primus.createServer` convenience method. The\n`createServer` method will automatically:\n\n- Setup a HTTP, HTTPS or SPDY server for you on the given port number.\n- Setup your Primus server with the given configuration.\n- Listen on the HTTP, HTTPS, SPDY server.\n- Attach a `primus.on('connection')` listener.\n- Return the created Primus instance.\n\n```js\nPrimus.createServer(function connection(spark) {\n\n}, { port: 8080, transformer: 'websockets' });\n```\n\nIn the above example we automatically create a HTTP server which will listen\non port 8080, a primus instance with the `websockets` transformer and start\nlistening for incoming connections. The supplied function in the\n`Primus.createServer` method is optional. You can just listen for incoming\nconnections your self using the returned Primus instance. If you want to listen to\na HTTPS or SPDY server, which is recommended, you can directly pass the SPDY and\nHTTPS certs/keys/pfx files in the options object:\n\n```js\nvar primus = Primus.createServer({\n  port: 443,\n  root: '/folder/with/https/cert/files',\n  cert: 'myfilename.cert',\n  key: 'myfilename.cert',\n  ca: 'myfilename.ca',\n  pfx: 'filename.pfx',\n  passphrase: 'my super sweet password'\n});\n\nprimus.on('connection', function (spark) {\n  spark.write('hello connnection');\n});\n```\n\n`Primus.createServer` returns a warning when it starts a HTTP server. The\nwarning advises you to use a HTTPS server and can be disabled setting the\noption `iknowhttpsisbetter` to `true`.\n\n#### Client library\n\nAs most libraries come with their own client-side framework for making the\nconnection we've also created a small wrapper for this. The library can be\nretrieved using:\n\n```js\nprimus.library();\n```\n\nWhich returns the client-side library as a string (which can then be minified or\neven have more code added to it). It does not come pre-minified as that is out\nof the scope of this project. You can store this on a CDN or on your static server.\nDo whatever you want with it, but remember to regenerate it every time you change\nPrimus server options. This is important because some properties of the client\nare set using the server configuration. For example if you change the\n`pathname`, the client should be regenerated to reflect that change and work\ncorrectly. We advise you to regenerate the library every time you redeploy so\nyou always have a client compatible with your back-end. To save the file you\ncan use:\n\n```js\nprimus.save(__dirname +'/primus.js');\n```\n\nThis will store the compiled library in your current directory. If you want to\nsave it asynchronously, you can supply the method with a callback method:\n\n```js\nprimus.save(__dirname +'/primus.js', function save(err) {\n\n});\n```\n\nBut to make it easier for you during development we've automatically added an\nextra route to the supplied HTTP server, this will serve the library for you so\nyou don't have to save it. Please note, that this route isn't optimised for\nserving static assets and should only be used during development. In your HTML\npage add:\n\n```html\n<script src=\"/primus/primus.js\"></script>\n```\n\nAs you can see, it will use the `/primus` pathname by default. Primus needs to\nown the whole path/namespace in order to function properly as it will forward\nall other requests directly in to the transformers so they can work their magic.\nIf you already have a static folder with the name `primus` you can change the\npathname to something different and still make this work. But you would of\ncourse need to update the `src` attribute of the script tag to set the correct\nlocation. It's always available at:\n\n```\n<protocol>://<server location>/<pathname>/primus.js\n```\n\nHere `<pathname>` is the `pathname` set in server options above. The client\nis cross domain compatible so you don't have to serve it from the\nsame domain you're running Primus on. But please note, that the real-time\nframework you're using might be tied to same domain restrictions.\n\nOnce you're all set up you can start listening for connections. These\nconnections are announced through the `connection` event.\n\n```js\nprimus.on('connection', function (spark) {\n  // spark is the new connection.\n});\n```\n\nDisconnects are announced using a `disconnection` event:\n\n```js\nprimus.on('disconnection', function (spark) {\n  // the spark that disconnected\n});\n```\n\nThe `spark` argument is the actual real-time socket/connection. Sparks have a\nreally low level interface and only expose a couple properties that are cross\nengine supported. The interface is modeled towards a Node.js stream compatible\ninterface. So this will include all methods that are available on the [stream\ninterface](https://nodejs.org/api/stream.html) including `Spark#pipe`.\n\n#### spark.headers\n\nThe `spark.headers` property contains the headers of either the request\nthat started a handshake with the server or the headers of the actual real-time\nconnection. This depends on the module you are using.\n\n*Please note that sending custom headers from the client to the server is\nimpossible as not all transports that these transformers support can add custom\nheaders to a request (JSONP for example). If you need to send custom data, use a\nquery string when connecting*\n\n#### spark.address\n\nThe `spark.address` property contains the `ip` and `port` of the\nconnection. If you're running your server behind a reverse proxy it will\nautomatically use the `x-forwarded-for` header. This way you will always have\nthe address of the connecting client and not the IP address of your proxy.\n\n*Please note that the `port` is probably out of date by the time you're going\nto read it as it's retrieved from an old request, not the request that is\nactive at the time you access this property.*\n\n#### spark.query\n\nThe `spark.query` contains the query string you used to connect to the server. It's\nparsed as an object. Please note that this may not be available for all supported\ntransformers.\n\n#### spark.socket\n\nThe `spark.socket` is set to the underlying socket of the transformer. This is not\nnecessarily a raw `Socket` and will differ from transformer to transformer.\n\n#### spark.id\n\nThis is a unique id that we use to identify this single connection with. Normally\nthe frameworks refer to this as a `sessionid`, which is confusing as it's only\nused for the duration of one single connection. You should not see this as a\n\"session id\", and rather expect it to change between disconnects and reconnects.\n\n#### spark.request\n\nThe `spark.request` gives you access to the HTTP request that was used to\ninitiate the real-time connection with the server. Please note that this request\nis already answered and closed (in most cases) so do not attempt to write or\nanswer it anyway. But it might be useful to access methods that get added by\nmiddleware layers, etc.\n\n#### spark.write(data)\n\nYou can use the `spark.write` method to send data over the socket. The data is\nautomatically encoded for you using the `parser` that you've set while creating\nthe Primus server instance. This method always returns `true` on success and\n`false` on failure so back pressure isn't handled.\n\n```js\nspark.write({ foo: 'bar' });\n```\n\n#### spark.end(data, options)\n\nYou can use `spark.end` to close the connection. This method takes two optional\narguments. The first, if provided, is the `data` to send to the client before\nclosing the connection. The second is an options object used to customize the\nbehavior of the method. By default the `spark.end` method closes the connection\nin a such way that the client knows it was intentional and it doesn't attempt a\nreconnection.\n\n```js\nspark.end(); // the client doesn't reconnect automatically\n```\n\nYou can change this behavior and trigger a client-side reconnection using the\n`reconnect` option.\n\n```js\nspark.end(undefined, { reconnect: true }); // trigger a client-side reconnection\n```\n\n#### spark.emits(event, parser)\n\nThis method is mostly used internally. It works similarly to the native `bind`\nfunction, returning a function that emits the assigned `event` every time it's\ncalled. If the last argument is a function, it will be used to parse the\narguments of the returned function. The `parser` is optional and always async,\nits **first** argument is a callback that follows the usual error first pattern,\nall successive arguments are the ones to parse. Using the `parser` you can\nreduce the arguments down to a single value, remove them completely or prevent\nthe event from being emitted. See [emits](https://github.com/primus/emits) for\ndetailed usage instructions.\n\n```js\nspark.emits('event', function parser(next, structure) {\n  next(undefined, structure.data);\n});\n```\n\nPlease note that the data that is received here isn't decoded yet.\n\n#### spark.on('data')\n\nThe `data` event is emitted when a message is received from the client. It's\nautomatically decoded by the specified decoder.\n\n```js\nspark.on('data', function message(data) {\n  // the message we've received.\n});\n```\n\n#### spark.on('end')\n\nThe `end` event is emitted when the client has disconnected.\n\n```js\nprimus.on('connection', function (spark) {\n  console.log('connection has the following headers', spark.headers);\n  console.log('connection was made from', spark.address);\n  console.log('connection id', spark.id);\n\n  spark.on('data', function (data) {\n    console.log('received data from the client', data);\n\n    //\n    // Always close the connection if we didn't receive our secret imaginary\n    // handshake.\n    //\n    if ('foo' !== data.secrethandshake) spark.end();\n    spark.write({ foo: 'bar' });\n    spark.write('banana');\n  });\n\n  spark.write('Hello world');\n})\n```\n\n### Connecting from the Browser\n\nPrimus comes with its client framework which can be compiled using\n`primus.library()` as mentioned above. To create a connection you can simply\ncreate a new Primus instance:\n\n```js\nvar primus = new Primus(url, { options });\n\n//\n// But it can be easier, with some syntax sugar.\n//\nvar primus = Primus.connect(url, { options });\n```\n\nThe URL should confirm the following conditions:\n\n- It should include the protocol it needs to connect with. This can either be\n  `http` or `https`. We recommend that you're using HTTPS for all your\n  connections as this prevents connection blocking by firewalls and anti-virus\n  programs.\n- The URL should not include a pathname. The pathname is configured by the\n  server (See: [getting-started](#getting-started)) and needs to be configured\n  there as it will be compiled in to the `primus.js` client file.\n\nIf no `url` argument is passed, it will default to the current URL.\n\nThe following options can be provided:\n\nName                | Description                             | Default\n--------------------|-----------------------------------------|---------------\n[reconnect]         | Configures the exponential back off     | `{}`\ntimeout             | Connect time out                        | `10000` ms\npingTimeout         | Max time to wait for a server ping      | `45000` ms\n[strategy]          | Our reconnect strategies                | `\"disconnect,online,timeout\"`\nmanual              | Manually open the connection            | `false`\nwebsockets          | Should we use WebSockets                | Boolean, is detected\nnetwork             | Use native `online`/`offline` detection | Boolean, is feature detected\ntransport           | Transport specific configuration        | `{}`\nqueueSize           | Number of messages that can be queued   | `Infinity`\n\nThere are 2 important options that we're going to look a bit closer at.\n\n##### Reconnect\n\nWhen the connection goes down unexpectedly an automatic reconnect process is\nstarted. It uses a randomised exponential back-off algorithm to prevent clients\nfrom DDoSing your server when you reboot as they will all be re-connecting at\ndifferent times. The reconnection can be configured using the `options` argument\nin `Primus` and you should add these options to the `reconnect` property:\n\nName                | Description                              | Default\n--------------------|------------------------------------------|---------------\nmax                 | Maximum delay for a reconnection attempt | `Infinity`\nmin                 | Minimum delay for a reconnection attempt | `500` ms\nretries             | Maximum amount of attempts               | `10`\nreconnect timeout   | Maximum time for an attempt to complete  | `30000` ms\nfactor              | Exponential back off factor              | `2`\n\n```js\nprimus = Primus.connect(url, {\n  reconnect: {\n      max: Infinity // Number: The max delay before we try to reconnect.\n    , min: 500 // Number: The minimum delay before we try reconnect.\n    , retries: 10 // Number: How many times we should try to reconnect.\n  }\n});\n```\n\nWhen you're going to customize `min` please note that it will grow\nexponentially e.g. `500 -> 1000 -> 2000 -> 4000 -> 8000` and is randomized\nso expect to have slightly higher or lower values.\n\nPlease note that when we reconnect, we will receive a new `connection` event on\nthe server and a new `open` event on the client, as the previous connection was\ncompletely dead and should therefore be considered a new connection.\n\nIf you are interested in learning more about the backoff algorithm you might\nwant to read http://dthain.blogspot.nl/2009/02/exponential-backoff-in-distributed.html\n\n##### Strategy\n\nThe strategy allows you to configure when you want a `reconnect` operation to\nkick in. We're providing some **sane** defaults for this but we still want to\nprovide users with highest level of customization:\n\n<dl>\n  <dt>disconnect</dt>\n  <dd>\n    Reconnect when we detect an unintentional disconnect in the connection.\n  </dd>\n  <dt>online</dt>\n  <dd>\n    Reconnect when the browser went from an offline event to an online event.\n  </dd>\n  <dt>timeout</dt>\n  <dd>\n    Reconnect when we failed to establish our initial connection. This can\n    happen because we took too long to connect or because there was an error\n    while we tried to connect (which happens when you connect to a dead server)\n  </dd>\n</dl>\n\nYou can supply these options as a comma-separated `String`:\n\n```js\nvar primus = new Primus(url, { strategy: 'online, timeout, disconnect' })\n```\n\nOr as an `Array`:\n\n```js\nvar primus = new Primus(url, { strategy: [ 'online', 'timeout', 'disconnect' ]});\n```\n\nWe'll try to normalize everything as much as possible, we `toLowerCase` everything\nand join it back to a readable string so if you wrote `dIsconNect` it will get\nnormalized to `disconnect`.\n\n**If you are using authentication you should disable the `timeout` strategy as\nthere is no way of detecting the difference between a failed authorization and a\nfailed connect. If you leave this enabled with authorization every unauthorized\naccess will try to reconnect again**.\n\nWe automatically disable this for you when you've set the authorization before\nyou save the library.\n\nBut there are always use cases where reconnection is not advised for your\napplication. In these cases we've provided a way to completely disable the\nreconnection, this is done by setting the `strategy` to `false`:\n\n```js\nvar primus = new Primus(url, { strategy: false });\n```\nIf you want to manually control the reconnection you can call `primus.end()`\nto close the connection and `primus.open()` to establish a new one. **Be sure\nto use `primus.open()` correctly, see below for details.**\n\n[reconnect]: #reconnect\n[strategy]: #strategy\n\n##### transport\n\nThe transport object allows you to add a transport specific configuration.\nWe only recommend using this if you understand and accept the following\nconsequences:\n\n- Primus will try to override configuration properties that are needed to\n  ensure a correct functioning.\n- We might start using options without any announcement or major version bump.\n- Expect your client and its connection to malfunction once you switch between\n  different transports, as these configurations are specific to the bundled\n  transformer library/client.\n- Bugs and bug reports caused by using this functionality are closed\n  immediately.\n\nHaving that said, this gives you total freedom while still getting the benefits\nof Primus.\n\n#### primus.open()\n\nThis method opens a connection with the server. By default it is called\nautomatically when the Primus instance is created, but there are cases where\nit's desirable to open the connection manually. To do this set the `manual`\noption to `true` and when you have the Primus instance call the method:\n\n```js\nprimus.open();\n```\n\n**When you call `primus.open()` you should make sure that the connection is\ntotally dead (e.g. after an `end` event) and primus isn't already trying or\nplanning to reconnect**.\n\n#### primus.write(message)\n\nOnce you've created your Primus instance you're ready to go. When you want to\nwrite data to your server you can just call the `.write` method:\n\n```js\nprimus.write('message');\n```\n\nIt automatically encodes your messages using the parser that you've specified on\nthe server. So sending objects back and forth between the server is nothing\ndifferent then just writing:\n\n```js\nprimus.write({ foo: 'bar' });\n```\n\nWhen you are sending messages to the server, you don't have to wait for the\n`open` event to happen, the client will automatically buffer all the data you've\nsend and automatically write it to the server once it's connected. The client\nsupports a couple of different events.\n\n#### primus.on('data')\n\nThe `data` event is the most important event of the whole library. It's emitted\nwhen we receive data from the server. The data that is received is already\ndecoded by the specified parser.\n\n```js\nprimus.on('data', function message(data) {\n  console.log('Received a new message from the server', data);\n});\n```\n\n#### primus.on('open')\n\nThe `open` event is emitted when we've successfully created a connection with\nthe server. It will also be emitted when we've successfully reconnected after the\nconnection goes down unintentionally.\n\n```js\nprimus.on('open', function open() {\n  console.log('Connection is alive and kicking');\n});\n```\n\n#### primus.on('error')\n\nThe `error` event is emitted when something breaks that is out of our control.\nUnlike Node.js, we do not throw an error if no `error` event listener is\nspecified. In general, when there is an active connection, it is not directly\nclosed when an `error` event is emitted. The cause of an error, in fact, could\nbe that the parser failed to encode or decode a message. In this case we only\nemit the error, discard the message and keep the connection alive. An `error`\nevent can also be emitted when a connection fails to establish. When this\nhappens the client automatically tries to reconnect, unless the connection gets\nclosed for some other reason. The only exception is when there is an\nauthorization hook. If we get an error when connecting to a server where\nauthorization is required, we simply close the connection, as we can't\ndeterminate if the error is the result of an unauthorized access or not.\n\n```js\nprimus.on('error', function error(err) {\n  console.error('Something horrible has happened', err.stack);\n});\n```\n\n#### primus.on('reconnect')\n\nThe `reconnect` event is emitted when we're attempting to reconnect to the\nserver. This all happens transparently and it's just a way for you to know when\nthese reconnects are actually happening.\n\n```js\nprimus.on('reconnect', function (opts) {\n  console.log('Reconnection attempt started');\n});\n```\n\n#### primus.on('reconnect scheduled')\n\nLooks a lot like the `reconnect` event mentioned above, but it's emitted when\nwe've detected that connection went/is down and we're going to start a reconnect\noperation. This event would be ideal to update your application's UI when the\nconnection is down and you are trying to reconnect in x seconds.\n\n```js\nprimus.on('reconnect scheduled', function (opts) {\n  console.log('Reconnecting in %d ms', opts.scheduled);\n  console.log('This is attempt %d out of %d', opts.attempt, opts.retries);\n});\n```\n\n#### primus.on('reconnected')\n\nThe client successfully reconnected with the server.\n\n```js\nprimus.on('reconnected', function (opts) {\n  console.log('It took %d ms to reconnect', opts.duration);\n});\n```\n\n#### primus.on('reconnect timeout')\n\nThe `reconnect timeout` event is emitted when a reconnection attempt takes too\nmuch time. This can happen for example when the server does not answer a request\nin a timely manner.\n\n```js\nprimus.on('reconnect timeout', function (err, opts) {\n  console.log('Timeout expired: %s', err.message);\n});\n```\n\nAfter this event a whole new reconnection procedure is automatically started, so\nyou don't have to worry about it.\n\n#### primus.on('reconnect failed')\n\nThis event is emitted when the reconnection failed, for example when all\nattempts to reconnect have been unsuccessful.\n\n```js\nprimus.on('reconnect failed', function (err, opts) {\n  console.log('The reconnection failed: %s', err.message);\n});\n```\n\n#### primus.on('end')\n\nThe `end` event is emitted when we've closed the connection. When this event is\nemitted you should consider your connection to be fully dead with no way of\nreconnecting. But it's also emitted when the server closes the connection.\n\n```js\nprimus.on('end', function () {\n  console.log('Connection closed');\n});\n```\n\n#### primus.end()\n\nWhen you want to close the connection you can call the `primus.end()` method.\nAfter this the connection should be considered dead and a new connection needs\nto be made using `Primus.connect(url)` or `primus = new Primus(url)` if you want\nto talk with the server again.\n\n```js\nprimus.end();\n```\n\n#### primus.destroy()\n\nThis method literally destroys the `primus` instance. Internally it calls the\n`primus.end()` method but it also frees some potentially heavy objects like\nthe underlying socket, the timers, the message transformers, etc. It also\nremoves all the event listeners but before doing that it emits a final `destroy`\nevent. Keep in mind that once this method is executed, you can no longer use\n`primus.open()` on the same `primus` instance.\n\n```js\nprimus.on('destroy', function () {\n  console.log('Feel the power of my lasers!');\n});\n\nprimus.destroy();\n```\n\n#### primus.emits(event, parser)\n\nThis method is analogous to the [`spark.emits`](#sparkemitsevent-parser) method.\nIt returns a function that emits the given event every time it's called. See\n[emits](https://github.com/primus/emits) for detailed usage instructions.\n\n```js\nprimus.emits('event', function parser(next, structure) {\n  next(undefined, structure.data);\n});\n```\n\n#### primus.id(callback)\n\nThere are cases where it is necessary to retrieve the [`spark.id`](#sparkid)\nfrom the client. To make this easier, we added a `primus.id()` method that\ntakes a callback function to which the id will be passed.\n\n```js\nprimus.id(function (id) {\n  console.log(id);\n});\n```\n\n### Connecting from the server\n\nThere are two ways of creating a server side client.\n\n1. When you've created your `primus` instance you can access the `Socket`\n   property on it. This `Socket` is automatically configured to connect to the\n   correct pathname, using the same `transformer` and `parser` that you've\n   specified when you created your `primus` instance.\n\n   ```js\n   var primus = new Primus(server, { transformer: transformer, parser: parser })\n     , Socket = primus.Socket;\n\n   var client = new Socket('http://localhost:8080');\n   //\n   // It has the same interface as the client, so you can just socket.write or\n   // listen for the `open` events etc.\n   //\n   ```\n2. You might need to connect from a different node process where you don't have\n   access to your `primus` instance and the compatible `Socket` instance. For\n   these cases there a special `createSocket` method where you can specify the\n   `transformer`, `parser`, `plugin` that you are using on your server to create\n   another compatible socket.\n\n   ```js\n   var Primus = require('primus') // Primus library from npm install primus\n     , Socket = Primus.createSocket({ transformer: transformer, parser: parser })\n     , client = new Socket('http://localhost:8080');\n   ```\n\nWhen you are using plugins with Primus make sure you add them **before** you\nreference the `primus.Socket` or it will compile a client without your plugins.\nIf you're using the `Primus.createSocket` api you can directly supply the\nplugins as part of the options as it supports `plugin` object:\n\n```js\nvar Socket = Primus.createSocket({\n  transformer: transformer,\n  parser: parser,\n  plugin: {\n    'my-emitter': require('my-emitter'),\n    'substream': require('substream')\n  }\n});\n```\n\nThe constructor returned by `primus.Socket` or `Primus.createSocket` has the\nsame signature of the constructor used to connect from the browser. This\nmeans that you can use all the options mentioned in the previous\n[section](#connecting-from-the-browser):\n\n```js\nvar Socket = Primus.createSocket()\n  , client = new Socket('http://localhost:8080', { options });\n```\n\nIf you do not know which transformer and parser are used on the server, we\nexpose a small JSON \"spec\" file that exposes this information. The specification\ncan be reached on the `/<pathname>/spec` and will output the following JSON\ndocument:\n\n  ```json\n  {\n    \"version\":\"2.4.0\",\n    \"pathname\":\"/primus\",\n    \"parser\":\"json\",\n    \"transformer\":\"websockets\"\n  }\n  ```\n\n### Authorization\n\n#### Server\n\nPrimus has a built-in auth hook that allows you to leverage the basic auth\nheader to validate the connection. To setup the optional auth hook, use the\n`Primus#authorize` method:\n\n```js\nvar authParser = require('basic-auth-parser');\n\n//\n// Add hook on server\n//\nprimus.authorize(function (req, done) {\n  var auth;\n\n  try { auth = authParser(req.headers['authorization']) }\n  catch (ex) { return done(ex) }\n\n  //\n  // Do some async auth check\n  //\n  authCheck(auth, done);\n});\n\nprimus.on('connection', function (spark) {\n  //\n  // You only get here if you make it through the auth hook!\n  //\n});\n```\n\nIn this particular case, if an error is passed to `done` by `authCheck` or\nthe exception handler then the connection attempt will never make it to the\n`primus.on('connection')` handler.\n\nThe error you pass can either be a string or an object. If an object, it can\nhave the following properties which affect the response sent to the client:\n\n- `statusCode`: The HTTP status code returned to the client. Defaults to 401.\n- `authenticate`: If set and `statusCode` is 401 then a `WWW-Authenticate`\n  header is added to the response, with a value equal to the `authenticate`\n  property's value.\n- `message`: The error message returned to the client. The response body will be\n  `{error: message}`, JSON-encoded.\n\nIf the error you pass is a string then a 401 response is sent to the client\nwith no `WWW-Authenticate` header and the string as the error message.\n\nFor example to send 500 when an exception is caught, 403 for forbidden users\nand details of the basic auth scheme being used when authentication fails:\n\n```js\nprimus.authorize(function (req, done) {\n  var auth;\n\n  if (req.headers.authorization) {\n    try { auth = authParser(req.headers.authorization) }\n    catch (ex) {\n      ex.statusCode = 500;\n      return done(ex);\n    }\n\n    if ((auth.scheme === 'myscheme') &&\n        checkCredentials(auth.username, auth.password)) {\n      if (userAllowed(auth.username)) {\n        return done();\n      } else {\n        return done({ statusCode: 403, message: 'Go away!' });\n      }\n    }\n  }\n\n  done({\n    message: 'Authentication required',\n    authenticate: 'Basic realm=\"myscheme\"'\n  });\n});\n```\n\nPlease note that the auth hook is run each and every time a request is made to\nthe server.\n\n#### Client\n\nUnfortunately, the amount of detail you get in your client when authorization\nfails depends on the transformer in use. Most real-time frameworks supported\nby Primus don't expose the status code, headers or response body.\n\nThe WebSocket transformer's underlying transport socket will fire an\n`unexpected-response` event with the HTTP request and response:\n\n```js\nprimus.on('outgoing::open', function () {\n  primus.socket.on('unexpected-response', function (req, res) {\n    console.error(res.statusCode);\n    console.error(res.headers['www-authenticate']);\n\n    //\n    // It's up to us to close the request (although it will time out).\n    //\n    req.abort();\n\n    //\n    // It's also up to us to emit an error so primus can clean up.\n    //\n    primus.socket.emit('error', 'authorization failed: ' + res.statusCode);\n  });\n});\n```\n\nIf you want to read the response body then you can do something like this:\n\n```js\nprimus.on('outgoing::open', function () {\n  primus.socket.on('unexpected-response', function (req, res) {\n    console.error(res.statusCode);\n    console.error(res.headers['www-authenticate']);\n\n    var data = '';\n\n    res.on('data', function (v) {\n      data += v;\n    });\n\n    res.on('end', function () {\n      //\n      // Remember error message is in the 'error' property.\n      //\n      primus.socket.emit('error', new Error(JSON.parse(data).error));\n    });\n  });\n});\n```\n\nIf `unexpected-response` isn't caught (because the WebSocket transformer isn't\nbeing used or you don't listen for it) then you'll get an `error` event:\n\n```js\nprimus.on('error', function error(err) {\n  console.error('Something horrible has happened', err.stack);\n});\n```\n\nAs noted above, `err` won't contain any details about the authorization failure\nso you won't be able to distinguish it from other errors.\n\n### Broadcasting\n\nBroadcasting allows you to write a message to every connected `Spark` on your server.\nThere are 2 different ways of doing broadcasting in Primus. The easiest way is to\nuse the `Primus#write` method which will write a message to every connected user:\n\n```js\nprimus.write('message');\n```\n\nThere are cases where you only want to broadcast a message to a smaller group of\nusers. To make it easier to do this, we've added a `Primus#forEach` method which\nallows you to iterate over all active connections.\n\n```js\nprimus.forEach(function (spark, id, connections) {\n  if (spark.query.foo !== 'bar') return;\n\n  spark.write('message');\n});\n```\n\nThe method can be also used asynchronously. To enable the asynchronous iteration\nyou have to call `Primus#forEach` with two arguments. The first is the iterator\nfunction that is called on every step. The iterator is called with a connection\nfrom the list and a callback for when it has finished. The second argument is\nthe main callback and is called when the iteration has finished.\n\n```js\nprimus.forEach(function (spark, next) {\n  //\n  // Do something and call next when done\n  //\n  next();\n}, function (err) {\n  console.log('We are done');\n});\n```\n\nThere are also cases where you want to select a single `Spark`. To do this you\ncan use the `Primus#spark` method.\n\n```js\n// Get a spark by its id\nvar spark = primus.spark(id);\n\nspark.write('message');\n```\n\nThis method returns a `Spark` or `undefined` if the given id doesn't match any\nof the active `Spark` ids on the server.\n\n### Destruction\n\nIn rare cases you might need to destroy the Primus instance you've created. You\ncan use the `primus.destroy()` or `primus.end()` method for this. This method\naccepts an Object which allows you to configure the destruction process:\n\n- `close` Close the HTTP server that Primus received. Defaults to `true`.\n- `reconnect` Automatically reconnect the clients. Defaults to `false`.\n- `timeout` Close all active connections and clean up the Primus instance after\n  the specified amount of timeout. Defaults to `0`.\n\nThe timeout is especially useful if you want gracefully shutdown your server but\nreally don't want to wait an infinite amount of time.\n\n```js\nprimus.destroy({ timeout: 10000 });\n```\n\n### Events\n\nPrimus is built upon the Stream and EventEmitter interfaces. This is a summary\nof the events emitted by Primus.\n\nEvent                 | Usage       | Location      | Description\n----------------------|-------------|---------------|----------------------------------------\n`outgoing::reconnect` | private     | client        | Transformer should reconnect.\n`reconnect scheduled` | **public**  | client        | We're scheduling a reconnect.\n`reconnect`           | **public**  | client        | Reconnect attempt is about to be made.\n`reconnected`         | **public**  | client        | Successfully reconnected.\n`reconnect timeout`   | **public**  | client        | Reconnect attempt took too much time.\n`reconnect failed`    | **public**  | client        | Failed to reconnect.\n`timeout`             | **public**  | client        | Failed to connect to server.\n`outgoing::open`      | private     | client/spark  | Transformer should connect.\n`incoming::open`      | private     | client/spark  | Transformer has connected.\n`open`                | **public**  | client        | Connection is open.\n`destroy`             | **public**  | client        | The instance has been destroyed.\n`incoming::error`     | private     | client        | Transformer received an error.\n`error`               | **public**  | client/spark  | An error happened.\n`incoming::data`      | private     | client/server | Transformer received data.\n`outgoing::data`      | private     | client/spark  | Transformer should write data.\n`data`                | **public**  | client/spark  | We received data.\n`incoming::end`       | private     | client/spark  | Transformer closed the connection.\n`outgoing::end`       | private     | client/spark  | Transformer should close connection.\n`end`                 | **public**  | client/spark  | The connection has ended.\n`close`               | **public**  | client/server | The connection has closed, we might reconnect. / The server has been destroyed.\n`connection`          | **public**  | server        | We received a new connection.\n`disconnection`       | **public**  | server        | We received a disconnection.\n`initialised`         | **public**  | server        | The server is initialised.\n`plugin`              | **public**  | server        | A new plugin has been added.\n`plugout`             | **public**  | server        | A plugin has been removed.\n`incoming::ping`      | private     | client        | We received a ping message.\n`outgoing::ping`      | private     | spark         | We're sending a ping message.\n`incoming::pong`      | private     | spark         | We received a pong message.\n`outgoing::pong`      | private     | client        | We're sending a pong message.\n`heartbeat`           | **public**  | spark         | We've received a response to a heartbeat.\n`online`              | **public**  | client        | We've regained a network connection.\n`offline`             | **public**  | client        | We've lost our internet connection.\n`log`                 | **public**  | server        | Log messages.\n`readyStateChange`    | **public**  | client/spark  | The readyState has changed.\n`outgoing::url`       | private     | client        | The options used to construct the URL.\n\nAs a rule of thumb assume that every event that is prefixed with `incoming::` or\n`outgoing::` is reserved for internal use only and that emitting such events your\nself will most likely result in chaos and destruction.\n\nTo make it easier for developers to emit events on Primus itself, we've added a\nsmall helper function that checks if the event you want to emit is reserved for\nPrimus only. This would be all `incoming::` and `outgoing::` prefixed events and\nthe events listed above. This method is called `<class>.reserved()` and it's\nimplemented on the `Spark`:\n\n```js\nprimus.on('connection', function connection(spark) {\n  spark.on('data', function (data) {\n    //\n    // Just imagine that we receive an array of arguments from the client which\n    // first argument is the name of the event that we need to emit and the\n    // second argument are the arguments for function.\n    //\n    if (spark.reserved(data.args[0])) return;\n\n    spark.emit.apply(spark, data.args[0]);\n  });\n});\n```\n\nBut also the client:\n\n```js\nvar primus = new Primus('http://example.bar');\n\nprimus.on('data', function (data) {\n  if (primus.reserved(data.args[0])) return;\n\n  primus.emit.apply(primus, data.args);\n});\n```\n\nAnd of course the `Primus` instance as well.\n\n### Heartbeats and latency\n\nHeartbeats are used in Primus to figure out if we still have an active, working\nand reliable connection with the server. These heartbeats are sent from the\n**server** to the client as shown in the following diagram.\n\n```\n     client will disconnect\n       if not recv within\n          `pingTimeout`\n\n     primus:pong:{timestamp}\n    +----------------------+\n    |                      |\n+---v----+            +---------+\n| server |            |  client |\n+--------+            +----^----+\n    |                      |\n    +----------------------+\n     primus:ping:{timestamp}\n\n      sent at `pingInterval`\n      server will disconnect\n      if no response since\n           last ping\n```\n\nThe heartbeat message that we send over the connection is\n`primus::ping::<timestamp>`. Upon receipt of this message, the client will send\nback a `primus::pong::<timestamp>` message with the same `<timestamp>` it\nreceived from the server.\nThis allows to calculate the latency between messages by simply getting\nthe `<timestamp>` and comparing it with the local time.\n\n### Supported Real-time Frameworks\n\nThe following transformers/transports are supported in Primus:\n\n#### BrowserChannel\n\nBrowserChannel was the original technology that GMail used for their real-time\ncommunication. It's designed for same domain communication and does not use\nWebSockets. To use BrowserChannel you need to install the `browserchannel`\nmodule:\n\n```\nnpm install browserchannel --save\n```\n\nAnd tell `Primus` that you want to use `browserchannel` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'browserchannel' });\n```\n\nThe `browserchannel` transformer comes with built-in node client support and can be\naccessed using:\n\n```js\nvar Socket = primus.Socket\n  , socket = new Socket('url');\n```\n\nPlease note that you should use at least version `1.0.6` which contains support\nfor query strings.\n\n#### Engine.IO\n\nEngine.IO is the low level transport functionality of Socket.IO 1.0. It supports\nmultiple transports for creating a real-time connection. It uses transport\nupgrading instead of downgrading which makes it more resilient to blocking\nproxies and firewalls. To enable `engine.io` you need to install the `engine.io`\nmodule:\n\n```\nnpm install engine.io --save\n```\n\nAnd tell `Primus` that you want to use `engine.io` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'engine.io' });\n```\n\nIf you want to use the client interface inside of Node.js you also need to\ninstall the `engine.io-client`:\n\n```\nnpm install engine.io-client --save\n```\n\nAnd then you can access it from your server instance:\n\n```js\nvar Socket = primus.Socket\n  , socket = new Socket('url');\n```\n\n#### Faye\n\nFaye is a WebSocket only transformer. It uses the `faye-websocket` module which\nis part of the [Faye](http://faye.jcoglan.com/) project and supports all\nprotocol specifications. To use this you need to install the `faye-websocket`\nmodule:\n\n```\nnpm install faye-websocket --save\n```\n\nAnd tell `Primus` that you want to use `faye` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'faye' });\n```\n\nThe `faye` transformer comes with built-in node client support and can be\naccessed using:\n\n```js\nvar Socket = primus.Socket\n  , socket = new Socket('url');\n```\n\n#### SockJS\n\nSockJS is a real-time server that focuses on cross-domain connections and does\nthis by using multiple transports. To use SockJS you need to install the\n`sockjs` module:\n\n```\nnpm install sockjs --save\n```\n\nAnd tell `Primus` that you want to use `sockjs` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'sockjs' });\n```\n\nIf you want to use the client interface inside of Node.js you also need to\ninstall the `sockjs-client` module:\n\n```\nnpm install sockjs-client --save\n```\n\nAnd then you can access it from your server instance:\n\n```js\nvar Socket = primus.Socket\n  , socket = new Socket('url');\n```\n\n#### uws\n\nuws is a WebSocket only transformer. It uses the `uws` module which is probably\nthe fastest WebSocket server available in Node.js. To use uws you have to\ninstall the `uws` module:\n\n```\nnpm install uws --save\n```\n\nAnd tell `Primus` that you want to use `uws` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'uws' });\n```\n\nIf you want to use the client interface inside of Node.js you also need to\ninstall the `ws` module:\n\n```\nnpm install ws --save\n```\n\nAnd then you can access it from your server instance:\n\n```js\nvar Socket = primus.Socket\n  , socket = new Socket('url');\n```\n\n#### WebSockets\n\nIf you are targeting a high end audience or maybe just need something for\ninternal uses you can use a pure WebSocket server. This transformer uses the\npopular `ws` module which is battle tested and supports all protocol\nspecifications. To use WebSockets you need to install the `ws` module:\n\n```\nnpm install ws --save\n```\n\nAnd tell `Primus` that you want to use `WebSockets` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'websockets' });\n```\n\nThe `WebSockets` transformer comes with built-in node client support and can be\naccessed using:\n\n```js\nvar Socket = primus.Socket\n  , socket = new Socket('url');\n```\n\nAs you can see from the examples above, it doesn't matter how you write the name\nof the transformer, we just `toLowerCase()` everything.\n\n### Transformer inconsistencies\n\n- BrowserChannel does not give you access to the `remotePort` of the incoming\n  connection. So when you access `spark.address` the `port` property will be set\n  to `1337` by default.\n- BrowserChannel is the only transformer that does not support cross domain\n  connections.\n- BrowserChannel and SockJS are written in CoffeeScript and this can make\n  debugging harder when their internals fail.\n- Engine.IO and SockJS do not ship their client-side library with their server\n  side component. We're bundling a snapshot of these libraries inside of Primus.\n  We will always be targeting the latest version of these transformers when we\n  bundle the library.\n\n### Parsers\n\nIn addition to support different frameworks we've also made it possible to use\ncustom encoding and decoding libraries. We're using `JSON` by default but you\ncould also use `binary` or `EJSON` for example (but these parsers need to be\nsupported by Primus, so check out the parser folder for examples). To specify\nthe parser to use you can supply a `parser` configuration option:\n\n```js\nvar primus = new Primus(server, { parser: 'JSON' });\n```\n\nAll parsers have an `async` interface for error handling.\n\n### Middleware\n\nPrimus has two ways of extending the functionality. We have [plugins](#plugins)\nbut also support middleware. And there is an important difference between these.\nThe middleware layers allows you to modify the incoming requests **before** they\nare passed in to the transformers. Plugins allow you to modify and interact with\nthe sparks. The middleware layer is only run for the requests that are handled\nby Primus.\n\nWe support 2 kind of middleware, **async** and **sync** middleware. The main\ndifference between these kinds is that sync middleware doesn't require a\ncallback, it is completely optional. In Primus, we eat our own dog food. Various\nof components in Primus are implemented through middleware layers:\n\n- `cors`: Adds the Access Control headers.\n- `primus.js`: It serves our `primus.js` client file.\n- `spec`: It outputs the server specification (version, transformer, path).\n- `authorization`: Our authorization handler, which is implemented as a middleware.\n- `no-cache`: Add no-cache headers to every HTTP request.\n- `x-xss`: Add `X-XSS-Protection` headers to every HTTP request.\n\n#### Primus.use(name, fn, options, index)\n\nThe `primus.use` method is how you add middleware layers to your system. All\nmiddleware layers need to be named. This allows you to also enable, disable and\nremove middleware layers. The supplied function can either be a pre-configured\nfunction that is ready to answer request/response or an unconfigured\nmiddleware. An unconfigured middleware is a function with less then 2 arguments.\nWe execute this function automatically with `Primus` as context of the function\nand optionally, the options that got provided:\n\n```js\nprimus.use('name', function () {\n  var primus = this;\n\n  return function (req, res) {\n    res.end('foo');\n  }\n}, { foo: 'bar' });\n```\n\nAs you can see in the example above, we assume that you return the actual\nmiddleware layer. If you don't need any pre-configuration you can just supply\nthe function directly:\n\n```js\n// sync middleware\nprimus.use('name', function (req, res) {\n\n});\n\n// async middleware\nprimus.use('name', function (req, res, next) {\n  doStuff();\n});\n```\n\nYou need to be aware that these middleware layers are running for HTTP requests\nbut also for upgrade requests. Certain middleware layers should only run for\nHTTP or Upgrade requests. To make it possible you can add a `http` or `upgrade`\nproperty to the middleware function and set it to `false` if you don't want it\nto be triggered.\n\n```js\nprimus.use('name', function () {\n  function middleware(req, res, next) {\n\n  }\n\n  middleware.upgrade = false; // Don't run this middleware for upgrades\n\n  return middleware;\n});\n```\n\nBy default a new middleware layer is added after the previous one, but there\nare cases where you need to add a middleware at a specified index in\nthe stack. To accomplish this you can use the optional 0 based `index`\nargument.\n\n```js\n// add a middleware after the first two in the stack\nprimus.use('name', function (req, res) {\n\n}, 2);\n```\n\n#### Primus.remove(name)\n\nThis method allows you to remove configured middleware. This works\nfor the middleware layers that you added but also the middleware layers that we\nadd by default. If you want to use a different way to serve the `primus.js`\nfile you can simply:\n\n```js\nprimus.remove('primus.js');\n```\n\nAnd add your own middleware instead.\n\n#### Primus.disable(name)\n\nIn addition to removing middleware layers, it's also possible to disable them so\nthey are skipped when we iterate over the middleware layers. It might be useful\nto just disable certain middleware layers in production.\n\n```js\nprimus.disable('name');\n```\n\n#### Primus.enable(name)\n\nOf course, when you can disable middleware there also needs to be way to enable\nthem again. This is exactly what this method does. Re-enable a disabled\nmiddleware layer.\n\n```js\nprimus.enable('name');\n```\n\n### Plugins\n\nPrimus was built as a low level interface where you can build your applications\nupon. At it's core, it's nothing more than something that passes messages back\nand forth between the client and server. To make it easier for developers to\nswitch to Primus we've developed a simple but effective plugin system that\nallows you to extend Primus's functionality.\n\nPlugins are added on the server side in the form of an `Object`:\n\n```js\n//\n// Require a plugin directly.\n//\nprimus.plugin('name', require('metroplex'));\n\n//\n// Or supply it manually with the required object structure\n//\nprimus.plugin('name', {\n  server: function (primus, options) {},\n  client: function (primus, options) {},\n  library: 'client side library'\n});\n```\n\nOr you can pass the plugin `Object` directly into the constructor:\n\n```js\nvar primus = new Primus(server, { plugin: {\n  name: {\n    server: function (primus, options) {},\n    client: function (primus, options) {},\n    library: 'client side library'\n  }\n}})\n```\n\nAnd last but not least, you can also supply the constructor with a comma or\nspace separated list of plugin names which will be required automatically:\n\n```js\nvar primus = new Primus(server, { plugin: 'metroplex, primus-emit' })\n```\n\nTo remove added plugins you can use the `plugout` method:\n\n```js\nprimus.plugin('name', require('metroplex'));\nprimus.plugout('name'); // returns true/false indicating successful removal.\n```\n\nThe server function is only executed on the server side and receives 2\narguments:\n\n1. A reference to the initialised Primus server.\n2. The options that were passed in the `new Primus(server, { options })`\n   constructor. So the plugin can be configured through the same interface.\n\nThe client receives the same arguments:\n\n1. A reference to the initialised Primus client.\n2. The options that were passed in the `new Primus(url, { options })`\n   constructor. So the plugin can be configured through the same interface.\n\nThe only thing you need to remember is that the client is stored in the library\nusing `toString()` so it cannot have any references outside the client's\nclosure. But luckily, there's a `library` property that will also be included on\nthe client side when it's specified. The `library` property should be an\nabsolute path to the library file.\n\n#### Intercepting the `connection` events\n\nThe `connection` event is emitted using a `async` emitter. It checks if your\nsupplied event emitter function has extra callback function. When it detects\nthis it will wait with the execution of the other assigned listeners until the\ncallback has been called. Please note that the order of assigning event\nlisteners is still respected so if you've assigned a `connection` listener\nbefore an async connection listener it will still be executed first.\n\n```js\nprimus.on('connection', function (spark) {\n  console.log('first call, i have no spark.newproperty', spark.newproperty);\n});\n\nprimus.on('connection', function (spark, next) {\n  longrunningasynmethod(spark.query, function (err, data) {\n    spark.newproperty = data;\n\n    console.log('second call, i added the new property');\n    next(err);\n  });\n});\n\nprimus.on('connection', function (spark) {\n  console.log('third call, i can read the ', spark.newproperty);\n});\n```\n\nWhen an error argument is supplied it will automatically end the connection and\nemit an `error` event on the spark. If you are coming from Socket.IO 1.0 >=,\nthis will basically work the same way as their middleware system.\n\n#### Extending the Spark / Socket\n\nThe server has a `.Spark` property that can be extended. This allows you to\neasily add new functionality to the socket. For example adding join room\nfunction would be as easy as:\n\n```js\nprimus.plugin('rooms', {\n  server: function (primus) {\n    var Spark = primus.Spark;\n\n    Spark.prototype.join = function () {\n      // implement room functionality.\n    };\n  }\n});\n```\n\n#### Transforming and intercepting messages\n\nIntercepting and transforming messages is something that a lot of plugins\nrequire. When you're building an `EventEmitter` plugin or something else you\nprobably don't want the default `data` event to be emitted but your custom\nevent. There are 2 different types of messages that can be transformed:\n\n1. `incoming` These messages are being received by the server.\n2. `outgoing` These messages are being sent to the client.\n\nThe transformer is available on both the client and the server and share, like\nyou would have expected the same identical API. Adding a new transformer is\nrelatively straightforward:\n\n```js\nprimus.transform('incoming', function (packet) {\n  //\n  // The packet.data contains the actual message that either received or\n  // transformed.\n  //\n\n  // This would transform all incoming messages to foo;\n  packet.data = 'foo';\n\n  // If you are handling the message and want to prevent the `data` event from\n  // happening, simply `return false` at the end of your function. No new\n  // transformers will be called, and the event won't be emitted.\n});\n```\n\nThese transformations can easily be done in the plugins:\n\n```js\nprimus.plugin('name', {\n  server: function (primus) {\n    primus.transform('outgoing', function (packet) {\n      packet.data = 'foo';\n    });\n\n    primus.transform('incoming', function (packet) {\n      if (packet.data === 'foo') packet.data = 'bar';\n    });\n  },\n\n  client: function (primus) {\n    primus.transform('outgoing', function (packet) {\n      packet.data = 'foo';\n    });\n\n    primus.transform('incoming', function (packet) {\n      if (packet.data === 'foo') packet.data = 'bar';\n    });\n  }\n});\n```\n\nWe also expose asynchronous interfaces for these transformers. If your function\naccepts 2 arguments we automatically assume it's async and that the last\nargument is the callback variable:\n\n```js\nprimus.transform('outgoing', function (packet, next) {\n  asyncprocess(packet.data, function (err, data) {\n    //\n    // If you return an error here, it will be emitted as `error` on the\n    // spark/client and no `data` event will be emitted.\n    //\n    if (err) return next(err);\n\n    //\n    // If you just wanted to ignore this message instead of emitting an error\n    // you can do:\n    //\n    if (err) return next(undefined, false);\n\n    //\n    // To update the data, just re-assign the `data` property on the packet you\n    // received and call the next callback.\n    //\n    packet.data = data;\n    next();\n  });\n});\n```\n\n#### Primus project plugins\n\nThe following plugins are part of the Primus project.\n\n<dl>\n  <dt><a href=\"https://github.com/primus/fortress-maximus\">fortess-maximus</a></dt>\n  <dd>\n    Fortress Maximus validates every incoming message on your Primus server as all\n    user input should be seen as a potential security risk.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/fortress-maximus\"><img\n      src=\"https://img.shields.io/npm/v/fortress-maximus.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://github.com/primus/fortress-maximus/actions?query=workflow%3ACI+branch%3Amaster\"><img\n      src=\"https://img.shields.io/github/actions/workflow/status/primus/fortress-maximus/ci.yml?branch=master&label=CI&style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/primus/metroplex\">metroplex</a></dt>\n  <dd>\n    Metroplex is a Redis based spark/connection registry for Primus. It stores\n    the sparks and their server address. So you can cluster multiple primus's\n    together with Metroplex and Omega Supreme\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/metroplex\"><img\n      src=\"https://img.shields.io/npm/v/metroplex.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://github.com/primus/metroplex/actions?query=workflow%3ACI+branch%3Amaster\"><img\n      src=\"https://img.shields.io/github/actions/workflow/status/primus/metroplex/ci.yml?branch=master&label=CI&style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/primus/mirage\">mirage</a></dt>\n  <dd>\n    Mirage generates and validates persistent session IDs.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/mirage\"><img\n      src=\"https://img.shields.io/npm/v/mirage.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://github.com/primus/mirage/actions?query=workflow%3ACI+branch%3Amaster\"><img\n      src=\"https://img.shields.io/github/actions/workflow/status/primus/mirage/ci.yml?branch=master&label=CI&style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/primus/omega-supreme\">omega-supreme</a></dt>\n  <dd>\n    Omega Supreme allows you to broadcast messages to Primus using a regular\n    HTTP request. These messages can be broacasted to every spark, single spark\n    or a collection of sparks.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/omega-supreme\"><img\n      src=\"https://img.shields.io/npm/v/omega-supreme.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://github.com/primus/omega-supreme/actions?query=workflow%3ACI+branch%3Amaster\"><img\n      src=\"https://img.shields.io/github/actions/workflow/status/primus/omega-supreme/ci.yml?branch=master&label=CI&style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/primus/primus-analytics\">primus-analytics</a></dt>\n  <dd>\n    Integrates Primus with Google Analytics.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-analytics\"><img\n      src=\"https://img.shields.io/npm/v/primus-analytics.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://github.com/primus/primus-analytics/actions?query=workflow%3ACI+branch%3Amaster\"><img\n      src=\"https://img.shields.io/github/actions/workflow/status/primus/primus-analytics/ci.yml?branch=master&label=CI&style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/primus/primus-emit\">primus-emit</a></dt>\n  <dd>\n    The emit module adds client -> server and server -> client event emitting to Primus.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-emit\"><img\n      src=\"https://img.shields.io/npm/v/primus-emit.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://github.com/primus/primus-emit/actions?query=workflow%3ACI+branch%3Amaster\"><img\n      src=\"https://img.shields.io/github/actions/workflow/status/primus/primus-emit/ci.yml?branch=master&label=CI&style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/primus/substream\">substream</a></dt>\n  <dd>\n    Substream is an opinionated but stream compatible connection multiplexer on\n    top of the Primus connections. These streams can be created without\n    pre-defining them on the server or client.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/substream\"><img\n      src=\"https://img.shields.io/npm/v/substream.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://github.com/primus/substream/actions?query=workflow%3ACI+branch%3Amaster\"><img\n      src=\"https://img.shields.io/github/actions/workflow/status/primus/substream/ci.yml?branch=master&label=CI&style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n#### Community plugins\n\nThese are also plugins created by our amazing community. If you want your module\nto be listed here, please open a pull request.\n\n<dl>\n  <dt><a href=\"https://github.com/Shopetti/backbone.primus\">backbone.primus</a></dt>\n  <dd>Bind primus.io events to backbone models and collections.</dd>\n  <dd>\n    <a href=\"https://travis-ci.org/Shopetti/backbone.primus\"><img\n      src=\"https://img.shields.io/travis/Shopetti/backbone.primus/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt>\n    <a href=\"https://github.com/latentflip/hapi_primus_sessions\">\n      hapi_primus_sessions\n    </a>\n  </dt>\n  <dd>\n    A hapi and primus plugin which extends primus' spark with a `getSession(cb)`\n    method which returns the current hapi session object.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/hapi_primus_sessions\"><img\n      src=\"https://img.shields.io/npm/v/hapi_primus_sessions.svg?style=flat-square\"\n      alt=\"NPM version\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/lemonde/primus-cluster\">primus-cluster</a></dt>\n  <dd>Scale Primus across multiple servers or with node cluster.</dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-cluster\"><img\n      src=\"https://img.shields.io/npm/v/primus-cluster.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://github.com/lemonde/primus-cluster/actions?query=workflow%3ACI+branch%3Amain\"><img\n      src=\"https://img.shields.io/github/actions/workflow/status/lemonde/primus-cluster/ci.yml?branch=main&label=CI&style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/cayasso/primus-emitter\">primus-emitter</a></dt>\n  <dd>A module that adds emitter capabilities to Primus.</dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-emitter\"><img\n      src=\"https://img.shields.io/npm/v/primus-emitter.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/cayasso/primus-emitter\"><img\n      src=\"https://img.shields.io/travis/cayasso/primus-emitter/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/zemirco/primus-express-session\">primus-express-session</a></dt>\n  <dd>Share a user session between Express and Primus.</dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-express-session\"><img\n      src=\"https://img.shields.io/npm/v/primus-express-session.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/zemirco/primus-express-session\"><img\n      src=\"https://img.shields.io/travis/zemirco/primus-express-session/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/cayasso/primus-multiplex\">primus-multiplex</a></dt>\n  <dd>A module that adds multiplexing capabilities to Primus.</dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-multiplex\"><img\n      src=\"https://img.shields.io/npm/v/primus-multiplex.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/cayasso/primus-multiplex\"><img\n      src=\"https://img.shields.io/travis/cayasso/primus-multiplex/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/mmalecki/primus-redis\">primus-redis</a></dt>\n  <dd>\n    primus-redis is a Redis store for Primus. It takes care of distributing\n    messages to other instances using Redis Pub/Sub.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-redis\"><img\n      src=\"https://img.shields.io/npm/v/primus-redis.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/mmalecki/primus-redis\"><img\n      src=\"https://img.shields.io/travis/mmalecki/primus-redis/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/mmalecki/primus-redis-rooms\">primus-redis-rooms</a></dt>\n  <dd>\n    primus-redis-rooms is a Redis store for Primus and primus-rooms.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-redis-rooms\"><img\n      src=\"https://img.shields.io/npm/v/primus-redis-rooms.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/mmalecki/primus-redis-rooms\"><img\n      src=\"https://img.shields.io/travis/mmalecki/primus-redis-rooms/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/cayasso/primus-resource\">primus-resource</a></dt>\n  <dd>\n    Define resources with auto-bound methods that can be called remotely on top of Primus.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-resource\"><img\n      src=\"https://img.shields.io/npm/v/primus-resource.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/cayasso/primus-resource\"><img\n      src=\"https://img.shields.io/travis/cayasso/primus-resource/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/swissmanu/primus-responder\">primus-responder</a></dt>\n  <dd>Client and server plugin that adds a request/response cycle to Primus.</dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-responder\"><img\n      src=\"https://img.shields.io/npm/v/primus-responder.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/swissmanu/primus-responder\"><img\n      src=\"https://img.shields.io/travis/swissmanu/primus-responder/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/cayasso/primus-rooms\">primus-rooms</a></dt>\n  <dd>\n    A module that adds rooms capabilities to Primus. It's based on the rooms\n    implementation of Socket.IO.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-rooms\"><img\n      src=\"https://img.shields.io/npm/v/primus-rooms.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/cayasso/primus-rooms\"><img\n      src=\"https://img.shields.io/travis/cayasso/primus-rooms/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/fadeenk/primus-rooms-redis-adapter\">primus-rooms-redis-adapter</a></dt>\n  <dd>\n    A redis adapter for primus-rooms module. Supports integration with metroplex and omega-supreme.\n  </dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-rooms-redis-adapter\"><img\n      src=\"https://img.shields.io/npm/v/primus-rooms-redis-adapter.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/fadeenk/primus-rooms-redis-adapter\"><img\n      src=\"https://img.shields.io/travis/fadeenk/primus-rooms-redis-adapter/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"https://github.com/Fishrock123/primus-spark-latency\">primus-spark-latency</a></dt>\n  <dd>Adds a latency property to primus sparks server-side.</dd>\n  <dd>\n    <a href=\"https://www.npmjs.com/package/primus-spark-latency\"><img\n      src=\"https://img.shields.io/npm/v/primus-spark-latency.svg?style=flat-square\"\n      alt=\"NPM version\" /></a><a href=\"https://travis-ci.org/Fishrock123/primus-spark-latency\"><img\n      src=\"https://img.shields.io/travis/Fishrock123/primus-spark-latency/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n</dl>\n\n### Community\n\nDeployed Primus to production or built an awesome demo using the technology?\nWe've set up a special [wiki] page for it where you can show your awesome\ncreations or learn from demo and example applications how to use Primus.\nCheckout the wiki page at:\n\nhttps://github.com/primus/primus/wiki/Production\n\n[wiki]: https://github.com/primus/primus/wiki\n\n### FAQ\n\n#### What is the best way to scale Primus\n\nScaling Primus is as simple as sticking it behind a load balancer that supports\n[sticky sessions](https://github.com/primus/primus/issues/147) and run multiple\nversions of your application. This is a vital feature that your load balancer\nneeds to support. This ensures that the incoming requests always go back to the\nsame server. If your load balancer does not support sticky sessions, get another\none. I highly recommend [HAProxy](http://www.haproxy.org/). According to my own\ntesting it is the fastest and best proxy available that supports WebSockets. See\nhttps://github.com/observing/balancerbattle for more detailed information.\n\nThe reason for which sticky-sessions are so important is that a lot of frameworks\nthat use polling transports require to save a state in the node process in order\nto work correctly. This state contains times, sessions ids, handshake data etc.\nIf a request from the same client does not enter the same node process it will\nbe treated as an `unknown` request and your real-time connection will be closed.\n\nIf you want more advanced scaling and messaging please take a look at the various\nplugins we've written for this scope. Plugins like metroplex, omega-supreme and\nprimacron can be time savers.\n\n#### Can I use cluster?\n\n> Note: The following only applies to websocket emulation transformers like\n> sockjs or engine.io. If you are using `ws`, `uws` or `faye-websocket`, there\n> is no need for sticky sessions, and thus no issue.\n\nThe `cluster` module that ships with Node.js does not implement sticky sessions.\n\nThere are projects like `stick-session` which attempt to implement\nsticky-sessions in cluster, but the problem with this specific approach is that\nit uses the `remoteAddress` of the connection. For some people this isn't a\nproblem but when you add this behind a load balancer the remote address will be\nset to the address of the load balancer that forwards the requests. So all in all\nit only causes more scalability problems instead of solving them. This is why\nwe've opted to warn people about the risks of `cluster` when we detect that the\nPrimus library is run in a worker environment. **USE IT AT YOUR OWN RISK**.\n\nTo turn off the cluster warning in your Primus instance you can set the option\n`iknowclusterwillbreakconnections` to `true`.\n\n#### How do I use Primus with Express\n\nExpress' `express()` instance isn't a valid HTTP server. In order to make it\nwork with `Primus` and other real-time transformers you need to feed the instance\nto a real `http` server and supply this server. See example below:\n\n```js\n'use strict';\n\nvar express = require('express')\n  , Primus = require('primus')\n  , app = express();\n\n//\n// Do your express magic.\n//\n\nvar server = require('http').createServer(app)\n  , primus = new Primus(server, { options });\n\nserver.listen(port);\n```\n\n#### Is require.js supported\n\nRequire.js is supported to a certain degree. The `primus.js` core file should be\ncompatible with require.js but it could be that the transformer of your choosing\nisn't compatible with require.js. For example `engine.io` uses `component` which\nintroduces it's own `require` function that causes issues. In addition to that,\nthere are plugins which might use these modules that break require.js. The\ngeneral advice for this is to drop require.js in favour of plain script loading\nor use of browserify where possible. If you feel strong about require.js we accept\npull requests that improve this behaviour or helps us save guard against these\nissues.\n\n#### Can I send custom headers to the server\n\nIt is not possible to send custom headers from the client to the server. This is\nbecause these headers need to be set by the actual transports that the\ntransformers are using. The only transport that would support this would be AJAX\npolling. To send custom data to the server use a query string in your connection\nURL, as this is something that all transports support.\n\n```js\nvar primus = new Primus('http://localhost:8080/?token=1&name=foo');\n```\n\n### Versioning\n\n#### History\n\nYou can discover the version history and change logs on the\n[Releases](https://github.com/primus/primus/releases) page\n\n#### Convention\n\nAll `0.x.x` releases should be considered unstable and not ready for production.\nThe version number is laid out as: `major.minor.patch` and tries to follow\nsemver as closely as possible but this is how we use our version numbering:\n\n<dl>\n  <dt>major</dt>\n  <dd>\n    <p>\n      A major and possible breaking change has been made in the primus core.\n      These changes are not backwards compatible with older versions.\n    </p>\n  </dd>\n  <dt>minor</dt>\n  <dd>\n    <p>\n      New features are added or a big change has happened with one of the\n      real-time libraries that we're supporting.\n    </p>\n  </dd>\n  <dt>patch</dt>\n  <dd>\n    <p>\n      A bug has been fixed, without any major internal and breaking changes.\n    </p>\n  </dd>\n</dl>\n\n#### Release cycle\n\nThere isn't a steady or monthly release cycle. We usually release a new version\nwhen:\n\n1. A critical bug is discovered.\n2. There have been a lot of minor changes.\n3. A framework did an incompatible update.\n4. A new framework is added.\n5. People ask for it.\n\n### Other languages\n\nThese projects are maintained by our valuable community and allow you to use\nPrimus in a different language than JavaScript:\n\n<dl>\n  <dt><a href=\"https://github.com/seegno/primus-objc\">primus-objc</a></dt>\n  <dd>\n    A client written in Objective-C for the Primus real-time framework with\n    initial support for web sockets (via SocketRocket) and socket.io (via\n    socket.IO-objc). Easily switch between different real-time Objective-C\n    frameworks without any code changes.\n  </dd>\n  <dd>\n    <a href=\"https://travis-ci.org/seegno/primus-objc\"><img\n      src=\"https://img.shields.io/travis/seegno/primus-objc/master.svg?style=flat-square\"\n      alt=\"Build Status\" /></a>\n  </dd>\n\n  <dt><a href=\"https://github.com/cine-io/primus-android\">primus-android</a></dt>\n  <dd>\n    A Primus client written in Java for Android with\n    initial support for web sockets via <a href=\"https://github.com/koush/AndroidAsync\">AndroidAsync</a>.\n  </dd>\n</dl>\n\nWant to have your project listed here? Add it using a pull-request!\n\n#### Protocol\n\nPrimus uses some internal protocol messages in order to keep the connection open\nand stable between a client and a server. If you are planning on implementing\nPrimus in another language you must handle the following `primus::*` prefixed\nmessages:\n\n- `primus::ping::<ping>` **server -> client**, The ping type contains the time\n  in EPOCH. Ping messages are needed to keep the connection open as certain load\n  balancers, proxies and browsers will close connections automatically when\n  there is inactivity.\n- `primus::pong::<ping>` **client -> server**, The pong is the response to the\n  `ping` packet. It echoes back the exact value that it received.\n- `primus::server::close` **server -> client**, Indication that the server\n  intentionally closed the connection and that no reconnection/connection should\n  be made.\n- `primus::id::` **client -> server**, Request of the internal `spark.id`\n  that's assigned to the connection.\n- `primus::id::<spark.id>` **server -> client**, The internal `id` that we used\n  on the server to identify the connection as we do not sync this information by\n  default and requires a `primus.id()` call on the client.\n\nAny other message that is prefixed with `primus::` should be ignored and not\nemitted to the user.\n\n### License\n\n[MIT](LICENSE)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 1.5068359375,
          "content": "# Security Guidelines\n\nPlease contact us directly at **security@3rd-Eden.com** for any bug that might\nimpact the security of this project. Please prefix the subject of your email\nwith `[security]` in lowercase and square brackets. Our email filters will\nautomatically prevent these messages from being moved to our spam box.\n\nYou will receive an acknowledgement of your report within **24 hours**.\n\nAll emails that do not include security vulnerabilities will be removed and\nblocked instantly.\n\n## Exceptions\n\nIf you do not receive an acknowledgement within the said time frame please give\nus the benefit of the doubt as it's possible that we haven't seen it yet. In\nthis case please send us a message **without details** using one of the\nfollowing methods:\n\n- Give our channel operators a heads up in our IRC room\n  ([irc.freenode.net#primus](https://webchat.freenode.net/?channels=primus)).\n- Contact the lead developers of this project on their personal e-mails. You\n  can find the e-mails in the git logs, for example using the following command:\n  `git --no-pager show -s --format='%an <%ae>' <gitsha>` where `<gitsha>` is the\n  SHA1 of their latest commit in the project.\n\nOnce we have acknowledged receipt of your report and confirmed the bug\nourselves we will work with you to fix the vulnerability and publicly acknowledge\nyour responsible disclosure, if you wish. In addition to that we will report\nall vulnerabilities to the [Node Security Project](https://nodesecurity.io/).\n\n## History\n\nNo security issues have been reported yet.\n"
        },
        {
          "name": "errors.js",
          "type": "blob",
          "size": 1.1005859375,
          "content": "'use strict';\n\nvar util = require('util');\n\n/**\n * Generic Primus error.\n *\n * @constructor\n * @param {String} message The reason for the error\n * @param {EventEmitter} logger Optional EventEmitter to emit a `log` event on.\n * @api public\n */\nfunction PrimusError(message, logger) {\n  Error.captureStackTrace(this, this.constructor);\n\n  this.message = message;\n  this.name = this.constructor.name;\n\n  if (logger) {\n    logger.emit('log', 'error', this);\n  }\n}\n\nutil.inherits(PrimusError, Error);\n\n/**\n * There was an error while parsing incoming or outgoing data.\n *\n * @param {String} message The reason for the error.\n * @param {Spark} spark The spark that caused the error.\n * @api public\n */\nfunction ParserError(message, spark) {\n  Error.captureStackTrace(this, this.constructor);\n\n  this.message = message;\n  this.name = this.constructor.name;\n\n  if (spark) {\n    if (spark.listeners('error').length) spark.emit('error', this);\n    spark.primus.emit('log', 'error', this);\n  }\n}\n\nutil.inherits(ParserError, Error);\n\n//\n// Expose our custom events.\n//\nexports.PrimusError = PrimusError;\nexports.ParserError = ParserError;\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 31.3056640625,
          "content": "'use strict';\n\nvar PrimusError = require('./errors').PrimusError\n  , EventEmitter = require('eventemitter3')\n  , Transformer = require('./transformer')\n  , log = require('diagnostics')('primus')\n  , Spark = require('./spark')\n  , fuse = require('fusing')\n  , fs = require('fs')\n  , vm = require('vm');\n\n/**\n * Primus is a universal wrapper for real-time frameworks that provides a common\n * interface for server and client interaction.\n *\n * @constructor\n * @param {HTTP.Server} server HTTP or HTTPS server instance.\n * @param {Object} options Configuration\n * @api public\n */\nfunction Primus(server, options) {\n  if (!(this instanceof Primus)) return new Primus(server, options);\n\n  this.fuse();\n\n  if ('object' !== typeof server) {\n    var message = 'The first argument of the constructor must be ' +\n      'an HTTP or HTTPS server instance';\n    throw new PrimusError(message, this);\n  }\n\n  options = options || {};\n  options.maxLength = options.maxLength || 10485760;  // Maximum allowed packet size.\n  options.transport = options.transport || {};        // Transformer specific options.\n  options.pingInterval = 'pingInterval' in options    // Heartbeat interval.\n    ? options.pingInterval\n    : 30000;\n\n  if ('timeout' in options) {\n    throw new PrimusError('The `timeout` option has been removed', this);\n  }\n\n  var primus = this\n    , key;\n\n  this.auth = options.authorization || null;  // Do we have an authorization handler.\n  this.connections = Object.create(null);     // Connection storage.\n  this.ark = Object.create(null);             // Plugin storage.\n  this.layers = [];                           // Middleware layers.\n  this.heartbeatInterval = null;              // The heartbeat interval.\n  this.transformer = null;                    // Reference to the real-time engine instance.\n  this.encoder = null;                        // Shorthand to the parser's encoder.\n  this.decoder = null;                        // Shorthand to the parser's decoder.\n  this.connected = 0;                         // Connection counter.\n  this.whitelist = [];                        // Forwarded-for white listing.\n  this.options = options;                     // The configuration.\n  this.transformers = {                       // Message transformers.\n    outgoing: [],\n    incoming: []\n  };\n\n  this.server = server;\n  this.pathname = 'string' === typeof options.pathname\n    ? options.pathname.charAt(0) !== '/'\n      ? '/'+ options.pathname\n      : options.pathname\n    : '/primus';\n\n  //\n  // Create a specification file with the information that people might need to\n  // connect to the server.\n  //\n  this.spec = {\n    pingInterval: options.pingInterval,\n    pathname: this.pathname,\n    version: this.version\n  };\n\n  //\n  // Create a pre-bound Spark constructor. Doing a Spark.bind(Spark, this) doesn't\n  // work as we cannot extend the constructor of it anymore. The added benefit of\n  // approach listed below is that the prototype extensions are only applied to\n  // the Spark of this Primus instance.\n  //\n  this.Spark = function Sparky(headers, address, query, id, request, socket) {\n    Spark.call(this, primus, headers, address, query, id, request, socket);\n  };\n\n  this.Spark.prototype = Object.create(Spark.prototype, {\n    constructor: {\n      configurable: true,\n      value: this.Spark,\n      writable: true\n    },\n    __initialise: {\n      value: Spark.prototype.__initialise.slice(),\n      configurable: true,\n      writable: true\n    }\n  });\n\n  //\n  // Copy over the original Spark static properties and methods so readable and\n  // writable can also be used.\n  //\n  for (key in Spark) {\n    this.Spark[key] = Spark[key];\n  }\n\n  this.parsers(options.parser);\n  this.initialise(options.transformer, options);\n\n  //\n  // If the plugins are supplied through the options, also initialise them.\n  // This also allows us to use plugins when creating a client constructor\n  // with the `Primus.createSocket({})` method.\n  //\n  if ('string' === typeof options.plugin) {\n    options.plugin.split(/[, ]+/).forEach(function register(name) {\n      primus.plugin(name, name);\n    });\n  } else if ('object' === typeof options.plugin) {\n    for (key in options.plugin) {\n      this.plugin(key, options.plugin[key]);\n    }\n  }\n\n  //\n  // - Cluster node 0.10 lets the Operating System decide to which worker a request\n  //   goes. This can result in a not even distribution where some workers are\n  //   used at 10% while others at 90%. In addition to that the load balancing\n  //   isn't sticky.\n  //\n  // - Cluster node 0.12 implements a custom round robin algorithm. This solves the\n  //   not even distribution of work but it does not address our sticky session\n  //   requirement.\n  //\n  // Projects like `sticky-session` attempt to implement sticky sessions but they\n  // are using `net` server instead of a HTTP server in combination with the\n  // remoteAddress of the connection to load balance. This does not work when you\n  // address your servers behind a load balancer as the IP is set to the load\n  // balancer, not the connecting clients. All in all, it only causes more\n  // scalability problems. So we've opted-in to warn users about the\n  // risks of using Primus in a cluster.\n  //\n  if (!options.iknowclusterwillbreakconnections && require('cluster').isWorker) [\n    '',\n    'The `cluster` module does not implement sticky sessions. Learn more about',\n    'this issue at:',\n    '',\n    'http://github.com/primus/primus#can-i-use-cluster',\n    ''\n  ].forEach(function warn(line) {\n    console.error('Primus: '+ line);\n  });\n}\n\n//\n// Fuse and spice-up the Primus prototype with EventEmitter and predefine\n// awesomeness.\n//\nfuse(Primus, EventEmitter);\n\n//\n// Lazy read the primus.js JavaScript client.\n//\nObject.defineProperty(Primus.prototype, 'client', {\n  get: function read() {\n    if (!read.primus) {\n      read.primus = fs.readFileSync(__dirname + '/dist/primus.js', 'utf-8');\n    }\n\n    return read.primus;\n  }\n});\n\n//\n// Lazy compile the primus.js JavaScript client for Node.js\n//\nObject.defineProperty(Primus.prototype, 'Socket', {\n  get: function () {\n    const sandbox = Object.keys(global).reduce((acc, key) => {\n      if (key !== 'global' && key !== 'require') acc[key] = global[key];\n      return acc;\n    }, {\n      __dirname: process.cwd(),\n      __filename: 'primus.js',\n      require: require,\n\n      //\n      // The following globals are introduced so libraries that use `instanceof`\n      // checks for type checking do not fail as the code is run in a new\n      // context.\n      //\n      Uint8Array: Uint8Array,\n      Object: Object,\n      RegExp: RegExp,\n      Array: Array,\n      Error: Error,\n      Date: Date\n    });\n\n    vm.runInNewContext(this.library(true), sandbox, { filename: 'primus.js' });\n    return sandbox[this.options.global || 'Primus'];\n  }\n});\n\n//\n// Expose the current version number.\n//\nPrimus.prototype.version = require('./package.json').version;\n\n//\n// A list of supported transformers and the required Node.js modules.\n//\nPrimus.transformers = require('./transformers.json');\nPrimus.parsers = require('./parsers.json');\n\n/**\n * Simple function to output common errors.\n *\n * @param {String} what What is missing.\n * @param {Object} where Either Primus.parsers or Primus.transformers.\n * @returns {Object}\n * @api private\n */\nPrimus.readable('is', function is(what, where) {\n  var missing = Primus.parsers !== where\n      ? 'transformer'\n      : 'parser'\n    , dependency = where[what];\n\n  return {\n    missing: function write() {\n      console.error('Primus:');\n      console.error('Primus: Missing required npm dependency for '+ what);\n      console.error('Primus: Please run the following command and try again:');\n      console.error('Primus:');\n      console.error('Primus:   npm install --save %s', dependency.server);\n      console.error('Primus:');\n\n      return 'Missing dependencies for '+ missing +': \"'+ what + '\"';\n    },\n\n    unknown: function write() {\n      console.error('Primus:');\n      console.error('Primus: Unsupported %s: \"%s\"', missing, what);\n      console.error('Primus: We only support the following %ss:', missing);\n      console.error('Primus:');\n      console.error('Primus:   %s', Object.keys(where).join(', '));\n      console.error('Primus:');\n\n      return 'Unsupported '+ missing +': \"'+ what +'\"';\n    }\n  };\n});\n\n/**\n * Initialise the real-time engine that was chosen.\n *\n * @param {Mixed} Transformer The name of the transformer or a constructor;\n * @param {Object} options Options.\n * @api private\n */\nPrimus.readable('initialise', function initialise(Transformer, options) {\n  Transformer = Transformer || 'websockets';\n\n  var primus = this\n    , transformer;\n\n  if ('string' === typeof Transformer) {\n    log('transformer `%s` is a string, attempting to resolve location', Transformer);\n    Transformer = transformer = Transformer.toLowerCase();\n    this.spec.transformer = transformer;\n\n    //\n    // This is a unknown transformer, it could be people made a typo.\n    //\n    if (!(Transformer in Primus.transformers)) {\n      log('the supplied transformer %s is not supported, please use %s', transformer, Primus.transformers);\n      throw new PrimusError(this.is(Transformer, Primus.transformers).unknown(), this);\n    }\n\n    try {\n      Transformer = require('./transformers/'+ transformer);\n      this.transformer = new Transformer(this);\n    } catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND') {\n        log('the supplied transformer `%s` is missing', transformer);\n        throw new PrimusError(this.is(transformer, Primus.transformers).missing(), this);\n      } else {\n        log(e);\n        throw e;\n      }\n    }\n  } else {\n    log('received a custom transformer');\n    this.spec.transformer = 'custom';\n  }\n\n  if ('function' !== typeof Transformer) {\n    throw new PrimusError('The given transformer is not a constructor', this);\n  }\n\n  this.transformer = this.transformer || new Transformer(this);\n\n  this.on('connection', function connection(stream) {\n    this.connected++;\n    this.connections[stream.id] = stream;\n\n    log('connection: %s currently serving %d concurrent', stream.id, this.connected);\n  });\n\n  this.on('disconnection', function disconnected(stream) {\n    this.connected--;\n    delete this.connections[stream.id];\n\n    log('disconnection: %s currently serving %d concurrent', stream.id, this.connected);\n  });\n\n  //\n  // Add our default middleware layers.\n  //\n  this.use('forwarded', require('./middleware/forwarded'));\n  this.use('cors', require('./middleware/access-control'));\n  this.use('primus.js', require('./middleware/primus'));\n  this.use('spec', require('./middleware/spec'));\n  this.use('x-xss', require('./middleware/xss'));\n  this.use('no-cache', require('./middleware/no-cache'));\n  this.use('authorization', require('./middleware/authorization'));\n\n  //\n  // Set the heartbeat interval.\n  //\n  if (options.pingInterval) {\n    this.heartbeatInterval = setInterval(\n      this.heartbeat.bind(this),\n      options.pingInterval\n    );\n  }\n\n  //\n  // Emit the initialised event after the next tick so we have some time to\n  // attach listeners.\n  //\n  process.nextTick(function tock() {\n    primus.emit('initialised', primus.transformer, primus.parser, options);\n  });\n});\n\n/**\n * Add a new authorization handler.\n *\n * @param {Function} auth The authorization handler.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('authorize', function authorize(auth) {\n  if ('function' !== typeof auth) {\n    throw new PrimusError('Authorize only accepts functions', this);\n  }\n\n  if (auth.length < 2) {\n    throw new PrimusError('Authorize function requires more arguments', this);\n  }\n\n  log('setting an authorization function');\n  this.auth = auth;\n  return this;\n});\n\n/**\n * Iterate over the connections.\n *\n * @param {Function} fn The function that is called every iteration.\n * @param {Function} done Optional callback, if you want to iterate asynchronously.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('forEach', function forEach(fn, done) {\n  if (!done) {\n    for (var id in this.connections) {\n      if (fn(this.spark(id), id, this.connections) === false) break;\n    }\n\n    return this;\n  }\n\n  var ids = Object.keys(this.connections)\n    , primus = this;\n\n  log('iterating over %d connections', ids.length);\n\n  function pushId(spark) {\n    ids.push(spark.id);\n  }\n\n  //\n  // We are going to iterate through the connections asynchronously so\n  // we should handle new connections as they come in.\n  //\n  primus.on('connection', pushId);\n\n  (function iterate() {\n    var id = ids.shift()\n      , spark;\n\n    if (!id) {\n      primus.removeListener('connection', pushId);\n      return done();\n    }\n\n    spark = primus.spark(id);\n\n    //\n    // The connection may have already been closed.\n    //\n    if (!spark) return iterate();\n\n    fn(spark, function next(err, forward) {\n      if (err || forward === false) {\n        primus.removeListener('connection', pushId);\n        return done(err);\n      }\n\n      iterate();\n    });\n  }());\n\n  return this;\n});\n\n/**\n * Send a ping packet to all clients to ensure that they are still connected.\n *\n * @returns {Primus}\n * @api private\n */\nPrimus.readable('heartbeat', function heartbeat() {\n  this.forEach(function forEach(spark) {\n    spark.heartbeat();\n  });\n\n  return this;\n});\n\n/**\n * Broadcast the message to all connections.\n *\n * @param {Mixed} data The data you want to send.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('write', function write(data) {\n  this.forEach(function forEach(spark) {\n    spark.write(data);\n  });\n\n  return this;\n});\n\n/**\n * Install message parsers.\n *\n * @param {Mixed} parser Parse name or parser Object.\n * @returns {Primus}\n * @api private\n */\nPrimus.readable('parsers', function parsers(parser) {\n  parser = parser || 'json';\n\n  if ('string' === typeof parser) {\n    log('transformer `%s` is a string, attempting to resolve location', parser);\n    parser = parser.toLowerCase();\n    this.spec.parser = parser;\n\n    //\n    // This is a unknown parser, it could be people made a typo.\n    //\n    if (!(parser in Primus.parsers)) {\n      log('the supplied parser `%s` is not supported please use %s', parser, Primus.parsers);\n      throw new PrimusError(this.is(parser, Primus.parsers).unknown(), this);\n    }\n\n    try { parser = require('./parsers/'+ parser); }\n    catch (e) {\n      if (e.code === 'MODULE_NOT_FOUND') {\n        log('the supplied parser `%s` is missing', parser);\n        throw new PrimusError(this.is(parser, Primus.parsers).missing(), this);\n      } else {\n        log(e);\n        throw e;\n      }\n    }\n  } else {\n    this.spec.parser = 'custom';\n  }\n\n  if ('object' !== typeof parser) {\n    throw new PrimusError('The given parser is not an Object', this);\n  }\n\n  this.encoder = parser.encoder;\n  this.decoder = parser.decoder;\n  this.parser = parser;\n\n  return this;\n});\n\n/**\n * Register a new message transformer. This allows you to easily manipulate incoming\n * and outgoing data which is particularity handy for plugins that want to send\n * meta data together with the messages.\n *\n * @param {String} type Incoming or outgoing\n * @param {Function} fn A new message transformer.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('transform', function transform(type, fn) {\n  if (!(type in this.transformers)) {\n    throw new PrimusError('Invalid transformer type', this);\n  }\n\n  if (~this.transformers[type].indexOf(fn)) {\n    log('the %s message transformer already exists, not adding it', type);\n    return this;\n  }\n\n  this.transformers[type].push(fn);\n  return this;\n});\n\n/**\n * Gets a spark by its id.\n *\n * @param {String} id The spark's id.\n * @returns {Spark}\n * @api private\n */\nPrimus.readable('spark', function spark(id) {\n  return this.connections[id];\n});\n\n/**\n * Generate a client library.\n *\n * @param {Boolean} nodejs Don't include the library, as we're running on Node.js.\n * @returns {String} The client library.\n * @api public\n */\nPrimus.readable('library', function compile(nodejs) {\n  var library = [ !nodejs ? this.transformer.library : null ]\n    , global = this.options.global || 'Primus'\n    , parser = this.parser.library || ''\n    , client = this.client;\n\n  //\n  // Add a simple export wrapper so it can be used as Node.js, AMD or browser\n  // client.\n  //\n  client = [\n    '(function UMDish(name, context, definition, plugins) {',\n    '  context[name] = definition.call(context);',\n    '  for (var i = 0; i < plugins.length; i++) {',\n    '    plugins[i](context[name])',\n    '  }',\n    '  if (typeof module !== \"undefined\" && module.exports) {',\n    '    module.exports = context[name];',\n    '  } else if (typeof define === \"function\" && define.amd) {',\n    '    define(function reference() { return context[name]; });',\n    '  }',\n    '})(\"'+ global +'\", this || {}, function wrapper() {',\n    '  var define, module, exports',\n    '    , Primus = '+ client.slice(client.indexOf('return ') + 7, -4) +';',\n    ''\n  ].join('\\n');\n\n  //\n  // Replace some basic content.\n  //\n  client = client\n    .replace('null; // @import {primus::pathname}', '\"'+ this.pathname.toString() +'\"')\n    .replace('null; // @import {primus::version}', '\"'+ this.version +'\"')\n    .replace('null; // @import {primus::client}', this.transformer.client.toString())\n    .replace('null; // @import {primus::auth}', (!!this.auth).toString())\n    .replace('null; // @import {primus::encoder}', this.encoder.toString())\n    .replace('null; // @import {primus::decoder}', this.decoder.toString());\n\n  //\n  // As we're given a `pingInterval` value on the server side, we need to update\n  // the `pingTimeout` on the client.\n  //\n  if (this.options.pingInterval) {\n    const value = this.options.pingInterval + Math.round(this.options.pingInterval / 2);\n\n    log('updating the default value of the client `pingTimeout` option');\n    client = client.replace(\n      'options.pingTimeout : 45e3;',\n      `options.pingTimeout : ${value};`\n    );\n  } else {\n    log('setting the default value of the client `pingTimeout` option to `false`');\n    client = client.replace(\n      'options.pingTimeout : 45e3;',\n      'options.pingTimeout : false;'\n    );\n  }\n\n  //\n  // Add the parser inside the closure, to prevent global leaking.\n  //\n  if (parser && parser.length) {\n    log('adding parser to the client file');\n    client += parser;\n  }\n\n  //\n  // Iterate over the parsers, and register the client side plugins. If there's\n  // a library bundled, add it the library array as there were some issues with\n  // frameworks that get included in module wrapper as it forces strict mode.\n  //\n  var name, plugin;\n\n  for (name in this.ark) {\n    plugin = this.ark[name];\n    name = JSON.stringify(name);\n\n    if (plugin.library) {\n      log('adding the library of the %s plugin to the client file', name);\n      library.push(plugin.library);\n    }\n\n    if (!plugin.client) continue;\n\n    log('adding the client code of the %s plugin to the client file', name);\n    client += 'Primus.prototype.ark['+ name +'] = '+ plugin.client.toString() +';\\n';\n  }\n\n  //\n  // Close the export wrapper and return the client. If we need to add\n  // a library, we should add them after we've created our closure and module\n  // exports. Some libraries seem to fail hard once they are wrapped in our\n  // closure so I'll rather expose a global variable instead of having to monkey\n  // patch too much code.\n  //\n  return client + [\n    '  return Primus;',\n    '},',\n    '['\n  ].concat(library.filter(Boolean).map(function expose(library) {\n    return [\n      'function (Primus) {',\n      library,\n      '}'\n    ].join('\\n');\n  }).join(',\\n'))\n  .concat(']);')\n  .join('\\n');\n});\n\n/**\n * Save the library to disk.\n *\n * @param {String} dir The location that we need to save the library.\n * @param {function} fn Optional callback, if you want an async save.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('save', function save(path, fn) {\n  if (!fn) fs.writeFileSync(path, this.library(), 'utf-8');\n  else fs.writeFile(path, this.library(), 'utf-8', fn);\n\n  return this;\n});\n\n/**\n * Register a new Primus plugin.\n *\n * ```js\n * primus.plugin('ack', {\n *   //\n *   // Only ran on the server.\n *   //\n *   server: function (primus, options) {\n *      // do stuff\n *   },\n *\n *   //\n *   // Runs on the client, it's automatically bundled.\n *   //\n *   client: function (primus, options) {\n *      // do client stuff\n *   },\n *\n *   //\n *   // Optional library that needs to be bundled on the client (should be a string)\n *   //\n *   library: ''\n * });\n * ```\n *\n * @param {String} name The name of the plugin.\n * @param {Object} energon The plugin that contains client and server extensions.\n * @returns {Mixed}\n * @api public\n */\nPrimus.readable('plugin', function plugin(name, energon) {\n  if (!name) return this.ark;\n\n  if (!energon) {\n    if ('string' === typeof name) return this.ark[name];\n    if ('object' === typeof name) {\n      energon = name;\n      name = energon.name;\n    }\n  }\n\n  if ('string' !== typeof name || !name) {\n    throw new PrimusError('Plugin name must be a non empty string', this);\n  }\n\n  if ('string' === typeof energon) {\n    log('plugin was passed as a string, attempting to require %s', energon);\n    energon = require(energon);\n  }\n\n  //\n  // Plugin accepts an object or a function only.\n  //\n  if (!/^(object|function)$/.test(typeof energon)) {\n    throw new PrimusError('Plugin should be an object or function', this);\n  }\n\n  //\n  // Plugin require a client, server or both to be specified in the object.\n  //\n  if (!energon.server && !energon.client) {\n    throw new PrimusError('Plugin is missing a client or server function', this);\n  }\n\n  //\n  // Don't allow duplicate plugins or plugin override as this is most likely\n  // unintentional.\n  //\n  if (name in this.ark) {\n    throw new PrimusError('Plugin name already defined', this);\n  }\n\n  log('adding %s as new plugin', name);\n  this.ark[name] = energon;\n  this.emit('plugin', name, energon);\n\n  if (!energon.server) return this;\n\n  log('calling the %s plugin\\'s server code', name);\n  energon.server.call(this, this, this.options);\n\n  return this;\n});\n\n/**\n * Remove plugin from the ark.\n *\n * @param {String} name Name of the plugin we need to remove from the ark.\n * @returns {Boolean} Successful removal of the plugin.\n * @api public\n */\nPrimus.readable('plugout', function plugout(name) {\n  if (!(name in this.ark)) return false;\n\n  this.emit('plugout', name, this.ark[name]);\n  delete this.ark[name];\n\n  return true;\n});\n\n/**\n * Add a new middleware layer. If no middleware name has been provided we will\n * attempt to take the name of the supplied function. If that fails, well fuck,\n * just random id it.\n *\n * @param {String} name The name of the middleware.\n * @param {Function} fn The middleware that's called each time.\n * @param {Object} options Middleware configuration.\n * @param {Number} level 0 based optional index for the middleware.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('use', function use(name, fn, options, level) {\n  if ('function' === typeof name) {\n    level = options;\n    options = fn;\n    fn = name;\n    name = fn.name || 'pid_'+ Date.now();\n  }\n\n  if (!level && 'number' === typeof options) {\n    level = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  //\n  // No or only 1 argument means that we need to initialise the middleware, this\n  // is a special initialisation process where we pass in a reference to the\n  // initialised Primus instance so a pre-compiling process can be done.\n  //\n  if (fn.length < 2) {\n    log('automatically configuring middleware `%s`', name);\n    fn = fn.call(this, options);\n  }\n\n  //\n  // Make sure that we have a function that takes at least 2 arguments.\n  //\n  if ('function' !== typeof fn || fn.length < 2) {\n    throw new PrimusError('Middleware should be a function that accepts at least 2 args');\n  }\n\n  var layer = {\n    length: fn.length,                // Amount of arguments indicates if it's async.\n    enabled: true,                    // Middleware is enabled by default.\n    name: name,                       // Used for lookups.\n    fn: fn                            // The actual middleware.\n  }, index = this.indexOfLayer(name);\n\n  //\n  // Override middleware layer if we already have a middleware layer with\n  // exactly the same name.\n  //\n  if (!~index) {\n    if (level >= 0 && level < this.layers.length) {\n      log('adding middleware `%s` to the supplied index at %d', name, level);\n      this.layers.splice(level, 0, layer);\n    } else {\n      this.layers.push(layer);\n    }\n  } else {\n    this.layers[index] = layer;\n  }\n\n  return this;\n});\n\n/**\n * Remove a middleware layer from the stack.\n *\n * @param {String} name The name of the middleware.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('remove', function remove(name) {\n  var index = this.indexOfLayer(name);\n\n  if (~index) {\n    log('removing middleware `%s`', name);\n    this.layers.splice(index, 1);\n  }\n\n  return this;\n});\n\n/**\n * Enable a given middleware layer.\n *\n * @param {String} name The name of the middleware.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('enable', function enable(name) {\n  var index = this.indexOfLayer(name);\n\n  if (~index) {\n    log('enabling middleware `%s`', name);\n    this.layers[index].enabled = true;\n  }\n  return this;\n});\n\n/**\n * Disable a given middleware layer.\n *\n * @param {String} name The name of the middleware.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('disable', function disable(name) {\n  var index = this.indexOfLayer(name);\n\n  if (~index) {\n    log('disabling middleware `%s`', name);\n    this.layers[index].enabled = false;\n  }\n\n  return this;\n});\n\n/**\n * Find the index of a given middleware layer by name.\n *\n * @param {String} name The name of the layer.\n * @returns {Number}\n * @api private\n */\nPrimus.readable('indexOfLayer', function indexOfLayer(name) {\n  for (var i = 0, length = this.layers.length; i < length; i++) {\n    if (this.layers[i].name === name) return i;\n  }\n\n  return -1;\n});\n\n/**\n * Destroy the created Primus instance.\n *\n * Options:\n * - close (boolean) Close the given server.\n * - reconnect (boolean) Trigger a client-side reconnect.\n * - timeout (number) Close all active connections after x milliseconds.\n *\n * @param {Object} options Destruction instructions.\n * @param {Function} fn Callback.\n * @returns {Primus}\n * @api public\n */\nPrimus.readable('destroy', function destroy(options, fn) {\n  if ('function' === typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  options = options || {};\n  if (options.reconnect) options.close = true;\n\n  var primus = this;\n\n  clearInterval(primus.heartbeatInterval);\n\n  setTimeout(function close() {\n    var transformer = primus.transformer;\n\n    //\n    // Ensure that the transformer receives the `close` event only once.\n    //\n    if (transformer) transformer.ultron.destroy();\n\n    //\n    // Close the connections that are left open.\n    //\n    primus.forEach(function shutdown(spark) {\n      spark.end(undefined, { reconnect: options.reconnect });\n    });\n\n    if (options.close !== false) {\n      //\n      // Closing a server that isn't started yet would throw an error.\n      //\n      try {\n        primus.server.close(function closed() {\n          primus.close(options, fn);\n        });\n        return;\n      }\n      catch (e) {}\n    }\n\n    primus.close(options, fn);\n  }, +options.timeout || 0);\n\n  return this;\n});\n\n/**\n * Free resources after emitting a final `close` event.\n *\n * @param {Object} options Destruction instructions.\n * @param {Function} fn Callback.\n * @returns {Primus}\n * @api private\n */\nPrimus.readable('close', function close(options, fn) {\n  var primus = this;\n  //\n  // Emit a final `close` event before removing all the listeners\n  // from all the event emitters.\n  //\n  primus.asyncemit('close', options, function done(err) {\n    if (err) {\n      if (fn) return fn(err);\n      throw err;\n    }\n\n    var transformer = primus.transformer\n      , server = primus.server;\n\n    //\n    // If we don't have a server we are most likely destroying an already\n    // destroyed Primus instance.\n    //\n    if (!server) return fn && fn();\n\n    server.removeAllListeners('request');\n    server.removeAllListeners('upgrade');\n\n    //\n    // Re-add the original listeners so that the server can be used again.\n    //\n    transformer.listeners('previous::request').forEach(function add(listener) {\n      server.on('request', listener);\n    });\n    transformer.listeners('previous::upgrade').forEach(function add(listener) {\n      server.on('upgrade', listener);\n    });\n\n    transformer.emit('close', options);\n    transformer.removeAllListeners();\n\n    primus.removeAllListeners();\n\n    //\n    // Null some potentially heavy objects to free some more memory instantly.\n    //\n    primus.transformers.outgoing.length = primus.transformers.incoming.length = 0;\n    primus.transformer = primus.encoder = primus.decoder = primus.server = null;\n    primus.connected = 0;\n\n    primus.connections = Object.create(null);\n    primus.ark = Object.create(null);\n\n    if (fn) fn();\n  });\n\n  return this;\n});\n\n/**\n * Async emit an event. We make a really broad assumption here and that is they\n * have the same amount of arguments as the supplied arguments (excluding the\n * event name).\n *\n * @returns {Primus}\n * @api private\n */\nPrimus.readable('asyncemit', require('asyncemit'));\n\n//\n// Alias for destroy.\n//\nPrimus.readable('end', Primus.prototype.destroy);\n\n/**\n * Checks if the given event is an emitted event by Primus.\n *\n * @param {String} evt The event name.\n * @returns {Boolean}\n * @api public\n */\nPrimus.readable('reserved', function reserved(evt) {\n  return (/^(incoming|outgoing)::/).test(evt)\n  || evt in reserved.events;\n});\n\n/**\n * The actual events that are used by Primus.\n *\n * @type {Object}\n * @api public\n */\nPrimus.prototype.reserved.events = {\n  'disconnection': 1,\n  'initialised': 1,\n  'connection': 1,\n  'plugout': 1,\n  'plugin': 1,\n  'close': 1,\n  'log': 1\n};\n\n/**\n * Add a createSocket interface so we can create a Server client with the\n * specified `transformer` and `parser`.\n *\n * ```js\n * var Socket = Primus.createSocket({ transformer: transformer, parser: parser })\n *   , socket = new Socket(url);\n * ```\n *\n * @param {Object} options The transformer / parser we need.\n * @returns {Socket}\n * @api public\n */\nPrimus.createSocket = function createSocket(options) {\n  // Make sure the temporary Primus we create below doesn't start a heartbeat\n  options = Object.assign({}, options, { pingInterval: false });\n\n  var primus = new Primus(new EventEmitter(), options);\n  return primus.Socket;\n};\n\n/**\n * Create a new Primus server.\n *\n * @param {Function} fn Request listener.\n * @param {Object} options Configuration.\n * @returns {Pipe}\n * @api public\n */\nPrimus.createServer = function createServer(fn, options) {\n  if ('object' === typeof fn) {\n    options = fn;\n    fn = null;\n  }\n\n  options = options || {};\n\n  var server = require('create-server')(Primus.prototype.merge.call(Primus, {\n    http: function warn() {\n      if (!options.iknowhttpsisbetter) [\n        '',\n        'We\\'ve detected that you\\'re using a HTTP instead of a HTTPS server.',\n        'Please be aware that real-time connections have less chance of being blocked',\n        'by firewalls and anti-virus scanners if they are encrypted (using SSL). If',\n        'you run your server behind a reverse and HTTPS terminating proxy ignore',\n        'this message, if not, you\\'ve been warned.',\n        ''\n      ].forEach(function each(line) {\n        console.log('primus: '+ line);\n      });\n    }\n  }, options));\n\n  //\n  // Now that we've got a server, we can setup the Primus and start listening.\n  //\n  var application = new Primus(server, options);\n\n  if (fn) application.on('connection', fn);\n  return application;\n};\n\n//\n// Expose the constructors of our Spark and Transformer so it can be extended by\n// a third party if needed.\n//\nPrimus.Transformer = Transformer;\nPrimus.Spark = Spark;\n\n//\n// Expose the module.\n//\nmodule.exports = Primus;\n"
        },
        {
          "name": "issues",
          "type": "tree",
          "content": null
        },
        {
          "name": "middleware",
          "type": "tree",
          "content": null
        },
        {
          "name": "migration.md",
          "type": "blob",
          "size": 3.1416015625,
          "content": "# migration\n\n- [Socket.IO](#Socket.IO)\n- [Engine.IO]()\n- [Sockjs]()\n- [Browserchannel]()\n- [WebSockets]()\n\nTransforming your current project to use Primus is not as hard as you might\nthink. The API’s in Primus are really similar to the one’s your currently using\nin framework **X**. We’ve prepared some small migration guides to make it even\neasier!\n\n## Socket.IO\n\n- `socket.send`: Use the `socket.write` method.\n- `socket.volatile`: No known replacement, but did not work as intended in\n  Socket.IO either so I don't assume this as a big loss\n- `socket.json.send`: Use the `socket.write` method, the encoding is done by default.\n\n\n### Missing features\n\nIf you’ve been using Socket.IO quite heavily you might notice that there are\nsome features from Socket.IO that are missing in Primus. The reason that these\nfeatures are not implemented is that we want to keep core light so it's easier\nto maintain and fix bugs. But! All of these missing features can be\nre-introduced in Primus using plugins! Our amazing community has stepped up and\ncreated a couple of small and reusable modules that add this missing\nfunctionality.\n\n#### Rooms\n\nPrimus doesn’t have a concept of rooms. If you are using the `socket.join` and\n`socket.leave` methods in your code you can install the `primus-rooms` plugin:\n\n```\nnpm install --save primus-rooms\n```\n\nAfter installing you can add the plugin using:\n\n```js\nprimus.plugin('rooms', require('primus-rooms'));\n```\n\nAnd now you can join and leave rooms again. Manually leaving rooms when the\nuser disconnects isn't necessary, the plugin handles this for you. For more\ninformation checkout the project on GitHub:\n\nhttps://github.com/cayasso/primus-rooms\n\n#### Namespace also known as multiplex\n\nIn Socket.IO you have a special `server.of` method which creates a new\nnamespace. There are some problems with this namespace implementation and that\nis that these namespaces are static and once they are created the live for the\nduration of your application. The plugins that introduce multiplexing in Primus\ndo not suffer from this, making them more flexible and powerful. There are two\ndifferent plugin you can use for multiplexing, there is `substream` which is\nmaintained by the Primus project or you can use `primus-multiplex`.\n\n#### emit\n\nThere are different modules that re-introduce the `emit` method. You could use\nthe `primus-emit` module which is build and maintained by the Primus project or\nthe `primus-emitter`. The main different between these modules is the size of\nthe code and the method that its using to emit events. The `primus-emit` module\nuses the same `emit` method to trigger events on the server and client while the\nother module uses a `send` method. The `primus-emit` module is smaller in size\nwhile the `primus-emitter` module is required by other plugins. \n\n> “A wish decision, you must make, young padawan” -- Yoda\n\nIn this guide we’re going to be using the `primus-emit` plugin as it has\ncomplete API compatibility with Socket.IO. We install this module using:\n\n```\nnpm install --save primus-emit\n```\n\nAnd the only thing we need to do to use it to add the plugin to the Primus\nserver using:\n\n```js\nprimus.plugin('emit', require('primus-emit'));\n```\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 2.67578125,
          "content": "{\n  \"name\": \"primus\",\n  \"version\": \"8.0.9\",\n  \"description\": \"Primus is a simple abstraction around real-time frameworks. It allows you to easily switch between different frameworks without any code changes.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"mkdir -p dist && browserify primus.js -s Primus -p deumdify | derequire > dist/primus.js\",\n    \"update\": \"find transformers -name update.sh -exec bash {} \\\\;\",\n    \"integration\": \"npm run build && mocha test/*.integration.js --exit\",\n    \"test\": \"npm run build && mocha test/*.test.js\",\n    \"prepublishOnly\": \"npm run build\"\n  },\n  \"homepage\": \"https://github.com/primus/primus#readme\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/primus/primus.git\"\n  },\n  \"keywords\": [\n    \"abstraction\",\n    \"browserchannel\",\n    \"engine.io\",\n    \"framework\",\n    \"comet\",\n    \"streaming\",\n    \"pubsub\",\n    \"pub\",\n    \"sub\",\n    \"ajax\",\n    \"xhr\",\n    \"polling\",\n    \"http\",\n    \"faye\",\n    \"io\",\n    \"primus\",\n    \"prumus\",\n    \"real-time\",\n    \"realtime\",\n    \"socket\",\n    \"socket.io\",\n    \"sockets\",\n    \"sockjs\",\n    \"spark\",\n    \"transformer\",\n    \"transformers\",\n    \"websocket\",\n    \"websockets\",\n    \"ws\",\n    \"uws\"\n  ],\n  \"author\": \"Arnout Kazemier\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"access-control\": \"~1.0.0\",\n    \"asyncemit\": \"~3.0.1\",\n    \"create-server\": \"~1.0.1\",\n    \"diagnostics\": \"~2.0.0\",\n    \"eventemitter3\": \"~5.0.0\",\n    \"forwarded-for\": \"~1.1.0\",\n    \"fusing\": \"~1.0.0\",\n    \"nanoid\": \"~3.3.3\",\n    \"setheader\": \"~1.0.2\",\n    \"ultron\": \"~1.1.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"~7.23.2\",\n    \"@babel/plugin-transform-object-assign\": \"~7.22.5\",\n    \"@babel/preset-env\": \"~7.23.2\",\n    \"@rollup/plugin-babel\": \"~6.0.3\",\n    \"@rollup/plugin-commonjs\": \"~25.0.3\",\n    \"@rollup/plugin-node-resolve\": \"~15.2.3\",\n    \"binary-pack\": \"~1.0.2\",\n    \"browserchannel\": \"~2.1.0\",\n    \"browserify\": \"~17.0.0\",\n    \"chai\": \"~4.3.4\",\n    \"condenseify\": \"~1.1.1\",\n    \"demolish\": \"~1.0.2\",\n    \"derequire\": \"~2.1.1\",\n    \"deumdify\": \"~1.2.3\",\n    \"ejson\": \"~2.2.0\",\n    \"emits\": \"~3.0.0\",\n    \"engine.io\": \"~6.5.1\",\n    \"engine.io-client\": \"~6.5.1\",\n    \"faye-websocket\": \"~0.11.0\",\n    \"inherits\": \"~2.0.3\",\n    \"mocha\": \"~10.2.0\",\n    \"pre-commit\": \"~1.2.0\",\n    \"primus-msgpack\": \"~1.0.2\",\n    \"pumpify\": \"~2.0.0\",\n    \"querystringify\": \"~2.2.0\",\n    \"recovery\": \"~0.2.6\",\n    \"request\": \"~2.88.0\",\n    \"rocambole\": \"~0.7.0\",\n    \"rocambole-node-remove\": \"~3.0.0\",\n    \"rollup\": \"~4.3.0\",\n    \"sockjs\": \"~0.3.18\",\n    \"sockjs-client\": \"~1.6.0\",\n    \"through2\": \"~4.0.2\",\n    \"tick-tock\": \"~1.0.0\",\n    \"url-parse\": \"~1.5.1\",\n    \"uws\": \"10.148.1\",\n    \"ws\": \"~8.14.2\",\n    \"yeast\": \"~0.1.2\"\n  },\n  \"pre-commit\": \"test, integration\"\n}\n"
        },
        {
          "name": "parsers.json",
          "type": "blob",
          "size": 0.1513671875,
          "content": "{\n  \"json\": {},\n  \"ejson\": {\n    \"server\": \"ejson\"\n  },\n  \"binary\": {\n    \"server\": \"binary-pack\"\n  },\n  \"msgpack\": {\n    \"server\": \"primus-msgpack\"\n  }\n}\n"
        },
        {
          "name": "parsers",
          "type": "tree",
          "content": null
        },
        {
          "name": "primus.js",
          "type": "blob",
          "size": 31.3505859375,
          "content": "/*globals require, define */\n'use strict';\n\nvar EventEmitter = require('eventemitter3')\n  , TickTock = require('tick-tock')\n  , Recovery = require('recovery')\n  , qs = require('querystringify')\n  , inherits = require('inherits')\n  , destroy = require('demolish')\n  , yeast = require('yeast')\n  , u2028 = /\\u2028/g\n  , u2029 = /\\u2029/g;\n\n/**\n * Context assertion, ensure that some of our public Primus methods are called\n * with the correct context to ensure that\n *\n * @param {Primus} self The context of the function.\n * @param {String} method The method name.\n * @api private\n */\nfunction context(self, method) {\n  if (self instanceof Primus) return;\n\n  var failure = new Error('Primus#'+ method + '\\'s context should called with a Primus instance');\n\n  if ('function' !== typeof self.listeners || !self.listeners('error').length) {\n    throw failure;\n  }\n\n  self.emit('error', failure);\n}\n\n//\n// Sets the default connection URL, it uses the default origin of the browser\n// when supported but degrades for older browsers. In Node.js, we cannot guess\n// where the user wants to connect to, so we just default to localhost.\n//\nvar defaultUrl;\n\ntry {\n  if (location.origin) {\n    defaultUrl = location.origin;\n  } else {\n    defaultUrl = location.protocol +'//'+ location.host;\n  }\n} catch (e) {\n  defaultUrl = 'http://127.0.0.1';\n}\n\n/**\n * Primus is a real-time library agnostic framework for establishing real-time\n * connections with servers.\n *\n * Options:\n * - reconnect, configuration for the reconnect process.\n * - manual, don't automatically call `.open` to start the connection.\n * - websockets, force the use of WebSockets, even when you should avoid them.\n * - timeout, connect timeout, server didn't respond in a timely manner.\n * - pingTimeout, The maximum amount of time to wait for the server to send a ping.\n * - network, Use network events as leading method for network connection drops.\n * - strategy, Reconnection strategies.\n * - transport, Transport options.\n * - url, uri, The URL to use connect with the server.\n *\n * @constructor\n * @param {String} url The URL of your server.\n * @param {Object} options The configuration.\n * @api public\n */\nfunction Primus(url, options) {\n  if (!(this instanceof Primus)) return new Primus(url, options);\n\n  Primus.Stream.call(this);\n\n  if ('function' !== typeof this.client) {\n    return this.critical(new Error(\n      'The client library has not been compiled correctly, see '+\n      'https://github.com/primus/primus#client-library for more details'\n    ));\n  }\n\n  if ('object' === typeof url) {\n    options = url;\n    url = options.url || options.uri || defaultUrl;\n  } else {\n    options = options || {};\n  }\n\n  if ('ping' in options || 'pong' in options) {\n    return this.critical(new Error(\n      'The `ping` and `pong` options have been removed'\n    ));\n  }\n\n  var primus = this;\n\n  // The maximum number of messages that can be placed in queue.\n  options.queueSize = 'queueSize' in options ? options.queueSize : Infinity;\n\n  // Connection timeout duration.\n  options.timeout = 'timeout' in options ? options.timeout : 10e3;\n\n  // Stores the back off configuration.\n  options.reconnect = 'reconnect' in options ? options.reconnect : {};\n\n  // Heartbeat ping interval.\n  options.pingTimeout = 'pingTimeout' in options ? options.pingTimeout : 45e3;\n\n  // Reconnect strategies.\n  options.strategy = 'strategy' in options ? options.strategy : [];\n\n  // Custom transport options.\n  options.transport = 'transport' in options ? options.transport : {};\n\n  primus.buffer = [];                           // Stores premature send data.\n  primus.writable = true;                       // Silly stream compatibility.\n  primus.readable = true;                       // Silly stream compatibility.\n  primus.url = primus.parse(url || defaultUrl); // Parse the URL to a readable format.\n  primus.readyState = Primus.CLOSED;            // The readyState of the connection.\n  primus.options = options;                     // Reference to the supplied options.\n  primus.timers = new TickTock(this);           // Contains all our timers.\n  primus.socket = null;                         // Reference to the internal connection.\n  primus.disconnect = false;                    // Did we receive a disconnect packet?\n  primus.transport = options.transport;         // Transport options.\n  primus.transformers = {                       // Message transformers.\n    outgoing: [],\n    incoming: []\n  };\n\n  //\n  // Create our reconnection instance.\n  //\n  primus.recovery = new Recovery(options.reconnect);\n\n  //\n  // Parse the reconnection strategy. It can have the following strategies:\n  //\n  // - timeout: Reconnect when we have a network timeout.\n  // - disconnect: Reconnect when we have an unexpected disconnect.\n  // - online: Reconnect when we're back online.\n  //\n  if ('string' === typeof options.strategy) {\n    options.strategy = options.strategy.split(/\\s?,\\s?/g);\n  }\n\n  if (false === options.strategy) {\n    //\n    // Strategies are disabled, but we still need an empty array to join it in\n    // to nothing.\n    //\n    options.strategy = [];\n  } else if (!options.strategy.length) {\n    options.strategy.push('disconnect', 'online');\n\n    //\n    // Timeout based reconnection should only be enabled conditionally. When\n    // authorization is enabled it could trigger.\n    //\n    if (!this.authorization) options.strategy.push('timeout');\n  }\n\n  options.strategy = options.strategy.join(',').toLowerCase();\n\n  //\n  // Force the use of WebSockets, even when we've detected some potential\n  // broken WebSocket implementation.\n  //\n  if ('websockets' in options) {\n    primus.AVOID_WEBSOCKETS = !options.websockets;\n  }\n\n  //\n  // Force or disable the use of NETWORK events as leading client side\n  // disconnection detection.\n  //\n  if ('network' in options) {\n    primus.NETWORK_EVENTS = options.network;\n  }\n\n  //\n  // Check if the user wants to manually initialise a connection. If they don't,\n  // we want to do it after a really small timeout so we give the users enough\n  // time to listen for `error` events etc.\n  //\n  if (!options.manual) primus.timers.setTimeout('open', function open() {\n    primus.timers.clear('open');\n    primus.open();\n  }, 0);\n\n  primus.initialise(options);\n}\n\n/**\n * Simple require wrapper to make browserify, node and require.js play nice.\n *\n * @param {String} name The module to require.\n * @returns {Object|Undefined} The module that we required.\n * @api private\n */\nPrimus.requires = Primus.require = function requires(name) {\n  if ('function' !== typeof require) return undefined;\n\n  return !('function' === typeof define && define.amd)\n    ? require(name)\n    : undefined;\n};\n\n//\n// It's possible that we're running in Node.js or in a Node.js compatible\n// environment. In this cases we try to inherit from the Stream base class.\n//\ntry {\n  Primus.Stream = Primus.requires('stream');\n} catch (e) { }\n\nif (!Primus.Stream) Primus.Stream = EventEmitter;\n\ninherits(Primus, Primus.Stream);\n\n/**\n * Primus readyStates, used internally to set the correct ready state.\n *\n * @type {Number}\n * @private\n */\nPrimus.OPENING = 1;   // We're opening the connection.\nPrimus.CLOSED  = 2;   // No active connection.\nPrimus.OPEN    = 3;   // The connection is open.\n\n/**\n * Are we working with a potentially broken WebSockets implementation? This\n * boolean can be used by transformers to remove `WebSockets` from their\n * supported transports.\n *\n * @type {Boolean}\n * @private\n */\nPrimus.prototype.AVOID_WEBSOCKETS = false;\n\n/**\n * Some browsers support registering emitting `online` and `offline` events when\n * the connection has been dropped on the client. We're going to detect it in\n * a simple `try {} catch (e) {}` statement so we don't have to do complicated\n * feature detection.\n *\n * @type {Boolean}\n * @private\n */\nPrimus.prototype.NETWORK_EVENTS = false;\nPrimus.prototype.online = true;\n\ntry {\n  if (\n       Primus.prototype.NETWORK_EVENTS = 'onLine' in navigator\n    && (window.addEventListener || document.body.attachEvent)\n  ) {\n    if (!navigator.onLine) {\n      Primus.prototype.online = false;\n    }\n  }\n} catch (e) { }\n\n/**\n * The Ark contains all our plugins definitions. It's namespaced by\n * name => plugin.\n *\n * @type {Object}\n * @private\n */\nPrimus.prototype.ark = {};\n\n/**\n * Simple emit wrapper that returns a function that emits an event once it's\n * called. This makes it easier for transports to emit specific events.\n *\n * @returns {Function} A function that will emit the event when called.\n * @api public\n */\nPrimus.prototype.emits = require('emits');\n\n/**\n * Return the given plugin.\n *\n * @param {String} name The name of the plugin.\n * @returns {Object|undefined} The plugin or undefined.\n * @api public\n */\nPrimus.prototype.plugin = function plugin(name) {\n  context(this, 'plugin');\n\n  if (name) return this.ark[name];\n\n  var plugins = {};\n\n  for (name in this.ark) {\n    plugins[name] = this.ark[name];\n  }\n\n  return plugins;\n};\n\n/**\n * Checks if the given event is an emitted event by Primus.\n *\n * @param {String} evt The event name.\n * @returns {Boolean} Indication of the event is reserved for internal use.\n * @api public\n */\nPrimus.prototype.reserved = function reserved(evt) {\n  return (/^(incoming|outgoing)::/).test(evt)\n  || evt in this.reserved.events;\n};\n\n/**\n * The actual events that are used by the client.\n *\n * @type {Object}\n * @public\n */\nPrimus.prototype.reserved.events = {\n  'reconnect scheduled': 1,\n  'reconnect timeout': 1,\n  'readyStateChange': 1,\n  'reconnect failed': 1,\n  'reconnected': 1,\n  'reconnect': 1,\n  'offline': 1,\n  'timeout': 1,\n  'destroy': 1,\n  'online': 1,\n  'error': 1,\n  'close': 1,\n  'open': 1,\n  'data': 1,\n  'end': 1\n};\n\n/**\n * Initialise the Primus and setup all parsers and internal listeners.\n *\n * @param {Object} options The original options object.\n * @returns {Primus}\n * @api private\n */\nPrimus.prototype.initialise = function initialise(options) {\n  var primus = this;\n\n  primus.recovery\n  .on('reconnected', primus.emits('reconnected'))\n  .on('reconnect failed', primus.emits('reconnect failed', function failed(next) {\n    primus.emit('end');\n    next();\n  }))\n  .on('reconnect timeout', primus.emits('reconnect timeout'))\n  .on('reconnect scheduled', primus.emits('reconnect scheduled'))\n  .on('reconnect', primus.emits('reconnect', function reconnect(next) {\n    primus.emit('outgoing::reconnect');\n    next();\n  }));\n\n  primus.on('outgoing::open', function opening() {\n    var readyState = primus.readyState;\n\n    primus.readyState = Primus.OPENING;\n    if (readyState !== primus.readyState) {\n      primus.emit('readyStateChange', 'opening');\n    }\n  });\n\n  primus.on('incoming::open', function opened() {\n    var readyState = primus.readyState;\n\n    if (primus.recovery.reconnecting()) {\n      primus.recovery.reconnected();\n    }\n\n    //\n    // The connection has been opened so we should set our state to\n    // (writ|read)able so our stream compatibility works as intended.\n    //\n    primus.writable = true;\n    primus.readable = true;\n\n    //\n    // Make sure we are flagged as `online` as we've successfully opened the\n    // connection.\n    //\n    if (!primus.online) {\n      primus.online = true;\n      primus.emit('online');\n    }\n\n    primus.readyState = Primus.OPEN;\n    if (readyState !== primus.readyState) {\n      primus.emit('readyStateChange', 'open');\n    }\n\n    primus.heartbeat();\n\n    if (primus.buffer.length) {\n      var data = primus.buffer.slice()\n        , length = data.length\n        , i = 0;\n\n      primus.buffer.length = 0;\n\n      for (; i < length; i++) {\n        primus._write(data[i]);\n      }\n    }\n\n    primus.emit('open');\n  });\n\n  primus.on('incoming::ping', function ping(time) {\n    primus.online = true;\n    primus.heartbeat();\n    primus.emit('outgoing::pong', time);\n    primus._write('primus::pong::'+ time);\n  });\n\n  primus.on('incoming::error', function error(e) {\n    var connect = primus.timers.active('connect')\n      , err = e;\n\n    //\n    // When the error is not an Error instance we try to normalize it.\n    //\n    if ('string' === typeof e) {\n      err = new Error(e);\n    } else if (!(e instanceof Error) && 'object' === typeof e) {\n      //\n      // BrowserChannel and SockJS returns an object which contains some\n      // details of the error. In order to have a proper error we \"copy\" the\n      // details in an Error instance.\n      //\n      err = new Error(e.message || e.reason);\n      for (var key in e) {\n        if (Object.prototype.hasOwnProperty.call(e, key))\n          err[key] = e[key];\n      }\n    }\n    //\n    // We're still doing a reconnect attempt, it could be that we failed to\n    // connect because the server was down. Failing connect attempts should\n    // always emit an `error` event instead of a `open` event.\n    //\n    //\n    if (primus.recovery.reconnecting()) return primus.recovery.reconnected(err);\n    if (primus.listeners('error').length) primus.emit('error', err);\n\n    //\n    // We received an error while connecting, this most likely the result of an\n    // unauthorized access to the server.\n    //\n    if (connect) {\n      if (~primus.options.strategy.indexOf('timeout')) {\n        primus.recovery.reconnect();\n      } else {\n        primus.end();\n      }\n    }\n  });\n\n  primus.on('incoming::data', function message(raw) {\n    primus.decoder(raw, function decoding(err, data) {\n      //\n      // Do a \"safe\" emit('error') when we fail to parse a message. We don't\n      // want to throw here as listening to errors should be optional.\n      //\n      if (err) return primus.listeners('error').length && primus.emit('error', err);\n\n      //\n      // Handle all \"primus::\" prefixed protocol messages.\n      //\n      if (primus.protocol(data)) return;\n      primus.transforms(primus, primus, 'incoming', data, raw);\n    });\n  });\n\n  primus.on('incoming::end', function end() {\n    var readyState = primus.readyState;\n\n    //\n    // This `end` started with the receiving of a primus::server::close packet\n    // which indicated that the user/developer on the server closed the\n    // connection and it was not a result of a network disruption. So we should\n    // kill the connection without doing a reconnect.\n    //\n    if (primus.disconnect) {\n      primus.disconnect = false;\n\n      return primus.end();\n    }\n\n    //\n    // Always set the readyState to closed, and if we're still connecting, close\n    // the connection so we're sure that everything after this if statement block\n    // is only executed because our readyState is set to `open`.\n    //\n    primus.readyState = Primus.CLOSED;\n    if (readyState !== primus.readyState) {\n      primus.emit('readyStateChange', 'end');\n    }\n\n    if (primus.timers.active('connect')) primus.end();\n    if (readyState !== Primus.OPEN) {\n      return primus.recovery.reconnecting()\n        ? primus.recovery.reconnect()\n        : false;\n    }\n\n    this.writable = false;\n    this.readable = false;\n\n    //\n    // Clear all timers in case we're not going to reconnect.\n    //\n    this.timers.clear();\n\n    //\n    // Fire the `close` event as an indication of connection disruption.\n    // This is also fired by `primus#end` so it is emitted in all cases.\n    //\n    primus.emit('close');\n\n    //\n    // The disconnect was unintentional, probably because the server has\n    // shutdown, so if the reconnection is enabled start a reconnect procedure.\n    //\n    if (~primus.options.strategy.indexOf('disconnect')) {\n      return primus.recovery.reconnect();\n    }\n\n    primus.emit('outgoing::end');\n    primus.emit('end');\n  });\n\n  //\n  // Setup the real-time client.\n  //\n  primus.client();\n\n  //\n  // Process the potential plugins.\n  //\n  for (var plugin in primus.ark) {\n    primus.ark[plugin].call(primus, primus, options);\n  }\n\n  //\n  // NOTE: The following code is only required if we're supporting network\n  // events as it requires access to browser globals.\n  //\n  if (!primus.NETWORK_EVENTS) return primus;\n\n  /**\n   * Handler for offline notifications.\n   *\n   * @api private\n   */\n  primus.offlineHandler = function offline() {\n    if (!primus.online) return; // Already or still offline, bailout.\n\n    primus.online = false;\n    primus.emit('offline');\n    primus.end();\n\n    //\n    // It is certainly possible that we're in a reconnection loop and that the\n    // user goes offline. In this case we want to kill the existing attempt so\n    // when the user goes online, it will attempt to reconnect freshly again.\n    //\n    primus.recovery.reset();\n  };\n\n  /**\n   * Handler for online notifications.\n   *\n   * @api private\n   */\n  primus.onlineHandler = function online() {\n    if (primus.online) return; // Already or still online, bailout.\n\n    primus.online = true;\n    primus.emit('online');\n\n    if (~primus.options.strategy.indexOf('online')) {\n      primus.recovery.reconnect();\n    }\n  };\n\n  if (window.addEventListener) {\n    window.addEventListener('offline', primus.offlineHandler, false);\n    window.addEventListener('online', primus.onlineHandler, false);\n  } else if (document.body.attachEvent){\n    document.body.attachEvent('onoffline', primus.offlineHandler);\n    document.body.attachEvent('ononline', primus.onlineHandler);\n  }\n\n  return primus;\n};\n\n/**\n * Really dead simple protocol parser. We simply assume that every message that\n * is prefixed with `primus::` could be used as some sort of protocol definition\n * for Primus.\n *\n * @param {String} msg The data.\n * @returns {Boolean} Is a protocol message.\n * @api private\n */\nPrimus.prototype.protocol = function protocol(msg) {\n  if (\n       'string' !== typeof msg\n    || msg.indexOf('primus::') !== 0\n  ) return false;\n\n  var last = msg.indexOf(':', 8)\n    , value = msg.slice(last + 2);\n\n  switch (msg.slice(8,  last)) {\n    case 'ping':\n      this.emit('incoming::ping', +value);\n      break;\n\n    case 'server':\n      //\n      // The server is closing the connection, forcefully disconnect so we don't\n      // reconnect again.\n      //\n      if ('close' === value) {\n        this.disconnect = true;\n      }\n      break;\n\n    case 'id':\n      this.emit('incoming::id', value);\n      break;\n\n    //\n    // Unknown protocol, somebody is probably sending `primus::` prefixed\n    // messages.\n    //\n    default:\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Execute the set of message transformers from Primus on the incoming or\n * outgoing message.\n * This function and it's content should be in sync with Spark#transforms in\n * spark.js.\n *\n * @param {Primus} primus Reference to the Primus instance with message transformers.\n * @param {Spark|Primus} connection Connection that receives or sends data.\n * @param {String} type The type of message, 'incoming' or 'outgoing'.\n * @param {Mixed} data The data to send or that has been received.\n * @param {String} raw The raw encoded data.\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.transforms = function transforms(primus, connection, type, data, raw) {\n  var packet = { data: data }\n    , fns = primus.transformers[type];\n\n  //\n  // Iterate in series over the message transformers so we can allow optional\n  // asynchronous execution of message transformers which could for example\n  // retrieve additional data from the server, do extra decoding or even\n  // message validation.\n  //\n  (function transform(index, done) {\n    var transformer = fns[index++];\n\n    if (!transformer) return done();\n\n    if (1 === transformer.length) {\n      if (false === transformer.call(connection, packet)) {\n        //\n        // When false is returned by an incoming transformer it means that's\n        // being handled by the transformer and we should not emit the `data`\n        // event.\n        //\n        return;\n      }\n\n      return transform(index, done);\n    }\n\n    transformer.call(connection, packet, function finished(err, arg) {\n      if (err) return connection.emit('error', err);\n      if (false === arg) return;\n\n      transform(index, done);\n    });\n  }(0, function done() {\n    //\n    // We always emit 2 arguments for the data event, the first argument is the\n    // parsed data and the second argument is the raw string that we received.\n    // This allows you, for example, to do some validation on the parsed data\n    // and then save the raw string in your database without the stringify\n    // overhead.\n    //\n    if ('incoming' === type) return connection.emit('data', packet.data, raw);\n\n    connection._write(packet.data);\n  }));\n\n  return this;\n};\n\n/**\n * Retrieve the current id from the server.\n *\n * @param {Function} fn Callback function.\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.id = function id(fn) {\n  if (this.socket && this.socket.id) return fn(this.socket.id);\n\n  this._write('primus::id::');\n  return this.once('incoming::id', fn);\n};\n\n/**\n * Establish a connection with the server. When this function is called we\n * assume that we don't have any open connections. If you do call it when you\n * have a connection open, it could cause duplicate connections.\n *\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.open = function open() {\n  context(this, 'open');\n\n  //\n  // Only start a `connection timeout` procedure if we're not reconnecting as\n  // that shouldn't count as an initial connection. This should be started\n  // before the connection is opened to capture failing connections and kill the\n  // timeout.\n  //\n  if (!this.recovery.reconnecting() && this.options.timeout) this.timeout();\n\n  this.emit('outgoing::open');\n  return this;\n};\n\n/**\n * Send a new message.\n *\n * @param {Mixed} data The data that needs to be written.\n * @returns {Boolean} Always returns true as we don't support back pressure.\n * @api public\n */\nPrimus.prototype.write = function write(data) {\n  context(this, 'write');\n  this.transforms(this, this, 'outgoing', data);\n\n  return true;\n};\n\n/**\n * The actual message writer.\n *\n * @param {Mixed} data The message that needs to be written.\n * @returns {Boolean} Successful write to the underlaying transport.\n * @api private\n */\nPrimus.prototype._write = function write(data) {\n  var primus = this;\n\n  //\n  // The connection is closed, normally this would already be done in the\n  // `spark.write` method, but as `_write` is used internally, we should also\n  // add the same check here to prevent potential crashes by writing to a dead\n  // socket.\n  //\n  if (Primus.OPEN !== primus.readyState) {\n    //\n    // If the buffer is at capacity, remove the first item.\n    //\n    if (this.buffer.length === this.options.queueSize) {\n      this.buffer.splice(0, 1);\n    }\n\n    this.buffer.push(data);\n    return false;\n  }\n\n  primus.encoder(data, function encoded(err, packet) {\n    //\n    // Do a \"safe\" emit('error') when we fail to parse a message. We don't\n    // want to throw here as listening to errors should be optional.\n    //\n    if (err) return primus.listeners('error').length && primus.emit('error', err);\n\n    //\n    // Hack 1: \\u2028 and \\u2029 are allowed inside a JSON string, but JavaScript\n    // defines them as newline separators. Unescaped control characters are not\n    // allowed inside JSON strings, so this causes an error at parse time. We\n    // work around this issue by escaping these characters. This can cause\n    // errors with JSONP requests or if the string is just evaluated.\n    //\n    if ('string' === typeof packet) {\n      if (~packet.indexOf('\\u2028')) packet = packet.replace(u2028, '\\\\u2028');\n      if (~packet.indexOf('\\u2029')) packet = packet.replace(u2029, '\\\\u2029');\n    }\n\n    primus.emit('outgoing::data', packet);\n  });\n\n  return true;\n};\n\n/**\n * Set a timer that, upon expiration, closes the client.\n *\n * @returns {Primus}\n * @api private\n */\nPrimus.prototype.heartbeat = function heartbeat() {\n  if (!this.options.pingTimeout) return this;\n\n  this.timers.clear('heartbeat');\n  this.timers.setTimeout('heartbeat', function expired() {\n    //\n    // The network events already captured the offline event.\n    //\n    if (!this.online) return;\n\n    this.online = false;\n    this.emit('offline');\n    this.emit('incoming::end');\n  }, this.options.pingTimeout);\n\n  return this;\n};\n\n/**\n * Start a connection timeout.\n *\n * @returns {Primus}\n * @api private\n */\nPrimus.prototype.timeout = function timeout() {\n  var primus = this;\n\n  /**\n   * Remove all references to the timeout listener as we've received an event\n   * that can be used to determine state.\n   *\n   * @api private\n   */\n  function remove() {\n    primus.removeListener('error', remove)\n          .removeListener('open', remove)\n          .removeListener('end', remove)\n          .timers.clear('connect');\n  }\n\n  primus.timers.setTimeout('connect', function expired() {\n    remove(); // Clean up old references.\n\n    if (primus.readyState === Primus.OPEN || primus.recovery.reconnecting()) {\n      return;\n    }\n\n    primus.emit('timeout');\n\n    //\n    // We failed to connect to the server.\n    //\n    if (~primus.options.strategy.indexOf('timeout')) {\n      primus.recovery.reconnect();\n    } else {\n      primus.end();\n    }\n  }, primus.options.timeout);\n\n  return primus.on('error', remove)\n    .on('open', remove)\n    .on('end', remove);\n};\n\n/**\n * Close the connection completely.\n *\n * @param {Mixed} data last packet of data.\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.end = function end(data) {\n  context(this, 'end');\n\n  if (\n      this.readyState === Primus.CLOSED\n    && !this.timers.active('connect')\n    && !this.timers.active('open')\n  ) {\n    //\n    // If we are reconnecting stop the reconnection procedure.\n    //\n    if (this.recovery.reconnecting()) {\n      this.recovery.reset();\n      this.emit('end');\n    }\n\n    return this;\n  }\n\n  if (data !== undefined) this.write(data);\n\n  this.writable = false;\n  this.readable = false;\n\n  var readyState = this.readyState;\n  this.readyState = Primus.CLOSED;\n\n  if (readyState !== this.readyState) {\n    this.emit('readyStateChange', 'end');\n  }\n\n  this.timers.clear();\n  this.emit('outgoing::end');\n  this.emit('close');\n  this.emit('end');\n\n  return this;\n};\n\n/**\n * Completely demolish the Primus instance and forcefully nuke all references.\n *\n * @returns {Boolean}\n * @api public\n */\nPrimus.prototype.destroy = destroy('url timers options recovery socket transport transformers', {\n  before: 'end',\n  after: ['removeAllListeners', function detach() {\n    if (!this.NETWORK_EVENTS) return;\n\n    if (window.addEventListener) {\n      window.removeEventListener('offline', this.offlineHandler);\n      window.removeEventListener('online', this.onlineHandler);\n    } else if (document.body.attachEvent){\n      document.body.detachEvent('onoffline', this.offlineHandler);\n      document.body.detachEvent('ononline', this.onlineHandler);\n    }\n  }]\n});\n\n/**\n * Create a shallow clone of a given object.\n *\n * @param {Object} obj The object that needs to be cloned.\n * @returns {Object} Copy.\n * @api private\n */\nPrimus.prototype.clone = function clone(obj) {\n  return this.merge({}, obj);\n};\n\n/**\n * Merge different objects in to one target object.\n *\n * @param {Object} target The object where everything should be merged in.\n * @returns {Object} Original target with all merged objects.\n * @api private\n */\nPrimus.prototype.merge = function merge(target) {\n  for (var i = 1, key, obj; i < arguments.length; i++) {\n    obj = arguments[i];\n\n    for (key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key))\n        target[key] = obj[key];\n    }\n  }\n\n  return target;\n};\n\n/**\n * Parse the connection string.\n *\n * @type {Function}\n * @param {String} url Connection URL.\n * @returns {Object} Parsed connection.\n * @api private\n */\nPrimus.prototype.parse = require('url-parse');\n\n/**\n * Parse a query string.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object} Parsed query string.\n * @api private\n */\nPrimus.prototype.querystring = qs.parse;\n/**\n * Transform a query string object back into string equiv.\n *\n * @param {Object} obj The query string object.\n * @returns {String}\n * @api private\n */\nPrimus.prototype.querystringify = qs.stringify;\n\n/**\n * Generates a connection URI.\n *\n * @param {String} protocol The protocol that should used to crate the URI.\n * @returns {String|options} The URL.\n * @api private\n */\nPrimus.prototype.uri = function uri(options) {\n  var url = this.url\n    , server = []\n    , qsa = false;\n\n  //\n  // Query strings are only allowed when we've received clearance for it.\n  //\n  if (options.query) qsa = true;\n\n  options = options || {};\n  options.protocol = 'protocol' in options\n    ? options.protocol\n    : 'http:';\n  options.query = url.query && qsa\n    ? url.query.slice(1)\n    : false;\n  options.secure = 'secure' in options\n    ? options.secure\n    : url.protocol === 'https:' || url.protocol === 'wss:';\n  options.auth = 'auth' in options\n    ? options.auth\n    : url.auth;\n  options.pathname = 'pathname' in options\n    ? options.pathname\n    : this.pathname;\n  options.port = 'port' in options\n    ? +options.port\n    : +url.port || (options.secure ? 443 : 80);\n\n  //\n  // We need to make sure that we create a unique connection URL every time to\n  // prevent back forward cache from becoming an issue. We're doing this by\n  // forcing an cache busting query string in to the URL.\n  //\n  var querystring = this.querystring(options.query || '');\n  querystring._primuscb = yeast();\n  options.query = this.querystringify(querystring);\n\n  //\n  // Allow transformation of the options before we construct a full URL from it.\n  //\n  this.emit('outgoing::url', options);\n\n  //\n  // Automatically suffix the protocol so we can supply `ws:` and `http:` and\n  // it gets transformed correctly.\n  //\n  server.push(options.secure ? options.protocol.replace(':', 's:') : options.protocol, '');\n\n  server.push(options.auth ? options.auth +'@'+ url.host : url.host);\n\n  //\n  // Pathnames are optional as some Transformers would just use the pathname\n  // directly.\n  //\n  if (options.pathname) server.push(options.pathname.slice(1));\n\n  //\n  // Optionally add a search query.\n  //\n  if (qsa) server[server.length - 1] += '?'+ options.query;\n  else delete options.query;\n\n  if (options.object) return options;\n  return server.join('/');\n};\n\n/**\n * Register a new message transformer. This allows you to easily manipulate incoming\n * and outgoing data which is particularity handy for plugins that want to send\n * meta data together with the messages.\n *\n * @param {String} type Incoming or outgoing\n * @param {Function} fn A new message transformer.\n * @returns {Primus}\n * @api public\n */\nPrimus.prototype.transform = function transform(type, fn) {\n  context(this, 'transform');\n\n  if (!(type in this.transformers)) {\n    return this.critical(new Error('Invalid transformer type'));\n  }\n\n  this.transformers[type].push(fn);\n  return this;\n};\n\n/**\n * A critical error has occurred, if we have an `error` listener, emit it there.\n * If not, throw it, so we get a stack trace + proper error message.\n *\n * @param {Error} err The critical error.\n * @returns {Primus}\n * @api private\n */\nPrimus.prototype.critical = function critical(err) {\n  if (this.emit('error', err)) return this;\n\n  throw err;\n};\n\n/**\n * Syntax sugar, adopt a Socket.IO like API.\n *\n * @param {String} url The URL we want to connect to.\n * @param {Object} options Connection options.\n * @returns {Primus}\n * @api public\n */\nPrimus.connect = function connect(url, options) {\n  return new Primus(url, options);\n};\n\n//\n// Expose the EventEmitter so it can be re-used by wrapping libraries we're also\n// exposing the Stream interface.\n//\nPrimus.EventEmitter = EventEmitter;\n\n//\n// These libraries are automatically inserted at the server-side using the\n// Primus#library method.\n//\nPrimus.prototype.client = null; // @import {primus::client};\nPrimus.prototype.authorization = null; // @import {primus::auth};\nPrimus.prototype.pathname = null; // @import {primus::pathname};\nPrimus.prototype.encoder = null; // @import {primus::encoder};\nPrimus.prototype.decoder = null; // @import {primus::decoder};\nPrimus.prototype.version = null; // @import {primus::version};\n\n//\n// Expose the library.\n//\nmodule.exports = Primus;\n"
        },
        {
          "name": "spark.js",
          "type": "blob",
          "size": 15.31640625,
          "content": "'use strict';\n\nvar ParserError = require('./errors').ParserError\n  , log = require('diagnostics')('primus:spark')\n  , parse = require('querystring').parse\n  , forwarded = require('forwarded-for')\n  , nanoid = require('nanoid').nanoid\n  , Ultron = require('ultron')\n  , fuse = require('fusing')\n  , u2028 = /\\u2028/g\n  , u2029 = /\\u2029/g;\n\n/**\n * The Spark is an indefinable, indescribable energy or soul of a transformer\n * which can be used to create new transformers. In our case, it's a simple\n * wrapping interface.\n *\n * @constructor\n * @param {Primus} primus Reference to the Primus server. (Set using .bind)\n * @param {Object} headers The request headers for this connection.\n * @param {Object} address The object that holds the remoteAddress and port.\n * @param {Object} query The query string of request.\n * @param {String} id An optional id of the socket, or we will generate one.\n * @param {Request} request The HTTP Request instance that initialised the spark.\n * @param {Mixed} socket Reference to the transformer socket.\n * @api public\n */\nfunction Spark(primus, headers, address, query, id, request, socket) {\n  this.fuse();\n\n  var writable = this.writable\n    , spark = this\n    , idgen = primus.options.idGenerator;\n\n  query = query || {};\n  id = idgen ? idgen() : (id || nanoid());\n  headers = headers || {};\n  address = address || {};\n  request = request || headers['primus::req::backup'];\n\n  writable('id', id);                   // Unique id for socket.\n  writable('primus', primus);           // References to Primus.\n  writable('remote', address);          // The remote address location.\n  writable('headers', headers);         // The request headers.\n  writable('request', request);         // Reference to an HTTP request.\n  writable('socket', socket);           // Reference to the transformer's socket\n  writable('writable', true);           // Silly stream compatibility.\n  writable('readable', true);           // Silly stream compatibility.\n  writable('queue', []);                // Data queue for data events.\n  writable('query', query);             // The query string.\n  writable('ultron', new Ultron(this)); // Our event listening cleanup.\n  writable('alive', true);              // Flag used to detect zombie sparks.\n\n  //\n  // Parse our query string.\n  //\n  if ('string' === typeof this.query) {\n    this.query = parse(this.query);\n  }\n\n  this.__initialise.forEach(function execute(initialise) {\n    initialise.call(spark);\n  });\n}\n\nfuse(Spark, require('stream'), { merge: false, mixin: false });\n\n//\n// Internal readyState's to prevent writes against close sockets.\n//\nSpark.OPENING = 1;    // Only here for primus.js readyState number compatibility.\nSpark.CLOSED  = 2;    // The connection is closed.\nSpark.OPEN    = 3;    // The connection is open.\n\n//\n// Make sure that we emit `readyState` change events when a new readyState is\n// checked. This way plugins can correctly act according to this.\n//\nSpark.readable('readyState', {\n  get: function get() {\n    return this.__readyState;\n  },\n  set: function set(readyState) {\n    if (this.__readyState === readyState) return readyState;\n\n    this.__readyState = readyState;\n    this.emit('readyStateChange');\n\n    return readyState;\n  }\n}, true);\n\nSpark.writable('__readyState', Spark.OPEN);\n\n//\n// Lazy parse interface for IP address information. As nobody is always\n// interested in this, we're going to defer parsing until it's actually needed.\n//\nSpark.get('address', function address() {\n  return this.request.forwarded || forwarded(this.remote, this.headers, this.primus.whitelist);\n});\n\n/**\n * Checks if the given event is an emitted event by Primus.\n *\n * @param {String} evt The event name.\n * @returns {Boolean}\n * @api public\n */\nSpark.readable('reserved', function reserved(evt) {\n  return (/^(incoming|outgoing)::/).test(evt)\n  || evt in reserved.events;\n});\n\n/**\n * The actual events that are used by the Spark.\n *\n * @type {Object}\n * @api public\n */\nSpark.prototype.reserved.events = {\n  readyStateChange: 1,\n  heartbeat: 1,\n  error: 1,\n  data: 1,\n  end: 1\n};\n\n/**\n * Allows for adding initialise listeners without people overriding our default\n * initializer. If they are feeling adventures and really want want to hack it\n * up, they can remove it from the __initialise array.\n *\n * @returns {Function} The last added initialise hook.\n * @api public\n */\nSpark.readable('initialise', {\n  get: function get() {\n    return this.__initialise[this.__initialise.length - 1];\n  },\n\n  set: function set(initialise) {\n    if ('function' === typeof initialise) this.__initialise.push(initialise);\n  }\n}, true);\n\n/**\n * Send a heartbeat to the client.\n *\n * Checks if any message has been received from the client before sending\n * another heartbeat. If not, we can assume it's dead (no response to our last\n * ping), so we should close.\n *\n * This is intentionally writable so it can be overwritten for custom heartbeat\n * policies.\n *\n * @returns {undefined}\n * @api public\n */\nSpark.writable('heartbeat', function heartbeat() {\n  var spark = this;\n  if (!spark.alive) {\n    //\n    // Set the `reconnect` option to `true` so we don't send a\n    // `primus::server::close` packet to an already broken connection.\n    //\n    spark.end(undefined, { reconnect: true });\n  } else {\n    const now = Date.now();\n\n    spark.alive = false;\n    spark.emit('outgoing::ping', now);\n    spark._write(`primus::ping::${now}`);\n  }\n});\n\n/**\n * Attach hooks and automatically announce a new connection.\n *\n * @type {Array}\n * @api private\n */\nSpark.readable('__initialise', [function initialise() {\n  var primus = this.primus\n    , ultron = this.ultron\n    , spark = this;\n\n  //\n  // Prevent double initialization of the spark. If we already have an\n  // `incoming::data` handler we assume that all other cases are handled as well.\n  //\n  if (this.listeners('incoming::data').length) {\n    return log('already has incoming::data listeners, bailing out');\n  }\n\n  //\n  // We've received new data from our client, decode and emit it.\n  //\n  ultron.on('incoming::data', function message(raw) {\n    primus.decoder.call(spark, raw, function decoding(err, data) {\n      //\n      // Do a \"save\" emit('error') when we fail to parse a message. We don't\n      // want to throw here as listening to errors should be optional.\n      //\n      if (err) {\n        log('failed to decode the incoming data for %s', spark.id);\n        return new ParserError('Failed to decode incoming data: '+ err.message, spark, err);\n      }\n\n      //\n      // Handle \"primus::\" prefixed protocol messages.\n      //\n      if (spark.protocol(data)) return;\n\n      spark.transforms(primus, spark, 'incoming', data, raw);\n    });\n  });\n\n  //\n  // We've received a pong event. This is fired upon receipt of a\n  // `pimus::pong::<timestamp>` message.\n  //\n  ultron.on('incoming::pong', function pong() {\n    spark.alive = true;\n    spark.emit('heartbeat');\n  });\n\n  //\n  // The client has disconnected.\n  //\n  ultron.on('incoming::end', function disconnect() {\n    //\n    // The socket is closed, sending data over it will throw an error.\n    //\n    log('transformer closed connection for %s', spark.id);\n    spark.end(undefined, { reconnect: true });\n  });\n\n  ultron.on('incoming::error', function error(err) {\n    //\n    // Ensure that the error we emit is always an Error instance. There are\n    // transformers that used to emit only strings. A string is not an Error.\n    //\n    if ('string' === typeof err) {\n      err = new Error(err);\n    }\n\n    if (spark.listeners('error').length) spark.emit('error', err);\n    spark.primus.emit('log', 'error', err);\n\n    log('transformer received error `%s` for %s', err.message, spark.id);\n    spark.end();\n  });\n\n  //\n  // End is triggered by both incoming and outgoing events.\n  //\n  ultron.on('end', function end() {\n    primus.emit('disconnection', spark);\n  });\n\n  //\n  // Announce a new connection. This allows the transformers to change or listen\n  // to events before we announce it.\n  //\n  process.nextTick(function tick() {\n    primus.asyncemit('connection', spark, function damn(err) {\n      if (!err) {\n        if (spark.queue) spark.queue.forEach(function each(packet) {\n          spark.emit('data', packet.data, packet.raw);\n        });\n\n        spark.queue = null;\n        return;\n      }\n\n      spark.emit('incoming::error', err);\n    });\n  });\n}]);\n\n/**\n * Execute the set of message transformers from Primus on the incoming or\n * outgoing message.\n * This function and it's content should be in sync with Primus#transforms in\n * primus.js.\n *\n * @param {Primus} primus Reference to the Primus instance with message transformers.\n * @param {Spark|Primus} connection Connection that receives or sends data.\n * @param {String} type The type of message, 'incoming' or 'outgoing'.\n * @param {Mixed} data The data to send or that has been received.\n * @param {String} raw The raw encoded data.\n * @returns {Spark}\n * @api public\n */\nSpark.readable('transforms', function transforms(primus, connection, type, data, raw) {\n  var packet = { data: data, raw: raw }\n    , fns = primus.transformers[type];\n\n  //\n  // Iterate in series over the message transformers so we can allow optional\n  // asynchronous execution of message transformers which could for example\n  // retrieve additional data from the server, do extra decoding or even\n  // message validation.\n  //\n  (function transform(index, done) {\n    var transformer = fns[index++];\n\n    if (!transformer) return done();\n\n    if (1 === transformer.length) {\n      if (false === transformer.call(connection, packet)) {\n        //\n        // When false is returned by an incoming transformer it means that's\n        // being handled by the transformer and we should not emit the `data`\n        // event.\n        //\n        return;\n      }\n\n      return transform(index, done);\n    }\n\n    transformer.call(connection, packet, function finished(err, arg) {\n      if (err) return connection.emit('error', err);\n      if (false === arg) return;\n\n      transform(index, done);\n    });\n  }(0, function done() {\n    //\n    // We always emit 2 arguments for the data event, the first argument is the\n    // parsed data and the second argument is the raw string that we received.\n    // This allows you, for example, to do some validation on the parsed data\n    // and then save the raw string in your database without the stringify\n    // overhead.\n    //\n    if ('incoming' === type) {\n      //\n      // This is pretty bad edge case, it's possible that the async version of\n      // the `connection` event listener takes so long that we cannot assign\n      // `data` handlers and we are already receiving data as the connection is\n      // already established. In this edge case we need to queue the data and\n      // pass it to the data event once we're listening.\n      //\n      if (connection.queue) return connection.queue.push(packet);\n      return connection.emit('data', packet.data, packet.raw);\n    }\n\n    connection._write(packet.data);\n  }));\n\n  return this;\n});\n\n/**\n * Really dead simple protocol parser. We simply assume that every message that\n * is prefixed with `primus::` could be used as some sort of protocol definition\n * for Primus.\n *\n * @param {String} msg The data.\n * @returns {Boolean} Is a protocol message.\n * @api private\n */\nSpark.readable('protocol', function protocol(msg) {\n  if (\n       'string' !== typeof msg\n    || msg.indexOf('primus::') !== 0\n  ) return false;\n\n  var last = msg.indexOf(':', 8)\n    , value = msg.slice(last + 2);\n\n  switch (msg.slice(8,  last)) {\n    case 'pong':\n      this.emit('incoming::pong', +value);\n      break;\n\n    case 'id':\n      this._write('primus::id::'+ this.id);\n      break;\n\n    //\n    // Unknown protocol, somebody is probably sending `primus::` prefixed\n    // messages.\n    //\n    default:\n      log('message `%s` was prefixed with primus:: but not supported', msg);\n      return false;\n  }\n\n  log('processed a primus protocol message `%s`', msg);\n  return true;\n});\n\n/**\n * Send a new message to a given spark.\n *\n * @param {Mixed} data The data that needs to be written.\n * @returns {Boolean} Always returns true.\n * @api public\n */\nSpark.readable('write', function write(data) {\n  var primus = this.primus;\n\n  //\n  // The connection is closed, return false.\n  //\n  if (Spark.CLOSED === this.readyState) {\n    log('attempted to write but readyState was already set to CLOSED for %s', this.id);\n    return false;\n  }\n\n  this.transforms(primus, this, 'outgoing', data);\n\n  return true;\n});\n\n/**\n * The actual message writer.\n *\n * @param {Mixed} data The message that needs to be written.\n * @returns {Boolean}\n * @api private\n */\nSpark.readable('_write', function _write(data) {\n  var primus = this.primus\n    , spark = this;\n\n  //\n  // The connection is closed, normally this would already be done in the\n  // `spark.write` method, but as `_write` is used internally, we should also\n  // add the same check here to prevent potential crashes by writing to a dead\n  // socket.\n  //\n  if (Spark.CLOSED === spark.readyState) {\n    log('attempted to _write but readyState was already set to CLOSED for %s', spark.id);\n    return false;\n  }\n\n  primus.encoder.call(spark, data, function encoded(err, packet) {\n    //\n    // Do a \"safe\" emit('error') when we fail to parse a message. We don't\n    // want to throw here as listening to errors should be optional.\n    //\n    if (err) return new ParserError('Failed to encode outgoing data: '+ err.message, spark, err);\n    if (!packet) return log('nothing to write, bailing out for %s', spark.id);\n\n    //\n    // Hack 1: \\u2028 and \\u2029 are allowed inside a JSON string, but JavaScript\n    // defines them as newline separators. Unescaped control characters are not\n    // allowed inside JSON strings, so this causes an error at parse time. We\n    // work around this issue by escaping these characters. This can cause\n    // errors with JSONP requests or if the string is just evaluated.\n    //\n    if ('string' === typeof packet) {\n      if (~packet.indexOf('\\u2028')) packet = packet.replace(u2028, '\\\\u2028');\n      if (~packet.indexOf('\\u2029')) packet = packet.replace(u2029, '\\\\u2029');\n    }\n\n    spark.emit('outgoing::data', packet);\n  });\n\n  return true;\n});\n\n/**\n * End the connection.\n *\n * Options:\n * - reconnect (boolean) Trigger client-side reconnect.\n *\n * @param {Mixed} data Optional closing data.\n * @param {Object} options End instructions.\n * @api public\n */\nSpark.readable('end', function end(data, options) {\n  if (Spark.CLOSED === this.readyState) return this;\n\n  options = options || {};\n  if (data !== undefined) this.write(data);\n\n  //\n  // If we want to trigger a reconnect do not send\n  // `primus::server::close`, otherwise bypass the .write method\n  // as this message should not be transformed.\n  //\n  if (!options.reconnect) this._write('primus::server::close');\n\n  //\n  // This seems redundant but there are cases where the above writes\n  // can trigger another `end` call. An example is with Engine.IO\n  // when calling `end` on the client and `end` on the spark right\n  // after. The `end` call on the spark comes before the `incoming::end`\n  // event and the result is an attempt of writing to a closed socket.\n  // When this happens Engine.IO closes the connection and without\n  // this check the following instructions could be executed twice.\n  //\n  if (Spark.CLOSED === this.readyState) return this;\n\n  log('emitting final events for spark %s', this.id);\n\n  this.readyState = Spark.CLOSED;\n  this.emit('outgoing::end');\n  this.emit('end');\n  this.ultron.destroy();\n  this.ultron = this.queue = null;\n\n  return this;\n});\n\n//\n// Expose the module.\n//\nmodule.exports = Spark;\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "transformer.js",
          "type": "blob",
          "size": 6.732421875,
          "content": "'use strict';\n\nvar log = require('diagnostics')('primus:transformer')\n  , middlewareError = require('./middleware/error')\n  , url = require('url').parse\n  , Ultron = require('ultron')\n  , fuse = require('fusing');\n\nfunction noop() {}\n\n/**\n * Transformer skeleton\n *\n * @constructor\n * @param {Primus} primus Reference to the Primus instance.\n * @api public\n */\nfunction Transformer(primus) {\n  this.fuse();\n\n  this.ultron = new Ultron(primus.server);  // Handles listeners with ease.\n  this.Spark = primus.Spark;                // Reference to the Spark constructor.\n  this.primus = primus;                     // Reference to the Primus instance.\n  this.service = null;                      // Stores the real-time service.\n\n  this.initialise();\n}\n\nfuse(Transformer, require('eventemitter3'));\n\n//\n// Simple logger shortcut.\n//\nObject.defineProperty(Transformer.prototype, 'logger', {\n  get: function logger() {\n    return {\n      error: this.primus.emits('log', 'error'), // Log error <line>.\n      warn:  this.primus.emits('log', 'warn'),  // Log warn <line>.\n      info:  this.primus.emits('log', 'info'),  // Log info <line>.\n      debug: this.primus.emits('log', 'debug'), // Log debug <line>.\n      log:   this.primus.emits('log', 'log'),   // Log log <line>.\n      plain: this.primus.emits('log', 'log')    // Log log <line>.\n    };\n  }\n});\n\n/**\n * Create the server and attach the appropriate event listeners.\n *\n * @api private\n */\nTransformer.readable('initialise', function initialise() {\n  if (this.server) this.server();\n\n  var server = this.primus.server\n    , transformer = this;\n\n  server.listeners('request').forEach(function each(fn) {\n    log('found existing request handlers on the HTTP server, moving Primus as first');\n    transformer.on('previous::request', fn, server);\n  });\n\n  server.listeners('upgrade').forEach(function each(fn) {\n    log('found existing upgrade handlers on the HTTP server, moving Primus as first');\n    transformer.on('previous::upgrade', fn, server);\n  });\n\n  //\n  // Remove the old listeners as we want to be the first request handler for all\n  // events.\n  //\n  server.removeAllListeners('request');\n  server.removeAllListeners('upgrade');\n\n  //\n  // Emit a close event.\n  //\n  this.ultron.on('close', function close() {\n    log('the HTTP server is closing');\n    transformer.emit('close');\n  });\n\n  //\n  // Start listening for incoming requests if we have a listener assigned to us.\n  //\n  if (this.listeners('request').length || this.listeners('previous::request').length) {\n    server.on('request', this.request.bind(this));\n  }\n\n  if (this.listeners('upgrade').length || this.listeners('previous::upgrade').length) {\n    server.on('upgrade', this.upgrade.bind(this));\n  }\n});\n\n/**\n * Iterate all the middleware layers that we're set on our Primus instance.\n *\n * @param {String} type Either `http` or `upgrade`\n * @param {Request} req HTTP request.\n * @param {Response} res HTTP response.\n * @param {Function} next Continuation callback.\n * @api private\n */\nTransformer.readable('forEach', function forEach(type, req, res, next) {\n  var transformer = this\n    , layers = transformer.primus.layers\n    , primus = transformer.primus;\n\n  req.query = req.uri.query || {};\n\n  //\n  // Add some silly HTTP properties for connect.js compatibility.\n  //\n  req.originalUrl = req.url;\n\n  if (!layers.length) {\n    next();\n    return transformer;\n  }\n\n  //\n  // Async or sync call the middleware layer.\n  //\n  (function iterate(index) {\n    var layer = layers[index++];\n\n    if (!layer) return next();\n    if (!layer.enabled || layer.fn[type] === false) return iterate(index);\n\n    if (layer.length === 2) {\n      log('executing middleware (%s) synchronously', layer.name);\n\n      if (layer.fn.call(primus, req, res)) return;\n      return iterate(index);\n    }\n\n    log('executing middleware (%s) asynchronously', layer.name);\n    layer.fn.call(primus, req, res, function done(err) {\n      if (err) return middlewareError(err, req, res);\n\n      iterate(index);\n    });\n  }(0));\n\n  return transformer;\n});\n\n/**\n * Start listening for incoming requests and check if we need to forward them to\n * the transformers.\n *\n * @param {Request} req HTTP request.\n * @param {Response} res HTTP response.\n * @api private\n */\nTransformer.readable('request', function request(req, res) {\n  if (!this.test(req)) return this.emit('previous::request', req, res);\n\n  req.headers['primus::req::backup'] = req;\n  res.once('end', function gc() {\n    delete req.headers['primus::req::backup'];\n  });\n\n  //\n  // I want to see you're face when you're looking at the lines of code above\n  // while you think, WTF what is this shit, you mad bro!? Let me take a moment\n  // to explain this mad and sadness.\n  //\n  // There are some real-time transformers that do not give us access to the\n  // HTTP request that initiated their `socket` connection. They only give us\n  // access to the information that they think is useful, we're greedy, we want\n  // everything and let developers decide what they want to use instead and\n  // therefor want to expose this HTTP request on our `spark` object.\n  //\n  // The reason it's added to the headers is because it's currently the only\n  // field that is accessible through all transformers.\n  //\n\n  log('handling HTTP request for url: %s', req.url);\n  this.forEach('http', req, res, this.emits('request', req, res));\n});\n\n/**\n * Starting listening for incoming upgrade requests and check if we need to\n * forward them to the transformers.\n *\n * @param {Request} req HTTP request.\n * @param {Socket} socket Socket.\n * @param {Buffer} head Buffered data.\n * @api private\n */\nTransformer.readable('upgrade', function upgrade(req, socket, head) {\n  if (!this.test(req)) return this.emit('previous::upgrade', req, socket, head);\n\n  //\n  // See Transformer#request for an explanation of this madness.\n  //\n  req.headers['primus::req::backup'] = req;\n  socket.once('end', function gc() {\n    delete req.headers['primus::req::backup'];\n  });\n\n  log('handling HTTP upgrade for url: %s', req.url);\n\n  //\n  // Add a listener for the `'error'` event before running middleware as there\n  // isn't a default one in Node.js >= 10. The socket is destroyed when an error\n  // occurs so there is no need to do anything.\n  //\n  socket.on('error', noop);\n\n  this.forEach('upgrade', req, socket, () => {\n    socket.removeListener('error', noop);\n    this.emit('upgrade', req, socket, head);\n  });\n});\n\n/**\n * Check if we should accept this request.\n *\n * @param {Request} req HTTP Request.\n * @returns {Boolean} Do we need to accept this request.\n * @api private\n */\nTransformer.readable('test', function test(req) {\n  req.uri = url(req.url, true);\n\n  var pathname = req.uri.pathname || '/'\n    , route = this.primus.pathname;\n\n  return pathname.slice(0, route.length) === route;\n});\n\n//\n// Expose the transformer's skeleton.\n//\nmodule.exports = Transformer;\n"
        },
        {
          "name": "transformers.json",
          "type": "blob",
          "size": 0.435546875,
          "content": "{\n  \"websockets\": {\n    \"server\": \"ws\",\n    \"client\": \"ws\"\n  },\n  \"engine.io\": {\n    \"server\": \"engine.io\",\n    \"client\": \"engine.io-client\"\n  },\n  \"browserchannel\": {\n    \"server\": \"browserchannel\",\n    \"client\": \"browserchannel\"\n  },\n  \"sockjs\": {\n    \"server\": \"sockjs\",\n    \"client\": \"sockjs-client\"\n  },\n  \"faye\": {\n    \"server\": \"faye-websocket\",\n    \"client\": \"faye-websocket\"\n  },\n  \"uws\": {\n    \"server\": \"uws\",\n    \"client\": \"ws\"\n  }\n}\n"
        },
        {
          "name": "transformers",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}