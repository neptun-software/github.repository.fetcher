{
  "metadata": {
    "timestamp": 1736561852435,
    "page": 519,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sindresorhus/file-type",
      "stars": 3768,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1708984375,
          "content": "root = true\n\n[*]\nindent_style = tab\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.yml]\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0185546875,
          "content": "* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0224609375,
          "content": "node_modules\nyarn.lock\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": "contributing.md",
          "type": "blob",
          "size": 0.1220703125,
          "content": "# Contributing\n\nIf you're adding support for a new file type, [please follow these steps](.github/pull_request_template.md).\n"
        },
        {
          "name": "core.d.ts",
          "type": "blob",
          "size": 8.853515625,
          "content": "/**\nTypings for primary entry point, Node.js specific typings can be found in index.d.ts\n*/\n\nimport type {ReadableStream as WebReadableStream} from 'node:stream/web';\nimport type {ITokenizer, AnyWebByteStream} from 'strtok3';\n\n/**\nEither the Node.js ReadableStream or the `lib.dom.d.ts` ReadableStream.\nRelated issue: https://github.com/DefinitelyTyped/DefinitelyTyped/pull/60377\n*/\nexport type AnyWebReadableStream<G> = WebReadableStream<G> | ReadableStream<G>;\n\nexport type FileTypeResult = {\n\t/**\n\tOne of the supported [file types](https://github.com/sindresorhus/file-type#supported-file-types).\n\t*/\n\treadonly ext: string;\n\n\t/**\n\tThe detected [MIME type](https://en.wikipedia.org/wiki/Internet_media_type).\n\t*/\n\treadonly mime: string;\n};\n\n/**\nDetect the file type of a `Uint8Array`, or `ArrayBuffer`.\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n\nIf file access is available, it is recommended to use `.fromFile()` instead.\n\n@param buffer - An Uint8Array or ArrayBuffer representing file data. It works best if the buffer contains the entire file. It may work with a smaller portion as well.\n@returns The detected file type, or `undefined` when there is no match.\n*/\nexport function fileTypeFromBuffer(buffer: Uint8Array | ArrayBuffer): Promise<FileTypeResult | undefined>;\n\n/**\nDetect the file type of a [web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream).\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n\n@param stream - A [web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) streaming a file to examine.\n@returns A `Promise` for an object with the detected file type, or `undefined` when there is no match.\n*/\nexport function fileTypeFromStream(stream: AnyWebByteStream): Promise<FileTypeResult | undefined>;\n\n/**\nDetect the file type from an [`ITokenizer`](https://github.com/Borewit/strtok3#tokenizer) source.\n\nThis method is used internally, but can also be used for a special \"tokenizer\" reader.\n\nA tokenizer propagates the internal read functions, allowing alternative transport mechanisms, to access files, to be implemented and used.\n\n@param tokenizer - File source implementing the tokenizer interface.\n@returns The detected file type, or `undefined` when there is no match.\n\nAn example is [`@tokenizer/http`](https://github.com/Borewit/tokenizer-http), which requests data using [HTTP-range-requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests). A difference with a conventional stream and the [*tokenizer*](https://github.com/Borewit/strtok3#tokenizer), is that it is able to *ignore* (seek, fast-forward) in the stream. For example, you may only need and read the first 6 bytes, and the last 128 bytes, which may be an advantage in case reading the entire file would take longer.\n\n@example\n```\nimport {makeTokenizer} from '@tokenizer/http';\nimport {fileTypeFromTokenizer} from 'file-type';\n\nconst audioTrackUrl = 'https://test-audio.netlify.com/Various%20Artists%20-%202009%20-%20netBloc%20Vol%2024_%20tiuqottigeloot%20%5BMP3-V2%5D/01%20-%20Diablo%20Swing%20Orchestra%20-%20Heroines.mp3';\n\nconst httpTokenizer = await makeTokenizer(audioTrackUrl);\nconst fileType = await fileTypeFromTokenizer(httpTokenizer);\n\nconsole.log(fileType);\n//=> {ext: 'mp3', mime: 'audio/mpeg'}\n```\n*/\nexport function fileTypeFromTokenizer(tokenizer: ITokenizer): Promise<FileTypeResult | undefined>;\n\n/**\nSupported file extensions.\n*/\nexport const supportedExtensions: ReadonlySet<string>;\n\n/**\nSupported MIME types.\n*/\nexport const supportedMimeTypes: ReadonlySet<string>;\n\nexport type StreamOptions = {\n\t/**\n\tThe default sample size in bytes.\n\n\t@default 4100\n\t*/\n\treadonly sampleSize?: number;\n};\n\n/**\nDetect the file type of a [`Blob`](https://nodejs.org/api/buffer.html#class-blob) or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).\n\n@param blob - The [`Blob`](https://nodejs.org/api/buffer.html#class-blob) used for file detection.\n@returns The detected file type, or `undefined` when there is no match.\n\n@example\n```\nimport {fileTypeFromBlob} from 'file-type';\n\nconst blob = new Blob(['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>'], {\n\ttype: 'text/plain',\n\tendings: 'native'\n});\n\nconsole.log(await fileTypeFromBlob(blob));\n//=> {ext: 'txt', mime: 'text/plain'}\n```\n*/\nexport declare function fileTypeFromBlob(blob: Blob): Promise<FileTypeResult | undefined>;\n\n/**\nA custom file type detector.\n\nDetectors can be added via the constructor options or by directly modifying `FileTypeParser#detectors`.\n\nDetectors provided through the constructor options are executed before the default detectors.\n\nCustom detectors allow for:\n- Introducing new `FileTypeResult` entries.\n- Modifying the detection behavior of existing `FileTypeResult` types.\n\n### Detector execution flow\n\nIf a detector returns `undefined`, the following rules apply:\n\n1. **No Tokenizer Interaction**: If the detector does not modify the tokenizer's position, the next detector in the sequence is executed.\n2. **Tokenizer Interaction**: If the detector modifies the tokenizer's position (`tokenizer.position` is advanced), no further detectors are executed. In this case, the file type remains `undefined`, as subsequent detectors cannot evaluate the content. This is an exceptional scenario, as it prevents any other detectors from determining the file type.\n\n### Example usage\n\nBelow is an example of a custom detector array. This can be passed to the `FileTypeParser` via the `fileTypeOptions` argument.\n\n```\nimport {FileTypeParser} from 'file-type';\n\nconst customDetectors = [\n\tasync tokenizer => {\n\t\tconst unicornHeader = [85, 78, 73, 67, 79, 82, 78]; // \"UNICORN\" in ASCII decimal\n\n\t\tconst buffer = new Uint8Array(unicornHeader.length);\n\t\tawait tokenizer.peekBuffer(buffer, {length: unicornHeader.length, mayBeLess: true});\n\t\tif (unicornHeader.every((value, index) => value === buffer[index])) {\n\t\t\treturn {ext: 'unicorn', mime: 'application/unicorn'};\n\t\t}\n\n\t\treturn undefined;\n\t},\n];\n\nconst buffer = new Uint8Array([85, 78, 73, 67, 79, 82, 78]);\nconst parser = new FileTypeParser({customDetectors});\nconst fileType = await parser.fromBuffer(buffer);\nconsole.log(fileType); // {ext: 'unicorn', mime: 'application/unicorn'}\n```\n\n@param tokenizer - The [tokenizer](https://github.com/Borewit/strtok3#tokenizer) used to read file content.\n@param fileType - The file type detected by standard or previous custom detectors, or `undefined` if no match is found.\n@returns The detected file type, or `undefined` if no match is found.\n*/\nexport type Detector = {\n\tid: string;\n\tdetect: (tokenizer: ITokenizer, fileType?: FileTypeResult) => Promise<FileTypeResult | undefined>;\n};\n\nexport type FileTypeOptions = {\n\tcustomDetectors?: Iterable<Detector>;\n};\n\nexport declare class TokenizerPositionError extends Error {\n\tconstructor(message?: string);\n}\n\nexport type AnyWebReadableByteStreamWithFileType = AnyWebReadableStream<Uint8Array> & {\n\treadonly fileType?: FileTypeResult;\n};\n\n/**\nReturns a `Promise` which resolves to the original readable stream argument, but with an added `fileType` property, which is an object like the one returned from `fileTypeFromFile()`.\n\nThis method can be handy to put in a stream pipeline, but it comes with a price. Internally `stream()` builds up a buffer of `sampleSize` bytes, used as a sample, to determine the file type. The sample size impacts the file detection resolution. A smaller sample size will result in lower probability of the best file type detection.\n*/\nexport function fileTypeStream(webStream: AnyWebReadableStream<Uint8Array>, options?: StreamOptions): Promise<AnyWebReadableByteStreamWithFileType>;\n\nexport declare class FileTypeParser {\n\t/**\n\tFile type detectors.\n\n\tInitialized with a single entry holding the built-in detector function.\n\t*/\n\tdetectors: Detector[];\n\n\tconstructor(options?: {customDetectors?: Iterable<Detector>; signal?: AbortSignal});\n\n\t/**\n\tWorks the same way as {@link fileTypeFromBuffer}, additionally taking into account custom detectors (if any were provided to the constructor).\n\t*/\n\tfromBuffer(buffer: Uint8Array | ArrayBuffer): Promise<FileTypeResult | undefined>;\n\n\t/**\n\tWorks the same way as {@link fileTypeFromTokenizer}, additionally taking into account custom detectors (if any were provided to the constructor).\n\t*/\n\tfromTokenizer(tokenizer: ITokenizer): Promise<FileTypeResult | undefined>;\n\n\t/**\n\tWorks the same way as {@link fileTypeFromBlob}, additionally taking into account custom detectors (if any were provided to the constructor).\n\t*/\n\tfromBlob(blob: Blob): Promise<FileTypeResult | undefined>;\n\n\t/**\n\tWorks the same way as {@link fileTypeStream}, additionally taking into account custom detectors (if any were provided to the constructor).\n\t*/\n\ttoDetectionStream(webStream: AnyWebReadableStream<Uint8Array>, options?: StreamOptions): Promise<AnyWebReadableByteStreamWithFileType>;\n}\n"
        },
        {
          "name": "core.js",
          "type": "blob",
          "size": 42.0263671875,
          "content": "/**\nPrimary entry point, Node.js specific entry point is index.js\n*/\n\nimport * as Token from 'token-types';\nimport * as strtok3 from 'strtok3/core';\nimport {ZipHandler} from '@tokenizer/inflate';\nimport {includes, getUintBE} from 'uint8array-extras';\nimport {\n\tstringToBytes,\n\ttarHeaderChecksumMatches,\n\tuint32SyncSafeToken,\n} from './util.js';\nimport {extensions, mimeTypes} from './supported.js';\n\nexport const reasonableDetectionSizeInBytes = 4100; // A fair amount of file-types are detectable within this range.\n\nexport async function fileTypeFromStream(stream) {\n\treturn new FileTypeParser().fromStream(stream);\n}\n\nexport async function fileTypeFromBuffer(input) {\n\treturn new FileTypeParser().fromBuffer(input);\n}\n\nexport async function fileTypeFromBlob(blob) {\n\treturn new FileTypeParser().fromBlob(blob);\n}\n\nfunction getFileTypeFromMimeType(mimeType) {\n\tswitch (mimeType) {\n\t\tcase 'application/epub+zip':\n\t\t\treturn {\n\t\t\t\text: 'epub',\n\t\t\t\tmime: 'application/epub+zip',\n\t\t\t};\n\t\tcase 'application/vnd.oasis.opendocument.text':\n\t\t\treturn {\n\t\t\t\text: 'odt',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.text',\n\t\t\t};\n\t\tcase 'application/vnd.oasis.opendocument.text-template':\n\t\t\treturn {\n\t\t\t\text: 'ott',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.text-template',\n\t\t\t};\n\t\tcase 'application/vnd.oasis.opendocument.spreadsheet':\n\t\t\treturn {\n\t\t\t\text: 'ods',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.spreadsheet',\n\t\t\t};\n\t\tcase 'application/vnd.oasis.opendocument.spreadsheet-template':\n\t\t\treturn {\n\t\t\t\text: 'ots',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.spreadsheet-template',\n\t\t\t};\n\t\tcase 'application/vnd.oasis.opendocument.presentation':\n\t\t\treturn {\n\t\t\t\text: 'odp',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.presentation',\n\t\t\t};\n\t\tcase 'application/vnd.oasis.opendocument.presentation-template':\n\t\t\treturn {\n\t\t\t\text: 'otp',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.presentation-template',\n\t\t\t};\n\t\tcase 'application/vnd.oasis.opendocument.graphics':\n\t\t\treturn {\n\t\t\t\text: 'odg',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.graphics',\n\t\t\t};\n\t\tcase 'application/vnd.oasis.opendocument.graphics-template':\n\t\t\treturn {\n\t\t\t\text: 'otg',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.graphics-template',\n\t\t\t};\n\t\tcase 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':\n\t\t\treturn {\n\t\t\t\text: 'xlsx',\n\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\t\t\t};\n\t\tcase 'application/vnd.ms-excel.sheet.macroEnabled':\n\t\t\treturn {\n\t\t\t\text: 'xlsm',\n\t\t\t\tmime: 'application/vnd.ms-excel.sheet.macroEnabled.12',\n\t\t\t};\n\t\tcase 'application/vnd.openxmlformats-officedocument.spreadsheetml.template':\n\t\t\treturn {\n\t\t\t\text: 'xltx',\n\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n\t\t\t};\n\t\tcase 'application/vnd.ms-excel.template.macroEnabled':\n\t\t\treturn {\n\t\t\t\text: 'xltm',\n\t\t\t\tmime: 'application/vnd.ms-excel.template.macroenabled.12',\n\t\t\t};\n\t\tcase 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':\n\t\t\treturn {\n\t\t\t\text: 'docx',\n\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\t\t\t};\n\t\tcase 'application/vnd.ms-word.document.macroEnabled':\n\t\t\treturn {\n\t\t\t\text: 'docm',\n\t\t\t\tmime: 'application/vnd.ms-word.document.macroEnabled.12',\n\t\t\t};\n\t\tcase 'application/vnd.openxmlformats-officedocument.wordprocessingml.template':\n\t\t\treturn {\n\t\t\t\text: 'dotx',\n\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n\t\t\t};\n\t\tcase 'application/vnd.ms-word.template.macroEnabledTemplate':\n\t\t\treturn {\n\t\t\t\text: 'dotm',\n\t\t\t\tmime: 'application/vnd.ms-word.template.macroEnabled.12',\n\t\t\t};\n\t\tcase 'application/vnd.openxmlformats-officedocument.presentationml.template':\n\t\t\treturn {\n\t\t\t\text: 'potx',\n\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.presentationml.template',\n\t\t\t};\n\t\tcase 'application/vnd.ms-powerpoint.template.macroEnabled':\n\t\t\treturn {\n\t\t\t\text: 'potm',\n\t\t\t\tmime: 'application/vnd.ms-powerpoint.template.macroEnabled.12',\n\t\t\t};\n\t\tcase 'application/vnd.openxmlformats-officedocument.presentationml.presentation':\n\t\t\treturn {\n\t\t\t\text: 'pptx',\n\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n\t\t\t};\n\t\tcase 'application/vnd.ms-powerpoint.presentation.macroEnabled':\n\t\t\treturn {\n\t\t\t\text: 'pptm',\n\t\t\t\tmime: 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',\n\t\t\t};\n\t\tcase 'application/vnd.ms-visio.drawing':\n\t\t\treturn {\n\t\t\t\text: 'vsdx',\n\t\t\t\tmime: 'application/vnd.visio',\n\t\t\t};\n\t\tcase 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml':\n\t\t\treturn {\n\t\t\t\text: '3mf',\n\t\t\t\tmime: 'model/3mf',\n\t\t\t};\n\t\tdefault:\n\t}\n}\n\nfunction _check(buffer, headers, options) {\n\toptions = {\n\t\toffset: 0,\n\t\t...options,\n\t};\n\n\tfor (const [index, header] of headers.entries()) {\n\t\t// If a bitmask is set\n\t\tif (options.mask) {\n\t\t\t// If header doesn't equal `buf` with bits masked off\n\t\t\tif (header !== (options.mask[index] & buffer[index + options.offset])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (header !== buffer[index + options.offset]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport async function fileTypeFromTokenizer(tokenizer) {\n\treturn new FileTypeParser().fromTokenizer(tokenizer);\n}\n\nexport async function fileTypeStream(webStream, options) {\n\treturn new FileTypeParser(options).toDetectionStream(webStream, options);\n}\n\nexport class FileTypeParser {\n\tconstructor(options) {\n\t\tthis.detectors = [...(options?.customDetectors ?? []),\n\t\t\t{id: 'core', detect: this.detectConfident},\n\t\t\t{id: 'core.imprecise', detect: this.detectImprecise}];\n\t\tthis.tokenizerOptions = {\n\t\t\tabortSignal: options?.signal,\n\t\t};\n\t}\n\n\tasync fromTokenizer(tokenizer) {\n\t\tconst initialPosition = tokenizer.position;\n\n\t\t// Iterate through all file-type detectors\n\t\tfor (const detector of this.detectors) {\n\t\t\tconst fileType = await detector.detect(tokenizer);\n\t\t\tif (fileType) {\n\t\t\t\treturn fileType;\n\t\t\t}\n\n\t\t\tif (initialPosition !== tokenizer.position) {\n\t\t\t\treturn undefined; // Cannot proceed scanning of the tokenizer is at an arbitrary position\n\t\t\t}\n\t\t}\n\t}\n\n\tasync fromBuffer(input) {\n\t\tif (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {\n\t\t\tthrow new TypeError(`Expected the \\`input\\` argument to be of type \\`Uint8Array\\` or \\`ArrayBuffer\\`, got \\`${typeof input}\\``);\n\t\t}\n\n\t\tconst buffer = input instanceof Uint8Array ? input : new Uint8Array(input);\n\n\t\tif (!(buffer?.length > 1)) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.fromTokenizer(strtok3.fromBuffer(buffer, this.tokenizerOptions));\n\t}\n\n\tasync fromBlob(blob) {\n\t\treturn this.fromStream(blob.stream());\n\t}\n\n\tasync fromStream(stream) {\n\t\tconst tokenizer = await strtok3.fromWebStream(stream, this.tokenizerOptions);\n\t\ttry {\n\t\t\treturn await this.fromTokenizer(tokenizer);\n\t\t} finally {\n\t\t\tawait tokenizer.close();\n\t\t}\n\t}\n\n\tasync toDetectionStream(stream, options) {\n\t\tconst {sampleSize = reasonableDetectionSizeInBytes} = options;\n\t\tlet detectedFileType;\n\t\tlet firstChunk;\n\n\t\tconst reader = stream.getReader({mode: 'byob'});\n\t\ttry {\n\t\t\t// Read the first chunk from the stream\n\t\t\tconst {value: chunk, done} = await reader.read(new Uint8Array(sampleSize));\n\t\t\tfirstChunk = chunk;\n\t\t\tif (!done && chunk) {\n\t\t\t\ttry {\n\t\t\t\t\t// Attempt to detect the file type from the chunk\n\t\t\t\t\tdetectedFileType = await this.fromBuffer(chunk.slice(0, sampleSize));\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (!(error instanceof strtok3.EndOfStreamError)) {\n\t\t\t\t\t\tthrow error; // Re-throw non-EndOfStreamError\n\t\t\t\t\t}\n\n\t\t\t\t\tdetectedFileType = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfirstChunk = chunk;\n\t\t} finally {\n\t\t\treader.releaseLock(); // Ensure the reader is released\n\t\t}\n\n\t\t// Create a new ReadableStream to manage locking issues\n\t\tconst transformStream = new TransformStream({\n\t\t\tasync start(controller) {\n\t\t\t\tcontroller.enqueue(firstChunk); // Enqueue the initial chunk\n\t\t\t},\n\t\t\ttransform(chunk, controller) {\n\t\t\t\t// Pass through the chunks without modification\n\t\t\t\tcontroller.enqueue(chunk);\n\t\t\t},\n\t\t});\n\n\t\tconst newStream = stream.pipeThrough(transformStream);\n\t\tnewStream.fileType = detectedFileType;\n\n\t\treturn newStream;\n\t}\n\n\tcheck(header, options) {\n\t\treturn _check(this.buffer, header, options);\n\t}\n\n\tcheckString(header, options) {\n\t\treturn this.check(stringToBytes(header), options);\n\t}\n\n\t// Detections with a high degree of certainty in identifying the correct file type\n\tdetectConfident = async tokenizer => {\n\t\tthis.buffer = new Uint8Array(reasonableDetectionSizeInBytes);\n\n\t\t// Keep reading until EOF if the file size is unknown.\n\t\tif (tokenizer.fileInfo.size === undefined) {\n\t\t\ttokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;\n\t\t}\n\n\t\tthis.tokenizer = tokenizer;\n\n\t\tawait tokenizer.peekBuffer(this.buffer, {length: 12, mayBeLess: true});\n\n\t\t// -- 2-byte signatures --\n\n\t\tif (this.check([0x42, 0x4D])) {\n\t\t\treturn {\n\t\t\t\text: 'bmp',\n\t\t\t\tmime: 'image/bmp',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x0B, 0x77])) {\n\t\t\treturn {\n\t\t\t\text: 'ac3',\n\t\t\t\tmime: 'audio/vnd.dolby.dd-raw',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x78, 0x01])) {\n\t\t\treturn {\n\t\t\t\text: 'dmg',\n\t\t\t\tmime: 'application/x-apple-diskimage',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x4D, 0x5A])) {\n\t\t\treturn {\n\t\t\t\text: 'exe',\n\t\t\t\tmime: 'application/x-msdownload',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x25, 0x21])) {\n\t\t\tawait tokenizer.peekBuffer(this.buffer, {length: 24, mayBeLess: true});\n\n\t\t\tif (\n\t\t\t\tthis.checkString('PS-Adobe-', {offset: 2})\n\t\t\t\t&& this.checkString(' EPSF-', {offset: 14})\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'eps',\n\t\t\t\t\tmime: 'application/eps',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\text: 'ps',\n\t\t\t\tmime: 'application/postscript',\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.check([0x1F, 0xA0])\n\t\t\t|| this.check([0x1F, 0x9D])\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'Z',\n\t\t\t\tmime: 'application/x-compress',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xC7, 0x71])) {\n\t\t\treturn {\n\t\t\t\text: 'cpio',\n\t\t\t\tmime: 'application/x-cpio',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x60, 0xEA])) {\n\t\t\treturn {\n\t\t\t\text: 'arj',\n\t\t\t\tmime: 'application/x-arj',\n\t\t\t};\n\t\t}\n\n\t\t// -- 3-byte signatures --\n\n\t\tif (this.check([0xEF, 0xBB, 0xBF])) { // UTF-8-BOM\n\t\t\t// Strip off UTF-8-BOM\n\t\t\tthis.tokenizer.ignore(3);\n\t\t\treturn this.detectConfident(tokenizer);\n\t\t}\n\n\t\tif (this.check([0x47, 0x49, 0x46])) {\n\t\t\treturn {\n\t\t\t\text: 'gif',\n\t\t\t\tmime: 'image/gif',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x49, 0x49, 0xBC])) {\n\t\t\treturn {\n\t\t\t\text: 'jxr',\n\t\t\t\tmime: 'image/vnd.ms-photo',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x1F, 0x8B, 0x8])) {\n\t\t\treturn {\n\t\t\t\text: 'gz',\n\t\t\t\tmime: 'application/gzip',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x42, 0x5A, 0x68])) {\n\t\t\treturn {\n\t\t\t\text: 'bz2',\n\t\t\t\tmime: 'application/x-bzip2',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('ID3')) {\n\t\t\tawait tokenizer.ignore(6); // Skip ID3 header until the header size\n\t\t\tconst id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);\n\t\t\tif (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {\n\t\t\t\t// Guess file type based on ID3 header for backward compatibility\n\t\t\t\treturn {\n\t\t\t\t\text: 'mp3',\n\t\t\t\t\tmime: 'audio/mpeg',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tawait tokenizer.ignore(id3HeaderLength);\n\t\t\treturn this.fromTokenizer(tokenizer); // Skip ID3 header, recursion\n\t\t}\n\n\t\t// Musepack, SV7\n\t\tif (this.checkString('MP+')) {\n\t\t\treturn {\n\t\t\t\text: 'mpc',\n\t\t\t\tmime: 'audio/x-musepack',\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\t(this.buffer[0] === 0x43 || this.buffer[0] === 0x46)\n\t\t\t&& this.check([0x57, 0x53], {offset: 1})\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'swf',\n\t\t\t\tmime: 'application/x-shockwave-flash',\n\t\t\t};\n\t\t}\n\n\t\t// -- 4-byte signatures --\n\n\t\t// Requires a sample size of 4 bytes\n\t\tif (this.check([0xFF, 0xD8, 0xFF])) {\n\t\t\tif (this.check([0xF7], {offset: 3})) { // JPG7/SOF55, indicating a ISO/IEC 14495 / JPEG-LS file\n\t\t\t\treturn {\n\t\t\t\t\text: 'jls',\n\t\t\t\t\tmime: 'image/jls',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\text: 'jpg',\n\t\t\t\tmime: 'image/jpeg',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x4F, 0x62, 0x6A, 0x01])) {\n\t\t\treturn {\n\t\t\t\text: 'avro',\n\t\t\t\tmime: 'application/avro',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('FLIF')) {\n\t\t\treturn {\n\t\t\t\text: 'flif',\n\t\t\t\tmime: 'image/flif',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('8BPS')) {\n\t\t\treturn {\n\t\t\t\text: 'psd',\n\t\t\t\tmime: 'image/vnd.adobe.photoshop',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('WEBP', {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'webp',\n\t\t\t\tmime: 'image/webp',\n\t\t\t};\n\t\t}\n\n\t\t// Musepack, SV8\n\t\tif (this.checkString('MPCK')) {\n\t\t\treturn {\n\t\t\t\text: 'mpc',\n\t\t\t\tmime: 'audio/x-musepack',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('FORM')) {\n\t\t\treturn {\n\t\t\t\text: 'aif',\n\t\t\t\tmime: 'audio/aiff',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('icns', {offset: 0})) {\n\t\t\treturn {\n\t\t\t\text: 'icns',\n\t\t\t\tmime: 'image/icns',\n\t\t\t};\n\t\t}\n\n\t\t// Zip-based file formats\n\t\t// Need to be before the `zip` check\n\t\tif (this.check([0x50, 0x4B, 0x3, 0x4])) { // Local file header signature\n\t\t\tlet fileType;\n\t\t\tawait new ZipHandler(tokenizer).unzip(zipHeader => {\n\t\t\t\tswitch (zipHeader.filename) {\n\t\t\t\t\tcase 'META-INF/mozilla.rsa':\n\t\t\t\t\t\tfileType = {\n\t\t\t\t\t\t\text: 'xpi',\n\t\t\t\t\t\t\tmime: 'application/x-xpinstall',\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstop: true,\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'META-INF/MANIFEST.MF':\n\t\t\t\t\t\tfileType = {\n\t\t\t\t\t\t\text: 'jar',\n\t\t\t\t\t\t\tmime: 'application/java-archive',\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstop: true,\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'mimetype':\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tasync handler(fileData) {\n\t\t\t\t\t\t\t\t// Use TextDecoder to decode the UTF-8 encoded data\n\t\t\t\t\t\t\t\tconst mimeType = new TextDecoder('utf-8').decode(fileData).trim();\n\t\t\t\t\t\t\t\tfileType = getFileTypeFromMimeType(mimeType);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstop: true,\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase '[Content_Types].xml':\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tasync handler(fileData) {\n\t\t\t\t\t\t\t\t// Use TextDecoder to decode the UTF-8 encoded data\n\t\t\t\t\t\t\t\tlet xmlContent = new TextDecoder('utf-8').decode(fileData);\n\t\t\t\t\t\t\t\tconst endPos = xmlContent.indexOf('.main+xml\"');\n\t\t\t\t\t\t\t\tif (endPos === -1) {\n\t\t\t\t\t\t\t\t\tconst mimeType = 'application/vnd.ms-package.3dmanufacturing-3dmodel+xml';\n\t\t\t\t\t\t\t\t\tif (xmlContent.includes(`ContentType=\"${mimeType}\"`)) {\n\t\t\t\t\t\t\t\t\t\tfileType = getFileTypeFromMimeType(mimeType);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\txmlContent = xmlContent.slice(0, Math.max(0, endPos));\n\t\t\t\t\t\t\t\t\tconst firstPos = xmlContent.lastIndexOf('\"');\n\t\t\t\t\t\t\t\t\tconst mimeType = xmlContent.slice(Math.max(0, firstPos + 1));\n\t\t\t\t\t\t\t\t\tfileType = getFileTypeFromMimeType(mimeType);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstop: true,\n\t\t\t\t\t\t};\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (/classes\\d*\\.dex/.test(zipHeader.filename)) {\n\t\t\t\t\t\t\tfileType = {\n\t\t\t\t\t\t\t\text: 'apk',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.android.package-archive',\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\treturn {stop: true};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {};\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn fileType ?? {\n\t\t\t\text: 'zip',\n\t\t\t\tmime: 'application/zip',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('OggS')) {\n\t\t\t// This is an OGG container\n\t\t\tawait tokenizer.ignore(28);\n\t\t\tconst type = new Uint8Array(8);\n\t\t\tawait tokenizer.readBuffer(type);\n\n\t\t\t// Needs to be before `ogg` check\n\t\t\tif (_check(type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'opus',\n\t\t\t\t\tmime: 'audio/ogg; codecs=opus',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If ' theora' in header.\n\t\t\tif (_check(type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'ogv',\n\t\t\t\t\tmime: 'video/ogg',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If '\\x01video' in header.\n\t\t\tif (_check(type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'ogm',\n\t\t\t\t\tmime: 'video/ogg',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If ' FLAC' in header  https://xiph.org/flac/faq.html\n\t\t\tif (_check(type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'oga',\n\t\t\t\t\tmime: 'audio/ogg',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex\n\t\t\tif (_check(type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'spx',\n\t\t\t\t\tmime: 'audio/ogg',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If '\\x01vorbis' in header\n\t\t\tif (_check(type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'ogg',\n\t\t\t\t\tmime: 'audio/ogg',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Default OGG container https://www.iana.org/assignments/media-types/application/ogg\n\t\t\treturn {\n\t\t\t\text: 'ogx',\n\t\t\t\tmime: 'application/ogg',\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.check([0x50, 0x4B])\n\t\t\t&& (this.buffer[2] === 0x3 || this.buffer[2] === 0x5 || this.buffer[2] === 0x7)\n\t\t\t&& (this.buffer[3] === 0x4 || this.buffer[3] === 0x6 || this.buffer[3] === 0x8)\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'zip',\n\t\t\t\tmime: 'application/zip',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('MThd')) {\n\t\t\treturn {\n\t\t\t\text: 'mid',\n\t\t\t\tmime: 'audio/midi',\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.checkString('wOFF')\n\t\t\t&& (\n\t\t\t\tthis.check([0x00, 0x01, 0x00, 0x00], {offset: 4})\n\t\t\t\t|| this.checkString('OTTO', {offset: 4})\n\t\t\t)\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'woff',\n\t\t\t\tmime: 'font/woff',\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.checkString('wOF2')\n\t\t\t&& (\n\t\t\t\tthis.check([0x00, 0x01, 0x00, 0x00], {offset: 4})\n\t\t\t\t|| this.checkString('OTTO', {offset: 4})\n\t\t\t)\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'woff2',\n\t\t\t\tmime: 'font/woff2',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xD4, 0xC3, 0xB2, 0xA1]) || this.check([0xA1, 0xB2, 0xC3, 0xD4])) {\n\t\t\treturn {\n\t\t\t\text: 'pcap',\n\t\t\t\tmime: 'application/vnd.tcpdump.pcap',\n\t\t\t};\n\t\t}\n\n\t\t// Sony DSD Stream File (DSF)\n\t\tif (this.checkString('DSD ')) {\n\t\t\treturn {\n\t\t\t\text: 'dsf',\n\t\t\t\tmime: 'audio/x-dsf', // Non-standard\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('LZIP')) {\n\t\t\treturn {\n\t\t\t\text: 'lz',\n\t\t\t\tmime: 'application/x-lzip',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('fLaC')) {\n\t\t\treturn {\n\t\t\t\text: 'flac',\n\t\t\t\tmime: 'audio/x-flac',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x42, 0x50, 0x47, 0xFB])) {\n\t\t\treturn {\n\t\t\t\text: 'bpg',\n\t\t\t\tmime: 'image/bpg',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('wvpk')) {\n\t\t\treturn {\n\t\t\t\text: 'wv',\n\t\t\t\tmime: 'audio/wavpack',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('%PDF')) {\n\t\t\ttry {\n\t\t\t\tawait tokenizer.ignore(1350);\n\t\t\t\tconst maxBufferSize = 10 * 1024 * 1024;\n\t\t\t\tconst buffer = new Uint8Array(Math.min(maxBufferSize, tokenizer.fileInfo.size));\n\t\t\t\tawait tokenizer.readBuffer(buffer, {mayBeLess: true});\n\n\t\t\t\t// Check if this is an Adobe Illustrator file\n\t\t\t\tif (includes(buffer, new TextEncoder().encode('AIPrivateData'))) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'ai',\n\t\t\t\t\t\tmime: 'application/postscript',\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Swallow end of stream error if file is too small for the Adobe AI check\n\t\t\t\tif (!(error instanceof strtok3.EndOfStreamError)) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Assume this is just a normal PDF\n\t\t\treturn {\n\t\t\t\text: 'pdf',\n\t\t\t\tmime: 'application/pdf',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x00, 0x61, 0x73, 0x6D])) {\n\t\t\treturn {\n\t\t\t\text: 'wasm',\n\t\t\t\tmime: 'application/wasm',\n\t\t\t};\n\t\t}\n\n\t\t// TIFF, little-endian type\n\t\tif (this.check([0x49, 0x49])) {\n\t\t\tconst fileType = await this.readTiffHeader(false);\n\t\t\tif (fileType) {\n\t\t\t\treturn fileType;\n\t\t\t}\n\t\t}\n\n\t\t// TIFF, big-endian type\n\t\tif (this.check([0x4D, 0x4D])) {\n\t\t\tconst fileType = await this.readTiffHeader(true);\n\t\t\tif (fileType) {\n\t\t\t\treturn fileType;\n\t\t\t}\n\t\t}\n\n\t\tif (this.checkString('MAC ')) {\n\t\t\treturn {\n\t\t\t\text: 'ape',\n\t\t\t\tmime: 'audio/ape',\n\t\t\t};\n\t\t}\n\n\t\t// https://github.com/file/file/blob/master/magic/Magdir/matroska\n\t\tif (this.check([0x1A, 0x45, 0xDF, 0xA3])) { // Root element: EBML\n\t\t\tasync function readField() {\n\t\t\t\tconst msb = await tokenizer.peekNumber(Token.UINT8);\n\t\t\t\tlet mask = 0x80;\n\t\t\t\tlet ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D\n\n\t\t\t\twhile ((msb & mask) === 0 && mask !== 0) {\n\t\t\t\t\t++ic;\n\t\t\t\t\tmask >>= 1;\n\t\t\t\t}\n\n\t\t\t\tconst id = new Uint8Array(ic + 1);\n\t\t\t\tawait tokenizer.readBuffer(id);\n\t\t\t\treturn id;\n\t\t\t}\n\n\t\t\tasync function readElement() {\n\t\t\t\tconst idField = await readField();\n\t\t\t\tconst lengthField = await readField();\n\n\t\t\t\tlengthField[0] ^= 0x80 >> (lengthField.length - 1);\n\t\t\t\tconst nrLength = Math.min(6, lengthField.length); // JavaScript can max read 6 bytes integer\n\n\t\t\t\tconst idView = new DataView(idField.buffer);\n\t\t\t\tconst lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);\n\n\t\t\t\treturn {\n\t\t\t\t\tid: getUintBE(idView),\n\t\t\t\t\tlen: getUintBE(lengthView),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tasync function readChildren(children) {\n\t\t\t\twhile (children > 0) {\n\t\t\t\t\tconst element = await readElement();\n\t\t\t\t\tif (element.id === 0x42_82) {\n\t\t\t\t\t\tconst rawValue = await tokenizer.readToken(new Token.StringType(element.len));\n\t\t\t\t\t\treturn rawValue.replaceAll(/\\00.*$/g, ''); // Return DocType\n\t\t\t\t\t}\n\n\t\t\t\t\tawait tokenizer.ignore(element.len); // ignore payload\n\t\t\t\t\t--children;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst re = await readElement();\n\t\t\tconst documentType = await readChildren(re.len);\n\n\t\t\tswitch (documentType) {\n\t\t\t\tcase 'webm':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'webm',\n\t\t\t\t\t\tmime: 'video/webm',\n\t\t\t\t\t};\n\n\t\t\t\tcase 'matroska':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'mkv',\n\t\t\t\t\t\tmime: 'video/x-matroska',\n\t\t\t\t\t};\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// RIFF file format which might be AVI, WAV, QCP, etc\n\t\tif (this.check([0x52, 0x49, 0x46, 0x46])) {\n\t\t\tif (this.check([0x41, 0x56, 0x49], {offset: 8})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'avi',\n\t\t\t\t\tmime: 'video/vnd.avi',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (this.check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'wav',\n\t\t\t\t\tmime: 'audio/wav',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// QLCM, QCP file\n\t\t\tif (this.check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'qcp',\n\t\t\t\t\tmime: 'audio/qcelp',\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (this.checkString('SQLi')) {\n\t\t\treturn {\n\t\t\t\text: 'sqlite',\n\t\t\t\tmime: 'application/x-sqlite3',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x4E, 0x45, 0x53, 0x1A])) {\n\t\t\treturn {\n\t\t\t\text: 'nes',\n\t\t\t\tmime: 'application/x-nintendo-nes-rom',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('Cr24')) {\n\t\t\treturn {\n\t\t\t\text: 'crx',\n\t\t\t\tmime: 'application/x-google-chrome-extension',\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.checkString('MSCF')\n\t\t\t|| this.checkString('ISc(')\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'cab',\n\t\t\t\tmime: 'application/vnd.ms-cab-compressed',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xED, 0xAB, 0xEE, 0xDB])) {\n\t\t\treturn {\n\t\t\t\text: 'rpm',\n\t\t\t\tmime: 'application/x-rpm',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xC5, 0xD0, 0xD3, 0xC6])) {\n\t\t\treturn {\n\t\t\t\text: 'eps',\n\t\t\t\tmime: 'application/eps',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x28, 0xB5, 0x2F, 0xFD])) {\n\t\t\treturn {\n\t\t\t\text: 'zst',\n\t\t\t\tmime: 'application/zstd',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x7F, 0x45, 0x4C, 0x46])) {\n\t\t\treturn {\n\t\t\t\text: 'elf',\n\t\t\t\tmime: 'application/x-elf',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x21, 0x42, 0x44, 0x4E])) {\n\t\t\treturn {\n\t\t\t\text: 'pst',\n\t\t\t\tmime: 'application/vnd.ms-outlook',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('PAR1')) {\n\t\t\treturn {\n\t\t\t\text: 'parquet',\n\t\t\t\tmime: 'application/x-parquet',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xCF, 0xFA, 0xED, 0xFE])) {\n\t\t\treturn {\n\t\t\t\text: 'macho',\n\t\t\t\tmime: 'application/x-mach-binary',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x04, 0x22, 0x4D, 0x18])) {\n\t\t\treturn {\n\t\t\t\text: 'lz4',\n\t\t\t\tmime: 'application/x-lz4', // Invented by us\n\t\t\t};\n\t\t}\n\n\t\t// -- 5-byte signatures --\n\n\t\tif (this.check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'otf',\n\t\t\t\tmime: 'font/otf',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('#!AMR')) {\n\t\t\treturn {\n\t\t\t\text: 'amr',\n\t\t\t\tmime: 'audio/amr',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('{\\\\rtf')) {\n\t\t\treturn {\n\t\t\t\text: 'rtf',\n\t\t\t\tmime: 'application/rtf',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x46, 0x4C, 0x56, 0x01])) {\n\t\t\treturn {\n\t\t\t\text: 'flv',\n\t\t\t\tmime: 'video/x-flv',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('IMPM')) {\n\t\t\treturn {\n\t\t\t\text: 'it',\n\t\t\t\tmime: 'audio/x-it',\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.checkString('-lh0-', {offset: 2})\n\t\t\t|| this.checkString('-lh1-', {offset: 2})\n\t\t\t|| this.checkString('-lh2-', {offset: 2})\n\t\t\t|| this.checkString('-lh3-', {offset: 2})\n\t\t\t|| this.checkString('-lh4-', {offset: 2})\n\t\t\t|| this.checkString('-lh5-', {offset: 2})\n\t\t\t|| this.checkString('-lh6-', {offset: 2})\n\t\t\t|| this.checkString('-lh7-', {offset: 2})\n\t\t\t|| this.checkString('-lzs-', {offset: 2})\n\t\t\t|| this.checkString('-lz4-', {offset: 2})\n\t\t\t|| this.checkString('-lz5-', {offset: 2})\n\t\t\t|| this.checkString('-lhd-', {offset: 2})\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'lzh',\n\t\t\t\tmime: 'application/x-lzh-compressed',\n\t\t\t};\n\t\t}\n\n\t\t// MPEG program stream (PS or MPEG-PS)\n\t\tif (this.check([0x00, 0x00, 0x01, 0xBA])) {\n\t\t\t//  MPEG-PS, MPEG-1 Part 1\n\t\t\tif (this.check([0x21], {offset: 4, mask: [0xF1]})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'mpg', // May also be .ps, .mpeg\n\t\t\t\t\tmime: 'video/MP1S',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// MPEG-PS, MPEG-2 Part 1\n\t\t\tif (this.check([0x44], {offset: 4, mask: [0xC4]})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'mpg', // May also be .mpg, .m2p, .vob or .sub\n\t\t\t\t\tmime: 'video/MP2P',\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (this.checkString('ITSF')) {\n\t\t\treturn {\n\t\t\t\text: 'chm',\n\t\t\t\tmime: 'application/vnd.ms-htmlhelp',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xCA, 0xFE, 0xBA, 0xBE])) {\n\t\t\treturn {\n\t\t\t\text: 'class',\n\t\t\t\tmime: 'application/java-vm',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('DRACO')) {\n\t\t\treturn {\n\t\t\t\text: 'drc',\n\t\t\t\tmime: 'application/vnd.google.draco', // Invented by us\n\t\t\t};\n\t\t}\n\n\t\t// -- 6-byte signatures --\n\n\t\tif (this.check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'xz',\n\t\t\t\tmime: 'application/x-xz',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('<?xml ')) {\n\t\t\treturn {\n\t\t\t\text: 'xml',\n\t\t\t\tmime: 'application/xml',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {\n\t\t\treturn {\n\t\t\t\text: '7z',\n\t\t\t\tmime: 'application/x-7z-compressed',\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7])\n\t\t\t&& (this.buffer[6] === 0x0 || this.buffer[6] === 0x1)\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'rar',\n\t\t\t\tmime: 'application/x-rar-compressed',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('solid ')) {\n\t\t\treturn {\n\t\t\t\text: 'stl',\n\t\t\t\tmime: 'model/stl',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('AC')) {\n\t\t\tconst version = new Token.StringType(4, 'latin1').get(this.buffer, 2);\n\t\t\tif (version.match('^d*') && version >= 1000 && version <= 1050) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'dwg',\n\t\t\t\t\tmime: 'image/vnd.dwg',\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (this.checkString('070707')) {\n\t\t\treturn {\n\t\t\t\text: 'cpio',\n\t\t\t\tmime: 'application/x-cpio',\n\t\t\t};\n\t\t}\n\n\t\t// -- 7-byte signatures --\n\n\t\tif (this.checkString('BLENDER')) {\n\t\t\treturn {\n\t\t\t\text: 'blend',\n\t\t\t\tmime: 'application/x-blender',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('!<arch>')) {\n\t\t\tawait tokenizer.ignore(8);\n\t\t\tconst string = await tokenizer.readToken(new Token.StringType(13, 'ascii'));\n\t\t\tif (string === 'debian-binary') {\n\t\t\t\treturn {\n\t\t\t\t\text: 'deb',\n\t\t\t\t\tmime: 'application/x-deb',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\text: 'ar',\n\t\t\t\tmime: 'application/x-unix-archive',\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.checkString('WEBVTT')\n\t\t\t&&\t(\n\t\t\t\t// One of LF, CR, tab, space, or end of file must follow \"WEBVTT\" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\\0` gives us the same result as checking for the end of the stream.\n\t\t\t\t(['\\n', '\\r', '\\t', ' ', '\\0'].some(char7 => this.checkString(char7, {offset: 6}))))\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'vtt',\n\t\t\t\tmime: 'text/vtt',\n\t\t\t};\n\t\t}\n\n\t\t// -- 8-byte signatures --\n\n\t\tif (this.check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {\n\t\t\t// APNG format (https://wiki.mozilla.org/APNG_Specification)\n\t\t\t// 1. Find the first IDAT (image data) chunk (49 44 41 54)\n\t\t\t// 2. Check if there is an \"acTL\" chunk before the IDAT one (61 63 54 4C)\n\n\t\t\t// Offset calculated as follows:\n\t\t\t// - 8 bytes: PNG signature\n\t\t\t// - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk\n\n\t\t\tawait tokenizer.ignore(8); // ignore PNG signature\n\n\t\t\tasync function readChunkHeader() {\n\t\t\t\treturn {\n\t\t\t\t\tlength: await tokenizer.readToken(Token.INT32_BE),\n\t\t\t\t\ttype: await tokenizer.readToken(new Token.StringType(4, 'latin1')),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\tconst chunk = await readChunkHeader();\n\t\t\t\tif (chunk.length < 0) {\n\t\t\t\t\treturn; // Invalid chunk length\n\t\t\t\t}\n\n\t\t\t\tswitch (chunk.type) {\n\t\t\t\t\tcase 'IDAT':\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\text: 'png',\n\t\t\t\t\t\t\tmime: 'image/png',\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'acTL':\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\text: 'apng',\n\t\t\t\t\t\t\tmime: 'image/apng',\n\t\t\t\t\t\t};\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tawait tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC\n\t\t\t\t}\n\t\t\t} while (tokenizer.position + 8 < tokenizer.fileInfo.size);\n\n\t\t\treturn {\n\t\t\t\text: 'png',\n\t\t\t\tmime: 'image/png',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'arrow',\n\t\t\t\tmime: 'application/x-apache-arrow',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'glb',\n\t\t\t\tmime: 'model/gltf-binary',\n\t\t\t};\n\t\t}\n\n\t\t// `mov` format variants\n\t\tif (\n\t\t\tthis.check([0x66, 0x72, 0x65, 0x65], {offset: 4}) // `free`\n\t\t\t|| this.check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) // `mdat` MJPEG\n\t\t\t|| this.check([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) // `moov`\n\t\t\t|| this.check([0x77, 0x69, 0x64, 0x65], {offset: 4}) // `wide`\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'mov',\n\t\t\t\tmime: 'video/quicktime',\n\t\t\t};\n\t\t}\n\n\t\t// -- 9-byte signatures --\n\n\t\tif (this.check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {\n\t\t\treturn {\n\t\t\t\text: 'orf',\n\t\t\t\tmime: 'image/x-olympus-orf',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('gimp xcf ')) {\n\t\t\treturn {\n\t\t\t\text: 'xcf',\n\t\t\t\tmime: 'image/x-xcf',\n\t\t\t};\n\t\t}\n\n\t\t// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)\n\t\t// It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.\n\t\t// `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.\n\t\t// Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).\n\t\tif (\n\t\t\tthis.checkString('ftyp', {offset: 4})\n\t\t\t&& (this.buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?\n\t\t) {\n\t\t\t// They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.\n\t\t\t// For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.\n\t\t\tconst brandMajor = new Token.StringType(4, 'latin1').get(this.buffer, 8).replace('\\0', ' ').trim();\n\t\t\tswitch (brandMajor) {\n\t\t\t\tcase 'avif':\n\t\t\t\tcase 'avis':\n\t\t\t\t\treturn {ext: 'avif', mime: 'image/avif'};\n\t\t\t\tcase 'mif1':\n\t\t\t\t\treturn {ext: 'heic', mime: 'image/heif'};\n\t\t\t\tcase 'msf1':\n\t\t\t\t\treturn {ext: 'heic', mime: 'image/heif-sequence'};\n\t\t\t\tcase 'heic':\n\t\t\t\tcase 'heix':\n\t\t\t\t\treturn {ext: 'heic', mime: 'image/heic'};\n\t\t\t\tcase 'hevc':\n\t\t\t\tcase 'hevx':\n\t\t\t\t\treturn {ext: 'heic', mime: 'image/heic-sequence'};\n\t\t\t\tcase 'qt':\n\t\t\t\t\treturn {ext: 'mov', mime: 'video/quicktime'};\n\t\t\t\tcase 'M4V':\n\t\t\t\tcase 'M4VH':\n\t\t\t\tcase 'M4VP':\n\t\t\t\t\treturn {ext: 'm4v', mime: 'video/x-m4v'};\n\t\t\t\tcase 'M4P':\n\t\t\t\t\treturn {ext: 'm4p', mime: 'video/mp4'};\n\t\t\t\tcase 'M4B':\n\t\t\t\t\treturn {ext: 'm4b', mime: 'audio/mp4'};\n\t\t\t\tcase 'M4A':\n\t\t\t\t\treturn {ext: 'm4a', mime: 'audio/x-m4a'};\n\t\t\t\tcase 'F4V':\n\t\t\t\t\treturn {ext: 'f4v', mime: 'video/mp4'};\n\t\t\t\tcase 'F4P':\n\t\t\t\t\treturn {ext: 'f4p', mime: 'video/mp4'};\n\t\t\t\tcase 'F4A':\n\t\t\t\t\treturn {ext: 'f4a', mime: 'audio/mp4'};\n\t\t\t\tcase 'F4B':\n\t\t\t\t\treturn {ext: 'f4b', mime: 'audio/mp4'};\n\t\t\t\tcase 'crx':\n\t\t\t\t\treturn {ext: 'cr3', mime: 'image/x-canon-cr3'};\n\t\t\t\tdefault:\n\t\t\t\t\tif (brandMajor.startsWith('3g')) {\n\t\t\t\t\t\tif (brandMajor.startsWith('3g2')) {\n\t\t\t\t\t\t\treturn {ext: '3g2', mime: 'video/3gpp2'};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {ext: '3gp', mime: 'video/3gpp'};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {ext: 'mp4', mime: 'video/mp4'};\n\t\t\t}\n\t\t}\n\n\t\t// -- 12-byte signatures --\n\n\t\tif (this.check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {\n\t\t\treturn {\n\t\t\t\text: 'rw2',\n\t\t\t\tmime: 'image/x-panasonic-rw2',\n\t\t\t};\n\t\t}\n\n\t\t// ASF_Header_Object first 80 bytes\n\t\tif (this.check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {\n\t\t\tasync function readHeader() {\n\t\t\t\tconst guid = new Uint8Array(16);\n\t\t\t\tawait tokenizer.readBuffer(guid);\n\t\t\t\treturn {\n\t\t\t\t\tid: guid,\n\t\t\t\t\tsize: Number(await tokenizer.readToken(Token.UINT64_LE)),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tawait tokenizer.ignore(30);\n\t\t\t// Search for header should be in first 1KB of file.\n\t\t\twhile (tokenizer.position + 24 < tokenizer.fileInfo.size) {\n\t\t\t\tconst header = await readHeader();\n\t\t\t\tlet payload = header.size - 24;\n\t\t\t\tif (_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {\n\t\t\t\t\t// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)\n\t\t\t\t\tconst typeId = new Uint8Array(16);\n\t\t\t\t\tpayload -= await tokenizer.readBuffer(typeId);\n\n\t\t\t\t\tif (_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {\n\t\t\t\t\t\t// Found audio:\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\text: 'asf',\n\t\t\t\t\t\t\tmime: 'audio/x-ms-asf',\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {\n\t\t\t\t\t\t// Found video:\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\text: 'asf',\n\t\t\t\t\t\t\tmime: 'video/x-ms-asf',\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tawait tokenizer.ignore(payload);\n\t\t\t}\n\n\t\t\t// Default to ASF generic extension\n\t\t\treturn {\n\t\t\t\text: 'asf',\n\t\t\t\tmime: 'application/vnd.ms-asf',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {\n\t\t\treturn {\n\t\t\t\text: 'ktx',\n\t\t\t\tmime: 'image/ktx',\n\t\t\t};\n\t\t}\n\n\t\tif ((this.check([0x7E, 0x10, 0x04]) || this.check([0x7E, 0x18, 0x04])) && this.check([0x30, 0x4D, 0x49, 0x45], {offset: 4})) {\n\t\t\treturn {\n\t\t\t\text: 'mie',\n\t\t\t\tmime: 'application/x-mie',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {offset: 2})) {\n\t\t\treturn {\n\t\t\t\text: 'shp',\n\t\t\t\tmime: 'application/x-esri-shape',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xFF, 0x4F, 0xFF, 0x51])) {\n\t\t\treturn {\n\t\t\t\text: 'j2c',\n\t\t\t\tmime: 'image/j2c',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {\n\t\t\t// JPEG-2000 family\n\n\t\t\tawait tokenizer.ignore(20);\n\t\t\tconst type = await tokenizer.readToken(new Token.StringType(4, 'ascii'));\n\t\t\tswitch (type) {\n\t\t\t\tcase 'jp2 ':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'jp2',\n\t\t\t\t\t\tmime: 'image/jp2',\n\t\t\t\t\t};\n\t\t\t\tcase 'jpx ':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'jpx',\n\t\t\t\t\t\tmime: 'image/jpx',\n\t\t\t\t\t};\n\t\t\t\tcase 'jpm ':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'jpm',\n\t\t\t\t\t\tmime: 'image/jpm',\n\t\t\t\t\t};\n\t\t\t\tcase 'mjp2':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'mj2',\n\t\t\t\t\t\tmime: 'image/mj2',\n\t\t\t\t\t};\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tthis.check([0xFF, 0x0A])\n\t\t\t|| this.check([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A])\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'jxl',\n\t\t\t\tmime: 'image/jxl',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xFE, 0xFF])) { // UTF-16-BOM-LE\n\t\t\tif (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], {offset: 2})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'xml',\n\t\t\t\t\tmime: 'application/xml',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn undefined; // Some unknown text based format\n\t\t}\n\n\t\tif (this.check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {\n\t\t\t// Detected Microsoft Compound File Binary File (MS-CFB) Format.\n\t\t\treturn {\n\t\t\t\text: 'cfb',\n\t\t\t\tmime: 'application/x-cfb',\n\t\t\t};\n\t\t}\n\n\t\t// Increase sample size from 12 to 256.\n\t\tawait tokenizer.peekBuffer(this.buffer, {length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true});\n\n\t\tif (this.check([0x61, 0x63, 0x73, 0x70], {offset: 36})) {\n\t\t\treturn {\n\t\t\t\text: 'icc',\n\t\t\t\tmime: 'application/vnd.iccprofile',\n\t\t\t};\n\t\t}\n\n\t\t// ACE: requires 14 bytes in the buffer\n\t\tif (this.checkString('**ACE', {offset: 7}) && this.checkString('**', {offset: 12})) {\n\t\t\treturn {\n\t\t\t\text: 'ace',\n\t\t\t\tmime: 'application/x-ace-compressed',\n\t\t\t};\n\t\t}\n\n\t\t// -- 15-byte signatures --\n\n\t\tif (this.checkString('BEGIN:')) {\n\t\t\tif (this.checkString('VCARD', {offset: 6})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'vcf',\n\t\t\t\t\tmime: 'text/vcard',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (this.checkString('VCALENDAR', {offset: 6})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'ics',\n\t\t\t\t\tmime: 'text/calendar',\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// `raf` is here just to keep all the raw image detectors together.\n\t\tif (this.checkString('FUJIFILMCCD-RAW')) {\n\t\t\treturn {\n\t\t\t\text: 'raf',\n\t\t\t\tmime: 'image/x-fujifilm-raf',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('Extended Module:')) {\n\t\t\treturn {\n\t\t\t\text: 'xm',\n\t\t\t\tmime: 'audio/x-xm',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('Creative Voice File')) {\n\t\t\treturn {\n\t\t\t\text: 'voc',\n\t\t\t\tmime: 'audio/x-voc',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x04, 0x00, 0x00, 0x00]) && this.buffer.length >= 16) { // Rough & quick check Pickle/ASAR\n\t\t\tconst jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);\n\n\t\t\tif (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {\n\t\t\t\ttry {\n\t\t\t\t\tconst header = new TextDecoder().decode(this.buffer.slice(16, jsonSize + 16));\n\t\t\t\t\tconst json = JSON.parse(header);\n\t\t\t\t\t// Check if Pickle is ASAR\n\t\t\t\t\tif (json.files) { // Final check, assuring Pickle/ASAR format\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\text: 'asar',\n\t\t\t\t\t\t\tmime: 'application/x-asar',\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} catch {}\n\t\t\t}\n\t\t}\n\n\t\tif (this.check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {\n\t\t\treturn {\n\t\t\t\text: 'mxf',\n\t\t\t\tmime: 'application/mxf',\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('SCRM', {offset: 44})) {\n\t\t\treturn {\n\t\t\t\text: 's3m',\n\t\t\t\tmime: 'audio/x-s3m',\n\t\t\t};\n\t\t}\n\n\t\t// Raw MPEG-2 transport stream (188-byte packets)\n\t\tif (this.check([0x47]) && this.check([0x47], {offset: 188})) {\n\t\t\treturn {\n\t\t\t\text: 'mts',\n\t\t\t\tmime: 'video/mp2t',\n\t\t\t};\n\t\t}\n\n\t\t// Blu-ray Disc Audio-Video (BDAV) MPEG-2 transport stream has 4-byte TP_extra_header before each 188-byte packet\n\t\tif (this.check([0x47], {offset: 4}) && this.check([0x47], {offset: 196})) {\n\t\t\treturn {\n\t\t\t\text: 'mts',\n\t\t\t\tmime: 'video/mp2t',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {\n\t\t\treturn {\n\t\t\t\text: 'mobi',\n\t\t\t\tmime: 'application/x-mobipocket-ebook',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {\n\t\t\treturn {\n\t\t\t\text: 'dcm',\n\t\t\t\tmime: 'application/dicom',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {\n\t\t\treturn {\n\t\t\t\text: 'lnk',\n\t\t\t\tmime: 'application/x.ms.shortcut', // Invented by us\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'alias',\n\t\t\t\tmime: 'application/x.apple.alias', // Invented by us\n\t\t\t};\n\t\t}\n\n\t\tif (this.checkString('Kaydara FBX Binary  \\u0000')) {\n\t\t\treturn {\n\t\t\t\text: 'fbx',\n\t\t\t\tmime: 'application/x.autodesk.fbx', // Invented by us\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tthis.check([0x4C, 0x50], {offset: 34})\n\t\t\t&& (\n\t\t\t\tthis.check([0x00, 0x00, 0x01], {offset: 8})\n\t\t\t\t|| this.check([0x01, 0x00, 0x02], {offset: 8})\n\t\t\t\t|| this.check([0x02, 0x00, 0x02], {offset: 8})\n\t\t\t)\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'eot',\n\t\t\t\tmime: 'application/vnd.ms-fontobject',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {\n\t\t\treturn {\n\t\t\t\text: 'indd',\n\t\t\t\tmime: 'application/x-indesign',\n\t\t\t};\n\t\t}\n\n\t\t// Increase sample size from 256 to 512\n\t\tawait tokenizer.peekBuffer(this.buffer, {length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true});\n\n\t\t// Requires a buffer size of 512 bytes\n\t\tif (tarHeaderChecksumMatches(this.buffer)) {\n\t\t\treturn {\n\t\t\t\text: 'tar',\n\t\t\t\tmime: 'application/x-tar',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0xFF, 0xFE])) { // UTF-16-BOM-BE\n\t\t\tif (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], {offset: 2})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'xml',\n\t\t\t\t\tmime: 'application/xml',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (this.check([0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00], {offset: 2})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'skp',\n\t\t\t\t\tmime: 'application/vnd.sketchup.skp',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn undefined; // Some text based format\n\t\t}\n\n\t\tif (this.checkString('-----BEGIN PGP MESSAGE-----')) {\n\t\t\treturn {\n\t\t\t\text: 'pgp',\n\t\t\t\tmime: 'application/pgp-encrypted',\n\t\t\t};\n\t\t}\n\t};\n\t// Detections with limited supporting data, resulting in a higher likelihood of false positives\n\tdetectImprecise = async tokenizer => {\n\t\tthis.buffer = new Uint8Array(reasonableDetectionSizeInBytes);\n\n\t\t// Read initial sample size of 8 bytes\n\t\tawait tokenizer.peekBuffer(this.buffer, {length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true});\n\n\t\tif (\n\t\t\tthis.check([0x0, 0x0, 0x1, 0xBA])\n\t\t\t|| this.check([0x0, 0x0, 0x1, 0xB3])\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'mpg',\n\t\t\t\tmime: 'video/mpeg',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x00, 0x01, 0x00, 0x00, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'ttf',\n\t\t\t\tmime: 'font/ttf',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x00, 0x00, 0x01, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'ico',\n\t\t\t\tmime: 'image/x-icon',\n\t\t\t};\n\t\t}\n\n\t\tif (this.check([0x00, 0x00, 0x02, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'cur',\n\t\t\t\tmime: 'image/x-icon',\n\t\t\t};\n\t\t}\n\n\t\t// Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)\n\t\tif (this.buffer.length >= 2 && this.check([0xFF, 0xE0], {offset: 0, mask: [0xFF, 0xE0]})) {\n\t\t\tif (this.check([0x10], {offset: 1, mask: [0x16]})) {\n\t\t\t\t// Check for (ADTS) MPEG-2\n\t\t\t\tif (this.check([0x08], {offset: 1, mask: [0x08]})) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'aac',\n\t\t\t\t\t\tmime: 'audio/aac',\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Must be (ADTS) MPEG-4\n\t\t\t\treturn {\n\t\t\t\t\text: 'aac',\n\t\t\t\t\tmime: 'audio/aac',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// MPEG 1 or 2 Layer 3 header\n\t\t\t// Check for MPEG layer 3\n\t\t\tif (this.check([0x02], {offset: 1, mask: [0x06]})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'mp3',\n\t\t\t\t\tmime: 'audio/mpeg',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check for MPEG layer 2\n\t\t\tif (this.check([0x04], {offset: 1, mask: [0x06]})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'mp2',\n\t\t\t\t\tmime: 'audio/mpeg',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Check for MPEG layer 1\n\t\t\tif (this.check([0x06], {offset: 1, mask: [0x06]})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'mp1',\n\t\t\t\t\tmime: 'audio/mpeg',\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t};\n\n\tasync readTiffTag(bigEndian) {\n\t\tconst tagId = await this.tokenizer.readToken(bigEndian ? Token.UINT16_BE : Token.UINT16_LE);\n\t\tthis.tokenizer.ignore(10);\n\t\tswitch (tagId) {\n\t\t\tcase 50_341:\n\t\t\t\treturn {\n\t\t\t\t\text: 'arw',\n\t\t\t\t\tmime: 'image/x-sony-arw',\n\t\t\t\t};\n\t\t\tcase 50_706:\n\t\t\t\treturn {\n\t\t\t\t\text: 'dng',\n\t\t\t\t\tmime: 'image/x-adobe-dng',\n\t\t\t\t};\n\t\t\tdefault:\n\t\t}\n\t}\n\n\tasync readTiffIFD(bigEndian) {\n\t\tconst numberOfTags = await this.tokenizer.readToken(bigEndian ? Token.UINT16_BE : Token.UINT16_LE);\n\t\tfor (let n = 0; n < numberOfTags; ++n) {\n\t\t\tconst fileType = await this.readTiffTag(bigEndian);\n\t\t\tif (fileType) {\n\t\t\t\treturn fileType;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync readTiffHeader(bigEndian) {\n\t\tconst version = (bigEndian ? Token.UINT16_BE : Token.UINT16_LE).get(this.buffer, 2);\n\t\tconst ifdOffset = (bigEndian ? Token.UINT32_BE : Token.UINT32_LE).get(this.buffer, 4);\n\n\t\tif (version === 42) {\n\t\t\t// TIFF file header\n\t\t\tif (ifdOffset >= 6) {\n\t\t\t\tif (this.checkString('CR', {offset: 8})) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'cr2',\n\t\t\t\t\t\tmime: 'image/x-canon-cr2',\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (ifdOffset >= 8) {\n\t\t\t\t\tconst someId1 = (bigEndian ? Token.UINT16_BE : Token.UINT16_LE).get(this.buffer, 8);\n\t\t\t\t\tconst someId2 = (bigEndian ? Token.UINT16_BE : Token.UINT16_LE).get(this.buffer, 10);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(someId1 === 0x1C && someId2 === 0xFE)\n\t\t\t\t\t\t|| (someId1 === 0x1F && someId2 === 0x0B)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\text: 'nef',\n\t\t\t\t\t\t\tmime: 'image/x-nikon-nef',\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait this.tokenizer.ignore(ifdOffset);\n\t\t\tconst fileType = await this.readTiffIFD(bigEndian);\n\t\t\treturn fileType ?? {\n\t\t\t\text: 'tif',\n\t\t\t\tmime: 'image/tiff',\n\t\t\t};\n\t\t}\n\n\t\tif (version === 43) {\t// Big TIFF file header\n\t\t\treturn {\n\t\t\t\text: 'tif',\n\t\t\t\tmime: 'image/tiff',\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport const supportedExtensions = new Set(extensions);\nexport const supportedMimeTypes = new Set(mimeTypes);\n"
        },
        {
          "name": "fixture",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.d.ts",
          "type": "blob",
          "size": 4.6796875,
          "content": "/**\nTypings for Node.js specific entry point.\n*/\n\nimport type {Readable as NodeReadableStream} from 'node:stream';\nimport type {AnyWebByteStream} from 'strtok3';\nimport {\n\ttype FileTypeResult,\n\ttype StreamOptions,\n\ttype AnyWebReadableStream,\n\ttype Detector,\n\ttype AnyWebReadableByteStreamWithFileType,\n\tFileTypeParser as DefaultFileTypeParser,\n} from './core.js';\n\nexport type ReadableStreamWithFileType = NodeReadableStream & {\n\treadonly fileType?: FileTypeResult;\n};\n\n/**\nExtending `FileTypeParser` with Node.js engine specific functions.\n*/\nexport declare class FileTypeParser extends DefaultFileTypeParser {\n\t/**\n\t@param stream - Node.js `stream.Readable` or web `ReadableStream`.\n\t*/\n\tfromStream(stream: AnyWebReadableStream<Uint8Array> | NodeReadableStream): Promise<FileTypeResult | undefined>;\n\n\tfromFile(filePath: string): Promise<FileTypeResult | undefined>;\n\n\t/**\n\tWorks the same way as {@link fileTypeStream}, additionally taking into account custom detectors (if any were provided to the constructor).\n\t*/\n\ttoDetectionStream(readableStream: NodeReadableStream, options?: StreamOptions): Promise<ReadableStreamWithFileType>;\n\ttoDetectionStream(webStream: AnyWebReadableStream<Uint8Array>, options?: StreamOptions): Promise<AnyWebReadableByteStreamWithFileType>;\n}\n\n/**\nDetect the file type of a file path.\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the file.\n\nThis is for Node.js only.\n\nTo read from a [`File`](https://developer.mozilla.org/docs/Web/API/File), see `fileTypeFromBlob()`.\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n\n@returns The detected file type and MIME type or `undefined` when there is no match.\n*/\nexport function fileTypeFromFile(filePath: string, options?: {customDetectors?: Iterable<Detector>}): Promise<FileTypeResult | undefined>;\n\n/**\nDetect the file type of a [web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream).\n\nIf the engine is Node.js, this may also be a [Node.js `stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable).\n\nDirect support for Node.js streams will be dropped in the future, when Node.js streams can be converted to Web streams (see [`toWeb()`](https://nodejs.org/api/stream.html#streamreadabletowebstreamreadable-options)).\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n\n@param stream - A [web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) or [Node.js `stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable) streaming a file to examine.\n@returns A `Promise` for an object with the detected file type, or `undefined` when there is no match.\n*/\nexport function fileTypeFromStream(stream: AnyWebReadableStream<Uint8Array> | NodeReadableStream): Promise<FileTypeResult | undefined>;\n\n/**\nReturns a `Promise` which resolves to the original readable stream argument, but with an added `fileType` property, which is an object like the one returned from `fileTypeFromFile()`.\n\nThis method can be handy to put in between a stream, but it comes with a price.\nInternally `stream()` builds up a buffer of `sampleSize` bytes, used as a sample, to determine the file type.\nThe sample size impacts the file detection resolution.\nA smaller sample size will result in lower probability of the best file type detection.\n\n@param readableStream - A [web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) or [Node.js `stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable), streaming a file to examine.\n@param options - May be used to override the default sample size.\n@returns A `Promise` which resolves to the original readable stream argument, but with an added `fileType` property, which is an object like the one returned from `fileTypeFromFile()`.\n\n@example\n```\nimport got from 'got';\nimport {fileTypeStream} from 'file-type';\n\nconst url = 'https://upload.wikimedia.org/wikipedia/en/a/a9/Example.jpg';\n\nconst stream1 = got.stream(url);\nconst stream2 = await fileTypeStream(stream1, {sampleSize: 1024});\n\nif (stream2.fileType?.mime === 'image/jpeg') {\n\t// stream2 can be used to stream the JPEG image (from the very beginning of the stream)\n}\n```\n*/\nexport function fileTypeStream(readableStream: NodeReadableStream, options?: StreamOptions): Promise<ReadableStreamWithFileType>;\nexport function fileTypeStream(webStream: AnyWebByteStream, options?: StreamOptions): Promise<AnyWebReadableByteStreamWithFileType>;\n\nexport * from './core.js';\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 2.431640625,
          "content": "/**\nNode.js specific entry point.\n*/\n\nimport {ReadableStream as WebReadableStream} from 'node:stream/web';\nimport {pipeline, PassThrough, Readable} from 'node:stream';\nimport * as strtok3 from 'strtok3';\nimport {FileTypeParser as DefaultFileTypeParser, reasonableDetectionSizeInBytes} from './core.js';\n\nexport class FileTypeParser extends DefaultFileTypeParser {\n\tasync fromStream(stream) {\n\t\tconst tokenizer = await (stream instanceof WebReadableStream ? strtok3.fromWebStream(stream, this.tokenizerOptions) : strtok3.fromStream(stream, this.tokenizerOptions));\n\t\ttry {\n\t\t\treturn await super.fromTokenizer(tokenizer);\n\t\t} finally {\n\t\t\tawait tokenizer.close();\n\t\t}\n\t}\n\n\tasync fromFile(path) {\n\t\tconst tokenizer = await strtok3.fromFile(path);\n\t\ttry {\n\t\t\treturn await super.fromTokenizer(tokenizer);\n\t\t} finally {\n\t\t\tawait tokenizer.close();\n\t\t}\n\t}\n\n\tasync toDetectionStream(readableStream, options = {}) {\n\t\tif (!(readableStream instanceof Readable)) {\n\t\t\treturn super.toDetectionStream(readableStream, options);\n\t\t}\n\n\t\tconst {sampleSize = reasonableDetectionSizeInBytes} = options;\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treadableStream.on('error', reject);\n\n\t\t\treadableStream.once('readable', () => {\n\t\t\t\t(async () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Set up output stream\n\t\t\t\t\t\tconst pass = new PassThrough();\n\t\t\t\t\t\tconst outputStream = pipeline ? pipeline(readableStream, pass, () => {}) : readableStream.pipe(pass);\n\n\t\t\t\t\t\t// Read the input stream and detect the filetype\n\t\t\t\t\t\tconst chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpass.fileType = await this.fromBuffer(chunk);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tif (error instanceof strtok3.EndOfStreamError) {\n\t\t\t\t\t\t\t\tpass.fileType = undefined;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve(outputStream);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t})();\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport async function fileTypeFromFile(path, fileTypeOptions) {\n\treturn (new FileTypeParser(fileTypeOptions)).fromFile(path, fileTypeOptions);\n}\n\nexport async function fileTypeFromStream(stream, fileTypeOptions) {\n\treturn (new FileTypeParser(fileTypeOptions)).fromStream(stream);\n}\n\nexport async function fileTypeStream(readableStream, options = {}) {\n\treturn new FileTypeParser(options).toDetectionStream(readableStream, options);\n}\n\nexport {\n\tfileTypeFromTokenizer,\n\tfileTypeFromBuffer,\n\tfileTypeFromBlob,\n\tsupportedMimeTypes,\n\tsupportedExtensions,\n} from './core.js';\n"
        },
        {
          "name": "index.test-d.ts",
          "type": "blob",
          "size": 1.7822265625,
          "content": "import {createReadStream} from 'node:fs';\nimport {expectType} from 'tsd';\nimport {\n\ttype FileTypeResult as FileTypeResultBrowser,\n} from './core.js';\nimport {\n\tfileTypeFromBlob,\n\tfileTypeFromBuffer,\n\tfileTypeFromFile,\n\tfileTypeFromStream,\n\tfileTypeStream,\n\tsupportedExtensions,\n\tsupportedMimeTypes,\n\ttype FileTypeResult,\n\ttype ReadableStreamWithFileType,\n} from './index.js';\n\nexpectType<Promise<FileTypeResult | undefined>>(fileTypeFromBuffer(new Uint8Array([0xFF, 0xD8, 0xFF])));\nexpectType<Promise<FileTypeResult | undefined>>(fileTypeFromBuffer(new ArrayBuffer(42)));\n\n(async () => {\n\tconst result = await fileTypeFromBuffer(new Uint8Array([0xFF, 0xD8, 0xFF]));\n\tif (result !== undefined) {\n\t\texpectType<string>(result.ext);\n\t\texpectType<string>(result.mime);\n\t}\n})();\n\n(async () => {\n\texpectType<FileTypeResult | undefined>(await fileTypeFromFile('myFile'));\n\n\tconst result = await fileTypeFromFile('myFile');\n\tif (result !== undefined) {\n\t\texpectType<string>(result.ext);\n\t\texpectType<string>(result.mime);\n\t}\n})();\n\n(async () => {\n\tconst stream = createReadStream('myFile');\n\n\texpectType<FileTypeResult | undefined>(await fileTypeFromStream(stream));\n\n\tconst result = await fileTypeFromStream(stream);\n\tif (result !== undefined) {\n\t\texpectType<string>(result.ext);\n\t\texpectType<string>(result.mime);\n\t}\n})();\n\nexpectType<ReadonlySet<string>>(supportedExtensions);\n\nexpectType<ReadonlySet<string>>(supportedMimeTypes);\n\nconst readableStream = createReadStream('file.png');\nconst streamWithFileType = fileTypeStream(readableStream);\nexpectType<Promise<ReadableStreamWithFileType>>(streamWithFileType);\n(async () => {\n\tconst {fileType} = await streamWithFileType;\n\texpectType<FileTypeResult | undefined>(fileType);\n})();\n\n// Browser\nexpectType<Promise<FileTypeResultBrowser | undefined>>(fileTypeFromBlob(new Blob([])));\n"
        },
        {
          "name": "license",
          "type": "blob",
          "size": 1.0908203125,
          "content": "MIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "media",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 3.365234375,
          "content": "{\n\t\"name\": \"file-type\",\n\t\"version\": \"19.6.0\",\n\t\"description\": \"Detect the file type of a file, stream, or data\",\n\t\"license\": \"MIT\",\n\t\"repository\": \"sindresorhus/file-type\",\n\t\"funding\": \"https://github.com/sindresorhus/file-type?sponsor=1\",\n\t\"author\": {\n\t\t\"name\": \"Sindre Sorhus\",\n\t\t\"email\": \"sindresorhus@gmail.com\",\n\t\t\"url\": \"https://sindresorhus.com\"\n\t},\n\t\"type\": \"module\",\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"node\": {\n\t\t\t\t\"types\": \"./index.d.ts\",\n\t\t\t\t\"import\": \"./index.js\"\n\t\t\t},\n\t\t\t\"default\": {\n\t\t\t\t\"types\": \"./core.d.ts\",\n\t\t\t\t\"import\": \"./core.js\"\n\t\t\t}\n\t\t},\n\t\t\"./core\": {\n\t\t\t\"types\": \"./core.d.ts\",\n\t\t\t\"import\": \"./core.js\"\n\t\t}\n\t},\n\t\"sideEffects\": false,\n\t\"engines\": {\n\t\t\"node\": \">=18\"\n\t},\n\t\"scripts\": {\n\t\t\"test\": \"xo && ava && tsd\"\n\t},\n\t\"files\": [\n\t\t\"index.js\",\n\t\t\"index.d.ts\",\n\t\t\"core.js\",\n\t\t\"core.d.ts\",\n\t\t\"supported.js\",\n\t\t\"util.js\"\n\t],\n\t\"keywords\": [\n\t\t\"mime\",\n\t\t\"file\",\n\t\t\"type\",\n\t\t\"magic\",\n\t\t\"archive\",\n\t\t\"image\",\n\t\t\"img\",\n\t\t\"pic\",\n\t\t\"picture\",\n\t\t\"flash\",\n\t\t\"photo\",\n\t\t\"video\",\n\t\t\"detect\",\n\t\t\"check\",\n\t\t\"is\",\n\t\t\"exif\",\n\t\t\"elf\",\n\t\t\"macho\",\n\t\t\"exe\",\n\t\t\"binary\",\n\t\t\"buffer\",\n\t\t\"uint8array\",\n\t\t\"jpg\",\n\t\t\"png\",\n\t\t\"apng\",\n\t\t\"gif\",\n\t\t\"webp\",\n\t\t\"flif\",\n\t\t\"xcf\",\n\t\t\"cr2\",\n\t\t\"cr3\",\n\t\t\"orf\",\n\t\t\"arw\",\n\t\t\"dng\",\n\t\t\"nef\",\n\t\t\"rw2\",\n\t\t\"raf\",\n\t\t\"tif\",\n\t\t\"bmp\",\n\t\t\"icns\",\n\t\t\"jxr\",\n\t\t\"psd\",\n\t\t\"indd\",\n\t\t\"zip\",\n\t\t\"tar\",\n\t\t\"rar\",\n\t\t\"gz\",\n\t\t\"bz2\",\n\t\t\"7z\",\n\t\t\"dmg\",\n\t\t\"mp4\",\n\t\t\"mid\",\n\t\t\"mkv\",\n\t\t\"webm\",\n\t\t\"mov\",\n\t\t\"avi\",\n\t\t\"mpg\",\n\t\t\"mp2\",\n\t\t\"mp3\",\n\t\t\"m4a\",\n\t\t\"ogg\",\n\t\t\"opus\",\n\t\t\"flac\",\n\t\t\"wav\",\n\t\t\"amr\",\n\t\t\"pdf\",\n\t\t\"epub\",\n\t\t\"mobi\",\n\t\t\"swf\",\n\t\t\"rtf\",\n\t\t\"woff\",\n\t\t\"woff2\",\n\t\t\"eot\",\n\t\t\"ttf\",\n\t\t\"otf\",\n\t\t\"ico\",\n\t\t\"flv\",\n\t\t\"ps\",\n\t\t\"xz\",\n\t\t\"sqlite\",\n\t\t\"xpi\",\n\t\t\"cab\",\n\t\t\"deb\",\n\t\t\"ar\",\n\t\t\"rpm\",\n\t\t\"Z\",\n\t\t\"lz\",\n\t\t\"cfb\",\n\t\t\"mxf\",\n\t\t\"mts\",\n\t\t\"wasm\",\n\t\t\"webassembly\",\n\t\t\"blend\",\n\t\t\"bpg\",\n\t\t\"docx\",\n\t\t\"pptx\",\n\t\t\"xlsx\",\n\t\t\"3gp\",\n\t\t\"j2c\",\n\t\t\"jp2\",\n\t\t\"jpm\",\n\t\t\"jpx\",\n\t\t\"mj2\",\n\t\t\"aif\",\n\t\t\"odt\",\n\t\t\"ods\",\n\t\t\"odp\",\n\t\t\"xml\",\n\t\t\"heic\",\n\t\t\"ics\",\n\t\t\"glb\",\n\t\t\"pcap\",\n\t\t\"dsf\",\n\t\t\"lnk\",\n\t\t\"alias\",\n\t\t\"voc\",\n\t\t\"ac3\",\n\t\t\"3g2\",\n\t\t\"m4b\",\n\t\t\"m4p\",\n\t\t\"m4v\",\n\t\t\"f4a\",\n\t\t\"f4b\",\n\t\t\"f4p\",\n\t\t\"f4v\",\n\t\t\"mie\",\n\t\t\"qcp\",\n\t\t\"asf\",\n\t\t\"ogv\",\n\t\t\"ogm\",\n\t\t\"oga\",\n\t\t\"spx\",\n\t\t\"ogx\",\n\t\t\"ape\",\n\t\t\"wv\",\n\t\t\"cur\",\n\t\t\"nes\",\n\t\t\"crx\",\n\t\t\"ktx\",\n\t\t\"dcm\",\n\t\t\"mpc\",\n\t\t\"arrow\",\n\t\t\"shp\",\n\t\t\"aac\",\n\t\t\"mp1\",\n\t\t\"it\",\n\t\t\"s3m\",\n\t\t\"xm\",\n\t\t\"ai\",\n\t\t\"skp\",\n\t\t\"avif\",\n\t\t\"eps\",\n\t\t\"lzh\",\n\t\t\"pgp\",\n\t\t\"asar\",\n\t\t\"stl\",\n\t\t\"chm\",\n\t\t\"3mf\",\n\t\t\"zst\",\n\t\t\"jxl\",\n\t\t\"vcf\",\n\t\t\"jls\",\n\t\t\"pst\",\n\t\t\"dwg\",\n\t\t\"parquet\",\n\t\t\"class\",\n\t\t\"arj\",\n\t\t\"cpio\",\n\t\t\"ace\",\n\t\t\"avro\",\n\t\t\"icc\",\n\t\t\"fbx\",\n\t\t\"vsdx\",\n\t\t\"vtt\",\n\t\t\"apk\",\n\t\t\"drc\",\n\t\t\"lz4\",\n\t\t\"potx\",\n\t\t\"xltx\",\n\t\t\"dotx\",\n\t\t\"xltm\",\n\t\t\"ots\",\n\t\t\"odg\",\n\t\t\"otg\",\n\t\t\"otp\",\n\t\t\"ott\",\n\t\t\"xlsm\",\n\t\t\"docm\",\n\t\t\"dotm\",\n\t\t\"potm\",\n\t\t\"pptm\",\n\t\t\"jar\"\n\t],\n\t\"dependencies\": {\n\t\t\"@tokenizer/inflate\": \"^0.2.6\",\n\t\t\"strtok3\": \"^10.0.1\",\n\t\t\"token-types\": \"^6.0.0\",\n\t\t\"uint8array-extras\": \"^1.4.0\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@tokenizer/token\": \"^0.3.0\",\n\t\t\"@types/node\": \"^22.10.5\",\n\t\t\"ava\": \"^6.0.1\",\n\t\t\"commonmark\": \"^0.31.2\",\n\t\t\"get-stream\": \"^9.0.1\",\n\t\t\"noop-stream\": \"^1.0.0\",\n\t\t\"tsd\": \"^0.31.2\",\n\t\t\"xo\": \"^0.60.0\"\n\t},\n\t\"xo\": {\n\t\t\"envs\": [\n\t\t\t\"node\",\n\t\t\t\"browser\"\n\t\t],\n\t\t\"ignores\": [\n\t\t\t\"fixture\"\n\t\t],\n\t\t\"rules\": {\n\t\t\t\"no-inner-declarations\": \"warn\",\n\t\t\t\"no-await-in-loop\": \"warn\",\n\t\t\t\"no-bitwise\": \"off\",\n\t\t\t\"@typescript-eslint/no-unsafe-assignment\": \"off\",\n\t\t\t\"unicorn/text-encoding-identifier-case\": \"off\",\n\t\t\t\"unicorn/switch-case-braces\": \"off\",\n\t\t\t\"unicorn/prefer-top-level-await\": \"off\"\n\t\t}\n\t},\n\t\"ava\": {\n\t\t\"serial\": true\n\t}\n}\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 30.4033203125,
          "content": "<h1 align=\"center\" title=\"file-type\">\n\t<img src=\"media/logo.jpg\" alt=\"file-type logo\">\n</h1>\n\n> Detect the file type of a file, stream, or data\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n\nThis package is for detecting binary-based file formats, not text-based formats like `.txt`, `.csv`, `.svg`, etc.\n\nWe accept contributions for commonly used modern file formats, not historical or obscure ones. Open an issue first for discussion.\n\n## Install\n\n```sh\nnpm install file-type\n```\n\n**This package is an ESM package. Your project needs to be ESM too. [Read more](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c). For TypeScript + CommonJS, see [`load-esm`](https://github.com/Borewit/load-esm).**\n\nIf you use it with Webpack, you need the latest Webpack version and ensure you configure it correctly for ESM.\n\n## Usage\n\n### Node.js\n\nDetermine file type from a file:\n\n```js\nimport {fileTypeFromFile} from 'file-type';\n\nconsole.log(await fileTypeFromFile('Unicorn.png'));\n//=> {ext: 'png', mime: 'image/png'}\n```\n\nDetermine file type from a Uint8Array/ArrayBuffer, which may be a portion of the beginning of a file:\n\n```js\nimport {fileTypeFromBuffer} from 'file-type';\nimport {readChunk} from 'read-chunk';\n\nconst buffer = await readChunk('Unicorn.png', {length: 4100});\n\nconsole.log(await fileTypeFromBuffer(buffer));\n//=> {ext: 'png', mime: 'image/png'}\n```\n\nDetermine file type from a stream:\n\n```js\nimport fs from 'node:fs';\nimport {fileTypeFromStream} from 'file-type';\n\nconst stream = fs.createReadStream('Unicorn.mp4');\n\nconsole.log(await fileTypeFromStream(stream));\n//=> {ext: 'mp4', mime: 'video/mp4'}\n```\n\nThe stream method can also be used to read from a remote location:\n\n```js\nimport got from 'got';\nimport {fileTypeFromStream} from 'file-type';\n\nconst url = 'https://upload.wikimedia.org/wikipedia/en/a/a9/Example.jpg';\n\nconst stream = got.stream(url);\n\nconsole.log(await fileTypeFromStream(stream));\n//=> {ext: 'jpg', mime: 'image/jpeg'}\n```\n\nAnother stream example:\n\n```js\nimport stream from 'node:stream';\nimport fs from 'node:fs';\nimport crypto from 'node:crypto';\nimport {fileTypeStream} from 'file-type';\n\nconst read = fs.createReadStream('encrypted.enc');\nconst decipher = crypto.createDecipheriv(alg, key, iv);\n\nconst streamWithFileType = await fileTypeStream(stream.pipeline(read, decipher));\n\nconsole.log(streamWithFileType.fileType);\n//=> {ext: 'mov', mime: 'video/quicktime'}\n\nconst write = fs.createWriteStream(`decrypted.${streamWithFileType.fileType.ext}`);\nstreamWithFileType.pipe(write);\n```\n\n### Browser\n\n```js\nimport {fileTypeFromStream} from 'file-type';\n\nconst url = 'https://upload.wikimedia.org/wikipedia/en/a/a9/Example.jpg';\n\nconst response = await fetch(url);\nconst fileType = await fileTypeFromStream(response.body);\n\nconsole.log(fileType);\n//=> {ext: 'jpg', mime: 'image/jpeg'}\n```\n\n## API\n\n### fileTypeFromBuffer(buffer)\n\nDetect the file type of a `Uint8Array`, or `ArrayBuffer`.\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n\nIf file access is available, it is recommended to use `fileTypeFromFile()` instead.\n\nReturns a `Promise` for an object with the detected file type:\n\n- `ext` - One of the [supported file types](#supported-file-types)\n- `mime` - The [MIME type](https://en.wikipedia.org/wiki/Internet_media_type)\n\nOr `undefined` when there is no match.\n\n#### buffer\n\nType: `Uint8Array | ArrayBuffer`\n\nA buffer representing file data. It works best if the buffer contains the entire file. It may work with a smaller portion as well.\n\n### fileTypeFromFile(filePath)\n\nDetect the file type of a file path.\n\nThis is for Node.js only.\n\nTo read from a [`File`](https://developer.mozilla.org/docs/Web/API/File), see [`fileTypeFromBlob()`](#filetypefromblobblob).\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n\nReturns a `Promise` for an object with the detected file type:\n\n- `ext` - One of the [supported file types](#supported-file-types)\n- `mime` - The [MIME type](https://en.wikipedia.org/wiki/Internet_media_type)\n\nOr `undefined` when there is no match.\n\n#### filePath\n\nType: `string`\n\nThe file path to parse.\n\n### fileTypeFromStream(stream)\n\nDetect the file type of a [web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream).\n\nIf the engine is Node.js, this may also be a [Node.js `stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable).\n\nDirect support for Node.js streams will be dropped in the future, when Node.js streams can be converted to Web streams (see [`toWeb()`](https://nodejs.org/api/stream.html#streamreadabletowebstreamreadable-options)).\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n\nReturns a `Promise` for an object with the detected file type:\n\n- `ext` - One of the [supported file types](#supported-file-types)\n- `mime` - The [MIME type](https://en.wikipedia.org/wiki/Internet_media_type)\n\nOr `undefined` when there is no match.\n\n#### stream\n\nType: [Web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) or [Node.js `stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable)\n\nA readable stream representing file data.\n\n### fileTypeFromBlob(blob)\n\nDetect the file type of a [`Blob`](https://developer.mozilla.org/docs/Web/API/Blob),\n\n> [!TIP]\n> A [`File` object](https://developer.mozilla.org/docs/Web/API/File) is a `Blob` and can be passed in here.\n\nIt will **stream** the underlying Blob.\n\nThe file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the blob.\n\nReturns a `Promise` for an object with the detected file type:\n\n- `ext` - One of the [supported file types](#supported-file-types)\n- `mime` - The [MIME type](https://en.wikipedia.org/wiki/Internet_media_type)\n\nOr `undefined` when there is no match.\n\n```js\nimport {fileTypeFromBlob} from 'file-type';\n\nconst blob = new Blob(['<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>'], {\n\ttype: 'text/plain',\n\tendings: 'native'\n});\n\nconsole.log(await fileTypeFromBlob(blob));\n//=> {ext: 'txt', mime: 'text/plain'}\n```\n\n> [!WARNING]\n> This method depends on [ReadableStreamBYOBReader](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader) which **requires Node.js  20**\n> and [may not be available in all modern browsers](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader#browser_compatibility).\n\nTo work around this limitation, you can use an alternative approach to read and process the `Blob` without relying on streaming:\n\n```js\nimport {fileTypeFromBuffer} from 'file-type';\n\nasync function readFromBlobWithoutStreaming(blob) {\n\tconst buffer = await blob.arrayBuffer();\n\treturn fileTypeFromBuffer(buffer);\n}\n```\n\n#### blob\n\nType: [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)\n\n### fileTypeFromTokenizer(tokenizer)\n\nDetect the file type from an `ITokenizer` source.\n\nThis method is used internally, but can also be used for a special \"tokenizer\" reader.\n\nA tokenizer propagates the internal read functions, allowing alternative transport mechanisms, to access files, to be implemented and used.\n\nReturns a `Promise` for an object with the detected file type:\n\n- `ext` - One of the [supported file types](#supported-file-types)\n- `mime` - The [MIME type](https://en.wikipedia.org/wiki/Internet_media_type)\n\nOr `undefined` when there is no match.\n\nAn example is [`@tokenizer/http`](https://github.com/Borewit/tokenizer-http), which requests data using [HTTP-range-requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests). A difference with a conventional stream and the [*tokenizer*](https://github.com/Borewit/strtok3#tokenizer), is that it can *ignore* (seek, fast-forward) in the stream. For example, you may only need and read the first 6 bytes, and the last 128 bytes, which may be an advantage in case reading the entire file would take longer.\n\n```js\nimport {makeTokenizer} from '@tokenizer/http';\nimport {fileTypeFromTokenizer} from 'file-type';\n\nconst audioTrackUrl = 'https://test-audio.netlify.com/Various%20Artists%20-%202009%20-%20netBloc%20Vol%2024_%20tiuqottigeloot%20%5BMP3-V2%5D/01%20-%20Diablo%20Swing%20Orchestra%20-%20Heroines.mp3';\n\nconst httpTokenizer = await makeTokenizer(audioTrackUrl);\nconst fileType = await fileTypeFromTokenizer(httpTokenizer);\n\nconsole.log(fileType);\n//=> {ext: 'mp3', mime: 'audio/mpeg'}\n```\n\nOr use [`@tokenizer/s3`](https://github.com/Borewit/tokenizer-s3) to determine the file type of a file stored on [Amazon S3](https://aws.amazon.com/s3):\n\n```js\nimport S3 from 'aws-sdk/clients/s3';\nimport {makeTokenizer} from '@tokenizer/s3';\nimport {fileTypeFromTokenizer} from 'file-type';\n\n// Initialize the S3 client\nconst s3 = new S3();\n\n// Initialize the S3 tokenizer.\nconst s3Tokenizer = await makeTokenizer(s3, {\n\tBucket: 'affectlab',\n\tKey: '1min_35sec.mp4'\n});\n\n// Figure out what kind of file it is.\nconst fileType = await fileTypeFromTokenizer(s3Tokenizer);\nconsole.log(fileType);\n```\n\nNote that only the minimum amount of data required to determine the file type is read (okay, just a bit extra to prevent too many fragmented reads).\n\n#### tokenizer\n\nType: [`ITokenizer`](https://github.com/Borewit/strtok3#tokenizer)\n\nA file source implementing the [tokenizer interface](https://github.com/Borewit/strtok3#tokenizer).\n\n### fileTypeStream(webStream, options?)\n\nReturns a `Promise` which resolves to the original readable stream argument, but with an added `fileType` property, which is an object like the one returned from `fileTypeFromFile()`.\n\nThis method can be handy to put in between a stream, but it comes with a price.\nInternally `stream()` builds up a buffer of `sampleSize` bytes, used as a sample, to determine the file type.\nThe sample size impacts the file detection resolution.\nA smaller sample size will result in lower probability of the best file type detection.\n\n**Note:** When using Node.js, a `stream.Readable` may be provided as well.\n\n#### readableStream\n\nType: [`stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable)\n\n#### options\n\nType: `object`\n\n##### sampleSize\n\nType: `number`\\\nDefault: `4100`\n\nThe sample size in bytes.\n\n#### Example\n\n```js\nimport got from 'got';\nimport {fileTypeStream} from 'file-type';\n\nconst url = 'https://upload.wikimedia.org/wikipedia/en/a/a9/Example.jpg';\n\nconst stream1 = got.stream(url);\nconst stream2 = await fileTypeStream(stream1, {sampleSize: 1024});\n\nif (stream2.fileType?.mime === 'image/jpeg') {\n\t// stream2 can be used to stream the JPEG image (from the very beginning of the stream)\n}\n```\n\n#### readableStream\n\nType: [`stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable)\n\nThe input stream.\n\n### supportedExtensions\n\nReturns a `Set<string>` of supported file extensions.\n\n### supportedMimeTypes\n\nReturns a `Set<string>` of supported MIME types.\n\n## Custom detectors\n\nA custom file type detector.\n\nDetectors can be added via the constructor options or by directly modifying `FileTypeParser#detectors`.\n\nDetectors provided through the constructor options are executed before the default detectors.\n\nCustom detectors allow for:\n- Introducing new `FileTypeResult` entries.\n- Modifying the detection behavior of existing `FileTypeResult` types.\n\n### Detector execution flow\n\nIf a detector returns `undefined`, the following rules apply:\n\n1. **No Tokenizer Interaction**: If the detector does not modify the tokenizer's position, the next detector in the sequence is executed.\n2. **Tokenizer Interaction**: If the detector modifies the tokenizer's position (`tokenizer.position` is advanced), no further detectors are executed. In this case, the file type remains `undefined`, as subsequent detectors cannot evaluate the content. This is an exceptional scenario, as it prevents any other detectors from determining the file type.\n\n### Example usage\n\nBelow is an example of a custom detector array. This can be passed to the `FileTypeParser` via the `fileTypeOptions` argument.\n\n```js\nimport {FileTypeParser} from 'file-type';\n\nconst unicornDetector = {\n\tid: 'unicorn', // May be used to recognize the detector in the detector list\n  \tasync detect(tokenizer) {\n\t\tconst unicornHeader = [85, 78, 73, 67, 79, 82, 78]; // \"UNICORN\" in ASCII decimal\n\n\t\tconst buffer = new Uint8Array(unicornHeader.length);\n\t\tawait tokenizer.peekBuffer(buffer, {length: unicornHeader.length, mayBeLess: true});\n\t\tif (unicornHeader.every((value, index) => value === buffer[index])) {\n\t\t\treturn {ext: 'unicorn', mime: 'application/unicorn'};\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n\nconst buffer = new Uint8Array([85, 78, 73, 67, 79, 82, 78]);\nconst parser = new FileTypeParser({customDetectors: [unicornDetector]});\nconst fileType = await parser.fromBuffer(buffer);\nconsole.log(fileType); // {ext: 'unicorn', mime: 'application/unicorn'}\n```\n\n```ts\n/**\n@param tokenizer - The [tokenizer](https://github.com/Borewit/strtok3#tokenizer) used to read file content.\n@param fileType - The file type detected by standard or previous custom detectors, or `undefined` if no match is found.\n@returns The detected file type, or `undefined` if no match is found.\n*/\nexport type Detector = (tokenizer: ITokenizer, fileType?: FileTypeResult) => Promise<FileTypeResult | undefined>;\n```\n\n## Abort signal\n\nSome async operations can be aborted by passing an [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) to the `FileTypeParser` constructor.\n\n```js\nimport {FileTypeParser} from 'file-type';\n\nconst abortController = new AbortController()\n\nconst parser = new FileTypeParser({abortSignal: abortController.signal});\n\nconst promise = parser.fromStream(blob.stream());\n\nabortController.abort(); // Abort file-type reading from the Blob stream.\n```\n\n## Supported file types\n\n- [`3g2`](https://en.wikipedia.org/wiki/3GP_and_3G2#3G2) - Multimedia container format defined by the 3GPP2 for 3G CDMA2000 multimedia services\n- [`3gp`](https://en.wikipedia.org/wiki/3GP_and_3G2#3GP) - Multimedia container format defined by the Third Generation Partnership Project (3GPP) for 3G UMTS multimedia services\n- [`3mf`](https://en.wikipedia.org/wiki/3D_Manufacturing_Format) - 3D Manufacturing Format\n- [`7z`](https://en.wikipedia.org/wiki/7z) - 7-Zip archive\n- [`Z`](https://fileinfo.com/extension/z) - Unix Compressed File\n- [`aac`](https://en.wikipedia.org/wiki/Advanced_Audio_Coding) - Advanced Audio Coding\n- [`ac3`](https://www.atsc.org/standard/a522012-digital-audio-compression-ac-3-e-ac-3-standard-12172012/) - ATSC A/52 Audio File\n- [`ace`](https://en.wikipedia.org/wiki/ACE_(compressed_file_format)) - ACE archive\n- [`ai`](https://en.wikipedia.org/wiki/Adobe_Illustrator_Artwork) - Adobe Illustrator Artwork\n- [`aif`](https://en.wikipedia.org/wiki/Audio_Interchange_File_Format) - Audio Interchange file\n- [`alias`](https://en.wikipedia.org/wiki/Alias_%28Mac_OS%29) - macOS Alias file\n- [`amr`](https://en.wikipedia.org/wiki/Adaptive_Multi-Rate_audio_codec) - Adaptive Multi-Rate audio codec\n- [`ape`](https://en.wikipedia.org/wiki/Monkey%27s_Audio) - Monkey's Audio\n- [`apk`](https://en.wikipedia.org/wiki/Apk_(file_format)) - Android package format\n- [`apng`](https://en.wikipedia.org/wiki/APNG) - Animated Portable Network Graphics\n- [`ar`](https://en.wikipedia.org/wiki/Ar_(Unix)) - Archive file\n- [`arj`](https://en.wikipedia.org/wiki/ARJ) - Archive file\n- [`arrow`](https://arrow.apache.org) - Columnar format for tables of data\n- [`arw`](https://en.wikipedia.org/wiki/Raw_image_format#ARW) - Sony Alpha Raw image file\n- [`asar`](https://github.com/electron/asar#format) - Archive format primarily used to enclose Electron applications\n- [`asf`](https://en.wikipedia.org/wiki/Advanced_Systems_Format) - Advanced Systems Format\n- [`avi`](https://en.wikipedia.org/wiki/Audio_Video_Interleave) - Audio Video Interleave file\n- [`avif`](https://en.wikipedia.org/wiki/AV1#AV1_Image_File_Format_(AVIF)) - AV1 Image File Format\n- [`avro`](https://en.wikipedia.org/wiki/Apache_Avro#Avro_Object_Container_File) - Object container file developed by Apache Avro\n- [`blend`](https://wiki.blender.org/index.php/Dev:Source/Architecture/File_Format) - Blender project\n- [`bmp`](https://en.wikipedia.org/wiki/BMP_file_format) - Bitmap image file\n- [`bpg`](https://bellard.org/bpg/) - Better Portable Graphics file\n- [`bz2`](https://en.wikipedia.org/wiki/Bzip2) - Archive file\n- [`cab`](https://en.wikipedia.org/wiki/Cabinet_(file_format)) - Cabinet file\n- [`cfb`](https://en.wikipedia.org/wiki/Compound_File_Binary_Format) - Compound File Binary Format\n- [`chm`](https://en.wikipedia.org/wiki/Microsoft_Compiled_HTML_Help) - Microsoft Compiled HTML Help\n- [`class`](https://en.wikipedia.org/wiki/Java_class_file) - Java class file\n- [`cpio`](https://en.wikipedia.org/wiki/Cpio) - Cpio archive\n- [`cr2`](https://fileinfo.com/extension/cr2) - Canon Raw image file (v2)\n- [`cr3`](https://fileinfo.com/extension/cr3) - Canon Raw image file (v3)\n- [`crx`](https://developer.chrome.com/extensions/crx) - Google Chrome extension\n- [`cur`](https://en.wikipedia.org/wiki/ICO_(file_format)) - Icon file\n- [`dcm`](https://en.wikipedia.org/wiki/DICOM#Data_format) - DICOM Image File\n- [`deb`](https://en.wikipedia.org/wiki/Deb_(file_format)) - Debian package\n- [`dmg`](https://en.wikipedia.org/wiki/Apple_Disk_Image) - Apple Disk Image\n- [`dng`](https://en.wikipedia.org/wiki/Digital_Negative) - Adobe Digital Negative image file\n- [`docm`](https://en.wikipedia.org/wiki/List_of_Microsoft_Office_filename_extensions) - Microsoft Word macro-enabled document\n- [`docx`](https://en.wikipedia.org/wiki/Office_Open_XML) - Microsoft Word document\n- [`dotm`](https://en.wikipedia.org/wiki/List_of_Microsoft_Office_filename_extensions) - Microsoft Word macro-enabled template\n- [`dotx`](https://en.wikipedia.org/wiki/List_of_Microsoft_Office_filename_extensions) - Microsoft Word template\n- [`drc`](https://en.wikipedia.org/wiki/Zstandard) - Google's Draco 3D Data Compression\n- [`dsf`](https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf) - Sony DSD Stream File (DSF)\n- [`dwg`](https://en.wikipedia.org/wiki/.dwg) - Autodesk CAD file\n- [`elf`](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) - Unix Executable and Linkable Format\n- [`eot`](https://en.wikipedia.org/wiki/Embedded_OpenType) - Embedded OpenType font\n- [`eps`](https://en.wikipedia.org/wiki/Encapsulated_PostScript) - Encapsulated PostScript\n- [`epub`](https://en.wikipedia.org/wiki/EPUB) - E-book file\n- [`exe`](https://en.wikipedia.org/wiki/.exe) - Executable file\n- [`f4a`](https://en.wikipedia.org/wiki/Flash_Video) - Audio-only ISO base media file format used by Adobe Flash Player\n- [`f4b`](https://en.wikipedia.org/wiki/Flash_Video) - Audiobook and podcast ISO base media file format used by Adobe Flash Player\n- [`f4p`](https://en.wikipedia.org/wiki/Flash_Video) - ISO base media file format protected by Adobe Access DRM used by Adobe Flash Player\n- [`f4v`](https://en.wikipedia.org/wiki/Flash_Video) - ISO base media file format used by Adobe Flash Player\n- [`fbx`](https://en.wikipedia.org/wiki/FBX) - Filmbox is a proprietary file format used to provide interoperability between digital content creation apps.\n- [`flac`](https://en.wikipedia.org/wiki/FLAC) - Free Lossless Audio Codec\n- [`flif`](https://en.wikipedia.org/wiki/Free_Lossless_Image_Format) - Free Lossless Image Format\n- [`flv`](https://en.wikipedia.org/wiki/Flash_Video) - Flash video\n- [`gif`](https://en.wikipedia.org/wiki/GIF) - Graphics Interchange Format\n- [`glb`](https://github.com/KhronosGroup/glTF) - GL Transmission Format\n- [`gz`](https://en.wikipedia.org/wiki/Gzip) - Archive file\n- [`heic`](https://nokiatech.github.io/heif/technical.html) - High Efficiency Image File Format\n- [`icc`](https://en.wikipedia.org/wiki/ICC_profile) - ICC Profile\n- [`icns`](https://en.wikipedia.org/wiki/Apple_Icon_Image_format) - Apple Icon image\n- [`ico`](https://en.wikipedia.org/wiki/ICO_(file_format)) - Windows icon file\n- [`ics`](https://en.wikipedia.org/wiki/ICalendar#Data_format) - iCalendar\n- [`indd`](https://en.wikipedia.org/wiki/Adobe_InDesign#File_format) - Adobe InDesign document\n- [`it`](https://wiki.openmpt.org/Manual:_Module_formats#The_Impulse_Tracker_format_.28.it.29) - Audio module format: Impulse Tracker\n- [`j2c`](https://en.wikipedia.org/wiki/JPEG_2000) - JPEG 2000\n- [`jar`](https://en.wikipedia.org/wiki/JAR_(file_format)) - Java archive\n- [`jls`](https://en.wikipedia.org/wiki/Lossless_JPEG#JPEG-LS) - Lossless/near-lossless compression standard for continuous-tone images\n- [`jp2`](https://en.wikipedia.org/wiki/JPEG_2000) - JPEG 2000\n- [`jpg`](https://en.wikipedia.org/wiki/JPEG) - Joint Photographic Experts Group image\n- [`jpm`](https://en.wikipedia.org/wiki/JPEG_2000) - JPEG 2000\n- [`jpx`](https://en.wikipedia.org/wiki/JPEG_2000) - JPEG 2000\n- [`jxl`](https://en.wikipedia.org/wiki/JPEG_XL) - JPEG XL image format\n- [`jxr`](https://en.wikipedia.org/wiki/JPEG_XR) - Joint Photographic Experts Group extended range\n- [`ktx`](https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/) - OpenGL and OpenGL ES textures\n- [`lnk`](https://en.wikipedia.org/wiki/Shortcut_%28computing%29#Microsoft_Windows) - Microsoft Windows file shortcut\n- [`lz`](https://en.wikipedia.org/wiki/Lzip) - Archive file\n- [`lz4`](https://en.wikipedia.org/wiki/LZ4_(compression_algorithm)) - Compressed archive created by one of a variety of LZ4 compression utilities\n- [`lzh`](https://en.wikipedia.org/wiki/LHA_(file_format)) - LZH archive\n- [`m4a`](https://en.wikipedia.org/wiki/M4A) - Audio-only MPEG-4 files\n- [`m4b`](https://en.wikipedia.org/wiki/M4B) - Audiobook and podcast MPEG-4 files, which also contain metadata including chapter markers, images, and hyperlinks\n- [`m4p`](https://en.wikipedia.org/wiki/MPEG-4_Part_14#Filename_extensions) - MPEG-4 files with audio streams encrypted by FairPlay Digital Rights Management as were sold through the iTunes Store\n- [`m4v`](https://en.wikipedia.org/wiki/M4V) - Video container format developed by Apple, which is very similar to the MP4 format\n- [`macho`](https://en.wikipedia.org/wiki/Mach-O) - Mach-O binary format\n- [`mid`](https://en.wikipedia.org/wiki/MIDI) - Musical Instrument Digital Interface file\n- [`mie`](https://en.wikipedia.org/wiki/Sidecar_file) - Dedicated meta information format which supports storage of binary as well as textual meta information\n- [`mj2`](https://en.wikipedia.org/wiki/Motion_JPEG_2000) - Motion JPEG 2000\n- [`mkv`](https://en.wikipedia.org/wiki/Matroska) - Matroska video file\n- [`mobi`](https://en.wikipedia.org/wiki/Mobipocket) - Mobipocket\n- [`mov`](https://en.wikipedia.org/wiki/QuickTime_File_Format) - QuickTime video file\n- [`mp1`](https://en.wikipedia.org/wiki/MPEG-1_Audio_Layer_I) - MPEG-1 Audio Layer I\n- [`mp2`](https://en.wikipedia.org/wiki/MPEG-1_Audio_Layer_II) - MPEG-1 Audio Layer II\n- [`mp3`](https://en.wikipedia.org/wiki/MP3) - Audio file\n- [`mp4`](https://en.wikipedia.org/wiki/MPEG-4_Part_14#Filename_extensions) - MPEG-4 Part 14 video file\n- [`mpc`](https://en.wikipedia.org/wiki/Musepack) - Musepack (SV7 & SV8)\n- [`mpg`](https://en.wikipedia.org/wiki/MPEG-1) - MPEG-1 file\n- [`mts`](https://en.wikipedia.org/wiki/.m2ts) - MPEG-2 Transport Stream, both raw and Blu-ray Disc Audio-Video (BDAV) versions\n- [`mxf`](https://en.wikipedia.org/wiki/Material_Exchange_Format) - Material Exchange Format\n- [`nef`](https://www.nikonusa.com/en/learn-and-explore/a/products-and-innovation/nikon-electronic-format-nef.html) - Nikon Electronic Format image file\n- [`nes`](https://fileinfo.com/extension/nes) - Nintendo NES ROM\n- [`odg`](https://en.wikipedia.org/wiki/OpenDocument) - OpenDocument for drawing\n- [`odp`](https://en.wikipedia.org/wiki/OpenDocument) - OpenDocument for presentations\n- [`ods`](https://en.wikipedia.org/wiki/OpenDocument) - OpenDocument for spreadsheets\n- [`odt`](https://en.wikipedia.org/wiki/OpenDocument) - OpenDocument for word processing\n- [`oga`](https://en.wikipedia.org/wiki/Ogg) - Audio file\n- [`ogg`](https://en.wikipedia.org/wiki/Ogg) - Audio file\n- [`ogm`](https://en.wikipedia.org/wiki/Ogg) - Audio file\n- [`ogv`](https://en.wikipedia.org/wiki/Ogg) - Audio file\n- [`ogx`](https://en.wikipedia.org/wiki/Ogg) - Audio file\n- [`opus`](https://en.wikipedia.org/wiki/Opus_(audio_format)) - Audio file\n- [`orf`](https://en.wikipedia.org/wiki/ORF_format) - Olympus Raw image file\n- [`otf`](https://en.wikipedia.org/wiki/OpenType) - OpenType font\n- [`otg`](https://en.wikipedia.org/wiki/OpenDocument_technical_specification#Templates) - OpenDocument template for drawing\n- [`otp`](https://en.wikipedia.org/wiki/OpenDocument_technical_specification#Templates) - OpenDocument template for presentations\n- [`ots`](https://en.wikipedia.org/wiki/OpenDocument_technical_specification#Templates) - OpenDocument template for spreadsheets\n- [`ott`](https://en.wikipedia.org/wiki/OpenDocument_technical_specification#Templates) - OpenDocument template for word processing\n- [`parquet`](https://en.wikipedia.org/wiki/Apache_Parquet) - Apache Parquet\n- [`pcap`](https://wiki.wireshark.org/Development/LibpcapFileFormat) - Libpcap File Format\n- [`pdf`](https://en.wikipedia.org/wiki/Portable_Document_Format) - Portable Document Format\n- [`pgp`](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) - Pretty Good Privacy\n- [`png`](https://en.wikipedia.org/wiki/Portable_Network_Graphics) - Portable Network Graphics\n- [`potm`](https://en.wikipedia.org/wiki/List_of_Microsoft_Office_filename_extensions) - Microsoft PowerPoint macro-enabled template\n- [`potx`](https://en.wikipedia.org/wiki/List_of_Microsoft_Office_filename_extensions) - Microsoft PowerPoint template\n- [`pptm`](https://en.wikipedia.org/wiki/List_of_Microsoft_Office_filename_extensions) - Microsoft PowerPoint macro-enabled document\n- [`pptx`](https://en.wikipedia.org/wiki/Office_Open_XML) - Microsoft PowerPoint document\n- [`ps`](https://en.wikipedia.org/wiki/Postscript) - Postscript\n- [`psd`](https://en.wikipedia.org/wiki/Adobe_Photoshop#File_format) - Adobe Photoshop document\n- [`pst`](https://en.wikipedia.org/wiki/Personal_Storage_Table) - Personal Storage Table file\n- [`qcp`](https://en.wikipedia.org/wiki/QCP) - Tagged and chunked data\n- [`raf`](https://en.wikipedia.org/wiki/Raw_image_format) - Fujifilm RAW image file\n- [`rar`](https://en.wikipedia.org/wiki/RAR_(file_format)) - Archive file\n- [`rpm`](https://fileinfo.com/extension/rpm) - Red Hat Package Manager file\n- [`rtf`](https://en.wikipedia.org/wiki/Rich_Text_Format) - Rich Text Format\n- [`rw2`](https://en.wikipedia.org/wiki/Raw_image_format) - Panasonic RAW image file\n- [`s3m`](https://wiki.openmpt.org/Manual:_Module_formats#The_ScreamTracker_3_format_.28.s3m.29) - Audio module format: ScreamTracker 3\n- [`shp`](https://en.wikipedia.org/wiki/Shapefile) - Geospatial vector data format\n- [`skp`](https://en.wikipedia.org/wiki/SketchUp) - SketchUp\n- [`spx`](https://en.wikipedia.org/wiki/Ogg) - Audio file\n- [`sqlite`](https://www.sqlite.org/fileformat2.html) - SQLite file\n- [`stl`](https://en.wikipedia.org/wiki/STL_(file_format)) - Standard Tesselated Geometry File Format (ASCII only)\n- [`swf`](https://en.wikipedia.org/wiki/SWF) - Adobe Flash Player file\n- [`tar`](https://en.wikipedia.org/wiki/Tar_(computing)#File_format) - Tarball archive file\n- [`tif`](https://en.wikipedia.org/wiki/Tagged_Image_File_Format) - Tagged Image file\n- [`ttf`](https://en.wikipedia.org/wiki/TrueType) - TrueType font\n- [`vcf`](https://en.wikipedia.org/wiki/VCard) - vCard\n- [`voc`](https://wiki.multimedia.cx/index.php/Creative_Voice) - Creative Voice File\n- [`vsdx`](https://en.wikipedia.org/wiki/Microsoft_Visio) - Microsoft Visio File\n- [`vtt`](https://en.wikipedia.org/wiki/WebVTT) - WebVTT File (for video captions)\n- [`wasm`](https://en.wikipedia.org/wiki/WebAssembly) - WebAssembly intermediate compiled format\n- [`wav`](https://en.wikipedia.org/wiki/WAV) - Waveform Audio file\n- [`webm`](https://en.wikipedia.org/wiki/WebM) - Web video file\n- [`webp`](https://en.wikipedia.org/wiki/WebP) - Web Picture format\n- [`woff`](https://en.wikipedia.org/wiki/Web_Open_Font_Format) - Web Open Font Format\n- [`woff2`](https://en.wikipedia.org/wiki/Web_Open_Font_Format) - Web Open Font Format\n- [`wv`](https://en.wikipedia.org/wiki/WavPack) - WavPack\n- [`xcf`](https://en.wikipedia.org/wiki/XCF_(file_format)) - eXperimental Computing Facility\n- [`xlsm`](https://en.wikipedia.org/wiki/List_of_Microsoft_Office_filename_extensions) - Microsoft Excel macro-enabled document\n- [`xlsx`](https://en.wikipedia.org/wiki/Office_Open_XML) - Microsoft Excel document\n- [`xltm`](https://en.wikipedia.org/wiki/List_of_Microsoft_Office_filename_extensions) - Microsoft Excel macro-enabled template\n- [`xltx`](https://en.wikipedia.org/wiki/List_of_Microsoft_Office_filename_extensions) - Microsoft Excel template\n- [`xm`](https://wiki.openmpt.org/Manual:_Module_formats#The_FastTracker_2_format_.28.xm.29) - Audio module format: FastTracker 2\n- [`xml`](https://en.wikipedia.org/wiki/XML) - eXtensible Markup Language\n- [`xpi`](https://en.wikipedia.org/wiki/XPInstall) - XPInstall file\n- [`xz`](https://en.wikipedia.org/wiki/Xz) - Compressed file\n- [`zip`](https://en.wikipedia.org/wiki/Zip_(file_format)) - Archive file\n- [`zst`](https://en.wikipedia.org/wiki/Zstandard) - Archive file\n\n*[Pull requests](.github/pull_request_template.md) are welcome for additional commonly used file types.*\n\nThe following file types will not be accepted:\n- [MS-CFB: Microsoft Compound File Binary File Format based formats](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cfb/53989ce4-7b05-4f8d-829b-d08d6148375b), too old and difficult to parse:\n\t- `.doc` - Microsoft Word 97-2003 Document\n\t- `.xls` - Microsoft Excel 97-2003 Document\n\t- `.ppt` - Microsoft PowerPoint97-2003 Document\n\t- `.msi` - Microsoft Windows Installer\n- `.csv` - [Reason.](https://github.com/sindresorhus/file-type/issues/264#issuecomment-568439196)\n- `.svg` - Detecting it requires a full-blown parser. Check out [`is-svg`](https://github.com/sindresorhus/is-svg) for something that mostly works.\n\n#### tokenizer\n\nType: [`ITokenizer`](https://github.com/Borewit/strtok3#tokenizer)\n\nUsable as source of the examined file.\n\n#### fileType\n\nType: `FileTypeResult`\n\nAn object having an `ext` (extension) and `mime` (mime type) property.\n\nDetected by the standard detections or a previous custom detection. Undefined if no matching fileTypeResult could be found.\n\n## Related\n\n- [file-type-cli](https://github.com/sindresorhus/file-type-cli) - CLI for this module\n- [image-dimensions](https://github.com/sindresorhus/image-dimensions) - Get the dimensions of an image\n\n## Maintainers\n\n- [Sindre Sorhus](https://github.com/sindresorhus)\n- [Borewit](https://github.com/Borewit)\n"
        },
        {
          "name": "supported.js",
          "type": "blob",
          "size": 5.8076171875,
          "content": "export const extensions = [\n\t'jpg',\n\t'png',\n\t'apng',\n\t'gif',\n\t'webp',\n\t'flif',\n\t'xcf',\n\t'cr2',\n\t'cr3',\n\t'orf',\n\t'arw',\n\t'dng',\n\t'nef',\n\t'rw2',\n\t'raf',\n\t'tif',\n\t'bmp',\n\t'icns',\n\t'jxr',\n\t'psd',\n\t'indd',\n\t'zip',\n\t'tar',\n\t'rar',\n\t'gz',\n\t'bz2',\n\t'7z',\n\t'dmg',\n\t'mp4',\n\t'mid',\n\t'mkv',\n\t'webm',\n\t'mov',\n\t'avi',\n\t'mpg',\n\t'mp2',\n\t'mp3',\n\t'm4a',\n\t'oga',\n\t'ogg',\n\t'ogv',\n\t'opus',\n\t'flac',\n\t'wav',\n\t'spx',\n\t'amr',\n\t'pdf',\n\t'epub',\n\t'elf',\n\t'macho',\n\t'exe',\n\t'swf',\n\t'rtf',\n\t'wasm',\n\t'woff',\n\t'woff2',\n\t'eot',\n\t'ttf',\n\t'otf',\n\t'ico',\n\t'flv',\n\t'ps',\n\t'xz',\n\t'sqlite',\n\t'nes',\n\t'crx',\n\t'xpi',\n\t'cab',\n\t'deb',\n\t'ar',\n\t'rpm',\n\t'Z',\n\t'lz',\n\t'cfb',\n\t'mxf',\n\t'mts',\n\t'blend',\n\t'bpg',\n\t'docx',\n\t'pptx',\n\t'xlsx',\n\t'3gp',\n\t'3g2',\n\t'j2c',\n\t'jp2',\n\t'jpm',\n\t'jpx',\n\t'mj2',\n\t'aif',\n\t'qcp',\n\t'odt',\n\t'ods',\n\t'odp',\n\t'xml',\n\t'mobi',\n\t'heic',\n\t'cur',\n\t'ktx',\n\t'ape',\n\t'wv',\n\t'dcm',\n\t'ics',\n\t'glb',\n\t'pcap',\n\t'dsf',\n\t'lnk',\n\t'alias',\n\t'voc',\n\t'ac3',\n\t'm4v',\n\t'm4p',\n\t'm4b',\n\t'f4v',\n\t'f4p',\n\t'f4b',\n\t'f4a',\n\t'mie',\n\t'asf',\n\t'ogm',\n\t'ogx',\n\t'mpc',\n\t'arrow',\n\t'shp',\n\t'aac',\n\t'mp1',\n\t'it',\n\t's3m',\n\t'xm',\n\t'ai',\n\t'skp',\n\t'avif',\n\t'eps',\n\t'lzh',\n\t'pgp',\n\t'asar',\n\t'stl',\n\t'chm',\n\t'3mf',\n\t'zst',\n\t'jxl',\n\t'vcf',\n\t'jls',\n\t'pst',\n\t'dwg',\n\t'parquet',\n\t'class',\n\t'arj',\n\t'cpio',\n\t'ace',\n\t'avro',\n\t'icc',\n\t'fbx',\n\t'vsdx',\n\t'vtt',\n\t'apk',\n\t'drc',\n\t'lz4',\n\t'potx',\n\t'xltx',\n\t'dotx',\n\t'xltm',\n\t'ott',\n\t'ots',\n\t'otp',\n\t'odg',\n\t'otg',\n\t'xlsm',\n\t'docm',\n\t'dotm',\n\t'potm',\n\t'pptm',\n\t'jar',\n];\n\nexport const mimeTypes = [\n\t'image/jpeg',\n\t'image/png',\n\t'image/gif',\n\t'image/webp',\n\t'image/flif',\n\t'image/x-xcf',\n\t'image/x-canon-cr2',\n\t'image/x-canon-cr3',\n\t'image/tiff',\n\t'image/bmp',\n\t'image/vnd.ms-photo',\n\t'image/vnd.adobe.photoshop',\n\t'application/x-indesign',\n\t'application/epub+zip',\n\t'application/x-xpinstall',\n\t'application/vnd.oasis.opendocument.text',\n\t'application/vnd.oasis.opendocument.spreadsheet',\n\t'application/vnd.oasis.opendocument.presentation',\n\t'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\t'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n\t'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\t'application/zip',\n\t'application/x-tar',\n\t'application/x-rar-compressed',\n\t'application/gzip',\n\t'application/x-bzip2',\n\t'application/x-7z-compressed',\n\t'application/x-apple-diskimage',\n\t'application/x-apache-arrow',\n\t'video/mp4',\n\t'audio/midi',\n\t'video/x-matroska',\n\t'video/webm',\n\t'video/quicktime',\n\t'video/vnd.avi',\n\t'audio/wav',\n\t'audio/qcelp',\n\t'audio/x-ms-asf',\n\t'video/x-ms-asf',\n\t'application/vnd.ms-asf',\n\t'video/mpeg',\n\t'video/3gpp',\n\t'audio/mpeg',\n\t'audio/mp4', // RFC 4337\n\t'video/ogg',\n\t'audio/ogg',\n\t'audio/ogg; codecs=opus',\n\t'application/ogg',\n\t'audio/x-flac',\n\t'audio/ape',\n\t'audio/wavpack',\n\t'audio/amr',\n\t'application/pdf',\n\t'application/x-elf',\n\t'application/x-mach-binary',\n\t'application/x-msdownload',\n\t'application/x-shockwave-flash',\n\t'application/rtf',\n\t'application/wasm',\n\t'font/woff',\n\t'font/woff2',\n\t'application/vnd.ms-fontobject',\n\t'font/ttf',\n\t'font/otf',\n\t'image/x-icon',\n\t'video/x-flv',\n\t'application/postscript',\n\t'application/eps',\n\t'application/x-xz',\n\t'application/x-sqlite3',\n\t'application/x-nintendo-nes-rom',\n\t'application/x-google-chrome-extension',\n\t'application/vnd.ms-cab-compressed',\n\t'application/x-deb',\n\t'application/x-unix-archive',\n\t'application/x-rpm',\n\t'application/x-compress',\n\t'application/x-lzip',\n\t'application/x-cfb',\n\t'application/x-mie',\n\t'application/mxf',\n\t'video/mp2t',\n\t'application/x-blender',\n\t'image/bpg',\n\t'image/j2c',\n\t'image/jp2',\n\t'image/jpx',\n\t'image/jpm',\n\t'image/mj2',\n\t'audio/aiff',\n\t'application/xml',\n\t'application/x-mobipocket-ebook',\n\t'image/heif',\n\t'image/heif-sequence',\n\t'image/heic',\n\t'image/heic-sequence',\n\t'image/icns',\n\t'image/ktx',\n\t'application/dicom',\n\t'audio/x-musepack',\n\t'text/calendar',\n\t'text/vcard',\n\t'text/vtt',\n\t'model/gltf-binary',\n\t'application/vnd.tcpdump.pcap',\n\t'audio/x-dsf', // Non-standard\n\t'application/x.ms.shortcut', // Invented by us\n\t'application/x.apple.alias', // Invented by us\n\t'audio/x-voc',\n\t'audio/vnd.dolby.dd-raw',\n\t'audio/x-m4a',\n\t'image/apng',\n\t'image/x-olympus-orf',\n\t'image/x-sony-arw',\n\t'image/x-adobe-dng',\n\t'image/x-nikon-nef',\n\t'image/x-panasonic-rw2',\n\t'image/x-fujifilm-raf',\n\t'video/x-m4v',\n\t'video/3gpp2',\n\t'application/x-esri-shape',\n\t'audio/aac',\n\t'audio/x-it',\n\t'audio/x-s3m',\n\t'audio/x-xm',\n\t'video/MP1S',\n\t'video/MP2P',\n\t'application/vnd.sketchup.skp',\n\t'image/avif',\n\t'application/x-lzh-compressed',\n\t'application/pgp-encrypted',\n\t'application/x-asar',\n\t'model/stl',\n\t'application/vnd.ms-htmlhelp',\n\t'model/3mf',\n\t'image/jxl',\n\t'application/zstd',\n\t'image/jls',\n\t'application/vnd.ms-outlook',\n\t'image/vnd.dwg',\n\t'application/x-parquet',\n\t'application/java-vm',\n\t'application/x-arj',\n\t'application/x-cpio',\n\t'application/x-ace-compressed',\n\t'application/avro',\n\t'application/vnd.iccprofile',\n\t'application/x.autodesk.fbx', // Invented by us\n\t'application/vnd.visio',\n\t'application/vnd.android.package-archive',\n\t'application/vnd.google.draco', // Invented by us\n\t'application/x-lz4', // Invented by us\n\t'application/vnd.openxmlformats-officedocument.presentationml.template',\n\t'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n\t'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n\t'application/vnd.ms-excel.template.macroenabled.12',\n\t'application/vnd.oasis.opendocument.text-template',\n\t'application/vnd.oasis.opendocument.spreadsheet-template',\n\t'application/vnd.oasis.opendocument.presentation-template',\n\t'application/vnd.oasis.opendocument.graphics',\n\t'application/vnd.oasis.opendocument.graphics-template',\n\t'application/vnd.ms-excel.sheet.macroEnabled.12',\n\t'application/vnd.ms-word.document.macroEnabled.12',\n\t'application/vnd.ms-word.template.macroEnabled.12',\n\t'application/vnd.ms-powerpoint.template.macroEnabled.12',\n\t'application/vnd.ms-powerpoint.presentation.macroEnabled.12',\n\t'application/java-archive',\n];\n"
        },
        {
          "name": "test.js",
          "type": "blob",
          "size": 24.47265625,
          "content": "import process from 'node:process';\nimport path from 'node:path';\nimport {fileURLToPath} from 'node:url';\nimport fs from 'node:fs';\nimport {readFile} from 'node:fs/promises';\nimport stream from 'node:stream';\nimport test from 'ava';\nimport {readableNoopStream} from 'noop-stream';\nimport {Parser as ReadmeParser} from 'commonmark';\nimport * as strtok3 from 'strtok3/core';\nimport {areUint8ArraysEqual} from 'uint8array-extras';\nimport {getStreamAsArrayBuffer} from 'get-stream';\nimport {\n\tfileTypeFromBuffer,\n\tfileTypeFromStream as fileTypeNodeFromStream,\n\tfileTypeFromFile,\n\tfileTypeFromBlob,\n\tfileTypeStream,\n\tsupportedExtensions,\n\tsupportedMimeTypes,\n\tFileTypeParser,\n} from './index.js';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\nconst missingTests = new Set([\n\t'mpc',\n]);\n\nconst [nodeMajorVersion] = process.versions.node.split('.').map(Number);\nconst nodeVersionSupportingByteBlobStream = 20;\n\nconst types = [...supportedExtensions].filter(extension => !missingTests.has(extension));\n\n// Define an entry here only if the fixture has a different\n// name than `fixture` or if you want multiple fixtures\nconst names = {\n\taac: [\n\t\t'fixture-adts-mpeg2',\n\t\t'fixture-adts-mpeg4',\n\t\t'fixture-adts-mpeg4-2',\n\t\t'fixture-id3v2',\n\t],\n\tasar: [\n\t\t'fixture',\n\t\t'fixture2',\n\t],\n\tarw: [\n\t\t'fixture-sony-zv-e10',\n\t],\n\tcr3: [\n\t\t'fixture',\n\t],\n\tdng: [\n\t\t'fixture-Leica-M10',\n\t],\n\tdrc: [\n\t\t'fixture-cube_pc',\n\t],\n\tepub: [\n\t\t'fixture',\n\t\t'fixture-crlf',\n\t],\n\tnef: [\n\t\t'fixture',\n\t\t'fixture2',\n\t\t'fixture3',\n\t\t'fixture4',\n\t],\n\t'3gp': [\n\t\t'fixture',\n\t\t'fixture2',\n\t],\n\twoff2: [\n\t\t'fixture',\n\t\t'fixture-otto',\n\t],\n\twoff: [\n\t\t'fixture',\n\t\t'fixture-otto',\n\t],\n\teot: [\n\t\t'fixture',\n\t\t'fixture-0x20001',\n\t],\n\tmov: [\n\t\t'fixture',\n\t\t'fixture-mjpeg',\n\t\t'fixture-moov',\n\t],\n\tmp2: [\n\t\t'fixture',\n\t\t'fixture-mpa',\n\t],\n\tmp3: [\n\t\t'fixture',\n\t\t'fixture-mp2l3',\n\t\t'fixture-ffe3',\n\t],\n\tmp4: [\n\t\t'fixture-imovie',\n\t\t'fixture-isom',\n\t\t'fixture-isomv2',\n\t\t'fixture-mp4v2',\n\t\t'fixture-dash',\n\t],\n\tmts: [\n\t\t'fixture-raw',\n\t\t'fixture-bdav',\n\t],\n\ttif: [\n\t\t'fixture-big-endian',\n\t\t'fixture-little-endian',\n\t\t'fixture-bali',\n\t],\n\tgz: [\n\t\t'fixture.tar',\n\t],\n\txz: [\n\t\t'fixture.tar',\n\t],\n\tlz: [\n\t\t'fixture.tar',\n\t],\n\tZ: [\n\t\t'fixture.tar',\n\t],\n\tzst: [\n\t\t'fixture.tar',\n\t],\n\tmkv: [\n\t\t'fixture',\n\t\t'fixture2',\n\t],\n\tmpg: [\n\t\t'fixture',\n\t\t'fixture2',\n\t\t'fixture.ps',\n\t\t'fixture.sub',\n\t],\n\theic: [\n\t\t'fixture-mif1',\n\t\t'fixture-msf1',\n\t\t'fixture-heic',\n\t],\n\tape: [\n\t\t'fixture-monkeysaudio',\n\t],\n\tmpc: [\n\t\t'fixture-sv7',\n\t\t'fixture-sv8',\n\t],\n\tpcap: [\n\t\t'fixture-big-endian',\n\t\t'fixture-little-endian',\n\t],\n\tpng: [\n\t\t'fixture',\n\t\t'fixture-itxt',\n\t],\n\ttar: [\n\t\t'fixture',\n\t\t'fixture-v7',\n\t\t'fixture-spaces',\n\t],\n\tmie: [\n\t\t'fixture-big-endian',\n\t\t'fixture-little-endian',\n\t],\n\tm4a: [\n\t\t'fixture-babys-songbook.m4b', // Actually it's an `.m4b`\n\t],\n\tm4v: [\n\t\t'fixture',\n\t\t'fixture-2', // Previously named as `fixture.mp4`\n\t],\n\tflac: [\n\t\t'fixture',\n\t\t'fixture-id3v2', // FLAC prefixed with ID3v2 header\n\t],\n\tdocx: [\n\t\t'fixture',\n\t\t'fixture2',\n\t\t'fixture-office365',\n\t],\n\tpptx: [\n\t\t'fixture',\n\t\t'fixture2',\n\t\t'fixture-office365',\n\t],\n\txlsx: [\n\t\t'fixture',\n\t\t'fixture2',\n\t\t'fixture-office365',\n\t],\n\togx: [\n\t\t'fixture-unknown-ogg', // Manipulated fixture to unrecognized Ogg based file\n\t],\n\tavif: [\n\t\t'fixture-yuv420-8bit', // Multiple bit-depths and/or subsamplings\n\t\t'fixture-sequence',\n\t],\n\teps: [\n\t\t'fixture',\n\t\t'fixture2',\n\t],\n\tcfb: [\n\t\t'fixture.msi',\n\t\t'fixture.xls',\n\t\t'fixture.doc',\n\t\t'fixture.ppt',\n\t\t'fixture-2.doc',\n\t],\n\tasf: [\n\t\t'fixture',\n\t\t'fixture.wma',\n\t\t'fixture.wmv',\n\t],\n\tai: [\n\t\t'fixture-normal', // Normal AI\n\t\t'fixture-without-pdf-compatibility', // AI without the PDF compatibility (cannot be opened by PDF viewers I guess)\n\t],\n\tjxl: [\n\t\t'fixture', // Image data stored within JXL container\n\t\t'fixture2', // Bare image data with no container\n\t],\n\tpdf: [\n\t\t'fixture',\n\t\t'fixture-adobe-illustrator', // PDF saved from Adobe Illustrator, using the default \"[Illustrator Default]\" preset\n\t\t'fixture-smallest', // PDF saved from Adobe Illustrator, using the preset \"smallest PDF\"\n\t\t'fixture-fast-web', // PDF saved from Adobe Illustrator, using the default \"[Illustrator Default\"] preset, but enabling \"Optimize for Fast Web View\"\n\t\t'fixture-printed', // PDF printed from Adobe Illustrator, but with a PDF printer.\n\t\t'fixture-minimal', // PDF written to be as small as the spec allows\n\t],\n\twebm: [\n\t\t'fixture-null', // EBML DocType with trailing null character\n\t],\n\txml: [\n\t\t'fixture',\n\t\t'fixture-utf8-bom', // UTF-8 with BOM\n\t\t'fixture-utf16-be-bom', // UTF-16 little endian encoded XML, with BOM\n\t\t'fixture-utf16-le-bom', // UTF-16 big endian encoded XML, with BOM\n\t],\n\tjls: [\n\t\t'fixture-normal',\n\t\t'fixture-hp1',\n\t\t'fixture-hp2',\n\t\t'fixture-hp3',\n\t],\n\tpst: [\n\t\t'fixture-sample',\n\t],\n\tdwg: [\n\t\t'fixture-line-weights',\n\t],\n\tj2c: [\n\t\t'fixture',\n\t],\n\tcpio: [\n\t\t'fixture-bin',\n\t\t'fixture-ascii',\n\t],\n\tvsdx: [\n\t\t'fixture-vsdx',\n\t\t'fixture-vstx',\n\t],\n\tvtt: [\n\t\t'fixture-vtt-linebreak',\n\t\t'fixture-vtt-space',\n\t\t'fixture-vtt-tab',\n\t\t'fixture-vtt-eof',\n\t],\n\tlz4: [\n\t\t'fixture',\n\t],\n};\n\n// Define an entry here only if the file type has potential\n// for false-positives\nconst falsePositives = {\n\tpng: [\n\t\t'fixture-corrupt',\n\t],\n};\n\n// Known failing fixture\nconst failingFixture = new Set([\n\t'fixture-password-protected', // .xls, Excel / MS-OSHARED / Compound-File-Binary-Format\n]);\n\nasync function checkBufferLike(t, type, bufferLike) {\n\tconst {ext, mime} = await fileTypeFromBuffer(bufferLike) ?? {};\n\tt.is(ext, type);\n\tt.is(typeof mime, 'string');\n}\n\nasync function checkBlobLike(t, type, bufferLike) {\n\tconst blob = new Blob([bufferLike]);\n\tconst {ext, mime} = await fileTypeFromBlob(blob) ?? {};\n\tt.is(ext, type);\n\tt.is(typeof mime, 'string');\n}\n\nasync function checkFile(t, type, filePath) {\n\tconst {ext, mime} = await fileTypeFromFile(filePath) ?? {};\n\tt.is(ext, type);\n\tt.is(typeof mime, 'string');\n}\n\nasync function testFromFile(t, extension, name) {\n\tconst file = path.join(__dirname, 'fixture', `${(name ?? 'fixture')}.${extension}`);\n\treturn checkFile(t, extension, file);\n}\n\nasync function testFromBuffer(t, extension, name) {\n\tconst fixtureName = `${(name ?? 'fixture')}.${extension}`;\n\n\tconst file = path.join(__dirname, 'fixture', fixtureName);\n\tconst chunk = fs.readFileSync(file);\n\tawait checkBufferLike(t, extension, chunk);\n\tawait checkBufferLike(t, extension, new Uint8Array(chunk));\n\tawait checkBufferLike(t, extension, chunk.buffer.slice(chunk.byteOffset, chunk.byteOffset + chunk.byteLength));\n}\n\nasync function testFromBlob(t, extension, name) {\n\tconst fixtureName = `${(name ?? 'fixture')}.${extension}`;\n\n\tconst file = path.join(__dirname, 'fixture', fixtureName);\n\tconst chunk = fs.readFileSync(file);\n\tawait checkBlobLike(t, extension, chunk);\n}\n\nasync function testFalsePositive(t, extension, name) {\n\tconst file = path.join(__dirname, 'fixture', `${name}.${extension}`);\n\n\tawait t.is(await fileTypeFromFile(file), undefined);\n\n\tconst chunk = fs.readFileSync(file);\n\tt.is(await fileTypeFromBuffer(chunk), undefined);\n\tt.is(await fileTypeFromBuffer(new Uint8Array(chunk)), undefined);\n\tt.is(await fileTypeFromBuffer(chunk.buffer), undefined);\n}\n\nasync function testFileNodeFromStream(t, extension, name) {\n\tconst filename = `${(name ?? 'fixture')}.${extension}`;\n\tconst file = path.join(__dirname, 'fixture', filename);\n\tconst fileType = await fileTypeNodeFromStream(fs.createReadStream(file));\n\n\tt.truthy(fileType, `identify ${filename}`);\n\tt.is(fileType.ext, extension, 'fileType.ext');\n\tt.is(typeof fileType.mime, 'string', 'fileType.mime');\n}\n\nasync function getStreamAsUint8Array(stream) {\n\treturn new Uint8Array(await getStreamAsArrayBuffer(stream));\n}\n\nasync function testStreamWithNodeStream(t, extension, name) {\n\tconst fixtureName = `${(name ?? 'fixture')}.${extension}`;\n\tconst file = path.join(__dirname, 'fixture', fixtureName);\n\n\tconst readableStream = await fileTypeStream(fs.createReadStream(file));\n\tconst fileStream = fs.createReadStream(file);\n\n\tconst [bufferA, bufferB] = await Promise.all([getStreamAsUint8Array(readableStream), getStreamAsUint8Array(fileStream)]);\n\n\tt.true(areUint8ArraysEqual(bufferA, bufferB));\n}\n\nasync function testStreamWithWebStream(t, extension, name) {\n\tconst fixtureName = `${(name ?? 'fixture')}.${extension}`;\n\tconst file = path.join(__dirname, 'fixture', fixtureName);\n\t// Read the file into a buffer\n\tconst fileBuffer = await readFile(file);\n\t// Create a Blob from the buffer\n\tconst blob = new Blob([fileBuffer]);\n\tconst webStream = await fileTypeStream(blob.stream());\n\tt.false(webStream.locked);\n\tconst webStreamResult = await getStreamAsUint8Array(webStream);\n\tt.false(webStream.locked, 'Ensure web-stream is released');\n\tt.true(areUint8ArraysEqual(fileBuffer, webStreamResult));\n}\n\ntest('Test suite must be able to detect Node.js major version', t => {\n\tt.is(typeof nodeMajorVersion, 'number', 'Detected Node.js major version should be a number');\n});\n\nlet i = 0;\nfor (const type of types) {\n\tif (Object.hasOwn(names, type)) {\n\t\tfor (const name of names[type]) {\n\t\t\tconst fixtureName = `${name}.${type}`;\n\t\t\tconst _test = failingFixture.has(fixtureName) ? test.failing : test;\n\n\t\t\t_test(`${name}.${type} ${i++} .fileTypeFromFile() method - same fileType`, testFromFile, type, name);\n\t\t\t_test(`${name}.${type} ${i++} .fileTypeFromBuffer() method - same fileType`, testFromBuffer, type, name);\n\t\t\tif (nodeMajorVersion >= nodeVersionSupportingByteBlobStream) {\n\t\t\t\t// Blob requires to stream to BYOB ReadableStream, requiring Node.js  20\n\t\t\t\t_test(`${name}.${type} ${i++} .fileTypeFromBlob() method - same fileType`, testFromBlob, type, name);\n\t\t\t\ttest(`${name}.${type} ${i++} .fileTypeStream() - identical Web Streams`, testStreamWithWebStream, type, name);\n\t\t\t}\n\n\t\t\t_test(`${name}.${type} ${i++} .fileTypeFromStream() Node.js method - same fileType`, testFileNodeFromStream, type, name);\n\t\t\t_test(`${name}.${type} ${i++} .fileTypeStream() - identical Node.js Readable streams`, testStreamWithNodeStream, type, name);\n\t\t}\n\t} else {\n\t\tconst fixtureName = `fixture.${type}`;\n\t\tconst _test = failingFixture.has(fixtureName) ? test.failing : test;\n\n\t\t_test(`${type} ${i++} .fileTypeFromFile()`, testFromFile, type);\n\t\t_test(`${type} ${i++} .fileTypeFromBuffer()`, testFromBuffer, type);\n\t\t_test(`${type} ${i++} .fileTypeFromStream() Node.js`, testFileNodeFromStream, type);\n\t\ttest(`${type} ${i++} .fileTypeStream() - identical streams`, testStreamWithNodeStream, type);\n\t}\n\n\tif (Object.hasOwn(falsePositives, type)) {\n\t\tfor (const falsePositiveFile of falsePositives[type]) {\n\t\t\ttest(`false positive - ${type} ${i++}`, testFalsePositive, type, falsePositiveFile);\n\t\t}\n\t}\n}\n\ntest('.fileTypeStream() method - empty stream', async t => {\n\tconst newStream = await fileTypeStream(readableNoopStream());\n\tt.is(newStream.fileType, undefined);\n});\n\ntest('.fileTypeStream() method - short stream', async t => {\n\tconst bufferA = new Uint8Array([0, 1, 0, 1]);\n\tclass MyStream extends stream.Readable {\n\t\t_read() {\n\t\t\tthis.push(bufferA);\n\t\t\tthis.push(null);\n\t\t}\n\t}\n\n\t// Test filetype detection\n\tconst shortStream = new MyStream();\n\tconst newStream = await fileTypeStream(shortStream);\n\tt.is(newStream.fileType, undefined);\n\n\t// Test usability of returned stream\n\tconst bufferB = await getStreamAsUint8Array(newStream);\n\tt.deepEqual(bufferA, bufferB);\n});\n\ntest('.fileTypeStream() method - no end-of-stream errors', async t => {\n\tconst file = path.join(__dirname, 'fixture', 'fixture.ogm');\n\tconst stream = await fileTypeStream(fs.createReadStream(file), {sampleSize: 30});\n\tt.is(stream.fileType, undefined);\n});\n\ntest('.fileTypeStream() method - error event', async t => {\n\tconst errorMessage = 'Fixture';\n\n\tconst readableStream = new stream.Readable({\n\t\tread() {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tthis.emit('error', new Error(errorMessage));\n\t\t\t});\n\t\t},\n\t});\n\n\tawait t.throwsAsync(fileTypeStream(readableStream), {message: errorMessage});\n});\n\ntest('.fileTypeStream() method - sampleSize option', async t => {\n\tconst file = path.join(__dirname, 'fixture', 'fixture.ogm');\n\tlet stream = await fileTypeStream(fs.createReadStream(file), {sampleSize: 30});\n\tt.is(typeof (stream.fileType), 'undefined', 'file-type cannot be determined with a sampleSize of 30');\n\n\tstream = await fileTypeStream(fs.createReadStream(file), {sampleSize: 4100});\n\tt.is(typeof (stream.fileType), 'object', 'file-type can be determined with a sampleSize of 4100');\n\tt.is(stream.fileType.mime, 'video/ogg');\n});\n\ntest('.fileTypeFromStream() method - be able to abort operation', async t => {\n\tconst bufferA = new Uint8Array([0, 1, 0, 1]);\n\tclass MyStream extends stream.Readable {\n\t\t_read() {\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.push(bufferA);\n\t\t\t\tthis.push(null);\n\t\t\t}, 500);\n\t\t}\n\t}\n\n\tconst shortStream = new MyStream();\n\tconst abortController = new AbortController();\n\tconst parser = new FileTypeParser({signal: abortController.signal});\n\tconst promiseFileType = parser.fromStream(shortStream);\n\tabortController.abort(); // Abort asynchronous operation: reading from shortStream\n\tconst error = await t.throwsAsync(promiseFileType);\n\tt.is(error.message, 'Stream closed');\n});\n\ntest('supportedExtensions.has', t => {\n\tt.true(supportedExtensions.has('jpg'));\n\tt.false(supportedExtensions.has('blah'));\n});\n\ntest('supportedMimeTypes.has', t => {\n\tt.true(supportedMimeTypes.has('video/mpeg'));\n\tt.false(supportedMimeTypes.has('video/blah'));\n});\n\ntest('validate the input argument type', async t => {\n\tawait t.throwsAsync(fileTypeFromBuffer('x'), {\n\t\tmessage: /Expected the `input` argument to be of type `Uint8Array`/,\n\t});\n\n\tawait t.notThrowsAsync(fileTypeFromBuffer(new Uint8Array()));\n\n\tawait t.notThrowsAsync(fileTypeFromBuffer(new ArrayBuffer()));\n});\n\ntest('validate the repo has all extensions and mimes in sync', t => {\n\t// File: core.js (base truth)\n\tfunction readIndexJS() {\n\t\tconst core = fs.readFileSync('core.js', {encoding: 'utf8'});\n\t\tconst extensionArray = core.match(/(?<=ext:\\s')(.*)(?=',)/g);\n\t\tconst mimeArray = core.match(/(?<=mime:\\s')(.*)(?=')/g);\n\t\tconst extensions = new Set(extensionArray);\n\t\tconst mimes = new Set(mimeArray);\n\n\t\treturn {\n\t\t\texts: extensions,\n\t\t\tmimes,\n\t\t};\n\t}\n\n\t// File: package.json\n\tfunction readPackageJSON() {\n\t\tconst packageJson = fs.readFileSync('package.json', {encoding: 'utf8'});\n\t\tconst {keywords} = JSON.parse(packageJson);\n\n\t\tconst allowedExtras = new Set([\n\t\t\t'mime',\n\t\t\t'file',\n\t\t\t'type',\n\t\t\t'magic',\n\t\t\t'archive',\n\t\t\t'image',\n\t\t\t'img',\n\t\t\t'pic',\n\t\t\t'picture',\n\t\t\t'flash',\n\t\t\t'photo',\n\t\t\t'video',\n\t\t\t'detect',\n\t\t\t'check',\n\t\t\t'is',\n\t\t\t'exif',\n\t\t\t'binary',\n\t\t\t'buffer',\n\t\t\t'uint8array',\n\t\t\t'webassembly',\n\t\t]);\n\n\t\tconst extensionArray = keywords.filter(keyword => !allowedExtras.has(keyword));\n\t\treturn extensionArray;\n\t}\n\n\t// File: readme.md\n\tfunction readReadmeMD() {\n\t\tconst index = fs.readFileSync('readme.md', {encoding: 'utf8'});\n\t\tconst extensionArray = index.match(/(?<=-\\s\\[`)(.*)(?=`)/g);\n\t\treturn extensionArray;\n\t}\n\n\t// Helpers\n\t// Find extensions/mimes that are defined twice in a file\n\tfunction findDuplicates(input) {\n\t\t// TODO: Fix this.\n\t\t// eslint-disable-next-line unicorn/no-array-reduce\n\t\treturn input.reduce((accumulator, element, index, array) => {\n\t\t\tif (array.indexOf(element) !== index && !accumulator.includes(element)) {\n\t\t\t\taccumulator.push(element);\n\t\t\t}\n\n\t\t\treturn accumulator;\n\t\t}, []);\n\t}\n\n\t// Find extensions/mimes that are in another file but not in `core.js`\n\tfunction findExtras(array, set) {\n\t\treturn array.filter(element => !set.has(element));\n\t}\n\n\t// Find extensions/mimes that are in `core.js` but missing from another file\n\tfunction findMissing(array, set) {\n\t\tconst missing = [];\n\t\tconst other = new Set(array);\n\t\tfor (const elemenet of set) {\n\t\t\tif (!other.has(elemenet)) {\n\t\t\t\tmissing.push(elemenet);\n\t\t\t}\n\t\t}\n\n\t\treturn missing;\n\t}\n\n\t// Test runner\n\tfunction validate(found, baseTruth, fileName, extensionOrMime) {\n\t\tconst duplicates = findDuplicates(found);\n\t\tconst extras = findExtras(found, baseTruth);\n\t\tconst missing = findMissing(found, baseTruth);\n\t\tt.is(duplicates.length, 0, `Found duplicate ${extensionOrMime}: ${duplicates} in ${fileName}.`);\n\t\tt.is(extras.length, 0, `Extra ${extensionOrMime}: ${extras} in ${fileName}.`);\n\t\tt.is(missing.length, 0, `Missing ${extensionOrMime}: ${missing} in ${fileName}.`);\n\t}\n\n\t// Get the base truth of extensions and mimes supported from core.js\n\tconst {exts} = readIndexJS();\n\n\t// Validate all extensions\n\tconst filesWithExtensions = {\n\t\t'supported.js': [...supportedExtensions],\n\t\t'package.json': readPackageJSON(),\n\t\t'readme.md': readReadmeMD(),\n\t};\n\n\tfor (const fileName in filesWithExtensions) {\n\t\tif (filesWithExtensions[fileName]) {\n\t\t\tconst foundExtensions = filesWithExtensions[fileName];\n\t\t\tvalidate(foundExtensions, exts, fileName, 'extensions');\n\t\t}\n\t}\n});\n\nclass BufferedStream extends stream.Readable {\n\tconstructor(buffer) {\n\t\tsuper();\n\t\tthis.push(buffer);\n\t\tthis.push(null);\n\t}\n\n\t_read() {}\n}\n\ntest('odd file sizes', async t => {\n\tconst oddFileSizes = [1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 255, 256, 257, 511, 512, 513];\n\n\tfor (const size of oddFileSizes) {\n\t\tconst buffer = new Uint8Array(size);\n\t\tawait t.notThrowsAsync(fileTypeFromBuffer(buffer), `fromBuffer: File size: ${size} bytes`);\n\t}\n\n\tfor (const size of oddFileSizes) {\n\t\tconst buffer = new Uint8Array(size);\n\t\tconst stream = new BufferedStream(buffer);\n\t\tawait t.notThrowsAsync(fileTypeNodeFromStream(stream), `fromStream: File size: ${size} bytes`);\n\t}\n});\n\ntest('supported files types are listed alphabetically', async t => {\n\tconst readme = await fs.promises.readFile('readme.md', {encoding: 'utf8'});\n\tlet currentNode = new ReadmeParser().parse(readme).firstChild;\n\n\twhile (currentNode) {\n\t\tif (currentNode.type === 'heading' && currentNode.firstChild.literal === 'Supported file types') {\n\t\t\t// Header  List  First list item\n\t\t\tcurrentNode = currentNode.next.firstChild;\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrentNode = currentNode.next;\n\t}\n\n\tlet previousFileType;\n\n\twhile (currentNode) {\n\t\t// List item  Paragraph  Link  Inline code  Text\n\t\tconst currentFileType = currentNode.firstChild.firstChild.firstChild.literal;\n\n\t\tif (previousFileType) {\n\t\t\tt.true(currentFileType > previousFileType, `${currentFileType} should be listed before ${previousFileType}`);\n\t\t}\n\n\t\tpreviousFileType = currentFileType;\n\t\tcurrentNode = currentNode.next;\n\t}\n});\n\ntest('corrupt MKV throws', async t => {\n\tconst filePath = path.join(__dirname, 'fixture/fixture-corrupt.mkv');\n\tawait t.throwsAsync(fileTypeFromFile(filePath), {message: /End-Of-Stream/});\n});\n\n// Create a custom detector for the just made up \"unicorn\" file type\nconst unicornDetector = {\n\tid: 'mock.unicorn',\n\tasync detect(tokenizer) {\n\t\tconst unicornHeader = [85, 78, 73, 67, 79, 82, 78]; // \"UNICORN\" as decimal string\n\t\tconst buffer = new Uint8Array(7);\n\t\tawait tokenizer.peekBuffer(buffer, {length: unicornHeader.length, mayBeLess: true});\n\t\tif (unicornHeader.every((value, index) => value === buffer[index])) {\n\t\t\treturn {ext: 'unicorn', mime: 'application/unicorn'};\n\t\t}\n\n\t\treturn undefined;\n\t},\n};\n\nconst mockPngDetector = {\n\tid: 'mock.png',\n\tdetect: () => ({ext: 'mockPng', mime: 'image/mockPng'}),\n};\n\nconst tokenizerPositionChanger = {\n\tid: 'mock.dirtyTokenizer',\n\tdetect(tokenizer) {\n\t\tconst buffer = new Uint8Array(1);\n\t\ttokenizer.readBuffer(buffer, {length: 1, mayBeLess: true});\n\t},\n};\n\nif (nodeMajorVersion >= nodeVersionSupportingByteBlobStream) {\n\t// Blob requires to stream to BYOB ReadableStream, requiring Node.js  20\n\n\ttest('fileTypeFromBlob should detect custom file type \"unicorn\" using custom detectors', async t => {\n\t\t// Set up the \"unicorn\" file content\n\t\tconst header = 'UNICORN FILE\\n';\n\t\tconst blob = new Blob([header]);\n\n\t\tconst customDetectors = [unicornDetector];\n\t\tconst parser = new FileTypeParser({customDetectors});\n\n\t\tconst result = await parser.fromBlob(blob);\n\t\tt.deepEqual(result, {ext: 'unicorn', mime: 'application/unicorn'});\n\t});\n\n\ttest('fileTypeFromBlob should keep detecting default file types when no custom detector matches', async t => {\n\t\tconst file = path.join(__dirname, 'fixture', 'fixture.png');\n\t\tconst chunk = fs.readFileSync(file);\n\t\tconst blob = new Blob([chunk]);\n\n\t\tconst customDetectors = [unicornDetector];\n\t\tconst parser = new FileTypeParser({customDetectors});\n\n\t\tconst result = await parser.fromBlob(blob);\n\t\tt.deepEqual(result, {ext: 'png', mime: 'image/png'});\n\t});\n\n\ttest('fileTypeFromBlob should allow overriding default file type detectors', async t => {\n\t\tconst file = path.join(__dirname, 'fixture', 'fixture.png');\n\t\tconst chunk = fs.readFileSync(file);\n\t\tconst blob = new Blob([chunk]);\n\n\t\tconst customDetectors = [mockPngDetector];\n\t\tconst parser = new FileTypeParser({customDetectors});\n\n\t\tconst result = await parser.fromBlob(blob);\n\t\tt.deepEqual(result, {ext: 'mockPng', mime: 'image/mockPng'});\n\t});\n}\n\ntest('fileTypeFromBuffer should detect custom file type \"unicorn\" using custom detectors', async t => {\n\tconst header = 'UNICORN FILE\\n';\n\tconst uint8ArrayContent = new TextEncoder().encode(header);\n\n\tconst customDetectors = [unicornDetector];\n\tconst parser = new FileTypeParser({customDetectors});\n\n\tconst result = await parser.fromBuffer(uint8ArrayContent);\n\tt.deepEqual(result, {ext: 'unicorn', mime: 'application/unicorn'});\n});\n\ntest('fileTypeFromBuffer should keep detecting default file types when no custom detector matches', async t => {\n\tconst file = path.join(__dirname, 'fixture', 'fixture.png');\n\tconst uint8ArrayContent = fs.readFileSync(file);\n\n\tconst customDetectors = [unicornDetector];\n\tconst parser = new FileTypeParser({customDetectors});\n\n\tconst result = await parser.fromBuffer(uint8ArrayContent);\n\tt.deepEqual(result, {ext: 'png', mime: 'image/png'});\n});\n\ntest('fileTypeFromBuffer should allow overriding default file type detectors', async t => {\n\tconst file = path.join(__dirname, 'fixture', 'fixture.png');\n\tconst uint8ArrayContent = fs.readFileSync(file);\n\n\tconst customDetectors = [mockPngDetector];\n\tconst parser = new FileTypeParser({customDetectors});\n\n\tconst result = await parser.fromBuffer(uint8ArrayContent);\n\tt.deepEqual(result, {ext: 'mockPng', mime: 'image/mockPng'});\n});\n\nclass CustomReadableStream extends stream.Readable {\n\t_read(_size) {\n\t\tthis.push('UNICORN');\n\t}\n}\ntest('fileTypeFromStream should detect custom file type \"unicorn\" using custom detectors', async t => {\n\tconst readableStream = new CustomReadableStream();\n\n\tconst customDetectors = [unicornDetector];\n\tconst parser = new FileTypeParser({customDetectors});\n\n\tconst result = await parser.fromStream(readableStream);\n\tt.deepEqual(result, {ext: 'unicorn', mime: 'application/unicorn'});\n});\n\ntest('fileTypeFromStream should keep detecting default file types when no custom detector matches', async t => {\n\tconst file = path.join(__dirname, 'fixture', 'fixture.png');\n\tconst readableStream = fs.createReadStream(file);\n\n\tconst customDetectors = [unicornDetector];\n\tconst parser = new FileTypeParser({customDetectors});\n\n\tconst result = await parser.fromStream(readableStream);\n\tt.deepEqual(result, {ext: 'png', mime: 'image/png'});\n});\n\ntest('fileTypeFromStream should allow overriding default file type detectors', async t => {\n\tconst file = path.join(__dirname, 'fixture', 'fixture.png');\n\tconst readableStream = fs.createReadStream(file);\n\n\tconst customDetectors = [mockPngDetector];\n\tconst parser = new FileTypeParser({customDetectors});\n\n\tconst result = await parser.fromStream(readableStream);\n\tt.deepEqual(result, {ext: 'mockPng', mime: 'image/mockPng'});\n});\n\ntest('fileTypeFromFile should detect custom file type \"unicorn\" using custom detectors', async t => {\n\tconst file = path.join(__dirname, 'fixture', 'fixture.unicorn');\n\n\tconst customDetectors = [unicornDetector];\n\n\tconst result = await fileTypeFromFile(file, {customDetectors});\n\tt.deepEqual(result, {ext: 'unicorn', mime: 'application/unicorn'});\n});\n\ntest('fileTypeFromFile should keep detecting default file types when no custom detector matches', async t => {\n\tconst file = path.join(__dirname, 'fixture', 'fixture.png');\n\n\tconst customDetectors = [unicornDetector];\n\n\tconst result = await fileTypeFromFile(file, {customDetectors});\n\tt.deepEqual(result, {ext: 'png', mime: 'image/png'});\n});\n\ntest('fileTypeFromFile should allow overriding default file type detectors', async t => {\n\tconst file = path.join(__dirname, 'fixture', 'fixture.png');\n\n\tconst customDetectors = [mockPngDetector];\n\n\tconst result = await fileTypeFromFile(file, {customDetectors});\n\tt.deepEqual(result, {ext: 'mockPng', mime: 'image/mockPng'});\n});\n\ntest('fileTypeFromTokenizer should return undefined when a custom detector changes the tokenizer position and does not return a file type', async t => {\n\tconst header = 'UNICORN FILE\\n';\n\tconst uint8ArrayContent = new TextEncoder().encode(header);\n\n\t// Include the unicornDetector here to verify it's not used after the tokenizer.position changed\n\tconst customDetectors = [tokenizerPositionChanger, unicornDetector];\n\tconst parser = new FileTypeParser({customDetectors});\n\n\tconst result = await parser.fromTokenizer(strtok3.fromBuffer(uint8ArrayContent));\n\tt.is(result, undefined);\n});\n"
        },
        {
          "name": "type.js",
          "type": "blob",
          "size": 0.4267578125,
          "content": "#!/usr/bin/node\nimport process from 'node:process';\nimport {fileTypeFromFile} from './index.js';\n\nconst [file] = process.argv.slice(2);\n\nif (!file) {\n\tconsole.error('Expected path of the file to examine');\n\tprocess.exit();\n}\n\nconst fileType = await fileTypeFromFile(file);\n\nif (fileType) {\n\tconsole.log(`MIME-type: ${fileType.mime}`);\n\tconsole.log(`Extension: ${fileType.ext}`);\n} else {\n\tconsole.log('Could not determine file type');\n}\n"
        },
        {
          "name": "util.js",
          "type": "blob",
          "size": 1.251953125,
          "content": "import {StringType} from 'token-types';\n\nexport function stringToBytes(string) {\n\treturn [...string].map(character => character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point\n}\n\n/**\nChecks whether the TAR checksum is valid.\n\n@param {Uint8Array} arrayBuffer - The TAR header `[offset ... offset + 512]`.\n@param {number} offset - TAR header offset.\n@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n*/\nexport function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {\n\tconst readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n\tif (Number.isNaN(readSum)) {\n\t\treturn false;\n\t}\n\n\tlet sum = 8 * 0x20; // Initialize signed bit sum\n\n\tfor (let index = offset; index < offset + 148; index++) {\n\t\tsum += arrayBuffer[index];\n\t}\n\n\tfor (let index = offset + 156; index < offset + 512; index++) {\n\t\tsum += arrayBuffer[index];\n\t}\n\n\treturn readSum === sum;\n}\n\n/**\nID3 UINT32 sync-safe tokenizer token.\n28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n*/\nexport const uint32SyncSafeToken = {\n\tget: (buffer, offset) => (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21),\n\tlen: 4,\n};\n"
        }
      ]
    }
  ]
}