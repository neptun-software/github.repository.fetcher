{
  "metadata": {
    "timestamp": 1736561808669,
    "page": 458,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jasondavies/d3-cloud",
      "stars": 3865,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0263671875,
          "content": "node_modules\nnpm-debug.log\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.396484375,
          "content": "Copyright (c) 2013, Jason Davies.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * The name Jason Davies may not be used to endorse or promote products\n    derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.427734375,
          "content": "# Word Cloud Layout\n\nThis is a [Wordle](http://www.wordle.net/)-inspired word cloud layout written\nin JavaScript. It uses HTML5 canvas and sprite masks to achieve\nnear-interactive speeds.\n\nSee [here](http://www.jasondavies.com/wordcloud/) for an interactive\ndemonstration along with implementation details.\n\n![Example cloud of Twitter search results for “amazing”](http://www.jasondavies.com/wordcloud/amazing.png)\n\n## Usage\n\nSee the samples in `examples/`.\n\n## API Reference\n\n<a name=\"cloud\" href=\"#cloud\">#</a> d3.layout.<b>cloud</b>()\n\nConstructs a new cloud layout instance.\n\n<a name=\"on\" href=\"#on\">#</a> <b>on</b>(<i>type</i>, <i>listener</i>)\n\nRegisters the specified *listener* to receive events of the specified *type*\nfrom the layout. Currently, only \"word\" and \"end\" events are supported.\n\nA \"word\" event is dispatched every time a word is successfully placed.\nRegistered listeners are called with a single argument: the word object that\nhas been placed.\n\nAn \"end\" event is dispatched when the layout has finished attempting to place\nall words.  Registered listeners are called with two arguments: an array of the\nword objects that were successfully placed, and a *bounds* object of the form\n`[{x0, y0}, {x1, y1}]` representing the extent of the placed objects.\n\n<a name=\"start\" href=\"#start\">#</a> <b>start</b>()\n\nStarts the layout algorithm.  This initialises various attributes on the word\nobjects, and attempts to place each word, starting with the largest word.\nStarting with the centre of the rectangular area, each word is tested for\ncollisions with all previously-placed words.  If a collision is found, it tries\nto place the word in a new position along the spiral.\n\n**Note:** if a word cannot be placed in any of the positions attempted along\nthe spiral, it is **not included** in the final word layout.  This may be\naddressed in a future release.\n\n<a name=\"stop\" href=\"#stop\">#</a> <b>stop</b>()\n\nStops the layout algorithm.\n\n<a name=\"timeInterval\" href=\"#timeInterval\">#</a> <b>timeInterval</b>([<i>time</i>])\n\nInternally, the layout uses `setInterval` to avoid locking up the browser’s\nevent loop.  If specified, **time** is the maximum amount of time that can be\nspent during the current timestep.  If not specified, returns the current\nmaximum time interval, which defaults to `Infinity`.\n\n<a name=\"words\" href=\"#words\">#</a> <b>words</b>([<i>words</i>])\n\nIf specified, sets the **words** array.  If not specified, returns the current\nwords array, which defaults to `[]`.\n\n<a name=\"size\" href=\"#size\">#</a> <b>size</b>([<i>size</i>])\n\nIf specified, sets the rectangular `[width, height]` of the layout.  If not\nspecified, returns the current size, which defaults to `[1, 1]`.\n\n<a name=\"font\" href=\"#font\">#</a> <b>font</b>([<i>font</i>])\n\nIf specified, sets the **font** accessor function, which indicates the font\nface for each word.  If not specified, returns the current font accessor\nfunction, which defaults to `\"serif\"`.\nA constant may be specified instead of a function.\n\n<a name=\"fontStyle\" href=\"#fontStyle\">#</a> <b>fontStyle</b>([<i>fontStyle</i>])\n\nIf specified, sets the **fontStyle** accessor function, which indicates the\nfont style for each word.  If not specified, returns the current fontStyle\naccessor function, which defaults to `\"normal\"`.\nA constant may be specified instead of a function.\n\n<a name=\"fontWeight\" href=\"#fontWeight\">#</a> <b>fontWeight</b>([<i>fontWeight</i>])\n\nIf specified, sets the **fontWeight** accessor function, which indicates the\nfont weight for each word.  If not specified, returns the current fontWeight\naccessor function, which defaults to `\"normal\"`.\nA constant may be specified instead of a function.\n\n<a name=\"fontSize\" href=\"#fontSize\">#</a> <b>fontSize</b>([<i>fontSize</i>])\n\nIf specified, sets the **fontSize** accessor function, which indicates the\nnumerical font size for each word.  If not specified, returns the current\nfontSize accessor function, which defaults to:\n\n```js\nfunction(d) { return Math.sqrt(d.value); }\n```\n\nA constant may be specified instead of a function.\n\n<a name=\"rotate\" href=\"#rotate\">#</a> <b>rotate</b>([<i>rotate</i>])\n\nIf specified, sets the **rotate** accessor function, which indicates the\nrotation angle (in degrees) for each word.  If not specified, returns the\ncurrent rotate accessor function, which defaults to:\n\n```js\nfunction() { return (~~(Math.random() * 6) - 3) * 30; }\n```\n\nA constant may be specified instead of a function.\n\n<a name=\"text\" href=\"#text\">#</a> <b>text</b>([<i>text</i>])\n\nIf specified, sets the **text** accessor function, which indicates the text for\neach word.  If not specified, returns the current text accessor function, which\ndefaults to:\n\n```js\nfunction(d) { return d.text; }\n```\n\nA constant may be specified instead of a function.\n\n<a name=\"spiral\" href=\"#spiral\">#</a> <b>spiral</b>([<i>spiral</i>])\n\nIf specified, sets the current type of spiral used for positioning words.  This\ncan either be one of the two built-in spirals, \"archimedean\" and \"rectangular\",\nor an arbitrary spiral generator can be used, of the following form:\n\n```js\n// size is the [width, height] array specified in cloud.size\nfunction(size) {\n  // t indicates the current step along the spiral; it may monotonically\n  // increase or decrease indicating clockwise or counterclockwise motion.\n  return function(t) { return [x, y]; };\n}\n```\n\nIf not specified, returns the current spiral generator, which defaults to the\nbuilt-in \"archimedean\" spiral.\n\n<a name=\"padding\" href=\"#padding\">#</a> <b>padding</b>([<i>padding</i>])\n\nIf specified, sets the **padding** accessor function, which indicates the\nnumerical padding for each word.  If not specified, returns the current\npadding, which defaults to 1.\n\n<a name=\"random\" href=\"#random\">#</a> <b>random</b>([<i>random</i>])\n\nIf specified, sets the internal random number generator, used for selecting the\ninitial position of each word, and the clockwise/counterclockwise direction of\nthe spiral for each word.  This should return a number in the range `[0, 1)`.\n\nIf not specified, returns the current random number generator, which defaults\nto `Math.random`.\n\n<a name=\"canvas\" href=\"#canvas\">#</a> <b>canvas</b>([<i>canvas</i>])\n\nIf specified, sets the **canvas** generator function, which is used internally\nto draw text.  If not specified, returns the current generator function, which\ndefaults to:\n\n```js\nfunction() { return document.createElement(\"canvas\"); }\n```\n\nWhen using Node.js, you will almost definitely override this default, e.g.\nusing the [canvas module](https://www.npmjs.com/package/canvas).\n"
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.28125,
          "content": "{\n  \"name\": \"d3-cloud\",\n  \"version\": \"1.2.4\",\n  \"main\": \"build/d3.layout.cloud.js\",\n  \"dependencies\": {\n    \"d3-dispatch\": \"1\"\n  },\n  \"ignore\": [\n    \".DS_Store\",\n    \".git\",\n    \".gitignore\",\n    \".npmignore\",\n    \"examples\",\n    \"index.js\",\n    \"node_modules\",\n    \"package.json\"\n  ]\n}\n"
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 10.3037109375,
          "content": "// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\n// Algorithm due to Jonathan Feinberg, https://s3.amazonaws.com/static.mrfeinberg.com/bv_ch03.pdf\n\nconst dispatch = require(\"d3-dispatch\").dispatch;\n\nconst RADIANS = Math.PI / 180;\n\nconst SPIRALS = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\n\nconst cw = 1 << 11 >> 5;\nconst ch = 1 << 11;\n\nmodule.exports = function() {\n  var size = [256, 256],\n      text = cloudText,\n      font = cloudFont,\n      fontSize = cloudFontSize,\n      fontStyle = cloudFontNormal,\n      fontWeight = cloudFontNormal,\n      rotate = cloudRotate,\n      padding = cloudPadding,\n      spiral = archimedeanSpiral,\n      words = [],\n      timeInterval = Infinity,\n      event = dispatch(\"word\", \"end\"),\n      timer = null,\n      random = Math.random,\n      cloud = {},\n      canvas = cloudCanvas;\n\n  cloud.canvas = function(_) {\n    return arguments.length ? (canvas = functor(_), cloud) : canvas;\n  };\n\n  cloud.start = function() {\n    var contextAndRatio = getContext(canvas()),\n        board = zeroArray((size[0] >> 5) * size[1]),\n        bounds = null,\n        n = words.length,\n        i = -1,\n        tags = [],\n        data = words.map(function(d, i) {\n          d.text = text.call(this, d, i);\n          d.font = font.call(this, d, i);\n          d.style = fontStyle.call(this, d, i);\n          d.weight = fontWeight.call(this, d, i);\n          d.rotate = rotate.call(this, d, i);\n          d.size = ~~fontSize.call(this, d, i);\n          d.padding = padding.call(this, d, i);\n          return d;\n        }).sort(function(a, b) { return b.size - a.size; });\n\n    if (timer) clearInterval(timer);\n    timer = setInterval(step, 0);\n    step();\n\n    return cloud;\n\n    function step() {\n      var start = Date.now();\n      while (Date.now() - start < timeInterval && ++i < n && timer) {\n        var d = data[i];\n        d.x = (size[0] * (random() + .5)) >> 1;\n        d.y = (size[1] * (random() + .5)) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n        if (d.hasText && place(board, d, bounds)) {\n          tags.push(d);\n          event.call(\"word\", cloud, d);\n          if (bounds) cloudBounds(bounds, d);\n          else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];\n          // Temporary hack\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n      if (i >= n) {\n        cloud.stop();\n        event.call(\"end\", cloud, tags, bounds);\n      }\n    }\n  }\n\n  cloud.stop = function() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n    for (const d of words) {\n      delete d.sprite;\n    }\n    return cloud;\n  };\n\n  function getContext(canvas) {\n    const context = canvas.getContext(\"2d\", {willReadFrequently: true});\n\n    canvas.width = canvas.height = 1;\n    const ratio = Math.sqrt(context.getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n\n    context.fillStyle = context.strokeStyle = \"red\";\n\n    return {context, ratio};\n  }\n\n  function place(board, tag, bounds) {\n    var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],\n        startX = tag.x,\n        startY = tag.y,\n        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n        s = spiral(size),\n        dt = random() < .5 ? 1 : -1,\n        t = -dt,\n        dxdy,\n        dx,\n        dy;\n\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||\n          tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || collideRects(tag, bounds)) {\n        if (!cloudCollide(tag, board, size[0])) {\n          var sprite = tag.sprite,\n              w = tag.width >> 5,\n              sw = size[0] >> 5,\n              lx = tag.x - (w << 4),\n              sx = lx & 0x7f,\n              msx = 32 - sx,\n              h = tag.y1 - tag.y0,\n              x = (tag.y + tag.y0) * sw + (lx >> 5),\n              last;\n          for (var j = 0; j < h; j++) {\n            last = 0;\n            for (var i = 0; i <= w; i++) {\n              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  cloud.timeInterval = function(_) {\n    return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;\n  };\n\n  cloud.words = function(_) {\n    return arguments.length ? (words = _, cloud) : words;\n  };\n\n  cloud.size = function(_) {\n    return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;\n  };\n\n  cloud.font = function(_) {\n    return arguments.length ? (font = functor(_), cloud) : font;\n  };\n\n  cloud.fontStyle = function(_) {\n    return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;\n  };\n\n  cloud.fontWeight = function(_) {\n    return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;\n  };\n\n  cloud.rotate = function(_) {\n    return arguments.length ? (rotate = functor(_), cloud) : rotate;\n  };\n\n  cloud.text = function(_) {\n    return arguments.length ? (text = functor(_), cloud) : text;\n  };\n\n  cloud.spiral = function(_) {\n    return arguments.length ? (spiral = SPIRALS[_] || _, cloud) : spiral;\n  };\n\n  cloud.fontSize = function(_) {\n    return arguments.length ? (fontSize = functor(_), cloud) : fontSize;\n  };\n\n  cloud.padding = function(_) {\n    return arguments.length ? (padding = functor(_), cloud) : padding;\n  };\n\n  cloud.random = function(_) {\n    return arguments.length ? (random = _, cloud) : random;\n  };\n\n  cloud.on = function() {\n    var value = event.on.apply(event, arguments);\n    return value === event ? cloud : value;\n  };\n\n  return cloud;\n};\n\nfunction cloudText(d) {\n  return d.text;\n}\n\nfunction cloudFont() {\n  return \"serif\";\n}\n\nfunction cloudFontNormal() {\n  return \"normal\";\n}\n\nfunction cloudFontSize(d) {\n  return Math.sqrt(d.value);\n}\n\nfunction cloudRotate() {\n  return (~~(random() * 6) - 3) * 30;\n}\n\nfunction cloudPadding() {\n  return 1;\n}\n\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  var c = contextAndRatio.context,\n      ratio = contextAndRatio.ratio;\n\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  var x = 0,\n      y = 0,\n      maxh = 0,\n      n = data.length;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + \" \" + d.weight + \" \" + ~~((d.size + 1) / ratio) + \"px \" + d.font;\n    const metrics = c.measureText(d.text);\n    const anchor = -Math.floor(metrics.width / 2);\n    let w = (metrics.width + 1) * ratio;\n    let h = d.size << 1;\n    if (d.rotate) {\n      var sr = Math.sin(d.rotate * RADIANS),\n          cr = Math.cos(d.rotate * RADIANS),\n          wcr = w * cr,\n          wsr = w * sr,\n          hcr = h * cr,\n          hsr = h * sr;\n      w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = (w + 0x1f) >> 5 << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= (cw << 5)) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * RADIANS);\n    c.fillText(d.text, anchor, 0);\n    if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, anchor, 0);\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n      sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    var w = d.width,\n        w32 = w >> 5,\n        h = d.y1 - d.y0;\n    // Zero the buffer\n    for (var i = 0; i < h * w32; i++) sprite[i] = 0;\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    var seen = 0,\n        seenRow = -1;\n    for (var j = 0; j < h; j++) {\n      for (var i = 0; i < w; i++) {\n        var k = w32 * j + (i >> 5),\n            m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;\n      else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  var sprite = tag.sprite,\n      w = tag.width >> 5,\n      lx = tag.x - (w << 4),\n      sx = lx & 0x7f,\n      msx = 32 - sx,\n      h = tag.y1 - tag.y0,\n      x = (tag.y + tag.y0) * sw + (lx >> 5),\n      last;\n  for (var j = 0; j < h; j++) {\n    last = 0;\n    for (var i = 0; i <= w; i++) {\n      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))\n          & board[x + i]) return true;\n    }\n    x += sw;\n  }\n  return false;\n}\n\nfunction cloudBounds(bounds, d) {\n  var b0 = bounds[0],\n      b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\n\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\n\nfunction archimedeanSpiral(size) {\n  var e = size[0] / size[1];\n  return function(t) {\n    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\n\nfunction rectangularSpiral(size) {\n  var dy = 4,\n      dx = dy * size[0] / size[1],\n      x = 0,\n      y = 0;\n  return function(t) {\n    var sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n      case 0:  x += dx; break;\n      case 1:  y += dy; break;\n      case 2:  x -= dx; break;\n      default: y -= dy; break;\n    }\n    return [x, y];\n  };\n}\n\n// TODO reuse arrays?\nfunction zeroArray(n) {\n  var a = [],\n      i = -1;\n  while (++i < n) a[i] = 0;\n  return a;\n}\n\nfunction cloudCanvas() {\n  return document.createElement(\"canvas\");\n}\n\nfunction functor(d) {\n  return typeof d === \"function\" ? d : function() { return d; };\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.771484375,
          "content": "{\n  \"name\": \"d3-cloud\",\n  \"version\": \"1.2.7\",\n  \"description\": \"Generate word clouds in JavaScript.\",\n  \"keywords\": [\n    \"word\",\n    \"cloud\",\n    \"tag\",\n    \"visualization\",\n    \"canvas\"\n  ],\n  \"homepage\": \"https://www.jasondavies.com/wordcloud/\",\n  \"license\": \"BSD-3-Clause\",\n  \"author\": {\n    \"name\": \"Jason Davies\",\n    \"url\": \"https://www.jasondavies.com/\"\n  },\n  \"main\": \"build/d3.layout.cloud.js\",\n  \"module\": \"index\",\n  \"jsnext:main\": \"index\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/jasondavies/d3-cloud.git\"\n  },\n  \"scripts\": {\n    \"build\": \"mkdir -p build && browserify --standalone d3.layout.cloud index.js > build/d3.layout.cloud.js\"\n  },\n  \"dependencies\": {\n    \"d3-dispatch\": \"^1.0.3\"\n  },\n  \"devDependencies\": {\n    \"browserify\": \"^17.0.0\"\n  }\n}\n"
        },
        {
          "name": "tea.yaml",
          "type": "blob",
          "size": 0.123046875,
          "content": "# https://tea.xyz/what-is-this-file\n---\nversion: 1.0.0\ncodeOwners:\n  - '0x36E1122030B48B83B1E0d2500D0052DAa922E292'\nquorum: 1\n"
        }
      ]
    }
  ]
}