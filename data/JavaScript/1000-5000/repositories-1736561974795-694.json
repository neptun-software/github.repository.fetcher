{
  "metadata": {
    "timestamp": 1736561974795,
    "page": 694,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "AloneMonkey/frida-ios-dump",
      "stars": 3473,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.029296875,
          "content": ".DS_Store\n.idea\n*.ipa\n\nfrida/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2017 Alone_Monkey\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.2392578125,
          "content": "# frida-ios-dump\nPull a decrypted IPA from a jailbroken device\n\n\n## Usage\n\n 1. Install [frida](http://www.frida.re/) on device\n 2. `sudo pip install -r requirements.txt --upgrade`\n 3. Run usbmuxd/iproxy SSH forwarding over USB (Default 2222 -> 22). e.g. `iproxy 2222 22`\n 4. Run ./dump.py `Display name` or `Bundle identifier`\n\nFor SSH/SCP make sure you have your public key added to the target device's ~/.ssh/authorized_keys file.\n\n```\n./dump.py Aftenposten\nStart the target app Aftenposten\nDumping Aftenposten to /var/folders/wn/9v1hs8ds6nv_xj7g95zxyl140000gn/T\nstart dump /var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/AftenpostenApp\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/AFNetworking.framework/AFNetworking\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/ATInternet_iOS_ObjC_SDK.framework/ATInternet_iOS_ObjC_SDK\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/SPTEventCollector.framework/SPTEventCollector\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/SPiDSDK.framework/SPiDSDK\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftCore.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftCoreData.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftCoreGraphics.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftCoreImage.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftCoreLocation.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftDarwin.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftDispatch.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftFoundation.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftObjectiveC.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftQuartzCore.dylib\nstart dump /private/var/containers/Bundle/Application/66423A80-0AFE-471C-BC9B-B571107D3C27/AftenpostenApp.app/Frameworks/libswiftUIKit.dylib\nGenerating Aftenposten.ipa\n\nDone.\n```\n\nCongratulations!!! You've got a decrypted IPA file.\n\nDrag to [MonkeyDev](https://github.com/AloneMonkey/MonkeyDev), Happy hacking!\n\n## Support\n\nPython 2.x and 3.x\n\n\n### issues\n\nIf the following error occurs:\n\n* causes device to reboot\n* lost connection\n* unexpected error while probing dyld of target process\n\nplease open the application before dumping.\n\n\n"
        },
        {
          "name": "dump.js",
          "type": "blob",
          "size": 11.4521484375,
          "content": "Module.ensureInitialized('Foundation');\n\nvar O_RDONLY = 0;\nvar O_WRONLY = 1;\nvar O_RDWR = 2;\nvar O_CREAT = 512;\n\nvar SEEK_SET = 0;\nvar SEEK_CUR = 1;\nvar SEEK_END = 2;\n\nfunction allocStr(str) {\n    return Memory.allocUtf8String(str);\n}\n\nfunction putStr(addr, str) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.writeUtf8String(addr, str);\n}\n\nfunction getByteArr(addr, l) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.readByteArray(addr, l);\n}\n\nfunction getU8(addr) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.readU8(addr);\n}\n\nfunction putU8(addr, n) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.writeU8(addr, n);\n}\n\nfunction getU16(addr) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.readU16(addr);\n}\n\nfunction putU16(addr, n) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.writeU16(addr, n);\n}\n\nfunction getU32(addr) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.readU32(addr);\n}\n\nfunction putU32(addr, n) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.writeU32(addr, n);\n}\n\nfunction getU64(addr) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.readU64(addr);\n}\n\nfunction putU64(addr, n) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.writeU64(addr, n);\n}\n\nfunction getPt(addr) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    return Memory.readPointer(addr);\n}\n\nfunction putPt(addr, n) {\n    if (typeof addr == \"number\") {\n        addr = ptr(addr);\n    }\n    if (typeof n == \"number\") {\n        n = ptr(n);\n    }\n    return Memory.writePointer(addr, n);\n}\n\nfunction malloc(size) {\n    return Memory.alloc(size);\n}\n\nfunction getExportFunction(type, name, ret, args) {\n    var nptr;\n    nptr = Module.findExportByName(null, name);\n    if (nptr === null) {\n        console.log(\"cannot find \" + name);\n        return null;\n    } else {\n        if (type === \"f\") {\n            var funclet = new NativeFunction(nptr, ret, args);\n            if (typeof funclet === \"undefined\") {\n                console.log(\"parse error \" + name);\n                return null;\n            }\n            return funclet;\n        } else if (type === \"d\") {\n            var datalet = Memory.readPointer(nptr);\n            if (typeof datalet === \"undefined\") {\n                console.log(\"parse error \" + name);\n                return null;\n            }\n            return datalet;\n        }\n    }\n}\n\nvar NSSearchPathForDirectoriesInDomains = getExportFunction(\"f\", \"NSSearchPathForDirectoriesInDomains\", \"pointer\", [\"int\", \"int\", \"int\"]);\nvar wrapper_open = getExportFunction(\"f\", \"open\", \"int\", [\"pointer\", \"int\", \"int\"]);\nvar read = getExportFunction(\"f\", \"read\", \"int\", [\"int\", \"pointer\", \"int\"]);\nvar write = getExportFunction(\"f\", \"write\", \"int\", [\"int\", \"pointer\", \"int\"]);\nvar lseek = getExportFunction(\"f\", \"lseek\", \"int64\", [\"int\", \"int64\", \"int\"]);\nvar close = getExportFunction(\"f\", \"close\", \"int\", [\"int\"]);\nvar remove = getExportFunction(\"f\", \"remove\", \"int\", [\"pointer\"]);\nvar access = getExportFunction(\"f\", \"access\", \"int\", [\"pointer\", \"int\"]);\nvar dlopen = getExportFunction(\"f\", \"dlopen\", \"pointer\", [\"pointer\", \"int\"]);\n\nfunction getDocumentDir() {\n    var NSDocumentDirectory = 9;\n    var NSUserDomainMask = 1;\n    var npdirs = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, 1);\n    return ObjC.Object(npdirs).objectAtIndex_(0).toString();\n}\n\nfunction open(pathname, flags, mode) {\n    if (typeof pathname == \"string\") {\n        pathname = allocStr(pathname);\n    }\n    return wrapper_open(pathname, flags, mode);\n}\n\nvar modules = null;\nfunction getAllAppModules() {\n    modules = new Array();\n    var tmpmods = Process.enumerateModulesSync();\n    for (var i = 0; i < tmpmods.length; i++) {\n        if (tmpmods[i].path.indexOf(\".app\") != -1) {\n            modules.push(tmpmods[i]);\n        }\n    }\n    return modules;\n}\n\nvar FAT_MAGIC = 0xcafebabe;\nvar FAT_CIGAM = 0xbebafeca;\nvar MH_MAGIC = 0xfeedface;\nvar MH_CIGAM = 0xcefaedfe;\nvar MH_MAGIC_64 = 0xfeedfacf;\nvar MH_CIGAM_64 = 0xcffaedfe;\nvar LC_SEGMENT = 0x1;\nvar LC_SEGMENT_64 = 0x19;\nvar LC_ENCRYPTION_INFO = 0x21;\nvar LC_ENCRYPTION_INFO_64 = 0x2C;\n\nfunction pad(str, n) {\n    return Array(n-str.length+1).join(\"0\")+str;\n}\n\nfunction swap32(value) {\n    value = pad(value.toString(16),8)\n    var result = \"\";\n    for(var i = 0; i < value.length; i=i+2){\n        result += value.charAt(value.length - i - 2);\n        result += value.charAt(value.length - i - 1);\n    }\n    return parseInt(result,16)\n}\n\nfunction dumpModule(name) {\n    if (modules == null) {\n        modules = getAllAppModules();\n    }\n\n    var targetmod = null;\n    for (var i = 0; i < modules.length; i++) {\n        if (modules[i].path.indexOf(name) != -1) {\n            targetmod = modules[i];\n            break;\n        }\n    }\n    if (targetmod == null) {\n        console.log(\"Cannot find module\");\n        return;\n    }\n    var modbase = modules[i].base;\n    var modsize = modules[i].size;\n    var newmodname = modules[i].name;\n    var newmodpath = getDocumentDir() + \"/\" + newmodname + \".fid\";\n    var oldmodpath = modules[i].path;\n\n\n    if(!access(allocStr(newmodpath),0)){\n        remove(allocStr(newmodpath));\n    }\n\n    var fmodule = open(newmodpath, O_CREAT | O_RDWR, 0);\n    var foldmodule = open(oldmodpath, O_RDONLY, 0);\n\n    if (fmodule == -1 || foldmodule == -1) {\n        console.log(\"Cannot open file\" + newmodpath);\n        return;\n    }\n\n    var is64bit = false;\n    var size_of_mach_header = 0;\n    var magic = getU32(modbase);\n    var cur_cpu_type = getU32(modbase.add(4));\n    var cur_cpu_subtype = getU32(modbase.add(8));\n    if (magic == MH_MAGIC || magic == MH_CIGAM) {\n        is64bit = false;\n        size_of_mach_header = 28;\n    }else if (magic == MH_MAGIC_64 || magic == MH_CIGAM_64) {\n        is64bit = true;\n        size_of_mach_header = 32;\n    }\n\n    var BUFSIZE = 4096;\n    var buffer = malloc(BUFSIZE);\n\n    read(foldmodule, buffer, BUFSIZE);\n\n    var fileoffset = 0;\n    var filesize = 0;\n    magic = getU32(buffer);\n    if(magic == FAT_CIGAM || magic == FAT_MAGIC){\n        var off = 4;\n        var archs = swap32(getU32(buffer.add(off)));\n        for (var i = 0; i < archs; i++) {\n            var cputype = swap32(getU32(buffer.add(off + 4)));\n            var cpusubtype = swap32(getU32(buffer.add(off + 8)));\n            if(cur_cpu_type == cputype && cur_cpu_subtype == cpusubtype){\n                fileoffset = swap32(getU32(buffer.add(off + 12)));\n                filesize = swap32(getU32(buffer.add(off + 16)));\n                break;\n            }\n            off += 20;\n        }\n\n        if(fileoffset == 0 || filesize == 0)\n            return;\n\n        lseek(fmodule, 0, SEEK_SET);\n        lseek(foldmodule, fileoffset, SEEK_SET);\n        for(var i = 0; i < parseInt(filesize / BUFSIZE); i++) {\n            read(foldmodule, buffer, BUFSIZE);\n            write(fmodule, buffer, BUFSIZE);\n        }\n        if(filesize % BUFSIZE){\n            read(foldmodule, buffer, filesize % BUFSIZE);\n            write(fmodule, buffer, filesize % BUFSIZE);\n        }\n    }else{\n        var readLen = 0;\n        lseek(foldmodule, 0, SEEK_SET);\n        lseek(fmodule, 0, SEEK_SET);\n        while(readLen = read(foldmodule, buffer, BUFSIZE)) {\n            write(fmodule, buffer, readLen);\n        }\n    }\n\n    var ncmds = getU32(modbase.add(16));\n    var off = size_of_mach_header;\n    var offset_cryptid = -1;\n    var crypt_off = 0;\n    var crypt_size = 0;\n    var segments = [];\n    for (var i = 0; i < ncmds; i++) {\n        var cmd = getU32(modbase.add(off));\n        var cmdsize = getU32(modbase.add(off + 4));\n        if (cmd == LC_ENCRYPTION_INFO || cmd == LC_ENCRYPTION_INFO_64) {\n            offset_cryptid = off + 16;\n            crypt_off = getU32(modbase.add(off + 8));\n            crypt_size = getU32(modbase.add(off + 12));\n        }\n        off += cmdsize;\n    }\n\n    if (offset_cryptid != -1) {\n        var tpbuf = malloc(8);\n        putU64(tpbuf, 0);\n        lseek(fmodule, offset_cryptid, SEEK_SET);\n        write(fmodule, tpbuf, 4);\n        lseek(fmodule, crypt_off, SEEK_SET);\n        write(fmodule, modbase.add(crypt_off), crypt_size);\n    }\n\n    close(fmodule);\n    close(foldmodule);\n    return newmodpath\n}\n\nfunction loadAllDynamicLibrary(app_path) {\n    var defaultManager = ObjC.classes.NSFileManager.defaultManager();\n    var errorPtr = Memory.alloc(Process.pointerSize); \n    Memory.writePointer(errorPtr, NULL); \n    var filenames = defaultManager.contentsOfDirectoryAtPath_error_(app_path, errorPtr);\n    for (var i = 0, l = filenames.count(); i < l; i++) {\n        var file_name = filenames.objectAtIndex_(i);\n        var file_path = app_path.stringByAppendingPathComponent_(file_name);\n        if (file_name.hasSuffix_(\".framework\")) {\n            var bundle = ObjC.classes.NSBundle.bundleWithPath_(file_path);\n            if (bundle.isLoaded()) {\n                console.log(\"[frida-ios-dump]: \" + file_name + \" has been loaded. \");\n            } else {\n                if (bundle.load()) {\n                    console.log(\"[frida-ios-dump]: Load \" + file_name + \" success. \");\n                } else {\n                    console.log(\"[frida-ios-dump]: Load \" + file_name + \" failed. \");\n                }\n            }\n        } else if (file_name.hasSuffix_(\".bundle\") || \n                   file_name.hasSuffix_(\".momd\") ||\n                   file_name.hasSuffix_(\".strings\") ||\n                   file_name.hasSuffix_(\".appex\") ||\n                   file_name.hasSuffix_(\".app\") ||\n                   file_name.hasSuffix_(\".lproj\") ||\n                   file_name.hasSuffix_(\".storyboardc\")) {\n            continue;\n        } else {\n            var isDirPtr = Memory.alloc(Process.pointerSize);\n            Memory.writePointer(isDirPtr,NULL);\n            defaultManager.fileExistsAtPath_isDirectory_(file_path, isDirPtr);\n            if (Memory.readPointer(isDirPtr) == 1) {\n                loadAllDynamicLibrary(file_path);\n            } else {\n                if (file_name.hasSuffix_(\".dylib\")) {\n                    var is_loaded = 0;\n                    for (var j = 0; j < modules.length; j++) {\n                        if (modules[j].path.indexOf(file_name) != -1) {\n                            is_loaded = 1;\n                            console.log(\"[frida-ios-dump]: \" + file_name + \" has been dlopen.\");\n                            break;\n                        }\n                    } \n\n                    if (!is_loaded) {\n                        if (dlopen(allocStr(file_path.UTF8String()), 9)) {\n                            console.log(\"[frida-ios-dump]: dlopen \" + file_name + \" success. \");\n                        } else {\n                            console.log(\"[frida-ios-dump]: dlopen \" + file_name + \" failed. \");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction handleMessage(message) {\n    modules = getAllAppModules();\n    var app_path = ObjC.classes.NSBundle.mainBundle().bundlePath();\n    loadAllDynamicLibrary(app_path);\n    // start dump\n    modules = getAllAppModules();\n    for (var i = 0; i  < modules.length; i++) {\n        console.log(\"start dump \" + modules[i].path);\n        var result = dumpModule(modules[i].path);\n        send({ dump: result, path: modules[i].path});\n    }\n    send({app: app_path.toString()});\n    send({done: \"ok\"});\n    recv(handleMessage);\n}\n\nrecv(handleMessage);"
        },
        {
          "name": "dump.py",
          "type": "blob",
          "size": 10.7158203125,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# Author : AloneMonkey\n# blog: www.alonemonkey.com\n\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\nimport sys\nimport codecs\nimport frida\nimport threading\nimport os\nimport shutil\nimport time\nimport argparse\nimport tempfile\nimport subprocess\nimport re\nimport paramiko\nfrom paramiko import SSHClient\nfrom scp import SCPClient\nfrom tqdm import tqdm\nimport traceback\n\nIS_PY2 = sys.version_info[0] < 3\nif IS_PY2:\n    reload(sys)\n    sys.setdefaultencoding('utf8')\n\nscript_dir = os.path.dirname(os.path.realpath(__file__))\n\nDUMP_JS = os.path.join(script_dir, 'dump.js')\n\nUser = 'root'\nPassword = 'alpine'\nHost = 'localhost'\nPort = 2222\nKeyFileName = None\n\nTEMP_DIR = tempfile.gettempdir()\nPAYLOAD_DIR = 'Payload'\nPAYLOAD_PATH = os.path.join(TEMP_DIR, PAYLOAD_DIR)\nfile_dict = {}\n\nfinished = threading.Event()\n\n\ndef get_usb_iphone():\n    Type = 'usb'\n    if int(frida.__version__.split('.')[0]) < 12:\n        Type = 'tether'\n    device_manager = frida.get_device_manager()\n    changed = threading.Event()\n\n    def on_changed():\n        changed.set()\n\n    device_manager.on('changed', on_changed)\n\n    device = None\n    while device is None:\n        devices = [dev for dev in device_manager.enumerate_devices() if dev.type == Type]\n        if len(devices) == 0:\n            print('Waiting for USB device...')\n            changed.wait()\n        else:\n            device = devices[0]\n\n    device_manager.off('changed', on_changed)\n\n    return device\n\n\ndef generate_ipa(path, display_name):\n    ipa_filename = display_name + '.ipa'\n\n    print('Generating \"{}\"'.format(ipa_filename))\n    try:\n        app_name = file_dict['app']\n\n        for key, value in file_dict.items():\n            from_dir = os.path.join(path, key)\n            to_dir = os.path.join(path, app_name, value)\n            if key != 'app':\n                shutil.move(from_dir, to_dir)\n\n        target_dir = './' + PAYLOAD_DIR\n        zip_args = ('zip', '-qr', os.path.join(os.getcwd(), ipa_filename), target_dir)\n        subprocess.check_call(zip_args, cwd=TEMP_DIR)\n        shutil.rmtree(PAYLOAD_PATH)\n    except Exception as e:\n        print(e)\n        finished.set()\n\ndef on_message(message, data):\n    t = tqdm(unit='B',unit_scale=True,unit_divisor=1024,miniters=1)\n    last_sent = [0]\n\n    def progress(filename, size, sent):\n        baseName = os.path.basename(filename)\n        if IS_PY2 or isinstance(baseName, bytes):\n            t.desc = baseName.decode(\"utf-8\")\n        else:\n            t.desc = baseName\n        t.total = size\n        t.update(sent - last_sent[0])\n        last_sent[0] = 0 if size == sent else sent\n\n    if 'payload' in message:\n        payload = message['payload']\n        if 'dump' in payload:\n            origin_path = payload['path']\n            dump_path = payload['dump']\n\n            scp_from = dump_path\n            scp_to = PAYLOAD_PATH + '/'\n\n            with SCPClient(ssh.get_transport(), progress = progress, socket_timeout = 60) as scp:\n                scp.get(scp_from, scp_to)\n\n            chmod_dir = os.path.join(PAYLOAD_PATH, os.path.basename(dump_path))\n            chmod_args = ('chmod', '655', chmod_dir)\n            try:\n                subprocess.check_call(chmod_args)\n            except subprocess.CalledProcessError as err:\n                print(err)\n\n            index = origin_path.find('.app/')\n            file_dict[os.path.basename(dump_path)] = origin_path[index + 5:]\n\n        if 'app' in payload:\n            app_path = payload['app']\n\n            scp_from = app_path\n            scp_to = PAYLOAD_PATH + '/'\n            with SCPClient(ssh.get_transport(), progress = progress, socket_timeout = 60) as scp:\n                scp.get(scp_from, scp_to, recursive=True)\n\n            chmod_dir = os.path.join(PAYLOAD_PATH, os.path.basename(app_path))\n            chmod_args = ('chmod', '755', chmod_dir)\n            try:\n                subprocess.check_call(chmod_args)\n            except subprocess.CalledProcessError as err:\n                print(err)\n\n            file_dict['app'] = os.path.basename(app_path)\n\n        if 'done' in payload:\n            finished.set()\n    t.close()\n\ndef compare_applications(a, b):\n    a_is_running = a.pid != 0\n    b_is_running = b.pid != 0\n    if a_is_running == b_is_running:\n        if a.name > b.name:\n            return 1\n        elif a.name < b.name:\n            return -1\n        else:\n            return 0\n    elif a_is_running:\n        return -1\n    else:\n        return 1\n\n\ndef cmp_to_key(mycmp):\n    \"\"\"Convert a cmp= function into a key= function\"\"\"\n\n    class K:\n        def __init__(self, obj):\n            self.obj = obj\n\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0\n\n        def __eq__(self, other):\n            return mycmp(self.obj, other.obj) == 0\n\n        def __le__(self, other):\n            return mycmp(self.obj, other.obj) <= 0\n\n        def __ge__(self, other):\n            return mycmp(self.obj, other.obj) >= 0\n\n        def __ne__(self, other):\n            return mycmp(self.obj, other.obj) != 0\n\n    return K\n\n\ndef get_applications(device):\n    try:\n        applications = device.enumerate_applications()\n    except Exception as e:\n        sys.exit('Failed to enumerate applications: %s' % e)\n\n    return applications\n\n\ndef list_applications(device):\n    applications = get_applications(device)\n\n    if len(applications) > 0:\n        pid_column_width = max(map(lambda app: len('{}'.format(app.pid)), applications))\n        name_column_width = max(map(lambda app: len(app.name), applications))\n        identifier_column_width = max(map(lambda app: len(app.identifier), applications))\n    else:\n        pid_column_width = 0\n        name_column_width = 0\n        identifier_column_width = 0\n\n    header_format = '%' + str(pid_column_width) + 's  ' + '%-' + str(name_column_width) + 's  ' + '%-' + str(\n        identifier_column_width) + 's'\n    print(header_format % ('PID', 'Name', 'Identifier'))\n    print('%s  %s  %s' % (pid_column_width * '-', name_column_width * '-', identifier_column_width * '-'))\n    line_format = '%' + str(pid_column_width) + 's  ' + '%-' + str(name_column_width) + 's  ' + '%-' + str(\n        identifier_column_width) + 's'\n    for application in sorted(applications, key=cmp_to_key(compare_applications)):\n        if application.pid == 0:\n            print(line_format % ('-', application.name, application.identifier))\n        else:\n            print(line_format % (application.pid, application.name, application.identifier))\n\n\ndef load_js_file(session, filename):\n    source = ''\n    with codecs.open(filename, 'r', 'utf-8') as f:\n        source = source + f.read()\n    script = session.create_script(source)\n    script.on('message', on_message)\n    script.load()\n\n    return script\n\n\ndef create_dir(path):\n    path = path.strip()\n    path = path.rstrip('\\\\')\n    if os.path.exists(path):\n        shutil.rmtree(path)\n    try:\n        os.makedirs(path)\n    except os.error as err:\n        print(err)\n\n\ndef open_target_app(device, name_or_bundleid):\n    print('Start the target app {}'.format(name_or_bundleid))\n\n    pid = ''\n    session = None\n    display_name = ''\n    bundle_identifier = ''\n    for application in get_applications(device):\n        if name_or_bundleid == application.identifier or name_or_bundleid == application.name:\n            pid = application.pid\n            display_name = application.name\n            bundle_identifier = application.identifier\n\n    try:\n        if not pid:\n            pid = device.spawn([bundle_identifier])\n            session = device.attach(pid)\n            device.resume(pid)\n        else:\n            session = device.attach(pid)\n    except Exception as e:\n        print(e) \n\n    return session, display_name, bundle_identifier\n\n\ndef start_dump(session, ipa_name):\n    print('Dumping {} to {}'.format(display_name, TEMP_DIR))\n\n    script = load_js_file(session, DUMP_JS)\n    script.post('dump')\n    finished.wait()\n\n    generate_ipa(PAYLOAD_PATH, ipa_name)\n\n    if session:\n        session.detach()\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='frida-ios-dump (by AloneMonkey v2.0)')\n    parser.add_argument('-l', '--list', dest='list_applications', action='store_true', help='List the installed apps')\n    parser.add_argument('-o', '--output', dest='output_ipa', help='Specify name of the decrypted IPA')\n    parser.add_argument('-H', '--host', dest='ssh_host', help='Specify SSH hostname')\n    parser.add_argument('-p', '--port', dest='ssh_port', help='Specify SSH port')\n    parser.add_argument('-u', '--user', dest='ssh_user', help='Specify SSH username')\n    parser.add_argument('-P', '--password', dest='ssh_password', help='Specify SSH password')\n    parser.add_argument('-K', '--key_filename', dest='ssh_key_filename', help='Specify SSH private key file path')\n    parser.add_argument('target', nargs='?', help='Bundle identifier or display name of the target app')\n\n    args = parser.parse_args()\n\n    exit_code = 0\n    ssh = None\n\n    if not len(sys.argv[1:]):\n        parser.print_help()\n        sys.exit(exit_code)\n\n    device = get_usb_iphone()\n\n    if args.list_applications:\n        list_applications(device)\n    else:\n        name_or_bundleid = args.target\n        output_ipa = args.output_ipa\n        # update ssh args\n        if args.ssh_host:\n            Host = args.ssh_host\n        if args.ssh_port:\n            Port = int(args.ssh_port)\n        if args.ssh_user:\n            User = args.ssh_user\n        if args.ssh_password:\n            Password = args.ssh_password\n        if args.ssh_key_filename:\n            KeyFileName = args.ssh_key_filename\n\n        try:\n            ssh = paramiko.SSHClient()\n            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            ssh.connect(Host, port=Port, username=User, password=Password, key_filename=KeyFileName)\n\n            create_dir(PAYLOAD_PATH)\n            (session, display_name, bundle_identifier) = open_target_app(device, name_or_bundleid)\n            if output_ipa is None:\n                output_ipa = display_name\n            output_ipa = re.sub('\\.ipa$', '', output_ipa)\n            if session:\n                start_dump(session, output_ipa)\n        except paramiko.ssh_exception.NoValidConnectionsError as e:\n            print(e)\n            print('Try specifying -H/--hostname and/or -p/--port')\n            exit_code = 1\n        except paramiko.AuthenticationException as e:\n            print(e)\n            print('Try specifying -u/--username and/or -P/--password')\n            exit_code = 1\n        except Exception as e:\n            print('*** Caught exception: %s: %s' % (e.__class__, e))\n            traceback.print_exc()\n            exit_code = 1\n\n    if ssh:\n        ssh.close()\n\n    if os.path.exists(PAYLOAD_PATH):\n        shutil.rmtree(PAYLOAD_PATH)\n\n    sys.exit(exit_code)\n"
        },
        {
          "name": "process.sh",
          "type": "blob",
          "size": 1.966796875,
          "content": "#!/bin/bash\n\nORIGINAL_IPA_FOLDER=\"${HOME}/Music/iTunes/iTunes Media/Mobile Applications\"\nDECRYPTED_IPA_FOLDER=\"${HOME}/Hacking/Decrypted Apps\"\n\nIOS_DEPLOY=\"/usr/local/bin/ios-deploy\"\nPLISTBUDDY=\"/usr/libexec/PlistBuddy\"\nFRIDA_DUMP_PY=\"./dump.py\"\n# CFBundleIdentifier in Info.plist to uninstall\n\nORIGINAL_IPAS=()\nwhile IFS=  read -r -d $'\\0'; do\n    ORIGINAL_IPA=$( echo \"${REPLY}\" )\n    ORIGINAL_IPAS+=( \"${ORIGINAL_IPA}\" )\ndone < <(find \"${ORIGINAL_IPA_FOLDER}\" -type f -name '*.ipa' -print0)\n\necho \"Decrypting ${#ORIGINAL_IPAS[@]} apps\"\nAPP_COUNTER=0\nfor ORIGINAL_IPA in \"${ORIGINAL_IPAS[@]}\"; do\n    APP_COUNTER=$((APP_COUNTER + 1))\n    echo \"#### Decryting app number: ${APP_COUNTER}\"\n    APP_BUNDLE_ID=\"\"\n    ESCAPED_IPA_PATH=$( echo \"${ORIGINAL_IPA}\" | sed 's/ /\\\\ /g' | sed 's/&/\\\\&/g' )\n\n    IPA_NAME=$( basename \"${ESCAPED_IPA_PATH}\" )\n\n    # Make a temp file for the iTunesMetadata.plist\n    ITUNESMETADATA_TMP_FILE=$( mktemp \"/tmp/iTunesMetadata.plist.XXXXXX\" ) || exit 1\n\n    # Unzip iTunesMetadata.plist to temp file\n    UNZIP_CMD=\"unzip -p ${ESCAPED_IPA_PATH} iTunesMetadata.plist > ${ITUNESMETADATA_TMP_FILE}\"\n    echo \"${UNZIP_CMD}\"\n    eval \"${UNZIP_CMD}\" || exit 1\n\n    # Extract softwareVersionBundleId from plist file\n    APP_BUNDLE_ID=$( \"${PLISTBUDDY}\" -c 'Print softwareVersionBundleId' \"${ITUNESMETADATA_TMP_FILE}\" )\n    echo \"App bundle identifier: ${APP_BUNDLE_ID}\"\n    rm \"${ITUNESMETADATA_TMP_FILE}\"\n\n    # Install the app\n    IOS_DEPLOY_INSTALL=\"${IOS_DEPLOY} -W --bundle ${ESCAPED_IPA_PATH}\"\n    echo \"${IOS_DEPLOY_INSTALL}\"\n    eval \"${IOS_DEPLOY_INSTALL}\"\n\n    if [ $? -eq 0 ]; then\n        sleep 1\n\n        echo \"Dumping ${APP_BUNDLE_ID}\"\n        FRIDA_DUMP_CMD=\"${FRIDA_DUMP_PY} --output ${IPA_NAME} ${APP_BUNDLE_ID}\"\n        echo \"${FRIDA_DUMP_CMD}\"\n        eval \"${FRIDA_DUMP_CMD}\"\n    fi\n\n    # Uninstall the app\n    IOS_DEPLOY_UNINSTALL=\"${IOS_DEPLOY} -W --uninstall_only --bundle_id ${APP_BUNDLE_ID}\"\n    echo \"${IOS_DEPLOY_UNINSTALL}\"\n    eval \"${IOS_DEPLOY_UNINSTALL}\"\ndone"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.1533203125,
          "content": "asn1crypto\nbcrypt\ncffi\ncolorama\ncryptography\nenum34\nfrida-tools\nidna\nipaddress\nparamiko\nprompt-toolkit\npyasn1\npycparser\nPygments\nPyNaCl\nscp\nsix\ntqdm\nwcwidth\n"
        }
      ]
    }
  ]
}