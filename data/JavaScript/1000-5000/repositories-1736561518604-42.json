{
  "metadata": {
    "timestamp": 1736561518604,
    "page": 42,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "manga-download/hakuneko",
      "stars": 4874,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".azure",
          "type": "tree",
          "content": null
        },
        {
          "name": ".eslintrc.json",
          "type": "blob",
          "size": 1.0927734375,
          "content": "{\n    \"env\": {\n        \"es6\": true,\n        \"node\": true,\n        \"browser\": true,\n        \"jest\": true\n    },\n    \"extends\": [\n        \"eslint:recommended\"\n    ],\n    \"globals\": {\n        \"protobuf\":\"readonly\",\n        \"CryptoJS\":\"readonly\",\n        \"JSZip\":\"readonly\",\n        \"OAuth\":\"readonly\",\n        \"PDFDocument\":\"readonly\",\n        \"HakuNeko\": \"readonly\",\n        \"Engine\": \"readonly\",\n        \"EventListener\": \"readonly\",\n        \"Connector\": \"readonly\",\n        \"ClipboardConnector\": \"readonly\",\n        \"EXIF\": \"readonly\"\n    },\n    \"parserOptions\": {\n        \"ecmaVersion\": 2018,\n        \"sourceType\": \"module\"\n    },\n    \"rules\": {\n        \"semi\": [\"error\", \"always\"],\n        \"semi-spacing\": \"error\",\n        \"comma-spacing\": \"error\",\n        \"brace-style\": \"error\",\n        \"no-extra-parens\": \"error\",\n        \"space-before-blocks\": \"error\",\n        //\"object-curly-spacing\": \"error\",\n        \"indent\": [\"error\", 4, { \"SwitchCase\": 1 }],\n        \"no-trailing-spaces\": \"error\",\n        \"no-multiple-empty-lines\": [\"error\", {\"max\": 1, \"maxBOF\": 0, \"maxEOF\": 0}],\n        \"no-multi-spaces\": \"error\"\n    }\n}"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1416015625,
          "content": "CNAME\nyarn.lock\npackage-lock.json\nnode_modules\n*.tar.bz2\n*.key\n*.pem\n*.log\nbuild\ncache\n.vscode\n.helper\n/redist/*.zip\n/test/*.log\njunit.xml\n.idea/"
        },
        {
          "name": "README.asciidoc",
          "type": "blob",
          "size": 4.4140625,
          "content": "= HakuNeko\n:toc:\n:numbered:\n:icons: font\n:linkattrs:\n:imagesdir: ./assets\nifdef::env-github[]\n:tip-caption: :bulb:\n:note-caption: :information_source:\n:important-caption: :heavy_exclamation_mark:\n:caution-caption: :fire:\n:warning-caption: :warning:\nendif::[]\n\n---\n\nüè° Website : https://hakuneko.download\n\nimage:https://hakuneko.download/assets/images/discord-small.png[link=https://discord.gg/A5d3NDf, title=\"Join us on discord\", window=\"_blank\"] Discord : https://discord.gg/A5d3NDf\n\n=== Download\n\nimage:https://img.shields.io/github/downloads/manga-download/hakuneko/latest/total?label=HakuNeko%20%28Stable%29&logo=github[link=https://github.com/manga-download/hakuneko/releases/latest, title=\"Download the latest stable release of HakuNeko\", window=\"_blank\"]\nimage:https://img.shields.io/github/downloads-pre/manga-download/hakuneko/latest/total?color=blue&label=HakuNeko%20%28Nightly%29&logo=azure-devops[link=https://github.com/manga-download/hakuneko/releases, title=\"Download the latest pre-release (nightly build) of HakuNeko\", window=\"_blank\"]\nimage:https://img.shields.io/chocolatey/dt/hakunekonightly?color=blue&label=Chocolatey%20package[link=https://community.chocolatey.org/packages/hakunekonightly, window=\"_blank\"]\n\nYes, the download section comes first, because this is what most users are looking for anyway.\nYou can download and run the installer/archive for your operating system from one of the mirror sites above.\nThere is also a portable version available for Windows which stores all its application data inside the application folder.\n\n---\n\n=== Status\n\nThis section shows the latest build and test results for the master branch of the mirrored repository on link:https://dev.azure.com/manga-download/hakuneko/_build[Azure].\n\nimage:https://img.shields.io/azure-devops/tests/manga-download/hakuneko/8?label=CI%20Tests&logo=azure-pipelines[Test Results, link=\"https://dev.azure.com/manga-download/hakuneko/_testManagement/runs?_a=runQuery\", title=\"List of CI Test Results\"]\nimage:https://dev.azure.com/manga-download/hakuneko/_apis/build/status/CI?branchName=master&label=CI%20Pipeline[Build Status, link=\"https://dev.azure.com/manga-download/hakuneko/_build/latest?definitionId=5&branchName=master\", title=\"Latest CI Pipeline Summary\"]\nimage:https://dev.azure.com/manga-download/hakuneko/_apis/build/status/Nightly?branchName=master&label=Nightly%20Build[Build Status, link=\"https://dev.azure.com/manga-download/hakuneko/_build/latest?definitionId=7&branchName=master\", title=\"Latest Nightly Build Summary\"]\n\n[%collapsible, title=\"Details\"]\n====\nContinuous Integration::\nimage:https://dev.azure.com/manga-download/hakuneko/_apis/build/status/CI?branchName=master&jobName=CI&configuration=CI%20Windows&label=CI%20-%20Windows[title=\"CI Pipeline: Windows\"]\n +\nimage:https://dev.azure.com/manga-download/hakuneko/_apis/build/status/CI?branchName=master&jobName=CI&configuration=CI%20Ubuntu&label=CI%20-%20Ubuntu[title=\"CI Pipeline: Ubuntu\"]\n +\nimage:https://dev.azure.com/manga-download/hakuneko/_apis/build/status/CI?branchName=master&jobName=CI&configuration=CI%20macOS&label=CI%20-%20macOS[title=\"CI Pipeline: macOS\"]\n\nNightly Builds::\nimage:https://dev.azure.com/manga-download/hakuneko/_apis/build/status/Nightly?branchName=master&jobName=Windows&label=Nightly%20-%20Windows[title=\"Nightly Build: Windows\"]\n +\nimage:https://dev.azure.com/manga-download/hakuneko/_apis/build/status/Nightly?branchName=master&jobName=Ubuntu&label=Nightly%20-%20Ubuntu[title=\"Nightly Build: Ubuntu\"]\n +\nimage:https://dev.azure.com/manga-download/hakuneko/_apis/build/status/Nightly?branchName=master&jobName=macOS&label=Nightly%20-%20macOS[title=\"Nightly Build: macOS\"]\n====\n\n---\n\n=== Introduction\n\nHakuNeko is a cross-platform downloader for manga and anime from various websites.\nHakuNeko was made to help users downloading media for circumstances that require offline usage.\nThe philosophy is ad-hoc consumption, get it when you going to read/watch it.\nIt is not meant to be a mass downloader to stock up thousands of chapters that are just collected and will probably never be read.\n\n[.clearfix]\n--\n[.center]\nimage::screenshot-pages.png[link=screenshot-pages.png, width=720, title=\"HakuNeko - Chapter Page Preview\", window=_blank]\n\n{nbsp} +\n\nimage::screenshot-video.png[link=screenshot-video.png, width=720, title=\"HakuNeko - Anime Playback\", window=_blank]\n--\n\n---\n\n=== Development\n\nFor developer documentation please check the link:https://github.com/manga-download/hakuneko/wiki/Developer-Manual[Wiki]\n\n---\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.1044921875,
          "content": "The whole purpose of the file is to get rid of GitHub's warning about the missing security policy file ...\n"
        },
        {
          "name": "UNLICENSE",
          "type": "blob",
          "size": 1.181640625,
          "content": "This is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org>\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "build-app.config",
          "type": "blob",
          "size": 0.8232421875,
          "content": "module.exports = {\n    version: require('./package.json').devDependencies.electron,\n    author: 'The HakuNeko Development Team <https://github.com/orgs/manga-download/people>',\n    name: {\n        package: 'hakuneko-desktop',\n        product: 'HakuNeko Desktop',\n    },\n    description: {\n        short: 'Manga Downloader',\n        long: 'Desktop Client for HakuNeko Web-Application'\n    },\n    license: 'Unlicense',\n    url: 'https://git.io/hakuneko',\n    src: 'src/app',\n    binary: {\n        windows: 'hakuneko.exe',\n        linux: 'hakuneko',\n        darwin: 'HakuNeko'\n    },\n    meta: {\n        section: 'net',\n        type: 'Application',\n        categories: 'Network;FileTransfer;',\n        menu: 'Applications/Network/File Transfer',\n        dependencies: {\n            deb: 'libc6',\n            rpm: 'libXScrnSaver'\n        }\n    }\n}"
        },
        {
          "name": "build-app.js",
          "type": "blob",
          "size": 31.9189453125,
          "content": "const path = require('path');\nconst fs = require('fs-extra');\nconst zlib = require('zlib');\nconst asar = require('asar');\nconst https = require('https');\nconst eol = require('os').EOL;\nconst exec = require('child_process').exec;\nconst config = require('./build-app.config');\n\n/**\n * Base class for platform dependent electron packagers\n */\nclass ElectronPackager {\n\n    /**\n     *\n     */\n    constructor(configuration) {\n        this._configuration = configuration;\n    }\n\n    /**\n     *\n     */\n    build(architecture) {\n        throw new Error('Not implemented!');\n    }\n\n    /**\n     *\n     * @param {*} folder\n     */\n    async _getSize(folder) {\n        if(process.platform !== 'win32') {\n            let size = await this._executeCommand(`du -k -c \"${folder}\" | grep total | cut -f1`);\n            return size.trim();\n        } else {\n            throw new Error('Not implemented!');\n        }\n    }\n\n    /**\n     *\n     * @param {string} archive\n     * @param {string} target\n     */\n    async _extractArchive(archive, target) {\n        if(process.platform === 'win32') {\n            await this._executeCommand(`7z x \"${archive}\" -o\"${target}\"`);\n        } else {\n            await this._executeCommand(`unzip \"${archive}\" -d \"${target}\"`);\n        }\n    }\n\n    /**\n     *\n     * @param {string} source\n     * @param {string} archive\n     */\n    async _compressArchive(source, archive) {\n        if(process.platform === 'win32') {\n            await this._executeCommand(`7z a \"${archive}\" \"${source}\"`);\n        } else {\n            throw new Error('Not implemented!');\n        }\n    }\n\n    /**\n     *\n     * @param {*} file\n     * @param {*} data\n     * @param {*} gzip\n     */\n    _saveFile(file, data, gzip) {\n        fs.ensureDirSync(path.dirname(file));\n        let content = gzip ? zlib.gzipSync(data, { level: 9 }) : data;\n        fs.writeFileSync(file, content, typeof content === 'string' ? { encoding: 'utf8' } : undefined);\n    }\n\n    /**\n     *\n     * @param {*} uri\n     * @param {*} file\n     */\n    _download(uri, file) {\n        return new Promise( (resolve, reject) => {\n            https.get(uri, response => {\n                if(response.headers['location']) {\n                    this._download(response.headers['location'], file)\n                        .then(() => resolve())\n                        .catch(error => reject(error));\n                } else {\n                    if(response.statusCode === 200) {\n                        console.log('Downloading:', file);\n                        let stream = fs.createWriteStream(file);\n                        response.pipe(stream);\n                        stream.on('finish', () => resolve());\n                        stream.on('error', error => reject(error));\n                    } else {\n                        console.error('Download Failed!');\n                        reject(new Error('Failed to download electron client!'));\n                    }\n                }\n            });\n        });\n    }\n\n    /**\n     *\n     * @param {*} version\n     * @param {*} platform\n     */\n    async _downloadElectron(version, platform, directory) {\n        let file = `electron-v${version}-${platform}.zip`;\n        let uri = `https://github.com/electron/electron/releases/download/v${version}/${file}`;\n        file = path.join('redist', file);\n\n        if(!fs.existsSync(file)) {\n            await this._download(uri, file);\n        }\n        await fs.ensureDir(directory);\n        await this._extractArchive(file, directory);\n        await fs.remove(path.join(directory, 'version'));\n        await fs.remove(path.join(directory, 'LICENSE'));\n        await fs.remove(path.join(directory, 'LICENSES.chromium.html'));\n    }\n\n    /**\n     *\n     * @param {string} moduleName\n     * @param {string} imageName Name of the binary image (wihtout any extension)\n     * @param {string} platform\n     * @param {bool} is64\n     */\n    async _bundleStaticBinary(moduleName, imageName, platform, architecture) {\n        let binary = imageName + (process.platform === 'win32' ? '.exe' : '');\n        let source = path.join('node_modules', '@hakuneko', moduleName, 'bin', platform, architecture, binary);\n        let target = path.join(this._stagingExecutableDirectory, binary);\n        console.log(`Bundle '${source}' ...`);\n        if(await fs.exists(source)) {\n            await fs.copy(source, target);\n            await fs.chmod(target, '0755');\n            console.log(`  => File bundled: '${target}'`);\n        } else {\n            console.log('  => File not found: skipped');\n        }\n    }\n\n    /**\n     *\n     * @param {string} architecture\n     */\n    async _bundleFFMPEG(architecture) {\n        await this._bundleStaticBinary('ffmpeg-binaries', 'ffmpeg', process.platform, architecture);\n    }\n\n    /**\n     *\n     * @param {string} architecture\n     */\n    async _bundleImageMagick(architecture) {\n        await this._bundleStaticBinary('imagemagick-binaries', 'convert', process.platform, architecture);\n    }\n\n    /**\n     *\n     * @param {string} architecture\n     */\n    async _bundleKindleGenerate(architecture) {\n        await this._bundleStaticBinary('kindlegen-binaries', 'kindlegen', process.platform, architecture);\n    }\n\n    /**\n     *\n     * @param {string} command\n     * @param {bool} silent\n     */\n    _executeCommand(command, silent) {\n        if(!silent) {\n            console.log('>', command);\n        }\n        return new Promise((resolve, reject) => {\n            exec(command, (error, stdout, stderr) => {\n                if(!silent) {\n                    console.log(stdout);\n                    console.log(stderr);\n                }\n                if(error) {\n                    reject(error);\n                } else {\n                    resolve(stdout);\n                }\n            });\n        });\n    }\n\n    /**\n     *\n     * @param  {...string} commands\n     */\n    async _validateCommands(...commands) {\n        for(let command of commands) {\n            try {\n                await this._executeCommand(command, true);\n            } catch(error) {\n                throw new Error(`Failed to run command '${command}', make sure it is correctly installed!`);\n            }\n        }\n    }\n}\n\n/**\n * Packager for linux platform\n */\nclass ElectronPackagerLinux extends ElectronPackager {\n\n    /**\n     *\n     */\n    constructor(configuration) {\n        super(configuration);\n        this.architectures = {\n            '32': {\n                name: 'i386',\n                suffix: 'linux_i386',\n                platform: 'linux-ia32'\n            },\n            '64': {\n                name: 'amd64',\n                suffix: 'linux_amd64',\n                platform: 'linux-x64'\n            },\n            'ARMv7': {\n                name: 'armv7l',\n                suffix: 'linux_armv7l',\n                platform: 'linux-armv7l'\n            },\n            'ARMHF': {\n                name: 'armhf',\n                suffix: 'linux_armhf',\n                platform: 'linux-armv7l'\n            },\n            'ARMv8': {\n                name: 'arm64',\n                suffix: 'linux_arm64',\n                platform: 'linux-arm64'\n            }\n        };\n        this._architecture = this.architectures[0];\n    }\n\n    /**\n     *\n     */\n    get _dirBuildRoot() {\n        return path.join('build', `${this._configuration.name.package}_${this._configuration.version}_${this._architecture.suffix}`);\n    }\n\n    /**\n     *\n     */\n    get _stagingExecutableDirectory() {\n        return path.join(this._dirBuildRoot, 'usr', 'lib', this._configuration.name.package);\n    }\n\n    /**\n     *\n     * @param {string} architecture '32' or '64'\n     */\n    async build(architecture) {\n        await this.buildDEB(architecture);\n        await this.buildRPM(architecture);\n    }\n\n    /**\n     *\n     */\n    async buildDEB(architecture) {\n        this._architecture = this.architectures[architecture];\n\n        await this._validateCommands('unzip --help', 'asar --version', 'fakeroot --version', 'dpkg --version', 'lintian --version');\n\n        await fs.remove(this._dirBuildRoot);\n        await this._copySkeletonDEB();\n        await this._bundleElectron();\n        await this._bundleFFMPEG(this._architecture.name);\n        await this._bundleImageMagick(this._architecture.name);\n        await this._bundleKindleGenerate(this._architecture.name);\n        this._createManpage();\n        this._createChangelog();\n        //this._createMenuEntry(); // => only menu or desktop is recommend\n        this._createDesktopShortcut();\n        await this._createControlDEB();\n        this._createPostScript('postrm');\n        this._createPostScript('postinst');\n        await this._createChecksumsDEB();\n\n        let deb = this._dirBuildRoot + '.deb';\n        await fs.remove(deb);\n        await this._executeCommand(`fakeroot dpkg-deb -v -b \"${this._dirBuildRoot}\" \"${deb}\"`);\n        await this._executeCommand(`lintian --profile debian \"${deb}\" || true`);\n    }\n\n    /**\n     *\n     */\n    async buildRPM(architecture) {\n        this._architecture = this.architectures[architecture];\n\n        await this._validateCommands('unzip --help', 'asar --version', 'fakeroot --version', 'rpm --version');\n\n        await fs.remove(this._dirBuildRoot);\n        await this._copySkeletonRPM();\n        await this._bundleElectron();\n        await this._bundleFFMPEG(this._architecture.name);\n        await this._bundleImageMagick(this._architecture.name);\n        await this._bundleKindleGenerate(this._architecture.name);\n        this._createManpage();\n        this._createChangelog();\n        //this._createMenuEntry(); // => only menu or desktop is recommend\n        this._createDesktopShortcut();\n        let specs = await this._createSpecsRPM();\n\n        let rpm = this._dirBuildRoot + '.rpm';\n        await fs.remove(rpm);\n        await this._executeCommand(`rpmbuild -bb --noclean --define \"_topdir $(pwd)/${this._dirBuildRoot}\" --define \"buildroot %{_topdir}\" \"${specs}\"`);\n        await this._executeCommand(`mv -f ${this._dirBuildRoot}/RPMS/*/*.rpm ${rpm}`);\n        await fs.remove(specs);\n    }\n\n    /**\n     *\n     */\n    async _bundleElectron() {\n        console.log('Bundle electron ...');\n        let folder = this._stagingExecutableDirectory;\n        await this._downloadElectron(this._configuration.version, this._architecture.platform, folder);\n        await fs.remove(path.join(folder, 'resources', 'default_app.asar'));\n        await asar.createPackage(config.src, path.join(folder, 'resources', 'app.asar'));\n        await fs.move(path.join(folder, 'electron'), path.join(folder, this._configuration.binary.linux));\n        // chmod 4755 fixes https://github.com/electron/electron/issues/17972\n        await fs.chmod(path.join(folder, 'chrome-sandbox'), '4755');\n        // remove executable flag from libraries => avoid lintian errors\n        await this._executeCommand(`find \"${folder}\" -type f -iname \"*.so\" -exec chmod -x {} \\\\;`);\n    }\n\n    /**\n     *\n     */\n    async _copySkeletonDEB() {\n        console.log('Copy DEB Skeleton ...');\n        //await this._executeCommand(`cp -r \"redist/deb\" \"${this._dirBuildRoot}\"`);\n        await fs.copy(path.join('redist', 'deb'), this._dirBuildRoot);\n    }\n\n    /**\n     *\n     */\n    async _copySkeletonRPM() {\n        console.log('Copy RPM Skeleton ...');\n        //await this._executeCommand(`cp -r \"redist/rpm\" \"${this._dirBuildRoot}\"`);\n        await fs.copy(path.join('redist', 'rpm'), this._dirBuildRoot);\n    }\n\n    /**\n     *\n     */\n    _createManpage() {\n        console.log('Creating Manpage ...');\n        let file = path.join(this._dirBuildRoot, 'usr', 'share', 'man', 'man1', this._configuration.name.package + '.1.gz');\n        let content = [\n            `.TH ${this._configuration.name.package} 1 \"\" \"\"`,\n            '',\n            '.SH NAME',\n            `${this._configuration.name.package} - ${this._configuration.description.short}`,\n            '',\n            '.SH SYNOPSIS',\n            this._configuration.name.package,\n            '',\n            '.SH DESCRIPTION',\n            this._configuration.description.long\n        ];\n        this._saveFile(file, content.join(eol), true);\n    }\n\n    /**\n     *\n     */\n    _createChangelog() {\n        console.log('Creating Changelog ...');\n        let file = path.join(this._dirBuildRoot, 'usr', 'share', 'doc', this._configuration.name.package, 'changelog.gz');\n        this._saveFile(file, '-', true);\n    }\n\n    /**\n     *\n     */\n    _createDesktopShortcut() {\n        console.log('Creating Desktop Shortcut ...');\n        let file = path.join(this._dirBuildRoot, 'usr', 'share', 'applications', this._configuration.name.package + '.desktop');\n        let content = [\n            '[Desktop Entry]',\n            'Version=1.0',\n            'Type=' + this._configuration.meta.type,\n            'Name=' + this._configuration.name.product,\n            'GenericName=' + this._configuration.description.short,\n            'Exec=' + path.join('/usr', 'lib', this._configuration.name.package, this._configuration.binary.linux),\n            'Icon=' + this._configuration.name.package,\n            'Categories=' + this._configuration.meta.categories\n        ];\n        this._saveFile(file, content.join(eol), false);\n    }\n\n    /**\n     *\n     */\n    _createMenuEntry() {\n        console.log('Creatng Menu Entry');\n        let file = path.join(this._dirBuildRoot, 'usr', 'share', 'menu', this._configuration.name.package);\n        let content = [\n            `?package(${this._configuration.name.package}):needs=\"X11\" \\\\`,\n            ` section=\"${this._configuration.meta.menu}\" \\\\`,\n            ` title=\"${this._configuration.name.product}\" \\\\`,\n            ` icon=\"/usr/share/pixmaps/${this._configuration.name.package}.xpm\" \\\\`,\n            ` command=\"${path.join('/usr/lib', this._configuration.name.package, this._configuration.binary.linux)}\"`\n        ];\n        this._saveFile(file, content.join(eol), false);\n    }\n\n    /**\n     *\n     */\n    async _createControlDEB() {\n        console.log('Creating DEB Control File ...');\n        let file = path.join(this._dirBuildRoot, 'DEBIAN', 'control');\n        let content = [\n            'Package: ' + this._configuration.name.package,\n            'Version: ' + this._configuration.version,\n            'Section: ' + this._configuration.meta.section,\n            'Architecture: ' + this._architecture.name,\n            'Installed-Size: ' + await this._getSize(path.join(this._dirBuildRoot, 'usr')),\n            'Depends: ' + this._configuration.meta.dependencies.deb,\n            'Maintainer: ' + this._configuration.author,\n            'Priority: optional',\n            'Homepage: ' + this._configuration.url,\n            'Description: ' + this._configuration.description.short,\n            ' ' + this._configuration.description.long,\n            ''\n        ];\n        this._saveFile(file, content.join(eol), false);\n    }\n\n    /**\n     *\n     */\n    _createPostScript(name) {\n        console.log(`Creating PostScript '${name}' ...`);\n        let file = path.join(this._dirBuildRoot, 'DEBIAN', name);\n        let symbolic = path.join('/usr', 'bin', this._configuration.name.package);\n        let binary = path.join('/usr', 'lib', this._configuration.name.package, this._configuration.binary.linux);\n        let content = [\n            '#!/bin/sh',\n            'set -e',\n            '#if [ -x /usr/bin/update-mime ] ; then update-mime ; fi',\n            '#if [ -x /usr/bin/update-menus ] ; then update-menus ; fi'\n        ];\n        if(name === 'postinst') {\n            content.push(`if [ ! -f ${symbolic} ] ; then ln -s ${binary} ${symbolic} ; fi`);\n        }\n        if(name === 'postrm') {\n            content.push(`if [ -f ${symbolic} ] ; then rm -f ${symbolic} ; fi`);\n        }\n        this._saveFile(file, content.join(eol), false);\n    }\n\n    /**\n     *\n     */\n    async _createChecksumsDEB() {\n        console.log('Creating Checksums ...');\n        await this._executeCommand(`cd \"${this._dirBuildRoot}\" && find usr -type f -print0 | xargs -0 md5sum > \"DEBIAN/md5sums\"`);\n    }\n\n    /**\n     *\n     */\n    async _createSpecsRPM() {\n        console.log('Creating RPM Specification File ...');\n        let file = path.join('build', 'specfile.spec');\n        let symbolic = path.join('/usr', 'bin', this._configuration.name.package);\n        let binary = path.join('/usr', 'lib', this._configuration.name.package, this._configuration.binary.linux);\n        let content = [\n            'Name: ' + this._configuration.name.package,\n            'Version: ' + this._configuration.version,\n            'Release: 0',\n            'License: ' + this._configuration.license,\n            'URL: ' + this._configuration.url,\n            'Requires: ' + this._configuration.meta.dependencies.rpm,\n            'Summary: ' + this._configuration.description.short,\n            '',\n            'Autoreq: no',\n            'AutoReqProv: no',\n            '',\n            '%description',\n            this._configuration.description.long,\n            '',\n            '%files',\n            `%dir /usr/lib/${this._configuration.name.package}/`,\n            await this._executeCommand(`cd \"${this._dirBuildRoot}\" && find usr -type f -exec echo /{} \\\\;`),\n            '%post',\n            `if [ ! -f ${symbolic} ] ; then ln -s ${binary} ${symbolic} ; fi`,\n            '',\n            '%postun',\n            `if [ -f ${symbolic} ] ; then rm -f ${symbolic} ; fi`\n        ];\n        this._saveFile(file, content.join(eol), false);\n        return file;\n    }\n}\n\n/**\n * Packager for windows platform\n */\nclass ElectronPackagerWindows extends ElectronPackager {\n\n    /**\n     *\n     */\n    constructor(configuration) {\n        super(configuration);\n        this.architectures = {\n            '32': {\n                is: {\n                    name: 'i386',\n                    suffix: 'windows-setup_i386',\n                    platform: 'win32-ia32'\n                },\n                zip: {\n                    name: 'i386',\n                    suffix: 'windows-portable_i386',\n                    platform: 'win32-ia32'\n                }\n            },\n            '64': {\n                is: {\n                    name: 'amd64',\n                    suffix: 'windows-setup_amd64',\n                    platform: 'win32-x64'\n                },\n                zip: {\n                    name: 'amd64',\n                    suffix: 'windows-portable_amd64',\n                    platform: 'win32-x64'\n                }\n            }\n        };\n        this._architecture = this.architectures[0];\n    }\n\n    /**\n     *\n     */\n    get _dirBuildRoot() {\n        return path.join('build', `${this._configuration.name.package}_${this._configuration.version}_${this._architecture.suffix}`);\n    }\n\n    /**\n     *\n     */\n    get _stagingExecutableDirectory() {\n        return this._dirBuildRoot;\n    }\n\n    /**\n     *\n     * @param {string} architecture '32' or '64'\n     */\n    async build(architecture) {\n        await this.buildIS(architecture);\n        await this.buildZIP(architecture);\n    }\n\n    /**\n     * Create InnoSetup installer\n     * @param {string} architecture\n     */\n    async buildIS(architecture) {\n        this._architecture = this.architectures[architecture].is;\n\n        await this._validateCommands('7z --help', 'asar --version', 'innosetup-compiler /?');\n\n        await fs.remove(this._dirBuildRoot);\n        await this._bundleElectron(false);\n        await this._bundleFFMPEG(this._architecture.name);\n        await this._bundleImageMagick(this._architecture.name);\n        await this._bundleKindleGenerate(this._architecture.name);\n        await this._editResource();\n        let setup = this._createScriptIS(architecture === '64');\n\n        await this._executeCommand(`innosetup-compiler \"${setup}\"`);\n        await fs.remove(setup);\n    }\n\n    /**\n     * Create portable archive\n     * @param {string} architecture\n     */\n    async buildZIP(architecture) {\n        this._architecture = this.architectures[architecture].zip;\n\n        await this._validateCommands('7z --help', 'asar --version');\n\n        await fs.remove(this._dirBuildRoot);\n        await this._bundleElectron(true);\n        await this._bundleFFMPEG(this._architecture.name);\n        await this._bundleImageMagick(this._architecture.name);\n        await this._bundleKindleGenerate(this._architecture.name);\n        await this._editResource();\n\n        let zip = this._dirBuildRoot + '.zip';\n        await fs.remove(zip);\n        await this._compressArchive('.\\\\' + this._dirBuildRoot, zip);\n    }\n\n    /**\n     *\n     * @param {bool} portable\n     */\n    async _bundleElectron(portable) {\n        console.log('Bundle electron ...');\n        let folder = this._stagingExecutableDirectory;\n        await this._downloadElectron(this._configuration.version, this._architecture.platform, folder);\n        await fs.remove(path.join(folder, 'resources', 'default_app.asar'));\n        if(portable) {\n            this._saveFile(path.join(folder, this._configuration.binary.windows + '.portable'), 'Delete this File to disable Portable Mode');\n        }\n        await asar.createPackage(config.src, path.join(folder, 'resources', 'app.asar'));\n        await fs.move(path.join(folder, 'electron.exe'), path.join(folder, this._configuration.binary.windows));\n    }\n\n    /**\n     *\n     */\n    async _editResource() {\n        let command = [\n            path.join('node_modules', 'rcedit', 'bin', 'rcedit.exe'),\n            `\"${path.join(this._dirBuildRoot, this._configuration.binary.windows)}\"`,\n            `--set-version-string \"ProductName\" \"${this._configuration.name.product}\"`,\n            `--set-version-string \"CompanyName\" \"\"`,\n            `--set-version-string \"LegalCopyright\" \"${(new Date()).getFullYear()}\"`,\n            `--set-version-string \"FileDescription\" \"${this._configuration.description.short}\"`,\n            `--set-version-string \"InternalName\" \"\"`,\n            `--set-version-string \"OriginalFilename\" \"${this._configuration.binary.windows}\"`,\n            `--set-file-version \"${this._configuration.version}\"`,\n            `--set-product-version \"${this._configuration.version}\"`,\n            `--set-icon \"redist\\\\iss\\\\app.ico\"`\n        ].join(' ');\n        await this._executeCommand(command);\n    }\n\n    /**\n     *\n     * @param {bool} is64\n     */\n    _createScriptIS(is64) {\n        console.log('Creating InnoSetup Script ...');\n        let file = path.join('build', 'setup.iss');\n        let content = [\n            '[Setup]',\n            'AppName=' + this._configuration.name.product,\n            'AppVerName=' + this._configuration.name.product,\n            'AppVersion=' + this._configuration.version,\n            'VersionInfoVersion=' + this._configuration.version,\n            'AppPublisher=' + this._configuration.author,\n            'AppPublisherURL=' + this._configuration.url,\n            (is64 ? '' : ';') + 'ArchitecturesInstallIn64BitMode=x64',\n            'DisableWelcomePage=yes',\n            'DefaultDirName=' + path.join('{pf}', this._configuration.name.product),\n            'DisableProgramGroupPage=yes',\n            //'DefaultGroupName=' + this._configuration.name.product,\n            'DisableReadyPage=yes',\n            'UninstallDisplayIcon=' + path.join('{app}', this._configuration.binary.windows),\n            //'WizardImageFile=compiler:wizmodernimage.bmp',\n            //'WizardSmallImageFile=compiler:wizmodernsmallimage.bmp',\n            'WizardImageFile=' + path.join('..', 'redist', 'iss', 'wizard.bmp'),\n            'WizardSmallImageFile=' + path.join('..', 'redist', 'iss', 'wizard-small.bmp'),\n            'OutputDir=.',\n            'OutputBaseFilename=' + path.basename(this._dirBuildRoot),\n            'ChangesEnvironment=yes',\n            '',\n            '[Tasks]',\n            'Name: shortcuts; Description: \"All\"; GroupDescription: \"Create Shortcuts:\";',\n            'Name: shortcuts\\\\desktop; Description: \"Desktop\"; GroupDescription: \"Create Shortcuts:\";',\n            'Name: shortcuts\\\\startmenu; Description: \"Startmenu Programs\"; GroupDescription: \"Create Shortcuts:\"; Flags: unchecked',\n            '',\n            '[Files]',\n            `Source: ${path.basename(this._dirBuildRoot)}\\\\*; DestDir: {app}; Flags: recursesubdirs`,\n            '',\n            '[UninstallDelete]',\n            'Name: {app}; Type: filesandordirs',\n            '',\n            '[Icons]',\n            `Name: \"{commondesktop}\\\\${this._configuration.name.product}\"; Tasks: shortcuts\\\\desktop; Filename: \"{app}\\\\${this._configuration.binary.windows}\";`,\n            `Name: \"{commonstartmenu}\\\\${this._configuration.name.product}\"; Tasks: shortcuts\\\\startmenu; Filename: \"{app}\\\\${this._configuration.binary.windows}\";`\n        ];\n        this._saveFile(file, content.join(eol), false);\n        return file;\n    }\n}\n\n/**\n * Packager for windows platform\n */\nclass ElectronPackagerDarwin extends ElectronPackager {\n\n    /**\n     *\n     */\n    constructor(configuration) {\n        super(configuration);\n        this.architectures = {\n            '64': {\n                dmg: {\n                    name: 'amd64',\n                    suffix: 'macos_amd64',\n                    platform: 'darwin-x64'\n                }\n            }\n        };\n        this._architecture = this.architectures[0];\n    }\n\n    /**\n     *\n     */\n    get _dirBuildRoot() {\n        return path.join('build', `${this._configuration.name.package}_${this._configuration.version}_${this._architecture.suffix}`);\n    }\n\n    /**\n     *\n     */\n    get _stagingExecutableDirectory() {\n        return path.join(this._dirBuildRoot, this._configuration.name.product + '.app', 'Contents', 'MacOS');\n    }\n\n    _wait(milliseconds) {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(), milliseconds);\n        });\n    }\n\n    /**\n     *\n     * @param {string} architecture '64'\n     */\n    async build(architecture) {\n        await this.buildDMG(architecture);\n    }\n\n    /**\n     * Create InnoSetup installer\n     * @param {string} architecture\n     */\n    async buildDMG(architecture) {\n        this._architecture = this.architectures[architecture].dmg;\n\n        await this._validateCommands('hdiutil info');\n\n        await fs.remove(this._dirBuildRoot);\n        await this._bundleElectron(false);\n        await this._bundleFFMPEG(this._architecture.name);\n        await this._bundleImageMagick(this._architecture.name);\n        await this._bundleKindleGenerate(this._architecture.name);\n        await this._createPList();\n\n        let dmg = this._dirBuildRoot + '.dmg';\n        await fs.remove(dmg);\n        let tmp = this._dirBuildRoot + '.tmp';\n        await fs.remove(tmp + '.dmg');\n        await this._executeCommand(`hdiutil create -volname \"${this._configuration.name.product}\" -srcfolder \"${this._dirBuildRoot}\" -fs \"HFS+\" -fsargs \"-c c=64,a=16,e=16\" -format \"UDRW\" \"${tmp}\"`);\n        let device = (await this._executeCommand(`hdiutil attach -readwrite -noverify -noautoopen \"${tmp}.dmg\" | egrep '^/dev/' | sed 1q | awk '{print $1}'`)).trim();\n        await this._wait(5000);\n        await this._executeCommand(`echo '${this._appleScript}' | osascript`);\n        await this._executeCommand(`chmod -Rf go-w \"/Volumes/${this._configuration.name.product}\"`);\n        await this._executeCommand(`sync`);\n        await this._wait(5000);\n        await this._executeCommand(`hdiutil detach \"${device}\"`);\n        await this._wait(5000);\n        await this._executeCommand(`hdiutil convert \"${tmp}.dmg\" -format \"UDZO\" -imagekey zlib-level=9 -o \"${dmg}\"`);\n        await fs.remove(tmp + '.dmg');\n    }\n\n    /**\n     *\n     */\n    async _bundleElectron() {\n        console.log('Bundle electron ...');\n        let folder = path.join(this._dirBuildRoot, 'Electron.app', 'Contents');\n        await this._downloadElectron(this._configuration.version, this._architecture.platform, this._dirBuildRoot);\n        await fs.remove(path.join(folder, 'Resources', 'default_app.asar'));\n        await asar.createPackage(config.src, path.join(folder, 'Resources', 'app.asar'));\n        await fs.move(path.join(folder, 'MacOS', 'Electron'), path.join(folder, 'MacOS', this._configuration.binary.darwin));\n        await fs.remove(path.join(folder, 'Resources', 'electron.icns'));\n        await fs.copy('res/icon.icns', path.join(folder, 'Resources', this._configuration.binary.darwin + '.icns'));\n        await fs.ensureDir(path.join(this._dirBuildRoot, '.images'));\n        await fs.copy('res/OSXSetup.png', path.join(this._dirBuildRoot, '.images', 'OSXSetup.png'));\n        await fs.move(path.join(this._dirBuildRoot, 'Electron.app'), path.join(this._dirBuildRoot, this._configuration.name.product + '.app'));\n    }\n\n    /**\n     *\n     */\n    _createPList() {\n        console.log('Creating P-List Info ...');\n        let file = path.join(this._dirBuildRoot, this._configuration.name.product + '.app', 'Contents', 'Info.plist');\n        let content = [\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n            '<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">',\n            '<plist version=\"1.0\">',\n            '<dict>',\n            '\t<key>CFBundleDisplayName</key>',\n            `\t<string>${this._configuration.name.product}</string>`,\n            // execytable is required\n            '\t<key>CFBundleExecutable</key>',\n            `\t<string>${this._configuration.binary.darwin}</string>`,\n            // icon file is required\n            '\t<key>CFBundleIconFile</key>',\n            `\t<string>${this._configuration.binary.darwin}.icns</string>`,\n            '\t<key>CFBundleIdentifier</key>',\n            `\t<string>${this._configuration.url}</string>`,\n            '\t<key>CFBundleName</key>',\n            `\t<string>${this._configuration.name.product}</string>`,\n            '\t<key>CFBundlePackageType</key>',\n            '\t<string>APPL</string>',\n            '\t<key>CFBundleShortVersionString</key>',\n            `\t<string>${this._configuration.version}</string>`,\n            '\t<key>CFBundleVersion</key>',\n            `\t<string>${this._configuration.version}</string>`,\n            '\t<key>LSMinimumSystemVersion</key>',\n            '\t<string>10.10.0</string>',\n            '\t<key>NSHighResolutionCapable</key>',\n            '\t<true/>',\n            '</dict>',\n            '</plist>'\n        ];\n        this._saveFile(file, content.join(eol), false);\n        return file;\n    }\n\n    get _appleScript() {\n        return `\n        tell application \"Finder\"\n            tell disk \"${this._configuration.name.product}\"\n                open\n                set current view of container window to icon view\n                set toolbar visible of container window to false\n                set statusbar visible of container window to false\n                set the bounds of container window to {100, 100, 560, 620}\n                set theViewOptions to the icon view options of container window\n                set arrangement of theViewOptions to not arranged\n                set icon size of theViewOptions to 64\n                set background picture of theViewOptions to file \".images:OSXSetup.png\"\n                make new alias file at container window to POSIX file \"/Applications\" with properties {name:\"Applications\"}\n                set position of item \"'${this._configuration.name.product}'\" of container window to {360, 180}\n                set position of item \"Applications\" of container window to {360, 390}\n                set position of item \".fseventsd\" of container window to {180, 620}\n                set position of item \".images\" of container window to {280, 620}\n                update without registering applications\n                delay 5\n                close\n            end tell\n        end tell\n        `;\n    }\n}\n\n/**\n *\n */\nasync function main() {\n    if(process.platform === 'win32') {\n        let packager = new ElectronPackagerWindows(config);\n        await packager.buildIS('64');\n        await packager.buildIS('32');\n        await packager.buildZIP('64');\n        await packager.buildZIP('32');\n    }\n    if(process.platform === 'linux') {\n        let packager = new ElectronPackagerLinux(config);\n        await packager.buildDEB('64');\n        await packager.buildDEB('32');\n        await packager.buildDEB('ARMv8');\n        await packager.buildDEB('ARMHF');\n        await packager.buildDEB('ARMv7');\n        await packager.buildRPM('64');\n        await packager.buildRPM('32');\n    }\n    if(process.platform === 'darwin') {\n        let packager = new ElectronPackagerDarwin(config);\n        await packager.buildDMG('64');\n    }\n}\n\n// exit application as soon as any uncaught exception is thrown\nprocess.on('unhandledRejection', error => { throw error; });\nmain();"
        },
        {
          "name": "build-web.config",
          "type": "blob",
          "size": 0.544921875,
          "content": "module.exports = {\n    source: 'src/web',\n    target: 'build/web',\n    version: 'mjs/VersionInfo.mjs',\n    polymer: {\n        entrypoint: 'index.html',\n        shell: '',\n        fragments: [\n            'lib/hakuneko/frontend@classic-light/app.html',\n            'lib/hakuneko/frontend@classic-dark/app.html'\n        ],\n        sources: [\n            'js/**/*',\n            'img/**/*',\n            'css/**/*',\n            'index.html',\n            'mjs/**/*'\n        ],\n        extraDependencies: [\n            'lib/webcomponentsjs/*-*.js'\n        ]\n    }\n}"
        },
        {
          "name": "build-web.js",
          "type": "blob",
          "size": 2.8916015625,
          "content": "const path = require('path');\nconst fs = require('fs-extra');\nconst exec = require('child_process').exec;\nconst vinyl = require('vinyl-fs');\nconst mergeStream = require('merge-stream');\nconst PolymerProject = require('polymer-build').PolymerProject;\nconst config = require('./build-web.config');\nconfig.source = config.source || 'src';\nconfig.target = config.target || 'build';\n\nfunction execute(command, silent) {\n    if(!silent) {\n        console.log('>', command);\n    }\n    return new Promise((resolve, reject) => {\n        exec(command, (error, stdout, stderr) => {\n            if(!silent) {\n                console.log(stdout);\n                console.log(stderr);\n            }\n            if(error) {\n                reject(error);\n            } else {\n                resolve(stdout);\n            }\n        });\n    });\n}\n\nasync function gitStashPush(identifier) {\n    identifier = identifier || 'DEPLOY#' + Date.now().toString(16).toUpperCase();\n    await execute(`git stash push -u -m '${identifier}'`);\n    return identifier;\n}\n\nasync function gitStashPop(identifier) {\n    let out = await execute(`git stash list`);\n    if(out.includes(identifier)) {\n        await execute(`git stash pop`);\n    }\n}\n\nfunction pipe(streamReader, streamWriter) {\n    return new Promise((resolve, reject) => {\n        let stream = streamReader.pipe(streamWriter);\n        stream.on('error', reject);\n        stream.on('end', resolve);\n    });\n}\n\nasync function polymerBuild(settings) {\n    let target = path.resolve(config.target);\n    let cwd = process.cwd();\n    if(config.source) {\n        process.chdir(config.source);\n    }\n\n    let project = new PolymerProject(settings);\n    let streamIn = mergeStream(project.sources(), project.dependencies());\n    let streamOut = vinyl.dest(target);\n    await pipe(streamIn, streamOut);\n\n    process.chdir(cwd);\n}\n\nasync function createVersionInfo(file) {\n    let branch = /*process.env.GITHUB_REF ? process.env.GITHUB_REF.split('/').pop() : */(await execute(`git rev-parse --abbrev-ref HEAD`)).trim();\n    let revision = (await execute(`git rev-parse HEAD`)).trim();\n    let content = [\n        `export default {`,\n        `    branch: {`,\n        `        label: '${branch}',`,\n        `        link: 'https://github.com/manga-download/hakuneko/commits/${branch}',`,\n        `    },`,\n        `    revision: {`,\n        `        label: '${revision.slice(0, 6)}',`,\n        `        link: 'https://github.com/manga-download/hakuneko/commits/${revision}',`,\n        `    }`,\n        `};`\n    ].join('\\n');\n    await fs.writeFile(file, content);\n}\n\nasync function main() {\n    let stashID = await gitStashPush();\n    await fs.remove(config.target);\n    await polymerBuild(config.polymer);\n    await createVersionInfo(path.join(config.target, config.version));\n    await gitStashPop(stashID);\n}\n\n// exit application as soon as any uncaught exception is thrown\nprocess.on('unhandledRejection', error => { throw error; });\nmain();"
        },
        {
          "name": "deploy-web.config",
          "type": "blob",
          "size": 0.5625,
          "content": "module.exports = {\n    key: 'key.pem',\n    passphrase: 'env:HAKUNEKO_PASSPHRASE',\n    build: './build/web',\n    branch: 'gh-pages',\n    /**\n     * Name of the directory within the deployment branch in which the artifacts will be placed\n     * The deployment directory must match the `applicationStartupURL` configuration in the desktop client\n     * e.g.\n     * 'https://manga-download.gihub.io/hakuneko/master/latest'\n     * 'https://manga-download.gihub.io/hakuneko/6.1.7/latest'\n     */\n    directory: './' + process.env.GITHUB_REF.split('/').pop() // current branch name\n}"
        },
        {
          "name": "deploy-web.js",
          "type": "blob",
          "size": 4.044921875,
          "content": "const path = require('path');\nconst fs = require('fs-extra');\nconst exec = require('child_process').exec;\nconst config = require('./deploy-web.config');\n\nfunction execute(command, silent) {\n    if(!silent) {\n        console.log('>', command);\n    }\n    return new Promise((resolve, reject) => {\n        exec(command, (error, stdout, stderr) => {\n            if(!silent) {\n                console.log(stdout);\n                console.log(stderr);\n            }\n            if(error) {\n                reject(error);\n            } else {\n                resolve(stdout);\n            }\n        });\n    });\n}\n\nfunction validateEnvironment() {\n    if(!process.env.GITHUB_ACTOR) {\n        throw new Error('Missing environment variable \"GITHUB_ACTOR\" providing the contributor name!');\n    }\n    if(!process.env.GITHUB_TOKEN) {\n        throw new Error('Missing environment variable \"GITHUB_TOKEN\" to provide access to the git repository!');\n    }\n    if(!process.env.HAKUNEKO_PASSPHRASE) {\n        throw new Error('Missing environment variable \"HAKUNEKO_PASSPHRASE\" to decrypt private key for signature!');\n    }\n}\n\nasync function gitStashPush(identifier) {\n    identifier = identifier || 'HTDOCS#' + Date.now().toString(16).toUpperCase();\n    await execute(`git stash push -u -m '${identifier}'`);\n    return identifier;\n}\n\nasync function gitStashPop(identifier) {\n    let out = await execute(`git stash list`);\n    if(out.includes(identifier)) {\n        await execute(`git stash pop`);\n    }\n}\n\nasync function sslPack(archive, meta) {\n    let key = path.resolve(config.key);\n    let cwd = process.cwd();\n    if(config.build) {\n        process.chdir(config.build);\n    }\n    await execute(`zip -r ${archive} . > /dev/null`);\n    let signature = await execute(`openssl dgst -sha256 -hex -sign ${key} -passin ${config.passphrase} ${archive} | cut -d' ' -f2`);\n    await fs.writeFile(meta, `${archive}?signature=${signature}`);\n    process.chdir(cwd);\n}\n\nasync function gitCommit() {\n    let user = process.env.GITHUB_ACTOR;\n    let mail = user + '@users.noreply.github.com';\n    let auth = Buffer.from('x-access-token:' + process.env.GITHUB_TOKEN).toString('base64');\n    await execute(`git add ${config.directory}/*`);\n    await execute(`git -c user.name=\"${user}\" -c user.email=\"${mail}\" commit -m 'Deployed Release: ${config.directory}'`);\n    await execute(`git -c http.extraheader=\"AUTHORIZATION: Basic ${auth}\" push origin HEAD:${config.branch}`);\n    // NOTE: Workaround to trigger page build (which is not done for public repositories by the commit above)\n    // https://developer.github.com/v3/repos/pages/#request-a-page-build\n    // See:\n    // - https://github.community/t5/GitHub-Actions/Github-action-not-triggering-gh-pages-upon-push/td-p/26869\n    // - https://github.com/peaceiris/actions-gh-pages/issues/9\n    let uri = `https://api.github.com/repos/manga-download/hakuneko/pages/builds`;\n    await execute(`curl --silent -L -X POST -H \"Content-Type: application/json\" -H \"Authorization: TOKEN ${process.env.HAKUNEKO_TOKEN}\" ${uri}`)\n}\n\nasync function main() {\n    validateEnvironment();\n    let meta = 'latest';\n    let archive = Date.now().toString(36).toUpperCase() + '.zip';\n    await sslPack(archive, meta);\n    await fs.remove(config.directory);\n    await fs.mkdir(config.directory);\n    await fs.move(path.resolve(config.build, meta), path.resolve(config.directory, meta));\n    await fs.move(path.resolve(config.build, archive), path.resolve(config.directory, archive));\n    let stashID = await gitStashPush();\n    await execute(`git fetch origin ${config.branch}`); // await execute(`git -c protocol.version=2 fetch --no-tags --prune --progress --no-recurse-submodules --depth=1 origin +gh-pages:refs/remotes/origin/gh-pages`);\n    await execute(`git checkout ${config.branch}`); // await execute(`git checkout --progress --force -B gh-pages refs/remotes/origin/gh-pages`);\n    await execute(`git rm -r ${config.directory} || true`);\n    await gitStashPop(stashID);\n    await gitCommit();\n}\n\n// exit application as soon as any uncaught exception is thrown\nprocess.on('unhandledRejection', error => { throw error; });\nmain();"
        },
        {
          "name": "key.pem",
          "type": "blob",
          "size": 1.724609375,
          "content": "-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-256-CBC,3B15F6E6C492AF7E01C6EED908FFEB27\n\nsHGLysGfMhIqTVbxjmZ6+fRBsMXoncJyc8WVvzYmjBwO/C0lln8LxptyAG1eUw81\nsU5KGLtodGZ0lz0mv4/jkqfPfqWo8Vkle+unJ4+klwAzZyyH5OgAkweXk8v0H9Sv\nJdunRKsOEWHUnG2PrgjUxtCQHxfv+0uXI4r5To2harvgHRADeV16257FcMAihEB4\nLhP2JnWLu97G70QSlre50gpSHQyTDA3/6oU09LN5oUnUaxTic219PvdBdhOtNCNa\nlyx4UugFTN3OTVh0463IUDPDt2hZKQL7MA8+HUwL8OE4nfbmZ1gJUnmzyE0wU36b\nVhNnk85Qpoq69IFqYPBAOaPlWqhTTAtQX+BKUS8lo0NStdTNRrkepOMztBDnNy/z\nVGDahcH5uIeJ4xUoPZ5ALI4hze1awrAWVbcB9v/jTD6sO/rVRphi5BGM1gyxngK+\nQEDyBEwh6dYCSfN+bl5i+tgclceBVN2OQZtadu0QAPovlJMIaYhCkHrGAAVEDUuY\n8ZslQluosuDVXPSPo9NhofBg4eqy4rfzPuZig88mmPEa3odi2J5ANbu8aorDCkNI\nUxX4JeIvNT/TJOYIE9+crbHUso5+qww0kggd8BowM+FILZFhM06y+8b+G5F4gU0M\n1YxI4EN4wpZQKoDNy/RDYRRfIgnHp6RJvD1uOYAvtbgvHKcdP/mYVff+IKX86nD2\nndW1dcmIP5YwAK4pOF/dve5DDQImXsMpf8qzuVbNMH37A+Vy5Q4soFotHwd6jEZw\nY1sV5aFrTos0Q/kzIFMfKiHDtb36gwyZ5fmsD3afaLL1UthvUPDPF2zxUEHjoXlm\nUbci9CNpsjqeYQepsQkxUb30LBHXMWY9ZGtyk4hvu9lom5LoMd7JJsXJ4WYQm1qY\n/2XzlA/roNcFz5Vuzlhswcv6qQSwpdXlAyx312zCkIb6HTHWrUde/eP4kOW0torQ\nwyCvavdPDHkuZhM+w4RWgZqwrlmr9NCwwFtir9QTsj+oQEpqEmxNybAfwV6xLISO\nTq1tDgagTsyrF4FgCz8X9ZdoZnqxWsRjIMTluxOqnbGlF7blhrbsMK+700FPF6Su\nCL5hqi3T8oTFp8/pdGCl+7TuWg2uFstoaBLg4740HbfFGtacbyZUYd5VcXNLaTRm\nwRprylc1O1ovqtcQqPS5YynqbOlTMcaR3u/0as8r8K9a/8/GEBgaxasefEOS51/M\nmq7MsLfxuW2pKFoJcmE4rbGnfCfS1uZ8WpsuTsyy827n/Xaum7gXQ/cDERtXD8Re\nFyXLjIU2dODDWnPUWOnoRJKDQ2e5zEknpgIjSwmvzB0UIQ5vLweIa8Xc+IDBgFV+\nwGgTffli3xy1vPFMnzM1iqVwzSatjWHzFbxq/impQdRDlngbIj+2IWCvVz8GdQU2\n4pEbVsm1VtgltsM5nE7sTrbq3mthxjX90v8bsDbbWmoboOYMkMqWPK6kpkxmxaBK\nbw3i1oZEWFi6sut1FDuikTkJTA7z7fFGUanIYQpBZtLUtNC+VqFblo38zIrsSMxJ\nf7AId3Dfq+ML6Jy5lcpBFrTquIgqokxYDtUC6XkSCqy/xDaUD5f2E2riKg0aEP1M\n-----END RSA PRIVATE KEY-----\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 2.0263671875,
          "content": "{\n  \"name\": \"hakuneko-dev\",\n  \"version\": \"1.0.0\",\n  \"description\": \"HakuNeko\",\n  \"author\": \"The HakuNeko Development Team <https://github.com/orgs/manga-download/people>\",\n  \"license\": \"Unlicense\",\n  \"main\": \"src/app/main.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://git.io/hakuneko\"\n  },\n  \"devDependencies\": {\n    \"@hakuneko/ffmpeg-binaries\": \"latest\",\n    \"@hakuneko/imagemagick-binaries\": \"latest\",\n    \"@hakuneko/kindlegen-binaries\": \"latest\",\n    \"@logtrine/logtrine\": \"latest\",\n    \"asar\": \"latest\",\n    \"discord-rpc\": \"latest\",\n    \"electron\": \"8.3.4\",\n    \"eslint\": \"^8.57.0\",\n    \"fs-extra\": \"latest\",\n    \"innosetup-compiler\": \"latest\",\n    \"jest\": \"latest\",\n    \"jest-junit\": \"latest\",\n    \"jszip\": \"latest\",\n    \"polymer-build\": \"latest\",\n    \"puppeteer-core\": \"latest\",\n    \"rcedit\": \"latest\",\n    \"win-7zip\": \"latest\"\n  },\n  \"scripts\": {\n    \"postinstall\": \"cd src/app && npm install --no-optional\",\n    \"start\": \"npm run start:dev\",\n    \"start:dev\": \"electron . --update-url=DISABLED --cache-directory=./src/web --disable-http-cache\",\n    \"start:build\": \"npm run build:web && electron . --update-url=DISABLED --cache-directory=./build/latest\",\n    \"lint\": \"npm run lint:app && npm run lint:web\",\n    \"lint:app\": \"eslint ./src/app --ignore-path .gitignore\",\n    \"lint:web\": \"eslint ./src/web/mjs/**/*.mjs --ignore-path .gitignore --parser-options ecmaVersion:2020\",\n    \"format\": \"npm run format:app && npm run format:web\",\n    \"format:app\": \"npm run lint:app -- --fix\",\n    \"format:web\": \"npm run lint:web -- --fix\",\n    \"build:app\": \"node build-app.js\",\n    \"build:web\": \"node build-web.js\",\n    \"deploy:web\": \"npm run build:web && node deploy-web.js\",\n    \"test\": \"jest --color --reporters=default --reporters=jest-junit\",\n    \"test:app\": \"jest --color --reporters=default --reporters=jest-junit --testPathPattern=/src/app\",\n    \"test:web\": \"jest --color --reporters=default --reporters=jest-junit --testPathPattern=/src/web\",\n    \"test:e2e\": \"jest --color --reporters=default --reporters=jest-junit --testPathPattern=/src/__tests__\"\n  }\n}\n"
        },
        {
          "name": "redist",
          "type": "tree",
          "content": null
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}