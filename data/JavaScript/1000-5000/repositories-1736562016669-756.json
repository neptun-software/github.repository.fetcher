{
  "metadata": {
    "timestamp": 1736562016669,
    "page": 756,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "primus/eventemitter3",
      "stars": 3367,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0400390625,
          "content": "node_modules/\ncoverage/\ndist/\n.tern-port\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Arnout Kazemier\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.349609375,
          "content": "# EventEmitter3\n\n[![Version npm](https://img.shields.io/npm/v/eventemitter3.svg?style=flat-square)](https://www.npmjs.com/package/eventemitter3)[![CI](https://img.shields.io/github/actions/workflow/status/primus/eventemitter3/ci.yml?branch=master&label=CI&style=flat-square)](https://github.com/primus/eventemitter3/actions?query=workflow%3ACI+branch%3Amaster)[![Coverage Status](https://img.shields.io/coveralls/primus/eventemitter3/master.svg?style=flat-square)](https://coveralls.io/r/primus/eventemitter3?branch=master)\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/eventemitter3.svg)](https://saucelabs.com/u/eventemitter3)\n\nEventEmitter3 is a high performance EventEmitter. It has been micro-optimized\nfor various of code paths making this, one of, if not the fastest EventEmitter\navailable for Node.js and browsers. The module is API compatible with the\nEventEmitter that ships by default with Node.js but there are some slight\ndifferences:\n\n- Domain support has been removed.\n- We do not `throw` an error when you emit an `error` event and nobody is\n  listening.\n- The `newListener` and `removeListener` events have been removed as they\n  are useful only in some uncommon use-cases.\n- The `setMaxListeners`, `getMaxListeners`, `prependListener` and\n  `prependOnceListener` methods are not available.\n- Support for custom context for events so there is no need to use `fn.bind`.\n- The `removeListener` method removes all matching listeners, not only the\n  first.\n\nIt's a drop in replacement for existing EventEmitters, but just faster. Free\nperformance, who wouldn't want that? The EventEmitter is written in EcmaScript 3\nso it will work in the oldest browsers and node versions that you need to\nsupport.\n\n## Installation\n\n```bash\n$ npm install --save eventemitter3\n```\n\n## CDN\n\nRecommended CDN:\n\n```text\nhttps://unpkg.com/eventemitter3@latest/dist/eventemitter3.umd.min.js\n```\n\n## Usage\n\nAfter installation the only thing you need to do is require the module:\n\n```js\nvar EventEmitter = require('eventemitter3');\n```\n\nAnd you're ready to create your own EventEmitter instances. For the API\ndocumentation, please follow the official Node.js documentation:\n\nhttp://nodejs.org/api/events.html\n\n### Contextual emits\n\nWe've upgraded the API of the `EventEmitter.on`, `EventEmitter.once` and\n`EventEmitter.removeListener` to accept an extra argument which is the `context`\nor `this` value that should be set for the emitted events. This means you no\nlonger have the overhead of an event that required `fn.bind` in order to get a\ncustom `this` value.\n\n```js\nvar EE = new EventEmitter()\n  , context = { foo: 'bar' };\n\nfunction emitted() {\n  console.log(this === context); // true\n}\n\nEE.once('event-name', emitted, context);\nEE.on('another-event', emitted, context);\nEE.removeListener('another-event', emitted, context);\n```\n\n### Tests and benchmarks\n\nThis module is well tested. You can run:\n\n- `npm test` to run the tests under Node.js.\n- `npm run test-browser` to run the tests in real browsers via Sauce Labs.\n\nWe also have a set of benchmarks to compare EventEmitter3 with some available\nalternatives. To run the benchmarks run `npm run benchmark`.\n\nTests and benchmarks are not included in the npm package. If you want to play\nwith them you have to clone the GitHub repository.\nNote that you will have to run an additional `npm i` in the benchmarks folder\nbefore `npm run benchmark`.\n\n## License\n\n[MIT](LICENSE)\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.d.ts",
          "type": "blob",
          "size": 3.41796875,
          "content": "/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n */\ndeclare class EventEmitter<\n  EventTypes extends EventEmitter.ValidEventTypes = string | symbol,\n  Context extends any = any\n> {\n  static prefixed: string | boolean;\n\n  /**\n   * Return an array listing the events for which the emitter has registered\n   * listeners.\n   */\n  eventNames(): Array<EventEmitter.EventNames<EventTypes>>;\n\n  /**\n   * Return the listeners registered for a given event.\n   */\n  listeners<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T\n  ): Array<EventEmitter.EventListener<EventTypes, T>>;\n\n  /**\n   * Return the number of listeners listening to a given event.\n   */\n  listenerCount(event: EventEmitter.EventNames<EventTypes>): number;\n\n  /**\n   * Calls each of the listeners registered for a given event.\n   */\n  emit<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    ...args: EventEmitter.EventArgs<EventTypes, T>\n  ): boolean;\n\n  /**\n   * Add a listener for a given event.\n   */\n  on<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>,\n    context?: Context\n  ): this;\n  addListener<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>,\n    context?: Context\n  ): this;\n\n  /**\n   * Add a one-time listener for a given event.\n   */\n  once<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn: EventEmitter.EventListener<EventTypes, T>,\n    context?: Context\n  ): this;\n\n  /**\n   * Remove the listeners of a given event.\n   */\n  removeListener<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn?: EventEmitter.EventListener<EventTypes, T>,\n    context?: Context,\n    once?: boolean\n  ): this;\n  off<T extends EventEmitter.EventNames<EventTypes>>(\n    event: T,\n    fn?: EventEmitter.EventListener<EventTypes, T>,\n    context?: Context,\n    once?: boolean\n  ): this;\n\n  /**\n   * Remove all listeners, or those of the specified event.\n   */\n  removeAllListeners(event?: EventEmitter.EventNames<EventTypes>): this;\n}\n\ndeclare namespace EventEmitter {\n  export interface ListenerFn<Args extends any[] = any[]> {\n    (...args: Args): void;\n  }\n\n  export interface EventEmitterStatic {\n    new <\n      EventTypes extends ValidEventTypes = string | symbol,\n      Context = any\n    >(): EventEmitter<EventTypes, Context>;\n  }\n\n  /**\n   * `object` should be in either of the following forms:\n   * ```\n   * interface EventTypes {\n   *   'event-with-parameters': any[]\n   *   'event-with-example-handler': (...args: any[]) => void\n   * }\n   * ```\n   */\n  export type ValidEventTypes = string | symbol | object;\n\n  export type EventNames<T extends ValidEventTypes> = T extends string | symbol\n    ? T\n    : keyof T;\n\n  export type ArgumentMap<T extends object> = {\n    [K in keyof T]: T[K] extends (...args: any[]) => void\n      ? Parameters<T[K]>\n      : T[K] extends any[]\n      ? T[K]\n      : any[];\n  };\n\n  export type EventListener<\n    T extends ValidEventTypes,\n    K extends EventNames<T>\n  > = T extends string | symbol\n    ? (...args: any[]) => void\n    : (\n        ...args: ArgumentMap<Exclude<T, string | symbol>>[Extract<K, keyof T>]\n      ) => void;\n\n  export type EventArgs<\n    T extends ValidEventTypes,\n    K extends EventNames<T>\n  > = Parameters<EventListener<T, K>>;\n\n  export const EventEmitter: EventEmitterStatic;\n}\n\nexport { EventEmitter }\nexport default EventEmitter;\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 8.9267578125,
          "content": "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n"
        },
        {
          "name": "index.mjs",
          "type": "blob",
          "size": 0.0888671875,
          "content": "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.5478515625,
          "content": "{\n  \"name\": \"eventemitter3\",\n  \"version\": \"5.0.1\",\n  \"description\": \"EventEmitter3 focuses on performance while maintaining a Node.js AND browser compatible interface.\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./index.d.ts\",\n      \"import\": \"./index.mjs\",\n      \"require\": \"./index.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"main\": \"index.js\",\n  \"types\": \"index.d.ts\",\n  \"scripts\": {\n    \"rollup\": \"rm -rf dist && rollup -c\",\n    \"benchmark\": \"find benchmarks/run -name '*.js' -exec benchmarks/start.sh {} \\\\;\",\n    \"test\": \"c8 --reporter=lcov --reporter=text mocha test/test.js\",\n    \"test-esm\": \"mocha test/test.mjs\",\n    \"prepublishOnly\": \"npm run rollup\",\n    \"test-browser\": \"node test/browser.js\"\n  },\n  \"files\": [\n    \"index.js\",\n    \"index.mjs\",\n    \"index.d.ts\",\n    \"dist\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/primus/eventemitter3.git\"\n  },\n  \"keywords\": [\n    \"EventEmitter\",\n    \"EventEmitter2\",\n    \"EventEmitter3\",\n    \"Events\",\n    \"addEventListener\",\n    \"addListener\",\n    \"emit\",\n    \"emits\",\n    \"emitter\",\n    \"event\",\n    \"once\",\n    \"pub/sub\",\n    \"publish\",\n    \"reactor\",\n    \"subscribe\"\n  ],\n  \"author\": \"Arnout Kazemier\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/primus/eventemitter3/issues\"\n  },\n  \"devDependencies\": {\n    \"@rollup/plugin-commonjs\": \"^25.0.7\",\n    \"@rollup/plugin-terser\": \"^0.4.0\",\n    \"assume\": \"^2.2.0\",\n    \"c8\": \"^8.0.1\",\n    \"mocha\": \"^10.0.0\",\n    \"pre-commit\": \"^1.2.0\",\n    \"rollup\": \"^4.5.2\",\n    \"sauce-browsers\": \"^3.0.0\",\n    \"sauce-test\": \"^1.3.3\"\n  }\n}\n"
        },
        {
          "name": "rollup.config.mjs",
          "type": "blob",
          "size": 0.7578125,
          "content": "import commonjs from '@rollup/plugin-commonjs';\nimport terser from '@rollup/plugin-terser';\n\nexport default [{\n  input: './index.mjs',\n  output: {\n    file: 'dist/eventemitter3.esm.js',\n    format: 'es'\n  },\n  plugins: [commonjs()]\n}, {\n  input: './index.mjs',\n  output: {\n    compact: true,\n    file: 'dist/eventemitter3.esm.min.js',\n    format: 'es',\n    sourcemap: true\n  },\n  plugins: [commonjs(), terser()]\n}, {\n  input: './index.js',\n  output: {\n    file: 'dist/eventemitter3.umd.js',\n    format: 'umd',\n    name: 'EventEmitter3'\n  },\n  plugins: [commonjs()]\n}, {\n  input: './index.js',\n  output: {\n    compact: true,\n    file: 'dist/eventemitter3.umd.min.js',\n    format: 'umd',\n    name: 'EventEmitter3',\n    sourcemap: true\n  },\n  plugins: [commonjs(), terser()]\n}];\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}