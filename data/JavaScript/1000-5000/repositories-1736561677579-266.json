{
  "metadata": {
    "timestamp": 1736561677579,
    "page": 266,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "joewalnes/reconnecting-websocket",
      "stars": 4251,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.048828125,
          "content": "MIT License:\n\nCopyright (c) 2010-2012, Joe Walnes\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.5,
          "content": "ReconnectingWebSocket\n=====================\n\nA small JavaScript library that decorates the WebSocket API to provide a WebSocket connection that will automatically reconnect if the connection is dropped.\n\nIt is API compatible, so when you have:\n\n```javascript\nvar ws = new WebSocket('ws://....');\n```\n\nyou can replace with:\n\n```javascript\nvar ws = new ReconnectingWebSocket('ws://....');\n```\n\nMinified library with gzip compression is less than 600 bytes.\n\nHow reconnections occur\n-----------------------\n\nWith the standard `WebSocket` API, the events you receive from the WebSocket instance are typically:\n\n    onopen\n    onmessage\n    onmessage\n    onmessage\n    onclose // At this point the WebSocket instance is dead.\n\nWith a `ReconnectingWebSocket`, after an `onclose` event is called it will automatically attempt to reconnect. In addition, a connection is attempted repeatedly (with a small pause) until it succeeds. So the events you receive may look something more like:\n\n    onopen\n    onmessage\n    onmessage\n    onmessage\n    onclose\n    // ReconnectingWebSocket attempts to reconnect\n    onopen\n    onmessage\n    onmessage\n    onmessage\n    onclose\n    // ReconnectingWebSocket attempts to reconnect\n    onopen\n    onmessage\n    onmessage\n    onmessage\n    onclose\n\nThis is all handled automatically for you by the library.\n\n## Parameters\n\n```javascript\nvar socket = new ReconnectingWebSocket(url, protocols, options);\n```\n\n#### `url`\n- The URL you are connecting to.\n- https://html.spec.whatwg.org/multipage/comms.html#network\n\n#### `protocols`\n- Optional string or array of protocols per the WebSocket spec.\n- https://tools.ietf.org/html/rfc6455\n\n#### `options`\n- Options (see below)\n\n## Options\n\nOptions can either be passed as the 3rd parameter upon instantiation or set directly on the object after instantiation:\n\n```javascript\nvar socket = new ReconnectingWebSocket(url, null, {debug: true, reconnectInterval: 3000});\n```\n\nor\n\n```javascript\nvar socket = new ReconnectingWebSocket(url);\nsocket.debug = true;\nsocket.timeoutInterval = 5400;\n```\n\n#### `debug`\n- Whether this instance should log debug messages or not. Debug messages are printed to `console.debug()`.\n- Accepts `true` or `false`\n- Default value: `false`\n\n#### `automaticOpen`\n- Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n- Accepts `true` or `false`\n- Default value: `true`\n\n#### `reconnectInterval`\n- The number of milliseconds to delay before attempting to reconnect.\n- Accepts `integer`\n- Default: `1000`\n\n#### `maxReconnectInterval`\n- The maximum number of milliseconds to delay a reconnection attempt.\n- Accepts `integer`\n- Default: `30000`\n\n####`reconnectDecay`\n- The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist.\n- Accepts `integer` or `float`\n- Default: `1.5`\n\n#### `timeoutInterval`\n- The maximum time in milliseconds to wait for a connection to succeed before closing and retrying.\n- Accepts `integer`\n- Default: `2000`\n\n#### `maxReconnectAttempts`\n- The maximum number of reconnection attempts that will be made before giving up. If null, reconnection attempts will be continue to be made forever.\n- Accepts `integer` or `null`.\n- Default: `null`\n\n#### `binaryType`\n- The binary type is required by some applications.\n- Accepts strings `'blob'` or `'arraybuffer'`.\n- Default: `'blob'`\n\n---\n\n## Methods\n\n#### `ws.open()`\n- Open the Reconnecting Websocket\n\n#### `ws.close(code, reason)`\n- Closes the WebSocket connection or connection attempt, if any. If the connection is already CLOSED, this method does nothing.\n- `code` is optional the closing code (default value 1000). [https://tools.ietf.org/html/rfc6455#section-7.4.1](https://tools.ietf.org/html/rfc6455#section-7.4.1)\n- `reason` is the optional reason that the socket is being closed. [https://tools.ietf.org/html/rfc6455#section-7.1.6](https://tools.ietf.org/html/rfc6455#section-7.1.6)\n\n#### `ws.refresh()`\n- Refresh the connection if still open (close and then re-open it).\n\n#### `ws.send(data)`\n- Transmits data to the server over the WebSocket connection.\n- Accepts @param data a text string, ArrayBuffer or Blob\n\nLike this? Check out [websocketd](https://github.com/joewalnes/websocketd) for the simplest way to create WebSocket backends from any programming language.\n\n[Follow @joewalnes](https://twitter.com/joewalnes)\n\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/joewalnes/reconnecting-websocket/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\n"
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.51171875,
          "content": "{\n  \"name\": \"reconnectingWebsocket\",\n  \"main\": \"reconnecting-websocket.js\",\n  \"version\": \"1.0.1\",\n  \"homepage\": \"https://github.com/joewalnes/reconnecting-websocket\",\n  \"authors\": [\n    \"Joe Walnes\",\n    \"headlessme <contact@coggle.it>\"\n  ],\n  \"description\": \"A small decorator for the JavaScript WebSocket API that automatically reconnects\",\n  \"moduleType\": [\n    \"amd\",\n    \"globals\",\n    \"node\"\n  ],\n  \"license\": \"MIT\",\n  \"ignore\": [\n    \"**/.*\",\n    \"node_modules\",\n    \"bower_components\",\n    \"test\",\n    \"tests\"\n  ]\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.65234375,
          "content": "{\n  \"name\": \"ReconnectingWebSocket\",\n  \"version\": \"1.0.1\",\n  \"description\": \"A small JavaScript library that decorates the WebSocket API to provide a WebSocket connection that will automatically reconnect if the connection is dropped.\",\n  \"main\": \"reconnecting-websocket.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/joewalnes/reconnecting-websocket.git\"\n  },\n  \"author\": \"Joe Walnes\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/joewalnes/reconnecting-websocket/issues\"\n  },\n  \"homepage\": \"https://github.com/joewalnes/reconnecting-websocket\"\n}\n"
        },
        {
          "name": "reconnecting-websocket.js",
          "type": "blob",
          "size": 14.0908203125,
          "content": "// MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof module !== 'undefined' && module.exports){\n        module.exports = factory();\n    } else {\n        global.ReconnectingWebSocket = factory();\n    }\n})(this, function () {\n\n    if (!('WebSocket' in window)) {\n        return;\n    }\n\n    function ReconnectingWebSocket(url, protocols, options) {\n\n        // Default settings\n        var settings = {\n\n            /** Whether this instance should log debug messages. */\n            debug: false,\n\n            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\n            automaticOpen: true,\n\n            /** The number of milliseconds to delay before attempting to reconnect. */\n            reconnectInterval: 1000,\n            /** The maximum number of milliseconds to delay a reconnection attempt. */\n            maxReconnectInterval: 30000,\n            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\n            reconnectDecay: 1.5,\n\n            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\n            timeoutInterval: 2000,\n\n            /** The maximum number of reconnection attempts to make. Unlimited if null. */\n            maxReconnectAttempts: null,\n\n            /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */\n            binaryType: 'blob'\n        }\n        if (!options) { options = {}; }\n\n        // Overwrite and define settings with options if they exist.\n        for (var key in settings) {\n            if (typeof options[key] !== 'undefined') {\n                this[key] = options[key];\n            } else {\n                this[key] = settings[key];\n            }\n        }\n\n        // These should be treated as read-only properties\n\n        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\n        this.url = url;\n\n        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\n        this.reconnectAttempts = 0;\n\n        /**\n         * The current state of the connection.\n         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n         * Read only.\n         */\n        this.readyState = WebSocket.CONNECTING;\n\n        /**\n         * A string indicating the name of the sub-protocol the server selected; this will be one of\n         * the strings specified in the protocols parameter when creating the WebSocket object.\n         * Read only.\n         */\n        this.protocol = null;\n\n        // Private state variables\n\n        var self = this;\n        var ws;\n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n\n        // Wire up \"on*\" properties as event handlers\n\n        eventTarget.addEventListener('open',       function(event) { self.onopen(event); });\n        eventTarget.addEventListener('close',      function(event) { self.onclose(event); });\n        eventTarget.addEventListener('connecting', function(event) { self.onconnecting(event); });\n        eventTarget.addEventListener('message',    function(event) { self.onmessage(event); });\n        eventTarget.addEventListener('error',      function(event) { self.onerror(event); });\n\n        // Expose the API required by EventTarget\n\n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n        /**\n         * This function generates an event that is compatible with standard\n         * compliant browsers and IE9 - IE11\n         *\n         * This will prevent the error:\n         * Object doesn't support this action\n         *\n         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n         * @param s String The name that the event should use\n         * @param args Object an optional object that the event will use\n         */\n        function generateEvent(s, args) {\n        \tvar evt = document.createEvent(\"CustomEvent\");\n        \tevt.initCustomEvent(s, false, false, args);\n        \treturn evt;\n        };\n\n        this.open = function (reconnectAttempt) {\n            ws = new WebSocket(self.url, protocols || []);\n            ws.binaryType = this.binaryType;\n\n            if (reconnectAttempt) {\n                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {\n                    return;\n                }\n            } else {\n                eventTarget.dispatchEvent(generateEvent('connecting'));\n                this.reconnectAttempts = 0;\n            }\n\n            if (self.debug || ReconnectingWebSocket.debugAll) {\n                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);\n            }\n\n            var localWs = ws;\n            var timeout = setTimeout(function() {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);\n                }\n                timedOut = true;\n                localWs.close();\n                timedOut = false;\n            }, self.timeoutInterval);\n\n            ws.onopen = function(event) {\n                clearTimeout(timeout);\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onopen', self.url);\n                }\n                self.protocol = ws.protocol;\n                self.readyState = WebSocket.OPEN;\n                self.reconnectAttempts = 0;\n                var e = generateEvent('open');\n                e.isReconnect = reconnectAttempt;\n                reconnectAttempt = false;\n                eventTarget.dispatchEvent(e);\n            };\n\n            ws.onclose = function(event) {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    self.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(generateEvent('close'));\n                } else {\n                    self.readyState = WebSocket.CONNECTING;\n                    var e = generateEvent('connecting');\n                    e.code = event.code;\n                    e.reason = event.reason;\n                    e.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(e);\n                    if (!reconnectAttempt && !timedOut) {\n                        if (self.debug || ReconnectingWebSocket.debugAll) {\n                            console.debug('ReconnectingWebSocket', 'onclose', self.url);\n                        }\n                        eventTarget.dispatchEvent(generateEvent('close'));\n                    }\n\n                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);\n                    setTimeout(function() {\n                        self.reconnectAttempts++;\n                        self.open(true);\n                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);\n                }\n            };\n            ws.onmessage = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);\n                }\n                var e = generateEvent('message');\n                e.data = event.data;\n                eventTarget.dispatchEvent(e);\n            };\n            ws.onerror = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);\n                }\n                eventTarget.dispatchEvent(generateEvent('error'));\n            };\n        }\n\n        // Whether or not to create a websocket upon instantiation\n        if (this.automaticOpen == true) {\n            this.open(false);\n        }\n\n        /**\n         * Transmits data to the server over the WebSocket connection.\n         *\n         * @param data a text string, ArrayBuffer or Blob to send to the server.\n         */\n        this.send = function(data) {\n            if (ws) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'send', self.url, data);\n                }\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n\n        /**\n         * Closes the WebSocket connection or connection attempt, if any.\n         * If the connection is already CLOSED, this method does nothing.\n         */\n        this.close = function(code, reason) {\n            // Default CLOSE_NORMAL code\n            if (typeof code == 'undefined') {\n                code = 1000;\n            }\n            forcedClose = true;\n            if (ws) {\n                ws.close(code, reason);\n            }\n        };\n\n        /**\n         * Additional public API method to refresh the connection if still open (close, re-open).\n         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n         */\n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n\n    /**\n     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n     * this indicates that the connection is ready to send and receive data.\n     */\n    ReconnectingWebSocket.prototype.onopen = function(event) {};\n    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\n    ReconnectingWebSocket.prototype.onclose = function(event) {};\n    /** An event listener to be called when a connection begins being attempted. */\n    ReconnectingWebSocket.prototype.onconnecting = function(event) {};\n    /** An event listener to be called when a message is received from the server. */\n    ReconnectingWebSocket.prototype.onmessage = function(event) {};\n    /** An event listener to be called when an error occurs. */\n    ReconnectingWebSocket.prototype.onerror = function(event) {};\n\n    /**\n     * Whether all instances of ReconnectingWebSocket should log debug messages.\n     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n     */\n    ReconnectingWebSocket.debugAll = false;\n\n    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\n    ReconnectingWebSocket.OPEN = WebSocket.OPEN;\n    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\n    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\n\n    return ReconnectingWebSocket;\n});\n"
        },
        {
          "name": "reconnecting-websocket.min.js",
          "type": "blob",
          "size": 3.02734375,
          "content": "!function(a,b){\"function\"==typeof define&&define.amd?define([],b):\"undefined\"!=typeof module&&module.exports?module.exports=b():a.ReconnectingWebSocket=b()}(this,function(){function a(b,c,d){function l(a,b){var c=document.createEvent(\"CustomEvent\");return c.initCustomEvent(a,!1,!1,b),c}var e={debug:!1,automaticOpen:!0,reconnectInterval:1e3,maxReconnectInterval:3e4,reconnectDecay:1.5,timeoutInterval:2e3};d||(d={});for(var f in e)this[f]=\"undefined\"!=typeof d[f]?d[f]:e[f];this.url=b,this.reconnectAttempts=0,this.readyState=WebSocket.CONNECTING,this.protocol=null;var h,g=this,i=!1,j=!1,k=document.createElement(\"div\");k.addEventListener(\"open\",function(a){g.onopen(a)}),k.addEventListener(\"close\",function(a){g.onclose(a)}),k.addEventListener(\"connecting\",function(a){g.onconnecting(a)}),k.addEventListener(\"message\",function(a){g.onmessage(a)}),k.addEventListener(\"error\",function(a){g.onerror(a)}),this.addEventListener=k.addEventListener.bind(k),this.removeEventListener=k.removeEventListener.bind(k),this.dispatchEvent=k.dispatchEvent.bind(k),this.open=function(b){h=new WebSocket(g.url,c||[]),b||k.dispatchEvent(l(\"connecting\")),(g.debug||a.debugAll)&&console.debug(\"ReconnectingWebSocket\",\"attempt-connect\",g.url);var d=h,e=setTimeout(function(){(g.debug||a.debugAll)&&console.debug(\"ReconnectingWebSocket\",\"connection-timeout\",g.url),j=!0,d.close(),j=!1},g.timeoutInterval);h.onopen=function(){clearTimeout(e),(g.debug||a.debugAll)&&console.debug(\"ReconnectingWebSocket\",\"onopen\",g.url),g.protocol=h.protocol,g.readyState=WebSocket.OPEN,g.reconnectAttempts=0;var d=l(\"open\");d.isReconnect=b,b=!1,k.dispatchEvent(d)},h.onclose=function(c){if(clearTimeout(e),h=null,i)g.readyState=WebSocket.CLOSED,k.dispatchEvent(l(\"close\"));else{g.readyState=WebSocket.CONNECTING;var d=l(\"connecting\");d.code=c.code,d.reason=c.reason,d.wasClean=c.wasClean,k.dispatchEvent(d),b||j||((g.debug||a.debugAll)&&console.debug(\"ReconnectingWebSocket\",\"onclose\",g.url),k.dispatchEvent(l(\"close\")));var e=g.reconnectInterval*Math.pow(g.reconnectDecay,g.reconnectAttempts);setTimeout(function(){g.reconnectAttempts++,g.open(!0)},e>g.maxReconnectInterval?g.maxReconnectInterval:e)}},h.onmessage=function(b){(g.debug||a.debugAll)&&console.debug(\"ReconnectingWebSocket\",\"onmessage\",g.url,b.data);var c=l(\"message\");c.data=b.data,k.dispatchEvent(c)},h.onerror=function(b){(g.debug||a.debugAll)&&console.debug(\"ReconnectingWebSocket\",\"onerror\",g.url,b),k.dispatchEvent(l(\"error\"))}},1==this.automaticOpen&&this.open(!1),this.send=function(b){if(h)return(g.debug||a.debugAll)&&console.debug(\"ReconnectingWebSocket\",\"send\",g.url,b),h.send(b);throw\"INVALID_STATE_ERR : Pausing to reconnect websocket\"},this.close=function(a,b){\"undefined\"==typeof a&&(a=1e3),i=!0,h&&h.close(a,b)},this.refresh=function(){h&&h.close()}}return a.prototype.onopen=function(){},a.prototype.onclose=function(){},a.prototype.onconnecting=function(){},a.prototype.onmessage=function(){},a.prototype.onerror=function(){},a.debugAll=!1,a.CONNECTING=WebSocket.CONNECTING,a.OPEN=WebSocket.OPEN,a.CLOSING=WebSocket.CLOSING,a.CLOSED=WebSocket.CLOSED,a});\n"
        }
      ]
    }
  ]
}