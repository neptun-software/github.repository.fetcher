{
  "metadata": {
    "timestamp": 1736561945595,
    "page": 652,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fastify/fast-json-stringify",
      "stars": 3532,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.078125,
          "content": "# Set default behavior to automatically convert line endings\n* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.1591796875,
          "content": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\nlerna-debug.log*\n.pnpm-debug.log*\n\n# Diagnostic reports (https://nodejs.org/api/report.html)\nreport.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n*.lcov\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Bower dependency directory (https://bower.io/)\nbower_components\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (https://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules/\njspm_packages/\n\n# Snowpack dependency directory (https://snowpack.dev/)\nweb_modules/\n\n# TypeScript cache\n*.tsbuildinfo\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Optional stylelint cache\n.stylelintcache\n\n# Microbundle cache\n.rpt2_cache/\n.rts2_cache_cjs/\n.rts2_cache_es/\n.rts2_cache_umd/\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Yarn Integrity file\n.yarn-integrity\n\n# dotenv environment variable files\n.env\n.env.development.local\n.env.test.local\n.env.production.local\n.env.local\n\n# parcel-bundler cache (https://parceljs.org/)\n.cache\n.parcel-cache\n\n# Next.js build output\n.next\nout\n\n# Nuxt.js build / generate output\n.nuxt\ndist\n\n# Gatsby files\n.cache/\n# Comment in the public line in if your project uses Gatsby and not Next.js\n# https://nextjs.org/blog/next-9-1#public-directory-support\n# public\n\n# vuepress build output\n.vuepress/dist\n\n# vuepress v2.x temp and cache directory\n.temp\n.cache\n\n# Docusaurus cache and generated files\n.docusaurus\n\n# Serverless directories\n.serverless/\n\n# FuseBox cache\n.fusebox/\n\n# DynamoDB Local files\n.dynamodb/\n\n# TernJS port file\n.tern-port\n\n# Stores VSCode versions used for testing VSCode extensions\n.vscode-test\n\n# yarn v2\n.yarn/cache\n.yarn/unplugged\n.yarn/build-state.yml\n.yarn/install-state.gz\n.pnp.*\n\n# Vim swap files\n*.swp\n\n# macOS files\n.DS_Store\n\n# Clinic\n.clinic\n\n# lock files\nbun.lockb\npackage-lock.json\npnpm-lock.yaml\nyarn.lock\n\n# editor files\n.vscode\n.idea\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.060546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016-2018 Matteo Collina\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.5693359375,
          "content": "# fast-json-stringify\n\n[![CI](https://github.com/fastify/fast-json-stringify/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/fastify/fast-json-stringify/actions/workflows/ci.yml)\n[![NPM version](https://img.shields.io/npm/v/fast-json-stringify.svg?style=flat)](https://www.npmjs.com/package/fast-json-stringify)\n[![neostandard javascript style](https://img.shields.io/badge/code_style-neostandard-brightgreen?style=flat)](https://github.com/neostandard/neostandard)\n[![NPM downloads](https://img.shields.io/npm/dm/fast-json-stringify.svg?style=flat)](https://www.npmjs.com/package/fast-json-stringify)\n\n\n__fast-json-stringify__ is significantly faster than `JSON.stringify()` for small payloads.\nIts performance advantage shrinks as your payload grows.\nIt pairs well with [__flatstr__](https://www.npmjs.com/package/flatstr), which triggers a V8 optimization that improves performance when eventually converting the string to a `Buffer`.\n\n\n### How it works\n\nfast-json-stringify requires a [JSON Schema Draft 7](https://json-schema.org/specification-links.html#draft-7) input to generate a fast `stringify` function.\n\n##### Benchmarks\n\n- Machine: `EX41S-SSD, Intel Core i7, 4Ghz, 64GB RAM, 4C/8T, SSD`.\n- Node.js `v18.12.1`\n\n```\nFJS creation x 4,129 ops/sec ±0.82% (92 runs sampled)\nCJS creation x 184,196 ops/sec ±0.12% (97 runs sampled)\nAJV Serialize creation x 61,130,591 ops/sec ±0.40% (92 runs sampled)\nJSON.stringify array x 5,057 ops/sec ±0.10% (100 runs sampled)\nfast-json-stringify array default x 6,243 ops/sec ±0.14% (98 runs sampled)\nfast-json-stringify array json-stringify x 6,261 ops/sec ±0.30% (99 runs sampled)\ncompile-json-stringify array x 6,842 ops/sec ±0.18% (96 runs sampled)\nAJV Serialize array x 6,964 ops/sec ±0.11% (95 runs sampled)\nJSON.stringify large array x 248 ops/sec ±0.07% (90 runs sampled)\nfast-json-stringify large array default x 99.96 ops/sec ±0.22% (74 runs sampled)\nfast-json-stringify large array json-stringify x 248 ops/sec ±0.07% (90 runs sampled)\ncompile-json-stringify large array x 317 ops/sec ±0.09% (89 runs sampled)\nAJV Serialize large array x 111 ops/sec ±0.07% (33 runs sampled)\nJSON.stringify long string x 16,002 ops/sec ±0.09% (98 runs sampled)\nfast-json-stringify long string x 15,979 ops/sec ±0.09% (96 runs sampled)\ncompile-json-stringify long string x 15,952 ops/sec ±0.31% (97 runs sampled)\nAJV Serialize long string x 21,416 ops/sec ±0.08% (98 runs sampled)\nJSON.stringify short string x 12,944,272 ops/sec ±0.09% (96 runs sampled)\nfast-json-stringify short string x 30,585,790 ops/sec ±0.27% (97 runs sampled)\ncompile-json-stringify short string x 30,656,406 ops/sec ±0.12% (96 runs sampled)\nAJV Serialize short string x 30,406,785 ops/sec ±0.37% (96 runs sampled)\nJSON.stringify obj x 3,153,043 ops/sec ±0.33% (99 runs sampled)\nfast-json-stringify obj x 6,866,434 ops/sec ±0.11% (100 runs sampled)\ncompile-json-stringify obj x 15,886,723 ops/sec ±0.15% (98 runs sampled)\nAJV Serialize obj x 8,969,043 ops/sec ±0.36% (97 runs sampled)\nJSON stringify date x 1,126,547 ops/sec ±0.09% (97 runs sampled)\nfast-json-stringify date format x 1,836,188 ops/sec ±0.12% (99 runs sampled)\ncompile-json-stringify date format x 1,125,735 ops/sec ±0.19% (98 runs sampled)\n```\n\n#### Table of contents:\n- <a href=\"#example\">`Example`</a>\n- <a href=\"#options\">`Options`</a>\n- <a href=\"#api\">`API`</a>\n - <a href=\"#fastJsonStringify\">`fastJsonStringify`</a>\n - <a href=\"#specific\">`Specific use cases`</a>\n - <a href=\"#required\">`Required`</a>\n - <a href=\"#missingFields\">`Missing fields`</a>\n - <a href=\"#patternProperties\">`Pattern Properties`</a>\n - <a href=\"#additionalProperties\">`Additional Properties`</a>\n - <a href=\"#AnyOf-and-OneOf\">`AnyOf` and `OneOf`</a>\n - <a href=\"#ref\">`Reuse - $ref`</a>\n - <a href=\"#long\">`Long integers`</a>\n - <a href=\"#integer\">`Integers`</a>\n - <a href=\"#nullable\">`Nullable`</a>\n - <a href=\"#largearrays\">`Large Arrays`</a>\n- <a href=\"#security\">`Security Notice`</a>\n- <a href=\"#debug\">`Debug Mode`</a>\n- <a href=\"#standalone\">`Standalone Mode`</a>\n- <a href=\"#acknowledgements\">`Acknowledgements`</a>\n- <a href=\"#license\">`License`</a>\n\n\n<a name=\"example\"></a>\nTry it out on RunKit: <a href=\"https://runkit.com/npm/fast-json-stringify\">https://runkit.com/npm/fast-json-stringify</a>\n## Example\n\n```js\nconst fastJson = require('fast-json-stringify')\nconst stringify = fastJson({\n  title: 'Example Schema',\n  type: 'object',\n  properties: {\n    firstName: {\n      type: 'string'\n    },\n    lastName: {\n      type: 'string'\n    },\n    age: {\n      description: 'Age in years',\n      type: 'integer'\n    },\n    reg: {\n      type: 'string'\n    }\n  }\n})\n\nconsole.log(stringify({\n  firstName: 'Matteo',\n  lastName: 'Collina',\n  age: 32,\n  reg: /\"([^\"]|\\\\\")*\"/\n}))\n```\n\n<a name=\"options\"></a>\n## Options\n\nOptionally, you may provide to `fast-json-stringify` an option object as second parameter:\n\n```js\nconst fastJson = require('fast-json-stringify')\nconst stringify = fastJson(mySchema, {\n  schema: { ... },\n  ajv: { ... },\n  rounding: 'ceil'\n})\n```\n\n- `schema`: external schemas references by $ref property. [More details](#ref)\n- `ajv`: [ajv v8 instance's settings](https://ajv.js.org/options.html) for those properties that require `ajv`. [More details](#anyof)\n- `rounding`: setup how the `integer` types will be rounded when not integers. [More details](#integer)\n- `largeArrayMechanism`: set the mechanism that should be used to handle large\n(by default `20000` or more items) arrays. [More details](#largearrays)\n\n\n<a name=\"api\"></a>\n## API\n<a name=\"fastJsonStringify\"></a>\n### fastJsonStringify(schema)\n\nBuild a `stringify()` function based on [jsonschema draft 7 spec](https://json-schema.org/specification-links.html#draft-7).\n\nSupported types:\n\n * `'string'`\n * `'integer'`\n * `'number'`\n * `'array'`\n * `'object'`\n * `'boolean'`\n * `'null'`\n\nAnd nested ones, too.\n\n<a name=\"specific\"></a>\n#### Specific use cases\n\n| Instance | Serialized as                |\n| -------- | ---------------------------- |\n| `Date`   | `string` via `toISOString()` |\n| `RegExp` | `string`                     |\n| `BigInt` | `integer` via `toString`     |\n\n[JSON Schema built-in formats](https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats) for dates are supported and will be serialized as:\n\n| Format      | Serialized format example  |\n| ----------- | -------------------------- |\n| `date-time` | `2020-04-03T09:11:08.615Z` |\n| `date`      | `2020-04-03`               |\n| `time`      | `09:11:08`                 |\n\n**Note**: In the case of string formatted Date and not Date Object, there will be no manipulation on it. It should be properly formatted.\n\nExample with a Date object:\n\n```javascript\nconst stringify = fastJson({\n  title: 'Example Schema with string date-time field',\n  type: 'string',\n  format: 'date-time'\n})\n\nconst date = new Date()\nconsole.log(stringify(date)) // '\"YYYY-MM-DDTHH:mm:ss.sssZ\"'\n```\n\n\n<a name=\"required\"></a>\n#### Required\nYou can set specific fields of an object as required in your schema by adding the field name inside the `required` array in your schema.\nExample:\n```javascript\nconst schema = {\n  title: 'Example Schema with required field',\n  type: 'object',\n  properties: {\n    nickname: {\n      type: 'string'\n    },\n    mail: {\n      type: 'string'\n    }\n  },\n  required: ['mail']\n}\n```\nIf the object to stringify is missing the required field(s), `fast-json-stringify` will throw an error.\n\n<a name=\"missingFields\"></a>\n#### Missing fields\nIf a field *is present* in the schema (and is not required) but it *is not present* in the object to stringify, `fast-json-stringify` will not write it in the final string.\nExample:\n```javascript\nconst stringify = fastJson({\n  title: 'Example Schema',\n  type: 'object',\n  properties: {\n    nickname: {\n      type: 'string'\n    },\n    mail: {\n      type: 'string'\n    }\n  }\n})\n\nconst obj = {\n  mail: 'mail@example.com'\n}\n\nconsole.log(stringify(obj)) // '{\"mail\":\"mail@example.com\"}'\n```\n\n<a name=\"defaults\"></a>\n#### Defaults\n`fast-json-stringify` supports `default` jsonschema key in order to serialize a value\nif it is `undefined` or not present.\n\nExample:\n```javascript\nconst stringify = fastJson({\n  title: 'Example Schema',\n  type: 'object',\n  properties: {\n    nickname: {\n      type: 'string',\n      default: 'the default string'\n    }\n  }\n})\n\nconsole.log(stringify({})) // '{\"nickname\":\"the default string\"}'\nconsole.log(stringify({nickname: 'my-nickname'})) // '{\"nickname\":\"my-nickname\"}'\n```\n\n<a name=\"patternProperties\"></a>\n#### Pattern properties\n`fast-json-stringify` supports pattern properties as defined by JSON schema.\n*patternProperties* must be an object, where the key is a valid regex and the value is an object, declared in this way: `{ type: 'type' }`.\n*patternProperties* will work only for the properties that are not explicitly listed in the properties object.\nExample:\n```javascript\nconst stringify = fastJson({\n  title: 'Example Schema',\n  type: 'object',\n  properties: {\n    nickname: {\n      type: 'string'\n    }\n  },\n  patternProperties: {\n    'num': {\n      type: 'number'\n    },\n    '.*foo$': {\n      type: 'string'\n    }\n  }\n})\n\nconst obj = {\n  nickname: 'nick',\n  matchfoo: 42,\n  otherfoo: 'str',\n  matchnum: 3\n}\n\nconsole.log(stringify(obj)) // '{\"matchfoo\":\"42\",\"otherfoo\":\"str\",\"matchnum\":3,\"nickname\":\"nick\"}'\n```\n\n<a name=\"additionalProperties\"></a>\n#### Additional properties\n`fast-json-stringify` supports additional properties as defined by JSON schema.\n*additionalProperties* must be an object or a boolean, declared in this way: `{ type: 'type' }`.\n*additionalProperties* will work only for the properties that are not explicitly listed in the *properties* and *patternProperties* objects.\n\nIf *additionalProperties* is not present or is set to `false`, every property that is not explicitly listed in the *properties* and *patternProperties* objects,will be ignored, as described in <a href=\"#missingFields\">Missing fields</a>.\nMissing fields are ignored to avoid having to rewrite objects before serializing. However, other schema rules would throw in similar situations.\nIf *additionalProperties* is set to `true`, it will be used by `JSON.stringify` to stringify the additional properties. If you want to achieve maximum performance, we strongly encourage you to use a fixed schema where possible.\nThe additional properties will always be serialized at the end of the object.\nExample:\n```javascript\nconst stringify = fastJson({\n  title: 'Example Schema',\n  type: 'object',\n  properties: {\n    nickname: {\n      type: 'string'\n    }\n  },\n  patternProperties: {\n    'num': {\n      type: 'number'\n    },\n    '.*foo$': {\n      type: 'string'\n    }\n  },\n  additionalProperties: {\n    type: 'string'\n  }\n})\n\nconst obj = {\n  nickname: 'nick',\n  matchfoo: 42,\n  otherfoo: 'str',\n  matchnum: 3,\n  nomatchstr: 'valar morghulis',\n  nomatchint: 313\n}\n\nconsole.log(stringify(obj)) // '{\"nickname\":\"nick\",\"matchfoo\":\"42\",\"otherfoo\":\"str\",\"matchnum\":3,\"nomatchstr\":\"valar morghulis\",nomatchint:\"313\"}'\n```\n\n#### AnyOf and OneOf\n\n`fast-json-stringify` supports the **anyOf** and **oneOf** keywords as defined by JSON schema. Both must be an array of valid JSON schemas. The different schemas will be tested in the specified order. The more schemas `stringify` has to try before finding a match, the slower it will be.\n\n*anyOf* and *oneOf* use [ajv](https://www.npmjs.com/package/ajv) as a JSON schema validator to find the schema that matches the data. This has an impact on performance—only use it as a last resort.\n\nExample:\n```javascript\nconst stringify = fastJson({\n  title: 'Example Schema',\n  type: 'object',\n  properties: {\n    'undecidedType': {\n      'anyOf': [{\n\ttype: 'string'\n      }, {\n\ttype: 'boolean'\n      }]\n    }\n  }\n})\n```\n\nWhen specifying object JSON schemas for *anyOf*, add *required* validation keyword to match only the objects with the properties you want.\n\nExample:\n```javascript\nconst stringify = fastJson({\n  title: 'Example Schema',\n  type: 'array',\n  items: {\n    anyOf: [\n      {\n        type: 'object',\n        properties: {\n          savedId: { type: 'string' }\n        },\n        // without \"required\" validation any object will match\n        required: ['savedId']\n      },\n      {\n        type: 'object',\n        properties: {\n          error: { type: 'string' }\n        },\n        required: ['error']\n      }\n    ]\n  }\n})\n```\n\n<a name=\"if-then-else\"></a>\n#### If/then/else\n`fast-json-stringify` supports `if/then/else` jsonschema feature. See [ajv documentation](https://ajv.js.org/keywords.html#ifthenelse).\n\nExample:\n```javascript\nconst stringify = fastJson({\n  'type': 'object',\n  'properties': {\n  },\n  'if': {\n    'properties': {\n      'kind': { 'type': 'string', 'enum': ['foobar'] }\n    }\n  },\n  'then': {\n    'properties': {\n      'kind': { 'type': 'string', 'enum': ['foobar'] },\n      'foo': { 'type': 'string' },\n      'bar': { 'type': 'number' }\n    }\n  },\n  'else': {\n    'properties': {\n      'kind': { 'type': 'string', 'enum': ['greeting'] },\n      'hi': { 'type': 'string' },\n      'hello': { 'type': 'number' }\n    }\n  }\n})\n\nconsole.log(stringify({\n  kind: 'greeting',\n  foo: 'FOO',\n  bar: 42,\n  hi: 'HI',\n  hello: 45\n})) // {\"kind\":\"greeting\",\"hi\":\"HI\",\"hello\":45}\nconsole.log(stringify({\n  kind: 'foobar',\n  foo: 'FOO',\n  bar: 42,\n  hi: 'HI',\n  hello: 45\n})) // {\"kind\":\"foobar\",\"foo\":\"FOO\",\"bar\":42}\n```\n\n**NB** Do not declare the properties twice or you will print them twice!\n\n<a name=\"ref\"></a>\n#### Reuse - $ref\nIf you want to reuse a definition of a value, you can use the property `$ref`.\nThe value of `$ref` must be a string in [JSON Pointer](https://tools.ietf.org/html/rfc6901) format.\nExample:\n```javascript\nconst schema = {\n  title: 'Example Schema',\n  definitions: {\n    num: {\n      type: 'object',\n      properties: {\n        int: {\n          type: 'integer'\n        }\n      }\n    },\n    str: {\n      type: 'string'\n    }\n  },\n  type: 'object',\n  properties: {\n    nickname: {\n      $ref: '#/definitions/str'\n    }\n  },\n  patternProperties: {\n    'num': {\n      $ref: '#/definitions/num'\n    }\n  },\n  additionalProperties: {\n    $ref: '#/definitions/def'\n  }\n}\n\nconst stringify = fastJson(schema)\n```\nIf you need to use an external definition, you can pass it as an option to `fast-json-stringify`.\nExample:\n```javascript\nconst schema = {\n  title: 'Example Schema',\n  type: 'object',\n  properties: {\n    nickname: {\n      $ref: 'strings#/definitions/str'\n    }\n  },\n  patternProperties: {\n    'num': {\n      $ref: 'numbers#/definitions/num'\n    }\n  },\n  additionalProperties: {\n    $ref: 'strings#/definitions/def'\n  }\n}\n\nconst externalSchema = {\n  numbers: {\n    definitions: {\n      num: {\n        type: 'object',\n        properties: {\n          int: {\n            type: 'integer'\n          }\n        }\n      }\n    }\n  },\n  strings: require('./string-def.json')\n}\n\nconst stringify = fastJson(schema, { schema: externalSchema })\n```\nExternal definitions can also reference each other.\nExample:\n```javascript\nconst schema = {\n  title: 'Example Schema',\n  type: 'object',\n  properties: {\n    foo: {\n      $ref: 'strings#/definitions/foo'\n    }\n  }\n}\n\nconst externalSchema = {\n  strings: {\n    definitions: {\n      foo: {\n        $ref: 'things#/definitions/foo'\n      }\n    }\n  },\n  things: {\n    definitions: {\n      foo: {\n        type: 'string'\n      }\n    }\n  }\n}\n\nconst stringify = fastJson(schema, { schema: externalSchema })\n```\n\n<a name=\"long\"></a>\n#### Long integers\nBy default the library will handle automatically [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt).\n\n<a name=\"integer\"></a>\n#### Integers\nThe `type: integer` property will be truncated if a floating point is provided.\nYou can customize this behaviour with the `rounding` option that will accept [`round`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round), [`ceil`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil), [`floor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor) or [`trunc`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc). Default is `trunc`:\n\n```js\nconst stringify = fastJson(schema, { rounding: 'ceil' })\n```\n\n\n<a name=\"nullable\"></a>\n#### Nullable\n\nAccording to the [Open API 3.0 specification](https://swagger.io/docs/specification/data-models/data-types/#null), a value that can be null must be declared `nullable`.\n\n##### Nullable object\n```javascript\nconst stringify = fastJson({\n  'title': 'Nullable schema',\n  'type': 'object',\n  'nullable': true,\n  'properties': {\n    'product': {\n      'nullable': true,\n      'type': 'object',\n      'properties': {\n        'name': {\n          'type': 'string'\n        }\n      }\n    }\n  }\n})\n\nconsole.log(stringify({product: {name: \"hello\"}})) // \"{\"product\":{\"name\":\"hello\"}}\"\nconsole.log(stringify({product: null})) // \"{\"product\":null}\"\nconsole.log(stringify(null)) // null\n```\n\nOtherwise, instead of raising an error, null values will be coerced as follows:\n\n- `integer` -> `0`\n- `number` -> `0`\n- `string` -> `\"\"`\n- `boolean` -> `false`\n- `object` -> `{}`\n- `array` -> `[]`\n\n<a name=\"largearrays\"></a>\n#### Large Arrays\n\nLarge arrays are, for the scope of this document, defined as arrays containing,\nby default, `20000` elements or more. That value can be adjusted via the option\nparameter `largeArraySize`.\n\nAt some point the overhead caused by the default mechanism used by\n`fast-json-stringify` to handle arrays starts increasing exponentially, leading\nto slow overall executions.\n\n##### Settings\n\nIn order to improve that the user can set the `largeArrayMechanism` and\n`largeArraySize` options.\n\n`largeArrayMechanism`'s default value is `default`. Valid values for it are:\n\n- `default` - This option is a compromise between performance and feature set by\nstill providing the expected functionality out of this lib but giving up some\npossible performance gain. With this option set, **large arrays** would be\nstringified by joining their stringified elements using `Array.join` instead of\nstring concatenation for better performance\n- `json-stringify` - This option will remove support for schema validation\nwithin **large arrays** completely. By doing so the overhead previously\nmentioned is nulled, greatly improving execution time. Mind there's no change\nin behavior for arrays not considered _large_\n\n`largeArraySize`'s default value is `20000`. Valid values for it are\ninteger-like values, such as:\n\n- `20000`\n- `2e4`\n- `'20000'`\n- `'2e4'` - _note this will be converted to `2`, not `20000`_\n- `1.5` - _note this will be converted to `1`_\n\n<a name=\"unsafe\"></a>\n#### Unsafe string\nBy default, the library escapes all strings. With the 'unsafe' format, the string isn't escaped. This has a potentially dangerous security issue. You can use it only if you are sure that your data doesn't need escaping. The advantage is a significant performance improvement.\n\nExample:\n```javascript\nconst stringify = fastJson({\n  title: 'Example Schema',\n  type: 'object',\n  properties: {\n    'code': {\n\t    type: 'string',\n\t    format 'unsafe'\n    }\n  }\n})\n```\n\n##### Benchmarks\n\nFor reference, here goes some benchmarks for comparison over the three\nmechanisms. Benchmarks conducted on an old machine.\n\n- Machine: `ST1000LM024 HN-M 1TB HDD, Intel Core i7-3610QM @ 2.3GHz, 12GB RAM, 4C/8T`.\n- Node.js `v16.13.1`\n\n```\nJSON.stringify large array x 157 ops/sec ±0.73% (86 runs sampled)\nfast-json-stringify large array default x 48.72 ops/sec ±4.92% (48 runs sampled)\nfast-json-stringify large array json-stringify x 157 ops/sec ±0.76% (86 runs sampled)\ncompile-json-stringify large array x 175 ops/sec ±4.47% (79 runs sampled)\nAJV Serialize large array x 58.76 ops/sec ±4.59% (60 runs sampled)\n```\n\n<a name=\"security\"></a>\n## Security notice\n\nTreat the schema definition as application code, it\nis not safe to use user-provided schemas.\n\nTo achieve low cost and high performance redaction `fast-json-stringify`\ncreates and compiles a function (using the `Function` constructor) on initialization.\nWhile the `schema` is currently validated for any developer errors,\nthere is no guarantee that supplying user-generated schema could not\nexpose your application to remote attacks.\n\nUsers are responsible for sending trusted data. `fast-json-stringify` guarantees that you will get\na valid output only if your input matches the schema or can be coerced to the schema. If your input\ndoesn't match the schema, you will get undefined behavior.\n\n<a name=\"debug\"></a>\n### Debug Mode\n\nThe debug mode can be activated during your development to understand what is going on when things do not\nwork as you expect.\n\n```js\nconst debugCompiled = fastJson({\n  title: 'default string',\n  type: 'object',\n  properties: {\n    firstName: {\n      type: 'string'\n    }\n  }\n}, { mode: 'debug' })\n\nconsole.log(debugCompiled) // it is a object contain code, ajv instance\nconst rawString = debugCompiled.code // it is the generated code\nconsole.log(rawString)\n\nconst stringify = fastJson.restore(debugCompiled) // use the generated string to get back the `stringify` function\nconsole.log(stringify({ firstName: 'Foo', surname: 'bar' })) // '{\"firstName\":\"Foo\"}'\n```\n\n<a name=\"standalone\"></a>\n### Standalone Mode\n\nThe standalone mode is used to compile the code that can be directly run by `node`\nitself. You need to have `fast-json-stringify` installed for the standalone code to work.\n\n```js\nconst fs = require('fs')\nconst code = fastJson({\n  title: 'default string',\n  type: 'object',\n  properties: {\n    firstName: {\n      type: 'string'\n    }\n  }\n}, { mode: 'standalone' })\n\nfs.writeFileSync('stringify.js', code)\nconst stringify = require('stringify.js')\nconsole.log(stringify({ firstName: 'Foo', surname: 'bar' })) // '{\"firstName\":\"Foo\"}'\n```\n\n<a name=\"acknowledgements\"></a>\n## Acknowledgements\n\nThis project was kindly sponsored by [nearForm](https://nearform.com).\n\n<a name=\"license\"></a>\n## License\n\nMIT\n"
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "build",
          "type": "tree",
          "content": null
        },
        {
          "name": "eslint.config.js",
          "type": "blob",
          "size": 0.1748046875,
          "content": "'use strict'\n\nmodule.exports = require('neostandard')({\n  ignores: [\n    ...require('neostandard').resolveIgnoresFromGitignore(),\n    'lib/schema-validator.js'\n  ],\n  ts: true\n})\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 27.5205078125,
          "content": "'use strict'\n\n/* eslint no-prototype-builtins: 0 */\n\nconst { RefResolver } = require('json-schema-ref-resolver')\n\nconst Serializer = require('./lib/serializer')\nconst Validator = require('./lib/validator')\nconst Location = require('./lib/location')\nconst validate = require('./lib/schema-validator')\nconst mergeSchemas = require('./lib/merge-schemas')\n\nconst SINGLE_TICK = /'/g\n\nlet largeArraySize = 2e4\nlet largeArrayMechanism = 'default'\n\nconst validRoundingMethods = [\n  'floor',\n  'ceil',\n  'round',\n  'trunc'\n]\n\nconst validLargeArrayMechanisms = [\n  'default',\n  'json-stringify'\n]\n\nlet schemaIdCounter = 0\n\nfunction isValidSchema (schema, name) {\n  if (!validate(schema)) {\n    if (name) {\n      name = `\"${name}\" `\n    } else {\n      name = ''\n    }\n    const first = validate.errors[0]\n    const err = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`)\n    err.errors = isValidSchema.errors\n    throw err\n  }\n}\n\nfunction resolveRef (context, location) {\n  const ref = location.schema.$ref\n\n  let hashIndex = ref.indexOf('#')\n  if (hashIndex === -1) {\n    hashIndex = ref.length\n  }\n\n  const schemaId = ref.slice(0, hashIndex) || location.schemaId\n  const jsonPointer = ref.slice(hashIndex) || '#'\n\n  const schema = context.refResolver.getSchema(schemaId, jsonPointer)\n  if (schema === null) {\n    throw new Error(`Cannot find reference \"${ref}\"`)\n  }\n\n  const newLocation = new Location(schema, schemaId, jsonPointer)\n  if (schema.$ref !== undefined) {\n    return resolveRef(context, newLocation)\n  }\n\n  return newLocation\n}\n\nfunction getMergedLocation (context, mergedSchemaId) {\n  const mergedSchema = context.refResolver.getSchema(mergedSchemaId, '#')\n  return new Location(mergedSchema, mergedSchemaId, '#')\n}\n\nfunction getSchemaId (schema, rootSchemaId) {\n  if (schema.$id && schema.$id.charAt(0) !== '#') {\n    return schema.$id\n  }\n  return rootSchemaId\n}\n\nfunction build (schema, options) {\n  isValidSchema(schema)\n\n  options = options || {}\n\n  const context = {\n    functions: [],\n    functionsCounter: 0,\n    functionsNamesBySchema: new Map(),\n    options,\n    refResolver: new RefResolver(),\n    rootSchemaId: schema.$id || `__fjs_root_${schemaIdCounter++}`,\n    validatorSchemasIds: new Set(),\n    mergedSchemasIds: new Map()\n  }\n\n  const schemaId = getSchemaId(schema, context.rootSchemaId)\n  if (!context.refResolver.hasSchema(schemaId)) {\n    context.refResolver.addSchema(schema, context.rootSchemaId)\n  }\n\n  if (options.schema) {\n    for (const key in options.schema) {\n      const schema = options.schema[key]\n      const schemaId = getSchemaId(schema, key)\n      if (!context.refResolver.hasSchema(schemaId)) {\n        isValidSchema(schema, key)\n        context.refResolver.addSchema(schema, key)\n      }\n    }\n  }\n\n  if (options.rounding) {\n    if (!validRoundingMethods.includes(options.rounding)) {\n      throw new Error(`Unsupported integer rounding method ${options.rounding}`)\n    }\n  }\n\n  if (options.largeArrayMechanism) {\n    if (validLargeArrayMechanisms.includes(options.largeArrayMechanism)) {\n      largeArrayMechanism = options.largeArrayMechanism\n    } else {\n      throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`)\n    }\n  }\n\n  if (options.largeArraySize) {\n    if (typeof options.largeArraySize === 'string' && Number.isFinite(Number.parseInt(options.largeArraySize, 10))) {\n      largeArraySize = Number.parseInt(options.largeArraySize, 10)\n    } else if (typeof options.largeArraySize === 'number' && Number.isInteger(options.largeArraySize)) {\n      largeArraySize = options.largeArraySize\n    } else if (typeof options.largeArraySize === 'bigint') {\n      largeArraySize = Number(options.largeArraySize)\n    } else {\n      throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`)\n    }\n  }\n\n  const location = new Location(schema, context.rootSchemaId)\n  const code = buildValue(context, location, 'input')\n\n  let contextFunctionCode = `\n    const JSON_STR_BEGIN_OBJECT = '{'\n    const JSON_STR_END_OBJECT = '}'\n    const JSON_STR_BEGIN_ARRAY = '['\n    const JSON_STR_END_ARRAY = ']'\n    const JSON_STR_COMMA = ','\n    const JSON_STR_COLONS = ':'\n    const JSON_STR_QUOTE = '\"'\n    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT\n    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY\n    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE\n    const JSON_STR_NULL = 'null'\n  `\n\n  // If we have only the invocation of the 'anonymous0' function, we would\n  // basically just wrap the 'anonymous0' function in the 'main' function and\n  // and the overhead of the intermediate variable 'json'. We can avoid the\n  // wrapping and the unnecessary memory allocation by aliasing 'anonymous0' to\n  // 'main'\n  if (code === 'json += anonymous0(input)') {\n    contextFunctionCode += `\n    ${context.functions.join('\\n')}\n    const main = anonymous0\n    return main\n    `\n  } else {\n    contextFunctionCode += `\n    function main (input) {\n      let json = ''\n      ${code}\n      return json\n    }\n    ${context.functions.join('\\n')}\n    return main\n    `\n  }\n\n  const serializer = new Serializer(options)\n  const validator = new Validator(options.ajv)\n\n  for (const schemaId of context.validatorSchemasIds) {\n    const schema = context.refResolver.getSchema(schemaId)\n    validator.addSchema(schema, schemaId)\n\n    const dependencies = context.refResolver.getSchemaDependencies(schemaId)\n    for (const [schemaId, schema] of Object.entries(dependencies)) {\n      validator.addSchema(schema, schemaId)\n    }\n  }\n\n  if (options.debugMode) {\n    options.mode = 'debug'\n  }\n\n  if (options.mode === 'debug') {\n    return {\n      validator,\n      serializer,\n      code: `validator\\nserializer\\n${contextFunctionCode}`,\n      ajv: validator.ajv\n    }\n  }\n\n  /* eslint no-new-func: \"off\" */\n  const contextFunc = new Function('validator', 'serializer', contextFunctionCode)\n\n  if (options.mode === 'standalone') {\n    const buildStandaloneCode = require('./lib/standalone')\n    return buildStandaloneCode(contextFunc, context, serializer, validator)\n  }\n\n  return contextFunc(validator, serializer)\n}\n\nconst objectKeywords = [\n  'properties',\n  'required',\n  'additionalProperties',\n  'patternProperties',\n  'maxProperties',\n  'minProperties',\n  'dependencies'\n]\n\nconst arrayKeywords = [\n  'items',\n  'additionalItems',\n  'maxItems',\n  'minItems',\n  'uniqueItems',\n  'contains'\n]\n\nconst stringKeywords = [\n  'maxLength',\n  'minLength',\n  'pattern'\n]\n\nconst numberKeywords = [\n  'multipleOf',\n  'maximum',\n  'exclusiveMaximum',\n  'minimum',\n  'exclusiveMinimum'\n]\n\n/**\n * Infer type based on keyword in order to generate optimized code\n * https://datatracker.ietf.org/doc/html/draft-handrews-json-schema-validation-01#section-6\n */\nfunction inferTypeByKeyword (schema) {\n  for (const keyword of objectKeywords) {\n    if (keyword in schema) return 'object'\n  }\n  for (const keyword of arrayKeywords) {\n    if (keyword in schema) return 'array'\n  }\n  for (const keyword of stringKeywords) {\n    if (keyword in schema) return 'string'\n  }\n  for (const keyword of numberKeywords) {\n    if (keyword in schema) return 'number'\n  }\n  return schema.type\n}\n\nfunction buildExtraObjectPropertiesSerializer (context, location, addComma) {\n  const schema = location.schema\n  const propertiesKeys = Object.keys(schema.properties || {})\n\n  let code = `\n    const propertiesKeys = ${JSON.stringify(propertiesKeys)}\n    for (const [key, value] of Object.entries(obj)) {\n      if (\n        propertiesKeys.includes(key) ||\n        value === undefined ||\n        typeof value === 'function' ||\n        typeof value === 'symbol'\n      ) continue\n  `\n\n  const patternPropertiesLocation = location.getPropertyLocation('patternProperties')\n  const patternPropertiesSchema = patternPropertiesLocation.schema\n\n  if (patternPropertiesSchema !== undefined) {\n    for (const propertyKey in patternPropertiesSchema) {\n      const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey)\n\n      code += `\n        if (/${propertyKey.replace(/\\\\*\\//g, '\\\\/')}/.test(key)) {\n          ${addComma}\n          json += serializer.asString(key) + JSON_STR_COLONS\n          ${buildValue(context, propertyLocation, 'value')}\n          continue\n        }\n      `\n    }\n  }\n\n  const additionalPropertiesLocation = location.getPropertyLocation('additionalProperties')\n  const additionalPropertiesSchema = additionalPropertiesLocation.schema\n\n  if (additionalPropertiesSchema !== undefined) {\n    if (additionalPropertiesSchema === true) {\n      code += `\n        ${addComma}\n        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)\n      `\n    } else {\n      const propertyLocation = location.getPropertyLocation('additionalProperties')\n      code += `\n        ${addComma}\n        json += serializer.asString(key) + JSON_STR_COLONS\n        ${buildValue(context, propertyLocation, 'value')}\n      `\n    }\n  }\n\n  code += `\n    }\n  `\n  return code\n}\n\nfunction buildInnerObject (context, location) {\n  const schema = location.schema\n\n  const propertiesLocation = location.getPropertyLocation('properties')\n  const requiredProperties = schema.required || []\n\n  // Should serialize required properties first\n  const propertiesKeys = Object.keys(schema.properties || {}).sort(\n    (key1, key2) => {\n      const required1 = requiredProperties.includes(key1)\n      const required2 = requiredProperties.includes(key2)\n      return required1 === required2 ? 0 : required1 ? -1 : 1\n    }\n  )\n  const hasRequiredProperties = requiredProperties.includes(propertiesKeys[0])\n\n  let code = 'let value\\n'\n\n  for (const key of requiredProperties) {\n    if (!propertiesKeys.includes(key)) {\n      const sanitizedKey = JSON.stringify(key)\n      code += `if (obj[${sanitizedKey}] === undefined) throw new Error('${sanitizedKey.replace(/'/g, '\\\\\\'')} is required!')\\n`\n    }\n  }\n\n  code += 'let json = JSON_STR_BEGIN_OBJECT\\n'\n\n  let addComma = ''\n  if (!hasRequiredProperties) {\n    code += 'let addComma = false\\n'\n    addComma = '!addComma && (addComma = true) || (json += JSON_STR_COMMA)'\n  }\n\n  for (const key of propertiesKeys) {\n    let propertyLocation = propertiesLocation.getPropertyLocation(key)\n    if (propertyLocation.schema.$ref) {\n      propertyLocation = resolveRef(context, propertyLocation)\n    }\n\n    const sanitizedKey = JSON.stringify(key)\n    const defaultValue = propertyLocation.schema.default\n    const isRequired = requiredProperties.includes(key)\n\n    code += `\n      value = obj[${sanitizedKey}]\n      if (value !== undefined) {\n        ${addComma}\n        json += ${JSON.stringify(sanitizedKey + ':')}\n        ${buildValue(context, propertyLocation, 'value')}\n      }`\n\n    if (defaultValue !== undefined) {\n      code += ` else {\n        ${addComma}\n        json += ${JSON.stringify(sanitizedKey + ':' + JSON.stringify(defaultValue))}\n      }\n      `\n    } else if (isRequired) {\n      code += ` else {\n        throw new Error('${sanitizedKey.replace(/'/g, '\\\\\\'')} is required!')\n      }\n      `\n    } else {\n      code += '\\n'\n    }\n\n    if (hasRequiredProperties) {\n      addComma = 'json += \\',\\''\n    }\n  }\n\n  if (schema.patternProperties || schema.additionalProperties) {\n    code += buildExtraObjectPropertiesSerializer(context, location, addComma)\n  }\n\n  code += `\n    return json + JSON_STR_END_OBJECT\n  `\n  return code\n}\n\nfunction mergeLocations (context, mergedSchemaId, mergedLocations) {\n  for (let i = 0; i < mergedLocations.length; i++) {\n    const location = mergedLocations[i]\n    const schema = location.schema\n    if (schema.$ref) {\n      mergedLocations[i] = resolveRef(context, location)\n    }\n  }\n\n  const mergedSchemas = []\n  for (const location of mergedLocations) {\n    const schema = cloneOriginSchema(context, location.schema, location.schemaId)\n    delete schema.$id\n\n    mergedSchemas.push(schema)\n  }\n\n  const mergedSchema = mergeSchemas(mergedSchemas)\n  const mergedLocation = new Location(mergedSchema, mergedSchemaId)\n\n  context.refResolver.addSchema(mergedSchema, mergedSchemaId)\n  return mergedLocation\n}\n\nfunction cloneOriginSchema (context, schema, schemaId) {\n  const clonedSchema = Array.isArray(schema) ? [] : {}\n\n  if (\n    schema.$id !== undefined &&\n    schema.$id.charAt(0) !== '#'\n  ) {\n    schemaId = schema.$id\n  }\n\n  const mergedSchemaRef = context.mergedSchemasIds.get(schema)\n  if (mergedSchemaRef) {\n    context.mergedSchemasIds.set(clonedSchema, mergedSchemaRef)\n  }\n\n  for (const key in schema) {\n    let value = schema[key]\n\n    if (key === '$ref' && typeof value === 'string' && value.charAt(0) === '#') {\n      value = schemaId + value\n    }\n\n    if (typeof value === 'object' && value !== null) {\n      value = cloneOriginSchema(context, value, schemaId)\n    }\n\n    clonedSchema[key] = value\n  }\n\n  return clonedSchema\n}\n\nfunction toJSON (variableName) {\n  return `(${variableName} && typeof ${variableName}.toJSON === 'function')\n    ? ${variableName}.toJSON()\n    : ${variableName}\n  `\n}\n\nfunction buildObject (context, location) {\n  const schema = location.schema\n\n  if (context.functionsNamesBySchema.has(schema)) {\n    return context.functionsNamesBySchema.get(schema)\n  }\n\n  const functionName = generateFuncName(context)\n  context.functionsNamesBySchema.set(schema, functionName)\n\n  let schemaRef = location.getSchemaRef()\n  if (schemaRef.startsWith(context.rootSchemaId)) {\n    schemaRef = schemaRef.replace(context.rootSchemaId, '')\n  }\n\n  let functionCode = `\n  `\n\n  const nullable = schema.nullable === true\n  functionCode += `\n    // ${schemaRef}\n    function ${functionName} (input) {\n      const obj = ${toJSON('input')}\n      ${!nullable ? 'if (obj === null) return JSON_STR_EMPTY_OBJECT' : ''}\n\n      ${buildInnerObject(context, location)}\n    }\n  `\n\n  context.functions.push(functionCode)\n  return functionName\n}\n\nfunction buildArray (context, location) {\n  const schema = location.schema\n\n  let itemsLocation = location.getPropertyLocation('items')\n  itemsLocation.schema = itemsLocation.schema || {}\n\n  if (itemsLocation.schema.$ref) {\n    itemsLocation = resolveRef(context, itemsLocation)\n  }\n\n  const itemsSchema = itemsLocation.schema\n\n  if (context.functionsNamesBySchema.has(schema)) {\n    return context.functionsNamesBySchema.get(schema)\n  }\n\n  const functionName = generateFuncName(context)\n  context.functionsNamesBySchema.set(schema, functionName)\n\n  let schemaRef = location.getSchemaRef()\n  if (schemaRef.startsWith(context.rootSchemaId)) {\n    schemaRef = schemaRef.replace(context.rootSchemaId, '')\n  }\n\n  let functionCode = `\n    function ${functionName} (obj) {\n      // ${schemaRef}\n  `\n\n  const nullable = schema.nullable === true\n  functionCode += `\n    ${!nullable ? 'if (obj === null) return JSON_STR_EMPTY_ARRAY' : ''}\n    if (!Array.isArray(obj)) {\n      throw new TypeError(\\`The value of '${schemaRef}' does not match schema definition.\\`)\n    }\n    const arrayLength = obj.length\n  `\n\n  if (!schema.additionalItems && Array.isArray(itemsSchema)) {\n    functionCode += `\n      if (arrayLength > ${itemsSchema.length}) {\n        throw new Error(\\`Item at ${itemsSchema.length} does not match schema definition.\\`)\n      }\n    `\n  }\n\n  if (largeArrayMechanism === 'json-stringify') {\n    functionCode += `if (arrayLength >= ${largeArraySize}) return JSON.stringify(obj)\\n`\n  }\n\n  functionCode += `\n    const arrayEnd = arrayLength - 1\n    let value\n    let json = ''\n  `\n\n  if (Array.isArray(itemsSchema)) {\n    for (let i = 0; i < itemsSchema.length; i++) {\n      const item = itemsSchema[i]\n      functionCode += `value = obj[${i}]`\n      const tmpRes = buildValue(context, itemsLocation.getPropertyLocation(i), 'value')\n      functionCode += `\n        if (${i} < arrayLength) {\n          if (${buildArrayTypeCondition(item.type, `[${i}]`)}) {\n            ${tmpRes}\n            if (${i} < arrayEnd) {\n              json += JSON_STR_COMMA\n            }\n          } else {\n            throw new Error(\\`Item at ${i} does not match schema definition.\\`)\n          }\n        }\n        `\n    }\n\n    if (schema.additionalItems) {\n      functionCode += `\n        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {\n          json += JSON.stringify(obj[i])\n          if (i < arrayEnd) {\n            json += JSON_STR_COMMA\n          }\n        }`\n    }\n  } else {\n    const code = buildValue(context, itemsLocation, 'obj[i]')\n    functionCode += `\n      for (let i = 0; i < arrayLength; i++) {\n        ${code}\n        if (i < arrayEnd) {\n          json += JSON_STR_COMMA\n        }\n      }`\n  }\n\n  functionCode += `\n    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY\n  }`\n\n  context.functions.push(functionCode)\n  return functionName\n}\n\nfunction buildArrayTypeCondition (type, accessor) {\n  let condition\n  switch (type) {\n    case 'null':\n      condition = 'value === null'\n      break\n    case 'string':\n      condition = `typeof value === 'string' ||\n      value === null ||\n      value instanceof Date ||\n      value instanceof RegExp ||\n      (\n        typeof value === \"object\" &&\n        typeof value.toString === \"function\" &&\n        value.toString !== Object.prototype.toString\n      )`\n      break\n    case 'integer':\n      condition = 'Number.isInteger(value)'\n      break\n    case 'number':\n      condition = 'Number.isFinite(value)'\n      break\n    case 'boolean':\n      condition = 'typeof value === \\'boolean\\''\n      break\n    case 'object':\n      condition = 'value && typeof value === \\'object\\' && value.constructor === Object'\n      break\n    case 'array':\n      condition = 'Array.isArray(value)'\n      break\n    default:\n      if (Array.isArray(type)) {\n        const conditions = type.map((subType) => {\n          return buildArrayTypeCondition(subType, accessor)\n        })\n        condition = `(${conditions.join(' || ')})`\n      }\n  }\n  return condition\n}\n\nfunction generateFuncName (context) {\n  return 'anonymous' + context.functionsCounter++\n}\n\nfunction buildMultiTypeSerializer (context, location, input) {\n  const schema = location.schema\n  const types = schema.type.sort(t1 => t1 === 'null' ? -1 : 1)\n\n  let code = ''\n\n  types.forEach((type, index) => {\n    location.schema = { ...location.schema, type }\n    const nestedResult = buildSingleTypeSerializer(context, location, input)\n\n    const statement = index === 0 ? 'if' : 'else if'\n    switch (type) {\n      case 'null':\n        code += `\n          ${statement} (${input} === null)\n            ${nestedResult}\n          `\n        break\n      case 'string': {\n        code += `\n          ${statement}(\n            typeof ${input} === \"string\" ||\n            ${input} === null ||\n            ${input} instanceof Date ||\n            ${input} instanceof RegExp ||\n            (\n              typeof ${input} === \"object\" &&\n              typeof ${input}.toString === \"function\" &&\n              ${input}.toString !== Object.prototype.toString\n            )\n          )\n            ${nestedResult}\n        `\n        break\n      }\n      case 'array': {\n        code += `\n          ${statement}(Array.isArray(${input}))\n            ${nestedResult}\n        `\n        break\n      }\n      case 'integer': {\n        code += `\n          ${statement}(Number.isInteger(${input}) || ${input} === null)\n            ${nestedResult}\n        `\n        break\n      }\n      default: {\n        code += `\n          ${statement}(typeof ${input} === \"${type}\" || ${input} === null)\n            ${nestedResult}\n        `\n        break\n      }\n    }\n  })\n  let schemaRef = location.getSchemaRef()\n  if (schemaRef.startsWith(context.rootSchemaId)) {\n    schemaRef = schemaRef.replace(context.rootSchemaId, '')\n  }\n  code += `\n    else throw new TypeError(\\`The value of '${schemaRef}' does not match schema definition.\\`)\n  `\n\n  return code\n}\n\nfunction buildSingleTypeSerializer (context, location, input) {\n  const schema = location.schema\n\n  switch (schema.type) {\n    case 'null':\n      return 'json += JSON_STR_NULL'\n    case 'string': {\n      if (schema.format === 'date-time') {\n        return `json += serializer.asDateTime(${input})`\n      } else if (schema.format === 'date') {\n        return `json += serializer.asDate(${input})`\n      } else if (schema.format === 'time') {\n        return `json += serializer.asTime(${input})`\n      } else if (schema.format === 'unsafe') {\n        return `json += serializer.asUnsafeString(${input})`\n      } else {\n        return `\n        if (typeof ${input} !== 'string') {\n          if (${input} === null) {\n            json += JSON_STR_EMPTY_STRING\n          } else if (${input} instanceof Date) {\n            json += JSON_STR_QUOTE + ${input}.toISOString() + JSON_STR_QUOTE\n          } else if (${input} instanceof RegExp) {\n            json += serializer.asString(${input}.source)\n          } else {\n            json += serializer.asString(${input}.toString())\n          }\n        } else {\n          json += serializer.asString(${input})\n        }\n        `\n      }\n    }\n    case 'integer':\n      return `json += serializer.asInteger(${input})`\n    case 'number':\n      return `json += serializer.asNumber(${input})`\n    case 'boolean':\n      return `json += serializer.asBoolean(${input})`\n    case 'object': {\n      const funcName = buildObject(context, location)\n      return `json += ${funcName}(${input})`\n    }\n    case 'array': {\n      const funcName = buildArray(context, location)\n      return `json += ${funcName}(${input})`\n    }\n    case undefined:\n      return `json += JSON.stringify(${input})`\n    default:\n      throw new Error(`${schema.type} unsupported`)\n  }\n}\n\nfunction buildConstSerializer (location, input) {\n  const schema = location.schema\n  const type = schema.type\n\n  const hasNullType = Array.isArray(type) && type.includes('null')\n\n  let code = ''\n\n  if (hasNullType) {\n    code += `\n      if (${input} === null) {\n        json += JSON_STR_NULL\n      } else {\n    `\n  }\n\n  code += `json += '${JSON.stringify(schema.const).replace(SINGLE_TICK, \"\\\\'\")}'`\n\n  if (hasNullType) {\n    code += `\n      }\n    `\n  }\n\n  return code\n}\n\nfunction buildAllOf (context, location, input) {\n  const schema = location.schema\n\n  let mergedSchemaId = context.mergedSchemasIds.get(schema)\n  if (mergedSchemaId) {\n    const mergedLocation = getMergedLocation(context, mergedSchemaId)\n    return buildValue(context, mergedLocation, input)\n  }\n\n  mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`\n  context.mergedSchemasIds.set(schema, mergedSchemaId)\n\n  const { allOf, ...schemaWithoutAllOf } = location.schema\n  const locations = [\n    new Location(\n      schemaWithoutAllOf,\n      location.schemaId,\n      location.jsonPointer\n    )\n  ]\n\n  const allOfsLocation = location.getPropertyLocation('allOf')\n  for (let i = 0; i < allOf.length; i++) {\n    locations.push(allOfsLocation.getPropertyLocation(i))\n  }\n\n  const mergedLocation = mergeLocations(context, mergedSchemaId, locations)\n  return buildValue(context, mergedLocation, input)\n}\n\nfunction buildOneOf (context, location, input) {\n  context.validatorSchemasIds.add(location.schemaId)\n\n  const schema = location.schema\n\n  const type = schema.anyOf ? 'anyOf' : 'oneOf'\n  const { [type]: oneOfs, ...schemaWithoutAnyOf } = location.schema\n\n  const locationWithoutOneOf = new Location(\n    schemaWithoutAnyOf,\n    location.schemaId,\n    location.jsonPointer\n  )\n  const oneOfsLocation = location.getPropertyLocation(type)\n\n  let code = ''\n\n  for (let index = 0; index < oneOfs.length; index++) {\n    const optionLocation = oneOfsLocation.getPropertyLocation(index)\n    const optionSchema = optionLocation.schema\n\n    let mergedSchemaId = context.mergedSchemasIds.get(optionSchema)\n    let mergedLocation = null\n    if (mergedSchemaId) {\n      mergedLocation = getMergedLocation(context, mergedSchemaId)\n    } else {\n      mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`\n      context.mergedSchemasIds.set(optionSchema, mergedSchemaId)\n\n      mergedLocation = mergeLocations(context, mergedSchemaId, [\n        locationWithoutOneOf,\n        optionLocation\n      ])\n    }\n\n    const nestedResult = buildValue(context, mergedLocation, input)\n    const schemaRef = optionLocation.getSchemaRef()\n    code += `\n      ${index === 0 ? 'if' : 'else if'}(validator.validate(\"${schemaRef}\", ${input}))\n        ${nestedResult}\n    `\n  }\n\n  let schemaRef = location.getSchemaRef()\n  if (schemaRef.startsWith(context.rootSchemaId)) {\n    schemaRef = schemaRef.replace(context.rootSchemaId, '')\n  }\n\n  code += `\n    else throw new TypeError(\\`The value of '${schemaRef}' does not match schema definition.\\`)\n  `\n\n  return code\n}\n\nfunction buildIfThenElse (context, location, input) {\n  context.validatorSchemasIds.add(location.schemaId)\n\n  const {\n    if: ifSchema,\n    then: thenSchema,\n    else: elseSchema,\n    ...schemaWithoutIfThenElse\n  } = location.schema\n\n  const rootLocation = new Location(\n    schemaWithoutIfThenElse,\n    location.schemaId,\n    location.jsonPointer\n  )\n\n  const ifLocation = location.getPropertyLocation('if')\n  const ifSchemaRef = ifLocation.getSchemaRef()\n\n  const thenLocation = location.getPropertyLocation('then')\n  let thenMergedSchemaId = context.mergedSchemasIds.get(thenSchema)\n  let thenMergedLocation = null\n  if (thenMergedSchemaId) {\n    thenMergedLocation = getMergedLocation(context, thenMergedSchemaId)\n  } else {\n    thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`\n    context.mergedSchemasIds.set(thenSchema, thenMergedSchemaId)\n\n    thenMergedLocation = mergeLocations(context, thenMergedSchemaId, [\n      rootLocation,\n      thenLocation\n    ])\n  }\n\n  if (!elseSchema) {\n    return `\n      if (validator.validate(\"${ifSchemaRef}\", ${input})) {\n        ${buildValue(context, thenMergedLocation, input)}\n      } else {\n        ${buildValue(context, rootLocation, input)}\n      }\n    `\n  }\n\n  const elseLocation = location.getPropertyLocation('else')\n  let elseMergedSchemaId = context.mergedSchemasIds.get(elseSchema)\n  let elseMergedLocation = null\n  if (elseMergedSchemaId) {\n    elseMergedLocation = getMergedLocation(context, elseMergedSchemaId)\n  } else {\n    elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`\n    context.mergedSchemasIds.set(elseSchema, elseMergedSchemaId)\n\n    elseMergedLocation = mergeLocations(context, elseMergedSchemaId, [\n      rootLocation,\n      elseLocation\n    ])\n  }\n\n  return `\n    if (validator.validate(\"${ifSchemaRef}\", ${input})) {\n      ${buildValue(context, thenMergedLocation, input)}\n    } else {\n      ${buildValue(context, elseMergedLocation, input)}\n    }\n  `\n}\n\nfunction buildValue (context, location, input) {\n  let schema = location.schema\n\n  if (typeof schema === 'boolean') {\n    return `json += JSON.stringify(${input})`\n  }\n\n  if (schema.$ref) {\n    location = resolveRef(context, location)\n    schema = location.schema\n  }\n\n  if (schema.allOf) {\n    return buildAllOf(context, location, input)\n  }\n\n  if (schema.anyOf || schema.oneOf) {\n    return buildOneOf(context, location, input)\n  }\n\n  if (schema.if && schema.then) {\n    return buildIfThenElse(context, location, input)\n  }\n\n  if (schema.type === undefined) {\n    const inferredType = inferTypeByKeyword(schema)\n    if (inferredType) {\n      schema.type = inferredType\n    }\n  }\n\n  let code = ''\n\n  const type = schema.type\n  const nullable = schema.nullable === true\n  if (nullable) {\n    code += `\n      if (${input} === null) {\n        json += JSON_STR_NULL\n      } else {\n    `\n  }\n\n  if (schema.const !== undefined) {\n    code += buildConstSerializer(location, input)\n  } else if (Array.isArray(type)) {\n    code += buildMultiTypeSerializer(context, location, input)\n  } else {\n    code += buildSingleTypeSerializer(context, location, input)\n  }\n\n  if (nullable) {\n    code += `\n      }\n    `\n  }\n\n  return code\n}\n\nmodule.exports = build\nmodule.exports.default = build\nmodule.exports.build = build\n\nmodule.exports.validLargeArrayMechanisms = validLargeArrayMechanisms\n\nmodule.exports.restore = function ({ code, validator, serializer }) {\n  // eslint-disable-next-line\n  return (Function.apply(null, ['validator', 'serializer', code])\n    .apply(null, [validator, serializer]))\n}\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 2.2822265625,
          "content": "{\n  \"name\": \"fast-json-stringify\",\n  \"version\": \"6.0.0\",\n  \"description\": \"Stringify your JSON at max speed\",\n  \"main\": \"index.js\",\n  \"type\": \"commonjs\",\n  \"types\": \"types/index.d.ts\",\n  \"scripts\": {\n    \"bench\": \"node ./benchmark/bench.js\",\n    \"bench:cmp\": \"node ./benchmark/bench-cmp-branch.js\",\n    \"bench:cmp:ci\": \"node ./benchmark/bench-cmp-branch.js --ci\",\n    \"benchmark\": \"node ./benchmark/bench-cmp-lib.js\",\n    \"lint\": \"eslint\",\n    \"lint:fix\": \"eslint --fix\",\n    \"test:typescript\": \"tsd\",\n    \"test:unit\": \"c8 node --test\",\n    \"test\": \"npm run test:unit && npm run test:typescript\"\n  },\n  \"precommit\": [\n    \"lint\",\n    \"test\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/fastify/fast-json-stringify.git\"\n  },\n  \"keywords\": [\n    \"json\",\n    \"stringify\",\n    \"schema\",\n    \"fast\"\n  ],\n  \"author\": \"Matteo Collina <hello@matteocollina.com>\",\n  \"contributors\": [\n    {\n      \"name\": \"Tomas Della Vedova\",\n      \"url\": \"http://delved.org\"\n    },\n    {\n      \"name\": \"Aras Abbasi\",\n      \"email\": \"aras.abbasi@gmail.com\"\n    },\n    {\n      \"name\": \"Manuel Spigolon\",\n      \"email\": \"behemoth89@gmail.com\"\n    },\n    {\n      \"name\": \"Frazer Smith\",\n      \"email\": \"frazer.dev@icloud.com\",\n      \"url\": \"https://github.com/fdawgs\"\n    }\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/fastify/fast-json-stringify/issues\"\n  },\n  \"homepage\": \"https://github.com/fastify/fast-json-stringify#readme\",\n  \"funding\": [\n    {\n      \"type\": \"github\",\n      \"url\": \"https://github.com/sponsors/fastify\"\n    },\n    {\n      \"type\": \"opencollective\",\n      \"url\": \"https://opencollective.com/fastify\"\n    }\n  ],\n  \"devDependencies\": {\n    \"@fastify/pre-commit\": \"^2.1.0\",\n    \"@sinclair/typebox\": \"^0.34.3\",\n    \"benchmark\": \"^2.1.4\",\n    \"c8\": \"^10.1.2\",\n    \"cli-select\": \"^1.1.2\",\n    \"compile-json-stringify\": \"^0.1.2\",\n    \"eslint\": \"^9.17.0\",\n    \"fast-json-stringify\": \".\",\n    \"is-my-json-valid\": \"^2.20.6\",\n    \"neostandard\": \"^0.12.0\",\n    \"simple-git\": \"^3.23.0\",\n    \"tsd\": \"^0.31.0\",\n    \"webpack\": \"^5.90.3\"\n  },\n  \"dependencies\": {\n    \"@fastify/merge-json-schemas\": \"^0.2.0\",\n    \"ajv\": \"^8.12.0\",\n    \"ajv-formats\": \"^3.0.1\",\n    \"fast-uri\": \"^3.0.0\",\n    \"json-schema-ref-resolver\": \"^2.0.0\",\n    \"rfdc\": \"^1.2.0\"\n  },\n  \"runkitExampleFilename\": \"./examples/example.js\"\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}