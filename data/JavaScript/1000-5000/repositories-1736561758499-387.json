{
  "metadata": {
    "timestamp": 1736561758499,
    "page": 387,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "xviniette/FlappyLearning",
      "stars": 3995,
      "defaultBranch": "gh-pages",
      "files": [
        {
          "name": "License",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2016 Vincent Bazia\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Neuroevolution.js",
          "type": "blob",
          "size": 13.607421875,
          "content": "/**\n * Provides a set of classes and methods for handling Neuroevolution and\n * genetic algorithms.\n *\n * @param {options} An object of options for Neuroevolution.\n */\nvar Neuroevolution = function (options) {\n\tvar self = this; // reference to the top scope of this module\n\n\t// Declaration of module parameters (options) and default values\n\tself.options = {\n\t\t/**\n\t\t * Logistic activation function.\n\t\t *\n\t\t * @param {a} Input value.\n\t\t * @return Logistic function output.\n\t\t */\n\t\tactivation: function (a) {\n\t\t\tap = (-a) / 1;\n\t\t\treturn (1 / (1 + Math.exp(ap)))\n\t\t},\n\n\t\t/**\n\t\t * Returns a random value between -1 and 1.\n\t\t *\n\t\t * @return Random value.\n\t\t */\n\t\trandomClamped: function () {\n\t\t\treturn Math.random() * 2 - 1;\n\t\t},\n\n\t\t// various factors and parameters (along with default values).\n\t\tnetwork: [1, [1], 1], // Perceptron network structure (1 hidden\n\t\t// layer).\n\t\tpopulation: 50, // Population by generation.\n\t\telitism: 0.2, // Best networks kepts unchanged for the next\n\t\t// generation (rate).\n\t\trandomBehaviour: 0.2, // New random networks for the next generation\n\t\t// (rate).\n\t\tmutationRate: 0.1, // Mutation rate on the weights of synapses.\n\t\tmutationRange: 0.5, // Interval of the mutation changes on the\n\t\t// synapse weight.\n\t\thistoric: 0, // Latest generations saved.\n\t\tlowHistoric: false, // Only save score (not the network).\n\t\tscoreSort: -1, // Sort order (-1 = desc, 1 = asc).\n\t\tnbChild: 1 // Number of children by breeding.\n\n\t}\n\n\t/**\n\t * Override default options.\n\t *\n\t * @param {options} An object of Neuroevolution options.\n\t * @return void\n\t */\n\tself.set = function (options) {\n\t\tfor (var i in options) {\n\t\t\tif (this.options[i] != undefined) { // Only override if the passed in value\n\t\t\t\t// is actually defined.\n\t\t\t\tself.options[i] = options[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t// Overriding default options with the pass in options\n\tself.set(options);\n\n\n\t/*NEURON**********************************************************************/\n\t/**\n\t * Artificial Neuron class\n\t *\n\t * @constructor\n\t */\n\tvar Neuron = function () {\n\t\tthis.value = 0;\n\t\tthis.weights = [];\n\t}\n\n\t/**\n\t * Initialize number of neuron weights to random clamped values.\n\t *\n\t * @param {nb} Number of neuron weights (number of inputs).\n\t * @return void\n\t */\n\tNeuron.prototype.populate = function (nb) {\n\t\tthis.weights = [];\n\t\tfor (var i = 0; i < nb; i++) {\n\t\t\tthis.weights.push(self.options.randomClamped());\n\t\t}\n\t}\n\n\n\t/*LAYER***********************************************************************/\n\t/**\n\t * Neural Network Layer class.\n\t *\n\t * @constructor\n\t * @param {index} Index of this Layer in the Network.\n\t */\n\tvar Layer = function (index) {\n\t\tthis.id = index || 0;\n\t\tthis.neurons = [];\n\t}\n\n\t/**\n\t * Populate the Layer with a set of randomly weighted Neurons.\n\t *\n\t * Each Neuron be initialied with nbInputs inputs with a random clamped\n\t * value.\n\t *\n\t * @param {nbNeurons} Number of neurons.\n\t * @param {nbInputs} Number of inputs.\n\t * @return void\n\t */\n\tLayer.prototype.populate = function (nbNeurons, nbInputs) {\n\t\tthis.neurons = [];\n\t\tfor (var i = 0; i < nbNeurons; i++) {\n\t\t\tvar n = new Neuron();\n\t\t\tn.populate(nbInputs);\n\t\t\tthis.neurons.push(n);\n\t\t}\n\t}\n\n\n\t/*NEURAL NETWORK**************************************************************/\n\t/**\n\t * Neural Network class\n\t *\n\t * Composed of Neuron Layers.\n\t *\n\t * @constructor\n\t */\n\tvar Network = function () {\n\t\tthis.layers = [];\n\t}\n\n\t/**\n\t * Generate the Network layers.\n\t *\n\t * @param {input} Number of Neurons in Input layer.\n\t * @param {hidden} Number of Neurons per Hidden layer.\n\t * @param {output} Number of Neurons in Output layer.\n\t * @return void\n\t */\n\tNetwork.prototype.perceptronGeneration = function (input, hiddens, output) {\n\t\tvar index = 0;\n\t\tvar previousNeurons = 0;\n\t\tvar layer = new Layer(index);\n\t\tlayer.populate(input, previousNeurons); // Number of Inputs will be set to\n\t\t// 0 since it is an input layer.\n\t\tpreviousNeurons = input; // number of input is size of previous layer.\n\t\tthis.layers.push(layer);\n\t\tindex++;\n\t\tfor (var i in hiddens) {\n\t\t\t// Repeat same process as first layer for each hidden layer.\n\t\t\tvar layer = new Layer(index);\n\t\t\tlayer.populate(hiddens[i], previousNeurons);\n\t\t\tpreviousNeurons = hiddens[i];\n\t\t\tthis.layers.push(layer);\n\t\t\tindex++;\n\t\t}\n\t\tvar layer = new Layer(index);\n\t\tlayer.populate(output, previousNeurons); // Number of input is equal to\n\t\t// the size of the last hidden\n\t\t// layer.\n\t\tthis.layers.push(layer);\n\t}\n\n\t/**\n\t * Create a copy of the Network (neurons and weights).\n\t *\n\t * Returns number of neurons per layer and a flat array of all weights.\n\t *\n\t * @return Network data.\n\t */\n\tNetwork.prototype.getSave = function () {\n\t\tvar datas = {\n\t\t\tneurons: [], // Number of Neurons per layer.\n\t\t\tweights: [] // Weights of each Neuron's inputs.\n\t\t};\n\n\t\tfor (var i in this.layers) {\n\t\t\tdatas.neurons.push(this.layers[i].neurons.length);\n\t\t\tfor (var j in this.layers[i].neurons) {\n\t\t\t\tfor (var k in this.layers[i].neurons[j].weights) {\n\t\t\t\t\t// push all input weights of each Neuron of each Layer into a flat\n\t\t\t\t\t// array.\n\t\t\t\t\tdatas.weights.push(this.layers[i].neurons[j].weights[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn datas;\n\t}\n\n\t/**\n\t * Apply network data (neurons and weights).\n\t *\n\t * @param {save} Copy of network data (neurons and weights).\n\t * @return void\n\t */\n\tNetwork.prototype.setSave = function (save) {\n\t\tvar previousNeurons = 0;\n\t\tvar index = 0;\n\t\tvar indexWeights = 0;\n\t\tthis.layers = [];\n\t\tfor (var i in save.neurons) {\n\t\t\t// Create and populate layers.\n\t\t\tvar layer = new Layer(index);\n\t\t\tlayer.populate(save.neurons[i], previousNeurons);\n\t\t\tfor (var j in layer.neurons) {\n\t\t\t\tfor (var k in layer.neurons[j].weights) {\n\t\t\t\t\t// Apply neurons weights to each Neuron.\n\t\t\t\t\tlayer.neurons[j].weights[k] = save.weights[indexWeights];\n\n\t\t\t\t\tindexWeights++; // Increment index of flat array.\n\t\t\t\t}\n\t\t\t}\n\t\t\tpreviousNeurons = save.neurons[i];\n\t\t\tindex++;\n\t\t\tthis.layers.push(layer);\n\t\t}\n\t}\n\n\t/**\n\t * Compute the output of an input.\n\t *\n\t * @param {inputs} Set of inputs.\n\t * @return Network output.\n\t */\n\tNetwork.prototype.compute = function (inputs) {\n\t\t// Set the value of each Neuron in the input layer.\n\t\tfor (var i in inputs) {\n\t\t\tif (this.layers[0] && this.layers[0].neurons[i]) {\n\t\t\t\tthis.layers[0].neurons[i].value = inputs[i];\n\t\t\t}\n\t\t}\n\n\t\tvar prevLayer = this.layers[0]; // Previous layer is input layer.\n\t\tfor (var i = 1; i < this.layers.length; i++) {\n\t\t\tfor (var j in this.layers[i].neurons) {\n\t\t\t\t// For each Neuron in each layer.\n\t\t\t\tvar sum = 0;\n\t\t\t\tfor (var k in prevLayer.neurons) {\n\t\t\t\t\t// Every Neuron in the previous layer is an input to each Neuron in\n\t\t\t\t\t// the next layer.\n\t\t\t\t\tsum += prevLayer.neurons[k].value *\n\t\t\t\t\t\tthis.layers[i].neurons[j].weights[k];\n\t\t\t\t}\n\n\t\t\t\t// Compute the activation of the Neuron.\n\t\t\t\tthis.layers[i].neurons[j].value = self.options.activation(sum);\n\t\t\t}\n\t\t\tprevLayer = this.layers[i];\n\t\t}\n\n\t\t// All outputs of the Network.\n\t\tvar out = [];\n\t\tvar lastLayer = this.layers[this.layers.length - 1];\n\t\tfor (var i in lastLayer.neurons) {\n\t\t\tout.push(lastLayer.neurons[i].value);\n\t\t}\n\t\treturn out;\n\t}\n\n\n\t/*GENOME**********************************************************************/\n\t/**\n\t * Genome class.\n\t *\n\t * Composed of a score and a Neural Network.\n\t *\n\t * @constructor\n\t *\n\t * @param {score}\n\t * @param {network}\n\t */\n\tvar Genome = function (score, network) {\n\t\tthis.score = score || 0;\n\t\tthis.network = network || null;\n\t}\n\n\n\t/*GENERATION******************************************************************/\n\t/**\n\t * Generation class.\n\t *\n\t * Composed of a set of Genomes.\n\t *\n\t * @constructor\n\t */\n\tvar Generation = function () {\n\t\tthis.genomes = [];\n\t}\n\n\t/**\n\t * Add a genome to the generation.\n\t *\n\t * @param {genome} Genome to add.\n\t * @return void.\n\t */\n\tGeneration.prototype.addGenome = function (genome) {\n\t\t// Locate position to insert Genome into.\n\t\t// The gnomes should remain sorted.\n\t\tfor (var i = 0; i < this.genomes.length; i++) {\n\t\t\t// Sort in descending order.\n\t\t\tif (self.options.scoreSort < 0) {\n\t\t\t\tif (genome.score > this.genomes[i].score) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Sort in ascending order.\n\t\t\t} else {\n\t\t\t\tif (genome.score < this.genomes[i].score) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// Insert genome into correct position.\n\t\tthis.genomes.splice(i, 0, genome);\n\t}\n\n\t/**\n\t * Breed to genomes to produce offspring(s).\n\t *\n\t * @param {g1} Genome 1.\n\t * @param {g2} Genome 2.\n\t * @param {nbChilds} Number of offspring (children).\n\t */\n\tGeneration.prototype.breed = function (g1, g2, nbChilds) {\n\t\tvar datas = [];\n\t\tfor (var nb = 0; nb < nbChilds; nb++) {\n\t\t\t// Deep clone of genome 1.\n\t\t\tvar data = JSON.parse(JSON.stringify(g1));\n\t\t\tfor (var i in g2.network.weights) {\n\t\t\t\t// Genetic crossover\n\t\t\t\t// 0.5 is the crossover factor.\n\t\t\t\t// FIXME Really should be a predefined constant.\n\t\t\t\tif (Math.random() <= 0.5) {\n\t\t\t\t\tdata.network.weights[i] = g2.network.weights[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Perform mutation on some weights.\n\t\t\tfor (var i in data.network.weights) {\n\t\t\t\tif (Math.random() <= self.options.mutationRate) {\n\t\t\t\t\tdata.network.weights[i] += Math.random() *\n\t\t\t\t\t\tself.options.mutationRange *\n\t\t\t\t\t\t2 -\n\t\t\t\t\t\tself.options.mutationRange;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdatas.push(data);\n\t\t}\n\n\t\treturn datas;\n\t}\n\n\t/**\n\t * Generate the next generation.\n\t *\n\t * @return Next generation data array.\n\t */\n\tGeneration.prototype.generateNextGeneration = function () {\n\t\tvar nexts = [];\n\n\t\tfor (var i = 0; i < Math.round(self.options.elitism *\n\t\t\t\tself.options.population); i++) {\n\t\t\tif (nexts.length < self.options.population) {\n\t\t\t\t// Push a deep copy of ith Genome's Nethwork.\n\t\t\t\tnexts.push(JSON.parse(JSON.stringify(this.genomes[i].network)));\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < Math.round(self.options.randomBehaviour *\n\t\t\t\tself.options.population); i++) {\n\t\t\tvar n = JSON.parse(JSON.stringify(this.genomes[0].network));\n\t\t\tfor (var k in n.weights) {\n\t\t\t\tn.weights[k] = self.options.randomClamped();\n\t\t\t}\n\t\t\tif (nexts.length < self.options.population) {\n\t\t\t\tnexts.push(n);\n\t\t\t}\n\t\t}\n\n\t\tvar max = 0;\n\t\twhile (true) {\n\t\t\tfor (var i = 0; i < max; i++) {\n\t\t\t\t// Create the children and push them to the nexts array.\n\t\t\t\tvar childs = this.breed(this.genomes[i], this.genomes[max],\n\t\t\t\t\t(self.options.nbChild > 0 ? self.options.nbChild : 1));\n\t\t\t\tfor (var c in childs) {\n\t\t\t\t\tnexts.push(childs[c].network);\n\t\t\t\t\tif (nexts.length >= self.options.population) {\n\t\t\t\t\t\t// Return once number of children is equal to the\n\t\t\t\t\t\t// population by generatino value.\n\t\t\t\t\t\treturn nexts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax++;\n\t\t\tif (max >= this.genomes.length - 1) {\n\t\t\t\tmax = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/*GENERATIONS*****************************************************************/\n\t/**\n\t * Generations class.\n\t *\n\t * Hold's previous Generations and current Generation.\n\t *\n\t * @constructor\n\t */\n\tvar Generations = function () {\n\t\tthis.generations = [];\n\t\tvar currentGeneration = new Generation();\n\t}\n\n\t/**\n\t * Create the first generation.\n\t *\n\t * @param {input} Input layer.\n\t * @param {input} Hidden layer(s).\n\t * @param {output} Output layer.\n\t * @return First Generation.\n\t */\n\tGenerations.prototype.firstGeneration = function (input, hiddens, output) {\n\t\t// FIXME input, hiddens, output unused.\n\n\t\tvar out = [];\n\t\tfor (var i = 0; i < self.options.population; i++) {\n\t\t\t// Generate the Network and save it.\n\t\t\tvar nn = new Network();\n\t\t\tnn.perceptronGeneration(self.options.network[0],\n\t\t\t\tself.options.network[1],\n\t\t\t\tself.options.network[2]);\n\t\t\tout.push(nn.getSave());\n\t\t}\n\n\t\tthis.generations.push(new Generation());\n\t\treturn out;\n\t}\n\n\t/**\n\t * Create the next Generation.\n\t *\n\t * @return Next Generation.\n\t */\n\tGenerations.prototype.nextGeneration = function () {\n\t\tif (this.generations.length == 0) {\n\t\t\t// Need to create first generation.\n\t\t\treturn false;\n\t\t}\n\n\t\tvar gen = this.generations[this.generations.length - 1]\n\t\t\t.generateNextGeneration();\n\t\tthis.generations.push(new Generation());\n\t\treturn gen;\n\t}\n\n\t/**\n\t * Add a genome to the Generations.\n\t *\n\t * @param {genome}\n\t * @return False if no Generations to add to.\n\t */\n\tGenerations.prototype.addGenome = function (genome) {\n\t\t// Can't add to a Generation if there are no Generations.\n\t\tif (this.generations.length == 0) return false;\n\n\t\t// FIXME addGenome returns void.\n\t\treturn this.generations[this.generations.length - 1].addGenome(genome);\n\t}\n\n\n\t/*SELF************************************************************************/\n\tself.generations = new Generations();\n\n\t/**\n\t * Reset and create a new Generations object.\n\t *\n\t * @return void.\n\t */\n\tself.restart = function () {\n\t\tself.generations = new Generations();\n\t}\n\n\t/**\n\t * Create the next generation.\n\t *\n\t * @return Neural Network array for next Generation.\n\t */\n\tself.nextGeneration = function () {\n\t\tvar networks = [];\n\n\t\tif (self.generations.generations.length == 0) {\n\t\t\t// If no Generations, create first.\n\t\t\tnetworks = self.generations.firstGeneration();\n\t\t} else {\n\t\t\t// Otherwise, create next one.\n\t\t\tnetworks = self.generations.nextGeneration();\n\t\t}\n\n\t\t// Create Networks from the current Generation.\n\t\tvar nns = [];\n\t\tfor (var i in networks) {\n\t\t\tvar nn = new Network();\n\t\t\tnn.setSave(networks[i]);\n\t\t\tnns.push(nn);\n\t\t}\n\n\t\tif (self.options.lowHistoric) {\n\t\t\t// Remove old Networks.\n\t\t\tif (self.generations.generations.length >= 2) {\n\t\t\t\tvar genomes =\n\t\t\t\t\tself.generations\n\t\t\t\t\t.generations[self.generations.generations.length - 2]\n\t\t\t\t\t.genomes;\n\t\t\t\tfor (var i in genomes) {\n\t\t\t\t\tdelete genomes[i].network;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (self.options.historic != -1) {\n\t\t\t// Remove older generations.\n\t\t\tif (self.generations.generations.length > self.options.historic + 1) {\n\t\t\t\tself.generations.generations.splice(0,\n\t\t\t\t\tself.generations.generations.length - (self.options.historic + 1));\n\t\t\t}\n\t\t}\n\n\t\treturn nns;\n\t}\n\n\t/**\n\t * Adds a new Genome with specified Neural Network and score.\n\t *\n\t * @param {network} Neural Network.\n\t * @param {score} Score value.\n\t * @return void.\n\t */\n\tself.networkScore = function (network, score) {\n\t\tself.generations.addGenome(new Genome(score, network.getSave()));\n\t}\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.5302734375,
          "content": "# Flappy Learning ([Demo](http://xviniette.github.io/FlappyLearning/))\n\nProgram that learns to play Flappy Bird by machine learning ([Neuroevolution](http://www.scholarpedia.org/article/Neuroevolution))\n\n![alt tag](https://github.com/xviniette/FlappyLearning/blob/gh-pages/img/flappy.png?raw=true)\n\n### [NeuroEvolution.js](http://github.com/xviniette/FlappyLearning/blob/gh-pages/Neuroevolution.js) : Utilization\n```javascript\n// Initialize\nvar ne = new Neuroevolution({options});\n\n//Default options values\nvar options = {\n    network:[1, [1], 1],    // Perceptron structure\n    population:50,          // Population by generation\n    elitism:0.2,            // Best networks kepts unchanged for the next generation (rate)\n    randomBehaviour:0.2,    // New random networks for the next generation (rate)\n    mutationRate:0.1,       // Mutation rate on the weights of synapses\n    mutationRange:0.5,      // Interval of the mutation changes on the synapse weight\n    historic:0,             // Latest generations saved\n    lowHistoric:false,      // Only save score (not the network)\n    scoreSort:-1,           // Sort order (-1 = desc, 1 = asc)\n    nbChild:1               // number of child by breeding\n}\n\n//Update options at any time\nne.set({options});\n\n// Generate first or next generation\nvar generation = ne.nextGeneration();\n\n//When an network is over -> save this score\nne.networkScore(generation[x], <score = 0>);\n```\n\nYou can see the NeuroEvolution integration in Flappy Bird in [Game.js](http://github.com/xviniette/FlappyLearning/blob/gh-pages/game.js).\n"
        },
        {
          "name": "game.js",
          "type": "blob",
          "size": 6.2763671875,
          "content": "(function() {\n\tvar timeouts = [];\n\tvar messageName = \"zero-timeout-message\";\n\n\tfunction setZeroTimeout(fn) {\n\t\ttimeouts.push(fn);\n\t\twindow.postMessage(messageName, \"*\");\n\t}\n\n\tfunction handleMessage(event) {\n\t\tif (event.source == window && event.data == messageName) {\n\t\t\tevent.stopPropagation();\n\t\t\tif (timeouts.length > 0) {\n\t\t\t\tvar fn = timeouts.shift();\n\t\t\t\tfn();\n\t\t\t}\n\t\t}\n\t}\n\n\twindow.addEventListener(\"message\", handleMessage, true);\n\n\twindow.setZeroTimeout = setZeroTimeout;\n})();\n\nvar Neuvol;\nvar game;\nvar FPS = 60;\nvar maxScore=0;\n\nvar images = {};\n\nvar speed = function(fps){\n\tFPS = parseInt(fps);\n}\n\nvar loadImages = function(sources, callback){\n\tvar nb = 0;\n\tvar loaded = 0;\n\tvar imgs = {};\n\tfor(var i in sources){\n\t\tnb++;\n\t\timgs[i] = new Image();\n\t\timgs[i].src = sources[i];\n\t\timgs[i].onload = function(){\n\t\t\tloaded++;\n\t\t\tif(loaded == nb){\n\t\t\t\tcallback(imgs);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar Bird = function(json){\n\tthis.x = 80;\n\tthis.y = 250;\n\tthis.width = 40;\n\tthis.height = 30;\n\n\tthis.alive = true;\n\tthis.gravity = 0;\n\tthis.velocity = 0.3;\n\tthis.jump = -6;\n\n\tthis.init(json);\n}\n\nBird.prototype.init = function(json){\n\tfor(var i in json){\n\t\tthis[i] = json[i];\n\t}\n}\n\nBird.prototype.flap = function(){\n\tthis.gravity = this.jump;\n}\n\nBird.prototype.update = function(){\n\tthis.gravity += this.velocity;\n\tthis.y += this.gravity;\n}\n\nBird.prototype.isDead = function(height, pipes){\n\tif(this.y >= height || this.y + this.height <= 0){\n\t\treturn true;\n\t}\n\tfor(var i in pipes){\n\t\tif(!(\n\t\t\tthis.x > pipes[i].x + pipes[i].width ||\n\t\t\tthis.x + this.width < pipes[i].x || \n\t\t\tthis.y > pipes[i].y + pipes[i].height ||\n\t\t\tthis.y + this.height < pipes[i].y\n\t\t\t)){\n\t\t\treturn true;\n\t}\n}\n}\n\nvar Pipe = function(json){\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.width = 50;\n\tthis.height = 40;\n\tthis.speed = 3;\n\n\tthis.init(json);\n}\n\nPipe.prototype.init = function(json){\n\tfor(var i in json){\n\t\tthis[i] = json[i];\n\t}\n}\n\nPipe.prototype.update = function(){\n\tthis.x -= this.speed;\n}\n\nPipe.prototype.isOut = function(){\n\tif(this.x + this.width < 0){\n\t\treturn true;\n\t}\n}\n\nvar Game = function(){\n\tthis.pipes = [];\n\tthis.birds = [];\n\tthis.score = 0;\n\tthis.canvas = document.querySelector(\"#flappy\");\n\tthis.ctx = this.canvas.getContext(\"2d\");\n\tthis.width = this.canvas.width;\n\tthis.height = this.canvas.height;\n\tthis.spawnInterval = 90;\n\tthis.interval = 0;\n\tthis.gen = [];\n\tthis.alives = 0;\n\tthis.generation = 0;\n\tthis.backgroundSpeed = 0.5;\n\tthis.backgroundx = 0;\n\tthis.maxScore = 0;\n}\n\nGame.prototype.start = function(){\n\tthis.interval = 0;\n\tthis.score = 0;\n\tthis.pipes = [];\n\tthis.birds = [];\n\n\tthis.gen = Neuvol.nextGeneration();\n\tfor(var i in this.gen){\n\t\tvar b = new Bird();\n\t\tthis.birds.push(b)\n\t}\n\tthis.generation++;\n\tthis.alives = this.birds.length;\n}\n\nGame.prototype.update = function(){\n\tthis.backgroundx += this.backgroundSpeed;\n\tvar nextHoll = 0;\n\tif(this.birds.length > 0){\n\t\tfor(var i = 0; i < this.pipes.length; i+=2){\n\t\t\tif(this.pipes[i].x + this.pipes[i].width > this.birds[0].x){\n\t\t\t\tnextHoll = this.pipes[i].height/this.height;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(var i in this.birds){\n\t\tif(this.birds[i].alive){\n\n\t\t\tvar inputs = [\n\t\t\tthis.birds[i].y / this.height,\n\t\t\tnextHoll\n\t\t\t];\n\n\t\t\tvar res = this.gen[i].compute(inputs);\n\t\t\tif(res > 0.5){\n\t\t\t\tthis.birds[i].flap();\n\t\t\t}\n\n\t\t\tthis.birds[i].update();\n\t\t\tif(this.birds[i].isDead(this.height, this.pipes)){\n\t\t\t\tthis.birds[i].alive = false;\n\t\t\t\tthis.alives--;\n\t\t\t\t//console.log(this.alives);\n\t\t\t\tNeuvol.networkScore(this.gen[i], this.score);\n\t\t\t\tif(this.isItEnd()){\n\t\t\t\t\tthis.start();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(var i = 0; i < this.pipes.length; i++){\n\t\tthis.pipes[i].update();\n\t\tif(this.pipes[i].isOut()){\n\t\t\tthis.pipes.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\n\tif(this.interval == 0){\n\t\tvar deltaBord = 50;\n\t\tvar pipeHoll = 120;\n\t\tvar hollPosition = Math.round(Math.random() * (this.height - deltaBord * 2 - pipeHoll)) +  deltaBord;\n\t\tthis.pipes.push(new Pipe({x:this.width, y:0, height:hollPosition}));\n\t\tthis.pipes.push(new Pipe({x:this.width, y:hollPosition+pipeHoll, height:this.height}));\n\t}\n\n\tthis.interval++;\n\tif(this.interval == this.spawnInterval){\n\t\tthis.interval = 0;\n\t}\n\n\tthis.score++;\n\tthis.maxScore = (this.score > this.maxScore) ? this.score : this.maxScore;\n\tvar self = this;\n\n\tif(FPS == 0){\n\t\tsetZeroTimeout(function(){\n\t\t\tself.update();\n\t\t});\n\t}else{\n\t\tsetTimeout(function(){\n\t\t\tself.update();\n\t\t}, 1000/FPS);\n\t}\n}\n\n\nGame.prototype.isItEnd = function(){\n\tfor(var i in this.birds){\n\t\tif(this.birds[i].alive){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nGame.prototype.display = function(){\n\tthis.ctx.clearRect(0, 0, this.width, this.height);\n\tfor(var i = 0; i < Math.ceil(this.width / images.background.width) + 1; i++){\n\t\tthis.ctx.drawImage(images.background, i * images.background.width - Math.floor(this.backgroundx%images.background.width), 0)\n\t}\n\n\tfor(var i in this.pipes){\n\t\tif(i%2 == 0){\n\t\t\tthis.ctx.drawImage(images.pipetop, this.pipes[i].x, this.pipes[i].y + this.pipes[i].height - images.pipetop.height, this.pipes[i].width, images.pipetop.height);\n\t\t}else{\n\t\t\tthis.ctx.drawImage(images.pipebottom, this.pipes[i].x, this.pipes[i].y, this.pipes[i].width, images.pipetop.height);\n\t\t}\n\t}\n\n\tthis.ctx.fillStyle = \"#FFC600\";\n\tthis.ctx.strokeStyle = \"#CE9E00\";\n\tfor(var i in this.birds){\n\t\tif(this.birds[i].alive){\n\t\t\tthis.ctx.save(); \n\t\t\tthis.ctx.translate(this.birds[i].x + this.birds[i].width/2, this.birds[i].y + this.birds[i].height/2);\n\t\t\tthis.ctx.rotate(Math.PI/2 * this.birds[i].gravity/20);\n\t\t\tthis.ctx.drawImage(images.bird, -this.birds[i].width/2, -this.birds[i].height/2, this.birds[i].width, this.birds[i].height);\n\t\t\tthis.ctx.restore();\n\t\t}\n\t}\n\n\tthis.ctx.fillStyle = \"white\";\n\tthis.ctx.font=\"20px Oswald, sans-serif\";\n\tthis.ctx.fillText(\"Score : \"+ this.score, 10, 25);\n\tthis.ctx.fillText(\"Max Score : \"+this.maxScore, 10, 50);\n\tthis.ctx.fillText(\"Generation : \"+this.generation, 10, 75);\n\tthis.ctx.fillText(\"Alive : \"+this.alives+\" / \"+Neuvol.options.population, 10, 100);\n\n\tvar self = this;\n\trequestAnimationFrame(function(){\n\t\tself.display();\n\t});\n}\n\nwindow.onload = function(){\n\tvar sprites = {\n\t\tbird:\"./img/bird.png\",\n\t\tbackground:\"./img/background.png\",\n\t\tpipetop:\"./img/pipetop.png\",\n\t\tpipebottom:\"./img/pipebottom.png\"\n\t}\n\n\tvar start = function(){\n\t\tNeuvol = new Neuroevolution({\n\t\t\tpopulation:50,\n\t\t\tnetwork:[2, [2], 1],\n\t\t});\n\t\tgame = new Game();\n\t\tgame.start();\n\t\tgame.update();\n\t\tgame.display();\n\t}\n\n\n\tloadImages(sprites, function(imgs){\n\t\timages = imgs;\n\t\tstart();\n\t})\n\n}\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.html",
          "type": "blob",
          "size": 0.623046875,
          "content": "<!DOCTYPE html>\n<html>\n<head>\n\t<title>NeuroEvolution : Flappy Bird</title>\n\t<link href='https://fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>\n</head>\n<body>\n\t<canvas id=\"flappy\" width=\"500\" height=\"512\"></canvas> <br/>\n\t<button onclick=\"speed(60)\">x1</button> \n\t<button onclick=\"speed(120)\">x2</button> \n\t<button onclick=\"speed(180)\">x3</button> \n\t<button onclick=\"speed(300)\">x5</button> \n\t<button onclick=\"speed(0)\">MAX</button> \n\t<br/>\n\t<a href=\"http://github.com/xviniette/FlappyLearning\">GitHub Repository</a>\n\t<script src = \"Neuroevolution.js\"></script>\n\t<script src = \"game.js\"></script>\n</body>\n</html>"
        }
      ]
    }
  ]
}