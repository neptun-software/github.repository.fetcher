{
  "metadata": {
    "timestamp": 1736561905717,
    "page": 596,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "HeiSir2014/M3U8-Downloader",
      "stars": 3628,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.048828125,
          "content": "[Nn]ode_modules/\nyarn.lock\nyarn-*\ndist/\n.DS_Store\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": ".yarnclean",
          "type": "blob",
          "size": 0.4580078125,
          "content": "# test directories\n__tests__\ntest\ntests\npowered-test\n\n# asset directories\ndocs\ndoc\nwebsite\nimages\nassets\n\n# examples\nexample\nexamples\n\n# code coverage directories\ncoverage\n.nyc_output\n\n# build scripts\nMakefile\nGulpfile.js\nGruntfile.js\n\n# configs\nappveyor.yml\ncircle.yml\ncodeship-services.yml\ncodeship-steps.yml\nwercker.yml\n.tern-project\n.gitattributes\n.editorconfig\n.*ignore\n.eslintrc\n.jshintrc\n.flowconfig\n.documentup.json\n.yarn-metadata.json\n.travis.yml\n\n# misc\n*.md\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.5068359375,
          "content": "\n![M3U8-Downloader-Build](https://img.shields.io/github/workflow/status/heisir2014/M3U8-Downloader/M3U8-Downloader-Build?style=flat-square)\n[![Release](https://img.shields.io/github/v/release/heisir2014/m3u8-downloader?style=flat-square)](https://github.com/HeiSir2014/M3U8-Downloader/releases/latest)\n[![Download](https://img.shields.io/github/downloads/heisir2014/m3u8-downloader/total?style=flat-square)](https://github.com/HeiSir2014/M3U8-Downloader/releases/latest)\n# M3U8-Downloader [直接下载](#下载可执行包)\nM3U8-Downloader是基于Electron框架开发的一款可以下载、播放HLS视频流的APP，功能特点如下：\n\n| 功能 | 支持 |\n| :-- | --: |\n| HLS协议点播源 | ✓ |\n| 自定义Http协议头下载 | ✓ |\n| 自定义KEY和IV解密 | ✓ |\n| 本地M3U8文件下载 | ✓ |\n| M3U8 直播源 | ✓ |\n| 标准 AES-128-CBC加密 | ✓ |\n| 标准 AES-196-CBC加密 | ✓ |\n| 标准 AES-256-CBC加密 | ✓ |\n| 非标准 AES-*-CBC加密 | ㄨ(可定制) |\n| 网页嗅探视频源 | ✓ |\n\n\n<div align=\"center\">\n    <br>\n    <img width=\"739\" src=\"https://github.com/HeiSir2014/M3U8-Downloader/blob/master/resource/HLSDownloadShow-3-1.gif?raw=true\" alt=\"M3U8-Downloader\">\n    <br>\n</div>\n\n# 功能规划\n\n```mermaid\nflowchart LR\n    A1(\"M3U8-Downloader\") ---> B1(\"MP4、M3U8、MPD下载\")\n    B1 ---> C1(自定义 文件名)\n    B1 ---> C2(自定义 Http Header)\n    C2 ---> D1(\"Referer、Cookies、User-Agent\")\n    B1 ---> C3(自定义 AES Key)\n    B1 ---> C4(多码率选择)\n    B1 ---> C5(HTTP代理)\n    \n    A1 ---> B2(\"MP4、M3U8、MPD批量下载\")\n    A1 ---> B3(\"TS文件合并\")\n    A1 ---> B4(\"浏览器资源嗅探\")\n    B4 ---> C6(\"FLV、MP4、MP3、WAV\")\n    B4 ---> C7(\"HLS(M3U8、TS)\")\n    B4 ---> C8(\"DASH(MPD)\")\n    B4 ---> C12(模拟多终端)\n    A1 ---> B5(\"Settings\")\n    B5 ---> C9(存储路径)\n    B5 ---> C10(设置代理)\n    B5 ---> C11(日志查看)\n```\n![mermaid-diagram-20210328004859](https://i.loli.net/2021/03/28/Ca5yhFQeTmG69DK.png)\n\n---\n\n# 获取M3U8视频地址\n\n在chrome浏览器打开视频网页，按下F12,页签点击到Network页面，在Filter框里输入\"m3u8\",然后按F5刷新页面，如果网页里的视频使用的是HLS源，就可以在这里捕获到视频流地址，然后选中右键 Copy -> Copy Link Address.\n提供m3u8源地址，下载并无损转码Mp4文件\n\n[自定义头添加-视频教程](https://player.bilibili.com/player.html?aid=498666070&bvid=BV1QK411n7VJ&cid=206827525&page=1)\n\n# 下载可执行包\n\n## 前往百度网盘下载\n\n```\n链接：https://pan.baidu.com/s/14zaMkxgfTC0HSge-Ze6EpQ \n提取码：m3u8 \n复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V1的分享\n```\n\n## Github 下载\n## [Releases下载](https://github.com/HeiSir2014/M3U8-Downloader/releases)\n\n# 运行源码\n### NodeJS开发环境搭建\n\n安装NodeJs最新版，[NodeJs Download](http://nodejs.cn/download/)\n\n### Clone 代码\n\n在任意文件夹下新建一个文件夹存放代码，并执行以下命令\n```\ncd newdir\n\ngit clone https://github.com/HeiSir2014/M3U8-Downloader.git .\n```\n### Yarn 环境安装\n\n```\nnpm install yarn -g\n```\n\n### Package 依赖安装\n\n```\nyarn\n```\n\nffmpeg-static 安装超时，可以尝试使用镜像:\n\n```\nFFMPEG_BINARIES_URL=https://cdn.npmmirror.com/binaries/ffmpeg-static yarn\n```\n\n### 运行M3U8-Downloader\n\n```\nyarn start\n```\n### 打包发布\n\n```\n//windows 平台打包\nyarn pack-win\n\n//mac 平台打包\nyarn pack-mac\n\n```\n\n### Enjoy it\n\n### 赞赏\n\n[赞赏链接](https://tools.heisir.cn/HLSDownload/2019/07/08/02/)\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.0244140625,
          "content": "theme: jekyll-theme-slate"
        },
        {
          "name": "main.js",
          "type": "blob",
          "size": 58.4775390625,
          "content": "const os = require('os')\r\nconst {\r\n    app,\r\n    BrowserWindow,\r\n    Tray,\r\n    ipcMain,\r\n    shell,\r\n    Menu,\r\n    dialog,\r\n    screen,\r\n    session,\r\n    nativeImage\r\n} = require('electron');\r\nconst isDev = require('electron-is-dev');\r\nconst {\r\n    spawn\r\n} = require('child_process');\r\nconst path = require('path');\r\nconst {\r\n    Parser\r\n} = require('m3u8-parser');\r\nconst fs = require('fs');\r\nconst async = require('async');\r\nconst download = require('download');\r\nconst crypto = require('crypto');\r\nconst got = require('got');\r\nconst {\r\n    Readable\r\n} = require('stream');\r\nconst ffmpeg = require('fluent-ffmpeg');\r\nconst package_self = require('./package.json');\r\nconst appInfo = package_self;\r\nconst winston = require('winston');\r\nconst nconf = require('nconf');\r\nconst ffmpegPath = require('ffmpeg-static').replace(/app.asar[\\/\\\\]{1,2}/g, '');\r\nconst contextMenu = require('electron-context-menu');\r\nconst Aria2 = require('aria2');\r\nconst forever = require('forever-monitor');\r\nconst filenamify = require('filenamify');\r\nconst {\r\n    HttpProxyAgent,\r\n    HttpsProxyAgent\r\n} = require('hpagent');\r\n\r\ncontextMenu({\r\n    showCopyImage: false,\r\n    showCopyImageAddress: false,\r\n    showInspectElement: false,\r\n    showServices: false,\r\n    showSearchWithGoogle: false\r\n});\r\n\r\nconst dateFormat = (dt) => {\r\n    return new Date(dt.getTime() - dt.getTimezoneOffset() * 60000).toISOString().replace(/T|(\\.\\d+Z)/g, ' ').trim()\r\n}\r\n\r\nlet isdelts = true;\r\nlet mainWindow = null;\r\nlet playerWindow = null;\r\nlet tray = null;\r\nlet AppTitle = 'M3U8-Downloader'\r\nlet firstHide = true;\r\n\r\nlet videoDatas = [];\r\nlet globalCond = {};\r\nconst pathConfigDir = app.getPath('userData');\r\nconst pathConfigFile = path.join(pathConfigDir, 'config.json');\r\nconst pathVideoDB = path.join(pathConfigDir, 'config_videos.json');\r\nconst aria2Dir = path.join(app.getAppPath(), \"static\", \"aria2\", process.platform);\r\nconst aria2_app = path.join(aria2Dir, \"aria2c.exe\");\r\nconst aria2_config = path.join(aria2Dir, \"aria2.conf\");\r\nlet aria2Client = null;\r\nlet aria2Server = null;\r\nlet proxy_agent = null;\r\nlet pathDownloadDir;\r\n\r\nconst httpTimeout = {\r\n    socket: 30000,\r\n    request: 30000,\r\n    response: 60000\r\n};\r\n\r\nconst referer = `https://tools.heisir.cn/M3U8Soft-Client?v=${package_self.version}`;\r\n\r\nfunction transformConfig(config) {\r\n    const result = []\r\n    for (const [k, v] of Object.entries(config)) {\r\n        if (v !== '') {\r\n            result.push(`--${k}=${v}`)\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\n\r\nconst logger = winston.createLogger({\r\n    level: 'debug',\r\n    format: winston.format.combine(\r\n        winston.format.timestamp({\r\n            format: 'YYYY-MM-DD HH:mm:ss'\r\n        }),\r\n        winston.format.printf(info => `${info.timestamp} ${info.level}: ${info.message}` + (info.splat !== undefined ? `${info.splat}` : \" \"))\r\n    ),\r\n    transports: [\r\n        new winston.transports.Console(),\r\n        new winston.transports.File({\r\n            filename: path.join(pathConfigDir, 'logs/error.log'),\r\n            level: 'error'\r\n        }),\r\n        new winston.transports.File({\r\n            filename: path.join(pathConfigDir, 'logs/all.log')\r\n        }),\r\n    ],\r\n});\r\n\r\nif (!fs.existsSync(pathConfigDir)) {\r\n    fs.mkdirSync(pathConfigDir, {\r\n        recursive: true\r\n    });\r\n}\r\n\r\nnconf.argv().env()\r\ntry {\r\n    nconf.file({\r\n        file: pathConfigFile\r\n    })\r\n} catch (error) {\r\n    logger.error('Please correct the mistakes in your configuration file: [%s].\\n' + error, configFilePath)\r\n}\r\n\r\n\r\nprocess.on('uncaughtException', (err, origin) => {\r\n    logger.error(`uncaughtException: ${err} | ${origin}`)\r\n});\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n    logger.error(`unhandledRejection: ${promise} | ${reason}`)\r\n});\r\n\r\nconsole.log(`\\n\\n----- ${appInfo.name} | v${appInfo.version} | ${os.platform()} -----\\n\\n`)\r\n\r\nfunction createWindow() {\r\n    // 创建浏览器窗口\r\n    let _workAreaSize = screen.getDisplayNearestPoint(screen.getCursorScreenPoint()).workAreaSize;\r\n    mainWindow = new BrowserWindow({\r\n        width: _workAreaSize.width * 0.6,\r\n        height: _workAreaSize.height * 0.7,\r\n        minWidth: 954,\r\n        minHeight: 600,\r\n        center: true,\r\n        frame: (process.platform == 'darwin'),\r\n        resizable: true,\r\n        webPreferences: {\r\n            nodeIntegration: true,\r\n            spellcheck: false,\r\n            contextIsolation: false,\r\n            webviewTag: true\r\n        },\r\n        icon: path.join(__dirname, 'static', 'icon', 'logo.png'),\r\n        alwaysOnTop: false,\r\n        hasShadow: false,\r\n        title: `${AppTitle} ${package_self.version}`\r\n    });\r\n    mainWindow.setMenu(null);\r\n    mainWindow.loadFile(path.join(__dirname, 'static', 'mainFrm.html'));\r\n    isDev && mainWindow.openDevTools();\r\n    mainWindow.on('closed', () => mainWindow = null);\r\n    mainWindow.webContents.on('dom-ready', (e) => {\r\n        e.sender.send('message', {\r\n            version: package_self.version,\r\n            config_save_dir: pathDownloadDir,\r\n            config_ffmpeg: ffmpegPath,\r\n            config_proxy: nconf.get('config_proxy'),\r\n            videoDatas,\r\n            platform: process.platform\r\n        });\r\n        e.sender.setTitle(`${AppTitle} ${package_self.version}`)\r\n    })\r\n    mainWindow.webContents.setWindowOpenHandler((details) => {\r\n        shell.openExternal(details.url);\r\n        return { action: 'deny' };\r\n    });\r\n}\r\n\r\nfunction createPlayerWindow(src) {\r\n    if (playerWindow == null) {\r\n        // 创建浏览器窗口\r\n        let _workAreaSize = screen.getDisplayNearestPoint(screen.getCursorScreenPoint()).workAreaSize;\r\n        playerWindow = new BrowserWindow({\r\n            width: _workAreaSize.width * 0.6,\r\n            height: _workAreaSize.height * 0.7,\r\n            skipTaskbar: false,\r\n            transparent: false,\r\n            frame: (process.platform == 'darwin'),\r\n            resizable: true,\r\n            webPreferences: {\r\n                nodeIntegration: true,\r\n                contextIsolation: false\r\n            },\r\n            icon: path.join(__dirname, 'static', 'icon', 'logo.png'),\r\n            alwaysOnTop: false,\r\n            hasShadow: false,\r\n            parent: mainWindow\r\n        });\r\n        playerWindow.setMenu(null)\r\n        playerWindow.on('closed', () => playerWindow = null);\r\n        playerWindow.loadFile(path.join(__dirname, 'static', 'player.html'));\r\n        playerWindow.webContents.on('dom-ready', (e) => {\r\n            e.sender.send('message', {\r\n                platform: process.platform, playsrc: src\r\n            });\r\n        });\r\n        isDev && playerWindow.openDevTools();\r\n        return;\r\n    }\r\n    playerWindow.webContents.send('message', {\r\n        playsrc: src\r\n    });\r\n}\r\n\r\n// 9999.9999.9999 > 1.1.1 最高支持4位版本对比。  1.2.1 > 1.2.0   1.3 > 1.2.9999\r\nfunction str2float(v) {\r\n    let va = v.split('.', 4);\r\n    if (!va) return -1;\r\n    let _r = 0;\r\n    let base = 100000000.0;\r\n    va.forEach(k => _r += (base * k), base /= 10000);\r\n    return _r;\r\n}\r\n\r\nlet _updateInterval;\r\nasync function checkUpdate() {\r\n    const {\r\n        body\r\n    } = await got(\"https://tools.heisir.cn/HLSDownload/package.json\").catch(logger.error);\r\n    if (!body) return;\r\n    try {\r\n        let _package = JSON.parse(body);\r\n        if (str2float(_package.version) <= str2float(package_self.version))\r\n            return;\r\n\r\n        _updateInterval && (clearInterval(_updateInterval), _updateInterval = null);\r\n\r\n        if (dialog.showMessageBoxSync(mainWindow, {\r\n            type: 'question',\r\n            buttons: [\"Yes\", \"No\"],\r\n            message: `检测到新版本(${_package.version})，是否要打开升级页面，下载最新版`\r\n        }) == 0) {\r\n            shell.openExternal(\"https://tools.heisir.cn/HLSDownload/download.html\");\r\n            return;\r\n        }\r\n    } catch (error) {\r\n        logger.error(error);\r\n    }\r\n}\r\n\r\nfunction webRequestReq(details, callback) {\r\n    if (!details.webContentsId || details.webContentsId == mainWindow.webContents.id) {\r\n        callback({ cancel: false }); return\r\n    }\r\n    const id = details.webContentsId;\r\n    if (/http.*\\.((mp4)|(m3u8)|(flv)|(mp3)|(mpd)|(wav))(\\?|$)/.test(details.url)) {\r\n        let [_null, _type] = details.url.match(/http.*\\.((mp4)|(m3u8)|(flv)|(mp3)|(mpd)|(wav))(\\?|$)/);\r\n\r\n        console.log(details);\r\n        let _item = {\r\n            type: _type.toUpperCase(),\r\n            url: details.url,\r\n            headers: JSON.stringify(details.requestHeaders)\r\n        }\r\n        mainWindow && mainWindow.webContents.send('message', { browserVideoItem: _item })\r\n    }\r\n\r\n    callback({ cancel: false });\r\n};\r\n\r\nfunction webRequestRsp(details) {\r\n    if (!details.webContentsId || details.webContentsId == mainWindow.webContents.id) {\r\n        return\r\n    }\r\n    const id = details.webContentsId;\r\n    /http.*\\.((mp4)|(m3u8)|(flv)|(mp3)|(mpd)|(wav))(\\?|$)/.test(details.url) &&\r\n        console.log(\"rsp\\t\" + details.url);\r\n}\r\n\r\n\r\napp.on('ready', () => {\r\n\r\n    // 单例应用程序\r\n    if (!app.requestSingleInstanceLock()) {\r\n        app.quit();\r\n        return\r\n    }\r\n    app.on('second-instance', (event, argv, cwd) => {\r\n        if (mainWindow) {\r\n            if (mainWindow.isMinimized()) {\r\n                mainWindow.restore()\r\n            } else if (mainWindow.isVisible()) {\r\n                mainWindow.focus()\r\n            } else {\r\n                mainWindow.show()\r\n                mainWindow.focus()\r\n            }\r\n        } else {\r\n            app.quit();\r\n        }\r\n    });\r\n    createWindow();\r\n    let iconImg = nativeImage.createFromPath(path.join(__dirname, 'static', 'icon', 'logo.png'));\r\n    tray = new Tray(iconImg.resize({ width: 20, height: 20 }));\r\n    tray.setToolTip(AppTitle);\r\n    tray.on(\"double-click\", () => {\r\n        mainWindow && mainWindow.show();\r\n    });\r\n\r\n    const contextMenu = Menu.buildFromTemplate([{\r\n        label: '显示窗口',\r\n        type: 'normal',\r\n        click: () => {\r\n            mainWindow.show();\r\n        }\r\n    },\r\n    {\r\n        type: 'separator'\r\n    },\r\n    {\r\n        label: '退出',\r\n        type: 'normal',\r\n        click: () => {\r\n            aria2Server && aria2Server.stop();\r\n            playerWindow && playerWindow.close();\r\n            mainWindow && mainWindow.close();\r\n            setTimeout(app.quit.bind(app), 1000);\r\n        }\r\n    }\r\n    ]);\r\n    tray.setContextMenu(contextMenu);\r\n    try {\r\n        videoDatas = JSON.parse(fs.readFileSync(pathVideoDB));\r\n    } catch (error) {\r\n        logger.error(error);\r\n    }\r\n\r\n    pathDownloadDir = nconf.get('SaveVideoDir');\r\n\r\n    const config_proxy = nconf.get('config_proxy');\r\n    let httpProxy = new HttpProxyAgent({\r\n        keepAlive: true,\r\n        keepAliveMsecs: 1000,\r\n        maxSockets: 256,\r\n        maxFreeSockets: 256,\r\n        scheduling: 'lifo',\r\n        proxy: config_proxy\r\n    });\r\n    proxy_agent = config_proxy ? {\r\n        http: httpProxy,\r\n        https: httpProxy\r\n    } : null;\r\n\r\n    //session.defaultSession.webRequest.onBeforeRequest(webRequestReq);\r\n    session.defaultSession.webRequest.onBeforeSendHeaders(webRequestReq);\r\n    session.defaultSession.webRequest.onResponseStarted(webRequestRsp);\r\n\r\n    //百度统计代码\r\n    false && (async () => {\r\n        try {\r\n            checkUpdate();\r\n            _updateInterval = setInterval(checkUpdate, 600000);\r\n\r\n            let HMACCOUNT = nconf.get('HMACCOUNT');\r\n            if (!HMACCOUNT) HMACCOUNT = '';\r\n            const {\r\n                headers\r\n            } = await got(\"http://hm.baidu.com/hm.js?300991eff395036b1ba22ae155143ff3\", {\r\n                headers: {\r\n                    \"Referer\": referer,\r\n                    \"Cookie\": \"HMACCOUNT=\" + HMACCOUNT\r\n                }\r\n            });\r\n            try {\r\n                HMACCOUNT = headers['set-cookie'] && headers['set-cookie'][0].match(/HMACCOUNT=(.*?);/i)[1];\r\n                if (HMACCOUNT) {\r\n                    nconf.set('HMACCOUNT', HMACCOUNT);\r\n                    nconf.save();\r\n                }\r\n            } catch (error_) {\r\n                logger.error(error_)\r\n            }\r\n            await got(`http://hm.baidu.com/hm.gif?hca=${HMACCOUNT}&cc=1&ck=1&cl=24-bit&ds=1920x1080&vl=977&ep=6621%2C1598&et=3&ja=0&ln=zh-cn&lo=0&lt=${(new Date().getTime() / 1000)}&rnd=0&si=300991eff395036b1ba22ae155143ff3&v=1.2.74&lv=3&sn=0&r=0&ww=1920&u=${encodeURIComponent(referer)}`, {\r\n                headers: {\r\n                    \"Referer\": referer,\r\n                    \"Cookie\": \"HMACCOUNT=\" + HMACCOUNT\r\n                }\r\n            });\r\n            await got(`http://hm.baidu.com/hm.gif?cc=1&ck=1&cl=24-bit&ds=1920x1080&vl=977&et=0&ja=0&ln=zh-cn&lo=0&rnd=0&si=300991eff395036b1ba22ae155143ff3&v=1.2.74&lv=1&sn=0&r=0&ww=1920&ct=!!&tt=M3U8Soft-Client`, {\r\n                headers: {\r\n                    \"Referer\": referer,\r\n                    \"Cookie\": \"HMACCOUNT=\" + HMACCOUNT\r\n                }\r\n            });\r\n            logger.info(\"call baidu-tong-ji end.\");\r\n        } catch (error) {\r\n            logger.error(error)\r\n        }\r\n    })();\r\n    return;\r\n\r\n    const EMPTY_STRING = '';\r\n    const systemConfig = {\r\n        'all-proxy': EMPTY_STRING,\r\n        'allow-overwrite': false,\r\n        'auto-file-renaming': true,\r\n        'check-certificate': false,\r\n        'continue': false,\r\n        'dir': app.getPath('downloads'),\r\n        'max-concurrent-downloads': 120,\r\n        'max-connection-per-server': 5,\r\n        'max-download-limit': 0,\r\n        'max-overall-download-limit': 0,\r\n        'max-overall-upload-limit': '256K',\r\n        'min-split-size': '1M',\r\n        'no-proxy': EMPTY_STRING,\r\n        'pause': true,\r\n        'rpc-listen-port': 16801,\r\n        'rpc-secret': EMPTY_STRING,\r\n        'seed-ratio': 1,\r\n        'seed-time': 60,\r\n        'split': 10,\r\n        'user-agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36Transmission/2.94'\r\n    }\r\n\r\n    let cmds = [aria2_app, `--conf-path=${aria2_config}`];\r\n    cmds = [...cmds, ...transformConfig(systemConfig)];\r\n    logger.debug(cmds.join(' '));\r\n\r\n    let instance = forever.start(cmds, {\r\n        max: 10,\r\n        parser: function (command, args) {\r\n            logger.debug(command, args);\r\n            return {\r\n                command: command,\r\n                args: args\r\n            }\r\n        },\r\n        silent: false\r\n    });\r\n    instance.on('start', function (process, data) {\r\n        let aria2 = new Aria2({\r\n            port: 16801\r\n        });\r\n        aria2.open();\r\n        aria2.on('close', (e) => {\r\n            console.log('----aria2 connect close----');\r\n            setTimeout(() => aria2.open(), 100);\r\n        });\r\n        aria2.on(\"onDownloadComplete\", downloadComplete);\r\n        aria2Client = aria2;\r\n\r\n        setInterval(() => {\r\n            aria2Client.call('getGlobalStat').then((result) => {\r\n                if (result && result['downloadSpeed']) {\r\n                    var _speed = '';\r\n                    var speed = parseInt(result['downloadSpeed']);\r\n                    _speed = (speed < 1024 * 1024) ? Math.round(speed / 1024) + ' KB/s' : (speed / 1024 / 1024).toFixed(2) + ' MiB/s'\r\n                    mainWindow.webContents.send('message', { downloadSpeed: _speed });\r\n                }\r\n            });\r\n        }, 1500);\r\n    });\r\n    aria2Server = instance;\r\n});\r\n\r\nfunction downloadComplete(e) {\r\n    console.log('---- aria2 downloadComplete ----');\r\n    var gid = e[0]['gid'];\r\n\r\n    console.log(gid);\r\n}\r\n\r\n// 当全部窗口关闭时退出。\r\napp.on('window-all-closed', async () => {\r\n\r\n    console.log('window-all-closed')\r\n    let HMACCOUNT = nconf.get('HMACCOUNT');\r\n    HMACCOUNT && await got(`http://hm.baidu.com/hm.gif?cc=1&ck=1&cl=24-bit&ds=1920x1080&vl=977&et=0&ja=0&ln=zh-cn&lo=0&rnd=0&si=300991eff395036b1ba22ae155143ff3&v=1.2.74&lv=1&sn=0&r=0&ww=1920&ct=!!&tt=M3U8Soft-Client`, {\r\n        headers: {\r\n            \"Referer\": referer,\r\n            \"Cookie\": \"HMACCOUNT=\" + HMACCOUNT\r\n        }\r\n    });\r\n\r\n    // 在 macOS 上，除非用户用 Cmd + Q 确定地退出，\r\n    // 否则绝大部分应用及其菜单栏会保持激活。\r\n    if (process.platform !== 'darwin') {\r\n        tray && tray.destroy();\r\n        tray = null;\r\n        app.quit();\r\n    };\r\n})\r\n\r\napp.on('activate', () => {\r\n    // 在macOS上，当单击dock图标并且没有其他窗口打开时，\r\n    // 通常在应用程序中重新创建一个窗口。\r\n    if (mainWindow === null) {\r\n        createWindow()\r\n    } else {\r\n        mainWindow.show();\r\n    }\r\n})\r\n\r\nipcMain.on(\"hide-windows\", function () {\r\n    mainWindow && mainWindow.hide(), (firstHide && tray && (tray.displayBalloon({\r\n        icon: path.join(__dirname, 'static', 'icon', 'logo-512.png'),\r\n        title: \"提示\",\r\n        content: \"我隐藏到这里了哦，双击我显示主窗口！\"\r\n    }), firstHide = false));\r\n});\r\n\r\nipcMain.on('open-log-dir', function (event, arg) {\r\n    showDirInExploer(path.join(pathConfigDir, 'logs'))\r\n});\r\n\r\nipcMain.on('task-clear', async function (event, object) {\r\n    videoDatas.forEach((video) => {\r\n        globalCond[video.id] = false;\r\n    })\r\n    videoDatas = [];\r\n    fs.writeFileSync(pathVideoDB, JSON.stringify(videoDatas));\r\n});\r\n\r\nipcMain.on('task-add', async function (event, object) {\r\n    logger.info(object);\r\n    let hlsSrc = object.url;\r\n    let _headers = {};\r\n    if (object.headers) {\r\n        let __ = object.headers.match(/(.*?): ?(.*?)(\\n|\\r|$)/g);\r\n        __ && __.forEach((_) => {\r\n            let ___ = _.match(/(.*?): ?(.*?)(\\n|\\r|$)/i);\r\n            ___ && (_headers[___[1]] = ___[2]);\r\n        });\r\n    }\r\n\r\n    let mes = hlsSrc.match(/^https?:\\/\\/[^/]*/);\r\n    let _hosts = '';\r\n    if (mes && mes.length >= 1) {\r\n        _hosts = mes[0];\r\n\r\n        if (_headers['Origin'] == null && _headers['origin'] == null) {\r\n            _headers['Origin'] = _hosts;\r\n        }\r\n        if (_headers['Referer'] == null && _headers['referer'] == null) {\r\n            _headers['Referer'] = _hosts;\r\n        }\r\n    }\r\n\r\n    object.headers = _headers;\r\n\r\n    let info = '解析资源失败！';\r\n    let code = -1;\r\n\r\n    let parser = new Parser();\r\n    if (/^file:\\/\\/\\//g.test(hlsSrc)) {\r\n        parser.push(fs.readFileSync(hlsSrc.replace(/^file:\\/\\/\\//g, '')));\r\n        parser.end();\r\n    } else {\r\n        for (let index = 0; index < 3; index++) {\r\n            let response = await got(hlsSrc, {\r\n                headers: _headers,\r\n                timeout: httpTimeout,\r\n                agent: proxy_agent\r\n            }).catch(logger.error); {\r\n                if (response && response.body != null &&\r\n                    response.body != '') {\r\n                    parser.push(response.body);\r\n                    parser.end();\r\n\r\n                    if (parser.manifest.segments.length == 0 && parser.manifest.playlists && parser.manifest.playlists.length && parser.manifest.playlists.length == 1) {\r\n                        let uri = parser.manifest.playlists[0].uri;\r\n                        if (!uri.startsWith('http')) {\r\n                            hlsSrc = uri[0] == '/' ? (hlsSrc.substr(0, hlsSrc.indexOf('/', 10)) + uri) :\r\n                                (hlsSrc.replace(/\\/[^\\/]*((\\?.*)|$)/, '/') + uri);\r\n                        }\r\n                        else {\r\n                            hlsSrc = uri;\r\n                        }\r\n                        object.url = hlsSrc;\r\n                        parser = new Parser();\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let count_seg = parser.manifest.segments.length;\r\n    if (count_seg > 0) {\r\n        code = 0;\r\n        if (parser.manifest.endList) {\r\n            let duration = 0;\r\n            parser.manifest.segments.forEach(segment => {\r\n                duration += segment.duration;\r\n            });\r\n            info = `点播资源解析成功，有 ${count_seg} 个片段，时长：${formatTime(duration)}，即将开始缓存...`;\r\n            startDownload(object);\r\n        } else {\r\n            info = `直播资源解析成功，即将开始缓存...`;\r\n            startDownloadLive(object);\r\n        }\r\n    } else if (parser.manifest.playlists && parser.manifest.playlists.length && parser.manifest.playlists.length >= 1) {\r\n        code = 1;\r\n        event.sender.send('task-add-reply', {\r\n            code: code,\r\n            message: '',\r\n            playlists: parser.manifest.playlists\r\n        });\r\n        return;\r\n    }\r\n    event.sender.send('task-add-reply', {\r\n        code: code,\r\n        message: info\r\n    });\r\n});\r\n\r\n\r\nipcMain.on('task-add-muti', async function (event, object) {\r\n    logger.info(object);\r\n    let m3u8_urls = object.m3u8_urls;\r\n    let _headers = {};\r\n    if (object.headers) {\r\n        let __ = object.headers.match(/(.*?): ?(.*?)(\\n|\\r|$)/g);\r\n        __ && __.forEach((_) => {\r\n            let ___ = _.match(/(.*?): ?(.*?)(\\n|\\r|$)/i);\r\n            ___ && (_headers[___[1]] = ___[2]);\r\n        });\r\n    }\r\n\r\n    let info = '解析资源失败！';\r\n    let code = -1;\r\n    let iidx = 0;\r\n    m3u8_urls.split(/\\r|\\n/g).forEach(urls => {\r\n        if (urls != '') {\r\n            let _obj = {\r\n                url: '',\r\n                headers: object.headers,\r\n                myKeyIV: '',\r\n                taskName: '',\r\n                taskIsDelTs: object.taskIsDelTs,\r\n                url_prefix: ''\r\n            };\r\n            if (/-{4}/.test(urls)) {\r\n                let __ = urls.split('----');\r\n                if (__ && __.length >= 2) {\r\n                    if (__[0]) {\r\n                        _obj.url = __[0];\r\n                        if (__[1]) {\r\n                            _obj.taskName = __[1];\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                _obj.url = urls;\r\n            }\r\n\r\n            if (_obj.url) {\r\n\r\n                let mes = _obj.url.match(/^https?:\\/\\/[^/]*/);\r\n                let _hosts = '';\r\n                if (mes && mes.length >= 1) {\r\n                    _hosts = mes[0];\r\n\r\n                    if (_headers['Origin'] == null && _headers['origin'] == null) {\r\n                        _headers['Origin'] = _hosts;\r\n                    }\r\n                    if (_headers['Referer'] == null && _headers['referer'] == null) {\r\n                        _headers['Referer'] = _hosts;\r\n                    }\r\n                }\r\n\r\n                _obj.headers = _headers;\r\n\r\n                startDownload(_obj, iidx);\r\n                iidx = iidx + 1;\r\n            }\r\n        }\r\n    })\r\n    info = `批量添加成功，正在下载...`;\r\n    event.sender.send('task-add-reply', {\r\n        code: 0,\r\n        message: info\r\n    });\r\n});\r\n\r\nclass QueueObject {\r\n    constructor() {\r\n        this.segment = null;\r\n        this.url = '';\r\n        this.url_prefix = '';\r\n        this.headers = '';\r\n        this.myKeyIV = '';\r\n        this.id = 0;\r\n        this.idx = 0;\r\n        this.dir = '';\r\n        this.then = this.catch = null;\r\n        this.retry = 0;\r\n    }\r\n    async callback(_callback) {\r\n        try {\r\n            this.retry = this.retry + 1;\r\n            if (this.retry > 5) {\r\n                this.catch && this.catch();\r\n                return;\r\n            }\r\n            if (!globalCond[this.id]) {\r\n                logger.debug(`globalCond[this.id] is not exsited.`);\r\n                return;\r\n            }\r\n\r\n            let partent_uri = this.url.replace(/([^\\/]*\\?.*$)|([^\\/]*$)/g, '');\r\n            let segment = this.segment;\r\n            let uri_ts = '';\r\n            if (/^http.*/.test(segment.uri)) {\r\n                uri_ts = segment.uri;\r\n            } else if (/^http/.test(this.url) && /^\\/.*/.test(segment.uri)) {\r\n                let mes = this.url.match(/^https?:\\/\\/[^/]*/);\r\n                if (mes && mes.length >= 1) {\r\n                    uri_ts = mes[0] + segment.uri;\r\n                } else {\r\n                    uri_ts = partent_uri + (partent_uri.endsWith('/') || segment.uri.startWith('/') ? '' : \"/\") + segment.uri;\r\n                }\r\n            } else if (/^http.*/.test(this.url)) {\r\n                uri_ts = partent_uri + (partent_uri.endsWith('/') || segment.uri.startWith('/') ? '' : \"/\") + segment.uri;\r\n            } else if (/^file:\\/\\/\\//.test(this.url) && !this.url_prefix) {\r\n                let fileDir = this.url.replace('file:///', '').replace(/[^\\\\/]{1,}$/, '');\r\n                uri_ts = path.join(fileDir, segment.uri);\r\n                if (!fs.existsSync(uri_ts)) {\r\n                    var me = segment.uri.match(/[^\\\\\\/\\?]{1,}\\?|$/i);\r\n                    if (me && me.length > 1) {\r\n                        uri_ts = path.join(fileDir, me[0].replace(/\\?$/, ''));\r\n                    }\r\n                    if (!fs.existsSync(uri_ts)) {\r\n                        globalCond[this.id] = false;\r\n                        this.catch && this.catch();\r\n                        return;\r\n                    }\r\n                }\r\n                uri_ts = \"file:///\" + uri_ts\r\n            } else if (/^file:\\/\\/\\//.test(this.url) && this.url_prefix) {\r\n                uri_ts = this.url_prefix + (this.url_prefix.endsWith('/') || segment.uri.startWith('/') ? '' : \"/\") + segment.uri;\r\n            }\r\n\r\n            let filename = `${((this.idx + 1) + '').padStart(6, '0')}.ts`;\r\n            let filpath = path.join(this.dir, filename);\r\n            let filpath_dl = path.join(this.dir, filename + \".dl\");\r\n\r\n            logger.debug(`2 ${segment.uri}`, `${filename}`);\r\n\r\n            //检测文件是否存在\r\n            for (let index = 0; index < 3 && !fs.existsSync(filpath); index++) {\r\n                // 下载的时候使用.dl后缀的文件名，下载完成后重命名\r\n                let that = this;\r\n\r\n                if (/^file:\\/\\/\\//.test(uri_ts)) {\r\n                    fs.copyFileSync(uri_ts.replace(/^file:\\/\\/\\//, ''), filpath_dl);\r\n                } else {\r\n\r\n                    var _headers = [];\r\n                    if (that.headers) {\r\n                        for (var _key in that.headers) {\r\n                            _headers.push(_key + \": \" + that.headers[_key])\r\n                        }\r\n                    }\r\n                    //aria2Client && aria2Client.call(\"addUri\", [uri_ts], { dir:that.dir, out: filename + \".dl\", split: \"16\", header: _headers});\r\n                    //break;\r\n                    await download(uri_ts, that.dir, {\r\n                        filename: filename + \".dl\",\r\n                        timeout: httpTimeout,\r\n                        headers: that.headers,\r\n                        agent: proxy_agent\r\n                    }).catch((err) => {\r\n                        logger.error(err)\r\n                        fs.existsSync(filpath_dl) && fs.unlinkSync(filpath_dl);\r\n                    });\r\n                }\r\n                if (!fs.existsSync(filpath_dl)) continue;\r\n\r\n                fs.statSync(filpath_dl).size <= 0 && fs.unlinkSync(filpath_dl);\r\n\r\n                if (segment.key != null && segment.key.method != null) {\r\n                    //标准解密TS流\r\n                    let aes_path = path.join(this.dir, \"aes.key\");\r\n                    if (!this.myKeyIV && !fs.existsSync(aes_path)) {\r\n                        let key_uri = segment.key.uri;\r\n                        if (/^http/.test(this.url) && !/^http.*/.test(key_uri) && !/^\\/.*/.test(key_uri)) {\r\n                            key_uri = partent_uri + key_uri;\r\n                        } else if (/^http/.test(this.url) && /^\\/.*/.test(key_uri)) {\r\n                            let mes = this.url.match(/^https?:\\/\\/[^/]*/);\r\n                            if (mes && mes.length >= 1) {\r\n                                key_uri = mes[0] + key_uri;\r\n                            } else {\r\n                                key_uri = partent_uri + key_uri;\r\n                            }\r\n                        } else if (/^file:\\/\\/\\//.test(this.url) && !this.url_prefix && !/^http.*/.test(key_uri)) {\r\n                            let fileDir = this.url.replace('file:///', '').replace(/[^\\\\/]{1,}$/, '');\r\n                            let key_uri_ = path.join(fileDir, key_uri);\r\n                            if (!fs.existsSync(key_uri_)) {\r\n                                var me = key_uri.match(/([^\\\\\\/\\?]{1,})(\\?|$)/i);\r\n                                if (me && me.length > 1) {\r\n                                    key_uri_ = path.join(fileDir, me[1]);\r\n                                }\r\n                                if (!fs.existsSync(key_uri_)) {\r\n                                    globalCond[this.id] = false;\r\n                                    this.catch && this.catch();\r\n                                    return;\r\n                                }\r\n                            }\r\n                            key_uri = \"file:///\" + key_uri_;\r\n                        } else if (/^file:\\/\\/\\//.test(this.url) && this.url_prefix && !/^http.*/.test(key_uri)) {\r\n                            key_uri = this.url_prefix + (this.url_prefix.endsWith('/') || key_uri.startWith('/') ? '' : \"/\") + key_uri;\r\n                        }\r\n\r\n                        if (/^http/.test(key_uri)) {\r\n                            await download(key_uri, that.dir, {\r\n                                filename: \"aes.key\",\r\n                                headers: that.headers,\r\n                                timeout: httpTimeout,\r\n                                agent: proxy_agent\r\n                            }).catch(console.error);\r\n                        } else if (/^file:\\/\\/\\//.test(key_uri)) {\r\n                            key_uri = key_uri.replace('file:///', '')\r\n                            if (fs.existsSync(key_uri)) {\r\n                                fs.copyFileSync(key_uri, aes_path);\r\n                            } else {\r\n                                globalCond[this.id] = false;\r\n                                this.catch && this.catch();\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (this.myKeyIV || fs.existsSync(aes_path)) {\r\n                        try {\r\n                            let key_ = null;\r\n                            let iv_ = null;\r\n                            if (!this.myKeyIV) {\r\n                                key_ = fs.readFileSync(aes_path);\r\n                                if (key_.length == 32) {\r\n                                    key_ = Buffer.from(fs.readFileSync(aes_path, {\r\n                                        encoding: 'utf8'\r\n                                    }), 'hex');\r\n                                }\r\n                                iv_ = segment.key.iv != null ? Buffer.from(segment.key.iv.buffer) :\r\n                                    Buffer.from(that.idx.toString(16).padStart(32, '0'), 'hex');\r\n                            } else {\r\n\r\n                                key_ = Buffer.from(this.myKeyIV.substr(0, 32), 'hex');\r\n                                if (this.myKeyIV.length >= 64) {\r\n                                    iv_ = Buffer.from(this.myKeyIV.substr(this.myKeyIV.length - 32, 32), 'hex');\r\n                                } else {\r\n                                    iv_ = Buffer.from(that.idx.toString(16).padStart(32, '0'), 'hex')\r\n                                }\r\n                            }\r\n                            logger.debug(`key:${key_.toString('hex')} | iv:${iv_.toString('hex')}`)\r\n                            let cipher = crypto.createDecipheriv((segment.key.method + \"-cbc\").toLowerCase(), key_, iv_);\r\n                            cipher.on('error', console.error);\r\n                            let inputData = fs.readFileSync(filpath_dl);\r\n                            let outputData = Buffer.concat([cipher.update(inputData), cipher.final()]);\r\n                            fs.writeFileSync(filpath, outputData);\r\n\r\n                            if (fs.existsSync(filpath_dl))\r\n                                fs.unlinkSync(filpath_dl);\r\n\r\n                            that.then && that.then();\r\n                        } catch (error) {\r\n                            logger.error(error)\r\n                            if (fs.existsSync(filpath_dl))\r\n                                fs.unlinkSync(filpath_dl);\r\n                        }\r\n                        return;\r\n                    }\r\n                } else {\r\n                    fs.renameSync(filpath_dl, filpath);\r\n                    break;\r\n                }\r\n            }\r\n            if (fs.existsSync(filpath)) {\r\n                this.then && this.then();\r\n            } else {\r\n                this.catch && this.catch();\r\n            }\r\n        } catch (e) {\r\n            logger.error(e);\r\n        } finally {\r\n            _callback();\r\n        }\r\n    }\r\n}\r\n\r\nfunction queue_callback(that, callback) {\r\n    that.callback(callback);\r\n}\r\n\r\nasync function startDownload(object, iidx) {\r\n    let id = !object.id ? (iidx != null ? (new Date().getTime() + iidx) : new Date().getTime()) : object.id;\r\n    let headers = object.headers;\r\n    let url_prefix = object.url_prefix;\r\n    let taskName = object.taskName;\r\n    let myKeyIV = object.myKeyIV;\r\n    let url = object.url;\r\n    let taskIsDelTs = object.taskIsDelTs;\r\n    if (!taskName) {\r\n        taskName = `${id}`;\r\n    }\r\n\r\n    let dir = path.join(pathDownloadDir, filenamify(taskName.trim(), { replacement: '_' }));\r\n\r\n    logger.info(dir);\r\n\r\n    !fs.existsSync(dir) && fs.mkdirSync(dir, { recursive: true });\r\n\r\n    let parser = new Parser();\r\n    if (/^file:\\/\\/\\//g.test(url)) {\r\n        parser.push(fs.readFileSync(url.replace(/^file:\\/\\/\\//, ''), { encoding: 'utf-8' }));\r\n        parser.end();\r\n    } else {\r\n        for (let index = 0; index < 3; index++) {\r\n            let response = await got(url, {\r\n                headers: headers,\r\n                timeout: httpTimeout,\r\n                agent: proxy_agent\r\n            }).catch(logger.error); {\r\n                if (response && response.body != null &&\r\n                    response.body != '') {\r\n                    parser.push(response.body);\r\n                    parser.end();\r\n                    if (parser.manifest.segments.length == 0 && parser.manifest.playlists && parser.manifest.playlists.length && parser.manifest.playlists.length >= 1) {\r\n                        let uri = parser.manifest.playlists[0].uri;\r\n                        if (!uri.startsWith('http')) {\r\n                            url = uri[0] == '/' ? (url.substr(0, url.indexOf('/', 10)) + uri) :\r\n                                (url.replace(/\\/[^\\/]*((\\?.*)|$)/, '/') + uri);\r\n                        }\r\n                        else {\r\n                            url = uri;\r\n                        }\r\n                        parser = new Parser();\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    //并发 2 个线程下载\r\n    var tsQueues = async.queue(queue_callback, 5);\r\n\r\n    let count_seg = parser.manifest.segments.length;\r\n    let count_downloaded = 0;\r\n    var video = {\r\n        id: id,\r\n        url: url,\r\n        url_prefix: url_prefix,\r\n        dir: dir,\r\n        segment_total: count_seg,\r\n        segment_downloaded: count_downloaded,\r\n        time: dateFormat(new Date(), \"yyyy-mm-dd HH:MM:ss\"),\r\n        status: '初始化...',\r\n        isLiving: false,\r\n        headers: headers,\r\n        taskName: taskName,\r\n        myKeyIV: myKeyIV,\r\n        taskIsDelTs: taskIsDelTs,\r\n        success: true,\r\n        videopath: ''\r\n    };\r\n\r\n    videoDatas.splice(0, 0, video);\r\n    fs.writeFileSync(pathVideoDB, JSON.stringify(videoDatas));\r\n\r\n    if (!object.id) {\r\n        mainWindow && mainWindow.webContents.send('task-notify-create', video);\r\n    }\r\n    globalCond[id] = true;\r\n    let segments = parser.manifest.segments;\r\n    for (let iSeg = 0; iSeg < segments.length; iSeg++) {\r\n        let qo = new QueueObject();\r\n        qo.dir = dir;\r\n        qo.idx = iSeg;\r\n        qo.id = id;\r\n        qo.url = url;\r\n        qo.url_prefix = url_prefix;\r\n        qo.headers = headers;\r\n        qo.myKeyIV = myKeyIV;\r\n        qo.segment = segments[iSeg];\r\n        qo.then = function () {\r\n            count_downloaded = count_downloaded + 1\r\n            video.segment_downloaded = count_downloaded;\r\n            video.status = `下载中...${count_downloaded}/${count_seg}`\r\n            if (video.success) {\r\n                mainWindow.webContents.send('task-notify-update', video);\r\n            }\r\n        };\r\n        qo.catch = function () {\r\n            if (this.retry < 5) {\r\n                tsQueues.push(this);\r\n            } else {\r\n                globalCond[id] = false;\r\n                video.success = false;\r\n\r\n                logger.info(`URL:${video.url} | ${this.segment.uri} download failed`);\r\n                video.status = \"多次尝试，下载片段失败\";\r\n                mainWindow.webContents.send('task-notify-end', video);\r\n\r\n                fs.writeFileSync(pathVideoDB, JSON.stringify(videoDatas));\r\n            }\r\n        }\r\n        tsQueues.push(qo);\r\n    }\r\n    tsQueues.drain(async () => {\r\n        if (!video.success) {\r\n            return;\r\n        }\r\n\r\n        logger.info('download success');\r\n        video.status = \"已完成，合并中...\";\r\n        mainWindow.webContents.send('task-notify-end', video);\r\n        let fileSegments = [];\r\n        for (let iSeg = 0; iSeg < segments.length; iSeg++) {\r\n            let filpath = path.join(dir, `${((iSeg + 1) + '').padStart(6, '0')}.ts`);\r\n            if (fs.existsSync(filpath)) {\r\n                fileSegments.push(filpath);\r\n            }\r\n        }\r\n        if (!fileSegments.length) {\r\n            video.status = \"下载失败，请检查链接有效性\";\r\n            mainWindow.webContents.send('task-notify-end', video);\r\n            logger.error(`[${url}] 下载失败，请检查链接有效性`);\r\n            return;\r\n        }\r\n        let outPathMP4 = path.join(dir, Date.now() + \".mp4\");\r\n        let outPathMP4_ = path.join(pathDownloadDir, filenamify(taskName.trim(), { replacement: '_' }) + '.mp4');\r\n        if (fs.existsSync(ffmpegPath)) {\r\n            let ffmpegInputStream = new FFmpegStreamReadable(null);\r\n            new ffmpeg(ffmpegInputStream)\r\n                .setFfmpegPath(ffmpegPath)\r\n                .videoCodec('copy')\r\n                .audioCodec('copy')\r\n                .format('mp4')\r\n                .save(outPathMP4)\r\n                .on('error', (error) => {\r\n                    logger.error(error)\r\n                    video.videopath = \"\";\r\n                    video.status = \"合并出错，请尝试手动合并\";\r\n                    mainWindow.webContents.send('task-notify-end', video);\r\n\r\n                    fs.writeFileSync(pathVideoDB, JSON.stringify(videoDatas));\r\n                })\r\n                .on('end', function () {\r\n                    logger.info(`${outPathMP4} merge finished.`)\r\n                    video.videopath = \"\";\r\n                    fs.existsSync(outPathMP4) && (fs.renameSync(outPathMP4, outPathMP4_), video.videopath = outPathMP4_);\r\n                    video.status = \"已完成\"\r\n                    mainWindow.webContents.send('task-notify-end', video);\r\n                    if (video.taskIsDelTs) {\r\n                        let index_path = path.join(dir, 'index.txt');\r\n                        fs.existsSync(index_path) && fs.unlinkSync(index_path);\r\n                        fileSegments.forEach(item => fs.existsSync(item) && fs.unlinkSync(item));\r\n                        let aesKey_path = path.join(dir, 'aes.key');\r\n                        fs.existsSync(aesKey_path) && fs.unlinkSync(aesKey_path);\r\n                        fs.rmdirSync(dir);\r\n                    }\r\n                    fs.writeFileSync(pathVideoDB, JSON.stringify(videoDatas));\r\n                })\r\n                .on('progress', (info) => {\r\n                    logger.info(JSON.stringify(info));\r\n                });\r\n\r\n            for (let i = 0; i < fileSegments.length; i++) {\r\n                let percent = Number.parseInt((i + 1) * 100 / fileSegments.length);\r\n                video.status = `合并中[${percent}%]`;\r\n                mainWindow.webContents.send('task-notify-end', video);\r\n                let filePath = fileSegments[i];\r\n                fs.existsSync(filePath) && ffmpegInputStream.push(fs.readFileSync(filePath));\r\n                while (ffmpegInputStream._readableState.length > 0) {\r\n                    await sleep(100);\r\n                }\r\n                console.log(\"push \" + percent);\r\n            }\r\n            console.log(\"push(null) end\");\r\n            ffmpegInputStream.push(null);\r\n        } else {\r\n            video.videopath = outPathMP4;\r\n            video.status = \"已完成，未发现本地FFMPEG，不进行合成。\"\r\n            mainWindow.webContents.send('task-notify-end', video);\r\n        }\r\n    });\r\n}\r\n\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nclass FFmpegStreamReadable extends Readable {\r\n    constructor(opt) {\r\n        super(opt);\r\n    }\r\n    _read() { }\r\n}\r\n\r\nasync function startDownloadLive(object) {\r\n\r\n    let id = !object.id ? new Date().getTime() : object.id;\r\n    let headers = object.headers;\r\n    let taskName = object.taskName;\r\n    let myKeyIV = object.myKeyIV;\r\n    let url = object.url;\r\n    if (!taskName) {\r\n        taskName = `${id}`;\r\n    }\r\n    let dir = path.join(pathDownloadDir, filenamify(taskName.trim(), { replacement: '_' }));\r\n\r\n    logger.info(dir);\r\n\r\n    if (!fs.existsSync(dir)) {\r\n        fs.mkdirSync(dir, {\r\n            recursive: true\r\n        });\r\n    }\r\n\r\n    let count_downloaded = 0;\r\n    let count_seg = 100;\r\n    var video = {\r\n        id: id,\r\n        url: url,\r\n        dir: dir,\r\n        segment_total: count_seg,\r\n        segment_downloaded: count_downloaded,\r\n        time: dateFormat(new Date(), \"yyyy-mm-dd HH:MM:ss\"),\r\n        status: '初始化...',\r\n        isLiving: true,\r\n        myKeyIV: myKeyIV,\r\n        taskName: taskName,\r\n        headers: headers,\r\n        videopath: ''\r\n    };\r\n\r\n    videoDatas.splice(0, 0, video);\r\n    fs.writeFileSync(pathVideoDB, JSON.stringify(videoDatas));\r\n\r\n    if (!object.id) {\r\n        mainWindow.webContents.send('task-notify-create', video);\r\n    }\r\n\r\n    let partent_uri = url.replace(/([^\\/]*\\?.*$)|([^\\/]*$)/g, '');\r\n    let segmentSet = new Set();\r\n    let ffmpegInputStream = null;\r\n    let ffmpegObj = null;\r\n    globalCond[id] = true;\r\n    while (globalCond[id]) {\r\n\r\n        try {\r\n            const response = await got(url, {\r\n                headers: headers,\r\n                timeout: httpTimeout,\r\n                agent: proxy_agent\r\n            }).catch(logger.error);\r\n            if (response == null || response.body == null || response.body == '') {\r\n                break;\r\n            }\r\n            let parser = new Parser();\r\n            parser.push(response.body);\r\n            parser.end();\r\n\r\n            let count_seg = parser.manifest.segments.length;\r\n            let segments = parser.manifest.segments;\r\n            logger.info(`解析到 ${count_seg} 片段`)\r\n            if (count_seg > 0) {\r\n                //开始下载片段的时间，下载完毕后，需要计算下次请求的时间\r\n                let _startTime = new Date();\r\n                let _videoDuration = 0;\r\n                for (let iSeg = 0; iSeg < segments.length; iSeg++) {\r\n                    let segment = segments[iSeg];\r\n                    if (segmentSet.has(segment.uri)) {\r\n                        continue;\r\n                    }\r\n                    if (!globalCond[id]) {\r\n                        break;\r\n                    }\r\n                    _videoDuration = _videoDuration + segment.duration * 1000;\r\n                    let uri_ts = '';\r\n                    if (/^http.*/.test(segment.uri)) {\r\n                        uri_ts = segment.uri;\r\n                    } else if (/^\\/.*/.test(segment.uri)) {\r\n                        let mes = url.match(/^https?:\\/\\/[^/]*/);\r\n                        if (mes && mes.length >= 1) {\r\n                            uri_ts = mes[0] + segment.uri;\r\n                        } else {\r\n                            uri_ts = partent_uri + segment.uri;\r\n                        }\r\n                    } else {\r\n                        uri_ts = partent_uri + segment.uri;\r\n                    }\r\n\r\n                    let filename = `${((count_downloaded + 1) + '').padStart(6, '0')}.ts`;\r\n                    let filpath = path.join(dir, filename);\r\n                    let filpath_dl = path.join(dir, filename + \".dl\");\r\n\r\n                    for (let index = 0; index < 3; index++) {\r\n                        if (!globalCond[id]) {\r\n                            break;\r\n                        }\r\n\r\n                        //let tsStream = await got.get(uri_ts, {responseType:'buffer', timeout:httpTimeout ,headers:headers}).catch(logger.error).body();\r\n\r\n                        await download(uri_ts, dir, {\r\n                            filename: filename + \".dl\",\r\n                            timeout: httpTimeout,\r\n                            headers: headers,\r\n                            agent: proxy_agent\r\n                        }).catch((err) => {\r\n                            logger.error(err)\r\n                            if (fs.existsSync(filpath_dl)) {\r\n                                fs.unlinkSync(filpath_dl);\r\n                            }\r\n                        });\r\n                        if (fs.existsSync(filpath_dl)) {\r\n                            let stat = fs.statSync(filpath_dl);\r\n                            if (stat.size > 0) {\r\n                                fs.renameSync(filpath_dl, filpath);\r\n                            } else {\r\n                                fs.unlinkSync(filpath_dl);\r\n                            }\r\n                        }\r\n                        if (fs.existsSync(filpath)) {\r\n                            segmentSet.add(segment.uri);\r\n                            if (ffmpegObj == null) {\r\n                                let outPathMP4 = path.join(dir, id + '.mp4');\r\n                                let newid = id;\r\n                                //不要覆盖之前下载的直播内容\r\n                                while (fs.existsSync(outPathMP4)) {\r\n                                    outPathMP4 = path.join(dir, newid + '.mp4');\r\n                                    newid = newid + 1;\r\n                                }\r\n                                if (fs.existsSync(ffmpegPath)) {\r\n                                    ffmpegInputStream = new FFmpegStreamReadable(null);\r\n\r\n                                    ffmpegObj = new ffmpeg(ffmpegInputStream)\r\n                                        .setFfmpegPath(ffmpegPath)\r\n                                        .videoCodec('copy')\r\n                                        .audioCodec('copy')\r\n                                        .save(outPathMP4)\r\n                                        .on('error', logger.info)\r\n                                        .on('end', function () {\r\n                                            video.videopath = outPathMP4;\r\n                                            video.status = \"已完成\";\r\n                                            mainWindow.webContents.send('task-notify-end', video);\r\n\r\n                                            fs.writeFileSync(pathVideoDB, JSON.stringify(videoDatas));\r\n                                        })\r\n                                        .on('progress', logger.info);\r\n                                } else {\r\n                                    video.videopath = outPathMP4;\r\n                                    video.status = \"已完成，未发现本地FFMPEG，不进行合成。\"\r\n                                    mainWindow.webContents.send('task-notify-update', video);\r\n                                }\r\n                            }\r\n\r\n                            if (ffmpegInputStream) {\r\n                                ffmpegInputStream.push(fs.readFileSync(filpath));\r\n                                fs.unlinkSync(filpath);\r\n                            }\r\n\r\n                            //fs.appendFileSync(path.join(dir,'index.txt'),`file '${filpath}'\\r\\n`);\r\n                            count_downloaded = count_downloaded + 1;\r\n                            video.segment_downloaded = count_downloaded;\r\n                            video.status = `直播中... [${count_downloaded}]`;\r\n                            mainWindow.webContents.send('task-notify-update', video);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (globalCond[id]) {\r\n                    //使下次下载M3U8时间提前1秒钟。\r\n                    _videoDuration = _videoDuration - 1000;\r\n                    let _downloadTime = (new Date().getTime() - _startTime.getTime());\r\n                    if (_downloadTime < _videoDuration) {\r\n                        await sleep(_videoDuration - _downloadTime);\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n            parser = null;\r\n        } catch (error) {\r\n            logger.info(error.response.body);\r\n        }\r\n    }\r\n    if (ffmpegInputStream) {\r\n        ffmpegInputStream.push(null);\r\n    }\r\n\r\n    if (count_downloaded <= 0) {\r\n        video.videopath = '';\r\n        video.status = \"已完成，下载失败\"\r\n        mainWindow.webContents.send('task-notify-end', video);\r\n        return;\r\n    }\r\n}\r\n\r\n\r\nfunction formatTime(duration) {\r\n    let sec = Math.floor(duration % 60).toLocaleString();\r\n    let min = Math.floor(duration / 60 % 60).toLocaleString();\r\n    let hour = Math.floor(duration / 3600 % 60).toLocaleString();\r\n    if (sec.length != 2) sec = '0' + sec;\r\n    if (min.length != 2) min = '0' + min;\r\n    if (hour.length != 2) hour = '0' + hour;\r\n    return hour + \":\" + min + \":\" + sec;\r\n}\r\n\r\n\r\nipcMain.on('delvideo', function (event, id) {\r\n    videoDatas.forEach(Element => {\r\n        if (Element.id == id) {\r\n            try {\r\n                if (false && fs.existsSync(Element.dir)) {\r\n                    var files = fs.readdirSync(Element.dir)\r\n                    files.forEach(e => {\r\n                        //fs.unlinkSync(path.join(Element.dir,e));\r\n                        shell.moveItemToTrash(path.join(Element.dir, e))\r\n                    })\r\n                    //fs.rmdirSync(Element.dir,{recursive :true})\r\n                    shell.moveItemToTrash(Element.dir)\r\n                }\r\n                var nIdx = videoDatas.indexOf(Element);\r\n                if (nIdx > -1) {\r\n                    videoDatas.splice(nIdx, 1);\r\n                    fs.writeFileSync(pathVideoDB, JSON.stringify(videoDatas));\r\n                }\r\n                event.sender.send(\"delvideo-reply\", Element);\r\n            } catch (error) {\r\n                logger.error(error)\r\n            }\r\n        }\r\n    });\r\n});\r\n\r\nfunction showDirInExploer(dir) {\r\n    shell.openExternal(dir).catch((reason) => {\r\n        logger.error(`openExternal Error:${dir} ${reason}`);\r\n\r\n        let files = fs.readdirSync(dir);\r\n        if (files && files.length > 0) {\r\n            shell.showItemInFolder(path.join(dir, files[0]));\r\n        } else {\r\n            shell.showItemInFolder(dir);\r\n        }\r\n    });\r\n}\r\n\r\nipcMain.on('opendir', function (event, arg, path) {\r\n    fs.existsSync(arg) && showDirInExploer(arg);\r\n    !fs.existsSync(arg) && fs.existsSync(path) && showDirInExploer(path);\r\n});\r\n\r\nipcMain.on('playvideo', function (event, arg) {\r\n    fs.existsSync(arg) && createPlayerWindow(arg);\r\n});\r\nipcMain.on('StartOrStop', function (event, arg) {\r\n    logger.info(arg);\r\n\r\n    let id = Number.parseInt(arg);\r\n    if (globalCond[id] == null) {\r\n        logger.info(\"不存在此任务\")\r\n        return;\r\n    }\r\n    globalCond[id] = !globalCond[id];\r\n    if (globalCond[id] == true) {\r\n        videoDatas.forEach(Element => {\r\n            if (Element.id == id) {\r\n                if (Element.isLiving == true) {\r\n                    startDownloadLive(Element);\r\n                } else {\r\n                    startDownload(Element);\r\n                }\r\n            }\r\n        });\r\n    }\r\n});\r\n\r\nipcMain.on('setting_isdelts', function (event, arg) {\r\n    isdelts = arg;\r\n});\r\n\r\nipcMain.on('set-config', function (event, data) {\r\n    nconf.set(data.key, data.value);\r\n    nconf.save();\r\n\r\n    if (data.key == 'config_proxy') {\r\n        const config_proxy = nconf.get('config_proxy');\r\n        proxy_agent = config_proxy ? {\r\n            http: new HttpProxyAgent({\r\n                keepAlive: true,\r\n                keepAliveMsecs: 1000,\r\n                maxSockets: 256,\r\n                maxFreeSockets: 256,\r\n                scheduling: 'lifo',\r\n                proxy: config_proxy\r\n            }),\r\n            https: new HttpsProxyAgent({\r\n                keepAlive: true,\r\n                keepAliveMsecs: 1000,\r\n                maxSockets: 256,\r\n                maxFreeSockets: 256,\r\n                scheduling: 'lifo',\r\n                proxy: config_proxy\r\n            })\r\n        } : null;\r\n    }\r\n})\r\n\r\nipcMain.on('open-config-dir', function (event, arg) {\r\n    let SaveDir = pathDownloadDir;\r\n    logger.debug(`初始目录 ${SaveDir}`);\r\n    dialog.showOpenDialog(mainWindow, {\r\n        title: \"请选择文件夹\",\r\n        defaultPath: SaveDir ? SaveDir : '',\r\n        properties: ['openDirectory', 'createDirectory'],\r\n    }).then(result => {\r\n        if (!result.canceled && result.filePaths.length == 1) {\r\n            logger.debug(`选择目录 ${result.filePaths}`);\r\n            pathDownloadDir = result.filePaths[0];\r\n            nconf.set('SaveVideoDir', pathDownloadDir);\r\n            nconf.save();\r\n            event.sender.send(\"message\", {\r\n                config_save_dir: pathDownloadDir,\r\n                config_ffmpeg: ffmpegPath\r\n            });\r\n        }\r\n    }).catch(err => {\r\n        logger.error(`showOpenDialog ${err}`)\r\n    });\r\n});\r\n\r\nipcMain.on('open-select-m3u8', function (event, arg) {\r\n    dialog.showOpenDialog(mainWindow, {\r\n        title: \"请选择一个M3U8文件\",\r\n        properties: ['openFile'],\r\n    }).then(result => {\r\n        if (!result.canceled && result.filePaths.length == 1) {\r\n            event.sender.send(\"open-select-m3u8-reply\", `file:///${result.filePaths[0]}`);\r\n        }\r\n    }).catch(err => {\r\n        logger.error(`showOpenDialog ${err}`)\r\n    });\r\n});\r\n\r\nipcMain.on('open-select-ts-dir', function (event, arg) {\r\n    if (arg) {\r\n        let files = [];\r\n        try {\r\n            files = fs.readdirSync(result.filePaths[0])\r\n        } catch (error) {\r\n\r\n        }\r\n        if (files && files.length > 0) {\r\n            let _files = files.filter((f) => {\r\n                return f.endsWith('.ts') || f.endsWith('.TS')\r\n            });\r\n            if (_files.length) {\r\n                event.sender.send(\"open-select-ts-select-reply\", _files);\r\n                return;\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    dialog.showOpenDialog(mainWindow, {\r\n        title: \"请选择欲合并的TS文件\",\r\n        properties: ['openFile', 'multiSelections'],\r\n        filters: [{\r\n            name: '视频片段',\r\n            extensions: ['ts']\r\n        }, {\r\n            name: '所有文件',\r\n            extensions: ['*']\r\n        }]\r\n    }).then(result => {\r\n        if (!result.canceled && result.filePaths.length >= 1) {\r\n            if (result.filePaths.length == 1) {\r\n                event.sender.send(\"open-select-ts-dir-reply\", result.filePaths[0]);\r\n\r\n                let files = [];\r\n                try {\r\n                    files = fs.readdirSync(result.filePaths[0])\r\n                } catch (error) {\r\n\r\n                }\r\n                if (files && files.length > 0) {\r\n                    let _files = files.filter((f) => {\r\n                        return f.endsWith('.ts') || f.endsWith('.TS')\r\n                    });\r\n                    if (_files && _files.length) {\r\n                        event.sender.send(\"open-select-ts-select-reply\", _files);\r\n                        return;\r\n                    } else {\r\n                        event.sender.send(\"open-select-ts-select-reply\", files);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            let _files = result.filePaths.filter((f) => {\r\n                return f.endsWith('.ts') || f.endsWith('.TS')\r\n            });\r\n            if (_files && _files.length) {\r\n                event.sender.send(\"open-select-ts-select-reply\", _files);\r\n            } else {\r\n                event.sender.send(\"open-select-ts-select-reply\", result.filePaths);\r\n            }\r\n        }\r\n    }).catch(err => {\r\n        logger.error(`showOpenDialog ${err}`)\r\n    });\r\n});\r\n\r\nipcMain.on('start-merge-ts', async function (event, task) {\r\n    if (!task) return\r\n    let name = task.name ? task.name : (new Date().getTime() + '');\r\n\r\n    let dir = path.join(pathDownloadDir, name);\r\n    if (!fs.existsSync(dir)) {\r\n        fs.mkdirSync(dir, {\r\n            recursive: true\r\n        });\r\n    }\r\n    let outPathMP4 = path.join(dir, `${new Date().getTime()}.mp4`);\r\n\r\n    if (fs.existsSync(ffmpegPath)) {\r\n        mainWindow.webContents.send('start-merge-ts-status', {\r\n            code: 0,\r\n            progress: 1,\r\n            status: '开始合并...'\r\n        });\r\n        ffmpegInputStream = new FFmpegStreamReadable(null);\r\n\r\n        let ffmpegObj = new ffmpeg(ffmpegInputStream)\r\n            .setFfmpegPath(ffmpegPath)\r\n            .videoCodec(task.mergeType == 'speed' ? 'copy' : 'libx264')\r\n            .audioCodec(task.mergeType == 'speed' ? 'copy' : 'aac')\r\n            .format('mp4')\r\n            .save(outPathMP4)\r\n            .on('error', (error) => {\r\n                logger.error(error)\r\n                mainWindow.webContents.send('start-merge-ts-status', {\r\n                    code: -2,\r\n                    progress: 100,\r\n                    status: '合并出错|' + error\r\n                });\r\n            })\r\n            .on('end', function () {\r\n                logger.info(`${outPathMP4} merge finished.`)\r\n                mainWindow.webContents.send('start-merge-ts-status', {\r\n                    code: 1,\r\n                    progress: 100,\r\n                    status: 'success',\r\n                    dir: dir,\r\n                    path: outPathMP4\r\n                });\r\n            })\r\n            .on('progress', (info) => {\r\n                logger.info(JSON.stringify(info));\r\n                mainWindow.webContents.send('start-merge-ts-status', {\r\n                    code: 0,\r\n                    progress: -1,\r\n                    status: JSON.stringify(info)\r\n                });\r\n            });\r\n        let count = task.ts_files.length\r\n        let _last = '';\r\n        for (let index = 0; index < count; index++) {\r\n            const file = task.ts_files[index];\r\n            ffmpegInputStream.push(fs.readFileSync(file));\r\n            while (ffmpegInputStream._readableState.length > 0) {\r\n                await sleep(200);\r\n            }\r\n            let precent = Number.parseInt((index + 1) * 100 / count);\r\n            mainWindow.webContents.send('start-merge-ts-status', {\r\n                code: 0,\r\n                progress: precent,\r\n                status: `合并中...[${precent}%]`\r\n            });\r\n        }\r\n        ffmpegInputStream.push(null);\r\n    } else {\r\n        mainWindow.webContents.send('start-merge-ts-status', {\r\n            code: -1,\r\n            progress: 100,\r\n            status: '未检测到FFMPEG,不进行合并操作。'\r\n        });\r\n    }\r\n});"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 3.744140625,
          "content": "{\n  \"name\": \"m3u8-downloader\",\n  \"productName\": \"M3U8-Downloader\",\n  \"version\": \"2.1.0\",\n  \"description\": \"M3U8-Downloader，用于下载主流网站的视频和直播。\",\n  \"main\": \"main.js\",\n  \"dependencies\": {\n    \"aria2\": \"^4.1.2\",\n    \"async\": \"^3.2.4\",\n    \"crypto-js\": \"^4.1.1\",\n    \"dateformat\": \"^5.0.3\",\n    \"download\": \"^8.0.0\",\n    \"electron-context-menu\": \"^3.6.0\",\n    \"electron-is-dev\": \"^2.0.0\",\n    \"ffmpeg-static\": \"^5.1.0\",\n    \"fluent-ffmpeg\": \"^2.1.2\",\n    \"forever-monitor\": \"^3.0.3\",\n    \"got\": \"11.8.3\",\n    \"hpagent\": \"^1.2.0\",\n    \"http\": \"0.0.0\",\n    \"https\": \"^1.0.0\",\n    \"m3u8-parser\": \"^6.0.0\",\n    \"nconf\": \"^0.12.0\",\n    \"queue\": \"^6.0.2\",\n    \"url\": \"^0.11.0\",\n    \"winston\": \"^3.8.2\",\n    \"filenamify\": \"4.3.0\"\n  },\n  \"devDependencies\": {\n    \"electron\": \"^22.0.0\",\n    \"electron-builder\": \"^23.6.0\"\n  },\n  \"scripts\": {\n    \"start\": \"electron .\",\n    \"pack-mac\": \"electron-builder --mac --publish always\",\n    \"pack-win\": \"electron-builder --win --publish always\",\n    \"postinstall\": \"electron-builder install-app-deps\",\n    \"pack-linux\": \"electron-builder --linux --publish always\",\n    \"windows-latest\": \"yarn pack-win\",\n    \"macos-latest\": \"yarn pack-mac\",\n    \"ubuntu-latest\": \"yarn pack-linux\"\n  },\n  \"build\": {\n    \"appId\": \"cn.heisir.m3u8-downloader\",\n    \"artifactName\": \"${productName}-${os}_${arch}-${version}.${ext}\",\n    \"copyright\": \"Copyright © 2021 ${author}\",\n    \"compression\": \"normal\",\n    \"directories\": {\n      \"output\": \"dist\"\n    },\n    \"files\": [\n      \"**/*\",\n      \"!dist/*\",\n      \"!.github/*\",\n      \"!test/*\",\n      \"!README.md\",\n      \"!node_modules/ffmpeg-static/ffmpeg.exe\",\n      \"!node_modules/ffmpeg-static/ffmpeg\",\n      \"!node_modules/ffmpeg-static/ffmpeg.ffmpeg\",\n      \"!static/aria2/*\"\n    ],\n    \"asar\": true,\n    \"win\": {\n      \"target\": [{\n          \"target\": \"nsis\"\n        },\n        {\n          \"target\": \"zip\",\n          \"arch\": [\n            \"x64\",\n            \"ia32\"\n          ]\n        }\n      ],\n      \"extraResources\": [\n        \"node_modules/ffmpeg-static/ffmpeg.exe\",\n        \"static/aria2/win32/aria2.conf\",\n        \"static/aria2/win32/aria2c.exe\"\n      ],\n      \"icon\": \"static/icon/logo-512.png\"\n    },\n    \"dmg\": {\n      \"window\": {\n        \"width\": 540,\n        \"height\": 380\n      },\n      \"contents\": [{\n          \"x\": 410,\n          \"y\": 230,\n          \"type\": \"link\",\n          \"path\": \"/Applications\"\n        },\n        {\n          \"x\": 130,\n          \"y\": 230,\n          \"type\": \"file\"\n        }\n      ]\n    },\n    \"mac\": {\n      \"hardenedRuntime\": true,\n      \"appId\": \"cn.heisir.m3u8-downloader-mac\",\n      \"category\": \"public.app-category.productivity\",\n      \"target\": [\n        \"dmg\"\n      ],\n      \"extraResources\": [\n        \"node_modules/ffmpeg-static/ffmpeg\",\n        \"static/aria2/darwin/aria2.conf\",\n        \"static/aria2/darwin/aria2c\"\n      ],\n      \"icon\": \"static/icon/logo.icns\"\n    },\n    \"nsis\": {\n      \"perMachine\": true,\n      \"oneClick\": false,\n      \"allowElevation\": true,\n      \"allowToChangeInstallationDirectory\": true,\n      \"installerIcon\": \"static/icon/logo.ico\",\n      \"uninstallerIcon\": \"static/icon/logo.ico\",\n      \"installerHeaderIcon\": \"static/icon/logo.ico\",\n      \"createDesktopShortcut\": true,\n      \"createStartMenuShortcut\": true,\n      \"shortcutName\": \"M3U8-Downloader\"\n    },\n    \"appImage\": {\n      \"category\": \"public.app-category.productivity\"\n    },\n    \"linux\": {\n      \"extraResources\": [\n        \"node_modules/ffmpeg-static/ffmpeg\",\n        \"static/aria2/linux/aria2.conf\",\n        \"static/aria2/linux/aria2c\"\n      ],\n      \"target\": [\n        \"AppImage\",\n        \"deb\"\n      ],\n      \"maintainer\": \"heisir <heisir21@163.com>\",\n      \"category\": \"Utility\"\n    }\n  },\n  \"author\": {\n    \"name\": \"heisir\",\n    \"email\": \"heisir21@163.com\",\n    \"qq\": \"1586462\"\n  },\n  \"license\": \"MIT\"\n}"
        },
        {
          "name": "resource",
          "type": "tree",
          "content": null
        },
        {
          "name": "static",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "ts-repair.js",
          "type": "blob",
          "size": 0.1533203125,
          "content": "const fs = require('fs');\n\nfunction repairTs(filePath)\n{\n    if(fs.existsSync(filePath))\n    {\n        let data = fs.readFileSync(filePath);\n        \n    }\n}"
        }
      ]
    }
  ]
}