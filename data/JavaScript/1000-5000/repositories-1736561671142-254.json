{
  "metadata": {
    "timestamp": 1736561671142,
    "page": 254,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dankogai/js-base64",
      "stars": 4283,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.720703125,
          "content": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\nlerna-debug.log*\n\n# Diagnostic reports (https://nodejs.org/api/report.html)\nreport.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n*.lcov\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Bower dependency directory (https://bower.io/)\nbower_components\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (https://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules/\njspm_packages/\n\n# TypeScript v1 declaration files\ntypings/\n\n# TypeScript cache\n*.tsbuildinfo\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Microbundle cache\n.rpt2_cache/\n.rts2_cache_cjs/\n.rts2_cache_es/\n.rts2_cache_umd/\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Yarn Integrity file\n.yarn-integrity\n\n# dotenv environment variables file\n.env\n.env.test\n\n# parcel-bundler cache (https://parceljs.org/)\n.cache\n\n# Next.js build output\n.next\n\n# Nuxt.js build / generate output\n.nuxt\ndist\n\n# Gatsby files\n.cache/\n# Comment in the public line in if your project uses Gatsby and *not* Next.js\n# https://nextjs.org/blog/next-9-1#public-directory-support\n# public\n\n# vuepress build output\n.vuepress/dist\n\n# Serverless directories\n.serverless/\n\n# FuseBox cache\n.fusebox/\n\n# DynamoDB Local files\n.dynamodb/\n\n# TernJS port file\n.tern-port\n\n# ignore all . folders but include . files\n.*/\n\n# from previous .gitignore\n*,v\n*.bak\nattic/**/*\nnode_modules/**/*\ntmp/**/*\npackage-lock.json\nyarn.lock\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.0400390625,
          "content": ".babelrc\n.eslintrc\n.travis.yml\n*,v\n*.bak\n"
        },
        {
          "name": "1x1.png",
          "type": "blob",
          "size": 0.06640625,
          "content": null
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.4453125,
          "content": "Copyright (c) 2014, Dan Kogai\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of {{{project}}} nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.4658203125,
          "content": "PJ=package.json\nTS=base64.ts\nJS=base64.js\nES5=base64.es5.js\nES6=base64.es6.js\nMJS=base64.mjs\nDTS=base64.d.ts\nMDTS=base64.d.mts\n\nall: $(MJS) $(JS)\n\n$(MJS): $(PJ) $(TS)\n\t-tsc -d --target es6 $(TS) > /dev/null; mv $(JS) $(MJS); cp $(DTS) $(MDTS)\n\n$(ES6): $(MJS)\n\tutil/makecjs $(MJS) > $(ES6)\n\n$(ES5): $(ES6)\n\ttsc --allowJS --outFile $(ES5) $(ES6)\n\n$(JS): $(ES5)\n\trm $(ES6) && mv $(ES5) $(JS)\n\ntest: $(PJ) $(MJS) $(JS)\n\tmocha\n\nclean:\n\t-rm $(DTS) $(MDTS) $(MJS) $(JS) $(ES5) $(ES6)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.166015625,
          "content": "[![CI via GitHub Actions](https://github.com/dankogai/js-base64/actions/workflows/node.js.yml/badge.svg)](https://github.com/dankogai/js-base64/actions/workflows/node.js.yml)\n\n# base64.js\n\nYet another [Base64] transcoder.\n\n[Base64]: http://en.wikipedia.org/wiki/Base64\n\n## Install\n\n```shell\n$ npm install --save js-base64\n```\n\n## Usage\n\n### In Browser\n\nLocally…\n\n```html\n<script src=\"base64.js\"></script>\n```\n\n… or Directly from CDN.  In which case you don't even need to install.\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/js-base64@3.7.7/base64.min.js\"></script>\n```\n\nThis good old way loads `Base64` in the global context (`window`).  Though `Base64.noConflict()` is made available, you should consider using ES6 Module to avoid tainting `window`.\n\n### As an ES6 Module\n\nlocally…\n\n```javascript\nimport { Base64 } from 'js-base64';\n```\n\n```javascript\n// or if you prefer no Base64 namespace\nimport { encode, decode } from 'js-base64';\n```\n\nor even remotely.\n\n```html\n<script type=\"module\">\n// note jsdelivr.net does not automatically minify .mjs\nimport { Base64 } from 'https://cdn.jsdelivr.net/npm/js-base64@3.7.7/base64.mjs';\n</script>\n```\n\n```html\n<script type=\"module\">\n// or if you prefer no Base64 namespace\nimport { encode, decode } from 'https://cdn.jsdelivr.net/npm/js-base64@3.7.7/base64.mjs';\n</script>\n```\n\n### node.js (commonjs)\n\n```javascript\nconst {Base64} = require('js-base64');\n```\n\nUnlike the case above, the global context is no longer modified.\n\nYou can also use [esm] to `import` instead of `require`.\n\n[esm]: https://github.com/standard-things/esm\n\n```javascript\nrequire=require('esm')(module);\nimport {Base64} from 'js-base64';\n```\n\n## SYNOPSIS\n\n```javascript\nlet latin = 'dankogai';\nlet utf8  = '小飼弾'\nlet u8s   =  new Uint8Array([100,97,110,107,111,103,97,105]);\nBase64.encode(latin);             // ZGFua29nYWk=\nBase64.encode(latin, true);       // ZGFua29nYWk skips padding\nBase64.encodeURI(latin);          // ZGFua29nYWk\nBase64.btoa(latin);               // ZGFua29nYWk=\nBase64.btoa(utf8);                // raises exception\nBase64.fromUint8Array(u8s);       // ZGFua29nYWk=\nBase64.fromUint8Array(u8s, true); // ZGFua29nYW which is URI safe\nBase64.encode(utf8);              // 5bCP6aO85by+\nBase64.encode(utf8, true)         // 5bCP6aO85by-\nBase64.encodeURI(utf8);           // 5bCP6aO85by-\n```\n\n```javascript\nBase64.decode(      'ZGFua29nYWk=');// dankogai\nBase64.decode(      'ZGFua29nYWk'); // dankogai\nBase64.atob(        'ZGFua29nYWk=');// dankogai\nBase64.atob(        '5bCP6aO85by+');// 'å°é£¼å¼¾' which is nonsense\nBase64.toUint8Array('ZGFua29nYWk=');// u8s above\nBase64.decode(      '5bCP6aO85by+');// 小飼弾\n// note .decodeURI() is unnecessary since it accepts both flavors\nBase64.decode(      '5bCP6aO85by-');// 小飼弾\n```\n\n```javascript\nBase64.isValid(0);      // false: 0 is not string\nBase64.isValid('');     // true: a valid Base64-encoded empty byte\nBase64.isValid('ZA=='); // true: a valid Base64-encoded 'd'\nBase64.isValid('Z A='); // true: whitespaces are okay\nBase64.isValid('ZA');   // true: padding ='s can be omitted\nBase64.isValid('++');   // true: can be non URL-safe\nBase64.isValid('--');   // true: or URL-safe\nBase64.isValid('+-');   // false: can't mix both\n```\n\n### Built-in Extensions\n\nBy default `Base64` leaves built-in prototypes untouched.  But you can extend them as below.\n\n```javascript\n// you have to explicitly extend String.prototype\nBase64.extendString();\n// once extended, you can do the following\n'dankogai'.toBase64();        // ZGFua29nYWk=\n'小飼弾'.toBase64();           // 5bCP6aO85by+\n'小飼弾'.toBase64(true);       // 5bCP6aO85by-\n'小飼弾'.toBase64URI();        // 5bCP6aO85by- ab alias of .toBase64(true)\n'小飼弾'.toBase64URL();        // 5bCP6aO85by- an alias of .toBase64URI()\n'ZGFua29nYWk='.fromBase64();  // dankogai\n'5bCP6aO85by+'.fromBase64();  // 小飼弾\n'5bCP6aO85by-'.fromBase64();  // 小飼弾\n'5bCP6aO85by-'.toUint8Array();// u8s above\n```\n\n```javascript\n// you have to explicitly extend Uint8Array.prototype\nBase64.extendUint8Array();\n// once extended, you can do the following\nu8s.toBase64();     // 'ZGFua29nYWk='\nu8s.toBase64URI();  // 'ZGFua29nYWk'\nu8s.toBase64URL();  // 'ZGFua29nYWk' an alias of .toBase64URI()\n```\n\n```javascript\n// extend all at once\nBase64.extendBuiltins()\n```\n\n## `.decode()` vs `.atob` (and `.encode()` vs `btoa()`)\n\nSuppose you have:\n\n```\nvar pngBase64 = \n  \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\";\n```\n\nWhich is a Base64-encoded 1x1 transparent PNG, **DO NOT USE** `Base64.decode(pngBase64)`.  Use `Base64.atob(pngBase64)` instead.  `Base64.decode()` decodes to UTF-8 string while `Base64.atob()` decodes to bytes, which is compatible to browser built-in `atob()` (Which is absent in node.js).  The same rule applies to the opposite direction.\n\nOr even better, `Base64.toUint8Array(pngBase64)`.\n\n## Brief History\n\n* Since version 3.3 it is written in TypeScript.  Now `base64.mjs` is compiled from `base64.ts` then `base64.js` is generated from `base64.mjs`.\n* Since version 3.7 `base64.js` is ES5-compatible again (hence IE11-compatible).\n* Since 3.0 `js-base64` switch to ES2015 module so it is no longer compatible with legacy browsers like IE (see above)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.2783203125,
          "content": "# Security Policy\n\n## Supported Versions\n\n\n| Version | Supported          |\n| ------- | ------------------ |\n| 3.x.x   | :white_check_mark: |\n| < 2.x   | :white_check_mark:  security fixes only |\n\n## Reporting a Vulnerability\n\nPlease mail it to the author, dankogai+github@gmail.com .\n"
        },
        {
          "name": "base64.d.mts",
          "type": "blob",
          "size": 3.8623046875,
          "content": "/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\ndeclare const version = \"3.7.7\";\n/**\n * @deprecated use lowercase `version`.\n */\ndeclare const VERSION = \"3.7.7\";\n/**\n * polyfill version of `btoa`\n */\ndeclare const btoaPolyfill: (bin: string) => string;\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\ndeclare const _btoa: (bin: string) => string;\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n * @returns {string} Base64 string\n */\ndeclare const fromUint8Array: (u8a: Uint8Array, urlsafe?: boolean) => string;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\ndeclare const utob: (u: string) => string;\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\ndeclare const encode: (src: string, urlsafe?: boolean) => string;\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n * @returns {string} Base64 string\n */\ndeclare const encodeURI: (src: string) => string;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\ndeclare const btou: (b: string) => string;\n/**\n * polyfill version of `atob`\n */\ndeclare const atobPolyfill: (asc: string) => string;\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\ndeclare const _atob: (asc: string) => string;\n/**\n * converts a Base64 string to a Uint8Array.\n */\ndeclare const toUint8Array: (a: string) => Uint8Array;\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\ndeclare const decode: (src: string) => string;\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\ndeclare const isValid: (src: any) => boolean;\n/**\n * extend String.prototype with relevant methods\n */\ndeclare const extendString: () => void;\n/**\n * extend Uint8Array.prototype with relevant methods\n */\ndeclare const extendUint8Array: () => void;\n/**\n * extend Builtin prototypes with relevant methods\n */\ndeclare const extendBuiltins: () => void;\ndeclare const gBase64: {\n    version: string;\n    VERSION: string;\n    atob: (asc: string) => string;\n    atobPolyfill: (asc: string) => string;\n    btoa: (bin: string) => string;\n    btoaPolyfill: (bin: string) => string;\n    fromBase64: (src: string) => string;\n    toBase64: (src: string, urlsafe?: boolean) => string;\n    encode: (src: string, urlsafe?: boolean) => string;\n    encodeURI: (src: string) => string;\n    encodeURL: (src: string) => string;\n    utob: (u: string) => string;\n    btou: (b: string) => string;\n    decode: (src: string) => string;\n    isValid: (src: any) => boolean;\n    fromUint8Array: (u8a: Uint8Array, urlsafe?: boolean) => string;\n    toUint8Array: (a: string) => Uint8Array;\n    extendString: () => void;\n    extendUint8Array: () => void;\n    extendBuiltins: () => void;\n};\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\nexport { gBase64 as Base64 };\n"
        },
        {
          "name": "base64.d.ts",
          "type": "blob",
          "size": 3.8623046875,
          "content": "/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\ndeclare const version = \"3.7.7\";\n/**\n * @deprecated use lowercase `version`.\n */\ndeclare const VERSION = \"3.7.7\";\n/**\n * polyfill version of `btoa`\n */\ndeclare const btoaPolyfill: (bin: string) => string;\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\ndeclare const _btoa: (bin: string) => string;\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n * @returns {string} Base64 string\n */\ndeclare const fromUint8Array: (u8a: Uint8Array, urlsafe?: boolean) => string;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\ndeclare const utob: (u: string) => string;\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\ndeclare const encode: (src: string, urlsafe?: boolean) => string;\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n * @returns {string} Base64 string\n */\ndeclare const encodeURI: (src: string) => string;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\ndeclare const btou: (b: string) => string;\n/**\n * polyfill version of `atob`\n */\ndeclare const atobPolyfill: (asc: string) => string;\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\ndeclare const _atob: (asc: string) => string;\n/**\n * converts a Base64 string to a Uint8Array.\n */\ndeclare const toUint8Array: (a: string) => Uint8Array;\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\ndeclare const decode: (src: string) => string;\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\ndeclare const isValid: (src: any) => boolean;\n/**\n * extend String.prototype with relevant methods\n */\ndeclare const extendString: () => void;\n/**\n * extend Uint8Array.prototype with relevant methods\n */\ndeclare const extendUint8Array: () => void;\n/**\n * extend Builtin prototypes with relevant methods\n */\ndeclare const extendBuiltins: () => void;\ndeclare const gBase64: {\n    version: string;\n    VERSION: string;\n    atob: (asc: string) => string;\n    atobPolyfill: (asc: string) => string;\n    btoa: (bin: string) => string;\n    btoaPolyfill: (bin: string) => string;\n    fromBase64: (src: string) => string;\n    toBase64: (src: string, urlsafe?: boolean) => string;\n    encode: (src: string, urlsafe?: boolean) => string;\n    encodeURI: (src: string) => string;\n    encodeURL: (src: string) => string;\n    utob: (u: string) => string;\n    btou: (b: string) => string;\n    decode: (src: string) => string;\n    isValid: (src: any) => boolean;\n    fromUint8Array: (u8a: Uint8Array, urlsafe?: boolean) => string;\n    toUint8Array: (a: string) => Uint8Array;\n    extendString: () => void;\n    extendUint8Array: () => void;\n    extendBuiltins: () => void;\n};\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\nexport { gBase64 as Base64 };\n"
        },
        {
          "name": "base64.html",
          "type": "blob",
          "size": 0.982421875,
          "content": "<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>Demo for base64.js</title>\n</head>\n<body>\n<h1>Demo for base64.js</h1>\n<table width=\"640\"><tbody>\n<tr><th width=\"50%\">Text</th><th>Base64\n(URL Safe <input id=\"encodeURI\" type=\"checkbox\" onclick=\"doit()\">)</th></tr>\n<tr>\n<th><textarea id=\"srctxt\" cols=\"32\" rows=\"4\" onkeyup=\"doit()\">\n</textarea></th>\n<th><textarea id=\"base64\" cols=\"32\" rows=\"4\" onkeyup=\"\n    $('srctxt').value = Base64.decode(this.value);\n    doit();\n\"></textarea></th>\n</tr>\n<tr><th width=\"50%\">Roundtrip</th><th></th></tr>\n<tr>\n<th><textarea id=\"roundtrip\" cols=\"32\" rows=\"4\" disabled></textarea></th>\n<th></th>\n</tr>\n</tbody></table>\n\n\n<script src=\"./base64.js\"></script>\n<script>\n$ = function(id){ return document.getElementById(id) };\nfunction doit(){\n    var encoded = Base64[ \n        'encode' + ($('encodeURI').checked ? 'URI' : '')\n     ]($('srctxt').value);\n    $('base64').value = encoded;\n    $('roundtrip').value = Base64.decode(encoded);\n}\n</script>\n</body>\n</html>\n"
        },
        {
          "name": "base64.js",
          "type": "blob",
          "size": 12.5,
          "content": "//\n// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!\n//\n;\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined'\n        ? module.exports = factory()\n        : typeof define === 'function' && define.amd\n            ? define(factory) :\n            // cf. https://github.com/dankogai/js-base64/issues/119\n            (function () {\n                // existing version for noConflict()\n                var _Base64 = global.Base64;\n                var gBase64 = factory();\n                gBase64.noConflict = function () {\n                    global.Base64 = _Base64;\n                    return gBase64;\n                };\n                if (global.Meteor) { // Meteor.js\n                    Base64 = gBase64;\n                }\n                global.Base64 = gBase64;\n            })();\n}((typeof self !== 'undefined' ? self\n    : typeof window !== 'undefined' ? window\n        : typeof global !== 'undefined' ? global\n            : this), function () {\n    'use strict';\n    /**\n     *  base64.ts\n     *\n     *  Licensed under the BSD 3-Clause License.\n     *    http://opensource.org/licenses/BSD-3-Clause\n     *\n     *  References:\n     *    http://en.wikipedia.org/wiki/Base64\n     *\n     * @author Dan Kogai (https://github.com/dankogai)\n     */\n    var version = '3.7.7';\n    /**\n     * @deprecated use lowercase `version`.\n     */\n    var VERSION = version;\n    var _hasBuffer = typeof Buffer === 'function';\n    var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\n    var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\n    var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var b64chs = Array.prototype.slice.call(b64ch);\n    var b64tab = (function (a) {\n        var tab = {};\n        a.forEach(function (c, i) { return tab[c] = i; });\n        return tab;\n    })(b64chs);\n    var b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n    var _fromCC = String.fromCharCode.bind(String);\n    var _U8Afrom = typeof Uint8Array.from === 'function'\n        ? Uint8Array.from.bind(Uint8Array)\n        : function (it) { return new Uint8Array(Array.prototype.slice.call(it, 0)); };\n    var _mkUriSafe = function (src) { return src\n        .replace(/=/g, '').replace(/[+\\/]/g, function (m0) { return m0 == '+' ? '-' : '_'; }); };\n    var _tidyB64 = function (s) { return s.replace(/[^A-Za-z0-9\\+\\/]/g, ''); };\n    /**\n     * polyfill version of `btoa`\n     */\n    var btoaPolyfill = function (bin) {\n        // console.log('polyfilled');\n        var u32, c0, c1, c2, asc = '';\n        var pad = bin.length % 3;\n        for (var i = 0; i < bin.length;) {\n            if ((c0 = bin.charCodeAt(i++)) > 255 ||\n                (c1 = bin.charCodeAt(i++)) > 255 ||\n                (c2 = bin.charCodeAt(i++)) > 255)\n                throw new TypeError('invalid character found');\n            u32 = (c0 << 16) | (c1 << 8) | c2;\n            asc += b64chs[u32 >> 18 & 63]\n                + b64chs[u32 >> 12 & 63]\n                + b64chs[u32 >> 6 & 63]\n                + b64chs[u32 & 63];\n        }\n        return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n    };\n    /**\n     * does what `window.btoa` of web browsers do.\n     * @param {String} bin binary string\n     * @returns {string} Base64-encoded string\n     */\n    var _btoa = typeof btoa === 'function' ? function (bin) { return btoa(bin); }\n        : _hasBuffer ? function (bin) { return Buffer.from(bin, 'binary').toString('base64'); }\n            : btoaPolyfill;\n    var _fromUint8Array = _hasBuffer\n        ? function (u8a) { return Buffer.from(u8a).toString('base64'); }\n        : function (u8a) {\n            // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n            var maxargs = 0x1000;\n            var strs = [];\n            for (var i = 0, l = u8a.length; i < l; i += maxargs) {\n                strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n            }\n            return _btoa(strs.join(''));\n        };\n    /**\n     * converts a Uint8Array to a Base64 string.\n     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n     * @returns {string} Base64 string\n     */\n    var fromUint8Array = function (u8a, urlsafe) {\n        if (urlsafe === void 0) { urlsafe = false; }\n        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n    };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const utob = (src: string) => unescape(encodeURIComponent(src));\n    // reverting good old fationed regexp\n    var cb_utob = function (c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                    + _fromCC(0x80 | (cc & 0x3f)))\n                    : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                        + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                        + _fromCC(0x80 | (cc & 0x3f)));\n        }\n        else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n                + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n                + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                + _fromCC(0x80 | (cc & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-8 string\n     * @returns {string} UTF-16 string\n     */\n    var utob = function (u) { return u.replace(re_utob, cb_utob); };\n    //\n    var _encode = _hasBuffer\n        ? function (s) { return Buffer.from(s, 'utf8').toString('base64'); }\n        : _TE\n            ? function (s) { return _fromUint8Array(_TE.encode(s)); }\n            : function (s) { return _btoa(utob(s)); };\n    /**\n     * converts a UTF-8-encoded string to a Base64 string.\n     * @param {boolean} [urlsafe] if `true` make the result URL-safe\n     * @returns {string} Base64 string\n     */\n    var encode = function (src, urlsafe) {\n        if (urlsafe === void 0) { urlsafe = false; }\n        return urlsafe\n            ? _mkUriSafe(_encode(src))\n            : _encode(src);\n    };\n    /**\n     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n     * @returns {string} Base64 string\n     */\n    var encodeURI = function (src) { return encode(src, true); };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const btou = (src: string) => decodeURIComponent(escape(src));\n    // reverting good old fationed regexp\n    var re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\n    var cb_btou = function (cccc) {\n        switch (cccc.length) {\n            case 4:\n                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                    | ((0x3f & cccc.charCodeAt(1)) << 12)\n                    | ((0x3f & cccc.charCodeAt(2)) << 6)\n                    | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n                return (_fromCC((offset >>> 10) + 0xD800)\n                    + _fromCC((offset & 0x3FF) + 0xDC00));\n            case 3:\n                return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    | (0x3f & cccc.charCodeAt(2)));\n            default:\n                return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                    | (0x3f & cccc.charCodeAt(1)));\n        }\n    };\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-16 string\n     * @returns {string} UTF-8 string\n     */\n    var btou = function (b) { return b.replace(re_btou, cb_btou); };\n    /**\n     * polyfill version of `atob`\n     */\n    var atobPolyfill = function (asc) {\n        // console.log('polyfilled');\n        asc = asc.replace(/\\s+/g, '');\n        if (!b64re.test(asc))\n            throw new TypeError('malformed base64.');\n        asc += '=='.slice(2 - (asc.length & 3));\n        var u24, bin = '', r1, r2;\n        for (var i = 0; i < asc.length;) {\n            u24 = b64tab[asc.charAt(i++)] << 18\n                | b64tab[asc.charAt(i++)] << 12\n                | (r1 = b64tab[asc.charAt(i++)]) << 6\n                | (r2 = b64tab[asc.charAt(i++)]);\n            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n                : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                    : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n        }\n        return bin;\n    };\n    /**\n     * does what `window.atob` of web browsers do.\n     * @param {String} asc Base64-encoded string\n     * @returns {string} binary string\n     */\n    var _atob = typeof atob === 'function' ? function (asc) { return atob(_tidyB64(asc)); }\n        : _hasBuffer ? function (asc) { return Buffer.from(asc, 'base64').toString('binary'); }\n            : atobPolyfill;\n    //\n    var _toUint8Array = _hasBuffer\n        ? function (a) { return _U8Afrom(Buffer.from(a, 'base64')); }\n        : function (a) { return _U8Afrom(_atob(a).split('').map(function (c) { return c.charCodeAt(0); })); };\n    /**\n     * converts a Base64 string to a Uint8Array.\n     */\n    var toUint8Array = function (a) { return _toUint8Array(_unURI(a)); };\n    //\n    var _decode = _hasBuffer\n        ? function (a) { return Buffer.from(a, 'base64').toString('utf8'); }\n        : _TD\n            ? function (a) { return _TD.decode(_toUint8Array(a)); }\n            : function (a) { return btou(_atob(a)); };\n    var _unURI = function (a) { return _tidyB64(a.replace(/[-_]/g, function (m0) { return m0 == '-' ? '+' : '/'; })); };\n    /**\n     * converts a Base64 string to a UTF-8 string.\n     * @param {String} src Base64 string.  Both normal and URL-safe are supported\n     * @returns {string} UTF-8 string\n     */\n    var decode = function (src) { return _decode(_unURI(src)); };\n    /**\n     * check if a value is a valid Base64 string\n     * @param {String} src a value to check\n      */\n    var isValid = function (src) {\n        if (typeof src !== 'string')\n            return false;\n        var s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n        return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n    };\n    //\n    var _noEnum = function (v) {\n        return {\n            value: v, enumerable: false, writable: true, configurable: true\n        };\n    };\n    /**\n     * extend String.prototype with relevant methods\n     */\n    var extendString = function () {\n        var _add = function (name, body) { return Object.defineProperty(String.prototype, name, _noEnum(body)); };\n        _add('fromBase64', function () { return decode(this); });\n        _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n        _add('toBase64URI', function () { return encode(this, true); });\n        _add('toBase64URL', function () { return encode(this, true); });\n        _add('toUint8Array', function () { return toUint8Array(this); });\n    };\n    /**\n     * extend Uint8Array.prototype with relevant methods\n     */\n    var extendUint8Array = function () {\n        var _add = function (name, body) { return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body)); };\n        _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n        _add('toBase64URI', function () { return fromUint8Array(this, true); });\n        _add('toBase64URL', function () { return fromUint8Array(this, true); });\n    };\n    /**\n     * extend Builtin prototypes with relevant methods\n     */\n    var extendBuiltins = function () {\n        extendString();\n        extendUint8Array();\n    };\n    var gBase64 = {\n        version: version,\n        VERSION: VERSION,\n        atob: _atob,\n        atobPolyfill: atobPolyfill,\n        btoa: _btoa,\n        btoaPolyfill: btoaPolyfill,\n        fromBase64: decode,\n        toBase64: encode,\n        encode: encode,\n        encodeURI: encodeURI,\n        encodeURL: encodeURI,\n        utob: utob,\n        btou: btou,\n        decode: decode,\n        isValid: isValid,\n        fromUint8Array: fromUint8Array,\n        toUint8Array: toUint8Array,\n        extendString: extendString,\n        extendUint8Array: extendUint8Array,\n        extendBuiltins: extendBuiltins\n    };\n    //\n    // export Base64 to the namespace\n    //\n    // ES5 is yet to have Object.assign() that may make transpilers unhappy.\n    // gBase64.Base64 = Object.assign({}, gBase64);\n    gBase64.Base64 = {};\n    Object.keys(gBase64).forEach(function (k) { return gBase64.Base64[k] = gBase64[k]; });\n    return gBase64;\n}));\n"
        },
        {
          "name": "base64.mjs",
          "type": "blob",
          "size": 10.052734375,
          "content": "/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.7';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = typeof btoa === 'function' ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = typeof atob === 'function' ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins\n};\n// makecjs:CUT //\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\n// and finally,\nexport { gBase64 as Base64 };\n"
        },
        {
          "name": "base64.ts",
          "type": "blob",
          "size": 10.3974609375,
          "content": "/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n * \n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.7';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re =\n    /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src: string) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s: string) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin: string) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = typeof btoa === 'function' ? (bin: string) => btoa(bin)\n    : _hasBuffer ? (bin: string) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a: Uint8Array) => Buffer.from(u8a).toString('base64')\n    : (u8a: Uint8Array) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs: string[] = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a: Uint8Array, urlsafe = false) =>\n    urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c: string) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    } else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u: string) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s: string) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s: string) => _fromUint8Array(_TE.encode(s))\n        : (s: string) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src: string, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src: string) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc: string) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)),\n                offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(\n                ((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2))\n            );\n        default:\n            return _fromCC(\n                ((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1))\n            );\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b: string) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc: string) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc)) throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = typeof atob === 'function' ? (asc: string) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc: string) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a: string) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a: string) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a: string): Uint8Array => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a: string) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a: string) => _TD.decode(_toUint8Array(a))\n        : (a: string) => btou(_atob(a));\nconst _unURI = (a: string) =>\n    _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src: string) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src: any) => {\n    if (typeof src !== 'string') return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(\n        String.prototype, name, _noEnum(body)\n    );\n    _add('fromBase64', function () { return decode(this) });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe) });\n    _add('toBase64URI', function () { return encode(this, true) });\n    _add('toBase64URL', function () { return encode(this, true) });\n    _add('toUint8Array', function () { return toUint8Array(this) });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(\n        Uint8Array.prototype, name, _noEnum(body)\n    );\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe) });\n    _add('toBase64URI', function () { return fromUint8Array(this, true) });\n    _add('toBase64URL', function () { return fromUint8Array(this, true) });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n}\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins\n}\n// makecjs:CUT //\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill }\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\n// and finally,\nexport { gBase64 as Base64 };\n"
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.248046875,
          "content": "{\n  \"name\": \"js-base64\",\n  \"version\": \"3.7.7\",\n  \"license\": \"BSD-3-Clause\",\n  \"main\": [\n    \"./base64.js\"\n  ],\n  \"ignore\": [\n    \"old\",\n    \"test\",\n    \".gitignore\",\n    \".travis.yml\",\n    \"base64.html\",\n    \"package.json\"\n  ],\n  \"dependencies\": {\n  }\n}\n"
        },
        {
          "name": "package.js",
          "type": "blob",
          "size": 0.1689453125,
          "content": "Package.describe({\n    summary: \"Yet another Base64 transcoder\"\n})\n\nPackage.on_use(function(api){\n    api.export('Base64');\n\n    api.add_files(['base64.js'], 'server');\n});\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.8076171875,
          "content": "{\n\t\"name\": \"js-base64\",\n\t\"version\": \"3.7.7\",\n\t\"description\": \"Yet another Base64 transcoder in pure-JS\",\n\t\"main\": \"base64.js\",\n\t\"module\": \"base64.mjs\",\n\t\"types\": \"base64.d.ts\",\n\t\"sideEffects\": false,\n\t\"files\": [\n\t\t\"base64.js\",\n\t\t\"base64.mjs\",\n\t\t\"base64.d.ts\",\n\t\t\"base64.d.mts\"\n\t],\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"import\": {\n\t\t\t\t\"types\": \"./base64.d.mts\",\n\t\t\t\t\"default\": \"./base64.mjs\"\n\t\t\t},\n\t\t\t\"require\": {\n\t\t\t\t\"types\": \"./base64.d.ts\",\n\t\t\t\t\"default\": \"./base64.js\"\n\t\t\t}\n\t\t},\n\t\t\"./package.json\": \"./package.json\"\n\t},\n\t\"scripts\": {\n\t\t\"test\": \"make clean && make test\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@types/node\": \"^20.11.5\",\n\t\t\"mocha\": \"^10.2.0\",\n\t\t\"typescript\": \"^5.3.3\"\n\t},\n\t\"repository\": \"git+https://github.com/dankogai/js-base64.git\",\n\t\"keywords\": [\n\t\t\"base64\",\n\t\t\"binary\"\n\t],\n\t\"author\": \"Dan Kogai\",\n\t\"license\": \"BSD-3-Clause\"\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}