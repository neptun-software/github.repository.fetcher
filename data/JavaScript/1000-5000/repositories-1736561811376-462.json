{
  "metadata": {
    "timestamp": 1736561811376,
    "page": 462,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "home-sweet-gnome/dash-to-panel",
      "stars": 3855,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0966796875,
          "content": ".~\n*~\ngschemas.compiled\ndash-to-panel@jderose9.github.com*.zip\n*.mo\npo/dash-to-panel.pot\nui/*.ui.h\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.5712890625,
          "content": "\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\f\n\t\t    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\f\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\f\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\f\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\f\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year  name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Library General\nPublic License instead of this License.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.66015625,
          "content": "# Basic Makefile\n\nUUID = dash-to-panel@jderose9.github.com\nBASE_MODULES = extension.js stylesheet.css metadata.json COPYING README.md\nEXTRA_MODULES = appIcons.js panel.js panelManager.js proximity.js intellihide.js progress.js panelPositions.js panelSettings.js panelStyle.js overview.js taskbar.js transparency.js windowPreview.js prefs.js utils.js desktopIconsIntegration.js\nUI_MODULES = ui/BoxAdvancedOptions.ui ui/BoxAnimateAppIconHoverOptions.ui ui/BoxDotOptions.ui ui/BoxDynamicOpacityOptions.ui ui/BoxGroupAppsOptions.ui ui/BoxIntellihideOptions.ui ui/BoxMiddleClickOptions.ui ui/BoxOverlayShortcut.ui ui/BoxScrollIconOptions.ui ui/BoxScrollPanelOptions.ui ui/BoxSecondaryMenuOptions.ui ui/BoxShowApplicationsOptions.ui ui/BoxShowDesktopOptions.ui ui/BoxWindowPreviewOptions.ui ui/SettingsAbout.ui ui/SettingsAction.ui ui/SettingsBehavior.ui ui/SettingsFineTune.ui ui/SettingsPosition.ui ui/SettingsStyle.ui\n\nEXTRA_IMAGES = highlight_stacked_bg.svg highlight_stacked_bg_2.svg highlight_stacked_bg_3.svg\n\nTOLOCALIZE =  prefs.js appIcons.js\nMSGSRC = $(wildcard po/*.po)\nifeq ($(strip $(DESTDIR)),)\n\tINSTALLBASE = $(HOME)/.local/share/gnome-shell/extensions\nelse\n\tINSTALLBASE = $(DESTDIR)/usr/share/gnome-shell/extensions\nendif\nINSTALLNAME = dash-to-panel@jderose9.github.com\n\n# The command line passed variable VERSION is used to set the version string\n# in the metadata and in the generated zip-file. If no VERSION is passed, the\n# version is pulled from the latest git tag and the current commit SHA1 is \n# added to the metadata\nifdef VERSION\n    ifdef TARGET\n\t\tFILESUFFIX = _v$(VERSION)_$(TARGET)\n\telse\n\t\tFILESUFFIX = _v$(VERSION)\n\tendif\nelse\n\tLATEST_TAG = $(shell git describe --match \"v[0-9]*\" --abbrev=0 --tags HEAD)\n\tVERSION = $(LATEST_TAG:v%=%)\n\tCOMMIT = $(shell git rev-parse HEAD)\n\tFILESUFFIX =\nendif\n\nall: extension\n\nclean:\n\trm -f ./schemas/gschemas.compiled\n\nextension: ./schemas/gschemas.compiled $(MSGSRC:.po=.mo)\n\n./schemas/gschemas.compiled: ./schemas/org.gnome.shell.extensions.dash-to-panel.gschema.xml\n\tglib-compile-schemas ./schemas/\n\npotfile: ./po/dash-to-panel.pot\n\nmergepo: potfile\n\tfor l in $(MSGSRC); do \\\n\t\tmsgmerge -U $$l ./po/dash-to-panel.pot; \\\n\tdone;\n\n./po/dash-to-panel.pot: $(TOLOCALIZE)\n\tmkdir -p po\n\txgettext -k_ -kN_ -o po/dash-to-panel.pot --package-name \"Dash To Panel\" $(TOLOCALIZE) --from-code=UTF-8\n\t\n\tfor l in $(UI_MODULES) ; do \\\n\t\tintltool-extract --type=gettext/glade $$l; \\\n\t\txgettext -k_ -kN_ -o po/dash-to-panel.pot $$l.h --join-existing --from-code=UTF-8; \\\n\t\trm -rf $$l.h; \\\n\tdone;\n\n\tsed -i -e 's/&\\#10;/\\\\n/g' po/dash-to-panel.pot\n\n./po/%.mo: ./po/%.po\n\tmsgfmt -c $< -o $@\n\ninstall: install-local\n\ninstall-local: _build\n\trm -rf $(INSTALLBASE)/$(INSTALLNAME)\n\tmkdir -p $(INSTALLBASE)/$(INSTALLNAME)\n\tcp -r ./_build/* $(INSTALLBASE)/$(INSTALLNAME)/\n\t-rm -fR _build\n\techo done\n\nzip-file: _build\n\tcd _build ; \\\n\tzip -qr \"$(UUID)$(FILESUFFIX).zip\" .\n\tmv _build/$(UUID)$(FILESUFFIX).zip ./\n\t-rm -fR _build\n\n_build: all\n\t-rm -fR ./_build\n\tmkdir -p _build\n\tcp $(BASE_MODULES) $(EXTRA_MODULES) _build\n\tmkdir -p _build/ui\n\tcp $(UI_MODULES) _build/ui\n\n\tmkdir -p _build/img\n\tcd img ; cp $(EXTRA_IMAGES) ../_build/img/\n\tmkdir -p _build/schemas\n\tcp schemas/*.xml _build/schemas/\n\tcp schemas/gschemas.compiled _build/schemas/\n\tmkdir -p _build/locale\n\tfor l in $(MSGSRC:.po=.mo) ; do \\\n\t\tlf=_build/locale/`basename $$l .mo`; \\\n\t\tmkdir -p $$lf; \\\n\t\tmkdir -p $$lf/LC_MESSAGES; \\\n\t\tcp $$l $$lf/LC_MESSAGES/dash-to-panel.mo; \\\n\tdone;\nifneq ($(and $(COMMIT),$(VERSION)),)\n\tsed -i 's/\"version\": [[:digit:]][[:digit:]]*/\"version\": $(VERSION),\\n\"commit\": \"$(COMMIT)\"/'  _build/metadata.json;\nelse ifneq ($(VERSION),)\n\tsed -i 's/\"version\": [[:digit:]][[:digit:]]*/\"version\": $(VERSION)/'  _build/metadata.json;\nendif\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.5390625,
          "content": "<p align=\"left\">\n  <img src=\"/media/design/svg/D2P_logo.svg\" width=\"620\"/>\n</p>\n<p align=\"left\">\n    <img src=\"/media/design/svg/GitHub_logo.svg\" width=\"120\"/>&nbsp;\n    <a href=\"https://extensions.gnome.org/extension/1160/dash-to-panel/\" style=\"margin-left: 20px\">\n        <img src=\"/media/design/svg/Gnome_logo.svg\" width=\"120px\"/>\n    </a>&nbsp;\n    <a href=\"https://www.paypal.com/donate/?hosted_button_id=5DCVELP7BSAVQ\">\n        <img src=\"https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif\" />\n    </a>\n</p>\n\n![](media/design/png/dtp-main-p2.png)\n\n### Introduction\n\nDash to Panel is an icon taskbar for Gnome Shell. This extension moves the dash into the gnome main panel so that the application launchers and system tray are combined into a single panel, similar to that found in KDE Plasma and Windows 7+. A separate dock is no longer needed for easy access to running and favorited applications. \n\nBeyond that, just about every aspect of the panel is fully customizable. From positioning and scaling panel elements to running indicators to multi-monitor display, to window previews and even intellihide, Dash to Panel has everything you need to make your workspace feel like home.\n\n### Features\n\n|Customizable appearance|\n|:-----:|\n|![screenshot](media/design/gif/customizable.gif)|\n|Hide & show panel elements and set their positions, sizes & colors|\n\n##\n\n<table>\n    <thead>\n        <tr>\n            <th colspan=2>Customizable running indicators</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td align=\"center\">Metro</td>\n            <td align=\"center\">Ciliora/Dashes</td>\n        </tr> \n        <tr>\n            <td align=\"center\"><img src=\"media/design/png/metro.png\"/></td>\n            <td align=\"center\"><img src=\"media/design/png/ciliora-dashes.png\"/></td>\n        </tr>\n        <tr>\n            <td align=\"center\">Ciliora</td>\n            <td align=\"center\">Squares/Segmented</td>\n        </tr> \n        <tr>\n            <td align=\"center\"><img src=\"media/design/png/ciliora.png\"/></td>\n            <td align=\"center\"><img src=\"media/design/png/squares-segments.png\"/></td>\n        </tr>\n        <tr>\n            <td align=\"center\">Dashes</td>\n            <td align=\"center\">Dots/Solid</td>\n        </tr> \n        <tr>\n            <td align=\"center\"><img src=\"media/design/png/dashes.png\"/></td>\n            <td align=\"center\"><img src=\"media/design/png/dots-solid.png\"/></td>\n        </tr>\n        <tr>\n            <td colspan=2 align=\"center\">Set position, style, weight & color of running indicators to easily and quickly identify focused and unfocused applications</td>\n        </tr>\n    </tbody>\n</table>\n\n##\n\n|Live Previews on Hover|\n|:-----:|\n|![screenshot](media/design/gif/previews.gif)|\n|Hover over the launcher icon for an open application to get a live window preview|\n\n##\n|Launch by Number|\n|:-----:|\n|![](media/design/png/indicators-num.png.png)|\n|Optionally launch your favorite applications via keyboard|\n\n##\n\n|Panel Intellihide|\n|:-----:|\n|![Intellihide](media/design/gif/Intellihide.gif)|\n|Hide and reveal the panel according to your set preferences|\n\n##\n|Additional Features|Feature Implemented|\n|:-----|:-----:|\n|Add \"Show Desktop\" button to panel|![](media/design/png/done.png)|\n|Isolate running apps by workspaces and/or monitors|![](media/design/png/done.png)|\n|Custom click behaviors (launch new window, cycle open windows, minimize, etc)|![](media/design/png/done.png)|\n|Integrate native Gnome appMenu into right-click secondary menu|![](media/design/png/done.png)|\n|Multi-monitor support|![](media/design/png/done.png)|\n|Dynamic transparency|![](media/design/png/done.png)|\n|Ungroup application windows|![](media/design/png/done.png)|\n|Export and import settings|![](media/design/png/done.png)|\n##\n\n### Installation\n\n**To install the most recent official release:\n[Visit Dash-to-Panel at GNOME Extensions](https://extensions.gnome.org/extension/1160/dash-to-panel/)**\n\nTo install a development version from source, please see the [Installation wiki page](https://github.com/home-sweet-gnome/dash-to-panel/wiki/Installation).\n\n## \n### FAQ\n\nHow do I customize the panel? [See the Wiki](https://github.com/home-sweet-gnome/dash-to-panel/wiki/Enable-and-Customize#customize-it)\n\nHow do I embed my bottom left notification drawer into the panel like a system tray? [Top Icons Plus](https://extensions.gnome.org/extension/2311/topicons-plus) or [(K)StatusNotifierItem/AppIndicator Support](https://extensions.gnome.org/extension/615/appindicator-support)\n\nHow do I add a traditional start menu? [Arc Menu](https://extensions.gnome.org/extension/3628/arcmenu/)\n\nHow do I disable the hot corner? [No Topleft Hot Corner](https://extensions.gnome.org/extension/118/no-topleft-hot-corner)\n\nHow do I move the notifications to somewhere other than the top center? [Notification Banner Reloaded](https://extensions.gnome.org/extension/4651/notification-banner-reloaded/)\n\nHow do I display Minimize & Maximize buttons? In the Tweak Tool application, turn on `Windows > Titlebar Buttons > Minimize & Maximize`.\n\nHow do I reset the extension to its default settings? `dconf reset -f /org/gnome/shell/extensions/dash-to-panel/`.\n\n## \n### Themes\nWhile this extension works well with most popular Gnome Shell themes, the following themes are known to have explicitly added custom styles for this extension:\n- [Ciliora Tertia](https://github.com/zagortenay333/ciliora-tertia-shell) / [Ciliora Secunda](https://github.com/zagortenay333/ciliora-secunda-shell)\n- [Plano](https://github.com/lassekongo83/plano-theme)\n\n\n## \n### Compatibility\n\nThis extension has been tested with Gnome 3.18+.\n\nThis extension manipulates the Gnome Main Panel, aka Top Bar. So, most other extensions which operate on the top bar should be compatible.\n\n##\n### Volunteers needed!\n\nThis extension could be even better with your help! Any items in the issue tracker labelled `help wanted` or `good first issue` are up for grabs. For more info, see the [Contributing wiki page](https://github.com/home-sweet-gnome/dash-to-panel/wiki/Contributing).\n\n## \n### Credits\n\nThis extension is developed and maintained by [@jderose9](https://github.com/jderose9) and [@charlesg99](https://github.com/charlesg99).\n\nSignificant portions of code in this extension were derived from [Dash-to-Dock](https://micheleg.github.io/dash-to-dock/index.html).\n\nAdditional credits: This extension leverages the work for [ZorinOS Taskbar](https://github.com/ZorinOS/zorin-taskbar) (used in [ZorinOS](https://zorinos.com/)) to show window previews and allow the dash from [Dash-to-Dock](https://micheleg.github.io/dash-to-dock/index.html) to be embedded in the Gnome main panel.\nCode to set anchor position taken from [Thoma5/gnome-shell-extension-bottompanel](https://github.com/Thoma5/gnome-shell-extension-bottompanel).\nPattern for moving panel contents based on [Frippery Move Clock](http://frippery.org/extensions/) by R M Yorston.\nIdeas for recursing child actors and assigning inline styles are based on code from the extension [StatusAreaHorizontalSpacing](https://bitbucket.org/mathematicalcoffee/status-area-horizontal-spacing-gnome-shell-extension).\n##\n\n#### Thanks to the following people for contributing via pull requests:\n\n- @franglais125 for launching apps by number (w/ overlay), bug fixes, and issue support\n- @LinxGem33 and @sbarrett322 for artwork, logos, screenshots and design effort\n- @dziku1337 for peek mode in window previews\n- @robrobinbin for configuring appMenu on/off in the panel\n- @MartinPL for toggling favorites on/off in panel\n- @jackwickham for thumbnail middle and right click actions\n- @abakkk for centering the taskbar icons in the panel, and animated taskbar hovering\n- @quasoft for changing of font weight of ungrouped application titles\n- @jordanribera for using icon's dominant color as running indicator color\n- @tper0700 for dynamically building context menu based on system capabilities\n- @levacic for configurable minimized application title font color\n- @l3nn4rt for toggling workspace switch popup\n- @hlechner for adjustable show desktop line color and window preview icon size\n- @ArtyomZorin for animated urgent icons\n- @jvpessoa10 for additional click window cycle options\n- @marksvc for assigning percent of display for panel length\n- @philippun1 for GNOME 40 support :rocket:\n- @HaselLoyance for toggle for notification counter badge\n- @rastersoft for Desktop Icons NG integration\n\n#### Bug Fixes: \n@imrvelj, @Teslator, @bil-elmoussaoui, @brandon-schumann, @sw9, @rockon999 , @lexruee, @3v1n0, @freeroot, @moqmar, @ArtyomZorin, @lkc0987, @saibotk, @vanillajonathan, @Zkdc, @leebickmtu, @l3nn4rt, @Melix19, @Aikatsui, @melix99, @kyrillzorin, @oneshadab, @CorvetteCole, @vantu5z, @spectreseven1138\n\n#### Documentation Improvements:\n@BoQsc, @zakkak, @dandv\n\n#### Translations: \n@frnogueira / @victorwpbastos / @vagkaefer (pt_BR), @zeten30 (cs), @franglais125 / @calotam / @oeramirez (es), @LaurentTreguier / @SolarLiner (fr), @elsieholmes (uk), @hosiet (zh\\_CN), @jonnius / @linuxr01 / @daPhipz (de), @urbalazs / @pappfer (hu), @crayxt (kk), @pkomur / @MartinPL / @alex4401 (pl), @AlexGluck / @GoodNike / @rjapolov / @vantu5z (ru), @sicklylife-jp / @ryonakano / @nexryai (ja), @oltulu / @TeknoMobil / @daenney (tr), @sbadux / @kowalski7cc / @l3nn4rt (it), @OriginCode / @pan93412 (zh\\_TW), @ojn (sv), @frandieguez (gl), @kuroehanako / @MarongHappy (ko)\n\n\n## \n### License & Terms ![](media/design/png/copyleft-16.png)\n\nDash to Panel is available under the terms of the GPL-v2 or later license See [`COPYING`](https://github.com/home-sweet-gnome/dash-to-panel/blob/master/COPYING) for details.\n\n![](https://img.shields.io/badge/Language-JavaScript-yellow.svg) ![](https://img.shields.io/badge/Licence-GPL--2.0-blue.svg)\n"
        },
        {
          "name": "appIcons.js",
          "type": "blob",
          "size": 72.6357421875,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Credits:\n * This file is based on code from the Dash to Dock extension by micheleg\n * and code from the Taskbar extension by Zorin OS\n * Some code was also adapted from the upstream Gnome Shell source code.\n */\n\n\nimport Clutter from 'gi://Clutter';\nimport GLib from 'gi://GLib';\nimport Gio from 'gi://Gio';\nimport Graphene from 'gi://Graphene';\nimport GObject from 'gi://GObject';\nimport Mtk from 'gi://Mtk';\nimport Shell from 'gi://Shell';\nimport St from 'gi://St';\n\nimport * as AppDisplay from 'resource:///org/gnome/shell/ui/appDisplay.js';\nimport * as AppMenu from 'resource:///org/gnome/shell/ui/appMenu.js';\nimport * as Dash from 'resource:///org/gnome/shell/ui/dash.js';\nimport * as DND from 'resource:///org/gnome/shell/ui/dnd.js';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as PopupMenu from 'resource:///org/gnome/shell/ui/popupMenu.js';\nimport * as Util from 'resource:///org/gnome/shell/misc/util.js';\nimport * as BoxPointer from 'resource:///org/gnome/shell/ui/boxpointer.js';\nimport {EventEmitter} from 'resource:///org/gnome/shell/misc/signals.js';\n\nimport * as Utils from './utils.js';\nimport * as PanelSettings from './panelSettings.js';\nimport * as Taskbar from './taskbar.js';\nimport * as Progress from './progress.js';\nimport {DTP_EXTENSION, SETTINGS, DESKTOPSETTINGS, TERMINALSETTINGS, EXTENSION_PATH} from './extension.js';\nimport {gettext as _, ngettext} from 'resource:///org/gnome/shell/extensions/extension.js';\n\n//timeout names\nconst T2 = 'mouseScrollTimeout';\nconst T3 = 'showDotsTimeout';\nconst T4 = 'overviewWindowDragEndTimeout';\nconst T5 = 'switchWorkspaceTimeout';\nconst T6 = 'displayProperIndicatorTimeout';\n\n//right padding defined for .overview-label in stylesheet.css\nconst TITLE_RIGHT_PADDING = 8;\nconst DOUBLE_CLICK_DELAY_MS = 450;\n\nlet LABEL_GAP = 5;\nlet MAX_INDICATORS = 4;\nexport const DEFAULT_PADDING_SIZE = 4;\n\nlet APPICON_STYLE = {\n    NORMAL: \"NORMAL\",\n    SYMBOLIC: \"SYMBOLIC\"\n}\n\nlet DOT_STYLE = {\n    DOTS: \"DOTS\",\n    SQUARES: \"SQUARES\",\n    DASHES: \"DASHES\",\n    SEGMENTED: \"SEGMENTED\",\n    CILIORA: \"CILIORA\",\n    METRO: \"METRO\",\n    SOLID: \"SOLID\"\n}\n\nlet DOT_POSITION = {\n    TOP: \"TOP\",\n    BOTTOM: \"BOTTOM\",\n    LEFT: 'LEFT',\n    RIGHT: 'RIGHT'\n}\n\nlet recentlyClickedAppLoopId = 0;\nlet recentlyClickedApp = null;\nlet recentlyClickedAppWindows = null;\nlet recentlyClickedAppIndex = 0;\nlet recentlyClickedAppMonitorIndex;\n\nlet tracker = Shell.WindowTracker.get_default();\n\n/**\n * Extend AppIcon\n *\n * - Apply a css class based on the number of windows of each application (#N);\n * - Draw a dot for each window of the application based on the default \"dot\" style which is hidden (#N);\n *   a class of the form \"running#N\" is applied to the AppWellIcon actor.\n *   like the original .running one.\n * - add a .focused style to the focused app\n * - Customize click actions.\n * - Update minimization animation target\n *\n */\n\nexport const TaskbarAppIcon = GObject.registerClass({\n}, class TaskbarAppIcon extends AppDisplay.AppIcon {\n\n    _init(appInfo, panel, iconParams, previewMenu, iconAnimator) {\n        this.dtpPanel = panel;\n        this._nWindows = 0;\n        this.window = appInfo.window;\n        this.isLauncher = appInfo.isLauncher;\n        this._previewMenu = previewMenu;\n        this.iconAnimator = iconAnimator;\n        this.lastClick = 0;\n\n        super._init(appInfo.app, iconParams);\n\n        this._timeoutsHandler = new Utils.TimeoutsHandler();\n\n        // Fix touchscreen issues before the listener is added by the parent constructor.\n        this._onTouchEvent = function(actor, event) {\n            if (event.type() == Clutter.EventType.TOUCH_BEGIN) {\n                // Open the popup menu on long press.\n                this._setPopupTimeout();\n            } else if (this._menuTimeoutId != 0 && (event.type() == Clutter.EventType.TOUCH_END || event.type() == Clutter.EventType.TOUCH_CANCEL)) {    \n                // Activate/launch the application.\n                this.activate(1);\n                this._removeMenuTimeout();\n            }\n            // Disable dragging via touch screen as it's buggy as hell. Not perfect for tablet users, but the alternative is way worse.\n            // Also, EVENT_PROPAGATE launches applications twice with this solution, so this.activate(1) above must only be called if there's already a window.\n            return Clutter.EVENT_STOP;\n        };\n        // Hack for missing TOUCH_END event.\n        this._onLeaveEvent = function(actor, event) {\n            this.fake_release();\n            if (this._menuTimeoutId != 0) this.activate(1); // Activate/launch the application if TOUCH_END didn't fire.\n            this._removeMenuTimeout();\n        };\n\n        \n        this._dot.set_width(0);\n        this._isGroupApps = SETTINGS.get_boolean('group-apps');\n        \n        this._container = new St.Widget({ style_class: 'dtp-container', layout_manager: new Clutter.BinLayout() });\n        this._dotsContainer = new St.Widget({ layout_manager: new Clutter.BinLayout() });\n        this._dtpIconContainer = new St.Widget({ layout_manager: new Clutter.BinLayout(), style: getIconContainerStyle(panel.checkIfVertical()) });\n\n        this.remove_child(this._iconContainer);\n        \n        this._dtpIconContainer.add_child(this._iconContainer);\n\n        if (appInfo.window) {\n            let box = new St.BoxLayout();\n\n            this._windowTitle = new St.Label({ \n                y_align: Clutter.ActorAlign.CENTER, \n                x_align: Clutter.ActorAlign.START, \n                style_class: 'overview-label' \n            });\n            \n            this._updateWindowTitle();\n            this._updateWindowTitleStyle();\n\n            this._scaleFactorChangedId = Utils.getStageTheme().connect('changed', () => this._updateWindowTitleStyle());\n\n            box.add_child(this._dtpIconContainer);\n            box.add_child(this._windowTitle);\n\n            this._dotsContainer.add_child(box);\n        } else {\n            this._dotsContainer.add_child(this._dtpIconContainer);\n        }\n\n        this._container.add_child(this._dotsContainer);\n        this.set_child(this._container);\n\n        if (panel.checkIfVertical()) {\n            this.set_width(panel.geom.w);\n        }\n\n        // Monitor windows-changes instead of app state.\n        // Keep using the same Id and function callback (that is extended)\n        if(this._stateChangedId > 0) {\n            this.app.disconnect(this._stateChangedId);\n            this._stateChangedId = 0;\n        }\n\n        this._onAnimateAppiconHoverChanged();\n        this._setAppIconPadding();\n        this._setAppIconStyle();\n        this._showDots();\n\n        this._focusWindowChangedId = global.display.connect('notify::focus-window', \n                                                            this._onFocusAppChanged.bind(this));\n\n        this._windowEnteredMonitorId = this._windowLeftMonitorId = 0;\n        this._stateChangedId = this.app.connect('windows-changed', this.onWindowsChanged.bind(this));\n\n        if (!this.window) {\n            if (SETTINGS.get_boolean('isolate-monitors')) {\n                this._windowEnteredMonitorId = Utils.DisplayWrapper.getScreen().connect('window-entered-monitor', this.onWindowEnteredOrLeft.bind(this));\n                this._windowLeftMonitorId = Utils.DisplayWrapper.getScreen().connect('window-left-monitor', this.onWindowEnteredOrLeft.bind(this));\n            }\n            \n            this._titleWindowChangeId = 0;\n            this._minimizedWindowChangeId = 0;\n        } else {\n            this._titleWindowChangeId = this.window.connect('notify::title', \n                                                this._updateWindowTitle.bind(this));\n\n            this._minimizedWindowChangeId = this.window.connect('notify::minimized',\n                                                this._updateWindowTitleStyle.bind(this));\n        }\n        \n        this._scrollEventId = this.connect('scroll-event', this._onMouseScroll.bind(this));\n\n        this._overviewWindowDragEndId = Main.overview.connect('window-drag-end',\n                                                this._onOverviewWindowDragEnd.bind(this));\n\n        this._switchWorkspaceId = global.window_manager.connect('switch-workspace',\n                                                this._onSwitchWorkspace.bind(this));\n\n        this._hoverChangeId = this.connect('notify::hover', () => this._onAppIconHoverChanged());\n        \n        this._dtpSettingsSignalIds = [\n            SETTINGS.connect('changed::animate-appicon-hover', this._onAnimateAppiconHoverChanged.bind(this)),\n            SETTINGS.connect('changed::dot-position', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-size', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-style-focused', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-style-unfocused', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-dominant', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-override', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-1', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-2', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-3', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-4', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-unfocused-different', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-unfocused-1', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-unfocused-2', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-unfocused-3', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::dot-color-unfocused-4', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::focus-highlight', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::focus-highlight-dominant', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::focus-highlight-color', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::focus-highlight-opacity', this._settingsChangeRefresh.bind(this)),\n            SETTINGS.connect('changed::group-apps-label-font-size', this._updateWindowTitleStyle.bind(this)),\n            SETTINGS.connect('changed::group-apps-label-font-weight', this._updateWindowTitleStyle.bind(this)),\n            SETTINGS.connect('changed::group-apps-label-font-color', this._updateWindowTitleStyle.bind(this)),\n            SETTINGS.connect('changed::group-apps-label-font-color-minimized', this._updateWindowTitleStyle.bind(this)),\n            SETTINGS.connect('changed::group-apps-label-max-width', this._updateWindowTitleStyle.bind(this)),\n            SETTINGS.connect('changed::group-apps-use-fixed-width', this._updateWindowTitleStyle.bind(this)),\n            SETTINGS.connect('changed::group-apps-underline-unfocused', this._settingsChangeRefresh.bind(this))\n        ]\n\n        this._progressIndicator = new Progress.ProgressIndicator(this, panel.progressManager);\n\n        this._numberOverlay();\n    }\n\n    getDragActor() {\n        return this.app.create_icon_texture(this.dtpPanel.taskbar.iconSize);\n    }\n\n    // Used by TaskbarItemContainer to animate appIcons on hover\n    getCloneButton() {\n        // The source of the clone is this._container,\n        // using this.actor directly would break DnD style.\n        let clone = new Clutter.Clone({\n            source: this.child,\n            x: this.child.x, y: this.child.y,\n            width: this.child.width, height: this.child.height,\n            pivot_point: new Graphene.Point({ x: 0.5, y: 0.5 }),\n            opacity: 255,\n            reactive: false,\n            x_align: Clutter.ActorAlign.CENTER, y_align: Clutter.ActorAlign.CENTER,\n        });\n\n        clone._delegate = this._delegate;\n\n        // \"clone\" of this.actor\n        return new St.Button({\n            child: clone,\n            x: this.x, y: this.y,\n            width: this.width, height: this.height,\n            reactive: false,\n        });\n    }\n\n    shouldShowTooltip() {\n        if (!SETTINGS.get_boolean('show-tooltip') || \n            (!this.isLauncher && SETTINGS.get_boolean(\"show-window-previews\") &&\n             this.getAppIconInterestingWindows().length > 0)) {\n            return false;\n        } else {\n            return this.hover && !this.window && \n                   (!this._menu || !this._menu.isOpen) && \n                   (this._previewMenu.getCurrentAppIcon() !== this);\n        }\n    }\n\n    _onAppIconHoverChanged() {\n        if (!SETTINGS.get_boolean('show-window-previews') || \n            (!this.window && !this._nWindows)) {\n            return;\n        }\n\n        if (this.hover) {\n            this._previewMenu.requestOpen(this);\n        } else {\n            this._previewMenu.requestClose();\n        }\n    }\n\n    _onDestroy() {\n        super._onDestroy();\n\n        this._timeoutsHandler.destroy();\n\n        this._previewMenu.close(true);\n\n        // Disconect global signals\n        if (this._stateChangedId > 0) {\n            this.app.disconnect(this._stateChangedId);\n            this._stateChangedId = 0;\n        }\n        \n        if(this._overviewWindowDragEndId)\n            Main.overview.disconnect(this._overviewWindowDragEndId);\n\n        if(this._focusWindowChangedId)\n            global.display.disconnect(this._focusWindowChangedId);\n\n        if(this._titleWindowChangeId)\n            this.window.disconnect(this._titleWindowChangeId);\n\n        if(this._minimizedWindowChangeId)\n            this.window.disconnect(this._minimizedWindowChangeId);\n\n        if (this._windowEnteredMonitorId) {\n            Utils.DisplayWrapper.getScreen().disconnect(this._windowEnteredMonitorId);\n            Utils.DisplayWrapper.getScreen().disconnect(this._windowLeftMonitorId);\n        }\n\n        if(this._switchWorkspaceId)\n            global.window_manager.disconnect(this._switchWorkspaceId);\n\n        if(this._scaleFactorChangedId)\n            Utils.getStageTheme().disconnect(this._scaleFactorChangedId);\n\n        if (this._hoverChangeId) {\n            this.disconnect(this._hoverChangeId);\n        }\n\n        if (this._scrollEventId) {\n            this.disconnect(this._scrollEventId);\n        }\n\n        for (let i = 0; i < this._dtpSettingsSignalIds.length; ++i) {\n            SETTINGS.disconnect(this._dtpSettingsSignalIds[i]);\n        }\n    }\n\n    onWindowsChanged() {\n        this._updateWindows();\n        this.updateIcon();\n\n        if (this._isGroupApps)\n            this._setIconStyle();\n    }\n\n    onWindowEnteredOrLeft(display, number, metaWindow) {\n        if (number > 0 && tracker.get_window_app(metaWindow) == this.app) {\n            this._updateWindows();\n            this._displayProperIndicator();\n        }\n    }\n\n    updateTitleStyle() {\n        this._updateWindowTitleStyle();\n    }\n\n    // Update indicator and target for minimization animation\n    updateIcon() {\n\n        // If (for unknown reason) the actor is not on the stage the reported size\n        // and position are random values, which might exceeds the integer range\n        // resulting in an error when assigned to the a rect. This is a more like\n        // a workaround to prevent flooding the system with errors.\n        if (this.get_stage() == null)\n            return;\n\n        let rect = new Mtk.Rectangle();\n\n        [rect.x, rect.y] = this.get_transformed_position();\n        [rect.width, rect.height] = this.get_transformed_size();\n\n        let windows = this.window ? [this.window] : this.getAppIconInterestingWindows(true);\n        windows.forEach(function(w) {\n            w.set_icon_geometry(rect);\n        });\n    }\n\n    _onAnimateAppiconHoverChanged() {\n        if (SETTINGS.get_boolean('animate-appicon-hover')) {\n            this._container.add_style_class_name('animate-appicon-hover');\n\n            // Workaround to prevent scaled icon from being ugly when it is animated on hover.\n            // It increases the \"resolution\" of the icon without changing the icon size.\n            this.icon.createIcon = (iconSize) => this.app.create_icon_texture(2 * iconSize);\n            this._iconIconBinActorAddedId = this.icon._iconBin.connect('child-added', () => {\n                let size = this.icon.iconSize * Utils.getScaleFactor()\n                \n                if (this.icon._iconBin.child.mapped) {\n                    this.icon._iconBin.child.set_size(size, size);\n                } else {\n                    let iconMappedId = this.icon._iconBin.child.connect('notify::mapped', () => {\n                        this.icon._iconBin.child.set_size(size, size);\n                        this.icon._iconBin.child.disconnect(iconMappedId);\n                    });\n                }\n            });\n            if (this.icon._iconBin.child)\n                this.icon._createIconTexture(this.icon.iconSize);\n        } else {\n            this._container.remove_style_class_name('animate-appicon-hover');\n\n            if (this._iconIconBinActorAddedId) {\n                this.icon._iconBin.disconnect(this._iconIconBinActorAddedId);\n                this._iconIconBinActorAddedId = 0;\n                this.icon.createIcon = this._createIcon.bind(this);\n            }\n        }\n    }\n\n    _onMouseScroll(actor, event) {\n        let scrollAction = SETTINGS.get_string('scroll-icon-action');\n        \n        if (scrollAction === 'PASS_THROUGH') {\n            return this.dtpPanel._onPanelMouseScroll(actor, event);\n        } else if (scrollAction === 'NOTHING' || (!this.window && !this._nWindows)) {\n            return;\n        }\n\n        let direction = Utils.getMouseScrollDirection(event);\n\n        if (direction && !this._timeoutsHandler.getId(T2)) {\n            this._timeoutsHandler.add([T2, SETTINGS.get_int('scroll-icon-delay'), () => {}]);\n\n            let windows = this.getAppIconInterestingWindows();\n\n            windows.sort(Taskbar.sortWindowsCompareFunction);\n            Utils.activateSiblingWindow(windows, direction, this.window);\n        }\n    }\n    \n    _showDots() {\n        // Just update style if dots already exist\n        if (this._focusedDots && this._unfocusedDots) {\n            this._updateWindows();\n            return;\n        }\n\n        if (!this._isGroupApps) {\n            this._focusedDots = new St.Widget({ \n                layout_manager: new Clutter.BinLayout(),\n                x_expand: true, y_expand: true,\n                visible: false\n            });\n\n            let mappedId = this.connect('notify::mapped', () => {\n                this._displayProperIndicator();\n                this.disconnect(mappedId);\n            });\n        } else {\n            this._focusedDots = new St.DrawingArea(), \n            this._unfocusedDots = new St.DrawingArea();\n            \n            this._focusedDots.connect('repaint', () => {\n                if (!this._dashItemContainer.animatingOut)\n                    // don't draw and trigger more animations if the icon is in the middle of\n                    // being removed from the panel\n                    this._drawRunningIndicator(this._focusedDots, SETTINGS.get_string('dot-style-focused'), true);\n            });\n            \n            this._unfocusedDots.connect('repaint', () => {\n                if (!this._dashItemContainer.animatingOut)\n                    this._drawRunningIndicator(this._unfocusedDots, SETTINGS.get_string('dot-style-unfocused'), false);\n            });\n                \n            this._dotsContainer.add_child(this._unfocusedDots);\n    \n            this._updateWindows();\n\n            this._timeoutsHandler.add([T3, 0, () => {\n                this._resetDots();\n                this._displayProperIndicator();\n            }]);\n        }\n\n        this._dotsContainer.add_child(this._focusedDots);\n    }\n\n    _resetDots() {\n        let position = SETTINGS.get_string('dot-position');\n        let isHorizontalDots = position == DOT_POSITION.TOP || position == DOT_POSITION.BOTTOM;\n        let sizeProp = isHorizontalDots ? 'width' : 'height';\n        let focusedDotStyle = SETTINGS.get_string('dot-style-focused');\n        let unfocusedDotStyle = SETTINGS.get_string('dot-style-unfocused');\n        \n        this._focusedIsWide = this._isWideDotStyle(focusedDotStyle);\n        this._unfocusedIsWide = this._isWideDotStyle(unfocusedDotStyle);\n\n        [, this._containerSize] = this._container[`get_preferred_${sizeProp}`](-1);\n\n        [this._focusedDots, this._unfocusedDots].forEach(d => {\n            d.set_size(-1, -1);\n            d.x_expand = d.y_expand = false;\n\n            d[sizeProp] = 1;\n            d[(isHorizontalDots ? 'y' : 'x') + '_expand'] = true;\n        });\n    }\n\n    _settingsChangeRefresh() {\n        if (this._isGroupApps) {\n            this._updateWindows();\n            this._resetDots();\n            this._focusedDots.queue_repaint();\n            this._unfocusedDots.queue_repaint();\n        }\n\n        this._displayProperIndicator();\n    }\n\n    _updateWindowTitleStyle() {\n        if (this._windowTitle) {\n            let useFixedWidth = SETTINGS.get_boolean('group-apps-use-fixed-width');\n            let fontWeight = SETTINGS.get_string('group-apps-label-font-weight');\n            let fontScale = DESKTOPSETTINGS.get_double('text-scaling-factor');\n            let fontColor = this.window.minimized ?\n                            SETTINGS.get_string('group-apps-label-font-color-minimized') :\n                            SETTINGS.get_string('group-apps-label-font-color');\n            let scaleFactor = Utils.getScaleFactor();\n            let maxLabelWidth = SETTINGS.get_int('group-apps-label-max-width') * scaleFactor;\n            let variableWidth = !useFixedWidth || this.dtpPanel.checkIfVertical() || this.dtpPanel.taskbar.fullScrollView;\n\n            this._windowTitle[(maxLabelWidth > 0 ? 'show' : 'hide')]();\n            this._windowTitle.set_width(variableWidth ? -1 : maxLabelWidth + TITLE_RIGHT_PADDING * scaleFactor);\n\n            this._windowTitle.clutter_text.natural_width = useFixedWidth ? maxLabelWidth : 0;\n            this._windowTitle.clutter_text.natural_width_set = useFixedWidth;\n\n            this._windowTitle.set_style('font-size: ' + SETTINGS.get_int('group-apps-label-font-size') * fontScale + 'px;' +\n                                        'font-weight: ' + fontWeight + ';' +\n                                        (useFixedWidth ? '' : 'max-width: ' + maxLabelWidth + 'px;') + \n                                        'color: ' + fontColor);\n        }\n    }\n\n    _updateWindowTitle() {\n        if (this._windowTitle.text != this.window.title) {\n            this._windowTitle.text = (this.window.title ? this.window.title : this.app.get_name()).replace(/\\r?\\n|\\r/g, '').trim();\n            \n            if (this._focusedDots) {\n                this._displayProperIndicator();\n            }\n        }\n    }\n\n    _setIconStyle(isFocused) {\n        let inlineStyle = 'margin: 0;';\n\n        if(SETTINGS.get_boolean('focus-highlight') && \n           this._checkIfFocusedApp() && !this.isLauncher &&  \n           (!this.window || isFocused) && !this._isThemeProvidingIndicator() && this._checkIfMonitorHasFocus()) {\n            let focusedDotStyle = SETTINGS.get_string('dot-style-focused');\n            let pos = SETTINGS.get_string('dot-position');\n            let highlightMargin = this._focusedIsWide ? SETTINGS.get_int('dot-size') : 0;\n\n            if(!this.window) {\n                let containerWidth = this._dtpIconContainer.get_width() / Utils.getScaleFactor();\n                let backgroundSize = containerWidth + \"px \" + \n                                     (containerWidth - (pos == DOT_POSITION.BOTTOM ? highlightMargin : 0)) + \"px;\";\n\n                if (focusedDotStyle == DOT_STYLE.CILIORA || focusedDotStyle == DOT_STYLE.SEGMENTED)\n                    highlightMargin += 1;\n\n                if (this._nWindows > 1 && focusedDotStyle == DOT_STYLE.METRO) {\n                    let bgSvg = '/img/highlight_stacked_bg';\n\n                    if (pos == DOT_POSITION.LEFT || pos == DOT_POSITION.RIGHT) {\n                        bgSvg += (this.dtpPanel.checkIfVertical() ? '_2' : '_3');\n                    }\n\n                    inlineStyle += \"background-image: url('\" + EXTENSION_PATH + bgSvg + \".svg');\" + \n                                   \"background-position: 0 \" + (pos == DOT_POSITION.TOP ? highlightMargin : 0) + \"px;\" +\n                                   \"background-size: \" + backgroundSize;\n                }\n            }\n\n            let highlightColor = this._getFocusHighlightColor();\n            inlineStyle += \"background-color: \" + cssHexTocssRgba(highlightColor, SETTINGS.get_int('focus-highlight-opacity') * 0.01);\n        }\n        \n        if(this._dotsContainer.get_style() != inlineStyle) {\n            this._dotsContainer.set_style(inlineStyle);\n        }\n    }\n\n    _checkIfFocusedApp() {\n        return tracker.focus_app == this.app;\n    }\n\n    _checkIfMonitorHasFocus() {\n        return global.display.focus_window && \n               (!SETTINGS.get_boolean('multi-monitors') || // only check same monitor index if multi window is enabled.\n                !SETTINGS.get_boolean('isolate-monitors') || \n                global.display.focus_window.get_monitor() === this.dtpPanel.monitor.index);\n    }\n\n    _setAppIconPadding() {\n        let padding = getIconPadding(this.dtpPanel.monitor.index);\n        let margin = SETTINGS.get_int('appicon-margin');\n\n        this.set_style('padding:' + (this.dtpPanel.checkIfVertical() ? margin + 'px 0' : '0 ' + margin + 'px;'));\n        this._iconContainer.set_style('padding: ' + padding + 'px;');\n    }\n\n    _setAppIconStyle() {\n        let symbolic_icon_style_name = 'symbolic-icon-style';\n        if (SETTINGS.get_string('appicon-style') === APPICON_STYLE.SYMBOLIC) {\n            this.add_style_class_name(symbolic_icon_style_name);\n        } else {\n            this.remove_style_class_name(symbolic_icon_style_name);\n        }\n    }\n\n    popupMenu() {\n        this._removeMenuTimeout();\n        this.fake_release();\n\n        if (!this._menu) {\n            this._menu = new TaskbarSecondaryMenu(this, this.dtpPanel.geom.position);\n            this._menu.setApp(this.app);\n            this._menu.connect('open-state-changed', (menu, isPoppedUp) => {\n                if (!isPoppedUp)\n                    this._onMenuPoppedDown();\n                else\n                    this._previewMenu.close(true);\n            });\n            let id = Main.overview.connect('hiding', () => {\n                this._menu.close();\n            });\n            this.connect('destroy', () => {\n                Main.overview.disconnect(id);\n            });\n\n            // We want to keep the item hovered while the menu is up\n            this._menu.blockSourceEvents = true;\n\n            Main.uiGroup.add_child(this._menu.actor);\n            this._menuManager.addMenu(this._menu);\n        }\n        this._menu.updateQuitText();\n\n        this.emit('menu-state-changed', true);\n\n        this.set_hover(true);\n        this._menu.open(BoxPointer.PopupAnimation.FULL);\n        this._menuManager.ignoreRelease();\n        this.emit('sync-tooltip');\n\n        return false;\n    }\n\n    _onFocusAppChanged(windowTracker) {\n        this._displayProperIndicator();\n    }\n\n    _onOverviewWindowDragEnd(windowTracker) {\n        this._timeoutsHandler.add([T4, 0, () => {\n            if (SETTINGS.get_boolean('isolate-workspaces'))\n                this._updateWindows()\n\n            this._displayProperIndicator()\n        }]);\n    }\n\n    _onSwitchWorkspace(windowTracker) {\n        if (this._isGroupApps) {\n            this._timeoutsHandler.add([T5, 0, () => this._displayProperIndicator()]);\n        } else {\n            this._displayProperIndicator();\n        }\n    }\n\n    _displayProperIndicator() {\n        let isFocused = this._isFocusedWindow();\n        let position = SETTINGS.get_string('dot-position');\n        let isHorizontalDots = position == DOT_POSITION.TOP || position == DOT_POSITION.BOTTOM;\n\n        this._setIconStyle(isFocused);\n\n        if(!this._isGroupApps) {\n            if (this.window && (SETTINGS.get_boolean('group-apps-underline-unfocused') || isFocused)) {\n                let align = Clutter.ActorAlign[position == DOT_POSITION.TOP || position == DOT_POSITION.LEFT ? 'START' : 'END'];\n                \n                this._focusedDots.set_size(0, 0);\n                this._focusedDots[isHorizontalDots ? 'height' : 'width'] = this._getRunningIndicatorSize();\n\n                this._focusedDots.y_align = this._focusedDots.x_align = Clutter.ActorAlign.FILL;\n                this._focusedDots[(isHorizontalDots ? 'y' : 'x') + '_align'] = align;\n                this._focusedDots.background_color = this._getRunningIndicatorColor(isFocused);\n                this._focusedDots.show();\n            } else if (this._focusedDots.visible) {\n                this._focusedDots.hide();\n            }\n        } else {\n            let sizeProp = isHorizontalDots ? 'width' : 'height';\n            let newFocusedDotsSize = 0;\n            let newFocusedDotsOpacity = 0;\n            let newUnfocusedDotsSize = 0;\n            let newUnfocusedDotsOpacity = 0;\n            \n            isFocused = this._checkIfFocusedApp() && this._checkIfMonitorHasFocus();\n\n            this._timeoutsHandler.add([T6, 0, () => {\n                if(isFocused) \n                    this.add_style_class_name('focused');\n                else\n                    this.remove_style_class_name('focused');\n            }]);\n\n            if(this._focusedIsWide) {\n                newFocusedDotsSize = (isFocused && this._nWindows > 0) ? this._containerSize : 0;\n                newFocusedDotsOpacity = 255;\n            } else {\n                newFocusedDotsSize = this._containerSize;\n                newFocusedDotsOpacity = (isFocused && this._nWindows > 0) ? 255 : 0;\n            }\n    \n            if(this._unfocusedIsWide) {\n                newUnfocusedDotsSize = (!isFocused && this._nWindows > 0) ? this._containerSize : 0;\n                newUnfocusedDotsOpacity = 255;\n            } else {\n                newUnfocusedDotsSize = this._containerSize;\n                newUnfocusedDotsOpacity = (!isFocused && this._nWindows > 0) ? 255 : 0;\n            }\n    \n            // Only animate if...\n            // animation is enabled in settings\n            // AND (going from a wide style to a narrow style indicator or vice-versa\n            // OR going from an open app to a closed app or vice versa)\n            let animate = SETTINGS.get_boolean('animate-app-switch') &&\n                         ((this._focusedIsWide != this._unfocusedIsWide) ||\n                          (this._focusedDots[sizeProp] != newUnfocusedDotsSize || this._unfocusedDots[sizeProp] != newFocusedDotsSize))\n            let duration = animate ? Taskbar.DASH_ANIMATION_TIME : 0.001;\n\n            this._animateDotDisplay(this._focusedDots, newFocusedDotsSize, this._unfocusedDots, newUnfocusedDotsOpacity, sizeProp, duration);\n            this._animateDotDisplay(this._unfocusedDots, newUnfocusedDotsSize, this._focusedDots, newFocusedDotsOpacity, sizeProp, duration);\n        }\n    }\n\n    _animateDotDisplay(dots, newSize, otherDots, newOtherOpacity, sizeProp, duration) {\n        Utils.stopAnimations(dots)\n\n        let tweenOpts = { \n            time: duration,\n            transition: 'easeInOutCubic',\n            onComplete: () => { \n                if(newOtherOpacity > 0)\n                    otherDots.opacity = newOtherOpacity;\n            }\n        };\n\n        if(newOtherOpacity == 0)\n            otherDots.opacity = newOtherOpacity;\n\n        tweenOpts[sizeProp] = newSize;\n\n        Utils.animate(dots, tweenOpts);\n    }\n\n    _isFocusedWindow() {\n        let focusedWindow = global.display.focus_window;\n        \n        while (focusedWindow) {\n            if (focusedWindow == this.window) {\n                return true;\n            }\n\n            focusedWindow = focusedWindow.get_transient_for();\n        }\n\n        return false;\n    }\n\n    _isWideDotStyle(dotStyle) {\n        return dotStyle == DOT_STYLE.SEGMENTED || \n            dotStyle == DOT_STYLE.CILIORA || \n            dotStyle == DOT_STYLE.METRO || \n            dotStyle == DOT_STYLE.SOLID;\n    }\n\n    _isThemeProvidingIndicator() {\n        // This is an attempt to determine if the theme is providing their own\n        // running indicator by way of a border image on the icon, for example in\n        // the theme Ciliora\n        return (this.icon.get_stage() && \n                this.icon.get_theme_node().get_border_image());\n    }\n\n    activate(button, modifiers, handleAsGrouped) {\n        let event = Clutter.get_current_event();\n\n        modifiers = event ? event.get_state() : modifiers || 0;\n\n        // Only consider SHIFT and CONTROL as modifiers (exclude SUPER, CAPS-LOCK, etc.)\n        modifiers = modifiers & (Clutter.ModifierType.SHIFT_MASK | Clutter.ModifierType.CONTROL_MASK);\n\n        let ctrlPressed = modifiers & Clutter.ModifierType.CONTROL_MASK\n\n        if (ctrlPressed) {\n            // CTRL-click or hotkey with ctrl\n            return this._launchNewInstance(true);\n        }\n\n        // We check what type of click we have and if the modifier SHIFT is\n        // being used. We then define what buttonAction should be for this\n        // event.\n        let buttonAction = 0;\n        let doubleClick;\n\n        if (button && button == 2 ) {\n            if (modifiers & Clutter.ModifierType.SHIFT_MASK)\n                buttonAction = SETTINGS.get_string('shift-middle-click-action');\n            else\n                buttonAction = SETTINGS.get_string('middle-click-action');\n        }\n        // fixed issue #1676 by checking for button 0 or 1 to also handle touchscreen\n        // input, probably not the proper fix as i'm not aware button 0 should exist\n        // but from using this fix for months it seems to not create any issues\n        else if (button === 0 || button === 1) {\n            let now = global.get_current_time()\n\n            doubleClick = now - this.lastClick < DOUBLE_CLICK_DELAY_MS\n            this.lastClick = now\n\n            if (modifiers & Clutter.ModifierType.SHIFT_MASK)\n                buttonAction = SETTINGS.get_string('shift-click-action');\n            else\n                buttonAction = SETTINGS.get_string('click-action');\n        }\n\n        let closePreview = () => this._previewMenu.close(SETTINGS.get_boolean('window-preview-hide-immediate-click'));\n        let appCount = this.getAppIconInterestingWindows().length;\n        let previewedAppIcon = this._previewMenu.getCurrentAppIcon();\n\n        if (this.window || buttonAction != 'TOGGLE-SHOWPREVIEW')\n            closePreview()\n\n        // We check if the app is running, and that the # of windows is > 0 in\n        // case we use workspace isolation,\n        let appIsRunning = this.app.state == Shell.AppState.RUNNING && appCount > 0;\n\n        // We customize the action only when the application is already running\n        if (appIsRunning && !this.isLauncher) {\n            if (this.window && !handleAsGrouped) {\n                //ungrouped applications behaviors\n                switch (buttonAction) {\n                    case 'RAISE': case 'CYCLE': case 'CYCLE-MIN': case 'MINIMIZE': case 'TOGGLE-SHOWPREVIEW': case 'TOGGLE-CYCLE':\n                        if (!Main.overview._shown && \n                            (buttonAction == 'MINIMIZE' || buttonAction == 'TOGGLE-SHOWPREVIEW' || buttonAction == 'TOGGLE-CYCLE' || buttonAction == 'CYCLE-MIN') && \n                            (this._isFocusedWindow() || (buttonAction == 'MINIMIZE' && (button == 2 || modifiers & Clutter.ModifierType.SHIFT_MASK)))) {\n                                this.window.minimize();\n                        } else {\n                            Main.activateWindow(this.window);\n                        }\n                        \n                        break;\n        \n                    case \"LAUNCH\":\n                        this._launchNewInstance();\n                        break;\n\n                    case \"QUIT\":\n                        this.window.delete(global.get_current_time());\n                        break; \n                }\n            } else {\n                //grouped application behaviors\n                let monitor = this.dtpPanel.monitor;\n                let appHasFocus = this._checkIfFocusedApp() && this._checkIfMonitorHasFocus();\n\n                switch (buttonAction) {\n                    case \"RAISE\":\n                        activateAllWindows(this.app, monitor);\n                        break;\n        \n                    case \"LAUNCH\":\n                        this._launchNewInstance();\n                        break;\n        \n                    case \"MINIMIZE\":\n                        // In overview just activate the app, unless the acion is explicitely\n                        // requested with a keyboard modifier\n                        if (!Main.overview._shown || modifiers){\n                            // If we have button=2 or a modifier, allow minimization even if\n                            // the app is not focused\n                            if (appHasFocus || button == 2 || modifiers & Clutter.ModifierType.SHIFT_MASK) {\n                                // minimize all windows on double click and always in the case of primary click without\n                                // additional modifiers\n                                let all_windows = (button == 1 && ! modifiers) || doubleClick;\n                                minimizeWindow(this.app, all_windows, monitor);\n                            }\n                            else\n                                activateAllWindows(this.app, monitor);\n                        }\n                        else\n                            this.app.activate();\n                        break;\n        \n                    case \"CYCLE\":\n                        if (!Main.overview._shown){\n                            if (appHasFocus) \n                                cycleThroughWindows(this.app, false, false, monitor);\n                            else {\n                                activateFirstWindow(this.app, monitor);\n                            }\n                        }\n                        else\n                            this.app.activate();\n                        break;\n                    case \"CYCLE-MIN\":\n                        if (!Main.overview._shown){\n                            if (appHasFocus || (recentlyClickedApp == this.app && recentlyClickedAppWindows[recentlyClickedAppIndex % recentlyClickedAppWindows.length] == \"MINIMIZE\")) \n                                cycleThroughWindows(this.app, false, true, monitor);\n                            else {\n                                activateFirstWindow(this.app, monitor);\n                            }\n                        }\n                        else\n                            this.app.activate();\n                        break;\n                    case \"TOGGLE-SHOWPREVIEW\":\n                        if (!Main.overview._shown) {\n                            if (appCount == 1) {\n                                closePreview()\n\n                                if (appHasFocus)\n                                    minimizeWindow(this.app, false, monitor);\n                                else\n                                    activateFirstWindow(this.app, monitor);\n                            } else {\n                                if (doubleClick) {\n                                    // minimize all windows if double clicked\n                                    closePreview()\n                                    minimizeWindow(this.app, true, monitor);\n                                } else if (previewedAppIcon != this) {\n                                    this._previewMenu.open(this);\n                                } \n    \n                                this.emit('sync-tooltip');\n                            } \n                        }\n                        else\n                            this.app.activate();\n                        break;\n                    case \"TOGGLE-CYCLE\":\n                        if (!Main.overview._shown) {\n                            if (appCount == 1) {\n                                if (appHasFocus)\n                                    minimizeWindow(this.app, false, monitor);\n                                else\n                                    activateFirstWindow(this.app, monitor);\n                            } else {\n                                cycleThroughWindows(this.app, false, false, monitor);\n                            } \n                        }\n                        else\n                            this.app.activate();\n                        break;\n                    case \"QUIT\":\n                        closeAllWindows(this.app, monitor);\n                        break;\n                }\n            }\n        }\n        else {\n            this._launchNewInstance();\n        }\n\n        global.display.emit('grab-op-begin', null, null);\n        Main.overview.hide();\n    }\n\n    _launchNewInstance(ctrlPressed) {\n        let maybeAnimate = () => SETTINGS.get_boolean('animate-window-launch') && this.animateLaunch()\n\n        if ((ctrlPressed || this.app.state == Shell.AppState.RUNNING) && \n            this.app.can_open_new_window()) {\n            maybeAnimate();\n            this.app.open_new_window(-1);\n        } else {\n            let windows = this.window ? [this.window] : this.app.get_windows();\n\n            if (windows.length) {\n                Main.activateWindow(windows[0]);\n            } else {\n                maybeAnimate();\n                this.app.activate();\n            }\n        }\n    }\n\n    _updateWindows() {\n        let windows = [this.window];\n        \n        if (!this.window) {\n            windows = this.getAppIconInterestingWindows();\n        \n            this._nWindows = windows.length;\n    \n            for (let i = 1; i <= MAX_INDICATORS; i++){\n                let className = 'running'+i;\n                if(i != this._nWindows)\n                    this.remove_style_class_name(className);\n                else\n                    this.add_style_class_name(className);\n            }\n        }\n\n        this._previewMenu.update(this, windows);\n    }\n\n    _getRunningIndicatorCount() {\n        return Math.min(this._nWindows, MAX_INDICATORS);\n    }\n\n    _getRunningIndicatorSize() {\n        return SETTINGS.get_int('dot-size') * Utils.getScaleFactor();\n    }\n\n    _getRunningIndicatorColor(isFocused) {\n        let color;\n        const fallbackColor = new Utils.ColorUtils.Color({ red: 82, green: 148, blue: 226, alpha: 255 });\n\n        if (SETTINGS.get_boolean('dot-color-dominant')) {\n            let dce = new Utils.DominantColorExtractor(this.app);\n            let palette = dce._getColorPalette();\n            if (palette) {\n                color = Utils.ColorUtils.color_from_string(palette.original)[1];\n            } else { // unable to determine color, fall back to theme\n                let themeNode = this._dot.get_theme_node();\n                color = themeNode.get_background_color();\n\n                // theme didn't provide one, use a default\n                if(color.alpha == 0) color = fallbackColor;\n            }\n        } else if(SETTINGS.get_boolean('dot-color-override')) {\n            let dotColorSettingPrefix = 'dot-color-';\n            \n            if(!isFocused && SETTINGS.get_boolean('dot-color-unfocused-different'))\n                dotColorSettingPrefix = 'dot-color-unfocused-';\n\n            color = Utils.ColorUtils.color_from_string(SETTINGS.get_string(dotColorSettingPrefix + (this._getRunningIndicatorCount() || 1) ))[1];\n        } else {\n            // Re-use the style - background color, and border width and color -\n            // of the default dot\n            let themeNode = this._dot.get_theme_node();\n            color = themeNode.get_background_color();\n\n            // theme didn't provide one, use a default\n            if(color.alpha == 0) color = fallbackColor;\n        }\n\n        return color;\n    }\n\n    _getFocusHighlightColor() {\n        if (SETTINGS.get_boolean('focus-highlight-dominant')) {\n            let dce = new Utils.DominantColorExtractor(this.app);\n            let palette = dce._getColorPalette();\n            if (palette) return palette.original;\n        }\n        return SETTINGS.get_string('focus-highlight-color');\n    }\n\n    _drawRunningIndicator(area, type, isFocused) {\n        let n = this._getRunningIndicatorCount();\n\n        if (!n) {\n            return;\n        }\n\n        let position = SETTINGS.get_string('dot-position');\n        let isHorizontalDots = position == DOT_POSITION.TOP || position == DOT_POSITION.BOTTOM;\n        let bodyColor = this._getRunningIndicatorColor(isFocused);\n        let [areaWidth, areaHeight] = area.get_surface_size();\n        let cr = area.get_context();\n        let size = this._getRunningIndicatorSize();\n\n        let areaSize = areaWidth;\n        let startX = 0;\n        let startY = 0;\n\n        if (isHorizontalDots) {\n            if (position == DOT_POSITION.BOTTOM) {\n                startY = areaHeight - size;\n            }\n        } else {\n            areaSize = areaHeight;\n\n            if (position == DOT_POSITION.RIGHT) {\n                startX = areaWidth - size;\n            }\n        }\n\n        if (type == DOT_STYLE.SOLID || type == DOT_STYLE.METRO) {\n            if (type == DOT_STYLE.SOLID || n <= 1) {\n                cr.translate(startX, startY);\n                cr.setSourceColor(bodyColor);\n                cr.newSubPath();\n                cr.rectangle.apply(cr, [0, 0].concat(isHorizontalDots ? [areaSize, size] : [size, areaSize]));\n                cr.fill();\n            } else {\n                let blackenedLength = (1 / 48) * areaSize; // need to scale with the SVG for the stacked highlight\n                let darkenedLength = isFocused ? (2 / 48) * areaSize : (10 / 48) * areaSize;\n                let blackenedColor = new Utils.ColorUtils.Color({ red: bodyColor.red * .3, green: bodyColor.green * .3, blue: bodyColor.blue * .3, alpha: bodyColor.alpha });\n                let darkenedColor = new Utils.ColorUtils.Color({ red: bodyColor.red * .7, green: bodyColor.green * .7, blue: bodyColor.blue * .7, alpha: bodyColor.alpha });\n                let solidDarkLength = areaSize - darkenedLength;\n                let solidLength = solidDarkLength - blackenedLength;\n\n                cr.translate(startX, startY);\n\n                cr.setSourceColor(bodyColor);\n                cr.newSubPath();\n                cr.rectangle.apply(cr, [0, 0].concat(isHorizontalDots ? [solidLength, size] : [size, solidLength]));\n                cr.fill();\n                cr.setSourceColor(blackenedColor);\n                cr.newSubPath();\n                cr.rectangle.apply(cr, isHorizontalDots ? [solidLength, 0, 1, size] : [0, solidLength, size, 1]);\n                cr.fill();\n                cr.setSourceColor(darkenedColor);\n                cr.newSubPath();\n                cr.rectangle.apply(cr, isHorizontalDots ? [solidDarkLength, 0, darkenedLength, size] : [0, solidDarkLength, size, darkenedLength]);\n                cr.fill();\n            }\n        } else {\n            let spacing = Math.ceil(areaSize / 18); // separation between the indicators\n            let length;\n            let dist;\n            let indicatorSize;\n            let translate;\n            let preDraw = () => {};\n            let draw;\n            let drawDash = (i, dashLength) => {\n                dist = i * dashLength + i * spacing;\n                cr.rectangle.apply(cr, (isHorizontalDots ? [dist, 0, dashLength, size] : [0, dist, size, dashLength]));\n            };\n        \n            switch (type) {\n                case DOT_STYLE.CILIORA:\n                    spacing = size;\n                    length = areaSize - (size * (n - 1)) - (spacing * (n - 1));\n                    translate = () => cr.translate(startX, startY);\n                    preDraw = () => {\n                        cr.newSubPath();\n                        cr.rectangle.apply(cr, [0, 0].concat(isHorizontalDots ? [length, size] : [size, length]));\n                    };\n                    draw = i => {\n                        dist = length + (i * spacing) + ((i - 1) * size);\n                        cr.rectangle.apply(cr, (isHorizontalDots ? [dist, 0] : [0, dist]).concat([size, size]));\n                    };\n                    break;\n                case DOT_STYLE.DOTS:\n                    let radius = size / 2;\n\n                    translate = () => {\n                        indicatorSize = Math.floor((areaSize - n * size - (n - 1) * spacing) / 2);\n                        cr.translate.apply(cr, isHorizontalDots ? [indicatorSize, startY] : [startX, indicatorSize]);\n                    }\n                    draw = i => {\n                        dist = (2 * i + 1) * radius + i * spacing;\n                        cr.arc.apply(cr, (isHorizontalDots ? [dist, radius] : [radius, dist]).concat([radius, 0, 2 * Math.PI]));\n                    };\n                    break;\n                case DOT_STYLE.SQUARES:\n                    translate = () => {\n                        indicatorSize = Math.floor((areaSize - n * size - (n - 1) * spacing) / 2);\n                        cr.translate.apply(cr, isHorizontalDots ? [indicatorSize, startY] : [startX, indicatorSize]);\n                    }\n                    draw = i => {\n                        dist = i * size + i * spacing;\n                        cr.rectangle.apply(cr, (isHorizontalDots ? [dist, 0] : [0, dist]).concat([size, size]));\n                    };\n                    break;\n                case DOT_STYLE.DASHES:\n                    length = Math.floor(areaSize / 4) - spacing;\n                    translate = () => {\n                        indicatorSize = Math.floor((areaSize - n * length - (n - 1) * spacing) / 2);\n                        cr.translate.apply(cr, isHorizontalDots ? [indicatorSize, startY] : [startX, indicatorSize]);\n                    }\n                    draw = i => drawDash(i, length);\n                    break;\n                case DOT_STYLE.SEGMENTED:\n                    length = Math.ceil((areaSize - ((n - 1) * spacing)) / n);\n                    translate = () => cr.translate(startX, startY);\n                    draw = i => drawDash(i, length);\n                    break;\n            }\n\n            translate();\n\n            cr.setSourceColor(bodyColor);\n            preDraw();\n            for (let i = 0; i < n; i++) {\n                cr.newSubPath();\n                draw(i);\n            }\n            cr.fill();\n        }\n        \n        cr.$dispose();\n    }\n\n    _numberOverlay() {\n        // Add label for a Hot-Key visual aid\n        this._numberOverlayLabel = new St.Label({ style_class: 'badge' });\n        this._numberOverlayBin = new St.Bin({\n            child: this._numberOverlayLabel, y: 2\n        });\n        this._numberOverlayLabel.add_style_class_name('number-overlay');\n        this._numberOverlayOrder = -1;\n        this._numberOverlayBin.hide();\n\n        this._dtpIconContainer.add_child(this._numberOverlayBin);\n    }\n\n    updateHotkeyNumberOverlay() {\n        this.updateNumberOverlay(this._numberOverlayBin, true);\n    }\n\n    updateNumberOverlay(bin, fixedSize) {\n        // We apply an overall scale factor that might come from a HiDPI monitor.\n        // Clutter dimensions are in physical pixels, but CSS measures are in logical\n        // pixels, so make sure to consider the scale.\n        // Set the font size to something smaller than the whole icon so it is\n        // still visible. The border radius is large to make the shape circular\n        let [minWidth, natWidth] = this._dtpIconContainer.get_preferred_width(-1);\n        let font_size =  Math.round(Math.max(12, 0.3 * natWidth) / Utils.getScaleFactor());\n        let size = Math.round(font_size * 1.3);\n        let label = bin.child;\n        let style = 'font-size: ' + font_size + 'px;' +\n                    'border-radius: ' + this.icon.iconSize + 'px;' +\n                    'height: ' + size +'px;';\n\n        if (fixedSize || label.get_text().length == 1) {\n            style += 'width: ' + size + 'px;';\n        } else {\n            style += 'padding: 0 2px;';\n        }\n\n        bin.x = 2;\n        label.set_style(style);\n    }\n\n    setNumberOverlay(number) {\n        this._numberOverlayOrder = number;\n        this._numberOverlayLabel.set_text(number.toString());\n    }\n\n    toggleNumberOverlay(activate) {\n        if (activate && this._numberOverlayOrder > -1)\n           this._numberOverlayBin.show();\n        else\n           this._numberOverlayBin.hide();\n    }\n\n    handleDragOver(source, actor, x, y, time) {\n        if (source == Main.xdndHandler) {\n            this._previewMenu.close(true);\n        }\n            \n        return DND.DragMotionResult.CONTINUE;\n    }\n\n    getAppIconInterestingWindows(isolateMonitors) {\n        return getInterestingWindows(this.app, this.dtpPanel.monitor, isolateMonitors);\n    }\n});\nTaskbarAppIcon.prototype.scaleAndFade = TaskbarAppIcon.prototype.undoScaleAndFade = () => {};\n\nexport function minimizeWindow(app, param, monitor){\n    // Param true make all app windows minimize\n    let windows = getInterestingWindows(app, monitor);\n    let current_workspace = Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace();\n    for (let i = 0; i < windows.length; i++) {\n        let w = windows[i];\n        if (w.get_workspace() == current_workspace && w.showing_on_its_workspace()){\n            w.minimize();\n            // Just minimize one window. By specification it should be the\n            // focused window on the current workspace.\n            if(!param)\n                break;\n        }\n    }\n}\n\n/*\n * By default only non minimized windows are activated.\n * This activates all windows in the current workspace.\n */\nexport function activateAllWindows(app, monitor){\n\n    // First activate first window so workspace is switched if needed,\n    // then activate all other app windows in the current workspace.\n    let windows = getInterestingWindows(app, monitor);\n    let w = windows[0];\n    Main.activateWindow(w);\n    let activeWorkspace = Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace_index();\n\n    if (windows.length <= 0)\n        return;\n\n    for (let i = windows.length - 1; i >= 0; i--){\n        if (windows[i].get_workspace().index() == activeWorkspace){\n            Main.activateWindow(windows[i]);\n        }\n    }\n}\n\nexport function activateFirstWindow(app, monitor){\n\n    let windows = getInterestingWindows(app, monitor);\n    Main.activateWindow(windows[0]);\n}\n\nexport function cycleThroughWindows(app, reversed, shouldMinimize, monitor) {\n    // Store for a little amount of time last clicked app and its windows\n    // since the order changes upon window interaction\n    let MEMORY_TIME=3000;\n\n    let app_windows = getInterestingWindows(app, monitor);\n\n    if(shouldMinimize)\n        app_windows.push(\"MINIMIZE\");\n\n    if (recentlyClickedAppLoopId > 0)\n        GLib.Source.remove(recentlyClickedAppLoopId);\n        \n    recentlyClickedAppLoopId = GLib.timeout_add(GLib.PRIORITY_DEFAULT,\n        MEMORY_TIME, resetRecentlyClickedApp);\n\n    // If there isn't already a list of windows for the current app,\n    // or the stored list is outdated, use the current windows list.\n    if (!recentlyClickedApp ||\n        recentlyClickedApp.get_id() != app.get_id() ||\n        recentlyClickedAppWindows.length != app_windows.length ||\n        recentlyClickedAppMonitorIndex != monitor.index) {\n        recentlyClickedApp = app;\n        recentlyClickedAppWindows = app_windows;\n        recentlyClickedAppIndex = 0;\n        recentlyClickedAppMonitorIndex = monitor.index;\n    }\n\n    if (reversed) {\n        recentlyClickedAppIndex--;\n        if (recentlyClickedAppIndex < 0) recentlyClickedAppIndex = recentlyClickedAppWindows.length - 1;\n    } else {\n        recentlyClickedAppIndex++;\n    }\n    let index = recentlyClickedAppIndex % recentlyClickedAppWindows.length;\n    \n    if(recentlyClickedAppWindows[index] === \"MINIMIZE\")\n        minimizeWindow(app, true, monitor);\n    else\n        Main.activateWindow(recentlyClickedAppWindows[index]);\n}\n\nexport function resetRecentlyClickedApp() {\n    if (recentlyClickedAppLoopId > 0)\n        GLib.Source.remove(recentlyClickedAppLoopId);\n\n    recentlyClickedAppLoopId=0;\n    recentlyClickedApp =null;\n    recentlyClickedAppWindows = null;\n    recentlyClickedAppIndex = 0;\n    recentlyClickedAppMonitorIndex = null;\n\n    return false;\n}\n\nexport function closeAllWindows(app, monitor) {\n    let windows = getInterestingWindows(app, monitor);\n    for (let i = 0; i < windows.length; i++)\n        windows[i].delete(global.get_current_time());\n}\n\n// Filter out unnecessary windows, for instance\n// nautilus desktop window.\nexport function getInterestingWindows(app, monitor, isolateMonitors) {\n    let windows = (\n            app ? \n            app.get_windows() : \n            global.get_window_actors().map(wa => wa.get_meta_window())\n        ).filter(w => !w.skip_taskbar);\n\n    // When using workspace or monitor isolation, we filter out windows\n    // that are not in the current workspace or on the same monitor as the appicon\n    if (SETTINGS.get_boolean('isolate-workspaces'))\n        windows = windows.filter(function(w) {\n            return w.get_workspace() && \n                   w.get_workspace() == Utils.getCurrentWorkspace();\n        });\n\n    if (monitor && SETTINGS.get_boolean('multi-monitors') && (isolateMonitors || SETTINGS.get_boolean('isolate-monitors'))) {\n        windows = windows.filter(function(w) {\n            return w.get_monitor() == monitor.index;\n        });\n    }\n    \n    return windows;\n}\n\nexport function cssHexTocssRgba(cssHex, opacity) {\n    let bigint = parseInt(cssHex.slice(1), 16);\n    let r = (bigint >> 16) & 255;\n    let g = (bigint >> 8) & 255;\n    let b = bigint & 255;\n\n    return 'rgba(' + [r, g, b].join(',') + ',' + opacity + ')';\n}\n\nexport function getIconPadding(monitorIndex) {\n    let panelSize = PanelSettings.getPanelSize(SETTINGS, monitorIndex);\n    let padding = SETTINGS.get_int('appicon-padding');\n    let availSize = panelSize - Taskbar.MIN_ICON_SIZE - panelSize % 2;\n\n    if (padding * 2 > availSize) {\n        padding = availSize * .5;\n    }\n\n    return padding;\n}\n\n/**\n * Extend AppMenu (AppIconMenu for pre gnome 41)\n *\n * - hide 'Show Details' according to setting\n * - show windows header only if show-window-previews is disabled\n * - Add close windows option based on quitfromdash extension\n *   (https://github.com/deuill/shell-extension-quitfromdash)\n */\n\nexport class TaskbarSecondaryMenu extends AppMenu.AppMenu {\n\n    constructor(source, side) {\n        super(source, side);\n        // constructor parameter does nos work for some reason\n        this._enableFavorites = true;\n        this._showSingleWindows = true;\n\n        // Remove \"Show Details\" menu item\n        if(!SETTINGS.get_boolean('secondarymenu-contains-showdetails')) {\n            let existingMenuItems = this._getMenuItems();\n            for (let i = 0; i < existingMenuItems.length; i++) {\n                let item = existingMenuItems[i];\n                if (item !== undefined && item.label !== undefined) {\n                    if (item.label.text == \"Show Details\") {\n                        this.box.remove_child(item.actor);\n                    }\n                }\n            }\n        }\n\n        // replace quit item\n        delete this._quitItem;\n        this._quitItem = this.addAction(_('Quit'), () => this._quitFromTaskbar());\n    }\n\n    updateQuitText() {\n        let count = this.sourceActor.window ? 1 : \n            getInterestingWindows(this._app, this.sourceActor.dtpPanel.monitor).length;\n\n        if ( count > 0) {\n            let quitFromTaskbarMenuText = \"\";\n            if (count == 1)\n                quitFromTaskbarMenuText = _(\"Quit\");\n            else\n                quitFromTaskbarMenuText = ngettext('Quit %d Window', 'Quit %d Windows', count).format(count);\n\n            this._quitItem.label.set_text(quitFromTaskbarMenuText);\n        }\n    }\n\n    _quitFromTaskbar() {\n        let time = global.get_current_time()\n        let windows = \n            this.sourceActor.window ? // ungrouped applications\n            [this.sourceActor.window] : \n            getInterestingWindows(this._app, this.sourceActor.dtpPanel.monitor)\n        \n        if (windows.length == this._app.get_windows().length)\n            this._app.request_quit()\n\n        GLib.idle_add(GLib.PRIORITY_DEFAULT_IDLE, () => {\n            windows.forEach((w) => !!w.get_compositor_private() && w.delete(time++));\n            \n            return GLib.SOURCE_REMOVE;\n        });\n    }\n}\n\n/**\n * This function is used for extendDashItemContainer\n */\nexport function ItemShowLabel() {\n    if (!this._labelText)\n        return;\n\n    this.label.set_text(this._labelText);\n    this.label.opacity = 0;\n    this.label.show();\n\n    let [stageX, stageY] = this.get_transformed_position();\n    let node = this.label.get_theme_node();\n\n    let itemWidth  = this.allocation.x2 - this.allocation.x1;\n    let itemHeight = this.allocation.y2 - this.allocation.y1;\n\n    let labelWidth = this.label.get_width();\n    let labelHeight = this.label.get_height();\n\n    let position = this._dtpPanel.getPosition();\n    let labelOffset = node.get_length('-x-offset');\n\n    // From TaskbarItemContainer\n    if (this._getIconAnimationOffset)\n        labelOffset += this._getIconAnimationOffset();\n\n    let xOffset = Math.floor((itemWidth - labelWidth) / 2);\n    let x = stageX + xOffset\n    let y = stageY + (itemHeight - labelHeight) * .5;\n\n    switch(position) {\n      case St.Side.TOP:\n          y = stageY + labelOffset + itemHeight;\n          break;\n      case St.Side.BOTTOM:\n          y = stageY - labelHeight - labelOffset;\n          break;\n      case St.Side.LEFT:\n          x = stageX + labelOffset + itemWidth;\n          break;\n      case St.Side.RIGHT:\n          x = stageX - labelWidth - labelOffset;\n          break;\n    }\n\n    // keep the label inside the screen border\n    // Only needed for the x coordinate.\n\n    // Leave a few pixel gap\n    let gap = LABEL_GAP;\n    let monitor = Main.layoutManager.findMonitorForActor(this);\n    if ( x - monitor.x < gap)\n        x += monitor.x - x + labelOffset;\n    else if ( x + labelWidth > monitor.x + monitor.width - gap)\n        x -= x + labelWidth -( monitor.x + monitor.width) + gap;\n\n    this.label.set_position(Math.round(x), Math.round(y));\n\n    let duration = Dash.DASH_ITEM_LABEL_SHOW_TIME; \n    \n    if (duration > 1) {\n        duration /= 1000;\n    }\n        \n    Utils.animate(this.label, { \n        opacity: 255,\n        time: duration,\n        transition: 'easeOutQuad',\n    });\n}\n\n/**\n * A wrapper class around the ShowAppsIcon class.\n *\n * - Pass settings to the constructor\n * - set label position based on dash orientation (Note, I am reusing most machinery of the appIcon class)\n * - implement a popupMenu based on the AppIcon code (Note, I am reusing most machinery of the appIcon class)\n *\n * I can't subclass the original object because of this: https://bugzilla.gnome.org/show_bug.cgi?id=688973.\n * thus use this pattern where the real showAppsIcon object is encaptulated, and a reference to it will be properly wired upon\n * use of this class in place of the original showAppsButton.\n *\n */\nexport const ShowAppsIconWrapper = class extends EventEmitter {\n\n    constructor(dtpPanel) {\n        super();\n\n        this.realShowAppsIcon = new Dash.ShowAppsIcon();\n\n        /* the variable equivalent to toggleButton has a different name in the appIcon class\n        (actor): duplicate reference to easily reuse appIcon methods */\n        this.actor = this.realShowAppsIcon.toggleButton;\n        this.realShowAppsIcon.show(false);\n\n        // Re-use appIcon methods\n        this._removeMenuTimeout = AppDisplay.AppIcon.prototype._removeMenuTimeout;\n        this._setPopupTimeout = AppDisplay.AppIcon.prototype._setPopupTimeout;\n        this._onKeyboardPopupMenu = AppDisplay.AppIcon.prototype._onKeyboardPopupMenu;\n\n        // No action on clicked (showing of the appsview is controlled elsewhere)\n        this._onClicked = (actor, button) => this._removeMenuTimeout();\n\n        this.actor.connect('leave-event', this._onLeaveEvent.bind(this));\n        this.actor.connect('button-press-event', this._onButtonPress.bind(this));\n        this.actor.connect('touch-event', this._onTouchEvent.bind(this));\n        this.actor.connect('clicked', this._onClicked.bind(this));\n        this.actor.connect('popup-menu', this._onKeyboardPopupMenu.bind(this));\n\n        this._menu = null;\n        this._menuManager = new PopupMenu.PopupMenuManager(this.actor);\n        this._menuTimeoutId = 0;\n\n        this.realShowAppsIcon._dtpPanel = dtpPanel;\n        Taskbar.extendDashItemContainer(this.realShowAppsIcon);\n\n        let customIconPath = SETTINGS.get_string('show-apps-icon-file');\n\n        this.realShowAppsIcon.icon.createIcon = function(size) {\n            this._iconActor = new St.Icon({ icon_name: 'view-app-grid-symbolic',\n                                            icon_size: size,\n                                            style_class: 'show-apps-icon',\n                                            track_hover: true });\n\n            if (customIconPath) {\n                this._iconActor.gicon = new Gio.FileIcon({ file: Gio.File.new_for_path(customIconPath) });\n            }\n\n            return this._iconActor;\n        };\n\n        this._changedShowAppsIconId = SETTINGS.connect('changed::show-apps-icon-file', () => {\n            customIconPath = SETTINGS.get_string('show-apps-icon-file');\n            this.realShowAppsIcon.icon._createIconTexture(this.realShowAppsIcon.icon.iconSize);\n        });\n\n        this._changedAppIconPaddingId = SETTINGS.connect('changed::appicon-padding', () => this.setShowAppsPadding());\n        this._changedAppIconSidePaddingId = SETTINGS.connect('changed::show-apps-icon-side-padding', () => this.setShowAppsPadding());\n        \n        this.setShowAppsPadding();\n    }\n    \n    _onButtonPress(_actor, event) {\n        let button = event.get_button();\n        if (button == 1) {\n            this._setPopupTimeout();\n        } else if (button == 3) {\n            this.popupMenu();\n            return Clutter.EVENT_STOP;\n        }\n        return Clutter.EVENT_PROPAGATE;\n    }\n\n    _onLeaveEvent(_actor, _event) {\n        this.actor.fake_release();\n        this._removeMenuTimeout();\n    }\n\n    _onTouchEvent(actor, event) {\n        if (event.type() == Clutter.EventType.TOUCH_BEGIN)\n        this._setPopupTimeout();\n\n        return Clutter.EVENT_PROPAGATE;\n    }\n\n    _onMenuPoppedDown() {\n        this._menu.sourceActor = this.actor;\n        this.actor.sync_hover();\n        this.emit('menu-state-changed', false);\n    }\n\n    setShowAppsPadding() {\n        let padding = getIconPadding(this.realShowAppsIcon._dtpPanel.monitor.index);\n        let sidePadding = SETTINGS.get_int('show-apps-icon-side-padding');\n        let isVertical = this.realShowAppsIcon._dtpPanel.checkIfVertical();\n\n        this.actor.set_style('padding:' + (padding + (isVertical ? sidePadding : 0)) + 'px ' + (padding + (isVertical ? 0 : sidePadding)) + 'px;');\n    }\n\n    createMenu() {\n        if (!this._menu) {\n            this._menu = new MyShowAppsIconMenu(this.realShowAppsIcon, this.realShowAppsIcon._dtpPanel);\n            this._menu.connect('open-state-changed', (menu, isPoppedUp) => {\n                if (!isPoppedUp)\n                    this._onMenuPoppedDown();\n            });\n            let id = Main.overview.connect('hiding', () => {\n                this._menu.close();\n            });\n            this._menu.actor.connect('destroy', () => {\n                Main.overview.disconnect(id);\n            });\n\n            // We want to keep the item hovered while the menu is up\n            this._menu.blockSourceEvents = true;\n\n            Main.uiGroup.add_child(this._menu.actor);\n            this._menuManager.addMenu(this._menu);\n        }\n    }\n\n    popupMenu(sourceActor = null) {\n        this._removeMenuTimeout();\n        this.actor.fake_release();\n        this.createMenu();\n\n        this._menu.updateItems(sourceActor == null ? this.realShowAppsIcon : sourceActor);\n\n        this.actor.set_hover(true);\n        this._menu.open(BoxPointer.PopupAnimation.FULL);\n        this._menuManager.ignoreRelease();\n        this.emit('sync-tooltip');\n\n        return false;\n    }\n\n    shouldShowTooltip() {\n        return SETTINGS.get_boolean('show-tooltip') && \n               (this.actor.hover && (!this._menu || !this._menu.isOpen));\n    }\n\n    destroy() {\n        SETTINGS.disconnect(this._changedShowAppsIconId);\n        SETTINGS.disconnect(this._changedAppIconSidePaddingId);\n        SETTINGS.disconnect(this._changedAppIconPaddingId);\n\n        this.realShowAppsIcon.destroy();\n    }\n};\n\n/**\n * A menu for the showAppsIcon\n */\nexport const MyShowAppsIconMenu = class extends PopupMenu.PopupMenu {\n\n    constructor(actor, dtpPanel) {\n        super(actor, 0, dtpPanel.getPosition());\n\n        this._dtpPanel = dtpPanel;\n\n        this.updateItems(actor);\n    }\n\n    updateItems(sourceActor) {\n        this.sourceActor = sourceActor;\n\n        this.removeAll();\n\n        if (this.sourceActor != Main.layoutManager.dummyCursor) {\n            this._appendItem({\n                title: _('Power options'),\n                cmd: ['gnome-control-center', 'power']\n            });\n\n            this._appendItem({\n                title: _('Event logs'),\n                cmd: ['gnome-logs']\n            });\n\n            this._appendItem({\n                title: _('System'),\n                cmd: ['gnome-control-center', 'info-overview']\n            });\n\n            this._appendItem({\n                title: _('Device Management'),\n                cmd: ['gnome-control-center', 'display']\n            });\n\n            this._appendItem({\n                title: _('Disk Management'),\n                cmd: ['gnome-disks']\n            });\n\n            this._appendList(\n                SETTINGS.get_strv('show-apps-button-context-menu-commands'),\n                SETTINGS.get_strv('show-apps-button-context-menu-titles')\n            )\n\n            this._appendSeparator();\n        }\n\n        this._appendItem({\n            title: _('Terminal'),\n            cmd: [TERMINALSETTINGS.get_string('exec')]\n        });\n\n        this._appendItem({\n            title: _('System monitor'),\n            cmd: ['gnome-system-monitor']\n        });\n\n        this._appendItem({\n            title: _('Files'),\n            cmd: ['nautilus']\n        });\n\n        this._appendItem({\n            title: _('Extensions'),\n            cmd: ['gnome-extensions-app']\n        });\n\n        this._appendItem({\n            title: _('Settings'),\n            cmd: ['gnome-control-center']\n        });\n\n        this._appendList(\n            SETTINGS.get_strv('panel-context-menu-commands'),\n            SETTINGS.get_strv('panel-context-menu-titles')\n        )\n\n        this._appendSeparator();\n\n        let lockTaskbarMenuItem = this._appendMenuItem(SETTINGS.get_boolean('taskbar-locked') ? _('Unlock taskbar') : _('Lock taskbar'));\n        lockTaskbarMenuItem.connect('activate', () => {\n            SETTINGS.set_boolean('taskbar-locked', !SETTINGS.get_boolean('taskbar-locked'));\n        });\n\n        let settingsMenuItem = this._appendMenuItem(_('Dash to Panel Settings'));\n        settingsMenuItem.connect('activate', () => DTP_EXTENSION.openPreferences())\n\n        if(this.sourceActor == Main.layoutManager.dummyCursor) {\n            this._appendSeparator();\n            let item = this._appendMenuItem(this._dtpPanel._restoreWindowList ? _('Restore Windows') : _('Show Desktop'));\n            item.connect('activate', this._dtpPanel._onShowDesktopButtonPress.bind(this._dtpPanel));\n        }\n    }\n\n\n    // Only add menu entries for commands that exist in path\n    _appendItem(info) {\n        if (GLib.find_program_in_path(info.cmd[0])) {\n            let item = this._appendMenuItem(_(info.title));\n\n            item.connect('activate', function() {\n                print(\"activated: \" + info.title);\n                Util.spawn(info.cmd);\n            });\n            return item;\n        }\n\n        return null;\n    }\n    \n    _appendList(commandList, titleList) {\n        if (commandList.length != titleList.length) {\n            return;\n        }\n        \n        for (let entry = 0; entry < commandList.length; entry++) {\n            this._appendItem({\n                title: titleList[entry],\n                cmd: commandList[entry].split(' ')\n            });\n        }\n    }\n\n    _appendSeparator() {\n        let separator = new PopupMenu.PopupSeparatorMenuItem();\n        this.addMenuItem(separator);\n    }\n\n    _appendMenuItem(labelText) {\n        // FIXME: app-well-menu-item style\n        let item = new PopupMenu.PopupMenuItem(labelText);\n        this.addMenuItem(item);\n        return item;\n    }\n};\n\n\nexport const getIconContainerStyle = function(isVertical) {\n    let style = 'padding: ';\n\n    if (SETTINGS.get_boolean('group-apps')) {\n        style += (isVertical ? '0;' : '0 ' + DEFAULT_PADDING_SIZE + 'px;');\n    } else {\n        style += (isVertical ? '' : '0 ') + DEFAULT_PADDING_SIZE + 'px;';\n    }\n\n    return style;\n}\n"
        },
        {
          "name": "desktopIconsIntegration.js",
          "type": "blob",
          "size": 6.43359375,
          "content": "/*\n * The code in this file is distributed under a \"1-clause BSD license\",\n * which makes it compatible with GPLv2 and GPLv3 too, and others.\n *\n * License text:\n *\n * Copyright (C) 2021 Sergio Costas (rastersoft@gmail.com)\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*******************************************************************************\n * Integration class\n *\n * This class must be added to other extensions in order to integrate\n * them with Desktop Icons NG. It allows an extension to notify how much margin\n * it uses in each side of each monitor.\n *\n * DON'T SEND PATCHES TO THIS FILE TO THE EXTENSION MAINTAINER. SEND THEM TO\n * DESKTOP ICONS NG MAINTAINER: https://gitlab.com/rastersoft/desktop-icons-ng\n *\n * In the *enable()* function, create a *DesktopIconsUsableAreaClass()*\n * object with\n *\n *     new DesktopIconsIntegration.DesktopIconsUsableAreaClass(object);\n *\n * Now, in the *disable()* function just call to the *destroy()* method before\n * nullifying the pointer. You must create a new object in enable() the next\n * time the extension is enabled.\n *\n * In your code, every time you change the margins, you should call first to\n * *resetMargins()* method to clear the current margins, and then call to\n * *setMargins(...)* method as many times as you need to set the margins in each\n * monitor. You don't need to call it for all the monitors, only for those where\n * you are painting something. If you don't set values for a monitor, they will\n * be considered zero.\n *\n * The margins values are relative to the monitor border.\n *\n *******************************************************************************/\n\nimport GLib from 'gi://GLib';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as ExtensionUtils from 'resource:///org/gnome/shell/misc/extensionUtils.js';\nimport {Extension} from 'resource:///org/gnome/shell/extensions/extension.js';\n\nconst IDENTIFIER_UUID = \"130cbc66-235c-4bd6-8571-98d2d8bba5e2\";\n\nexport class DesktopIconsUsableAreaClass {\n    _checkIfExtensionIsEnabled(extension) {\n        return (extension?.state === ExtensionUtils.ExtensionState.ENABLED) ||\n               (extension?.state === ExtensionUtils.ExtensionState.ACTIVE);\n    }\n\n    constructor() {\n        const Me = Extension.lookupByURL(import.meta.url);\n        this._UUID = Me.uuid;\n        this._extensionManager = Main.extensionManager;\n        this._timedMarginsID = 0;\n        this._margins = {};\n        this._emID = this._extensionManager.connect('extension-state-changed', (_obj, extension) => {\n            if (!extension)\n                return;\n\n            // If an extension is being enabled and lacks the DesktopIconsUsableArea object, we can avoid launching a refresh\n            if (this._checkIfExtensionIsEnabled(extension)) {\n                this._sendMarginsToExtension(extension);\n                return;\n            }\n            // if the extension is being disabled, we must do a full refresh, because if there were other extensions originally\n            // loaded after that extension, those extensions will be disabled and enabled again without notification\n            this._changedMargins();\n        });\n    }\n\n    /**\n     * Sets or updates the top, bottom, left and right margins for a\n     * monitor. Values are measured from the monitor border (and NOT from\n     * the workspace border).\n     *\n     * @param {int} monitor Monitor number to which set the margins.\n     *                      A negative value means \"the primary monitor\".\n     * @param {int} top Top margin in pixels\n     * @param {int} bottom Bottom margin in pixels\n     * @param {int} left Left margin in pixels\n     * @param {int} right Right margin in pixels\n     */\n    setMargins(monitor, top, bottom, left, right) {\n        this._margins[monitor] = {\n            'top': top,\n            'bottom': bottom,\n            'left': left,\n            'right': right\n        };\n        this._changedMargins();\n    }\n\n    /**\n     * Clears the current margins. Must be called before configuring the monitors\n     * margins with setMargins().\n     */\n    resetMargins() {\n        this._margins = {};\n        this._changedMargins();\n    }\n\n    /**\n     * Disconnects all the signals and removes the margins.\n     */\n    destroy() {\n        if (this._emID) {\n            this._extensionManager.disconnect(this._emID);\n            this._emID = 0;\n        }\n        if (this._timedMarginsID) {\n            GLib.source_remove(this._timedMarginsID);\n            this._timedMarginsID = 0;\n        }\n        this._margins = null;\n        this._changedMargins();\n    }\n\n    _changedMargins() {\n        if (this._timedMarginsID) {\n            GLib.source_remove(this._timedMarginsID);\n        }\n        this._timedMarginsID = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, ()=> {\n            this._sendMarginsToAll();\n            this._timedMarginsID = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    _sendMarginsToAll() {\n        this._extensionManager.getUuids().forEach(uuid =>\n            this._sendMarginsToExtension(this._extensionManager.lookup(uuid)));\n    }\n\n    _sendMarginsToExtension(extension) {\n        // check that the extension is an extension that has the logic to accept\n        // working margins\n        if (!this._checkIfExtensionIsEnabled(extension))\n            return;\n\n        const usableArea = extension?.stateObj?.DesktopIconsUsableArea;\n        if (usableArea?.uuid === IDENTIFIER_UUID)\n            usableArea.setMarginsForExtension(this._UUID, this._margins);\n    }\n}\n"
        },
        {
          "name": "extension.js",
          "type": "blob",
          "size": 4.3857421875,
          "content": "/*\n * Dash-To-Panel extension for Gnome 3\n * Copyright 2016 Jason DeRose (jderose9) and Charles Gagnon (charlesg99)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nimport Gio from 'gi://Gio';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport {EventEmitter} from 'resource:///org/gnome/shell/misc/signals.js';\nimport {Extension, gettext as _} from 'resource:///org/gnome/shell/extensions/extension.js';\n\nimport * as  PanelManager from './panelManager.js';\nimport * as AppIcons from './appIcons.js';\n\n\nconst UBUNTU_DOCK_UUID = 'ubuntu-dock@ubuntu.com';\n\nlet panelManager;\nlet extensionChangedHandler;\nlet startupCompleteHandler;\nlet disabledUbuntuDock;\nlet extensionSystem = Main.extensionManager;\n\nexport let DTP_EXTENSION = null;\nexport let SETTINGS = null;\nexport let DESKTOPSETTINGS = null;\nexport let TERMINALSETTINGS = null;\nexport let PERSISTENTSTORAGE = null;\nexport let EXTENSION_UUID = null;\nexport let EXTENSION_PATH = null;\n\nexport default class DashToPanelExtension extends Extension {\n    constructor(metadata) {\n        super(metadata);\n\n        this._realHasOverview = Main.sessionMode.hasOverview;\n        \n        //create an object that persists until gnome-shell is restarted, even if the extension is disabled\n        PERSISTENTSTORAGE = {};\n    }\n\n    enable() {\n        DTP_EXTENSION = this;\n\n        // The Ubuntu Dock extension might get enabled after this extension\n        extensionChangedHandler = extensionSystem.connect('extension-state-changed', (data, extension) => {\n            if (extension.uuid === UBUNTU_DOCK_UUID && extension.state === 1) {\n                _enable(this);\n            }\n        });\n\n        //create a global object that can emit signals and conveniently expose functionalities to other extensions \n        global.dashToPanel = new EventEmitter();\n        \n        _enable(this);\n    }\n\n    disable(reset = false) {\n        panelManager.disable();\n\n        DTP_EXTENSION = null;\n        SETTINGS = null;\n        DESKTOPSETTINGS = null;\n        TERMINALSETTINGS = null;\n        panelManager = null;\n\n        if (!reset) {\n            extensionSystem.disconnect(extensionChangedHandler);\n\n            if (disabledUbuntuDock) {\n                disabledUbuntuDock = false;\n                extensionSystem.enableExtension(UBUNTU_DOCK_UUID);\n            }\n\n            delete global.dashToPanel;\n\n            AppIcons.resetRecentlyClickedApp();\n        }\n\n        if (startupCompleteHandler) {\n            Main.layoutManager.disconnect(startupCompleteHandler);\n            startupCompleteHandler = null;\n        }\n\n        Main.sessionMode.hasOverview = this._realHasOverview;\n    }\n}\n\nfunction _enable(extension) {\n    let enabled = global.settings.get_strv('enabled-extensions');\n\n    if (enabled?.indexOf(UBUNTU_DOCK_UUID) >= 0) {\n        disabledUbuntuDock = true;\n        extensionSystem.disableExtension(UBUNTU_DOCK_UUID);\n    }\n\n    if (panelManager)\n        return panelManager.toggleDash(); // already initialized but ubuntu dock restored the original dash on disable\n\n    SETTINGS = extension.getSettings('org.gnome.shell.extensions.dash-to-panel');\n    DESKTOPSETTINGS = new Gio.Settings({schema_id: 'org.gnome.desktop.interface'});\n    TERMINALSETTINGS = new Gio.Settings({schema_id: 'org.gnome.desktop.default-applications.terminal'})\n    EXTENSION_UUID = extension.uuid\n    EXTENSION_PATH = extension.path\n\n    Main.layoutManager.startInOverview = !SETTINGS.get_boolean('hide-overview-on-startup');\n\n    if (SETTINGS.get_boolean('hide-overview-on-startup') && Main.layoutManager._startingUp) {\n        Main.sessionMode.hasOverview = false;\n        startupCompleteHandler = Main.layoutManager.connect('startup-complete', () => {\n            Main.sessionMode.hasOverview = extension._realHasOverview\n        });\n    }\n\n    panelManager = new PanelManager.PanelManager();\n\n    panelManager.enable();\n}"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "intellihide.js",
          "type": "blob",
          "size": 14.9873046875,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport Clutter from 'gi://Clutter';\nimport Meta from 'gi://Meta';\nimport Shell from 'gi://Shell';\nimport St from 'gi://St';\n\nimport * as GrabHelper from 'resource:///org/gnome/shell/ui/grabHelper.js';\nimport * as Layout from 'resource:///org/gnome/shell/ui/layout.js';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as OverviewControls from 'resource:///org/gnome/shell/ui/overviewControls.js';\nimport * as PointerWatcher from 'resource:///org/gnome/shell/ui/pointerWatcher.js';\n\nimport * as Proximity from './proximity.js';\nimport * as Utils from './utils.js';\nimport {SETTINGS} from './extension.js';\n\n//timeout intervals\nconst CHECK_POINTER_MS = 200;\nconst CHECK_GRAB_MS = 400;\nconst POST_ANIMATE_MS = 50; \nconst MIN_UPDATE_MS = 250;\n\n//timeout names\nconst T1 = 'checkGrabTimeout';\nconst T2 = 'limitUpdateTimeout';\nconst T3 = 'postAnimateTimeout';\n\nconst SIDE_CONTROLS_ANIMATION_TIME = OverviewControls.SIDE_CONTROLS_ANIMATION_TIME / (OverviewControls.SIDE_CONTROLS_ANIMATION_TIME > 1 ? 1000 : 1);\n\nexport const Hold = {\n    NONE: 0,\n    TEMPORARY: 1,\n    PERMANENT: 2\n};\n\nexport const Intellihide = class {\n\n    constructor(dtpPanel) {\n        this._dtpPanel = dtpPanel;\n        this._panelBox = dtpPanel.panelBox;\n        this._panelManager = dtpPanel.panelManager;\n        this._proximityManager = this._panelManager.proximityManager;\n        this._holdStatus = Hold.NONE;\n        \n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._timeoutsHandler = new Utils.TimeoutsHandler();\n\n        this._intellihideChangedId = SETTINGS.connect('changed::intellihide', () => this._changeEnabledStatus());\n        this._intellihideOnlySecondaryChangedId = SETTINGS.connect('changed::intellihide-only-secondary', () => this._changeEnabledStatus());\n\n        this.enabled = false;\n        this._changeEnabledStatus();\n    }\n\n    enable() {\n        this.enabled = true;\n        this._monitor = this._dtpPanel.monitor;\n        this._animationDestination = -1;\n        this._pendingUpdate = false;\n        this._hoveredOut = false;\n        this._windowOverlap = false;\n        this._translationProp = 'translation_' + (this._dtpPanel.checkIfVertical() ? 'x' : 'y');\n\n        this._panelBox.translation_y = 0;\n        this._panelBox.translation_x = 0;\n\n        this._setTrackPanel(true);\n        this._bindGeneralSignals();\n\n        if (SETTINGS.get_boolean('intellihide-hide-from-windows')) {\n            this._proximityWatchId = this._proximityManager.createWatch(\n                this._panelBox.get_parent(),\n                this._dtpPanel.monitor.index,\n                Proximity.Mode[SETTINGS.get_string('intellihide-behaviour')], \n                0, 0,\n                overlap => { \n                    this._windowOverlap = overlap;\n                    this._queueUpdatePanelPosition();\n                }\n            );\n        }\n\n        this._setRevealMechanism();\n        this._queueUpdatePanelPosition();\n    }\n\n    disable(reset) {\n        if (this._proximityWatchId) {\n            this._proximityManager.removeWatch(this._proximityWatchId);\n        }\n\n        this._setTrackPanel(false);\n\n        this._signalsHandler.destroy();\n        this._timeoutsHandler.destroy();\n\n        this._removeRevealMechanism();\n\n        this._revealPanel(!reset);\n        \n        this.enabled = false;\n    }\n\n    destroy() {\n        SETTINGS.disconnect(this._intellihideChangedId);\n        SETTINGS.disconnect(this._intellihideOnlySecondaryChangedId);\n        \n        if (this.enabled) {\n            this.disable();\n        }\n    }\n\n    toggle() {\n        this[this._holdStatus & Hold.PERMANENT ? 'release' : 'revealAndHold'](Hold.PERMANENT);\n    }\n\n    revealAndHold(holdStatus) {\n        if (this.enabled && !this._holdStatus) {\n            this._revealPanel();\n        }\n        \n        this._holdStatus |= holdStatus;\n    }\n\n    release(holdStatus) {\n        this._holdStatus -= holdStatus;\n\n        if (this.enabled && !this._holdStatus) {\n            this._queueUpdatePanelPosition();\n        }\n    }\n\n    reset() {\n        this.disable(true);\n        this.enable();\n    }\n\n    _changeEnabledStatus() {\n        let intellihide = SETTINGS.get_boolean('intellihide');\n        let onlySecondary = SETTINGS.get_boolean('intellihide-only-secondary');\n        let enabled = intellihide && !(this._dtpPanel.isPrimary && onlySecondary);\n\n        if (this.enabled !== enabled) {\n            this[enabled ? 'enable' : 'disable']();\n        }\n    }\n\n    _bindGeneralSignals() {\n        this._signalsHandler.add(\n            [\n                this._dtpPanel.taskbar,\n                ['menu-closed', 'end-drag'],\n                () => {\n                    this._panelBox.sync_hover();\n                    this._onHoverChanged();\n                }\n            ],\n            [\n                SETTINGS, \n                [\n                    'changed::intellihide-use-pressure',\n                    'changed::intellihide-hide-from-windows',\n                    'changed::intellihide-behaviour',\n                    'changed::intellihide-pressure-threshold',\n                    'changed::intellihide-pressure-time'\n                ],\n                () => this.reset()\n            ],\n            [\n                this._panelBox,\n                'notify::hover',\n                () => this._onHoverChanged()\n            ],\n            [\n                this._dtpPanel.taskbar.previewMenu,\n                'open-state-changed',\n                () => this._queueUpdatePanelPosition()\n            ],\n            [\n                Main.overview,\n                [\n                    'showing',\n                    'hiding'\n                ],\n                () => this._queueUpdatePanelPosition()\n            ]\n        );\n\n        if (Meta.is_wayland_compositor()) {\n            this._signalsHandler.add([\n                this._panelBox,\n                'notify::visible', \n                () => Utils.setDisplayUnredirect(!this._panelBox.visible)\n            ]);\n        }\n    }\n\n    _onHoverChanged() {\n        this._hoveredOut = !this._panelBox.hover;\n        this._queueUpdatePanelPosition();\n    }\n\n    _setTrackPanel(enable) {\n        let actorData = Utils.getTrackedActorData(this._panelBox)\n\n        actorData.affectsStruts = !enable;\n        actorData.trackFullscreen = !enable;\n\n        this._panelBox.track_hover = enable;\n        this._panelBox.reactive = enable;\n        this._panelBox.visible = enable ? enable : this._panelBox.visible;\n        \n        Main.layoutManager._queueUpdateRegions();\n    }\n\n    _setRevealMechanism() {\n        let barriers = Meta.BackendCapabilities.BARRIERS\n\n        if ((global.backend.capabilities & barriers) === barriers && SETTINGS.get_boolean('intellihide-use-pressure')) {\n            this._edgeBarrier = this._createBarrier();\n            this._pressureBarrier = new Layout.PressureBarrier(\n                SETTINGS.get_int('intellihide-pressure-threshold'), \n                SETTINGS.get_int('intellihide-pressure-time'), \n                Shell.ActionMode.NORMAL\n            );\n            this._pressureBarrier.addBarrier(this._edgeBarrier);\n            this._signalsHandler.add([this._pressureBarrier, 'trigger', () => this._queueUpdatePanelPosition(true)]);\n        } else {\n            this._pointerWatch = PointerWatcher.getPointerWatcher()\n                                               .addWatch(CHECK_POINTER_MS, (x, y) => this._checkMousePointer(x, y));\n        }\n    }\n\n    _removeRevealMechanism() {\n        if (this._pointerWatch) {\n            PointerWatcher.getPointerWatcher()._removeWatch(this._pointerWatch);\n        }\n\n        if (this._pressureBarrier) {\n            this._pressureBarrier.destroy();\n            this._edgeBarrier.destroy();\n\n            this._pressureBarrier = 0;\n        }\n    }\n\n    _createBarrier() {\n        let position = this._dtpPanel.geom.position;\n        let opts = { backend: global.backend };\n\n        if (this._dtpPanel.checkIfVertical()) {\n            opts.y1 = this._monitor.y;\n            opts.y2 = this._monitor.y + this._monitor.height;\n            opts.x1 = opts.x2 = this._monitor.x;\n        } else {\n            opts.x1 = this._monitor.x;\n            opts.x2 = this._monitor.x + this._monitor.width;\n            opts.y1 = opts.y2 = this._monitor.y;\n        }\n\n        if (position == St.Side.TOP) {\n            opts.directions = Meta.BarrierDirection.POSITIVE_Y;\n        } else if (position == St.Side.BOTTOM) {\n            opts.y1 = opts.y2 = opts.y1 + this._monitor.height;\n            opts.directions = Meta.BarrierDirection.NEGATIVE_Y;\n        } else if (position == St.Side.LEFT) {\n            opts.directions = Meta.BarrierDirection.POSITIVE_X;\n        } else {\n            opts.x1 = opts.x2 = opts.x1 + this._monitor.width;\n            opts.directions = Meta.BarrierDirection.NEGATIVE_X;\n        }\n\n        return new Meta.Barrier(opts);\n    }\n\n    _checkMousePointer(x, y) {\n        let position = this._dtpPanel.geom.position;\n\n        if (!this._panelBox.hover && !Main.overview.visible &&\n            ((position == St.Side.TOP && y <= this._monitor.y + 1) || \n             (position == St.Side.BOTTOM && y >= this._monitor.y + this._monitor.height - 1) ||\n             (position == St.Side.LEFT && x <= this._monitor.x + 1) ||\n             (position == St.Side.RIGHT && x >= this._monitor.x + this._monitor.width - 1)) &&\n            ((x >= this._monitor.x && x < this._monitor.x + this._monitor.width) && \n             (y >= this._monitor.y && y < this._monitor.y + this._monitor.height))) {\n            this._queueUpdatePanelPosition(true);\n        }\n    }\n\n    _queueUpdatePanelPosition(fromRevealMechanism) {\n        if (!fromRevealMechanism && this._timeoutsHandler.getId(T2) && !Main.overview.visible) {\n            //unless this is a mouse interaction or entering/leaving the overview, limit the number\n            //of updates, but remember to update again when the limit timeout is reached\n            this._pendingUpdate = true;\n        } else if (!this._holdStatus) {\n            this._checkIfShouldBeVisible(fromRevealMechanism) ? this._revealPanel() : this._hidePanel();\n            this._timeoutsHandler.add([T2, MIN_UPDATE_MS, () => this._endLimitUpdate()]);\n        }\n    }\n\n    _endLimitUpdate() {\n        if (this._pendingUpdate) {\n            this._pendingUpdate = false;\n            this._queueUpdatePanelPosition();\n        }\n    }\n\n    _checkIfShouldBeVisible(fromRevealMechanism) {\n        if (Main.overview.visibleTarget || this._dtpPanel.taskbar.previewMenu.opened || \n            this._dtpPanel.taskbar._dragMonitor || this._panelBox.get_hover() || this._checkIfGrab()) {\n            return true;\n        }\n\n        if (fromRevealMechanism) {\n            let mouseBtnIsPressed = global.get_pointer()[2] & Clutter.ModifierType.BUTTON1_MASK;\n            \n            //the user is trying to reveal the panel\n            if (this._monitor.inFullscreen && !mouseBtnIsPressed) {\n                return SETTINGS.get_boolean('intellihide-show-in-fullscreen');\n            }\n\n            return !mouseBtnIsPressed;\n        }\n\n        if (!SETTINGS.get_boolean('intellihide-hide-from-windows')) {\n            return this._panelBox.hover;\n        }\n\n        return !this._windowOverlap;\n    }\n\n    _checkIfGrab() {\n        let isGrab \n        \n        if (GrabHelper._grabHelperStack)\n            // gnome-shell < 42\n            isGrab = GrabHelper._grabHelperStack.some(gh => gh._owner == this._dtpPanel.panel)\n        else if (global.stage.get_grab_actor) {\n            // gnome-shell >= 42\n            let grabActor = global.stage.get_grab_actor()\n            let sourceActor = grabActor?._sourceActor || grabActor\n\n            isGrab = sourceActor && \n                     (sourceActor == Main.layoutManager.dummyCursor || \n                      this._dtpPanel.statusArea.quickSettings?.menu.actor.contains(sourceActor) || \n                      this._dtpPanel.panel.contains(sourceActor))\n        }\n\n        if (isGrab)\n            //there currently is a grab on a child of the panel, check again soon to catch its release\n            this._timeoutsHandler.add([T1, CHECK_GRAB_MS, () => this._queueUpdatePanelPosition()]);\n\n        return isGrab;\n    }\n\n    _revealPanel(immediate) {\n        if (!this._panelBox.visible) {\n            this._panelBox.visible = true;\n            this._dtpPanel.taskbar._shownInitially = false;\n        }\n\n        this._animatePanel(0, immediate);\n    }\n\n    _hidePanel(immediate) {\n        let position = this._dtpPanel.geom.position;\n        let size = this._panelBox[position == St.Side.LEFT || position == St.Side.RIGHT ? 'width' : 'height']; \n        let coefficient = position == St.Side.TOP || position == St.Side.LEFT ? -1 : 1;\n\n        this._animatePanel(size * coefficient, immediate);\n    }\n\n    _animatePanel(destination, immediate) {\n        let animating = Utils.isAnimating(this._panelBox, this._translationProp);\n\n        if (!((animating && destination === this._animationDestination) || \n              (!animating && destination === this._panelBox[this._translationProp]))) {\n            //the panel isn't already at, or animating to the asked destination\n            if (animating) {\n                Utils.stopAnimations(this._panelBox);\n            }\n\n            this._animationDestination = destination;\n\n            if (immediate) {\n                this._panelBox[this._translationProp] = destination;\n                this._panelBox.visible = !destination;\n            } else {\n                let tweenOpts = {\n                    //when entering/leaving the overview, use its animation time instead of the one from the settings\n                    time: Main.overview.visible ? \n                          SIDE_CONTROLS_ANIMATION_TIME :\n                          SETTINGS.get_int('intellihide-animation-time') * 0.001,\n                    //only delay the animation when hiding the panel after the user hovered out\n                    delay: destination != 0 && this._hoveredOut ? SETTINGS.get_int('intellihide-close-delay') * 0.001 : 0,\n                    transition: 'easeOutQuad',\n                    onComplete: () => {\n                        this._panelBox.visible = !destination;\n                        Main.layoutManager._queueUpdateRegions();\n                        this._timeoutsHandler.add([T3, POST_ANIMATE_MS, () => this._queueUpdatePanelPosition()]);\n                    }\n                };\n\n                tweenOpts[this._translationProp] = destination;\n                Utils.animate(this._panelBox, tweenOpts);\n            }\n        }\n\n        this._hoveredOut = false;\n    }\n}\n"
        },
        {
          "name": "media",
          "type": "tree",
          "content": null
        },
        {
          "name": "metadata.json",
          "type": "blob",
          "size": 0.9013671875,
          "content": "{\n  \"extension-id\": \"dash-to-panel\",\n  \"uuid\": \"dash-to-panel@jderose9.github.com\",\n  \"name\": \"Dash to Panel\",\n  \"description\": \"An icon taskbar for the Gnome Shell. This extension moves the dash into the gnome main panel so that the application launchers and system tray are combined into a single panel, similar to that found in KDE Plasma and Windows 7+. A separate dock is no longer needed for easy access to running and favorited applications.\\n\\nFor a more traditional experience, you may also want to use Tweak Tool to enable Windows > Titlebar Buttons > Minimize & Maximize.\\n\\nFor the best support, please report any issues on Github. Dash-to-panel is developed and maintained by @jderose9 and @charlesg99.\",\n  \"shell-version\": [ \"46\", \"47\" ],\n  \"url\": \"https://github.com/home-sweet-gnome/dash-to-panel\",\n  \"gettext-domain\": \"dash-to-panel\",\n  \"version\": 9999,\n  \"donations\": {\n      \"paypal\": \"charlesg99\"\n  }\n}\n"
        },
        {
          "name": "overview.js",
          "type": "blob",
          "size": 18.146484375,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Credits:\n * This file is based on code from the Dash to Dock extension by micheleg\n * \n * Some code was also adapted from the upstream Gnome Shell source code.\n */\n\nimport * as Intellihide from './intellihide.js';\nimport * as Utils from './utils.js';\n\nimport Clutter from 'gi://Clutter';\nimport Gio from 'gi://Gio';\nimport Shell from 'gi://Shell';\nimport St from 'gi://St';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as WindowManager from 'resource:///org/gnome/shell/ui/windowManager.js';\nimport {WindowPreview} from 'resource:///org/gnome/shell/ui/windowPreview.js';\nimport {InjectionManager} from 'resource:///org/gnome/shell/extensions/extension.js';\nimport {SETTINGS} from './extension.js';\n\nconst GS_HOTKEYS_KEY = 'switch-to-application-';\n\n// When the dash is shown, workspace window preview bottom labels go over it (default\n// gnome-shell behavior), but when the extension hides the dash, leave some space\n// so those labels don't go over a bottom panel\nconst LABEL_MARGIN = 60;\n\n//timeout names\nconst T1 = 'swipeEndTimeout';\nconst T2 = 'numberOverlayTimeout';\n\nexport const Overview = class {\n\n    constructor() {\n        this._injectionManager = new InjectionManager();\n        this._numHotkeys = 10;\n    }\n\n    enable (primaryPanel) {\n        this._panel = primaryPanel;\n        this.taskbar = primaryPanel.taskbar;\n\n        this._injectionsHandler = new Utils.InjectionsHandler();\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._timeoutsHandler = new Utils.TimeoutsHandler();\n\n        this._optionalWorkspaceIsolation();\n        this._optionalHotKeys();\n        this._optionalNumberOverlay();\n        this._optionalClickToExit();\n\n        this.toggleDash();\n        this._adaptAlloc();\n\n        this._signalsHandler.add([\n            SETTINGS,\n            [\n                'changed::stockgs-keep-dash',\n                'changed::panel-sizes'\n            ], \n            () => this.toggleDash()\n        ]);\n    }\n\n    disable() {\n        this._signalsHandler.destroy();\n        this._injectionsHandler.destroy();\n        this._timeoutsHandler.destroy();\n        this._injectionManager.clear();\n\n        this.toggleDash(true);\n\n        // Remove key bindings\n        this._disableHotKeys();\n        this._disableExtraShortcut();\n        this._disableClickToExit();\n    }\n\n    toggleDash(visible) {\n        if (visible === undefined) {\n            visible = SETTINGS.get_boolean('stockgs-keep-dash');\n        }\n\n        let visibilityFunc = visible ? 'show' : 'hide';\n        let height = visible ? -1 : LABEL_MARGIN * Utils.getScaleFactor();\n        let overviewControls = Main.overview._overview._controls;\n\n        overviewControls.dash[visibilityFunc]();\n        overviewControls.dash.set_height(height);\n    }\n\n    _adaptAlloc() {\n        let overviewControls = Main.overview._overview._controls\n\n        this._injectionManager.overrideMethod(Object.getPrototypeOf(overviewControls), 'vfunc_allocate', \n            (originalAllocate) => \n                (box) => {\n                    let focusedPanel = this._panel.panelManager.focusedMonitorPanel\n                    \n                    if (focusedPanel) {\n                        let position = focusedPanel.geom.position\n                        let isBottom = position == St.Side.BOTTOM\n\n                        if (focusedPanel.intellihide?.enabled) {\n                            // Panel intellihide is enabled (struts aren't taken into account on overview allocation),\n                            // dynamically modify the overview box to follow the reveal/hide animation\n                            let { transitioning, finalState, progress } = overviewControls._stateAdjustment.getStateTransitionParams()\n                            let size = focusedPanel.geom[focusedPanel.checkIfVertical() ? 'w' : 'h'] * \n                                    (transitioning ? Math.abs((finalState != 0 ? 0 : 1) - progress) : 1)\n\n                            if (isBottom || position == St.Side.RIGHT)\n                                box[focusedPanel.fixedCoord.c2] -= size\n                            else\n                                box[focusedPanel.fixedCoord.c1] += size\n                        } else if (isBottom)\n                            // The default overview allocation is very good and takes into account external \n                            // struts, everywhere but the bottom where the dash is usually fixed anyway.\n                            // If there is a bottom panel under the dash location, give it some space here\n                            box.y2 -= focusedPanel.geom.h\n                    }\n                    \n                    originalAllocate.call(overviewControls, box)\n                }\n        );\n    }\n\n    /**\n     * Isolate overview to open new windows for inactive apps\n     */\n    _optionalWorkspaceIsolation() {\n        let label = 'optionalWorkspaceIsolation';\n        \n        let enable = () => {\n            this._injectionsHandler.removeWithLabel(label);\n\n            this._injectionsHandler.addWithLabel(label, [\n                Shell.App.prototype,\n                'activate',\n                IsolatedOverview\n            ]);\n\n            this._signalsHandler.removeWithLabel(label);\n\n            this._signalsHandler.addWithLabel(label, [\n                global.window_manager,\n                'switch-workspace',\n                () => this._panel.panelManager.allPanels.forEach(p => p.taskbar.handleIsolatedWorkspaceSwitch())\n            ]);\n        }\n\n        let disable = () => {\n            this._signalsHandler.removeWithLabel(label);\n            this._injectionsHandler.removeWithLabel(label);\n        }\n\n        function IsolatedOverview() {\n            // These lines take care of Nautilus for icons on Desktop\n            let activeWorkspace = Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace();\n            let windows = this.get_windows().filter(w => w.get_workspace().index() == activeWorkspace.index());\n\n            if (windows.length > 0 && \n                (!(windows.length == 1 && windows[0].skip_taskbar) || \n                 this.is_on_workspace(activeWorkspace)))\n                return Main.activateWindow(windows[0]);\n            \n            return this.open_new_window(-1);\n        }\n\n        this._signalsHandler.add([\n            SETTINGS,\n            'changed::isolate-workspaces',\n            () => {\n                this._panel.panelManager.allPanels.forEach(p => p.taskbar.resetAppIcons());\n\n                if (SETTINGS.get_boolean('isolate-workspaces'))\n                    enable();\n                else\n                    disable();\n            }\n        ]);\n\n        if (SETTINGS.get_boolean('isolate-workspaces'))\n            enable();\n    }\n\n    // Hotkeys\n    _activateApp(appIndex, modifiers) {\n        let seenApps = {};\n        let apps = [];\n        \n        this.taskbar._getAppIcons().forEach(appIcon => {\n            if (!seenApps[appIcon.app] || this.taskbar.allowSplitApps) {\n                apps.push(appIcon);\n            }\n\n            seenApps[appIcon.app] = (seenApps[appIcon.app] || 0) + 1;\n        });\n\n        this._showOverlay();\n\n        if (appIndex < apps.length) {\n            let appIcon = apps[appIndex];\n            let seenAppCount = seenApps[appIcon.app];\n            let windowCount = appIcon.window || appIcon._hotkeysCycle ? seenAppCount : appIcon._nWindows;\n\n            if (SETTINGS.get_boolean('shortcut-previews') && windowCount > 1 && \n                !(modifiers & ~(Clutter.ModifierType.MOD1_MASK | Clutter.ModifierType.SUPER_MASK))) { //ignore the alt (MOD1_MASK) and super key (SUPER_MASK)\n                if (this._hotkeyPreviewCycleInfo && this._hotkeyPreviewCycleInfo.appIcon != appIcon) {\n                    this._endHotkeyPreviewCycle();\n                }\n                \n                if (!this._hotkeyPreviewCycleInfo) {\n                    this._hotkeyPreviewCycleInfo = {\n                        appIcon: appIcon,\n                        currentWindow: appIcon.window,\n                        keyFocusOutId: appIcon.connect('key-focus-out', () => appIcon.grab_key_focus()),\n                        capturedEventId: global.stage.connect('captured-event', (actor, e) => {\n                            if (e.type() == Clutter.EventType.KEY_RELEASE && e.get_key_symbol() == (Clutter.KEY_Super_L || Clutter.Super_L)) {\n                                this._endHotkeyPreviewCycle(true);\n                            }\n        \n                            return Clutter.EVENT_PROPAGATE;\n                        })\n                    };\n\n                    appIcon._hotkeysCycle = appIcon.window;\n                    appIcon.window = null;\n                    appIcon._previewMenu.open(appIcon, true);\n                    appIcon.grab_key_focus();\n                }\n                \n                appIcon._previewMenu.focusNext();\n            } else {\n                // Activate with button = 1, i.e. same as left click\n                let button = 1;\n                this._endHotkeyPreviewCycle();\n                appIcon.activate(button, modifiers, !this.taskbar.allowSplitApps);\n            }\n        }\n    }\n\n    _endHotkeyPreviewCycle(focusWindow) {\n        if (this._hotkeyPreviewCycleInfo) {\n            global.stage.disconnect(this._hotkeyPreviewCycleInfo.capturedEventId);\n            this._hotkeyPreviewCycleInfo.appIcon.disconnect(this._hotkeyPreviewCycleInfo.keyFocusOutId);\n\n            if (focusWindow) {\n                this._hotkeyPreviewCycleInfo.appIcon._previewMenu.activateFocused();\n            } else\n                this._hotkeyPreviewCycleInfo.appIcon._previewMenu.close()\n\n            this._hotkeyPreviewCycleInfo.appIcon.window = this._hotkeyPreviewCycleInfo.currentWindow;\n            delete this._hotkeyPreviewCycleInfo.appIcon._hotkeysCycle;\n            this._hotkeyPreviewCycleInfo = 0;\n        }\n    }\n\n    _optionalHotKeys() {\n        this._hotKeysEnabled = false;\n        if (SETTINGS.get_boolean('hot-keys'))\n            this._enableHotKeys();\n\n        this._signalsHandler.add([\n            SETTINGS,\n            'changed::hot-keys',\n            () => {\n                if (SETTINGS.get_boolean('hot-keys'))\n                    this._enableHotKeys();\n                else\n                    this._disableHotKeys();\n            }\n        ]);\n    }\n\n    _resetHotkeys() {\n        this._disableHotKeys();\n        this._enableHotKeys();\n    }\n\n    _enableHotKeys() {\n        if (this._hotKeysEnabled)\n            return;\n\n        //3.32 introduced app hotkeys, disable them to prevent conflicts\n        if (Main.wm._switchToApplication) {\n            for (let i = 1; i < 10; ++i) {\n                Utils.removeKeybinding(GS_HOTKEYS_KEY + i);\n            }\n        }\n\n        // Setup keyboard bindings for taskbar elements\n        let shortcutNumKeys = SETTINGS.get_string('shortcut-num-keys');\n        let bothNumKeys = shortcutNumKeys == 'BOTH';\n        let keys = [];\n        let prefixModifiers = Clutter.ModifierType.SUPER_MASK\n\n        if (SETTINGS.get_string('hotkey-prefix-text') == 'SuperAlt')\n            prefixModifiers |= Clutter.ModifierType.MOD1_MASK\n        \n        if (bothNumKeys || shortcutNumKeys == 'NUM_ROW') {\n            keys.push('app-hotkey-', 'app-shift-hotkey-', 'app-ctrl-hotkey-'); // Regular numbers\n        }\n        \n        if (bothNumKeys || shortcutNumKeys == 'NUM_KEYPAD') {\n            keys.push('app-hotkey-kp-', 'app-shift-hotkey-kp-', 'app-ctrl-hotkey-kp-'); // Key-pad numbers\n        }\n\n        keys.forEach( function(key) {\n            let modifiers = prefixModifiers\n            \n            // for some reason, in gnome-shell >= 40 Clutter.get_current_event() is now empty\n            // for keyboard events. Create here the modifiers that are needed in appicon.activate \n            modifiers |= (key.indexOf('-shift-') >= 0 ? Clutter.ModifierType.SHIFT_MASK : 0)\n            modifiers |= (key.indexOf('-ctrl-') >= 0 ? Clutter.ModifierType.CONTROL_MASK : 0)\n\n            for (let i = 0; i < this._numHotkeys; i++) {\n                let appNum = i;\n\n                Utils.addKeybinding(key + (i + 1), SETTINGS, () => this._activateApp(appNum, modifiers));\n            }\n        }, this);\n\n        this._hotKeysEnabled = true;\n\n        if (SETTINGS.get_string('hotkeys-overlay-combo') === 'ALWAYS')\n            this.taskbar.toggleNumberOverlay(true);\n    }\n\n    _disableHotKeys() {\n        if (!this._hotKeysEnabled)\n            return;\n\n        let keys = ['app-hotkey-', 'app-shift-hotkey-', 'app-ctrl-hotkey-',  // Regular numbers\n                    'app-hotkey-kp-', 'app-shift-hotkey-kp-', 'app-ctrl-hotkey-kp-']; // Key-pad numbers\n        keys.forEach( function(key) {\n            for (let i = 0; i < this._numHotkeys; i++) {\n                Utils.removeKeybinding(key + (i + 1));\n            }\n        }, this);\n        \n        if (Main.wm._switchToApplication) {\n            let gsSettings = new Gio.Settings({ schema_id: WindowManager.SHELL_KEYBINDINGS_SCHEMA });\n\n            for (let i = 1; i < 10; ++i) {\n                Utils.addKeybinding(GS_HOTKEYS_KEY + i, gsSettings, Main.wm._switchToApplication.bind(Main.wm));\n            }\n        }\n\n        this._hotKeysEnabled = false;\n\n        this.taskbar.toggleNumberOverlay(false);\n    }\n\n    _optionalNumberOverlay() {\n        // Enable extra shortcut\n        if (SETTINGS.get_boolean('hot-keys'))\n            this._enableExtraShortcut();\n\n        this._signalsHandler.add([\n            SETTINGS,\n            'changed::hot-keys',\n            this._checkHotkeysOptions.bind(this)\n        ], [\n            SETTINGS,\n            'changed::hotkeys-overlay-combo',\n            () => {\n                if (SETTINGS.get_boolean('hot-keys') && SETTINGS.get_string('hotkeys-overlay-combo') === 'ALWAYS')\n                    this.taskbar.toggleNumberOverlay(true);\n                else\n                    this.taskbar.toggleNumberOverlay(false);\n            }\n        ], [\n            SETTINGS,\n            'changed::shortcut-num-keys',\n            () =>  this._resetHotkeys()\n        ]);\n    }\n\n    _checkHotkeysOptions() {\n        if (SETTINGS.get_boolean('hot-keys'))\n            this._enableExtraShortcut();\n        else\n            this._disableExtraShortcut();\n    }\n\n    _enableExtraShortcut() {\n        Utils.addKeybinding('shortcut', SETTINGS, () => this._showOverlay(true));\n    }\n\n    _disableExtraShortcut() {\n        Utils.removeKeybinding('shortcut');\n    }\n\n    _showOverlay(overlayFromShortcut) {\n        //wait for intellihide timeout initialization\n        if (!this._panel.intellihide) {\n            return;\n        }\n\n        // Restart the counting if the shortcut is pressed again\n        let hotkey_option = SETTINGS.get_string('hotkeys-overlay-combo');\n\n        if (hotkey_option === 'NEVER')\n            return;\n\n        if (hotkey_option === 'TEMPORARILY' || overlayFromShortcut)\n            this.taskbar.toggleNumberOverlay(true);\n\n        this._panel.intellihide.revealAndHold(Intellihide.Hold.TEMPORARY);\n\n        let timeout = SETTINGS.get_int('overlay-timeout');\n        \n        if (overlayFromShortcut) {\n            timeout = SETTINGS.get_int('shortcut-timeout');\n        }\n\n        // Hide the overlay/dock after the timeout\n        this._timeoutsHandler.add([T2, timeout, () => {\n            if (hotkey_option != 'ALWAYS') {\n                this.taskbar.toggleNumberOverlay(false);\n            }\n            \n            this._panel.intellihide.release(Intellihide.Hold.TEMPORARY);\n        }]);\n    }\n\n    _optionalClickToExit() {\n        this._clickToExitEnabled = false;\n        if (SETTINGS.get_boolean('overview-click-to-exit'))\n            this._enableClickToExit();\n\n        this._signalsHandler.add([\n            SETTINGS,\n            'changed::overview-click-to-exit',\n            () => {\n                if (SETTINGS.get_boolean('overview-click-to-exit'))\n                    this._enableClickToExit();\n                else\n                    this._disableClickToExit();\n            }\n        ]);\n    }\n\n    _enableClickToExit() {\n        if (this._clickToExitEnabled)\n            return;\n\n        this._signalsHandler.addWithLabel('click-to-exit', [\n            Main.layoutManager.overviewGroup,\n            'button-release-event',\n            () => {\n                let [x, y] = global.get_pointer();\n                let pickedActor = global.stage.get_actor_at_pos(Clutter.PickMode.REACTIVE, x, y);\n                \n                if (pickedActor) {\n                    let parent = pickedActor.get_parent();\n\n                    if (\n                        (\n                         pickedActor.has_style_class_name &&\n                         pickedActor.has_style_class_name('apps-scroll-view') &&\n                         !pickedActor.has_style_pseudo_class('first-child')\n                        ) || (\n                         parent?.has_style_class_name &&\n                         parent.has_style_class_name('window-picker')\n                        ) ||\n                        Main.overview._overview._controls._searchEntryBin.contains(pickedActor) ||\n                        pickedActor instanceof WindowPreview\n                    )\n                        return Clutter.EVENT_PROPAGATE\n                } \n\n                Main.overview.toggle()\n            }\n        ]);\n\n        this._clickToExitEnabled = true;\n    }\n\n    _disableClickToExit() {\n        if (!this._clickToExitEnabled)\n            return;\n        \n        this._signalsHandler.removeWithLabel('click-to-exit')\n\n        this._clickToExitEnabled = false;\n    }\n\n    _onSwipeBegin() {\n        this._swiping = true;\n        return true;\n    }\n\n    _onSwipeEnd() {\n        this._timeoutsHandler.add([\n            T1,\n            0, \n            () => this._swiping = false\n        ]);\n        return true;\n    }\n\n}\n"
        },
        {
          "name": "panel.js",
          "type": "blob",
          "size": 48.66015625,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Credits:\n * This file is based on code from the Dash to Dock extension by micheleg\n * and code from the Taskbar extension by Zorin OS\n * \n * Code to re-anchor the panel was taken from Thoma5 BottomPanel:\n * https://github.com/Thoma5/gnome-shell-extension-bottompanel\n * \n * Pattern for moving clock based on Frippery Move Clock by R M Yorston\n * http://frippery.org/extensions/\n * \n * Some code was also adapted from the upstream Gnome Shell source code.\n */\n\nimport Clutter from 'gi://Clutter';\nimport GObject from 'gi://GObject';\nimport * as AppIcons from './appIcons.js';\nimport * as Utils from './utils.js';\nimport * as Taskbar from './taskbar.js';\nimport * as TaskbarItemContainer from './taskbar.js';\nimport * as Pos from './panelPositions.js';\nimport * as PanelSettings from './panelSettings.js';\nimport * as PanelStyle from './panelStyle.js';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as Dash from 'resource:///org/gnome/shell/ui/dash.js';\nimport * as CtrlAltTab from 'resource:///org/gnome/shell/ui/ctrlAltTab.js';\nimport * as PanelMenu from 'resource:///org/gnome/shell/ui/panelMenu.js';\nimport St from 'gi://St';\nimport Meta from 'gi://Meta';\nimport Pango from 'gi://Pango';\nimport * as DND from 'resource:///org/gnome/shell/ui/dnd.js';\nimport Shell from 'gi://Shell';\nimport * as PopupMenu from 'resource:///org/gnome/shell/ui/popupMenu.js';\nimport * as DateMenu from 'resource:///org/gnome/shell/ui/dateMenu.js';\nimport * as Volume from 'resource:///org/gnome/shell/ui/status/volume.js';\nimport * as Progress from './progress.js';\n\nimport * as Intellihide from './intellihide.js';\nimport * as Transparency from './transparency.js';\nimport {SETTINGS, DESKTOPSETTINGS, PERSISTENTSTORAGE} from './extension.js';\nimport {gettext as _, InjectionManager} from 'resource:///org/gnome/shell/extensions/extension.js';\n\nlet tracker = Shell.WindowTracker.get_default();\nexport const panelBoxes = ['_leftBox', '_centerBox', '_rightBox'];\n\n//timeout names\nconst T2 = 'startIntellihideTimeout';\nconst T4 = 'showDesktopTimeout';\nconst T5 = 'trackerFocusAppTimeout';\nconst T6 = 'scrollPanelDelayTimeout';\nconst T7 = 'waitPanelBoxAllocation';\n\nexport const Panel = GObject.registerClass({\n}, class Panel extends St.Widget {\n\n    _init(panelManager, monitor, panelBox, isStandalone) {\n        super._init({ layout_manager: new Clutter.BinLayout() });\n\n        this._timeoutsHandler = new Utils.TimeoutsHandler();\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._injectionManager = new InjectionManager();\n\n        this.panelManager = panelManager;\n        this.panelStyle = new PanelStyle.PanelStyle();\n\n        this.monitor = monitor;\n        this.panelBox = panelBox;\n\n        // when the original gnome-shell top panel is kept, all panels are \"standalone\",\n        // so in this case use isPrimary to get the panel on the primary dtp monitor, which\n        // might be different from the system's primary monitor.\n        this.isStandalone = isStandalone;\n        this.isPrimary = !isStandalone || (SETTINGS.get_boolean('stockgs-keep-top-panel') && \n                                           monitor == panelManager.dtpPrimaryMonitor);\n\n        this._sessionStyle = null;\n        this._unmappedButtons = [];\n        this._elementGroups = [];\n\n        let systemMenuInfo = Utils.getSystemMenuInfo();\n\n        if (isStandalone) {\n            this.panel = new SecondaryPanel({ name: 'panel', reactive: true });\n            this.statusArea = this.panel.statusArea = {};\n\n            //next 3 functions are needed by other extensions to add elements to the secondary panel\n            this.panel.addToStatusArea = function(role, indicator, position, box) {\n                return Main.panel.addToStatusArea.call(this, role, indicator, position, box);\n            };\n\n            this.panel._addToPanelBox = function(role, indicator, position, box) {\n                Main.panel._addToPanelBox.call(this, role, indicator, position, box);\n            };\n\n            this.panel._onMenuSet = function(indicator) {\n                Main.panel._onMenuSet.call(this, indicator);\n            };\n\n            this._leftBox = this.panel._leftBox = new St.BoxLayout({ name: 'panelLeft' });\n            this._centerBox = this.panel._centerBox = new St.BoxLayout({ name: 'panelCenter' });\n            this._rightBox = this.panel._rightBox = new St.BoxLayout({ name: 'panelRight' });\n\n            this.menuManager = this.panel.menuManager = new PopupMenu.PopupMenuManager(this.panel);\n\n            this._setPanelMenu(systemMenuInfo.name, systemMenuInfo.constructor, this.panel);\n            this._setPanelMenu('dateMenu', DateMenu.DateMenuButton, this.panel);\n            this._setPanelMenu('activities', Main.panel.statusArea.activities.constructor, this.panel);\n\n            this.panel.add_child(this._leftBox);\n            this.panel.add_child(this._centerBox);\n            this.panel.add_child(this._rightBox);\n        } else {\n            this.panel = Main.panel;\n            this.statusArea = Main.panel.statusArea;\n            this.menuManager = Main.panel.menuManager;\n\n            panelBoxes.forEach(p => this[p] = Main.panel[p]);\n\n            ['activities', systemMenuInfo.name, 'dateMenu'].forEach(b => {\n                let container = this.statusArea[b].container;\n                let parent = container.get_parent();\n                let siblings = parent.get_children();\n                let index = siblings.indexOf(container);\n\n                container._dtpOriginalParent = parent;\n                container._dtpOriginalIndex = index && index == siblings.length - 1 ? -1: index;\n                parent ? parent.remove_child(container) : null;\n                this.panel.add_child(container);\n            });\n        }\n\n        // Create a wrapper around the real showAppsIcon in order to add a popupMenu. Most of \n        // its behavior is handled by the taskbar, but its positioning is done at the panel level\n        this.showAppsIconWrapper = new AppIcons.ShowAppsIconWrapper(this);\n        this.panel.add_child(this.showAppsIconWrapper.realShowAppsIcon);\n\n        this.panel._delegate = this;\n        \n        this.add_child(this.panel);\n\n        if (Main.panel._onButtonPress || Main.panel._tryDragWindow) {\n            this._signalsHandler.add([\n                this.panel, \n                [\n                    'button-press-event', \n                    'touch-event'\n                ],\n                this._onButtonPress.bind(this)\n            ]);\n        }\n\n        if (Main.panel._onKeyPress) {\n            this._signalsHandler.add([this.panel, 'key-press-event', Main.panel._onKeyPress.bind(this)]);\n        }\n       \n        Main.ctrlAltTabManager.addGroup(this, _(\"Top Bar\")+\" \"+ monitor.index, 'focus-top-bar-symbolic',\n                                        { sortGroup: CtrlAltTab.SortGroup.TOP });\n    }\n\n    enable () {\n        let { name: systemMenuName } = Utils.getSystemMenuInfo();\n\n        if (this.statusArea[systemMenuName] && this.statusArea[systemMenuName]._volumeOutput) {\n            Utils.getIndicators(this.statusArea[systemMenuName]._volumeOutput)._dtpIgnoreScroll = 1;\n        }\n\n        this.geom = this.getGeometry();\n        \n        this._setPanelPosition();\n\n        if (!this.isStandalone) {\n            this._injectionManager.overrideMethod(Object.getPrototypeOf(this.panel), 'vfunc_allocate', () => (box) => this._mainPanelAllocate(box));\n\n            // remove the extra space before the clock when the message-indicator is displayed\n            if (DateMenu.IndicatorPad) {\n                this._injectionManager.overrideMethod(DateMenu.IndicatorPad.prototype, 'vfunc_get_preferred_width', () => () => [0,0]);\n                this._injectionManager.overrideMethod(DateMenu.IndicatorPad.prototype, 'vfunc_get_preferred_height', () => () => [0,0]);\n            }\n        }\n\n        if (!DateMenu.IndicatorPad && this.statusArea.dateMenu) {\n            //3.36 switched to a size constraint applied on an anonymous child\n            let indicatorPad = this.statusArea.dateMenu.get_first_child().get_first_child();\n\n            this._dateMenuIndicatorPadContraints = indicatorPad.get_constraints();\n            indicatorPad.clear_constraints();\n        }\n\n        this.menuManager._oldChangeMenu = this.menuManager._changeMenu;\n        this.menuManager._changeMenu = (menu) => {\n            if (!SETTINGS.get_boolean('stockgs-panelbtn-click-only')) {\n                this.menuManager._oldChangeMenu(menu);\n            }\n        };\n\n        this.dynamicTransparency = new Transparency.DynamicTransparency(this);\n        \n        this.taskbar = new Taskbar.Taskbar(this);\n\n        this.panel.add_child(this.taskbar.actor);\n\n        this._setShowDesktopButton(true);\n        \n        this._setAllocationMap();\n\n        this.panel.add_style_class_name('dashtopanelMainPanel ' + this.getOrientation());\n\n        this._timeoutsHandler.add([T2, SETTINGS.get_int('intellihide-enable-start-delay'), () => this.intellihide = new Intellihide.Intellihide(this)]);\n\n        this._signalsHandler.add(\n            // this is to catch changes to the theme or window scale factor\n            [\n                Utils.getStageTheme(), \n                'changed', \n                () => (this._resetGeometry(), this._setShowDesktopButtonStyle()),\n            ],\n            [\n                // sync hover after a popupmenu is closed\n                this.taskbar,\n                'menu-closed', \n                () => this.panel.sync_hover()\n            ],\n            [\n                Main.overview,\n                [\n                    'showing',\n                    'hiding'\n                ],\n                () => this._adjustForOverview()\n            ],\n            [\n                Main.overview,\n                'hidden',\n                () => {\n                    if (this.isPrimary) {\n                        //reset the primary monitor when exiting the overview\n                        this.panelManager.setFocusedMonitor(this.monitor);\n                    }\n                }\n            ],\n            [\n                this.statusArea.activities,\n                'captured-event', \n                (actor, e) => {\n                    if (e.type() == Clutter.EventType.BUTTON_PRESS || e.type() == Clutter.EventType.TOUCH_BEGIN) {\n                        //temporarily use as primary the monitor on which the activities btn was clicked \n                        this.panelManager.setFocusedMonitor(this.monitor);\n                    }\n                }\n            ],\n            [\n                this._centerBox,\n                'child-added',\n                () => this._onBoxActorAdded(this._centerBox)\n            ],\n            [\n                this._rightBox,\n                'child-added',\n                () => this._onBoxActorAdded(this._rightBox)\n            ],\n            [\n                this.panel,\n                'scroll-event',\n                this._onPanelMouseScroll.bind(this)\n            ],\n            [\n                Main.layoutManager,\n                'startup-complete',\n                () => this._resetGeometry()\n            ]\n        );\n\n        this._bindSettingsChanges();\n\n        this.panelStyle.enable(this);\n\n        if (this.checkIfVertical()) {\n            this._signalsHandler.add([\n                this.panelBox,\n                'notify::visible',\n                () => {\n                    if (this.panelBox.visible) {\n                        this._refreshVerticalAlloc();\n                    }\n                }\n            ]);\n\n            if (this.statusArea.dateMenu) {\n                this._formatVerticalClock();\n                \n                this._signalsHandler.add([\n                    this.statusArea.dateMenu._clock,\n                    'notify::clock',\n                    () => this._formatVerticalClock()\n                ]);\n            }\n        }\n\n        // Since we are usually visible but not usually changing, make sure\n        // most repaint requests don't actually require us to repaint anything.\n        // This saves significant CPU when repainting the screen.\n        this.set_offscreen_redirect(Clutter.OffscreenRedirect.ALWAYS);\n\n        this._initProgressManager();\n    }\n\n    disable() {\n        this.panelStyle.disable();\n\n        this._timeoutsHandler.destroy();\n        this._signalsHandler.destroy();\n        \n        this.panel.remove_child(this.taskbar.actor);\n\n        if (this.intellihide) {\n            this.intellihide.destroy();\n        }\n\n        this.dynamicTransparency.destroy();\n\n        this.progressManager.destroy();\n\n        this.taskbar.destroy();\n        this.showAppsIconWrapper.destroy();\n\n        this.menuManager._changeMenu = this.menuManager._oldChangeMenu;\n\n        this._unmappedButtons.forEach(a => this._disconnectVisibleId(a));\n\n        if (this.statusArea.dateMenu) {\n            this.statusArea.dateMenu._clockDisplay.text = this.statusArea.dateMenu._clock.clock;\n            this.statusArea.dateMenu._clockDisplay.clutter_text.set_width(-1);\n\n            if (this._dateMenuIndicatorPadContraints) {\n                let indicatorPad = this.statusArea.dateMenu.get_first_child().get_first_child();\n\n                this._dateMenuIndicatorPadContraints.forEach(c => indicatorPad.add_constraint(c));\n            }\n        }\n\n        this._setVertical(this.panel, false);\n        this._setVertical(this._centerBox, false);\n        this._setVertical(this._rightBox, false);\n\n        let { name: systemMenuName } = Utils.getSystemMenuInfo();\n\n        if (!this.isStandalone) {\n            ['vertical', 'horizontal', 'dashtopanelMainPanel'].forEach(c => this.panel.remove_style_class_name(c));\n\n            if (!Main.sessionMode.isLocked) {\n                ['activities', systemMenuName, 'dateMenu'].forEach(b => {\n                    let container = this.statusArea[b].container;\n                    let originalParent = container._dtpOriginalParent;\n    \n                    this.panel.remove_child(container);\n\n                    originalParent && originalParent.insert_child_at_index(\n                        container, \n                        Math.min(container._dtpOriginalIndex, originalParent.get_children().length - 1)\n                    );\n                    \n                    delete container._dtpOriginalParent;\n                    delete container._dtpOriginalIndex;\n                });\n            }\n\n            this._setShowDesktopButton(false);\n\n            delete Utils.getIndicators(this.statusArea[systemMenuName]._volumeOutput)._dtpIgnoreScroll;\n\n            this._injectionManager.clear();\n            \n            this.panel._delegate = this.panel;\n        } else {\n            this._removePanelMenu('dateMenu');\n            this._removePanelMenu(systemMenuName);\n            this._removePanelMenu('activities');\n        }\n\n        Main.ctrlAltTabManager.removeGroup(this);\n    }\n\n    getPosition() {\n        let position = PanelSettings.getPanelPosition(SETTINGS, this.monitor.index);\n\n        if (position == Pos.TOP) {\n            return St.Side.TOP;\n        } else if (position == Pos.RIGHT) {\n            return St.Side.RIGHT;\n        } else if (position == Pos.BOTTOM) {\n            return St.Side.BOTTOM;\n        }\n        \n        return St.Side.LEFT;\n    }\n\n    checkIfVertical() {\n        let position = this.getPosition();\n    \n        return (position == St.Side.LEFT || position == St.Side.RIGHT);\n    }\n    \n    getOrientation() {\n        return (this.checkIfVertical() ? 'vertical' : 'horizontal');\n    }\n\n    updateElementPositions() {\n        let panelPositions = this.panelManager.panelsElementPositions[this.monitor.index] || Pos.defaults;\n\n        this._updateGroupedElements(panelPositions);\n\n        this.panel.hide();\n        this.panel.show();\n    }\n\n    _updateGroupedElements(panelPositions) {\n        let previousPosition = 0;\n        let previousCenteredPosition = 0;\n        let currentGroup = -1;\n\n        this._elementGroups = [];\n\n        panelPositions.forEach(pos => {\n            let allocationMap = this.allocationMap[pos.element];\n\n            if (allocationMap.actor) {\n                allocationMap.actor.visible = pos.visible;\n\n                if (!pos.visible) {\n                    return;\n                }\n\n                let currentPosition = pos.position;\n                let isCentered = Pos.checkIfCentered(currentPosition);\n\n                if (currentPosition == Pos.STACKED_TL && previousPosition == Pos.STACKED_BR) {\n                    currentPosition = Pos.STACKED_BR;\n                }\n\n                if (!previousPosition || \n                    (previousPosition == Pos.STACKED_TL && currentPosition != Pos.STACKED_TL) ||\n                    (previousPosition != Pos.STACKED_BR && currentPosition == Pos.STACKED_BR) ||\n                    (isCentered && previousPosition != currentPosition && previousPosition != Pos.STACKED_BR)) {\n                    this._elementGroups[++currentGroup] = { elements: [], index: this._elementGroups.length, expandableIndex: -1 };\n                    previousCenteredPosition = 0;\n                }\n\n                if (pos.element == Pos.TASKBAR) {\n                    this._elementGroups[currentGroup].expandableIndex = this._elementGroups[currentGroup].elements.length;\n                }\n\n                if (isCentered && !this._elementGroups[currentGroup].isCentered) {\n                    this._elementGroups[currentGroup].isCentered = 1;\n                    previousCenteredPosition = currentPosition;\n                }\n\n                this._elementGroups[currentGroup].position = previousCenteredPosition || currentPosition;\n                this._elementGroups[currentGroup].elements.push(allocationMap);\n\n                allocationMap.position = currentPosition;\n                previousPosition = currentPosition;\n            }\n        });\n    }\n\n    _bindSettingsChanges() {\n        let isVertical = this.checkIfVertical();\n\n        this._signalsHandler.add(\n            [\n                SETTINGS,\n                [\n                    'changed::panel-sizes',\n                    'changed::group-apps'\n                ],\n                () => this._resetGeometry()\n            ],\n            [\n                SETTINGS,\n                [\n                    'changed::appicon-margin',\n                    'changed::appicon-padding'\n                ],\n                () => this.taskbar.resetAppIcons()\n            ],\n            [\n                SETTINGS,\n                [\n                    'changed::showdesktop-button-width',\n                    'changed::trans-use-custom-bg',\n                    'changed::desktop-line-use-custom-color',\n                    'changed::desktop-line-custom-color',\n                    'changed::trans-bg-color'\n                ],\n                () => this._setShowDesktopButtonStyle()\n            ],\n            [\n                DESKTOPSETTINGS,\n                'changed::clock-format',\n                () => {\n                    this._clockFormat = null;\n                    \n                    if (isVertical) {\n                        this._formatVerticalClock();\n                    }\n                }\n            ],\n            [\n                SETTINGS,\n                'changed::progress-show-bar',\n                () => this._initProgressManager()\n            ],\n            [\n                SETTINGS,\n                'changed::progress-show-count',\n                () => this._initProgressManager()\n            ]\n        );\n\n        if (isVertical) {\n            this._signalsHandler.add([SETTINGS, 'changed::group-apps-label-max-width', () => this._resetGeometry()]);\n        }\n    }\n\n    _setPanelMenu(propName, constr, container) {\n        if (!this.statusArea[propName]) {\n            this.statusArea[propName] = this._getPanelMenu(propName, constr);\n            this.menuManager.addMenu(this.statusArea[propName].menu);\n            container.insert_child_at_index(this.statusArea[propName].container, 0);\n        }\n    }\n    \n    _removePanelMenu(propName) {\n        if (this.statusArea[propName]) {\n            let parent = this.statusArea[propName].container.get_parent();\n\n            if (parent) {\n                parent.remove_child(this.statusArea[propName].container);\n            }\n\n            //calling this.statusArea[propName].destroy(); is buggy for now, gnome-shell never\n            //destroys those panel menus...\n            //since we can't destroy the menu (hence properly disconnect its signals), let's \n            //store it so the next time a panel needs one of its kind, we can reuse it instead \n            //of creating a new one\n            let panelMenu = this.statusArea[propName];\n\n            this.menuManager.removeMenu(panelMenu.menu);\n            PERSISTENTSTORAGE[propName].push(panelMenu);\n            this.statusArea[propName] = null;\n        }\n    }\n\n    _getPanelMenu(propName, constr) {\n        PERSISTENTSTORAGE[propName] = PERSISTENTSTORAGE[propName] || [];\n\n        if (!PERSISTENTSTORAGE[propName].length) {\n            PERSISTENTSTORAGE[propName].push(new constr());\n        }\n\n        return PERSISTENTSTORAGE[propName].pop();\n    }\n\n    _adjustForOverview() {\n        let isFocusedMonitor = this.panelManager.checkIfFocusedMonitor(this.monitor);\n        let isOverview = !!Main.overview.visibleTarget;\n        let isOverviewFocusedMonitor = isOverview && isFocusedMonitor;\n        let isShown = !isOverview || isOverviewFocusedMonitor;\n        let actorData = Utils.getTrackedActorData(this.panelBox)\n\n        // prevent the \"chrome\" to update the panelbox visibility while in overview\n        actorData.trackFullscreen = !isOverview\n\n        this.panelBox[isShown ? 'show' : 'hide']();\n    }\n\n    _resetGeometry() {\n        this.geom = this.getGeometry();\n        this._setPanelPosition();\n        this.taskbar.resetAppIcons(true);\n        this.dynamicTransparency.updateExternalStyle();\n\n        if (this.intellihide && this.intellihide.enabled) {\n            this.intellihide.reset();\n        }\n\n        if (this.checkIfVertical()) {\n            this.showAppsIconWrapper.realShowAppsIcon.toggleButton.set_width(this.geom.w);\n            this._refreshVerticalAlloc();\n        }\n    }\n\n    getGeometry() {\n        let scaleFactor = Utils.getScaleFactor();\n        let panelBoxTheme = this.panelBox.get_theme_node();\n        let lrPadding = panelBoxTheme.get_padding(St.Side.RIGHT) + panelBoxTheme.get_padding(St.Side.LEFT);\n        let topPadding = panelBoxTheme.get_padding(St.Side.TOP);\n        let tbPadding = topPadding + panelBoxTheme.get_padding(St.Side.BOTTOM);\n        let position = this.getPosition();\n        let length = PanelSettings.getPanelLength(SETTINGS, this.monitor.index) / 100;\n        let anchor = PanelSettings.getPanelAnchor(SETTINGS, this.monitor.index);\n        let anchorPlaceOnMonitor = 0;\n        let gsTopPanelOffset = 0;\n        let x = 0, y = 0;\n        let w = 0, h = 0;\n\n        const panelSize = PanelSettings.getPanelSize(SETTINGS, this.monitor.index);\n        this.dtpSize = panelSize * scaleFactor;\n\n        if (SETTINGS.get_boolean('stockgs-keep-top-panel') && Main.layoutManager.primaryMonitor == this.monitor) {\n            gsTopPanelOffset = Main.layoutManager.panelBox.height - topPadding;\n        }\n\n        if (this.checkIfVertical()) {\n            if (!SETTINGS.get_boolean('group-apps')) {\n                // add window title width and side padding of _dtpIconContainer when vertical\n                this.dtpSize += SETTINGS.get_int('group-apps-label-max-width') + AppIcons.DEFAULT_PADDING_SIZE * 2 / scaleFactor;\n            }\n\n            this.sizeFunc = 'get_preferred_height',\n            this.fixedCoord = { c1: 'x1', c2: 'x2' }\n            this.varCoord = { c1: 'y1', c2: 'y2' };\n\n            w = this.dtpSize;\n            h = this.monitor.height * length - tbPadding - gsTopPanelOffset;\n        } else {\n            this.sizeFunc = 'get_preferred_width';\n            this.fixedCoord = { c1: 'y1', c2: 'y2' };\n            this.varCoord = { c1: 'x1', c2: 'x2' };\n\n            w = this.monitor.width * length - lrPadding;\n            h = this.dtpSize;\n        }\n\n        if (position == St.Side.TOP || position == St.Side.LEFT) {\n            x = this.monitor.x;\n            y = this.monitor.y + gsTopPanelOffset;\n        } else if (position == St.Side.RIGHT) {\n            x = this.monitor.x + this.monitor.width - this.dtpSize - lrPadding;\n            y = this.monitor.y + gsTopPanelOffset;\n        } else { //BOTTOM\n            x = this.monitor.x;\n            y = this.monitor.y + this.monitor.height - this.dtpSize - tbPadding;\n        }\n\n        if (this.checkIfVertical()) {\n            let viewHeight = this.monitor.height - gsTopPanelOffset;\n            \n            if (anchor === Pos.MIDDLE) {\n                anchorPlaceOnMonitor = (viewHeight - h) / 2;\n            } else if (anchor === Pos.END) {\n                anchorPlaceOnMonitor = viewHeight - h;\n            } else { // Pos.START\n                anchorPlaceOnMonitor = 0;\n            }\n            y = y + anchorPlaceOnMonitor;\n        } else {\n            if (anchor === Pos.MIDDLE) {\n                anchorPlaceOnMonitor = (this.monitor.width - w) / 2;\n            } else if (anchor === Pos.END) {\n                anchorPlaceOnMonitor = this.monitor.width - w;\n            } else { // Pos.START\n                anchorPlaceOnMonitor = 0;\n            }\n            x = x + anchorPlaceOnMonitor;\n        }\n\n        return {\n            x, y, \n            w, h,\n            lrPadding,\n            tbPadding,\n            position\n        };\n    }\n\n    _setAllocationMap() {\n        this.allocationMap = {};\n        let setMap = (name, actor) => this.allocationMap[name] = { \n            actor: actor,\n            box: new Clutter.ActorBox() \n        };\n        \n        setMap(Pos.SHOW_APPS_BTN, this.showAppsIconWrapper.realShowAppsIcon);\n        setMap(Pos.ACTIVITIES_BTN, this.statusArea.activities ? this.statusArea.activities.container : 0);\n        setMap(Pos.LEFT_BOX, this._leftBox);\n        setMap(Pos.TASKBAR, this.taskbar.actor);\n        setMap(Pos.CENTER_BOX, this._centerBox);\n        setMap(Pos.DATE_MENU, this.statusArea.dateMenu.container);\n        setMap(Pos.SYSTEM_MENU, this.statusArea[Utils.getSystemMenuInfo().name].container);\n        setMap(Pos.RIGHT_BOX, this._rightBox);\n        setMap(Pos.DESKTOP_BTN, this._showDesktopButton);\n    }\n\n    _mainPanelAllocate(box) {\n        this.panel.set_allocation(box);\n    }\n\n    vfunc_allocate(box) {\n        this.set_allocation(box);\n\n        let fixed = 0;\n        let centeredMonitorGroup;\n        let panelAlloc = new Clutter.ActorBox({ x1: 0, y1: 0, x2: this.geom.w, y2: this.geom.h });\n        let assignGroupSize = (group, update) => {\n            group.size = 0;\n            group.tlOffset = 0;\n            group.brOffset = 0;\n\n            group.elements.forEach(element => {\n                if (!update) {\n                    element.box[this.fixedCoord.c1] = panelAlloc[this.fixedCoord.c1];\n                    element.box[this.fixedCoord.c2] = panelAlloc[this.fixedCoord.c2];\n                    element.natSize = element.actor[this.sizeFunc](-1)[1];\n                }\n\n                if (!group.isCentered || Pos.checkIfCentered(element.position)) {\n                    group.size += element.natSize;\n                } else if (element.position == Pos.STACKED_TL) {\n                    group.tlOffset += element.natSize;\n                } else { // Pos.STACKED_BR\n                    group.brOffset += element.natSize;\n                }\n            });\n\n            if (group.isCentered) {\n                group.size += Math.max(group.tlOffset, group.brOffset) * 2;\n                group.tlOffset = Math.max(group.tlOffset - group.brOffset, 0);\n            }\n        };\n        let allocateGroup = (group, tlLimit, brLimit) => {\n            let startPosition = tlLimit;\n            let currentPosition = 0;\n\n            if (group.expandableIndex >= 0) {\n                let availableSize = brLimit - tlLimit;\n                let expandable = group.elements[group.expandableIndex];\n                let i = 0;\n                let l = this._elementGroups.length;\n                let tlSize = 0;\n                let brSize = 0;\n\n                if (centeredMonitorGroup && (centeredMonitorGroup != group || expandable.position != Pos.CENTERED_MONITOR)) {\n                    if (centeredMonitorGroup.index < group.index || (centeredMonitorGroup == group && expandable.position == Pos.STACKED_TL)) {\n                        i = centeredMonitorGroup.index;\n                    } else {\n                        l = centeredMonitorGroup.index;\n                    }\n                }\n\n                for (; i < l; ++i) {\n                    let refGroup = this._elementGroups[i];\n\n                    if (i < group.index && (!refGroup.fixed || refGroup[this.varCoord.c2] > tlLimit)) {\n                        tlSize += refGroup.size;\n                    } else if (i > group.index && (!refGroup.fixed || refGroup[this.varCoord.c1] < brLimit)) {\n                        brSize += refGroup.size;\n                    }\n                }\n                \n                if (group.isCentered) {\n                    availableSize -= Math.max(tlSize, brSize) * 2;\n                } else {\n                    availableSize -= tlSize + brSize;\n                }\n                \n                if (availableSize < group.size) {\n                    expandable.natSize -= (group.size - availableSize) * (group.isCentered && !Pos.checkIfCentered(expandable.position) ? .5 : 1);\n                    assignGroupSize(group, true);\n                }\n            }\n            \n            if (group.isCentered) {\n                startPosition = tlLimit + (brLimit - tlLimit - group.size) * .5;\n            } else if (group.position == Pos.STACKED_BR) {\n                startPosition = brLimit - group.size;\n            }\n\n            currentPosition = group.tlOffset + startPosition;\n\n            group.elements.forEach(element => {\n                element.box[this.varCoord.c1] = Math.round(currentPosition);\n                element.box[this.varCoord.c2] = Math.round((currentPosition += element.natSize));\n\n                element.actor.allocate(element.box);\n            });\n\n            group[this.varCoord.c1] = startPosition;\n            group[this.varCoord.c2] = currentPosition;\n            group.fixed = 1;\n            ++fixed;\n        };\n\n        this.panel.allocate(panelAlloc);\n\n        this._elementGroups.forEach(group => {\n            group.fixed = 0;\n\n            assignGroupSize(group);\n\n            if (group.position == Pos.CENTERED_MONITOR) {\n                centeredMonitorGroup = group;\n            }\n        });\n\n        if (centeredMonitorGroup) {\n            allocateGroup(centeredMonitorGroup, panelAlloc[this.varCoord.c1], panelAlloc[this.varCoord.c2]);\n        }\n\n        let iterations = 0; //failsafe\n        while (fixed < this._elementGroups.length && ++iterations < 10) {\n            for (let i = 0, l = this._elementGroups.length; i < l; ++i) {\n                let group = this._elementGroups[i];\n\n                if (group.fixed) {\n                    continue;\n                }\n\n                let prevGroup = this._elementGroups[i - 1];\n                let nextGroup = this._elementGroups[i + 1];\n                let prevLimit = prevGroup && prevGroup.fixed ? prevGroup[this.varCoord.c2] : \n                                    centeredMonitorGroup && group.index > centeredMonitorGroup.index ? centeredMonitorGroup[this.varCoord.c2] : panelAlloc[this.varCoord.c1];\n                let nextLimit = nextGroup && nextGroup.fixed ? nextGroup[this.varCoord.c1] : \n                                    centeredMonitorGroup && group.index < centeredMonitorGroup.index ? centeredMonitorGroup[this.varCoord.c1] : panelAlloc[this.varCoord.c2];\n\n                if (group.position == Pos.STACKED_TL) {\n                    allocateGroup(group, panelAlloc[this.varCoord.c1], nextLimit);\n                } else if (group.position == Pos.STACKED_BR) {\n                    allocateGroup(group, prevLimit, panelAlloc[this.varCoord.c2]);\n                } else if ((!prevGroup || prevGroup.fixed) && (!nextGroup || nextGroup.fixed)) { // CENTERED\n                    allocateGroup(group, prevLimit, nextLimit);\n                }\n            }\n        }\n    }\n\n    _setPanelPosition() {\n        let clipContainer = this.panelBox.get_parent();\n\n        this.set_size(this.geom.w, this.geom.h);\n        clipContainer.set_position(this.geom.x, this.geom.y);\n\n        this._setVertical(this.panel, this.checkIfVertical());\n\n        // styles for theming\n        Object.keys(St.Side).forEach(p => {\n            let cssName = 'dashtopanel' + p.charAt(0) + p.slice(1).toLowerCase();\n            \n            this.panel[(St.Side[p] == this.geom.position ? 'add' : 'remove') + '_style_class_name'](cssName);\n        });\n\n        this._setPanelClip(clipContainer);\n\n        Main.layoutManager._updateHotCorners();\n        Main.layoutManager._updatePanelBarrier(this);\n    }\n\n    _setPanelClip(clipContainer) {\n        clipContainer = clipContainer || this.panelBox.get_parent();\n        this._timeoutsHandler.add([T7, 0, () => Utils.setClip(clipContainer, clipContainer.x, clipContainer.y, this.panelBox.width, this.panelBox.height)]);\n    }\n\n    _onButtonPress(actor, event) {\n        let type = event.type();\n        let isPress = type == Clutter.EventType.BUTTON_PRESS;\n        let button = isPress ? event.get_button() : -1;\n        let [stageX, stageY] = event.get_coords();\n\n        if (button == 3 && global.stage.get_actor_at_pos(Clutter.PickMode.REACTIVE, stageX, stageY) == this.panel) {\n            //right click on an empty part of the panel, temporarily borrow and display the showapps context menu\n            Main.layoutManager.setDummyCursorGeometry(stageX, stageY, 0, 0);\n\n            this.showAppsIconWrapper.createMenu();\n            this.showAppsIconWrapper.popupMenu(Main.layoutManager.dummyCursor);\n\n            return Clutter.EVENT_STOP;\n        } else {\n            const targetActor = global.stage.get_event_actor(event);\n\n            if (Main.modalCount > 0 || targetActor != actor || \n                (!isPress && type != Clutter.EventType.TOUCH_BEGIN) ||\n                (isPress && button != 1)) {\n                return Clutter.EVENT_PROPAGATE;\n            }\n        }\n\n        let params = this.checkIfVertical() ? [stageY, 'y', 'height'] : [stageX, 'x', 'width'];\n        let dragWindow = this._getDraggableWindowForPosition.apply(this, params.concat(['maximized_' + this.getOrientation() + 'ly']));\n\n        if (!dragWindow)\n            return Clutter.EVENT_PROPAGATE;\n\n        global.display.begin_grab_op(dragWindow,\n                                     Meta.GrabOp.MOVING,\n                                     false, /* pointer grab */\n                                     true, /* frame action */\n                                     button,\n                                     event.get_state(),\n                                     event.get_time(),\n                                     stageX, stageY);\n\n        return Clutter.EVENT_STOP;\n    }\n\n    _getDraggableWindowForPosition(stageCoord, coord, dimension, maximizedProp) {\n        let workspace = Utils.getCurrentWorkspace();\n        let allWindowsByStacking = global.display.sort_windows_by_stacking(\n            workspace.list_windows()\n        ).reverse();\n\n        return Utils.find(allWindowsByStacking, metaWindow => {\n            let rect = metaWindow.get_frame_rect();\n\n            return metaWindow.get_monitor() == this.monitor.index &&\n                   metaWindow.showing_on_its_workspace() &&\n                   metaWindow.get_window_type() != Meta.WindowType.DESKTOP &&\n                   metaWindow[maximizedProp] &&\n                   stageCoord > rect[coord] && stageCoord < rect[coord] + rect[dimension];\n        });\n    }\n\n    _onBoxActorAdded(box) {\n        if (this.checkIfVertical()) {\n            this._setVertical(box, true);\n        }\n    }\n\n    _refreshVerticalAlloc() {\n        this._setVertical(this._centerBox, true);\n        this._setVertical(this._rightBox, true);\n        this._formatVerticalClock();\n    }\n\n    _setVertical(actor, isVertical) {\n        let _set = (actor, isVertical) => {\n            if (!actor || actor instanceof Dash.DashItemContainer || actor instanceof TaskbarItemContainer.TaskbarItemContainer) {\n                return;\n            }\n\n            if (actor instanceof St.BoxLayout) {\n                actor.vertical = isVertical;\n            } else if (\n                actor != this.statusArea.appMenu &&\n                ((actor._delegate || actor) instanceof PanelMenu.ButtonBox || actor == this.statusArea.quickSettings) \n            ) {\n                let child = actor.get_first_child();\n\n                if (isVertical && !actor.visible && !actor._dtpVisibleId) {\n                    this._unmappedButtons.push(actor);\n                    actor._dtpVisibleId = actor.connect('notify::visible', () => {\n                        this._disconnectVisibleId(actor);\n                        this._refreshVerticalAlloc();\n                    });\n                    actor._dtpDestroyId = actor.connect('destroy', () => this._disconnectVisibleId(actor));\n                }\n\n                if (child) {\n                    let [, natWidth] = actor.get_preferred_width(-1);\n\n                    child.x_align = Clutter.ActorAlign[isVertical ? 'CENTER' : 'START'];\n                    actor.set_width(isVertical ? this.dtpSize : -1);\n                    isVertical = isVertical && (natWidth > this.dtpSize);\n                    actor[(isVertical ? 'add' : 'remove') + '_style_class_name']('vertical');\n                }\n            }\n\n            actor.get_children().forEach(c => _set(c, isVertical));\n        };\n\n        _set(actor, false);\n        \n        if (isVertical)\n            _set(actor, isVertical);\n    }\n\n    _disconnectVisibleId(actor) {\n        actor.disconnect(actor._dtpVisibleId);\n        actor.disconnect(actor._dtpDestroyId);\n\n        delete actor._dtpVisibleId;\n        delete actor._dtpDestroyId;\n        \n        this._unmappedButtons.splice(this._unmappedButtons.indexOf(actor), 1);\n    }\n\n    _formatVerticalClock() {\n        // https://github.com/GNOME/gnome-desktop/blob/master/libgnome-desktop/gnome-wall-clock.c#L310\n        if (this.statusArea.dateMenu) {\n            let datetime = this.statusArea.dateMenu._clock.clock;\n            let datetimeParts = datetime.split(' ');\n            let time = datetimeParts[1];\n            let clockText = this.statusArea.dateMenu._clockDisplay.clutter_text;\n            let setClockText = (text, useTimeSeparator) => {\n                let stacks = text instanceof Array;\n                let separator = `\\n<span size=\"8192\"> ${useTimeSeparator ? '‧‧' : '—' } </span>\\n`;\n        \n                clockText.set_text((stacks ? text.join(separator) : text).trim());\n                clockText.set_use_markup(stacks);\n                clockText.get_allocation_box();\n        \n                return !clockText.get_layout().is_ellipsized();\n            };\n\n            if (clockText.ellipsize == Pango.EllipsizeMode.NONE) {\n                //on gnome-shell 3.36.4, the clockdisplay isn't ellipsize anymore, so set it back \n                clockText.ellipsize = Pango.EllipsizeMode.END;\n            }\n\n            clockText.natural_width = this.dtpSize;\n\n            if (!time) {\n                datetimeParts = datetime.split(' ');\n                time = datetimeParts.pop();\n                datetimeParts = [datetimeParts.join(' '), time];\n            }\n\n            if (!setClockText(datetime) && \n                !setClockText(datetimeParts) && \n                !setClockText(time)) {\n                let timeParts = time.split('∶');\n\n                if (!this._clockFormat) {\n                    this._clockFormat = DESKTOPSETTINGS.get_string('clock-format');\n                }\n\n                if (this._clockFormat == '12h') {\n                    timeParts.push.apply(timeParts, timeParts.pop().split(' '));\n                }\n\n                setClockText(timeParts, true);\n            }\n        }\n    }\n\n    _setShowDesktopButton(add) {\n        if (add) {\n            if(this._showDesktopButton)\n                return;\n\n            this._showDesktopButton = new St.Bin({ style_class: 'showdesktop-button',\n                            reactive: true,\n                            can_focus: true,\n                            // x_fill: true,\n                            // y_fill: true,\n                            track_hover: true });\n\n            this._setShowDesktopButtonStyle();\n\n            this._showDesktopButton.connect('touch-event', (actor, event) => {\n              if (event.type() == Clutter.EventType.TOUCH_BEGIN) {\n                this._onShowDesktopButtonPress();\n              }\n            });\n            this._showDesktopButton.connect('button-press-event', () => this._onShowDesktopButtonPress());\n            this._showDesktopButton.connect('enter-event', () => {\n                this._showDesktopButton.add_style_class_name(this._getBackgroundBrightness() ?\n                            'showdesktop-button-light-hovered' : 'showdesktop-button-dark-hovered');\n\n                if (SETTINGS.get_boolean('show-showdesktop-hover')) {\n                    this._timeoutsHandler.add([T4, SETTINGS.get_int('show-showdesktop-delay'), () => {\n                        this._hiddenDesktopWorkspace = Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace();\n                        this._toggleWorkspaceWindows(true, this._hiddenDesktopWorkspace);\n                    }]);\n                }\n            });\n            \n            this._showDesktopButton.connect('leave-event', () => {\n                this._showDesktopButton.remove_style_class_name(this._getBackgroundBrightness() ?\n                            'showdesktop-button-light-hovered' : 'showdesktop-button-dark-hovered');\n\n                if (SETTINGS.get_boolean('show-showdesktop-hover')) {\n                    if (this._timeoutsHandler.getId(T4)) {\n                        this._timeoutsHandler.remove(T4);\n                    } else if (this._hiddenDesktopWorkspace) {\n                        this._toggleWorkspaceWindows(false, this._hiddenDesktopWorkspace);\n                    }\n                }\n            });\n\n            this.panel.add_child(this._showDesktopButton);\n        } else {\n            if(!this._showDesktopButton)\n                return;\n\n            this.panel.remove_child(this._showDesktopButton);\n            this._showDesktopButton.destroy();\n            this._showDesktopButton = null;\n        }\n    }\n\n    _setShowDesktopButtonStyle() {\n        let rgb = this._getBackgroundBrightness() ? \"rgba(55, 55, 55, .2)\" : \"rgba(200, 200, 200, .2)\";\n\n        let isLineCustom = SETTINGS.get_boolean('desktop-line-use-custom-color');\n        rgb = isLineCustom ? SETTINGS.get_string('desktop-line-custom-color') : rgb;\n\n        if (this._showDesktopButton) {\n            let buttonSize = SETTINGS.get_int('showdesktop-button-width') + 'px;';\n            let isVertical = this.checkIfVertical();\n\n            let sytle = \"border: 0 solid \" + rgb + \";\";\n            sytle += isVertical ? 'border-top-width:1px;height:' + buttonSize : 'border-left-width:1px;width:' + buttonSize;\n\n            this._showDesktopButton.set_style(sytle);\n            this._showDesktopButton[(isVertical ? 'x' : 'y') + '_expand'] = true;\n        }\n    }\n\n    // _getBackgroundBrightness: return true if panel has a bright background color\n    _getBackgroundBrightness() {\n        return Utils.checkIfColorIsBright(this.dynamicTransparency.backgroundColorRgb);\n    }\n\n    _toggleWorkspaceWindows(hide, workspace) {\n        let time = SETTINGS.get_int('show-showdesktop-time') * .001;\n\n        workspace.list_windows().forEach(w => {\n            if (!w.minimized && !w.customJS_ding) {\n                let tweenOpts = {\n                    opacity: hide ? 0 : 255,\n                    time: time,\n                    transition: 'easeOutQuad'\n                };\n                \n                Utils.animateWindowOpacity(w.get_compositor_private(), tweenOpts);\n            }\n        });\n    }\n\n    _onShowDesktopButtonPress() {\n        let label = 'trackerFocusApp';\n\n        this._signalsHandler.removeWithLabel(label);\n        this._timeoutsHandler.remove(T5);\n\n        if(this._restoreWindowList && this._restoreWindowList.length) {\n            this._timeoutsHandler.remove(T4);\n\n            let current_workspace = Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace();\n            let windows = current_workspace.list_windows();\n            this._restoreWindowList.forEach(function(w) {\n                if(windows.indexOf(w) > -1)\n                    Main.activateWindow(w);\n            });\n            this._restoreWindowList = null;\n        } else {\n            let current_workspace = Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace();\n            let windows = current_workspace.list_windows().filter(function (w) {\n                return w.showing_on_its_workspace() && !w.skip_taskbar;\n            });\n            windows = global.display.sort_windows_by_stacking(windows);\n\n            windows.forEach(function(w) {\n                w.minimize();\n            });\n            \n            this._restoreWindowList = windows;\n\n            this._timeoutsHandler.add([T5, 20, () => this._signalsHandler.addWithLabel(\n                label, \n                [\n                    tracker, \n                    'notify::focus-app', \n                    () => this._restoreWindowList = null\n                ]\n            )]);\n        }\n\n        Main.overview.hide();\n    }\n\n    _onPanelMouseScroll(actor, event) {\n        let scrollAction = SETTINGS.get_string('scroll-panel-action');\n        let direction = Utils.getMouseScrollDirection(event);\n\n        const targetActor = global.stage.get_event_actor(event);\n\n        if (!this._checkIfIgnoredScrollSource(targetActor) && !this._timeoutsHandler.getId(T6)) {\n            if (direction && scrollAction === 'SWITCH_WORKSPACE') {\n                let args = [global.display];\n\n                //adjust for horizontal workspaces\n                if (Utils.DisplayWrapper.getWorkspaceManager().layout_rows === 1) {\n                    direction = direction == 'up' ? 'left' : 'right';\n                }\n\n                //gnome-shell < 3.30 needs an additional \"screen\" param\n                global.screen ? args.push(global.screen) : 0;\n\n                let showWsPopup = SETTINGS.get_boolean('scroll-panel-show-ws-popup');\n                showWsPopup ? 0 : Main.wm._workspaceSwitcherPopup = { display: () => {} };\n                Main.wm._showWorkspaceSwitcher.apply(Main.wm, args.concat([0, { get_name: () => 'switch---' + direction }]));\n                showWsPopup ? 0 : Main.wm._workspaceSwitcherPopup = null;\n            } else if (direction && scrollAction === 'CYCLE_WINDOWS') {\n                let windows = this.taskbar.getAppInfos().reduce((ws, appInfo) => ws.concat(appInfo.windows), []);\n                \n                Utils.activateSiblingWindow(windows, direction);\n            } else if (scrollAction === 'CHANGE_VOLUME' && !event.is_pointer_emulated()) {\n                let proto = Volume.OutputIndicator.prototype;\n                let func = proto._handleScrollEvent || proto.vfunc_scroll_event || proto._onScrollEvent;\n                let indicator = Main.panel.statusArea[Utils.getSystemMenuInfo().name]._volumeOutput;\n\n                if (indicator.quickSettingsItems)\n                    // new quick settings menu in gnome-shell > 42\n                    func(indicator.quickSettingsItems[0], event);\n                else\n                    func.call(indicator, 0, event);\n            } else {\n                return;\n            }\n\n            const scrollDelay = SETTINGS.get_int('scroll-panel-delay');\n\n            if (scrollDelay) {\n                this._timeoutsHandler.add([T6, scrollDelay, () => {}]);\n            }\n        }\n    }\n\n    _checkIfIgnoredScrollSource(source) {\n        let ignoredConstr = ['WorkspaceIndicator'];\n\n        return source.get_parent()._dtpIgnoreScroll || ignoredConstr.indexOf(source.constructor.name) >= 0;\n    }\n\n    _initProgressManager() {\n        const progressVisible = SETTINGS.get_boolean('progress-show-bar');\n        const countVisible = SETTINGS.get_boolean('progress-show-count');\n        const pm = this.progressManager;\n\n        if(!pm && (progressVisible || countVisible))\n            this.progressManager = new Progress.ProgressManager();\n        else if (pm)\n            Object.keys(pm._entriesByDBusName).forEach((k) => pm._entriesByDBusName[k].setCountVisible(countVisible));\n    }\n});\n\nexport const SecondaryPanel = GObject.registerClass({\n}, class SecondaryPanel extends St.Widget {\n\n    _init(params) {\n        super._init(params);\n    }\n\n    vfunc_allocate(box) {\n        this.set_allocation(box);\n    }\n});\n"
        },
        {
          "name": "panelManager.js",
          "type": "blob",
          "size": 29.2509765625,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Credits:\n * This file is based on code from the Dash to Dock extension by micheleg\n * and code from the Taskbar extension by Zorin OS\n * \n * Code to re-anchor the panel was taken from Thoma5 BottomPanel:\n * https://github.com/Thoma5/gnome-shell-extension-bottompanel\n * \n * Pattern for moving clock based on Frippery Move Clock by R M Yorston\n * http://frippery.org/extensions/\n * \n * Some code was also adapted from the upstream Gnome Shell source code.\n */\n\nimport * as Overview from './overview.js';\nimport * as Panel from './panel.js';\nimport * as PanelSettings from './panelSettings.js';\nimport * as Proximity from './proximity.js';\nimport * as Utils from './utils.js';\nimport * as DesktopIconsIntegration from './desktopIconsIntegration.js';\n\nimport GLib from 'gi://GLib';\nimport GObject from 'gi://GObject';\nimport Clutter from 'gi://Clutter';\nimport Meta from 'gi://Meta';\nimport Shell from 'gi://Shell';\nimport St from 'gi://St';\n\nimport * as BoxPointer from 'resource:///org/gnome/shell/ui/boxpointer.js';\nimport * as LookingGlass from 'resource:///org/gnome/shell/ui/lookingGlass.js';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as PanelMenu from 'resource:///org/gnome/shell/ui/panelMenu.js';\nimport * as Layout from 'resource:///org/gnome/shell/ui/layout.js';\nimport {InjectionManager} from 'resource:///org/gnome/shell/extensions/extension.js';\nimport {SETTINGS} from './extension.js';\nimport {SecondaryMonitorDisplay, WorkspacesView} from 'resource:///org/gnome/shell/ui/workspacesView.js';\n\n\nexport const PanelManager = class {\n\n    constructor() {\n        this.overview = new Overview.Overview();\n        this.panelsElementPositions = {};\n        this._injectionManager = new InjectionManager();\n\n        this._saveMonitors();\n    }\n\n    enable(reset) {\n        let dtpPrimaryIndex = SETTINGS.get_int('primary-monitor');\n\n        this.allPanels = [];\n        this.dtpPrimaryMonitor = Main.layoutManager.monitors[dtpPrimaryIndex] || Main.layoutManager.primaryMonitor;\n        this.proximityManager = new Proximity.ProximityManager();\n\n        if (this.dtpPrimaryMonitor) {\n            this.primaryPanel = this._createPanel(this.dtpPrimaryMonitor, SETTINGS.get_boolean('stockgs-keep-top-panel'));\n            this.allPanels.push(this.primaryPanel);\n            this.overview.enable(this.primaryPanel);\n\n            this.setFocusedMonitor(this.dtpPrimaryMonitor);\n        }\n\n        if (SETTINGS.get_boolean('multi-monitors')) {\n            Main.layoutManager.monitors.filter(m => m != this.dtpPrimaryMonitor).forEach(m => {\n                this.allPanels.push(this._createPanel(m, true));\n            });\n        }\n\n        global.dashToPanel.panels = this.allPanels;\n        global.dashToPanel.emit('panels-created');\n\n        this.allPanels.forEach(p => {\n            let panelPosition = p.getPosition();\n            let leftOrRight = (panelPosition == St.Side.LEFT || panelPosition == St.Side.RIGHT);\n            \n            p.panelBox.set_size(\n                leftOrRight ? -1 : p.geom.w + p.geom.lrPadding, \n                leftOrRight ? p.geom.h + p.geom.tbPadding : -1\n            );\n\n            this._findPanelMenuButtons(p.panelBox).forEach(pmb => this._adjustPanelMenuButton(pmb, p.monitor, panelPosition));\n            \n            p.taskbar.iconAnimator.start();\n        });\n\n        this._setDesktopIconsMargins();\n        //in 3.32, BoxPointer now inherits St.Widget\n        if (BoxPointer.BoxPointer.prototype.vfunc_get_preferred_height) {\n            let panelManager = this;\n\n            this._injectionManager.overrideMethod(BoxPointer.BoxPointer.prototype, 'vfunc_get_preferred_height', () => function(forWidth) {\n                let alloc = { min_size: 0, natural_size: 0 };\n                \n                [alloc.min_size, alloc.natural_size] = this.vfunc_get_preferred_height(forWidth);\n\n                return panelManager._getBoxPointerPreferredHeight(this, alloc);\n            });\n        }\n\n        this._updatePanelElementPositions();\n        \n        if (reset) return;\n\n        this._desktopIconsUsableArea = new DesktopIconsIntegration.DesktopIconsUsableAreaClass();\n\n        this._oldUpdatePanelBarrier = Main.layoutManager._updatePanelBarrier;\n        Main.layoutManager._updatePanelBarrier = (panel) => {\n            let panelUpdates = panel ? [panel] : this.allPanels;\n\n            panelUpdates.forEach(p => newUpdatePanelBarrier.call(Main.layoutManager, p));\n        };\n        Main.layoutManager._updatePanelBarrier();\n\n        this._oldUpdateHotCorners = Main.layoutManager._updateHotCorners;\n        Main.layoutManager._updateHotCorners = newUpdateHotCorners.bind(Main.layoutManager);\n        Main.layoutManager._updateHotCorners();\n\n        this._forceHotCornerId = SETTINGS.connect('changed::stockgs-force-hotcorner', () => Main.layoutManager._updateHotCorners());\n\n        if (Main.layoutManager._interfaceSettings) {\n            this._enableHotCornersId = Main.layoutManager._interfaceSettings.connect('changed::enable-hot-corners', () => Main.layoutManager._updateHotCorners());\n        }\n\n        this._oldUpdateWorkspacesViews = Main.overview._overview._controls._workspacesDisplay._updateWorkspacesViews;\n        Main.overview._overview._controls._workspacesDisplay._updateWorkspacesViews = this._newUpdateWorkspacesViews.bind(Main.overview._overview._controls._workspacesDisplay);\n\n        this._oldSetPrimaryWorkspaceVisible = Main.overview._overview._controls._workspacesDisplay.setPrimaryWorkspaceVisible\n        Main.overview._overview._controls._workspacesDisplay.setPrimaryWorkspaceVisible = this._newSetPrimaryWorkspaceVisible.bind(Main.overview._overview._controls._workspacesDisplay);\n\n        LookingGlass.LookingGlass.prototype._oldResize = LookingGlass.LookingGlass.prototype._resize;\n        LookingGlass.LookingGlass.prototype._resize = _newLookingGlassResize;\n\n        LookingGlass.LookingGlass.prototype._oldOpen = LookingGlass.LookingGlass.prototype.open;\n        LookingGlass.LookingGlass.prototype.open = _newLookingGlassOpen;\n\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n\n        //listen settings\n        this._signalsHandler.add(\n            [\n                SETTINGS,\n                [\n                    'changed::primary-monitor',\n                    'changed::multi-monitors',\n                    'changed::isolate-monitors',\n                    'changed::panel-positions',\n                    'changed::panel-lengths',\n                    'changed::panel-anchors',\n                    'changed::stockgs-keep-top-panel'\n                ],\n                () => this._reset()\n            ],\n            [\n                SETTINGS,\n                'changed::panel-element-positions',\n                () => this._updatePanelElementPositions()\n            ],\n            [\n                SETTINGS,\n                'changed::intellihide-key-toggle-text',\n                () => this._setKeyBindings(true)\n            ],\n            [\n                SETTINGS,\n                'changed::panel-sizes',\n                () => {\n                    GLib.idle_add(GLib.PRIORITY_LOW, () => {\n                        this._setDesktopIconsMargins();\n                        return GLib.SOURCE_REMOVE;\n                    });\n                }\n            ],\n            [\n                Utils.DisplayWrapper.getMonitorManager(),\n                'monitors-changed', \n                () => {\n                    if (Main.layoutManager.primaryMonitor) {\n                        this._saveMonitors();\n                        this._reset();\n                    }\n                }\n            ]\n        );\n\n        Panel.panelBoxes.forEach(c => this._signalsHandler.add(\n            [\n                Main.panel[c], \n                'child-added', \n                (parent, child) => {\n                    this.primaryPanel &&\n                    child instanceof St.Bin && \n                    this._adjustPanelMenuButton(this._getPanelMenuButton(child.get_first_child()), this.primaryPanel.monitor, this.primaryPanel.getPosition())\n                }\n            ]\n        ));\n\n        this._setKeyBindings(true);\n\n        // keep GS overview.js from blowing away custom panel styles\n        if(!SETTINGS.get_boolean('stockgs-keep-top-panel'))\n            Object.defineProperty(Main.panel, \"style\", {configurable: true, set(v) {}});\n    }\n\n    disable(reset) {\n        this.primaryPanel && this.overview.disable();\n        this.proximityManager.destroy();\n\n        this.allPanels.forEach(p => {\n            p.taskbar.iconAnimator.pause();\n\n            this._findPanelMenuButtons(p.panelBox).forEach(pmb => {\n                if (pmb.menu._boxPointer._dtpGetPreferredHeightId) {\n                    pmb.menu._boxPointer._container.disconnect(pmb.menu._boxPointer._dtpGetPreferredHeightId);\n                }\n\n                pmb.menu._boxPointer.sourceActor = pmb.menu._boxPointer._dtpSourceActor;\n                delete pmb.menu._boxPointer._dtpSourceActor;\n                pmb.menu._boxPointer._userArrowSide = St.Side.TOP;\n            })\n\n            this._removePanelBarriers(p);\n\n            p.disable();\n\n            let clipContainer = p.panelBox.get_parent();\n\n            Main.layoutManager._untrackActor(p.panelBox);\n            Main.layoutManager.removeChrome(clipContainer);\n\n            if (p.isStandalone) {\n                p.panelBox.destroy();\n            } else {\n                p.panelBox.remove_child(p);\n                p.remove_child(p.panel);\n                p.panelBox.add_child(p.panel);\n\n                p.panelBox.set_position(clipContainer.x, clipContainer.y);\n\n                clipContainer.remove_child(p.panelBox);\n                Main.layoutManager.addChrome(p.panelBox, { affectsStruts: true, trackFullscreen: true });\n            }\n        });\n\n        this._injectionManager.clear();\n\n        if (Main.layoutManager.primaryMonitor) {\n            Main.layoutManager.panelBox.set_position(Main.layoutManager.primaryMonitor.x, Main.layoutManager.primaryMonitor.y);\n            Main.layoutManager.panelBox.set_size(Main.layoutManager.primaryMonitor.width, -1);\n        }\n\n        if (reset) return;\n        \n        this._setKeyBindings(false);\n\n        this._signalsHandler.destroy();\n\n        Main.layoutManager._updateHotCorners = this._oldUpdateHotCorners;\n        Main.layoutManager._updateHotCorners();\n\n        SETTINGS.disconnect(this._forceHotCornerId);\n\n        if (this._enableHotCornersId) {\n            Main.layoutManager._interfaceSettings.disconnect(this._enableHotCornersId);\n        }\n\n        Main.layoutManager._updatePanelBarrier = this._oldUpdatePanelBarrier;\n        Main.layoutManager._updatePanelBarrier();\n\n        Main.overview._overview._controls._workspacesDisplay._updateWorkspacesViews = this._oldUpdateWorkspacesViews;\n        Main.overview._overview._controls._workspacesDisplay.setPrimaryWorkspaceVisible = this._oldSetPrimaryWorkspaceVisible;\n\n        LookingGlass.LookingGlass.prototype._resize = LookingGlass.LookingGlass.prototype._oldResize;\n        delete LookingGlass.LookingGlass.prototype._oldResize;\n\n        LookingGlass.LookingGlass.prototype.open = LookingGlass.LookingGlass.prototype._oldOpen;\n        delete LookingGlass.LookingGlass.prototype._oldOpen\n\n        delete Main.panel.style;\n        this._desktopIconsUsableArea.destroy();\n        this._desktopIconsUsableArea = null;\n    }\n\n    toggleDash() {\n        this.overview.toggleDash();\n    }\n\n    _setDesktopIconsMargins() {\n        this._desktopIconsUsableArea?.resetMargins();\n        this.allPanels.forEach(p => {\n            switch(p.geom.position) {\n                case St.Side.TOP:\n                    this._desktopIconsUsableArea?.setMargins(p.monitor.index, p.geom.h, 0, 0, 0);\n                    break;\n                case St.Side.BOTTOM:\n                    this._desktopIconsUsableArea?.setMargins(p.monitor.index, 0, p.geom.h, 0, 0);\n                    break;\n                case St.Side.LEFT:\n                    this._desktopIconsUsableArea?.setMargins(p.monitor.index, 0, 0, p.geom.w, 0);\n                    break;\n                case St.Side.RIGHT:\n                    this._desktopIconsUsableArea?.setMargins(p.monitor.index, 0, 0, 0, p.geom.w);\n                    break;\n            }\n        });\n    }\n\n    setFocusedMonitor(monitor) {\n        this.focusedMonitorPanel = this.allPanels.find(p => p.monitor == monitor)\n\n        if (!this.checkIfFocusedMonitor(monitor)) {\n            Main.overview._overview.clear_constraints();\n            Main.overview._overview.add_constraint(new Layout.MonitorConstraint({ index: monitor.index }));\n\n            Main.overview._overview._controls._workspacesDisplay._primaryIndex = monitor.index;\n        }\n    }\n\n    _newSetPrimaryWorkspaceVisible(visible) {\n        if (this._primaryVisible === visible)\n            return;\n\n        this._primaryVisible = visible;\n\n        const primaryIndex = Main.overview._overview._controls._workspacesDisplay._primaryIndex;\n        const primaryWorkspace = this._workspacesViews[primaryIndex];\n        if (primaryWorkspace)\n            primaryWorkspace.visible = visible;\n    }\n\n    _newUpdateWorkspacesViews() {\n        for (let i = 0; i < this._workspacesViews.length; i++)\n            this._workspacesViews[i].destroy();\n\n        this._workspacesViews = [];\n        let monitors = Main.layoutManager.monitors;\n        for (let i = 0; i < monitors.length; i++) {\n            let view;\n            if (i === this._primaryIndex) {\n                view = new WorkspacesView(i,\n                    this._controls,\n                    this._scrollAdjustment,\n                    this._fitModeAdjustment,\n                    this._overviewAdjustment);\n\n                view.visible = this._primaryVisible;\n                this.bind_property('opacity', view, 'opacity', GObject.BindingFlags.SYNC_CREATE);\n                this.add_child(view);\n            } else {\n                // No idea why atm, but we need the import at the top of this file and to use the\n                // full imports ns here, otherwise SecondaryMonitorDisplay can't be used ¯\\_(ツ)_/¯\n                view = new SecondaryMonitorDisplay(i,\n                    this._controls,\n                    this._scrollAdjustment,\n                    this._fitModeAdjustment,\n                    this._overviewAdjustment);\n                Main.layoutManager.overviewGroup.add_child(view);\n            }\n\n            this._workspacesViews.push(view);\n        }\n    }\n\n    _saveMonitors() {\n        //Mutter meta_monitor_manager_get_primary_monitor (global.display.get_primary_monitor()) doesn't return the same\n        //monitor as GDK gdk_screen_get_primary_monitor (imports.gi.Gdk.Screen.get_default().get_primary_monitor()).\n        //Since the Mutter function is what's used in gnome-shell and we can't access it from the settings dialog, store \n        //the monitors information in a setting so we can use the same monitor indexes as the ones in gnome-shell\n        let keyMonitors = 'available-monitors';\n        let keyPrimary = 'primary-monitor';\n        let primaryIndex = Main.layoutManager.primaryIndex;\n        let newMonitors = [primaryIndex];\n        let savedMonitors = SETTINGS.get_value(keyMonitors).deep_unpack();\n        let dtpPrimaryIndex = SETTINGS.get_int(keyPrimary);\n        let newDtpPrimaryIndex = primaryIndex;\n\n        Main.layoutManager.monitors.filter(m => m.index != primaryIndex).forEach(m => newMonitors.push(m.index));\n\n        if (savedMonitors[0] != dtpPrimaryIndex) {\n            // dash to panel primary wasn't the gnome-shell primary (first index of available-monitors)\n            let savedIndex = savedMonitors.indexOf(dtpPrimaryIndex)\n\n            // default to primary if it was set to a monitor that is no longer available\n            newDtpPrimaryIndex = newMonitors[savedIndex];\n            newDtpPrimaryIndex = newDtpPrimaryIndex == null ? primaryIndex : newDtpPrimaryIndex;\n        }\n        \n        SETTINGS.set_int(keyPrimary, newDtpPrimaryIndex);\n        SETTINGS.set_value(keyMonitors, new GLib.Variant('ai', newMonitors));\n    }\n\n    checkIfFocusedMonitor(monitor) {\n        return Main.overview._overview._controls._workspacesDisplay._primaryIndex == monitor.index;\n    }\n\n    _createPanel(monitor, isStandalone) {\n        let panelBox;\n        let panel;\n        let clipContainer = new Clutter.Actor();\n        \n        if (isStandalone) {\n            panelBox = new St.BoxLayout({ name: 'panelBox' });\n        } else {\n            panelBox = Main.layoutManager.panelBox;\n            Main.layoutManager._untrackActor(panelBox);\n            panelBox.remove_child(Main.panel);\n            Main.layoutManager.removeChrome(panelBox);\n        }\n\n        Main.layoutManager.addChrome(clipContainer, { affectsInputRegion: false });\n        clipContainer.add_child(panelBox);\n        Main.layoutManager.trackChrome(panelBox, { trackFullscreen: true, affectsStruts: true, affectsInputRegion: true });\n        \n        panel = new Panel.Panel(this, monitor, panelBox, isStandalone);\n        panelBox.add_child(panel);\n        panel.enable();\n\n        panelBox.visible = true;\n        if (monitor.inFullscreen) {\n            panelBox.hide();\n        }\n        panelBox.set_position(0, 0);\n\n        return panel;\n    }\n\n    _reset() {\n        this.disable(true);\n        this.allPanels = [];\n        this.enable(true);\n    }\n\n    _updatePanelElementPositions() {\n        this.panelsElementPositions = PanelSettings.getSettingsJson(SETTINGS, 'panel-element-positions');\n        this.allPanels.forEach(p => p.updateElementPositions());\n    }\n\n    _adjustPanelMenuButton(button, monitor, arrowSide) {\n        if (button) {\n            button.menu._boxPointer._dtpSourceActor = button.menu._boxPointer.sourceActor;\n            button.menu._boxPointer.sourceActor = button;\n            button.menu._boxPointer._userArrowSide = arrowSide;\n            button.menu._boxPointer._dtpInPanel = 1;\n\n            if (!button.menu._boxPointer.vfunc_get_preferred_height) {\n                button.menu._boxPointer._dtpGetPreferredHeightId = button.menu._boxPointer._container.connect('get-preferred-height', (actor, forWidth, alloc) => {\n                    this._getBoxPointerPreferredHeight(button.menu._boxPointer, alloc, monitor);\n                });\n            }\n        }\n    }\n\n    _getBoxPointerPreferredHeight(boxPointer, alloc, monitor) {\n        if (boxPointer._dtpInPanel && boxPointer.sourceActor && SETTINGS.get_boolean('intellihide')) {\n            monitor = monitor || Main.layoutManager.findMonitorForActor(boxPointer.sourceActor);\n            let panel = Utils.find(global.dashToPanel.panels, p => p.monitor == monitor);\n            let excess = alloc.natural_size + panel.dtpSize + 10 - monitor.height; // 10 is arbitrary\n\n            if (excess > 0) {\n                alloc.natural_size -= excess;\n            }\n        }\n\n        return [alloc.min_size, alloc.natural_size];\n    }\n\n    _findPanelMenuButtons(container) {\n        let panelMenuButtons = [];\n        let panelMenuButton;\n\n        let find = parent => parent.get_children().forEach(c => {\n            if ((panelMenuButton = this._getPanelMenuButton(c))) {\n                panelMenuButtons.push(panelMenuButton);\n            }\n\n            find(c);\n        });\n\n        find(container);\n\n        return panelMenuButtons;\n    }\n\n    _removePanelBarriers(panel) {\n        if (panel.isStandalone && panel._rightPanelBarrier) {\n            panel._rightPanelBarrier.destroy();\n        }\n\n        if (panel._leftPanelBarrier) {\n            panel._leftPanelBarrier.destroy();\n            delete panel._leftPanelBarrier;\n        }\n    }\n\n    _getPanelMenuButton(obj) {\n        return obj instanceof PanelMenu.Button && obj.menu?._boxPointer ? obj : 0;\n    }\n\n    _setKeyBindings(enable) {\n        let keys = {\n            'intellihide-key-toggle': () => this.allPanels.forEach(p => p.intellihide.toggle())\n        };\n\n        Object.keys(keys).forEach(k => {\n            Utils.removeKeybinding(k);\n\n            if (enable) {\n                Utils.addKeybinding(k, SETTINGS, keys[k], Shell.ActionMode.NORMAL);\n            }\n        });\n    }\n\n};\n\n// This class drives long-running icon animations, to keep them running in sync\n// with each other.\nexport const IconAnimator = class {\n\n    constructor(actor) {\n        this._count = 0;\n        this._started = false;\n        this._animations = {\n            dance: [],\n        };\n        this._timeline = new Clutter.Timeline({\n            duration: 3000,\n            repeat_count: -1,\n        });\n\n        /* Just use the construction property when no need to support 3.36 */\n        if (this._timeline.set_actor)\n            this._timeline.set_actor(actor);\n\n        this._timeline.connect('new-frame', () => {\n            const progress = this._timeline.get_progress();\n            const danceRotation = progress < 1/6 ? 15*Math.sin(progress*24*Math.PI) : 0;\n            const dancers = this._animations.dance;\n            for (let i = 0, iMax = dancers.length; i < iMax; i++) {\n                dancers[i].target.rotation_angle_z = danceRotation;\n            }\n        });\n    }\n\n    destroy() {\n        this._timeline.stop();\n        this._timeline = null;\n        for (let name in this._animations) {\n            const pairs = this._animations[name];\n            for (let i = 0, iMax = pairs.length; i < iMax; i++) {\n                const pair = pairs[i];\n                pair.target.disconnect(pair.targetDestroyId);\n            }\n        }\n        this._animations = null;\n    }\n\n    pause() {\n        if (this._started && this._count > 0) {\n            this._timeline.stop();\n        }\n        this._started = false;\n    }\n\n    start() {\n        if (!this._started && this._count > 0) {\n            this._timeline.start();\n        }\n        this._started = true;\n    }\n\n    addAnimation(target, name) {\n        const targetDestroyId = target.connect('destroy', () => this.removeAnimation(target, name));\n        this._animations[name].push({ target: target, targetDestroyId: targetDestroyId });\n        if (this._started && this._count === 0) {\n            this._timeline.start();\n        }\n        this._count++;\n    }\n\n    removeAnimation(target, name) {\n        const pairs = this._animations[name];\n        for (let i = 0, iMax = pairs.length; i < iMax; i++) {\n            const pair = pairs[i];\n            if (pair.target === target) {\n                target.disconnect(pair.targetDestroyId);\n                pairs.splice(i, 1);\n                this._count--;\n                if (this._started && this._count === 0) {\n                    this._timeline.stop();\n                }\n                return;\n            }\n        }\n    }\n};\n\nfunction newUpdateHotCorners() {\n    // destroy old hot corners\n    this.hotCorners.forEach(function(corner) {\n        if (corner)\n            corner.destroy();\n    });\n    this.hotCorners = [];\n\n    //global.settings is ubuntu specific setting to disable the hot corner (Tweak tool > Top Bar > Activities Overview Hot Corner)\n    //this._interfaceSettings is for the setting to disable the hot corner introduced in gnome-shell 3.34 \n    if ((global.settings.list_keys().indexOf('enable-hot-corners') >= 0 && !global.settings.get_boolean('enable-hot-corners')) ||\n        (this._interfaceSettings && !this._interfaceSettings.get_boolean('enable-hot-corners'))) {\n        this.emit('hot-corners-changed');\n        return;\n    }\n\n    // build new hot corners\n    for (let i = 0; i < this.monitors.length; i++) {\n        let panel = Utils.find(global.dashToPanel.panels, p => p.monitor.index == i);\n        let panelPosition = panel ? panel.getPosition() : St.Side.BOTTOM;\n        let panelTopLeft = panelPosition == St.Side.TOP || panelPosition == St.Side.LEFT;\n        let monitor = this.monitors[i];\n        let cornerX = this._rtl ? monitor.x + monitor.width : monitor.x;\n        let cornerY = monitor.y;\n\n        let haveTopLeftCorner = true;\n        \n        // If the panel is on the bottom, unless this is explicitly forced, don't add a topleft \n        // hot corner unless it is actually a top left panel. Otherwise, it stops the mouse \n        // as you are dragging across. In the future, maybe we will automatically move the \n        // hotcorner to the bottom when the panel is positioned at the bottom\n        if (i != this.primaryIndex || (!panelTopLeft && !SETTINGS.get_boolean('stockgs-force-hotcorner'))) {\n            // Check if we have a top left (right for RTL) corner.\n            // I.e. if there is no monitor directly above or to the left(right)\n            let besideX = this._rtl ? monitor.x + 1 : cornerX - 1;\n            let besideY = cornerY;\n            let aboveX = cornerX;\n            let aboveY = cornerY - 1;\n\n            for (let j = 0; j < this.monitors.length; j++) {\n                if (i == j)\n                    continue;\n                let otherMonitor = this.monitors[j];\n                if (besideX >= otherMonitor.x &&\n                    besideX < otherMonitor.x + otherMonitor.width &&\n                    besideY >= otherMonitor.y &&\n                    besideY < otherMonitor.y + otherMonitor.height) {\n                    haveTopLeftCorner = false;\n                    break;\n                }\n                if (aboveX >= otherMonitor.x &&\n                    aboveX < otherMonitor.x + otherMonitor.width &&\n                    aboveY >= otherMonitor.y &&\n                    aboveY < otherMonitor.y + otherMonitor.height) {\n                    haveTopLeftCorner = false;\n                    break;\n                }\n            }\n        }\n\n        if (haveTopLeftCorner) {\n            let corner = new Layout.HotCorner(this, monitor, cornerX, cornerY);\n\n            corner.setBarrierSize = size => Object.getPrototypeOf(corner).setBarrierSize.call(corner, Math.min(size, 32));\n            corner.setBarrierSize(panel ? panel.dtpSize : 32);\n            this.hotCorners.push(corner);\n        } else {\n            this.hotCorners.push(null);\n        }\n    }\n\n    this.emit('hot-corners-changed');\n}\n\nfunction newUpdatePanelBarrier(panel) {\n    let barriers = {\n        _rightPanelBarrier: [(panel.isStandalone ? panel : this)],\n        _leftPanelBarrier: [panel]\n    };\n\n    Object.keys(barriers).forEach(k => {\n        let obj = barriers[k][0];\n\n        if (obj[k]) {\n            obj[k].destroy();\n            obj[k] = null;\n        }\n    });\n\n    if (!this.primaryMonitor || !panel.panelBox.height) {\n        return;\n    }\n\n    let barrierSize = Math.min(10, panel.panelBox.height); \n    let fixed1 = panel.monitor.y;\n    let fixed2 = panel.monitor.y + barrierSize;\n    \n    if (panel.checkIfVertical()) {\n        barriers._rightPanelBarrier.push(panel.monitor.y + panel.monitor.height, Meta.BarrierDirection.NEGATIVE_Y);\n        barriers._leftPanelBarrier.push(panel.monitor.y, Meta.BarrierDirection.POSITIVE_Y);\n    } else {\n        barriers._rightPanelBarrier.push(panel.monitor.x + panel.monitor.width, Meta.BarrierDirection.NEGATIVE_X);\n        barriers._leftPanelBarrier.push(panel.monitor.x, Meta.BarrierDirection.POSITIVE_X);\n    }\n\n    switch (panel.getPosition()) {\n        //values are initialized as St.Side.TOP \n        case St.Side.BOTTOM:\n            fixed1 = panel.monitor.y + panel.monitor.height - barrierSize;\n            fixed2 = panel.monitor.y + panel.monitor.height;\n            break;\n        case St.Side.LEFT:\n            fixed1 = panel.monitor.x + barrierSize;\n            fixed2 = panel.monitor.x;\n            break;\n        case St.Side.RIGHT:\n            fixed1 = panel.monitor.x + panel.monitor.width - barrierSize;\n            fixed2 = panel.monitor.x + panel.monitor.width;\n            break;\n    }\n\n    //remove left barrier if it overlaps one of the hotcorners\n    for (let k in this.hotCorners) {\n        let hc = this.hotCorners[k];\n\n        if (hc && hc._monitor == panel.monitor && \n            ((fixed1 == hc._x || fixed2 == hc._x) || fixed1 == hc._y || fixed2 == hc._y)) {\n                delete barriers._leftPanelBarrier;\n                break;\n        }\n    }\n\n    Object.keys(barriers).forEach(k => {\n        let barrierOptions = { \n            backend: global.backend,\n            directions: barriers[k][2]\n        };\n        \n        barrierOptions[panel.varCoord.c1] = barrierOptions[panel.varCoord.c2] = barriers[k][1];\n        barrierOptions[panel.fixedCoord.c1] = fixed1;\n        barrierOptions[panel.fixedCoord.c2] = fixed2;\n\n        barriers[k][0][k] = new Meta.Barrier(barrierOptions);\n    });\n}\n\nfunction _newLookingGlassResize() {\n    let primaryMonitorPanel = Utils.find(global.dashToPanel.panels, p => p.monitor == Main.layoutManager.primaryMonitor);\n    let topOffset = primaryMonitorPanel.getPosition() == St.Side.TOP ? primaryMonitorPanel.dtpSize + 8 : 32;\n\n    this._oldResize();\n\n    this._hiddenY = Main.layoutManager.primaryMonitor.y + topOffset - this.height;\n    this._targetY = this._hiddenY + this.height;\n    this.y = this._hiddenY;\n\n    this._objInspector.set_position(this.x + Math.floor(this.width * 0.1), this._targetY + Math.floor(this.height * 0.1));\n}\n\nfunction _newLookingGlassOpen() {\n    if (this._open)\n        return;\n\n    this._resize();\n    this._oldOpen();\n}\n"
        },
        {
          "name": "panelPositions.js",
          "type": "blob",
          "size": 2.3916015625,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nexport const SHOW_APPS_BTN = 'showAppsButton';\nexport const ACTIVITIES_BTN = 'activitiesButton';\nexport const TASKBAR = 'taskbar';\nexport const DATE_MENU = 'dateMenu';\nexport const SYSTEM_MENU = 'systemMenu';\nexport const LEFT_BOX = 'leftBox';\nexport const CENTER_BOX = 'centerBox';\nexport const RIGHT_BOX = 'rightBox';\nexport const DESKTOP_BTN = 'desktopButton';\n\nexport const STACKED_TL = 'stackedTL';\nexport const STACKED_BR = 'stackedBR';\nexport const CENTERED = 'centered';\nexport const CENTERED_MONITOR = 'centerMonitor';\n\nexport const TOP = 'TOP';\nexport const BOTTOM = 'BOTTOM';\nexport const LEFT = 'LEFT';\nexport const RIGHT = 'RIGHT';\n\nexport const START = 'START';\nexport const MIDDLE = 'MIDDLE';\nexport const END = 'END';\n\nexport const defaults = [\n    { element: SHOW_APPS_BTN,   visible: true,     position: STACKED_TL },\n    { element: ACTIVITIES_BTN,  visible: false,    position: STACKED_TL },\n    { element: LEFT_BOX,        visible: true,     position: STACKED_TL },\n    { element: TASKBAR,         visible: true,     position: STACKED_TL },\n    { element: CENTER_BOX,      visible: true,     position: STACKED_BR },\n    { element: RIGHT_BOX,       visible: true,     position: STACKED_BR },\n    { element: DATE_MENU,       visible: true,     position: STACKED_BR },\n    { element: SYSTEM_MENU,     visible: true,     position: STACKED_BR },\n    { element: DESKTOP_BTN,     visible: true,     position: STACKED_BR },\n];\n\nexport const optionDialogFunctions = {};\n\noptionDialogFunctions[SHOW_APPS_BTN] = '_showShowAppsButtonOptions';\noptionDialogFunctions[DESKTOP_BTN] = '_showDesktopButtonOptions';\n\nexport function checkIfCentered(position) {\n    return position == CENTERED || position == CENTERED_MONITOR;\n}\n"
        },
        {
          "name": "panelSettings.js",
          "type": "blob",
          "size": 4.1259765625,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Pos from './panelPositions.js';\n\n/** Return object representing a settings value that is stored as JSON. */\nexport function getSettingsJson(settings, setting) {\n    try {\n        return JSON.parse(settings.get_string(setting));\n    } catch(e) {\n        log('Error parsing positions: ' + e.message);\n    }\n}\n/** Write value object as JSON to setting in settings. */\nexport function setSettingsJson(settings, setting, value) {\n    try {\n        const json = JSON.stringify(value);\n        settings.set_string(setting, json);\n    } catch(e) {\n        log('Error serializing setting: ' + e.message);\n    }\n}\n\n/** Returns size of panel on a specific monitor, in pixels. */\nexport function getPanelSize(settings, monitorIndex) {\n    const sizes = getSettingsJson(settings, 'panel-sizes');\n    // Pull in deprecated setting if panel-sizes does not have setting for monitor.\n    const fallbackSize = settings.get_int('panel-size');\n    const theDefault = 48;\n    return sizes[monitorIndex] || fallbackSize || theDefault;\n}\n\nexport function setPanelSize(settings, monitorIndex, value) {\n    if (!(Number.isInteger(value) && value <= 128 && value >= 16)) {\n        log('Not setting invalid panel size: ' + value);\n        return;\n    }\n    let sizes = getSettingsJson(settings, 'panel-sizes');\n    sizes[monitorIndex] = value;\n    setSettingsJson(settings, 'panel-sizes', sizes);\n}\n\n/**\n * Returns length of panel on a specific monitor, as a whole number percent,\n * from settings. e.g. 100\n */\nexport function getPanelLength(settings, monitorIndex) {\n    const lengths = getSettingsJson(settings, 'panel-lengths');\n    const theDefault = 100;\n    return lengths[monitorIndex] || theDefault;\n}\n\nexport function setPanelLength(settings, monitorIndex, value) {\n    if (!(Number.isInteger(value) && value <= 100 && value >= 0)) {\n        log('Not setting invalid panel length: ' + value);\n        return;\n    }\n    let lengths = getSettingsJson(settings, 'panel-lengths');\n    lengths[monitorIndex] = value;\n    setSettingsJson(settings, 'panel-lengths', lengths);\n}\n\n/** Returns position of panel on a specific monitor. */\nexport function getPanelPosition(settings, monitorIndex) {\n    const positions = getSettingsJson(settings, 'panel-positions');\n    const fallbackPosition = settings.get_string('panel-position');\n    const theDefault = Pos.BOTTOM;\n    return positions[monitorIndex] || fallbackPosition || theDefault;\n}\n\nexport function setPanelPosition(settings, monitorIndex, value) {\n    if (!(value === Pos.TOP || value === Pos.BOTTOM || value === Pos.LEFT\n        || value === Pos.RIGHT)) {\n        log('Not setting invalid panel position: ' + value);\n        return;\n    }\n    const positions = getSettingsJson(settings, 'panel-positions');\n    positions[monitorIndex] = value;\n    setSettingsJson(settings, 'panel-positions', positions);\n}\n\n/** Returns anchor location of panel on a specific monitor. */\nexport function getPanelAnchor(settings, monitorIndex) {\n    const anchors = getSettingsJson(settings, 'panel-anchors');\n    const theDefault = Pos.MIDDLE;\n    return anchors[monitorIndex] || theDefault;\n}\n\nexport function setPanelAnchor(settings, monitorIndex, value) {\n    if (!(value === Pos.START || value === Pos.MIDDLE || value === Pos.END)) {\n        log('Not setting invalid panel anchor: ' + value);\n        return;\n    }\n    const anchors = getSettingsJson(settings, 'panel-anchors');\n    anchors[monitorIndex] = value;\n    setSettingsJson(settings, 'panel-anchors', anchors);\n}\n"
        },
        {
          "name": "panelStyle.js",
          "type": "blob",
          "size": 12.1201171875,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Credits:\n * Ideas for recursing child actors and assigning inline styles\n * are based on code from the StatusAreaHorizontalSpacing extension\n * https://bitbucket.org/mathematicalcoffee/status-area-horizontal-spacing-gnome-shell-extension\n * mathematical.coffee@gmail.com\n */\n\nimport * as Utils from './utils.js';\nimport {SETTINGS} from './extension.js';\n\n\nexport const PanelStyle = class {\n\n    enable(panel) {\n        this.panel = panel;\n\n        this._applyStyles();\n\n        this._bindSettingsChanges();\n    }\n\n    disable() {\n        for (let i = 0; i < this._dtpSettingsSignalIds.length; ++i) {\n            SETTINGS.disconnect(this._dtpSettingsSignalIds[i]);\n        }\n\n        this._removeStyles();\n    }\n\n    _bindSettingsChanges() {\n        let configKeys = [\n            \"tray-size\",\n            \"leftbox-size\",\n            \"tray-padding\",\n            \"leftbox-padding\",\n            \"status-icon-padding\",\n        ];\n\n        this._dtpSettingsSignalIds = [];\n        \n        for(let i in configKeys) {\n            this._dtpSettingsSignalIds.push(SETTINGS.connect('changed::' + configKeys[i], () => {\n                this._removeStyles();\n                this._applyStyles();\n            }));\n        }\n    }\n\n    _applyStyles() {\n        this._rightBoxOperations = [];\n        \n        let trayPadding = SETTINGS.get_int('tray-padding');\n        let isVertical = this.panel.checkIfVertical();\n        let paddingStyle = 'padding: ' + (isVertical ? '%dpx 0' : '0 %dpx');\n\n        if(trayPadding >= 0) {\n            let operation = {};\n            let trayPaddingStyleLine;\n\n            if (isVertical) {\n                trayPaddingStyleLine = paddingStyle.format(trayPadding);\n                operation.compareFn = function (actor) {\n                    let parent = actor.get_parent();\n                    return ((parent && parent.has_style_class_name && (parent.has_style_class_name('panel-button') && !parent.has_style_class_name('clock-display'))) || \n                            (actor.has_style_class_name && actor.has_style_class_name('clock')));\n                };\n            } else {\n                trayPaddingStyleLine = '-natural-hpadding: %dpx'.format(trayPadding);\n                if (trayPadding < 6) {\n                    trayPaddingStyleLine += '; -minimum-hpadding: %dpx'.format(trayPadding);\n                }\n                \n                operation.compareFn = function (actor) {\n                    return (actor.has_style_class_name && actor.has_style_class_name('panel-button'));\n                };\n            }\n            \n            operation.applyFn = (actor, operationIdx) => {\n                this._overrideStyle(actor, trayPaddingStyleLine, operationIdx);\n                this._refreshPanelButton(actor);\n            };\n            this._rightBoxOperations.push(operation);\n        }\n\n        let statusIconPadding = SETTINGS.get_int('status-icon-padding');\n        if(statusIconPadding >= 0) {\n            let statusIconPaddingStyleLine = paddingStyle.format(statusIconPadding)\n            let operation = {};\n            operation.compareFn = function (actor) {\n                return (actor.has_style_class_name && actor.has_style_class_name('system-status-icon'));\n            };\n            operation.applyFn = (actor, operationIdx) => {\n                this._overrideStyle(actor, statusIconPaddingStyleLine, operationIdx);\n            };\n            this._rightBoxOperations.push(operation);\n        }\n\n        let trayContentSize = SETTINGS.get_int('tray-size');\n        if(trayContentSize > 0) {\n            let trayIconSizeStyleLine = 'icon-size: %dpx'.format(trayContentSize)\n            let operation = {};\n            operation.compareFn = function (actor) {\n                return (actor.constructor && actor.constructor.name == 'St_Icon');\n            };\n            operation.applyFn = (actor, operationIdx) => {\n                this._overrideStyle(actor, trayIconSizeStyleLine, operationIdx);\n            };\n            this._rightBoxOperations.push(operation);\n\n            let trayContentSizeStyleLine = 'font-size: %dpx'.format(trayContentSize)\n            operation = {};\n            operation.compareFn = function (actor) {\n                return (actor.constructor && actor.constructor.name == 'St_Label');\n            };\n            operation.applyFn = (actor, operationIdx) => {\n                this._overrideStyle(actor, trayContentSizeStyleLine, operationIdx);\n            };\n            this._rightBoxOperations.push(operation);\n\n            this._overrideStyle(this.panel._rightBox, trayContentSizeStyleLine, 0);\n            this._overrideStyle(this.panel._centerBox, trayContentSizeStyleLine, 0);\n        }\n       \n        // center box has been moved next to the right box and will be treated the same\n        this._centerBoxOperations = this._rightBoxOperations;\n\n        this._leftBoxOperations = [];\n\n        let leftboxPadding = SETTINGS.get_int('leftbox-padding');\n        if(leftboxPadding >= 0) {\n            let leftboxPaddingStyleLine = paddingStyle.format(leftboxPadding);\n            let operation = {};\n            operation.compareFn = function (actor) {\n                let parent = actor.get_parent();\n                return (parent && parent.has_style_class_name && parent.has_style_class_name('panel-button'));\n            };\n            operation.applyFn = (actor, operationIdx) => {\n                this._overrideStyle(actor, leftboxPaddingStyleLine, operationIdx);\n            };\n            this._leftBoxOperations.push(operation);\n        }\n\n        let leftboxContentSize = SETTINGS.get_int('leftbox-size');\n        if(leftboxContentSize > 0) {\n            let leftboxIconSizeStyleLine = 'icon-size: %dpx'.format(leftboxContentSize)\n            let operation = {};\n            operation.compareFn = function (actor) {\n                return (actor.constructor && actor.constructor.name == 'St_Icon');\n            };\n            operation.applyFn = (actor, operationIdx) => {\n                this._overrideStyle(actor, leftboxIconSizeStyleLine, operationIdx);\n            };\n            this._leftBoxOperations.push(operation);\n\n            let leftboxContentSizeStyleLine = 'font-size: %dpx'.format(leftboxContentSize)\n            operation = {};\n            operation.compareFn = function (actor) {\n                return (actor.constructor && actor.constructor.name == 'St_Label');\n            };\n            operation.applyFn = (actor, operationIdx) => {\n                this._overrideStyle(actor, leftboxContentSizeStyleLine, operationIdx);\n            };\n            this._leftBoxOperations.push(operation);\n\n            this._overrideStyle(this.panel._leftBox, leftboxContentSizeStyleLine, 0);\n        }\n\n        this._applyStylesRecursively();\n        \n        /* connect signal */\n        this._rightBoxActorAddedID = this.panel._rightBox.connect('child-added',\n            (container, actor) => {\n                if(this._rightBoxOperations.length && !this._ignoreAddedChild)\n                    this._recursiveApply(actor, this._rightBoxOperations);\n\n                this._ignoreAddedChild = 0;\n            }\n        );\n        this._centerBoxActorAddedID = this.panel._centerBox.connect('child-added',\n            (container, actor) => {\n                if(this._centerBoxOperations.length && !this._ignoreAddedChild)\n                    this._recursiveApply(actor, this._centerBoxOperations);\n\n                this._ignoreAddedChild = 0;\n            }\n        );\n        this._leftBoxActorAddedID = this.panel._leftBox.connect('child-added',\n            (container, actor) => {\n                if(this._leftBoxOperations.length)\n                    this._recursiveApply(actor, this._leftBoxOperations);\n            }\n        );\n    }\n\n    _removeStyles() {\n        /* disconnect signal */\n        if (this._rightBoxActorAddedID) \n            this.panel._rightBox.disconnect(this._rightBoxActorAddedID);\n        if (this._centerBoxActorAddedID) \n            this.panel._centerBox.disconnect(this._centerBoxActorAddedID);\n        if (this._leftBoxActorAddedID) \n            this.panel._leftBox.disconnect(this._leftBoxActorAddedID);\n\n        this._restoreOriginalStyle(this.panel._rightBox);\n        this._restoreOriginalStyle(this.panel._centerBox);\n        this._restoreOriginalStyle(this.panel._leftBox);\n\n        this._applyStylesRecursively(true);\n    }\n\n    _applyStylesRecursively(restore) {\n        /*recurse actors */\n        if(this._rightBoxOperations.length) {\n            // add the system menu as we move it from the rightbox to the panel to position it independently\n            let children = this.panel._rightBox.get_children().concat([this.panel.statusArea[Utils.getSystemMenuInfo().name].container]);\n            for(let i in children)\n                this._recursiveApply(children[i], this._rightBoxOperations, restore);\n        }\n\n        if(this._centerBoxOperations.length) {\n            // add the date menu as we move it from the centerbox to the panel to position it independently\n            let children = this.panel._centerBox.get_children().concat([this.panel.statusArea.dateMenu.container]);\n            for(let i in children)\n                this._recursiveApply(children[i], this._centerBoxOperations, restore);\n        }\n\n        if(this._leftBoxOperations.length) {\n            let children = this.panel._leftBox.get_children();\n            for(let i in children)\n                this._recursiveApply(children[i], this._leftBoxOperations, restore);\n        }\n    }\n\n    _recursiveApply(actor, operations, restore) {\n        for(let i in operations) {\n            let o = operations[i];\n            if(o.compareFn(actor))\n                if(restore)\n                    o.restoreFn ? o.restoreFn(actor) : this._restoreOriginalStyle(actor);\n                else\n                    o.applyFn(actor, i);\n        }\n\n        if(actor.get_children) {\n            let children = actor.get_children();\n            for(let i in children) {\n                this._recursiveApply(children[i], operations, restore);\n            }\n        }\n    }\n    \n    _overrideStyle(actor, styleLine, operationIdx) {\n        if (actor._dtp_original_inline_style === undefined) {\n            actor._dtp_original_inline_style = actor.get_style();\n        }\n\n        if(actor._dtp_style_overrides === undefined) {\n            actor._dtp_style_overrides = {};\n        }\n\n        actor._dtp_style_overrides[operationIdx] = styleLine;\n        let newStyleLine = '';\n        for(let i in actor._dtp_style_overrides)\n            newStyleLine += actor._dtp_style_overrides[i] + '; ';\n        actor.set_style(newStyleLine + (actor._dtp_original_inline_style || ''));\n     }\n\n    _restoreOriginalStyle(actor) {\n        if (actor._dtp_original_inline_style !== undefined) {\n            actor.set_style(actor._dtp_original_inline_style);\n            delete actor._dtp_original_inline_style;\n            delete actor._dtp_style_overrides;\n        }\n\n        if (actor.has_style_class_name('panel-button')) {\n            this._refreshPanelButton(actor);\n        }\n    }\n\n    _refreshPanelButton(actor) {\n        if (actor.visible) {\n            //force gnome 3.34+ to refresh (having problem with the -natural-hpadding)\n            let parent = actor.get_parent();\n            let children = parent.get_children();\n            let actorIndex = 0;\n\n            if (children.length > 1) {\n                actorIndex = children.indexOf(actor);\n            }\n\n            this._ignoreAddedChild = [this.panel._centerBox, this.panel._rightBox].indexOf(parent) >= 0;\n\n            parent.remove_child(actor);\n            parent.insert_child_at_index(actor, actorIndex);\n        }\n    }\n    \n}\n"
        },
        {
          "name": "po",
          "type": "tree",
          "content": null
        },
        {
          "name": "prefs.js",
          "type": "blob",
          "size": 116.3994140625,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Credits:\n * This file is based on code from the Dash to Dock extension by micheleg.\n * Some code was also adapted from the upstream Gnome Shell source code.\n */\n\nimport GdkPixbuf from 'gi://GdkPixbuf';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport GObject from 'gi://GObject';\nimport Gtk from 'gi://Gtk';\nimport Gdk from 'gi://Gdk';\n\nimport * as PanelSettings from './panelSettings.js';\nimport * as Pos from './panelPositions.js';\n\nimport {ExtensionPreferences, gettext as _, ngettext} from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js';\n\nconst SCALE_UPDATE_TIMEOUT = 500;\nconst DEFAULT_PANEL_SIZES = [ 128, 96, 64, 48, 32, 24, 16 ];\nconst DEFAULT_FONT_SIZES = [ 96, 64, 48, 32, 24, 16, 0 ];\nconst DEFAULT_MARGIN_SIZES = [ 32, 24, 16, 12, 8, 4, 0 ];\nconst DEFAULT_PADDING_SIZES = [ 32, 24, 16, 12, 8, 4, 0, -1 ];\n// Minimum length could be 0, but a higher value may help prevent confusion about where the panel went.\nconst LENGTH_MARKS = [ 100, 90, 80, 70, 60, 50, 40, 30, 20, 10 ];\nconst MAX_WINDOW_INDICATOR = 4;\n\nconst SCHEMA_PATH = '/org/gnome/shell/extensions/dash-to-panel/';\n\n/**\n * This function was copied from the activities-config extension\n * https://github.com/nls1729/acme-code/tree/master/activities-config\n * by Norman L. Smith.\n */\nfunction cssHexString(css) {\n    let rrggbb = '#';\n    let start;\n    for (let loop = 0; loop < 3; loop++) {\n        let end = 0;\n        let xx = '';\n        for (let loop = 0; loop < 2; loop++) {\n            while (true) {\n                let x = css.slice(end, end + 1);\n                if ((x == '(') || (x == ',') || (x == ')'))\n                    break;\n                end++;\n            }\n            if (loop == 0) {\n                end++;\n                start = end;\n            }\n        }\n        xx = parseInt(css.slice(start, end)).toString(16);\n        if (xx.length == 1)\n            xx = '0' + xx;\n        rrggbb += xx;\n        css = css.slice(end);\n    }\n    return rrggbb;\n}\n\nfunction setShortcut(settings, shortcutName) {\n    let shortcut_text = settings.get_string(shortcutName + '-text');\n    let [success, key, mods] = Gtk.accelerator_parse(shortcut_text);\n\n    if (success && Gtk.accelerator_valid(key, mods)) {\n        let shortcut = Gtk.accelerator_name(key, mods);\n        settings.set_strv(shortcutName, [shortcut]);\n    }\n    else {\n        settings.set_strv(shortcutName, []);\n    }\n}\n\nfunction checkHotkeyPrefix(settings) {\n    settings.delay();\n\n    let hotkeyPrefix = settings.get_string('hotkey-prefix-text');\n    if (hotkeyPrefix == 'Super')\n       hotkeyPrefix = '<Super>';\n    else if (hotkeyPrefix == 'SuperAlt')\n       hotkeyPrefix = '<Super><Alt>';\n    let [ , , mods]       = Gtk.accelerator_parse(hotkeyPrefix);\n    let [ , , shift_mods] = Gtk.accelerator_parse('<Shift>' + hotkeyPrefix);\n    let [ , , ctrl_mods]  = Gtk.accelerator_parse('<Ctrl>'  + hotkeyPrefix);\n\n    let numHotkeys = 10;\n    for (let i = 1; i <= numHotkeys; i++) {\n        let number = i;\n        if (number == 10)\n            number = 0;\n        let key    = Gdk.keyval_from_name(number.toString());\n        let key_kp = Gdk.keyval_from_name('KP_' + number.toString());\n        if (Gtk.accelerator_valid(key, mods)) {\n            let shortcut    = Gtk.accelerator_name(key, mods);\n            let shortcut_kp = Gtk.accelerator_name(key_kp, mods);\n\n            // Setup shortcut strings\n            settings.set_strv('app-hotkey-'    + i, [shortcut]);\n            settings.set_strv('app-hotkey-kp-' + i, [shortcut_kp]);\n\n            // With <Shift>\n            shortcut    = Gtk.accelerator_name(key, shift_mods);\n            shortcut_kp = Gtk.accelerator_name(key_kp, shift_mods);\n            settings.set_strv('app-shift-hotkey-'    + i, [shortcut]);\n            settings.set_strv('app-shift-hotkey-kp-' + i, [shortcut_kp]);\n\n            // With <Control>\n            shortcut    = Gtk.accelerator_name(key, ctrl_mods);\n            shortcut_kp = Gtk.accelerator_name(key_kp, ctrl_mods);\n            settings.set_strv('app-ctrl-hotkey-'    + i, [shortcut]);\n            settings.set_strv('app-ctrl-hotkey-kp-' + i, [shortcut_kp]);\n        }\n        else {\n            // Reset default settings for the relevant keys if the\n            // accelerators are invalid\n            let keys = ['app-hotkey-' + i, 'app-shift-hotkey-' + i, 'app-ctrl-hotkey-' + i,  // Regular numbers\n                        'app-hotkey-kp-' + i, 'app-shift-hotkey-kp-' + i, 'app-ctrl-hotkey-kp-' + i]; // Key-pad numbers\n            keys.forEach(function(val) {\n                settings.set_value(val, settings.get_default_value(val));\n            }, this);\n        }\n    }\n\n    settings.apply();\n}\n\nfunction mergeObjects(main, bck) {\n    for (const prop in bck) {\n        if (!main.hasOwnProperty(prop) && bck.hasOwnProperty(prop)) {\n            main[prop] = bck[prop];\n        }\n    }\n\n    return main;\n}\n\nconst Preferences = class {\n\n    constructor(window, settings, path) {\n        // this._settings = ExtensionUtils.getSettings('org.gnome.shell.extensions.dash-to-panel');\n        this._rtl = (Gtk.Widget.get_default_direction() == Gtk.TextDirection.RTL);\n        this._builder = new Gtk.Builder();\n        this._builder.set_scope(new BuilderScope(this));\n        this._settings = settings;\n        this._path = path;\n        \n        this._metadata = ExtensionPreferences.lookupByURL(import.meta.url).metadata;\n        this._builder.set_translation_domain(this._metadata['gettext-domain']);\n\n        window.set_search_enabled(true);\n\n        // dialogs\n        this._builder.add_from_file(this._path + '/ui/BoxAnimateAppIconHoverOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxDotOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxShowDesktopOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxDynamicOpacityOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxIntellihideOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxShowApplicationsOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxWindowPreviewOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxGroupAppsOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxMiddleClickOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxOverlayShortcut.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxSecondaryMenuOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxScrollPanelOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxScrollIconOptions.ui');\n        this._builder.add_from_file(this._path + '/ui/BoxAdvancedOptions.ui');\n\n        // pages\n        this._builder.add_from_file(this._path + '/ui/SettingsPosition.ui');\n        let pagePosition = this._builder.get_object('position');\n        window.add(pagePosition);\n\n        this._builder.add_from_file(this._path + '/ui/SettingsStyle.ui');\n        let pageStyle = this._builder.get_object('style');\n        window.add(pageStyle);\n\n        this._builder.add_from_file(this._path + '/ui/SettingsBehavior.ui');\n        let pageBehavior = this._builder.get_object('behavior');\n        window.add(pageBehavior);\n\n        this._builder.add_from_file(this._path + '/ui/SettingsAction.ui');\n        let pageAction = this._builder.get_object('action');\n        window.add(pageAction);\n\n        this._builder.add_from_file(this._path + '/ui/SettingsFineTune.ui');\n        let pageFineTune = this._builder.get_object('finetune');\n        window.add(pageFineTune);\n\n        this._builder.add_from_file(this._path + '/ui/SettingsAbout.ui');\n        let pageAbout = this._builder.get_object('about');\n        window.add(pageAbout);\n\n        let listbox = this._builder.get_object('taskbar_display_listbox');\n        let provider = new Gtk.CssProvider();\n        provider.load_from_data('list { background-color: transparent; }', -1);\n        let context = listbox.get_style_context();\n        context.add_provider(provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION);\n\n        // set the window as notebook, it is being used as parent for dialogs\n        this.notebook = window;\n\n        // Timeout to delay the update of the settings\n        this._panel_size_timeout = 0;\n        this._dot_height_timeout = 0;\n        this._tray_size_timeout = 0;\n        this._leftbox_size_timeout = 0;\n        this._appicon_margin_timeout = 0;\n        this._appicon_padding_timeout = 0;\n        this._opacity_timeout = 0;\n        this._tray_padding_timeout = 0;\n        this._statusicon_padding_timeout = 0;\n        this._leftbox_padding_timeout = 0;\n        this._addFormatValueCallbacks();\n        this._bindSettings();\n    }\n\n    /**\n     * Connect signals\n     */\n    _connector(builder, object, signal, handler) {\n        object.connect(signal, this._SignalHandler[handler].bind(this));\n    }\n\n    _updateVerticalRelatedOptions() {\n        let position = this._getPanelPosition(this._currentMonitorIndex);\n        let isVertical = position == Pos.LEFT || position == Pos.RIGHT;\n        let showDesktopWidthLabel = this._builder.get_object('show_showdesktop_width_label');\n\n        showDesktopWidthLabel.set_title(isVertical ? _('Show Desktop button height (px)') : _('Show Desktop button width (px)'));\n\n        this._displayPanelPositionsForMonitor(this._currentMonitorIndex);\n    }\n\n    _maybeDisableTopPosition() {\n        let keepTopPanel = this._settings.get_boolean('stockgs-keep-top-panel');\n        let monitorSync = this._settings.get_boolean('panel-element-positions-monitors-sync');\n        let topAvailable = !keepTopPanel || (!monitorSync && this._currentMonitorIndex != this.monitors[0]);\n        let topRadio = this._builder.get_object('position_top_button');\n\n        topRadio.set_sensitive(topAvailable);\n        topRadio.set_tooltip_text(!topAvailable ? _('Unavailable when gnome-shell top panel is present') : '');\n    }\n\n    _getPanelPosition(monitorIndex) {\n        return PanelSettings.getPanelPosition(this._settings, monitorIndex);\n    }\n\n    _setPanelPosition(position) {\n        const monitorSync = this._settings.get_boolean('panel-element-positions-monitors-sync');\n        const monitorsToSetFor = monitorSync ? this.monitors : [this._currentMonitorIndex];\n        monitorsToSetFor.forEach(monitorIndex => {\n            PanelSettings.setPanelPosition(this._settings, monitorIndex, position);\n        });\n        this._setAnchorLabels(this._currentMonitorIndex);\n    }\n\n    _setPositionRadios(position) {\n        this._ignorePositionRadios = true;\n\n        switch (position) {\n            case Pos.BOTTOM:\n                this._builder.get_object('position_bottom_button').set_active(true);\n                break;\n            case Pos.TOP:\n                this._builder.get_object('position_top_button').set_active(true);\n                break;\n            case Pos.LEFT:\n                this._builder.get_object('position_left_button').set_active(true);\n                break;\n            case Pos.RIGHT:\n                this._builder.get_object('position_right_button').set_active(true);\n                break;\n        }\n\n        this._ignorePositionRadios = false;\n    }\n\n    /**\n     * Set panel anchor combo labels according to whether the monitor's panel is vertical\n     * or horizontal, or if all monitors' panels are being configured and they are a mix\n     * of vertical and horizontal.\n     */\n    _setAnchorLabels(currentMonitorIndex) {\n        const monitorSync = this._settings.get_boolean('panel-element-positions-monitors-sync');\n        const monitorsToSetFor = monitorSync ? this.monitors : [currentMonitorIndex];\n        const allVertical = monitorsToSetFor.every(i => {\n            const position = PanelSettings.getPanelPosition(this._settings, i);\n            return position === Pos.LEFT || position === Pos.RIGHT\n        });\n        const allHorizontal = monitorsToSetFor.every(i => {\n            const position = PanelSettings.getPanelPosition(this._settings, i);\n            return position === Pos.TOP || position === Pos.BOTTOM;\n        });\n\n        const anchor_combo = this._builder.get_object('panel_anchor_combo');\n        anchor_combo.remove_all();\n\n        if (allHorizontal) {\n            anchor_combo.append(Pos.START, _('Left'));\n            anchor_combo.append(Pos.MIDDLE, _('Center'));\n            anchor_combo.append(Pos.END, _('Right'));\n        } else if (allVertical) {\n            anchor_combo.append(Pos.START, _('Top'));\n            anchor_combo.append(Pos.MIDDLE, _('Middle'));\n            anchor_combo.append(Pos.END, _('Bottom'));\n        } else {\n            // Setting for a mix of horizontal and vertical panels on different monitors.\n            anchor_combo.append(Pos.START, _('Start'));\n            anchor_combo.append(Pos.MIDDLE, _('Middle'));\n            anchor_combo.append(Pos.END, _('End'));\n        }\n\n        // Set combo box after re-populating its options. But only if it's for a single-panel\n        // configuration, or a multi-panel configuration where they all have the same anchor\n        // setting. So don't set the combo box if there is a multi-panel configuration with\n        // different anchor settings.\n        const someAnchor = PanelSettings.getPanelAnchor(this._settings, currentMonitorIndex);\n        if (monitorsToSetFor.every(i =>\n            PanelSettings.getPanelAnchor(this._settings, i) === someAnchor)) {\n            const panel_anchor = PanelSettings.getPanelAnchor(this._settings, currentMonitorIndex);\n            this._builder.get_object('panel_anchor_combo').set_active_id(panel_anchor);\n        }\n    }\n\n    /**\n     * When a monitor is selected, update the widgets for panel position, size, anchoring,\n     * and contents so they accurately show the settings for the panel on that monitor.\n     */\n    _updateWidgetSettingsForMonitor(monitorIndex) {\n        // Update display of panel screen position setting\n        this._maybeDisableTopPosition();\n        const panelPosition = this._getPanelPosition(monitorIndex);\n        this._setPositionRadios(panelPosition);\n\n        // Update display of thickness, length, and anchor settings\n        const panel_size_scale = this._builder.get_object('panel_size_scale');\n        const size = PanelSettings.getPanelSize(this._settings, monitorIndex);\n        panel_size_scale.set_value(size);\n\n        const panel_length_scale = this._builder.get_object('panel_length_scale');\n        const length = PanelSettings.getPanelLength(this._settings, monitorIndex);\n        panel_length_scale.set_value(length);\n        this._setAnchorWidgetSensitivity(length);\n\n        this._setAnchorLabels(monitorIndex);\n\n        // Update display of panel content settings\n        this._displayPanelPositionsForMonitor(monitorIndex);\n    }\n\n    /**\n     * Anchor is only relevant if panel length is less than 100%. Enable or disable\n     * anchor widget sensitivity accordingly.\n     */\n    _setAnchorWidgetSensitivity(panelLength) {\n        const isPartialLength = panelLength < 100;\n        this._builder.get_object('panel_anchor_label').set_sensitive(isPartialLength);\n        this._builder.get_object('panel_anchor_combo').set_sensitive(isPartialLength);\n    }\n\n    _displayPanelPositionsForMonitor(monitorIndex) {\n        let taskbarListBox = this._builder.get_object('taskbar_display_listbox');\n        \n        while(taskbarListBox.get_first_child())\n        {\n            taskbarListBox.remove(taskbarListBox.get_first_child());\n        }\n\n        let labels = {};\n        let panelPosition = this._getPanelPosition(monitorIndex);\n        let isVertical = panelPosition == Pos.LEFT || panelPosition == Pos.RIGHT;\n        let panelElementPositionsSettings = PanelSettings.getSettingsJson(this._settings, 'panel-element-positions');\n        let panelElementPositions = panelElementPositionsSettings[monitorIndex] || Pos.defaults;\n        let updateElementsSettings = () => {\n            let newPanelElementPositions = [];\n            let monitorSync = this._settings.get_boolean('panel-element-positions-monitors-sync');\n            let monitors = monitorSync ? this.monitors : [monitorIndex];\n\n            let child = taskbarListBox.get_first_child();\n            while (child != null)\n            {\n                newPanelElementPositions.push({\n                    element: child.id,\n                    visible: child.visibleToggleBtn.get_active(),\n                    position: child.positionCombo.get_active_id()\n                });\n                child = child.get_next_sibling();\n            }\n            \n            monitors.forEach(m => panelElementPositionsSettings[m] = newPanelElementPositions);\n            this._settings.set_string('panel-element-positions', JSON.stringify(panelElementPositionsSettings));\n        };\n\n\n        labels[Pos.SHOW_APPS_BTN] = _('Show Applications button');\n        labels[Pos.ACTIVITIES_BTN] = _('Activities button');\n        labels[Pos.TASKBAR] = _('Taskbar');\n        labels[Pos.DATE_MENU] = _('Date menu');\n        labels[Pos.SYSTEM_MENU] = _('System menu');\n        labels[Pos.LEFT_BOX] = _('Left box');\n        labels[Pos.CENTER_BOX] = _('Center box');\n        labels[Pos.RIGHT_BOX] = _('Right box');\n        labels[Pos.DESKTOP_BTN] = _('Desktop button');\n\n        panelElementPositions.forEach(el => {\n            let row = new Gtk.ListBoxRow();\n            let grid = new Gtk.Grid({ margin_start: 12, margin_end: 12, column_spacing: 8 });\n            let upDownGrid = new Gtk.Grid({ column_spacing: 2 });\n            let upBtn = new Gtk.Button({ tooltip_text: _('Move up') });\n            let upImg = new Gtk.Image({ icon_name: 'go-up-symbolic', pixel_size: 12 });\n            let downBtn = new Gtk.Button({ tooltip_text: _('Move down') });\n            let downImg = new Gtk.Image({ icon_name: 'go-down-symbolic', pixel_size: 12 });\n            let visibleToggleBtn = new Gtk.ToggleButton({ label: _('Visible'), active: el.visible });\n            let positionCombo = new Gtk.ComboBoxText({ tooltip_text: _('Select element position') });\n            let upDownClickHandler = limit => {\n                let index = row.get_index();\n\n                if (index != limit) {\n                    taskbarListBox.remove(row);\n                    taskbarListBox.insert(row, index + (!limit ? -1 : 1));\n                    updateElementsSettings();\n                }\n            };\n\n            positionCombo.append(Pos.STACKED_TL, isVertical ? _('Stacked to top') : _('Stacked to left'));\n            positionCombo.append(Pos.STACKED_BR, isVertical ? _('Stacked to bottom') :_('Stacked to right'));\n            positionCombo.append(Pos.CENTERED, _('Centered'));\n            positionCombo.append(Pos.CENTERED_MONITOR, _('Monitor Center'));\n            positionCombo.set_active_id(el.position);\n\n            upBtn.connect('clicked', () => upDownClickHandler(0));\n            downBtn.connect('clicked', () => upDownClickHandler(panelElementPositions.length - 1));\n            visibleToggleBtn.connect('toggled', () => updateElementsSettings());\n            positionCombo.connect('changed', () => updateElementsSettings());\n\n            upBtn.set_child(upImg);\n            downBtn.set_child(downImg);\n\n            upDownGrid.attach(upBtn, 0, 0, 1, 1);\n            upDownGrid.attach(downBtn, 1, 0, 1, 1);\n\n            grid.attach(upDownGrid, 0, 0, 1, 1);\n            grid.attach(new Gtk.Label({ label: labels[el.element], xalign: 0, hexpand: true }), 1, 0, 1, 1);\n\n            if (Pos.optionDialogFunctions[el.element]) {\n                let cogImg = new Gtk.Image({ icon_name: 'emblem-system-symbolic' });\n                let optionsBtn = new Gtk.Button({ tooltip_text: _('More options') });\n                \n                optionsBtn.get_style_context().add_class('circular');\n                optionsBtn.set_child(cogImg);\n                grid.attach(optionsBtn, 2, 0, 1, 1);\n\n                optionsBtn.connect('clicked', () => this[Pos.optionDialogFunctions[el.element]]());\n            }\n\n            grid.attach(visibleToggleBtn, 3, 0, 1, 1);\n            grid.attach(positionCombo, 4, 0, 1, 1);\n\n            row.id = el.element;\n            row.visibleToggleBtn = visibleToggleBtn;\n            row.positionCombo = positionCombo;\n\n            row.set_child(grid);\n            taskbarListBox.insert(row, -1);\n        });\n    }\n\n    _createPreferencesDialog(title, content, reset_function = null) {\n        let dialog;\n        \n        dialog = new Gtk.Dialog({ title: title,\n                                    transient_for: this.notebook.get_root(),\n                                    use_header_bar: true,\n                                    modal: true });\n\n        // GTK+ leaves positive values for application-defined response ids.\n        // Use +1 for the reset action\n        if (reset_function != null)\n            dialog.add_button(_('Reset to defaults'), 1);\n\n        dialog.get_content_area().append(content);\n\n        dialog.connect('response', (dialog, id) => {\n            if (id == 1) {\n                // restore default settings\n                if (reset_function)\n                    reset_function();\n            } else {\n                // remove the settings content so it doesn't get destroyed;\n                dialog.get_content_area().remove(content);\n                dialog.destroy();\n            }\n            return;\n        });\n\n        return dialog;\n    }\n\n    _showShowAppsButtonOptions() {\n        let box = this._builder.get_object('show_applications_options');\n\n        let dialog = this._createPreferencesDialog(_('Show Applications options'), box, () =>\n        {\n            // restore default settings\n            this._settings.set_value('show-apps-icon-side-padding', this._settings.get_default_value('show-apps-icon-side-padding'));\n            this._builder.get_object('show_applications_side_padding_spinbutton').set_value(this._settings.get_int('show-apps-icon-side-padding'));\n            this._settings.set_value('show-apps-override-escape', this._settings.get_default_value('show-apps-override-escape'));\n            handleIconChange.call(this, null);\n        });\n\n        let fileChooserButton = this._builder.get_object('show_applications_icon_file_filebutton');\n        let fileChooser = new Gtk.FileChooserNative({ title: _('Open icon'), transient_for: dialog });\n        let fileImage = this._builder.get_object('show_applications_current_icon_image');\n        let fileFilter = new Gtk.FileFilter();\n        fileFilter.add_pixbuf_formats();\n        fileChooser.filter = fileFilter;\n\n        let handleIconChange = function(newIconPath) {\n            if (newIconPath && GLib.file_test(newIconPath, GLib.FileTest.EXISTS)) {\n                let file = Gio.File.new_for_path(newIconPath);\n                let pixbuf = GdkPixbuf.Pixbuf.new_from_stream_at_scale(file.read(null), 32, 32, true, null);\n\n                fileImage.set_from_pixbuf(pixbuf);\n                fileChooser.set_file(file);\n                fileChooserButton.set_label(newIconPath);\n            } else {\n                newIconPath = '';\n                fileImage.set_from_icon_name('view-app-grid-symbolic');\n                let picturesFolder = Gio.File.new_for_path(GLib.get_user_special_dir(GLib.UserDirectory.DIRECTORY_PICTURES));\n                fileChooser.set_file(picturesFolder);\n                fileChooserButton.set_label(\"(None)\");\n            }\n\n            this._settings.set_string('show-apps-icon-file', newIconPath || '');\n        };\n\n        fileChooserButton.connect('clicked', () => {\n            fileChooser.show();\n        });\n\n        fileChooser.connect('response', widget => handleIconChange.call(this, widget.get_file().get_path()));\n        handleIconChange.call(this, this._settings.get_string('show-apps-icon-file'));\n\n        // we have to destroy the fileChooser as well\n        dialog.connect('response', (dialog, id) => {\n            if (id != 1) {\n                fileChooser.destroy();\n            }\n            return;\n        });\n\n        dialog.show();\n        dialog.set_default_size(1, 1);\n    }\n\n    _showDesktopButtonOptions() {\n        let box = this._builder.get_object('box_show_showdesktop_options');\n        \n        let dialog = this._createPreferencesDialog(_('Show Desktop options'), box, () =>\n        {\n            // restore default settings\n            this._settings.set_value('showdesktop-button-width', this._settings.get_default_value('showdesktop-button-width'));\n            this._builder.get_object('show_showdesktop_width_spinbutton').set_value(this._settings.get_int('showdesktop-button-width'));\n\n            this._settings.set_value('desktop-line-use-custom-color', this._settings.get_default_value('desktop-line-use-custom-color'));\n\n            this._settings.set_value('show-showdesktop-hover', this._settings.get_default_value('show-showdesktop-hover'));\n\n            this._settings.set_value('show-showdesktop-delay', this._settings.get_default_value('show-showdesktop-delay'));\n            this._builder.get_object('show_showdesktop_delay_spinbutton').set_value(this._settings.get_int('show-showdesktop-delay'));\n\n            this._settings.set_value('show-showdesktop-time', this._settings.get_default_value('show-showdesktop-time'));\n            this._builder.get_object('show_showdesktop_time_spinbutton').set_value(this._settings.get_int('show-showdesktop-time'));\n        });\n\n        this._builder.get_object('show_showdesktop_width_spinbutton').set_value(this._settings.get_int('showdesktop-button-width'));\n        this._builder.get_object('show_showdesktop_width_spinbutton').connect('value-changed', (widget) => {\n            this._settings.set_int('showdesktop-button-width', widget.get_value());\n        });\n\n        this._builder.get_object('show_showdesktop_delay_spinbutton').set_value(this._settings.get_int('show-showdesktop-delay'));\n        this._builder.get_object('show_showdesktop_delay_spinbutton').connect('value-changed', (widget) => {\n            this._settings.set_int('show-showdesktop-delay', widget.get_value());\n        });\n\n        this._builder.get_object('show_showdesktop_time_spinbutton').set_value(this._settings.get_int('show-showdesktop-time'));\n        this._builder.get_object('show_showdesktop_time_spinbutton').connect('value-changed', (widget) => {\n            this._settings.set_int('show-showdesktop-time', widget.get_value());\n        });\n\n        dialog.show();\n        dialog.set_default_size(1, 1);\n    }\n\n    _addFormatValueCallbacks() {\n        // position\n        this._builder.get_object('panel_size_scale')\n        .set_format_value_func((scale, value) => {\n            return value + ' px';\n        });\n\n        // style\n        this._builder.get_object('appicon_margin_scale')\n        .set_format_value_func((scale, value) => {\n            return value + ' px';\n        });\n\n        this._builder.get_object('appicon_padding_scale')\n        .set_format_value_func((scale, value) => {\n            return value + ' px';\n        });\n\n        // fine-tune box1\n        this._builder.get_object('tray_size_scale')\n        .set_format_value_func((scale, value) => {\n            return value + ' px';\n        });\n\n        this._builder.get_object('leftbox_size_scale')\n        .set_format_value_func((scale, value) => {\n            return value + ' px';\n        });\n\n        // fine-tune box2\n        this._builder.get_object('tray_padding_scale')\n        .set_format_value_func((scale, value) => {\n            return value + ' px';\n        });\n\n        this._builder.get_object('statusicon_padding_scale')\n        .set_format_value_func((scale, value) => {\n            return value + ' px';\n        });\n\n        this._builder.get_object('leftbox_padding_scale')\n        .set_format_value_func((scale, value) => {\n            return value + ' px';\n        });\n\n        // animate hovering app icons dialog\n        this._builder.get_object('animate_appicon_hover_options_duration_scale')\n        .set_format_value_func((scale, value) => {\n            return _(\"%d ms\").format(value);\n        });\n\n        this._builder.get_object('animate_appicon_hover_options_rotation_scale')\n        .set_format_value_func((scale, value) => {\n            return _(\"%d °\").format(value);\n        });\n\n        this._builder.get_object('animate_appicon_hover_options_travel_scale')\n        .set_format_value_func((scale, value) => {\n            return _(\"%d %%\").format(value);\n        });\n\n        this._builder.get_object('animate_appicon_hover_options_zoom_scale')\n        .set_format_value_func((scale, value) => {\n            return _(\"%d %%\").format(value);\n        });\n\n        this._builder.get_object('animate_appicon_hover_options_convexity_scale')\n        .set_format_value_func((scale, value) => {\n            return _(\"%.1f\").format(value);\n        });\n\n        this._builder.get_object('animate_appicon_hover_options_extent_scale')\n        .set_format_value_func((scale, value) => {\n            return ngettext(\"%d icon\", \"%d icons\", value).format(value);\n        });\n    }\n\n    _bindSettings() {\n        // size options\n        let panel_size_scale = this._builder.get_object('panel_size_scale');\n        panel_size_scale.set_range(DEFAULT_PANEL_SIZES[DEFAULT_PANEL_SIZES.length - 1], DEFAULT_PANEL_SIZES[0]);\n        DEFAULT_PANEL_SIZES.slice(1, -1).forEach(function(val) {\n             panel_size_scale.add_mark(val, Gtk.PositionType.TOP, val.toString());\n        });\n\n        // Correct for rtl languages\n        if (this._rtl) {\n            // Flip value position: this is not done automatically\n            panel_size_scale.set_value_pos(Gtk.PositionType.LEFT);\n            // I suppose due to a bug, having a more than one mark and one above a value of 100\n            // makes the rendering of the marks wrong in rtl. This doesn't happen setting the scale as not flippable\n            // and then manually inverting it\n            panel_size_scale.set_flippable(false);\n            panel_size_scale.set_inverted(true);\n        }\n\n        // App icon style option\n        this._builder.get_object('appicon_style_combo').set_active_id(this._settings.get_string('appicon-style'));\n        this._builder.get_object('appicon_style_combo').connect('changed', (widget) => {\n            this._settings.set_string('appicon-style', widget.get_active_id());\n        });\n\n        // Dots Position option\n        let dotPosition = this._settings.get_string('dot-position');\n\n        switch (dotPosition) {\n            case 'BOTTOM':\n                this._builder.get_object('dots_bottom_button').set_active(true);\n                break;\n            case 'TOP':\n                this._builder.get_object('dots_top_button').set_active(true);\n                break;\n            case 'LEFT':\n                this._builder.get_object('dots_left_button').set_active(true);\n                break;\n            case 'RIGHT':\n                this._builder.get_object('dots_right_button').set_active(true);\n                break;\n        }\n\n        this._builder.get_object('dot_style_focused_combo').set_active_id(this._settings.get_string('dot-style-focused'));\n        this._builder.get_object('dot_style_focused_combo').connect('changed', (widget) => {\n            this._settings.set_string('dot-style-focused', widget.get_active_id());\n        });\n\n        this._builder.get_object('dot_style_unfocused_combo').set_active_id(this._settings.get_string('dot-style-unfocused'));\n        this._builder.get_object('dot_style_unfocused_combo').connect('changed', (widget) => {\n            this._settings.set_string('dot-style-unfocused', widget.get_active_id());\n        });\n\n        for (let i = 1; i <= MAX_WINDOW_INDICATOR; i++) {\n            let idx = i;\n            this._builder.get_object('dot_color_' + idx + '_colorbutton').connect('color-set', (button) => {\n                let rgba = button.get_rgba();\n                let css = rgba.to_string();\n                let hexString = cssHexString(css);\n                this._settings.set_string('dot-color-' + idx, hexString);\n            });\n\n            this._builder.get_object('dot_color_unfocused_' + idx + '_colorbutton').connect('color-set', (button) => {\n                let rgba = button.get_rgba();\n                let css = rgba.to_string();\n                let hexString = cssHexString(css);\n                this._settings.set_string('dot-color-unfocused-' + idx, hexString);\n            });\n        }\n\n        this._builder.get_object('dot_color_apply_all_button').connect('clicked', () => {\n            for (let i = 2; i <= MAX_WINDOW_INDICATOR; i++) {\n                this._settings.set_value('dot-color-' + i, this._settings.get_value('dot-color-1'));\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('dot-color-' + i));\n                this._builder.get_object('dot_color_' + i + '_colorbutton').set_rgba(rgba);\n            }\n        });\n\n        this._builder.get_object('dot_color_unfocused_apply_all_button').connect('clicked', () => {\n            for (let i = 2; i <= MAX_WINDOW_INDICATOR; i++) {\n                this._settings.set_value('dot-color-unfocused-' + i, this._settings.get_value('dot-color-unfocused-1'));\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('dot-color-unfocused-' + i));\n                this._builder.get_object('dot_color_unfocused_' + i + '_colorbutton').set_rgba(rgba);\n            }\n        });\n\n        this._builder.get_object('focus_highlight_color_colorbutton').connect('color-set', (button) => {\n            let rgba = button.get_rgba();\n            let css = rgba.to_string();\n            let hexString = cssHexString(css);\n            this._settings.set_string('focus-highlight-color', hexString);\n        });\n\n        this._builder.get_object('dot_style_options_button').connect('clicked', () => {\n            let box = this._builder.get_object('box_dots_options');\n\n            let dialog = this._createPreferencesDialog(_('Running Indicator Options'), box, () =>\n            {\n                // restore default settings\n                this._settings.set_value('dot-color-dominant', this._settings.get_default_value('dot-color-dominant'));\n                this._settings.set_value('dot-color-override', this._settings.get_default_value('dot-color-override'));\n                this._settings.set_value('dot-color-unfocused-different', this._settings.get_default_value('dot-color-unfocused-different'));\n\n                this._settings.set_value('focus-highlight-color', this._settings.get_default_value('focus-highlight-color'));\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('focus-highlight-color'));\n                this._builder.get_object('focus_highlight_color_colorbutton').set_rgba(rgba);\n\n                this._settings.set_value('focus-highlight-opacity', this._settings.get_default_value('focus-highlight-opacity'));\n                this._builder.get_object('focus_highlight_opacity_spinbutton').set_value(this._settings.get_int('focus-highlight-opacity'));\n\n                for (let i = 1; i <= MAX_WINDOW_INDICATOR; i++) {\n                    this._settings.set_value('dot-color-' + i, this._settings.get_default_value('dot-color-' + i));\n                    rgba = new Gdk.RGBA();\n                    rgba.parse(this._settings.get_string('dot-color-' + i));\n                    this._builder.get_object('dot_color_' + i + '_colorbutton').set_rgba(rgba);\n\n                    this._settings.set_value('dot-color-unfocused-' + i, this._settings.get_default_value('dot-color-unfocused-' + i));\n                    rgba = new Gdk.RGBA();\n                    rgba.parse(this._settings.get_string('dot-color-unfocused-' + i));\n                    this._builder.get_object('dot_color_unfocused_' + i + '_colorbutton').set_rgba(rgba);\n                }\n\n                this._settings.set_value('dot-size', this._settings.get_default_value('dot-size'));\n                this._builder.get_object('dot_size_spinbutton').set_value(this._settings.get_int('dot-size'));\n\n                this._settings.set_value('focus-highlight', this._settings.get_default_value('focus-highlight'));\n                this._settings.set_value('focus-highlight-dominant', this._settings.get_default_value('focus-highlight-dominant'));\n            });\n\n            this._settings.bind('dot-color-dominant',\n                            this._builder.get_object('dot_color_dominant_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('dot-color-override',\n                            this._builder.get_object('dot_color_override_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n            // when either becomes active, turn the other off\n            this._builder.get_object('dot_color_dominant_switch').connect('state-set', (widget) => {\n                if (widget.get_active()) this._settings.set_boolean('dot-color-override', false);\n            });\n            this._builder.get_object('dot_color_override_switch').connect('state-set', (widget) => {\n                if (widget.get_active()) this._settings.set_boolean('dot-color-dominant', false);\n                else this._settings.set_boolean('dot-color-unfocused-different', false);\n            });\n\n            this._settings.bind('dot-color-unfocused-different',\n                            this._builder.get_object('dot_color_unfocused_different_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('dot-color-override',\n                                this._builder.get_object('grid_dot_color'),\n                                'sensitive',\n                                Gio.SettingsBindFlags.DEFAULT);\n            \n            this._settings.bind('dot-color-override',\n                                this._builder.get_object('dot_color_unfocused_box'),\n                                'sensitive',\n                                Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('dot-color-unfocused-different',\n                                this._builder.get_object('grid_dot_color_unfocused'),\n                                'sensitive',\n                                Gio.SettingsBindFlags.DEFAULT);\n            \n            for (let i = 1; i <= MAX_WINDOW_INDICATOR; i++) {\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('dot-color-' + i));\n                this._builder.get_object('dot_color_' + i + '_colorbutton').set_rgba(rgba);\n\n                rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('dot-color-unfocused-' + i));\n                this._builder.get_object('dot_color_unfocused_' + i + '_colorbutton').set_rgba(rgba);\n            }\n\n            this._settings.bind('focus-highlight',\n                    this._builder.get_object('focus_highlight_switch'),\n                    'active',\n                    Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('focus-highlight',\n                    this._builder.get_object('grid_focus_highlight_options'),\n                    'sensitive',\n                    Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('focus-highlight-dominant',\n                    this._builder.get_object('focus_highlight_dominant_switch'),\n                    'active',\n                    Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('focus-highlight-dominant',\n                    this._builder.get_object('focus_highlight_color_label'),\n                    'sensitive',\n                    Gio.SettingsBindFlags.INVERT_BOOLEAN);\n\n            this._settings.bind('focus-highlight-dominant',\n                    this._builder.get_object('focus_highlight_color_colorbutton'),\n                    'sensitive',\n                    Gio.SettingsBindFlags.INVERT_BOOLEAN);\n\n\n            (function() {\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('focus-highlight-color'));\n                this._builder.get_object('focus_highlight_color_colorbutton').set_rgba(rgba);\n            }).apply(this);\n\n            this._builder.get_object('focus_highlight_opacity_spinbutton').set_value(this._settings.get_int('focus-highlight-opacity'));\n            this._builder.get_object('focus_highlight_opacity_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('focus-highlight-opacity', widget.get_value());\n            });\n\n            this._builder.get_object('dot_size_spinbutton').set_value(this._settings.get_int('dot-size'));\n            this._builder.get_object('dot_size_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('dot-size', widget.get_value());\n            });\n\n            dialog.show();\n            dialog.set_default_size(1, 1);\n\n        });\n\n        //multi-monitor\n        this.monitors = this._settings.get_value('available-monitors').deep_unpack();\n\n        let dtpPrimaryMonitorIndex = this.monitors.indexOf(this._settings.get_int('primary-monitor'));\n\n        if (dtpPrimaryMonitorIndex < 0) {\n            dtpPrimaryMonitorIndex = 0;\n        }\n\n        this._currentMonitorIndex = this.monitors[dtpPrimaryMonitorIndex];\n\n        this._settings.connect('changed::panel-positions', () => this._updateVerticalRelatedOptions());\n        this._updateVerticalRelatedOptions();\n        \n        for (let i = 0; i < this.monitors.length; ++i) {\n            //the gnome-shell primary index is the first one in the \"available-monitors\" setting\n            let label = !i ? _('Primary monitor') : _('Monitor ') + (i + 1);\n\n            this._builder.get_object('multimon_primary_combo').append_text(label);\n            this._builder.get_object('taskbar_position_monitor_combo').append_text(label);\n        }\n        \n        this._builder.get_object('multimon_primary_combo').set_active(dtpPrimaryMonitorIndex);\n        this._builder.get_object('taskbar_position_monitor_combo').set_active(dtpPrimaryMonitorIndex);\n\n        this._settings.bind('panel-element-positions-monitors-sync',\n                            this._builder.get_object('taskbar_position_sync_button'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('panel-element-positions-monitors-sync',\n                            this._builder.get_object('taskbar_position_monitor_combo'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.INVERT_BOOLEAN);\n\n        this._settings.connect('changed::panel-element-positions-monitors-sync', () => {\n            this._maybeDisableTopPosition();\n            // The anchor combo box may has different labels for single- or all-monitor configuration.\n            this._setAnchorLabels(this._currentMonitorIndex);\n        });\n\n        this._builder.get_object('multimon_primary_combo').connect('changed', (widget) => {\n            this._settings.set_int('primary-monitor', this.monitors[widget.get_active()]);\n        });\n\n        this._builder.get_object('taskbar_position_monitor_combo').connect('changed', (widget) => {\n            this._currentMonitorIndex = this.monitors[widget.get_active()];\n            this._updateWidgetSettingsForMonitor(this._currentMonitorIndex);\n        });\n\n        this._settings.bind('multi-monitors',\n                            this._builder.get_object('multimon_multi_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        if (this.monitors.length === 1) {\n            this._builder.get_object('multimon_multi_switch').set_sensitive(false);\n        }\n\n        const panel_length_scale = this._builder.get_object('panel_length_scale');\n        panel_length_scale.connect('value-changed', (widget) => {\n            const value = widget.get_value();\n            const monitorSync = this._settings.get_boolean('panel-element-positions-monitors-sync');\n            const monitorsToSetFor = monitorSync ? this.monitors : [this._currentMonitorIndex];\n            monitorsToSetFor.forEach(monitorIndex => {\n                PanelSettings.setPanelLength(this._settings, monitorIndex, value);\n            });\n\n            this._setAnchorWidgetSensitivity(value);\n        });\n\n        this._builder.get_object('panel_anchor_combo').connect('changed', (widget) => {\n            const value = widget.get_active_id();\n            // Value can be null while anchor labels are being swapped out\n            if (value !== null) {\n                const monitorSync = this._settings.get_boolean('panel-element-positions-monitors-sync');\n                const monitorsToSetFor = monitorSync ? this.monitors : [this._currentMonitorIndex];\n                monitorsToSetFor.forEach(monitorIndex => {\n                    PanelSettings.setPanelAnchor(this._settings, monitorIndex, value);\n                });\n            }\n        });\n\n        this._updateWidgetSettingsForMonitor(this._currentMonitorIndex);\n\n        //dynamic opacity\n        this._settings.bind('trans-use-custom-bg',\n                            this._builder.get_object('trans_bg_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('trans-use-custom-bg',\n                            this._builder.get_object('trans_bg_color_colorbutton'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        let rgba = new Gdk.RGBA();\n        rgba.parse(this._settings.get_string('trans-bg-color'));\n        this._builder.get_object('trans_bg_color_colorbutton').set_rgba(rgba);\n\n        this._builder.get_object('trans_bg_color_colorbutton').connect('color-set',  (button) => {\n            let rgba = button.get_rgba();\n            let css = rgba.to_string();\n            let hexString = cssHexString(css);\n            this._settings.set_string('trans-bg-color', hexString);\n        });\n\n        this._settings.bind('trans-use-custom-opacity',\n                            this._builder.get_object('trans_opacity_override_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('trans-use-custom-opacity',\n                            this._builder.get_object('trans_opacity_box'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('trans-use-custom-opacity',\n                        this._builder.get_object('trans_opacity_box2'),\n                        'sensitive',\n                        Gio.SettingsBindFlags.DEFAULT);\n\n        this._builder.get_object('trans_opacity_override_switch').connect('notify::active', (widget) => {\n            if (!widget.get_active())\n                this._builder.get_object('trans_dyn_switch').set_active(false);\n        });\n\n        this._builder.get_object('trans_opacity_spinbutton').set_value(this._settings.get_double('trans-panel-opacity') * 100);\n        this._builder.get_object('trans_opacity_spinbutton').connect('value-changed',  (widget) => {\n            this._settings.set_double('trans-panel-opacity', widget.get_value() * 0.01);\n        });\n\n        this._settings.bind('trans-use-dynamic-opacity',\n                            this._builder.get_object('trans_dyn_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('trans-use-dynamic-opacity',\n                            this._builder.get_object('trans_dyn_options_button'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('trans-dynamic-behavior',\n                            this._builder.get_object('trans_options_window_type_combo'),\n                            'active-id',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('trans-use-custom-gradient',\n                            this._builder.get_object('trans_gradient_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('trans-use-custom-gradient',\n                            this._builder.get_object('trans_gradient_box'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('trans-use-custom-gradient',\n                        this._builder.get_object('trans_gradient_box2'),\n                        'sensitive',\n                        Gio.SettingsBindFlags.DEFAULT);\n\n        rgba.parse(this._settings.get_string('trans-gradient-top-color'));\n        this._builder.get_object('trans_gradient_color1_colorbutton').set_rgba(rgba);\n\n        this._builder.get_object('trans_gradient_color1_colorbutton').connect('color-set',  (button) => {\n            let rgba = button.get_rgba();\n            let css = rgba.to_string();\n            let hexString = cssHexString(css);\n            this._settings.set_string('trans-gradient-top-color', hexString);\n        });\n\n        this._builder.get_object('trans_gradient_color1_spinbutton').set_value(this._settings.get_double('trans-gradient-top-opacity') * 100);\n        this._builder.get_object('trans_gradient_color1_spinbutton').connect('value-changed',  (widget) => {\n            this._settings.set_double('trans-gradient-top-opacity', widget.get_value() * 0.01);\n        });\n\n        rgba.parse(this._settings.get_string('trans-gradient-bottom-color'));\n        this._builder.get_object('trans_gradient_color2_colorbutton').set_rgba(rgba);\n\n        this._builder.get_object('trans_gradient_color2_colorbutton').connect('color-set',  (button) => {\n            let rgba = button.get_rgba();\n            let css = rgba.to_string();\n            let hexString = cssHexString(css);\n            this._settings.set_string('trans-gradient-bottom-color', hexString);\n        });\n\n        this._builder.get_object('trans_gradient_color2_spinbutton').set_value(this._settings.get_double('trans-gradient-bottom-opacity') * 100);\n        this._builder.get_object('trans_gradient_color2_spinbutton').connect('value-changed',  (widget) => {\n            this._settings.set_double('trans-gradient-bottom-opacity', widget.get_value() * 0.01);\n        });\n\n        this._builder.get_object('trans_options_distance_spinbutton').set_value(this._settings.get_int('trans-dynamic-distance'));\n        this._builder.get_object('trans_options_distance_spinbutton').connect('value-changed',  (widget) => {\n            this._settings.set_int('trans-dynamic-distance', widget.get_value());\n        });\n        \n        this._builder.get_object('trans_options_min_opacity_spinbutton').set_value(this._settings.get_double('trans-dynamic-anim-target') * 100);\n        this._builder.get_object('trans_options_min_opacity_spinbutton').connect('value-changed',  (widget) => {\n            this._settings.set_double('trans-dynamic-anim-target', widget.get_value() * 0.01);\n        });\n\n        this._builder.get_object('trans_options_anim_time_spinbutton').set_value(this._settings.get_int('trans-dynamic-anim-time'));\n        this._builder.get_object('trans_options_anim_time_spinbutton').connect('value-changed',  (widget) => {\n            this._settings.set_int('trans-dynamic-anim-time', widget.get_value());\n        });\n\n        this._builder.get_object('trans_dyn_options_button').connect('clicked', () => {\n            let box = this._builder.get_object('box_dynamic_opacity_options');\n\n            let dialog = this._createPreferencesDialog(_('Dynamic opacity options'), box, () =>\n            {\n                    // restore default settings\n                    this._settings.set_value('trans-dynamic-behavior', this._settings.get_default_value('trans-dynamic-behavior'));\n\n                    this._settings.set_value('trans-dynamic-distance', this._settings.get_default_value('trans-dynamic-distance'));\n                    this._builder.get_object('trans_options_distance_spinbutton').set_value(this._settings.get_int('trans-dynamic-distance'));\n\n                    this._settings.set_value('trans-dynamic-anim-target', this._settings.get_default_value('trans-dynamic-anim-target'));\n                    this._builder.get_object('trans_options_min_opacity_spinbutton').set_value(this._settings.get_double('trans-dynamic-anim-target') * 100);\n\n                    this._settings.set_value('trans-dynamic-anim-time', this._settings.get_default_value('trans-dynamic-anim-time'));\n                    this._builder.get_object('trans_options_anim_time_spinbutton').set_value(this._settings.get_int('trans-dynamic-anim-time'));\n            });\n\n            dialog.show();\n            dialog.set_default_size(1, 1);\n\n        });\n        \n        this._settings.bind('desktop-line-use-custom-color',\n                            this._builder.get_object('override_show_desktop_line_color_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('desktop-line-use-custom-color',\n                            this._builder.get_object('override_show_desktop_line_color_colorbutton'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n        \n        rgba.parse(this._settings.get_string('desktop-line-custom-color'));\n        this._builder.get_object('override_show_desktop_line_color_colorbutton').set_rgba(rgba);\n        this._builder.get_object('override_show_desktop_line_color_colorbutton').connect('color-set',  (button) => {\n            let rgba = button.get_rgba();\n            let css = rgba.to_string();\n            this._settings.set_string('desktop-line-custom-color', css);\n        });\n\n\n        this._settings.bind('intellihide',\n                            this._builder.get_object('intellihide_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('intellihide',\n                            this._builder.get_object('intellihide_options_button'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('intellihide-hide-from-windows',\n                            this._builder.get_object('intellihide_window_hide_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('intellihide-hide-from-windows',\n                            this._builder.get_object('intellihide_behaviour_options'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('intellihide-behaviour',\n                            this._builder.get_object('intellihide_behaviour_combo'),\n                            'active-id',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('intellihide-use-pressure',\n                            this._builder.get_object('intellihide_use_pressure_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT); \n\n        this._settings.bind('intellihide-use-pressure',\n                            this._builder.get_object('intellihide_use_pressure_options'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('intellihide-use-pressure',\n                        this._builder.get_object('intellihide_use_pressure_options2'),\n                        'sensitive',\n                        Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('intellihide-show-in-fullscreen',\n                            this._builder.get_object('intellihide_show_in_fullscreen_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('intellihide-only-secondary',\n                            this._builder.get_object('intellihide_only_secondary_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('multi-monitors',\n                            this._builder.get_object('grid_intellihide_only_secondary'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._builder.get_object('multimon_multi_switch').connect('notify::active', (widget) => {\n            if (!widget.get_active())\n                this._builder.get_object('intellihide_only_secondary_switch').set_active(false);\n        });\n\n        this._builder.get_object('intellihide_pressure_threshold_spinbutton').set_value(this._settings.get_int('intellihide-pressure-threshold'));\n        this._builder.get_object('intellihide_pressure_threshold_spinbutton').connect('value-changed',  (widget) => {\n            this._settings.set_int('intellihide-pressure-threshold', widget.get_value());\n        });\n\n        this._builder.get_object('intellihide_pressure_time_spinbutton').set_value(this._settings.get_int('intellihide-pressure-time'));\n        this._builder.get_object('intellihide_pressure_time_spinbutton').connect('value-changed',  (widget) => {\n            this._settings.set_int('intellihide-pressure-time', widget.get_value());\n        });\n\n        this._settings.bind('intellihide-key-toggle-text',\n                             this._builder.get_object('intellihide_toggle_entry'),\n                             'text',\n                             Gio.SettingsBindFlags.DEFAULT);\n        this._settings.connect('changed::intellihide-key-toggle-text', () => setShortcut(this._settings, 'intellihide-key-toggle'));\n\n        this._builder.get_object('intellihide_animation_time_spinbutton').set_value(this._settings.get_int('intellihide-animation-time'));\n        this._builder.get_object('intellihide_animation_time_spinbutton').connect('value-changed', (widget) => {\n            this._settings.set_int('intellihide-animation-time', widget.get_value());\n        });\n\n        this._builder.get_object('intellihide_close_delay_spinbutton').set_value(this._settings.get_int('intellihide-close-delay'));\n        this._builder.get_object('intellihide_close_delay_spinbutton').connect('value-changed', (widget) => {\n            this._settings.set_int('intellihide-close-delay', widget.get_value());\n        });\n\n        this._builder.get_object('intellihide_enable_start_delay_spinbutton').set_value(this._settings.get_int('intellihide-enable-start-delay'));\n        this._builder.get_object('intellihide_enable_start_delay_spinbutton').connect('value-changed', (widget) => {\n            this._settings.set_int('intellihide-enable-start-delay', widget.get_value());\n        });\n\n        this._builder.get_object('intellihide_options_button').connect('clicked', () => {\n            let box = this._builder.get_object('box_intellihide_options');\n\n            let dialog = this._createPreferencesDialog(_('Intellihide options'), box, () =>\n            {\n                // restore default settings\n                this._settings.set_value('intellihide-hide-from-windows', this._settings.get_default_value('intellihide-hide-from-windows'));\n                this._settings.set_value('intellihide-behaviour', this._settings.get_default_value('intellihide-behaviour'));\n                this._settings.set_value('intellihide-use-pressure', this._settings.get_default_value('intellihide-use-pressure'));\n                this._settings.set_value('intellihide-show-in-fullscreen', this._settings.get_default_value('intellihide-show-in-fullscreen'));\n                this._settings.set_value('intellihide-only-secondary', this._settings.get_default_value('intellihide-only-secondary'));\n\n                this._settings.set_value('intellihide-pressure-threshold', this._settings.get_default_value('intellihide-pressure-threshold'));\n                this._builder.get_object('intellihide_pressure_threshold_spinbutton').set_value(this._settings.get_int('intellihide-pressure-threshold'));\n                \n                this._settings.set_value('intellihide-pressure-time', this._settings.get_default_value('intellihide-pressure-time'));\n                this._builder.get_object('intellihide_pressure_time_spinbutton').set_value(this._settings.get_int('intellihide-pressure-time'));\n\n                this._settings.set_value('intellihide-key-toggle-text', this._settings.get_default_value('intellihide-key-toggle-text'));\n\n                this._settings.set_value('intellihide-animation-time', this._settings.get_default_value('intellihide-animation-time'));\n                this._builder.get_object('intellihide_animation_time_spinbutton').set_value(this._settings.get_int('intellihide-animation-time'));\n\n                this._settings.set_value('intellihide-close-delay', this._settings.get_default_value('intellihide-close-delay'));\n                this._builder.get_object('intellihide_close_delay_spinbutton').set_value(this._settings.get_int('intellihide-close-delay'));\n\n                this._settings.set_value('intellihide-enable-start-delay', this._settings.get_default_value('intellihide-enable-start-delay'));\n                this._builder.get_object('intellihide_enable_start_delay_spinbutton').set_value(this._settings.get_int('intellihide-enable-start-delay'));\n            });\n\n            dialog.show();\n            dialog.set_default_size(1, 1);\n\n        });\n\n        // Behavior panel\n\n        this._builder.get_object('show_applications_side_padding_spinbutton').set_value(this._settings.get_int('show-apps-icon-side-padding'));\n        this._builder.get_object('show_applications_side_padding_spinbutton').connect('value-changed', (widget) => {\n            this._settings.set_int('show-apps-icon-side-padding', widget.get_value());\n        });\n\n        this._settings.bind('show-apps-override-escape',\n                            this._builder.get_object('show_applications_esc_key_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('show-showdesktop-hover',\n                            this._builder.get_object('show_showdesktop_hide_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('show-showdesktop-hover',\n                            this._builder.get_object('grid_show_showdesktop_hide_options'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('show-showdesktop-hover',\n                        this._builder.get_object('grid_show_showdesktop_hide_options2'),\n                        'sensitive',\n                        Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('show-window-previews',\n                            this._builder.get_object('show_window_previews_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('show-window-previews',\n                            this._builder.get_object('show_window_previews_button'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('show-tooltip',\n                            this._builder.get_object('show_tooltip_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('show-favorites',\n                            this._builder.get_object('show_favorite_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('show-favorites-all-monitors',\n                            this._builder.get_object('multimon_multi_show_favorites_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n                            \n        this._settings.bind('show-favorites',\n                            this._builder.get_object('multimon_multi_show_favorites_switch'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('show-running-apps',\n                            this._builder.get_object('show_runnning_apps_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT); \n\n        this._setPreviewTitlePosition();\n\n        this._builder.get_object('grid_preview_title_font_color_colorbutton').connect('color-set',  (button) => {\n            let rgba = button.get_rgba();\n            let css = rgba.to_string();\n            let hexString = cssHexString(css);\n            this._settings.set_string('window-preview-title-font-color', hexString);\n        });\n\n        this._builder.get_object('show_window_previews_button').connect('clicked', () => {\n            let scrolledWindow = this._builder.get_object('box_window_preview_options');\n\n            let dialog = this._createPreferencesDialog(_('Window preview options'), scrolledWindow, () =>\n            {\n                // restore default settings\n                this._settings.set_value('show-window-previews-timeout', this._settings.get_default_value('show-window-previews-timeout'));\n                this._builder.get_object('preview_timeout_spinbutton').set_value(this._settings.get_int('show-window-previews-timeout'));\n\n                this._settings.set_value('leave-timeout', this._settings.get_default_value('leave-timeout'));\n                this._builder.get_object('leave_timeout_spinbutton').set_value(this._settings.get_int('leave-timeout'));\n\n                this._settings.set_value('window-preview-hide-immediate-click', this._settings.get_default_value('window-preview-hide-immediate-click'));\n\n                this._settings.set_value('window-preview-animation-time', this._settings.get_default_value('window-preview-animation-time'));\n                this._builder.get_object('animation_time_spinbutton').set_value(this._settings.get_int('window-preview-animation-time'));\n\n                this._settings.set_value('preview-use-custom-opacity', this._settings.get_default_value('preview-use-custom-opacity'));\n                \n                this._settings.set_value('window-preview-use-custom-icon-size', this._settings.get_default_value('window-preview-use-custom-icon-size'));\n\n                this._settings.set_value('preview-custom-opacity', this._settings.get_default_value('preview-custom-opacity'));\n                this._builder.get_object('preview_custom_opacity_spinbutton').set_value(this._settings.get_int('preview-custom-opacity'));\n\n                this._settings.set_value('window-preview-title-position', this._settings.get_default_value('window-preview-title-position'));\n                this._setPreviewTitlePosition();\n\n                this._settings.set_value('peek-mode', this._settings.get_default_value('peek-mode'));\n                this._settings.set_value('window-preview-show-title', this._settings.get_default_value('window-preview-show-title'));\n                this._settings.set_value('enter-peek-mode-timeout', this._settings.get_default_value('enter-peek-mode-timeout'));\n                this._builder.get_object('enter_peek_mode_timeout_spinbutton').set_value(this._settings.get_int('enter-peek-mode-timeout'));\n                this._settings.set_value('peek-mode-opacity', this._settings.get_default_value('peek-mode-opacity'));\n                this._builder.get_object('peek_mode_opacity_spinbutton').set_value(this._settings.get_int('peek-mode-opacity'));\n\n                this._settings.set_value('window-preview-size', this._settings.get_default_value('window-preview-size'));\n                this._builder.get_object('preview_size_spinbutton').set_value(this._settings.get_int('window-preview-size'));\n\n                this._settings.set_value('window-preview-fixed-x', this._settings.get_default_value('window-preview-fixed-x'));\n                this._settings.set_value('window-preview-fixed-y', this._settings.get_default_value('window-preview-fixed-y'));\n\n                this._settings.set_value('window-preview-aspect-ratio-x', this._settings.get_default_value('window-preview-aspect-ratio-x'));\n                this._builder.get_object('preview_aspect_ratio_x_combo').set_active_id(this._settings.get_int('window-preview-aspect-ratio-x').toString());\n\n                this._settings.set_value('window-preview-aspect-ratio-y', this._settings.get_default_value('window-preview-aspect-ratio-y'));\n                this._builder.get_object('preview_aspect_ratio_y_combo').set_active_id(this._settings.get_int('window-preview-aspect-ratio-y').toString());\n                \n                this._settings.set_value('window-preview-padding', this._settings.get_default_value('window-preview-padding'));\n                this._builder.get_object('preview_padding_spinbutton').set_value(this._settings.get_int('window-preview-padding'));\n\n                this._settings.set_value('preview-middle-click-close', this._settings.get_default_value('preview-middle-click-close'));\n\n                this._settings.set_value('window-preview-title-font-size', this._settings.get_default_value('window-preview-title-font-size'));\n                this._builder.get_object('preview_title_size_spinbutton').set_value(this._settings.get_int('window-preview-title-font-size'));\n                \n                this._settings.set_value('window-preview-custom-icon-size', this._settings.get_default_value('window-preview-custom-icon-size'));\n                this._builder.get_object('preview_custom_icon_size_spinbutton').set_value(this._settings.get_int('window-preview-custom-icon-size'));\n\n                this._settings.set_value('window-preview-title-font-weight', this._settings.get_default_value('window-preview-title-font-weight'));\n                this._builder.get_object('grid_preview_title_weight_combo').set_active_id(this._settings.get_string('window-preview-title-font-weight'));\n\n                this._settings.set_value('window-preview-title-font-color', this._settings.get_default_value('window-preview-title-font-color'));\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('window-preview-title-font-color'));\n                this._builder.get_object('grid_preview_title_font_color_colorbutton').set_rgba(rgba);\n            });\n\n            this._builder.get_object('preview_timeout_spinbutton').set_value(this._settings.get_int('show-window-previews-timeout'));\n            this._builder.get_object('preview_timeout_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('show-window-previews-timeout', widget.get_value());\n            });\n\n            this._settings.bind('preview-middle-click-close',\n                            this._builder.get_object('preview_middle_click_close_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('window-preview-fixed-x',\n                            this._builder.get_object('preview_aspect_ratio_x_fixed_togglebutton'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('window-preview-fixed-y',\n                            this._builder.get_object('preview_aspect_ratio_y_fixed_togglebutton'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('preview-use-custom-opacity',\n                            this._builder.get_object('preview_custom_opacity_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('preview-use-custom-opacity',\n                            this._builder.get_object('preview_custom_opacity_spinbutton'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('window-preview-use-custom-icon-size',\n                            this._builder.get_object('preview_custom_icon_size_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('window-preview-use-custom-icon-size',\n                            this._builder.get_object('preview_custom_icon_size_spinbutton'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n            this._builder.get_object('preview_custom_opacity_spinbutton').set_value(this._settings.get_int('preview-custom-opacity'));\n            this._builder.get_object('preview_custom_opacity_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('preview-custom-opacity', widget.get_value());\n            });\n                            \n            this._settings.bind('peek-mode',\n                            this._builder.get_object('peek_mode_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('peek-mode',\n                            this._builder.get_object('grid_enter_peek_mode_timeout'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('peek-mode',\n                            this._builder.get_object('grid_peek_mode_opacity'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n            \n            this._settings.bind('window-preview-show-title',\n                            this._builder.get_object('preview_show_title_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('window-preview-show-title',\n                            this._builder.get_object('grid_preview_custom_icon_size'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('window-preview-show-title',\n                            this._builder.get_object('grid_preview_title_size'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('window-preview-show-title',\n                            this._builder.get_object('grid_preview_title_weight'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('window-preview-show-title',\n                            this._builder.get_object('grid_preview_title_font_color'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n            this._builder.get_object('enter_peek_mode_timeout_spinbutton').set_value(this._settings.get_int('enter-peek-mode-timeout'));\n            this._builder.get_object('enter_peek_mode_timeout_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('enter-peek-mode-timeout', widget.get_value());\n            });\n\n            this._builder.get_object('leave_timeout_spinbutton').set_value(this._settings.get_int('leave-timeout'));\n            this._builder.get_object('leave_timeout_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('leave-timeout', widget.get_value());\n            });\n\n            this._settings.bind('window-preview-hide-immediate-click',\n                                this._builder.get_object('preview_immediate_click_button'),\n                                'active',\n                                Gio.SettingsBindFlags.DEFAULT);\n\n            this._builder.get_object('animation_time_spinbutton').set_value(this._settings.get_int('window-preview-animation-time'));\n            this._builder.get_object('animation_time_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('window-preview-animation-time', widget.get_value());\n            });\n\n            this._builder.get_object('peek_mode_opacity_spinbutton').set_value(this._settings.get_int('peek-mode-opacity'));\n            this._builder.get_object('peek_mode_opacity_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('peek-mode-opacity', widget.get_value());\n            });\n\n            this._builder.get_object('preview_size_spinbutton').set_value(this._settings.get_int('window-preview-size'));\n            this._builder.get_object('preview_size_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('window-preview-size', widget.get_value());\n            });\n\n            this._builder.get_object('preview_aspect_ratio_x_combo').set_active_id(this._settings.get_int('window-preview-aspect-ratio-x').toString());\n            this._builder.get_object('preview_aspect_ratio_x_combo').connect('changed', (widget) => {\n                this._settings.set_int('window-preview-aspect-ratio-x', parseInt(widget.get_active_id(), 10));\n            });\n\n            this._builder.get_object('preview_aspect_ratio_y_combo').set_active_id(this._settings.get_int('window-preview-aspect-ratio-y').toString());\n            this._builder.get_object('preview_aspect_ratio_y_combo').connect('changed', (widget) => {\n                this._settings.set_int('window-preview-aspect-ratio-y', parseInt(widget.get_active_id(), 10));\n            });\n\n            this._builder.get_object('preview_padding_spinbutton').set_value(this._settings.get_int('window-preview-padding'));\n            this._builder.get_object('preview_padding_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('window-preview-padding', widget.get_value());\n            });\n\n            this._builder.get_object('preview_title_size_spinbutton').set_value(this._settings.get_int('window-preview-title-font-size'));\n            this._builder.get_object('preview_title_size_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('window-preview-title-font-size', widget.get_value());\n            });\n            \n            this._builder.get_object('preview_custom_icon_size_spinbutton').set_value(this._settings.get_int('window-preview-custom-icon-size'));\n            this._builder.get_object('preview_custom_icon_size_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('window-preview-custom-icon-size', widget.get_value());\n            });\n\n            this._builder.get_object('grid_preview_title_weight_combo').set_active_id(this._settings.get_string('window-preview-title-font-weight'));\n            this._builder.get_object('grid_preview_title_weight_combo').connect('changed', (widget) => {\n                this._settings.set_string('window-preview-title-font-weight', widget.get_active_id());\n            });\n\n            (function() {\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('window-preview-title-font-color'));\n                this._builder.get_object('grid_preview_title_font_color_colorbutton').set_rgba(rgba);\n            }).apply(this);\n\n            dialog.show();\n\n        });\n       \n        this._settings.bind('isolate-workspaces',\n                            this._builder.get_object('isolate_workspaces_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('isolate-monitors',\n                            this._builder.get_object('multimon_multi_isolate_monitor_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('overview-click-to-exit',\n                            this._builder.get_object('clicktoexit_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('hide-overview-on-startup',\n                            this._builder.get_object('hide_overview_on_startup_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('group-apps',\n                            this._builder.get_object('group_apps_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT | Gio.SettingsBindFlags.INVERT_BOOLEAN);\n\n        this._settings.bind('group-apps',\n                            this._builder.get_object('show_group_apps_options_button'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT | Gio.SettingsBindFlags.INVERT_BOOLEAN);\n\n        this._settings.bind('progress-show-count',\n                            this._builder.get_object('show_notification_badge_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._builder.get_object('group_apps_label_font_color_colorbutton').connect('color-set',  (button) => {\n            let rgba = button.get_rgba();\n            let css = rgba.to_string();\n            let hexString = cssHexString(css);\n            this._settings.set_string('group-apps-label-font-color', hexString);\n        });\n\n        this._builder.get_object('group_apps_label_font_color_minimized_colorbutton').connect('color-set',  (button) => {\n            let rgba = button.get_rgba();\n            let css = rgba.to_string();\n            let hexString = cssHexString(css);\n            this._settings.set_string('group-apps-label-font-color-minimized', hexString);\n        });\n\n        this._settings.bind('group-apps-use-fixed-width',\n                            this._builder.get_object('group_apps_use_fixed_width_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('group-apps-underline-unfocused',\n                            this._builder.get_object('group_apps_underline_unfocused_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('group-apps-use-launchers',\n                            this._builder.get_object('group_apps_use_launchers_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);    \n\n        this._builder.get_object('show_group_apps_options_button').connect('clicked', () => {\n            let box = this._builder.get_object('box_group_apps_options');\n\n            let dialog = this._createPreferencesDialog(_('Ungrouped application options'), box, () =>\n            {\n                // restore default settings\n                this._settings.set_value('group-apps-label-font-size', this._settings.get_default_value('group-apps-label-font-size'));\n                this._builder.get_object('group_apps_label_font_size_spinbutton').set_value(this._settings.get_int('group-apps-label-font-size'));\n\n                this._settings.set_value('group-apps-label-font-weight', this._settings.get_default_value('group-apps-label-font-weight'));\n                this._builder.get_object('group_apps_label_font_weight_combo').set_active_id(this._settings.get_string('group-apps-label-font-weight'));\n\n                this._settings.set_value('group-apps-label-font-color', this._settings.get_default_value('group-apps-label-font-color'));\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('group-apps-label-font-color'));\n                this._builder.get_object('group_apps_label_font_color_colorbutton').set_rgba(rgba);\n\n                this._settings.set_value('group-apps-label-font-color-minimized', this._settings.get_default_value('group-apps-label-font-color-minimized'));\n                let minimizedFontColor = new Gdk.RGBA();\n                minimizedFontColor.parse(this._settings.get_string('group-apps-label-font-color-minimized'));\n                this._builder.get_object('group_apps_label_font_color_minimized_colorbutton').set_rgba(minimizedFontColor);\n\n                this._settings.set_value('group-apps-label-max-width', this._settings.get_default_value('group-apps-label-max-width'));\n                this._builder.get_object('group_apps_label_max_width_spinbutton').set_value(this._settings.get_int('group-apps-label-max-width'));\n\n                this._settings.set_value('group-apps-use-fixed-width', this._settings.get_default_value('group-apps-use-fixed-width'));\n                this._settings.set_value('group-apps-underline-unfocused', this._settings.get_default_value('group-apps-underline-unfocused'));\n                this._settings.set_value('group-apps-use-launchers', this._settings.get_default_value('group-apps-use-launchers'));\n            });\n\n            this._builder.get_object('group_apps_label_font_size_spinbutton').set_value(this._settings.get_int('group-apps-label-font-size'));\n            this._builder.get_object('group_apps_label_font_size_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('group-apps-label-font-size', widget.get_value());\n            });\n\n            this._builder.get_object('group_apps_label_font_weight_combo').set_active_id(this._settings.get_string('group-apps-label-font-weight'));\n            this._builder.get_object('group_apps_label_font_weight_combo').connect('changed', (widget) => {\n                this._settings.set_string('group-apps-label-font-weight', widget.get_active_id());\n            });\n\n            (function() {\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('group-apps-label-font-color'));\n                this._builder.get_object('group_apps_label_font_color_colorbutton').set_rgba(rgba);\n            }).apply(this);\n\n            (function() {\n                let rgba = new Gdk.RGBA();\n                rgba.parse(this._settings.get_string('group-apps-label-font-color-minimized'));\n                this._builder.get_object('group_apps_label_font_color_minimized_colorbutton').set_rgba(rgba);\n            }).apply(this);\n\n            this._builder.get_object('group_apps_label_max_width_spinbutton').set_value(this._settings.get_int('group-apps-label-max-width'));\n            this._builder.get_object('group_apps_label_max_width_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('group-apps-label-max-width', widget.get_value());\n            });\n\n            dialog.show();\n            dialog.set_default_size(600, 1);\n\n        });    \n\n        this._builder.get_object('click_action_combo').set_active_id(this._settings.get_string('click-action'));\n        this._builder.get_object('click_action_combo').connect('changed', (widget) => {\n            this._settings.set_string('click-action', widget.get_active_id());\n        });\n\n        this._builder.get_object('shift_click_action_combo').connect('changed', (widget) => {\n            this._settings.set_string('shift-click-action', widget.get_active_id());\n        });\n\n        this._builder.get_object('middle_click_action_combo').connect('changed', (widget) => {\n            this._settings.set_string('middle-click-action', widget.get_active_id());\n        });\n        this._builder.get_object('shift_middle_click_action_combo').connect('changed', (widget) => {\n            this._settings.set_string('shift-middle-click-action', widget.get_active_id());\n        });\n\n        // Create dialog for middle-click options\n        this._builder.get_object('middle_click_options_button').connect('clicked', () => {\n            let box = this._builder.get_object('box_middle_click_options');\n\n            let dialog = this._createPreferencesDialog(_('Customize middle-click behavior'), box, () =>\n            {\n                // restore default settings for the relevant keys\n                let keys = ['shift-click-action', 'middle-click-action', 'shift-middle-click-action'];\n                keys.forEach(function(val) {\n                    this._settings.set_value(val, this._settings.get_default_value(val));\n                }, this);\n                this._builder.get_object('shift_click_action_combo').set_active_id(this._settings.get_string('shift-click-action'));\n                this._builder.get_object('middle_click_action_combo').set_active_id(this._settings.get_string('middle-click-action'));\n                this._builder.get_object('shift_middle_click_action_combo').set_active_id(this._settings.get_string('shift-middle-click-action'));\n            });\n\n            this._builder.get_object('shift_click_action_combo').set_active_id(this._settings.get_string('shift-click-action'));\n\n            this._builder.get_object('middle_click_action_combo').set_active_id(this._settings.get_string('middle-click-action'));\n\n            this._builder.get_object('shift_middle_click_action_combo').set_active_id(this._settings.get_string('shift-middle-click-action'));\n\n            this._settings.bind('shift-click-action',\n                                this._builder.get_object('shift_click_action_combo'),\n                                'active-id',\n                                Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('middle-click-action',\n                                this._builder.get_object('middle_click_action_combo'),\n                                'active-id',\n                                Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('shift-middle-click-action',\n                                this._builder.get_object('shift_middle_click_action_combo'),\n                                'active-id',\n                                Gio.SettingsBindFlags.DEFAULT);\n\n            dialog.show();\n            dialog.set_default_size(700, 1);\n\n        });\n\n        this._builder.get_object('scroll_panel_combo').set_active_id(this._settings.get_string('scroll-panel-action'));\n        this._builder.get_object('scroll_panel_combo').connect('changed', (widget) => {\n            this._settings.set_string('scroll-panel-action', widget.get_active_id());\n        });\n\n        this._builder.get_object('scroll_icon_combo').set_active_id(this._settings.get_string('scroll-icon-action'));\n        this._builder.get_object('scroll_icon_combo').connect('changed', (widget) => {\n            this._settings.set_string('scroll-icon-action', widget.get_active_id());\n        });\n\n        // Create dialog for panel scroll options\n        this._builder.get_object('scroll_panel_options_button').connect('clicked', () => {\n            let box = this._builder.get_object('scroll_panel_options_box');\n\n            let dialog = this._createPreferencesDialog(_('Customize panel scroll behavior'), box, () =>\n            {\n                // restore default settings\n                this._settings.set_value('scroll-panel-delay', this._settings.get_default_value('scroll-panel-delay'));\n                this._builder.get_object('scroll_panel_options_delay_spinbutton').set_value(this._settings.get_int('scroll-panel-delay'));\n\n                this._settings.set_value('scroll-panel-show-ws-popup', this._settings.get_default_value('scroll-panel-show-ws-popup'));\n            });\n\n            this._builder.get_object('scroll_panel_options_delay_spinbutton').set_value(this._settings.get_int('scroll-panel-delay'));\n            this._builder.get_object('scroll_panel_options_delay_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('scroll-panel-delay', widget.get_value());\n            });\n\n            this._settings.bind('scroll-panel-show-ws-popup',\n                            this._builder.get_object('scroll_panel_options_show_ws_popup_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n            dialog.show();\n            dialog.set_default_size(640, 1);\n\n        });\n\n        // Create dialog for icon scroll options\n        this._builder.get_object('scroll_icon_options_button').connect('clicked', () => {\n            let box = this._builder.get_object('scroll_icon_options_box');\n\n            let dialog = this._createPreferencesDialog(_('Customize icon scroll behavior'), box, () =>\n            {\n                // restore default settings\n                this._settings.set_value('scroll-icon-delay', this._settings.get_default_value('scroll-icon-delay'));\n                this._builder.get_object('scroll_icon_options_delay_spinbutton').set_value(this._settings.get_int('scroll-icon-delay'));\n            });\n\n            this._builder.get_object('scroll_icon_options_delay_spinbutton').set_value(this._settings.get_int('scroll-icon-delay'));\n            this._builder.get_object('scroll_icon_options_delay_spinbutton').connect('value-changed', (widget) => {\n                this._settings.set_int('scroll-icon-delay', widget.get_value());\n            });\n\n            dialog.show();\n            dialog.set_default_size(640, 1);\n\n        });\n\n        this._settings.bind('hot-keys',\n                            this._builder.get_object('hot_keys_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('hot-keys',\n                            this._builder.get_object('overlay_button'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._builder.get_object('overlay_combo').connect('changed', (widget) => {\n            this._settings.set_string('hotkeys-overlay-combo', widget.get_active_id());\n        });\n\n        this._settings.bind('shortcut-previews',\n                            this._builder.get_object('shortcut_preview_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._builder.get_object('shortcut_num_keys_combo').set_active_id(this._settings.get_string('shortcut-num-keys'));\n        this._builder.get_object('shortcut_num_keys_combo').connect('changed', (widget) => {\n            this._settings.set_string('shortcut-num-keys', widget.get_active_id());\n        });\n\n        this._settings.connect('changed::hotkey-prefix-text', () => {checkHotkeyPrefix(this._settings);});\n\n        this._builder.get_object('hotkey_prefix_combo').set_active_id(this._settings.get_string('hotkey-prefix-text'));\n\n        this._settings.bind('hotkey-prefix-text',\n                            this._builder.get_object('hotkey_prefix_combo'),\n                            'active-id',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._builder.get_object('overlay_combo').set_active_id(this._settings.get_string('hotkeys-overlay-combo'));\n\n        this._settings.bind('hotkeys-overlay-combo',\n                            this._builder.get_object('overlay_combo'),\n                            'active-id',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('overlay-timeout',\n                            this._builder.get_object('timeout_spinbutton'),\n                            'value',\n                            Gio.SettingsBindFlags.DEFAULT);\n        if (this._settings.get_string('hotkeys-overlay-combo') !== 'TEMPORARILY') {\n            this._builder.get_object('timeout_spinbutton').set_sensitive(false);\n        }\n\n        this._settings.connect('changed::hotkeys-overlay-combo', () => {\n            if (this._settings.get_string('hotkeys-overlay-combo') !== 'TEMPORARILY')\n                this._builder.get_object('timeout_spinbutton').set_sensitive(false);\n            else\n                this._builder.get_object('timeout_spinbutton').set_sensitive(true);\n        });\n\n        this._settings.bind('shortcut-text',\n                            this._builder.get_object('shortcut_entry'),\n                            'text',\n                            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.connect('changed::shortcut-text', () => {setShortcut(this._settings, 'shortcut');});\n\n        // Create dialog for number overlay options\n        this._builder.get_object('overlay_button').connect('clicked', () => {\n            let box = this._builder.get_object('box_overlay_shortcut');\n\n            let dialog = this._createPreferencesDialog(_('Advanced hotkeys options'), box, () =>\n            {\n                // restore default settings for the relevant keys\n                let keys = ['hotkey-prefix-text', 'shortcut-text', 'hotkeys-overlay-combo', 'overlay-timeout', 'shortcut-previews'];\n                keys.forEach(function(val) {\n                    this._settings.set_value(val, this._settings.get_default_value(val));\n                }, this);\n            });\n\n            dialog.show();\n            dialog.set_default_size(600, 1);\n\n        });\n        \n        // setup dialog for secondary menu options\n        this._builder.get_object('secondarymenu_options_button').connect('clicked', () => {\n            let box = this._builder.get_object('box_secondarymenu_options');\n\n            let dialog = this._createPreferencesDialog(_('Secondary Menu Options'), box, () =>\n            {\n                // restore default settings\n                this._settings.set_value('secondarymenu-contains-appmenu', this._settings.get_default_value('secondarymenu-contains-appmenu'));\n                this._settings.set_value('secondarymenu-contains-showdetails', this._settings.get_default_value('secondarymenu-contains-showdetails'));\n            });\n\n            // TODO setting secondarymenu-contains-appmenu is not being used anywhere\n            this._settings.bind('secondarymenu-contains-appmenu',\n                    this._builder.get_object('secondarymenu_appmenu_switch'),\n                    'active',\n                    Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('secondarymenu-contains-showdetails',\n                    this._builder.get_object('secondarymenu_showdetails_switch'),\n                    'active',\n                    Gio.SettingsBindFlags.DEFAULT);\n\n            dialog.show();\n            dialog.set_default_size(480, 1);\n\n        });\n\n        // setup dialog for advanced options\n        this._builder.get_object('button_advanced_options').connect('clicked', () => {\n            let box = this._builder.get_object('box_advanced_options');\n\n            let dialog = this._createPreferencesDialog(_('Advanced Options'), box);\n\n            dialog.show();\n            dialog.set_default_size(480, 1);\n\n        });\n\n        // Fine-tune panel\n\n        let sizeScales = [\n            {objectName: 'tray_size_scale', valueName: 'tray-size', range: DEFAULT_FONT_SIZES },\n            {objectName: 'leftbox_size_scale', valueName: 'leftbox-size', range: DEFAULT_FONT_SIZES },\n            {objectName: 'appicon_margin_scale', valueName: 'appicon-margin', range: DEFAULT_MARGIN_SIZES },\n            {objectName: 'appicon_padding_scale', valueName: 'appicon-padding', range: DEFAULT_MARGIN_SIZES },\n            {objectName: 'tray_padding_scale', valueName: 'tray-padding', range: DEFAULT_PADDING_SIZES },\n            {objectName: 'leftbox_padding_scale', valueName: 'leftbox-padding', range: DEFAULT_PADDING_SIZES },\n            {objectName: 'statusicon_padding_scale', valueName: 'status-icon-padding', range: DEFAULT_PADDING_SIZES },\n            {objectName: 'panel_length_scale', valueName: '', range: LENGTH_MARKS }\n        ];\n\n        for(const idx in sizeScales) {\n            let size_scale = this._builder.get_object(sizeScales[idx].objectName);\n            let range = sizeScales[idx].range;\n            size_scale.set_range(range[range.length - 1], range[0]);\n            let value;\n            if (sizeScales[idx].objectName === 'panel_length_scale') {\n                value = PanelSettings.getPanelLength(this._settings, this._currentMonitorIndex);\n            } else {\n                value = this._settings.get_int(sizeScales[idx].valueName);\n            }\n            size_scale.set_value(value);\n            // Add marks from range arrays, omitting the first and last values.\n            range.slice(1, -1).forEach(function(val) {\n                size_scale.add_mark(val, Gtk.PositionType.TOP, val.toString());\n            });\n\n            // Corrent for rtl languages\n            if (this._rtl) {\n                // Flip value position: this is not done automatically\n                size_scale.set_value_pos(Gtk.PositionType.LEFT);\n                // I suppose due to a bug, having a more than one mark and one above a value of 100\n                // makes the rendering of the marks wrong in rtl. This doesn't happen setting the scale as not flippable\n                // and then manually inverting it\n                size_scale.set_flippable(false);\n                size_scale.set_inverted(true);\n            }\n        }\n\n        this._settings.bind('animate-app-switch',\n                            this._builder.get_object('animate_app_switch_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('animate-window-launch',\n                            this._builder.get_object('animate_window_launch_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('animate-appicon-hover',\n                            this._builder.get_object('animate_appicon_hover_switch'),\n                            'active',\n                             Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('animate-appicon-hover',\n                            this._builder.get_object('animate_appicon_hover_button'),\n                            'sensitive',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        {\n            this._settings.bind('animate-appicon-hover-animation-type',\n                                this._builder.get_object('animate_appicon_hover_options_type_combo'),\n                                'active-id',\n                                Gio.SettingsBindFlags.DEFAULT);\n\n            let scales = [\n                ['animate_appicon_hover_options_duration_scale', 'animate-appicon-hover-animation-duration', 1],\n                ['animate_appicon_hover_options_rotation_scale', 'animate-appicon-hover-animation-rotation', 1],\n                ['animate_appicon_hover_options_travel_scale', 'animate-appicon-hover-animation-travel', 100],\n                ['animate_appicon_hover_options_zoom_scale', 'animate-appicon-hover-animation-zoom', 100],\n                ['animate_appicon_hover_options_convexity_scale', 'animate-appicon-hover-animation-convexity', 1],\n                ['animate_appicon_hover_options_extent_scale', 'animate-appicon-hover-animation-extent', 1],\n            ];\n\n            let updateScale = scale => {\n                let [id, key, factor] = scale;\n                let type = this._settings.get_string('animate-appicon-hover-animation-type');\n                let value = this._settings.get_value(key).deep_unpack()[type];\n                let defaultValue = this._settings.get_default_value(key).deep_unpack()[type];\n                this._builder.get_object(id).sensitive = defaultValue !== undefined;\n                this._builder.get_object(id).set_value(value * factor || 0);\n                this._builder.get_object(id).clear_marks();\n                this._builder.get_object(id).add_mark(defaultValue * factor, Gtk.PositionType.TOP,\n                                                      defaultValue !== undefined ? (defaultValue * factor).toString() : ' ');\n            };\n\n            scales.forEach(scale => {\n                let [id, key, factor] = scale;\n                this._settings.connect('changed::' + key, () => updateScale(scale));\n                this._builder.get_object(id).connect('value-changed', widget => {\n                    let type = this._settings.get_string('animate-appicon-hover-animation-type');\n                    let variant = this._settings.get_value(key);\n                    let unpacked = variant.deep_unpack();\n                    if (unpacked[type] != widget.get_value() / factor) {\n                        unpacked[type] = widget.get_value() / factor;\n                        this._settings.set_value(key, new GLib.Variant(variant.get_type_string(), unpacked));\n                    }\n                });\n            });\n\n            this._settings.connect('changed::animate-appicon-hover-animation-type', () => scales.forEach(updateScale));\n            scales.forEach(updateScale);\n        }\n\n        this._builder.get_object('animate_appicon_hover_button').connect('clicked', () => {\n            let box = this._builder.get_object('animate_appicon_hover_options');\n\n            let dialog = this._createPreferencesDialog(_('App icon animation options'), box, () =>\n            {\n                // restore default settings\n                this._settings.set_value('animate-appicon-hover-animation-type', this._settings.get_default_value('animate-appicon-hover-animation-type'));\n                this._settings.set_value('animate-appicon-hover-animation-duration', this._settings.get_default_value('animate-appicon-hover-animation-duration'));\n                this._settings.set_value('animate-appicon-hover-animation-rotation', this._settings.get_default_value('animate-appicon-hover-animation-rotation'));\n                this._settings.set_value('animate-appicon-hover-animation-travel', this._settings.get_default_value('animate-appicon-hover-animation-travel'));\n                this._settings.set_value('animate-appicon-hover-animation-zoom', this._settings.get_default_value('animate-appicon-hover-animation-zoom'));\n                this._settings.set_value('animate-appicon-hover-animation-convexity', this._settings.get_default_value('animate-appicon-hover-animation-convexity'));\n                this._settings.set_value('animate-appicon-hover-animation-extent', this._settings.get_default_value('animate-appicon-hover-animation-extent'));\n            });\n\n            dialog.show();\n\n        });\n\n        this._settings.bind('stockgs-keep-dash',\n                            this._builder.get_object('stockgs_dash_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('stockgs-keep-top-panel',\n                            this._builder.get_object('stockgs_top_panel_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        \n\n        this._settings.connect('changed::stockgs-keep-top-panel', () => this._maybeDisableTopPosition());\n\n        this._maybeDisableTopPosition();\n\n        this._settings.bind('stockgs-panelbtn-click-only',\n                            this._builder.get_object('stockgs_panelbtn_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n        \n        this._settings.bind('stockgs-force-hotcorner',\n                            this._builder.get_object('stockgs_hotcorner_switch'),\n                            'active',\n                            Gio.SettingsBindFlags.DEFAULT);\n\n        // About Panel\n\n        this._builder.get_object('extension_version').set_label(this._metadata.version.toString() + (this._metadata.commit ? ' (' + this._metadata.commit + ')' : ''));\n\n        this._builder.get_object('importexport_export_button').connect('clicked', widget => {\n            this._showFileChooser(\n                _('Export settings'),\n                { action: Gtk.FileChooserAction.SAVE },\n                \"Save\",\n                filename => {\n                    let file = Gio.file_new_for_path(filename);\n                    let raw = file.replace(null, false, Gio.FileCreateFlags.NONE, null);\n                    let out = Gio.BufferedOutputStream.new_sized(raw, 4096);\n\n                    out.write_all(GLib.spawn_command_line_sync('dconf dump ' + SCHEMA_PATH)[1], null);\n                    out.close(null);\n                }\n            );\n        });\n\n        this._builder.get_object('importexport_import_button').connect('clicked', widget => {\n            this._showFileChooser(\n                _('Import settings'),\n                { action: Gtk.FileChooserAction.OPEN },\n                \"Open\",\n                filename => {\n                    if (filename && GLib.file_test(filename, GLib.FileTest.EXISTS)) {\n                        let settingsFile = Gio.File.new_for_path(filename);\n                        let [ , pid, stdin, stdout, stderr] =\n                            GLib.spawn_async_with_pipes(\n                                null,\n                                ['dconf', 'load', SCHEMA_PATH],\n                                null,\n                                GLib.SpawnFlags.SEARCH_PATH | GLib.SpawnFlags.DO_NOT_REAP_CHILD,\n                                null\n                            );\n\n                        stdin = new Gio.UnixOutputStream({ fd: stdin, close_fd: true });\n                        GLib.close(stdout);\n                        GLib.close(stderr);\n\n                        stdin.splice(settingsFile.read(null), Gio.OutputStreamSpliceFlags.CLOSE_SOURCE | Gio.OutputStreamSpliceFlags.CLOSE_TARGET, null);\n                    }\n                }\n            );\n        });\n\n    }\n\n    _setPreviewTitlePosition() {\n        switch (this._settings.get_string('window-preview-title-position')) {\n            case 'BOTTOM':\n                this._builder.get_object('preview_title_position_bottom_button').set_active(true);\n                break;\n            case 'TOP':\n                this._builder.get_object('preview_title_position_top_button').set_active(true);\n                break;\n        }\n    }\n\n    _showFileChooser(title, params, acceptBtn, acceptHandler) {\n        let dialog = new Gtk.FileChooserDialog(mergeObjects({ title: title, transient_for: this.notebook.get_root() }, params));\n\n        dialog.add_button(\"Cancel\", Gtk.ResponseType.CANCEL);\n        dialog.add_button(acceptBtn, Gtk.ResponseType.ACCEPT);\n\n        dialog.show();\n\n        dialog.connect('response', (dialog, id) => {\n            if (id == Gtk.ResponseType.ACCEPT)\n                acceptHandler.call(this, dialog.get_file().get_path());\n            \n            dialog.destroy();\n        });\n    }\n}\n\n\nconst BuilderScope = GObject.registerClass({\n    Implements: [Gtk.BuilderScope],\n}, class BuilderScope extends GObject.Object {\n  \n    _init(preferences) {\n        this._preferences = preferences;\n        super._init();\n    }\n\n    vfunc_create_closure(builder, handlerName, flags, connectObject) {\n        if (flags & Gtk.BuilderClosureFlags.SWAPPED)\n            throw new Error('Unsupported template signal flag \"swapped\"');\n        \n        if (typeof this[handlerName] === 'undefined')\n            throw new Error(`${handlerName} is undefined`);\n        \n        return this[handlerName].bind(connectObject || this);\n    }\n    \n    on_btn_click(connectObject) {\n        connectObject.set_label(\"Clicked\");\n    }\n\n    position_bottom_button_clicked_cb(button) {\n        if (!this._preferences._ignorePositionRadios && button.get_active()) this._preferences._setPanelPosition(Pos.BOTTOM);\n    }\n\n    position_top_button_clicked_cb(button) {\n        if (!this._preferences._ignorePositionRadios && button.get_active()) this._preferences._setPanelPosition(Pos.TOP);\n    }\n    \n    position_left_button_clicked_cb(button) {\n       if (!this._preferences._ignorePositionRadios && button.get_active()) this._preferences._setPanelPosition(Pos.LEFT);\n    }\n\n    position_right_button_clicked_cb(button) {\n       if (!this._preferences._ignorePositionRadios && button.get_active()) this._preferences._setPanelPosition(Pos.RIGHT);\n    }\n\n    dots_bottom_button_toggled_cb(button) {\n        if (button.get_active())\n            this._preferences._settings.set_string('dot-position', \"BOTTOM\");\n    }\n\n    dots_top_button_toggled_cb(button) {\n        if (button.get_active())\n            this._preferences._settings.set_string('dot-position', \"TOP\");\n    }\n\n    dots_left_button_toggled_cb(button) {\n        if (button.get_active())\n            this._preferences._settings.set_string('dot-position', \"LEFT\");\n    }\n\n    dots_right_button_toggled_cb(button) {\n        if (button.get_active())\n            this._preferences._settings.set_string('dot-position', \"RIGHT\");\n    }\n\n    preview_title_position_bottom_button_toggled_cb(button) {\n        if (button.get_active())\n            this._preferences._settings.set_string('window-preview-title-position', 'BOTTOM');\n    }\n\n    preview_title_position_top_button_toggled_cb(button) {\n        if (button.get_active())\n            this._preferences._settings.set_string('window-preview-title-position', 'TOP');\n    }\n\n    panel_size_scale_value_changed_cb(scale) {\n        // Avoid settings the size continuously\n        if (this._preferences._panel_size_timeout > 0)\n            GLib.Source.remove(this._preferences._panel_size_timeout);\n\n        this._preferences._panel_size_timeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n            const value = scale.get_value();\n            const monitorSync = this._preferences._settings.get_boolean('panel-element-positions-monitors-sync');\n            const monitorsToSetFor = monitorSync ? this._preferences.monitors : [this._preferences._currentMonitorIndex];\n            monitorsToSetFor.forEach(monitorIndex => {\n                PanelSettings.setPanelSize(this._preferences._settings, monitorIndex, value);\n            });\n\n            this._preferences._panel_size_timeout = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    tray_size_scale_value_changed_cb(scale) {\n        // Avoid settings the size consinuosly\n        if (this._preferences._tray_size_timeout > 0)\n            GLib.Source.remove(this._preferences._tray_size_timeout);\n\n        this._preferences._tray_size_timeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n            this._preferences._settings.set_int('tray-size', scale.get_value());\n            this._preferences._tray_size_timeout = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    leftbox_size_scale_value_changed_cb(scale) {\n        // Avoid settings the size consinuosly\n        if (this._preferences._leftbox_size_timeout > 0)\n            GLib.Source.remove(this._preferences._leftbox_size_timeout);\n\n        this._preferences._leftbox_size_timeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n            this._preferences._settings.set_int('leftbox-size', scale.get_value());\n            this._preferences._leftbox_size_timeout = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    appicon_margin_scale_value_changed_cb(scale) {\n        // Avoid settings the size consinuosly\n        if (this._preferences._appicon_margin_timeout > 0)\n            GLib.Source.remove(this._preferences._appicon_margin_timeout);\n\n        this._preferences._appicon_margin_timeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n            this._preferences._settings.set_int('appicon-margin', scale.get_value());\n            this._preferences._appicon_margin_timeout = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    appicon_padding_scale_value_changed_cb(scale) {\n        // Avoid settings the size consinuosly\n        if (this._preferences._appicon_padding_timeout > 0)\n            GLib.Source.remove(this._preferences._appicon_padding_timeout);\n\n        this._preferences._appicon_padding_timeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n            this._preferences._settings.set_int('appicon-padding', scale.get_value());\n            this._preferences._appicon_padding_timeout = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    tray_padding_scale_value_changed_cb(scale) {\n        // Avoid settings the size consinuosly\n        if (this._preferences._tray_padding_timeout > 0)\n            GLib.Source.remove(this._preferences._tray_padding_timeout);\n\n        this._preferences._tray_padding_timeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n            this._preferences._settings.set_int('tray-padding', scale.get_value());\n            this._preferences._tray_padding_timeout = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    statusicon_padding_scale_value_changed_cb(scale) {\n        // Avoid settings the size consinuosly\n        if (this._preferences._statusicon_padding_timeout > 0)\n            GLib.Source.remove(this._preferences._statusicon_padding_timeout);\n\n        this._preferences._statusicon_padding_timeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n            this._preferences._settings.set_int('status-icon-padding', scale.get_value());\n            this._preferences._statusicon_padding_timeout = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    leftbox_padding_scale_value_changed_cb(scale) {\n        // Avoid settings the size consinuosly\n        if (this._preferences._leftbox_padding_timeout > 0)\n            GLib.Source.remove(this._preferences._leftbox_padding_timeout);\n\n        this._preferences._leftbox_padding_timeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n            this._preferences._settings.set_int('leftbox-padding', scale.get_value());\n            this._preferences._leftbox_padding_timeout = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n});\n\n\nexport default class DashToPanelPreferences extends ExtensionPreferences {\n    fillPreferencesWindow(window) {\n        window._settings = this.getSettings('org.gnome.shell.extensions.dash-to-panel');\n\n        // use default width or window\n        window.set_default_size(0, 740);\n\n        let preferences = new Preferences(window, window._settings, this.path);\n    }\n}\n"
        },
        {
          "name": "progress.js",
          "type": "blob",
          "size": 18.6806640625,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Credits:\n * This file is based on code from the Dash to Dock extension by micheleg\n */\n\nimport Cairo from 'cairo';\nimport Gio from 'gi://Gio';\nimport Clutter from 'gi://Clutter';\nimport Pango from 'gi://Pango';\nimport St from 'gi://St';\nimport * as Utils from './utils.js';\nimport {SETTINGS} from './extension.js';\n\nimport {EventEmitter} from 'resource:///org/gnome/shell/misc/signals.js';\n\n\nexport const ProgressManager = class extends EventEmitter {\n\n    constructor() {\n        super();\n\n        this._entriesByDBusName = {};\n\n        this._launcher_entry_dbus_signal_id =\n            Gio.DBus.session.signal_subscribe(null, // sender\n                'com.canonical.Unity.LauncherEntry', // iface\n                null, // member\n                null, // path\n                null, // arg0\n                Gio.DBusSignalFlags.NONE,\n                this._onEntrySignalReceived.bind(this));\n\n        this._dbus_name_owner_changed_signal_id =\n            Gio.DBus.session.signal_subscribe('org.freedesktop.DBus',  // sender\n                'org.freedesktop.DBus',  // interface\n                'NameOwnerChanged',      // member\n                '/org/freedesktop/DBus', // path\n                null,                    // arg0\n                Gio.DBusSignalFlags.NONE,\n                this._onDBusNameOwnerChanged.bind(this));\n\n        this._acquireUnityDBus();\n    }\n\n    destroy() {\n        if (this._launcher_entry_dbus_signal_id) {\n            Gio.DBus.session.signal_unsubscribe(this._launcher_entry_dbus_signal_id);\n        }\n\n        if (this._dbus_name_owner_changed_signal_id) {\n            Gio.DBus.session.signal_unsubscribe(this._dbus_name_owner_changed_signal_id);\n        }\n\n        this._releaseUnityDBus();\n    }\n\n    size() {\n        return Object.keys(this._entriesByDBusName).length;\n    }\n\n    lookupByDBusName(dbusName) {\n        return this._entriesByDBusName.hasOwnProperty(dbusName) ? this._entriesByDBusName[dbusName] : null;\n    }\n\n    lookupById(appId) {\n        let ret = [];\n        for (let dbusName in this._entriesByDBusName) {\n            let entry = this._entriesByDBusName[dbusName];\n            if (entry && entry.appId() == appId) {\n                ret.push(entry);\n            }\n        }\n\n        return ret;\n    }\n\n    addEntry(entry) {\n        let existingEntry = this.lookupByDBusName(entry.dbusName());\n        if (existingEntry) {\n            existingEntry.update(entry);\n        } else {\n            this._entriesByDBusName[entry.dbusName()] = entry;\n            this.emit('progress-entry-added', entry);\n        }\n    }\n\n    removeEntry(entry) {\n        delete this._entriesByDBusName[entry.dbusName()]\n        this.emit('progress-entry-removed', entry);\n    }\n\n    _acquireUnityDBus() {\n        if (!this._unity_bus_id) {\n            Gio.DBus.session.own_name('com.canonical.Unity',\n                Gio.BusNameOwnerFlags.ALLOW_REPLACEMENT, null, null);\n        }\n    }\n\n    _releaseUnityDBus() {\n        if (this._unity_bus_id) {\n            Gio.DBus.session.unown_name(this._unity_bus_id);\n            this._unity_bus_id = 0;\n        }\n    }\n\n    _onEntrySignalReceived(connection, sender_name, object_path,\n        interface_name, signal_name, parameters, user_data) {\n        if (!parameters || !signal_name)\n            return;\n\n        if (signal_name == 'Update') {\n            if (!sender_name) {\n                return;\n            }\n\n            this._handleUpdateRequest(sender_name, parameters);\n        }\n    }\n\n    _onDBusNameOwnerChanged(connection, sender_name, object_path,\n        interface_name, signal_name, parameters, user_data) {\n        if (!parameters || !this.size())\n            return;\n\n        let [name, before, after] = parameters.deep_unpack();\n\n        if (!after) {\n            if (this._entriesByDBusName.hasOwnProperty(before)) {\n                this.removeEntry(this._entriesByDBusName[before]);\n            }\n        }\n    }\n\n    _handleUpdateRequest(senderName, parameters) {\n        if (!senderName || !parameters) {\n            return;\n        }\n\n        let [appUri, properties] = parameters.deep_unpack();\n        let appId = appUri.replace(/(^\\w+:|^)\\/\\//, '');\n        let entry = this.lookupByDBusName(senderName);\n\n        if (entry) {\n            entry.setDBusName(senderName);\n            entry.update(properties);\n        } else {\n            let entry = new AppProgress(senderName, appId, properties);\n            this.addEntry(entry);\n        }\n    }\n};\n\nexport class AppProgress extends EventEmitter {\n\n    constructor(dbusName, appId, properties) {\n        super();\n\n        this._dbusName = dbusName;\n        this._appId = appId;\n        this._count = 0;\n        this._countVisible = false;\n        this._progress = 0.0;\n        this._progressVisible = false;\n        this._urgent = false;\n        this.update(properties);\n    }\n\n    appId() {\n        return this._appId;\n    }\n\n    dbusName() {\n        return this._dbusName;\n    }\n\n    count() {\n        return this._count;\n    }\n\n    setCount(count) {\n        if (this._count != count) {\n            this._count = count;\n            this.emit('count-changed', this._count);\n        }\n    }\n\n    countVisible() {\n        return this._countVisible;\n    }\n\n    setCountVisible(countVisible) {\n        if (this._countVisible != countVisible) {\n            this._countVisible = countVisible;\n            this.emit('count-visible-changed', this._countVisible);\n        }\n    }\n\n    progress() {\n        return this._progress;\n    }\n\n    setProgress(progress) {\n        if (this._progress != progress) {\n            this._progress = progress;\n            this.emit('progress-changed', this._progress);\n        }\n    }\n\n    progressVisible() {\n        return this._progressVisible;\n    }\n\n    setProgressVisible(progressVisible) {\n        if (this._progressVisible != progressVisible) {\n            this._progressVisible = progressVisible;\n            this.emit('progress-visible-changed', this._progressVisible);\n        }\n    }\n\n    urgent() {\n        return this._urgent;\n    }\n\n    setUrgent(urgent) {\n        if (this._urgent != urgent) {\n            this._urgent = urgent;\n            this.emit('urgent-changed', this._urgent);\n        }\n    }\n\n    setDBusName(dbusName) {\n        if (this._dbusName != dbusName) {\n            let oldName = this._dbusName;\n            this._dbusName = dbusName;\n            this.emit('dbus-name-changed', oldName);\n        }\n    }\n\n    update(other) {\n        if (other instanceof AppProgress) {\n            this.setDBusName(other.dbusName())\n            this.setCount(other.count());\n            this.setCountVisible(other.countVisible());\n            this.setProgress(other.progress());\n            this.setProgressVisible(other.progressVisible())\n            this.setUrgent(other.urgent());\n        } else {\n            for (let property in other) {\n                if (other.hasOwnProperty(property)) {\n                    if (property == 'count') {\n                        this.setCount(other[property].get_int64());\n                    } else if (property == 'count-visible') {\n                        this.setCountVisible(SETTINGS.get_boolean('progress-show-count') && other[property].get_boolean());\n                    } else if (property == 'progress') {\n                        this.setProgress(other[property].get_double());\n                    } else if (property == 'progress-visible') {\n                        this.setProgressVisible(SETTINGS.get_boolean('progress-show-bar') && other[property].get_boolean());\n                    } else if (property == 'urgent') {\n                        this.setUrgent(other[property].get_boolean());\n                    } else {\n                        // Not implemented yet\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nexport const ProgressIndicator = class {\n\n    constructor(source, progressManager) {\n        this._source = source;\n        this._progressManager = progressManager;\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n\n        this._sourceDestroyId = this._source.connect('destroy', () => {\n            this._signalsHandler.destroy();\n        });          \n\n        this._notificationBadgeLabel = new St.Label({ style_class: 'badge' });\n        this._notificationBadgeBin = new St.Bin({\n            child: this._notificationBadgeLabel, y: 2, x: 2\n        });\n        this._notificationBadgeLabel.add_style_class_name('notification-badge');\n        this._notificationBadgeCount = 0;\n        this._notificationBadgeBin.hide();\n\n        this._source._dtpIconContainer.add_child(this._notificationBadgeBin);\n        this._source._dtpIconContainer.connect('notify::allocation', this.updateNotificationBadge.bind(this));\n\n        this._progressManagerEntries = [];\n        this._progressManager.lookupById(this._source.app.id).forEach(\n            (entry) => {\n                this.insertEntry(entry);\n            }\n        );\n\n        this._signalsHandler.add([\n            this._progressManager,\n            'progress-entry-added',\n            this._onEntryAdded.bind(this)\n        ], [\n            this._progressManager,\n            'progress-entry-removed',\n            this._onEntryRemoved.bind(this)\n        ]);\n    }\n\n    destroy() {\n        this._source.disconnect(this._sourceDestroyId);\n        this._signalsHandler.destroy();\n    }\n\n    _onEntryAdded(appProgress, entry) {\n        if (!entry || !entry.appId())\n            return;\n        if (this._source && this._source.app && this._source.app.id == entry.appId()) {\n            this.insertEntry(entry);\n        }\n    }\n\n    _onEntryRemoved(appProgress, entry) {\n        if (!entry || !entry.appId())\n            return;\n\n        if (this._source && this._source.app && this._source.app.id == entry.appId()) {\n            this.removeEntry(entry);\n        }\n    }\n\n    updateNotificationBadge() {\n        this._source.updateNumberOverlay(this._notificationBadgeBin);\n        this._notificationBadgeLabel.clutter_text.ellipsize = Pango.EllipsizeMode.MIDDLE;\n    }\n\n    _notificationBadgeCountToText(count) {\n        if (count <= 9999) {\n            return count.toString();\n        } else if (count < 1e5) {\n            let thousands = count / 1e3;\n            return thousands.toFixed(1).toString() + \"k\";\n        } else if (count < 1e6) {\n            let thousands = count / 1e3;\n            return thousands.toFixed(0).toString() + \"k\";\n        } else if (count < 1e8) {\n            let millions = count / 1e6;\n            return millions.toFixed(1).toString() + \"M\";\n        } else if (count < 1e9) {\n            let millions = count / 1e6;\n            return millions.toFixed(0).toString() + \"M\";\n        } else {\n            let billions = count / 1e9;\n            return billions.toFixed(1).toString() + \"B\";\n        }\n    }\n\n    setNotificationBadge(count) {\n        this._notificationBadgeCount = count;\n        let text = this._notificationBadgeCountToText(count);\n        this._notificationBadgeLabel.set_text(text);\n    }\n\n    toggleNotificationBadge(activate) {\n        if (activate && this._notificationBadgeCount > 0) {\n            this.updateNotificationBadge();\n            this._notificationBadgeBin.show();\n        }\n        else\n            this._notificationBadgeBin.hide();\n    }\n\n    _showProgressOverlay() {\n        if (this._progressOverlayArea) {\n            this._updateProgressOverlay();\n            return;\n        }\n\n        this._progressOverlayArea = new St.DrawingArea({x_expand: true, y_expand: true});\n        this._progressOverlayArea.add_style_class_name('progress-bar');\n        this._progressOverlayArea.connect('repaint', () => {\n            this._drawProgressOverlay(this._progressOverlayArea);\n        });\n\n        this._source._iconContainer.add_child(this._progressOverlayArea);\n        let node = this._progressOverlayArea.get_theme_node();\n\n        let [hasColor, color] = node.lookup_color('-progress-bar-background', false);\n        if (hasColor)\n            this._progressbar_background = color\n        else\n            this._progressbar_background = new Utils.ColorUtils.Color({red: 204, green: 204, blue: 204, alpha: 255});\n\n        [hasColor, color] = node.lookup_color('-progress-bar-border', false);\n        if (hasColor)\n            this._progressbar_border = color;\n        else\n            this._progressbar_border = new Utils.ColorUtils.Color({red: 230, green: 230, blue: 230, alpha: 255});\n\n        this._updateProgressOverlay();\n    }\n\n    _hideProgressOverlay() {\n        if (this._progressOverlayArea)\n            this._progressOverlayArea.destroy();\n\n        this._progressOverlayArea = null;\n        this._progressbar_background = null;\n        this._progressbar_border = null;\n    }\n\n    _updateProgressOverlay() {\n\n        if (this._progressOverlayArea) {\n            this._progressOverlayArea.queue_repaint();\n        }\n    }\n\n    _drawProgressOverlay(area) {\n        let scaleFactor = Utils.getScaleFactor();\n        let [surfaceWidth, surfaceHeight] = area.get_surface_size();\n        let cr = area.get_context();\n\n        let iconSize = this._source.icon.iconSize * scaleFactor;\n\n        let x = Math.floor((surfaceWidth - iconSize) / 2);\n        let y = Math.floor((surfaceHeight - iconSize) / 2);\n\n        let lineWidth = Math.floor(1.0 * scaleFactor);\n        let padding = Math.floor(iconSize * 0.05);\n        let width = iconSize - 2.0*padding;\n        let height = Math.floor(Math.min(18.0*scaleFactor, 0.20*iconSize));\n        x += padding;\n        y += iconSize - height - padding;\n\n        cr.setLineWidth(lineWidth);\n\n        // Draw the outer stroke\n        let stroke = new Cairo.LinearGradient(0, y, 0, y + height);\n        let fill = null;\n        stroke.addColorStopRGBA(0.5, 0.5, 0.5, 0.5, 0.1);\n        stroke.addColorStopRGBA(0.9, 0.8, 0.8, 0.8, 0.4);\n        Utils.drawRoundedLine(cr, x + lineWidth/2.0, y + lineWidth/2.0, width, height, true, true, stroke, fill);\n\n        // Draw the background\n        x += lineWidth;\n        y += lineWidth;\n        width -= 2.0*lineWidth;\n        height -= 2.0*lineWidth;\n\n        stroke = Cairo.SolidPattern.createRGBA(0.20, 0.20, 0.20, 0.9);\n        fill = new Cairo.LinearGradient(0, y, 0, y + height);\n        fill.addColorStopRGBA(0.4, 0.25, 0.25, 0.25, 1.0);\n        fill.addColorStopRGBA(0.9, 0.35, 0.35, 0.35, 1.0);\n        Utils.drawRoundedLine(cr, x + lineWidth/2.0, y + lineWidth/2.0, width, height, true, true, stroke, fill);\n\n        // Draw the finished bar\n        x += lineWidth;\n        y += lineWidth;\n        width -= 2.0*lineWidth;\n        height -= 2.0*lineWidth;\n\n        let finishedWidth = Math.ceil(this._progress * width);\n\n        let bg = this._progressbar_background;\n        let bd = this._progressbar_border;\n\n        stroke = Cairo.SolidPattern.createRGBA(bd.red/255, bd.green/255, bd.blue/255, bd.alpha/255);\n        fill = Cairo.SolidPattern.createRGBA(bg.red/255, bg.green/255, bg.blue/255, bg.alpha/255);\n\n        if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)\n            Utils.drawRoundedLine(cr, x + lineWidth/2.0 + width - finishedWidth, y + lineWidth/2.0, finishedWidth, height, true, true, stroke, fill);\n        else\n            Utils.drawRoundedLine(cr, x + lineWidth/2.0, y + lineWidth/2.0, finishedWidth, height, true, true, stroke, fill);\n\n        cr.$dispose();\n    }\n\n    setProgress(progress) {\n        this._progress = Math.min(Math.max(progress, 0.0), 1.0);\n        this._updateProgressOverlay();\n    }\n\n    toggleProgressOverlay(activate) {\n        if (activate) {\n            this._showProgressOverlay();\n        }\n        else {\n            this._hideProgressOverlay();\n        }\n    }\n\n    insertEntry(appProgress) {\n        if (!appProgress || this._progressManagerEntries.indexOf(appProgress) !== -1)\n            return;\n\n        this._progressManagerEntries.push(appProgress);\n        this._selectEntry(appProgress);\n    }\n\n    removeEntry(appProgress) {\n        if (!appProgress || this._progressManagerEntries.indexOf(appProgress) == -1)\n            return;\n\n        this._progressManagerEntries.splice(this._progressManagerEntries.indexOf(appProgress), 1);\n\n        if (this._progressManagerEntries.length > 0) {\n            this._selectEntry(this._progressManagerEntries[this._progressManagerEntries.length-1]);\n        } else {\n            this.setNotificationBadge(0);\n            this.toggleNotificationBadge(false);\n            this.setProgress(0);\n            this.toggleProgressOverlay(false);\n            this.setUrgent(false);\n        }\n    }\n\n    _selectEntry(appProgress) {\n        if (!appProgress)\n            return;\n\n        this._signalsHandler.removeWithLabel('progress-entry');\n\n        this._signalsHandler.addWithLabel('progress-entry',\n        [\n            appProgress,\n            'count-changed',\n            (appProgress, value) => {\n                this.setNotificationBadge(value);\n            }\n        ], [\n            appProgress,\n            'count-visible-changed',\n            (appProgress, value) => {\n                this.toggleNotificationBadge(value);\n            }\n        ], [\n            appProgress,\n            'progress-changed',\n            (appProgress, value) => {\n                this.setProgress(value);\n            }\n        ], [\n            appProgress,\n            'progress-visible-changed',\n            (appProgress, value) => {\n                this.toggleProgressOverlay(value);\n            }\n        ], [\n            appProgress,\n            'urgent-changed',\n            (appProgress, value) => {\n                this.setUrgent(value)\n            }\n        ]);\n\n        this.setNotificationBadge(appProgress.count());\n        this.toggleNotificationBadge(appProgress.countVisible());\n        this.setProgress(appProgress.progress());\n        this.toggleProgressOverlay(appProgress.progressVisible());\n\n        this._isUrgent = false;\n    }\n\n    setUrgent(urgent) {\n        const icon = this._source.icon._iconBin;\n        if (urgent) {\n            if (!this._isUrgent) {\n                icon.set_pivot_point(0.5, 0.5);\n                this._source.iconAnimator.addAnimation(icon, 'dance');\n                this._isUrgent = true;\n            }\n        } else {\n            if (this._isUrgent) {\n                this._source.iconAnimator.removeAnimation(icon, 'dance');\n                this._isUrgent = false;\n            }\n            icon.rotation_angle_z = 0;\n        }\n    }\n};\n"
        },
        {
          "name": "proximity.js",
          "type": "blob",
          "size": 7.919921875,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport Meta from 'gi://Meta';\nimport Mtk from 'gi://Mtk';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\n\nimport * as Utils from './utils.js';\n\n//timeout intervals\nconst MIN_UPDATE_MS = 200;\n\n//timeout names\nconst T1 = 'limitUpdateTimeout';\n\nexport const Mode = {\n    ALL_WINDOWS: 0,\n    FOCUSED_WINDOWS: 1,\n    MAXIMIZED_WINDOWS: 2\n};\n\nexport class ProximityWatch {\n\n    constructor(actor, monitorIndex, mode, xThreshold, yThreshold, handler) {\n        this.actor = actor;\n        this.monitorIndex = monitorIndex\n        this.overlap = false;\n        this.mode = mode;\n        this.threshold = [xThreshold, yThreshold];\n        this.handler = handler;\n\n        this._allocationChangedId = actor.connect('notify::allocation', () => this._updateWatchRect());\n\n        this._updateWatchRect();\n    }\n\n    destroy() {\n        this.actor.disconnect(this._allocationChangedId);\n    }\n\n    _updateWatchRect() {\n        let [actorX, actorY] = this.actor.get_position();\n\n        this.rect = new Mtk.Rectangle({ \n            x: actorX - this.threshold[0],\n            y: actorY - this.threshold[1],\n            width: this.actor.width + this.threshold[0] * 2,\n            height: this.actor.height + this.threshold[1] * 2 \n        });\n    }\n};\n\nexport const ProximityManager = class {\n\n    constructor() {\n        this._counter = 1;\n        this._watches = {};\n        this._focusedWindowInfo = null;\n\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._timeoutsHandler = new Utils.TimeoutsHandler();\n\n        this._bindSignals();\n        this._setFocusedWindow();\n    }\n\n    createWatch(actor, monitorIndex, mode, xThreshold, yThreshold, handler) {\n        let watch = new ProximityWatch(actor, monitorIndex, mode, xThreshold, yThreshold, handler);\n\n        this._watches[this._counter] = watch;\n        this.update();\n        \n        return this._counter++;\n    }\n\n    removeWatch(id) {\n        if (this._watches[id]) {\n            this._watches[id].destroy();\n            delete this._watches[id];\n        }\n    }\n\n    update() {\n        this._queueUpdate(true);\n    }\n\n    destroy() {\n        this._signalsHandler.destroy();\n        this._timeoutsHandler.destroy();\n        this._disconnectFocusedWindow();\n        Object.keys(this._watches).forEach(id => this.removeWatch(id));\n    }\n\n    _bindSignals() {\n        this._signalsHandler.add(\n            [\n                global.window_manager,\n                'switch-workspace', \n                () => this._queueUpdate()\n            ],\n            [\n                Main.overview,\n                'hidden',\n                () => this._queueUpdate()\n            ],\n            [\n                global.display,\n                'notify::focus-window', \n                () => {\n                    this._setFocusedWindow();\n                    this._queueUpdate();\n                }\n            ],\n            [\n                global.display, \n                'restacked', \n                () => this._queueUpdate()\n            ]\n        );\n    }\n\n    _setFocusedWindow() {\n        this._disconnectFocusedWindow();\n\n        let focusedWindow = global.display.focus_window;\n\n        if (focusedWindow) {\n            let focusedWindowInfo = this._getFocusedWindowInfo(focusedWindow);\n\n            if (focusedWindowInfo && this._checkIfHandledWindowType(focusedWindowInfo.metaWindow)) {\n                focusedWindowInfo.allocationId = focusedWindowInfo.window.connect('notify::allocation', () => this._queueUpdate());\n                focusedWindowInfo.destroyId = focusedWindowInfo.window.connect('destroy', () => this._disconnectFocusedWindow(true));\n                \n                this._focusedWindowInfo = focusedWindowInfo;\n            }\n        }\n    }\n\n    _getFocusedWindowInfo(focusedWindow) {\n        let window = focusedWindow.get_compositor_private();\n        let focusedWindowInfo;\n\n        if (window) {\n            focusedWindowInfo = { window: window };\n            focusedWindowInfo.metaWindow = focusedWindow;\n\n            if (focusedWindow.is_attached_dialog()) {\n                let mainMetaWindow = focusedWindow.get_transient_for();\n\n                if (focusedWindowInfo.metaWindow.get_frame_rect().height < mainMetaWindow.get_frame_rect().height) {\n                    focusedWindowInfo.window = mainMetaWindow.get_compositor_private();\n                    focusedWindowInfo.metaWindow = mainMetaWindow;\n                }\n            }\n        }\n\n        return focusedWindowInfo;\n    }\n\n    _disconnectFocusedWindow(destroy) {\n        if (this._focusedWindowInfo && !destroy) {\n            this._focusedWindowInfo.window.disconnect(this._focusedWindowInfo.allocationId);\n            this._focusedWindowInfo.window.disconnect(this._focusedWindowInfo.destroyId);\n        }\n\n        this._focusedWindowInfo = null;\n    }\n\n    _getHandledWindows() {\n        return Utils.getCurrentWorkspace()\n                    .list_windows()\n                    .filter(mw => this._checkIfHandledWindow(mw));\n    }\n\n    _checkIfHandledWindow(metaWindow) {\n        return metaWindow && \n               !metaWindow.minimized &&\n               !metaWindow.customJS_ding &&\n               this._checkIfHandledWindowType(metaWindow);\n    }\n\n    _checkIfHandledWindowType(metaWindow) {\n        let metaWindowType = metaWindow.get_window_type();\n\n        //https://www.roojs.org/seed/gir-1.2-gtk-3.0/seed/Meta.WindowType.html\n        return metaWindowType <= Meta.WindowType.SPLASHSCREEN && \n               metaWindowType != Meta.WindowType.DESKTOP;\n    }\n\n    _queueUpdate(noDelay) {\n        if (!noDelay && this._timeoutsHandler.getId(T1)) {\n            //limit the number of updates\n            this._pendingUpdate = true;\n            return;\n        }\n\n        this._timeoutsHandler.add([T1, MIN_UPDATE_MS, () => this._endLimitUpdate()]);\n\n        let metaWindows = this._getHandledWindows();\n\n        Object.keys(this._watches).forEach(id => {\n            let watch = this._watches[id];\n            let overlap = !!this._update(watch, metaWindows);\n\n            if (overlap !== watch.overlap) {\n                watch.handler(overlap);\n                watch.overlap = overlap;\n            }\n        });\n    }\n\n    _endLimitUpdate() {\n        if (this._pendingUpdate) {\n            this._pendingUpdate = false;\n            this._queueUpdate();\n        }\n    }\n\n    _update(watch, metaWindows) {\n        if (watch.mode === Mode.FOCUSED_WINDOWS)\n            return (this._focusedWindowInfo && \n                    this._checkIfHandledWindow(this._focusedWindowInfo.metaWindow) &&\n                    this._checkProximity(this._focusedWindowInfo.metaWindow, watch));\n\n        if (watch.mode === Mode.MAXIMIZED_WINDOWS)\n            return metaWindows.some(mw => mw.maximized_vertically && mw.maximized_horizontally && \n                                          mw.get_monitor() == watch.monitorIndex);\n        \n        //Mode.ALL_WINDOWS\n        return metaWindows.some(mw => this._checkProximity(mw, watch));\n    }\n\n    _checkProximity(metaWindow, watch) {\n        let windowRect = metaWindow.get_frame_rect();\n\n        return windowRect.overlap(watch.rect) && \n               ((!watch.threshold[0] && !watch.threshold[1]) || \n                metaWindow.get_monitor() == watch.monitorIndex || \n                windowRect.overlap(global.display.get_monitor_geometry(watch.monitorIndex)));\n    }\n};\n"
        },
        {
          "name": "schemas",
          "type": "tree",
          "content": null
        },
        {
          "name": "stylesheet.css",
          "type": "blob",
          "size": 3.9765625,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Credits:\n * This file is based on code from the Dash to Dock extension by micheleg\n * and code from the Taskbar extension by Zorin OS\n * Some code was also adapted from the upstream Gnome Shell source code.\n */\n\n#dashtopanelTaskbar .dash-item-container > StWidget,\n.dashtopanelMainPanel .dash-item-container .show-apps {\n\tmargin: 0;\n\tpadding: 0;\n}\n\n#dashtopanelScrollview .overview-tile,\n.dashtopanelMainPanel .overview-tile {\n\tbackground: none;\n}\n\n#dashtopanelScrollview .overview-tile .overview-label {\n\t/* must match TITLE_RIGHT_PADDING in apppicons.js */\n\tpadding-right: 8px;\n\ttext-align: left;\n}\n\n#dashtopanelScrollview .overview-tile:hover .dtp-container,\n#dashtopanelScrollview .overview-tile:focus .dtp-container,\n.dashtopanelMainPanel .dash-item-container .show-apps:hover {\n\tbackground-color: rgba(238, 238, 238, 0.1);\n}\n\n.dashtopanelMainPanel .dash-item-container .show-apps .overview-icon {\n\tcolor: #FFF;\n}\n\n#dashtopanelTaskbar .dash-item-container .overview-tile:hover,\n#dashtopanelTaskbar .dash-item-container .overview-tile .dtp-container .overview-icon,\n#dashtopanelScrollview .overview-tile:hover .dtp-container.animate-appicon-hover,\n.dashtopanelMainPanel .dash-item-container .show-apps:hover .overview-icon {\n\tbackground: none;\n}\n\n#dashtopanelScrollview .overview-tile:active .dtp-container {\n\tbackground-color: rgba(238, 238, 236, 0.18);\n}\n\n#dashtopanelScrollview .overview-tile .favorite {\n\tbackground-color: rgba(80, 150, 255, 0.4);\n}\n\n#dashtopanelTaskbar .scrollview-fade {\n\tbackground-gradient-end: rgba(0, 0, 0, 0);\n}\n\n.dashtopanelSecondaryMenu {\n\tmax-width: 400px;\n}\n\n.dashtopanelMainPanel.vertical .panel-button {\n\ttext-align: center;\n}\n\n.dashtopanelMainPanel.vertical .panel-button.vertical *,\n.dashtopanelMainPanel.vertical .panel-button.clock-display * {\n\tpadding: 0;\n\tmargin: 0;\n}\n\n.dashtopanelMainPanel.vertical .panel-button > *,\n.dashtopanelMainPanel.vertical .panel-button.vertical > *,\n.dashtopanelMainPanel.vertical .panel-button.vertical .system-status-icon,\n.dashtopanelMainPanel.vertical .panel-button.clock-display > *,\n.dashtopanelMainPanel.vertical .panel-button.clock-display .clock {\n\tpadding: 8px 0;\n}\n\n.dashtopanelMainPanel.vertical .panel-button.clock-display {\n\t-natural-hpadding: 0;\n\t-minimum-hpadding: 0;\n}\n\n#dashtopanelThumbnailList {\n\tspacing: 0em;\n\tpadding: 0 1em;\n}\n\n#dashtopanelThumbnailList .popup-menu-item {\n\tpadding: 0;\n\tborder-radius: 5px;\n\tspacing: 0;\n}\n\n#dashtopanelThumbnailList .window-box {\n\tpadding: 0;\n\tspacing: 0;\n}\n\n#dashtopanelThumbnailList .preview-window-title {\n\tpadding-top: 1em;\n}\n\n.popup-menu.panel-menu {\n\tmargin-bottom: 0;\n}\n\n#panel #panelLeft, #panel #panelCenter {\n\tspacing: 0px;\n}\n\n.showdesktop-button-dark-hovered {\n\tbackground-color: rgba(200, 200, 200, .4);\n}\n\n.showdesktop-button-light-hovered {\n\tbackground-color: rgba(55, 55, 55, .4);\n}\n\n#dashtopanelScrollview .badge {\n\tcolor: rgba(255, 255, 255, 1);\n\tfont-weight: bold;\n\ttext-align: center;\n}\n\n#dashtopanelScrollview .number-overlay {\n\tbackground-color: rgba(0,0,0,0.8);\n}\n\n#dashtopanelScrollview .notification-badge {\n\tbackground-color: rgba(255,0,0,0.8);\n}\n\n#dashtopanelScrollview .progress-bar {\n\t/* Customization of the progress bar style, e.g.:\n\t-progress-bar-background: rgba(0.8, 0.8, 0.8, 1);\n\t-progress-bar-border: rgba(0.9, 0.9, 0.9, 1); */\n}\n\n.symbolic-icon-style {\n\t-st-icon-style: symbolic;\n}\n"
        },
        {
          "name": "taskbar.js",
          "type": "blob",
          "size": 58.4912109375,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Credits:\n * This file is based on code from the Dash to Dock extension by micheleg\n * and code from the Taskbar extension by Zorin OS\n * Some code was also adapted from the upstream Gnome Shell source code.\n */\n\n\nimport Clutter from 'gi://Clutter';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport GObject from 'gi://GObject';\nimport Graphene from 'gi://Graphene';\nimport Shell from 'gi://Shell';\nimport St from 'gi://St';\n\nimport * as AppFavorites from 'resource:///org/gnome/shell/ui/appFavorites.js';\nimport * as Dash from 'resource:///org/gnome/shell/ui/dash.js';\nimport * as DND from 'resource:///org/gnome/shell/ui/dnd.js';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport {EventEmitter} from 'resource:///org/gnome/shell/misc/signals.js';\n\nimport * as AppIcons from './appIcons.js';\nimport * as PanelManager from './panelManager.js';\nimport * as PanelSettings from './panelSettings.js';\nimport * as Pos from './panelPositions.js';\nimport * as Utils from './utils.js';\nimport * as WindowPreview from './windowPreview.js';\nimport {SETTINGS} from './extension.js';\n\nconst SearchController = Main.overview.searchController;\n\nexport const DASH_ANIMATION_TIME = .2; // Dash.DASH_ANIMATION_TIME is now private\nconst DASH_ITEM_HOVER_TIMEOUT = .3; // Dash.DASH_ITEM_HOVER_TIMEOUT is now private\nexport const MIN_ICON_SIZE = 4;\n\nconst T1 = 'ensureAppIconVisibilityTimeout'\nconst T2 = 'showLabelTimeout'\nconst T3 = 'resetHoverTimeout'\n\n\n/**\n * Extend DashItemContainer\n *\n * - set label position based on taskbar orientation\n *\n *  I can't subclass the original object because of this: https://bugzilla.gnome.org/show_bug.cgi?id=688973.\n *  thus use this ugly pattern.\n */\n\nexport function extendDashItemContainer(dashItemContainer) {\n    dashItemContainer.showLabel = AppIcons.ItemShowLabel;\n}\n\nconst iconAnimationSettings = {\n    _getDictValue(key) {\n        let type = SETTINGS.get_string('animate-appicon-hover-animation-type');\n        return SETTINGS.get_value(key).deep_unpack()[type] || 0;\n    },\n\n    get type() {\n        if (!SETTINGS.get_boolean('animate-appicon-hover'))\n            return \"\";\n\n        return SETTINGS.get_string('animate-appicon-hover-animation-type');\n    },\n\n    get convexity() {\n        return Math.max(0, this._getDictValue('animate-appicon-hover-animation-convexity'));\n    },\n\n    get duration() {\n        return this._getDictValue('animate-appicon-hover-animation-duration');\n    },\n\n    get extent() {\n        return Math.max(1, this._getDictValue('animate-appicon-hover-animation-extent'));\n    },\n\n    get rotation() {\n        return this._getDictValue('animate-appicon-hover-animation-rotation');\n    },\n\n    get travel() {\n        return Math.max(0, this._getDictValue('animate-appicon-hover-animation-travel'));\n    },\n\n    get zoom() {\n        return Math.max(1, this._getDictValue('animate-appicon-hover-animation-zoom'));\n    },\n};\n\n/* This class is a fork of the upstream DashActor class (ui.dash.js)\n *\n * Summary of changes:\n * - modified chldBox calculations for when 'show-apps-at-top' option is checked\n * - handle horizontal dash\n */\nexport const TaskbarActor = GObject.registerClass({\n}, class TaskbarActor extends St.Widget {\n    _init(delegate) {\n        this._delegate = delegate;\n        this._currentBackgroundColor = 0;\n        super._init({ name: 'dashtopanelTaskbar',\n                      layout_manager: new Clutter.BoxLayout({ orientation: Clutter.Orientation[delegate.dtpPanel.getOrientation().toUpperCase()] }),\n                      clip_to_allocation: true });\n    }\n\n    vfunc_allocate(box) {\n        this.set_allocation(box);\n\n        let panel = this._delegate.dtpPanel;\n        let availFixedSize = box[panel.fixedCoord.c2] - box[panel.fixedCoord.c1];\n        let availVarSize = box[panel.varCoord.c2] - box[panel.varCoord.c1];\n        let [dummy, scrollview, leftFade, rightFade] = this.get_children();\n        let [, natSize] = this[panel.sizeFunc](availFixedSize);\n        let childBox = new Clutter.ActorBox();\n        let orientation = panel.getOrientation();\n\n        dummy.allocate(childBox);\n\n        childBox[panel.varCoord.c1] = box[panel.varCoord.c1];\n        childBox[panel.varCoord.c2] = Math.min(availVarSize, natSize);\n        childBox[panel.fixedCoord.c1] = box[panel.fixedCoord.c1];\n        childBox[panel.fixedCoord.c2] = box[panel.fixedCoord.c2];\n\n        scrollview.allocate(childBox);\n\n        let [value, , upper, , , pageSize] = scrollview[orientation[0] + 'adjustment'].get_values();\n        upper = Math.floor(upper);\n        scrollview._dtpFadeSize = upper > pageSize ? this._delegate.iconSize : 0;\n\n        if (this._currentBackgroundColor !== panel.dynamicTransparency.currentBackgroundColor) {\n            this._currentBackgroundColor = panel.dynamicTransparency.currentBackgroundColor;\n            let gradientStyle = 'background-gradient-start: ' + this._currentBackgroundColor +\n                                'background-gradient-direction: ' + orientation;\n\n            leftFade.set_style(gradientStyle);\n            rightFade.set_style(gradientStyle);\n        }\n        \n        childBox[panel.varCoord.c2] = childBox[panel.varCoord.c1] + (value > 0 ? scrollview._dtpFadeSize : 0);\n        leftFade.allocate(childBox);\n\n        childBox[panel.varCoord.c1] = box[panel.varCoord.c2] - (value + pageSize < upper ? scrollview._dtpFadeSize : 0);\n        childBox[panel.varCoord.c2] = box[panel.varCoord.c2];\n        rightFade.allocate(childBox);\n    }\n\n    // We want to request the natural size of all our children\n    // as our natural width, so we chain up to StWidget (which\n    // then calls BoxLayout)\n    vfunc_get_preferred_width(forHeight) {\n        let [, natWidth] = St.Widget.prototype.vfunc_get_preferred_width.call(this, forHeight);\n        \n        return [0, natWidth];\n    }\n\n    vfunc_get_preferred_height(forWidth) {\n        let [, natHeight] = St.Widget.prototype.vfunc_get_preferred_height.call(this, forWidth);\n        \n        return [0, natHeight];\n    }\n});\n\n/* This class is a fork of the upstream dash class (ui.dash.js)\n *\n * Summary of changes:\n * - disconnect global signals adding a destroy method;\n * - play animations even when not in overview mode\n * - set a maximum icon size\n * - show running and/or favorite applications\n * - emit a custom signal when an app icon is added\n * - Add scrollview\n *   Ensure actor is visible on keyfocus inside the scrollview\n * - add 128px icon size, might be useful for hidpi display\n * - Sync minimization application target position.\n */\n\nexport const Taskbar = class extends EventEmitter {\n\n    constructor(panel) {\n        super();\n\n        this.dtpPanel = panel;\n        \n        // start at smallest size due to running indicator drawing area expanding but not shrinking\n        this.iconSize = 16;\n\n        this._shownInitially = false;\n\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._timeoutsHandler = new Utils.TimeoutsHandler();\n\n        this._labelShowing = false;\n        this.fullScrollView = 0;\n\n        let isVertical = panel.checkIfVertical();\n\n        this._box = new St.BoxLayout({ vertical: isVertical,\n                                       clip_to_allocation: false,\n                                       x_align: Clutter.ActorAlign.START,\n                                       y_align: Clutter.ActorAlign.START });\n\n        this._container = new TaskbarActor(this);\n        this._scrollView = new St.ScrollView({ name: 'dashtopanelScrollview',\n                                               hscrollbar_policy: St.PolicyType.NEVER,\n                                               vscrollbar_policy: St.PolicyType.NEVER,\n                                               enable_mouse_scrolling: true });\n\n        this._scrollView.connect('leave-event', this._onLeaveEvent.bind(this));\n        this._scrollView.connect('motion-event', this._onMotionEvent.bind(this));\n        this._scrollView.connect('scroll-event', this._onScrollEvent.bind(this));\n        this._scrollView.add_child(this._box);\n\n        this._showAppsIconWrapper = panel.showAppsIconWrapper;\n        this._showAppsIconWrapper.connect('menu-state-changed', (showAppsIconWrapper, opened) => {\n            this._itemMenuStateChanged(showAppsIconWrapper, opened);\n        });\n        // an instance of the showAppsIcon class is encapsulated in the wrapper\n        this._showAppsIcon = this._showAppsIconWrapper.realShowAppsIcon;\n        this.showAppsButton = this._showAppsIcon.toggleButton;\n\n        if (isVertical) {\n            this.showAppsButton.set_width(panel.geom.w);\n        }\n\n        this.showAppsButton.connect('notify::checked', this._onShowAppsButtonToggled.bind(this));\n\n        this.showAppsButton.checked = (SearchController._showAppsButton) ? SearchController._showAppsButton.checked : false;\n\n        this._showAppsIcon.childScale = 1;\n        this._showAppsIcon.childOpacity = 255;\n        this._showAppsIcon.icon.setIconSize(this.iconSize);\n        this._hookUpLabel(this._showAppsIcon, this._showAppsIconWrapper);\n\n        this._container.add_child(new St.Widget({ width: 0, reactive: false }));\n        this._container.add_child(this._scrollView);\n        \n        let orientation = panel.getOrientation();\n        let fadeStyle = 'background-gradient-direction:' + orientation;\n        let fade1 = new St.Widget({ style_class: 'scrollview-fade', reactive: false });\n        let fade2 = new St.Widget({ style_class: 'scrollview-fade', \n                                    reactive: false,  \n                                    pivot_point: new Graphene.Point({ x: .5, y: .5 }), \n                                    rotation_angle_z: 180 });\n\n        fade1.set_style(fadeStyle);\n        fade2.set_style(fadeStyle);\n\n        this._container.add_child(fade1);\n        this._container.add_child(fade2);\n\n        this.previewMenu = new WindowPreview.PreviewMenu(panel);\n        this.previewMenu.enable();\n\n        let rtl = Clutter.get_default_text_direction() == Clutter.TextDirection.RTL;\n        this.actor = new St.Bin({\n            child: this._container,\n            y_align: Clutter.ActorAlign.START,\n            x_align: rtl ? Clutter.ActorAlign.END : Clutter.ActorAlign.START\n        });\n\n        const adjustment = this._scrollView[orientation[0] + 'adjustment'];\n        \n        this._workId = Main.initializeDeferredWork(this._box, this._redisplay.bind(this));\n\n        this._settings = new Gio.Settings({ schema_id: 'org.gnome.shell' });\n\n        this._appSystem = Shell.AppSystem.get_default();\n\n        this.iconAnimator = new PanelManager.IconAnimator(this.dtpPanel.panel);\n\n        this._signalsHandler.add(\n            [\n                this.dtpPanel.panel,\n                'notify::height',\n                () => this._queueRedisplay()\n            ],\n            [\n                this.dtpPanel.panel,\n                'notify::width',\n                () => this._queueRedisplay()\n            ],\n            [\n                this._appSystem,\n                'installed-changed',\n                () => {\n                    AppFavorites.getAppFavorites().reload();\n                    this._queueRedisplay();\n                }\n            ],\n            [\n                this._appSystem,\n                'app-state-changed',\n                this._queueRedisplay.bind(this)\n            ],\n            [\n                AppFavorites.getAppFavorites(),\n                'changed',\n                this._queueRedisplay.bind(this)\n            ],\n            [\n                global.window_manager,\n                'switch-workspace', \n                () => this._connectWorkspaceSignals()\n            ],\n            [\n                Utils.DisplayWrapper.getScreen(),\n                [\n                    'window-entered-monitor',\n                    'window-left-monitor'\n                ],\n                () => {\n                    if (SETTINGS.get_boolean('isolate-monitors')) {\n                        this._queueRedisplay();\n                    }\n                }\n            ],\n            [\n                Main.overview,\n                'item-drag-begin',\n                this._onDragBegin.bind(this)\n            ],\n            [\n                Main.overview,\n                'item-drag-end',\n                this._onDragEnd.bind(this)\n            ],\n            [\n                Main.overview,\n                'item-drag-cancelled',\n                this._onDragCancelled.bind(this)\n            ],\n            [\n                // Ensure the ShowAppsButton status is kept in sync\n                SearchController._showAppsButton,\n                'notify::checked',\n                this._syncShowAppsButtonToggled.bind(this)\n            ],\n            [\n                SETTINGS,\n                [\n                    'changed::dot-size',\n                    'changed::show-favorites',\n                    'changed::show-running-apps',\n                    'changed::show-favorites-all-monitors'\n                ],\n                () => {\n                    setAttributes()\n                    this._redisplay()\n                }\n            ],\n            [\n                SETTINGS,\n                'changed::group-apps',\n                () => {\n                    setAttributes()\n                    this._connectWorkspaceSignals();\n                }\n            ],\n            [\n                SETTINGS,\n                [\n                    'changed::appicon-style',\n                    'changed::group-apps-use-launchers',\n                    'changed::taskbar-locked'\n                ],\n                () => {\n                    setAttributes()\n                    this.resetAppIcons()\n                }\n            ],\n            [\n                adjustment,\n                [\n                    'notify::upper',\n                    'notify::pageSize'\n                ],\n                () => this._onScrollSizeChange(adjustment)\n            ]\n        );\n\n        let setAttributes = () => {\n            this.isGroupApps = SETTINGS.get_boolean('group-apps');\n            this.usingLaunchers = !this.isGroupApps && SETTINGS.get_boolean('group-apps-use-launchers');\n            this.showFavorites = SETTINGS.get_boolean('show-favorites') && \n                                 (this.dtpPanel.isPrimary || SETTINGS.get_boolean('show-favorites-all-monitors'))\n            this.showRunningApps = SETTINGS.get_boolean('show-running-apps')\n            this.allowSplitApps = this.usingLaunchers || (!this.isGroupApps && !this.showFavorites)\n        }\n\n        setAttributes()\n\n        this._onScrollSizeChange(adjustment);\n        this._connectWorkspaceSignals();\n    }\n\n    destroy() {\n        if (this._waitIdleId) {\n            GLib.source_remove(this._waitIdleId);\n            this._waitIdleId = 0;\n        }\n\n        this._timeoutsHandler.destroy();\n        this.iconAnimator.destroy();\n\n        this._signalsHandler.destroy();\n        this._signalsHandler = 0;\n\n        this._container.destroy();\n        \n        this.previewMenu.disable();\n        this.previewMenu.destroy();\n\n        this._disconnectWorkspaceSignals();\n    }\n\n    _dropIconAnimations() {\n        this._getTaskbarIcons().forEach(item => {\n            item.raise(0);\n            item.stretch(0);\n        });\n    }\n\n    _updateIconAnimations(pointerX, pointerY) {\n        this._iconAnimationTimestamp = Date.now();\n        let type = iconAnimationSettings.type;\n\n        if (!pointerX || !pointerY)\n            [pointerX, pointerY] = global.get_pointer();\n\n        this._getTaskbarIcons().forEach(item => {\n            let [x, y] = item.get_transformed_position();\n            let [width, height] = item.get_transformed_size();\n            let [centerX, centerY] = [x + width / 2, y + height / 2];\n            let size = this._box.vertical ? height : width;\n            let difference = this._box.vertical ? pointerY - centerY : pointerX - centerX;\n            let distance = Math.abs(difference);\n            let maxDistance = (iconAnimationSettings.extent / 2) * size;\n\n            if (type == 'PLANK') {\n                // Make the position stable for items that are far from the pointer.\n                let translation = distance <= maxDistance ?\n                                  distance / (2 + 8 * distance / maxDistance) :\n                                  // the previous expression with distance = maxDistance\n                                  maxDistance / 10;\n\n                if (difference > 0)\n                    translation *= -1;\n\n                item.stretch(translation);\n            }\n\n            if (distance <= maxDistance) {\n                let level = (maxDistance - distance) / maxDistance;\n                level = Math.pow(level, iconAnimationSettings.convexity);\n                item.raise(level);\n            } else {\n                item.raise(0);\n            }\n        });\n    }\n\n    _onLeaveEvent(actor) {\n        let [stageX, stageY] = global.get_pointer();\n        let [success, x, y] = actor.transform_stage_point(stageX, stageY);\n        if (success && !actor.allocation.contains(x, y) && (iconAnimationSettings.type == 'RIPPLE' || iconAnimationSettings.type == 'PLANK'))\n            this._dropIconAnimations();\n\n        return Clutter.EVENT_PROPAGATE;\n    }\n\n    _onMotionEvent(actor_, event) {\n        if (iconAnimationSettings.type == 'RIPPLE' || iconAnimationSettings.type == 'PLANK') {\n            let timestamp = Date.now();\n            if (!this._iconAnimationTimestamp ||\n                (timestamp - this._iconAnimationTimestamp >= iconAnimationSettings.duration / 2)) {\n                let [pointerX, pointerY] = event.get_coords();\n                this._updateIconAnimations(pointerX, pointerY);\n            }\n        }\n\n        return Clutter.EVENT_PROPAGATE;\n    }\n\n    _onScrollEvent(actor, event) {\n\n        let orientation = this.dtpPanel.getOrientation();\n\n        // reset timeout to avid conflicts with the mousehover event\n        this._timeoutsHandler.add([T1, 0,\n            () => this._swiping = false\n        ]);\n\n        // Skip to avoid double events mouse\n        if (event.is_pointer_emulated())\n            return Clutter.EVENT_STOP;\n\n        let adjustment, delta;\n\n        adjustment = this._scrollView[orientation[0] + 'adjustment'];\n\n        let increment = adjustment.step_increment;\n\n        switch ( event.get_scroll_direction() ) {\n        case Clutter.ScrollDirection.UP:\n        case Clutter.ScrollDirection.LEFT:\n            delta = -increment;\n            break;\n        case Clutter.ScrollDirection.DOWN:\n        case Clutter.ScrollDirection.RIGHT:\n            delta = +increment;\n            break;\n        case Clutter.ScrollDirection.SMOOTH:\n            let [dx, dy] = event.get_scroll_delta();\n            delta = dy*increment;\n            delta += dx*increment;\n            break;\n\n        }\n\n        adjustment.set_value(adjustment.get_value() + delta);\n\n        return Clutter.EVENT_STOP;\n\n    }\n\n    _onScrollSizeChange(adjustment) {\n        // Update minimization animation target position on scrollview change.\n        this._updateAppIcons();\n\n        // When applications are ungrouped and there is some empty space on the horizontal taskbar,\n        // force a fixed label width to prevent the icons from \"wiggling\" when an animation runs\n        // (adding or removing an icon). When the taskbar is full, revert to a dynamic label width\n        // to allow them to resize and make room for new icons.\n        if (!this.dtpPanel.checkIfVertical() && !this.isGroupApps) {\n            let initial = this.fullScrollView;\n\n            if (!this.fullScrollView && Math.floor(adjustment.upper) > adjustment.page_size) {\n                this.fullScrollView = adjustment.page_size;\n            } else if (adjustment.page_size < this.fullScrollView) {\n                this.fullScrollView = 0;\n            }\n\n            if (initial != this.fullScrollView && !this._waitIdleId) {\n                this._waitIdleId = GLib.idle_add(GLib.PRIORITY_DEFAULT_IDLE, () => {\n                    this._getAppIcons().forEach(a => a.updateTitleStyle())\n                    this._waitIdleId = 0;\n\n                    return GLib.SOURCE_REMOVE;\n                });\n            }\n        }\n    }\n\n    _onDragBegin() {\n        this._dragCancelled = false;\n        this._dragMonitor = {\n            dragMotion: this._onDragMotion.bind(this)\n        };\n        DND.addDragMonitor(this._dragMonitor);\n\n        if (this._box.get_n_children() == 0) {\n            this._emptyDropTarget = new Dash.EmptyDropTargetItem();\n            this._box.insert_child_at_index(this._emptyDropTarget, 0);\n            this._emptyDropTarget.show(true);\n        }\n\n        this._toggleFavoriteHighlight(true);\n    }\n\n    _onDragCancelled() {\n        this._dragCancelled = true;\n\n        if (this._dragInfo) {\n            this._box.set_child_at_index(this._dragInfo[1]._dashItemContainer, this._dragInfo[0]);\n        }\n        \n        this._endDrag();\n    }\n\n    _onDragEnd() {\n        if (this._dragCancelled)\n            return;\n\n        this._endDrag();\n    }\n\n    _endDrag() {\n        if (this._dragInfo && this._dragInfo[1]._dashItemContainer instanceof DragPlaceholderItem) {\n            this._box.remove_child(this._dragInfo[1]._dashItemContainer);\n            this._dragInfo[1]._dashItemContainer.destroy();\n            delete this._dragInfo[1]._dashItemContainer;\n        }\n\n        this._dragInfo = null;\n        this._clearEmptyDropTarget();\n        this._showAppsIcon.setDragApp(null);\n        DND.removeDragMonitor(this._dragMonitor);\n        \n        this._dragMonitor = null;\n        this.emit('end-drag');\n        \n        this._toggleFavoriteHighlight();\n    }\n\n    _onDragMotion(dragEvent) {\n        let app = Dash.Dash.getAppFromSource(dragEvent.source);\n        if (app == null)\n            return DND.DragMotionResult.CONTINUE;\n\n        let showAppsHovered = this._showAppsIcon.contains(dragEvent.targetActor);\n\n        if (showAppsHovered)\n            this._showAppsIcon.setDragApp(app);\n        else\n            this._showAppsIcon.setDragApp(null);\n\n        return DND.DragMotionResult.CONTINUE;\n    }\n\n    _toggleFavoriteHighlight(show) {\n        let appFavorites = AppFavorites.getAppFavorites();\n        let cssFuncName = (show ? 'add' : 'remove') + '_style_class_name';\n        \n        if (this.showFavorites)\n            this._getAppIcons().filter(appIcon => (this.usingLaunchers && appIcon.isLauncher) || \n                                                  (!this.usingLaunchers && appFavorites.isFavorite(appIcon.app.get_id())))\n                               .forEach(fav => fav._container[cssFuncName]('favorite'));\n    }\n\n    handleIsolatedWorkspaceSwitch() {\n        this._shownInitially = this.isGroupApps;\n        this._queueRedisplay();\n    }\n\n    _connectWorkspaceSignals() {\n        this._disconnectWorkspaceSignals();\n\n        this._lastWorkspace = Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace();\n\n        this._workspaceWindowAddedId = this._lastWorkspace.connect('window-added', () => this._queueRedisplay());\n        this._workspaceWindowRemovedId = this._lastWorkspace.connect('window-removed', () => this._queueRedisplay());\n    }\n\n    _disconnectWorkspaceSignals() {\n        if (this._lastWorkspace) {\n            this._lastWorkspace.disconnect(this._workspaceWindowAddedId);\n            this._lastWorkspace.disconnect(this._workspaceWindowRemovedId);\n\n            this._lastWorkspace = null;\n        }\n    }\n\n    _queueRedisplay() {\n        Main.queueDeferredWork(this._workId);\n    }\n\n    _hookUpLabel(item, syncHandler) {\n        item.child.connect('notify::hover', () => {\n            this._syncLabel(item, syncHandler);\n        });\n\n        syncHandler.connect('sync-tooltip', () => {\n            this._syncLabel(item, syncHandler);\n        });\n    }\n\n    _createAppItem(app, window, isLauncher) {\n        let appIcon = new AppIcons.TaskbarAppIcon(\n            {\n                app, \n                window,\n                isLauncher\n            },\n            this.dtpPanel,\n            { \n                setSizeManually: true,\n                showLabel: false,\n                isDraggable: !SETTINGS.get_boolean('taskbar-locked'),\n            },\n            this.previewMenu,\n            this.iconAnimator\n        );\n\n        if (appIcon._draggable) {\n            appIcon._draggable.connect('drag-begin',\n                                       () => {\n                                           appIcon.opacity = 0;\n                                           appIcon.isDragged = 1;\n                                           this._dropIconAnimations();\n                                       });\n            appIcon._draggable.connect('drag-end',\n                                       () => {\n                                           appIcon.opacity = 255;\n                                           delete appIcon.isDragged;\n                                           this._updateAppIcons();\n                                       });\n        }\n\n        appIcon.connect('menu-state-changed',\n                        (appIcon, opened) => {\n                            this._itemMenuStateChanged(item, opened);\n                        });\n\n        let item = new TaskbarItemContainer();\n\n        item._dtpPanel = this.dtpPanel\n        extendDashItemContainer(item);\n\n        item.setChild(appIcon);\n        appIcon._dashItemContainer = item;\n\n        appIcon.connect('notify::hover', () => {\n            if (appIcon.hover){\n                this._timeoutsHandler.add([T1, 100, \n                    () => Utils.ensureActorVisibleInScrollView(this._scrollView, appIcon, this._scrollView._dtpFadeSize)\n                ])\n\n                if (!appIcon.isDragged && iconAnimationSettings.type == 'SIMPLE')\n                    appIcon.get_parent().raise(1);\n                else if (!appIcon.isDragged && (iconAnimationSettings.type == 'RIPPLE' || iconAnimationSettings.type == 'PLANK'))\n                    this._updateIconAnimations();\n            } else {\n                this._timeoutsHandler.remove(T1)\n\n                if (!appIcon.isDragged && iconAnimationSettings.type == 'SIMPLE')\n                    appIcon.get_parent().raise(0);\n            }\n        });\n\n        appIcon.connect('clicked',\n            (actor) => {\n                Utils.ensureActorVisibleInScrollView(this._scrollView, actor, this._scrollView._dtpFadeSize);\n        });\n\n        appIcon.connect('key-focus-in', (actor) => {\n                let [x_shift, y_shift] = Utils.ensureActorVisibleInScrollView(this._scrollView, actor, this._scrollView._dtpFadeSize);\n\n                // This signal is triggered also by mouse click. The popup menu is opened at the original\n                // coordinates. Thus correct for the shift which is going to be applied to the scrollview.\n                if (appIcon._menu) {\n                    appIcon._menu._boxPointer.xOffset = -x_shift;\n                    appIcon._menu._boxPointer.yOffset = -y_shift;\n                }\n        });\n        \n        // Override default AppIcon label_actor, now the\n        // accessible_name is set at DashItemContainer.setLabelText\n        appIcon.label_actor = null;\n        item.setLabelText(app.get_name());\n\n        appIcon.icon.setIconSize(this.iconSize);\n        this._hookUpLabel(item, appIcon);\n\n        return item;\n    }\n\n    // Return an array with the \"proper\" appIcons currently in the taskbar\n    _getAppIcons() {\n        // Only consider children which are \"proper\" icons and which are not\n        // animating out (which means they will be destroyed at the end of\n        // the animation)\n        return this._getTaskbarIcons().map(function(actor){\n            return actor.child._delegate;\n        });\n    }\n\n    _getTaskbarIcons(includeAnimated) {\n        return this._box.get_children().filter(function(actor) {\n            return actor.child &&\n                   actor.child._delegate &&\n                   actor.child._delegate.icon &&\n                   (includeAnimated || !actor.animatingOut);\n        });\n    }\n\n    _updateAppIcons() {\n        let appIcons = this._getAppIcons();\n\n        appIcons.filter(icon => icon.constructor === AppIcons.TaskbarAppIcon).forEach(icon => {\n            icon.updateIcon();\n        });\n    }\n\n    _itemMenuStateChanged(item, opened) {\n        // When the menu closes, it calls sync_hover, which means\n        // that the notify::hover handler does everything we need to.\n        if (opened) {\n            this._timeoutsHandler.remove(T2)\n\n            item.hideLabel();\n        } else {\n            // I want to listen from outside when a menu is closed. I used to\n            // add a custom signal to the appIcon, since gnome 3.8 the signal\n            // calling this callback was added upstream.\n            this.emit('menu-closed');\n\n            // The icon menu grabs the events and, once it is closed, the pointer is maybe\n            // no longer over the taskbar and the animations are not dropped.\n            if (iconAnimationSettings.type == 'RIPPLE' || iconAnimationSettings.type == 'PLANK') {\n                this._scrollView.sync_hover();\n                if (!this._scrollView.hover)\n                    this._dropIconAnimations();\n            }\n        }\n    }\n\n    _syncLabel(item, syncHandler) {\n        let shouldShow = syncHandler ? syncHandler.shouldShowTooltip() : item.child.get_hover();\n\n        if (shouldShow) {\n            if (!this._timeoutsHandler.getId(T2)) {\n                let timeout = this._labelShowing ? 0 : DASH_ITEM_HOVER_TIMEOUT;\n\n                this._timeoutsHandler.add([T2, timeout,\n                    () => {\n                        this._labelShowing = true;\n                        item.showLabel();\n                    }\n                ]);\n\n                this._timeoutsHandler.remove(T3)\n            }\n        } else {\n            this._timeoutsHandler.remove(T2)\n\n            item.hideLabel();\n            if (this._labelShowing) {\n                this._timeoutsHandler.add([T3, DASH_ITEM_HOVER_TIMEOUT,\n                    () => this._labelShowing = false\n                ]);\n            }\n        }\n    }\n\n    _adjustIconSize() {\n        const thisMonitorIndex = this.dtpPanel.monitor.index;\n        let panelSize = PanelSettings.getPanelSize(SETTINGS, thisMonitorIndex);\n        let availSize = panelSize - SETTINGS.get_int('appicon-padding') * 2;\n        let minIconSize = MIN_ICON_SIZE + panelSize % 2;\n\n        if (availSize == this.iconSize)\n            return;\n\n        if (availSize < minIconSize) {\n            availSize = minIconSize;\n        }\n        \n        // For the icon size, we only consider children which are \"proper\"\n        // icons and which are not animating out (which means they will be \n        // destroyed at the end of the animation)\n        let iconChildren = this._getTaskbarIcons().concat([this._showAppsIcon]);\n        let scale = this.iconSize / availSize;\n        \n        this.iconSize = availSize;\n\n        for (let i = 0; i < iconChildren.length; i++) {\n            let icon = iconChildren[i].child._delegate.icon;\n\n            // Set the new size immediately, to keep the icons' sizes\n            // in sync with this.iconSize\n            icon.setIconSize(this.iconSize);\n\n            // Don't animate the icon size change when the overview\n            // is transitioning, or when initially filling\n            // the taskbar\n            if (Main.overview.animationInProgress ||\n                !this._shownInitially)\n                continue;\n\n            let [targetWidth, targetHeight] = icon.icon.get_size();\n\n            // Scale the icon's texture to the previous size and\n            // tween to the new size\n            icon.icon.set_size(icon.icon.width * scale, icon.icon.height * scale);\n\n            Utils.animate(icon.icon,\n                        { width: targetWidth,\n                            height: targetHeight,\n                            time: DASH_ANIMATION_TIME,\n                            transition: 'easeOutQuad',\n                        });\n        }\n    }\n\n    sortAppsCompareFunction(appA, appB) {\n        return getAppStableSequence(appA, this.dtpPanel.monitor) - \n               getAppStableSequence(appB, this.dtpPanel.monitor);\n    }\n\n    getAppInfos() {\n        //get the user's favorite apps\n        let favoriteApps = this.showFavorites ? AppFavorites.getAppFavorites().getFavorites() : [];\n\n        //find the apps that should be in the taskbar: the favorites first, then add the running apps\n        // When using isolation, we filter out apps that have no windows in\n        // the current workspace (this check is done in AppIcons.getInterestingWindows)\n        let runningApps = this.showRunningApps ? this._getRunningApps().sort(this.sortAppsCompareFunction.bind(this)) : [];\n\n        if (this.allowSplitApps) {\n            return this._createAppInfos(favoriteApps, [], true)\n                       .concat(this._createAppInfos(runningApps)\n                       .filter(appInfo => appInfo.windows.length));\n        } else {\n            return this._createAppInfos(favoriteApps.concat(runningApps.filter(app => favoriteApps.indexOf(app) < 0)))\n                       .filter(appInfo => appInfo.windows.length || favoriteApps.indexOf(appInfo.app) >= 0);\n        }\n    }\n\n    _redisplay() {\n        if (!this._signalsHandler) {\n            return;\n        }\n\n        //get the currently displayed appIcons\n        let currentAppIcons = this._getTaskbarIcons();\n        let expectedAppInfos = this.getAppInfos();\n\n        //remove the appIcons which are not in the expected apps list\n        for (let i = currentAppIcons.length - 1; i > -1; --i) {\n            let appIcon = currentAppIcons[i].child._delegate;\n            let appIndex = Utils.findIndex(expectedAppInfos, appInfo => appInfo.app == appIcon.app &&\n                                                                        (!this.allowSplitApps || this.isGroupApps || appInfo.windows[0] == appIcon.window) &&\n                                                                        appInfo.isLauncher == appIcon.isLauncher);\n\n            if (appIndex < 0 || \n                (appIcon.window && (this.isGroupApps || expectedAppInfos[appIndex].windows.indexOf(appIcon.window) < 0)) ||\n                (!appIcon.window && !appIcon.isLauncher && \n                 !this.isGroupApps && expectedAppInfos[appIndex].windows.length)) {\n                currentAppIcons[i][this._shownInitially ? 'animateOutAndDestroy' : 'destroy']();\n                currentAppIcons.splice(i, 1);\n            }\n        }\n\n        //if needed, reorder the existing appIcons and create the missing ones\n        let currentPosition = 0;\n        for (let i = 0, l = expectedAppInfos.length; i < l; ++i) {\n            let neededAppIcons = this.isGroupApps || !expectedAppInfos[i].windows.length ? \n                                 [{ app: expectedAppInfos[i].app, window: null, isLauncher: expectedAppInfos[i].isLauncher }] : \n                                 expectedAppInfos[i].windows.map(window => ({ app: expectedAppInfos[i].app, window: window, isLauncher: false }));\n                                 \n            for (let j = 0, ll = neededAppIcons.length; j < ll; ++j) {\n                //check if the icon already exists\n                let matchingAppIconIndex = Utils.findIndex(currentAppIcons, appIcon => appIcon.child._delegate.app == neededAppIcons[j].app && \n                                                                                       appIcon.child._delegate.window == neededAppIcons[j].window);\n\n                if (matchingAppIconIndex > 0 && matchingAppIconIndex != currentPosition) {\n                    //moved icon, reposition it\n                    this._box.remove_child(currentAppIcons[matchingAppIconIndex]);\n                    this._box.insert_child_at_index(currentAppIcons[matchingAppIconIndex], currentPosition);\n                } else if (matchingAppIconIndex < 0) {\n                    //the icon doesn't exist yet, create a new one\n                    let newAppIcon = this._createAppItem(neededAppIcons[j].app, neededAppIcons[j].window, neededAppIcons[j].isLauncher);\n                    \n                    this._box.insert_child_at_index(newAppIcon, currentPosition);\n                    currentAppIcons.splice(currentPosition, 0, newAppIcon);\n                    \n                    // Skip animations on first run when adding the initial set\n                    // of items, to avoid all items zooming in at once\n                    newAppIcon.show(this._shownInitially);\n                }\n\n                ++currentPosition;\n            }\n        }\n\n        this._adjustIconSize();\n\n        // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=692744\n        // Without it, StBoxLayout may use a stale size cache\n        this._box.queue_relayout();\n\n        // This is required for icon reordering when the scrollview is used.\n        this._updateAppIcons();\n\n        // This will update the size, and the corresponding number for each icon on the primary panel\n        if (this.dtpPanel.isPrimary) {\n            this._updateNumberOverlay();\n        }\n\n        this._shownInitially = true;\n    }\n\n    _getRunningApps() {\n        let tracker = Shell.WindowTracker.get_default();\n        let windows = global.get_window_actors();\n        let apps = [];\n\n        for (let i = 0, l = windows.length; i < l; ++i) {\n            let app = tracker.get_window_app(windows[i].metaWindow);\n\n            if (app && apps.indexOf(app) < 0) {\n                apps.push(app);\n            }\n        }\n        \n        return apps;\n    }\n\n    _createAppInfos(apps, defaultWindows, defaultIsLauncher) {\n        if (this.allowSplitApps && !defaultIsLauncher) {\n            let separateApps = []\n            \n            if (apps.length) {\n                let tracker = Shell.WindowTracker.get_default();\n                let windows = AppIcons.getInterestingWindows(null, this.dtpPanel.monitor)\n                                      .sort(sortWindowsCompareFunction)\n\n                windows.forEach(w => {\n                    let windowApp = tracker.get_window_app(w)\n\n                    if (apps.indexOf(windowApp) >= 0)\n                        separateApps.push({\n                            app: windowApp, \n                            isLauncher: false, \n                            windows: [w]\n                        })\n                })\n            }\n\n            return separateApps\n        }\n\n        return apps.map(app => ({ \n            app: app, \n            isLauncher: defaultIsLauncher || false,\n            windows: defaultWindows || AppIcons.getInterestingWindows(app, this.dtpPanel.monitor)\n                                               .sort(sortWindowsCompareFunction)\n        }));\n    }\n\n    // Reset the displayed apps icon to mantain the correct order\n    resetAppIcons (geometryChange) {\n        let children = this._getTaskbarIcons(true);\n\n        for (let i = 0; i < children.length; i++) {\n            let item = children[i];\n            item.destroy();\n        }\n\n        // to avoid ugly animations, just suppress them like when taskbar is first loaded.\n        this._shownInitially = false;\n        this._redisplay();\n\n        if (geometryChange && this.dtpPanel.checkIfVertical()) {\n            this.previewMenu._updateClip();\n        }\n    }\n\n    _updateNumberOverlay() {\n        let seenApps = {};\n        let counter = 0;\n\n        this._getAppIcons().forEach(icon => {\n            if (!seenApps[icon.app] || this.allowSplitApps) {\n                seenApps[icon.app] = 1;\n                counter++;\n            }\n\n            if (counter <= 10) {\n                icon.setNumberOverlay(counter == 10 ? 0 : counter);\n            } else {\n                // No overlay after 10\n                icon.setNumberOverlay(-1);\n            }\n\n            icon.updateHotkeyNumberOverlay();\n        });\n\n        if (SETTINGS.get_boolean('hot-keys') &&\n            SETTINGS.get_string('hotkeys-overlay-combo') === 'ALWAYS')\n            this.toggleNumberOverlay(true);\n    }\n\n    toggleNumberOverlay(activate) {\n        let appIcons = this._getAppIcons();\n        appIcons.forEach(function(icon) {\n            icon.toggleNumberOverlay(activate);\n        });\n    }\n\n    _clearEmptyDropTarget() {\n        if (this._emptyDropTarget) {\n            this._emptyDropTarget.animateOutAndDestroy();\n            this._emptyDropTarget = null;\n        }\n    }\n\n    handleDragOver(source, actor, x, y, time) {\n        if (source == Main.xdndHandler)\n            return DND.DragMotionResult.CONTINUE;\n\n        // Don't allow favoriting of transient apps\n        if (source.app == null || source.app.is_window_backed())\n            return DND.DragMotionResult.NO_DROP;\n\n        if (!this._settings.is_writable('favorite-apps'))\n            return DND.DragMotionResult.NO_DROP;\n\n        let isVertical = this.dtpPanel.checkIfVertical();\n\n        if (!this._box.contains(source) && !source._dashItemContainer) {\n            //not an appIcon of the taskbar, probably from the applications view\n            source._dashItemContainer = new DragPlaceholderItem(source, this.iconSize, isVertical);\n            this._box.insert_child_above(source._dashItemContainer, null);\n        }\n\n        let sizeProp = isVertical ? 'height' : 'width';\n        let posProp = isVertical ? 'y' : 'x';\n        let pos = isVertical ? y : x;\n\n        let currentAppIcons = this._getAppIcons();\n        let sourceIndex = currentAppIcons.indexOf(source);\n        let hoveredIndex = Utils.findIndex(currentAppIcons, \n                                           appIcon => pos >= appIcon._dashItemContainer[posProp] && \n                                                      pos <= (appIcon._dashItemContainer[posProp] + appIcon._dashItemContainer[sizeProp]));\n        \n        if (!this._dragInfo) {\n            this._dragInfo = [sourceIndex, source];\n        }\n\n        if (hoveredIndex >= 0) {\n            let isLeft = pos < currentAppIcons[hoveredIndex]._dashItemContainer[posProp] + currentAppIcons[hoveredIndex]._dashItemContainer[sizeProp] * .5;\n            let prevIcon = currentAppIcons[hoveredIndex - 1]\n            let nextIcon = currentAppIcons[hoveredIndex + 1]\n\n            // Don't allow positioning before or after self and between icons of same app if ungrouped and showing favorites\n            if (!(hoveredIndex === sourceIndex ||\n                  (isLeft && hoveredIndex - 1 == sourceIndex) ||\n                  (!this.allowSplitApps && isLeft && hoveredIndex - 1 >= 0 && source.app != prevIcon.app && \n                   prevIcon.app == currentAppIcons[hoveredIndex].app) ||\n                  (!isLeft && hoveredIndex + 1 == sourceIndex) ||\n                  (!this.allowSplitApps && !isLeft && hoveredIndex + 1 < currentAppIcons.length && source.app != nextIcon.app && \n                   nextIcon.app == currentAppIcons[hoveredIndex].app))) {\n                    this._box.set_child_at_index(source._dashItemContainer, hoveredIndex);\n    \n                    // Ensure the next and previous icon are visible when moving the icon\n                    // (I assume there's room for both of them)\n                    if (hoveredIndex > 1)\n                        Utils.ensureActorVisibleInScrollView(this._scrollView, this._box.get_children()[hoveredIndex-1], this._scrollView._dtpFadeSize);\n                    if (hoveredIndex < this._box.get_children().length-1)\n                        Utils.ensureActorVisibleInScrollView(this._scrollView, this._box.get_children()[hoveredIndex+1], this._scrollView._dtpFadeSize);\n            }\n        }\n        \n        return this._dragInfo[0] !== sourceIndex ? DND.DragMotionResult.MOVE_DROP : DND.DragMotionResult.CONTINUE;\n    }\n\n    // Draggable target interface\n    acceptDrop (source, actor, x, y, time) {\n        // Don't allow favoriting of transient apps\n        if (!this._dragInfo || !source.app || source.app.is_window_backed() || \n            !this._settings.is_writable('favorite-apps')) {\n            return false;\n        }\n\n        let appIcons = this._getAppIcons();\n        let sourceIndex = appIcons.indexOf(source);\n        let usingLaunchers = !this.isGroupApps && this.usingLaunchers;\n\n        // dragging the icon to its original position\n        if (this._dragInfo[0] === sourceIndex) {\n            return true;\n        }\n\n        let appFavorites = AppFavorites.getAppFavorites();\n        let sourceAppId = source.app.get_id();\n        let appIsFavorite = this.showFavorites && appFavorites.isFavorite(sourceAppId);\n        let replacingIndex = sourceIndex + (sourceIndex > this._dragInfo[0] ? -1 : 1);\n        let favoriteIndex = replacingIndex >= 0 ? appFavorites.getFavorites().indexOf(appIcons[replacingIndex].app) : 0;\n        let sameApps = this.allowSplitApps ? [] : appIcons.filter(a => a != source && a.app == source.app);\n        let favoritesCount = 0;\n        let position = 0;\n        let interestingWindows = {};\n        let getAppWindows = app => {\n            if (!interestingWindows[app]) {\n                interestingWindows[app] = AppIcons.getInterestingWindows(app, this.dtpPanel.monitor);\n            }\n\n            let appWindows = interestingWindows[app]; //prevents \"reference to undefined property Symbol.toPrimitive\" warning\n            return appWindows;\n        };\n        \n        if (sameApps.length && \n            ((!appIcons[sourceIndex - 1] || appIcons[sourceIndex - 1].app !== source.app) && \n             (!appIcons[sourceIndex + 1] || appIcons[sourceIndex + 1].app !== source.app))) {\n            appIcons.splice(appIcons.indexOf(sameApps[0]), sameApps.length);\n            Array.prototype.splice.apply(appIcons, [sourceIndex + 1, 0].concat(sameApps));\n        }\n\n        for (let i = 0, l = appIcons.length; i < l; ++i) {\n            let windows = [];\n            \n            if (!usingLaunchers || (!source.isLauncher && !appIcons[i].isLauncher)) {\n                windows = appIcons[i].window ? [appIcons[i].window] : getAppWindows(appIcons[i].app);\n            }\n\n            windows.forEach(w => w._dtpPosition = position++);\n\n            if (this.showFavorites && \n                ((usingLaunchers && appIcons[i].isLauncher) || \n                 (!usingLaunchers && appFavorites.isFavorite(appIcons[i].app.get_id())))) {\n                ++favoritesCount;\n            }\n        }\n\n        if (sourceIndex < favoritesCount) {\n            if (appIsFavorite) {\n                appFavorites.moveFavoriteToPos(sourceAppId, favoriteIndex);\n            } else {\n                appFavorites.addFavoriteAtPos(sourceAppId, favoriteIndex);\n            }\n        } else if (appIsFavorite && this.showFavorites && (!usingLaunchers || source.isLauncher)) {\n            appFavorites.removeFavorite(sourceAppId);\n        }\n\n        appFavorites.emit('changed');\n\n        return true;\n    }\n\n    _onShowAppsButtonToggled() {\n        // Sync the status of the default appButtons. Only if the two statuses are\n        // different, that means the user interacted with the extension provided\n        // application button, cutomize the behaviour. Otherwise the shell has changed the\n        // status (due to the _syncShowAppsButtonToggled function below) and it\n        // has already performed the desired action.\n        let selector = SearchController;\n\n        if (selector._showAppsButton &&\n            selector._showAppsButton.checked !== this.showAppsButton.checked) {\n            // find visible view\n\n            if (this.showAppsButton.checked) {\n                if (SETTINGS.get_boolean('show-apps-override-escape')) {\n                    //override escape key to return to the desktop when entering the overview using the showapps button\n                    SearchController._onStageKeyPress = function(actor, event) {\n                        if (Main.modalCount == 1 && event.get_key_symbol() === Clutter.KEY_Escape) {\n                            this._searchActive ? this.reset() : Main.overview.hide();\n    \n                            return Clutter.EVENT_STOP;\n                        }\n    \n                        return Object.getPrototypeOf(this)._onStageKeyPress.call(this, actor, event);\n                    };\n\n                    let overviewHiddenId = Main.overview.connect('hidden', () => {\n                        Main.overview.disconnect(overviewHiddenId);\n                        delete SearchController._onStageKeyPress;\n                    });\n                }\n\n                // force exiting overview if needed\n                if (!Main.overview._shown) {\n                    this.forcedOverview = true;\n                }\n\n                //temporarily use as primary the monitor on which the showapps btn was clicked, this is\n                //restored by the panel when exiting the overview\n                this.dtpPanel.panelManager.setFocusedMonitor(this.dtpPanel.monitor);\n\n                // Finally show the overview\n                selector._showAppsButton.checked = true;\n                Main.overview.show(2 /*APP_GRID*/);\n            }\n            else {\n                if (this.forcedOverview) {\n                    // force exiting overview if needed\n                    Main.overview.hide();\n                } else {\n                    selector._showAppsButton.checked = false;\n                }\n\n                this.forcedOverview = false;\n            }\n        }\n    }\n    \n    _syncShowAppsButtonToggled() {\n        let status = SearchController._showAppsButton.checked;\n        if (this.showAppsButton.checked !== status)\n            this.showAppsButton.checked = status;\n    }\n    \n    showShowAppsButton() {\n        this.showAppsButton.visible = true;\n        this.showAppsButton.set_width(-1);\n        this.showAppsButton.set_height(-1);\n    }\n\n    popupFocusedAppSecondaryMenu() {\n        let appIcons = this._getAppIcons();\n        let tracker = Shell.WindowTracker.get_default();\n\n        for(let i in appIcons) {\n            if(appIcons[i].app == tracker.focus_app) {\n                let appIcon = appIcons[i];\n                if(appIcon._menu && appIcon._menu.isOpen)\n                    appIcon._menu.close();\n                else\n                    appIcon.popupMenu();\n\n                appIcon.sync_hover();\n                break;\n            }\n        }\n    }\n};\n\nexport const TaskbarItemContainer = GObject.registerClass({\n\n}, class TaskbarItemContainer extends Dash.DashItemContainer {\n\n    _init() {\n        super._init()\n    }\n\n    vfunc_allocate(box) {\n        if (this.child == null)\n            return;\n\n        this.set_allocation(box);\n\n        let availWidth = box.x2 - box.x1;\n        let availHeight = box.y2 - box.y1;\n        let [minChildWidth, minChildHeight, natChildWidth, natChildHeight] = this.child.get_preferred_size();\n        let [childScaleX, childScaleY] = this.child.get_scale();\n\n        let childWidth = Math.min(natChildWidth * childScaleX, availWidth);\n        let childHeight = Math.min(natChildHeight * childScaleY, availHeight);\n        let childBox = new Clutter.ActorBox();\n\n        childBox.x1 = (availWidth - childWidth) / 2;\n        childBox.y1 = (availHeight - childHeight) / 2;\n        childBox.x2 = childBox.x1 + childWidth;\n        childBox.y2 = childBox.y1 + childHeight;\n\n        this.child.allocate(childBox);\n    }\n\n    // In case appIcon is removed from the taskbar while it is hovered,\n    // restore opacity before dashItemContainer.animateOutAndDestroy does the destroy animation.\n    animateOutAndDestroy() {\n        if (this._raisedClone) {\n            this._raisedClone.source.opacity = 255;\n            this._raisedClone.destroy();\n        }\n\n        super.animateOutAndDestroy();\n    }\n\n    // For ItemShowLabel\n    _getIconAnimationOffset() {\n        if (!SETTINGS.get_boolean('animate-appicon-hover'))\n            return 0;\n\n        let travel = iconAnimationSettings.travel;\n        let zoom = iconAnimationSettings.zoom;\n        return this._dtpPanel.dtpSize * (travel + (zoom - 1) / 2);\n    }\n\n    _updateCloneContainerPosition(cloneContainer) {\n        let [stageX, stageY] = this.get_transformed_position();\n\n        cloneContainer.set_position(\n            stageX - this._dtpPanel.panelBox.translation_x - this.translation_x,\n            stageY - this._dtpPanel.panelBox.translation_y - this.translation_y\n        );\n    }\n\n    _createRaisedClone() {\n        let [width, height] = this.get_transformed_size();\n\n        // \"clone\" of this child (appIcon actor)\n        let cloneButton = this.child._delegate.getCloneButton();\n\n        // \"clone\" of this (taskbarItemContainer)\n        let cloneContainer = new St.Bin({\n            child: cloneButton,\n            width: width, height: height,\n            reactive: false,\n        });\n\n        this._updateCloneContainerPosition(cloneContainer);\n\n        // For the stretch animation\n        let boundProperty = this._dtpPanel.checkIfVertical() ? 'translation_y' : 'translation_x';\n        this.bind_property(boundProperty, cloneContainer, boundProperty, GObject.BindingFlags.SYNC_CREATE);\n\n\n        // The clone follows its source when the taskbar is scrolled.\n        let taskbarScrollView = this.get_parent().get_parent();\n        let adjustment = this._dtpPanel.checkIfVertical() ? taskbarScrollView.get_vadjustment() : taskbarScrollView.get_hadjustment();\n        let adjustmentChangedId = adjustment.connect('notify::value', () => this._updateCloneContainerPosition(cloneContainer));\n\n        // Update clone position when an item is added to / removed from the taskbar.\n        let taskbarBox = this.get_parent();\n        let taskbarBoxAllocationChangedId = taskbarBox.connect('notify::allocation', () => this._updateCloneContainerPosition(cloneContainer));\n\n        // The clone itself\n        this._raisedClone = cloneButton.child;\n        this._raisedClone.connect('destroy', () => {\n            adjustment.disconnect(adjustmentChangedId);\n            taskbarBox.disconnect(taskbarBoxAllocationChangedId);\n            GLib.idle_add(GLib.PRIORITY_DEFAULT_IDLE, () => {\n                cloneContainer.destroy();\n                return GLib.SOURCE_REMOVE;\n            });\n            delete this._raisedClone;\n        });\n\n        this._raisedClone.source.opacity = 0;\n        Main.uiGroup.add_child(cloneContainer);\n    }\n\n    // Animate the clone.\n    // AppIcon actors cannot go outside the taskbar so the animation is done with a clone.\n    // If level is zero, the clone is dropped and destroyed.\n    raise(level) {\n        if (this._raisedClone)\n            Utils.stopAnimations(this._raisedClone);\n        else if (level)\n            this._createRaisedClone();\n        else\n            return;\n\n        let panelPosition = this._dtpPanel.getPosition();\n        let panelElementPositions = this._dtpPanel.panelManager.panelsElementPositions[this._dtpPanel.monitor.index] || Pos.defaults;\n        let taskbarPosition = panelElementPositions.filter(pos => pos.element == 'taskbar')[0].position;\n\n        let vertical = panelPosition == St.Side.LEFT || panelPosition == St.Side.RIGHT;\n        let translationDirection = panelPosition == St.Side.TOP || panelPosition == St.Side.LEFT ? 1 : -1;\n        let rotationDirection;\n        if (panelPosition == St.Side.LEFT || taskbarPosition == Pos.STACKED_TL)\n            rotationDirection = -1;\n        else if (panelPosition == St.Side.RIGHT || taskbarPosition == Pos.STACKED_BR)\n            rotationDirection = 1;\n        else {\n            let items = this.get_parent().get_children();\n            let index = items.indexOf(this);\n            rotationDirection = (index - (items.length - 1) / 2) / ((items.length - 1) / 2);\n        }\n\n        let duration = iconAnimationSettings.duration / 1000;\n        let rotation = iconAnimationSettings.rotation;\n        let travel = iconAnimationSettings.travel;\n        let zoom = iconAnimationSettings.zoom;\n\n        // level is about 1 for the icon that is hovered, less for others.\n        // time depends on the translation to do.\n        let [width, height] = this._raisedClone.source.get_transformed_size();\n        let translationMax = (vertical ? width : height) * (travel + (zoom - 1) / 2);\n        let translationEnd = translationMax * level;\n        let translationDone = vertical ? this._raisedClone.translation_x : this._raisedClone.translation_y;\n        let translationTodo = Math.abs(translationEnd - translationDone);\n        let scale = 1 + (zoom - 1) * level;\n        let rotationAngleZ = rotationDirection * rotation * level;\n        let time = duration * translationTodo / translationMax;\n\n        let options = {\n            scale_x: scale, scale_y: scale,\n            rotation_angle_z: rotationAngleZ,\n            time: time,\n            transition: 'easeOutQuad',\n            onComplete: () => {\n                if (!level) {\n                    this._raisedClone.source.opacity = 255;\n                    this._raisedClone.destroy();\n                    delete this._raisedClone;\n                }\n            }\n        };\n        options[vertical ? 'translation_x' : 'translation_y'] = translationDirection * translationEnd;\n\n        Utils.animate(this._raisedClone, options);\n    }\n\n    // Animate this and cloneContainer, since cloneContainer translation is bound to this.\n    stretch(translation) {\n        let duration = iconAnimationSettings.duration / 1000;\n        let zoom = iconAnimationSettings.zoom;\n        let animatedProperty = this._dtpPanel.checkIfVertical() ? 'translation_y' : 'translation_x';\n        let isShowing = this.opacity != 255 || this.child.opacity != 255;\n\n        if (isShowing) {\n            // Do no stop the animation initiated in DashItemContainer.show.\n            this[animatedProperty] = zoom * translation;\n        } else {\n            let options = {\n                time: duration,\n                transition: 'easeOutQuad',\n            };\n            options[animatedProperty] = zoom * translation;\n\n            Utils.stopAnimations(this);\n            Utils.animate(this, options);\n        }\n    }\n});\n\nconst DragPlaceholderItem = GObject.registerClass({\n}, class DragPlaceholderItem extends St.Widget {\n\n    _init(appIcon, iconSize, isVertical) {\n        super._init({ style: AppIcons.getIconContainerStyle(isVertical), layout_manager: new Clutter.BinLayout() });\n\n        this.child = { _delegate: appIcon };\n\n        this._clone = new Clutter.Clone({ \n            source: appIcon.icon._iconBin,\n            width: iconSize,\n            height: iconSize\n        });\n\n        this.add_child(this._clone);\n    }\n\n    destroy() {\n        this._clone.destroy();\n        super.destroy();\n    }\n});\n\nexport function getAppStableSequence(app, monitor) {\n    let windows = AppIcons.getInterestingWindows(app, monitor);\n    \n    return windows.reduce((prevWindow, window) => {\n        return Math.min(prevWindow, getWindowStableSequence(window));\n    }, Infinity);\n}\n\nexport function sortWindowsCompareFunction(windowA, windowB) {\n    return getWindowStableSequence(windowA) - getWindowStableSequence(windowB);\n}\n\nexport function getWindowStableSequence(window) {\n    return ('_dtpPosition' in window ? window._dtpPosition : window.get_stable_sequence()); \n}\n"
        },
        {
          "name": "transparency.js",
          "type": "blob",
          "size": 8.662109375,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport GdkPixbuf from 'gi://GdkPixbuf';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport St from 'gi://St';\n\nimport * as Proximity from './proximity.js';\nimport * as Utils from './utils.js';\nimport {SETTINGS} from './extension.js';\n\nexport const DynamicTransparency = class {\n\n    constructor(dtpPanel) {\n        this._dtpPanel = dtpPanel;\n        this._proximityManager = dtpPanel.panelManager.proximityManager;\n        this._proximityWatchId = 0;\n        this.currentBackgroundColor = 0;\n\n        this._initialPanelStyle = dtpPanel.panel.get_style();\n\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._bindSignals();\n\n        this._updateAnimationDuration();\n        this._updateAllAndSet();\n        this._updateProximityWatch();\n    }\n\n    destroy() {\n        this._signalsHandler.destroy();\n        this._proximityManager.removeWatch(this._proximityWatchId);\n\n        this._dtpPanel.panel.set_style(this._initialPanelStyle);\n    }\n\n    updateExternalStyle() {\n        this._updateComplementaryStyles();\n        this._setBackground();\n    }\n\n    _bindSignals() {\n        this._signalsHandler.add(\n            [\n                Utils.getStageTheme(),\n                'changed',\n                () => this._updateAllAndSet()\n            ],\n            [\n                Main.overview,\n                [\n                    'showing',\n                    'hiding'\n                ],\n                () => this._updateAlphaAndSet()\n            ],\n            [\n                SETTINGS,\n                [\n                    'changed::trans-use-custom-bg',\n                    'changed::trans-bg-color'\n                ],\n                () => this._updateColorAndSet()\n            ],\n            [\n                SETTINGS,\n                [\n                    'changed::trans-use-custom-opacity',\n                    'changed::trans-panel-opacity',\n                    'changed::trans-bg-color',\n                    'changed::trans-dynamic-anim-target',\n                    'changed::trans-use-dynamic-opacity'\n                ],\n                () => this._updateAlphaAndSet()\n            ],\n            [\n                SETTINGS,\n                [\n                    'changed::trans-use-custom-gradient',\n                    'changed::trans-gradient-top-color',\n                    'changed::trans-gradient-bottom-color',\n                    'changed::trans-gradient-top-opacity',\n                    'changed::trans-gradient-bottom-opacity'\n                ],\n                () => this._updateGradientAndSet()\n            ],\n            [\n                SETTINGS,\n                [\n                    'changed::trans-dynamic-behavior',\n                    'changed::trans-use-dynamic-opacity',\n                    'changed::trans-dynamic-distance'\n                ],\n                () => this._updateProximityWatch()\n            ],\n            [\n                SETTINGS, \n                'changed::trans-dynamic-anim-time',\n                () => this._updateAnimationDuration()\n            ]\n        );\n    }\n\n    _updateProximityWatch() {\n        this._proximityManager.removeWatch(this._proximityWatchId);\n\n        if (SETTINGS.get_boolean('trans-use-dynamic-opacity')) {\n            let isVertical = this._dtpPanel.checkIfVertical();\n            let threshold = SETTINGS.get_int('trans-dynamic-distance');\n\n            this._windowOverlap = false;\n            this._updateAlphaAndSet()\n\n            this._proximityWatchId = this._proximityManager.createWatch(\n                this._dtpPanel.panelBox.get_parent(),\n                this._dtpPanel.monitor.index,\n                Proximity.Mode[SETTINGS.get_string('trans-dynamic-behavior')], \n                isVertical ? threshold : 0, \n                isVertical ? 0 : threshold, \n                overlap => { \n                    this._windowOverlap = overlap;\n                    this._updateAlphaAndSet();\n                }\n            );\n        }\n    }\n\n    _updateAnimationDuration() {\n        this.animationDuration = (SETTINGS.get_int('trans-dynamic-anim-time') * 0.001) + 's;';\n    }\n\n    _updateAllAndSet() {\n        let themeBackground = this._getThemeBackground(true);\n\n        this._updateColor(themeBackground);\n        this._updateAlpha(themeBackground);\n        this._updateComplementaryStyles();\n        this._updateGradient();\n        this._setBackground();\n        this._setGradient();\n    }\n\n    _updateColorAndSet() {\n        this._updateColor();\n        this._setBackground();\n    }\n\n    _updateAlphaAndSet() {\n        this._updateAlpha();\n        this._setBackground();\n    }\n\n    _updateGradientAndSet() {\n        this._updateGradient();\n        this._setGradient();\n    }\n\n    _updateComplementaryStyles() {\n        let panelThemeNode = this._dtpPanel.panel.get_theme_node();\n\n        this._complementaryStyles = 'border-radius: ' + panelThemeNode.get_border_radius(0) + 'px;';\n    }\n\n    _updateColor(themeBackground) {\n        this.backgroundColorRgb = SETTINGS.get_boolean('trans-use-custom-bg') ?\n                                  SETTINGS.get_string('trans-bg-color') :\n                                  (themeBackground || this._getThemeBackground());\n    }\n\n    _updateAlpha(themeBackground) {\n        if (this._windowOverlap && !Main.overview.visibleTarget && SETTINGS.get_boolean('trans-use-dynamic-opacity')) {\n            this.alpha = SETTINGS.get_double('trans-dynamic-anim-target');\n        } else {\n            this.alpha = SETTINGS.get_boolean('trans-use-custom-opacity') ?\n                         SETTINGS.get_double('trans-panel-opacity') : \n                         (themeBackground || this._getThemeBackground()).alpha * 0.003921569; // 1 / 255 = 0.003921569\n        }\n    }\n\n    _updateGradient() {\n        this._gradientStyle = '';\n\n        if (SETTINGS.get_boolean('trans-use-custom-gradient')) {\n            this._gradientStyle += 'background-gradient-direction: ' + (this._dtpPanel.checkIfVertical() ? 'horizontal;' : 'vertical;') +\n                                   'background-gradient-start: ' + Utils.getrgbaColor(SETTINGS.get_string('trans-gradient-top-color'), \n                                                                                      SETTINGS.get_double('trans-gradient-top-opacity')) + \n                                   'background-gradient-end: ' + Utils.getrgbaColor(SETTINGS.get_string('trans-gradient-bottom-color'), \n                                                                                    SETTINGS.get_double('trans-gradient-bottom-opacity'));\n        }\n    }\n\n    _setBackground() {\n        this.currentBackgroundColor = Utils.getrgbaColor(this.backgroundColorRgb, this.alpha);\n\n        let transition = 'transition-duration:' + this.animationDuration;\n\n        this._dtpPanel.set_style('background-color: ' + this.currentBackgroundColor + transition + this._complementaryStyles);\n    }\n\n    _setGradient() {\n        this._dtpPanel.panel.set_style(\n            'background: none; ' + \n            'border-image: none; ' + \n            'background-image: none; ' +\n            this._gradientStyle +\n            'transition-duration:' + this.animationDuration\n        );\n    }\n\n    _getThemeBackground(reload) {\n        if (reload || !this._themeBackground) {\n            let fakePanel = new St.Bin({ name: 'panel' });\n            Main.uiGroup.add_child(fakePanel);\n            let fakeTheme = fakePanel.get_theme_node()\n            this._themeBackground = this._getBackgroundImageColor(fakeTheme) || fakeTheme.get_background_color();\n            Main.uiGroup.remove_child(fakePanel);\n        }\n\n        return this._themeBackground;\n    }\n\n    _getBackgroundImageColor(theme) {\n        let bg = null;\n\n        try {\n            let imageFile = theme.get_background_image() || theme.get_border_image().get_file();\n\n            if (imageFile) {\n                let imageBuf = GdkPixbuf.Pixbuf.new_from_file(imageFile.get_path());\n                let pixels = imageBuf.get_pixels();\n\n                bg = { red: pixels[0], green: pixels[1], blue: pixels[2], alpha: pixels[3] };\n            }\n        } catch (error) {}\n\n        return bg;\n    }\n}\n"
        },
        {
          "name": "ui",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.js",
          "type": "blob",
          "size": 25.3515625,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n * Credits:\n * This file is based on code from the Dash to Dock extension by micheleg\n * and code from the Taskbar extension by Zorin OS\n * Some code was also adapted from the upstream Gnome Shell source code.\n */\n\nimport Clutter from 'gi://Clutter';\nimport Cogl from 'gi://Cogl';\nimport GdkPixbuf from 'gi://GdkPixbuf';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport Graphene from 'gi://Graphene';\nimport Meta from 'gi://Meta';\nimport Shell from 'gi://Shell';\nimport St from 'gi://St';\nimport * as Util from 'resource:///org/gnome/shell/misc/util.js';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as MessageTray from 'resource:///org/gnome/shell/ui/messageTray.js';\n\nconst SCROLL_TIME = Util.SCROLL_TIME / (Util.SCROLL_TIME > 1 ? 1000 : 1);\n\n// simplify global signals and function injections handling\n// abstract class\nexport const  BasicHandler = class {\n\n    constructor() {\n        this._storage = new Object();\n    }\n\n    add(/*unlimited 3-long array arguments*/){\n\n        // convert arguments object to array, concatenate with generic\n        let args = [].concat('generic', [].slice.call(arguments));\n        // call addWithLabel with ags as if they were passed arguments\n        this.addWithLabel.apply(this, args);\n    }\n\n    destroy() {\n        for( let label in this._storage )\n            this.removeWithLabel(label);\n    }\n\n    addWithLabel( label /* plus unlimited 3-long array arguments*/) {\n\n        if(this._storage[label] == undefined)\n            this._storage[label] = new Array();\n\n        // skip first element of the arguments\n        for( let i = 1; i < arguments.length; i++ ) {\n            let item = this._storage[label];\n            let handlers = this._create(arguments[i]);\n\n            for (let j = 0, l = handlers.length; j < l; ++j) {\n                item.push(handlers[j]);\n            }\n        }\n\n    }\n\n    removeWithLabel(label){\n\n        if(this._storage[label]) {\n            for( let i = 0; i < this._storage[label].length; i++ ) {\n                this._remove(this._storage[label][i]);\n            }\n\n            delete this._storage[label];\n        }\n    }\n\n    /* Virtual methods to be implemented by subclass */\n    // create single element to be stored in the storage structure\n    _create(item){\n      throw new Error('no implementation of _create in ' + this);\n    }\n\n    // correctly delete single element\n    _remove(item){\n      throw new Error('no implementation of _remove in ' + this);\n    }\n}\n\n// Manage global signals\nexport const GlobalSignalsHandler = class extends BasicHandler {\n\n    _create(item) {\n        let handlers = [];\n\n        item[1] = [].concat(item[1]);\n\n        for (let i = 0, l = item[1].length; i < l; ++i) {\n            let object = item[0];\n            let event = item[1][i];\n            let callback = item[2]\n            try {\n                let id = object.connect(event, callback);\n\n                handlers.push([object, id]);\n            } catch (e) \n            {\n\n            }\n        }\n\n        return handlers;\n    }\n\n    _remove(item){\n       item[0].disconnect(item[1]);\n    }\n};\n\n/**\n * Manage function injection: both instances and prototype can be overridden\n * and restored\n */\nexport const InjectionsHandler = class extends BasicHandler {\n\n    _create(item) {\n        let object = item[0];\n        let name = item[1];\n        let injectedFunction = item[2];\n        let original = object[name];\n\n        object[name] = injectedFunction;\n        return [[object, name, injectedFunction, original]];\n    }\n\n    _remove(item) {\n        let object = item[0];\n        let name = item[1];\n        let original = item[3];\n        object[name] = original;\n    }\n};\n\n/**\n * Manage timeouts: the added timeouts have their id reset on completion\n */\nexport const TimeoutsHandler = class extends BasicHandler {\n\n    _create(item) {\n        let name = item[0];\n        let delay = item[1];\n        let timeoutHandler = item[2];\n\n        this._remove(item);\n\n        this[name] = GLib.timeout_add(GLib.PRIORITY_DEFAULT, delay, () => {\n            this[name] = 0;\n            timeoutHandler();\n\n            return GLib.SOURCE_REMOVE;\n        });\n\n        return [[name]];\n    }\n\n    remove(name) {\n        this._remove([name])\n    }\n\n    _remove(item) {\n        let name = item[0];\n\n        if (this[name]) {\n            GLib.Source.remove(this[name]);\n            this[name] = 0;\n        }\n    }\n\n    getId(name) {\n        return this[name] ? this[name] : 0;\n    }\n};\n\n// This is wrapper to maintain compatibility with GNOME-Shell 3.30+ as well as\n// previous versions.\nexport const DisplayWrapper = {\n    getScreen() {\n        return global.screen || global.display;\n    },\n\n    getWorkspaceManager() {\n        return global.screen || global.workspace_manager;\n    },\n\n    getMonitorManager() {\n        return global.screen || global.backend.get_monitor_manager();\n    }\n};\n\nlet unredirectEnabled = true\nexport const setDisplayUnredirect = (enable) => {\n    if (enable && !unredirectEnabled)\n        Meta.enable_unredirect_for_display(global.display);\n    else if (!enable && unredirectEnabled)\n        Meta.disable_unredirect_for_display(global.display);\n\n    unredirectEnabled = enable;\n};\n\nexport const getSystemMenuInfo = function() {\n    return {\n        name: 'quickSettings',\n        constructor: Main.panel.statusArea.quickSettings.constructor\n    };\n}\n\nexport const getCurrentWorkspace = function() {\n    return DisplayWrapper.getWorkspaceManager().get_active_workspace();\n};\n\nexport const getWorkspaceByIndex = function(index) {\n    return DisplayWrapper.getWorkspaceManager().get_workspace_by_index(index);\n};\n\nexport const getWorkspaceCount = function() {\n    return DisplayWrapper.getWorkspaceManager().n_workspaces;\n};\n\nexport const getStageTheme = function() {\n    return St.ThemeContext.get_for_stage(global.stage);\n};\n\nexport const getScaleFactor = function() {\n    return getStageTheme().scale_factor || 1;\n};\n\nexport const findIndex = function(array, predicate) {\n    if (array) {\n        if (Array.prototype.findIndex) {\n            return array.findIndex(predicate);\n        }\n\n        for (let i = 0, l = array.length; i < l; ++i) {\n            if (predicate(array[i])) {\n                return i;\n            }\n        }\n    }\n\n    return -1;\n};\n\nexport const find = function(array, predicate) {\n    let index = findIndex(array, predicate);\n\n    if (index > -1) {\n        return array[index];\n    }\n};\n\nexport const mergeObjects = function(main, bck) {\n    for (const prop in bck) {\n        if (!main.hasOwnProperty(prop) && bck.hasOwnProperty(prop)) {\n            main[prop] = bck[prop];\n        }\n    }\n\n    return main;\n};\n\nexport const getTrackedActorData = (actor) => {\n    let trackedIndex = Main.layoutManager._findActor(actor);\n    \n    if (trackedIndex >= 0)\n        return Main.layoutManager._trackedActors[trackedIndex]\n}\n\nexport const getTransformedAllocation = function(actor) {\n    let extents = actor.get_transformed_extents();\n    let topLeft = extents.get_top_left();\n    let bottomRight = extents.get_bottom_right();\n\n    return { x1: topLeft.x, x2: bottomRight.x, y1: topLeft.y, y2: bottomRight.y };\n};\n\nexport const setClip = function(actor, x, y, width, height) {\n    actor.set_clip(0, 0, width, height);\n    actor.set_position(x, y);\n    actor.set_size(width, height);\n};\n\nexport const addKeybinding = function(key, settings, handler, modes) {\n    if (!Main.wm._allowedKeybindings[key]) {\n        Main.wm.addKeybinding(\n            key, \n            settings,\n            Meta.KeyBindingFlags.NONE,\n            modes || (Shell.ActionMode.NORMAL | Shell.ActionMode.OVERVIEW),\n            handler\n        );\n    }\n};\n\nexport const removeKeybinding = function(key) {\n    if (Main.wm._allowedKeybindings[key]) {\n        Main.wm.removeKeybinding(key);\n    }\n};\n\nexport const getrgbColor = function(color) {\n    color = typeof color === 'string' ? ColorUtils.color_from_string(color)[1] : color;\n\n    return { red: color.red, green: color.green, blue: color.blue };\n};\n\nexport const getrgbaColor = function(color, alpha, offset) {\n    if (alpha <= 0) {\n        return 'transparent; ';\n    }\n\n    let rgb = getrgbColor(color);\n\n    if (offset) {\n        ['red', 'green', 'blue'].forEach(k => {\n            rgb[k] = Math.min(255, Math.max(0, rgb[k] + offset));\n\n            if (rgb[k] == color[k]) {\n                rgb[k] = Math.min(255, Math.max(0, rgb[k] - offset));\n            }\n        });\n    }\n\n    return 'rgba(' + rgb.red + ',' + rgb.green + ',' + rgb.blue + ',' + (Math.floor(alpha * 100) * 0.01) + '); ' ;\n};\n\nexport const checkIfColorIsBright = function(color) {\n    let rgb = getrgbColor(color);\n    let brightness = 0.2126 * rgb.red + 0.7152 * rgb.green + 0.0722 * rgb.blue;\n\n    return brightness > 128;\n};\n\nexport const getMouseScrollDirection = function(event) {\n    let direction;\n\n    switch (event.get_scroll_direction()) {\n        case Clutter.ScrollDirection.UP:\n        case Clutter.ScrollDirection.LEFT:\n            direction = 'up';\n            break;\n        case Clutter.ScrollDirection.DOWN:\n        case Clutter.ScrollDirection.RIGHT:\n            direction = 'down';\n            break;\n    }\n\n    return direction;\n};\n\nexport const checkIfWindowHasTransient = function(window) {\n    let hasTransient;\n\n    window.foreach_transient(t => !(hasTransient = true));\n\n    return hasTransient;\n};\n\nexport const activateSiblingWindow = function(windows, direction, startWindow) {\n    let windowIndex = windows.indexOf(global.display.focus_window);\n    let nextWindowIndex = windowIndex < 0 ?\n                          startWindow ? windows.indexOf(startWindow) : 0 : \n                          windowIndex + (direction == 'up' ? -1 : 1);\n\n    if (nextWindowIndex == windows.length) {\n        nextWindowIndex = 0;\n    } else if (nextWindowIndex < 0) {\n        nextWindowIndex = windows.length - 1;\n    }\n\n    if (windowIndex != nextWindowIndex) {\n        Main.activateWindow(windows[nextWindowIndex]);\n    }\n};\n\nexport const animateWindowOpacity = function(window, tweenOpts) {\n    //there currently is a mutter bug with the windowactor opacity, starting with 3.34\n    //https://gitlab.gnome.org/GNOME/mutter/issues/836\n\n    //since 3.36, a workaround is to use the windowactor's child for the fade animation\n    //this leaves a \"shadow\" on the desktop, so the windowactor needs to be hidden\n    //when the animation is complete\n    let visible = tweenOpts.opacity > 0;\n    let windowActor = window;\n    let initialOpacity = window.opacity;\n\n    window = windowActor.get_first_child() || windowActor;\n\n    if (!windowActor.visible && visible) {\n        window.opacity = 0;\n        windowActor.visible = visible;\n        tweenOpts.opacity = Math.min(initialOpacity, tweenOpts.opacity);\n    }\n    \n    if (!visible) {\n        tweenOpts.onComplete = () => { \n            windowActor.visible = visible; \n            window.opacity = initialOpacity; \n        };\n    }\n\n    animate(window, tweenOpts);\n};\n\nexport const animate = function(actor, options) {\n    //the original animations used Tweener instead of Clutter animations, so we\n    //use \"time\" and \"delay\" properties defined in seconds, as opposed to Clutter \n    //animations \"duration\" and \"delay\" which are defined in milliseconds\n    if (options.delay) {\n        options.delay = options.delay * 1000;\n    }\n\n    options.duration = options.time * 1000;\n    delete options.time;\n\n    if (options.transition) {\n        //map Tweener easing equations to Clutter animation modes\n        options.mode = {\n            'easeInCubic': Clutter.AnimationMode.EASE_IN_CUBIC,\n            'easeInOutCubic': Clutter.AnimationMode.EASE_IN_OUT_CUBIC,\n            'easeInOutQuad': Clutter.AnimationMode.EASE_IN_OUT_QUAD,\n            'easeOutQuad': Clutter.AnimationMode.EASE_OUT_QUAD\n        }[options.transition] || Clutter.AnimationMode.LINEAR;\n\n        delete options.transition;\n    }\n\n    let params = [options];\n\n    if ('value' in options && actor instanceof St.Adjustment) {\n        params.unshift(options.value);\n        delete options.value;\n    }\n\n    actor.ease.apply(actor, params);\n}\n\nexport const isAnimating = function(actor, prop) {\n    return !!actor.get_transition(prop);\n}\n\nexport const stopAnimations = function(actor) {\n    actor.remove_all_transitions();\n}\n\nexport const getIndicators = function(delegate) {\n    if (delegate instanceof St.BoxLayout) {\n        return delegate;\n    }\n\n    return delegate.indicators;\n}\n\nexport const getPoint = function(coords) {\n    return new Graphene.Point(coords);\n}\n\nexport const notify = function(text, iconName, action, isTransient) {\n    let source = new MessageTray.SystemNotificationSource();\n    let notification = new MessageTray.Notification(source, 'Dash to Panel', text);\n    let notifyFunc = source.showNotification || source.notify;\n    \n    if (iconName) {\n        source.createIcon = function() {\n            return new St.Icon({ icon_name: iconName });\n        };\n    }   \n\n    if (action) {\n        if (!(action instanceof Array)) {\n            action = [action];\n        }\n\n        action.forEach(a => notification.addAction(a.text, a.func));\n    }\n\n    Main.messageTray.add(source);\n\n    notification.setTransient(isTransient);\n    notifyFunc.call(source, notification);\n};\n\n/*\n * This is a copy of the same function in utils.js, but also adjust horizontal scrolling\n * and perform few further cheks on the current value to avoid changing the values when\n * it would be clamp to the current one in any case.\n * Return the amount of shift applied\n*/\nexport const ensureActorVisibleInScrollView = function(scrollView, actor, fadeSize, onComplete) {\n    const vadjustment = scrollView.vadjustment;\n    const hadjustment = scrollView.hadjustment;\n    let [vvalue, vlower, vupper, vstepIncrement, vpageIncrement, vpageSize] = vadjustment.get_values();\n    let [hvalue, hlower, hupper, hstepIncrement, hpageIncrement, hpageSize] = hadjustment.get_values();\n\n    let [hvalue0, vvalue0] = [hvalue, vvalue];\n\n    let voffset = fadeSize;\n    let hoffset = fadeSize;\n    \n    let box = actor.get_allocation_box();\n    let y1 = box.y1, y2 = box.y2, x1 = box.x1, x2 = box.x2;\n\n    let parent = actor.get_parent();\n    while (parent != scrollView) {\n        if (!parent)\n            throw new Error(\"actor not in scroll view\");\n\n        let box = parent.get_allocation_box();\n        y1 += box.y1;\n        y2 += box.y1;\n        x1 += box.x1;\n        x2 += box.x1;\n        parent = parent.get_parent();\n    }\n\n    if (y1 < vvalue + voffset)\n        vvalue = Math.max(0, y1 - voffset);\n    else if (vvalue < vupper - vpageSize && y2 > vvalue + vpageSize - voffset)\n        vvalue = Math.min(vupper -vpageSize, y2 + voffset - vpageSize);\n\n    if (x1 < hvalue + hoffset)\n        hvalue = Math.max(0, x1 - hoffset);\n    else if (hvalue < hupper - hpageSize && x2 > hvalue + hpageSize - hoffset)\n        hvalue = Math.min(hupper - hpageSize, x2 + hoffset - hpageSize);\n\n    let tweenOpts = {\n        time: SCROLL_TIME,\n        onComplete: onComplete || (() => {}),\n        transition: 'easeOutQuad'\n    };\n\n    if (vvalue !== vvalue0) {\n        animate(vadjustment, mergeObjects(tweenOpts, { value: vvalue }));\n    }\n\n    if (hvalue !== hvalue0) {\n        animate(hadjustment, mergeObjects(tweenOpts, { value: hvalue }));\n    }\n\n    return [hvalue- hvalue0, vvalue - vvalue0];\n}\n \n/**\n *  ColorUtils is adapted from https://github.com/micheleg/dash-to-dock\n */\nlet colorNs = Clutter.Color ? Clutter : Cogl\n\nexport const ColorUtils = {\n    color_from_string: colorNs.color_from_string,\n    Color: colorNs.Color,\n\n    colorLuminance(r, g, b, dlum) {\n        // Darken or brighten color by a fraction dlum\n        // Each rgb value is modified by the same fraction.\n        // Return \"#rrggbb\" strin\n\n        let rgbString = '#';\n\n        rgbString += ColorUtils._decimalToHex(Math.round(Math.min(Math.max(r*(1+dlum), 0), 255)), 2);\n        rgbString += ColorUtils._decimalToHex(Math.round(Math.min(Math.max(g*(1+dlum), 0), 255)), 2);\n        rgbString += ColorUtils._decimalToHex(Math.round(Math.min(Math.max(b*(1+dlum), 0), 255)), 2);\n\n        return rgbString;\n    },\n\n    _decimalToHex(d, padding) {\n        // Convert decimal to an hexadecimal string adding the desired padding\n\n        let hex = d.toString(16);\n        while (hex.length < padding)\n            hex = '0'+ hex;\n        return hex;\n    },\n\n    HSVtoRGB(h, s, v) {\n        // Convert hsv ([0-1, 0-1, 0-1]) to rgb ([0-255, 0-255, 0-255]).\n        // Following algorithm in https://en.wikipedia.org/wiki/HSL_and_HSV\n        // here with h = [0,1] instead of [0, 360]\n        // Accept either (h,s,v) independently or  {h:h, s:s, v:v} object.\n        // Return {r:r, g:g, b:b} object.\n\n        if (arguments.length === 1) {\n            s = h.s;\n            v = h.v;\n            h = h.h;\n        }\n\n        let r,g,b;\n        let c = v*s;\n        let h1 = h*6;\n        let x = c*(1 - Math.abs(h1 % 2 - 1));\n        let m = v - c;\n\n        if (h1 <=1)\n            r = c + m, g = x + m, b = m;\n        else if (h1 <=2)\n            r = x + m, g = c + m, b = m;\n        else if (h1 <=3)\n            r = m, g = c + m, b = x + m;\n        else if (h1 <=4)\n            r = m, g = x + m, b = c + m;\n        else if (h1 <=5)\n            r = x + m, g = m, b = c + m;\n        else\n            r = c + m, g = m, b = x + m;\n\n        return {\n            r: Math.round(r * 255),\n            g: Math.round(g * 255),\n            b: Math.round(b * 255)\n        };\n    },\n\n    RGBtoHSV(r, g, b) {\n        // Convert rgb ([0-255, 0-255, 0-255]) to hsv ([0-1, 0-1, 0-1]).\n        // Following algorithm in https://en.wikipedia.org/wiki/HSL_and_HSV\n        // here with h = [0,1] instead of [0, 360]\n        // Accept either (r,g,b) independently or {r:r, g:g, b:b} object.\n        // Return {h:h, s:s, v:v} object.\n\n        if (arguments.length === 1) {\n            r = r.r;\n            g = r.g;\n            b = r.b;\n        }\n\n        let h,s,v;\n\n        let M = Math.max(r, g, b);\n        let m = Math.min(r, g, b);\n        let c = M - m;\n\n        if (c == 0)\n            h = 0;\n        else if (M == r)\n            h = ((g-b)/c) % 6;\n        else if (M == g)\n            h = (b-r)/c + 2;\n        else\n            h = (r-g)/c + 4;\n\n        h = h/6;\n        v = M/255;\n        if (M !== 0)\n            s = c/M;\n        else\n            s = 0;\n\n        return {h: h, s: s, v: v};\n    }\n};\n\n/**\n *  DominantColorExtractor is adapted from https://github.com/micheleg/dash-to-dock\n */\nlet themeLoader = null;\nlet iconCacheMap = new Map();\nconst MAX_CACHED_ITEMS = 1000;\nconst BATCH_SIZE_TO_DELETE = 50;\nconst DOMINANT_COLOR_ICON_SIZE = 64;\n\nexport const DominantColorExtractor = class {\n\n    constructor(app){\n        this._app = app;\n    }\n\n    /**\n     * Try to get the pixel buffer for the current icon, if not fail gracefully\n     */\n    _getIconPixBuf() {\n        let iconTexture = this._app.create_icon_texture(16);\n\n        if (themeLoader === null) {\n            themeLoader = new St.IconTheme();\n        }\n\n        // Unable to load the icon texture, use fallback\n        if (iconTexture instanceof St.Icon === false) {\n            return null;\n        }\n\n        iconTexture = iconTexture.get_gicon();\n\n        // Unable to load the icon texture, use fallback\n        if (iconTexture === null) {\n            return null;\n        }\n\n        if (iconTexture instanceof Gio.FileIcon) {\n            // Use GdkPixBuf to load the pixel buffer from the provided file path\n            return GdkPixbuf.Pixbuf.new_from_file(iconTexture.get_file().get_path());\n        }\n\n        // Get the pixel buffer from the icon theme\n        if (iconTexture instanceof Gio.ThemedIcon) {\n            let icon_info = themeLoader.lookup_icon(iconTexture.get_names()[0],\n                DOMINANT_COLOR_ICON_SIZE, 0);\n            \n            if (icon_info !== null) {\n                return icon_info.load_icon();\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * The backlight color choosing algorithm was mostly ported to javascript from the\n     * Unity7 C++ source of Canonicals:\n     * https://bazaar.launchpad.net/~unity-team/unity/trunk/view/head:/launcher/LauncherIcon.cpp\n     * so it more or less works the same way.\n     */\n    _getColorPalette() {\n        if (iconCacheMap.get(this._app.get_id())) {\n            // We already know the answer\n            return iconCacheMap.get(this._app.get_id());\n        }\n\n        let pixBuf = this._getIconPixBuf();\n        if (pixBuf == null)\n            return null;\n\n        let pixels = pixBuf.get_pixels(),\n            offset = 0;\n\n        let total  = 0,\n            rTotal = 0,\n            gTotal = 0,\n            bTotal = 0;\n\n        let resample_y = 1,\n            resample_x = 1;\n\n        // Resampling of large icons\n        // We resample icons larger than twice the desired size, as the resampling\n        // to a size s\n        // DOMINANT_COLOR_ICON_SIZE < s < 2*DOMINANT_COLOR_ICON_SIZE,\n        // most of the case exactly DOMINANT_COLOR_ICON_SIZE as the icon size is tipycally\n        // a multiple of it.\n        let width = pixBuf.get_width();\n        let height = pixBuf.get_height();\n\n        // Resample\n        if (height >= 2* DOMINANT_COLOR_ICON_SIZE)\n            resample_y = Math.floor(height/DOMINANT_COLOR_ICON_SIZE);\n\n        if (width >= 2* DOMINANT_COLOR_ICON_SIZE)\n            resample_x = Math.floor(width/DOMINANT_COLOR_ICON_SIZE);\n\n        if (resample_x !==1 || resample_y !== 1)\n            pixels = this._resamplePixels(pixels, resample_x, resample_y);\n\n        // computing the limit outside the for (where it would be repeated at each iteration)\n        // for performance reasons\n        let limit = pixels.length;\n        for (let offset = 0; offset < limit; offset+=4) {\n            let r = pixels[offset],\n                g = pixels[offset + 1],\n                b = pixels[offset + 2],\n                a = pixels[offset + 3];\n\n            let saturation = (Math.max(r,g, b) - Math.min(r,g, b));\n            let relevance  = 0.1 * 255 * 255 + 0.9 * a * saturation;\n\n            rTotal += r * relevance;\n            gTotal += g * relevance;\n            bTotal += b * relevance;\n\n            total += relevance;\n        }\n\n        total = total * 255;\n\n        let r = rTotal / total,\n            g = gTotal / total,\n            b = bTotal / total;\n\n        let hsv = ColorUtils.RGBtoHSV(r * 255, g * 255, b * 255);\n\n        if (hsv.s > 0.15)\n            hsv.s = 0.65;\n        hsv.v = 0.90;\n\n        let rgb = ColorUtils.HSVtoRGB(hsv.h, hsv.s, hsv.v);\n\n        // Cache the result.\n        let backgroundColor = {\n            lighter:  ColorUtils.colorLuminance(rgb.r, rgb.g, rgb.b, 0.2),\n            original: ColorUtils.colorLuminance(rgb.r, rgb.g, rgb.b, 0),\n            darker:   ColorUtils.colorLuminance(rgb.r, rgb.g, rgb.b, -0.5)\n        };\n\n        if (iconCacheMap.size >= MAX_CACHED_ITEMS) {\n            //delete oldest cached values (which are in order of insertions)\n            let ctr=0;\n            for (let key of iconCacheMap.keys()) {\n                if (++ctr > BATCH_SIZE_TO_DELETE)\n                    break;\n                iconCacheMap.delete(key);\n            }\n        }\n\n        iconCacheMap.set(this._app.get_id(), backgroundColor);\n\n        return backgroundColor;\n    }\n\n    /**\n     * Downsample large icons before scanning for the backlight color to\n     * improve performance.\n     *\n     * @param pixBuf\n     * @param pixels\n     * @param resampleX\n     * @param resampleY\n     *\n     * @return [];\n     */\n    _resamplePixels(pixels, resampleX, resampleY) {\n        let resampledPixels = [];\n        // computing the limit outside the for (where it would be repeated at each iteration)\n        // for performance reasons\n        let limit = pixels.length / (resampleX * resampleY) / 4;\n        for (let i = 0; i < limit; i++) {\n            let pixel = i * resampleX * resampleY;\n\n            resampledPixels.push(pixels[pixel * 4]);\n            resampledPixels.push(pixels[pixel * 4 + 1]);\n            resampledPixels.push(pixels[pixel * 4 + 2]);\n            resampledPixels.push(pixels[pixel * 4 + 3]);\n        }\n\n        return resampledPixels;\n    }\n\n};\n\nexport const drawRoundedLine = function(cr, x, y, width, height, isRoundLeft, isRoundRight, stroke, fill) {\n    if (height > width) {\n        y += Math.floor((height - width) / 2.0);\n        height = width;\n    }\n    \n    height = 2.0 * Math.floor(height / 2.0);\n    \n    const leftRadius = isRoundLeft ? height / 2.0 : 0.0;\n    const rightRadius = isRoundRight ? height / 2.0 : 0.0;\n    \n    cr.moveTo(x + width - rightRadius, y);\n    cr.lineTo(x + leftRadius, y);\n    if (isRoundLeft)\n        cr.arcNegative(x + leftRadius, y + leftRadius, leftRadius, -Math.PI/2, Math.PI/2);\n    else\n        cr.lineTo(x, y + height);\n    cr.lineTo(x + width - rightRadius, y + height);\n    if (isRoundRight)\n        cr.arcNegative(x + width - rightRadius, y + rightRadius, rightRadius, Math.PI/2, -Math.PI/2);\n    else\n        cr.lineTo(x + width, y);\n    cr.closePath();\n    \n    if (fill != null) {\n        cr.setSource(fill);\n        cr.fillPreserve();\n    }\n    if (stroke != null)\n        cr.setSource(stroke);\n    cr.stroke();\n}\n"
        },
        {
          "name": "windowPreview.js",
          "type": "blob",
          "size": 40.2431640625,
          "content": "/*\n * This file is part of the Dash-To-Panel extension for Gnome 3\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport GObject from 'gi://GObject';\nimport Clutter from 'gi://Clutter';\nimport GLib from 'gi://GLib';\nimport Graphene from 'gi://Graphene';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport Meta from 'gi://Meta';\nimport * as PopupMenu from 'resource:///org/gnome/shell/ui/popupMenu.js';\nimport St from 'gi://St';\n\nimport * as Taskbar from './taskbar.js';\nimport * as Utils from './utils.js';\nimport {SETTINGS, DESKTOPSETTINGS} from './extension.js';\nimport {gettext as _} from 'resource:///org/gnome/shell/extensions/extension.js';\n\n//timeout intervals\nconst ENSURE_VISIBLE_MS = 200;\n\n//timeout names\nconst T1 = 'openMenuTimeout';\nconst T2 = 'closeMenuTimeout';\nconst T3 = 'peekTimeout';\nconst T4 = 'ensureVisibleTimeout';\n\nconst MAX_TRANSLATION = 40;\nconst HEADER_HEIGHT = 38;\nconst MAX_CLOSE_BUTTON_SIZE = 30;\nconst MIN_DIMENSION = 100;\nconst FOCUSED_COLOR_OFFSET = 24;\nconst HEADER_COLOR_OFFSET = -12;\nconst FADE_SIZE = 36;\nconst PEEK_INDEX_PROP = '_dtpPeekInitialIndex';\n\nlet headerHeight = 0;\nlet alphaBg = 0;\nlet isLeftButtons = false;\nlet isTopHeader = true;\nlet isManualStyling = false;\nlet scaleFactor = 1;\nlet animationTime = 0;\nlet aspectRatio = {};\n\nexport const PreviewMenu = GObject.registerClass({\n    Signals: { 'open-state-changed': {} }\n}, class PreviewMenu extends St.Widget {\n\n    _init(panel) {\n        super._init({ layout_manager: new Clutter.BinLayout() });\n\n        let geom = panel.geom;\n        this.panel = panel;\n        this.currentAppIcon = null;\n        this._focusedPreview = null;\n        this._peekedWindow = null;\n        this.allowCloseWindow = true;\n        this.peekInitialWorkspaceIndex = -1;\n        this.opened = false;\n        this.isVertical = geom.position == St.Side.LEFT || geom.position == St.Side.RIGHT;\n        this._translationProp = 'translation_' + (this.isVertical ? 'x' : 'y');\n        this._translationDirection = (geom.position == St.Side.TOP || geom.position == St.Side.LEFT ? -1 : 1);\n        this._translationOffset = Math.min(panel.dtpSize, MAX_TRANSLATION) * this._translationDirection;\n\n        this.menu = new St.Widget({ \n            name: 'preview-menu', \n            layout_manager: new Clutter.BinLayout(), \n            reactive: true, \n            track_hover: true,\n            x_expand: true, \n            y_expand: true, \n            x_align: Clutter.ActorAlign[geom.position != St.Side.RIGHT ? 'START' : 'END'],\n            y_align: Clutter.ActorAlign[geom.position != St.Side.BOTTOM ? 'START' : 'END']\n        });\n        this._box = new St.BoxLayout({ vertical: this.isVertical });\n        this._scrollView = new St.ScrollView({\n            name: 'dashtopanelPreviewScrollview',\n            hscrollbar_policy: St.PolicyType.NEVER,\n            vscrollbar_policy: St.PolicyType.NEVER,\n            enable_mouse_scrolling: true,\n            y_expand: !this.isVertical\n        });\n\n        this._scrollView.add_child(this._box);\n        this.menu.add_child(this._scrollView);\n        this.add_child(this.menu);\n    }\n\n    enable() {\n        this._timeoutsHandler = new Utils.TimeoutsHandler();\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n\n        Main.layoutManager.addChrome(this, { affectsInputRegion: false });\n        Main.layoutManager.trackChrome(this.menu, { affectsInputRegion: true });\n        \n        this._resetHiddenState();\n        this._refreshGlobals();\n        this._updateClip();\n        this.menu.set_position(1, 1);\n\n        this._signalsHandler.add(\n            [\n                this.menu,\n                'notify::hover',\n                () => this._onHoverChanged()\n            ],\n            [\n                this._scrollView,\n                'scroll-event', \n                this._onScrollEvent.bind(this)\n            ],\n            [\n                this.panel.panelBox,\n                'style-changed',\n                () => this._updateClip()\n            ],\n            [\n                Utils.DisplayWrapper.getScreen(),\n                'in-fullscreen-changed',\n                () => {\n                    if (global.display.focus_window && global.display.focus_window.is_fullscreen()) {\n                        this.close(true);\n                    }\n                }\n            ],\n            [\n                SETTINGS,\n                [\n                    'changed::panel-sizes',\n                    'changed::window-preview-size',\n                    'changed::window-preview-padding',\n                    'changed::window-preview-show-title'\n                ],\n                () => {\n                    this._refreshGlobals();\n                    this._updateClip();\n                }\n            ]\n        );\n    }\n\n    disable() {\n        this._timeoutsHandler.destroy();\n        this._signalsHandler.destroy();\n\n        this.close(true);\n\n        Main.layoutManager.untrackChrome(this.menu);\n        Main.layoutManager.removeChrome(this);\n    }\n\n    requestOpen(appIcon) {\n        let timeout = SETTINGS.get_int('show-window-previews-timeout');\n\n        if (this.opened) {\n            timeout = Math.min(100, timeout);\n        }\n\n        this._endOpenCloseTimeouts();\n        this._timeoutsHandler.add([T1, timeout, () => this.open(appIcon)]);\n    }\n\n    requestClose() {\n        this._endOpenCloseTimeouts();\n        this._addCloseTimeout();\n    }\n\n    open(appIcon, preventCloseWindow) {\n        if (this.currentAppIcon != appIcon) {\n            this.currentAppIcon = appIcon;\n            this.allowCloseWindow = !preventCloseWindow;\n\n            if (!this.opened) {\n                this._refreshGlobals();\n                \n                this.set_height(this.clipHeight);\n                this.menu.show();\n                \n                setStyle(this.menu, 'background: ' + Utils.getrgbaColor(this.panel.dynamicTransparency.backgroundColorRgb, alphaBg));\n            }\n\n            this._mergeWindows(appIcon);\n            this._updatePosition();\n            this._animateOpenOrClose(true);\n\n            this._setReactive(true);\n            this._setOpenedState(true);\n        }\n    }\n\n    close(immediate) {\n        this._endOpenCloseTimeouts();\n        this._removeFocus();\n        this._endPeek();\n        \n        if (immediate) {\n            Utils.stopAnimations(this.menu);\n            this._resetHiddenState();\n        } else {\n            this._animateOpenOrClose(false, () => this._resetHiddenState());\n        }\n\n        this._setReactive(false);\n        this.currentAppIcon = null;\n    }\n\n    update(appIcon, windows) {\n        if (this.currentAppIcon == appIcon) {\n            if (windows && !windows.length) {\n                this.close();\n            } else {\n                this._addAndRemoveWindows(windows);\n                this._updatePosition();\n            }\n        }\n    }\n\n    updatePosition() {\n        this._updatePosition();\n    }\n\n    focusNext() {\n        let previews = this._box.get_children();\n        let currentIndex = this._focusedPreview ? previews.indexOf(this._focusedPreview) : -1;\n        let nextIndex = currentIndex + 1;\n        \n        nextIndex = previews[nextIndex] ? nextIndex : 0;\n\n        if (previews[nextIndex]) {\n            this._removeFocus();\n            previews[nextIndex].setFocus(true);\n            this._focusedPreview = previews[nextIndex];\n        }\n\n        return nextIndex;\n    }\n\n    activateFocused() {\n        if (this.opened && this._focusedPreview) {\n            this._focusedPreview.activate();\n        }\n    }\n\n    requestPeek(window) {\n        this._timeoutsHandler.remove(T3);\n\n        if (SETTINGS.get_boolean('peek-mode')) {\n            if (this.peekInitialWorkspaceIndex < 0) {\n                this._timeoutsHandler.add([T3, SETTINGS.get_int('enter-peek-mode-timeout'), () => this._peek(window)]);\n            } else {\n                this._peek(window);\n            }\n        }\n    }\n\n    endPeekHere() {\n        this._endPeek(true);\n    }\n\n    ensureVisible(preview) {\n        let [ , upper, pageSize] = this._getScrollAdjustmentValues();\n        \n        if (upper > pageSize) {\n            this._timeoutsHandler.add([\n                T4, \n                ENSURE_VISIBLE_MS, \n                () => Utils.ensureActorVisibleInScrollView(this._scrollView, preview, MIN_DIMENSION, () => this._updateScrollFade())\n            ]);\n        }\n    }\n\n    getCurrentAppIcon() {\n        return this.currentAppIcon;\n    }\n\n    _setReactive(reactive) {\n        this._box.get_children().forEach(c => c.reactive = reactive);\n        this.menu.reactive = reactive;\n    }\n\n    _setOpenedState(opened) {\n        this.opened = opened;\n        this.emit('open-state-changed');\n    }\n\n    _resetHiddenState() {\n        this.menu.hide();\n        this.set_height(0);\n        this._setOpenedState(false);\n        this.menu.opacity = 0;\n        this.menu[this._translationProp] = this._translationOffset;\n        this._box.get_children().forEach(c => c.destroy());\n    }\n\n    _removeFocus() {\n        if (this._focusedPreview) {\n            this._focusedPreview.setFocus(false);\n            this._focusedPreview = null;\n        }\n    }\n\n    _mergeWindows(appIcon, windows) {\n        windows = windows || (appIcon.window ? [appIcon.window] : appIcon.getAppIconInterestingWindows());\n        windows.sort(Taskbar.sortWindowsCompareFunction);\n    \n        let currentPreviews = this._box.get_children();\n        let l = Math.max(windows.length, currentPreviews.length);\n\n        for (let i = 0; i < l; ++i) {\n            if (currentPreviews[i] && windows[i]) {\n                currentPreviews[i].assignWindow(windows[i], this.opened);\n            } else if (!currentPreviews[i]) {\n                this._addNewPreview(windows[i]);\n            } else if (!windows[i]) {\n                currentPreviews[i][!this.opened ? 'destroy' : 'animateOut']();\n            }\n        }\n    }\n\n    _addAndRemoveWindows(windows) {\n        let currentPreviews = this._box.get_children();\n\n        windows.sort(Taskbar.sortWindowsCompareFunction);\n\n        for (let i = 0, l = windows.length; i < l; ++i) {\n            let currentIndex = Utils.findIndex(currentPreviews, c => c.window == windows[i]);\n            \n            if (currentIndex < 0) {\n                this._addNewPreview(windows[i]);\n            } else {\n                currentPreviews[currentIndex].assignWindow(windows[i]);\n                currentPreviews.splice(currentIndex, 1);\n\n                if (this._peekedWindow && this._peekedWindow == windows[i]) {\n                    this.requestPeek(windows[i]);\n                }\n            }\n        }\n\n        currentPreviews.forEach(c => c.animateOut());\n    }\n\n    _addNewPreview(window) {\n        let preview = new Preview(this);\n\n        this._box.add_child(preview);\n        preview.adjustOnStage();\n        preview.assignWindow(window, this.opened);\n    }\n\n    _addCloseTimeout() {\n        this._timeoutsHandler.add([T2, SETTINGS.get_int('leave-timeout'), () => this.close()]);\n    }\n\n    _onHoverChanged() {\n        this._endOpenCloseTimeouts();\n\n        if (this.currentAppIcon && !this.menu.hover) {\n            this._addCloseTimeout();\n            this._endPeek();\n        }\n    }\n\n    _onScrollEvent(actor, event) {\n        if (!event.is_pointer_emulated()) {\n            let vOrh = this.isVertical ? 'v' : 'h';\n            let adjustment = this._scrollView['get_' + vOrh + 'scroll_bar']().get_adjustment(); \n            let increment = adjustment.step_increment;\n            let delta = increment;\n\n            switch (event.get_scroll_direction()) {\n                case Clutter.ScrollDirection.UP:\n                    delta = -increment;\n                    break;\n                case Clutter.ScrollDirection.SMOOTH:\n                    let [dx, dy] = event.get_scroll_delta();\n                    delta = dy * increment;\n                    delta += dx * increment;\n                    break;\n            }\n            \n            adjustment.set_value(adjustment.get_value() + delta);\n            this._updateScrollFade();\n        }\n\n        return Clutter.EVENT_STOP;\n    }\n\n    _endOpenCloseTimeouts() {\n        this._timeoutsHandler.remove(T1);\n        this._timeoutsHandler.remove(T2);\n        this._timeoutsHandler.remove(T4);\n    }\n\n    _refreshGlobals() {\n        isLeftButtons = Meta.prefs_get_button_layout().left_buttons.indexOf(Meta.ButtonFunction.CLOSE) >= 0;\n        isTopHeader = SETTINGS.get_string('window-preview-title-position') == 'TOP';\n        isManualStyling = SETTINGS.get_boolean('window-preview-manual-styling');\n        scaleFactor = Utils.getScaleFactor();\n        headerHeight = SETTINGS.get_boolean('window-preview-show-title') ? HEADER_HEIGHT * scaleFactor : 0;\n        animationTime = SETTINGS.get_int('window-preview-animation-time') * .001;\n        aspectRatio.x = {\n            size: SETTINGS.get_int('window-preview-aspect-ratio-x'),\n            fixed: SETTINGS.get_boolean('window-preview-fixed-x')\n        };\n        aspectRatio.y = {\n            size: SETTINGS.get_int('window-preview-aspect-ratio-y'),\n            fixed: SETTINGS.get_boolean('window-preview-fixed-y')\n        };\n        \n        alphaBg = SETTINGS.get_boolean('preview-use-custom-opacity') ? \n                  SETTINGS.get_int('preview-custom-opacity') * .01 : \n                  this.panel.dynamicTransparency.alpha;\n    }\n\n    _updateClip() {\n        let x, y, w;\n        let geom = this.panel.getGeometry();\n        let panelBoxTheme = this.panel.panelBox.get_theme_node();\n        let previewSize = (SETTINGS.get_int('window-preview-size') + \n                           SETTINGS.get_int('window-preview-padding') * 2) * scaleFactor;\n        \n        if (this.isVertical) {\n            w = previewSize;\n            this.clipHeight = this.panel.monitor.height;\n            y = this.panel.monitor.y;\n        } else {\n            w = this.panel.monitor.width;\n            this.clipHeight = (previewSize + headerHeight);\n            x = this.panel.monitor.x;\n        }\n\n        if (geom.position == St.Side.LEFT) {\n            x = this.panel.monitor.x + this.panel.dtpSize + panelBoxTheme.get_padding(St.Side.LEFT);\n        } else if (geom.position == St.Side.RIGHT) {\n            x = this.panel.monitor.x + this.panel.monitor.width - (this.panel.dtpSize + previewSize) - panelBoxTheme.get_padding(St.Side.RIGHT);\n        } else if (geom.position == St.Side.TOP) {\n            y = this.panel.monitor.y + this.panel.dtpSize + panelBoxTheme.get_padding(St.Side.TOP);\n        } else { //St.Side.BOTTOM\n            y = this.panel.monitor.y + this.panel.monitor.height - (this.panel.dtpSize + panelBoxTheme.get_padding(St.Side.BOTTOM) + previewSize + headerHeight);\n        }\n\n        Utils.setClip(this, x, y, w, this.clipHeight);\n    }\n\n    _updatePosition() {\n        let sourceNode = this.currentAppIcon.get_theme_node();\n        let sourceContentBox = sourceNode.get_content_box(this.currentAppIcon.get_allocation_box());\n        let sourceAllocation = Utils.getTransformedAllocation(this.currentAppIcon);\n        let [previewsWidth, previewsHeight] = this._getPreviewsSize();\n        let appIconMargin = SETTINGS.get_int('appicon-margin') / scaleFactor;\n        let x = 0, y = 0;\n\n        previewsWidth = Math.min(previewsWidth, this.panel.monitor.width);\n        previewsHeight = Math.min(previewsHeight, this.panel.monitor.height);\n        this._updateScrollFade(previewsWidth < this.panel.monitor.width && previewsHeight < this.panel.monitor.height);\n        \n        if (this.isVertical) {\n            y = sourceAllocation.y1 + appIconMargin - this.panel.monitor.y + (sourceContentBox.y2 - sourceContentBox.y1 - previewsHeight) * .5;\n            y = Math.max(y, 0);\n            y = Math.min(y, this.panel.monitor.height - previewsHeight);\n        } else {\n            x = sourceAllocation.x1 + appIconMargin - this.panel.monitor.x + (sourceContentBox.x2 - sourceContentBox.x1 - previewsWidth) * .5;\n            x = Math.max(x, 0);\n            x = Math.min(x, this.panel.monitor.width - previewsWidth);\n        }\n\n        if (!this.opened) {\n            this.menu.set_position(x, y);\n            this.menu.set_size(previewsWidth, previewsHeight);\n        } else {\n            Utils.animate(this.menu, getTweenOpts({ x: x, y: y, width: previewsWidth, height: previewsHeight }));\n        }\n    }\n\n    _updateScrollFade(remove) {\n        let [value, upper, pageSize] = this._getScrollAdjustmentValues();\n        let needsFade = Math.round(upper) > Math.round(pageSize);\n        let fadeWidgets = this.menu.get_children().filter(c => c != this._scrollView);\n        \n        if (!remove && needsFade) {\n            if (!fadeWidgets.length) {\n                fadeWidgets.push(this._getFadeWidget());\n                fadeWidgets.push(this._getFadeWidget(true));\n    \n                this.menu.add_child(fadeWidgets[0]);\n                this.menu.add_child(fadeWidgets[1]);\n            }\n            \n            fadeWidgets[0].visible = value > 0;\n            fadeWidgets[1].visible = value + pageSize < upper;\n        } else if (remove || (!needsFade && fadeWidgets.length)) {\n            fadeWidgets.forEach(fw => fw.destroy());\n        }\n    }\n\n    _getScrollAdjustmentValues() {\n        let [value , , upper, , , pageSize] = this._scrollView[(this.isVertical ? 'v' : 'h') + 'adjustment'].get_values();\n\n        return [value, upper, pageSize];\n    }\n\n    _getFadeWidget(end) {\n        let x = 0, y = 0;\n        let startBg = Utils.getrgbaColor(this.panel.dynamicTransparency.backgroundColorRgb, Math.min(alphaBg + .1, 1));\n        let endBg = Utils.getrgbaColor(this.panel.dynamicTransparency.backgroundColorRgb, 0)\n        let fadeStyle = 'background-gradient-start:' + startBg + \n                        'background-gradient-end:' + endBg + \n                        'background-gradient-direction:' + this.panel.getOrientation();\n\n        if (this.isVertical) {\n            y = end ? this.panel.monitor.height - FADE_SIZE : 0;\n        } else {\n            x = end ? this.panel.monitor.width - FADE_SIZE : 0;\n        }\n\n        let fadeWidget = new St.Widget({ \n            reactive: false, \n            pivot_point: new Graphene.Point({ x: .5, y: .5 }), \n            rotation_angle_z: end ? 180 : 0,\n            style: fadeStyle,\n            x: x, y: y,\n            width: this.isVertical ? this.width : FADE_SIZE, \n            height: this.isVertical ? FADE_SIZE : this.height\n        });\n\n        return fadeWidget;\n    }\n\n    _getPreviewsSize() {\n        let previewsWidth = 0;\n        let previewsHeight = 0;\n\n        this._box.get_children().forEach(c => {\n            if (!c.animatingOut) {\n                let [width, height] = c.getSize();\n\n                if (this.isVertical) {\n                    previewsWidth = Math.max(width, previewsWidth);\n                    previewsHeight += height;\n                } else {\n                    previewsWidth += width;\n                    previewsHeight = Math.max(height, previewsHeight);\n                }\n            }\n        });\n\n        return [previewsWidth, previewsHeight];\n    }\n\n    _animateOpenOrClose(show, onComplete) {\n        let isTranslationAnimation = this.menu[this._translationProp] != 0;\n        let tweenOpts = {\n            opacity: show ? 255 : 0,\n            transition: show ? 'easeInOutQuad' : 'easeInCubic',\n            onComplete: () => {\n                if (isTranslationAnimation) {\n                    Main.layoutManager._queueUpdateRegions();\n                }\n                \n                (onComplete || (() => {}))();\n            }\n        };\n\n        tweenOpts[this._translationProp] = show ? this._translationDirection : this._translationOffset;\n\n        Utils.animate(this.menu, getTweenOpts(tweenOpts));\n    }\n\n    _peek(window) {\n        let currentWorkspace = Utils.getCurrentWorkspace();\n        let windowWorkspace = window.get_workspace();\n        let focusWindow = () => this._focusMetaWindow(SETTINGS.get_int('peek-mode-opacity'), window);\n        \n        this._restorePeekedWindowStack();\n\n        if (this._peekedWindow && windowWorkspace != currentWorkspace) {\n            currentWorkspace.list_windows().forEach(mw => this.animateWindowOpacity(mw, null, 255))\n        }\n\n        this._peekedWindow = window;\n        \n        if (currentWorkspace != windowWorkspace) {\n            this._switchToWorkspaceImmediate(windowWorkspace.index());\n            this._timeoutsHandler.add([T3, 100, focusWindow]);\n        } else {\n            focusWindow();\n        }\n\n        if (this.peekInitialWorkspaceIndex < 0) {\n            this.peekInitialWorkspaceIndex = currentWorkspace.index();\n        }\n    }\n\n    _endPeek(stayHere) {\n        this._timeoutsHandler.remove(T3);\n\n        if (this._peekedWindow) {\n            let immediate = !stayHere && this.peekInitialWorkspaceIndex != Utils.getCurrentWorkspace().index();\n\n            this._restorePeekedWindowStack();\n            this._focusMetaWindow(255, this._peekedWindow, immediate, true);\n            this._peekedWindow = null;\n\n            if (!stayHere) {\n                this._switchToWorkspaceImmediate(this.peekInitialWorkspaceIndex);\n            }\n\n            this.peekInitialWorkspaceIndex = -1;\n        }\n    }\n\n    _switchToWorkspaceImmediate(workspaceIndex) {\n        let workspace = Utils.getWorkspaceByIndex(workspaceIndex);\n        let shouldAnimate = Main.wm._shouldAnimate;\n\n        if (!workspace || (!workspace.list_windows().length && \n            workspaceIndex < Utils.getWorkspaceCount() - 1)) {\n            workspace = Utils.getCurrentWorkspace();\n        }\n\n        Main.wm._shouldAnimate = () => false;\n        workspace.activate(global.display.get_current_time_roundtrip());\n        Main.wm._shouldAnimate = shouldAnimate;\n    }\n\n    _focusMetaWindow(dimOpacity, window, immediate, ignoreFocus) {\n        window.get_workspace().list_windows().forEach(mw => {\n            let wa = mw.get_compositor_private();\n            let isFocused = !ignoreFocus && mw == window;\n\n            if (wa) {\n                if (isFocused) {\n                    mw[PEEK_INDEX_PROP] = wa.get_parent().get_children().indexOf(wa);\n                    wa.get_parent().set_child_above_sibling(wa, null);\n                }\n\n                if (isFocused && mw.minimized) {\n                    wa.show();\n                }\n\n                this.animateWindowOpacity(mw, wa, isFocused ? 255 : dimOpacity, immediate)\n            }\n        });\n    }\n\n    animateWindowOpacity(metaWindow, windowActor, opacity, immediate) {\n        windowActor = windowActor || metaWindow.get_compositor_private();\n        \n        if (windowActor && !metaWindow.minimized) {\n            let tweenOpts = getTweenOpts({ opacity });\n\n            if (immediate && !metaWindow.is_on_all_workspaces()) {\n                tweenOpts.time = 0;\n            }\n            \n            Utils.animateWindowOpacity(windowActor, tweenOpts);\n        }\n    }\n\n    _restorePeekedWindowStack() {\n        let windowActor = this._peekedWindow ? this._peekedWindow.get_compositor_private() : null;\n\n        if (windowActor) {\n            if (this._peekedWindow.hasOwnProperty(PEEK_INDEX_PROP)) {\n                windowActor.get_parent().set_child_at_index(windowActor, this._peekedWindow[PEEK_INDEX_PROP]);\n                delete this._peekedWindow[PEEK_INDEX_PROP];\n            }\n\n            if (this._peekedWindow.minimized) {\n                windowActor.hide();\n            }\n        }\n    }\n});\n\nexport const Preview = GObject.registerClass({\n}, class Preview extends St.Widget {\n\n    _init(previewMenu) {\n        super._init({ \n            style_class: 'preview-container', \n            reactive: true, \n            track_hover: true,\n            layout_manager: new Clutter.BinLayout()\n        });\n\n        this.window = null;\n        this._waitWindowId = 0;\n        this._needsCloseButton = true;\n        this.cloneWidth = this.cloneHeight = 0;\n        this._previewMenu = previewMenu;\n        this._padding = SETTINGS.get_int('window-preview-padding') * scaleFactor;\n        this._previewDimensions = this._getPreviewDimensions();\n        this.animatingOut = false;\n\n        let box = new St.Widget({ layout_manager: new Clutter.BoxLayout({ orientation: Clutter.Orientation.VERTICAL }), y_expand: true });\n        let [previewBinWidth, previewBinHeight] = this._getBinSize();\n        let closeButton = new St.Button({ style_class: 'window-close', accessible_name: 'Close window' });\n\n        closeButton.add_child(new St.Icon({ icon_name: 'window-close-symbolic' }));\n\n        this._closeButtonBin = new St.Widget({ \n            style_class: 'preview-close-btn-container',\n            layout_manager: new Clutter.BinLayout(), \n            opacity: 0, \n            x_expand: true, y_expand: true, \n            x_align: Clutter.ActorAlign[isLeftButtons ? 'START' : 'END'], \n            y_align: Clutter.ActorAlign[isTopHeader ? 'START' : 'END']\n        });\n\n        this._closeButtonBin.add_child(closeButton);\n\n        this._previewBin = new St.Widget({ \n            layout_manager: new Clutter.BinLayout(),\n            x_expand: true, y_expand: true, \n            style: 'padding: ' + this._padding / scaleFactor + 'px;'\n        });\n\n        this._previewBin.set_size(previewBinWidth, previewBinHeight);\n\n        box.add_child(this._previewBin);\n        \n        if (headerHeight) {\n            let headerBox = new St.Widget({\n                style_class: 'preview-header-box',\n                layout_manager: new Clutter.BoxLayout(), \n                x_expand: true, \n                y_align: Clutter.ActorAlign[isTopHeader ? 'START' : 'END']\n            });\n            \n            setStyle(headerBox, this._getBackgroundColor(HEADER_COLOR_OFFSET, 1));\n            this._workspaceIndicator = new St.Label({ y_align: Clutter.ActorAlign.CENTER });\n            this._windowTitle = new St.Label({ y_align: Clutter.ActorAlign.CENTER, x_expand: true });\n\n            this._iconBin = new St.Widget({ layout_manager: new Clutter.BinLayout() });\n            this._iconBin.set_size(headerHeight, headerHeight);\n    \n            headerBox.add_child(this._iconBin);\n            headerBox.insert_child_at_index(this._workspaceIndicator, isLeftButtons ? 0 : 1);\n            headerBox.insert_child_at_index(this._windowTitle, isLeftButtons ? 1 : 2);\n\n            box.insert_child_at_index(headerBox, isTopHeader ? 0 : 1);\n        }\n\n        this.add_child(box);\n        this.add_child(this._closeButtonBin);\n\n        closeButton.connect('clicked', () => this._onCloseBtnClick());\n        this.connect('notify::hover', () => this._onHoverChanged());\n        this.connect('button-release-event', (actor, e) => this._onButtonReleaseEvent(e));\n        this.connect('destroy', () => this._onDestroy());\n    }\n\n    adjustOnStage() {\n        let closeButton = this._closeButtonBin.get_first_child();\n        let closeButtonHeight = closeButton.height;\n        let maxCloseButtonSize = MAX_CLOSE_BUTTON_SIZE * scaleFactor;\n        let closeButtonBorderRadius = '';\n\n        if (closeButtonHeight > maxCloseButtonSize) {\n            closeButtonHeight = maxCloseButtonSize;\n            closeButton.set_size(closeButtonHeight, closeButtonHeight);\n        }\n\n        if (!headerHeight) {\n            closeButtonBorderRadius = 'border-radius: ';\n            \n            if (isTopHeader) {\n                closeButtonBorderRadius += (isLeftButtons ? '0 0 4px 0;' : '0 0 0 4px;');\n            } else {\n                closeButtonBorderRadius += (isLeftButtons ? '0 4px 0 0;' : '4px 0 0 0;');\n            }\n        }\n\n        setStyle(\n            this._closeButtonBin,\n            'padding: ' + (headerHeight ? Math.round((headerHeight - closeButtonHeight) * .5 / scaleFactor) : 4) + 'px;' +\n            this._getBackgroundColor(HEADER_COLOR_OFFSET, headerHeight ? 1 : .6) +\n            closeButtonBorderRadius\n        );\n    }\n\n    assignWindow(window, animateSize) {\n        if (this.window != window) {\n            let _assignWindowClone = () => {\n                if (window.get_compositor_private()) {\n                    let cloneBin = this._getWindowCloneBin(window);\n                    \n                    this._resizeClone(cloneBin, window);\n                    this._addClone(cloneBin, animateSize);\n                    this._previewMenu.updatePosition();\n                } else if (!this._waitWindowId) {\n                    this._waitWindowId = GLib.idle_add(GLib.PRIORITY_DEFAULT_IDLE, () => {\n                        this._waitWindowId = 0;\n\n                        if (this._previewMenu.opened) {\n                            _assignWindowClone();\n                        }\n\n                        return GLib.SOURCE_REMOVE;\n                    });\n                }\n            };\n\n            _assignWindowClone();\n        }\n\n        this._cancelAnimateOut();\n        this._removeWindowSignals();\n        this.window = window;\n        this._needsCloseButton = this._previewMenu.allowCloseWindow && window.can_close() && !Utils.checkIfWindowHasTransient(window);\n        this._updateHeader();\n    }\n\n    animateOut() {\n        if (!this.animatingOut) {\n            let tweenOpts = getTweenOpts({ opacity: 0, width: 0, height: 0, onComplete: () => this.destroy() });\n\n            this.animatingOut = true;\n\n            Utils.stopAnimations(this);\n            Utils.animate(this, tweenOpts);\n        }\n    }\n\n    getSize() {\n        let [binWidth, binHeight] = this._getBinSize();\n\n        binWidth = Math.max(binWidth, this.cloneWidth + this._padding * 2);\n        binHeight = Math.max(binHeight, this.cloneHeight + this._padding * 2) + headerHeight;\n\n        return [binWidth, binHeight];\n    }\n\n    setFocus(focused) {\n        this._hideOrShowCloseButton(!focused);\n        setStyle(this, this._getBackgroundColor(FOCUSED_COLOR_OFFSET, focused ? '-' : 0));\n\n        if (focused) {\n            this._previewMenu.ensureVisible(this);\n            this._previewMenu.requestPeek(this.window);\n        }\n    }\n\n    activate() {\n        this._previewMenu.endPeekHere();\n        this._previewMenu.close();\n        Main.activateWindow(this.window);\n    }\n\n    _onDestroy() {\n        if (this._waitWindowId) {\n            GLib.source_remove(this._waitWindowId);\n            this._waitWindowId = 0;\n        }\n\n        this._removeWindowSignals();\n    }\n\n    _onHoverChanged() {\n        this.setFocus(this.hover);\n    }\n\n    _onCloseBtnClick() {\n        this._hideOrShowCloseButton(true);\n        this.reactive = false;\n\n        if (!SETTINGS.get_boolean('group-apps')) {\n            this._previewMenu.close();\n        } else {\n            this._previewMenu.endPeekHere();\n        }\n\n        this.window.delete(global.get_current_time());\n    }\n\n    _onButtonReleaseEvent(e) {\n        switch (e.get_button()) {\n            case 1: // Left click\n                this.activate();\n                break;\n            case 2: // Middle click\n                if (SETTINGS.get_boolean('preview-middle-click-close')) {\n                    this._onCloseBtnClick();\n                }\n                break;\n            case 3: // Right click\n                this._showContextMenu(e);\n                break;\n        }\n\n        return Clutter.EVENT_STOP;\n    }\n\n    _cancelAnimateOut() {\n        if (this.animatingOut) {\n            this.animatingOut = false;\n\n            Utils.stopAnimations(this);\n            Utils.animate(this, getTweenOpts({ opacity: 255, width: this.cloneWidth, height: this.cloneHeight }));\n        }\n    }\n\n    _showContextMenu(e) {\n        let coords = e.get_coords();\n        let currentWorkspace = this._previewMenu.peekInitialWorkspaceIndex < 0 ? \n                               Utils.getCurrentWorkspace() : \n                               Utils.getWorkspaceByIndex(this._previewMenu.peekInitialWorkspaceIndex);\n\n        Main.wm._showWindowMenu(null, this.window, Meta.WindowMenuType.WM, {\n            x: coords[0],\n            y: coords[1],\n            width: 0,\n            height: 0\n        });\n\n        let menu = Main.wm._windowMenuManager._manager._menus[0];\n\n        menu.connect('open-state-changed', () => this._previewMenu.menu.sync_hover());\n        this._previewMenu.menu.sync_hover();\n\n        if (this.window.get_workspace() != currentWorkspace) {\n            let menuItem = new PopupMenu.PopupMenuItem(_('Move to current Workspace') + ' [' + (currentWorkspace.index() + 1) + ']');\n            let menuItems = menu.box.get_children();\n            let insertIndex = Utils.findIndex(menuItems, c => c._delegate instanceof PopupMenu.PopupSeparatorMenuItem);\n\n            insertIndex = insertIndex >= 0 ? insertIndex : menuItems.length - 1;\n            menu.addMenuItem(menuItem, insertIndex);\n            menuItem.connect('activate', () => this.window.change_workspace(currentWorkspace));\n        }\n    }\n\n    _removeWindowSignals() {\n        if (this._titleWindowChangeId) {\n            this.window.disconnect(this._titleWindowChangeId);\n            this._titleWindowChangeId = 0;\n        }\n    }\n\n    _updateHeader() {\n        if (headerHeight) {\n            let iconTextureSize = SETTINGS.get_boolean('window-preview-use-custom-icon-size') ? \n                                  SETTINGS.get_int('window-preview-custom-icon-size') : \n                                  headerHeight / scaleFactor * .6;\n            let icon = this._previewMenu.getCurrentAppIcon().app.create_icon_texture(iconTextureSize);\n            let workspaceIndex = '';\n            let workspaceStyle = null;\n            let fontScale = DESKTOPSETTINGS.get_double('text-scaling-factor');\n            let commonTitleStyles = 'color: ' + SETTINGS.get_string('window-preview-title-font-color') + ';' +\n                                    'font-size: ' + SETTINGS.get_int('window-preview-title-font-size') * fontScale + 'px;' +\n                                    'font-weight: ' + SETTINGS.get_string('window-preview-title-font-weight') + ';';\n            \n            this._iconBin.destroy_all_children();\n            this._iconBin.add_child(icon);\n\n            if (!SETTINGS.get_boolean('isolate-workspaces')) {\n                workspaceIndex = (this.window.get_workspace().index() + 1).toString();\n                workspaceStyle = 'margin: 0 4px 0 ' + (isLeftButtons ? Math.round((headerHeight - icon.width) * .5) + 'px' : '0') + '; padding: 0 4px;' +  \n                                 'border: 2px solid ' + this._getRgbaColor(FOCUSED_COLOR_OFFSET, .8) + 'border-radius: 2px;' + commonTitleStyles;\n            }\n    \n            this._workspaceIndicator.text = workspaceIndex; \n            setStyle(this._workspaceIndicator, workspaceStyle);\n\n            this._titleWindowChangeId = this.window.connect('notify::title', () => this._updateWindowTitle());\n            setStyle(this._windowTitle, 'max-width: 0px; padding-right: 4px;' + commonTitleStyles);\n            this._updateWindowTitle();\n        }\n    }\n\n    _updateWindowTitle() {\n        this._windowTitle.text = this.window.title;\n    }\n\n    _hideOrShowCloseButton(hide) {\n        if (this._needsCloseButton) {\n            Utils.animate(this._closeButtonBin, getTweenOpts({ opacity: hide ? 0 : 255 }));\n        }\n    }\n\n    _getBackgroundColor(offset, alpha) {\n        return 'background-color: ' + this._getRgbaColor(offset, alpha) + \n               'transition-duration:' + this._previewMenu.panel.dynamicTransparency.animationDuration;\n    }\n\n    _getRgbaColor(offset, alpha) {\n        alpha = Math.abs(alpha);\n\n        if (isNaN(alpha)) {\n            alpha = alphaBg;\n        }\n\n        return Utils.getrgbaColor(this._previewMenu.panel.dynamicTransparency.backgroundColorRgb, alpha, offset);\n    }\n\n    _addClone(newCloneBin, animateSize) {\n        let currentClones = this._previewBin.get_children();\n        let newCloneOpts = getTweenOpts({ opacity: 255 });\n        \n        this._previewBin.add_child(newCloneBin);\n\n        if (currentClones.length) {\n            let currentCloneBin = currentClones.pop();\n            let currentCloneOpts = getTweenOpts({ opacity: 0, onComplete: () => currentCloneBin.destroy() });\n\n            if (newCloneBin.width > currentCloneBin.width) {\n                newCloneOpts.width = newCloneBin.width;\n                newCloneBin.width = currentCloneBin.width;\n            } else {\n                currentCloneOpts.width = newCloneBin.width;\n            }\n\n            if (newCloneBin.height > currentCloneBin.height) {\n                newCloneOpts.height = newCloneBin.height;\n                newCloneBin.height = currentCloneBin.height;\n            } else {\n                currentCloneOpts.height = newCloneBin.height;\n            }\n\n            currentClones.forEach(c => c.destroy());\n            Utils.animate(currentCloneBin, currentCloneOpts);\n        } else if (animateSize) {\n            newCloneBin.width = 0;\n            newCloneBin.height = 0;\n            newCloneOpts.width = this.cloneWidth;\n            newCloneOpts.height = this.cloneHeight;\n        }\n\n        Utils.animate(newCloneBin, newCloneOpts);\n    }\n    \n    _getWindowCloneBin(window) {\n        let frameRect = window.get_frame_rect();\n        let bufferRect = window.get_buffer_rect();\n        let clone = new Clutter.Clone({ source: window.get_compositor_private() });\n        let cloneBin = new St.Widget({ \n            opacity: 0,\n            layout_manager: frameRect.width != bufferRect.width || \n                            frameRect.height != bufferRect.height ?\n                            new WindowCloneLayout(frameRect, bufferRect) :\n                            new Clutter.BinLayout()\n        });\n        \n        cloneBin.add_child(clone);\n\n        return cloneBin;\n    }\n\n    _getBinSize() {\n        let [fixedWidth, fixedHeight] = this._previewDimensions;\n\n        return [\n            aspectRatio.x.fixed ? fixedWidth + this._padding * 2 : -1,\n            aspectRatio.y.fixed ? fixedHeight + this._padding * 2 : -1\n        ];\n    }\n\n    _resizeClone(cloneBin, window) {\n        let frameRect = cloneBin.layout_manager.frameRect || window.get_frame_rect();\n        let [fixedWidth, fixedHeight] = this._previewDimensions;\n        let ratio = Math.min(fixedWidth / frameRect.width, fixedHeight / frameRect.height, 1);\n        let cloneWidth = frameRect.width * ratio;\n        let cloneHeight = frameRect.height * ratio;\n        \n        let clonePaddingTB = cloneHeight < MIN_DIMENSION ? MIN_DIMENSION - cloneHeight : 0;\n        let clonePaddingLR = cloneWidth < MIN_DIMENSION ? MIN_DIMENSION - cloneWidth : 0;\n        let clonePaddingTop = clonePaddingTB * .5;\n        let clonePaddingLeft = clonePaddingLR * .5;\n        \n        this.cloneWidth = cloneWidth + clonePaddingLR * scaleFactor;\n        this.cloneHeight = cloneHeight + clonePaddingTB * scaleFactor;\n\n        cloneBin.set_style('padding: ' + clonePaddingTop + 'px ' + clonePaddingLeft + 'px;');\n        cloneBin.layout_manager.ratio = ratio;\n        cloneBin.layout_manager.padding = [clonePaddingLeft * scaleFactor, clonePaddingTop * scaleFactor];\n\n        cloneBin.get_first_child().set_size(cloneWidth, cloneHeight);\n    }\n\n    _getPreviewDimensions() {\n        let size = SETTINGS.get_int('window-preview-size') * scaleFactor;\n        let w, h;\n\n        if (this._previewMenu.isVertical) {\n            w = size;\n            h = w * aspectRatio.y.size / aspectRatio.x.size;\n        } else {\n            h = size;\n            w = h * aspectRatio.x.size / aspectRatio.y.size;\n        }\n\n        return [w, h];\n    }\n});\n\nexport const WindowCloneLayout = GObject.registerClass({\n}, class WindowCloneLayout extends Clutter.BinLayout {\n\n    _init(frameRect, bufferRect) {\n        super._init();\n\n        //the buffer_rect contains the transparent padding that must be removed\n        this.frameRect = frameRect;\n        this.bufferRect = bufferRect;\n    }\n\n    vfunc_allocate(actor, box) {\n        let [width, height] = box.get_size();\n\n        box.set_origin(\n            (this.bufferRect.x - this.frameRect.x) * this.ratio + this.padding[0], \n            (this.bufferRect.y - this.frameRect.y) * this.ratio + this.padding[1]\n        );\n\n        box.set_size(\n            width + (this.bufferRect.width - this.frameRect.width) * this.ratio, \n            height + (this.bufferRect.height - this.frameRect.height) * this.ratio\n        );\n\n        actor.get_first_child().allocate(box);\n    }\n});\n\nexport function setStyle(actor, style) {\n    if (!isManualStyling) {\n        actor.set_style(style);\n    }\n}\n\nexport function getTweenOpts(opts) {\n    let defaults = {\n        time: animationTime,\n        transition: 'easeInOutQuad'\n    };\n\n    return Utils.mergeObjects(opts || {}, defaults);\n}\n"
        }
      ]
    }
  ]
}