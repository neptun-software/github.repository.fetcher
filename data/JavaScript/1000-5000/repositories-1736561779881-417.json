{
  "metadata": {
    "timestamp": 1736561779881,
    "page": 417,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "micheleg/dash-to-dock",
      "stars": 3929,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".eslintrc.yml",
          "type": "blob",
          "size": 0.6494140625,
          "content": "ignorePatterns:\n  - _build/**\n\nextends:\n - ./lint/eslintrc-gjs.yml\n - ./lint/eslintrc-shell.yml\n\noverrides:\n  - files: ./*.js\n    globals:\n      global: readonly\n      _: readonly\n      C_: readonly\n      N_: readonly\n      ngettext: readonly\n\n    rules:\n      prefer-const: error\n      prefer-destructuring: warn\n      guard-for-in: error\n      max-len:\n        - error\n        - code: 110\n          ignoreUrls: true\n          ignoreTemplateLiterals: true\n\n      comma-dangle:\n        - error\n        - arrays: always-multiline\n          objects: always-multiline\n          imports: always-multiline\n          functions: never\n\nparserOptions:\n  sourceType: module\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1142578125,
          "content": ".~\n*~\ngschemas.compiled\ndash-to-dock@micxgx.gmail.com.zip\n*.mo\npo/dashtodock.pot\nstylesheet.css\nSettings.ui.h\n_build\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.390625,
          "content": "# Basic Makefile\n\nUUID = dash-to-dock@micxgx.gmail.com\nBASE_MODULES = extension.js \\\n               metadata.json \\\n               COPYING \\\n               README.md \\\n               $(NULL)\n\nEXTRA_MODULES = \\\n                appSpread.js \\\n                dash.js \\\n                docking.js \\\n                appIcons.js \\\n\t\t\t\tappIconsDecorator.js \\\n                appIconIndicators.js \\\n                fileManager1API.js \\\n                imports.js \\\n                launcherAPI.js \\\n                locations.js \\\n                locationsWorker.js \\\n                notificationsMonitor.js \\\n                windowPreview.js \\\n                intellihide.js \\\n                prefs.js \\\n                theming.js \\\n                utils.js \\\n                dbusmenuUtils.js \\\n                desktopIconsIntegration.js \\\n                Settings.ui \\\n                $(NULL)\n\nEXTRA_MEDIA = logo.svg \\\n              glossy.svg \\\n              highlight_stacked_bg.svg \\\n              highlight_stacked_bg_h.svg \\\n              $(NULL)\n\nTOLOCALIZE =  prefs.js \\\n\t\t\t  docking.js \\\n              appIcons.js \\\n              appIconsDecorator.js \\\n              locations.js \\\n              $(NULL)\n\nMSGSRC = $(wildcard po/*.po)\nifeq ($(strip $(DESTDIR)),)\n\tINSTALLTYPE = local\n\tINSTALLBASE = $(HOME)/.local/share/gnome-shell/extensions\nelse\n\tINSTALLTYPE = system\n\tSHARE_PREFIX = $(DESTDIR)/usr/share\n\tINSTALLBASE = $(SHARE_PREFIX)/gnome-shell/extensions\nendif\nINSTALLNAME = dash-to-dock@micxgx.gmail.com\n\n# The command line passed variable VERSION is used to set the version string\n# in the metadata and in the generated zip-file. If no VERSION is passed, the\n# current commit SHA1 is used as version number in the metadata while the\n# generated zip file has no string attached.\nifdef VERSION\n\tVSTRING = _v$(VERSION)\nelse\n\tVERSION = $(shell git rev-parse HEAD)\n\tVSTRING =\nendif\n\nall: extension\n\nclean:\n\trm -f ./schemas/gschemas.compiled\n\trm -f stylesheet.css\n\trm -rf _build\n\nextension: ./schemas/gschemas.compiled ./stylesheet.css $(MSGSRC:.po=.mo)\n\n./schemas/gschemas.compiled: ./schemas/org.gnome.shell.extensions.dash-to-dock.gschema.xml\n\tglib-compile-schemas ./schemas/\n\npotfile: ./po/dashtodock.pot\n\nmergepo: potfile\n\tfor l in $(MSGSRC); do \\\n\t\tmsgmerge -U $$l ./po/dashtodock.pot; \\\n\tdone;\n\n./po/dashtodock.pot: $(TOLOCALIZE) Settings.ui\n\tmkdir -p po\n\txgettext --keyword=__ --keyword=N__ --add-comments='Translators:' -o po/dashtodock.pot --package-name \"Dash to Dock\" --from-code=utf-8 $(TOLOCALIZE)\n\tintltool-extract --type=gettext/glade Settings.ui\n\txgettext --keyword=_ --keyword=N_ --join-existing -o po/dashtodock.pot Settings.ui.h\n\n./po/%.mo: ./po/%.po\n\tmsgfmt -c $< -o $@\n\n./stylesheet.css: ./_stylesheet.scss\nifeq ($(SASS), ruby)\n\tsass --sourcemap=none --no-cache --scss _stylesheet.scss stylesheet.css\nelse ifeq ($(SASS), dart)\n\tsass --no-source-map _stylesheet.scss stylesheet.css\nelse ifeq ($(SASS), sassc)\n\tsassc --omit-map-comment _stylesheet.scss stylesheet.css\nelse\n\tsassc --omit-map-comment _stylesheet.scss stylesheet.css\nendif\n\ninstall: install-local\n\ninstall-local: _build\n\trm -rf $(INSTALLBASE)/$(INSTALLNAME)\n\tmkdir -p $(INSTALLBASE)/$(INSTALLNAME)\n\tcp -r ./_build/* $(INSTALLBASE)/$(INSTALLNAME)/\nifeq ($(INSTALLTYPE),system)\n\t# system-wide settings and locale files\n\trm -r $(INSTALLBASE)/$(INSTALLNAME)/schemas $(INSTALLBASE)/$(INSTALLNAME)/locale\n\tmkdir -p $(SHARE_PREFIX)/glib-2.0/schemas $(SHARE_PREFIX)/locale\n\tcp -r ./schemas/*gschema.* $(SHARE_PREFIX)/glib-2.0/schemas\n\tcp -r ./_build/locale/* $(SHARE_PREFIX)/locale\nendif\n\t-rm -fR _build\n\techo done\n\nzip-file: _build check\n\tcd _build ; \\\n\tzip -qr \"$(UUID)$(VSTRING).zip\" .\n\tmv _build/$(UUID)$(VSTRING).zip ./\n\t-rm -fR _build\n\n_build: all\n\t-rm -fR ./_build\n\tmkdir -p _build\n\tcp $(BASE_MODULES) $(EXTRA_MODULES) _build\n\tcp -a dependencies _build\n\tcp stylesheet.css _build\n\tmkdir -p _build/media\n\tcd media ; cp $(EXTRA_MEDIA) ../_build/media/\n\tmkdir -p _build/schemas\n\tcp schemas/*.xml _build/schemas/\n\tcp schemas/gschemas.compiled _build/schemas/\n\tmkdir -p _build/locale\n\tfor l in $(MSGSRC:.po=.mo) ; do \\\n\t\tlf=_build/locale/`basename $$l .mo`; \\\n\t\tmkdir -p $$lf; \\\n\t\tmkdir -p $$lf/LC_MESSAGES; \\\n\t\tcp $$l $$lf/LC_MESSAGES/dashtodock.mo; \\\n\tdone;\n\tsed -i 's/\"version\": -1/\"version\": \"$(VERSION)\"/'  _build/metadata.json;\n\nifeq ($(strip $(ESLINT)),)\n    ESLINT = eslint\nendif\n\nifneq ($(strip $(ESLINT_TAP)),)\n    ESLINT_ARGS = -f tap\nendif\n\ncheck:\n\tESLINT_USE_FLAT_CONFIG=false $(ESLINT) $(ESLINT_ARGS) .\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.373046875,
          "content": "# Dash to Dock\n![screenshot](https://github.com/micheleg/dash-to-dock/raw/master/media/screenshot.jpg)\n\n## A dock for the GNOME Shell\nThis extension enhances the dash moving it out of the overview and transforming it in a dock for an easier launching of applications and a faster switching between windows and desktops without having to leave the desktop view.\n\n[<img src=\"https://micheleg.github.io/dash-to-dock/media/get-it-on-ego.png\" height=\"100\">](https://extensions.gnome.org/extension/307/dash-to-dock)\n\nFor additional installation instructions and more information visit [https://micheleg.github.io/dash-to-dock/](https://micheleg.github.io/dash-to-dock/).\n\n## Installation from source\n\nThe extension can be installed directly from source, either for the convenience of using git or to test the latest development version. Clone the desired branch with git\n\n### Build Dependencies\n\nTo compile the stylesheet you'll need an implementation of SASS. Dash to Dock supports `dart-sass` (`sass`), `sassc`, and `ruby-sass`. Every distro should have at least one of these implementations, we recommend using `dart-sass` (`sass`) or `sassc` over `ruby-sass` as `ruby-sass` is deprecated.\n\nBy default, Dash to Dock will attempt to build with `sassc`. To change this behavior set the `SASS` environment variable to either `dart` or `ruby`.\n\n```bash\nexport SASS=dart\n# or...\nexport SASS=ruby\n```\n\n### Building\n\nClone the repository or download the branch from github. A simple Makefile is included.\n\nNext use `make` to install the extension into your home directory. A Shell reload is required `Alt+F2 r Enter` under Xorg or under Wayland you may have to logout and login. The extension has to be enabled  with *gnome-extensions-app* (GNOME Extensions) or with *dconf*.\n\n```bash\ngit clone https://github.com/micheleg/dash-to-dock.git\nmake -C dash-to-dock install\n```\n\nIf `msgfmt` is not available on your system, you will see an error message like the following:\n\n```bash\nmake: msgfmt: No such file or directory\n```\n\nIn this case install the `gettext` package from your distribution's repository.\n\n\n## Bug Reporting\n\nBugs should be reported to the Github bug tracker [https://github.com/micheleg/dash-to-dock/issues](https://github.com/micheleg/dash-to-dock/issues).\n\n## License\nDash to Dock Gnome Shell extension is distributed under the terms of the GNU General Public License,\nversion 2 or later. See the COPYING file for details.\n"
        },
        {
          "name": "Settings.ui",
          "type": "blob",
          "size": 163.970703125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<interface>\n  <requires lib=\"gtk\" version=\"4.0\"/>\n  <object class=\"GtkAdjustment\" id=\"animation_time_adjustment\">\n    <property name=\"upper\">1</property>\n    <property name=\"step-increment\">0.050000000000000003</property>\n    <property name=\"page-increment\">0.25</property>\n  </object>\n  <object class=\"GtkBox\" id=\"box_middle_click_options\">\n    <property name=\"can_focus\">0</property>\n    <property name=\"margin_start\">12</property>\n    <property name=\"margin_end\">12</property>\n    <property name=\"margin_top\">12</property>\n    <property name=\"margin_bottom\">12</property>\n    <property name=\"orientation\">vertical</property>\n    <child>\n      <object class=\"GtkFrame\" id=\"frame_middle_click_options\">\n        <property name=\"can_focus\">0</property>\n        <property name=\"child\">\n          <object class=\"GtkListBox\" id=\"listbox_middle_click_options\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"hexpand\">1</property>\n            <property name=\"vexpand\">1</property>\n            <property name=\"selection_mode\">none</property>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow11\">\n                <property name=\"width_request\">100</property>\n                <property name=\"height_request\">80</property>\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"buitin_theme7\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"builtin_theme_description4\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">When set to minimize, double clicking minimizes all the windows of the application.</property>\n                        <property name=\"wrap\">1</property>\n                        <property name=\"xalign\">0</property>\n                        <property name=\"max_width_chars\">40</property>\n\n                        <style>\n                          <class name=\"dim-label\"/>\n                        </style>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"builtin_theme_label4\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Shift+Click action</property>\n                        <property name=\"xalign\">0</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkComboBoxText\" id=\"shift_click_action_combo\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"valign\">center</property>\n                        <items>\n                          <item translatable=\"yes\">Raise window</item>\n                          <item translatable=\"yes\">Minimize window</item>\n                          <item translatable=\"yes\">Launch new instance</item>\n                          <item translatable=\"yes\">Cycle through windows</item>\n                          <item translatable=\"yes\">Minimize or overview</item>\n                          <item translatable=\"yes\">Show window previews</item>\n                          <item translatable=\"yes\">Minimize or show previews</item>\n                          <item translatable=\"yes\">Focus or show previews</item>\n                          <item translatable=\"yes\">Focus or app spread</item>\n                          <item translatable=\"yes\">Focus, minimize or show previews</item>\n                          <item translatable=\"yes\">Focus, minimize or app spread</item>\n                          <item translatable=\"yes\">Quit</item>\n                        </items>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                          <property name=\"row-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow_middle_click\">\n                <property name=\"width_request\">100</property>\n                <property name=\"height_request\">80</property>\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"grid_middle_click\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"description_middle_click\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Behavior for Middle-Click.</property>\n                        <property name=\"wrap\">1</property>\n                        <property name=\"xalign\">0</property>\n                        <property name=\"max_width_chars\">40</property>\n\n                        <style>\n                          <class name=\"dim-label\"/>\n                        </style>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"label_middle_click\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Middle-Click action</property>\n                        <property name=\"xalign\">0</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkComboBoxText\" id=\"middle_click_action_combo\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"valign\">center</property>\n                        <items>\n                          <item translatable=\"yes\">Raise window</item>\n                          <item translatable=\"yes\">Minimize window</item>\n                          <item translatable=\"yes\">Launch new instance</item>\n                          <item translatable=\"yes\">Cycle through windows</item>\n                          <item translatable=\"yes\">Minimize or overview</item>\n                          <item translatable=\"yes\">Show window previews</item>\n                          <item translatable=\"yes\">Minimize or show previews</item>\n                          <item translatable=\"yes\">Focus or show previews</item>\n                          <item translatable=\"yes\">Focus or app spread</item>\n                          <item translatable=\"yes\">Focus, minimize or show previews</item>\n                          <item translatable=\"yes\">Focus, minimize or app spread</item>\n                          <item translatable=\"yes\">Quit</item>\n                        </items>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                          <property name=\"row-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow_shift_middle_click\">\n                <property name=\"width_request\">100</property>\n                <property name=\"height_request\">80</property>\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"grid_shift_middle_click\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"description_shift_middle_click\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Behavior for Shift+Middle-Click.</property>\n                        <property name=\"wrap\">1</property>\n                        <property name=\"xalign\">0</property>\n                        <property name=\"max_width_chars\">40</property>\n\n                        <style>\n                          <class name=\"dim-label\"/>\n                        </style>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"label_shift_middle_click\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Shift+Middle-Click action</property>\n                        <property name=\"xalign\">0</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkComboBoxText\" id=\"shift_middle_click_action_combo\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"valign\">center</property>\n                        <items>\n                          <item translatable=\"yes\">Raise window</item>\n                          <item translatable=\"yes\">Minimize window</item>\n                          <item translatable=\"yes\">Launch new instance</item>\n                          <item translatable=\"yes\">Cycle through windows</item>\n                          <item translatable=\"yes\">Minimize or overview</item>\n                          <item translatable=\"yes\">Show window previews</item>\n                          <item translatable=\"yes\">Minimize or show previews</item>\n                          <item translatable=\"yes\">Focus or show previews</item>\n                          <item translatable=\"yes\">Focus or app spread</item>\n                          <item translatable=\"yes\">Focus, minimize or show previews</item>\n                          <item translatable=\"yes\">Focus, minimize or app spread</item>\n                          <item translatable=\"yes\">Quit</item>\n                        </items>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                          <property name=\"row-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n          </object>\n        </property>\n        <child type=\"label_item\">\n          <placeholder/>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"custom_opacity_adjustement\">\n    <property name=\"upper\">1</property>\n    <property name=\"step-increment\">0.01</property>\n    <property name=\"page-increment\">0.10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"dock_size_adjustment\">\n    <property name=\"lower\">0.33</property>\n    <property name=\"upper\">1</property>\n    <property name=\"step-increment\">0.01</property>\n    <property name=\"page-increment\">0.10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"dot_border_width_adjustment\">\n    <property name=\"upper\">10</property>\n    <property name=\"step-increment\">1</property>\n    <property name=\"page-increment\">5</property>\n  </object>\n  <object class=\"GtkBox\" id=\"running_dots_advance_settings_box\">\n    <property name=\"hexpand\">1</property>\n    <property name=\"vexpand\">1</property>\n    <property name=\"can_focus\">0</property>\n    <property name=\"margin_start\">12</property>\n    <property name=\"margin_end\">12</property>\n    <property name=\"margin_top\">12</property>\n    <property name=\"margin_bottom\">12</property>\n    <property name=\"orientation\">vertical</property>\n    <child>\n      <object class=\"GtkFrame\" id=\"frame1\">\n        <property name=\"can_focus\">0</property>\n\n        <property name=\"child\">\n          <object class=\"GtkListBox\" id=\"listbox7\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"selection_mode\">none</property>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow10\">\n                <property name=\"width_request\">100</property>\n                <property name=\"height_request\">80</property>\n                <property name=\"child\">\n                  <object class=\"GtkBox\" id=\"dot_style_box\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"orientation\">vertical</property>\n                    <property name=\"spacing\">12</property>\n                    <child>\n                      <object class=\"GtkBox\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"spacing\">32</property>\n                        <child>\n                          <object class=\"GtkLabel\" id=\"unity_backlit_items_label\">\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"xalign\">0</property>\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"valign\">center</property>\n                            <property name=\"label\" translatable=\"yes\">Enable Unity7 like glossy backlit items</property>\n\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkSwitch\" id=\"unity_backlit_items_switch\">\n                            <property name=\"valign\">center</property>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkCheckButton\" id=\"apply_gloss_effect_checkbutton\">\n                        <property name=\"label\" translatable=\"yes\">Apply glossy effect.</property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkBox\">\n                        <property name=\"can_focus\">0</property>\n                        <child>\n                          <object class=\"GtkLabel\" id=\"dominant_color_label\">\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"xalign\">0</property>\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"halign\">start</property>\n                            <property name=\"label\" translatable=\"yes\">Use dominant color</property>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkSwitch\" id=\"dominant_color_switch\"/>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkGrid\" id=\"grid1\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"column_spacing\">32</property>\n                        <child>\n                          <object class=\"GtkSwitch\" id=\"dot_style_switch\">\n                            <layout>\n                              <property name=\"column\">1</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkLabel\" id=\"label4\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"xalign\">0</property>\n                            <property name=\"label\" translatable=\"yes\">Customize indicator style</property>\n                            <property name=\"justify\">fill</property>\n\n                            <layout>\n                              <property name=\"column\">0</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkBox\" id=\"dot_style_settings_box\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"margin_bottom\">1</property>\n                        <property name=\"orientation\">vertical</property>\n                        <property name=\"spacing\">12</property>\n                        <child>\n                          <object class=\"GtkBox\" id=\"dot_color_box\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"dot_color_label\">\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"label\" translatable=\"yes\">Color</property>\n\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkColorButton\" id=\"dot_color_colorbutton\">\n                                <property name=\"receives_default\">1</property>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkBox\" id=\"border_color_box\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"dot_border_color_label\">\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"label\" translatable=\"yes\">Border color</property>\n\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkColorButton\" id=\"dot_border_color_colorbutton\">\n                                <property name=\"receives_default\">1</property>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkBox\" id=\"box_boder_width_box\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"dot_border_width_label\">\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"label\" translatable=\"yes\">Border width</property>\n\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"dot_border_width_spin_button\">\n                                <property name=\"adjustment\">dot_border_width_adjustment</property>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n          </object>\n        </property>\n        <child type=\"label_item\">\n          <placeholder/>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"hide_timeout_adjustment\">\n    <property name=\"upper\">1</property>\n    <property name=\"step-increment\">0.050000000000000003</property>\n    <property name=\"page-increment\">0.25</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"icon_size_adjustment\">\n    <property name=\"lower\">16</property>\n    <property name=\"upper\">128</property>\n    <property name=\"step-increment\">1</property>\n    <property name=\"page-increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"preview_size_adjustment\">\n    <property name=\"lower\">0.0</property>\n    <property name=\"upper\">1</property>\n    <property name=\"step_increment\">0.01</property>\n    <property name=\"page_increment\">0.1</property>\n  </object>\n  <object class=\"GtkNotebook\" id=\"settings_notebook\">\n    <property name=\"margin_start\">6</property>\n    <property name=\"margin_end\">6</property>\n    <property name=\"margin_top\">6</property>\n    <property name=\"margin_bottom\">6</property>\n    <child>\n      <object class=\"GtkNotebookPage\">\n        <property name=\"child\">\n          <object class=\"GtkBox\" id=\"position_and_size\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"margin_start\">24</property>\n            <property name=\"margin_end\">24</property>\n            <property name=\"margin_top\">24</property>\n            <property name=\"margin_bottom\">24</property>\n            <property name=\"orientation\">vertical</property>\n            <property name=\"spacing\">24</property>\n            <child>\n              <object class=\"GtkFrame\" id=\"dock_display\">\n                <property name=\"can_focus\">0</property>\n\n                <property name=\"child\">\n                  <object class=\"GtkListBox\" id=\"dock_display_listbox\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"selection_mode\">none</property>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"dock_monitor_listboxrow\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"dock_monitor_grid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"dock_monitor_label\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Show the dock on</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkComboBoxText\" id=\"dock_monitor_combo\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"width_request\">400</property>\n                                <property name=\"valign\">center</property>\n                                <signal name=\"changed\" handler=\"dock_display_combo_changed_cb\" />\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"multi_monitor_button\">\n                                <property name=\"label\" translatable=\"yes\">Show on all monitors</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">2</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <placeholder/>\n                            </child>\n                            <child>\n                              <placeholder/>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"dock_position_listboxrow\">\n                        <property name=\"width_request\">100</property>\n                        <property name=\"child\">\n                          <object class=\"GtkBox\" id=\"dock_position_box\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"dock_position_label\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <property name=\"label\" translatable=\"yes\">Position on screen</property>\n\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkBox\" id=\"dock_position_butttons_box\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"spacing\">32</property>\n                                <child>\n                                  <object class=\"GtkCheckButton\" id=\"position_left_button\">\n                                    <property name=\"label\" translatable=\"yes\">Left</property>\n                                    <property name=\"halign\">end</property>\n                                    <property name=\"valign\">center</property>\n\n                                    <signal name=\"toggled\" handler=\"position_left_button_toggled_cb\" />\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkCheckButton\" id=\"position_bottom_button\">\n                                    <property name=\"label\" translatable=\"yes\">Bottom</property>\n                                    <property name=\"halign\">center</property>\n\n                                    <property name=\"group\">position_left_button</property>\n                                    <signal name=\"toggled\" handler=\"position_bottom_button_toggled_cb\" />\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkCheckButton\" id=\"position_top_button\">\n                                    <property name=\"label\" translatable=\"yes\">Top</property>\n                                    <property name=\"halign\">center</property>\n\n\n                                    <property name=\"group\">position_left_button</property>\n                                    <signal name=\"toggled\" handler=\"position_top_button_toggled_cb\" />\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkCheckButton\" id=\"position_right_button\">\n                                    <property name=\"label\" translatable=\"yes\">Right</property>\n                                    <property name=\"valign\">center</property>\n\n                                    <property name=\"group\">position_left_button</property>\n                                    <signal name=\"toggled\" handler=\"position_right_button_toggled_cb\" />\n                                  </object>\n                                </child>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n                <child type=\"label_item\">\n                  <placeholder/>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkFrame\" id=\"intelligent_autohide_frame\">\n                <property name=\"can_focus\">0</property>\n\n                <property name=\"child\">\n                  <object class=\"GtkListBox\" id=\"listbox3\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"selection_mode\">none</property>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow14\">\n                        <property name=\"width_request\">100</property>\n                        <property name=\"height_request\">80</property>\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"intelligent_autohide_grid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_description7\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Hide the dock when it obstructs a window of the current application. More refined settings are available.</property>\n                                <property name=\"wrap\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <style>\n                                  <class name=\"dim-label\"/>\n                                </style>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_label8\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Intelligent autohide</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkBox\" id=\"box3\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"spacing\">6</property>\n                                <child>\n                                  <object class=\"GtkButton\" id=\"intelligent_autohide_button\">\n                                    <property name=\"receives_default\">1</property>\n                                    <property name=\"halign\">center</property>\n                                    <property name=\"valign\">center</property>\n\n                                    <child>\n                                      <object class=\"GtkImage\" id=\"image\">\n                                        <property name=\"can_focus\">0</property>\n                                        <property name=\"icon_name\">emblem-system-symbolic</property>\n                                      </object>\n                                    </child>\n                                    <style>\n                                      <class name=\"circular\"/>\n                                    </style>\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkSwitch\" id=\"intelligent_autohide_switch\">\n                                    <property name=\"halign\">end</property>\n                                    <property name=\"valign\">center</property>\n                                  </object>\n                                </child>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                  <property name=\"row-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n                <child type=\"label_item\">\n                  <placeholder/>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkFrame\" id=\"size_frame\">\n                <property name=\"can_focus\">0</property>\n\n                <property name=\"child\">\n                  <object class=\"GtkListBox\" id=\"size_listbox\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"selection_mode\">none</property>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"dock_size_listboxrow\">\n                        <property name=\"width_request\">100</property>\n                        <property name=\"height_request\">80</property>\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"dock_size_grid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"dock_size_label\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"label\" translatable=\"yes\">Dock size limit</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkScale\" id=\"dock_size_scale\">\n                                <property name=\"draw-value\">1</property>\n                                <property name=\"valign\">baseline</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"adjustment\">dock_size_adjustment</property>\n                                <property name=\"round_digits\">0</property>\n                                <property name=\"digits\">2</property>\n                                <property name=\"value_pos\">right</property>\n                                <signal name=\"value-changed\" handler=\"dock_size_scale_value_changed_cb\" />\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"dock_size_extend_checkbutton\">\n                                <property name=\"label\" translatable=\"yes\">Panel mode: extend to the screen edge</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"dock_center_icons_check\">\n                                <property name=\"label\" translatable=\"yes\">Place icons to the center</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">2</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"icon_size_listboxrow\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"icon_size_grid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_label6\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"label\" translatable=\"yes\">Icon size limit</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkScale\" id=\"icon_size_scale\">\n                                <property name=\"draw-value\">1</property>\n                                <property name=\"valign\">baseline</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"adjustment\">icon_size_adjustment</property>\n                                <property name=\"round_digits\">1</property>\n                                <property name=\"digits\">0</property>\n                                <property name=\"value_pos\">right</property>\n                                <signal name=\"value-changed\" handler=\"icon_size_scale_value_changed_cb\" />\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"icon_size_fixed_checkbutton\">\n                                <property name=\"label\" translatable=\"yes\">Fixed icon size: scroll to reveal other icons</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"preview_size_listboxrow\">\n                        <property name=\"can_focus\">True</property>\n                        <child>\n                          <object class=\"GtkGrid\" id=\"preview_size_grid\">\n                            <property name=\"can_focus\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_label7\">\n                                <property name=\"can_focus\">False</property>\n                                <property name=\"label\" translatable=\"yes\">Preview size scale</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkScale\" id=\"preview_size_scale\">\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"draw-value\">1</property>\n                                <property name=\"adjustment\">preview_size_adjustment</property>\n                                <property name=\"restrict_to_fill_level\">0</property>\n                                <property name=\"fill_level\">0</property>\n                                <property name=\"round_digits\">0</property>\n                                <property name=\"digits\">2</property>\n                                <property name=\"value_pos\">right</property>\n                                <!-- <signal name=\"format-value\" handler=\"preview_size_scale_format_value_cb\" /> -->\n                                <signal name=\"value-changed\" handler=\"preview_size_scale_value_changed_cb\" />\n                              </object>\n                            </child>\n                            <layout>\n                              <property name=\"column\">0</property>\n                              <property name=\"row\">1</property>\n                            </layout>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n                <child type=\"label_item\">\n                  <placeholder/>\n                </child>\n              </object>\n            </child>\n          </object>\n        </property>\n        <property name=\"tab\">\n          <object class=\"GtkLabel\" id=\"general_label\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"label\" translatable=\"yes\">Position and size</property>\n          </object>\n        </property>\n      </object>\n    </child>\n    <child>\n      <object class=\"GtkNotebookPage\">\n        <property name=\"position\">1</property>\n        <property name=\"child\">\n          <object class=\"GtkBox\" id=\"apps\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"margin_start\">24</property>\n            <property name=\"margin_end\">24</property>\n            <property name=\"margin_top\">24</property>\n            <property name=\"margin_bottom\">24</property>\n            <property name=\"orientation\">vertical</property>\n            <property name=\"spacing\">24</property>\n            <child>\n              <object class=\"GtkFrame\" id=\"customize_theme1\">\n                <property name=\"can_focus\">0</property>\n\n                <property name=\"child\">\n                  <object class=\"GtkListBox\" id=\"listbox9\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"selection_mode\">none</property>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow6\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"shrink_dash1\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show_favorite_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"shrink_dash_label1\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Show pinned applications</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow16\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"shrink_dash2\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show_running_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"shrink_dash_label2\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Show running applications</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"application_button_isolation_button\">\n                                <property name=\"label\" translatable=\"yes\">Isolate workspaces</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">2</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"application_button_urgent_button\">\n                                <property name=\"label\" translatable=\"yes\">Show urgent windows despite current workspace</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">3</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"application_button_monitor_isolation_button\">\n                                <property name=\"label\" translatable=\"yes\">Isolate monitors</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">4</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"windows_preview_button\">\n                                <property name=\"margin_top\">3</property>\n                                <property name=\"label\" translatable=\"yes\">Show open windows' previews</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"scroll_to_icon_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Keep the focused application always visible in the dash</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow17\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"shrink_dash3\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show_applications_button_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                  <property name=\"row-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"shrink_dash_description1\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">If disabled, these settings are accessible from gnome-tweak-tool or the extension website.</property>\n                                <property name=\"wrap\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <style>\n                                  <class name=\"dim-label\"/>\n                                </style>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"shrink_dash_label3\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Show &lt;i&gt;Applications&lt;/i&gt; icon</property>\n                                <property name=\"use_markup\">1</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"application_button_first_button\">\n                                <property name=\"label\" translatable=\"yes\">Move at beginning of the dock</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">2</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"application_button_animation_button\">\n                                <style>\n                                <class name=\"text-button\"/>\n                                </style>\n                                <property name=\"margin_top\">3</property>\n                                <child>\n                                  <object class=\"GtkLabel\" id=\"label3\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"halign\">start</property>\n                                    <property name=\"label\" translatable=\"yes\">Animate &lt;i&gt;Show Applications&lt;/i&gt;</property>\n                                    <property name=\"use_markup\">1</property>\n                                  </object>\n                                </child>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">3</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"show_apps_always_in_the_edge\">\n                                <style>\n                                  <class name=\"text-button\"/>\n                                </style>\n                                <property name=\"margin_top\">3</property>\n                                <child>\n                                  <object class=\"GtkLabel\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"halign\">start</property>\n                                    <property name=\"label\" translatable=\"yes\">Put &lt;i&gt;Show Applications&lt;/i&gt; in a dock edge when using Panel mode</property>\n                                    <property name=\"use_markup\">1</property>\n                                  </object>\n                                </child>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">4</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow18\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"shrink_dash4\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show_trash_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"shrink_dash_label4\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Show trash can</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow19\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"shrink_dash5\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show_mounts_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"shrink_dash_label5\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Show volumes and devices</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"show_only_mounted_devices_check\">\n                                <property name=\"label\" translatable=\"yes\">Only if mounted</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                  <property name=\"column-span\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"show_network_volumes_check\">\n                                <property name=\"label\" translatable=\"yes\">Include network volumes</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">2</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"isolate_locations_row\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"isolate_locations_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Isolate volumes, devices and trash windows from file manager</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"wiggle_urgent_applications_row\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"wiggle_urgent_applications_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Wiggle urgent applications</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"hide_tooltip_row\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"hide_tooltip_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Hide application tooltip</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show_icons_emblems_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Show icons emblems</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">When enabled application icons will show notification counters and progress-bars (if Unity API is used).</property>\n                                <property name=\"wrap\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <style>\n                                  <class name=\"dim-label\"/>\n                                </style>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"notifications_counter_check\">\n                                <property name=\"label\" translatable=\"yes\">Show the number of unread notifications</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"margin_top\">12</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">2</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkCheckButton\" id=\"applications_override_counter\">\n                                <style>\n                                  <class name=\"text-button\"/>\n                                </style>\n                                <property name=\"margin_top\">3</property>\n                                <child>\n                                  <object class=\"GtkLabel\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"halign\">start</property>\n                                    <property name=\"label\" translatable=\"yes\">Application-provided counter overrides the notifications counter</property>\n                                  </object>\n                                </child>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">3</property>\n                                  <property name=\"column-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n                <child type=\"label_item\">\n                  <placeholder/>\n                </child>\n              </object>\n            </child>\n          </object>\n        </property>\n        <property name=\"tab\">\n          <object class=\"GtkLabel\" id=\"launchers_label\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"label\" translatable=\"yes\">Launchers</property>\n          </object>\n        </property>\n      </object>\n    </child>\n    <child>\n      <object class=\"GtkNotebookPage\">\n        <property name=\"position\">2</property>\n        <property name=\"child\">\n          <object class=\"GtkBox\" id=\"behaviour\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"margin_start\">24</property>\n            <property name=\"margin_end\">24</property>\n            <property name=\"margin_top\">24</property>\n            <property name=\"margin_bottom\">24</property>\n            <property name=\"orientation\">vertical</property>\n            <property name=\"spacing\">24</property>\n            <child>\n              <object class=\"GtkFrame\" id=\"hot_keys_frame\">\n                <property name=\"can_focus\">0</property>\n\n                <property name=\"child\">\n                  <object class=\"GtkListBox\" id=\"hot_keys_listbox\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"selection_mode\">none</property>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"hot_keys_listboxrow\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"hot_keys_grid\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"hot_keys_description\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Enable Super+(0-9) as shortcuts to activate apps. It can also be used together with Shift and Ctrl.</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"wrap\">1</property>\n                                <property name=\"xalign\">0</property>\n\n                                <style>\n                                  <class name=\"dim-label\"/>\n                                </style>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"hot_keys_label\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Use keyboard shortcuts to activate apps</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkBox\" id=\"overlay_box\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"spacing\">6</property>\n                                <child>\n                                  <object class=\"GtkButton\" id=\"overlay_button\">\n                                    <property name=\"receives_default\">1</property>\n                                    <property name=\"halign\">center</property>\n                                    <property name=\"valign\">center</property>\n\n                                    <child>\n                                      <object class=\"GtkImage\" id=\"image_overlay\">\n                                        <property name=\"can_focus\">0</property>\n                                        <property name=\"icon_name\">emblem-system-symbolic</property>\n                                      </object>\n                                    </child>\n                                    <style>\n                                      <class name=\"circular\"/>\n                                    </style>\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkSwitch\" id=\"hot_keys_switch\">\n                                    <property name=\"halign\">end</property>\n                                    <property name=\"valign\">center</property>\n                                  </object>\n                                </child>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                  <property name=\"row-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n                <child type=\"label_item\">\n                  <placeholder/>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkFrame\" id=\"built_in_theme_frame3\">\n                <property name=\"can_focus\">0</property>\n\n                <property name=\"child\">\n                  <object class=\"GtkListBox\" id=\"listbox6\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"selection_mode\">none</property>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow9\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"buitin_theme5\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_description5\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Behaviour when clicking on the icon of a running application.</property>\n                                <property name=\"wrap\">1</property>\n                                <property name=\"xalign\">0</property>\n\n                                <style>\n                                  <class name=\"dim-label\"/>\n                                </style>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_label5\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Click action</property>\n                                <property name=\"xalign\">0</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkBox\" id=\"click_box\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"spacing\">6</property>\n                                <child>\n                                  <object class=\"GtkButton\" id=\"middle_click_options_button\">\n                                    <property name=\"receives_default\">1</property>\n                                    <property name=\"valign\">center</property>\n                                    <child>\n                                      <object class=\"GtkImage\" id=\"middle_click_image\">\n                                        <property name=\"can_focus\">0</property>\n                                        <property name=\"icon_name\">emblem-system-symbolic</property>\n                                      </object>\n                                    </child>\n                                    <style>\n                                      <class name=\"circular\"/>\n                                    </style>\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkComboBoxText\" id=\"click_action_combo\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"valign\">center</property>\n                                    <items>\n                                      <item translatable=\"yes\">Raise window</item>\n                                      <item translatable=\"yes\">Minimize</item>\n                                      <item translatable=\"yes\">Launch new instance</item>\n                                      <item translatable=\"yes\">Cycle through windows</item>\n                                      <item translatable=\"yes\">Minimize or overview</item>\n                                      <item translatable=\"yes\">Show window previews</item>\n                                      <item translatable=\"yes\">Minimize or show previews</item>\n                                      <item translatable=\"yes\">Focus or show previews</item>\n                                      <item translatable=\"yes\">Focus or app spread</item>\n                                      <item translatable=\"yes\">Focus, minimize or show previews</item>\n                                      <item translatable=\"yes\">Focus, minimize or app spread</item>\n                                    </items>\n                                  </object>\n                                </child>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                  <property name=\"row-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n                <child type=\"label_item\">\n                  <placeholder/>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkFrame\" id=\"built_in_theme_frame_scroll\">\n                <property name=\"can_focus\">0</property>\n\n                <property name=\"child\">\n                  <object class=\"GtkListBox\" id=\"listbox5\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"selection_mode\">none</property>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow_scroll\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"buitin_theme_scroll\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_description_scroll\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Behaviour when scrolling on the icon of an application.</property>\n                                <property name=\"wrap\">1</property>\n                                <property name=\"xalign\">0</property>\n\n                                <style>\n                                  <class name=\"dim-label\"/>\n                                </style>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_label_scroll\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Scroll action</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkBox\" id=\"click_box_scroll\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"spacing\">6</property>\n                                <child>\n                                  <object class=\"GtkComboBoxText\" id=\"scroll_action_combo\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"valign\">center</property>\n                                    <items>\n                                      <item translatable=\"yes\">Do nothing</item>\n                                      <item translatable=\"yes\">Cycle through windows</item>\n                                      <item translatable=\"yes\">Switch workspace</item>\n                                    </items>\n                                  </object>\n                                </child>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                  <property name=\"row-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n                <child type=\"label_item\">\n                  <placeholder/>\n                </child>\n              </object>\n            </child>\n          </object>\n        </property>\n        <property name=\"tab\">\n          <object class=\"GtkLabel\" id=\"behaviour_label\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"halign\">start</property>\n            <property name=\"label\" translatable=\"yes\">Behavior</property>\n          </object>\n        </property>\n      </object>\n    </child>\n    <child>\n      <object class=\"GtkNotebookPage\">\n        <property name=\"position\">3</property>\n        <property name=\"child\">\n          <object class=\"GtkBox\" id=\"appearance\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"margin_start\">24</property>\n            <property name=\"margin_end\">24</property>\n            <property name=\"margin_top\">24</property>\n            <property name=\"margin_bottom\">24</property>\n            <property name=\"orientation\">vertical</property>\n            <property name=\"spacing\">24</property>\n            <child>\n              <object class=\"GtkFrame\" id=\"built_in_theme_frame\">\n                <property name=\"can_focus\">0</property>\n\n                <property name=\"child\">\n                  <object class=\"GtkListBox\" id=\"listbox1\">\n                    <property name=\"selection_mode\">none</property>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow2\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"shrink_dash\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"shrink_dash_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                  <property name=\"row-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"shrink_dash_description\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Save space reducing padding and border radius.</property>\n\n                                <style>\n                                  <class name=\"dim-label\"/>\n                                </style>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"shrink_dash_label\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Shrink the dash</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"listboxrow_rnd_border\">\n                        <property name=\"width_request\">100</property>\n                        <property name=\"height_request\">80</property>\n                        <property name=\"child\">\n                          <object class=\"GtkBox\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"spacing\">32</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"force_straight_corner_label\">\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"valign\">center</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Force straight corner</property>\n\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"force_straight_corner_switch\">\n                                <property name=\"valign\">center</property>\n                                <property name=\"margin_start\">3</property>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"width_request\">100</property>\n                        <property name=\"height_request\">80</property>\n                        <property name=\"child\">\n                          <object class=\"GtkBox\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"spacing\">32</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"valign\">center</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Show overview on startup</property>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show_overview_on_startup_switch\">\n                                <property name=\"valign\">center</property>\n                                <property name=\"margin_start\">3</property>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n                <child type=\"label_item\">\n                  <placeholder/>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkFrame\">\n                <property name=\"can_focus\">0</property>\n\n                <property name=\"child\">\n                  <object class=\"GtkBox\">\n                    <property name=\"orientation\">vertical</property>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"child\">\n                          <object class=\"GtkGrid\" id=\"buitin_theme\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">12</property>\n                            <property name=\"margin_bottom\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_description\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Few customizations meant to integrate the dock with the default GNOME theme. Alternatively, specific options can be enabled below.</property>\n                                <property name=\"wrap\">1</property>\n                                <property name=\"xalign\">0</property>\n\n                                <style>\n                                  <class name=\"dim-label\"/>\n                                </style>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"builtin_theme_label\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"halign\">start</property>\n                                <property name=\"label\" translatable=\"yes\">Use built-in theme</property>\n\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"builtin_theme_switch\">\n                                <property name=\"halign\">end</property>\n                                <property name=\"valign\">center</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                  <property name=\"row-span\">2</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </property>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBox\" id=\"customize_theme\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"selection_mode\">none</property>\n                        <child>\n                          <object class=\"GtkListBoxRow\" id=\"listboxrow3\">\n                            <property name=\"child\">\n                              <object class=\"GtkGrid\" id=\"running_dots\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"margin_start\">12</property>\n                                <property name=\"margin_end\">12</property>\n                                <property name=\"margin_top\">12</property>\n                                <property name=\"margin_bottom\">12</property>\n                                <property name=\"column_spacing\">32</property>\n                                <child>\n                                  <object class=\"GtkLabel\" id=\"running_dots_label\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"hexpand\">1</property>\n                                    <property name=\"halign\">start</property>\n                                    <property name=\"label\" translatable=\"yes\">Customize windows counter indicators</property>\n\n                                    <layout>\n                                      <property name=\"column\">0</property>\n                                      <property name=\"row\">0</property>\n                                    </layout>\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkBox\" id=\"box4\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"spacing\">6</property>\n                                    <child>\n                                      <object class=\"GtkButton\" id=\"running_indicators_advance_settings_button\">\n                                        <property name=\"receives_default\">1</property>\n                                        <property name=\"halign\">center</property>\n                                        <property name=\"valign\">center</property>\n\n                                        <child>\n                                          <object class=\"GtkImage\" id=\"image1\">\n                                            <property name=\"can_focus\">0</property>\n                                            <property name=\"icon_name\">emblem-system-symbolic</property>\n                                          </object>\n                                        </child>\n                                        <style>\n                                          <class name=\"circular\"/>\n                                        </style>\n                                      </object>\n                                    </child>\n                                    <child>\n                                      <object class=\"GtkComboBoxText\" id=\"running_indicators_combo\">\n                                        <property name=\"can_focus\">0</property>\n                                        <items>\n                                          <item translatable=\"yes\">Default</item>\n                                          <item translatable=\"yes\">Dots</item>\n                                          <item translatable=\"yes\">Squares</item>\n                                          <item translatable=\"yes\">Dashes</item>\n                                          <item translatable=\"yes\">Segmented</item>\n                                          <item translatable=\"yes\">Solid</item>\n                                          <item translatable=\"yes\">Ciliora</item>\n                                          <item translatable=\"yes\">Metro</item>\n                                          <item translatable=\"yes\">Binary</item>\n                                          <item translatable=\"yes\">Dot</item>\n                                        </items>\n                                      </object>\n                                    </child>\n                                    <layout>\n                                      <property name=\"column\">1</property>\n                                      <property name=\"row\">0</property>\n                                      <property name=\"row-span\">2</property>\n                                    </layout>\n                                  </object>\n                                </child>\n                                <child>\n                                  <placeholder/>\n                                </child>\n                              </object>\n                            </property>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkListBoxRow\" id=\"custom_background_color_listboxrow\">\n                            <property name=\"child\">\n                              <object class=\"GtkGrid\" id=\"custom_background_color_grid\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"margin_start\">12</property>\n                                <property name=\"margin_end\">12</property>\n                                <property name=\"margin_top\">12</property>\n                                <property name=\"margin_bottom\">12</property>\n                                <property name=\"column_spacing\">32</property>\n                                <child>\n                                  <object class=\"GtkLabel\" id=\"custom_background_color_description\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"hexpand\">1</property>\n                                    <property name=\"halign\">start</property>\n                                    <property name=\"label\" translatable=\"yes\">Set the background color for the dash.</property>\n                                    <property name=\"wrap\">1</property>\n                                    <property name=\"xalign\">0</property>\n\n                                    <style>\n                                      <class name=\"dim-label\"/>\n                                    </style>\n                                    <layout>\n                                      <property name=\"column\">0</property>\n                                      <property name=\"row\">1</property>\n                                    </layout>\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkLabel\" id=\"custom_background_color_label\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"hexpand\">1</property>\n                                    <property name=\"halign\">start</property>\n                                    <property name=\"label\" translatable=\"yes\">Customize the dash color</property>\n\n                                    <layout>\n                                      <property name=\"column\">0</property>\n                                      <property name=\"row\">0</property>\n                                    </layout>\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkBox\" id=\"custom_background_color_box\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"spacing\">6</property>\n                                    <child>\n                                      <object class=\"GtkColorButton\" id=\"custom_background_color\">\n                                        <property name=\"receives_default\">1</property>\n                                        <property name=\"halign\">center</property>\n                                        <property name=\"valign\">center</property>\n\n                                      </object>\n                                    </child>\n                                    <child>\n                                      <object class=\"GtkSwitch\" id=\"custom_background_color_switch\">\n                                        <property name=\"halign\">end</property>\n                                        <property name=\"valign\">center</property>\n                                      </object>\n                                    </child>\n                                    <layout>\n                                      <property name=\"column\">1</property>\n                                      <property name=\"row\">0</property>\n                                      <property name=\"row-span\">2</property>\n                                    </layout>\n                                  </object>\n                                </child>\n                              </object>\n                            </property>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkListBoxRow\" id=\"listboxrow4\">\n                            <property name=\"child\">\n                              <object class=\"GtkBox\" id=\"box2\">\n                                <property name=\"can_focus\">0</property>\n                                <property name=\"orientation\">vertical</property>\n                                <child>\n                                  <object class=\"GtkGrid\" id=\"customize_opacity\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"margin_start\">12</property>\n                                    <property name=\"margin_end\">12</property>\n                                    <property name=\"margin_top\">12</property>\n                                    <property name=\"margin_bottom\">12</property>\n                                    <property name=\"column_spacing\">32</property>\n                                    <child>\n                                      <object class=\"GtkLabel\" id=\"customize_opacity_description\">\n                                        <property name=\"can_focus\">0</property>\n                                        <property name=\"hexpand\">1</property>\n                                        <property name=\"halign\">start</property>\n                                        <property name=\"label\" translatable=\"yes\">Tune the dash background opacity.</property>\n\n                                        <style>\n                                          <class name=\"dim-label\"/>\n                                        </style>\n                                        <layout>\n                                          <property name=\"column\">0</property>\n                                          <property name=\"row\">1</property>\n                                        </layout>\n                                      </object>\n                                    </child>\n                                    <child>\n                                      <object class=\"GtkLabel\" id=\"customize_opacity_label\">\n                                        <property name=\"can_focus\">0</property>\n                                        <property name=\"hexpand\">1</property>\n                                        <property name=\"halign\">start</property>\n                                        <property name=\"label\" translatable=\"yes\">Customize opacity</property>\n\n                                        <layout>\n                                          <property name=\"column\">0</property>\n                                          <property name=\"row\">0</property>\n                                        </layout>\n                                      </object>\n                                    </child>\n                                    <child>\n                                      <object class=\"GtkBox\" id=\"customize_opacity_box\">\n                                        <property name=\"can_focus\">0</property>\n                                        <property name=\"spacing\">6</property>\n                                        <child>\n                                          <object class=\"GtkButton\" id=\"dynamic_opacity_button\">\n                                            <property name=\"receives_default\">1</property>\n                                            <property name=\"halign\">center</property>\n                                            <property name=\"valign\">center</property>\n                                            <child>\n                                              <object class=\"GtkImage\" id=\"dynamic_opacity_image\">\n                                                <property name=\"can_focus\">0</property>\n                                                <property name=\"icon_name\">emblem-system-symbolic</property>\n                                              </object>\n                                            </child>\n                                            <style>\n                                              <class name=\"circular\"/>\n                                            </style>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkComboBoxText\" id=\"customize_opacity_combo\">\n                                            <property name=\"can_focus\">0</property>\n                                            <property name=\"valign\">center</property>\n                                            <items>\n                                              <item id=\"0\" translatable=\"yes\">Default</item>\n                                              <item id=\"1\" translatable=\"yes\">Fixed</item>\n                                              <item id=\"3\" translatable=\"yes\">Dynamic</item>\n                                            </items>\n                                          </object>\n                                        </child>\n                                        <layout>\n                                          <property name=\"column\">1</property>\n                                          <property name=\"row\">0</property>\n                                          <property name=\"row-span\">2</property>\n                                        </layout>\n                                      </object>\n                                    </child>\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkBox\" id=\"custom_opacity\">\n                                    <property name=\"can_focus\">0</property>\n                                    <property name=\"margin_start\">12</property>\n                                    <property name=\"margin_end\">12</property>\n                                    <property name=\"margin_top\">12</property>\n                                    <property name=\"margin_bottom\">12</property>\n                                    <property name=\"spacing\">32</property>\n                                    <child>\n                                      <object class=\"GtkLabel\" id=\"custom_opacity_label\">\n                                        <property name=\"can_focus\">0</property>\n                                        <property name=\"label\" translatable=\"yes\">Opacity</property>\n                                      </object>\n                                    </child>\n                                    <child>\n                                      <object class=\"GtkScale\" id=\"custom_opacity_scale\">\n                                        <property name=\"hexpand\">1</property>\n                                        <property name=\"draw-value\">1</property>\n                                        <property name=\"adjustment\">custom_opacity_adjustement</property>\n\n                                        <property name=\"restrict_to_fill_level\">0</property>\n                                        <property name=\"fill_level\">0</property>\n                                        <property name=\"round_digits\">0</property>\n                                        <property name=\"digits\">2</property>\n                                        <property name=\"value_pos\">right</property>\n                                        <signal name=\"value-changed\" handler=\"custom_opacity_scale_value_changed_cb\" />\n                                      </object>\n                                    </child>\n                                  </object>\n                                </child>\n                              </object>\n                            </property>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n                <child type=\"label_item\">\n                  <placeholder/>\n                </child>\n              </object>\n            </child>\n          </object>\n        </property>\n        <property name=\"tab\">\n          <object class=\"GtkLabel\" id=\"appearance_label\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"label\" translatable=\"yes\">Appearance</property>\n          </object>\n        </property>\n      </object>\n    </child>\n    <child>\n      <object class=\"GtkNotebookPage\">\n        <property name=\"position\">4</property>\n        <property name=\"child\">\n          <object class=\"GtkBox\" id=\"about\">\n            <property name=\"visible\">0</property>\n            <property name=\"can_focus\">0</property>\n            <property name=\"margin_top\">24</property>\n            <property name=\"margin_bottom\">24</property>\n            <property name=\"hexpand\">1</property>\n            <property name=\"vexpand\">1</property>\n            <property name=\"orientation\">vertical</property>\n            <property name=\"spacing\">5</property>\n            <child>\n              <object class=\"GtkImage\" id=\"logo\">\n                <property name=\"can_focus\">0</property>\n                <property name=\"file\">./media/logo.svg</property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkLabel\" id=\"extension_name\">\n                <property name=\"can_focus\">0</property>\n                <property name=\"label\">&lt;b&gt;Dash to Dock&lt;/b&gt;</property>\n                <property name=\"use_markup\">1</property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkBox\" id=\"box1\">\n                <property name=\"can_focus\">0</property>\n                <property name=\"halign\">center</property>\n                <child>\n                  <object class=\"GtkLabel\" id=\"extension_version_label\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"halign\">end</property>\n                    <property name=\"label\" translatable=\"yes\">version: </property>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkLabel\" id=\"extension_version\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"halign\">start</property>\n                    <property name=\"label\">...</property>\n                  </object>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkLabel\" id=\"extension_description\">\n                <property name=\"can_focus\">0</property>\n                <property name=\"label\" translatable=\"yes\">Moves the dash out of the overview transforming it in a dock</property>\n                <property name=\"justify\">center</property>\n                <property name=\"wrap\">1</property>\n                <property name=\"xalign\">0</property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkBox\" id=\"box10\">\n                <property name=\"can_focus\">0</property>\n                <property name=\"halign\">center</property>\n                <property name=\"spacing\">5</property>\n                <child>\n                  <object class=\"GtkLabel\" id=\"label15\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"label\" translatable=\"yes\">Created by</property>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkLabel\" id=\"label16\">\n                    <property name=\"label\">Michele (&lt;a href=&quot;mailto:micxgx@gmail.com&quot;&gt;micxgx@gmail.com&lt;/a&gt;)</property>\n                    <property name=\"use_markup\">1</property>\n                  </object>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkLinkButton\" id=\"homepage_link\">\n                <property name=\"label\" translatable=\"yes\">Webpage</property>\n                <property name=\"receives_default\">1</property>\n                <property name=\"halign\">center</property>\n\n                <property name=\"uri\">https://micheleg.github.io/dash-to-dock/</property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkLabel\" id=\"label1\">\n                <property name=\"vexpand\">1</property>\n                <property name=\"valign\">end</property>\n                <property name=\"label\" translatable=\"yes\">&lt;span size=&quot;small&quot;&gt;This program comes with ABSOLUTELY NO WARRANTY.\nSee the &lt;a href=&quot;https://www.gnu.org/licenses/old-licenses/gpl-2.0.html&quot;&gt;GNU General Public License, version 2 or later&lt;/a&gt; for details.&lt;/span&gt;</property>\n                <property name=\"use_markup\">1</property>\n                <property name=\"justify\">center</property>\n                <property name=\"wrap\">1</property>\n                <property name=\"xalign\">0</property>\n              </object>\n            </child>\n          </object>\n        </property>\n        <property name=\"tab\">\n          <object class=\"GtkLabel\" id=\"about_label\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"label\" translatable=\"yes\">About</property>\n          </object>\n        </property>\n      </object>\n    </child>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"max_opacity_adjustement\">\n    <property name=\"upper\">1</property>\n    <property name=\"step-increment\">0.01</property>\n    <property name=\"page-increment\">0.10000000000000001</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"min_opacity_adjustement\">\n    <property name=\"upper\">1</property>\n    <property name=\"step-increment\">0.01</property>\n    <property name=\"page-increment\">0.10000000000000001</property>\n  </object>\n  <object class=\"GtkBox\" id=\"advanced_transparency_dialog\">\n    <property name=\"hexpand\">1</property>\n    <property name=\"vexpand\">1</property>\n    <property name=\"can_focus\">0</property>\n    <property name=\"margin_start\">12</property>\n    <property name=\"margin_end\">12</property>\n    <property name=\"margin_top\">12</property>\n    <property name=\"margin_bottom\">12</property>\n    <property name=\"orientation\">vertical</property>\n    <child>\n      <object class=\"GtkFrame\" id=\"advanced_transparency_frame\">\n        <property name=\"can_focus\">0</property>\n\n        <property name=\"child\">\n          <object class=\"GtkListBox\" id=\"advanced_transparency_listbox\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"selection_mode\">none</property>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"advanced_transparency_listboxrow\">\n                <property name=\"width_request\">100</property>\n                <property name=\"height_request\">80</property>\n                <property name=\"child\">\n                  <object class=\"GtkBox\" id=\"advanced_transparency_box\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"orientation\">vertical</property>\n                    <property name=\"spacing\">12</property>\n                    <child>\n                      <object class=\"GtkBox\" id=\"min_alpha_box_1\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"margin_start\">12</property>\n                        <property name=\"margin_end\">12</property>\n                        <property name=\"margin_top\">12</property>\n                        <property name=\"margin_bottom\">12</property>\n                        <property name=\"spacing\">32</property>\n                        <child>\n                          <object class=\"GtkLabel\" id=\"customize_alphas_label\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"label\" translatable=\"yes\">Customize minimum and maximum opacity values</property>\n                            <property name=\"justify\">fill</property>\n                            <property name=\"xalign\">0</property>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkSwitch\" id=\"customize_alphas_switch\">\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkBox\" id=\"min_alpha_box\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"margin_start\">12</property>\n                        <property name=\"margin_end\">12</property>\n                        <property name=\"margin_top\">12</property>\n                        <property name=\"margin_bottom\">12</property>\n                        <property name=\"spacing\">32</property>\n                        <child>\n                          <object class=\"GtkLabel\" id=\"min_alpha_label\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"label\" translatable=\"yes\">Minimum opacity</property>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkScale\" id=\"min_alpha_scale\">\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"draw-value\">1</property>\n                            <property name=\"adjustment\">min_opacity_adjustement</property>\n\n                            <property name=\"restrict_to_fill_level\">0</property>\n                            <property name=\"fill_level\">0</property>\n                            <property name=\"round_digits\">0</property>\n                            <property name=\"digits\">2</property>\n                            <property name=\"value_pos\">right</property>\n                            <signal name=\"value-changed\" handler=\"min_opacity_scale_value_changed_cb\" />\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkBox\" id=\"max_alpha_box\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"margin_start\">12</property>\n                        <property name=\"margin_end\">12</property>\n                        <property name=\"margin_top\">12</property>\n                        <property name=\"margin_bottom\">12</property>\n                        <property name=\"spacing\">32</property>\n                        <child>\n                          <object class=\"GtkLabel\" id=\"max_alpha_label\">\n                            <property name=\"can_focus\">0</property>\n                            <property name=\"label\" translatable=\"yes\">Maximum opacity</property>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkScale\" id=\"max_alpha_scale\">\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"draw-value\">1</property>\n                            <property name=\"adjustment\">max_opacity_adjustement</property>\n\n                            <property name=\"restrict_to_fill_level\">0</property>\n                            <property name=\"fill_level\">0</property>\n                            <property name=\"round_digits\">0</property>\n                            <property name=\"digits\">2</property>\n                            <property name=\"value_pos\">right</property>\n                            <signal name=\"value-changed\" handler=\"max_opacity_scale_value_changed_cb\" />\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n          </object>\n        </property>\n        <child type=\"label_item\">\n          <placeholder/>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"pressure_threshold_adjustment\">\n    <property name=\"upper\">1000</property>\n    <property name=\"step-increment\">50</property>\n    <property name=\"page-increment\">250</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"shortcut_time_adjustment\">\n    <property name=\"upper\">10</property>\n    <property name=\"step-increment\">0.25</property>\n    <property name=\"page-increment\">1</property>\n  </object>\n  <object class=\"GtkBox\" id=\"box_overlay_shortcut\">\n    <property name=\"hexpand\">1</property>\n    <property name=\"vexpand\">1</property>\n    <property name=\"margin_start\">12</property>\n    <property name=\"margin_end\">12</property>\n    <property name=\"margin_top\">12</property>\n    <property name=\"margin_bottom\">12</property>\n    <property name=\"orientation\">vertical</property>\n    <child>\n      <object class=\"GtkFrame\" id=\"frame_overlay_show_dock\">\n        <property name=\"child\">\n          <object class=\"GtkListBox\" id=\"listbox_overlay_shortcut\">\n            <property name=\"selection_mode\">none</property>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow_overlay_shortcut\">\n                <property name=\"width_request\">100</property>\n                <property name=\"height_request\">80</property>\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"grid_overlay\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkSwitch\" id=\"overlay_switch\">\n                        <property name=\"halign\">end</property>\n                        <property name=\"valign\">center</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                          <property name=\"row-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"overlay_label\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Number overlay</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"overlay_description\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"label\" translatable=\"yes\">Temporarily show the application numbers over the icons, corresponding to the shortcut.</property>\n                        <property name=\"wrap\">1</property>\n                        <property name=\"xalign\">0</property>\n                        <property name=\"max_width_chars\">40</property>\n\n                        <style>\n                          <class name=\"dim-label\"/>\n                        </style>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow_show_dock\">\n                <property name=\"width_request\">100</property>\n                <property name=\"height_request\">80</property>\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"grid_show_dock\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkSwitch\" id=\"show_dock_switch\">\n                        <property name=\"halign\">end</property>\n                        <property name=\"valign\">center</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                          <property name=\"row-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"show_dock_label\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"halign\">start</property>\n                        <property name=\"label\" translatable=\"yes\">Show the dock if it is hidden</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"show_dock_description\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"label\" translatable=\"yes\">If using autohide, the dock will appear for a short time when triggering the shortcut.</property>\n                        <property name=\"wrap\">1</property>\n                        <property name=\"xalign\">0</property>\n                        <property name=\"max_width_chars\">40</property>\n\n                        <style>\n                          <class name=\"dim-label\"/>\n                        </style>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow_extra_shortcut\">\n                <property name=\"width_request\">100</property>\n                <property name=\"height_request\">80</property>\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"grid_shortcut\">\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkEntry\" id=\"shortcut_entry\">\n                        <property name=\"valign\">center</property>\n                        <property name=\"width_chars\">12</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"shortcut_label\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Shortcut for the options above</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"shortcut_description\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"label\" translatable=\"yes\">Syntax: &lt;Shift&gt;, &lt;Ctrl&gt;, &lt;Alt&gt;, &lt;Super&gt;</property>\n                        <property name=\"wrap\">1</property>\n                        <property name=\"xalign\">0</property>\n                        <property name=\"max_width_chars\">40</property>\n\n                        <style>\n                          <class name=\"dim-label\"/>\n                        </style>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <placeholder/>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow_timeout\">\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"grid_timeout\">\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"hexpand\">1</property>\n                    <property name=\"row_spacing\">6</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkSpinButton\" id=\"timeout_spinbutton\">\n                        <property name=\"halign\">end</property>\n                        <property name=\"adjustment\">shortcut_time_adjustment</property>\n                        <property name=\"digits\">3</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"shortcut_timeout_label\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Hide timeout (s)</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n          </object>\n        </property>\n        <child type=\"label_item\">\n          <placeholder/>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"show_timeout_adjustment\">\n    <property name=\"upper\">1</property>\n    <property name=\"step-increment\">0.050000000000000003</property>\n    <property name=\"page-increment\">0.25</property>\n  </object>\n  <object class=\"GtkBox\" id=\"intelligent_autohide_advanced_settings_box\">\n    <property name=\"hexpand\">1</property>\n    <property name=\"vexpand\">1</property>\n    <property name=\"can_focus\">0</property>\n    <property name=\"margin_start\">12</property>\n    <property name=\"margin_end\">12</property>\n    <property name=\"margin_top\">12</property>\n    <property name=\"margin_bottom\">12</property>\n    <property name=\"orientation\">vertical</property>\n    <child>\n      <object class=\"GtkFrame\" id=\"intelligent_autohide_advanced_settings_frame\">\n        <property name=\"can_focus\">0</property>\n\n        <property name=\"child\">\n          <object class=\"GtkListBox\" id=\"listbox4\">\n            <property name=\"can_focus\">0</property>\n            <property name=\"selection_mode\">none</property>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow8\">\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"buitin_theme2\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"builtin_theme_description2\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"halign\">start</property>\n                        <property name=\"label\" translatable=\"yes\">Show the dock by mouse hover on the screen edge.</property>\n                        <property name=\"wrap\">1</property>\n                        <property name=\"xalign\">0</property>\n\n                        <style>\n                          <class name=\"dim-label\"/>\n                        </style>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"builtin_theme_label2\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Autohide</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkSwitch\" id=\"autohide_switch\">\n                        <property name=\"halign\">end</property>\n                        <property name=\"valign\">center</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                          <property name=\"row-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkCheckButton\" id=\"require_pressure_checkbutton\">\n                        <property name=\"label\" translatable=\"yes\">Push to show: require pressure to show the dock</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">3</property>\n                          <property name=\"column-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkCheckButton\" id=\"autohide_enable_in_fullscreen_checkbutton\">\n                        <property name=\"label\" translatable=\"yes\">Enable in fullscreen mode</property>\n                        <property name=\"margin_top\">12</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">2</property>\n                          <property name=\"column-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkCheckButton\" id=\"show_dock_urgent_notify_checkbutton\">\n                        <property name=\"label\" translatable=\"yes\">Show dock for urgent notifications</property>\n                        <property name=\"margin_top\">12</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">4</property>\n                          <property name=\"column-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow15\">\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"intellihide_grid\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"builtin_theme_description3\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"halign\">start</property>\n                        <property name=\"label\" translatable=\"yes\">Show the dock when it doesn&apos;t obstruct application windows.</property>\n                        <property name=\"wrap\">1</property>\n                        <property name=\"xalign\">0</property>\n\n                        <style>\n                          <class name=\"dim-label\"/>\n                        </style>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"builtin_theme_label3\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Dodge windows</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkSwitch\" id=\"intellihide_switch\">\n                        <property name=\"halign\">end</property>\n                        <property name=\"valign\">center</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                          <property name=\"row-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkBox\" id=\"intellihide_mode_box\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"orientation\">vertical</property>\n                        <child>\n                          <object class=\"GtkCheckButton\" id=\"all_windows_radio_button\">\n                            <property name=\"label\" translatable=\"yes\">All windows</property>\n                            <property name=\"margin_top\">12</property>\n\n                            <signal name=\"toggled\" handler=\"all_windows_radio_button_toggled_cb\" />\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkCheckButton\" id=\"focus_application_windows_radio_button\">\n                            <property name=\"label\" translatable=\"yes\">Only focused application&apos;s windows</property>\n                            <property name=\"group\">all_windows_radio_button</property>\n                            <signal name=\"toggled\" handler=\"focus_application_windows_radio_button_toggled_cb\" />\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkCheckButton\" id=\"maximized_windows_radio_button\">\n                            <property name=\"label\" translatable=\"yes\">Only maximized windows</property>\n                            <property name=\"group\">all_windows_radio_button</property>\n                            <signal name=\"toggled\" handler=\"maximized_windows_radio_button_toggled_cb\" />\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkCheckButton\" id=\"always_on_top_radio_button\">\n                            <property name=\"label\" translatable=\"yes\">Always on top</property>\n                            <property name=\"group\">all_windows_radio_button</property>\n                            <signal name=\"toggled\" handler=\"always_on_top_radio_button_toggled_cb\" />\n                          </object>\n                        </child>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">2</property>\n                          <property name=\"column-span\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"listboxrow5\">\n                <property name=\"child\">\n                  <object class=\"GtkGrid\" id=\"grid2\">\n                    <property name=\"can_focus\">0</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"hexpand\">1</property>\n                    <property name=\"row_spacing\">6</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkSpinButton\" id=\"animation_duration_spinbutton\">\n                        <property name=\"halign\">end</property>\n                        <property name=\"adjustment\">animation_time_adjustment</property>\n                        <property name=\"digits\">3</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"label2\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Animation duration (s)</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkSpinButton\" id=\"hide_timeout_spinbutton\">\n                        <property name=\"halign\">end</property>\n                        <property name=\"adjustment\">hide_timeout_adjustment</property>\n                        <property name=\"digits\">3</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkSpinButton\" id=\"show_timeout_spinbutton\">\n                        <property name=\"halign\">end</property>\n                        <property name=\"adjustment\">show_timeout_adjustment</property>\n                        <property name=\"digits\">3</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkSpinButton\" id=\"pressure_threshold_spinbutton\">\n                        <property name=\"text\">0.000</property>\n                        <property name=\"adjustment\">pressure_threshold_adjustment</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">3</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"label9\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Hide timeout (s)</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">1</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"show_timeout_label\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Show timeout (s)</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">2</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"pressure_threshold_label\">\n                        <property name=\"can_focus\">0</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Pressure threshold</property>\n\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">3</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </property>\n              </object>\n            </child>\n          </object>\n        </property>\n        <child type=\"label_item\">\n          <placeholder/>\n        </child>\n      </object>\n    </child>\n  </object>\n</interface>\n"
        },
        {
          "name": "_stylesheet.scss",
          "type": "blob",
          "size": 16.37109375,
          "content": "// From https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/43.0/data/theme/gnome-shell-sass/_common.scss#L28\n$base_padding: 6px;\n$base_margin: 4px;\n\n$base_border_radius: 8px;\n$modal_radius: $base_border_radius * 2;\n\n// From https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/43.0/data/theme/gnome-shell-sass/_colors.scss\n$variant: 'dark';\n$fg_color: if($variant == 'light', transparentize(black, .2), white);\n$borders_color: if($variant == 'light', transparentize($fg_color, .5), transparentize($fg_color, .9));\n$_dark_base_color: darken(desaturate(#241f31, 100%), 2%);\n$base_color: if($variant =='light', #fff, $_dark_base_color);\n$system_bg_color: $base_color;\n\n$remark_color: rgba(238, 238, 238, 0.2);\n\n// From https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/43.0/data/theme/gnome-shell-sass/widgets/_dash.scss\n$dash_background_color: lighten($system_bg_color, 5%);\n$dash_placeholder_size: 32px;\n$dash_padding: $base_padding*2; // 12px\n$dash_border_radius: $modal_radius + $dash_padding;\n$dash_padding_gnome: $dash_padding;\n\n$dash_edge_offset: $base_margin * 3;\n\n// Dash to dock specifics\n$dash_padding: $base_padding + 4px; // 10px\n$dash_border_radius: $modal_radius * 1.5;\n\n$dock_spacing: round($base_padding / 4);\n$dock_bottom_margin: $base_margin * 4;\n$dock_start_margin: $dock_bottom_margin;\n$dock_side_margin: $dock_start_margin / 4;\n$dock_edge_items_padding: $dash_padding - $dock_spacing;\n$dock_fixed_inner_margin: $dock_side_margin;\n$dock_icons_distance: 4px;\n\n@function shrink($val) {\n    @return round($val / 4);\n}\n\n@function shrink_light($val) {\n    @return round($val * 0.75);\n}\n\n@function is_horizontal($side) {\n    @return $side == top or $side == bottom;\n}\n\n@function checked-map-get($map, $key) {\n    $value: map-get($map, $key);\n    @if ($value == null) {\n        @error 'Key ' + $key + ' not found';\n    }\n    @return $value;\n}\n\n@function opposite($val) {\n    @return checked-map-get(\n        (\n            left: right,\n            right: left,\n            top: bottom,\n            bottom: top,\n        ),\n        $val\n    );\n}\n\n// minor-dimension is vertical space in horizontal mode and\n// horizontal space in vertical mode.\n@mixin set-internal-children-property($side, $property,\n                                      $minor_dimension,\n                                      $major_dimension: $minor_dimension,\n                                      $edges: 0) {\n    @if $property != margin and $property != padding {\n        @error \"Property \" + $property + \" not supported!\";\n    }\n\n    @if is_horizontal($side) {\n        #{$property}: $minor_dimension $major_dimension;\n        &:ltr:first-child, &:rtl:last-child {\n            #{$property}-left: $edges;\n        }\n        &:ltr:last-child, &:rtl:first-child {\n            #{$property}-right: $edges;\n        }\n    } @else {\n        #{$property}: $major_dimension $minor_dimension;\n        &:first-child {\n            #{$property}-top: $edges;\n        }\n        &:last-child {\n            #{$property}-bottom: $edges;\n        }\n    }\n}\n\n@mixin padded-edge-child($chid, $side, $padding) {\n    @if $chid == first {\n        @if is_horizontal($side) {\n            padding-left: $padding;\n        } @else {\n            padding-top: $padding;\n        }\n    } @else if $chid == last {\n        @if is_horizontal($side) {\n            padding-right: $padding;\n        } @else {\n            padding-bottom: $padding;\n        }\n    } @else {\n        @error \"Invalid rule\";\n    }\n}\n\n// In extended mode we need to use the first and last .dash-item-container's\n// to apply the padding on the dock, to ensure that the actual first or last\n// child show-apps item will actually include the padding area so that it will\n// be clickable up to the dock edge, and make Fitts happy.\n// I don't think the same should happen for normal icons, so in the other side\n// the padding will be applied via the scrolled area, given we can't get the\n// parent of the first/last app-well-app icon to apply a rule there.\n@mixin padded-dash-edge-items($side, $padding) {\n    @each $child_pos in first, last {\n        > :#{$child_pos}-child {\n            // Use this instead of #dashtodockDashScrollview rule to apply the\n            // padding via the last app-icon item\n            //.dash-item-container:#{$child_pos}-child .app-well-app,\n            .show-apps {\n                @include padded-edge-child($child_pos, $side, $padding);\n            }\n        }\n\n        #dashtodockDashScrollview:#{$child_pos}-child {\n            @include padded-edge-child($child_pos, $side, $padding);\n        }\n    }\n}\n\n$dock_sides: [bottom, top, left, right];\n$dock_style_modes: [null, shrink, extended, extended-shrink];\n\n@mixin dock-container-style($side, $style_mode, $parameters) {\n    $style_selector: '';\n    $is_shrink: checked-map-get($parameters, is_shrink);\n    $is_extended: checked-map-get($parameters, is_extended);\n    $base_padding: checked-map-get($parameters, base_padding);\n    $spacing: checked-map-get($parameters, spacing);\n    $border_radius: checked-map-get($parameters, border_radius);\n    $side_margin: checked-map-get($parameters, side_margin);\n    $padding: checked-map-get($parameters, padding);\n    $margin: checked-map-get($parameters, margin);\n    $edge_items_padding: checked-map-get($parameters, edge_items_padding);\n    $fixed_inner_margin: checked-map-get($parameters, fixed_inner_margin);\n\n    @if ($is_extended) {\n        $style_selector: $style_selector +'.extended';\n    }\n\n    @if ($is_shrink) {\n        $style_selector: $style_selector +'.shrink';\n    }\n\n    &#{$style_selector} {\n        #dash {\n            margin: 0px;\n            padding: 0px;\n\n            .dash-background {\n                margin: 0;\n                margin-#{$side}: $side_margin;\n                padding: 0;\n                border-radius: $border_radius;\n                spacing: $base_padding;\n            }\n\n            .dash-separator {\n                background-color: $borders_color;\n                @if is_horizontal($side) {\n                    margin: 0 $margin;\n                    width: 1px;\n                    height: 0;\n                } @else {\n                    width: 0;\n                    height: 1px;\n                    margin: $margin 0;\n                }\n                margin-#{$side}: $side_margin;\n            }\n\n            #dashtodockDashContainer {\n                padding: if($is_extended, 0, $padding);\n                padding-#{$side}: 0;\n                padding-#{opposite($side)}: 0;\n\n                @if ($is_extended) {\n                    @include padded-dash-edge-items($side, $edge_items_padding);\n                }\n            }\n\n            .dash-item-container {\n                /* Disable all margins defined upstream, we handle them here */\n                > * {margin: 0;}\n\n                @include set-internal-children-property($side, margin,\n                    0, $dock_icons_distance / 2);\n\n                .app-well-app,\n                .show-apps,\n                .overview-tile {\n                    @include set-internal-children-property($side, padding, $spacing);\n                    padding-#{$side}: $padding + $side_margin;\n                    padding-#{opposite($side)}: $padding;\n\n                    &.updating {\n                        opacity: 0.5;\n                    };\n                }\n\n                .app-well-app,\n                .overview-tile {\n                    &.running .overview-icon {\n                        background-image: none;\n                    }\n                    &.focused .overview-icon {\n                        background-color: $remark_color;\n                    }\n\n                    .app-well-app-running-dot,\n                    .app-grid-running-dot {\n                        margin-bottom: 2px;\n                    }\n                }\n\n                > StButton {\n                    transition-duration: 250;\n                    background-size: contain;\n                }\n            }\n        }\n\n        &.fixed {\n            #dash {\n                .dash-background {\n                    margin-#{opposite($side)}: $fixed_inner_margin;\n                }\n\n                .dash-item-container {\n\n                    .app-well-app,\n                    .show-apps {\n                        padding-#{opposite($side)}: $padding + $fixed_inner_margin;\n                    }\n                }\n            }\n        }\n    }\n}\n\n.dash-item-container .overview-tile .overview-icon,\n.dash-item-container .show-apps .overview-icon {\n    background-color: rgba(255,255,255,0);\n}\n\n.dash-item-container .overview-tile:hover .overview-icon,\n.dash-item-container .overview-tile.focused .overview-icon,\n.dash-item-container .show-apps:hover .overview-icon {\n    background-color: $remark_color;\n}\n\n.dash-item-container .overview-tile .app-grid-running-dot {\n    margin-bottom: $dash_padding_gnome - 4px;\n    offset-y: -$dash_padding + $dash_edge_offset;\n}\n\n@each $side in $dock_sides {\n    @each $style_mode in $dock_style_modes {\n        $is_shrink: str-index(#{$style_mode}, shrink) !=null;\n        $is_extended: str-index(#{$style_mode}, extended) !=null;\n\n        #dashtodockContainer.#{$side} {\n            $parameters: (\n                is_shrink: $is_shrink,\n                is_extended: $is_extended,\n                base_padding: $base_padding,\n                spacing: $dock_spacing,\n                border_radius: $dash_border_radius,\n                side_margin: $dock_side_margin,\n                padding: $dash_padding,\n                margin: $base_margin,\n                edge_items_padding: $dock_edge_items_padding,\n                fixed_inner_margin: $dock_fixed_inner_margin,\n            );\n\n            @if ($is_shrink) {\n                $parameters: map-merge($parameters, (\n                    base_padding: shrink($base_padding),\n                    spacing: shrink($dock_spacing),\n                    border_radius: shrink_light($dash_border_radius),\n                    side_margin: /* not shrunk */ $dock_side_margin,\n                    padding: shrink($dash_padding),\n                    margin: shrink($base_margin),\n                    edge_items_padding: shrink_light($dock_edge_items_padding),\n                    fixed_inner_margin: shrink($dock_fixed_inner_margin),\n                ));\n            }\n\n            @if ($is_extended) {\n                $parameters: map-merge($parameters, (\n                    border_radius: 0,\n                    side_margin: 0,\n                    fixed_inner_margin: 0,\n                ));\n            }\n\n            @include dock-container-style($side, $style_mode, $parameters);\n        }\n\n        .dash-label.#{$side} {\n            $label_offset: if($is_shrink, shrink($dash_padding), $dash_padding);\n            $style_selector: if($is_shrink, '.shrink', null);\n\n            &#{$style_selector} {\n                @if is_horizontal($side) {\n                    margin-#{$side}: $label_offset;\n                    -x-offset: 0;\n                    -y-offset: 0;\n                } @else {\n                    margin: 0;\n                    -x-offset: $label_offset;\n                    -y-offset: 0;\n                }\n            }\n        }\n    }\n\n    .dashtodock-app-well-preview-menu-item.#{$side} {\n        @include set-internal-children-property($side, padding,\n            0.5em, 0.5em, 1em);\n    }\n}\n\n#dashtodockContainer.top.shrink #dash .dash-background {\n    margin-top: 4px;\n    margin-bottom: 0;\n}\n\n#dashtodockContainer.straight-corner #dash .dash-background,\n#dashtodockContainer.shrink.straight-corner #dash .dash-background {\n    border-radius: 0px;\n}\n\n/* Scrollview style */\n.bottom #dashtodockDashScrollview,\n.top #dashtodockDashScrollview {\n    -st-hfade-offset: 24px;\n}\n\n.left #dashtodockDashScrollview,\n.right #dashtodockDashScrollview {\n    -st-vfade-offset: 24px;\n}\n\n#dashtodockContainer.dashtodock #dash .dash-background {\n    background: $dash_background_color;\n}\n\n#dashtodockContainer.dashtodock .progress-bar,\n.overview-tile .progress-bar,\n.icon-grid .progress-bar {\n    /* Customization of the progress bar style. The possible elements\n     * are:\n     *\n     * -XXXXXX-YYYYYY: plain color\n     * -XXXXXX-YYYYYY-color-start: start color for gradient\n     * -XXXXXX-YYYYYY-color-end: end color for gradient\n     * -XXXXXX-YYYYYY-offset-start: offset for start color in gradient (0-1)\n     * -XXXXXX-YYYYYY-offset-end: offset for end color in gradient (0-1)\n     * -XXXXXX-line-width: width value for the line used for the border\n     *\n     * XXXXXX can be either\n     *\n     *    progress-bar-track: the \"track\" over which the progress bar is shown\n     *    progress-bar: the progress bar itself\n     *\n     * YYYYYY can be either\n     *\n     *    background: for the background color\n     *    border: for the border color\n     *\n     * plain color entries have priority over gradients, so if both are set for\n     * an element, the plain color will be used.\n     *\n     * Examples:\n     *\n     *  -progress-bar-track-background: rgba(128, 128, 0, 0.75);\n     *  -progress-bar-track-border: rgba(0, 0, 255, 0.25);\n     *\n     *  -progress-bar-background: rgba(0, 204, 204, 1);\n     *  -progress-bar-border: rgba(230, 230, 230, 1);\n     *\n     * Default values when these entries aren't set are equivalent to:\n     *   -progress-bar-track-background-color-start: 64, 64, 64, 1.0\n     *   -progress-bar-track-background-color-end: 89, 89, 89, 1.0\n     *   -progress-bar-track-background-start-offset: 0.4\n     *   -progress-bar-track-background-end-offset: 0.9\n     *   -progress-bar-track-border-color-start: 128, 128, 128, 0.1\n     *   -progress-bar-track-border-color-end: 89, 89, 89, 0.4\n     *   -progress-bar-track-border-start-offset: 0.5\n     *   -progress-bar-track-border-end-offset: 0.9\n     *   -progress-bar-track-line-width: 1\n     *   -progress-bar-background: 204, 204, 204, 1.0\n     *   -progress-bar-border: 230, 230, 230, 1.0\n     *   -progress-bar-height-factor: (0.20) 20% of the icon size\n     *   -progress-bar-line-width: 1\n     *   -progress-bar-top-offset: undefined\n     *   -progress-bar-valign: 1.0\n     *   -progress-bar-horizontal-padding: 0.05 (5% of icon size)\n     *   -progress-bar-vertical-padding: 0.05 (5% of icon size)\n     */\n    -progress-bar-track-background: rgba(0, 0, 0, 0.45);\n    -progress-bar-track-border: rgba(0, 0, 0, 0.7);\n    -progress-bar-background: rgba(255, 255, 255, 1.0);\n    -progress-bar-border: rgba(255, 255, 255, 1.0);\n}\n\n#overview,\n.apps-scroll-view {\n    .progress-bar {\n        -progress-bar-height-factor: 0.15;\n        -progress-bar-top-offset: 0;\n        -progress-bar-valign: 0.95;\n    }\n}\n\n#overview .grid-search-results .overview-tile .progress-bar,\n#overview .app-folder-dialog .progress-bar {\n    -progress-bar-height-factor: 0.13;\n}\n\n#dashtodockContainer.top #dash .placeholder,\n#dashtodockContainer.bottom #dash .placeholder {\n    width: 32px;\n    height: 1px;\n}\n\n/*\n * This is applied to a dummy actor. Only the alpha value for the background and border color\n * and the transition-duration are used\n */\n#dashtodockContainer.dummy-opaque {\n    background-color: rgba(0, 0, 0, 0.8);\n    border-color: rgba(0, 0, 0, 0.4);\n    transition-duration: 300ms;\n}\n\n/*\n * This is applied to a dummy actor. Only the alpha value for the background and border color\n * and the transition-duration are used\n */\n#dashtodockContainer.dummy-transparent {\n    background-color: rgba(0, 0, 0, 0.2);\n    border-color: rgba(0, 0, 0, 0.1);\n    transition-duration: 500ms;\n}\n\n#dashtodockContainer .number-overlay,\n.overview-tile .number-overlay,\n.icon-grid .number-overlay {\n    color: rgba(255, 255, 255, 1);\n    background-color: rgba(0, 0, 0, 0.8);\n    text-align: center;\n}\n\n#dashtodockContainer .notification-badge,\n.overview-tile .notification-badge,\n.icon-grid .notification-badge {\n    color: rgba(255, 255, 255, 1);\n    background-color: rgba(255, 0, 0, 1);\n    padding: 0.2em 0.5em;\n    border-radius: 1em;\n    font-weight: bold;\n    text-align: center;\n    margin: 2px;\n}\n\n#dashtodockPreviewSeparator.popup-separator-menu-item-horizontal {\n    width: 1px;\n    height: auto;\n    border-right-width: 1px;\n    margin: 32px 0px;\n}\n\n#dashtodockContainer .metro .overview-icon {\n    border-radius: 0px;\n}\n\n@for $i from 2 through 4 {\n    #dashtodockContainer.bottom .metro.running#{$i}.focused,\n    #dashtodockContainer.top .metro.running#{$i}.focused {\n        background-image: url(\"./media/highlight_stacked_bg.svg\");\n        background-position: 0px 0px;\n        background-size: contain;\n    }\n\n    #dashtodockContainer.left .metro.running#{$i}.focused,\n    #dashtodockContainer.right .metro.running#{$i}.focused {\n        background-image: url(\"./media/highlight_stacked_bg_h.svg\");\n        background-position: 0px 0px;\n        background-size: contain;\n    }\n}\n"
        },
        {
          "name": "appIconIndicators.js",
          "type": "blob",
          "size": 44.142578125,
          "content": "import {\n    Clutter,\n    Cogl,\n    GdkPixbuf,\n    Gio,\n    GObject,\n    Pango,\n    St,\n} from './dependencies/gi.js';\n\nimport {Main} from './dependencies/shell/ui.js';\n\nimport {\n    Docking,\n    Utils,\n} from './imports.js';\n\nconst {cairo: Cairo} = imports;\n\nconst RunningIndicatorStyle = Object.freeze({\n    DEFAULT: 0,\n    DOTS: 1,\n    SQUARES: 2,\n    DASHES: 3,\n    SEGMENTED: 4,\n    SOLID: 5,\n    CILIORA: 6,\n    METRO: 7,\n    BINARY: 8,\n    DOT: 9,\n});\n\nconst MAX_WINDOWS_CLASSES = 4;\n\n\n/*\n * This is the main indicator class to be used. The desired behavior is\n * obtained by composing the desired classes below based on the settings.\n *\n */\nexport class AppIconIndicator {\n    constructor(source) {\n        this._indicators = [];\n\n        // Choose the style for the running indicators\n        let runningIndicator = null;\n        let runningIndicatorStyle;\n\n        const {settings} = Docking.DockManager;\n        if (settings.applyCustomTheme)\n            runningIndicatorStyle = RunningIndicatorStyle.DOTS;\n        else\n            ({runningIndicatorStyle} = settings);\n\n        if (settings.showIconsEmblems &&\n            !Docking.DockManager.getDefault().notificationsMonitor.dndMode) {\n            const unityIndicator = new UnityIndicator(source);\n            this._indicators.push(unityIndicator);\n        }\n\n        switch (runningIndicatorStyle) {\n        case RunningIndicatorStyle.DEFAULT:\n            runningIndicator = new RunningIndicatorDefault(source);\n            break;\n\n        case RunningIndicatorStyle.DOTS:\n            runningIndicator = new RunningIndicatorDots(source);\n            break;\n\n        case RunningIndicatorStyle.SQUARES:\n            runningIndicator = new RunningIndicatorSquares(source);\n            break;\n\n        case RunningIndicatorStyle.DASHES:\n            runningIndicator = new RunningIndicatorDashes(source);\n            break;\n\n        case RunningIndicatorStyle.SEGMENTED:\n            runningIndicator = new RunningIndicatorSegmented(source);\n            break;\n\n        case RunningIndicatorStyle.SOLID:\n            runningIndicator = new RunningIndicatorSolid(source);\n            break;\n\n        case RunningIndicatorStyle.CILIORA:\n            runningIndicator = new RunningIndicatorCiliora(source);\n            break;\n\n        case RunningIndicatorStyle.METRO:\n            runningIndicator = new RunningIndicatorMetro(source);\n            break;\n\n        case RunningIndicatorStyle.BINARY:\n            runningIndicator = new RunningIndicatorBinary(source);\n            break;\n\n        case RunningIndicatorStyle.DOT:\n            runningIndicator = new RunningIndicatorDot(source);\n            break;\n\n        default:\n            runningIndicator = new RunningIndicatorBase(source);\n        }\n\n        this._indicators.push(runningIndicator);\n    }\n\n    update() {\n        for (let i = 0; i < this._indicators.length; i++) {\n            const indicator = this._indicators[i];\n            indicator.update();\n        }\n    }\n\n    destroy() {\n        for (let i = 0; i < this._indicators.length; i++) {\n            const indicator = this._indicators[i];\n            indicator.destroy();\n        }\n    }\n}\n\n/*\n * Base class to be inherited by all indicators of any kind\n*/\nclass IndicatorBase {\n    constructor(source) {\n        this._source = source;\n        this._signalsHandler = new Utils.GlobalSignalsHandler(this._source);\n    }\n\n    update() {\n    }\n\n    destroy() {\n        this._source = null;\n        this._signalsHandler.destroy();\n        this._signalsHandler = null;\n    }\n}\n\n/*\n * A base indicator class for running style, from which all other RunningIndicators should derive,\n * providing some basic methods, variables definitions and their update,  css style classes handling.\n *\n */\nclass RunningIndicatorBase extends IndicatorBase {\n    constructor(source) {\n        super(source);\n\n        this._side = Utils.getPosition();\n        this._dominantColorExtractor = new DominantColorExtractor(this._source.app);\n        this._signalsHandler.add(this._source, 'notify::running', () => this.update());\n        this._signalsHandler.add(this._source, 'notify::focused', () => this.update());\n        this._signalsHandler.add(this._source, 'notify::windows-count', () => this._updateCounterClass());\n        this.update();\n    }\n\n    get _number() {\n        return Math.min(this._source.windowsCount, MAX_WINDOWS_CLASSES);\n    }\n\n    update() {\n        this._updateCounterClass();\n        this._updateDefaultDot();\n    }\n\n    _updateCounterClass() {\n        for (let i = 1; i <= MAX_WINDOWS_CLASSES; i++) {\n            const className = `running${i}`;\n            if (i !== this._number)\n                this._source.remove_style_class_name(className);\n            else\n                this._source.add_style_class_name(className);\n        }\n    }\n\n    _updateDefaultDot() {\n        if (this._source.running)\n            this._source._dot.show();\n        else\n            this._source._dot.hide();\n    }\n\n    _hideDefaultDot() {\n        // I use opacity to hide the default dot because the show/hide function\n        // are used by the parent class.\n        this._source._dot.opacity = 0;\n    }\n\n    _restoreDefaultDot() {\n        this._source._dot.opacity = 255;\n    }\n\n    _enableBacklight() {\n        const colorPalette = this._dominantColorExtractor._getColorPalette();\n\n        // Fallback\n        if (!colorPalette) {\n            this._source._iconContainer.set_style(\n                'border-radius: 5px;' +\n                'background-gradient-direction: vertical;' +\n                'background-gradient-start: #e0e0e0;' +\n                'background-gradient-end: darkgray;'\n            );\n\n            return;\n        }\n\n        this._source._iconContainer.set_style(\n            `${'border-radius: 5px;' +\n            'background-gradient-direction: vertical;' +\n            'background-gradient-start: '}${colorPalette.original};` +\n            `background-gradient-end: ${colorPalette.darker};`\n        );\n    }\n\n    _disableBacklight() {\n        this._source._iconContainer.set_style(null);\n    }\n\n    destroy() {\n        this._disableBacklight();\n        // Remove glossy background if the children still exists\n        if (this._source._iconContainer.get_children().length > 1)\n            this._source._iconContainer.get_children()[1].set_style(null);\n        this._restoreDefaultDot();\n\n        super.destroy();\n    }\n}\n\n// We add a css class so third parties themes can limit their indicator customization\n// to the case we do nothing\nclass RunningIndicatorDefault extends RunningIndicatorBase {\n    constructor(source) {\n        super(source);\n        this._source.add_style_class_name('default');\n    }\n\n    destroy() {\n        this._source.remove_style_class_name('default');\n        super.destroy();\n    }\n}\n\nconst IndicatorDrawingArea = GObject.registerClass(\nclass IndicatorDrawingArea extends St.DrawingArea {\n    vfunc_allocate(box) {\n        if (box.x1 !== 0 || box.y1 !== 0)\n            return super.vfunc_allocate(box);\n\n        // We assume that the are is a rectangle in the operations below:\n        const size = Math.min(box.get_width(), box.get_height());\n        box.x2 = size;\n        box.y2 = size;\n        this.set_allocation(box);\n\n        return super.vfunc_allocate(box);\n    }\n});\n\nclass RunningIndicatorDots extends RunningIndicatorBase {\n    constructor(source) {\n        super(source);\n\n        this._hideDefaultDot();\n\n        this._area = new IndicatorDrawingArea({\n            x_expand: true,\n            y_expand: true,\n        });\n\n        // We draw for the bottom case and rotate the canvas for other placements\n        // set center of rotations to the center\n        this._area.set_pivot_point(0.5, 0.5);\n\n        switch (this._side) {\n        case St.Side.TOP:\n            this._area.rotation_angle_z = 180;\n            break;\n\n        case St.Side.BOTTOM:\n            // nothing\n            break;\n\n        case St.Side.LEFT:\n            this._area.rotation_angle_z = 90;\n            break;\n\n        case St.Side.RIGHT:\n            this._area.rotation_angle_z = -90;\n            break;\n        }\n\n        this._area.connect('repaint', this._updateIndicator.bind(this));\n        this._source._iconContainer.add_child(this._area);\n\n        const keys = ['custom-theme-running-dots-color',\n            'custom-theme-running-dots-border-color',\n            'custom-theme-running-dots-border-width',\n            'custom-theme-customize-running-dots',\n            'unity-backlit-items',\n            'apply-glossy-effect',\n            'running-indicator-dominant-color'];\n\n        keys.forEach(function (key) {\n            this._signalsHandler.add(\n                Docking.DockManager.settings,\n                `changed::${key}`,\n                this.update.bind(this)\n            );\n        }, this);\n\n        // Apply glossy background\n        // TODO: move to enable/disableBacklit to apply it only to the running apps?\n        // TODO: move to css class for theming support\n        const {extension} = Docking.DockManager;\n        this._glossyBackgroundStyle = `background-image: url('${extension.path}/media/glossy.svg');` +\n                                      'background-size: contain;';\n    }\n\n    update() {\n        super.update();\n\n        // Enable / Disable the backlight of running apps\n        if (!Docking.DockManager.settings.applyCustomTheme &&\n            Docking.DockManager.settings.unityBacklitItems) {\n            const [icon] = this._source._iconContainer.get_children();\n            icon.set_style(\n                Docking.DockManager.settings.applyGlossyEffect\n                    ? this._glossyBackgroundStyle : null);\n            if (this._source.running)\n                this._enableBacklight();\n            else\n                this._disableBacklight();\n        } else {\n            this._disableBacklight();\n            this._source._iconContainer.get_children()[1].set_style(null);\n        }\n\n        if (this._area)\n            this._area.queue_repaint();\n    }\n\n    _computeStyle() {\n        const [width, height] = this._area.get_surface_size();\n        this._width = height;\n        this._height = width;\n\n        // By default re-use the style - background color, and border width and color -\n        // of the default dot\n        const themeNode = this._source._dot.get_theme_node();\n        this._borderColor = themeNode.get_border_color(this._side);\n        this._borderWidth = themeNode.get_border_width(this._side);\n        this._bodyColor = themeNode.get_background_color();\n\n        const {settings} = Docking.DockManager;\n        if (!settings.applyCustomTheme) {\n            // Adjust for the backlit case\n            const Color = Clutter.Color ?? Cogl.Color;\n\n            if (settings.unityBacklitItems) {\n                // Use dominant color for dots too if the backlit is enables\n                const colorPalette = this._dominantColorExtractor._getColorPalette();\n\n                // Slightly adjust the styling\n                this._borderWidth = 2;\n\n                if (colorPalette) {\n                    [, this._borderColor] = Color.from_string(colorPalette.lighter);\n                    [, this._bodyColor] = Color.from_string(colorPalette.darker);\n                } else {\n                    // Fallback\n                    [, this._borderColor] = Color.from_string('white');\n                    [, this._bodyColor] = Color.from_string('gray');\n                }\n            }\n\n            // Apply dominant color if requested\n            if (settings.runningIndicatorDominantColor) {\n                const colorPalette = this._dominantColorExtractor._getColorPalette();\n                if (colorPalette)\n                    [, this._bodyColor] = Color.from_string(colorPalette.original);\n                else\n                    // Fallback\n                    [, this._bodyColor] = Color.from_string(settings.customThemeRunningDotsColor);\n            }\n\n            // Finally, use customize style if requested\n            if (settings.customThemeCustomizeRunningDots) {\n                [, this._borderColor] = Color.from_string(settings.customThemeRunningDotsBorderColor);\n                this._borderWidth = settings.customThemeRunningDotsBorderWidth;\n                [, this._bodyColor] =  Color.from_string(settings.customThemeRunningDotsColor);\n            }\n        }\n\n        // Define the radius as an arbitrary size, but keep large enough to account\n        // for the drawing of the border.\n        this._radius = Math.max(this._width / 22, this._borderWidth / 2);\n        this._padding = 0; // distance from the margin\n        this._spacing = this._radius + this._borderWidth; // separation between the dots\n    }\n\n    _updateIndicator() {\n        const cr = this._area.get_context();\n\n        this._computeStyle();\n        this._drawIndicator(cr);\n        cr.$dispose();\n    }\n\n    _drawIndicator(cr) {\n        // Draw the required numbers of dots\n        const n = this._number;\n\n        cr.setLineWidth(this._borderWidth);\n        Utils.cairoSetSourceColor(cr, this._borderColor);\n\n        // draw for the bottom case:\n        cr.translate(\n            (this._width - (2 * n) * this._radius - (n - 1) * this._spacing) / 2,\n            this._height - this._padding);\n\n        for (let i = 0; i < n; i++) {\n            cr.newSubPath();\n            cr.arc((2 * i + 1) * this._radius + i * this._spacing,\n                -this._radius - this._borderWidth / 2,\n                this._radius, 0, 2 * Math.PI);\n        }\n\n        cr.strokePreserve();\n        Utils.cairoSetSourceColor(cr, this._bodyColor);\n        cr.fill();\n    }\n\n    destroy() {\n        this._area.destroy();\n        super.destroy();\n    }\n}\n\n// Adapted from dash-to-panel by Jason DeRose\n// https://github.com/jderose9/dash-to-panel\nclass RunningIndicatorCiliora extends RunningIndicatorDots {\n    _drawIndicator(cr) {\n        if (this._source.running) {\n            const size =  Math.max(this._width / 20, this._borderWidth);\n            const spacing = size; // separation between the dots\n            const lineLength = this._width - (size * (this._number - 1)) - (spacing * (this._number - 1));\n            let padding = this._borderWidth;\n            // For the backlit case here we don't want the outer border visible\n            if (Docking.DockManager.settings.unityBacklitItems &&\n                !Docking.DockManager.settings.customThemeCustomizeRunningDots)\n                padding = 0;\n            const yOffset = this._height - padding - size;\n\n            cr.setLineWidth(this._borderWidth);\n            Utils.cairoSetSourceColor(cr, this._borderColor);\n\n            cr.translate(0, yOffset);\n            cr.newSubPath();\n            cr.rectangle(0, 0, lineLength, size);\n            for (let i = 1; i < this._number; i++) {\n                cr.newSubPath();\n                cr.rectangle(lineLength + (i * spacing) + ((i - 1) * size), 0, size, size);\n            }\n\n            cr.strokePreserve();\n            Utils.cairoSetSourceColor(cr, this._bodyColor);\n            cr.fill();\n        }\n    }\n}\n\n// Adapted from dash-to-panel by Jason DeRose\n// https://github.com/jderose9/dash-to-panel\nclass RunningIndicatorSegmented extends RunningIndicatorDots {\n    _drawIndicator(cr) {\n        if (this._source.running) {\n            const size =  Math.max(this._width / 20, this._borderWidth);\n            const spacing = Math.ceil(this._width / 18); // separation between the dots\n            const dashLength = Math.ceil((this._width - ((this._number - 1) * spacing)) / this._number);\n            let padding = this._borderWidth;\n            // For the backlit case here we don't want the outer border visible\n            if (Docking.DockManager.settings.unityBacklitItems &&\n                !Docking.DockManager.settings.customThemeCustomizeRunningDots)\n                padding = 0;\n            const yOffset = this._height - padding - size;\n\n            cr.setLineWidth(this._borderWidth);\n            Utils.cairoSetSourceColor(cr, this._borderColor);\n\n            cr.translate(0, yOffset);\n            for (let i = 0; i < this._number; i++) {\n                cr.newSubPath();\n                cr.rectangle(i * dashLength + i * spacing, 0, dashLength, size);\n            }\n\n            cr.strokePreserve();\n            Utils.cairoSetSourceColor(cr, this._bodyColor);\n            cr.fill();\n        }\n    }\n}\n\n// Adapted from dash-to-panel by Jason DeRose\n// https://github.com/jderose9/dash-to-panel\nclass RunningIndicatorSolid extends RunningIndicatorDots {\n    _drawIndicator(cr) {\n        if (this._source.running) {\n            const size =  Math.max(this._width / 20, this._borderWidth);\n            let padding = this._borderWidth;\n            // For the backlit case here we don't want the outer border visible\n            if (Docking.DockManager.settings.unityBacklitItems &&\n                !Docking.DockManager.settings.customThemeCustomizeRunningDots)\n                padding = 0;\n            const yOffset = this._height - padding - size;\n\n            cr.setLineWidth(this._borderWidth);\n            Utils.cairoSetSourceColor(cr, this._borderColor);\n\n            cr.translate(0, yOffset);\n            cr.newSubPath();\n            cr.rectangle(0, 0, this._width, size);\n\n            cr.strokePreserve();\n            Utils.cairoSetSourceColor(cr, this._bodyColor);\n            cr.fill();\n        }\n    }\n}\n\n// Adapted from dash-to-panel by Jason DeRose\n// https://github.com/jderose9/dash-to-panel\nclass RunningIndicatorSquares extends RunningIndicatorDots {\n    _drawIndicator(cr) {\n        if (this._source.running) {\n            const size =  Math.max(this._width / 11, this._borderWidth);\n            const padding = this._borderWidth;\n            const spacing = Math.ceil(this._width / 18); // separation between the dots\n            const yOffset = this._height - padding - size;\n\n            cr.setLineWidth(this._borderWidth);\n            Utils.cairoSetSourceColor(cr, this._borderColor);\n\n            cr.translate(\n                Math.floor((this._width - this._number * size - (this._number - 1) * spacing) / 2),\n                yOffset);\n\n            for (let i = 0; i < this._number; i++) {\n                cr.newSubPath();\n                cr.rectangle(i * size + i * spacing, 0, size, size);\n            }\n            cr.strokePreserve();\n            Utils.cairoSetSourceColor(cr, this._bodyColor);\n            cr.fill();\n        }\n    }\n}\n\n// Adapted from dash-to-panel by Jason DeRose\n// https://github.com/jderose9/dash-to-panel\nclass RunningIndicatorDashes extends RunningIndicatorDots {\n    _drawIndicator(cr) {\n        if (this._source.running) {\n            const size =  Math.max(this._width / 20, this._borderWidth);\n            const padding = this._borderWidth;\n            const spacing = Math.ceil(this._width / 18); // separation between the dots\n            const dashLength = Math.floor(this._width / 4) - spacing;\n            const yOffset = this._height - padding - size;\n\n            cr.setLineWidth(this._borderWidth);\n            Utils.cairoSetSourceColor(cr, this._borderColor);\n\n            cr.translate(\n                Math.floor((this._width - this._number * dashLength - (this._number - 1) * spacing) / 2),\n                yOffset);\n\n            for (let i = 0; i < this._number; i++) {\n                cr.newSubPath();\n                cr.rectangle(i * dashLength + i * spacing, 0, dashLength, size);\n            }\n\n            cr.strokePreserve();\n            Utils.cairoSetSourceColor(cr, this._bodyColor);\n            cr.fill();\n        }\n    }\n}\n\n// Adapted from dash-to-panel by Jason DeRose\n// https://github.com/jderose9/dash-to-panel\nclass RunningIndicatorMetro extends RunningIndicatorDots {\n    constructor(source) {\n        super(source);\n        this._source.add_style_class_name('metro');\n    }\n\n    destroy() {\n        this._source.remove_style_class_name('metro');\n        super.destroy();\n    }\n\n    _drawIndicator(cr) {\n        if (this._source.running) {\n            const size =  Math.max(this._width / 20, this._borderWidth);\n            let padding = 0;\n            // For the backlit case here we don't want the outer border visible\n            if (Docking.DockManager.settings.unityBacklitItems &&\n                !Docking.DockManager.settings.customThemeCustomizeRunningDots)\n                padding = 0;\n            const yOffset = this._height - padding - size;\n\n            const n = this._number;\n            if (n <= 1) {\n                cr.translate(0, yOffset);\n                Utils.cairoSetSourceColor(cr, this._bodyColor);\n                cr.newSubPath();\n                cr.rectangle(0, 0, this._width, size);\n                cr.fill();\n            } else {\n                // need to scale with the SVG for the stacked highlight\n                const blackenedLength = (1 / 48) * this._width;\n                const darkenedLength = this._source.focused\n                    ? (2 / 48) * this._width : (10 / 48) * this._width;\n                const blackenedColor = this._bodyColor.shade(.3);\n                const darkenedColor = this._bodyColor.shade(.7);\n\n                cr.translate(0, yOffset);\n\n                Utils.cairoSetSourceColor(cr, this._bodyColor);\n                cr.newSubPath();\n                cr.rectangle(0, 0, this._width - darkenedLength - blackenedLength, size);\n                cr.fill();\n                Utils.cairoSetSourceColor(cr, blackenedColor);\n                cr.newSubPath();\n                cr.rectangle(this._width - darkenedLength - blackenedLength, 0, 1, size);\n                cr.fill();\n                Utils.cairoSetSourceColor(cr, darkenedColor);\n                cr.newSubPath();\n                cr.rectangle(this._width - darkenedLength, 0, darkenedLength, size);\n                cr.fill();\n            }\n        }\n    }\n}\n\nclass RunningIndicatorBinary extends RunningIndicatorDots {\n    _drawIndicator(cr) {\n        // Draw the required numbers of dots\n        const n = Math.min(15, this._source.windowsCount);\n\n        if (this._source.running) {\n            const size =  Math.max(this._width / 11, this._borderWidth);\n            const spacing = Math.ceil(this._width / 18);\n            const yOffset = this._height - size;\n            const binaryValue = String(`0000${(n >>> 0).toString(2)}`).slice(-4);\n\n            cr.setLineWidth(this._borderWidth);\n            Utils.cairoSetSourceColor(cr, this._borderColor);\n\n            cr.translate(Math.floor((this._width - 4 * size - (4 - 1) * spacing) / 2), yOffset);\n            for (let i = 0; i < binaryValue.length; i++) {\n                if (binaryValue[i] === '1') {\n                    cr.newSubPath();\n                    cr.arc((2 * i + 1) * this._radius + i * spacing,\n                        -this._radius - this._borderWidth / 2,\n                        this._radius, 0, 2 * Math.PI);\n                } else {\n                    cr.newSubPath();\n                    cr.rectangle(i * size + i * spacing,\n                        -this._radius - this._borderWidth / 2 - size / 5,\n                        size, size / 3);\n                }\n            }\n            cr.strokePreserve();\n            Utils.cairoSetSourceColor(cr, this._bodyColor);\n            cr.fill();\n        }\n    }\n}\n\nclass RunningIndicatorDot extends RunningIndicatorDots {\n    _computeStyle() {\n        super._computeStyle();\n\n        this._radius = Math.max(this._width / 26, this._borderWidth / 2);\n    }\n\n    _drawIndicator(cr) {\n        if (!this._source.running)\n            return;\n\n        cr.setLineWidth(this._borderWidth);\n        Utils.cairoSetSourceColor(cr, this._borderColor);\n\n        // draw from the bottom case:\n        cr.translate(\n            (this._width - 2 * this._radius) / 2,\n            this._height - this._padding);\n        cr.newSubPath();\n        cr.arc(this._radius,\n            -this._radius - this._borderWidth / 2,\n            this._radius, 0, 2 * Math.PI);\n\n        cr.strokePreserve();\n        Utils.cairoSetSourceColor(cr, this._bodyColor);\n        cr.fill();\n    }\n}\n\n/*\n * Unity like notification and progress indicators\n */\nexport class UnityIndicator extends IndicatorBase {\n    static defaultProgressBar = {\n        // default values for the progress bar itself\n        background: {\n            colorStart: {red: 204, green: 204, blue: 204, alpha: 255},\n            colorEnd: null,\n        },\n        border: {\n            colorStart: {red: 230, green: 230, blue: 230, alpha: 255},\n            colorEnd: null,\n        },\n    };\n\n    static defaultProgressBarTrack = {\n        // default values for the progress bar track\n        background: {\n            colorStart: {red: 64, green: 64, blue: 64, alpha: 255},\n            colorEnd: {red: 89, green: 89, blue: 89, alpha: 255},\n            offsetStart: 0.4,\n            offsetEnd: 0.9,\n        },\n        border: {\n            colorStart: {red: 128, green: 128, blue: 128, alpha: 26},\n            colorEnd: {red: 204, green: 204, blue: 204, alpha: 102},\n            offsetStart: 0.5,\n            offsetEnd: 0.9,\n        },\n    };\n\n    static notificationBadgeSignals = Symbol('notification-badge-signals');\n\n    constructor(source) {\n        super(source);\n\n        const {remoteModel, notificationsMonitor} = Docking.DockManager.getDefault();\n        const remoteEntry = remoteModel.lookupById(this._source.app.id);\n        this._remoteEntry = remoteEntry;\n\n        this._signalsHandler.add([\n            remoteEntry,\n            ['count-changed', 'count-visible-changed'],\n            () => this._updateNotificationsCount(),\n        ], [\n            remoteEntry,\n            ['progress-changed', 'progress-visible-changed'],\n            (sender, {progress, progress_visible: progressVisible}) =>\n                this.setProgress(progressVisible ? progress : -1),\n        ], [\n            remoteEntry,\n            'urgent-changed',\n            (sender, {urgent}) => this.setUrgent(urgent),\n        ], [\n            remoteEntry,\n            'updating-changed',\n            (sender, {updating}) => this.setUpdating(updating),\n        ], [\n            notificationsMonitor,\n            'changed',\n            () => this._updateNotificationsCount(),\n        ], [\n            this._source,\n            'style-changed',\n            () => this._updateIconStyle(),\n        ]);\n\n        this._updateNotificationsCount();\n        this.setProgress(this._remoteEntry.progress_visible\n            ? this._remoteEntry.progress : -1);\n        this.setUrgent(this._remoteEntry.urgent);\n        this.setUpdating(this._remoteEntry.updating);\n    }\n\n    destroy() {\n        this._notificationBadgeBin?.destroy();\n        this._notificationBadgeBin = null;\n        this._hideProgressOverlay();\n        this.setUrgent(false);\n        this.setUpdating(false);\n        this._remoteEntry = null;\n\n        super.destroy();\n    }\n\n    _updateNotificationBadgeStyle() {\n        const themeContext = St.ThemeContext.get_for_stage(global.stage);\n        const fontDesc = themeContext.get_font();\n        const defaultFontSize = fontDesc.get_size() / 1024;\n        let fontSize = defaultFontSize * 0.9;\n        const {iconSize} = Main.overview.dash;\n        const defaultIconSize = Docking.DockManager.settings.get_default_value(\n            'dash-max-icon-size').unpack();\n\n        if (!fontDesc.get_size_is_absolute()) {\n            // fontSize was expressed in points, so convert to pixel\n            fontSize /= 0.75;\n        }\n\n        let sizeMultiplier;\n        if (iconSize < defaultIconSize) {\n            sizeMultiplier = Math.max(24, Math.min(iconSize +\n                iconSize * 0.3, defaultIconSize)) / defaultIconSize;\n        } else {\n            sizeMultiplier = iconSize / defaultIconSize;\n        }\n\n        fontSize = Math.round(sizeMultiplier * fontSize);\n        const leftMargin = Math.round(sizeMultiplier * 3);\n\n        this._notificationBadgeBin.child.set_style(\n            `font-size: ${fontSize}px;` +\n            `margin-left: ${leftMargin}px`\n        );\n    }\n\n    _notificationBadgeCountToText(count) {\n        if (count <= 9999) {\n            return count.toString();\n        } else if (count < 1e5) {\n            const thousands = count / 1e3;\n            return `${thousands.toFixed(1).toString()}k`;\n        } else if (count < 1e6) {\n            const thousands = count / 1e3;\n            return `${thousands.toFixed(0).toString()}k`;\n        } else if (count < 1e8) {\n            const millions = count / 1e6;\n            return `${millions.toFixed(1).toString()}M`;\n        } else if (count < 1e9) {\n            const millions = count / 1e6;\n            return `${millions.toFixed(0).toString()}M`;\n        } else {\n            const billions = count / 1e9;\n            return `${billions.toFixed(1).toString()}B`;\n        }\n    }\n\n    _updateNotificationsCount() {\n        const remoteCount = this._remoteEntry['count-visible']\n            ? this._remoteEntry.count ?? 0 : 0;\n\n        if (remoteCount > 0 &&\n            Docking.DockManager.settings.applicationCounterOverridesNotifications) {\n            this.setNotificationCount(remoteCount);\n            return;\n        }\n\n        const {notificationsMonitor} = Docking.DockManager.getDefault();\n        const notificationsCount = notificationsMonitor.getAppNotificationsCount(\n            this._source.app.id);\n\n        this.setNotificationCount(remoteCount + notificationsCount);\n    }\n\n    _updateNotificationsBadge(text) {\n        if (this._notificationBadgeBin) {\n            this._notificationBadgeBin.child.text = text;\n            return;\n        }\n\n        this._notificationBadgeBin = new St.Bin({\n            child: new St.Label({\n                styleClass: 'notification-badge',\n                text,\n            }),\n            xAlign: Clutter.ActorAlign.END,\n            yAlign: Clutter.ActorAlign.START,\n            xExpand: true,\n            yExpand: true,\n        });\n        this._notificationBadgeBin.child.clutterText.ellipsize =\n            Pango.EllipsizeMode.MIDDLE;\n\n        this._source._iconContainer.add_child(this._notificationBadgeBin);\n        this._updateNotificationBadgeStyle();\n\n        const themeContext = St.ThemeContext.get_for_stage(global.stage);\n        this._signalsHandler.addWithLabel(UnityIndicator.notificationBadgeSignals, [\n            themeContext,\n            'changed',\n            () => this._updateNotificationBadgeStyle(),\n        ], [\n            themeContext,\n            'notify::scale-factor',\n            () => this._updateNotificationBadgeStyle(),\n        ], [\n            this._source._iconContainer,\n            'notify::size',\n            () => this._updateNotificationBadgeStyle(),\n        ]);\n    }\n\n    setNotificationCount(count) {\n        if (count > 0) {\n            const text = this._notificationBadgeCountToText(count);\n            this._updateNotificationsBadge(text);\n        } else if (this._notificationBadgeBin) {\n            this._signalsHandler.removeWithLabel(UnityIndicator.notificationBadgeSignals);\n            this._notificationBadgeBin.destroy();\n            this._notificationBadgeBin = null;\n        }\n    }\n\n    _showProgressOverlay() {\n        if (this._progressOverlayArea) {\n            this._updateProgressOverlay();\n            return;\n        }\n\n        this._progressOverlayArea = new St.DrawingArea({x_expand: true, y_expand: true});\n        this._progressOverlayArea.add_style_class_name('progress-bar');\n        this._progressOverlayArea.connect('repaint', () => {\n            this._drawProgressOverlay(this._progressOverlayArea);\n        });\n\n        this._source._iconContainer.add_child(this._progressOverlayArea);\n        this._updateProgressOverlay();\n    }\n\n    _hideProgressOverlay() {\n        this._progressOverlayArea?.destroy();\n        this._progressOverlayArea = null;\n    }\n\n    _updateProgressOverlay() {\n        this._progressOverlayArea?.queue_repaint();\n    }\n\n    _readGradientData(node, elementName, defaultValues) {\n        const output = {\n            colorStart: defaultValues.colorStart,\n            colorEnd: defaultValues.colorEnd,\n            offsetStart: defaultValues.offsetStart ?? 0.0,\n            offsetEnd: defaultValues.offsetEnd ?? 1.0,\n        };\n\n        const [hasElementName, elementNameValue] = node.lookup_color(elementName, false);\n        if (hasElementName) {\n            output.colorStart = elementNameValue;\n            output.colorEnd = null;\n        } else {\n            const [hasColorStart, colorStartValue] = node.lookup_color(`${elementName}-color-start`, false);\n            const [hasColorEnd, colorEndValue] = node.lookup_color(`${elementName}-color-end`, false);\n            if (hasColorStart && hasColorEnd) {\n                output.colorStart = colorStartValue;\n                output.colorEnd = colorEndValue;\n            }\n        }\n\n        const [hasOffsetStart, offsetStartValue] = node.lookup_color(`${elementName}-offset-start`, false);\n        if (hasOffsetStart)\n            output.offsetStart = offsetStartValue;\n\n        const [hasOffsetEnd, offsetEndValue] = node.lookup_color(`${elementName}-offset-end`, false);\n        if (hasOffsetEnd)\n            output.offsetEnd = offsetEndValue;\n\n        return output;\n    }\n\n    _readThemeDoubleValue(node, elementName, defaultValue) {\n        const [hasValue, value] = node.lookup_double(elementName, false);\n        return hasValue ? value : defaultValue;\n    }\n\n    _readElementData(node, elementName, defaultValues) {\n        return {\n            background: this._readGradientData(node, `${elementName}-background`, defaultValues.background),\n            border: this._readGradientData(node, `${elementName}-border`, defaultValues.border),\n            lineWidth: this._readThemeDoubleValue(node, `${elementName}-line-width`,\n                defaultValues.lineWidth ?? 1.0),\n        };\n    }\n\n    _createGradient(values, x0, y0, x1, y1) {\n        if (values.colorEnd) {\n            const gradient = new Cairo.LinearGradient(x0, y0, x1, y1);\n            gradient.addColorStopRGBA(values.offsetStart,\n                values.colorStart.red / 255,\n                values.colorStart.green / 255,\n                values.colorStart.blue / 255,\n                values.colorStart.alpha / 255);\n            gradient.addColorStopRGBA(values.offsetEnd,\n                values.colorEnd.red / 255,\n                values.colorEnd.green / 255,\n                values.colorEnd.blue / 255,\n                values.colorEnd.alpha / 255);\n            return gradient;\n        } else {\n            const gradient = Cairo.SolidPattern.createRGBA(values.colorStart.red / 255,\n                values.colorStart.green / 255,\n                values.colorStart.blue / 255,\n                values.colorStart.alpha / 255);\n            return gradient;\n        }\n    }\n\n    _drawProgressOverlay(area) {\n        const {scaleFactor} = St.ThemeContext.get_for_stage(global.stage);\n        const [surfaceWidth, surfaceHeight] = area.get_surface_size();\n        const cr = area.get_context();\n        const node = this._progressOverlayArea.get_theme_node();\n        const iconSize = this._source.icon.iconSize * scaleFactor;\n\n        let x = Math.floor((surfaceWidth - iconSize) / 2);\n        let y = Math.floor((surfaceHeight - iconSize) / 2);\n\n        const readThemeValue = element =>\n            this._readThemeDoubleValue(node, `-progress-bar-${element}`);\n\n        y = readThemeValue('top-offset') ?? y;\n\n        const baseLineWidth = Math.floor(Number(scaleFactor));\n        const horizontalPadding = iconSize *\n            Utils.clampDouble(readThemeValue('horizontal-padding') ?? 0.05);\n        const verticalPadding = iconSize *\n            Utils.clampDouble(readThemeValue('vertical-padding') ?? 0.05);\n        const heightFactor =\n            Utils.clampDouble(readThemeValue('height-factor') ?? 0.20);\n\n        let width = iconSize - 2.0 * horizontalPadding;\n        let height = Math.floor(Math.min(18.0 * scaleFactor, heightFactor * iconSize));\n        x += horizontalPadding;\n\n        const valign = Utils.clampDouble(readThemeValue('valign') ?? 1);\n        y += (iconSize - height - verticalPadding) * valign;\n\n        const progressBarTrack = this._readElementData(node,\n            '-progress-bar-track',\n            UnityIndicator.defaultProgressBarTrack);\n\n        const progressBar = this._readElementData(node,\n            '-progress-bar',\n            UnityIndicator.defaultProgressBar);\n\n        // Draw the track\n        let lineWidth = baseLineWidth * progressBarTrack.lineWidth;\n        cr.setLineWidth(lineWidth);\n\n        x += lineWidth;\n        y += lineWidth;\n        width -= 2.0 * lineWidth;\n        height -= 2.0 * lineWidth;\n\n        let fill = this._createGradient(progressBarTrack.background, 0, y, 0, y + height);\n        let stroke = this._createGradient(progressBarTrack.border, 0, y, 0, y + height);\n        Utils.drawRoundedLine(cr, x + lineWidth / 2.0,\n            y + lineWidth / 2.0, width, height, true, true, stroke, fill);\n\n        // Draw the finished bar\n        lineWidth = baseLineWidth * progressBar.lineWidth;\n        cr.setLineWidth(lineWidth);\n\n        x += lineWidth;\n        y += lineWidth;\n        width -= 2.0 * lineWidth;\n        height -= 2.0 * lineWidth;\n\n        const finishedWidth = Math.ceil(this._progress * width);\n        fill = this._createGradient(progressBar.background, 0, y, 0, y + height);\n        stroke = this._createGradient(progressBar.border, 0, y, 0, y + height);\n\n        if (Clutter.get_default_text_direction() === Clutter.TextDirection.RTL) {\n            Utils.drawRoundedLine(cr,\n                x + lineWidth / 2.0 + width - finishedWidth, y + lineWidth / 2.0,\n                finishedWidth, height, true, true, stroke, fill);\n        } else {\n            Utils.drawRoundedLine(cr, x + lineWidth / 2.0, y + lineWidth / 2.0,\n                finishedWidth, height, true, true, stroke, fill);\n        }\n\n        cr.$dispose();\n    }\n\n    setProgress(progress) {\n        if (progress < 0) {\n            this._hideProgressOverlay();\n        } else {\n            this._progress = Math.min(progress, 1.0);\n            this._showProgressOverlay();\n        }\n    }\n\n    setUrgent(urgent) {\n        if (urgent || this._isUrgent !== undefined)\n            this._source.urgent = urgent;\n\n        if (urgent)\n            this._isUrgent = urgent;\n        else\n            delete this._isUrgent;\n    }\n\n    setUpdating(updating) {\n        this._source.updating = updating;\n    }\n\n    _updateIconStyle() {\n        const opacity = this._readThemeDoubleValue(this._source.get_theme_node(),\n            'opacity') ?? (this._source.updating ? 0.5 : 1);\n        this._source.icon.set_opacity(255 * opacity);\n    }\n}\n\n\n// Global icon cache. Used for Unity7 styling.\nconst iconCacheMap = new Map();\n// Max number of items to store\n// We don't expect to ever reach this number, but let's put an hard limit to avoid\n// even the remote possibility of the cached items to grow indefinitely.\nconst MAX_CACHED_ITEMS = 1000;\n// When the size exceed it, the oldest 'n' ones are deleted\nconst  BATCH_SIZE_TO_DELETE = 50;\n// The icon size used to extract the dominant color\nconst DOMINANT_COLOR_ICON_SIZE = 64;\n\n// Compute dominant color from the app icon.\n// The color is cached for efficiency.\nclass DominantColorExtractor {\n    constructor(app) {\n        this._app = app;\n    }\n\n    /**\n     * Try to get the pixel buffer for the current icon, if not fail gracefully\n     */\n    _getIconPixBuf() {\n        let iconTexture = this._app.create_icon_texture(16);\n        const themeLoader = Docking.DockManager.iconTheme;\n\n        // Unable to load the icon texture, use fallback\n        if (iconTexture instanceof St.Icon === false)\n            return null;\n\n\n        iconTexture = iconTexture.get_gicon();\n\n        // Unable to load the icon texture, use fallback\n        if (!iconTexture)\n            return null;\n\n        if (iconTexture instanceof Gio.FileIcon) {\n            // Use GdkPixBuf to load the pixel buffer from the provided file path\n            return GdkPixbuf.Pixbuf.new_from_file(iconTexture.get_file().get_path());\n        } else if (iconTexture instanceof Gio.ThemedIcon) {\n            // Get the first pixel buffer available in the icon theme\n            const iconNames = iconTexture.get_names();\n            const iconInfo = themeLoader.choose_icon(iconNames, DOMINANT_COLOR_ICON_SIZE, 0);\n\n            if (iconInfo)\n                return iconInfo.load_icon();\n            else\n                return null;\n        }\n\n        // Use GdkPixBuf to load the pixel buffer from memory\n        // iconTexture.load is available unless iconTexture is not an instance of Gio.LoadableIcon\n        // this means that iconTexture is an instance of Gio.EmblemedIcon,\n        // which may be converted to a normal icon via iconTexture.get_icon?\n        const [iconBuffer] = iconTexture.load(DOMINANT_COLOR_ICON_SIZE, null);\n        return GdkPixbuf.Pixbuf.new_from_stream(iconBuffer, null);\n    }\n\n    /**\n     * The backlight color choosing algorithm was mostly ported to javascript from the\n     * Unity7 C++ source of Canonicals:\n     * https://bazaar.launchpad.net/~unity-team/unity/trunk/view/head:/launcher/LauncherIcon.cpp\n     * so it more or less works the same way.\n     */\n    _getColorPalette() {\n        if (iconCacheMap.get(this._app.get_id())) {\n            // We already know the answer\n            return iconCacheMap.get(this._app.get_id());\n        }\n\n        const pixBuf = this._getIconPixBuf();\n        if (!pixBuf)\n            return null;\n\n        let pixels = pixBuf.get_pixels();\n\n        let total  = 0,\n            rTotal = 0,\n            gTotal = 0,\n            bTotal = 0;\n\n        let resampleX = 1;\n        let resampleY = 1;\n\n        // Resampling of large icons\n        // We resample icons larger than twice the desired size, as the resampling\n        // to a size s\n        // DOMINANT_COLOR_ICON_SIZE < s < 2*DOMINANT_COLOR_ICON_SIZE,\n        // most of the case exactly DOMINANT_COLOR_ICON_SIZE as the icon size is\n        // typically a multiple of it.\n        const width = pixBuf.get_width();\n        const height = pixBuf.get_height();\n\n        // Resample\n        if (height >= 2 * DOMINANT_COLOR_ICON_SIZE)\n            resampleY = Math.floor(height / DOMINANT_COLOR_ICON_SIZE);\n\n        if (width >= 2 * DOMINANT_COLOR_ICON_SIZE)\n            resampleX = Math.floor(width / DOMINANT_COLOR_ICON_SIZE);\n\n        if (resampleX !== 1 || resampleY !== 1)\n            pixels = this._resamplePixels(pixels, resampleX, resampleY);\n\n        // computing the limit outside the for (where it would be repeated at each iteration)\n        // for performance reasons\n        const limit = pixels.length;\n        for (let offset = 0; offset < limit; offset += 4) {\n            const r = pixels[offset],\n                g = pixels[offset + 1],\n                b = pixels[offset + 2],\n                a = pixels[offset + 3];\n\n            const saturation = Math.max(r, g, b) - Math.min(r, g, b);\n            const relevance  = 0.1 * 255 * 255 + 0.9 * a * saturation;\n\n            rTotal += r * relevance;\n            gTotal += g * relevance;\n            bTotal += b * relevance;\n\n            total += relevance;\n        }\n\n        total *= 255;\n\n        const r = rTotal / total,\n            g = gTotal / total,\n            b = bTotal / total;\n\n        const hsv = Utils.ColorUtils.RGBtoHSV(r * 255, g * 255, b * 255);\n\n        if (hsv.s > 0.15)\n            hsv.s = 0.65;\n        hsv.v = 0.90;\n\n        const rgb = Utils.ColorUtils.HSVtoRGB(hsv.h, hsv.s, hsv.v);\n\n        // Cache the result.\n        const backgroundColor = {\n            lighter:  Utils.ColorUtils.ColorLuminance(rgb.r, rgb.g, rgb.b, 0.2),\n            original: Utils.ColorUtils.ColorLuminance(rgb.r, rgb.g, rgb.b, 0),\n            darker:   Utils.ColorUtils.ColorLuminance(rgb.r, rgb.g, rgb.b, -0.5),\n        };\n\n        if (iconCacheMap.size >= MAX_CACHED_ITEMS) {\n            // delete oldest cached values (which are in order of insertions)\n            let ctr = 0;\n            for (const key of iconCacheMap.keys()) {\n                if (++ctr > BATCH_SIZE_TO_DELETE)\n                    break;\n                iconCacheMap.delete(key);\n            }\n        }\n\n        iconCacheMap.set(this._app.get_id(), backgroundColor);\n\n        return backgroundColor;\n    }\n\n    /**\n     * Downscale large icons before scanning for the backlight color to\n     * improve performance.\n     *\n     * @param pixBuf\n     * @param pixels\n     * @param resampleX\n     * @param resampleY\n     *\n     * @returns [];\n     */\n    _resamplePixels(pixels, resampleX, resampleY) {\n        const resampledPixels = [];\n        // computing the limit outside the for (where it would be repeated at each iteration)\n        // for performance reasons\n        const limit = pixels.length / (resampleX * resampleY) / 4;\n        for (let i = 0; i < limit; i++) {\n            const pixel = i * resampleX * resampleY;\n\n            resampledPixels.push(pixels[pixel * 4]);\n            resampledPixels.push(pixels[pixel * 4 + 1]);\n            resampledPixels.push(pixels[pixel * 4 + 2]);\n            resampledPixels.push(pixels[pixel * 4 + 3]);\n        }\n\n        return resampledPixels;\n    }\n}\n"
        },
        {
          "name": "appIcons.js",
          "type": "blob",
          "size": 57.728515625,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {\n    Clutter,\n    Gio,\n    GLib,\n    GObject,\n    Meta,\n    Mtk,\n    Shell,\n    St,\n} from './dependencies/gi.js';\n\nimport {\n    AppDisplay,\n    AppFavorites,\n    BoxPointer,\n    Dash,\n    Main,\n    PopupMenu,\n} from './dependencies/shell/ui.js';\n\nimport {\n    ParentalControlsManager,\n    Util,\n} from './dependencies/shell/misc.js';\n\nimport {\n    AppIconIndicators,\n    DBusMenuUtils,\n    Docking,\n    Locations,\n    Theming,\n    Utils,\n    WindowPreview,\n} from './imports.js';\n\nimport {Extension} from './dependencies/shell/extensions/extension.js';\n\n// Use __ () and N__() for the extension gettext domain, and reuse\n// the shell domain with the default _() and N_()\nconst {gettext: __, ngettext} = Extension;\n\nconst DBusMenu = await DBusMenuUtils.haveDBusMenu();\n\nconst tracker = Shell.WindowTracker.get_default();\n\nconst Labels = Object.freeze({\n    ISOLATE_MONITORS: Symbol('isolate-monitors'),\n    ISOLATE_WORKSPACES: Symbol('isolate-workspaces'),\n    URGENT_WINDOWS: Symbol('urgent-windows'),\n});\n\nconst clickAction = Object.freeze({\n    SKIP: 0,\n    MINIMIZE: 1,\n    LAUNCH: 2,\n    CYCLE_WINDOWS: 3,\n    MINIMIZE_OR_OVERVIEW: 4,\n    PREVIEWS: 5,\n    MINIMIZE_OR_PREVIEWS: 6,\n    FOCUS_OR_PREVIEWS: 7,\n    FOCUS_OR_APP_SPREAD: 8,\n    FOCUS_MINIMIZE_OR_PREVIEWS: 9,\n    FOCUS_MINIMIZE_OR_APP_SPREAD: 10,\n    QUIT: 11,\n});\n\nconst scrollAction = Object.freeze({\n    DO_NOTHING: 0,\n    CYCLE_WINDOWS: 1,\n    SWITCH_WORKSPACE: 2,\n});\n\nlet recentlyClickedAppLoopId = 0;\nlet recentlyClickedApp = null;\nlet recentlyClickedAppWindows = null;\nlet recentlyClickedAppIndex = 0;\nlet recentlyClickedAppMonitor = -1;\n\n/**\n * Extend AppIcon\n *\n * - Apply a css class based on the number of windows of each application (#N);\n * - Customized indicators for running applications in place of the default \"dot\" style which is hidden (#N);\n *   a class of the form \"running#N\" is applied to the AppWellIcon actor.\n *   like the original .running one.\n * - Add a .focused style to the focused app\n * - Customize click actions.\n * - Update minimization animation target\n * - Update menu if open on windows change\n */\nconst DockAbstractAppIcon = GObject.registerClass({\n    GTypeFlags: GObject.TypeFlags.ABSTRACT,\n    Properties: {\n        'focused': GObject.ParamSpec.boolean(\n            'focused', 'focused', 'focused',\n            GObject.ParamFlags.READWRITE,\n            false),\n        'running': GObject.ParamSpec.boolean(\n            'running', 'running', 'running',\n            GObject.ParamFlags.READWRITE,\n            false),\n        'urgent': GObject.ParamSpec.boolean(\n            'urgent', 'urgent', 'urgent',\n            GObject.ParamFlags.READWRITE,\n            false),\n        'updating': GObject.ParamSpec.boolean(\n            'updating', 'updating', 'updating',\n            GObject.ParamFlags.READWRITE,\n            false),\n        'windows-count': GObject.ParamSpec.uint(\n            'windows-count', 'windows-count', 'windows-count',\n            GObject.ParamFlags.READWRITE,\n            0, GLib.MAXUINT32, 0),\n    },\n}, class DockAbstractAppIcon extends Dash.DashIcon {\n    // settings are required inside.\n    _init(app, monitorIndex, iconAnimator) {\n        super._init(app);\n\n        // a prefix is required to avoid conflicting with the parent class variable\n        this.monitorIndex = monitorIndex;\n        this._signalsHandler = new Utils.GlobalSignalsHandler(this);\n        this.iconAnimator = iconAnimator;\n        this._indicator = new AppIconIndicators.AppIconIndicator(this);\n        this._urgentWindows = new Set();\n\n        // Monitor windows-changes instead of app state.\n        // Keep using the same Id and function callback (that is extended)\n        if (this._stateChangedId > 0) {\n            this.app.disconnect(this._stateChangedId);\n            this._stateChangedId = 0;\n        }\n\n        this._signalsHandler.add(this.app, 'windows-changed', () => this._updateWindows());\n        this._signalsHandler.add(this.app, 'notify::state', () => this._updateRunningState());\n        this._signalsHandler.add(global.display, 'window-demands-attention', (_dpy, window) =>\n            this._onWindowDemandsAttention(window));\n        this._signalsHandler.add(global.display, 'window-marked-urgent', (_dpy, window) =>\n            this._onWindowDemandsAttention(window));\n\n        // In Wayland sessions, this signal is needed to track the state of windows dragged\n        // from one monitor to another. As this is triggered quite often (whenever a new\n        // window of any application opened or moved to a different desktop),\n        // we restrict this signal to  the case when Labels.ISOLATE_MONITORS is true,\n        // and if there are at least 2 monitors.\n        if (Docking.DockManager.settings.isolateMonitors &&\n            Main.layoutManager.monitors.length > 1) {\n            this._signalsHandler.addWithLabel(Labels.ISOLATE_MONITORS,\n                global.display,\n                'window-entered-monitor',\n                this._onWindowEntered.bind(this));\n        }\n\n        this.connect('notify::running', () => {\n            if (this.running)\n                this.add_style_class_name('running');\n            else\n                this.remove_style_class_name('running');\n        });\n        this.notify('running');\n\n        this.connect('notify::focused', () => {\n            if (this.focused)\n                this.add_style_class_name('focused');\n            else\n                this.remove_style_class_name('focused');\n        });\n        this.notify('focused');\n\n        this.connect('notify::updating', () => {\n            if (this.updating)\n                this.add_style_class_name('updating');\n            else\n                this.remove_style_class_name('updating');\n        });\n        this.notify('updating');\n\n        const {notificationsMonitor} = Docking.DockManager.getDefault();\n\n        this.connect('notify::urgent', () => {\n            const icon = this.icon._iconBin;\n            this._signalsHandler.removeWithLabel(Labels.URGENT_WINDOWS);\n            if (this.urgent) {\n                if (Docking.DockManager.settings.danceUrgentApplications &&\n                    notificationsMonitor.enabled) {\n                    icon.set_pivot_point(0.5, 0.5);\n                    this.iconAnimator.addAnimation(icon, 'wiggle');\n                }\n                if (this.running && !this._urgentWindows.size) {\n                    const urgentWindows = this.getInterestingWindows();\n                    urgentWindows.forEach(w => (w._manualUrgency = true));\n                    this._updateUrgentWindows(urgentWindows);\n                }\n            } else {\n                this.iconAnimator.removeAnimation(icon, 'wiggle');\n                icon.rotation_angle_z = 0;\n                this._urgentWindows.forEach(w => delete w._manualUrgency);\n                this._updateUrgentWindows();\n            }\n        });\n        this.notify('urgent');\n\n        this._progressOverlayArea = null;\n        this._progress = 0;\n\n        [\n            'apply-custom-theme',\n            'running-indicator-style',\n            'show-icons-emblems',\n            'show-icons-notifications-counter',\n            'application-counter-overrides-notifications',\n        ].forEach(key => {\n            this._signalsHandler.add(\n                Docking.DockManager.settings,\n                `changed::${key}`, () => {\n                    this._indicator.destroy();\n                    this._indicator = new AppIconIndicators.AppIconIndicator(this);\n                }\n            );\n        });\n\n        this._signalsHandler.add(notificationsMonitor, 'state-changed', () => {\n            this._indicator.destroy();\n            this._indicator = new AppIconIndicators.AppIconIndicator(this);\n        });\n\n        this._updateState();\n        this._numberOverlay();\n\n        this._previewMenuManager = null;\n        this._previewMenu = null;\n    }\n\n    _onDestroy() {\n        super._onDestroy();\n\n        // This is necessary due to an upstream bug\n        // https://bugzilla.gnome.org/show_bug.cgi?id=757556\n        // It can be safely removed once it get solved upstream.\n        this._menu?.close(false);\n        delete this._menu;\n    }\n\n    ownsWindow(window) {\n        return this.app === tracker.get_window_app(window);\n    }\n\n    _onWindowEntered(metaScreen, monitorIndex, metaWin) {\n        if (this.ownsWindow(metaWin))\n            this._updateWindows();\n    }\n\n    vfunc_scroll_event(scrollEvent) {\n        const {settings} = Docking.DockManager;\n        const isEnabled = settings.scrollAction === scrollAction.CYCLE_WINDOWS;\n        if (!isEnabled)\n            return Clutter.EVENT_PROPAGATE;\n\n        // We only activate windows of running applications, i.e. we never open new windows\n        // We check if the app is running, and that the # of windows is > 0 in\n        // case we use workspace isolation,\n        if (!this.running)\n            return Clutter.EVENT_PROPAGATE;\n\n        if (this._optionalScrollCycleWindowsDeadTimeId) {\n            return Clutter.EVENT_PROPAGATE;\n        } else {\n            this._optionalScrollCycleWindowsDeadTimeId = GLib.timeout_add(\n                GLib.PRIORITY_DEFAULT, 250, () => {\n                    this._optionalScrollCycleWindowsDeadTimeId = 0;\n                });\n        }\n\n        let direction = null;\n\n        switch (scrollEvent.direction) {\n        case Clutter.ScrollDirection.UP:\n            direction = Meta.MotionDirection.UP;\n            break;\n        case Clutter.ScrollDirection.DOWN:\n            direction = Meta.MotionDirection.DOWN;\n            break;\n        case Clutter.ScrollDirection.SMOOTH: {\n            const [, dy] = Clutter.get_current_event().get_scroll_delta();\n            if (dy < 0)\n                direction = Meta.MotionDirection.UP;\n            else if (dy > 0)\n                direction = Meta.MotionDirection.DOWN;\n        }\n            break;\n        }\n\n        if (!Main.overview.visible) {\n            const reversed = direction === Meta.MotionDirection.UP;\n            if (this.focused && !this._urgentWindows.size) {\n                this._cycleThroughWindows(reversed);\n            } else {\n                // Activate the first window\n                const windows = this.getInterestingWindows();\n                if (windows.length > 0) {\n                    const [w] = windows;\n                    Main.activateWindow(w);\n                }\n            }\n        } else {\n            this.app.activate();\n        }\n        return Clutter.EVENT_STOP;\n    }\n\n    _updateWindows() {\n        if (this._menu && this._menu.isOpen)\n            this._menu.update();\n\n        this._updateState();\n        this.updateIconGeometry();\n    }\n\n    _updateState() {\n        this._urgentWindows.clear();\n        const interestingWindows = this.getInterestingWindows();\n        this.windowsCount = interestingWindows.length;\n        this._updateRunningState();\n        this._updateFocusState();\n        this._updateUrgentWindows(interestingWindows);\n\n        if (Docking.DockManager.settings.isolateWorkspaces) {\n            this._signalsHandler.removeWithLabel(Labels.ISOLATE_WORKSPACES);\n            interestingWindows.forEach(window =>\n                this._signalsHandler.addWithLabel(Labels.ISOLATE_WORKSPACES,\n                    window, 'workspace-changed', () => this._updateWindows()));\n        }\n    }\n\n    _updateRunningState() {\n        this.running = (this.app.state === Shell.AppState.RUNNING) && this.windowsCount;\n    }\n\n    _updateFocusState() {\n        this.focused = tracker.focus_app === this.app && this.running;\n    }\n\n    _updateUrgentWindows(interestingWindows) {\n        this._signalsHandler.removeWithLabel(Labels.URGENT_WINDOWS);\n        this._urgentWindows.clear();\n        if (interestingWindows === undefined)\n            interestingWindows = this.getInterestingWindows();\n        interestingWindows.filter(isWindowUrgent).forEach(win => this._addUrgentWindow(win));\n        this.urgent = !!this._urgentWindows.size;\n    }\n\n    _onWindowDemandsAttention(window) {\n        if (this.ownsWindow(window) && isWindowUrgent(window))\n            this._addUrgentWindow(window);\n    }\n\n    _updateDotStyle() {\n        super._updateDotStyle();\n        const themeNode = this._dot.get_theme_node();\n        this._dot.translationX = themeNode.get_length('offset-x');\n    }\n\n    _addUrgentWindow(window) {\n        if (this._urgentWindows.has(window))\n            return;\n\n        if (window._manualUrgency && window.has_focus()) {\n            delete window._manualUrgency;\n            return;\n        }\n\n        this._urgentWindows.add(window);\n        this.urgent = true;\n\n        const onDemandsAttentionChanged = () => {\n            if (!isWindowUrgent(window))\n                this._updateUrgentWindows();\n        };\n\n        if (window.demandsAttention) {\n            this._signalsHandler.addWithLabel(Labels.URGENT_WINDOWS, window,\n                'notify::demands-attention', () => onDemandsAttentionChanged());\n        }\n        if (window.urgent) {\n            this._signalsHandler.addWithLabel(Labels.URGENT_WINDOWS, window,\n                'notify::urgent', () => onDemandsAttentionChanged());\n        }\n        if (window._manualUrgency) {\n            this._signalsHandler.addWithLabel(Labels.URGENT_WINDOWS, window,\n                'focus', () => {\n                    delete window._manualUrgency;\n                    onDemandsAttentionChanged();\n                });\n        }\n    }\n\n    /**\n     * Update target for minimization animation\n     */\n    updateIconGeometry() {\n        // If (for unknown reason) the actor is not on the stage the reported size\n        // and position are random values, which might exceeds the integer range\n        // resulting in an error when assigned to the a rect. This is a more like\n        // a workaround to prevent flooding the system with errors.\n        if (!this.get_stage())\n            return;\n\n        const rect = new Mtk.Rectangle();\n\n        [rect.x, rect.y] = this.get_transformed_position();\n        [rect.width, rect.height] = this.get_transformed_size();\n\n        let windows = this.getWindows();\n        if (Docking.DockManager.settings.multiMonitor) {\n            const {monitorIndex} = this;\n            windows = windows.filter(w => w.get_monitor() === monitorIndex);\n        }\n        windows.forEach(w => w.set_icon_geometry(rect));\n    }\n\n    _updateRunningStyle() {\n        // The logic originally in this function has been moved to\n        // AppIconIndicatorBase._updateDefaultDot(). However it cannot be removed as\n        // it called by the parent constructor.\n    }\n\n    popupMenu() {\n        this._removeMenuTimeout();\n        this.fake_release();\n        this._draggable.fakeRelease();\n\n        if (!this._menu) {\n            this._menu = new DockAppIconMenu(this);\n            this._menu.connect('activate-window', (menu, window) => {\n                if (window) {\n                    Main.activateWindow(window);\n                } else {\n                    Main.overview.hide();\n                    Main.panel.closeCalendar();\n                }\n            });\n            this._menu.connect('open-state-changed', (menu, isPoppedUp) => {\n                if (!isPoppedUp) {\n                    this._onMenuPoppedDown();\n                } else {\n                    // Setting the max-height is s useful if part of the menu is\n                    // scrollable so the minimum height is smaller than the natural height.\n                    const monitorIndex = Main.layoutManager.findIndexForActor(this);\n                    const workArea = Main.layoutManager.getWorkAreaForMonitor(monitorIndex);\n                    const position = Utils.getPosition();\n                    const {scaleFactor} = St.ThemeContext.get_for_stage(global.stage);\n                    const isHorizontal = position === St.Side.TOP || position === St.Side.BOTTOM;\n                    // If horizontal also remove the height of the dash\n                    const {dockFixed: fixedDock} = Docking.DockManager.settings;\n                    const additionalMargin = isHorizontal && !fixedDock ? Main.overview.dash.height : 0;\n                    const verticalMargins = this._menu.actor.margin_top + this._menu.actor.margin_bottom;\n                    const maxMenuHeight = workArea.height - additionalMargin - verticalMargins;\n                    // Also set a max width to the menu, so long labels (long windows title) get truncated\n                    this._menu.actor.style = 'max-width: 400px; ' +\n                        `max-height: ${Math.round(maxMenuHeight / scaleFactor)}px;`;\n                }\n            });\n            const id = Main.overview.connect('hiding', () => {\n                this._menu.close();\n            });\n            this._menu.actor.connect('destroy', () => {\n                Main.overview.disconnect(id);\n            });\n\n            this._menuManager.addMenu(this._menu);\n        }\n\n        this.emit('menu-state-changed', true);\n\n        this.set_hover(true);\n        this._menu.popup();\n        this._menuManager.ignoreRelease();\n        this.emit('sync-tooltip');\n\n        return false;\n    }\n\n    activate(button) {\n        const event = Clutter.get_current_event();\n        let modifiers = event ? event.get_state() : 0;\n\n        // Only consider SHIFT and CONTROL as modifiers (exclude SUPER, CAPS-LOCK, etc.)\n        modifiers &= Clutter.ModifierType.SHIFT_MASK | Clutter.ModifierType.CONTROL_MASK;\n\n        // We don't change the CTRL-click behavior: in such case we just chain\n        // up the parent method and return.\n        if (modifiers & Clutter.ModifierType.CONTROL_MASK) {\n            // Keep default behavior: launch new window\n            // By calling the parent method I make it compatible\n            // with other extensions tweaking ctrl + click\n            super.activate(button);\n            return;\n        }\n\n        // We check what type of click we have and if the modifier SHIFT is\n        // being used. We then define what buttonAction should be for this\n        // event.\n        let buttonAction = 0;\n        const {settings} = Docking.DockManager;\n        if (button && button === 2) {\n            if (modifiers & Clutter.ModifierType.SHIFT_MASK)\n                buttonAction = settings.shiftMiddleClickAction;\n            else\n                buttonAction = settings.middleClickAction;\n        } else if (button && button === 1) {\n            if (modifiers & Clutter.ModifierType.SHIFT_MASK)\n                buttonAction = settings.shiftClickAction;\n            else\n                buttonAction = settings.clickAction;\n        }\n\n        switch (buttonAction) {\n        case clickAction.FOCUS_OR_APP_SPREAD:\n            if (!Docking.DockManager.getDefault().appSpread.supported)\n                buttonAction = clickAction.FOCUS_OR_PREVIEWS;\n            break;\n\n        case clickAction.FOCUS_MINIMIZE_OR_APP_SPREAD:\n            if (!Docking.DockManager.getDefault().appSpread.supported)\n                buttonAction = clickAction.FOCUS_MINIMIZE_OR_PREVIEWS;\n            break;\n        }\n\n        // We check if the app is running, and that the # of windows is > 0 in\n        // case we use workspace isolation.\n        const windows = this.getInterestingWindows();\n\n        // Some action modes (e.g. MINIMIZE_OR_OVERVIEW) require overview to remain open\n        // This variable keeps track of this\n        let shouldHideOverview = true;\n\n        // We customize the action only when the application is already running\n        if (this.running) {\n            const hasUrgentWindows = !!this._urgentWindows.size;\n            const singleOrUrgentWindows = windows.length === 1 || hasUrgentWindows;\n            switch (buttonAction) {\n            case clickAction.MINIMIZE:\n                // In overview just activate the app, unless the action is explicitly\n                // requested with a keyboard modifier\n                if (!Main.overview.visible || modifiers) {\n                    // If we have button=2 or a modifier, allow minimization even if\n                    // the app is not focused\n                    if (this.focused && !hasUrgentWindows || button === 2 ||\n                        modifiers & Clutter.ModifierType.SHIFT_MASK) {\n                        // minimize all windows on double click and always in\n                        // the case of primary click without additional modifiers\n                        let clickCount = 0;\n                        if (Clutter.EventType.CLUTTER_BUTTON_PRESS)\n                            clickCount = event.get_click_count();\n                        const allWindows = (button === 1 && !modifiers) || clickCount > 1;\n                        this._minimizeWindow(allWindows);\n                    } else {\n                        this._activateAllWindows();\n                    }\n                } else {\n                    const [w] = windows;\n                    Main.activateWindow(w);\n                }\n                break;\n\n            case clickAction.MINIMIZE_OR_OVERVIEW:\n                // When a single window is present, toggle minimization\n                // If only one windows is present toggle minimization, but\n                // only when triggered with the simple click action\n                // (no modifiers, no middle click).\n                if (singleOrUrgentWindows && !modifiers && button === 1) {\n                    const [w] = windows;\n                    if (this.focused) {\n                        if (buttonAction !== clickAction.FOCUS_OR_APP_SPREAD) {\n                            // Window is raised, minimize it\n                            this._minimizeWindow(w);\n                        }\n                    } else {\n                        // Window is minimized, raise it\n                        Main.activateWindow(w);\n                    }\n                    // Launch overview when multiple windows are present\n                    // TODO: only show current app windows when gnome shell API will allow it\n                } else {\n                    shouldHideOverview = false;\n                    Main.overview.toggle();\n                }\n                break;\n\n            case clickAction.CYCLE_WINDOWS:\n                if (!Main.overview.visible) {\n                    if (this.focused && !hasUrgentWindows) {\n                        this._cycleThroughWindows();\n                    } else {\n                        // Activate the first window\n                        const [w] = windows;\n                        Main.activateWindow(w);\n                    }\n                } else {\n                    this.app.activate();\n                }\n                break;\n\n            case clickAction.FOCUS_OR_PREVIEWS:\n                if (this.focused && !hasUrgentWindows &&\n                    (windows.length > 1 || modifiers || button !== 1)) {\n                    this._windowPreviews();\n                } else {\n                    // Activate the first window\n                    const [w] = windows;\n                    Main.activateWindow(w);\n                }\n                break;\n\n            case clickAction.FOCUS_MINIMIZE_OR_PREVIEWS:\n                if (this.focused && !hasUrgentWindows) {\n                    if (windows.length > 1 || modifiers || button !== 1)\n                        this._windowPreviews();\n                    else if (!Main.overview.visible)\n                        this._minimizeWindow();\n                } else {\n                    // Activate the first window\n                    const [w] = windows;\n                    Main.activateWindow(w);\n                }\n                break;\n\n            case clickAction.LAUNCH:\n                this.launchNewWindow();\n                break;\n\n            case clickAction.PREVIEWS:\n                if (!Main.overview.visible) {\n                    // If only one windows is present just switch to it,\n                    // but only when triggered with the simple click action\n                    // (no modifiers, no middle click).\n                    if (singleOrUrgentWindows && !modifiers && button === 1) {\n                        const [w] = windows;\n                        Main.activateWindow(w);\n                    } else {\n                        this._windowPreviews();\n                    }\n                } else {\n                    this.app.activate();\n                }\n                break;\n\n            case clickAction.MINIMIZE_OR_PREVIEWS:\n                // When a single window is present, toggle minimization\n                // If only one windows is present toggle minimization, but only\n                // when triggered with the standard click action (no modifiers,\n                // no middle click).\n                if (!Main.overview.visible) {\n                    if (singleOrUrgentWindows && !modifiers && button === 1) {\n                        const [w] = windows;\n                        if (this.focused) {\n                            // Window is raised, minimize it\n                            this._minimizeWindow(w);\n                        } else {\n                            // Window is minimized, raise it\n                            Main.activateWindow(w);\n                        }\n                    } else {\n                        // Launch previews when multiple windows are present\n                        this._windowPreviews();\n                    }\n                } else {\n                    this.app.activate();\n                }\n                break;\n\n            case clickAction.FOCUS_OR_APP_SPREAD:\n                if (this.focused && !singleOrUrgentWindows && !modifiers && button === 1) {\n                    shouldHideOverview = false;\n                    Docking.DockManager.getDefault().appSpread.toggle(this.app);\n                } else {\n                    // Activate the first window\n                    Main.activateWindow(windows[0]);\n                }\n                break;\n\n            case clickAction.FOCUS_MINIMIZE_OR_APP_SPREAD:\n                if (this.focused && !singleOrUrgentWindows && !modifiers && button === 1) {\n                    shouldHideOverview = false;\n                    Docking.DockManager.getDefault().appSpread.toggle(this.app);\n                } else if (!this.focused) {\n                    // Activate the first window\n                    Main.activateWindow(windows[0]);\n                } else {\n                    this._minimizeWindow();\n                }\n                break;\n\n            case clickAction.QUIT:\n                this.closeAllWindows();\n                break;\n\n            case clickAction.SKIP:\n                Main.activateWindow(windows[0]);\n                break;\n            }\n        } else {\n            this.launchNewWindow();\n        }\n\n        // Hide overview except when action mode requires it\n        if (shouldHideOverview)\n            Main.overview.hide();\n    }\n\n    shouldShowTooltip() {\n        return super.shouldShowTooltip() && !this._previewMenu?.isOpen &&\n            !Docking.DockManager.settings.hideTooltip;\n    }\n\n    _windowPreviews() {\n        if (!this._previewMenu) {\n            this._previewMenuManager = new PopupMenu.PopupMenuManager(this);\n\n            this._previewMenu = new WindowPreview.WindowPreviewMenu(this);\n\n            this._previewMenuManager.addMenu(this._previewMenu);\n\n            this._previewMenu.connect('open-state-changed', (menu, isPoppedUp) => {\n                if (!isPoppedUp)\n                    this._onMenuPoppedDown();\n            });\n            const id = Main.overview.connect('hiding', () => {\n                this._previewMenu.close();\n            });\n            this._previewMenu.actor.connect('destroy', () => {\n                Main.overview.disconnect(id);\n            });\n        }\n\n        this.emit('menu-state-changed', !this._previewMenu.isOpen);\n\n        if (this._previewMenu.isOpen)\n            this._previewMenu.close();\n        else\n            this._previewMenu.popup();\n\n        return false;\n    }\n\n    // Try to do the right thing when attempting to launch a new window of an app. In\n    // particular, if the application doesn't allow to launch a new window, activate\n    // the existing window instead.\n    launchNewWindow() {\n        if (this.updating) {\n            const icon = Gio.Icon.new_for_string('action-unavailable-symbolic');\n            Main.osdWindowManager.show(-1, icon,\n                _('%s is updating, try again later').format(this.name),\n                null);\n            return;\n        }\n\n        if (this.app.state === Shell.AppState.RUNNING &&\n            this.app.can_open_new_window()) {\n            this.animateLaunch();\n            this.app.open_new_window(-1);\n        } else {\n            // Try to manually activate the first window. Otherwise, when the\n            // app is activated by switching to a different workspace, a launch\n            // spinning icon is shown and disappears only after a timeout.\n            const windows = this.getWindows();\n            if (windows.length > 0) {\n                Main.activateWindow(windows[0]);\n            } else {\n                this.app.activate();\n                this.animateLaunch();\n            }\n        }\n    }\n\n    _numberOverlay() {\n        // Add label for a Hot-Key visual aid\n        this._numberOverlayLabel = new St.Label();\n        this._numberOverlayBin = new St.Bin({\n            child: this._numberOverlayLabel,\n            x_align: Clutter.ActorAlign.START,\n            y_align: Clutter.ActorAlign.START,\n            x_expand: true, y_expand: true,\n        });\n        this._numberOverlayLabel.add_style_class_name('number-overlay');\n        this._numberOverlayOrder = -1;\n        this._numberOverlayBin.hide();\n\n        this._iconContainer.add_child(this._numberOverlayBin);\n    }\n\n    updateNumberOverlay() {\n        // We apply an overall scale factor that might come from a HiDPI monitor.\n        // Clutter dimensions are in physical pixels, but CSS measures are in logical\n        // pixels, so make sure to consider the scale.\n        const scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;\n        // Set the font size to something smaller than the whole icon so it is\n        // still visible. The border radius is large to make the shape circular\n        const [minWidth_, natWidth] = this._iconContainer.get_preferred_width(-1);\n        const fontSize = Math.round(Math.max(12, 0.3 * natWidth) / scaleFactor);\n        const size = Math.round(fontSize * 1.2);\n        this._numberOverlayLabel.set_style(\n            `font-size: ${fontSize}px;` +\n           `border-radius: ${this.icon.iconSize}px;` +\n           `width: ${size}px; height: ${size}px;`\n        );\n    }\n\n    setNumberOverlay(number) {\n        this._numberOverlayOrder = number;\n        this._numberOverlayLabel.set_text(number.toString());\n    }\n\n    toggleNumberOverlay(activate) {\n        if (activate && this._numberOverlayOrder > -1) {\n            this.updateNumberOverlay();\n            this._numberOverlayBin.show();\n        } else {\n            this._numberOverlayBin.hide();\n        }\n    }\n\n    _minimizeWindow(param) {\n        // Param true make all app windows minimize\n        const windows = this.getInterestingWindows();\n        const currentWorkspace = global.workspace_manager.get_active_workspace();\n        for (let i = 0; i < windows.length; i++) {\n            const w = windows[i];\n            if (w.get_workspace() === currentWorkspace && w.showing_on_its_workspace()) {\n                w.minimize();\n                // Just minimize one window. By specification it should be the\n                // focused window on the current workspace.\n                if (!param)\n                    break;\n            }\n        }\n    }\n\n    // By default only non minimized windows are activated.\n    // This activates all windows in the current workspace.\n    _activateAllWindows() {\n        // First activate first window so workspace is switched if needed.\n        // We don't do this if isolation is on!\n        if (!Docking.DockManager.settings.isolateWorkspaces &&\n            !Docking.DockManager.settings.isolateMonitors) {\n            if (!this.running)\n                this.animateLaunch();\n            this.app.activate();\n        }\n\n        // then activate all other app windows in the current workspace\n        const windows = this.getInterestingWindows();\n        const activeWorkspace = global.workspace_manager.get_active_workspace_index();\n\n        if (windows.length <= 0)\n            return;\n\n        for (let i = windows.length - 1; i >= 0; i--) {\n            if (windows[i].get_workspace()?.index() === activeWorkspace)\n                Main.activateWindow(windows[i]);\n        }\n    }\n\n    // This closes all windows of the app.\n    closeAllWindows() {\n        const windows = this.getInterestingWindows();\n        const time = global.get_current_time();\n        windows.forEach(w => w.delete(time));\n    }\n\n    _cycleThroughWindows(reversed) {\n        // Store for a little amount of time last clicked app and its windows\n        // since the order changes upon window interaction\n        const MEMORY_TIME = 3000;\n\n        const appWindows = this.getInterestingWindows();\n\n        if (appWindows.length < 1)\n            return;\n\n        if (recentlyClickedAppLoopId > 0)\n            GLib.source_remove(recentlyClickedAppLoopId);\n        recentlyClickedAppLoopId = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT, MEMORY_TIME, this._resetRecentlyClickedApp);\n\n        // If there isn't already a list of windows for the current app,\n        // or the stored list is outdated, use the current windows list.\n        const monitorIsolation = Docking.DockManager.settings.isolateMonitors;\n        if (!recentlyClickedApp ||\n            recentlyClickedApp.get_id() !== this.app.get_id() ||\n            recentlyClickedAppWindows.length !== appWindows.length ||\n            (recentlyClickedAppMonitor !== this.monitorIndex && monitorIsolation)) {\n            recentlyClickedApp = this.app;\n            recentlyClickedAppWindows = appWindows;\n            recentlyClickedAppMonitor = this.monitorIndex;\n            recentlyClickedAppIndex = 0;\n        }\n\n        if (reversed) {\n            recentlyClickedAppIndex--;\n            if (recentlyClickedAppIndex < 0)\n                recentlyClickedAppIndex = recentlyClickedAppWindows.length - 1;\n        } else {\n            recentlyClickedAppIndex++;\n        }\n        const index = recentlyClickedAppIndex % recentlyClickedAppWindows.length;\n        const window = recentlyClickedAppWindows[index];\n\n        Main.activateWindow(window);\n    }\n\n    _resetRecentlyClickedApp() {\n        if (recentlyClickedAppLoopId > 0)\n            GLib.source_remove(recentlyClickedAppLoopId);\n        recentlyClickedAppLoopId = 0;\n        recentlyClickedApp = null;\n        recentlyClickedAppWindows = null;\n        recentlyClickedAppIndex = 0;\n        recentlyClickedAppMonitor = -1;\n\n        return false;\n    }\n\n    getWindows() {\n        return this.app.get_windows();\n    }\n\n    // Filter out unnecessary windows, for instance\n    // nautilus desktop window.\n    getInterestingWindows() {\n        const interestingWindows = getInterestingWindows(this.getWindows(),\n            this.monitorIndex);\n\n        if (!this._urgentWindows.size)\n            return interestingWindows;\n\n        return [...new Set([...this._urgentWindows, ...interestingWindows])];\n    }\n\n    getSnapName() {\n        return this.app.appInfo?.get_string('X-SnapInstanceName');\n    }\n});\n\nconst DockAppIcon = GObject.registerClass({\n}, class DockAppIcon extends DockAbstractAppIcon {\n    _init(app, monitorIndex, iconAnimator) {\n        super._init(app, monitorIndex, iconAnimator);\n\n        this._signalsHandler.add(tracker, 'notify::focus-app', () => this._updateFocusState());\n    }\n});\n\nconst DockLocationAppIcon = GObject.registerClass({\n}, class DockLocationAppIcon extends DockAbstractAppIcon {\n    _init(app, monitorIndex, iconAnimator) {\n        if (!(app.appInfo instanceof Locations.LocationAppInfo))\n            throw new Error('Provided application %s is not a Location'.format(app));\n\n        super._init(app, monitorIndex, iconAnimator);\n\n        if (Docking.DockManager.settings.isolateLocations) {\n            this._signalsHandler.add(tracker, 'notify::focus-app', () => this._updateFocusState());\n        } else {\n            this._signalsHandler.add(global.display, 'notify::focus-window',\n                () => this._updateFocusState());\n        }\n\n        this._signalsHandler.add(this.app, 'notify::icon', () => this.icon.update());\n    }\n\n    get location() {\n        return this.app.location;\n    }\n\n    _updateFocusState() {\n        if (Docking.DockManager.settings.isolateLocations) {\n            super._updateFocusState();\n            return;\n        }\n\n        this.focused = this.app.isFocused && this.running;\n    }\n});\n\n/**\n * @param app\n * @param monitorIndex\n * @param iconAnimator\n */\nexport function makeAppIcon(app, monitorIndex, iconAnimator) {\n    if (app.appInfo instanceof Locations.LocationAppInfo)\n        return new DockLocationAppIcon(app, monitorIndex, iconAnimator);\n\n    return new DockAppIcon(app, monitorIndex, iconAnimator);\n}\n\n/**\n * DockAppIconMenu\n *\n * - set popup arrow side based on dash orientation\n * - Add close windows option based on quitfromdash extension\n *   (https://github.com/deuill/shell-extension-quitfromdash)\n * - Add open windows thumbnails instead of list\n * - update menu when application windows change\n */\nconst DockAppIconMenu = class DockAppIconMenu extends PopupMenu.PopupMenu {\n    constructor(source) {\n        super(source, 0.5, Utils.getPosition());\n\n        this._signalsHandler = new Utils.GlobalSignalsHandler(this);\n\n        // We want to keep the item hovered while the menu is up\n        this.blockSourceEvents = true;\n\n        this.actor.add_style_class_name('app-menu');\n        this.actor.add_style_class_name('dock-app-menu');\n\n        // Chain our visibility and lifecycle to that of the source\n        this._signalsHandler.add(source, 'notify::mapped', () => {\n            if (!source.mapped)\n                this.close();\n        });\n        source.connect('destroy', () => this.destroy());\n\n        Main.uiGroup.add_child(this.actor);\n\n        const {remoteModel} = Docking.DockManager.getDefault();\n        const remoteModelApp = remoteModel?.lookupById(this.sourceActor?.app?.id);\n        if (remoteModelApp && DBusMenu) {\n            const [onQuickList, onDynamicSection] = Utils.splitHandler((sender,\n                {quicklist}, dynamicSection) => {\n                dynamicSection.removeAll();\n                if (quicklist) {\n                    quicklist.get_children().forEach(remoteItem =>\n                        dynamicSection.addMenuItem(\n                            DBusMenuUtils.makePopupMenuItem(remoteItem, false)));\n                }\n            });\n\n            this._signalsHandler.add([\n                remoteModelApp,\n                'quicklist-changed',\n                onQuickList,\n            ], [\n                this,\n                'dynamic-section-changed',\n                onDynamicSection,\n            ]);\n        }\n    }\n\n    destroy() {\n        super.destroy();\n        delete this.sourceActor;\n        delete this._signalsHandler;\n    }\n\n    _appendSeparator() {\n        this.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());\n    }\n\n    _appendMenuItem(labelText, params) {\n        const item = new PopupMenu.PopupMenuItem(labelText, params);\n        this.addMenuItem(item);\n        return item;\n    }\n\n    popup(_activatingButton) {\n        this._rebuildMenu();\n        this.open(BoxPointer.PopupAnimation.FULL);\n    }\n\n    removeAll() {\n        super.removeAll();\n\n        delete this._allWindowsMenuItem;\n        delete this._quitMenuItem;\n    }\n\n    _rebuildMenu() {\n        this.removeAll();\n\n        const appItemLabel = this.sourceActor.updating\n            ? _('%s is being updated').format(this.sourceActor.name)\n            : this.sourceActor.name;\n        this.addMenuItem(new PopupMenu.PopupSeparatorMenuItem(appItemLabel));\n\n        const {app} = this.sourceActor;\n\n        if (Docking.DockManager.settings.showWindowsPreview) {\n            // Display the app windows menu items and the separator between windows\n            // of the current desktop and other windows.\n            const windows = this.sourceActor.getInterestingWindows();\n\n            this._allWindowsMenuItem = new PopupMenu.PopupSubMenuMenuItem(__('All Windows'), false);\n            if (this._allWindowsMenuItem.menu?.actor)\n                this._allWindowsMenuItem.menu.actor.overlayScrollbars = true;\n            this._allWindowsMenuItem.hide();\n            if (windows.length > 0)\n                this.addMenuItem(this._allWindowsMenuItem);\n        } else {\n            const windows = this.sourceActor.getInterestingWindows();\n\n            if (windows.length > 0) {\n                this.addMenuItem(\n                    /* Translators: This is the heading of a list of open windows */\n                    new PopupMenu.PopupSeparatorMenuItem(_('Open Windows')));\n            }\n\n            windows.forEach(window => {\n                const title = window.title ? window.title : app.get_name();\n                const item = this._appendMenuItem(title);\n                item.connect('activate', () => {\n                    this.emit('activate-window', window);\n                });\n            });\n        }\n\n        if (!app.is_window_backed()) {\n            this._appendSeparator();\n\n            const appInfo = app.get_app_info();\n            const actions = this.sourceActor.updating ? [] : appInfo.list_actions();\n            if (!this.sourceActor.updating &&\n                app.can_open_new_window() &&\n                actions.indexOf('new-window') === -1) {\n                const newMenuItem = this._appendMenuItem(_('New Window'));\n                newMenuItem.connect('activate', () => {\n                    if (app.state === Shell.AppState.STOPPED)\n                        this.sourceActor.animateLaunch();\n\n                    app.open_new_window(-1);\n                    this.emit('activate-window', null);\n                });\n                this._appendSeparator();\n            }\n\n            if (!this.sourceActor.updating &&\n                Docking.DockManager.getDefault().discreteGpuAvailable &&\n                app.state === Shell.AppState.STOPPED) {\n                const appPrefersNonDefaultGPU = appInfo.get_boolean('PrefersNonDefaultGPU');\n                const gpuPref = appPrefersNonDefaultGPU\n                    ? Shell.AppLaunchGpu.DEFAULT\n                    : Shell.AppLaunchGpu.DISCRETE;\n                const gpuMenuItem = this._appendMenuItem(appPrefersNonDefaultGPU\n                    ? _('Launch using Integrated Graphics Card')\n                    : _('Launch using Discrete Graphics Card'));\n                gpuMenuItem.connect('activate', () => {\n                    this.sourceActor.animateLaunch();\n                    app.launch(0, -1, gpuPref);\n                    this.emit('activate-window', null);\n                });\n            }\n\n            for (let i = 0; i < actions.length; i++) {\n                const action = actions[i];\n                const item = this._appendMenuItem(appInfo.get_action_name(action));\n                item.sensitive = !appInfo.busy;\n                item.connect('activate', (emitter, event) => {\n                    app.launch_action(action, event.get_time(), -1);\n                    this.emit('activate-window', null);\n                });\n            }\n\n            const canFavorite = global.settings.is_writable('favorite-apps') &&\n                (this.sourceActor instanceof DockAppIcon) &&\n                ParentalControlsManager.getDefault().shouldShowApp(app.appInfo);\n\n            if (canFavorite) {\n                this._appendSeparator();\n\n                const isFavorite = AppFavorites.getAppFavorites().isFavorite(app.get_id());\n                if (isFavorite) {\n                    const item = this._appendMenuItem(_('Unpin'));\n                    item.connect('activate', () => {\n                        const favs = AppFavorites.getAppFavorites();\n                        favs.removeFavorite(app.get_id());\n                    });\n                } else {\n                    const item = this._appendMenuItem(__('Pin to Dock'));\n                    item.connect('activate', () => {\n                        const favs = AppFavorites.getAppFavorites();\n                        favs.addFavorite(app.get_id());\n                    });\n                }\n            }\n\n            if (Shell.AppSystem.get_default().lookup_app('org.gnome.Software.desktop') &&\n                this.sourceActor instanceof DockAppIcon &&\n                !this.sourceActor.getSnapName()) {\n                this._appendSeparator();\n                const item = this._appendMenuItem(_('App Details'));\n                item.connect('activate', () => {\n                    const id = app.get_id();\n                    const args = GLib.Variant.new('(ss)', [id, '']);\n                    Gio.DBus.get(Gio.BusType.SESSION, null,\n                        (o, res) => {\n                            const bus = Gio.DBus.get_finish(res);\n                            bus.call('org.gnome.Software',\n                                '/org/gnome/Software',\n                                'org.gtk.Actions', 'Activate',\n                                GLib.Variant.new('(sava{sv})',\n                                    ['details', [args], null]),\n                                null, 0, -1, null, null);\n                            Main.overview.hide();\n                        });\n                });\n            }\n\n            if (this.sourceActor instanceof DockAppIcon) {\n                const snapName = this.sourceActor.getSnapName();\n                const snapStore = snapName\n                    ? Shell.AppSystem.get_default().lookup_app(\n                        'snap-store_snap-store.desktop') : null;\n\n                if (snapStore) {\n                    this._appendSeparator();\n                    const item = this._appendMenuItem(_('App Details'));\n                    item.connect('activate', (_, event) => {\n                        snapStore.activate_full(-1, event.get_time());\n                        Util.spawnApp(\n                            [...snapStore.appInfo.get_commandline().split(' '), snapName]);\n                        Main.overview.hide();\n                    });\n                }\n            }\n        }\n\n        // dynamic menu\n        const items = this._getMenuItems();\n        let i = items.length;\n        if (Shell.AppSystem.get_default().lookup_app('org.gnome.Software.desktop'))\n            i -= 2;\n\n        if (global.settings.is_writable('favorite-apps'))\n            i -= 2;\n\n        if (i < 0)\n            i = 0;\n\n        const dynamicSection = new PopupMenu.PopupMenuSection();\n        this.addMenuItem(dynamicSection, i);\n        this.emit('dynamic-section-changed', dynamicSection);\n\n        // quit menu\n        this._appendSeparator();\n        this._quitMenuItem = this._appendMenuItem(_('Quit'));\n        this._quitMenuItem.connect('activate', () => this.sourceActor.closeAllWindows());\n\n        this.update();\n    }\n\n    // update menu content when application windows change. This is desirable as actions\n    // acting on windows (closing) are performed while the menu is shown.\n    update() {\n        // update, show or hide the quit menu\n        if (this.sourceActor.windowsCount > 0) {\n            if (this.sourceActor.windowsCount === 1) {\n                this._quitMenuItem.label.set_text(_('Quit'));\n            } else {\n                this._quitMenuItem.label.set_text(ngettext(\n                    'Quit %d Window', 'Quit %d Windows', this.sourceActor.windowsCount).format(\n                    this.sourceActor.windowsCount));\n            }\n\n            this._quitMenuItem.actor.show();\n        } else {\n            this._quitMenuItem.actor.hide();\n        }\n\n        if (Docking.DockManager.settings.showWindowsPreview) {\n            const windows = this.sourceActor.getInterestingWindows();\n\n            // update, show, or hide the allWindows menu\n            // Check if there are new windows not already displayed. In such case,\n            // repopulate the allWindows menu. Windows removal is already handled\n            // by each preview being connected to the destroy signal\n            const oldWindows = this._allWindowsMenuItem.menu._getMenuItems().map(item => {\n                return item._window;\n            });\n\n            const newWindows = windows.filter(w =>\n                oldWindows.indexOf(w) < 0);\n            if (newWindows.length > 0) {\n                this._populateAllWindowMenu(windows);\n\n                // Try to set the width to that of the submenu.\n                // TODO: can't get the actual size, getting a bit less.\n                // Temporary workaround: add 15px to compensate\n                this._allWindowsMenuItem.width =  this._allWindowsMenuItem.menu.actor.width + 15;\n            }\n\n            // The menu is created hidden and never hidden after being shown.\n            // Instead, a signal connected to its items destroy will set is\n            // insensitive if no more windows preview are shown.\n            if (windows.length > 0) {\n                this._allWindowsMenuItem.show();\n                this._allWindowsMenuItem.setSensitive(true);\n\n                if (Docking.DockManager.settings.defaultWindowsPreviewToOpen)\n                    this._allWindowsMenuItem.menu.open();\n            }\n        }\n\n        // Update separators\n        this._getMenuItems().forEach(item => {\n            if ('label' in item)\n                this._updateSeparatorVisibility(item);\n        });\n    }\n\n    _populateAllWindowMenu(windows) {\n        this._allWindowsMenuItem.menu.removeAll();\n\n        if (windows.length > 0) {\n            const activeWorkspace = global.workspace_manager.get_active_workspace();\n            let separatorShown =  windows[0].get_workspace() !== activeWorkspace;\n\n            for (let i = 0; i < windows.length; i++) {\n                const window = windows[i];\n                if (!separatorShown && window.get_workspace() !== activeWorkspace) {\n                    this._allWindowsMenuItem.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());\n                    separatorShown = true;\n                }\n\n                const item = new WindowPreview.WindowPreviewMenuItem(window,\n                    St.Side.LEFT);\n                this._allWindowsMenuItem.menu.addMenuItem(item);\n                item.connect('activate', () => {\n                    this.emit('activate-window', window);\n                });\n\n                // This is to achieve a more graceful transition when the last\n                // window is closed.\n                item.connect('destroy', () => {\n                    // It's still counting the item just going to be destroyed\n                    if (this._allWindowsMenuItem.menu._getMenuItems().length === 1)\n                        this._allWindowsMenuItem.setSensitive(false);\n                });\n            }\n        }\n    }\n};\n\n/**\n * @param w\n */\nfunction isWindowUrgent(w) {\n    return w.urgent || w.demandsAttention || w._manualUrgency;\n}\n\n/**\n * Filter out unnecessary windows, for instance\n * nautilus desktop window.\n *\n * @param windows\n * @param monitorIndex\n */\nexport function getInterestingWindows(windows, monitorIndex) {\n    const {settings} = Docking.DockManager;\n\n    // When using workspace isolation, we filter out windows\n    // that are neither in the current workspace nor marked urgent\n    if (settings.isolateWorkspaces) {\n        const showUrgent = settings.workspaceAgnosticUrgentWindows;\n        const activeWorkspace = global.workspace_manager.get_active_workspace();\n        windows = windows.filter(w => {\n            const inWorkspace = w.get_workspace() === activeWorkspace;\n            return inWorkspace || (showUrgent && isWindowUrgent(w));\n        });\n    }\n\n    if (settings.isolateMonitors && monitorIndex >= 0) {\n        windows = windows.filter(w => {\n            return w.get_monitor() === monitorIndex;\n        });\n    }\n\n    return windows.filter(w => !w.skipTaskbar);\n}\n\n/**\n * A ShowAppsIcon improved class.\n *\n * - set label position based on dash orientation\n *   Note: we are am reusing most machinery of the appIcon class.\n * - implement a popupMenu based on the AppIcon code\n *   Note: we are reusing most machinery of the appIcon class)\n *\n */\n\nexport const DockShowAppsIcon = GObject.registerClass({\n    Signals: {\n        'menu-state-changed': {param_types: [GObject.TYPE_BOOLEAN]},\n        'sync-tooltip': {},\n    },\n}\n, class DockShowAppsIcon extends Dash.ShowAppsIcon {\n    _init(position) {\n        super._init();\n\n        // Re-use appIcon methods\n        const {prototype: appIconPrototype} = AppDisplay.AppIcon;\n        this.toggleButton.y_expand = false;\n        this.toggleButton.connect('popup-menu', () =>\n            appIconPrototype._onKeyboardPopupMenu.call(this));\n        this.toggleButton.connect('clicked', () =>\n            this._removeMenuTimeout());\n\n        this.reactive = true;\n        this.toggleButton.popupMenu = (...args) =>\n            this.popupMenu(...args);\n        this.toggleButton._setPopupTimeout = (...args) =>\n            this._setPopupTimeout(...args);\n        this.toggleButton._removeMenuTimeout = (...args) =>\n            this._removeMenuTimeout(...args);\n\n        this.label?.add_style_class_name(Theming.PositionStyleClass[position]);\n        if (Docking.DockManager.settings.customThemeShrink)\n            this.label?.add_style_class_name('shrink');\n\n        this._menu = null;\n        this._menuManager = new PopupMenu.PopupMenuManager(this);\n        this._menuTimeoutId = 0;\n    }\n\n    _createIcon(size) {\n        this._iconActor = super._createIcon(size);\n        this._iconActor.fallbackIconName = this._iconActor.iconName;\n        this._iconActor.fallbackGicon = this._iconActor.gicon;\n        this._iconActor.iconName = `view-app-grid-${Main.sessionMode.currentMode}-symbolic`;\n        return this._iconActor;\n    }\n\n    vfunc_leave_event(...args) {\n        return AppDisplay.AppIcon.prototype.vfunc_leave_event.call(\n            this.toggleButton, ...args);\n    }\n\n    vfunc_button_press_event(...args) {\n        return AppDisplay.AppIcon.prototype.vfunc_button_press_event.call(\n            this.toggleButton, ...args);\n    }\n\n    vfunc_touch_event(...args) {\n        return AppDisplay.AppIcon.prototype.vfunc_touch_event.call(\n            this.toggleButton, ...args);\n    }\n\n    showLabel(...args) {\n        itemShowLabel.call(this, ...args);\n    }\n\n    setForcedHighlight(...args) {\n        AppDisplay.AppIcon.prototype.setForcedHighlight.call(this, ...args);\n    }\n\n    _onMenuPoppedDown(...args) {\n        AppDisplay.AppIcon.prototype._onMenuPoppedDown.call(this, ...args);\n    }\n\n    _setPopupTimeout(...args) {\n        AppDisplay.AppIcon.prototype._setPopupTimeout.call(this, ...args);\n    }\n\n    _removeMenuTimeout(...args) {\n        AppDisplay.AppIcon.prototype._removeMenuTimeout.call(this, ...args);\n    }\n\n    popupMenu() {\n        this._removeMenuTimeout();\n        this.toggleButton.fake_release();\n\n        if (!this._menu) {\n            this._menu = new DockShowAppsIconMenu(this);\n            this._menu.connect('open-state-changed', (menu, isPoppedUp) => {\n                if (!isPoppedUp)\n                    this._onMenuPoppedDown();\n            });\n            const id = Main.overview.connect('hiding', () => {\n                this._menu.close();\n            });\n            this._menu.actor.connect('destroy', () => {\n                Main.overview.disconnect(id);\n            });\n            this._menuManager.addMenu(this._menu);\n        }\n\n        this.emit('menu-state-changed', true);\n\n        this.toggleButton.set_hover(true);\n        this._menu.popup();\n        this._menuManager.ignoreRelease();\n        this.emit('sync-tooltip');\n\n        return false;\n    }\n});\n\n\n/**\n * A menu for the showAppsIcon\n */\nclass DockShowAppsIconMenu extends DockAppIconMenu {\n    _rebuildMenu() {\n        this.removeAll();\n\n        /* Translators: %s is \"Settings\", which is automatically translated. You\n           can also translate the full message if this fits better your language. */\n        const name = __('Dash to Dock %s').format(_('Settings'));\n        const item = this._appendMenuItem(name);\n\n        item.connect('activate', () =>\n            Docking.DockManager.extension.openPreferences());\n    }\n}\n\n/**\n * This function is used for both DockShowAppsIcon and DockDashItemContainer\n */\nexport function itemShowLabel() {\n    /* eslint-disable no-invalid-this */\n    // Check if the label is still present at all. When switching workspace, the\n    // item might have been destroyed in between.\n    if (!this._labelText || !this.label.get_stage())\n        return;\n\n    this.label.set_text(this._labelText);\n    this.label.opacity = 0;\n    this.label.show();\n\n    const [stageX, stageY] = this.get_transformed_position();\n    const node = this.label.get_theme_node();\n\n    const itemWidth  = this.allocation.x2 - this.allocation.x1;\n    const itemHeight = this.allocation.y2 - this.allocation.y1;\n\n    const labelWidth = this.label.get_width();\n    const labelHeight = this.label.get_height();\n\n    let x, y, xOffset, yOffset;\n\n    const position = Utils.getPosition();\n    const labelOffset = node.get_length('-x-offset');\n\n    switch (position) {\n    case St.Side.LEFT:\n        yOffset = Math.floor((itemHeight - labelHeight) / 2);\n        y = stageY + yOffset;\n        xOffset = labelOffset;\n        x = stageX + this.get_width() + xOffset;\n        break;\n    case St.Side.RIGHT:\n        yOffset = Math.floor((itemHeight - labelHeight) / 2);\n        y = stageY + yOffset;\n        xOffset = labelOffset;\n        x = Math.round(stageX) - labelWidth - xOffset;\n        break;\n    case St.Side.TOP:\n        y = stageY + labelOffset + itemHeight;\n        xOffset = Math.floor((itemWidth - labelWidth) / 2);\n        x = stageX + xOffset;\n        break;\n    case St.Side.BOTTOM:\n        yOffset = labelOffset;\n        y = stageY - labelHeight - yOffset;\n        xOffset = Math.floor((itemWidth - labelWidth) / 2);\n        x = stageX + xOffset;\n        break;\n    }\n\n    // keep the label inside the screen border\n    // Only needed fot the x coordinate.\n\n    // Leave a few pixel gap\n    const gap = 5;\n    const monitor = Main.layoutManager.findMonitorForActor(this);\n    if (x - monitor.x < gap)\n        x += monitor.x - x + labelOffset;\n    else if (x + labelWidth > monitor.x + monitor.width - gap)\n        x -= x + labelWidth - (monitor.x + monitor.width) + gap;\n\n    this.label.remove_all_transitions();\n    this.label.set_position(x, y);\n    this.label.ease({\n        opacity: 255,\n        duration: Dash.DASH_ITEM_LABEL_SHOW_TIME,\n        mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n    });\n    /* eslint-enable no-invalid-this */\n}\n"
        },
        {
          "name": "appIconsDecorator.js",
          "type": "blob",
          "size": 5.7421875,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\n\nimport {\n    Docking,\n    AppIconIndicators,\n    Utils,\n} from './imports.js';\n\nimport {\n    Gio,\n} from './dependencies/gi.js';\n\nimport {\n    AppMenu,\n    AppDisplay,\n    Main,\n    PopupMenu,\n} from './dependencies/shell/ui.js';\n\nconst Labels = Object.freeze({\n    GENERIC: Symbol('generic'),\n    ICONS: Symbol('icons'),\n});\n\nexport class AppIconsDecorator {\n    constructor() {\n        this._signals = new Utils.GlobalSignalsHandler();\n        this._methodInjections = new Utils.InjectionsHandler();\n        this._propertyInjections = new Utils.PropertyInjectionsHandler(\n            null, {allowNewProperty: true});\n        this._indicators = new Set();\n\n        this._patchAppIcons();\n        this._decorateIcons();\n    }\n\n    destroy() {\n        this._signals?.destroy();\n        delete this._signals;\n        this._methodInjections?.destroy();\n        delete this._methodInjections;\n        this._propertyInjections?.destroy();\n        delete this._propertyInjections;\n        this._indicators?.forEach(i => i.destroy());\n        this._indicators?.clear();\n        delete this._indicators;\n    }\n\n    _decorateIcon(parentIcon, signalLabel = Labels.GENERIC) {\n        const indicator = new AppIconIndicators.UnityIndicator(parentIcon);\n        this._indicators.add(indicator);\n        this._signals.addWithLabel(signalLabel, parentIcon, 'destroy', () => {\n            this._indicators.delete(indicator);\n            indicator.destroy();\n        });\n        return indicator;\n    }\n\n    _decorateIcons() {\n        const {appDisplay} = Docking.DockManager.getDefault().overviewControls;\n\n        const decorateAppIcons = () => {\n            this._indicators.forEach(i => i.destroy());\n            this._indicators.clear();\n            this._signals.removeWithLabel(Labels.ICONS);\n\n            const decorateViewIcons = view => {\n                const items = view.getAllItems();\n                items.forEach(i => {\n                    if (i instanceof AppDisplay.AppIcon) {\n                        this._decorateIcon(i, Labels.ICONS);\n                    } else if (i instanceof AppDisplay.FolderIcon) {\n                        decorateViewIcons(i.view);\n                        this._signals.addWithLabel(Labels.ICONS, i.view,\n                            'view-loaded', () => decorateAppIcons());\n                    }\n                });\n            };\n            decorateViewIcons(appDisplay);\n        };\n\n        this._signals.add(appDisplay, 'view-loaded', () => decorateAppIcons());\n        decorateAppIcons();\n    }\n\n    _patchAppIcons() {\n        const self = this;\n\n        this._methodInjections.add(AppDisplay.AppSearchProvider.prototype,\n            'createResultObject', function (originalFunction, ...args) {\n                /* eslint-disable no-invalid-this */\n                const result = originalFunction.call(this, ...args);\n                if (result instanceof AppDisplay.AppIcon)\n                    self._decorateIcon(result);\n                return result;\n                /* eslint-enable no-invalid-this */\n            });\n\n        this._methodInjections.add(AppDisplay.AppIcon.prototype,\n            'activate', function (originalFunction, ...args) {\n                /* eslint-disable no-invalid-this */\n                if (this.updating) {\n                    const icon = Gio.Icon.new_for_string('action-unavailable-symbolic');\n                    Main.osdWindowManager.show(-1, icon,\n                        _('%s is updating, try again later').format(this.name),\n                        null);\n                    return;\n                }\n\n                originalFunction.call(this, ...args);\n                /* eslint-enable no-invalid-this */\n            });\n\n        const appIconsTypes = [\n            AppDisplay.AppSearchProvider,\n            AppDisplay.AppIcon,\n        ];\n        appIconsTypes.forEach(type =>\n            this._propertyInjections.add(type.prototype, 'updating', {\n                get() {\n                    return !!this.__d2dUpdating;\n                },\n                set(updating) {\n                    if (this.updating === updating)\n                        return;\n                    this.__d2dUpdating = updating;\n                    if (updating)\n                        this.add_style_class_name('updating');\n                    else\n                        this.remove_style_class_name('updating');\n                },\n            }));\n\n        this._methodInjections.add(AppMenu.AppMenu.prototype,\n            'open', function (originalFunction, ...args) {\n                /* eslint-disable no-invalid-this */\n                if (!this.sourceActor.updating) {\n                    originalFunction.call(this, ...args);\n                    return;\n                }\n\n                if (this.isOpen)\n                    return;\n\n                if (this.isEmpty())\n                    return;\n\n                // Temporarily hide all the menu items a part the Pinning and\n                // the details one while we're updating.\n                const validItems = [\n                    this._toggleFavoriteItem,\n                    this._detailsItem,\n                ];\n                const items = this._getMenuItems().filter(\n                    i => !validItems.includes(i)).map(i =>\n                    i instanceof PopupMenu.PopupMenuBase ? i.actor : i);\n                const itemsVisibility = items.map(i => i.visible);\n                items.forEach(i => (i.visible = false));\n                const menuClosedId = this.connect('menu-closed', () => {\n                    this.disconnect(menuClosedId);\n                    items.forEach((i, idx) => (i.visible = itemsVisibility[idx]));\n                });\n                originalFunction.call(this, ...args);\n                /* eslint-enable no-invalid-this */\n            });\n    }\n}\n"
        },
        {
          "name": "appSpread.js",
          "type": "blob",
          "size": 7.05859375,
          "content": "import {Atk, Clutter} from './dependencies/gi.js';\n\nimport {\n    Main,\n    SearchController,\n    Workspace,\n    WorkspaceThumbnail,\n} from './dependencies/shell/ui.js';\n\nimport {Utils} from './imports.js';\n\nexport class AppSpread {\n    constructor() {\n        this.app = null;\n        this.supported = true;\n        this.windows = [];\n\n        // fail early and do nothing, if mandatory gnome shell functions are missing\n        if (Main.overview.isDummy ||\n            !Workspace?.Workspace?.prototype._isOverviewWindow ||\n            !WorkspaceThumbnail?.WorkspaceThumbnail?.prototype._isOverviewWindow) {\n            log('Dash to dock: Unable to temporarily replace shell functions ' +\n                'for app spread - using previews instead');\n            this.supported = false;\n            return;\n        }\n\n        this._signalHandlers = new Utils.GlobalSignalsHandler();\n        this._methodInjections = new Utils.InjectionsHandler();\n        this._vfuncInjections = new Utils.VFuncInjectionsHandler();\n    }\n\n    get isInAppSpread() {\n        return !!this.app;\n    }\n\n    destroy() {\n        if (!this.supported)\n            return;\n        this._hideAppSpread();\n        this._signalHandlers.destroy();\n        this._methodInjections.destroy();\n        this._vfuncInjections.destroy();\n    }\n\n    toggle(app) {\n        const newApp = this.app !== app;\n        if (this.app)\n            Main.overview.hide(); // also triggers hook 'hidden'\n\n        if (app && newApp)\n            this._showAppSpread(app);\n    }\n\n    _updateWindows() {\n        this.windows = this.app.get_windows();\n    }\n\n    _restoreDefaultWindows() {\n        const {workspaceManager} = global;\n\n        for (let i = 0; i < workspaceManager.nWorkspaces; i++) {\n            const metaWorkspace = workspaceManager.get_workspace_by_index(i);\n            metaWorkspace.list_windows().forEach(w => metaWorkspace.emit('window-added', w));\n        }\n    }\n\n    _filterWindows() {\n        const {workspaceManager} = global;\n\n        for (let i = 0; i < workspaceManager.nWorkspaces; i++) {\n            const metaWorkspace = workspaceManager.get_workspace_by_index(i);\n            metaWorkspace.list_windows().filter(w => !this.windows.includes(w)).forEach(\n                w => metaWorkspace.emit('window-removed', w));\n        }\n    }\n\n    _restoreDefaultOverview() {\n        this._hideAppSpread();\n        this._restoreDefaultWindows();\n    }\n\n    _showAppSpread(app) {\n        if (this.isInAppSpread)\n            return;\n\n        // Checked in overview \"hide\" event handler _hideAppSpread\n        this.app = app;\n        this._updateWindows();\n\n        // we need to hook into overview 'hidden' like this, in case app spread\n        // overview is hidden by choosing another app it should then do its\n        // cleanup too\n        this._signalHandlers.add(Main.overview, 'hidden', () => this._hideAppSpread());\n\n        const appSpread = this;\n        this._methodInjections.add([\n            // Filter workspaces to only show current app windows\n            Workspace.Workspace.prototype, '_isOverviewWindow',\n            function (originalMethod, window) {\n                /* eslint-disable no-invalid-this */\n                const isOverviewWindow = originalMethod.call(this, window);\n                return isOverviewWindow && appSpread.windows.includes(window);\n                /* eslint-enable no-invalid-this */\n            },\n        ],\n        [\n            // Filter thumbnails to only show current app windows\n            WorkspaceThumbnail.WorkspaceThumbnail.prototype, '_isOverviewWindow',\n            function (originalMethod, windowActor) {\n                /* eslint-disable no-invalid-this */\n                const isOverviewWindow = originalMethod.call(this, windowActor);\n                return isOverviewWindow && appSpread.windows.includes(windowActor.metaWindow);\n                /* eslint-enable no-invalid-this */\n            },\n        ]);\n\n        const activitiesButton = Main.panel.statusArea?.activities;\n\n        if (activitiesButton) {\n            this._signalHandlers.add(Main.overview, 'showing', () => {\n                activitiesButton.remove_style_pseudo_class('overview');\n                activitiesButton.remove_accessible_state(Atk.StateType.CHECKED);\n            });\n\n            this._vfuncInjections.add([\n                activitiesButton.constructor.prototype,\n                'event',\n                function (event) {\n                    if (event.type() === Clutter.EventType.TOUCH_END ||\n                        event.type() === Clutter.EventType.BUTTON_RELEASE) {\n                        if (Main.overview.shouldToggleByCornerOrButton())\n                            appSpread._restoreDefaultOverview();\n                    }\n                    return Clutter.EVENT_PROPAGATE;\n                },\n            ],\n            [\n                activitiesButton.constructor.prototype,\n                'key_release_event',\n                function (keyEvent) {\n                    const {keyval} = keyEvent;\n                    if (keyval === Clutter.KEY_Return || keyval === Clutter.KEY_space) {\n                        if (Main.overview.shouldToggleByCornerOrButton())\n                            appSpread._restoreDefaultOverview();\n                    }\n                    return Clutter.EVENT_PROPAGATE;\n                },\n            ]);\n        }\n\n        this._signalHandlers.add(Main.overview.dash.showAppsButton, 'notify::checked', () => {\n            if (Main.overview.dash.showAppsButton.checked)\n                this._restoreDefaultOverview();\n        });\n\n        // If closing windows in AppSpread, and only one window left:\n        // exit app spread and focus remaining window (handled in _hideAppSpread)\n        this._signalHandlers.add(this.app, 'windows-changed', () => {\n            this._updateWindows();\n\n            if (this.windows.length <= 1)\n                Main.overview.hide();\n        });\n\n        this._disableSearch();\n\n        Main.overview.show();\n    }\n\n    _hideAppSpread() {\n        if (!this.isInAppSpread)\n            return;\n\n        if (Main.overview.visible) {\n            Main.panel.statusArea?.activities.add_style_pseudo_class('overview');\n            Main.panel.statusArea?.activities.add_accessible_state(Atk.StateType.CHECKED);\n        }\n\n        // Restore original behaviour\n        this.app = null;\n        this._enableSearch();\n        this._methodInjections.clear();\n        this._signalHandlers.clear();\n        this._vfuncInjections.clear();\n\n        // Check reason for leaving AppSpread was closing app windows and only one window left...\n        if (this.windows.length === 1)\n            Main.activateWindow(this.windows[0]);\n\n        this.windows = [];\n    }\n\n    _disableSearch() {\n        if (!SearchController.SearchController.prototype._shouldTriggerSearch)\n            return;\n\n        if (Main.overview.searchEntry)\n            Main.overview.searchEntry.opacity = 0;\n\n        this._methodInjections.add(\n            SearchController.SearchController.prototype,\n            '_shouldTriggerSearch', () => false);\n    }\n\n    _enableSearch() {\n        if (Main.overview.searchEntry)\n            Main.overview.searchEntry.opacity = 255;\n    }\n}\n"
        },
        {
          "name": "dash.js",
          "type": "blob",
          "size": 41.818359375,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {\n    Clutter,\n    Gio,\n    GLib,\n    GObject,\n    Shell,\n    St,\n} from './dependencies/gi.js';\n\nimport {\n    AppFavorites,\n    Dash,\n    DND,\n    Main,\n} from './dependencies/shell/ui.js';\n\nimport {\n    Util,\n} from './dependencies/shell/misc.js';\n\nimport {\n    AppIcons,\n    Docking,\n    Theming,\n    Utils,\n} from './imports.js';\n\n// module \"Dash\" does not export DASH_ANIMATION_TIME\n// so we just define it like it is defined in Dash;\n// taken from https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/main/js/ui/dash.js\nconst DASH_ANIMATION_TIME = 200;\nconst DASH_VISIBILITY_TIMEOUT = 3;\n\nconst Labels = Object.freeze({\n    SHOW_MOUNTS: Symbol('show-mounts'),\n    FIRST_LAST_CHILD_WORKAROUND: Symbol('first-last-child-workaround'),\n});\n\n/**\n * Extend DashItemContainer\n *\n * - set label position based on dash orientation\n *\n */\nconst DockDashItemContainer = GObject.registerClass(\nclass DockDashItemContainer extends Dash.DashItemContainer {\n    _init(position) {\n        super._init();\n\n        this.label?.add_style_class_name(Theming.PositionStyleClass[position]);\n        if (Docking.DockManager.settings.customThemeShrink)\n            this.label?.add_style_class_name('shrink');\n    }\n\n    showLabel() {\n        return AppIcons.itemShowLabel.call(this);\n    }\n\n    // we override the method show taken from:\n    // https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/main/js/ui/dash.js\n    // in order to apply a little modification at the end of the animation\n    // which makes sure that the icon background is not blurry\n    show(animate) {\n        if (this.child == null)\n            return;\n\n        this.ease({\n            scale_x: 1,\n            scale_y: 1,\n            opacity: 255,\n            duration: animate ? DASH_ANIMATION_TIME : 0,\n            mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n            onComplete: () => {\n                // when the animation is ended, we simulate\n                // a hover to gain back focus and unblur the\n                // background\n                this.set_hover(true);\n            },\n        });\n    }\n});\n\nconst DockDashIconsVerticalLayout = GObject.registerClass(\n    class DockDashIconsVerticalLayout extends Clutter.BoxLayout {\n        _init() {\n            super._init({\n                orientation: Clutter.Orientation.VERTICAL,\n            });\n        }\n\n        vfunc_get_preferred_height(container, forWidth) {\n            const [natHeight] = super.vfunc_get_preferred_height(container, forWidth);\n            return [natHeight, 0];\n        }\n    });\n\n\nconst baseIconSizes = [16, 22, 24, 32, 48, 64, 96, 128];\n\n/**\n * This class is a fork of the upstream dash class (ui.dash.js)\n *\n * Summary of changes:\n * - disconnect global signals adding a destroy method;\n * - play animations even when not in overview mode\n * - set a maximum icon size\n * - show running and/or favorite applications\n * - hide showApps label when the custom menu is shown.\n * - add scrollview\n *   ensure actor is visible on keyfocus inseid the scrollview\n * - add 128px icon size, might be useful for hidpi display\n * - sync minimization application target position.\n * - keep running apps ordered.\n */\nexport const DockDash = GObject.registerClass({\n    Properties: {\n        'requires-visibility': GObject.ParamSpec.boolean(\n            'requires-visibility', 'requires-visibility', 'requires-visibility',\n            GObject.ParamFlags.READWRITE,\n            false),\n    },\n    Signals: {\n        'menu-opened': {},\n        'menu-closed': {},\n        'icon-size-changed': {},\n    },\n}, class DockDash extends St.Widget {\n    _init(monitorIndex) {\n        // Initialize icon variables and size\n        super._init({\n            name: 'dash',\n            offscreen_redirect: Clutter.OffscreenRedirect.ALWAYS,\n            layout_manager: new Clutter.BinLayout(),\n        });\n\n        this._maxWidth = -1;\n        this._maxHeight = -1;\n        this.iconSize = Docking.DockManager.settings.dashMaxIconSize;\n        this._availableIconSizes = baseIconSizes;\n        this._shownInitially = false;\n        this._initializeIconSize(this.iconSize);\n        this._signalsHandler = new Utils.GlobalSignalsHandler(this);\n\n        this._separator = null;\n\n        this._monitorIndex = monitorIndex;\n        this._position = Utils.getPosition();\n        this._isHorizontal = (this._position === St.Side.TOP) ||\n                               (this._position === St.Side.BOTTOM);\n\n        this._dragPlaceholder = null;\n        this._dragPlaceholderPos = -1;\n        this._animatingPlaceholdersCount = 0;\n        this._showLabelTimeoutId = 0;\n        this._resetHoverTimeoutId = 0;\n        this._labelShowing = false;\n\n        this._dashContainer = new St.BoxLayout({\n            name: 'dashtodockDashContainer',\n            x_align: Clutter.ActorAlign.CENTER,\n            y_align: Clutter.ActorAlign.CENTER,\n            vertical: !this._isHorizontal,\n            y_expand: this._isHorizontal,\n            x_expand: !this._isHorizontal,\n        });\n\n        this._scrollView = new St.ScrollView({\n            name: 'dashtodockDashScrollview',\n            hscrollbar_policy: this._isHorizontal ? St.PolicyType.EXTERNAL : St.PolicyType.NEVER,\n            vscrollbar_policy: this._isHorizontal ?  St.PolicyType.NEVER : St.PolicyType.EXTERNAL,\n            x_expand: this._isHorizontal,\n            y_expand: !this._isHorizontal,\n            enable_mouse_scrolling: false,\n        });\n\n        this._scrollView.connect('scroll-event', this._onScrollEvent.bind(this));\n\n        this._boxContainer = new St.BoxLayout({\n            name: 'dashtodockBoxContainer',\n            x_align: Clutter.ActorAlign.FILL,\n            y_align: Clutter.ActorAlign.FILL,\n            vertical: !this._isHorizontal,\n        });\n        this._boxContainer.add_style_class_name(Theming.PositionStyleClass[this._position]);\n\n        const rtl = Clutter.get_default_text_direction() === Clutter.TextDirection.RTL;\n        this._box = new St.BoxLayout({\n            vertical: !this._isHorizontal,\n            clip_to_allocation: false,\n            ...!this._isHorizontal ? {layout_manager: new DockDashIconsVerticalLayout()} : {},\n            x_align: rtl ? Clutter.ActorAlign.END : Clutter.ActorAlign.START,\n            y_align: this._isHorizontal ? Clutter.ActorAlign.CENTER : Clutter.ActorAlign.START,\n            y_expand: !this._isHorizontal,\n            x_expand: this._isHorizontal,\n        });\n        this._box._delegate = this;\n        this._boxContainer.add_child(this._box);\n        Utils.addActor(this._scrollView, this._boxContainer);\n        this._dashContainer.add_child(this._scrollView);\n\n        this._showAppsIcon = new AppIcons.DockShowAppsIcon(this._position);\n        this._showAppsIcon.show(false);\n        this._showAppsIcon.icon.setIconSize(this.iconSize);\n        this._showAppsIcon.x_expand = false;\n        this._showAppsIcon.y_expand = false;\n        this.showAppsButton.connect('notify::hover', a => {\n            if (this._showAppsIcon.get_parent() === this._boxContainer)\n                this._ensureItemVisibility(a);\n        });\n        if (!this._isHorizontal)\n            this._showAppsIcon.y_align = Clutter.ActorAlign.START;\n        this._hookUpLabel(this._showAppsIcon);\n        this._showAppsIcon.connect('menu-state-changed', (_icon, opened) => {\n            this._itemMenuStateChanged(this._showAppsIcon, opened);\n        });\n        this.updateShowAppsButton();\n\n        this._background = new St.Widget({\n            style_class: 'dash-background',\n            y_expand: this._isHorizontal,\n            x_expand: !this._isHorizontal,\n        });\n\n        const sizerBox = new Clutter.Actor();\n        sizerBox.add_constraint(new Clutter.BindConstraint({\n            source: this._isHorizontal ? this._showAppsIcon.icon : this._dashContainer,\n            coordinate: Clutter.BindCoordinate.HEIGHT,\n        }));\n        sizerBox.add_constraint(new Clutter.BindConstraint({\n            source: this._isHorizontal ? this._dashContainer : this._showAppsIcon.icon,\n            coordinate: Clutter.BindCoordinate.WIDTH,\n        }));\n        this._background.add_child(sizerBox);\n\n        this.add_child(this._background);\n        this.add_child(this._dashContainer);\n\n        this._workId = Main.initializeDeferredWork(this._box, this._redisplay.bind(this));\n\n        this._shellSettings = new Gio.Settings({\n            schema_id: 'org.gnome.shell',\n        });\n\n        this._appSystem = Shell.AppSystem.get_default();\n\n        this.iconAnimator = new Docking.IconAnimator(this);\n\n        this._signalsHandler.add([\n            this._appSystem,\n            'installed-changed',\n            () => {\n                AppFavorites.getAppFavorites().reload();\n                this._queueRedisplay();\n            },\n        ], [\n            AppFavorites.getAppFavorites(),\n            'changed',\n            this._queueRedisplay.bind(this),\n        ], [\n            this._appSystem,\n            'app-state-changed',\n            this._queueRedisplay.bind(this),\n        ], [\n            Main.overview,\n            'item-drag-begin',\n            this._onItemDragBegin.bind(this),\n        ], [\n            Main.overview,\n            'item-drag-end',\n            this._onItemDragEnd.bind(this),\n        ], [\n            Main.overview,\n            'item-drag-cancelled',\n            this._onItemDragCancelled.bind(this),\n        ], [\n            Main.overview,\n            'window-drag-begin',\n            this._onWindowDragBegin.bind(this),\n        ], [\n            Main.overview,\n            'window-drag-cancelled',\n            this._onWindowDragEnd.bind(this),\n        ], [\n            Main.overview,\n            'window-drag-end',\n            this._onWindowDragEnd.bind(this),\n        ]);\n\n        this.connect('destroy', this._onDestroy.bind(this));\n    }\n\n    vfunc_get_preferred_height(forWidth) {\n        const [minHeight, natHeight] = super.vfunc_get_preferred_height.call(this, forWidth);\n        if (!this._isHorizontal && this._maxHeight !== -1 && natHeight > this._maxHeight)\n            return [minHeight, this._maxHeight];\n        else\n            return [minHeight, natHeight];\n    }\n\n    vfunc_get_preferred_width(forHeight) {\n        const [minWidth, natWidth] = super.vfunc_get_preferred_width.call(this, forHeight);\n        if (this._isHorizontal && this._maxWidth !== -1 && natWidth > this._maxWidth)\n            return [minWidth, this._maxWidth];\n        else\n            return [minWidth, natWidth];\n    }\n\n    get _container() {\n        return this._dashContainer;\n    }\n\n    _onDestroy() {\n        this.iconAnimator.destroy();\n\n        if (this._requiresVisibilityTimeout) {\n            GLib.source_remove(this._requiresVisibilityTimeout);\n            delete this._requiresVisibilityTimeout;\n        }\n\n        if (this._ensureActorVisibilityTimeoutId) {\n            GLib.source_remove(this._ensureActorVisibilityTimeoutId);\n            delete this._ensureActorVisibilityTimeoutId;\n        }\n    }\n\n\n    _onItemDragBegin(...args) {\n        return Dash.Dash.prototype._onItemDragBegin.call(this, ...args);\n    }\n\n    _onItemDragCancelled(...args) {\n        return Dash.Dash.prototype._onItemDragCancelled.call(this, ...args);\n    }\n\n    _onItemDragEnd(...args) {\n        return Dash.Dash.prototype._onItemDragEnd.call(this, ...args);\n    }\n\n    _endItemDrag(...args) {\n        return Dash.Dash.prototype._endItemDrag.call(this, ...args);\n    }\n\n    _onItemDragMotion(...args) {\n        return Dash.Dash.prototype._onItemDragMotion.call(this, ...args);\n    }\n\n    _appIdListToHash(...args) {\n        return Dash.Dash.prototype._appIdListToHash.call(this, ...args);\n    }\n\n    _queueRedisplay(...args) {\n        return Dash.Dash.prototype._queueRedisplay.call(this, ...args);\n    }\n\n    _hookUpLabel(...args) {\n        return Dash.Dash.prototype._hookUpLabel.call(this, ...args);\n    }\n\n    _syncLabel(...args) {\n        return Dash.Dash.prototype._syncLabel.call(this, ...args);\n    }\n\n    _clearDragPlaceholder(...args) {\n        return Dash.Dash.prototype._clearDragPlaceholder.call(this, ...args);\n    }\n\n    _clearEmptyDropTarget(...args) {\n        return Dash.Dash.prototype._clearEmptyDropTarget.call(this, ...args);\n    }\n\n    handleDragOver(source, actor, x, y, time) {\n        let ret;\n        if (this._isHorizontal) {\n            ret = Dash.Dash.prototype.handleDragOver.call(this, source, actor, x, y, time);\n\n            if (ret === DND.DragMotionResult.CONTINUE)\n                return ret;\n        } else {\n            const propertyInjections = new Utils.PropertyInjectionsHandler();\n            propertyInjections.add(this._box, 'width', {\n                get: () => this._box.get_children().reduce((a, c) => a + c.height, 0),\n            });\n\n            if (this._dragPlaceholder) {\n                propertyInjections.add(this._dragPlaceholder, 'width', {\n                    get: () => this._dragPlaceholder.height,\n                });\n            }\n\n            ret = Dash.Dash.prototype.handleDragOver.call(this, source, actor, y, x, time);\n            propertyInjections.destroy();\n\n            if (ret === DND.DragMotionResult.CONTINUE)\n                return ret;\n\n            if (this._dragPlaceholder) {\n                this._dragPlaceholder.child.set_width(this.iconSize / 2);\n                this._dragPlaceholder.child.set_height(this.iconSize);\n\n                let pos = this._dragPlaceholderPos;\n                if (this._isHorizontal &&\n                    Clutter.get_default_text_direction() === Clutter.TextDirection.RTL)\n                    pos = this._box.get_children() - 1 - pos;\n\n                if (pos !== this._dragPlaceholderPos) {\n                    this._dragPlaceholderPos = pos;\n                    this._box.set_child_at_index(this._dragPlaceholder,\n                        this._dragPlaceholderPos);\n                }\n            }\n        }\n\n        if (this._dragPlaceholder) {\n            // Ensure the next and previous icon are visible when moving the\n            // placeholder (we're assuming there's room for both of them)\n            const children = this._box.get_children();\n            if (this._dragPlaceholderPos > 0) {\n                ensureActorVisibleInScrollView(this._scrollView,\n                    children[this._dragPlaceholderPos - 1]);\n            }\n\n            if (this._dragPlaceholderPos >= -1 &&\n                this._dragPlaceholderPos < children.length - 1) {\n                ensureActorVisibleInScrollView(this._scrollView,\n                    children[this._dragPlaceholderPos + 1]);\n            }\n        }\n\n        return ret;\n    }\n\n    acceptDrop(...args) {\n        return Dash.Dash.prototype.acceptDrop.call(this, ...args);\n    }\n\n    _onWindowDragBegin(...args) {\n        return Dash.Dash.prototype._onWindowDragBegin.call(this, ...args);\n    }\n\n    _onWindowDragEnd(...args) {\n        return Dash.Dash.prototype._onWindowDragEnd.call(this, ...args);\n    }\n\n    _onScrollEvent(actor, event) {\n        // If scroll is not used because the icon is resized, let the scroll event propagate.\n        if (!Docking.DockManager.settings.iconSizeFixed)\n            return Clutter.EVENT_PROPAGATE;\n\n        // reset timeout to avid conflicts with the mousehover event\n        this._ensureItemVisibility(null);\n\n        // Skip to avoid double events mouse\n        // TODO: Horizontal events are emulated, potentially due to a conflict\n        // with the workspace switching gesture.\n        if (!this._isHorizontal && event.is_pointer_emulated())\n            return Clutter.EVENT_STOP;\n\n\n        let adjustment, delta = 0;\n\n        if (this._isHorizontal)\n            adjustment = this._scrollView.get_hscroll_bar().get_adjustment();\n        else\n            adjustment = this._scrollView.get_vscroll_bar().get_adjustment();\n\n        const increment = adjustment.step_increment;\n\n        if (this._isHorizontal) {\n            switch (event.get_scroll_direction()) {\n            case Clutter.ScrollDirection.LEFT:\n                delta = -increment;\n                break;\n            case Clutter.ScrollDirection.RIGHT:\n                delta = Number(increment);\n                break;\n            case Clutter.ScrollDirection.SMOOTH: {\n                const [dx] = event.get_scroll_delta();\n                delta = dx * increment;\n                break;\n            }\n            }\n        } else {\n            switch (event.get_scroll_direction()) {\n            case Clutter.ScrollDirection.UP:\n                delta = -increment;\n                break;\n            case Clutter.ScrollDirection.DOWN:\n                delta = Number(increment);\n                break;\n            case Clutter.ScrollDirection.SMOOTH: {\n                const [, dy] = event.get_scroll_delta();\n                delta = dy * increment;\n                break;\n            }\n            }\n        }\n\n        const value = adjustment.get_value();\n\n        // TODO: Remove this if possible.\n        if (Number.isNaN(value))\n            adjustment.set_value(delta);\n        else\n            adjustment.set_value(value + delta);\n\n        return Clutter.EVENT_STOP;\n    }\n\n    _ensureItemVisibility(actor) {\n        if (actor?.hover) {\n            const destroyId =\n                actor.connect('destroy', () => this._ensureItemVisibility(null));\n            this._ensureActorVisibilityTimeoutId = GLib.timeout_add(\n                GLib.PRIORITY_DEFAULT, 100, () => {\n                    actor.disconnect(destroyId);\n                    ensureActorVisibleInScrollView(this._scrollView, actor);\n                    this._ensureActorVisibilityTimeoutId = 0;\n                    return GLib.SOURCE_REMOVE;\n                });\n        } else if (this._ensureActorVisibilityTimeoutId) {\n            GLib.source_remove(this._ensureActorVisibilityTimeoutId);\n            this._ensureActorVisibilityTimeoutId = 0;\n        }\n    }\n\n    _createAppItem(app) {\n        const appIcon = new AppIcons.makeAppIcon(app, this._monitorIndex, this.iconAnimator);\n\n        if (appIcon._draggable) {\n            appIcon._draggable.connect('drag-begin', () => {\n                appIcon.opacity = 50;\n            });\n            appIcon._draggable.connect('drag-end', () => {\n                appIcon.opacity = 255;\n            });\n        }\n\n        appIcon.connect('menu-state-changed', (_, opened) => {\n            this._itemMenuStateChanged(item, opened);\n        });\n\n        const item = new DockDashItemContainer(this._position);\n        item.setChild(appIcon);\n\n        appIcon.connect('notify::hover', a => this._ensureItemVisibility(a));\n        appIcon.connect('clicked', actor => {\n            ensureActorVisibleInScrollView(this._scrollView, actor);\n        });\n\n        appIcon.connect('key-focus-in', actor => {\n            const [xShift, yShift] = ensureActorVisibleInScrollView(this._scrollView, actor);\n\n            // This signal is triggered also by mouse click. The popup menu is opened at the original\n            // coordinates. Thus correct for the shift which is going to be applied to the scrollview.\n            if (appIcon._menu) {\n                appIcon._menu._boxPointer.xOffset = -xShift;\n                appIcon._menu._boxPointer.yOffset = -yShift;\n            }\n        });\n\n        appIcon.connect('notify::focused', () => {\n            const {settings} = Docking.DockManager;\n            if (appIcon.focused && settings.scrollToFocusedApplication)\n                ensureActorVisibleInScrollView(this._scrollView, item);\n        });\n\n        appIcon.connect('notify::urgent', () => {\n            if (appIcon.urgent) {\n                ensureActorVisibleInScrollView(this._scrollView, item);\n                if (Docking.DockManager.settings.showDockUrgentNotify)\n                    this._requireVisibility();\n            }\n        });\n\n        // Override default AppIcon label_actor, now the\n        // accessible_name is set at DashItemContainer.setLabelText\n        appIcon.label_actor = null;\n        item.setLabelText(app.get_name());\n\n        appIcon.icon.setIconSize(this.iconSize);\n        this._hookUpLabel(item, appIcon);\n\n        item.connect('notify::position', () => appIcon.updateIconGeometry());\n        item.connect('notify::size', () => appIcon.updateIconGeometry());\n\n        return item;\n    }\n\n    _requireVisibility() {\n        this.requiresVisibility = true;\n\n        if (this._requiresVisibilityTimeout)\n            GLib.source_remove(this._requiresVisibilityTimeout);\n\n        this._requiresVisibilityTimeout = GLib.timeout_add_seconds(GLib.PRIORITY_DEFAULT,\n            DASH_VISIBILITY_TIMEOUT, () => {\n                this._requiresVisibilityTimeout = 0;\n                this.requiresVisibility = false;\n            });\n    }\n\n    /**\n     * Return an array with the \"proper\" appIcons currently in the dash\n     */\n    getAppIcons() {\n        // Only consider children which are \"proper\"\n        // icons (i.e. ignoring drag placeholders) and which are not\n        // animating out (which means they will be destroyed at the end of\n        // the animation)\n        const iconChildren = this._box.get_children().filter(actor => {\n            return actor.child &&\n                   !!actor.child.icon &&\n                   !actor.animatingOut;\n        });\n\n        const appIcons = iconChildren.map(actor => {\n            return actor.child;\n        });\n\n        return appIcons;\n    }\n\n    _itemMenuStateChanged(item, opened) {\n        Dash.Dash.prototype._itemMenuStateChanged.call(this, item, opened);\n\n        if (opened) {\n            this.emit('menu-opened');\n        } else {\n            // I want to listen from outside when a menu is closed. I used to\n            // add a custom signal to the appIcon, since gnome 3.8 the signal\n            // calling this callback was added upstream.\n            this.emit('menu-closed');\n        }\n    }\n\n    _adjustIconSize() {\n        // For the icon size, we only consider children which are \"proper\"\n        // icons (i.e. ignoring drag placeholders) and which are not\n        // animating out (which means they will be destroyed at the end of\n        // the animation)\n        const iconChildren = this._box.get_children().filter(actor => {\n            return actor.child &&\n                   actor.child._delegate &&\n                   actor.child._delegate.icon &&\n                   !actor.animatingOut;\n        });\n\n        iconChildren.push(this._showAppsIcon);\n\n        if (this._maxWidth === -1 && this._maxHeight === -1)\n            return;\n\n        // Check if the container is present in the stage. This avoids critical\n        // errors when unlocking the screen\n        if (!this._container.get_stage())\n            return;\n\n        const themeNode = this._dashContainer.get_theme_node();\n        const maxAllocation = new Clutter.ActorBox({\n            x1: 0,\n            y1: 0,\n            x2: this._isHorizontal ? this._maxWidth : 42 /* whatever */,\n            y2: this._isHorizontal ? 42 : this._maxHeight,\n        });\n        const maxContent = themeNode.get_content_box(maxAllocation);\n        let availSpace;\n        if (this._isHorizontal)\n            availSpace = maxContent.get_width();\n        else\n            availSpace = maxContent.get_height();\n\n        const spacing = themeNode.get_length('spacing');\n\n        const [{child: firstButton}] = iconChildren;\n        const {child: firstIcon} = firstButton?.icon ?? {child: null};\n\n        // if no icons there's nothing to adjust\n        if (!firstIcon)\n            return;\n\n        // Enforce valid spacings during the size request\n        firstIcon.ensure_style();\n        const [, , iconWidth, iconHeight] = firstIcon.get_preferred_size();\n        const [, , buttonWidth, buttonHeight] = firstButton.get_preferred_size();\n\n        if (this._isHorizontal) {\n            // Subtract icon padding and box spacing from the available width\n            availSpace -= iconChildren.length * (buttonWidth - iconWidth) +\n                           (iconChildren.length - 1) * spacing;\n\n            if (this._separator) {\n                const [, , separatorWidth] = this._separator.get_preferred_size();\n                availSpace -= separatorWidth + spacing;\n            }\n        } else {\n            // Subtract icon padding and box spacing from the available height\n            availSpace -= iconChildren.length * (buttonHeight - iconHeight) +\n                           (iconChildren.length - 1) * spacing;\n\n            if (this._separator) {\n                const [, , , separatorHeight] = this._separator.get_preferred_size();\n                availSpace -= separatorHeight + spacing;\n            }\n        }\n\n        const maxIconSize = availSpace / iconChildren.length;\n        const {scaleFactor} = St.ThemeContext.get_for_stage(global.stage);\n        const iconSizes = this._availableIconSizes.map(s => s * scaleFactor);\n\n        let [newIconSize] = this._availableIconSizes;\n        for (let i = 0; i < iconSizes.length; i++) {\n            if (iconSizes[i] <= maxIconSize)\n                newIconSize = this._availableIconSizes[i];\n        }\n\n        if (newIconSize === this.iconSize)\n            return;\n\n        const oldIconSize = this.iconSize;\n        this.iconSize = newIconSize;\n        this.emit('icon-size-changed');\n\n        const scale = oldIconSize / newIconSize;\n        for (let i = 0; i < iconChildren.length; i++) {\n            const {icon} = iconChildren[i].child._delegate;\n\n            // Set the new size immediately, to keep the icons' sizes\n            // in sync with this.iconSize\n            icon.setIconSize(this.iconSize);\n\n            // Don't animate the icon size change when the overview\n            // is transitioning, not visible or when initially filling\n            // the dash\n            if (!Main.overview.visible || Main.overview.animationInProgress ||\n                !this._shownInitially)\n                continue;\n\n            const [targetWidth, targetHeight] = icon.icon.get_size();\n\n            // Scale the icon's texture to the previous size and\n            // tween to the new size\n            icon.icon.set_size(icon.icon.width * scale,\n                icon.icon.height * scale);\n\n            icon.icon.ease({\n                width: targetWidth,\n                height: targetHeight,\n                duration: DASH_ANIMATION_TIME,\n                mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n            });\n        }\n\n        if (this._separator) {\n            const animateProperties = this._isHorizontal\n                ? {height: this.iconSize} : {width: this.iconSize};\n\n            this._separator.ease({\n                ...animateProperties,\n                duration: DASH_ANIMATION_TIME,\n                mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n            });\n        }\n    }\n\n    _redisplay() {\n        const favorites = AppFavorites.getAppFavorites().getFavoriteMap();\n\n        let running = this._appSystem.get_running();\n        const dockManager = Docking.DockManager.getDefault();\n        const {settings} = dockManager;\n\n        this._scrollView.set({\n            xAlign: Clutter.ActorAlign.FILL,\n            yAlign: Clutter.ActorAlign.FILL,\n        });\n        if (dockManager.settings.dockExtended) {\n            if (!this._isHorizontal) {\n                this._scrollView.yAlign = dockManager.settings.alwaysCenterIcons\n                    ? Clutter.ActorAlign.CENTER : Clutter.ActorAlign.START;\n            } else {\n                this._scrollView.xAlign = dockManager.settings.alwaysCenterIcons\n                    ? Clutter.ActorAlign.CENTER : Clutter.ActorAlign.START;\n            }\n        }\n\n        if (settings.isolateWorkspaces ||\n            settings.isolateMonitors) {\n            // When using isolation, we filter out apps that have no windows in\n            // the current workspace\n            const monitorIndex = this._monitorIndex;\n            running = running.filter(app =>\n                AppIcons.getInterestingWindows(app.get_windows(), monitorIndex).length);\n        }\n\n        const children = this._box.get_children().filter(actor => {\n            return actor.child &&\n                   actor.child._delegate &&\n                   actor.child._delegate.app;\n        });\n        // Apps currently in the dash\n        let oldApps = children.map(actor => actor.child._delegate.app);\n        // Apps supposed to be in the dash\n        const newApps = [];\n\n        const {showFavorites} = settings;\n        if (showFavorites)\n            newApps.push(...Object.values(favorites));\n\n        if (settings.showRunning) {\n            // We reorder the running apps so that they don't change position on the\n            // dash with every redisplay() call\n\n            // First: add the apps from the oldApps list that are still running\n            oldApps.forEach(oldApp => {\n                const index = running.indexOf(oldApp);\n                if (index > -1) {\n                    const [app] = running.splice(index, 1);\n                    if (!showFavorites || !(app.get_id() in favorites))\n                        newApps.push(app);\n                }\n            });\n\n            // Second: add the new apps\n            running.forEach(app => {\n                if (!showFavorites || !(app.get_id() in favorites))\n                    newApps.push(app);\n            });\n        }\n\n        this._signalsHandler.removeWithLabel(Labels.SHOW_MOUNTS);\n        if (dockManager.removables) {\n            this._signalsHandler.addWithLabel(Labels.SHOW_MOUNTS,\n                dockManager.removables, 'changed', this._queueRedisplay.bind(this));\n            dockManager.removables.getApps().forEach(removable => {\n                if (!newApps.includes(removable))\n                    newApps.push(removable);\n            });\n        } else {\n            oldApps = oldApps.filter(app => !app.location || app.isTrash);\n        }\n\n        if (dockManager.trash) {\n            const trashApp = dockManager.trash.getApp();\n            if (!newApps.includes(trashApp))\n                newApps.push(trashApp);\n        } else {\n            oldApps = oldApps.filter(app => !app.isTrash);\n        }\n\n        // Temporary remove the separator so that we don't compute to position icons\n        const oldSeparatorPos = this._box.get_children().indexOf(this._separator);\n        if (this._separator)\n            this._box.remove_child(this._separator);\n\n        // Figure out the actual changes to the list of items; we iterate\n        // over both the list of items currently in the dash and the list\n        // of items expected there, and collect additions and removals.\n        // Moves are both an addition and a removal, where the order of\n        // the operations depends on whether we encounter the position\n        // where the item has been added first or the one from where it\n        // was removed.\n        // There is an assumption that only one item is moved at a given\n        // time; when moving several items at once, everything will still\n        // end up at the right position, but there might be additional\n        // additions/removals (e.g. it might remove all the launchers\n        // and add them back in the new order even if a smaller set of\n        // additions and removals is possible).\n        // If above assumptions turns out to be a problem, we might need\n        // to use a more sophisticated algorithm, e.g. Longest Common\n        // Subsequence as used by diff.\n\n        const addedItems = [];\n        const removedActors = [];\n\n        let newIndex = 0;\n        let oldIndex = 0;\n        while (newIndex < newApps.length || oldIndex < oldApps.length) {\n            const oldApp = oldApps.length > oldIndex ? oldApps[oldIndex] : null;\n            const newApp = newApps.length > newIndex ? newApps[newIndex] : null;\n\n            // No change at oldIndex/newIndex\n            if (oldApp === newApp) {\n                oldIndex++;\n                newIndex++;\n                continue;\n            }\n\n            // App removed at oldIndex\n            if (oldApp && !newApps.includes(oldApp)) {\n                removedActors.push(children[oldIndex]);\n                oldIndex++;\n                continue;\n            }\n\n            // App added at newIndex\n            if (newApp && !oldApps.includes(newApp)) {\n                addedItems.push({\n                    app: newApp,\n                    item: this._createAppItem(newApp),\n                    pos: newIndex,\n                });\n                newIndex++;\n                continue;\n            }\n\n            // App moved\n            const nextApp = newApps.length > newIndex + 1\n                ? newApps[newIndex + 1] : null;\n            const insertHere = nextApp && nextApp === oldApp;\n            const alreadyRemoved = removedActors.reduce((result, actor) => {\n                const removedApp = actor.child._delegate.app;\n                return result || removedApp === newApp;\n            }, false);\n\n            if (insertHere || alreadyRemoved) {\n                const newItem = this._createAppItem(newApp);\n                addedItems.push({\n                    app: newApp,\n                    item: newItem,\n                    pos: newIndex + removedActors.length,\n                });\n                newIndex++;\n            } else {\n                removedActors.push(children[oldIndex]);\n                oldIndex++;\n            }\n        }\n\n        for (let i = 0; i < addedItems.length; i++) {\n            this._box.insert_child_at_index(addedItems[i].item,\n                addedItems[i].pos);\n        }\n\n        for (let i = 0; i < removedActors.length; i++) {\n            const item = removedActors[i];\n\n            // Don't animate item removal when the overview is transitioning\n            // or hidden\n            if (!Main.overview.animationInProgress)\n                item.animateOutAndDestroy();\n            else\n                item.destroy();\n        }\n\n        // Update separator\n        const nFavorites = Object.keys(favorites).length;\n        const nIcons = children.length + addedItems.length - removedActors.length;\n        if (nFavorites > 0 && nFavorites < nIcons) {\n            if (!this._separator) {\n                this._separator = new St.Widget({\n                    style_class: 'dash-separator',\n                    x_align: this._isHorizontal\n                        ? Clutter.ActorAlign.FILL : Clutter.ActorAlign.CENTER,\n                    y_align: this._isHorizontal\n                        ? Clutter.ActorAlign.CENTER : Clutter.ActorAlign.FILL,\n                    width: this._isHorizontal ? -1 : this.iconSize,\n                    height: this._isHorizontal ? this.iconSize : -1,\n                    reactive: true,\n                    track_hover: true,\n                });\n                this._separator.connect('notify::hover', a => this._ensureItemVisibility(a));\n            }\n            let pos = nFavorites + this._animatingPlaceholdersCount;\n            if (this._dragPlaceholder)\n                pos++;\n            const removedFavorites = removedActors.filter(a =>\n                children.indexOf(a) < oldSeparatorPos);\n            pos += removedFavorites.length;\n            this._box.insert_child_at_index(this._separator, pos);\n        } else if (this._separator) {\n            this._separator.destroy();\n            this._separator = null;\n        }\n\n        this._adjustIconSize();\n\n        // Skip animations on first run when adding the initial set\n        // of items, to avoid all items zooming in at once\n        const animate = this._shownInitially &&\n            !Main.layoutManager._startingUp;\n\n        if (!this._shownInitially)\n            this._shownInitially = true;\n\n        addedItems.forEach(({item}) => item.show(animate));\n\n        // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=692744\n        // Without it, StBoxLayout may use a stale size cache\n        this._box.queue_relayout();\n\n        // This will update the size, and the corresponding number for each icon\n        this._updateNumberOverlay();\n\n        this.updateShowAppsButton();\n    }\n\n    _updateNumberOverlay() {\n        const appIcons = this.getAppIcons();\n        let counter = 1;\n        appIcons.forEach(icon => {\n            if (counter < 10) {\n                icon.setNumberOverlay(counter);\n                counter++;\n            } else if (counter === 10) {\n                icon.setNumberOverlay(0);\n                counter++;\n            } else {\n                // No overlay after 10\n                icon.setNumberOverlay(-1);\n            }\n            icon.updateNumberOverlay();\n        });\n    }\n\n    toggleNumberOverlay(activate) {\n        const appIcons = this.getAppIcons();\n        appIcons.forEach(icon => {\n            icon.toggleNumberOverlay(activate);\n        });\n    }\n\n    _initializeIconSize(maxSize) {\n        const maxAllowed = baseIconSizes[baseIconSizes.length - 1];\n        maxSize = Math.min(maxSize, maxAllowed);\n\n        if (Docking.DockManager.settings.iconSizeFixed) {\n            this._availableIconSizes = [maxSize];\n        } else {\n            this._availableIconSizes = baseIconSizes.filter(val => {\n                return val < maxSize;\n            });\n            this._availableIconSizes.push(maxSize);\n        }\n    }\n\n    setIconSize(maxSize, doNotAnimate) {\n        this._initializeIconSize(maxSize);\n\n        if (doNotAnimate)\n            this._shownInitially = false;\n\n        this._queueRedisplay();\n    }\n\n    /**\n     * Reset the displayed apps icon to maintain the correct order when changing\n     * show favorites/show running settings\n     */\n    resetAppIcons() {\n        const children = this._box.get_children().filter(actor => {\n            return actor.child &&\n                   !!actor.child.icon;\n        });\n        for (let i = 0; i < children.length; i++) {\n            const item = children[i];\n            item.destroy();\n        }\n\n        // to avoid ugly animations, just suppress them like when dash is first loaded.\n        this._shownInitially = false;\n        this._redisplay();\n    }\n\n    get showAppsButton() {\n        return this._showAppsIcon.toggleButton;\n    }\n\n    showShowAppsButton() {\n        this._showAppsIcon.visible = true;\n        this._showAppsIcon.show(true);\n        this.updateShowAppsButton();\n    }\n\n    hideShowAppsButton() {\n        this._showAppsIcon.visible = false;\n    }\n\n    setMaxSize(maxWidth, maxHeight) {\n        if (this._maxWidth === maxWidth &&\n            this._maxHeight === maxHeight)\n            return;\n\n        this._maxWidth = maxWidth;\n        this._maxHeight = maxHeight;\n        this._queueRedisplay();\n    }\n\n    updateShowAppsButton() {\n        if (this._showAppsIcon.get_parent() && !this._showAppsIcon.visible)\n            return;\n\n        const {settings} = Docking.DockManager;\n        const notifiedProperties = [];\n        const showAppsContainer = settings.showAppsAlwaysInTheEdge || !settings.dockExtended\n            ? this._dashContainer : this._boxContainer;\n\n        this._signalsHandler.addWithLabel(Labels.FIRST_LAST_CHILD_WORKAROUND,\n            showAppsContainer, 'notify',\n            (_obj, pspec) => notifiedProperties.push(pspec.name));\n\n        if (this._showAppsIcon.get_parent() !== showAppsContainer) {\n            this._showAppsIcon.get_parent()?.remove_child(this._showAppsIcon);\n\n            if (Docking.DockManager.settings.showAppsAtTop)\n                showAppsContainer.insert_child_below(this._showAppsIcon, null);\n            else\n                showAppsContainer.insert_child_above(this._showAppsIcon, null);\n        } else if (settings.showAppsAtTop) {\n            showAppsContainer.set_child_below_sibling(this._showAppsIcon, null);\n        } else {\n            showAppsContainer.set_child_above_sibling(this._showAppsIcon, null);\n        }\n\n        this._signalsHandler.removeWithLabel(Labels.FIRST_LAST_CHILD_WORKAROUND);\n\n        // This is indeed ugly, but we need to ensure that the last and first\n        // visible widgets are re-computed by St, that is buggy because of a\n        // mutter issue that is being fixed:\n        // https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2047\n        if (!notifiedProperties.includes('first-child'))\n            showAppsContainer.notify('first-child');\n        if (!notifiedProperties.includes('last-child'))\n            showAppsContainer.notify('last-child');\n    }\n});\n\n\n/**\n * This is a copy of the same function in utils.js, but also adjust horizontal scrolling\n * and perform few further checks on the current value to avoid changing the values when\n * it would be clamp to the current one in any case.\n * Return the amount of shift applied\n *\n * @param scrollView\n * @param actor\n */\nfunction ensureActorVisibleInScrollView(scrollView, actor) {\n    // access to scrollView.[hv]scroll was deprecated in gnome 46\n    // instead, adjustment can be accessed directly\n    // keep old way for backwards compatibility (gnome <= 45)\n    const vAdjustment = scrollView.vadjustment ?? scrollView.vscroll.adjustment;\n    const hAdjustment = scrollView.hadjustment ?? scrollView.hscroll.adjustment;\n    const {value: vValue0, pageSize: vPageSize, upper: vUpper} = vAdjustment;\n    const {value: hValue0, pageSize: hPageSize, upper: hUpper} = hAdjustment;\n    let [hValue, vValue] = [hValue0, vValue0];\n    let vOffset = 0;\n    let hOffset = 0;\n\n    const fade = scrollView.get_effect('fade');\n    if (fade) {\n        vOffset = fade.fade_margins.top;\n        hOffset = fade.fade_margins.left;\n    }\n\n    const box = actor.get_allocation_box();\n    let {y1} = box, {y2} = box, {x1} = box, {x2} = box;\n\n    let parent = actor.get_parent();\n    while (parent !== scrollView) {\n        if (!parent)\n            throw new Error('Actor not in scroll view');\n\n        const parentBox = parent.get_allocation_box();\n        y1 += parentBox.y1;\n        y2 += parentBox.y1;\n        x1 += parentBox.x1;\n        x2 += parentBox.x1;\n        parent = parent.get_parent();\n    }\n\n    if (y1 < vValue + vOffset)\n        vValue = Math.max(0, y1 - vOffset);\n    else if (vValue < vUpper - vPageSize && y2 > vValue + vPageSize - vOffset)\n        vValue = Math.min(vUpper - vPageSize, y2 + vOffset - vPageSize);\n\n    if (x1 < hValue + hOffset)\n        hValue = Math.max(0, x1 - hOffset);\n    else if (hValue < hUpper - hPageSize && x2 > hValue + hPageSize - hOffset)\n        hValue = Math.min(hUpper - hPageSize, x2 + hOffset - hPageSize);\n\n    if (vValue !== vValue0) {\n        vAdjustment.ease(vValue, {\n            mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n            duration: Util.SCROLL_TIME,\n        });\n    }\n\n    if (hValue !== hValue0) {\n        hAdjustment.ease(hValue, {\n            mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n            duration: Util.SCROLL_TIME,\n        });\n    }\n\n    return [hValue - hValue0, vValue - vValue0];\n}\n"
        },
        {
          "name": "dbusmenuUtils.js",
          "type": "blob",
          "size": 10.6298828125,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {\n    Atk,\n    Clutter,\n    Gio,\n    GLib,\n    St,\n} from './dependencies/gi.js';\n\nimport {PopupMenu} from './dependencies/shell/ui.js';\n\nimport {Utils} from './imports.js';\n\n// Dbusmenu features not (yet) supported:\n//\n//   * The CHILD_DISPLAY property\n//\n//     This seems to have only one possible value in the Dbusmenu API, so\n//     there's little point in depending on it--the code in libdbusmenu sets it\n//     if and only if an item has children, so for our purposes it's simpler\n//     and more intuitive to just check children.length. (This does ignore the\n//     possibility of a program not using libdbusmenu and setting CHILD_DISPLAY\n//     independently, perhaps to indicate that an childless menu item should\n//     nevertheless be displayed like a submenu.)\n//\n//   * Children more than two levels deep\n//\n//     PopupMenu doesn't seem to support submenus in submenus.\n//\n//   * Shortcut keys\n//\n//     If these keys are supposed to be installed as global shortcuts, we'd\n//     have to query these aggressively and not wait for the DBus menu to be\n//     mapped to a popup menu. A shortcut key that only works once the popup\n//     menu is open and has key focus is possibly of marginal value.\n\n/**\n *\n */\nexport async function haveDBusMenu() {\n    try {\n        const {default: DBusMenu} = await import('gi://Dbusmenu');\n        return DBusMenu;\n    } catch (e) {\n        log(`Failed to import DBusMenu, quicklists are not available: ${e}`);\n        return null;\n    }\n}\n\nconst DBusMenu = await haveDBusMenu();\n\n/**\n * @param dbusmenuItem\n * @param deep\n */\nexport function makePopupMenuItem(dbusmenuItem, deep) {\n    // These are the only properties guaranteed to be available when the root\n    // item is first announced. Other properties might be loaded already, but\n    // be sure to connect to Dbusmenu.MENUITEM_SIGNAL_PROPERTY_CHANGED to get\n    // the most up-to-date values in case they aren't.\n    const itemType = dbusmenuItem.property_get(DBusMenu.MENUITEM_PROP_TYPE);\n    const label = dbusmenuItem.property_get(DBusMenu.MENUITEM_PROP_LABEL);\n    const visible = dbusmenuItem.property_get_bool(DBusMenu.MENUITEM_PROP_VISIBLE);\n    const enabled = dbusmenuItem.property_get_bool(DBusMenu.MENUITEM_PROP_ENABLED);\n    const accessibleDesc = dbusmenuItem.property_get(DBusMenu.MENUITEM_PROP_ACCESSIBLE_DESC);\n    // const childDisplay = dbusmenuItem.property_get(Dbusmenu.MENUITEM_PROP_CHILD_DISPLAY);\n\n    let item;\n    const signalsHandler = new Utils.GlobalSignalsHandler();\n    const wantIcon = itemType === DBusMenu.CLIENT_TYPES_IMAGE;\n\n    // If the basic type of the menu item needs to change, call this.\n    const recreateItem = () => {\n        const newItem = makePopupMenuItem(dbusmenuItem, deep);\n        const parentMenu = item._parent;\n        parentMenu.addMenuItem(newItem);\n        // Reminder: Clutter thinks of later entries in the child list as\n        // \"above\" earlier ones, so \"above\" here means \"below\" in terms of the\n        // menu's vertical order.\n        parentMenu.actor.set_child_above_sibling(newItem.actor, item.actor);\n        if (newItem.menu)\n            parentMenu.actor.set_child_above_sibling(newItem.menu.actor, newItem.actor);\n\n        parentMenu.actor.remove_child(item.actor);\n        item.destroy();\n        item = null;\n    };\n\n    const updateDisposition = () => {\n        const disposition = dbusmenuItem.property_get(DBusMenu.MENUITEM_PROP_DISPOSITION);\n        let iconName = null;\n        switch (disposition) {\n        case DBusMenu.MENUITEM_DISPOSITION_ALERT:\n        case DBusMenu.MENUITEM_DISPOSITION_WARNING:\n            iconName = 'dialog-warning-symbolic';\n            break;\n        case DBusMenu.MENUITEM_DISPOSITION_INFORMATIVE:\n            iconName = 'dialog-information-symbolic';\n            break;\n        }\n        if (iconName) {\n            item._dispositionIcon = new St.Icon({\n                icon_name: iconName,\n                style_class: 'popup-menu-icon',\n                y_align: Clutter.ActorAlign.CENTER,\n                y_expand: true,\n            });\n            let expander;\n            for (let child = item.label.get_next_sibling(); ; child = child.get_next_sibling()) {\n                if (!child) {\n                    expander = new St.Bin({\n                        style_class: 'popup-menu-item-expander',\n                        x_expand: true,\n                    });\n                    item.actor.add_child(expander);\n                    break;\n                } else if (child instanceof St.Widget &&\n                           child.has_style_class_name('popup-menu-item-expander')) {\n                    expander = child;\n                    break;\n                }\n            }\n            item.actor.insert_child_above(item._dispositionIcon, expander);\n        } else if (item._dispositionIcon) {\n            item.actor.remove_child(item._dispositionIcon);\n            item._dispositionIcon = null;\n        }\n    };\n\n    const updateIcon = () => {\n        if (!wantIcon)\n            return;\n\n        const iconData = dbusmenuItem.property_get_byte_array(DBusMenu.MENUITEM_PROP_ICON_DATA);\n        const iconName = dbusmenuItem.property_get(DBusMenu.MENUITEM_PROP_ICON_NAME);\n        if (iconName)\n            item.icon.icon_name = iconName;\n        else if (iconData.length)\n            item.icon.gicon = Gio.BytesIcon.new(iconData);\n    };\n\n    const updateOrnament = () => {\n        const toggleType = dbusmenuItem.property_get(DBusMenu.MENUITEM_PROP_TOGGLE_TYPE);\n        switch (toggleType) {\n        case DBusMenu.MENUITEM_TOGGLE_CHECK:\n            item.actor.accessible_role = Atk.Role.CHECK_MENU_ITEM;\n            break;\n        case DBusMenu.MENUITEM_TOGGLE_RADIO:\n            item.actor.accessible_role = Atk.Role.RADIO_MENU_ITEM;\n            break;\n        default:\n            item.actor.accessible_role = Atk.Role.MENU_ITEM;\n        }\n        let ornament = PopupMenu.Ornament.NONE;\n        const state = dbusmenuItem.property_get_int(DBusMenu.MENUITEM_PROP_TOGGLE_STATE);\n        if (state === DBusMenu.MENUITEM_TOGGLE_STATE_UNKNOWN) {\n            // PopupMenu doesn't natively support an \"unknown\" ornament, but we\n            // can hack one in:\n            item.setOrnament(ornament);\n            item.actor.add_accessible_state(Atk.StateType.INDETERMINATE);\n            item._ornamentLabel.text = '\\u2501';\n            item.actor.remove_style_pseudo_class('checked');\n        } else {\n            item.actor.remove_accessible_state(Atk.StateType.INDETERMINATE);\n            if (state === DBusMenu.MENUITEM_TOGGLE_STATE_CHECKED) {\n                if (toggleType === DBusMenu.MENUITEM_TOGGLE_CHECK)\n                    ornament = PopupMenu.Ornament.CHECK;\n                else if (toggleType === DBusMenu.MENUITEM_TOGGLE_RADIO)\n                    ornament = PopupMenu.Ornament.DOT;\n\n                item.actor.add_style_pseudo_class('checked');\n            } else {\n                item.actor.remove_style_pseudo_class('checked');\n            }\n            item.setOrnament(ornament);\n        }\n    };\n\n    const onPropertyChanged = (_, name, value) => {\n        // `value` is null when a property is cleared, so handle those cases\n        // with sensible defaults.\n        switch (name) {\n        case DBusMenu.MENUITEM_PROP_TYPE:\n            recreateItem();\n            break;\n        case DBusMenu.MENUITEM_PROP_ENABLED:\n            item.setSensitive(value ? value.unpack() : false);\n            break;\n        case DBusMenu.MENUITEM_PROP_LABEL:\n            item.label.text = value ? value.unpack() : '';\n            break;\n        case DBusMenu.MENUITEM_PROP_VISIBLE:\n            item.actor.visible = value ? value.unpack() : false;\n            break;\n        case DBusMenu.MENUITEM_PROP_DISPOSITION:\n            updateDisposition();\n            break;\n        case DBusMenu.MENUITEM_PROP_ACCESSIBLE_DESC:\n            item.actor.get_accessible().accessible_description = value && value.unpack() || '';\n            break;\n        case DBusMenu.MENUITEM_PROP_ICON_DATA:\n        case DBusMenu.MENUITEM_PROP_ICON_NAME:\n            updateIcon();\n            break;\n        case DBusMenu.MENUITEM_PROP_TOGGLE_TYPE:\n        case DBusMenu.MENUITEM_PROP_TOGGLE_STATE:\n            updateOrnament();\n            break;\n        }\n    };\n\n\n    // Start actually building the menu item.\n    const children = dbusmenuItem.get_children();\n    if (children.length && !deep) {\n        // Make a submenu.\n        item = new PopupMenu.PopupSubMenuMenuItem(label, wantIcon);\n        const updateChildren = () => {\n            const itemChildren = dbusmenuItem.get_children();\n            if (!itemChildren.length) {\n                recreateItem();\n                return;\n            }\n\n            item.menu.removeAll();\n            itemChildren.forEach(remoteChild =>\n                item.menu.addMenuItem(makePopupMenuItem(remoteChild, true)));\n        };\n        updateChildren();\n        signalsHandler.add(\n            [dbusmenuItem, DBusMenu.MENUITEM_SIGNAL_CHILD_ADDED, updateChildren],\n            [dbusmenuItem, DBusMenu.MENUITEM_SIGNAL_CHILD_MOVED, updateChildren],\n            [dbusmenuItem, DBusMenu.MENUITEM_SIGNAL_CHILD_REMOVED, updateChildren]);\n    } else {\n        // Don't make a submenu.\n        if (!deep) {\n            // We only have the potential to get a submenu if we aren't deep.\n            signalsHandler.add(\n                [dbusmenuItem, DBusMenu.MENUITEM_SIGNAL_CHILD_ADDED, recreateItem],\n                [dbusmenuItem, DBusMenu.MENUITEM_SIGNAL_CHILD_MOVED, recreateItem],\n                [dbusmenuItem, DBusMenu.MENUITEM_SIGNAL_CHILD_REMOVED, recreateItem]);\n        }\n\n        if (itemType === DBusMenu.CLIENT_TYPES_SEPARATOR) {\n            item = new PopupMenu.PopupSeparatorMenuItem();\n        } else if (wantIcon) {\n            item = new PopupMenu.PopupImageMenuItem(label, null);\n            item.icon = item._icon;\n        } else {\n            item = new PopupMenu.PopupMenuItem(label);\n        }\n    }\n\n    // Set common initial properties.\n    item.actor.visible = visible;\n    item.setSensitive(enabled);\n    if (accessibleDesc)\n        item.actor.get_accessible().accessible_description = accessibleDesc;\n\n    updateDisposition();\n    updateIcon();\n    updateOrnament();\n\n    // Prevent an initial resize flicker.\n    if (wantIcon)\n        item.icon.icon_size = 16;\n\n\n    signalsHandler.add(dbusmenuItem, DBusMenu.MENUITEM_SIGNAL_PROPERTY_CHANGED, onPropertyChanged);\n\n    // Connections on item will be lost when item is disposed; there's no need\n    // to add them to signalsHandler.\n    item.connect('activate', () =>\n        dbusmenuItem.handle_event(DBusMenu.MENUITEM_EVENT_ACTIVATED,\n            new GLib.Variant('i', 0), Math.floor(Date.now() / 1000)));\n    item.connect('destroy', () => signalsHandler.destroy());\n\n    return item;\n}\n"
        },
        {
          "name": "default.nix",
          "type": "blob",
          "size": 0.1162109375,
          "content": "with import <nixpkgs> {};\nstdenv.mkDerivation {\n    name = \"dash-to-dock\";\n    buildInputs = [ gnumake glib sassc ];\n}\n"
        },
        {
          "name": "dependencies",
          "type": "tree",
          "content": null
        },
        {
          "name": "desktopIconsIntegration.js",
          "type": "blob",
          "size": 6.388671875,
          "content": "/*\n * The code in this file is distributed under a \"1-clause BSD license\",\n * which makes it compatible with GPLv2 and GPLv3 too, and others.\n *\n * License text:\n *\n * Copyright (C) 2021 Sergio Costas (rastersoft@gmail.com)\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Integration class\n *\n * This class must be added to other extensions in order to integrate\n * them with Desktop Icons NG. It allows an extension to notify how much margin\n * it uses in each side of each monitor.\n *\n * DON'T SEND PATCHES TO THIS FILE TO THE EXTENSION MAINTAINER. SEND THEM TO\n * DESKTOP ICONS NG MAINTAINER: https://gitlab.com/rastersoft/desktop-icons-ng\n *\n * In the *enable()* function, create a *DesktopIconsUsableAreaClass()*\n * object with\n *\n *     new DesktopIconsIntegration.DesktopIconsUsableAreaClass(object);\n *\n * Now, in the *disable()* function just call to the *destroy()* method before\n * nullifying the pointer. You must create a new object in enable() the next\n * time the extension is enabled.\n *\n * In your code, every time you change the margins, you should call first to\n * *resetMargins()* method to clear the current margins, and then call to\n * *setMargins(...)* method as many times as you need to set the margins in each\n * monitor. You don't need to call it for all the monitors, only for those where\n * you are painting something. If you don't set values for a monitor, they will\n * be considered zero.\n *\n * The margins values are relative to the monitor border.\n *\n *******************************************************************************/\n\nimport GLib from 'gi://GLib';\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as ExtensionUtils from 'resource:///org/gnome/shell/misc/extensionUtils.js';\nimport {Extension} from 'resource:///org/gnome/shell/extensions/extension.js';\n\nconst IDENTIFIER_UUID = '130cbc66-235c-4bd6-8571-98d2d8bba5e2';\n\nexport class DesktopIconsUsableAreaClass {\n    _checkIfExtensionIsEnabled(extension) {\n        return (extension?.state === ExtensionUtils.ExtensionState.ENABLED) ||\n               (extension?.state === ExtensionUtils.ExtensionState.ACTIVE);\n    }\n\n    constructor() {\n        const Me = Extension.lookupByURL(import.meta.url);\n        this._UUID = Me.uuid;\n        this._extensionManager = Main.extensionManager;\n        this._timedMarginsID = 0;\n        this._margins = {};\n        this._emID = this._extensionManager.connect('extension-state-changed', (_obj, extension) => {\n            if (!extension)\n                return;\n\n            // If an extension is being enabled and lacks the\n            // DesktopIconsUsableArea object, we can avoid launching a refresh\n            if (this._checkIfExtensionIsEnabled(extension)) {\n                this._sendMarginsToExtension(extension);\n                return;\n            }\n            // if the extension is being disabled, we must do a full refresh,\n            // because if there were other extensions originally\n            // loaded after that extension, those extensions will be disabled\n            // and enabled again without notification\n            this._changedMargins();\n        });\n    }\n\n    /**\n     * Sets or updates the top, bottom, left and right margins for a\n     * monitor. Values are measured from the monitor border (and NOT from\n     * the workspace border).\n     *\n     * @param {int} monitor Monitor number to which set the margins.\n     *                      A negative value means \"the primary monitor\".\n     * @param {int} top Top margin in pixels\n     * @param {int} bottom Bottom margin in pixels\n     * @param {int} left Left margin in pixels\n     * @param {int} right Right margin in pixels\n     */\n    setMargins(monitor, top, bottom, left, right) {\n        this._margins[monitor] = {\n            top,\n            bottom,\n            left,\n            right,\n        };\n        this._changedMargins();\n    }\n\n    /**\n     * Clears the current margins. Must be called before configuring the monitors\n     * margins with setMargins().\n     */\n    resetMargins() {\n        this._margins = {};\n        this._changedMargins();\n    }\n\n    /**\n     * Disconnects all the signals and removes the margins.\n     */\n    destroy() {\n        if (this._emID) {\n            this._extensionManager.disconnect(this._emID);\n            this._emID = 0;\n        }\n        if (this._timedMarginsID) {\n            GLib.source_remove(this._timedMarginsID);\n            this._timedMarginsID = 0;\n        }\n        this._margins = null;\n        this._changedMargins();\n    }\n\n    _changedMargins() {\n        if (this._timedMarginsID)\n            GLib.source_remove(this._timedMarginsID);\n\n        this._timedMarginsID = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, () => {\n            this._sendMarginsToAll();\n            this._timedMarginsID = 0;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    _sendMarginsToAll() {\n        this._extensionManager.getUuids().forEach(uuid =>\n            this._sendMarginsToExtension(this._extensionManager.lookup(uuid)));\n    }\n\n    _sendMarginsToExtension(extension) {\n        // check that the extension is an extension that has the logic to accept\n        // working margins\n        if (!this._checkIfExtensionIsEnabled(extension))\n            return;\n\n        const usableArea = extension?.stateObj?.DesktopIconsUsableArea;\n        if (usableArea?.uuid === IDENTIFIER_UUID) {\n            usableArea.setMarginsForExtension(\n                this._UUID, this._margins);\n        }\n    }\n}\n"
        },
        {
          "name": "docking.js",
          "type": "blob",
          "size": 95.2490234375,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {\n    Clutter,\n    GLib,\n    Gio,\n    GObject,\n    Meta,\n    Shell,\n    St,\n} from './dependencies/gi.js';\n\nimport {\n    AppMenu,\n    AppDisplay,\n    Layout,\n    Main,\n    OverviewControls,\n    PointerWatcher,\n    Workspace,\n    WorkspacesView,\n    WorkspaceSwitcherPopup,\n} from './dependencies/shell/ui.js';\n\nimport {\n    AnimationUtils,\n} from './dependencies/shell/misc.js';\n\nimport {\n    AppIconsDecorator,\n    AppSpread,\n    DockDash,\n    DesktopIconsIntegration,\n    FileManager1API,\n    Intellihide,\n    LauncherAPI,\n    Locations,\n    NotificationsMonitor,\n    Theming,\n    Utils,\n} from './imports.js';\n\nconst {signals: Signals} = imports;\n\nconst DOCK_DWELL_CHECK_INTERVAL = 100;\nconst ICON_ANIMATOR_DURATION = 3000;\nconst STARTUP_ANIMATION_TIME = 500;\n\nexport const State = Object.freeze({\n    HIDDEN:  0,\n    SHOWING: 1,\n    SHOWN:   2,\n    HIDING:  3,\n});\n\nconst scrollAction = Object.freeze({\n    DO_NOTHING: 0,\n    CYCLE_WINDOWS: 1,\n    SWITCH_WORKSPACE: 2,\n});\n\nconst Labels = Object.freeze({\n    INITIALIZE: Symbol('initialize'),\n    ISOLATION: Symbol('isolation'),\n    LOCATIONS: Symbol('locations'),\n    MAIN_DASH: Symbol('main-dash'),\n    OLD_DASH_CHANGES: Symbol('old-dash-changes'),\n    SETTINGS: Symbol('settings'),\n    STARTUP_ANIMATION: Symbol('startup-animation'),\n    WORKSPACE_SWITCH_SCROLL: Symbol('workspace-switch-scroll'),\n});\n\n/**\n * A simple St.Widget with one child whose allocation takes into account the\n * slide out of its child via the slide-x property ([0:1]).\n *\n * Required since I want to track the input region of this container which is\n * based on its allocation even if the child overflows the parent actor. By doing\n * this the region of the dash that is slide-out is not stealing anymore the input\n * regions making the extension usable when the primary monitor is the right one.\n *\n * The slide-x parameter can be used to directly animate the sliding. The parent\n * must have a WEST (SOUTH) anchor_point to achieve the sliding to the RIGHT (BOTTOM)\n * side.\n */\nconst DashSlideContainer = GObject.registerClass({\n    Properties: {\n        'monitor-index': GObject.ParamSpec.uint(\n            'monitor-index', 'monitor-index', 'monitor-index',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            0, GLib.MAXUINT32, 0),\n        'side': GObject.ParamSpec.enum(\n            'side', 'side', 'side',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            St.Side, St.Side.LEFT),\n        'slide-x': GObject.ParamSpec.double(\n            'slide-x', 'slide-x', 'slide-x',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT,\n            0, 1, 1),\n    },\n}, class DashSlideContainer extends St.Bin {\n    _init(params = {}) {\n        super._init(params);\n\n        this._slideoutSize = 0; // minimum size when slided out\n        this.connect('notify::slide-x', () => this.queue_relayout());\n\n        if (this.side === St.Side.TOP && DockManager.settings.dockFixed) {\n            this._signalsHandler = new Utils.GlobalSignalsHandler(this);\n            this._signalsHandler.add(Main.panel, 'notify::height',\n                () => this.queue_relayout());\n        }\n    }\n\n    vfunc_allocate(box) {\n        const contentBox = this.get_theme_node().get_content_box(box);\n\n        this.set_allocation(box);\n\n        if (!this.child)\n            return;\n\n        const availWidth = contentBox.x2 - contentBox.x1;\n        let availHeight = contentBox.y2 - contentBox.y1;\n        const [, , natChildWidth, natChildHeight] =\n            this.child.get_preferred_size();\n\n        const childWidth = natChildWidth;\n        const childHeight = natChildHeight;\n\n        const childBox = new Clutter.ActorBox();\n\n        const slideoutSize = this._slideoutSize;\n\n        if (this.side === St.Side.LEFT) {\n            childBox.x1 = (this.slideX - 1) * (childWidth - slideoutSize);\n            childBox.x2 = slideoutSize + this.slideX * (childWidth - slideoutSize);\n            childBox.y1 = 0;\n            childBox.y2 = childBox.y1 + childHeight;\n        } else if ((this.side === St.Side.RIGHT) || (this.side === St.Side.BOTTOM)) {\n            childBox.x1 = 0;\n            childBox.x2 = childWidth;\n            childBox.y1 = 0;\n            childBox.y2 = childBox.y1 + childHeight;\n        } else if (this.side === St.Side.TOP) {\n            const monitor = Main.layoutManager.monitors[this.monitorIndex];\n            let yOffset = 0;\n            if (Main.panel.x === monitor.x && Main.panel.y === monitor.y &&\n                DockManager.settings.dockFixed)\n                yOffset = Main.panel.height;\n            childBox.x1 = 0;\n            childBox.x2 = childWidth;\n            childBox.y1 = (this.slideX - 1) * (childHeight - slideoutSize) + yOffset;\n            childBox.y2 = slideoutSize + this.slideX * (childHeight - slideoutSize) + yOffset;\n            availHeight += yOffset;\n        }\n\n        this.child.allocate(childBox);\n\n        this.child.set_clip(-childBox.x1, -childBox.y1,\n            -childBox.x1 + availWidth, -childBox.y1 + availHeight);\n    }\n\n    /**\n     * Just the child width but taking into account the slided out part\n     *\n     * @param forHeight\n     */\n    vfunc_get_preferred_width(forHeight) {\n        let [minWidth, natWidth] = super.vfunc_get_preferred_width(forHeight || 0);\n        if ((this.side ===  St.Side.LEFT) || (this.side === St.Side.RIGHT)) {\n            minWidth = (minWidth - this._slideoutSize) * this.slideX + this._slideoutSize;\n            natWidth = (natWidth - this._slideoutSize) * this.slideX + this._slideoutSize;\n        }\n        return [minWidth, natWidth];\n    }\n\n    /**\n     * Just the child height but taking into account the slided out part\n     *\n     * @param forWidth\n     */\n    vfunc_get_preferred_height(forWidth) {\n        let [minHeight, natHeight] = super.vfunc_get_preferred_height(forWidth || 0);\n        if ((this.side ===  St.Side.TOP) || (this.side ===  St.Side.BOTTOM)) {\n            minHeight = (minHeight - this._slideoutSize) * this.slideX + this._slideoutSize;\n            natHeight = (natHeight - this._slideoutSize) * this.slideX + this._slideoutSize;\n\n            if (this.side === St.Side.TOP && DockManager.settings.dockFixed) {\n                const monitor = Main.layoutManager.monitors[this.monitorIndex];\n                if (Main.panel.x === monitor.x && Main.panel.y === monitor.y) {\n                    minHeight += Main.panel.height;\n                    natHeight += Main.panel.height;\n                }\n            }\n        }\n        return [minHeight, natHeight];\n    }\n});\n\nconst DockedDash = GObject.registerClass({\n    Properties: {\n        'is-main': GObject.ParamSpec.boolean(\n            'is-main', 'is-main', 'is-main',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            false),\n        'monitor-index': GObject.ParamSpec.uint(\n            'monitor-index', 'monitor-index', 'monitor-index',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            0, GLib.MAXUINT32, 0),\n    },\n    Signals: {\n        'showing': {},\n        'hiding': {},\n    },\n}, class DashToDock extends St.Bin {\n    _init(params) {\n        this._position = Utils.getPosition();\n\n        // This is the centering actor\n        super._init({\n            ...params,\n            name: 'dashtodockContainer',\n            reactive: false,\n            style_class: Theming.PositionStyleClass[this._position],\n        });\n\n        if (this.monitorIndex === undefined) {\n            // Hello turkish locale, gjs has instead defined this.monitorIndex\n            // See: https://gitlab.gnome.org/GNOME/gjs/-/merge_requests/742\n            this.monitorIndex = this.monitor_index;\n        }\n\n        this._rtl = Clutter.get_default_text_direction() === Clutter.TextDirection.RTL;\n\n        // Load settings\n        const {settings} = DockManager;\n        this._isHorizontal = (this._position === St.Side.TOP) || (this._position === St.Side.BOTTOM);\n\n        // Temporary ignore hover events linked to autohide for whatever reason\n        this._ignoreHover = false;\n        this._oldIgnoreHover = null;\n        // This variables are linked to the settings regardles of autohide or intellihide\n        // being temporary disable. Get set by _updateVisibilityMode;\n        this._autohideIsEnabled = null;\n        this._intellihideIsEnabled = null;\n\n        // This variable marks if Meta.disable_unredirect_for_display() is called\n        // to help restore the original state when intelihide is disabled.\n        this._unredirectDisabled = false;\n\n        // Create intellihide object to monitor windows overlapping\n        this._intellihide = new Intellihide.Intellihide(this.monitorIndex);\n\n        // initialize dock state\n        this._dockState = State.HIDDEN;\n\n        // Put dock on the required monitor\n        this._monitor = Main.layoutManager.monitors[this.monitorIndex];\n\n        // this store size and the position where the dash is shown;\n        // used by intellihide module to check window overlap.\n        this.staticBox = new Clutter.ActorBox();\n\n        // Initialize pressure barrier variables\n        this._canUsePressure = false;\n        this._pressureBarrier = null;\n        this._barrier = null;\n        this._removeBarrierTimeoutId = 0;\n\n        // Initialize dwelling system variables\n        this._dockDwelling = false;\n        this._dockWatch = null;\n        this._dockDwellUserTime = 0;\n        this._dockDwellTimeoutId = 0;\n\n        // Create a new dash object\n        this.dash = new DockDash.DockDash(this.monitorIndex);\n\n        if (Main.overview.isDummy || !settings.showShowAppsButton)\n            this.dash.hideShowAppsButton();\n\n        // Create the containers for sliding in and out and\n        // centering, turn on track hover\n        // This is the sliding actor whose allocation is to be tracked for input regions\n        this._slider = new DashSlideContainer({\n            monitor_index: this._monitor.index,\n            side: this._position,\n            slide_x: Main.layoutManager._startingUp ? 0 : 1,\n            ...this._isHorizontal ? {\n                x_align: Clutter.ActorAlign.CENTER,\n            } : {\n                y_align: Clutter.ActorAlign.CENTER,\n            },\n        });\n\n        // This is the actor whose hover status us tracked for autohide\n        this._box = new St.BoxLayout({\n            name: 'dashtodockBox',\n            reactive: true,\n            track_hover: true,\n        });\n        this._box.connect('notify::hover', this._hoverChanged.bind(this));\n\n        // Connect global signals\n        this._signalsHandler = new Utils.GlobalSignalsHandler(this);\n        this._bindSettingsChanges();\n        this._signalsHandler.add([\n            // update when workarea changes, for instance if  other extensions modify the struts\n            // (like moving th panel at the bottom)\n            global.display,\n            'workareas-changed',\n            this._resetPosition.bind(this),\n        ], [\n            global.display,\n            'in-fullscreen-changed',\n            this._updateBarrier.bind(this),\n        ], [\n            // Monitor windows overlapping\n            this._intellihide,\n            'status-changed',\n            this._updateDashVisibility.bind(this),\n        ], [\n            this.dash,\n            'menu-opened',\n            () => {\n                this._onMenuOpened();\n            },\n        ], [\n            // sync hover after a popupmenu is closed\n            this.dash,\n            'menu-closed',\n            () => {\n                this._onMenuClosed();\n            },\n        ], [\n            this.dash,\n            'notify::requires-visibility',\n            () => this._updateDashVisibility(),\n        ]);\n\n        if (!Main.overview.isDummy) {\n            this._signalsHandler.add([\n                Main.overview,\n                'item-drag-begin',\n                this._onDragStart.bind(this),\n            ], [\n                Main.overview,\n                'item-drag-end',\n                this._onDragEnd.bind(this),\n            ], [\n                Main.overview,\n                'item-drag-cancelled',\n                this._onDragEnd.bind(this),\n            ], [\n                Main.overview,\n                'showing',\n                this._onOverviewShowing.bind(this),\n            ], [\n                Main.overview,\n                'hiding',\n                this._onOverviewHiding.bind(this),\n            ],\n            [\n                Main.overview,\n                'hidden',\n                this._onOverviewHidden.bind(this),\n            ]);\n        }\n\n        this._themeManager = new Theming.ThemeManager(this);\n        this._signalsHandler.add(this._themeManager, 'updated',\n            () => this.dash.resetAppIcons());\n\n        this._signalsHandler.add(DockManager.iconTheme, 'changed',\n            () => this.dash.resetAppIcons());\n\n        // Since the actor is not a topLevel child and its parent is now not added to the Chrome,\n        // the allocation change of the parent container (slide in and slideout) doesn't trigger\n        // anymore an update of the input regions. Force the update manually.\n        this.connect('notify::allocation',\n            Main.layoutManager._queueUpdateRegions.bind(Main.layoutManager));\n\n\n        // Since Clutter has no longer ClutterAllocationFlags,\n        // \"allocation-changed\" signal has been removed. MR !1245\n        this.dash._container.connect('notify::allocation', this._updateStaticBox.bind(this));\n        this._slider.connect(this._isHorizontal ? 'notify::x' : 'notify::y',\n            this._updateStaticBox.bind(this));\n\n        // Load optional features that need to be activated for one dock only\n        if (this.isMain)\n            this._enableExtraFeatures();\n        // Load optional features that need to be activated once per dock\n        this._optionalScrollWorkspaceSwitch();\n\n        // Delay operations that require the shell to be fully loaded and with\n        // user theme applied.\n\n        this._signalsHandler.addWithLabel(Labels.INITIALIZE, global.stage,\n            'after-paint', () => this._initialize());\n\n        // Add dash container actor and the container to the Chrome.\n        this.set_child(this._slider);\n        this._slider.set_child(this._box);\n        this._box.add_child(this.dash);\n\n        // Add aligning container without tracking it for input region\n        this._trackDock();\n\n        // Create and apply height/width constraint to the dash.\n        if (this._isHorizontal) {\n            this.connect('notify::width', () => {\n                this.dash.setMaxSize(this.width, this.height);\n            });\n        } else {\n            this.connect('notify::height', () => {\n                this.dash.setMaxSize(this.width, this.height);\n            });\n        }\n\n        if (this._position === St.Side.RIGHT) {\n            this.connect('notify::width', () =>\n                (this.translation_x = -this.width));\n        } else if (this._position === St.Side.BOTTOM) {\n            this.connect('notify::height', () =>\n                (this.translation_y = -this.height));\n        }\n\n        // Set initial position\n        this._resetPosition();\n\n        this.connect('destroy', this._onDestroy.bind(this));\n    }\n\n    get position() {\n        return this._position;\n    }\n\n    get isHorizontal() {\n        return this._isHorizontal;\n    }\n\n    _untrackDock() {\n        Main.layoutManager.untrackChrome(this);\n    }\n\n    _trackDock() {\n        if (DockManager.settings.dockFixed) {\n            Main.layoutManager.addChrome(this, {\n                trackFullscreen: true,\n                affectsStruts: true,\n            });\n        } else {\n            Main.layoutManager.addChrome(this);\n        }\n    }\n\n    _initialize() {\n        this._signalsHandler.removeWithLabel(Labels.INITIALIZE);\n\n        // Apply custom css class according to the settings\n        this._themeManager.updateCustomTheme();\n\n        this._updateVisibilityMode();\n\n        // In case we are already inside the overview when the extension is loaded,\n        // for instance on unlocking the screen if it was locked with the overview open.\n        if (Main.overview.visibleTarget)\n            this._onOverviewShowing();\n\n        this._updateAutoHideBarriers();\n    }\n\n    _onDestroy() {\n        // The dash, intellihide and themeManager have global signals as well internally\n        this.dash.destroy();\n        this._intellihide.destroy();\n        this._themeManager.destroy();\n\n        if (this._marginLater) {\n            Utils.laterRemove(this._marginLater);\n            delete this._marginLater;\n        }\n\n        if (this._triggerTimeoutId)\n            GLib.source_remove(this._triggerTimeoutId);\n\n        this._restoreUnredirect();\n\n        // Remove barrier timeout\n        if (this._removeBarrierTimeoutId > 0)\n            GLib.source_remove(this._removeBarrierTimeoutId);\n\n        // Remove existing barrier\n        this._removeBarrier();\n\n        // Remove pointer watcher\n        if (this._dockWatch) {\n            PointerWatcher.getPointerWatcher()._removeWatch(this._dockWatch);\n            this._dockWatch = null;\n        }\n    }\n\n    _updateAutoHideBarriers() {\n        // Remove pointer watcher\n        if (this._dockWatch) {\n            PointerWatcher.getPointerWatcher()._removeWatch(this._dockWatch);\n            this._dockWatch = null;\n        }\n\n        // Setup pressure barrier (GS38+ only)\n        this._updatePressureBarrier();\n        this._updateBarrier();\n\n        // setup dwelling system if pressure barriers are not available\n        this._setupDockDwellIfNeeded();\n    }\n\n    _bindSettingsChanges() {\n        const {settings} = DockManager;\n        this._signalsHandler.add([\n            settings,\n            'changed::scroll-action',\n            () => {\n                this._optionalScrollWorkspaceSwitch();\n            },\n        ], [\n            settings,\n            'changed::dash-max-icon-size',\n            () => {\n                this.dash.setIconSize(settings.dashMaxIconSize);\n            },\n        ], [\n            settings,\n            'changed::icon-size-fixed',\n            () => {\n                this.dash.setIconSize(settings.dashMaxIconSize);\n            },\n        ], [\n            settings,\n            'changed::show-favorites',\n            () => {\n                this.dash.resetAppIcons();\n            },\n        ], [\n            settings,\n            'changed::show-trash',\n            () => {\n                this.dash.resetAppIcons();\n            },\n            Utils.SignalsHandlerFlags.CONNECT_AFTER,\n        ], [\n            settings,\n            'changed::show-mounts',\n            () => {\n                this.dash.resetAppIcons();\n            },\n            Utils.SignalsHandlerFlags.CONNECT_AFTER,\n        ], [\n            settings,\n            'changed::isolate-locations',\n            () => this.dash.resetAppIcons(),\n            Utils.SignalsHandlerFlags.CONNECT_AFTER,\n        ], [\n            settings,\n            'changed::dance-urgent-applications',\n            () => this.dash.resetAppIcons(),\n            Utils.SignalsHandlerFlags.CONNECT_AFTER,\n        ], [\n            settings,\n            'changed::show-running',\n            () => {\n                this.dash.resetAppIcons();\n            },\n        ], [\n            settings,\n            'changed::show-apps-always-in-the-edge',\n            () => {\n                this.dash.updateShowAppsButton();\n            },\n        ], [\n            settings,\n            'changed::show-apps-at-top',\n            () => {\n                this.dash.updateShowAppsButton();\n            },\n        ], [\n            settings,\n            'changed::show-show-apps-button',\n            () => {\n                if (!Main.overview.isDummy &&\n                        settings.showShowAppsButton)\n                    this.dash.showShowAppsButton();\n                else\n                    this.dash.hideShowAppsButton();\n            },\n        ], [\n            settings,\n            'changed::dock-fixed',\n            () => {\n                this._untrackDock();\n                this._trackDock();\n\n                this._resetPosition();\n                this._updateAutoHideBarriers();\n                this._updateVisibilityMode();\n            },\n        ], [\n            settings,\n            'changed::manualhide',\n            () => {\n                this._updateVisibilityMode();\n            },\n        ], [\n            settings,\n            'changed::intellihide',\n            () => {\n                this._updateVisibilityMode();\n                this._updateVisibleDesktop();\n            },\n        ], [\n            settings,\n            'changed::intellihide-mode',\n            () => {\n                this._intellihide.forceUpdate();\n            },\n        ], [\n            settings,\n            'changed::autohide',\n            () => {\n                this._updateVisibilityMode();\n                this._updateAutoHideBarriers();\n            },\n        ], [\n            settings,\n            'changed::autohide-in-fullscreen',\n            this._updateBarrier.bind(this),\n        ], [\n            settings,\n            'changed::show-dock-urgent-notify',\n            () => {\n                this.dash.resetAppIcons();\n            },\n        ],\n        [\n            settings,\n            'changed::extend-height',\n            this._resetPosition.bind(this),\n        ], [\n            settings,\n            'changed::height-fraction',\n            this._resetPosition.bind(this),\n        ], [\n            settings,\n            'changed::always-center-icons',\n            () => this.dash.resetAppIcons(),\n        ], [\n            settings,\n            'changed::require-pressure-to-show',\n            () => this._updateAutoHideBarriers(),\n        ], [\n            settings,\n            'changed::pressure-threshold',\n            () => {\n                this._updatePressureBarrier();\n                this._updateBarrier();\n            },\n        ]);\n    }\n\n    _restoreUnredirect() {\n        if (this._unredirectDisabled) {\n            Meta.enable_unredirect_for_display(global.display);\n            this._unredirectDisabled = false;\n        }\n    }\n\n    /**\n     * This is call when visibility settings change\n     */\n    _updateVisibilityMode() {\n        const {settings} = DockManager;\n        if (DockManager.settings.dockFixed || DockManager.settings.manualhide) {\n            this._autohideIsEnabled = false;\n            this._intellihideIsEnabled = false;\n        } else {\n            this._autohideIsEnabled = settings.autohide;\n            this._intellihideIsEnabled = settings.intellihide;\n        }\n\n        if (this._autohideIsEnabled)\n            this.add_style_class_name('autohide');\n        else\n            this.remove_style_class_name('autohide');\n\n        if (this._intellihideIsEnabled) {\n            this._intellihide.enable();\n        } else {\n            this._intellihide.disable();\n            this._restoreUnredirect();\n        }\n\n        this._updateDashVisibility();\n    }\n\n    /**\n     * Show/hide dash based on, in order of priority:\n     * overview visibility\n     * fixed mode\n     * intellihide\n     * autohide\n     * overview visibility\n     */\n    _updateDashVisibility() {\n        if (DockManager.settings.manualhide) {\n            this._ignoreHover = true;\n            this._removeAnimations();\n            this._animateOut(0, 0);\n            return;\n        }\n\n        if (Main.overview.visibleTarget)\n            return;\n\n        const {settings} = DockManager;\n\n        if (DockManager.settings.dockFixed) {\n            this._removeAnimations();\n            this._animateIn(settings.animationTime, 0);\n        } else if (this._intellihideIsEnabled) {\n            if (!this.dash.requiresVisibility && this._intellihide.getOverlapStatus()) {\n                this._ignoreHover = false;\n                // Do not hide if autohide is enabled and mouse is hover\n                if (!this._box.hover || !this._autohideIsEnabled)\n                    this._animateOut(settings.animationTime, 0);\n            } else {\n                this._ignoreHover = true;\n                this._removeAnimations();\n                this._animateIn(settings.animationTime, 0);\n            }\n        } else if (this._autohideIsEnabled) {\n            this._ignoreHover = false;\n\n            if (this._box.hover || this.dash.requiresVisibility)\n                this._animateIn(settings.animationTime, 0);\n            else\n                this._animateOut(settings.animationTime, 0);\n        } else {\n            this._animateOut(settings.animationTime, 0);\n        }\n    }\n\n    _onOverviewShowing() {\n        this.add_style_class_name('overview');\n\n        this._ignoreHover = true;\n        this._intellihide.disable();\n        this._removeAnimations();\n        this._animateIn(DockManager.settings.animationTime, 0);\n    }\n\n    _onOverviewHiding() {\n        this._intellihide.enable();\n        this._updateDashVisibility();\n    }\n\n    _onOverviewHidden() {\n        this.remove_style_class_name('overview');\n        this._updateDashVisibility();\n    }\n\n    _onMenuOpened() {\n        this._ignoreHover = true;\n    }\n\n    _onMenuClosed() {\n        this._ignoreHover = false;\n        this._box.sync_hover();\n        this._updateDashVisibility();\n    }\n\n    _hoverChanged() {\n        if (!this._ignoreHover) {\n            // Skip if dock is not in autohide mode for instance because it is shown\n            // by intellihide.\n            if (this._autohideIsEnabled) {\n                if (this._box.hover || Main.overview.visible)\n                    this._show();\n                else\n                    this._hide();\n            }\n        }\n    }\n\n    getDockState() {\n        return this._dockState;\n    }\n\n    _show() {\n        this._delayedHide = false;\n        if ((this._dockState === State.HIDDEN) || (this._dockState === State.HIDING)) {\n            if (this._dockState === State.HIDING)\n                // suppress all potential queued transitions - i.e. added but not started,\n                // always give priority to show\n                this._removeAnimations();\n\n            this.emit('showing');\n            this._animateIn(DockManager.settings.animationTime, 0);\n        }\n    }\n\n    _hide() {\n        // If no hiding animation is running or queued\n        if ((this._dockState === State.SHOWN) || (this._dockState === State.SHOWING)) {\n            const {settings} = DockManager;\n            const delay = settings.hideDelay;\n\n            if (this._dockState === State.SHOWING) {\n                // if a show already started, let it finish; queue hide without removing the show.\n                // to obtain this, we wait for the animateIn animation to be completed\n                this._delayedHide = true;\n                return;\n            }\n\n            this.emit('hiding');\n            this._animateOut(settings.animationTime, delay);\n        }\n    }\n\n    _animateIn(time, delay) {\n        if (!this._unredirectDisabled && this._intellihideIsEnabled) {\n            Meta.disable_unredirect_for_display(global.display);\n            this._unredirectDisabled = true;\n        }\n        this._dockState = State.SHOWING;\n        this.dash.iconAnimator.start();\n        this._delayedHide = false;\n\n        this._slider.ease_property('slide-x', 1, {\n            duration: time * 1000,\n            delay: delay * 1000,\n            mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n            onComplete: () => {\n                this._dockState = State.SHOWN;\n                // Remove barrier so that mouse pointer is released and can\n                // monitors on other side of dock.\n                // NOTE: Delay needed to keep mouse from moving past dock and\n                // re-hiding dock immediately. This gives users an opportunity\n                // to hover over the dock\n                if (this._removeBarrierTimeoutId > 0)\n                    GLib.source_remove(this._removeBarrierTimeoutId);\n\n                if (!this._delayedHide) {\n                    this._removeBarrierTimeoutId = GLib.timeout_add(\n                        GLib.PRIORITY_DEFAULT, 100, this._removeBarrier.bind(this));\n                } else {\n                    this._hide();\n                }\n            },\n        });\n    }\n\n    _animateOut(time, delay) {\n        this._dockState = State.HIDING;\n\n        this._slider.ease_property('slide-x', 0, {\n            duration: time * 1000,\n            delay: delay * 1000,\n            mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n            onComplete: () => {\n                this._dockState = State.HIDDEN;\n                if (this._intellihideIsEnabled && this._unredirectDisabled) {\n                    Meta.enable_unredirect_for_display(global.display);\n                    this._unredirectDisabled = false;\n                }\n                // Remove queued barrier removal timeout if any\n                if (this._removeBarrierTimeoutId > 0)\n                    GLib.source_remove(this._removeBarrierTimeoutId);\n                this._updateBarrier();\n                this.dash.iconAnimator.pause();\n            },\n        });\n    }\n\n    /**\n     * Dwelling system based on the GNOME Shell 3.14 messageTray code.\n     */\n    _setupDockDwellIfNeeded() {\n        // If we don't have extended barrier features, then we need\n        // to support the old tray dwelling mechanism.\n        if (this._autohideIsEnabled &&\n            (!Utils.supportsExtendedBarriers() ||\n             !DockManager.settings.requirePressureToShow)) {\n            const pointerWatcher = PointerWatcher.getPointerWatcher();\n            this._dockWatch = pointerWatcher.addWatch(\n                DOCK_DWELL_CHECK_INTERVAL, this._checkDockDwell.bind(this));\n            this._dockDwelling = false;\n            this._dockDwellUserTime = 0;\n        }\n    }\n\n    _checkDockDwell(x, y) {\n        const workArea = Main.layoutManager.getWorkAreaForMonitor(this._monitor.index);\n        let shouldDwell;\n        // Check for the correct screen edge, extending the sensitive area to the whole workarea,\n        // minus 1 px to avoid conflicting with other active corners.\n        if (this._position === St.Side.LEFT) {\n            shouldDwell = (x === this._monitor.x) && (y > workArea.y) &&\n                (y < workArea.y + workArea.height);\n        } else if (this._position === St.Side.RIGHT) {\n            shouldDwell = (x === this._monitor.x + this._monitor.width - 1) &&\n                (y > workArea.y) && (y < workArea.y + workArea.height);\n        } else if (this._position === St.Side.TOP) {\n            shouldDwell = (y === this._monitor.y) && (x > workArea.x) &&\n                (x < workArea.x + workArea.width);\n        } else if (this._position === St.Side.BOTTOM) {\n            shouldDwell = (y === this._monitor.y + this._monitor.height - 1) &&\n                (x > workArea.x) && (x < workArea.x + workArea.width);\n        }\n\n        if (shouldDwell) {\n            // We only set up dwell timeout when the user is not hovering over the dock\n            // already (!this._box.hover).\n            // The _dockDwelling variable is used so that we only try to\n            // fire off one dock dwell - if it fails (because, say, the user has the mouse down),\n            // we don't try again until the user moves the mouse up and down again.\n            if (!this._dockDwelling && !this._box.hover && (this._dockDwellTimeoutId === 0)) {\n                // Save the interaction timestamp so we can detect user input\n                const focusWindow = global.display.focus_window;\n                this._dockDwellUserTime = focusWindow ? focusWindow.user_time : 0;\n\n                this._dockDwellTimeoutId = GLib.timeout_add(\n                    GLib.PRIORITY_DEFAULT,\n                    DockManager.settings.showDelay * 1000,\n                    this._dockDwellTimeout.bind(this));\n                GLib.Source.set_name_by_id(this._dockDwellTimeoutId,\n                    '[dash-to-dock] this._dockDwellTimeout');\n            }\n            this._dockDwelling = true;\n        } else {\n            this._cancelDockDwell();\n            this._dockDwelling = false;\n        }\n    }\n\n    _cancelDockDwell() {\n        if (this._dockDwellTimeoutId !== 0) {\n            GLib.source_remove(this._dockDwellTimeoutId);\n            this._dockDwellTimeoutId = 0;\n        }\n    }\n\n    _dockDwellTimeout() {\n        this._dockDwellTimeoutId = 0;\n\n        if (!DockManager.settings.autohideInFullscreen &&\n            this._monitor.inFullscreen)\n            return GLib.SOURCE_REMOVE;\n\n        // We don't want to open the tray when a modal dialog\n        // is up, so we check the modal count for that. When we are in the\n        // overview we have to take the overview's modal push into account\n        if (Main.modalCount > (Main.overview.visible ? 1 : 0))\n            return GLib.SOURCE_REMOVE;\n\n        // If the user interacted with the focus window since we started the tray\n        // dwell (by clicking or typing), don't activate the message tray\n        const focusWindow = global.display.focus_window;\n        const currentUserTime = focusWindow ? focusWindow.user_time : 0;\n        if (currentUserTime !== this._dockDwellUserTime)\n            return GLib.SOURCE_REMOVE;\n\n        // Reuse the pressure version function, the logic is the same\n        this._onPressureSensed();\n        return GLib.SOURCE_REMOVE;\n    }\n\n    _updatePressureBarrier() {\n        const {settings} = DockManager;\n        this._canUsePressure = Utils.supportsExtendedBarriers();\n        const {pressureThreshold} = settings;\n\n        // Remove existing pressure barrier\n        if (this._pressureBarrier) {\n            this._pressureBarrier.destroy();\n            this._pressureBarrier = null;\n        }\n\n        if (this._barrier) {\n            this._barrier.destroy();\n            this._barrier = null;\n        }\n\n        // Create new pressure barrier based on pressure threshold setting\n        if (this._canUsePressure && this._autohideIsEnabled &&\n            DockManager.settings.requirePressureToShow) {\n            this._pressureBarrier = new Layout.PressureBarrier(\n                pressureThreshold, settings.showDelay * 1000,\n                Shell.ActionMode.NORMAL | Shell.ActionMode.OVERVIEW);\n            this._pressureBarrier.connect('trigger', _barrier => {\n                if (!settings.autohideInFullscreen && this._monitor.inFullscreen)\n                    return;\n                this._onPressureSensed();\n            });\n        }\n    }\n\n    /**\n     * handler for mouse pressure sensed\n     */\n    _onPressureSensed() {\n        if (Main.overview.visibleTarget)\n            return;\n\n        if (this._triggerTimeoutId)\n            GLib.source_remove(this._triggerTimeoutId);\n\n        // In case the mouse move away from the dock area before hovering it,\n        // in such case the leave event would never be triggered and the dock\n        // would stay visible forever.\n        this._triggerTimeoutId =  GLib.timeout_add(GLib.PRIORITY_DEFAULT, 250, () => {\n            const [x, y, mods_] = global.get_pointer();\n            let shouldHide = true;\n            switch (this._position) {\n            case St.Side.LEFT:\n                if (x <= this.staticBox.x2 &&\n                    x >= this._monitor.x &&\n                    y >= this._monitor.y &&\n                    y <= this._monitor.y + this._monitor.height)\n                    shouldHide = false;\n\n                break;\n            case St.Side.RIGHT:\n                if (x >= this.staticBox.x1 &&\n                    x <= this._monitor.x + this._monitor.width &&\n                    y >= this._monitor.y &&\n                    y <= this._monitor.y + this._monitor.height)\n                    shouldHide = false;\n\n                break;\n            case St.Side.TOP:\n                if (x >= this._monitor.x &&\n                    x <= this._monitor.x + this._monitor.width &&\n                    y <= this.staticBox.y2 &&\n                    y >= this._monitor.y)\n                    shouldHide = false;\n\n                break;\n            case St.Side.BOTTOM:\n                if (x >= this._monitor.x &&\n                    x <= this._monitor.x + this._monitor.width &&\n                    y >= this.staticBox.y1 &&\n                    y <= this._monitor.y + this._monitor.height)\n                    shouldHide = false;\n            }\n            if (shouldHide) {\n                this._triggerTimeoutId = 0;\n                this._hoverChanged();\n                return GLib.SOURCE_REMOVE;\n            } else {\n                return GLib.SOURCE_CONTINUE;\n            }\n        });\n\n        this._show();\n    }\n\n    /**\n     * Remove pressure barrier\n     */\n    _removeBarrier() {\n        if (this._barrier) {\n            if (this._pressureBarrier)\n                this._pressureBarrier.removeBarrier(this._barrier);\n            this._barrier.destroy();\n            this._barrier = null;\n        }\n        this._removeBarrierTimeoutId = 0;\n        return false;\n    }\n\n    /**\n     * Update pressure barrier size\n     */\n    _updateBarrier() {\n        // Remove existing barrier\n        this._removeBarrier();\n\n        // The barrier needs to be removed in fullscreen with autohide disabled\n        // otherwise the mouse can get trapped on monitor.\n        if (this._monitor.inFullscreen &&\n            !DockManager.settings.autohideInFullscreen)\n            return;\n\n        // Manually reset pressure barrier\n        // This is necessary because we remove the pressure barrier when it is\n        // triggered to show the dock\n        if (this._pressureBarrier) {\n            this._pressureBarrier._reset();\n            this._pressureBarrier._isTriggered = false;\n        }\n\n        // Create new barrier\n        // The barrier extends to the whole workarea, minus 1 px to avoid\n        // conflicting with other active corners\n        // Note: dash in fixed position doesn't use pressure barrier.\n        if (this._canUsePressure && this._autohideIsEnabled &&\n            DockManager.settings.requirePressureToShow) {\n            let x1, x2, y1, y2, direction;\n            const workArea = Main.layoutManager.getWorkAreaForMonitor(\n                this._monitor.index);\n\n            if (this._position === St.Side.LEFT) {\n                x1 = this._monitor.x + 1;\n                x2 = x1;\n                y1 = workArea.y + 1;\n                y2 = workArea.y + workArea.height - 1;\n                direction = Meta.BarrierDirection.POSITIVE_X;\n            } else if (this._position === St.Side.RIGHT) {\n                x1 = this._monitor.x + this._monitor.width - 1;\n                x2 = x1;\n                y1 = workArea.y + 1;\n                y2 = workArea.y + workArea.height - 1;\n                direction = Meta.BarrierDirection.NEGATIVE_X;\n            } else if (this._position === St.Side.TOP) {\n                x1 = workArea.x + 1;\n                x2 = workArea.x + workArea.width - 1;\n                y1 = this._monitor.y;\n                y2 = y1;\n                direction = Meta.BarrierDirection.POSITIVE_Y;\n            } else if (this._position === St.Side.BOTTOM) {\n                x1 = workArea.x + 1;\n                x2 = workArea.x + workArea.width - 1;\n                y1 = this._monitor.y + this._monitor.height;\n                y2 = y1;\n                direction = Meta.BarrierDirection.NEGATIVE_Y;\n            }\n\n            if (this._pressureBarrier && this._dockState === State.HIDDEN) {\n                this._barrier = new Meta.Barrier({\n                    backend: global.backend,\n                    x1,\n                    x2,\n                    y1,\n                    y2,\n                    directions: direction,\n                });\n                this._pressureBarrier.addBarrier(this._barrier);\n            }\n        }\n    }\n\n    _isPrimaryMonitor() {\n        return this.monitorIndex === Main.layoutManager.primaryIndex;\n    }\n\n    _resetPosition() {\n        // Ensure variables linked to settings are updated.\n        this._updateVisibilityMode();\n\n        const {dockFixed: fixedIsEnabled, dockExtended: extendHeight} = DockManager.settings;\n\n        if (fixedIsEnabled)\n            this.add_style_class_name('fixed');\n        else\n            this.remove_style_class_name('fixed');\n\n        // Note: do not use the workarea coordinates in the direction on which the dock is placed,\n        // to avoid a loop [position change -> workArea change -> position change] with\n        // fixed dock.\n        const workArea = Main.layoutManager.getWorkAreaForMonitor(this.monitorIndex);\n\n        let fraction = DockManager.settings.heightFraction;\n        if (extendHeight)\n            fraction = 1;\n        else if ((fraction < 0) || (fraction > 1))\n            fraction = 0.95;\n\n        if (this._isHorizontal) {\n            this.width = Math.round(fraction * workArea.width);\n\n            let posY = this._monitor.y;\n            if (this._position === St.Side.BOTTOM)\n                posY += this._monitor.height;\n\n            this.x = workArea.x + Math.round((1 - fraction) / 2 * workArea.width);\n            this.y = posY;\n\n            if (extendHeight) {\n                this.dash._container.set_width(this.width);\n                this.add_style_class_name('extended');\n            } else {\n                this.dash._container.set_width(-1);\n                this.remove_style_class_name('extended');\n            }\n        } else {\n            this.height = Math.round(fraction * workArea.height);\n\n            let posX = this._monitor.x;\n            if (this._position === St.Side.RIGHT)\n                posX += this._monitor.width;\n\n            this.x = posX;\n            this.y = workArea.y + Math.round((1 - fraction) / 2 * workArea.height);\n\n            if (extendHeight) {\n                this.dash._container.set_height(this.height);\n                this.add_style_class_name('extended');\n            } else {\n                this.dash._container.set_height(-1);\n                this.remove_style_class_name('extended');\n            }\n        }\n    }\n\n    _updateVisibleDesktop() {\n        if (!this._intellihideIsEnabled)\n            return;\n\n        const {desktopIconsUsableArea} = DockManager.getDefault();\n        if (this._position === St.Side.BOTTOM)\n            desktopIconsUsableArea.setMargins(this.monitorIndex, 0, this._box.height, 0, 0);\n        else if (this._position === St.Side.TOP)\n            desktopIconsUsableArea.setMargins(this.monitorIndex, this._box.height, 0, 0, 0);\n        else if (this._position === St.Side.RIGHT)\n            desktopIconsUsableArea.setMargins(this.monitorIndex, 0, 0, 0, this._box.width);\n        else if (this._position === St.Side.LEFT)\n            desktopIconsUsableArea.setMargins(this.monitorIndex, 0, 0, this._box.width, 0);\n    }\n\n    _updateStaticBox() {\n        this.staticBox.init_rect(\n            this.x + this._slider.x - (this._position === St.Side.RIGHT ? this._box.width : 0),\n            this.y + this._slider.y - (this._position === St.Side.BOTTOM ? this._box.height : 0),\n            this._box.width,\n            this._box.height\n        );\n\n        this._intellihide.updateTargetBox(this.staticBox);\n        this._updateVisibleDesktop();\n    }\n\n    _removeAnimations() {\n        this._slider.remove_all_transitions();\n    }\n\n    _onDragStart() {\n        this._oldIgnoreHover = this._ignoreHover;\n        this._ignoreHover = true;\n        this._animateIn(DockManager.settings.animationTime, 0);\n    }\n\n    _onDragEnd() {\n        if (this._oldIgnoreHover)\n            this._ignoreHover = this._oldIgnoreHover;\n        this._oldIgnoreHover = null;\n        this._box.sync_hover();\n    }\n\n    /**\n     * Show dock and give key focus to it\n     */\n    _onAccessibilityFocus() {\n        this._box.navigate_focus(null, St.DirectionType.TAB_FORWARD, false);\n        this._animateIn(DockManager.settings.animationTime, 0);\n    }\n\n    // Optional features to be enabled only for the main Dock\n    _enableExtraFeatures() {\n        // Restore dash accessibility\n        Main.ctrlAltTabManager.addGroup(\n            this.dash, _('Dash'), 'user-bookmarks-symbolic',\n            {focusCallback: this._onAccessibilityFocus.bind(this)});\n    }\n\n    /**\n     * Switch workspace by scrolling over the dock\n     */\n    _optionalScrollWorkspaceSwitch() {\n        const isEnabled = () =>\n            DockManager.settings.scrollAction === scrollAction.SWITCH_WORKSPACE;\n\n        const enable = () => {\n            this._signalsHandler.removeWithLabel(Labels.WORKSPACE_SWITCH_SCROLL);\n\n            this._signalsHandler.addWithLabel(Labels.WORKSPACE_SWITCH_SCROLL,\n                this._box, 'scroll-event', (_, e) => onScrollEvent(e));\n        };\n\n        const disable = () => {\n            this._signalsHandler.removeWithLabel(Labels.WORKSPACE_SWITCH_SCROLL);\n\n            if (this._optionalScrollWorkspaceSwitchDeadTimeId) {\n                GLib.source_remove(this._optionalScrollWorkspaceSwitchDeadTimeId);\n                this._optionalScrollWorkspaceSwitchDeadTimeId = 0;\n            }\n        };\n\n        DockManager.settings.connect('changed::scroll-action', () => {\n            if (isEnabled())\n                enable();\n            else\n                disable();\n        });\n\n        if (isEnabled())\n            enable();\n\n        // This was inspired to desktop-scroller@obsidien.github.com\n        const onScrollEvent = event => {\n            // When in overview change workspace only in windows view\n            if (Main.overview.visible)\n                return false;\n\n            const activeWs = global.workspace_manager.get_active_workspace();\n            let direction = null;\n\n            let prevDirection, nextDirection;\n            if (global.workspace_manager.layout_columns > global.workspace_manager.layout_rows) {\n                prevDirection = Meta.MotionDirection.UP;\n                nextDirection = Meta.MotionDirection.DOWN;\n            } else {\n                prevDirection = Meta.MotionDirection.LEFT;\n                nextDirection = Meta.MotionDirection.RIGHT;\n            }\n\n            switch (event.get_scroll_direction()) {\n            case Clutter.ScrollDirection.UP:\n                direction = prevDirection;\n                break;\n            case Clutter.ScrollDirection.DOWN:\n                direction = nextDirection;\n                break;\n            case Clutter.ScrollDirection.SMOOTH: {\n                const [dx_, dy] = event.get_scroll_delta();\n                if (dy < 0)\n                    direction = prevDirection;\n                else if (dy > 0)\n                    direction = nextDirection;\n            }\n                break;\n            }\n\n            if (direction) {\n                // Prevent scroll events from triggering too many workspace switches\n                // by adding a 250ms dead time between each scroll event.\n                // Useful on laptops when using a touch pad.\n\n                // During the deadtime do nothing\n                if (this._optionalScrollWorkspaceSwitchDeadTimeId) {\n                    return false;\n                } else {\n                    this._optionalScrollWorkspaceSwitchDeadTimeId = GLib.timeout_add(\n                        GLib.PRIORITY_DEFAULT, 250, () => {\n                            this._optionalScrollWorkspaceSwitchDeadTimeId = 0;\n                        });\n                }\n\n                let ws;\n\n                ws = activeWs.get_neighbor(direction);\n\n                if (!Main.wm._workspaceSwitcherPopup) {\n                    // Support Workspace Grid extension showing their custom\n                    // Grid Workspace Switcher\n                    if (global.workspace_manager.workspace_grid !== undefined) {\n                        Main.wm._workspaceSwitcherPopup =\n                            global.workspace_manager.workspace_grid.getWorkspaceSwitcherPopup();\n                    } else {\n                        Main.wm._workspaceSwitcherPopup = new WorkspaceSwitcherPopup.WorkspaceSwitcherPopup();\n                    }\n                }\n                // Set the actor non reactive, so that it doesn't prevent the\n                // clicks events from reaching the dash actor. I can't see a reason\n                // why it should be reactive.\n                Main.wm._workspaceSwitcherPopup.reactive = false;\n                Main.wm._workspaceSwitcherPopup.connect('destroy', () => {\n                    Main.wm._workspaceSwitcherPopup = null;\n                });\n\n                // If Workspace Grid is installed, let them handle the scroll behavior.\n                if (global.workspace_manager.workspace_grid !== undefined)\n                    ws = global.workspace_manager.workspace_grid.actionMoveWorkspace(direction);\n                else\n                    Main.wm.actionMoveWorkspace(ws);\n\n                // Do not show workspaceSwitcher in overview\n                if (!Main.overview.visible)\n                    Main.wm._workspaceSwitcherPopup.display(direction, ws.index());\n\n                return true;\n            } else {\n                return false;\n            }\n        };\n    }\n\n    _activateApp(appIndex) {\n        const children = this.dash._box.get_children().filter(actor => {\n            return actor.child &&\n                       actor.child.app;\n        });\n\n        // Apps currently in the dash\n        const apps = children.map(actor => {\n            return actor.child;\n        });\n\n        // Activate with button = 1, i.e. same as left click\n        const button = 1;\n        if (appIndex < apps.length)\n            apps[appIndex].activate(button);\n    }\n});\n\n/*\n * Handle keyboard shortcuts\n */\nconst NUM_HOTKEYS = 10;\n\nconst KeyboardShortcuts = class DashToDockKeyboardShortcuts {\n    constructor() {\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n\n        this._hotKeysEnabled = false;\n        if (DockManager.settings.hotKeys)\n            this._enableHotKeys();\n\n        this._signalsHandler.add([\n            DockManager.settings,\n            'changed::hot-keys',\n            () => {\n                if (DockManager.settings.hotKeys)\n                    this._enableHotKeys.bind(this)();\n                else\n                    this._disableHotKeys.bind(this)();\n            },\n        ]);\n\n        this._optionalNumberOverlay();\n    }\n\n    destroy() {\n        DockManager.allDocks.forEach(dock => {\n            if (dock._numberOverlayTimeoutId) {\n                GLib.source_remove(dock._numberOverlayTimeoutId);\n                dock._numberOverlayTimeoutId = 0;\n            }\n        });\n\n        // Remove keybindings\n        this._disableHotKeys();\n        this._disableExtraShortcut();\n        this._signalsHandler.destroy();\n    }\n\n    _enableHotKeys() {\n        if (this._hotKeysEnabled)\n            return;\n\n        // Setup keyboard bindings for dash elements\n        const keys = ['app-hotkey-', 'app-shift-hotkey-', 'app-ctrl-hotkey-'];\n        const {mainDock} = DockManager.getDefault();\n        keys.forEach(function (key) {\n            for (let i = 0; i < NUM_HOTKEYS; i++) {\n                const appNum = i;\n                Main.wm.addKeybinding(key + (i + 1), DockManager.settings,\n                    Meta.KeyBindingFlags.IGNORE_AUTOREPEAT,\n                    Shell.ActionMode.NORMAL | Shell.ActionMode.OVERVIEW,\n                    () => {\n                        mainDock._activateApp(appNum);\n                        this._showOverlay();\n                    });\n            }\n        }, this);\n\n        this._hotKeysEnabled = true;\n    }\n\n    _disableHotKeys() {\n        if (!this._hotKeysEnabled)\n            return;\n\n        const keys = ['app-hotkey-', 'app-shift-hotkey-', 'app-ctrl-hotkey-'];\n        keys.forEach(key => {\n            for (let i = 0; i < NUM_HOTKEYS; i++)\n                Main.wm.removeKeybinding(key + (i + 1));\n        }, this);\n\n        this._hotKeysEnabled = false;\n    }\n\n    _optionalNumberOverlay() {\n        const {settings} = DockManager;\n        this._shortcutIsSet = false;\n        // Enable extra shortcut if either 'overlay' or 'show-dock' are true\n        if (settings.hotKeys &&\n           (settings.hotkeysOverlay || settings.hotkeysShowDock))\n            this._enableExtraShortcut();\n\n        this._signalsHandler.add([\n            settings,\n            'changed::hot-keys',\n            this._checkHotkeysOptions.bind(this),\n        ], [\n            settings,\n            'changed::hotkeys-overlay',\n            this._checkHotkeysOptions.bind(this),\n        ], [\n            settings,\n            'changed::hotkeys-show-dock',\n            this._checkHotkeysOptions.bind(this),\n        ]);\n    }\n\n    _checkHotkeysOptions() {\n        const {settings} = DockManager;\n\n        if (settings.hotKeys &&\n           (settings.hotkeysOverlay || settings.hotkeysShowDock))\n            this._enableExtraShortcut();\n        else\n            this._disableExtraShortcut();\n    }\n\n    _enableExtraShortcut() {\n        if (!this._shortcutIsSet) {\n            Main.wm.addKeybinding('shortcut', DockManager.settings,\n                Meta.KeyBindingFlags.IGNORE_AUTOREPEAT,\n                Shell.ActionMode.NORMAL | Shell.ActionMode.OVERVIEW,\n                this._showOverlay.bind(this));\n            this._shortcutIsSet = true;\n        }\n    }\n\n    _disableExtraShortcut() {\n        if (this._shortcutIsSet) {\n            Main.wm.removeKeybinding('shortcut');\n            this._shortcutIsSet = false;\n        }\n    }\n\n    _showOverlay() {\n        for (const dock of DockManager.allDocks) {\n            if (DockManager.settings.hotkeysOverlay)\n                dock.dash.toggleNumberOverlay(true);\n\n            // Restart the counting if the shortcut is pressed again\n            if (dock._numberOverlayTimeoutId) {\n                GLib.source_remove(dock._numberOverlayTimeoutId);\n                dock._numberOverlayTimeoutId = 0;\n            }\n\n            // Hide the overlay/dock after the timeout\n            const timeout = DockManager.settings.shortcutTimeout * 1000;\n            dock._numberOverlayTimeoutId = GLib.timeout_add(\n                GLib.PRIORITY_DEFAULT, timeout, () => {\n                    dock._numberOverlayTimeoutId = 0;\n                    dock.dash.toggleNumberOverlay(false);\n                    // Hide the dock again if necessary\n                    dock._updateDashVisibility();\n                });\n\n            // Show the dock if it is hidden\n            if (DockManager.settings.hotkeysShowDock) {\n                const showDock = dock._intellihideIsEnabled || dock._autohideIsEnabled;\n                if (showDock)\n                    dock._show();\n            }\n        }\n    }\n};\n\n/**\n * Isolate overview to open new windows for inactive apps\n * Note: the future implementation is not fully contained here.\n * Some bits are around in other methods of other classes.\n * This class just take care of enabling/disabling the option.\n */\nconst WorkspaceIsolation = class DashToDockWorkspaceIsolation {\n    constructor() {\n        const {settings} = DockManager;\n\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._injectionsHandler = new Utils.InjectionsHandler();\n\n        const updateAllDocks = () => {\n            DockManager.allDocks.forEach(dock =>\n                dock.dash.resetAppIcons());\n            if (settings.isolateWorkspaces ||\n                settings.isolateMonitors)\n                this._enable.bind(this)();\n            else\n                this._disable.bind(this)();\n        };\n        this._signalsHandler.add(\n            [settings, 'changed::isolate-workspaces', updateAllDocks],\n            [settings, 'changed::workspace-agnostic-urgent-windows', updateAllDocks],\n            [settings, 'changed::isolate-monitors', updateAllDocks]\n        );\n\n        if (settings.isolateWorkspaces ||\n            settings.isolateMonitors)\n            this._enable();\n    }\n\n    _enable() {\n        // ensure I never double-register/inject\n        // although it should never happen\n        this._disable();\n\n        DockManager.allDocks.forEach(dock => {\n            this._signalsHandler.addWithLabel(\n                Labels.ISOLATION,\n                [global.display, 'restacked', () => dock.dash._queueRedisplay()],\n                [global.display, 'window-marked-urgent', () => dock.dash._queueRedisplay()],\n                [global.display, 'window-demands-attention', () => dock.dash._queueRedisplay()],\n                [global.window_manager, 'switch-workspace', () => dock.dash._queueRedisplay()]\n            );\n\n            // This last signal is only needed for monitor isolation, as windows\n            // might migrate from one monitor to another without triggering 'restacked'\n            if (DockManager.settings.isolateMonitors) {\n                this._signalsHandler.addWithLabel(Labels.ISOLATION,\n                    global.display,\n                    'window-entered-monitor',\n                    dock.dash._queueRedisplay.bind(dock.dash));\n            }\n        }, this);\n\n        /**\n         * here this is the Shell.App\n         */\n        function IsolatedOverview() {\n            // These lines take care of Nautilus for icons on Desktop\n            const activeWorkspaceIndex =\n                global.workspaceManager.get_active_workspace_index();\n            const windows = this.get_windows().filter(w =>\n                !w.skipTaskbar && w.get_workspace().index() === activeWorkspaceIndex);\n\n            if (windows.length)\n                return Main.activateWindow(windows[0]);\n            return this.open_new_window(-1);\n        }\n\n        this._injectionsHandler.addWithLabel(Labels.ISOLATION,\n            Shell.App.prototype,\n            'activate',\n            IsolatedOverview);\n    }\n\n    _disable() {\n        this._signalsHandler.removeWithLabel(Labels.ISOLATION);\n        this._injectionsHandler.removeWithLabel(Labels.ISOLATION);\n    }\n\n    destroy() {\n        this._signalsHandler.destroy();\n        this._injectionsHandler.destroy();\n    }\n};\n\n\nexport class DockManager {\n    constructor(extension) {\n        if (DockManager._singleton)\n            throw new Error('DashToDock has been already initialized');\n        DockManager._singleton = this;\n        this._extension = extension;\n        this._signalsHandler = new Utils.GlobalSignalsHandler(this);\n        this._methodInjections = new Utils.InjectionsHandler(this);\n        this._vfuncInjections = new Utils.VFuncInjectionsHandler(this);\n        this._propertyInjections = new Utils.PropertyInjectionsHandler(this);\n        this._settings = this._extension.getSettings(\n            'org.gnome.shell.extensions.dash-to-dock');\n        this._appSwitcherSettings = new Gio.Settings({schema_id: 'org.gnome.shell.app-switcher'});\n        this._mapSettingsValues();\n\n        this._iconTheme = new St.IconTheme();\n\n        this._desktopIconsUsableArea = new DesktopIconsIntegration.DesktopIconsUsableAreaClass();\n        this._oldDash = Main.overview.isDummy ? null : Main.overview.dash;\n        this._discreteGpuAvailable = AppDisplay.discreteGpuAvailable;\n        this._appSpread = new AppSpread.AppSpread();\n        this._notificationsMonitor = new NotificationsMonitor.NotificationsMonitor();\n\n        const needsRemoteModel = () =>\n            !this._notificationsMonitor.dndMode && this._settings.showIconsEmblems;\n\n        const ensureRemoteModel = () => {\n            if (needsRemoteModel && !this._remoteModel) {\n                this._remoteModel = new LauncherAPI.LauncherEntryRemoteModel();\n                this._appIconsDecorator = new AppIconsDecorator.AppIconsDecorator();\n            } else if (!needsRemoteModel) {\n                this._remoteModel?.destroy();\n                delete this._remoteModel;\n                this._appIconsDecorator?.destroy();\n                delete this._appIconsDecorator;\n            }\n        };\n        ensureRemoteModel();\n\n        this._notificationsMonitor.connect('changed', ensureRemoteModel);\n        this._settings.connect('changed::show-icons-emblems', ensureRemoteModel);\n\n        if (this._discreteGpuAvailable === undefined) {\n            const updateDiscreteGpuAvailable = () => {\n                const switcherooProxy = global.get_switcheroo_control();\n                if (switcherooProxy) {\n                    const prop = switcherooProxy.get_cached_property('HasDualGpu');\n                    this._discreteGpuAvailable = prop?.unpack() ?? false;\n                } else {\n                    this._discreteGpuAvailable = false;\n                }\n            };\n            this._signalsHandler.add(global, 'notify::switcheroo-control',\n                () => updateDiscreteGpuAvailable());\n            updateDiscreteGpuAvailable();\n        }\n\n        // Connect relevant signals to the toggling function\n        this._bindSettingsChanges();\n\n        this._ensureLocations();\n\n        /* Array of all the docks created */\n        this._allDocks = [];\n        this._createDocks();\n\n        this._overrideAppMenus();\n\n        // status variable: true when the overview is shown through the dash\n        // applications button.\n        this._forcedOverview = false;\n    }\n\n    static getDefault() {\n        return DockManager._singleton;\n    }\n\n    static get allDocks() {\n        return DockManager.getDefault()._allDocks;\n    }\n\n    static get extension() {\n        return DockManager.getDefault().extension;\n    }\n\n    static get settings() {\n        return DockManager.getDefault().settings;\n    }\n\n    get extension() {\n        return this._extension;\n    }\n\n    get settings() {\n        return this._settings;\n    }\n\n    static get iconTheme() {\n        return DockManager.getDefault().iconTheme;\n    }\n\n    get settings() { // eslint-disable-line no-dupe-class-members\n        return this._settings;\n    }\n\n    get iconTheme() {\n        return this._iconTheme;\n    }\n\n    get fm1Client() {\n        return this._fm1Client;\n    }\n\n    get remoteModel() {\n        return this._remoteModel;\n    }\n\n    get mainDock() {\n        return this._allDocks.length ? this._allDocks[0] : null;\n    }\n\n    get removables() {\n        return this._removables;\n    }\n\n    get trash() {\n        return this._trash;\n    }\n\n    get desktopIconsUsableArea() {\n        return this._desktopIconsUsableArea;\n    }\n\n    get discreteGpuAvailable() {\n        return AppDisplay.discreteGpuAvailable || this._discreteGpuAvailable;\n    }\n\n    get appSpread() {\n        return this._appSpread;\n    }\n\n    get notificationsMonitor() {\n        return this._notificationsMonitor;\n    }\n\n    getDockByMonitor(monitorIndex) {\n        return this._allDocks.find(d => d.monitorIndex === monitorIndex);\n    }\n\n    _ensureLocations() {\n        const {showMounts, showTrash} = this.settings;\n\n        if (showTrash || showMounts) {\n            if (!this._fm1Client)\n                this._fm1Client = new FileManager1API.FileManager1Client();\n        } else if (this._fm1Client) {\n            this._fm1Client.destroy();\n            this._fm1Client = null;\n        }\n\n        if (showMounts && !this._removables) {\n            this._removables = new Locations.Removables();\n        } else if (!showMounts && this._removables) {\n            this._removables.destroy();\n            this._removables = null;\n        }\n\n        if (showTrash && !this._trash) {\n            this._trash = new Locations.Trash();\n        } else if (!showTrash && this._trash) {\n            this._trash.destroy();\n            this._trash = null;\n        }\n\n        Locations.unWrapFileManagerApp();\n        [this._methodInjections, this._propertyInjections].forEach(\n            injections => injections.removeWithLabel(Labels.LOCATIONS));\n\n        if (showMounts || showTrash) {\n            if (this.settings.isolateLocations) {\n                const fileManagerApp = Locations.wrapFileManagerApp();\n\n                this._methodInjections.addWithLabel(Labels.LOCATIONS, [\n                    Shell.AppSystem.prototype, 'get_running',\n                    function (originalMethod, ...args) {\n                        /* eslint-disable no-invalid-this */\n                        const runningApps = originalMethod.call(this, ...args);\n                        const locationApps = Locations.getRunningApps();\n                        if (!locationApps.length)\n                            return runningApps;\n\n                        const fileManagerIdx = runningApps.indexOf(fileManagerApp);\n                        if (fileManagerIdx > -1 && fileManagerApp?.state !== Shell.AppState.RUNNING)\n                            runningApps.splice(fileManagerIdx, 1);\n\n                        return [...runningApps, ...locationApps].sort(Utils.shellAppCompare);\n                        /* eslint-enable no-invalid-this */\n                    },\n                ],\n                [\n                    Shell.WindowTracker.prototype, 'get_window_app',\n                    function (originalMethod, window) {\n                        /* eslint-disable no-invalid-this */\n                        const locationApp = Locations.getRunningApps().find(a =>\n                            a.get_windows().includes(window));\n                        return locationApp ?? originalMethod.call(this, window);\n                        /* eslint-enable no-invalid-this */\n                    },\n                ],\n                [\n                    Shell.WindowTracker.prototype, 'get_app_from_pid',\n                    function (originalMethod, pid) {\n                        /* eslint-disable no-invalid-this */\n                        const locationApp = Locations.getRunningApps().find(a =>\n                            a.get_pids().includes(pid));\n                        return locationApp ?? originalMethod.call(this, pid);\n                        /* eslint-enable no-invalid-this */\n                    },\n                ]);\n\n                const {get: defaultFocusAppGetter} = Object.getOwnPropertyDescriptor(\n                    Shell.WindowTracker.prototype, 'focus_app');\n                this._propertyInjections.addWithLabel(Labels.LOCATIONS,\n                    Shell.WindowTracker.prototype, 'focus_app', {\n                        get() {\n                            const locationApp = Locations.getRunningApps().find(a => a.isFocused);\n                            return locationApp ?? defaultFocusAppGetter.call(this);\n                        },\n                    });\n            }\n        }\n    }\n\n    _toggle() {\n        if (this._toggleLater)\n            return;\n\n        this._toggleLater = Utils.laterAdd(Meta.LaterType.BEFORE_REDRAW, () => {\n            delete this._toggleLater;\n            this._restoreDash();\n            this._deleteDocks();\n            this._createDocks();\n            this.emit('toggled');\n        });\n    }\n\n    _mapExternalSetting(settings, key, mappedKey, mapValueFunction) {\n        const camelMappedKey = mappedKey.replace(/-([a-z\\d])/g, k => k[1].toUpperCase());\n\n        const dockPropertyDesc = Object.getOwnPropertyDescriptor(this.settings, camelMappedKey);\n\n        if (!dockPropertyDesc)\n            throw new Error('Setting %s not found in dock'.format(mappedKey));\n\n        const mappedValue = () => mapValueFunction(settings.get_value(key).recursiveUnpack());\n        Object.defineProperty(this.settings, camelMappedKey, {\n            get: () => mappedValue() ?? dockPropertyDesc.value,\n            set: value => {\n                if (mappedValue())\n                    dockPropertyDesc.value = value;\n            },\n        });\n\n        this._signalsHandler.addWithLabel(Labels.SETTINGS, settings,\n            'changed::%s'.format(key), () => {\n                this._signalsHandler.blockWithLabel(Labels.SETTINGS);\n                this.settings.emit('changed::%s'.format(mappedKey), mappedKey);\n                this._signalsHandler.unblockWithLabel(Labels.SETTINGS);\n            });\n    }\n\n    _mapSettingsValues() {\n        this.settings.settingsSchema.list_keys().forEach(key => {\n            const camelKey = key.replace(/-([a-z\\d])/g, k => k[1].toUpperCase());\n            const updateSetting = () => {\n                const schemaKey = this.settings.settingsSchema.get_key(key);\n                if (schemaKey.get_range().deepUnpack()[0] === 'enum')\n                    this.settings[camelKey] = this.settings.get_enum(key);\n                else\n                    this.settings[camelKey] = this.settings.get_value(key).recursiveUnpack();\n            };\n            updateSetting();\n            this._signalsHandler.addWithLabel(Labels.SETTINGS, this.settings,\n                `changed::${key}`, updateSetting);\n            if (key !== camelKey) {\n                Object.defineProperty(this.settings, key,\n                    {get: () => this.settings[camelKey]});\n            }\n        });\n        Object.defineProperties(this.settings, {\n            dockExtended: {get: () => this.settings.extendHeight},\n        });\n    }\n\n    _bindSettingsChanges() {\n        // Connect relevant signals to the toggling function\n        this._signalsHandler.addWithLabel(Labels.SETTINGS, [\n            Utils.getMonitorManager(),\n            'monitors-changed',\n            this._toggle.bind(this),\n        ], [\n            Main.sessionMode,\n            'updated',\n            this._toggle.bind(this),\n        ], [\n            this._settings,\n            'changed::multi-monitor',\n            this._toggle.bind(this),\n        ], [\n            this._settings,\n            'changed::preferred-monitor',\n            this._toggle.bind(this),\n        ], [\n            this._settings,\n            'changed::preferred-monitor-by-connector',\n            this._toggle.bind(this),\n        ], [\n            this._settings,\n            'changed::dock-position',\n            this._toggle.bind(this),\n        ], [\n            this._settings,\n            'changed::extend-height',\n            () => this._adjustPanelCorners(),\n        ], [\n            this._settings,\n            'changed::dock-fixed',\n            () => this._adjustPanelCorners(),\n        ], [\n            this._settings,\n            'changed::show-trash',\n            () => this._ensureLocations(),\n        ], [\n            this._settings,\n            'changed::show-mounts',\n            () => this._ensureLocations(),\n        ], [\n            this._settings,\n            'changed::isolate-locations',\n            () => this._ensureLocations(),\n        ], [\n            this._settings,\n            'changed::intellihide',\n            () => {\n                if (!this._settings.intellihide)\n                    this._desktopIconsUsableArea.resetMargins();\n            },\n        ]);\n\n        this._mapExternalSetting(this._appSwitcherSettings, 'current-workspace-only',\n            'isolate-workspaces', value => value || undefined);\n    }\n\n    _createDocks() {\n        // If there are no monitors (headless configurations, but it can also\n        // happen temporary while disconnecting and reconnecting monitors), just\n        // do nothing. When a monitor will be connected we we'll be notified and\n        // and thus create the docks. This prevents pointing trying to access\n        // monitors throughout the code, were we are assuming that at least the\n        // primary monitor is present.\n        if (Main.layoutManager.monitors.length <= 0)\n            return;\n\n\n        this._preferredMonitorIndex = this.settings.preferredMonitor;\n        if (this._preferredMonitorIndex === -2) {\n            const monitorManager = Utils.getMonitorManager();\n            this._preferredMonitorIndex = monitorManager.get_monitor_for_connector(\n                this.settings.preferredMonitorByConnector);\n        } else if (this._preferredMonitorIndex >= 0) {\n            // Primary monitor used to be always 0 in Gdk, but the shell has a different\n            // concept (where the order depends on mutter order).\n            // So even if now the extension settings may use the same logic of the shell\n            // we prefer not to break the previously configured systems, and so we still\n            // assume that the gsettings monitor numbering follows the old strategy.\n            // This ensure the indexing in the settings and in the shell are matched,\n            // i.e. that we start counting from the primaryMonitorIndex\n            this._preferredMonitorIndex =\n                (Main.layoutManager.primaryIndex + this._preferredMonitorIndex) %\n                Main.layoutManager.monitors.length;\n        }\n\n        // In case of multi-monitor, we consider the dock on the primary monitor\n        // to be the preferred (main) one regardless of the settings the dock\n        // goes on the primary monitor also if the settings are inconsistent\n        // (e.g. desired monitor not connected).\n        if (this.settings.multiMonitor ||\n            this._preferredMonitorIndex < 0 ||\n            this._preferredMonitorIndex > Main.layoutManager.monitors.length - 1)\n            this._preferredMonitorIndex = Main.layoutManager.primaryIndex;\n\n\n        // First we create the main Dock, to get the extra features to bind to this one\n        let dock = new DockedDash({\n            monitorIndex: this._preferredMonitorIndex,\n            isMain: true,\n        });\n        this._allDocks.push(dock);\n\n        // connect app icon into the view selector\n        dock.dash.showAppsButton.connect('notify::checked',\n            this._onShowAppsButtonToggled.bind(this));\n\n        // Make the necessary changes to Main.overview.dash\n        this._prepareMainDash();\n\n        // Adjust corners if necessary\n        this._adjustPanelCorners();\n\n        if (this.settings.multiMonitor) {\n            const nMon = Main.layoutManager.monitors.length;\n            for (let iMon = 0; iMon < nMon; iMon++) {\n                if (iMon === this._preferredMonitorIndex)\n                    continue;\n                dock = new DockedDash({monitorIndex: iMon});\n                this._allDocks.push(dock);\n                // connect app icon into the view selector\n                dock.dash.showAppsButton.connect('notify::checked',\n                    this._onShowAppsButtonToggled.bind(this));\n            }\n        }\n\n        // Load optional features. We load *after* the docks are created, since\n        // we need to connect the signals to all dock instances.\n        this._workspaceIsolation = new WorkspaceIsolation();\n        this._keyboardShortcuts = new KeyboardShortcuts();\n\n        this.emit('docks-ready');\n    }\n\n    _prepareStartupAnimation() {\n        DockManager.allDocks.forEach(dock => {\n            const {dash} = dock;\n\n            dock.opacity = 255;\n            dash.set({\n                opacity: 0,\n                translation_x: 0,\n                translation_y: 0,\n            });\n        });\n    }\n\n    _runStartupAnimation() {\n        DockManager.allDocks.forEach(dock => {\n            const {dash} = dock;\n\n            switch (dock.position) {\n            case St.Side.LEFT:\n                dash.translation_x = -dash.width;\n                break;\n            case St.Side.RIGHT:\n                dash.translation_x = dash.width;\n                break;\n            case St.Side.BOTTOM:\n                dash.translation_y = dash.height;\n                break;\n            case St.Side.TOP:\n                dash.translation_y = -dash.height;\n                break;\n            }\n\n            dash.ease({\n                opacity: 255,\n                translation_x: 0,\n                translation_y: 0,\n                duration: STARTUP_ANIMATION_TIME,\n                mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n            });\n        });\n    }\n\n    _prepareMainDash() {\n        // Ensure Main.overview.dash is set to our dash in dummy mode\n        // while just use the default getter otherwise.\n        // The getter must be dynamic and not set only when we've a dummy\n        // overview because the mode can change dynamically.\n        this._propertyInjections.removeWithLabel(Labels.MAIN_DASH);\n        const defaultDashGetter = Object.getOwnPropertyDescriptor(\n            Main.overview.constructor.prototype, 'dash').get;\n        this._propertyInjections.addWithLabel(Labels.MAIN_DASH, Main.overview, 'dash', {\n            get: () => Main.overview.isDummy\n                ? this.mainDock.dash : defaultDashGetter.call(Main.overview),\n        });\n\n        if (Main.overview.isDummy)\n            return;\n\n        // Hide usual Dash\n        this._oldDash.hide();\n\n        // Also set dash width to 1, so it's almost not taken into account by code\n        // calculating the reserved space in the overview. The reason to keep it at 1 is\n        // to allow its visibility change to trigger an allocation of the appGrid which\n        // in turn is triggering the appsIcon spring animation, required when no other\n        // actors has this effect, i.e in horizontal mode and without the workspaceThumbnails\n        // 1 static workspace only)\n        this._oldDash.set_height(1);\n\n        this._signalsHandler.addWithLabel(Labels.OLD_DASH_CHANGES, [\n            this._oldDash,\n            'notify::visible',\n            () => this._oldDash.hide(),\n        ], [\n            this._oldDash,\n            'notify::height',\n            () => this._oldDash.set_height(1),\n        ]);\n\n        // Pretend I'm the dash: meant to make app grid swarm animation come from\n        // the right position of the appShowButton.\n        this.overviewControls.dash = this.mainDock.dash;\n        this.searchController._showAppsButton = this.mainDock.dash.showAppsButton;\n\n        // We also need to ignore max-size changes\n        this._methodInjections.addWithLabel(Labels.MAIN_DASH, this._oldDash,\n            'setMaxSize', () => {});\n        this._methodInjections.addWithLabel(Labels.MAIN_DASH, this._oldDash,\n            'allocate', () => {});\n        // And to return the preferred height depending on the state\n        this._methodInjections.addWithLabel(Labels.MAIN_DASH, this._oldDash,\n            'get_preferred_height', (_originalMethod, ...args) => {\n                if (this.mainDock.isHorizontal && !this.settings.dockFixed)\n                    return this.mainDock.get_preferred_height(...args);\n                return [0, 0];\n            });\n\n        // FIXME: https://gitlab.gnome.org/GNOME/gnome-shell/-/merge_requests/2890\n        // const { ControlsManagerLayout } = OverviewControls;\n        const ControlsManagerLayout = this.overviewControls.layout_manager.constructor;\n\n        const maybeAdjustBoxSize = (state, box, spacing) => {\n            // ensure that an undefined value will be converted into a valid one\n            spacing = spacing ?? 0;\n\n            if (state === OverviewControls.ControlsState.WINDOW_PICKER) {\n                const searchBox = this.overviewControls._searchEntry.get_allocation_box();\n                const {shouldShow: wsThumbnails} = this.overviewControls._thumbnailsBox;\n\n                if (!wsThumbnails) {\n                    box.y1 += spacing;\n                    box.y2 -= spacing;\n                }\n\n                box.y2 -= searchBox.get_height() + 2 * spacing;\n            }\n\n            return box;\n        };\n\n        const maybeAdjustBoxToDock = (state, box, spacing) => {\n            maybeAdjustBoxSize(state, box, spacing);\n\n            if (this.mainDock.isHorizontal || this.settings.dockFixed)\n                return box;\n\n            const [, preferredWidth] = this.mainDock.get_preferred_width(\n                box.get_height());\n\n            if (this.mainDock.position === St.Side.LEFT)\n                box.x1 += preferredWidth;\n            else if (this.mainDock.position === St.Side.RIGHT)\n                box.x2 -= preferredWidth;\n\n            return box;\n        };\n\n        this._vfuncInjections.addWithLabel(Labels.MAIN_DASH, ControlsManagerLayout.prototype,\n            'allocate', function (container) {\n                /* eslint-disable no-invalid-this */\n                const oldPostAllocation = this._runPostAllocation;\n                this._runPostAllocation = () => {};\n\n                const monitor = Main.layoutManager.findMonitorForActor(container);\n                const workArea = Main.layoutManager.getWorkAreaForMonitor(monitor.index);\n                const startX = workArea.x - monitor.x;\n                const startY = workArea.y - monitor.y;\n                const workAreaBox = new Clutter.ActorBox();\n                workAreaBox.set_origin(startX, startY);\n                workAreaBox.set_size(workArea.width, workArea.height);\n\n                // GNOME 46 changes \"spacing\" to \"_spacing\".\n                const spacing = this.spacing ?? this._spacing;\n\n                maybeAdjustBoxToDock(undefined, workAreaBox, spacing);\n                const oldStartY = workAreaBox.y1;\n\n                const propertyInjections = new Utils.PropertyInjectionsHandler();\n                propertyInjections.add(Main.layoutManager.panelBox, 'height', {value: startY});\n\n                if (Main.layoutManager.panelBox.y === Main.layoutManager.primaryMonitor.y)\n                    workAreaBox.y1 -= oldStartY;\n\n                this.vfunc_allocate(container, workAreaBox);\n\n                propertyInjections.destroy();\n                workAreaBox.y1 = oldStartY;\n\n                const adjustActorHorizontalAllocation = actor => {\n                    if (!actor.visible || !workAreaBox.x1)\n                        return;\n\n                    const contentBox = actor.get_allocation_box();\n                    contentBox.set_size(workAreaBox.get_width(), contentBox.get_height());\n                    contentBox.set_origin(workAreaBox.x1, contentBox.y1);\n                    actor.allocate(contentBox);\n                };\n\n                [this._searchEntry, this._workspacesThumbnails, this._searchController].forEach(\n                    actor => adjustActorHorizontalAllocation(actor));\n\n                this._runPostAllocation = oldPostAllocation;\n                this._runPostAllocation();\n                /* eslint-enable no-invalid-this */\n            });\n\n        /**\n         * This can be removed or bypassed when GNOME/gnome-shell!1892 will be merged\n         *\n         * @param originalFunction\n         * @param state\n         * @param workAreaBox\n         * @param {...any} args\n         */\n        function workspaceBoxOriginFixer(originalFunction, state, workAreaBox, ...args) {\n            /* eslint-disable no-invalid-this */\n            const workspaceBox = originalFunction.call(this, state, workAreaBox, ...args);\n            workspaceBox.set_origin(workAreaBox.x1, workspaceBox.y1);\n            return workspaceBox;\n            /* eslint-enable no-invalid-this */\n        }\n\n        this._methodInjections.addWithLabel(Labels.MAIN_DASH, [\n            ControlsManagerLayout.prototype,\n            '_computeWorkspacesBoxForState',\n            function (originalFunction, state, ...args) {\n                /* eslint-disable no-invalid-this */\n                if (state === OverviewControls.ControlsState.HIDDEN)\n                    return originalFunction.call(this, state, ...args);\n\n                const box = workspaceBoxOriginFixer.call(this, originalFunction, state, ...args);\n                // GNOME 46 changes \"spacing\" to \"_spacing\".\n                const spacing = this.spacing ?? this._spacing;\n                const dock = DockManager.getDefault().getDockByMonitor(Main.layoutManager.primaryIndex);\n                if (!dock)\n                    return box;\n                else\n                    return maybeAdjustBoxSize(state, box, spacing);\n                /* eslint-enable no-invalid-this */\n            },\n        ], [\n            WorkspacesView.SecondaryMonitorDisplay.prototype,\n            '_getWorkspacesBoxForState',\n            function (originalFunction, state, ...args) {\n                /* eslint-disable no-invalid-this */\n                if (state === OverviewControls.ControlsState.HIDDEN)\n                    return originalFunction.call(this, state, ...args);\n\n                const box = workspaceBoxOriginFixer.call(this, originalFunction, state, ...args);\n                const dock = DockManager.getDefault().getDockByMonitor(this._monitorIndex);\n                if (!dock)\n                    return box;\n                if (state === OverviewControls.ControlsState.WINDOW_PICKER &&\n                    dock.position === St.Side.BOTTOM) {\n                    const [, preferredHeight] = dock.get_preferred_height(box.get_width());\n                    box.y2 -= preferredHeight;\n                }\n                return box;\n                /* eslint-enable no-invalid-this */\n            },\n        ], [\n            ControlsManagerLayout.prototype,\n            '_getAppDisplayBoxForState',\n            function (originalFunction, ...args) {\n                /* eslint-disable no-invalid-this */\n                return workspaceBoxOriginFixer.call(this, originalFunction, ...args);\n                /* eslint-enable no-invalid-this */\n            },\n        ]);\n\n        this._vfuncInjections.addWithLabel(Labels.MAIN_DASH, Workspace.WorkspaceBackground.prototype,\n            'allocate', function (box) {\n                /* eslint-disable no-invalid-this */\n                this.vfunc_allocate(box);\n\n                // This code has been submitted upstream via GNOME/gnome-shell!1892\n                // so can be removed when that gets merged (or bypassed on newer shell\n                // versions).\n                const monitor = Main.layoutManager.monitors[this._monitorIndex];\n                const [contentWidth, contentHeight] = this._bin.get_content_box().get_size();\n                const [mX1, mX2] = [monitor.x, monitor.x + monitor.width];\n                const [mY1, mY2] = [monitor.y, monitor.y + monitor.height];\n                const [wX1, wX2] = [this._workarea.x, this._workarea.x + this._workarea.width];\n                const [wY1, wY2] = [this._workarea.y, this._workarea.y + this._workarea.height];\n                const xScale = contentWidth / this._workarea.width;\n                const yScale = contentHeight / this._workarea.height;\n                const leftOffset = wX1 - mX1;\n                const topOffset = wY1 - mY1;\n                const rightOffset = mX2 - wX2;\n                const bottomOffset = mY2 - wY2;\n\n                const contentBox = new Clutter.ActorBox();\n                contentBox.set_origin(-leftOffset * xScale, -topOffset * yScale);\n                contentBox.set_size(\n                    contentWidth + (leftOffset + rightOffset) * xScale,\n                    contentHeight + (topOffset + bottomOffset) * yScale);\n\n                this._backgroundGroup.allocate(contentBox);\n                /* eslint-enable no-invalid-this */\n            });\n\n        // Reduce the space that the workspaces can use in secondary monitors\n        this._methodInjections.addWithLabel(Labels.MAIN_DASH, WorkspacesView.WorkspacesView.prototype,\n            '_getFirstFitAllWorkspaceBox', function (originalFunction, ...args) {\n                /* eslint-disable no-invalid-this */\n                const box = originalFunction.call(this, ...args);\n                if (DockManager.settings.dockFixed ||\n                    this._monitorIndex === Main.layoutManager.primaryIndex)\n                    return box;\n\n                const dock = DockManager.getDefault().getDockByMonitor(this._monitorIndex);\n                if (!dock)\n                    return box;\n\n                if (dock.isHorizontal) {\n                    const [, preferredHeight] = dock.get_preferred_height(box.get_width());\n                    box.y2 -= preferredHeight;\n                    if (dock.position === St.Side.TOP)\n                        box.set_origin(box.x1, box.y1 + preferredHeight);\n                } else {\n                    const [, preferredWidth] = dock.get_preferred_width(box.get_height());\n                    box.x2 -= preferredWidth / 2;\n                    if (dock.position === St.Side.LEFT)\n                        box.set_origin(box.x1 + preferredWidth, box.y1);\n                }\n                return box;\n                /* eslint-enable no-invalid-this */\n            });\n\n        if (AppDisplay.BaseAppView?.prototype?._pageForCoords) {\n            // Ensure we handle Dnd events happening on the dock when we're\n            // dragging from AppDisplay.\n            // Remove when merged\n            // https://gitlab.gnome.org/GNOME/gnome-shell/-/merge_requests/2002\n            this._methodInjections.addWithLabel(Labels.MAIN_DASH,\n                AppDisplay.BaseAppView.prototype,\n                '_pageForCoords', function (originalFunction, ...args) {\n                    /* eslint-disable no-invalid-this */\n                    if (!this._scrollView.has_pointer)\n                        return AppDisplay.SidePages.NONE;\n                    return originalFunction.call(this, ...args);\n                    /* eslint-enable no-invalid-this */\n                });\n        }\n\n        if (Main.layoutManager._startingUp) {\n            this._prepareStartupAnimation();\n\n            const hadOverview = Main.sessionMode.hasOverview;\n\n            // Convince LayoutManager to use the legacy startup animation:\n            if (this._settings.disableOverviewOnStartup)\n                Main.sessionMode.hasOverview = false;\n\n            this._signalsHandler.addWithLabel(Labels.STARTUP_ANIMATION,\n                Main.layoutManager, 'startup-complete', () => {\n                    this._signalsHandler.removeWithLabel(Labels.STARTUP_ANIMATION);\n                    Main.sessionMode.hasOverview = hadOverview;\n                    this._runStartupAnimation();\n                });\n        }\n    }\n\n    _deleteDocks() {\n        if (!this._allDocks.length)\n            return;\n\n        // Remove extra features\n        this._workspaceIsolation.destroy();\n        this._keyboardShortcuts.destroy();\n        this._desktopIconsUsableArea.resetMargins();\n\n        // Delete all docks\n        this._allDocks.forEach(d => d.destroy());\n        this._allDocks = [];\n\n        this.emit('docks-destroyed');\n    }\n\n    _restoreDash() {\n        if (!this._oldDash)\n            return;\n\n        this._signalsHandler.removeWithLabel(Labels.OLD_DASH_CHANGES);\n        [this._methodInjections, this._vfuncInjections, this._propertyInjections].forEach(\n            injections => injections.removeWithLabel(Labels.MAIN_DASH));\n\n        this.overviewControls.layout_manager._dash = this._oldDash;\n        this.overviewControls.dash = this._oldDash;\n        this.searchController._showAppsButton = this._oldDash.showAppsButton;\n        Main.overview.dash.show();\n        Main.overview.dash.set_height(-1); // reset default dash size\n        // This force the recalculation of the icon size\n        Main.overview.dash._maxHeight = -1;\n    }\n\n    get overviewControls() {\n        return Main.overview._overview.controls;\n    }\n\n    get searchController() {\n        return this.overviewControls._searchController;\n    }\n\n    _onShowAppsButtonToggled(button) {\n        const {checked} = button;\n        const {overviewControls} = this;\n\n        if (!Main.overview.visible) {\n            this.mainDock.dash.showAppsButton._fromDesktop = true;\n            Main.overview.show(OverviewControls.ControlsState.APP_GRID);\n        } else if (!checked && this.mainDock.dash.showAppsButton._fromDesktop) {\n            Main.overview.hide();\n            this.mainDock.dash.showAppsButton._fromDesktop = false;\n        } else {\n            // TODO: I'm not sure how reliable this is, we might need to move the\n            // _onShowAppsButtonToggled logic into the extension.\n            if (!checked)\n                this.mainDock.dash.showAppsButton._fromDesktop = false;\n\n\n            // Instead of \"syncing\" the stock button, let's call its callback directly.\n            overviewControls._onShowAppsButtonToggled();\n        }\n\n        // Because we \"disconnected\" from the search controller, we have to manage its state.\n        this.searchController._setSearchActive(false);\n    }\n\n    _overrideAppMenus() {\n        this._methodInjections.add(AppMenu.AppMenu.prototype,\n            '_updateFavoriteItem', function (originalFunction, ...args) {\n                /* eslint-disable no-invalid-this */\n                originalFunction.call(this, ...args);\n                if (!this._toggleFavoriteItem.visible)\n                    return;\n\n                const {id} = this._app;\n                this._toggleFavoriteItem.label.text = this._appFavorites.isFavorite(id)\n                    ? _('Unpin') : _('Pin to Dock');\n                /* eslint-enable no-invalid-this */\n            });\n    }\n\n    destroy() {\n        this.emit('destroy');\n        if (this._toggleLater) {\n            Utils.laterRemove(this._toggleLater);\n            delete this._toggleLater;\n        }\n        this._restoreDash();\n        this._deleteDocks();\n        this._revertPanelCorners();\n        if (this._oldSelectorMargin)\n            this.searchController.margin_bottom = this._oldSelectorMargin;\n        if (this._fm1Client) {\n            this._fm1Client.destroy();\n            this._fm1Client = null;\n        }\n        this._notificationsMonitor.destroy();\n        this._appSpread.destroy();\n        this._trash?.destroy();\n        this._trash = null;\n        Locations.unWrapFileManagerApp();\n        this._removables?.destroy();\n        this._removables = null;\n        this._iconTheme = null;\n        this._remoteModel?.destroy();\n        this._appIconsDecorator?.destroy();\n        this._settings = null;\n        this._appSwitcherSettings = null;\n        this._oldDash = null;\n\n        this._desktopIconsUsableArea?.destroy();\n        this._desktopIconsUsableArea = null;\n        this._extension = null;\n        DockManager._singleton = null;\n    }\n\n    /**\n     * Adjust Panel corners, remove this when 41 won't be supported anymore\n     */\n    _adjustPanelCorners() {\n        if (!this._hasPanelCorners())\n            return;\n\n        const position = Utils.getPosition();\n        const isHorizontal = (position === St.Side.TOP) || (position === St.Side.BOTTOM);\n        const dockOnPrimary  = this._settings.multiMonitor ||\n                             this._preferredMonitorIndex === Main.layoutManager.primaryIndex;\n\n        if (!isHorizontal && dockOnPrimary && this.settings.dockExtended && this.settings.dockFixed) {\n            Main.panel._rightCorner.hide();\n            Main.panel._leftCorner.hide();\n        } else {\n            this._revertPanelCorners();\n        }\n    }\n\n    _revertPanelCorners() {\n        if (!this._hasPanelCorners())\n            return;\n\n        Main.panel._leftCorner.show();\n        Main.panel._rightCorner.show();\n    }\n\n    _hasPanelCorners() {\n        return !!Main.panel?._rightCorner && !!Main.panel?._leftCorner;\n    }\n}\nSignals.addSignalMethods(DockManager.prototype);\n\n// This class drives long-running icon animations, to keep them running in sync\n// with each other, and to save CPU by pausing them when the dock is hidden.\nexport class IconAnimator {\n    constructor(actor) {\n        this._count = 0;\n        this._started = false;\n        this._animations = {\n            wiggle: [],\n        };\n        this._timeline = new Clutter.Timeline({\n            duration: AnimationUtils.adjustAnimationTime(ICON_ANIMATOR_DURATION) || 1,\n            repeat_count: -1,\n            actor,\n        });\n\n        this._updateSettings();\n        this._settingsChangedId = St.Settings.get().connect('notify',\n            () => this._updateSettings());\n\n        this._timeline.connect('new-frame', () => {\n            const progress = this._timeline.get_progress();\n            const wiggleRotation = progress < 1 / 6 ? 15 * Math.sin(progress * 24 * Math.PI) : 0;\n            const wigglers = this._animations.wiggle;\n            for (let i = 0, iMax = wigglers.length; i < iMax; i++)\n                wigglers[i].target.rotation_angle_z = wiggleRotation;\n        });\n    }\n\n    _updateSettings() {\n        this._timeline.set_duration(\n            AnimationUtils.adjustAnimationTime(ICON_ANIMATOR_DURATION) || 1);\n    }\n\n    destroy() {\n        St.Settings.get().disconnect(this._settingsChangedId);\n        this._timeline.stop();\n        this._timeline = null;\n        for (const pairs of Object.values(this._animations)) {\n            for (let i = 0, iMax = pairs.length; i < iMax; i++) {\n                const pair = pairs[i];\n                pair.target.disconnect(pair.targetDestroyId);\n            }\n        }\n        this._animations = null;\n    }\n\n    pause() {\n        if (this._started && this._count > 0)\n            this._timeline.stop();\n\n        this._started = false;\n    }\n\n    start() {\n        if (!this._started && this._count > 0)\n            this._timeline.start();\n\n        this._started = true;\n    }\n\n    addAnimation(target, name) {\n        const targetDestroyId = target.connect('destroy',\n            () => this.removeAnimation(target, name));\n        this._animations[name].push({target, targetDestroyId});\n        if (this._started && this._count === 0)\n            this._timeline.start();\n\n        this._count++;\n    }\n\n    removeAnimation(target, name) {\n        const pairs = this._animations[name];\n        for (let i = 0, iMax = pairs.length; i < iMax; i++) {\n            const pair = pairs[i];\n            if (pair.target === target) {\n                target.disconnect(pair.targetDestroyId);\n                pairs.splice(i, 1);\n                this._count--;\n                if (this._started && this._count === 0)\n                    this._timeline.stop();\n\n                return;\n            }\n        }\n    }\n}\n"
        },
        {
          "name": "extension.js",
          "type": "blob",
          "size": 0.474609375,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {DockManager} from './docking.js';\nimport {Extension} from './dependencies/shell/extensions/extension.js';\n\n// We export this so it can be accessed by other extensions\nexport let dockManager;\n\nexport default class DashToDockExtension extends Extension.Extension {\n    enable() {\n        dockManager = new DockManager(this);\n    }\n\n    disable() {\n        dockManager?.destroy();\n        dockManager = null;\n    }\n}\n"
        },
        {
          "name": "fileManager1API.js",
          "type": "blob",
          "size": 6.662109375,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {GLib, Gio} from './dependencies/gi.js';\nconst {signals: Signals} = imports;\n\nimport {Utils} from './imports.js';\n\nconst FileManager1Iface = '<node><interface name=\"org.freedesktop.FileManager1\">\\\n                               <property name=\"OpenWindowsWithLocations\" type=\"a{sas}\" access=\"read\"/>\\\n                           </interface></node>';\n\nconst FileManager1Proxy = Gio.DBusProxy.makeProxyWrapper(FileManager1Iface);\n\nconst Labels = Object.freeze({\n    WINDOWS: Symbol('windows'),\n});\n\n/**\n * This class implements a client for the org.freedesktop.FileManager1 dbus\n * interface, and specifically for the OpenWindowsWithLocations property\n * which is published by Nautilus, but is not an official part of the interface.\n *\n * The property is a map from window identifiers to a list of locations open in\n * the window.\n */\nexport class FileManager1Client {\n    constructor() {\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._cancellable = new Gio.Cancellable();\n\n        this._windowsByPath = new Map();\n        this._windowsByLocation = new Map();\n        this._proxy = new FileManager1Proxy(Gio.DBus.session,\n            'org.freedesktop.FileManager1',\n            '/org/freedesktop/FileManager1',\n            (initable, error) => {\n            // Use async construction to avoid blocking on errors.\n                if (error) {\n                    if (!error.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))\n                        global.log(error);\n                } else {\n                    this._updateWindows();\n                    this._updateLocationMap();\n                }\n            }, this._cancellable);\n\n        this._signalsHandler.add([\n            this._proxy,\n            'g-properties-changed',\n            this._onPropertyChanged.bind(this),\n        ], [\n            // We must additionally listen for Screen events to know when to\n            // rebuild our location map when the set of available windows changes.\n            global.workspaceManager,\n            'workspace-added',\n            () => this._onWindowsChanged(),\n        ], [\n            global.workspaceManager,\n            'workspace-removed',\n            () => this._onWindowsChanged(),\n        ], [\n            global.display,\n            'window-entered-monitor',\n            () => this._onWindowsChanged(),\n        ], [\n            global.display,\n            'window-left-monitor',\n            () => this._onWindowsChanged(),\n        ]);\n    }\n\n    destroy() {\n        if (this._windowsUpdateIdle) {\n            GLib.source_remove(this._windowsUpdateIdle);\n            delete this._windowsUpdateIdle;\n        }\n        this._cancellable.cancel();\n        this._signalsHandler.destroy();\n        this._windowsByLocation.clear();\n        this._windowsByPath.clear();\n        this._proxy = null;\n    }\n\n    /**\n     * Return an array of windows that are showing a location or\n     * sub-directories of that location.\n     *\n     * @param location\n     */\n    getWindows(location) {\n        if (!location)\n            return [];\n\n        location += location.endsWith('/') ? '' : '/';\n        const windows = [];\n        this._windowsByLocation.forEach((wins, l) => {\n            if (l.startsWith(location))\n                windows.push(...wins);\n        });\n        return [...new Set(windows)];\n    }\n\n    _onPropertyChanged(proxy, changed, _invalidated) {\n        const property = changed.unpack();\n        if (property &&\n            ('OpenWindowsWithLocations' in property))\n            this._updateLocationMap();\n    }\n\n    _updateWindows() {\n        const oldSize = this._windowsByPath.size;\n        const oldPaths = this._windowsByPath.keys();\n        this._windowsByPath = Utils.getWindowsByObjectPath();\n\n        if (oldSize !== this._windowsByPath.size)\n            return true;\n\n        return [...oldPaths].some(path => !this._windowsByPath.has(path));\n    }\n\n    _onWindowsChanged() {\n        if (this._windowsUpdateIdle)\n            return;\n\n        this._windowsUpdateIdle = GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {\n            if (this._updateWindows())\n                this._updateLocationMap();\n\n            delete this._windowsUpdateIdle;\n            return GLib.SOURCE_REMOVE;\n        });\n    }\n\n    _updateLocationMap() {\n        const properties = this._proxy.get_cached_property_names();\n        if (!properties) {\n            // Nothing to check yet.\n            return;\n        }\n\n        if (properties.includes('OpenWindowsWithLocations'))\n            this._updateFromPaths();\n    }\n\n    _locationMapsEquals(mapA, mapB) {\n        if (mapA.size !== mapB.size)\n            return false;\n\n        const setsEquals = (a, b) => a.size === b.size &&\n            [...a].every(value => b.has(value));\n\n        for (const [key, val] of mapA) {\n            const windowsSet = mapB.get(key);\n            if (!windowsSet || !setsEquals(windowsSet, val))\n                return false;\n        }\n        return true;\n    }\n\n    _updateFromPaths() {\n        const locationsByWindowsPath = this._proxy.OpenWindowsWithLocations;\n\n        const windowsByLocation = new Map();\n        this._signalsHandler.removeWithLabel(Labels.WINDOWS);\n\n        Object.entries(locationsByWindowsPath).forEach(([windowPath, locations]) => {\n            locations.forEach(location => {\n                const win = this._windowsByPath.get(windowPath);\n                const windowGroup = win ? [win] : [];\n\n                win?.foreach_transient(w => windowGroup.push(w) || true);\n\n                windowGroup.forEach(window => {\n                    location += location.endsWith('/') ? '' : '/';\n                    // Use a set to deduplicate when a window has a\n                    // location open in multiple tabs.\n                    const windows = windowsByLocation.get(location) || new Set();\n                    windows.add(window);\n\n                    if (windows.size === 1)\n                        windowsByLocation.set(location, windows);\n\n                    this._signalsHandler.addWithLabel(Labels.WINDOWS, window,\n                        'unmanaged', () => {\n                            const wins = this._windowsByLocation.get(location);\n                            wins.delete(window);\n                            if (!wins.size)\n                                this._windowsByLocation.delete(location);\n                            this.emit('windows-changed');\n                        });\n                });\n            });\n        });\n\n        if (!this._locationMapsEquals(this._windowsByLocation, windowsByLocation)) {\n            this._windowsByLocation = windowsByLocation;\n            this.emit('windows-changed');\n        }\n    }\n}\nSignals.addSignalMethods(FileManager1Client.prototype);\n"
        },
        {
          "name": "imports.js",
          "type": "blob",
          "size": 0.8388671875,
          "content": "export * as AppIconIndicators from './appIconIndicators.js';\nexport * as AppIcons from './appIcons.js';\nexport * as AppIconsDecorator from './appIconsDecorator.js';\nexport * as AppSpread from './appSpread.js';\nexport * as DockDash from './dash.js';\nexport * as DBusMenuUtils from './dbusmenuUtils.js';\nexport * as DesktopIconsIntegration from './desktopIconsIntegration.js';\nexport * as Docking from './docking.js';\nexport * as Extension from './extension.js';\nexport * as FileManager1API from './fileManager1API.js';\nexport * as Intellihide from './intellihide.js';\nexport * as LauncherAPI from './launcherAPI.js';\nexport * as Locations from './locations.js';\nexport * as NotificationsMonitor from './notificationsMonitor.js';\nexport * as Theming from './theming.js';\nexport * as Utils from './utils.js';\nexport * as WindowPreview from './windowPreview.js';\n"
        },
        {
          "name": "intellihide.js",
          "type": "blob",
          "size": 11.1142578125,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {\n    GLib,\n    Meta,\n    Shell,\n} from './dependencies/gi.js';\n\nimport {\n    Docking,\n    Utils,\n} from './imports.js';\n\nconst {signals: Signals} = imports;\n\n// A good compromise between reactivity and efficiency; to be tuned.\nconst INTELLIHIDE_CHECK_INTERVAL = 100;\n\nconst OverlapStatus = Object.freeze({\n    UNDEFINED: -1,\n    FALSE: 0,\n    TRUE: 1,\n});\n\nconst IntellihideMode = Object.freeze({\n    ALL_WINDOWS: 0,\n    FOCUS_APPLICATION_WINDOWS: 1,\n    MAXIMIZED_WINDOWS: 2,\n    ALWAYS_ON_TOP: 3,\n});\n\n// List of windows type taken into account. Order is important (keep the original\n// enum order).\nconst handledWindowTypes = [\n    Meta.WindowType.NORMAL,\n    Meta.WindowType.DOCK,\n    Meta.WindowType.DIALOG,\n    Meta.WindowType.MODAL_DIALOG,\n    Meta.WindowType.TOOLBAR,\n    Meta.WindowType.MENU,\n    Meta.WindowType.UTILITY,\n    Meta.WindowType.SPLASHSCREEN,\n    Meta.WindowType.DROPDOWN_MENU,\n];\n\n// List of applications, ignore windows of these applications in considering intellihide\nconst ignoreApps = ['com.rastersoft.ding', 'com.desktop.ding'];\n\n/**\n * A rough and ugly implementation of the intellihide behaviour.\n * Intallihide object: emit 'status-changed' signal when the overlap of windows\n * with the provided targetBoxClutter.ActorBox changes;\n */\nexport class Intellihide {\n    constructor(monitorIndex) {\n        // Load settings\n        this._monitorIndex = monitorIndex;\n\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._tracker = Shell.WindowTracker.get_default();\n        this._focusApp = null; // The application whose window is focused.\n        this._topApp = null; // The application whose window is on top on the monitor with the dock.\n\n        this._isEnabled = false;\n        this.status = OverlapStatus.UNDEFINED;\n        this._targetBox = null;\n\n        this._checkOverlapTimeoutContinue = false;\n        this._checkOverlapTimeoutId = 0;\n\n        this._trackedWindows = new Map();\n\n        // Connect global signals\n        this._signalsHandler.add([\n            // Add signals on windows created from now on\n            global.display,\n            'window-created',\n            this._windowCreated.bind(this),\n        ], [\n            // triggered for instance when the window list order changes,\n            // included when the workspace is switched\n            global.display,\n            'restacked',\n            this._checkOverlap.bind(this),\n        ], [\n            // when windows are alwasy on top, the focus window can change\n            // without the windows being restacked. Thus monitor window focus change.\n            this._tracker,\n            'notify::focus-app',\n            this._checkOverlap.bind(this),\n        ], [\n            // update wne monitor changes, for instance in multimonitor when monitor are attached\n            Utils.getMonitorManager(),\n            'monitors-changed',\n            this._checkOverlap.bind(this),\n        ]);\n    }\n\n    destroy() {\n        // Disconnect global signals\n        this._signalsHandler.destroy();\n\n        // Remove  residual windows signals\n        this.disable();\n    }\n\n    enable() {\n        this._isEnabled = true;\n        this._status = OverlapStatus.UNDEFINED;\n        global.get_window_actors().forEach(function (wa) {\n            this._addWindowSignals(wa);\n        }, this);\n        this._doCheckOverlap();\n    }\n\n    disable() {\n        this._isEnabled = false;\n\n        for (const wa of this._trackedWindows.keys())\n            this._removeWindowSignals(wa);\n\n        this._trackedWindows.clear();\n\n        if (this._checkOverlapTimeoutId > 0) {\n            GLib.source_remove(this._checkOverlapTimeoutId);\n            this._checkOverlapTimeoutId = 0;\n        }\n    }\n\n    _windowCreated(display, metaWindow) {\n        this._addWindowSignals(metaWindow.get_compositor_private());\n        this._doCheckOverlap();\n    }\n\n    _addWindowSignals(wa) {\n        if (!this._handledWindow(wa))\n            return;\n        const signalId = wa.connect('notify::allocation', this._checkOverlap.bind(this));\n        this._trackedWindows.set(wa, signalId);\n        wa.connect('destroy', this._removeWindowSignals.bind(this));\n    }\n\n    _removeWindowSignals(wa) {\n        if (this._trackedWindows.get(wa)) {\n            wa.disconnect(this._trackedWindows.get(wa));\n            this._trackedWindows.delete(wa);\n        }\n    }\n\n    updateTargetBox(box) {\n        this._targetBox = box;\n        this._checkOverlap();\n    }\n\n    forceUpdate() {\n        this._status = OverlapStatus.UNDEFINED;\n        this._doCheckOverlap();\n    }\n\n    getOverlapStatus() {\n        return this._status === OverlapStatus.TRUE;\n    }\n\n    _checkOverlap() {\n        if (!this._isEnabled || !this._targetBox)\n            return;\n\n        /* Limit the number of calls to the doCheckOverlap function */\n        if (this._checkOverlapTimeoutId) {\n            this._checkOverlapTimeoutContinue = true;\n            return;\n        }\n\n        this._doCheckOverlap();\n\n        this._checkOverlapTimeoutId = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT, INTELLIHIDE_CHECK_INTERVAL, () => {\n                this._doCheckOverlap();\n                if (this._checkOverlapTimeoutContinue) {\n                    this._checkOverlapTimeoutContinue = false;\n                    return GLib.SOURCE_CONTINUE;\n                } else {\n                    this._checkOverlapTimeoutId = 0;\n                    return GLib.SOURCE_REMOVE;\n                }\n            });\n    }\n\n    _doCheckOverlap() {\n        if (!this._isEnabled || !this._targetBox)\n            return;\n\n        let overlaps = OverlapStatus.FALSE;\n        let windows = global.get_window_actors().filter(wa => this._handledWindow(wa));\n\n        if (windows.length > 0) {\n            /*\n             * Get the top window on the monitor where the dock is placed.\n             * The idea is that we dont want to overlap with the windows of the topmost application,\n             * event is it's not the focused app -- for instance because in multimonitor the user\n             * select a window in the secondary monitor.\n             */\n\n            let topWindow = null;\n            for (let i = windows.length - 1; i >= 0; i--) {\n                const metaWin = windows[i].get_meta_window();\n                if (metaWin.get_monitor() === this._monitorIndex) {\n                    topWindow = metaWin;\n                    break;\n                }\n            }\n\n            if (topWindow) {\n                this._topApp = this._tracker.get_window_app(topWindow);\n                // If there isn't a focused app, use that of the window on top\n                this._focusApp = this._tracker.focus_app || this._topApp;\n\n                windows = windows.filter(this._intellihideFilterInteresting, this);\n\n                for (let i = 0;  i < windows.length; i++) {\n                    const win = windows[i].get_meta_window();\n\n                    if (win) {\n                        const rect = win.get_frame_rect();\n\n                        const test = (rect.x < this._targetBox.x2) &&\n                                   (rect.x + rect.width > this._targetBox.x1) &&\n                                   (rect.y < this._targetBox.y2) &&\n                                   (rect.y + rect.height > this._targetBox.y1);\n\n                        if (test) {\n                            overlaps = OverlapStatus.TRUE;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (this._status !== overlaps) {\n            this._status = overlaps;\n            this.emit('status-changed', this._status);\n        }\n    }\n\n    // Filter interesting windows to be considered for intellihide.\n    // Consider all windows visible on the current workspace.\n    // Optionally skip windows of other applications\n    _intellihideFilterInteresting(wa) {\n        const metaWin = wa.get_meta_window();\n        const currentWorkspace = global.workspace_manager.get_active_workspace_index();\n        const workspace = metaWin.get_workspace();\n        const workspaceIndex = workspace.index();\n\n        // Depending on the intellihide mode, exclude non-relevent windows\n        switch (Docking.DockManager.settings.intellihideMode) {\n        case IntellihideMode.ALL_WINDOWS:\n            // Do nothing\n            break;\n\n        case IntellihideMode.FOCUS_APPLICATION_WINDOWS:\n            // Skip windows of other apps\n            if (this._focusApp) {\n                // The DropDownTerminal extension is not an application per se\n                // so we match its window by wm class instead\n                if (metaWin.get_wm_class() === 'DropDownTerminalWindow')\n                    return true;\n\n                const currentApp = this._tracker.get_window_app(metaWin);\n                const focusWindow = global.display.get_focus_window();\n\n                // Consider half maximized windows side by side\n                // and windows which are alwayson top\n                if (currentApp !== this._focusApp && currentApp !== this._topApp &&\n                    !((focusWindow && focusWindow.maximized_vertically &&\n                       !focusWindow.maximized_horizontally) &&\n                     (metaWin.maximized_vertically && !metaWin.maximized_horizontally) &&\n                     metaWin.get_monitor() === focusWindow.get_monitor()) &&\n                        !metaWin.is_above())\n                    return false;\n            }\n            break;\n\n        case IntellihideMode.MAXIMIZED_WINDOWS:\n            // Skip unmaximized windows\n            if (!metaWin.maximized_vertically && !metaWin.maximized_horizontally && !metaWin.fullscreen)\n                return false;\n            break;\n\n        case IntellihideMode.ALWAYS_ON_TOP:\n            // Always on top, except for fullscreen windows\n            if (this._focusApp) {\n                const {focusWindow} = global.display;\n                if (!focusWindow?.fullscreen)\n                    return false;\n            }\n            break;\n        }\n\n        if (workspaceIndex === currentWorkspace && metaWin.showing_on_its_workspace())\n            return true;\n        else\n            return false;\n    }\n\n    // Filter windows by type\n    // inspired by Opacify@gnome-shell.localdomain.pl\n    _handledWindow(wa) {\n        const metaWindow = wa.get_meta_window();\n\n        if (!metaWindow)\n            return false;\n\n        // The DING extension desktop window needs to be excluded\n        // so we match its window by application id and window property.\n        const wmApp = metaWindow.get_gtk_application_id();\n        if (ignoreApps.includes(wmApp) && metaWindow.is_skip_taskbar())\n            return false;\n\n        // The DropDownTerminal extension uses the POPUP_MENU window type hint\n        // so we match its window by wm class instead\n        if (metaWindow.get_wm_class() === 'DropDownTerminalWindow')\n            return true;\n\n        const wtype = metaWindow.get_window_type();\n        for (let i = 0; i < handledWindowTypes.length; i++) {\n            const hwtype = handledWindowTypes[i];\n            if (hwtype === wtype)\n                return true;\n            else if (hwtype > wtype)\n                return false;\n        }\n        return false;\n    }\n}\n\nSignals.addSignalMethods(Intellihide.prototype);\n"
        },
        {
          "name": "launcherAPI.js",
          "type": "blob",
          "size": 9.2197265625,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {Gio} from './dependencies/gi.js';\nimport {DBusMenuUtils} from './imports.js';\n\nconst DBusMenu = await DBusMenuUtils.haveDBusMenu();\n\nexport class LauncherEntryRemoteModel {\n    constructor() {\n        this._entrySourceStacks = new Map();\n        this._remoteMaps = new Map();\n\n        this._launcher_entry_dbus_signal_id =\n            Gio.DBus.session.signal_subscribe(null, // sender\n                'com.canonical.Unity.LauncherEntry', // iface\n                'Update', // member\n                null, // path\n                null, // arg0\n                Gio.DBusSignalFlags.NONE,\n                (_connection, senderName, _objectPath, _interfaceName, _signalName, parameters) =>\n                    this._onUpdate(senderName, ...parameters.deep_unpack()));\n\n        this._dbus_name_owner_changed_signal_id =\n            Gio.DBus.session.signal_subscribe('org.freedesktop.DBus',  // sender\n                'org.freedesktop.DBus',  // interface\n                'NameOwnerChanged',      // member\n                '/org/freedesktop/DBus', // path\n                null,                    // arg0\n                Gio.DBusSignalFlags.NONE,\n                (connection, _senderName, _objectPath, _interfaceName, _signalName, parameters) =>\n                    this._onDBusNameChange(...parameters.deep_unpack().slice(1)));\n\n        this._acquireUnityDBus();\n    }\n\n    destroy() {\n        if (this._launcher_entry_dbus_signal_id)\n            Gio.DBus.session.signal_unsubscribe(this._launcher_entry_dbus_signal_id);\n\n\n        if (this._dbus_name_owner_changed_signal_id)\n            Gio.DBus.session.signal_unsubscribe(this._dbus_name_owner_changed_signal_id);\n\n\n        this._releaseUnityDBus();\n    }\n\n    _lookupStackById(appId) {\n        let sourceStack = this._entrySourceStacks.get(appId);\n        if (!sourceStack) {\n            sourceStack = new PropertySourceStack(new LauncherEntry(),\n                launcherEntryDefaults);\n            this._entrySourceStacks.set(appId, sourceStack);\n        }\n\n        return sourceStack;\n    }\n\n    lookupById(appId) {\n        return this._lookupStackById(appId).target;\n    }\n\n    _acquireUnityDBus() {\n        if (!this._unity_bus_id) {\n            this._unity_bus_id = Gio.DBus.session.own_name('com.canonical.Unity',\n                Gio.BusNameOwnerFlags.ALLOW_REPLACEMENT | Gio.BusNameOwnerFlags.REPLACE,\n                null, () => (this._unity_bus_id = 0));\n        }\n    }\n\n    _releaseUnityDBus() {\n        if (this._unity_bus_id) {\n            Gio.DBus.session.unown_name(this._unity_bus_id);\n            this._unity_bus_id = 0;\n        }\n    }\n\n    _onDBusNameChange(before, after) {\n        if (!before || !this._remoteMaps.size)\n            return;\n\n        const remoteMap = this._remoteMaps.get(before);\n        if (!remoteMap)\n            return;\n\n        this._remoteMaps.delete(before);\n        if (after && !this._remoteMaps.has(after)) {\n            this._remoteMaps.set(after, remoteMap);\n        } else {\n            for (const [appId, remote] of remoteMap) {\n                const sourceStack = this._entrySourceStacks.get(appId);\n                const changed = sourceStack.remove(remote);\n                if (changed)\n                    sourceStack.target._emitChangedEvents(changed);\n            }\n        }\n    }\n\n    _onUpdate(senderName, appUri, properties) {\n        if (!senderName)\n            return;\n\n\n        const appId = appUri.replace(/(^\\w+:|^)\\/\\//, '');\n        if (!appId)\n            return;\n\n\n        let remoteMap = this._remoteMaps.get(senderName);\n        if (!remoteMap)\n            this._remoteMaps.set(senderName, remoteMap = new Map());\n\n        let remote = remoteMap.get(appId);\n        if (!remote)\n            remoteMap.set(appId, remote = Object.assign({}, launcherEntryDefaults));\n\n        for (const name in properties) {\n            if (name === 'quicklist' && DBusMenu) {\n                const quicklistPath = properties[name].unpack();\n                if (quicklistPath &&\n                    (!remote._quicklistMenuClient ||\n                     remote._quicklistMenuClient.dbus_object !== quicklistPath)) {\n                    remote.quicklist = null;\n                    let menuClient = remote._quicklistMenuClient;\n                    if (menuClient) {\n                        menuClient.dbus_object = quicklistPath;\n                    } else {\n                        // This property should not be enumerable\n                        Object.defineProperty(remote, '_quicklistMenuClient', {\n                            writable: true,\n                            value: menuClient = new DBusMenu.Client({\n                                dbus_name: senderName,\n                                dbus_object: quicklistPath,\n                            }),\n                        });\n                    }\n                    const handler = () => {\n                        const root = menuClient.get_root();\n                        if (remote.quicklist !== root) {\n                            remote.quicklist = root;\n                            if (sourceStack.isTop(remote)) {\n                                sourceStack.target.quicklist = root;\n                                sourceStack.target._emitChangedEvents(['quicklist']);\n                            }\n                        }\n                    };\n                    menuClient.connect(DBusMenu.CLIENT_SIGNAL_ROOT_CHANGED, handler);\n                }\n            } else {\n                remote[name] = properties[name].unpack();\n            }\n        }\n\n        const sourceStack = this._lookupStackById(appId);\n        sourceStack.target._emitChangedEvents(sourceStack.update(remote));\n    }\n}\n\nconst launcherEntryDefaults = Object.freeze({\n    count: 0,\n    progress: 0,\n    urgent: false,\n    updating: false,\n    quicklist: null,\n    'count-visible': false,\n    'progress-visible': false,\n});\n\nconst LauncherEntry = class DashToDockLauncherEntry {\n    constructor() {\n        this._connections = new Map();\n        this._handlers = new Map();\n        this._nextId = 0;\n    }\n\n    connect(eventNames, callback) {\n        if (typeof eventNames === 'string')\n            eventNames = [eventNames];\n\n        callback(this, this);\n        const id = this._nextId++;\n        const handler = {id, callback};\n        eventNames.forEach(name => {\n            let handlerList = this._handlers.get(name);\n            if (!handlerList)\n                this._handlers.set(name, handlerList = []);\n\n            handlerList.push(handler);\n        });\n        this._connections.set(id, eventNames);\n        return id;\n    }\n\n    disconnect(id) {\n        const eventNames = this._connections.get(id);\n        if (!eventNames)\n            return;\n\n        this._connections.delete(id);\n        eventNames.forEach(name => {\n            const handlerList = this._handlers.get(name);\n            if (handlerList) {\n                for (let i = 0, iMax = handlerList.length; i < iMax; i++) {\n                    if (handlerList[i].id === id) {\n                        handlerList.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n        });\n    }\n\n    _emitChangedEvents(propertyNames) {\n        const handlers = new Set();\n        propertyNames.forEach(name => {\n            const handlerList = this._handlers.get(`${name}-changed`);\n            if (handlerList) {\n                for (let i = 0, iMax = handlerList.length; i < iMax; i++)\n                    handlers.add(handlerList[i]);\n            }\n        });\n        Array.from(handlers).sort((x, y) => x.id - y.id).forEach(handler => handler.callback(this, this));\n    }\n};\n\nfor (const [name, defaultValue] of Object.entries(launcherEntryDefaults)) {\n    const jsName = name.replaceAll('-', '_');\n    LauncherEntry.prototype[jsName] = defaultValue;\n    if (jsName !== name) {\n        Object.defineProperty(LauncherEntry.prototype, name, {\n            get() {\n                return this[jsName];\n            },\n            set(value) {\n                this[jsName] = value;\n            },\n        });\n    }\n}\n\nconst PropertySourceStack = class DashToDockPropertySourceStack {\n    constructor(target, bottom) {\n        this.target = target;\n        this._bottom = bottom;\n        this._stack = [];\n    }\n\n    isTop(source) {\n        return this._stack.length > 0 && this._stack[this._stack.length - 1] === source;\n    }\n\n    update(source) {\n        if (!this.isTop(source)) {\n            this.remove(source);\n            this._stack.push(source);\n        }\n        return this._assignFrom(source);\n    }\n\n    remove(source) {\n        const stack = this._stack;\n        const top = stack[stack.length - 1];\n        if (top === source) {\n            stack.length--;\n            return this._assignFrom(stack.length > 0 ? stack[stack.length - 1] : this._bottom);\n        }\n        for (let i = 0, iMax = stack.length; i < iMax; i++) {\n            if (stack[i] === source) {\n                stack.splice(i, 1);\n                break;\n            }\n        }\n\n        return null;\n    }\n\n    _assignFrom(source) {\n        const changedProperties = [];\n        for (const name in source) {\n            if (this.target[name] !== source[name]) {\n                this.target[name] = source[name];\n                changedProperties.push(name);\n            }\n        }\n        return changedProperties;\n    }\n};\n"
        },
        {
          "name": "lint",
          "type": "tree",
          "content": null
        },
        {
          "name": "locations.js",
          "type": "blob",
          "size": 48.3623046875,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {\n    Gio,\n    GLib,\n    GObject,\n    Shell,\n    St,\n} from './dependencies/gi.js';\n\nimport {ShellMountOperation} from './dependencies/shell/ui.js';\n\nimport {\n    Docking,\n    Utils,\n} from './imports.js';\n\nimport {Extension} from './dependencies/shell/extensions/extension.js';\n\n// Use __ () and N__() for the extension gettext domain, and reuse\n// the shell domain with the default _() and N_()\nconst {gettext: __} = Extension;\n\nconst {signals: Signals} = imports;\n\nconst FALLBACK_REMOVABLE_MEDIA_ICON = 'drive-removable-media';\nconst FALLBACK_TRASH_ICON = 'user-trash';\nconst FILE_MANAGER_DESKTOP_APP_ID = 'org.gnome.Nautilus.desktop';\nconst ATTRIBUTE_METADATA_CUSTOM_ICON = 'metadata::custom-icon';\nconst TRASH_URI = 'trash://';\nconst UPDATE_TRASH_DELAY = 1000;\nconst LAUNCH_HANDLER_MAX_WAIT = 200;\n\nconst NautilusFileOperations2Interface = '<node>\\\n    <interface name=\"org.gnome.Nautilus.FileOperations2\">\\\n        <method name=\"EmptyTrash\">\\\n            <arg type=\"b\" name=\"ask_confirmation\" direction=\"in\"/>\\\n            <arg type=\"a{sv}\" name=\"platform_data\" direction=\"in\"/>\\\n        </method>\\\n    </interface>\\\n</node>';\n\nconst NautilusFileOperations2ProxyInterface =\n    Gio.DBusProxy.makeProxyWrapper(NautilusFileOperations2Interface);\n\nconst Labels = Object.freeze({\n    LOCATION_WINDOWS: Symbol('location-windows'),\n    WINDOWS_CHANGED: Symbol('windows-changed'),\n});\n\nconst GJS_SUPPORTS_FILE_IFACE_PROMISES = imports.system.version >= 17101;\n\nif (GJS_SUPPORTS_FILE_IFACE_PROMISES) {\n    Gio._promisify(Gio.File.prototype, 'query_info_async');\n    Gio._promisify(Gio.File.prototype, 'query_default_handler_async');\n}\n\n\n/**\n *\n */\nfunction makeNautilusFileOperationsProxy() {\n    const proxy = new NautilusFileOperations2ProxyInterface(\n        Gio.DBus.session,\n        'org.gnome.Nautilus',\n        '/org/gnome/Nautilus/FileOperations2', (_p, error) => {\n            if (error)\n                logError(error, 'Error connecting to Nautilus');\n        }\n    );\n\n    proxy.platformData = params => {\n        const defaultParams = {\n            parentHandle: '',\n            timestamp: global.get_current_time(),\n            windowPosition: 'center',\n        };\n        const {parentHandle, timestamp, windowPosition} = {\n            ...defaultParams,\n            ...params,\n        };\n\n        return {\n            'parent-handle': new GLib.Variant('s', parentHandle),\n            'timestamp': new GLib.Variant('u', timestamp),\n            'window-position': new GLib.Variant('s', windowPosition),\n        };\n    };\n\n    return proxy;\n}\n\nexport const LocationAppInfo = GObject.registerClass({\n    Implements: [Gio.AppInfo],\n    Properties: {\n        'location': GObject.ParamSpec.object(\n            'location', 'location', 'location',\n            GObject.ParamFlags.READWRITE,\n            Gio.File.$gtype),\n        'name': GObject.ParamSpec.string(\n            'name', 'name', 'name',\n            GObject.ParamFlags.READWRITE,\n            null),\n        'icon': GObject.ParamSpec.object(\n            'icon', 'icon', 'icon',\n            GObject.ParamFlags.READWRITE,\n            Gio.Icon.$gtype),\n        'cancellable': GObject.ParamSpec.object(\n            'cancellable', 'cancellable', 'cancellable',\n            GObject.ParamFlags.READWRITE,\n            Gio.Cancellable.$gtype),\n    },\n}, class LocationAppInfo extends Gio.DesktopAppInfo {\n    static get GJS_BINARY_PATH() {\n        if (!this._gjsBinaryPath)\n            this._gjsBinaryPath = GLib.find_program_in_path('gjs');\n\n        return this._gjsBinaryPath;\n    }\n\n    list_actions() {\n        return [];\n    }\n\n    get_action_name() {\n        return null;\n    }\n\n    get_boolean() {\n        return false;\n    }\n\n    vfunc_dup() {\n        return new LocationAppInfo({\n            location: this.location,\n            name: this.name,\n            icon: this.icon,\n            cancellable: this.cancellable,\n        });\n    }\n\n    vfunc_equal(other) {\n        if (this.location)\n            return this.location.equal(other?.location);\n\n        return this.name === other.name &&\n            (this.icon ? this.icon.equal(other?.icon) : !other?.icon);\n    }\n\n    vfunc_get_id() {\n        return 'location:%s'.format(this.location?.get_uri());\n    }\n\n    vfunc_get_name() {\n        return this.name;\n    }\n\n    vfunc_get_description() {\n        return null;\n    }\n\n    vfunc_get_executable() {\n        return null;\n    }\n\n    vfunc_get_icon() {\n        return this.icon;\n    }\n\n    vfunc_launch(files, context) {\n        if (files?.length) {\n            throw new GLib.Error(Gio.IOErrorEnum,\n                Gio.IOErrorEnum.NOT_SUPPORTED, 'Launching with files not supported');\n        }\n\n        return this.getHandlerApp().launch_uris([this.location.get_uri()], context);\n    }\n\n    vfunc_supports_uris() {\n        return false;\n    }\n\n    vfunc_supports_files() {\n        return false;\n    }\n\n    vfunc_launch_uris(uris, context) {\n        return this.launch(uris, context);\n    }\n\n    vfunc_should_show() {\n        return true;\n    }\n\n    vfunc_set_as_default_for_type() {\n        throw new GLib.Error(Gio.IOErrorEnum,\n            Gio.IOErrorEnum.NOT_SUPPORTED, 'Not supported');\n    }\n\n    vfunc_set_as_default_for_extension() {\n        throw new GLib.Error(Gio.IOErrorEnum,\n            Gio.IOErrorEnum.NOT_SUPPORTED, 'Not supported');\n    }\n\n    vfunc_add_supports_type() {\n        throw new GLib.Error(Gio.IOErrorEnum,\n            Gio.IOErrorEnum.NOT_SUPPORTED, 'Not supported');\n    }\n\n    vfunc_can_remove_supports_type() {\n        return false;\n    }\n\n    vfunc_remove_supports_type() {\n        return false;\n    }\n\n    vfunc_can_delete() {\n        return false;\n    }\n\n    vfunc_do_delete() {\n        return false;\n    }\n\n    vfunc_get_commandline() {\n        try {\n            return this.getHandlerApp().get_commandline();\n        } catch {\n            return this._getFallbackCommandLine();\n        }\n    }\n\n    vfunc_get_display_name() {\n        return this.name;\n    }\n\n    vfunc_set_as_last_used_for_type() {\n        throw new GLib.Error(Gio.IOErrorEnum,\n            Gio.IOErrorEnum.NOT_SUPPORTED, 'Not supported');\n    }\n\n    vfunc_get_supported_types() {\n        return [];\n    }\n\n    _getFallbackCommandLine() {\n        return `gio open ${this.location?.get_uri()}`;\n    }\n\n    async _queryLocationIcons(params) {\n        const icons = {standard: null, custom: null};\n        if (!this.location)\n            return icons;\n\n        const cancellable = params.cancellable ?? this.cancellable;\n        const iconsQuery = [];\n        if (params?.standard)\n            iconsQuery.push(Gio.FILE_ATTRIBUTE_STANDARD_ICON);\n\n        if (params?.custom)\n            iconsQuery.push(ATTRIBUTE_METADATA_CUSTOM_ICON);\n\n        if (!iconsQuery.length)\n            throw new Error('Invalid Query Location Icons parameters');\n\n        let info;\n        try {\n            if (!GJS_SUPPORTS_FILE_IFACE_PROMISES) {\n                Gio._promisify(this.location.constructor.prototype,\n                    'query_info_async', 'query_info_finish');\n            }\n            info = await this.location.query_info_async(\n                iconsQuery.join(','),\n                Gio.FileQueryInfoFlags.NONE,\n                GLib.PRIORITY_LOW, cancellable);\n            if (info.has_attribute(Gio.FILE_ATTRIBUTE_STANDARD_ICON))\n                icons.standard = info.get_icon();\n        } catch (e) {\n            if (e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.NOT_FOUND) ||\n                e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.NOT_MOUNTED))\n                return icons;\n            throw e;\n        }\n\n        const customIcon = info.get_attribute_string(ATTRIBUTE_METADATA_CUSTOM_ICON);\n        if (customIcon) {\n            const customIconFile = GLib.uri_parse_scheme(customIcon)\n                ? Gio.File.new_for_uri(customIcon) : Gio.File.new_for_path(customIcon);\n            const iconFileInfo = await customIconFile.query_info_async(\n                Gio.FILE_ATTRIBUTE_STANDARD_TYPE,\n                Gio.FileQueryInfoFlags.NONE,\n                GLib.PRIORITY_LOW, cancellable);\n\n            if (iconFileInfo.get_file_type() === Gio.FileType.REGULAR)\n                icons.custom = Gio.FileIcon.new(customIconFile);\n        }\n\n        return icons;\n    }\n\n    async _updateLocationIcon(params = {standard: true, custom: true}) {\n        const cancellable = new Utils.CancellableChild(this.cancellable);\n\n        try {\n            this._updateIconCancellable?.cancel();\n            this._updateIconCancellable = cancellable;\n\n            const icons = await this._queryLocationIcons({cancellable, ...params});\n            const icon = icons.custom ?? icons.standard;\n\n            if (icon && !icon.equal(this.icon))\n                this.icon = icon;\n        } catch (e) {\n            if (!e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))\n                logError(e, 'Impossible to update icon for %s'.format(this.get_id()));\n        } finally {\n            cancellable.cancel();\n            if (this._updateIconCancellable === cancellable)\n                delete this._updateIconCancellable;\n        }\n    }\n\n    async _getHandlerAppAsync(cancellable) {\n        if (!this.location)\n            return null;\n\n        try {\n            if (!GJS_SUPPORTS_FILE_IFACE_PROMISES) {\n                Gio._promisify(this.location.constructor.prototype,\n                    'query_default_handler_async',\n                    'query_default_handler_finish');\n            }\n\n            return await this.location.query_default_handler_async(\n                GLib.PRIORITY_DEFAULT, cancellable);\n        } catch (e) {\n            if (e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.NOT_MOUNTED))\n                return getFileManagerApp()?.appInfo;\n\n            if (!e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED)) {\n                logError(e, 'Impossible to find an URI handler for %s'.format(\n                    this.get_id()));\n            }\n\n            throw e;\n        }\n    }\n\n    _getHandlerAppFromWorker(cancellable) {\n        const locationsWorker = GLib.build_filenamev([\n            Docking.DockManager.extension.path,\n            'locationsWorker.js',\n        ]);\n        const locationsWorkerArgs = [LocationAppInfo.GJS_BINARY_PATH, '-m',\n            locationsWorker, 'handler', this.location.get_uri(),\n            '--timeout', `${LAUNCH_HANDLER_MAX_WAIT}`];\n        const subProcess = Gio.Subprocess.new(locationsWorkerArgs,\n            Gio.SubprocessFlags.STDOUT_PIPE | Gio.SubprocessFlags.STDERR_PIPE);\n\n        try {\n            const [, stdOut, stdErr] = subProcess.communicate(null, cancellable);\n            subProcess.wait(cancellable);\n            const errorCode = subProcess.get_exit_status();\n            const textDecoder = new TextDecoder();\n\n            if (errorCode) {\n                const errorLines = textDecoder.decode(stdErr.toArray()).split('\\n');\n                const error = new GLib.Error(Gio.IOErrorEnum,\n                    errorCode === GLib.MAXUINT8 ? 0 : errorCode, errorLines[0]);\n                error.stack = `${errorLines.slice(3).join('\\n')}${error.stack}`;\n                throw error;\n            }\n\n            const desktopId = textDecoder.decode(stdOut.toArray()).trim();\n            const handlerApp = Shell.AppSystem.get_default().lookup_app(desktopId)?.appInfo;\n            return handlerApp;\n        } finally {\n            subProcess.force_exit();\n        }\n    }\n\n    getHandlerApp() {\n        if (this._handlerApp)\n            return this._handlerApp;\n\n        if (!this.location)\n            return null;\n\n        const cancellable = new Utils.CancellableChild(this.cancellable);\n\n        try {\n            if (LocationAppInfo.GJS_BINARY_PATH)\n                this._handlerApp = this._getHandlerAppFromWorker(cancellable);\n            else\n                this._handlerApp = this.location.query_default_handler(cancellable);\n\n            if (!this._handlerApp) {\n                throw new GLib.Error(Gio.IOErrorEnum,\n                    Gio.IOErrorEnum.NOT_FOUND, `Handler for ${this.location} not found`);\n            }\n        } catch (e) {\n            if (e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.NOT_MOUNTED))\n                return getFileManagerApp()?.appInfo;\n\n            if (!e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED)) {\n                logError(e, 'Impossible to find an URI handler for %s'.format(\n                    this.get_id()));\n            }\n\n            throw e;\n        }\n\n        return this._handlerApp;\n    }\n\n    destroy() {\n        this.location = null;\n        this.icon = null;\n        this.name = null;\n        this._handlerApp = null;\n        this.cancellable?.cancel();\n    }\n});\n\nconst MountableVolumeAppInfo = GObject.registerClass({\n    Implements: [Gio.AppInfo],\n    Properties: {\n        'volume': GObject.ParamSpec.object(\n            'volume', 'volume', 'volume',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            Gio.Volume.$gtype),\n        'mount': GObject.ParamSpec.object(\n            'mount', 'mount', 'mount',\n            GObject.ParamFlags.READWRITE,\n            Gio.Mount.$gtype),\n        'busy': GObject.ParamSpec.boolean(\n            'busy', 'busy', 'busy',\n            GObject.ParamFlags.READWRITE,\n            false),\n    },\n},\nclass MountableVolumeAppInfo extends LocationAppInfo {\n    _init(volume, cancellable = null) {\n        super._init({\n            volume,\n            cancellable,\n        });\n\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n\n        const updateAndMonitor = () => {\n            this._update();\n            this._monitorChanges();\n        };\n        updateAndMonitor();\n        this._mountChanged = this.connect('notify::mount', updateAndMonitor);\n\n        if (!this.mount && this.volume.get_identifier('class') === 'network') {\n            // For some devices the mount point isn't advertised promptly\n            // even if it's already existing, and there's no signaling about\n            this._lazyUpdater = GLib.timeout_add_seconds(GLib.PRIORITY_DEFAULT, 2, () => {\n                this._update();\n                delete this._lazyUpdater;\n                return GLib.SOURCE_REMOVE;\n            });\n        }\n    }\n\n    get busy() {\n        return !!this._currentAction;\n    }\n\n    get currentAction() {\n        return this._currentAction;\n    }\n\n    destroy() {\n        if (this._lazyUpdater) {\n            GLib.source_remove(this._lazyUpdater);\n            delete this._lazyUpdater;\n        }\n        this.disconnect(this._mountChanged);\n        this.mount = null;\n        this._signalsHandler.destroy();\n\n        super.destroy();\n    }\n\n    vfunc_dup() {\n        return new MountableVolumeAppInfo({\n            volume: this.volume,\n            cancellable: this.cancellable,\n        });\n    }\n\n    vfunc_get_id() {\n        const uuid = this.mount?.get_uuid() ?? this.volume.get_uuid();\n        return uuid ? 'mountable-volume:%s'.format(uuid) : super.vfunc_get_id();\n    }\n\n    vfunc_equal(other) {\n        if (this.volume === other?.volume && this.mount === other?.mount)\n            return true;\n\n        return this.get_id() === other?.get_id();\n    }\n\n    list_actions() {\n        const actions = [];\n        const {mount} = this;\n\n        if (mount) {\n            if (this.mount.can_unmount())\n                actions.push('unmount');\n            if (this.mount.can_eject())\n                actions.push('eject');\n\n            return actions;\n        }\n\n        if (this.volume.can_mount())\n            actions.push('mount');\n        if (this.volume.can_eject())\n            actions.push('eject');\n\n        return actions;\n    }\n\n    get_action_name(action) {\n        switch (action) {\n        case 'mount':\n            return __('Mount');\n        case 'unmount':\n            return __('Unmount');\n        case 'eject':\n            return __('Eject');\n        default:\n            return null;\n        }\n    }\n\n    vfunc_launch(files, context) {\n        if (this.mount || files?.length)\n            return super.vfunc_launch(files, context);\n\n        this.mountAndLaunch(files, context);\n        return true;\n    }\n\n    _update() {\n        this.mount = this.volume.get_mount();\n\n        const removable = this.mount ?? this.volume;\n        this.name = removable.get_name();\n        this.icon = removable.get_icon();\n\n        this.location = this.mount?.get_default_location() ??\n            this.volume.get_activation_root();\n\n        this._updateLocationIcon({custom: true});\n    }\n\n    _monitorChanges() {\n        this._signalsHandler.destroy();\n\n        const removable = this.mount ?? this.volume;\n        this._signalsHandler.add(removable, 'changed', () => this._update());\n\n        if (this.mount) {\n            this._signalsHandler.add(this.mount, 'pre-unmount', () => this._update());\n            this._signalsHandler.add(this.mount, 'unmounted', () => this._update());\n        }\n    }\n\n    async mountAndLaunch(files, context) {\n        if (this.mount)\n            return super.vfunc_launch(files, context);\n\n        try {\n            await this.launchAction('mount');\n            if (!this.mount) {\n                throw new Error('No mounted location to open for %s'.format(\n                    this.get_id()));\n            }\n\n            return super.vfunc_launch(files, context);\n        } catch (e) {\n            logError(e, 'Mount and launch %s'.format(this.get_id()));\n            return false;\n        }\n    }\n\n    _notifyActionError(action, message) {\n        if (action === 'mount') {\n            global.notify_error(__('Failed to mount %s'.format(\n                this.get_name())), message);\n        } else if (action === 'unmount') {\n            global.notify_error(__('Failed to umount %s'.format(\n                this.get_name())), message);\n        } else if (action === 'eject') {\n            global.notify_error(__('Failed to eject %s'.format(\n                this.get_name())), message);\n        }\n    }\n\n    async launchAction(action) {\n        if (!this.list_actions().includes(action))\n            throw new Error('Action %s is not supported by %s', action, this);\n\n        if (this._currentAction) {\n            if (this._currentAction === 'mount') {\n                this._notifyActionError(action,\n                    __('Mount operation already in progress'));\n            } else if (this._currentAction === 'unmount') {\n                this._notifyActionError(action,\n                    __('Umount operation already in progress'));\n            } else if (this._currentAction === 'eject') {\n                this._notifyActionError(action,\n                    __('Eject operation already in progress'));\n            }\n\n            throw new Error('Another action %s is being performed in %s'.format(\n                this._currentAction, this));\n        }\n\n        this._currentAction = action;\n        this.notify('busy');\n        const removable = this.mount ?? this.volume;\n        const operation = new ShellMountOperation.ShellMountOperation(removable);\n        try {\n            if (action === 'mount') {\n                await this.volume.mount(Gio.MountMountFlags.NONE, operation.mountOp,\n                    this.cancellable);\n            } else if (action === 'unmount') {\n                await this.mount.unmount_with_operation(Gio.MountUnmountFlags.FORCE,\n                    operation.mountOp, this.cancellable);\n            } else if (action === 'eject') {\n                await removable.eject_with_operation(Gio.MountUnmountFlags.FORCE,\n                    operation.mountOp, this.cancellable);\n            } else {\n                logError(new Error(), 'No action %s on removable %s'.format(action,\n                    removable.get_name()));\n                return false;\n            }\n\n            return true;\n        } catch (e) {\n            if (action === 'mount' &&\n                e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.ALREADY_MOUNTED))\n                return true;\n            else if (action === 'umount' &&\n                     e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.NOT_MOUNTED))\n                return true;\n\n            if (e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.FAILED))\n                this._notifyActionError(action, e.message);\n\n            if (action === 'mount' && this._isEncryptedMountError(e)) {\n                delete this._currentAction;\n                operation.close();\n                return this.launchAction(action);\n            }\n\n            if (!e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED)) {\n                logError(e, 'Impossible to %s removable %s'.format(action,\n                    removable.get_name()));\n            }\n\n            return false;\n        } finally {\n            delete this._currentAction;\n            this.notify('busy');\n            this._update();\n            operation.close();\n        }\n    }\n\n    _isEncryptedMountError(error) {\n        // FIXME: we will always get G_IO_ERROR_FAILED from the gvfs udisks\n        // backend, see https://bugs.freedesktop.org/show_bug.cgi?id=51271\n\n        if (!error.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.FAILED))\n            return false;\n\n        // cryptsetup\n        if (error.message.includes('No key available with this passphrase'))\n            return true;\n\n        // udisks (no password)\n        if (error.message.includes('No key available to unlock device'))\n            return true;\n\n        // libblockdev wrong password opening LUKS device\n        if (error.message.includes('Failed to activate device: Incorrect passphrase'))\n            return true;\n\n        // cryptsetup returns EINVAL in many cases, including wrong TCRYPT password/parameters\n        if (error.message.includes('Failed to load device\\'s parameters: Invalid argument') ||\n            error.message.includes(`Failed to load device's parameters: ${GLib.strerror(22 /* EINVAL */)}`))\n            return true;\n\n        // cryptsetup returns EPERM when the TCRYPT header can't be decrypted\n        // with the provided password/parameters.\n        if (error.message.includes('Failed to load device\\'s parameters: Operation not permitted') ||\n            error.message.includes(`Failed to load device's parameters: ${GLib.strerror(1 /* EPERM */)}`))\n            return true;\n\n        return false;\n    }\n});\n\nconst TrashAppInfo = GObject.registerClass({\n    Implements: [Gio.AppInfo],\n    Properties: {\n        'empty': GObject.ParamSpec.boolean(\n            'empty', 'empty', 'empty',\n            GObject.ParamFlags.READWRITE,\n            true),\n    },\n},\nclass TrashAppInfo extends LocationAppInfo {\n    static initPromises(file) {\n        if (TrashAppInfo._promisified)\n            return;\n\n        const trashProto = file.constructor.prototype;\n        Gio._promisify(Gio.FileEnumerator.prototype, 'close_async', 'close_finish');\n        Gio._promisify(Gio.FileEnumerator.prototype, 'next_files_async', 'next_files_finish');\n        Gio._promisify(trashProto, 'enumerate_children_async', 'enumerate_children_finish');\n        Gio._promisify(trashProto, 'query_info_async', 'query_info_finish');\n        TrashAppInfo._promisified = true;\n    }\n\n    _init(cancellable = null) {\n        super._init({\n            location: Gio.file_new_for_uri(TRASH_URI),\n            name: __('Trash'),\n            icon: Gio.ThemedIcon.new(FALLBACK_TRASH_ICON),\n            cancellable,\n        });\n        TrashAppInfo.initPromises(this.location);\n\n        try {\n            this._monitor = this.location.monitor_directory(0, this.cancellable);\n            this._schedUpdateId = 0;\n            this._monitorChangedId = this._monitor.connect('changed', () =>\n                this._onTrashChange());\n        } catch (e) {\n            if (e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))\n                return;\n            logError(e, 'Impossible to monitor trash');\n        }\n        this._updateTrash();\n\n        this.connect('notify::empty', () => this._updateLocationIcon());\n        this.notify('empty');\n    }\n\n    destroy() {\n        if (this._schedUpdateId) {\n            GLib.source_remove(this._schedUpdateId);\n            this._schedUpdateId = 0;\n        }\n        this._updateTrashCancellable?.cancel();\n        this._monitor?.disconnect(this._monitorChangedId);\n        this._monitor = null;\n\n        super.destroy();\n    }\n\n    list_actions() {\n        return this.empty ? [] : ['empty-trash'];\n    }\n\n    get_action_name(action) {\n        switch (action) {\n        case 'empty-trash':\n            return __('Empty Trash');\n        default:\n            return null;\n        }\n    }\n\n    _onTrashChange() {\n        if (this._schedUpdateId) {\n            GLib.source_remove(this._schedUpdateId);\n            this._schedUpdateId = 0;\n        }\n\n        if (this._monitor.is_cancelled())\n            return;\n\n        this._schedUpdateId = GLib.timeout_add(GLib.PRIORITY_LOW,\n            UPDATE_TRASH_DELAY, () => {\n                this._schedUpdateId = 0;\n                this._updateTrash();\n                return GLib.SOURCE_REMOVE;\n            });\n    }\n\n    async _updateTrash() {\n        const priority = GLib.PRIORITY_LOW;\n        this._updateTrashCancellable?.cancel();\n        const cancellable = new Utils.CancellableChild(this.cancellable);\n        this._updateTrashCancellable = cancellable;\n\n        try {\n            const trashInfo = await this.location.query_info_async(\n                Gio.FILE_ATTRIBUTE_TRASH_ITEM_COUNT,\n                Gio.FileQueryInfoFlags.NONE,\n                priority, cancellable);\n            this.empty = !trashInfo.get_attribute_uint32(\n                Gio.FILE_ATTRIBUTE_TRASH_ITEM_COUNT);\n            return;\n        } catch (e) {\n            if (!e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))\n                logError(e, 'Impossible to get trash children from infos');\n        } finally {\n            cancellable.cancel();\n            if (this._updateIconCancellable === cancellable)\n                delete this._updateTrashCancellable;\n        }\n\n        try {\n            const childrenEnumerator = await this.location.enumerate_children_async(\n                Gio.FILE_ATTRIBUTE_STANDARD_TYPE, Gio.FileQueryInfoFlags.NONE,\n                priority, cancellable);\n            const children = await childrenEnumerator.next_files_async(1,\n                priority, cancellable);\n            this.empty = !children.length;\n\n            await childrenEnumerator.close_async(priority, null);\n        } catch (e) {\n            if (!e.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))\n                logError(e, 'Impossible to enumerate trash children');\n        } finally {\n            cancellable.cancel();\n            if (this._updateIconCancellable === cancellable)\n                delete this._updateTrashCancellable;\n        }\n    }\n\n    launchAction(action, timestamp) {\n        if (!this.list_actions().includes(action))\n            throw new Error('Action %s is not supported by %s', action, this);\n\n        const nautilus = makeNautilusFileOperationsProxy();\n        const askConfirmation = true;\n        nautilus.EmptyTrashRemote(askConfirmation,\n            nautilus.platformData({timestamp}), (_p, error) => {\n                if (error)\n                    logError(error, 'Empty trash failed');\n            }, this.cancellable);\n    }\n});\n\n/**\n * @param shellApp\n */\nfunction wrapWindowsBackedApp(shellApp) {\n    if (shellApp._dtdData)\n        throw new Error('%s has been already wrapped'.format(shellApp));\n\n    shellApp._dtdData = {\n        windows: [],\n        state: undefined,\n        startingWorkspace: 0,\n        isFocused: false,\n        proxyProperties: [],\n        sources: new Set(),\n        signalConnections: new Utils.GlobalSignalsHandler(),\n        methodInjections: new Utils.InjectionsHandler(),\n        propertyInjections: new Utils.PropertyInjectionsHandler(),\n        addProxyProperties(parent, proxyProperties) {\n            Object.entries(proxyProperties).forEach(([p, o]) => {\n                const publicProp = o.public ? p : `_${p}`;\n                const get = o.getter && o.value instanceof Function\n                    ? () => this[p]() : () => this[p];\n                Object.defineProperty(parent, publicProp, Object.assign({\n                    get,\n                    set: v => (this[p] = v),\n                    configurable: true,\n                    enumerable: !!o.enumerable,\n                }, o.readOnly ? {set: undefined} : {}));\n                if (o.value)\n                    this[p] = o.value;\n                this.proxyProperties.push(publicProp);\n            });\n        },\n        destroy() {\n            this.windows = [];\n            this.proxyProperties = [];\n            this.sources.forEach(s => GLib.source_remove(s));\n            this.sources.clear();\n            this.signalConnections.destroy();\n            this.methodInjections.destroy();\n            this.propertyInjections.destroy();\n        },\n    };\n\n    shellApp._dtdData.addProxyProperties(shellApp, {\n        windows: {},\n        state: {},\n        startingWorkspace: {},\n        isFocused: {public: true},\n        signalConnections: {readOnly: true},\n        sources: {readOnly: true},\n        checkFocused: {},\n        setDtdData: {},\n    });\n\n    shellApp._setDtdData = function (data, params = {}) {\n        for (const [name, value] of Object.entries(data)) {\n            if (params.readOnly && name in this._dtdData)\n                throw new Error('Property %s is already defined'.format(name));\n            const defaultParams = {public: true, readOnly: true};\n            this._dtdData.addProxyProperties(this, {\n                [name]: {...defaultParams, ...params, value},\n            });\n        }\n    };\n\n    const m = (...args) => shellApp._dtdData.methodInjections.add(shellApp, ...args);\n    const p = (...args) => shellApp._dtdData.propertyInjections.add(shellApp, ...args);\n\n    // mi is Method injector, pi is Property injector\n    shellApp._setDtdData({mi: m, pi: p}, {public: false});\n\n    m('get_state', () => shellApp._state ?? shellApp._getStateByWindows());\n    p('state', {get: () => shellApp.get_state()});\n\n    m('get_windows', () => shellApp._windows);\n    m('get_n_windows', () => shellApp._windows.length);\n    m('get_pids', () => shellApp._windows.reduce((pids, w) => {\n        if (w.get_pid() > 0 && !pids.includes(w.get_pid()))\n            pids.push(w.get_pid());\n        return pids;\n    }, []));\n    m('is_on_workspace', (_om, workspace) => shellApp._windows.some(w =>\n        w.get_workspace() === workspace) ||\n        (shellApp.state === Shell.AppState.STARTING &&\n         [-1, workspace.index()].includes(shellApp._startingWorkspace)));\n    m('request_quit', () => shellApp._windows.filter(w =>\n        w.can_close()).forEach(w => w.delete(global.get_current_time())));\n\n    shellApp._setDtdData({\n        _getStateByWindows() {\n            return this.get_n_windows() ? Shell.AppState.RUNNING : Shell.AppState.STOPPED;\n        },\n\n        _updateWindows() {\n            throw new GObject.NotImplementedError(`_updateWindows in ${this.constructor.name}`);\n        },\n\n        _notifyStateChanged() {\n            Shell.AppSystem.get_default().emit('app-state-changed', this);\n            this.notify('state');\n        },\n\n        _setState(state) {\n            const oldState = this.state;\n            this._state = state;\n\n            if (this.state !== oldState)\n                this._notifyStateChanged();\n        },\n\n        _setWindows(windows) {\n            const oldState = this.state;\n            const oldWindows = this._windows.slice();\n            const result = {windowsChanged: false, stateChanged: false};\n            this._state = undefined;\n\n            if (windows.length !== oldWindows.length ||\n                windows.some((win, index) => win !== oldWindows[index])) {\n                this._windows = windows.filter(w => !w.is_override_redirect());\n                this.emit('windows-changed');\n                result.windowsChanged = true;\n            }\n\n            if (this.state !== oldState) {\n                this._notifyStateChanged();\n                this._checkFocused();\n                result.stateChanged = true;\n            }\n\n            return result;\n        },\n    }, {readOnly: false});\n\n    shellApp._sources.add(GLib.idle_add(GLib.DEFAULT_PRIORITY, () => {\n        shellApp._updateWindows();\n        shellApp._sources.delete(GLib.main_current_source().source_id);\n        return GLib.SOURCE_REMOVE;\n    }));\n\n    const windowTracker = Shell.WindowTracker.get_default();\n    shellApp._checkFocused = function () {\n        if (this._windows.some(w => w.has_focus())) {\n            this.isFocused = true;\n            windowTracker.notify('focus-app');\n        } else if (this.isFocused) {\n            this.isFocused = false;\n            windowTracker.notify('focus-app');\n        }\n    };\n\n    shellApp._checkFocused();\n    shellApp._signalConnections.add(global.display, 'notify::focus-window', () =>\n        shellApp._checkFocused());\n\n    // Re-implements shell_app_activate_window for generic activation and alt-tab support\n    m('activate_window', function (_om, window, timestamp) {\n        /* eslint-disable no-invalid-this */\n        if (!window)\n            [window] = this.get_windows();\n        else if (!this._windows.includes(window))\n            return;\n\n        const currentWorkspace = global.workspace_manager.get_active_workspace();\n        const workspace = window.get_workspace();\n        const sameWorkspaceWindows = this.get_windows().filter(w =>\n            w.get_workspace() === workspace);\n        sameWorkspaceWindows.forEach(w => w.raise());\n\n        if (workspace !== currentWorkspace)\n            workspace.activate_with_focus(window, timestamp);\n        else\n            window.activate(timestamp);\n        /* eslint-enable no-invalid-this */\n    });\n\n    // Re-implements shell_app_activate_full for generic activation and dash support\n    m('activate_full', function (_om, workspace, timestamp) {\n        /* eslint-disable no-invalid-this */\n        if (!timestamp)\n            timestamp = global.get_current_time();\n\n        switch (this.state) {\n        case Shell.AppState.STOPPED:\n            try {\n                this._startingWorkspace = workspace;\n                this._setState(Shell.AppState.STARTING);\n                this.launch(timestamp, workspace, Shell.AppLaunchGpu.APP_PREF);\n            } catch (e) {\n                logError(e);\n                this._setState(Shell.AppState.STOPPED);\n                global.notify_error(_('Failed to launch %s'.format(\n                    this.get_name())), e.message);\n            }\n            break;\n        case Shell.AppState.RUNNING:\n            this.activate_window(null, timestamp);\n            break;\n        }\n        /* eslint-enable no-invalid-this */\n    });\n\n    m('activate', () => shellApp.activate_full(-1, 0));\n\n    m('compare', (_om, other) => Utils.shellAppCompare(shellApp, other));\n\n    const {destroy: defaultDestroy} = shellApp;\n    shellApp.destroy = function () {\n        /* eslint-disable no-invalid-this */\n        this._dtdData.proxyProperties.forEach(prop => delete this[prop]);\n        this._dtdData.destroy();\n        this._dtdData = undefined;\n        this.appInfo.destroy?.();\n        this.destroy = defaultDestroy;\n        defaultDestroy?.call(this);\n        /* eslint-enable no-invalid-this */\n    };\n\n    return shellApp;\n}\n\n/**\n * We can't inherit from Shell.App as it's a final type, so let's patch it\n *\n * @param params\n */\nfunction makeLocationApp(params) {\n    if (!(params?.appInfo instanceof LocationAppInfo))\n        throw new TypeError('Invalid location');\n\n    const {fallbackIconName} = params;\n    delete params.fallbackIconName;\n\n    const shellApp = new Shell.App(params);\n    wrapWindowsBackedApp(shellApp);\n\n    shellApp._setDtdData({\n        location: () => shellApp.appInfo.location,\n        isTrash: shellApp.appInfo instanceof TrashAppInfo,\n    }, {getter: true, enumerable: true});\n\n    shellApp._mi('toString', defaultToString =>\n        '[LocationApp \"%s\" - %s]'.format(shellApp.get_id(),\n            defaultToString.call(shellApp)));\n\n    shellApp._mi('launch', (_om, timestamp, workspace, _gpuPref) =>\n        shellApp.appInfo.launch([],\n            global.create_app_launch_context(timestamp, workspace)));\n\n    shellApp._mi('launch_action', (_om, actionName, ...args) =>\n        shellApp.appInfo.launchAction(actionName, ...args));\n\n    shellApp._mi('create_icon_texture', (_om, iconSize) => new St.Icon({\n        iconSize,\n        gicon: shellApp.icon,\n        fallbackIconName,\n    }));\n\n    // FIXME: We need to add a new API to Nautilus to open new windows\n    shellApp._mi('can_open_new_window', () => {\n        try {\n            if (!shellApp.get_n_windows())\n                return true;\n\n            const handlerApp = shellApp.appInfo.getHandlerApp();\n\n            if (handlerApp.has_key('SingleMainWindow'))\n                return !handlerApp.get_boolean('SingleMainWindow');\n\n            if (handlerApp.has_key('X-GNOME-SingleWindow'))\n                return !handlerApp.get_boolean('X-GNOME-SingleWindow');\n\n            if (handlerApp.get_commandline()?.split(' ').includes('--new-window'))\n                return true;\n\n            const [window] = shellApp.get_windows();\n            if (window && window.get_gtk_window_object_path())\n                return window.get_gtk_application_id() === null;\n\n            return true;\n        } catch {\n            return false;\n        }\n    });\n\n    shellApp._mi('open_new_window', function (_om, workspace) {\n        /* eslint-disable no-invalid-this */\n        const context = global.create_app_launch_context(0, workspace);\n        if (!this.get_n_windows()) {\n            this.appInfo.launch([], context);\n            return;\n        }\n        const appId = this.appInfo.get_id();\n        Gio.AppInfo.create_from_commandline(this.appInfo.get_commandline(),\n            this.appInfo.get_id(), appId\n                ? Gio.AppInfoCreateFlags.SUPPORTS_STARTUP_NOTIFICATION\n                : Gio.AppInfoCreateFlags.NONE).launch_uris(\n            [this.appInfo.location.get_uri()], context);\n        /* eslint-enable no-invalid-this */\n    });\n\n    if (shellApp.appInfo instanceof MountableVolumeAppInfo) {\n        shellApp._mi('get_busy', function (parentGetBusy) {\n            /* eslint-disable no-invalid-this */\n            if (this.appInfo.busy)\n                return true;\n            return parentGetBusy.call(this);\n            /* eslint-enable no-invalid-this */\n        });\n        shellApp._pi('busy', {get: () => shellApp.get_busy()});\n        shellApp._signalConnections.add(shellApp.appInfo, 'notify::busy', _ =>\n            shellApp.notify('busy'));\n    }\n\n    shellApp._mi('get_windows', function () {\n        /* eslint-disable no-invalid-this */\n        if (this._needsResort)\n            this._sortWindows();\n        return this._windows;\n        /* eslint-enable no-invalid-this */\n    });\n\n    const {fm1Client} = Docking.DockManager.getDefault();\n    shellApp._setDtdData({\n        _needsResort: true,\n\n        _windowsOrderChanged() {\n            this._needsResort = true;\n            this.emit('windows-changed');\n        },\n\n        _sortWindows() {\n            this._windows.sort(Utils.shellWindowsCompare);\n            this._needsResort = false;\n        },\n\n        _updateWindows() {\n            const windows = fm1Client.getWindows(this.location?.get_uri()).sort(\n                Utils.shellWindowsCompare);\n            const {windowsChanged} = this._setWindows(windows);\n\n            if (!windowsChanged)\n                return;\n\n            this._signalConnections.removeWithLabel(Labels.LOCATION_WINDOWS);\n            windows.forEach(w =>\n                this._signalConnections.addWithLabel(Labels.LOCATION_WINDOWS, w,\n                    'notify::user-time', () => {\n                        if (w !== this._windows[0])\n                            this._windowsOrderChanged();\n                    }));\n        },\n    }, {readOnly: false});\n\n    shellApp._signalConnections.add(fm1Client, 'windows-changed', () =>\n        shellApp._updateWindows());\n    shellApp._signalConnections.add(shellApp.appInfo, 'notify::icon', () =>\n        shellApp.notify('icon'));\n    shellApp._signalConnections.add(global.workspaceManager,\n        'workspace-switched', () => shellApp._windowsOrderChanged());\n\n    return shellApp;\n}\n\n/**\n *\n */\nfunction getFileManagerApp() {\n    return Shell.AppSystem.get_default().lookup_app(FILE_MANAGER_DESKTOP_APP_ID);\n}\n\n/**\n *\n */\nexport function wrapFileManagerApp() {\n    const fileManagerApp = getFileManagerApp();\n    if (!fileManagerApp)\n        return null;\n\n    if (fileManagerApp._dtdData)\n        return fileManagerApp;\n\n    const originalGetWindows = fileManagerApp.get_windows;\n    wrapWindowsBackedApp(fileManagerApp);\n\n    const {removables, trash} = Docking.DockManager.getDefault();\n    fileManagerApp._signalConnections.addWithLabel(Labels.WINDOWS_CHANGED,\n        fileManagerApp, 'windows-changed', () => {\n            fileManagerApp.stop_emission_by_name('windows-changed');\n            // Let's wait for the location app to take control before of us\n            const id = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 50, () => {\n                fileManagerApp._sources.delete(id);\n                fileManagerApp._updateWindows();\n                return GLib.SOURCE_REMOVE;\n            });\n            fileManagerApp._sources.add(id);\n        });\n\n    fileManagerApp._signalConnections.add(global.workspaceManager,\n        'workspace-switched', () => {\n            fileManagerApp._signalConnections.blockWithLabel(Labels.WINDOWS_CHANGED);\n            fileManagerApp.emit('windows-changed');\n            fileManagerApp._signalConnections.unblockWithLabel(Labels.WINDOWS_CHANGED);\n        });\n\n    if (removables) {\n        fileManagerApp._signalConnections.add(removables, 'changed', () =>\n            fileManagerApp._updateWindows());\n        fileManagerApp._signalConnections.add(removables, 'windows-changed', () =>\n            fileManagerApp._updateWindows());\n    }\n\n    if (trash?.getApp()) {\n        fileManagerApp._signalConnections.add(trash.getApp(), 'windows-changed', () =>\n            fileManagerApp._updateWindows());\n    }\n\n    fileManagerApp._updateWindows = function () {\n        const locationWindows = [];\n        getRunningApps().forEach(a => locationWindows.push(...a.get_windows()));\n        const windows = originalGetWindows.call(this).filter(w =>\n            !locationWindows.includes(w));\n\n        this._signalConnections.blockWithLabel(Labels.WINDOWS_CHANGED);\n        this._setWindows(windows);\n        this._signalConnections.unblockWithLabel(Labels.WINDOWS_CHANGED);\n    };\n\n    fileManagerApp._mi('toString', defaultToString =>\n        '[FileManagerApp - %s]'.format(defaultToString.call(fileManagerApp)));\n\n    return fileManagerApp;\n}\n\n/**\n *\n */\nexport function unWrapFileManagerApp() {\n    const fileManagerApp = getFileManagerApp();\n    if (!fileManagerApp || !fileManagerApp._dtdData)\n        return;\n\n    fileManagerApp.destroy();\n}\n\n/**\n * This class maintains a Shell.App representing the Trash and keeps it\n * up-to-date as the trash fills and is emptied over time.\n */\nexport class Trash {\n    destroy() {\n        this._trashApp?.destroy();\n    }\n\n    _ensureApp() {\n        if (this._trashApp)\n            return;\n\n        this._trashApp = makeLocationApp({\n            appInfo: new TrashAppInfo(new Gio.Cancellable()),\n            fallbackIconName: FALLBACK_TRASH_ICON,\n        });\n    }\n\n    getApp() {\n        this._ensureApp();\n        return this._trashApp;\n    }\n}\n\n/**\n * This class maintains Shell.App representations for removable devices\n * plugged into the system, and keeps the list of Apps up-to-date as\n * devices come and go and are mounted and unmounted.\n */\nexport class Removables {\n    static initVolumePromises(object) {\n        // TODO: This can be simplified using actual interface type when we\n        // can depend on gjs 1.72\n        if (!(object instanceof Gio.Volume) || object.constructor.prototype._d2dPromisified)\n            return;\n\n        Gio._promisify(object.constructor.prototype, 'mount', 'mount_finish');\n        Gio._promisify(object.constructor.prototype, 'eject_with_operation',\n            'eject_with_operation_finish');\n        object.constructor.prototype._d2dPromisified = true;\n    }\n\n    static initMountPromises(object) {\n        // TODO: This can be simplified using actual interface type when we\n        // can depend on gjs 1.72\n        if (!(object instanceof Gio.Mount) || object.constructor.prototype._d2dPromisified)\n            return;\n\n        Gio._promisify(object.constructor.prototype, 'eject_with_operation',\n            'eject_with_operation_finish');\n        Gio._promisify(object.constructor.prototype, 'unmount_with_operation',\n            'unmount_with_operation_finish');\n        object.constructor.prototype._d2dPromisified = true;\n    }\n\n    constructor() {\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n\n        this._monitor = Gio.VolumeMonitor.get();\n        this._cancellable = new Gio.Cancellable();\n\n        this._monitor.get_mounts().forEach(m => Removables.initMountPromises(m));\n        this._updateVolumes();\n\n        this._signalsHandler.add([\n            this._monitor,\n            'volume-added',\n            (_, volume) => this._onVolumeAdded(volume),\n        ], [\n            this._monitor,\n            'volume-removed',\n            (_, volume) => this._onVolumeRemoved(volume),\n        ], [\n            this._monitor,\n            'mount-added',\n            (_, mount) => this._onMountAdded(mount),\n        ], [\n            Docking.DockManager.settings,\n            'changed::show-mounts-only-mounted',\n            () => this._updateVolumes(),\n        ], [\n            Docking.DockManager.settings,\n            'changed::show-mounts-network',\n            () => this._updateVolumes(),\n        ]);\n    }\n\n    destroy() {\n        this._volumeApps.forEach(a => a.destroy());\n        this._volumeApps = [];\n        this._cancellable.cancel();\n        this._cancellable = null;\n        this._signalsHandler.destroy();\n        this._monitor = null;\n    }\n\n    _updateVolumes() {\n        this._volumeApps?.forEach(a => a.destroy());\n        this._volumeApps = [];\n        this.emit('changed');\n\n        this._monitor.get_volumes().forEach(v => this._onVolumeAdded(v));\n    }\n\n    _onVolumeAdded(volume) {\n        Removables.initVolumePromises(volume);\n\n        if (!Docking.DockManager.settings.showMountsNetwork &&\n            volume.get_identifier('class') === 'network')\n            return;\n\n\n        const mount = volume.get_mount();\n        if (mount) {\n            if (mount.is_shadowed())\n                return;\n            if (!mount.can_eject() && !mount.can_unmount())\n                return;\n        } else {\n            if (Docking.DockManager.settings.showMountsOnlyMounted)\n                return;\n            if (!volume.can_mount() && !volume.can_eject())\n                return;\n        }\n\n        const appInfo = new MountableVolumeAppInfo(volume,\n            new Utils.CancellableChild(this._cancellable));\n        const volumeApp = makeLocationApp({\n            appInfo,\n            fallbackIconName: FALLBACK_REMOVABLE_MEDIA_ICON,\n        });\n\n        volumeApp._signalConnections.add(volumeApp, 'windows-changed',\n            () => this.emit('windows-changed', volumeApp));\n\n        if (Docking.DockManager.settings.showMountsOnlyMounted) {\n            volumeApp._signalConnections.add(appInfo, 'notify::mount',\n                () => !appInfo.mount && this._onVolumeRemoved(appInfo.volume));\n        }\n\n        this._volumeApps.push(volumeApp);\n        this.emit('changed');\n    }\n\n    _onVolumeRemoved(volume) {\n        const volumeIndex = this._volumeApps.findIndex(({appInfo}) =>\n            appInfo.volume === volume);\n        if (volumeIndex !== -1) {\n            const [volumeApp] = this._volumeApps.splice(volumeIndex, 1);\n            // We don't care about cancelling the ongoing operations from now on.\n            volumeApp.appInfo.cancellable = null;\n            volumeApp.destroy();\n            this.emit('changed');\n        }\n    }\n\n    _onMountAdded(mount) {\n        Removables.initMountPromises(mount);\n\n        if (!Docking.DockManager.settings.showMountsOnlyMounted)\n            return;\n\n        if (!this._volumeApps.find(({appInfo}) => appInfo.mount === mount)) {\n            // In some Gio.Mount implementations the volume may be set after\n            // mount is emitted, so we could just ignore it as we'll get it\n            // later via volume-added\n            const volume = mount.get_volume();\n            if (volume)\n                this._onVolumeAdded(volume);\n        }\n    }\n\n    getApps() {\n        return this._volumeApps;\n    }\n}\nSignals.addSignalMethods(Removables.prototype);\n\n/**\n *\n */\nfunction getApps() {\n    const dockManager = Docking.DockManager.getDefault();\n    const locationApps = [];\n\n    if (dockManager.removables)\n        locationApps.push(...dockManager.removables.getApps());\n\n    if (dockManager.trash)\n        locationApps.push(dockManager.trash.getApp());\n\n    return locationApps;\n}\n\n/**\n *\n */\nexport function getRunningApps() {\n    return getApps().filter(a => a.state === Shell.AppState.RUNNING);\n}\n\n/**\n *\n */\nexport function getStartingApps() {\n    return getApps().filter(a => a.state === Shell.AppState.STARTING);\n}\n"
        },
        {
          "name": "locationsWorker.js",
          "type": "blob",
          "size": 2.689453125,
          "content": "#!/usr/bin/env gjs\n\nimport GLib from 'gi://GLib';\nimport Gio from 'gi://Gio';\n\nconst GJS_SUPPORTS_FILE_IFACE_PROMISES = imports.system.version >= 17101;\n\nif (GJS_SUPPORTS_FILE_IFACE_PROMISES)\n    Gio._promisify(Gio.File.prototype, 'query_default_handler_async');\n\nfunction getHandlerAppAsync(location, cancellable) {\n    if (!location)\n        return null;\n\n    if (!GJS_SUPPORTS_FILE_IFACE_PROMISES) {\n        Gio._promisify(location.constructor.prototype,\n            'query_default_handler_async',\n            'query_default_handler_finish');\n    }\n\n    return location.query_default_handler_async(\n        GLib.PRIORITY_DEFAULT, cancellable);\n}\n\nasync function mainAsync(argv) {\n    if (argv.length < 1) {\n        const currentBinary = GLib.path_get_basename(new Error().fileName);\n        printerr(`Usage: ${currentBinary} <action> uri [ --timeout <value> ]`);\n        return 1;\n    }\n\n    const [action, uri] = argv;\n    let timeout = 200;\n\n    if (action !== 'handler')\n        throw new TypeError(`Unexpected action ${action}`);\n\n    for (let i = 1; i < argv.length; ++i) {\n        if (argv[i] === '--timeout' && i < argv.length - 1)\n            timeout = argv[++i];\n    }\n\n    const location = Gio.File.new_for_uri(uri);\n    const cancellable = new Gio.Cancellable();\n\n    // GVfs providers could hang when querying the file information, so we\n    // workaround this by using the async API in a sync way, but we need to\n    // use a timeout to avoid this to hang forever, better than hang the\n    // shell.\n    let launchMaxWaitId;\n\n    try {\n        const handler = await Promise.race([\n            getHandlerAppAsync(location, cancellable),\n            new Promise((_resolve, reject) => {\n                launchMaxWaitId = GLib.timeout_add(\n                    GLib.PRIORITY_DEFAULT, timeout, () => {\n                        launchMaxWaitId = 0;\n                        cancellable.cancel();\n                        reject(new GLib.Error(Gio.IOErrorEnum,\n                            Gio.IOErrorEnum.TIMED_OUT,\n                            `Searching for ${location.get_uri()} ` +\n                            'handler took too long'));\n                        return GLib.SOURCE_REMOVE;\n                    });\n            }),\n        ]);\n\n        print(handler.get_id());\n    } catch (e) {\n        printerr(e.message);\n        logError(e);\n        return e.code ? e.code : GLib.MAXUINT8;\n    } finally {\n        if (launchMaxWaitId)\n            GLib.source_remove(launchMaxWaitId);\n    }\n\n    return 0;\n}\n\nfunction main(args) {\n    let ret;\n    const loop = new GLib.MainLoop(null, false);\n    mainAsync(args).then(r => (ret = r)).catch(logError).finally(() => loop.quit());\n    loop.run();\n\n    return ret;\n}\n\nimports.system.exit(main(ARGV));\n"
        },
        {
          "name": "media",
          "type": "tree",
          "content": null
        },
        {
          "name": "metadata.json",
          "type": "blob",
          "size": 0.5078125,
          "content": "{\n\"shell-version\": [\n    \"45\",\n    \"46\",\n    \"47\"\n],\n\"uuid\": \"dash-to-dock@micxgx.gmail.com\",\n\"name\": \"Dash to Dock\",\n\"description\": \"A dock for the Gnome Shell. This extension moves the dash out of the overview transforming it in a dock for an easier launching of applications and a faster switching between windows and desktops. Side and bottom placement options are available.\",\n\"original-author\": \"micxgx@gmail.com\",\n\"url\": \"https://micheleg.github.io/dash-to-dock/\",\n\"gettext-domain\": \"dashtodock\",\n\"version\": 99\n}\n"
        },
        {
          "name": "notificationsMonitor.js",
          "type": "blob",
          "size": 3.85546875,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {Gio} from './dependencies/gi.js';\nimport {Main} from './dependencies/shell/ui.js';\n\nimport {\n    Docking,\n    Utils,\n} from './imports.js';\n\nconst {signals: Signals} = imports;\n\nconst Labels = Object.freeze({\n    SOURCES: Symbol('sources'),\n    NOTIFICATIONS: Symbol('notifications'),\n});\nexport class NotificationsMonitor {\n    constructor() {\n        this._settings = new Gio.Settings({\n            schema_id: 'org.gnome.desktop.notifications',\n        });\n\n        this._appNotifications = Object.create(null);\n        this._signalsHandler = new Utils.GlobalSignalsHandler(this);\n\n        const getIsEnabled = () => !this.dndMode &&\n            Docking.DockManager.settings.showIconsNotificationsCounter;\n\n        this._isEnabled = getIsEnabled();\n        const checkIsEnabled = () => {\n            const isEnabled = getIsEnabled();\n            if (isEnabled !== this._isEnabled) {\n                this._isEnabled = isEnabled;\n                this.emit('state-changed');\n\n                this._updateState();\n            }\n        };\n\n        this._dndMode = !this._settings.get_boolean('show-banners');\n        this._signalsHandler.add(this._settings, 'changed::show-banners', () => {\n            this._dndMode = !this._settings.get_boolean('show-banners');\n            checkIsEnabled();\n        });\n        this._signalsHandler.add(Docking.DockManager.settings,\n            'changed::show-icons-notifications-counter', checkIsEnabled);\n\n        this._updateState();\n    }\n\n    destroy() {\n        this.emit('destroy');\n        this._signalsHandler?.destroy();\n        this._signalsHandler = null;\n        this._appNotifications = null;\n        this._settings = null;\n    }\n\n    get enabled() {\n        return this._isEnabled;\n    }\n\n    get dndMode() {\n        return this._dndMode;\n    }\n\n    getAppNotificationsCount(appId) {\n        return this._appNotifications[appId] ?? 0;\n    }\n\n    _updateState() {\n        if (this.enabled) {\n            this._signalsHandler.addWithLabel(Labels.SOURCES, Main.messageTray,\n                'source-added', () => this._checkNotifications());\n            this._signalsHandler.addWithLabel(Labels.SOURCES, Main.messageTray,\n                'source-removed', () => this._checkNotifications());\n        } else {\n            this._signalsHandler.removeWithLabel(Labels.SOURCES);\n        }\n\n        this._checkNotifications();\n    }\n\n    _checkNotifications() {\n        this._appNotifications = Object.create(null);\n        this._signalsHandler.removeWithLabel(Labels.NOTIFICATIONS);\n\n        if (this.enabled) {\n            Main.messageTray.getSources().forEach(source => {\n                this._signalsHandler.addWithLabel(Labels.NOTIFICATIONS, source,\n                    'notification-added', () => this._checkNotifications());\n\n                source.notifications.forEach(notification => {\n                    const app = notification.source?.app ?? notification.source?._app;\n                    const appId = app?.id ?? app?._appId;\n\n                    if (appId) {\n                        if (notification.resident) {\n                            if (notification.acknowledged)\n                                return;\n\n                            this._signalsHandler.addWithLabel(Labels.NOTIFICATIONS,\n                                notification, 'notify::acknowledged',\n                                () => this._checkNotifications());\n                        }\n\n                        this._signalsHandler.addWithLabel(Labels.NOTIFICATIONS,\n                            notification, 'destroy', () => this._checkNotifications());\n\n                        this._appNotifications[appId] =\n                            (this._appNotifications[appId] ?? 0) + 1;\n                    }\n                });\n            });\n        }\n\n        this.emit('changed');\n    }\n}\n\nSignals.addSignalMethods(NotificationsMonitor.prototype);\n"
        },
        {
          "name": "po",
          "type": "tree",
          "content": null
        },
        {
          "name": "prefs.js",
          "type": "blob",
          "size": 47.0322265625,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport GLib from 'gi://GLib';\nimport GObject from 'gi://GObject';\nimport Gdk from 'gi://Gdk';\nimport Gio from 'gi://Gio';\nimport Gtk from 'gi://Gtk';\n\nimport {\n    ExtensionPreferences,\n\n    // Use __ () and N__() for the extension gettext domain, and reuse\n    // the shell domain with the default _() and N_()\n    gettext as __,\n} from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js';\n\nconst SCALE_UPDATE_TIMEOUT = 500;\nconst DEFAULT_ICONS_SIZES = [128, 96, 64, 48, 32, 24, 16];\n\nconst TransparencyMode = Object.freeze({\n    DEFAULT: 0,\n    FIXED: 1,\n    DYNAMIC: 3,\n});\n\nconst RunningIndicatorStyle = Object.freeze({\n    DEFAULT: 0,\n    DOTS: 1,\n    SQUARES: 2,\n    DASHES: 3,\n    SEGMENTED: 4,\n    SOLID: 5,\n    CILIORA: 6,\n    METRO: 7,\n});\n\nconst MonitorsConfig = GObject.registerClass({\n    Signals: {\n        'updated': {},\n    },\n}, class MonitorsConfig extends GObject.Object {\n    static get XML_INTERFACE() {\n        return '<node>\\\n            <interface name=\"org.gnome.Mutter.DisplayConfig\">\\\n                <method name=\"GetCurrentState\">\\\n                <arg name=\"serial\" direction=\"out\" type=\"u\" />\\\n                <arg name=\"monitors\" direction=\"out\" type=\"a((ssss)a(siiddada{sv})a{sv})\" />\\\n                <arg name=\"logical_monitors\" direction=\"out\" type=\"a(iiduba(ssss)a{sv})\" />\\\n                <arg name=\"properties\" direction=\"out\" type=\"a{sv}\" />\\\n                </method>\\\n                <signal name=\"MonitorsChanged\" />\\\n            </interface>\\\n        </node>';\n    }\n\n    static get ProxyWrapper() {\n        return Gio.DBusProxy.makeProxyWrapper(MonitorsConfig.XML_INTERFACE);\n    }\n\n    constructor() {\n        super();\n\n        this._monitorsConfigProxy = new MonitorsConfig.ProxyWrapper(\n            Gio.DBus.session,\n            'org.gnome.Mutter.DisplayConfig',\n            '/org/gnome/Mutter/DisplayConfig'\n        );\n\n        // Connecting to a D-Bus signal\n        this._monitorsConfigProxy.connectSignal('MonitorsChanged',\n            () => this._updateResources());\n\n        this._primaryMonitor = null;\n        this._monitors = [];\n        this._logicalMonitors = [];\n\n        this._updateResources();\n    }\n\n    _updateResources() {\n        this._monitorsConfigProxy.GetCurrentStateRemote((resources, err) => {\n            if (err) {\n                logError(err);\n                return;\n            }\n\n            const [serial_, monitors, logicalMonitors] = resources;\n            let index = 0;\n            for (const monitor of monitors) {\n                const [monitorSpecs, modes_, props] = monitor;\n                const [connector, vendor, product, serial] = monitorSpecs;\n                this._monitors.push({\n                    index: index++,\n                    active: false,\n                    connector, vendor, product, serial,\n                    displayName: props['display-name'].unpack(),\n                });\n            }\n\n            for (const logicalMonitor of logicalMonitors) {\n                const [x_, y_, scale_, transform_, isPrimary, monitorsSpecs] =\n                    logicalMonitor;\n\n                // We only care about the first one really\n                for (const monitorSpecs of monitorsSpecs) {\n                    const [connector, vendor, product, serial] = monitorSpecs;\n                    const monitor = this._monitors.find(m =>\n                        m.connector === connector && m.vendor === vendor &&\n                        m.product === product && m.serial === serial);\n\n                    if (monitor) {\n                        monitor.active = true;\n                        monitor.isPrimary = isPrimary;\n                        if (monitor.isPrimary)\n                            this._primaryMonitor = monitor;\n                        break;\n                    }\n                }\n            }\n\n            const activeMonitors = this._monitors.filter(m => m.active);\n            if (activeMonitors.length > 1 && logicalMonitors.length === 1) {\n                // We're in cloning mode, so let's just activate the primary monitor\n                this._monitors.forEach(m => (m.active = false));\n                this._primaryMonitor.active = true;\n            }\n\n            this._updateMonitorsIndexes();\n            this.emit('updated');\n        });\n    }\n\n    _updateMonitorsIndexes() {\n        // This function ensures that we follow the old Gdk indexing strategy\n        // for monitors, it can be removed when we don't care about breaking\n        // old user configurations or external apps configuring this extension\n        // such as ubuntu's gnome-control-center.\n        const {index: primaryMonitorIndex} = this._primaryMonitor;\n        for (const monitor of this._monitors) {\n            let {index} = monitor;\n            // The The dock uses the Gdk index for monitors, where the primary monitor\n            // always has index 0, so let's follow what dash-to-dock does in docking.js\n            // (as part of _createDocks), but using inverted math\n            index -= primaryMonitorIndex;\n\n            if (index < 0)\n                index += this._monitors.length;\n\n            monitor.index = index;\n        }\n    }\n\n    get primaryMonitor() {\n        return this._primaryMonitor;\n    }\n\n    get monitors() {\n        return this._monitors;\n    }\n});\n\n/**\n * @param settings\n */\nfunction setShortcut(settings) {\n    const shortcutText = settings.get_string('shortcut-text');\n    const [success, key, mods] = Gtk.accelerator_parse(shortcutText);\n\n    if (success && Gtk.accelerator_valid(key, mods)) {\n        const shortcut = Gtk.accelerator_name(key, mods);\n        settings.set_strv('shortcut', [shortcut]);\n    } else {\n        settings.set_strv('shortcut', []);\n    }\n}\n\nconst DockSettings = GObject.registerClass({\n    Implements: [Gtk.BuilderScope],\n}, class DashToDockSettings extends GObject.Object {\n    _init(extensionPreferences) {\n        super._init();\n\n        this._extensionPreferences = extensionPreferences;\n        this._settings = extensionPreferences.getSettings(\n            'org.gnome.shell.extensions.dash-to-dock');\n        this._appSwitcherSettings = new Gio.Settings({schema_id: 'org.gnome.shell.app-switcher'});\n        this._rtl = Gtk.Widget.get_default_direction() === Gtk.TextDirection.RTL;\n\n        this._builder = new Gtk.Builder();\n        this._builder.set_scope(this);\n        this._builder.set_translation_domain(\n            extensionPreferences.metadata['gettext-domain']);\n        this._builder.add_from_file(`${extensionPreferences.path}/Settings.ui`);\n\n        this.widget = this._builder.get_object('settings_notebook');\n\n        // Set a reasonable initial window height\n        this.widget.connect('realize', () => {\n            const rootWindow = this.widget.get_root();\n            rootWindow.set_default_size(-1, 850);\n            rootWindow.connect('close-request', () => this._onWindowsClosed());\n        });\n\n        // Timeout to delay the update of the settings\n        this._dock_size_timeout = 0;\n        this._icon_size_timeout = 0;\n        this._opacity_timeout = 0;\n\n        this._monitorsConfig = new MonitorsConfig();\n        this._bindSettings();\n    }\n\n    _onWindowsClosed() {\n        if (this._dock_size_timeout) {\n            GLib.source_remove(this._dock_size_timeout);\n            delete this._dock_size_timeout;\n        }\n\n        if (this._icon_size_timeout) {\n            GLib.source_remove(this._icon_size_timeout);\n            delete this._icon_size_timeout;\n        }\n\n        if (this._opacity_timeout) {\n            GLib.source_remove(this._opacity_timeout);\n            delete this._opacity_timeout;\n        }\n    }\n\n    vfunc_create_closure(builder, handlerName, flags, connectObject) {\n        if (flags & Gtk.BuilderClosureFlags.SWAPPED)\n            throw new Error('Unsupported template signal flag \"swapped\"');\n\n        if (typeof this[handlerName] === 'undefined')\n            throw new Error(`${handlerName} is undefined`);\n\n        return this[handlerName].bind(connectObject || this);\n    }\n\n    dock_display_combo_changed_cb(combo) {\n        if (!this._monitors?.length || this._updatingSettings)\n            return;\n\n        const preferredMonitor = this._monitors[combo.get_active()].connector;\n\n        this._updatingSettings = true;\n        this._settings.set_string('preferred-monitor-by-connector', preferredMonitor);\n        this._settings.set_int('preferred-monitor', -2);\n        this._updatingSettings = false;\n    }\n\n    position_top_button_toggled_cb(button) {\n        if (button.get_active())\n            this._settings.set_enum('dock-position', 0);\n    }\n\n    position_right_button_toggled_cb(button) {\n        if (button.get_active())\n            this._settings.set_enum('dock-position', 1);\n    }\n\n    position_bottom_button_toggled_cb(button) {\n        if (button.get_active())\n            this._settings.set_enum('dock-position', 2);\n    }\n\n    position_left_button_toggled_cb(button) {\n        if (button.get_active())\n            this._settings.set_enum('dock-position', 3);\n    }\n\n    icon_size_combo_changed_cb(combo) {\n        this._settings.set_int('dash-max-icon-size', this._allIconSizes[combo.get_active()]);\n    }\n\n    dock_size_scale_value_changed_cb(scale) {\n        // Avoid settings the size continuously\n        if (this._dock_size_timeout > 0)\n            GLib.source_remove(this._dock_size_timeout);\n        this._dock_size_timeout = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n                this._settings.set_double('height-fraction', scale.get_value());\n                this._dock_size_timeout = 0;\n                return GLib.SOURCE_REMOVE;\n            });\n    }\n\n    icon_size_scale_value_changed_cb(scale) {\n        // Avoid settings the size consinuosly\n        if (this._icon_size_timeout > 0)\n            GLib.source_remove(this._icon_size_timeout);\n        this._icon_size_timeout = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n                this._settings.set_int('dash-max-icon-size', scale.get_value());\n                this._icon_size_timeout = 0;\n                return GLib.SOURCE_REMOVE;\n            });\n    }\n\n    preview_size_scale_format_value_cb(scale, value) {\n        return value === 0 ? 'auto' : value;\n    }\n\n    preview_size_scale_value_changed_cb(scale) {\n        this._settings.set_double('preview-size-scale', scale.get_value());\n    }\n\n    custom_opacity_scale_value_changed_cb(scale) {\n        // Avoid settings the opacity consinuosly as it's change is animated\n        if (this._opacity_timeout > 0)\n            GLib.source_remove(this._opacity_timeout);\n        this._opacity_timeout = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n                this._settings.set_double('background-opacity', scale.get_value());\n                this._opacity_timeout = 0;\n                return GLib.SOURCE_REMOVE;\n            });\n    }\n\n    min_opacity_scale_value_changed_cb(scale) {\n        // Avoid settings the opacity consinuosly as it's change is animated\n        if (this._opacity_timeout > 0)\n            GLib.source_remove(this._opacity_timeout);\n        this._opacity_timeout = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n                this._settings.set_double('min-alpha', scale.get_value());\n                this._opacity_timeout = 0;\n                return GLib.SOURCE_REMOVE;\n            });\n    }\n\n    max_opacity_scale_value_changed_cb(scale) {\n        // Avoid settings the opacity consinuosly as it's change is animated\n        if (this._opacity_timeout > 0)\n            GLib.source_remove(this._opacity_timeout);\n        this._opacity_timeout = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT, SCALE_UPDATE_TIMEOUT, () => {\n                this._settings.set_double('max-alpha', scale.get_value());\n                this._opacity_timeout = 0;\n                return GLib.SOURCE_REMOVE;\n            });\n    }\n\n    all_windows_radio_button_toggled_cb(button) {\n        if (button.get_active())\n            this._settings.set_enum('intellihide-mode', 0);\n    }\n\n    focus_application_windows_radio_button_toggled_cb(button) {\n        if (button.get_active())\n            this._settings.set_enum('intellihide-mode', 1);\n    }\n\n    maximized_windows_radio_button_toggled_cb(button) {\n        if (button.get_active())\n            this._settings.set_enum('intellihide-mode', 2);\n    }\n\n    always_on_top_radio_button_toggled_cb(button) {\n        if (button.get_active())\n            this._settings.set_enum('intellihide-mode', 3);\n    }\n\n    _updateMonitorsSettings() {\n        // Monitor options\n        const preferredMonitor = this._settings.get_int('preferred-monitor');\n        const preferredMonitorByConnector = this._settings.get_string('preferred-monitor-by-connector');\n        const dockMonitorCombo = this._builder.get_object('dock_monitor_combo');\n\n        this._monitors = [];\n        dockMonitorCombo.remove_all();\n        let primaryIndex = -1;\n\n        // Add connected monitors\n        for (const monitor of this._monitorsConfig.monitors) {\n            if (!monitor.active && monitor.index !== preferredMonitor)\n                continue;\n\n            if (monitor.isPrimary) {\n                dockMonitorCombo.append_text(\n                    /* Translators: This will be followed by Display Name - Connector. */\n                    `${__('Primary monitor: ') + monitor.displayName} - ${\n                        monitor.connector}`);\n                primaryIndex = this._monitors.length;\n            } else {\n                dockMonitorCombo.append_text(\n                    /* Translators: Followed by monitor index, Display Name - Connector. */\n                    `${__('Secondary monitor ') + (monitor.index + 1)} - ${\n                        monitor.displayName} - ${monitor.connector}`);\n            }\n\n            this._monitors.push(monitor);\n\n            if (monitor.index === preferredMonitor ||\n                (preferredMonitor === -2 && preferredMonitorByConnector === monitor.connector))\n                dockMonitorCombo.set_active(this._monitors.length - 1);\n        }\n\n        if (dockMonitorCombo.get_active() < 0 && primaryIndex >= 0)\n            dockMonitorCombo.set_active(primaryIndex);\n    }\n\n    _bindSettings() {\n        // Position and size panel\n\n        this._updateMonitorsSettings();\n        this._monitorsConfig.connect('updated',\n            () => this._updateMonitorsSettings());\n        this._settings.connect('changed::preferred-monitor',\n            () => this._updateMonitorsSettings());\n        this._settings.connect('changed::preferred-monitor-by-connector',\n            () => this._updateMonitorsSettings());\n\n        // Position option\n        const position = this._settings.get_enum('dock-position');\n\n        switch (position) {\n        case 0:\n            this._builder.get_object('position_top_button').set_active(true);\n            break;\n        case 1:\n            this._builder.get_object('position_right_button').set_active(true);\n            break;\n        case 2:\n            this._builder.get_object('position_bottom_button').set_active(true);\n            break;\n        case 3:\n            this._builder.get_object('position_left_button').set_active(true);\n            break;\n        }\n\n        if (this._rtl) {\n            /* Left is Right in rtl as a setting */\n            this._builder.get_object('position_left_button').set_label(__('Right'));\n            this._builder.get_object('position_right_button').set_label(__('Left'));\n        }\n\n        // Intelligent autohide options\n        this._settings.bind('dock-fixed',\n            this._builder.get_object('intelligent_autohide_switch'),\n            'active',\n            Gio.SettingsBindFlags.INVERT_BOOLEAN);\n        this._settings.bind('dock-fixed',\n            this._builder.get_object('intelligent_autohide_button'),\n            'sensitive',\n            Gio.SettingsBindFlags.INVERT_BOOLEAN);\n        this._settings.bind('autohide',\n            this._builder.get_object('autohide_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('autohide-in-fullscreen',\n            this._builder.get_object('autohide_enable_in_fullscreen_checkbutton'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-dock-urgent-notify',\n            this._builder.get_object('show_dock_urgent_notify_checkbutton'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('require-pressure-to-show',\n            this._builder.get_object('require_pressure_checkbutton'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('intellihide',\n            this._builder.get_object('intellihide_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('animation-time',\n            this._builder.get_object('animation_duration_spinbutton'),\n            'value',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('hide-delay',\n            this._builder.get_object('hide_timeout_spinbutton'),\n            'value',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-delay',\n            this._builder.get_object('show_timeout_spinbutton'),\n            'value',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('pressure-threshold',\n            this._builder.get_object('pressure_threshold_spinbutton'),\n            'value',\n            Gio.SettingsBindFlags.DEFAULT);\n\n        // this._builder.get_object('animation_duration_spinbutton').set_value(\n        //   this._settings.get_double('animation-time'));\n\n        // Create dialog for intelligent autohide advanced settings\n        this._builder.get_object('intelligent_autohide_button').connect('clicked', () => {\n            const dialog = new Gtk.Dialog({\n                title: __('Intelligent autohide customization'),\n                transient_for: this.widget.get_root(),\n                use_header_bar: true,\n                modal: true,\n            });\n\n            // GTK+ leaves positive values for application-defined response ids.\n            // Use +1 for the reset action\n            dialog.add_button(__('Reset to defaults'), 1);\n\n            const box = this._builder.get_object('intelligent_autohide_advanced_settings_box');\n            dialog.get_content_area().append(box);\n\n            this._settings.bind('intellihide',\n                this._builder.get_object('intellihide_mode_box'),\n                'sensitive',\n                Gio.SettingsBindFlags.GET);\n\n            // intellihide mode\n\n            const intellihideModeRadioButtons = [\n                this._builder.get_object('all_windows_radio_button'),\n                this._builder.get_object('focus_application_windows_radio_button'),\n                this._builder.get_object('maximized_windows_radio_button'),\n                this._builder.get_object('always_on_top_radio_button'),\n            ];\n\n            intellihideModeRadioButtons[this._settings.get_enum('intellihide-mode')].set_active(true);\n\n            this._settings.bind('autohide',\n                this._builder.get_object('require_pressure_checkbutton'),\n                'sensitive',\n                Gio.SettingsBindFlags.GET);\n\n            this._settings.bind('autohide',\n                this._builder.get_object('autohide_enable_in_fullscreen_checkbutton'),\n                'sensitive',\n                Gio.SettingsBindFlags.GET);\n\n            this._settings.bind('autohide',\n                this._builder.get_object('show_dock_urgent_notify_checkbutton'),\n                'sensitive',\n                Gio.SettingsBindFlags.GET);\n\n            this._settings.bind('require-pressure-to-show',\n                this._builder.get_object('show_timeout_spinbutton'),\n                'sensitive',\n                Gio.SettingsBindFlags.INVERT_BOOLEAN);\n            this._settings.bind('require-pressure-to-show',\n                this._builder.get_object('show_timeout_label'),\n                'sensitive',\n                Gio.SettingsBindFlags.INVERT_BOOLEAN);\n            this._settings.bind('require-pressure-to-show',\n                this._builder.get_object('pressure_threshold_spinbutton'),\n                'sensitive',\n                Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('require-pressure-to-show',\n                this._builder.get_object('pressure_threshold_label'),\n                'sensitive',\n                Gio.SettingsBindFlags.DEFAULT);\n\n            dialog.connect('response', (_, id) => {\n                if (id === 1) {\n                    // restore default settings for the relevant keys\n                    const keys = ['intellihide', 'autohide', 'intellihide-mode',\n                        'autohide-in-fullscreen', 'show-dock-urgent-notify',\n                        'require-pressure-to-show', 'animation-time',\n                        'show-delay', 'hide-delay', 'pressure-threshold'];\n                    keys.forEach(function (val) {\n                        this._settings.set_value(val, this._settings.get_default_value(val));\n                    }, this);\n                    intellihideModeRadioButtons[this._settings.get_enum('intellihide-mode')].set_active(true);\n                } else {\n                    // remove the settings box so it doesn't get destroyed;\n                    dialog.get_content_area().remove(box);\n                    dialog.destroy();\n                }\n            });\n\n            dialog.present();\n        });\n\n        // size options\n        const dockSizeScale = this._builder.get_object('dock_size_scale');\n        dockSizeScale.set_value(this._settings.get_double('height-fraction'));\n        dockSizeScale.add_mark(0.9, Gtk.PositionType.TOP, null);\n        dockSizeScale.set_format_value_func((_, value) => {\n            return `${Math.round(value * 100)} %`;\n        });\n        const iconSizeScale = this._builder.get_object('icon_size_scale');\n        iconSizeScale.set_range(8, DEFAULT_ICONS_SIZES[0]);\n        iconSizeScale.set_value(this._settings.get_int('dash-max-icon-size'));\n        DEFAULT_ICONS_SIZES.forEach(val => {\n            iconSizeScale.add_mark(val, Gtk.PositionType.TOP, val.toString());\n        });\n        iconSizeScale.set_format_value_func((_, value) => {\n            return `${value} px`;\n        });\n        this._builder.get_object('preview_size_scale').set_value(\n            this._settings.get_double('preview-size-scale'));\n\n        // Corrent for rtl languages\n        if (this._rtl) {\n            // Flip value position: this is not done automatically\n            dockSizeScale.set_value_pos(Gtk.PositionType.LEFT);\n            iconSizeScale.set_value_pos(Gtk.PositionType.LEFT);\n            // I suppose due to a bug, having a more than one mark and one above\n            // a value of 100 makes the rendering of the marks wrong in rtl.\n            // This doesn't happen setting the scale as not flippable\n            // and then manually inverting it\n            iconSizeScale.set_flippable(false);\n            iconSizeScale.set_inverted(true);\n        }\n\n        this._settings.bind('icon-size-fixed',\n            this._builder.get_object('icon_size_fixed_checkbutton'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('extend-height',\n            this._builder.get_object('dock_size_extend_checkbutton'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('extend-height',\n            this._builder.get_object('dock_size_scale'),\n            'sensitive',\n            Gio.SettingsBindFlags.INVERT_BOOLEAN);\n        this._settings.bind('always-center-icons',\n            this._builder.get_object('dock_center_icons_check'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('extend-height',\n            this._builder.get_object('dock_center_icons_check'),\n            'sensitive',\n            Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('multi-monitor',\n            this._builder.get_object('dock_monitor_combo'),\n            'sensitive',\n            Gio.SettingsBindFlags.INVERT_BOOLEAN);\n\n\n        // Apps panel\n\n        this._settings.bind('show-running',\n            this._builder.get_object('show_running_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        const applicationButtonIsolationButton =\n            this._builder.get_object('application_button_isolation_button');\n        this._settings.bind('isolate-workspaces',\n            applicationButtonIsolationButton,\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        applicationButtonIsolationButton.connect(\n            'notify::sensitive', check => {\n                if (check.sensitive) {\n                    [check.label] = check.label.split('\\n');\n                } else {\n                    check.label += `\\n${\n                        __('Managed by GNOME Multitasking\\'s Application Switching setting.')}`;\n                }\n            });\n        this._appSwitcherSettings.bind('current-workspace-only',\n            applicationButtonIsolationButton,\n            'sensitive',\n            Gio.SettingsBindFlags.INVERT_BOOLEAN |\n            Gio.SettingsBindFlags.SYNC_CREATE);\n        this._settings.bind('workspace-agnostic-urgent-windows',\n            this._builder.get_object('application_button_urgent_button'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('isolate-monitors',\n            this._builder.get_object('application_button_monitor_isolation_button'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-windows-preview',\n            this._builder.get_object('windows_preview_button'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('multi-monitor',\n            this._builder.get_object('multi_monitor_button'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-favorites',\n            this._builder.get_object('show_favorite_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-trash',\n            this._builder.get_object('show_trash_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-mounts',\n            this._builder.get_object('show_mounts_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-mounts-only-mounted',\n            this._builder.get_object('show_only_mounted_devices_check'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-mounts-network',\n            this._builder.get_object('show_network_volumes_check'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('isolate-locations',\n            this._builder.get_object('isolate_locations_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        const isolateLocationsBindings = ['show_trash_switch', 'show_mounts_switch'];\n        const updateIsolateLocations = () => {\n            this._builder.get_object('isolate_locations_row').sensitive =\n                isolateLocationsBindings.some(s => this._builder.get_object(s).active);\n        };\n        updateIsolateLocations();\n        isolateLocationsBindings.forEach(s => this._builder.get_object(s).connect(\n            'notify::active', () => updateIsolateLocations()));\n        this._settings.bind('dance-urgent-applications',\n            this._builder.get_object('wiggle_urgent_applications_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('hide-tooltip',\n            this._builder.get_object('hide_tooltip_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-icons-emblems',\n            this._builder.get_object('show_icons_emblems_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        const notificationsCounterCheck = this._builder.get_object(\n            'notifications_counter_check');\n        this._settings.bind('show-icons-notifications-counter',\n            notificationsCounterCheck,\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-icons-emblems',\n            notificationsCounterCheck,\n            'sensitive',\n            Gio.SettingsBindFlags.GET);\n\n        const applicationsOverrideCounter =\n            this._builder.get_object('applications_override_counter');\n        this._settings.bind('application-counter-overrides-notifications',\n            applicationsOverrideCounter,\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        notificationsCounterCheck.bind_property('active',\n            applicationsOverrideCounter, 'sensitive',\n            GObject.BindingFlags.SYNC_CREATE);\n        this._settings.connect('changed::show-icons-emblems', () => {\n            if (this._settings.get_boolean('show-icons-emblems'))\n                applicationsOverrideCounter.sensitive = notificationsCounterCheck.active;\n            else\n                applicationsOverrideCounter.sensitive = false;\n        });\n        this._settings.bind('show-show-apps-button',\n            this._builder.get_object('show_applications_button_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-apps-at-top',\n            this._builder.get_object('application_button_first_button'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-show-apps-button',\n            this._builder.get_object('application_button_first_button'),\n            'sensitive',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-show-apps-button',\n            this._builder.get_object('application_button_animation_button'),\n            'sensitive',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-apps-always-in-the-edge',\n            this._builder.get_object('show_apps_always_in_the_edge'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('show-show-apps-button',\n            this._builder.get_object('show_apps_always_in_the_edge'),\n            'sensitive',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('scroll-to-focused-application',\n            this._builder.get_object('scroll_to_icon_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n\n\n        // Behavior panel\n\n        this._settings.bind('hot-keys',\n            this._builder.get_object('hot_keys_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('hot-keys',\n            this._builder.get_object('overlay_button'),\n            'sensitive',\n            Gio.SettingsBindFlags.DEFAULT);\n\n        this._builder.get_object('click_action_combo').set_active(this._settings.get_enum('click-action'));\n        this._builder.get_object('click_action_combo').connect('changed', widget => {\n            this._settings.set_enum('click-action', widget.get_active());\n        });\n\n        this._builder.get_object('scroll_action_combo').set_active(this._settings.get_enum('scroll-action'));\n        this._builder.get_object('scroll_action_combo').connect('changed', widget => {\n            this._settings.set_enum('scroll-action', widget.get_active());\n        });\n\n        this._builder.get_object('shift_click_action_combo').connect('changed', widget => {\n            this._settings.set_enum('shift-click-action', widget.get_active());\n        });\n\n        this._builder.get_object('middle_click_action_combo').connect('changed', widget => {\n            this._settings.set_enum('middle-click-action', widget.get_active());\n        });\n        this._builder.get_object('shift_middle_click_action_combo').connect('changed', widget => {\n            this._settings.set_enum('shift-middle-click-action', widget.get_active());\n        });\n\n        // Create dialog for number overlay options\n        this._builder.get_object('overlay_button').connect('clicked', () => {\n            const dialog = new Gtk.Dialog({\n                title: __('Show dock and application numbers'),\n                transient_for: this.widget.get_root(),\n                use_header_bar: true,\n                modal: true,\n            });\n\n            // GTK+ leaves positive values for application-defined response ids.\n            // Use +1 for the reset action\n            dialog.add_button(__('Reset to defaults'), 1);\n\n            const box = this._builder.get_object('box_overlay_shortcut');\n            dialog.get_content_area().append(box);\n\n            this._builder.get_object('overlay_switch').set_active(\n                this._settings.get_boolean('hotkeys-overlay'));\n            this._builder.get_object('show_dock_switch').set_active(\n                this._settings.get_boolean('hotkeys-show-dock'));\n\n            // We need to update the shortcut 'strv' when the text is modified\n            this._settings.connect('changed::shortcut-text', () => setShortcut(this._settings));\n            this._settings.bind('shortcut-text',\n                this._builder.get_object('shortcut_entry'),\n                'text',\n                Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('hotkeys-overlay',\n                this._builder.get_object('overlay_switch'),\n                'active',\n                Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('hotkeys-show-dock',\n                this._builder.get_object('show_dock_switch'),\n                'active',\n                Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('shortcut-timeout',\n                this._builder.get_object('timeout_spinbutton'),\n                'value',\n                Gio.SettingsBindFlags.DEFAULT);\n\n            dialog.connect('response', (_, id) => {\n                if (id === 1) {\n                    // restore default settings for the relevant keys\n                    const keys = ['shortcut-text', 'hotkeys-overlay',\n                        'hotkeys-show-dock', 'shortcut-timeout'];\n                    keys.forEach(function (val) {\n                        this._settings.set_value(val, this._settings.get_default_value(val));\n                    }, this);\n                } else {\n                    // remove the settings box so it doesn't get destroyed;\n                    dialog.get_content_area().remove(box);\n                    dialog.destroy();\n                }\n            });\n\n            dialog.present();\n        });\n\n        // Create dialog for middle-click options\n        this._builder.get_object('middle_click_options_button').connect('clicked', () => {\n            const dialog = new Gtk.Dialog({\n                title: __('Customize middle-click behavior'),\n                transient_for: this.widget.get_root(),\n                use_header_bar: true,\n                modal: true,\n            });\n\n            // GTK+ leaves positive values for application-defined response ids.\n            // Use +1 for the reset action\n            dialog.add_button(__('Reset to defaults'), 1);\n\n            const box = this._builder.get_object('box_middle_click_options');\n            dialog.get_content_area().append(box);\n\n            this._builder.get_object('shift_click_action_combo').set_active(\n                this._settings.get_enum('shift-click-action'));\n\n            this._builder.get_object('middle_click_action_combo').set_active(\n                this._settings.get_enum('middle-click-action'));\n\n            this._builder.get_object('shift_middle_click_action_combo').set_active(\n                this._settings.get_enum('shift-middle-click-action'));\n\n            this._settings.bind('shift-click-action',\n                this._builder.get_object('shift_click_action_combo'),\n                'active-id',\n                Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('middle-click-action',\n                this._builder.get_object('middle_click_action_combo'),\n                'active-id',\n                Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('shift-middle-click-action',\n                this._builder.get_object('shift_middle_click_action_combo'),\n                'active-id',\n                Gio.SettingsBindFlags.DEFAULT);\n\n            dialog.connect('response', (_, id) => {\n                if (id === 1) {\n                    // restore default settings for the relevant keys\n                    const keys = ['shift-click-action', 'middle-click-action', 'shift-middle-click-action'];\n                    keys.forEach(function (val) {\n                        this._settings.set_value(val, this._settings.get_default_value(val));\n                    }, this);\n                    this._builder.get_object('shift_click_action_combo').set_active(\n                        this._settings.get_enum('shift-click-action'));\n                    this._builder.get_object('middle_click_action_combo').set_active(\n                        this._settings.get_enum('middle-click-action'));\n                    this._builder.get_object('shift_middle_click_action_combo').set_active(\n                        this._settings.get_enum('shift-middle-click-action'));\n                } else {\n                    // remove the settings box so it doesn't get destroyed;\n                    dialog.get_content_area().remove(box);\n                    dialog.destroy();\n                }\n            });\n\n            dialog.present();\n        });\n\n        // Appearance Panel\n\n        this._settings.bind('apply-custom-theme',\n            this._builder.get_object('customize_theme'),\n            'sensitive',\n            Gio.SettingsBindFlags.INVERT_BOOLEAN | Gio.SettingsBindFlags.GET);\n        this._settings.bind('apply-custom-theme',\n            this._builder.get_object('builtin_theme_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('custom-theme-shrink',\n            this._builder.get_object('shrink_dash_switch'),\n            'active',\n            Gio.SettingsBindFlags.DEFAULT);\n\n        // Running indicators\n        this._builder.get_object('running_indicators_combo').set_active(\n            this._settings.get_enum('running-indicator-style')\n        );\n        this._builder.get_object('running_indicators_combo').connect(\n            'changed',\n            widget => {\n                this._settings.set_enum('running-indicator-style', widget.get_active());\n            }\n        );\n\n        if (this._settings.get_enum('running-indicator-style') === RunningIndicatorStyle.DEFAULT)\n            this._builder.get_object('running_indicators_advance_settings_button').set_sensitive(false);\n\n        this._settings.connect('changed::running-indicator-style', () => {\n            if (this._settings.get_enum('running-indicator-style') === RunningIndicatorStyle.DEFAULT)\n                this._builder.get_object('running_indicators_advance_settings_button').set_sensitive(false);\n            else\n                this._builder.get_object('running_indicators_advance_settings_button').set_sensitive(true);\n        });\n\n        // Create dialog for running indicators advanced settings\n        this._builder.get_object('running_indicators_advance_settings_button').connect('clicked', () => {\n            const dialog = new Gtk.Dialog({\n                title: __('Customize running indicators'),\n                transient_for: this.widget.get_root(),\n                use_header_bar: true,\n                modal: true,\n            });\n\n            const box = this._builder.get_object('running_dots_advance_settings_box');\n            dialog.get_content_area().append(box);\n\n            this._settings.bind('running-indicator-dominant-color',\n                this._builder.get_object('dominant_color_switch'),\n                'active',\n                Gio.SettingsBindFlags.DEFAULT);\n\n            this._settings.bind('custom-theme-customize-running-dots',\n                this._builder.get_object('dot_style_switch'),\n                'active',\n                Gio.SettingsBindFlags.DEFAULT);\n            this._settings.bind('custom-theme-customize-running-dots',\n                this._builder.get_object('dot_style_settings_box'),\n                'sensitive', Gio.SettingsBindFlags.DEFAULT);\n\n            const rgba = new Gdk.RGBA();\n            rgba.parse(this._settings.get_string('custom-theme-running-dots-color'));\n            this._builder.get_object('dot_color_colorbutton').set_rgba(rgba);\n\n            this._builder.get_object('dot_color_colorbutton').connect('notify::rgba', button => {\n                const css = button.rgba.to_string();\n\n                this._settings.set_string('custom-theme-running-dots-color', css);\n            });\n\n            rgba.parse(this._settings.get_string('custom-theme-running-dots-border-color'));\n            this._builder.get_object('dot_border_color_colorbutton').set_rgba(rgba);\n\n            this._builder.get_object('dot_border_color_colorbutton').connect('notify::rgba', button => {\n                const css = button.rgba.to_string();\n\n                this._settings.set_string('custom-theme-running-dots-border-color', css);\n            });\n\n            this._settings.bind('custom-theme-running-dots-border-width',\n                this._builder.get_object('dot_border_width_spin_button'),\n                'value',\n                Gio.SettingsBindFlags.DEFAULT);\n\n\n            dialog.connect('response', () => {\n                // remove the settings box so it doesn't get destroyed;\n                dialog.get_content_area().remove(box);\n                dialog.destroy();\n            });\n\n            dialog.present();\n        });\n\n        this._settings.bind('custom-background-color',\n            this._builder.get_object('custom_background_color_switch'),\n            'active', Gio.SettingsBindFlags.DEFAULT);\n        this._settings.bind('custom-background-color',\n            this._builder.get_object('custom_background_color'),\n            'sensitive', Gio.SettingsBindFlags.DEFAULT);\n\n        const rgba = new Gdk.RGBA();\n        rgba.parse(this._settings.get_string('background-color'));\n        this._builder.get_object('custom_background_color').set_rgba(rgba);\n\n        this._builder.get_object('custom_background_color').connect('notify::rgba', button => {\n            const css = button.rgba.to_string();\n\n            this._settings.set_string('background-color', css);\n        });\n\n        // Opacity\n        this._builder.get_object('customize_opacity_combo').set_active_id(\n            this._settings.get_enum('transparency-mode').toString()\n        );\n        this._builder.get_object('customize_opacity_combo').connect(\n            'changed',\n            widget => {\n                this._settings.set_enum('transparency-mode', parseInt(widget.get_active_id()));\n            }\n        );\n\n        const customOpacityScale = this._builder.get_object('custom_opacity_scale');\n        customOpacityScale.set_value(this._settings.get_double('background-opacity'));\n        customOpacityScale.set_format_value_func((_, value) => {\n            return `${Math.round(value * 100)}%`;\n        });\n\n        if (this._settings.get_enum('transparency-mode') !== TransparencyMode.FIXED)\n            this._builder.get_object('custom_opacity_scale').set_sensitive(false);\n\n        this._settings.connect('changed::transparency-mode', () => {\n            if (this._settings.get_enum('transparency-mode') !== TransparencyMode.FIXED)\n                this._builder.get_object('custom_opacity_scale').set_sensitive(false);\n            else\n                this._builder.get_object('custom_opacity_scale').set_sensitive(true);\n        });\n\n        if (this._settings.get_enum('transparency-mode') !== TransparencyMode.DYNAMIC)\n            this._builder.get_object('dynamic_opacity_button').set_sensitive(false);\n\n\n        this._settings.connect('changed::transparency-mode', () => {\n            if (this._settings.get_enum('transparency-mode') !== TransparencyMode.DYNAMIC)\n                this._builder.get_object('dynamic_opacity_button').set_sensitive(false);\n\n            else\n                this._builder.get_object('dynamic_opacity_button').set_sensitive(true);\n        });\n\n        // Create dialog for transparency advanced settings\n        this._builder.get_object('dynamic_opacity_button').connect('clicked', () => {\n            const dialog = new Gtk.Dialog({\n                title: __('Customize opacity'),\n                transient_for: this.widget.get_root(),\n                use_header_bar: true,\n                modal: true,\n            });\n\n            const box = this._builder.get_object('advanced_transparency_dialog');\n            dialog.get_content_area().append(box);\n\n            this._settings.bind(\n                'customize-alphas',\n                this._builder.get_object('customize_alphas_switch'),\n                'active',\n                Gio.SettingsBindFlags.DEFAULT\n            );\n            this._settings.bind(\n                'customize-alphas',\n                this._builder.get_object('min_alpha_scale'),\n                'sensitive',\n                Gio.SettingsBindFlags.DEFAULT\n            );\n            this._settings.bind(\n                'customize-alphas',\n                this._builder.get_object('max_alpha_scale'),\n                'sensitive',\n                Gio.SettingsBindFlags.DEFAULT\n            );\n\n            const minAlphaScale = this._builder.get_object('min_alpha_scale');\n            const maxAlphaScale = this._builder.get_object('max_alpha_scale');\n            minAlphaScale.set_value(\n                this._settings.get_double('min-alpha')\n            );\n            minAlphaScale.set_format_value_func((_, value) => {\n                return `${Math.round(value * 100)} %`;\n            });\n            maxAlphaScale.set_format_value_func((_, value) => {\n                return `${Math.round(value * 100)} %`;\n            });\n\n            maxAlphaScale.set_value(\n                this._settings.get_double('max-alpha')\n            );\n\n            dialog.connect('response', () => {\n                // remove the settings box so it doesn't get destroyed;\n                dialog.get_content_area().remove(box);\n                dialog.destroy();\n            });\n\n            dialog.present();\n        });\n\n\n        this._settings.bind('unity-backlit-items',\n            this._builder.get_object('unity_backlit_items_switch'),\n            'active', Gio.SettingsBindFlags.DEFAULT\n        );\n        this._settings.bind('apply-glossy-effect',\n            this._builder.get_object('apply_gloss_effect_checkbutton'),\n            'active', Gio.SettingsBindFlags.DEFAULT\n        );\n        this._settings.bind('unity-backlit-items',\n            this._builder.get_object('apply_gloss_effect_checkbutton'),\n            'sensitive',\n            Gio.SettingsBindFlags.DEFAULT\n        );\n\n        this._settings.bind('force-straight-corner',\n            this._builder.get_object('force_straight_corner_switch'),\n            'active', Gio.SettingsBindFlags.DEFAULT);\n\n        this._settings.bind('disable-overview-on-startup',\n            this._builder.get_object('show_overview_on_startup_switch'),\n            'active', Gio.SettingsBindFlags.INVERT_BOOLEAN);\n\n        // About Panel\n\n        this._builder.get_object('extension_version').set_label(\n            `${this._extensionPreferences.metadata.version}`);\n    }\n});\n\nexport default class DockPreferences extends ExtensionPreferences {\n    getPreferencesWidget() {\n        const settings = new DockSettings(this);\n        const {widget} = settings;\n        return widget;\n    }\n}\n"
        },
        {
          "name": "schemas",
          "type": "tree",
          "content": null
        },
        {
          "name": "theming.js",
          "type": "blob",
          "size": 19.89453125,
          "content": "// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-\n\nimport {\n    Clutter,\n    Cogl,\n    GObject,\n    Meta,\n    St,\n} from './dependencies/gi.js';\n\nimport {Main} from './dependencies/shell/ui.js';\n\nimport {\n    Docking,\n    Utils,\n} from './imports.js';\n\nconst {signals: Signals} = imports;\n\n/*\n * DEFAULT:  transparency given by theme\n * FIXED:    constant transparency chosen by user\n * DYNAMIC:  apply 'transparent' style when no windows are close to the dock\n * */\nconst TransparencyMode = {\n    DEFAULT:  0,\n    FIXED:    1,\n    DYNAMIC:  3,\n};\n\nconst Labels = Object.freeze({\n    TRANSPARENCY: Symbol('transparency'),\n});\n\nexport const PositionStyleClass = Object.freeze([\n    'top',\n    'right',\n    'bottom',\n    'left',\n]);\n\n/**\n * Manage theme customization and custom theme support\n */\nexport class ThemeManager {\n    constructor(dock) {\n        this._signalsHandler = new Utils.GlobalSignalsHandler(this);\n        this._bindSettingsChanges();\n        this._actor = dock;\n        this._dash = dock.dash;\n\n        // initialize colors with generic values\n        this._customizedBackground = {red: 0, green: 0, blue: 0, alpha: 0};\n        this._customizedBorder = {red: 0, green: 0, blue: 0, alpha: 0};\n        this._transparency = new Transparency(dock);\n\n        this._signalsHandler.add([\n            // When theme changes re-obtain default background color\n            St.ThemeContext.get_for_stage(global.stage),\n            'changed',\n            this.updateCustomTheme.bind(this),\n        ], [\n            // update :overview pseudoclass\n            Main.overview,\n            'showing',\n            this._onOverviewShowing.bind(this),\n        ], [\n            Main.overview,\n            'hiding',\n            this._onOverviewHiding.bind(this),\n        ]);\n\n        this._updateCustomStyleClasses();\n\n        // destroy themeManager when the managed actor is destroyed (e.g. extension unload)\n        // in order to disconnect signals\n        this._signalsHandler.add(this._actor, 'destroy', () => this.destroy());\n    }\n\n    destroy() {\n        this.emit('destroy');\n        this._transparency.destroy();\n        this._destroyed = true;\n    }\n\n    _onOverviewShowing() {\n        this._actor.add_style_pseudo_class('overview');\n    }\n\n    _onOverviewHiding() {\n        this._actor.remove_style_pseudo_class('overview');\n    }\n\n    _updateDashOpacity() {\n        const newAlpha = Docking.DockManager.settings.backgroundOpacity;\n\n        const [backgroundColor, borderColor] = this._getDefaultColors();\n\n        if (!backgroundColor)\n            return;\n\n        // Get the background and border alphas. We check the background alpha\n        // for a minimum of .001 to prevent division by 0 errors\n        const backgroundAlpha = Math.max(Math.round(backgroundColor.alpha / 2.55) / 100, .001);\n        let borderAlpha = Math.round(borderColor.alpha / 2.55) / 100;\n\n        // The border and background alphas should remain in sync\n        // We also limit the borderAlpha to a maximum of 1 (full opacity)\n        borderAlpha = Math.min((borderAlpha / backgroundAlpha) * newAlpha, 1);\n\n        this._customizedBackground = `rgba(${\n            backgroundColor.red},${\n            backgroundColor.green},${\n            backgroundColor.blue},${\n            newAlpha})`;\n\n        this._customizedBorder = `rgba(${\n            borderColor.red},${\n            borderColor.green},${\n            borderColor.blue},${\n            borderAlpha})`;\n    }\n\n    _getDefaultColors() {\n        // Prevent shell crash if the actor is not on the stage.\n        // It happens enabling/disabling repeatedly the extension\n        if (!this._dash._background.get_stage())\n            return [null, null];\n\n        // Remove custom style\n        const oldStyle = this._dash._background.get_style();\n        this._dash._background.set_style(null);\n\n        const themeNode = this._dash._background.get_theme_node();\n        this._dash._background.set_style(oldStyle);\n\n        const backgroundColor = themeNode.get_background_color();\n\n        // Just in case the theme has different border colors ..\n        // We want to find the inside border-color of the dock because it is\n        // the side most visible to the user. We do this by finding the side\n        // opposite the position\n        const position = Utils.getPosition();\n        let side = position + 2;\n        if (side > 3)\n            side = Math.abs(side - 4);\n\n        const borderColor = themeNode.get_border_color(side);\n\n        return [backgroundColor, borderColor];\n    }\n\n    _updateDashColor() {\n        // Retrieve the color. If needed we will adjust it before passing it to\n        // this._transparency.\n        let [backgroundColor] = this._getDefaultColors();\n\n        if (!backgroundColor)\n            return;\n\n        const {settings} = Docking.DockManager;\n\n        if (settings.customBackgroundColor) {\n            // When applying a custom color, we need to check the alpha value,\n            // if not the opacity will always be overridden by the color below.\n            // Note that if using 'dynamic' transparency modes,\n            // the opacity will be set by the opaque/transparent styles anyway.\n            let newAlpha = Math.round(backgroundColor.alpha / 2.55) / 100;\n\n            ({backgroundColor} = settings);\n            // backgroundColor is a string like rgb(0,0,0)\n            const Color = Clutter.Color ?? Cogl.Color;\n            const [ret, color] = Color.from_string(backgroundColor);\n            if (!ret) {\n                logError(new Error(`${backgroundColor} is not a valid color string`));\n                return;\n            }\n\n            if (settings.transparencyMode === TransparencyMode.FIXED) {\n                newAlpha = settings.backgroundOpacity;\n                this._customizedBackground =\n                    `rgba(${color.red}, ${color.green}, ${color.blue}, ${newAlpha})`;\n            } else {\n                this._customizedBackground = backgroundColor;\n            }\n\n            this._customizedBorder = this._customizedBackground;\n\n            color.alpha = newAlpha * 255;\n            this._transparency.setColor(color);\n        } else {\n            // backgroundColor is a {Clutter,Cogl}.Color object\n            this._transparency.setColor(backgroundColor);\n        }\n    }\n\n    _updateCustomStyleClasses() {\n        const {settings} = Docking.DockManager;\n\n        if (settings.applyCustomTheme)\n            this._actor.add_style_class_name('dashtodock');\n        else\n            this._actor.remove_style_class_name('dashtodock');\n\n        if (settings.customThemeShrink)\n            this._actor.add_style_class_name('shrink');\n        else\n            this._actor.remove_style_class_name('shrink');\n\n        if (settings.runningIndicatorStyle !== 0)\n            this._actor.add_style_class_name('running-dots');\n        else\n            this._actor.remove_style_class_name('running-dots');\n\n        // If not the built-in theme option is not selected\n        if (!settings.applyCustomTheme) {\n            if (settings.forceStraightCorner)\n                this._actor.add_style_class_name('straight-corner');\n            else\n                this._actor.remove_style_class_name('straight-corner');\n        } else {\n            this._actor.remove_style_class_name('straight-corner');\n        }\n    }\n\n    updateCustomTheme() {\n        if (this._destroyed)\n            throw new Error(`Impossible to update a destroyed ${this.constructor.name}`);\n        this._updateCustomStyleClasses();\n        this._updateDashOpacity();\n        this._updateDashColor();\n        this._adjustTheme();\n        this.emit('updated');\n    }\n\n    /**\n     * Reimported back and adapted from atomdock\n     */\n    _adjustTheme() {\n        // Prevent shell crash if the actor is not on the stage.\n        // It happens enabling/disabling repeatedly the extension\n        if (!this._dash._background.get_stage())\n            return;\n\n        const {settings} = Docking.DockManager;\n\n        // Remove prior style edits\n        this._dash._background.set_style(null);\n        this._transparency.disable();\n\n        // If built-in theme is enabled do nothing else\n        if (settings.applyCustomTheme)\n            return;\n\n        let newStyle = '';\n        const position = Utils.getPosition(settings);\n\n        // obtain theme border settings\n        const themeNode = this._dash._background.get_theme_node();\n        const borderColor = themeNode.get_border_color(St.Side.TOP);\n        const borderWidth = themeNode.get_border_width(St.Side.TOP);\n\n        // We're copying border and corner styles to left border and top-left\n        // corner, also removing bottom border and bottom-right corner styles\n        let borderMissingStyle = '';\n\n        if (this._rtl && (position !== St.Side.RIGHT)) {\n            borderMissingStyle = `border-right: ${borderWidth}px solid ${\n                borderColor.to_string()};`;\n        } else if (!this._rtl && (position !== St.Side.LEFT)) {\n            borderMissingStyle = `border-left: ${borderWidth}px solid ${\n                borderColor.to_string()};`;\n        }\n\n        newStyle = borderMissingStyle;\n\n        if (newStyle) {\n            // I do call set_style possibly twice so that only the background gets the transition.\n            // The transition-property css rules seems to be unsupported\n            this._dash._background.set_style(newStyle);\n        }\n\n        // Customize background\n        const fixedTransparency = settings.transparencyMode === TransparencyMode.FIXED;\n        const defaultTransparency = settings.transparencyMode === TransparencyMode.DEFAULT;\n        if (!defaultTransparency && !fixedTransparency) {\n            this._transparency.enable();\n        } else if (!defaultTransparency || settings.customBackgroundColor) {\n            newStyle = `${newStyle}background-color:${this._customizedBackground}; ` +\n                       `border-color:${this._customizedBorder}; ` +\n                       'transition-delay: 0s; transition-duration: 0.250s;';\n            this._dash._background.set_style(newStyle);\n        }\n    }\n\n    _bindSettingsChanges() {\n        const keys = ['transparency-mode',\n            'customize-alphas',\n            'min-alpha',\n            'max-alpha',\n            'background-opacity',\n            'custom-background-color',\n            'background-color',\n            'apply-custom-theme',\n            'custom-theme-shrink',\n            'custom-theme-running-dots',\n            'extend-height',\n            'force-straight-corner'];\n\n        this._signalsHandler.add(...keys.map(key => [\n            Docking.DockManager.settings,\n            `changed::${key}`,\n            () => this.updateCustomTheme(),\n        ]));\n    }\n}\nSignals.addSignalMethods(ThemeManager.prototype);\n\n/**\n * The following class is based on the following upstream commit:\n * https://git.gnome.org/browse/gnome-shell/commit/?id=447bf55e45b00426ed908b1b1035f472c2466956\n * Transparency when free-floating\n */\nclass Transparency {\n    constructor(dock) {\n        this._dash = dock.dash;\n        this._actor = this._dash._container;\n        this._backgroundActor = this._dash._background;\n        this._dockActor = dock;\n        this._dock = dock;\n        this._panel = Main.panel;\n        this._position = Utils.getPosition();\n\n        // All these properties are replaced with the ones in the .dummy-opaque\n        // and .dummy-transparent css classes\n        this._backgroundColor = '0,0,0';\n        this._transparentAlpha = '0.2';\n        this._opaqueAlpha = '1';\n        this._transparentAlphaBorder = '0.1';\n        this._opaqueAlphaBorder = '0.5';\n        this._transparentTransition = '0ms';\n        this._opaqueTransition = '0ms';\n        this._base_actor_style = '';\n\n        this._signalsHandler = new Utils.GlobalSignalsHandler();\n        this._trackedWindows = new Map();\n    }\n\n    enable() {\n        // ensure I never double-register/inject\n        // although it should never happen\n        this.disable();\n\n        this._base_actor_style = this._actor.get_style();\n        if (!this._base_actor_style)\n            this._base_actor_style = '';\n\n\n        let addedSignal = 'child-added';\n        let removedSignal = 'child-removed';\n\n        // for compatibility with Gnome Shell 45\n        if (GObject.signal_lookup('actor-added', global.window_group)) {\n            addedSignal = 'actor-added';\n            removedSignal = 'actor-removed';\n        }\n\n        this._signalsHandler.addWithLabel(Labels.TRANSPARENCY, [\n            global.window_group,\n            addedSignal,\n            this._onWindowActorAdded.bind(this),\n        ], [\n            global.window_group,\n            removedSignal,\n            this._onWindowActorRemoved.bind(this),\n        ], [\n            global.window_manager,\n            'switch-workspace',\n            this._updateSolidStyle.bind(this),\n        ], [\n            Main.overview,\n            'hiding',\n            this._updateSolidStyle.bind(this),\n        ], [\n            Main.overview,\n            'showing',\n            this._updateSolidStyle.bind(this),\n        ]);\n\n        // Window signals\n        global.window_group.get_children().filter(child => {\n            // An irrelevant window actor ('Gnome-shell') produces an error when the signals are\n            // disconnected, therefore do not add signals to it.\n            return child instanceof Meta.WindowActor &&\n                   child.get_meta_window().get_wm_class() !== 'Gnome-shell';\n        }).forEach(function (win) {\n            this._onWindowActorAdded(null, win);\n        }, this);\n\n        if (this._actor.get_stage())\n            this._updateSolidStyle();\n\n        this._updateStyles();\n        this._updateSolidStyle();\n\n        this.emit('transparency-enabled');\n    }\n\n    disable() {\n        // ensure I never double-register/inject\n        // although it should never happen\n        this._signalsHandler.removeWithLabel(Labels.TRANSPARENCY);\n\n        for (const key of this._trackedWindows.keys()) {\n            this._trackedWindows.get(key).forEach(id => {\n                key.disconnect(id);\n            });\n        }\n        this._trackedWindows.clear();\n\n        this.emit('transparency-disabled');\n    }\n\n    destroy() {\n        this.disable();\n        this._signalsHandler.destroy();\n    }\n\n    _onWindowActorAdded(container, metaWindowActor) {\n        const signalIds = [];\n        ['notify::allocation', 'notify::visible'].forEach(s => {\n            signalIds.push(metaWindowActor.connect(s, this._updateSolidStyle.bind(this)));\n        });\n        this._trackedWindows.set(metaWindowActor, signalIds);\n    }\n\n    _onWindowActorRemoved(container, metaWindowActor) {\n        if (!this._trackedWindows.get(metaWindowActor))\n            return;\n\n        this._trackedWindows.get(metaWindowActor).forEach(id => {\n            metaWindowActor.disconnect(id);\n        });\n        this._trackedWindows.delete(metaWindowActor);\n        this._updateSolidStyle();\n    }\n\n    _updateSolidStyle() {\n        const isNear = this._dockIsNear();\n        if (isNear) {\n            this._backgroundActor.set_style(this._opaque_style);\n            this._dockActor.remove_style_class_name('transparent');\n            this._dockActor.add_style_class_name('opaque');\n        } else {\n            this._backgroundActor.set_style(this._transparent_style);\n            this._dockActor.remove_style_class_name('opaque');\n            this._dockActor.add_style_class_name('transparent');\n        }\n\n        this.emit('solid-style-updated', isNear);\n    }\n\n    _dockIsNear() {\n        if (this._dockActor.has_style_pseudo_class('overview'))\n            return false;\n        /* Get all the windows in the active workspace that are in the primary monitor and visible */\n        const activeWorkspace = global.workspace_manager.get_active_workspace();\n        const dash = this._dash;\n        const windows = activeWorkspace.list_windows().filter(metaWindow => {\n            return metaWindow.get_monitor() === dash._monitorIndex &&\n                   metaWindow.showing_on_its_workspace() &&\n                   metaWindow.get_window_type() !== Meta.WindowType.DESKTOP &&\n                   !metaWindow.skip_taskbar;\n        });\n\n        /* Check if at least one window is near enough to the panel.\n         * If the dock is hidden, we need to account for the space it would take\n         * up when it slides out. This is avoid an ugly transition.\n         * */\n        let factor = 0;\n        if (!Docking.DockManager.settings.dockFixed &&\n            this._dock.getDockState() === Docking.State.HIDDEN)\n            factor = 1;\n        const [leftCoord, topCoord] = this._actor.get_transformed_position();\n        let threshold;\n        if (this._position === St.Side.LEFT)\n            threshold = leftCoord + this._actor.get_width() * (factor + 1);\n        else if (this._position === St.Side.RIGHT)\n            threshold = leftCoord - this._actor.get_width() * factor;\n        else if (this._position === St.Side.TOP)\n            threshold = topCoord + this._actor.get_height() * (factor + 1);\n        else\n            threshold = topCoord - this._actor.get_height() * factor;\n\n        const scale = St.ThemeContext.get_for_stage(global.stage).scale_factor;\n        const isNearEnough = windows.some(metaWindow => {\n            let coord;\n            if (this._position === St.Side.LEFT) {\n                coord = metaWindow.get_frame_rect().x;\n                return coord < threshold + 5 * scale;\n            } else if (this._position === St.Side.RIGHT) {\n                coord = metaWindow.get_frame_rect().x + metaWindow.get_frame_rect().width;\n                return coord > threshold - 5 * scale;\n            } else if (this._position === St.Side.TOP) {\n                coord = metaWindow.get_frame_rect().y;\n                return coord < threshold + 5 * scale;\n            } else {\n                coord = metaWindow.get_frame_rect().y + metaWindow.get_frame_rect().height;\n                return coord > threshold - 5 * scale;\n            }\n        });\n\n        return isNearEnough;\n    }\n\n    _updateStyles() {\n        this._getAlphas();\n\n        this._transparent_style = `${this._base_actor_style\n        }background-color: rgba(${\n            this._backgroundColor}, ${this._transparentAlpha});` +\n            `border-color: rgba(${\n                this._backgroundColor}, ${this._transparentAlphaBorder});` +\n            `transition-duration: ${this._transparentTransition}ms;`;\n\n        this._opaque_style = `${this._base_actor_style\n        }background-color: rgba(${\n            this._backgroundColor}, ${this._opaqueAlpha});` +\n            `border-color: rgba(${\n                this._backgroundColor},${this._opaqueAlphaBorder});` +\n            `transition-duration: ${this._opaqueTransition}ms;`;\n\n        this.emit('styles-updated');\n    }\n\n    setColor(color) {\n        this._backgroundColor = `${color.red},${color.green},${color.blue}`;\n        this._updateStyles();\n    }\n\n    _getAlphas() {\n        // Create dummy object and add to the uiGroup to get it to the stage\n        const dummyObject = new St.Bin({\n            name: 'dashtodockContainer',\n        });\n        Main.uiGroup.add_child(dummyObject);\n\n        dummyObject.add_style_class_name('dummy-opaque');\n        let themeNode = dummyObject.get_theme_node();\n        this._opaqueAlpha = themeNode.get_background_color().alpha / 255;\n        this._opaqueAlphaBorder = themeNode.get_border_color(0).alpha / 255;\n        this._opaqueTransition = themeNode.get_transition_duration();\n\n        dummyObject.add_style_class_name('dummy-transparent');\n        themeNode = dummyObject.get_theme_node();\n        this._transparentAlpha = themeNode.get_background_color().alpha / 255;\n        this._transparentAlphaBorder = themeNode.get_border_color(0).alpha / 255;\n        this._transparentTransition = themeNode.get_transition_duration();\n\n        Main.uiGroup.remove_child(dummyObject);\n\n        const {settings} = Docking.DockManager;\n\n        if (settings.customizeAlphas) {\n            this._opaqueAlpha = settings.maxAlpha;\n            this._opaqueAlphaBorder = this._opaqueAlpha / 2;\n            this._transparentAlpha = settings.minAlpha;\n            this._transparentAlphaBorder = this._transparentAlpha / 2;\n        }\n    }\n}\nSignals.addSignalMethods(Transparency.prototype);\n"
        },
        {
          "name": "utils.js",
          "type": "blob",
          "size": 20.2734375,
          "content": "import {\n    Clutter,\n    GLib,\n    Gio,\n    GObject,\n    Meta,\n    Shell,\n    St,\n} from './dependencies/gi.js';\n\nimport {\n    Docking,\n} from './imports.js';\n\nconst {_gi: Gi} = imports;\n\nexport const SignalsHandlerFlags = Object.freeze({\n    NONE: 0,\n    CONNECT_AFTER: 1,\n});\n\nconst GENERIC_KEY = Symbol('generic');\n\n/**\n * Simplify global signals and function injections handling\n * abstract class\n */\nconst BasicHandler = class DashToDockBasicHandler {\n    static get genericKey() {\n        return GENERIC_KEY;\n    }\n\n    constructor(parentObject) {\n        this._storage = Object.create(null);\n\n        if (parentObject) {\n            if (!(parentObject.connect instanceof Function))\n                throw new TypeError('Not a valid parent object');\n\n            if (!(parentObject instanceof GObject.Object) ||\n                GObject.signal_lookup('destroy', parentObject.constructor.$gtype)) {\n                this._parentObject = parentObject;\n                this._destroyId = parentObject.connect('destroy', () => this.destroy());\n            }\n        }\n    }\n\n    add(...args) {\n        // Convert arguments object to array, concatenate with generic\n        // Call addWithLabel with ags as if they were passed arguments\n        this.addWithLabel(GENERIC_KEY, ...args);\n    }\n\n    clear() {\n        Object.getOwnPropertySymbols(this._storage).forEach(label =>\n            this.removeWithLabel(label));\n    }\n\n    destroy() {\n        this._parentObject?.disconnect(this._destroyId);\n        this._parentObject = null;\n\n        this.clear();\n    }\n\n    block() {\n        Object.getOwnPropertySymbols(this._storage).forEach(label =>\n            this.blockWithLabel(label));\n    }\n\n    unblock() {\n        Object.getOwnPropertySymbols(this._storage).forEach(label =>\n            this.unblockWithLabel(label));\n    }\n\n    addWithLabel(label, ...args) {\n        if (typeof label !== 'symbol')\n            throw new Error(`Invalid label ${label}, must be a symbol`);\n\n        let argsArray = [...args];\n        if (argsArray.every(arg => !Array.isArray(arg)))\n            argsArray = [argsArray];\n\n        if (this._storage[label] === undefined)\n            this._storage[label] = [];\n\n        // Skip first element of the arguments\n        for (const argArray of argsArray) {\n            if (argArray.length < 3)\n                throw new Error('Unexpected number of arguments');\n            const item = this._storage[label];\n            try {\n                item.push(this._create(...argArray));\n            } catch (e) {\n                logError(e);\n            }\n        }\n    }\n\n    removeWithLabel(label) {\n        this._storage[label]?.reverse().forEach(item => this._remove(item));\n        delete this._storage[label];\n    }\n\n    blockWithLabel(label) {\n        (this._storage[label] || []).forEach(item => this._block(item));\n    }\n\n    unblockWithLabel(label) {\n        (this._storage[label] || []).forEach(item => this._unblock(item));\n    }\n\n    _removeByItem(item) {\n        Object.getOwnPropertySymbols(this._storage).forEach(label =>\n            (this._storage[label] = this._storage[label].filter(it => {\n                if (!this._itemsEqual(it, item))\n                    return true;\n                this._remove(item);\n                return false;\n            })));\n    }\n\n    // Virtual methods to be implemented by subclass\n\n    /**\n     * Create single element to be stored in the storage structure\n     *\n     * @param _object\n     * @param _element\n     * @param _callback\n     */\n    _create(_object, _element, _callback) {\n        throw new GObject.NotImplementedError(`_create in ${this.constructor.name}`);\n    }\n\n    /**\n     * Correctly delete single element\n     *\n     * @param _item\n     */\n    _remove(_item) {\n        throw new GObject.NotImplementedError(`_remove in ${this.constructor.name}`);\n    }\n\n    /**\n     * Block single element\n     *\n     * @param _item\n     */\n    _block(_item) {\n        throw new GObject.NotImplementedError(`_block in ${this.constructor.name}`);\n    }\n\n    /**\n     * Unblock single element\n     *\n     * @param _item\n     */\n    _unblock(_item) {\n        throw new GObject.NotImplementedError(`_unblock in ${this.constructor.name}`);\n    }\n\n    _itemsEqual(itemA, itemB) {\n        if (itemA === itemB)\n            return true;\n\n        if (itemA.length !== itemB.length)\n            return false;\n\n        return itemA.every((_, idx) => itemA[idx] === itemB[idx]);\n    }\n};\n\n/**\n * Manage global signals\n */\nexport class GlobalSignalsHandler extends BasicHandler {\n    _create(object, event, callback, flags = SignalsHandlerFlags.NONE) {\n        if (!object)\n            throw new Error('Impossible to connect to an invalid object');\n\n        const after = flags === SignalsHandlerFlags.CONNECT_AFTER;\n        const connector = after ? object.connect_after : object.connect;\n\n        if (!connector) {\n            throw new Error(`Requested to connect to signal '${event}', ` +\n                `but no implementation for 'connect${after ? '_after' : ''}' ` +\n                `found in ${object.constructor.name}`);\n        }\n\n        const item = [object];\n        const isDestroy = event === 'destroy';\n        const isParentObject = object === this._parentObject;\n\n        if (isDestroy && !isParentObject) {\n            const originalCallback = callback;\n            callback = () => {\n                this._removeByItem(item);\n                originalCallback();\n            };\n        }\n        const id = connector.call(object, event, callback);\n        item.push(id);\n\n        if (isDestroy && isParentObject) {\n            this._parentObject.disconnect(this._destroyId);\n            this._destroyId =\n                this._parentObject.connect('destroy', () => this.destroy());\n        }\n\n        return item;\n    }\n\n    _remove(item) {\n        const [object, id] = item;\n        object.disconnect(id);\n    }\n\n    _block(item) {\n        const [object, id] = item;\n\n        if (object instanceof GObject.Object)\n            GObject.Object.prototype.block_signal_handler.call(object, id);\n    }\n\n    _unblock(item) {\n        const [object, id] = item;\n\n        if (object instanceof GObject.Object)\n            GObject.Object.prototype.unblock_signal_handler.call(object, id);\n    }\n}\n\n/**\n * Color manipulation utilities\n */\nexport class ColorUtils {\n    // Darken or brigthen color by a fraction dlum\n    // Each rgb value is modified by the same fraction.\n    // Return \"#rrggbb\" string\n    static ColorLuminance(r, g, b, dlum) {\n        let rgbString = '#';\n\n        rgbString += ColorUtils._decimalToHex(Math.round(Math.min(Math.max(r * (1 + dlum), 0), 255)), 2);\n        rgbString += ColorUtils._decimalToHex(Math.round(Math.min(Math.max(g * (1 + dlum), 0), 255)), 2);\n        rgbString += ColorUtils._decimalToHex(Math.round(Math.min(Math.max(b * (1 + dlum), 0), 255)), 2);\n\n        return rgbString;\n    }\n\n    // Convert decimal to an hexadecimal string adding the desired padding\n    static _decimalToHex(d, padding) {\n        let hex = d.toString(16);\n        while (hex.length < padding)\n            hex = `0${hex}`;\n        return hex;\n    }\n\n    // Convert hsv ([0-1, 0-1, 0-1]) to rgb ([0-255, 0-255, 0-255]).\n    // Following algorithm in https://en.wikipedia.org/wiki/HSL_and_HSV\n    // here with h = [0,1] instead of [0, 360]\n    // Accept either (h,s,v) independently or  {h:h, s:s, v:v} object.\n    // Return {r:r, g:g, b:b} object.\n    static HSVtoRGB(h, s, v) {\n        if (arguments.length === 1)\n            ({s, v, h} = h);\n\n        let r, g, b;\n        const c = v * s;\n        const h1 = h * 6;\n        const x = c * (1 - Math.abs(h1 % 2 - 1));\n        const m = v - c;\n\n        if (h1 <= 1) {\n            r = c + m;\n            g = x + m;\n            b = m;\n        } else if (h1 <= 2) {\n            r = x + m;\n            g = c + m;\n            b = m;\n        } else if (h1 <= 3) {\n            r = m;\n            g = c + m;\n            b = x + m;\n        } else if (h1 <= 4) {\n            r = m;\n            g = x + m;\n            b = c + m;\n        } else if (h1 <= 5) {\n            r = x + m;\n            g = m;\n            b = c + m;\n        } else {\n            r = c + m;\n            g = m;\n            b = x + m;\n        }\n\n        return {\n            r: Math.round(r * 255),\n            g: Math.round(g * 255),\n            b: Math.round(b * 255),\n        };\n    }\n\n    // Convert rgb ([0-255, 0-255, 0-255]) to hsv ([0-1, 0-1, 0-1]).\n    // Following algorithm in https://en.wikipedia.org/wiki/HSL_and_HSV\n    // here with h = [0,1] instead of [0, 360]\n    // Accept either (r,g,b) independently or {r:r, g:g, b:b} object.\n    // Return {h:h, s:s, v:v} object.\n    static RGBtoHSV(r, g, b) {\n        if (arguments.length === 1)\n            ({r, g, b} = r);\n\n        let h, s;\n\n        const M = Math.max(r, g, b);\n        const m = Math.min(r, g, b);\n        const c = M - m;\n\n        if (c === 0)\n            h = 0;\n        else if (M === r)\n            h = ((g - b) / c) % 6;\n        else if (M === g)\n            h = (b - r) / c + 2;\n        else\n            h = (r - g) / c + 4;\n\n        h /= 6;\n        const v = M / 255;\n        if (M !== 0)\n            s = c / M;\n        else\n            s = 0;\n\n        return {\n            h,\n            s,\n            v,\n        };\n    }\n}\n\n/**\n * Manage function injection: both instances and prototype can be overridden\n * and restored\n */\nexport class InjectionsHandler extends BasicHandler {\n    _create(object, name, injectedFunction) {\n        const original = object[name];\n\n        if (!(original instanceof Function))\n            throw new Error(`Function ${name}() is not available for ${object}`);\n\n        object[name] = function (...args) {\n            return injectedFunction.call(this, original, ...args);\n        };\n        return [object, name, original];\n    }\n\n    _remove(item) {\n        const [object, name, original] = item;\n        object[name] = original;\n    }\n}\n\n/**\n * Manage vfunction injection: both instances and prototype can be overridden\n * and restored\n */\nexport class VFuncInjectionsHandler extends BasicHandler {\n    _create(prototype, name, injectedFunction) {\n        const original = prototype[`vfunc_${name}`];\n        if (!(original instanceof Function))\n            throw new Error(`Virtual function ${name} is not available for ${prototype}`);\n        this._replaceVFunc(prototype, name, injectedFunction);\n        return [prototype, name];\n    }\n\n    _remove(item) {\n        const [prototype, name] = item;\n        const originalVFunc = prototype[`vfunc_${name}`];\n        try {\n            // This may fail if trying to reset to a never-overridden vfunc\n            // as gjs doesn't consider it a function, even if it's true that\n            // originalVFunc instanceof Function.\n            this._replaceVFunc(prototype, name, originalVFunc);\n        } catch {\n            try {\n                this._replaceVFunc(prototype, name, function (...args) {\n                    // eslint-disable-next-line no-invalid-this\n                    return originalVFunc.call(this, ...args);\n                });\n            } catch (e) {\n                logError(e, `Removing vfunc_${name}`);\n            }\n        }\n    }\n\n    _replaceVFunc(prototype, name, func) {\n        if (Gi.gobject_prototype_symbol && Gi.gobject_prototype_symbol in prototype)\n            prototype = prototype[Gi.gobject_prototype_symbol];\n\n        return prototype[Gi.hook_up_vfunc_symbol](name, func);\n    }\n}\n\n/**\n * Manage properties injection: both instances and prototype can be overridden\n * and restored\n */\nexport class PropertyInjectionsHandler extends BasicHandler {\n    constructor(parentObject, params) {\n        super(parentObject);\n        this._params = params;\n    }\n\n    _create(instance, name, injectedPropertyDescriptor) {\n        if (!this._params?.allowNewProperty && !(name in instance))\n            throw new Error(`Object ${instance} has no '${name}' property`);\n\n        const {prototype} = instance.constructor;\n        const originalPropertyDescriptor = Object.getOwnPropertyDescriptor(prototype, name) ??\n            Object.getOwnPropertyDescriptor(instance, name);\n\n        Object.defineProperty(instance, name, {\n            ...originalPropertyDescriptor,\n            ...injectedPropertyDescriptor,\n            ...{configurable: true},\n        });\n        return [instance, name, originalPropertyDescriptor];\n    }\n\n    _remove(item) {\n        const [instance, name, originalPropertyDescriptor] = item;\n        if (originalPropertyDescriptor)\n            Object.defineProperty(instance, name, originalPropertyDescriptor);\n        else\n            delete instance[name];\n    }\n}\n\n/**\n * Return the actual position reverseing left and right in rtl\n */\nexport function getPosition() {\n    const position = Docking.DockManager.settings.dockPosition;\n    if (Clutter.get_default_text_direction() === Clutter.TextDirection.RTL) {\n        if (position === St.Side.LEFT)\n            return St.Side.RIGHT;\n        else if (position === St.Side.RIGHT)\n            return St.Side.LEFT;\n    }\n    return position;\n}\n\n/**\n * @param cr\n * @param x\n * @param y\n * @param width\n * @param height\n * @param isRoundLeft\n * @param isRoundRight\n * @param stroke\n * @param fill\n */\nexport function drawRoundedLine(cr, x, y, width, height, isRoundLeft, isRoundRight, stroke, fill) {\n    if (height > width) {\n        y += Math.floor((height - width) / 2.0);\n        height = width;\n    }\n\n    height = 2.0 * Math.floor(height / 2.0);\n\n    const leftRadius = isRoundLeft ? height / 2.0 : 0.0;\n    const rightRadius = isRoundRight ? height / 2.0 : 0.0;\n\n    cr.moveTo(x + width - rightRadius, y);\n    cr.lineTo(x + leftRadius, y);\n    if (isRoundLeft)\n        cr.arcNegative(x + leftRadius, y + leftRadius, leftRadius, -Math.PI / 2, Math.PI / 2);\n    else\n        cr.lineTo(x, y + height);\n    cr.lineTo(x + width - rightRadius, y + height);\n    if (isRoundRight)\n        cr.arcNegative(x + width - rightRadius, y + rightRadius, rightRadius, Math.PI / 2, -Math.PI / 2);\n    else\n        cr.lineTo(x + width, y);\n    cr.closePath();\n\n    if (fill) {\n        cr.setSource(fill);\n        cr.fillPreserve();\n    }\n    if (stroke)\n        cr.setSource(stroke);\n    cr.stroke();\n}\n\n/**\n * Convert a signal handler with n value parameters (that is, excluding the\n * signal source parameter) to an array of n handlers that are each responsible\n * for receiving one of the n values and calling the original handler with the\n * most up-to-date arguments.\n *\n * @param handler\n */\nexport function splitHandler(handler) {\n    if (handler.length > 30)\n        throw new Error('too many parameters');\n\n    const count = handler.length - 1;\n    let missingValueBits = (1 << count) - 1;\n    const values = Array.from({length: count});\n    return values.map((_ignored, i) => {\n        const mask = ~(1 << i);\n        return (obj, value) => {\n            values[i] = value;\n            missingValueBits &= mask;\n            if (missingValueBits === 0)\n                handler(obj, ...values);\n        };\n    });\n}\n\n/**\n * Construct a map of gtk application window object paths to MetaWindows.\n */\nexport function getWindowsByObjectPath() {\n    const windowsByObjectPath = new Map();\n    const {workspaceManager} = global;\n    const workspaces = [...new Array(workspaceManager.nWorkspaces)].map(\n        (_c, i) => workspaceManager.get_workspace_by_index(i));\n\n    workspaces.forEach(ws => {\n        ws.list_windows().forEach(w => {\n            const path = w.get_gtk_window_object_path();\n            if (path)\n                windowsByObjectPath.set(path, w);\n        });\n    });\n\n    return windowsByObjectPath;\n}\n\n/**\n * Re-implements shell_app_compare so that can be used to resort running apps\n *\n * @param appA\n * @param appB\n */\nexport function shellAppCompare(appA, appB) {\n    if (appA.state !== appB.state) {\n        if (appA.state === Shell.AppState.RUNNING)\n            return -1;\n        return 1;\n    }\n\n    const windowsA = appA.get_windows();\n    const windowsB = appB.get_windows();\n\n    const isMinimized = windows => !windows.some(w => w.showing_on_its_workspace());\n    const minimizedB = isMinimized(windowsB);\n    if (isMinimized(windowsA) !== minimizedB) {\n        if (minimizedB)\n            return -1;\n        return 1;\n    }\n\n    if (appA.state === Shell.AppState.RUNNING) {\n        if (windowsA.length && !windowsB.length)\n            return -1;\n        else if (!windowsA.length && windowsB.length)\n            return 1;\n\n        const lastUserTime = windows =>\n            Math.max(...windows.map(w => w.get_user_time()));\n        return lastUserTime(windowsB) - lastUserTime(windowsA);\n    }\n\n    return 0;\n}\n\n/**\n * Re-implements shell_app_compare_windows\n *\n * @param winA\n * @param winB\n */\nexport function shellWindowsCompare(winA, winB) {\n    const activeWorkspace = global.workspaceManager.get_active_workspace();\n    const wsA = winA.get_workspace() === activeWorkspace;\n    const wsB = winB.get_workspace() === activeWorkspace;\n\n    if (wsA && !wsB)\n        return -1;\n    else if (!wsA && wsB)\n        return 1;\n\n    const visA = winA.showing_on_its_workspace();\n    const visB = winB.showing_on_its_workspace();\n\n    if (visA && !visB)\n        return -1;\n    else if (!visA && visB)\n        return 1;\n\n    return winB.get_user_time() - winA.get_user_time();\n}\n\nexport const CancellableChild = GObject.registerClass({\n    Properties: {\n        'parent': GObject.ParamSpec.object(\n            'parent', 'parent', 'parent',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            Gio.Cancellable.$gtype),\n    },\n},\nclass CancellableChild extends Gio.Cancellable {\n    _init(parent) {\n        if (parent && !(parent instanceof Gio.Cancellable))\n            throw TypeError('Not a valid cancellable');\n\n        super._init({parent});\n\n        if (parent?.is_cancelled()) {\n            this.cancel();\n            return;\n        }\n\n        this._connectToParent();\n    }\n\n    _connectToParent() {\n        this._connectId = this.parent?.connect(() => {\n            this._realCancel();\n\n            if (this._disconnectIdle)\n                return;\n\n            this._disconnectIdle = GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {\n                delete this._disconnectIdle;\n                this._disconnectFromParent();\n                return GLib.SOURCE_REMOVE;\n            });\n        });\n    }\n\n    _disconnectFromParent() {\n        if (this._connectId && !this._disconnectIdle) {\n            this.parent.disconnect(this._connectId);\n            delete this._connectId;\n        }\n    }\n\n    _realCancel() {\n        Gio.Cancellable.prototype.cancel.call(this);\n    }\n\n    cancel() {\n        this._disconnectFromParent();\n        this._realCancel();\n    }\n});\n\n/**\n *\n */\nexport function getMonitorManager() {\n    return global.backend.get_monitor_manager?.() ?? Meta.MonitorManager.get();\n}\n\n/**\n * @param laterType\n * @param callback\n */\nexport function laterAdd(laterType, callback) {\n    return global.compositor?.get_laters?.().add(laterType, callback) ??\n        Meta.later_add(laterType, callback);\n}\n\n/**\n * @param id\n */\nexport function laterRemove(id) {\n    if (global.compositor?.get_laters)\n        global.compositor?.get_laters().remove(id);\n    else\n        Meta.later_remove(id);\n}\n\n/**\n * Up to Gnome Shell 45, the Cairo Context object didn't export the\n * `setSourceColor()` method, so Clutter included a function call for\n * that, written in C. In Gnome Shell 46, the method was finally exported,\n * so that function was removed.\n *\n * This function is, thus, required for Gnome Shell 45 compatibility.\n *\n * @param {*} cr A cairo context\n * @param {*} sourceColor The new color for source\n */\nexport function cairoSetSourceColor(cr, sourceColor) {\n    if (Clutter.cairo_set_source_color)\n        Clutter.cairo_set_source_color(cr, sourceColor);\n    else\n        cr.setSourceColor(sourceColor);\n}\n\n/**\n * Specifies if the system supports extended barriers. This function\n * is required for Gnome Shell 45 compatibility, which used\n * `global.display.supports_extended_barriers`. Gnome Shell 46 moved\n * that into global.backend.capabilities.\n *\n * @returns True if the system supports extended barriers.\n */\nexport function supportsExtendedBarriers() {\n    if (global.display.supports_extended_barriers)\n        return global.display.supports_extended_barriers();\n    return !!(global.backend.capabilities & Meta.BackendCapabilities.BARRIERS);\n}\n\nexport function addActor(element, actor) {\n    if (element.add_actor)\n        element.add_actor(actor);\n    else\n        element.add_child(actor);\n}\n\nexport const clamp = (v, m, M) => Math.min(Math.max(v, m), M);\nexport const clampDouble = v => clamp(v, 0, 1);\n"
        },
        {
          "name": "windowPreview.js",
          "type": "blob",
          "size": 21.986328125,
          "content": "/*\n * Credits:\n * This file is based on code from the Dash to Panel extension by Jason DeRose\n * and code from the Taskbar extension by Zorin OS\n * Some code was also adapted from the upstream Gnome Shell source code.\n */\n\nimport {\n    Clutter,\n    GLib,\n    GObject,\n    Meta,\n    St,\n} from './dependencies/gi.js';\n\nimport {\n    BoxPointer,\n    Main,\n    PopupMenu,\n    Workspace,\n} from './dependencies/shell/ui.js';\n\nimport {\n    Docking,\n    Theming,\n    Utils,\n} from './imports.js';\n\nconst PREVIEW_MAX_WIDTH = 250;\nconst PREVIEW_MAX_HEIGHT = 150;\n\nconst PREVIEW_ANIMATION_DURATION = 250;\nconst MAX_PREVIEW_GENERATION_ATTEMPTS = 15;\n\nconst MENU_MARGINS = 10;\n\nexport class WindowPreviewMenu extends PopupMenu.PopupMenu {\n    constructor(source) {\n        super(source, 0.5, Utils.getPosition());\n\n        // We want to keep the item hovered while the menu is up\n        this.blockSourceEvents = true;\n\n        this._source = source;\n        this._app = this._source.app;\n        const workArea = Main.layoutManager.getWorkAreaForMonitor(\n            this._source.monitorIndex);\n        const {scaleFactor} = St.ThemeContext.get_for_stage(global.stage);\n\n        this.actor.add_style_class_name('app-menu');\n        this.actor.set_style(\n            `max-width: ${Math.round(workArea.width / scaleFactor) - MENU_MARGINS}px; ` +\n            `max-height: ${Math.round(workArea.height / scaleFactor) - MENU_MARGINS}px;`);\n        this.actor.hide();\n\n        // Chain our visibility and lifecycle to that of the source\n        this._mappedId = this._source.connect('notify::mapped', () => {\n            if (!this._source.mapped)\n                this.close();\n        });\n        this._destroyId = this._source.connect('destroy', this.destroy.bind(this));\n\n        Utils.addActor(Main.uiGroup, this.actor);\n\n        this.connect('destroy', this._onDestroy.bind(this));\n    }\n\n    _redisplay() {\n        if (this._previewBox)\n            this._previewBox.destroy();\n        this._previewBox = new WindowPreviewList(this._source);\n        this.addMenuItem(this._previewBox);\n        this._previewBox._redisplay();\n    }\n\n    popup() {\n        const windows = this._source.getInterestingWindows();\n        if (windows.length > 0) {\n            this._redisplay();\n            this.open(BoxPointer.PopupAnimation.FULL);\n            this.actor.navigate_focus(null, St.DirectionType.TAB_FORWARD, false);\n            this._source.emit('sync-tooltip');\n        }\n    }\n\n    _onDestroy() {\n        if (this._mappedId)\n            this._source.disconnect(this._mappedId);\n\n        if (this._destroyId)\n            this._source.disconnect(this._destroyId);\n    }\n}\n\nclass WindowPreviewList extends PopupMenu.PopupMenuSection {\n    constructor(source) {\n        super();\n        this.actor = new St.ScrollView({\n            name: 'dashtodockWindowScrollview',\n            hscrollbar_policy: St.PolicyType.NEVER,\n            vscrollbar_policy: St.PolicyType.NEVER,\n            overlay_scrollbars: true,\n            enable_mouse_scrolling: true,\n        });\n\n        this.actor.connect('scroll-event', this._onScrollEvent.bind(this));\n\n        const position = Utils.getPosition();\n        this.isHorizontal = position === St.Side.BOTTOM || position === St.Side.TOP;\n        this.box.set_vertical(!this.isHorizontal);\n        this.box.set_name('dashtodockWindowList');\n        Utils.addActor(this.actor, this.box);\n        this.actor._delegate = this;\n\n        this._shownInitially = false;\n\n        this._source = source;\n        this.app = source.app;\n\n        this._redisplayId = Main.initializeDeferredWork(this.actor, this._redisplay.bind(this));\n\n        this.actor.connect('destroy', this._onDestroy.bind(this));\n        this._stateChangedId = this.app.connect('windows-changed',\n            this._queueRedisplay.bind(this));\n    }\n\n    _queueRedisplay() {\n        Main.queueDeferredWork(this._redisplayId);\n    }\n\n    _onScrollEvent(actor, event) {\n        // Event coordinates are relative to the stage but can be transformed\n        // as the actor will only receive events within his bounds.\n        const [stageX, stageY] = event.get_coords();\n        const [,, eventY] = actor.transform_stage_point(stageX, stageY);\n        const [, actorH] = actor.get_size();\n\n        // If the scroll event is within a 1px margin from\n        // the relevant edge of the actor, let the event propagate.\n        if (eventY >= actorH - 2)\n            return Clutter.EVENT_PROPAGATE;\n\n        // Skip to avoid double events mouse\n        if (event.is_pointer_emulated())\n            return Clutter.EVENT_STOP;\n\n        let adjustment, delta;\n\n        if (this.isHorizontal)\n            adjustment = this.actor.get_hscroll_bar().get_adjustment();\n        else\n            adjustment = this.actor.get_vscroll_bar().get_adjustment();\n\n        const increment = adjustment.step_increment;\n\n        switch (event.get_scroll_direction()) {\n        case Clutter.ScrollDirection.UP:\n            delta = -increment;\n            break;\n        case Clutter.ScrollDirection.DOWN:\n            delta = Number(increment);\n            break;\n        case Clutter.ScrollDirection.SMOOTH: {\n            const [dx, dy] = event.get_scroll_delta();\n            delta = dy * increment;\n            delta += dx * increment;\n            break;\n        }\n        }\n\n        adjustment.set_value(adjustment.get_value() + delta);\n\n        return Clutter.EVENT_STOP;\n    }\n\n    _onDestroy() {\n        this.app.disconnect(this._stateChangedId);\n        this._stateChangedId = 0;\n    }\n\n    _createPreviewItem(window) {\n        const preview = new WindowPreviewMenuItem(window, Utils.getPosition());\n        return preview;\n    }\n\n    _redisplay() {\n        const children = this._getMenuItems().filter(actor => {\n            return actor._window;\n        });\n\n        // Windows currently on the menu\n        const oldWin = children.map(actor => {\n            return actor._window;\n        });\n\n        // All app windows with a static order\n        const newWin = this._source.getInterestingWindows().sort((a, b) =>\n            a.get_stable_sequence() > b.get_stable_sequence());\n\n        const addedItems = [];\n        const removedActors = [];\n\n        let newIndex = 0;\n        let oldIndex = 0;\n\n        while (newIndex < newWin.length || oldIndex < oldWin.length) {\n            const currentOldWin = oldWin[oldIndex];\n            const currentNewWin = newWin[newIndex];\n\n            // No change at oldIndex/newIndex\n            if (currentOldWin === currentNewWin) {\n                oldIndex++;\n                newIndex++;\n                continue;\n            }\n\n            // Window removed at oldIndex\n            if (currentOldWin && !newWin.includes(currentOldWin)) {\n                removedActors.push(children[oldIndex]);\n                oldIndex++;\n                continue;\n            }\n\n            // Window added at newIndex\n            if (currentNewWin && !oldWin.includes(currentNewWin)) {\n                addedItems.push({\n                    item: this._createPreviewItem(currentNewWin),\n                    pos: newIndex,\n                });\n                newIndex++;\n                continue;\n            }\n\n            // Window moved\n            const insertHere = newWin[newIndex + 1] &&\n                             newWin[newIndex + 1] === currentOldWin;\n            const alreadyRemoved = removedActors.reduce((result, actor) =>\n                result || actor._window === currentNewWin, false);\n\n            if (insertHere || alreadyRemoved) {\n                addedItems.push({\n                    item: this._createPreviewItem(currentNewWin),\n                    pos: newIndex + removedActors.length,\n                });\n                newIndex++;\n            } else {\n                removedActors.push(children[oldIndex]);\n                oldIndex++;\n            }\n        }\n\n        for (let i = 0; i < addedItems.length; i++) {\n            this.addMenuItem(addedItems[i].item,\n                addedItems[i].pos);\n        }\n\n        for (let i = 0; i < removedActors.length; i++) {\n            const item = removedActors[i];\n            if (this._shownInitially)\n                item._animateOutAndDestroy();\n            else\n                item.actor.destroy();\n        }\n\n        // Skip animations on first run when adding the initial set\n        // of items, to avoid all items zooming in at once\n        const animate = this._shownInitially;\n\n        if (!this._shownInitially)\n            this._shownInitially = true;\n\n        for (let i = 0; i < addedItems.length; i++)\n            addedItems[i].item.show(animate);\n\n        // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=692744\n        // Without it, StBoxLayout may use a stale size cache\n        this.box.queue_relayout();\n\n        if (newWin.length < 1)\n            this._getTopMenu().close(~0);\n\n        // As for upstream:\n        // St.ScrollView always requests space horizontally for a possible vertical\n        // scrollbar if in AUTOMATIC mode. Doing better would require implementation\n        // of width-for-height in St.BoxLayout and St.ScrollView. This looks bad\n        // when we *don't* need it, so turn off the scrollbar when that's true.\n        // Dynamic changes in whether we need it aren't handled properly.\n        const needsScrollbar = this._needsScrollbar();\n        const scrollbarPolicy = needsScrollbar\n            ? St.PolicyType.AUTOMATIC : St.PolicyType.NEVER;\n        if (this.isHorizontal)\n            this.actor.hscrollbarPolicy = scrollbarPolicy;\n        else\n            this.actor.vscrollbarPolicy = scrollbarPolicy;\n\n        if (needsScrollbar)\n            this.actor.add_style_pseudo_class('scrolled');\n        else\n            this.actor.remove_style_pseudo_class('scrolled');\n    }\n\n    _needsScrollbar() {\n        const topMenu = this._getTopMenu();\n        const topThemeNode = topMenu.actor.get_theme_node();\n        if (this.isHorizontal) {\n            const [topMinWidth_, topNaturalWidth] =\n                topMenu.actor.get_preferred_width(-1);\n            const topMaxWidth = topThemeNode.get_max_width();\n            return topMaxWidth >= 0 && topNaturalWidth >= topMaxWidth;\n        } else {\n            const [topMinHeight_, topNaturalHeight] =\n                topMenu.actor.get_preferred_height(-1);\n            const topMaxHeight = topThemeNode.get_max_height();\n            return topMaxHeight >= 0 && topNaturalHeight >= topMaxHeight;\n        }\n    }\n\n    isAnimatingOut() {\n        return this.actor.get_children().reduce((result, actor) => {\n            return result || actor.animatingOut;\n        }, false);\n    }\n}\n\nexport const WindowPreviewMenuItem = GObject.registerClass(\nclass WindowPreviewMenuItem extends PopupMenu.PopupBaseMenuItem {\n    _init(window, position, params) {\n        super._init(params);\n\n        this._window = window;\n        this._destroyId = 0;\n        this._windowAddedId = 0;\n\n        // We don't want this: it adds spacing on the left of the item.\n        this.remove_child(this._ornamentIcon);\n        this.add_style_class_name('dashtodock-app-well-preview-menu-item');\n        this.add_style_class_name(Theming.PositionStyleClass[position]);\n        if (Docking.DockManager.settings.customThemeShrink)\n            this.add_style_class_name('shrink');\n\n        // Now we don't have to set PREVIEW_MAX_WIDTH and PREVIEW_MAX_HEIGHT as\n        // preview size - that made all kinds of windows either stretched or\n        // squished (aspect ratio problem)\n        this._cloneBin = new St.Bin();\n\n        this._updateWindowPreviewSize();\n\n        // TODO: improve the way the closebutton is layout. Just use some padding\n        // for the moment.\n        this._cloneBin.set_style('padding-bottom: 0.5em');\n\n        const buttonLayout = Meta.prefs_get_button_layout();\n        this.closeButton = new St.Button({\n            style_class: 'window-close',\n            opacity: 0,\n            x_expand: true,\n            y_expand: true,\n            x_align: buttonLayout.left_buttons.includes(Meta.ButtonFunction.CLOSE)\n                ? Clutter.ActorAlign.START : Clutter.ActorAlign.END,\n            y_align: Clutter.ActorAlign.START,\n        });\n        Utils.addActor(this.closeButton, new St.Icon({icon_name: 'window-close-symbolic'}));\n        this.closeButton.connect('clicked', () => this._closeWindow());\n\n        const overlayGroup = new Clutter.Actor({\n            layout_manager: new Clutter.BinLayout(),\n            y_expand: true,\n        });\n\n        overlayGroup.add_child(this._cloneBin);\n        overlayGroup.add_child(this.closeButton);\n\n        const label = new St.Label({text: window.get_title()});\n        label.set_style(`max-width: ${PREVIEW_MAX_WIDTH}px`);\n        const labelBin = new St.Bin({\n            child: label,\n            x_align: Clutter.ActorAlign.CENTER,\n        });\n\n        this._windowTitleId = this._window.connect('notify::title', () => {\n            label.set_text(this._window.get_title());\n        });\n\n        const box = new St.BoxLayout({\n            vertical: true,\n            reactive: true,\n            x_expand: true,\n        });\n\n        if (box.add) {\n            box.add(overlayGroup);\n            box.add(labelBin);\n        } else {\n            box.add_child(overlayGroup);\n            box.add_child(labelBin);\n        }\n        this._box = box;\n        this.add_child(box);\n\n        this._cloneTexture(window);\n\n        this.connect('destroy', this._onDestroy.bind(this));\n    }\n\n    vfunc_style_changed() {\n        super.vfunc_style_changed();\n\n        // For some crazy clutter / St reason we can't just have this handled\n        // automatically or here via vfunc_allocate + vfunc_get_preferred_*\n        // because if we do so, the St paddings on first / last child are lost\n        const themeNode = this.get_theme_node();\n        let [minWidth, naturalWidth] = this._box.get_preferred_width(-1);\n        let [minHeight, naturalHeight] = this._box.get_preferred_height(naturalWidth);\n        [minWidth, naturalWidth] = themeNode.adjust_preferred_width(minWidth, naturalWidth);\n        [minHeight, naturalHeight] = themeNode.adjust_preferred_height(minHeight, naturalHeight);\n        this.set({minWidth, naturalWidth, minHeight, naturalHeight});\n    }\n\n    _getWindowPreviewSize() {\n        const emptySize = [0, 0, 0];\n\n        const mutterWindow = this._window.get_compositor_private();\n        if (!mutterWindow?.get_texture())\n            return emptySize;\n\n        const [width, height] = mutterWindow.get_size();\n        if (!width || !height)\n            return emptySize;\n\n        let {previewSizeScale: scale} = Docking.DockManager.settings;\n        if (!scale) {\n            // a simple example with 1680x1050:\n            // * 250/1680 = 0,1488\n            // * 150/1050 = 0,1429\n            // => scale is 0,1429\n            scale = Math.min(1.0, PREVIEW_MAX_WIDTH / width, PREVIEW_MAX_HEIGHT / height);\n        }\n\n        scale *= St.ThemeContext.get_for_stage(global.stage).scaleFactor;\n\n        // width and height that we wanna multiply by scale\n        return [width, height, scale];\n    }\n\n    _updateWindowPreviewSize() {\n        // This gets the actual windows size for the preview\n        [this._width, this._height, this._scale] = this._getWindowPreviewSize();\n        this._cloneBin.set_size(this._width * this._scale, this._height * this._scale);\n    }\n\n    _cloneTexture(metaWin) {\n        // Newly-created windows are added to a workspace before\n        // the compositor finds out about them...\n        if (!this._width || !this._height) {\n            this._cloneTextureLater = Utils.laterAdd(Meta.LaterType.BEFORE_REDRAW, () => {\n                // Check if there's still a point in getting the texture,\n                // otherwise this could go on indefinitely\n                this._updateWindowPreviewSize();\n\n                if (this._width && this._height) {\n                    this._cloneTexture(metaWin);\n                } else {\n                    this._cloneAttempt = (this._cloneAttempt || 0) + 1;\n                    if (this._cloneAttempt < MAX_PREVIEW_GENERATION_ATTEMPTS)\n                        return GLib.SOURCE_CONTINUE;\n                }\n                delete this._cloneTextureLater;\n                return GLib.SOURCE_REMOVE;\n            });\n            return;\n        }\n\n        const mutterWindow = metaWin.get_compositor_private();\n        const clone = new Clutter.Clone({\n            source: mutterWindow,\n            reactive: true,\n            width: this._width * this._scale,\n            height: this._height * this._scale,\n        });\n\n        // when the source actor is destroyed, i.e. the window closed, first destroy the clone\n        // and then destroy the menu item (do this animating out)\n        this._destroyId = mutterWindow.connect('destroy', () => {\n            clone.destroy();\n            this._destroyId = 0; // avoid to try to disconnect this signal from mutterWindow in _onDestroy(),\n            // as the object was just destroyed\n            this._animateOutAndDestroy();\n        });\n\n        this._clone = clone;\n        this._mutterWindow = mutterWindow;\n        this._cloneBin.set_child(this._clone);\n\n        this._clone.connect('destroy', () => {\n            if (this._destroyId) {\n                mutterWindow.disconnect(this._destroyId);\n                this._destroyId = 0;\n            }\n            this._clone = null;\n        });\n    }\n\n    _windowCanClose() {\n        return this._window.can_close() &&\n               !this._hasAttachedDialogs();\n    }\n\n    _closeWindow() {\n        this._workspace = this._window.get_workspace();\n\n        // This mechanism is copied from the workspace.js upstream code\n        // It forces window activation if the windows don't get closed,\n        // for instance because asking user confirmation, by monitoring the opening of\n        // such additional confirmation window\n        this._windowAddedId = this._workspace.connect('window-added',\n            this._onWindowAdded.bind(this));\n\n        this.deleteAllWindows();\n    }\n\n    deleteAllWindows() {\n        // Delete all windows, starting from the bottom-most (most-modal) one\n        // let windows = this._window.get_compositor_private().get_children();\n        const windows = this._clone.get_children();\n        for (let i = windows.length - 1; i >= 1; i--) {\n            const realWindow = windows[i].source;\n            const metaWindow = realWindow.meta_window;\n\n            metaWindow.delete(global.get_current_time());\n        }\n\n        this._window.delete(global.get_current_time());\n    }\n\n    _onWindowAdded(workspace, win) {\n        const metaWindow = this._window;\n\n        if (win.get_transient_for() === metaWindow) {\n            workspace.disconnect(this._windowAddedId);\n            this._windowAddedId = 0;\n\n            // use an idle handler to avoid mapping problems -\n            // see comment in Workspace._windowAdded\n            const activationEvent = Clutter.get_current_event();\n            this._windowAddedLater = Utils.laterAdd(Meta.LaterType.BEFORE_REDRAW, () => {\n                delete this._windowAddedLater;\n                this.emit('activate', activationEvent);\n                return GLib.SOURCE_REMOVE;\n            });\n        }\n    }\n\n    _hasAttachedDialogs() {\n        // count trasient windows\n        let n = 0;\n        this._window.foreach_transient(() => {\n            n++;\n        });\n        return n > 0;\n    }\n\n    vfunc_key_focus_in() {\n        super.vfunc_key_focus_in();\n        this._showCloseButton();\n    }\n\n    vfunc_key_focus_out() {\n        super.vfunc_key_focus_out();\n        this._hideCloseButton();\n    }\n\n    vfunc_enter_event(crossingEvent) {\n        this._showCloseButton();\n        return super.vfunc_enter_event(crossingEvent);\n    }\n\n    vfunc_leave_event(crossingEvent) {\n        this._hideCloseButton();\n        return super.vfunc_leave_event(crossingEvent);\n    }\n\n    _idleToggleCloseButton() {\n        this._idleToggleCloseId = 0;\n\n        this._hideCloseButton();\n\n        return GLib.SOURCE_REMOVE;\n    }\n\n    _showCloseButton() {\n        if (this._windowCanClose()) {\n            this.closeButton.show();\n            this.closeButton.remove_all_transitions();\n            this.closeButton.ease({\n                opacity: 255,\n                duration: Workspace.WINDOW_OVERLAY_FADE_TIME,\n                mode: Clutter.AnimationMode.EASE_OUT_QUAD,\n            });\n        }\n    }\n\n    _hideCloseButton() {\n        if (this.closeButton.has_pointer ||\n            this.get_children().some(a => a.has_pointer))\n            return;\n\n        this.closeButton.remove_all_transitions();\n        this.closeButton.ease({\n            opacity: 0,\n            duration: Workspace.WINDOW_OVERLAY_FADE_TIME,\n            mode: Clutter.AnimationMode.EASE_IN_QUAD,\n        });\n    }\n\n    show(animate) {\n        const fullWidth = this.get_width();\n\n        this.opacity = 0;\n        this.set_width(0);\n\n        const time = animate ? PREVIEW_ANIMATION_DURATION : 0;\n        this.remove_all_transitions();\n        this.ease({\n            opacity: 255,\n            width: fullWidth,\n            duration: time,\n            mode: Clutter.AnimationMode.EASE_IN_OUT_QUAD,\n        });\n    }\n\n    _animateOutAndDestroy() {\n        this.remove_all_transitions();\n        this.ease({\n            opacity: 0,\n            duration: PREVIEW_ANIMATION_DURATION,\n        });\n\n        this.ease({\n            width: 0,\n            height: 0,\n            duration: PREVIEW_ANIMATION_DURATION,\n            delay: PREVIEW_ANIMATION_DURATION,\n            onComplete: () => this.destroy(),\n        });\n    }\n\n    activate() {\n        Main.activateWindow(this._window);\n        this._getTopMenu().close();\n    }\n\n    _onDestroy() {\n        if (this._cloneTextureLater) {\n            Utils.laterRemove(this._cloneTextureLater);\n            delete this._cloneTextureLater;\n        }\n\n        if (this._windowAddedLater) {\n            Utils.laterRemove(this._windowAddedLater);\n            delete this._windowAddedLater;\n        }\n\n        if (this._windowAddedId > 0) {\n            this._workspace.disconnect(this._windowAddedId);\n            this._windowAddedId = 0;\n        }\n\n        if (this._destroyId > 0) {\n            this._mutterWindow.disconnect(this._destroyId);\n            this._destroyId = 0;\n        }\n\n        if (this._windowTitleId > 0) {\n            this._window.disconnect(this._windowTitleId);\n            this._windowTitleId = 0;\n        }\n    }\n});\n"
        }
      ]
    }
  ]
}