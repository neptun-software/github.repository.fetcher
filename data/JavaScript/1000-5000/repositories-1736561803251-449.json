{
  "metadata": {
    "timestamp": 1736561803251,
    "page": 449,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "brianchirls/Seriously.js",
      "stars": 3878,
      "defaultBranch": "master",
      "files": [
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.0126953125,
          "content": "Brian Chirls\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.5830078125,
          "content": "# Contributing to Seriously.js #\n\nContributions are welcome, whether new core features, effects, bug fixes or examples. Please follow these guidelines.\n\n## Workflow ##\n* All contributions should be based off the latest `develop` branch, and pull requests must be submitted to `develop`. Any pull requests to `master` will be rejected.\n* Create a separate branch for each patch or feature\n* Any modifications to the core script must pass unit tests. Whenever possible, especially for new features, please add a test.\n* New features or effects should have an example.\n* Any copied assets (e.g. images, shaders or code) should have the appropriate license and credit allowing for their use in this repository.\n* When refactoring existing code, make sure all relevant examples still work or are updated to work.\n* If a patch is relevant to a [GitHub issue](https://github.com/brianchirls/Seriously.js/issues?state=open), please reference the issue number with a hash in the commit message.\n* All Javascript code should follow the style guide below\n\n## Code Style ##\n* Indent with tabs, not spaces\n* No trailing spaces\n* Single quotes for strings\n* Spaces around binary operators (e.g. `a + b`, not `a+b`), but not unary ones\n* `if`, `while`, `try`, etc. must all have braces and span multiple lines.\n* All local variables should be declared in one `var` statement at the top of each function\n* functions should be declared after `var` but before any other statements.\n* Lots of comments please, but put them on the line before the code, not at the end of the line.\n* When in doubt, refer to existing code.\n\n## Best Practices ##\n* Prioritize speed for code that runs in render loops, but prioritize readability, simplicity and usability for everything else.\n* Publicly accessible methods should be simple to use and forgiving of mistakes whenever possible. Assume they're being used by inexperienced programmers.\n* Observe [WebGL best practices](https://developer.mozilla.org/en-US/docs/Web/WebGL/WebGL_best_practices)\n* Private or protected code may assume more advanced users, to prioritize speed and power.\n* Minimize impact on the global environment. No unnecessary global variables, and shim when necessary but don't polyfill.\n* All plugins must support either AMD or global declarations (see [UMD](https://github.com/umdjs/umd/blob/master/returnExportsGlobal.js)). Examples may use AMD, but it's not required.\n* Check all Javascript code with jshint or jslint, but use your brain. The following options are recommended:\n`    devel: true, bitwise: true, browser: true, white: true, nomen: true, plusplus: true, maxerr: 50, indent: 4, todo: true`"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0361328125,
          "content": "Copyright (c) 2012-2014 Brian Chirls\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.76953125,
          "content": "# Seriously.js\n\nSeriously.js is a real-time, node-based video compositor for the web.\nInspired by professional software such as After Effects and Nuke,\nSeriously.js renders high-quality video effects, but allows them to be\ndynamic and interactive.\n\n## Getting Started\n\nFull documentation is in progress at the [wiki](https://github.com/brianchirls/Seriously.js/wiki). Start with the\n[Tutorial](https://github.com/brianchirls/Seriously.js/wiki/Tutorial) and\n[FAQ](https://github.com/brianchirls/Seriously.js/wiki/Frequently-Asked-Questions).\n\n## Features\n\n- Optimized rendering path and GPU accelerated up to 60 frames per second\n- Accept image input from varied sources: video, image, canvas, array, webcam, Three.js\n- Effect parameters accept multiple formats and can monitor HTML form inputs\n- Basic 2D transforms (translate, rotate, scale, skew) on effect nodes\n- Plugin architecture for adding new effects, sources and targets\n- Read pixel array from any node\n- Load with [AMD](http://requirejs.org/docs/whyamd.html#amd)/[RequireJS](http://www.requirejs.org/)\n\n### Included Effects\n- Accumulator\n- Ascii Text\n- Bleach Bypass\n- Blend\n- Brightness/Contrast\n- Channel Mapping\n- Checkerboard Generator\n- Chroma Key\n- Color Complements\n- [Color Cube](http://www.youtube.com/watch?v=rfQ8rKGTVlg&t=24m30s)\n- Color Generator\n- Color Look-Up Table\n- Color Select\n- Color Temperature\n- Crop\n- [Daltonize](http://www.daltonize.org/p/about.html)\n- Directional Blur\n- Displacement Map\n- Dither\n- Edge Detect\n- Emboss\n- Exposure Adjust\n- Expressions\n- Fader\n- False Color\n- Fast Approximate Anti-Aliasing\n- Film Grain\n- Freeze Frame\n- Gaussian Blur\n- Hex Tiles\n- Highlights/Shadows\n- Hue/Saturation Adjust\n- Invert\n- Kaleidoscope\n- Layers\n- Linear Transfer\n- Luma Key\n- Mirror\n- Night Vision\n- Optical Flow\n- Panorama\n- Pixelate\n- Polar Coordinates\n- Ripple\n- Scanlines\n- Sepia tone\n- Simplex Noise\n- Sketch\n- Split\n- Throttle Frame Rate\n- Tone Adjust\n- TV Glitch\n- Vibrance\n- Vignette\n- White Balance\n\n### Requirements\n\n#### WebGL\n\nSeriously.js requires a browser that supports [WebGL](http://en.wikipedia.org/wiki/Webgl). \nDevelopment is targeted to and tested in Firefox (4.0+), Google Chrome (9+), Internet Explorer (11+) and Opera (18+). Safari is [expected to support WebGL](http://caniuse.com/#search=webgl)\nin the near future.\n\nEven though a browser may support WebGL, the ability to run it depends\non the system's graphics card. Seriously.js is heavily optimized, so most\nmodern desktops and notebooks should be sufficient. Older systems may\nrun slower, especially when using high-resolution videos.\n\nMobile browser support for WebGL has improved. Mobile Firefox, Chrome and Safari have decent\nsupport, but they can be slower than desktop versions due to limited system resources.\n\nSeriously.js provides a method to detect browser support and offer\ndescriptive error messages wherever possible.\n\n#### Cross-Origin Videos and Images\n\nDue to security limitations of WebGL, Seriously.js can only process video\nor images that are served from the same domain, unless they are served\nwith [CORS headers](http://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/).\nFirefox, Chrome and Opera support CORS for video, but Safari and Internet Explorer do not, and videos served with CORS are rare. So for now, it is best to host your own video files.\n\n## Contributing\n\nBug fixes, new features, effects and examples are welcome and appreciated. Please follow the [Contributing Guidelines](https://github.com/brianchirls/Seriously.js/wiki/Contributing).\n\n## License\nSeriously.js is made available under the [MIT License](http://www.opensource.org/licenses/mit-license.php).\n\nIndividual plugins may be licensed differently. Check source code comments.\n\n## Credits\n\nSeriously.js is created and maintained by [Brian Chirls](http://chirls.com)"
        },
        {
          "name": "effects",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.html",
          "type": "blob",
          "size": 16.265625,
          "content": "<!DOCTYPE html>\n<html lang=\"en-US\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>Seriously.js</title>\n\t\t<!--<script type=\"text/javascript\" src=\"lib/webgl-debug.js\"></script> -->\n\t\t<script type=\"text/javascript\" src=\"seriously.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"transforms/seriously.transform3d.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.accumulator.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.ascii.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.bleach-bypass.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.blend.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.brightness-contrast.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.checkerboard.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.chroma.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.color.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.colorcomplements.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.color-select.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.temperature.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.daltonize.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.dither.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.edge.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.emboss.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.exposure.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.falsecolor.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.freeze.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.highlights-shadows.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.kaleidoscope.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.lumakey.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.fader.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.filmgrain.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.blur.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.hue-saturation.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.hex.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.invert.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.directionblur.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.nightvision.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.noise.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.opticalflow.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.pixelate.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.polar.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.ripple.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.scanlines.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.sepia.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.sketch.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.throttle.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.tone.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.tvglitch.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.vibrance.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.vignette.js\"></script>\n\t\t<script type=\"text/javascript\" src=\"effects/seriously.split.js\"></script>\n\t\t<style>\n\n\t\tbody {\n\t\t\tbackground-color: #aaa;\n\t\t}\n\n\t\timg, video {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\tcanvas {\n\t\t\tborder: black solid 1px;\n\t\t}\n\n\t\t#transforms input[type=range] {\n\t\t\twidth: 360px;\n\t\t}\n\n\t\t@media screen and (min-width: 740px) {\n\t\t\t#transforms input[type=range] {\n\t\t\t\twidth: 720px;\n\t\t\t}\n\t\t}\n\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<button id=\"colorbutton\">Color Bars</button>\n\t\t<button id=\"camera\">Camera</button>\n\t\t<img id=\"colorbars\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANwAAAClCAYAAAA3d5OIAAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH2gIPFxcpA4p/0AAAA2BJREFUeJzt2r9qVHkcxuHvmRyHhCASRcRStErnwnYWWdgljaX1doqCld5CRNhLELtd8AJs1sq5AmFTuMUqoiABXSZIxEgyzngDyWbI4vsrfJ72/HnPwHw4U0w3Go1m1cjz59drdfWfJtt/j8/XrdOPmmxXVfUvrtXk0r9Ntq/8caU2Hm402a6qGg9+qdPT/Sbb909cqyf7t5tsV1UNmi3Dd0hwECQ4CBIcBAkOggQHQYKDIMFBkOAgSHAQJDgIEhwECQ6CBAdBgoMgwUGQ4CBIcBAkOAgSHAQJDoIEB0GCgyDBQZDgIEhwECQ4CBIcBAkOggQHQYKDIMFBkOAgSHAQJDgIEhwECQ6CBAdBgoMgwUGQ4CBIcBAkOAgSHAQJDoIEB0GCgyDBQZDgIEhwECQ4CBIcBAkOggQHQYKDIMFBkOAgSHAQJDgIEhwECQ6CBAdBgoMgwUGQ4CBIcBAkOAgSHAQJDoIEB0GCgyDBQZDgIEhwECQ4CBIcBAkOggQHQYKDIMFBkOAgSHAQJDgIEhwECQ6CBAdBgoMgwUGQ4CBIcBAkOAgSHAQJDoIEB0GCgyDBQZDgIEhwECQ4CBIcBAkOggQHQYKDIMFBkOAgSHAQJDgIEhwECQ6C+rW1duPLyz/W4uK4yfbZ6akabTeZrqqqeycv17Phsybbf/2wVGujJtNVVbVy82IN3r9vsr2+PqzRjSbTVeUNB1GCgyDBQZDgIEhwECQ4CBIcBAkOggQHQYKDIMFBkOAgqO9PPm02PhuOa78/dejxy6sX6szK4cf/j+Xpcm1/Pv6/l7dejevNy3fHvv7DtGpx/9yxr/9P3bQ+94f/OXiws1MnNje/zfYcph8/1uzLlyPP67quBoP53gkLCwtznbe1tVWbDT97VxeuzpqtH+HPB3dq/eefWj/Gge7++luNfn/d+jEONBl8qrcrj1s/xqF2d3drNjv6a9f3fQ2Hw7nuubS0VF3XHXneZDKpvb29ue75LfhJCUGCgyDBQZDgIEhwECQ4CBIcBAkOggQHQYKDIMFBkOAgSHAQJDgIEhwECQ6CBAdBgoMgwUGQ4CBIcBAkOAgSHAQJDoIEB0GCgyDBQZDgIEhwECQ4CBIcBAkOggQHQYKDIMFBkOAgSHAQJDgIEhwECQ6CvgJd+V3gFFLyFgAAAABJRU5ErkJggg==\"/>\n\t\t<img id=\"img\"/>\n\t\t<video id=\"video\"></video>\n\t\t<select id=\"effects\">\n\t\t\t<option value=\"\">None</option>\n\t\t</select><br/>\n\t\t<div id=\"options\"></div>\n\t\t<canvas id=\"canvas\" width=\"960\" height=\"540\"></canvas>\n\t\t<table id=\"transforms\">\n\t\t\t<tr><td><label for=\"rotate-x\">Rotate X</label></td><td><input type=\"range\" id=\"rotate-x\" min=\"0\" max=\"360\" step=\"1\" value=\"0\"/></td></tr>\n\t\t\t<tr><td><label for=\"rotate-y\">Rotate Y</label></td><td><input type=\"range\" id=\"rotate-y\" min=\"0\" max=\"360\" step=\"1\" value=\"0\"/></td></tr>\n\t\t\t<tr><td><label for=\"rotate-z\">Rotate Z</label></td><td><input type=\"range\" id=\"rotate-z\" min=\"0\" max=\"360\" step=\"1\" value=\"0\"/></td></tr>\n\t\t\t<tr><td><label for=\"translate-z\">Translate Z</label></td><td><input type=\"range\" id=\"translate-z\" min=\"-40\" max=\"90\" step=\"1\" value=\"0\"/></td></tr>\n\t\t\t<tr><td><label for=\"perspective\">Perspective</label></td><td><input type=\"range\" id=\"perspective\" min=\"0\" max=\"90\" step=\"1\" value=\"0\"/></td></tr>\n\t\t</table>\n\t<script type=\"text/javascript\">\n\n\t(function () {\n\tvar e, i,\n\t\tinput,\n\t\tgUM,\n\t\tsources,\n\t\teffect,\n\t\telement,\n\t\ttarget,\n\t\ttimeNodes = [],\n\t\teffects = Seriously.effects(),\n\t\teffectObjects = {},\n\t\trequestAnimFrame = (function(){\n\t\t\tvar lastTime = 0;\n\t\t\treturn  window.requestAnimationFrame       ||\n\t\t\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\t\t\twindow.mozRequestAnimationFrame    ||\n\t\t\t\t\twindow.oRequestAnimationFrame      ||\n\t\t\t\t\twindow.msRequestAnimationFrame     ||\n\t\t\t\t\tfunction (callback) {\n\t\t\t\t\t\tvar currTime, timeToCall, id;\n\n\t\t\t\t\t\tfunction timeoutCallback() {\n\t\t\t\t\t\t\tcallback(currTime + timeToCall);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrTime = new Date().getTime();\n\t\t\t\t\t\ttimeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\t\t\t\t\tid = window.setTimeout(timeoutCallback, timeToCall);\n\t\t\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\t\t\treturn id;\n\t\t\t\t\t};\n\t\t}());\n\n\t\t//for now, only effects that process a single image\n\t\tfor (e in effects) {\n\t\t\teffect = effects[e];\n\t\t\tsources = 0;\n\n\t\t\tfor (i in effect.inputs) {\n\t\t\t\tif (effect.inputs[i].type === 'image') {\n\t\t\t\t\tsources++;\n\t\t\t\t\tif (sources > 1) {\n\t\t\t\t\t\tdelete effects[e];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgUM = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n\n\t\tif (!gUM) {\n\t\t\tdocument.body.removeChild(document.getElementById('camera'));\n\t\t\t//return;\n\t\t}\n\n\t\twindow.addEventListener('DOMContentLoaded', function() {\n\t\t\tvar s = Seriously(),\n\t\t\t\tblend = s.effect('blend'),\n\t\t\t\tsource = s.transform('reformat'),\n\t\t\t\ttransform2d = s.transform('2d'),\n\t\t\t\ttransform3d = s.transform('3d'),\n\t\t\t\t//perspective = s.transform('perspective'),\n\t\t\t\toptions = document.getElementById('options'),\n\t\t\t\timg = document.getElementById('img'),\n\t\t\t\tvideo = document.getElementById('video'),\n\t\t\t\tselect = document.getElementById('effects'),\n\t\t\t\tactive,\n\t\t\t\twebCamStream,\n\t\t\t\ttranslateZ, rotateX, rotateY, rotateZ,\n\t\t\t\te;\n\n\t\t\tfor (e in effects) {\n\t\t\t\tif (!Seriously.incompatible(e)) {\n\t\t\t\t\teffect = effects[e];\n\t\t\t\t\telement = document.createElement('option');\n\t\t\t\t\telement.value = e;\n\t\t\t\t\telement.appendChild(document.createTextNode(effect.title));\n\t\t\t\t\tselect.appendChild(element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsource.source = '#colorbars';\n\t\t\tsource.width = 720;\n\t\t\tsource.height = 540;\n\n\t\t\ttransform2d.source = source;\n\t\t\ttransform2d.scale(0.2);\n\t\t\ttransform2d.translate(-260, -200);\n\t\t\t//todo: translate to lower left corner\n\n\t\t\tblend.top = transform2d;\n\t\t\tblend.bottom = source;\n\n\t\t\ttransform3d.source = blend;\n\n\t\t\ttarget = s.target('#canvas');\n\t\t\ttarget.source = transform3d;\n\n\t\t\ts.go(function () {\n\t\t\t\tif (active && active.effect.time !== undefined) {\n\t\t\t\t\tactive.effect.time = Date.now() / 1000;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\ttranslateZ = document.getElementById('translate-z');\n\t\t\ttranslateZ.addEventListener('input', function () {\n\t\t\t\ttransform3d.translateZ = -parseFloat(this.value);\n\t\t\t});\n\n\t\t\trotateX = document.getElementById('rotate-x');\n\t\t\trotateX.addEventListener('input', function () {\n\t\t\t\ttransform3d.rotationX = parseFloat(this.value);\n\t\t\t});\n\n\t\t\trotateY = document.getElementById('rotate-y');\n\t\t\trotateY.addEventListener('input', function () {\n\t\t\t\ttransform3d.rotationY = parseFloat(this.value);\n\t\t\t});\n\n\t\t\trotateZ = document.getElementById('rotate-z');\n\t\t\trotateZ.addEventListener('input', function () {\n\t\t\t\ttransform3d.rotationZ = parseFloat(this.value);\n\t\t\t});\n\n\t\t\t/*\n\t\t\tperspective = document.getElementById('perspective');\n\t\t\tperspective.addEventListener('input', function () {\n\t\t\t\tblend.perspective(this.value);\n\t\t\t});\n\t\t\t*/\n\n\t\t\tdocument.getElementById('colorbutton').addEventListener('click', function() {\n\t\t\t\tvideo.pause();\n\t\t\t\tif (webCamStream && webCamStream.stop) {\n\t\t\t\t\twebCamStream.stop();\n\t\t\t\t}\n\t\t\t\twebCamStream = null;\n\t\t\t\tsource.source = '#colorbars';\n\t\t\t\ttarget.height = source.original.naturalHeight;\n\t\t\t\ttarget.width = source.original.naturalWidth;\n\t\t\t});\n\n\t\t\ttarget.original.addEventListener('dragover', function(event) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\ttarget.original.addEventListener('drop', function(event) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tvar reader = new FileReader,\n\t\t\t\t\tfile = event.dataTransfer.files[0],\n\t\t\t\t\tmedium = file.type.split('/')[0];\n\t\t\t\tconsole.log(file);\n\n\t\t\t\treader.onload = function(event) {\n\t\t\t\t\tfunction resize() {\n\t\t\t\t\t\ttarget.height = element.videoHeight || element.naturalHeight || element.height;\n\t\t\t\t\t\ttarget.width = element.videoWidth || element.naturalWidth || element.width;\n\t\t\t\t\t\tif (element.play) {\n\t\t\t\t\t\t\telement.currentTime = 0;\n\t\t\t\t\t\t\telement.play();\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttarget.render();\n\t\t\t\t\t}\n\n\t\t\t\t\tvar element;\n\t\t\t\t\tif (medium === 'image') {\n\t\t\t\t\t\telement = img;\n\t\t\t\t\t\telement.onload = resize;\n\t\t\t\t\t\telement.src = event.target.result;\n\t\t\t\t\t} else if (medium === 'video') {\n\t\t\t\t\t\telement = video;\n\t\t\t\t\t\telement.src = event.target.result;\n\t\t\t\t\t\tif (element.videoWidth) {\n\t\t\t\t\t\t\tresize();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telement.addEventListener('loadedmetadata', resize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//element.play();\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tsource.source = element;\n\t\t\t\t};\n\n\t\t\t\tif (medium === 'image' || medium === 'video') {\n\t\t\t\t\treader.readAsDataURL(file);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}, true);\n\n\t\t\tgUM && document.getElementById('camera').addEventListener('click', function () {\n\t\t\t\tgUM.call(navigator, { video: true }, function(stream) {\n\t\t\t\t\tfunction resize() {\n\t\t\t\t\t\ttarget.height = video.videoHeight;\n\t\t\t\t\t\ttarget.width = video.videoWidth;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (window.webkitURL) {\n\t\t\t\t\t\tvideo.src = window.webkitURL.createObjectURL(stream);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvideo.src = stream;\n\t\t\t\t\t}\n\n\t\t\t\t\twebCamStream = stream;\n\n\t\t\t\t\tvideo.play();\n\t\t\t\t\tif (video.videoWidth) {\n\t\t\t\t\t\tresize();\n\t\t\t\t\t}\n\t\t\t\t\tvideo.onloadedmetadata = video.onplay = resize;\n\t\t\t\t\tsource.source = video;\n\t\t\t\t}, function() {\n\t\t\t\t\tconsole.log('getUserMedia failed');\n\t\t\t\t});\n\n\t\t\t});\n\n\t\t\tselect.addEventListener('change', function() {\n\t\t\t\tfunction arrayToHex(color) {\n\t\t\t\t\tvar i, val, s = '#';\n\t\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\t\tval = Math.min(255, Math.round(color[i] * 255 || 0));\n\t\t\t\t\t\tval = val.toString(16);\n\t\t\t\t\t\tif (val.length === 1) {\n\t\t\t\t\t\t\tval = '0' + val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts += val;\n\t\t\t\t\t}\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\n\t\t\t\tvar form,\n\t\t\t\t\ttable,\n\t\t\t\t\trow,\n\t\t\t\t\tcell,\n\t\t\t\t\tlabel,\n\t\t\t\t\telement,\n\t\t\t\t\toption,\n\t\t\t\t\ti, j,\n\t\t\t\t\tinput,\n\t\t\t\t\tinputs,\n\t\t\t\t\tobj,\n\t\t\t\t\teffectType,\n\t\t\t\t\tname = this.value;\n\n\t\t\t\tif (name && !effectObjects[name]) {\n\t\t\t\t\teffectObjects[name] = obj = {\n\t\t\t\t\t\teffect: s.effect(name),\n\t\t\t\t\t\tform: document.createElement('div')\n\t\t\t\t\t};\n\n\t\t\t\t\t//create form\n\t\t\t\t\toptions.appendChild(obj.form);\n\t\t\t\t\teffectType = effects[name];\n\n\t\t\t\t\t//todo: title, description, set up table\n\n\t\t\t\t\tinputs = obj.effect.inputs();\n\t\t\t\t\tfor (i in inputs) {\n\t\t\t\t\t\tinput = inputs[i];\n\n\t\t\t\t\t\t//types: color, number (slider, number, text), enum (select), boolean (checkbox), vector\n\t\t\t\t\t\tif (input.type === 'image') {\n\t\t\t\t\t\t\tobj.source = i;\n\t\t\t\t\t\t\tobj.effect[i] = source;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//todo: way later - arrays of inputs\n\n\t\t\t\t\t\t\tif (!table) {\n\t\t\t\t\t\t\t\ttable = document.createElement('table');\n\t\t\t\t\t\t\t\tobj.form.appendChild(table);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trow = document.createElement('tr');\n\t\t\t\t\t\t\ttable.appendChild(row);\n\n\t\t\t\t\t\t\tcell = document.createElement('th');\n\t\t\t\t\t\t\trow.appendChild(cell);\n\n\t\t\t\t\t\t\tlabel = document.createElement('label');\n\t\t\t\t\t\t\tlabel.setAttribute('for','input-' + name + '-' + i);\n\t\t\t\t\t\t\tlabel.appendChild(document.createTextNode(input.title));\n\t\t\t\t\t\t\tcell.appendChild(label);\n\n\t\t\t\t\t\t\tcell = document.createElement('td');\n\t\t\t\t\t\t\trow.appendChild(cell);\n\n\t\t\t\t\t\t\tif ((i === 'time' || i == 'timer') && input.type === 'number') {\n\t\t\t\t\t\t\t\tif (timeNodes.indexOf(obj.effect) < 0) {\n\t\t\t\t\t\t\t\t\ttimeNodes.push(obj.effect);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (input.type === 'number') {\n\t\t\t\t\t\t\t\telement = document.createElement('input');\n\t\t\t\t\t\t\t\tif (input.min !== -Infinity && input.min !== undefined &&\n\t\t\t\t\t\t\t\t\tinput.max !== Infinity && input.max !== undefined) {\n\n\t\t\t\t\t\t\t\t\telement.setAttribute('type', 'range');\n\t\t\t\t\t\t\t\t\telement.setAttribute('min', input.min);\n\t\t\t\t\t\t\t\t\telement.setAttribute('max', input.max);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement.setAttribute('type', 'number');\n\t\t\t\t\t\t\t\t\tif (input.min !== -Infinity && input.min !== undefined) {\n\t\t\t\t\t\t\t\t\t\telement.setAttribute('min', input.min);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (input.max !== Infinity && input.max !== undefined) {\n\t\t\t\t\t\t\t\t\t\telement.setAttribute('max', input.max);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (input.step && !isNaN(input.step) && input.step > 0) {\n\t\t\t\t\t\t\t\t\telement.setAttribute('step', input.step);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telement.setAttribute('step', 0.01);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telement.value = input.defaultValue;\n\t\t\t\t\t\t\t} else if (input.type === 'color') {\n\t\t\t\t\t\t\t\telement = document.createElement('input');\n\n\t\t\t\t\t\t\t\t//element.addEventListener('click', function(e) {\n\t\t\t\t\t\t\t\t//\te = e || window.event;\n\t\t\t\t\t\t\t\t//\tcolorPicker(e);\n\t\t\t\t\t\t\t\t//\tcolorPicker.cP.style.zIndex = 1;\n\t\t\t\t\t\t\t\t//}, false);\n\t\t\t\t\t\t\t\telement.value = arrayToHex(input.defaultValue);\n\t\t\t\t\t\t\t} else if (input.type === 'enum') {\n\t\t\t\t\t\t\t\telement = document.createElement('select');\n\t\t\t\t\t\t\t\tfor (j = 0; j < input.options.length; j++) {\n\t\t\t\t\t\t\t\t\toption = document.createElement('option');\n\t\t\t\t\t\t\t\t\tif (input.options[j].length) {\n\t\t\t\t\t\t\t\t\t\toption.value = input.options[j][0];\n\t\t\t\t\t\t\t\t\t\toption.appendChild(document.createTextNode(input.options[j][1]));\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\toption.value = input.options[j];\n\t\t\t\t\t\t\t\t\t\toption.appendChild(document.createTextNode(input.options[j]));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telement.appendChild(option);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telement.value = input.defaultValue;\n\t\t\t\t\t\t\t} else if (input.type === 'boolean') {\n\t\t\t\t\t\t\t\telement = document.createElement('input');\n\t\t\t\t\t\t\t\telement.setAttribute('type', 'checkbox');\n\t\t\t\t\t\t\t\telement.checked = input.defaultValue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telement = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (element) {\n\t\t\t\t\t\t\t\telement.id = 'input-' + name + '-' + i;\n\t\t\t\t\t\t\t\tcell.appendChild(element);\n\t\t\t\t\t\t\t\tobj.effect[i] = element;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (active) {\n\t\t\t\t\tactive.form.style.display = 'none';\n\t\t\t\t}\n\n\t\t\t\tif (name) {\n\t\t\t\t\tactive = effectObjects[name];\n\t\t\t\t\tactive.form.style.display = 'block';\n\t\t\t\t\tblend.bottom = active.effect;\n\t\t\t\t} else {\n\t\t\t\t\tblend.bottom = source;\n\t\t\t\t}\n\n\t\t\t}, false);\n\t\t}, false);\n\t})();\n\t</script>\n\t</body>\n</html>\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "seriously.js",
          "type": "blob",
          "size": 152.6298828125,
          "content": "/*jslint devel: true, bitwise: true, browser: true, white: true, nomen: true, plusplus: true, maxerr: 50, indent: 4, todo: true */\n/*global Float32Array, Uint8Array, Uint16Array, WebGLTexture, HTMLInputElement, HTMLSelectElement, HTMLElement, WebGLFramebuffer, HTMLCanvasElement, WebGLRenderingContext, define, module, exports */\n(function (root, factory) {\n\t'use strict';\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine('seriously', function () {\n\t\t\tvar Seriously = factory(root);\n\t\t\tif (!root.Seriously) {\n\t\t\t\troot.Seriously = Seriously;\n\t\t\t}\n\t\t\treturn Seriously;\n\t\t});\n\t} else if (typeof exports === 'object') {\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like enviroments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory(root);\n\t} else if (typeof root.Seriously !== 'function') {\n\t\t// Browser globals\n\t\troot.Seriously = factory(root);\n\t}\n}(window, function (window) {\n\t'use strict';\n\n\tvar document = window.document,\n\t\tconsole = window.console,\n\n\t/*\n\t\tGlobal-ish look-up variables\n\t*/\n\n\ttestContext,\n\tcolorCtx,\n\tincompatibility,\n\tseriousEffects = {},\n\tseriousTransforms = {},\n\tseriousSources = {},\n\tseriousTargets = {},\n\ttimeouts = [],\n\tallEffectsByHook = {},\n\tallTransformsByHook = {},\n\tallSourcesByHook = {\n\t\tcanvas: [],\n\t\timage: [],\n\t\tvideo: []\n\t},\n\tallTargetsByHook = {},\n\tallTargets = window.WeakMap && new WeakMap(),\n\tidentity,\n\tmaxSeriouslyId = 0,\n\tnop = function () {},\n\tnoVideoTextureSupport,\n\n\t/*\n\t\tGlobal reference variables\n\t*/\n\n\t// http://www.w3.org/TR/css3-color/#svg-color\n\tcolorNames = {\n\t\ttransparent: [0, 0, 0, 0],\n\t\tblack: [0, 0, 0, 1],\n\t\tred: [1, 0, 0, 1],\n\t\tgreen: [0, 128 / 255, 0, 1],\n\t\tblue: [0, 0, 1, 1],\n\t\twhite: [1, 1, 1, 1],\n\t\tsilver: [192 / 255, 192 / 255, 192 / 255, 1],\n\t\tgray: [128 / 255, 128 / 255, 128 / 255, 1],\n\t\tmaroon: [128 / 255, 0, 0, 1],\n\t\tpurple: [128 / 255, 0, 128 / 255, 1],\n\t\tfuchsia: [1, 0, 1, 1],\n\t\tlime: [0, 1, 0, 1],\n\t\tolive: [128 / 255, 128 / 255, 0, 1],\n\t\tyellow: [1, 1, 0, 1],\n\t\tnavy: [0, 0, 128 / 255, 1],\n\t\tteal: [0, 128 / 255, 128 / 255, 1],\n\t\taqua: [0, 1, 1, 1],\n\t\torange: [1, 165 / 255, 0, 1]\n\t},\n\n\tcolorRegex = /^(rgb|hsl)a?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*(\\d+(\\.\\d*)?)\\s*)?\\)/i,\n\thexColorRegex = /^#(([0-9a-fA-F]{3,8}))/,\n\n\tvectorFields = ['x', 'y', 'z', 'w'],\n\tcolorFields = ['r', 'g', 'b', 'a'],\n\n\toutputRenderOptions = {\n\t\tsrcRGB: 0x0302, //SRC_ALPHA\n\t\tdstRGB: 0x0303, //ONE_MINUS_SRC_ALPHA\n\t\tsrcAlpha: 0x01, //ONE\n\t\tdstAlpha: 0x0303 //ONE_MINUS_SRC_ALPHA\n\t},\n\n\tshaderDebugConstants = [\n\t\t'MAX_COMBINED_TEXTURE_IMAGE_UNITS',\n\t\t'MAX_FRAGMENT_UNIFORM_VECTORS',\n\t\t'MAX_TEXTURE_IMAGE_UNITS',\n\t\t'MAX_VARYING_VECTORS',\n\t\t'MAX_VERTEX_ATTRIBS',\n\t\t'MAX_VERTEX_TEXTURE_IMAGE_UNITS',\n\t\t'MAX_VERTEX_UNIFORM_VECTORS'\n\t],\n\n\tshaderNameRegex = /^[\\t ]*#define[\\t ]+SHADER_NAME\\s+([^$\\n\\r]+)/i,\n\n\tbaseVertexShader,\n\tbaseFragmentShader,\n\n\t/*\n\t\tutility functions\n\t*/\n\n\t/*\n\tmat4 matrix functions borrowed from gl-matrix by toji\n\thttps://github.com/toji/gl-matrix\n\tLicense: https://github.com/toji/gl-matrix/blob/master/LICENSE.md\n\t*/\n\tmat4 = {\n\t\t/*\n\t\t * mat4.frustum\n\t\t * Generates a frustum matrix with the given bounds\n\t\t *\n\t\t * Params:\n\t\t * left, right - scalar, left and right bounds of the frustum\n\t\t * bottom, top - scalar, bottom and top bounds of the frustum\n\t\t * near, far - scalar, near and far bounds of the frustum\n\t\t * dest - Optional, mat4 frustum matrix will be written into\n\t\t *\n\t\t * Returns:\n\t\t * dest if specified, a new mat4 otherwise\n\t\t */\n\t\tfrustum: function (left, right, bottom, top, near, far, dest) {\n\t\t\tif(!dest) { dest = mat4.create(); }\n\t\t\tvar rl = (right - left),\n\t\t\t\ttb = (top - bottom),\n\t\t\t\tfn = (far - near);\n\t\t\tdest[0] = (near*2) / rl;\n\t\t\tdest[1] = 0;\n\t\t\tdest[2] = 0;\n\t\t\tdest[3] = 0;\n\t\t\tdest[4] = 0;\n\t\t\tdest[5] = (near*2) / tb;\n\t\t\tdest[6] = 0;\n\t\t\tdest[7] = 0;\n\t\t\tdest[8] = (right + left) / rl;\n\t\t\tdest[9] = (top + bottom) / tb;\n\t\t\tdest[10] = -(far + near) / fn;\n\t\t\tdest[11] = -1;\n\t\t\tdest[12] = 0;\n\t\t\tdest[13] = 0;\n\t\t\tdest[14] = -(far*near*2) / fn;\n\t\t\tdest[15] = 0;\n\t\t\treturn dest;\n\t\t},\n\n\t\tperspective: function (fovy, aspect, near, far, dest) {\n\t\t\tvar top = near*Math.tan(fovy*Math.PI / 360.0),\n\t\t\t\tright = top*aspect;\n\t\t\treturn mat4.frustum(-right, right, -top, top, near, far, dest);\n\t\t},\n\t\tmultiply: function (dest, mat, mat2) {\n\t\t\t// Cache the matrix values (makes for huge speed increases!)\n\t\t\tvar a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],\n\t\t\t\ta10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],\n\t\t\t\ta20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],\n\t\t\t\ta30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],\n\n\t\t\t// Cache only the current line of the second matrix\n\t\t\tb0 = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];\n\t\t\tdest[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n\t\t\tdest[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n\t\t\tdest[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n\t\t\tdest[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n\t\t\tb0 = mat2[4];\n\t\t\tb1 = mat2[5];\n\t\t\tb2 = mat2[6];\n\t\t\tb3 = mat2[7];\n\t\t\tdest[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n\t\t\tdest[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n\t\t\tdest[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n\t\t\tdest[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n\t\t\tb0 = mat2[8];\n\t\t\tb1 = mat2[9];\n\t\t\tb2 = mat2[10];\n\t\t\tb3 = mat2[11];\n\t\t\tdest[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n\t\t\tdest[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n\t\t\tdest[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n\t\t\tdest[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n\t\t\tb0 = mat2[12];\n\t\t\tb1 = mat2[13];\n\t\t\tb2 = mat2[14];\n\t\t\tb3 = mat2[15];\n\t\t\tdest[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n\t\t\tdest[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n\t\t\tdest[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n\t\t\tdest[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n\t\t\treturn dest;\n\t\t},\n\t\tidentity: function (dest) {\n\t\t\tdest[0] = 1;\n\t\t\tdest[1] = 0;\n\t\t\tdest[2] = 0;\n\t\t\tdest[3] = 0;\n\t\t\tdest[4] = 0;\n\t\t\tdest[5] = 1;\n\t\t\tdest[6] = 0;\n\t\t\tdest[7] = 0;\n\t\t\tdest[8] = 0;\n\t\t\tdest[9] = 0;\n\t\t\tdest[10] = 1;\n\t\t\tdest[11] = 0;\n\t\t\tdest[12] = 0;\n\t\t\tdest[13] = 0;\n\t\t\tdest[14] = 0;\n\t\t\tdest[15] = 1;\n\t\t\treturn dest;\n\t\t},\n\t\tcopy: function (out, a) {\n\t\t\tout[0] = a[0];\n\t\t\tout[1] = a[1];\n\t\t\tout[2] = a[2];\n\t\t\tout[3] = a[3];\n\t\t\tout[4] = a[4];\n\t\t\tout[5] = a[5];\n\t\t\tout[6] = a[6];\n\t\t\tout[7] = a[7];\n\t\t\tout[8] = a[8];\n\t\t\tout[9] = a[9];\n\t\t\tout[10] = a[10];\n\t\t\tout[11] = a[11];\n\t\t\tout[12] = a[12];\n\t\t\tout[13] = a[13];\n\t\t\tout[14] = a[14];\n\t\t\tout[15] = a[15];\n\t\t\treturn out;\n\t\t}\n\t},\n\n\trequestAnimationFrame = (function (){\n\t\tvar lastTime = 0;\n\t\treturn  window.requestAnimationFrame ||\n\t\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\t\twindow.oRequestAnimationFrame ||\n\t\t\t\twindow.msRequestAnimationFrame ||\n\t\t\t\tfunction (callback) {\n\t\t\t\t\tvar currTime, timeToCall, id;\n\n\t\t\t\t\tfunction timeoutCallback() {\n\t\t\t\t\t\tcallback(currTime + timeToCall);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrTime = new Date().getTime();\n\t\t\t\t\ttimeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\t\t\t\tid = window.setTimeout(timeoutCallback, timeToCall);\n\t\t\t\t\tlastTime = currTime + timeToCall;\n\t\t\t\t\treturn id;\n\t\t\t\t};\n\t}()),\n\n\tcancelAnimFrame = (function (){\n\t\treturn  window.cancelAnimationFrame ||\n\t\t\t\twindow.webkitCancelAnimationFrame ||\n\t\t\t\twindow.mozCancelAnimationFrame ||\n\t\t\t\twindow.oCancelAnimationFrame ||\n\t\t\t\twindow.msCancelAnimationFrame ||\n\t\t\t\tfunction (id) {\n\t\t\t\t\twindow.cancelTimeout(id);\n\t\t\t\t};\n\t}()),\n\n\treservedEffectProperties = [\n\t\t'alias',\n\t\t'destroy',\n\t\t'effect',\n\t\t'id',\n\t\t'initialize',\n\t\t'inputs',\n\t\t'isDestroyed',\n\t\t'isReady',\n\t\t'matte',\n\t\t'off',\n\t\t'on',\n\t\t'readPixels',\n\t\t'render',\n\t\t'title',\n\t\t'update'\n\t],\n\n\treservedTransformProperties = [\n\t\t'alias',\n\t\t'destroy',\n\t\t'id',\n\t\t'inputs',\n\t\t'isDestroyed',\n\t\t'isReady',\n\t\t'off',\n\t\t'on',\n\t\t'source',\n\t\t'title',\n\t\t'update'\n\t],\n\n\treservedNames = [\n\t\t'aliases',\n\t\t'defaults',\n\t\t'destroy',\n\t\t'effect',\n\t\t'go',\n\t\t'id',\n\t\t'incompatible',\n\t\t'isDestroyed',\n\t\t'isEffect',\n\t\t'isNode',\n\t\t'isSource',\n\t\t'isTarget',\n\t\t'isTransform',\n\t\t'removeAlias',\n\t\t'render',\n\t\t'source',\n\t\t'stop',\n\t\t'target',\n\t\t'transform'\n\t];\n\n\tfunction getElement(input, tags) {\n\t\tvar element,\n\t\t\ttag;\n\n\t\tif (typeof input === 'string') {\n\t\t\t//element = document.getElementById(input) || document.getElementsByTagName(input)[0];\n\t\t\telement = document.querySelector(input);\n\t\t} else if (!input) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (input.tagName) {\n\t\t\telement = input;\n\t\t}\n\n\t\tif (!element) {\n\t\t\treturn input;\n\t\t}\n\n\t\ttag = element.tagName.toLowerCase();\n\t\tif (tags && tags.indexOf(tag) < 0) {\n\t\t\treturn input;\n\t\t}\n\n\t\treturn element;\n\t}\n\n\tfunction extend(dest, src) {\n\t\tvar property,\n\t\t\tdescriptor;\n\n\t\t//todo: are we sure this is safe?\n\t\tif (dest.prototype && src.prototype && dest.prototype !== src.prototype) {\n\t\t\textend(dest.prototype, src.prototype);\n\t\t}\n\n\t\tfor (property in src) {\n\t\t\tif (src.hasOwnProperty(property)) {\n\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(src, property);\n\n\t\t\t\tif (descriptor.get || descriptor.set) {\n\t\t\t\t\tObject.defineProperty(dest, property, {\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tget: descriptor.get,\n\t\t\t\t\t\tset: descriptor.set\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tdest[property] = src[property];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dest;\n\t}\n\n\tfunction consoleMethod(name) {\n\t\tvar method;\n\t\tif (!console) {\n\t\t\treturn nop;\n\t\t}\n\n\t\tif (typeof console[name] === 'function') {\n\t\t\tmethod = console[name];\n\t\t} else if (typeof console.log === 'function') {\n\t\t\tmethod = console.log;\n\t\t} else {\n\t\t\treturn nop;\n\t\t}\n\n\t\tif (method.bind) {\n\t\t\treturn method.bind(console);\n\t\t}\n\n\t\treturn function () {\n\t\t\tmethod.apply(console, arguments);\n\t\t};\n\t}\n\n\t/*\n\tLike instanceof, but it will work on elements that come from different windows (e.g. iframes)\n\n\tWe do not use this for constructors defined in this script.\n\t*/\n\tfunction isInstance(obj, proto) {\n\t\tif (!proto) {\n\t\t\tproto = 'HTMLElement';\n\t\t}\n\n\t\tif (obj instanceof window[proto]) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!obj || typeof obj !== 'object') {\n\t\t\treturn false;\n\t\t}\n\n\t\twhile (obj) {\n\t\t\tobj = Object.getPrototypeOf(obj);\n\t\t\tif (obj && obj.constructor.name === proto) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//http://www.w3.org/TR/css3-color/#hsl-color\n\tfunction hslToRgb(h, s, l, a, out) {\n\t\tfunction hueToRgb(m1, m2, h) {\n\t\t\th = h % 1;\n\t\t\tif (h < 0) {\n\t\t\t\th += 1;\n\t\t\t}\n\t\t\tif (h < 1 / 6) {\n\t\t\t\treturn m1 + (m2 - m1) * h * 6;\n\t\t\t}\n\t\t\tif (h < 1 / 2) {\n\t\t\t\treturn m2;\n\t\t\t}\n\t\t\tif (h < 2 / 3) {\n\t\t\t\treturn m1 + (m2 - m1) * (2/3 - h) * 6;\n\t\t\t}\n\t\t\treturn m1;\n\t\t}\n\n\t\tvar m1, m2;\n\t\tif (l < 0.5) {\n\t\t\tm2 = l * (s + 1);\n\t\t} else {\n\t\t\tm2 = l + s - l * s;\n\t\t}\n\t\tm1 = l * 2 - m2;\n\n\t\tif (!out) {\n\t\t\tout = [];\n\t\t}\n\n\t\tout[0] = hueToRgb(m1, m2, h + 1/3);\n\t\tout[1] = hueToRgb(m1, m2, h);\n\t\tout[2] = hueToRgb(m1, m2, h - 1/3);\n\t\tout[3] = a;\n\n\t\treturn out;\n\t}\n\n\tfunction colorArrayToHex(color) {\n\t\tvar i,\n\t\t\tval,\n\t\t\thex,\n\t\t\ts = '#',\n\t\t\tlen = color[3] < 1 ? 4 : 3;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tval = Math.min(255, Math.round(color[i] * 255 || 0));\n\t\t\thex = val.toString(16);\n\t\t\tif (val < 16) {\n\t\t\t\thex = '0' + hex;\n\t\t\t}\n\t\t\ts += hex;\n\t\t}\n\t\treturn s;\n\t}\n\n\tfunction isArrayLike(obj) {\n\t\treturn Array.isArray(obj) ||\n\t\t\t(obj && obj.BYTES_PER_ELEMENT && 'length' in obj);\n\t}\n\n\t/*\n\tfaster than setTimeout(fn, 0);\n\thttp://dbaron.org/log/20100309-faster-timeouts\n\t*/\n\tfunction setTimeoutZero(fn) {\n\t\t/*\n\t\tWorkaround for postMessage bug in Firefox if the page is loaded from the file system\n\t\thttps://bugzilla.mozilla.org/show_bug.cgi?id=740576\n\t\tShould run fine, but maybe a few milliseconds slower per frame.\n\t\t*/\n\t\tfunction timeoutFunction() {\n\t\t\tif (timeouts.length) {\n\t\t\t\t(timeouts.shift())();\n\t\t\t}\n\t\t}\n\n\t\tif (typeof fn !== 'function') {\n\t\t\tthrow new Error('setTimeoutZero argument is not a function');\n\t\t}\n\n\t\ttimeouts.push(fn);\n\t\tif (window.location.protocol === 'file:') {\n\t\t\tsetTimeout(timeoutFunction, 0);\n\t\t\treturn;\n\t\t}\n\n\t\twindow.postMessage('seriously-timeout-message', window.location);\n\t}\n\n\twindow.addEventListener('message', function (event) {\n\t\tif (event.source === window && event.data === 'seriously-timeout-message') {\n\t\t\tevent.stopPropagation();\n\t\t\tif (timeouts.length > 0) {\n\t\t\t\tvar fn = timeouts.shift();\n\t\t\t\tfn();\n\t\t\t}\n\t\t}\n\t}, true);\n\n\tfunction getWebGlContext(canvas, options) {\n\t\tvar context;\n\t\ttry {\n\t\t\tif (window.WebGLDebugUtils && options && options.debugContext) {\n\t\t\t\tcontext = window.WebGLDebugUtils.makeDebugContext(canvas.getContext('webgl', options));\n\t\t\t} else {\n\t\t\t\tcontext = canvas.getContext('webgl', options);\n\t\t\t}\n\t\t} catch (expError) {\n\t\t}\n\n\t\tif (!context) {\n\t\t\ttry {\n\t\t\t\tcontext = canvas.getContext('experimental-webgl', options);\n\t\t\t} catch (error) {\n\t\t\t}\n\t\t}\n\t\treturn context;\n\t}\n\n\tfunction getTestContext() {\n\t\tvar canvas;\n\n\t\tif (testContext && testContext.getError() === testContext.CONTEXT_LOST_WEBGL) {\n\t\t\t/*\n\t\t\tTest context was lost already, and the webglcontextlost event maybe hasn't fired yet\n\t\t\tso try making a new context\n\t\t\t*/\n\t\t\ttestContext = undefined;\n\t\t}\n\n\t\tif (testContext || !window.WebGLRenderingContext || incompatibility) {\n\t\t\treturn testContext;\n\t\t}\n\n\t\tcanvas = document.createElement('canvas');\n\t\ttestContext = getWebGlContext(canvas);\n\n\t\tif (testContext) {\n\t\t\tcanvas.addEventListener('webglcontextlost', function contextLost(event) {\n\t\t\t\t/*\n\t\t\t\tIf/When context is lost, just clear testContext and create\n\t\t\t\ta new one the next time it's needed\n\t\t\t\t*/\n\t\t\t\tevent.preventDefault();\n\t\t\t\tif (testContext && testContext.canvas === this) {\n\t\t\t\t\ttestContext = undefined;\n\t\t\t\t\tcanvas.removeEventListener('webglcontextlost', contextLost, false);\n\t\t\t\t}\n\t\t\t}, false);\n\t\t} else {\n\t\t\tSeriously.logger.warn('Unable to access WebGL.');\n\t\t}\n\n\t\treturn testContext;\n\t}\n\n\tfunction checkSource(source) {\n\t\tvar element, canvas, ctx, texture;\n\n\t\t//todo: don't need to create a new array every time we do this\n\t\telement = getElement(source, ['img', 'canvas', 'video']);\n\t\tif (!element) {\n\t\t\treturn false;\n\t\t}\n\n\t\tcanvas = document.createElement('canvas');\n\t\tif (!canvas) {\n\t\t\tSeriously.logger.warn('Browser does not support canvas or Seriously.js');\n\t\t\treturn false;\n\t\t}\n\n\t\tif (element.naturalWidth === 0 && element.tagName === 'IMG') {\n\t\t\tSeriously.logger.warn('Image not loaded');\n\t\t\treturn false;\n\t\t}\n\n\t\tif (element.readyState === 0 && element.videoWidth === 0 && element.tagName === 'VIDEO') {\n\t\t\tSeriously.logger.warn('Video not loaded');\n\t\t\treturn false;\n\t\t}\n\n\t\tctx = getTestContext();\n\t\tif (ctx) {\n\t\t\ttexture = ctx.createTexture();\n\t\t\tif (!texture) {\n\t\t\t\tSeriously.logger.error('Test WebGL context has been lost');\n\t\t\t}\n\n\t\t\tctx.bindTexture(ctx.TEXTURE_2D, texture);\n\n\t\t\ttry {\n\t\t\t\tctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, ctx.RGBA, ctx.UNSIGNED_BYTE, element);\n\t\t\t} catch (textureError) {\n\t\t\t\tif (textureError.code === window.DOMException.SECURITY_ERR) {\n\t\t\t\t\tSeriously.logger.log('Unable to access cross-domain image');\n\t\t\t\t} else {\n\t\t\t\t\tSeriously.logger.error('Error storing image to texture: ' + textureError.message);\n\t\t\t\t}\n\t\t\t\tctx.deleteTexture(texture);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tctx.deleteTexture(texture);\n\t\t} else {\n\t\t\tctx = canvas.getContext('2d');\n\t\t\ttry {\n\t\t\t\tctx.drawImage(element, 0, 0);\n\t\t\t\tctx.getImageData(0, 0, 1, 1);\n\t\t\t} catch (drawImageError) {\n\t\t\t\tif (drawImageError.code === window.DOMException.SECURITY_ERR) {\n\t\t\t\t\tSeriously.logger.log('Unable to access cross-domain image');\n\t\t\t\t} else {\n\t\t\t\t\tSeriously.logger.error('Error drawing image to canvas: ' + drawImageError.message);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// This method will return a false positive for resources that aren't\n\t\t// actually images or haven't loaded yet\n\n\t\treturn true;\n\t}\n\n\tfunction validateInputSpecs(plugin) {\n\t\tvar input,\n\t\t\toptions,\n\t\t\tname;\n\n\t\tfunction normalizeEnumOption(option, i) {\n\t\t\tvar key,\n\t\t\t\tname;\n\n\t\t\tif (isArrayLike(option)) {\n\t\t\t\tkey = option[0];\n\t\t\t\tname = option[1] || key;\n\t\t\t} else {\n\t\t\t\tkey = option;\n\t\t\t}\n\n\t\t\tif (typeof key === 'string') {\n\t\t\t\tkey = key.toLowerCase();\n\t\t\t} else if (typeof key === 'number') {\n\t\t\t\tkey = String(key);\n\t\t\t} else if (!key) {\n\t\t\t\tkey = '';\n\t\t\t}\n\n\t\t\toptions[key] = name;\n\n\t\t\tif (!i) {\n\t\t\t\tinput.firstValue = key;\n\t\t\t}\n\t\t}\n\n\t\tfunction passThrough(value) {\n\t\t\treturn value;\n\t\t}\n\n\t\tfor (name in plugin.inputs) {\n\t\t\tif (plugin.inputs.hasOwnProperty(name)) {\n\t\t\t\tif (plugin.reserved.indexOf(name) >= 0 || Object.prototype[name]) {\n\t\t\t\t\tthrow new Error('Reserved input name: ' + name);\n\t\t\t\t}\n\n\t\t\t\tinput = plugin.inputs[name];\n\t\t\t\tinput.name = name;\n\n\t\t\t\tif (isNaN(input.min)) {\n\t\t\t\t\tinput.min = -Infinity;\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(input.max)) {\n\t\t\t\t\tinput.max = Infinity;\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(input.minCount)) {\n\t\t\t\t\tinput.minCount = -Infinity;\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(input.maxCount)) {\n\t\t\t\t\tinput.maxCount = Infinity;\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(input.step)) {\n\t\t\t\t\tinput.step = 0;\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(input.mod)) {\n\t\t\t\t\tinput.mod = 0;\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'enum') {\n\t\t\t\t\t/*\n\t\t\t\t\tNormalize options to make validation easy\n\t\t\t\t\t- all items will have both a key and a name\n\t\t\t\t\t- all keys will be lowercase strings\n\t\t\t\t\t*/\n\t\t\t\t\tif (input.options && isArrayLike(input.options) && input.options.length) {\n\t\t\t\t\t\toptions = {};\n\t\t\t\t\t\tinput.options.forEach(normalizeEnumOption);\n\t\t\t\t\t\tinput.options = options;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'vector') {\n\t\t\t\t\tif (input.dimensions < 2) {\n\t\t\t\t\t\tinput.dimensions = 2;\n\t\t\t\t\t} else if (input.dimensions > 4) {\n\t\t\t\t\t\tinput.dimensions = 4;\n\t\t\t\t\t} else if (!input.dimensions || isNaN(input.dimensions)) {\n\t\t\t\t\t\tinput.dimensions = 4;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinput.dimensions = Math.round(input.dimensions);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinput.dimensions = 1;\n\t\t\t\t}\n\n\t\t\t\tinput.shaderDirty = !!input.shaderDirty;\n\n\t\t\t\tif (typeof input.validate !== 'function') {\n\t\t\t\t\tinput.validate = Seriously.inputValidators[input.type] || passThrough;\n\t\t\t\t}\n\n\t\t\t\tif (!plugin.defaultImageInput && input.type === 'image') {\n\t\t\t\t\tplugin.defaultImageInput = name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\thelper Classes\n\t*/\n\n\tfunction FrameBuffer(gl, width, height, options) {\n\t\tvar frameBuffer,\n\t\t\trenderBuffer,\n\t\t\ttex,\n\t\t\tstatus,\n\t\t\tuseFloat = options === true ? options : (options && options.useFloat);\n\n\t\tuseFloat = false;//useFloat && !!gl.getExtension('OES_texture_float'); //useFloat is not ready!\n\t\tif (useFloat) {\n\t\t\tthis.type = gl.FLOAT;\n\t\t} else {\n\t\t\tthis.type = gl.UNSIGNED_BYTE;\n\t\t}\n\n\t\tframeBuffer = gl.createFramebuffer();\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n\n\t\tif (options && options.texture) {\n\t\t\tthis.texture = options.texture;\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, this.texture);\n\t\t\tthis.ownTexture = false;\n\t\t} else {\n\t\t\tthis.texture = gl.createTexture();\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, this.texture);\n\t\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\tthis.ownTexture = true;\n\t\t}\n\n\t\ttry {\n\t\t\tif (this.type === gl.FLOAT) {\n\t\t\t\ttex = new Float32Array(width * height * 4);\n\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, tex);\n\t\t\t} else {\n\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\t\t\t\tthis.type = gl.UNSIGNED_BYTE;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// Null rejected\n\t\t\tthis.type = gl.UNSIGNED_BYTE;\n\t\t\ttex = new Uint8Array(width * height * 4);\n\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tex);\n\t\t}\n\n\t\trenderBuffer = gl.createRenderbuffer();\n\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);\n\t\tgl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);\n\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderBuffer);\n\n\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\n\n\t\tstatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n\t\tif (status === gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {\n\t\t\tthrow new Error('Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT');\n\t\t}\n\n\t\tif (status === gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {\n\t\t\tthrow new Error('Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');\n\t\t}\n\n\t\tif (status === gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS) {\n\t\t\tthrow new Error('Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS');\n\t\t}\n\n\t\tif (status === gl.FRAMEBUFFER_UNSUPPORTED) {\n\t\t\tthrow new Error('Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED');\n\t\t}\n\n\t\tif (status !== gl.FRAMEBUFFER_COMPLETE) {\n\t\t\tthrow new Error('Incomplete framebuffer: ' + status);\n\t\t}\n\n\t\t//clean up\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, null);\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\t\tthis.gl = gl;\n\t\tthis.frameBuffer = frameBuffer;\n\t\tthis.renderBuffer = renderBuffer;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t}\n\n\tFrameBuffer.prototype.resize = function (width, height) {\n\t\tvar gl = this.gl;\n\n\t\tif (this.width === width && this.height === height) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tif (!gl) {\n\t\t\treturn;\n\t\t}\n\n\t\tgl.bindTexture(gl.TEXTURE_2D, this.texture);\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);\n\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);\n\n\t\t//todo: handle float\n\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\t\tgl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);\n\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\n\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, null);\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\t};\n\n\tFrameBuffer.prototype.destroy = function () {\n\t\tvar gl = this.gl;\n\n\t\tif (gl) {\n\t\t\tgl.deleteFramebuffer(this.frameBuffer);\n\t\t\tgl.deleteRenderbuffer(this.renderBuffer);\n\t\t\tif (this.ownTexture) {\n\t\t\t\tgl.deleteTexture(this.texture);\n\t\t\t}\n\t\t}\n\n\t\tdelete this.frameBuffer;\n\t\tdelete this.renderBuffer;\n\t\tdelete this.texture;\n\t\tdelete this.gl;\n\t};\n\n\t/* ShaderProgram - utility class for building and accessing WebGL shaders */\n\n\tfunction ShaderProgram(gl, vertexShaderSource, fragmentShaderSource) {\n\t\tvar program, vertexShader, fragmentShader,\n\t\t\tprogramError = '',\n\t\t\tshaderError,\n\t\t\ti, l,\n\t\t\tshaderNameRegexMatch,\n\t\t\tobj;\n\n\t\tfunction compileShader(source, fragment) {\n\t\t\tvar shader, j;\n\t\t\tif (fragment) {\n\t\t\t\tshader = gl.createShader(gl.FRAGMENT_SHADER);\n\t\t\t} else {\n\t\t\t\tshader = gl.createShader(gl.VERTEX_SHADER);\n\t\t\t}\n\n\t\t\tgl.shaderSource(shader, source);\n\t\t\tgl.compileShader(shader);\n\n\t\t\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\t\t\tsource = source.split(/[\\n\\r]/);\n\t\t\t\tfor (j = 0; j < source.length; j++) {\n\t\t\t\t\tsource[j] = (j + 1) + ':\\t' + source[j];\n\t\t\t\t}\n\t\t\t\tsource.unshift('Error compiling ' + (fragment ? 'fragment' : 'vertex') + ' shader:');\n\t\t\t\tSeriously.logger.error(source.join('\\n'));\n\t\t\t\tthrow new Error('Shader error: ' + gl.getShaderInfoLog(shader));\n\t\t\t}\n\n\t\t\treturn shader;\n\t\t}\n\n\t\tfunction makeShaderSetter(info, loc) {\n\t\t\tif (info.type === gl.SAMPLER_2D) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\tinfo.glTexture = gl['TEXTURE' + value];\n\t\t\t\t\tgl.uniform1i(loc, value);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (info.type === gl.BOOL|| info.type === gl.INT) {\n\t\t\t\tif (info.size > 1) {\n\t\t\t\t\treturn function (value) {\n\t\t\t\t\t\tgl.uniform1iv(loc, value);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn function (value) {\n\t\t\t\t\tgl.uniform1i(loc, value);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (info.type === gl.FLOAT) {\n\t\t\t\tif (info.size > 1) {\n\t\t\t\t\treturn function (value) {\n\t\t\t\t\t\tgl.uniform1fv(loc, value);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn function (value) {\n\t\t\t\t\tgl.uniform1f(loc, value);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (info.type === gl.FLOAT_VEC2) {\n\t\t\t\treturn function (obj) {\n\t\t\t\t\tgl.uniform2f(loc, obj[0], obj[1]);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (info.type === gl.FLOAT_VEC3) {\n\t\t\t\treturn function (obj) {\n\t\t\t\t\tgl.uniform3f(loc, obj[0], obj[1], obj[2]);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (info.type === gl.FLOAT_VEC4) {\n\t\t\t\treturn function (obj) {\n\t\t\t\t\tgl.uniform4f(loc, obj[0], obj[1], obj[2], obj[3]);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (info.type === gl.FLOAT_MAT3) {\n\t\t\t\treturn function (mat3) {\n\t\t\t\t\tgl.uniformMatrix3fv(loc, false, mat3);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (info.type === gl.FLOAT_MAT4) {\n\t\t\t\treturn function (mat4) {\n\t\t\t\t\tgl.uniformMatrix4fv(loc, false, mat4);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Unknown shader uniform type: ' + info.type);\n\t\t}\n\n\t\tfunction makeShaderGetter(loc) {\n\t\t\treturn function () {\n\t\t\t\treturn gl.getUniform(program, loc);\n\t\t\t};\n\t\t}\n\n\t\tvertexShader = compileShader(vertexShaderSource);\n\t\tfragmentShader = compileShader(fragmentShaderSource, true);\n\n\t\tprogram = gl.createProgram();\n\t\tgl.attachShader(program, vertexShader);\n\t\tshaderError = gl.getShaderInfoLog(vertexShader);\n\t\tif (shaderError) {\n\t\t\tprogramError += 'Vertex shader error: ' + shaderError + '\\n';\n\t\t}\n\t\tgl.attachShader(program, fragmentShader);\n\t\tshaderError = gl.getShaderInfoLog(fragmentShader);\n\t\tif (shaderError) {\n\t\t\tprogramError += 'Fragment shader error: ' + shaderError + '\\n';\n\t\t}\n\t\tgl.linkProgram(program);\n\n\t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\t\t\tprogramError += gl.getProgramInfoLog(program);\n\t\t\tgl.deleteProgram(program);\n\t\t\tgl.deleteShader(vertexShader);\n\t\t\tgl.deleteShader(fragmentShader);\n\n\t\t\tshaderNameRegexMatch = shaderNameRegex.exec(vertexShaderSource) ||\n\t\t\t\tshaderNameRegex.exec(fragmentShaderSource);\n\n\t\t\tif (shaderNameRegexMatch) {\n\t\t\t\tprogramError = 'Shader = ' + shaderNameRegexMatch[1] + '\\n' + programError;\n\t\t\t}\n\n\t\t\tshaderDebugConstants.forEach(function (c) {\n\t\t\t\tprogramError += '\\n' + c + ': ' + gl.getParameter(gl[c]);\n\t\t\t});\n\n\t\t\tthrow new Error('Could not initialize shader:\\n' + programError);\n\t\t}\n\n\t\tgl.useProgram(program);\n\n\t\tthis.uniforms = {};\n\n\t\tl = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\t\tfor (i = 0; i < l; ++i) {\n\t\t\tobj = {\n\t\t\t\tinfo: gl.getActiveUniform(program, i)\n\t\t\t};\n\n\t\t\tobj.name = obj.info.name.replace(/\\[0\\]$/, '');\n\t\t\tobj.loc = gl.getUniformLocation(program, obj.name);\n\t\t\tobj.set = makeShaderSetter(obj.info, obj.loc);\n\t\t\tobj.get = makeShaderGetter(obj.loc);\n\t\t\tthis.uniforms[obj.name] = obj;\n\n\t\t\tif (!this[obj.name]) {\n\t\t\t\t//for convenience\n\t\t\t\tthis[obj.name] = obj;\n\t\t\t}\n\t\t}\n\n\t\tthis.attributes = {};\n\t\tthis.location = {};\n\t\tl = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\t\tfor (i = 0; i < l; ++i) {\n\t\t\tobj = {\n\t\t\t\tinfo: gl.getActiveAttrib(program, i)\n\t\t\t};\n\n\t\t\tobj.name = obj.info.name;\n\t\t\tobj.location = gl.getAttribLocation(program, obj.name);\n\t\t\tthis.attributes[obj.name] = obj;\n\t\t\tthis.location[obj.name] = obj.location;\n\t\t}\n\n\t\tthis.gl = gl;\n\t\tthis.program = program;\n\n\t\tthis.destroy = function () {\n\t\t\tvar key;\n\n\t\t\tif (gl) {\n\t\t\t\tgl.deleteProgram(program);\n\t\t\t\tgl.deleteShader(vertexShader);\n\t\t\t\tgl.deleteShader(fragmentShader);\n\t\t\t}\n\n\t\t\tfor (key in this) {\n\t\t\t\tif (this.hasOwnProperty(key)) {\n\t\t\t\t\tdelete this[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprogram = null;\n\t\t\tvertexShader = null;\n\t\t\tfragmentShader = null;\n\t\t};\n\t}\n\n\tShaderProgram.prototype.use = function () {\n\t\tthis.gl.useProgram(this.program);\n\t};\n\n\t/*\n\t\tmain class: Seriously\n\t*/\n\n\tfunction Seriously(options) {\n\n\t\t//if called without 'new', make a new object and return that\n\t\tif (window === this || !(this instanceof Seriously) || this.id !== undefined) {\n\t\t\treturn new Seriously(options);\n\t\t}\n\n\t\t//initialize object, private properties\n\t\tvar id = ++maxSeriouslyId,\n\t\t\tseriously = this,\n\t\t\tnodes = [],\n\t\t\tnodesById = {},\n\t\t\tnodeId = 0,\n\t\t\tsources = [],\n\t\t\ttargets = [],\n\t\t\ttransforms = [],\n\t\t\teffects = [],\n\t\t\taliases = {},\n\t\t\tpreCallbacks = [],\n\t\t\tpostCallbacks = [],\n\t\t\tdefaultInputs = {},\n\t\t\tglCanvas,\n\t\t\tgl,\n\t\t\tprimaryTarget,\n\t\t\trectangleModel,\n\t\t\tcommonShaders = {},\n\t\t\tbaseShader,\n\t\t\tNode, SourceNode, EffectNode, TransformNode, TargetNode,\n\t\t\tEffect, Source, Transform, Target,\n\t\t\tauto = false,\n\t\t\tisDestroyed = false,\n\t\t\trafId;\n\n\t\tfunction makeGlModel(shape, gl) {\n\t\t\tvar vertex, index, texCoord;\n\n\t\t\tif (!gl) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvertex = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vertex);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, shape.vertices, gl.STATIC_DRAW);\n\t\t\tvertex.size = 3;\n\n\t\t\tindex = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index);\n\t\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW);\n\n\t\t\ttexCoord = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, texCoord);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, shape.coords, gl.STATIC_DRAW);\n\t\t\ttexCoord.size = 2;\n\n\t\t\treturn {\n\t\t\t\tvertex: vertex,\n\t\t\t\tindex: index,\n\t\t\t\ttexCoord: texCoord,\n\t\t\t\tlength: shape.indices.length,\n\t\t\t\tmode: shape.mode || gl.TRIANGLES\n\t\t\t};\n\t\t}\n\n\t\tfunction buildRectangleModel(gl) {\n\t\t\tvar shape = {};\n\n\t\t\tshape.vertices = new Float32Array([\n\t\t\t\t-1, -1, 0,\n\t\t\t\t1, -1, 0,\n\t\t\t\t1, 1, 0,\n\t\t\t\t-1, 1, 0\n\t\t\t]);\n\n\t\t\tshape.indices = new Uint16Array([\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\t// Front face\n\t\t\t]);\n\n\t\t\tshape.coords = new Float32Array([\n\t\t\t\t0, 0,\n\t\t\t\t1, 0,\n\t\t\t\t1, 1,\n\t\t\t\t0, 1\n\t\t\t]);\n\n\t\t\treturn makeGlModel(shape, gl);\n\t\t}\n\n\t\tfunction attachContext(context) {\n\t\t\tvar i, node;\n\n\t\t\tif (gl) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcontext.canvas.addEventListener('webglcontextlost', destroyContext, false);\n\t\t\tcontext.canvas.addEventListener('webglcontextrestored', restoreContext, false);\n\n\t\t\tif (context.isContextLost()) {\n\t\t\t\tSeriously.logger.warn('Unable to attach lost WebGL context. Will try again when context is restored.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgl = context;\n\t\t\tglCanvas = context.canvas;\n\n\t\t\trectangleModel = buildRectangleModel(gl);\n\n\t\t\tbaseShader = new ShaderProgram(\n\t\t\t\tgl,\n\t\t\t\t'#define SHADER_NAME seriously.base\\n' + baseVertexShader, '#define SHADER_NAME seriously.base\\n' + baseFragmentShader\n\t\t\t);\n\n\t\t\tfor (i = 0; i < effects.length; i++) {\n\t\t\t\tnode = effects[i];\n\t\t\t\tnode.gl = gl;\n\t\t\t\tnode.initialize();\n\t\t\t\tnode.buildShader();\n\t\t\t}\n\n\t\t\tfor (i = 0; i < sources.length; i++) {\n\t\t\t\tnode = sources[i];\n\t\t\t\tnode.initialize();\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targets.length; i++) {\n\t\t\t\tnode = targets[i];\n\n\t\t\t\tif (!node.model) {\n\t\t\t\t\tnode.model = rectangleModel;\n\t\t\t\t\tnode.shader = baseShader;\n\t\t\t\t}\n\n\t\t\t\t//todo: initialize frame buffer if not main canvas\n\t\t\t}\n\t\t}\n\n\t\tfunction restoreContext() {\n\t\t\tvar context,\n\t\t\t\ttarget,\n\t\t\t\ti,\n\t\t\t\tnode;\n\n\t\t\tif (primaryTarget && !gl) {\n\t\t\t\ttarget = primaryTarget.target;\n\n\t\t\t\t//todo: if too many webglcontextlost events fired in too short a time, abort\n\t\t\t\t//todo: consider allowing \"manual\" control of restoring context\n\n\t\t\t\tif (isInstance(target, 'WebGLFramebuffer')) {\n\t\t\t\t\tSeriously.logger.error('Unable to restore target built on WebGLFramebuffer');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcontext = getWebGlContext(target, {\n\t\t\t\t\talpha: true,\n\t\t\t\t\tpremultipliedAlpha: true,\n\t\t\t\t\tpreserveDrawingBuffer: true,\n\t\t\t\t\tstencil: true,\n\t\t\t\t\tdebugContext: primaryTarget.debugContext\n\t\t\t\t});\n\n\t\t\t\tif (context) {\n\t\t\t\t\tif (context.isContextLost()) {\n\t\t\t\t\t\tSeriously.logger.error('Unable to restore WebGL Context');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tattachContext(context);\n\n\t\t\t\t\tif (primaryTarget.renderToTexture) {\n\t\t\t\t\t\tprimaryTarget.frameBuffer = new FrameBuffer(gl, primaryTarget.width, primaryTarget.height, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprimaryTarget.frameBuffer = {\n\t\t\t\t\t\t\tframeBuffer: null\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\tSet all nodes dirty. In most cases, it should only be necessary\n\t\t\t\t\tto set sources dirty, but we want to make sure unattached nodes are covered\n\n\t\t\t\t\tThis should get renderDaemon running again if necessary.\n\t\t\t\t\t*/\n\t\t\t\t\tfor (i = 0; i < nodes.length; i++) {\n\t\t\t\t\t\tnode = nodes[i];\n\t\t\t\t\t\tnode.setDirty();\n\t\t\t\t\t\tnode.emit('webglcontextrestored');\n\t\t\t\t\t}\n\n\t\t\t\t\tSeriously.logger.log('WebGL context restored');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction destroyContext(event) {\n\t\t\t// either webglcontextlost or primary target node has been destroyed\n\t\t\tvar i, node;\n\n\t\t\t/*\n\t\t\ttodo: once multiple shared webgl resources are supported,\n\t\t\tsee if we can switch context to another existing one and\n\t\t\trebuild immediately\n\t\t\t*/\n\n\t\t\tif (event) {\n\t\t\t\tSeriously.logger.warn('WebGL context lost');\n\t\t\t\t/*\n\t\t\t\ttodo: if too many webglcontextlost events fired in too short a time,\n\t\t\t\tdon't preventDefault\n\t\t\t\t*/\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\n\t\t\t//don't draw anymore until context is restored\n\t\t\tif (rafId) {\n\t\t\t\tcancelAnimFrame(rafId);\n\t\t\t\trafId = 0;\n\t\t\t}\n\n\t\t\tif (glCanvas) {\n\t\t\t\tglCanvas.removeEventListener('webglcontextlost', destroyContext, false);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < effects.length; i++) {\n\t\t\t\tnode = effects[i];\n\t\t\t\tnode.gl = null;\n\t\t\t\tnode.initialized = false;\n\t\t\t\tnode.baseShader = null;\n\t\t\t\tnode.model = null;\n\t\t\t\tnode.frameBuffer = null;\n\t\t\t\tnode.texture = null;\n\t\t\t\tif (node.shader && node.shader.destroy) {\n\t\t\t\t\tnode.shader.destroy();\n\t\t\t\t\tif (node.effect.commonShader) {\n\t\t\t\t\t\tdelete commonShaders[node.hook];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnode.shaderDirty = true;\n\t\t\t\tnode.shader = null;\n\t\t\t\tif (node.effect.lostContext) {\n\t\t\t\t\tnode.effect.lostContext.call(node);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\ttodo: do we need to set nodes to uready?\n\t\t\t\tif so, make sure nodes never get set to ready unless gl exists\n\t\t\t\tand make sure to set ready again when context is restored\n\t\t\t\t*/\n\n\t\t\t\tif (event) {\n\t\t\t\t\tnode.emit('webglcontextlost');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < sources.length; i++) {\n\t\t\t\tnode = sources[i];\n\t\t\t\t//node.setUnready();\n\t\t\t\tnode.texture = null;\n\t\t\t\tnode.initialized = false;\n\t\t\t\tnode.allowRefresh = false;\n\t\t\t\tif (event) {\n\t\t\t\t\tnode.emit('webglcontextlost');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < transforms.length; i++) {\n\t\t\t\tnode = transforms[i];\n\t\t\t\tnode.frameBuffer = null;\n\t\t\t\tnode.texture = null;\n\t\t\t\tif (event) {\n\t\t\t\t\tnode.emit('webglcontextlost');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targets.length; i++) {\n\t\t\t\tnode = targets[i];\n\t\t\t\tnode.model = false;\n\t\t\t\tnode.frameBuffer = null;\n\t\t\t\t//texture?\n\t\t\t\tif (event) {\n\t\t\t\t\tnode.emit('webglcontextlost');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (baseShader && baseShader.destroy) {\n\t\t\t\tbaseShader.destroy();\n\t\t\t}\n\n\t\t\t//clean up rectangleModel\n\t\t\tif (gl) {\n\t\t\t\tgl.deleteBuffer(rectangleModel.vertex);\n\t\t\t\tgl.deleteBuffer(rectangleModel.texCoord);\n\t\t\t\tgl.deleteBuffer(rectangleModel.index);\n\t\t\t}\n\n\t\t\tif (rectangleModel) {\n\t\t\t\tdelete rectangleModel.vertex;\n\t\t\t\tdelete rectangleModel.texCoord;\n\t\t\t\tdelete rectangleModel.index;\n\t\t\t}\n\n\t\t\trectangleModel = null;\n\t\t\tbaseShader = null;\n\t\t\tgl = null;\n\t\t\tglCanvas = null;\n\t\t}\n\n\t\t/*\n\t\truns on every frame, as long as there are media sources (img, video, canvas, etc.) to check,\n\t\tdirty target nodes or pre/post callbacks to run. any sources that are updated are set to dirty,\n\t\tforcing all dependent nodes to render\n\t\t*/\n\t\tfunction renderDaemon(now) {\n\t\t\tvar i, node,\n\t\t\t\tkeepRunning = false;\n\n\t\t\trafId = 0;\n\n\t\t\tif (preCallbacks.length) {\n\t\t\t\tkeepRunning = true;\n\t\t\t\tfor (i = 0; i < preCallbacks.length; i++) {\n\t\t\t\t\tpreCallbacks[i].call(seriously, now);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sources && sources.length) {\n\t\t\t\tkeepRunning = true;\n\t\t\t\tfor (i = 0; i < sources.length; i++) {\n\t\t\t\t\tnode = sources[i];\n\n\t\t\t\t\tif (node.dirty ||\n\t\t\t\t\t\t\tnode.checkDirty && node.checkDirty()) {\n\t\t\t\t\t\tnode.dirty = false;\n\t\t\t\t\t\tnode.setDirty();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targets.length; i++) {\n\t\t\t\tnode = targets[i];\n\t\t\t\tif (node.auto && node.dirty) {\n\t\t\t\t\tnode.render();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (postCallbacks.length) {\n\t\t\t\tkeepRunning = true;\n\t\t\t\tfor (i = 0; i < postCallbacks.length; i++) {\n\t\t\t\t\tpostCallbacks[i].call(seriously);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//rafId may have been set again by a callback or in target.setDirty()\n\t\t\tif (keepRunning && !rafId) {\n\t\t\t\trafId = requestAnimationFrame(renderDaemon);\n\t\t\t}\n\t\t}\n\n\t\tfunction draw(shader, model, uniforms, frameBuffer, node, options) {\n\t\t\tvar numTextures = 0,\n\t\t\t\tname, value, shaderUniform,\n\t\t\t\twidth, height,\n\t\t\t\tnodeGl = (node && node.gl) || gl,\n\t\t\t\tsrcRGB, srcAlpha,\n\t\t\t\tdstRGB, dstAlpha;\n\n\t\t\tif (!nodeGl) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (node) {\n\t\t\t\twidth = options && options.width || node.width || nodeGl.canvas.width;\n\t\t\t\theight = options && options.height || node.height || nodeGl.canvas.height;\n\t\t\t} else {\n\t\t\t\twidth = options && options.width || nodeGl.canvas.width;\n\t\t\t\theight = options && options.height || nodeGl.canvas.height;\n\t\t\t}\n\n\t\t\tshader.use();\n\n\t\t\tnodeGl.viewport(0, 0, width, height);\n\n\t\t\tnodeGl.bindFramebuffer(nodeGl.FRAMEBUFFER, frameBuffer);\n\n\t\t\t/* todo: do this all only once at the beginning, since we only have one model? */\n\t\t\tnodeGl.enableVertexAttribArray(shader.location.position);\n\t\t\tnodeGl.enableVertexAttribArray(shader.location.texCoord);\n\n\t\t\tif (model.texCoord) {\n\t\t\t\tnodeGl.bindBuffer(nodeGl.ARRAY_BUFFER, model.texCoord);\n\t\t\t\tnodeGl.vertexAttribPointer(shader.location.texCoord, model.texCoord.size, nodeGl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tnodeGl.bindBuffer(nodeGl.ARRAY_BUFFER, model.vertex);\n\t\t\tnodeGl.vertexAttribPointer(shader.location.position, model.vertex.size, nodeGl.FLOAT, false, 0, 0);\n\n\t\t\tnodeGl.bindBuffer(nodeGl.ELEMENT_ARRAY_BUFFER, model.index);\n\n\t\t\t//default for depth is disable\n\t\t\tif (options && options.depth) {\n\t\t\t\tgl.enable(gl.DEPTH_TEST);\n\t\t\t} else {\n\t\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\t}\n\n\t\t\t//default for blend is enabled\n\t\t\tif (!options) {\n\t\t\t\tgl.enable(gl.BLEND);\n\t\t\t\tgl.blendFunc(\n\t\t\t\t\tgl.ONE,\n\t\t\t\t\tgl.ZERO\n\t\t\t\t);\n\t\t\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\t\t} else if (options.blend === undefined || options.blend) {\n\t\t\t\tgl.enable(gl.BLEND);\n\n\t\t\t\tsrcRGB = options.srcRGB === undefined ? gl.ONE : options.srcRGB;\n\t\t\t\tdstRGB = options.dstRGB || gl.ZERO;\n\t\t\t\tsrcAlpha = options.srcAlpha === undefined ? srcRGB : options.srcAlpha;\n\t\t\t\tdstAlpha = options.dstAlpha === undefined ? dstRGB : options.dstAlpha;\n\n\t\t\t\tgl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);\n\t\t\t\tgl.blendEquation(options.blendEquation || gl.FUNC_ADD);\n\t\t\t} else {\n\t\t\t\tgl.disable(gl.BLEND);\n\t\t\t}\n\n\t\t\t/* set uniforms to current values */\n\t\t\tfor (name in uniforms) {\n\t\t\t\tif (uniforms.hasOwnProperty(name)) {\n\t\t\t\t\tvalue = uniforms[name];\n\t\t\t\t\tshaderUniform = shader.uniforms[name];\n\t\t\t\t\tif (shaderUniform) {\n\t\t\t\t\t\tif (isInstance(value, 'WebGLTexture')) {\n\t\t\t\t\t\t\tnodeGl.activeTexture(nodeGl.TEXTURE0 + numTextures);\n\t\t\t\t\t\t\tnodeGl.bindTexture(nodeGl.TEXTURE_2D, value);\n\t\t\t\t\t\t\tshaderUniform.set(numTextures);\n\t\t\t\t\t\t\tnumTextures++;\n\t\t\t\t\t\t} else if (value instanceof SourceNode ||\n\t\t\t\t\t\t\t\tvalue instanceof EffectNode ||\n\t\t\t\t\t\t\t\tvalue instanceof TransformNode) {\n\t\t\t\t\t\t\tif (value.texture) {\n\t\t\t\t\t\t\t\tnodeGl.activeTexture(nodeGl.TEXTURE0 + numTextures);\n\t\t\t\t\t\t\t\tnodeGl.bindTexture(nodeGl.TEXTURE_2D, value.texture);\n\t\t\t\t\t\t\t\tshaderUniform.set(numTextures);\n\t\t\t\t\t\t\t\tnumTextures++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(value !== undefined && value !== null) {\n\t\t\t\t\t\t\tshaderUniform.set(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//default for clear is true\n\t\t\tif (!options || options.clear === undefined || options.clear) {\n\t\t\t\tnodeGl.clearColor(0.0, 0.0, 0.0, 0.0);\n\t\t\t\tnodeGl.clear(nodeGl.COLOR_BUFFER_BIT | nodeGl.DEPTH_BUFFER_BIT);\n\t\t\t}\n\n\t\t\t// draw!\n\t\t\tnodeGl.drawElements(model.mode, model.length, nodeGl.UNSIGNED_SHORT, 0);\n\n\t\t\t//to protect other 3D libraries that may not remember to turn their depth tests on\n\t\t\tgl.enable(gl.DEPTH_TEST);\n\t\t}\n\n\t\tfunction findInputNode(hook, source, options) {\n\t\t\tvar node, i;\n\n\t\t\tif (typeof hook !== 'string' || !source && source !== 0) {\n\t\t\t\tif (!options || typeof options !== 'object') {\n\t\t\t\t\toptions = source;\n\t\t\t\t}\n\t\t\t\tsource = hook;\n\t\t\t}\n\n\t\t\tif (typeof hook !== 'string' || !seriousSources[hook]) {\n\t\t\t\thook = null;\n\t\t\t}\n\n\t\t\tif (source instanceof SourceNode ||\n\t\t\t\t\tsource instanceof EffectNode ||\n\t\t\t\t\tsource instanceof TransformNode) {\n\t\t\t\tnode = source;\n\t\t\t} else if (source instanceof Effect ||\n\t\t\t\t\tsource instanceof Source ||\n\t\t\t\t\tsource instanceof Transform) {\n\t\t\t\tnode = nodesById[source.id];\n\n\t\t\t\tif (!node) {\n\t\t\t\t\tthrow new Error('Cannot connect a foreign node');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (typeof source === 'string' && isNaN(source)) {\n\t\t\t\t\tsource = getElement(source, ['canvas', 'img', 'video']);\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < sources.length; i++) {\n\t\t\t\t\tnode = sources[i];\n\t\t\t\t\tif ((!hook || hook === node.hook) && node.compare && node.compare(source, options)) {\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnode = new SourceNode(hook, source, options);\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\n\t\t//trace back all sources to make sure we're not making a cyclical connection\n\t\tfunction traceSources(node, original) {\n\t\t\tvar i,\n\t\t\t\tsource,\n\t\t\t\tnodeSources;\n\n\t\t\tif (!(node instanceof EffectNode) && !(node instanceof TransformNode)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (node === original) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tnodeSources = node.sources;\n\n\t\t\tfor (i in nodeSources) {\n\t\t\t\tif (nodeSources.hasOwnProperty(i)) {\n\t\t\t\t\tsource = nodeSources[i];\n\n\t\t\t\t\tif (source === original || traceSources(source, original)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tNode = function () {\n\t\t\tthis.ready = false;\n\t\t\tthis.width = 1;\n\t\t\tthis.height = 1;\n\n\t\t\tthis.gl = gl;\n\n\t\t\tthis.uniforms = {\n\t\t\t\tresolution: [this.width, this.height],\n\t\t\t\ttransform: null\n\t\t\t};\n\n\t\t\tthis.dirty = true;\n\t\t\tthis.isDestroyed = false;\n\n\t\t\tthis.seriously = seriously;\n\n\t\t\tthis.listeners = {};\n\n\t\t\tthis.id = nodeId;\n\t\t\tnodeId++;\n\t\t};\n\n\t\tNode.prototype.setReady = function () {\n\t\t\tvar i;\n\n\t\t\tif (!this.ready) {\n\t\t\t\tthis.ready = true;\n\t\t\t\tthis.emit('ready');\n\t\t\t\tif (this.targets) {\n\t\t\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\t\t\tthis.targets[i].setReady();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tNode.prototype.setUnready = function () {\n\t\t\tvar i;\n\n\t\t\tif (this.ready) {\n\t\t\t\tthis.ready = false;\n\t\t\t\tthis.emit('unready');\n\t\t\t\tif (this.targets) {\n\t\t\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\t\t\tthis.targets[i].setUnready();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tNode.prototype.setDirty = function () {\n\t\t\t//loop through all targets calling setDirty (depth-first)\n\t\t\tvar i;\n\n\t\t\tif (!this.dirty) {\n\t\t\t\tthis.emit('dirty');\n\t\t\t\tthis.dirty = true;\n\t\t\t\tif (this.targets) {\n\t\t\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\t\t\tthis.targets[i].setDirty();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tNode.prototype.initFrameBuffer = function (useFloat) {\n\t\t\tif (gl) {\n\t\t\t\tthis.frameBuffer = new FrameBuffer(gl, this.width, this.height, useFloat);\n\t\t\t}\n\t\t};\n\n\t\tNode.prototype.readPixels = function (x, y, width, height, dest) {\n\t\t\tvar nodeGl = this.gl || gl;\n\n\t\t\tif (!gl) {\n\t\t\t\t//todo: is this the best approach?\n\t\t\t\tthrow new Error('Cannot read pixels until a canvas is connected');\n\t\t\t}\n\n\t\t\t//todo: check on x, y, width, height\n\n\t\t\tif (!this.frameBuffer) {\n\t\t\t\tthis.initFrameBuffer();\n\t\t\t\tthis.setDirty();\n\t\t\t}\n\n\t\t\t//todo: should we render here?\n\t\t\tthis.render();\n\n\t\t\t//todo: figure out formats and types\n\t\t\tif (dest === undefined) {\n\t\t\t\tdest = new Uint8Array(width * height * 4);\n\t\t\t} else if (!(isInstance(dest, 'Uint8Array'))) {\n\t\t\t\tthrow new Error('Incompatible array type');\n\t\t\t}\n\n\t\t\tnodeGl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer.frameBuffer);\n\t\t\tnodeGl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, dest);\n\n\t\t\treturn dest;\n\t\t};\n\n\t\tNode.prototype.resize = function () {\n\t\t\tvar width,\n\t\t\t\theight;\n\n\t\t\tif (this.source) {\n\t\t\t\twidth = this.source.width;\n\t\t\t\theight = this.source.height;\n\t\t\t} else if (this.sources && this.sources.source) {\n\t\t\t\twidth = this.sources.source.width;\n\t\t\t\theight = this.sources.source.height;\n\t\t\t} else if (this.inputs && this.inputs.width) {\n\t\t\t\twidth = this.inputs.width;\n\t\t\t\theight = this.inputs.height || width;\n\t\t\t} else if (this.inputs && this.inputs.height) {\n\t\t\t\twidth = height = this.inputs.height;\n\t\t\t} else {\n\t\t\t\t//this node will be responsible for calculating its own size\n\t\t\t\twidth = 1;\n\t\t\t\theight = 1;\n\t\t\t}\n\n\t\t\twidth = Math.floor(width);\n\t\t\theight = Math.floor(height);\n\n\t\t\tif (this.width !== width || this.height !== height) {\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tthis.emit('resize');\n\t\t\t\tthis.setDirty();\n\t\t\t}\n\n\t\t\tif (this.uniforms && this.uniforms.resolution) {\n\t\t\t\tthis.uniforms.resolution[0] = width;\n\t\t\t\tthis.uniforms.resolution[1] = height;\n\t\t\t}\n\n\t\t\tif (this.frameBuffer && this.frameBuffer.resize) {\n\t\t\t\tthis.frameBuffer.resize(width, height);\n\t\t\t}\n\t\t};\n\n\t\tNode.prototype.on = function (eventName, callback) {\n\t\t\tvar listeners,\n\t\t\t\tindex = -1;\n\n\t\t\tif (!eventName || typeof callback !== 'function') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlisteners = this.listeners[eventName];\n\t\t\tif (listeners) {\n\t\t\t\tindex = listeners.indexOf(callback);\n\t\t\t} else {\n\t\t\t\tlisteners = this.listeners[eventName] = [];\n\t\t\t}\n\n\t\t\tif (index < 0) {\n\t\t\t\tlisteners.push(callback);\n\t\t\t}\n\t\t};\n\n\t\tNode.prototype.off = function (eventName, callback) {\n\t\t\tvar listeners,\n\t\t\t\tindex = -1;\n\n\t\t\tif (!eventName || typeof callback !== 'function') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlisteners = this.listeners[eventName];\n\t\t\tif (listeners) {\n\t\t\t\tindex = listeners.indexOf(callback);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tlisteners.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tNode.prototype.emit = function (eventName) {\n\t\t\tvar i,\n\t\t\t\tlisteners = this.listeners[eventName];\n\n\t\t\tif (listeners && listeners.length) {\n\t\t\t\tfor (i = 0; i < listeners.length; i++) {\n\t\t\t\t\tsetTimeoutZero(listeners[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tNode.prototype.destroy = function () {\n\t\t\tvar i,\n\t\t\t\tkey;\n\n\t\t\tdelete this.gl;\n\t\t\tdelete this.seriously;\n\n\t\t\t//remove all listeners\n\t\t\tfor (key in this.listeners) {\n\t\t\t\tif (this.listeners.hasOwnProperty(key)) {\n\t\t\t\t\tdelete this.listeners[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//clear out uniforms\n\t\t\tfor (i in this.uniforms) {\n\t\t\t\tif (this.uniforms.hasOwnProperty(i)) {\n\t\t\t\t\tdelete this.uniforms[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//clear out list of targets and disconnect each\n\t\t\tif (this.targets) {\n\t\t\t\tdelete this.targets;\n\t\t\t}\n\n\t\t\t//clear out frameBuffer\n\t\t\tif (this.frameBuffer && this.frameBuffer.destroy) {\n\t\t\t\tthis.frameBuffer.destroy();\n\t\t\t\tdelete this.frameBuffer;\n\t\t\t}\n\n\t\t\t//remove from main nodes index\n\t\t\ti = nodes.indexOf(this);\n\t\t\tif (i >= 0) {\n\t\t\t\tnodes.splice(i, 1);\n\t\t\t}\n\t\t\tdelete nodesById[this.id];\n\n\t\t\tthis.isDestroyed = true;\n\t\t};\n\n\t\tEffect = function (effectNode) {\n\t\t\tvar name, me = effectNode;\n\n\t\t\tfunction setInput(inputName, input) {\n\t\t\t\tvar lookup, value, effectInput, i;\n\n\t\t\t\teffectInput = me.effect.inputs[inputName];\n\n\t\t\t\tlookup = me.inputElements[inputName];\n\n\t\t\t\tif (typeof input === 'string' && isNaN(input)) {\n\t\t\t\t\tif (effectInput.type === 'enum') {\n\t\t\t\t\t\tif (!effectInput.options.hasOwnProperty(input)) {\n\t\t\t\t\t\t\tinput = getElement(input, ['select']);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (effectInput.type === 'number' || effectInput.type === 'boolean') {\n\t\t\t\t\t\tinput = getElement(input, ['input', 'select']);\n\t\t\t\t\t} else if (effectInput.type === 'image') {\n\t\t\t\t\t\tinput = getElement(input, ['canvas', 'img', 'video']);\n\t\t\t\t\t}\n\t\t\t\t\t//todo: color? date/time?\n\t\t\t\t}\n\n\t\t\t\tif (isInstance(input, 'HTMLInputElement') || isInstance(input, 'HTMLSelectElement')) {\n\t\t\t\t\tvalue = input.value;\n\n\t\t\t\t\tif (lookup && lookup.element !== input) {\n\t\t\t\t\t\tlookup.element.removeEventListener('change', lookup.listener, true);\n\t\t\t\t\t\tlookup.element.removeEventListener('input', lookup.listener, true);\n\t\t\t\t\t\tdelete me.inputElements[inputName];\n\t\t\t\t\t\tlookup = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!lookup) {\n\t\t\t\t\t\tlookup = {\n\t\t\t\t\t\t\telement: input,\n\t\t\t\t\t\t\tlistener: (function (name, element) {\n\t\t\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\t\t\tvar oldValue, newValue;\n\n\t\t\t\t\t\t\t\t\tif (input.type === 'checkbox') {\n\t\t\t\t\t\t\t\t\t\t//special case for check box\n\t\t\t\t\t\t\t\t\t\toldValue = input.checked;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\toldValue = element.value;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnewValue = me.setInput(name, oldValue);\n\n\t\t\t\t\t\t\t\t\t//special case for color type\n\t\t\t\t\t\t\t\t\tif (effectInput.type === 'color') {\n\t\t\t\t\t\t\t\t\t\tnewValue = colorArrayToHex(newValue).substr(0, 7);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//if input validator changes our value, update HTML Element\n\t\t\t\t\t\t\t\t\t//todo: make this optional...somehow\n\t\t\t\t\t\t\t\t\tif (newValue !== oldValue) {\n\t\t\t\t\t\t\t\t\t\telement.value = newValue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}(inputName, input))\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tme.inputElements[inputName] = lookup;\n\t\t\t\t\t\tif (input.type === 'range') {\n\t\t\t\t\t\t\tinput.addEventListener('input', lookup.listener, true);\n\t\t\t\t\t\t\tinput.addEventListener('change', lookup.listener, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinput.addEventListener('change', lookup.listener, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lookup && input.type === 'checkbox') {\n\t\t\t\t\t\tvalue = input.checked;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (lookup) {\n\t\t\t\t\t\tlookup.element.removeEventListener('change', lookup.listener, true);\n\t\t\t\t\t\tlookup.element.removeEventListener('input', lookup.listener, true);\n\t\t\t\t\t\tdelete me.inputElements[inputName];\n\t\t\t\t\t}\n\t\t\t\t\tvalue = input;\n\t\t\t\t}\n\n\t\t\t\tme.setInput(inputName, value);\n\t\t\t\treturn me.inputs[inputName];\n\t\t\t}\n\n\t\t\tfunction makeImageSetter(inputName) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\tvar val = setInput(inputName, value);\n\t\t\t\t\treturn val && val.pub;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction makeImageGetter(inputName) {\n\t\t\t\treturn function () {\n\t\t\t\t\tvar val = me.inputs[inputName];\n\t\t\t\t\treturn val && val.pub;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction makeSetter(inputName) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\treturn setInput(inputName, value);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction makeGetter(inputName) {\n\t\t\t\treturn function () {\n\t\t\t\t\treturn me.inputs[inputName];\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t//priveleged publicly accessible methods/setters/getters\n\t\t\t//todo: provide alternate set/get methods\n\t\t\tfor (name in me.effect.inputs) {\n\t\t\t\tif (me.effect.inputs.hasOwnProperty(name)) {\n\t\t\t\t\tif (this[name] === undefined) {\n\t\t\t\t\t\tif (me.effect.inputs[name].type === 'image') {\n\t\t\t\t\t\t\tObject.defineProperty(this, name, {\n\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\tget: makeImageGetter(name),\n\t\t\t\t\t\t\t\tset: makeImageSetter(name)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tObject.defineProperty(this, name, {\n\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\tget: makeGetter(name),\n\t\t\t\t\t\t\t\tset: makeSetter(name)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//todo: this is temporary. get rid of it.\n\t\t\t\t\t\tthrow new Error('Cannot overwrite Seriously.' + name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject.defineProperties(this, {\n\t\t\t\teffect: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.hook;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\ttitle: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.effect.title || me.hook;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\twidth: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.width;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\theight: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.height;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tid: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.render = function () {\n\t\t\t\tme.render();\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.readPixels = function (x, y, width, height, dest) {\n\t\t\t\treturn me.readPixels(x, y, width, height, dest);\n\t\t\t};\n\n\t\t\tthis.on = function (eventName, callback) {\n\t\t\t\tme.on(eventName, callback);\n\t\t\t};\n\n\t\t\tthis.off = function (eventName, callback) {\n\t\t\t\tme.off(eventName, callback);\n\t\t\t};\n\n\t\t\tthis.inputs = function (name) {\n\t\t\t\tvar result,\n\t\t\t\t\tinput,\n\t\t\t\t\tinputs,\n\t\t\t\t\ti,\n\t\t\t\t\tkey;\n\n\t\t\t\tinputs = me.effect.inputs;\n\n\t\t\t\tif (name) {\n\t\t\t\t\tinput = inputs[name];\n\t\t\t\t\tif (!input) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = {\n\t\t\t\t\t\ttype: input.type,\n\t\t\t\t\t\tdefaultValue: input.defaultValue,\n\t\t\t\t\t\ttitle: input.title || name\n\t\t\t\t\t};\n\n\t\t\t\t\tif (input.type === 'number') {\n\t\t\t\t\t\tresult.min = input.min;\n\t\t\t\t\t\tresult.max = input.max;\n\t\t\t\t\t\tresult.step = input.step;\n\t\t\t\t\t\tresult.mod = input.mod;\n\t\t\t\t\t} else if (input.type === 'enum') {\n\t\t\t\t\t\t//make a copy\n\t\t\t\t\t\tresult.options = extend({}, input.options);\n\t\t\t\t\t} else if (input.type === 'vector') {\n\t\t\t\t\t\tresult.dimensions = input.dimensions;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (input.description) {\n\t\t\t\t\t\tresult.description = input.description;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tresult = {};\n\t\t\t\tfor (key in inputs) {\n\t\t\t\t\tif (inputs.hasOwnProperty(key)) {\n\t\t\t\t\t\tresult[key] = this.inputs(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\n\t\t\tthis.alias = function (inputName, aliasName) {\n\t\t\t\tme.alias(inputName, aliasName);\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.matte = function (polygons) {\n\t\t\t\tme.matte(polygons);\n\t\t\t};\n\n\t\t\tthis.destroy = function () {\n\t\t\t\tvar i,\n\t\t\t\t\tdescriptor;\n\n\t\t\t\tme.destroy();\n\n\t\t\t\tfor (i in this) {\n\t\t\t\t\tif (this.hasOwnProperty(i) && i !== 'isDestroyed' && i !== 'id') {\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(this, i);\n\t\t\t\t\t\tif (descriptor.get || descriptor.set ||\n\t\t\t\t\t\t\t\ttypeof this[i] !== 'function') {\n\t\t\t\t\t\t\tdelete this[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis[i] = nop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.isDestroyed = function () {\n\t\t\t\treturn me.isDestroyed;\n\t\t\t};\n\n\t\t\tthis.isReady = function () {\n\t\t\t\treturn me.ready;\n\t\t\t};\n\t\t};\n\n\t\tEffectNode = function (hook, options) {\n\t\t\tvar key, name, input,\n\t\t\t\tdefaultValue,\n\t\t\t\tdefaults,\n\t\t\t\tdefaultSources = {};\n\n\t\t\tNode.call(this, options);\n\t\t\tthis.gl = gl;\n\n\t\t\tthis.effectRef = seriousEffects[hook];\n\t\t\tthis.sources = {};\n\t\t\tthis.targets = [];\n\t\t\tthis.inputElements = {};\n\t\t\tthis.dirty = true;\n\t\t\tthis.shaderDirty = true;\n\t\t\tthis.hook = hook;\n\t\t\tthis.options = options;\n\t\t\tthis.transform = null;\n\n\t\t\tthis.effect = extend({}, this.effectRef);\n\t\t\tif (this.effectRef.definition) {\n\t\t\t\t/*\n\t\t\t\ttodo: copy over inputs object separately in case some are specified\n\t\t\t\tin advance and some are specified in definition function\n\t\t\t\t*/\n\t\t\t\textend(this.effect, this.effectRef.definition.call(this, options));\n\t\t\t}\n\t\t\tvalidateInputSpecs(this.effect);\n\n\t\t\tthis.uniforms.transform = identity;\n\t\t\tthis.inputs = {};\n\t\t\tdefaults = defaultInputs[hook];\n\t\t\tfor (name in this.effect.inputs) {\n\t\t\t\tif (this.effect.inputs.hasOwnProperty(name)) {\n\t\t\t\t\tinput = this.effect.inputs[name];\n\n\t\t\t\t\tif (input.defaultValue === undefined || input.defaultValue === null) {\n\t\t\t\t\t\tif (input.type === 'number') {\n\t\t\t\t\t\t\tinput.defaultValue = Math.min(Math.max(0, input.min), input.max);\n\t\t\t\t\t\t} else if (input.type === 'color') {\n\t\t\t\t\t\t\tinput.defaultValue = [0, 0, 0, 0];\n\t\t\t\t\t\t} else if (input.type === 'boolean') {\n\t\t\t\t\t\t\tinput.defaultValue = false;\n\t\t\t\t\t\t} else if (input.type === 'string') {\n\t\t\t\t\t\t\tinput.defaultValue = '';\n\t\t\t\t\t\t} else if (input.type === 'enum') {\n\t\t\t\t\t\t\tinput.defaultValue = input.firstValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdefaultValue = input.validate.call(this, input.defaultValue, input);\n\t\t\t\t\tif (defaults && defaults[name] !== undefined) {\n\t\t\t\t\t\tdefaultValue = input.validate.call(this, defaults[name], input, input.defaultValue, defaultValue);\n\t\t\t\t\t\tdefaults[name] = defaultValue;\n\t\t\t\t\t\tif (input.type === 'image') {\n\t\t\t\t\t\t\tdefaultSources[name] = defaultValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.inputs[name] = defaultValue;\n\t\t\t\t\tif (input.uniform) {\n\t\t\t\t\t\tthis.uniforms[input.uniform] = input.defaultValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (gl) {\n\t\t\t\tthis.initialize();\n\t\t\t\tif (this.effect.commonShader) {\n\t\t\t\t\t/*\n\t\t\t\t\tthis effect is unlikely to need to be modified again\n\t\t\t\t\tby changing parameters, so build it now to avoid jank later\n\t\t\t\t\t*/\n\t\t\t\t\tthis.buildShader();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateReady();\n\t\t\tthis.inPlace = this.effect.inPlace;\n\n\t\t\tthis.pub = new Effect(this);\n\n\t\t\tnodes.push(this);\n\t\t\tnodesById[this.id] = this;\n\t\t\teffects.push(this);\n\n\t\t\tallEffectsByHook[hook].push(this);\n\n\t\t\tfor (name in defaultSources) {\n\t\t\t\tif (defaultSources.hasOwnProperty(name)) {\n\t\t\t\t\tthis.setInput(name, defaultSources[name]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tEffectNode.prototype = Object.create(Node.prototype);\n\t\tEffectNode.prototype.constructor = EffectNode;\n\n\t\tEffectNode.prototype.initialize = function () {\n\t\t\tif (!this.initialized) {\n\t\t\t\tvar that = this;\n\n\t\t\t\tthis.baseShader = baseShader;\n\n\t\t\t\tif (this.shape) {\n\t\t\t\t\tthis.model = makeGlModel(this.shape, this.gl);\n\t\t\t\t} else {\n\t\t\t\t\tthis.model = rectangleModel;\n\t\t\t\t}\n\n\t\t\t\tif (typeof this.effect.initialize === 'function') {\n\t\t\t\t\tthis.effect.initialize.call(this, function () {\n\t\t\t\t\t\tthat.initFrameBuffer(true);\n\t\t\t\t\t}, gl);\n\t\t\t\t} else {\n\t\t\t\t\tthis.initFrameBuffer(true);\n\t\t\t\t}\n\n\t\t\t\tif (this.frameBuffer) {\n\t\t\t\t\tthis.texture = this.frameBuffer.texture;\n\t\t\t\t}\n\n\t\t\t\tthis.initialized = true;\n\t\t\t}\n\t\t};\n\n\t\tEffectNode.prototype.resize = function () {\n\t\t\tvar i;\n\n\t\t\tNode.prototype.resize.call(this);\n\n\t\t\tif (this.effect.resize) {\n\t\t\t\tthis.effect.resize.call(this);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\tthis.targets[i].resize();\n\t\t\t}\n\t\t};\n\n\t\tEffectNode.prototype.updateReady = function () {\n\t\t\tvar i,\n\t\t\t\tinput,\n\t\t\t\tkey,\n\t\t\t\teffect,\n\t\t\t\tready = true,\n\t\t\t\tmethod;\n\n\t\t\teffect = this.effect;\n\t\t\tfor (key in effect.inputs) {\n\t\t\t\tif (effect.inputs.hasOwnProperty(key)) {\n\t\t\t\t\tinput = this.effect.inputs[key];\n\t\t\t\t\tif (input.type === 'image' &&\n\t\t\t\t\t\t\t(!this.sources[key] || !this.sources[key].ready) &&\n\t\t\t\t\t\t\t(!effect.requires || effect.requires.call(this, key, this.inputs))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\tready = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.ready !== ready) {\n\t\t\t\tthis.ready = ready;\n\t\t\t\tthis.emit(ready ? 'ready' : 'unready');\n\t\t\t\tmethod = ready ? 'setReady' : 'setUnready';\n\n\t\t\t\tif (this.targets) {\n\t\t\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\t\t\tthis.targets[i][method]();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tEffectNode.prototype.setReady = EffectNode.prototype.updateReady;\n\n\t\tEffectNode.prototype.setUnready = EffectNode.prototype.updateReady;\n\n\t\tEffectNode.prototype.addTarget = function (target) {\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\tif (this.targets[i] === target) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.targets.push(target);\n\t\t};\n\n\t\tEffectNode.prototype.removeTarget = function (target) {\n\t\t\tvar i = this.targets && this.targets.indexOf(target);\n\t\t\tif (i >= 0) {\n\t\t\t\tthis.targets.splice(i, 1);\n\t\t\t}\n\t\t};\n\n\t\tEffectNode.prototype.removeSource = function (source) {\n\t\t\tvar i, pub = source && source.pub;\n\n\t\t\tfor (i in this.inputs) {\n\t\t\t\tif (this.inputs.hasOwnProperty(i) &&\n\t\t\t\t\t(this.inputs[i] === source || this.inputs[i] === pub)) {\n\t\t\t\t\tthis.inputs[i] = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i in this.sources) {\n\t\t\t\tif (this.sources.hasOwnProperty(i) &&\n\t\t\t\t\t(this.sources[i] === source || this.sources[i] === pub)) {\n\t\t\t\t\tthis.sources[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tEffectNode.prototype.buildShader = function () {\n\t\t\tvar shader,\n\t\t\t\teffect = this.effect,\n\t\t\t\tme = this;\n\n\t\t\tfunction addShaderName(shaderSrc) {\n\t\t\t\tif (shaderNameRegex.test(shaderSrc)) {\n\t\t\t\t\treturn shaderSrc;\n\t\t\t\t}\n\n\t\t\t\treturn '#define SHADER_NAME seriously.' + me.hook + '\\n' +\n\t\t\t\t\tshaderSrc;\n\t\t\t}\n\n\t\t\tif (this.shaderDirty) {\n\t\t\t\tif (effect.commonShader && commonShaders[this.hook]) {\n\t\t\t\t\tif (!this.shader) {\n\t\t\t\t\t\tcommonShaders[this.hook].count++;\n\t\t\t\t\t}\n\t\t\t\t\tthis.shader = commonShaders[this.hook].shader;\n\t\t\t\t} else if (effect.shader) {\n\t\t\t\t\tif (this.shader && !effect.commonShader) {\n\t\t\t\t\t\tthis.shader.destroy();\n\t\t\t\t\t}\n\t\t\t\t\tshader = effect.shader.call(this, this.inputs, {\n\t\t\t\t\t\tvertex: baseVertexShader,\n\t\t\t\t\t\tfragment: baseFragmentShader\n\t\t\t\t\t}, Seriously.util);\n\n\t\t\t\t\tif (shader instanceof ShaderProgram) {\n\t\t\t\t\t\tthis.shader = shader;\n\t\t\t\t\t} else if (shader && shader.vertex && shader.fragment) {\n\t\t\t\t\t\tthis.shader = new ShaderProgram(\n\t\t\t\t\t\t\tgl,\n\t\t\t\t\t\t\taddShaderName(shader.vertex),\n\t\t\t\t\t\t\taddShaderName(shader.fragment)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.shader = baseShader;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (effect.commonShader) {\n\t\t\t\t\t\tcommonShaders[this.hook] = {\n\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\tshader: this.shader\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.shader = baseShader;\n\t\t\t\t}\n\n\t\t\t\tthis.shaderDirty = false;\n\t\t\t}\n\t\t};\n\n\t\tEffectNode.prototype.render = function () {\n\t\t\tvar key,\n\t\t\t\tframeBuffer,\n\t\t\t\teffect = this.effect,\n\t\t\t\tthat = this,\n\t\t\t\tinPlace;\n\n\t\t\tfunction drawFn(shader, model, uniforms, frameBuffer, node, options) {\n\t\t\t\tdraw(shader, model, uniforms, frameBuffer, node || that, options);\n\t\t\t}\n\n\t\t\tif (!gl) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!this.initialized) {\n\t\t\t\tthis.initialize();\n\t\t\t}\n\n\t\t\tif (this.shaderDirty) {\n\t\t\t\tthis.buildShader();\n\t\t\t}\n\n\t\t\tif (this.dirty && this.ready) {\n\t\t\t\tfor (key in this.sources) {\n\t\t\t\t\tif (this.sources.hasOwnProperty(key) &&\n\t\t\t\t\t\t(!effect.requires || effect.requires.call(this, key, this.inputs))) {\n\n\t\t\t\t\t\t//todo: set source texture in case it changes?\n\t\t\t\t\t\t//sourcetexture = this.sources[i].render() || this.sources[i].texture\n\n\t\t\t\t\t\tinPlace = typeof this.inPlace === 'function' ? this.inPlace(key) : this.inPlace;\n\t\t\t\t\t\tthis.sources[key].render(!inPlace);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.frameBuffer) {\n\t\t\t\t\tframeBuffer = this.frameBuffer.frameBuffer;\n\t\t\t\t}\n\n\t\t\t\tif (typeof effect.draw === 'function') {\n\t\t\t\t\teffect.draw.call(this, this.shader, this.model, this.uniforms, frameBuffer, drawFn);\n\t\t\t\t\tthis.emit('render');\n\t\t\t\t} else if (frameBuffer) {\n\t\t\t\t\tdraw(this.shader, this.model, this.uniforms, frameBuffer, this);\n\t\t\t\t\tthis.emit('render');\n\t\t\t\t}\n\n\t\t\t\tthis.dirty = false;\n\t\t\t}\n\n\t\t\treturn this.texture;\n\t\t};\n\n\t\tEffectNode.prototype.setInput = function (name, value) {\n\t\t\tvar input, uniform,\n\t\t\t\tsourceKeys,\n\t\t\t\tsource,\n\t\t\t\tme = this,\n\t\t\t\tdefaultValue;\n\n\t\t\tfunction disconnectSource() {\n\t\t\t\tvar previousSource = me.sources[name],\n\t\t\t\t\tkey;\n\n\t\t\t\t/*\n\t\t\t\tremove this node from targets of previously connected source node,\n\t\t\t\tbut only if the source node is not being used as another input\n\t\t\t\t*/\n\t\t\t\tif (previousSource) {\n\t\t\t\t\tfor (key in me.sources) {\n\t\t\t\t\t\tif (key !== name &&\n\t\t\t\t\t\t\t\tme.sources.hasOwnProperty(key) &&\n\t\t\t\t\t\t\t\tme.sources[key] === previousSource) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpreviousSource.removeTarget(me);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.effect.inputs.hasOwnProperty(name)) {\n\t\t\t\tinput = this.effect.inputs[name];\n\t\t\t\tif (input.type === 'image') {\n\t\t\t\t\t//&& !(value instanceof Effect) && !(value instanceof Source)) {\n\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tvalue = findInputNode(value);\n\n\t\t\t\t\t\tif (value !== this.sources[name]) {\n\t\t\t\t\t\t\tdisconnectSource();\n\n\t\t\t\t\t\t\tif (traceSources(value, this)) {\n\t\t\t\t\t\t\t\tthrow new Error('Attempt to make cyclical connection.');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.sources[name] = value;\n\t\t\t\t\t\t\tvalue.addTarget(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete this.sources[name];\n\t\t\t\t\t\tvalue = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tuniform = this.sources[name];\n\n\t\t\t\t\tsourceKeys = Object.keys(this.sources);\n\t\t\t\t\tif (this.inPlace === true && sourceKeys.length === 1) {\n\t\t\t\t\t\tsource = this.sources[sourceKeys[0]];\n\t\t\t\t\t\tthis.uniforms.transform = source && source.cumulativeMatrix || identity;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.uniforms.transform = identity;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (defaultInputs[this.hook] && defaultInputs[this.hook][name] !== undefined) {\n\t\t\t\t\t\tdefaultValue = defaultInputs[this.hook][name];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdefaultValue = input.defaultValue;\n\t\t\t\t\t}\n\t\t\t\t\tvalue = input.validate.call(this, value, input, defaultValue, this.inputs[name]);\n\t\t\t\t\tuniform = value;\n\t\t\t\t}\n\n\t\t\t\tif (this.inputs[name] === value && input.type !== 'color' && input.type !== 'vector') {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tthis.inputs[name] = value;\n\n\t\t\t\tif (input.uniform) {\n\t\t\t\t\tthis.uniforms[input.uniform] = uniform;\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'image') {\n\t\t\t\t\tthis.resize();\n\t\t\t\t\tthis.updateReady();\n\t\t\t\t} else if (input.updateSources) {\n\t\t\t\t\tthis.updateReady();\n\t\t\t\t}\n\n\t\t\t\tif (input.shaderDirty) {\n\t\t\t\t\tthis.shaderDirty = true;\n\t\t\t\t}\n\n\t\t\t\tthis.setDirty();\n\n\t\t\t\tif (input.update) {\n\t\t\t\t\tinput.update.call(this, value);\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t}\n\t\t};\n\n\t\tEffectNode.prototype.alias = function (inputName, aliasName) {\n\t\t\tvar that = this;\n\n\t\t\tif (reservedNames.indexOf(aliasName) >= 0) {\n\t\t\t\tthrow new Error('\\'' + aliasName + '\\' is a reserved name and cannot be used as an alias.');\n\t\t\t}\n\n\t\t\tif (this.effect.inputs.hasOwnProperty(inputName)) {\n\t\t\t\tif (!aliasName) {\n\t\t\t\t\taliasName = inputName;\n\t\t\t\t}\n\n\t\t\t\tseriously.removeAlias(aliasName);\n\n\t\t\t\taliases[aliasName] = {\n\t\t\t\t\tnode: this,\n\t\t\t\t\tinput: inputName\n\t\t\t\t};\n\n\t\t\t\tObject.defineProperty(seriously, aliasName, {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn that.inputs[inputName];\n\t\t\t\t\t},\n\t\t\t\t\tset: function (value) {\n\t\t\t\t\t\treturn that.setInput(inputName, value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\t/*\n\t\tmatte function to be assigned as a method to EffectNode and TargetNode\n\t\t*/\n\t\tEffectNode.prototype.matte = function (poly) {\n\t\t\tvar polys,\n\t\t\t\tpolygons = [],\n\t\t\t\tpolygon,\n\t\t\t\tvertices = [],\n\t\t\t\ti, j, v,\n\t\t\t\tvert, prev,\n\t\t\t\t//triangles = [],\n\t\t\t\tshape = {};\n\n\t\t\t//detect whether it's multiple polygons or what\n\t\t\tfunction makePolygonsArray(poly) {\n\t\t\t\tif (!poly || !poly.length || !Array.isArray(poly)) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tif (!Array.isArray(poly[0])) {\n\t\t\t\t\treturn [poly];\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(poly[0]) && !isNaN(poly[0][0])) {\n\t\t\t\t\treturn [poly];\n\t\t\t\t}\n\n\t\t\t\treturn poly;\n\t\t\t}\n\n\t\t\tfunction linesIntersect(a1, a2, b1, b2) {\n\t\t\t\tvar ua_t, ub_t, u_b, ua, ub;\n\t\t\t\tua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n\t\t\t\tub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);\n\t\t\t\tu_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\t\t\t\tif (u_b) {\n\t\t\t\t\tua = ua_t / u_b;\n\t\t\t\t\tub = ub_t / u_b;\n\t\t\t\t\tif (ua > 0 && ua <= 1 && ub > 0 && ub <= 1) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tx: a1.x + ua * (a2.x - a1.x),\n\t\t\t\t\t\t\ty: a1.y + ua * (a2.y - a1.y)\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfunction makeSimple(poly) {\n\t\t\t\t/*\n\t\t\t\tthis uses a slow, naive approach to detecting line intersections.\n\t\t\t\tUse Bentley-Ottmann Algorithm\n\t\t\t\tsee: http://softsurfer.com/Archive/algorithm_0108/algorithm_0108.htm#Bentley-Ottmann Algorithm\n\t\t\t\tsee: https://github.com/tokumine/sweepline\n\t\t\t\t*/\n\t\t\t\tvar i, j,\n\t\t\t\t\tedge1, edge2,\n\t\t\t\t\tintersect,\n\t\t\t\t\tintersections = [],\n\t\t\t\t\tnewPoly,\n\t\t\t\t\thead, point,\n\t\t\t\t\tnewPolygons,\n\t\t\t\t\tpoint1, point2;\n\n\t\t\t\tif (poly.simple) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < poly.edges.length; i++) {\n\t\t\t\t\tedge1 = poly.edges[i];\n\t\t\t\t\tfor (j = i + 1; j < poly.edges.length; j++) {\n\t\t\t\t\t\tedge2 = poly.edges[j];\n\t\t\t\t\t\tintersect = linesIntersect(edge1[0], edge1[1], edge2[0], edge2[1]);\n\t\t\t\t\t\tif (intersect) {\n\t\t\t\t\t\t\tintersect.edge1 = edge1;\n\t\t\t\t\t\t\tintersect.edge2 = edge2;\n\t\t\t\t\t\t\tintersections.push(intersect);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (intersections.length) {\n\t\t\t\t\tnewPolygons = [];\n\n\t\t\t\t\tfor (i = 0; i < intersections.length; i++) {\n\t\t\t\t\t\tintersect = intersections[i];\n\t\t\t\t\t\tedge1 = intersect.edge1;\n\t\t\t\t\t\tedge2 = intersect.edge2;\n\n\t\t\t\t\t\t//make new points\n\t\t\t\t\t\t//todo: set ids for points\n\t\t\t\t\t\tpoint1 = {\n\t\t\t\t\t\t\tx: intersect.x,\n\t\t\t\t\t\t\ty: intersect.y,\n\t\t\t\t\t\t\tprev: edge1[0],\n\t\t\t\t\t\t\tnext: edge2[1],\n\t\t\t\t\t\t\tid: vertices.length\n\t\t\t\t\t\t};\n\t\t\t\t\t\tpoly.vertices.push(point1);\n\t\t\t\t\t\tvertices.push(point1);\n\n\t\t\t\t\t\tpoint2 = {\n\t\t\t\t\t\t\tx: intersect.x,\n\t\t\t\t\t\t\ty: intersect.y,\n\t\t\t\t\t\t\tprev: edge2[0],\n\t\t\t\t\t\t\tnext: edge1[1],\n\t\t\t\t\t\t\tid: vertices.length\n\t\t\t\t\t\t};\n\t\t\t\t\t\tpoly.vertices.push(point2);\n\t\t\t\t\t\tvertices.push(point1);\n\n\t\t\t\t\t\t//modify old points\n\t\t\t\t\t\tpoint1.prev.next = point1;\n\t\t\t\t\t\tpoint1.next.prev = point1;\n\t\t\t\t\t\tpoint2.prev.next = point2;\n\t\t\t\t\t\tpoint2.next.prev = point2;\n\n\t\t\t\t\t\t//don't bother modifying the old edges. we're just gonna throw them out\n\t\t\t\t\t}\n\n\t\t\t\t\t//make new polygons\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnewPoly = {\n\t\t\t\t\t\t\tedges: [],\n\t\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\t\tsimple: true\n\t\t\t\t\t\t};\n\t\t\t\t\t\tnewPolygons.push(newPoly);\n\t\t\t\t\t\tpoint = poly.vertices[0];\n\t\t\t\t\t\thead = point;\n\t\t\t\t\t\t//while (point.next !== head && poly.vertices.length) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ti = poly.vertices.indexOf(point);\n\t\t\t\t\t\t\tpoly.vertices.splice(i, 1);\n\t\t\t\t\t\t\tnewPoly.edges.push([point, point.next]);\n\t\t\t\t\t\t\tnewPoly.vertices.push(point);\n\t\t\t\t\t\t\tpoint = point.next;\n\t\t\t\t\t\t} while (point !== head);\n\t\t\t\t\t} while (poly.vertices.length);\n\n\t\t\t\t\t//remove original polygon from list\n\t\t\t\t\ti = polygons.indexOf(poly);\n\t\t\t\t\tpolygons.splice(i, 1);\n\n\t\t\t\t\t//add new polygons to list\n\t\t\t\t\tfor (i = 0; i < newPolygons.length; i++) {\n\t\t\t\t\t\tpolygons.push(newPolygons[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpoly.simple = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction clockWise(poly) {\n\t\t\t\tvar p, q, n = poly.vertices.length,\n\t\t\t\t\tpv, qv, sum = 0;\n\t\t\t\tfor (p = n - 1, q = 0; q < n; p = q, q++) {\n\t\t\t\t\tpv = poly.vertices[p];\n\t\t\t\t\tqv = poly.vertices[q];\n\t\t\t\t\t//sum += (next.x - v.x) * (next.y + v.y);\n\t\t\t\t\t//sum += (v.next.x + v.x) * (v.next.y - v.y);\n\t\t\t\t\tsum += pv.x * qv.y - qv.x * pv.y;\n\t\t\t\t}\n\t\t\t\treturn sum > 0;\n\t\t\t}\n\n\t\t\tfunction triangulate(poly) {\n\t\t\t\tvar v, points = poly.vertices,\n\t\t\t\t\tn, V = [], indices = [],\n\t\t\t\t\tnv, count, m, u, w,\n\n\t\t\t\t\t//todo: give these variables much better names\n\t\t\t\t\ta, b, c, s, t;\n\n\t\t\t\tfunction pointInTriangle(a, b, c, p) {\n\t\t\t\t\tvar ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy,\n\t\t\t\t\t\tcXap, bXcp, aXbp;\n\n\t\t\t\t\tax = c.x - b.x;\n\t\t\t\t\tay = c.y - b.y;\n\t\t\t\t\tbx = a.x - c.x;\n\t\t\t\t\tby = a.y - c.y;\n\t\t\t\t\tcx = b.x - a.x;\n\t\t\t\t\tcy = b.y - a.y;\n\t\t\t\t\tapx = p.x - a.x;\n\t\t\t\t\tapy = p.y - a.y;\n\t\t\t\t\tbpx = p.x - b.x;\n\t\t\t\t\tbpy = p.y - b.y;\n\t\t\t\t\tcpx = p.x - c.x;\n\t\t\t\t\tcpy = p.y - c.y;\n\n\t\t\t\t\taXbp = ax * bpy - ay * bpx;\n\t\t\t\t\tcXap = cx * apy - cy * apx;\n\t\t\t\t\tbXcp = bx * cpy - by * cpx;\n\n\t\t\t\t\treturn aXbp >= 0 && bXcp >=0 && cXap >=0;\n\t\t\t\t}\n\n\t\t\t\tfunction snip(u, v, w, n, V) {\n\t\t\t\t\tvar p, a, b, c, point;\n\t\t\t\t\ta = points[V[u]];\n\t\t\t\t\tb = points[V[v]];\n\t\t\t\t\tc = points[V[w]];\n\t\t\t\t\tif (0 > (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (p = 0; p < n; p++) {\n\t\t\t\t\t\tif (!(p === u || p === v || p === w)) {\n\t\t\t\t\t\t\tpoint = points[V[p]];\n\t\t\t\t\t\t\tif (pointInTriangle(a, b, c, point)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t//copy points\n\t\t\t\t//for (v = 0; v < poly.vertices.length; v++) {\n\t\t\t\t//\tpoints.push(poly.vertices[v]);\n\t\t\t\t//}\n\t\t\t\tn = points.length;\n\n\t\t\t\tif (poly.clockWise) {\n\t\t\t\t\tfor (v = 0; v < n; v++) {\n\t\t\t\t\t\tV[v] = v;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (v = 0; v < n; v++) {\n\t\t\t\t\t\tV[v] = (n - 1) - v;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnv = n;\n\t\t\t\tcount = 2 * nv;\n\t\t\t\tm = 0;\n\t\t\t\tv = nv - 1;\n\t\t\t\twhile (nv > 2) {\n\t\t\t\t\tif ((count--) <= 0) {\n\t\t\t\t\t\treturn indices;\n\t\t\t\t\t}\n\n\t\t\t\t\tu = v;\n\t\t\t\t\tif (nv <= u) {\n\t\t\t\t\t\tu = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tv = u + 1;\n\t\t\t\t\tif (nv <= v) {\n\t\t\t\t\t\tv = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tw = v + 1;\n\t\t\t\t\tif (nv < w) {\n\t\t\t\t\t\tw = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (snip(u, v, w, nv, V)) {\n\t\t\t\t\t\ta = V[u];\n\t\t\t\t\t\tb = V[v];\n\t\t\t\t\t\tc = V[w];\n\t\t\t\t\t\tif (poly.clockWise) {\n\t\t\t\t\t\t\tindices.push(points[a]);\n\t\t\t\t\t\t\tindices.push(points[b]);\n\t\t\t\t\t\t\tindices.push(points[c]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindices.push(points[c]);\n\t\t\t\t\t\t\tindices.push(points[b]);\n\t\t\t\t\t\t\tindices.push(points[a]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tfor (s = v, t = v + 1; t < nv; s++, t++) {\n\t\t\t\t\t\t\tV[s] = V[t];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv--;\n\t\t\t\t\t\tcount = 2 * nv;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpolygon.indices = indices;\n\t\t\t}\n\n\t\t\tpolys = makePolygonsArray(poly);\n\n\t\t\tfor (i = 0; i < polys.length; i++) {\n\t\t\t\tpoly = polys[i];\n\t\t\t\tprev = null;\n\t\t\t\tpolygon = {\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tedges: []\n\t\t\t\t};\n\n\t\t\t\tfor (j = 0; j < poly.length; j++) {\n\t\t\t\t\tv = poly[j];\n\t\t\t\t\tif (typeof v ==='object' && !isNaN(v.x) && !isNaN(v.y)) {\n\t\t\t\t\t\tvert = {\n\t\t\t\t\t\t\tx: v.x,\n\t\t\t\t\t\t\ty: v.y,\n\t\t\t\t\t\t\tid: vertices.length\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (v.length >= 2 && !isNaN(v[0]) && !isNaN(v[1])) {\n\t\t\t\t\t\tvert = {\n\t\t\t\t\t\t\tx: v[0],\n\t\t\t\t\t\t\ty: v[1],\n\t\t\t\t\t\t\tid: vertices.length\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (vert) {\n\t\t\t\t\t\tif (prev) {\n\t\t\t\t\t\t\tprev.next = vert;\n\t\t\t\t\t\t\tvert.prev = prev;\n\t\t\t\t\t\t\tvert.next = polygon.vertices[0];\n\t\t\t\t\t\t\tpolygon.vertices[0].prev = vert;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpolygon.head = vert;\n\t\t\t\t\t\t\tvert.next = vert;\n\t\t\t\t\t\t\tvert.prev = vert;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvertices.push(vert);\n\t\t\t\t\t\tpolygon.vertices.push(vert);\n\t\t\t\t\t\tprev = vert;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (polygon.vertices.length > 2) {\n\t\t\t\t\tif (polygon.vertices.length === 3) {\n\t\t\t\t\t\tpolygon.simple = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tpolygons.push(polygon);\n\n\t\t\t\t\t//save edges\n\t\t\t\t\tfor (j = 0; j < polygon.vertices.length; j++) {\n\t\t\t\t\t\tvert = polygon.vertices[j];\n\t\t\t\t\t\tpolygon.edges.push([\n\t\t\t\t\t\t\tvert, vert.next\n\t\t\t\t\t\t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = polygons.length - 1; i >= 0; i--) {\n\t\t\t\tpolygon = polygons[i];\n\t\t\t\tmakeSimple(polygon);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tpolygon = polygons[i];\n\t\t\t\tpolygon.clockWise = clockWise(polygon);\n\t\t\t\ttriangulate(polygon);\n\t\t\t}\n\n\t\t\t//build shape\n\t\t\tshape.vertices = [];\n\t\t\tshape.coords = [];\n\t\t\tfor (i = 0; i < vertices.length; i++) {\n\t\t\t\tv = vertices[i];\n\t\t\t\tshape.vertices.push(v.x * 2 - 1);\n\t\t\t\tshape.vertices.push(v.y * -2 + 1);\n\t\t\t\tshape.vertices.push(-1);\n\n\t\t\t\tshape.coords.push(v.x);\n\t\t\t\tshape.coords.push(v.y * -1 + 1);\n\t\t\t}\n\t\t\tshape.vertices = new Float32Array(shape.vertices);\n\t\t\tshape.coords = new Float32Array(shape.coords);\n\n\t\t\tshape.indices = [];\n\t\t\tfor (i = 0; i < polygons.length; i++) {\n\t\t\t\tpolygon = polygons[i];\n\t\t\t\tfor (j = 0; j < polygon.indices.length; j++) {\n\t\t\t\t\tv = polygon.indices[j];\n\t\t\t\t\tshape.indices.push(v.id);\n\t\t\t\t\t//shape.indices.push(v[1].id);\n\t\t\t\t\t//shape.indices.push(v[2].id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tshape.indices = new Uint16Array(shape.indices);\n\n\t\t\tthis.shape = shape;\n\t\t\tif (this.gl) {\n\t\t\t\tmakeGlModel(shape, this.gl);\n\t\t\t}\n\t\t};\n\n\t\tEffectNode.prototype.destroy = function () {\n\t\t\tvar i, key, item, hook = this.hook;\n\n\t\t\t//let effect destroy itself\n\t\t\tif (this.effect.destroy && typeof this.effect.destroy === 'function') {\n\t\t\t\tthis.effect.destroy.call(this);\n\t\t\t}\n\t\t\tdelete this.effect;\n\n\t\t\t//shader\n\t\t\tif (commonShaders[hook]) {\n\t\t\t\tcommonShaders[hook].count--;\n\t\t\t\tif (!commonShaders[hook].count) {\n\t\t\t\t\tdelete commonShaders[hook];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.shader && this.shader.destroy && this.shader !== baseShader && !commonShaders[hook]) {\n\t\t\t\tthis.shader.destroy();\n\t\t\t}\n\t\t\tdelete this.shader;\n\n\t\t\t//stop watching any input elements\n\t\t\tfor (key in this.inputElements) {\n\t\t\t\tif (this.inputElements.hasOwnProperty(key)) {\n\t\t\t\t\titem = this.inputElements[key];\n\t\t\t\t\titem.element.removeEventListener('change', item.listener, true);\n\t\t\t\t\titem.element.removeEventListener('input', item.listener, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//sources\n\t\t\tfor (key in this.sources) {\n\t\t\t\tif (this.sources.hasOwnProperty(key)) {\n\t\t\t\t\titem = this.sources[key];\n\t\t\t\t\tif (item && item.removeTarget) {\n\t\t\t\t\t\titem.removeTarget(this);\n\t\t\t\t\t}\n\t\t\t\t\tdelete this.sources[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//targets\n\t\t\twhile (this.targets.length) {\n\t\t\t\titem = this.targets.pop();\n\t\t\t\tif (item && item.removeSource) {\n\t\t\t\t\titem.removeSource(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (key in this) {\n\t\t\t\tif (this.hasOwnProperty(key) && key !== 'id') {\n\t\t\t\t\tdelete this[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//remove any aliases\n\t\t\tfor (key in aliases) {\n\t\t\t\tif (aliases.hasOwnProperty(key)) {\n\t\t\t\t\titem = aliases[key];\n\t\t\t\t\tif (item.node === this) {\n\t\t\t\t\t\tseriously.removeAlias(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//remove self from master list of effects\n\t\t\ti = effects.indexOf(this);\n\t\t\tif (i >= 0) {\n\t\t\t\teffects.splice(i, 1);\n\t\t\t}\n\n\t\t\ti = allEffectsByHook[hook].indexOf(this);\n\t\t\tif (i >= 0) {\n\t\t\t\tallEffectsByHook[hook].splice(i, 1);\n\t\t\t}\n\n\t\t\tNode.prototype.destroy.call(this);\n\t\t};\n\n\t\tSource = function (sourceNode) {\n\t\t\tvar me = sourceNode;\n\n\t\t\t//priveleged accessor methods\n\t\t\tObject.defineProperties(this, {\n\t\t\t\toriginal: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.source;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tid: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.id;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\twidth: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.width;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\theight: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.height;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.render = function () {\n\t\t\t\tme.render();\n\t\t\t};\n\n\t\t\tthis.update = function () {\n\t\t\t\tme.setDirty();\n\t\t\t};\n\n\t\t\tthis.readPixels = function (x, y, width, height, dest) {\n\t\t\t\treturn me.readPixels(x, y, width, height, dest);\n\t\t\t};\n\n\t\t\tthis.on = function (eventName, callback) {\n\t\t\t\tme.on(eventName, callback);\n\t\t\t};\n\n\t\t\tthis.off = function (eventName, callback) {\n\t\t\t\tme.off(eventName, callback);\n\t\t\t};\n\n\t\t\tthis.destroy = function () {\n\t\t\t\tvar i,\n\t\t\t\t\tdescriptor;\n\n\t\t\t\tme.destroy();\n\n\t\t\t\tfor (i in this) {\n\t\t\t\t\tif (this.hasOwnProperty(i) && i !== 'isDestroyed' && i !== 'id') {\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(this, i);\n\t\t\t\t\t\tif (descriptor.get || descriptor.set ||\n\t\t\t\t\t\t\t\ttypeof this[i] !== 'function') {\n\t\t\t\t\t\t\tdelete this[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis[i] = nop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.isDestroyed = function () {\n\t\t\t\treturn me.isDestroyed;\n\t\t\t};\n\n\t\t\tthis.isReady = function () {\n\t\t\t\treturn me.ready;\n\t\t\t};\n\t\t};\n\n\t\t/*\n\t\t\tpossible sources: img, video, canvas (2d or 3d), texture, ImageData, array, typed array\n\t\t*/\n\t\tSourceNode = function (hook, source, options) {\n\t\t\tvar opts = options || {},\n\t\t\t\tflip = opts.flip === undefined ? true : opts.flip,\n\t\t\t\twidth = opts.width,\n\t\t\t\theight = opts.height,\n\t\t\t\tdeferTexture = false,\n\t\t\t\tthat = this,\n\t\t\t\tmatchedType = false,\n\t\t\t\tkey,\n\t\t\t\tplugin;\n\n\t\t\tfunction sourcePlugin(hook, source, options, force) {\n\t\t\t\tvar p = seriousSources[hook];\n\t\t\t\tif (p.definition) {\n\t\t\t\t\tp = p.definition.call(that, source, options, force);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tp = extend(extend({}, seriousSources[hook]), p);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tfunction compareSource(source) {\n\t\t\t\treturn that.source === source;\n\t\t\t}\n\n\t\t\tNode.call(this);\n\n\t\t\tif (hook && typeof hook !== 'string' || !source && source !== 0) {\n\t\t\t\tif (!options || typeof options !== 'object') {\n\t\t\t\t\toptions = source;\n\t\t\t\t}\n\t\t\t\tsource = hook;\n\t\t\t}\n\n\t\t\tif (typeof source === 'string' && isNaN(source)) {\n\t\t\t\tsource = getElement(source, ['canvas', 'img', 'video']);\n\t\t\t}\n\n\t\t\t// forced source type?\n\t\t\tif (typeof hook === 'string' && seriousSources[hook]) {\n\t\t\t\tplugin = sourcePlugin(hook, source, options, true);\n\t\t\t\tif (plugin) {\n\t\t\t\t\tthis.hook = hook;\n\t\t\t\t\tmatchedType = true;\n\t\t\t\t\tdeferTexture = plugin.deferTexture;\n\t\t\t\t\tthis.plugin = plugin;\n\t\t\t\t\tthis.compare = plugin.compare;\n\t\t\t\t\tthis.checkDirty = plugin.checkDirty;\n\t\t\t\t\tif (plugin.source) {\n\t\t\t\t\t\tsource = plugin.source;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//todo: could probably stand to re-work and re-indent this whole block now that we have plugins\n\t\t\tif (!plugin && isInstance(source)) {\n\t\t\t\tif (source.tagName === 'CANVAS') {\n\t\t\t\t\tthis.width = source.width;\n\t\t\t\t\tthis.height = source.height;\n\n\t\t\t\t\tthis.render = this.renderImageCanvas;\n\t\t\t\t\tmatchedType = true;\n\t\t\t\t\tthis.hook = 'canvas';\n\t\t\t\t\tthis.compare = compareSource;\n\t\t\t\t} else if (source.tagName === 'IMG') {\n\t\t\t\t\tthis.width = source.naturalWidth || 1;\n\t\t\t\t\tthis.height = source.naturalHeight || 1;\n\n\t\t\t\t\tif (!source.complete || !source.naturalWidth) {\n\t\t\t\t\t\tdeferTexture = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tsource.addEventListener('load', function () {\n\t\t\t\t\t\tif (!that.isDestroyed) {\n\t\t\t\t\t\t\tif (that.width !== source.naturalWidth || that.height !== source.naturalHeight) {\n\t\t\t\t\t\t\t\tthat.width = source.naturalWidth;\n\t\t\t\t\t\t\t\tthat.height = source.naturalHeight;\n\t\t\t\t\t\t\t\tthat.resize();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthat.setDirty();\n\t\t\t\t\t\t\tthat.setReady();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, true);\n\n\t\t\t\t\tthis.render = this.renderImageCanvas;\n\t\t\t\t\tmatchedType = true;\n\t\t\t\t\tthis.hook = 'image';\n\t\t\t\t\tthis.compare = compareSource;\n\t\t\t\t}\n\t\t\t} else if (!plugin && isInstance(source, 'WebGLTexture')) {\n\t\t\t\tif (gl && !gl.isTexture(source)) {\n\t\t\t\t\tthrow new Error('Not a valid WebGL texture.');\n\t\t\t\t}\n\n\t\t\t\t//different defaults\n\t\t\t\tif (!isNaN(width)) {\n\t\t\t\t\tif (isNaN(height)) {\n\t\t\t\t\t\theight = width;\n\t\t\t\t\t}\n\t\t\t\t} else if (!isNaN(height)) {\n\t\t\t\t\twidth = height;\n\t\t\t\t}/* else {\n\t\t\t\t\t//todo: guess based on dimensions of target canvas\n\t\t\t\t\t//throw new Error('Must specify width and height when using a WebGL texture as a source');\n\t\t\t\t}*/\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tif (opts.flip === undefined) {\n\t\t\t\t\tflip = false;\n\t\t\t\t}\n\t\t\t\tmatchedType = true;\n\n\t\t\t\tthis.texture = source;\n\t\t\t\tthis.initialized = true;\n\t\t\t\tthis.hook = 'texture';\n\t\t\t\tthis.compare = compareSource;\n\n\t\t\t\t//todo: if WebGLTexture source is from a different context render it and copy it over\n\t\t\t\tthis.render = function () {};\n\t\t\t}\n\n\t\t\tif (!matchedType && !plugin) {\n\t\t\t\tfor (key in seriousSources) {\n\t\t\t\t\tif (seriousSources.hasOwnProperty(key) && seriousSources[key]) {\n\t\t\t\t\t\tplugin = sourcePlugin(key, source, options, false);\n\t\t\t\t\t\tif (plugin) {\n\t\t\t\t\t\t\tthis.hook = key;\n\t\t\t\t\t\t\tmatchedType = true;\n\t\t\t\t\t\t\tdeferTexture = plugin.deferTexture;\n\t\t\t\t\t\t\tthis.plugin = plugin;\n\t\t\t\t\t\t\tthis.compare = plugin.compare;\n\t\t\t\t\t\t\tthis.checkDirty = plugin.checkDirty;\n\t\t\t\t\t\t\tif (plugin.source) {\n\t\t\t\t\t\t\t\tsource = plugin.source;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!matchedType) {\n\t\t\t\tthrow new Error('Unknown source type');\n\t\t\t}\n\n\t\t\tthis.source = source;\n\t\t\tif (this.flip === undefined) {\n\t\t\t\tthis.flip = flip;\n\t\t\t}\n\n\t\t\tthis.targets = [];\n\n\t\t\tif (!deferTexture) {\n\t\t\t\tthat.setReady();\n\t\t\t}\n\n\t\t\tthis.pub = new Source(this);\n\n\t\t\tnodes.push(this);\n\t\t\tnodesById[this.id] = this;\n\t\t\tsources.push(this);\n\t\t\tallSourcesByHook[this.hook].push(this);\n\n\t\t\tif (sources.length && !rafId) {\n\t\t\t\trenderDaemon();\n\t\t\t}\n\t\t};\n\n\t\tSourceNode.prototype = Object.create(Node.prototype);\n\t\tSourceNode.prototype.constructor = SourceNode;\n\n\t\tSourceNode.prototype.initialize = function () {\n\t\t\tvar texture;\n\n\t\t\tif (!gl || this.texture || !this.ready) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttexture = gl.createTexture();\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\n\t\t\tthis.texture = texture;\n\t\t\tthis.initialized = true;\n\t\t\tthis.allowRefresh = true;\n\t\t\tthis.setDirty();\n\t\t};\n\n\t\tSourceNode.prototype.initFrameBuffer = function (useFloat) {\n\t\t\tif (gl) {\n\t\t\t\tthis.frameBuffer = new FrameBuffer(gl, this.width, this.height, {\n\t\t\t\t\ttexture: this.texture,\n\t\t\t\t\tuseFloat: useFloat\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tSourceNode.prototype.addTarget = function (target) {\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\tif (this.targets[i] === target) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.targets.push(target);\n\t\t};\n\n\t\tSourceNode.prototype.removeTarget = function (target) {\n\t\t\tvar i = this.targets && this.targets.indexOf(target);\n\t\t\tif (i >= 0) {\n\t\t\t\tthis.targets.splice(i, 1);\n\t\t\t}\n\t\t};\n\n\t\tSourceNode.prototype.resize = function () {\n\t\t\tvar i,\n\t\t\t\ttarget;\n\n\t\t\tthis.uniforms.resolution[0] = this.width;\n\t\t\tthis.uniforms.resolution[1] = this.height;\n\n\t\t\tif (this.framebuffer) {\n\t\t\t\tthis.framebuffer.resize(this.width, this.height);\n\t\t\t}\n\n\t\t\tthis.emit('resize');\n\t\t\tthis.setDirty();\n\n\t\t\tif (this.targets) {\n\t\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\t\ttarget = this.targets[i];\n\t\t\t\t\ttarget.resize();\n\t\t\t\t\tif (target.setTransformDirty) {\n\t\t\t\t\t\ttarget.setTransformDirty();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tSourceNode.prototype.setReady = function () {\n\t\t\tvar i;\n\t\t\tif (!this.ready) {\n\t\t\t\tthis.ready = true;\n\t\t\t\tthis.resize();\n\t\t\t\tthis.initialize();\n\n\t\t\t\tthis.emit('ready');\n\t\t\t\tif (this.targets) {\n\t\t\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\t\t\tthis.targets[i].setReady();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t};\n\n\t\tSourceNode.prototype.render = function () {\n\t\t\tvar media = this.source;\n\n\t\t\tif (!gl || !media && media !== 0 || !this.ready) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!this.initialized) {\n\t\t\t\tthis.initialize();\n\t\t\t}\n\n\t\t\tif (!this.allowRefresh) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.plugin && this.plugin.render &&\n\t\t\t\t\t(this.dirty || this.checkDirty && this.checkDirty()) &&\n\t\t\t\t\tthis.plugin.render.call(this, gl, draw, rectangleModel, baseShader)) {\n\n\t\t\t\tthis.dirty = false;\n\t\t\t\tthis.emit('render');\n\t\t\t}\n\t\t};\n\n\t\tSourceNode.prototype.renderImageCanvas = function () {\n\t\t\tvar media = this.source;\n\n\t\t\tif (!gl || !media || !this.ready) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!this.initialized) {\n\t\t\t\tthis.initialize();\n\t\t\t}\n\n\t\t\tif (!this.allowRefresh) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.dirty) {\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, this.texture);\n\t\t\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flip);\n\t\t\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\t\t\t\ttry {\n\t\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, media);\n\n\t\t\t\t\tthis.dirty = false;\n\t\t\t\t\tthis.emit('render');\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (securityError) {\n\t\t\t\t\tif (securityError.code === window.DOMException.SECURITY_ERR) {\n\t\t\t\t\t\tthis.allowRefresh = false;\n\t\t\t\t\t\tSeriously.logger.error('Unable to access cross-domain image');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\tSourceNode.prototype.destroy = function () {\n\t\t\tvar i, key, item;\n\n\t\t\tif (this.plugin && this.plugin.destroy) {\n\t\t\t\tthis.plugin.destroy.call(this);\n\t\t\t}\n\n\t\t\tif (gl && this.texture) {\n\t\t\t\tgl.deleteTexture(this.texture);\n\t\t\t}\n\n\t\t\t//targets\n\t\t\twhile (this.targets.length) {\n\t\t\t\titem = this.targets.pop();\n\t\t\t\tif (item && item.removeSource) {\n\t\t\t\t\titem.removeSource(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//remove self from master list of sources\n\t\t\ti = sources.indexOf(this);\n\t\t\tif (i >= 0) {\n\t\t\t\tsources.splice(i, 1);\n\t\t\t}\n\n\t\t\ti = allSourcesByHook[this.hook].indexOf(this);\n\t\t\tif (i >= 0) {\n\t\t\t\tallSourcesByHook[this.hook].splice(i, 1);\n\t\t\t}\n\n\t\t\tfor (key in this) {\n\t\t\t\tif (this.hasOwnProperty(key) && key !== 'id') {\n\t\t\t\t\tdelete this[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tNode.prototype.destroy.call(this);\n\t\t};\n\n\t\t//todo: implement render for array and typed array\n\n\t\tTarget = function (targetNode) {\n\t\t\tvar me = targetNode;\n\n\t\t\t//priveleged accessor methods\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tsource: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\tif (me.source) {\n\t\t\t\t\t\t\treturn me.source.pub;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tset: function (value) {\n\t\t\t\t\t\tme.setSource(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\toriginal: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.target;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\twidth: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.width;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (value) {\n\t\t\t\t\t\tif (!isNaN(value) && value >0 && me.width !== value) {\n\t\t\t\t\t\t\tme.width = value;\n\t\t\t\t\t\t\tme.resize();\n\t\t\t\t\t\t\tme.setTransformDirty();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\theight: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.height;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (value) {\n\t\t\t\t\t\tif (!isNaN(value) && value >0 && me.height !== value) {\n\t\t\t\t\t\t\tme.height = value;\n\t\t\t\t\t\t\tme.resize();\n\t\t\t\t\t\t\tme.setTransformDirty();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tid: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.render = function () {\n\t\t\t\tme.render();\n\t\t\t};\n\n\t\t\tthis.readPixels = function (x, y, width, height, dest) {\n\t\t\t\treturn me.readPixels(x, y, width, height, dest);\n\t\t\t};\n\n\t\t\tthis.on = function (eventName, callback) {\n\t\t\t\tme.on(eventName, callback);\n\t\t\t};\n\n\t\t\tthis.off = function (eventName, callback) {\n\t\t\t\tme.off(eventName, callback);\n\t\t\t};\n\n\t\t\tthis.go = function (options) {\n\t\t\t\tme.go(options);\n\t\t\t};\n\n\t\t\tthis.stop = function () {\n\t\t\t\tme.stop();\n\t\t\t};\n\n\t\t\tthis.getTexture = function () {\n\t\t\t\treturn me.frameBuffer.texture;\n\t\t\t};\n\n\t\t\tthis.destroy = function () {\n\t\t\t\tvar i,\n\t\t\t\t\tdescriptor;\n\n\t\t\t\tme.destroy();\n\n\t\t\t\tfor (i in this) {\n\t\t\t\t\tif (this.hasOwnProperty(i) && i !== 'isDestroyed' && i !== 'id') {\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(this, i);\n\t\t\t\t\t\tif (descriptor.get || descriptor.set ||\n\t\t\t\t\t\t\t\ttypeof this[i] !== 'function') {\n\t\t\t\t\t\t\tdelete this[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis[i] = nop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.inputs = function (name) {\n\t\t\t\treturn {\n\t\t\t\t\tsource: {\n\t\t\t\t\t\ttype: 'image'\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tthis.isDestroyed = function () {\n\t\t\t\treturn me.isDestroyed;\n\t\t\t};\n\n\t\t\tthis.isReady = function () {\n\t\t\t\treturn me.ready;\n\t\t\t};\n\t\t};\n\n\t\t/*\n\t\t\tpossible targets: canvas (2d or 3d), gl render buffer (must be same canvas)\n\t\t*/\n\t\tTargetNode = function (hook, target, options) {\n\t\t\tvar opts,\n\t\t\t\tflip,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tthat = this,\n\t\t\t\tmatchedType = false,\n\t\t\t\ti, element, elements, context,\n\t\t\t\tdebugContext,\n\t\t\t\tframeBuffer,\n\t\t\t\ttargetList,\n\t\t\t\ttriedWebGl = false,\n\t\t\t\tkey;\n\n\t\t\tfunction targetPlugin(hook, target, options, force) {\n\t\t\t\tvar plugin = seriousTargets[hook];\n\t\t\t\tif (plugin.definition) {\n\t\t\t\t\tplugin = plugin.definition.call(that, target, options, force);\n\t\t\t\t\tif (!plugin) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tplugin = extend(extend({}, seriousTargets[hook]), plugin);\n\t\t\t\t\tthat.hook = key;\n\t\t\t\t\tmatchedType = true;\n\t\t\t\t\tthat.plugin = plugin;\n\t\t\t\t\tthat.compare = plugin.compare;\n\t\t\t\t\tif (plugin.target) {\n\t\t\t\t\t\ttarget = plugin.target;\n\t\t\t\t\t}\n\t\t\t\t\tif (plugin.gl && !that.gl) {\n\t\t\t\t\t\tthat.gl = plugin.gl;\n\t\t\t\t\t\tif (!gl) {\n\t\t\t\t\t\t\tattachContext(plugin.gl);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (that.gl === gl) {\n\t\t\t\t\t\tthat.model = rectangleModel;\n\t\t\t\t\t\tthat.shader = baseShader;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn plugin;\n\t\t\t}\n\n\t\t\tfunction compareTarget(target) {\n\t\t\t\treturn that.target === target;\n\t\t\t}\n\n\t\t\tNode.call(this);\n\n\t\t\tif (hook && typeof hook !== 'string' || !target && target !== 0) {\n\t\t\t\tif (!options || typeof options !== 'object') {\n\t\t\t\t\toptions = target;\n\t\t\t\t}\n\t\t\t\ttarget = hook;\n\t\t\t}\n\n\t\t\topts = options || {};\n\t\t\tflip = opts.flip === undefined ? true : opts.flip;\n\t\t\twidth = parseInt(opts.width, 10);\n\t\t\theight = parseInt(opts.height, 10);\n\t\t\tdebugContext = opts.debugContext;\n\n\t\t\t// forced target type?\n\t\t\tif (typeof hook === 'string' && seriousTargets[hook]) {\n\t\t\t\ttargetPlugin(hook, target, opts, true);\n\t\t\t}\n\n\t\t\tthis.renderToTexture = opts.renderToTexture;\n\n\t\t\tif (isInstance(target, 'WebGLFramebuffer')) {\n\t\t\t\tframeBuffer = target;\n\n\t\t\t\tif (isInstance(opts, 'HTMLCanvasElement')) {\n\t\t\t\t\ttarget = opts;\n\t\t\t\t} else if (isInstance(opts, 'WebGLRenderingContext')) {\n\t\t\t\t\ttarget = opts.canvas;\n\t\t\t\t} else if (isInstance(opts.canvas, 'HTMLCanvasElement')) {\n\t\t\t\t\ttarget = opts.canvas;\n\t\t\t\t} else if (isInstance(opts.context, 'WebGLRenderingContext')) {\n\t\t\t\t\ttarget = opts.context.canvas;\n\t\t\t\t} else {\n\t\t\t\t\t//todo: search all canvases for matching contexts?\n\t\t\t\t\tthrow new Error('Must provide a canvas with WebGLFramebuffer target');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isInstance(target, 'HTMLCanvasElement')) {\n\t\t\t\twidth = target.width;\n\t\t\t\theight = target.height;\n\n\t\t\t\t//try to get a webgl context.\n\t\t\t\tif (!gl || gl.canvas !== target && opts.allowSecondaryWebGL) {\n\t\t\t\t\ttriedWebGl = true;\n\t\t\t\t\tcontext = getWebGlContext(target, {\n\t\t\t\t\t\talpha: true,\n\t\t\t\t\t\tpremultipliedAlpha: true,\n\t\t\t\t\t\tpreserveDrawingBuffer: true,\n\t\t\t\t\t\tstencil: true,\n\t\t\t\t\t\tdebugContext: debugContext\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (!context) {\n\t\t\t\t\tif (!opts.allowSecondaryWebGL && gl && gl.canvas !== target) {\n\t\t\t\t\t\tthrow new Error('Only one WebGL target canvas allowed. Set allowSecondaryWebGL option to create secondary context.');\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.render = nop;\n\t\t\t\t\tSeriously.logger.log('Unable to create WebGL context.');\n\t\t\t\t\t//throw new Error('Unable to create WebGL context.');\n\t\t\t\t} else if (!gl || gl === context) {\n\t\t\t\t\t//this is our main WebGL canvas\n\t\t\t\t\tif (!primaryTarget) {\n\t\t\t\t\t\tprimaryTarget = this;\n\t\t\t\t\t}\n\t\t\t\t\tif (!gl) {\n\t\t\t\t\t\tattachContext(context);\n\t\t\t\t\t}\n\t\t\t\t\tthis.render = this.renderWebGL;\n\n\t\t\t\t\t/*\n\t\t\t\t\tDon't remember what this is for. Maybe we should remove it\n\t\t\t\t\t*/\n\t\t\t\t\tif (opts.renderToTexture) {\n\t\t\t\t\t\tif (gl) {\n\t\t\t\t\t\t\tthis.frameBuffer = new FrameBuffer(gl, width, height, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.frameBuffer = {\n\t\t\t\t\t\t\tframeBuffer: frameBuffer || null\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//set up alternative drawing method using ArrayBufferView\n\t\t\t\t\tthis.gl = context;\n\n\t\t\t\t\t//this.pixels = new Uint8Array(width * height * 4);\n\t\t\t\t\t//todo: probably need another framebuffer for renderToTexture?\n\t\t\t\t\t//todo: handle lost context on secondary webgl\n\t\t\t\t\tthis.frameBuffer = {\n\t\t\t\t\t\tframeBuffer: frameBuffer || null\n\t\t\t\t\t};\n\t\t\t\t\tthis.shader = new ShaderProgram(this.gl, baseVertexShader, baseFragmentShader);\n\t\t\t\t\tthis.model = buildRectangleModel.call(this, this.gl);\n\t\t\t\t\tthis.pixels = null;\n\n\t\t\t\t\tthis.texture = this.gl.createTexture();\n\t\t\t\t\tthis.gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\t\t\t\t\tthis.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\t\t\tthis.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\t\t\tthis.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tthis.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n\t\t\t\t\tthis.render = this.renderSecondaryWebGL;\n\t\t\t\t}\n\n\t\t\t\tmatchedType = true;\n\t\t\t}\n\n\t\t\tif (!matchedType) {\n\t\t\t\tfor (key in seriousTargets) {\n\t\t\t\t\tif (seriousTargets.hasOwnProperty(key) && seriousTargets[key]) {\n\t\t\t\t\t\tif (targetPlugin(key, target, opts, false)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!matchedType) {\n\t\t\t\tthrow new Error('Unknown target type');\n\t\t\t}\n\n\t\t\tif (allTargets) {\n\t\t\t\ttargetList = allTargets.get(target);\n\t\t\t\tif (targetList) {\n\t\t\t\t\tSeriously.logger.warn(\n\t\t\t\t\t\t'Target already in use by another instance',\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tObject.keys(targetList).map(function (key) {\n\t\t\t\t\t\t\treturn targetList[key];\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\ttargetList = {};\n\t\t\t\t\tallTargets.set(target, targetList);\n\t\t\t\t}\n\t\t\t\ttargetList[seriously.id] = seriously;\n\t\t\t}\n\n\t\t\tthis.target = target;\n\t\t\tthis.transform = null;\n\t\t\tthis.transformDirty = true;\n\t\t\tthis.flip = flip;\n\t\t\tif (width) {\n\t\t\t\tthis.width = width;\n\t\t\t}\n\t\t\tif (height) {\n\t\t\t\tthis.height = height;\n\t\t\t}\n\n\t\t\tthis.uniforms.resolution[0] = this.width;\n\t\t\tthis.uniforms.resolution[1] = this.height;\n\n\t\t\tif (opts.auto !== undefined) {\n\t\t\t\tthis.auto = opts.auto;\n\t\t\t} else {\n\t\t\t\tthis.auto = auto;\n\t\t\t}\n\t\t\tthis.frames = 0;\n\n\t\t\tthis.pub = new Target(this);\n\n\t\t\tnodes.push(this);\n\t\t\tnodesById[this.id] = this;\n\t\t\ttargets.push(this);\n\t\t};\n\n\t\tTargetNode.prototype = Object.create(Node.prototype);\n\t\tTargetNode.prototype.constructor = TargetNode;\n\n\t\tTargetNode.prototype.setSource = function (source) {\n\t\t\tvar newSource;\n\n\t\t\t//todo: what if source is null/undefined/false\n\n\t\t\tnewSource = findInputNode(source);\n\n\t\t\t//todo: check for cycles\n\n\t\t\tif (newSource !== this.source) {\n\t\t\t\tif (this.source) {\n\t\t\t\t\tthis.source.removeTarget(this);\n\t\t\t\t}\n\t\t\t\tthis.source = newSource;\n\t\t\t\tnewSource.addTarget(this);\n\n\t\t\t\tif (newSource) {\n\t\t\t\t\tthis.resize();\n\t\t\t\t\tif (newSource.ready) {\n\t\t\t\t\t\tthis.setReady();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.setUnready();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.setDirty();\n\t\t\t}\n\t\t};\n\n\t\tTargetNode.prototype.setDirty = function () {\n\t\t\tthis.dirty = true;\n\n\t\t\tif (this.auto && !rafId) {\n\t\t\t\trafId = requestAnimationFrame(renderDaemon);\n\t\t\t}\n\t\t};\n\n\t\tTargetNode.prototype.resize = function () {\n\t\t\t//if target is a canvas, reset size to canvas size\n\t\t\tif (isInstance(this.target, 'HTMLCanvasElement')) {\n\t\t\t\tif (this.width !== this.target.width || this.height !== this.target.height) {\n\t\t\t\t\tthis.target.width = this.width;\n\t\t\t\t\tthis.target.height = this.height;\n\t\t\t\t\tthis.uniforms.resolution[0] = this.width;\n\t\t\t\t\tthis.uniforms.resolution[1] = this.height;\n\t\t\t\t\tthis.emit('resize');\n\t\t\t\t\tthis.setTransformDirty();\n\t\t\t\t}\n\t\t\t} else if (this.plugin && this.plugin.resize) {\n\t\t\t\tthis.plugin.resize.call(this);\n\t\t\t}\n\n\t\t\tif (this.source &&\n\t\t\t\t(this.source.width !== this.width || this.source.height !== this.height)) {\n\t\t\t\tif (!this.transform) {\n\t\t\t\t\tthis.transform = new Float32Array(16);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tTargetNode.prototype.setTransformDirty = function () {\n\t\t\tthis.transformDirty = true;\n\t\t\tthis.setDirty();\n\t\t};\n\n\t\tTargetNode.prototype.go = function () {\n\t\t\tthis.auto = true;\n\t\t\tthis.setDirty();\n\t\t};\n\n\t\tTargetNode.prototype.stop = function () {\n\t\t\tthis.auto = false;\n\t\t};\n\n\t\tTargetNode.prototype.render = function () {\n\t\t\tif (gl && this.plugin && this.plugin.render) {\n\t\t\t\tthis.plugin.render.call(this, draw, baseShader, rectangleModel);\n\t\t\t}\n\t\t};\n\n\t\tTargetNode.prototype.renderWebGL = function () {\n\t\t\tvar matrix, x, y;\n\n\t\t\tthis.resize();\n\n\t\t\tif (gl && this.dirty && this.ready) {\n\t\t\t\tif (!this.source) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.source.render();\n\n\t\t\t\tthis.uniforms.source = this.source.texture;\n\n\t\t\t\tif (this.source.width === this.width && this.source.height === this.height) {\n\t\t\t\t\tthis.uniforms.transform = this.source.cumulativeMatrix || identity;\n\t\t\t\t} else if (this.transformDirty) {\n\t\t\t\t\tmatrix = this.transform;\n\t\t\t\t\tmat4.copy(matrix, this.source.cumulativeMatrix || identity);\n\t\t\t\t\tx = this.source.width / this.width;\n\t\t\t\t\ty = this.source.height / this.height;\n\t\t\t\t\tmatrix[0] *= x;\n\t\t\t\t\tmatrix[1] *= x;\n\t\t\t\t\tmatrix[2] *= x;\n\t\t\t\t\tmatrix[3] *= x;\n\t\t\t\t\tmatrix[4] *= y;\n\t\t\t\t\tmatrix[5] *= y;\n\t\t\t\t\tmatrix[6] *= y;\n\t\t\t\t\tmatrix[7] *= y;\n\t\t\t\t\tthis.uniforms.transform = matrix;\n\t\t\t\t\tthis.transformDirty = false;\n\t\t\t\t}\n\n\t\t\t\tdraw(baseShader, rectangleModel, this.uniforms, this.frameBuffer.frameBuffer, this, outputRenderOptions);\n\n\t\t\t\tthis.emit('render');\n\t\t\t\tthis.dirty = false;\n\t\t\t}\n\t\t};\n\n\t\tTargetNode.prototype.renderSecondaryWebGL = function () {\n\t\t\tvar sourceWidth,\n\t\t\t\tsourceHeight,\n\t\t\t\tmatrix,\n\t\t\t\tx,\n\t\t\t\ty;\n\n\t\t\tif (this.dirty && this.ready && this.source) {\n\t\t\t\tthis.emit('render');\n\t\t\t\tthis.source.render(true);\n\n\t\t\t\tsourceWidth = this.source.width;\n\t\t\t\tsourceHeight = this.source.height;\n\n\t\t\t\tif (!this.pixels || this.pixels.length !== sourceWidth * sourceHeight * 4) {\n\t\t\t\t\tthis.pixels = new Uint8Array(sourceWidth * sourceHeight * 4);\n\t\t\t\t}\n\n\t\t\t\tthis.source.readPixels(0, 0, sourceWidth, sourceHeight, this.pixels);\n\n\t\t\t\tthis.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, sourceWidth, sourceHeight, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.pixels);\n\n\t\t\t\tif (sourceWidth === this.width && sourceHeight === this.height) {\n\t\t\t\t\tthis.uniforms.transform = identity;\n\t\t\t\t} else if (this.transformDirty) {\n\t\t\t\t\tmatrix = this.transform;\n\t\t\t\t\tmat4.copy(matrix, identity);\n\t\t\t\t\tx = this.source.width / this.width;\n\t\t\t\t\ty = this.source.height / this.height;\n\t\t\t\t\tmatrix[0] *= x;\n\t\t\t\t\tmatrix[1] *= x;\n\t\t\t\t\tmatrix[2] *= x;\n\t\t\t\t\tmatrix[3] *= x;\n\t\t\t\t\tmatrix[4] *= y;\n\t\t\t\t\tmatrix[5] *= y;\n\t\t\t\t\tmatrix[6] *= y;\n\t\t\t\t\tmatrix[7] *= y;\n\t\t\t\t\tthis.uniforms.transform = matrix;\n\t\t\t\t\tthis.transformDirty = false;\n\t\t\t\t}\n\n\t\t\t\tthis.uniforms.source = this.texture;\n\t\t\t\tdraw(this.shader, this.model, this.uniforms, null, this, outputRenderOptions);\n\n\t\t\t\tthis.dirty = false;\n\t\t\t}\n\t\t};\n\n\t\tTargetNode.prototype.removeSource = function (source) {\n\t\t\tif (this.source === source || this.source === source.pub) {\n\t\t\t\tthis.source = null;\n\t\t\t}\n\t\t};\n\n\t\tTargetNode.prototype.destroy = function () {\n\t\t\tvar i,\n\t\t\t\ttargetList;\n\n\t\t\t//source\n\t\t\tif (this.source && this.source.removeTarget) {\n\t\t\t\tthis.source.removeTarget(this);\n\t\t\t}\n\n\t\t\tif (allTargets) {\n\t\t\t\ttargetList = allTargets.get(this.target);\n\t\t\t\tdelete targetList[seriously.id];\n\t\t\t\tif (!Object.keys(targetList).length) {\n\t\t\t\t\tallTargets.delete(this.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.plugin && this.plugin.destroy) {\n\t\t\t\tthis.plugin.destroy.call(this);\n\t\t\t}\n\n\t\t\tdelete this.source;\n\t\t\tdelete this.target;\n\t\t\tdelete this.pub;\n\t\t\tdelete this.uniforms;\n\t\t\tdelete this.pixels;\n\t\t\tdelete this.auto;\n\n\t\t\t//remove self from master list of targets\n\t\t\ti = targets.indexOf(this);\n\t\t\tif (i >= 0) {\n\t\t\t\ttargets.splice(i, 1);\n\t\t\t}\n\n\t\t\tNode.prototype.destroy.call(this);\n\n\t\t\t//clear out context so we can start over\n\t\t\tif (this === primaryTarget) {\n\t\t\t\tglCanvas.removeEventListener('webglcontextrestored', restoreContext, false);\n\t\t\t\tdestroyContext();\n\t\t\t\tprimaryTarget = null;\n\t\t\t}\n\t\t};\n\n\t\tTransform = function (transformNode) {\n\t\t\tvar me = transformNode,\n\t\t\t\tself = this,\n\t\t\t\tkey;\n\n\t\t\tfunction setInput(inputName, def, input) {\n\t\t\t\tvar inputKey, lookup, value;\n\n\t\t\t\tlookup = me.inputElements[inputName];\n\n\t\t\t\t//todo: there is some duplicate code with Effect here. Consolidate.\n\t\t\t\tif (typeof input === 'string' && isNaN(input)) {\n\t\t\t\t\tif (def.type === 'enum') {\n\t\t\t\t\t\tif (!def.options.hasOwnProperty(input)) {\n\t\t\t\t\t\t\tinput = getElement(input, ['select']);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (def.type === 'number' || def.type === 'boolean') {\n\t\t\t\t\t\tinput = getElement(input, ['input', 'select']);\n\t\t\t\t\t} else if (def.type === 'image') {\n\t\t\t\t\t\tinput = getElement(input, ['canvas', 'img', 'video']);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isInstance(input, 'HTMLInputElement') || isInstance(input, 'HTMLSelectElement')) {\n\t\t\t\t\tvalue = input.value;\n\n\t\t\t\t\tif (lookup && lookup.element !== input) {\n\t\t\t\t\t\tlookup.element.removeEventListener('change', lookup.listener, true);\n\t\t\t\t\t\tlookup.element.removeEventListener('input', lookup.listener, true);\n\t\t\t\t\t\tdelete me.inputElements[inputName];\n\t\t\t\t\t\tlookup = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!lookup) {\n\t\t\t\t\t\tlookup = {\n\t\t\t\t\t\t\telement: input,\n\t\t\t\t\t\t\tlistener: (function (element) {\n\t\t\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\t\t\tvar oldValue, newValue;\n\n\t\t\t\t\t\t\t\t\tif (input.type === 'checkbox') {\n\t\t\t\t\t\t\t\t\t\t//special case for check box\n\t\t\t\t\t\t\t\t\t\toldValue = input.checked;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\toldValue = element.value;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnewValue = me.setInput(inputName, oldValue);\n\n\t\t\t\t\t\t\t\t\t//special case for color type\n\t\t\t\t\t\t\t\t\tif (input.type === 'color') {\n\t\t\t\t\t\t\t\t\t\tnewValue = colorArrayToHex(newValue);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//if input validator changes our value, update HTML Element\n\t\t\t\t\t\t\t\t\t//todo: make this optional...somehow\n\t\t\t\t\t\t\t\t\tif (newValue !== oldValue) {\n\t\t\t\t\t\t\t\t\t\telement.value = newValue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}(input))\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tme.inputElements[inputName] = lookup;\n\t\t\t\t\t\tif (input.type === 'range') {\n\t\t\t\t\t\t\tinput.addEventListener('input', lookup.listener, true);\n\t\t\t\t\t\t\tinput.addEventListener('change', lookup.listener, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinput.addEventListener('change', lookup.listener, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lookup && input.type === 'checkbox') {\n\t\t\t\t\t\tvalue = input.checked;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (lookup) {\n\t\t\t\t\t\tlookup.element.removeEventListener('change', lookup.listener, true);\n\t\t\t\t\t\tlookup.element.removeEventListener('input', lookup.listener, true);\n\t\t\t\t\t\tdelete me.inputElements[inputName];\n\t\t\t\t\t}\n\t\t\t\t\tvalue = input;\n\t\t\t\t}\n\n\t\t\t\tme.setInput(inputName, value);\n\t\t\t}\n\n\t\t\tfunction setProperty(name, def) {\n\t\t\t\t// todo: validate value passed to 'set'\n\t\t\t\tObject.defineProperty(self, name, {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn def.get.call(me);\n\t\t\t\t\t},\n\t\t\t\t\tset: function (val) {\n\t\t\t\t\t\tsetInput(name, def, val);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction makeMethod(method) {\n\t\t\t\treturn function () {\n\t\t\t\t\tif (method.apply(me, arguments)) {\n\t\t\t\t\t\tme.setTransformDirty();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t//priveleged accessor methods\n\t\t\tObject.defineProperties(this, {\n\t\t\t\ttransform: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.hook;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\ttitle: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.plugin.title || me.hook;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\twidth: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.width;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\theight: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.height;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tid: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.id;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsource: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn me.source && me.source.pub;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (source) {\n\t\t\t\t\t\tme.setSource(source);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// attach methods\n\t\t\tfor (key in me.methods) {\n\t\t\t\tif (me.methods.hasOwnProperty(key)) {\n\t\t\t\t\tthis[key] = makeMethod(me.methods[key]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (key in me.inputs) {\n\t\t\t\tif (me.inputs.hasOwnProperty(key)) {\n\t\t\t\t\tsetProperty(key, me.inputs[key]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.update = function () {\n\t\t\t\tme.setDirty();\n\t\t\t};\n\n\t\t\tthis.inputs = function (name) {\n\t\t\t\tvar result,\n\t\t\t\t\tinput,\n\t\t\t\t\tinputs,\n\t\t\t\t\ti,\n\t\t\t\t\tkey;\n\n\t\t\t\tinputs = me.plugin.inputs;\n\n\t\t\t\t/*\n\t\t\t\tOnly reports setter/getter inputs, not methods\n\t\t\t\t*/\n\n\t\t\t\tif (name) {\n\t\t\t\t\tinput = inputs[name];\n\t\t\t\t\tif (!input || input.method) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = {\n\t\t\t\t\t\ttype: input.type,\n\t\t\t\t\t\tdefaultValue: input.defaultValue,\n\t\t\t\t\t\ttitle: input.title || name\n\t\t\t\t\t};\n\n\t\t\t\t\tif (input.type === 'number') {\n\t\t\t\t\t\tresult.min = input.min;\n\t\t\t\t\t\tresult.max = input.max;\n\t\t\t\t\t\tresult.step = input.step;\n\t\t\t\t\t\tresult.mod = input.mod;\n\t\t\t\t\t} else if (input.type === 'enum') {\n\t\t\t\t\t\t//make a copy\n\t\t\t\t\t\tresult.options = extend({}, input.options);\n\t\t\t\t\t} else if (input.type === 'vector') {\n\t\t\t\t\t\tresult.dimensions = input.dimensions;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (input.description) {\n\t\t\t\t\t\tresult.description = input.description;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tresult = {};\n\t\t\t\tfor (key in inputs) {\n\t\t\t\t\tif (inputs.hasOwnProperty(key) && !inputs[key].method) {\n\t\t\t\t\t\tresult[key] = this.inputs(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\n\t\t\tthis.alias = function (inputName, aliasName) {\n\t\t\t\tme.alias(inputName, aliasName);\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.on = function (eventName, callback) {\n\t\t\t\tme.on(eventName, callback);\n\t\t\t};\n\n\t\t\tthis.off = function (eventName, callback) {\n\t\t\t\tme.off(eventName, callback);\n\t\t\t};\n\n\t\t\tthis.destroy = function () {\n\t\t\t\tvar i,\n\t\t\t\t\tdescriptor;\n\n\t\t\t\tme.destroy();\n\n\t\t\t\tfor (i in this) {\n\t\t\t\t\tif (this.hasOwnProperty(i) && i !== 'isDestroyed' && i !== 'id') {\n\t\t\t\t\t\t//todo: probably can simplify this if the only setter/getter is id\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(this, i);\n\t\t\t\t\t\tif (descriptor.get || descriptor.set ||\n\t\t\t\t\t\t\t\ttypeof this[i] !== 'function') {\n\t\t\t\t\t\t\tdelete this[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis[i] = nop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.isDestroyed = function () {\n\t\t\t\treturn me.isDestroyed;\n\t\t\t};\n\n\t\t\tthis.isReady = function () {\n\t\t\t\treturn me.ready;\n\t\t\t};\n\t\t};\n\n\t\tTransformNode = function (hook, options) {\n\t\t\tvar key,\n\t\t\t\tinput,\n\t\t\t\tinitialValue,\n\t\t\t\tdefaultValue,\n\t\t\t\tdefaults;\n\n\t\t\tthis.matrix = new Float32Array(16);\n\t\t\tthis.cumulativeMatrix = new Float32Array(16);\n\n\t\t\tthis.ready = false;\n\t\t\tthis.width = 1;\n\t\t\tthis.height = 1;\n\n\t\t\tthis.seriously = seriously;\n\n\t\t\tthis.transformRef = seriousTransforms[hook];\n\t\t\tthis.hook = hook;\n\t\t\tthis.id = nodeId;\n\t\t\tnodeId++;\n\n\t\t\tthis.options = options;\n\t\t\tthis.sources = null;\n\t\t\tthis.targets = [];\n\t\t\tthis.inputElements = {};\n\t\t\tthis.inputs = {};\n\t\t\tthis.methods = {};\n\t\t\tthis.listeners = {};\n\n\t\t\tthis.texture = null;\n\t\t\tthis.frameBuffer = null;\n\t\t\tthis.uniforms = null;\n\n\t\t\tthis.dirty = true;\n\t\t\tthis.transformDirty = true;\n\t\t\tthis.renderDirty = false;\n\t\t\tthis.isDestroyed = false;\n\t\t\tthis.transformed = false;\n\n\t\t\tthis.plugin = extend({}, this.transformRef);\n\t\t\tif (this.transformRef.definition) {\n\t\t\t\textend(this.plugin, this.transformRef.definition.call(this, options));\n\t\t\t}\n\n\t\t\t// set up inputs and methods\n\t\t\tfor (key in this.plugin.inputs) {\n\t\t\t\tif (this.plugin.inputs.hasOwnProperty(key)) {\n\t\t\t\t\tinput = this.plugin.inputs[key];\n\n\t\t\t\t\tif (input.method && typeof input.method === 'function') {\n\t\t\t\t\t\tthis.methods[key] = input.method;\n\t\t\t\t\t} else if (typeof input.set === 'function' && typeof input.get === 'function') {\n\t\t\t\t\t\tthis.inputs[key] = input;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalidateInputSpecs(this.plugin);\n\n\t\t\t// set default value for all inputs (no defaults for methods)\n\t\t\tdefaults = defaultInputs[hook];\n\t\t\tfor (key in this.plugin.inputs) {\n\t\t\t\tif (this.plugin.inputs.hasOwnProperty(key)) {\n\t\t\t\t\tinput = this.plugin.inputs[key];\n\n\t\t\t\t\tif (typeof input.set === 'function' && typeof input.get === 'function' &&\n\t\t\t\t\t\t\ttypeof input.method !== 'function') {\n\n\t\t\t\t\t\tinitialValue = input.get.call(this);\n\t\t\t\t\t\tdefaultValue = input.defaultValue === undefined ? initialValue : input.defaultValue;\n\t\t\t\t\t\tdefaultValue = input.validate.call(this, defaultValue, input, initialValue);\n\t\t\t\t\t\tif (defaults && defaults[key] !== undefined) {\n\t\t\t\t\t\t\tdefaultValue = input.validate.call(this, defaults[key], input, input.defaultValue, defaultValue);\n\t\t\t\t\t\t\tdefaults[key] = defaultValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (defaultValue !== initialValue) {\n\t\t\t\t\t\t\tinput.set.call(this, defaultValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnodes.push(this);\n\t\t\tnodesById[this.id] = this;\n\n\t\t\tthis.pub = new Transform(this);\n\n\t\t\ttransforms.push(this);\n\n\t\t\tallTransformsByHook[hook].push(this);\n\t\t};\n\n\t\tTransformNode.prototype = Object.create(Node.prototype);\n\t\tTransformNode.prototype.constructor = TransformNode;\n\n\t\tTransformNode.prototype.setDirty = function () {\n\t\t\tthis.renderDirty = true;\n\t\t\tNode.prototype.setDirty.call(this);\n\t\t};\n\n\t\tTransformNode.prototype.setTransformDirty = function () {\n\t\t\tvar i,\n\t\t\t\ttarget;\n\t\t\tthis.transformDirty = true;\n\t\t\tthis.dirty = true;\n\t\t\tthis.renderDirty = true;\n\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\ttarget = this.targets[i];\n\t\t\t\tif (target.setTransformDirty) {\n\t\t\t\t\ttarget.setTransformDirty();\n\t\t\t\t} else {\n\t\t\t\t\ttarget.setDirty();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tTransformNode.prototype.resize = function () {\n\t\t\tvar i;\n\n\t\t\tNode.prototype.resize.call(this);\n\n\t\t\tif (this.plugin.resize) {\n\t\t\t\tthis.plugin.resize.call(this);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\tthis.targets[i].resize();\n\t\t\t}\n\n\t\t\tthis.setTransformDirty();\n\t\t};\n\n\t\tTransformNode.prototype.setSource = function (source) {\n\t\t\tvar newSource;\n\n\t\t\t//todo: what if source is null/undefined/false\n\n\t\t\tnewSource = findInputNode(source);\n\n\t\t\tif (newSource === this.source) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (traceSources(newSource, this)) {\n\t\t\t\tthrow new Error('Attempt to make cyclical connection.');\n\t\t\t}\n\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.removeTarget(this);\n\t\t\t}\n\t\t\tthis.source = newSource;\n\t\t\tnewSource.addTarget(this);\n\n\t\t\tif (newSource && newSource.ready) {\n\t\t\t\tthis.setReady();\n\t\t\t} else {\n\t\t\t\tthis.setUnready();\n\t\t\t}\n\t\t\tthis.resize();\n\t\t};\n\n\t\tTransformNode.prototype.addTarget = function (target) {\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\tif (this.targets[i] === target) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.targets.push(target);\n\t\t};\n\n\t\tTransformNode.prototype.removeTarget = function (target) {\n\t\t\tvar i = this.targets && this.targets.indexOf(target);\n\t\t\tif (i >= 0) {\n\t\t\t\tthis.targets.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (this.targets && this.targets.length) {\n\t\t\t\tthis.resize();\n\t\t\t}\n\t\t};\n\n\t\tTransformNode.prototype.setInput = function (name, value) {\n\t\t\tvar input,\n\t\t\t\tdefaultValue,\n\t\t\t\tprevious;\n\n\t\t\tif (this.plugin.inputs.hasOwnProperty(name)) {\n\t\t\t\tinput = this.plugin.inputs[name];\n\n\t\t\t\tif (defaultInputs[this.hook] && defaultInputs[this.hook][name] !== undefined) {\n\t\t\t\t\tdefaultValue = defaultInputs[this.hook][name];\n\t\t\t\t} else {\n\t\t\t\t\tdefaultValue = input.defaultValue;\n\t\t\t\t}\n\n\t\t\t\tprevious = input.get.call(this);\n\t\t\t\tif (defaultValue === undefined) {\n\t\t\t\t\tdefaultValue = previous;\n\t\t\t\t}\n\t\t\t\tvalue = input.validate.call(this, value, input, defaultValue, previous);\n\n\t\t\t\tif (input.set.call(this, value)) {\n\t\t\t\t\tthis.setTransformDirty();\n\t\t\t\t}\n\n\t\t\t\treturn input.get.call(this);\n\t\t\t}\n\t\t};\n\n\t\tTransformNode.prototype.alias = function (inputName, aliasName) {\n\t\t\tvar me = this,\n\t\t\t\tinput,\n\t\t\t\tdef;\n\n\t\t\tif (reservedNames.indexOf(aliasName) >= 0) {\n\t\t\t\tthrow new Error('\\'' + aliasName + '\\' is a reserved name and cannot be used as an alias.');\n\t\t\t}\n\n\t\t\tif (this.plugin.inputs.hasOwnProperty(inputName)) {\n\t\t\t\tif (!aliasName) {\n\t\t\t\t\taliasName = inputName;\n\t\t\t\t}\n\n\t\t\t\tseriously.removeAlias(aliasName);\n\n\t\t\t\tinput = this.inputs[inputName];\n\t\t\t\tif (input) {\n\t\t\t\t\tdef = me.inputs[inputName];\n\t\t\t\t\tObject.defineProperty(seriously, aliasName, {\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tget: function () {\n\t\t\t\t\t\t\treturn def.get.call(me);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset: function (val) {\n\t\t\t\t\t\t\tif (def.set.call(me, val)) {\n\t\t\t\t\t\t\t\tme.setTransformDirty();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tinput = this.methods[inputName];\n\t\t\t\t\tif (input) {\n\t\t\t\t\t\tdef = input;\n\t\t\t\t\t\tseriously[aliasName] = function () {\n\t\t\t\t\t\t\tif (def.apply(me, arguments)) {\n\t\t\t\t\t\t\t\tme.setTransformDirty();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (input) {\n\t\t\t\t\taliases[aliasName] = {\n\t\t\t\t\t\tnode: this,\n\t\t\t\t\t\tinput: inputName\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\tTransformNode.prototype.render = function (renderTransform) {\n\t\t\tif (!this.source) {\n\t\t\t\tif (this.transformDirty) {\n\t\t\t\t\tmat4.copy(this.cumulativeMatrix, this.matrix);\n\t\t\t\t\tthis.transformDirty = false;\n\t\t\t\t}\n\t\t\t\tthis.texture = null;\n\t\t\t\tthis.dirty = false;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.source.render();\n\n\t\t\tif (this.transformDirty) {\n\t\t\t\tif (this.transformed) {\n\t\t\t\t\t//use this.matrix\n\t\t\t\t\tif (this.source.cumulativeMatrix) {\n\t\t\t\t\t\tmat4.multiply(this.cumulativeMatrix, this.matrix, this.source.cumulativeMatrix);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmat4.copy(this.cumulativeMatrix, this.matrix);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//copy source.cumulativeMatrix\n\t\t\t\t\tmat4.copy(this.cumulativeMatrix, this.source.cumulativeMatrix || identity);\n\t\t\t\t}\n\n\t\t\t\tthis.transformDirty = false;\n\t\t\t}\n\n\t\t\tif (renderTransform && gl) {\n\t\t\t\tif (this.renderDirty) {\n\t\t\t\t\tif (!this.frameBuffer) {\n\t\t\t\t\t\tthis.uniforms = {\n\t\t\t\t\t\t\tresolution: [this.width, this.height]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.frameBuffer = new FrameBuffer(gl, this.width, this.height);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.uniforms.source = this.source.texture;\n\t\t\t\t\tthis.uniforms.transform = this.cumulativeMatrix || identity;\n\t\t\t\t\tdraw(baseShader, rectangleModel, this.uniforms, this.frameBuffer.frameBuffer, this);\n\n\t\t\t\t\tthis.renderDirty = false;\n\t\t\t\t}\n\t\t\t\tthis.texture = this.frameBuffer.texture;\n\t\t\t} else if (this.source) {\n\t\t\t\tthis.texture = this.source.texture;\n\t\t\t} else {\n\t\t\t\tthis.texture = null;\n\t\t\t}\n\n\t\t\tthis.dirty = false;\n\n\t\t\treturn this.texture;\n\t\t};\n\n\t\tTransformNode.prototype.readPixels = function (x, y, width, height, dest) {\n\t\t\tvar nodeGl = this.gl || gl;\n\n\t\t\tif (!gl) {\n\t\t\t\t//todo: is this the best approach?\n\t\t\t\tthrow new Error('Cannot read pixels until a canvas is connected');\n\t\t\t}\n\n\t\t\t//todo: check on x, y, width, height\n\t\t\tthis.render(true);\n\n\t\t\tif (dest === undefined) {\n\t\t\t\tdest = new Uint8Array(width * height * 4);\n\t\t\t} else if (!(isInstance(dest, 'Uint8Array'))) {\n\t\t\t\tthrow new Error('Incompatible array type');\n\t\t\t}\n\n\t\t\tnodeGl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer.frameBuffer);\n\t\t\tnodeGl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, dest);\n\n\t\t\treturn dest;\n\t\t};\n\n\t\tTransformNode.prototype.destroy = function () {\n\t\t\tvar i, key, item, hook = this.hook;\n\n\t\t\t//let effect destroy itself\n\t\t\tif (this.plugin.destroy && typeof this.plugin.destroy === 'function') {\n\t\t\t\tthis.plugin.destroy.call(this);\n\t\t\t}\n\t\t\tdelete this.effect;\n\n\t\t\tif (this.frameBuffer) {\n\t\t\t\tthis.frameBuffer.destroy();\n\t\t\t\tdelete this.frameBuffer;\n\t\t\t\tdelete this.texture;\n\t\t\t}\n\n\t\t\t//stop watching any input elements\n\t\t\tfor (i in this.inputElements) {\n\t\t\t\tif (this.inputElements.hasOwnProperty(i)) {\n\t\t\t\t\titem = this.inputElements[i];\n\t\t\t\t\titem.element.removeEventListener('change', item.listener, true);\n\t\t\t\t\titem.element.removeEventListener('input', item.listener, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//sources\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.removeTarget(this);\n\t\t\t}\n\n\t\t\t//targets\n\t\t\twhile (this.targets.length) {\n\t\t\t\titem = this.targets.pop();\n\t\t\t\tif (item && item.removeSource) {\n\t\t\t\t\titem.removeSource(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (key in this) {\n\t\t\t\tif (this.hasOwnProperty(key) && key !== 'id') {\n\t\t\t\t\tdelete this[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//remove any aliases\n\t\t\tfor (key in aliases) {\n\t\t\t\tif (aliases.hasOwnProperty(key)) {\n\t\t\t\t\titem = aliases[key];\n\t\t\t\t\tif (item.node === this) {\n\t\t\t\t\t\tseriously.removeAlias(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//remove self from master list of effects\n\t\t\ti = transforms.indexOf(this);\n\t\t\tif (i >= 0) {\n\t\t\t\ttransforms.splice(i, 1);\n\t\t\t}\n\n\t\t\ti = allTransformsByHook[hook].indexOf(this);\n\t\t\tif (i >= 0) {\n\t\t\t\tallTransformsByHook[hook].splice(i, 1);\n\t\t\t}\n\n\t\t\tNode.prototype.destroy.call(this);\n\t\t};\n\n\t\tTransformNode.prototype.setReady = Node.prototype.setReady;\n\t\tTransformNode.prototype.setUnready = Node.prototype.setUnready;\n\t\tTransformNode.prototype.on = Node.prototype.on;\n\t\tTransformNode.prototype.off = Node.prototype.off;\n\t\tTransformNode.prototype.emit = Node.prototype.emit;\n\n\t\t/*\n\t\tInitialize Seriously object based on options\n\t\t*/\n\n\t\tif (isInstance(options, 'HTMLCanvasElement')) {\n\t\t\toptions = {\n\t\t\t\tcanvas: options\n\t\t\t};\n\t\t} else {\n\t\t\toptions = options || {};\n\t\t}\n\n\t\tif (options.canvas) {\n\t\t}\n\n\t\t/*\n\t\tpriveleged methods\n\t\t*/\n\t\tthis.effect = function (hook, options) {\n\t\t\tif (!seriousEffects[hook]) {\n\t\t\t\tthrow new Error('Unknown effect: ' + hook);\n\t\t\t}\n\n\t\t\tvar effectNode = new EffectNode(hook, options);\n\t\t\treturn effectNode.pub;\n\t\t};\n\n\t\tthis.source = function (hook, source, options) {\n\t\t\tvar sourceNode = findInputNode(hook, source, options);\n\t\t\treturn sourceNode.pub;\n\t\t};\n\n\t\tthis.transform = function (hook, opts) {\n\t\t\tvar transformNode;\n\n\t\t\tif (typeof hook !== 'string') {\n\t\t\t\topts = hook;\n\t\t\t\thook = false;\n\t\t\t}\n\n\t\t\tif (hook) {\n\t\t\t\tif (!seriousTransforms[hook]) {\n\t\t\t\t\tthrow new Error('Unknown transform: ' + hook);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thook = options && options.defaultTransform || '2d';\n\t\t\t\tif (!seriousTransforms[hook]) {\n\t\t\t\t\tthrow new Error('No transform specified');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttransformNode = new TransformNode(hook, opts);\n\t\t\treturn transformNode.pub;\n\t\t};\n\n\t\tthis.target = function (hook, target, options) {\n\t\t\tvar targetNode,\n\t\t\t\telement,\n\t\t\t\ti;\n\n\t\t\tif (hook && typeof hook === 'string' && !seriousTargets[hook]) {\n\t\t\t\telement = document.querySelector(hook);\n\t\t\t}\n\n\t\t\tif (typeof hook !== 'string' || !target && target !== 0 || element) {\n\t\t\t\tif (!options || typeof options !== 'object') {\n\t\t\t\t\toptions = target;\n\t\t\t\t}\n\t\t\t\ttarget = element || hook;\n\t\t\t\thook = null;\n\t\t\t}\n\n\t\t\tif (typeof target === 'string' && isNaN(target)) {\n\t\t\t\ttarget = document.querySelector(target);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targets.length; i++) {\n\t\t\t\ttargetNode = targets[i];\n\t\t\t\tif ((!hook || hook === targetNode.hook) &&\n\t\t\t\t\t\t(targetNode.target === target || targetNode.compare && targetNode.compare(target, options))) {\n\n\t\t\t\t\treturn targetNode.pub;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttargetNode = new TargetNode(hook, target, options);\n\n\t\t\treturn targetNode.pub;\n\t\t};\n\n\t\tthis.aliases = function () {\n\t\t\treturn Object.keys(aliases);\n\t\t};\n\n\t\tthis.removeAlias = function (name) {\n\t\t\tif (aliases[name]) {\n\t\t\t\tdelete this[name];\n\t\t\t\tdelete aliases[name];\n\t\t\t}\n\t\t};\n\n\t\tthis.defaults = function (hook, options) {\n\t\t\tvar key;\n\n\t\t\tif (!hook) {\n\t\t\t\tif (hook === null) {\n\t\t\t\t\tfor (key in defaultInputs) {\n\t\t\t\t\t\tif (defaultInputs.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tdelete defaultInputs[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof hook === 'object') {\n\t\t\t\tfor (key in hook) {\n\t\t\t\t\tif (hook.hasOwnProperty(key)) {\n\t\t\t\t\t\tthis.defaults(key, hook[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (options === null) {\n\t\t\t\tdelete defaultInputs[hook];\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\tdefaultInputs[hook] = extend({}, options);\n\t\t\t}\n\t\t};\n\n\t\tthis.go = function (pre, post) {\n\t\t\tvar i;\n\n\t\t\tif (typeof pre === 'function' && preCallbacks.indexOf(pre) < 0) {\n\t\t\t\tpreCallbacks.push(pre);\n\t\t\t}\n\n\t\t\tif (typeof post === 'function' && postCallbacks.indexOf(post) < 0) {\n\t\t\t\tpostCallbacks.push(post);\n\t\t\t}\n\n\t\t\tauto = true;\n\t\t\tfor (i = 0; i < targets.length; i++) {\n\t\t\t\ttargets[i].go();\n\t\t\t}\n\n\t\t\tif (!rafId && (preCallbacks.length || postCallbacks.length)) {\n\t\t\t\trenderDaemon();\n\t\t\t}\n\t\t};\n\n\t\tthis.stop = function () {\n\t\t\tpreCallbacks.length = 0;\n\t\t\tpostCallbacks.length = 0;\n\t\t\tcancelAnimFrame(rafId);\n\t\t\trafId = 0;\n\t\t};\n\n\t\tthis.render = function () {\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < targets.length; i++) {\n\t\t\t\ttargets[i].render(options);\n\t\t\t}\n\t\t};\n\n\t\tthis.destroy = function () {\n\t\t\tvar i,\n\t\t\t\tnode,\n\t\t\t\tdescriptor;\n\n\t\t\twhile (nodes.length) {\n\t\t\t\tnode = nodes[0];\n\t\t\t\tnode.pub.destroy();\n\t\t\t}\n\n\t\t\tfor (i in this) {\n\t\t\t\tif (this.hasOwnProperty(i) && i !== 'isDestroyed' && i !== 'id') {\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(this, i);\n\t\t\t\t\tif (descriptor.get || descriptor.set ||\n\t\t\t\t\t\t\ttypeof this[i] !== 'function') {\n\t\t\t\t\t\tdelete this[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis[i] = nop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tseriously = null;\n\n\t\t\t//todo: do we really need to allocate new arrays here?\n\t\t\tsources = [];\n\t\t\ttargets = [];\n\t\t\teffects = [];\n\t\t\tnodes = [];\n\n\t\t\tpreCallbacks.length = 0;\n\t\t\tpostCallbacks.length = 0;\n\t\t\tcancelAnimFrame(rafId);\n\t\t\trafId = 0;\n\n\t\t\tisDestroyed = true;\n\t\t};\n\n\t\tthis.isDestroyed = function () {\n\t\t\treturn isDestroyed;\n\t\t};\n\n\t\tthis.incompatible = function (hook) {\n\t\t\tvar key,\n\t\t\t\tplugin,\n\t\t\t\tfailure = false;\n\n\t\t\tfailure = Seriously.incompatible(hook);\n\n\t\t\tif (failure) {\n\t\t\t\treturn failure;\n\t\t\t}\n\n\t\t\tif (!hook) {\n\t\t\t\tfor (key in allEffectsByHook) {\n\t\t\t\t\tif (allEffectsByHook.hasOwnProperty(key) && allEffectsByHook[key].length) {\n\t\t\t\t\t\tplugin = seriousEffects[key];\n\t\t\t\t\t\tif (plugin && typeof plugin.compatible === 'function' &&\n\t\t\t\t\t\t\t\t!plugin.compatible.call(this)) {\n\t\t\t\t\t\t\treturn 'plugin-' + key;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (key in allSourcesByHook) {\n\t\t\t\t\tif (allSourcesByHook.hasOwnProperty(key) && allSourcesByHook[key].length) {\n\t\t\t\t\t\tplugin = seriousSources[key];\n\t\t\t\t\t\tif (plugin && typeof plugin.compatible === 'function' &&\n\t\t\t\t\t\t\t\t!plugin.compatible.call(this)) {\n\t\t\t\t\t\t\treturn 'source-' + key;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\t/*\n\t\tInformational utility methods\n\t\t*/\n\n\t\tthis.isNode = function (candidate) {\n\t\t\tvar node;\n\t\t\tif (candidate) {\n\t\t\t\tnode = nodesById[candidate.id];\n\t\t\t\tif (node && !node.isDestroyed) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tthis.isSource = function (candidate) {\n\t\t\treturn this.isNode(candidate) && candidate instanceof Source;\n\t\t};\n\n\t\tthis.isEffect = function (candidate) {\n\t\t\treturn this.isNode(candidate) && candidate instanceof Effect;\n\t\t};\n\n\t\tthis.isTransform = function (candidate) {\n\t\t\treturn this.isNode(candidate) && candidate instanceof Transform;\n\t\t};\n\n\t\tthis.isTarget = function (candidate) {\n\t\t\treturn this.isNode(candidate) && candidate instanceof Target;\n\t\t};\n\n\t\tObject.defineProperties(this, {\n\t\t\tid: {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn id;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t//todo: load, save, find\n\n\t\tthis.defaults(options.defaults);\n\t}\n\n\tSeriously.incompatible = function (hook) {\n\t\tvar canvas, gl, plugin;\n\n\t\tif (incompatibility === undefined) {\n\t\t\tcanvas = document.createElement('canvas');\n\t\t\tif (!canvas || !canvas.getContext) {\n\t\t\t\tincompatibility = 'canvas';\n\t\t\t} else if (!window.WebGLRenderingContext) {\n\t\t\t\tincompatibility = 'webgl';\n\t\t\t} else {\n\t\t\t\tgl = getTestContext();\n\t\t\t\tif (!gl) {\n\t\t\t\t\tincompatibility = 'context';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (incompatibility) {\n\t\t\treturn incompatibility;\n\t\t}\n\n\t\tif (hook) {\n\t\t\tplugin = seriousEffects[hook];\n\t\t\tif (plugin && typeof plugin.compatible === 'function' &&\n\t\t\t\t!plugin.compatible(gl)) {\n\n\t\t\t\treturn 'plugin-' + hook;\n\t\t\t}\n\n\t\t\tplugin = seriousSources[hook];\n\t\t\tif (plugin && typeof plugin.compatible === 'function' &&\n\t\t\t\t!plugin.compatible(gl)) {\n\n\t\t\t\treturn 'source-' + hook;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tSeriously.plugin = function (hook, definition, meta) {\n\t\tvar effect;\n\n\t\tif (seriousEffects[hook]) {\n\t\t\tSeriously.logger.warn('Effect [' + hook + '] already loaded');\n\t\t\treturn;\n\t\t}\n\n\t\tif (meta === undefined && typeof definition === 'object') {\n\t\t\tmeta = definition;\n\t\t}\n\n\t\tif (!meta) {\n\t\t\treturn;\n\t\t}\n\n\t\teffect = extend({}, meta);\n\n\t\tif (typeof definition === 'function') {\n\t\t\teffect.definition = definition;\n\t\t}\n\n\t\teffect.reserved = reservedEffectProperties;\n\n\t\tif (effect.inputs) {\n\t\t\tvalidateInputSpecs(effect);\n\t\t}\n\n\t\tif (!effect.title) {\n\t\t\teffect.title = hook;\n\t\t}\n\n\t\t/*\n\t\tif (typeof effect.requires !== 'function') {\n\t\t\teffect.requires = false;\n\t\t}\n\t\t*/\n\n\t\tseriousEffects[hook] = effect;\n\t\tallEffectsByHook[hook] = [];\n\n\t\treturn effect;\n\t};\n\n\tSeriously.removePlugin = function (hook) {\n\t\tvar all, effect, plugin;\n\n\t\tif (!hook) {\n\t\t\treturn this;\n\t\t}\n\n\t\tplugin = seriousEffects[hook];\n\n\t\tif (!plugin) {\n\t\t\treturn this;\n\t\t}\n\n\t\tall = allEffectsByHook[hook];\n\t\tif (all) {\n\t\t\twhile (all.length) {\n\t\t\t\teffect = all.shift();\n\t\t\t\teffect.destroy();\n\t\t\t}\n\t\t\tdelete allEffectsByHook[hook];\n\t\t}\n\n\t\tdelete seriousEffects[hook];\n\n\t\treturn this;\n\t};\n\n\tSeriously.source = function (hook, definition, meta) {\n\t\tvar source;\n\n\t\tif (seriousSources[hook]) {\n\t\t\tSeriously.logger.warn('Source [' + hook + '] already loaded');\n\t\t\treturn;\n\t\t}\n\n\t\tif (meta === undefined && typeof definition === 'object') {\n\t\t\tmeta = definition;\n\t\t}\n\n\t\tif (!meta && !definition) {\n\t\t\treturn;\n\t\t}\n\n\t\tsource = extend({}, meta);\n\n\t\tif (typeof definition === 'function') {\n\t\t\tsource.definition = definition;\n\t\t}\n\n\t\tif (!source.title) {\n\t\t\tsource.title = hook;\n\t\t}\n\n\n\t\tseriousSources[hook] = source;\n\t\tallSourcesByHook[hook] = [];\n\n\t\treturn source;\n\t};\n\n\tSeriously.removeSource = function (hook) {\n\t\tvar all, source, plugin;\n\n\t\tif (!hook) {\n\t\t\treturn this;\n\t\t}\n\n\t\tplugin = seriousSources[hook];\n\n\t\tif (!plugin) {\n\t\t\treturn this;\n\t\t}\n\n\t\tall = allSourcesByHook[hook];\n\t\tif (all) {\n\t\t\twhile (all.length) {\n\t\t\t\tsource = all.shift();\n\t\t\t\tsource.destroy();\n\t\t\t}\n\t\t\tdelete allSourcesByHook[hook];\n\t\t}\n\n\t\tdelete seriousSources[hook];\n\n\t\treturn this;\n\t};\n\n\tSeriously.transform = function (hook, definition, meta) {\n\t\tvar transform;\n\n\t\tif (seriousTransforms[hook]) {\n\t\t\tSeriously.logger.warn('Transform [' + hook + '] already loaded');\n\t\t\treturn;\n\t\t}\n\n\t\tif (meta === undefined && typeof definition === 'object') {\n\t\t\tmeta = definition;\n\t\t}\n\n\t\tif (!meta && !definition) {\n\t\t\treturn;\n\t\t}\n\n\t\ttransform = extend({}, meta);\n\n\t\tif (typeof definition === 'function') {\n\t\t\ttransform.definition = definition;\n\t\t}\n\n\t\ttransform.reserved = reservedTransformProperties;\n\n\t\t//todo: validate method definitions\n\t\tif (transform.inputs) {\n\t\t\tvalidateInputSpecs(transform);\n\t\t}\n\n\t\tif (!transform.title) {\n\t\t\ttransform.title = hook;\n\t\t}\n\n\t\tseriousTransforms[hook] = transform;\n\t\tallTransformsByHook[hook] = [];\n\n\t\treturn transform;\n\t};\n\n\tSeriously.removeTransform = function (hook) {\n\t\tvar all, transform, plugin;\n\n\t\tif (!hook) {\n\t\t\treturn this;\n\t\t}\n\n\t\tplugin = seriousTransforms[hook];\n\n\t\tif (!plugin) {\n\t\t\treturn this;\n\t\t}\n\n\t\tall = allTransformsByHook[hook];\n\t\tif (all) {\n\t\t\twhile (all.length) {\n\t\t\t\ttransform = all.shift();\n\t\t\t\ttransform.destroy();\n\t\t\t}\n\t\t\tdelete allTransformsByHook[hook];\n\t\t}\n\n\t\tdelete seriousTransforms[hook];\n\n\t\treturn this;\n\t};\n\n\tSeriously.target = function (hook, definition, meta) {\n\t\tvar target;\n\n\t\tif (seriousTargets[hook]) {\n\t\t\tSeriously.logger.warn('Target [' + hook + '] already loaded');\n\t\t\treturn;\n\t\t}\n\n\t\tif (meta === undefined && typeof definition === 'object') {\n\t\t\tmeta = definition;\n\t\t}\n\n\t\tif (!meta && !definition) {\n\t\t\treturn;\n\t\t}\n\n\t\ttarget = extend({}, meta);\n\n\t\tif (typeof definition === 'function') {\n\t\t\ttarget.definition = definition;\n\t\t}\n\n\t\tif (!target.title) {\n\t\t\ttarget.title = hook;\n\t\t}\n\n\n\t\tseriousTargets[hook] = target;\n\t\tallTargetsByHook[hook] = [];\n\n\t\treturn target;\n\t};\n\n\tSeriously.removeTarget = function (hook) {\n\t\tvar all, target, plugin;\n\n\t\tif (!hook) {\n\t\t\treturn this;\n\t\t}\n\n\t\tplugin = seriousTargets[hook];\n\n\t\tif (!plugin) {\n\t\t\treturn this;\n\t\t}\n\n\t\tall = allTargetsByHook[hook];\n\t\tif (all) {\n\t\t\twhile (all.length) {\n\t\t\t\ttarget = all.shift();\n\t\t\t\ttarget.destroy();\n\t\t\t}\n\t\t\tdelete allTargetsByHook[hook];\n\t\t}\n\n\t\tdelete seriousTargets[hook];\n\n\t\treturn this;\n\t};\n\n\t//todo: validators should not allocate new objects/arrays if input is valid\n\tSeriously.inputValidators = {\n\t\tcolor: function (value, input, defaultValue, oldValue) {\n\t\t\tvar s,\n\t\t\t\ta,\n\t\t\t\tmatch,\n\t\t\t\ti;\n\n\t\t\ta = oldValue || [];\n\n\t\t\tif (typeof value === 'string') {\n\t\t\t\t//todo: support percentages, decimals\n\t\t\t\tmatch = colorRegex.exec(value);\n\t\t\t\tif (match && match.length) {\n\t\t\t\t\tif (match.length < 3) {\n\t\t\t\t\t\ta[0] = a[1] = a[2] = a[3] = 0;\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\n\t\t\t\t\ta[3] = 1;\n\t\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\t\ta[i] = parseFloat(match[i + 2]) / 255;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isNaN(match[6])) {\n\t\t\t\t\t\ta[3] = parseFloat(match[6]);\n\t\t\t\t\t}\n\t\t\t\t\tif (match[1].toLowerCase() === 'hsl') {\n\t\t\t\t\t\treturn hslToRgb(a[0], a[1], a[2], a[3], a);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\n\t\t\t\tmatch = hexColorRegex.exec(value);\n\t\t\t\tif (match && match.length) {\n\t\t\t\t\ts = match[1];\n\t\t\t\t\tif (s.length === 3) {\n\t\t\t\t\t\ta[0] = parseInt(s[0], 16) / 15;\n\t\t\t\t\t\ta[1] = parseInt(s[1], 16) / 15;\n\t\t\t\t\t\ta[2] = parseInt(s[2], 16) / 15;\n\t\t\t\t\t\ta[3] = 1;\n\t\t\t\t\t} else if (s.length === 4) {\n\t\t\t\t\t\ta[0] = parseInt(s[0], 16) / 15;\n\t\t\t\t\t\ta[1] = parseInt(s[1], 16) / 15;\n\t\t\t\t\t\ta[2] = parseInt(s[2], 16) / 15;\n\t\t\t\t\t\ta[3] = parseInt(s[3], 16) / 15;\n\t\t\t\t\t} else if (s.length === 6) {\n\t\t\t\t\t\ta[0] = parseInt(s.substr(0, 2), 16) / 255;\n\t\t\t\t\t\ta[1] = parseInt(s.substr(2, 2), 16) / 255;\n\t\t\t\t\t\ta[2] = parseInt(s.substr(4, 2), 16) / 255;\n\t\t\t\t\t\ta[3] = 1;\n\t\t\t\t\t} else if (s.length === 8) {\n\t\t\t\t\t\ta[0] = parseInt(s.substr(0, 2), 16) / 255;\n\t\t\t\t\t\ta[1] = parseInt(s.substr(2, 2), 16) / 255;\n\t\t\t\t\t\ta[2] = parseInt(s.substr(4, 2), 16) / 255;\n\t\t\t\t\t\ta[3] = parseInt(s.substr(6, 2), 16) / 255;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta[0] = a[1] = a[2] = a[3] = 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\n\t\t\t\tmatch = colorNames[value.toLowerCase()];\n\t\t\t\tif (match) {\n\t\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\t\ta[i] = match[i];\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\n\t\t\t\tif (!colorCtx) {\n\t\t\t\t\tcolorCtx = document.createElement('canvas').getContext('2d');\n\t\t\t\t}\n\t\t\t\tcolorCtx.fillStyle = value;\n\t\t\t\ts = colorCtx.fillStyle;\n\t\t\t\tif (s && s !== '#000000') {\n\t\t\t\t\treturn Seriously.inputValidators.color(s, input, defaultValue, oldValue);\n\t\t\t\t}\n\n\t\t\t\ta[0] = a[1] = a[2] = a[3] = 0;\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tif (isArrayLike(value)) {\n\t\t\t\ta = value;\n\t\t\t\tif (a.length < 3) {\n\t\t\t\t\ta[0] = a[1] = a[2] = a[3] = 0;\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\t\tif (isNaN(a[i])) {\n\t\t\t\t\t\ta[0] = a[1] = a[2] = a[3] = 0;\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a.length < 4) {\n\t\t\t\t\ta.push(1);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tif (typeof value === 'number') {\n\t\t\t\ta[0] = a[1] = a[2] = value;\n\t\t\t\ta[3] = 1;\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tif (typeof value === 'object') {\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\ts = colorFields[i];\n\t\t\t\t\tif (value[s] === null || isNaN(value[s])) {\n\t\t\t\t\t\ta[i] = i === 3 ? 1 : 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta[i] = value[s];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\ta[0] = a[1] = a[2] = a[3] = 0;\n\t\t\treturn a;\n\t\t},\n\t\tnumber: function (value, input, defaultValue) {\n\t\t\tvalue = parseFloat(value);\n\n\t\t\tif (isNaN(value)) {\n\t\t\t\treturn defaultValue || 0;\n\t\t\t}\n\n\t\t\tif (input.mod) {\n\t\t\t\tvalue = value - input.mod * Math.floor(value / input.mod);\n\t\t\t}\n\n\t\t\tif (value < input.min) {\n\t\t\t\treturn input.min;\n\t\t\t}\n\n\t\t\tif (value > input.max) {\n\t\t\t\treturn input.max;\n\t\t\t}\n\n\t\t\tif (input.step) {\n\t\t\t\treturn Math.round(value / input.step) * input.step;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\t\t'enum': function (value, input, defaultValue) {\n\t\t\tvar options = input.options || [],\n\t\t\t\ti,\n\t\t\t\topt;\n\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tvalue = value.toLowerCase();\n\t\t\t} else if (typeof value === 'number') {\n\t\t\t\tvalue = value.toString();\n\t\t\t} else if (!value) {\n\t\t\t\tvalue = '';\n\t\t\t}\n\n\t\t\tif (options.hasOwnProperty(value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\treturn defaultValue || '';\n\t\t},\n\t\tvector: function (value, input, defaultValue, oldValue) {\n\t\t\tvar a, i, s, n = input.dimensions || 4;\n\n\t\t\ta = oldValue || [];\n\t\t\tif (isArrayLike(value)) {\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\ta[i] = value[i] || 0;\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tif (typeof value === 'object') {\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\ts = vectorFields[i];\n\t\t\t\t\tif (value[s] === undefined) {\n\t\t\t\t\t\ts = colorFields[i];\n\t\t\t\t\t}\n\t\t\t\t\ta[i] = value[s] || 0;\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tvalue = parseFloat(value) || 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\ta[i] = value;\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\t\t'boolean': function (value) {\n\t\t\tif (!value) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (value && value.toLowerCase && value.toLowerCase() === 'false') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\t\t'string': function (value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (value !== 0 && !value) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tif (value.toString) {\n\t\t\t\treturn value.toString();\n\t\t\t}\n\n\t\t\treturn String(value);\n\t\t}\n\t\t//todo: date/time\n\t};\n\n\tSeriously.prototype.effects = Seriously.effects = function () {\n\t\tvar name,\n\t\t\teffect,\n\t\t\tmanifest,\n\t\t\teffects = {},\n\t\t\tinput,\n\t\t\ti;\n\n\t\tfor (name in seriousEffects) {\n\t\t\tif (seriousEffects.hasOwnProperty(name)) {\n\t\t\t\teffect = seriousEffects[name];\n\t\t\t\tmanifest = {\n\t\t\t\t\ttitle: effect.title || name,\n\t\t\t\t\tdescription: effect.description || '',\n\t\t\t\t\tinputs: {}\n\t\t\t\t};\n\n\t\t\t\tfor (i in effect.inputs) {\n\t\t\t\t\tif (effect.inputs.hasOwnProperty(i)) {\n\t\t\t\t\t\tinput = effect.inputs[i];\n\t\t\t\t\t\tmanifest.inputs[i] = {\n\t\t\t\t\t\t\ttype: input.type,\n\t\t\t\t\t\t\tdefaultValue: input.defaultValue,\n\t\t\t\t\t\t\tstep: input.step,\n\t\t\t\t\t\t\tmin: input.min,\n\t\t\t\t\t\t\tmax: input.max,\n\t\t\t\t\t\t\tmod: input.mod,\n\t\t\t\t\t\t\tminCount: input.minCount,\n\t\t\t\t\t\t\tmaxCount: input.maxCount,\n\t\t\t\t\t\t\tdimensions: input.dimensions,\n\t\t\t\t\t\t\ttitle: input.title || i,\n\t\t\t\t\t\t\tdescription: input.description || '',\n\t\t\t\t\t\t\toptions: input.options || []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\teffects[name] = manifest;\n\t\t\t}\n\t\t}\n\n\t\treturn effects;\n\t};\n\n\tif (window.Float32Array) {\n\t\tidentity = new Float32Array([\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\t\t]);\n\t}\n\n\t//check for plugins loaded out of order\n\tif (window.Seriously) {\n\t\tif (typeof window.Seriously === 'object') {\n\t\t\t(function () {\n\t\t\t\tvar i;\n\t\t\t\tfor (i in window.Seriously) {\n\t\t\t\t\tif (window.Seriously.hasOwnProperty(i) &&\n\t\t\t\t\t\ti !== 'plugin' &&\n\t\t\t\t\t\ttypeof window.Seriously[i] === 'object') {\n\n\t\t\t\t\t\tSeriously.plugin(i, window.Seriously[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}());\n\t\t}\n\t}\n\n\t/*\n\n\t*/\n\tSeriously.logger = {\n\t\tlog: consoleMethod('log'),\n\t\tinfo: consoleMethod('info'),\n\t\twarn: consoleMethod('warn'),\n\t\terror: consoleMethod('error')\n\t};\n\n\tSeriously.util = {\n\t\tmat4: mat4,\n\t\tcheckSource: checkSource,\n\t\thslToRgb: hslToRgb,\n\t\tcolors: colorNames,\n\t\tsetTimeoutZero: setTimeoutZero,\n\t\tShaderProgram: ShaderProgram,\n\t\tFrameBuffer: FrameBuffer,\n\t\trequestAnimationFrame: requestAnimationFrame,\n\t\tshader: {\n\t\t\tmakeNoise: 'float makeNoise(float u, float v, float timer) {\\n' +\n\t\t\t\t\t\t'\tfloat x = u * v * mod(timer * 1000.0, 100.0);\\n' +\n\t\t\t\t\t\t'\tx = mod(x, 13.0) * mod(x, 127.0);\\n' +\n\t\t\t\t\t\t'\tfloat dx = mod(x, 0.01);\\n' +\n\t\t\t\t\t\t'\treturn clamp(0.1 + dx * 100.0, 0.0, 1.0);\\n' +\n\t\t\t\t\t\t'}\\n',\n\t\t\trandom: '#ifndef RANDOM\\n' +\n\t\t\t\t'#define RANDOM\\n' +\n\t\t\t\t'float random(vec2 n) {\\n' +\n\t\t\t\t'\treturn 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\\n' +\n\t\t\t\t'}\\n' +\n\t\t\t\t'#endif\\n'\n\t\t}\n\t};\n\n\tSeriously.source('video', function (video, options, force) {\n\t\tvar me = this,\n\t\t\tkey,\n\t\t\topts,\n\n\t\t\tcanvas,\n\t\t\tctx2d,\n\n\t\t\tdestroyed = false,\n\t\t\tdeferTexture = false,\n\n\t\t\tisSeeking = false,\n\t\t\tlastRenderTime = 0;\n\n\t\tfunction initializeVideo() {\n\t\t\tvideo.removeEventListener('loadedmetadata', initializeVideo, true);\n\n\t\t\tif (destroyed) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (video.videoWidth) {\n\t\t\t\tif (me.width !== video.videoWidth || me.height !== video.videoHeight) {\n\t\t\t\t\tme.width = video.videoWidth;\n\t\t\t\t\tme.height = video.videoHeight;\n\t\t\t\t\tme.resize();\n\t\t\t\t}\n\n\t\t\t\tif (deferTexture) {\n\t\t\t\t\tme.setReady();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Workaround for Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=926753\n\t\t\t\tdeferTexture = true;\n\t\t\t\tsetTimeout(initializeVideo, 50);\n\t\t\t}\n\t\t}\n\n\t\tfunction seeking() {\n\t\t\t// IE doesn't report .seeking properly so make our own\n\t\t\tisSeeking = true;\n\t\t}\n\n\t\tfunction seeked() {\n\t\t\tisSeeking = false;\n\t\t\tme.setDirty();\n\t\t}\n\n\t\tif (isInstance(video, 'HTMLVideoElement')) {\n\t\t\tif (video.readyState) {\n\t\t\t\tinitializeVideo();\n\t\t\t} else {\n\t\t\t\tdeferTexture = true;\n\t\t\t\tvideo.addEventListener('loadedmetadata', initializeVideo, true);\n\t\t\t}\n\n\t\t\tvideo.addEventListener('seeking', seeking, false);\n\t\t\tvideo.addEventListener('seeked', seeked, false);\n\n\t\t\treturn {\n\t\t\t\tdeferTexture: deferTexture,\n\t\t\t\tsource: video,\n\t\t\t\trender: function renderVideo(gl) {\n\t\t\t\t\tvar source,\n\t\t\t\t\t\terror;\n\n\t\t\t\t\tlastRenderTime = video.currentTime;\n\n\t\t\t\t\tif (!video.videoHeight || !video.videoWidth) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (noVideoTextureSupport) {\n\t\t\t\t\t\tif (!ctx2d) {\n\t\t\t\t\t\t\tctx2d = document.createElement('canvas').getContext('2d');\n\t\t\t\t\t\t\tcanvas = ctx2d.canvas;\n\t\t\t\t\t\t\tcanvas.width = me.width;\n\t\t\t\t\t\t\tcanvas.height = me.height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsource = canvas;\n\t\t\t\t\t\tctx2d.drawImage(video, 0, 0, me.width, me.height);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsource = video;\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, me.texture);\n\t\t\t\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, me.flip);\n\t\t\t\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\n\n\t\t\t\t\t\t//workaround for lack of video texture support in IE\n\t\t\t\t\t\tif (noVideoTextureSupport === undefined) {\n\t\t\t\t\t\t\terror = gl.getError();\n\t\t\t\t\t\t\tif (error === gl.INVALID_VALUE) {\n\t\t\t\t\t\t\t\tnoVideoTextureSupport = true;\n\t\t\t\t\t\t\t\treturn renderVideo(gl);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnoVideoTextureSupport = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} catch (securityError) {\n\t\t\t\t\t\tif (securityError.code === window.DOMException.SECURITY_ERR) {\n\t\t\t\t\t\t\tme.allowRefresh = false;\n\t\t\t\t\t\t\tSeriously.logger.error('Unable to access cross-domain image');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSeriously.logger.error('Error rendering video source', securityError);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\tcheckDirty: function () {\n\t\t\t\t\treturn !isSeeking && video.currentTime !== lastRenderTime;\n\t\t\t\t},\n\t\t\t\tcompare: function (source) {\n\t\t\t\t\treturn me.source === source;\n\t\t\t\t},\n\t\t\t\tdestroy: function () {\n\t\t\t\t\tdestroyed = true;\n\t\t\t\t\tvideo.removeEventListener('seeking', seeking, false);\n\t\t\t\t\tvideo.removeEventListener('seeked', seeked, false);\n\t\t\t\t\tvideo.removeEventListener('loadedmetadata', initializeVideo, true);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}, {\n\t\ttitle: 'Video'\n\t});\n\n\t/*\n\tDefault transform - 2D\n\tAffine transforms\n\t- translate\n\t- rotate (degrees)\n\t- scale\n\t- skew\n\n\ttodo: move this to a different file when we have a build tool\n\t*/\n\tSeriously.transform('2d', function (options) {\n\t\tvar me = this,\n\t\t\tdegrees = !(options && options.radians),\n\n\t\t\tcenterX = 0,\n\t\t\tcenterY = 0,\n\t\t\tscaleX = 1,\n\t\t\tscaleY = 1,\n\t\t\ttranslateX = 0,\n\t\t\ttranslateY = 0,\n\t\t\trotation = 0,\n\t\t\tskewX = 0,\n\t\t\tskewY = 0;\n\n\t\t//todo: skew order\n\t\t//todo: invert?\n\n\t\tfunction recompute() {\n\t\t\tvar matrix = me.matrix,\n\t\t\t\tangle,\n\t\t\t\ts, c,\n\t\t\t\tm00,\n\t\t\t\tm01,\n\t\t\t\tm02,\n\t\t\t\tm03,\n\t\t\t\tm10,\n\t\t\t\tm11,\n\t\t\t\tm12,\n\t\t\t\tm13;\n\n\t\t\tfunction translate(x, y) {\n\t\t\t\tmatrix[12] = matrix[0] * x + matrix[4] * y + matrix[12];\n\t\t\t\tmatrix[13] = matrix[1] * x + matrix[5] * y + matrix[13];\n\t\t\t\tmatrix[14] = matrix[2] * x + matrix[6] * y + matrix[14];\n\t\t\t\tmatrix[15] = matrix[3] * x + matrix[7] * y + matrix[15];\n\t\t\t}\n\n\t\t\tif (!translateX &&\n\t\t\t\t\t!translateY &&\n\t\t\t\t\t!rotation &&\n\t\t\t\t\t!skewX &&\n\t\t\t\t\t!skewY &&\n\t\t\t\t\tscaleX === 1 &&\n\t\t\t\t\tscaleY === 1\n\t\t\t\t\t) {\n\t\t\t\tme.transformed = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//calculate transformation matrix\n\t\t\tmat4.identity(matrix);\n\n\t\t\ttranslate(translateX + centerX, translateY + centerY);\n\n\t\t\t//skew\n\t\t\tif (skewX) {\n\t\t\t\tmatrix[4] = skewX / me.width;\n\t\t\t}\n\t\t\tif (skewY) {\n\t\t\t\tmatrix[1] = skewY / me.height;\n\t\t\t}\n\n\t\t\tif (rotation) {\n\t\t\t\tm00 = matrix[0];\n\t\t\t\tm01 = matrix[1];\n\t\t\t\tm02 = matrix[2];\n\t\t\t\tm03 = matrix[3];\n\t\t\t\tm10 = matrix[4];\n\t\t\t\tm11 = matrix[5];\n\t\t\t\tm12 = matrix[6];\n\t\t\t\tm13 = matrix[7];\n\n\t\t\t\t//rotate\n\t\t\t\tangle = -(degrees ? rotation * Math.PI / 180 : rotation);\n\t\t\t\t//...rotate\n\t\t\t\ts = Math.sin(angle);\n\t\t\t\tc = Math.cos(angle);\n\t\t\t\tmatrix[0] = m00 * c + m10 * s;\n\t\t\t\tmatrix[1] = m01 * c + m11 * s;\n\t\t\t\tmatrix[2] = m02 * c + m12 * s;\n\t\t\t\tmatrix[3] = m03 * c + m13 * s;\n\t\t\t\tmatrix[4] = m10 * c - m00 * s;\n\t\t\t\tmatrix[5] = m11 * c - m01 * s;\n\t\t\t\tmatrix[6] = m12 * c - m02 * s;\n\t\t\t\tmatrix[7] = m13 * c - m03 * s;\n\t\t\t}\n\n\t\t\t//scale\n\t\t\tif (scaleX !== 1) {\n\t\t\t\tmatrix[0] *= scaleX;\n\t\t\t\tmatrix[1] *= scaleX;\n\t\t\t\tmatrix[2] *= scaleX;\n\t\t\t\tmatrix[3] *= scaleX;\n\t\t\t}\n\t\t\tif (scaleY !== 1) {\n\t\t\t\tmatrix[4] *= scaleY;\n\t\t\t\tmatrix[5] *= scaleY;\n\t\t\t\tmatrix[6] *= scaleY;\n\t\t\t\tmatrix[7] *= scaleY;\n\t\t\t}\n\n\t\t\ttranslate(-centerX, -centerY);\n\n\t\t\tme.transformed = true;\n\t\t}\n\n\t\treturn {\n\t\t\tinputs: {\n\t\t\t\treset: {\n\t\t\t\t\tmethod: function () {\n\t\t\t\t\t\tcenterX = 0;\n\t\t\t\t\t\tcenterY = 0;\n\t\t\t\t\t\tscaleX = 1;\n\t\t\t\t\t\tscaleY = 1;\n\t\t\t\t\t\ttranslateX = 0;\n\t\t\t\t\t\ttranslateY = 0;\n\t\t\t\t\t\trotation = 0;\n\t\t\t\t\t\tskewX = 0;\n\t\t\t\t\t\tskewY = 0;\n\n\t\t\t\t\t\tif (me.transformed) {\n\t\t\t\t\t\t\tme.transformed = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\ttranslate: {\n\t\t\t\t\tmethod: function (x, y) {\n\t\t\t\t\t\tif (isNaN(x)) {\n\t\t\t\t\t\t\tx = translateX;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isNaN(y)) {\n\t\t\t\t\t\t\ty = translateY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (x === translateX && y === translateY) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttranslateX = x;\n\t\t\t\t\t\ttranslateY = y;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: [\n\t\t\t\t\t\t'number',\n\t\t\t\t\t\t'number'\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\ttranslateX: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn translateX;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (x) {\n\t\t\t\t\t\tif (x === translateX) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttranslateX = x;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\ttranslateY: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn translateY;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (y) {\n\t\t\t\t\t\tif (y === translateY) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttranslateY = y;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\trotation: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn rotation;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (angle) {\n\t\t\t\t\t\tif (angle === rotation) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//todo: fmod 360deg or Math.PI * 2 radians\n\t\t\t\t\t\trotation = parseFloat(angle);\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\tcenter: {\n\t\t\t\t\tmethod: function (x, y) {\n\t\t\t\t\t\tif (isNaN(x)) {\n\t\t\t\t\t\t\tx = centerX;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isNaN(y)) {\n\t\t\t\t\t\t\ty = centerY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (x === centerX && y === centerY) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcenterX = x;\n\t\t\t\t\t\tcenterY = y;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: [\n\t\t\t\t\t\t'number',\n\t\t\t\t\t\t'number'\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tcenterX: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn centerX;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (x) {\n\t\t\t\t\t\tif (x === centerX) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcenterX = x;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\tcenterY: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn centerY;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (y) {\n\t\t\t\t\t\tif (y === centerY) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcenterY = y;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\tskew: {\n\t\t\t\t\tmethod: function (x, y) {\n\t\t\t\t\t\tif (isNaN(x)) {\n\t\t\t\t\t\t\tx = skewX;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isNaN(y)) {\n\t\t\t\t\t\t\ty = skewY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (x === skewX && y === skewY) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tskewX = x;\n\t\t\t\t\t\tskewY = y;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: [\n\t\t\t\t\t\t'number',\n\t\t\t\t\t\t'number'\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tskewX: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn skewX;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (x) {\n\t\t\t\t\t\tif (x === skewX) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tskewX = x;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\tskewY: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn skewY;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (y) {\n\t\t\t\t\t\tif (y === skewY) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tskewY = y;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\tscale: {\n\t\t\t\t\tmethod: function (x, y) {\n\t\t\t\t\t\tvar newX, newY;\n\n\t\t\t\t\t\tif (isNaN(x)) {\n\t\t\t\t\t\t\tnewX = scaleX;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewX = x;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif only one value is specified, set both x and y to the same scale\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (isNaN(y)) {\n\t\t\t\t\t\t\tif (isNaN(x)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnewY = newX;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewY = y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (newX === scaleX && newY === scaleY) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscaleX = newX;\n\t\t\t\t\t\tscaleY = newY;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: [\n\t\t\t\t\t\t'number',\n\t\t\t\t\t\t'number'\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tscaleX: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn scaleX;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (x) {\n\t\t\t\t\t\tif (x === scaleX) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscaleX = x;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\tscaleY: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn scaleY;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (y) {\n\t\t\t\t\t\tif (y === scaleY) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscaleY = y;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, {\n\t\ttitle: '2D Transform',\n\t\tdescription: 'Translate, Rotate, Scale, Skew'\n\t});\n\n\t/*\n\ttodo: move this to a different file when we have a build tool\n\t*/\n\tSeriously.transform('flip', function () {\n\t\tvar me = this,\n\t\t\thorizontal = true;\n\n\t\tfunction recompute() {\n\t\t\tvar matrix = me.matrix;\n\n\t\t\t//calculate transformation matrix\n\t\t\t//mat4.identity(matrix);\n\n\t\t\t//scale\n\t\t\tif (horizontal) {\n\t\t\t\tmatrix[0] = -1;\n\t\t\t\tmatrix[5] = 1;\n\t\t\t} else {\n\t\t\t\tmatrix[0] = 1;\n\t\t\t\tmatrix[5] = -1;\n\t\t\t}\n\t\t}\n\n\t\tmat4.identity(me.matrix);\n\t\trecompute();\n\n\t\tme.transformDirty = true;\n\n\t\tme.transformed = true;\n\n\t\treturn {\n\t\t\tinputs: {\n\t\t\t\tdirection: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn horizontal ? 'horizontal' : 'vertical';\n\t\t\t\t\t},\n\t\t\t\t\tset: function (d) {\n\t\t\t\t\t\tvar horiz;\n\t\t\t\t\t\tif (d === 'vertical') {\n\t\t\t\t\t\t\thoriz = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thoriz = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (horiz === horizontal) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thorizontal = horiz;\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'string'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, {\n\t\ttitle: 'Flip',\n\t\tdescription: 'Flip Horizontal/Vertical'\n\t});\n\n\t/*\n\tReformat\n\ttodo: move this to a different file when we have a build tool\n\t*/\n\tSeriously.transform('reformat', function () {\n\t\tvar me = this,\n\t\t\tforceWidth,\n\t\t\tforceHeight,\n\t\t\tmode = 'contain';\n\n\t\tfunction recompute() {\n\t\t\tvar matrix = me.matrix,\n\t\t\t\twidth = forceWidth || me.width,\n\t\t\t\theight = forceHeight || me.height,\n\t\t\t\tscaleX,\n\t\t\t\tscaleY,\n\t\t\t\tsource = me.source,\n\t\t\t\tsourceWidth = source && source.width || 1,\n\t\t\t\tsourceHeight = source && source.height || 1,\n\t\t\t\taspectIn,\n\t\t\t\taspectOut;\n\n\t\t\tif (mode === 'distort' || width === sourceWidth && height === sourceHeight) {\n\t\t\t\tme.transformed = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taspectIn = sourceWidth / sourceHeight;\n\n\t\t\taspectOut = width / height;\n\n\t\t\tif (mode === 'none') {\n\t\t\t\tscaleX = sourceWidth / width;\n\t\t\t\tscaleY = sourceHeight / height;\n\t\t\t} else if (mode === 'width' || mode === 'contain' && aspectOut <= aspectIn) {\n\t\t\t\tscaleX = 1;\n\t\t\t\tscaleY = aspectOut / aspectIn;\n\t\t\t} else if (mode === 'height' || mode === 'contain' && aspectOut > aspectIn) {\n\t\t\t\tscaleX = aspectIn / aspectOut;\n\t\t\t\tscaleY = 1;\n\t\t\t} else {\n\t\t\t\t//mode === 'cover'\n\t\t\t\tif (aspectOut > aspectIn) {\n\t\t\t\t\tscaleX = 1;\n\t\t\t\t\tscaleY = aspectOut / aspectIn;\n\t\t\t\t} else {\n\t\t\t\t\tscaleX = aspectIn / aspectOut;\n\t\t\t\t\tscaleY = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (scaleX === 1 && scaleY === 1) {\n\t\t\t\tme.transformed = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//calculate transformation matrix\n\t\t\tmat4.identity(matrix);\n\n\t\t\t//scale\n\t\t\tif (scaleX !== 1) {\n\t\t\t\tmatrix[0] *= scaleX;\n\t\t\t\tmatrix[1] *= scaleX;\n\t\t\t\tmatrix[2] *= scaleX;\n\t\t\t\tmatrix[3] *= scaleX;\n\t\t\t}\n\t\t\tif (scaleY !== 1) {\n\t\t\t\tmatrix[4] *= scaleY;\n\t\t\t\tmatrix[5] *= scaleY;\n\t\t\t\tmatrix[6] *= scaleY;\n\t\t\t\tmatrix[7] *= scaleY;\n\t\t\t}\n\t\t\tme.transformed = true;\n\t\t}\n\n\t\tfunction getWidth() {\n\t\t\treturn forceWidth || me.source && me.source.width || 1;\n\t\t}\n\n\t\tfunction getHeight() {\n\t\t\treturn forceHeight || me.source && me.source.height || 1;\n\t\t}\n\n\t\tthis.resize = function () {\n\t\t\tvar width = getWidth(),\n\t\t\t\theight = getHeight(),\n\t\t\t\ti;\n\n\t\t\tif (this.width !== width || this.height !== height) {\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tif (this.uniforms && this.uniforms.resolution) {\n\t\t\t\t\tthis.uniforms.resolution[0] = width;\n\t\t\t\t\tthis.uniforms.resolution[1] = height;\n\t\t\t\t}\n\n\t\t\t\tif (this.frameBuffer && this.frameBuffer.resize) {\n\t\t\t\t\tthis.frameBuffer.resize(width, height);\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < this.targets.length; i++) {\n\t\t\t\t\tthis.targets[i].resize();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setTransformDirty();\n\n\t\t\trecompute();\n\t\t};\n\n\t\treturn {\n\t\t\tinputs: {\n\t\t\t\twidth: {\n\t\t\t\t\tget: getWidth,\n\t\t\t\t\tset: function (x) {\n\t\t\t\t\t\tx = Math.floor(x);\n\t\t\t\t\t\tif (x === forceWidth) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tforceWidth = x;\n\n\t\t\t\t\t\tthis.resize();\n\n\t\t\t\t\t\t//don't need to run setTransformDirty again\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\theight: {\n\t\t\t\t\tget: getHeight,\n\t\t\t\t\tset: function (y) {\n\t\t\t\t\t\ty = Math.floor(y);\n\t\t\t\t\t\tif (y === forceHeight) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tforceHeight = y;\n\n\t\t\t\t\t\tthis.resize();\n\n\t\t\t\t\t\t//don't need to run setTransformDirty again\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'number'\n\t\t\t\t},\n\t\t\t\tmode: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn mode;\n\t\t\t\t\t},\n\t\t\t\t\tset: function (m) {\n\t\t\t\t\t\tif (m === mode) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmode = m;\n\n\t\t\t\t\t\trecompute();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'enum',\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t'cover',\n\t\t\t\t\t\t'contain',\n\t\t\t\t\t\t'distort',\n\t\t\t\t\t\t'width',\n\t\t\t\t\t\t'height',\n\t\t\t\t\t\t'none'\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, {\n\t\ttitle: 'Reformat',\n\t\tdescription: 'Change output dimensions'\n\t});\n\n\t/*\n\ttodo: additional transform node types\n\t- perspective\n\t- matrix\n\t*/\n\n\tbaseVertexShader = [\n\t\t'precision mediump float;',\n\n\t\t'attribute vec4 position;',\n\t\t'attribute vec2 texCoord;',\n\n\t\t'uniform vec2 resolution;',\n\t\t'uniform mat4 transform;',\n\n\t\t'varying vec2 vTexCoord;',\n\n\t\t'void main(void) {',\n\t\t// first convert to screen space\n\t\t'\tvec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',\n\t\t'\tscreenPosition = transform * screenPosition;',\n\n\t\t// convert back to OpenGL coords\n\t\t'\tgl_Position.xy = screenPosition.xy * 2.0 / resolution;',\n\t\t'\tgl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',\n\t\t'\tgl_Position.w = screenPosition.w;',\n\t\t'\tvTexCoord = texCoord;',\n\t\t'}\\n'\n\t].join('\\n');\n\n\tbaseFragmentShader = [\n\t\t'precision mediump float;',\n\n\t\t'varying vec2 vTexCoord;',\n\n\t\t'uniform sampler2D source;',\n\n\t\t'void main(void) {',\n\t\t/*\n\t\t'\tif (any(lessThan(vTexCoord, vec2(0.0))) || any(greaterThanEqual(vTexCoord, vec2(1.0)))) {',\n\t\t'\t\tgl_FragColor = vec4(0.0);',\n\t\t'\t} else {',\n\t\t*/\n\t\t'\t\tgl_FragColor = texture2D(source, vTexCoord);',\n\t\t//'\t}',\n\t\t'}'\n\t].join('\\n');\n\n\t/*\n\t * simplex noise shaders\n\t * https://github.com/ashima/webgl-noise\n\t * Copyright (C) 2011 by Ashima Arts (Simplex noise)\n\t * Copyright (C) 2011 by Stefan Gustavson (Classic noise)\n\t */\n\n\tSeriously.util.shader.noiseHelpers = '#ifndef NOISE_HELPERS\\n' +\n\t\t'#define NOISE_HELPERS\\n' +\n\t\t'vec2 mod289(vec2 x) {\\n' +\n\t\t'\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\\n' +\n\t\t'}\\n' +\n\t\t'vec3 mod289(vec3 x) {\\n' +\n\t\t'\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\\n' +\n\t\t'}\\n' +\n\t\t'vec4 mod289(vec4 x) {\\n' +\n\t\t'\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\\n' +\n\t\t'}\\n' +\n\t\t'vec3 permute(vec3 x) {\\n' +\n\t\t'\treturn mod289(((x*34.0)+1.0)*x);\\n' +\n\t\t'}\\n' +\n\t\t'vec4 permute(vec4 x) {\\n' +\n\t\t'\treturn mod289(((x*34.0)+1.0)*x);\\n' +\n\t\t'}\\n' +\n\t\t'vec4 taylorInvSqrt(vec4 r) {\\n' +\n\t\t'\treturn 1.79284291400159 - 0.85373472095314 * r;\\n' +\n\t\t'}\\n' +\n\t\t'float taylorInvSqrt(float r) {\\n' +\n\t\t'\treturn 1.79284291400159 - 0.85373472095314 * r;\\n' +\n\t\t'}\\n' +\n\t\t'#endif\\n';\n\n\tSeriously.util.shader.snoise2d = '#ifndef NOISE2D\\n' +\n\t\t'#define NOISE2D\\n' +\n\t\t'float snoise(vec2 v) {\\n' +\n\t\t'\tconst vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\\n' +\n\t\t'\t\t0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\\n' +\n\t\t'\t\t-0.577350269189626, // -1.0 + 2.0 * C.x\\n' +\n\t\t'\t\t0.024390243902439); // 1.0 / 41.0\\n' +\n\t\t'\tvec2 i = floor(v + dot(v, C.yy));\\n' +\n\t\t'\tvec2 x0 = v - i + dot(i, C.xx);\\n' +\n\t\t'\tvec2 i1;\\n' +\n\t\t'\t//i1.x = step(x0.y, x0.x); // x0.x > x0.y ? 1.0 : 0.0\\n' +\n\t\t'\t//i1.y = 1.0 - i1.x;\\n' +\n\t\t'\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n' +\n\t\t'\t// x0 = x0 - 0.0 + 0.0 * C.xx ;\\n' +\n\t\t'\t// x1 = x0 - i1 + 1.0 * C.xx ;\\n' +\n\t\t'\t// x2 = x0 - 1.0 + 2.0 * C.xx ;\\n' +\n\t\t'\tvec4 x12 = x0.xyxy + C.xxzz;\\n' +\n\t\t'\tx12.xy -= i1;\\n' +\n\t\t'\ti = mod289(i); // Avoid truncation effects in permutation\\n' +\n\t\t'\tvec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\\n' +\n\t\t'\tvec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\\n' +\n\t\t'\tm = m*m ;\\n' +\n\t\t'\tm = m*m ;\\n' +\n\t\t'\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\\n' +\n\t\t'\tvec3 h = abs(x) - 0.5;\\n' +\n\t\t'\tvec3 ox = floor(x + 0.5);\\n' +\n\t\t'\tvec3 a0 = x - ox;\\n' +\n\t\t'\tm *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\\n' +\n\t\t'\tvec3 g;\\n' +\n\t\t'\tg.x = a0.x * x0.x + h.x * x0.y;\\n' +\n\t\t'\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n' +\n\t\t'\treturn 130.0 * dot(m, g);\\n' +\n\t\t'}\\n' +\n\t\t'#endif\\n';\n\n\tSeriously.util.shader.snoise3d = '#ifndef NOISE3D\\n' +\n\t\t'#define NOISE3D\\n' +\n\t\t'float snoise(vec3 v) {\\n' +\n\t\t'\tconst vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\\n' +\n\t\t'\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\\n' +\n\n\t\t// First corner\n\t\t'\tvec3 i = floor(v + dot(v, C.yyy));\\n' +\n\t\t'\tvec3 x0 = v - i + dot(i, C.xxx) ;\\n' +\n\n\t\t// Other corners\n\t\t'\tvec3 g = step(x0.yzx, x0.xyz);\\n' +\n\t\t'\tvec3 l = 1.0 - g;\\n' +\n\t\t'\tvec3 i1 = min(g.xyz, l.zxy);\\n' +\n\t\t'\tvec3 i2 = max(g.xyz, l.zxy);\\n' +\n\n\t\t'\t// x0 = x0 - 0.0 + 0.0 * C.xxx;\\n' +\n\t\t'\t// x1 = x0 - i1 + 1.0 * C.xxx;\\n' +\n\t\t'\t// x2 = x0 - i2 + 2.0 * C.xxx;\\n' +\n\t\t'\t// x3 = x0 - 1.0 + 3.0 * C.xxx;\\n' +\n\t\t'\tvec3 x1 = x0 - i1 + C.xxx;\\n' +\n\t\t'\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n' +\n\t\t'\tvec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\\n' +\n\n\t\t// Permutations\n\t\t'\ti = mod289(i);\\n' +\n\t\t'\tvec4 p = permute(permute(permute(\\n' +\n\t\t'\t\t\t\t\t\ti.z + vec4(0.0, i1.z, i2.z, 1.0))\\n' +\n\t\t'\t\t\t\t\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0))\\n' +\n\t\t'\t\t\t\t\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0));\\n' +\n\n\t\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t\t'\tfloat n_ = 0.142857142857; // 1.0/7.0\\n' +\n\t\t'\tvec3 ns = n_ * D.wyz - D.xzx;\\n' +\n\n\t\t'\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p, 7 * 7)\\n' +\n\n\t\t'\tvec4 x_ = floor(j * ns.z);\\n' +\n\t\t'\tvec4 y_ = floor(j - 7.0 * x_); // mod(j, N)\\n' +\n\n\t\t'\tvec4 x = x_ * ns.x + ns.yyyy;\\n' +\n\t\t'\tvec4 y = y_ * ns.x + ns.yyyy;\\n' +\n\t\t'\tvec4 h = 1.0 - abs(x) - abs(y);\\n' +\n\n\t\t'\tvec4 b0 = vec4(x.xy, y.xy);\\n' +\n\t\t'\tvec4 b1 = vec4(x.zw, y.zw);\\n' +\n\n\t\t'\t//vec4 s0 = vec4(lessThan(b0, 0.0)) * 2.0 - 1.0;\\n' +\n\t\t'\t//vec4 s1 = vec4(lessThan(b1, 0.0)) * 2.0 - 1.0;\\n' +\n\t\t'\tvec4 s0 = floor(b0) * 2.0 + 1.0;\\n' +\n\t\t'\tvec4 s1 = floor(b1) * 2.0 + 1.0;\\n' +\n\t\t'\tvec4 sh = -step(h, vec4(0.0));\\n' +\n\n\t\t'\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\\n' +\n\t\t'\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\\n' +\n\n\t\t'\tvec3 p0 = vec3(a0.xy, h.x);\\n' +\n\t\t'\tvec3 p1 = vec3(a0.zw, h.y);\\n' +\n\t\t'\tvec3 p2 = vec3(a1.xy, h.z);\\n' +\n\t\t'\tvec3 p3 = vec3(a1.zw, h.w);\\n' +\n\n\t\t//Normalise gradients\n\t\t'\tvec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\\n' +\n\t\t'\tp0 *= norm.x;\\n' +\n\t\t'\tp1 *= norm.y;\\n' +\n\t\t'\tp2 *= norm.z;\\n' +\n\t\t'\tp3 *= norm.w;\\n' +\n\n\t\t// Mix final noise value\n\t\t'\tvec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\\n' +\n\t\t'\tm = m * m;\\n' +\n\t\t'\treturn 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\\n' +\n\t\t'}\\n' +\n\t\t'#endif\\n';\n\n\tSeriously.util.shader.snoise4d = '#ifndef NOISE4D\\n' +\n\t\t'#define NOISE4D\\n' +\n\t\t'vec4 grad4(float j, vec4 ip)\\n' +\n\t\t'\t{\\n' +\n\t\t'\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\\n' +\n\t\t'\tvec4 p, s;\\n' +\n\t\t'\\n' +\n\t\t'\tp.xyz = floor(fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\\n' +\n\t\t'\tp.w = 1.5 - dot(abs(p.xyz), ones.xyz);\\n' +\n\t\t'\ts = vec4(lessThan(p, vec4(0.0)));\\n' +\n\t\t'\tp.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\\n' +\n\t\t'\\n' +\n\t\t'\treturn p;\\n' +\n\t\t'\t}\\n' +\n\t\t'\\n' +\n\t\t// (sqrt(5) - 1)/4 = F4, used once below\\n\n\t\t'#define F4 0.309016994374947451\\n' +\n\t\t'\\n' +\n\t\t'float snoise(vec4 v)\\n' +\n\t\t'\t{\\n' +\n\t\t'\tconst vec4 C = vec4(0.138196601125011, // (5 - sqrt(5))/20 G4\\n' +\n\t\t'\t\t\t\t\t\t0.276393202250021, // 2 * G4\\n' +\n\t\t'\t\t\t\t\t\t0.414589803375032, // 3 * G4\\n' +\n\t\t'\t\t\t\t\t\t-0.447213595499958); // -1 + 4 * G4\\n' +\n\t\t'\\n' +\n\t\t// First corner\n\t\t'\tvec4 i = floor(v + dot(v, vec4(F4)));\\n' +\n\t\t'\tvec4 x0 = v - i + dot(i, C.xxxx);\\n' +\n\t\t'\\n' +\n\t\t// Other corners\n\t\t'\\n' +\n\t\t// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\t\t'\tvec4 i0;\\n' +\n\t\t'\tvec3 isX = step(x0.yzw, x0.xxx);\\n' +\n\t\t'\tvec3 isYZ = step(x0.zww, x0.yyz);\\n' +\n\t\t// i0.x = dot(isX, vec3(1.0));\n\t\t'\ti0.x = isX.x + isX.y + isX.z;\\n' +\n\t\t'\ti0.yzw = 1.0 - isX;\\n' +\n\t\t// i0.y += dot(isYZ.xy, vec2(1.0));\n\t\t'\ti0.y += isYZ.x + isYZ.y;\\n' +\n\t\t'\ti0.zw += 1.0 - isYZ.xy;\\n' +\n\t\t'\ti0.z += isYZ.z;\\n' +\n\t\t'\ti0.w += 1.0 - isYZ.z;\\n' +\n\t\t'\\n' +\n\t\t\t// i0 now contains the unique values 0, 1, 2, 3 in each channel\n\t\t'\tvec4 i3 = clamp(i0, 0.0, 1.0);\\n' +\n\t\t'\tvec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\\n' +\n\t\t'\tvec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\\n' +\n\t\t'\\n' +\n\t\t'\tvec4 x1 = x0 - i1 + C.xxxx;\\n' +\n\t\t'\tvec4 x2 = x0 - i2 + C.yyyy;\\n' +\n\t\t'\tvec4 x3 = x0 - i3 + C.zzzz;\\n' +\n\t\t'\tvec4 x4 = x0 + C.wwww;\\n' +\n\t\t'\\n' +\n\t\t// Permutations\n\t\t'\ti = mod289(i);\\n' +\n\t\t'\tfloat j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\\n' +\n\t\t'\tvec4 j1 = permute(permute(permute(permute (\\n' +\n\t\t'\t\t\t\t\ti.w + vec4(i1.w, i2.w, i3.w, 1.0))\\n' +\n\t\t'\t\t\t\t\t+ i.z + vec4(i1.z, i2.z, i3.z, 1.0))\\n' +\n\t\t'\t\t\t\t\t+ i.y + vec4(i1.y, i2.y, i3.y, 1.0))\\n' +\n\t\t'\t\t\t\t\t+ i.x + vec4(i1.x, i2.x, i3.x, 1.0));\\n' +\n\t\t'\\n' +\n\t\t// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n\t\t// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\t\t'\tvec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\\n' +\n\t\t'\\n' +\n\t\t'\tvec4 p0 = grad4(j0, ip);\\n' +\n\t\t'\tvec4 p1 = grad4(j1.x, ip);\\n' +\n\t\t'\tvec4 p2 = grad4(j1.y, ip);\\n' +\n\t\t'\tvec4 p3 = grad4(j1.z, ip);\\n' +\n\t\t'\tvec4 p4 = grad4(j1.w, ip);\\n' +\n\t\t'\\n' +\n\t\t// Normalise gradients\n\t\t'\tvec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\\n' +\n\t\t'\tp0 *= norm.x;\\n' +\n\t\t'\tp1 *= norm.y;\\n' +\n\t\t'\tp2 *= norm.z;\\n' +\n\t\t'\tp3 *= norm.w;\\n' +\n\t\t'\tp4 *= taylorInvSqrt(dot(p4, p4));\\n' +\n\t\t'\\n' +\n\t\t// Mix contributions from the five corners\n\t\t'\tvec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\\n' +\n\t\t'\tvec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\\n' +\n\t\t'\tm0 = m0 * m0;\\n' +\n\t\t'\tm1 = m1 * m1;\\n' +\n\t\t'\treturn 49.0 * (dot(m0*m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2)))\\n' +\n\t\t'\t\t\t\t\t\t\t+ dot(m1*m1, vec2(dot(p3, x3), dot(p4, x4)))) ;\\n' +\n\t\t'}\\n' +\n\t\t'#endif\\n';\n\n\treturn Seriously;\n}));\n"
        },
        {
          "name": "sources",
          "type": "tree",
          "content": null
        },
        {
          "name": "targets",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "transforms",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}