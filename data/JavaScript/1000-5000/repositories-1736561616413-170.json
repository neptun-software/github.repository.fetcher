{
  "metadata": {
    "timestamp": 1736561616413,
    "page": 170,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "felipe-augusto/clean-code-javascript",
      "stars": 4489,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.06640625,
          "content": "*.md linguist-documentation=false\n*.md linguist-language=JavaScript\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.068359375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017 Ryan McDermott, Felipe Santos\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 57.580078125,
          "content": "Repositório original: [ryanmcdermott/clean-code-javascript](https://github.com/ryanmcdermott/clean-code-javascript)\n\n# clean-code-javascript\n\n## Índice\n  1. [Introdução](#introdução)\n  2. [Variáveis](#variáveis)\n  3. [Funções](#funções)\n  4. [Objetos e Estruturas de Dados](#objetos-e-estruturas-de-dados)\n  5. [Classes](#classes)\n  6. [SOLID](#solid)\n  7. [Testes](#testes)\n  8. [Concorrência](#concorrência)\n  9. [Tratamento de Erros](#tratamento-de-erros)\n  10. [Formatação](#formatação)\n  11. [Comentários](#comentários)\n  12. [Traduções](#traduções)\n\n## Introdução\n![Imagem humorística da estimativa de qualidade do software baseado na contagem de quantos palavrões você gritou enquanto lia o código.](http://www.osnews.com/images/comics/wtfm.jpg)\n\nPrincípios da Engenharia de Software, do livro de Robert C. Martin\n[*Código Limpo*](https://www.amazon.com.br/C%C3%B3digo-Limpo-Habilidades-Pr%C3%A1ticas-Software/dp/8576082675),\nadaptados para JavaScript. Isto não é um guia de estilos. É um guia para se produzir código [legível, reutilizável e refatorável](https://github.com/ryanmcdermott/3rs-of-software-architecture) em JavaScript.\n\nNem todo princípio demonstrado deve ser seguido rigorosamente, e ainda menos são um consenso universal. Estes princípios são orientações e nada mais, entretanto, foram codificados durante muitos anos de experiência coletiva pelos autores de *Código limpo*.\n\nNosso ofício de engenharia de software tem pouco mais de 50 anos e ainda estamos aprendendo muito. Quando a arquitetura de software for tão velha quanto a própria arquitetura, talvez então tenhamos regras mais rígidas para seguir. Por enquanto, deixe que estas orientações sirvam como critério para se avaliar a qualidade de código JavaScript que tanto você e o seu time produzirem.\n\nMais uma coisa: aprender isto não irá lhe transformar imediatamente em um desenvolvedor de software melhor, trabalhar com eles por muitos anos não quer dizer que você não cometerá erros. Toda porção de código começa com um rascunho, como argila molhada sendo moldada em sua forma final. Finalmente, talhamos as imperfeições quando revisamos com nossos colegas. Não se sinta culpado pelos primeiros rascunhos que ainda precisam de melhorias. Ao invés, desconte em seu código.\n\n## **Variáveis**\n### Use nomes de variáveis que tenham significado e sejam pronunciáveis\n\n**Ruim:**\n```javascript\nconst yyyymmdstr = moment().format('YYYY/MM/DD');\n```\n\n**Bom:**\n```javascript\nconst currentDate = moment().format('YYYY/MM/DD');\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Use o mesmo vocabulário para o mesmo tipo de variável\n\n**Ruim:**\n```javascript\ngetUserInfo();\ngetClientData();\ngetCustomerRecord();\n```\n\n**Bom:**\n```javascript\ngetUser();\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Use nomes pesquisáveis\nNós iremos ler mais código que escrever. É importante que o código que escrevemos seja legível e pesquisável. *Não* dando nomes em variáveis que sejam significativos para entender nosso programa, machucamos nossos leitores. Torne seus nomes pesquisáveis. Ferramentas como [buddy.js](https://github.com/danielstjules/buddy.js) e [ESLint](https://github.com/eslint/eslint/blob/660e0918933e6e7fede26bc675a0763a6b357c94/docs/rules/no-magic-numbers.md) podem ajudar a identificar constantes sem nome.\n\n**Ruim:**\n```javascript\n// Para que diabos serve 86400000?\nsetTimeout(blastOff, 86400000);\n\n```\n\n**Bom:**\n```javascript\n// Declare-as como `const` global em letras maiúsculas.\nconst MILLISECONDS_PER_DAY = 86400000;\n\nsetTimeout(blastOff, MILLISECONDS_PER_DAY);\n\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Use variáveis explicativas\n**Ruim:**\n```javascript\nconst address = 'One Infinite Loop, Cupertino 95014';\nconst cityZipCodeRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/;\nsaveCityZipCode(address.match(cityZipCodeRegex)[1], address.match(cityZipCodeRegex)[2]);\n```\n\n**Bom:**\n```javascript\nconst address = 'One Infinite Loop, Cupertino 95014';\nconst cityZipCodeRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/;\nconst [, city, zipCode] = address.match(cityZipCodeRegex) || [];\nsaveCityZipCode(city, zipCode);\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Evite Mapeamento Mental\nExplicito é melhor que implícito.\n\n**Ruim:**\n```javascript\nconst locations = ['Austin', 'New York', 'San Francisco'];\nlocations.forEach((l) => {\n  doStuff();\n  doSomeOtherStuff();\n  // ...\n  // ...\n  // ...\n  // Espera, para que serve o `l` mesmo?\n  dispatch(l);\n});\n```\n\n**Bom:**\n```javascript\nconst locations = ['Austin', 'New York', 'San Francisco'];\nlocations.forEach((location) => {\n  doStuff();\n  doSomeOtherStuff();\n  // ...\n  // ...\n  // ...\n  dispatch(location);\n});\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Não adicione contextos desnecessários\nSe o nome de sua classe/objeto já lhe diz alguma coisa, não as repita nos nomes de suas variáveis.\n\n**Ruim:**\n```javascript\nconst Car = {\n  carMake: 'Honda',\n  carModel: 'Accord',\n  carColor: 'Blue'\n};\n\nfunction paintCar(car, color) {\n  car.carColor = color;\n}\n```\n\n**Bom:**\n```javascript\nconst Car = {\n  make: 'Honda',\n  model: 'Accord',\n  color: 'Blue'\n};\n\nfunction paintCar(car, color) {\n  car.color = color;\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Use argumentos padrões ao invés de curto circuitar ou usar condicionais\n\nArgumentos padrões são geralmente mais limpos do que curto circuitos. Esteja ciente que se você usá-los, sua função apenas irá fornecer valores padrões para argumentos `undefined`. Outros valores \"falsos\" como `''`, `\"\"`, `false`, `null`, `0`, e `NaN`, não serão substituídos por valores padrões.\n\n**Ruim:**\n```javascript\nfunction createMicrobrewery(name) {\n  const breweryName = name || 'Hipster Brew Co.';\n  // ...\n}\n\n```\n\n**Bom:**\n```javascript\nfunction createMicrobrewery(breweryName = 'Hipster Brew Co.') {\n  // ...\n}\n\n```\n**[⬆ voltar ao topo](#Índice)**\n\n## **Funções**\n### Argumentos de funções (idealmente 2 ou menos)\nLimitar a quantidade de parâmetros de uma função é incrivelmente importante porque torna mais fácil testá-la. Ter mais que três leva a uma explosão combinatória onde você tem que testar muitos casos diferentes com cada argumento separadamente.\n\nUm ou dois argumentos é o caso ideal, e três devem ser evitados se possível. Qualquer coisa a mais que isso deve ser consolidada. Geralmente, se você tem mais que dois argumentos então sua função está tentando fazer muitas coisas. Nos casos em que não está, na maioria das vezes um objeto é suficiente como argumento.\n\nJá que JavaScript lhe permite criar objetos instantaneamente, sem ter que escrever muita coisa, você pode usar um objeto se você se pegar precisando usar muitos argumentos.\n\nPara tornar mais óbvio quais as propriedades que as funções esperam, você pode usar a sintaxe de desestruturação (destructuring) do ES2015/ES6. Ela possui algumas vantagens:\n\n\n1. Quando alguém olha para a assinatura de uma função, fica imediatamente claro quais propriedades são usadas.\n2. Desestruturação também clona os valores primitivos específicos do objeto passado como argumento para a função. Isso pode ajudar a evitar efeitos colaterais. Nota: objetos e vetores que são desestruturados a partir do objeto passado por argumento NÃO são clonados.\n3. Linters podem te alertar sobre propriedades não utilizadas, o que seria impossível sem usar desestruturação.\n\n**Ruim:**\n```javascript\nfunction createMenu(title, body, buttonText, cancellable) {\n  // ...\n}\n```\n\n**Bom:**\n```javascript\nfunction createMenu({ title, body, buttonText, cancellable }) {\n  // ...\n}\n\ncreateMenu({\n  title: 'Foo',\n  body: 'Bar',\n  buttonText: 'Baz',\n  cancellable: true\n});\n\n```\n**[⬆ voltar ao topo](#Índice)**\n\n\n### Funções devem fazer uma coisa\nEssa é de longe a regra mais importante em engenharia de software. Quando funções fazem mais que uma coisa, elas se tornam difíceis de serem compostas, testadas e raciocinadas. Quando você pode isolar uma função para realizar apenas uma ação, elas podem ser refatoradas facilmente e seu código ficará muito mais limpo. Se você não levar mais nada desse guia além disso, você já estará na frente de muitos desenvolvedores.\n\n**Ruim:**\n```javascript\nfunction emailClients(clients) {\n  clients.forEach((client) => {\n    const clientRecord = database.lookup(client);\n    if (clientRecord.isActive()) {\n      email(client);\n    }\n  });\n}\n```\n\n**Bom:**\n```javascript\nfunction emailActiveClients(clients) {\n  clients\n    .filter(isActiveClient)\n    .forEach(email);\n}\n\nfunction isActiveClient(client) {\n  const clientRecord = database.lookup(client);\n  return clientRecord.isActive();\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Nomes de funções devem dizer o que elas fazem\n\n**Ruim:**\n```javascript\nfunction addToDate(date, month) {\n  // ...\n}\n\nconst date = new Date();\n\n// É difícil dizer pelo nome da função o que é adicionado\naddToDate(date, 1);\n```\n\n**Bom:**\n```javascript\nfunction addMonthToDate(month, date) {\n  // ...\n}\n\nconst date = new Date();\naddMonthToDate(1, date);\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Funções devem ter apenas um nível de abstração\nQuando você tem mais de um nível de abstração sua função provavelmente esta fazendo coisas demais. Dividir suas funções leva a reutilização e testes mais fáceis.\n\n**Ruim:**\n```javascript\nfunction parseBetterJSAlternative(code) {\n  const REGEXES = [\n    // ...\n  ];\n\n  const statements = code.split(' ');\n  const tokens = [];\n  REGEXES.forEach((REGEX) => {\n    statements.forEach((statement) => {\n      // ...\n    });\n  });\n\n  const ast = [];\n  tokens.forEach((token) => {\n    // lex...\n  });\n\n  ast.forEach((node) => {\n    // parse...\n  });\n}\n```\n\n**Bom:**\n```javascript\nfunction tokenize(code) {\n  const REGEXES = [\n    // ...\n  ];\n\n  const statements = code.split(' ');\n  const tokens = [];\n  REGEXES.forEach((REGEX) => {\n    statements.forEach((statement) => {\n      tokens.push( /* ... */ );\n    });\n  });\n\n  return tokens;\n}\n\nfunction lexer(tokens) {\n  const ast = [];\n  tokens.forEach((token) => {\n    ast.push( /* ... */ );\n  });\n\n  return ast;\n}\n\nfunction parseBetterJSAlternative(code) {\n  const tokens = tokenize(code);\n  const ast = lexer(tokens);\n  ast.forEach((node) => {\n    // parse...\n  });\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Remova código duplicado\nFaça absolutamente seu melhor para evitar código duplicado. Código duplicado quer dizer que existe mais de um lugar onde você deverá alterar algo se precisar mudar alguma lógica.\n\nImagine que você é dono de um restaurante e você toma conta do seu estoque: todos os seus tomates, cebolas, alhos, temperos, etc. Se você tem múltiplas listas onde guarda estas informações, então você terá que atualizar todas elas quando servir um prato que tenha tomates. Se você tivesse apenas uma lista, teria apenas um lugar para atualizar!\n\nFrequentemente, você possui código duplicado porque você tem duas ou mais\ncoisas levemente diferentes, que possuem muito em comum, mas suas diferenças lhe forçam a ter mais duas ou três funções que fazem muito das mesmas coisas. Remover código duplicado significa criar uma abstração que seja capaz de lidar com este conjunto de coisas diferentes com apenas uma função/módulo/classe.\n\nConseguir a abstração correta é crítico, por isso que você deveria seguir os princípios SOLID descritos na seção *Classes*. Abstrações ruins podem ser piores do que código duplicado, então tome cuidado! Dito isto, se você puder fazer uma boa abstração, faça-a! Não repita a si mesmo, caso contrário você se pegará atualizando muitos lugares toda vez que precisar mudar qualquer coisinha.\n\n**Ruim:**\n```javascript\nfunction showDeveloperList(developers) {\n  developers.forEach((developer) => {\n    const expectedSalary = developer.calculateExpectedSalary();\n    const experience = developer.getExperience();\n    const githubLink = developer.getGithubLink();\n    const data = {\n      expectedSalary,\n      experience,\n      githubLink\n    };\n\n    render(data);\n  });\n}\n\nfunction showManagerList(managers) {\n  managers.forEach((manager) => {\n    const expectedSalary = manager.calculateExpectedSalary();\n    const experience = manager.getExperience();\n    const portfolio = manager.getMBAProjects();\n    const data = {\n      expectedSalary,\n      experience,\n      portfolio\n    };\n\n    render(data);\n  });\n}\n```\n\n**Bom:**\n```javascript\nfunction showEmployeeList(employees) {\n  employees.forEach((employee) => {\n    const expectedSalary = employee.calculateExpectedSalary();\n    const experience = employee.getExperience();\n\n    const data = {\n      expectedSalary,\n      experience\n    };\n\n    switch(employee.type){\n      case 'manager':\n        data.portfolio = employee.getMBAProjects();\n        break;\n      case 'developer':\n        data.githubLink = employee.getGithubLink();\n        break;\n    }\n\n    render(data);\n  });\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Defina (set) objetos padrões com Object.assign\n\n**Ruim:**\n```javascript\nconst menuConfig = {\n  title: null,\n  body: 'Bar',\n  buttonText: null,\n  cancellable: true\n};\n\nfunction createMenu(config) {\n  config.title = config.title || 'Foo';\n  config.body = config.body || 'Bar';\n  config.buttonText = config.buttonText || 'Baz';\n  config.cancellable = config.cancellable !== undefined ? config.cancellable : true;\n}\n\ncreateMenu(menuConfig);\n```\n\n**Bom:**\n```javascript\nconst menuConfig = {\n  title: 'Order',\n  // Usuário não incluiu a chave 'body'\n  buttonText: 'Send',\n  cancellable: true\n};\n\nfunction createMenu(config) {\n  config = Object.assign({\n    title: 'Foo',\n    body: 'Bar',\n    buttonText: 'Baz',\n    cancellable: true\n  }, config);\n\n  // configuração agora é: {title: \"Order\", body: \"Bar\", buttonText: \"Send\", cancellable: true}\n  // ...\n}\n\ncreateMenu(menuConfig);\n```\n**[⬆ voltar ao topo](#Índice)**\n\n\n### Não use flags como parâmetros de funções\nFlags falam para o seu usuário que sua função faz mais de uma coisa. Funções devem fazer apenas uma coisa. Divida suas funções se elas estão seguindo caminhos de código diferentes baseadas em um valor booleano.\n\n**Ruim:**\n```javascript\nfunction createFile(name, temp) {\n  if (temp) {\n    fs.create(`./temp/${name}`);\n  } else {\n    fs.create(name);\n  }\n}\n```\n\n**Bom:**\n```javascript\nfunction createFile(name) {\n  fs.create(name);\n}\n\nfunction createTempFile(name) {\n  createFile(`./temp/${name}`);\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Evite Efeitos Colaterais (parte 1)\nUma função produz um efeito colateral se ela faz alguma coisa que não seja receber um valor de entrada e retornar outro(s) valor(es). Um efeito colateral pode ser escrever em um arquivo, modificar uma variável global, ou acidentalmente transferir todo seu dinheiro para um estranho.\n\nAgora, você precisa de efeitos colaterais ocasionalmente no seu programa. Como no exemplo anterior, você pode precisar escrever em um arquivo. O que você quer fazer é centralizar aonde está fazendo isto. Não tenha diversas funções e classes que escrevam para um arquivo em particular. Tenha um serviço que faça isso. Um e apenas um.\n\nO ponto principal é evitar armadilhas como compartilhar o estado entre objetos sem nenhuma estrutura, usando tipos de dados mutáveis que podem ser escritos por qualquer coisa, e não centralizando onde seu efeito colateral acontece. Se você conseguir fazer isto, você será muito mais feliz que a grande maioria dos outros programadores.\n\n**Ruim:**\n```javascript\n// Variável global referenciada pela função seguinte\n// Se tivéssemos outra função que usa esse nome, então seria um vetor (array) e poderia quebrar seu código\nlet name = 'Ryan McDermott';\n\nfunction splitIntoFirstAndLastName() {\n  name = name.split(' ');\n}\n\nsplitIntoFirstAndLastName();\n\nconsole.log(name); // ['Ryan', 'McDermott'];\n```\n\n**Bom:**\n```javascript\nfunction splitIntoFirstAndLastName(name) {\n  return name.split(' ');\n}\n\nconst name = 'Ryan McDermott';\nconst newName = splitIntoFirstAndLastName(name);\n\nconsole.log(name); // 'Ryan McDermott';\nconsole.log(newName); // ['Ryan', 'McDermott'];\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Evite Efeitos Colaterais (parte 2)\nEm JavaScript, tipos primitivos são passados por valor e objetos/vetores são passados por referência. No caso de objetos e vetores, se sua função faz uma mudança em um vetor de um carrinho de compras, por exemplo, adicionando um item para ser comprado, então qualquer outra função que use o vetor `cart` também será afetada por essa adição. Isso pode ser ótimo, mas também pode ser ruim. Vamos imaginar uma situação ruim:\n\nO usuário clica no botão \"Comprar\", botão que invoca a função `purchase` que dispara uma série de requisições e manda o vetor `cart` para o servidor. Devido a uma conexão ruim de internet, a função `purchase` precisa fazer novamente a requisição. Agora, imagine que nesse meio tempo o usuário acidentalmente clique no botão `Adicionar ao carrinho` em um produto que ele não queria antes da requisição começar. Se isto acontecer e a requisição for enviada novamente, então a função `purchase` irá enviar acidentalmente o vetor com o novo produto adicionado porque existe uma referência para o vetor `cart` que a função `addItemToCart` modificou adicionando um produto indesejado.\n\nUma ótima solução seria que a função `addCartToItem` sempre clonasse o vetor `cart`, editasse-o, e então retornasse seu clone. Isso garante que nenhuma outra função que possua uma referência para o carrinho de compras seja afetada por qualquer mudança feita.\n\nDuas ressalvas desta abordagem:\n\n  1. Podem haver casos onde você realmente quer mudar o objeto de entrada, mas quando você adota este tipo de programação, você vai descobrir que estes casos são bastante raros. A maioria das coisas podem ser refatoradas para não terem efeitos colaterais.\n\n  2. Clonar objetos grandes pode ser bastante caro em termos de desempenho. Com sorte, na prática isso não é um problema, porque existem [ótimas bibliotecas](https://facebook.github.io/immutable-js/) que permitem que este tipo de programação seja rápida e não seja tão intensa no uso de memória quanto seria se você clonasse manualmente objetos e vetores.\n\n\n**Ruim:**\n```javascript\nconst addItemToCart = (cart, item) => {\n  cart.push({ item, date: Date.now() });\n};\n```\n\n**Bom:**\n```javascript\nconst addItemToCart = (cart, item) => {\n  return [...cart, { item, date: Date.now() }];\n};\n```\n\n### Não escreva em funções globais\nPoluir globais é uma prática ruim em JavaScript porque você pode causar conflito com outra biblioteca e o usuário da sua API não faria a menor ideia até que ele tivesse um exceção sendo levantada em produção. Vamos pensar em um exemplo: e se você quisesse estender o método nativo Array do JavaScript para ter um método `diff` que poderia mostrar a diferença entre dois vetores? Você poderia escrever sua nova função em `Array.prototype`, mas poderia colidir com outra biblioteca que tentou fazer a mesma coisa. E se esta outra biblioteca estava apenas usando `diff` para achar a diferença entre o primeiro e último elemento de um vetor? É por isso que seria muito melhor usar as classes padrões do ES2015/ES6 e apenas estender o `Array` global.\n\n**Ruim:**\n```javascript\nArray.prototype.diff = function diff(comparisonArray) {\n  const hash = new Set(comparisonArray);\n  return this.filter(elem => !hash.has(elem));\n};\n```\n\n**Bom:**\n```javascript\nclass SuperArray extends Array {\n  diff(comparisonArray) {\n    const hash = new Set(comparisonArray);\n    return this.filter(elem => !hash.has(elem));\n  }\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Favoreça programação funcional sobre programação imperativa\nJavaScript não é uma linguagem funcional da mesma forma que Haskell é, mas tem um toque de funcional em si. Linguagens funcionais são mais limpas e fáceis de se testar. Favoreça esse tipo de programação quando puder.\n\n**Ruim:**\n```javascript\nconst programmerOutput = [\n  {\n    name: 'Uncle Bobby',\n    linesOfCode: 500\n  }, {\n    name: 'Suzie Q',\n    linesOfCode: 1500\n  }, {\n    name: 'Jimmy Gosling',\n    linesOfCode: 150\n  }, {\n    name: 'Gracie Hopper',\n    linesOfCode: 1000\n  }\n];\n\nlet totalOutput = 0;\n\nfor (let i = 0; i < programmerOutput.length; i++) {\n  totalOutput += programmerOutput[i].linesOfCode;\n}\n```\n\n**Bom:**\n```javascript\nconst programmerOutput = [\n  {\n    name: 'Uncle Bobby',\n    linesOfCode: 500\n  }, {\n    name: 'Suzie Q',\n    linesOfCode: 1500\n  }, {\n    name: 'Jimmy Gosling',\n    linesOfCode: 150\n  }, {\n    name: 'Gracie Hopper',\n    linesOfCode: 1000\n  }\n];\n\nconst INITIAL_VALUE = 0;\n\nconst totalOutput = programmerOutput\n  .map((programmer) => programmer.linesOfCode)\n  .reduce((acc, linesOfCode) => acc + linesOfCode, INITIAL_VALUE);\n```\n**[⬆ volta ao topo](#Índice)**\n\n### Encapsule condicionais\n\n**Ruim:**\n```javascript\nif (fsm.state === 'fetching' && isEmpty(listNode)) {\n  // ...\n}\n```\n\n**Bom:**\n```javascript\nfunction shouldShowSpinner(fsm, listNode) {\n  return fsm.state === 'fetching' && isEmpty(listNode);\n}\n\nif (shouldShowSpinner(fsmInstance, listNodeInstance)) {\n  // ...\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Evite negações de condicionais\n\n**Ruim:**\n```javascript\nfunction isDOMNodeNotPresent(node) {\n  // ...\n}\n\nif (!isDOMNodeNotPresent(node)) {\n  // ...\n}\n```\n\n**Bom:**\n```javascript\nfunction isDOMNodePresent(node) {\n  // ...\n}\n\nif (isDOMNodePresent(node)) {\n  // ...\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Evite condicionais\nEsta parece ser uma tarefa impossível. Da primeira vez que as pessoas escutam isso, a maioria diz, “como eu supostamente faria alguma coisa sem usar `if`? ” A resposta é que você pode usar polimorfismo para realizar a mesma tarefa em diversos casos. A segunda questão é geralmente, “bom, isso é ótimo, mas porque eu deveria fazer isso?” A resposta é um conceito de código limpo aprendido previamente: uma função deve fazer apenas uma coisa. Quando você tem classes e funções que tem declarações `if`, você esta dizendo para seu usuário que sua função faz mais de uma coisa. Relembre-se, apenas uma coisa.\n\n**Ruim:**\n```javascript\nclass Airplane {\n  // ...\n  getCruisingAltitude() {\n    switch (this.type) {\n      case '777':\n        return this.getMaxAltitude() - this.getPassengerCount();\n      case 'Air Force One':\n        return this.getMaxAltitude();\n      case 'Cessna':\n        return this.getMaxAltitude() - this.getFuelExpenditure();\n    }\n  }\n}\n```\n\n**Bom:**\n```javascript\nclass Airplane {\n  // ...\n}\n\nclass Boeing777 extends Airplane {\n  // ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude() - this.getPassengerCount();\n  }\n}\n\nclass AirForceOne extends Airplane {\n  // ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude();\n  }\n}\n\nclass Cessna extends Airplane {\n  // ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude() - this.getFuelExpenditure();\n  }\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Evite checagem de tipos (parte 1)\nJavaScript não possui tipos, o que significa que suas funções podem receber qualquer tipo de argumento. Algumas vezes esta liberdade pode te morder, e se torna tentador fazer checagem de tipos em suas funções. Existem muitas formas de evitar ter que fazer isso. A primeira coisa a se considerar são APIs consistentes.\n\n**Ruim:**\n```javascript\nfunction travelToTexas(vehicle) {\n  if (vehicle instanceof Bicycle) {\n    vehicle.pedal(this.currentLocation, new Location('texas'));\n  } else if (vehicle instanceof Car) {\n    vehicle.drive(this.currentLocation, new Location('texas'));\n  }\n}\n```\n\n**Bom:**\n```javascript\nfunction travelToTexas(vehicle) {\n  vehicle.move(this.currentLocation, new Location('texas'));\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Evite checagem de tipos (parte 2)\nSe você estiver trabalhando com valores primitivos básicos como strings e inteiros, e você não pode usar polimorfismo, mas ainda sente a necessidade de checar o tipo, você deveria considerar usar TypeScript. É uma excelente alternativa para o JavaScript normal, já que fornece uma tipagem estática sobre a sintaxe  padrão do JavaScript. O problema com checagem manual em JavaScript é que para se fazer bem feito requer tanta verborragia extra que a falsa “tipagem-segura” que você consegue não compensa pela perca de legibilidade. Mantenha seu JavaScript limpo, escreve bons testes, e tenha boas revisões de código. Ou, de outra forma, faça tudo isso, mas com TypeScript (que, como eu falei, é uma ótima alternativa!).\n\n**Ruim:**\n```javascript\nfunction combine(val1, val2) {\n  if (typeof val1 === 'number' && typeof val2 === 'number' ||\n      typeof val1 === 'string' && typeof val2 === 'string') {\n    return val1 + val2;\n  }\n\n  throw new Error('Must be of type String or Number');\n}\n```\n\n**Bom:**\n```javascript\nfunction combine(val1, val2) {\n  return val1 + val2;\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Não otimize demais\nNavegadores modernos fazem muitas otimizações por debaixo dos panos em tempo de execução. Muitas vezes, se você estiver otimizando, está apenas perdendo o seu tempo. [Existem bons recursos](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers) para se verificar onde falta otimização. Foque nesses por enquanto, até que eles sejam consertados caso seja possível.\n\n**Ruim:**\n```javascript\n\n// Em navegadores antigos, cada iteração de `list.length` não cacheada seria custosa\n// devido a recomputação de `list.length`. Em navegadores modernos, isto é otimizado.\nfor (let i = 0, len = list.length; i < len; i++) {\n  // ...\n}\n```\n\n**Bom:**\n```javascript\nfor (let i = 0; i < list.length; i++) {\n  // ...\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Remova código morto\nCódigo morto é tão ruim quanto código duplicado. Não existe nenhum motivo para deixá-lo em seu código. Se ele não estiver sendo chamado, livre-se dele. Ele ainda estará a salvo no seu histórico de versionamento se ainda precisar dele.\n\n**Ruim:**\n```javascript\nfunction oldRequestModule(url) {\n  // ...\n}\n\nfunction newRequestModule(url) {\n  // ...\n}\n\nconst req = newRequestModule;\ninventoryTracker('apples', req, 'www.inventory-awesome.io');\n\n```\n\n**Bom:**\n```javascript\nfunction newRequestModule(url) {\n  // ...\n}\n\nconst req = newRequestModule;\ninventoryTracker('apples', req, 'www.inventory-awesome.io');\n```\n**[⬆ voltar ao topo](#Índice)**\n\n## **Objetos e Estruturas de Dados**\n### Use getters e setters\nUsar getters e setters para acessar dados em objetos é bem melhor que simplesmente procurar por uma propriedade em um objeto. \"Por quê?\", você deve perguntar. Bem, aqui vai uma lista desorganizada de motivos:\n\n* Quando você quer fazer mais além de pegar (get) a propriedade de um objeto, você não tem que procurar e mudar todos os acessores do seu código;\n* Torna mais fácil fazer validação quando estiver dando um `set`;\n* Encapsula a representação interna;\n* Mais fácil de adicionar logs e tratamento de erros quando dando get and set;\n* Você pode usar lazy loading nas propriedades de seu objeto, digamos, por exemplo, pegando ele de um servidor.\n\n\n**Ruim:**\n```javascript\nfunction makeBankAccount() {\n  // ...\n\n  return {\n    balance: 0,\n    // ...\n  };\n}\n\nconst account = makeBankAccount();\naccount.balance = 100;\n```\n\n**Bom:**\n```javascript\nfunction makeBankAccount() {\n  // este é privado\n  let balance = 0;\n\n  // um \"getter\", feito público através do objeto retornado abaixo\n  function getBalance() {\n    return balance;\n  }\n\n  // um \"setter\", feito público através do objeto retornado abaixo\n  function setBalance(amount) {\n    // ... validate before updating the balance\n    balance = amount;\n  }\n\n  return {\n    // ...\n    getBalance,\n    setBalance,\n  };\n}\n\nconst account = makeBankAccount();\naccount.setBalance(100);\n\n```\n**[⬆ voltar ao topo](#Índice)**\n\n\n### Faça objetos terem membros privados\nIsto pode ser alcançado através de closures (para ES5 e além).\n\n**Ruim:**\n```javascript\n\nconst Employee = function(name) {\n  this.name = name;\n};\n\nEmployee.prototype.getName = function getName() {\n  return this.name;\n};\n\nconst employee = new Employee('John Doe');\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe\ndelete employee.name;\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: undefined\n```\n\n**Bom:**\n```javascript\nfunction makeEmployee(name) {\n  return {\n    getName() {\n      return name;\n    },\n  };\n}\n\nconst employee = makeEmployee('John Doe');\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe\ndelete employee.name;\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe\n```\n**[⬆ voltar ao topo](#Índice)**\n\n\n## **Classes**\n### Prefira classes do ES2015/ES6 ao invés de funções simples do ES5\nÉ muito difícil conseguir que herança de classe, construtores, e definições de métodos sejam legíveis para classes de ES5 clássicas. Se você precisa de herança (e esteja ciente que você talvez não precise), então prefira classes ES2015/ES6. Entretanto, prefira funções pequenas ao invés de classes até que você precise de objetos maiores e mais complexos.\n\n**Ruim:**\n```javascript\nconst Animal = function(age) {\n  if (!(this instanceof Animal)) {\n    throw new Error('Instantiate Animal with `new`');\n  }\n\n  this.age = age;\n};\n\nAnimal.prototype.move = function move() {};\n\nconst Mammal = function(age, furColor) {\n  if (!(this instanceof Mammal)) {\n    throw new Error('Instantiate Mammal with `new`');\n  }\n\n  Animal.call(this, age);\n  this.furColor = furColor;\n};\n\nMammal.prototype = Object.create(Animal.prototype);\nMammal.prototype.constructor = Mammal;\nMammal.prototype.liveBirth = function liveBirth() {};\n\nconst Human = function(age, furColor, languageSpoken) {\n  if (!(this instanceof Human)) {\n    throw new Error('Instantiate Human with `new`');\n  }\n\n  Mammal.call(this, age, furColor);\n  this.languageSpoken = languageSpoken;\n};\n\nHuman.prototype = Object.create(Mammal.prototype);\nHuman.prototype.constructor = Human;\nHuman.prototype.speak = function speak() {};\n```\n\n**Bom:**\n```javascript\nclass Animal {\n  constructor(age) {\n    this.age = age;\n  }\n\n  move() { /* ... */ }\n}\n\nclass Mammal extends Animal {\n  constructor(age, furColor) {\n    super(age);\n    this.furColor = furColor;\n  }\n\n  liveBirth() { /* ... */ }\n}\n\nclass Human extends Mammal {\n  constructor(age, furColor, languageSpoken) {\n    super(age, furColor);\n    this.languageSpoken = languageSpoken;\n  }\n\n  speak() { /* ... */ }\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n\n### Use encadeamento de métodos\nEste padrão é muito útil em JavaScript e você o verá em muitas bibliotecas como jQuery e Lodash. Ele permite que seu código seja expressivo e menos verboso. Por esse motivo, eu digo, use encadeamento de métodos e dê uma olhada em como o seu código ficará mais limpo. Em suas funções de classes, apenas retorne `this` no final de cada função, e você poderá encadear mais métodos de classe nele.\n\n**Ruim:**\n```javascript\nclass Car {\n  constructor(make, model, color) {\n    this.make = make;\n    this.model = model;\n    this.color = color;\n  }\n\n  setMake(make) {\n    this.make = make;\n  }\n\n  setModel(model) {\n    this.model = model;\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  save() {\n    console.log(this.make, this.model, this.color);\n  }\n}\n\nconst car = new Car('Ford','F-150','red');\ncar.setColor('pink');\ncar.save();\n```\n\n**Bom:**\n```javascript\nclass Car {\n  constructor(make, model, color) {\n    this.make = make;\n    this.model = model;\n    this.color = color;\n  }\n\n  setMake(make) {\n    this.make = make;\n    // NOTA: Retorne this para encadear\n    return this;\n  }\n\n  setModel(model) {\n    this.model = model;\n    // NOTA: Retorne this para encadear\n    return this;\n  }\n\n  setColor(color) {\n    this.color = color;\n    // NOTA: Retorne this para encadear\n    return this;\n  }\n\n  save() {\n    console.log(this.make, this.model, this.color);\n    // NOTA: Retorne this para encadear\n    return this;\n  }\n}\n\nconst car = new Car('Ford','F-150','red')\n  .setColor('pink')\n  .save();\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Prefira composição ao invés de herança\nComo dito famosamente em [*Padrão de projeto*](https://pt.wikipedia.org/wiki/Padr%C3%A3o_de_projeto_de_software) pela Gangue dos Quatro, você deve preferir composição sobre herança onde você puder. Existem muitas boas razões para usar herança e muitas boas razões para se usar composição. O ponto principal para essa máxima é que se sua mente for instintivamente para a herança, tente pensar se composição poderia modelar melhor o seu problema. Em alguns casos pode.\n\nVocê deve estar pensando então, \"quando eu deveria usar herança?\" Isso depende especificamente do seu problema, mas essa é uma lista decente de quando herança faz mais sentido que composição:\n\n1. Sua herança representa uma relação de \"isto-é\" e não uma relação de \"isto-tem\" (Human→Animal vs. User->UserDetails)\n2. Você pode reutilizar código de classes de base (Humanos podem se mover como todos os animais).\n3. Você quer fazer mudanças globais para classes derivadas mudando apenas a classe base. (Mudar o custo calórico para todos os animais quando se movem).\n\n**Ruim:**\n```javascript\nclass Employee {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n\n  // ...\n}\n\n// Ruim porque Employees (Empregados) \"tem\" dados de impostos. EmployeeTaxData não é um tipo de Employee\nclass EmployeeTaxData extends Employee {\n  constructor(ssn, salary) {\n    super();\n    this.ssn = ssn;\n    this.salary = salary;\n  }\n\n  // ...\n}\n```\n\n**Bom:**\n```javascript\nclass EmployeeTaxData {\n  constructor(ssn, salary) {\n    this.ssn = ssn;\n    this.salary = salary;\n  }\n\n  // ...\n}\n\nclass Employee {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n\n  setTaxData(ssn, salary) {\n    this.taxData = new EmployeeTaxData(ssn, salary);\n  }\n  // ...\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n## **SOLID**\n### Princípio da Responsabilidade Única (SRP)\nComo dito em Código Limpo, \"Nunca deveria haver mais de um motivo para uma classe ter que mudar\". É tentador empacotar uma classe em excesso com muitas funcionalidades, como quando você pode levar apenas uma mala em seu voo. O problema com isso é que sua classe não será conceitualmente coesa e dar-lhe-á diversos motivos para mudá-la. Minimizar o número de vezes que você precisa mudar uma classe é importante, porque, se muitas funcionalidades estão em uma classe e você mudar uma porção dela, pode ser difícil entender como isto afetará outros módulos que dependem dela no seu código.\n\n**Ruim:**\n```javascript\nclass UserSettings {\n  constructor(user) {\n    this.user = user;\n  }\n\n  changeSettings(settings) {\n    if (this.verifyCredentials()) {\n      // ...\n    }\n  }\n\n  verifyCredentials() {\n    // ...\n  }\n}\n```\n\n**Bom:**\n```javascript\nclass UserAuth {\n  constructor(user) {\n    this.user = user;\n  }\n\n  verifyCredentials() {\n    // ...\n  }\n}\n\n\nclass UserSettings {\n  constructor(user) {\n    this.user = user;\n    this.auth = new UserAuth(user);\n  }\n\n  changeSettings(settings) {\n    if (this.auth.verifyCredentials()) {\n      // ...\n    }\n  }\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Princípio do Aberto/Fechado (OCP)\nComo foi dito por Bertrand Meyer, \"entidades de software (classes, módulos, funções, etc.) devem se manter abertas para extensões, mas fechadas para modificações.\" Mas o que isso significa? Esse princípio basicamente diz que você deve permitir que usuários adicionem novas funcionalidades sem mudar código já existente.\n\n**Ruim:**\n```javascript\nclass AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'ajaxAdapter';\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'nodeAdapter';\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    if (this.adapter.name === 'ajaxAdapter') {\n      return makeAjaxCall(url).then((response) => {\n        // transforma a resposta e retorna\n      });\n    } else if (this.adapter.name === 'httpNodeAdapter') {\n      return makeHttpCall(url).then((response) => {\n        // transforma a resposta e retorna\n      });\n    }\n  }\n}\n\nfunction makeAjaxCall(url) {\n  // faz a request e retorna a promessa\n}\n\nfunction makeHttpCall(url) {\n  // faz a request e retorna a promessa\n}\n```\n\n**Bom:**\n```javascript\nclass AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'ajaxAdapter';\n  }\n\n  request(url) {\n    // faz a request e retorna a promessa\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'nodeAdapter';\n  }\n\n  request(url) {\n    // faz a request e retorna a promessa\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    return this.adapter.request(url).then((response) => {\n      // transforma a resposta e retorna\n    });\n  }\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n\n### Princípio de Substituição de Liskov (LSP)\nEsse é um termo assustador para um conceito extremamente simples. É formalmente definido como “Se S é um subtipo de T, então objetos do tipo T podem ser substituídos por objetos com o tipo S (i.e., objetos do tipo S podem substituir objetos do tipo T) sem alterar nenhuma das propriedades desejáveis de um programa (corretude, desempenho em tarefas, etc.).” Esta é uma definição ainda mais assustadora.\n\nA melhor explicação para este conceito é se você tiver uma classe pai e uma classe filha, então a classe base e a classe filha pode ser usadas indistintamente sem ter resultados incorretos. Isso ainda pode ser confuso, então vamos dar uma olhada no exemplo clássico do Quadrado-Retângulo (Square-Rectangle). Matematicamente, um quadrado é um retângulo, mas se você modelá-lo usando uma relação “isto-é” através de herança, você rapidamente terá problemas.\n\n**Ruim:**\n```javascript\nclass Rectangle {\n  constructor() {\n    this.width = 0;\n    this.height = 0;\n  }\n\n  setColor(color) {\n    // ...\n  }\n\n  render(area) {\n    // ...\n  }\n\n  setWidth(width) {\n    this.width = width;\n  }\n\n  setHeight(height) {\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Rectangle {\n  setWidth(width) {\n    this.width = width;\n    this.height = width;\n  }\n\n  setHeight(height) {\n    this.width = height;\n    this.height = height;\n  }\n}\n\nfunction renderLargeRectangles(rectangles) {\n  rectangles.forEach((rectangle) => {\n    rectangle.setWidth(4);\n    rectangle.setHeight(5);\n    const area = rectangle.getArea(); // RUIM: Retorna 25 para o Quadrado. Deveria ser 20.\n    rectangle.render(area);\n  });\n}\n\nconst rectangles = [new Rectangle(), new Rectangle(), new Square()];\nrenderLargeRectangles(rectangles);\n```\n\n**Bom:**\n```javascript\nclass Shape {\n  setColor(color) {\n    // ...\n  }\n\n  render(area) {\n    // ...\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(width, height) {\n    super();\n    this.width = width;\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Shape {\n  constructor(length) {\n    super();\n    this.length = length;\n  }\n\n  getArea() {\n    return this.length * this.length;\n  }\n}\n\nfunction renderLargeShapes(shapes) {\n  shapes.forEach((shape) => {\n    const area = shape.getArea();\n    shape.render(area);\n  });\n}\n\nconst shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];\nrenderLargeShapes(shapes);\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Princípio da Segregação de Interface (ISP)\nJavaScript não possui interfaces então esse princípio não se aplica estritamente como os outros. Entretanto, é importante e relevante até mesmo com a falta de um sistema de tipos em JavaScript.\n\nISP diz que \"Clientes não devem ser forcados a depender de interfaces que eles não usam.\" Interfaces são contratos implícitos em JavaScript devido a sua tipagem pato (duck typing).\n\nUm bom exemplo para se observar que demonstra esse princípio em JavaScript é de classes que requerem objetos de configurações grandes. Não pedir para clientes definirem grandes quantidades de opções é benéfico, porque na maioria das vezes eles não precisarão de todas as configurações. Torná-las opcionais ajuda a prevenir uma “interferência gorda”.\n\n**Ruim:**\n```javascript\nclass DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.animationModule.setup();\n  }\n\n  traverse() {\n    // ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName('body'),\n  animationModule() {} //  Na maioria das vezes, não precisamos animar enquanto atravessamos (traversing).\n  // ...\n});\n\n```\n\n**Bom:**\n```javascript\nclass DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.options = settings.options;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.setupOptions();\n  }\n\n  setupOptions() {\n    if (this.options.animationModule) {\n      // ...\n    }\n  }\n\n  traverse() {\n    // ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName('body'),\n  options: {\n    animationModule() {}\n  }\n});\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Princípio da Inversão de Dependência  (DIP)\nEste princípio nos diz duas coisas essenciais:\n1. Módulos de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de abstrações.\n2. Abstrações não devem depender de detalhes. Detalhes devem depender de abstrações.\n\nIsso pode ser difícil de entender a princípio, mas se você já trabalhou com AngularJS, você já viu uma implementação deste princípio na forma de injeção de dependência (DI). Apesar de não serem conceitos idênticos, DIP não deixa módulos de alto nível saber os detalhes de seus módulos de baixo nível, assim como configurá-los. Isso pode ser alcançado através de DI. Um grande benefício é que reduz o acoplamento entre os módulos. Acoplamento é um padrão de desenvolvimento muito ruim porque torna seu código mais difícil de ser refatorado.\n\nComo dito anteriormente, JavaScript não possui interfaces, então as abstrações que são necessárias são contratos implícitos. Que quer dizer que, os métodos e as classes que um objeto/classe expõe para outros objeto/classe. No exemplo abaixo, o contrato implícito é que qualquer módulo de Request  para `InventoryTracker` terá um método `requestItems`:\n\n**Ruim:**\n```javascript\nclass InventoryRequester {\n  constructor() {\n    this.REQ_METHODS = ['HTTP'];\n  }\n\n  requestItem(item) {\n    // ...\n  }\n}\n\nclass InventoryTracker {\n  constructor(items) {\n    this.items = items;\n\n    // Ruim: Nós criamos uma dependência numa implementação de request especifica.\n    // Nós deveriamos apenas ter requestItems dependendo de um método de request: `request`\n    this.requester = new InventoryRequester();\n  }\n\n  requestItems() {\n    this.items.forEach((item) => {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\nconst inventoryTracker = new InventoryTracker(['apples', 'bananas']);\ninventoryTracker.requestItems();\n```\n\n**Bom:**\n```javascript\nclass InventoryTracker {\n  constructor(items, requester) {\n    this.items = items;\n    this.requester = requester;\n  }\n\n  requestItems() {\n    this.items.forEach((item) => {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\nclass InventoryRequesterV1 {\n  constructor() {\n    this.REQ_METHODS = ['HTTP'];\n  }\n\n  requestItem(item) {\n    // ...\n  }\n}\n\nclass InventoryRequesterV2 {\n  constructor() {\n    this.REQ_METHODS = ['WS'];\n  }\n\n  requestItem(item) {\n    // ...\n  }\n}\n\n// Construindo nossas dependências externamente e injetando-as, podemos facilmente\n// substituir nosso módulo de request por um novo mais chique que usa WebSockets\nconst inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());\ninventoryTracker.requestItems();\n```\n**[⬆ voltar ao topo](#Índice)**\n\n## **Testes**\nTestes são mais importantes que entregas. Se você não possui testes ou uma quantidade inadequada, então toda vez que você entregar seu código você não terá certeza se você não quebrou alguma coisa. Decidir o que constitui uma quantidade adequada é responsabilidade do seu time, mas ter 100% de cobertura (todas as sentenças e branches) é a maneira que se alcança uma alta confiança e uma paz de espírito em desenvolvimento. Isso quer dizer que além de ter um ótimo framework de testes, você também precisa usar uma [boa ferramenta de cobertura](http://gotwarlost.github.io/istanbul/).\n\nNão existe desculpa para não escrever testes. Existem [diversos frameworks de testes em JS ótimos](http://jstherightway.org/#testing-tools), então encontre um que seu time prefira. Quando você encontrar um que funciona para seu time, então tenha como objetivo sempre escrever testes para cada nova funcionalidade/módulo que você introduzir. Se seu método preferido for Desenvolvimento Orientado a Testes (TDD), isso é ótimo, mas o ponto principal é apenas ter certeza que você está alcançado suas metas de cobertura antes de lançar qualquer funcionalidade, ou refatorar uma já existente.\n\n### Um conceito por teste\n\n**Ruim:**\n```javascript\nimport assert from 'assert';\n\ndescribe('MakeMomentJSGreatAgain', () => {\n  it('handles date boundaries', () => {\n    let date;\n\n    date = new MakeMomentJSGreatAgain('1/1/2015');\n    date.addDays(30);\n    assert.equal('1/31/2015', date);\n\n    date = new MakeMomentJSGreatAgain('2/1/2016');\n    date.addDays(28);\n    assert.equal('02/29/2016', date);\n\n    date = new MakeMomentJSGreatAgain('2/1/2015');\n    date.addDays(28);\n    assert.equal('03/01/2015', date);\n  });\n});\n```\n\n**Bom:**\n```javascript\nimport assert from 'assert';\n\ndescribe('MakeMomentJSGreatAgain', () => {\n  it('handles 30-day months', () => {\n    const date = new MakeMomentJSGreatAgain('1/1/2015');\n    date.addDays(30);\n    assert.equal('1/31/2015', date);\n  });\n\n  it('handles leap year', () => {\n    const date = new MakeMomentJSGreatAgain('2/1/2016');\n    date.addDays(28);\n    assert.equal('02/29/2016', date);\n  });\n\n  it('handles non-leap year', () => {\n    const date = new MakeMomentJSGreatAgain('2/1/2015');\n    date.addDays(28);\n    assert.equal('03/01/2015', date);\n  });\n});\n```\n**[⬆ voltar ao topo](#Índice)**\n\n## **Concorrência**\n### Use Promessas, não callbacks\nCallbacks não são limpos, e eles causam uma quantidade excessiva de aninhamentos. A partir de ES2015/ES6, Promessas são um tipo nativo global. Use-as!\n\n**Ruim:**\n```javascript\nimport { get } from 'request';\nimport { writeFile } from 'fs';\n\nget('https://en.wikipedia.org/wiki/Robert_Cecil_Martin', (requestErr, response) => {\n  if (requestErr) {\n    console.error(requestErr);\n  } else {\n    writeFile('article.html', response.body, (writeErr) => {\n      if (writeErr) {\n        console.error(writeErr);\n      } else {\n        console.log('File written');\n      }\n    });\n  }\n});\n\n```\n\n**Bom:**\n```javascript\nimport { get } from 'request';\nimport { writeFile } from 'fs';\n\nget('https://en.wikipedia.org/wiki/Robert_Cecil_Martin')\n  .then((response) => {\n    return writeFile('article.html', response);\n  })\n  .then(() => {\n    console.log('File written');\n  })\n  .catch((err) => {\n    console.error(err);\n  });\n\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Async/Await são ainda mais limpas que Promessas\nPromessas são uma alternativa bem mais limpa que callbacks, mas o ES2017/ES8 traz `async` e `await` que oferecem uma solução ainda mais limpa. Tudo o que você precisa é uma função que tem como prefixo a palavra-chave `async`, e então você pode escrever sua lógica imperativamente sem usar `then` para encadear suas funções. Use isto se você puder tirar vantagem das funcionalidades do  ES2017/ES8 hoje!\n\n**Ruim:**\n```javascript\nimport { get } from 'request-promise';\nimport { writeFile } from 'fs-promise';\n\nget('https://en.wikipedia.org/wiki/Robert_Cecil_Martin')\n  .then((response) => {\n    return writeFile('article.html', response);\n  })\n  .then(() => {\n    console.log('File written');\n  })\n  .catch((err) => {\n    console.error(err);\n  });\n\n```\n\n**Bom:**\n```javascript\nimport { get } from 'request-promise';\nimport { writeFile } from 'fs-promise';\n\nasync function getCleanCodeArticle() {\n  try {\n    const response = await get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin');\n    await writeFile('article.html', response);\n    console.log('File written');\n  } catch(err) {\n    console.error(err);\n  }\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n\n## **Tratamento de Erros**\n`throw error` é uma coisa boa! Eles significam que o programa identificou\ncom sucesso quando algo deu errado e está permitindo que você saiba parando\na execução da função no processo atual, fechando o processo (em Node), e\nnotificando você no console com a pilha de processos.\n\n### Não ignore erros capturados\nNão fazer nada com um erro capturado não te dá a habilidade de resolvê-lo ou\nreagir ao erro informado. Exibir um log no console(`console.log`) não é muito\nmelhor porque muitas vezes ele pode ficar perdido entre um monte de outras\ncoisas impressas no console. Se você envolver qualquer pedaço de código em um\n`try/catch` isso significa que você acredita que um erro pode ocorrer lá e então\nvocê deveria ter um plano, ou criar caminho de código para quando isso ocorrer.\n\n**Ruim:**\n```javascript\ntry {\n  functionThatMightThrow();\n} catch (error) {\n  console.log(error);\n}\n```\n\n**Bom:**\n```javascript\ntry {\n  functionThatMightThrow();\n} catch (error) {\n  // Uma opção (mais chamativa que console.log):\n  console.error(error);\n  // Outra opção:\n  notifyUserOfError(error);\n  // Outra opção:\n  reportErrorToService(error);\n  // OU as três!\n}\n```\n\n### Não ignore promessas rejeitadas\nPela mesma razão que você não deveria ignorar erros\ncaptados de `try/catch`\n\n**Ruim:**\n```javascript\ngetdata()\n  .then((data) => {\n    functionThatMightThrow(data);\n  })\n  .catch((error) => {\n    console.log(error);\n  });\n```\n\n**Bom:**\n```javascript\ngetdata()\n  .then((data) => {\n    functionThatMightThrow(data);\n  })\n  .catch((error) => {\n    // One option (more noisy than console.log):\n    console.error(error);\n    // Another option:\n    notifyUserOfError(error);\n    // Another option:\n    reportErrorToService(error);\n    // OR do all three!\n  });\n\n```\n\n**[⬆ voltar ao topo](#Índice)**\n\n\n## **Formatação**\nFormatação é subjetiva. Como muitas regras aqui, não há nenhuma regra fixa e\nrápida que você precisa seguir. O ponto principal é NÃO DISCUTA sobre formatação.\nExistem [muitas ferramentas](http://standardjs.com/rules.html) para automatizar isso.\nUtilize uma! É um desperdício de tempo e dinheiro para engenheiros discutirem sobre\nformatação.\n\nPara coisas que não possam utilizar formatação automática (identação, tabs vs. espaços,\naspas simples vs. duplas, etc.) olhe aqui para alguma orientação.\n\n### Utilize capitalização consistente\nJavaScript não é uma linguagem tipada, então a capitalização diz muito sobre\nsuas variáveis, funções, etc. Estas regras são subjetivas, então sua equipe\npode escolher o que quiserem. O ponto é, não importa o que vocês todos escolham,\napenas seja consistente.\n\n**Ruim:**\n```javascript\nconst DAYS_IN_WEEK = 7;\nconst daysInMonth = 30;\n\nconst songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];\nconst Artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];\n\nfunction eraseDatabase() {}\nfunction restore_database() {}\n\nclass animal {}\nclass Alpaca {}\n```\n\n**Bom:**\n```javascript\nconst DAYS_IN_WEEK = 7;\nconst DAYS_IN_MONTH = 30;\n\nconst SONGS = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];\nconst ARTISTS = ['ACDC', 'Led Zeppelin', 'The Beatles'];\n\nfunction eraseDatabase() {}\nfunction restoreDatabase() {}\n\nclass Animal {}\nclass Alpaca {}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n\n### Funções e chamadas de funções devem estar próximas\nSe uma função chamar outra, mantenha estas funções verticalmente próximas no arquivo\nfonte. Em um cenário ideal, manter a chamada logo acima da função. Nós tendemos a\nler códigos de cima para baixo, como num jornal. Por causa disso, faça o seu código\ndesta maneira.\n\n**Ruim:**\n```javascript\nclass PerformanceReview {\n  constructor(employee) {\n    this.employee = employee;\n  }\n\n  lookupPeers() {\n    return db.lookup(this.employee, 'peers');\n  }\n\n  lookupManager() {\n    return db.lookup(this.employee, 'manager');\n  }\n\n  getPeerReviews() {\n    const peers = this.lookupPeers();\n    // ...\n  }\n\n  perfReview() {\n    this.getPeerReviews();\n    this.getManagerReview();\n    this.getSelfReview();\n  }\n\n  getManagerReview() {\n    const manager = this.lookupManager();\n  }\n\n  getSelfReview() {\n    // ...\n  }\n}\n\nconst review = new PerformanceReview(employee);\nreview.perfReview();\n```\n\n**Bom:**\n```javascript\nclass PerformanceReview {\n  constructor(employee) {\n    this.employee = employee;\n  }\n\n  perfReview() {\n    this.getPeerReviews();\n    this.getManagerReview();\n    this.getSelfReview();\n  }\n\n  getPeerReviews() {\n    const peers = this.lookupPeers();\n    // ...\n  }\n\n  lookupPeers() {\n    return db.lookup(this.employee, 'peers');\n  }\n\n  getManagerReview() {\n    const manager = this.lookupManager();\n  }\n\n  lookupManager() {\n    return db.lookup(this.employee, 'manager');\n  }\n\n  getSelfReview() {\n    // ...\n  }\n}\n\nconst review = new PerformanceReview(employee);\nreview.perfReview();\n```\n\n**[⬆ voltar ao topo](#Índice)**\n\n## **Comentários**\n### Apenas comente coisas que tenham complexidade de lógica de negócio.\nComentários são uma desculpa, não um requisito. Um bom código documenta-se, *a maior parte*, por si só.\n\n**Ruim:**\n```javascript\nfunction hashIt(data) {\n  // A hash\n  let hash = 0;\n\n  // Tamanho da string\n  const length = data.length;\n\n  // Loop em cada caracter da informação\n  for (let i = 0; i < length; i++) {\n    // Pega o código do caracter.\n    const char = data.charCodeAt(i);\n    // Cria a hash\n    hash = ((hash << 5) - hash) + char;\n    // Converte para um integer 32-bit\n    hash &= hash;\n  }\n}\n```\n\n**Bom:**\n```javascript\n\nfunction hashIt(data) {\n  let hash = 0;\n  const length = data.length;\n\n  for (let i = 0; i < length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n\n    // Converte para um integer 32-bit\n    hash &= hash;\n  }\n}\n\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Não deixe código comentado na sua base de código\nControle de versão existe por uma razão. Deixar códigos velhos no seu histórico.\n\n**Ruim:**\n```javascript\ndoStuff();\n// doOtherStuff();\n// doSomeMoreStuff();\n// doSoMuchStuff();\n```\n\n**Bom:**\n```javascript\ndoStuff();\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Não comente registro de alterações\nLembre-se, utilize controle de versão! Não tem necessidade em deixar códigos\ninutilizados, códigos comentados e especialmente registros de alterações.\nUtilize `git log` para pegar o histórico!\n\n**Ruim:**\n```javascript\n/**\n * 2016-12-20: Removidas monads, não entendia elas (RM)\n * 2016-10-01: Melhoria utilizando monads especiais (JP)\n * 2016-02-03: Removido checagem de tipos (LI)\n * 2015-03-14: Adicionada checagem de tipos (JR)\n */\nfunction combine(a, b) {\n  return a + b;\n}\n```\n\n**Bom:**\n```javascript\nfunction combine(a, b) {\n  return a + b;\n}\n```\n**[⬆ voltar ao topo](#Índice)**\n\n### Evite marcadores de posição\nEles geralmente criam ruídos. Deixe que as funções e nomes de variáveis em conjunto\ncom a devida identação e formatação deem a estrutura visual para o seu código.\n\n**Ruim:**\n```javascript\n////////////////////////////////////////////////////////////////////////////////\n// Intanciação do Scope Model\n////////////////////////////////////////////////////////////////////////////////\n$scope.model = {\n  menu: 'foo',\n  nav: 'bar'\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Configuração da Action\n////////////////////////////////////////////////////////////////////////////////\nconst actions = function() {\n  // ...\n};\n```\n\n**Bom:**\n```javascript\n$scope.model = {\n  menu: 'foo',\n  nav: 'bar'\n};\n\nconst actions = function() {\n  // ...\n};\n```\n**[⬆ voltar ao topo](#Índice)**\n\n## **Traduções**\n\nExistem traduções disponíveis em outras linguas:\n\n  - ![en](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/United-States.png) **Inglês**: [ryanmcdermott/clean-code-javascript](https://github.com/ryanmcdermott/clean-code-javascript)\n  - ![es](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Uruguay.png) **Espanhol**: [andersontr15/clean-code-javascript](https://github.com/andersontr15/clean-code-javascript-es)\n  - ![cn](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/China.png) **Chinês**:\n    - [alivebao/clean-code-js](https://github.com/alivebao/clean-code-js)\n    - [beginor/clean-code-javascript](https://github.com/beginor/clean-code-javascript)\n  - ![de](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Germany.png) **Alemão**: [marcbruederlin/clean-code-javascript](https://github.com/marcbruederlin/clean-code-javascript)\n  - ![kr](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/South-Korea.png) **Coreano**: [qkraudghgh/clean-code-javascript-ko](https://github.com/qkraudghgh/clean-code-javascript-ko)\n  - ![pl](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Poland.png) **Polaco**: [greg-dev/clean-code-javascript-pl](https://github.com/greg-dev/clean-code-javascript-pl)\n  - ![ru](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Russia.png) **Russo**:\n    - [BoryaMogila/clean-code-javascript-ru/](https://github.com/BoryaMogila/clean-code-javascript-ru/)\n    - [maksugr/clean-code-javascript](https://github.com/maksugr/clean-code-javascript)\n  - ![vi](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Vietnam.png) **Vietnamita**: [hienvd/clean-code-javascript/](https://github.com/hienvd/clean-code-javascript/)\n  - ![ja](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Japan.png) **Japonês**: [mitsuruog/clean-code-javascript/](https://github.com/mitsuruog/clean-code-javascript/)\n  - ![id](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Indonesia.png) **Indonésio**:\n  [andirkh/clean-code-javascript/](https://github.com/andirkh/clean-code-javascript/)\n"
        }
      ]
    }
  ]
}