{
  "metadata": {
    "timestamp": 1736562022454,
    "page": 764,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "facebookarchive/mention-bot",
      "stars": 3358,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".babelrc",
          "type": "blob",
          "size": 0.150390625,
          "content": "{\n  \"presets\": [\"react\"],\n  \"plugins\": [\n    \"babel-plugin-transform-object-rest-spread\",\n    \"syntax-async-functions\",\n    \"transform-regenerator\"\n  ]\n}\n"
        },
        {
          "name": ".env.example",
          "type": "blob",
          "size": 0.0634765625,
          "content": "GITHUB_USER=your-bot-username\nGITHUB_TOKEN=your-bot-access-token\n"
        },
        {
          "name": ".flowconfig",
          "type": "blob",
          "size": 0.099609375,
          "content": "[ignore]\n.*/node_modules/jsonlint/test/.*\n\n[include]\n\n[libs]\ninterfaces/\n\n[options]\n\n[version]\n0.60.1\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0654296875,
          "content": "node_modules\nnpm-debug.log\n.env\n.idea\nyarn.lock\n/.history\n/.vscode\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1064453125,
          "content": "language: node_js\n\ncache:\n    directories:\n        - node_modules\n        - $NVM_DIR\n\nnode_js:\n  - v5\n  - v4\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.2431640625,
          "content": "# Code of Conduct\n\nFacebook has adopted a Code of Conduct that we expect project participants to adhere to. Please [read the full text](https://code.facebook.com/codeofconduct) so that you can understand what actions will and will not be tolerated.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.75,
          "content": "# Contributing to mention-bot\n\nWe are no longer actively accepting contributions to this project.\n\n\n## Code of Conduct\nThe code of conduct is described in [`CODE_OF_CONDUCT.md`](CODE_OF_CONDUCT.md).\n\n## Contributor License Agreement (\"CLA\")\nIn order to accept your pull request, we need you to submit a CLA. You only need\nto do this once to work on any of Facebook's open source projects.\n\nComplete your CLA here: <https://code.facebook.com/cla>\n\n## Issues\nWe use GitHub issues to track public bugs. Please ensure your description is\nclear and has sufficient instructions to be able to reproduce the issue.\n\n## License\nBy contributing to mention-bot, you agree that your contributions will be licensed\nunder the LICENSE file in the root directory of this source tree.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.03125,
          "content": "FROM node:4-onbuild\nEXPOSE 5000\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.49609375,
          "content": "BSD License\n\nFor mention-bot software\n\nCopyright (c) 2015-present, Facebook, Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n * Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n * Neither the name Facebook nor the names of its contributors may be used to\n   endorse or promote products derived from this software without specific\n   prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "PATENTS",
          "type": "blob",
          "size": 1.935546875,
          "content": "Additional Grant of Patent Rights Version 2\n\n\"Software\" means the mention-bot software distributed by Facebook, Inc.\n\nFacebook, Inc. (\"Facebook\") hereby grants to each recipient of the Software\n(\"you\") a perpetual, worldwide, royalty-free, non-exclusive, irrevocable\n(subject to the termination provision below) license under any Necessary\nClaims, to make, have made, use, sell, offer to sell, import, and otherwise\ntransfer the Software. For avoidance of doubt, no license is granted under\nFacebookâ€™s rights in any patent claims that are infringed by (i) modifications\nto the Software made by you or any third party or (ii) the Software in\ncombination with any software or other technology.\n\nThe license granted hereunder will terminate, automatically and without notice,\nif you (or any of your subsidiaries, corporate affiliates or agents) initiate\ndirectly or indirectly, or take a direct financial interest in, any Patent\nAssertion: (i) against Facebook or any of its subsidiaries or corporate\naffiliates, (ii) against any party if such Patent Assertion arises in whole or\nin part from any software, technology, product or service of Facebook or any of\nits subsidiaries or corporate affiliates, or (iii) against any party relating\nto the Software. Notwithstanding the foregoing, if Facebook or any of its\nsubsidiaries or corporate affiliates files a lawsuit alleging patent\ninfringement against you in the first instance, and you respond by filing a\npatent infringement counterclaim in that lawsuit against that party that is\nunrelated to the Software, the license granted hereunder will not terminate\nunder section (i) of this paragraph due to such counterclaim.\n\nA \"Necessary Claim\" is a claim of a patent owned by Facebook that is\nnecessarily infringed by the Software standing alone.\n\nA \"Patent Assertion\" is any lawsuit or other action alleging direct, indirect,\nor contributory infringement or inducement to infringe any patent, including a\ncross-claim or counterclaim.\n"
        },
        {
          "name": "Procfile",
          "type": "blob",
          "size": 0.0146484375,
          "content": "web: npm start\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.9716796875,
          "content": "** THIS REPO HAS BEEN ARCHIVED AND IS NO LONGER BEING ACTIVELY MAINTAINED **\n\n# mention-bot [![Build Status](https://travis-ci.org/facebook/mention-bot.svg?branch=master)](https://travis-ci.org/facebook/mention-bot)\n\nDo you have a GitHub project that is too big for people to subscribe to all the notifications? The mention bot will automatically mention potential reviewers on pull requests. It helps getting faster turnaround on pull requests by involving the right people early on.\n\n<img width=\"769\" src=\"https://cloud.githubusercontent.com/assets/197597/11023035/a2f8733e-8622-11e5-84df-49a3d9425938.png\">\n\n## How To Use?\n\n- Go to\n - your project on GitHub > Settings > Webhooks & services > Add Webhook or\n - your organization on GitHub > Settings > Webhooks > Add Webhook\n- Payload URL: (https://mention-bot.herokuapp.com/)\n- Content type: `application/json`\n- Secret: Leave blank\n- Let me select individual events > Check `Pull Request`\n- Add Webhook\n\nAnd you are done. Next time a pull request is opened, you should see the bot add a comment ;)\n\n## Configuration\n\nThe bot can be configured by adding a `.mention-bot` file to the base directory of the repo. Here's a list of the possible options:\n\n```js\n{\n  \"maxReviewers\": 5, // Maximum  number of people to ping in the PR message, default is 3\n  \"numFilesToCheck\": 10, // Number of files to check against, default is 5\n  \"message\": \"@pullRequester, thanks! @reviewers, please review this.\",\n             // custom message using @pullRequester and @reviewers\n  \"alwaysNotifyForPaths\": [\n    {\n      \"name\": \"ghuser\", // The user's Github username\n      \"files\": [\"src/js/**/*.js\"], // The array of file globs associated with the user\n      \"skipTeamPrs\": false // mention-bot will exclude the creator's own team from mentions\n    }\n  ], // Users will always be mentioned based on file glob\n  \"fallbackNotifyForPaths\": [\n    {\n      \"name\": \"ghuser\", // The user's Github username\n      \"files\": [\"src/js/**/*.js\"], // The array of file globs associated with the user\n      \"skipTeamPrs\": false // mention-bot will exclude the creator's own team from mentions\n    }\n  ], // Users will be mentioned based on file glob if no other user was found\n  \"findPotentialReviewers\": true, // mention-bot will try to find potential reviewers based on files history, if disabled, `alwaysNotifyForPaths` is used instead\n  \"fileBlacklist\": [\"*.md\"], // mention-bot will ignore any files that match these file globs\n  \"userBlacklist\": [], // Users in this list will never be mentioned by mention-bot\n  \"userBlacklistForPR\": [], // PR made by users in this list will be ignored\n  \"requiredOrgs\": [], // mention-bot will only mention user who are a member of one of these organizations\n  \"actions\": [\"opened\"], // List of PR actions that mention-bot will listen to, default is \"opened\"\n  \"branches\": [],  // List of branches that mention-bot will listen to, default is all branches\n  \"skipAlreadyAssignedPR\": false, // mention-bot will ignore already assigned PR's\n  \"skipAlreadyMentionedPR\": false, // mention-bot will ignore if there is already existing an exact mention\n  \"assignToReviewer\": false, // mention-bot assigns the most appropriate reviewer for PR\n  \"createReviewRequest\": false, // mention-bot creates review request for the most appropriate reviewer for PR\n  \"createComment\": true, // mention-bot creates a comment mentioning the reviewers for the PR\n  \"skipTitle\": \"\", // mention-bot will ignore PR that includes this text in the title,\n  \"withLabel\": \"\", // mention-bot will only consider PR's with this label. Must set actions to [\"labeled\"].\n  \"delayed\": false, // mention-bot will wait to comment until specified time in `delayedUntil` value\n  \"delayedUntil\": \"3d\", // Used if delayed is equal true, permitted values are: minutes, hours, or days, e.g.: '3 days', '40 minutes', '1 hour', '3d', '1h', '10m'\n  \"skipCollaboratorPR\": false // mention-bot will ignore if PR is made by collaborator\n}\n```\n\nThe glob matching is an extended form of glob syntax performed by [`minimatch`](https://github.com/isaacs/minimatch), with the default options; read [the `minimatch` README](https://github.com/isaacs/minimatch/blob/master/README.md) for more details.\n\n**Note:** The `.mention-bot` file must be valid JSON.\n\nThe default config can be overridden via environment config. e.g.:\n\n```zsh\nMENTION_BOT_CONFIG={\"maxReviewers\":1,\"delayed\":true}\n```\n---\n\n## How Does It Work?\n\nEvery time there's a new pull request, GitHub wakes up the mention bot <img src=\"https://avatars0.githubusercontent.com/u/15710697?v=3&s=40\" width=\"20\" height=\"20\" /> using Webhooks.\n\nOnce awakened, the bot will download the diff of the pull request and figure out which files and lines have been touched.\n\n<img width=\"1139\" src=\"https://cloud.githubusercontent.com/assets/197597/11022818/92edd20e-861d-11e5-8c44-c64c1a7de79f.png\">\n\nFor these, it will download the associated blame to figure out who last touched that line, as they may be a good reviewer.\n\n<img width=\"923\" src=\"https://cloud.githubusercontent.com/assets/197597/11022820/973166aa-861d-11e5-83b1-b05e8228f974.png\">\n\nAfter running the [algorithm](#algorithm) described in the next section, it will comment on the pull request notifying those people and go back to sleep.\n\n<img width=\"769\" src=\"https://cloud.githubusercontent.com/assets/197597/11022875/3e4949de-861f-11e5-8459-573a8dbc9013.png\">\n\n## Algorithm\n\nThe problem of finding who the best reviewers are is really hard and I don't think that any algorithm will achieve perfection. Instead, what we want here is to be **best effort**. We want to notify people that are likely going to be interested and be good reviewers. If we ping a few too many people that's not the end of the world neither if we don't ping the exact right person.\n\nWe use two heuristics:\n- If a line was deleted or modified, the person that last touched that line is likely going to care about this pull request.\n- If a person last touched many lines in the file where the change was made, they will want to be notified.\n\n**Initialization**\n\nCreate two empty hash map:\n- `DeletedLines` for authors of deleted lines.\n- `AllLines` for authors of lines in the changed files.\n\n**Filling the data structures**\n\n- for each deleted line, find the author in the blame and increase its count by one in the `DeletedLines` map.\n- for each line in every file that was changed, find the author in the blame and increase its count by one in the `AllLines` map.\n\nSince getting the blame information is sending an http request to GitHub it is pretty expensive. We first sort the files by number of deleted lines and only pick the top 5. Since we're only looking for 3 names and the algorithm is best effort, this greatly speeds up the algorithm in case of large pull requests for little loss in precision.\n\n**Putting it all together**\n\n- delete from `AllLines` all the names that appear in both maps. We don't want to mention the same person twice.\n- sort each map by count\n- concat `DeletedLines` with `AllLines`\n- take the first three names\n\n## How To Contribute or Run Your Own Bot?\n\nIf you want to use a different account for the bot, change the message or extend it with more functionalities, we've tried to make it super easy:\n\n```bash\ngit clone https://github.com/facebook/mention-bot.git\ncd mention-bot\nnpm install\nnpm start\n# Follow the instructions there\n```\n\nAlternatively, click the button below:\n\n[![Deploy](https://www.herokucdn.com/deploy/button.svg)](https://heroku.com/deploy)\n\nIf you would like the mention-bot to function on private repositories, set the `GITHUB_USER` and `GITHUB_PASSWORD` environment variables. You must disable two-factor authentication or you will receive a console log like this: `Login to ${USERNAME} failed`.\n\nYou can also set a `REQUIRED_ORG` environment variable, so you don't have to configure it in each repository of your organization.\n\nYou can also build deploy it as a Docker image:\n\n```bash\ndocker build -t mention-bot .\ndocker run -e GITHUB_USER=\"a\" -p 5000:5000  mention-bot\n```\n\n**Build & run the bot locally with docker-compose**\n\nCopy `.env.example` to `.env` and fill in your bot's information. Build and run\nthe bot:\n\n```bash\ndocker-compose up\n```\n\nThe bot will be available at http://localhost.\n\n## Configuring a custom message\n\nIf you want to change the default message, you can write your custom logic in [message.js](https://github.com/facebook/mention-bot/blob/master/message.js), or add 'message' in the [.mention-bot configuration](#configuration) file.\n\n## How to run the bot on GitHub Enterprise\n\nIf you want to run the bot on your GitHub Enterprise instance, add the GHE host and path prefix to the config section of package.json\n\n```json\n\"config\": {\n  \"gheHost\": \"github.my-GHE-enabled-company.com\",\n  \"ghePathPrefix\": \"/api/v3\"\n}\n```\n\nIf you use `http` protocol, the config section like this:\n\n```json\n\"config\": {\n  \"gheHost\": \"github.my-GHE-enabled-company.com\",\n  \"ghePathPrefix\": \"/api/v3\",\n  \"gheProtocol\": \"http\",\n  \"ghePort\": 80\n}\n```\n\n\n## Programmatic API\n\nWhen you require `mention-bot` you will get all the functions exposed by [`mention-bot.js`](https://github.com/facebook/mention-bot/blob/master/mention-bot.js) module. You are expected to manage your own server and also connection to the github repository.\n\n```\nnpm install mention-bot github\n```\n\nAPI can be used like this:\n\n```js\nvar mentionBot = require('mention-bot');\nvar GitHubApi = require('github');\n\nvar github = new GitHubApi({ version: '3.0.0' });\ngithub.authenticate({\n  type: 'oauth',\n  token: '...token...'\n});\n\nmentionBot\n  .guessOwnersForPullRequest(\n    'https://github.com/fbsamples/bot-testing', // repo\n    65, // pull request number\n    'mention-bot', // user that created the pull request\n    'master', // branch\n    { maxReviewers: 3 }, // config\n    github\n  )\n  .then(function(users) {\n    // array with user names which should be included in review\n    console.log(users);\n  })\n  .catch(function(err) {\n    console.error(err);\n  });\n```\n\n## License\n\nmention-bot is [BSD-licensed](https://github.com/facebook/mention-bot/blob/master/LICENSE). We also provide an [additional patent grant](https://github.com/facebook/mention-bot/blob/master/PATENTS).\n"
        },
        {
          "name": "__mocks__",
          "type": "tree",
          "content": null
        },
        {
          "name": "__tests__",
          "type": "tree",
          "content": null
        },
        {
          "name": "app.json",
          "type": "blob",
          "size": 0.712890625,
          "content": "{\n  \"name\": \"mention-bot\",\n  \"description\": \"Automatically mention potential reviewers on pull requests.\",\n  \"repository\": \"https://github.com/facebook/mention-bot\",\n  \"logo\": \"https://avatars0.githubusercontent.com/u/15710697\",\n  \"keywords\": [\"node\", \"express\", \"github\", \"pull requests\"],\n  \"env\": {\n    \"GITHUB_TOKEN\": {\n      \"description\": \"A token generated for the account which will comment on your pull requests.\",\n      \"required\": true\n    },\n    \"GITHUB_USER\": {\n      \"description\": \"If you want mention-bot to work with private repos, you need to add your GitHub login\",\n      \"required\": false\n    },\n    \"GITHUB_PASSWORD\": {\n      \"description\": \"Password for GitHub account.\",\n      \"required\": false\n    }\n  }\n}\n"
        },
        {
          "name": "cache",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.js",
          "type": "blob",
          "size": 0.5654296875,
          "content": "var exports = module.exports = {};\n\nvar packageConfig = require('./package.json').config;\nvar configJson = require('./config.json');\n\nvar mergedConfig = Object.assign(packageConfig, configJson);\n\nexports.github = {\n  host: process.env.GHE_HOST || mergedConfig.gheHost || 'github.com',\n  apiHost: process.env.GHE_API_HOST || mergedConfig.gheHost || 'api.github.com',\n  protocol: process.env.GHE_PROTOCOL || mergedConfig.gheProtocol || 'https',\n  pathPrefix: process.env.GHE_PATH_PREFIX || mergedConfig.ghePathPrefix,\n  port: process.env.GHE_PORT || mergedConfig.ghePort || 443\n};\n"
        },
        {
          "name": "config.json",
          "type": "blob",
          "size": 0.0029296875,
          "content": "{}\n"
        },
        {
          "name": "cookieJar.js",
          "type": "blob",
          "size": 1.5458984375,
          "content": "/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n'use strict';\n\nclass CookieJar {\n  cookies: { [key: string]: string };\n\n  constructor() {\n    this.cookies = {};\n  }\n\n  /**\n   * Serializes stored cookies into http header format\n   */\n  get(): string {\n    return Object.keys(this.cookies)\n      .map(function(key) {\n        let str = key;\n        if (this.cookies[key]) {\n          str += '=' + this.cookies[key];\n        }\n        return str;\n      }, this)\n      .join('; ');\n  }\n\n  /**\n   * Parses a single header line of cookie, parses them, and stores them in a hash\n   */\n  parseCookieHeader(headerLine: string) {\n    headerLine.split(';')\n      .forEach(function(cookie) {\n        var pair = cookie.split('=');\n        this.cookies[pair[0]] = pair[1];\n      }, this);\n  }\n\n  /**\n   * Finds Set-Cookie header in resp headers and adds them to the jar\n   * Returns all stored cookies where the new cookies overwrite previous cookies\n   */\n\n  parseHeaders(headers: string) {\n    if (!headers) {\n      return;\n    }\n    headers.split('\\n')\n      .filter(function(line) {\n        return line.split('Set-Cookie').length > 1;\n      })\n      .forEach(function(line) {\n        this.parseCookieHeader(line.split('Set-Cookie: ')[1].trim());\n      }, this);\n    return this.get();\n  }\n}\n\nmodule.exports = CookieJar;\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.1796875,
          "content": "version: '3'\n\nservices:\n  web:\n    build: .\n    restart: always\n    ports:\n      - \"80:5000\"\n    environment:\n      GITHUB_USER: \"${GITHUB_USER}\"\n      GITHUB_TOKEN: \"${GITHUB_TOKEN}\"\n"
        },
        {
          "name": "githubAuthCookies.js",
          "type": "blob",
          "size": 2.67578125,
          "content": "/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n'use strict';\nvar USERNAME = process.env.GITHUB_USER;\nvar PASSWORD = process.env.GITHUB_PASSWORD;\nvar config = require('./config');\nvar childProcess = require('child_process');\nvar CookieJar = require('./cookieJar');\nvar jar = new CookieJar();\n\nvar ghHost = config.github.host\nvar ghProtocol = config.github.protocol\n\n/**\n * Scrape github login page\n */\nvar githubLogin = function() {\n  var output = childProcess.execSync(\n    `curl -v -L ${ghProtocol}://${ghHost}/login 2>&1`,\n    {encoding: 'utf8'}\n  ).toString().split('<!DOCTYPE html>');\n\n  return {\n    headers: output[0],\n    body: output[1]\n  };\n};\n\n\n/**\n * gets a CSRF token by hitting github's login form\n * returns CSRF token\n */\nvar getAuthenticityToken = function() {\n  var login = githubLogin();\n  jar.parseHeaders(login.headers);\n  return encodeURIComponent(\n    (login.body.match(/action=\"\\/session\".*name=\"authenticity_token\".*value=\"([^\"]+)\"/) || [''])[1]\n  );\n};\n\n/**\n * runs curl request to perform login action\n * returns github response headers\n */\nvar getGithubLoginResponseHeaders = function(): string {\n  var authenticity_token = getAuthenticityToken();\n  var commandArr = [\n    `${ghProtocol}://${ghHost}/session`,\n    `--silent`,\n    `-v`,\n    `-d`, `utf8=%E2%9C%93&authenticity_token=${authenticity_token}`,\n    `-d`, `login=${USERNAME || ''}`,\n    `--data-urlencode`, `password=${PASSWORD || ''}`,\n    `-H`, `Pragma: no-cache`,\n    `-H`, `Origin: ${ghProtocol}://${ghHost}`,\n    `-H`, `Accept-Encoding: gzip, deflate`,\n    `-H`, `Accept-Language: en-US,en;q=0.8`,\n    `-H`, `Upgrade-Insecure-Requests: 1`,\n    `-H`, `User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36`,\n    `-H`, `Content-Type: application/x-www-form-urlencoded`,\n    `-H`, `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`,\n    `-H`, `Cache-Control: no-cache`,\n    `-H`, `Referer: ${ghProtocol}://${ghHost}/`,\n    `-H`, `Cookie: ${jar.get()}`,\n    `-H`, `Connection: keep-alive`,\n  ];\n\n  return childProcess.spawnSync(\n    'curl',\n    commandArr,\n    {encoding: 'utf8'}\n  ).stderr.toString();\n};\n\nif (USERNAME) {\n  var headers = getGithubLoginResponseHeaders();\n  jar.parseHeaders(headers);\n  if (jar.cookies['logged_in'] === 'no') {\n    console.error(`Login to ${USERNAME} failed`);\n  }\n\n  module.exports = jar.get();\n} else {\n  module.exports = null;\n}\n"
        },
        {
          "name": "interfaces",
          "type": "tree",
          "content": null
        },
        {
          "name": "mention-bot.js",
          "type": "blob",
          "size": 17.9033203125,
          "content": "/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n'use strict';\n\nvar githubAuthCookies = require('./githubAuthCookies');\nvar fs = require('fs');\nvar minimatch = require('minimatch');\n\nasync function downloadFileAsync(url: string, cookies: ?string): Promise<string> {\n  return new Promise(function(resolve, reject) {\n    var args = ['--silent', '-L', url];\n\n    if (cookies) {\n      args.push('-H', `Cookie: ${cookies}`);\n    }\n\n    require('child_process')\n      .execFile('curl', args, {encoding: 'utf8', maxBuffer: 1000 * 1024 * 10}, function(error, stdout, stderr) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(stdout.toString());\n        }\n      });\n  });\n}\n\nasync function readFileAsync(name: string, encoding: string): Promise<string> {\n  return new Promise(function(resolve, reject) {\n    fs.readFile(name, encoding, function(err, data) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\ntype FileInfo = {\n  path: string,\n  deletedLines: Array<number>,\n};\n\ntype WhitelistUser = {\n  name: string,\n  files: Array<string>,\n  skipTeamPrs: bool\n};\n\ntype TeamData = {\n  name: string,\n  id: number\n};\n\ntype TeamMembership = {\n  name: string,\n  state: string\n};\n\nfunction startsWith(str, start) {\n  return str.substr(0, start.length) === start;\n}\n\nfunction parseDiffFile(lines: Array<string>): Array<FileInfo> {\n  // diff --git \"a/path\" \"b/path\" or rename to path/file or rename from path/file\n  var diffRegex = /^diff --git \"?a\\/(.+)\"?\\s/;\n  // @@ -from_line,from_count +to_line,to_count @@ first line\n  var offsetRegex = /^@@ -(\\d+).+@@/;\n  var offset = null;\n  var current = 0;\n  return lines.reduce((f, line) => {\n    var match = diffRegex.exec(line);\n    if (match) {\n      offset = null;\n      f.push({path: match[1], deletedLines: []});\n      return f;\n    }\n    var offsetMatch = offsetRegex.exec(line);\n    if (offsetMatch) {\n      offset = parseInt(offsetMatch[1], 10)\n      current = 0;\n      return f;\n    }\n    if (line.startsWith('-') && offset) {\n      f[f.length -1].deletedLines.push(current + offset);\n    }\n    if (!line.startsWith('+')) {\n      current++;\n    }\n    return f;\n  }, [])\n}\n\nfunction parseDiff(diff: string): Array<FileInfo> {\n  var files = [];\n  // The algorithm is designed to be best effort. If the http request failed\n  // for some reason and we get an empty file, we should not crash.\n  if (!diff || !diff.match(/^diff/)) {\n    return files;\n  }\n\n  var lines = diff.trim().split('\\n');\n  files = parseDiffFile(lines);\n\n  return files;\n}\n\n/**\n * Sadly, github doesn't have an API to get line by line blame for a file.\n * We could git clone the repo and blame, but it's annoying to have to\n * maintain a local git repo and the blame is going to be name + email instead\n * of the github username, so we'll have to do a http request anyway.\n *\n * There are two main ways to extract information from an HTML file:\n *   - First is to work like a browser: parse the html, build a DOM tree and\n *     use a jQuery-like API to traverse the DOM and extract what you need.\n *     The big issue is that creating the DOM is --extremely-- slow.\n *   - Second is to use regex to analyze the outputted html and find whatever\n *     we want.\n *\n * I(vjeux)'ve scraped hundreds of websites using both techniques and both of\n * them have the same reliability when it comes to the website updating their\n * markup. If they change what you are extracting you are screwed and if they\n * change something around, both are resistant to it when written properly.\n * So, might as well use the fastest one of the two: regex :)\n */\nfunction parseBlame(blame: string): Array<string> {\n  // The way the document is structured is that commits and lines are\n  // interleaved. So every time we see a commit we grab the author's name\n  // and every time we see a line we log the last seen author.\n  var re = /(<img(?:.*)alt=\"@([^\"]+)\"|<div class=\"blob-code blob-code-inner js-file-line\")/g;\n\n  var currentAuthor = 'none';\n  var lines = [];\n  var match;\n  while (match = re.exec(blame)) {\n    if (match[2]) {\n      currentAuthor = match[2];\n    } else {\n      lines.push(currentAuthor);\n    }\n  }\n\n  return lines;\n}\n\nfunction getDeletedOwners(\n  files: Array<FileInfo>,\n  blames: { [key: string]: Array<string> }\n): { [key: string]: number } {\n  var owners = {};\n  files.forEach(function(file) {\n    var blame = blames[file['path']];\n    if (!blame) {\n      return;\n    }\n    file.deletedLines.forEach(function (line) {\n      // In a perfect world, this should never fail. However, in practice, the\n      // blame request may fail, the blame is checking against master and the\n      // pull request isn't, the blame file was too big and the curl wrapper\n      // only read the first n bytes...\n      // Since the output of the algorithm is best effort, it's better to just\n      // swallow errors and have a less accurate implementation than to crash.\n      var name = blame[line - 1];\n      if (!name) {\n        return;\n      }\n      owners[name] = (owners[name] || 0) + 1;\n    });\n  });\n  return owners;\n}\n\nfunction getAllOwners(\n  files: Array<FileInfo>,\n  blames: { [key: string]: Array<string> }\n): { [key: string]: number } {\n  var owners = {};\n  files.forEach(function(file) {\n    var blame = blames[file.path];\n    if (!blame) {\n      return;\n    }\n    for (var i = 0; i < blame.length; ++i) {\n      var name = blame[i];\n      if (!name) {\n        return;\n      }\n      owners[name] = (owners[name] || 0) + 1;\n    }\n  });\n  return owners;\n}\n\nfunction getSortedOwners(\n  owners: { [key: string]: number }\n): Array<string> {\n  var sorted_owners = Object.keys(owners);\n  sorted_owners.sort(function(a, b) {\n    var countA = owners[a];\n    var countB = owners[b];\n    return countA > countB ? -1 : (countA < countB ? 1 : 0);\n  });\n  return sorted_owners;\n}\n\nasync function getDiffForPullRequest(\n  owner: string,\n  repo: string,\n  id: number,\n  github: Object\n): Promise<string> {\n  return new Promise(function(resolve, reject) {\n    github.pullRequests.get({\n      owner: owner,\n      repo: repo,\n      number: id,\n      headers: {Accept: 'application/vnd.github.diff'}\n    }, function (err, result) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result.data);\n      }\n    });\n  });\n}\n\nasync function getMatchingOwners(\n  files: Array<FileInfo>,\n  whitelist: Array<WhitelistUser>,\n  creator: string,\n  org: ?string,\n  github: Object\n): Promise<Array<string>> {\n  var owners = [];\n  var users = whitelist || [];\n\n  users.forEach(function(user) {\n    let userHasChangedFile = false;\n\n    user.files.forEach(function(pattern) {\n      if (!userHasChangedFile) {\n        userHasChangedFile = files.find(function(file) {\n          return minimatch(file.path, pattern, { dot: true });\n        });\n      }\n    });\n\n    if (userHasChangedFile && owners.indexOf(user.name) === -1) {\n      owners.push(user.name);\n    }\n  });\n\n  if (org) {\n    owners = await filterOwnTeam(users, owners, creator, org, github);\n  }\n  return owners;\n}\n\nasync function filterOwnTeam(\n  users: Array<WhitelistUser>,\n  owners: Array<string>,\n  creator: string,\n  org: string,\n  github: Object\n): Promise<Array<string>> {\n  if (!users.some(function(user) {\n    return user.skipTeamPrs;\n  })) {\n    return owners;\n  }\n\n  // GitHub does not provide an API to look up a team by name.\n  // Instead, get all teams, then filter against those matching\n  // our teams list who want to be excluded from their own PR's.\n  var teamData = await getTeams(org, github, 0);\n  teamData = teamData.filter(function(team) {\n    return users.some(function(user) {\n      return user.skipTeamPrs && user.name === team.name;\n    });\n  });\n  var promises = teamData.map(function(teamInfo) {\n    return getTeamMembership(creator, teamInfo, github);\n  });\n  var teamMemberships = await Promise.all(promises);\n  teamMemberships = teamMemberships.filter(function(membership) {\n    return membership.state === 'active';\n  });\n  return owners.filter(function(owner) {\n    return !teamMemberships.find(function(membership) {\n        return owner === membership.name;\n    });\n  });\n}\n\n/**\n * While developing/debugging the algorithm itself, it's very important not to\n * make http requests to github. Not only it's going to make the reload cycle\n * much slower, it's also going to temporary/permanently ban your ip and\n * you won't be able to get anymore work done when it happens :(\n */\nasync function fetch(url: string): Promise<string> {\n  const cacheKey = url.replace(/[^a-zA-Z0-9-_\\.]/g, '-');\n  return cacheGet(cacheKey, () => downloadFileAsync(url, githubAuthCookies));\n}\n\nasync function cacheGet(\n  cacheKey: string,\n  getFn: () => Promise<string>\n): Promise<string> {\n  if (!module.exports.enableCachingForDebugging) {\n    return getFn();\n  }\n\n  const cacheDir = __dirname + '/cache/';\n  if (!fs.existsSync(cacheDir)) {\n    fs.mkdir(cacheDir);\n  }\n\n  cacheKey = cacheDir + cacheKey;\n  if (!fs.existsSync(cacheKey)) {\n    const contents = await getFn();\n    fs.writeFileSync(cacheKey, contents);\n  }\n  return readFileAsync(cacheKey, 'utf8');\n}\n\nasync function getTeams(\n  org: string,\n  github: Object,\n  page: number\n): Promise<Array<TeamData>> {\n  const perPage = 100;\n  return new Promise(function(resolve, reject) {\n    github.orgs.getTeams({\n      org: org,\n      page: page,\n      per_page: perPage\n    }, function(err, teams) {\n      if (err) {\n        reject(err);\n      } else {\n        var teamData = teams.map(function(team) {\n          return {\n            name: org + \"/\" + team.slug,\n            id: team.id\n          };\n        });\n        if (teamData.length === perPage) {\n          getTeams(org, github, ++page).then(function(results) {\n            resolve(teamData.concat(results));\n          })\n          .catch(reject);\n        } else {\n          resolve(teamData);\n        }\n      }\n    });\n  });\n}\n\nasync function getOwnerOrgs(\n  username: string,\n  github: Object\n): Promise<Array<string>> {\n  return new Promise(function(resolve, reject) {\n    github.orgs.getForUser({ username: username }, function(err, result) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(\n          result.map(function (obj){\n            return obj.login;\n          })\n        );\n      }\n    });\n  });\n}\n\nasync function getMembersOfOrg(\n  org: string,\n  github: Object,\n  page: number\n): Promise<Array<string>> {\n  const perPage = 100;\n  return new Promise(function(resolve, reject) {\n    github.orgs.getMembers({\n      org: org,\n      page: page,\n      per_page: perPage\n    }, function(err, members) {\n      if (err) {\n        reject(err);\n      } else {\n        var logins = members.map(function (obj){\n          return obj.login;\n        })\n        if(logins.length === perPage) {\n          getMembersOfOrg(org, github, ++page).then(function(results) {\n            resolve(logins.concat(results));\n          })\n          .catch(reject);\n        } else {\n          resolve(logins);\n        }\n      }\n    });\n  });\n}\n\nasync function filterRequiredOrgs(\n  owners: Array<string>,\n  config: Object,\n  github: Object\n): Promise<Array<string>> {\n  var promises = config.requiredOrgs.map(function(reqOrg) {\n    return getMembersOfOrg(reqOrg, github, 0);\n  })\n\n  var currentMembers = [].concat.apply([], await Promise.all(promises));\n  return owners.filter(function(owner) {\n    // User passes if they are in any of the required organizations\n    return currentMembers.indexOf(owner) >= 0;\n  });\n}\n\nasync function getTeamMembership(\n  creator: string,\n  teamData: TeamData,\n  github: Object\n): Promise<TeamMembership> {\n  return new Promise(function(resolve, reject) {\n    github.orgs.getTeamMembership({\n      id: teamData.id,\n      username: creator\n    }, function(err, data) {\n      if (err) {\n        if (err.code === 404 &&\n                err.message === '{\"message\":\"Not Found\",\"documentation_url\":\"https://developer.github.com/v3/orgs/teams/#get-team-membership\"}') {\n          resolve({name: teamData.name, state: 'nonmember'});\n        } else {\n          reject(err);\n        }\n      } else {\n        resolve({name: teamData.name, state: data.state});\n      }\n    });\n  });\n}\n\n/**\n * If the repo is private than we should only mention users that are still part\n * of that org.\n * Otherwise we could end up with a situation where all the people mentioned have\n * left the org and none of the current staff get notified\n**/\n\nasync function filterPrivateRepo(\n  owners: Array<string>,\n  org: string,\n  github: Object\n): Promise<Array<string>> {\n  var currentMembers = await getMembersOfOrg(org, github, 0);\n\n  return owners.filter(function(owner, index) {\n    // user passes if they are still in the org\n    return currentMembers.some(function(member) {\n      return member === owner;\n    });\n  });\n}\n\n/**\n * The problem at hand is to find a set of three best effort people that have\n * context on a pull request. It doesn't (and actually can't) be perfect.\n *\n * The most precise information we have is when someone deletes or modifies\n * a line of code. We know who last touched those lines and they are most\n * likely good candidates for reviewing the code.\n * This is of course not always the case, people can codemod big number of\n * lines and have very little context on that particular one, people move\n * file around and absorb all the blame...\n *\n * But, not all pull requests modify code, many of them just add new lines.\n * I first played with giving credit to people that blamed the lines around\n * but it was unclear how to spread out the credit.\n * A much dumber strategy but which has proven to be effective is to\n * completely ignore new lines and instead find the people that are blamed\n * for the biggest number of lines in the file.\n *\n * Given those two observations, the algorithm is as follow:\n *  - For each line that has been deleted, give 1 ponumber to the blamed author\n *    in a 'deletedOwners' pool.\n *  - For each file that has been touched, for each line in that file, give 1\n *    ponumber to the blamed author in a 'allOwners' pool.\n *  Once you've got those two pools, sort them by number of points, dedupe\n *  them, concat them and finally take the first 3 names.\n */\nasync function guessOwners(\n  files: Array<FileInfo>,\n  blames: { [key: string]: Array<string> },\n  creator: string,\n  defaultOwners: Array<string>,\n  fallbackOwners: Array<string>,\n  privateRepo: boolean,\n  org: ?string,\n  config: Object,\n  github: Object\n): Promise<Array<string>> {\n  var deletedOwners = getDeletedOwners(files, blames);\n  var allOwners = getAllOwners(files, blames);\n\n  deletedOwners = getSortedOwners(deletedOwners);\n  allOwners = getSortedOwners(allOwners);\n\n  // Remove owners that are also in deletedOwners\n  var deletedOwnersSet = new Set(deletedOwners);\n  var allOwners = allOwners.filter(function(element) {\n    return !deletedOwnersSet.has(element);\n  });\n\n  var owners = []\n    .concat(deletedOwners)\n    .concat(allOwners)\n    .filter(function(owner) {\n      return owner !== 'none';\n    })\n    .filter(function(owner) {\n      return owner !== creator;\n    })\n    .filter(function(owner) {\n      return config.userBlacklist.indexOf(owner) === -1;\n    });\n\n  if (config.requiredOrgs.length > 0) {\n    owners = await filterRequiredOrgs(owners, config, github);\n  }\n\n  if (privateRepo && org != null) {\n    owners = await filterPrivateRepo(owners, org, github);\n  }\n\n  if (owners.length === 0) {\n    defaultOwners = defaultOwners.concat(fallbackOwners);\n  }\n\n  return owners\n    .slice(0, config.maxReviewers)\n    .concat(defaultOwners)\n    .filter(function(owner, index, ownersFound) {\n      return ownersFound.indexOf(owner) === index;\n    });\n}\n\nasync function guessOwnersForPullRequest(\n  repoURL: string,\n  id: number,\n  creator: string,\n  targetBranch: string,\n  privateRepo: boolean,\n  org: ?string,\n  config: Object,\n  github: Object\n): Promise<Array<string>> {\n  const ownerAndRepo = repoURL.split('/').slice(-2);\n  const cacheKey = `${repoURL}-pull-${id}.diff`.replace(/[^a-zA-Z0-9-_\\.]/g, '-');\n  const diff = await cacheGet(\n    cacheKey,\n    () => getDiffForPullRequest(ownerAndRepo[0], ownerAndRepo[1], id, github)\n  );\n  var files = parseDiff(diff);\n  var defaultOwners = await getMatchingOwners(files, config.alwaysNotifyForPaths, creator, org, github);\n  var fallbackOwners = await getMatchingOwners(files, config.fallbackNotifyForPaths, creator, org, github);\n  if (!config.findPotentialReviewers) {\n      return defaultOwners;\n  }\n\n  // There are going to be degenerated changes that end up modifying hundreds\n  // of files. In theory, it would be good to actually run the algorithm on\n  // all of them to get the best set of reviewers. In practice, we don't\n  // want to do hundreds of http requests. Using the top 5 files is enough\n  // to get us 3 people that may have context.\n  files.sort(function(a, b) {\n    var countA = a.deletedLines.length;\n    var countB = b.deletedLines.length;\n    return countA > countB ? -1 : (countA < countB ? 1 : 0);\n  });\n  // remove files that match any of the globs in the file blacklist config\n  config.fileBlacklist.forEach(function(glob) {\n    files = files.filter(function(file) {\n      return !minimatch(file.path, glob);\n    });\n  });\n  files = files.slice(0, config.numFilesToCheck);\n\n  var blames = {};\n  // create blame promises (allows concurrent loading)\n  var promises = files.map(function(file) {\n    return fetch(repoURL + '/blame/' + targetBranch + '/' + file.path);\n  });\n\n  // wait for all promises to resolve\n  var results = await Promise.all(promises);\n  results.forEach(function(result, index) {\n    blames[files[index].path] = parseBlame(result);\n  });\n\n  // This is the line that implements the actual algorithm, all the lines\n  // before are there to fetch and extract the data needed.\n  return guessOwners(files, blames, creator, defaultOwners, fallbackOwners, privateRepo, org, config, github);\n}\n\nmodule.exports = {\n  enableCachingForDebugging: false,\n  parseDiff: parseDiff,\n  parseBlame: parseBlame,\n  guessOwnersForPullRequest: guessOwnersForPullRequest,\n};\n"
        },
        {
          "name": "message.js",
          "type": "blob",
          "size": 0.9501953125,
          "content": "/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n'use strict';\n\nmodule.exports = function(\n  reviewers: Array<string>,\n  pullRequester: string,\n  mentionSentenceBuilder: (reviewers: Array<string>) => string,\n  defaultMessageGenerator: (reviewers: Array<string>, pullRequester: string) => string\n): string {\n\n  // This file is a place where you can change the way the message the bot\n  // uses to comment. For example:\n  //\n  //   return pullRequester + ', thanks!' + mentionSentenceBuilder(reviewers) + \n  //          ', please review this';\n  //\n  // will print\n  //\n  //   @hunkim, thanks! @georgecodes and @vjeux, please review this.\n\n\treturn defaultMessageGenerator(reviewers, pullRequester);\n};\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.962890625,
          "content": "{\n  \"name\": \"mention-bot\",\n  \"version\": \"3.0.2\",\n  \"license\": \"BSD-3-Clause\",\n  \"repository\": \"facebook/mention-bot\",\n  \"scripts\": {\n    \"test\": \"flow && jest\",\n    \"start\": \"node run-server.js\"\n  },\n  \"main\": \"./run-mention-bot.js\",\n  \"engines\": {\n    \"node\": \">=4\"\n  },\n  \"jest\": {\n    \"scriptPreprocessor\": \"<rootDir>/node_modules/babel-jest\",\n    \"unmockedModulePathPatterns\": [\n      \"core-js/.*\"\n    ]\n  },\n  \"config\": {},\n  \"dependencies\": {\n    \"babel-core\": \"^6.0.0\",\n    \"babel-jest\": \"^6.0.1\",\n    \"babel-plugin-syntax-async-functions\": \"^6.1.4\",\n    \"babel-plugin-transform-object-rest-spread\": \"^6.1.18\",\n    \"babel-plugin-transform-regenerator\": \"^6.1.4\",\n    \"babel-polyfill\": \"^6.1.4\",\n    \"babel-preset-react\": \"^6.1.2\",\n    \"bl\": \"^1.0.0\",\n    \"download-file-sync\": \"^1.0.3\",\n    \"express\": \"^4.13.3\",\n    \"flow-bin\": \"^0.60.1\",\n    \"github\": \"^7.3.2\",\n    \"jest-cli\": \"^0.7.1\",\n    \"jsonlint\": \"^1.6.2\",\n    \"minimatch\": \"^3.0.0\",\n    \"node-schedule\": \"^1.0.0\"\n  }\n}\n"
        },
        {
          "name": "run-mention-bot.js",
          "type": "blob",
          "size": 0.4052734375,
          "content": "/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nrequire('babel-core/register');\nrequire('babel-polyfill');\nmodule.exports = require('./mention-bot.js');\n"
        },
        {
          "name": "run-server.js",
          "type": "blob",
          "size": 0.3837890625,
          "content": "/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nrequire('babel-core/register');\nrequire('babel-polyfill');\nrequire('./server.js');\n"
        },
        {
          "name": "schedule.js",
          "type": "blob",
          "size": 2.32421875,
          "content": "/**\n * Copyright (c) 2016-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n'use strict';\n\nvar minimatch = require('minimatch');\nvar nodeSchedule = require('node-schedule');\n\n\nvar schedule: { jobs: Array<any>, work: Function, performAt: Function, parse: Function } = {\n  jobs: [],\n\n  work: function(time: Date, callback: Function){\n    var promise: Promise<void> = new Promise(function(resolve, reject: (error: any) => void){\n      callback(resolve, reject);\n    });\n\n    var job = nodeSchedule.scheduleJob(time, promise);\n    this.jobs.push(job);\n\n    return promise;\n  },\n\n  performAt: async function(time: Date, callback: Function) {\n    try {\n      await this.work(time, callback);\n    } catch(e) {\n      console.error(e)\n    }\n  },\n\n  parse: function(delayTime: string): Date {\n    var moment: Array<string> = [\n        'm', 'min', 'mins', 'minute', 'minutes',\n        'h', 'hour', 'hours',\n        'd', 'day', 'days'\n      ];\n    var invalidTimeMsg: string = 'Invalid delay time setting, it should in following format:\\n' +\n      '3m, 3 m, or 3 min\\naccepted moments are: ' + moment.join(', ') + '\\n instead got ' + delayTime + '\\n';\n\n    if(!minimatch(delayTime, '*+(' + moment.join('|') + ')')) {\n      throw new Error(invalidTimeMsg);\n    }\n\n    var curTime: Date = new Date();\n    var minutes: number = curTime.getMinutes();\n    var hours: number = curTime.getHours();\n    var day: number = curTime.getDate();\n    var month: number = curTime.getMonth();\n    var year: number = curTime.getFullYear();\n    var parsedTime: ?Array<string> = delayTime.match(/(\\d+)\\s?(\\w*)/);\n    var time: number | false = false;\n\n    if(parsedTime) {\n      time = parseInt(parsedTime[1]);\n    }\n\n    if(!parsedTime || !time){\n      throw new Error(invalidTimeMsg);\n    }\n\n    switch (parsedTime[2][0]) {\n      case 'm':\n        minutes += time;\n        break;\n      case 'h':\n        hours += time;\n        break;\n      case 'd':\n        day += time;\n        break;\n      default:\n        throw new Error(invalidTimeMsg);\n    }\n\n    return new Date(year, month, day, hours, minutes, curTime.getSeconds(), 0);\n  }\n};\n\nmodule.exports = schedule;\n"
        },
        {
          "name": "server.js",
          "type": "blob",
          "size": 12.9326171875,
          "content": "/**\n * Copyright (c) 2016-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\nvar bl = require('bl');\nvar config = require('./config');\nvar express = require('express');\nvar fs = require('fs');\nvar mentionBot = require('./mention-bot.js');\nvar messageGenerator = require('./message.js');\nvar util = require('util');\nvar schedule = require('./schedule.js');\n\nvar GitHubApi = require('github');\nvar jsonlint = require('jsonlint');\n\nvar CONFIG_PATH = '.mention-bot';\n\nif (!process.env.GITHUB_TOKEN) {\n  console.error('The bot was started without a GitHub account to post with.');\n  console.error('To get started:');\n  console.error('1) Create a new account for the bot');\n  console.error('2) Settings > Personal access tokens > Generate new token');\n  console.error('3) Only check `public_repo` and click Generate token');\n  console.error('4) Run the following command:');\n  console.error('GITHUB_TOKEN=insert_token_here npm start');\n  console.error('5) Run the following command in another tab:');\n  console.error('curl -X POST -d @__tests__/data/23.webhook http://localhost:5000/');\n  console.error('6) Check if it has commented here: https://github.com/fbsamples/bot-testing/pull/23');\n  process.exit(1);\n}\n\nif (!process.env.GITHUB_USER) {\n  console.warn(\n    'There was no GitHub user detected.',\n    'This is fine, but mention-bot won\\'t work with private repos.'\n  );\n  console.warn(\n    'To make mention-bot work with private repos, please expose',\n    'GITHUB_USER and GITHUB_PASSWORD as environment variables.',\n    'The username and password must have access to the private repo',\n    'you want to use.'\n  );\n}\n\nvar github = new GitHubApi({\n  host: config.github.apiHost,\n  pathPrefix: config.github.pathPrefix,\n  protocol: config.github.protocol,\n  port: config.github.port\n});\n\ngithub.authenticate({\n  type: 'oauth',\n  token: process.env.GITHUB_TOKEN\n});\n\nvar app = express();\n\nfunction buildMentionSentence(reviewers) {\n  var atReviewers = reviewers.map(function(owner) { return '@' + owner; });\n\n  if (reviewers.length === 1) {\n    return atReviewers[0];\n  }\n\n  return (\n    atReviewers.slice(0, atReviewers.length - 1).join(', ') +\n    ' and ' + atReviewers[atReviewers.length - 1]\n  );\n}\n\nfunction getDefaultMessageGenerator(findPotentialReviewers) {\n  return function(reviewers, pullRequester) {\n    return util.format(\n      '%s, thanks for your PR! ' +\n      '%se identified %s to be%s potential reviewer%s.',\n      pullRequester,\n      findPotentialReviewers ? 'By analyzing the history of the files in this pull request, w' : 'W',\n      buildMentionSentence(reviewers),\n      reviewers.length > 1 ? '' : ' a',\n      reviewers.length > 1 ? 's' : ''\n    );\n  }\n}\n\nfunction configMessageGenerator(message, reviewers, pullRequester) {\n  var withReviewers = message.replace(/@reviewers/g, buildMentionSentence(reviewers));\n  return withReviewers.replace(/@pullRequester/g, pullRequester);\n}\n\nfunction getRepoConfig(request) {\n  return new Promise(function(resolve, reject) {\n    github.repos.getContent(request, function(err, result) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      try {\n        var data = JSON.parse(result.data);\n        resolve(data);\n      } catch (e) {\n        try {\n          e.repoConfig = result.data;\n        } catch (e) {}\n        reject(e);\n      }\n    });\n  });\n}\n\nasync function work(body) {\n  var data = {};\n  try {\n    data = JSON.parse(body.toString());\n    console.log(data.pull_request.html_url);\n  } catch (e) {\n    console.error(e);\n  }\n\n  // default config\n  var repoConfig = {\n    maxReviewers: 3,\n    numFilesToCheck: 5,\n    userBlacklist: [],\n    userBlacklistForPR: [],\n    userWhitelist: [],\n    fileBlacklist: [],\n    requiredOrgs: [],\n    findPotentialReviewers: true,\n    actions: ['opened'],\n    branches:[],\n    skipAlreadyAssignedPR: false,\n    skipAlreadyMentionedPR: false,\n    delayed: false,\n    delayedUntil: '3d',\n    assignToReviewer: false,\n    createReviewRequest: false,\n    createComment: true,\n    skipTitle: '',\n    withLabel: '',\n    skipCollaboratorPR: false,\n  };\n\n  if (process.env.MENTION_BOT_CONFIG) {\n    try {\n      repoConfig = {\n        ...repoConfig,\n        ...JSON.parse(process.env.MENTION_BOT_CONFIG)\n      };\n    } catch(e) {\n      console.error(\n        'Error attempting to read the config from the environment variable ' +\n        ' MENTION_BOT_CONFIG'\n      );\n      console.error(e);\n    }\n  }\n\n  try {\n    // request config from repo\n    var configRes = await getRepoConfig({\n      owner: data.repository.owner.login,\n      repo: data.repository.name,\n      ref: data.pull_request.base.ref,\n      path: CONFIG_PATH,\n      headers: {\n        Accept: 'application/vnd.github.v3.raw+json'\n      }\n    }).catch(function(e) {\n      if (e instanceof SyntaxError && repoConfig.actions.indexOf(data.action) !== -1) {\n        // Syntax error while reading custom configuration file\n        var errorLog = '';\n        try {\n          jsonlint.parse(e.repoConfig)\n        } catch(err) {\n          errorLog = err;\n        }\n        var message =\n          'Unable to parse mention-bot custom configuration file due to a syntax error.\\n' +\n          'Please check the potential root causes below:\\n\\n' +\n          '1. Having comments\\n' +\n          '2. Invalid JSON type\\n' +\n          '3. Having extra \",\" in the last JSON attribute\\n\\n' +\n          'Error message:\\n' +\n          '```\\n' + errorLog + '\\n```';\n        createComment(data, message);\n      }\n    });\n    repoConfig = {...repoConfig, ...configRes};\n  } catch (e) {\n    if (e.code === 404 &&\n        e.message.match(/message.*Not Found.*documentation_url.*developer.github.com/)) {\n      console.log('Couldn\\'t find ' + CONFIG_PATH + ' in repo. Continuing with default configuration.');\n    } else {\n      console.error(e);\n    }\n  }\n\n  function isValid(repoConfig, data) {\n    if (repoConfig.branches && repoConfig.branches.length > 0 && repoConfig.branches.indexOf(data.pull_request.base.ref) === -1) {\n      console.log(\n        'Skipping because base ref is \"' + data.pull_request.base.ref + '\".',\n        'We only care about: \"' + repoConfig.branches.join(\"', '\") + '\"'\n      );\n      return false;\n    }\n\n    if (repoConfig.actions.indexOf(data.action) === -1) {\n      console.log(\n        'Skipping because action is \"' + data.action + '\".',\n        'We only care about: \"' + repoConfig.actions.join(\"', '\") + '\"'\n      );\n      return false;\n    }\n\n    if (repoConfig.withLabel && data.label &&\n        data.label.name != repoConfig.withLabel) {\n      console.log('Skipping because pull request does not have label: \"' + repoConfig.withLabel + '\".');\n      return false;\n    }\n\n    if (repoConfig.skipTitle &&\n        data.pull_request.title.indexOf(repoConfig.skipTitle) > -1) {\n      console.log('Skipping because pull request title contains: \"' + repoConfig.skipTitle + '\".');\n      return false;\n    }\n\n    if (repoConfig.skipCollaboratorPR) {\n      github.repos.checkCollaborator({\n        owner: data.repository.owner.login, // 'fbsamples'\n        repo: data.repository.name, // 'bot-testing'\n        username: data.pull_request.user.login\n      }, function(err, res){\n        if (res && res.meta.status === '204 No Content') {\n          console.log('Skipping because pull request is made by collaborator.');\n          return false;\n        }\n      });\n    }\n\n    if (repoConfig.skipAlreadyAssignedPR &&\n        data.pull_request.assignee &&\n        data.pull_request.assignee.login) {\n      console.log('Skipping because pull request is already assigned.');\n      return false;\n    }\n\n    if (process.env.REQUIRED_ORG) {\n      if (repoConfig.requiredOrgs.indexOf(process.env.REQUIRED_ORG) === -1) {\n        repoConfig.requiredOrgs.push(process.env.REQUIRED_ORG);\n      }\n    }\n\n    if (repoConfig.userBlacklistForPR.indexOf(data.pull_request.user.login) >= 0) {\n      console.log('Skipping because blacklisted user created Pull Request.');\n      return false;\n    }\n\n    if (repoConfig.skipTitle &&\n        data.pull_request.title.indexOf(repoConfig.skipTitle) > -1) {\n      console.log('Skipping because pull request title contains: \"' + repoConfig.skipTitle + '\".');\n      return false;\n    }\n\n    return true;\n  }\n\n  if (!isValid(repoConfig, data)) {\n    return;\n  }\n\n  var org = null;\n\n  if (data.organization) {\n    org = data.organization.login;\n  }\n\n  var reviewers = await mentionBot.guessOwnersForPullRequest(\n    data.repository.html_url, // 'https://github.com/fbsamples/bot-testing'\n    data.pull_request.number, // 23\n    data.pull_request.user.login, // 'mention-bot'\n    data.pull_request.base.ref, // 'master'\n    data.repository.private, //true or false\n    org, //the org name of the repo\n    repoConfig,\n    github\n  );\n\n  console.log('Reviewers:', reviewers);\n\n  if (reviewers.length === 0) {\n    console.log('Skipping because there are no reviewers found.');\n    return;\n  }\n\n  var message = null;\n  if (repoConfig.message) {\n    message = configMessageGenerator(\n      repoConfig.message,\n      reviewers,\n      '@' + data.pull_request.user.login\n    );\n  } else {\n    message = messageGenerator(\n      reviewers,\n      '@' + data.pull_request.user.login, // pull-requester\n      buildMentionSentence,\n      getDefaultMessageGenerator(repoConfig.findPotentialReviewers)\n    );\n  }\n\n  function createComment(data, message, reject) {\n    if (!repoConfig.createComment) {\n      return;\n    }\n\n    github.issues.createComment({\n      owner: data.repository.owner.login, // 'fbsamples'\n      repo: data.repository.name, // 'bot-testing'\n      number: data.pull_request.number, // 23\n      body: message\n    }, function(err) {\n      if (err) {\n        if (typeof reject === 'function') {\n          return reject(err);\n        }\n      }\n    })\n  }\n\n  function assignReviewer(data, reviewers, reject) {\n    if (!repoConfig.assignToReviewer) {\n      return;\n    }\n\n    github.issues.edit({\n      owner: data.repository.owner.login, // 'fbsamples'\n      repo: data.repository.name, // 'bot-testing'\n      number: data.pull_request.number, // 23\n      assignees: reviewers\n    }, function(err) {\n      if (err) {\n        if (typeof reject === 'function') {\n          return reject(err);\n        }\n      }\n    });\n  }\n\n  function requestReview(data, reviewers, reject) {\n    if (!repoConfig.createReviewRequest) {\n      return;\n    }\n\n    github.pullRequests.createReviewRequest({\n      owner: data.repository.owner.login, // 'fbsamples'\n      repo: data.repository.name, // 'bot-testing'\n      number: data.pull_request.number, // 23\n      reviewers: reviewers\n    }, function(err) {\n      if (err) {\n        if (typeof reject === 'function') {\n          return reject(err);\n        }\n      }\n    });\n  }\n\n  function getComments(data, page) {\n    return new Promise(function(resolve, reject) {\n      github.issues.getComments({\n        owner: data.repository.owner.login, // 'fbsamples'\n        repo: data.repository.name, // 'bot-testing'\n        number: data.pull_request.number, // 23\n        page: page, // 1\n        per_page: 100 // maximum supported\n      }, function(err, result) {\n        if (err) {\n          reject(err);\n        }\n        resolve(result);\n      });\n    });\n  }\n\n  if (repoConfig.skipAlreadyMentionedPR) {\n    var page;\n    var comments = [[]];\n\n    for (page = 1; comments.length != 0; ++page) {\n      comments = await getComments(data, page);\n      if (comments.find(function(comment) {\n        return comment.body == message;\n      })) {\n        console.log('Skipping because there is already existing an exact mention.');\n        return;\n      }\n    }\n  }\n\n  if (repoConfig.delayed) {\n    schedule.performAt(schedule.parse(repoConfig.delayedUntil), function(resolve, reject) {\n      github.pullRequests.get({\n        owner: data.repository.owner.login,\n        repo: data.repository.name,\n        number: data.pull_request.number\n      }, function(err, currentData) {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        if (!isValid(repoConfig, currentData)) {\n          reject('PR validation failed');\n          return;\n        }\n\n        createComment(currentData, message, reject);\n        assignReviewer(currentData, reviewers, reject);\n        requestReview(currentData, reviewers, reject);\n      });\n    });\n  } else {\n    createComment(data, message);\n    assignReviewer(data, reviewers);\n    requestReview(data, reviewers);\n  }\n\n  return;\n};\n\napp.post('/', function(req, res) {\n  req.pipe(bl(function(err, body) {\n    work(body)\n      .then(function() { res.end(); })\n      .catch(function(e) {\n        console.error(e);\n        console.error(e.stack);\n        res.status(500).send('Internal Server Error');\n      });\n  }));\n});\n\napp.get('/', function(req, res) {\n  res.send(\n    'GitHub Mention Bot Active. ' +\n    'Go to https://github.com/facebook/mention-bot for more information.'\n  );\n});\n\napp.set('port', process.env.PORT || 5000);\n\napp.listen(app.get('port'), function() {\n  console.log('Listening on port', app.get('port'));\n});\n"
        }
      ]
    }
  ]
}