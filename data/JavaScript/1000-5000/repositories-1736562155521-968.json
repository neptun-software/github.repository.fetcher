{
  "metadata": {
    "timestamp": 1736562155521,
    "page": 968,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tc39/proposal-observable",
      "stars": 3078,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".babelrc",
          "type": "blob",
          "size": 0.0556640625,
          "content": "{\n    \"plugins\": [\"transform-es2015-modules-commonjs\"]\n}\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0498046875,
          "content": ".DS_Store\n_*\nnode_modules\nObservableTests\ncommonjs\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.0283203125,
          "content": ".DS_Store\n_*\nObservableTests\n"
        },
        {
          "name": "Can Observable be built on Cancel Tokens.md",
          "type": "blob",
          "size": 31.5283203125,
          "content": "# Can Observable be built on CancelTokens rather than Subscriptions?\n\nThe current proposal specifies that the Observable prototype contains two methods that allow a consumer to receive their notifications:\n\n1. forEach\n2. subscribe\n\nThe forEach function accepts a Cancel Token, and executes unsubscription logic when a cancellation notification is received from the token.\n\nIn contrast, the subscribe method returns a Subscription object. Subscription objects are basically thunks which synchronously execute unsubscription logic.\n\nIt has been proposed that Observable’s `subscribe` method should accept a `CancelToken` rather than returning a `Subscription` object. The main rationale for this change is reduced API surface area. Rather than learning about two concepts which can be used to cancel an asynchronous operation, developers would only have to learn about one.\n\n\nThis document will explore whether Observable can be built on cancel tokens, and outline what changes (if any) would need to be made to both the cancelable promises and observable proposals.\n\n## Replacing Subscriptions with CancelTokens\n\nIn order to implement Observable with CancelTokens rather than Subscriptions, the following changes must be made to the observable and cancelable promises specifications respectively:\n\n1. Modify subscribe to accept a CancelToken instead of returning Subscription\n2. Replace `error` method in Observer with `else` and `catch`\n3. Replace SubscriptionObserver with CancelTokenObserver\n4. Ensure CancelTokens weakly reference input tokens\n5. Ensure CancelTokens propagate cancellation notifications synchronously\n\n### Modifying subscribe to accept a CancelToken instead of returning a Subscription\n\nThis is the API of the Subscription-based Observable:\n```js\ninterface Observable {\n    constructor(subscriber : SubscriberFunction);\n    subscribe(observer : Observer) : Subscription;\n    // more snipped...\n}\n\nfunction SubscriberFunction(observer: SubscriptionObserver) : (void => void) | Subscription;\n```\n\nIn order to build Observable on cancel tokens, the API of the Observable would need to be changed to this:\n\n```js\ninterface Observable {\n    constructor(subscriber : SubscriberFunction);\n    subscribe(observer : Observer, token : CancelToken | void) : void;\n    // more snipped.\n}\nfunction SubscriberFunction(observer: CancelTokenObserver, token : CancelToken) : void\n```\n\n\nHere’s an example of a CancelToken-based Observable being created and consumed:\n\n\n```js\nlet bodyMouseMoves = new Observable((observer, token) => {\n  handler = event => observer.next(event);\n  token.promise.then(() => document.body.removeEventListener(\"mousemove\", handler));\n  document.body.addEventListener(\"mousemove\", handler);\n});\n\nlet { token, cancel } = CancelToken.source();\nbodyMouseMoves.subscribe(\n  {\n    next(event) {\n      if (event.clientX <= 50) {\n        console.log(\"mouse hasn’t moved passed 50px\");\n      }\n      else {\n        token.cancel(new Cancel(\"Only want to listen to mouse until it moves passed 50px\"));\n      }\n    }\n  },\n  token);\n```\n\n\nNote that in order to cancel a subscription, the consumer must cancel the token passed to `subscribe`. The Cancelable Promises proposal dictates that when an asynchronous function is canceled, the Promise must resolve to a Cancel object. In order to allow developers to avoid inadvertently catching Cancel objects, the Cancelable Promises proposal adds a `else` method to the Promise prototype. This method only receives rejected values which are not `Cancel` instances, allowing Cancel instances to propagate.\n\n\nIf Observables are to be built on cancel tokens, consumers must be able to differentiate whether a subscription closed due to either cancellation or error.\n\n### Replacing `error` method in Observer with `else` and `catch`\n\n\nIn the Subscription-based proposal, Observers have only one method which receives errors:\n\n\n```js\ninterface Observer {\n  next(v:any):any\n  error(e:anythingButCancel):any\n  complete(v:any):any\n}\n```\n\n\nIf Subscriptions are to be replaced with CancelTokens, consumers of Observables must be differentiate whether a subscription was closed due to cancellation or error. One way of accomplishing this is to replace Observer’s `error` method with two methods: `else` and `catch`.\n\n\n```js\ninterface Observer {\n  next(v:any):any\n  else(e:anythingButCancel):any\n  catch(e:any):any\n  complete(v:any):any\n}\n```\n\n\nNote that the new Observer methods correspond to the Promise prototype methods proposed in the Cancelable Promises Proposal. If the `else` method is defined, the Observable will call it with the value - provided that the value is not a `Cancel` instance. Otherwise if the `catch` method is defined on the Observer, `catch` will be passed the value regardless of whether it is a Cancel instance or not.\n\n\nThis raises an important question: how will usercode which catches errors invoke the right method on the Observer? The Cancelable Promises proposal does not currently provide a brand check for `Cancel` instances. Furthermore `try` statements cannot contain both an `else` and `catch` block.\n\n\nIn the next section a change to the subscribe API will be proposed to enable Observable implementations to notify the right method on the Observer if a subscription is closed due to failure.\n\n### Replacing SubscriptionObserver with CancelTokenObserver\n\nThe Subscription-based proposal specifies a SubscriptionObserver.\n\n```js\ninterface SubscriptionObserver {\n\n    // Sends the next value in the sequence\n    next(value);\n\n    // Sends the sequence error\n    error(errorValue);\n\n    // Sends the sequence completion value\n    complete(completeValue);\n\n    // A boolean value indicating whether the subscription is closed\n    get closed() : Boolean;\n}\n```\n\nIn the Subscription-based proposal, a SubscriptionObserver is created which wraps the input Observer whenever `subscribe` is invoked. Then the `subscribe` method passes the SubscriptionObserver to the subscribe implementation provided to the Observable constructor.\nWrapping the observer in a SubscriptionObserver is beneficial for the following reasons:\n\n* it normalizes the input Observer API, ensuring that all methods are present.\n* it ensures that no notifications are delivered to the Observer after the subscription is closed.\n\n\nif Subscriptions are replaced with Cancel Tokens,  it is necessary to replace the `SubscriptionObserver` with a `CancelTokenObserver`.\n\n\n```js\nclass CancelTokenObserver {\n   // Sends the next value in the sequence\n    next(value);\n\n    // If wrapped observer is CancelTokenObserver\n    //   calls throw on wrapped observer\n    // Else if errorValue is _not_ Cancel and wrapped observer has else method\n    //   calls else on wrapped observer\n    // Else if wrapped observer has catch method\n    //   calls catch on wrapped observer\n    throw(errorValue);\n\n    // Receives all error values except Cancels\n    else(errorValue);\n\n    // When present alongside else method, receives only Cancels. If else method does not exist on Observer, receives all errors.\n    catch(errorValue);\n\n    // Sends the sequence completion value\n    complete(completeValue);\n}\n```\n\n\nThe `CancelTokenObserver` provides the same benefits as the `SubscriptonObserver`. However in addition to the Observer contract, the CancelTokenObserver prototype contains a `throw` method.\n\n\nIf the Observer wrapped by CancelTokenObserver is a CancelTokenObserver, the throw method will forward the value to the wrapped Observer’s throw method. Otherwise if an `else` method is defined on the Observer wrapped by CancelTokenObserver, the throw method forwards its input value to that `else` method - provided that the input value is not a `Cancel` instance. Otherwise if the `catch` method is defined on the Observer wrapped by CancelTokenObserver then the throw method will forward its input to `catch`. Finally if no suitable method on the observer can be found to receive the caught value, the error will be logged using HostReportErrors.\n\n\nIn order to leverage throw, implementations of `subscribe` should always use the `catch` clause when invoking an operation that may fail. If a value is caught, the subscribe implementation should pass the value to the `CancelTokenObserver`’s throw method. This will ensure that the value is delegated to the correct method on the `Observer`.\n\n\nHere’s an example of this pattern in action:\n\n\n```js\nfunction map(observable, projection) {\n    return new Observable((observer, token) => {\n        const self = this;\n        let index = 0;\n        observable.subscribe(\n            {\n                next(value) {\n                    try {\n                        value = projection(value, index++, self);\n                    }\n                    catch(e) {\n                        return observer.throw(e);\n                    }\n\n\n                    observer.next(value);\n                },\n                catch(e) {\n                    observer.throw(e);\n                },\n                complete(v) {\n                    observer.complete(v);\n                }\n            },\n            token);\n    });\n}\n```\n\n\nIf it's input token is canceled, Observable’s subscribe method will notify the observer’s`catch` method. Here’s a polyfill of the Observable constructor and the `subscribe` method demonstrating how the Observer is notified on token cancellation.\n\n\n```js\nclass Observable {\n    constructor(subscriber) {\n        // The stream subscriber must be a function\n        if (typeof subscriber !== \"function\")\n            throw new TypeError(\"Observable initializer must be a function\");\n\n\n        this._subscriber = subscriber;\n    }\n\n\n    subscribe(observer, token) {\n        if (Object(observer) !== observer) {\n            throw new TypeError(observer + \" is not a object\");\n        }\n\n\n        if (token != null && Object(token) !== token) {\n            throw new TypeError(token + \" is not an object\");\n        }\n\n\n        if (token == null) {\n            token = new CancelToken(() => {});\n        }\n\n\n        token.promise.then(cancel => observer.catch(cancel));\n        observer = new CancelTokenObserver(observer, token);\n\n\n        const reason = token.reason;\n        if (reason) {\n            return observer.catch(reason);\n        }\n\n\n        try {\n            this._subscriber(observer, token);\n        } catch(e) {\n            observer.throw(e);\n        }\n    }\n    // rest snipped...\n}\n```\n\n\nOn the surface the CancelToken-based implementation of `subscribe` appears to be more efficient than the Subscription-based implementation. Note that a single `CancelToken` may be used by many Observables. In the Subscription-based proposals, many functions which compose Observables generate a Subscription per call to `subscribe`. Under the circumstances it would appear as though the CancelToken-based proposal may require fewer allocations than the Subscription-based proposal.\n\n\nUnfortunately the implementation above will leak memory when some common Observable compositions are applied. In the following sections this memory leak will be explained, a change to the implementation will be proposed to avoid it, and finally a change to the CancelToken specification will be rationalized.\n\n### Modifying `CancelToken.prototype.race` to weakly retain references to all  input tokens\n\n\nThe implementation of `subscribe` in the previous section does not allow certain common composition operations to be written without introducing a memory leak. As an example, consider the `flatten` function which is commonly applied to Observables:\n\n```js\nimport _ from \"lodashforObservables\";\n\nlet mouseDowns = document.body.on(‘mousedown’);\nlet mouseUps = document.body.on(‘mouseup’);\nlet mouseMoves = document.body.on(‘mousemove’);\n\nlet mouseDrags =\n  _(mouseDowns).\n    map(() => _(mouseMoves).takeUntil(mouseUps)).\n    flatten();\n```\n\nThe code above creates an Observable that notifies all of the mouse moves that occur between a mouse down and mouse up event.\n\nThe `flatten` function accepts an input Observable of Observables, and returns a new Observable which notifies its Observer of the data in each of the Observables in the input Observable. Consider the following example:\n\n\n```js\nimport _ from \"lodashforObservables\";\n\nflatten(Observable.of(\n   Observable.of(1,2,3),\n   Observable.of(4,5,6))).\n   forEach(x => console.log(x));\n```\n\n\nWith the code above is run, the following console output is expected:\n\n```\n1\n2\n3\n4\n5\n6\n```\n\nThe `flatten` function allows an long-running asynchronous operation to be composed together from multiple smaller asynchronous operations. Consider the following code which looks for a stock that matches a particular criteria:\n\n```js\nimport _ from \"lodashforObservables\";\nasync function buyFirstMatchStock(stocks) {\n  var stockInfo = await _(stocks).\n      map(symbol =>\n        _.fromPromise(getStockInfoPromise(symbol)).\n      flatten().\n      filter(stockInfo => matchesLocalCritera(stockInfo)).\n      first();\n\n  let purchasePrice = await purchase(stockInfo);\n  return purchasePrice;\n}\n```\n\nNote that this async function may run for a long time, as well as spawn many smaller async operations as it retrieves the info for each stock from a remote service.\n\nNow consider the following implementation of `flatten`:\n\n```js\nfunction flatten(observable) {\n    return new Observable((observer, token) => {\n        let outerObservableDone = false;\n        let innerObservables = 0;\n\n        observable.subscribe({\n            next(innerObservable) {\n                innerObservables++;\n\n                innerObservable.subscribe(\n                    {\n                        next(value) {\n                            observer.next(value);\n                        },\n                        catch(e) {\n                            innerObservables--;\n                            observer.throw(e);\n                        },\n                        complete(v) {\n                            innerObservables--;\n                            if (innerObservables === 0 && outerObservableDone) {\n                                observer.complete(v);\n                            }\n                        }\n                    },\n                    token);\n            },\n            catch(e) {\n                observer.throw(e);\n            },\n            complete(v) {\n                outerObservableDone = true;\n                if (innerObservables === 0) {\n                    observer.complete(v);\n                }\n            }\n        },\n        token);\n    });\n}\n```\n\nThis implementation of flatten contains a memory leak. In the following sections, the root cause of the leak will be explained, and a solution will be proposed.\n\n#### Memory leaks and the inability to unsubscribe from cancellation notifications\n\nIn the previous section it was suggested that the implementation of flatten had a memory leak. However rather than focus on the definition of flatten, it will be demonstrated that the root cause of the leak is in the implementation of Observable.prototype.subscribe suggested earlier in this document.\n\n\nConsider the (truncated) definition of Observable.prototype.subscribe again:\n\n\n```js\nclass Observable {\n   subscribe(observer, token) {\n        // input validation snipped...\n        if (token == null) {\n            token = new CancelToken(() => {});\n        }\n        observer = new CancelTokenObserver(observer, token);\n        token.promise.then(cancel => observer.catch(cancel));\n        // call to subscribe implementation snipped...\n    }\n    // snip...\n}\n```\n\nNote that subscribe attaches a handler to the input token’s Promise in order to inform the Observer in case of token cancellation. Furthermore note that when the input token is passed to the subscribe implementation, the implementation may also attach cleanup logic to the token to be executed if the token is canceled. This enables subscribe implementations to free resources in the event the subscription is closed due to cancellation.\n\nThere is a problem with using this approach to ensure that resources are cleaned up when a subscription is closed. JavaScript’s proposed cancel tokens use a Promise to notify consumers of cancellation.\n\n```js\nvar source = CancelToken.source();\nvar token = source.token;\ntoken.promise.then(cancel => {\n    // cleanup logic\n});\n```\n\nNote that there is no way to detach a handler to a Promise in JavaScript except to resolve the Promise. That means that **once a cancellation handler has been attached to a cancel token, it cannot be detached until the token is canceled.** JS CancelTokens are notably different than .NET Cancellation Tokens in this respect, because .NET Cancellation Tokens allow handlers to be unsubscribed using an Observer-like interface.\n\n```cs\nCancellationTokenSource source = new CancellationTokenSource();\nCancellationToken token = source.Token;\n\n// register\nCancellationTokenRegistration registration = token.Register(() => {\n    // cleanup logic\n})\n\n// unregister\nregistration.Dispose();\n```\n\nThe inability to detach a cancellation handler from a cancel token is the root cause of the memory leak in flatten. When a subscription closes, the cleanup logic the implementation registered with the token cannot detached. As a result the current implementation leaks memory when operations like flatten are applied, which can create a long running async Observables out of many (potentially short-lived) Observables.  As the flattened Observable subscribes to inner Observables, cleanup logic may be attached to the token. However as each of these subscription closes, cleanup logic is not run, nor is the handler detached.\n\nThe implementation of `flatten` below is identical to the one included earlier in the document, but annotates the code with comments detailing the memory leak:\n\n```js\nfunction flatten(observable) {\n    return new Observable((observer, token) => {\n        let outerObservableDone = false;\n        let innerObservables = 0;\n\n        // Each Observable received from this stream will attach a\n        // handler to the token on subscription. This handler will remain\n        // attached until the token received by `subscribe` is cancelled -  \n        // even after the subscription to the Observable has closed.\n        observable.subscribe({\n            next(innerObservable) {\n                innerObservables++;\n\n                // handler attached to token.promise\n                innerObservable.subscribe(\n                    {\n                        next(value) {\n                            observer.next(value);\n                        },\n                        catch(e) {\n                            // handler not detached from promise,\n                            // even though innerObservable subscription\n                            // is closed\n                            innerObservables--;\n                            observer.throw(e);\n                        },\n                        complete(v) {\n                            // handler not detached from promise,\n                            // even though innerObservable subscription\n                            // is closed\n                            innerObservables--;\n                            if (innerObservables === 0 && outerObservableDone) {\n                                observer.complete(v);\n                            }\n                        }\n                    },\n                    token);\n            },\n            catch(e) {\n                observer.throw(e);\n            },\n            complete(v) {\n                outerObservableDone = true;\n                if (innerObservables === 0) {\n                    observer.complete(v);\n                }\n            }\n        },\n        token);\n    });\n}\n```\n\nThe `flatten` operator demonstrates that a long-running operation cannot share CancelToken’s among many Observables without leaking memory. In the next section we’ll modify the polyfill `subscribe` to allow each implementation to free its resources once the subscription closes.\n\n#### Enabling Observables to cleanup when a subscription is closed\n\nIn the previous section we demonstrated that sharing a single cancel token among multiple Observables can create memory leaks when long-running asynchronous operations are composed out of many smaller asynchronous operations. One solution to this problem is to create a new CancelToken for each call to subscribe.\n\nConsider the following (revised) polyfill of Observable.prototype.subscribe:\n\n```js\nexport class Observable {\n    subscribe(observer, outerToken) {\n        let token;\n        // argument validation omitted...\n\n        // Create new CancelToken for this Subscription operation and\n        // link it to the Observable.\n        const { token: innerToken, cancel } = CancelToken.source();\n        token = outerToken != null ? CancelToken.race([outerToken, innerToken]) : innerToken;\n\n        // The cancel fn is passed to the CancelTokenObserver so that it\n        // can cleanup subscription resources when it receives a\n        // else or complete notification\n        observer = new CancelTokenObserver(observer, token, cancel);\n        token.promise.then(c => observer.catch(c));\n\n        const reason = token.reason;\n        if (reason) {\n            return observer.catch(reason);\n        }\n\n        try {\n            this._subscriber(observer, token);\n        } catch(e) {\n            observer.throw(e);\n        }\n    }\n```\n\n\nNote that Observable’s subscribe method creates a new CancelTokenSource each time it is invoked. Then a raced token is created created from the source token and the input token, and the raced token is subsequently passed to the subscribe implementation. The net effect is that a cancel token is created specifically for each subscription.\n\nIn order to ensure that a subscribe implementation’s clean up logic is executed when the subscription is closed, the source’s cancel function is passed to the `CancelTokenObserver` along with the token. The CancelTokenObserver runs the cancel function whenever an `else` or `complete` notification is received. This causes cleanup logic to be run whenever a subscription is closed.\n\nNote this logic in the polyfill of `CancelTokenObserver.prototype.else` below:\n\n```js\n// Abstract operation\nfunction closeCancelTokenObserver(cancelTokenObserver) {\n    cancelTokenObserver._closed = true;\n    cancelTokenObserver._observer = undefined;\n    cancelTokenObserver._subscriptionCancel = new Cancel(\"Subscription canceled.\");\n    cancelTokenObserver._cancel(cancelTokenObserver._subscriptionCancel);\n}\n\nclass CancelTokenObserver {\n    constructor(observer, token, cancel) {\n        this._observer = observer;\n        this._token = token;\n        this._cancel = cancel;\n    }\n    // other methods snipped...\n    complete(value) {\n        // if token is cancelled, noop\n        if (isCancelTokenObserverTokenCancelled(this)) {\n            return;\n        }\n\n\n        let observer = this._observer;\n        // close subscription by cancelling token\n        closeCancelTokenObserver(this);\n\n\n        let m = getMethod(observer, \"complete\");\n\n\n        if (m) {\n            try {\n                m.call(observer, value);\n            }\n            catch(e) {\n                // HostReportErrors(e)\n            }\n        }\n    }\n}\n```\n\nNote the `complete` method cancels the token created specifically for this subscription, ensuring that resources are cleaned up when the subscription closes.\n\nCreating a new CancelToken per subscription allows subscriptions to cleanup their resources as soon as a subscription is closed. However this alone is not enough to eliminate all memory leaks.  Depending on the implementation of CancelToken.prototype.race, this implementation may simply trade one leak for another. In the next section this problem will be explained in more detail, and an implementation of CancelToken.prototype.race will be proposed which eliminates the memory leak.\n\n### Ensuring CancelTokens weakly reference input tokens\n\nRecall that in the previous section the polyfill of the `subscribe` implementation was modified to create a raced CancelToken from a new source token and the input token, and passed the raced token to the `subscribe` implementation:\n\n\nexport class Observable {\n    subscribe(observer, outerToken) {\n        let token;\n        // argument validation omitted...\n\n\n        // Create new CancelToken for this Subscription operation and\n        // link it to the Observable.\n        const { token: innerToken, cancel } = CancelToken.source();\n        token = outerToken != null ? CancelToken.race([outerToken, innerToken]) : innerToken;\n\n\n        // The cancel fn is passed to the CancelTokenObserver so that it\n        // can cleanup subscription resources when it receives a\n        // else or complete notification\n        observer = new CancelTokenObserver(observer, token, cancel);\n        token.promise.then(c => observer.catch(c));\n        // pass token to subscribe implementation\n    }\n}\n\n\nNote that in order to avoid memory leaks the subscribe implementation assumes that input tokens passed to CancelToken.prototype.race weakly reference the raced token. If not there is still a memory leak, because just as there is no way to detach a Promise handler, there is also no way to unlink a raced token from its input tokens.\n\n\nConsider the most obvious implementation of CancelToken.prototype.race:\n\n\n```js\nclass CancelToken {\n  // snip…\n  static race(cancelTokens) {\n    return new CancelToken(cancel => {\n      Promise.race(cancelTokens.map(token => token.promise)).then(cancel);\n    });\n  }\n}\n```\n\n\nNote that the implementation above will cause a reference to the raced canceltoken to be captured indirectly by all cancel tokens via the raced promise. If we assume that CancelToken uses the implementation of CancelToken.prototype.race above, then the memory leak has simply been moved rather than removed. In a long-running async operation like `flatten`, more and more tokens will be linked as each new Observables is subscribed. These references will be retained - even after the subscription has been closed.\n\n\nThe memory leak can be eliminated if the implementation of `CancelToken.prototype.race` is modified like so:\n\n\n```js\nclass CancelToken {\n  // snip…\n  static race(inputTokens) {\n    let tokenCancel;\n    let token = new CancelToken(cancel => tokenCancel = cancel);\n    for(let inputToken of inputTokens) {\n      addWeakRefToLinkedCancelFunction(inputToken, tokenCancel);\n    }\n    return token;\n  }\n}\n```\n\n\nWhen a token is cancelled, it iterates its list of weak references and forwards the `Cancel` instance to each cancel function found in the list.\n\n\n```js\nexport default class CancelToken {\n  constructor(fn) {\n    let promiseCancel;\n\n\n    this.promise = new Promise((accept, reject) => {\n      promiseCancel = accept;\n    });\n\n\n    let cancel = reason => {\n      this.reason = reason;\n      let weakRefs = getCancelTokenWeakRefs(this);\n      for(let weakRef of weakRefs) {\n        let linkedCancel = getWeakRefValue(weakRef);\n        if (linkedCancel) {\n          linkedCancel(reason);\n        }\n      }\n      clearCancelTokenWeakRefs(this);\n      promiseCancel(reason);\n    }\n\n\n    fn(cancel);\n  }\n\n\n  // more functions snipped...\n}\n```\n\nThis approach largely mitigates the memory leak by ensuring that raced tokens associated with completed Observable subscriptions can be collected by GC. However it's worth noting that another side effect of the implementation above is that cancellation propagates to linked tokens synchronously. This is fortuitous, because in addition to weakly referenced linked tokens, synchronous cancellation propagation is essential if the implementation of Observable on CancelTokens proposed in the document is to be viable. The next section will explain why sync cancellation propagation is necessary in order to implement Observables on CancelTokens.\n\n### Ensuring CancelTokens synchronously propagate cancellation\n\nIn the previous section we provided a naïve implementation of CancelToken.prototype.race which used promises to propagate cancellation.\n\n```js\nclass CancelToken {\n  // snip…\n  static race(cancelTokens) {\n    return new CancelToken(cancel => {\n      Promise.race(cancelTokens.map(token => token.promise)).then(cancel);\n    });\n  }\n}\n```\nOne implication of the use of Promises in the naive `race` implementation’s is that cancellation will be propagated to linked tokens _asynchronously_. Async cancellation propagation is not compatible with the CancelToken-based implementation of Observable proposed in this document. The problem is that if cancellation is _not_ propagated synchronously, notifications can be delivered to an Observer after a token has been cancelled.\n\nThe following code creates an Observable that can multi-cast messages to multiple observers:\n\n```js\nlet capturedObservers = new Set();\nlet subject = new Observable((observer, token) => {\n  capturedObservers.add(observer);\n  token.promise.then(() => capturedObservers.delete(observer));\n});\n\nlet { token, cancel } = CancelToken.source();\n\nsubject.subscribe({\n  next(msg) { console.log(msg); }\n}, token);\n\ncancel(new Cancel(\"Closing subscription\"));\n\nfor(let observer of capturedObservers) {\n  observer.next(\"message\");\n}\n```\n\nRecall that Observable enforces the invariant that **no notification is delivered to an Observer after a subscription has been closed.** In this regard Observables match the behavior of Iterators, which never produce new values after they have completed. Note in the example above that the token is cancelled prior to any Observer being notified. Under the circumstances we would expect no console output as a result of the Observers being notified. However if we ran the code above we would observe the following console output (assuming the naive implementation of CancelToken.prototype.race):\n\n```\nmessage\n```\n\nIn order to understand why the message is delivered to the Observer after the token passed to subscribe has been cancelled, consider the implementation of `subscribe` again:\n\n```js\nexport class Observable {\n    subscribe(observer, outerToken) {\n        let token;\n        // argument validation omitted...\n\n        // Create new CancelToken for this Subscription operation and\n        // link it to the Observable.\n        const { token: innerToken, cancel } = CancelToken.source();\n        token = outerToken != null ? CancelToken.race([outerToken, innerToken]) : innerToken;\n\n        // The cancel fn is passed to the CancelTokenObserver so that it\n        // can cleanup subscription resources when it receives a\n        // else or complete notification\n        observer = new CancelTokenObserver(observer, token, cancel);\n        token.promise.then(c => observer.catch(c));\n\n        const reason = token.reason;\n        if (reason) {\n            return observer.catch(reason);\n        }\n\n\n        try {\n            this._subscriber(observer, token);\n        } catch(e) {\n            observer.throw(e);\n        }\n    }\n}\n```\n\nNote that the input cancel token passed to subscribe is not passed directly to the subscribe implementation provided to the Observable constructor. Instead, a raced CancelToken is created from the input cancel token and a new cancel token created specifically for the subscription. Assuming async propagation of cancellation, the token received by the subscribe implementation will not receive the cancellation notification within the same job as cancellation was invoked. As a consequence the Observer receives all notifications dispatched in the same job in which the input token cancellation is executed.\n\nIf the alternate implementation of CancelToken.prototype.race described in the previous implementation is used instead, the raced token receives the cancellation in the same job as the in in which the input token cancellation is executed. As a consequence, no console output would be received as expected.\n\n## Observable can be implemented on CancelTokens\n\nAssuming the implementation of `CancelToken.prototype.race` proposed in this document, Observable can be implemented on CancelTokens with no loss of expressiveness. For a reference implementation, see [here](https://github.com/jhusain/proposal-observable/blob/master/src/Observable.js).\n"
        },
        {
          "name": "ObservableEventTarget.md",
          "type": "blob",
          "size": 20.9306640625,
          "content": "# Extending EventTarget with Observable\n\nCurrently the web has two primitives with which developers can build concurrent programs:\n\n1. EventTarget\n2. Promise\n\nUnfortunately the inability to compose these two primitives makes it is difficult to coordinate concurrency without the use of shared mutable state. This introduces incidental complexity into web applications, and increases the likelihood of race conditions.\n\nThis proposal aims to enable more composable approaches to concurrency coordination by adding a new interface to the DOM: `ObservableEventTarget`. `ObservableEventTarget` is an interface which extends `EventTarget` with an `on` method. When the `on` method is invoked with a event type argument, an Observable is created. Events of the same type which are subsequently dispatched to the `ObservableEventTarget` are also dispatched to any observers observing the Observable. `Observable`s shares a common subset of `EventTarget` and `Promise` semantics, allowing concurrent programs which use both primitives to be built compositionally. \n\n## ObservableEventTarget API\n\nThe `ObservableEventTarget` interface inherits from `EventTarget` and introduces a new method: `on`. The `on` method creates an`Observable` and forwards events dispatched to the `ObservableEventTarget` to the Observers of that Observable.\n\n```\ninterface Event { /* https://dom.spec.whatwg.org/#event */ }\n\ndictionary OnOptions {  \n  // listen for an \"error\" event on the EventTarget,\n  // and send it to each Observer's error method\n  boolean receiveError = false;\n\n  // member indicates that the callback will not cancel\n  // the event by invoking preventDefault().\n  boolean passive = false;,\n\n  // handler function which can optionally execute stateful\n  // actions on the event before the event is dispatched to\n  // Observers (ex. event.preventDefault()).\n  EventHandler handler = null;\n\n  // member indicates that the Observable will complete after\n  // one event is dispatched.\n  boolean once = false;\n}\n\ninterface ObservableEventTarget extends EventTarget {\n  Observable<Event> on(DOMString type, optional (OnOptions or boolean) options);\n}\n```\n\nAny implementation of `EventTarget` can also implement the `ObservableEventTarget` interface to enable instances to be adaptated to `Observable`s.\n\n## Design Considerations\n\nThe semantics of `EventTarget`'s and `Observable`'s subscription APIs overlap cleanly. Both share the following semantics...\n\n* the ability to synchronously subscribe and unsubscribe from notifications\n* the ability to synchronously dispatch notifications\n* errors thrown from notification handlers are reported to the host rather than being propagated\n\n`EventTarget`s have semantics which control the way events are propagated through the DOM. The `on` method accepts an `OnOptions` dictionary object which allow event propagation semantics to be specified when the ObservableEventTarget is adapted to an Observable. The `OnOptions` dictionary extends the DOM's `AddEventListenerOptions` dictionary object and adds two additional fields:\n\n1. `receiveError`\n2. `handler`\n\n### The  `OnOptions` `receiveError` member\n\nThe `receiveError` member specifies whether or not events with type `\"error\"` should be passed to the  `error` method on the Observable's Observers.\n\nIn the example below the  `on` method is used to create an `Observable` which dispatches an Image's \"load\" event to its observers. Setting the `\"once\"` member of the `OnOptions` dictionary to `true` results in a `complete`  notification being dispatched to the observers immediately afterwards. Once an Observer has been dispatched a `complete` notification, it is unsubscribed from the Observable and consequently the `ObservableEventTarget`.\n\n```js\nconst displayImage = document.querySelector(\"#displayImage\");\n\nconst image = new Image();\nconst load = image.on('load', { receiveError: true, once: true });\nimage.src = \"./possibleImage\";\n\nload.subscribe({\n  next(e) {\n    displayImage.src = e.target.src;\n  },\n  error(e) {\n    displayImage.src = \"errorloading.png\";\n  },\n  complete() {\n    // this notification will be received after next ()\n    // as a result of the once member being set to true\n  }\n})\n```\n\nNote that the `receiveError` member of the `OnOptions` object is set to true. Therefore if the Image receives an `\"error\"` Event, the Event is passed to the `error`  method of each of the `Observable`'s `Observer`s. This, too, results in unsubscription from all of the Image's underlying events.\n\n\n### The  `OnOptions` `handler` member\n\nThe `handler` callback function is invoked on the event object prior to the event being dispatched to the Observable's Observers. The handler gives developers the ability execute stateful operations on the Event object (ex. `preventDefault`, `stopPropagation`),  within the same tick on the event loop as the event is received.\n\nIn the example below, event composition is used build a drag method for a button to allow it to be absolutely positioned in an online WYSWYG editor. Note that the `handler` member of the `OnOptions` object is set to a function which prevents the host browser from initiating its default action. This ensures that the button does not appear pressed when it is being dragged around the design surface.\n\n```js\nimport \"_\" from \"lodash-for-observable\";\n\nconst button  = document.querySelector(\"#button\");\nconst surface = document.querySelector(\"#surface\");\n\n// invoke preventDefault() in handler to suppresses the browser default action\n// which is to depress the button.\nconst opts = { handler(e) { e.preventDefault(); } };\nconst mouseDowns = _(button.on( \"mousedown\", opts));\nconst mouseMoves = _(surface.on(\"mousemove\", opts));\nconst mouseUps   = _(surface.on(\"mouseup\",   opts));\n\nconst mouseDrags = mouseDowns.flatMap(() => mouseMoves.takeUntil(mouseUps));\n\nmouseDrags.subscribe({\n  next(e) {\n    button.style.top = e.offsetX;\n    button.style.left = e.offsetY;\n  }\n})\n```\n\n## Example Implementation\n\nThis is an example implementation of ObservableEventTarget. The `on` method delegates to\n`addEventListener`, and adds a handler for an `\"error\"` event if the `receiveError` member on the `OnOptions` object has a value of `true`.\n\n```js\nclass ObservableEventTarget extends EventTarget {\n  on(type, opts) {\n    return Observable(observer => {\n      if (typeof opts !== \"boolean\") {\n        opts = {};\n      }\n      else {\n        opts = {\n          capture: opts\n        };\n      }\n\n      const handler = (typeof opts.handler === \"function\") ? opts.handler : null;\n      const once = opts.once;\n\n      const eventHandler = e => {\n        try {\n          if (handler != null) {\n            handler(e);\n          }\n\n          observer.next(e);\n        }\n        finally {\n          if (once) {\n            observer.complete();\n          }\n        }\n      };\n\n      const errorHandler = observer.error.bind(observer);\n\n      this.addEventListener(type, eventHandler, opts);\n\n      if (opts.receiveError) {\n        this.addEventListener(\"error\", errorHandler)\n      }\n\n      // unsubscription logic executed when either the complete or\n      // error method is invoked on Observer, or the consumer\n      // unsubscribes.\n      return () => {\n        this.removeEventListener(type);\n\n        if (receiveError) {\n          this.removeEventListener(\"error\", errorHandler);\n        }\n      };\n    });\n  }\n}\n```\n\n## Problem: EventTargets and Promises are difficult to Compose\n\nWeb applications need to remain responsive to user input while performing long-running operations like network requests. Consequently web applications often subscribe to EventTargets and Promises concurrently. In some circumstances, an application may start additional concurrent operations when each new event of a particular type is received (ex. a web browser starting a new concurrent download for each file link clicked). However web applications often respond to events by **canceling or ignoring the output of one or more concurrently running tasks** (ex. canceling an outstanding request for a view's data when the user navigates elsewhere). \n\nUnfortunately this common concurrency coordination pattern, in which outstanding network requests are canceled when an event of a certain type is received, is challenging to implement compositionally using EventTargets and Promises. These challenges will be demonstrated using the use case of an image browser app created for a news aggregator.\n\n### Use Case: Browsing the Images in a News aggregator\n\nConsider the use case of a web app which allows users to browse through images posted on a news aggregator site.\n\n![Aggregator](http://tc39.github.io/proposal-observable/aggregator.png)\n\nA user can select from several image-oriented subs using a select box. Each time a new sub is selected, the app downloads the first 300 post summaries from that sub. Once the posts have been loaded, the user can navigate through the images associated with each post using a next and previous button. When the user navigates to a new post, the image is displayed as soon as it has been successfully preloaded. If the image load is not successful, or the post does have an associated image, a placeholder image is displayed. Whenever data is being loaded from the network, a transparent animated loading image is rendered over top of the image.\n\nThis app may appear simple, but implementations could suffer from any of the following race conditions:\n\n* In the event requests for a sub's posts complete out of order, images from old subs may be displayed after images from subs selected by the user more recently.\n* In the event image preloads complete out of order, old images may be displayed after images selected by the user more recently.\n* While a new sub is being loaded, the UI may continue responding to the navigation events for the current sub. Consequently images from the old sub may be displayed briefly before abruptly being replaced by those in the newly-loaded sub.\n\nNote that all of these race conditions have one thing in common: they can be avoided by unsubscribing from a pending network request or an event type when an event is received. In the following subsections, two solutions will be contrasted:\n\n1. Coordinating concurrency using shared mutable state\n2. Coordinating concurrency compositionally using EventTargetObservable and a library \n\n#### Solution: Coordinate Concurrency using Shared Mutable State\n\nConsider the following solution, which coordinates concurrent subscriptions to both EventTargets and Promises using shared mutable state.\n\n```js\nconst subSelect = document.querySelector('#subSelect');\nconst displayedImage = document.querySelector(\"#displayedImage\");\nconst titleLabel = document.querySelector(\"#titleLabel\");\nconst previousButton = document.querySelector(\"#previousButton\");\nconst nextButton = document.querySelector(\"#nextButton\");\n\n// shared mutable state used to track the currently displayed image\nlet index;\n\n// shared mutable state used to coordinate concurrency\nlet posts;\nlet currentOperationToken = {};\n\nfunction showProgress() {\n  progressImage.style.visibility = \"visible\";\n}\n\nfunction switchImage(direction) {\n  // guard against navigating while a new sub is being loaded\n  if (posts == null) {\n    return;\n  }\n  showProgress();\n\n  if (posts) {\n    index = circularIndex(index + direction, posts.length)\n  }\n\n  const summary = posts[index];\n\n  // capture current operation id in closure so it can be used to\n  // confirm operation is not outdated when Promise resolves\n  currentOperationToken = {};\n  let thisOperationToken = currentOperationToken;\n  \n  return preloadImage(summary.image).\n    then(\n      () => {\n        // noop if this is no longer the current operation\n        if (thisOperationToken === currentOperationToken) {\n          titleLabel.innerText = summary.title\n          displayedImage.src = detail.image || \"./noimagefound.gif\"\n        }\n      },\n      e => {\n        // noop if this is no longer the current operation\n        if (thisOperationToken === currentOperationToken) {\n          titleLabel.innerText = summary.title\n          displayedImage.src = \"./errorloadingpost.png\";\n        }\n      });\n}\n\nfunction subSelectHandler() {\n  showProgress();\n\n  let sub = subSelect.value;\n  // indicate a new set of posts is being loaded to guard\n  // against responding to navigation events in the interim\n  posts = null;\n\n  // capture current operation id in closure so it can be used to\n  // confirm operation is not outdated when Promise resolves\n  \n  currentOperationToken = {};\n  let thisOperationToken = currentOperationToken;\n  newsAggregator.\n      getSubPosts(sub).\n      then(\n        postsResponse => {\n          if (thisOperationToken === currentOperationToken) {\n            index = 0;\n            posts = postsResponse;\n            return switchImage(0);\n          }\n        },\n        e => {\n          // unsubscribe from events to avoid putting unnecessary\n          // load on news aggregator when the server is down.\n          nextButton.removeEventListener(\"click\", nextHandler);\n          previousButton.removeEventListener(\"click\", previousHandler);\n          subSelect.removeEventListener(\"change\", subSelectHandler);\n          alert(\"News Aggregator is not responding. Please try again later.\");\n        });\n});\n\nfunction nextHandler() {\n  switchImage(1)\n};\n\nfunction previousHandler() {\n  switchImage(-1);\n};\n\nsubSelect.addEventListener(\"change\", subSelectHandler);\nnextButton.addEventListener(\"click\", nextHandler);\npreviousButton.addEventListener(\"click\", previousHandler);\n\n// load current sub\nsubSelectHandler();\n```\n\nIn the example solution above race conditions are avoided by using shared mutable state to track the current operation, and explicit guards are used to avoid responding to outdated operations.\n\n```js\nif (posts == null) {\n  return;\n}\n\n// ...snip...\n\nif (thisOperationToken === currentOperationToken) {\n  // ...snip...\n}\n```\n\nFailure to explicitly include these guards can lead to race conditions which calls notifications to be processed out of order. Furthermore the inability to unsubscribe from Promises means that these guards must be explicitly inserted in both the resolve and reject callbacks.\n\nYet more shared mutable state is necessary because EventTarget and Promise do not compose. Note that in order to make the values resolved by `Promises` available to `EventTarget` handlers, it is necessary to write them to the shared mutable `posts` variable.\n\n#### Alternate Solution: ObservableEventTarget and a small combinator library\n\nCanceling or ignoring the output of a concurrent operation when a new event is received is one of the most common concurrency coordination patterns used in web applications. This common coordination pattern can be encapsulated in a single Observable method: `switchLatest`.\n\nThe `switchLatest` combinator transforms a multi-dimensional Observable into an Observable flattened by one dimension. As soon the outer Observable notifies an inner Observable, `switchLatest` unsubscribes from the currently-subscribed inner Observable and subscribes to the most recently notified inner Observable.\n\nThe behavior of the `switchLatest` function can be understood more easily through the use of a textual representation. Consider the following textual representation of an Observable:\n\n```<|,,,1,,,,,5,,,,,,,9,,,,|>```\n\nIn the representation above each ```<|``` is the point at which the Observable is subscribed, and each ```|>``` indicates a `complete` notification. Furthermore each `,` represents 10 milliseconds and each number represents a `next` notification to the Observer. \n\nA program in which a network request is sent for each event in an event stream can be modeled as a two-dimensional Observable...\n\n```\n<|\n,,,,,<|,,,,,,,,,,,,,,,,,,,,,,88,,,,|>\n,,,,,,,,,<|,,,,,33,,,,,,,,,,,,,|>\n,,,,,,,,,,,,,,,,,,,,,<|,,,,,,,,,9|>\n,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,|>\n```\n\nIf the `switchLatest` function is applied to flatten the two-dimensional Observable above, the following result is produced.\n\n`<|,,,,,,,,,,,,,,,,33,,,,,,,,,,,9,,,,,,,|>`\n\nNote that none of the data in the first inner `Observable` makes it into the flattened stream, because the first inner `Observable` does not notify prior to the notification of a new inner `Observable`. Consequently the `switchLatest` combinator unsubscribes from the previous inner `Observable` before that `Observable` has the opportunity to notify. The second inner `Observable` only has the opportunity to notify `8` prior to the arrival of a new inner `Observable`, which notifies `9` and completes. Shortly thereafter the outer `Observable` completes, thereby completing the flattened Observable.\n\nHere's an example of `switchLatest` being used to build an auto-complete box:\n\n```js\nimport _ from \"lodash-for-observable\";\nconst textbox = document.querySelector(\"#textbox\");\nlet keyups = _.on(textbox, \"keyup\");\n\nkeyups.\n  // disregard outstanding request and switch to\n  // new one created by projection function.\n  map(() =>\n    // userland \"lodash-for-observable\" library\n    // automatically adapts Promises into Observables\n    getSearchResultSet(textbox.value)).\n  switchLatest().\n  subscribe({\n    next(resultSet) {\n      display(resultSet);\n    },\n    error(error) {\n      alert(error);\n    }\n  });\n```\n\nNote that using `switchLatest` guarantees that search results for a particular search not come back out-of-order by switching to the the result of the latest Promise each time a key is pressed.\n\nIn the example above the `switchLatest` operation is applied to the result of a `map` operation. The `switchMap` method is a shorthand for this common pattern. Here is the example above rewritten to use `switchMap`.\n\n```js\nimport _ from \"lodash-for-observable\";\nconst textbox = document.querySelector(\"#textbox\");\nlet keyups = _.on(textbox, \"keyup\");\n\nkeyups.\n  // disregard outstanding request and switch to\n  // new one created by projection function.\n  switchMap(() =>\n    // userland \"lodash-for-observable\" library\n    // automatically adapts Promises into Observables\n    getSearchResultSet(textbox.value)).\n  subscribe({\n    next(resultSet) {\n      display(resultSet);\n    },\n    error(error) {\n      alert(error);\n    }\n  });\n```\n\nHere's an algorithm for the Image Viewer app which uses `switchMap` to avoid race conditions without relying on shared mutable state.\n\n```js\nimport newsAggregator from \"news-aggregator\";\nimport _ from \"lodash-for-observable\";\n\nconst previousClicks = _(previousButton.on(\"click\"));\nconst nextClicks = _(nextButton.on(\"click\"));\n\nconst getNavigatedItems = (array) =>\n  _.merge(\n    Observable.of(0),\n    backClicks.map(() => -1),\n    forwardClicks.map(() => 1)).\n    // <|0,,,,,,,,,,1,,,,,,,,,1,,,,,,,-1,,,,,,,,-1,,,,,,,,\n    scan(\n      (index, direction) =>\n        circularIndex(index + direction, length)).\n    // <|0,,,,,,,,,,1,,,,,,,,,2,,,,,,,,1,,,,,,,,0,,,,,,,,,\n    map(index => array[index]);\n    // <|item,,,,,,,item,,,,,,item,,,,,,item,,,,item,,,,,,\n\nconst subSelect = document.querySelector('#subSelect');\n// ,,,,,,\"pics\",,,,,,\"humour\",,,,,,,,,,,,\"cute\",,,,,,,\nconst subs = _(subSelect.on(\"change\")).map(e => e.target.value);\n\n_.\n  merge(backClicks, forwardClicks, subs).\n  subscribe(() => progressImage.style.visibility = \"visible\");\n\nconst postsWithImages =\n  subs.\n    // ,,,,,\"pics\",,,,\"humour\",,,,,,,,,,\"cute\",,,,,,,,\n    switchMap(sub => // ignore outstanding sub requests, nav events, and image loads and switch to new sub\n      newsAggregator.getSubPosts(sub, 300).\n        //,,,[ {title:\"My Cat\", image:\"http://\"}, {title:\"Meme\",image:\"http://\"}, ...],,,,,[...],,,,\n        switchMap(posts => getNavigatedItems(posts)).\n        //,,,{title:\"My Cat\",image:\"http://\"},,,,,,,,{title:\"Meme\",image:\"http://\"},,,,,,,,,,,,,       \n        switchMap(post => { // ignore outstanding image loads, switch to new post\n          const image = new Image();\n          image.src = post.image;\n          return _.(image.on('load', { receiveError: true, once: true })).\n            map(() => post).\n            catch(error => Observable.of({...post, image: \"./errorloadingpost.png\"}));\n        }));\n        //,,,,,,,,,,,,{title: \"My Cat\",image: \"http://...\"\"},,,,,,,{title:\"Meme\",image:\"http://\"},,,,,,,,,\n\nconst displayedImage = document.querySelector(\"#displayedImage\");\nconst titleLabel = document.querySelector(\"#titleLabel\");\nconst progressImage = document.querySelector(\"#progressImage\");\n\npostDetails.subscribe({\n  next({title, image}) {\n    progressImage.style.visibility = \"hidden\";\n    titleLabel.innerHTML = title;\n    displayedImage.src = image;\n  }\n  error(e) {\n    alert(\"News Aggregator is not responding. Please try again later.\");\n  }\n});\n```\n\nNote that the resulting code is shorter than the correct previous solution. More importantly the code contains does not utilize any shared mutable state for concurrency coordination.\n\n## More Compositional Web Applications with ObservableEventTarget\n\nThe web platform has much to gain by including a primitive which can allow EventTargets and Promises to be composed. This proposal, along with the Observable proposal currently being considered by the TC-39, are incremental steps towards a more compositional approach to concurrency coordination. If the Observable proposal is accepted, the Observable prototype will have the opportunity to be enriched with useful combinators over time, eliminating the need for a combinator library in common cases.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.6640625,
          "content": "## ECMAScript Observable ##\n\nThis proposal introduces an **Observable** type to the ECMAScript standard library.\nThe **Observable** type can be used to model push-based data sources such as DOM\nevents, timer intervals, and sockets.  In addition, observables are:\n\n- *Compositional*: Observables can be composed with higher-order combinators.\n- *Lazy*: Observables do not start emitting data until an **observer** has subscribed.\n\n### Example: Observing Keyboard Events ###\n\nUsing the **Observable** constructor, we can create a function which returns an\nobservable stream of events for an arbitrary DOM element and event type.\n\n```js\nfunction listen(element, eventName) {\n    return new Observable(observer => {\n        // Create an event handler which sends data to the sink\n        let handler = event => observer.next(event);\n\n        // Attach the event handler\n        element.addEventListener(eventName, handler, true);\n\n        // Return a cleanup function which will cancel the event stream\n        return () => {\n            // Detach the event handler from the element\n            element.removeEventListener(eventName, handler, true);\n        };\n    });\n}\n```\n\nWe can then use standard combinators to filter and map the events in the stream,\njust like we would with an array.\n\n```js\n// Return an observable of special key down commands\nfunction commandKeys(element) {\n    let keyCommands = { \"38\": \"up\", \"40\": \"down\" };\n\n    return listen(element, \"keydown\")\n        .filter(event => event.keyCode in keyCommands)\n        .map(event => keyCommands[event.keyCode])\n}\n```\n\n*Note: The \"filter\" and \"map\" methods are not included in this proposal.  They may\nbe added in a future version of this specification.*\n\nWhen we want to consume the event stream, we subscribe with an **observer**.\n\n```js\nlet subscription = commandKeys(inputElement).subscribe({\n    next(val) { console.log(\"Received key command: \" + val) },\n    error(err) { console.log(\"Received an error: \" + err) },\n    complete() { console.log(\"Stream complete\") },\n});\n```\n\nThe object returned by **subscribe** will allow us to cancel the subscription at any time.\nUpon cancelation, the Observable's cleanup function will be executed.\n\n```js\n// After calling this function, no more events will be sent\nsubscription.unsubscribe();\n```\n\n### Motivation ###\n\nThe Observable type represents one of the fundamental protocols for processing asynchronous\nstreams of data.  It is particularly effective at modeling streams of data which originate\nfrom the environment and are pushed into the application, such as user interface events. By\noffering Observable as a component of the ECMAScript standard library, we allow platforms\nand applications to share a common push-based stream protocol.\n\n### Implementations ###\n\n- [RxJS 5](https://github.com/ReactiveX/RxJS)\n- [core-js](https://github.com/zloirock/core-js#observable)\n- [zen-observable](https://github.com/zenparsing/zen-observable)\n- [fate-observable](https://github.com/shanewholloway/node-fate-observable)\n\n### Running Tests ###\n\nTo run the unit tests, install the **es-observable-tests** package into your project.\n\n```\nnpm install es-observable-tests\n```\n\nThen call the exported `runTests` function with the constructor you want to test.\n\n```js\nrequire(\"es-observable-tests\").runTests(MyObservable);\n```\n\n### API ###\n\n#### Observable ####\n\nAn Observable represents a sequence of values which may be observed.\n\n```js\ninterface Observable {\n\n    constructor(subscriber : SubscriberFunction);\n\n    // Subscribes to the sequence with an observer\n    subscribe(observer : Observer) : Subscription;\n\n    // Subscribes to the sequence with callbacks\n    subscribe(onNext : Function,\n              onError? : Function,\n              onComplete? : Function) : Subscription;\n\n    // Returns itself\n    [Symbol.observable]() : Observable;\n\n    // Converts items to an Observable\n    static of(...items) : Observable;\n\n    // Converts an observable or iterable to an Observable\n    static from(observable) : Observable;\n\n}\n\ninterface Subscription {\n\n    // Cancels the subscription\n    unsubscribe() : void;\n\n    // A boolean value indicating whether the subscription is closed\n    get closed() : Boolean;\n}\n\nfunction SubscriberFunction(observer: SubscriptionObserver) : (void => void)|Subscription;\n```\n\n#### Observable.of ####\n\n`Observable.of` creates an Observable of the values provided as arguments.  The values\nare delivered synchronously when `subscribe` is called.\n\n```js\nObservable.of(\"red\", \"green\", \"blue\").subscribe({\n    next(color) {\n        console.log(color);\n    }\n});\n\n/*\n > \"red\"\n > \"green\"\n > \"blue\"\n*/\n```\n\n#### Observable.from ####\n\n`Observable.from` converts its argument to an Observable.\n\n- If the argument has a `Symbol.observable` method, then it returns the result of\n  invoking that method.  If the resulting object is not an instance of Observable,\n  then it is wrapped in an Observable which will delegate subscription.\n- Otherwise, the argument is assumed to be an iterable and the iteration values are\n  delivered synchronously when `subscribe` is called.\n\nConverting from an object which supports `Symbol.observable` to an Observable:\n\n```js\nObservable.from({\n    [Symbol.observable]() {\n        return new Observable(observer => {\n            setTimeout(() => {\n                observer.next(\"hello\");\n                observer.next(\"world\");\n                observer.complete();\n            }, 2000);\n        });\n    }\n}).subscribe({\n    next(value) {\n        console.log(value);\n    }\n});\n\n/*\n > \"hello\"\n > \"world\"\n*/\n\nlet observable = new Observable(observer => {});\nObservable.from(observable) === observable; // true\n\n```\n\nConverting from an iterable to an Observable:\n\n```js\nObservable.from([\"mercury\", \"venus\", \"earth\"]).subscribe({\n    next(value) {\n        console.log(value);\n    }\n});\n\n/*\n > \"mercury\"\n > \"venus\"\n > \"earth\"\n*/\n```\n\n#### Observer ####\n\nAn Observer is used to receive data from an Observable, and is supplied as an\nargument to **subscribe**.\n\nAll methods are optional.\n\n```js\ninterface Observer {\n\n    // Receives the subscription object when `subscribe` is called\n    start(subscription : Subscription);\n\n    // Receives the next value in the sequence\n    next(value);\n\n    // Receives the sequence error\n    error(errorValue);\n\n    // Receives a completion notification\n    complete();\n}\n```\n\n#### SubscriptionObserver ####\n\nA SubscriptionObserver is a normalized Observer which wraps the observer object supplied to\n**subscribe**.\n\n```js\ninterface SubscriptionObserver {\n\n    // Sends the next value in the sequence\n    next(value);\n\n    // Sends the sequence error\n    error(errorValue);\n\n    // Sends the completion notification\n    complete();\n\n    // A boolean value indicating whether the subscription is closed\n    get closed() : Boolean;\n}\n```\n"
        },
        {
          "name": "Why error and complete.md",
          "type": "blob",
          "size": 10.669921875,
          "content": "Why are error and completion notifications useful in Event Streams?\n======\n\nObservables have a well-defined way of notifying that a stream of data has ended, either due to error or completion. These notifications are sent by either resolving or rejecting the Promise returned from `forEach`:\n\n```js\nlet promise = someObservable.forEach(value => process(value));\npromise.then(\n  result => console.log(“Final value:”, result),\n  error => console.error(“Oh no!:”, error));\n```\n\nThis contrasts with both EventTarget (ET) and EventEmitter (EE), neither of which has a well-defined way of notifying that the stream has ended due to completion or error. It's reasonable to question the value of these notifications given that they are not present in either EE or ET, arguably the two most common push stream APIs used in JavaScript. \n\nThis document attempts to justify the value of completion and error notifications by demonstrating that they enable useful composition operations. These composition operations in turn allow for a wider range of async programming patterns to be expressed within asynchronous functions. This improves developer ergonomics because using async functions offer developers a host of benefits including...\n\n* Avoiding memory leaks caused by failure to release callbacks\n* Automatically propagating errors\n* The ability to use JavaScript control flow primitives (for/while/try)\n\nEnabling Event Stream Composition with Completion notifications\n------\n\nOn the web it is common to build workflows in which events in an event stream are processed until an event is received from another event stream. Here are some examples:\n\n* Listening for events from a DOM element until another event occurs which causes the element to be unmounted\n* Drawing a signature on a canvas by listening to a mouse move until a mouse up move is received\n* Dragging elements in a user-interface across the screen\n* Recognizing complex touch gestures\n\nListening to an event stream until an event is received from another event stream can be cumbersome using either EE or ET. Neither API returns Promises, which makes it difficult to coordinate their events in async functions. As a consequence developers must often fallback to using callbacks and state machines.\n\nHere’s an example that draws a signature on a canvas until a cancel button is pressed:\n\n```js\nfunction drawSignature(canvas, cancelButton, okButton) {\n  const context = signatureCanvas.getContext('2d');\n  const toPoint = e => ({ x: e.offsetX, y: e.offsetY });\n  let onMouseDown, onMouseMove, onMouseUp, onCancelClick;\n  \n  onMouseUp = () => {\n    canvas.removeEventListener('mousemove', onMouseMove);\n    canvas.removeEventListener('mouseup', onMouseUp);\n  };\n  \n  onMouseDown = e => {\n    let lastPoint = toPoint(e);\n    \n    onMouseMove = e => {\n      let point = toPoint(e);\n      strokeLine(context, lastPoint.x, lastPoint.y, point.x, point.y);\n      lastPoint = point;\n      okButton.disabled = false;\n    };\n\n    canvas.addEventListener('mousemove', onMouseMove);\n    canvas.addEventListener('mouseup', onMouseUp);\n  };\n  \n  onCancelClick = e => {\n    onmouseup();\n    canvas.removeEventListener('mousedown', onMouseDown);\n    cancelButton.removeEventListener('click', onCancelClick);\n  };\n\n  canvas.addEventListener('mousedown', onMouseDown);\n  cancelButton.addEventListener('click', onCancelClick);\n}\n```\n\nIn addition to the nonlinear nature of the code above, note how easy it is to accidentally omit event unsubscription. Neglecting to unsubscribe from events can cause memory leaks which are difficult to track down and gradually degrade application performance. These leaks are more severe in single-page web applications, because long-running pages are more likely to run out of memory.\n\n### Declarative concurrency in async functions using takeUntil\n\nIt’s interesting to note **while most ETs and EEs are infinite, it is possible to build a single *finite* event streams from two or more infinite event streams.** By adding an explicit completion event to Observable we are able to create a very useful composition operation: `takeUntil`. \n\nThe `takeUntil` method operation accepts a “source” Observable, and a \"stop\" Observable, and concurrently listens to both. The result is a composed Observable that forwards all of the events received from the \"source\" stream until a notification is received from the \"stop\" stream. Once a notification is received from the \"stop\" stream, the composed Observable notifies completion to its Observer, and unsubscribes from both the “source” and “stop” streams.\n\nHere’s the signature code collection above rewritten using Observable and takeUntil:\n\n```js\nimport { _ } from 'lodash-for-events';\n\nasync function drawSignature(signatureCanvas, okButton, token) {\n  await.cancelToken = cancelToken;\n  const context = signatureCanvas.getContext('2d');\n  const toPoint = e => ({ x: e.offsetX, y: e.offsetY });\n  const sigMouseDowns =\n    _(signatureCanvas.on('mousedown')).map(toPoint);\n  const sigMouseMoves =\n    _(signatureCanvas.on('mousemove')).map(toPoint);\n  const sigMouseUps   = \n    _(signatureCanvas.on('mouseup')).map(toPoint);\n\n  while(true) {\n    let lastPoint = await sigMouseDowns.first(token);\n\n    await sigMouseMoves.takeUntil(sigMouseUps).\n      forEach(\n        point => {\n          strokeLine(context, lastPoint.x, lastPoint.y, point.x, point.y);\n          okButton.disabled = false;\n          lastPoint = point;\n        },\n        token);\n  }\n}\n```\n \nIn the example above the takeUntil operation concurrently listens to both event streams internally, and exposes a single (possibly) finite event stream which can be consumed within an async function. The `takeUntil` function also removes the need for developers to explicitly unsubscribe from events, because unsubscription is automatically executed when the stream terminates.\n\nEnabling Observable and Promise composition with Error notifications\n-------\n\nIn the previous section it was demonstrated that adding a completion notification to Observable allows multiple infinite event streams to be composed into a (possibly) finite event stream. This allows the common concurrency pattern of processing an event until another event occurs to be expressed within an async function.\n\nThis section will demonstrate that adding an error notification to Observables enables them to be composed together with Promises to create new event streams. In order to compose Promises and Observables, we must adapt Promises into Observables. In order to ensure that errors from Promise rejections are not swallowed, we must add a corresponding error notification to Observables. If we add an error notification to Observable, Observable’s functions can automatically propagate unhandled errors, just as Promise functions do (ex. `then`). The result is that when new event streams are produced by composing Promises and Observables, errors arising from Promises rejections can be caught using try/else within an async function.\n\nThere are many use cases for combining Observables and Promises on the web. One such use case is an auto-complete box which displays searches as the user types. A well-written autocomplete box has the following features:\n\n* debounces keypresses to avoid flooding the server with requests\n* ensures that responses are not handled out of order (ie. displaying results for “a” on top of “ab”)\n* retries individual requests for a certain number of times, but give up if an individual request fails more than 3 times and tell the user to come back later. This reduces traffic in the event the server is down, and gives it a chance to recover.\n\nIn the example below we combine an Observable of keypress events with async requests to create a new stream of search results which are never returned out of order.\n\n```js\nimport { _ } from 'lodash-for-events';\n\nasync function displaySearchResults(input, searchResultsDiv, token) {\n  try {\n    await _(input.on('keyup')).\n      debounce(20).\n      map(e => input.value).\n      switchMap(query =>\n        _.fromPromiseFactory(subToken => search(query, subToken))).\n      forEach(\n        results => {\n          searchResultsDiv.innerHTML = \n            \"<ul>\" +\n              results.\n                map(result => `<li>${result}</li>`).\n                reduce((html, li) => html + li) +\n            \"</ul>\";\n        },\n        token);\n  }\n  else {\n    searchResults.innerHTML = \"The server is down right now. Come back later and try again.\";\n  }\n}\n```\n\nLet’s go over the functions used above one by one:\n\n* debounce. This function debounces an Observable stream given a timespan in milliseconds.\n* search. This function returns a Promise which will eventually return the search results for a given query. The function will retry 3 times to compensate for intermittent server failures, then reject if another error is encountered.\n* switchMap. This function ensures that results are never returned out of order. The function is called *switchMap* because it *maps* each item in the stream into a new asynchronous operation, creating a nested stream of async operations (in this case an `Observable<Observable<Array<String>>>`). Then it flattens the nested stream of async operations into a flat stream of their results by *switching* to the latest async operation whenever it arrives, and unsubscribing from any outstanding async operations if they exist (in this case producing an `Observable<Array<String>>`).\n* fromPromiseFactory. This function accepts a factory function which accepts a cancel token and returns a Promise. The result is an Observable which creates a new instance of the Promise for each subscription, and cancels the underlying async operation when the subscription ends.\n\nThe Promise returned by `search` rejects after a certain number of retries. If the Promise eventually rejects, `fromPromiseFactory` propagates the error through via the Observable’s error notification. Having a well-defined semantic for sending errors ensures each subsequent function (ex. `switchMap`, `forEach`) can automatically forward the error, just as Promise functions automatically forward rejection errors. As a result, the developer can use the familiar try/catch mechanism to handle errors that arise from a Promise which has been composed together with an event stream.\n\nObservable's error and completion notifications improve the expressiveness of async functions\n------\n\nWhile an individual EE’s or ET’s are typically infinite streams, the examples above demonstrate that adding both completion and error notifications to Observable enables new types of composition operations. These composition operations enable both event streams and Promises to be combined together declaratively. The benefit of this approach is that more async programming patterns can be expressed using simple JavaScript control flow primitives within async functions.\n"
        },
        {
          "name": "build-tests.js",
          "type": "blob",
          "size": 0.423828125,
          "content": "var ChildProcess = require(\"child_process\");\n\nfunction compile(args) {\n\n    return new Promise(function(resolve) {\n\n        var child = ChildProcess.spawn(\n            \"esdown\",\n            (\"- \" + args).split(/ /g),\n            { stdio: \"inherit\", env: process.env, cwd: __dirname });\n\n        child.on(\"close\", resolve);\n    });\n}\n\ncompile(\"./test/default.js ./es-observable-tests/es-observable-tests.js -b -r -g ObservableTests\");\n"
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "dom-event-dispatch.md",
          "type": "blob",
          "size": 3.2900390625,
          "content": "## Implementing EventTarget with Observable ##\n\n### Changes to Event Dispatch ###\n\nWe modify the \"invoke event listener\" algorithm so that each event listener holds a\nreference to an **observer**.  The observer's **next** method is invoked with the\ncurrent event.\n\n#### Invoking Event Listeners ####\n\nTo invoke the event listeners for an object with an event run these steps:\n\n1. Let *event* be the event for which the event listeners are invoked.\n1. Let *observers* be a copy of the event listeners associated with the object for which\n   these steps are run.\n1. Initialize *event*'s currentTarget attribute to the object for which these steps are\n   run.\n1. Then run these substeps for each event *listener* in *listeners*:\n    1. If *event*'s stop immediate propagation flag is set, terminate the **invoke**\n       algorithm.\n    1. Let *listener* be the event listener.\n    1. If *event*'s type attribute value is not *listener*'s type, terminate these substeps\n       (and run them for the next event listener).\n    1. If *event*'s eventPhase attribute value is **CAPTURING_PHASE** and listener's\n       capture is **false**, terminate these substeps (and run them for the next event\n       listener).\n    1. If *event*'s eventPhase attribute value is **BUBBLING_PHASE** and listener's\n       capture is **true**, terminate these substeps (and run them for the next event\n       listener).\n    1. Let *observer* be the *listener*'s observer.\n    1. Invoke the `next` method of *observer*, with the event passed to this algorithm\n       as the first argument.  If this throws any exception, report the exception.\n\n### EventTarget Implementation in JavaScript ###\n\n```js\nfunction findHandler(list, type, handler, capture) {\n    return list.findIndex(x =>\n        x.type === type &&\n        x.handler === handler &&\n        x.capture === capture);\n}\n\nclass EventTarget {\n\n    @listeners = [];\n    @handlers = [];\n\n    on(type, capture = false) {\n\n        return new Observable(observer => {\n\n            // On subscription, add a listener\n            this.@listeners.push({ observer, type, capture });\n\n            // On unsubscription, remove the listener\n            return _=> {\n\n                let index = this.@listeners.findIndex(\n                    listener => listener.observer === observer);\n\n                if (index >= 0)\n                    this.@listeners.splice(index, 1);\n            };\n        });\n    }\n\n    addEventListener(type, handler, capture = false) {\n\n        let index = findHandler(this.@handlers, type, handler, capture);\n\n        // Dedupe:  exit if listener is already registered\n        if (index >= 0)\n            return;\n\n        // Subscribe to the event stream\n        let subscription = this.on(type, capture).subscribe({\n            next(event) { handler.call(event.currentTarget, event) }\n        });\n\n        // Store the handler and subscription\n        this.@handlers.push({ type, handler, capture, subscription });\n    }\n\n    removeEventListener(type, handler, capture = false) {\n\n        let index = findHandler(this.@handlers, type, handler, capture);\n\n        // Exit if listener is not registered\n        if (index < 0)\n            return;\n\n        // Call the cancellation function and remove the handler\n        this.@handlers[index].subscription.unsubscribe();\n        this.@handlers.splice(index, 1);\n    }\n\n}\n```\n"
        },
        {
          "name": "es-observable-tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.419921875,
          "content": "{\n  \"name\": \"es-observable\",\n  \"private\": true,\n  \"scripts\": {\n    \"test\": \"babel-node run-tests.js\",\n    \"prepare\": \"babel -d commonjs/src/ src/ && babel -d commonjs/test/ test/ && babel -d commonjs/ run-tests.js\"\n  },\n  \"main\": \"commonjs/src/Observable.js\",\n  \"version\": \"0.3.0\",\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.26.0\",\n    \"babel-plugin-transform-es2015-modules-commonjs\": \"^6.26.0\",\n    \"moon-unit\": \"^0.2.2\"\n  }\n}\n"
        },
        {
          "name": "run-tests.js",
          "type": "blob",
          "size": 0.1162109375,
          "content": "import { Observable } from \"./src/Observable.js\";\nimport { runTests } from \"./test/default.js\";\n\nrunTests(Observable);\n"
        },
        {
          "name": "spec",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}