{
  "metadata": {
    "timestamp": 1736561608483,
    "page": 158,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mholt/json-to-go",
      "stars": 4532,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Matt Holt\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.1005859375,
          "content": "[<img src=\"https://mholt.github.io/json-to-go/resources/images/json-to-go.png\" alt=\"JSON-to-Go converts JSON to a Go struct\"></a>](https://mholt.github.io/json-to-go)\n\nTranslates JSON into a Go type definition. [Check it out!](http://mholt.github.io/json-to-go)\n\nThis is a sister tool to [curl-to-Go](https://mholt.github.io/curl-to-go), which converts curl commands to Go code.\n\nThings to note:\n\n- The script sometimes has to make some assumptions, so give the output a once-over.\n- In an array of objects, it is assumed that the first object is representative of the rest of them.\n- The output is indented, but not formatted. Use `go fmt`!\n\nContributions are welcome! Open a pull request to fix a bug, or open an issue to discuss a new feature or change.\n\n### Usage\n\n- Read JSON file:\n\n  ```sh\n  node json-to-go.js sample.json\n  ```\n\n- Read JSON file from stdin:\n\n  ```sh\n  node json-to-go.js < sample.json\n  cat sample.json | node json-to-go.js\n  ```\n\n### Credits\n\nJSON-to-Go is brought to you by Matt Holt ([mholt6](https://twitter.com/mholt6)).\n\nThe Go Gopher is originally by Renee French. This artwork is an adaptation.\n"
        },
        {
          "name": "json-to-go.js",
          "type": "blob",
          "size": 14.857421875,
          "content": "/*\n\tJSON-to-Go\n\tby Matt Holt\n\n\thttps://github.com/mholt/json-to-go\n\n\tA simple utility to translate JSON into a Go type definition.\n*/\n\nfunction jsonToGo(json, typename, flatten = true, example = false, allOmitempty = false)\n{\n\tlet data;\n\tlet scope;\n\tlet go = \"\";\n\tlet tabs = 0;\n\n\tconst seen = {};\n\tconst stack = [];\n\tlet accumulator = \"\";\n\tlet innerTabs = 0;\n\tlet parent = \"\";\n\tlet globallySeenTypeNames = [];\n\tlet previousParents = \"\";\n\n\ttry\n\t{\n\t\tdata = JSON.parse(json.replace(/(:\\s*\\[?\\s*-?\\d*)\\.0/g, \"$1.1\")); // hack that forces floats to stay as floats\n\t\tscope = data;\n\t}\n\tcatch (e)\n\t{\n\t\treturn {\n\t\t\tgo: \"\",\n\t\t\terror: e.message\n\t\t};\n\t}\n\n\ttypename = format(typename || \"AutoGenerated\");\n\tappend(`type ${typename} `);\n\n\tparseScope(scope);\n\n\tif (flatten)\n\t\tgo += accumulator\n\n\t// add final newline for POSIX 3.206\n\tif (!go.endsWith(`\\n`))\n\t\tgo += `\\n`\n\n\treturn {\n\t\tgo: go\n\t};\n\n\n\tfunction parseScope(scope, depth = 0)\n\t{\n\t\tif (typeof scope === \"object\" && scope !== null)\n\t\t{\n\t\t\tif (Array.isArray(scope))\n\t\t\t{\n\t\t\t\tlet sliceType;\n\t\t\t\tconst scopeLength = scope.length;\n\n\t\t\t\tfor (let i = 0; i < scopeLength; i++)\n\t\t\t\t{\n\t\t\t\t\tconst thisType = goType(scope[i]);\n\t\t\t\t\tif (!sliceType)\n\t\t\t\t\t\tsliceType = thisType;\n\t\t\t\t\telse if (sliceType != thisType)\n\t\t\t\t\t{\n\t\t\t\t\t\tsliceType = mostSpecificPossibleGoType(thisType, sliceType);\n\t\t\t\t\t\tif (sliceType == \"any\")\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst slice = flatten && [\"struct\", \"slice\"].includes(sliceType)\n\t\t\t\t\t? `[]${parent}`\n\t\t\t\t\t: `[]`;\n\n\t\t\t\tif (flatten && depth >= 2)\n\t\t\t\t\tappender(slice);\n\t\t\t\telse\n\t\t\t\t\tappend(slice)\n\t\t\t\tif (sliceType == \"struct\") {\n\t\t\t\t\tconst allFields = {};\n\n\t\t\t\t\t// for each field counts how many times appears\n\t\t\t\t\tfor (let i = 0; i < scopeLength; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst keys = Object.keys(scope[i])\n\t\t\t\t\t\tfor (let k in keys)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet keyname = keys[k];\n\t\t\t\t\t\t\tif (!(keyname in allFields)) {\n\t\t\t\t\t\t\t\tallFields[keyname] = {\n\t\t\t\t\t\t\t\t\tvalue: scope[i][keyname],\n\t\t\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tconst existingValue = allFields[keyname].value;\n\t\t\t\t\t\t\t\tconst currentValue = scope[i][keyname];\n\n\t\t\t\t\t\t\t\tif (!areSameType(existingValue, currentValue)) {\n\t\t\t\t\t\t\t\t\tif(existingValue !== null) {\n\t\t\t\t\t\t\t\t\t\tallFields[keyname].value = null // force type \"any\" if types are not identical\n\t\t\t\t\t\t\t\t\t\tconsole.warn(`Warning: key \"${keyname}\" uses multiple types. Defaulting to type \"any\".`)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tallFields[keyname].count++\n\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// if variable was first detected as int (7) and a second time as float64 (3.14)\n\t\t\t\t\t\t\t\t// then we want to select float64, not int. Similar for int64 and float64.\n\t\t\t\t\t\t\t\tif(areSameType(currentValue, 1))\n\t\t\t\t\t\t\t\t\tallFields[keyname].value = findBestValueForNumberType(existingValue, currentValue);\n\n\t\t\t\t\t\t\t\tif (areObjects(existingValue, currentValue)) {\n\t\t\t\t\t\t\t\t\tconst comparisonResult = compareObjectKeys(\n\t\t\t\t\t\t\t\t\t\tObject.keys(currentValue),\n\t\t\t\t\t\t\t\t\t\tObject.keys(existingValue)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\tif (!comparisonResult) {\n\t\t\t\t\t\t\t\t\t\tkeyname = `${keyname}_${uuidv4()}`;\n\t\t\t\t\t\t\t\t\t\tallFields[keyname] = {\n\t\t\t\t\t\t\t\t\t\t\tvalue: currentValue,\n\t\t\t\t\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tallFields[keyname].count++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// create a common struct with all fields found in the current array\n\t\t\t\t\t// omitempty dict indicates if a field is optional\n\t\t\t\t\tconst keys = Object.keys(allFields), struct = {}, omitempty = {};\n\t\t\t\t\tfor (let k in keys)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst keyname = keys[k], elem = allFields[keyname];\n\n\t\t\t\t\t\tstruct[keyname] = elem.value;\n\t\t\t\t\t\tomitempty[keyname] = elem.count != scopeLength;\n\t\t\t\t\t}\n\t\t\t\t\tparseStruct(depth + 1, innerTabs, struct, omitempty, previousParents); // finally parse the struct !!\n\t\t\t\t}\n\t\t\t\telse if (sliceType == \"slice\") {\n\t\t\t\t\tparseScope(scope[0], depth)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (flatten && depth >= 2) {\n\t\t\t\t\t\tappender(sliceType || \"any\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tappend(sliceType || \"any\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (flatten) {\n\t\t\t\t\tif (depth >= 2){\n\t\t\t\t\t\tappender(parent)\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tappend(parent)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparseStruct(depth + 1, innerTabs, scope, false, previousParents);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (flatten && depth >= 2){\n\t\t\t\tappender(goType(scope));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tappend(goType(scope));\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseStruct(depth, innerTabs, scope, omitempty, oldParents)\n\t{\n\t\tif (flatten) {\n\t\t\tstack.push(\n\t\t\t\tdepth >= 2\n\t\t\t\t? \"\\n\"\n\t\t\t\t: \"\"\n\t\t\t)\n\t\t}\n\n\t\tconst seenTypeNames = [];\n\n\t\tif (flatten && depth >= 2)\n\t\t{\n\t\t\tconst parentType = `type ${parent}`;\n\t\t\tconst scopeKeys = formatScopeKeys(Object.keys(scope));\n\n\t\t\t// this can only handle two duplicate items\n\t\t\t// future improvement will handle the case where there could\n\t\t\t// three or more duplicate keys with different values\n\t\t\tif (parent in seen && compareObjectKeys(scopeKeys, seen[parent])) {\n\t\t\t\tstack.pop();\n\t\t\t\treturn\n\t\t\t}\n\t\t\tseen[parent] = scopeKeys;\n\n\t\t\tappender(`${parentType} struct {\\n`);\n\t\t\t++innerTabs;\n\t\t\tconst keys = Object.keys(scope);\n\t\t\tpreviousParents = parent\n\t\t\tfor (let i in keys)\n\t\t\t{\n\t\t\t\tconst keyname = getOriginalName(keys[i]);\n\t\t\t\tindenter(innerTabs)\n\t\t\t\tlet typename\n\t\t\t\t// structs will be defined on the top level of the go file, so they need to be globally unique\n\t\t\t\tif (typeof scope[keys[i]] === \"object\" && scope[keys[i]] !== null) {\n\t\t\t\t\ttypename = uniqueTypeName(format(keyname), globallySeenTypeNames, previousParents)\n\t\t\t\t\tgloballySeenTypeNames.push(typename)\n\t\t\t\t} else {\n\t\t\t\t\ttypename = uniqueTypeName(format(keyname), seenTypeNames)\n\t\t\t\t\tseenTypeNames.push(typename)\n\t\t\t\t}\n\n\t\t\t\tappender(typename+\" \");\n\t\t\t\tparent = typename\n\t\t\t\tparseScope(scope[keys[i]], depth);\n\t\t\t\tappender(' `json:\"'+keyname);\n\t\t\t\tif (allOmitempty || (omitempty && omitempty[keys[i]] === true))\n\t\t\t\t{\n\t\t\t\t\tappender(',omitempty');\n\t\t\t\t}\n\t\t\t\tappender('\"`\\n');\n\t\t\t}\n\t\t\tindenter(--innerTabs);\n\t\t\tappender(\"}\");\n\t\t\tpreviousParents = oldParents;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappend(\"struct {\\n\");\n\t\t\t++tabs;\n\t\t\tconst keys = Object.keys(scope);\n\t\t\tpreviousParents = parent\n\t\t\tfor (let i in keys)\n\t\t\t{\n\t\t\t\tconst keyname = getOriginalName(keys[i]);\n\t\t\t\tindent(tabs);\n\t\t\t\tlet typename\n\t\t\t\t// structs will be defined on the top level of the go file, so they need to be globally unique\n\t\t\t\tif (typeof scope[keys[i]] === \"object\" && scope[keys[i]] !== null) {\n\t\t\t\t\ttypename = uniqueTypeName(format(keyname), globallySeenTypeNames, previousParents)\n\t\t\t\t\tgloballySeenTypeNames.push(typename)\n\t\t\t\t} else {\n\t\t\t\t\ttypename = uniqueTypeName(format(keyname), seenTypeNames)\n\t\t\t\t\tseenTypeNames.push(typename)\n\t\t\t\t}\n\n\t\t\t\tappend(typename+\" \");\n\t\t\t\tparent = typename\n\t\t\t\tparseScope(scope[keys[i]], depth);\n\t\t\t\tappend(' `json:\"'+keyname);\n\t\t\t\tif (allOmitempty || (omitempty && omitempty[keys[i]] === true))\n\t\t\t\t{\n\t\t\t\t\tappend(',omitempty');\n\t\t\t\t}\n\t\t\t\tif (example && scope[keys[i]] !== \"\" && typeof scope[keys[i]] !== \"object\")\n\t\t\t\t{\n\t\t\t\t\tappend('\" example:\"'+scope[keys[i]])\n\t\t\t\t}\n\t\t\t\tappend('\"`\\n');\n\t\t\t}\n\t\t\tindent(--tabs);\n\t\t\tappend(\"}\");\n\t\t\tpreviousParents = oldParents;\n\t\t}\n\t\tif (flatten)\n\t\t\taccumulator += stack.pop();\n\t}\n\n\tfunction indent(tabs)\n\t{\n\t\tfor (let i = 0; i < tabs; i++)\n\t\t\tgo += '\\t';\n\t}\n\n\tfunction append(str)\n\t{\n\t\tgo += str;\n\t}\n\n\tfunction indenter(tabs)\n\t{\n\t\tfor (let i = 0; i < tabs; i++)\n\t\t\tstack[stack.length - 1] += '\\t';\n\t}\n\n\tfunction appender(str)\n\t{\n\t\tstack[stack.length - 1] += str;\n\t}\n\n\t// Generate a unique name to avoid duplicate struct field names.\n\t// This function appends a number at the end of the field name.\n\tfunction uniqueTypeName(name, seen, prefix=null) {\n\t\tif (seen.indexOf(name) === -1) {\n\t\t\treturn name;\n\t\t}\n\n\t\t// check if we can get a unique name by prefixing it\n\t\tif(prefix) {\n\t\t\tname = prefix+name\n\t\t\tif (seen.indexOf(name) === -1) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\tlet i = 0;\n\t\twhile (true) {\n\t\t\tlet newName = name + i.toString();\n\t\t\tif (seen.indexOf(newName) === -1) {\n\t\t\t\treturn newName;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t// Sanitizes and formats a string to make an appropriate identifier in Go\n\tfunction format(str)\n\t{\n\t\tstr = formatNumber(str);\n\n\t\tlet sanitized = toProperCase(str).replace(/[^a-z0-9]/ig, \"\")\n\t\tif (!sanitized) {\n\t\t\treturn \"NAMING_FAILED\";\n\t\t}\n\n\t\t// After sanitizing the remaining characters can start with a number.\n\t\t// Run the sanitized string again trough formatNumber to make sure the identifier is Num[0-9] or Zero_... instead of 1.\n\t\treturn formatNumber(sanitized)\n\t}\n\n\t// Adds a prefix to a number to make an appropriate identifier in Go\n\tfunction formatNumber(str) {\n\t\tif (!str)\n\t\t\treturn \"\";\n\t\telse if (str.match(/^\\d+$/))\n\t\t\tstr = \"Num\" + str;\n\t\telse if (str.charAt(0).match(/\\d/))\n\t\t{\n\t\t\tconst numbers = {'0': \"Zero_\", '1': \"One_\", '2': \"Two_\", '3': \"Three_\",\n\t\t\t\t'4': \"Four_\", '5': \"Five_\", '6': \"Six_\", '7': \"Seven_\",\n\t\t\t\t'8': \"Eight_\", '9': \"Nine_\"};\n\t\t\tstr = numbers[str.charAt(0)] + str.substr(1);\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t// Determines the most appropriate Go type\n\tfunction goType(val)\n\t{\n\t\tif (val === null)\n\t\t\treturn \"any\";\n\n\t\tswitch (typeof val)\n\t\t{\n\t\t\tcase \"string\":\n\t\t\t\tif (/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(\\.\\d+)?(\\+\\d\\d:\\d\\d|Z)$/.test(val))\n\t\t\t\t\treturn \"time.Time\";\n\t\t\t\telse\n\t\t\t\t\treturn \"string\";\n\t\t\tcase \"number\":\n\t\t\t\tif (val % 1 === 0)\n\t\t\t\t{\n\t\t\t\t\tif (val > -2147483648 && val < 2147483647)\n\t\t\t\t\t\treturn \"int\";\n\t\t\t\t\telse\n\t\t\t\t\t\treturn \"int64\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn \"float64\";\n\t\t\tcase \"boolean\":\n\t\t\t\treturn \"bool\";\n\t\t\tcase \"object\":\n\t\t\t\tif (Array.isArray(val))\n\t\t\t\t\treturn \"slice\";\n\t\t\t\treturn \"struct\";\n\t\t\tdefault:\n\t\t\t\treturn \"any\";\n\t\t}\n\t}\n\n\t// change the value to expand ints and floats to their larger equivalent\n\tfunction findBestValueForNumberType(existingValue, newValue) {\n\t\tif (!areSameType(newValue, 1)) {\n\t\t\tconsole.error(`Error: currentValue ${newValue} is not a number`)\n\t\t\treturn null // falls back to goType \"any\"\n\t\t}\n\n\t\tconst newGoType = goType(newValue)\n\t\tconst existingGoType = goType(existingValue)\n\n\t\tif (newGoType === existingGoType)\n\t\t\treturn existingValue\n\n\t\t// always upgrade float64\n\t\tif (newGoType === \"float64\")\n\t\t\treturn newValue\n\t\tif (existingGoType === \"float64\")\n\t\t\treturn existingValue\n\n\t\t// it's too complex to distinguish int types and float32, so we force-upgrade to float64\n\t\t// if anyone has a better suggestion, PRs are welcome!\n\t\tif (newGoType.includes(\"float\") && existingGoType.includes(\"int\"))\n\t\t\treturn Number.MAX_VALUE\n\t\tif (newGoType.includes(\"int\") && existingGoType.includes(\"float\"))\n\t\t\treturn Number.MAX_VALUE\n\n\t\tif (newGoType.includes(\"int\") && existingGoType.includes(\"int\")) {\n\t\t\tconst existingValueAbs = Math.abs(existingValue);\n\t\t\tconst newValueAbs = Math.abs(newValue);\n\n\t\t\t// if the sum is overflowing, it's safe to assume numbers are very large. So we force int64.\n\t\t\tif (!isFinite(existingValueAbs + newValueAbs))\n\t\t\t\treturn Number.MAX_SAFE_INTEGER\n\n\t\t\t// it's too complex to distinguish int8, int16, int32 and int64, so we just use the sum as best-guess\n\t\t\treturn existingValueAbs + newValueAbs;\n\t\t}\n\n\t\t// There should be other cases\n\t\tconsole.error(`Error: something went wrong with findBestValueForNumberType() using the values: '${newValue}' and '${existingValue}'`)\n\t\tconsole.error(\"       Please report the problem to https://github.com/mholt/json-to-go/issues\")\n\t\treturn null // falls back to goType \"any\"\n\t}\n\n\t// Given two types, returns the more specific of the two\n\tfunction mostSpecificPossibleGoType(typ1, typ2)\n\t{\n\t\tif (typ1.substr(0, 5) == \"float\"\n\t\t\t\t&& typ2.substr(0, 3) == \"int\")\n\t\t\treturn typ1;\n\t\telse if (typ1.substr(0, 3) == \"int\"\n\t\t\t\t&& typ2.substr(0, 5) == \"float\")\n\t\t\treturn typ2;\n\t\telse\n\t\t\treturn \"any\";\n\t}\n\n\t// Proper cases a string according to Go conventions\n\tfunction toProperCase(str)\n\t{\n\t\t// ensure that the SCREAMING_SNAKE_CASE is converted to snake_case\n\t\tif (str.match(/^[_A-Z0-9]+$/)) {\n\t\t\tstr = str.toLowerCase();\n\t\t}\n\n\t\t// https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.go#L771-L810\n\t\tconst commonInitialisms = [\n\t\t\t\"ACL\", \"API\", \"ASCII\", \"CPU\", \"CSS\", \"DNS\", \"EOF\", \"GUID\", \"HTML\", \"HTTP\",\n\t\t\t\"HTTPS\", \"ID\", \"IP\", \"JSON\", \"LHS\", \"QPS\", \"RAM\", \"RHS\", \"RPC\", \"SLA\",\n\t\t\t\"SMTP\", \"SQL\", \"SSH\", \"TCP\", \"TLS\", \"TTL\", \"UDP\", \"UI\", \"UID\", \"UUID\",\n\t\t\t\"URI\", \"URL\", \"UTF8\", \"VM\", \"XML\", \"XMPP\", \"XSRF\", \"XSS\"\n\t\t];\n\n\t\treturn str.replace(/(^|[^a-zA-Z])([a-z]+)/g, function(unused, sep, frag)\n\t\t{\n\t\t\tif (commonInitialisms.indexOf(frag.toUpperCase()) >= 0)\n\t\t\t\treturn sep + frag.toUpperCase();\n\t\t\telse\n\t\t\t\treturn sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();\n\t\t}).replace(/([A-Z])([a-z]+)/g, function(unused, sep, frag)\n\t\t{\n\t\t\tif (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)\n\t\t\t\treturn (sep + frag).toUpperCase();\n\t\t\telse\n\t\t\t\treturn sep + frag;\n\t\t});\n\t}\n\n\tfunction uuidv4() {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\t  var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n\t\t  return v.toString(16);\n\t\t});\n\t}\n\n\tfunction getOriginalName(unique) {\n\t\tconst reLiteralUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n\t\tconst uuidLength = 36;\n\n\t\tif (unique.length >= uuidLength) {\n\t\t\tconst tail = unique.substr(-uuidLength);\n\t\t\tif (reLiteralUUID.test(tail)) {\n\t\t\t\treturn unique.slice(0, -1 * (uuidLength + 1))\n\t\t\t}\n\t\t}\n\t\treturn unique\n\t}\n\n\tfunction areObjects(objectA, objectB) {\n\t\tconst object = \"[object Object]\";\n\t\treturn Object.prototype.toString.call(objectA) === object\n\t\t\t&& Object.prototype.toString.call(objectB) === object;\n\t}\n\n\tfunction areSameType(objectA, objectB) {\n\t\t// prototype.toString required to compare Arrays and Objects\n\t\tconst typeA =  Object.prototype.toString.call(objectA)\n\t\tconst typeB = Object.prototype.toString.call(objectB)\n\t\treturn typeA === typeB\n\t}\n\n\tfunction compareObjectKeys(itemAKeys, itemBKeys) {\n\t\tconst lengthA = itemAKeys.length;\n\t\tconst lengthB = itemBKeys.length;\n\n\t\t// nothing to compare, probably identical\n\t\tif (lengthA == 0 && lengthB == 0)\n\t\t\treturn true;\n\n\t\t// duh\n\t\tif (lengthA != lengthB)\n\t\t\treturn false;\n\n\t\tfor (let item of itemAKeys) {\n\t\t\tif (!itemBKeys.includes(item))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction formatScopeKeys(keys) {\n\t\tfor (let i in keys) {\n\t\t\tkeys[i] = format(keys[i]);\n\t\t}\n\t\treturn keys\n\t}\n}\n\nif (typeof module != 'undefined') {\n\tif (!module.parent) {\n\t\tlet filename = null\n\n\t\tfunction jsonToGoWithErrorHandling(json) {\n\t\t\tconst output = jsonToGo(json)\n\t\t\tif (output.error) {\n\t\t\t\tconsole.error(output.error)\n\t\t\t\tprocess.exitCode = 1\n\t\t\t}\n\t\t\tprocess.stdout.write(output.go)\n\t\t}\n\n\t\tprocess.argv.forEach((val, index) => {\n\t\t\tif (index < 2)\n\t\t\t\treturn\n\n\t\t\tif (!val.startsWith('-')) {\n\t\t\t\tfilename = val\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst argument = val.replace(/-/g, '')\n\t\t\tif (argument === \"big\")\n\t\t\t\tconsole.warn(`Warning: The argument '${argument}' has been deprecated and has no effect anymore`)\n\t\t\telse {\n\t\t\t\tconsole.error(`Unexpected argument ${val} received`)\n\t\t\t\tprocess.exit(1)\n\t\t\t}\n\t\t})\n\n\t\tif (filename) {\n\t\t\tconst fs = require('fs');\n\t\t\tconst json = fs.readFileSync(filename, 'utf8');\n\t\t\tjsonToGoWithErrorHandling(json)\n\t\t\treturn\n\t\t}\n\n\t\tif (!filename) {\n\t\t\tbufs = []\n\t\t\tprocess.stdin.on('data', function(buf) {\n\t\t\t\tbufs.push(buf)\n\t\t\t})\n\t\t\tprocess.stdin.on('end', function() {\n\t\t\t\tconst json = Buffer.concat(bufs).toString('utf8')\n\t\t\t\tjsonToGoWithErrorHandling(json)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tmodule.exports = jsonToGo\n\t}\n}\n"
        },
        {
          "name": "json-to-go.test.js",
          "type": "blob",
          "size": 7.236328125,
          "content": "const jsonToGo = require(\"./json-to-go\");\n\nfunction quote(str) {\n  return \"'\" + str\n    .replace(/\\t/g, \"\\\\t\")\n    .replace(/\\n/g, \"\\\\n\")\n    .replace(/\\r/g, \"\\\\r\")\n    .replace(/'/g, \"\\\\'\") + \"'\"\n}\n\nfunction test(includeExampleData) {\n  const testCases = [\n    {\n      input: '{\"SourceCode\": \"exampleDataHere\"}',\n      expected:\n        'type AutoGenerated struct {\\n\\tSourceCode string `json:\"SourceCode\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tSourceCode string `json:\"SourceCode\" example:\"exampleDataHere\"`\\n}\\n',\n    },\n    {\n      input: '{\"source_code\": \"exampleDataHere\"}',\n      expected:\n        'type AutoGenerated struct {\\n\\tSourceCode string `json:\"source_code\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tSourceCode string `json:\"source_code\" example:\"exampleDataHere\"`\\n}\\n',\n    },\n    {\n      input: '{\"sourceCode\": \"exampleDataHere\"}',\n      expected:\n        'type AutoGenerated struct {\\n\\tSourceCode string `json:\"sourceCode\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tSourceCode string `json:\"sourceCode\" example:\"exampleDataHere\"`\\n}\\n',\n    },\n    {\n      input: '{\"SOURCE_CODE\": \"\"}',\n      expected:\n        'type AutoGenerated struct {\\n\\tSourceCode string `json:\"SOURCE_CODE\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tSourceCode string `json:\"SOURCE_CODE\"`\\n}\\n',\n    },\n    {\n      input: '{\"PublicIP\": \"\"}',\n      expected:\n        'type AutoGenerated struct {\\n\\tPublicIP string `json:\"PublicIP\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tPublicIP string `json:\"PublicIP\"`\\n}\\n',\n    },\n    {\n      input: '{\"public_ip\": \"\"}',\n      expected:\n        'type AutoGenerated struct {\\n\\tPublicIP string `json:\"public_ip\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tPublicIP string `json:\"public_ip\"`\\n}\\n',\n    },\n    {\n      input: '{\"publicIP\": \"\"}',\n      expected:\n        'type AutoGenerated struct {\\n\\tPublicIP string `json:\"publicIP\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tPublicIP string `json:\"publicIP\"`\\n}\\n',\n    },\n    {\n      input: '{\"PUBLIC_IP\": \"\"}',\n      expected:\n        'type AutoGenerated struct {\\n\\tPublicIP string `json:\"PUBLIC_IP\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tPublicIP string `json:\"PUBLIC_IP\"`\\n}\\n',\n    },\n    {\n      input: '{\"+1\": \"Fails\", \"-1\": \"This should not cause duplicate field name\"}',\n      expected:\n        'type AutoGenerated struct {\\n\\tNum1 string `json:\"+1\"`\\n\\tNum10 string `json:\"-1\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tNum1 string `json:\"+1\" example:\"Fails\"`\\n\\tNum10 string `json:\"-1\" example:\"This should not cause duplicate field name\"`\\n}\\n',\n    },\n    {\n      input: '{\"age\": 46}',\n      expected:\n        'type AutoGenerated struct {\\n\\tAge int `json:\"age\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tAge int `json:\"age\" example:\"46\"`\\n}\\n',\n    },\n    {\n      input: '{\"negativeFloat\": -1.00}',\n      expected:\n        'type AutoGenerated struct {\\n\\tNegativeFloat float64 `json:\"negativeFloat\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tNegativeFloat float64 `json:\"negativeFloat\" example:\"-1.1\"`\\n}\\n',\n    },\n    {\n      input: '{\"zeroFloat\": 0.00}',\n      expected:\n        'type AutoGenerated struct {\\n\\tZeroFloat float64 `json:\"zeroFloat\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tZeroFloat float64 `json:\"zeroFloat\" example:\"0.1\"`\\n}\\n',\n    },\n    {\n      input: '{\"positiveFloat\": 1.00}',\n      expected:\n        'type AutoGenerated struct {\\n\\tPositiveFloat float64 `json:\"positiveFloat\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tPositiveFloat float64 `json:\"positiveFloat\" example:\"1.1\"`\\n}\\n',\n    },\n    {\n      input: '{\"negativeFloats\": [-1.00, -2.00, -3.00]}',\n      expected:\n        'type AutoGenerated struct {\\n\\tNegativeFloats []float64 `json:\"negativeFloats\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tNegativeFloats []float64 `json:\"negativeFloats\"`\\n}\\n',\n    },\n    {\n      input: '{\"zeroFloats\": [0.00, 0.00, 0.00]}',\n      expected:\n        'type AutoGenerated struct {\\n\\tZeroFloats []float64 `json:\"zeroFloats\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tZeroFloats []float64 `json:\"zeroFloats\"`\\n}\\n',\n    },\n    {\n      input: '{\"positiveFloats\": [1.00, 2.00, 3.00]}',\n      expected:\n        'type AutoGenerated struct {\\n\\tPositiveFloats []float64 `json:\"positiveFloats\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tPositiveFloats []float64 `json:\"positiveFloats\"`\\n}\\n',\n    },\n    {\n      input: '{\"topLevel\": { \"secondLevel\": \"exampleDataHere\"} }',\n      expected:\n        'type AutoGenerated struct {\\n\\tTopLevel struct {\\n\\t\\tSecondLevel string `json:\"secondLevel\"`\\n\\t} `json:\"topLevel\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tTopLevel struct {\\n\\t\\tSecondLevel string `json:\"secondLevel\" example:\"exampleDataHere\"`\\n\\t} `json:\"topLevel\"`\\n}\\n',\n    },\n    {\n      input: '{\"people\": [{ \"name\": \"Frank\"}, {\"name\": \"Dennis\"}, {\"name\": \"Dee\"}, {\"name\": \"Charley\"}, {\"name\":\"Mac\"}] }',\n      expected:\n        'type AutoGenerated struct {\\n\\tPeople []struct {\\n\\t\\tName string `json:\"name\"`\\n\\t} `json:\"people\"`\\n}\\n',\n      expectedWithExample:\n        'type AutoGenerated struct {\\n\\tPeople []struct {\\n\\t\\tName string `json:\"name\" example:\"Frank\"`\\n\\t} `json:\"people\"`\\n}\\n',\n    },\n  ];\n\n  for (const testCase of testCases) {\n    const got = jsonToGo(testCase.input, null, null, includeExampleData);\n    if (got.error) {\n      console.assert(!got.error, `format('${testCase.input}'): ${got.error}`);\n      process.exitCode = 16\n    } else {\n      const exp = includeExampleData ? testCase.expectedWithExample : testCase.expected\n      const success = got.go === exp\n      console.assert(success,\n        `format('${testCase.input}'): \\n\\tgot:  ${quote(got.go)}\\n\\twant: ${quote(exp)}`\n      );\n      if(!success) process.exitCode = 17\n    }\n  }\n  console.log(includeExampleData ? \"done testing samples with data\" : \"done testing samples without data\")\n}\n\nfunction testFiles() {\n  const fs = require('fs');\n  const path = require('path');\n\n  const testCases = [\n    \"duplicate-top-level-structs\",\n    \"double-nested-objects\",\n    \"array-with-mixed-float-int\",\n    \"array-with-nonmatching-types\",\n  ];\n\n  for (const testCase of testCases) {\n\n    try {\n      const jsonData = fs.readFileSync(path.join('tests', testCase + '.json'), 'utf8');\n      const expectedGoData = fs.readFileSync(path.join('tests', testCase + '.go'), 'utf8');\n      const got = jsonToGo(jsonData);\n      if (got.error) {\n        console.assert(!got.error, `format('${jsonData}'): ${got.error}`);\n        process.exitCode = 18\n      } else {\n        const success = got.go === expectedGoData\n        console.assert(success,\n          `format('${jsonData}'): \\n\\tgot:  ${quote(got.go)}\\n\\twant: ${quote(expectedGoData)}`\n        );\n        if(!success) process.exitCode = 19\n      }\n    } catch (err) {\n      console.error(err);\n      process.exitCode = 20\n    }\n  }\n  console.log(\"done testing files\")\n}\n\ntest(false);\ntest(true)\ntestFiles()\n"
        },
        {
          "name": "sample.json",
          "type": "blob",
          "size": 2.67578125,
          "content": "[\n    {\n        \"input_index\": 0,\n        \"candidate_index\": 0,\n        \"delivery_line_1\": \"1 N Rosedale St\",\n        \"last_line\": \"Baltimore MD 21229-3737\",\n        \"delivery_point_barcode\": \"212293737013\",\n        \"components\": {\n            \"primary_number\": \"1\",\n            \"street_predirection\": \"N\",\n            \"street_name\": \"Rosedale\",\n            \"street_suffix\": \"St\",\n            \"city_name\": \"Baltimore\",\n            \"state_abbreviation\": \"MD\",\n            \"zipcode\": \"21229\",\n            \"plus4_code\": \"3737\",\n            \"delivery_point\": \"01\",\n            \"delivery_point_check_digit\": \"3\"\n        },\n        \"metadata\": {\n            \"record_type\": \"S\",\n            \"zip_type\": \"Standard\",\n            \"county_fips\": \"24510\",\n            \"county_name\": \"Baltimore City\",\n            \"carrier_route\": \"C047\",\n            \"congressional_district\": \"07\",\n            \"rdi\": \"Residential\",\n            \"elot_sequence\": \"0059\",\n            \"elot_sort\": \"A\",\n            \"latitude\": 39.28602,\n            \"longitude\": -76.6689,\n            \"precision\": \"Zip9\",\n            \"time_zone\": \"Eastern\",\n            \"utc_offset\": -5,\n            \"dst\": true\n        },\n        \"analysis\": {\n            \"dpv_match_code\": \"Y\",\n            \"dpv_footnotes\": \"AABB\",\n            \"dpv_cmra\": \"N\",\n            \"dpv_vacant\": \"N\",\n            \"active\": \"Y\"\n        }\n    },\n    {\n        \"input_index\": 0,\n        \"candidate_index\": 1,\n        \"delivery_line_1\": \"1 S Rosedale St\",\n        \"last_line\": \"Baltimore MD 21229-3739\",\n        \"delivery_point_barcode\": \"212293739011\",\n        \"components\": {\n            \"primary_number\": \"1\",\n            \"street_predirection\": \"S\",\n            \"street_name\": \"Rosedale\",\n            \"street_suffix\": \"St\",\n            \"city_name\": \"Baltimore\",\n            \"state_abbreviation\": \"MD\",\n            \"zipcode\": \"21229\",\n            \"plus4_code\": \"3739\",\n            \"delivery_point\": \"01\",\n            \"delivery_point_check_digit\": \"1\"\n        },\n        \"metadata\": {\n            \"record_type\": \"S\",\n            \"zip_type\": \"Standard\",\n            \"county_fips\": \"24510\",\n            \"county_name\": \"Baltimore City\",\n            \"carrier_route\": \"C047\",\n            \"congressional_district\": \"07\",\n            \"rdi\": \"Residential\",\n            \"elot_sequence\": \"0064\",\n            \"elot_sort\": \"A\",\n            \"latitude\": 39.2858,\n            \"longitude\": -76.66889,\n            \"precision\": \"Zip9\",\n            \"time_zone\": \"Eastern\",\n            \"utc_offset\": -5,\n            \"dst\": true\n        },\n        \"analysis\": {\n            \"dpv_match_code\": \"Y\",\n            \"dpv_footnotes\": \"AABB\",\n            \"dpv_cmra\": \"N\",\n            \"dpv_vacant\": \"N\",\n            \"active\": \"Y\"\n        }\n    }\n]"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}