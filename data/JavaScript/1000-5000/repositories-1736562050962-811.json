{
  "metadata": {
    "timestamp": 1736562050962,
    "page": 811,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "andersontr15/clean-code-javascript-es",
      "stars": 3286,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.06640625,
          "content": "*.md linguist-documentation=false\n*.md linguist-language=JavaScript\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0732421875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017 Ryan McDermott, Theodore Anderson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 55.90625,
          "content": "Repositorio original: [ryanmcdermott/clean-code-javascript](https://github.com/ryanmcdermott/clean-code-javascript)\n\n# clean-code-javascript \n\n## Contenido\n  1. [Introducción](#introducción)\n  2. [Variables](#variables)\n  3. [Funciones](#funciones)\n  4. [Objetos y estructuras de data](#objetos-y-estructuras-de-data)\n  5. [Clases](#clases)\n  6. [SOLID](#solid)\n  7. [Pruebas](#pruebas)\n  8. [Concurrencia](#concurrencia)\n  9. [Resolver los errores](#resolver-los-errores)\n  10. [Formatear](#formatear)\n  11. [Comentarios](#comentarios)\n\n## Introducción\n\n![Imagen gracioso de la estimación de la calidad de software como una cifra \nde cuantos expletivos que uno puede gritar al leer programas](http://www.osnews.com/images/comics/wtfm.jpg)\n\nLos principios de la ingeniería de software, del libro de Robert C. Martin [*Clean Code*](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882), adaptado para JavaScript. Esta no es una guía de estilo, en cambio, es una guía para crear software que sea reutilizable, comprensible y que se pueda mejorar con el tiempo.\n\nNo hay que seguir tan estrictamente todos los principios en este libro, y vale la pena mencionar que hacia muchos de ellos habrá controversia en cuanto al consentimiento. Estas son reflexiones hechas después de muchos años de experiencia colectiva de los autores de *Clean Code*.\n\nNuestra obra de ingeniería de software lleva poco más que 50 años como negocio, y aún estamos aprendiendo. Cuando la arquitectura de software llegue a ser tan vieja como la arquitectura en sí misma, quizás tengamos reglas más estrictas para seguir. Hasta entonces, dejemos que estas guías sirvan como ejemplo para medir la calidad del código en JavaScript que tú y tu equipo producen.\n\nUna cosa más: saber esto no te hará un mejor ingeniero inmediatamente, y tampoco trabajar con estas herramientas durante muchos años garantiza que nunca te equivocarás. Cualquier código empieza primero como un borrador, como arcilla mojada moldeándose en su forma final. Por último, arreglamos las imperfecciones cuando lo repasamos con nuestros compañeros de trabajo. No seas tan duro contigo mismo por los borradores iniciales que aún necesitan mejorar. ¡Trabaja más duro para mejorar el programa!\n\n## **Variables**\n### Utiliza nombres significativos y pronunciables para las variables\n\n**Mal hecho:**\n```javascript\nconst yyyymmdstr = moment().format('YYYY/MM/DD');\n```\n\n**Bien hecho:**\n```javascript\nconst fechaActual = moment().format('YYYY/MM/DD');\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Utiliza el vocabulario igual para las variables del mismo tipo \n\n**Mal hecho:**\n```javascript\nconseguirInfoUsuario();\nconseguirDataDelCliente();\nconseguirRecordDelCliente();\n```\n\n**Bien hecho:**\n```javascript\nconseguirUsuario();\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Utiliza nombres buscables \n\nNosotros leemos mucho más código que jamás escribiremos. Es importante que el código que escribimos sea legible y buscable. Cuando faltamos nombrar a las variables de manera buscable y legible, acabamos confundiendo a nuestros lectores. Echa un vistazo a las herramientas para ayudarte: [buddy.js](https://github.com/danielstjules/buddy.js) y\n[ESLint](https://github.com/eslint/eslint/blob/660e0918933e6e7fede26bc675a0763a6b357c94/docs/rules/no-magic-numbers.md)\n\n**Mal hecho:**\n```javascript\n// Para qué rayos sirve 86400000? \nsetTimeout(hastaLaInfinidadYMasAlla, 86400000);\n\n```\n\n**Bien hecho:**\n```javascript\n// Decláralos como variables globales de 'const'.\nconst MILISEGUNDOS_EN_UN_DIA = 8640000;\n\nsetTimeout(hastaLaInfinidadYMasAlla, MILISEGUNDOS_EN_UN_DIA);\n\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Utiliza variables explicativas\n**Mal hecho:**\n```javascript\nconst direccion = 'One Infinite Loop, Cupertino 95014';\nconst codigoPostalRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/;\nsaveCityZipCode(direccion.match(codigoPostalRegex)[1], direccion.match(codigoPostalRegex)[2]);\n```\n\n**Bien hecho:**\n```javascript\nconst direccion = 'One Infinite Loop, Cupertino 95014';\nconst codigoPostalRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/;\nconst [, ciudad, codigoPostal] = direccion.match(codigoPostalRegex) || [];\nguardarcodigoPostal(ciudad, codigoPostal);\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Evitar el mapeo mental \nEl explícito es mejor que el implícito.\n\n**Mal hecho:**\n```javascript\nconst ubicaciones = ['Austin', 'New York', 'San Francisco'];\nubicaciones.forEach((u) => {\n  hazUnaCosa();\n  hasMasCosas()\n  // ...\n  // ...\n  // ...\n  // Espera, para qué existe la 'u'?\n  ejecuta(u);\n});\n```\n\n**Bien hecho:**\n```javascript\nconst ubicaciones = ['Austin', 'New York', 'San Francisco'];\nubicaciones.forEach((ubicacion) => {\n  hazUnaCosa();\n  hazMasCosas()\n  // ...\n  // ...\n  // ...\n  ejecuta(ubicacion);\n});\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### No incluyas contexto innecesario  \nSi el nombre de tu clase/objeto te dice algo, no lo repitas \nde nuevo en el nombre de variable.\n\n**Mal hecho:**\n```javascript\nconst Coche = {\n  cocheMarca: 'Honda',\n  cocheModelo: 'Accord',\n  cocheColor: 'Blue'\n};\n\nfunction pintarCoche(coche) {\n  coche.cocheColor = 'Red';\n}\n```\n\n**Bien hecho:**\n```javascript\nconst Coche = {\n  marca: 'Honda',\n  modelo: 'Accord',\n  color: 'Blue'\n};\n\nfunction pintarCoche(coche) {\n  coche.color = 'Red';\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Utiliza argumentos predefinidos en vez de utilizar condicionales \nLos argumentos predefinidos muchas veces son más organizados que utilizar los condicionales.\nSe consciente que si tú los usas, tu función sólo tendrá valores para los argumentos de `undefined`.\nLos demás valores de 'falso' como `''`, `\"\"`, `false`, `null`, `0`, y\n`NaN`, no se reemplazan con un valor predefinido.\n\n**Mal hecho:**\n```javascript\nfunction crearMicroCerveceria(nombre) {\n  const nombreDelMicroCerveceria = nombre || 'Hipster Brew Co.';\n  // ...\n}\n\n```\n\n**Bien hecho:**\n```javascript\nfunction crearMicroCerveceria(nombreDelMicroCerveceria = 'Hipster Brew Co.') {\n  // ...\n}\n\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n## **Funciones**\n### Argumentos de funciones (2 o menos idealmente)\n\nLimitar la cantidad de parámetros de tus funciones es increíblemente importante ya que hace que tus pruebas del código sean más fáciles. Al pasar los 3 argumentos, llegarás a un escenario de una explosión combinatoria en que hay que comprobar con pruebas muchos casos únicos con un argumento separado.\n\nUno o dos argumentos es la situación ideal, y más que eso uno debe evitar si es posible. Todo lo que se puede consolidar se debe consolidar. Normalmente, si tienes más que dos argumentos, tu función sirve para hacer demasiado. En otros casos, es mejor refactorizar y hacerlo un objeto para encapsular las funciones extras.\n\nYa que JavaScript te deja crear objetos cuando quieras sin incorporar la arquitectura de 'clases', se puede usar un objeto si necesitas muchos argumentos.\n\nPara hacerlo más obvio cuáles argumentos espera la función, se puede usar la sintaxis de ES2015/ES6: 'destructuración'. Esta sintaxis tiene varias ventajas:\n\n1. Cuando alguien se fija en el firme de la función, es inmediatamente claro cuáles argumentos se usan.\n2. Destructurar también copia los valores específicos y primitivos del objeto argumento que se le pasa a la función. Esto puede evitar los efectos extras. Ojo: objetos y arreglos que se destructuran del objeto argumento NO se copian.\n3. Los 'linters' te pueden avisar cuales argumentos / propiedades no se usan, lo cual sería imposible sin destructurar.\n\n\n**Mal hecho:**\n```javascript\nfunction crearMenu(titulo, contexto, textoDelBoton, cancelable) {\n  // ...\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction crearMenu({ titulo, contexto, textoDelBoton, cancelable }) {\n  // ...\n}\n\ncrearMenu({\n  titulo: 'Foo',\n  contexto: 'Bar',\n  textoDelBoton: 'Baz',\n  cancelable: true\n});\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Las funciones deben tener una sola responsabilidad\nEsta regla por mucho es la más importante en la ingeniería de software. Cuando las funciones sirven para hacer más que una sola cosa, se dificultan las pruebas, la composición y el entender. Cuando puedes aislar una función hasta tener solo una acción, se pueden mejorar más fácil y tu código llegue a ser mucho más limpio. Si solamente entiendes una cosa de esta guía, entiende esta regla y estarás adelantado de muchos desarrolladores.\n\n**Mal hecho:**\n```javascript\nfunction escribirClientes(clients) {\n  clientes.forEach((cliente) => {\n    const recordDelCliente = database.busca(cliente);\n    if (recordDelCliente.esActivo()) {\n      escribir(cliente);\n    }\n  });\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction escribirClientes(clientes) {\n  clientes\n    .filter(esActivoElCliente)\n    .forEach(email);\n}\n\nfunction esActivoElCliente(cliente) {\n  const recordDelCliente = database.busca(cliente);\n  return recordDelCliente.esActivo();\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Los nombres de las funciones deben explicar lo que hacen\n\n**Mal hecho:**\n```javascript\nfunction adelantarLaFechaPorUnDia(fecha, mes) {\n  // ...\n}\n\nconst fecha = new Date();\n// Es difícil entender del nombre lo que hace la función \nadelantarLaFechaPorUnDia(fecha, 1);\n```\n\n**Bien hecho:**\n```javascript\nfunction agregarMesAlDia(mes, fecha) {\n  // ...\n}\n\nconst fecha = new Date();\nagregarMesAlDia(1, fecha);\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Las funciones deben tener solo un nivel de abstracción \nCuando tienes más que un nivel de abstracción tu función suele servir \npara hacer demasiado. Crear varias funciones más pequeñas se debe a mejor reutilización\ny comprobación más fácil. \n\n**Mal hecho:**\n```javascript\nfunction parseBetterJSAlternative(code) {\n  const REGEXES = [\n    // ...\n  ];\n\n  const statements = code.split(' ');\n  const tokens = [];\n  REGEXES.forEach((REGEX) => {\n    statements.forEach((statement) => {\n      // ...\n    });\n  });\n\n  const ast = [];\n  tokens.forEach((token) => {\n    // lex...\n  });\n\n  ast.forEach((node) => {\n    // parse...\n  });\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction tokenize(code) {\n  const REGEXES = [\n    // ...\n  ];\n\n  const statements = code.split(' ');\n  const tokens = [];\n  REGEXES.forEach((REGEX) => {\n    statements.forEach((statement) => {\n      tokens.push( /* ... */ );\n    });\n  });\n\n  return tokens;\n}\n\nfunction lexer(tokens) {\n  const ast = [];\n  tokens.forEach((token) => {\n    ast.push( /* ... */ );\n  });\n\n  return ast;\n}\n\nfunction parseBetterJSAlternative(code) {\n  const tokens = tokenize(code);\n  const ast = lexer(tokens);\n  ast.forEach((node) => {\n    // parse...\n  });\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Eliminar el código duplicado \nHaz tanto como puedas para evitar código duplicado. El código duplicado es malo ya que significa que hay varios lugares donde hay que actualizar algo si un cambio es necesario en tu lógico.\n\nImagínate que estás en un restaurante y necesitas organizar tu inventario: todos tus tomates, cebolla, pimientos y tal. Si tienes varias listas donde organizas el inventario, cada lista se tendrá que actualizar en cuanto se baja tu inventario. En cambio, si logras tener una sola lista, solo se actualizará en un lugar a la hora de apuntar el inventario.\n\nMuchas veces tienes código duplicado se debe al hecho de tener dos o más cosas semejantes. Estos archivos pueden comparten varias cosas, pero sus diferencias te obligan separarlos para tener dos o más funciones que hacen cosas muy similares. Remover el código duplicado significa que se puede hacer la misma cosa que un solo función/módulo/clase.\n\nObtener la abstracción correcta es crítica y por eso debes de adherir a los principios de SOLID que se explican en la sección de Clases. Las malas abstracciones pueden ser aún peores que el código duplicado, ¡así que ten cuidado! Es decir, si puedes hacer una buena abstracción, ¡hazla! No te repitas, si no te darás cuenta de que andas actualizando mucho código en varios lugares a la hora de implementar un cambio.\n\n\n**Mal hecho:**\n```javascript\nfunction showDeveloperList(developers) {\n  developers.forEach((developer) => {\n    const expectedSalary = developer.calculateExpectedSalary();\n    const experience = developer.getExperience();\n    const githubLink = developer.getGithubLink();\n    const data = {\n      expectedSalary,\n      experience,\n      githubLink\n    };\n\n    render(data);\n  });\n}\n\nfunction showManagerList(managers) {\n  managers.forEach((manager) => {\n    const expectedSalary = manager.calculateExpectedSalary();\n    const experience = manager.getExperience();\n    const portfolio = manager.getMBAProjects();\n    const data = {\n      expectedSalary,\n      experience,\n      portfolio\n    };\n\n    render(data);\n  });\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction showEmployeeList(employees) {\n  employees.forEach((employee) => {\n    const expectedSalary = employee.calculateExpectedSalary();\n    const experience = employee.getExperience();\n\n    let portfolio = employee.getGithubLink();\n\n    if (employee.type === 'manager') {\n      portfolio = employee.getMBAProjects();\n    }\n\n    const data = {\n      expectedSalary,\n      experience,\n      portfolio\n    };\n\n    render(data);\n  });\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Crear objetos predefinidos con Object.assign\n\n**Mal hecho:**\n```javascript\nconst menuConfig = {\n  title: null,\n  body: 'Bar',\n  buttonText: null,\n  cancellable: true\n};\n\nfunction createMenu(config) {\n  config.title = config.title || 'Foo';\n  config.body = config.body || 'Bar';\n  config.buttonText = config.buttonText || 'Baz';\n  config.cancellable = config.cancellable === undefined ? config.cancellable : true;\n}\n\ncreateMenu(menuConfig);\n```\n\n**Bien hecho:**\n```javascript\nconst menuConfig = {\n  title: 'Order',\n  // El usuario no tenía la clave 'body'\n  buttonText: 'Send',\n  cancellable: true\n};\n\nfunction createMenu(config) {\n  config = Object.assign({\n    title: 'Foo',\n    body: 'Bar',\n    buttonText: 'Baz',\n    cancellable: true\n  }, config);\n  // el variable 'config' ahora iguala: {title: \"Order\", body: \"Bar\", buttonText: \"Send\", cancellable: true}\n  // ...\n}\n\ncreateMenu(menuConfig);\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### No utilices 'marcadores' como parámetros de las funciones\nLos marcadores existen para decirle a tu usuario que esta función hace más que una sola cosa. \nComo se ha mencionado antes las funciones deben hacer una sola cosa. \nDivide tus funciones en varias funciones más pequeñas si se adhieren a distintos métodos basados en un booleano. \n\n**Mal hecho:**\n```javascript\nfunction createFile(name, temp) {\n  if (temp) {\n    fs.create(`./temp/${name}`);\n  } else {\n    fs.create(name);\n  }\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction createFile(name) {\n  fs.create(name);\n}\n\nfunction createTempFile(name) {\n  createFile(`./temp/${name}`);\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Evitar que las funciones produzcan efectos extras (parte 1)\nUna función produce un efecto extra si hace cualquier cosa más que solo tomar \nun valor y volverlo/los). Un efecto extra podría ser escribir a un archivo, \nmodificar un variable global, o accidentalmente enviar todo tu dinero a un \ndesconfiado. \n\nBueno, las funciones necesitan tener efectos extras a menudo. Como el ejemplo anterior, \npuede que sea necesario escribir hasta un archivo. En ese caso, hay que centralizar en el 'por qué' \nde lo que estás haciendo. No tengas varias funciones y clases que escriben hasta un archivo particular. \nEn cambio, crea un 'servicio' que se dedica a eso: uno y solo un servicio.\n\nEl punto clave aquí es evitar las equivocaciones comunes como compartir 'estado' entre \nobjeto sin ninguna estructura, utilizar tipos de data mutables que se pueden escribir hasta \nlo que sea, y no centralizar donde se ocurren los efectos extras. Si puedes conseguir esto, \nserás más feliz que la mayoría de los demás programadores.\n\n\n**Mal hecho:**\n```javascript\n// Global variable referenced by following function.\n// If we had another function that used this name, now it'd be an array and it could break it.\nlet name = 'Ryan McDermott';\n\nfunction splitIntoFirstAndLastName() {\n  name = name.split(' ');\n}\n\nsplitIntoFirstAndLastName();\n\nconsole.log(name); // ['Ryan', 'McDermott'];\n```\n\n**Bien hecho:**\n```javascript\nfunction splitIntoFirstAndLastName(name) {\n  return name.split(' ');\n}\n\nconst name = 'Ryan McDermott';\nconst newName = splitIntoFirstAndLastName(name);\n\nconsole.log(name); // 'Ryan McDermott';\nconsole.log(newName); // ['Ryan', 'McDermott'];\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Evitar los efectos extras(parte 2)\nEn JavaScript, los primitivos se pasan por valores y los objetos/arrays se\npasan por referencia. En el caso de los objetos y los array, si tu función \nhace un cambio en la shopping cart array, por ejemplo, con agregar una cosa a \nla hora de comprar, resulta que todas las demás funciones que utilizan este array \nestarán afectadas. Esto puede ser bueno o malo. Imaginemos una situación mala:\n\nEl usuario le da click a \"Comprar\", un botón que invoca la función de \"comprar\".\nEsta función hace una solicitud del red y envía el array de 'cart' hasta el servidor.\nDebido a la conexión mala del red, la función sigue intentando invocarse para mandar \nla solicitud. Ahora, que pasa mientras tanto cuando el usuario le da click otra vez \nal botón en una cosa que no querían antes de que empezase la solicitud del red? \nBueno, si pasa eso y comienza la solicitud del red, la función de 'comprar' \nmandara sin querer la cosa que estaba agregada accidentalmente ya que tiene una \nreferencia al array de 'shopping cart' que la función 'addItemToCart' modifico \ncon agregar una cosa no deseada.\n\nUna buena solución seria que la función 'addItemToCart' siempre copiara la 'carta',\neditarla, y devolvérsela a la copia. Esto asegura que ninguna otra función relacionada \nse afectará por estos cambios.\n\nDos cosas para mencionar con esta solución:\n  1. Puede que existan escenarios donde de verdad quieres modificar el objeto de input, \n  pero cuando adoptas esta práctica de programar, te darás cuentas de que estos casos son \n  bastante únicos.\n  2. Copiar objetos grandes pueden ser muy caros en cuanto a la velocidad y calidad de tu programa.\n  Afortunadamente, no hay mucho problema con esto ya que existen muchas [recursos](https://facebook.github.io/immutable-js/)\n  que nos dejan lograr el copiar de objetos y arrays sin perder actuación.\n\n\n**Mal hecho:**\n```javascript\nconst addItemToCart = (cart, item) => {\n  cart.push({ item, date: Date.now() });\n};\n```\n\n**Bien hecho:**\n```javascript\nconst addItemToCart = (cart, item) => {\n  return [...cart, { item, date : Date.now() }];\n};\n```\n\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### No intentes cambiar las funciones globales\nPolucionar las construcciones globales no es buen costumbre en JavaScript \nya que se puede afrontar con otra biblioteca y el usuario de tu API no se daría \ncuenta hasta que reciba una excepción cuando ya está en producción el código. Pensemos \nen un ejemplo: que pasaría si quisieras extender los métodos nativos de la clase Array para \ntener un método de 'diff' en que se podría mostrar la diferencia entre dos arrays?\nPodrías escribir una nueva función hasta el prototipo del `Array.prototype`, pero eso\ntambién podría causar problemas con otra biblioteca que contenía el método igual. \nBueno, ¿qué pasaría si la otra biblioteca solamente usaba ‘diff’ para averiguar la diferencia entre el primer elemento y el último elemento del array? Por eso hay que utilizar las clases de ES2015/ES6 y extender el global de `Array`. \n\n\n**Mal hecho:**\n```javascript\nArray.prototype.diff = function diff(comparisonArray) {\n  const hash = new Set(comparisonArray);\n  return this.filter(elem => !hash.has(elem));\n};\n```\n\n**Bien hecho:**\n```javascript\nclass SuperArray extends Array {\n  diff(comparisonArray) {\n    const hash = new Set(comparisonArray);\n    return this.filter(elem => !hash.has(elem));\n  }\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Favorece a la programación funcional en vez de la programación imperativa\nJavaScript no es un idioma funcional tal como es Haskell, pero tiene su propio \nsabor funcional. Los idiomas funcionales son más limpios y fáciles de comprobar.\nFavorece este estilo de programar cuando puedes.\n\n\n**Mal hecho:**\n```javascript\nconst programmerOutput = [\n  {\n    name: 'Uncle Bobby',\n    linesOfCode: 500\n  }, {\n    name: 'Suzie Q',\n    linesOfCode: 1500\n  }, {\n    name: 'Jimmy Gosling',\n    linesOfCode: 150\n  }, {\n    name: 'Gracie Hopper',\n    linesOfCode: 1000\n  }\n];\n\nlet totalOutput = 0;\n\nfor (let i = 0; i < programmerOutput.length; i++) {\n  totalOutput += programmerOutput[i].linesOfCode;\n}\n```\n\n**Bien hecho:**\n```javascript\nconst programmerOutput = [\n  {\n    name: 'Uncle Bobby',\n    linesOfCode: 500\n  }, {\n    name: 'Suzie Q',\n    linesOfCode: 1500\n  }, {\n    name: 'Jimmy Gosling',\n    linesOfCode: 150\n  }, {\n    name: 'Gracie Hopper',\n    linesOfCode: 1000\n  }\n];\n\nconst INITIAL_VALUE = 0;\n\nconst totalOutput = programmerOutput\n  .map((programmer) => programmer.linesOfCode)\n  .reduce((acc, linesOfCode) => acc + linesOfCode, INITIAL_VALUE);\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Encapsular los condicionales\n\n**Mal hecho:**\n```javascript\nif (fsm.state === 'fetching' && isEmpty(listNode)) {\n  // ...\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction shouldShowSpinner(fsm, listNode) {\n  return fsm.state === 'fetching' && isEmpty(listNode);\n}\n\nif (shouldShowSpinner(fsmInstance, listNodeInstance)) {\n  // ...\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Evitar los condicionales negativos\n\n**Mal hecho:**\n```javascript\nfunction isDOMNodeNotPresent(node) {\n  // ...\n}\n\nif (!isDOMNodeNotPresent(node)) {\n  // ...\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction isDOMNodePresent(node) {\n  // ...\n}\n\nif (isDOMNodePresent(node)) {\n  // ...\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Evitar los condicionales\nEsto parece ser un reto imposible. Al escuchar esto por primera vez, \nla mayoría de la gente dirá: \"como se supone que hago sin una declaración de 'if'?\"\nBueno, la respuesta es que puedes utilizar  para lograr los \nmismos retos en muchos escenarios. La segunda pregunta suele ser: \"bueno, eso está bien, pero por qué voy a querer hacer eso?\" La respuesta yace en un concepto anterior que ya hemos \naprendido: una función solo debe hacer una sola cosa. Cuando tienes clases y funciones \nque contienen declaraciones de `if`, le dices al usuario que tu función hace más que una sola \ncosa. Recuerda, solo haz una cosa.\n\n\n**Mal hecho:**\n```javascript\nclass Airplane {\n  // ...\n  getCruisingAltitude() {\n    switch (this.type) {\n      case '777':\n        return this.getMaxAltitude() - this.getPassengerCount();\n      case 'Air Force One':\n        return this.getMaxAltitude();\n      case 'Cessna':\n        return this.getMaxAltitude() - this.getFuelExpenditure();\n    }\n  }\n}\n```\n\n**Bien hecho:**\n```javascript\nclass Airplane {\n  // ...\n}\n\nclass Boeing777 extends Airplane {\n  // ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude() - this.getPassengerCount();\n  }\n}\n\nclass AirForceOne extends Airplane {\n  // ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude();\n  }\n}\n\nclass Cessna extends Airplane {\n  // ...\n  getCruisingAltitude() {\n    return this.getMaxAltitude() - this.getFuelExpenditure();\n  }\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Evitar la comprobación de tipos (parte 1)\nJavaScript es un idioma no tecleado, por lo cual significa que tus funciones\npueden aceptar cualquier tipo de argumento. A veces te aprovechas de esta libertad\ny tienes ganas de hacer comprobación de `tipos` dentro de tus funciones. Hay muchas \nmaneras de evitar tener que hacer esto. La primeras cosas para considerar son APIs\nconsistentes.\n\n**Mal hecho:**\n```javascript\nfunction travelToTexas(vehicle) {\n  if (vehicle instanceof Bicycle) {\n    vehicle.pedal(this.currentLocation, new Location('texas'));\n  } else if (vehicle instanceof Car) {\n    vehicle.drive(this.currentLocation, new Location('texas'));\n  }\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction travelToTexas(vehicle) {\n  vehicle.move(this.currentLocation, new Location('texas'));\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Evitar la comprobación de tipos (parte 2)\nSi estás trabajando con los valores primitivos básicos como `strings`, enteros y arrays y que no puedes utilizar polimorfismo, pero existe la necesidad de comprobar los `tipos`, debes\nconsiderar utilizando TypeScript. Es un alternativo excelente a JavaScript, y te provee con los tipos estáticos encima del sintaxis estándar de JavaScript. El problema con comprobar los tipos en JavaScript es que para hacerlo bien resulta en mucho más verbos que no vale la pena al lado de la legibilidad disminuida que viene a junto con esta solución. Intenta mantener limpio tu código de JavaScript, escribe buenas pruebas, y haz buenas revisiones de código.\nEso dicho, haz todo lo de arriba, pero con TypeScript (por lo cual, como dije, es buen alternativo).\n\n\n**Mal hecho:**\n```javascript\nfunction combine(val1, val2) {\n  if (typeof val1 === 'number' && typeof val2 === 'number' ||\n      typeof val1 === 'string' && typeof val2 === 'string') {\n    return val1 + val2;\n  }\n\n  throw new Error('Must be of type String or Number');\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction combine(val1, val2) {\n  return val1 + val2;\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### No optimices demasiado\nLos navegadores modernos hacen mucha optimización en el fondo a la hora de ejecutar.\nMuchas veces, malgastas tu tiempo si optimizas. [Hay buenos recursos para esto](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers) para ver donde carece de optimizar tu código. Enfócate en esos huecos donde puedes optimizar, hasta que se puedan \narreglar si es posible.\n\n**Mal hecho:**\n```javascript\n\n// On old browsers, each iteration with uncached `list.length` would be costly\n// because of `list.length` recomputation. In modern browsers, this is optimized.\nfor (let i = 0, len = list.length; i < len; i++) {\n  // ...\n}\n```\n\n**Bien hecho:**\n```javascript\nfor (let i = 0; i < list.length; i++) {\n  // ...\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Eliminar el código muerto\nEl código muerto es tan elegante como el código duplicado. No hay razón \npara guardarlo. Si no se usa, ¡elimínalo! Aun estará en tu historia del control versión\nsi de verdad lo necesitas.\n\n\n**Mal hecho:**\n```javascript\nfunction oldRequestModule(url) {\n  // ...\n}\n\nfunction newRequestModule(url) {\n  // ...\n}\n\nconst req = newRequestModule;\ninventoryTracker('apples', req, 'www.inventory-awesome.io');\n\n```\n\n**Bien hecho:**\n```javascript\nfunction newRequestModule(url) {\n  // ...\n}\n\nconst req = newRequestModule;\ninventoryTracker('apples', req, 'www.inventory-awesome.io');\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n## **Objetos y estructuras de data**\n### Utiliza getters y setters\nUtilizar los getters y setters para acceder data dentro de los objetos \npuede ser mejor que simplemente buscar una propiedad. \"Por qué?\" Bueno, aquí \nte dejo con una lista desorganizada de las razones: \n\n* Cuando quieres hacer algo más allá de acceder una propiedad de objeto, no tienes \nqué buscar todos los accesorios en tu programa.\n* Hace que implementar validación sea más fácil cuando construyes un `set`\n* Encapsula la representación internal\n* Facilita la incorporación de apuntar errores de acceder y crear\n* Puedes cargar de manera vaga las propiedades del objeto, digamos de un servidor\npor ejemplo\n\n\n**Mal hecho:**\n```javascript\nfunction makeBankAccount() {\n  // ...\n\n  return {\n    balance: 0,\n    // ...\n  };\n}\n\nconst account = makeBankAccount();\naccount.balance = 100;\n```\n\n**Bien hecho:**\n```javascript\nfunction makeBankAccount() {\n  // this one is private\n  let balance = 0;\n\n  // a \"getter\", made public via the returned object below\n  function getBalance() {\n    return balance;\n  }\n\n  // a \"setter\", made public via the returned object below\n  function setBalance(amount) {\n    // ... validate before updating the balance\n    balance = amount;\n  }\n\n  return {\n    // ...\n    getBalance,\n    setBalance,\n  };\n}\n\nconst account = makeBankAccount();\naccount.setBalance(100);\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Haz que los objetos tengan miembros privados\nEsto se puede lograr con `closures` (con ES5 y antes)\n\n**Mal hecho:**\n```javascript\n\nconst Employee = function(name) {\n  this.name = name;\n};\n\nEmployee.prototype.getName = function getName() {\n  return this.name;\n};\n\nconst employee = new Employee('John Doe');\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe\ndelete employee.name;\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: undefined\n```\n\n**Bien hecho:**\n```javascript\nfunction makeEmployee(name) {\n  return {\n    getName() {\n      return name;\n    },\n  };\n}\n\nconst employee = makeEmployee('John Doe');\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe\ndelete employee.name;\nconsole.log(`Employee name: ${employee.getName()}`); // Employee name: John Doe\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n\n## **Clases**\n### Prefiere ES2015/ES6 clases en vez de funciones normales de ES5\nEs muy difícil para obtener una herencia legible de las clases, las construcción y \nlas definiciones de los métodos para las clases de ES5. Si necesitas la herencia (y puede que no la vayas a necesitar), entonces prefiere a las clases de ES2015/ES6. Sin embargo, prefiere funciones pequeñas hasta que necesites objetos más grandes y complejos.\n\n**Mal hecho:**\n```javascript\nconst Animal = function(age) {\n  if (!(this instanceof Animal)) {\n    throw new Error('Instantiate Animal with `new`');\n  }\n\n  this.age = age;\n};\n\nAnimal.prototype.move = function move() {};\n\nconst Mammal = function(age, furColor) {\n  if (!(this instanceof Mammal)) {\n    throw new Error('Instantiate Mammal with `new`');\n  }\n\n  Animal.call(this, age);\n  this.furColor = furColor;\n};\n\nMammal.prototype = Object.create(Animal.prototype);\nMammal.prototype.constructor = Mammal;\nMammal.prototype.liveBirth = function liveBirth() {};\n\nconst Human = function(age, furColor, languageSpoken) {\n  if (!(this instanceof Human)) {\n    throw new Error('Instantiate Human with `new`');\n  }\n\n  Mammal.call(this, age, furColor);\n  this.languageSpoken = languageSpoken;\n};\n\nHuman.prototype = Object.create(Mammal.prototype);\nHuman.prototype.constructor = Human;\nHuman.prototype.speak = function speak() {};\n```\n\n**Bien hecho:**\n```javascript\nclass Animal {\n  constructor(age) {\n    this.age = age;\n  }\n\n  move() { /* ... */ }\n}\n\nclass Mammal extends Animal {\n  constructor(age, furColor) {\n    super(age);\n    this.furColor = furColor;\n  }\n\n  liveBirth() { /* ... */ }\n}\n\nclass Human extends Mammal {\n  constructor(age, furColor, languageSpoken) {\n    super(age, furColor);\n    this.languageSpoken = languageSpoken;\n  }\n\n  speak() { /* ... */ }\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n\n### Utiliza la agregación de métodos\nEste modelo es muy útil en JavaScript y puede que lo veas en muchas bibliotecas \ncomo jQuery y Lodash. También permite que tu código sea expresivo y menos verboso.\nPor eso, digo, utiliza el encadenamiento de métodos y échale un vistazo a lo limpio \nque llega a ser tu código. En tus funciones de clases, simplemente devuelve el `this` al final de cada función y asi puedes seguir encadenando los metodos de tu clase.\n\n**Mal hecho:**\n```javascript\nclass Car {\n  constructor() {\n    this.make = 'Honda';\n    this.model = 'Accord';\n    this.color = 'white';\n  }\n\n  setMake(make) {\n    this.make = make;\n  }\n\n  setModel(model) {\n    this.model = model;\n  }\n\n  setColor(color) {\n    this.color = color;\n  }\n\n  save() {\n    console.log(this.make, this.model, this.color);\n  }\n}\n\nconst car = new Car();\ncar.setColor('pink');\ncar.setMake('Ford');\ncar.setModel('F-150');\ncar.save();\n```\n\n**Bien hecho:**\n```javascript\nclass Car {\n  constructor() {\n    this.make = 'Honda';\n    this.model = 'Accord';\n    this.color = 'white';\n  }\n\n  setMake(make) {\n    this.make = make;\n    // NOTE: Returning this for chaining\n    return this;\n  }\n\n  setModel(model) {\n    this.model = model;\n    // NOTE: Returning this for chaining\n    return this;\n  }\n\n  setColor(color) {\n    this.color = color;\n    // NOTE: Returning this for chaining\n    return this;\n  }\n\n  save() {\n    console.log(this.make, this.model, this.color);\n    // NOTE: Returning this for chaining\n    return this;\n  }\n}\n\nconst car = new Car()\n  .setColor('pink')\n  .setMake('Ford')\n  .setModel('F-150')\n  .save();\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Prefiere composición en vez de la herencia \nComo se ha dicho antes famosamente en el libro de [*Design Patterns*](https://en.wikipedia.org/wiki/Design_Patterns) escrito por el `Gang of Four`, debes preferir composición en vez de \nla herencia cuando puedas. Hay muchas razones para utilizar estos dos modelos. El punto importante aquí es que tu mente naturalmente quiere utilizar la herencia, así que intenta pensar si composición también podría resolver tu problema. En algunos casos, puede que sea la solución.\n\nPuede que te preguntes, ¿”cuando debería de utilizar la herencia?\" Bueno, \ndepende de tu problema del momento, pero esta sería una lista decente de cuando \ntiene más sentido utilizarla que la composición\n\n1. Tu herencia representa una relación de \"es-un\" y no un \"tener-un\" (Humano->Animal vs Usuario->Detalles del Usuario)\n2. Puedes reutilizar tu código de las clases bases (Los humanos pueden moverse como todos los animales)\n3. Quieres hacer cambios globales a las clases derivadas con cambiar una clase base.\n(Cambiar el gasto calórico de todos los animales cuando se mueven)\n\n**Mal hecho:**\n```javascript\nclass Employee {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n\n  // ...\n}\n\n// Bad because Employees \"have\" tax data. EmployeeTaxData is not a type of Employee\nclass EmployeeTaxData extends Employee {\n  constructor(ssn, salary) {\n    super();\n    this.ssn = ssn;\n    this.salary = salary;\n  }\n\n  // ...\n}\n```\n\n**Bien hecho:**\n```javascript\nclass EmployeeTaxData {\n  constructor(ssn, salary) {\n    this.ssn = ssn;\n    this.salary = salary;\n  }\n\n  // ...\n}\n\nclass Employee {\n  constructor(name, email) {\n    this.name = name;\n    this.email = email;\n  }\n\n  setTaxData(ssn, salary) {\n    this.taxData = new EmployeeTaxData(ssn, salary);\n  }\n  // ...\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n## **SOLID**\n### El principio único de responsabilidad (SRP)\nComo se menciona en *Clean Code*, \"Nunca debe existir más que una sola razón para cambiar \nuna clase\". Vale la pena decir que es normal querer llenar una 'clase' con muchas funciones, \nigual que cuando solo te permiten llevar una maleta en el vuelo. El problema existe en que \ntu 'clase' no estará cohesiva conceptualmente y existirá muchas razones para cambiarse.\nMinimizar la cantidad de veces que necesitas cambiar una clase es importante. Es importante \nya que con demasiada funcionalidad viene dificultad de modificarlo y entender cómo afecta \na otros módulos dependientes en tu programa.\n\n**Mal hecho:**\n```javascript\nclass UserSettings {\n  constructor(user) {\n    this.user = user;\n  }\n\n  changeSettings(settings) {\n    if (this.verifyCredentials()) {\n      // ...\n    }\n  }\n\n  verifyCredentials() {\n    // ...\n  }\n}\n```\n\n**Bien hecho:**\n```javascript\nclass UserAuth {\n  constructor(user) {\n    this.user = user;\n  }\n\n  verifyCredentials() {\n    // ...\n  }\n}\n\n\nclass UserSettings {\n  constructor(user) {\n    this.user = user;\n    this.auth = new UserAuth(user);\n  }\n\n  changeSettings(settings) {\n    if (this.auth.verifyCredentials()) {\n      // ...\n    }\n  }\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Principio de abierto/cerrado (OCP)\nComo dijo Bertrand Meyer, \"las entidades de software (clases, módulos, funciones, etc.)\ndeben abrirse para extensión, pero cerrarse para modificación. ¿Qué significa eso? \nBueno, este principio básicamente nos dice que debes permitir que tus usuarios \nintroduzcan nuevas funcionalidades sin cambiar el código existente.\n\n**Mal hecho:**\n```javascript\nclass AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'ajaxAdapter';\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'nodeAdapter';\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    if (this.adapter.name === 'ajaxAdapter') {\n      return makeAjaxCall(url).then((response) => {\n        // transform response and return\n      });\n    } else if (this.adapter.name === 'httpNodeAdapter') {\n      return makeHttpCall(url).then((response) => {\n        // transform response and return\n      });\n    }\n  }\n}\n\nfunction makeAjaxCall(url) {\n  // request and return promise\n}\n\nfunction makeHttpCall(url) {\n  // request and return promise\n}\n```\n\n**Bien hecho:**\n```javascript\nclass AjaxAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'ajaxAdapter';\n  }\n\n  request(url) {\n    // request and return promise\n  }\n}\n\nclass NodeAdapter extends Adapter {\n  constructor() {\n    super();\n    this.name = 'nodeAdapter';\n  }\n\n  request(url) {\n    // request and return promise\n  }\n}\n\nclass HttpRequester {\n  constructor(adapter) {\n    this.adapter = adapter;\n  }\n\n  fetch(url) {\n    return this.adapter.request(url).then((response) => {\n      // transform response and return\n    });\n  }\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### El principio de sustitución de Liskov (LSP)\nEste es un término espantoso para un concepto muy simple. Formalmente se define como \n\"Si S es un subtipo de T que los objetos de T se reemplazan con los objetos de tipo S\".\n(Es decir, los objetos de tipo S se pueden substituir con los objetos de tipo T sin alterar \nlas propiedades deseables del programa (precisión, actuación, etc.). Esa si es una definición aún más espantosa.\n\nLa mejor explanación para este concepto es si tienes una clase `padre` y una clase `hijo`, \nluego la clase base y la clase `hijo` se pueden intercambiar sin tener resultados que carecen de precisión. \nPuede que aun estas confundido, así que miremos al modelo clásico de rectángulo-cuadro. \nMatemáticamente, un cuadro es un rectángulo, pero si lo modelas como una relación de \"es-un\" con la herencia, te meterás en problemas rápidamente.\n\n**Mal hecho:**\n```javascript\nclass Rectangle {\n  constructor() {\n    this.width = 0;\n    this.height = 0;\n  }\n\n  setColor(color) {\n    // ...\n  }\n\n  render(area) {\n    // ...\n  }\n\n  setWidth(width) {\n    this.width = width;\n  }\n\n  setHeight(height) {\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Rectangle {\n  setWidth(width) {\n    this.width = width;\n    this.height = width;\n  }\n\n  setHeight(height) {\n    this.width = height;\n    this.height = height;\n  }\n}\n\nfunction renderLargeRectangles(rectangles) {\n  rectangles.forEach((rectangle) => {\n    rectangle.setWidth(4);\n    rectangle.setHeight(5);\n    const area = rectangle.getArea(); // BAD: Returns 25 for Square. Should be 20.\n    rectangle.render(area);\n  });\n}\n\nconst rectangles = [new Rectangle(), new Rectangle(), new Square()];\nrenderLargeRectangles(rectangles);\n```\n\n**Bien hecho:**\n```javascript\nclass Shape {\n  setColor(color) {\n    // ...\n  }\n\n  render(area) {\n    // ...\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(width, height) {\n    super();\n    this.width = width;\n    this.height = height;\n  }\n\n  getArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Shape {\n  constructor(length) {\n    super();\n    this.length = length;\n  }\n\n  getArea() {\n    return this.length * this.length;\n  }\n}\n\nfunction renderLargeShapes(shapes) {\n  shapes.forEach((shape) => {\n    const area = shape.getArea();\n    shape.render(area);\n  });\n}\n\nconst shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];\nrenderLargeShapes(shapes);\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### El principio de segregación en cuanto a los interfaces (ISP)\nJavaScript no tiene interfaces así que este principio no se aplica tanto como en otros \nidiomas. Sin embargo, es importante y es relevante, aunque JavaScript no tenga un sistema \nde `tipos`.\n\nISP declara que \"Los clientes no se deben forzar para depender en interfaces que \nno implementan\". Los interfaces son contratos implícitos en JavaScript debido al `teclear de duck`.\n\nUn buen ejemplo que demuestra este principio en JavaScript es para las clases que \nnecesitan objetos grandes de composición. Con no requerir que los clientes se encarguen \nde muchas opciones, puedes beneficiar ya que la mayoría del tiempo no hace falta todo lo extra. \nCuando haces que las opciones del contratos sean opcionales, evitas un \"interfaz gordo\".\n\n\n**Mal hecho:**\n```javascript\nclass DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.animationModule.setup();\n  }\n\n  traverse() {\n    // ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName('body'),\n  animationModule() {} // Most of the time, we won't need to animate when traversing.\n  // ...\n});\n\n```\n\n**Bien hecho:**\n```javascript\nclass DOMTraverser {\n  constructor(settings) {\n    this.settings = settings;\n    this.options = settings.options;\n    this.setup();\n  }\n\n  setup() {\n    this.rootNode = this.settings.rootNode;\n    this.setupOptions();\n  }\n\n  setupOptions() {\n    if (this.options.animationModule) {\n      // ...\n    }\n  }\n\n  traverse() {\n    // ...\n  }\n}\n\nconst $ = new DOMTraverser({\n  rootNode: document.getElementsByTagName('body'),\n  options: {\n    animationModule() {}\n  }\n});\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### El principio de la inversión de las dependencias (DIP)\nEste principio declara dos cosas esenciales:\n1. Los módulos de nivel alto no deben depender en los módulos de nivel bajo.\nLos dos deben dependerse en las abstracciones.\n2. Las abstracciones no deben dependerse en las detalles. Las detalles deben\ndependerse en las abstracciones.\n\nEsto ha de entender la primera vez, pero si has trabajado con \nAngularJS, has visto una implementación de este principio en la forma de la inyección de dependencias (DI). \nMientras que no son conceptos idénticos, el DIP mantiene que los módulos de nivel alto no sepan las detalles de los módulos de nivel bajo y también se encarga de ellos. \nEsto se puede conseguir con DI. Un beneficio enorme de esto es que reduce la convivencia entre los módulos. \nLa convivencia es un modelo muy malo en cuanto al desarrollo de software ya dificulta la posibilidad de refactorizar.\n\nComo se ha mencionado previamente, JavaScript no tiene interfaces así que las abstracciones\nde las que se dependen son contratos implícitos. Es decir, los métodos y las propiedades \nque un objeto/clase expone hasta otro objeto/clase. En el ejemplo más abajo, el contrato implícito es que cualquier módulo de Request que utilizar el `InventoryTracker` debe tener \nun método de `requestItems`.\n\n\n**Mal hecho:**\n```javascript\nclass InventoryRequester {\n  constructor() {\n    this.REQ_METHODS = ['HTTP'];\n  }\n\n  requestItem(item) {\n    // ...\n  }\n}\n\nclass InventoryTracker {\n  constructor(items) {\n    this.items = items;\n\n    // BAD: We have created a dependency on a specific request implementation.\n    // We should just have requestItems depend on a request method: `request`\n    this.requester = new InventoryRequester();\n  }\n\n  requestItems() {\n    this.items.forEach((item) => {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\nconst inventoryTracker = new InventoryTracker(['apples', 'bananas']);\ninventoryTracker.requestItems();\n```\n\n**Bien hecho:**\n```javascript\nclass InventoryTracker {\n  constructor(items, requester) {\n    this.items = items;\n    this.requester = requester;\n  }\n\n  requestItems() {\n    this.items.forEach((item) => {\n      this.requester.requestItem(item);\n    });\n  }\n}\n\nclass InventoryRequesterV1 {\n  constructor() {\n    this.REQ_METHODS = ['HTTP'];\n  }\n\n  requestItem(item) {\n    // ...\n  }\n}\n\nclass InventoryRequesterV2 {\n  constructor() {\n    this.REQ_METHODS = ['WS'];\n  }\n\n  requestItem(item) {\n    // ...\n  }\n}\n\n// By constructing our dependencies externally and injecting them, we can easily\n// substitute our request module for a fancy new one that uses WebSockets.\nconst inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());\ninventoryTracker.requestItems();\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n## **Pruebas**\nComprobar nuestro código es más importante que enviarlo. Si no tienes pruebas o tienes una cantidad inadecuada, cada vez que envías tu código tendrás dudas en cuanto el saber de cuantos errores aún existen en tus programas. Deducir en lo que constituye una cantidad adecuada es la responsabilidad del equipo, pero tener cobertura 100% (todos las declaraciones y ramos) es como se logra una confianza alta y una tranquilidad de mente. Esto significa que encima de utilizar una estructura de pruebas, también necesitas usar una buena herramienta de cobertura.\n\nNo existe excusa para no escribir pruebas. Hay muchas estructuras buenas de pruebas para JS, así que busca una que le guste tu equipo. Cuando encuentras una que tu equipo le gusta, enfócate en siempre escribir pruebas para cada nueva característica/módulo que introduces. Si tu método preferido es el Test Driven Development (TDD), eso está bien, pero el punto principal es que te aseguras de llegar a tus objetivos de cobertura antes de enviar el código o refactorizar una prueba ya existente.\n\n\n### Un solo concepto para cada prueba\n\n**Mal hecho:**\n```javascript\nimport assert from 'assert';\n\ndescribe('MakeMomentJSGreatAgain', () => {\n  it('handles date boundaries', () => {\n    let date;\n\n    date = new MakeMomentJSGreatAgain('1/1/2015');\n    date.addDays(30);\n    assert.equal('1/31/2015', date);\n\n    date = new MakeMomentJSGreatAgain('2/1/2016');\n    date.addDays(28);\n    assert.equal('02/29/2016', date);\n\n    date = new MakeMomentJSGreatAgain('2/1/2015');\n    date.addDays(28);\n    assert.equal('03/01/2015', date);\n  });\n});\n```\n\n**Bien hecho:**\n```javascript\nimport assert from 'assert';\n\ndescribe('MakeMomentJSGreatAgain', () => {\n  it('handles 30-day months', () => {\n    const date = new MakeMomentJSGreatAgain('1/1/2015');\n    date.addDays(30);\n    assert.equal('1/31/2015', date);\n  });\n\n  it('handles leap year', () => {\n    const date = new MakeMomentJSGreatAgain('2/1/2016');\n    date.addDays(28);\n    assert.equal('02/29/2016', date);\n  });\n\n  it('handles non-leap year', () => {\n    const date = new MakeMomentJSGreatAgain('2/1/2015');\n    date.addDays(28);\n    assert.equal('03/01/2015', date);\n  });\n});\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n## **Concurrencia**\n### Utiliza las promesas y no utilices los callbacks\nLos callbacks no son limpos y utilizan una cantidad excesiva de encajamiento. Con ES2015/ES6, las Promesas son un tipo ya nativo del idioma. Utilizalas!\n\n**Mal hecho:**\n```javascript\nimport { get } from 'request';\nimport { writeFile } from 'fs';\n\nget('https://en.wikipedia.org/wiki/Robert_Cecil_Martin', (requestErr, response) => {\n  if (requestErr) {\n    console.error(requestErr);\n  } else {\n    writeFile('article.html', response.body, (writeErr) => {\n      if (writeErr) {\n        console.error(writeErr);\n      } else {\n        console.log('File written');\n      }\n    });\n  }\n});\n\n```\n\n**Bien hecho:**\n```javascript\nimport { get } from 'request';\nimport { writeFile } from 'fs';\n\nget('https://en.wikipedia.org/wiki/Robert_Cecil_Martin')\n  .then((response) => {\n    return writeFile('article.html', response);\n  })\n  .then(() => {\n    console.log('File written');\n  })\n  .catch((err) => {\n    console.error(err);\n  });\n\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Async/Await son aún más limpios que las Promesas\nLas Promesas son una alternativa muy limpia a los callbacks, pero ES2017/E8 incluye \n`async` y `await` que ofrecen una solución aún más limpia. Todo lo que necesitas es una función que empieza con la palabra `async`, y luego puedes escribir tu lógico imperativamente sin una fila de funciones de `then`. Utiliza esto si puedes aprovecharte de los beneficios de ES2017/E8 hoy!\n\n**Mal hecho:**\n```javascript\nimport { get } from 'request-promise';\nimport { writeFile } from 'fs-promise';\n\nget('https://en.wikipedia.org/wiki/Robert_Cecil_Martin')\n  .then((response) => {\n    return writeFile('article.html', response);\n  })\n  .then(() => {\n    console.log('File written');\n  })\n  .catch((err) => {\n    console.error(err);\n  });\n\n```\n\n**Bien hecho:**\n```javascript\nimport { get } from 'request-promise';\nimport { writeFile } from 'fs-promise';\n\nasync function getCleanCodeArticle() {\n  try {\n    const response = await get('https://en.wikipedia.org/wiki/Robert_Cecil_Martin');\n    await writeFile('article.html', response);\n    console.log('File written');\n  } catch(err) {\n    console.error(err);\n  }\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n\n## **Resolver los errores**\n¡Los errores que emergen en tus programas son buenos! Significan que tu ejecución ha tenido \néxito a la hora de identificar un error en tu programa y te avisa con \ndetener la ejecución del 'stack' actual, matando el proceso (en Node),\ny notificarse en el 'console' con un reporte de 'stack trace'\n\n### No les ignores a los errores pillados\nHacer nada cuando existe un error pillado no te da la habilidad de arreglar o resolverlo.\nApuntar el error al console (`console.log`) no es mucho mejor ya que muchas veces se puede perder en un mar de cosas que se apuntan al console. Si metes tu código en un `try/catch` significa que un error puede ocurrir allí y así que deberías de tener un plan, o crear una solución por si acaso.\n\n\n**Mal hecho:**\n```javascript\ntry {\n  functionThatMightThrow();\n} catch (error) {\n  console.log(error);\n}\n```\n\n**Bien hecho:**\n```javascript\ntry {\n  functionThatMightThrow();\n} catch (error) {\n  // One option (more noisy than console.log):\n  console.error(error);\n  // Another option:\n  notifyUserOfError(error);\n  // Another option:\n  reportErrorToService(error);\n  // OR do all three!\n}\n```\n\n### No le ignores a las promesas rechazadas \nIgual que no debes ignorar a los errores no pillados \nde un 'try/catch'\n\n**Mal hecho:**\n```javascript\ngetdata()\n  .then((data) => {\n    functionThatMightThrow(data);\n  })\n  .catch((error) => {\n    console.log(error);\n  });\n```\n\n**Bien hecho:**\n```javascript\ngetdata()\n  .then((data) => {\n    functionThatMightThrow(data);\n  })\n  .catch((error) => {\n     // Una opción (más ruidoso que console.log):\n    console.error(error);\n    // Otra opción:\n    notifyUserOfError(error);\n    // Otra opción\n    reportErrorToService(error);\n    // O haz las tres!\n  });\n```\n\n**[⬆ vuelve hasta arriba](#contenido)**\n\n## **Formatear**\nFormatear es subjetivo. Como muchas reglas en esta guía, no hay que seguirlas\n100%. El punto clave es: NO DISCUTAS sobre formatear. \nHay muchas [herramientas](http://standardjs.com/rules.html) para facilitar esto.\n¡Utiliza una de estas herramientas! Te desperdicias de tu propio tiempo y el tiempo de los demás cuando \ndiscuten sobre formatear.\n\nPara las cosas que no tienen relevancia al formateo automático (indentación, tabulos y espacios,\ncomillas dobles y sencillas, etc.), busca aquí para aconsejarte.\n\n### Utiliza capitalización consistente\nJavaScript es un idioma no tecleado, así que la capitalización puede decirte muchas cosas sobre tus variables, funciones, etc. Estas reglas son subjetivas, así que tu equipo puede escoger lo que quiera. El punto es, sin importar lo que escojas, se consistente.\n\n\n**Mal hecho:**\n```javascript\nconst DAYS_IN_WEEK = 7;\nconst daysInMonth = 30;\n\nconst songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];\nconst Artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];\n\nfunction eraseDatabase() {}\nfunction restore_database() {}\n\nclass animal {}\nclass Alpaca {}\n```\n\n**Bien hecho:**\n```javascript\nconst DAYS_IN_WEEK = 7;\nconst DAYS_IN_MONTH = 30;\n\nconst songs = ['Back In Black', 'Stairway to Heaven', 'Hey Jude'];\nconst artists = ['ACDC', 'Led Zeppelin', 'The Beatles'];\n\nfunction eraseDatabase() {}\nfunction restoreDatabase() {}\n\nclass Animal {}\nclass Alpaca {}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Los llamadores y llamantes de las funciones deben existir cercas \nSi una función le llama a otra, mantiene esa funcionas verticalmente cerca en \nsu archivo de fuente. Idealmente, mantiene el llamador justo encima del llamante.\nSolemos leer código arriba-abajo, como un periódico. Debido a esto, haz que tus programas sean legibles así.\n\n\n**Mal hecho:**\n```javascript\nclass PerformanceReview {\n  constructor(employee) {\n    this.employee = employee;\n  }\n\n  lookupPeers() {\n    return db.lookup(this.employee, 'peers');\n  }\n\n  lookupManager() {\n    return db.lookup(this.employee, 'manager');\n  }\n\n  getPeerReviews() {\n    const peers = this.lookupPeers();\n    // ...\n  }\n\n  perfReview() {\n    this.getPeerReviews();\n    this.getManagerReview();\n    this.getSelfReview();\n  }\n\n  getManagerReview() {\n    const manager = this.lookupManager();\n  }\n\n  getSelfReview() {\n    // ...\n  }\n}\n\nconst review = new PerformanceReview(user);\nreview.perfReview();\n```\n\n**Bien hecho:**\n```javascript\nclass PerformanceReview {\n  constructor(employee) {\n    this.employee = employee;\n  }\n\n  perfReview() {\n    this.getPeerReviews();\n    this.getManagerReview();\n    this.getSelfReview();\n  }\n\n  getPeerReviews() {\n    const peers = this.lookupPeers();\n    // ...\n  }\n\n  lookupPeers() {\n    return db.lookup(this.employee, 'peers');\n  }\n\n  getManagerReview() {\n    const manager = this.lookupManager();\n  }\n\n  lookupManager() {\n    return db.lookup(this.employee, 'manager');\n  }\n\n  getSelfReview() {\n    // ...\n  }\n}\n\nconst review = new PerformanceReview(employee);\nreview.perfReview();\n```\n\n**[⬆ vuelve hasta arriba](#contenido)**\n\n## **Comentarios**\n### Solamente comenta las cosas que tienen lógico complejo.\nLos comentarios existen para pedir perdón, pero no son un requisito. El código bueno más que nada se documenta sí mismo.\n\n**Mal hecho:**\n```javascript\nfunction hashIt(data) {\n  // El hash\n  let hash = 0;\n\n  // Length of string\n  const length = data.length;\n  // Iterar cada caracter en la data\n  for (let i = 0; i < length; i++) {\n     // Conseguir el código del caracter\n    const char = data.charCodeAt(i);\n    // Crear el hash \n    hash = ((hash << 5) - hash) + char;\n    // Conviertelo hasta 32-bit\n    hash &= hash;\n  }\n}\n```\n\n**Bien hecho:**\n```javascript\n\nfunction hashIt(data) {\n  let hash = 0;\n  const length = data.length;\n\n  for (let i = 0; i < length; i++) {\n    const char = data.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash &= hash;\n  }\n}\n\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### No dejes código inutilizado en tus archivos \nEl control de versión existe para una razón. Deja el código viejo \nen tu historia (git).\n\n**Mal hecho:**\n```javascript\n\nhazAlgo()\n// hazMasCosas();\n// hazAunMasCosas();\n// hazTantasOtrasCosas();\n```\n\n**Bien hecho:**\n```javascript\ndoStuff();\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### No escribas comentarios de jornada \nOjo: ¡utiliza el control de versión (git)! No hay necesidad para el código no utilizado, \ncomentado, y especialmente comentarios de jornada. En cambio, utiliza 'git log' para \nrecuperar una historia de lo que has hecho.\n\n**Mal hecho:**\n```javascript\n/**\n * 2016-12-20: Remover monads, no los entendia bien (RM)\n * 2016-10-01: Mejorar utilizando los monads especiales (JP)\n * 2016-02-03: Remover la comprobacion de tipos de data (LI)\n * 2015-03-14: Agregar la funcion combinar (JR)\n */\nfunction combinar(a, b) {\n  return a + b;\n}\n```\n\n**Bien hecho:**\n```javascript\nfunction combinar(a, b) {\n  return a + b;\n}\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n### Evitar los marcadores posicionales\nLos marcadores posicionales suelen dificultar las cosas. Deja que las funciones,\nlos nombres de tus variables, la indentación adecuada y el formatear creen una estructura \nvisual para tu código.\n\n**Mal hecho:**\n```javascript\n////////////////////////////////////////////////////////////////////////////////\n// Instanciacion del modelo de Scope\n////////////////////////////////////////////////////////////////////////////////\n$scope.modelo = {\n  menu: 'foo',\n  nav: 'bar'\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Iniciar de acciones \n////////////////////////////////////////////////////////////////////////////////\nconst acciones = function() {\n  // ...\n};\n```\n\n**Bien hecho:**\n```javascript\n$scope.modelo = {\n  menu: 'foo',\n  nav: 'bar'\n};\n\nconst acciones = function() {\n  // ...\n};\n```\n**[⬆ vuelve hasta arriba](#contenido)**\n\n"
        }
      ]
    }
  ]
}