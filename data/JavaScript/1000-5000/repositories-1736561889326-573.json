{
  "metadata": {
    "timestamp": 1736561889326,
    "page": 573,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "just-js/just",
      "stars": 3664,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.107421875,
          "content": "*.tz\n*.gz\n*.7z\njust\nbuiltins.h\n.ccache\nscratch\n.vscode\nout\ndeps\n*.o\n*.a\nmodules\nexamples\n.just\nlib/*/*\n*.debug"
        },
        {
          "name": ".gitpod.yml",
          "type": "blob",
          "size": 0.078125,
          "content": "tasks:\n  - init: |\n      make clean runtime\n    command: |\n      ./just --help\n\n"
        },
        {
          "name": "BUILD.md",
          "type": "blob",
          "size": 0.794921875,
          "content": "```bash\n## make the main runtime\nmake runtime\n## change the config and rebuild using an eval\n./just eval \"require('build').run(require('config/runtime.js'))\"\n## or pipe ebal to just\necho \"require('build').run(require('config/runtime.js'))\" | ./just --\n## or rebuild like this\n./just build\n## or use a different config\n./just build foo.js\n## or use json instead\n./just build foo.json\n## dump a configuration\n./just build config/runtime.js --dump\n## clean and build\n./just build config/runtime.js --clean\n## clean and make a debug build\n./just build config/runtime.js --clean --debug\n## install examples\n./just build config/runtime.js examples\n## build the net module\nMODULE=net ./just build config/runtime.js module\n## build debug version of the net module\nMODULE=net ./just build config/runtime.js module-debug\n```"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.2431640625,
          "content": "## Hacking on just in Gitpod\n\nIf you have a web browser, you can get a fully pre-configured development environment with one click:\n\n[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/just-js/just)"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2020 Andrew Johnston\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 5.71875,
          "content": "CC=g++\nRELEASE=0.1.13\nINSTALL=/usr/local/bin\nLIBS=lib/loop.js lib/path.js lib/fs.js lib/process.js lib/build.js lib/repl.js lib/acorn.js lib/configure.js\nMODULES=modules/net/net.o modules/epoll/epoll.o modules/fs/fs.o modules/sys/sys.o modules/vm/vm.o\nTARGET=just\nLIB=-ldl -lrt\nEMBEDS=just.cc just.h Makefile main.cc lib/websocket.js lib/inspector.js just.js config.js\nFLAGS=${CFLAGS}\nLFLAG=${LFLAGS}\nJUST_HOME=$(shell pwd)\n\n.PHONY: help clean\n\nhelp:\n\t@awk 'BEGIN {FS = \":.*?## \"} /^[a-zA-Z0-9_\\.-]+:.*?## / {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}' $(MAKEFILE_LIST)\n\nmodules: ## download the modules for this release\n\trm -fr modules\n\tcurl -L -o modules.tar.gz https://github.com/just-js/modules/archive/$(RELEASE).tar.gz\n\ttar -zxvf modules.tar.gz\n\tmv modules-$(RELEASE) modules\n\trm -f modules.tar.gz\n\nlibs: ## download the libs for this release\n\trm -fr libs-$(RELEASE)\n\tcurl -L -o libs.tar.gz https://github.com/just-js/libs/archive/$(RELEASE).tar.gz\n\ttar -zxvf libs.tar.gz\n\tcp -fr libs-$(RELEASE)/* lib/\n\trm -fr libs-$(RELEASE)\n\trm -f libs.tar.gz\n\nexamples: ## download the examples for this release\n\trm -fr examples\n\tcurl -L -o examples.tar.gz https://github.com/just-js/examples/archive/$(RELEASE).tar.gz\n\ttar -zxvf examples.tar.gz\n\tmv examples-$(RELEASE) examples\n\trm -f examples.tar.gz\n\nv8headers: ## download v8 headers\n\tcurl -L -o v8headers-$(RELEASE).tar.gz https://raw.githubusercontent.com/just-js/v8headers/$(RELEASE)/v8.tar.gz\n\ttar -zxvf v8headers-$(RELEASE).tar.gz\n\trm -f v8headers-$(RELEASE).tar.gz\n\ndeps/v8/libv8_monolith.a: ## download v8 monolithic library for linking\nifeq (,$(wildcard /etc/alpine-release))\n\tcurl -L -o v8lib-$(RELEASE).tar.gz https://raw.githubusercontent.com/just-js/libv8/$(RELEASE)/v8.tar.gz\nelse\n\tcurl -L -o v8lib-$(RELEASE).tar.gz https://raw.githubusercontent.com/just-js/libv8/$(RELEASE)/v8-alpine.tar.gz\nendif\n\ttar -zxvf v8lib-$(RELEASE).tar.gz\n\trm -f v8lib-$(RELEASE).tar.gz\n\nv8src: ## download the full v8 source for this release\n\tcurl -L -o v8src-$(RELEASE).tar.gz https://raw.githubusercontent.com/just-js/v8src/$(RELEASE)/v8src.tar.gz\n\ttar -zxvf v8src-$(RELEASE).tar.gz\n\trm -f v8src-$(RELEASE).tar.gz\n\nmodule: ## build a shared library for a module \n\tCFLAGS=\"$(FLAGS)\" LFLAGS=\"${LFLAG}\" JUST_HOME=\"$(JUST_HOME)\" $(MAKE) -C modules/${MODULE}/ library\n\nmodule-static: ## build a shared library for a module \n\tCFLAGS=\"$(FLAGS)\" LFLAGS=\"${LFLAG}\" JUST_HOME=\"$(JUST_HOME)\" $(MAKE) -C modules/${MODULE}/ FLAGS=-DSTATIC library\n\nbuiltins.o: just.cc just.h Makefile main.cc ## compile builtins with build dependencies\n\tgcc builtins.S -c -o builtins.o\n\ndebugger:\n\tjust build --clean --config debugger.js\n\nmain: modules builtins.o deps/v8/libv8_monolith.a\n\t$(CC) -c ${FLAGS} -DJUST_VERSION='\"${RELEASE}\"' -std=c++17 -DV8_COMPRESS_POINTERS -I. -I./deps/v8/include -g -O3 -march=native -mtune=native -Wpedantic -Wall -Wextra -flto -Wno-unused-parameter just.cc\n\t$(CC) -c ${FLAGS} -std=c++17 -DV8_COMPRESS_POINTERS -I. -I./deps/v8/include -g -O3 -march=native -mtune=native -Wpedantic -Wall -Wextra -flto -Wno-unused-parameter main.cc\n  ifeq (${TARGET}, just)\n\t$(CC) -g -rdynamic -flto -pthread -m64 -Wl,--start-group deps/v8/libv8_monolith.a main.o just.o builtins.o ${MODULES} -Wl,--end-group ${LFLAG} ${LIB} -o ${TARGET} -Wl,-rpath=/usr/local/lib/${TARGET}\n  else\n\t$(CC) -g -rdynamic -flto -pthread -m64 -Wl,--start-group deps/v8/libv8_monolith.a main.o just.o builtins.o ${MODULES} -Wl,--end-group ${LFLAG} ${LIB} -o ${TARGET}\n  endif\n\tobjcopy --only-keep-debug ${TARGET} ${TARGET}.debug\n\tstrip --strip-debug --strip-unneeded ${TARGET}\n\tobjcopy --add-gnu-debuglink=${TARGET}.debug ${TARGET}\n\nmain-static: modules builtins.o deps/v8/libv8_monolith.a\n\t$(CC) -c ${FLAGS} -DJUST_VERSION='\"${RELEASE}\"' -std=c++17 -DV8_COMPRESS_POINTERS -I. -I./deps/v8/include -O3 -march=native -mtune=native -Wpedantic -Wall -Wextra -flto -Wno-unused-parameter just.cc\n\t$(CC) -c ${FLAGS} -std=c++17 -DV8_COMPRESS_POINTERS -I. -I./deps/v8/include -O3 -march=native -mtune=native -Wpedantic -Wall -Wextra -flto -Wno-unused-parameter main.cc\n  ifeq (${TARGET}, just)\n\t$(CC) -g -static -flto -pthread -m64 -Wl,--start-group deps/v8/libv8_monolith.a main.o just.o builtins.o ${MODULES} -Wl,--end-group ${LFLAG} ${LIB} -o ${TARGET} -Wl,-rpath=/usr/local/lib/${TARGET}\n  else\n\t$(CC) -g -static -flto -pthread -m64 -Wl,--start-group deps/v8/libv8_monolith.a main.o just.o builtins.o ${MODULES} -Wl,--end-group ${LFLAG} ${LIB} -o ${TARGET}\n  endif\n\tobjcopy --only-keep-debug ${TARGET} ${TARGET}.debug\n\tstrip --strip-debug --strip-unneeded ${TARGET}\n\tobjcopy --add-gnu-debuglink=${TARGET}.debug ${TARGET}\n\nmodule-net:\n\t$(MAKE) MODULE=net module\n\nmodule-sys:\n\t$(MAKE) MODULE=sys module\n\nmodule-epoll:\n\t$(MAKE) MODULE=epoll module\n\nmodule-vm:\n\t$(MAKE) MODULE=vm module\n\nmodule-fs:\n\t$(MAKE) MODULE=fs module\n\nmodule-static-net:\n\t$(MAKE) MODULE=net module-static\n\nmodule-static-sys:\n\t$(MAKE) MODULE=sys module-static\n\nmodule-static-epoll:\n\t$(MAKE) MODULE=epoll module-static\n\nmodule-static-vm:\n\t$(MAKE) MODULE=vm module-static\n\nmodule-static-fs:\n\t$(MAKE) MODULE=fs module-static\n\nruntime: deps/v8/libv8_monolith.a modules module-vm module-net module-sys module-epoll module-fs\n\t$(MAKE) main\n\nruntime-static: deps/v8/libv8_monolith.a modules module-static-vm module-static-net module-static-sys module-static-epoll module-static-fs\n\t$(MAKE) main-static\n\nclean: ## tidy up\n\trm -f *.o\n\trm -f ${TARGET}\n\ncleanall: ## remove just and build deps\n\trm -fr deps\n\trm -f *.gz\n\trm -fr modules\n\trm -fr libs\n\trm -fr examples\n\t$(MAKE) clean\n\ninstall: ## install\n\tmkdir -p ${INSTALL}\n\tcp -f ${TARGET} ${INSTALL}/${TARGET}\n\ninstall-debug: ## install debug symbols\n\tmkdir -p ${INSTALL}/.debug\n\tcp -f ${TARGET}.debug ${INSTALL}/.debug/${TARGET}.debug\n\nuninstall: ## uninstall\n\trm -f ${INSTALL}/${TARGET}\n\trm -f ${INSTALL}/${TARGET}/.debug\n\n.DEFAULT_GOAL := help\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.8154296875,
          "content": "# Just [![Gitpod ready-to-code](https://img.shields.io/badge/Gitpod-ready--to--code-908a85?logo=gitpod)](https://gitpod.io/#https://github.com/just-js/just)\n\n## *** Attention ***\n\n**17 Nov 2023**\n\nThis project is not being actively maintained in it's current state. please see [lo](https://github.com/just-js/lo) for a new, low-level JavaScript runtime i am working on. Very shortly this should be in a place where I will be able to \"resurrect\" the \"just\" project and base it on lo. Keep an eye out over coming weeks on [twitter](https://twitter.com/justjs14)  or come join us on [discord](https://discord.gg/ZnNsBwaBKr) to discuss the new work. 🙏 🚀\n\n## Build and Run\n\nCurrently working on modern linux (debian/ubuntu and alpine tested) on x86_64\n\n```bash\n# download and run the build script\nsh -c \"$(curl -sSL https://raw.githubusercontent.com/just-js/just/current/install.sh)\"\n# install just binary to /usr/local/bin\nmake -C just install\n# export the just home directory\nexport JUST_HOME=$(pwd)/just\nexport JUST_TARGET=$JUST_HOME\n# if you don't want to install, add JUST_HOME to SPATH\nexport PATH=$PATH:$JUST_HOME\n# run a shell\njust\n```\n\n## Create a new Application\n```bash\n# initialise a new application in the hello directory\njust init hello\ncd hello\n# build hello app\njust build hello.js --clean --static\n./hello\n```\n\n## Command Line Options\n\n### Run a Just shell/repl\n```bash\njust\n```\n\n### Pipe a script to stdin\n```bash\ncat hello.js | just --\n```\n\n### Eval some Javascript passed as an argument\n```bash\njust eval \"just.print(just.memoryUsage().rss)\"\n```\n\n### Run a script\n```bash\njust hello.js\n```\n\n### Initialise a new project and build it\n```bash\njust init hello\ncd hello\njust build\n```\n\n### Clean a built project\n```bash\njust clean\n```\n\n## Documentation\n\nComing soon...\n\n## Philosophy/Goals\n- small, secure, robust and performant js runtime for linux\n- small codebase. easy to understand and hack\n- very simple layer on top of system calls, v8 and c/c++ standard libraries\n- minimal use of classes/function templates and OO - \"c\" in javascript\n- favour return codes over exceptions\n- platform for building system software on linux in javascript\n- as close to native performance as possible\n- secure by default\n- avoid abstraction as much as possible. abstractions can be built in userland\n- commonjs modules, no support for ES modules\n- non-async by default - can do blocking calls and not use the event loop\n- event loop in JS-land. full control over epoll api\n- small standard library - leave as much to userland as possible. focus on primitives needed to build higher level abstractions\n- useful as a teaching/learning platform for linux system programming and learning more about javascript and v8 internals\n- small number of source files\n- minimal dependencies - g++ and make only\n- keep LOC as small as possible < 5k\n- allocate as little as possible on v8 heap\n"
        },
        {
          "name": "VSCode.md",
          "type": "blob",
          "size": 5.869140625,
          "content": "# Prerequisites\n\nThis should work on recent Windows, Linux and Mac. Needs docker and ability to run VSCode\n\n# Install VSCode\n\nhttps://code.visualstudio.com/download\n\n# Install VSCode Remote Containers Extension\n\nhttps://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers\n\n# Clone the just Repo\n\n```\ngit clone git@github.com:just-js/just.git\n```\n\n# Checkout a Specific Branch\n\nmain branch may be broken at any moment in time (until we finalise a better process for release management) so you may want to checkout a specific release tag\n\n```\ncd just\ngit checkout 0.1.2\n```\n\nor to checkout the current release, which should be stable and is just a tag of the current released version\n```\ncd just\ngit checkout current\n```\n\n\n# Start in VSCode\n\n- open the 'just' folder in vscode\n\nyou should be prompted to \"Reopen in Container\". Click that button.\n\n- wait for container to be built and started\n- open a terminal in vscode\n\n# VSCode Terminal Commands\n\n## build the runtime and install it\n\n```\nmake clean runtime\nsudo make install\n```\n\n## build a module\n\n```\nmake MODULE=blake3 module\nsudo make -C modules/blake3 install\n```\n\n## Download Examples\n\n```\nmake examples\n```\n\n## Create a Module\n\n- we'll use modules/fib that comes by default as an example\n- build your module\n\n```\nmake MODULE=fib module\nsudo make -C modules/fib install\n```\n\n# Test Your Module\n\ncreate a script: examples/fib.js\n\n```Javascript\nconst { fib } = just.library('fib')\njust.print('fib: ' + fib.calculate(parseInt(just.args[2] || '1', 10)))\n```\n\nor eval from the shell\n\n```bash\njust eval \"just.print(just.library('fib').fib.calculate(parseInt(just.args[3], 10)))\" 42\n```\n\n# C++ Extension and Intellisense\n\n## Debugging Javascript\n\nThis should now be working. To try it out, follow the instructions to run the HTTP server below but instead run the server with the --inspector flag, e.g.\n```\njust --inspector server.js\n```\n\nYou should then be able to debug from VSCode using this launch configuration:\n```json\n    {\n      \"address\": \"127.0.0.1\",\n      \"localRoot\": \"/workspaces/just\",\n      \"name\": \"Attach to Remote\",\n      \"port\": 9222,\n      \"remoteRoot\": \"/workspaces/just\",\n      \"request\": \"attach\",\n      \"skipFiles\": [\n        \"<node_internals>/**\"\n      ],\n      \"type\": \"pwa-node\"\n    },\n```\n\ngive it a couple of seconds to hook up and you should see \"server.js\" appear in the \"Loaded Scripts\" section. You may need to expand the workspaces to see it.\n\n![Hello World](https://i.ibb.co/854RS8z/debugging.png)\n\n\ndouble-click on server.js to open it in the editor and then you can set breakpoints, step through code etc.\n\n## Debugging C++\n\nhttps://code.visualstudio.com/docs/remote/containers#_debugging-in-a-container\n\n- build the debug version of the runtime\n```\nmake runtime-debug\n```\n\n- build a debug version of your module\n```\nmake MODULE=fib module-debug\n```\n- Install the Microsoft [C/C++ Extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)\n- create a .vscode/launch.json file\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Just Debug! (C++)\",\n      \"type\": \"cppdbg\",\n      \"request\": \"launch\",\n      \"program\": \"${workspaceFolder}/just\",\n      \"args\": [\"fib.js\", \"42\"],\n      \"stopAtEntry\": false,\n      \"additionalSOLibSearchPath\": \"/usr/local/lib/just\",\n      \"cwd\": \"${workspaceFolder}/examples\",\n      \"externalConsole\": false,\n      \"MIMode\": \"gdb\",\n      \"setupCommands\": [\n          {\n              \"description\": \"Enable pretty-printing for gdb\",\n              \"text\": \"-enable-pretty-printing\",\n              \"ignoreFailures\": true\n          }\n      ]\n    }\n\n  ]\n}\n```\n- Set breakpoints in your C++ code\n- Launch \"Just Debug! (C++)\"\n- Add the following to your .vscode/settings.json for code browsing\n```json\n{\n  \"C_Cpp.default.defines\": [\"V8_TARGET_ARCH_X64\"],\n  \"C_Cpp.default.includePath\": [\n      \"${workspaceFolder}\",\n      \"${workspaceFolder}/deps/v8/include\",\n      \"${workspaceFolder}/deps/v8/src\",\n      \"${workspaceFolder}/deps/v8/gen\",\n      \"${workspaceFolder}/deps/v8\",\n      \"${workspaceFolder}/modules/blake3\",\n      \"${workspaceFolder}/modules/ffi\",\n      \"${workspaceFolder}/modules/fib\",\n      \"${workspaceFolder}/modules/html\",\n      \"${workspaceFolder}/modules/openssl\",\n      \"${workspaceFolder}/modules/openssl/deps/openssl-OpenSSL_1_1_1d/include\",\n      \"${workspaceFolder}/modules/pg\",\n      \"${workspaceFolder}/modules/pg/deps/postgresql-12.3/src/include\",\n      \"${workspaceFolder}/modules/pg/deps/postgresql-12.3/src\",\n      \"${workspaceFolder}/modules/pg/deps/postgresql-12.3/src/interfaces/libpq\",\n      \"${workspaceFolder}/modules/picohttp\",\n      \"${workspaceFolder}/modules/rocksdb\",\n      \"${workspaceFolder}/modules/rocksdb/deps/rocksdb-6.10.2/include\",\n      \"${workspaceFolder}/modules/tcc\",\n      \"${workspaceFolder}/modules/tcc/deps/tcc-0.9.27\",\n      \"${workspaceFolder}/modules/zlib/deps/zlib-1.2.11\",\n      \"${workspaceFolder}/modules/zlib\"\n  ],\n  \"C_Cpp.default.cppStandard\": \"c++11\"\n}\n```\n\n## C++ Intellisense/Code Browsing\n\n- Install the Microsoft C/C++ Extension below\n- Download the full v8 source of the release Just(js) was built with so you can drill down to the v8 code if you need to\n\n```\nmake v8src\n```\n\n## Useful Extensions\n\n- StandardJS: https://marketplace.visualstudio.com/items?itemName=chenxsan.vscode-standardjs. Add the following to your .vscode/settings.json:\n```json\n  \"standard.enable\": true,\n  \"standard.options\": {\n      \"globals\": [\"just\", \"BigInt\", \"BigUint64Array\", \"Atomics\", \"WebAssembly\", \"SharedArrayBuffer\"]\n  },\n```\n- Microsoft C/C++ Extension: https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\n\n## HTTP Server Example\n\nRun the server. It listens on 127.0.0.1:3000\n\n```\nmake runtime\nsudo make install\nmake MODULE=http module\nsudo make -C modules/http install\nmake examples\ncd examples/http\njust server.js\n```\n\nTest the Server\n\n```\ncurl -vvv http://127.0.0.1:3000/\ncurl -vvv http://127.0.0.1:3000/json\ncurl -vvv http://127.0.0.1:3000/async\n```"
        },
        {
          "name": "builtins.S",
          "type": "blob",
          "size": 2.41796875,
          "content": ".global _binary_lib_fs_js_start\n_binary_lib_fs_js_start:\n        .incbin \"lib/fs.js\"\n        .global _binary_lib_fs_js_end\n_binary_lib_fs_js_end:\n.global _binary_lib_loop_js_start\n_binary_lib_loop_js_start:\n        .incbin \"lib/loop.js\"\n        .global _binary_lib_loop_js_end\n_binary_lib_loop_js_end:\n.global _binary_lib_path_js_start\n_binary_lib_path_js_start:\n        .incbin \"lib/path.js\"\n        .global _binary_lib_path_js_end\n_binary_lib_path_js_end:\n.global _binary_lib_process_js_start\n_binary_lib_process_js_start:\n        .incbin \"lib/process.js\"\n        .global _binary_lib_process_js_end\n_binary_lib_process_js_end:\n.global _binary_lib_build_js_start\n_binary_lib_build_js_start:\n        .incbin \"lib/build.js\"\n        .global _binary_lib_build_js_end\n_binary_lib_build_js_end:\n.global _binary_lib_repl_js_start\n_binary_lib_repl_js_start:\n        .incbin \"lib/repl.js\"\n        .global _binary_lib_repl_js_end\n_binary_lib_repl_js_end:\n.global _binary_lib_configure_js_start\n_binary_lib_configure_js_start:\n        .incbin \"lib/configure.js\"\n        .global _binary_lib_configure_js_end\n_binary_lib_configure_js_end:\n.global _binary_lib_acorn_js_start\n_binary_lib_acorn_js_start:\n        .incbin \"lib/acorn.js\"\n        .global _binary_lib_acorn_js_end\n_binary_lib_acorn_js_end:\n.global _binary_just_cc_start\n_binary_just_cc_start:\n        .incbin \"just.cc\"\n        .global _binary_just_cc_end\n_binary_just_cc_end:\n.global _binary_Makefile_start\n_binary_Makefile_start:\n        .incbin \"Makefile\"\n        .global _binary_Makefile_end\n_binary_Makefile_end:\n.global _binary_main_cc_start\n_binary_main_cc_start:\n        .incbin \"main.cc\"\n        .global _binary_main_cc_end\n_binary_main_cc_end:\n.global _binary_just_h_start\n_binary_just_h_start:\n        .incbin \"just.h\"\n        .global _binary_just_h_end\n_binary_just_h_end:\n.global _binary_just_js_start\n_binary_just_js_start:\n        .incbin \"just.js\"\n        .global _binary_just_js_end\n_binary_just_js_end:\n.global _binary_lib_inspector_js_start\n_binary_lib_inspector_js_start:\n        .incbin \"lib/inspector.js\"\n        .global _binary_lib_inspector_js_end\n_binary_lib_inspector_js_end:\n.global _binary_lib_websocket_js_start\n_binary_lib_websocket_js_start:\n        .incbin \"lib/websocket.js\"\n        .global _binary_lib_websocket_js_end\n_binary_lib_websocket_js_end:\n.global _binary_config_js_start\n_binary_config_js_start:\n        .incbin \"config.js\"\n        .global _binary_config_js_end\n_binary_config_js_end:\n"
        },
        {
          "name": "config.js",
          "type": "blob",
          "size": 1.048828125,
          "content": "const libs = [\n  'lib/fs.js',\n  'lib/loop.js',\n  'lib/path.js',\n  'lib/process.js',\n  'lib/build.js',\n  'lib/repl.js',\n  'lib/configure.js',\n  'lib/acorn.js'\n]\n\nconst version = just.version.just\nconst v8flags = '--stack-trace-limit=10 --use-strict --disallow-code-generation-from-strings'\nconst v8flagsFromCommandLine = true\nconst debug = false\nconst capabilities = [] // list of allowed internal modules, api calls etc. TBD\n\nconst modules = [{\n  name: 'sys',\n  obj: [\n    'modules/sys/sys.o'\n  ],\n  lib: ['dl', 'rt']\n}, {\n  name: 'fs',\n  obj: [\n    'modules/fs/fs.o'\n  ]\n}, {\n  name: 'net',\n  obj: [\n    'modules/net/net.o'\n  ]\n}, {\n  name: 'vm',\n  obj: [\n    'modules/vm/vm.o'\n  ]\n}, {\n  name: 'epoll',\n  obj: [\n    'modules/epoll/epoll.o'\n  ]\n}]\n\nconst embeds = [\n  'just.cc',\n  'Makefile',\n  'main.cc',\n  'just.h',\n  'just.js',\n  'config.js',\n  'lib/websocket.js',\n  'lib/inspector.js'\n]\n\nconst target = 'just'\nconst main = 'just.js'\n\nmodule.exports = { version, libs, modules, capabilities, target, main, v8flags, embeds, static: false, debug, v8flagsFromCommandLine }\n"
        },
        {
          "name": "debugger.js",
          "type": "blob",
          "size": 1.28125,
          "content": "const libs = [\n  'lib/fs.js',\n  'lib/loop.js',\n  'lib/path.js',\n  'lib/process.js',\n  'lib/build.js',\n  'lib/repl.js',\n  'lib/configure.js',\n  'lib/acorn.js',\n  'lib/websocket.js',\n  'lib/inspector.js'\n]\n\nconst version = just.version.just\nconst v8flags = '--stack-trace-limit=10 --use-strict --disallow-code-generation-from-strings'\nconst debug = false\nconst capabilities = [] // list of allowed internal modules, api calls etc. TBD\n\nconst modules = [{\n  name: 'sys',\n  obj: [\n    'modules/sys/sys.o'\n  ],\n  lib: ['dl', 'rt']\n}, {\n  name: 'sha1',\n  obj: [\n    'modules/sha1/sha1.o'\n  ]\n}, {\n  name: 'encode',\n  obj: [\n    'modules/encode/encode.o'\n  ]\n}, {\n  name: 'fs',\n  obj: [\n    'modules/fs/fs.o'\n  ]\n}, {\n  name: 'inspector',\n  obj: [\n    'modules/inspector/inspector.o'\n  ]\n}, {\n  name: 'net',\n  obj: [\n    'modules/net/net.o'\n  ]\n}, {\n  name: 'http',\n  obj: [\n    'modules/http/http.o',\n    'modules/http/picohttpparser.o'\n  ]\n}, {\n  name: 'vm',\n  obj: [\n    'modules/vm/vm.o'\n  ]\n}, {\n  name: 'epoll',\n  obj: [\n    'modules/epoll/epoll.o'\n  ]\n}]\n\nconst embeds = [\n  'just.cc',\n  'Makefile',\n  'main.cc',\n  'just.h',\n  'just.js',\n  'config.js'\n]\n\nconst target = 'just'\nconst main = 'just.js'\n\nmodule.exports = { version, libs, modules, capabilities, target, main, v8flags, embeds, static: false, debug }\n"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 0.1796875,
          "content": "#!/bin/sh\ncurl -L -o just.tar.gz https://github.com/just-js/just/archive/current.tar.gz\nmkdir -p just && tar -zxvf just.tar.gz -C just --strip-components 1\nmake -C just runtime-static\n"
        },
        {
          "name": "just.cc",
          "type": "blob",
          "size": 22.126953125,
          "content": "#include \"just.h\"\n\nstd::map<std::string, just::builtin*> just::builtins;\nstd::map<std::string, just::register_plugin> just::modules;\nuint32_t scriptId = 1;\nuint64_t* hrtimeptr;\nclock_t clock_id = CLOCK_MONOTONIC;\n\nssize_t just::process_memory_usage() {\n  char buf[1024];\n  const char* s = NULL;\n  ssize_t n = 0;\n  unsigned long val = 0;\n  int fd = 0;\n  int i = 0;\n  do {\n    fd = open(\"/proc/thread-self/stat\", O_RDONLY);\n  } while (fd == -1 && errno == EINTR);\n  if (fd == -1) return (ssize_t)errno;\n  do\n    n = read(fd, buf, sizeof(buf) - 1);\n  while (n == -1 && errno == EINTR);\n  close(fd);\n  if (n == -1)\n    return (ssize_t)errno;\n  buf[n] = '\\0';\n  s = strchr(buf, ' ');\n  if (s == NULL)\n    goto err;\n  s += 1;\n  if (*s != '(')\n    goto err;\n  s = strchr(s, ')');\n  if (s == NULL)\n    goto err;\n  for (i = 1; i <= 22; i++) {\n    s = strchr(s + 1, ' ');\n    if (s == NULL)\n      goto err;\n  }\n  errno = 0;\n  val = strtoul(s, NULL, 10);\n  if (errno != 0)\n    goto err;\n  return val * (unsigned long)getpagesize();\nerr:\n  return 0;\n}\n\nuint64_t just::hrtime() {\n  struct timespec t;\n  if (clock_gettime(clock_id, &t)) return 0;\n  return (t.tv_sec * (uint64_t) 1e9) + t.tv_nsec;\n}\n\nvoid just::builtins_add (const char* name, const char* source, \n  unsigned int size) {\n  struct builtin* b = new builtin();\n  b->size = size;\n  b->source = source;\n  builtins[name] = b;\n}\n\nvoid just::SET_METHOD(Isolate *isolate, Local<ObjectTemplate> \n  recv, const char *name, FunctionCallback callback) {\n  recv->Set(String::NewFromUtf8(isolate, name, \n    NewStringType::kInternalized).ToLocalChecked(), \n    FunctionTemplate::New(isolate, callback));\n}\n\nvoid just::SET_MODULE(Isolate *isolate, Local<ObjectTemplate> \n  recv, const char *name, Local<ObjectTemplate> module) {\n  recv->Set(String::NewFromUtf8(isolate, name, \n    NewStringType::kInternalized).ToLocalChecked(), \n    module);\n}\n\nvoid just::SET_VALUE(Isolate *isolate, Local<ObjectTemplate> \n  recv, const char *name, Local<Value> value) {\n  recv->Set(String::NewFromUtf8(isolate, name, \n    NewStringType::kInternalized).ToLocalChecked(), \n    value);\n}\n\nvoid just::PrintStackTrace(Isolate* isolate, const TryCatch& try_catch) {\n  HandleScope handleScope(isolate);\n  Local<Message> message = try_catch.Message();\n  Local<StackTrace> stack = message->GetStackTrace();\n  Local<Value> scriptName = message->GetScriptResourceName();\n  String::Utf8Value scriptname(isolate, scriptName);\n  Local<Context> context = isolate->GetCurrentContext();\n  int linenum = message->GetLineNumber(context).FromJust();\n  v8::String::Utf8Value err_message(isolate, message->Get().As<String>());\n  fprintf(stderr, \"%s in %s on line %i\\n\", *err_message, *scriptname, linenum);\n  if (stack.IsEmpty()) return;\n  for (int i = 0; i < stack->GetFrameCount(); i++) {\n    Local<StackFrame> stack_frame = stack->GetFrame(isolate, i);\n    Local<String> functionName = stack_frame->GetFunctionName();\n    Local<String> scriptName = stack_frame->GetScriptName();\n    String::Utf8Value fn_name_s(isolate, functionName);\n    String::Utf8Value script_name(isolate, scriptName);\n    const int line_number = stack_frame->GetLineNumber();\n    const int column = stack_frame->GetColumn();\n    if (stack_frame->IsEval()) {\n      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {\n        fprintf(stderr, \"    at [eval]:%i:%i\\n\", line_number, column);\n      } else {\n        fprintf(stderr, \"    at [eval] (%s:%i:%i)\\n\", *script_name,\n          line_number, column);\n      }\n      break;\n    }\n    if (fn_name_s.length() == 0) {\n      fprintf(stderr, \"    at %s:%i:%i\\n\", *script_name, line_number, column);\n    } else {\n      fprintf(stderr, \"    at %s (%s:%i:%i)\\n\", *fn_name_s, *script_name,\n        line_number, column);\n    }\n  }\n  fflush(stderr);\n}\n\nvoid just::PromiseRejectCallback(PromiseRejectMessage data) {\n  if (data.GetEvent() == v8::kPromiseRejectAfterResolved ||\n      data.GetEvent() == v8::kPromiseResolveAfterResolved) {\n    // Ignore reject/resolve after resolved.\n    return;\n  }\n  Local<Promise> promise = data.GetPromise();\n  Isolate* isolate = promise->GetIsolate();\n  if (data.GetEvent() == v8::kPromiseHandlerAddedAfterReject) {\n    return;\n  }\n  Local<Value> exception = data.GetValue();\n  v8::Local<Message> message;\n  // Assume that all objects are stack-traces.\n  if (exception->IsObject()) {\n    message = v8::Exception::CreateMessage(isolate, exception);\n  }\n  if (!exception->IsNativeError() &&\n      (message.IsEmpty() || message->GetStackTrace().IsEmpty())) {\n    // If there is no real Error object, manually create a stack trace.\n    exception = v8::Exception::Error(\n        v8::String::NewFromUtf8Literal(isolate, \"Unhandled Promise.\"));\n    message = Exception::CreateMessage(isolate, exception);\n  }\n  Local<Context> context = isolate->GetCurrentContext();\n  TryCatch try_catch(isolate);\n  Local<Object> globalInstance = context->Global();\n  Local<Value> func = globalInstance->Get(context, \n    String::NewFromUtf8Literal(isolate, \"onUnhandledRejection\", \n      NewStringType::kNormal)).ToLocalChecked();\n  if (func.IsEmpty()) {\n    return;\n  }\n  Local<Function> onUnhandledRejection = Local<Function>::Cast(func);\n  if (try_catch.HasCaught()) {\n    fprintf(stderr, \"PromiseRejectCallback: Cast\\n\");\n    return;\n  }\n  Local<Value> argv[1] = { exception };\n  MaybeLocal<Value> result = onUnhandledRejection->Call(context, \n    globalInstance, 1, argv);\n  if (result.IsEmpty() && try_catch.HasCaught()) {\n    fprintf(stderr, \"PromiseRejectCallback: Call\\n\");\n  }\n}\n\nvoid just::FreeMemory(void* buf, size_t length, void* data) {\n  free(buf);\n}\n\nchar* readFile(char filename[]) {\n  std::ifstream file;\n  file.open(filename, std::ifstream::ate);\n  char* contents;\n  if (!file) {\n    contents = new char[1];\n    return contents;\n  }\n  size_t file_size = file.tellg();\n  file.seekg(0);\n  std::filebuf* file_buf = file.rdbuf();\n  contents = new char[file_size + 1]();\n  file_buf->sgetn(contents, file_size);\n  file.close();\n  return contents;\n}\n\nv8::MaybeLocal<v8::Module> loadModule(char code[],\n                                      char name[],\n                                      v8::Local<v8::Context> cx) {\n  v8::Local<v8::String> vcode =\n      v8::String::NewFromUtf8(cx->GetIsolate(), code).ToLocalChecked();\n  v8::Local<v8::PrimitiveArray> opts =\n      v8::PrimitiveArray::New(cx->GetIsolate(), just::HostDefinedOptions::kLength);\n  opts->Set(cx->GetIsolate(), just::HostDefinedOptions::kType,\n                            v8::Number::New(cx->GetIsolate(), just::ScriptType::kModule));\n  v8::ScriptOrigin origin(cx->GetIsolate(), v8::String::NewFromUtf8(cx->GetIsolate(), name).ToLocalChecked(), // resource name\n    0, // line offset\n    0,  // column offset\n    true, // is shared cross-origin\n    -1,  // script id\n    v8::Local<v8::Value>(), // source map url\n    false, // is opaque\n    false, // is wasm\n    true, // is module\n    opts);\n  v8::Context::Scope context_scope(cx);\n  v8::ScriptCompiler::Source source(vcode, origin);\n  v8::MaybeLocal<v8::Module> mod;\n  mod = v8::ScriptCompiler::CompileModule(cx->GetIsolate(), &source);\n  return mod;\n}\n\n// lifted from here: https://gist.github.com/surusek/4c05e4dcac6b82d18a1a28e6742fc23e\nv8::MaybeLocal<v8::Module> just::OnModuleInstantiate(v8::Local<v8::Context> context,\n                                       v8::Local<v8::String> specifier,\n                                       v8::Local<v8::FixedArray> import_assertions, \n                                       v8::Local<v8::Module> referrer) {\n  v8::String::Utf8Value str(context->GetIsolate(), specifier);\n  return loadModule(readFile(*str), *str, context);\n}\n\nv8::Local<v8::Module> checkModule(v8::MaybeLocal<v8::Module> maybeModule,\n                                  v8::Local<v8::Context> cx) {\n  v8::Local<v8::Module> mod;\n  if (!maybeModule.ToLocal(&mod)) {\n    printf(\"Error loading module!\\n\");\n    exit(EXIT_FAILURE);\n  }\n  v8::Maybe<bool> result = mod->InstantiateModule(cx, just::OnModuleInstantiate);\n  if (result.IsNothing()) {\n    printf(\"\\nCan't instantiate module.\\n\");\n    exit(EXIT_FAILURE);\n  }\n  return mod;\n}\n\nv8::Local<v8::Value> execModule(v8::Local<v8::Module> mod,\n                                v8::Local<v8::Context> cx,\n                                bool nsObject) {\n  v8::Local<v8::Value> retValue;\n  if (!mod->Evaluate(cx).ToLocal(&retValue)) {\n    printf(\"Error evaluating module!\\n\");\n    exit(EXIT_FAILURE);\n  }\n  if (nsObject)\n    return mod->GetModuleNamespace();\n  else\n    return retValue;\n}\n\nv8::MaybeLocal<v8::Promise> OnDynamicImport(v8::Local<v8::Context> context,\n  v8::Local<v8::Data> host_defined_options,\n  v8::Local<v8::Value> resource_name,\n  v8::Local<v8::String> specifier,\n  v8::Local<v8::FixedArray> import_assertions) {\n  v8::Local<v8::Promise::Resolver> resolver =\n      v8::Promise::Resolver::New(context).ToLocalChecked();\n  v8::MaybeLocal<v8::Promise> promise(resolver->GetPromise());\n  v8::String::Utf8Value name(context->GetIsolate(), specifier);\n  v8::Local<v8::Module> mod =\n      checkModule(loadModule(readFile(*name), *name, context), context);\n  v8::Local<v8::Value> retValue = execModule(mod, context, true);\n  resolver->Resolve(context, retValue).ToChecked();\n  return promise;\n}\n\nint just::CreateIsolate(int argc, char** argv, \n  const char* main_src, unsigned int main_len, \n  const char* js, unsigned int js_len, struct iovec* buf, int fd,\n  uint64_t start) {\n  Isolate::CreateParams create_params;\n  int statusCode = 0;\n  create_params.array_buffer_allocator = \n    ArrayBuffer::Allocator::NewDefaultAllocator();\n  Isolate *isolate = Isolate::New(create_params);\n  {\n    Isolate::Scope isolate_scope(isolate);\n    HandleScope handle_scope(isolate);\n    // TODO: make this a config option\n    isolate->SetCaptureStackTraceForUncaughtExceptions(true, 1000, \n      StackTrace::kDetailed);\n    Local<ObjectTemplate> global = ObjectTemplate::New(isolate);\n    Local<ObjectTemplate> just = ObjectTemplate::New(isolate);\n    just::Init(isolate, just);\n    global->Set(String::NewFromUtf8Literal(isolate, \"just\", \n      NewStringType::kNormal), just);\n    Local<Context> context = Context::New(isolate, NULL, global);\n    Context::Scope context_scope(context);\n    isolate->SetPromiseRejectCallback(PromiseRejectCallback);\n    isolate->SetHostImportModuleDynamicallyCallback(OnDynamicImport);\n    Local<Array> arguments = Array::New(isolate);\n    for (int i = 0; i < argc; i++) {\n      arguments->Set(context, i, String::NewFromUtf8(isolate, argv[i], \n        NewStringType::kNormal, strlen(argv[i])).ToLocalChecked()).Check();\n    }\n    Local<Object> globalInstance = context->Global();\n    globalInstance->Set(context, String::NewFromUtf8Literal(isolate, \n      \"global\", \n      NewStringType::kNormal), globalInstance).Check();\n    Local<Value> obj = globalInstance->Get(context, \n      String::NewFromUtf8Literal(\n        isolate, \"just\", \n        NewStringType::kNormal)).ToLocalChecked();\n    Local<Object> justInstance = Local<Object>::Cast(obj);\n    if (buf != NULL) {\n      std::unique_ptr<BackingStore> backing = SharedArrayBuffer::NewBackingStore(\n          buf->iov_base, buf->iov_len, [](void*, size_t, void*){}, nullptr);\n      Local<SharedArrayBuffer> ab = SharedArrayBuffer::New(isolate, std::move(backing));\n      justInstance->Set(context, String::NewFromUtf8Literal(isolate, \n        \"buffer\", NewStringType::kNormal), ab).Check();\n    }\n    if (start > 0) {\n      justInstance->Set(context, String::NewFromUtf8Literal(isolate, \"start\", \n        NewStringType::kNormal), \n        BigInt::New(isolate, start)).Check();\n    }\n    if (fd != 0) {\n      justInstance->Set(context, String::NewFromUtf8Literal(isolate, \"fd\", \n        NewStringType::kNormal), \n        Integer::New(isolate, fd)).Check();\n    }\n    justInstance->Set(context, String::NewFromUtf8Literal(isolate, \"args\", \n      NewStringType::kNormal), arguments).Check();\n    if (js_len > 0) {\n      justInstance->Set(context, String::NewFromUtf8Literal(isolate, \n        \"workerSource\", NewStringType::kNormal), \n        String::NewFromUtf8(isolate, js, NewStringType::kNormal, \n        js_len).ToLocalChecked()).Check();\n    }\n    TryCatch try_catch(isolate);\n\n    Local<v8::PrimitiveArray> opts =\n        v8::PrimitiveArray::New(isolate, just::HostDefinedOptions::kLength);\n    opts->Set(isolate, just::HostDefinedOptions::kType, \n      v8::Number::New(isolate, just::ScriptType::kModule));\n    ScriptOrigin baseorigin(\n      isolate,\n      String::NewFromUtf8Literal(isolate, \"just.js\", \n      NewStringType::kInternalized), // resource name\n      0, // line offset\n      0,  // column offset\n      false, // is shared cross-origin\n      scriptId++,  // script id\n      Local<Value>(), // source map url\n      false, // is opaque\n      false, // is wasm\n      true,  // is module\n      opts\n    );\n    Local<String> base;\n    base = String::NewFromUtf8(isolate, main_src, NewStringType::kNormal, \n      main_len).ToLocalChecked();\n    ScriptCompiler::Source basescript(base, baseorigin);\n    Local<Module> module;\n    if (!ScriptCompiler::CompileModule(isolate, &basescript).ToLocal(&module)) {\n      PrintStackTrace(isolate, try_catch);\n      return 1;\n    }\n    Maybe<bool> ok2 = module->InstantiateModule(context, just::OnModuleInstantiate);\n    if (ok2.IsNothing()) {\n      if (try_catch.HasCaught() && !try_catch.HasTerminated()) {\n        try_catch.ReThrow();\n      }\n      return 1;\n    }\n    module->Evaluate(context).ToLocalChecked();\n    if (try_catch.HasCaught() && !try_catch.HasTerminated()) {\n      try_catch.ReThrow();\n      return 1;\n    }\n    Local<Value> func = globalInstance->Get(context, \n      String::NewFromUtf8Literal(isolate, \"onExit\", \n        NewStringType::kNormal)).ToLocalChecked();\n    if (func->IsFunction()) {\n      Local<Function> onExit = Local<Function>::Cast(func);\n      Local<Value> argv[1] = {Integer::New(isolate, 0)};\n      MaybeLocal<Value> result = onExit->Call(context, globalInstance, 0, argv);\n      if (!result.IsEmpty()) {\n        statusCode = result.ToLocalChecked()->Uint32Value(context).ToChecked();\n      }\n      if (try_catch.HasCaught() && !try_catch.HasTerminated()) {\n        just::PrintStackTrace(isolate, try_catch);\n        return 2;\n      }\n      statusCode = result.ToLocalChecked()->Uint32Value(context).ToChecked();\n    }\n  }\n  isolate->ContextDisposedNotification();\n  isolate->LowMemoryNotification();\n  isolate->ClearKeptObjects();\n  bool stop = false;\n  while(!stop) {\n    stop = isolate->IdleNotificationDeadline(1);  \n  }\n  isolate->Dispose();\n  delete create_params.array_buffer_allocator;\n  isolate = nullptr;\n  return statusCode;\n}\n\nint just::CreateIsolate(int argc, char** argv, const char* main_src, \n  unsigned int main_len, uint64_t start) {\n  return CreateIsolate(argc, argv, main_src, main_len, NULL, 0, NULL, 0, start);\n}\n\nvoid just::Print(const FunctionCallbackInfo<Value> &args) {\n  Isolate *isolate = args.GetIsolate();\n  if (args[0].IsEmpty()) return;\n  String::Utf8Value str(args.GetIsolate(), args[0]);\n  int endline = 1;\n  if (args.Length() > 1) {\n    endline = static_cast<int>(args[1]->BooleanValue(isolate));\n  }\n  const char *cstr = *str;\n  if (endline == 1) {\n    fprintf(stdout, \"%s\\n\", cstr);\n  } else {\n    fprintf(stdout, \"%s\", cstr);\n  }\n}\n\nvoid just::Error(const FunctionCallbackInfo<Value> &args) {\n  Isolate *isolate = args.GetIsolate();\n  if (args[0].IsEmpty()) return;\n  String::Utf8Value str(args.GetIsolate(), args[0]);\n  int endline = 1;\n  if (args.Length() > 1) {\n    endline = static_cast<int>(args[1]->BooleanValue(isolate));\n  }\n  const char *cstr = *str;\n  if (endline == 1) {\n    fprintf(stderr, \"%s\\n\", cstr);\n  } else {\n    fprintf(stderr, \"%s\", cstr);\n  }\n}\n\nvoid just::Load(const FunctionCallbackInfo<Value> &args) {\n  Isolate *isolate = args.GetIsolate();\n  Local<Context> context = isolate->GetCurrentContext();\n  Local<ObjectTemplate> exports = ObjectTemplate::New(isolate);\n  if (args[0]->IsString()) {\n    String::Utf8Value name(isolate, args[0]);\n    auto iter = just::modules.find(*name);\n    if (iter == just::modules.end()) {\n      return;\n    } else {\n      register_plugin _init = (*iter->second);\n      auto _register = reinterpret_cast<InitializerCallback>(_init());\n      _register(isolate, exports);\n    }\n  } else {\n    Local<BigInt> address64 = Local<BigInt>::Cast(args[0]);\n    void* ptr = reinterpret_cast<void*>(address64->Uint64Value());\n    register_plugin _init = reinterpret_cast<register_plugin>(ptr);\n    auto _register = reinterpret_cast<InitializerCallback>(_init());\n    _register(isolate, exports);\n  }\n  args.GetReturnValue().Set(exports->NewInstance(context).ToLocalChecked());\n}\n\nvoid just::Builtin(const FunctionCallbackInfo<Value> &args) {\n  Isolate *isolate = args.GetIsolate();\n  String::Utf8Value name(isolate, args[0]);\n  just::builtin* b = builtins[*name];\n  if (b == nullptr) {\n    args.GetReturnValue().Set(Null(isolate));\n    return;\n  }\n  if (args.Length() == 1) {\n    args.GetReturnValue().Set(String::NewFromUtf8(isolate, b->source, \n      NewStringType::kNormal, b->size).ToLocalChecked());\n    return;\n  }\n\n  std::unique_ptr<BackingStore> backing = SharedArrayBuffer::NewBackingStore(\n      (void*)b->source, b->size, [](void*, size_t, void*){}, nullptr);\n  Local<SharedArrayBuffer> ab = SharedArrayBuffer::New(isolate, std::move(backing));\n\n  //Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, (void*)b->source, b->size, v8::ArrayBufferCreationMode::kExternalized);\n  args.GetReturnValue().Set(ab);\n}\n\nvoid just::MemoryUsage(const FunctionCallbackInfo<Value> &args) {\n  Isolate *isolate = args.GetIsolate();\n  ssize_t rss = just::process_memory_usage();\n  HeapStatistics v8_heap_stats;\n  isolate->GetHeapStatistics(&v8_heap_stats);\n  Local<BigUint64Array> array;\n  Local<ArrayBuffer> ab;\n  if (args.Length() > 0) {\n    array = args[0].As<BigUint64Array>();\n    ab = array->Buffer();\n  } else {\n    ab = ArrayBuffer::New(isolate, 16 * 8);\n    array = BigUint64Array::New(ab, 0, 16);\n  }\n  std::shared_ptr<BackingStore> backing = ab->GetBackingStore();\n  uint64_t *fields = static_cast<uint64_t *>(backing->Data());\n  fields[0] = rss;\n  fields[1] = v8_heap_stats.total_heap_size();\n  fields[2] = v8_heap_stats.used_heap_size();\n  fields[3] = v8_heap_stats.external_memory();\n  fields[4] = v8_heap_stats.does_zap_garbage();\n  fields[5] = v8_heap_stats.heap_size_limit();\n  fields[6] = v8_heap_stats.malloced_memory();\n  fields[7] = v8_heap_stats.number_of_detached_contexts();\n  fields[8] = v8_heap_stats.number_of_native_contexts();\n  fields[9] = v8_heap_stats.peak_malloced_memory();\n  fields[10] = v8_heap_stats.total_available_size();\n  fields[11] = v8_heap_stats.total_heap_size_executable();\n  fields[12] = v8_heap_stats.total_physical_size();\n  fields[13] = isolate->AdjustAmountOfExternalAllocatedMemory(0);\n  args.GetReturnValue().Set(array);\n}\n\nvoid just::Sleep(const FunctionCallbackInfo<Value> &args) {\n  sleep(Local<Integer>::Cast(args[0])->Value());\n}\n\nvoid just::Exit(const FunctionCallbackInfo<Value>& args) {\n  exit(Local<Integer>::Cast(args[0])->Value());\n}\n\nvoid just::PID(const FunctionCallbackInfo<Value> &args) {\n  args.GetReturnValue().Set(Integer::New(args.GetIsolate(), getpid()));\n}\n\nvoid just::Chdir(const FunctionCallbackInfo<Value> &args) {\n  Isolate *isolate = args.GetIsolate();\n  String::Utf8Value path(isolate, args[0]);\n  args.GetReturnValue().Set(Integer::New(isolate, chdir(*path)));\n}\n\nvoid just::Builtins(const FunctionCallbackInfo<Value> &args) {\n  Isolate *isolate = args.GetIsolate();\n  Local<Context> context = isolate->GetCurrentContext();\n  Local<Array> b = Array::New(isolate);\n  int i = 0;\n  for (auto const& builtin : builtins) {\n    b->Set(context, i++, String::NewFromUtf8(isolate, builtin.first.c_str(), \n      NewStringType::kNormal, builtin.first.length()).ToLocalChecked()).Check();\n  }\n  args.GetReturnValue().Set(b);\n}\n\nvoid just::Modules(const FunctionCallbackInfo<Value> &args) {\n  Isolate *isolate = args.GetIsolate();\n  Local<Context> context = isolate->GetCurrentContext();\n  Local<Array> m = Array::New(isolate);\n  int i = 0;\n  for (auto const& module : modules) {\n    m->Set(context, i++, String::NewFromUtf8(isolate, module.first.c_str(), \n      NewStringType::kNormal, module.first.length()).ToLocalChecked()).Check();\n  }\n  args.GetReturnValue().Set(m);\n}\n\nvoid just::HRTime(const FunctionCallbackInfo<Value> &args) {\n  if (hrtimeptr != NULL) {\n    *hrtimeptr = just::hrtime();\n    return;\n  }\n  Isolate *isolate = args.GetIsolate();\n  Local<BigUint64Array> array;\n  Local<ArrayBuffer> ab;\n  if (args.Length() > 0) {\n    array = args[0].As<BigUint64Array>();\n    ab = array->Buffer();\n  } else {\n    ab = ArrayBuffer::New(isolate, 8);\n    array = BigUint64Array::New(ab, 0, 1);\n    args.GetReturnValue().Set(array);\n  }\n  hrtimeptr = (uint64_t*)ab->GetBackingStore()->Data();\n  *hrtimeptr = just::hrtime();\n}\n\nvoid just::Init(Isolate* isolate, Local<ObjectTemplate> target) {\n  Local<ObjectTemplate> version = ObjectTemplate::New(isolate);\n  SET_VALUE(isolate, version, \"just\", String::NewFromUtf8Literal(isolate, \n    JUST_VERSION));\n  SET_VALUE(isolate, version, \"v8\", String::NewFromUtf8(isolate, \n    v8::V8::GetVersion()).ToLocalChecked());\n  Local<ObjectTemplate> kernel = ObjectTemplate::New(isolate);\n  utsname kernel_rec;\n  int rc = uname(&kernel_rec);\n  if (rc == 0) {\n    kernel->Set(String::NewFromUtf8Literal(isolate, \"os\", \n      NewStringType::kNormal), String::NewFromUtf8(isolate, \n      kernel_rec.sysname).ToLocalChecked());\n    kernel->Set(String::NewFromUtf8Literal(isolate, \"release\", \n      NewStringType::kNormal), String::NewFromUtf8(isolate, \n      kernel_rec.release).ToLocalChecked());\n    kernel->Set(String::NewFromUtf8Literal(isolate, \"version\", \n      NewStringType::kNormal), String::NewFromUtf8(isolate, \n      kernel_rec.version).ToLocalChecked());\n  }\n  version->Set(String::NewFromUtf8Literal(isolate, \"kernel\", \n    NewStringType::kNormal), kernel);\n  SET_METHOD(isolate, target, \"print\", Print);\n  SET_METHOD(isolate, target, \"error\", Error);\n \n  // TODO: move these four to sys library\n  SET_METHOD(isolate, target, \"exit\", Exit);\n  SET_METHOD(isolate, target, \"pid\", PID);\n  SET_METHOD(isolate, target, \"chdir\", Chdir);\n  SET_METHOD(isolate, target, \"sleep\", Sleep);\n  SET_METHOD(isolate, target, \"hrtime\", HRTime);\n\n  SET_MODULE(isolate, target, \"version\", version);\n  // TODO: move this to vm library\n  SET_METHOD(isolate, target, \"memoryUsage\", MemoryUsage);\n\n  SET_METHOD(isolate, target, \"load\", Load);\n  SET_METHOD(isolate, target, \"builtin\", Builtin);\n  SET_METHOD(isolate, target, \"builtins\", Builtins);\n  SET_METHOD(isolate, target, \"modules\", Modules);\n}\n"
        },
        {
          "name": "just.h",
          "type": "blob",
          "size": 3.84765625,
          "content": "#ifndef JUST_H\n#define JUST_H\n\n#include <v8.h>\n#include <libplatform/libplatform.h>\n#include <map>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <sys/utsname.h>\n\nnamespace just {\n\n#define JUST_MICROS_PER_SEC 1e6\n\nusing v8::String;\nusing v8::NewStringType;\nusing v8::Local;\nusing v8::Isolate;\nusing v8::Context;\nusing v8::ObjectTemplate;\nusing v8::FunctionCallbackInfo;\nusing v8::Function;\nusing v8::Object;\nusing v8::Value;\nusing v8::MaybeLocal;\nusing v8::Module;\nusing v8::TryCatch;\nusing v8::Message;\nusing v8::StackTrace;\nusing v8::StackFrame;\nusing v8::HandleScope;\nusing v8::Integer;\nusing v8::BigInt;\nusing v8::FunctionTemplate;\nusing v8::ScriptOrigin;\nusing v8::True;\nusing v8::False;\nusing v8::ScriptCompiler;\nusing v8::ArrayBuffer;\nusing v8::Array;\nusing v8::Maybe;\nusing v8::HeapStatistics;\nusing v8::Float64Array;\nusing v8::HeapSpaceStatistics;\nusing v8::BigUint64Array;\nusing v8::Int32Array;\nusing v8::Exception;\nusing v8::FunctionCallback;\nusing v8::Script;\nusing v8::Platform;\nusing v8::V8;\nusing v8::BackingStore;\nusing v8::SharedArrayBuffer;\nusing v8::PromiseRejectMessage;\nusing v8::Promise;\nusing v8::PromiseRejectEvent;\nusing v8::Uint32Array;\nusing v8::BigUint64Array;\nusing v8::FixedArray;\n\nenum ScriptType : int {\n  kScript,\n  kModule,\n  kFunction,\n};\n\nenum HostDefinedOptions : int {\n  kType = 8,\n  kID = 9,\n  kLength = 10,\n};\n\nssize_t process_memory_usage();\n\nuint64_t hrtime();\ntypedef void *(*register_plugin)();\nstruct builtin {\n  unsigned int size;\n  const char* source;\n};\nextern std::map<std::string, builtin*> builtins;\nextern std::map<std::string, register_plugin> modules;\nvoid builtins_add (const char* name, const char* source, \n  unsigned int size);\n\nusing InitializerCallback = void (*)(Isolate* isolate, \n  Local<ObjectTemplate> exports);\nv8::MaybeLocal<v8::Module> OnModuleInstantiate(v8::Local<v8::Context> context,\n  v8::Local<v8::String> specifier, v8::Local<v8::FixedArray> import_assertions, \n  v8::Local<v8::Module> referrer);\n\nint CreateIsolate(int argc, char** argv, \n  const char* main, unsigned int main_len,\n  const char* js, unsigned int js_len, struct iovec* buf, int fd,\n  uint64_t start);\nint CreateIsolate(int argc, char** argv,\n  const char* main, unsigned int main_len, uint64_t start);\nvoid PrintStackTrace(Isolate* isolate, const TryCatch& try_catch);\nvoid PromiseRejectCallback(PromiseRejectMessage message);\nvoid FreeMemory(void* buf, size_t length, void* data);\n\nvoid SET_METHOD(Isolate *isolate, Local<ObjectTemplate> \n  recv, const char *name, FunctionCallback callback);\nvoid SET_MODULE(Isolate *isolate, Local<ObjectTemplate> \n  recv, const char *name, Local<ObjectTemplate> module);\nvoid SET_VALUE(Isolate *isolate, Local<ObjectTemplate> \n  recv, const char *name, Local<Value> value);\n\nvoid Print(const FunctionCallbackInfo<Value> &args);\nvoid Error(const FunctionCallbackInfo<Value> &args);\nvoid Load(const FunctionCallbackInfo<Value> &args);\nvoid Sleep(const FunctionCallbackInfo<Value> &args);\nvoid PID(const FunctionCallbackInfo<Value> &args);\nvoid Exit(const FunctionCallbackInfo<Value> &args);\nvoid Chdir(const FunctionCallbackInfo<Value> &args);\nvoid HRTime(const FunctionCallbackInfo<Value> &args);\nvoid AllocHRTime(const FunctionCallbackInfo<Value> &args);\nvoid Builtin(const FunctionCallbackInfo<Value> &args);\nvoid MemoryUsage(const FunctionCallbackInfo<Value> &args);\nvoid Builtins(const FunctionCallbackInfo<Value> &args);\nvoid Modules(const FunctionCallbackInfo<Value> &args);\n\n/**\n  * Setup the target ObjectTemplate with 'just' property which holds the\n  * basic functions in the runtime core\n  * .version\n  * .version.just\n  * .version.v8\n  * .version.kernel\n  * .version.kernel.os\n  * .version.kernel.release\n  * .version.kernel.version\n  * .print()\n  * .error()\n  * .load()\n  * .pid()\n  * .sleep()\n  * .exit()\n  * .chdir()\n  * .builtin()\n  * .memoryUsage()\n**/\nvoid Init(Isolate* isolate, Local<ObjectTemplate> target);\n\n}\n#endif\n"
        },
        {
          "name": "just.js",
          "type": "blob",
          "size": 12.974609375,
          "content": "(function () {\n  function wrapHRTime (just) {\n    const { hrtime } = just\n    const u64 = hrtime()\n    const u32 = new Uint32Array(u64.buffer)\n    const start = Number(just.start)\n    return () => {\n      hrtime()\n      return ((u32[1] * 0x100000000) + u32[0]) - start\n    }\n  }\n\n  function wrapMemoryUsage (memoryUsage) {\n    const mem = new BigUint64Array(16)\n    return () => {\n      memoryUsage(mem)\n      return {\n        rss: mem[0],\n        total_heap_size: mem[1],\n        used_heap_size: mem[2],\n        external_memory: mem[3],\n        heap_size_limit: mem[5],\n        total_available_size: mem[10],\n        total_heap_size_executable: mem[11],\n        total_physical_size: mem[12]\n      }\n    }\n  }\n\n  function wrapCpuUsage (cpuUsage) {\n    const cpu = new Uint32Array(4)\n    const result = { elapsed: 0, user: 0, system: 0, cuser: 0, csystem: 0 }\n    const clock = cpuUsage(cpu)\n    const last = { user: cpu[0], system: cpu[1], cuser: cpu[2], csystem: cpu[3], clock }\n    return () => {\n      const clock = cpuUsage(cpu)\n      result.elapsed = clock - last.clock\n      result.user = cpu[0] - last.user\n      result.system = cpu[1] - last.system\n      result.cuser = cpu[2] - last.cuser\n      result.csystem = cpu[3] - last.csystem\n      last.user = cpu[0]\n      last.system = cpu[1]\n      last.cuser = cpu[2]\n      last.csystem = cpu[3]\n      last.clock = clock\n      return result\n    }\n  }\n\n  function wrapgetrUsage (getrUsage) {\n    const res = new Float64Array(16)\n    return () => {\n      getrUsage(res)\n      return {\n        user: res[0],\n        system: res[1],\n        maxrss: res[2],\n        ixrss: res[3],\n        idrss: res[4],\n        isrss: res[5],\n        minflt: res[6],\n        majflt: res[7],\n        nswap: res[8],\n        inblock: res[9],\n        outblock: res[10],\n        msgsnd: res[11],\n        msgrcv: res[12],\n        ssignals: res[13],\n        nvcsw: res[14],\n        nivcsw: res[15]\n      }\n    }\n  }\n\n  function wrapHeapUsage (heapUsage) {\n    const heap = (new Array(16)).fill(0).map(v => new Float64Array(4))\n    return () => {\n      const usage = heapUsage(heap)\n      usage.spaces = Object.keys(usage.heapSpaces).map(k => {\n        const space = usage.heapSpaces[k]\n        return {\n          name: k,\n          size: space[2],\n          used: space[3],\n          available: space[1],\n          physicalSize: space[0]\n        }\n      })\n      delete usage.heapSpaces\n      return usage\n    }\n  }\n\n  function wrapEnv (env) {\n    return () => {\n      return env()\n        .map(entry => entry.split('='))\n        .reduce((e, pair) => { e[pair[0]] = pair[1]; return e }, {})\n    }\n  }\n\n  function wrapLibrary (cache = {}) {\n    function loadLibrary (path, name) {\n      if (cache[name]) return cache[name]\n      if (!just.sys.dlopen) return {}\n      const handle = just.sys.dlopen(path, just.sys.RTLD_LAZY)\n      if (!handle) return {}\n      const ptr = just.sys.dlsym(handle, `_register_${name}`)\n      if (!ptr) return {}\n      const lib = just.load(ptr)\n      if (!lib) return {}\n      lib.close = () => just.sys.dlclose(handle)\n      lib.type = 'module-external'\n      cache[name] = lib\n      return lib\n    }\n\n    function library (name, path) {\n      if (cache[name]) return cache[name]\n      const lib = just.load(name)\n      if (!lib) {\n        if (path) return loadLibrary(path, name)\n        return loadLibrary(`${name}.so`, name)\n      }\n      lib.type = 'module'\n      cache[name] = lib\n      return lib\n    }\n\n    return { library, cache }\n  }\n\n  function wrapRequire (cache = {}) {\n    const appRoot = just.sys.cwd()\n    const { HOME, JUST_TARGET } = just.env()\n    const justDir = JUST_TARGET || `${HOME}/.just`\n\n    function requireNative (path) {\n      path = `lib/${path}.js`\n      if (cache[path]) return cache[path].exports\n      const { vm } = just\n      const params = ['exports', 'require', 'module']\n      const exports = {}\n      const module = { exports, type: 'native', dirName: appRoot }\n      module.text = just.builtin(path)\n      if (!module.text) return\n      const fun = vm.compile(module.text, path, params, [])\n      module.function = fun\n      cache[path] = module\n      fun.call(exports, exports, p => just.require(p, module), module)\n      return module.exports\n    }\n\n    function require (path, parent = { dirName: appRoot }) {\n      const { join, baseName, fileName } = just.path\n      if (path[0] === '@') path = `${appRoot}/lib/${path.slice(1)}/${fileName(path.slice(1))}.js`\n      const ext = path.split('.').slice(-1)[0]\n      if (ext === 'js' || ext === 'json') {\n        let dirName = parent.dirName\n        const fileName = join(dirName, path)\n        if (cache[fileName]) return cache[fileName].exports\n        dirName = baseName(fileName)\n        const params = ['exports', 'require', 'module']\n        const exports = {}\n        const module = { exports, dirName, fileName, type: ext }\n        // todo: this is not secure\n        if (just.fs.isFile(fileName)) {\n          module.text = just.fs.readFile(fileName)\n        } else {\n          path = fileName.replace(appRoot, '')\n          if (path[0] === '/') path = path.slice(1)\n          module.text = just.builtin(path)\n          if (!module.text) {\n            path = `${justDir}/${path}`\n            if (!just.fs.isFile(path)) return\n            module.text = just.fs.readFile(path)\n            if (!module.text) return\n          }\n        }\n        cache[fileName] = module\n        if (ext === 'js') {\n          const fun = just.vm.compile(module.text, fileName, params, [])\n          module.function = fun\n          fun.call(exports, exports, p => require(p, module), module)\n        } else {\n          module.exports = JSON.parse(module.text)\n        }\n        return module.exports\n      }\n      return requireNative(path, parent)\n    }\n\n    return { requireNative, require, cache }\n  }\n\n  function setTimeout (callback, timeout, repeat = 0, loop = just.factory.loop) {\n    const buf = new ArrayBuffer(8)\n    const timerfd = just.sys.timer(repeat, timeout)\n    loop.add(timerfd, (fd, event) => {\n      callback()\n      just.fs.read(fd, buf, 0, buf.byteLength)\n      if (repeat === 0) {\n        loop.remove(fd)\n        just.fs.close(fd)\n      }\n    })\n    return timerfd\n  }\n\n  function setInterval (callback, timeout, loop = just.factory.loop) {\n    return setTimeout(callback, timeout, timeout, loop)\n  }\n\n  function clearTimeout (fd, loop = just.factory.loop) {\n    loop.remove(fd)\n    just.fs.close(fd)\n  }\n\n  class SystemError extends Error {\n    constructor (syscall) {\n      const { sys } = just\n      const errno = sys.errno()\n      const message = `${syscall} (${errno}) ${sys.strerror(errno)}`\n      super(message)\n      this.errno = errno\n      this.name = 'SystemError'\n    }\n  }\n\n  function setNonBlocking (fd) {\n    let flags = just.fs.fcntl(fd, just.sys.F_GETFL, 0)\n    if (flags < 0) return flags\n    flags |= just.net.O_NONBLOCK\n    return just.fs.fcntl(fd, just.sys.F_SETFL, flags)\n  }\n\n  function parseArgs (args) {\n    const opts = {}\n    args = args.filter(arg => {\n      if (arg.slice(0, 2) === '--') {\n        opts[arg.slice(2)] = true\n        return false\n      }\n      return true\n    })\n    opts.args = args\n    return opts\n  }\n\n  function main (opts) {\n    const { library, cache } = wrapLibrary()\n    let debugStarted = false\n\n    delete global.console\n\n    global.onUnhandledRejection = err => {\n      just.error('onUnhandledRejection')\n      if (err) just.error(err.stack)\n    }\n\n    // load the builtin modules\n    just.vm = library('vm').vm\n    just.loop = library('epoll').epoll\n    just.fs = library('fs').fs\n    just.net = library('net').net\n    just.sys = library('sys').sys\n    just.env = wrapEnv(just.sys.env)\n\n    // todo: what about sharedarraybuffers?\n    ArrayBuffer.prototype.writeString = function(str, off = 0) { // eslint-disable-line\n      return just.sys.writeString(this, str, off)\n    }\n    ArrayBuffer.prototype.readString = function (len = this.byteLength, off = 0) { // eslint-disable-line\n      return just.sys.readString(this, len, off)\n    }\n    ArrayBuffer.prototype.getAddress = function () { // eslint-disable-line\n      return just.sys.getAddress(this)\n    }\n    ArrayBuffer.prototype.copyFrom = function (src, off = 0, len = src.byteLength, soff = 0) { // eslint-disable-line\n      return just.sys.memcpy(this, src, off, len, soff)\n    }\n    ArrayBuffer.fromString = str => just.sys.calloc(1, str)\n    String.byteLength = just.sys.utf8Length\n\n    const { requireNative, require } = wrapRequire(cache)\n\n    just.SystemError = SystemError\n    Object.assign(just.fs, requireNative('fs'))\n    just.config = requireNative('config')\n    just.path = requireNative('path')\n    just.factory = requireNative('loop').factory\n    just.factory.loop = just.factory.create(128)\n    just.process = requireNative('process')\n    just.setTimeout = setTimeout\n    just.setInterval = setInterval\n    just.clearTimeout = just.clearInterval = clearTimeout\n    just.library = library\n    just.requireNative = requireNative\n    just.net.setNonBlocking = setNonBlocking\n    just.require = global.require = require\n    just.require.cache = cache\n    just.hrtime = wrapHRTime(just)\n    just.memoryUsage = wrapMemoryUsage(just.memoryUsage)\n    just.cpuUsage = wrapCpuUsage(just.sys.cpuUsage)\n    just.rUsage = wrapgetrUsage(just.sys.getrUsage)\n    just.heapUsage = wrapHeapUsage(just.sys.heapUsage)\n\n    function startup () {\n      if (!just.args.length) return true\n      if (just.workerSource) {\n        const scriptName = just.path.join(just.sys.cwd(), just.args[0] || 'thread')\n        just.main = just.workerSource\n        delete just.workerSource\n        just.vm.runScript(just.main, scriptName)\n        return\n      }\n      if (just.args.length === 1) {\n        const replModule = just.require('repl')\n        if (!replModule) {\n          throw new Error('REPL not enabled. Maybe I should be a standalone?')\n        }\n        replModule.repl()\n        return\n      }\n      if (just.args[1] === '--') {\n        // todo: limit size\n        // todo: allow streaming in multiple scripts with a separator and running them all\n        const buf = new ArrayBuffer(4096)\n        const chunks = []\n        let bytes = just.net.read(just.sys.STDIN_FILENO, buf, 0, buf.byteLength)\n        while (bytes > 0) {\n          chunks.push(buf.readString(bytes))\n          bytes = just.net.read(just.sys.STDIN_FILENO, buf, 0, buf.byteLength)\n        }\n        just.vm.runScript(chunks.join(''), 'stdin')\n        return\n      }\n      if (just.args[1] === 'eval') {\n        just.vm.runScript(just.args[2], 'eval')\n        return\n      }\n      if (just.args[1] === 'build') {\n        const buildModule = just.require('build')\n        if (!buildModule) throw new Error('Build not Available')\n        let config\n        if (just.opts.config) {\n          config = require(just.args[2]) || {}\n        } else {\n          if (just.args.length > 2) {\n            config = just.require('configure').run(just.args[2], opts)\n          } else {\n            config = require(just.args[2] || 'config.json') || require('config.js') || {}\n          }\n        }\n        buildModule.run(config, opts)\n          .then(cfg => {\n            if (opts.dump) just.print(JSON.stringify(cfg, null, '  '))\n          })\n          .catch(err => just.error(err.stack))\n        return\n      }\n      if (just.args[1] === 'init') {\n        const buildModule = just.require('build')\n        if (!buildModule) throw new Error('Build not Available')\n        buildModule.init(just.args[2] || 'hello')\n        return\n      }\n      if (just.args[1] === 'clean') {\n        const buildModule = just.require('build')\n        if (!buildModule) throw new Error('Build not Available')\n        buildModule.clean()\n        return\n      }\n      const scriptName = just.path.join(just.sys.cwd(), just.args[1])\n      just.main = just.fs.readFile(just.args[1])\n      if (opts.esm) {\n        just.vm.runModule(just.main, scriptName)\n      } else {\n        just.vm.runScript(just.main, scriptName)\n      }\n    }\n    if (opts.inspector) {\n      const inspectorLib = just.library('inspector')\n      if (!inspectorLib) throw new SystemError('inspector module is not enabled')\n      just.inspector = inspectorLib.inspector\n      // TODO: this is ugly\n      Object.assign(just.inspector, require('inspector'))\n      just.encode = library('encode').encode\n      just.sha1 = library('sha1').sha1\n      global.process = {\n        pid: just.sys.pid(),\n        version: 'v15.6.0',\n        arch: 'x64',\n        env: just.env()\n      }\n      const _require = global.require\n      global.require = (name, path) => {\n        if (name === 'module') return ['fs', 'process', 'repl']\n        return _require(name, path)\n      }\n      global.inspector = just.inspector.createInspector({\n        title: 'Just!',\n        onReady: () => {\n          if (debugStarted) return just.factory.run()\n          debugStarted = true\n          if (!startup()) just.factory.run()\n        }\n      })\n      just.inspector.enable()\n      just.factory.run(1)\n      return\n    }\n    if (!startup()) just.factory.run()\n  }\n\n  const opts = parseArgs(just.args)\n  just.args = opts.args\n  just.opts = opts\n  if (opts.bare) {\n    just.load('vm').vm.runScript(just.args[1], 'eval')\n  } else {\n    main(opts)\n  }\n})()\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.cc",
          "type": "blob",
          "size": 0.74609375,
          "content": "#include \"just.h\"\n#include \"main.h\"\n\nint main(int argc, char** argv) {\n  uint64_t start = just::hrtime();\n  setvbuf(stdout, nullptr, _IONBF, 0);\n  setvbuf(stderr, nullptr, _IONBF, 0);\n  std::unique_ptr<v8::Platform> platform = v8::platform::NewDefaultPlatform();\n  v8::V8::InitializePlatform(platform.get());\n  v8::V8::SetFlagsFromString(v8flags);\n  if (_v8flags_from_commandline == 1) {\n    v8::V8::SetFlagsFromCommandLine(&argc, argv, true);\n  }\n  v8::V8::Initialize();\n  register_builtins();\n  if (_use_index) {\n    just::CreateIsolate(argc, argv, just_js, just_js_len, \n      index_js, index_js_len, \n      NULL, 0, start);\n  } else {\n    just::CreateIsolate(argc, argv, just_js, just_js_len, start);\n  }\n  v8::V8::Dispose();\n  platform.reset();\n  return 0;\n}\n"
        },
        {
          "name": "main.h",
          "type": "blob",
          "size": 3.84375,
          "content": "extern char _binary_lib_fs_js_start[];\nextern char _binary_lib_fs_js_end[];\nextern char _binary_lib_loop_js_start[];\nextern char _binary_lib_loop_js_end[];\nextern char _binary_lib_path_js_start[];\nextern char _binary_lib_path_js_end[];\nextern char _binary_lib_process_js_start[];\nextern char _binary_lib_process_js_end[];\nextern char _binary_lib_build_js_start[];\nextern char _binary_lib_build_js_end[];\nextern char _binary_lib_repl_js_start[];\nextern char _binary_lib_repl_js_end[];\nextern char _binary_lib_configure_js_start[];\nextern char _binary_lib_configure_js_end[];\nextern char _binary_lib_acorn_js_start[];\nextern char _binary_lib_acorn_js_end[];\nextern char _binary_just_cc_start[];\nextern char _binary_just_cc_end[];\nextern char _binary_Makefile_start[];\nextern char _binary_Makefile_end[];\nextern char _binary_main_cc_start[];\nextern char _binary_main_cc_end[];\nextern char _binary_just_h_start[];\nextern char _binary_just_h_end[];\nextern char _binary_just_js_start[];\nextern char _binary_just_js_end[];\nextern char _binary_lib_inspector_js_start[];\nextern char _binary_lib_inspector_js_end[];\nextern char _binary_lib_websocket_js_start[];\nextern char _binary_lib_websocket_js_end[];\nextern char _binary_config_js_start[];\nextern char _binary_config_js_end[];\nextern \"C\" {\n  extern void* _register_sys();\n  extern void* _register_fs();\n  extern void* _register_net();\n  extern void* _register_vm();\n  extern void* _register_epoll();\n}\nvoid register_builtins() {\n  just::builtins_add(\"lib/fs.js\", _binary_lib_fs_js_start, _binary_lib_fs_js_end - _binary_lib_fs_js_start);\n  just::builtins_add(\"lib/loop.js\", _binary_lib_loop_js_start, _binary_lib_loop_js_end - _binary_lib_loop_js_start);\n  just::builtins_add(\"lib/path.js\", _binary_lib_path_js_start, _binary_lib_path_js_end - _binary_lib_path_js_start);\n  just::builtins_add(\"lib/process.js\", _binary_lib_process_js_start, _binary_lib_process_js_end - _binary_lib_process_js_start);\n  just::builtins_add(\"lib/build.js\", _binary_lib_build_js_start, _binary_lib_build_js_end - _binary_lib_build_js_start);\n  just::builtins_add(\"lib/repl.js\", _binary_lib_repl_js_start, _binary_lib_repl_js_end - _binary_lib_repl_js_start);\n  just::builtins_add(\"lib/configure.js\", _binary_lib_configure_js_start, _binary_lib_configure_js_end - _binary_lib_configure_js_start);\n  just::builtins_add(\"lib/acorn.js\", _binary_lib_acorn_js_start, _binary_lib_acorn_js_end - _binary_lib_acorn_js_start);\n  just::builtins_add(\"just.cc\", _binary_just_cc_start, _binary_just_cc_end - _binary_just_cc_start);\n  just::builtins_add(\"Makefile\", _binary_Makefile_start, _binary_Makefile_end - _binary_Makefile_start);\n  just::builtins_add(\"main.cc\", _binary_main_cc_start, _binary_main_cc_end - _binary_main_cc_start);\n  just::builtins_add(\"just.h\", _binary_just_h_start, _binary_just_h_end - _binary_just_h_start);\n  just::builtins_add(\"just.js\", _binary_just_js_start, _binary_just_js_end - _binary_just_js_start);\n  just::builtins_add(\"lib/inspector.js\", _binary_lib_inspector_js_start, _binary_lib_inspector_js_end - _binary_lib_inspector_js_start);\n  just::builtins_add(\"lib/websocket.js\", _binary_lib_websocket_js_start, _binary_lib_websocket_js_end - _binary_lib_websocket_js_start);\n  just::builtins_add(\"config.js\", _binary_config_js_start, _binary_config_js_end - _binary_config_js_start);\n  just::modules[\"sys\"] = &_register_sys;\n  just::modules[\"fs\"] = &_register_fs;\n  just::modules[\"net\"] = &_register_net;\n  just::modules[\"vm\"] = &_register_vm;\n  just::modules[\"epoll\"] = &_register_epoll;\n}\nstatic unsigned int just_js_len = _binary_just_js_end - _binary_just_js_start;\nstatic const char* just_js = _binary_just_js_start;\nstatic unsigned int index_js_len = 0;\nstatic const char* index_js = NULL;\nstatic unsigned int _use_index = 0;\nstatic const char* v8flags = \"--stack-trace-limit=10 --use-strict --disallow-code-generation-from-strings\";\nstatic unsigned int _v8flags_from_commandline = 1;"
        },
        {
          "name": "scc.sh",
          "type": "blob",
          "size": 0.087890625,
          "content": "scc --exclude-dir=\"deps,config,.devcontainer,.git,.vscode\" --include-ext=\"cc,h,js\" --wide\n"
        }
      ]
    }
  ]
}