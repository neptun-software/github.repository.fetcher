{
  "metadata": {
    "timestamp": 1736562094952,
    "page": 879,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "siimon/prom-client",
      "stars": 3183,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.197265625,
          "content": "; http://editorconfig.org\n\nroot = true\n\n[*]\nindent_style = tab\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.yml]\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".eslintignore",
          "type": "blob",
          "size": 0.009765625,
          "content": "coverage/\n"
        },
        {
          "name": ".eslintrc",
          "type": "blob",
          "size": 1.9931640625,
          "content": "{\n\t\"plugins\": [\"prettier\"],\n\t\"extends\": [\n\t\t\"eslint:recommended\",\n\t\t\"plugin:n/recommended\",\n\t\t\"plugin:prettier/recommended\"\n\t],\n\t\"env\": {\n\t\t\"node\": true,\n\t\t\"es6\": true\n\t},\n\t\"parserOptions\": {\n\t\t\"ecmaVersion\": 2019\n\t},\n\t\"rules\": {\n\t\t\"no-underscore-dangle\": \"off\",\n\t\t\"no-mixed-requires\": \"off\",\n\t\t\"new-cap\": \"off\",\n\t\t\"no-path-concat\": \"off\",\n\t\t\"no-shadow\": \"warn\",\n\t\t\"no-array-constructor\": \"error\",\n\t\t\"no-caller\": \"error\",\n\t\t\"no-eval\": \"error\",\n\t\t\"no-extend-native\": \"error\",\n\t\t\"no-extra-bind\": \"error\",\n\t\t\"no-with\": \"error\",\n\t\t\"no-loop-func\": \"error\",\n\t\t\"no-multi-str\": \"error\",\n\t\t\"no-new-func\": \"error\",\n\t\t\"no-new-object\": \"error\",\n\t\t\"no-return-assign\": \"error\",\n\t\t\"no-sequences\": \"error\",\n\t\t\"no-shadow-restricted-names\": \"error\",\n\t\t\"no-unused-expressions\": \"error\",\n\t\t\"no-use-before-define\": \"off\",\n\t\t\"no-new\": \"off\",\n\t\t\"dot-notation\": [\"error\", { \"allowKeywords\": true }],\n\t\t\"eqeqeq\": \"error\",\n\t\t\"new-parens\": \"error\",\n\t\t\"strict\": [\"error\", \"global\"],\n\t\t\"yoda\": \"error\",\n\t\t\"valid-jsdoc\": \"error\",\n\t\t\"object-shorthand\": \"error\",\n\t\t\"no-var\": \"error\",\n\t\t\"prefer-const\": \"error\",\n\t\t\"prefer-arrow-callback\": \"error\",\n\t\t\"arrow-body-style\": [\n\t\t\t\"error\",\n\t\t\t\"as-needed\",\n\t\t\t{ \"requireReturnForObjectLiteral\": true }\n\t\t],\n\t\t\"prefer-template\": \"error\"\n\t},\n\t\"overrides\": [\n\t\t{\n\t\t\t\"files\": [\"test/**/*.js\"],\n\t\t\t\"env\": {\n\t\t\t\t\"jest\": true\n\t\t\t},\n\t\t\t\"rules\": {\n\t\t\t\t\"no-console\": \"off\",\n\t\t\t\t\"no-unused-vars\": \"off\",\n\t\t\t\t\"no-shadow\": \"off\",\n\t\t\t\t\"no-unused-expressions\": \"off\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"files\": [\"example/**/*.js\", \"benchmarks/**/*.js\"],\n\t\t\t\"rules\": {\n\t\t\t\t\"no-console\": \"off\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"files\": [\"**/*.ts\"],\n\t\t\t\"extends\": [\"plugin:@typescript-eslint/recommended\"],\n\t\t\t\"parser\": \"@typescript-eslint/parser\",\n\t\t\t\"plugins\": [\"@typescript-eslint\"],\n\t\t\t\"rules\": {\n\t\t\t\t\"no-shadow\": \"off\",\n\t\t\t\t\"@typescript-eslint/no-shadow\": \"warn\",\n\t\t\t\t\"n/no-unsupported-features/es-syntax\": \"off\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"files\": [\"**/*.d.ts\"],\n\t\t\t\"rules\": {\n\t\t\t\t\"@typescript-eslint/no-explicit-any\": \"off\",\n\t\t\t\t\"@typescript-eslint/no-unused-vars\": \"off\"\n\t\t\t}\n\t\t}\n\t]\n}\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0185546875,
          "content": "* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0771484375,
          "content": ".DS_Store\nnode_modules\n.idea/\n*.log\ncoverage/\npackage-lock.json\n*.heapsnapshot\n"
        },
        {
          "name": ".husky",
          "type": "tree",
          "content": null
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 17.9921875,
          "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/) and this\nproject adheres to [Semantic Versioning](http://semver.org/).\n\n## [Unreleased]\n\n### Breaking\n\n### Changed\n\n### Added\n\n[unreleased]: https://github.com/siimon/prom-client/compare/v15.1.3...HEAD\n\n## [15.1.3] - 2024-06-27\n\n### Changed\n\n- Improve error message when number of registered labels mismatch with the number of labels provided\n\n## [15.1.2] - 2024-04-16\n\n### Changed\n\n- Add `Registry.PROMETHEUS_CONTENT_TYPE` and `Registry.OPENMETRICS_CONTENT_TYPE` constants to the TypeScript types\n- Correctly read and set `contentType` top level export\n\n### Added\n\n- Enable `bun.js` by catching `NotImplemented` error (Fixes [#570](https://github.com/siimon/prom-client/issues/570))\n\n## [15.1.1] - 2024-03-26\n\n### Changed\n\n- Improve the memory usage of histograms when the `enableExemplars` option is disabled\n- fix: Avoid updating exemplar values during subsequent metric changes (Fixes [#616](https://github.com/siimon/prom-client/issues/616))\n\n## [15.1.0] - 2023-12-15\n\n### Changed\n\n- remove unnecessary loop from `osMemoryHeapLinux`\n- Improve performance of `hashObject` by using pre-sorted array of label names\n- Fix type of `collectDefaultMetrics.metricsList`\n\n### Added\n\n- Allow Pushgateway to now require job names for compatibility with Gravel Gateway.\n- Allow `histogram.startTime()` to be used with exemplars.\n\n[15.1.0]: https://github.com/siimon/prom-client/compare/v15.0.0...v15.1.0\n\n## [15.0.0] - 2023-10-09\n\n### Breaking\n\n- drop support for Node.js versions 10, 12, 14, 17 and 19\n\n### Changed\n\n- Refactor histogram internals and provide a fast path for rendering metrics to\n  Prometheus strings when there are many labels shared across different values.\n- Disable custom content encoding for pushgateway delete requests in order to\n  avoid failures from the server when using `Content-Encoding: gzip` header.\n- Refactor `escapeString` helper in `lib/registry.js` to improve performance and\n  avoid an unnecessarily complex regex.\n- Cleanup code and refactor to be more efficient\n- Correct TS types for working with OpenMetrics\n- Updated Typescript and Readme docs for `setToCurrentTime()` to reflect units as seconds.\n- Do not ignore error if request to pushgateway fails\n- Make sure to reject the request to pushgateway if it times out\n\n### Added\n\n- Support for OpenMetrics and Exemplars\n\n[15.0.0]: https://github.com/siimon/prom-client/compare/v14.2.0...v15.0.0\n\n## [14.2.0] - 2023-03-06\n\n### Changed\n\n- Refactor `getMetricAsPrometheusString` method in the `Registry` class to use `Array.prototype.join`\n  instead of loop of string concatenations.\n- Also use `Array.prototype.map`, and object spread instead of an explicit `for` loop\n- changed: updated the sample output in `example/default-metrics.js`\n- `summary` metrics now has a `pruneAgedBuckets` config parameter\n  to remove entries without any new values in the last `maxAgeSeconds`.\n  Default is `false` (old behavior)\n\n### Added\n\n- Add `get` method to type definitions of metric classes\n\n[14.2.0]: https://github.com/siimon/prom-client/compare/v14.1.1...v14.2.0\n\n## [14.1.1] - 2022-12-31\n\n### Changed\n\n- Increase compatibility with external build system such as `rollup` by making perf_hooks optional in gc.js\n\n[14.1.1]: https://github.com/siimon/prom-client/compare/v14.1.0...v14.1.1\n\n## [14.1.0] - 2022-08-23\n\n### Changed\n\n- types: converted all the generic Metric types to be optional\n\n- The `done()` functions returned by `gauge.startTimer()` and\n  `summary.startTimer()` now return the timed duration. Histograms already had\n  this behavior.\n\n- types: fixed type for `registry.getMetricsAsArray()`\n\n- Improve performance of `gague.inc()` and `gauge.dec()` by calling `hashObject()` once.\n\n### Added\n\n- The `processResources` metric was added, which keeps a track of all sorts of\n  active resources. It consists of the following gauges:\n\n  - `nodejs_active_resources` - Number of active resources that are currently\n    keeping the event loop alive, grouped by async resource type.\n  - `nodejs_active_resources_total` - Total number of active resources.\n    It is supposed to provide the combined result of the `processHandles` and\n    `processRequests` metrics along with information about any other types of\n    async resources that these metrics do not keep a track of (like timers).\n\n- Support gzipped pushgateway requests\n\n[14.1.0]: https://github.com/siimon/prom-client/compare/v14.0.1...v14.1.0\n\n## [14.0.1] - 2021-11-02\n\n### Changed\n\n- changed: typedef for pushgateway to reflect js implementation.\n\n[14.0.1]: https://github.com/siimon/prom-client/compare/v14.0.0...v14.0.1\n\n## [14.0.0] - 2021-09-18\n\n### Breaking\n\n- changed: `linearBuckets` does not propagate rounding errors anymore.\n\n  Fewer bucket bounds will be affected by rounding errors. Histogram bucket\n  labels may change. [`6f1f3b2`](https://github.com/siimon/prom-client/commit/6f1f3b24c9c21311ff33e7d4b987b40c6b304e04)\n\n- changed: The push gateway methods `pushAdd()`, `push()` and `delete()` now\n  return Promises instead of accepting a callback:\n\n  ```js\n  // Old:\n  gateway.pushAdd({ jobName: 'test' }, (err, resp, body) => {});\n  // New:\n  gateway\n    .pushAdd({ jobName: 'test' })\n    .then(({ resp, body }) => {})\n    .catch(err => {});\n  // or\n  const { resp, body } = await gateway.pushAdd({ jobName: 'test' });\n  ```\n\n  [`f177b1f`](https://github.com/siimon/prom-client/commit/f177b1fd3d4db5fc48fcb1ec02d94069fffcf144)\n\n- changed: The default `nodejs_eventloop_lag_*` metrics are now reset every time\n  they are observed. This prevents these metrics from \"stabilizing\" over a long\n  period of time and becoming insensitive to small changes. For more info, see\n  [#370](https://github.com/siimon/prom-client/issues/370). [`0f444cd`](https://github.com/siimon/prom-client/commit/0f444cd38e4c7074991270106c270f731bafddb8)\n\n### Changed\n\n- Add missing `await`/`then`s to examples. [`074f339`](https://github.com/siimon/prom-client/commit/074f339914e5d71b5829cd4a949affae23dbc409)\n- Add missing type declaration for `client.contentType`. [`3b66641`](https://github.com/siimon/prom-client/commit/3b6664160bdd1555045b03d8f4c421022f30e1db)\n- Modernize some label processing code. [`c9bf1d8`](https://github.com/siimon/prom-client/commit/c9bf1d8e3db3b5fb97faf2df9ca9b9af670288f3)\n\n[14.0.0]: https://github.com/siimon/prom-client/compare/v13.2.0...v14.0.0\n\n## [13.2.0] - 2021-08-08\n\n### Changed\n\n- Don't add event listener to `process` if cluster module is not used.\n- fix: set labels for default memory metrics on linux.\n- fix: fix DEP0152 deprecation warning in Node.js v16+.\n- fix: Set aggregation mode for newer event loop metrics. (Fixes [#418](https://github.com/siimon/prom-client/issues/418))\n- Improve performance of/reduce memory allocations in Gauge.\n\n### Added\n\n- feat: added `zero()` to `Histogram` for setting the metrics for a given label combination to zero\n- fix: allow `Gauge.inc/dec(0)` without defaulting to 1\n\n[13.2.0]: https://github.com/siimon/prom-client/compare/v13.1.0...v13.2.0\n\n## [13.1.0] - 2021-01-24\n\n### Changed\n\n- fix: push client attempting to write Promise (fixes [#390](https://github.com/siimon/prom-client/issues/390))\n- types: improve type checking of labels\n- fix: Summary#observe should throw when adding additional labels to labelset (fixes [#262](https://github.com/siimon/prom-client/issues/262))\n\n### Added\n\n- feat: added the ability to pass labels as an object to `labels()` and `remove()`\n- Added: More examples with commented output\n\n[13.1.0]: https://github.com/siimon/prom-client/compare/v13.0.0...v13.1.0\n\n## [13.0.0] - 2020-12-16\n\n### Breaking\n\n- changed: The following functions are now async (return a promise):\n  `registry.metrics()`\n  `registry.getMetricsAsJSON()`\n  `registry.getMetricsAsArray()`\n  `registry.getSingleMetricAsString()`\n\n  If your metrics server has a line like `res.send(register.metrics())`, you\n  should change it to `res.send(await register.metrics())`.\n\n  Additionally, all metric types now accept an optional `collect` function,\n  which is called when the metric's value should be collected and within which\n  you should set the metric's value. You should provide a `collect` function for\n  point-in-time metrics (e.g. current memory usage, as opposed to HTTP request\n  durations that are continuously logged in a histogram).\n\n- changed: `register.clusterMetrics()` no longer accepts a callback; it only\n  returns a promise.\n\n- removed: v12.0.0 added the undocumented functions `registry.registerCollector`\n  and `registry.collectors()`. These have been removed. If you were using them,\n  you should instead provide a `collect` function as described above.\n\n### Changed\n\n- fix: provide nodejs_version_info metric value after calling `registry.resetMetrics()` (#238)\n- fix: provide process_max_fds metric value after calling `registry.resetMetrics()`\n- fix: provide process_start_time_seconds metric value after calling `registry.resetMetrics()`\n- chore: improve performance of `registry.getMetricAsPrometheusString`\n- chore: refactor metrics to reduce code duplication\n- chore: replace `utils.getPropertiesFromObj` with `Object.values`\n- chore: remove unused `catch` bindings\n- chore: upgrade Prettier to 2.x\n- fix: startTimer returns `number` in typescript instead of `void`\n- fix: incorrect typings of `registry.getSingleMetric' (#388)\n- chore: stop testing node v13 on CI\n\n### Added\n\n- feat: exposed `registry.registerCollector()` and `registry.collectors()` methods in TypeScript declaration\n- Added: complete working example of a pushgateway push in `example/pushgateway.js`\n- feat: added support for adding labels to default metrics (#374)\n- Added CHANGELOG reminder\n\n[13.0.0]: https://github.com/siimon/prom-client/compare/v12.0.0...v13.0.0\n\n## [12.0.0] - 2020-02-20\n\n### Breaking\n\n- Dropped support for end-of-life Node.js versions 6.x and 8.x\n- Dropped the previously deprecated support for positional parameters in\n  constructors, only the config object forms remain.\n- Default metrics are collected on scrape of metrics endpoint, not on an\n  interval. The `timeout` option to `collectDefaultMetrics(conf)` is no longer\n  supported or needed, and the function no longer returns a `Timeout` object.\n\n### Changed\n\n- chore: remove ignored package-lock.json\n- fix: `process_max_fds` is process limit, not OS (#314)\n- Changed `Metric` labelNames & labelValues in TypeScript declaration to a generic type `T extends string`, instead of `string`\n- Lazy-load Node.js Cluster module to fix Passenger support (#293)\n- fix: avoid mutation bug in `registry.getMetricsAsJSON()`\n- fix: improve performance of `registry.getMetrics*`\n- End function of histogram `startTimer`, when invoked returns the number of seconds\n- chore: reindent package.json\n- chore: correct var name in processStartTime\n- chore: add test for `process_start_time_seconds`\n- chore: spelling corrections in README\n\n### Added\n\n- feat: implement GC metrics collection without native(C++) modules.\n- feat: implement advanced event loop monitoring\n\n[12.0.0]: https://github.com/siimon/prom-client/compare/v11.5.3...v12.0.0\n\n## [11.5.3] - 2019-06-27\n\n### Changed\n\n- Parameter `compressCount` in Summaries to control compression of data in t-digest.\n- Compress t-digest in Summaries\n\n[11.5.3]: https://github.com/siimon/prom-client/compare/v11.5.2...v11.5.3\n\n## [11.5.2] - 2019-06-20\n\n### Changed\n\n- fix: avoid mutation bug in registry\n\n[11.5.2]: https://github.com/siimon/prom-client/compare/v11.5.1...v11.5.2\n\n## [11.5.1] - 2019-06-13\n\n### Changed\n\n- fix: guard against missing constructor\n\n[11.5.1]: https://github.com/siimon/prom-client/compare/v11.5.0...v11.5.1\n\n## [11.5.0] - 2019-06-04\n\n### Added\n\n- Added `timestamps` toggle to `collectDefaultMetrics` options\n- Export `validateMetricName`\n\n[11.5.0]: https://github.com/siimon/prom-client/compare/v11.4.0...v11.5.0\n\n## [11.4.0] - 2019-06-04\n\n### Added\n\n- `nodejs_active_handles` metric to the `collectDefaultMetrics()`. Unlike `nodejs_active_handles_total` it split count of active handles by type.\n- `nodejs_active_requests` metric to the `collectDefaultMetrics()`. Unlike `nodejs_active_requests_total` it split count of active requests by type.\n\n[11.4.0]: https://github.com/siimon/prom-client/compare/v11.3.0...v11.4.0\n\n## [11.3.0] - 2019-04-02\n\n### Changed\n\n- Check that cluster worker is still connected before attempting to query it for\n  metrics. (#244)\n\n### Added\n\n- Added a `remove()` method on each metric type, based on [Prometheus \"Writing Client Libraries\" section on labels](https://prometheus.io/docs/instrumenting/writing_clientlibs/#labels)\n\n[11.3.0]: https://github.com/siimon/prom-client/compare/v11.2.1...v11.3.0\n\n## [11.2.1]\n\n### Breaking\n\n### Changed\n\n### Added\n\n- Updated types for Summary in typescript definition file\n\n[11.2.1]: https://github.com/siimon/prom-client/compare/v11.2.0...v11.2.1\n\n## [11.2.0]\n\n### Changed\n\n- Updated child dependency `merge` patch version to remove vulnerability.\n\n### Added\n\n- Added an initial `benchmark` suite which can be run with `npm run benchmarks`.\n- Add support for sliding windows in Summaries\n\n[11.2.0]: https://github.com/siimon/prom-client/compare/v11.1.3...v11.2.0\n\n## [11.1.3] - 2018-09-22\n\n### Changed\n\n- Fixed performance by avoiding `Object.assign` on hot paths, as well as\n  mutating objects when appropriate.\n\n[11.1.3]: https://github.com/siimon/prom-client/compare/v11.1.2...v11.1.3\n\n## [11.1.2] - 2018-09-19\n\n### Changed\n\n- Allow setting Gauge values to NaN, +Inf, and -Inf\n- Fixed `histogram` scrape performance by using `acc.push` instead of `acc.concat`. Fixes #216 with #219\n\n[11.1.2]: https://github.com/siimon/prom-client/compare/v11.1.1...v11.1.2\n\n## [11.1.1] - 2018-06-29\n\n### Changed\n\n- Fixed `processOpenFileDescriptors` metric when no custom config was set\n\n[11.1.1]: https://github.com/siimon/prom-client/compare/v11.1.0...v11.1.1\n\n## [11.1.0] - 2018-06-29\n\n- Added ability to set a name prefix in the default metrics\n\n### Changed\n\n- Fixed `startTimer` utility to not mutate objects passed as `startLabels`\n- Fixed `Counter` to validate labels parameter of `inc()` against initial\n  labelset\n- Fixed `AggregatorFactory` losing the aggregator method of metrics\n\n[11.1.0]: https://github.com/siimon/prom-client/compare/v11.0.0...v11.1.0\n\n## [11.0.0] - 2018-03-10\n\n### Breaking\n\n- Fixed `gauge.setToCurrentTime()` to use seconds instead of milliseconds\n  - This conforms to Prometheus\n    [best practices](https://prometheus.io/docs/practices/naming/#base-units)\n- Dropped support for node 4\n\n[11.0.0]: https://github.com/siimon/prom-client/compare/v10.2.3...v11.0.0\n\n## [10.2.3] - 2018-02-28\n\n### Breaking\n\n### Changed\n\n- Fixed issue that `registry.getMetricsAsJSON()` ignores registry default labels\n\n### Added\n\n[10.2.3]: https://github.com/siimon/prom-client/compare/v10.2.2...v10.2.3\n\n## [10.2.2] - 2017-11-02\n\n### Changed\n\n- Fixed invalid `process_virtual_memory_bytes` reported under linux\n\n## [10.2.1] - 2017-10-27\n\n### Changed\n\n- Only resolve/reject `clusterMetrics` promise if no callback is provided\n\n## [10.2.0] - 2017-10-16\n\n### Changed\n\n- Don't add event listeners if cluster module is not used.\n- Fixed issue with counters having extra records when using empty labels\n\n### Added\n\n- Added `reset` to Counter and Gauge\n- Added `resetMetrics` to register to calling `reset` of all metric instances\n\n## [10.1.1] - 2017-09-26\n\n### Changed\n\n- Update TypeScript definitions and JSDoc comments to match JavaScript sources\n- Fix lexical scope of `arguments` in cluster code\n\n## [10.1.0] - 2017-09-04\n\n### Added\n\n- Support aggregating metrics across workers in a Node.js cluster.\n\n## [10.0.4] - 2017-08-22\n\n### Changed\n\n- Include invalid values in the error messages\n\n## [10.0.3] - 2017-08-07\n\n### Added\n\n- Added registerMetric to definitions file\n\n### Changed\n\n- Fixed typing of DefaultMetricsCollectorConfiguration in definitions file\n- Don't pass timestamps through to pushgateway by default\n\n## [10.0.2] - 2017-07-07\n\n### Changed\n\n- Don't poll default metrics every single tick\n\n## [10.0.1] - 2017-07-06\n\n### Added\n\n- Metrics should be initialized to 0 when there are no labels\n\n## [10.0.0] - 2017-07-04\n\n### Breaking\n\n- Print deprecation warning when metrics are constructed using non-objects\n- Print deprecation warning when `collectDefaultMetrics` is called with a number\n\n### Added\n\n- Ability to set default labels by registry\n- Allow passing in `registry` as second argument to `collectDefaultMetrics` to\n  use that instead of the default registry\n\n### Changed\n\n- Convert code base to ES2015 code (node 4)\n  - add engines field to package.json\n  - Use object shorthand\n  - Remove `util-extend` in favor of `Object.assign`\n  - Arrow functions over binding or putting `this` in a variable\n  - Use template strings\n  - `prototype` -> `class`\n\n## [9.1.1] - 2017-06-17\n\n### Changed\n\n- Don't set timestamps for metrics that are never updated\n\n## [9.1.0] - 2017-06-07\n\n### Added\n\n- Ability to merge registries\n\n### Changed\n\n- Correct typedefs for object constructor of metrics\n\n## [9.0.0] - 2017-05-06\n\n### Added\n\n- Support for multiple registers\n- Support for object literals in metric constructors\n- Timestamp support\n\n### Changed\n\n- Collection of default metrics is now disabled by default. Start collection by\n  running `collectDefaultMetrics()`.\n\n### Deprecated\n\n- Creating metrics with one argument per parameter - use object literals\n  instead.\n\n[10.2.2]: https://github.com/siimon/prom-client/compare/v10.2.1...v10.2.2\n[10.2.1]: https://github.com/siimon/prom-client/compare/v10.2.0...v10.2.1\n[10.2.0]: https://github.com/siimon/prom-client/compare/v10.1.1...v10.2.0\n[10.1.1]: https://github.com/siimon/prom-client/compare/v10.1.0...v10.1.1\n[10.1.0]: https://github.com/siimon/prom-client/compare/v10.0.4...v10.1.0\n[10.0.4]: https://github.com/siimon/prom-client/compare/v10.0.3...v10.0.4\n[10.0.3]: https://github.com/siimon/prom-client/compare/v10.0.2...v10.0.3\n[10.0.2]: https://github.com/siimon/prom-client/compare/v10.0.1...v10.0.2\n[10.0.1]: https://github.com/siimon/prom-client/compare/v10.0.0...v10.0.1\n[10.0.0]: https://github.com/siimon/prom-client/compare/v9.1.1...v10.0.0\n[9.1.1]: https://github.com/siimon/prom-client/compare/v9.1.0...v9.1.1\n[9.1.0]: https://github.com/siimon/prom-client/compare/v9.0.0...v9.1.0\n[9.0.0]: https://github.com/siimon/prom-client/commit/1ef835f908e1a5032f228bbc754479fe7ccf5201\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0751953125,
          "content": "                                Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2015 Simon Nyberg\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.5966796875,
          "content": "# Prometheus client for node.js [![Actions Status](https://github.com/siimon/prom-client/workflows/Node.js%20CI/badge.svg?branch=master)](https://github.com/siimon/prom-client/actions)\n\nA prometheus client for Node.js that supports histogram, summaries, gauges and\ncounters.\n\n## Usage\n\nSee example folder for a sample usage. The library does not bundle any web\nframework. To expose the metrics, respond to Prometheus's scrape requests with\nthe result of `await registry.metrics()`.\n\n### Usage with Node.js's `cluster` module\n\nNode.js's `cluster` module spawns multiple processes and hands off socket\nconnections to those workers. Returning metrics from a worker's local registry\nwill only reveal that individual worker's metrics, which is generally\nundesirable. To solve this, you can aggregate all of the workers' metrics in the\nmaster process. See `example/cluster.js` for an example.\n\nDefault metrics use sensible aggregation methods. (Note, however, that the event\nloop lag mean and percentiles are averaged, which is not perfectly accurate.)\nCustom metrics are summed across workers by default. To use a different\naggregation method, set the `aggregator` property in the metric config to one of\n'sum', 'first', 'min', 'max', 'average' or 'omit'. (See `lib/metrics/version.js`\nfor an example.)\n\nIf you need to expose metrics about an individual worker, you can include a\nvalue that is unique to the worker (such as the worker ID or process ID) in a\nlabel. (See `example/server.js` for an example using\n`worker_${cluster.worker.id}` as a label value.)\n\nMetrics are aggregated from the global registry by default. To use a different\nregistry, call\n`client.AggregatorRegistry.setRegistries(registryOrArrayOfRegistries)` from the\nworker processes.\n\n## API\n\n### Default metrics\n\nThere are some default metrics recommended by Prometheus\n[itself](https://prometheus.io/docs/instrumenting/writing_clientlibs/#standard-and-runtime-collectors).\nTo collect these, call `collectDefaultMetrics`. In addition, some\nNode.js-specific metrics are included, such as event loop lag, active handles,\nGC and Node.js version. See [lib/metrics](lib/metrics) for a list of all\nmetrics.\n\nNOTE: Some of the metrics, concerning File Descriptors and Memory, are only\navailable on Linux.\n\n`collectDefaultMetrics` optionally accepts a config object with following entries:\n\n- `prefix` an optional prefix for metric names. Default: no prefix.\n- `register` to which registry the metrics should be registered. Default: the global default registry.\n- `gcDurationBuckets` with custom buckets for GC duration histogram. Default buckets of GC duration histogram are `[0.001, 0.01, 0.1, 1, 2, 5]` (in seconds).\n- `eventLoopMonitoringPrecision` with sampling rate in milliseconds. Must be greater than zero. Default: 10.\n\nTo register metrics to another registry, pass it in as `register`:\n\n```js\nconst client = require('prom-client');\nconst collectDefaultMetrics = client.collectDefaultMetrics;\nconst Registry = client.Registry;\nconst register = new Registry();\ncollectDefaultMetrics({ register });\n```\n\nTo use custom buckets for GC duration histogram, pass it in as `gcDurationBuckets`:\n\n```js\nconst client = require('prom-client');\nconst collectDefaultMetrics = client.collectDefaultMetrics;\ncollectDefaultMetrics({ gcDurationBuckets: [0.1, 0.2, 0.3] });\n```\n\nTo prefix metric names with your own arbitrary string, pass in a `prefix`:\n\n```js\nconst client = require('prom-client');\nconst collectDefaultMetrics = client.collectDefaultMetrics;\nconst prefix = 'my_application_';\ncollectDefaultMetrics({ prefix });\n```\n\nTo apply generic labels to all default metrics, pass an object to the `labels` property (useful if you're working in a clustered environment):\n\n```js\nconst client = require('prom-client');\nconst collectDefaultMetrics = client.collectDefaultMetrics;\ncollectDefaultMetrics({\n  labels: { NODE_APP_INSTANCE: process.env.NODE_APP_INSTANCE },\n});\n```\n\nYou can get the full list of metrics by inspecting\n`client.collectDefaultMetrics.metricsList`.\n\nDefault metrics are collected on scrape of metrics endpoint,\nnot on an interval.\n\n```js\nconst client = require('prom-client');\n\nconst collectDefaultMetrics = client.collectDefaultMetrics;\n\ncollectDefaultMetrics();\n```\n\n### Custom Metrics\n\nAll metric types have two mandatory parameters: `name` and `help`. Refer to\n<https://prometheus.io/docs/practices/naming/> for guidance on naming metrics.\n\nFor metrics based on point-in-time observations (e.g. current memory usage, as\nopposed to HTTP request durations observed continuously in a histogram), you\nshould provide a `collect()` function, which will be invoked when Prometheus\nscrapes your metrics endpoint. `collect()` can either be synchronous or return a\npromise. See **Gauge** below for an example. (Note that you should not update\nmetric values in a `setInterval` callback; do so in this `collect` function\ninstead.)\n\nSee [**Labels**](#labels) for information on how to configure labels for all\nmetric types.\n\n#### Counter\n\nCounters go up, and reset when the process restarts.\n\n```js\nconst client = require('prom-client');\nconst counter = new client.Counter({\n  name: 'metric_name',\n  help: 'metric_help',\n});\ncounter.inc(); // Increment by 1\ncounter.inc(10); // Increment by 10\n```\n\n#### Gauge\n\nGauges are similar to Counters but a Gauge's value can be decreased.\n\n```js\nconst client = require('prom-client');\nconst gauge = new client.Gauge({ name: 'metric_name', help: 'metric_help' });\ngauge.set(10); // Set to 10\ngauge.inc(); // Increment 1\ngauge.inc(10); // Increment 10\ngauge.dec(); // Decrement by 1\ngauge.dec(10); // Decrement by 10\n```\n\n##### Configuration\n\nIf the gauge is used for a point-in-time observation, you should provide a\n`collect` function:\n\n```js\nconst client = require('prom-client');\nnew client.Gauge({\n  name: 'metric_name',\n  help: 'metric_help',\n  collect() {\n    // Invoked when the registry collects its metrics' values.\n    // This can be synchronous or it can return a promise/be an async function.\n    this.set(/* the current value */);\n  },\n});\n```\n\n```js\n// Async version:\nconst client = require('prom-client');\nnew client.Gauge({\n  name: 'metric_name',\n  help: 'metric_help',\n  async collect() {\n    // Invoked when the registry collects its metrics' values.\n    const currentValue = await somethingAsync();\n    this.set(currentValue);\n  },\n});\n```\n\nNote that you should not use arrow functions for `collect` because arrow\nfunctions will not have the correct value for `this`.\n\n##### Utility Functions\n\n```js\n// Set value to current time in seconds:\ngauge.setToCurrentTime();\n\n// Record durations:\nconst end = gauge.startTimer();\nhttp.get('url', res => {\n  end();\n});\n```\n\n#### Histogram\n\nHistograms track sizes and frequency of events.\n\n##### Configuration\n\nThe defaults buckets are intended to cover usual web/RPC requests, but they can\nbe overridden. (See also [**Bucket Generators**](#bucket-generators).)\n\n```js\nconst client = require('prom-client');\nnew client.Histogram({\n  name: 'metric_name',\n  help: 'metric_help',\n  buckets: [0.1, 5, 15, 50, 100, 500],\n});\n```\n\n##### Examples\n\n```js\nconst client = require('prom-client');\nconst histogram = new client.Histogram({\n  name: 'metric_name',\n  help: 'metric_help',\n});\nhistogram.observe(10); // Observe value in histogram\n```\n\n##### Utility Methods\n\n```js\nconst end = histogram.startTimer();\nxhrRequest(function (err, res) {\n  const seconds = end(); // Observes and returns the value to xhrRequests duration in seconds\n});\n```\n\n#### Summary\n\nSummaries calculate percentiles of observed values.\n\n##### Configuration\n\nThe default percentiles are: 0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999. But they\ncan be overridden by specifying a `percentiles` array. (See also\n[**Bucket Generators**](#bucket-generators).)\n\n```js\nconst client = require('prom-client');\nnew client.Summary({\n  name: 'metric_name',\n  help: 'metric_help',\n  percentiles: [0.01, 0.1, 0.9, 0.99],\n});\n```\n\nTo enable the sliding window functionality for summaries you need to add\n`maxAgeSeconds` and `ageBuckets` to the config like this:\n\n```js\nconst client = require('prom-client');\nnew client.Summary({\n  name: 'metric_name',\n  help: 'metric_help',\n  maxAgeSeconds: 600,\n  ageBuckets: 5,\n  pruneAgedBuckets: false,\n});\n```\n\nThe `maxAgeSeconds` will tell how old a bucket can be before it is reset and\n`ageBuckets` configures how many buckets we will have in our sliding window for\nthe summary. If `pruneAgedBuckets` is `false` (default), the metric value will\nalways be present, even when empty (its percentile values will be `0`). Set\n`pruneAgedBuckets` to `true` if you don't want to export it when it is empty.\n\n##### Examples\n\n```js\nconst client = require('prom-client');\nconst summary = new client.Summary({\n  name: 'metric_name',\n  help: 'metric_help',\n});\nsummary.observe(10);\n```\n\n##### Utility Methods\n\n```js\nconst end = summary.startTimer();\nxhrRequest(function (err, res) {\n  end(); // Observes the value to xhrRequests duration in seconds\n});\n```\n\n### Labels\n\nAll metrics can take a `labelNames` property in the configuration object. All\nlabel names that the metric support needs to be declared here. There are two\nways to add values to the labels:\n\n```js\nconst client = require('prom-client');\nconst gauge = new client.Gauge({\n  name: 'metric_name',\n  help: 'metric_help',\n  labelNames: ['method', 'statusCode'],\n});\n\n// 1st version: Set value to 100 with \"method\" set to \"GET\" and \"statusCode\" to \"200\"\ngauge.set({ method: 'GET', statusCode: '200' }, 100);\n// 2nd version: Same effect as above\ngauge.labels({ method: 'GET', statusCode: '200' }).set(100);\n// 3rd version: And again the same effect as above\ngauge.labels('GET', '200').set(100);\n```\n\nIt is also possible to use timers with labels, both before and after the timer\nis created:\n\n```js\nconst end = startTimer({ method: 'GET' }); // Set method to GET, we don't know statusCode yet\nxhrRequest(function (err, res) {\n  if (err) {\n    end({ statusCode: '500' }); // Sets value to xhrRequest duration in seconds with statusCode 500\n  } else {\n    end({ statusCode: '200' }); // Sets value to xhrRequest duration in seconds with statusCode 200\n  }\n});\n```\n\n#### Zeroing metrics with Labels\n\nMetrics with labels can not be exported before they have been observed at least\nonce since the possible label values are not known before they're observed.\n\nFor histograms, this can be solved by explicitly zeroing all expected label values:\n\n```js\nconst histogram = new client.Histogram({\n  name: 'metric_name',\n  help: 'metric_help',\n  buckets: [0.1, 5, 15, 50, 100, 500],\n  labels: ['method'],\n});\nhistogram.zero({ method: 'GET' });\nhistogram.zero({ method: 'POST' });\n```\n\n#### Strongly typed Labels\n\nTypescript can also enforce label names using `as const`\n\n```typescript\nimport * as client from 'prom-client';\n\nconst counter = new client.Counter({\n  name: 'metric_name',\n  help: 'metric_help',\n  // add `as const` here to enforce label names\n  labelNames: ['method'] as const,\n});\n\n// Ok\ncounter.inc({ method: 1 });\n\n// this is an error since `'methods'` is not a valid `labelName`\n// @ts-expect-error\ncounter.inc({ methods: 1 });\n```\n\n#### Default Labels (segmented by registry)\n\nStatic labels may be applied to every metric emitted by a registry:\n\n```js\nconst client = require('prom-client');\nconst defaultLabels = { serviceName: 'api-v1' };\nclient.register.setDefaultLabels(defaultLabels);\n```\n\nThis will output metrics in the following way:\n\n```\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes{serviceName=\"api-v1\"} 33853440 1498510040309\n```\n\nDefault labels will be overridden if there is a name conflict.\n\n`register.clear()` will clear default labels.\n\n### Exemplars\n\nThe exemplars defined in the OpenMetrics specification can be enabled on Counter\nand Histogram metric types. The default metrics have support for OpenTelemetry,\nthey will populate the exemplars with the labels `{traceId, spanId}` and their\ncorresponding values.\n\nThe format for `inc()` and `observe()` calls are different if exemplars are\nenabled. They get a single object with the format\n`{labels, value, exemplarLabels}`.\n\nWhen using exemplars, the registry used for metrics should be set to OpenMetrics\ntype (including the global or default registry if no registries are specified).\n\n### Registry type\n\nThe library supports both the old Prometheus format and the OpenMetrics format.\nThe format can be set per registry. For default metrics:\n\n```js\nconst Prometheus = require('prom-client');\nPrometheus.register.setContentType(\n  Prometheus.Registry.OPENMETRICS_CONTENT_TYPE,\n);\n```\n\nCurrently available registry types are defined by the content types:\n\n**PROMETHEUS_CONTENT_TYPE** - version 0.0.4 of the original Prometheus metrics,\nthis is currently the default registry type.\n\n**OPENMETRICS_CONTENT_TYPE** - defaults to version 1.0.0 of the\n[OpenMetrics standard](https://github.com/OpenObservability/OpenMetrics/blob/d99b705f611b75fec8f450b05e344e02eea6921d/specification/OpenMetrics.md).\n\nThe HTTP Content-Type string for each registry type is exposed both at module\nlevel (`prometheusContentType` and `openMetricsContentType`) and as static\nproperties on the `Registry` object.\n\nThe `contentType` constant exposed by the module returns the default content\ntype when creating a new registry, currently defaults to Prometheus type.\n\n### Multiple registries\n\nBy default, metrics are automatically registered to the global registry (located\nat `require('prom-client').register`). You can prevent this by specifying\n`registers: []` in the metric constructor configuration.\n\nUsing non-global registries requires creating a Registry instance and passing it\ninside `registers` in the metric configuration object. Alternatively you can\npass an empty `registers` array and register it manually.\n\nRegistry has a `merge` function that enables you to expose multiple registries\non the same endpoint. If the same metric name exists in both registries, an\nerror will be thrown.\n\nMerging registries of different types is undefined. The user needs to make sure\nall used registries have the same type (Prometheus or OpenMetrics versions).\n\n```js\nconst client = require('prom-client');\nconst registry = new client.Registry();\nconst counter = new client.Counter({\n  name: 'metric_name',\n  help: 'metric_help',\n  registers: [registry], // specify a non-default registry\n});\nconst histogram = new client.Histogram({\n  name: 'metric_name',\n  help: 'metric_help',\n  registers: [], // don't automatically register this metric\n});\nregistry.registerMetric(histogram); // register metric manually\ncounter.inc();\n\nconst mergedRegistries = client.Registry.merge([registry, client.register]);\n```\n\nIf you want to use multiple or non-default registries with the Node.js `cluster`\nmodule, you will need to set the registry/registries to aggregate from:\n\n```js\nconst AggregatorRegistry = client.AggregatorRegistry;\nAggregatorRegistry.setRegistries(registry);\n// or for multiple registries:\nAggregatorRegistry.setRegistries([registry1, registry2]);\n```\n\n### Register\n\nYou can get all metrics by running `await register.metrics()`, which will return\na string in the Prometheus exposition format.\n\n#### Getting a single metric value in Prometheus exposition format\n\nIf you need to output a single metric in the Prometheus exposition format, you\ncan use `await register.getSingleMetricAsString(*name of metric*)`, which will\nreturn a string for Prometheus to consume.\n\n#### Getting a single metric\n\nIf you need to get a reference to a previously registered metric, you can use\n`register.getSingleMetric(*name of metric*)`.\n\n#### Removing metrics\n\nYou can remove all metrics by calling `register.clear()`. You can also remove a\nsingle metric by calling `register.removeSingleMetric(*name of metric*)`.\n\n#### Resetting metrics\n\nIf you need to reset all metrics, you can use `register.resetMetrics()`. The\nmetrics will remain present in the register and can be used without the need to\ninstantiate them again, like you would need to do after `register.clear()`.\n\n#### Cluster metrics\n\nYou can get aggregated metrics for all workers in a Node.js cluster with\n`await register.clusterMetrics()`. This method returns a promise that resolves\nwith a metrics string suitable for Prometheus to consume.\n\n```js\nconst metrics = await register.clusterMetrics();\n\n// - or -\n\nregister\n  .clusterMetrics()\n  .then(metrics => {\n    /* ... */\n  })\n  .catch(err => {\n    /* ... */\n  });\n```\n\n### Pushgateway\n\nIt is possible to push metrics via a\n[Pushgateway](https://github.com/prometheus/pushgateway).\n\n```js\nconst client = require('prom-client');\nlet gateway = new client.Pushgateway('http://127.0.0.1:9091');\n\ngateway.pushAdd({ jobName: 'test' })\n\t.then(({resp, body}) => {\n\t\t/* ... */\n\t})\n\t.catch(err => {\n\t\t/* ... */\n\t})); //Add metric and overwrite old ones\ngateway.push({ jobName: 'test' })\n\t.then(({resp, body}) => {\n\t\t/* ... */\n\t})\n\t.catch(err => {\n\t\t/* ... */\n\t})); //Overwrite all metrics (use PUT)\ngateway.delete({ jobName: 'test' })\n\t.then(({resp, body}) => {\n\t\t/* ... */\n\t})\n\t.catch(err => {\n\t\t/* ... */\n\t})); //Delete all metrics for jobName\n\n//All gateway requests can have groupings on it\ngateway.pushAdd({ jobName: 'test', groupings: { key: 'value' } })\n\t.then(({resp, body}) => {\n\t\t/* ... */\n\t})\n\t.catch(err => {\n\t\t/* ... */\n\t}));\n\n// It's possible to extend the Pushgateway with request options from nodes core\n// http/https library. In particular, you might want to provide an agent so that\n// TCP connections are reused.\ngateway = new client.Pushgateway('http://127.0.0.1:9091', {\n  timeout: 5000, //Set the request timeout to 5000ms\n  agent: new http.Agent({\n    keepAlive: true,\n    keepAliveMsec: 10000,\n    maxSockets: 5,\n  }),\n});\n```\n\nSome gateways such as [Gravel Gateway](https://github.com/sinkingpoint/prometheus-gravel-gateway) do not support grouping by job name, exposing a plain `/metrics` endpoint instead of `/metrics/job/<jobName>`. It's possible to configure a gateway instance to not require a jobName in the options argument.\n\n```js\ngravelGateway = new client.Pushgateway('http://127.0.0.1:9091', {\n  timeout: 5000,\n  requireJobName: false,\n});\ngravelGateway.pushAdd();\n```\n\n### Bucket Generators\n\nFor convenience, there are two bucket generator functions - linear and\nexponential.\n\n```js\nconst client = require('prom-client');\nnew client.Histogram({\n  name: 'metric_name',\n  help: 'metric_help',\n  buckets: client.linearBuckets(0, 10, 20), //Create 20 buckets, starting on 0 and a width of 10\n});\n\nnew client.Histogram({\n  name: 'metric_name',\n  help: 'metric_help',\n  buckets: client.exponentialBuckets(1, 2, 5), //Create 5 buckets, starting on 1 and with a factor of 2\n});\n```\n\n### Garbage Collection Metrics\n\nTo avoid native dependencies in this module, GC statistics for bytes reclaimed\nin each GC sweep are kept in a separate module:\nhttps://github.com/SimenB/node-prometheus-gc-stats. (Note that that metric may\nno longer be accurate now that v8 uses parallel garbage collection.)\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.d.ts",
          "type": "blob",
          "size": 19.482421875,
          "content": "// Type definitions for prom-client\n// Definitions by: Simon Nyberg http://twitter.com/siimon_nyberg\n\nexport type Charset = 'utf-8';\n\nexport type PrometheusMIME = 'text/plain';\nexport type PrometheusMetricsVersion = '0.0.4';\n\nexport type OpenMetricsMIME = 'application/openmetrics-text';\nexport type OpenMetricsVersion = '1.0.0';\n\nexport type OpenMetricsContentType =\n\t`${OpenMetricsMIME}; version=${OpenMetricsVersion}; charset=${Charset}`;\nexport type PrometheusContentType =\n\t`${PrometheusMIME}; version=${PrometheusMetricsVersion}; charset=${Charset}`;\n\nexport type RegistryContentType =\n\t| PrometheusContentType\n\t| OpenMetricsContentType;\n\n/**\n * Container for all registered metrics\n */\nexport class Registry<\n\tBoundRegistryContentType extends RegistryContentType = PrometheusContentType,\n> {\n\t/**\n\t * Get string representation for all metrics\n\t */\n\tmetrics(): Promise<string>;\n\n\t/**\n\t * Remove all metrics from the registry\n\t */\n\tclear(): void;\n\n\t/**\n\t * Reset all metrics in the registry\n\t */\n\tresetMetrics(): void;\n\n\t/**\n\t * Register metric to register\n\t * @param metric Metric to add to register\n\t */\n\tregisterMetric<T extends string>(metric: Metric<T>): void;\n\n\t/**\n\t * Get all metrics as objects\n\t */\n\tgetMetricsAsJSON(): Promise<MetricObjectWithValues<MetricValue<string>>[]>;\n\n\t/**\n\t * Get all metrics as objects\n\t */\n\tgetMetricsAsArray(): MetricObject[];\n\n\t/**\n\t * Remove a single metric\n\t * @param name The name of the metric to remove\n\t */\n\tremoveSingleMetric(name: string): void;\n\n\t/**\n\t * Get a single metric\n\t * @param name The name of the metric\n\t */\n\tgetSingleMetric<T extends string>(name: string): Metric<T> | undefined;\n\n\t/**\n\t * Set static labels to every metric emitted by this registry\n\t * @param labels of name/value pairs:\n\t * { defaultLabel: \"value\", anotherLabel: \"value 2\" }\n\t */\n\tsetDefaultLabels(labels: object): void;\n\n\t/**\n\t * Get a string representation of a single metric by name\n\t * @param name The name of the metric\n\t */\n\tgetSingleMetricAsString(name: string): Promise<string>;\n\n\t/**\n\t * Gets the Content-Type of the metrics for use in the response headers.\n\t */\n\treadonly contentType: BoundRegistryContentType;\n\n\t/**\n\t * Set the content type of a registry. Used to change between Prometheus and\n\t * OpenMetrics versions.\n\t * @param contentType The type of the registry\n\t */\n\tsetContentType(contentType: BoundRegistryContentType): void;\n\n\t/**\n\t * Merge registers\n\t * @param registers The registers you want to merge together\n\t */\n\tstatic merge(registers: Registry[]): Registry;\n\n\t/**\n\t * HTTP Prometheus Content-Type for metrics response headers.\n\t */\n\tstatic PROMETHEUS_CONTENT_TYPE: PrometheusContentType;\n\n\t/**\n\t * HTTP OpenMetrics Content-Type for metrics response headers.\n\t */\n\tstatic OPENMETRICS_CONTENT_TYPE: OpenMetricsContentType;\n}\nexport type Collector = () => void;\n\n/**\n * The register that contains all metrics\n */\nexport const register: Registry;\n\n/**\n * HTTP Content-Type for metrics response headers for the default registry,\n * defaults to Prometheus text format.\n */\nexport const contentType: RegistryContentType;\n\n/**\n * HTTP Prometheus Content-Type for metrics response headers.\n */\nexport const prometheusContentType: PrometheusContentType;\n\n/**\n * HTTP OpenMetrics Content-Type for metrics response headers.\n */\nexport const openMetricsContentType: OpenMetricsContentType;\n\nexport class AggregatorRegistry<\n\tT extends RegistryContentType,\n> extends Registry<T> {\n\t/**\n\t * Gets aggregated metrics for all workers.\n\t * @return {Promise<string>} Promise that resolves with the aggregated\n\t * metrics.\n\t */\n\tclusterMetrics(): Promise<string>;\n\n\t/**\n\t * Creates a new Registry instance from an array of metrics that were\n\t * created by `registry.getMetricsAsJSON()`. Metrics are aggregated using\n\t * the method specified by their `aggregator` property, or by summation if\n\t * `aggregator` is undefined.\n\t * @param {Array} metricsArr Array of metrics, each of which created by\n\t *   `registry.getMetricsAsJSON()`.\n\t * @return {Registry} aggregated registry.\n\t */\n\tstatic aggregate<T extends RegistryContentType>(\n\t\tmetricsArr: Array<object>,\n\t): Registry<T>; // TODO Promise?\n\n\t/**\n\t * Sets the registry or registries to be aggregated. Call from workers to\n\t * use a registry/registries other than the default global registry.\n\t * @param {Array<Registry>|Registry} regs Registry or registries to be\n\t *   aggregated.\n\t * @return {void}\n\t */\n\tstatic setRegistries(\n\t\tregs:\n\t\t\t| Array<\n\t\t\t\t\tRegistry<PrometheusContentType> | Registry<OpenMetricsContentType>\n\t\t\t  >\n\t\t\t| Registry<PrometheusContentType>\n\t\t\t| Registry<OpenMetricsContentType>,\n\t): void;\n}\n\n/**\n * General metric type\n */\nexport type Metric<T extends string = string> =\n\t| Counter<T>\n\t| Gauge<T>\n\t| Summary<T>\n\t| Histogram<T>;\n\n/**\n * Aggregation methods, used for aggregating metrics in a Node.js cluster.\n */\nexport type Aggregator = 'omit' | 'sum' | 'first' | 'min' | 'max' | 'average';\n\nexport enum MetricType {\n\tCounter,\n\tGauge,\n\tHistogram,\n\tSummary,\n}\n\ntype CollectFunction<T> = (this: T) => void | Promise<void>;\n\ninterface MetricObject {\n\tname: string;\n\thelp: string;\n\ttype: MetricType;\n\taggregator: Aggregator;\n\tcollect: CollectFunction<any>;\n}\n\ninterface MetricObjectWithValues<T extends MetricValue<string>>\n\textends MetricObject {\n\tvalues: T[];\n}\n\ntype MetricValue<T extends string> = {\n\tvalue: number;\n\tlabels: LabelValues<T>;\n};\n\ntype MetricValueWithName<T extends string> = MetricValue<T> & {\n\tmetricName?: string;\n};\n\ntype LabelValues<T extends string> = Partial<Record<T, string | number>>;\n\ninterface MetricConfiguration<T extends string> {\n\tname: string;\n\thelp: string;\n\tlabelNames?: T[] | readonly T[];\n\tregisters?: (\n\t\t| Registry<PrometheusContentType>\n\t\t| Registry<OpenMetricsContentType>\n\t)[];\n\taggregator?: Aggregator;\n\tcollect?: CollectFunction<any>;\n\tenableExemplars?: boolean;\n}\n\nexport interface CounterConfiguration<T extends string>\n\textends MetricConfiguration<T> {\n\tcollect?: CollectFunction<Counter<T>>;\n}\n\nexport interface IncreaseDataWithExemplar<T extends string> {\n\tvalue?: number;\n\tlabels?: LabelValues<T>;\n\texemplarLabels?: LabelValues<T>;\n}\n\nexport interface ObserveDataWithExemplar<T extends string> {\n\tvalue: number;\n\tlabels?: LabelValues<T>;\n\texemplarLabels?: LabelValues<T>;\n}\n\n/**\n * A counter is a cumulative metric that represents a single numerical value that only ever goes up\n */\nexport class Counter<T extends string = string> {\n\t/**\n\t * @param configuration Configuration when creating a Counter metric. Name and Help is required.\n\t */\n\tconstructor(configuration: CounterConfiguration<T>);\n\n\t/**\n\t * Increment for given labels\n\t * @param labels Object with label keys and values\n\t * @param value The number to increment with\n\t */\n\tinc(labels: LabelValues<T>, value?: number): void;\n\n\t/**\n\t * Increment with value\n\t * @param value The value to increment with\n\t */\n\tinc(value?: number): void;\n\n\t/**\n\t * Increment with exemplars\n\t * @param incData Object with labels, value and exemplars for an increase\n\t */\n\tinc(incData: IncreaseDataWithExemplar<T>): void;\n\n\t/**\n\t * Get counter metric object\n\t */\n\tget(): Promise<MetricObjectWithValues<MetricValue<T>>>;\n\n\t/**\n\t * Return the child for given labels\n\t * @param values Label values\n\t * @return Configured counter with given labels\n\t */\n\tlabels(...values: string[]): Counter.Internal;\n\n\t/**\n\t * Return the child for given labels\n\t * @param labels Object with label keys and values\n\t * @return Configured counter with given labels\n\t */\n\tlabels(labels: LabelValues<T>): Counter.Internal;\n\n\t/**\n\t * Reset counter values\n\t */\n\treset(): void;\n\n\t/**\n\t * Remove metrics for the given label values\n\t * @param values Label values\n\t */\n\tremove(...values: string[]): void;\n\n\t/**\n\t * Remove metrics for the given label values\n\t * @param labels Object with label keys and values\n\t */\n\tremove(labels: LabelValues<T>): void;\n}\n\nexport namespace Counter {\n\tinterface Internal {\n\t\t/**\n\t\t * Increment with value\n\t\t * @param value The value to increment with\n\t\t */\n\t\tinc(value?: number): void;\n\t}\n}\n\nexport interface GaugeConfiguration<T extends string>\n\textends MetricConfiguration<T> {\n\tcollect?: CollectFunction<Gauge<T>>;\n}\n\n/**\n * A gauge is a metric that represents a single numerical value that can arbitrarily go up and down.\n */\nexport class Gauge<T extends string = string> {\n\t/**\n\t * @param configuration Configuration when creating a Gauge metric. Name and Help is mandatory\n\t */\n\tconstructor(configuration: GaugeConfiguration<T>);\n\n\t/**\n\t * Increment gauge for given labels\n\t * @param labels Object with label keys and values\n\t * @param value The value to increment with\n\t */\n\tinc(labels: LabelValues<T>, value?: number): void;\n\n\t/**\n\t * Increment gauge\n\t * @param value The value to increment with\n\t */\n\tinc(value?: number): void;\n\n\t/**\n\t * Decrement gauge\n\t * @param labels Object with label keys and values\n\t * @param value Value to decrement with\n\t */\n\tdec(labels: LabelValues<T>, value?: number): void;\n\n\t/**\n\t * Decrement gauge\n\t * @param value The value to decrement with\n\t */\n\tdec(value?: number): void;\n\n\t/**\n\t * Set gauge value for labels\n\t * @param labels Object with label keys and values\n\t * @param value The value to set\n\t */\n\tset(labels: LabelValues<T>, value: number): void;\n\n\t/**\n\t * Set gauge value\n\t * @param value The value to set\n\t */\n\tset(value: number): void;\n\n\t/**\n\t * Get gauge metric object\n\t */\n\tget(): Promise<MetricObjectWithValues<MetricValue<T>>>;\n\n\t/**\n\t * Set gauge value to current epoch time in seconds\n\t * @param labels Object with label keys and values\n\t */\n\tsetToCurrentTime(labels?: LabelValues<T>): void;\n\n\t/**\n\t * Start a timer. Calling the returned function will set the gauge's value\n\t * to the observed duration in seconds.\n\t * @param labels Object with label keys and values\n\t * @return Function to invoke when timer should be stopped. The value it\n\t * returns is the timed duration.\n\t */\n\tstartTimer(labels?: LabelValues<T>): (labels?: LabelValues<T>) => number;\n\n\t/**\n\t * Return the child for given labels\n\t * @param values Label values\n\t * @return Configured gauge with given labels\n\t */\n\tlabels(...values: string[]): Gauge.Internal<T>;\n\n\t/**\n\t * Return the child for given labels\n\t * @param labels Object with label keys and values\n\t * @return Configured counter with given labels\n\t */\n\tlabels(labels: LabelValues<T>): Gauge.Internal<T>;\n\n\t/**\n\t * Reset gauge values\n\t */\n\treset(): void;\n\n\t/**\n\t * Remove metrics for the given label values\n\t * @param values Label values\n\t */\n\tremove(...values: string[]): void;\n\n\t/**\n\t * Remove metrics for the given label values\n\t * @param labels Object with label keys and values\n\t */\n\tremove(labels: LabelValues<T>): void;\n}\n\nexport namespace Gauge {\n\tinterface Internal<T extends string> {\n\t\t/**\n\t\t * Increment gauge with value\n\t\t * @param value The value to increment with\n\t\t */\n\t\tinc(value?: number): void;\n\n\t\t/**\n\t\t * Decrement with value\n\t\t * @param value The value to decrement with\n\t\t */\n\t\tdec(value?: number): void;\n\n\t\t/**\n\t\t * Set gauges value\n\t\t * @param value The value to set\n\t\t */\n\t\tset(value: number): void;\n\n\t\t/**\n\t\t * Set gauge value to current epoch time in ms\n\t\t */\n\t\tsetToCurrentTime(): void;\n\n\t\t/**\n\t\t * Start a timer. Calling the returned function will set the gauge's value\n\t\t * to the observed duration in seconds.\n\t\t * @return Function to invoke when timer should be stopped. The value it\n\t\t * returns is the timed duration.\n\t\t */\n\t\tstartTimer(): (labels?: LabelValues<T>) => number;\n\t}\n}\n\nexport interface HistogramConfiguration<T extends string>\n\textends MetricConfiguration<T> {\n\tbuckets?: number[];\n\tcollect?: CollectFunction<Histogram<T>>;\n}\n\n/**\n * A histogram samples observations (usually things like request durations or response sizes) and counts them in configurable buckets\n */\nexport class Histogram<T extends string = string> {\n\t/**\n\t * @param configuration Configuration when creating the Histogram. Name and Help is mandatory\n\t */\n\tconstructor(configuration: HistogramConfiguration<T>);\n\n\t/**\n\t * Observe value\n\t * @param value The value to observe\n\t */\n\tobserve(value: number): void;\n\t/**\n\t * Observe value for given labels\n\t * @param labels Object with label keys and values\n\t * @param value The value to observe\n\t */\n\tobserve(labels: LabelValues<T>, value: number): void;\n\n\t/**\n\t * Observe with exemplars\n\t * @param observeData Object with labels, value and exemplars for an observation\n\t */\n\tobserve(observeData: ObserveDataWithExemplar<T>): void;\n\n\t/**\n\t * Get histogram metric object\n\t */\n\tget(): Promise<MetricObjectWithValues<MetricValueWithName<T>>>;\n\n\t/**\n\t * Start a timer. Calling the returned function will observe the duration in\n\t * seconds in the histogram.\n\t * @param labels Object with label keys and values\n\t * @return Function to invoke when timer should be stopped. The value it\n\t * returns is the timed duration.\n\t */\n\tstartTimer(labels?: LabelValues<T>): (labels?: LabelValues<T>) => number;\n\n\t/**\n\t * Start a timer with exemplar. Calling the returned function will observe the duration in\n\t * seconds in the histogram.\n\t * @param labels Object with label keys and values\n\t * @param exemplarLabels Object with label keys and values for exemplars\n\t * @return Function to invoke when timer should be stopped. The value it\n\t * returns is the timed duration.\n\t */\n\tstartTimer(\n\t\tlabels?: LabelValues<T>,\n\t\texemplarLabels?: LabelValues<T>,\n\t): (labels?: LabelValues<T>, exemplarLabels?: LabelValues<T>) => number;\n\n\t/**\n\t * Reset histogram values\n\t */\n\treset(): void;\n\n\t/**\n\t * Initialize the metrics for the given combination of labels to zero\n\t */\n\tzero(labels: LabelValues<T>): void;\n\n\t/**\n\t * Return the child for given labels\n\t * @param values Label values\n\t * @return Configured histogram with given labels\n\t */\n\tlabels(...values: string[]): Histogram.Internal<T>;\n\n\t/**\n\t * Return the child for given labels\n\t * @param labels Object with label keys and values\n\t * @return Configured counter with given labels\n\t */\n\tlabels(labels: LabelValues<T>): Histogram.Internal<T>;\n\n\t/**\n\t * Remove metrics for the given label values\n\t * @param values Label values\n\t */\n\tremove(...values: string[]): void;\n\n\t/**\n\t * Remove metrics for the given label values\n\t * @param labels Object with label keys and values\n\t */\n\tremove(labels: LabelValues<T>): void;\n}\n\nexport namespace Histogram {\n\tinterface Internal<T extends string> {\n\t\t/**\n\t\t * Observe value\n\t\t * @param value The value to observe\n\t\t */\n\t\tobserve(value: number): void;\n\n\t\t/**\n\t\t * Start a timer. Calling the returned function will observe the\n\t\t * duration in seconds in the histogram.\n\t\t * @param labels Object with label keys and values\n\t\t * @return Function to invoke when timer should be stopped. The value it\n\t\t * returns is the timed duration.\n\t\t */\n\t\tstartTimer(): (labels?: LabelValues<T>) => void;\n\t}\n\n\tinterface Config {\n\t\t/**\n\t\t * Buckets used in the histogram\n\t\t */\n\t\tbuckets?: number[];\n\t}\n}\n\nexport interface SummaryConfiguration<T extends string>\n\textends MetricConfiguration<T> {\n\tpercentiles?: number[];\n\tmaxAgeSeconds?: number;\n\tageBuckets?: number;\n\tpruneAgedBuckets?: boolean;\n\tcompressCount?: number;\n\tcollect?: CollectFunction<Summary<T>>;\n}\n\n/**\n * A summary samples observations\n */\nexport class Summary<T extends string = string> {\n\t/**\n\t * @param configuration Configuration when creating Summary metric. Name and Help is mandatory\n\t */\n\tconstructor(configuration: SummaryConfiguration<T>);\n\n\t/**\n\t * Observe value in summary\n\t * @param value The value to observe\n\t */\n\tobserve(value: number): void;\n\t/**\n\t * Observe value for given labels\n\t * @param labels Object with label keys and values\n\t * @param value Value to observe\n\t */\n\tobserve(labels: LabelValues<T>, value: number): void;\n\n\t/**\n\t * Get summary metric object\n\t */\n\tget(): Promise<MetricObjectWithValues<MetricValueWithName<T>>>;\n\n\t/**\n\t * Start a timer. Calling the returned function will observe the duration in\n\t * seconds in the summary.\n\t * @param labels Object with label keys and values\n\t * @return Function to invoke when timer should be stopped\n\t */\n\tstartTimer(labels?: LabelValues<T>): (labels?: LabelValues<T>) => number;\n\n\t/**\n\t * Reset all values in the summary\n\t */\n\treset(): void;\n\n\t/**\n\t * Return the child for given labels\n\t * @param values Label values\n\t * @return Configured summary with given labels\n\t */\n\tlabels(...values: string[]): Summary.Internal<T>;\n\n\t/**\n\t * Return the child for given labels\n\t * @param labels Object with label keys and values\n\t * @return Configured counter with given labels\n\t */\n\tlabels(labels: LabelValues<T>): Summary.Internal<T>;\n\n\t/**\n\t * Remove metrics for the given label values\n\t * @param values Label values\n\t */\n\tremove(...values: string[]): void;\n\n\t/**\n\t * Remove metrics for the given label values\n\t * @param labels Object with label keys and values\n\t */\n\tremove(labels: LabelValues<T>): void;\n}\n\nexport namespace Summary {\n\tinterface Internal<T extends string> {\n\t\t/**\n\t\t * Observe value in summary\n\t\t * @param value The value to observe\n\t\t */\n\t\tobserve(value: number): void;\n\n\t\t/**\n\t\t * Start a timer. Calling the returned function will observe the\n\t\t * duration in seconds in the summary.\n\t\t * @param labels Object with label keys and values\n\t\t * @return Function to invoke when timer should be stopped. The value it\n\t\t * returns is the timed duration.\n\t\t */\n\t\tstartTimer(): (labels?: LabelValues<T>) => number;\n\t}\n\n\tinterface Config {\n\t\t/**\n\t\t * Configurable percentiles, values should never be greater than 1\n\t\t */\n\t\tpercentiles?: number[];\n\t}\n}\n\n/**\n * Push metrics to a Pushgateway\n */\nexport class Pushgateway<T extends RegistryContentType> {\n\t/**\n\t * @param url Complete url to the Pushgateway. If port is needed append url with :port\n\t * @param options Options\n\t * @param registry Registry\n\t */\n\tconstructor(url: string, options?: any, registry?: Registry<T>);\n\n\t/**\n\t * Add metric and overwrite old ones\n\t * @param params Push parameters\n\t */\n\tpushAdd(\n\t\tparams: Pushgateway.Parameters,\n\t): Promise<{ resp?: unknown; body?: unknown }>;\n\n\t/**\n\t * Overwrite all metric (using PUT to Pushgateway)\n\t * @param params Push parameters\n\t */\n\tpush(\n\t\tparams: Pushgateway.Parameters,\n\t): Promise<{ resp?: unknown; body?: unknown }>;\n\n\t/**\n\t * Delete all metrics for jobName\n\t * @param params Push parameters\n\t */\n\tdelete(\n\t\tparams: Pushgateway.Parameters,\n\t): Promise<{ resp?: unknown; body?: unknown }>;\n}\n\nexport namespace Pushgateway {\n\tinterface Parameters {\n\t\t/**\n\t\t * Jobname that is pushing the metric\n\t\t */\n\t\tjobName: string;\n\t\t/**\n\t\t * Label sets used in the url when making a request to the Pushgateway,\n\t\t */\n\t\tgroupings?: {\n\t\t\t[key: string]: string;\n\t\t};\n\t}\n}\n\n/**\n * Create an array with equal spacing between the elements\n * @param start The first value in the array\n * @param width The spacing between the elements\n * @param count The number of items in array\n * @return An array with the requested number of elements\n */\nexport function linearBuckets(\n\tstart: number,\n\twidth: number,\n\tcount: number,\n): number[];\n\n/**\n * Create an array that grows exponentially\n * @param start The first value in the array\n * @param factor The exponential factor\n * @param count The number of items in array\n * @return An array with the requested number of elements\n */\nexport function exponentialBuckets(\n\tstart: number,\n\tfactor: number,\n\tcount: number,\n): number[];\n\nexport interface DefaultMetricsCollectorConfiguration<\n\tT extends RegistryContentType,\n> {\n\tregister?: Registry<T>;\n\tprefix?: string;\n\tgcDurationBuckets?: number[];\n\teventLoopMonitoringPrecision?: number;\n\tlabels?: object;\n}\n\nexport const collectDefaultMetrics: {\n\t/**\n\t * Configure default metrics\n\t * @param config Configuration object for default metrics collector\n\t */\n\t<T extends RegistryContentType>(\n\t\tconfig?: DefaultMetricsCollectorConfiguration<T>,\n\t): void;\n\t/** All available default metrics */\n\tmetricsList: string[];\n};\n\n/**\n * Validate a metric name\n * @param name The name to validate\n * @return True if the metric name is valid, false if not\n */\nexport function validateMetricName(name: string): boolean;\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 1.1640625,
          "content": "/**\n * Prometheus client\n * @module Prometheus client\n */\n\n'use strict';\n\nexports.register = require('./lib/registry').globalRegistry;\nexports.Registry = require('./lib/registry');\nObject.defineProperty(exports, 'contentType', {\n\tconfigurable: false,\n\tenumerable: true,\n\tget() {\n\t\treturn exports.register.contentType;\n\t},\n\tset(value) {\n\t\texports.register.setContentType(value);\n\t},\n});\nexports.prometheusContentType = exports.Registry.PROMETHEUS_CONTENT_TYPE;\nexports.openMetricsContentType = exports.Registry.OPENMETRICS_CONTENT_TYPE;\nexports.validateMetricName = require('./lib/validation').validateMetricName;\n\nexports.Counter = require('./lib/counter');\nexports.Gauge = require('./lib/gauge');\nexports.Histogram = require('./lib/histogram');\nexports.Summary = require('./lib/summary');\nexports.Pushgateway = require('./lib/pushgateway');\n\nexports.linearBuckets = require('./lib/bucketGenerators').linearBuckets;\nexports.exponentialBuckets =\n\trequire('./lib/bucketGenerators').exponentialBuckets;\n\nexports.collectDefaultMetrics = require('./lib/defaultMetrics');\n\nexports.aggregators = require('./lib/metricAggregators').aggregators;\nexports.AggregatorRegistry = require('./lib/cluster');\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.880859375,
          "content": "{\n\t\"name\": \"prom-client\",\n\t\"version\": \"15.1.3\",\n\t\"description\": \"Client for prometheus\",\n\t\"main\": \"index.js\",\n\t\"files\": [\n\t\t\"lib/\",\n\t\t\"index.js\",\n\t\t\"index.d.ts\"\n\t],\n\t\"engines\": {\n\t\t\"node\": \"^16 || ^18 || >=20\"\n\t},\n\t\"scripts\": {\n\t\t\"benchmarks\": \"node ./benchmarks/index.js\",\n\t\t\"test\": \"npm run lint && npm run check-prettier && npm run compile-typescript && npm run test-unit\",\n\t\t\"lint\": \"eslint .\",\n\t\t\"test-unit\": \"jest\",\n\t\t\"run-prettier\": \"prettier . .eslintrc\",\n\t\t\"check-prettier\": \"npm run run-prettier -- --check\",\n\t\t\"compile-typescript\": \"tsc --project .\",\n\t\t\"prepare\": \"husky\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git@github.com:siimon/prom-client.git\"\n\t},\n\t\"keywords\": [\n\t\t\"Prometheus\",\n\t\t\"Metrics\",\n\t\t\"Client\"\n\t],\n\t\"author\": \"Simon Nyberg\",\n\t\"license\": \"Apache-2.0\",\n\t\"homepage\": \"https://github.com/siimon/prom-client\",\n\t\"devDependencies\": {\n\t\t\"@clevernature/benchmark-regression\": \"^1.0.0\",\n\t\t\"@typescript-eslint/eslint-plugin\": \"^6.21.0\",\n\t\t\"@typescript-eslint/parser\": \"^6.21.0\",\n\t\t\"eslint\": \"^8.32.0\",\n\t\t\"eslint-config-prettier\": \"^9.1.0\",\n\t\t\"eslint-plugin-n\": \"^16.0.0\",\n\t\t\"eslint-plugin-prettier\": \"^5.0.1\",\n\t\t\"express\": \"^4.13.3\",\n\t\t\"husky\": \"^9.0.0\",\n\t\t\"jest\": \"^29.3.1\",\n\t\t\"lint-staged\": \"^13.1.0\",\n\t\t\"nock\": \"^13.0.5\",\n\t\t\"prettier\": \"3.3.2\",\n\t\t\"typescript\": \"^5.0.4\"\n\t},\n\t\"dependencies\": {\n\t\t\"@opentelemetry/api\": \"^1.4.0\",\n\t\t\"tdigest\": \"^0.1.1\"\n\t},\n\t\"types\": \"./index.d.ts\",\n\t\"jest\": {\n\t\t\"testEnvironment\": \"node\",\n\t\t\"testRegex\": \".*Test\\\\.js$\"\n\t},\n\t\"lint-staged\": {\n\t\t\"*.{js,ts}\": \"eslint --fix\",\n\t\t\"*.{md,json,yml}\": \"prettier --write\",\n\t\t\".travis.yml\": \"prettier --write\"\n\t},\n\t\"prettier\": {\n\t\t\"singleQuote\": true,\n\t\t\"useTabs\": true,\n\t\t\"arrowParens\": \"avoid\",\n\t\t\"trailingComma\": \"all\",\n\t\t\"endOfLine\": \"auto\",\n\t\t\"overrides\": [\n\t\t\t{\n\t\t\t\t\"files\": \"*.md\",\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"useTabs\": false\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"files\": \".eslintrc\",\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"parser\": \"json\"\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tsconfig.json",
          "type": "blob",
          "size": 0.095703125,
          "content": "{\n\t\"compilerOptions\": {\n\t\t\"target\": \"es6\",\n\t\t\"strict\": true,\n\t\t\"types\": [],\n\t\t\"noEmit\": true\n\t}\n}\n"
        }
      ]
    }
  ]
}