{
  "metadata": {
    "timestamp": 1736561785840,
    "page": 426,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jquery-backstretch/jquery-backstretch",
      "stars": 3912,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": ".DS_Store\nnode_modules"
        },
        {
          "name": "Gruntfile.js",
          "type": "blob",
          "size": 1.779296875,
          "content": "/*global module:false*/\nmodule.exports = function(grunt) {\n\n  grunt.loadNpmTasks( 'grunt-contrib-qunit' );\n  grunt.loadNpmTasks( 'grunt-contrib-jshint' );\n  grunt.loadNpmTasks( 'grunt-contrib-concat' );\n  grunt.loadNpmTasks( 'grunt-contrib-uglify' );\n  grunt.loadNpmTasks( 'grunt-contrib-watch' );\n    \n  // Project configuration.\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),\n    concat: {\n      dist: {\n        src: 'src/jquery.backstretch.js',\n        dest: 'jquery.backstretch.js'\n      }\n    },\n    uglify: {\n      options: {\n        banner: '/*! <%= pkg.title || pkg.name %> - v<%= pkg.version %> - ' +\n          '<%= grunt.template.today(\"yyyy-mm-dd\") %>\\\\n' +\n          '<%= pkg.homepage ? \"* \" + pkg.homepage + \"\\\\n\" : \"\" %>' +\n          '* Copyright (c) <%= grunt.template.today(\"yyyy\") %> <%= pkg.author.name %>;' +\n          '* Fork of improvements - by Daniel Cohen Gindi (danielgindi@gmail.com)' +\n          ' Licensed <%= pkg.licenses.map(function (x) { return x[\"type\"] }).join(\", \") %> */'\n      },\n      dist: {\n        src: 'src/jquery.backstretch.js',\n        dest: 'jquery.backstretch.min.js'\n      }\n    },\n    qunit: {\n      files: ['test/**/*.html']\n    },\n    watch: {\n      files: 'src/jquery.backstretch.js',\n      tasks: 'jshint qunit'\n    },\n    jshint: {\n      options: {\n        curly: true,\n        eqeqeq: true,\n        immed: true,\n        latedef: false,\n        newcap: true,\n        noarg: true,\n        sub: true,\n        undef: true,\n        boss: true,\n        eqnull: true,\n        browser: true,\n        laxcomma: true,\n        laxbreak: true,\n        globals: {\n          jQuery: true\n        }\n      },\n      files: ['src/**/*.js', 'test/**/*.js']\n    }\n  });\n\n  // Default task.\n  grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);\n\n};"
        },
        {
          "name": "LICENSE-MIT",
          "type": "blob",
          "size": 1.03125,
          "content": "Copyright (c) 2012 Scott Robbin\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.8193359375,
          "content": "Note: This repo is currently looking for maintainers: https://github.com/jquery-backstretch/jquery-backstretch/issues/464\n\n# Backstretch\n\nBackstretch is a simple jQuery plugin that allows you to add a dynamically-resized, slideshow-capable background image to any page or element. The image will stretch to fit the page/element, and will automatically resize as the window/element size changes.\n\n** We're back in business! Merged `danielgindi/jquery-backstretch`, and all eyes please get back here! **\n\n## Demo\n\nThere are a couple of examples included with this package, or feel free to check it out live [on the project page itself](http://srobbin.com/jquery-plugins/backstretch/).\n\n## Installation\n\n1. Download/save the JS file from GitHub.\n2. Install via Bower with the following command.\n\n```\nbower install jquery-backstretch\n```\n\n## Setup\n\nInclude the jQuery library (version 1.7 or newer) and Backstretch plugin files in your webpage (preferably at the bottom of the page, before the closing BODY tag):\n\n```html\n<script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"></script>\n<script src=\"jquery.backstretch.min.js\"></script>\n<script>\n  // To attach Backstrech as the body's background\n  $.backstretch(\"path/to/image.jpg\");\n\n  // You may also attach Backstretch to a block-level element\n  $(\".foo\").backstretch(\"path/to/image.jpg\");\n\n  // If your element defines a background image with CSS, you can omit the argement altogether\n  $(\".foo\").backstretch();\n\n  // Or, to start a slideshow, just pass in an array of images\n  $(\".foo\").backstretch([\n    \"path/to/image.jpg\",\n    \"path/to/image2.jpg\",\n    \"path/to/image3.jpg\"    \n  ], {duration: 4000});\n\n  // Or, to load from a url that can accept a resolution and provide the best image for that resolution\n  $(\".foo\").backstretch([\n    \"path/to/image.jpg?width={width}&height={height}\"\n  ]);\n\n  // Or, to automatically choose from a set of resolutions.\n  // The width is the width of the image, and the algorithm chooses the best fit.\n  $(\".foo\").backstretch([\n    [\n      { width: 1080, url: \"path/to/image1_1080.jpg\" },\n      { width: 720, url: \"path/to/image1_720.jpg\" },\n      { width: 320, url: \"path/to/image1_320.jpg\" }\n    ],\n    [\n      { width: 1080, url: \"path/to/image2_1080.jpg\" },\n      { width: 720, url: \"path/to/image2_720.jpg\" },\n      { width: 320, url: \"path/to/image2_320.jpg\" }\n    ]\n  ]);\n\n  // If we wanted to specify different images for different pixel-ratios:\n  $(\".foo\").backstretch([\n    [\n      // Will only be chosed for a @2x device\n      { width: 1080, url: \"path/to/image1_1080@2x.jpg\", pixelRatio: 2 },\n      \n      // Will only be chosed for a @1x device\n      { width: 1080, url: \"path/to/image1_1080.jpg\", pixelRatio: 1 },\n      \n      { width: 720, url: \"path/to/image1_720@2x.jpg\", pixelRatio: 2 },\n      { width: 720, url: \"path/to/image1_720.jpg\", pixelRatio: 1 },\n      { width: 320, url: \"path/to/image1_320@2x.jpg\",  pixelRatio: 2 },\n      { width: 320, url: \"path/to/image1_320.jpg\", pixelRatio: 1 }\n    ]\n  ]);\n\n  // If we wanted the browser to automatically choose from a set of resolutions,\n  // While considering the pixel-ratio of the device\n  $(\".foo\").backstretch([\n    [\n      // Will be chosen for a 2160 device or a 1080*2 device\n      { width: 2160, url: \"path/to/image1_2160.jpg\", pixelRatio: \"auto\" }, \n      \n      // Will be chosen for a 1080 device or a 540*2 device\n      { width: 1080, url: \"path/to/image1_1080.jpg\", pixelRatio: \"auto\" },\n      \n      // Will be chosen for a 1440 device or a 720*2 device\n      { width: 1440, url: \"path/to/image1_1440.jpg\", pixelRatio: \"auto\" },\n      { width: 720, url: \"path/to/image1_720.jpg\", pixelRatio: \"auto\" },\n      { width: 640, url: \"path/to/image1_640.jpg\", pixelRatio: \"auto\" },\n      { width: 320, url: \"path/to/image1_320.jpg\", pixelRatio: \"auto\" }\n    ]\n  ]);\n</script>\n```\n\n## Automatic resolution selection\n\nThe automatic resolution selection algorithm has multiple options to choose from.  \nThe default behaviour is that it matches the logical width of the element against the specified image sizes. Which means that an element with a 320px width on a @2x device is still considered as 320px.  \nIf you want 320px on a @2x device to be considered as 640px, then you can specify `pixelRatio: \"auto\"` on the specific image resolution.  \nHowever if you want to limit specific images to only be chosen if the device has a certain pixel ratio - you can specify that pixel ratio i.e `pixelRatio: 2.5`.\n\n## Options\n\n| Name | Description | Type | Default |\n|------|-------------|------|---------|\n| `alignX` * | This parameter controls the horizontal alignment of the image. Can be 'center'/'left'/'right' or any number between 0.0 and 1.0. | Integer or String | 0.5 |\n| `alignY` * | This parameter controls the vertical alignment of the image. Can be 'center'/'top'/'bottom' or any number between 0.0 and 1.0. | Integer or String | 0.5 |\n| `scale` * | Controls the scaling mode. Can be 'cover'/'fit'/'fit-smaller'/'fill' | String | 'cover' |\n| `transition` * | Type of transition to use. If multiple are specified, then it will be chosed randomly | String or Array<String> | 'fade' |\n| `transitionDuration` * | This is the duration at which the image will transition in. Integers in milliseconds are accepted, as well as standard jQuery speed strings (slow, normal, fast). | Integer or String | 0 |\n| `transitionEasing` * | The easing function that will be used for animations. | Any supported jQuery easing value | *jQuery default* |\n| `animateFirst` | If `true`, the first image will transition in like all the others. | Boolean | true |\n| `fade` * | Sets `transition` to `'fade'` and `transitionDuration` to whatever value was specified. | Integer or String | |\n| `fadeFirst` | Synonym for `animateFirst` | Boolean | true |\n| `duration` * | The amount of time in between slides, when using Backstretch as a slideshow, expressed as the number of milliseconds. | Integer | 5000 |\n| `paused` | For slideshows: Disables the change between slides | Boolean | false |\n| `start` | The index of the image in the array you want to start your slideshow with. | Integer | 0 |\n| `preload` | How many images to preload at once? I.e. Lazy-loading can be enabled by specifying 0. | Integer | 2 |\n| `preloadSize` | How many images to preload in parallel? If we are preloading 5 images for the next slides, we might want to still limit it to only preload 2 or 3 at once, according to the expected available bandwidth. | Integer | 1 |\n| `bypassCss` | Avoid adding any CSS to the IMG element. I.e if you want a dynamic IMG tag that is laid out with the content. | Boolean | false |\n| `alwaysTestWindowResolution` | Always test against window's width instead of the element's width. | Boolean | false |\n| `resolutionRefreshRate` | Threshold for how long to wait before the image resolution will be switched? | Integer | 2500 |\n| `resolutionChangeRatioThreshold` | Threshold for how much should the different in the resolution be before switch image | Number | 0.1 (10%) |\n| `centeredX` | Deprecated. Still works but please do not use it. | Boolean | true |\n| `centeredY` | Deprecated. Still works but please do not use it. | Boolean | true |\n\n* Options marked with an `*` can be specified for individual images\n\n## Image definition\n\nEach image in the set can be a String specifying the URL for the image, *or* an object with the following options, *or* an array of images for different resolutions to choose between.\nA url can be a url to a video also.\nCurrently the plugin will automatically recognize a *youtube* url. If you pass urls to raw videos, you have to specify `isVideo: true`.\n\n| Name | Description | Type | Default |\n|------|-------------|------|---------|\n| `url` | The url of the image or video | String | |\n| `alt` | The alternative text for this image (If you want to play along with screen readers) | String | '' |\n| `alignX` | This parameter controls the horizontal alignment of the image. Can be 'center'/'left'/'right' or any number between 0.0 and 1.0. | Integer or String | 0.5 |\n| `alignY` | This parameter controls the vertical alignment of the image. Can be 'center'/'top'/'bottom' or any number between 0.0 and 1.0. | Integer or String | 0.5 |\n| `scale` | Controls the scaling mode. Can be 'cover'/'fit'/'fit-smaller'/'fill' | String | 'cover' |\n| `transition` | Type of transition to use. If multiple are specified, then it will be chosed randomly | String or Array<String> | 'fade' |\n| `transitionDuration` | This is the duration at which the image will transition in. Integers in milliseconds are accepted, as well as standard jQuery speed strings (slow, normal, fast). | Integer or String | 0 |\n| `transitionEasing` | The easing function that will be used for animations. | Any supported jQuery easing value | *jQuery default* |\n| `fade` | Sets `transition` to `'fade'` and `transitionDuration` to whatever value was specified. | Integer or String | |\n| `duration` | The amount of time in between slides, when using Backstretch as a slideshow, expressed as the number of milliseconds. | Integer | 5000 |\n| `isVideo` | Tell the plugin the this is a video (if cannot be recognized automatically) | Boolean | false |\n| `loop` | Should the video be looped? If yes, then the duration will be used to determine when to stop. | Boolean | false |\n| `mute` | Should the video be muted? | Boolean | true |\n| `poster` | This is for specifying the `poster` attribute in standard <video> tags | String | |\n\n## Per-resolution-image definition\n\nIf you have specified an array of resolutions for a single image, then these are the available options:\n\n| Name | Description | Type | Default |\n|------|-------------|------|---------|\n| `url` | The url of the image | String | |\n| `url` for `<video>` | Instead of a single `url`, an array of sources can be specified. Each source has a `src` and `type` attributes. | Array of `{ src, type }` | |\n| `alt` | The alternative text for this image (If you want to play along with screen readers) | String | '' |\n| `width` | The width of the image | Integer | |\n| `pixelRatio` | A strict rule to only choose for the specified device pixel ratio. If set to 'auto', then the element's width will first be multiplied by the device's pixel ratio before evaluating. | Number or \"auto\" | undefined |\n| `deviceOrientation` | Restrict image selection to specific device orientation | `'landscape'` or `'portrait'` | undefined |\n| `windowOrientation` | Restrict image selection to specific window orientation (based on current window's inner width/height) | `'landscape'` / `'portrait'` / `'square'` | undefined |\n| `orientation` | Restrict image selection to the element's orientation based on the element's current inner width/height) | `'landscape'` / `'portrait'` / `'square'` | undefined |\n| `alignX` | This parameter controls the horizontal alignment of the image. Can be 'center'/'left'/'right' or any number between 0.0 and 1.0. | Integer or String | 0.5 |\n| `alignY` | This parameter controls the vertical alignment of the image. Can be 'center'/'top'/'bottom' or any number between 0.0 and 1.0. | Integer or String | 0.5 |\n| `scale` | Controls the scaling mode. Can be 'cover'/'fit'/'fit-smaller'/'fill' | String | 'cover' |\n| `fade` | This is the speed at which the image will fade in. Integers in milliseconds are accepted, as well as standard jQuery speed strings (slow, normal, fast). | Integer or String | 0 |\n| `duration` | The amount of time in between slides, when using Backstretch as a slideshow, expressed as the number of milliseconds. | Integer | 5000 |\n\n## Transitions\n\n* `'fade'`\n* `'fade_in_out'` / `'fadeInOut'`\n* `'push_left'` / `'pushLeft'`\n* `'push_right'` / `'pushRight'`\n* `'push_up'` / `'pushUp'`\n* `'push_down'` / `'pushDown'`\n* `'cover_left'` / `'coverLeft'`\n* `'cover_right'` / `'coverRight'`\n* `'cover_up'` / `'coverUp'`\n* `'cover_down'` / `'coverDown'`\n\n## Notes about video support:\n\n* If the video is not in `loop` mode, then it will play until the end. You have to specify a duration for the specific video in order to limit its playing duration.\n* Mobile browsers do not allow playback of videos without the users tapping a play button... So you may want to detect those and supply different media arrays for those browsers.\n\n## Slideshow API\n\nOnce you've instantiated a Backstretch slideshow, there are many actions that you can perform it:\n\n```javascript\n// Start a slideshow\n$('.foo').backstretch([\n  'path/to/image.jpg',\n  'path/to/image2.jpg',\n  'path/to/image3.jpg'\n]);\n\n// Slideshow with granular control\n$('.foo').backstretch([\n  { url: 'path/to/image.jpg', duration: 3000 }\n  { url: 'path/to/image2.jpg', fade: 250 },\n  { url: 'path/to/image3.jpg', alignY: 0.2 }\n]);\n\n// Pause the slideshow\n$('.foo').backstretch(\"pause\");\n\n// Advance to the next slide\n$('.foo').backstretch(\"next\");\n```\n\n| Method | Description |\n|------|-------------|\n| `.backstretch(\"show\", n)` | Jump to the slide at a given index, where n is the number of the image that you'd like to display. Slide number starts at 0. |\n| `.backstretch(\"prev\")` | Display the previous image in a slideshow. |\n| `.backstretch(\"next\")` | Advance to the next image in a slideshow. |\n| `.backstretch(\"pause\")` | Pause the slideshow. |\n| `.backstretch(\"resume\")` | Resume a paused slideshow. |\n| `.backstretch(\"destroy\", preserveBackground)` | Destroy the Backstretch instance. Optionally, you can pass in a Boolean parameter, preserveBackground, to determine whether or not you'd like to keep the current image stretched as the background image. |\n| `.backstretch(\"resize\")` | This method is called automatically when the container (window or block-level element) is resized, however you can always call this manually if needed. |\n| `.backstretch(\"current\")` | This function returns the index of the current slide |\n\n## Public Variables\n\nSometimes, you'll want to access Backstretch's images after you've instantiated the plugin. For example, perhaps you'd like to be able add more images to a slideshow. Doing so is easy. You can access the images array as follows:\n\n```javascript\n$('.foo').backstretch([\n  'path/to/image.jpg',\n  'path/to/image2.jpg',\n  'path/to/image3.jpg'\n]);\n\n// Access the instance\nvar instance = $('.foo').data('backstretch');\n\n// Then, you can manipulate the images array directly\ninstance.images.push('path/to/image4.jpg')\n```\n\nAdditionally, the current index of a slideshow is available through the instance as well:\n\n```javascript\n$(\"body\").data(\"backstretch\").index;\n```\n\n## Events\n\n### backstretch.before\n\nBackstretch will fire a \"backstretch.before\" event before a new image loads, triggering a function that is passed the event, Backstretch instance, and index of the image that will be displayed. If you listen for that event, you can, for example, coordinate other changes to coincide with your slideshow.\n\n```javascript\n$(window).on(\"backstretch.before\", function (e, instance, index) {\n  // If we wanted to stop the slideshow after it reached the end\n  if (index === instance.images.length - 1) {\n    instance.pause();\n  };\n});\n```\n\n### backstretch.after\n\nBackstretch will also fire a \"backstretch.after\" event after the new images has completed loading.\n\n```javascript\n$(window).on(\"backstretch.after\", function (e, instance, index) {\n  // Do something\n});\n```\n\n## Changelog\n\n### Version 2.1.18\n\n* Bugfix: When another library imports youtube api first, YT detection misbehaves in backstretch.\n\n### Version 2.1.17\n\n* Bugfix: Calling `.backstretch(...)` on an already backstretched element did not properly destroy the older backstretch instance. Resulted in ghost backstretches... \n\n### Version 2.1.16\n\n* New: Added `scale` feature.\n\n### Version 2.1.15\n\n* Improvement: Not modifying `background` property, but `background-image`, to allow CSS to play with colors. (@philsbury)\n\n### Version 2.1.14\n\n* New: Added `'deviceOrientation'`, `'windowOrientation'` and `'orientation'` options\n\n### Version 2.1.13\n\n* Bugfix: Native video source tags were misspelled\n* Bugfix: Youtube matching regex was not constrained to `youtube.com`/`youtu.be` domain\n\n### Version 2.1.12\n\n* New: Added `'fade_in_out'` transition\n\n### Version 2.1.11\n\n* Bugfix: Resolution detection routine failed to properly match current url - and cause an additional replace of the image. This affected video urls in a way that caused them to being played from the start.\n\n### Version 2.1.10\n\n* Bugfix: `pixelRatio == 'auto'` was ignored due to a missing rule.\n\n### Version 2.1.9\n\n* Allow overriding transition options for a single `show(...)` call\n* Bugfix: Next transition can go wrong because of css leftover of previous transition\n\n### Version 2.1.8\n\n* Improved method calling through `.backstretch('method', ...)` to pass all arguments, and return value.\n* Added `current()` function to return current slide index.\n\n### Version 2.1.7\n\n* Minor documentation improvements. Version release for updated docs in NPM etc.\n\n### Version 2.1.6\n\n* Minor fix: `background` css on the target element was sometimes cleared prematurely. (Issue #18)\n\n### Version 2.1.5\n\n* Minor fix: `resolutionChangeRatioTreshold` was a typo. Changed to `resolutionChangeRatioThreshold`, but keeping backwards compatibility.\n\n### Version 2.1.4\n\n* New: Added more transitions beside fade\n* Bugfix: Youtube Iframe API's `destroy` was not being called\n* Minor documentation updates\n\n### Version 2.1.3\n\n* New: Youtube and `<video>` support!\n\n### Version 2.1.2\n\n* Bugfix: Executing backstretch methods on already backstretched elements failed\n\n### Version 2.1.1\n\n* Published to bower under \"jquery-backstretch-2\"\n\n### Version 2.1.0\n\n* New `alwaysTestWindowResolution` option\n* New `resolutionRefreshRate` option\n* New `resolutionChangeRatioTreshold` option\n* Minor bugfix: If there was no `fade` duration, the new image was still being removed asynchronously. Possibly causing a glitch if custom CSS is used.\n\n### Version 2.0.9\n\n* New `alt` image property\n* New `bypassCss` option\n\n### Version 2.0.8\n\n* Changed multi-res feature `width`'s meaning. `width` now means the actual width of the image to match against.\n* Added `pixelRatio` option for multires.\n\n### Version 2.0.7\n\n* More granular control over options\n* 1. Now you can specify `alignX`/`alignY`/`duration`/`fade` on an image basis\n* 2. Minor bugfixes\n* 3. Deprecated `centeredX`/`centeredY`\n\n### Version 2.0.6\n\n* Minor bug fixes due to latest PRs\n\n### Version 2.0.5\n\n* New `fadeFirst` feature\n* New `alignX` feature\n* New `alignY` feature\n* New `paused` feature\n* New `start` feature\n* New `preload` feature\n* New `preloadSize` feature\n* New feature: url templates\n* New feature: automatic resolution selection\n* Minor bug fixes\n\n### Version 2.0\n\n* Now accepts an array of images to create a slideshow\n* Can attach Backstretch to any block-level element, not just the body\n* Deprecated \"speed\" option in favor of \"fade\" for fadeIn timing\n* Added \"duration\" option, and Slideshow API\n\n### Version 1.2\n\n* You can now called backstretch twice, and it will replace the existing image.\n\n### Version 1.1\n\n* Added 'centeredX' and 'centeredY' options.\n* Removed 'hideUntilReady' option. It looks pretty bad if you don't hide the image until it's fully loaded.\n* Fixed IE img onload bug.\n* Now supports iPhone/iPad orientation changes.\n"
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.66015625,
          "content": "{\n  \"name\": \"jquery-backstretch\",\n  \"description\": \"A simple jQuery plugin that allows you to add a dynamically-resized, slideshow-capable background image to any page or element.\",\n  \"version\": \"2.1.15\",\n  \"homepage\": \"http://www.jquery-backstretch.com/\",\n  \"author\": {\n    \"name\": \"Scott Robbin\",\n    \"email\": \"scott@robbin.co\",\n    \"url\": \"http://srobbin.com\"\n  },\n  \"main\": [\"jquery.backstretch.js\"],\n  \"dependencies\": {\n    \"jquery\": \">=1.9.x\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/jquery-backstretch/jquery-backstretch.git\"\n  },\n  \"ignore\": [\n    \"Gruntfile.js\",\n    \"examples\",\n    \"libs\",\n    \"test\",\n    \".gitignore\",\n    \"src\"\n  ]\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "jquery.backstretch.js",
          "type": "blob",
          "size": 45.560546875,
          "content": "/*\n * Backstretch\n * http://srobbin.com/jquery-plugins/backstretch/\n *\n * Copyright (c) 2013 Scott Robbin\n * Licensed under the MIT license.\n */\n\n;(function ($, window, undefined) {\n  'use strict';\n\n  /** @const */\n  var YOUTUBE_REGEXP = /^.*(youtu\\.be\\/|youtube\\.com\\/v\\/|youtube\\.com\\/embed\\/|youtube\\.com\\/watch\\?v=|youtube\\.com\\/watch\\?.*\\&v=)([^#\\&\\?]*).*/i;\n\n  /* PLUGIN DEFINITION\n   * ========================= */\n\n  $.fn.backstretch = function (images, options) {\n    var args = arguments;\n\n    /*\n     * Scroll the page one pixel to get the right window height on iOS\n     * Pretty harmless for everyone else\n    */\n    if ($(window).scrollTop() === 0) {\n      window.scrollTo(0, 0);\n    }\n\n    var returnValues;\n\n    this.each(function (eachIndex) {\n      var $this = $(this)\n        , obj = $this.data('backstretch');\n\n      // Do we already have an instance attached to this element?\n      if (obj) {\n\n        // Is this a method they're trying to execute?\n        if (typeof args[0] === 'string' &&\n          typeof obj[args[0]] === 'function') {\n\n          // Call the method\n          var returnValue = obj[args[0]].apply(obj, Array.prototype.slice.call(args, 1));\n          if (returnValue === obj) { // If a method is chaining\n            returnValue = undefined;\n          }\n          if (returnValue !== undefined) {\n            returnValues = returnValues || [];\n            returnValues[eachIndex] = returnValue;\n          }\n\n          return; // Nothing further to do\n        }\n\n        // Merge the old options with the new\n        options = $.extend(obj.options, options);\n\n        // Remove the old instance\n        if (typeof obj === 'object' && 'destroy' in obj) {\n          obj.destroy(true);\n        }\n      }\n\n      // We need at least one image\n      if (!images || (images && images.length === 0)) {\n        var cssBackgroundImage = $this.css('background-image');\n        if (cssBackgroundImage && cssBackgroundImage !== 'none') {\n          images = [{url: $this.css('backgroundImage').replace(/url\\(|\\)|\"|'/g, \"\")}];\n        }\n        else {\n          $.error('No images were supplied for Backstretch, or element must have a CSS-defined background image.');\n        }\n      }\n\n      obj = new Backstretch(this, images, options || {});\n      $this.data('backstretch', obj);\n    });\n\n    return returnValues ? returnValues.length === 1 ? returnValues[0] : returnValues : this;\n  };\n\n  // If no element is supplied, we'll attach to body\n  $.backstretch = function (images, options) {\n    // Return the instance\n    return $('body')\n      .backstretch(images, options)\n      .data('backstretch');\n  };\n\n  // Custom selector\n  $.expr[':'].backstretch = function (elem) {\n    return $(elem).data('backstretch') !== undefined;\n  };\n\n  /* DEFAULTS\n   * ========================= */\n\n  $.fn.backstretch.defaults = {\n    duration: 5000                // Amount of time in between slides (if slideshow)\n    , transition: 'fade'          // Type of transition between slides\n    , transitionDuration: 0       // Duration of transition between slides\n    , animateFirst: true          // Animate the transition of first image of slideshow in?\n    , alignX: 0.5                 // The x-alignment for the image, can be 'left'|'center'|'right' or any number between 0.0 and 1.0\n    , alignY: 0.5                 // The y-alignment for the image, can be 'top'|'center'|'bottom' or any number between 0.0 and 1.0\n    , paused: false               // Whether the images should slide after given duration\n    , start: 0                    // Index of the first image to show\n    , preload: 2                  // How many images preload at a time?\n    , preloadSize: 1              // How many images can we preload in parallel?\n    , resolutionRefreshRate: 2500 // How long to wait before switching resolution?\n    , resolutionChangeRatioThreshold: 0.1 // How much a change should it be before switching resolution?\n  };\n\n  /* STYLES\n   *\n   * Baked-in styles that we'll apply to our elements.\n   * In an effort to keep the plugin simple, these are not exposed as options.\n   * That said, anyone can override these in their own stylesheet.\n   * ========================= */\n  var styles = {\n    wrap: {\n      left: 0\n      , top: 0\n      , overflow: 'hidden'\n      , margin: 0\n      , padding: 0\n      , height: '100%'\n      , width: '100%'\n      , zIndex: -999999\n    }\n    , itemWrapper: {\n      position: 'absolute'\n      , display: 'none'\n      , margin: 0\n      , padding: 0\n      , border: 'none'\n      , width: '100%'\n      , height: '100%'\n      , zIndex: -999999\n    }\n    , item: {\n      position: 'absolute'\n      , margin: 0\n      , padding: 0\n      , border: 'none'\n      , width: '100%'\n      , height: '100%'\n      , maxWidth: 'none'\n    }\n  };\n\n  /* Given an array of different options for an image,\n   * choose the optimal image for the container size.\n   *\n   * Given an image template (a string with {{ width }} and/or\n   * {{height}} inside) and a container object, returns the\n   * image url with the exact values for the size of that\n   * container.\n   *\n   * Returns an array of urls optimized for the specified resolution.\n   *\n   */\n  var optimalSizeImages = (function () {\n\n    /* Sorts the array of image sizes based on width */\n    var widthInsertSort = function (arr) {\n      for (var i = 1; i < arr.length; i++) {\n        var tmp = arr[i],\n          j = i;\n        while (arr[j - 1] && parseInt(arr[j - 1].width, 10) > parseInt(tmp.width, 10)) {\n          arr[j] = arr[j - 1];\n          --j;\n        }\n        arr[j] = tmp;\n      }\n\n      return arr;\n    };\n\n    /* Given an array of various sizes of the same image and a container width,\n     * return the best image.\n     */\n    var selectBest = function (containerWidth, containerHeight, imageSizes) {\n\n      var devicePixelRatio = window.devicePixelRatio || 1;\n      var deviceOrientation = getDeviceOrientation();\n      var windowOrientation = getWindowOrientation();\n      var wrapperOrientation = (containerHeight > containerWidth) ?\n        'portrait' :\n        (containerWidth > containerHeight ? 'landscape' : 'square');\n\n      var lastAllowedImage = 0;\n      var testWidth;\n\n      for (var j = 0, image; j < imageSizes.length; j++) {\n\n        image = imageSizes[j];\n\n        // In case a new image was pushed in, process it:\n        if (typeof image === 'string') {\n          image = imageSizes[j] = {url: image};\n        }\n\n        if (image.pixelRatio && image.pixelRatio !== 'auto' && parseFloat(image.pixelRatio) !== devicePixelRatio) {\n          // We disallowed choosing this image for current device pixel ratio,\n          // So skip this one.\n          continue;\n        }\n\n        if (image.deviceOrientation && image.deviceOrientation !== deviceOrientation) {\n          // We disallowed choosing this image for current device orientation,\n          // So skip this one.\n          continue;\n        }\n\n        if (image.windowOrientation && image.windowOrientation !== deviceOrientation) {\n          // We disallowed choosing this image for current window orientation,\n          // So skip this one.\n          continue;\n        }\n\n        if (image.orientation && image.orientation !== wrapperOrientation) {\n          // We disallowed choosing this image for current element's orientation,\n          // So skip this one.\n          continue;\n        }\n\n        // Mark this one as the last one we investigated\n        // which does not violate device pixel ratio rules.\n        // We may choose this one later if there's no match.\n        lastAllowedImage = j;\n\n        // For most images, we match the specified width against element width,\n        // And enforcing a limit depending on the \"pixelRatio\" property if specified.\n        // But if a pixelRatio=\"auto\", then we consider the width as the physical width of the image,\n        // And match it while considering the device's pixel ratio.\n        testWidth = containerWidth;\n        if (image.pixelRatio === 'auto') {\n          containerWidth *= devicePixelRatio;\n        }\n\n        // Stop when the width of the image is larger or equal to the container width\n        if (image.width >= testWidth) {\n          break;\n        }\n      }\n\n      // Use the image located at where we stopped\n      return imageSizes[Math.min(j, lastAllowedImage)];\n    };\n\n    var replaceTagsInUrl = function (url, templateReplacer) {\n\n      if (typeof url === 'string') {\n        url = url.replace(/{{(width|height)}}/g, templateReplacer);\n      }\n      else if (url instanceof Array) {\n        for (var i = 0; i < url.length; i++) {\n          if (url[i].src) {\n            url[i].src = replaceTagsInUrl(url[i].src, templateReplacer);\n          }\n          else {\n            url[i] = replaceTagsInUrl(url[i], templateReplacer);\n          }\n        }\n      }\n\n      return url;\n    };\n\n    return function ($container, images) {\n      var containerWidth = $container.width(),\n        containerHeight = $container.height();\n\n      var chosenImages = [];\n\n      var templateReplacer = function (match, key) {\n        if (key === 'width') {\n          return containerWidth;\n        }\n        if (key === 'height') {\n          return containerHeight;\n        }\n        return match;\n      };\n\n      for (var i = 0; i < images.length; i++) {\n        if ($.isArray(images[i])) {\n          images[i] = widthInsertSort(images[i]);\n          var chosen = selectBest(containerWidth, containerHeight, images[i]);\n          chosenImages.push(chosen);\n        }\n        else {\n          // In case a new image was pushed in, process it:\n          if (typeof images[i] === 'string') {\n            images[i] = {url: images[i]};\n          }\n\n          var item = $.extend({}, images[i]);\n          item.url = replaceTagsInUrl(item.url, templateReplacer);\n          chosenImages.push(item);\n        }\n      }\n      return chosenImages;\n    };\n\n  })();\n\n  var isVideoSource = function (source) {\n    return YOUTUBE_REGEXP.test(source.url) || source.isVideo;\n  };\n\n  /* Preload images */\n  var preload = (function (sources, startAt, count, batchSize, callback) {\n    // Plugin cache\n    var cache = [];\n\n    // Wrapper for cache\n    var caching = function (image) {\n      for (var i = 0; i < cache.length; i++) {\n        if (cache[i].src === image.src) {\n          return cache[i];\n        }\n      }\n      cache.push(image);\n      return image;\n    };\n\n    // Execute callback\n    var exec = function (sources, callback, last) {\n      if (typeof callback === 'function') {\n        callback.call(sources, last);\n      }\n    };\n\n    // Closure to hide cache\n    return function preload(sources, startAt, count, batchSize, callback) {\n      // Check input data\n      if (typeof sources === 'undefined') {\n        return;\n      }\n      if (!$.isArray(sources)) {\n        sources = [sources];\n      }\n\n      if (arguments.length < 5 && typeof arguments[arguments.length - 1] === 'function') {\n        callback = arguments[arguments.length - 1];\n      }\n\n      startAt = (typeof startAt === 'function' || !startAt) ? 0 : startAt;\n      count = (typeof count === 'function' || !count || count < 0) ? sources.length : Math.min(count, sources.length);\n      batchSize = (typeof batchSize === 'function' || !batchSize) ? 1 : batchSize;\n\n      if (startAt >= sources.length) {\n        startAt = 0;\n        count = 0;\n      }\n      if (batchSize < 0) {\n        batchSize = count;\n      }\n      batchSize = Math.min(batchSize, count);\n\n      var next = sources.slice(startAt + batchSize, count - batchSize);\n      sources = sources.slice(startAt, batchSize);\n      count = sources.length;\n\n      // If sources array is empty\n      if (!count) {\n        exec(sources, callback, true);\n        return;\n      }\n\n      // Image loading callback\n      var countLoaded = 0;\n\n      var loaded = function () {\n        countLoaded++;\n        if (countLoaded !== count) {\n          return;\n        }\n\n        exec(sources, callback, !next);\n        preload(next, 0, 0, batchSize, callback);\n      };\n\n      // Loop sources to preload\n      var image;\n\n      for (var i = 0; i < sources.length; i++) {\n\n        if (isVideoSource(sources[i])) {\n\n          // Do not preload videos. There are issues with that.\n          // First - we need to keep an instance of the preloaded and use that exactly, not a copy.\n          // Second - there are memory issues.\n          // If there will be a requirement from users - I'll try to implement this.\n\n          continue;\n\n        }\n        else {\n\n          image = new Image();\n          image.src = sources[i].url;\n\n          image = caching(image);\n\n          if (image.complete) {\n            loaded();\n          }\n          else {\n            $(image).on('load error', loaded);\n          }\n\n        }\n\n      }\n    };\n  })();\n\n  /* Process images array */\n  var processImagesArray = function (images) {\n    var processed = [];\n    for (var i = 0; i < images.length; i++) {\n      if (typeof images[i] === 'string') {\n        processed.push({url: images[i]});\n      }\n      else if ($.isArray(images[i])) {\n        processed.push(processImagesArray(images[i]));\n      }\n      else {\n        processed.push(processOptions(images[i]));\n      }\n    }\n    return processed;\n  };\n\n  /* Process options */\n  var processOptions = function (options, required) {\n\n    // Convert old options\n\n    // centeredX/centeredY are deprecated\n    if (options.centeredX || options.centeredY) {\n      if (window.console && window.console.log) {\n        window.console.log('jquery.backstretch: `centeredX`/`centeredY` is deprecated, please use `alignX`/`alignY`');\n      }\n      if (options.centeredX) {\n        options.alignX = 0.5;\n      }\n      if (options.centeredY) {\n        options.alignY = 0.5;\n      }\n    }\n\n    // Deprecated spec\n    if (options.speed !== undefined) {\n\n      if (window.console && window.console.log) {\n        window.console.log('jquery.backstretch: `speed` is deprecated, please use `transitionDuration`');\n      }\n\n      options.transitionDuration = options.speed;\n      options.transition = 'fade';\n    }\n\n    // Typo\n    if (options.resolutionChangeRatioTreshold !== undefined) {\n      window.console.log('jquery.backstretch: `treshold` is a typo!');\n      options.resolutionChangeRatioThreshold = options.resolutionChangeRatioTreshold;\n    }\n\n    // Current spec that needs processing\n\n    if (options.fadeFirst !== undefined) {\n      options.animateFirst = options.fadeFirst;\n    }\n\n    if (options.fade !== undefined) {\n      options.transitionDuration = options.fade;\n      options.transition = 'fade';\n    }\n\n    if (options.scale) {\n      options.scale = validScale(options.scale);\n    }\n\n    return processAlignOptions(options);\n  };\n\n  /* Process align options */\n  var processAlignOptions = function (options, required) {\n    if (options.alignX === 'left') {\n      options.alignX = 0.0;\n    }\n    else if (options.alignX === 'center') {\n      options.alignX = 0.5;\n    }\n    else if (options.alignX === 'right') {\n      options.alignX = 1.0;\n    }\n    else {\n      if (options.alignX !== undefined || required) {\n        options.alignX = parseFloat(options.alignX);\n        if (isNaN(options.alignX)) {\n          options.alignX = 0.5;\n        }\n      }\n    }\n\n    if (options.alignY === 'top') {\n      options.alignY = 0.0;\n    }\n    else if (options.alignY === 'center') {\n      options.alignY = 0.5;\n    }\n    else if (options.alignY === 'bottom') {\n      options.alignY = 1.0;\n    }\n    else {\n      if (options.alignX !== undefined || required) {\n        options.alignY = parseFloat(options.alignY);\n        if (isNaN(options.alignY)) {\n          options.alignY = 0.5;\n        }\n      }\n    }\n\n    return options;\n  };\n\n  var SUPPORTED_SCALE_OPTIONS = {\n    'cover': 'cover',\n    'fit': 'fit',\n    'fit-smaller': 'fit-smaller',\n    'fill': 'fill'\n  };\n\n  function validScale(scale) {\n    if (!SUPPORTED_SCALE_OPTIONS.hasOwnProperty(scale)) {\n      return 'cover';\n    }\n    return scale;\n  }\n\n  /* CLASS DEFINITION\n   * ========================= */\n  var Backstretch = function (container, images, options) {\n    this.options = $.extend({}, $.fn.backstretch.defaults, options || {});\n\n    this.firstShow = true;\n\n    // Process options\n    processOptions(this.options, true);\n\n    /* In its simplest form, we allow Backstretch to be called on an image path.\n     * e.g. $.backstretch('/path/to/image.jpg')\n     * So, we need to turn this back into an array.\n     */\n    this.images = processImagesArray($.isArray(images) ? images : [images]);\n\n    /**\n     * Paused-Option\n     */\n    if (this.options.paused) {\n      this.paused = true;\n    }\n\n    /**\n     * Start-Option (Index)\n     */\n    if (this.options.start >= this.images.length) {\n      this.options.start = this.images.length - 1;\n    }\n    if (this.options.start < 0) {\n      this.options.start = 0;\n    }\n\n    // Convenience reference to know if the container is body.\n    this.isBody = container === document.body;\n\n    /* We're keeping track of a few different elements\n     *\n     * Container: the element that Backstretch was called on.\n     * Wrap: a DIV that we place the image into, so we can hide the overflow.\n     * Root: Convenience reference to help calculate the correct height.\n     */\n    var $window = $(window);\n    this.$container = $(container);\n    this.$root = this.isBody ? supportsFixedPosition ? $window : $(document) : this.$container;\n\n    this.originalImages = this.images;\n    this.images = optimalSizeImages(\n      this.options.alwaysTestWindowResolution ? $window : this.$root,\n      this.originalImages);\n\n    /**\n     * Pre-Loading.\n     * This is the first image, so we will preload a minimum of 1 images.\n     */\n    preload(this.images, this.options.start || 0, this.options.preload || 1);\n\n    // Don't create a new wrap if one already exists (from a previous instance of Backstretch)\n    var $existing = this.$container.children(\".backstretch\").first();\n    this.$wrap = $existing.length ? $existing :\n      $('<div class=\"backstretch\"></div>')\n        .css(this.options.bypassCss ? {} : styles.wrap)\n        .appendTo(this.$container);\n\n    if (!this.options.bypassCss) {\n\n      // Non-body elements need some style adjustments\n      if (!this.isBody) {\n        // If the container is statically positioned, we need to make it relative,\n        // and if no zIndex is defined, we should set it to zero.\n        var position = this.$container.css('position')\n          , zIndex = this.$container.css('zIndex');\n\n        this.$container.css({\n          position: position === 'static' ? 'relative' : position\n          , zIndex: zIndex === 'auto' ? 0 : zIndex\n        });\n\n        // Needs a higher z-index\n        this.$wrap.css({zIndex: -999998});\n      }\n\n      // Fixed or absolute positioning?\n      this.$wrap.css({\n        position: this.isBody && supportsFixedPosition ? 'fixed' : 'absolute'\n      });\n\n    }\n\n    // Set the first image\n    this.index = this.options.start;\n    this.show(this.index);\n\n    // Listen for resize\n    $window.on('resize.backstretch', $.proxy(this.resize, this))\n           .on('orientationchange.backstretch', $.proxy(function () {\n             // Need to do this in order to get the right window height\n             if (this.isBody && window.pageYOffset === 0) {\n               window.scrollTo(0, 1);\n               this.resize();\n             }\n           }, this));\n  };\n\n  var performTransition = function (options) {\n\n    var transition = options.transition || 'fade';\n\n    // Look for multiple options\n    if (typeof transition === 'string' && transition.indexOf('|') > -1) {\n      transition = transition.split('|');\n    }\n\n    if (transition instanceof Array) {\n      transition = transition[Math.round(Math.random() * (transition.length - 1))];\n    }\n\n    var $new = options['new'];\n    var $old = options['old'] ? options['old'] : $([]);\n\n    switch (transition.toString().toLowerCase()) {\n\n      default:\n      case 'fade':\n        $new.fadeIn({\n          duration: options.duration,\n          complete: options.complete,\n          easing: options.easing || undefined\n        });\n        break;\n\n      case 'fadeinout':\n      case 'fade_in_out':\n\n        var fadeInNew = function () {\n          $new.fadeIn({\n            duration: options.duration / 2,\n            complete: options.complete,\n            easing: options.easing || undefined\n          });\n        };\n\n        if ($old.length) {\n          $old.fadeOut({\n            duration: options.duration / 2,\n            complete: fadeInNew,\n            easing: options.easing || undefined\n          });\n        }\n        else {\n          fadeInNew();\n        }\n\n        break;\n\n      case 'pushleft':\n      case 'push_left':\n      case 'pushright':\n      case 'push_right':\n      case 'pushup':\n      case 'push_up':\n      case 'pushdown':\n      case 'push_down':\n      case 'coverleft':\n      case 'cover_left':\n      case 'coverright':\n      case 'cover_right':\n      case 'coverup':\n      case 'cover_up':\n      case 'coverdown':\n      case 'cover_down':\n\n        var transitionParts = transition.match(/^(cover|push)_?(.*)$/);\n\n        var animProp = transitionParts[2] === 'left' ? 'right' :\n          transitionParts[2] === 'right' ? 'left' :\n            transitionParts[2] === 'down' ? 'top' :\n              transitionParts[2] === 'up' ? 'bottom' :\n                'right';\n\n        var newCssStart = {\n          'display': ''\n        }, newCssAnim = {};\n        newCssStart[animProp] = '-100%';\n        newCssAnim[animProp] = 0;\n\n        $new\n          .css(newCssStart)\n          .animate(newCssAnim, {\n            duration: options.duration,\n            complete: function () {\n              $new.css(animProp, '');\n              options.complete.apply(this, arguments);\n            },\n            easing: options.easing || undefined\n          });\n\n        if (transitionParts[1] === 'push' && $old.length) {\n          var oldCssAnim = {};\n          oldCssAnim[animProp] = '100%';\n\n          $old\n            .animate(oldCssAnim, {\n              duration: options.duration,\n              complete: function () {\n                $old.css('display', 'none');\n              },\n              easing: options.easing || undefined\n            });\n        }\n\n        break;\n    }\n\n  };\n\n  /* PUBLIC METHODS\n   * ========================= */\n  Backstretch.prototype = {\n\n    resize: function () {\n      try {\n\n        // Check for a better suited image after the resize\n        var $resTest = this.options.alwaysTestWindowResolution ? $(window) : this.$root;\n        var newContainerWidth = $resTest.width();\n        var newContainerHeight = $resTest.height();\n        var changeRatioW = newContainerWidth / (this._lastResizeContainerWidth || 0);\n        var changeRatioH = newContainerHeight / (this._lastResizeContainerHeight || 0);\n        var resolutionChangeRatioThreshold = this.options.resolutionChangeRatioThreshold || 0.0;\n\n        // check for big changes in container size\n        if ((newContainerWidth !== this._lastResizeContainerWidth ||\n          newContainerHeight !== this._lastResizeContainerHeight) &&\n          ((Math.abs(changeRatioW - 1) >= resolutionChangeRatioThreshold || isNaN(changeRatioW)) ||\n            (Math.abs(changeRatioH - 1) >= resolutionChangeRatioThreshold || isNaN(changeRatioH)))) {\n\n          this._lastResizeContainerWidth = newContainerWidth;\n          this._lastResizeContainerHeight = newContainerHeight;\n\n          // Big change: rebuild the entire images array\n          this.images = optimalSizeImages($resTest, this.originalImages);\n\n          // Preload them (they will be automatically inserted on the next cycle)\n          if (this.options.preload) {\n            preload(this.images, (this.index + 1) % this.images.length, this.options.preload);\n          }\n\n          // In case there is no cycle and the new source is different than the current\n          if (this.images.length === 1 &&\n            this._currentImage.url !== this.images[0].url) {\n\n            // Wait a little an update the image being showed\n            var that = this;\n            clearTimeout(that._selectAnotherResolutionTimeout);\n            that._selectAnotherResolutionTimeout = setTimeout(function () {\n              that.show(0);\n            }, this.options.resolutionRefreshRate);\n          }\n        }\n\n        var bgCSS = {left: 0, top: 0, right: 'auto', bottom: 'auto'}\n\n          , boxWidth = this.isBody ? this.$root.width() : this.$root.innerWidth()\n          , boxHeight = this.isBody\n          ? (window.innerHeight ? window.innerHeight : this.$root.height())\n          : this.$root.innerHeight()\n\n          , naturalWidth = this.$itemWrapper.data('width')\n          , naturalHeight = this.$itemWrapper.data('height')\n\n          , ratio = (naturalWidth / naturalHeight) || 1\n\n          , alignX = this._currentImage.alignX === undefined ? this.options.alignX : this._currentImage.alignX\n          , alignY = this._currentImage.alignY === undefined ? this.options.alignY : this._currentImage.alignY\n          , scale = validScale(this._currentImage.scale || this.options.scale);\n\n        var width, height;\n\n        if (scale === 'fit' || scale === 'fit-smaller') {\n          width = naturalWidth;\n          height = naturalHeight;\n\n          if (width > boxWidth ||\n            height > boxHeight ||\n            scale === 'fit-smaller') {\n            var boxRatio = boxWidth / boxHeight;\n            if (boxRatio > ratio) {\n              width = Math.floor(boxHeight * ratio);\n              height = boxHeight;\n            }\n            else if (boxRatio < ratio) {\n              width = boxWidth;\n              height = Math.floor(boxWidth / ratio);\n            }\n            else {\n              width = boxWidth;\n              height = boxHeight;\n            }\n          }\n        }\n        else if (scale === 'fill') {\n          width = boxWidth;\n          height = boxHeight;\n        }\n        else { // 'cover'\n          width = Math.max(boxHeight * ratio, boxWidth);\n          height = Math.max(width / ratio, boxHeight);\n        }\n\n        // Make adjustments based on image ratio\n        bgCSS.top = -(height - boxHeight) * alignY;\n        bgCSS.left = -(width - boxWidth) * alignX;\n        bgCSS.width = width;\n        bgCSS.height = height;\n\n        if (!this.options.bypassCss) {\n\n          this.$wrap\n              .css({width: boxWidth, height: boxHeight})\n              .find('>.backstretch-item').not('.deleteable')\n              .each(function () {\n                var $wrapper = $(this);\n                $wrapper.find('img,video,iframe')\n                        .css(bgCSS);\n              });\n        }\n\n        var evt = $.Event('backstretch.resize', {\n          relatedTarget: this.$container[0]\n        });\n        this.$container.trigger(evt, this);\n\n      }\n      catch (err) {\n        // IE7 seems to trigger resize before the image is loaded.\n        // This try/catch block is a hack to let it fail gracefully.\n      }\n\n      return this;\n    }\n\n    // Show the slide at a certain position\n    , show: function (newIndex, overrideOptions) {\n\n      // Validate index\n      if (Math.abs(newIndex) > this.images.length - 1) {\n        return;\n      }\n\n      // Vars\n      var that = this\n        , $oldItemWrapper = that.$wrap.find('>.backstretch-item').addClass('deleteable')\n        , oldVideoWrapper = that.videoWrapper\n        , evtOptions = {relatedTarget: that.$container[0]};\n\n      // Trigger the \"before\" event\n      that.$container.trigger($.Event('backstretch.before', evtOptions), [that, newIndex]);\n\n      // Set the new frame index\n      this.index = newIndex;\n      var selectedImage = that.images[newIndex];\n\n      // Pause the slideshow\n      clearTimeout(that._cycleTimeout);\n\n      // New image\n\n      delete that.videoWrapper; // Current item may not be a video\n\n      var isVideo = isVideoSource(selectedImage);\n      if (isVideo) {\n        that.videoWrapper = new VideoWrapper(selectedImage);\n        that.$item = that.videoWrapper.$video.css('pointer-events', 'none');\n      }\n      else {\n        that.$item = $('<img />');\n      }\n\n      that.$itemWrapper = $('<div class=\"backstretch-item\">')\n        .append(that.$item);\n\n      if (this.options.bypassCss) {\n        that.$itemWrapper.css({\n          'display': 'none'\n        });\n      }\n      else {\n        that.$itemWrapper.css(styles.itemWrapper);\n        that.$item.css(styles.item);\n      }\n\n      that.$item.bind(isVideo ? 'canplay' : 'load', function (e) {\n        var $this = $(this)\n          , $wrapper = $this.parent()\n          , options = $wrapper.data('options');\n\n        if (overrideOptions) {\n          options = $.extend({}, options, overrideOptions);\n        }\n\n        var imgWidth = this.naturalWidth || this.videoWidth || this.width\n          , imgHeight = this.naturalHeight || this.videoHeight || this.height;\n\n        // Save the natural dimensions\n        $wrapper\n          .data('width', imgWidth)\n          .data('height', imgHeight);\n\n        var getOption = function (opt) {\n          return options[opt] !== undefined ?\n            options[opt] :\n            that.options[opt];\n        };\n\n        var transition = getOption('transition');\n        var transitionEasing = getOption('transitionEasing');\n        var transitionDuration = getOption('transitionDuration');\n\n        // Show the image, then delete the old one\n        var bringInNextImage = function () {\n\n          if (oldVideoWrapper) {\n            oldVideoWrapper.stop();\n            oldVideoWrapper.destroy();\n          }\n\n          $oldItemWrapper.remove();\n\n          // Resume the slideshow\n          if (!that.paused && that.images.length > 1) {\n            that.cycle();\n          }\n\n          // Now we can clear the background on the element, to spare memory\n          if (!that.options.bypassCss && !that.isBody) {\n            that.$container.css('background-image', 'none');\n          }\n\n          // Trigger the \"after\" and \"show\" events\n          // \"show\" is being deprecated\n          $(['after', 'show']).each(function () {\n            that.$container.trigger($.Event('backstretch.' + this, evtOptions), [that, newIndex]);\n          });\n\n          if (isVideo) {\n            that.videoWrapper.play();\n          }\n        };\n\n        if ((that.firstShow && !that.options.animateFirst) || !transitionDuration || !transition) {\n          // Avoid transition on first show or if there's no transitionDuration value\n          $wrapper.show();\n          bringInNextImage();\n        }\n        else {\n\n          performTransition({\n            'new': $wrapper,\n            old: $oldItemWrapper,\n            transition: transition,\n            duration: transitionDuration,\n            easing: transitionEasing,\n            complete: bringInNextImage\n          });\n\n        }\n\n        that.firstShow = false;\n\n        // Resize\n        that.resize();\n      });\n\n      that.$itemWrapper.appendTo(that.$wrap);\n\n      that.$item.attr('alt', selectedImage.alt || '');\n      that.$itemWrapper.data('options', selectedImage);\n\n      if (!isVideo) {\n        that.$item.attr('src', selectedImage.url);\n      }\n\n      that._currentImage = selectedImage;\n\n      return that;\n    }\n\n    , current: function () {\n      return this.index;\n    }\n\n    , next: function () {\n      var args = Array.prototype.slice.call(arguments, 0);\n      args.unshift(this.index < this.images.length - 1 ? this.index + 1 : 0);\n      return this.show.apply(this, args);\n    }\n\n    , prev: function () {\n      var args = Array.prototype.slice.call(arguments, 0);\n      args.unshift(this.index === 0 ? this.images.length - 1 : this.index - 1);\n      return this.show.apply(this, args);\n    }\n\n    , pause: function () {\n      // Pause the slideshow\n      this.paused = true;\n\n      if (this.videoWrapper) {\n        this.videoWrapper.pause();\n      }\n\n      return this;\n    }\n\n    , resume: function () {\n      // Resume the slideshow\n      this.paused = false;\n\n      if (this.videoWrapper) {\n        this.videoWrapper.play();\n      }\n\n      this.cycle();\n      return this;\n    }\n\n    , cycle: function () {\n      // Start/resume the slideshow\n      if (this.images.length > 1) {\n        // Clear the timeout, just in case\n        clearTimeout(this._cycleTimeout);\n\n        var duration = (this._currentImage && this._currentImage.duration) || this.options.duration;\n        var isVideo = isVideoSource(this._currentImage);\n\n        var callNext = function () {\n          this.$item.off('.cycle');\n\n          // Check for paused slideshow\n          if (!this.paused) {\n            this.next();\n          }\n        };\n\n        // Special video handling\n        if (isVideo) {\n\n          // Leave video at last frame\n          if (!this._currentImage.loop) {\n            var lastFrameTimeout = 0;\n\n            this.$item\n                .on('playing.cycle', function () {\n                  var player = $(this).data('player');\n\n                  clearTimeout(lastFrameTimeout);\n                  lastFrameTimeout = setTimeout(function () {\n                    player.pause();\n                    player.$video.trigger('ended');\n                  }, (player.getDuration() - player.getCurrentTime()) * 1000);\n                })\n                .on('ended.cycle', function () {\n                  clearTimeout(lastFrameTimeout);\n                });\n          }\n\n          // On error go to next\n          this.$item.on('error.cycle initerror.cycle', $.proxy(callNext, this));\n        }\n\n        if (isVideo && !this._currentImage.duration) {\n          // It's a video - playing until end\n          this.$item.on('ended.cycle', $.proxy(callNext, this));\n\n        }\n        else {\n          // Cycling according to specified duration\n          this._cycleTimeout = setTimeout($.proxy(callNext, this), duration);\n        }\n\n      }\n      return this;\n    }\n\n    , destroy: function (preserveBackground) {\n      // Stop the resize events\n      $(window).off('resize.backstretch orientationchange.backstretch');\n\n      // Stop any videos\n      if (this.videoWrapper) {\n        this.videoWrapper.destroy();\n      }\n\n      // Clear the timeout\n      clearTimeout(this._cycleTimeout);\n\n      // Remove Backstretch\n      if (!preserveBackground) {\n        this.$wrap.remove();\n      }\n      this.$container.removeData('backstretch');\n    }\n  };\n\n  /**\n   * Video Abstraction Layer\n   *\n   * Static methods:\n   * > VideoWrapper.loadYoutubeAPI() -> Call in order to load the Youtube API.\n   *                                   An 'youtube_api_load' event will be triggered on $(window) when the API is loaded.\n   *\n   * Generic:\n   * > player.type -> type of the video\n   * > player.video / player.$video -> contains the element holding the video\n   * > player.play() -> plays the video\n   * > player.pause() -> pauses the video\n   * > player.setCurrentTime(position) -> seeks to a position by seconds\n   *\n   * Youtube:\n   * > player.ytId will contain the youtube ID if the source is a youtube url\n   * > player.ytReady is a flag telling whether the youtube source is ready for playback\n   * */\n\n  var VideoWrapper = function () { this.init.apply(this, arguments); };\n\n  /**\n   * @param {Object} options\n   * @param {String|Array<String>|Array<{{src: String, type: String?}}>} options.url\n   * @param {Boolean} options.loop=false\n   * @param {Boolean?} options.mute=true\n   * @param {String?} options.poster\n   * loop, mute, poster\n   */\n  VideoWrapper.prototype.init = function (options) {\n\n    var that = this;\n\n    var $video;\n\n    var setVideoElement = function () {\n      that.$video = $video;\n      that.video = $video[0];\n    };\n\n    // Determine video type\n\n    var videoType = 'video';\n\n    if (!(options.url instanceof Array) &&\n      YOUTUBE_REGEXP.test(options.url)) {\n      videoType = 'youtube';\n    }\n\n    that.type = videoType;\n\n    if (videoType === 'youtube') {\n\n      // Try to load the API in the meantime\n      VideoWrapper.loadYoutubeAPI();\n\n      that.ytId = options.url.match(YOUTUBE_REGEXP)[2];\n      var src = 'https://www.youtube.com/embed/' + that.ytId +\n        '?rel=0&autoplay=0&showinfo=0&controls=0&modestbranding=1' +\n        '&cc_load_policy=0&disablekb=1&iv_load_policy=3&loop=0' +\n        '&enablejsapi=1&origin=' + encodeURIComponent(window.location.origin);\n\n      that.__ytStartMuted = !!options.mute || options.mute === undefined;\n\n      $video = $('<iframe />')\n        .attr({'src_to_load': src})\n        .css({'border': 0, 'margin': 0, 'padding': 0})\n        .data('player', that);\n\n      if (options.loop) {\n        $video.on('ended.loop', function () {\n          if (!that.__manuallyStopped) {\n            that.play();\n          }\n        });\n      }\n\n      that.ytReady = false;\n\n      setVideoElement();\n\n      if (window['YT'] && window['YT'].loaded) {\n        that._initYoutube();\n        $video.trigger('initsuccess');\n      }\n      else {\n        $(window).one('youtube_api_load', function () {\n          that._initYoutube();\n          $video.trigger('initsuccess');\n        });\n      }\n\n    }\n    else {\n      // Traditional <video> tag with multiple sources\n\n      $video = $('<video>')\n        .prop('autoplay', false)\n        .prop('controls', false)\n        .prop('loop', !!options.loop)\n        .prop('muted', !!options.mute || options.mute === undefined)\n\n        // Let the first frames be available before playback, as we do transitions\n        .prop('preload', 'auto')\n        .prop('poster', options.poster || '');\n\n      var sources = (options.url instanceof Array) ? options.url : [options.url];\n\n      for (var i = 0; i < sources.length; i++) {\n        var sourceItem = sources[i];\n        if (typeof (sourceItem) === 'string') {\n          sourceItem = {src: sourceItem};\n        }\n        $('<source>')\n          .attr('src', sourceItem.src)\n          // Make sure to not specify type if unknown -\n          //   so the browser will try to autodetect.\n          .attr('type', sourceItem.type || null)\n          .appendTo($video);\n      }\n\n      if (!$video[0].canPlayType || !sources.length) {\n        $video.trigger('initerror');\n      }\n      else {\n        $video.trigger('initsuccess');\n      }\n\n      setVideoElement();\n    }\n\n  };\n\n  VideoWrapper.prototype._initYoutube = function () {\n    var that = this;\n\n    var YT = window['YT'];\n\n    that.$video\n        .attr('src', that.$video.attr('src_to_load'))\n        .removeAttr('src_to_load');\n\n    // It won't init if it's not in the DOM, so we emulate that\n    var hasParent = !!that.$video[0].parentNode;\n    if (!hasParent) {\n      var $tmpParent = $('<div>').css('display', 'none !important').appendTo(document.body);\n      that.$video.appendTo($tmpParent);\n    }\n\n    var player = new YT.Player(that.video, {\n      events: {\n        'onReady': function () {\n\n          if (that.__ytStartMuted) {\n            player.mute();\n          }\n\n          if (!hasParent) {\n            // Restore parent to old state - without interrupting any changes\n            if (that.$video[0].parentNode === $tmpParent[0]) {\n              that.$video.detach();\n            }\n            $tmpParent.remove();\n          }\n\n          that.ytReady = true;\n          that._updateYoutubeSize();\n          that.$video.trigger('canplay');\n        },\n        'onStateChange': function (event) {\n          switch (event.data) {\n            case YT.PlayerState.PLAYING:\n              that.$video.trigger('playing');\n              break;\n            case YT.PlayerState.ENDED:\n              that.$video.trigger('ended');\n              break;\n            case YT.PlayerState.PAUSED:\n              that.$video.trigger('pause');\n              break;\n            case YT.PlayerState.BUFFERING:\n              that.$video.trigger('waiting');\n              break;\n            case YT.PlayerState.CUED:\n              that.$video.trigger('canplay');\n              break;\n          }\n        },\n        'onPlaybackQualityChange': function () {\n          that._updateYoutubeSize();\n          that.$video.trigger('resize');\n        },\n        'onError': function (err) {\n          that.hasError = true;\n          that.$video.trigger({'type': 'error', 'error': err});\n        }\n      }\n    });\n\n    that.ytPlayer = player;\n\n    return that;\n  };\n\n  VideoWrapper.prototype._updateYoutubeSize = function () {\n    var that = this;\n\n    switch (that.ytPlayer.getPlaybackQuality() || 'medium') {\n      case 'small':\n        that.video.videoWidth = 426;\n        that.video.videoHeight = 240;\n        break;\n      case 'medium':\n        that.video.videoWidth = 640;\n        that.video.videoHeight = 360;\n        break;\n      default:\n      case 'large':\n        that.video.videoWidth = 854;\n        that.video.videoHeight = 480;\n        break;\n      case 'hd720':\n        that.video.videoWidth = 1280;\n        that.video.videoHeight = 720;\n        break;\n      case 'hd1080':\n        that.video.videoWidth = 1920;\n        that.video.videoHeight = 1080;\n        break;\n      case 'highres':\n        that.video.videoWidth = 2560;\n        that.video.videoHeight = 1440;\n        break;\n    }\n\n    return that;\n  };\n\n  VideoWrapper.prototype.play = function () {\n    var that = this;\n\n    that.__manuallyStopped = false;\n\n    if (that.type === 'youtube') {\n      if (that.ytReady) {\n        that.$video.trigger('play');\n        that.ytPlayer.playVideo();\n      }\n    }\n    else {\n      that.video.play();\n    }\n\n    return that;\n  };\n\n  VideoWrapper.prototype.pause = function () {\n    var that = this;\n\n    that.__manuallyStopped = false;\n\n    if (that.type === 'youtube') {\n      if (that.ytReady) {\n        that.ytPlayer.pauseVideo();\n      }\n    }\n    else {\n      that.video.pause();\n    }\n\n    return that;\n  };\n\n  VideoWrapper.prototype.stop = function () {\n    var that = this;\n\n    that.__manuallyStopped = true;\n\n    if (that.type === 'youtube') {\n      if (that.ytReady) {\n        that.ytPlayer.pauseVideo();\n        that.ytPlayer.seekTo(0);\n      }\n    }\n    else {\n      that.video.pause();\n      that.video.currentTime = 0;\n    }\n\n    return that;\n  };\n\n  VideoWrapper.prototype.destroy = function () {\n    var that = this;\n\n    if (that.ytPlayer) {\n      that.ytPlayer.destroy();\n    }\n\n    that.$video.remove();\n\n    return that;\n  };\n\n  VideoWrapper.prototype.getCurrentTime = function (seconds) {\n    var that = this;\n\n    if (that.type === 'youtube') {\n      if (that.ytReady) {\n        return that.ytPlayer.getCurrentTime();\n      }\n    }\n    else {\n      return that.video.currentTime;\n    }\n\n    return 0;\n  };\n\n  VideoWrapper.prototype.setCurrentTime = function (seconds) {\n    var that = this;\n\n    if (that.type === 'youtube') {\n      if (that.ytReady) {\n        that.ytPlayer.seekTo(seconds, true);\n      }\n    }\n    else {\n      that.video.currentTime = seconds;\n    }\n\n    return that;\n  };\n\n  VideoWrapper.prototype.getDuration = function () {\n    var that = this;\n\n    if (that.type === 'youtube') {\n      if (that.ytReady) {\n        return that.ytPlayer.getDuration();\n      }\n    }\n    else {\n      return that.video.duration;\n    }\n\n    return 0;\n  };\n\n  /**\n   * This will load the youtube API (if not loaded yet)\n   * Use $(window).one('youtube_api_load', ...) to listen for API loaded event\n   */\n  VideoWrapper.loadYoutubeAPI = function () {\n    if (window['YT'] && window['__yt_load_event_interval__']) {\n      return;\n    }\n    \n    if (!window['YT'] && !$('script[src*=www\\\\.youtube\\\\.com\\\\/iframe_api]').length) {\n      $('<script type=\"text/javascript\" src=\"https://www.youtube.com/iframe_api\">').appendTo('body');\n    }\n    \n    window['__yt_load_event_interval__'] = setInterval(function () {\n      if (window['YT'] && window['YT'].loaded) {\n        $(window).trigger('youtube_api_load');\n        clearTimeout(window['__yt_load_event_interval__']);\n        delete window['__yt_load_event_interval__'];\n      }\n    }, 50);\n  };\n\n  var getDeviceOrientation = function () {\n\n    if ('matchMedia' in window) {\n      if (window.matchMedia(\"(orientation: portrait)\").matches) {\n        return 'portrait';\n      }\n      else if (window.matchMedia(\"(orientation: landscape)\").matches) {\n        return 'landscape';\n      }\n    }\n\n    if (screen.height > screen.width) {\n      return 'portrait';\n    }\n\n    // Even square devices have orientation,\n    //   but a desktop browser may be too old for `matchMedia`.\n    // Defaulting to `landscape` for the VERY rare case of a square desktop screen is good enough.\n    return 'landscape';\n  };\n\n  var getWindowOrientation = function () {\n    if (window.innerHeight > window.innerWidth) {\n      return 'portrait';\n    }\n    if (window.innerWidth > window.innerHeight) {\n      return 'landscape';\n    }\n\n    return 'square';\n  };\n\n  /* SUPPORTS FIXED POSITION?\n   *\n   * Based on code from jQuery Mobile 1.1.0\n   * http://jquerymobile.com/\n   *\n   * In a nutshell, we need to figure out if fixed positioning is supported.\n   * Unfortunately, this is very difficult to do on iOS, and usually involves\n   * injecting content, scrolling the page, etc.. It's ugly.\n   * jQuery Mobile uses this workaround. It's not ideal, but works.\n   *\n   * Modified to detect IE6\n   * ========================= */\n\n  var supportsFixedPosition = (function () {\n    var ua = navigator.userAgent\n      , platform = navigator.platform\n      // Rendering engine is Webkit, and capture major version\n      , wkmatch = ua.match(/AppleWebKit\\/([0-9]+)/)\n      , wkversion = !!wkmatch && wkmatch[1]\n      , ffmatch = ua.match(/Fennec\\/([0-9]+)/)\n      , ffversion = !!ffmatch && ffmatch[1]\n      , operammobilematch = ua.match(/Opera Mobi\\/([0-9]+)/)\n      , omversion = !!operammobilematch && operammobilematch[1]\n      , iematch = ua.match(/MSIE ([0-9]+)/)\n      , ieversion = !!iematch && iematch[1];\n\n    return !(\n      // iOS 4.3 and older : Platform is iPhone/Pad/Touch and Webkit version is less than 534 (ios5)\n      ((platform.indexOf(\"iPhone\") > -1 || platform.indexOf(\"iPad\") > -1 || platform.indexOf(\n        \"iPod\") > -1) && wkversion && wkversion < 534) ||\n\n      // Opera Mini\n      (window.operamini && ({}).toString.call(window.operamini) === \"[object OperaMini]\") ||\n      (operammobilematch && omversion < 7458) ||\n\n      //Android lte 2.1: Platform is Android and Webkit version is less than 533 (Android 2.2)\n      (ua.indexOf(\"Android\") > -1 && wkversion && wkversion < 533) ||\n\n      // Firefox Mobile before 6.0 -\n      (ffversion && ffversion < 6) ||\n\n      // WebOS less than 3\n      (\"palmGetResource\" in window && wkversion && wkversion < 534) ||\n\n      // MeeGo\n      (ua.indexOf(\"MeeGo\") > -1 && ua.indexOf(\"NokiaBrowser/8.5.0\") > -1) ||\n\n      // IE6\n      (ieversion && ieversion <= 6)\n    );\n  }());\n\n}(jQuery, window));\n"
        },
        {
          "name": "jquery.backstretch.min.js",
          "type": "blob",
          "size": 17.208984375,
          "content": "/*! Backstretch - v2.1.18 - 2019-09-18\\n* Copyright (c) 2019 Scott Robbin;* Fork of improvements - by Daniel Cohen Gindi (danielgindi@gmail.com) Licensed MIT */!function(a,b,c){\"use strict\";function d(a){return m.hasOwnProperty(a)?a:\"cover\"}var e=/^.*(youtu\\.be\\/|youtube\\.com\\/v\\/|youtube\\.com\\/embed\\/|youtube\\.com\\/watch\\?v=|youtube\\.com\\/watch\\?.*\\&v=)([^#\\&\\?]*).*/i;a.fn.backstretch=function(d,e){var f=arguments;0===a(b).scrollTop()&&b.scrollTo(0,0);var g;return this.each(function(b){var h=a(this),i=h.data(\"backstretch\");if(i){if(\"string\"==typeof f[0]&&\"function\"==typeof i[f[0]]){var j=i[f[0]].apply(i,Array.prototype.slice.call(f,1));return j===i&&(j=c),void(j!==c&&(g=g||[],g[b]=j))}e=a.extend(i.options,e),\"object\"==typeof i&&\"destroy\"in i&&i.destroy(!0)}if(!d||d&&0===d.length){var k=h.css(\"background-image\");k&&\"none\"!==k?d=[{url:h.css(\"backgroundImage\").replace(/url\\(|\\)|\"|'/g,\"\")}]:a.error(\"No images were supplied for Backstretch, or element must have a CSS-defined background image.\")}i=new n(this,d,e||{}),h.data(\"backstretch\",i)}),g?1===g.length?g[0]:g:this},a.backstretch=function(b,c){return a(\"body\").backstretch(b,c).data(\"backstretch\")},a.expr[\":\"].backstretch=function(b){return a(b).data(\"backstretch\")!==c},a.fn.backstretch.defaults={duration:5e3,transition:\"fade\",transitionDuration:0,animateFirst:!0,alignX:.5,alignY:.5,paused:!1,start:0,preload:2,preloadSize:1,resolutionRefreshRate:2500,resolutionChangeRatioThreshold:.1};var f={wrap:{left:0,top:0,overflow:\"hidden\",margin:0,padding:0,height:\"100%\",width:\"100%\",zIndex:-999999},itemWrapper:{position:\"absolute\",display:\"none\",margin:0,padding:0,border:\"none\",width:\"100%\",height:\"100%\",zIndex:-999999},item:{position:\"absolute\",margin:0,padding:0,border:\"none\",width:\"100%\",height:\"100%\",maxWidth:\"none\"}},g=function(){var c=function(a){for(var b=1;b<a.length;b++){for(var c=a[b],d=b;a[d-1]&&parseInt(a[d-1].width,10)>parseInt(c.width,10);)a[d]=a[d-1],--d;a[d]=c}return a},d=function(a,c,d){for(var e,f,g=b.devicePixelRatio||1,h=q(),i=(r(),c>a?\"portrait\":a>c?\"landscape\":\"square\"),j=0,k=0;k<d.length&&(f=d[k],\"string\"==typeof f&&(f=d[k]={url:f}),f.pixelRatio&&\"auto\"!==f.pixelRatio&&parseFloat(f.pixelRatio)!==g||f.deviceOrientation&&f.deviceOrientation!==h||f.windowOrientation&&f.windowOrientation!==h||f.orientation&&f.orientation!==i||(j=k,e=a,\"auto\"===f.pixelRatio&&(a*=g),!(f.width>=e)));k++);return d[Math.min(k,j)]},e=function(a,b){if(\"string\"==typeof a)a=a.replace(/{{(width|height)}}/g,b);else if(a instanceof Array)for(var c=0;c<a.length;c++)a[c].src?a[c].src=e(a[c].src,b):a[c]=e(a[c],b);return a};return function(b,f){for(var g=b.width(),h=b.height(),i=[],j=function(a,b){return\"width\"===b?g:\"height\"===b?h:a},k=0;k<f.length;k++)if(a.isArray(f[k])){f[k]=c(f[k]);var l=d(g,h,f[k]);i.push(l)}else{\"string\"==typeof f[k]&&(f[k]={url:f[k]});var m=a.extend({},f[k]);m.url=e(m.url,j),i.push(m)}return i}}(),h=function(a){return e.test(a.url)||a.isVideo},i=function(b,c,d,e,f){var g=[],i=function(a){for(var b=0;b<g.length;b++)if(g[b].src===a.src)return g[b];return g.push(a),a},j=function(a,b,c){\"function\"==typeof b&&b.call(a,c)};return function b(c,d,e,f,g){if(\"undefined\"!=typeof c){a.isArray(c)||(c=[c]),arguments.length<5&&\"function\"==typeof arguments[arguments.length-1]&&(g=arguments[arguments.length-1]),d=\"function\"!=typeof d&&d?d:0,e=\"function\"==typeof e||!e||e<0?c.length:Math.min(e,c.length),f=\"function\"!=typeof f&&f?f:1,d>=c.length&&(d=0,e=0),f<0&&(f=e),f=Math.min(f,e);var k=c.slice(d+f,e-f);if(c=c.slice(d,f),e=c.length,!e)return void j(c,g,!0);for(var l,m=0,n=function(){m++,m===e&&(j(c,g,!k),b(k,0,0,f,g))},o=0;o<c.length;o++)h(c[o])||(l=new Image,l.src=c[o].url,l=i(l),l.complete?n():a(l).on(\"load error\",n))}}}(),j=function(b){for(var c=[],d=0;d<b.length;d++)\"string\"==typeof b[d]?c.push({url:b[d]}):a.isArray(b[d])?c.push(j(b[d])):c.push(k(b[d]));return c},k=function(a,e){return(a.centeredX||a.centeredY)&&(b.console&&b.console.log&&b.console.log(\"jquery.backstretch: `centeredX`/`centeredY` is deprecated, please use `alignX`/`alignY`\"),a.centeredX&&(a.alignX=.5),a.centeredY&&(a.alignY=.5)),a.speed!==c&&(b.console&&b.console.log&&b.console.log(\"jquery.backstretch: `speed` is deprecated, please use `transitionDuration`\"),a.transitionDuration=a.speed,a.transition=\"fade\"),a.resolutionChangeRatioTreshold!==c&&(b.console.log(\"jquery.backstretch: `treshold` is a typo!\"),a.resolutionChangeRatioThreshold=a.resolutionChangeRatioTreshold),a.fadeFirst!==c&&(a.animateFirst=a.fadeFirst),a.fade!==c&&(a.transitionDuration=a.fade,a.transition=\"fade\"),a.scale&&(a.scale=d(a.scale)),l(a)},l=function(a,b){return\"left\"===a.alignX?a.alignX=0:\"center\"===a.alignX?a.alignX=.5:\"right\"===a.alignX?a.alignX=1:(a.alignX!==c||b)&&(a.alignX=parseFloat(a.alignX),isNaN(a.alignX)&&(a.alignX=.5)),\"top\"===a.alignY?a.alignY=0:\"center\"===a.alignY?a.alignY=.5:\"bottom\"===a.alignY?a.alignY=1:(a.alignX!==c||b)&&(a.alignY=parseFloat(a.alignY),isNaN(a.alignY)&&(a.alignY=.5)),a},m={cover:\"cover\",fit:\"fit\",\"fit-smaller\":\"fit-smaller\",fill:\"fill\"},n=function(c,d,e){this.options=a.extend({},a.fn.backstretch.defaults,e||{}),this.firstShow=!0,k(this.options,!0),this.images=j(a.isArray(d)?d:[d]),this.options.paused&&(this.paused=!0),this.options.start>=this.images.length&&(this.options.start=this.images.length-1),this.options.start<0&&(this.options.start=0),this.isBody=c===document.body;var h=a(b);this.$container=a(c),this.$root=this.isBody?s?h:a(document):this.$container,this.originalImages=this.images,this.images=g(this.options.alwaysTestWindowResolution?h:this.$root,this.originalImages),i(this.images,this.options.start||0,this.options.preload||1);var l=this.$container.children(\".backstretch\").first();if(this.$wrap=l.length?l:a('<div class=\"backstretch\"></div>').css(this.options.bypassCss?{}:f.wrap).appendTo(this.$container),!this.options.bypassCss){if(!this.isBody){var m=this.$container.css(\"position\"),n=this.$container.css(\"zIndex\");this.$container.css({position:\"static\"===m?\"relative\":m,zIndex:\"auto\"===n?0:n}),this.$wrap.css({zIndex:-999998})}this.$wrap.css({position:this.isBody&&s?\"fixed\":\"absolute\"})}this.index=this.options.start,this.show(this.index),h.on(\"resize.backstretch\",a.proxy(this.resize,this)).on(\"orientationchange.backstretch\",a.proxy(function(){this.isBody&&0===b.pageYOffset&&(b.scrollTo(0,1),this.resize())},this))},o=function(b){var d=b.transition||\"fade\";\"string\"==typeof d&&d.indexOf(\"|\")>-1&&(d=d.split(\"|\")),d instanceof Array&&(d=d[Math.round(Math.random()*(d.length-1))]);var e=b.new,f=b.old?b.old:a([]);switch(d.toString().toLowerCase()){default:case\"fade\":e.fadeIn({duration:b.duration,complete:b.complete,easing:b.easing||c});break;case\"fadeinout\":case\"fade_in_out\":var g=function(){e.fadeIn({duration:b.duration/2,complete:b.complete,easing:b.easing||c})};f.length?f.fadeOut({duration:b.duration/2,complete:g,easing:b.easing||c}):g();break;case\"pushleft\":case\"push_left\":case\"pushright\":case\"push_right\":case\"pushup\":case\"push_up\":case\"pushdown\":case\"push_down\":case\"coverleft\":case\"cover_left\":case\"coverright\":case\"cover_right\":case\"coverup\":case\"cover_up\":case\"coverdown\":case\"cover_down\":var h=d.match(/^(cover|push)_?(.*)$/),i=\"left\"===h[2]?\"right\":\"right\"===h[2]?\"left\":\"down\"===h[2]?\"top\":\"up\"===h[2]?\"bottom\":\"right\",j={display:\"\"},k={};if(j[i]=\"-100%\",k[i]=0,e.css(j).animate(k,{duration:b.duration,complete:function(){e.css(i,\"\"),b.complete.apply(this,arguments)},easing:b.easing||c}),\"push\"===h[1]&&f.length){var l={};l[i]=\"100%\",f.animate(l,{duration:b.duration,complete:function(){f.css(\"display\",\"none\")},easing:b.easing||c})}}};n.prototype={resize:function(){try{var e=this.options.alwaysTestWindowResolution?a(b):this.$root,f=e.width(),h=e.height(),j=f/(this._lastResizeContainerWidth||0),k=h/(this._lastResizeContainerHeight||0),l=this.options.resolutionChangeRatioThreshold||0;if((f!==this._lastResizeContainerWidth||h!==this._lastResizeContainerHeight)&&(Math.abs(j-1)>=l||isNaN(j)||Math.abs(k-1)>=l||isNaN(k))&&(this._lastResizeContainerWidth=f,this._lastResizeContainerHeight=h,this.images=g(e,this.originalImages),this.options.preload&&i(this.images,(this.index+1)%this.images.length,this.options.preload),1===this.images.length&&this._currentImage.url!==this.images[0].url)){var m=this;clearTimeout(m._selectAnotherResolutionTimeout),m._selectAnotherResolutionTimeout=setTimeout(function(){m.show(0)},this.options.resolutionRefreshRate)}var n,o,p={left:0,top:0,right:\"auto\",bottom:\"auto\"},q=this.isBody?this.$root.width():this.$root.innerWidth(),r=this.isBody?b.innerHeight?b.innerHeight:this.$root.height():this.$root.innerHeight(),s=this.$itemWrapper.data(\"width\"),t=this.$itemWrapper.data(\"height\"),u=s/t||1,v=this._currentImage.alignX===c?this.options.alignX:this._currentImage.alignX,w=this._currentImage.alignY===c?this.options.alignY:this._currentImage.alignY,x=d(this._currentImage.scale||this.options.scale);if(\"fit\"===x||\"fit-smaller\"===x){if(n=s,o=t,n>q||o>r||\"fit-smaller\"===x){var y=q/r;y>u?(n=Math.floor(r*u),o=r):y<u?(n=q,o=Math.floor(q/u)):(n=q,o=r)}}else\"fill\"===x?(n=q,o=r):(n=Math.max(r*u,q),o=Math.max(n/u,r));p.top=-(o-r)*w,p.left=-(n-q)*v,p.width=n,p.height=o,this.options.bypassCss||this.$wrap.css({width:q,height:r}).find(\">.backstretch-item\").not(\".deleteable\").each(function(){var b=a(this);b.find(\"img,video,iframe\").css(p)});var z=a.Event(\"backstretch.resize\",{relatedTarget:this.$container[0]});this.$container.trigger(z,this)}catch(a){}return this},show:function(b,d){if(!(Math.abs(b)>this.images.length-1)){var e=this,g=e.$wrap.find(\">.backstretch-item\").addClass(\"deleteable\"),i=e.videoWrapper,j={relatedTarget:e.$container[0]};e.$container.trigger(a.Event(\"backstretch.before\",j),[e,b]),this.index=b;var k=e.images[b];clearTimeout(e._cycleTimeout),delete e.videoWrapper;var l=h(k);return l?(e.videoWrapper=new p(k),e.$item=e.videoWrapper.$video.css(\"pointer-events\",\"none\")):e.$item=a(\"<img />\"),e.$itemWrapper=a('<div class=\"backstretch-item\">').append(e.$item),this.options.bypassCss?e.$itemWrapper.css({display:\"none\"}):(e.$itemWrapper.css(f.itemWrapper),e.$item.css(f.item)),e.$item.bind(l?\"canplay\":\"load\",function(f){var h=a(this),k=h.parent(),m=k.data(\"options\");d&&(m=a.extend({},m,d));var n=this.naturalWidth||this.videoWidth||this.width,p=this.naturalHeight||this.videoHeight||this.height;k.data(\"width\",n).data(\"height\",p);var q=function(a){return m[a]!==c?m[a]:e.options[a]},r=q(\"transition\"),s=q(\"transitionEasing\"),t=q(\"transitionDuration\"),u=function(){i&&(i.stop(),i.destroy()),g.remove(),!e.paused&&e.images.length>1&&e.cycle(),e.options.bypassCss||e.isBody||e.$container.css(\"background-image\",\"none\"),a([\"after\",\"show\"]).each(function(){e.$container.trigger(a.Event(\"backstretch.\"+this,j),[e,b])}),l&&e.videoWrapper.play()};e.firstShow&&!e.options.animateFirst||!t||!r?(k.show(),u()):o({new:k,old:g,transition:r,duration:t,easing:s,complete:u}),e.firstShow=!1,e.resize()}),e.$itemWrapper.appendTo(e.$wrap),e.$item.attr(\"alt\",k.alt||\"\"),e.$itemWrapper.data(\"options\",k),l||e.$item.attr(\"src\",k.url),e._currentImage=k,e}},current:function(){return this.index},next:function(){var a=Array.prototype.slice.call(arguments,0);return a.unshift(this.index<this.images.length-1?this.index+1:0),this.show.apply(this,a)},prev:function(){var a=Array.prototype.slice.call(arguments,0);return a.unshift(0===this.index?this.images.length-1:this.index-1),this.show.apply(this,a)},pause:function(){return this.paused=!0,this.videoWrapper&&this.videoWrapper.pause(),this},resume:function(){return this.paused=!1,this.videoWrapper&&this.videoWrapper.play(),this.cycle(),this},cycle:function(){if(this.images.length>1){clearTimeout(this._cycleTimeout);var b=this._currentImage&&this._currentImage.duration||this.options.duration,c=h(this._currentImage),d=function(){this.$item.off(\".cycle\"),this.paused||this.next()};if(c){if(!this._currentImage.loop){var e=0;this.$item.on(\"playing.cycle\",function(){var b=a(this).data(\"player\");clearTimeout(e),e=setTimeout(function(){b.pause(),b.$video.trigger(\"ended\")},1e3*(b.getDuration()-b.getCurrentTime()))}).on(\"ended.cycle\",function(){clearTimeout(e)})}this.$item.on(\"error.cycle initerror.cycle\",a.proxy(d,this))}c&&!this._currentImage.duration?this.$item.on(\"ended.cycle\",a.proxy(d,this)):this._cycleTimeout=setTimeout(a.proxy(d,this),b)}return this},destroy:function(c){a(b).off(\"resize.backstretch orientationchange.backstretch\"),this.videoWrapper&&this.videoWrapper.destroy(),clearTimeout(this._cycleTimeout),c||this.$wrap.remove(),this.$container.removeData(\"backstretch\")}};var p=function(){this.init.apply(this,arguments)};p.prototype.init=function(d){var f,g=this,h=function(){g.$video=f,g.video=f[0]},i=\"video\";if(d.url instanceof Array||!e.test(d.url)||(i=\"youtube\"),g.type=i,\"youtube\"===i){p.loadYoutubeAPI(),g.ytId=d.url.match(e)[2];var j=\"https://www.youtube.com/embed/\"+g.ytId+\"?rel=0&autoplay=0&showinfo=0&controls=0&modestbranding=1&cc_load_policy=0&disablekb=1&iv_load_policy=3&loop=0&enablejsapi=1&origin=\"+encodeURIComponent(b.location.origin);g.__ytStartMuted=!!d.mute||d.mute===c,f=a(\"<iframe />\").attr({src_to_load:j}).css({border:0,margin:0,padding:0}).data(\"player\",g),d.loop&&f.on(\"ended.loop\",function(){g.__manuallyStopped||g.play()}),g.ytReady=!1,h(),b.YT&&b.YT.loaded?(g._initYoutube(),f.trigger(\"initsuccess\")):a(b).one(\"youtube_api_load\",function(){g._initYoutube(),f.trigger(\"initsuccess\")})}else{f=a(\"<video>\").prop(\"autoplay\",!1).prop(\"controls\",!1).prop(\"loop\",!!d.loop).prop(\"muted\",!!d.mute||d.mute===c).prop(\"preload\",\"auto\").prop(\"poster\",d.poster||\"\");for(var k=d.url instanceof Array?d.url:[d.url],l=0;l<k.length;l++){var m=k[l];\"string\"==typeof m&&(m={src:m}),a(\"<source>\").attr(\"src\",m.src).attr(\"type\",m.type||null).appendTo(f)}f[0].canPlayType&&k.length?f.trigger(\"initsuccess\"):f.trigger(\"initerror\"),h()}},p.prototype._initYoutube=function(){var c=this,d=b.YT;c.$video.attr(\"src\",c.$video.attr(\"src_to_load\")).removeAttr(\"src_to_load\");var e=!!c.$video[0].parentNode;if(!e){var f=a(\"<div>\").css(\"display\",\"none !important\").appendTo(document.body);c.$video.appendTo(f)}var g=new d.Player(c.video,{events:{onReady:function(){c.__ytStartMuted&&g.mute(),e||(c.$video[0].parentNode===f[0]&&c.$video.detach(),f.remove()),c.ytReady=!0,c._updateYoutubeSize(),c.$video.trigger(\"canplay\")},onStateChange:function(a){switch(a.data){case d.PlayerState.PLAYING:c.$video.trigger(\"playing\");break;case d.PlayerState.ENDED:c.$video.trigger(\"ended\");break;case d.PlayerState.PAUSED:c.$video.trigger(\"pause\");break;case d.PlayerState.BUFFERING:c.$video.trigger(\"waiting\");break;case d.PlayerState.CUED:c.$video.trigger(\"canplay\")}},onPlaybackQualityChange:function(){c._updateYoutubeSize(),c.$video.trigger(\"resize\")},onError:function(a){c.hasError=!0,c.$video.trigger({type:\"error\",error:a})}}});return c.ytPlayer=g,c},p.prototype._updateYoutubeSize=function(){var a=this;switch(a.ytPlayer.getPlaybackQuality()||\"medium\"){case\"small\":a.video.videoWidth=426,a.video.videoHeight=240;break;case\"medium\":a.video.videoWidth=640,a.video.videoHeight=360;break;default:case\"large\":a.video.videoWidth=854,a.video.videoHeight=480;break;case\"hd720\":a.video.videoWidth=1280,a.video.videoHeight=720;break;case\"hd1080\":a.video.videoWidth=1920,a.video.videoHeight=1080;break;case\"highres\":a.video.videoWidth=2560,a.video.videoHeight=1440}return a},p.prototype.play=function(){var a=this;return a.__manuallyStopped=!1,\"youtube\"===a.type?a.ytReady&&(a.$video.trigger(\"play\"),a.ytPlayer.playVideo()):a.video.play(),a},p.prototype.pause=function(){var a=this;return a.__manuallyStopped=!1,\"youtube\"===a.type?a.ytReady&&a.ytPlayer.pauseVideo():a.video.pause(),a},p.prototype.stop=function(){var a=this;return a.__manuallyStopped=!0,\"youtube\"===a.type?a.ytReady&&(a.ytPlayer.pauseVideo(),a.ytPlayer.seekTo(0)):(a.video.pause(),a.video.currentTime=0),a},p.prototype.destroy=function(){var a=this;return a.ytPlayer&&a.ytPlayer.destroy(),a.$video.remove(),a},p.prototype.getCurrentTime=function(a){var b=this;return\"youtube\"!==b.type?b.video.currentTime:b.ytReady?b.ytPlayer.getCurrentTime():0},p.prototype.setCurrentTime=function(a){var b=this;return\"youtube\"===b.type?b.ytReady&&b.ytPlayer.seekTo(a,!0):b.video.currentTime=a,b},p.prototype.getDuration=function(){var a=this;return\"youtube\"!==a.type?a.video.duration:a.ytReady?a.ytPlayer.getDuration():0},p.loadYoutubeAPI=function(){b.YT&&b.__yt_load_event_interval__||(b.YT||a(\"script[src*=www\\\\.youtube\\\\.com\\\\/iframe_api]\").length||a('<script type=\"text/javascript\" src=\"https://www.youtube.com/iframe_api\">').appendTo(\"body\"),b.__yt_load_event_interval__=setInterval(function(){b.YT&&b.YT.loaded&&(a(b).trigger(\"youtube_api_load\"),clearTimeout(b.__yt_load_event_interval__),delete b.__yt_load_event_interval__)},50))};var q=function(){if(\"matchMedia\"in b){if(b.matchMedia(\"(orientation: portrait)\").matches)return\"portrait\";if(b.matchMedia(\"(orientation: landscape)\").matches)return\"landscape\"}return screen.height>screen.width?\"portrait\":\"landscape\"},r=function(){return b.innerHeight>b.innerWidth?\"portrait\":b.innerWidth>b.innerHeight?\"landscape\":\"square\"},s=function(){var a=navigator.userAgent,c=navigator.platform,d=a.match(/AppleWebKit\\/([0-9]+)/),e=!!d&&d[1],f=a.match(/Fennec\\/([0-9]+)/),g=!!f&&f[1],h=a.match(/Opera Mobi\\/([0-9]+)/),i=!!h&&h[1],j=a.match(/MSIE ([0-9]+)/),k=!!j&&j[1];return!((c.indexOf(\"iPhone\")>-1||c.indexOf(\"iPad\")>-1||c.indexOf(\"iPod\")>-1)&&e&&e<534||b.operamini&&\"[object OperaMini]\"==={}.toString.call(b.operamini)||h&&i<7458||a.indexOf(\"Android\")>-1&&e&&e<533||g&&g<6||\"palmGetResource\"in b&&e&&e<534||a.indexOf(\"MeeGo\")>-1&&a.indexOf(\"NokiaBrowser/8.5.0\")>-1||k&&k<=6)}()}(jQuery,window);"
        },
        {
          "name": "libs",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.0244140625,
          "content": "{\n  \"name\": \"jquery-backstretch\",\n  \"title\": \"Backstretch\",\n  \"description\": \"A simple jQuery plugin that allows you to add a dynamically-resized, slideshow-capable background image to any page or element.\",\n  \"version\": \"2.1.18\",\n  \"main\": \"jquery.backstretch.js\",\n  \"author\": {\n    \"name\": \"Scott Robbin\",\n    \"email\": \"scott@robbin.co\",\n    \"url\": \"http://srobbin.com\"\n  },\n  \"contributors\": [\n    {\n      \"name\": \"Daniel Cohen Gindi\",\n      \"email\": \"danielgindi@gmail.com\"\n    }\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/jquery-backstretch/jquery-backstretch.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/jquery-backstretch/jquery-backstretch/issues\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"MIT\"\n    }\n  ],\n  \"dependencies\": {\n    \"jquery\": \"^3.1.1\"\n  },\n  \"devDependencies\": {\n    \"grunt\": \"1.0.*\",\n    \"grunt-contrib-qunit\": \"1.2.*\",\n    \"grunt-contrib-jshint\": \"1.0.*\",\n    \"grunt-contrib-concat\": \"1.0.*\",\n    \"grunt-contrib-uglify\": \"2.0.*\",\n    \"grunt-contrib-watch\": \"1.0.*\"\n  },\n  \"keywords\": []\n}\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}