{
  "metadata": {
    "timestamp": 1736561962252,
    "page": 674,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "antimatter15/ocrad.js",
      "stars": 3496,
      "defaultBranch": "master",
      "files": [
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.7568359375,
          "content": "August 8, 2016\n\n\t* Major update to Ocrad.js, based on Ocrad 0.25\n\nJanuary 13, 2015\n\n\t* Major update to Ocrad.js, based on Ocrad 0.24\n\t* New Asynchronous API automatically handles creation of web workers\n\t* New recognition options\n\t\t* scale — upscale or downscale the input image by an integer factor\n\t\t* filters — restrict recognition to letters, or numbers\n\t\t* transform — apply rotation or mirroring to image\n\t* Directly recognize text from image or video elements\n\t* Simple API for recognizing determining the location of text blocks, lines or individual characters\n\t* Lazy initialization — it doesn't initialize emscripten until run for the first time\n\nMay 6, 2014\n\n\t* NodeJS module\n\nJanuary 1, 2014\n\n\t* First Version of Ocrad.js, based on 0.23-prelease of Ocrad\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.2451171875,
          "content": "\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\t\t       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n \n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n  \n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n\t\t     END OF TERMS AND CONDITIONS\n\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.4619140625,
          "content": "ocrad.js\n========\n\nOCR in Javascript via Emscripten by [Kevin Kwok](http://antimatter15.com)\n\n\n\nAs with any minor stepping stone on the <strikeout>road to hell</strikeout> relentless trajectory of <link>Atwood's Law, I probably don't need to justify the existence of yet another \"x, but now in Javascript!\", but I might as well try. After all, we all would like to think that there's some ulterior motive to fulfilling that prophecy. \n\nOn tablet or other touchscreen devices- of which there are quite a number of nowadays (as the New Year's Eve post, I am obliged to include conjecture about the technological zeitgeist), a library such as Ocrad.js might be used to add handwriting input in a device and operating system agnostic manner. Oftentimes, capturing the strokes and sending them over to a server to process might entail unacceptably high latency. Maybe you're working on an offline-capable note-taking app, or a browser extension which indexes all the doge memes that you stumble upon while prawling the dark corners of the internet.\n\nIf you've been following my trail of blog posts recently, you'd probably be able to tell that I've been scrambling to finish the program that I prototyped many months ago overnight at a Hackathon. The idea of the extension was kind of simple and also kind of magical: a browser extension that allowed users to highlight, copy, and paste text from any image as if it were plain text. Of course the implementation is a bit difficult and actually relies on the advent of a number of newfangled technologies.\n\nIf you try to search for some open source text recognition engine, the first thing that comes up is Tesseract. That isn't a mistake, because it turns out that the competition is worlds away in terms of accuracy. It's actually pretty sad that the state of the art hasn't progressed substantially since the mid-nineties.\n\nA month ago, I tried compiling Tesseract using Emscripten. Perhaps it was a bad thing to try first, but soon I learned that even if it did work out, it probably wouldn't have been practical anyway. I had figured that all OCR engines had been powered by artificial neural networks, support vector machines, k-nearest-neighbors and their machine learning kin. It turns out that this is hardly the norm except in the realm of the actually-accurate, whose open source provinces live under the protection of Lord Tesseract. \n\nGOCR and Ocrad are essentially the only other open source OCR engines (there's technically also Cuneiform, but the source code is in a really really big zip file from some website in Russian and its also really slow according to benchmarks). And something I didn't realize until I had peered into the source code is that they are powered by (presumably) painstakingly written rules for each and every detectable glyph and variation. This kind of blew my mind.\n\nAnyway, I tried to compile GOCR first and was immediately struck by how easy and painless it had been. I was on a roll, and decided to do Ocrad as well. It wasn't particularly hard- sure it was slightly more involved but still hardly anything. \n\nIf you know me in person, you'll probably know that I'm not a terribly decisive person. Oftentimes, I'll delay the decision until there isn't a choice left for me to make. Anyway, serially-indecisive-me strikes again, so I alternated between the development of GOCR.js and Ocrad.js, leading up to a simultaneous release.\n\nBut in the back of my mind, I knew that eventually I would have to pick one for building my image highlighting project. \n\nWhat consistently amazes me about Optical Character Recognition isn't its astonishing quality or lack thereof. Rather, it's how utterly unpredictable the results can be. Sometimes there'll be some barely legible block of text that comes through absolutely pristine, and some other time there will be a perfectly clean input which outputs complete garbage. Maybe this is a testament to the sheer difficulty of computer vision or the incredible and underappreciated abilities of the human visual cortex.\n\nAt one point, I was talking to someone and I distinctly remembered (I know, all the best stories start this way) a sense of surprise when the person indicated that he had heard of Tesseract, the open source OCR engine. I had appraised it as somewhat more obscure than it evidently was. Some time later, I confided about the incident with a friend, and he said something along the lines of \"OCR is one of those fields that everyone comes across once\".\n\nI guess I've kind of held onto that thought for a while now, and it certainly seems to have at least a grain of truth. Text embedded into the physical world is more or less our primary means we have for communication and expression. Technology is about building tools that augment human capacity and inevitably entails supplanting some human capability. Data input is a huge bottleneck, and while we're kind of sidestepping the problem with things like QR codes by bringing the digital world into the physical. OCR is just one of those fundamental enabling technologies which ought to be as broad in scope as the set of humans who have interacted with a keyboard.\n\nI can't help but feel that the rather large set of people who have interacted with the problem character recognition have surveyed the available tools and reached the same conclusion as your miniature Magic 8 Ball desk ornament: \"Try again later\". It doesn't take long for one to discover an instance of perfectly crisp and legible type which results in line noise of such entropy that it'd give DUAL_EC_DRBG a run for its money. \"No, there really isn't any way for this to be the state of the art.\" \"Well, I guess if it is, then maybe it'll improve in a few years- technology improves quickly, right?\" \n\nYou would think that some analogue of Linus's Law would hold true: \"given enough eyeballs, all bugs are shallow\"- especially if you're dealing with literal eyeballs reading letters. But incidentally, the engine that absolutely everyone uses was developed three decades ago (It's older than I am!), abandoned for a decade before being acquired and released to the world (by our favorite benevolent overlords, Google). \n\nIn fact, what's absolutely stunning is the sheer universality of Tesseract. Just about everything which claims to have text recognition as a feature is backed by it. At one point, I was hoping that Mathematica had some clever routine using morphology and symbolic new kinds of sciences and evolved automata pattern recognition. Nope! Nestled deep within the gigabytes of code lies the Chuck Testa of textadermies: Tesseract.\n\n\n\n\n\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 1.3955078125,
          "content": "# Define your emscripten path. Change it you don't use emscripten portable\nPATH=\"$HOME/emsdk_portable:$HOME/emsdk_portable/clang/fastcomp/build_master_64/bin:$HOME/emsdk_portable/node/4.1.1_64bit/bin:$HOME/emsdk_portable/emscripten/master:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games\"\nEMSCRIPTEN=\"$HOME/emsdk_portable/emscripten/master\"\n\n# autogenerate some parts of the postcode\npython src/generate.py\n\n# compile ocrad\ncd ocrad-*\nemconfigure ./configure\nemmake make\nemcc -02 --memory-init-file 0 -v -s TOTAL_MEMORY=33554432 -s EXPORTED_FUNCTIONS=\"['_OCRAD_set_exportfile', '_OCRAD_transform', '_OCRAD_add_filter', '_OCRAD_version', '_OCRAD_open', '_OCRAD_close', '_OCRAD_get_errno', '_OCRAD_set_image', '_OCRAD_set_image_from_file', '_OCRAD_set_utf8_format', '_OCRAD_set_threshold', '_OCRAD_scale', '_OCRAD_recognize', '_OCRAD_result_blocks', '_OCRAD_result_lines', '_OCRAD_result_chars_total', '_OCRAD_result_chars_block', '_OCRAD_result_chars_line', '_OCRAD_result_line', '_OCRAD_result_first_character']\" ocradlib.o page_image_io.o page_image.o rectangle.o textpage.o bitmap.o blob.o textblock.o character_r11.o ucs.o character.o textline.o track.o rational.o profile.o mask.o feats.o common.o feats_test0.o feats_test1.o segment.o character_r12.o character_r13.o textline_r2.o textblock.o textpage.o arg_parser.o user_filter.o iso_8859.o -o ../ocrad.js --pre-js ../src/pre.js --post-js ../src/post.js\nmake clean\n"
        },
        {
          "name": "demo.html",
          "type": "blob",
          "size": 18.615234375,
          "content": "<!doctype html>\n<html>\n\t<head>\n\t\t<title>Ocrad.js - Optical Character Recognition in Javascript</title>\n\t\t<meta charset=\"utf8\">\n\t\t<style>\n\t\t\tbody {\n\t\t\t\tfont-family: sans-serif;\n\t\t\t\t\n\t\t\t\tbackground: #DCE9E9;\n\t\t\t\t-moz-transition: background-color 0.5s;\n\t\t\t\t-webkit-transition: background-color 0.5s;\n\t\t\t\t-o-transition: background-color 0.5s;\n\t\t\t\ttransition: background-color 0.5s;\n\t\t\t}\n\t\t\tbody.dragging {\n\t\t\t\tbackground-color: #F0E6DC;\n\t\t\t}\n\t\t\t#main {\n\t\t\t\tmargin-right: auto;\n\t\t\t\tmargin-left: auto;\n\t\t\t\tpadding: 10px;\n\t\t\t\twidth: 600px;\n\t\t\t}\n\t\t\th1 {\n\t\t\t\tfont-size: 400%;\n\t\t\t\tmargin-top: 30px;\n\n\t\t\t}\n\t\t\tdiv.content {\n\t\t\t\tpadding: 50px;\n\t\t\t}\n\t\t\tcanvas.content {\n\t\t\t\t\n\t\t\t}\n\t\t\t.output {\n\t\t\t\tbackground: rgb(255, 245, 211);\n\t\t\t}\n\t\t\t#output {\n\t\t\t\tpadding: 20px;\n\t\t\t\tpadding-bottom: 0;\n\t\t\t\ttext-align: center; \n\t\t\t\tmin-height: 80px;\n\t\t\t\t-moz-transition: background-color 0.5s;\n\t\t\t\t-webkit-transition: background-color 0.5s;\n\t\t\t\t-o-transition: background-color 0.5s;\n\t\t\t\ttransition: background-color 0.5s;\n\t\t\t}\n\t\t\t.content {\n\t\t\t\tbackground: white;\n\t\t\t\tmargin-bottom: 50px;\n\t\t\t\tline-height: 1.5em;\n\t\t\t}\n\t\t\t.content.inverse {\n\t\t\t\tbackground: rgb(56, 56, 56);\n\t\t\t\tcolor: white;\n\t\t\t}\n\n\t\t\t.processing {\n\t\t\t\tbackground-color: rgb(211, 232, 255);\n\t\t\t}\n\t\t\ta {\n\t\t\t\ttext-decoration: none;\n\t\t\t\tfont-weight: bold;\n\t\t\t}\n\t\t\th3 {\n\t\t\t\ttext-align: center;\n\t\t\t\tfont-style: italic;\n\t\t\t}\n\t\t\t.footer {\n\t\t\t\tfont-size: x-small;\n\t\t\t\ttext-align: center;\n\t\t\t\tmargin-bottom: 50px;\n\t\t\t}\n\t\t\t#squish.squish { font-size: xx-small; }\n\t\t\t#squish.squishsquish { font-size: 7px; }\n\t\t\t#squish.squishsquishsquish { font-size: 5px; }\n\t\t\t#squish.squishsquishsquishsquish { font-size: 2px; }\n\t\t\t#squish.squishsquishsquishsquishsquish { display: none; }\n\n\t\t\t.buttons {\n\t\t\t\tposition: absolute;\n\t\t\t\tmargin-left: -60px;\n\t\t\t\tmargin-top: -250px;\n\t\t\t}\n\t\t\t#demo {\n\t\t\t\tbox-shadow: 0px 0px 35px rgba(0,0,0,0.2);\n\t\t\t\tmargin-bottom: 50px;\n\t\t\t\tbackground: white;\n\t\t\t}\n\t\t\t#timing {\n\t\t\t\tfont-size: x-small;\n\t\t\t}\n\t\t\thr {\n\t\t\t\tborder: none;\n\t\t\t}\n\t\t\t.buttons #clear { color: red; font-size: 400%; font-weight: bold; cursor: pointer;}\n\t\t\t.buttons #word { color: blue; font-size: 300%; font-weight: bold; cursor: pointer; margin-left: -2px;}\n\t\t\t.nose {\n\t\t\t\t-moz-transition: background-color 0.5s;\n\t\t\t\t-webkit-transition: background-color 0.5s;\n\t\t\t\t-o-transition: background-color 0.5s;\n\t\t\t\ttransition: background-color 0.5s;\n\t\t\t}\n\t\t\t.nose:hover {\n\t\t\t\tbackground-color: rgb(255, 222, 211);\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<a href=\"https://github.com/antimatter15/ocrad.js\"><img style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png\" alt=\"Fork me on GitHub\"></a>\n\t\t<div id=\"main\">\n\t\t\t<input type=\"file\" style=\"position:absolute; top: -100px\" id=\"picker\" onchange=\"picked_file(this.files[0])\">\n\n\t\t\t<h1>Ocrad.js&nbsp;<div style=\"font-size: small; font-weight: normal; display: inline\">Optical Character Recognition in JS</div></h1>\n\t\t\t<div class=\"content\">\n\t\t\t\t<strong>Ocrad.js</strong> is a <strong>pure-javascript</strong> version of Antonio Diaz Diaz's <a href=\"http://www.gnu.org/software/ocrad/\">Ocrad</a> project, automatically converted using <a href=\"https://github.com/kripken/emscripten\">Emscripten</a>. It is a simple <a href=\"http://en.wikipedia.org/wiki/Optical_character_recognition\">OCR (Optical Character Recognition)</a> program that can convert scanned images of text back into text. Clocking in at <strong>about a megabyte</strong> of Javascript with no hefty training data dependencies (looking at you, <a href=\"https://code.google.com/p/tesseract-ocr/\">Tesseract</a>), it's on the lighter end of the spectrum.\n\t\t\t\t<p style=\"margin-bottom: 0; font-size: small\">\n\t\t\t\tThis was made by <a href=\"http://antimatter15.com\">Kevin Kwok</a> (please follow me <a href=\"http://twitter.com/antimatter15\">@antimatter15</a> or <a href=\"http://google.com/+KevinKwok\">G+</a>)\n\t\t\t</div>\n\t\t\t\n\t\t\t<div class=\"content inverse\">\n\t\t\t\tBelow is a <strong>simple demo</strong>, which should hopefully demonstrate the <strong>capabilities</strong> but will more likely show the substantial <strong>limitations</strong> of the library. \n\t\t\t\t<hr>\n\n\t\t\t\tHit the buttons on the left to <strong>reset the canvas</strong> or to randomly <strong>put some text</strong> in a random font. You can also try to <strong>draw something</strong> with your cursor.\n\t\t\t</div>\n\t\t\t<div id=\"demo\">\n\t\t\t\t<div class=\"output\">\n\n\t\t\t\t\t<div id=\"output\">\n\t\t\t\t\t\t<div id=\"text\"></div>\n\t\t\t\t\t\t<span id=\"timing\"></span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<canvas id='c' class=\"\" width=\"600\" height=\"300\"></canvas>\n\t\t\t\t<div class=\"buttons\">\n\t\t\t\t\t<div id=\"clear\" onclick=\"reset_canvas()\">&times;</div>\n\t\t\t\t\t<div id=\"word\" onclick=\"da_word()\">&#8635;</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"output nose\" style=\"padding: 25px; cursor: pointer\" onclick=\"open_picker()\">\n\t\t\t\t\tYou can also <strong>drag and drop</strong> an image from your computer <small>(JPEG, PNG, GIF, BMP, SVG, or NetPBM)</small> to feed into the text recognizer or <strong>choose a file</strong> by clicking anywhere on this box. \n\t\t\t\t\t\n\t\t\t\t</div>\n\n\t\t\t</div>\n\n\t\t\t<div class=\"content\">\n\t\t\t\tThe <strong>Ocrad.js API</strong> is really simple. First you need to include <tt>ocrad.js</tt> which is about 1MB in size.\n\t\t\t\t<div style=\"padding: 20px; font-family: monospace\">\n\t\t\t\t\t&lt;script src=\"ocrad.js\"&gt;&lt;/script&gt;\n\t\t\t\t</div>\n\t\t\t\tThis file exposes a single global function, <tt>OCRAD</tt> which takes an image as an argument and returns the recognized text as a string. \n\t\t\t\t<div style=\"padding: 20px; font-family: monospace\">\n\t\t\t\t\tvar string = OCRAD(image);<br>\n\t\t\t\t\talert(string);\n\t\t\t\t</div>\n\t\t\t\tThe <tt>image</tt> argument can be a canvas element, a Context2D instance, or an instance of ImageData.\n\t\t\t</div>\n\n\t\t\t<div class=\"content\">\n\t\t\t\tOcrad.js also <strong>exposes all</strong> of the <a href=\"http://www.gnu.org/software/ocrad/manual/ocrad_manual.html#Library-functions\">C library functions</a> in addition to the extremely simple high level API covered in the last section. By calling <tt>OCRAD.version()</tt> you can find the current version string: <tt>0.23-pre1</tt>, the latest pre-release version of the software available. \n\n\t\t\t\t<div style=\"padding: 20px; font-family: monospace\">\n\t\t\t\t\t<i>string</i> OCRAD.version()<br>\n\t\t\t\t\t<i>void</i> OCRAD.write_file(<i>string</i> filename, <i>Uint8Array</i> PBM Image Data)<br>\n\t\t\t\t\t<i>pointer</i> OCRAD.open()<br>\n\t\t\t\t\t<i>int</i> OCRAD.close(<i>pointer</i> descriptor)<br>\n\t\t\t\t\t(and more!)\n\t\t\t\t\t<!-- OCRAD.get_errno<br>\n\t\t\t\t\tOCRAD.set_image<br>\n\t\t\t\t\tOCRAD.set_image_from_file<br>\n\t\t\t\t\tOCRAD.set_utf8_format<br>\n\t\t\t\t\tOCRAD.set_threshold<br>\n\t\t\t\t\tOCRAD.scale<br>\n\t\t\t\t\tOCRAD.recognize<br>\n\t\t\t\t\tOCRAD.result_blocks<br>\n\t\t\t\t\tOCRAD.result_lines<br>\n\t\t\t\t\tOCRAD.result_chars_total<br>\n\t\t\t\t\tOCRAD.result_chars_block<br>\n\t\t\t\t\tOCRAD.result_chars_line<br>\n\t\t\t\t\tOCRAD.result_line<br>\n\t\t\t\t\tOCRAD.result_first_character<br> -->\n\t\t\t\t</div>\n\n\t\t\t\t\n\n\t\t\t</div>\n\n\t\t\t<div class=\"content\">\n\t\t\t\t<strong>What about <a href=\"http://antimatter15.github.io/gocr.js/demo.html\">GOCR.js</a>?</strong>\n\n\t\t\t\tIf you stumbled upon that page first, you might have realized that this entire page is a heinous act of plagiarism probably worthy of <a href=\"http://mit.edu\">academic</a> suspension&mdash; if not for the fact that I made that other page as well. It turns out that porting things with Emscripten is just so gosh-darned easy and addictive (don't tell the <a href=\"http://dea.gov\">DEA</a> I don't have an <a href=\"http://en.wikipedia.org/wiki/Prescription_drug\">permscription</a>). The neat thing about GOCR is that it compiles under Emscripten without any modifications, whereas Ocrad has some dependency issues. \n\t\t\t\t<p>\n\t\t\t\tUnlike GOCR.js, Ocrad.js is designed as a port of the library, rather than a wrapper around the executable. This means that processing subsequent images doesn't involve reinitializing an executable, so processing an image can be done in as little as <strong>an eighth of the time</strong> it takes GOCR.js to do the same (The fact that Ocrad is naturally faster than GOCR doesn't hurt this statistic either). \n\t\t\t\t<p>\n\t\t\t\tWith a simple script which generates some text in some random font selected from the Google Font API, I ran a few hundred trials comparing the recognized text with the original text. The metric was a modified Levenshtein distance where the substitution cost for capitalization errors is <tt>0.1</tt>. Of <tt>485</tt> trials, <tt>175</tt> trials ended up favoring GOCR.js, <tt>184</tt> favoring Ocrad.js, and <tt>126</tt> resulted in a tie. From playing with the draw tool, it seems that <strong>Ocrad is much more predictable and forgiving</strong> for minor alignment and orientation errors.\n\t\t\t\t<p>\n\t\t\t\tThere have been some other comparisons on the performance of OCRAD versus GOCR. In this <a href=\"http://www.mathstat.dal.ca/~selinger/ocr-test/\">comparison done by Peter Selinger</a>, Ocrad comes out just behind Tesseract. Another <a href=\"http://www.splitbrain.org/blog/2010-06/15-linux_ocr_software_comparison\">comparison by Andreas Gohr</a> has GOCR performing better than Ocrad. \n\t\t\t\t<p>\n\t\t\t\tAccuracy wise, they're actually pretty close. It might be possible to create something which meshes together the outputs of both, picking whichever output matches a certain heuristic for quality. Ocrad does seem to vastly outperform GOCR when it comes to letter sketches on a canvas, so that's the one I'm focusing on here.\n\t\t\t</div>\n\n\n\t\t\t<div class=\"content\">\n\t\t\t\tAside from the relentless march of <a href=\"http://www.codinghorror.com/blog/2007/07/the-principle-of-least-power.html\">Atwood's law</a>, there are legitimate applications which might benefit from <strong>client side OCR</strong> (I'd like to think that I'm currently working on one, and no, it's not solving the <a href=\"http://en.wikipedia.org/wiki/CAPTCHA\">wavy squiggly letters</a> blockading your attempts at building a spam empire). Arguably, it'd be best to go for porting the best possible open source OCR engine in existence (looking at you, <a href=\"https://code.google.com/p/tesseract-ocr/\">Tesseract</a>). Unlike OCRAD and GOCR, which interestingly seem to be <strong>powered by painstakingly written rules for each recognizable glyph</strong>, Tesseract uses neural networks and the ilk to learn features common to different letters (which means it's extensible and multilingual). When you include the training data, <strong>Tesseract is actually kind of massive</strong> &mdash; A functional Emscripten port would probably be at least 30 times the size of OCRAD.js! \n\t\t\t</div>\n\n\t\t\t<div class='footer'><div id='squish'>Hi. This was made by <a href=\"http://antimatter15.com\">me</a>. I am a tiny footer, please don't <a href=\"javascript:void(document.getElementById('squish').className+='squish')\">squish</a> me.</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<script src=\"ocrad.js\"></script>\n\t\t<script src=\"http://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js\"></script> \n\n\t\t<script>\n\t\t\tvar c = document.getElementById('c'),\n\t\t\t\to = c.getContext('2d');\n\n\t\t\tfunction reset_canvas(){\n\t\t\t\to.fillStyle = 'white'\n\t\t\t\to.fillRect(0, 0, c.width, c.height)\n\t\t\t\to.fillStyle = 'black'\t\n\t\t\t}\n\n\t\t\t// here's a really simple little drawing app so people can try their luck at\n\t\t\t// the lottery that is offline handwriting recognition\n\t\t\tvar drag = false, lastX, lastY;\n\t\t\tc.onmousedown = function(e){ drag = true; lastX = 0; lastY = 0; e.preventDefault(); c.onmousemove(e) }\n\t\t\tc.onmouseup   = function(e){ drag = false; e.preventDefault(); runOCR() }\n\t\t\tc.onmousemove = function(e){\n\t\t\t\te.preventDefault()\n\t\t\t\tvar rect = c.getBoundingClientRect();\n\t\t\t\tvar r = 5;\n\n\t\t\t\tfunction dot(x, y){\n\t\t\t\t\to.beginPath()\n\t\t\t\t\to.moveTo(x + r, y)\n\t\t\t\t\to.arc(x, y, r, 0, Math.PI * 2)\n\t\t\t\t\to.fill()\n\t\t\t\t}\n\t\t\t\tif(drag){\n\t\t\t\t\tvar x = e.clientX - rect.left, \n\t\t\t\t\t\ty = e.clientY - rect.top;\n\t\t\t\t\t\n\t\t\t\t\tif(lastX && lastY){\n\t\t\t\t\t\tvar dx = x - lastX, dy = y - lastY;\n\t\t\t\t\t\tvar d = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\t\t\tfor(var i = 1; i < d; i += 2){\n\t\t\t\t\t\t\tdot(lastX + dx / d * i, lastY + dy / d * i)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdot(x, y)\n\n\t\t\t\t\tlastX = x;\n\t\t\t\t\tlastY = y;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tdocument.body.ondragover = function(){ document.body.className = 'dragging'; return false }\n\t\t\tdocument.body.ondragend = function(){ document.body.className = ''; return false }\n\t\t\tdocument.body.onclick = function(){document.body.className = '';}\n\t\t\tdocument.body.ondrop = function(e){\n\t\t\t\te.preventDefault();\n\t\t\t\tdocument.body.className = '';\n\t\t\t\tpicked_file(e.dataTransfer.files[0]);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfunction open_picker(){\n\t\t\t\tvar e = document.createEvent(\"MouseEvents\");\t\n\t\t\t\te.initEvent('click', true, true);\n\t\t\t\tdocument.getElementById('picker').dispatchEvent(e);\n\t\t\t}\n\n\t\t\tfunction picked_file(file){\n\t\t\t\tif(!file) return;\n\t\t\t\t// document.getElementById(\"output\").className = 'processing'\n\n\t\t\t\tvar ext = file.name.split('.').slice(-1)[0];\n\t\t\t\tvar reader = new FileReader();\n\n\t\t\t\tif(file.type == \"image/x-portable-bitmap\" || ext == 'pbm' || ext == 'pgm' || ext == 'pnm' || ext == 'ppm'){\n\t\t\t\t\treader.onload = function(){\n\t\t\t\t\t\treset_canvas();\n\t\t\t\t\t\tdocument.getElementById(\"text\").innerHTML = 'Recognizing Text... This may take a while...'\n\t\t\t\t\t\to.font = '30px sans-serif'\n\t\t\t\t\t\to.fillText('No previews for NetPBM format.', 50, 100);\n\t\t\t\t\t\trunOCR(new Uint8Array(reader.result), true);\n\t\t\t\t\t}\n\t\t\t\t\treader.readAsArrayBuffer(file)\n\t\t\t\t}else{\n\t\t\t\t\treader.onload = function(){\n\t\t\t\t\t\tvar img = new Image();\n\t\t\t\t\t\timg.src = reader.result;\n\t\t\t\t\t\timg.onerror = function(){\n\t\t\t\t\t\t\treset_canvas();\n\t\t\t\t\t\t\to.font = '30px sans-serif'\n\t\t\t\t\t\t\to.fillText('Error: Invalid Image ' + file.name, 50, 100);\n\t\t\t\t\t\t}\n\t\t\t\t\t\timg.onload = function(){\n\t\t\t\t\t\t\tdocument.getElementById(\"text\").innerHTML = 'Recognizing Text... This may take a while...'\n\t\t\t\t\t\t\treset_canvas();\n\t\t\t\t\t\t\tvar rat = Math.min(c.width / img.width, c.height / img.height);\n\t\t\t\t\t\t\to.drawImage(img, 0, 0, img.width * rat, img.height * rat)\n\t\t\t\t\t\t\tvar tmp = document.createElement('canvas')\n\t\t\t\t\t\t\ttmp.width = img.width;\n\t\t\t\t\t\t\ttmp.height = img.height;\n\t\t\t\t\t\t\tvar ctx = tmp.getContext('2d')\n\t\t\t\t\t\t\tctx.drawImage(img, 0, 0)\n\t\t\t\t\t\t\tvar image_data = ctx.getImageData(0, 0, tmp.width, tmp.height);\n\t\t\t\t\t\t\trunOCR(image_data, true)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\treader.readAsDataURL(file)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\tvar lastWorker;\n\t\t\tvar worker = new Worker('worker.js')\n\t\t\tfunction runOCR(image_data, raw_feed){\n\t\t\t\tdocument.getElementById(\"output\").className = 'processing'\n\t\t\t\tworker.onmessage = function(e){\n\n\t\t\t\t\tdocument.getElementById(\"output\").className = ''\n\t\t\t\t\t\n\t\t\t\t\tif('innerText' in document.getElementById(\"text\")){\n\t\t\t\t\t\tdocument.getElementById(\"text\").innerText = e.data\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdocument.getElementById(\"text\").textContent = e.data\t\n\t\t\t\t\t}\n\t\t\t\t\tdocument.getElementById('timing').innerHTML = 'recognition took ' + ((Date.now() - start)/1000).toFixed(2) + 's';\n\t\t\t\t}\n\t\t\t\tvar start = Date.now()\n\t\t\t\tif(!raw_feed){\n\t\t\t\t\timage_data = o.getImageData(0, 0, c.width, c.height);\t\n\t\t\t\t}\n\n\t\t\t\tworker.postMessage(image_data)\n\t\t\t\tlastWorker = worker;\n\t\t\t}\n\n\n\n\t\t\treset_canvas()\n\n\n\t\t\tvar quotes = [\n\t\t\t\t'Welcome to Ocrad.JS!',\n\t\t\t\t'Grumpy wizards make toxic brew for the evil Queen and Jack.',\n\t\t\t\t'The Quick Brown Fox Jumped Over The Lazy Dog.',\n\t\t\t\t'Everything is linear when plotted log-log with a fat magic marker.',\n\t\t\t\t'Hello OCR!',\n\t\t\t\t'This demo better put Engelbart to shame!',\n\t\t\t\t'Very OCR. Such Recognize. Wow.',\n\t\t\t\t'Much Text. Wow. So Letters. Very Recognition. Wow.',\n\t\t\t\t\"I don't know what to say.\",\n\t\t\t\t'Here are some words.',\n\t\t\t\t'Words words words words words words words - Hamlet.',\n\t\t\t\t'The Very Quick, Much Brown Fox Jumped So Over Such Lazy Doge. Wow.',\n\t\t\t\t'Is this algorithm better than a fifth grader? (no)',\n\t\t\t\t'I am Cow. Hear me moo! I weigh twice as much as you.',\n\t\t\t\t'Nineteen Eighty Four',\n\t\t\t\t'How many tweets would a twit-chuck tweet if a tweet could tweet.',\n\t\t\t\t'I shall call him squishy and he shall be my squishy.',\n\t\t\t\t'Such Text. Very OCR. Much Optical. Wow.',\n\t\t\t\t\"Here's to looking at pixels, kid.\",\n\t\t\t\t\"Do or do not, there is no try.\",\n\t\t\t\t\"Yo Banana Boy!\",\n\t\t\t\t\"This shit is bananas, B-A-N-A-N-A-S.\",\n\t\t\t\t\"I have discovered a truly marvelous proof which this box is too small to contain.\",\n\t\t\t\t\"Tech-mol-ogy is it good or is it whack?\",\n\t\t\t\t\"Say What Again! I dare you! I double-dare you!\",\n\t\t\t\t\"D-I-N-O-S-A-YOU ARE A DINOSAUR\",\n\t\t\t\t\"Hello my name is dug. I have just met you. I love you.\",\n\t\t\t\t\"ABC DEF GHI JKL MNO PQR STU VWX YZ\",\n\t\t\t\t\"abc def ghi jkl mno pqr stu vwx yz\",\n\t\t\t\t\"0 1 2 3 4 5 6 7 8 9\",\n\t\t\t\t\"One Two Three Four Five Six Seven Eight Nine Ten\",\n\t\t\t\t\"Your mother was a hamster and your father smelt of elderberries.\",\n\t\t\t\t\"Hello World!\",\n\t\t\t\t\"Goodnight, cruel world!\",\n\t\t\t\t\"Do not go gentle into that good night\",\n\t\t\t\t\"To be, or not to be: That is the question. Whether tis nobler in the mind to suffer the slings and arrows of outrageous fortune.\",\n\t\t\t\t\"You're not crazy!\",\n\t\t\t\t\"Time flies like an arrow, Fruit flies like a banana.\",\n\t\t\t\t\"This message is bludgeoning the deceased equine.\",\n\t\t\t\t\"Rawr! I'm a dinosaur!\",\n\t\t\t\t\"Hesitation is always easy but rarely useful.\",\n\t\t\t\t\"Quis custodiet ipsos custodes?\",\n\t\t\t\t\"Tuesday's meeting of the apathy club was canceled due to lack of interest.\",\n\t\t\t\t\"We sell your users so you don't have to!\",\n\t\t\t\t\"Life is good.\",\n\t\t\t\t\"A true magician never unveils his trick.\",\n\t\t\t\t\"Ceci n'est pas une pipe.\"\n\t\t\t];\n\t\t\tvar fonts = ['Droid Sans', 'Philosopher', 'Alegreya Sans', 'Chango', 'Coming Soon', 'Allan', 'Cardo', 'Bubbler One', 'Bowlby One SC', 'Prosto One', 'Rufina', 'Cantora One', 'Denk One', 'Play', 'Architects Daughter', 'Nova Square', 'Inder', 'Gloria Hallelujah', 'Telex', 'Comfortaa', 'Merienda', 'Boogaloo', 'Krona One', 'Orienta', 'Sofadi One', 'Source Sans Pro', 'Revalia', 'Overlock', 'Kelly Slab', 'Rye', 'Butcherman', 'Lato', 'Milonga', 'Aladin', 'Princess Sofia', 'Audiowide', 'Italiana', 'Michroma', 'Cabin Condensed', 'Jura', 'Marko One', 'PT Mono', 'Bubblegum Sans', 'Amaranth']\n\t\t\t\n\n\t\t\tfunction fisher_yates(a) {\n\t\t\t\tfor (var i = a.length - 1; i > 0; i--) {\n\t\t\t\t\tvar j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t\tvar temp = a[i]; a[i] = a[j]; a[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfisher_yates(fonts);\n\t\t\tfisher_yates(quotes);\n\n\t\t\tfunction da_word(){\n\t\t\t\treset_canvas()\n\t\t\t\t\n\t\t\t\tvar font = fonts.shift(); fonts.push(font); // do a rotation\n\n\t\t\t\tif(Math.random() > 0.7){\n\t\t\t\t\tvar phrase = font;\n\t\t\t\t}else{\n\t\t\t\t\tvar phrase = quotes.shift() //quotes[Math.floor(quotes.length * Math.random())];\n\t\t\t\t\tquotes.push(phrase);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tWebFont.load({\n\t\t\t\t\tgoogle: {\n\t\t\t\t\t\tfamilies: [font]\n\t\t\t\t\t},\n\t\t\t\t\tactive: function(){\n\t\t\t\t\t\to.font = '30px \"' + font + '\"'\n\t\t\t\t\t\tvar words = phrase.split(' '), buf = [], n = 70;\n\t\t\t\t\t\tfor(var i = 0; i < words.length; i++){\n\t\t\t\t\t\t\tbuf.push(words[i])\n\t\t\t\t\t\t\tif(buf.join(' ').length > 15 || i == words.length - 1){\n\t\t\t\t\t\t\t\to.fillText(buf.join(' '), 50, n);\n\t\t\t\t\t\t\t\tbuf = []\n\t\t\t\t\t\t\t\tn += 50\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunOCR(phrase);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\to.font = '30px sans-serif'\n\t\t\to.fillText(\"Welcome to the Ocrad.js Demo!\", 50, 100);\n\t\t\trunOCR();\n\t\t</script>\n\t</body>\n</html>\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "ocrad-0.25",
          "type": "tree",
          "content": null
        },
        {
          "name": "ocrad.js",
          "type": "blob",
          "size": 3133.3369140625,
          "content": "var OCRAD = (function(){\nfunction createOcradInstance(){\n\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it, and do the work to get that through\n// closure compiler if necessary. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to do an eval in order to handle the closure compiler\n// case, where this code here is minified but Module was defined\n// elsewhere (e.g. case 4 above). We also need to check if Module\n// already exists (e.g. case 3 above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module;\nif (!Module) Module = (typeof Module !== 'undefined' ? Module : null) || {};\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nfor (var key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\n// The environment setup code below is customized to use Module.\n// *** Environment setup code ***\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\n\n// Three configurations we can be running in:\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\nif (Module['ENVIRONMENT']) {\n  if (Module['ENVIRONMENT'] === 'WEB') {\n    ENVIRONMENT_IS_WEB = true;\n  } else if (Module['ENVIRONMENT'] === 'WORKER') {\n    ENVIRONMENT_IS_WORKER = true;\n  } else if (Module['ENVIRONMENT'] === 'NODE') {\n    ENVIRONMENT_IS_NODE = true;\n  } else if (Module['ENVIRONMENT'] === 'SHELL') {\n    ENVIRONMENT_IS_SHELL = true;\n  } else {\n    throw new Error('The provided Module[\\'ENVIRONMENT\\'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.');\n  }\n} else {\n  ENVIRONMENT_IS_WEB = typeof window === 'object';\n  ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n  ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n}\n\n\nif (ENVIRONMENT_IS_NODE) {\n  // Expose functionality in the same simple way that the shells work\n  // Note that we pollute the global namespace here, otherwise we break in node\n  if (!Module['print']) Module['print'] = console.log;\n  if (!Module['printErr']) Module['printErr'] = console.warn;\n\n  var nodeFS;\n  var nodePath;\n\n  Module['read'] = function read(filename, binary) {\n    if (!nodeFS) nodeFS = require('fs');\n    if (!nodePath) nodePath = require('path');\n\n    filename = nodePath['normalize'](filename);\n    var ret = nodeFS['readFileSync'](filename);\n    // The path is absolute if the normalized version is the same as the resolved.\n    if (!ret && filename != nodePath['resolve'](filename)) {\n      filename = path.join(__dirname, '..', 'src', filename);\n      ret = nodeFS['readFileSync'](filename);\n    }\n    if (ret && !binary) ret = ret.toString();\n    return ret;\n  };\n\n  Module['readBinary'] = function readBinary(filename) {\n    var ret = Module['read'](filename, true);\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n    assert(ret.buffer);\n    return ret;\n  };\n\n  Module['load'] = function load(f) {\n    globalEval(read(f));\n  };\n\n  if (!Module['thisProgram']) {\n    if (process['argv'].length > 1) {\n      Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n    } else {\n      Module['thisProgram'] = 'unknown-program';\n    }\n  }\n\n  Module['arguments'] = process['argv'].slice(2);\n\n  if (typeof module !== 'undefined') {\n    module['exports'] = Module;\n  }\n\n  process['on']('uncaughtException', function(ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\n}\nelse if (ENVIRONMENT_IS_SHELL) {\n  if (!Module['print']) Module['print'] = print;\n  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm\n\n  if (typeof read != 'undefined') {\n    Module['read'] = read;\n  } else {\n    Module['read'] = function read() { throw 'no read() available (jsc?)' };\n  }\n\n  Module['readBinary'] = function readBinary(f) {\n    if (typeof readbuffer === 'function') {\n      return new Uint8Array(readbuffer(f));\n    }\n    var data = read(f, 'binary');\n    assert(typeof data === 'object');\n    return data;\n  };\n\n  if (typeof scriptArgs != 'undefined') {\n    Module['arguments'] = scriptArgs;\n  } else if (typeof arguments != 'undefined') {\n    Module['arguments'] = arguments;\n  }\n\n}\nelse if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  Module['read'] = function read(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, false);\n    xhr.send(null);\n    return xhr.responseText;\n  };\n\n  Module['readAsync'] = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n      } else {\n        onerror();\n      }\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n  if (typeof arguments != 'undefined') {\n    Module['arguments'] = arguments;\n  }\n\n  if (typeof console !== 'undefined') {\n    if (!Module['print']) Module['print'] = function print(x) {\n      console.log(x);\n    };\n    if (!Module['printErr']) Module['printErr'] = function printErr(x) {\n      console.warn(x);\n    };\n  } else {\n    // Probably a worker, and without console.log. We can do very little here...\n    var TRY_USE_DUMP = false;\n    if (!Module['print']) Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== \"undefined\") ? (function(x) {\n      dump(x);\n    }) : (function(x) {\n      // self.postMessage(x); // enable this if you want stdout to be sent as messages\n    }));\n  }\n\n  if (ENVIRONMENT_IS_WORKER) {\n    Module['load'] = importScripts;\n  }\n\n  if (typeof Module['setWindowTitle'] === 'undefined') {\n    Module['setWindowTitle'] = function(title) { document.title = title };\n  }\n}\nelse {\n  // Unreachable because SHELL is dependant on the others\n  throw 'Unknown runtime environment. Where are we?';\n}\n\nfunction globalEval(x) {\n  eval.call(null, x);\n}\nif (!Module['load'] && Module['read']) {\n  Module['load'] = function load(f) {\n    globalEval(Module['read'](f));\n  };\n}\nif (!Module['print']) {\n  Module['print'] = function(){};\n}\nif (!Module['printErr']) {\n  Module['printErr'] = Module['print'];\n}\nif (!Module['arguments']) {\n  Module['arguments'] = [];\n}\nif (!Module['thisProgram']) {\n  Module['thisProgram'] = './this.program';\n}\n\n// *** Environment setup code ***\n\n// Closure helpers\nModule.print = Module['print'];\nModule.printErr = Module['printErr'];\n\n// Callbacks\nModule['preRun'] = [];\nModule['postRun'] = [];\n\n// Merge back in the overrides\nfor (var key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = undefined;\n\n\n\n// {{PREAMBLE_ADDITIONS}}\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in: \n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at: \n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n//========================================\n// Runtime code shared with compiler\n//========================================\n\nvar Runtime = {\n  setTempRet0: function (value) {\n    tempRet0 = value;\n  },\n  getTempRet0: function () {\n    return tempRet0;\n  },\n  stackSave: function () {\n    return STACKTOP;\n  },\n  stackRestore: function (stackTop) {\n    STACKTOP = stackTop;\n  },\n  getNativeTypeSize: function (type) {\n    switch (type) {\n      case 'i1': case 'i8': return 1;\n      case 'i16': return 2;\n      case 'i32': return 4;\n      case 'i64': return 8;\n      case 'float': return 4;\n      case 'double': return 8;\n      default: {\n        if (type[type.length-1] === '*') {\n          return Runtime.QUANTUM_SIZE; // A pointer\n        } else if (type[0] === 'i') {\n          var bits = parseInt(type.substr(1));\n          assert(bits % 8 === 0);\n          return bits/8;\n        } else {\n          return 0;\n        }\n      }\n    }\n  },\n  getNativeFieldSize: function (type) {\n    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);\n  },\n  STACK_ALIGN: 16,\n  prepVararg: function (ptr, type) {\n    if (type === 'double' || type === 'i64') {\n      // move so the load is aligned\n      if (ptr & 7) {\n        assert((ptr & 7) === 4);\n        ptr += 4;\n      }\n    } else {\n      assert((ptr & 3) === 0);\n    }\n    return ptr;\n  },\n  getAlignSize: function (type, size, vararg) {\n    // we align i64s and doubles on 64-bit boundaries, unlike x86\n    if (!vararg && (type == 'i64' || type == 'double')) return 8;\n    if (!type) return Math.min(size, 8); // align structures internally to 64 bits\n    return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);\n  },\n  dynCall: function (sig, ptr, args) {\n    if (args && args.length) {\n      assert(args.length == sig.length-1);\n      if (!args.splice) args = Array.prototype.slice.call(args);\n      args.splice(0, 0, ptr);\n      assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n      return Module['dynCall_' + sig].apply(null, args);\n    } else {\n      assert(sig.length == 1);\n      assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n      return Module['dynCall_' + sig].call(null, ptr);\n    }\n  },\n  functionPointers: [],\n  addFunction: function (func) {\n    for (var i = 0; i < Runtime.functionPointers.length; i++) {\n      if (!Runtime.functionPointers[i]) {\n        Runtime.functionPointers[i] = func;\n        return 2*(1 + i);\n      }\n    }\n    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n  },\n  removeFunction: function (index) {\n    Runtime.functionPointers[(index-2)/2] = null;\n  },\n  warnOnce: function (text) {\n    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};\n    if (!Runtime.warnOnce.shown[text]) {\n      Runtime.warnOnce.shown[text] = 1;\n      Module.printErr(text);\n    }\n  },\n  funcWrappers: {},\n  getFuncWrapper: function (func, sig) {\n    assert(sig);\n    if (!Runtime.funcWrappers[sig]) {\n      Runtime.funcWrappers[sig] = {};\n    }\n    var sigCache = Runtime.funcWrappers[sig];\n    if (!sigCache[func]) {\n      sigCache[func] = function dynCall_wrapper() {\n        return Runtime.dynCall(sig, func, arguments);\n      };\n    }\n    return sigCache[func];\n  },\n  getCompilerSetting: function (name) {\n    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work';\n  },\n  stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = (((STACKTOP)+15)&-16);(assert((((STACKTOP|0) < (STACK_MAX|0))|0))|0); return ret; },\n  staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + (assert(!staticSealed),size))|0;STATICTOP = (((STATICTOP)+15)&-16); return ret; },\n  dynamicAlloc: function (size) { var ret = DYNAMICTOP;DYNAMICTOP = (DYNAMICTOP + (assert(DYNAMICTOP > 0),size))|0;DYNAMICTOP = (((DYNAMICTOP)+15)&-16); if (DYNAMICTOP >= TOTAL_MEMORY) { var success = enlargeMemory(); if (!success) { DYNAMICTOP = ret;  return 0; } }; return ret; },\n  alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 16))*(quantum ? quantum : 16); return ret; },\n  makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0))); return ret; },\n  GLOBAL_BASE: 8,\n  QUANTUM_SIZE: 4,\n  __dummy__: 0\n}\n\n\n\nModule[\"Runtime\"] = Runtime;\n\n\n\n//========================================\n// Runtime essentials\n//========================================\n\nvar ABORT = false; // whether we are quitting the application. no code should run after this. set in exit() and abort()\nvar EXITSTATUS = 0;\n\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\nvar globalScope = this;\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  if (!func) {\n    try { func = eval('_' + ident); } catch(e) {}\n  }\n  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');\n  return func;\n}\n\nvar cwrap, ccall;\n(function(){\n  var JSfuncs = {\n    // Helpers for cwrap -- it can't refer to Runtime directly because it might\n    // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n    // out what the minified function name is.\n    'stackSave': function() {\n      Runtime.stackSave()\n    },\n    'stackRestore': function() {\n      Runtime.stackRestore()\n    },\n    // type conversion from js to c\n    'arrayToC' : function(arr) {\n      var ret = Runtime.stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    },\n    'stringToC' : function(str) {\n      var ret = 0;\n      if (str !== null && str !== undefined && str !== 0) { // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        ret = Runtime.stackAlloc((str.length << 2) + 1);\n        writeStringToMemory(str, ret);\n      }\n      return ret;\n    }\n  };\n  // For fast lookup of conversion functions\n  var toC = {'string' : JSfuncs['stringToC'], 'array' : JSfuncs['arrayToC']};\n\n  // C calling interface. \n  ccall = function ccallFunc(ident, returnType, argTypes, args, opts) {\n    var func = getCFunc(ident);\n    var cArgs = [];\n    var stack = 0;\n    assert(returnType !== 'array', 'Return type should not be \"array\".');\n    if (args) {\n      for (var i = 0; i < args.length; i++) {\n        var converter = toC[argTypes[i]];\n        if (converter) {\n          if (stack === 0) stack = Runtime.stackSave();\n          cArgs[i] = converter(args[i]);\n        } else {\n          cArgs[i] = args[i];\n        }\n      }\n    }\n    var ret = func.apply(null, cArgs);\n    if ((!opts || !opts.async) && typeof EmterpreterAsync === 'object') {\n      assert(!EmterpreterAsync.state, 'cannot start async op with normal JS calling ccall');\n    }\n    if (opts && opts.async) assert(!returnType, 'async ccalls cannot return values');\n    if (returnType === 'string') ret = Pointer_stringify(ret);\n    if (stack !== 0) {\n      if (opts && opts.async) {\n        EmterpreterAsync.asyncFinalizers.push(function() {\n          Runtime.stackRestore(stack);\n        });\n        return;\n      }\n      Runtime.stackRestore(stack);\n    }\n    return ret;\n  }\n\n  var sourceRegex = /^function\\s*[a-zA-Z$_0-9]*\\s*\\(([^)]*)\\)\\s*{\\s*([^*]*?)[\\s;]*(?:return\\s*(.*?)[;\\s]*)?}$/;\n  function parseJSFunc(jsfunc) {\n    // Match the body and the return value of a javascript function source\n    var parsed = jsfunc.toString().match(sourceRegex).slice(1);\n    return {arguments : parsed[0], body : parsed[1], returnValue: parsed[2]}\n  }\n\n  // sources of useful functions. we create this lazily as it can trigger a source decompression on this entire file\n  var JSsource = null;\n  function ensureJSsource() {\n    if (!JSsource) {\n      JSsource = {};\n      for (var fun in JSfuncs) {\n        if (JSfuncs.hasOwnProperty(fun)) {\n          // Elements of toCsource are arrays of three items:\n          // the code, and the return value\n          JSsource[fun] = parseJSFunc(JSfuncs[fun]);\n        }\n      }\n    }\n  }\n  \n  cwrap = function cwrap(ident, returnType, argTypes) {\n    argTypes = argTypes || [];\n    var cfunc = getCFunc(ident);\n    // When the function takes numbers and returns a number, we can just return\n    // the original function\n    var numericArgs = argTypes.every(function(type){ return type === 'number'});\n    var numericRet = (returnType !== 'string');\n    if ( numericRet && numericArgs) {\n      return cfunc;\n    }\n    // Creation of the arguments list ([\"$1\",\"$2\",...,\"$nargs\"])\n    var argNames = argTypes.map(function(x,i){return '$'+i});\n    var funcstr = \"(function(\" + argNames.join(',') + \") {\";\n    var nargs = argTypes.length;\n    if (!numericArgs) {\n      // Generate the code needed to convert the arguments from javascript\n      // values to pointers\n      ensureJSsource();\n      funcstr += 'var stack = ' + JSsource['stackSave'].body + ';';\n      for (var i = 0; i < nargs; i++) {\n        var arg = argNames[i], type = argTypes[i];\n        if (type === 'number') continue;\n        var convertCode = JSsource[type + 'ToC']; // [code, return]\n        funcstr += 'var ' + convertCode.arguments + ' = ' + arg + ';';\n        funcstr += convertCode.body + ';';\n        funcstr += arg + '=(' + convertCode.returnValue + ');';\n      }\n    }\n\n    // When the code is compressed, the name of cfunc is not literally 'cfunc' anymore\n    var cfuncname = parseJSFunc(function(){return cfunc}).returnValue;\n    // Call the function\n    funcstr += 'var ret = ' + cfuncname + '(' + argNames.join(',') + ');';\n    if (!numericRet) { // Return type can only by 'string' or 'number'\n      // Convert the result to a string\n      var strgfy = parseJSFunc(function(){return Pointer_stringify}).returnValue;\n      funcstr += 'ret = ' + strgfy + '(ret);';\n    }\n    funcstr += \"if (typeof EmterpreterAsync === 'object') { assert(!EmterpreterAsync.state, 'cannot start async op with normal JS calling cwrap') }\";\n    if (!numericArgs) {\n      // If we had a stack, restore it\n      ensureJSsource();\n      funcstr += JSsource['stackRestore'].body.replace('()', '(stack)') + ';';\n    }\n    funcstr += 'return ret})';\n    return eval(funcstr);\n  };\n})();\nModule[\"ccall\"] = ccall;\nModule[\"cwrap\"] = cwrap;\n\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n}\nModule[\"setValue\"] = setValue;\n\n\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for setValue: ' + type);\n    }\n  return null;\n}\nModule[\"getValue\"] = getValue;\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_STATIC = 2; // Cannot be freed\nvar ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 4; // Do not allocate\nModule[\"ALLOC_NORMAL\"] = ALLOC_NORMAL;\nModule[\"ALLOC_STACK\"] = ALLOC_STACK;\nModule[\"ALLOC_STATIC\"] = ALLOC_STATIC;\nModule[\"ALLOC_DYNAMIC\"] = ALLOC_DYNAMIC;\nModule[\"ALLOC_NONE\"] = ALLOC_NONE;\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [typeof _malloc === 'function' ? _malloc : Runtime.staticAlloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var ptr = ret, stop;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[((ptr)>>2)]=0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[((ptr++)>>0)]=0;\n    }\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(slab, ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n\n  var i = 0, type, typeSize, previousType;\n  while (i < size) {\n    var curr = slab[i];\n\n    if (typeof curr === 'function') {\n      curr = Runtime.getFunctionIndex(curr);\n    }\n\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n    assert(type, 'Must know what type to store in allocate!');\n\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret+i, curr, type);\n\n    // no need to look up size unless type changes, so cache it\n    if (previousType !== type) {\n      typeSize = Runtime.getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n\n  return ret;\n}\nModule[\"allocate\"] = allocate;\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n  if (!staticSealed) return Runtime.staticAlloc(size);\n  if ((typeof _sbrk !== 'undefined' && !_sbrk.called) || !runtimeInitialized) return Runtime.dynamicAlloc(size);\n  return _malloc(size);\n}\nModule[\"getMemory\"] = getMemory;\n\nfunction Pointer_stringify(ptr, /* optional */ length) {\n  if (length === 0 || !ptr) return '';\n  // TODO: use TextDecoder\n  // Find the length, and check for UTF while doing so\n  var hasUtf = 0;\n  var t;\n  var i = 0;\n  while (1) {\n    assert(ptr + i < TOTAL_MEMORY);\n    t = HEAPU8[(((ptr)+(i))>>0)];\n    hasUtf |= t;\n    if (t == 0 && !length) break;\n    i++;\n    if (length && i == length) break;\n  }\n  if (!length) length = i;\n\n  var ret = '';\n\n  if (hasUtf < 128) {\n    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n    var curr;\n    while (length > 0) {\n      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n      ret = ret ? ret + curr : curr;\n      ptr += MAX_CHUNK;\n      length -= MAX_CHUNK;\n    }\n    return ret;\n  }\n  return Module['UTF8ToString'](ptr);\n}\nModule[\"Pointer_stringify\"] = Pointer_stringify;\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = HEAP8[((ptr++)>>0)];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\nModule[\"AsciiToString\"] = AsciiToString;\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\nModule[\"stringToAscii\"] = stringToAscii;\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nfunction UTF8ArrayToString(u8Array, idx) {\n  var u0, u1, u2, u3, u4, u5;\n\n  var str = '';\n  while (1) {\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    u0 = u8Array[idx++];\n    if (!u0) return str;\n    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n    u1 = u8Array[idx++] & 63;\n    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n    u2 = u8Array[idx++] & 63;\n    if ((u0 & 0xF0) == 0xE0) {\n      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u3 = u8Array[idx++] & 63;\n      if ((u0 & 0xF8) == 0xF0) {\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n      } else {\n        u4 = u8Array[idx++] & 63;\n        if ((u0 & 0xFC) == 0xF8) {\n          u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;\n        } else {\n          u5 = u8Array[idx++] & 63;\n          u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;\n        }\n      }\n    }\n    if (u0 < 0x10000) {\n      str += String.fromCharCode(u0);\n    } else {\n      var ch = u0 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    }\n  }\n}\nModule[\"UTF8ArrayToString\"] = UTF8ArrayToString;\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction UTF8ToString(ptr) {\n  return UTF8ArrayToString(HEAPU8,ptr);\n}\nModule[\"UTF8ToString\"] = UTF8ToString;\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null \n//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x1FFFFF) {\n      if (outIdx + 3 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0x3FFFFFF) {\n      if (outIdx + 4 >= endIdx) break;\n      outU8Array[outIdx++] = 0xF8 | (u >> 24);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 5 >= endIdx) break;\n      outU8Array[outIdx++] = 0xFC | (u >> 30);\n      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n}\nModule[\"stringToUTF8Array\"] = stringToUTF8Array;\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\nModule[\"stringToUTF8\"] = stringToUTF8;\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) {\n      ++len;\n    } else if (u <= 0x7FF) {\n      len += 2;\n    } else if (u <= 0xFFFF) {\n      len += 3;\n    } else if (u <= 0x1FFFFF) {\n      len += 4;\n    } else if (u <= 0x3FFFFFF) {\n      len += 5;\n    } else {\n      len += 6;\n    }\n  }\n  return len;\n}\nModule[\"lengthBytesUTF8\"] = lengthBytesUTF8;\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction UTF16ToString(ptr) {\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n    if (codeUnit == 0)\n      return str;\n    ++i;\n    // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n    str += String.fromCharCode(codeUnit);\n  }\n}\n\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null \n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    HEAP16[((outPtr)>>1)]=codeUnit;\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP16[((outPtr)>>1)]=0;\n  return outPtr - startPtr;\n}\n\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\n\nfunction UTF32ToString(ptr) {\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n    if (utf32 == 0)\n      return str;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n}\n\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null \n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    HEAP32[((outPtr)>>2)]=codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP32[((outPtr)>>2)]=0;\n  return outPtr - startPtr;\n}\n\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n\nfunction demangle(func) {\n  var hasLibcxxabi = !!Module['___cxa_demangle'];\n  if (hasLibcxxabi) {\n    try {\n      var buf = _malloc(func.length);\n      writeStringToMemory(func.substr(1), buf);\n      var status = _malloc(4);\n      var ret = Module['___cxa_demangle'](buf, 0, 0, status);\n      if (getValue(status, 'i32') === 0 && ret) {\n        return Pointer_stringify(ret);\n      }\n      // otherwise, libcxxabi failed, we can try ours which may return a partial result\n    } catch(e) {\n      // failure when using libcxxabi, we can try ours which may return a partial result\n      return func;\n    } finally {\n      if (buf) _free(buf);\n      if (status) _free(status);\n      if (ret) _free(ret);\n    }\n  }\n  Runtime.warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n  return func;\n}\n\nfunction demangleAll(text) {\n  return text.replace(/__Z[\\w\\d_]+/g, function(x) { var y = demangle(x); return x === y ? x : (x + ' [' + y + ']') });\n}\n\nfunction jsStackTrace() {\n  var err = new Error();\n  if (!err.stack) {\n    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n    // so try that as a special-case.\n    try {\n      throw new Error(0);\n    } catch(e) {\n      err = e;\n    }\n    if (!err.stack) {\n      return '(no stack trace available)';\n    }\n  }\n  return err.stack.toString();\n}\n\nfunction stackTrace() {\n  return demangleAll(jsStackTrace());\n}\nModule[\"stackTrace\"] = stackTrace;\n\n// Memory management\n\nvar PAGE_SIZE = 4096;\n\nfunction alignMemoryPage(x) {\n  if (x % 4096 > 0) {\n    x += (4096 - (x % 4096));\n  }\n  return x;\n}\n\nvar HEAP;\nvar buffer;\nvar HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\nfunction updateGlobalBuffer(buf) {\n  Module['buffer'] = buffer = buf;\n}\n\nfunction updateGlobalBufferViews() {\n  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n}\n\nvar STATIC_BASE = 0, STATICTOP = 0, staticSealed = false; // static area\nvar STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0; // stack area\nvar DYNAMIC_BASE = 0, DYNAMICTOP = 0; // dynamic area handled by sbrk\n\n\nfunction abortOnCannotGrowMemory() {\n  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n}\n\nfunction enlargeMemory() {\n  abortOnCannotGrowMemory();\n}\n\n\nvar TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;\nvar TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 33554432;\n\nvar totalMemory = 64*1024;\nwhile (totalMemory < TOTAL_MEMORY || totalMemory < 2*TOTAL_STACK) {\n  if (totalMemory < 16*1024*1024) {\n    totalMemory *= 2;\n  } else {\n    totalMemory += 16*1024*1024\n  }\n}\nif (totalMemory !== TOTAL_MEMORY) {\n  Module.printErr('increasing TOTAL_MEMORY to ' + totalMemory + ' to be compliant with the asm.js spec (and given that TOTAL_STACK=' + TOTAL_STACK + ')');\n  TOTAL_MEMORY = totalMemory;\n}\n\n// Initialize the runtime's memory\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\nassert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),\n       'JS engine does not provide full typed array support');\n\n\n\n// Use a provided buffer, if there is one, or else allocate a new one\nif (Module['buffer']) {\n  buffer = Module['buffer'];\n  assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);\n} else {\n  buffer = new ArrayBuffer(TOTAL_MEMORY);\n}\nupdateGlobalBufferViews();\n\n\n// Endianness check (note: assumes compiler arch was little-endian)\nHEAP32[0] = 255;\nif (HEAPU8[0] !== 255 || HEAPU8[3] !== 0) throw 'Typed arrays 2 must be run on a little-endian system';\n\nModule['HEAP'] = HEAP;\nModule['buffer'] = buffer;\nModule['HEAP8'] = HEAP8;\nModule['HEAP16'] = HEAP16;\nModule['HEAP32'] = HEAP32;\nModule['HEAPU8'] = HEAPU8;\nModule['HEAPU16'] = HEAPU16;\nModule['HEAPU32'] = HEAPU32;\nModule['HEAPF32'] = HEAPF32;\nModule['HEAPF64'] = HEAPF64;\n\nfunction callRuntimeCallbacks(callbacks) {\n  while(callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Runtime.dynCall('v', func);\n      } else {\n        Runtime.dynCall('vi', func, [callback.arg]);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the runtime has exited\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n  // compatibility - merge in anything from Module['preRun'] at this time\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction ensureInitRuntime() {\n  if (runtimeInitialized) return;\n  runtimeInitialized = true;\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  callRuntimeCallbacks(__ATEXIT__);\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  // compatibility - merge in anything from Module['postRun'] at this time\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\nModule[\"addOnPreRun\"] = addOnPreRun;\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\nModule[\"addOnInit\"] = addOnInit;\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\nModule[\"addOnPreMain\"] = addOnPreMain;\n\nfunction addOnExit(cb) {\n  __ATEXIT__.unshift(cb);\n}\nModule[\"addOnExit\"] = addOnExit;\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\nModule[\"addOnPostRun\"] = addOnPostRun;\n\n// Tools\n\n\nfunction intArrayFromString(stringy, dontAddNull, length /* optional */) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\nModule[\"intArrayFromString\"] = intArrayFromString;\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\nModule[\"intArrayToString\"] = intArrayToString;\n\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  var array = intArrayFromString(string, dontAddNull);\n  var i = 0;\n  while (i < array.length) {\n    var chr = array[i];\n    HEAP8[(((buffer)+(i))>>0)]=chr;\n    i = i + 1;\n  }\n}\nModule[\"writeStringToMemory\"] = writeStringToMemory;\n\nfunction writeArrayToMemory(array, buffer) {\n  for (var i = 0; i < array.length; i++) {\n    HEAP8[((buffer++)>>0)]=array[i];\n  }\n}\nModule[\"writeArrayToMemory\"] = writeArrayToMemory;\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);\n    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\n}\nModule[\"writeAsciiToMemory\"] = writeAsciiToMemory;\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n                    : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n                        : Math.pow(2, bits-1);\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n  return value;\n}\n\n\n// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )\nif (!Math['imul'] || Math['imul'](0xffffffff, 5) !== -5) Math['imul'] = function imul(a, b) {\n  var ah  = a >>> 16;\n  var al = a & 0xffff;\n  var bh  = b >>> 16;\n  var bl = b & 0xffff;\n  return (al*bl + ((ah*bl + al*bh) << 16))|0;\n};\nMath.imul = Math['imul'];\n\n\nif (!Math['clz32']) Math['clz32'] = function(x) {\n  x = x >>> 0;\n  for (var i = 0; i < 32; i++) {\n    if (x & (1 << (31 - i))) return i;\n  }\n  return 32;\n};\nMath.clz32 = Math['clz32']\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_min = Math.min;\nvar Math_clz32 = Math.clz32;\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// PRE_RUN_ADDITIONS (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function() {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            Module.printErr('still waiting on run dependencies:');\n          }\n          Module.printErr('dependency: ' + dep);\n        }\n        if (shown) {\n          Module.printErr('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    Module.printErr('warning: run dependency added without ID');\n  }\n}\nModule[\"addRunDependency\"] = addRunDependency;\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    Module.printErr('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\nModule[\"removeRunDependency\"] = removeRunDependency;\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n\n\nvar memoryInitializer = null;\n\n\n\n\n// === Body ===\n\nvar ASM_CONSTS = [];\n\n\n\n\nSTATIC_BASE = 8;\n\nSTATICTOP = STATIC_BASE + 9456;\n  /* global initializers */  __ATINIT__.push();\n  \n\n/* memory initializer */ allocate([212,2,0,0,134,3,0,0,212,2,0,0,17,25,0,0,252,2,0,0,239,24,0,0,56,0,0,0,0,0,0,0,252,2,0,0,156,24,0,0,24,0,0,0,0,0,0,0,252,2,0,0,193,24,0,0,72,0,0,0,0,0,0,0,212,2,0,0,226,24,0,0,252,2,0,0,9,26,0,0,16,0,0,0,0,0,0,0,252,2,0,0,37,26,0,0,16,0,0,0,0,0,0,0,252,2,0,0,53,26,0,0,96,0,0,0,0,0,0,0,252,2,0,0,106,26,0,0,56,0,0,0,0,0,0,0,252,2,0,0,70,26,0,0,128,0,0,0,0,0,0,0,150,13,0,0,0,0,0,0,155,13,0,0,1,0,0,0,164,13,0,0,2,0,0,0,174,13,0,0,3,0,0,0,184,13,0,0,4,0,0,0,194,13,0,0,5,0,0,0,204,13,0,0,6,0,0,0,214,13,0,0,7,0,0,0,0,0,0,0,0,0,0,0,224,13,0,0,0,0,0,0,232,13,0,0,1,0,0,0,245,13,0,0,2,0,0,0,253,13,0,0,3,0,0,0,10,14,0,0,4,0,0,0,22,14,0,0,5,0,0,0,33,14,0,0,6,0,0,0,43,14,0,0,7,0,0,0,58,14,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,255,255,255,255,1,0,0,0,255,255,255,255,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,255,255,255,255,108,1,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,3,0,0,0,208,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,224,1,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,3,0,0,0,216,28,0,0,0,4,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,224,1,0,0,88,2,0,0,9,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,3,0,0,0,224,32,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,24,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,0,0,0,0,40,0,0,0,7,0,0,0,15,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,16,0,0,0,17,0,0,0,18,0,0,0,30,25,0,0,0,0,0,0,80,0,0,0,19,0,0,0,20,0,0,0,21,0,0,0,0,0,0,0,96,0,0,0,22,0,0,0,23,0,0,0,24,0,0,0,0,0,0,0,112,0,0,0,22,0,0,0,25,0,0,0,24,0,0,0,45,0,114,98,0,119,0,48,46,50,53,0,101,110,100,45,111,102,45,102,105,108,101,32,114,101,97,100,105,110,103,32,112,110,109,32,102,105,108,101,46,0,78,49,48,80,97,103,101,95,105,109,97,103,101,53,69,114,114,111,114,69,0,106,117,110,107,32,105,110,32,112,98,109,32,102,105,108,101,32,119,104,101,114,101,32,98,105,116,115,32,115,104,111,117,108,100,32,98,101,46,0,106,117,110,107,32,105,110,32,112,110,109,32,102,105,108,101,32,119,104,101,114,101,32,97,110,32,105,110,116,101,103,101,114,32,115,104,111,117,108,100,32,98,101,46,0,110,117,109,98,101,114,32,116,111,111,32,98,105,103,32,105,110,32,112,110,109,32,102,105,108,101,46,0,122,101,114,111,32,109,97,120,118,97,108,32,105,110,32,112,103,109,32,102,105,108,101,46,0,118,97,108,117,101,32,62,32,109,97,120,118,97,108,32,105,110,32,112,103,109,32,102,105,108,101,46,0,109,97,120,118,97,108,32,62,32,50,53,53,32,105,110,32,112,103,109,32,34,80,53,34,32,102,105,108,101,46,0,122,101,114,111,32,109,97,120,118,97,108,32,105,110,32,112,112,109,32,102,105,108,101,46,0,118,97,108,117,101,32,62,32,109,97,120,118,97,108,32,105,110,32,112,112,109,32,102,105,108,101,46,0,109,97,120,118,97,108,32,62,32,50,53,53,32,105,110,32,112,112,109,32,34,80,54,34,32,102,105,108,101,46,0,98,97,100,32,109,97,103,105,99,32,110,117,109,98,101,114,32,45,32,110,111,116,32,97,32,112,98,109,44,32,112,103,109,32,111,114,32,112,112,109,32,102,105,108,101,46,0,122,101,114,111,32,119,105,100,116,104,32,105,110,32,112,110,109,32,102,105,108,101,46,0,122,101,114,111,32,104,101,105,103,104,116,32,105,110,32,112,110,109,32,102,105,108,101,46,0,105,109,97,103,101,32,116,111,111,32,115,109,97,108,108,46,32,77,105,110,105,109,117,109,32,115,105,122,101,32,105,115,32,51,120,51,46,0,105,109,97,103,101,32,116,111,111,32,98,105,103,46,32,39,105,110,116,39,32,119,105,108,108,32,111,118,101,114,102,108,111,119,46,0,102,105,108,101,32,116,121,112,101,32,105,115,32,80,37,99,10,0,102,105,108,101,32,115,105,122,101,32,105,115,32,37,100,119,32,120,32,37,100,104,10,0,80,37,99,10,37,100,32,37,100,10,0,37,100,10,0,37,100,32,0,37,100,32,37,100,32,37,100,10,0,37,100,32,37,100,32,37,100,32,0,37,99,32,37,99,32,37,99,32,0,98,97,100,32,112,97,114,97,109,101,116,101,114,32,98,117,105,108,100,105,110,103,32,97,32,114,101,100,117,99,101,100,32,80,97,103,101,95,105,109,97,103,101,46,0,115,99,97,108,101,32,102,97,99,116,111,114,32,116,111,111,32,98,105,103,46,32,39,105,110,116,39,32,119,105,108,108,32,111,118,101,114,102,108,111,119,46,0,108,32,61,32,37,100,44,32,116,32,61,32,37,100,44,32,114,32,61,32,37,100,44,32,98,32,61,32,37,100,10,0,98,97,100,32,112,97,114,97,109,101,116,101,114,32,98,117,105,108,100,105,110,103,32,97,32,82,101,99,116,97,110,103,108,101,46,0,108,101,102,116,44,32,98,97,100,32,112,97,114,97,109,101,116,101,114,32,114,101,115,105,122,105,110,103,32,97,32,82,101,99,116,97,110,103,108,101,46,0,116,111,112,44,32,98,97,100,32,112,97,114,97,109,101,116,101,114,32,114,101,115,105,122,105,110,103,32,97,32,82,101,99,116,97,110,103,108,101,46,0,114,105,103,104,116,44,32,98,97,100,32,112,97,114,97,109,101,116,101,114,32,114,101,115,105,122,105,110,103,32,97,32,82,101,99,116,97,110,103,108,101,46,0,98,111,116,116,111,109,44,32,98,97,100,32,112,97,114,97,109,101,116,101,114,32,114,101,115,105,122,105,110,103,32,97,32,82,101,99,116,97,110,103,108,101,46,0,104,101,105,103,104,116,44,32,98,97,100,32,112,97,114,97,109,101,116,101,114,32,114,101,115,105,122,105,110,103,32,97,32,82,101,99,116,97,110,103,108,101,46,0,119,105,100,116,104,44,32,98,97,100,32,112,97,114,97,109,101,116,101,114,32,114,101,115,105,122,105,110,103,32,97,32,82,101,99,116,97,110,103,108,101,46,0,106,111,105,110,95,98,108,111,98,115,44,32,108,111,115,116,32,98,108,111,98,46,0,110,117,109,98,101,114,32,111,102,32,116,101,120,116,32,98,108,111,99,107,115,32,61,32,37,100,10,0,116,111,116,97,108,32,122,111,110,101,115,32,105,110,32,112,97,103,101,32,37,100,10,0,116,111,116,97,108,32,98,108,111,98,115,32,105,110,32,112,97,103,101,32,37,100,10,10,0,122,111,110,101,32,37,100,32,111,102,32,37,100,10,0,122,111,110,101,32,115,105,122,101,32,37,100,119,32,120,32,37,100,104,10,0,116,111,116,97,108,32,98,108,111,98,115,32,105,110,32,122,111,110,101,32,37,117,10,10,0,84,101,120,116,112,97,103,101,58,58,116,101,120,116,98,108,111,99,107,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,46,0,115,111,117,114,99,101,32,102,105,108,101,32,37,115,10,0,116,111,116,97,108,32,116,101,120,116,32,98,108,111,99,107,115,32,37,100,10,0,116,101,120,116,32,98,108,111,99,107,32,37,100,32,37,100,32,37,100,32,37,100,32,37,100,10,0,98,97,100,32,112,97,114,97,109,101,116,101,114,32,98,117,105,108,100,105,110,103,32,97,32,66,105,116,109,97,112,32,102,114,111,109,32,112,97,114,116,32,111,102,32,97,110,111,116,104,101,114,32,111,110,101,46,0,104,111,108,101,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,46,0,32,79,0,32,46,0,102,105,108,108,95,104,111,108,101,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,46,0,100,101,108,101,116,101,95,104,111,108,101,44,32,108,111,115,116,32,104,111,108,101,46,0,106,111,105,110,95,104,111,108,101,115,44,32,108,111,115,116,32,104,111,108,101,46,0,108,105,110,101,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,46,0,37,100,32,108,105,110,101,115,10,10,0,37,100,32,99,104,97,114,97,99,116,101,114,115,32,105,110,32,108,105,110,101,32,37,100,10,0,108,105,110,101,115,32,37,100,10,0,108,105,110,101,32,37,100,32,99,104,97,114,115,32,37,100,32,104,101,105,103,104,116,32,37,100,10,0,99,111,110,115,116,32,98,108,111,98,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,0,98,108,111,98,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,0,105,110,115,101,114,116,95,103,117,101,115,115,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,0,115,119,97,112,95,103,117,101,115,115,101,115,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,0,103,117,101,115,115,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,0,95,0,37,100,32,103,117,101,115,115,101,115,32,32,32,32,0,103,117,101,115,115,32,39,37,115,39,44,32,99,111,110,102,105,100,101,110,99,101,32,37,100,32,32,32,32,0,103,117,101,115,115,32,39,37,99,39,44,32,99,111,110,102,105,100,101,110,99,101,32,37,100,32,32,32,32,0,103,117,101,115,115,32,39,92,116,39,44,32,99,111,110,102,105,100,101,110,99,101,32,37,100,32,32,32,32,0,108,101,102,116,32,61,32,37,100,44,32,116,111,112,32,61,32,37,100,44,32,114,105,103,104,116,32,61,32,37,100,44,32,98,111,116,116,111,109,32,61,32,37,100,10,0,119,105,100,116,104,32,61,32,37,100,44,32,104,101,105,103,104,116,32,61,32,37,100,44,32,104,99,101,110,116,101,114,32,61,32,37,100,44,32,118,99,101,110,116,101,114,32,61,32,37,100,44,32,98,108,97,99,107,32,97,114,101,97,32,61,32,37,100,37,37,10,0,104,98,97,114,115,32,61,32,37,100,44,32,118,98,97,114,115,32,61,32,37,100,10,0,10,10,0,32,37,99,0,32,32,116,111,112,40,37,100,41,0,32,32,118,99,101,110,116,101,114,40,37,100,41,0,32,32,98,111,116,116,111,109,40,37,100,41,0,32,32,98,111,120,46,116,111,112,40,37,100,41,0,32,32,98,111,120,46,118,99,101,110,116,101,114,40,37,100,41,0,32,32,98,111,120,46,98,111,116,116,111,109,40,37,100,41,0,32,32,104,49,46,116,111,112,40,37,100,41,0,32,32,104,49,46,98,111,116,116,111,109,40,37,100,41,0,32,32,104,50,46,116,111,112,40,37,100,41,0,32,32,104,50,46,98,111,116,116,111,109,40,37,100,41,0,37,51,100,32,37,51,100,32,37,50,100,32,37,50,100,59,32,37,100,0,44,32,39,37,99,39,37,100,0,44,32,39,37,115,39,37,100,0,99,104,97,114,97,99,116,101,114,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,46,0,105,115,95,107,101,121,95,99,104,97,114,97,99,116,101,114,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,46,0,100,101,108,101,116,101,95,99,104,97,114,97,99,116,101,114,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,46,0,105,110,115,101,114,116,95,115,112,97,99,101,44,32,105,110,100,101,120,32,111,117,116,32,111,102,32,98,111,117,110,100,115,46,0,105,110,115,101,114,116,95,115,112,97,99,101,44,32,116,114,97,99,107,32,110,111,116,32,115,101,116,32,121,101,116,46,0,109,101,97,110,32,104,101,105,103,104,116,32,61,32,37,100,44,32,109,101,100,105,97,110,32,104,101,105,103,104,116,32,61,32,37,100,44,32,116,114,97,99,107,32,115,101,103,109,101,110,116,115,32,61,32,37,100,44,32,98,105,103,32,105,110,105,116,105,97,108,115,32,61,32,37,100,10,0,108,32,61,32,37,100,44,32,108,99,32,61,32,37,100,44,32,114,32,61,32,37,100,44,32,114,99,32,61,32,37,100,44,32,104,32,61,32,37,100,10,0,98,97,100,32,112,97,114,97,109,101,116,101,114,32,98,117,105,108,100,105,110,103,32,97,32,86,114,104,111,109,98,111,105,100,46,0,101,120,116,101,110,100,95,108,101,102,116,44,32,98,97,100,32,112,97,114,97,109,101,116,101,114,32,114,101,115,105,122,105,110,103,32,97,32,86,114,104,111,109,98,111,105,100,46,0,101,120,116,101,110,100,95,114,105,103,104,116,44,32,98,97,100,32,112,97,114,97,109,101,116,101,114,32,114,101,115,105,122,105,110,103,32,97,32,86,114,104,111,109,98,111,105,100,46,0,111,99,114,97,100,58,32,105,110,116,101,114,110,97,108,32,101,114,114,111,114,58,32,37,115,10,0,104,101,108,112,0,32,32,37,115,0,110,111,110,101,0,114,111,116,97,116,101,57,48,0,114,111,116,97,116,101,49,56,48,0,114,111,116,97,116,101,50,55,48,0,109,105,114,114,111,114,95,108,114,0,109,105,114,114,111,114,95,116,98,0,109,105,114,114,111,114,95,100,49,0,109,105,114,114,111,114,95,100,50,0,108,101,116,116,101,114,115,0,108,101,116,116,101,114,115,95,111,110,108,121,0,110,117,109,98,101,114,115,0,110,117,109,98,101,114,115,95,111,110,108,121,0,115,97,109,101,95,104,101,105,103,104,116,0,116,101,120,116,95,98,108,111,99,107,0,117,112,112,101,114,95,110,117,109,0,117,112,112,101,114,95,110,117,109,95,109,97,114,107,0,117,112,112,101,114,95,110,117,109,95,111,110,108,121,0,37,115,58,32,98,97,100,32,102,105,108,116,101,114,32,39,37,115,39,10,0,86,97,108,105,100,32,102,105,108,116,101,114,32,110,97,109,101,115,58,0,84,33,34,25,13,1,2,3,17,75,28,12,16,4,11,29,18,30,39,104,110,111,112,113,98,32,5,6,15,19,20,21,26,8,22,7,40,36,23,24,9,10,14,27,31,37,35,131,130,125,38,42,43,60,61,62,63,67,71,74,77,88,89,90,91,92,93,94,95,96,97,99,100,101,102,103,105,106,107,108,114,115,116,121,122,123,124,0,73,108,108,101,103,97,108,32,98,121,116,101,32,115,101,113,117,101,110,99,101,0,68,111,109,97,105,110,32,101,114,114,111,114,0,82,101,115,117,108,116,32,110,111,116,32,114,101,112,114,101,115,101,110,116,97,98,108,101,0,78,111,116,32,97,32,116,116,121,0,80,101,114,109,105,115,115,105,111,110,32,100,101,110,105,101,100,0,79,112,101,114,97,116,105,111,110,32,110,111,116,32,112,101,114,109,105,116,116,101,100,0,78,111,32,115,117,99,104,32,102,105,108,101,32,111,114,32,100,105,114,101,99,116,111,114,121,0,78,111,32,115,117,99,104,32,112,114,111,99,101,115,115,0,70,105,108,101,32,101,120,105,115,116,115,0,86,97,108,117,101,32,116,111,111,32,108,97,114,103,101,32,102,111,114,32,100,97,116,97,32,116,121,112,101,0,78,111,32,115,112,97,99,101,32,108,101,102,116,32,111,110,32,100,101,118,105,99,101,0,79,117,116,32,111,102,32,109,101,109,111,114,121,0,82,101,115,111,117,114,99,101,32,98,117,115,121,0,73,110,116,101,114,114,117,112,116,101,100,32,115,121,115,116,101,109,32,99,97,108,108,0,82,101,115,111,117,114,99,101,32,116,101,109,112,111,114,97,114,105,108,121,32,117,110,97,118,97,105,108,97,98,108,101,0,73,110,118,97,108,105,100,32,115,101,101,107,0,67,114,111,115,115,45,100,101,118,105,99,101,32,108,105,110,107,0,82,101,97,100,45,111,110,108,121,32,102,105,108,101,32,115,121,115,116,101,109,0,68,105,114,101,99,116,111,114,121,32,110,111,116,32,101,109,112,116,121,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,112,101,101,114,0,79,112,101,114,97,116,105,111,110,32,116,105,109,101,100,32,111,117,116,0,67,111,110,110,101,99,116,105,111,110,32,114,101,102,117,115,101,100,0,72,111,115,116,32,105,115,32,100,111,119,110,0,72,111,115,116,32,105,115,32,117,110,114,101,97,99,104,97,98,108,101,0,65,100,100,114,101,115,115,32,105,110,32,117,115,101,0,66,114,111,107,101,110,32,112,105,112,101,0,73,47,79,32,101,114,114,111,114,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,32,111,114,32,97,100,100,114,101,115,115,0,66,108,111,99,107,32,100,101,118,105,99,101,32,114,101,113,117,105,114,101,100,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,0,78,111,116,32,97,32,100,105,114,101,99,116,111,114,121,0,73,115,32,97,32,100,105,114,101,99,116,111,114,121,0,84,101,120,116,32,102,105,108,101,32,98,117,115,121,0,69,120,101,99,32,102,111,114,109,97,116,32,101,114,114,111,114,0,73,110,118,97,108,105,100,32,97,114,103,117,109,101,110,116,0,65,114,103,117,109,101,110,116,32,108,105,115,116,32,116,111,111,32,108,111,110,103,0,83,121,109,98,111,108,105,99,32,108,105,110,107,32,108,111,111,112,0,70,105,108,101,110,97,109,101,32,116,111,111,32,108,111,110,103,0,84,111,111,32,109,97,110,121,32,111,112,101,110,32,102,105,108,101,115,32,105,110,32,115,121,115,116,101,109,0,78,111,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,115,32,97,118,97,105,108,97,98,108,101,0,66,97,100,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,0,78,111,32,99,104,105,108,100,32,112,114,111,99,101,115,115,0,66,97,100,32,97,100,100,114,101,115,115,0,70,105,108,101,32,116,111,111,32,108,97,114,103,101,0,84,111,111,32,109,97,110,121,32,108,105,110,107,115,0,78,111,32,108,111,99,107,115,32,97,118,97,105,108,97,98,108,101,0,82,101,115,111,117,114,99,101,32,100,101,97,100,108,111,99,107,32,119,111,117,108,100,32,111,99,99,117,114,0,83,116,97,116,101,32,110,111,116,32,114,101,99,111,118,101,114,97,98,108,101,0,80,114,101,118,105,111,117,115,32,111,119,110,101,114,32,100,105,101,100,0,79,112,101,114,97,116,105,111,110,32,99,97,110,99,101,108,101,100,0,70,117,110,99,116,105,111,110,32,110,111,116,32,105,109,112,108,101,109,101,110,116,101,100,0,78,111,32,109,101,115,115,97,103,101,32,111,102,32,100,101,115,105,114,101,100,32,116,121,112,101,0,73,100,101,110,116,105,102,105,101,114,32,114,101,109,111,118,101,100,0,68,101,118,105,99,101,32,110,111,116,32,97,32,115,116,114,101,97,109,0,78,111,32,100,97,116,97,32,97,118,97,105,108,97,98,108,101,0,68,101,118,105,99,101,32,116,105,109,101,111,117,116,0,79,117,116,32,111,102,32,115,116,114,101,97,109,115,32,114,101,115,111,117,114,99,101,115,0,76,105,110,107,32,104,97,115,32,98,101,101,110,32,115,101,118,101,114,101,100,0,80,114,111,116,111,99,111,108,32,101,114,114,111,114,0,66,97,100,32,109,101,115,115,97,103,101,0,70,105,108,101,32,100,101,115,99,114,105,112,116,111,114,32,105,110,32,98,97,100,32,115,116,97,116,101,0,78,111,116,32,97,32,115,111,99,107,101,116,0,68,101,115,116,105,110,97,116,105,111,110,32,97,100,100,114,101,115,115,32,114,101,113,117,105,114,101,100,0,77,101,115,115,97,103,101,32,116,111,111,32,108,97,114,103,101,0,80,114,111,116,111,99,111,108,32,119,114,111,110,103,32,116,121,112,101,32,102,111,114,32,115,111,99,107,101,116,0,80,114,111,116,111,99,111,108,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,80,114,111,116,111,99,111,108,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,83,111,99,107,101,116,32,116,121,112,101,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,78,111,116,32,115,117,112,112,111,114,116,101,100,0,80,114,111,116,111,99,111,108,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,65,100,100,114,101,115,115,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,98,121,32,112,114,111,116,111,99,111,108,0,65,100,100,114,101,115,115,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,78,101,116,119,111,114,107,32,105,115,32,100,111,119,110,0,78,101,116,119,111,114,107,32,117,110,114,101,97,99,104,97,98,108,101,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,110,101,116,119,111,114,107,0,67,111,110,110,101,99,116,105,111,110,32,97,98,111,114,116,101,100,0,78,111,32,98,117,102,102,101,114,32,115,112,97,99,101,32,97,118,97,105,108,97,98,108,101,0,83,111,99,107,101,116,32,105,115,32,99,111,110,110,101,99,116,101,100,0,83,111,99,107,101,116,32,110,111,116,32,99,111,110,110,101,99,116,101,100,0,67,97,110,110,111,116,32,115,101,110,100,32,97,102,116,101,114,32,115,111,99,107,101,116,32,115,104,117,116,100,111,119,110,0,79,112,101,114,97,116,105,111,110,32,97,108,114,101,97,100,121,32,105,110,32,112,114,111,103,114,101,115,115,0,79,112,101,114,97,116,105,111,110,32,105,110,32,112,114,111,103,114,101,115,115,0,83,116,97,108,101,32,102,105,108,101,32,104,97,110,100,108,101,0,82,101,109,111,116,101,32,73,47,79,32,101,114,114,111,114,0,81,117,111,116,97,32,101,120,99,101,101,100,101,100,0,78,111,32,109,101,100,105,117,109,32,102,111,117,110,100,0,87,114,111,110,103,32,109,101,100,105,117,109,32,116,121,112,101,0,78,111,32,101,114,114,111,114,32,105,110,102,111,114,109,97,116,105,111,110,0,0,114,119,97,0,17,0,10,0,17,17,17,0,0,0,0,5,0,0,0,0,0,0,9,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,15,10,17,17,17,3,10,7,0,1,19,9,11,11,0,0,9,6,11,0,0,11,0,6,17,0,0,0,17,17,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,10,10,17,17,17,0,10,0,0,2,0,9,11,0,0,0,9,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,4,13,0,0,0,0,9,14,0,0,0,0,0,14,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,0,9,16,0,0,0,0,0,16,0,0,16,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,10,0,0,0,0,9,11,0,0,0,0,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,45,43,32,32,32,48,88,48,120,0,40,110,117,108,108,41,0,45,48,88,43,48,88,32,48,88,45,48,120,43,48,120,32,48,120,0,105,110,102,0,73,78,70,0,110,97,110,0,78,65,78,0,46,0,98,97,115,105,99,95,115,116,114,105,110,103,0,118,101,99,116,111,114,0,99,97,110,110,111,116,32,122,101,114,111,32,111,117,116,32,116,104,114,101,97,100,32,118,97,108,117,101,32,102,111,114,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,40,41,0,99,97,110,110,111,116,32,99,114,101,97,116,101,32,112,116,104,114,101,97,100,32,107,101,121,32,102,111,114,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,40,41,0,112,116,104,114,101,97,100,95,111,110,99,101,32,102,97,105,108,117,114,101,32,105,110,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,95,102,97,115,116,40,41,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,48,95,95,115,105,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,54,95,95,115,104,105,109,95,116,121,112,101,95,105,110,102,111,69,0,83,116,57,116,121,112,101,95,105,110,102,111,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,83,116,57,101,120,99,101,112,116,105,111,110,0,117,110,99,97,117,103,104,116,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,101,120,99,101,112,116,105,111,110,32,111,102,32,116,121,112,101,32,37,115,58,32,37,115,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,101,120,99,101,112,116,105,111,110,32,111,102,32,116,121,112,101,32,37,115,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,102,111,114,101,105,103,110,32,101,120,99,101,112,116,105,111,110,0,116,101,114,109,105,110,97,116,105,110,103,0,116,101,114,109,105,110,97,116,101,95,104,97,110,100,108,101,114,32,117,110,101,120,112,101,99,116,101,100,108,121,32,114,101,116,117,114,110,101,100,0,116,101,114,109,105,110,97,116,101,95,104,97,110,100,108,101,114,32,117,110,101,120,112,101,99,116,101,100,108,121,32,116,104,114,101,119,32,97,110,32,101,120,99,101,112,116,105,111,110,0,83,116,57,98,97,100,95,97,108,108,111,99,0,115,116,100,58,58,98,97,100,95,97,108,108,111,99,0,83,116,49,49,108,111,103,105,99,95,101,114,114,111,114,0,83,116,49,50,108,101,110,103,116,104,95,101,114,114,111,114,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,57,95,95,112,111,105,110,116,101,114,95,116,121,112,101,95,105,110,102,111,69,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,112,98,97,115,101,95,116,121,112,101,95,105,110,102,111,69,0], \"i8\", ALLOC_NONE, Runtime.GLOBAL_BASE);\n\n\n\n\n\n/* no memory initializer */\nvar tempDoublePtr = STATICTOP; STATICTOP += 16;\n\nassert(tempDoublePtr % 8 == 0);\n\nfunction copyTempFloat(ptr) { // functions, because inlining this code increases code size too much\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n}\n\nfunction copyTempDouble(ptr) {\n\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\n\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\n\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\n\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\n\n  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];\n\n  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];\n\n  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];\n\n  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];\n\n}\n\n// {{PRE_LIBRARY}}\n\n\n   \n  Module[\"_i64Subtract\"] = _i64Subtract;\n\n  \n  function ___setErrNo(value) {\n      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;\n      else Module.printErr('failed to set errno from JS');\n      return value;\n    }\n  \n  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};function _sysconf(name) {\n      // long sysconf(int name);\n      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html\n      switch(name) {\n        case 30: return PAGE_SIZE;\n        case 85: return totalMemory / PAGE_SIZE;\n        case 132:\n        case 133:\n        case 12:\n        case 137:\n        case 138:\n        case 15:\n        case 235:\n        case 16:\n        case 17:\n        case 18:\n        case 19:\n        case 20:\n        case 149:\n        case 13:\n        case 10:\n        case 236:\n        case 153:\n        case 9:\n        case 21:\n        case 22:\n        case 159:\n        case 154:\n        case 14:\n        case 77:\n        case 78:\n        case 139:\n        case 80:\n        case 81:\n        case 82:\n        case 68:\n        case 67:\n        case 164:\n        case 11:\n        case 29:\n        case 47:\n        case 48:\n        case 95:\n        case 52:\n        case 51:\n        case 46:\n          return 200809;\n        case 79:\n          return 0;\n        case 27:\n        case 246:\n        case 127:\n        case 128:\n        case 23:\n        case 24:\n        case 160:\n        case 161:\n        case 181:\n        case 182:\n        case 242:\n        case 183:\n        case 184:\n        case 243:\n        case 244:\n        case 245:\n        case 165:\n        case 178:\n        case 179:\n        case 49:\n        case 50:\n        case 168:\n        case 169:\n        case 175:\n        case 170:\n        case 171:\n        case 172:\n        case 97:\n        case 76:\n        case 32:\n        case 173:\n        case 35:\n          return -1;\n        case 176:\n        case 177:\n        case 7:\n        case 155:\n        case 8:\n        case 157:\n        case 125:\n        case 126:\n        case 92:\n        case 93:\n        case 129:\n        case 130:\n        case 131:\n        case 94:\n        case 91:\n          return 1;\n        case 74:\n        case 60:\n        case 69:\n        case 70:\n        case 4:\n          return 1024;\n        case 31:\n        case 42:\n        case 72:\n          return 32;\n        case 87:\n        case 26:\n        case 33:\n          return 2147483647;\n        case 34:\n        case 1:\n          return 47839;\n        case 38:\n        case 36:\n          return 99;\n        case 43:\n        case 37:\n          return 2048;\n        case 0: return 2097152;\n        case 3: return 65536;\n        case 28: return 32768;\n        case 44: return 32767;\n        case 75: return 16384;\n        case 39: return 1000;\n        case 89: return 700;\n        case 71: return 256;\n        case 40: return 255;\n        case 2: return 100;\n        case 180: return 64;\n        case 25: return 20;\n        case 5: return 16;\n        case 6: return 6;\n        case 73: return 4;\n        case 84: {\n          if (typeof navigator === 'object') return navigator['hardwareConcurrency'] || 1;\n          return 1;\n        }\n      }\n      ___setErrNo(ERRNO_CODES.EINVAL);\n      return -1;\n    }\n\n  \n  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()\n      return !!__ZSt18uncaught_exceptionv.uncaught_exception;\n    }\n  \n  \n  \n  var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:function (adjusted) {\n        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;\n        for (var ptr in EXCEPTIONS.infos) {\n          var info = EXCEPTIONS.infos[ptr];\n          if (info.adjusted === adjusted) {\n            return ptr;\n          }\n        }\n        return adjusted;\n      },addRef:function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount++;\n      },decRef:function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        assert(info.refcount > 0);\n        info.refcount--;\n        if (info.refcount === 0) {\n          if (info.destructor) {\n            Runtime.dynCall('vi', info.destructor, [ptr]);\n          }\n          delete EXCEPTIONS.infos[ptr];\n          ___cxa_free_exception(ptr);\n        }\n      },clearRef:function (ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount = 0;\n      }};\n  function ___resumeException(ptr) {\n      if (!EXCEPTIONS.last) { EXCEPTIONS.last = ptr; }\n      EXCEPTIONS.clearRef(EXCEPTIONS.deAdjust(ptr)); // exception refcount should be cleared, but don't free it\n      throw ptr;\n    }function ___cxa_find_matching_catch() {\n      var thrown = EXCEPTIONS.last;\n      if (!thrown) {\n        // just pass through the null ptr\n        return ((asm[\"setTempRet0\"](0),0)|0);\n      }\n      var info = EXCEPTIONS.infos[thrown];\n      var throwntype = info.type;\n      if (!throwntype) {\n        // just pass through the thrown ptr\n        return ((asm[\"setTempRet0\"](0),thrown)|0);\n      }\n      var typeArray = Array.prototype.slice.call(arguments);\n  \n      var pointer = Module['___cxa_is_pointer_type'](throwntype);\n      // can_catch receives a **, add indirection\n      if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);\n      HEAP32[((___cxa_find_matching_catch.buffer)>>2)]=thrown;\n      thrown = ___cxa_find_matching_catch.buffer;\n      // The different catch blocks are denoted by different types.\n      // Due to inheritance, those types may not precisely match the\n      // type of the thrown object. Find one which matches, and\n      // return the type of the catch block which should be called.\n      for (var i = 0; i < typeArray.length; i++) {\n        if (typeArray[i] && Module['___cxa_can_catch'](typeArray[i], throwntype, thrown)) {\n          thrown = HEAP32[((thrown)>>2)]; // undo indirection\n          info.adjusted = thrown;\n          return ((asm[\"setTempRet0\"](typeArray[i]),thrown)|0);\n        }\n      }\n      // Shouldn't happen unless we have bogus data in typeArray\n      // or encounter a type for which emscripten doesn't have suitable\n      // typeinfo defined. Best-efforts match just in case.\n      thrown = HEAP32[((thrown)>>2)]; // undo indirection\n      return ((asm[\"setTempRet0\"](throwntype),thrown)|0);\n    }function ___cxa_throw(ptr, type, destructor) {\n      EXCEPTIONS.infos[ptr] = {\n        ptr: ptr,\n        adjusted: ptr,\n        type: type,\n        destructor: destructor,\n        refcount: 0\n      };\n      EXCEPTIONS.last = ptr;\n      if (!(\"uncaught_exception\" in __ZSt18uncaught_exceptionv)) {\n        __ZSt18uncaught_exceptionv.uncaught_exception = 1;\n      } else {\n        __ZSt18uncaught_exceptionv.uncaught_exception++;\n      }\n      throw ptr;\n    }\n\n   \n  Module[\"_memset\"] = _memset;\n\n  function ___gxx_personality_v0() {\n    }\n\n   \n  Module[\"_bitshift64Shl\"] = _bitshift64Shl;\n\n  function _abort() {\n      Module['abort']();\n    }\n\n  \n  \n  function _free() {\n  }\n  Module[\"_free\"] = _free;function ___cxa_free_exception(ptr) {\n      try {\n        return _free(ptr);\n      } catch(e) { // XXX FIXME\n        Module.printErr('exception during cxa_free_exception: ' + e);\n      }\n    }function ___cxa_end_catch() {\n      if (___cxa_end_catch.rethrown) {\n        ___cxa_end_catch.rethrown = false;\n        return;\n      }\n      // Clear state flag.\n      asm['setThrew'](0);\n      // Call destructor if one is registered then clear it.\n      var ptr = EXCEPTIONS.caught.pop();\n      if (ptr) {\n        EXCEPTIONS.decRef(EXCEPTIONS.deAdjust(ptr));\n        EXCEPTIONS.last = 0; // XXX in decRef?\n      }\n    }\n\n\n  function _pthread_once(ptr, func) {\n      if (!_pthread_once.seen) _pthread_once.seen = {};\n      if (ptr in _pthread_once.seen) return;\n      Runtime.dynCall('v', func);\n      _pthread_once.seen[ptr] = 1;\n    }\n\n  function ___lock() {}\n\n  function ___unlock() {}\n\n  \n  var PTHREAD_SPECIFIC={};function _pthread_getspecific(key) {\n      return PTHREAD_SPECIFIC[key] || 0;\n    }\n\n   \n  Module[\"_i64Add\"] = _i64Add;\n\n  \n  var PTHREAD_SPECIFIC_NEXT_KEY=1;function _pthread_key_create(key, destructor) {\n      if (key == 0) {\n        return ERRNO_CODES.EINVAL;\n      }\n      HEAP32[((key)>>2)]=PTHREAD_SPECIFIC_NEXT_KEY;\n      // values start at 0\n      PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;\n      PTHREAD_SPECIFIC_NEXT_KEY++;\n      return 0;\n    }\n\n  \n  function __exit(status) {\n      // void _exit(int status);\n      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html\n      Module['exit'](status);\n    }function _exit(status) {\n      __exit(status);\n    }\n\n  function _pthread_setspecific(key, value) {\n      if (!(key in PTHREAD_SPECIFIC)) {\n        return ERRNO_CODES.EINVAL;\n      }\n      PTHREAD_SPECIFIC[key] = value;\n      return 0;\n    }\n\n  \n  function _malloc(bytes) {\n      /* Over-allocate to make sure it is byte-aligned by 8.\n       * This will leak memory, but this is only the dummy\n       * implementation (replaced by dlmalloc normally) so\n       * not an issue.\n       */\n      var ptr = Runtime.dynamicAlloc(bytes + 8);\n      return (ptr+8) & 0xFFFFFFF8;\n    }\n  Module[\"_malloc\"] = _malloc;function ___cxa_allocate_exception(size) {\n      return _malloc(size);\n    }\n\n  \n  \n  \n  var ERRNO_MESSAGES={0:\"Success\",1:\"Not super-user\",2:\"No such file or directory\",3:\"No such process\",4:\"Interrupted system call\",5:\"I/O error\",6:\"No such device or address\",7:\"Arg list too long\",8:\"Exec format error\",9:\"Bad file number\",10:\"No children\",11:\"No more processes\",12:\"Not enough core\",13:\"Permission denied\",14:\"Bad address\",15:\"Block device required\",16:\"Mount device busy\",17:\"File exists\",18:\"Cross-device link\",19:\"No such device\",20:\"Not a directory\",21:\"Is a directory\",22:\"Invalid argument\",23:\"Too many open files in system\",24:\"Too many open files\",25:\"Not a typewriter\",26:\"Text file busy\",27:\"File too large\",28:\"No space left on device\",29:\"Illegal seek\",30:\"Read only file system\",31:\"Too many links\",32:\"Broken pipe\",33:\"Math arg out of domain of func\",34:\"Math result not representable\",35:\"File locking deadlock error\",36:\"File or path name too long\",37:\"No record locks available\",38:\"Function not implemented\",39:\"Directory not empty\",40:\"Too many symbolic links\",42:\"No message of desired type\",43:\"Identifier removed\",44:\"Channel number out of range\",45:\"Level 2 not synchronized\",46:\"Level 3 halted\",47:\"Level 3 reset\",48:\"Link number out of range\",49:\"Protocol driver not attached\",50:\"No CSI structure available\",51:\"Level 2 halted\",52:\"Invalid exchange\",53:\"Invalid request descriptor\",54:\"Exchange full\",55:\"No anode\",56:\"Invalid request code\",57:\"Invalid slot\",59:\"Bad font file fmt\",60:\"Device not a stream\",61:\"No data (for no delay io)\",62:\"Timer expired\",63:\"Out of streams resources\",64:\"Machine is not on the network\",65:\"Package not installed\",66:\"The object is remote\",67:\"The link has been severed\",68:\"Advertise error\",69:\"Srmount error\",70:\"Communication error on send\",71:\"Protocol error\",72:\"Multihop attempted\",73:\"Cross mount point (not really error)\",74:\"Trying to read unreadable message\",75:\"Value too large for defined data type\",76:\"Given log. name not unique\",77:\"f.d. invalid for this operation\",78:\"Remote address changed\",79:\"Can   access a needed shared lib\",80:\"Accessing a corrupted shared lib\",81:\".lib section in a.out corrupted\",82:\"Attempting to link in too many libs\",83:\"Attempting to exec a shared library\",84:\"Illegal byte sequence\",86:\"Streams pipe error\",87:\"Too many users\",88:\"Socket operation on non-socket\",89:\"Destination address required\",90:\"Message too long\",91:\"Protocol wrong type for socket\",92:\"Protocol not available\",93:\"Unknown protocol\",94:\"Socket type not supported\",95:\"Not supported\",96:\"Protocol family not supported\",97:\"Address family not supported by protocol family\",98:\"Address already in use\",99:\"Address not available\",100:\"Network interface is not configured\",101:\"Network is unreachable\",102:\"Connection reset by network\",103:\"Connection aborted\",104:\"Connection reset by peer\",105:\"No buffer space available\",106:\"Socket is already connected\",107:\"Socket is not connected\",108:\"Can't send after socket shutdown\",109:\"Too many references\",110:\"Connection timed out\",111:\"Connection refused\",112:\"Host is down\",113:\"Host is unreachable\",114:\"Socket already connected\",115:\"Connection already in progress\",116:\"Stale file handle\",122:\"Quota exceeded\",123:\"No medium (in tape drive)\",125:\"Operation canceled\",130:\"Previous owner died\",131:\"State not recoverable\"};\n  \n  var PATH={splitPath:function (filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },normalizeArray:function (parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up--; up) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },normalize:function (path) {\n        var isAbsolute = path.charAt(0) === '/',\n            trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter(function(p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },dirname:function (path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },basename:function (path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash+1);\n      },extname:function (path) {\n        return PATH.splitPath(path)[3];\n      },join:function () {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join('/'));\n      },join2:function (l, r) {\n        return PATH.normalize(l + '/' + r);\n      },resolve:function () {\n        var resolvedPath = '',\n          resolvedAbsolute = false;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = (i >= 0) ? arguments[i] : FS.cwd();\n          // Skip empty and invalid entries\n          if (typeof path !== 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            return ''; // an invalid portion invalidates the whole thing\n          }\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = path.charAt(0) === '/';\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {\n          return !!p;\n        }), !resolvedAbsolute).join('/');\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n      },relative:function (from, to) {\n        from = PATH.resolve(from).substr(1);\n        to = PATH.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      }};\n  \n  var TTY={ttys:[],init:function () {\n        // https://github.com/kripken/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n        //   // with text files until FS.init can be refactored.\n        //   process['stdin']['setEncoding']('utf8');\n        // }\n      },shutdown:function () {\n        // https://github.com/kripken/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\n        //   process['stdin']['pause']();\n        // }\n      },register:function (dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },stream_ops:{open:function (stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },close:function (stream) {\n          // flush any pending line data\n          stream.tty.ops.flush(stream.tty);\n        },flush:function (stream) {\n          stream.tty.ops.flush(stream.tty);\n        },read:function (stream, buffer, offset, length, pos /* ignored */) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset+i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },write:function (stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\n          }\n          for (var i = 0; i < length; i++) {\n            try {\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\n            } catch (e) {\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\n            }\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }},default_tty_ops:{get_char:function (tty) {\n          if (!tty.input.length) {\n            var result = null;\n            if (ENVIRONMENT_IS_NODE) {\n              // we will read data by chunks of BUFSIZE\n              var BUFSIZE = 256;\n              var buf = new Buffer(BUFSIZE);\n              var bytesRead = 0;\n  \n              var fd = process.stdin.fd;\n              // Linux and Mac cannot use process.stdin.fd (which isn't set up as sync)\n              var usingDevice = false;\n              try {\n                fd = fs.openSync('/dev/stdin', 'r');\n                usingDevice = true;\n              } catch (e) {}\n  \n              bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);\n  \n              if (usingDevice) { fs.closeSync(fd); }\n              if (bytesRead > 0) {\n                result = buf.slice(0, bytesRead).toString('utf-8');\n              } else {\n                result = null;\n              }\n  \n            } else if (typeof window != 'undefined' &&\n              typeof window.prompt == 'function') {\n              // Browser.\n              result = window.prompt('Input: ');  // returns null on cancel\n              if (result !== null) {\n                result += '\\n';\n              }\n            } else if (typeof readline == 'function') {\n              // Command line.\n              result = readline();\n              if (result !== null) {\n                result += '\\n';\n              }\n            }\n            if (!result) {\n              return null;\n            }\n            tty.input = intArrayFromString(result, true);\n          }\n          return tty.input.shift();\n        },put_char:function (tty, val) {\n          if (val === null || val === 10) {\n            Module['print'](UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\n          }\n        },flush:function (tty) {\n          if (tty.output && tty.output.length > 0) {\n            Module['print'](UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }},default_tty1_ops:{put_char:function (tty, val) {\n          if (val === null || val === 10) {\n            Module['printErr'](UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },flush:function (tty) {\n          if (tty.output && tty.output.length > 0) {\n            Module['printErr'](UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }}};\n  \n  var MEMFS={ops_table:null,mount:function (mount) {\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\n      },createNode:function (parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          // no supported\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek\n              }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.buffer.byteLength which gives the whole capacity.\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n          node.contents = null; \n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        // add the new node to the parent\n        if (parent) {\n          parent.contents[name] = node;\n        }\n        return node;\n      },getFileDataAsRegularArray:function (node) {\n        if (node.contents && node.contents.subarray) {\n          var arr = [];\n          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\n          return arr; // Returns a copy of the original data.\n        }\n        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.\n      },getFileDataAsTypedArray:function (node) {\n        if (!node.contents) return new Uint8Array;\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n        return new Uint8Array(node.contents);\n      },expandFileStorage:function (node, newCapacity) {\n        // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file\n        // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to\n        // increase the size.\n        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {\n          node.contents = MEMFS.getFileDataAsRegularArray(node);\n          node.usedBytes = node.contents.length; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it.\n        }\n  \n        if (!node.contents || node.contents.subarray) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well.\n          var prevCapacity = node.contents ? node.contents.buffer.byteLength : 0;\n          if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n          // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n          // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n          // avoid overshooting the allocation cap by a very large margin.\n          var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n          newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0);\n          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n          return;\n        }\n        // Not using a typed array to back the file storage. Use a standard JS array instead.\n        if (!node.contents && newCapacity > 0) node.contents = [];\n        while (node.contents.length < newCapacity) node.contents.push(0);\n      },resizeFileStorage:function (node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null; // Fully decommit when requesting a resize to zero.\n          node.usedBytes = 0;\n          return;\n        }\n        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n          }\n          node.usedBytes = newSize;\n          return;\n        }\n        // Backing with a JS array.\n        if (!node.contents) node.contents = [];\n        if (node.contents.length > newSize) node.contents.length = newSize;\n        else while (node.contents.length < newSize) node.contents.push(0);\n        node.usedBytes = newSize;\n      },node_ops:{getattr:function (node) {\n          var attr = {};\n          // device numbers reuse inode numbers.\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n          //       but this is not required by the standard.\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },setattr:function (node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },lookup:function (parent, name) {\n          throw FS.genericErrors[ERRNO_CODES.ENOENT];\n        },mknod:function (parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },rename:function (old_node, new_dir, new_name) {\n          // if we're overwriting a directory at new_name, make sure it's empty.\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {\n            }\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n              }\n            }\n          }\n          // do the internal rewiring\n          delete old_node.parent.contents[old_node.name];\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          old_node.parent = new_dir;\n        },unlink:function (parent, name) {\n          delete parent.contents[name];\n        },rmdir:function (parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n          }\n          delete parent.contents[name];\n        },readdir:function (node) {\n          var entries = ['.', '..']\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n            entries.push(key);\n          }\n          return entries;\n        },symlink:function (parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },readlink:function (node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n          return node.link;\n        }},stream_ops:{read:function (stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          assert(size >= 0);\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },write:function (stream, buffer, offset, length, position, canOwn) {\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n  \n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\n            if (canOwn) { // Can we just reuse the buffer we are given?\n              assert(position === 0, 'canOwn must imply no weird position inside the file');\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\n              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n  \n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n          MEMFS.expandFileStorage(node, position+length);\n          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.\n          else {\n            for (var i = 0; i < length; i++) {\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position+length);\n          return length;\n        },llseek:function (stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {  // SEEK_CUR.\n            position += stream.position;\n          } else if (whence === 2) {  // SEEK_END.\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n          return position;\n        },allocate:function (stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },mmap:function (stream, buffer, offset, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          // Only make a new copy when MAP_PRIVATE is specified.\n          if ( !(flags & 2) &&\n                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {\n            // We can't emulate MAP_SHARED when the file is not backed by the buffer\n            // we're mapping to (e.g. the HEAP buffer).\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            // Try to avoid unnecessary slices.\n            if (position > 0 || position + length < stream.node.usedBytes) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n            allocated = true;\n            ptr = _malloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);\n            }\n            buffer.set(contents, ptr);\n          }\n          return { ptr: ptr, allocated: allocated };\n        },msync:function (stream, buffer, offset, length, mmapFlags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n          }\n          if (mmapFlags & 2) {\n            // MAP_PRIVATE calls need not to be synced back to underlying fs\n            return 0;\n          }\n  \n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          // should we check if bytesWritten and length are the same?\n          return 0;\n        }}};\n  \n  var IDBFS={dbs:{},indexedDB:function () {\n        if (typeof indexedDB !== 'undefined') return indexedDB;\n        var ret = null;\n        if (typeof window === 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n        assert(ret, 'IDBFS used, but indexedDB not supported');\n        return ret;\n      },DB_VERSION:21,DB_STORE_NAME:\"FILE_DATA\",mount:function (mount) {\n        // reuse all of the core MEMFS functionality\n        return MEMFS.mount.apply(null, arguments);\n      },syncfs:function (mount, populate, callback) {\n        IDBFS.getLocalSet(mount, function(err, local) {\n          if (err) return callback(err);\n  \n          IDBFS.getRemoteSet(mount, function(err, remote) {\n            if (err) return callback(err);\n  \n            var src = populate ? remote : local;\n            var dst = populate ? local : remote;\n  \n            IDBFS.reconcile(src, dst, callback);\n          });\n        });\n      },getDB:function (name, callback) {\n        // check the cache first\n        var db = IDBFS.dbs[name];\n        if (db) {\n          return callback(null, db);\n        }\n  \n        var req;\n        try {\n          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);\n        } catch (e) {\n          return callback(e);\n        }\n        req.onupgradeneeded = function(e) {\n          var db = e.target.result;\n          var transaction = e.target.transaction;\n  \n          var fileStore;\n  \n          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {\n            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);\n          } else {\n            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);\n          }\n  \n          if (!fileStore.indexNames.contains('timestamp')) {\n            fileStore.createIndex('timestamp', 'timestamp', { unique: false });\n          }\n        };\n        req.onsuccess = function() {\n          db = req.result;\n  \n          // add to the cache\n          IDBFS.dbs[name] = db;\n          callback(null, db);\n        };\n        req.onerror = function(e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },getLocalSet:function (mount, callback) {\n        var entries = {};\n  \n        function isRealDir(p) {\n          return p !== '.' && p !== '..';\n        };\n        function toAbsolute(root) {\n          return function(p) {\n            return PATH.join2(root, p);\n          }\n        };\n  \n        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));\n  \n        while (check.length) {\n          var path = check.pop();\n          var stat;\n  \n          try {\n            stat = FS.stat(path);\n          } catch (e) {\n            return callback(e);\n          }\n  \n          if (FS.isDir(stat.mode)) {\n            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));\n          }\n  \n          entries[path] = { timestamp: stat.mtime };\n        }\n  \n        return callback(null, { type: 'local', entries: entries });\n      },getRemoteSet:function (mount, callback) {\n        var entries = {};\n  \n        IDBFS.getDB(mount.mountpoint, function(err, db) {\n          if (err) return callback(err);\n  \n          var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');\n          transaction.onerror = function(e) {\n            callback(this.error);\n            e.preventDefault();\n          };\n  \n          var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n          var index = store.index('timestamp');\n  \n          index.openKeyCursor().onsuccess = function(event) {\n            var cursor = event.target.result;\n  \n            if (!cursor) {\n              return callback(null, { type: 'remote', db: db, entries: entries });\n            }\n  \n            entries[cursor.primaryKey] = { timestamp: cursor.key };\n  \n            cursor.continue();\n          };\n        });\n      },loadLocalEntry:function (path, callback) {\n        var stat, node;\n  \n        try {\n          var lookup = FS.lookupPath(path);\n          node = lookup.node;\n          stat = FS.stat(path);\n        } catch (e) {\n          return callback(e);\n        }\n  \n        if (FS.isDir(stat.mode)) {\n          return callback(null, { timestamp: stat.mtime, mode: stat.mode });\n        } else if (FS.isFile(stat.mode)) {\n          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.\n          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.\n          node.contents = MEMFS.getFileDataAsTypedArray(node);\n          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });\n        } else {\n          return callback(new Error('node type not supported'));\n        }\n      },storeLocalEntry:function (path, entry, callback) {\n        try {\n          if (FS.isDir(entry.mode)) {\n            FS.mkdir(path, entry.mode);\n          } else if (FS.isFile(entry.mode)) {\n            FS.writeFile(path, entry.contents, { encoding: 'binary', canOwn: true });\n          } else {\n            return callback(new Error('node type not supported'));\n          }\n  \n          FS.chmod(path, entry.mode);\n          FS.utime(path, entry.timestamp, entry.timestamp);\n        } catch (e) {\n          return callback(e);\n        }\n  \n        callback(null);\n      },removeLocalEntry:function (path, callback) {\n        try {\n          var lookup = FS.lookupPath(path);\n          var stat = FS.stat(path);\n  \n          if (FS.isDir(stat.mode)) {\n            FS.rmdir(path);\n          } else if (FS.isFile(stat.mode)) {\n            FS.unlink(path);\n          }\n        } catch (e) {\n          return callback(e);\n        }\n  \n        callback(null);\n      },loadRemoteEntry:function (store, path, callback) {\n        var req = store.get(path);\n        req.onsuccess = function(event) { callback(null, event.target.result); };\n        req.onerror = function(e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },storeRemoteEntry:function (store, path, entry, callback) {\n        var req = store.put(entry, path);\n        req.onsuccess = function() { callback(null); };\n        req.onerror = function(e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },removeRemoteEntry:function (store, path, callback) {\n        var req = store.delete(path);\n        req.onsuccess = function() { callback(null); };\n        req.onerror = function(e) {\n          callback(this.error);\n          e.preventDefault();\n        };\n      },reconcile:function (src, dst, callback) {\n        var total = 0;\n  \n        var create = [];\n        Object.keys(src.entries).forEach(function (key) {\n          var e = src.entries[key];\n          var e2 = dst.entries[key];\n          if (!e2 || e.timestamp > e2.timestamp) {\n            create.push(key);\n            total++;\n          }\n        });\n  \n        var remove = [];\n        Object.keys(dst.entries).forEach(function (key) {\n          var e = dst.entries[key];\n          var e2 = src.entries[key];\n          if (!e2) {\n            remove.push(key);\n            total++;\n          }\n        });\n  \n        if (!total) {\n          return callback(null);\n        }\n  \n        var errored = false;\n        var completed = 0;\n        var db = src.type === 'remote' ? src.db : dst.db;\n        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');\n        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\n  \n        function done(err) {\n          if (err) {\n            if (!done.errored) {\n              done.errored = true;\n              return callback(err);\n            }\n            return;\n          }\n          if (++completed >= total) {\n            return callback(null);\n          }\n        };\n  \n        transaction.onerror = function(e) {\n          done(this.error);\n          e.preventDefault();\n        };\n  \n        // sort paths in ascending order so directory entries are created\n        // before the files inside them\n        create.sort().forEach(function (path) {\n          if (dst.type === 'local') {\n            IDBFS.loadRemoteEntry(store, path, function (err, entry) {\n              if (err) return done(err);\n              IDBFS.storeLocalEntry(path, entry, done);\n            });\n          } else {\n            IDBFS.loadLocalEntry(path, function (err, entry) {\n              if (err) return done(err);\n              IDBFS.storeRemoteEntry(store, path, entry, done);\n            });\n          }\n        });\n  \n        // sort paths in descending order so files are deleted before their\n        // parent directories\n        remove.sort().reverse().forEach(function(path) {\n          if (dst.type === 'local') {\n            IDBFS.removeLocalEntry(path, done);\n          } else {\n            IDBFS.removeRemoteEntry(store, path, done);\n          }\n        });\n      }};\n  \n  var NODEFS={isWindows:false,staticInit:function () {\n        NODEFS.isWindows = !!process.platform.match(/^win/);\n      },mount:function (mount) {\n        assert(ENVIRONMENT_IS_NODE);\n        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);\n      },createNode:function (parent, name, mode, dev) {\n        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var node = FS.createNode(parent, name, mode);\n        node.node_ops = NODEFS.node_ops;\n        node.stream_ops = NODEFS.stream_ops;\n        return node;\n      },getMode:function (path) {\n        var stat;\n        try {\n          stat = fs.lstatSync(path);\n          if (NODEFS.isWindows) {\n            // On Windows, directories return permission bits 'rw-rw-rw-', even though they have 'rwxrwxrwx', so\n            // propagate write bits to execute bits.\n            stat.mode = stat.mode | ((stat.mode & 146) >> 1);\n          }\n        } catch (e) {\n          if (!e.code) throw e;\n          throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n        }\n        return stat.mode;\n      },realPath:function (node) {\n        var parts = [];\n        while (node.parent !== node) {\n          parts.push(node.name);\n          node = node.parent;\n        }\n        parts.push(node.mount.opts.root);\n        parts.reverse();\n        return PATH.join.apply(null, parts);\n      },flagsToPermissionStringMap:{0:\"r\",1:\"r+\",2:\"r+\",64:\"r\",65:\"r+\",66:\"r+\",129:\"rx+\",193:\"rx+\",514:\"w+\",577:\"w\",578:\"w+\",705:\"wx\",706:\"wx+\",1024:\"a\",1025:\"a\",1026:\"a+\",1089:\"a\",1090:\"a+\",1153:\"ax\",1154:\"ax+\",1217:\"ax\",1218:\"ax+\",4096:\"rs\",4098:\"rs+\"},flagsToPermissionString:function (flags) {\n        flags &= ~0100000 /*O_LARGEFILE*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\n        flags &= ~02000000 /*O_CLOEXEC*/; // Some applications may pass it; it makes no sense for a single process.\n        if (flags in NODEFS.flagsToPermissionStringMap) {\n          return NODEFS.flagsToPermissionStringMap[flags];\n        } else {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n      },node_ops:{getattr:function (node) {\n          var path = NODEFS.realPath(node);\n          var stat;\n          try {\n            stat = fs.lstatSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.\n          // See http://support.microsoft.com/kb/140365\n          if (NODEFS.isWindows && !stat.blksize) {\n            stat.blksize = 4096;\n          }\n          if (NODEFS.isWindows && !stat.blocks) {\n            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;\n          }\n          return {\n            dev: stat.dev,\n            ino: stat.ino,\n            mode: stat.mode,\n            nlink: stat.nlink,\n            uid: stat.uid,\n            gid: stat.gid,\n            rdev: stat.rdev,\n            size: stat.size,\n            atime: stat.atime,\n            mtime: stat.mtime,\n            ctime: stat.ctime,\n            blksize: stat.blksize,\n            blocks: stat.blocks\n          };\n        },setattr:function (node, attr) {\n          var path = NODEFS.realPath(node);\n          try {\n            if (attr.mode !== undefined) {\n              fs.chmodSync(path, attr.mode);\n              // update the common node structure mode as well\n              node.mode = attr.mode;\n            }\n            if (attr.timestamp !== undefined) {\n              var date = new Date(attr.timestamp);\n              fs.utimesSync(path, date, date);\n            }\n            if (attr.size !== undefined) {\n              fs.truncateSync(path, attr.size);\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },lookup:function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n          var mode = NODEFS.getMode(path);\n          return NODEFS.createNode(parent, name, mode);\n        },mknod:function (parent, name, mode, dev) {\n          var node = NODEFS.createNode(parent, name, mode, dev);\n          // create the backing node for this in the fs root as well\n          var path = NODEFS.realPath(node);\n          try {\n            if (FS.isDir(node.mode)) {\n              fs.mkdirSync(path, node.mode);\n            } else {\n              fs.writeFileSync(path, '', { mode: node.mode });\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n          return node;\n        },rename:function (oldNode, newDir, newName) {\n          var oldPath = NODEFS.realPath(oldNode);\n          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);\n          try {\n            fs.renameSync(oldPath, newPath);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },unlink:function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n          try {\n            fs.unlinkSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },rmdir:function (parent, name) {\n          var path = PATH.join2(NODEFS.realPath(parent), name);\n          try {\n            fs.rmdirSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },readdir:function (node) {\n          var path = NODEFS.realPath(node);\n          try {\n            return fs.readdirSync(path);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },symlink:function (parent, newName, oldPath) {\n          var newPath = PATH.join2(NODEFS.realPath(parent), newName);\n          try {\n            fs.symlinkSync(oldPath, newPath);\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },readlink:function (node) {\n          var path = NODEFS.realPath(node);\n          try {\n            path = fs.readlinkSync(path);\n            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);\n            return path;\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        }},stream_ops:{open:function (stream) {\n          var path = NODEFS.realPath(stream.node);\n          try {\n            if (FS.isFile(stream.node.mode)) {\n              stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },close:function (stream) {\n          try {\n            if (FS.isFile(stream.node.mode) && stream.nfd) {\n              fs.closeSync(stream.nfd);\n            }\n          } catch (e) {\n            if (!e.code) throw e;\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n        },read:function (stream, buffer, offset, length, position) {\n          if (length === 0) return 0; // node errors on 0 length reads\n          // FIXME this is terrible.\n          var nbuffer = new Buffer(length);\n          var res;\n          try {\n            res = fs.readSync(stream.nfd, nbuffer, 0, length, position);\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n          if (res > 0) {\n            for (var i = 0; i < res; i++) {\n              buffer[offset + i] = nbuffer[i];\n            }\n          }\n          return res;\n        },write:function (stream, buffer, offset, length, position) {\n          // FIXME this is terrible.\n          var nbuffer = new Buffer(buffer.subarray(offset, offset + length));\n          var res;\n          try {\n            res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);\n          } catch (e) {\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n          }\n          return res;\n        },llseek:function (stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {  // SEEK_CUR.\n            position += stream.position;\n          } else if (whence === 2) {  // SEEK_END.\n            if (FS.isFile(stream.node.mode)) {\n              try {\n                var stat = fs.fstatSync(stream.nfd);\n                position += stat.size;\n              } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n              }\n            }\n          }\n  \n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n  \n          return position;\n        }}};\n  \n  var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:function (mount) {\n        assert(ENVIRONMENT_IS_WORKER);\n        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();\n        var root = WORKERFS.createNode(null, '/', WORKERFS.DIR_MODE, 0);\n        var createdParents = {};\n        function ensureParent(path) {\n          // return the parent node, creating subdirs as necessary\n          var parts = path.split('/');\n          var parent = root;\n          for (var i = 0; i < parts.length-1; i++) {\n            var curr = parts.slice(0, i+1).join('/');\n            if (!createdParents[curr]) {\n              createdParents[curr] = WORKERFS.createNode(parent, curr, WORKERFS.DIR_MODE, 0);\n            }\n            parent = createdParents[curr];\n          }\n          return parent;\n        }\n        function base(path) {\n          var parts = path.split('/');\n          return parts[parts.length-1];\n        }\n        // We also accept FileList here, by using Array.prototype\n        Array.prototype.forEach.call(mount.opts[\"files\"] || [], function(file) {\n          WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);\n        });\n        (mount.opts[\"blobs\"] || []).forEach(function(obj) {\n          WORKERFS.createNode(ensureParent(obj[\"name\"]), base(obj[\"name\"]), WORKERFS.FILE_MODE, 0, obj[\"data\"]);\n        });\n        (mount.opts[\"packages\"] || []).forEach(function(pack) {\n          pack['metadata'].files.forEach(function(file) {\n            var name = file.filename.substr(1); // remove initial slash\n            WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack['blob'].slice(file.start, file.end));\n          });\n        });\n        return root;\n      },createNode:function (parent, name, mode, dev, contents, mtime) {\n        var node = FS.createNode(parent, name, mode);\n        node.mode = mode;\n        node.node_ops = WORKERFS.node_ops;\n        node.stream_ops = WORKERFS.stream_ops;\n        node.timestamp = (mtime || new Date).getTime();\n        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\n        if (mode === WORKERFS.FILE_MODE) {\n          node.size = contents.size;\n          node.contents = contents;\n        } else {\n          node.size = 4096;\n          node.contents = {};\n        }\n        if (parent) {\n          parent.contents[name] = node;\n        }\n        return node;\n      },node_ops:{getattr:function (node) {\n          return {\n            dev: 1,\n            ino: undefined,\n            mode: node.mode,\n            nlink: 1,\n            uid: 0,\n            gid: 0,\n            rdev: undefined,\n            size: node.size,\n            atime: new Date(node.timestamp),\n            mtime: new Date(node.timestamp),\n            ctime: new Date(node.timestamp),\n            blksize: 4096,\n            blocks: Math.ceil(node.size / 4096),\n          };\n        },setattr:function (node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n        },lookup:function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        },mknod:function (parent, name, mode, dev) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },rename:function (oldNode, newDir, newName) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },unlink:function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },rmdir:function (parent, name) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },readdir:function (node) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },symlink:function (parent, newName, oldPath) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        },readlink:function (node) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }},stream_ops:{read:function (stream, buffer, offset, length, position) {\n          if (position >= stream.node.size) return 0;\n          var chunk = stream.node.contents.slice(position, position + length);\n          var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\n          buffer.set(new Uint8Array(ab), offset);\n          return chunk.size;\n        },write:function (stream, buffer, offset, length, position) {\n          throw new FS.ErrnoError(ERRNO_CODES.EIO);\n        },llseek:function (stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {  // SEEK_CUR.\n            position += stream.position;\n          } else if (whence === 2) {  // SEEK_END.\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.size;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n          }\n          return position;\n        }}};\n  \n  var _stdin=STATICTOP; STATICTOP += 16;;\n  \n  var _stdout=STATICTOP; STATICTOP += 16;;\n  \n  var _stderr=STATICTOP; STATICTOP += 16;;var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function (e) {\n        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();\n        return ___setErrNo(e.errno);\n      },lookupPath:function (path, opts) {\n        path = PATH.resolve(FS.cwd(), path);\n        opts = opts || {};\n  \n        if (!path) return { path: '', node: null };\n  \n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        for (var key in defaults) {\n          if (opts[key] === undefined) {\n            opts[key] = defaults[key];\n          }\n        }\n  \n        if (opts.recurse_count > 8) {  // max recursive lookup of 8\n          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);\n        }\n  \n        // split the path\n        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {\n          return !!p;\n        }), false);\n  \n        // start at the root\n        var current = FS.root;\n        var current_path = '/';\n  \n        for (var i = 0; i < parts.length; i++) {\n          var islast = (i === parts.length-1);\n          if (islast && opts.parent) {\n            // stop resolving\n            break;\n          }\n  \n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n  \n          // jump to the mount's root node if this is a mountpoint\n          if (FS.isMountpoint(current)) {\n            if (!islast || (islast && opts.follow_mount)) {\n              current = current.mounted.root;\n            }\n          }\n  \n          // by default, lookupPath will not follow a symlink if it is the final path component.\n          // setting opts.follow = true will override this behavior.\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH.resolve(PATH.dirname(current_path), link);\n  \n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });\n              current = lookup.node;\n  \n              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\n                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);\n              }\n            }\n          }\n        }\n  \n        return { path: current_path, node: current };\n      },getPath:function (node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;\n          }\n          path = path ? node.name + '/' + path : node.name;\n          node = node.parent;\n        }\n      },hashName:function (parentid, name) {\n        var hash = 0;\n  \n  \n        for (var i = 0; i < name.length; i++) {\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n        }\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\n      },hashAddNode:function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },hashRemoveNode:function (node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },lookupNode:function (parent, name) {\n        var err = FS.mayLookup(parent);\n        if (err) {\n          throw new FS.ErrnoError(err, parent);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        // if we failed to find it in the cache, call into the VFS\n        return FS.lookup(parent, name);\n      },createNode:function (parent, name, mode, rdev) {\n        if (!FS.FSNode) {\n          FS.FSNode = function(parent, name, mode, rdev) {\n            if (!parent) {\n              parent = this;  // root node sets parent to itself\n            }\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n          };\n  \n          FS.FSNode.prototype = {};\n  \n          // compatibility\n          var readMode = 292 | 73;\n          var writeMode = 146;\n  \n          // NOTE we must use Object.defineProperties instead of individual calls to\n          // Object.defineProperty in order to make closure compiler happy\n          Object.defineProperties(FS.FSNode.prototype, {\n            read: {\n              get: function() { return (this.mode & readMode) === readMode; },\n              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }\n            },\n            write: {\n              get: function() { return (this.mode & writeMode) === writeMode; },\n              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }\n            },\n            isFolder: {\n              get: function() { return FS.isDir(this.mode); }\n            },\n            isDevice: {\n              get: function() { return FS.isChrdev(this.mode); }\n            }\n          });\n        }\n  \n        var node = new FS.FSNode(parent, name, mode, rdev);\n  \n        FS.hashAddNode(node);\n  \n        return node;\n      },destroyNode:function (node) {\n        FS.hashRemoveNode(node);\n      },isRoot:function (node) {\n        return node === node.parent;\n      },isMountpoint:function (node) {\n        return !!node.mounted;\n      },isFile:function (mode) {\n        return (mode & 61440) === 32768;\n      },isDir:function (mode) {\n        return (mode & 61440) === 16384;\n      },isLink:function (mode) {\n        return (mode & 61440) === 40960;\n      },isChrdev:function (mode) {\n        return (mode & 61440) === 8192;\n      },isBlkdev:function (mode) {\n        return (mode & 61440) === 24576;\n      },isFIFO:function (mode) {\n        return (mode & 61440) === 4096;\n      },isSocket:function (mode) {\n        return (mode & 49152) === 49152;\n      },flagModes:{\"r\":0,\"rs\":1052672,\"r+\":2,\"w\":577,\"wx\":705,\"xw\":705,\"w+\":578,\"wx+\":706,\"xw+\":706,\"a\":1089,\"ax\":1217,\"xa\":1217,\"a+\":1090,\"ax+\":1218,\"xa+\":1218},modeStringToFlags:function (str) {\n        var flags = FS.flagModes[str];\n        if (typeof flags === 'undefined') {\n          throw new Error('Unknown file open mode: ' + str);\n        }\n        return flags;\n      },flagsToPermissionString:function (flag) {\n        var perms = ['r', 'w', 'rw'][flag & 3];\n        if ((flag & 512)) {\n          perms += 'w';\n        }\n        return perms;\n      },nodePermissions:function (node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        // return 0 if any user, group or owner bits are set.\n        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {\n          return ERRNO_CODES.EACCES;\n        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {\n          return ERRNO_CODES.EACCES;\n        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {\n          return ERRNO_CODES.EACCES;\n        }\n        return 0;\n      },mayLookup:function (dir) {\n        var err = FS.nodePermissions(dir, 'x');\n        if (err) return err;\n        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;\n        return 0;\n      },mayCreate:function (dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return ERRNO_CODES.EEXIST;\n        } catch (e) {\n        }\n        return FS.nodePermissions(dir, 'wx');\n      },mayDelete:function (dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var err = FS.nodePermissions(dir, 'wx');\n        if (err) {\n          return err;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return ERRNO_CODES.ENOTDIR;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return ERRNO_CODES.EBUSY;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return ERRNO_CODES.EISDIR;\n          }\n        }\n        return 0;\n      },mayOpen:function (node, flags) {\n        if (!node) {\n          return ERRNO_CODES.ENOENT;\n        }\n        if (FS.isLink(node.mode)) {\n          return ERRNO_CODES.ELOOP;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\n              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\n            return ERRNO_CODES.EISDIR;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {\n        fd_start = fd_start || 0;\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);\n      },getStream:function (fd) {\n        return FS.streams[fd];\n      },createStream:function (stream, fd_start, fd_end) {\n        if (!FS.FSStream) {\n          FS.FSStream = function(){};\n          FS.FSStream.prototype = {};\n          // compatibility\n          Object.defineProperties(FS.FSStream.prototype, {\n            object: {\n              get: function() { return this.node; },\n              set: function(val) { this.node = val; }\n            },\n            isRead: {\n              get: function() { return (this.flags & 2097155) !== 1; }\n            },\n            isWrite: {\n              get: function() { return (this.flags & 2097155) !== 0; }\n            },\n            isAppend: {\n              get: function() { return (this.flags & 1024); }\n            }\n          });\n        }\n        // clone it, so we can return an instance of FSStream\n        var newStream = new FS.FSStream();\n        for (var p in stream) {\n          newStream[p] = stream[p];\n        }\n        stream = newStream;\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },closeStream:function (fd) {\n        FS.streams[fd] = null;\n      },chrdev_stream_ops:{open:function (stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          // override node's stream ops with the device's\n          stream.stream_ops = device.stream_ops;\n          // forward the open call\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },llseek:function () {\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n        }},major:function (dev) {\n        return ((dev) >> 8);\n      },minor:function (dev) {\n        return ((dev) & 0xff);\n      },makedev:function (ma, mi) {\n        return ((ma) << 8 | (mi));\n      },registerDevice:function (dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },getDevice:function (dev) {\n        return FS.devices[dev];\n      },getMounts:function (mount) {\n        var mounts = [];\n        var check = [mount];\n  \n        while (check.length) {\n          var m = check.pop();\n  \n          mounts.push(m);\n  \n          check.push.apply(check, m.mounts);\n        }\n  \n        return mounts;\n      },syncfs:function (populate, callback) {\n        if (typeof(populate) === 'function') {\n          callback = populate;\n          populate = false;\n        }\n  \n        FS.syncFSRequests++;\n  \n        if (FS.syncFSRequests > 1) {\n          console.log('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');\n        }\n  \n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n  \n        function doCallback(err) {\n          assert(FS.syncFSRequests > 0);\n          FS.syncFSRequests--;\n          return callback(err);\n        }\n  \n        function done(err) {\n          if (err) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(err);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        };\n  \n        // sync all mounts\n        mounts.forEach(function (mount) {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },mount:function (type, opts, mountpoint) {\n        var root = mountpoint === '/';\n        var pseudo = !mountpoint;\n        var node;\n  \n        if (root && FS.root) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n          mountpoint = lookup.path;  // use the absolute path\n          node = lookup.node;\n  \n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n          }\n  \n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n          }\n        }\n  \n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n  \n        // create a root node for the fs\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n  \n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          // set as a mountpoint\n          node.mounted = mount;\n  \n          // add the new mount to the current mount's children\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n  \n        return mountRoot;\n      },unmount:function (mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n  \n        // destroy the nodes for this mount, and all its child mounts\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n  \n        Object.keys(FS.nameTable).forEach(function (hash) {\n          var current = FS.nameTable[hash];\n  \n          while (current) {\n            var next = current.name_next;\n  \n            if (mounts.indexOf(current.mount) !== -1) {\n              FS.destroyNode(current);\n            }\n  \n            current = next;\n          }\n        });\n  \n        // no longer a mountpoint\n        node.mounted = null;\n  \n        // remove this mount from the child mounts\n        var idx = node.mount.mounts.indexOf(mount);\n        assert(idx !== -1);\n        node.mount.mounts.splice(idx, 1);\n      },lookup:function (parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },mknod:function (path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === '.' || name === '..') {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var err = FS.mayCreate(parent, name);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },create:function (path, mode) {\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },mkdir:function (path, mode) {\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },mkdev:function (path, mode, dev) {\n        if (typeof(dev) === 'undefined') {\n          dev = mode;\n          mode = 438 /* 0666 */;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },symlink:function (oldpath, newpath) {\n        if (!PATH.resolve(oldpath)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        var newname = PATH.basename(newpath);\n        var err = FS.mayCreate(parent, newname);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },rename:function (old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        // parents must exist\n        var lookup, old_dir, new_dir;\n        try {\n          lookup = FS.lookupPath(old_path, { parent: true });\n          old_dir = lookup.node;\n          lookup = FS.lookupPath(new_path, { parent: true });\n          new_dir = lookup.node;\n        } catch (e) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        }\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        // need to be part of the same mount\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);\n        }\n        // source must exist\n        var old_node = FS.lookupNode(old_dir, old_name);\n        // old path should not be an ancestor of the new path\n        var relative = PATH.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        // new path should not be an ancestor of the old path\n        relative = PATH.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\n        }\n        // see if the new path already exists\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n          // not fatal\n        }\n        // early out if nothing needs to change\n        if (old_node === new_node) {\n          return;\n        }\n        // we'll need to delete the old entry\n        var isdir = FS.isDir(old_node.mode);\n        var err = FS.mayDelete(old_dir, old_name, isdir);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        // need delete permissions if we'll be overwriting.\n        // need create permissions if new doesn't already exist.\n        err = new_node ?\n          FS.mayDelete(new_dir, new_name, isdir) :\n          FS.mayCreate(new_dir, new_name);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        }\n        // if we are going to change the parent, check write permissions\n        if (new_dir !== old_dir) {\n          err = FS.nodePermissions(old_dir, 'w');\n          if (err) {\n            throw new FS.ErrnoError(err);\n          }\n        }\n        try {\n          if (FS.trackingDelegate['willMovePath']) {\n            FS.trackingDelegate['willMovePath'](old_path, new_path);\n          }\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['willMovePath']('\"+old_path+\"', '\"+new_path+\"') threw an exception: \" + e.message);\n        }\n        // remove the node from the lookup hash\n        FS.hashRemoveNode(old_node);\n        // do the underlying fs rename\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          // add the node back to the hash (in case node_ops.rename\n          // changed its name)\n          FS.hashAddNode(old_node);\n        }\n        try {\n          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onMovePath']('\"+old_path+\"', '\"+new_path+\"') threw an exception: \" + e.message);\n        }\n      },rmdir:function (path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, true);\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        }\n        try {\n          if (FS.trackingDelegate['willDeletePath']) {\n            FS.trackingDelegate['willDeletePath'](path);\n          }\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['willDeletePath']('\"+path+\"') threw an exception: \" + e.message);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n        try {\n          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onDeletePath']('\"+path+\"') threw an exception: \" + e.message);\n        }\n      },readdir:function (path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n        }\n        return node.node_ops.readdir(node);\n      },unlink:function (path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var err = FS.mayDelete(parent, name, false);\n        if (err) {\n          // POSIX says unlink should set EPERM, not EISDIR\n          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;\n          throw new FS.ErrnoError(err);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\n        }\n        try {\n          if (FS.trackingDelegate['willDeletePath']) {\n            FS.trackingDelegate['willDeletePath'](path);\n          }\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['willDeletePath']('\"+path+\"') threw an exception: \" + e.message);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n        try {\n          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onDeletePath']('\"+path+\"') threw an exception: \" + e.message);\n        }\n      },readlink:function (path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },stat:function (path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        return node.node_ops.getattr(node);\n      },lstat:function (path) {\n        return FS.stat(path, true);\n      },chmod:function (path, mode, dontFollow) {\n        var node;\n        if (typeof path === 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        node.node_ops.setattr(node, {\n          mode: (mode & 4095) | (node.mode & ~4095),\n          timestamp: Date.now()\n        });\n      },lchmod:function (path, mode) {\n        FS.chmod(path, mode, true);\n      },fchmod:function (fd, mode) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        FS.chmod(stream.node, mode);\n      },chown:function (path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path === 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n          // we ignore the uid / gid for now\n        });\n      },lchown:function (path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },fchown:function (fd, uid, gid) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        FS.chown(stream.node, uid, gid);\n      },truncate:function (path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var node;\n        if (typeof path === 'string') {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var err = FS.nodePermissions(node, 'w');\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },ftruncate:function (fd, len) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        FS.truncate(stream.node, len);\n      },utime:function (path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },open:function (path, flags, mode, fd_start, fd_end) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;\n        if ((flags & 64)) {\n          mode = (mode & 4095) | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path === 'object') {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {\n            // ignore\n          }\n        }\n        // perhaps we need to create the node\n        var created = false;\n        if ((flags & 64)) {\n          if (node) {\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\n            if ((flags & 128)) {\n              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);\n            }\n          } else {\n            // node doesn't exist, try to create it\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\n        }\n        // can't truncate a device\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        // if asked only for a directory, then this must be one\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n        }\n        // check permissions, if this is not a file we just created now (it is ok to\n        // create and write to a file with read-only permissions; it is read-only\n        // for later use)\n        if (!created) {\n          var err = FS.mayOpen(node, flags);\n          if (err) {\n            throw new FS.ErrnoError(err);\n          }\n        }\n        // do truncation if necessary\n        if ((flags & 512)) {\n          FS.truncate(node, 0);\n        }\n        // we've already handled these, don't pass down to the underlying vfs\n        flags &= ~(128 | 512);\n  \n        // register the stream with the filesystem\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),  // we want the absolute path to the node\n          flags: flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n          ungotten: [],\n          error: false\n        }, fd_start, fd_end);\n        // call the new stream's open function\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module['logReadFiles'] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n            Module['printErr']('read file: ' + path);\n          }\n        }\n        try {\n          if (FS.trackingDelegate['onOpenFile']) {\n            var trackingFlags = 0;\n            if ((flags & 2097155) !== 1) {\n              trackingFlags |= FS.tracking.openFlags.READ;\n            }\n            if ((flags & 2097155) !== 0) {\n              trackingFlags |= FS.tracking.openFlags.WRITE;\n            }\n            FS.trackingDelegate['onOpenFile'](path, trackingFlags);\n          }\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onOpenFile']('\"+path+\"', flags) threw an exception: \" + e.message);\n        }\n        return stream;\n      },close:function (stream) {\n        if (stream.getdents) stream.getdents = null; // free readdir state\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n      },llseek:function (stream, offset, whence) {\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },read:function (stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        var seeking = true;\n        if (typeof position === 'undefined') {\n          position = stream.position;\n          seeking = false;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },write:function (stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        if (stream.flags & 1024) {\n          // seek to the end before writing in append mode\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = true;\n        if (typeof position === 'undefined') {\n          position = stream.position;\n          seeking = false;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        try {\n          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);\n        } catch(e) {\n          console.log(\"FS.trackingDelegate['onWriteToFile']('\"+path+\"') threw an exception: \" + e.message);\n        }\n        return bytesWritten;\n      },allocate:function (stream, offset, length) {\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },mmap:function (stream, buffer, offset, length, position, prot, flags) {\n        // TODO if PROT is PROT_WRITE, make sure we have write access\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(ERRNO_CODES.EACCES);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\n        }\n        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);\n      },msync:function (stream, buffer, offset, length, mmapFlags) {\n        if (!stream || !stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },munmap:function (stream) {\n        return 0;\n      },ioctl:function (stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },readFile:function (path, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 'r';\n        opts.encoding = opts.encoding || 'binary';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === 'utf8') {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === 'binary') {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },writeFile:function (path, data, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 'w';\n        opts.encoding = opts.encoding || 'utf8';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (opts.encoding === 'utf8') {\n          var buf = new Uint8Array(lengthBytesUTF8(data)+1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, 0, opts.canOwn);\n        } else if (opts.encoding === 'binary') {\n          FS.write(stream, data, 0, data.length, 0, opts.canOwn);\n        }\n        FS.close(stream);\n      },cwd:function () {\n        return FS.currentPath;\n      },chdir:function (path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\n        }\n        var err = FS.nodePermissions(lookup.node, 'x');\n        if (err) {\n          throw new FS.ErrnoError(err);\n        }\n        FS.currentPath = lookup.path;\n      },createDefaultDirectories:function () {\n        FS.mkdir('/tmp');\n        FS.mkdir('/home');\n        FS.mkdir('/home/web_user');\n      },createDefaultDevices:function () {\n        // create /dev\n        FS.mkdir('/dev');\n        // setup /dev/null\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: function() { return 0; },\n          write: function(stream, buffer, offset, length, pos) { return length; }\n        });\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\n        // setup /dev/tty and /dev/tty1\n        // stderr needs to print output using Module['printErr']\n        // so we register a second tty just for it.\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n        // setup /dev/[u]random\n        var random_device;\n        if (typeof crypto !== 'undefined') {\n          // for modern web browsers\n          var randomBuffer = new Uint8Array(1);\n          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };\n        } else if (ENVIRONMENT_IS_NODE) {\n          // for nodejs\n          random_device = function() { return require('crypto').randomBytes(1)[0]; };\n        } else {\n          // default for ES5 platforms\n          random_device = function() { return (Math.random()*256)|0; };\n        }\n        FS.createDevice('/dev', 'random', random_device);\n        FS.createDevice('/dev', 'urandom', random_device);\n        // we're not going to emulate the actual shm device,\n        // just create the tmp dirs that reside in it commonly\n        FS.mkdir('/dev/shm');\n        FS.mkdir('/dev/shm/tmp');\n      },createSpecialDirectories:function () {\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)\n        FS.mkdir('/proc');\n        FS.mkdir('/proc/self');\n        FS.mkdir('/proc/self/fd');\n        FS.mount({\n          mount: function() {\n            var node = FS.createNode('/proc/self', 'fd', 16384 | 0777, 73);\n            node.node_ops = {\n              lookup: function(parent, name) {\n                var fd = +name;\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n                var ret = {\n                  parent: null,\n                  mount: { mountpoint: 'fake' },\n                  node_ops: { readlink: function() { return stream.path } }\n                };\n                ret.parent = ret; // make it look like a simple root node\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, '/proc/self/fd');\n      },createStandardStreams:function () {\n        // TODO deprecate the old functionality of a single\n        // input / output callback and that utilizes FS.createDevice\n        // and instead require a unique set of stream ops\n  \n        // by default, we symlink the standard streams to the\n        // default tty devices. however, if the standard streams\n        // have been overwritten we create a unique device for\n        // them instead.\n        if (Module['stdin']) {\n          FS.createDevice('/dev', 'stdin', Module['stdin']);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdin');\n        }\n        if (Module['stdout']) {\n          FS.createDevice('/dev', 'stdout', null, Module['stdout']);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdout');\n        }\n        if (Module['stderr']) {\n          FS.createDevice('/dev', 'stderr', null, Module['stderr']);\n        } else {\n          FS.symlink('/dev/tty1', '/dev/stderr');\n        }\n  \n        // open default streams for the stdin, stdout and stderr devices\n        var stdin = FS.open('/dev/stdin', 'r');\n        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');\n  \n        var stdout = FS.open('/dev/stdout', 'w');\n        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');\n  \n        var stderr = FS.open('/dev/stderr', 'w');\n        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');\n      },ensureErrnoError:function () {\n        if (FS.ErrnoError) return;\n        FS.ErrnoError = function ErrnoError(errno, node) {\n          //Module.printErr(stackTrace()); // useful for debugging\n          this.node = node;\n          this.setErrno = function(errno) {\n            this.errno = errno;\n            for (var key in ERRNO_CODES) {\n              if (ERRNO_CODES[key] === errno) {\n                this.code = key;\n                break;\n              }\n            }\n          };\n          this.setErrno(errno);\n          this.message = ERRNO_MESSAGES[errno];\n          if (this.stack) this.stack = demangleAll(this.stack);\n        };\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\n        [ERRNO_CODES.ENOENT].forEach(function(code) {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = '<generic error, no stack>';\n        });\n      },staticInit:function () {\n        FS.ensureErrnoError();\n  \n        FS.nameTable = new Array(4096);\n  \n        FS.mount(MEMFS, {}, '/');\n  \n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n  \n        FS.filesystems = {\n          'MEMFS': MEMFS,\n          'IDBFS': IDBFS,\n          'NODEFS': NODEFS,\n          'WORKERFS': WORKERFS,\n        };\n      },init:function (input, output, error) {\n        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');\n        FS.init.initialized = true;\n  \n        FS.ensureErrnoError();\n  \n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n        Module['stdin'] = input || Module['stdin'];\n        Module['stdout'] = output || Module['stdout'];\n        Module['stderr'] = error || Module['stderr'];\n  \n        FS.createStandardStreams();\n      },quit:function () {\n        FS.init.initialized = false;\n        // force-flush all streams, so we get musl std streams printed out\n        var fflush = Module['_fflush'];\n        if (fflush) fflush(0);\n        // close all of our streams\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },getMode:function (canRead, canWrite) {\n        var mode = 0;\n        if (canRead) mode |= 292 | 73;\n        if (canWrite) mode |= 146;\n        return mode;\n      },joinPath:function (parts, forceRelative) {\n        var path = PATH.join.apply(null, parts);\n        if (forceRelative && path[0] == '/') path = path.substr(1);\n        return path;\n      },absolutePath:function (relative, base) {\n        return PATH.resolve(base, relative);\n      },standardizePath:function (path) {\n        return PATH.normalize(path);\n      },findObject:function (path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (ret.exists) {\n          return ret.object;\n        } else {\n          ___setErrNo(ret.error);\n          return null;\n        }\n      },analyzePath:function (path, dontResolveLastLink) {\n        // operate from within the context of the symlink's target\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {\n        }\n        var ret = {\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\n          parentExists: false, parentPath: null, parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === '/';\n        } catch (e) {\n          ret.error = e.errno;\n        };\n        return ret;\n      },createFolder:function (parent, name, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.mkdir(path, mode);\n      },createPath:function (parent, path, canRead, canWrite) {\n        parent = typeof parent === 'string' ? parent : FS.getPath(parent);\n        var parts = path.split('/').reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n            // ignore EEXIST\n          }\n          parent = current;\n        }\n        return current;\n      },createFile:function (parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {\n        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data === 'string') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          // make sure we can write to the file\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 'w');\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n        return node;\n      },createDevice:function (parent, name, input, output) {\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        // Create a fake device that a set of stream ops to emulate\n        // the old behavior.\n        FS.registerDevice(dev, {\n          open: function(stream) {\n            stream.seekable = false;\n          },\n          close: function(stream) {\n            // flush any pending line data\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read: function(stream, buffer, offset, length, pos /* ignored */) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES.EIO);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset+i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write: function(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset+i]);\n              } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES.EIO);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },createLink:function (parent, name, target, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\n        return FS.symlink(target, path);\n      },forceLoadFile:function (obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        var success = true;\n        if (typeof XMLHttpRequest !== 'undefined') {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (Module['read']) {\n          // Command-line.\n          try {\n            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\n            //          read() will try to parse UTF8.\n            obj.contents = intArrayFromString(Module['read'](obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            success = false;\n          }\n        } else {\n          throw new Error('Cannot load without read() or XMLHttpRequest.');\n        }\n        if (!success) ___setErrNo(ERRNO_CODES.EIO);\n        return success;\n      },createLazyFile:function (parent, name, url, canRead, canWrite) {\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = []; // Loaded chunks. Index is the chunk number\n        }\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n          if (idx > this.length-1 || idx < 0) {\n            return undefined;\n          }\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = (idx / this.chunkSize)|0;\n          return this.getter(chunkNum)[chunkOffset];\n        }\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        }\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          // Find length\n          var xhr = new XMLHttpRequest();\n          xhr.open('HEAD', url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n  \n          var chunkSize = 1024*1024; // Chunk size in bytes\n  \n          if (!hasByteServing) chunkSize = datalength;\n  \n          // Function to get a range from the remote URL.\n          var doXHR = (function(from, to) {\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n  \n            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n  \n            // Some hints to the browser that we want binary data.\n            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';\n            if (xhr.overrideMimeType) {\n              xhr.overrideMimeType('text/plain; charset=x-user-defined');\n            }\n  \n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n            if (xhr.response !== undefined) {\n              return new Uint8Array(xhr.response || []);\n            } else {\n              return intArrayFromString(xhr.responseText || '', true);\n            }\n          });\n          var lazyArray = this;\n          lazyArray.setDataGetter(function(chunkNum) {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum+1) * chunkSize - 1; // including this byte\n            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\n            if (typeof(lazyArray.chunks[chunkNum]) === \"undefined\") {\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n            if (typeof(lazyArray.chunks[chunkNum]) === \"undefined\") throw new Error(\"doXHR failed!\");\n            return lazyArray.chunks[chunkNum];\n          });\n  \n          if (usesGzip || !datalength) {\n            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\n            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            console.log(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n  \n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        }\n        if (typeof XMLHttpRequest !== 'undefined') {\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: function() {\n                if(!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: function() {\n                if(!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._chunkSize;\n              }\n            }\n          });\n  \n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url: url };\n        }\n  \n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        // This is a total hack, but I want to get this lazy file code out of the\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\n        // be its own thin LAZYFS proxying calls to MEMFS.\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        // Add a function that defers querying the file size until it is asked the first time.\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function() { return this.contents.length; }\n          }\n        });\n        // override each stream op with one that tries to force load the lazy file first\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(function(key) {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = function forceLoadLazyFile() {\n            if (!FS.forceLoadFile(node)) {\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\n            }\n            return fn.apply(null, arguments);\n          };\n        });\n        // use a custom read function\n        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n          if (!FS.forceLoadFile(node)) {\n            throw new FS.ErrnoError(ERRNO_CODES.EIO);\n          }\n          var contents = stream.node.contents;\n          if (position >= contents.length)\n            return 0;\n          var size = Math.min(contents.length - position, length);\n          assert(size >= 0);\n          if (contents.slice) { // normal array\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n        Browser.init(); // XXX perhaps this method should move onto Browser?\n        // TODO we should allow people to just pass in a complete filename instead\n        // of parent and name being that we just join them anyways\n        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname\n        function processData(byteArray) {\n          function finish(byteArray) {\n            if (preFinish) preFinish();\n            if (!dontCreateFile) {\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n            }\n            if (onload) onload();\n            removeRunDependency(dep);\n          }\n          var handled = false;\n          Module['preloadPlugins'].forEach(function(plugin) {\n            if (handled) return;\n            if (plugin['canHandle'](fullname)) {\n              plugin['handle'](byteArray, fullname, finish, function() {\n                if (onerror) onerror();\n                removeRunDependency(dep);\n              });\n              handled = true;\n            }\n          });\n          if (!handled) finish(byteArray);\n        }\n        addRunDependency(dep);\n        if (typeof url == 'string') {\n          Browser.asyncLoad(url, function(byteArray) {\n            processData(byteArray);\n          }, onerror);\n        } else {\n          processData(url);\n        }\n      },indexedDB:function () {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      },DB_NAME:function () {\n        return 'EM_FS_' + window.location.pathname;\n      },DB_VERSION:20,DB_STORE_NAME:\"FILE_DATA\",saveFilesToDB:function (paths, onload, onerror) {\n        onload = onload || function(){};\n        onerror = onerror || function(){};\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n          console.log('creating db');\n          var db = openRequest.result;\n          db.createObjectStore(FS.DB_STORE_NAME);\n        };\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0, fail = 0, total = paths.length;\n          function finish() {\n            if (fail == 0) onload(); else onerror();\n          }\n          paths.forEach(function(path) {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };\n            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      },loadFilesFromDB:function (paths, onload, onerror) {\n        onload = onload || function(){};\n        onerror = onerror || function(){};\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = onerror; // no database to load from\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');\n          } catch(e) {\n            onerror(e);\n            return;\n          }\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0, fail = 0, total = paths.length;\n          function finish() {\n            if (fail == 0) onload(); else onerror();\n          }\n          paths.forEach(function(path) {\n            var getRequest = files.get(path);\n            getRequest.onsuccess = function getRequest_onsuccess() {\n              if (FS.analyzePath(path).exists) {\n                FS.unlink(path);\n              }\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n              ok++;\n              if (ok + fail == total) finish();\n            };\n            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      }};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:function (dirfd, path) {\n        if (path[0] !== '/') {\n          // relative path\n          var dir;\n          if (dirfd === -100) {\n            dir = FS.cwd();\n          } else {\n            var dirstream = FS.getStream(dirfd);\n            if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n            dir = dirstream.path;\n          }\n          path = PATH.join2(dir, path);\n        }\n        return path;\n      },doStat:function (func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            // an error occurred while trying to look up the path; we should just report ENOTDIR\n            return -ERRNO_CODES.ENOTDIR;\n          }\n          throw e;\n        }\n        HEAP32[((buf)>>2)]=stat.dev;\n        HEAP32[(((buf)+(4))>>2)]=0;\n        HEAP32[(((buf)+(8))>>2)]=stat.ino;\n        HEAP32[(((buf)+(12))>>2)]=stat.mode;\n        HEAP32[(((buf)+(16))>>2)]=stat.nlink;\n        HEAP32[(((buf)+(20))>>2)]=stat.uid;\n        HEAP32[(((buf)+(24))>>2)]=stat.gid;\n        HEAP32[(((buf)+(28))>>2)]=stat.rdev;\n        HEAP32[(((buf)+(32))>>2)]=0;\n        HEAP32[(((buf)+(36))>>2)]=stat.size;\n        HEAP32[(((buf)+(40))>>2)]=4096;\n        HEAP32[(((buf)+(44))>>2)]=stat.blocks;\n        HEAP32[(((buf)+(48))>>2)]=(stat.atime.getTime() / 1000)|0;\n        HEAP32[(((buf)+(52))>>2)]=0;\n        HEAP32[(((buf)+(56))>>2)]=(stat.mtime.getTime() / 1000)|0;\n        HEAP32[(((buf)+(60))>>2)]=0;\n        HEAP32[(((buf)+(64))>>2)]=(stat.ctime.getTime() / 1000)|0;\n        HEAP32[(((buf)+(68))>>2)]=0;\n        HEAP32[(((buf)+(72))>>2)]=stat.ino;\n        return 0;\n      },doMsync:function (addr, stream, len, flags) {\n        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));\n        FS.msync(stream, buffer, 0, len, flags);\n      },doMkdir:function (path, mode) {\n        // remove a trailing slash, if one - /a/b/ has basename of '', but\n        // we want to create b in the context of this function\n        path = PATH.normalize(path);\n        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      },doMknod:function (path, mode, dev) {\n        // we don't want this in the JS API as it uses mknod to create all nodes.\n        switch (mode & 61440) {\n          case 32768:\n          case 8192:\n          case 24576:\n          case 4096:\n          case 49152:\n            break;\n          default: return -ERRNO_CODES.EINVAL;\n        }\n        FS.mknod(path, mode, dev);\n        return 0;\n      },doReadlink:function (path, buf, bufsize) {\n        if (bufsize <= 0) return -ERRNO_CODES.EINVAL;\n        var ret = FS.readlink(path);\n        ret = ret.slice(0, Math.max(0, bufsize));\n        writeStringToMemory(ret, buf, true);\n        return ret.length;\n      },doAccess:function (path, amode) {\n        if (amode & ~7) {\n          // need a valid mode\n          return -ERRNO_CODES.EINVAL;\n        }\n        var node;\n        var lookup = FS.lookupPath(path, { follow: true });\n        node = lookup.node;\n        var perms = '';\n        if (amode & 4) perms += 'r';\n        if (amode & 2) perms += 'w';\n        if (amode & 1) perms += 'x';\n        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {\n          return -ERRNO_CODES.EACCES;\n        }\n        return 0;\n      },doDup:function (path, flags, suggestFD) {\n        var suggest = FS.getStream(suggestFD);\n        if (suggest) FS.close(suggest);\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n      },doReadv:function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[(((iov)+(i*8))>>2)];\n          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n          var curr = FS.read(stream, HEAP8,ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n          if (curr < len) break; // nothing more to read\n        }\n        return ret;\n      },doWritev:function (stream, iov, iovcnt, offset) {\n        var ret = 0;\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[(((iov)+(i*8))>>2)];\n          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n          var curr = FS.write(stream, HEAP8,ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n        }\n        return ret;\n      },varargs:0,get:function (varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n        return ret;\n      },getStr:function () {\n        var ret = Pointer_stringify(SYSCALLS.get());\n        return ret;\n      },getStreamFromFD:function () {\n        var stream = FS.getStream(SYSCALLS.get());\n        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return stream;\n      },getSocketFromFD:function () {\n        var socket = SOCKFS.getSocket(SYSCALLS.get());\n        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\n        return socket;\n      },getSocketAddress:function (allowNull) {\n        var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();\n        if (allowNull && addrp === 0) return null;\n        var info = __read_sockaddr(addrp, addrlen);\n        if (info.errno) throw new FS.ErrnoError(info.errno);\n        info.addr = DNS.lookup_addr(info.addr) || info.addr;\n        return info;\n      },get64:function () {\n        var low = SYSCALLS.get(), high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);\n        else assert(high === -1);\n        return low;\n      },getZero:function () {\n        assert(SYSCALLS.get() === 0);\n      }};function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // ioctl\n      var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();\n      switch (op) {\n        case 21505: {\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          return 0;\n        }\n        case 21506: {\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          return 0; // no-op, not actually adjusting terminal settings\n        }\n        case 21519: {\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          var argp = SYSCALLS.get();\n          HEAP32[((argp)>>2)]=0;\n          return 0;\n        }\n        case 21520: {\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\n          return -ERRNO_CODES.EINVAL; // not supported\n        }\n        case 21531: {\n          var argp = SYSCALLS.get();\n          return FS.ioctl(stream, op, argp);\n        }\n        default: abort('bad ioctl syscall ' + op);\n      }\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n   \n  Module[\"_bitshift64Ashr\"] = _bitshift64Ashr;\n\n   \n  Module[\"_bitshift64Lshr\"] = _bitshift64Lshr;\n\n  function ___cxa_get_exception_ptr(ptr) {\n      // TODO: use info.adjusted?\n      return ptr;\n    }\n\n  function _pthread_cleanup_push(routine, arg) {\n      __ATEXIT__.push(function() { Runtime.dynCall('vi', routine, [arg]) })\n      _pthread_cleanup_push.level = __ATEXIT__.length;\n    }\n\n  function ___cxa_find_matching_catch_4() {\n          return ___cxa_find_matching_catch.apply(null, arguments);\n        }\n\n  function ___cxa_find_matching_catch_2() {\n          return ___cxa_find_matching_catch.apply(null, arguments);\n        }\n\n  function ___cxa_find_matching_catch_3() {\n          return ___cxa_find_matching_catch.apply(null, arguments);\n        }\n\n  function ___cxa_begin_catch(ptr) {\n      __ZSt18uncaught_exceptionv.uncaught_exception--;\n      EXCEPTIONS.caught.push(ptr);\n      EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));\n      return ptr;\n    }\n\n  function _llvm_eh_typeid_for(type) {\n      return type;\n    }\n\n  function ___syscall5(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // open\n      var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get() // optional TODO\n      var stream = FS.open(pathname, flags, mode);\n      return stream.fd;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  \n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n      return dest;\n    } \n  Module[\"_memcpy\"] = _memcpy;\n\n  function ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // close\n      var stream = SYSCALLS.getStreamFromFD();\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function _sbrk(bytes) {\n      // Implement a Linux-like 'memory area' for our 'process'.\n      // Changes the size of the memory area by |bytes|; returns the\n      // address of the previous top ('break') of the memory area\n      // We control the \"dynamic\" memory - DYNAMIC_BASE to DYNAMICTOP\n      var self = _sbrk;\n      if (!self.called) {\n        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned\n        self.called = true;\n        assert(Runtime.dynamicAlloc);\n        self.alloc = Runtime.dynamicAlloc;\n        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };\n      }\n      var ret = DYNAMICTOP;\n      if (bytes != 0) {\n        var success = self.alloc(bytes);\n        if (!success) return -1 >>> 0; // sbrk failure code\n      }\n      return ret;  // Previous break location.\n    }\n\n   \n  Module[\"_memmove\"] = _memmove;\n\n  function _pthread_cleanup_pop() {\n      assert(_pthread_cleanup_push.level == __ATEXIT__.length, 'cannot pop if something else added meanwhile!');\n      __ATEXIT__.pop();\n      _pthread_cleanup_push.level = __ATEXIT__.length;\n    }\n\n  function _time(ptr) {\n      var ret = (Date.now()/1000)|0;\n      if (ptr) {\n        HEAP32[((ptr)>>2)]=ret;\n      }\n      return ret;\n    }\n\n  function _pthread_self() {\n      //FIXME: assumes only a single thread\n      return 0;\n    }\n\n  function ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // llseek\n      var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();\n      var offset = offset_low;\n      assert(offset_high === 0);\n      FS.llseek(stream, offset, whence);\n      HEAP32[((result)>>2)]=stream.position;\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n\n  function ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // writev\n      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\n      return SYSCALLS.doWritev(stream, iov, iovcnt);\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall221(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // fcntl64\n      var stream = SYSCALLS.getStreamFromFD(), cmd = SYSCALLS.get();\n      switch (cmd) {\n        case 0: {\n          var arg = SYSCALLS.get();\n          if (arg < 0) {\n            return -ERRNO_CODES.EINVAL;\n          }\n          var newStream;\n          newStream = FS.open(stream.path, stream.flags, 0, arg);\n          return newStream.fd;\n        }\n        case 1:\n        case 2:\n          return 0;  // FD_CLOEXEC makes no sense for a single process.\n        case 3:\n          return stream.flags;\n        case 4: {\n          var arg = SYSCALLS.get();\n          stream.flags |= arg;\n          return 0;\n        }\n        case 12:\n        case 12: {\n          var arg = SYSCALLS.get();\n          var offset = 0;\n          // We're always unlocked.\n          HEAP16[(((arg)+(offset))>>1)]=2;\n          return 0;\n        }\n        case 13:\n        case 14:\n        case 13:\n        case 14:\n          return 0; // Pretend that the locking is successful.\n        case 16:\n        case 8:\n          return -ERRNO_CODES.EINVAL; // These are for sockets. We don't have them fully implemented yet.\n        case 9:\n          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.\n          ___setErrNo(ERRNO_CODES.EINVAL);\n          return -1;\n        default: {\n          return -ERRNO_CODES.EINVAL;\n        }\n      }\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall145(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // readv\n      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\n      return SYSCALLS.doReadv(stream, iov, iovcnt);\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\nFS.staticInit();__ATINIT__.unshift(function() { if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init() });__ATMAIN__.push(function() { FS.ignorePermissions = false });__ATEXIT__.push(function() { FS.quit() });Module[\"FS_createFolder\"] = FS.createFolder;Module[\"FS_createPath\"] = FS.createPath;Module[\"FS_createDataFile\"] = FS.createDataFile;Module[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;Module[\"FS_createLazyFile\"] = FS.createLazyFile;Module[\"FS_createLink\"] = FS.createLink;Module[\"FS_createDevice\"] = FS.createDevice;Module[\"FS_unlink\"] = FS.unlink;;\n__ATINIT__.unshift(function() { TTY.init() });__ATEXIT__.push(function() { TTY.shutdown() });;\nif (ENVIRONMENT_IS_NODE) { var fs = require(\"fs\"); var NODEJS_PATH = require(\"path\"); NODEFS.staticInit(); };\nSTACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);\n\nstaticSealed = true; // seal the static portion of memory\n\nSTACK_MAX = STACK_BASE + TOTAL_STACK;\n\nDYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);\n\nassert(DYNAMIC_BASE < TOTAL_MEMORY, \"TOTAL_MEMORY not big enough for stack\");\n\n var cttz_i8 = allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0], \"i8\", ALLOC_DYNAMIC);\n\n\nfunction nullFunc_iiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_viiiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_i(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'i'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_vi(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_vii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_ii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_viii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_v(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_iiiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_viiiiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_iii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_iiiiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction nullFunc_viiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\n\nfunction invoke_iiii(index,a1,a2,a3) {\n  try {\n    return Module[\"dynCall_iiii\"](index,a1,a2,a3);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viiiii(index,a1,a2,a3,a4,a5) {\n  try {\n    Module[\"dynCall_viiiii\"](index,a1,a2,a3,a4,a5);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_i(index) {\n  try {\n    return Module[\"dynCall_i\"](index);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_vi(index,a1) {\n  try {\n    Module[\"dynCall_vi\"](index,a1);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_vii(index,a1,a2) {\n  try {\n    Module[\"dynCall_vii\"](index,a1,a2);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_ii(index,a1) {\n  try {\n    return Module[\"dynCall_ii\"](index,a1);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viii(index,a1,a2,a3) {\n  try {\n    Module[\"dynCall_viii\"](index,a1,a2,a3);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_v(index) {\n  try {\n    Module[\"dynCall_v\"](index);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iiiii(index,a1,a2,a3,a4) {\n  try {\n    return Module[\"dynCall_iiiii\"](index,a1,a2,a3,a4);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viiiiii(index,a1,a2,a3,a4,a5,a6) {\n  try {\n    Module[\"dynCall_viiiiii\"](index,a1,a2,a3,a4,a5,a6);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iii(index,a1,a2) {\n  try {\n    return Module[\"dynCall_iii\"](index,a1,a2);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_iiiiii(index,a1,a2,a3,a4,a5) {\n  try {\n    return Module[\"dynCall_iiiiii\"](index,a1,a2,a3,a4,a5);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nfunction invoke_viiii(index,a1,a2,a3,a4) {\n  try {\n    Module[\"dynCall_viiii\"](index,a1,a2,a3,a4);\n  } catch(e) {\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\n    asm[\"setThrew\"](1, 0);\n  }\n}\n\nModule.asmGlobalArg = { \"Math\": Math, \"Int8Array\": Int8Array, \"Int16Array\": Int16Array, \"Int32Array\": Int32Array, \"Uint8Array\": Uint8Array, \"Uint16Array\": Uint16Array, \"Uint32Array\": Uint32Array, \"Float32Array\": Float32Array, \"Float64Array\": Float64Array, \"NaN\": NaN, \"Infinity\": Infinity };\n\nModule.asmLibraryArg = { \"abort\": abort, \"assert\": assert, \"nullFunc_iiii\": nullFunc_iiii, \"nullFunc_viiiii\": nullFunc_viiiii, \"nullFunc_i\": nullFunc_i, \"nullFunc_vi\": nullFunc_vi, \"nullFunc_vii\": nullFunc_vii, \"nullFunc_ii\": nullFunc_ii, \"nullFunc_viii\": nullFunc_viii, \"nullFunc_v\": nullFunc_v, \"nullFunc_iiiii\": nullFunc_iiiii, \"nullFunc_viiiiii\": nullFunc_viiiiii, \"nullFunc_iii\": nullFunc_iii, \"nullFunc_iiiiii\": nullFunc_iiiiii, \"nullFunc_viiii\": nullFunc_viiii, \"invoke_iiii\": invoke_iiii, \"invoke_viiiii\": invoke_viiiii, \"invoke_i\": invoke_i, \"invoke_vi\": invoke_vi, \"invoke_vii\": invoke_vii, \"invoke_ii\": invoke_ii, \"invoke_viii\": invoke_viii, \"invoke_v\": invoke_v, \"invoke_iiiii\": invoke_iiiii, \"invoke_viiiiii\": invoke_viiiiii, \"invoke_iii\": invoke_iii, \"invoke_iiiiii\": invoke_iiiiii, \"invoke_viiii\": invoke_viiii, \"_pthread_cleanup_pop\": _pthread_cleanup_pop, \"___syscall221\": ___syscall221, \"_pthread_key_create\": _pthread_key_create, \"_abort\": _abort, \"_pthread_cleanup_push\": _pthread_cleanup_push, \"___gxx_personality_v0\": ___gxx_personality_v0, \"___cxa_find_matching_catch_4\": ___cxa_find_matching_catch_4, \"___cxa_free_exception\": ___cxa_free_exception, \"___cxa_find_matching_catch_2\": ___cxa_find_matching_catch_2, \"___cxa_find_matching_catch_3\": ___cxa_find_matching_catch_3, \"___setErrNo\": ___setErrNo, \"_llvm_eh_typeid_for\": _llvm_eh_typeid_for, \"_sbrk\": _sbrk, \"___cxa_begin_catch\": ___cxa_begin_catch, \"_emscripten_memcpy_big\": _emscripten_memcpy_big, \"___cxa_end_catch\": ___cxa_end_catch, \"___resumeException\": ___resumeException, \"__ZSt18uncaught_exceptionv\": __ZSt18uncaught_exceptionv, \"__exit\": __exit, \"_pthread_getspecific\": _pthread_getspecific, \"_pthread_self\": _pthread_self, \"___cxa_get_exception_ptr\": ___cxa_get_exception_ptr, \"_pthread_once\": _pthread_once, \"___syscall54\": ___syscall54, \"___unlock\": ___unlock, \"_pthread_setspecific\": _pthread_setspecific, \"___cxa_throw\": ___cxa_throw, \"_sysconf\": _sysconf, \"___lock\": ___lock, \"___syscall6\": ___syscall6, \"___syscall5\": ___syscall5, \"_time\": _time, \"___cxa_allocate_exception\": ___cxa_allocate_exception, \"___syscall140\": ___syscall140, \"_exit\": _exit, \"___cxa_find_matching_catch\": ___cxa_find_matching_catch, \"___syscall145\": ___syscall145, \"___syscall146\": ___syscall146, \"STACKTOP\": STACKTOP, \"STACK_MAX\": STACK_MAX, \"tempDoublePtr\": tempDoublePtr, \"ABORT\": ABORT, \"cttz_i8\": cttz_i8 };\n// EMSCRIPTEN_START_ASM\nvar asm = (function(global, env, buffer) {\n  'almost asm';\n  \n  \n  var HEAP8 = new global.Int8Array(buffer);\n  var HEAP16 = new global.Int16Array(buffer);\n  var HEAP32 = new global.Int32Array(buffer);\n  var HEAPU8 = new global.Uint8Array(buffer);\n  var HEAPU16 = new global.Uint16Array(buffer);\n  var HEAPU32 = new global.Uint32Array(buffer);\n  var HEAPF32 = new global.Float32Array(buffer);\n  var HEAPF64 = new global.Float64Array(buffer);\n\n\n  var STACKTOP=env.STACKTOP|0;\n  var STACK_MAX=env.STACK_MAX|0;\n  var tempDoublePtr=env.tempDoublePtr|0;\n  var ABORT=env.ABORT|0;\n  var cttz_i8=env.cttz_i8|0;\n\n  var __THREW__ = 0;\n  var threwValue = 0;\n  var setjmpId = 0;\n  var undef = 0;\n  var nan = global.NaN, inf = global.Infinity;\n  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;\n\n  var tempRet0 = 0;\n  var tempRet1 = 0;\n  var tempRet2 = 0;\n  var tempRet3 = 0;\n  var tempRet4 = 0;\n  var tempRet5 = 0;\n  var tempRet6 = 0;\n  var tempRet7 = 0;\n  var tempRet8 = 0;\n  var tempRet9 = 0;\n  var Math_floor=global.Math.floor;\n  var Math_abs=global.Math.abs;\n  var Math_sqrt=global.Math.sqrt;\n  var Math_pow=global.Math.pow;\n  var Math_cos=global.Math.cos;\n  var Math_sin=global.Math.sin;\n  var Math_tan=global.Math.tan;\n  var Math_acos=global.Math.acos;\n  var Math_asin=global.Math.asin;\n  var Math_atan=global.Math.atan;\n  var Math_atan2=global.Math.atan2;\n  var Math_exp=global.Math.exp;\n  var Math_log=global.Math.log;\n  var Math_ceil=global.Math.ceil;\n  var Math_imul=global.Math.imul;\n  var Math_min=global.Math.min;\n  var Math_clz32=global.Math.clz32;\n  var abort=env.abort;\n  var assert=env.assert;\n  var nullFunc_iiii=env.nullFunc_iiii;\n  var nullFunc_viiiii=env.nullFunc_viiiii;\n  var nullFunc_i=env.nullFunc_i;\n  var nullFunc_vi=env.nullFunc_vi;\n  var nullFunc_vii=env.nullFunc_vii;\n  var nullFunc_ii=env.nullFunc_ii;\n  var nullFunc_viii=env.nullFunc_viii;\n  var nullFunc_v=env.nullFunc_v;\n  var nullFunc_iiiii=env.nullFunc_iiiii;\n  var nullFunc_viiiiii=env.nullFunc_viiiiii;\n  var nullFunc_iii=env.nullFunc_iii;\n  var nullFunc_iiiiii=env.nullFunc_iiiiii;\n  var nullFunc_viiii=env.nullFunc_viiii;\n  var invoke_iiii=env.invoke_iiii;\n  var invoke_viiiii=env.invoke_viiiii;\n  var invoke_i=env.invoke_i;\n  var invoke_vi=env.invoke_vi;\n  var invoke_vii=env.invoke_vii;\n  var invoke_ii=env.invoke_ii;\n  var invoke_viii=env.invoke_viii;\n  var invoke_v=env.invoke_v;\n  var invoke_iiiii=env.invoke_iiiii;\n  var invoke_viiiiii=env.invoke_viiiiii;\n  var invoke_iii=env.invoke_iii;\n  var invoke_iiiiii=env.invoke_iiiiii;\n  var invoke_viiii=env.invoke_viiii;\n  var _pthread_cleanup_pop=env._pthread_cleanup_pop;\n  var ___syscall221=env.___syscall221;\n  var _pthread_key_create=env._pthread_key_create;\n  var _abort=env._abort;\n  var _pthread_cleanup_push=env._pthread_cleanup_push;\n  var ___gxx_personality_v0=env.___gxx_personality_v0;\n  var ___cxa_find_matching_catch_4=env.___cxa_find_matching_catch_4;\n  var ___cxa_free_exception=env.___cxa_free_exception;\n  var ___cxa_find_matching_catch_2=env.___cxa_find_matching_catch_2;\n  var ___cxa_find_matching_catch_3=env.___cxa_find_matching_catch_3;\n  var ___setErrNo=env.___setErrNo;\n  var _llvm_eh_typeid_for=env._llvm_eh_typeid_for;\n  var _sbrk=env._sbrk;\n  var ___cxa_begin_catch=env.___cxa_begin_catch;\n  var _emscripten_memcpy_big=env._emscripten_memcpy_big;\n  var ___cxa_end_catch=env.___cxa_end_catch;\n  var ___resumeException=env.___resumeException;\n  var __ZSt18uncaught_exceptionv=env.__ZSt18uncaught_exceptionv;\n  var __exit=env.__exit;\n  var _pthread_getspecific=env._pthread_getspecific;\n  var _pthread_self=env._pthread_self;\n  var ___cxa_get_exception_ptr=env.___cxa_get_exception_ptr;\n  var _pthread_once=env._pthread_once;\n  var ___syscall54=env.___syscall54;\n  var ___unlock=env.___unlock;\n  var _pthread_setspecific=env._pthread_setspecific;\n  var ___cxa_throw=env.___cxa_throw;\n  var _sysconf=env._sysconf;\n  var ___lock=env.___lock;\n  var ___syscall6=env.___syscall6;\n  var ___syscall5=env.___syscall5;\n  var _time=env._time;\n  var ___cxa_allocate_exception=env.___cxa_allocate_exception;\n  var ___syscall140=env.___syscall140;\n  var _exit=env._exit;\n  var ___cxa_find_matching_catch=env.___cxa_find_matching_catch;\n  var ___syscall145=env.___syscall145;\n  var ___syscall146=env.___syscall146;\n  var tempFloat = 0.0;\n\n// EMSCRIPTEN_START_FUNCS\n\nfunction stackAlloc(size) {\n  size = size|0;\n  var ret = 0;\n  ret = STACKTOP;\n  STACKTOP = (STACKTOP + size)|0;\n  STACKTOP = (STACKTOP + 15)&-16;\nif ((STACKTOP|0) >= (STACK_MAX|0)) abort();\n\n  return ret|0;\n}\nfunction stackSave() {\n  return STACKTOP|0;\n}\nfunction stackRestore(top) {\n  top = top|0;\n  STACKTOP = top;\n}\nfunction establishStackSpace(stackBase, stackMax) {\n  stackBase = stackBase|0;\n  stackMax = stackMax|0;\n  STACKTOP = stackBase;\n  STACK_MAX = stackMax;\n}\n\nfunction setThrew(threw, value) {\n  threw = threw|0;\n  value = value|0;\n  if ((__THREW__|0) == 0) {\n    __THREW__ = threw;\n    threwValue = value;\n  }\n}\nfunction copyTempFloat(ptr) {\n  ptr = ptr|0;\n  HEAP8[tempDoublePtr>>0] = HEAP8[ptr>>0];\n  HEAP8[tempDoublePtr+1>>0] = HEAP8[ptr+1>>0];\n  HEAP8[tempDoublePtr+2>>0] = HEAP8[ptr+2>>0];\n  HEAP8[tempDoublePtr+3>>0] = HEAP8[ptr+3>>0];\n}\nfunction copyTempDouble(ptr) {\n  ptr = ptr|0;\n  HEAP8[tempDoublePtr>>0] = HEAP8[ptr>>0];\n  HEAP8[tempDoublePtr+1>>0] = HEAP8[ptr+1>>0];\n  HEAP8[tempDoublePtr+2>>0] = HEAP8[ptr+2>>0];\n  HEAP8[tempDoublePtr+3>>0] = HEAP8[ptr+3>>0];\n  HEAP8[tempDoublePtr+4>>0] = HEAP8[ptr+4>>0];\n  HEAP8[tempDoublePtr+5>>0] = HEAP8[ptr+5>>0];\n  HEAP8[tempDoublePtr+6>>0] = HEAP8[ptr+6>>0];\n  HEAP8[tempDoublePtr+7>>0] = HEAP8[ptr+7>>0];\n}\n\nfunction setTempRet0(value) {\n  value = value|0;\n  tempRet0 = value;\n}\nfunction getTempRet0() {\n  return tempRet0|0;\n}\n\nfunction _OCRAD_version() {\n var label = 0, sp = 0;\n sp = STACKTOP;\n return (867|0);\n}\nfunction _OCRAD_open() {\n var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n HEAP32[1700] = -1;\n $0 = (__ZnwjRKSt9nothrow_t(56,9440)|0);\n $1 = ($0|0)==(0|0);\n if ($1) {\n  $8 = 0;\n  return ($8|0);\n }\n $2 = ((($0)) + 28|0);\n ;HEAP32[$0>>2]=0|0;HEAP32[$0+4>>2]=0|0;HEAP32[$0+8>>2]=0|0;HEAP32[$0+12>>2]=0|0;HEAP32[$0+16>>2]=0|0;HEAP32[$0+20>>2]=0|0;HEAP32[$0+24>>2]=0|0;\n $3 = ((($0)) + 32|0);\n HEAP32[$3>>2] = 0;\n $4 = ((($0)) + 36|0);\n HEAP32[$4>>2] = 0;\n $5 = ((($0)) + 40|0);\n HEAP8[$5>>0] = 52;\n $6 = ((($0)) + 41|0);\n HEAP8[$6>>0] = 0;\n $7 = ((($0)) + 44|0);\n ;HEAP32[$7>>2]=0|0;HEAP32[$7+4>>2]=0|0;HEAP32[$7+8>>2]=0|0;\n HEAP32[$2>>2] = 0;\n $8 = $0;\n return ($8|0);\n}\nfunction _OCRAD_close($ocrdes) {\n $ocrdes = $ocrdes|0;\n var $$0 = 0, $$01 = 0, $$02 = 0, $$pre$i$i = 0, $$pre$i$i$i$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0;\n var $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0;\n var $40 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $eh$lpad$body$index2Z2D = 0, $eh$lpad$body$indexZ2D = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$02 = -1;\n  return ($$02|0);\n }\n $1 = ((($ocrdes)) + 4|0);\n $2 = HEAP32[$1>>2]|0;\n $3 = ($2|0)==(0|0);\n do {\n  if (!($3)) {\n   __THREW__ = 0;\n   invoke_vi(26,($2|0));\n   $4 = __THREW__; __THREW__ = 0;\n   $5 = $4&1;\n   if (!($5)) {\n    __ZdlPv($2);\n    break;\n   }\n   $6 = ___cxa_find_matching_catch_2()|0;\n   $7 = tempRet0;\n   __ZdlPv($2);\n   $$0 = $7;$$01 = $6;\n   ___resumeException($$01|0);\n   // unreachable;\n  }\n } while(0);\n $8 = HEAP32[$ocrdes>>2]|0;\n $9 = ($8|0)==(0|0);\n if (!($9)) {\n  $10 = ((($8)) + 16|0);\n  $11 = HEAP32[$10>>2]|0;\n  $12 = ($11|0)==(0|0);\n  if (!($12)) {\n   $13 = ((($8)) + 20|0);\n   $14 = HEAP32[$13>>2]|0;\n   $15 = ($14|0)==($11|0);\n   if ($15) {\n    $25 = $11;\n   } else {\n    $17 = $14;\n    while(1) {\n     $16 = ((($17)) + -12|0);\n     HEAP32[$13>>2] = $16;\n     $18 = HEAP32[$16>>2]|0;\n     $19 = ($18|0)==(0|0);\n     if ($19) {\n      $20 = $16;\n     } else {\n      $22 = ((($17)) + -8|0);\n      $23 = HEAP32[$22>>2]|0;\n      $24 = ($23|0)==($18|0);\n      if (!($24)) {\n       HEAP32[$22>>2] = $18;\n      }\n      __ZdlPv($18);\n      $$pre$i$i$i$i = HEAP32[$13>>2]|0;\n      $20 = $$pre$i$i$i$i;\n     }\n     $21 = ($20|0)==($11|0);\n     if ($21) {\n      break;\n     } else {\n      $17 = $20;\n     }\n    }\n    $$pre$i$i = HEAP32[$10>>2]|0;\n    $25 = $$pre$i$i;\n   }\n   __ZdlPv($25);\n  }\n  __ZdlPv($8);\n }\n $26 = ((($ocrdes)) + 44|0);\n __THREW__ = 0;\n invoke_vi(27,($26|0));\n $27 = __THREW__; __THREW__ = 0;\n $28 = $27&1;\n do {\n  if ($28) {\n   $32 = ___cxa_find_matching_catch_2()|0;\n   $33 = tempRet0;\n   $34 = ((($ocrdes)) + 12|0);\n   __THREW__ = 0;\n   invoke_vi(28,($34|0));\n   $35 = __THREW__; __THREW__ = 0;\n   $36 = $35&1;\n   if ($36) {\n    $37 = ___cxa_find_matching_catch_3(0|0)|0;\n    $38 = tempRet0;\n    ___clang_call_terminate($37);\n    // unreachable;\n   } else {\n    $eh$lpad$body$index2Z2D = $33;$eh$lpad$body$indexZ2D = $32;\n   }\n  } else {\n   $29 = ((($ocrdes)) + 12|0);\n   __THREW__ = 0;\n   invoke_vi(28,($29|0));\n   $30 = __THREW__; __THREW__ = 0;\n   $31 = $30&1;\n   if ($31) {\n    $39 = ___cxa_find_matching_catch_2()|0;\n    $40 = tempRet0;\n    $eh$lpad$body$index2Z2D = $40;$eh$lpad$body$indexZ2D = $39;\n    break;\n   }\n   __ZdlPv($ocrdes);\n   $$02 = 0;\n   return ($$02|0);\n  }\n } while(0);\n __ZdlPv($ocrdes);\n $$0 = $eh$lpad$body$index2Z2D;$$01 = $eh$lpad$body$indexZ2D;\n ___resumeException($$01|0);\n // unreachable;\n return (0)|0;\n}\nfunction _OCRAD_get_errno($ocrdes) {\n $ocrdes = $ocrdes|0;\n var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = 1;\n  return ($$0|0);\n }\n $1 = ((($ocrdes)) + 8|0);\n $2 = HEAP32[$1>>2]|0;\n $$0 = $2;\n return ($$0|0);\n}\nfunction _OCRAD_set_image($ocrdes,$image,$invert) {\n $ocrdes = $ocrdes|0;\n $image = $image|0;\n $invert = $invert|0;\n var $$0 = 0, $$01 = 0, $$02 = 0, $$pre$i$i = 0, $$pre$i$i$i$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0;\n var $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0;\n var $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $switch = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();\n $0 = sp;\n $1 = ($ocrdes|0)==(0|0);\n if ($1) {\n  $$02 = -1;\n  STACKTOP = sp;return ($$02|0);\n }\n $2 = ($image|0)==(0|0);\n if (!($2)) {\n  $3 = ((($image)) + 4|0);\n  $4 = HEAP32[$3>>2]|0;\n  $5 = ($4|0)<(3);\n  if (!($5)) {\n   $6 = ((($image)) + 8|0);\n   $7 = HEAP32[$6>>2]|0;\n   $8 = ($7|0)<(3);\n   if (!($8)) {\n    $9 = (2147483647 / ($7|0))&-1;\n    $10 = ($9|0)<($4|0);\n    if (!($10)) {\n     $11 = ((($image)) + 12|0);\n     $12 = HEAP32[$11>>2]|0;\n     $switch = ($12>>>0)<(3);\n     if ($switch) {\n      __THREW__ = 0;\n      $14 = (invoke_ii(29,32)|0);\n      $15 = __THREW__; __THREW__ = 0;\n      $16 = $15&1;\n      L10: do {\n       if ($16) {\n        $24 = ___cxa_find_matching_catch_3(80|0)|0;\n        $25 = tempRet0;\n        $$0 = $25;$$01 = $24;\n       } else {\n        __THREW__ = 0;\n        invoke_viii(30,($14|0),($image|0),($invert|0));\n        $17 = __THREW__; __THREW__ = 0;\n        $18 = $17&1;\n        if ($18) {\n         $26 = ___cxa_find_matching_catch_3(80|0)|0;\n         $27 = tempRet0;\n         __ZdlPv($14);\n         $$0 = $27;$$01 = $26;\n         break;\n        }\n        $19 = ((($ocrdes)) + 4|0);\n        $20 = HEAP32[$19>>2]|0;\n        $21 = ($20|0)==(0|0);\n        do {\n         if (!($21)) {\n          __THREW__ = 0;\n          invoke_vi(26,($20|0));\n          $22 = __THREW__; __THREW__ = 0;\n          $23 = $22&1;\n          if ($23) {\n           $28 = ___cxa_find_matching_catch_3(80|0)|0;\n           $29 = tempRet0;\n           __ZdlPv($20);\n           $$0 = $29;$$01 = $28;\n           break L10;\n          } else {\n           __ZdlPv($20);\n           HEAP32[$19>>2] = 0;\n           break;\n          }\n         }\n        } while(0);\n        $30 = HEAP32[$ocrdes>>2]|0;\n        $31 = ($30|0)==(0|0);\n        if (!($31)) {\n         $32 = ((($30)) + 16|0);\n         $33 = HEAP32[$32>>2]|0;\n         $34 = ($33|0)==(0|0);\n         if (!($34)) {\n          $35 = ((($30)) + 20|0);\n          $36 = HEAP32[$35>>2]|0;\n          $37 = ($36|0)==($33|0);\n          if ($37) {\n           $47 = $33;\n          } else {\n           $39 = $36;\n           while(1) {\n            $38 = ((($39)) + -12|0);\n            HEAP32[$35>>2] = $38;\n            $40 = HEAP32[$38>>2]|0;\n            $41 = ($40|0)==(0|0);\n            if ($41) {\n             $42 = $38;\n            } else {\n             $44 = ((($39)) + -8|0);\n             $45 = HEAP32[$44>>2]|0;\n             $46 = ($45|0)==($40|0);\n             if (!($46)) {\n              HEAP32[$44>>2] = $40;\n             }\n             __ZdlPv($40);\n             $$pre$i$i$i$i = HEAP32[$35>>2]|0;\n             $42 = $$pre$i$i$i$i;\n            }\n            $43 = ($42|0)==($33|0);\n            if ($43) {\n             break;\n            } else {\n             $39 = $42;\n            }\n           }\n           $$pre$i$i = HEAP32[$32>>2]|0;\n           $47 = $$pre$i$i;\n          }\n          __ZdlPv($47);\n         }\n         __ZdlPv($30);\n        }\n        HEAP32[$ocrdes>>2] = $14;\n        $$02 = 0;\n        STACKTOP = sp;return ($$02|0);\n       }\n      } while(0);\n      $48 = (_llvm_eh_typeid_for((80|0))|0);\n      $49 = ($$0|0)==($48|0);\n      if (!($49)) {\n       ___resumeException($$01|0);\n       // unreachable;\n      }\n      (___cxa_get_exception_ptr(($$01|0))|0);\n      HEAP32[$0>>2] = (808);\n      (___cxa_begin_catch(($$01|0))|0);\n      $50 = ((($ocrdes)) + 8|0);\n      HEAP32[$50>>2] = 2;\n      __ZNSt9bad_allocD2Ev($0);\n      ___cxa_end_catch();\n      $$02 = -1;\n      STACKTOP = sp;return ($$02|0);\n     }\n    }\n   }\n  }\n }\n $13 = ((($ocrdes)) + 8|0);\n HEAP32[$13>>2] = 1;\n $$02 = -1;\n STACKTOP = sp;return ($$02|0);\n}\nfunction _OCRAD_set_image_from_file($ocrdes,$filename,$invert) {\n $ocrdes = $ocrdes|0;\n $filename = $filename|0;\n $invert = $invert|0;\n var $$0 = 0, $$01 = 0, $$1 = 0, $$pre$i$i = 0, $$pre$i$i$i$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0;\n var $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0;\n var $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $infile$0 = 0, $retval$0 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();\n $0 = sp;\n $1 = ($ocrdes|0)==(0|0);\n if ($1) {\n  $$1 = -1;\n  STACKTOP = sp;return ($$1|0);\n }\n $2 = ($filename|0)==(0|0);\n if (!($2)) {\n  $3 = HEAP8[$filename>>0]|0;\n  $4 = ($3<<24>>24)==(0);\n  if (!($4)) {\n   $5 = (_strcmp($filename,860)|0);\n   $6 = ($5|0)==(0);\n   if ($6) {\n    $7 = HEAP32[149]|0;\n    $infile$0 = $7;\n   } else {\n    $8 = (_fopen($filename,862)|0);\n    $infile$0 = $8;\n   }\n   $9 = ($infile$0|0)==(0|0);\n   if (!($9)) {\n    __THREW__ = 0;\n    $11 = (invoke_ii(29,32)|0);\n    $12 = __THREW__; __THREW__ = 0;\n    $13 = $12&1;\n    L12: do {\n     if ($13) {\n      $21 = ___cxa_find_matching_catch_4(80|0,0|0)|0;\n      $22 = tempRet0;\n      $$0 = $22;$$01 = $21;\n      label = 28;\n     } else {\n      __THREW__ = 0;\n      invoke_viii(31,($11|0),($infile$0|0),($invert|0));\n      $14 = __THREW__; __THREW__ = 0;\n      $15 = $14&1;\n      if ($15) {\n       $23 = ___cxa_find_matching_catch_4(80|0,0|0)|0;\n       $24 = tempRet0;\n       __ZdlPv($11);\n       $$0 = $24;$$01 = $23;\n       label = 28;\n       break;\n      }\n      $16 = ((($ocrdes)) + 4|0);\n      $17 = HEAP32[$16>>2]|0;\n      $18 = ($17|0)==(0|0);\n      do {\n       if (!($18)) {\n        __THREW__ = 0;\n        invoke_vi(26,($17|0));\n        $19 = __THREW__; __THREW__ = 0;\n        $20 = $19&1;\n        if ($20) {\n         $25 = ___cxa_find_matching_catch_4(80|0,0|0)|0;\n         $26 = tempRet0;\n         __ZdlPv($17);\n         $$0 = $26;$$01 = $25;\n         label = 28;\n         break L12;\n        } else {\n         __ZdlPv($17);\n         HEAP32[$16>>2] = 0;\n         break;\n        }\n       }\n      } while(0);\n      $27 = HEAP32[$ocrdes>>2]|0;\n      $28 = ($27|0)==(0|0);\n      if (!($28)) {\n       $29 = ((($27)) + 16|0);\n       $30 = HEAP32[$29>>2]|0;\n       $31 = ($30|0)==(0|0);\n       if (!($31)) {\n        $32 = ((($27)) + 20|0);\n        $33 = HEAP32[$32>>2]|0;\n        $34 = ($33|0)==($30|0);\n        if ($34) {\n         $44 = $30;\n        } else {\n         $36 = $33;\n         while(1) {\n          $35 = ((($36)) + -12|0);\n          HEAP32[$32>>2] = $35;\n          $37 = HEAP32[$35>>2]|0;\n          $38 = ($37|0)==(0|0);\n          if ($38) {\n           $39 = $35;\n          } else {\n           $41 = ((($36)) + -8|0);\n           $42 = HEAP32[$41>>2]|0;\n           $43 = ($42|0)==($37|0);\n           if (!($43)) {\n            HEAP32[$41>>2] = $37;\n           }\n           __ZdlPv($37);\n           $$pre$i$i$i$i = HEAP32[$32>>2]|0;\n           $39 = $$pre$i$i$i$i;\n          }\n          $40 = ($39|0)==($30|0);\n          if ($40) {\n           break;\n          } else {\n           $36 = $39;\n          }\n         }\n         $$pre$i$i = HEAP32[$29>>2]|0;\n         $44 = $$pre$i$i;\n        }\n        __ZdlPv($44);\n       }\n       __ZdlPv($27);\n      }\n      HEAP32[$ocrdes>>2] = $11;\n      $retval$0 = 0;\n     }\n    } while(0);\n    do {\n     if ((label|0) == 28) {\n      $45 = (_llvm_eh_typeid_for((80|0))|0);\n      $46 = ($$0|0)==($45|0);\n      if ($46) {\n       (___cxa_get_exception_ptr(($$01|0))|0);\n       HEAP32[$0>>2] = (808);\n       (___cxa_begin_catch(($$01|0))|0);\n       $47 = ((($ocrdes)) + 8|0);\n       HEAP32[$47>>2] = 2;\n       __ZNSt9bad_allocD2Ev($0);\n       ___cxa_end_catch();\n       $retval$0 = -1;\n       break;\n      } else {\n       (___cxa_begin_catch(($$01|0))|0);\n       $48 = ((($ocrdes)) + 8|0);\n       HEAP32[$48>>2] = 1;\n       ___cxa_end_catch();\n       $retval$0 = -1;\n       break;\n      }\n     }\n    } while(0);\n    (_fclose($infile$0)|0);\n    $$1 = $retval$0;\n    STACKTOP = sp;return ($$1|0);\n   }\n  }\n }\n $10 = ((($ocrdes)) + 8|0);\n HEAP32[$10>>2] = 1;\n $$1 = -1;\n STACKTOP = sp;return ($$1|0);\n}\nfunction _OCRAD_set_utf8_format($ocrdes,$utf8) {\n $ocrdes = $ocrdes|0;\n $utf8 = $utf8|0;\n var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if ($2) {\n  $3 = ((($ocrdes)) + 8|0);\n  HEAP32[$3>>2] = 3;\n  $$0 = -1;\n  return ($$0|0);\n } else {\n  $4 = ((($ocrdes)) + 41|0);\n  $5 = $utf8&1;\n  HEAP8[$4>>0] = $5;\n  $$0 = 0;\n  return ($$0|0);\n }\n return (0)|0;\n}\nfunction _OCRAD_set_threshold($ocrdes,$threshold) {\n $ocrdes = $ocrdes|0;\n $threshold = $threshold|0;\n var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $threshold$off = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if ($2) {\n  $3 = ((($ocrdes)) + 8|0);\n  HEAP32[$3>>2] = 3;\n  $$0 = -1;\n  return ($$0|0);\n }\n $threshold$off = (($threshold) + 1)|0;\n $4 = ($threshold$off>>>0)>(256);\n if ($4) {\n  $5 = ((($ocrdes)) + 8|0);\n  HEAP32[$5>>2] = 1;\n  $$0 = -1;\n  return ($$0|0);\n } else {\n  __ZN10Page_image9thresholdEi($1,$threshold);\n  $$0 = 0;\n  return ($$0|0);\n }\n return (0)|0;\n}\nfunction _OCRAD_scale($ocrdes,$value) {\n $ocrdes = $ocrdes|0;\n $value = $value|0;\n var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if ($2) {\n  $3 = ((($ocrdes)) + 8|0);\n  HEAP32[$3>>2] = 3;\n  $$0 = -1;\n  return ($$0|0);\n }\n __THREW__ = 0;\n $4 = (invoke_iii(32,($1|0),($value|0))|0);\n $5 = __THREW__; __THREW__ = 0;\n $6 = $5&1;\n if ($6) {\n  $7 = ___cxa_find_matching_catch_3(0|0)|0;\n  $8 = tempRet0;\n  (___cxa_begin_catch(($7|0))|0);\n  ___cxa_end_catch();\n } else {\n  if ($4) {\n   $$0 = 0;\n   return ($$0|0);\n  }\n }\n $9 = ((($ocrdes)) + 8|0);\n HEAP32[$9>>2] = 1;\n $$0 = -1;\n return ($$0|0);\n}\nfunction _OCRAD_transform($ocrdes,$transformation) {\n $ocrdes = $ocrdes|0;\n $transformation = $transformation|0;\n var $$0 = 0, $$1 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $trans = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();\n $trans = sp;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$1 = -1;\n  STACKTOP = sp;return ($$1|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if ($2) {\n  $3 = ((($ocrdes)) + 8|0);\n  HEAP32[$3>>2] = 3;\n  $$1 = -1;\n  STACKTOP = sp;return ($$1|0);\n }\n HEAP32[$trans>>2] = 0;\n $4 = (__ZN14Transformation3setEPKc($trans,$transformation)|0);\n if ($4) {\n  $5 = HEAP32[$ocrdes>>2]|0;\n  __ZN10Page_image9transformERK14Transformation($5,$trans);\n  $$0 = 0;\n } else {\n  $$0 = -1;\n }\n $$1 = $$0;\n STACKTOP = sp;return ($$1|0);\n}\nfunction _OCRAD_set_exportfile($ocrdes,$filename) {\n $ocrdes = $ocrdes|0;\n $filename = $filename|0;\n var $$1 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $exportfile$0 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$1 = -1;\n  return ($$1|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if ($2) {\n  $3 = ((($ocrdes)) + 8|0);\n  HEAP32[$3>>2] = 3;\n  $$1 = -1;\n  return ($$1|0);\n }\n $4 = ($filename|0)==(0|0);\n if (!($4)) {\n  $5 = HEAP8[$filename>>0]|0;\n  $6 = ($5<<24>>24)==(0);\n  if (!($6)) {\n   $7 = (_strcmp($filename,860)|0);\n   $8 = ($7|0)==(0);\n   if ($8) {\n    $9 = HEAP32[119]|0;\n    $exportfile$0 = $9;\n   } else {\n    $10 = (_fopen($filename,865)|0);\n    $exportfile$0 = $10;\n   }\n   $11 = ($exportfile$0|0)==(0|0);\n   if (!($11)) {\n    $13 = ((($ocrdes)) + 32|0);\n    HEAP32[$13>>2] = $exportfile$0;\n    $$1 = 0;\n    return ($$1|0);\n   }\n  }\n }\n $12 = ((($ocrdes)) + 8|0);\n HEAP32[$12>>2] = 1;\n $$1 = -1;\n return ($$1|0);\n}\nfunction _OCRAD_add_filter($ocrdes,$name) {\n $ocrdes = $ocrdes|0;\n $name = $name|0;\n var $$0 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if ($2) {\n  $3 = ((($ocrdes)) + 8|0);\n  HEAP32[$3>>2] = 3;\n  $$0 = -1;\n  return ($$0|0);\n } else {\n  $4 = ((($ocrdes)) + 12|0);\n  (__ZN7Control10add_filterEPKcS1_($4,7360,$name)|0);\n  $$0 = 0;\n  return ($$0|0);\n }\n return (0)|0;\n}\nfunction _OCRAD_recognize($ocrdes,$layout) {\n $ocrdes = $ocrdes|0;\n $layout = $layout|0;\n var $$0 = 0, $$01 = 0, $$1 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0;\n var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$1 = -1;\n  return ($$1|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if ($2) {\n  $3 = ((($ocrdes)) + 8|0);\n  HEAP32[$3>>2] = 3;\n  $$1 = -1;\n  return ($$1|0);\n }\n $4 = (__ZnwjRKSt9nothrow_t(40,9440)|0);\n $5 = ($4|0)==(0|0);\n if ($5) {\n  $9 = ((($ocrdes)) + 8|0);\n  HEAP32[$9>>2] = 2;\n  $$1 = -1;\n  return ($$1|0);\n }\n $6 = ((($ocrdes)) + 12|0);\n __THREW__ = 0;\n invoke_viiiii(33,($4|0),($1|0),(7360|0),($6|0),($layout|0));\n $7 = __THREW__; __THREW__ = 0;\n $8 = $7&1;\n if ($8) {\n  $10 = ___cxa_find_matching_catch_2()|0;\n  $11 = tempRet0;\n  __ZdlPvRKSt9nothrow_t($4,9440);\n  $$0 = $11;$$01 = $10;\n  ___resumeException($$01|0);\n  // unreachable;\n }\n $12 = ((($ocrdes)) + 4|0);\n $13 = HEAP32[$12>>2]|0;\n $14 = ($13|0)==(0|0);\n do {\n  if (!($14)) {\n   __THREW__ = 0;\n   invoke_vi(26,($13|0));\n   $15 = __THREW__; __THREW__ = 0;\n   $16 = $15&1;\n   if (!($16)) {\n    __ZdlPv($13);\n    break;\n   }\n   $17 = ___cxa_find_matching_catch_2()|0;\n   $18 = tempRet0;\n   __ZdlPv($13);\n   $$0 = $18;$$01 = $17;\n   ___resumeException($$01|0);\n   // unreachable;\n  }\n } while(0);\n HEAP32[$12>>2] = $4;\n $19 = ((($ocrdes)) + 32|0);\n $20 = HEAP32[$19>>2]|0;\n $21 = ($20|0)==(0|0);\n if ($21) {\n  $$1 = 0;\n  return ($$1|0);\n }\n __ZNK8Textpage6xprintERK7Control($4,$6);\n $$1 = 0;\n return ($$1|0);\n}\nfunction _OCRAD_result_blocks($ocrdes) {\n $ocrdes = $ocrdes|0;\n var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if (!($2)) {\n  $3 = ((($ocrdes)) + 4|0);\n  $4 = HEAP32[$3>>2]|0;\n  $5 = ($4|0)==(0|0);\n  if (!($5)) {\n   $7 = ((($4)) + 28|0);\n   $8 = ((($4)) + 32|0);\n   $9 = HEAP32[$8>>2]|0;\n   $10 = HEAP32[$7>>2]|0;\n   $11 = (($9) - ($10))|0;\n   $12 = $11 >> 2;\n   $$0 = $12;\n   return ($$0|0);\n  }\n }\n $6 = ((($ocrdes)) + 8|0);\n HEAP32[$6>>2] = 3;\n $$0 = -1;\n return ($$0|0);\n}\nfunction _OCRAD_result_lines($ocrdes,$blocknum) {\n $ocrdes = $ocrdes|0;\n $blocknum = $blocknum|0;\n var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0;\n var $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if (!($2)) {\n  $3 = ((($ocrdes)) + 4|0);\n  $4 = HEAP32[$3>>2]|0;\n  $5 = ($4|0)==(0|0);\n  if (!($5)) {\n   $7 = ($blocknum|0)<(0);\n   if (!($7)) {\n    $8 = ((($4)) + 28|0);\n    $9 = ((($4)) + 32|0);\n    $10 = HEAP32[$9>>2]|0;\n    $11 = HEAP32[$8>>2]|0;\n    $12 = (($10) - ($11))|0;\n    $13 = $12 >> 2;\n    $14 = ($13|0)>($blocknum|0);\n    if ($14) {\n     $16 = (__ZNK8Textpage9textblockEi($4,$blocknum)|0);\n     $17 = ((($16)) + 16|0);\n     $18 = ((($16)) + 20|0);\n     $19 = HEAP32[$18>>2]|0;\n     $20 = HEAP32[$17>>2]|0;\n     $21 = (($19) - ($20))|0;\n     $22 = $21 >> 2;\n     $$0 = $22;\n     return ($$0|0);\n    }\n   }\n   $15 = ((($ocrdes)) + 8|0);\n   HEAP32[$15>>2] = 1;\n   $$0 = -1;\n   return ($$0|0);\n  }\n }\n $6 = ((($ocrdes)) + 8|0);\n HEAP32[$6>>2] = 3;\n $$0 = -1;\n return ($$0|0);\n}\nfunction _OCRAD_result_chars_total($ocrdes) {\n $ocrdes = $ocrdes|0;\n var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;\n var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0;\n var $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $b$04 = 0, $c$03 = 0, $c$1$lcssa = 0, $c$11 = 0, $i$02 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if (!($2)) {\n  $3 = ((($ocrdes)) + 4|0);\n  $4 = HEAP32[$3>>2]|0;\n  $5 = ($4|0)==(0|0);\n  if (!($5)) {\n   $6 = ((($4)) + 28|0);\n   $7 = ((($4)) + 32|0);\n   $8 = HEAP32[$7>>2]|0;\n   $9 = HEAP32[$6>>2]|0;\n   $10 = (($8) - ($9))|0;\n   $11 = ($10|0)>(0);\n   if ($11) {\n    $13 = $4;$b$04 = 0;$c$03 = 0;\n   } else {\n    $$0 = 0;\n    return ($$0|0);\n   }\n   while(1) {\n    $14 = (__ZNK8Textpage9textblockEi($13,$b$04)|0);\n    $15 = ((($14)) + 16|0);\n    $16 = ((($14)) + 20|0);\n    $17 = HEAP32[$16>>2]|0;\n    $18 = HEAP32[$15>>2]|0;\n    $19 = (($17) - ($18))|0;\n    $20 = ($19|0)>(0);\n    if ($20) {\n     $c$11 = $c$03;$i$02 = 0;\n     while(1) {\n      $30 = HEAP32[$3>>2]|0;\n      $31 = (__ZNK8Textpage9textblockEi($30,$b$04)|0);\n      $32 = (__ZNK9Textblock8textlineEi($31,$i$02)|0);\n      $33 = ((($32)) + 16|0);\n      $34 = ((($32)) + 20|0);\n      $35 = HEAP32[$34>>2]|0;\n      $36 = HEAP32[$33>>2]|0;\n      $37 = (($35) - ($36))|0;\n      $38 = $37 >> 2;\n      $39 = (($38) + ($c$11))|0;\n      $40 = (($i$02) + 1)|0;\n      $41 = HEAP32[$3>>2]|0;\n      $42 = (__ZNK8Textpage9textblockEi($41,$b$04)|0);\n      $43 = ((($42)) + 16|0);\n      $44 = ((($42)) + 20|0);\n      $45 = HEAP32[$44>>2]|0;\n      $46 = HEAP32[$43>>2]|0;\n      $47 = (($45) - ($46))|0;\n      $48 = $47 >> 2;\n      $49 = ($40|0)<($48|0);\n      if ($49) {\n       $c$11 = $39;$i$02 = $40;\n      } else {\n       $c$1$lcssa = $39;\n       break;\n      }\n     }\n    } else {\n     $c$1$lcssa = $c$03;\n    }\n    $21 = (($b$04) + 1)|0;\n    $22 = HEAP32[$3>>2]|0;\n    $23 = ((($22)) + 28|0);\n    $24 = ((($22)) + 32|0);\n    $25 = HEAP32[$24>>2]|0;\n    $26 = HEAP32[$23>>2]|0;\n    $27 = (($25) - ($26))|0;\n    $28 = $27 >> 2;\n    $29 = ($21|0)<($28|0);\n    if ($29) {\n     $13 = $22;$b$04 = $21;$c$03 = $c$1$lcssa;\n    } else {\n     $$0 = $c$1$lcssa;\n     break;\n    }\n   }\n   return ($$0|0);\n  }\n }\n $12 = ((($ocrdes)) + 8|0);\n HEAP32[$12>>2] = 3;\n $$0 = -1;\n return ($$0|0);\n}\nfunction _OCRAD_result_chars_block($ocrdes,$blocknum) {\n $ocrdes = $ocrdes|0;\n $blocknum = $blocknum|0;\n var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;\n var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0;\n var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $c$01 = 0, $i$02 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if (!($2)) {\n  $3 = ((($ocrdes)) + 4|0);\n  $4 = HEAP32[$3>>2]|0;\n  $5 = ($4|0)==(0|0);\n  if (!($5)) {\n   $7 = ($blocknum|0)<(0);\n   if (!($7)) {\n    $8 = ((($4)) + 28|0);\n    $9 = ((($4)) + 32|0);\n    $10 = HEAP32[$9>>2]|0;\n    $11 = HEAP32[$8>>2]|0;\n    $12 = (($10) - ($11))|0;\n    $13 = $12 >> 2;\n    $14 = ($13|0)>($blocknum|0);\n    if ($14) {\n     $15 = (__ZNK8Textpage9textblockEi($4,$blocknum)|0);\n     $16 = ((($15)) + 16|0);\n     $17 = ((($15)) + 20|0);\n     $18 = HEAP32[$17>>2]|0;\n     $19 = HEAP32[$16>>2]|0;\n     $20 = (($18) - ($19))|0;\n     $21 = ($20|0)>(0);\n     if ($21) {\n      $c$01 = 0;$i$02 = 0;\n     } else {\n      $$0 = 0;\n      return ($$0|0);\n     }\n     while(1) {\n      $23 = HEAP32[$3>>2]|0;\n      $24 = (__ZNK8Textpage9textblockEi($23,$blocknum)|0);\n      $25 = (__ZNK9Textblock8textlineEi($24,$i$02)|0);\n      $26 = ((($25)) + 16|0);\n      $27 = ((($25)) + 20|0);\n      $28 = HEAP32[$27>>2]|0;\n      $29 = HEAP32[$26>>2]|0;\n      $30 = (($28) - ($29))|0;\n      $31 = $30 >> 2;\n      $32 = (($31) + ($c$01))|0;\n      $33 = (($i$02) + 1)|0;\n      $34 = HEAP32[$3>>2]|0;\n      $35 = (__ZNK8Textpage9textblockEi($34,$blocknum)|0);\n      $36 = ((($35)) + 16|0);\n      $37 = ((($35)) + 20|0);\n      $38 = HEAP32[$37>>2]|0;\n      $39 = HEAP32[$36>>2]|0;\n      $40 = (($38) - ($39))|0;\n      $41 = $40 >> 2;\n      $42 = ($33|0)<($41|0);\n      if ($42) {\n       $c$01 = $32;$i$02 = $33;\n      } else {\n       $$0 = $32;\n       break;\n      }\n     }\n     return ($$0|0);\n    }\n   }\n   $22 = ((($ocrdes)) + 8|0);\n   HEAP32[$22>>2] = 1;\n   $$0 = -1;\n   return ($$0|0);\n  }\n }\n $6 = ((($ocrdes)) + 8|0);\n HEAP32[$6>>2] = 3;\n $$0 = -1;\n return ($$0|0);\n}\nfunction _OCRAD_result_chars_line($ocrdes,$blocknum,$linenum) {\n $ocrdes = $ocrdes|0;\n $blocknum = $blocknum|0;\n $linenum = $linenum|0;\n var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;\n var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if (!($2)) {\n  $3 = ((($ocrdes)) + 4|0);\n  $4 = HEAP32[$3>>2]|0;\n  $5 = ($4|0)==(0|0);\n  if (!($5)) {\n   $7 = ($blocknum|0)<(0);\n   if (!($7)) {\n    $8 = ((($4)) + 28|0);\n    $9 = ((($4)) + 32|0);\n    $10 = HEAP32[$9>>2]|0;\n    $11 = HEAP32[$8>>2]|0;\n    $12 = (($10) - ($11))|0;\n    $13 = $12 >> 2;\n    $14 = ($13|0)<=($blocknum|0);\n    $15 = ($linenum|0)<(0);\n    $or$cond = $15 | $14;\n    if (!($or$cond)) {\n     $16 = (__ZNK8Textpage9textblockEi($4,$blocknum)|0);\n     $17 = ((($16)) + 16|0);\n     $18 = ((($16)) + 20|0);\n     $19 = HEAP32[$18>>2]|0;\n     $20 = HEAP32[$17>>2]|0;\n     $21 = (($19) - ($20))|0;\n     $22 = $21 >> 2;\n     $23 = ($22|0)>($linenum|0);\n     if ($23) {\n      $25 = HEAP32[$3>>2]|0;\n      $26 = (__ZNK8Textpage9textblockEi($25,$blocknum)|0);\n      $27 = (__ZNK9Textblock8textlineEi($26,$linenum)|0);\n      $28 = ((($27)) + 16|0);\n      $29 = ((($27)) + 20|0);\n      $30 = HEAP32[$29>>2]|0;\n      $31 = HEAP32[$28>>2]|0;\n      $32 = (($30) - ($31))|0;\n      $33 = $32 >> 2;\n      $$0 = $33;\n      return ($$0|0);\n     }\n    }\n   }\n   $24 = ((($ocrdes)) + 8|0);\n   HEAP32[$24>>2] = 1;\n   $$0 = -1;\n   return ($$0|0);\n  }\n }\n $6 = ((($ocrdes)) + 8|0);\n HEAP32[$6>>2] = 3;\n $$0 = -1;\n return ($$0|0);\n}\nfunction _OCRAD_result_line($ocrdes,$blocknum,$linenum) {\n $ocrdes = $ocrdes|0;\n $blocknum = $blocknum|0;\n $linenum = $linenum|0;\n var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;\n var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0;\n var $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0;\n var $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $7 = 0, $8 = 0, $9 = 0, $i$04 = 0, $i1$05 = 0, $or$cond = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = 0;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if (!($2)) {\n  $3 = ((($ocrdes)) + 4|0);\n  $4 = HEAP32[$3>>2]|0;\n  $5 = ($4|0)==(0|0);\n  if (!($5)) {\n   $7 = ($blocknum|0)<(0);\n   if (!($7)) {\n    $8 = ((($4)) + 28|0);\n    $9 = ((($4)) + 32|0);\n    $10 = HEAP32[$9>>2]|0;\n    $11 = HEAP32[$8>>2]|0;\n    $12 = (($10) - ($11))|0;\n    $13 = $12 >> 2;\n    $14 = ($13|0)<=($blocknum|0);\n    $15 = ($linenum|0)<(0);\n    $or$cond = $15 | $14;\n    if (!($or$cond)) {\n     $16 = (__ZNK8Textpage9textblockEi($4,$blocknum)|0);\n     $17 = ((($16)) + 16|0);\n     $18 = ((($16)) + 20|0);\n     $19 = HEAP32[$18>>2]|0;\n     $20 = HEAP32[$17>>2]|0;\n     $21 = (($19) - ($20))|0;\n     $22 = $21 >> 2;\n     $23 = ($22|0)>($linenum|0);\n     if ($23) {\n      $25 = HEAP32[$3>>2]|0;\n      $26 = (__ZNK8Textpage9textblockEi($25,$blocknum)|0);\n      $27 = (__ZNK9Textblock8textlineEi($26,$linenum)|0);\n      $28 = ((($ocrdes)) + 44|0);\n      $29 = HEAP8[$28>>0]|0;\n      $30 = $29 & 1;\n      $31 = ($30<<24>>24)==(0);\n      if ($31) {\n       $35 = ((($28)) + 1|0);\n       HEAP8[$35>>0] = 0;\n       HEAP8[$28>>0] = 0;\n      } else {\n       $32 = ((($ocrdes)) + 52|0);\n       $33 = HEAP32[$32>>2]|0;\n       HEAP8[$33>>0] = 0;\n       $34 = ((($ocrdes)) + 48|0);\n       HEAP32[$34>>2] = 0;\n      }\n      $36 = ((($ocrdes)) + 41|0);\n      $37 = HEAP8[$36>>0]|0;\n      $38 = ($37<<24>>24)==(0);\n      $39 = ((($27)) + 16|0);\n      $40 = ((($27)) + 20|0);\n      $41 = HEAP32[$40>>2]|0;\n      $42 = HEAP32[$39>>2]|0;\n      $43 = (($41) - ($42))|0;\n      $44 = ($43|0)>(0);\n      if ($38) {\n       if ($44) {\n        $i$04 = 0;\n        while(1) {\n         $45 = (__ZNK8Textline9characterEi($27,$i$04)|0);\n         $46 = (__ZNK9Character11byte_resultEv($45)|0);\n         __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc($28,$46);\n         $47 = (($i$04) + 1)|0;\n         $48 = HEAP32[$40>>2]|0;\n         $49 = HEAP32[$39>>2]|0;\n         $50 = (($48) - ($49))|0;\n         $51 = $50 >> 2;\n         $52 = ($47|0)<($51|0);\n         if ($52) {\n          $i$04 = $47;\n         } else {\n          break;\n         }\n        }\n       }\n      } else {\n       if ($44) {\n        $i1$05 = 0;\n        while(1) {\n         $53 = (__ZNK8Textline9characterEi($27,$i1$05)|0);\n         $54 = (__ZNK9Character11utf8_resultEv($53)|0);\n         (__ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKc($28,$54)|0);\n         $55 = (($i1$05) + 1)|0;\n         $56 = HEAP32[$40>>2]|0;\n         $57 = HEAP32[$39>>2]|0;\n         $58 = (($56) - ($57))|0;\n         $59 = $58 >> 2;\n         $60 = ($55|0)<($59|0);\n         if ($60) {\n          $i1$05 = $55;\n         } else {\n          break;\n         }\n        }\n       }\n      }\n      __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc($28,10);\n      $61 = HEAP8[$28>>0]|0;\n      $62 = $61 & 1;\n      $63 = ($62<<24>>24)==(0);\n      if ($63) {\n       $66 = ((($28)) + 1|0);\n       $$0 = $66;\n       return ($$0|0);\n      } else {\n       $64 = ((($ocrdes)) + 52|0);\n       $65 = HEAP32[$64>>2]|0;\n       $$0 = $65;\n       return ($$0|0);\n      }\n     }\n    }\n   }\n   $24 = ((($ocrdes)) + 8|0);\n   HEAP32[$24>>2] = 1;\n   $$0 = 0;\n   return ($$0|0);\n  }\n }\n $6 = ((($ocrdes)) + 8|0);\n HEAP32[$6>>2] = 3;\n $$0 = 0;\n return ($$0|0);\n}\nfunction _OCRAD_result_first_character($ocrdes) {\n $ocrdes = $ocrdes|0;\n var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;\n var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($ocrdes|0)==(0|0);\n if ($0) {\n  $$0 = -1;\n  return ($$0|0);\n }\n $1 = HEAP32[$ocrdes>>2]|0;\n $2 = ($1|0)==(0|0);\n if (!($2)) {\n  $3 = ((($ocrdes)) + 4|0);\n  $4 = HEAP32[$3>>2]|0;\n  $5 = ($4|0)==(0|0);\n  if (!($5)) {\n   $7 = ((($4)) + 28|0);\n   $8 = ((($4)) + 32|0);\n   $9 = HEAP32[$8>>2]|0;\n   $10 = HEAP32[$7>>2]|0;\n   $11 = (($9) - ($10))|0;\n   $12 = ($11|0)>(0);\n   if (!($12)) {\n    $$0 = 0;\n    return ($$0|0);\n   }\n   $13 = (__ZNK8Textpage9textblockEi($4,0)|0);\n   $14 = ((($13)) + 16|0);\n   $15 = ((($13)) + 20|0);\n   $16 = HEAP32[$15>>2]|0;\n   $17 = HEAP32[$14>>2]|0;\n   $18 = (($16) - ($17))|0;\n   $19 = ($18|0)>(0);\n   if (!($19)) {\n    $$0 = 0;\n    return ($$0|0);\n   }\n   $20 = HEAP32[$3>>2]|0;\n   $21 = (__ZNK8Textpage9textblockEi($20,0)|0);\n   $22 = (__ZNK9Textblock8textlineEi($21,0)|0);\n   $23 = (__ZNK8Textline9characterEi($22,0)|0);\n   $24 = ((($23)) + 28|0);\n   $25 = ((($23)) + 32|0);\n   $26 = HEAP32[$25>>2]|0;\n   $27 = HEAP32[$24>>2]|0;\n   $28 = ($26|0)==($27|0);\n   if ($28) {\n    $$0 = 0;\n    return ($$0|0);\n   }\n   $29 = ((($ocrdes)) + 41|0);\n   $30 = HEAP8[$29>>0]|0;\n   $31 = ($30<<24>>24)==(0);\n   $32 = (__ZNK9Character5guessEi($23,0)|0);\n   $33 = HEAP32[$32>>2]|0;\n   if (!($31)) {\n    $$0 = $33;\n    return ($$0|0);\n   }\n   $34 = (__ZN3UCS11map_to_byteEi($33)|0);\n   $35 = $34&255;\n   $$0 = $35;\n   return ($$0|0);\n  }\n }\n $6 = ((($ocrdes)) + 8|0);\n HEAP32[$6>>2] = 3;\n $$0 = -1;\n return ($$0|0);\n}\nfunction ___clang_call_terminate($0) {\n $0 = $0|0;\n var label = 0, sp = 0;\n sp = STACKTOP;\n (___cxa_begin_catch(($0|0))|0);\n __ZSt9terminatev();\n // unreachable;\n}\nfunction __ZN10Page_image7read_p1EP8_IO_FILEb($this,$f,$invert) {\n $this = $this|0;\n $f = $f|0;\n $invert = $invert|0;\n var $$0$i$us = 0, $$0$i1$i$i$us = 0, $$0$i1$i$i10$us = 0, $$0$i14$us = 0, $$0$i2$i$i$us = 0, $$0$i2$i$i11$us = 0, $$in$i$i$us = 0, $$in$i$i7$us = 0, $$pre$i$i$us = 0, $$pre$i$i3$us = 0, $$pre$i$us = 0, $$pre$i5$us = 0, $$pre$phi$i$usZ2D = 0, $$pre$phi$i6$usZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0;\n var $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0;\n var $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0;\n var $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0;\n var $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0;\n var $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0;\n var $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0;\n var $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $ch$0$i$us = 0, $ch$0$i$us$lcssa = 0, $ch$0$i18$us = 0, $ch$0$i18$us$lcssa = 0, $col$029$us = 0, $col2$026$us = 0;\n var $row$032$us = 0, $row1$027$us = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ((($this)) + 28|0);\n HEAP8[$0>>0] = 1;\n $1 = ((($this)) + 29|0);\n HEAP8[$1>>0] = 0;\n $2 = ((($this)) + 12|0);\n $3 = HEAP32[$2>>2]|0;\n $4 = ((($this)) + 4|0);\n $5 = HEAP32[$4>>2]|0;\n $6 = (($3) + 1)|0;\n $7 = (($6) - ($5))|0;\n $8 = ((($this)) + 8|0);\n $9 = HEAP32[$8>>2]|0;\n $10 = HEAP32[$this>>2]|0;\n $11 = (($9) + 1)|0;\n $12 = (($11) - ($10))|0;\n $13 = ($7|0)>(0);\n if ($invert) {\n  if (!($13)) {\n   return;\n  }\n  $72 = ($12|0)>(0);\n  $73 = ((($this)) + 16|0);\n  if ($72) {\n   $row1$027$us = 0;\n  } else {\n   return;\n  }\n  L8: while(1) {\n   $col2$026$us = 0;\n   while(1) {\n    $74 = HEAP32[$73>>2]|0;\n    $75 = (($74) + (($row1$027$us*12)|0)|0);\n    while(1) {\n     $76 = (_fgetc($f)|0);\n     $77 = ($76|0)==(-1);\n     if ($77) {\n      label = 53;\n      break L8;\n     }\n     $78 = $76&255;\n     $79 = ($78<<24>>24)==(35);\n     if ($79) {\n      while(1) {\n       $80 = (_fgetc($f)|0);\n       $81 = ($80|0)==(-1);\n       if ($81) {\n        label = 54;\n        break L8;\n       }\n       $82 = $80&255;\n       $83 = ($82<<24>>24)==(10);\n       if ($83) {\n        $ch$0$i18$us = 10;\n        break;\n       }\n      }\n     } else {\n      $ch$0$i18$us = $78;\n     }\n     $84 = $ch$0$i18$us&255;\n     $85 = (_isspace($84)|0);\n     $86 = ($85|0)==(0);\n     if ($86) {\n      $ch$0$i18$us$lcssa = $ch$0$i18$us;\n      break;\n     }\n    }\n    switch ($ch$0$i18$us$lcssa<<24>>24) {\n    case 48:  {\n     $$0$i14$us = 0;\n     break;\n    }\n    case 49:  {\n     $$0$i14$us = 1;\n     break;\n    }\n    default: {\n     label = 55;\n     break L8;\n    }\n    }\n    $87 = (((($74) + (($row1$027$us*12)|0)|0)) + 4|0);\n    $88 = HEAP32[$87>>2]|0;\n    $89 = (((($74) + (($row1$027$us*12)|0)|0)) + 8|0);\n    $90 = HEAP32[$89>>2]|0;\n    $91 = ($88|0)==($90|0);\n    $92 = $90;\n    if ($91) {\n     $95 = $88;\n     $96 = HEAP32[$75>>2]|0;\n     $97 = (($95) - ($96))|0;\n     $98 = (($97) + 1)|0;\n     $99 = ($98|0)<(0);\n     if ($99) {\n      __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($75);\n      $$pre$i$i$us = HEAP32[$75>>2]|0;\n      $$pre$i$us = HEAP32[$89>>2]|0;\n      $$in$i$i$us = $$pre$i$i$us;$$pre$phi$i$usZ2D = $89;$102 = $$pre$i$us;\n     } else {\n      $$in$i$i$us = $96;$$pre$phi$i$usZ2D = $89;$102 = $92;\n     }\n     $100 = $$in$i$i$us;\n     $101 = (($102) - ($$in$i$i$us))|0;\n     $103 = ($101>>>0)<(1073741823);\n     if ($103) {\n      $106 = $101 << 1;\n      $107 = ($106>>>0)<($98>>>0);\n      $108 = $107 ? $98 : $106;\n      $109 = HEAP32[$87>>2]|0;\n      $110 = (($109) - ($$in$i$i$us))|0;\n      $111 = ($108|0)==(0);\n      if ($111) {\n       $$0$i2$i$i$us = 0;$114 = 0;$115 = $110;$121 = $109;\n      } else {\n       $$0$i1$i$i$us = $108;$138 = $109;$139 = $110;\n       label = 44;\n      }\n     } else {\n      $104 = HEAP32[$87>>2]|0;\n      $105 = (($104) - ($$in$i$i$us))|0;\n      $$0$i1$i$i$us = 2147483647;$138 = $104;$139 = $105;\n      label = 44;\n     }\n     if ((label|0) == 44) {\n      label = 0;\n      $112 = (__Znwj($$0$i1$i$i$us)|0);\n      $$0$i2$i$i$us = $$0$i1$i$i$us;$114 = $112;$115 = $139;$121 = $138;\n     }\n     $113 = (($114) + ($115)|0);\n     $116 = (($114) + ($$0$i2$i$i$us)|0);\n     $117 = $116;\n     HEAP8[$113>>0] = $$0$i14$us;\n     $118 = ((($113)) + 1|0);\n     $119 = $118;\n     $120 = (($121) - ($$in$i$i$us))|0;\n     $122 = (0 - ($120))|0;\n     $123 = (($113) + ($122)|0);\n     $124 = $123;\n     _memcpy(($123|0),($100|0),($120|0))|0;\n     HEAP32[$75>>2] = $124;\n     HEAP32[$87>>2] = $119;\n     HEAP32[$$pre$phi$i$usZ2D>>2] = $117;\n     $125 = ($$in$i$i$us|0)==(0);\n     if (!($125)) {\n      __ZdlPv($100);\n     }\n    } else {\n     HEAP8[$88>>0] = $$0$i14$us;\n     $93 = HEAP32[$87>>2]|0;\n     $94 = ((($93)) + 1|0);\n     HEAP32[$87>>2] = $94;\n    }\n    $126 = (($col2$026$us) + 1)|0;\n    $127 = ($126|0)<($12|0);\n    if ($127) {\n     $col2$026$us = $126;\n    } else {\n     break;\n    }\n   }\n   $128 = (($row1$027$us) + 1)|0;\n   $129 = ($128|0)<($7|0);\n   if ($129) {\n    $row1$027$us = $128;\n   } else {\n    label = 56;\n    break;\n   }\n  }\n  if ((label|0) == 53) {\n   $133 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$133>>2] = 872;\n   ___cxa_throw(($133|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 54) {\n   $134 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$134>>2] = 872;\n   ___cxa_throw(($134|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 55) {\n   $135 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$135>>2] = 923;\n   ___cxa_throw(($135|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 56) {\n   return;\n  }\n } else {\n  if (!($13)) {\n   return;\n  }\n  $14 = ($12|0)>(0);\n  $15 = ((($this)) + 16|0);\n  if ($14) {\n   $row$032$us = 0;\n  } else {\n   return;\n  }\n  L51: while(1) {\n   $col$029$us = 0;\n   while(1) {\n    $16 = HEAP32[$15>>2]|0;\n    $17 = (($16) + (($row$032$us*12)|0)|0);\n    while(1) {\n     $18 = (_fgetc($f)|0);\n     $19 = ($18|0)==(-1);\n     if ($19) {\n      label = 50;\n      break L51;\n     }\n     $20 = $18&255;\n     $21 = ($20<<24>>24)==(35);\n     if ($21) {\n      while(1) {\n       $22 = (_fgetc($f)|0);\n       $23 = ($22|0)==(-1);\n       if ($23) {\n        label = 51;\n        break L51;\n       }\n       $24 = $22&255;\n       $25 = ($24<<24>>24)==(10);\n       if ($25) {\n        $ch$0$i$us = 10;\n        break;\n       }\n      }\n     } else {\n      $ch$0$i$us = $20;\n     }\n     $26 = $ch$0$i$us&255;\n     $27 = (_isspace($26)|0);\n     $28 = ($27|0)==(0);\n     if ($28) {\n      $ch$0$i$us$lcssa = $ch$0$i$us;\n      break;\n     }\n    }\n    switch ($ch$0$i$us$lcssa<<24>>24) {\n    case 48:  {\n     $$0$i$us = 1;\n     break;\n    }\n    case 49:  {\n     $$0$i$us = 0;\n     break;\n    }\n    default: {\n     label = 52;\n     break L51;\n    }\n    }\n    $29 = (((($16) + (($row$032$us*12)|0)|0)) + 4|0);\n    $30 = HEAP32[$29>>2]|0;\n    $31 = (((($16) + (($row$032$us*12)|0)|0)) + 8|0);\n    $32 = HEAP32[$31>>2]|0;\n    $33 = ($30|0)==($32|0);\n    $34 = $32;\n    if ($33) {\n     $37 = $30;\n     $38 = HEAP32[$17>>2]|0;\n     $39 = (($37) - ($38))|0;\n     $40 = (($39) + 1)|0;\n     $41 = ($40|0)<(0);\n     if ($41) {\n      __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($17);\n      $$pre$i$i3$us = HEAP32[$17>>2]|0;\n      $$pre$i5$us = HEAP32[$31>>2]|0;\n      $$in$i$i7$us = $$pre$i$i3$us;$$pre$phi$i6$usZ2D = $31;$44 = $$pre$i5$us;\n     } else {\n      $$in$i$i7$us = $38;$$pre$phi$i6$usZ2D = $31;$44 = $34;\n     }\n     $42 = $$in$i$i7$us;\n     $43 = (($44) - ($$in$i$i7$us))|0;\n     $45 = ($43>>>0)<(1073741823);\n     if ($45) {\n      $48 = $43 << 1;\n      $49 = ($48>>>0)<($40>>>0);\n      $50 = $49 ? $40 : $48;\n      $51 = HEAP32[$29>>2]|0;\n      $52 = (($51) - ($$in$i$i7$us))|0;\n      $53 = ($50|0)==(0);\n      if ($53) {\n       $$0$i2$i$i11$us = 0;$56 = 0;$57 = $52;$63 = $51;\n      } else {\n       $$0$i1$i$i10$us = $50;$136 = $51;$137 = $52;\n       label = 20;\n      }\n     } else {\n      $46 = HEAP32[$29>>2]|0;\n      $47 = (($46) - ($$in$i$i7$us))|0;\n      $$0$i1$i$i10$us = 2147483647;$136 = $46;$137 = $47;\n      label = 20;\n     }\n     if ((label|0) == 20) {\n      label = 0;\n      $54 = (__Znwj($$0$i1$i$i10$us)|0);\n      $$0$i2$i$i11$us = $$0$i1$i$i10$us;$56 = $54;$57 = $137;$63 = $136;\n     }\n     $55 = (($56) + ($57)|0);\n     $58 = (($56) + ($$0$i2$i$i11$us)|0);\n     $59 = $58;\n     HEAP8[$55>>0] = $$0$i$us;\n     $60 = ((($55)) + 1|0);\n     $61 = $60;\n     $62 = (($63) - ($$in$i$i7$us))|0;\n     $64 = (0 - ($62))|0;\n     $65 = (($55) + ($64)|0);\n     $66 = $65;\n     _memcpy(($65|0),($42|0),($62|0))|0;\n     HEAP32[$17>>2] = $66;\n     HEAP32[$29>>2] = $61;\n     HEAP32[$$pre$phi$i6$usZ2D>>2] = $59;\n     $67 = ($$in$i$i7$us|0)==(0);\n     if (!($67)) {\n      __ZdlPv($42);\n     }\n    } else {\n     HEAP8[$30>>0] = $$0$i$us;\n     $35 = HEAP32[$29>>2]|0;\n     $36 = ((($35)) + 1|0);\n     HEAP32[$29>>2] = $36;\n    }\n    $68 = (($col$029$us) + 1)|0;\n    $69 = ($68|0)<($12|0);\n    if ($69) {\n     $col$029$us = $68;\n    } else {\n     break;\n    }\n   }\n   $70 = (($row$032$us) + 1)|0;\n   $71 = ($70|0)<($7|0);\n   if ($71) {\n    $row$032$us = $70;\n   } else {\n    label = 56;\n    break;\n   }\n  }\n  if ((label|0) == 50) {\n   $130 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$130>>2] = 872;\n   ___cxa_throw(($130|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 51) {\n   $131 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$131>>2] = 872;\n   ___cxa_throw(($131|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 52) {\n   $132 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$132>>2] = 923;\n   ___cxa_throw(($132|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 56) {\n   return;\n  }\n }\n}\nfunction __ZN10Page_image7read_p4EP8_IO_FILEb($this,$f,$invert) {\n $this = $this|0;\n $f = $f|0;\n $invert = $invert|0;\n var $$0$i1$i$i$us = 0, $$0$i1$i$i12$us = 0, $$0$i2$i$i$us = 0, $$0$i2$i$i13$us = 0, $$in$i$i$us = 0, $$in$i$i9$us = 0, $$pre$i$i$us = 0, $$pre$i$i5$us = 0, $$pre$i$us = 0, $$pre$i7$us = 0, $$pre$phi$i$usZ2D = 0, $$pre$phi$i8$usZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0;\n var $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0;\n var $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0;\n var $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0;\n var $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0;\n var $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0;\n var $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0;\n var $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $col$030$us = 0, $col$1$lcssa$us = 0, $col$127$us = 0, $col2$022$us = 0, $col2$1$lcssa$us = 0, $col2$121$us = 0, $not$$us = 0, $or$cond$us = 0, $or$cond2$us = 0, $row$032$us = 0, $row1$024$us = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ((($this)) + 28|0);\n HEAP8[$0>>0] = 1;\n $1 = ((($this)) + 29|0);\n HEAP8[$1>>0] = 0;\n $2 = ((($this)) + 12|0);\n $3 = HEAP32[$2>>2]|0;\n $4 = ((($this)) + 4|0);\n $5 = HEAP32[$4>>2]|0;\n $6 = (($3) + 1)|0;\n $7 = (($6) - ($5))|0;\n $8 = ((($this)) + 8|0);\n $9 = HEAP32[$8>>2]|0;\n $10 = HEAP32[$this>>2]|0;\n $11 = (($9) + 1)|0;\n $12 = (($11) - ($10))|0;\n $13 = ($7|0)>(0);\n if ($invert) {\n  if (!($13)) {\n   return;\n  }\n  $70 = ($12|0)>(0);\n  $71 = ((($this)) + 16|0);\n  if ($70) {\n   $row1$024$us = 0;\n  } else {\n   return;\n  }\n  L8: while(1) {\n   $col2$022$us = 0;\n   while(1) {\n    $72 = (_fgetc($f)|0);\n    $73 = ($72|0)==(-1);\n    if ($73) {\n     label = 41;\n     break L8;\n    }\n    $123 = ($col2$022$us|0)<($12|0);\n    if ($123) {\n     $77 = 128;$col2$121$us = $col2$022$us;\n     while(1) {\n      $74 = HEAP32[$71>>2]|0;\n      $75 = (($74) + (($row1$024$us*12)|0)|0);\n      $76 = $77 & $72;\n      $78 = ($76|0)!=(0);\n      $79 = $78&1;\n      $80 = (((($74) + (($row1$024$us*12)|0)|0)) + 4|0);\n      $81 = HEAP32[$80>>2]|0;\n      $82 = (((($74) + (($row1$024$us*12)|0)|0)) + 8|0);\n      $83 = HEAP32[$82>>2]|0;\n      $84 = ($81|0)==($83|0);\n      $85 = $83;\n      if ($84) {\n       $88 = $81;\n       $89 = HEAP32[$75>>2]|0;\n       $90 = (($88) - ($89))|0;\n       $91 = (($90) + 1)|0;\n       $92 = ($91|0)<(0);\n       if ($92) {\n        __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($75);\n        $$pre$i$i$us = HEAP32[$75>>2]|0;\n        $$pre$i$us = HEAP32[$82>>2]|0;\n        $$in$i$i$us = $$pre$i$i$us;$$pre$phi$i$usZ2D = $82;$95 = $$pre$i$us;\n       } else {\n        $$in$i$i$us = $89;$$pre$phi$i$usZ2D = $82;$95 = $85;\n       }\n       $93 = $$in$i$i$us;\n       $94 = (($95) - ($$in$i$i$us))|0;\n       $96 = ($94>>>0)<(1073741823);\n       if ($96) {\n        $99 = $94 << 1;\n        $100 = ($99>>>0)<($91>>>0);\n        $101 = $100 ? $91 : $99;\n        $102 = HEAP32[$80>>2]|0;\n        $103 = (($102) - ($$in$i$i$us))|0;\n        $104 = ($101|0)==(0);\n        if ($104) {\n         $$0$i2$i$i$us = 0;$107 = 0;$108 = $103;$114 = $102;\n        } else {\n         $$0$i1$i$i$us = $101;$131 = $102;$132 = $103;\n         label = 32;\n        }\n       } else {\n        $97 = HEAP32[$80>>2]|0;\n        $98 = (($97) - ($$in$i$i$us))|0;\n        $$0$i1$i$i$us = 2147483647;$131 = $97;$132 = $98;\n        label = 32;\n       }\n       if ((label|0) == 32) {\n        label = 0;\n        $105 = (__Znwj($$0$i1$i$i$us)|0);\n        $$0$i2$i$i$us = $$0$i1$i$i$us;$107 = $105;$108 = $132;$114 = $131;\n       }\n       $106 = (($107) + ($108)|0);\n       $109 = (($107) + ($$0$i2$i$i$us)|0);\n       $110 = $109;\n       HEAP8[$106>>0] = $79;\n       $111 = ((($106)) + 1|0);\n       $112 = $111;\n       $113 = (($114) - ($$in$i$i$us))|0;\n       $115 = (0 - ($113))|0;\n       $116 = (($106) + ($115)|0);\n       $117 = $116;\n       _memcpy(($116|0),($93|0),($113|0))|0;\n       HEAP32[$75>>2] = $117;\n       HEAP32[$80>>2] = $112;\n       HEAP32[$$pre$phi$i$usZ2D>>2] = $110;\n       $118 = ($$in$i$i$us|0)==(0);\n       if (!($118)) {\n        __ZdlPv($93);\n       }\n      } else {\n       HEAP8[$81>>0] = $79;\n       $86 = HEAP32[$80>>2]|0;\n       $87 = ((($86)) + 1|0);\n       HEAP32[$80>>2] = $87;\n      }\n      $119 = $77 >>> 1;\n      $120 = (($col2$121$us) + 1)|0;\n      $121 = ($119|0)!=(0);\n      $122 = ($120|0)<($12|0);\n      $or$cond2$us = $122 & $121;\n      if ($or$cond2$us) {\n       $77 = $119;$col2$121$us = $120;\n      } else {\n       $col2$1$lcssa$us = $120;\n       break;\n      }\n     }\n    } else {\n     $col2$1$lcssa$us = $col2$022$us;\n    }\n    $124 = ($col2$1$lcssa$us|0)<($12|0);\n    if ($124) {\n     $col2$022$us = $col2$1$lcssa$us;\n    } else {\n     break;\n    }\n   }\n   $125 = (($row1$024$us) + 1)|0;\n   $126 = ($125|0)<($7|0);\n   if ($126) {\n    $row1$024$us = $125;\n   } else {\n    label = 42;\n    break;\n   }\n  }\n  if ((label|0) == 41) {\n   $128 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$128>>2] = 872;\n   ___cxa_throw(($128|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 42) {\n   return;\n  }\n } else {\n  if (!($13)) {\n   return;\n  }\n  $14 = ($12|0)>(0);\n  $15 = ((($this)) + 16|0);\n  if ($14) {\n   $row$032$us = 0;\n  } else {\n   return;\n  }\n  L42: while(1) {\n   $col$030$us = 0;\n   while(1) {\n    $16 = (_fgetc($f)|0);\n    $17 = ($16|0)==(-1);\n    if ($17) {\n     label = 40;\n     break L42;\n    }\n    $66 = ($col$030$us|0)<($12|0);\n    if ($66) {\n     $21 = 128;$col$127$us = $col$030$us;\n     while(1) {\n      $18 = HEAP32[$15>>2]|0;\n      $19 = (($18) + (($row$032$us*12)|0)|0);\n      $20 = $21 & $16;\n      $not$$us = ($20|0)==(0);\n      $22 = $not$$us&1;\n      $23 = (((($18) + (($row$032$us*12)|0)|0)) + 4|0);\n      $24 = HEAP32[$23>>2]|0;\n      $25 = (((($18) + (($row$032$us*12)|0)|0)) + 8|0);\n      $26 = HEAP32[$25>>2]|0;\n      $27 = ($24|0)==($26|0);\n      $28 = $26;\n      if ($27) {\n       $31 = $24;\n       $32 = HEAP32[$19>>2]|0;\n       $33 = (($31) - ($32))|0;\n       $34 = (($33) + 1)|0;\n       $35 = ($34|0)<(0);\n       if ($35) {\n        __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($19);\n        $$pre$i$i5$us = HEAP32[$19>>2]|0;\n        $$pre$i7$us = HEAP32[$25>>2]|0;\n        $$in$i$i9$us = $$pre$i$i5$us;$$pre$phi$i8$usZ2D = $25;$38 = $$pre$i7$us;\n       } else {\n        $$in$i$i9$us = $32;$$pre$phi$i8$usZ2D = $25;$38 = $28;\n       }\n       $36 = $$in$i$i9$us;\n       $37 = (($38) - ($$in$i$i9$us))|0;\n       $39 = ($37>>>0)<(1073741823);\n       if ($39) {\n        $42 = $37 << 1;\n        $43 = ($42>>>0)<($34>>>0);\n        $44 = $43 ? $34 : $42;\n        $45 = HEAP32[$23>>2]|0;\n        $46 = (($45) - ($$in$i$i9$us))|0;\n        $47 = ($44|0)==(0);\n        if ($47) {\n         $$0$i2$i$i13$us = 0;$50 = 0;$51 = $46;$57 = $45;\n        } else {\n         $$0$i1$i$i12$us = $44;$129 = $45;$130 = $46;\n         label = 13;\n        }\n       } else {\n        $40 = HEAP32[$23>>2]|0;\n        $41 = (($40) - ($$in$i$i9$us))|0;\n        $$0$i1$i$i12$us = 2147483647;$129 = $40;$130 = $41;\n        label = 13;\n       }\n       if ((label|0) == 13) {\n        label = 0;\n        $48 = (__Znwj($$0$i1$i$i12$us)|0);\n        $$0$i2$i$i13$us = $$0$i1$i$i12$us;$50 = $48;$51 = $130;$57 = $129;\n       }\n       $49 = (($50) + ($51)|0);\n       $52 = (($50) + ($$0$i2$i$i13$us)|0);\n       $53 = $52;\n       HEAP8[$49>>0] = $22;\n       $54 = ((($49)) + 1|0);\n       $55 = $54;\n       $56 = (($57) - ($$in$i$i9$us))|0;\n       $58 = (0 - ($56))|0;\n       $59 = (($49) + ($58)|0);\n       $60 = $59;\n       _memcpy(($59|0),($36|0),($56|0))|0;\n       HEAP32[$19>>2] = $60;\n       HEAP32[$23>>2] = $55;\n       HEAP32[$$pre$phi$i8$usZ2D>>2] = $53;\n       $61 = ($$in$i$i9$us|0)==(0);\n       if (!($61)) {\n        __ZdlPv($36);\n       }\n      } else {\n       HEAP8[$24>>0] = $22;\n       $29 = HEAP32[$23>>2]|0;\n       $30 = ((($29)) + 1|0);\n       HEAP32[$23>>2] = $30;\n      }\n      $62 = $21 >>> 1;\n      $63 = (($col$127$us) + 1)|0;\n      $64 = ($62|0)!=(0);\n      $65 = ($63|0)<($12|0);\n      $or$cond$us = $65 & $64;\n      if ($or$cond$us) {\n       $21 = $62;$col$127$us = $63;\n      } else {\n       $col$1$lcssa$us = $63;\n       break;\n      }\n     }\n    } else {\n     $col$1$lcssa$us = $col$030$us;\n    }\n    $67 = ($col$1$lcssa$us|0)<($12|0);\n    if ($67) {\n     $col$030$us = $col$1$lcssa$us;\n    } else {\n     break;\n    }\n   }\n   $68 = (($row$032$us) + 1)|0;\n   $69 = ($68|0)<($7|0);\n   if ($69) {\n    $row$032$us = $68;\n   } else {\n    label = 42;\n    break;\n   }\n  }\n  if ((label|0) == 40) {\n   $127 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$127>>2] = 872;\n   ___cxa_throw(($127|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 42) {\n   return;\n  }\n }\n}\nfunction __ZN10Page_image7read_p2EP8_IO_FILEb($this,$f,$invert) {\n $this = $this|0;\n $f = $f|0;\n $invert = $invert|0;\n var $$ = 0, $$$us = 0, $$0$i1$i$i = 0, $$0$i1$i$i$us = 0, $$0$i2$i$i = 0, $$0$i2$i$i$us = 0, $$in$i$i = 0, $$in$i$i$us = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i$i$us = 0, $$pre$i$us = 0, $$pre$phi$i$usZ2D = 0, $$pre$phi$iZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0;\n var $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0;\n var $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;\n var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;\n var $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0;\n var $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0;\n var $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0;\n var $98 = 0, $99 = 0, $col$02 = 0, $col$02$us = 0, $row$03 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n $1 = ($0|0)==(0);\n if ($1) {\n  $2 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$2>>2] = 1035;\n  ___cxa_throw(($2|0),(8|0),(0|0));\n  // unreachable;\n }\n $3 = ($0|0)>(255);\n $4 = $3 ? 255 : $0;\n $5 = $4&255;\n $6 = ((($this)) + 28|0);\n HEAP8[$6>>0] = $5;\n $7 = $4 >>> 1;\n $8 = $7 & 127;\n $9 = $8&255;\n $10 = ((($this)) + 29|0);\n HEAP8[$10>>0] = $9;\n $11 = ((($this)) + 12|0);\n $12 = HEAP32[$11>>2]|0;\n $13 = ((($this)) + 4|0);\n $14 = HEAP32[$13>>2]|0;\n $15 = (($12) + 1)|0;\n $16 = (($15) - ($14))|0;\n $17 = ((($this)) + 8|0);\n $18 = HEAP32[$17>>2]|0;\n $19 = HEAP32[$this>>2]|0;\n $20 = (($18) + 1)|0;\n $21 = (($20) - ($19))|0;\n $22 = ($16|0)>(0);\n if (!($22)) {\n  return;\n }\n $23 = ($21|0)>(0);\n $24 = ((($this)) + 16|0);\n $row$03 = 0;\n L7: while(1) {\n  if ($23) {\n   if ($3) {\n    $col$02$us = 0;\n    while(1) {\n     $25 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n     $26 = ($0|0)<($25|0);\n     if ($26) {\n      label = 23;\n      break L7;\n     }\n     $27 = (($0) - ($25))|0;\n     $$$us = $invert ? $27 : $25;\n     $28 = ($$$us*255)|0;\n     $29 = (($28|0) / ($0|0))&-1;\n     $30 = HEAP32[$24>>2]|0;\n     $31 = (($30) + (($row$03*12)|0)|0);\n     $32 = $29&255;\n     $33 = (((($30) + (($row$03*12)|0)|0)) + 4|0);\n     $34 = HEAP32[$33>>2]|0;\n     $35 = (((($30) + (($row$03*12)|0)|0)) + 8|0);\n     $36 = HEAP32[$35>>2]|0;\n     $37 = ($34|0)==($36|0);\n     $38 = $36;\n     if ($37) {\n      $41 = $34;\n      $42 = HEAP32[$31>>2]|0;\n      $43 = (($41) - ($42))|0;\n      $44 = (($43) + 1)|0;\n      $45 = ($44|0)<(0);\n      if ($45) {\n       __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($31);\n       $$pre$i$i$us = HEAP32[$31>>2]|0;\n       $$pre$i$us = HEAP32[$35>>2]|0;\n       $$in$i$i$us = $$pre$i$i$us;$$pre$phi$i$usZ2D = $35;$48 = $$pre$i$us;\n      } else {\n       $$in$i$i$us = $42;$$pre$phi$i$usZ2D = $35;$48 = $38;\n      }\n      $46 = $$in$i$i$us;\n      $47 = (($48) - ($$in$i$i$us))|0;\n      $49 = ($47>>>0)<(1073741823);\n      if ($49) {\n       $52 = $47 << 1;\n       $53 = ($52>>>0)<($44>>>0);\n       $54 = $53 ? $44 : $52;\n       $55 = HEAP32[$33>>2]|0;\n       $56 = (($55) - ($$in$i$i$us))|0;\n       $57 = ($54|0)==(0);\n       if ($57) {\n        $$0$i2$i$i$us = 0;$60 = 0;$61 = $56;$67 = $55;\n       } else {\n        $$0$i1$i$i$us = $54;$124 = $55;$125 = $56;\n        label = 16;\n       }\n      } else {\n       $50 = HEAP32[$33>>2]|0;\n       $51 = (($50) - ($$in$i$i$us))|0;\n       $$0$i1$i$i$us = 2147483647;$124 = $50;$125 = $51;\n       label = 16;\n      }\n      if ((label|0) == 16) {\n       label = 0;\n       $58 = (__Znwj($$0$i1$i$i$us)|0);\n       $$0$i2$i$i$us = $$0$i1$i$i$us;$60 = $58;$61 = $125;$67 = $124;\n      }\n      $59 = (($60) + ($61)|0);\n      $62 = (($60) + ($$0$i2$i$i$us)|0);\n      $63 = $62;\n      HEAP8[$59>>0] = $32;\n      $64 = ((($59)) + 1|0);\n      $65 = $64;\n      $66 = (($67) - ($$in$i$i$us))|0;\n      $68 = (0 - ($66))|0;\n      $69 = (($59) + ($68)|0);\n      $70 = $69;\n      _memcpy(($69|0),($46|0),($66|0))|0;\n      HEAP32[$31>>2] = $70;\n      HEAP32[$33>>2] = $65;\n      HEAP32[$$pre$phi$i$usZ2D>>2] = $63;\n      $71 = ($$in$i$i$us|0)==(0);\n      if (!($71)) {\n       __ZdlPv($46);\n      }\n     } else {\n      HEAP8[$34>>0] = $32;\n      $39 = HEAP32[$33>>2]|0;\n      $40 = ((($39)) + 1|0);\n      HEAP32[$33>>2] = $40;\n     }\n     $72 = (($col$02$us) + 1)|0;\n     $73 = ($72|0)<($21|0);\n     if ($73) {\n      $col$02$us = $72;\n     } else {\n      break;\n     }\n    }\n   } else {\n    $col$02 = 0;\n    while(1) {\n     $76 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n     $77 = ($0|0)<($76|0);\n     if ($77) {\n      label = 23;\n      break L7;\n     }\n     $79 = (($0) - ($76))|0;\n     $$ = $invert ? $79 : $76;\n     $80 = HEAP32[$24>>2]|0;\n     $81 = (($80) + (($row$03*12)|0)|0);\n     $82 = $$&255;\n     $83 = (((($80) + (($row$03*12)|0)|0)) + 4|0);\n     $84 = HEAP32[$83>>2]|0;\n     $85 = (((($80) + (($row$03*12)|0)|0)) + 8|0);\n     $86 = HEAP32[$85>>2]|0;\n     $87 = ($84|0)==($86|0);\n     $88 = $86;\n     if ($87) {\n      $91 = $84;\n      $92 = HEAP32[$81>>2]|0;\n      $93 = (($91) - ($92))|0;\n      $94 = (($93) + 1)|0;\n      $95 = ($94|0)<(0);\n      if ($95) {\n       __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($81);\n       $$pre$i$i = HEAP32[$81>>2]|0;\n       $$pre$i = HEAP32[$85>>2]|0;\n       $$in$i$i = $$pre$i$i;$$pre$phi$iZ2D = $85;$98 = $$pre$i;\n      } else {\n       $$in$i$i = $92;$$pre$phi$iZ2D = $85;$98 = $88;\n      }\n      $96 = $$in$i$i;\n      $97 = (($98) - ($$in$i$i))|0;\n      $99 = ($97>>>0)<(1073741823);\n      if ($99) {\n       $102 = $97 << 1;\n       $103 = ($102>>>0)<($94>>>0);\n       $104 = $103 ? $94 : $102;\n       $105 = HEAP32[$83>>2]|0;\n       $106 = (($105) - ($$in$i$i))|0;\n       $107 = ($104|0)==(0);\n       if ($107) {\n        $$0$i2$i$i = 0;$110 = 0;$111 = $106;$117 = $105;\n       } else {\n        $$0$i1$i$i = $104;$126 = $105;$127 = $106;\n        label = 32;\n       }\n      } else {\n       $100 = HEAP32[$83>>2]|0;\n       $101 = (($100) - ($$in$i$i))|0;\n       $$0$i1$i$i = 2147483647;$126 = $100;$127 = $101;\n       label = 32;\n      }\n      if ((label|0) == 32) {\n       label = 0;\n       $108 = (__Znwj($$0$i1$i$i)|0);\n       $$0$i2$i$i = $$0$i1$i$i;$110 = $108;$111 = $127;$117 = $126;\n      }\n      $109 = (($110) + ($111)|0);\n      $112 = (($110) + ($$0$i2$i$i)|0);\n      $113 = $112;\n      HEAP8[$109>>0] = $82;\n      $114 = ((($109)) + 1|0);\n      $115 = $114;\n      $116 = (($117) - ($$in$i$i))|0;\n      $118 = (0 - ($116))|0;\n      $119 = (($109) + ($118)|0);\n      $120 = $119;\n      _memcpy(($119|0),($96|0),($116|0))|0;\n      HEAP32[$81>>2] = $120;\n      HEAP32[$83>>2] = $115;\n      HEAP32[$$pre$phi$iZ2D>>2] = $113;\n      $121 = ($$in$i$i|0)==(0);\n      if (!($121)) {\n       __ZdlPv($96);\n      }\n     } else {\n      HEAP8[$84>>0] = $82;\n      $89 = HEAP32[$83>>2]|0;\n      $90 = ((($89)) + 1|0);\n      HEAP32[$83>>2] = $90;\n     }\n     $122 = (($col$02) + 1)|0;\n     $123 = ($122|0)<($21|0);\n     if ($123) {\n      $col$02 = $122;\n     } else {\n      break;\n     }\n    }\n   }\n  }\n  $74 = (($row$03) + 1)|0;\n  $75 = ($74|0)<($16|0);\n  if ($75) {\n   $row$03 = $74;\n  } else {\n   label = 20;\n   break;\n  }\n }\n if ((label|0) == 20) {\n  return;\n }\n else if ((label|0) == 23) {\n  $78 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$78>>2] = 1060;\n  ___cxa_throw(($78|0),(8|0),(0|0));\n  // unreachable;\n }\n}\nfunction __ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f) {\n $f = $f|0;\n var $$lcssa = 0, $$lcssa19 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;\n var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $ch$0 = 0, $ch$0$i = 0, $ch$0$i$lcssa = 0, $ch$0$i5 = 0, $i$0 = 0;\n var $isdigit = 0, $isdigit2 = 0, $isdigittmp = 0, $isdigittmp1 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n L1: while(1) {\n  $0 = (_fgetc($f)|0);\n  $1 = ($0|0)==(-1);\n  if ($1) {\n   label = 3;\n   break;\n  }\n  $3 = $0&255;\n  $4 = ($3<<24>>24)==(35);\n  if ($4) {\n   while(1) {\n    $5 = (_fgetc($f)|0);\n    $6 = ($5|0)==(-1);\n    if ($6) {\n     label = 6;\n     break L1;\n    }\n    $8 = $5&255;\n    $9 = ($8<<24>>24)==(10);\n    if ($9) {\n     $ch$0$i = 10;\n     break;\n    }\n   }\n  } else {\n   $ch$0$i = $3;\n  }\n  $10 = $ch$0$i&255;\n  $11 = (_isspace($10)|0);\n  $12 = ($11|0)==(0);\n  if ($12) {\n   $$lcssa = $10;$ch$0$i$lcssa = $ch$0$i;\n   label = 9;\n   break;\n  }\n }\n if ((label|0) == 3) {\n  $2 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$2>>2] = 872;\n  ___cxa_throw(($2|0),(8|0),(0|0));\n  // unreachable;\n }\n else if ((label|0) == 6) {\n  $7 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$7>>2] = 872;\n  ___cxa_throw(($7|0),(8|0),(0|0));\n  // unreachable;\n }\n else if ((label|0) == 9) {\n  $isdigittmp = (($$lcssa) + -48)|0;\n  $isdigit = ($isdigittmp>>>0)<(10);\n  if ($isdigit) {\n   $ch$0 = $ch$0$i$lcssa;$i$0 = 0;\n  } else {\n   $13 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$13>>2] = 962;\n   ___cxa_throw(($13|0),(8|0),(0|0));\n   // unreachable;\n  }\n  L14: while(1) {\n   $14 = $ch$0&255;\n   $15 = (-2147483601 - ($14))|0;\n   $16 = (($15|0) / 10)&-1;\n   $17 = ($16|0)<($i$0|0);\n   if ($17) {\n    label = 12;\n    break;\n   }\n   $19 = (($14) + -48)|0;\n   $20 = ($i$0*10)|0;\n   $21 = (($19) + ($20))|0;\n   $22 = (_fgetc($f)|0);\n   $23 = ($22|0)==(-1);\n   if ($23) {\n    label = 14;\n    break;\n   }\n   $25 = $22&255;\n   $26 = ($25<<24>>24)==(35);\n   if ($26) {\n    while(1) {\n     $27 = (_fgetc($f)|0);\n     $28 = ($27|0)==(-1);\n     if ($28) {\n      label = 17;\n      break L14;\n     }\n     $30 = $27&255;\n     $31 = ($30<<24>>24)==(10);\n     if ($31) {\n      $ch$0$i5 = 10;\n      break;\n     }\n    }\n   } else {\n    $ch$0$i5 = $25;\n   }\n   $32 = $ch$0$i5&255;\n   $isdigittmp1 = (($32) + -48)|0;\n   $isdigit2 = ($isdigittmp1>>>0)<(10);\n   if ($isdigit2) {\n    $ch$0 = $ch$0$i5;$i$0 = $21;\n   } else {\n    $$lcssa19 = $21;\n    label = 20;\n    break;\n   }\n  }\n  if ((label|0) == 12) {\n   $18 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$18>>2] = 1007;\n   ___cxa_throw(($18|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 14) {\n   $24 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$24>>2] = 872;\n   ___cxa_throw(($24|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 17) {\n   $29 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$29>>2] = 872;\n   ___cxa_throw(($29|0),(8|0),(0|0));\n   // unreachable;\n  }\n  else if ((label|0) == 20) {\n   return ($$lcssa19|0);\n  }\n }\n return (0)|0;\n}\nfunction __ZN10Page_image7read_p5EP8_IO_FILEb($this,$f,$invert) {\n $this = $this|0;\n $f = $f|0;\n $invert = $invert|0;\n var $$0$i1$i$i = 0, $$0$i1$i$i$us = 0, $$0$i2$i$i = 0, $$0$i2$i$i$us = 0, $$in$i$i = 0, $$in$i$i$us = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i$i$us = 0, $$pre$i$us = 0, $$pre$phi$i$usZ2D = 0, $$pre$phi$iZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0;\n var $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0;\n var $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0;\n var $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0;\n var $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0;\n var $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0;\n var $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0;\n var $96 = 0, $97 = 0, $98 = 0, $99 = 0, $col$02 = 0, $col$02$us = 0, $row$03 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n $1 = ($0|0)==(0);\n if ($1) {\n  $2 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$2>>2] = 1035;\n  ___cxa_throw(($2|0),(8|0),(0|0));\n  // unreachable;\n }\n $3 = ($0|0)>(255);\n if ($3) {\n  $4 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$4>>2] = 1088;\n  ___cxa_throw(($4|0),(8|0),(0|0));\n  // unreachable;\n }\n $5 = $0&255;\n $6 = ((($this)) + 28|0);\n HEAP8[$6>>0] = $5;\n $7 = $0 >>> 1;\n $8 = $7 & 127;\n $9 = $8&255;\n $10 = ((($this)) + 29|0);\n HEAP8[$10>>0] = $9;\n $11 = ((($this)) + 12|0);\n $12 = HEAP32[$11>>2]|0;\n $13 = ((($this)) + 4|0);\n $14 = HEAP32[$13>>2]|0;\n $15 = (($12) + 1)|0;\n $16 = (($15) - ($14))|0;\n $17 = ((($this)) + 8|0);\n $18 = HEAP32[$17>>2]|0;\n $19 = HEAP32[$this>>2]|0;\n $20 = (($18) + 1)|0;\n $21 = (($20) - ($19))|0;\n $22 = ($16|0)>(0);\n if (!($22)) {\n  return;\n }\n $23 = ($21|0)>(0);\n $24 = ((($this)) + 16|0);\n $row$03 = 0;\n L10: while(1) {\n  if ($23) {\n   if ($invert) {\n    $col$02$us = 0;\n    while(1) {\n     $25 = (_fgetc($f)|0);\n     $26 = ($25|0)==(-1);\n     if ($26) {\n      label = 26;\n      break L10;\n     }\n     $27 = $25&255;\n     $28 = HEAP8[$6>>0]|0;\n     $29 = ($28&255)<($27&255);\n     if ($29) {\n      label = 28;\n      break L10;\n     }\n     $30 = $28&255;\n     $31 = (($30) - ($25))|0;\n     $32 = $31&255;\n     $33 = HEAP32[$24>>2]|0;\n     $34 = (($33) + (($row$03*12)|0)|0);\n     $35 = (((($33) + (($row$03*12)|0)|0)) + 4|0);\n     $36 = HEAP32[$35>>2]|0;\n     $37 = (((($33) + (($row$03*12)|0)|0)) + 8|0);\n     $38 = HEAP32[$37>>2]|0;\n     $39 = ($36|0)==($38|0);\n     $40 = $38;\n     if ($39) {\n      $43 = $36;\n      $44 = HEAP32[$34>>2]|0;\n      $45 = (($43) - ($44))|0;\n      $46 = (($45) + 1)|0;\n      $47 = ($46|0)<(0);\n      if ($47) {\n       __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($34);\n       $$pre$i$i$us = HEAP32[$34>>2]|0;\n       $$pre$i$us = HEAP32[$37>>2]|0;\n       $$in$i$i$us = $$pre$i$i$us;$$pre$phi$i$usZ2D = $37;$50 = $$pre$i$us;\n      } else {\n       $$in$i$i$us = $44;$$pre$phi$i$usZ2D = $37;$50 = $40;\n      }\n      $48 = $$in$i$i$us;\n      $49 = (($50) - ($$in$i$i$us))|0;\n      $51 = ($49>>>0)<(1073741823);\n      if ($51) {\n       $54 = $49 << 1;\n       $55 = ($54>>>0)<($46>>>0);\n       $56 = $55 ? $46 : $54;\n       $57 = HEAP32[$35>>2]|0;\n       $58 = (($57) - ($$in$i$i$us))|0;\n       $59 = ($56|0)==(0);\n       if ($59) {\n        $$0$i2$i$i$us = 0;$62 = 0;$63 = $58;$69 = $57;\n       } else {\n        $$0$i1$i$i$us = $56;$128 = $57;$129 = $58;\n        label = 19;\n       }\n      } else {\n       $52 = HEAP32[$35>>2]|0;\n       $53 = (($52) - ($$in$i$i$us))|0;\n       $$0$i1$i$i$us = 2147483647;$128 = $52;$129 = $53;\n       label = 19;\n      }\n      if ((label|0) == 19) {\n       label = 0;\n       $60 = (__Znwj($$0$i1$i$i$us)|0);\n       $$0$i2$i$i$us = $$0$i1$i$i$us;$62 = $60;$63 = $129;$69 = $128;\n      }\n      $61 = (($62) + ($63)|0);\n      $64 = (($62) + ($$0$i2$i$i$us)|0);\n      $65 = $64;\n      HEAP8[$61>>0] = $32;\n      $66 = ((($61)) + 1|0);\n      $67 = $66;\n      $68 = (($69) - ($$in$i$i$us))|0;\n      $70 = (0 - ($68))|0;\n      $71 = (($61) + ($70)|0);\n      $72 = $71;\n      _memcpy(($71|0),($48|0),($68|0))|0;\n      HEAP32[$34>>2] = $72;\n      HEAP32[$35>>2] = $67;\n      HEAP32[$$pre$phi$i$usZ2D>>2] = $65;\n      $73 = ($$in$i$i$us|0)==(0);\n      if (!($73)) {\n       __ZdlPv($48);\n      }\n     } else {\n      HEAP8[$36>>0] = $32;\n      $41 = HEAP32[$35>>2]|0;\n      $42 = ((($41)) + 1|0);\n      HEAP32[$35>>2] = $42;\n     }\n     $74 = (($col$02$us) + 1)|0;\n     $75 = ($74|0)<($21|0);\n     if ($75) {\n      $col$02$us = $74;\n     } else {\n      break;\n     }\n    }\n   } else {\n    $col$02 = 0;\n    while(1) {\n     $78 = (_fgetc($f)|0);\n     $79 = ($78|0)==(-1);\n     if ($79) {\n      label = 26;\n      break L10;\n     }\n     $81 = $78&255;\n     $82 = HEAP8[$6>>0]|0;\n     $83 = ($82&255)<($81&255);\n     if ($83) {\n      label = 28;\n      break L10;\n     }\n     $85 = HEAP32[$24>>2]|0;\n     $86 = (($85) + (($row$03*12)|0)|0);\n     $87 = (((($85) + (($row$03*12)|0)|0)) + 4|0);\n     $88 = HEAP32[$87>>2]|0;\n     $89 = (((($85) + (($row$03*12)|0)|0)) + 8|0);\n     $90 = HEAP32[$89>>2]|0;\n     $91 = ($88|0)==($90|0);\n     $92 = $90;\n     if ($91) {\n      $95 = $88;\n      $96 = HEAP32[$86>>2]|0;\n      $97 = (($95) - ($96))|0;\n      $98 = (($97) + 1)|0;\n      $99 = ($98|0)<(0);\n      if ($99) {\n       __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($86);\n       $$pre$i$i = HEAP32[$86>>2]|0;\n       $$pre$i = HEAP32[$89>>2]|0;\n       $$in$i$i = $$pre$i$i;$$pre$phi$iZ2D = $89;$102 = $$pre$i;\n      } else {\n       $$in$i$i = $96;$$pre$phi$iZ2D = $89;$102 = $92;\n      }\n      $100 = $$in$i$i;\n      $101 = (($102) - ($$in$i$i))|0;\n      $103 = ($101>>>0)<(1073741823);\n      if ($103) {\n       $106 = $101 << 1;\n       $107 = ($106>>>0)<($98>>>0);\n       $108 = $107 ? $98 : $106;\n       $109 = HEAP32[$87>>2]|0;\n       $110 = (($109) - ($$in$i$i))|0;\n       $111 = ($108|0)==(0);\n       if ($111) {\n        $$0$i2$i$i = 0;$114 = 0;$115 = $110;$121 = $109;\n       } else {\n        $$0$i1$i$i = $108;$130 = $109;$131 = $110;\n        label = 37;\n       }\n      } else {\n       $104 = HEAP32[$87>>2]|0;\n       $105 = (($104) - ($$in$i$i))|0;\n       $$0$i1$i$i = 2147483647;$130 = $104;$131 = $105;\n       label = 37;\n      }\n      if ((label|0) == 37) {\n       label = 0;\n       $112 = (__Znwj($$0$i1$i$i)|0);\n       $$0$i2$i$i = $$0$i1$i$i;$114 = $112;$115 = $131;$121 = $130;\n      }\n      $113 = (($114) + ($115)|0);\n      $116 = (($114) + ($$0$i2$i$i)|0);\n      $117 = $116;\n      HEAP8[$113>>0] = $81;\n      $118 = ((($113)) + 1|0);\n      $119 = $118;\n      $120 = (($121) - ($$in$i$i))|0;\n      $122 = (0 - ($120))|0;\n      $123 = (($113) + ($122)|0);\n      $124 = $123;\n      _memcpy(($123|0),($100|0),($120|0))|0;\n      HEAP32[$86>>2] = $124;\n      HEAP32[$87>>2] = $119;\n      HEAP32[$$pre$phi$iZ2D>>2] = $117;\n      $125 = ($$in$i$i|0)==(0);\n      if (!($125)) {\n       __ZdlPv($100);\n      }\n     } else {\n      HEAP8[$88>>0] = $81;\n      $93 = HEAP32[$87>>2]|0;\n      $94 = ((($93)) + 1|0);\n      HEAP32[$87>>2] = $94;\n     }\n     $126 = (($col$02) + 1)|0;\n     $127 = ($126|0)<($21|0);\n     if ($127) {\n      $col$02 = $126;\n     } else {\n      break;\n     }\n    }\n   }\n  }\n  $76 = (($row$03) + 1)|0;\n  $77 = ($76|0)<($16|0);\n  if ($77) {\n   $row$03 = $76;\n  } else {\n   label = 23;\n   break;\n  }\n }\n if ((label|0) == 23) {\n  return;\n }\n else if ((label|0) == 26) {\n  $80 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$80>>2] = 872;\n  ___cxa_throw(($80|0),(8|0),(0|0));\n  // unreachable;\n }\n else if ((label|0) == 28) {\n  $84 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$84>>2] = 1060;\n  ___cxa_throw(($84|0),(8|0),(0|0));\n  // unreachable;\n }\n}\nfunction __ZN10Page_image7read_p3EP8_IO_FILEb($this,$f,$invert) {\n $this = $this|0;\n $f = $f|0;\n $invert = $invert|0;\n var $$0$i1$i$i = 0, $$0$i1$i$i$us = 0, $$0$i2$i$i = 0, $$0$i2$i$i$us = 0, $$in$i$i = 0, $$in$i$i$us = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i$i$us = 0, $$pre$i$us = 0, $$pre$phi$i$usZ2D = 0, $$pre$phi$iZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0;\n var $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0;\n var $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0;\n var $141 = 0, $142 = 0, $143 = 0, $144 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0;\n var $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0;\n var $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0;\n var $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0;\n var $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $col$06 = 0, $col$06$us = 0, $or$cond = 0;\n var $or$cond$us = 0, $or$cond2 = 0, $or$cond2$us = 0, $row$07 = 0, $val$1 = 0, $val$1$us = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n $1 = ($0|0)==(0);\n if ($1) {\n  $2 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$2>>2] = 1119;\n  ___cxa_throw(($2|0),(8|0),(0|0));\n  // unreachable;\n }\n $3 = ($0|0)>(255);\n $4 = $3 ? 255 : $0;\n $5 = $4&255;\n $6 = ((($this)) + 28|0);\n HEAP8[$6>>0] = $5;\n $7 = $4 >>> 1;\n $8 = $7 & 127;\n $9 = $8&255;\n $10 = ((($this)) + 29|0);\n HEAP8[$10>>0] = $9;\n $11 = ((($this)) + 12|0);\n $12 = HEAP32[$11>>2]|0;\n $13 = ((($this)) + 4|0);\n $14 = HEAP32[$13>>2]|0;\n $15 = (($12) + 1)|0;\n $16 = (($15) - ($14))|0;\n $17 = ((($this)) + 8|0);\n $18 = HEAP32[$17>>2]|0;\n $19 = HEAP32[$this>>2]|0;\n $20 = (($18) + 1)|0;\n $21 = (($20) - ($19))|0;\n $22 = ($16|0)>(0);\n if (!($22)) {\n  return;\n }\n $23 = ($21|0)>(0);\n $24 = ((($this)) + 16|0);\n $row$07 = 0;\n L7: while(1) {\n  if ($23) {\n   if ($invert) {\n    $col$06$us = 0;\n    while(1) {\n     $25 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n     $26 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n     $27 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n     $28 = ($25|0)>($0|0);\n     $29 = ($26|0)>($0|0);\n     $or$cond$us = $28 | $29;\n     $30 = ($27|0)>($0|0);\n     $or$cond2$us = $or$cond$us | $30;\n     if ($or$cond2$us) {\n      label = 25;\n      break L7;\n     }\n     $31 = ($26|0)<($27|0);\n     $32 = $31 ? $27 : $26;\n     $33 = ($25|0)<($32|0);\n     $34 = $33 ? $32 : $25;\n     $35 = (($0) - ($34))|0;\n     if ($3) {\n      $36 = ($35*255)|0;\n      $37 = (($36|0) / ($0|0))&-1;\n      $val$1$us = $37;\n     } else {\n      $val$1$us = $35;\n     }\n     $38 = HEAP32[$24>>2]|0;\n     $39 = (($38) + (($row$07*12)|0)|0);\n     $40 = $val$1$us&255;\n     $41 = (((($38) + (($row$07*12)|0)|0)) + 4|0);\n     $42 = HEAP32[$41>>2]|0;\n     $43 = (((($38) + (($row$07*12)|0)|0)) + 8|0);\n     $44 = HEAP32[$43>>2]|0;\n     $45 = ($42|0)==($44|0);\n     $46 = $44;\n     if ($45) {\n      $49 = $42;\n      $50 = HEAP32[$39>>2]|0;\n      $51 = (($49) - ($50))|0;\n      $52 = (($51) + 1)|0;\n      $53 = ($52|0)<(0);\n      if ($53) {\n       __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($39);\n       $$pre$i$i$us = HEAP32[$39>>2]|0;\n       $$pre$i$us = HEAP32[$43>>2]|0;\n       $$in$i$i$us = $$pre$i$i$us;$$pre$phi$i$usZ2D = $43;$56 = $$pre$i$us;\n      } else {\n       $$in$i$i$us = $50;$$pre$phi$i$usZ2D = $43;$56 = $46;\n      }\n      $54 = $$in$i$i$us;\n      $55 = (($56) - ($$in$i$i$us))|0;\n      $57 = ($55>>>0)<(1073741823);\n      if ($57) {\n       $60 = $55 << 1;\n       $61 = ($60>>>0)<($52>>>0);\n       $62 = $61 ? $52 : $60;\n       $63 = HEAP32[$41>>2]|0;\n       $64 = (($63) - ($$in$i$i$us))|0;\n       $65 = ($62|0)==(0);\n       if ($65) {\n        $$0$i2$i$i$us = 0;$68 = 0;$69 = $64;$75 = $63;\n       } else {\n        $$0$i1$i$i$us = $62;$141 = $63;$142 = $64;\n        label = 18;\n       }\n      } else {\n       $58 = HEAP32[$41>>2]|0;\n       $59 = (($58) - ($$in$i$i$us))|0;\n       $$0$i1$i$i$us = 2147483647;$141 = $58;$142 = $59;\n       label = 18;\n      }\n      if ((label|0) == 18) {\n       label = 0;\n       $66 = (__Znwj($$0$i1$i$i$us)|0);\n       $$0$i2$i$i$us = $$0$i1$i$i$us;$68 = $66;$69 = $142;$75 = $141;\n      }\n      $67 = (($68) + ($69)|0);\n      $70 = (($68) + ($$0$i2$i$i$us)|0);\n      $71 = $70;\n      HEAP8[$67>>0] = $40;\n      $72 = ((($67)) + 1|0);\n      $73 = $72;\n      $74 = (($75) - ($$in$i$i$us))|0;\n      $76 = (0 - ($74))|0;\n      $77 = (($67) + ($76)|0);\n      $78 = $77;\n      _memcpy(($77|0),($54|0),($74|0))|0;\n      HEAP32[$39>>2] = $78;\n      HEAP32[$41>>2] = $73;\n      HEAP32[$$pre$phi$i$usZ2D>>2] = $71;\n      $79 = ($$in$i$i$us|0)==(0);\n      if (!($79)) {\n       __ZdlPv($54);\n      }\n     } else {\n      HEAP8[$42>>0] = $40;\n      $47 = HEAP32[$41>>2]|0;\n      $48 = ((($47)) + 1|0);\n      HEAP32[$41>>2] = $48;\n     }\n     $80 = (($col$06$us) + 1)|0;\n     $81 = ($80|0)<($21|0);\n     if ($81) {\n      $col$06$us = $80;\n     } else {\n      break;\n     }\n    }\n   } else {\n    $col$06 = 0;\n    while(1) {\n     $84 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n     $85 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n     $86 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n     $87 = ($84|0)>($0|0);\n     $88 = ($85|0)>($0|0);\n     $or$cond = $87 | $88;\n     $89 = ($86|0)>($0|0);\n     $or$cond2 = $or$cond | $89;\n     if ($or$cond2) {\n      label = 25;\n      break L7;\n     }\n     $91 = ($86|0)<($85|0);\n     $92 = $91 ? $86 : $85;\n     $93 = ($92|0)<($84|0);\n     $94 = $93 ? $92 : $84;\n     if ($3) {\n      $95 = ($94*255)|0;\n      $96 = (($95|0) / ($0|0))&-1;\n      $val$1 = $96;\n     } else {\n      $val$1 = $94;\n     }\n     $97 = HEAP32[$24>>2]|0;\n     $98 = (($97) + (($row$07*12)|0)|0);\n     $99 = $val$1&255;\n     $100 = (((($97) + (($row$07*12)|0)|0)) + 4|0);\n     $101 = HEAP32[$100>>2]|0;\n     $102 = (((($97) + (($row$07*12)|0)|0)) + 8|0);\n     $103 = HEAP32[$102>>2]|0;\n     $104 = ($101|0)==($103|0);\n     $105 = $103;\n     if ($104) {\n      $108 = $101;\n      $109 = HEAP32[$98>>2]|0;\n      $110 = (($108) - ($109))|0;\n      $111 = (($110) + 1)|0;\n      $112 = ($111|0)<(0);\n      if ($112) {\n       __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($98);\n       $$pre$i$i = HEAP32[$98>>2]|0;\n       $$pre$i = HEAP32[$102>>2]|0;\n       $$in$i$i = $$pre$i$i;$$pre$phi$iZ2D = $102;$115 = $$pre$i;\n      } else {\n       $$in$i$i = $109;$$pre$phi$iZ2D = $102;$115 = $105;\n      }\n      $113 = $$in$i$i;\n      $114 = (($115) - ($$in$i$i))|0;\n      $116 = ($114>>>0)<(1073741823);\n      if ($116) {\n       $119 = $114 << 1;\n       $120 = ($119>>>0)<($111>>>0);\n       $121 = $120 ? $111 : $119;\n       $122 = HEAP32[$100>>2]|0;\n       $123 = (($122) - ($$in$i$i))|0;\n       $124 = ($121|0)==(0);\n       if ($124) {\n        $$0$i2$i$i = 0;$127 = 0;$128 = $123;$134 = $122;\n       } else {\n        $$0$i1$i$i = $121;$143 = $122;$144 = $123;\n        label = 36;\n       }\n      } else {\n       $117 = HEAP32[$100>>2]|0;\n       $118 = (($117) - ($$in$i$i))|0;\n       $$0$i1$i$i = 2147483647;$143 = $117;$144 = $118;\n       label = 36;\n      }\n      if ((label|0) == 36) {\n       label = 0;\n       $125 = (__Znwj($$0$i1$i$i)|0);\n       $$0$i2$i$i = $$0$i1$i$i;$127 = $125;$128 = $144;$134 = $143;\n      }\n      $126 = (($127) + ($128)|0);\n      $129 = (($127) + ($$0$i2$i$i)|0);\n      $130 = $129;\n      HEAP8[$126>>0] = $99;\n      $131 = ((($126)) + 1|0);\n      $132 = $131;\n      $133 = (($134) - ($$in$i$i))|0;\n      $135 = (0 - ($133))|0;\n      $136 = (($126) + ($135)|0);\n      $137 = $136;\n      _memcpy(($136|0),($113|0),($133|0))|0;\n      HEAP32[$98>>2] = $137;\n      HEAP32[$100>>2] = $132;\n      HEAP32[$$pre$phi$iZ2D>>2] = $130;\n      $138 = ($$in$i$i|0)==(0);\n      if (!($138)) {\n       __ZdlPv($113);\n      }\n     } else {\n      HEAP8[$101>>0] = $99;\n      $106 = HEAP32[$100>>2]|0;\n      $107 = ((($106)) + 1|0);\n      HEAP32[$100>>2] = $107;\n     }\n     $139 = (($col$06) + 1)|0;\n     $140 = ($139|0)<($21|0);\n     if ($140) {\n      $col$06 = $139;\n     } else {\n      break;\n     }\n    }\n   }\n  }\n  $82 = (($row$07) + 1)|0;\n  $83 = ($82|0)<($16|0);\n  if ($83) {\n   $row$07 = $82;\n  } else {\n   label = 22;\n   break;\n  }\n }\n if ((label|0) == 22) {\n  return;\n }\n else if ((label|0) == 25) {\n  $90 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$90>>2] = 1144;\n  ___cxa_throw(($90|0),(8|0),(0|0));\n  // unreachable;\n }\n}\nfunction __ZN10Page_image7read_p6EP8_IO_FILEb($this,$f,$invert) {\n $this = $this|0;\n $f = $f|0;\n $invert = $invert|0;\n var $$0$i1$i$i = 0, $$0$i1$i$i$us = 0, $$0$i2$i$i = 0, $$0$i2$i$i$us = 0, $$in$i$i = 0, $$in$i$i$us = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i$i$us = 0, $$pre$i$us = 0, $$pre$phi$i$usZ2D = 0, $$pre$phi$iZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0;\n var $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0;\n var $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0;\n var $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $16 = 0;\n var $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0;\n var $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0;\n var $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0;\n var $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0;\n var $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $col$08 = 0, $col$08$us = 0, $or$cond = 0, $or$cond$us = 0, $or$cond2 = 0, $or$cond2$us = 0, $row$09 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = (__ZN12_GLOBAL__N_110pnm_getintEP8_IO_FILE($f)|0);\n $1 = ($0|0)==(0);\n if ($1) {\n  $2 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$2>>2] = 1119;\n  ___cxa_throw(($2|0),(8|0),(0|0));\n  // unreachable;\n }\n $3 = ($0|0)>(255);\n if ($3) {\n  $4 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$4>>2] = 1172;\n  ___cxa_throw(($4|0),(8|0),(0|0));\n  // unreachable;\n }\n $5 = $0&255;\n $6 = ((($this)) + 28|0);\n HEAP8[$6>>0] = $5;\n $7 = $0 >>> 1;\n $8 = $7 & 127;\n $9 = $8&255;\n $10 = ((($this)) + 29|0);\n HEAP8[$10>>0] = $9;\n $11 = ((($this)) + 12|0);\n $12 = HEAP32[$11>>2]|0;\n $13 = ((($this)) + 4|0);\n $14 = HEAP32[$13>>2]|0;\n $15 = (($12) + 1)|0;\n $16 = (($15) - ($14))|0;\n $17 = ((($this)) + 8|0);\n $18 = HEAP32[$17>>2]|0;\n $19 = HEAP32[$this>>2]|0;\n $20 = (($18) + 1)|0;\n $21 = (($20) - ($19))|0;\n $22 = ($16|0)>(0);\n if (!($22)) {\n  return;\n }\n $23 = ($21|0)>(0);\n $24 = ((($this)) + 16|0);\n $row$09 = 0;\n L10: while(1) {\n  if ($23) {\n   if ($invert) {\n    $col$08$us = 0;\n    while(1) {\n     $25 = (_fgetc($f)|0);\n     $26 = ($25|0)==(-1);\n     if ($26) {\n      label = 28;\n      break L10;\n     }\n     $27 = $25&255;\n     $28 = (_fgetc($f)|0);\n     $29 = ($28|0)==(-1);\n     if ($29) {\n      label = 30;\n      break L10;\n     }\n     $30 = $28&255;\n     $31 = (_fgetc($f)|0);\n     $32 = ($31|0)==(-1);\n     if ($32) {\n      label = 32;\n      break L10;\n     }\n     $33 = $31&255;\n     $34 = HEAP8[$6>>0]|0;\n     $35 = ($27&255)>($34&255);\n     $36 = ($30&255)>($34&255);\n     $or$cond$us = $35 | $36;\n     $37 = ($33&255)>($34&255);\n     $or$cond2$us = $37 | $or$cond$us;\n     if ($or$cond2$us) {\n      label = 34;\n      break L10;\n     }\n     $38 = $34&255;\n     $39 = ($30&255)<($33&255);\n     $40 = $39 ? $33 : $30;\n     $41 = ($27&255)<($40&255);\n     $42 = $41 ? $40 : $27;\n     $43 = $42&255;\n     $44 = (($38) - ($43))|0;\n     $45 = $44&255;\n     $46 = HEAP32[$24>>2]|0;\n     $47 = (($46) + (($row$09*12)|0)|0);\n     $48 = (((($46) + (($row$09*12)|0)|0)) + 4|0);\n     $49 = HEAP32[$48>>2]|0;\n     $50 = (((($46) + (($row$09*12)|0)|0)) + 8|0);\n     $51 = HEAP32[$50>>2]|0;\n     $52 = ($49|0)==($51|0);\n     $53 = $51;\n     if ($52) {\n      $56 = $49;\n      $57 = HEAP32[$47>>2]|0;\n      $58 = (($56) - ($57))|0;\n      $59 = (($58) + 1)|0;\n      $60 = ($59|0)<(0);\n      if ($60) {\n       __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($47);\n       $$pre$i$i$us = HEAP32[$47>>2]|0;\n       $$pre$i$us = HEAP32[$50>>2]|0;\n       $$in$i$i$us = $$pre$i$i$us;$$pre$phi$i$usZ2D = $50;$63 = $$pre$i$us;\n      } else {\n       $$in$i$i$us = $57;$$pre$phi$i$usZ2D = $50;$63 = $53;\n      }\n      $61 = $$in$i$i$us;\n      $62 = (($63) - ($$in$i$i$us))|0;\n      $64 = ($62>>>0)<(1073741823);\n      if ($64) {\n       $67 = $62 << 1;\n       $68 = ($67>>>0)<($59>>>0);\n       $69 = $68 ? $59 : $67;\n       $70 = HEAP32[$48>>2]|0;\n       $71 = (($70) - ($$in$i$i$us))|0;\n       $72 = ($69|0)==(0);\n       if ($72) {\n        $$0$i2$i$i$us = 0;$75 = 0;$76 = $71;$82 = $70;\n       } else {\n        $$0$i1$i$i$us = $69;$155 = $70;$156 = $71;\n        label = 21;\n       }\n      } else {\n       $65 = HEAP32[$48>>2]|0;\n       $66 = (($65) - ($$in$i$i$us))|0;\n       $$0$i1$i$i$us = 2147483647;$155 = $65;$156 = $66;\n       label = 21;\n      }\n      if ((label|0) == 21) {\n       label = 0;\n       $73 = (__Znwj($$0$i1$i$i$us)|0);\n       $$0$i2$i$i$us = $$0$i1$i$i$us;$75 = $73;$76 = $156;$82 = $155;\n      }\n      $74 = (($75) + ($76)|0);\n      $77 = (($75) + ($$0$i2$i$i$us)|0);\n      $78 = $77;\n      HEAP8[$74>>0] = $45;\n      $79 = ((($74)) + 1|0);\n      $80 = $79;\n      $81 = (($82) - ($$in$i$i$us))|0;\n      $83 = (0 - ($81))|0;\n      $84 = (($74) + ($83)|0);\n      $85 = $84;\n      _memcpy(($84|0),($61|0),($81|0))|0;\n      HEAP32[$47>>2] = $85;\n      HEAP32[$48>>2] = $80;\n      HEAP32[$$pre$phi$i$usZ2D>>2] = $78;\n      $86 = ($$in$i$i$us|0)==(0);\n      if (!($86)) {\n       __ZdlPv($61);\n      }\n     } else {\n      HEAP8[$49>>0] = $45;\n      $54 = HEAP32[$48>>2]|0;\n      $55 = ((($54)) + 1|0);\n      HEAP32[$48>>2] = $55;\n     }\n     $87 = (($col$08$us) + 1)|0;\n     $88 = ($87|0)<($21|0);\n     if ($88) {\n      $col$08$us = $87;\n     } else {\n      break;\n     }\n    }\n   } else {\n    $col$08 = 0;\n    while(1) {\n     $91 = (_fgetc($f)|0);\n     $92 = ($91|0)==(-1);\n     if ($92) {\n      label = 28;\n      break L10;\n     }\n     $94 = $91&255;\n     $95 = (_fgetc($f)|0);\n     $96 = ($95|0)==(-1);\n     if ($96) {\n      label = 30;\n      break L10;\n     }\n     $98 = $95&255;\n     $99 = (_fgetc($f)|0);\n     $100 = ($99|0)==(-1);\n     if ($100) {\n      label = 32;\n      break L10;\n     }\n     $102 = $99&255;\n     $103 = HEAP8[$6>>0]|0;\n     $104 = ($94&255)>($103&255);\n     $105 = ($98&255)>($103&255);\n     $or$cond = $104 | $105;\n     $106 = ($102&255)>($103&255);\n     $or$cond2 = $106 | $or$cond;\n     if ($or$cond2) {\n      label = 34;\n      break L10;\n     }\n     $108 = ($102&255)<($98&255);\n     $109 = $108 ? $102 : $98;\n     $110 = ($109&255)<($94&255);\n     $111 = $110 ? $109 : $94;\n     $112 = HEAP32[$24>>2]|0;\n     $113 = (($112) + (($row$09*12)|0)|0);\n     $114 = (((($112) + (($row$09*12)|0)|0)) + 4|0);\n     $115 = HEAP32[$114>>2]|0;\n     $116 = (((($112) + (($row$09*12)|0)|0)) + 8|0);\n     $117 = HEAP32[$116>>2]|0;\n     $118 = ($115|0)==($117|0);\n     $119 = $117;\n     if ($118) {\n      $122 = $115;\n      $123 = HEAP32[$113>>2]|0;\n      $124 = (($122) - ($123))|0;\n      $125 = (($124) + 1)|0;\n      $126 = ($125|0)<(0);\n      if ($126) {\n       __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($113);\n       $$pre$i$i = HEAP32[$113>>2]|0;\n       $$pre$i = HEAP32[$116>>2]|0;\n       $$in$i$i = $$pre$i$i;$$pre$phi$iZ2D = $116;$129 = $$pre$i;\n      } else {\n       $$in$i$i = $123;$$pre$phi$iZ2D = $116;$129 = $119;\n      }\n      $127 = $$in$i$i;\n      $128 = (($129) - ($$in$i$i))|0;\n      $130 = ($128>>>0)<(1073741823);\n      if ($130) {\n       $133 = $128 << 1;\n       $134 = ($133>>>0)<($125>>>0);\n       $135 = $134 ? $125 : $133;\n       $136 = HEAP32[$114>>2]|0;\n       $137 = (($136) - ($$in$i$i))|0;\n       $138 = ($135|0)==(0);\n       if ($138) {\n        $$0$i2$i$i = 0;$141 = 0;$142 = $137;$148 = $136;\n       } else {\n        $$0$i1$i$i = $135;$157 = $136;$158 = $137;\n        label = 43;\n       }\n      } else {\n       $131 = HEAP32[$114>>2]|0;\n       $132 = (($131) - ($$in$i$i))|0;\n       $$0$i1$i$i = 2147483647;$157 = $131;$158 = $132;\n       label = 43;\n      }\n      if ((label|0) == 43) {\n       label = 0;\n       $139 = (__Znwj($$0$i1$i$i)|0);\n       $$0$i2$i$i = $$0$i1$i$i;$141 = $139;$142 = $158;$148 = $157;\n      }\n      $140 = (($141) + ($142)|0);\n      $143 = (($141) + ($$0$i2$i$i)|0);\n      $144 = $143;\n      HEAP8[$140>>0] = $111;\n      $145 = ((($140)) + 1|0);\n      $146 = $145;\n      $147 = (($148) - ($$in$i$i))|0;\n      $149 = (0 - ($147))|0;\n      $150 = (($140) + ($149)|0);\n      $151 = $150;\n      _memcpy(($150|0),($127|0),($147|0))|0;\n      HEAP32[$113>>2] = $151;\n      HEAP32[$114>>2] = $146;\n      HEAP32[$$pre$phi$iZ2D>>2] = $144;\n      $152 = ($$in$i$i|0)==(0);\n      if (!($152)) {\n       __ZdlPv($127);\n      }\n     } else {\n      HEAP8[$115>>0] = $111;\n      $120 = HEAP32[$114>>2]|0;\n      $121 = ((($120)) + 1|0);\n      HEAP32[$114>>2] = $121;\n     }\n     $153 = (($col$08) + 1)|0;\n     $154 = ($153|0)<($21|0);\n     if ($154) {\n      $col$08 = $153;\n     } else {\n      break;\n     }\n    }\n   }\n  }\n  $89 = (($row$09) + 1)|0;\n  $90 = ($89|0)<($16|0);\n  if ($90) {\n   $row$09 = $89;\n  } else {\n   label = 25;\n   break;\n  }\n }\n if ((label|0) == 25) {\n  return;\n }\n else if ((label|0) == 28) {\n  $93 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$93>>2] = 872;\n  ___cxa_throw(($93|0),(8|0),(0|0));\n  // unreachable;\n }\n else if ((label|0) == 30) {\n  $97 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$97>>2] = 872;\n  ___cxa_throw(($97|0),(8|0),(0|0));\n  // unreachable;\n }\n else if ((label|0) == 32) {\n  $101 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$101>>2] = 872;\n  ___cxa_throw(($101|0),(8|0),(0|0));\n  // unreachable;\n }\n else if ((label|0) == 34) {\n  $107 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$107>>2] = 1144;\n  ___cxa_throw(($107|0),(8|0),(0|0));\n  // unreachable;\n }\n}\nfunction __ZN10Page_imageC2EP8_IO_FILEb($this,$f,$invert) {\n $this = $this|0;\n $f = $f|0;\n $invert = $invert|0;\n var $$in = 0, $$in$lcssa = 0, $$in17 = 0, $$lcssa = 0, $$off = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i$i = 0, $$pre$i$i$i6 = 0, $$pre15 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0;\n var $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0;\n var $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0;\n var $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;\n var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0;\n var $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0;\n var $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0;\n var $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0;\n var $97 = 0, $98 = 0, $99 = 0, $lpad$phi$index = 0, $lpad$phi$index6 = 0, $row$013 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_ptr4 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();\n $vararg_buffer1 = sp + 8|0;\n $vararg_buffer = sp;\n __ZN9RectangleC2Eiiii($this,0,0,0,0);\n $0 = ((($this)) + 16|0);\n HEAP32[$0>>2] = 0;\n $1 = ((($this)) + 20|0);\n HEAP32[$1>>2] = 0;\n $2 = ((($this)) + 24|0);\n HEAP32[$2>>2] = 0;\n $3 = (_fgetc($f)|0);\n $4 = ($3|0)==(-1);\n L1: do {\n  if ($4) {\n   $5 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$5>>2] = 872;\n   __THREW__ = 0;\n   invoke_viii(34,($5|0),(8|0),(0|0));\n   $6 = __THREW__; __THREW__ = 0;\n   label = 8;\n  } else {\n   $7 = $3&255;\n   $8 = ($7<<24>>24)==(80);\n   if ($8) {\n    $9 = (_fgetc($f)|0);\n    $10 = ($9|0)==(-1);\n    if ($10) {\n     $11 = (___cxa_allocate_exception(4)|0);\n     HEAP32[$11>>2] = 872;\n     __THREW__ = 0;\n     invoke_viii(34,($11|0),(8|0),(0|0));\n     $12 = __THREW__; __THREW__ = 0;\n     label = 8;\n     break;\n    }\n    $13 = $9&255;\n    $$off = (($13) + -49)<<24>>24;\n    $14 = ($$off&255)<(6);\n    if ($14) {\n     $35 = $9 & 255;\n     __THREW__ = 0;\n     $36 = (invoke_ii(35,($f|0))|0);\n     $37 = __THREW__; __THREW__ = 0;\n     $38 = $37&1;\n     if ($38) {\n      label = 8;\n      break;\n     }\n     $39 = ($36|0)==(0);\n     if ($39) {\n      $40 = (___cxa_allocate_exception(4)|0);\n      HEAP32[$40>>2] = 1250;\n      __THREW__ = 0;\n      invoke_viii(34,($40|0),(8|0),(0|0));\n      $41 = __THREW__; __THREW__ = 0;\n      label = 8;\n      break;\n     }\n     __THREW__ = 0;\n     invoke_vii(36,($this|0),($36|0));\n     $42 = __THREW__; __THREW__ = 0;\n     $43 = $42&1;\n     if ($43) {\n      label = 8;\n      break;\n     }\n     __THREW__ = 0;\n     $44 = (invoke_ii(35,($f|0))|0);\n     $45 = __THREW__; __THREW__ = 0;\n     $46 = $45&1;\n     if ($46) {\n      label = 8;\n      break;\n     }\n     $47 = ($44|0)==(0);\n     if ($47) {\n      $48 = (___cxa_allocate_exception(4)|0);\n      HEAP32[$48>>2] = 1274;\n      __THREW__ = 0;\n      invoke_viii(34,($48|0),(8|0),(0|0));\n      $49 = __THREW__; __THREW__ = 0;\n      label = 8;\n      break;\n     }\n     __THREW__ = 0;\n     invoke_vii(37,($this|0),($44|0));\n     $50 = __THREW__; __THREW__ = 0;\n     $51 = $50&1;\n     if ($51) {\n      label = 8;\n      break;\n     }\n     $52 = ((($this)) + 8|0);\n     $53 = HEAP32[$52>>2]|0;\n     $54 = HEAP32[$this>>2]|0;\n     $55 = (($53) + 1)|0;\n     $56 = (($55) - ($54))|0;\n     $57 = ($56|0)<(3);\n     if (!($57)) {\n      $58 = ((($this)) + 12|0);\n      $59 = HEAP32[$58>>2]|0;\n      $60 = ((($this)) + 4|0);\n      $61 = HEAP32[$60>>2]|0;\n      $62 = (($59) + 1)|0;\n      $63 = (($62) - ($61))|0;\n      $64 = ($63|0)<(3);\n      if (!($64)) {\n       $67 = (2147483647 / ($56|0))&-1;\n       $68 = ($67|0)<($63|0);\n       if ($68) {\n        $69 = (___cxa_allocate_exception(4)|0);\n        HEAP32[$69>>2] = 1337;\n        __THREW__ = 0;\n        invoke_viii(34,($69|0),(8|0),(0|0));\n        $70 = __THREW__; __THREW__ = 0;\n        label = 8;\n        break;\n       }\n       $71 = HEAP32[$1>>2]|0;\n       $72 = HEAP32[$0>>2]|0;\n       $73 = (($71) - ($72))|0;\n       $74 = (($73|0) / 12)&-1;\n       $75 = ($63>>>0)>($74>>>0);\n       $76 = $72;\n       $77 = $71;\n       if ($75) {\n        $78 = (($63) - ($74))|0;\n        __THREW__ = 0;\n        invoke_vii(38,($0|0),($78|0));\n        $79 = __THREW__; __THREW__ = 0;\n        $80 = $79&1;\n        if ($80) {\n         label = 8;\n         break;\n        }\n        $$pre = HEAP32[$1>>2]|0;\n        $91 = $$pre;\n       } else {\n        $81 = ($63>>>0)<($74>>>0);\n        if ($81) {\n         $82 = (($76) + (($63*12)|0)|0);\n         $83 = ($77|0)==($82|0);\n         if ($83) {\n          $91 = $71;\n         } else {\n          $85 = $77;\n          while(1) {\n           $84 = ((($85)) + -12|0);\n           HEAP32[$1>>2] = $84;\n           $86 = HEAP32[$84>>2]|0;\n           $87 = ($86|0)==(0|0);\n           if ($87) {\n            $$in = $84;\n           } else {\n            $93 = ((($85)) + -8|0);\n            $94 = HEAP32[$93>>2]|0;\n            $95 = ($94|0)==($86|0);\n            if (!($95)) {\n             HEAP32[$93>>2] = $86;\n            }\n            __ZdlPv($86);\n            $$pre$i$i$i6 = HEAP32[$1>>2]|0;\n            $$in = $$pre$i$i$i6;\n           }\n           $88 = ($$in|0)==($82|0);\n           if ($88) {\n            $$in$lcssa = $$in;\n            break;\n           } else {\n            $85 = $$in;\n           }\n          }\n          $89 = $$in$lcssa;\n          $91 = $89;\n         }\n        } else {\n         $91 = $71;\n        }\n       }\n       $90 = HEAP32[$0>>2]|0;\n       $92 = ($91|0)==($90|0);\n       L41: do {\n        if (!($92)) {\n         $$in17 = $90;$row$013 = 0;\n         L42: while(1) {\n          $96 = $$in17;\n          $97 = (($96) + (($row$013*12)|0)|0);\n          $98 = HEAP32[$52>>2]|0;\n          $99 = HEAP32[$this>>2]|0;\n          $100 = (($98) + 1)|0;\n          $101 = (($100) - ($99))|0;\n          $102 = (((($96) + (($row$013*12)|0)|0)) + 8|0);\n          $103 = HEAP32[$102>>2]|0;\n          $104 = HEAP32[$97>>2]|0;\n          $105 = (($103) - ($104))|0;\n          $106 = ($105>>>0)<($101>>>0);\n          $107 = $104;\n          do {\n           if ($106) {\n            $108 = (((($96) + (($row$013*12)|0)|0)) + 4|0);\n            $109 = HEAP32[$108>>2]|0;\n            $110 = (($109) - ($104))|0;\n            $111 = ($100|0)==($99|0);\n            if ($111) {\n             $116 = 0;\n            } else {\n             __THREW__ = 0;\n             $112 = (invoke_ii(29,($101|0))|0);\n             $113 = __THREW__; __THREW__ = 0;\n             $114 = $113&1;\n             if ($114) {\n              $$lcssa = $96;\n              break L42;\n             } else {\n              $116 = $112;\n             }\n            }\n            $115 = (($116) + ($110)|0);\n            $117 = $115;\n            $118 = (($116) + ($101)|0);\n            $119 = $118;\n            $120 = (0 - ($110))|0;\n            $121 = (($115) + ($120)|0);\n            $122 = $121;\n            _memcpy(($121|0),($107|0),($110|0))|0;\n            HEAP32[$97>>2] = $122;\n            HEAP32[$108>>2] = $117;\n            HEAP32[$102>>2] = $119;\n            $123 = ($104|0)==(0);\n            if ($123) {\n             break;\n            }\n            __ZdlPv($107);\n           }\n          } while(0);\n          $124 = (($row$013) + 1)|0;\n          $125 = HEAP32[$1>>2]|0;\n          $126 = HEAP32[$0>>2]|0;\n          $127 = (($125) - ($126))|0;\n          $128 = (($127|0) / 12)&-1;\n          $129 = ($124>>>0)<($128>>>0);\n          if ($129) {\n           $$in17 = $126;$row$013 = $124;\n          } else {\n           break L41;\n          }\n         }\n         $15 = ___cxa_find_matching_catch_2()|0;\n         $16 = tempRet0;\n         $19 = $$lcssa;$lpad$phi$index = $15;$lpad$phi$index6 = $16;\n         break L1;\n        }\n       } while(0);\n       switch ($35|0) {\n       case 49:  {\n        __THREW__ = 0;\n        invoke_viii(39,($this|0),($f|0),($invert|0));\n        $130 = __THREW__; __THREW__ = 0;\n        $131 = $130&1;\n        if ($131) {\n         label = 8;\n         break L1;\n        }\n        break;\n       }\n       case 52:  {\n        __THREW__ = 0;\n        invoke_viii(40,($this|0),($f|0),($invert|0));\n        $132 = __THREW__; __THREW__ = 0;\n        $133 = $132&1;\n        if ($133) {\n         label = 8;\n         break L1;\n        }\n        break;\n       }\n       case 50:  {\n        __THREW__ = 0;\n        invoke_viii(41,($this|0),($f|0),($invert|0));\n        $134 = __THREW__; __THREW__ = 0;\n        $135 = $134&1;\n        if ($135) {\n         label = 8;\n         break L1;\n        }\n        break;\n       }\n       case 53:  {\n        __THREW__ = 0;\n        invoke_viii(42,($this|0),($f|0),($invert|0));\n        $136 = __THREW__; __THREW__ = 0;\n        $137 = $136&1;\n        if ($137) {\n         label = 8;\n         break L1;\n        }\n        break;\n       }\n       case 51:  {\n        __THREW__ = 0;\n        invoke_viii(43,($this|0),($f|0),($invert|0));\n        $138 = __THREW__; __THREW__ = 0;\n        $139 = $138&1;\n        if ($139) {\n         label = 8;\n         break L1;\n        }\n        break;\n       }\n       case 54:  {\n        __THREW__ = 0;\n        invoke_viii(44,($this|0),($f|0),($invert|0));\n        $140 = __THREW__; __THREW__ = 0;\n        $141 = $140&1;\n        if ($141) {\n         label = 8;\n         break L1;\n        }\n        break;\n       }\n       default: {\n       }\n       }\n       $142 = HEAP32[1700]|0;\n       $143 = ($142|0)>(0);\n       if (!($143)) {\n        STACKTOP = sp;return;\n       }\n       $144 = HEAP32[90]|0;\n       HEAP32[$vararg_buffer>>2] = $35;\n       (_fprintf($144,1373,$vararg_buffer)|0);\n       $145 = HEAP32[$52>>2]|0;\n       $146 = HEAP32[$this>>2]|0;\n       $147 = (($145) + 1)|0;\n       $148 = (($147) - ($146))|0;\n       $149 = HEAP32[$58>>2]|0;\n       $150 = HEAP32[$60>>2]|0;\n       $151 = (($149) + 1)|0;\n       $152 = (($151) - ($150))|0;\n       HEAP32[$vararg_buffer1>>2] = $148;\n       $vararg_ptr4 = ((($vararg_buffer1)) + 4|0);\n       HEAP32[$vararg_ptr4>>2] = $152;\n       (_fprintf($144,1391,$vararg_buffer1)|0);\n       STACKTOP = sp;return;\n      }\n     }\n     $65 = (___cxa_allocate_exception(4)|0);\n     HEAP32[$65>>2] = 1299;\n     __THREW__ = 0;\n     invoke_viii(34,($65|0),(8|0),(0|0));\n     $66 = __THREW__; __THREW__ = 0;\n     label = 8;\n     break;\n    }\n   }\n   $33 = (___cxa_allocate_exception(4)|0);\n   HEAP32[$33>>2] = 1203;\n   __THREW__ = 0;\n   invoke_viii(34,($33|0),(8|0),(0|0));\n   $34 = __THREW__; __THREW__ = 0;\n   label = 8;\n  }\n } while(0);\n if ((label|0) == 8) {\n  $17 = ___cxa_find_matching_catch_2()|0;\n  $18 = tempRet0;\n  $$pre15 = HEAP32[$0>>2]|0;\n  $19 = $$pre15;$lpad$phi$index = $17;$lpad$phi$index6 = $18;\n }\n $20 = ($19|0)==(0|0);\n if ($20) {\n  ___resumeException($lpad$phi$index|0);\n  // unreachable;\n }\n $21 = HEAP32[$1>>2]|0;\n $22 = ($21|0)==($19|0);\n if ($22) {\n  $32 = $19;\n } else {\n  $24 = $21;\n  while(1) {\n   $23 = ((($24)) + -12|0);\n   HEAP32[$1>>2] = $23;\n   $25 = HEAP32[$23>>2]|0;\n   $26 = ($25|0)==(0|0);\n   if ($26) {\n    $27 = $23;\n   } else {\n    $29 = ((($24)) + -8|0);\n    $30 = HEAP32[$29>>2]|0;\n    $31 = ($30|0)==($25|0);\n    if (!($31)) {\n     HEAP32[$29>>2] = $25;\n    }\n    __ZdlPv($25);\n    $$pre$i$i$i = HEAP32[$1>>2]|0;\n    $27 = $$pre$i$i$i;\n   }\n   $28 = ($27|0)==($19|0);\n   if ($28) {\n    break;\n   } else {\n    $24 = $27;\n   }\n  }\n  $$pre$i = HEAP32[$0>>2]|0;\n  $32 = $$pre$i;\n }\n __ZdlPv($32);\n ___resumeException($lpad$phi$index|0);\n // unreachable;\n}\nfunction __ZNSt3__16vectorINS0_IhNS_9allocatorIhEEEENS1_IS3_EEE8__appendEj($this,$__n) {\n $this = $this|0;\n $__n = $__n|0;\n var $$0$i = 0, $$0$i10 = 0, $$0$i8 = 0, $$pre = 0, $$pre20 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0;\n var $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0;\n var $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0;\n var $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0;\n var $77 = 0, $8 = 0, $9 = 0, $__v = 0, $scevgep$i = 0, $scevgep$i11 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();\n $__v = sp;\n $0 = ((($this)) + 8|0);\n $1 = HEAP32[$0>>2]|0;\n $2 = ((($this)) + 4|0);\n $3 = HEAP32[$2>>2]|0;\n $4 = (($1) - ($3))|0;\n $5 = (($4|0) / 12)&-1;\n $6 = ($5>>>0)<($__n>>>0);\n $7 = $3;\n if (!($6)) {\n  $$0$i = $__n;$8 = $7;\n  while(1) {\n   HEAP32[$8>>2] = 0;\n   $9 = ((($8)) + 4|0);\n   HEAP32[$9>>2] = 0;\n   $10 = ((($8)) + 8|0);\n   HEAP32[$10>>2] = 0;\n   $11 = ((($8)) + 12|0);\n   $12 = (($$0$i) + -1)|0;\n   $13 = ($12|0)==(0);\n   if ($13) {\n    break;\n   } else {\n    $$0$i = $12;$8 = $11;\n   }\n  }\n  $scevgep$i = (($7) + (($__n*12)|0)|0);\n  HEAP32[$2>>2] = $scevgep$i;\n  STACKTOP = sp;return;\n }\n $14 = ((($this)) + 8|0);\n $15 = HEAP32[$this>>2]|0;\n $16 = (($3) - ($15))|0;\n $17 = (($16|0) / 12)&-1;\n $18 = (($17) + ($__n))|0;\n $19 = ($18>>>0)>(357913941);\n if ($19) {\n  __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($this);\n  $$pre = HEAP32[$0>>2]|0;\n  $$pre20 = HEAP32[$this>>2]|0;\n  $21 = $$pre20;$22 = $$pre;\n } else {\n  $21 = $15;$22 = $1;\n }\n $20 = (($22) - ($21))|0;\n $23 = (($20|0) / 12)&-1;\n $24 = ($23>>>0)<(178956970);\n if ($24) {\n  $25 = $23 << 1;\n  $26 = ($25>>>0)<($18>>>0);\n  $27 = $26 ? $18 : $25;\n  $$0$i8 = $27;\n } else {\n  $$0$i8 = 357913941;\n }\n $28 = HEAP32[$2>>2]|0;\n $29 = (($28) - ($21))|0;\n $30 = (($29|0) / 12)&-1;\n $31 = ((($__v)) + 12|0);\n HEAP32[$31>>2] = 0;\n $32 = ((($__v)) + 16|0);\n HEAP32[$32>>2] = $14;\n $33 = ($$0$i8|0)==(0);\n if ($33) {\n  $36 = 0;\n } else {\n  $34 = ($$0$i8*12)|0;\n  $35 = (__Znwj($34)|0);\n  $36 = $35;\n }\n HEAP32[$__v>>2] = $36;\n $37 = (($36) + (($30*12)|0)|0);\n $38 = ((($__v)) + 8|0);\n HEAP32[$38>>2] = $37;\n $39 = ((($__v)) + 4|0);\n HEAP32[$39>>2] = $37;\n $40 = (($36) + (($$0$i8*12)|0)|0);\n $41 = ((($__v)) + 12|0);\n HEAP32[$41>>2] = $40;\n $$0$i10 = $__n;$42 = $37;\n while(1) {\n  HEAP32[$42>>2] = 0;\n  $43 = ((($42)) + 4|0);\n  HEAP32[$43>>2] = 0;\n  $44 = ((($42)) + 8|0);\n  HEAP32[$44>>2] = 0;\n  $45 = ((($42)) + 12|0);\n  $46 = (($$0$i10) + -1)|0;\n  $47 = ($46|0)==(0);\n  if ($47) {\n   break;\n  } else {\n   $$0$i10 = $46;$42 = $45;\n  }\n }\n $scevgep$i11 = (($37) + (($__n*12)|0)|0);\n HEAP32[$38>>2] = $scevgep$i11;\n __THREW__ = 0;\n invoke_vii(45,($this|0),($__v|0));\n $48 = __THREW__; __THREW__ = 0;\n $49 = $48&1;\n if ($49) {\n  $63 = ___cxa_find_matching_catch_2()|0;\n  $64 = tempRet0;\n  $65 = HEAP32[$39>>2]|0;\n  $66 = HEAP32[$38>>2]|0;\n  $67 = ($66|0)==($65|0);\n  if (!($67)) {\n   $69 = $66;\n   while(1) {\n    $68 = ((($69)) + -12|0);\n    $70 = HEAP32[$68>>2]|0;\n    $71 = ($70|0)==(0|0);\n    if (!($71)) {\n     $73 = ((($69)) + -8|0);\n     $74 = HEAP32[$73>>2]|0;\n     $75 = ($74|0)==($70|0);\n     if (!($75)) {\n      HEAP32[$73>>2] = $70;\n     }\n     __ZdlPv($70);\n    }\n    $72 = ($68|0)==($65|0);\n    if ($72) {\n     break;\n    } else {\n     $69 = $68;\n    }\n   }\n   HEAP32[$38>>2] = $65;\n  }\n  $76 = HEAP32[$__v>>2]|0;\n  $77 = ($76|0)==(0|0);\n  if ($77) {\n   ___resumeException($63|0);\n   // unreachable;\n  }\n  __ZdlPv($76);\n  ___resumeException($63|0);\n  // unreachable;\n } else {\n  $50 = HEAP32[$39>>2]|0;\n  $51 = HEAP32[$38>>2]|0;\n  $52 = ($51|0)==($50|0);\n  if (!($52)) {\n   $54 = $51;\n   while(1) {\n    $53 = ((($54)) + -12|0);\n    $55 = HEAP32[$53>>2]|0;\n    $56 = ($55|0)==(0|0);\n    if (!($56)) {\n     $58 = ((($54)) + -8|0);\n     $59 = HEAP32[$58>>2]|0;\n     $60 = ($59|0)==($55|0);\n     if (!($60)) {\n      HEAP32[$58>>2] = $55;\n     }\n     __ZdlPv($55);\n    }\n    $57 = ($53|0)==($50|0);\n    if ($57) {\n     break;\n    } else {\n     $54 = $53;\n    }\n   }\n   HEAP32[$38>>2] = $50;\n  }\n  $61 = HEAP32[$__v>>2]|0;\n  $62 = ($61|0)==(0|0);\n  if (!($62)) {\n   __ZdlPv($61);\n  }\n  STACKTOP = sp;return;\n }\n}\nfunction __ZNSt3__16vectorINS0_IhNS_9allocatorIhEEEENS1_IS3_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS3_RS4_EE($this,$__v) {\n $this = $this|0;\n $__v = $__v|0;\n var $$01$i$i$i$i = 0, $$02$i = 0, $$lcssa = 0, $$lcssa25 = 0, $$lcssa27 = 0, $$pre = 0, $$pre$i = 0, $$pre$phi11Z2D = 0, $$pre$phiZ2D = 0, $$pre8 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;\n var $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0;\n var $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $6 = 0;\n var $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = HEAP32[$this>>2]|0;\n $1 = ((($this)) + 4|0);\n $2 = HEAP32[$1>>2]|0;\n $3 = ((($__v)) + 4|0);\n $4 = ($2|0)==($0|0);\n do {\n  if ($4) {\n   $5 = $0;\n   $$pre8 = HEAP32[$3>>2]|0;\n   $$pre$phi11Z2D = $3;$$pre$phiZ2D = $this;$43 = $$pre8;$44 = $5;\n  } else {\n   $$pre$i = HEAP32[$3>>2]|0;\n   $$02$i = $2;$7 = $$pre$i;\n   while(1) {\n    $6 = ((($7)) + -12|0);\n    $8 = ((($$02$i)) + -12|0);\n    HEAP32[$6>>2] = 0;\n    $9 = ((($7)) + -8|0);\n    HEAP32[$9>>2] = 0;\n    $10 = ((($7)) + -4|0);\n    HEAP32[$10>>2] = 0;\n    $11 = ((($$02$i)) + -8|0);\n    $12 = HEAP32[$11>>2]|0;\n    $13 = HEAP32[$8>>2]|0;\n    $14 = (($12) - ($13))|0;\n    $15 = ($12|0)==($13|0);\n    if (!($15)) {\n     $16 = ($14|0)<(0);\n     if ($16) {\n      __THREW__ = 0;\n      invoke_vi(46,($6|0));\n      $17 = __THREW__; __THREW__ = 0;\n      $18 = $17&1;\n      if ($18) {\n       $$lcssa = $6;$$lcssa25 = $9;\n       break;\n      }\n     }\n     __THREW__ = 0;\n     $19 = (invoke_ii(29,($14|0))|0);\n     $20 = __THREW__; __THREW__ = 0;\n     $21 = $20&1;\n     if ($21) {\n      $$lcssa = $6;$$lcssa25 = $9;\n      break;\n     }\n     HEAP32[$9>>2] = $19;\n     HEAP32[$6>>2] = $19;\n     $22 = (($19) + ($14)|0);\n     $23 = ((($7)) + -4|0);\n     HEAP32[$23>>2] = $22;\n     $24 = HEAP32[$8>>2]|0;\n     $25 = HEAP32[$11>>2]|0;\n     $26 = ($24|0)==($25|0);\n     if (!($26)) {\n      $$01$i$i$i$i = $24;$28 = $19;\n      while(1) {\n       $27 = HEAP8[$$01$i$i$i$i>>0]|0;\n       HEAP8[$28>>0] = $27;\n       $29 = HEAP32[$9>>2]|0;\n       $30 = ((($29)) + 1|0);\n       HEAP32[$9>>2] = $30;\n       $31 = ((($$01$i$i$i$i)) + 1|0);\n       $32 = ($31|0)==($25|0);\n       if ($32) {\n        break;\n       } else {\n        $$01$i$i$i$i = $31;$28 = $30;\n       }\n      }\n     }\n    }\n    $39 = HEAP32[$3>>2]|0;\n    $40 = ((($39)) + -12|0);\n    HEAP32[$3>>2] = $40;\n    $41 = ($8|0)==($0|0);\n    if ($41) {\n     $$lcssa27 = $40;\n     label = 16;\n     break;\n    } else {\n     $$02$i = $8;$7 = $40;\n    }\n   }\n   if ((label|0) == 16) {\n    $42 = $$lcssa27;\n    $$pre = HEAP32[$this>>2]|0;\n    $$pre$phi11Z2D = $3;$$pre$phiZ2D = $this;$43 = $42;$44 = $$pre;\n    break;\n   }\n   $33 = ___cxa_find_matching_catch_2()|0;\n   $34 = tempRet0;\n   $35 = HEAP32[$$lcssa>>2]|0;\n   $36 = ($35|0)==(0|0);\n   if ($36) {\n    ___resumeException($33|0);\n    // unreachable;\n   }\n   $37 = HEAP32[$$lcssa25>>2]|0;\n   $38 = ($37|0)==($35|0);\n   if (!($38)) {\n    HEAP32[$$lcssa25>>2] = $35;\n   }\n   __ZdlPv($35);\n   ___resumeException($33|0);\n   // unreachable;\n  }\n } while(0);\n HEAP32[$$pre$phiZ2D>>2] = $43;\n HEAP32[$$pre$phi11Z2D>>2] = $44;\n $45 = ((($__v)) + 8|0);\n $46 = HEAP32[$1>>2]|0;\n $47 = HEAP32[$45>>2]|0;\n HEAP32[$1>>2] = $47;\n HEAP32[$45>>2] = $46;\n $48 = ((($this)) + 8|0);\n $49 = ((($__v)) + 12|0);\n $50 = HEAP32[$48>>2]|0;\n $51 = HEAP32[$49>>2]|0;\n HEAP32[$48>>2] = $51;\n HEAP32[$49>>2] = $50;\n $52 = HEAP32[$$pre$phi11Z2D>>2]|0;\n HEAP32[$__v>>2] = $52;\n return;\n}\nfunction __ZNK10Page_image4saveEP8_IO_FILEc($this,$f,$filetype) {\n $this = $this|0;\n $f = $f|0;\n $filetype = $filetype|0;\n var $$0 = 0, $$byte$0 = 0, $$lcssa = 0, $$lcssa113 = 0, $$lcssa116 = 0, $$lcssa7 = 0, $$lcssa8 = 0, $$lcssa9 = 0, $$pre = 0, $$pre71 = 0, $$pre72 = 0, $$pre73 = 0, $$pre74 = 0, $$pre75 = 0, $$pre76 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0;\n var $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0;\n var $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0;\n var $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0;\n var $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0;\n var $175 = 0, $176 = 0, $177 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0;\n var $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0;\n var $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0;\n var $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0;\n var $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $byte$050 = 0, $byte$2 = 0, $byte$2$lcssa = 0, $col$04299 = 0, $col11$016 = 0, $col2$052 = 0, $col4$024 = 0;\n var $col6$034 = 0, $col8$010 = 0, $filetype$off = 0, $mask$051 = 0, $mask$1 = 0, $mask$1$lcssa = 0, $row$046 = 0, $row1$058 = 0, $row10$020 = 0, $row3$030 = 0, $row5$038 = 0, $row7$012 = 0, $vararg_buffer = 0, $vararg_buffer12 = 0, $vararg_buffer17 = 0, $vararg_buffer22 = 0, $vararg_buffer3 = 0, $vararg_buffer6 = 0, $vararg_buffer9 = 0, $vararg_ptr1 = 0;\n var $vararg_ptr15 = 0, $vararg_ptr16 = 0, $vararg_ptr2 = 0, $vararg_ptr20 = 0, $vararg_ptr21 = 0, $vararg_ptr25 = 0, $vararg_ptr26 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 96|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();\n $vararg_buffer22 = sp + 72|0;\n $vararg_buffer17 = sp + 56|0;\n $vararg_buffer12 = sp + 40|0;\n $vararg_buffer9 = sp + 32|0;\n $vararg_buffer6 = sp + 24|0;\n $vararg_buffer3 = sp + 16|0;\n $vararg_buffer = sp;\n $filetype$off = (($filetype) + -49)<<24>>24;\n $0 = ($filetype$off&255)>(5);\n if ($0) {\n  $$0 = 0;\n  STACKTOP = sp;return ($$0|0);\n }\n $1 = $filetype << 24 >> 24;\n $2 = ((($this)) + 8|0);\n $3 = HEAP32[$2>>2]|0;\n $4 = HEAP32[$this>>2]|0;\n $5 = (($3) + 1)|0;\n $6 = (($5) - ($4))|0;\n $7 = ((($this)) + 12|0);\n $8 = HEAP32[$7>>2]|0;\n $9 = ((($this)) + 4|0);\n $10 = HEAP32[$9>>2]|0;\n $11 = (($8) + 1)|0;\n $12 = (($11) - ($10))|0;\n HEAP32[$vararg_buffer>>2] = $1;\n $vararg_ptr1 = ((($vararg_buffer)) + 4|0);\n HEAP32[$vararg_ptr1>>2] = $6;\n $vararg_ptr2 = ((($vararg_buffer)) + 8|0);\n HEAP32[$vararg_ptr2>>2] = $12;\n (_fprintf($f,1415,$vararg_buffer)|0);\n switch ($filetype<<24>>24) {\n case 49:  {\n  $16 = HEAP32[$9>>2]|0;\n  $17 = HEAP32[$7>>2]|0;\n  $18 = ($16|0)>($17|0);\n  if ($18) {\n   $$0 = 1;\n   STACKTOP = sp;return ($$0|0);\n  }\n  $19 = ((($this)) + 16|0);\n  $20 = ((($this)) + 29|0);\n  $row$046 = $16;\n  while(1) {\n   $21 = HEAP32[$this>>2]|0;\n   $22 = HEAP32[$2>>2]|0;\n   $23 = ($21|0)>($22|0);\n   if (!($23)) {\n    $24 = HEAP32[$9>>2]|0;\n    $25 = (($row$046) - ($24))|0;\n    $26 = HEAP32[$19>>2]|0;\n    $27 = (($26) + (($25*12)|0)|0);\n    $28 = HEAP32[$27>>2]|0;\n    $29 = HEAP8[$28>>0]|0;\n    $30 = HEAP8[$20>>0]|0;\n    $31 = ($29&255)<=($30&255);\n    $32 = $31 ? 49 : 48;\n    (_putc($32,$f)|0);\n    $33 = HEAP32[$2>>2]|0;\n    $34 = ($21|0)<($33|0);\n    if ($34) {\n     $col$04299 = $21;\n     while(1) {\n      $38 = (($col$04299) + 1)|0;\n      $$pre72 = HEAP32[$this>>2]|0;\n      $39 = HEAP32[$9>>2]|0;\n      $40 = (($row$046) - ($39))|0;\n      $41 = HEAP32[$19>>2]|0;\n      $42 = (($38) - ($$pre72))|0;\n      $43 = (($41) + (($40*12)|0)|0);\n      $44 = HEAP32[$43>>2]|0;\n      $45 = (($44) + ($42)|0);\n      $46 = HEAP8[$45>>0]|0;\n      $47 = HEAP8[$20>>0]|0;\n      $48 = ($46&255)<=($47&255);\n      $49 = $48 ? 49 : 48;\n      (_putc($49,$f)|0);\n      $50 = HEAP32[$2>>2]|0;\n      $51 = ($38|0)<($50|0);\n      if ($51) {\n       $col$04299 = $38;\n      } else {\n       break;\n      }\n     }\n    }\n   }\n   (_putc(10,$f)|0);\n   $35 = (($row$046) + 1)|0;\n   $36 = HEAP32[$7>>2]|0;\n   $37 = ($row$046|0)<($36|0);\n   if ($37) {\n    $row$046 = $35;\n   } else {\n    $$0 = 1;\n    break;\n   }\n  }\n  STACKTOP = sp;return ($$0|0);\n  break;\n }\n case 52:  {\n  $52 = HEAP32[$9>>2]|0;\n  $53 = HEAP32[$7>>2]|0;\n  $54 = ($52|0)>($53|0);\n  if ($54) {\n   $$0 = 1;\n   STACKTOP = sp;return ($$0|0);\n  }\n  $55 = ((($this)) + 16|0);\n  $56 = ((($this)) + 29|0);\n  $row1$058 = $52;\n  while(1) {\n   $57 = HEAP32[$this>>2]|0;\n   $58 = HEAP32[$2>>2]|0;\n   $59 = ($57|0)>($58|0);\n   if (!($59)) {\n    $173 = $58;$65 = $57;$byte$050 = 0;$col2$052 = $57;$mask$051 = -128;\n    while(1) {\n     $61 = HEAP32[$9>>2]|0;\n     $62 = (($row1$058) - ($61))|0;\n     $63 = HEAP32[$55>>2]|0;\n     $64 = (($col2$052) - ($65))|0;\n     $66 = (($63) + (($62*12)|0)|0);\n     $67 = HEAP32[$66>>2]|0;\n     $68 = (($67) + ($64)|0);\n     $69 = HEAP8[$68>>0]|0;\n     $70 = HEAP8[$56>>0]|0;\n     $71 = ($69&255)<=($70&255);\n     $72 = $71 ? $mask$051 : 0;\n     $$byte$0 = $72 | $byte$050;\n     $73 = ($mask$051&255) >>> 1;\n     $74 = ($73<<24>>24)==(0);\n     if ($74) {\n      $75 = $$byte$0&255;\n      (_putc($75,$f)|0);\n      $$pre71 = HEAP32[$2>>2]|0;\n      $77 = $$pre71;$byte$2 = 0;$mask$1 = -128;\n     } else {\n      $77 = $173;$byte$2 = $$byte$0;$mask$1 = $73;\n     }\n     $76 = ($col2$052|0)<($77|0);\n     if (!($76)) {\n      $byte$2$lcssa = $byte$2;$mask$1$lcssa = $mask$1;\n      break;\n     }\n     $78 = (($col2$052) + 1)|0;\n     $$pre = HEAP32[$this>>2]|0;\n     $173 = $77;$65 = $$pre;$byte$050 = $byte$2;$col2$052 = $78;$mask$051 = $mask$1;\n    }\n    $60 = ($mask$1$lcssa<<24>>24)==(-128);\n    if (!($60)) {\n     $79 = $byte$2$lcssa&255;\n     (_putc($79,$f)|0);\n    }\n   }\n   $80 = (($row1$058) + 1)|0;\n   $81 = HEAP32[$7>>2]|0;\n   $82 = ($row1$058|0)<($81|0);\n   if ($82) {\n    $row1$058 = $80;\n   } else {\n    $$0 = 1;\n    break;\n   }\n  }\n  STACKTOP = sp;return ($$0|0);\n  break;\n }\n default: {\n  $13 = ((($this)) + 28|0);\n  $14 = HEAP8[$13>>0]|0;\n  $15 = $14&255;\n  HEAP32[$vararg_buffer3>>2] = $15;\n  (_fprintf($f,1426,$vararg_buffer3)|0);\n  switch ($filetype<<24>>24) {\n  case 51:  {\n   $128 = HEAP32[$9>>2]|0;\n   $129 = HEAP32[$7>>2]|0;\n   $130 = ($128|0)>($129|0);\n   if ($130) {\n    $$0 = 1;\n    STACKTOP = sp;return ($$0|0);\n   }\n   $131 = ((($this)) + 16|0);\n   $row7$012 = $128;\n   while(1) {\n    $132 = HEAP32[$this>>2]|0;\n    $133 = HEAP32[$2>>2]|0;\n    $134 = ($132|0)<($133|0);\n    $135 = HEAP32[$131>>2]|0;\n    $136 = (($135) + (($row7$012*12)|0)|0);\n    $137 = HEAP32[$136>>2]|0;\n    if ($134) {\n     $145 = $137;$col8$010 = $132;\n     while(1) {\n      $144 = (($145) + ($col8$010)|0);\n      $146 = HEAP8[$144>>0]|0;\n      $147 = $146&255;\n      HEAP32[$vararg_buffer17>>2] = $147;\n      $vararg_ptr20 = ((($vararg_buffer17)) + 4|0);\n      HEAP32[$vararg_ptr20>>2] = $147;\n      $vararg_ptr21 = ((($vararg_buffer17)) + 8|0);\n      HEAP32[$vararg_ptr21>>2] = $147;\n      (_fprintf($f,1444,$vararg_buffer17)|0);\n      $148 = (($col8$010) + 1)|0;\n      $149 = HEAP32[$2>>2]|0;\n      $150 = ($148|0)<($149|0);\n      $151 = HEAP32[$131>>2]|0;\n      $152 = (($151) + (($row7$012*12)|0)|0);\n      $153 = HEAP32[$152>>2]|0;\n      if ($150) {\n       $145 = $153;$col8$010 = $148;\n      } else {\n       $$lcssa = $149;$$lcssa7 = $153;\n       break;\n      }\n     }\n    } else {\n     $$lcssa = $133;$$lcssa7 = $137;\n    }\n    $138 = (($$lcssa7) + ($$lcssa)|0);\n    $139 = HEAP8[$138>>0]|0;\n    $140 = $139&255;\n    HEAP32[$vararg_buffer12>>2] = $140;\n    $vararg_ptr15 = ((($vararg_buffer12)) + 4|0);\n    HEAP32[$vararg_ptr15>>2] = $140;\n    $vararg_ptr16 = ((($vararg_buffer12)) + 8|0);\n    HEAP32[$vararg_ptr16>>2] = $140;\n    (_fprintf($f,1434,$vararg_buffer12)|0);\n    $141 = (($row7$012) + 1)|0;\n    $142 = HEAP32[$7>>2]|0;\n    $143 = ($row7$012|0)<($142|0);\n    if ($143) {\n     $row7$012 = $141;\n    } else {\n     $$0 = 1;\n     break;\n    }\n   }\n   STACKTOP = sp;return ($$0|0);\n   break;\n  }\n  case 54:  {\n   $154 = HEAP32[$9>>2]|0;\n   $155 = HEAP32[$7>>2]|0;\n   $156 = ($154|0)>($155|0);\n   if ($156) {\n    $$0 = 1;\n    STACKTOP = sp;return ($$0|0);\n   }\n   $157 = ((($this)) + 16|0);\n   $$pre75 = HEAP32[$2>>2]|0;\n   $160 = $$pre75;$176 = $155;$row10$020 = $154;\n   while(1) {\n    $158 = HEAP32[$this>>2]|0;\n    $159 = ($158|0)>($160|0);\n    if ($159) {\n     $163 = $176;$177 = $160;\n    } else {\n     $col11$016 = $158;\n     while(1) {\n      $164 = HEAP32[$157>>2]|0;\n      $165 = (($164) + (($row10$020*12)|0)|0);\n      $166 = HEAP32[$165>>2]|0;\n      $167 = (($166) + ($col11$016)|0);\n      $168 = HEAP8[$167>>0]|0;\n      $169 = $168&255;\n      HEAP32[$vararg_buffer22>>2] = $169;\n      $vararg_ptr25 = ((($vararg_buffer22)) + 4|0);\n      HEAP32[$vararg_ptr25>>2] = $169;\n      $vararg_ptr26 = ((($vararg_buffer22)) + 8|0);\n      HEAP32[$vararg_ptr26>>2] = $169;\n      (_fprintf($f,1454,$vararg_buffer22)|0);\n      $170 = (($col11$016) + 1)|0;\n      $171 = HEAP32[$2>>2]|0;\n      $172 = ($col11$016|0)<($171|0);\n      if ($172) {\n       $col11$016 = $170;\n      } else {\n       $$lcssa113 = $171;\n       break;\n      }\n     }\n     $$pre76 = HEAP32[$7>>2]|0;\n     $163 = $$pre76;$177 = $$lcssa113;\n    }\n    $161 = (($row10$020) + 1)|0;\n    $162 = ($row10$020|0)<($163|0);\n    if ($162) {\n     $160 = $177;$176 = $163;$row10$020 = $161;\n    } else {\n     $$0 = 1;\n     break;\n    }\n   }\n   STACKTOP = sp;return ($$0|0);\n   break;\n  }\n  case 50:  {\n   $83 = HEAP32[$9>>2]|0;\n   $84 = HEAP32[$7>>2]|0;\n   $85 = ($83|0)>($84|0);\n   if ($85) {\n    $$0 = 1;\n    STACKTOP = sp;return ($$0|0);\n   }\n   $86 = ((($this)) + 16|0);\n   $row3$030 = $83;\n   while(1) {\n    $87 = HEAP32[$this>>2]|0;\n    $88 = HEAP32[$2>>2]|0;\n    $89 = ($87|0)<($88|0);\n    $90 = HEAP32[$86>>2]|0;\n    $91 = (($90) + (($row3$030*12)|0)|0);\n    $92 = HEAP32[$91>>2]|0;\n    if ($89) {\n     $100 = $92;$col4$024 = $87;\n     while(1) {\n      $99 = (($100) + ($col4$024)|0);\n      $101 = HEAP8[$99>>0]|0;\n      $102 = $101&255;\n      HEAP32[$vararg_buffer9>>2] = $102;\n      (_fprintf($f,1430,$vararg_buffer9)|0);\n      $103 = (($col4$024) + 1)|0;\n      $104 = HEAP32[$2>>2]|0;\n      $105 = ($103|0)<($104|0);\n      $106 = HEAP32[$86>>2]|0;\n      $107 = (($106) + (($row3$030*12)|0)|0);\n      $108 = HEAP32[$107>>2]|0;\n      if ($105) {\n       $100 = $108;$col4$024 = $103;\n      } else {\n       $$lcssa8 = $104;$$lcssa9 = $108;\n       break;\n      }\n     }\n    } else {\n     $$lcssa8 = $88;$$lcssa9 = $92;\n    }\n    $93 = (($$lcssa9) + ($$lcssa8)|0);\n    $94 = HEAP8[$93>>0]|0;\n    $95 = $94&255;\n    HEAP32[$vararg_buffer6>>2] = $95;\n    (_fprintf($f,1426,$vararg_buffer6)|0);\n    $96 = (($row3$030) + 1)|0;\n    $97 = HEAP32[$7>>2]|0;\n    $98 = ($row3$030|0)<($97|0);\n    if ($98) {\n     $row3$030 = $96;\n    } else {\n     $$0 = 1;\n     break;\n    }\n   }\n   STACKTOP = sp;return ($$0|0);\n   break;\n  }\n  case 53:  {\n   $109 = HEAP32[$9>>2]|0;\n   $110 = HEAP32[$7>>2]|0;\n   $111 = ($109|0)>($110|0);\n   if ($111) {\n    $$0 = 1;\n    STACKTOP = sp;return ($$0|0);\n   }\n   $112 = ((($this)) + 16|0);\n   $$pre73 = HEAP32[$2>>2]|0;\n   $115 = $$pre73;$174 = $110;$row5$038 = $109;\n   while(1) {\n    $113 = HEAP32[$this>>2]|0;\n    $114 = ($113|0)>($115|0);\n    if ($114) {\n     $118 = $174;$175 = $115;\n    } else {\n     $col6$034 = $113;\n     while(1) {\n      $119 = HEAP32[$112>>2]|0;\n      $120 = (($119) + (($row5$038*12)|0)|0);\n      $121 = HEAP32[$120>>2]|0;\n      $122 = (($121) + ($col6$034)|0);\n      $123 = HEAP8[$122>>0]|0;\n      $124 = $123&255;\n      (_fputc($124,$f)|0);\n      $125 = (($col6$034) + 1)|0;\n      $126 = HEAP32[$2>>2]|0;\n      $127 = ($col6$034|0)<($126|0);\n      if ($127) {\n       $col6$034 = $125;\n      } else {\n       $$lcssa116 = $126;\n       break;\n      }\n     }\n     $$pre74 = HEAP32[$7>>2]|0;\n     $118 = $$pre74;$175 = $$lcssa116;\n    }\n    $116 = (($row5$038) + 1)|0;\n    $117 = ($row5$038|0)<($118|0);\n    if ($117) {\n     $115 = $175;$174 = $118;$row5$038 = $116;\n    } else {\n     $$0 = 1;\n     break;\n    }\n   }\n   STACKTOP = sp;return ($$0|0);\n   break;\n  }\n  default: {\n   $$0 = 1;\n   STACKTOP = sp;return ($$0|0);\n  }\n  }\n }\n }\n return (0)|0;\n}\nfunction __ZN10Page_imageC2ERK12OCRAD_Pixmapb($this,$image,$invert) {\n $this = $this|0;\n $image = $image|0;\n $invert = $invert|0;\n var $$0$i1$i$i = 0, $$0$i1$i$i$us = 0, $$0$i1$i$i12$us = 0, $$0$i1$i$i35$us = 0, $$0$i1$i$i50$us = 0, $$0$i1$i$i65$us = 0, $$0$i2$i$i = 0, $$0$i2$i$i$us = 0, $$0$i2$i$i13$us = 0, $$0$i2$i$i36$us = 0, $$0$i2$i$i51$us = 0, $$0$i2$i$i66$us = 0, $$in = 0, $$in$i$i = 0, $$in$i$i$us = 0, $$in$i$i32$us = 0, $$in$i$i47$us = 0, $$in$i$i62$us = 0, $$in$i$i9$us = 0, $$lcssa = 0;\n var $$lcssa200 = 0, $$lcssa201 = 0, $$lcssa202 = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i$i$i21 = 0, $$pre$i$i$us = 0, $$pre$i$i28$us = 0, $$pre$i$i43$us = 0, $$pre$i$i5$us = 0, $$pre$i$i58$us = 0, $$pre$i$us = 0, $$pre$i24 = 0, $$pre$i30$us = 0, $$pre$i45$us = 0, $$pre$i60$us = 0, $$pre$i7$us = 0, $$pre$phi$i$usZ2D = 0, $$pre$phi$i31$usZ2D = 0;\n var $$pre$phi$i46$usZ2D = 0, $$pre$phi$i61$usZ2D = 0, $$pre$phi$i8$usZ2D = 0, $$pre$phi$iZ2D = 0, $$pre$phi169Z2D = 0, $$pre$phiZ2D = 0, $$pre166 = 0, $$pre167 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0;\n var $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0;\n var $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0;\n var $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0;\n var $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0;\n var $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0;\n var $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0;\n var $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0;\n var $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0;\n var $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0;\n var $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0;\n var $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0;\n var $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0;\n var $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0;\n var $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0;\n var $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0;\n var $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0;\n var $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0;\n var $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0;\n var $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0;\n var $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0;\n var $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0;\n var $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0;\n var $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $col$0111$us = 0, $col10$0119$us = 0;\n var $col13$0135 = 0, $col13$0135$us = 0, $col4$0106$us = 0, $col7$0127$us = 0, $i$0115$us = 0, $i$1110$us = 0, $i11$0139 = 0, $i11$1$lcssa = 0, $i11$1134 = 0, $i11$1134$us = 0, $i2$0107$us = 0, $i2$1105$us = 0, $i5$0131$us = 0, $i5$1126$us = 0, $i8$0123$us = 0, $i8$1118$us = 0, $lpad$phi$index = 0, $lpad$phi$index8 = 0, $not$$us = 0, $row$0142 = 0;\n var $row1$0116$us = 0, $row12$0140 = 0, $row3$0108$us = 0, $row6$0132$us = 0, $row9$0124$us = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ((($image)) + 8|0);\n $1 = HEAP32[$0>>2]|0;\n $2 = (($1) + -1)|0;\n $3 = ((($image)) + 4|0);\n $4 = HEAP32[$3>>2]|0;\n $5 = (($4) + -1)|0;\n __ZN9RectangleC2Eiiii($this,0,0,$2,$5);\n $6 = ((($this)) + 16|0);\n HEAP32[$6>>2] = 0;\n $7 = ((($this)) + 20|0);\n HEAP32[$7>>2] = 0;\n $8 = ((($this)) + 24|0);\n HEAP32[$8>>2] = 0;\n $9 = ((($this)) + 12|0);\n $10 = HEAP32[$9>>2]|0;\n $11 = ((($this)) + 4|0);\n $12 = HEAP32[$11>>2]|0;\n $13 = (($10) + 1)|0;\n $14 = ($13|0)==($12|0);\n L1: do {\n  if ($14) {\n   label = 4;\n  } else {\n   $15 = (($13) - ($12))|0;\n   __THREW__ = 0;\n   invoke_vii(38,($6|0),($15|0));\n   $16 = __THREW__; __THREW__ = 0;\n   $17 = $16&1;\n   if ($17) {\n    $34 = ___cxa_find_matching_catch_2()|0;\n    $35 = tempRet0;\n    $lpad$phi$index = $34;$lpad$phi$index8 = $35;\n    break;\n   }\n   $$pre = HEAP32[$7>>2]|0;\n   $$pre166 = HEAP32[$6>>2]|0;\n   $18 = ($$pre|0)==($$pre166|0);\n   if ($18) {\n    label = 4;\n   } else {\n    $19 = ((($this)) + 8|0);\n    $$in = $$pre166;$row$0142 = 0;\n    while(1) {\n     $50 = $$in;\n     $51 = (($50) + (($row$0142*12)|0)|0);\n     $52 = HEAP32[$19>>2]|0;\n     $53 = HEAP32[$this>>2]|0;\n     $54 = (($52) + 1)|0;\n     $55 = (($54) - ($53))|0;\n     $56 = (((($50) + (($row$0142*12)|0)|0)) + 8|0);\n     $57 = HEAP32[$56>>2]|0;\n     $58 = HEAP32[$51>>2]|0;\n     $59 = (($57) - ($58))|0;\n     $60 = ($59>>>0)<($55>>>0);\n     $61 = $58;\n     if ($60) {\n      $62 = (((($50) + (($row$0142*12)|0)|0)) + 4|0);\n      $63 = HEAP32[$62>>2]|0;\n      $64 = (($63) - ($58))|0;\n      $65 = ($54|0)==($53|0);\n      if ($65) {\n       $70 = 0;\n      } else {\n       __THREW__ = 0;\n       $66 = (invoke_ii(29,($55|0))|0);\n       $67 = __THREW__; __THREW__ = 0;\n       $68 = $67&1;\n       if ($68) {\n        break;\n       } else {\n        $70 = $66;\n       }\n      }\n      $69 = (($70) + ($64)|0);\n      $71 = $69;\n      $72 = (($70) + ($55)|0);\n      $73 = $72;\n      $74 = (0 - ($64))|0;\n      $75 = (($69) + ($74)|0);\n      $76 = $75;\n      _memcpy(($75|0),($61|0),($64|0))|0;\n      HEAP32[$51>>2] = $76;\n      HEAP32[$62>>2] = $71;\n      HEAP32[$56>>2] = $73;\n      $77 = ($58|0)==(0);\n      if (!($77)) {\n       __ZdlPv($61);\n      }\n     }\n     $78 = (($row$0142) + 1)|0;\n     $79 = HEAP32[$7>>2]|0;\n     $80 = HEAP32[$6>>2]|0;\n     $81 = (($79) - ($80))|0;\n     $82 = (($81|0) / 12)&-1;\n     $83 = ($78>>>0)<($82>>>0);\n     if ($83) {\n      $$in = $80;$row$0142 = $78;\n     } else {\n      $$pre$phi169Z2D = $this;$$pre$phiZ2D = $19;\n      label = 6;\n      break L1;\n     }\n    }\n    $32 = ___cxa_find_matching_catch_2()|0;\n    $33 = tempRet0;\n    $lpad$phi$index = $32;$lpad$phi$index8 = $33;\n   }\n  }\n } while(0);\n if ((label|0) == 4) {\n  $$pre167 = ((($this)) + 8|0);\n  $$pre$phi169Z2D = $this;$$pre$phiZ2D = $$pre167;\n  label = 6;\n }\n L19: do {\n  if ((label|0) == 6) {\n   $20 = HEAP32[$9>>2]|0;\n   $21 = HEAP32[$11>>2]|0;\n   $22 = (($20) + 1)|0;\n   $23 = (($22) - ($21))|0;\n   $24 = HEAP32[$$pre$phiZ2D>>2]|0;\n   $25 = HEAP32[$$pre$phi169Z2D>>2]|0;\n   $26 = (($24) + 1)|0;\n   $27 = (($26) - ($25))|0;\n   $28 = ((($image)) + 12|0);\n   $29 = HEAP32[$28>>2]|0;\n   switch ($29|0) {\n   case 0:  {\n    $84 = ((($this)) + 28|0);\n    HEAP8[$84>>0] = 1;\n    $85 = ((($this)) + 29|0);\n    HEAP8[$85>>0] = 0;\n    $86 = ($23|0)>(0);\n    if ($invert) {\n     if (!($86)) {\n      return;\n     }\n     $144 = ($27|0)>(0);\n     if ($144) {\n      $i2$0107$us = 0;$row3$0108$us = 0;\n     } else {\n      return;\n     }\n     L30: while(1) {\n      $col4$0106$us = 0;$i2$1105$us = $i2$0107$us;\n      while(1) {\n       $145 = HEAP32[$6>>2]|0;\n       $146 = (($145) + (($row3$0108$us*12)|0)|0);\n       $147 = HEAP32[$image>>2]|0;\n       $148 = (($147) + ($i2$1105$us)|0);\n       $149 = HEAP8[$148>>0]|0;\n       $150 = ($149<<24>>24)!=(0);\n       $151 = $150&1;\n       $152 = (((($145) + (($row3$0108$us*12)|0)|0)) + 4|0);\n       $153 = HEAP32[$152>>2]|0;\n       $154 = (((($145) + (($row3$0108$us*12)|0)|0)) + 8|0);\n       $155 = HEAP32[$154>>2]|0;\n       $156 = ($153|0)==($155|0);\n       $157 = $155;\n       if ($156) {\n        $160 = $153;\n        $161 = HEAP32[$146>>2]|0;\n        $162 = (($160) - ($161))|0;\n        $163 = (($162) + 1)|0;\n        $164 = ($163|0)<(0);\n        if ($164) {\n         __THREW__ = 0;\n         invoke_vi(46,($146|0));\n         $165 = __THREW__; __THREW__ = 0;\n         $166 = $165&1;\n         if ($166) {\n          label = 61;\n          break L30;\n         }\n         $$pre$i$i43$us = HEAP32[$146>>2]|0;\n         $$pre$i45$us = HEAP32[$154>>2]|0;\n         $$in$i$i47$us = $$pre$i$i43$us;$$pre$phi$i46$usZ2D = $154;$169 = $$pre$i45$us;\n        } else {\n         $$in$i$i47$us = $161;$$pre$phi$i46$usZ2D = $154;$169 = $157;\n        }\n        $167 = $$in$i$i47$us;\n        $168 = (($169) - ($$in$i$i47$us))|0;\n        $170 = ($168>>>0)<(1073741823);\n        if ($170) {\n         $173 = $168 << 1;\n         $174 = ($173>>>0)<($163>>>0);\n         $175 = $174 ? $163 : $173;\n         $176 = HEAP32[$152>>2]|0;\n         $177 = (($176) - ($$in$i$i47$us))|0;\n         $178 = ($175|0)==(0);\n         if ($178) {\n          $$0$i2$i$i51$us = 0;$183 = 0;$184 = $177;$190 = $176;\n         } else {\n          $$0$i1$i$i50$us = $175;$460 = $176;$461 = $177;\n          label = 55;\n         }\n        } else {\n         $171 = HEAP32[$152>>2]|0;\n         $172 = (($171) - ($$in$i$i47$us))|0;\n         $$0$i1$i$i50$us = 2147483647;$460 = $171;$461 = $172;\n         label = 55;\n        }\n        if ((label|0) == 55) {\n         label = 0;\n         __THREW__ = 0;\n         $179 = (invoke_ii(29,($$0$i1$i$i50$us|0))|0);\n         $180 = __THREW__; __THREW__ = 0;\n         $181 = $180&1;\n         if ($181) {\n          label = 61;\n          break L30;\n         } else {\n          $$0$i2$i$i51$us = $$0$i1$i$i50$us;$183 = $179;$184 = $461;$190 = $460;\n         }\n        }\n        $182 = (($183) + ($184)|0);\n        $185 = (($183) + ($$0$i2$i$i51$us)|0);\n        $186 = $185;\n        HEAP8[$182>>0] = $151;\n        $187 = ((($182)) + 1|0);\n        $188 = $187;\n        $189 = (($190) - ($$in$i$i47$us))|0;\n        $191 = (0 - ($189))|0;\n        $192 = (($182) + ($191)|0);\n        $193 = $192;\n        _memcpy(($192|0),($167|0),($189|0))|0;\n        HEAP32[$146>>2] = $193;\n        HEAP32[$152>>2] = $188;\n        HEAP32[$$pre$phi$i46$usZ2D>>2] = $186;\n        $194 = ($$in$i$i47$us|0)==(0);\n        if (!($194)) {\n         __ZdlPv($167);\n        }\n       } else {\n        HEAP8[$153>>0] = $151;\n        $158 = HEAP32[$152>>2]|0;\n        $159 = ((($158)) + 1|0);\n        HEAP32[$152>>2] = $159;\n       }\n       $195 = (($col4$0106$us) + 1)|0;\n       $196 = (($i2$1105$us) + 1)|0;\n       $197 = ($195|0)<($27|0);\n       if ($197) {\n        $col4$0106$us = $195;$i2$1105$us = $196;\n       } else {\n        $$lcssa = $196;\n        break;\n       }\n      }\n      $198 = (($row3$0108$us) + 1)|0;\n      $199 = ($198|0)<($23|0);\n      if ($199) {\n       $i2$0107$us = $$lcssa;$row3$0108$us = $198;\n      } else {\n       label = 131;\n       break;\n      }\n     }\n     if ((label|0) == 61) {\n      $200 = ___cxa_find_matching_catch_2()|0;\n      $201 = tempRet0;\n      $lpad$phi$index = $200;$lpad$phi$index8 = $201;\n      break L19;\n     }\n     else if ((label|0) == 131) {\n      return;\n     }\n    } else {\n     if (!($86)) {\n      return;\n     }\n     $87 = ($27|0)>(0);\n     if ($87) {\n      $i$0115$us = 0;$row1$0116$us = 0;\n     } else {\n      return;\n     }\n     L60: while(1) {\n      $col$0111$us = 0;$i$1110$us = $i$0115$us;\n      while(1) {\n       $88 = HEAP32[$6>>2]|0;\n       $89 = (($88) + (($row1$0116$us*12)|0)|0);\n       $90 = HEAP32[$image>>2]|0;\n       $91 = (($90) + ($i$1110$us)|0);\n       $92 = HEAP8[$91>>0]|0;\n       $not$$us = ($92<<24>>24)==(0);\n       $93 = $not$$us&1;\n       $94 = (((($88) + (($row1$0116$us*12)|0)|0)) + 4|0);\n       $95 = HEAP32[$94>>2]|0;\n       $96 = (((($88) + (($row1$0116$us*12)|0)|0)) + 8|0);\n       $97 = HEAP32[$96>>2]|0;\n       $98 = ($95|0)==($97|0);\n       $99 = $97;\n       if ($98) {\n        $102 = $95;\n        $103 = HEAP32[$89>>2]|0;\n        $104 = (($102) - ($103))|0;\n        $105 = (($104) + 1)|0;\n        $106 = ($105|0)<(0);\n        if ($106) {\n         __THREW__ = 0;\n         invoke_vi(46,($89|0));\n         $107 = __THREW__; __THREW__ = 0;\n         $108 = $107&1;\n         if ($108) {\n          label = 43;\n          break L60;\n         }\n         $$pre$i$i28$us = HEAP32[$89>>2]|0;\n         $$pre$i30$us = HEAP32[$96>>2]|0;\n         $$in$i$i32$us = $$pre$i$i28$us;$$pre$phi$i31$usZ2D = $96;$111 = $$pre$i30$us;\n        } else {\n         $$in$i$i32$us = $103;$$pre$phi$i31$usZ2D = $96;$111 = $99;\n        }\n        $109 = $$in$i$i32$us;\n        $110 = (($111) - ($$in$i$i32$us))|0;\n        $112 = ($110>>>0)<(1073741823);\n        if ($112) {\n         $115 = $110 << 1;\n         $116 = ($115>>>0)<($105>>>0);\n         $117 = $116 ? $105 : $115;\n         $118 = HEAP32[$94>>2]|0;\n         $119 = (($118) - ($$in$i$i32$us))|0;\n         $120 = ($117|0)==(0);\n         if ($120) {\n          $$0$i2$i$i36$us = 0;$125 = 0;$126 = $119;$132 = $118;\n         } else {\n          $$0$i1$i$i35$us = $117;$458 = $118;$459 = $119;\n          label = 37;\n         }\n        } else {\n         $113 = HEAP32[$94>>2]|0;\n         $114 = (($113) - ($$in$i$i32$us))|0;\n         $$0$i1$i$i35$us = 2147483647;$458 = $113;$459 = $114;\n         label = 37;\n        }\n        if ((label|0) == 37) {\n         label = 0;\n         __THREW__ = 0;\n         $121 = (invoke_ii(29,($$0$i1$i$i35$us|0))|0);\n         $122 = __THREW__; __THREW__ = 0;\n         $123 = $122&1;\n         if ($123) {\n          label = 43;\n          break L60;\n         } else {\n          $$0$i2$i$i36$us = $$0$i1$i$i35$us;$125 = $121;$126 = $459;$132 = $458;\n         }\n        }\n        $124 = (($125) + ($126)|0);\n        $127 = (($125) + ($$0$i2$i$i36$us)|0);\n        $128 = $127;\n        HEAP8[$124>>0] = $93;\n        $129 = ((($124)) + 1|0);\n        $130 = $129;\n        $131 = (($132) - ($$in$i$i32$us))|0;\n        $133 = (0 - ($131))|0;\n        $134 = (($124) + ($133)|0);\n        $135 = $134;\n        _memcpy(($134|0),($109|0),($131|0))|0;\n        HEAP32[$89>>2] = $135;\n        HEAP32[$94>>2] = $130;\n        HEAP32[$$pre$phi$i31$usZ2D>>2] = $128;\n        $136 = ($$in$i$i32$us|0)==(0);\n        if (!($136)) {\n         __ZdlPv($109);\n        }\n       } else {\n        HEAP8[$95>>0] = $93;\n        $100 = HEAP32[$94>>2]|0;\n        $101 = ((($100)) + 1|0);\n        HEAP32[$94>>2] = $101;\n       }\n       $137 = (($col$0111$us) + 1)|0;\n       $138 = (($i$1110$us) + 1)|0;\n       $139 = ($137|0)<($27|0);\n       if ($139) {\n        $col$0111$us = $137;$i$1110$us = $138;\n       } else {\n        $$lcssa200 = $138;\n        break;\n       }\n      }\n      $140 = (($row1$0116$us) + 1)|0;\n      $141 = ($140|0)<($23|0);\n      if ($141) {\n       $i$0115$us = $$lcssa200;$row1$0116$us = $140;\n      } else {\n       label = 131;\n       break;\n      }\n     }\n     if ((label|0) == 43) {\n      $142 = ___cxa_find_matching_catch_2()|0;\n      $143 = tempRet0;\n      $lpad$phi$index = $142;$lpad$phi$index8 = $143;\n      break L19;\n     }\n     else if ((label|0) == 131) {\n      return;\n     }\n    }\n    break;\n   }\n   case 1:  {\n    $202 = ((($this)) + 28|0);\n    HEAP8[$202>>0] = -1;\n    $203 = ((($this)) + 29|0);\n    HEAP8[$203>>0] = 127;\n    $204 = ($23|0)>(0);\n    if ($invert) {\n     if (!($204)) {\n      return;\n     }\n     $262 = ($27|0)>(0);\n     if ($262) {\n      $i8$0123$us = 0;$row9$0124$us = 0;\n     } else {\n      return;\n     }\n     L92: while(1) {\n      $col10$0119$us = 0;$i8$1118$us = $i8$0123$us;\n      while(1) {\n       $263 = HEAP32[$6>>2]|0;\n       $264 = (($263) + (($row9$0124$us*12)|0)|0);\n       $265 = HEAP8[$202>>0]|0;\n       $266 = $265&255;\n       $267 = HEAP32[$image>>2]|0;\n       $268 = (($267) + ($i8$1118$us)|0);\n       $269 = HEAP8[$268>>0]|0;\n       $270 = $269&255;\n       $271 = (($266) - ($270))|0;\n       $272 = $271&255;\n       $273 = (((($263) + (($row9$0124$us*12)|0)|0)) + 4|0);\n       $274 = HEAP32[$273>>2]|0;\n       $275 = (((($263) + (($row9$0124$us*12)|0)|0)) + 8|0);\n       $276 = HEAP32[$275>>2]|0;\n       $277 = ($274|0)==($276|0);\n       $278 = $276;\n       if ($277) {\n        $281 = $274;\n        $282 = HEAP32[$264>>2]|0;\n        $283 = (($281) - ($282))|0;\n        $284 = (($283) + 1)|0;\n        $285 = ($284|0)<(0);\n        if ($285) {\n         __THREW__ = 0;\n         invoke_vi(46,($264|0));\n         $286 = __THREW__; __THREW__ = 0;\n         $287 = $286&1;\n         if ($287) {\n          label = 98;\n          break L92;\n         }\n         $$pre$i$i5$us = HEAP32[$264>>2]|0;\n         $$pre$i7$us = HEAP32[$275>>2]|0;\n         $$in$i$i9$us = $$pre$i$i5$us;$$pre$phi$i8$usZ2D = $275;$290 = $$pre$i7$us;\n        } else {\n         $$in$i$i9$us = $282;$$pre$phi$i8$usZ2D = $275;$290 = $278;\n        }\n        $288 = $$in$i$i9$us;\n        $289 = (($290) - ($$in$i$i9$us))|0;\n        $291 = ($289>>>0)<(1073741823);\n        if ($291) {\n         $294 = $289 << 1;\n         $295 = ($294>>>0)<($284>>>0);\n         $296 = $295 ? $284 : $294;\n         $297 = HEAP32[$273>>2]|0;\n         $298 = (($297) - ($$in$i$i9$us))|0;\n         $299 = ($296|0)==(0);\n         if ($299) {\n          $$0$i2$i$i13$us = 0;$304 = 0;$305 = $298;$311 = $297;\n         } else {\n          $$0$i1$i$i12$us = $296;$464 = $297;$465 = $298;\n          label = 92;\n         }\n        } else {\n         $292 = HEAP32[$273>>2]|0;\n         $293 = (($292) - ($$in$i$i9$us))|0;\n         $$0$i1$i$i12$us = 2147483647;$464 = $292;$465 = $293;\n         label = 92;\n        }\n        if ((label|0) == 92) {\n         label = 0;\n         __THREW__ = 0;\n         $300 = (invoke_ii(29,($$0$i1$i$i12$us|0))|0);\n         $301 = __THREW__; __THREW__ = 0;\n         $302 = $301&1;\n         if ($302) {\n          label = 98;\n          break L92;\n         } else {\n          $$0$i2$i$i13$us = $$0$i1$i$i12$us;$304 = $300;$305 = $465;$311 = $464;\n         }\n        }\n        $303 = (($304) + ($305)|0);\n        $306 = (($304) + ($$0$i2$i$i13$us)|0);\n        $307 = $306;\n        HEAP8[$303>>0] = $272;\n        $308 = ((($303)) + 1|0);\n        $309 = $308;\n        $310 = (($311) - ($$in$i$i9$us))|0;\n        $312 = (0 - ($310))|0;\n        $313 = (($303) + ($312)|0);\n        $314 = $313;\n        _memcpy(($313|0),($288|0),($310|0))|0;\n        HEAP32[$264>>2] = $314;\n        HEAP32[$273>>2] = $309;\n        HEAP32[$$pre$phi$i8$usZ2D>>2] = $307;\n        $315 = ($$in$i$i9$us|0)==(0);\n        if (!($315)) {\n         __ZdlPv($288);\n        }\n       } else {\n        HEAP8[$274>>0] = $272;\n        $279 = HEAP32[$273>>2]|0;\n        $280 = ((($279)) + 1|0);\n        HEAP32[$273>>2] = $280;\n       }\n       $316 = (($col10$0119$us) + 1)|0;\n       $317 = (($i8$1118$us) + 1)|0;\n       $318 = ($316|0)<($27|0);\n       if ($318) {\n        $col10$0119$us = $316;$i8$1118$us = $317;\n       } else {\n        $$lcssa201 = $317;\n        break;\n       }\n      }\n      $319 = (($row9$0124$us) + 1)|0;\n      $320 = ($319|0)<($23|0);\n      if ($320) {\n       $i8$0123$us = $$lcssa201;$row9$0124$us = $319;\n      } else {\n       label = 131;\n       break;\n      }\n     }\n     if ((label|0) == 98) {\n      $321 = ___cxa_find_matching_catch_2()|0;\n      $322 = tempRet0;\n      $lpad$phi$index = $321;$lpad$phi$index8 = $322;\n      break L19;\n     }\n     else if ((label|0) == 131) {\n      return;\n     }\n    } else {\n     if (!($204)) {\n      return;\n     }\n     $205 = ($27|0)>(0);\n     if ($205) {\n      $i5$0131$us = 0;$row6$0132$us = 0;\n     } else {\n      return;\n     }\n     L122: while(1) {\n      $col7$0127$us = 0;$i5$1126$us = $i5$0131$us;\n      while(1) {\n       $206 = HEAP32[$6>>2]|0;\n       $207 = (($206) + (($row6$0132$us*12)|0)|0);\n       $208 = HEAP32[$image>>2]|0;\n       $209 = (($208) + ($i5$1126$us)|0);\n       $210 = (((($206) + (($row6$0132$us*12)|0)|0)) + 4|0);\n       $211 = HEAP32[$210>>2]|0;\n       $212 = (((($206) + (($row6$0132$us*12)|0)|0)) + 8|0);\n       $213 = HEAP32[$212>>2]|0;\n       $214 = ($211|0)==($213|0);\n       $215 = $213;\n       if ($214) {\n        $219 = $211;\n        $220 = HEAP32[$207>>2]|0;\n        $221 = (($219) - ($220))|0;\n        $222 = (($221) + 1)|0;\n        $223 = ($222|0)<(0);\n        if ($223) {\n         __THREW__ = 0;\n         invoke_vi(46,($207|0));\n         $224 = __THREW__; __THREW__ = 0;\n         $225 = $224&1;\n         if ($225) {\n          label = 80;\n          break L122;\n         }\n         $$pre$i$i58$us = HEAP32[$207>>2]|0;\n         $$pre$i60$us = HEAP32[$212>>2]|0;\n         $$in$i$i62$us = $$pre$i$i58$us;$$pre$phi$i61$usZ2D = $212;$228 = $$pre$i60$us;\n        } else {\n         $$in$i$i62$us = $220;$$pre$phi$i61$usZ2D = $212;$228 = $215;\n        }\n        $226 = $$in$i$i62$us;\n        $227 = (($228) - ($$in$i$i62$us))|0;\n        $229 = ($227>>>0)<(1073741823);\n        if ($229) {\n         $232 = $227 << 1;\n         $233 = ($232>>>0)<($222>>>0);\n         $234 = $233 ? $222 : $232;\n         $235 = HEAP32[$210>>2]|0;\n         $236 = (($235) - ($$in$i$i62$us))|0;\n         $237 = ($234|0)==(0);\n         if ($237) {\n          $$0$i2$i$i66$us = 0;$242 = 0;$243 = $236;$250 = $235;\n         } else {\n          $$0$i1$i$i65$us = $234;$462 = $235;$463 = $236;\n          label = 74;\n         }\n        } else {\n         $230 = HEAP32[$210>>2]|0;\n         $231 = (($230) - ($$in$i$i62$us))|0;\n         $$0$i1$i$i65$us = 2147483647;$462 = $230;$463 = $231;\n         label = 74;\n        }\n        if ((label|0) == 74) {\n         label = 0;\n         __THREW__ = 0;\n         $238 = (invoke_ii(29,($$0$i1$i$i65$us|0))|0);\n         $239 = __THREW__; __THREW__ = 0;\n         $240 = $239&1;\n         if ($240) {\n          label = 80;\n          break L122;\n         } else {\n          $$0$i2$i$i66$us = $$0$i1$i$i65$us;$242 = $238;$243 = $463;$250 = $462;\n         }\n        }\n        $241 = (($242) + ($243)|0);\n        $244 = (($242) + ($$0$i2$i$i66$us)|0);\n        $245 = $244;\n        $246 = HEAP8[$209>>0]|0;\n        HEAP8[$241>>0] = $246;\n        $247 = ((($241)) + 1|0);\n        $248 = $247;\n        $249 = (($250) - ($$in$i$i62$us))|0;\n        $251 = (0 - ($249))|0;\n        $252 = (($241) + ($251)|0);\n        $253 = $252;\n        _memcpy(($252|0),($226|0),($249|0))|0;\n        HEAP32[$207>>2] = $253;\n        HEAP32[$210>>2] = $248;\n        HEAP32[$$pre$phi$i61$usZ2D>>2] = $245;\n        $254 = ($$in$i$i62$us|0)==(0);\n        if (!($254)) {\n         __ZdlPv($226);\n        }\n       } else {\n        $216 = HEAP8[$209>>0]|0;\n        HEAP8[$211>>0] = $216;\n        $217 = HEAP32[$210>>2]|0;\n        $218 = ((($217)) + 1|0);\n        HEAP32[$210>>2] = $218;\n       }\n       $255 = (($col7$0127$us) + 1)|0;\n       $256 = (($i5$1126$us) + 1)|0;\n       $257 = ($255|0)<($27|0);\n       if ($257) {\n        $col7$0127$us = $255;$i5$1126$us = $256;\n       } else {\n        $$lcssa202 = $256;\n        break;\n       }\n      }\n      $258 = (($row6$0132$us) + 1)|0;\n      $259 = ($258|0)<($23|0);\n      if ($259) {\n       $i5$0131$us = $$lcssa202;$row6$0132$us = $258;\n      } else {\n       label = 131;\n       break;\n      }\n     }\n     if ((label|0) == 80) {\n      $260 = ___cxa_find_matching_catch_2()|0;\n      $261 = tempRet0;\n      $lpad$phi$index = $260;$lpad$phi$index8 = $261;\n      break L19;\n     }\n     else if ((label|0) == 131) {\n      return;\n     }\n    }\n    break;\n   }\n   case 2:  {\n    $323 = ((($this)) + 28|0);\n    HEAP8[$323>>0] = -1;\n    $324 = ((($this)) + 29|0);\n    HEAP8[$324>>0] = 127;\n    $325 = ($23|0)>(0);\n    if (!($325)) {\n     return;\n    }\n    $326 = ($27|0)>(0);\n    $i11$0139 = 0;$row12$0140 = 0;\n    L150: while(1) {\n     if ($326) {\n      if ($invert) {\n       $col13$0135$us = 0;$i11$1134$us = $i11$0139;\n       while(1) {\n        $327 = HEAP32[$image>>2]|0;\n        $328 = (($327) + ($i11$1134$us)|0);\n        $329 = HEAP8[$328>>0]|0;\n        $330 = (($i11$1134$us) + 1)|0;\n        $331 = (($327) + ($330)|0);\n        $332 = HEAP8[$331>>0]|0;\n        $333 = (($i11$1134$us) + 2)|0;\n        $334 = (($327) + ($333)|0);\n        $335 = HEAP8[$334>>0]|0;\n        $336 = HEAP8[$323>>0]|0;\n        $337 = $336&255;\n        $338 = ($332&255)<($335&255);\n        $339 = $338 ? $335 : $332;\n        $340 = ($329&255)<($339&255);\n        $341 = $340 ? $339 : $329;\n        $342 = $341&255;\n        $343 = (($337) - ($342))|0;\n        $344 = $343&255;\n        $345 = HEAP32[$6>>2]|0;\n        $346 = (($345) + (($row12$0140*12)|0)|0);\n        $347 = (((($345) + (($row12$0140*12)|0)|0)) + 4|0);\n        $348 = HEAP32[$347>>2]|0;\n        $349 = (((($345) + (($row12$0140*12)|0)|0)) + 8|0);\n        $350 = HEAP32[$349>>2]|0;\n        $351 = ($348|0)==($350|0);\n        $352 = $350;\n        if ($351) {\n         $355 = $348;\n         $356 = HEAP32[$346>>2]|0;\n         $357 = (($355) - ($356))|0;\n         $358 = (($357) + 1)|0;\n         $359 = ($358|0)<(0);\n         if ($359) {\n          __THREW__ = 0;\n          invoke_vi(46,($346|0));\n          $360 = __THREW__; __THREW__ = 0;\n          $361 = $360&1;\n          if ($361) {\n           label = 116;\n           break L150;\n          }\n          $$pre$i$i$us = HEAP32[$346>>2]|0;\n          $$pre$i$us = HEAP32[$349>>2]|0;\n          $$in$i$i$us = $$pre$i$i$us;$$pre$phi$i$usZ2D = $349;$364 = $$pre$i$us;\n         } else {\n          $$in$i$i$us = $356;$$pre$phi$i$usZ2D = $349;$364 = $352;\n         }\n         $362 = $$in$i$i$us;\n         $363 = (($364) - ($$in$i$i$us))|0;\n         $365 = ($363>>>0)<(1073741823);\n         if ($365) {\n          $368 = $363 << 1;\n          $369 = ($368>>>0)<($358>>>0);\n          $370 = $369 ? $358 : $368;\n          $371 = HEAP32[$347>>2]|0;\n          $372 = (($371) - ($$in$i$i$us))|0;\n          $373 = ($370|0)==(0);\n          if ($373) {\n           $$0$i2$i$i$us = 0;$378 = 0;$379 = $372;$385 = $371;\n          } else {\n           $$0$i1$i$i$us = $370;$466 = $371;$467 = $372;\n           label = 112;\n          }\n         } else {\n          $366 = HEAP32[$347>>2]|0;\n          $367 = (($366) - ($$in$i$i$us))|0;\n          $$0$i1$i$i$us = 2147483647;$466 = $366;$467 = $367;\n          label = 112;\n         }\n         if ((label|0) == 112) {\n          label = 0;\n          __THREW__ = 0;\n          $374 = (invoke_ii(29,($$0$i1$i$i$us|0))|0);\n          $375 = __THREW__; __THREW__ = 0;\n          $376 = $375&1;\n          if ($376) {\n           label = 116;\n           break L150;\n          } else {\n           $$0$i2$i$i$us = $$0$i1$i$i$us;$378 = $374;$379 = $467;$385 = $466;\n          }\n         }\n         $377 = (($378) + ($379)|0);\n         $380 = (($378) + ($$0$i2$i$i$us)|0);\n         $381 = $380;\n         HEAP8[$377>>0] = $344;\n         $382 = ((($377)) + 1|0);\n         $383 = $382;\n         $384 = (($385) - ($$in$i$i$us))|0;\n         $386 = (0 - ($384))|0;\n         $387 = (($377) + ($386)|0);\n         $388 = $387;\n         _memcpy(($387|0),($362|0),($384|0))|0;\n         HEAP32[$346>>2] = $388;\n         HEAP32[$347>>2] = $383;\n         HEAP32[$$pre$phi$i$usZ2D>>2] = $381;\n         $389 = ($$in$i$i$us|0)==(0);\n         if (!($389)) {\n          __ZdlPv($362);\n         }\n        } else {\n         HEAP8[$348>>0] = $344;\n         $353 = HEAP32[$347>>2]|0;\n         $354 = ((($353)) + 1|0);\n         HEAP32[$347>>2] = $354;\n        }\n        $390 = (($col13$0135$us) + 1)|0;\n        $391 = (($i11$1134$us) + 3)|0;\n        $392 = ($390|0)<($27|0);\n        if ($392) {\n         $col13$0135$us = $390;$i11$1134$us = $391;\n        } else {\n         $i11$1$lcssa = $391;\n         break;\n        }\n       }\n      } else {\n       $col13$0135 = 0;$i11$1134 = $i11$0139;\n       while(1) {\n        $397 = HEAP32[$image>>2]|0;\n        $398 = (($397) + ($i11$1134)|0);\n        $399 = HEAP8[$398>>0]|0;\n        $400 = (($i11$1134) + 1)|0;\n        $401 = (($397) + ($400)|0);\n        $402 = HEAP8[$401>>0]|0;\n        $403 = (($i11$1134) + 2)|0;\n        $404 = (($397) + ($403)|0);\n        $405 = HEAP8[$404>>0]|0;\n        $406 = ($405&255)<($402&255);\n        $407 = $406 ? $405 : $402;\n        $408 = ($407&255)<($399&255);\n        $409 = $408 ? $407 : $399;\n        $410 = HEAP32[$6>>2]|0;\n        $411 = (($410) + (($row12$0140*12)|0)|0);\n        $412 = (((($410) + (($row12$0140*12)|0)|0)) + 4|0);\n        $413 = HEAP32[$412>>2]|0;\n        $414 = (((($410) + (($row12$0140*12)|0)|0)) + 8|0);\n        $415 = HEAP32[$414>>2]|0;\n        $416 = ($413|0)==($415|0);\n        $417 = $415;\n        if ($416) {\n         $420 = $413;\n         $421 = HEAP32[$411>>2]|0;\n         $422 = (($420) - ($421))|0;\n         $423 = (($422) + 1)|0;\n         $424 = ($423|0)<(0);\n         if ($424) {\n          __THREW__ = 0;\n          invoke_vi(46,($411|0));\n          $425 = __THREW__; __THREW__ = 0;\n          $426 = $425&1;\n          if ($426) {\n           label = 7;\n           break L150;\n          }\n          $$pre$i$i = HEAP32[$411>>2]|0;\n          $$pre$i = HEAP32[$414>>2]|0;\n          $$in$i$i = $$pre$i$i;$$pre$phi$iZ2D = $414;$429 = $$pre$i;\n         } else {\n          $$in$i$i = $421;$$pre$phi$iZ2D = $414;$429 = $417;\n         }\n         $427 = $$in$i$i;\n         $428 = (($429) - ($$in$i$i))|0;\n         $430 = ($428>>>0)<(1073741823);\n         if ($430) {\n          $433 = $428 << 1;\n          $434 = ($433>>>0)<($423>>>0);\n          $435 = $434 ? $423 : $433;\n          $436 = HEAP32[$412>>2]|0;\n          $437 = (($436) - ($$in$i$i))|0;\n          $438 = ($435|0)==(0);\n          if ($438) {\n           $$0$i2$i$i = 0;$443 = 0;$444 = $437;$450 = $436;\n          } else {\n           $$0$i1$i$i = $435;$468 = $436;$469 = $437;\n           label = 127;\n          }\n         } else {\n          $431 = HEAP32[$412>>2]|0;\n          $432 = (($431) - ($$in$i$i))|0;\n          $$0$i1$i$i = 2147483647;$468 = $431;$469 = $432;\n          label = 127;\n         }\n         if ((label|0) == 127) {\n          label = 0;\n          __THREW__ = 0;\n          $439 = (invoke_ii(29,($$0$i1$i$i|0))|0);\n          $440 = __THREW__; __THREW__ = 0;\n          $441 = $440&1;\n          if ($441) {\n           label = 7;\n           break L150;\n          } else {\n           $$0$i2$i$i = $$0$i1$i$i;$443 = $439;$444 = $469;$450 = $468;\n          }\n         }\n         $442 = (($443) + ($444)|0);\n         $445 = (($443) + ($$0$i2$i$i)|0);\n         $446 = $445;\n         HEAP8[$442>>0] = $409;\n         $447 = ((($442)) + 1|0);\n         $448 = $447;\n         $449 = (($450) - ($$in$i$i))|0;\n         $451 = (0 - ($449))|0;\n         $452 = (($442) + ($451)|0);\n         $453 = $452;\n         _memcpy(($452|0),($427|0),($449|0))|0;\n         HEAP32[$411>>2] = $453;\n         HEAP32[$412>>2] = $448;\n         HEAP32[$$pre$phi$iZ2D>>2] = $446;\n         $454 = ($$in$i$i|0)==(0);\n         if (!($454)) {\n          __ZdlPv($427);\n         }\n        } else {\n         HEAP8[$413>>0] = $409;\n         $418 = HEAP32[$412>>2]|0;\n         $419 = ((($418)) + 1|0);\n         HEAP32[$412>>2] = $419;\n        }\n        $455 = (($col13$0135) + 1)|0;\n        $456 = (($i11$1134) + 3)|0;\n        $457 = ($455|0)<($27|0);\n        if ($457) {\n         $col13$0135 = $455;$i11$1134 = $456;\n        } else {\n         $i11$1$lcssa = $456;\n         break;\n        }\n       }\n      }\n     } else {\n      $i11$1$lcssa = $i11$0139;\n     }\n     $395 = (($row12$0140) + 1)|0;\n     $396 = ($395|0)<($23|0);\n     if ($396) {\n      $i11$0139 = $i11$1$lcssa;$row12$0140 = $395;\n     } else {\n      label = 131;\n      break;\n     }\n    }\n    if ((label|0) == 7) {\n     $30 = ___cxa_find_matching_catch_2()|0;\n     $31 = tempRet0;\n     $lpad$phi$index = $30;$lpad$phi$index8 = $31;\n     break L19;\n    }\n    else if ((label|0) == 116) {\n     $393 = ___cxa_find_matching_catch_2()|0;\n     $394 = tempRet0;\n     $lpad$phi$index = $393;$lpad$phi$index8 = $394;\n     break L19;\n    }\n    else if ((label|0) == 131) {\n     return;\n    }\n    break;\n   }\n   default: {\n    return;\n   }\n   }\n  }\n } while(0);\n $36 = HEAP32[$6>>2]|0;\n $37 = ($36|0)==(0|0);\n if ($37) {\n  ___resumeException($lpad$phi$index|0);\n  // unreachable;\n }\n $38 = HEAP32[$7>>2]|0;\n $39 = ($38|0)==($36|0);\n if ($39) {\n  $49 = $36;\n } else {\n  $41 = $38;\n  while(1) {\n   $40 = ((($41)) + -12|0);\n   HEAP32[$7>>2] = $40;\n   $42 = HEAP32[$40>>2]|0;\n   $43 = ($42|0)==(0|0);\n   if ($43) {\n    $44 = $40;\n   } else {\n    $46 = ((($41)) + -8|0);\n    $47 = HEAP32[$46>>2]|0;\n    $48 = ($47|0)==($42|0);\n    if (!($48)) {\n     HEAP32[$46>>2] = $42;\n    }\n    __ZdlPv($42);\n    $$pre$i$i$i21 = HEAP32[$7>>2]|0;\n    $44 = $$pre$i$i$i21;\n   }\n   $45 = ($44|0)==($36|0);\n   if ($45) {\n    break;\n   } else {\n    $41 = $44;\n   }\n  }\n  $$pre$i24 = HEAP32[$6>>2]|0;\n  $49 = $$pre$i24;\n }\n __ZdlPv($49);\n ___resumeException($lpad$phi$index|0);\n // unreachable;\n}\nfunction __ZN10Page_imageC2ERKS_i($this,$source,$scale) {\n $this = $this|0;\n $source = $source|0;\n $scale = $scale|0;\n var $$0$i1$i$i = 0, $$0$i1$i$i$us = 0, $$0$i2$i$i = 0, $$0$i2$i$i$us = 0, $$in$i$i = 0, $$in$i$i$us = 0, $$lcssa74 = 0, $$lcssa74$lcssa = 0, $$phi$trans$insert = 0, $$phi$trans$insert51 = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i$i$i = 0, $$pre$i$i$i8 = 0, $$pre$i$i$us = 0, $$pre$i$us = 0, $$pre$i3 = 0, $$pre52 = 0, $$pre53 = 0;\n var $$pre54 = 0, $$pre55 = 0, $$pre56 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0;\n var $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0;\n var $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0;\n var $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0;\n var $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0;\n var $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0;\n var $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0;\n var $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0;\n var $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0;\n var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0;\n var $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0;\n var $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0;\n var $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0;\n var $99 = 0, $col$030 = 0, $col$030$us = 0, $i$023$us$us = 0, $j$021$us$us = 0, $lpad$phi$index = 0, $lpad$phi$index4 = 0, $row$034 = 0, $sum$022$us$us = 0, $sum$120$us$us = 0, label = 0, sp = 0;\n sp = STACKTOP;\n ;HEAP32[$this>>2]=HEAP32[$source>>2]|0;HEAP32[$this+4>>2]=HEAP32[$source+4>>2]|0;HEAP32[$this+8>>2]=HEAP32[$source+8>>2]|0;HEAP32[$this+12>>2]=HEAP32[$source+12>>2]|0;\n $0 = ((($this)) + 16|0);\n HEAP32[$0>>2] = 0;\n $1 = ((($this)) + 20|0);\n HEAP32[$1>>2] = 0;\n $2 = ((($this)) + 24|0);\n HEAP32[$2>>2] = 0;\n $3 = ((($this)) + 28|0);\n $4 = ((($source)) + 28|0);\n $5 = HEAP16[$4>>1]|0;\n $6 = $5&255;\n HEAP8[$3>>0] = $6;\n $7 = ((($this)) + 29|0);\n $8 = ($5&65535) >>> 8;\n $9 = $8&255;\n HEAP8[$7>>0] = $9;\n $10 = ($scale|0)<(2);\n if ($10) {\n  label = 4;\n } else {\n  $11 = ((($source)) + 8|0);\n  $12 = HEAP32[$11>>2]|0;\n  $13 = HEAP32[$source>>2]|0;\n  $14 = (($12) + 1)|0;\n  $15 = (($14) - ($13))|0;\n  $16 = ($15|0)<($scale|0);\n  if ($16) {\n   label = 4;\n  } else {\n   $17 = ((($source)) + 12|0);\n   $18 = HEAP32[$17>>2]|0;\n   $19 = ((($source)) + 4|0);\n   $20 = HEAP32[$19>>2]|0;\n   $21 = (($18) + 1)|0;\n   $22 = (($21) - ($20))|0;\n   $23 = ($22|0)<($scale|0);\n   if ($23) {\n    label = 4;\n   } else {\n    $48 = $18;$50 = $20;\n    label = 18;\n   }\n  }\n }\n if ((label|0) == 4) {\n  __THREW__ = 0;\n  invoke_vi(47,(1464|0));\n  $24 = __THREW__; __THREW__ = 0;\n  $25 = $24&1;\n  if ($25) {\n   label = 8;\n  } else {\n   $$phi$trans$insert = ((($source)) + 12|0);\n   $$pre = HEAP32[$$phi$trans$insert>>2]|0;\n   $$phi$trans$insert51 = ((($source)) + 4|0);\n   $$pre52 = HEAP32[$$phi$trans$insert51>>2]|0;\n   $48 = $$pre;$50 = $$pre52;\n   label = 18;\n  }\n }\n do {\n  if ((label|0) == 18) {\n   $46 = Math_imul($scale, $scale)|0;\n   $47 = (($48) + 1)|0;\n   $49 = (($47) - ($50))|0;\n   $51 = (($49|0) / ($scale|0))&-1;\n   __THREW__ = 0;\n   invoke_vii(37,($this|0),($51|0));\n   $52 = __THREW__; __THREW__ = 0;\n   $53 = $52&1;\n   if ($53) {\n    label = 8;\n   } else {\n    $54 = ((($source)) + 8|0);\n    $55 = HEAP32[$54>>2]|0;\n    $56 = HEAP32[$source>>2]|0;\n    $57 = (($55) + 1)|0;\n    $58 = (($57) - ($56))|0;\n    $59 = (($58|0) / ($scale|0))&-1;\n    __THREW__ = 0;\n    invoke_vii(36,($this|0),($59|0));\n    $60 = __THREW__; __THREW__ = 0;\n    $61 = $60&1;\n    if ($61) {\n     label = 8;\n    } else {\n     $62 = ((($this)) + 12|0);\n     $63 = HEAP32[$62>>2]|0;\n     $64 = ((($this)) + 4|0);\n     $65 = HEAP32[$64>>2]|0;\n     $66 = (($63) + 1)|0;\n     $67 = (($66) - ($65))|0;\n     $68 = HEAP32[$1>>2]|0;\n     $69 = HEAP32[$0>>2]|0;\n     $70 = (($68) - ($69))|0;\n     $71 = (($70|0) / 12)&-1;\n     $72 = ($67>>>0)>($71>>>0);\n     $73 = $69;\n     $74 = $68;\n     if ($72) {\n      $75 = (($67) - ($71))|0;\n      __THREW__ = 0;\n      invoke_vii(38,($0|0),($75|0));\n      $76 = __THREW__; __THREW__ = 0;\n      $77 = $76&1;\n      if ($77) {\n       label = 8;\n       break;\n      }\n     } else {\n      $78 = ($67>>>0)<($71>>>0);\n      if ($78) {\n       $79 = (($73) + (($67*12)|0)|0);\n       $80 = ($74|0)==($79|0);\n       if (!($80)) {\n        $82 = $74;\n        while(1) {\n         $81 = ((($82)) + -12|0);\n         HEAP32[$1>>2] = $81;\n         $83 = HEAP32[$81>>2]|0;\n         $84 = ($83|0)==(0|0);\n         if ($84) {\n          $85 = $81;\n         } else {\n          $95 = ((($82)) + -8|0);\n          $96 = HEAP32[$95>>2]|0;\n          $97 = ($96|0)==($83|0);\n          if (!($97)) {\n           HEAP32[$95>>2] = $83;\n          }\n          __ZdlPv($83);\n          $$pre$i$i$i8 = HEAP32[$1>>2]|0;\n          $85 = $$pre$i$i$i8;\n         }\n         $86 = ($85|0)==($79|0);\n         if ($86) {\n          break;\n         } else {\n          $82 = $85;\n         }\n        }\n       }\n      }\n     }\n     $87 = HEAP32[$62>>2]|0;\n     $88 = HEAP32[$64>>2]|0;\n     $89 = (($87) + 1)|0;\n     $90 = (($89) - ($88))|0;\n     $91 = ($90|0)>(0);\n     if (!($91)) {\n      return;\n     }\n     $92 = ((($this)) + 8|0);\n     $93 = ((($source)) + 16|0);\n     $$pre53 = HEAP32[$92>>2]|0;\n     $$pre54 = HEAP32[$this>>2]|0;\n     $94 = ($scale|0)>(0);\n     $103 = $$pre53;$105 = $$pre54;$row$034 = 0;\n     L27: while(1) {\n      $98 = Math_imul($row$034, $scale)|0;\n      $99 = (($98) + ($scale))|0;\n      $100 = HEAP32[$0>>2]|0;\n      $101 = (($100) + (($row$034*12)|0)|0);\n      $102 = (($103) + 1)|0;\n      $104 = (($102) - ($105))|0;\n      $106 = (((($100) + (($row$034*12)|0)|0)) + 8|0);\n      $107 = HEAP32[$106>>2]|0;\n      $108 = HEAP32[$101>>2]|0;\n      $109 = (($107) - ($108))|0;\n      $110 = ($109>>>0)<($104>>>0);\n      $111 = $108;\n      if ($110) {\n       $112 = (((($100) + (($row$034*12)|0)|0)) + 4|0);\n       $113 = HEAP32[$112>>2]|0;\n       $114 = (($113) - ($108))|0;\n       $115 = ($102|0)==($105|0);\n       if ($115) {\n        $120 = 0;\n       } else {\n        __THREW__ = 0;\n        $116 = (invoke_ii(29,($104|0))|0);\n        $117 = __THREW__; __THREW__ = 0;\n        $118 = $117&1;\n        if ($118) {\n         label = 7;\n         break;\n        } else {\n         $120 = $116;\n        }\n       }\n       $119 = (($120) + ($114)|0);\n       $121 = $119;\n       $122 = (($120) + ($104)|0);\n       $123 = $122;\n       $124 = (0 - ($114))|0;\n       $125 = (($119) + ($124)|0);\n       $126 = $125;\n       _memcpy(($125|0),($111|0),($114|0))|0;\n       HEAP32[$101>>2] = $126;\n       HEAP32[$112>>2] = $121;\n       HEAP32[$106>>2] = $123;\n       $127 = ($108|0)==(0);\n       if ($127) {\n        $131 = $103;$133 = $105;\n       } else {\n        __ZdlPv($111);\n        $$pre55 = HEAP32[$92>>2]|0;\n        $$pre56 = HEAP32[$this>>2]|0;\n        $131 = $$pre55;$133 = $$pre56;\n       }\n      } else {\n       $131 = $103;$133 = $105;\n      }\n      $128 = HEAP32[$0>>2]|0;\n      $129 = (($128) + (($row$034*12)|0)|0);\n      $130 = (($131) + 1)|0;\n      $132 = (($130) - ($133))|0;\n      $134 = ($132|0)>(0);\n      L36: do {\n       if ($134) {\n        $135 = (((($128) + (($row$034*12)|0)|0)) + 4|0);\n        $136 = (((($128) + (($row$034*12)|0)|0)) + 8|0);\n        if ($94) {\n         $col$030$us = 0;\n        } else {\n         $col$030 = 0;\n         while(1) {\n          $206 = HEAP32[$135>>2]|0;\n          $207 = HEAP32[$136>>2]|0;\n          $208 = ($206|0)==($207|0);\n          if ($208) {\n           $211 = $206;\n           $212 = HEAP32[$129>>2]|0;\n           $213 = (($211) - ($212))|0;\n           $214 = (($213) + 1)|0;\n           $215 = ($214|0)<(0);\n           if ($215) {\n            __THREW__ = 0;\n            invoke_vi(46,($129|0));\n            $216 = __THREW__; __THREW__ = 0;\n            $217 = $216&1;\n            if ($217) {\n             label = 6;\n             break L27;\n            }\n            $$pre$i$i = HEAP32[$129>>2]|0;\n            $$pre$i = HEAP32[$136>>2]|0;\n            $$in$i$i = $$pre$i$i;$220 = $$pre$i;\n           } else {\n            $$in$i$i = $212;$220 = $211;\n           }\n           $218 = $$in$i$i;\n           $219 = (($220) - ($$in$i$i))|0;\n           $221 = ($219>>>0)<(1073741823);\n           if ($221) {\n            $224 = $219 << 1;\n            $225 = ($224>>>0)<($214>>>0);\n            $226 = $225 ? $214 : $224;\n            $227 = HEAP32[$135>>2]|0;\n            $228 = (($227) - ($$in$i$i))|0;\n            $229 = ($226|0)==(0);\n            if ($229) {\n             $$0$i2$i$i = 0;$234 = 0;$235 = $228;$241 = $227;\n            } else {\n             $$0$i1$i$i = $226;$256 = $227;$257 = $228;\n             label = 65;\n            }\n           } else {\n            $222 = HEAP32[$135>>2]|0;\n            $223 = (($222) - ($$in$i$i))|0;\n            $$0$i1$i$i = 2147483647;$256 = $222;$257 = $223;\n            label = 65;\n           }\n           if ((label|0) == 65) {\n            label = 0;\n            __THREW__ = 0;\n            $230 = (invoke_ii(29,($$0$i1$i$i|0))|0);\n            $231 = __THREW__; __THREW__ = 0;\n            $232 = $231&1;\n            if ($232) {\n             label = 6;\n             break L27;\n            } else {\n             $$0$i2$i$i = $$0$i1$i$i;$234 = $230;$235 = $257;$241 = $256;\n            }\n           }\n           $233 = (($234) + ($235)|0);\n           $236 = (($234) + ($$0$i2$i$i)|0);\n           $237 = $236;\n           HEAP8[$233>>0] = 0;\n           $238 = ((($233)) + 1|0);\n           $239 = $238;\n           $240 = (($241) - ($$in$i$i))|0;\n           $242 = (0 - ($240))|0;\n           $243 = (($233) + ($242)|0);\n           $244 = $243;\n           _memcpy(($243|0),($218|0),($240|0))|0;\n           HEAP32[$129>>2] = $244;\n           HEAP32[$135>>2] = $239;\n           HEAP32[$136>>2] = $237;\n           $245 = ($$in$i$i|0)==(0);\n           if (!($245)) {\n            __ZdlPv($218);\n           }\n          } else {\n           HEAP8[$206>>0] = 0;\n           $209 = HEAP32[$135>>2]|0;\n           $210 = ((($209)) + 1|0);\n           HEAP32[$135>>2] = $210;\n          }\n          $246 = (($col$030) + 1)|0;\n          $247 = HEAP32[$92>>2]|0;\n          $248 = HEAP32[$this>>2]|0;\n          $249 = (($247) + 1)|0;\n          $250 = (($249) - ($248))|0;\n          $251 = ($246|0)<($250|0);\n          if ($251) {\n           $col$030 = $246;\n          } else {\n           $252 = $248;$253 = $247;\n           break L36;\n          }\n         }\n        }\n        while(1) {\n         $137 = Math_imul($col$030$us, $scale)|0;\n         $138 = (($137) + ($scale))|0;\n         $139 = HEAP32[$93>>2]|0;\n         $i$023$us$us = $98;$sum$022$us$us = 0;\n         while(1) {\n          $188 = (($139) + (($i$023$us$us*12)|0)|0);\n          $189 = HEAP32[$188>>2]|0;\n          $j$021$us$us = $137;$sum$120$us$us = $sum$022$us$us;\n          while(1) {\n           $192 = (($189) + ($j$021$us$us)|0);\n           $193 = HEAP8[$192>>0]|0;\n           $194 = $193&255;\n           $195 = (($194) + ($sum$120$us$us))|0;\n           $196 = (($j$021$us$us) + 1)|0;\n           $197 = ($196|0)<($138|0);\n           if ($197) {\n            $j$021$us$us = $196;$sum$120$us$us = $195;\n           } else {\n            $$lcssa74 = $195;\n            break;\n           }\n          }\n          $190 = (($i$023$us$us) + 1)|0;\n          $191 = ($190|0)<($99|0);\n          if ($191) {\n           $i$023$us$us = $190;$sum$022$us$us = $$lcssa74;\n          } else {\n           $$lcssa74$lcssa = $$lcssa74;\n           break;\n          }\n         }\n         $185 = (($$lcssa74$lcssa|0) / ($46|0))&-1;\n         $140 = $185&255;\n         $141 = HEAP32[$135>>2]|0;\n         $186 = HEAP32[$136>>2]|0;\n         $187 = ($141|0)==($186|0);\n         if ($187) {\n          $144 = $141;\n          $145 = HEAP32[$129>>2]|0;\n          $146 = (($144) - ($145))|0;\n          $147 = (($146) + 1)|0;\n          $148 = ($147|0)<(0);\n          if ($148) {\n           __THREW__ = 0;\n           invoke_vi(46,($129|0));\n           $149 = __THREW__; __THREW__ = 0;\n           $150 = $149&1;\n           if ($150) {\n            label = 55;\n            break L27;\n           }\n           $$pre$i$i$us = HEAP32[$129>>2]|0;\n           $$pre$i$us = HEAP32[$136>>2]|0;\n           $$in$i$i$us = $$pre$i$i$us;$153 = $$pre$i$us;\n          } else {\n           $$in$i$i$us = $145;$153 = $144;\n          }\n          $151 = $$in$i$i$us;\n          $152 = (($153) - ($$in$i$i$us))|0;\n          $154 = ($152>>>0)<(1073741823);\n          if ($154) {\n           $157 = $152 << 1;\n           $158 = ($157>>>0)<($147>>>0);\n           $159 = $158 ? $147 : $157;\n           $160 = HEAP32[$135>>2]|0;\n           $161 = (($160) - ($$in$i$i$us))|0;\n           $162 = ($159|0)==(0);\n           if ($162) {\n            $$0$i2$i$i$us = 0;$167 = 0;$168 = $161;$174 = $160;\n           } else {\n            $$0$i1$i$i$us = $159;$254 = $160;$255 = $161;\n            label = 47;\n           }\n          } else {\n           $155 = HEAP32[$135>>2]|0;\n           $156 = (($155) - ($$in$i$i$us))|0;\n           $$0$i1$i$i$us = 2147483647;$254 = $155;$255 = $156;\n           label = 47;\n          }\n          if ((label|0) == 47) {\n           label = 0;\n           __THREW__ = 0;\n           $163 = (invoke_ii(29,($$0$i1$i$i$us|0))|0);\n           $164 = __THREW__; __THREW__ = 0;\n           $165 = $164&1;\n           if ($165) {\n            label = 55;\n            break L27;\n           } else {\n            $$0$i2$i$i$us = $$0$i1$i$i$us;$167 = $163;$168 = $255;$174 = $254;\n           }\n          }\n          $166 = (($167) + ($168)|0);\n          $169 = (($167) + ($$0$i2$i$i$us)|0);\n          $170 = $169;\n          HEAP8[$166>>0] = $140;\n          $171 = ((($166)) + 1|0);\n          $172 = $171;\n          $173 = (($174) - ($$in$i$i$us))|0;\n          $175 = (0 - ($173))|0;\n          $176 = (($166) + ($175)|0);\n          $177 = $176;\n          _memcpy(($176|0),($151|0),($173|0))|0;\n          HEAP32[$129>>2] = $177;\n          HEAP32[$135>>2] = $172;\n          HEAP32[$136>>2] = $170;\n          $178 = ($$in$i$i$us|0)==(0);\n          if (!($178)) {\n           __ZdlPv($151);\n          }\n         } else {\n          HEAP8[$141>>0] = $140;\n          $142 = HEAP32[$135>>2]|0;\n          $143 = ((($142)) + 1|0);\n          HEAP32[$135>>2] = $143;\n         }\n         $179 = (($col$030$us) + 1)|0;\n         $180 = HEAP32[$92>>2]|0;\n         $181 = HEAP32[$this>>2]|0;\n         $182 = (($180) + 1)|0;\n         $183 = (($182) - ($181))|0;\n         $184 = ($179|0)<($183|0);\n         if ($184) {\n          $col$030$us = $179;\n         } else {\n          $252 = $181;$253 = $180;\n          break;\n         }\n        }\n       } else {\n        $252 = $133;$253 = $131;\n       }\n      } while(0);\n      $200 = (($row$034) + 1)|0;\n      $201 = HEAP32[$62>>2]|0;\n      $202 = HEAP32[$64>>2]|0;\n      $203 = (($201) + 1)|0;\n      $204 = (($203) - ($202))|0;\n      $205 = ($200|0)<($204|0);\n      if ($205) {\n       $103 = $253;$105 = $252;$row$034 = $200;\n      } else {\n       label = 31;\n       break;\n      }\n     }\n     if ((label|0) == 6) {\n      $26 = ___cxa_find_matching_catch_2()|0;\n      $27 = tempRet0;\n      $lpad$phi$index = $26;$lpad$phi$index4 = $27;\n      break;\n     }\n     else if ((label|0) == 7) {\n      $28 = ___cxa_find_matching_catch_2()|0;\n      $29 = tempRet0;\n      $lpad$phi$index = $28;$lpad$phi$index4 = $29;\n      break;\n     }\n     else if ((label|0) == 31) {\n      return;\n     }\n     else if ((label|0) == 55) {\n      $198 = ___cxa_find_matching_catch_2()|0;\n      $199 = tempRet0;\n      $lpad$phi$index = $198;$lpad$phi$index4 = $199;\n      break;\n     }\n    }\n   }\n  }\n } while(0);\n if ((label|0) == 8) {\n  $30 = ___cxa_find_matching_catch_2()|0;\n  $31 = tempRet0;\n  $lpad$phi$index = $30;$lpad$phi$index4 = $31;\n }\n $32 = HEAP32[$0>>2]|0;\n $33 = ($32|0)==(0|0);\n if ($33) {\n  ___resumeException($lpad$phi$index|0);\n  // unreachable;\n }\n $34 = HEAP32[$1>>2]|0;\n $35 = ($34|0)==($32|0);\n if ($35) {\n  $45 = $32;\n } else {\n  $37 = $34;\n  while(1) {\n   $36 = ((($37)) + -12|0);\n   HEAP32[$1>>2] = $36;\n   $38 = HEAP32[$36>>2]|0;\n   $39 = ($38|0)==(0|0);\n   if ($39) {\n    $40 = $36;\n   } else {\n    $42 = ((($37)) + -8|0);\n    $43 = HEAP32[$42>>2]|0;\n    $44 = ($43|0)==($38|0);\n    if (!($44)) {\n     HEAP32[$42>>2] = $38;\n    }\n    __ZdlPv($38);\n    $$pre$i$i$i = HEAP32[$1>>2]|0;\n    $40 = $$pre$i$i$i;\n   }\n   $41 = ($40|0)==($32|0);\n   if ($41) {\n    break;\n   } else {\n    $37 = $40;\n   }\n  }\n  $$pre$i3 = HEAP32[$0>>2]|0;\n  $45 = $$pre$i3;\n }\n __ZdlPv($45);\n ___resumeException($lpad$phi$index|0);\n // unreachable;\n}\nfunction __ZN12_GLOBAL__N_17otsu_thERKNSt3__16vectorINS1_IhNS0_9allocatorIhEEEENS2_IS4_EEEERK9Rectanglei($data,$re,$maxval) {\n $data = $data|0;\n $re = $re|0;\n $maxval = $maxval|0;\n var $$0 = 0, $$01 = 0, $$02 = 0, $$lcssa = 0, $$pre = 0, $$pre49 = 0, $$pre50 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0.0, $108 = 0, $109 = 0;\n var $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0;\n var $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0;\n var $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0;\n var $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0;\n var $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0;\n var $20 = 0, $200 = 0, $201 = 0.0, $202 = 0.0, $203 = 0.0, $204 = 0.0, $205 = 0, $206 = 0.0, $207 = 0.0, $208 = 0.0, $209 = 0.0, $21 = 0, $210 = 0.0, $211 = 0.0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0;\n var $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0;\n var $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $26 = 0, $27 = 0;\n var $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0;\n var $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0;\n var $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0;\n var $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $bvar_max$035 = 0.0;\n var $bvar_max$1 = 0.0, $bvar_max$2 = 0.0, $chist = 0, $cmom = 0, $col$040 = 0, $exitcond = 0, $hist = 0, $i$038 = 0, $i1$037 = 0, $lpad$phi$index = 0, $lpad$phi$index2 = 0, $or$cond = 0, $row$044 = 0, $scevgep$i$i$i = 0, $scevgep$i$i$i$i = 0, $scevgep$i$i$i14 = 0, $scevgep$i$i$i19 = 0, $scevgep$i$i$i29 = 0, $scevgep$i$i$i4 = 0, $scevgep$i$i$i9 = 0;\n var $scevgep4$i$i$i = 0, $scevgep4$i$i$i$i = 0, $scevgep4$i$i$i10 = 0, $scevgep4$i$i$i15 = 0, $scevgep4$i$i$i20 = 0, $scevgep4$i$i$i30 = 0, $scevgep4$i$i$i5 = 0, $threshold$0$lcssa = 0, $threshold$036 = 0, $threshold$1 = 0, $threshold$2 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 64|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();\n $hist = sp + 44|0;\n $chist = sp + 32|0;\n $cmom = sp + 20|0;\n $0 = sp + 8|0;\n $1 = sp + 16|0;\n $2 = sp;\n $3 = ($maxval|0)==(1);\n if ($3) {\n  $$0 = 0;\n  STACKTOP = sp;return ($$0|0);\n }\n $4 = (($maxval) + 1)|0;\n HEAP32[$hist>>2] = 0;\n $5 = ((($hist)) + 4|0);\n HEAP32[$5>>2] = 0;\n $6 = ((($hist)) + 8|0);\n HEAP32[$6>>2] = 0;\n $7 = ($4|0)==(0);\n do {\n  if ($7) {\n   $49 = 0;\n  } else {\n   $8 = ($4>>>0)>(1073741823);\n   if ($8) {\n    __THREW__ = 0;\n    invoke_vi(46,($hist|0));\n    $9 = __THREW__; __THREW__ = 0;\n    $10 = $9&1;\n    if (!($10)) {\n     label = 5;\n    }\n   } else {\n    label = 5;\n   }\n   if ((label|0) == 5) {\n    $11 = $4 << 2;\n    __THREW__ = 0;\n    $12 = (invoke_ii(29,($11|0))|0);\n    $13 = __THREW__; __THREW__ = 0;\n    $14 = $13&1;\n    if (!($14)) {\n     HEAP32[$hist>>2] = $12;\n     $15 = (($12) + ($4<<2)|0);\n     $16 = ((($hist)) + 8|0);\n     HEAP32[$16>>2] = $15;\n     $17 = $maxval << 2;\n     $18 = (($17) + 4)|0;\n     _memset(($12|0),0,($18|0))|0;\n     HEAP32[$5>>2] = $15;\n     $49 = $12;\n     break;\n    }\n   }\n   $19 = ___cxa_find_matching_catch_2()|0;\n   $20 = tempRet0;\n   $21 = HEAP32[$hist>>2]|0;\n   $22 = ($21|0)==(0|0);\n   $23 = $21;\n   if ($22) {\n    ___resumeException($19|0);\n    // unreachable;\n   }\n   $24 = HEAP32[$5>>2]|0;\n   $25 = ($24|0)==($21|0);\n   if (!($25)) {\n    $scevgep$i$i$i$i = ((($24)) + -4|0);\n    $26 = $scevgep$i$i$i$i;\n    $27 = (($26) - ($23))|0;\n    $28 = $27 >>> 2;\n    $29 = $28 ^ -1;\n    $scevgep4$i$i$i$i = (($24) + ($29<<2)|0);\n    HEAP32[$5>>2] = $scevgep4$i$i$i$i;\n   }\n   __ZdlPv($21);\n   ___resumeException($19|0);\n   // unreachable;\n  }\n } while(0);\n $30 = ((($re)) + 4|0);\n $31 = HEAP32[$30>>2]|0;\n $32 = ((($re)) + 12|0);\n $33 = HEAP32[$32>>2]|0;\n $34 = ($31|0)>($33|0);\n if (!($34)) {\n  $35 = ((($re)) + 8|0);\n  $$pre = HEAP32[$35>>2]|0;\n  $250 = $33;$38 = $$pre;$row$044 = $31;\n  while(1) {\n   $36 = HEAP32[$re>>2]|0;\n   $37 = ($36|0)>($38|0);\n   if ($37) {\n    $251 = $38;$41 = $250;\n   } else {\n    $col$040 = $36;\n    while(1) {\n     $42 = HEAP32[$data>>2]|0;\n     $43 = (($42) + (($row$044*12)|0)|0);\n     $44 = HEAP32[$43>>2]|0;\n     $45 = (($44) + ($col$040)|0);\n     $46 = HEAP8[$45>>0]|0;\n     $47 = $46&255;\n     $48 = (($49) + ($47<<2)|0);\n     $50 = HEAP32[$48>>2]|0;\n     $51 = (($50) + 1)|0;\n     HEAP32[$48>>2] = $51;\n     $52 = (($col$040) + 1)|0;\n     $53 = HEAP32[$35>>2]|0;\n     $54 = ($col$040|0)<($53|0);\n     if ($54) {\n      $col$040 = $52;\n     } else {\n      $$lcssa = $53;\n      break;\n     }\n    }\n    $$pre49 = HEAP32[$32>>2]|0;\n    $251 = $$lcssa;$41 = $$pre49;\n   }\n   $39 = (($row$044) + 1)|0;\n   $40 = ($row$044|0)<($41|0);\n   if ($40) {\n    $250 = $41;$38 = $251;$row$044 = $39;\n   } else {\n    break;\n   }\n  }\n }\n HEAP32[$chist>>2] = 0;\n $55 = ((($chist)) + 4|0);\n HEAP32[$55>>2] = 0;\n $56 = ((($chist)) + 8|0);\n HEAP32[$56>>2] = 0;\n $57 = ((($chist)) + 8|0);\n $58 = ($4|0)!=(0);\n if ($58) {\n  $59 = $4 << 2;\n  __THREW__ = 0;\n  $60 = (invoke_ii(29,($59|0))|0);\n  $61 = __THREW__; __THREW__ = 0;\n  $62 = $61&1;\n  if ($62) {\n   label = 33;\n  } else {\n   $63 = $60;\n   $64 = (($60) + ($4<<2)|0);\n   $65 = $64;\n   HEAP32[$chist>>2] = $63;\n   HEAP32[$55>>2] = $63;\n   HEAP32[$57>>2] = $65;\n   $66 = ($60|0)==($64|0);\n   if ($66) {\n    label = 22;\n   } else {\n    $67 = HEAP32[$49>>2]|0;\n    HEAP32[$60>>2] = $67;\n    $68 = ((($60)) + 4|0);\n    HEAP32[$55>>2] = $68;\n    label = 23;\n   }\n  }\n } else {\n  label = 22;\n }\n if ((label|0) == 22) {\n  __THREW__ = 0;\n  invoke_vii(48,($chist|0),($49|0));\n  $69 = __THREW__; __THREW__ = 0;\n  $70 = $69&1;\n  if ($70) {\n   label = 33;\n  } else {\n   label = 23;\n  }\n }\n if ((label|0) == 23) {\n  HEAP32[$cmom>>2] = 0;\n  $71 = ((($cmom)) + 4|0);\n  HEAP32[$71>>2] = 0;\n  $72 = ((($cmom)) + 8|0);\n  HEAP32[$72>>2] = 0;\n  $73 = ((($cmom)) + 8|0);\n  if ($58) {\n   $78 = $4 << 3;\n   __THREW__ = 0;\n   $79 = (invoke_ii(29,($78|0))|0);\n   $80 = __THREW__; __THREW__ = 0;\n   $81 = $80&1;\n   if ($81) {\n    label = 35;\n   } else {\n    $82 = $79;\n    $83 = (($79) + ($4<<3)|0);\n    $84 = $83;\n    HEAP32[$cmom>>2] = $82;\n    HEAP32[$71>>2] = $82;\n    HEAP32[$73>>2] = $84;\n    $85 = $0;\n    $86 = $85;\n    HEAP32[$86>>2] = 0;\n    $87 = (($85) + 4)|0;\n    $88 = $87;\n    HEAP32[$88>>2] = 0;\n    $89 = ($79|0)==($83|0);\n    if ($89) {\n     label = 28;\n    } else {\n     $90 = $79;\n     $91 = $90;\n     HEAP32[$91>>2] = 0;\n     $92 = (($90) + 4)|0;\n     $93 = $92;\n     HEAP32[$93>>2] = 0;\n     $94 = ((($79)) + 8|0);\n     HEAP32[$71>>2] = $94;\n     label = 29;\n    }\n   }\n  } else {\n   $74 = $0;\n   $75 = $74;\n   HEAP32[$75>>2] = 0;\n   $76 = (($74) + 4)|0;\n   $77 = $76;\n   HEAP32[$77>>2] = 0;\n   label = 28;\n  }\n  if ((label|0) == 28) {\n   __THREW__ = 0;\n   invoke_vii(49,($cmom|0),($0|0));\n   $95 = __THREW__; __THREW__ = 0;\n   $96 = $95&1;\n   if ($96) {\n    label = 35;\n   } else {\n    label = 29;\n   }\n  }\n  do {\n   if ((label|0) == 29) {\n    $97 = ($maxval|0)<(1);\n    if ($97) {\n     $98 = HEAP32[$cmom>>2]|0;\n     $181 = $98;$threshold$0$lcssa = 0;\n    } else {\n     $i$038 = 1;\n     while(1) {\n      $135 = (($i$038) + -1)|0;\n      $136 = HEAP32[$chist>>2]|0;\n      $137 = (($136) + ($135<<2)|0);\n      $138 = HEAP32[$137>>2]|0;\n      $139 = HEAP32[$hist>>2]|0;\n      $140 = (($139) + ($i$038<<2)|0);\n      $141 = HEAP32[$140>>2]|0;\n      $142 = (($141) + ($138))|0;\n      HEAP32[$1>>2] = $142;\n      $143 = HEAP32[$55>>2]|0;\n      $144 = HEAP32[$57>>2]|0;\n      $145 = ($143|0)==($144|0);\n      if ($145) {\n       __THREW__ = 0;\n       invoke_vii(48,($chist|0),($1|0));\n       $147 = __THREW__; __THREW__ = 0;\n       $148 = $147&1;\n       if ($148) {\n        label = 34;\n        break;\n       }\n       $$pre50 = HEAP32[$hist>>2]|0;\n       $158 = $$pre50;\n      } else {\n       HEAP32[$143>>2] = $142;\n       $146 = ((($143)) + 4|0);\n       HEAP32[$55>>2] = $146;\n       $158 = $139;\n      }\n      $149 = HEAP32[$cmom>>2]|0;\n      $150 = (($149) + ($135<<3)|0);\n      $151 = $150;\n      $152 = $151;\n      $153 = HEAP32[$152>>2]|0;\n      $154 = (($151) + 4)|0;\n      $155 = $154;\n      $156 = HEAP32[$155>>2]|0;\n      $157 = (($158) + ($i$038<<2)|0);\n      $159 = HEAP32[$157>>2]|0;\n      $160 = Math_imul($159, $i$038)|0;\n      $161 = ($160|0)<(0);\n      $162 = $161 << 31 >> 31;\n      $163 = (_i64Add(($160|0),($162|0),($153|0),($156|0))|0);\n      $164 = tempRet0;\n      $165 = $2;\n      $166 = $165;\n      HEAP32[$166>>2] = $163;\n      $167 = (($165) + 4)|0;\n      $168 = $167;\n      HEAP32[$168>>2] = $164;\n      $169 = HEAP32[$71>>2]|0;\n      $170 = HEAP32[$73>>2]|0;\n      $171 = ($169|0)==($170|0);\n      if ($171) {\n       __THREW__ = 0;\n       invoke_vii(49,($cmom|0),($2|0));\n       $177 = __THREW__; __THREW__ = 0;\n       $178 = $177&1;\n       if ($178) {\n        label = 34;\n        break;\n       }\n      } else {\n       $172 = $169;\n       $173 = $172;\n       HEAP32[$173>>2] = $163;\n       $174 = (($172) + 4)|0;\n       $175 = $174;\n       HEAP32[$175>>2] = $164;\n       $176 = ((($169)) + 8|0);\n       HEAP32[$71>>2] = $176;\n      }\n      $179 = (($i$038) + 1)|0;\n      $180 = ($i$038|0)<($maxval|0);\n      if ($180) {\n       $i$038 = $179;\n      } else {\n       break;\n      }\n     }\n     if ((label|0) == 34) {\n      $122 = ___cxa_find_matching_catch_2()|0;\n      $123 = tempRet0;\n      $lpad$phi$index = $122;$lpad$phi$index2 = $123;\n      break;\n     }\n     $99 = HEAP32[$cmom>>2]|0;\n     $100 = (($99) + ($maxval<<3)|0);\n     $101 = $100;\n     $102 = $101;\n     $103 = HEAP32[$102>>2]|0;\n     $104 = (($101) + 4)|0;\n     $105 = $104;\n     $106 = HEAP32[$105>>2]|0;\n     $107 = (+($103>>>0)) + (4294967296.0*(+($106|0)));\n     $108 = ($maxval|0)>(0);\n     if ($108) {\n      $109 = HEAP32[$chist>>2]|0;\n      $110 = HEAP32[$30>>2]|0;\n      $111 = ((($re)) + 8|0);\n      $112 = HEAP32[$111>>2]|0;\n      $113 = HEAP32[$re>>2]|0;\n      $114 = (($112) + 1)|0;\n      $115 = (($114) - ($113))|0;\n      $116 = HEAP32[$32>>2]|0;\n      $117 = (($116) + 1)|0;\n      $118 = (($117) - ($110))|0;\n      $119 = Math_imul($115, $118)|0;\n      $bvar_max$035 = 0.0;$i1$037 = 0;$threshold$036 = 0;\n      while(1) {\n       $190 = (($109) + ($i1$037<<2)|0);\n       $191 = HEAP32[$190>>2]|0;\n       $192 = ($191|0)>(0);\n       $193 = ($119|0)>($191|0);\n       $or$cond = $192 & $193;\n       if ($or$cond) {\n        $194 = (($99) + ($i1$037<<3)|0);\n        $195 = $194;\n        $196 = $195;\n        $197 = HEAP32[$196>>2]|0;\n        $198 = (($195) + 4)|0;\n        $199 = $198;\n        $200 = HEAP32[$199>>2]|0;\n        $201 = (+($197>>>0)) + (4294967296.0*(+($200|0)));\n        $202 = (+($191|0));\n        $203 = $201 / $202;\n        $204 = $107 - $201;\n        $205 = (($119) - ($191))|0;\n        $206 = (+($205|0));\n        $207 = $204 / $206;\n        $208 = $203 - $207;\n        $209 = $208 * $208;\n        $210 = $202 * $209;\n        $211 = $206 * $210;\n        $212 = $211 > $bvar_max$035;\n        $bvar_max$1 = $212 ? $211 : $bvar_max$035;\n        $threshold$1 = $212 ? $i1$037 : $threshold$036;\n        $bvar_max$2 = $bvar_max$1;$threshold$2 = $threshold$1;\n       } else {\n        $bvar_max$2 = $bvar_max$035;$threshold$2 = $threshold$036;\n       }\n       $213 = (($i1$037) + 1)|0;\n       $exitcond = ($213|0)==($maxval|0);\n       if ($exitcond) {\n        $181 = $99;$threshold$0$lcssa = $threshold$2;\n        break;\n       } else {\n        $bvar_max$035 = $bvar_max$2;$i1$037 = $213;$threshold$036 = $threshold$2;\n       }\n      }\n     } else {\n      $181 = $99;$threshold$0$lcssa = 0;\n     }\n    }\n    $182 = ($181|0)==(0|0);\n    $183 = $181;\n    if (!($182)) {\n     $184 = HEAP32[$71>>2]|0;\n     $185 = ($184|0)==($181|0);\n     if (!($185)) {\n      $scevgep$i$i$i19 = ((($184)) + -8|0);\n      $186 = $scevgep$i$i$i19;\n      $187 = (($186) - ($183))|0;\n      $188 = $187 >>> 3;\n      $189 = $188 ^ -1;\n      $scevgep4$i$i$i20 = (($184) + ($189<<3)|0);\n      HEAP32[$71>>2] = $scevgep4$i$i$i20;\n     }\n     __ZdlPv($181);\n    }\n    $214 = HEAP32[$chist>>2]|0;\n    $215 = ($214|0)==(0|0);\n    $216 = $214;\n    if (!($215)) {\n     $217 = HEAP32[$55>>2]|0;\n     $218 = ($217|0)==($214|0);\n     if (!($218)) {\n      $scevgep$i$i$i14 = ((($217)) + -4|0);\n      $219 = $scevgep$i$i$i14;\n      $220 = (($219) - ($216))|0;\n      $221 = $220 >>> 2;\n      $222 = $221 ^ -1;\n      $scevgep4$i$i$i15 = (($217) + ($222<<2)|0);\n      HEAP32[$55>>2] = $scevgep4$i$i$i15;\n     }\n     __ZdlPv($214);\n    }\n    $223 = HEAP32[$hist>>2]|0;\n    $224 = ($223|0)==(0|0);\n    $225 = $223;\n    if (!($224)) {\n     $226 = HEAP32[$5>>2]|0;\n     $227 = ($226|0)==($223|0);\n     if (!($227)) {\n      $scevgep$i$i$i9 = ((($226)) + -4|0);\n      $228 = $scevgep$i$i$i9;\n      $229 = (($228) - ($225))|0;\n      $230 = $229 >>> 2;\n      $231 = $230 ^ -1;\n      $scevgep4$i$i$i10 = (($226) + ($231<<2)|0);\n      HEAP32[$5>>2] = $scevgep4$i$i$i10;\n     }\n     __ZdlPv($223);\n    }\n    $$0 = $threshold$0$lcssa;\n    STACKTOP = sp;return ($$0|0);\n   }\n   else if ((label|0) == 35) {\n    $124 = ___cxa_find_matching_catch_2()|0;\n    $125 = tempRet0;\n    $lpad$phi$index = $124;$lpad$phi$index2 = $125;\n   }\n  } while(0);\n  $126 = HEAP32[$cmom>>2]|0;\n  $127 = ($126|0)==(0|0);\n  $128 = $126;\n  if ($127) {\n   $$01 = $lpad$phi$index2;$$02 = $lpad$phi$index;\n  } else {\n   $129 = HEAP32[$71>>2]|0;\n   $130 = ($129|0)==($126|0);\n   if (!($130)) {\n    $scevgep$i$i$i29 = ((($129)) + -8|0);\n    $131 = $scevgep$i$i$i29;\n    $132 = (($131) - ($128))|0;\n    $133 = $132 >>> 3;\n    $134 = $133 ^ -1;\n    $scevgep4$i$i$i30 = (($129) + ($134<<3)|0);\n    HEAP32[$71>>2] = $scevgep4$i$i$i30;\n   }\n   __ZdlPv($126);\n   $$01 = $lpad$phi$index2;$$02 = $lpad$phi$index;\n  }\n }\n else if ((label|0) == 33) {\n  $120 = ___cxa_find_matching_catch_2()|0;\n  $121 = tempRet0;\n  $$01 = $121;$$02 = $120;\n }\n $232 = HEAP32[$chist>>2]|0;\n $233 = ($232|0)==(0|0);\n $234 = $232;\n if (!($233)) {\n  $235 = HEAP32[$55>>2]|0;\n  $236 = ($235|0)==($232|0);\n  if (!($236)) {\n   $scevgep$i$i$i4 = ((($235)) + -4|0);\n   $237 = $scevgep$i$i$i4;\n   $238 = (($237) - ($234))|0;\n   $239 = $238 >>> 2;\n   $240 = $239 ^ -1;\n   $scevgep4$i$i$i5 = (($235) + ($240<<2)|0);\n   HEAP32[$55>>2] = $scevgep4$i$i$i5;\n  }\n  __ZdlPv($232);\n }\n $241 = HEAP32[$hist>>2]|0;\n $242 = ($241|0)==(0|0);\n $243 = $241;\n if ($242) {\n  ___resumeException($$02|0);\n  // unreachable;\n }\n $244 = HEAP32[$5>>2]|0;\n $245 = ($244|0)==($241|0);\n if (!($245)) {\n  $scevgep$i$i$i = ((($244)) + -4|0);\n  $246 = $scevgep$i$i$i;\n  $247 = (($246) - ($243))|0;\n  $248 = $247 >>> 2;\n  $249 = $248 ^ -1;\n  $scevgep4$i$i$i = (($244) + ($249<<2)|0);\n  HEAP32[$5>>2] = $scevgep4$i$i$i;\n }\n __ZdlPv($241);\n ___resumeException($$02|0);\n // unreachable;\n return (0)|0;\n}\nfunction __ZNSt3__16vectorIiNS_9allocatorIiEEE21__push_back_slow_pathIKiEEvRT_($this,$__x) {\n $this = $this|0;\n $__x = $__x|0;\n var $$0$i1 = 0, $$0$i2 = 0, $$in = 0, $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0;\n var $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0;\n var $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ((($this)) + 4|0);\n $1 = HEAP32[$0>>2]|0;\n $2 = HEAP32[$this>>2]|0;\n $3 = (($1) - ($2))|0;\n $4 = $3 >> 2;\n $5 = (($4) + 1)|0;\n $6 = ($5>>>0)>(1073741823);\n if ($6) {\n  __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($this);\n  $$pre = HEAP32[$this>>2]|0;\n  $$in = $$pre;\n } else {\n  $$in = $2;\n }\n $7 = ((($this)) + 8|0);\n $8 = HEAP32[$7>>2]|0;\n $9 = (($8) - ($$in))|0;\n $10 = $9 >> 2;\n $11 = ($10>>>0)<(536870911);\n if ($11) {\n  $15 = $9 >> 1;\n  $16 = ($15>>>0)<($5>>>0);\n  $17 = $16 ? $5 : $15;\n  $18 = HEAP32[$0>>2]|0;\n  $19 = (($18) - ($$in))|0;\n  $20 = $19 >> 2;\n  $21 = ($17|0)==(0);\n  if ($21) {\n   $$0$i2 = 0;$25 = 0;$26 = $20;$33 = $18;\n  } else {\n   $$0$i1 = $17;$41 = $18;$42 = $20;\n   label = 6;\n  }\n } else {\n  $12 = HEAP32[$0>>2]|0;\n  $13 = (($12) - ($$in))|0;\n  $14 = $13 >> 2;\n  $$0$i1 = 1073741823;$41 = $12;$42 = $14;\n  label = 6;\n }\n if ((label|0) == 6) {\n  $22 = $$0$i1 << 2;\n  $23 = (__Znwj($22)|0);\n  $$0$i2 = $$0$i1;$25 = $23;$26 = $42;$33 = $41;\n }\n $24 = (($25) + ($26<<2)|0);\n $27 = (($25) + ($$0$i2<<2)|0);\n $28 = $27;\n $29 = HEAP32[$__x>>2]|0;\n HEAP32[$24>>2] = $29;\n $30 = ((($24)) + 4|0);\n $31 = $30;\n $32 = (($33) - ($$in))|0;\n $34 = $32 >> 2;\n $35 = (0 - ($34))|0;\n $36 = (($24) + ($35<<2)|0);\n $37 = $36;\n $38 = $$in;\n _memcpy(($36|0),($38|0),($32|0))|0;\n HEAP32[$this>>2] = $37;\n HEAP32[$0>>2] = $31;\n HEAP32[$7>>2] = $28;\n $39 = ($$in|0)==(0);\n if ($39) {\n  return;\n }\n $40 = $$in;\n __ZdlPv($40);\n return;\n}\nfunction __ZNSt3__16vectorIxNS_9allocatorIxEEE21__push_back_slow_pathIKxEEvRT_($this,$__x) {\n $this = $this|0;\n $__x = $__x|0;\n var $$0$i1 = 0, $$0$i2 = 0, $$in = 0, $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0;\n var $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0;\n var $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ((($this)) + 4|0);\n $1 = HEAP32[$0>>2]|0;\n $2 = HEAP32[$this>>2]|0;\n $3 = (($1) - ($2))|0;\n $4 = $3 >> 3;\n $5 = (($4) + 1)|0;\n $6 = ($5>>>0)>(536870911);\n if ($6) {\n  __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($this);\n  $$pre = HEAP32[$this>>2]|0;\n  $$in = $$pre;\n } else {\n  $$in = $2;\n }\n $7 = ((($this)) + 8|0);\n $8 = HEAP32[$7>>2]|0;\n $9 = (($8) - ($$in))|0;\n $10 = $9 >> 3;\n $11 = ($10>>>0)<(268435455);\n if ($11) {\n  $15 = $9 >> 2;\n  $16 = ($15>>>0)<($5>>>0);\n  $17 = $16 ? $5 : $15;\n  $18 = HEAP32[$0>>2]|0;\n  $19 = (($18) - ($$in))|0;\n  $20 = $19 >> 3;\n  $21 = ($17|0)==(0);\n  if ($21) {\n   $$0$i2 = 0;$25 = 0;$26 = $20;$42 = $18;\n  } else {\n   $$0$i1 = $17;$50 = $18;$51 = $20;\n   label = 6;\n  }\n } else {\n  $12 = HEAP32[$0>>2]|0;\n  $13 = (($12) - ($$in))|0;\n  $14 = $13 >> 3;\n  $$0$i1 = 536870911;$50 = $12;$51 = $14;\n  label = 6;\n }\n if ((label|0) == 6) {\n  $22 = $$0$i1 << 3;\n  $23 = (__Znwj($22)|0);\n  $$0$i2 = $$0$i1;$25 = $23;$26 = $51;$42 = $50;\n }\n $24 = (($25) + ($26<<3)|0);\n $27 = (($25) + ($$0$i2<<3)|0);\n $28 = $27;\n $29 = $__x;\n $30 = $29;\n $31 = HEAP32[$30>>2]|0;\n $32 = (($29) + 4)|0;\n $33 = $32;\n $34 = HEAP32[$33>>2]|0;\n $35 = $24;\n $36 = $35;\n HEAP32[$36>>2] = $31;\n $37 = (($35) + 4)|0;\n $38 = $37;\n HEAP32[$38>>2] = $34;\n $39 = ((($24)) + 8|0);\n $40 = $39;\n $41 = (($42) - ($$in))|0;\n $43 = $41 >> 3;\n $44 = (0 - ($43))|0;\n $45 = (($24) + ($44<<3)|0);\n $46 = $45;\n $47 = $$in;\n _memcpy(($45|0),($47|0),($41|0))|0;\n HEAP32[$this>>2] = $46;\n HEAP32[$0>>2] = $40;\n HEAP32[$7>>2] = $28;\n $48 = ($$in|0)==(0);\n if ($48) {\n  return;\n }\n $49 = $$in;\n __ZdlPv($49);\n return;\n}\nfunction __ZN10Page_image9thresholdEi($this,$th) {\n $this = $this|0;\n $th = $th|0;\n var $$sink = 0, $$sink$in = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ($th>>>0)<(256);\n $1 = ((($this)) + 28|0);\n $2 = HEAP8[$1>>0]|0;\n if ($0) {\n  $3 = $2&255;\n  $4 = Math_imul($3, $th)|0;\n  $5 = (($4|0) / 255)&-1;\n  $$sink$in = $5;\n } else {\n  $6 = ((($this)) + 16|0);\n  $7 = $2&255;\n  $8 = (__ZN12_GLOBAL__N_17otsu_thERKNSt3__16vectorINS1_IhNS0_9allocatorIhEEEENS2_IS4_EEEERK9Rectanglei($6,$this,$7)|0);\n  $$sink$in = $8;\n }\n $$sink = $$sink$in&255;\n $9 = ((($this)) + 29|0);\n HEAP8[$9>>0] = $$sink;\n return;\n}\nfunction __ZNSt3__16vectorIhNS_9allocatorIhEEE8__appendEj($this,$__n) {\n $this = $this|0;\n $__n = $__n|0;\n var $$0$i = 0, $$0$i2 = 0, $$0$i34 = 0, $$0$i35 = 0, $$lcssa = 0, $$pre = 0, $$pre6 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0;\n var $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0;\n var $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $__v$sroa$12$0 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ((($this)) + 8|0);\n $1 = HEAP32[$0>>2]|0;\n $2 = ((($this)) + 4|0);\n $3 = HEAP32[$2>>2]|0;\n $4 = (($1) - ($3))|0;\n $5 = ($4>>>0)<($__n>>>0);\n if (!($5)) {\n  $6 = $3;\n  $$0$i = $__n;$7 = $6;\n  while(1) {\n   HEAP8[$7>>0] = 0;\n   $8 = HEAP32[$2>>2]|0;\n   $9 = ((($8)) + 1|0);\n   HEAP32[$2>>2] = $9;\n   $10 = (($$0$i) + -1)|0;\n   $11 = ($10|0)==(0);\n   if ($11) {\n    break;\n   } else {\n    $$0$i = $10;$7 = $9;\n   }\n  }\n  return;\n }\n $12 = HEAP32[$this>>2]|0;\n $13 = (($3) - ($12))|0;\n $14 = (($13) + ($__n))|0;\n $15 = ($14|0)<(0);\n if ($15) {\n  __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($this);\n  $$pre = HEAP32[$0>>2]|0;\n  $$pre6 = HEAP32[$this>>2]|0;\n  $17 = $$pre6;$18 = $$pre;\n } else {\n  $17 = $12;$18 = $1;\n }\n $16 = (($18) - ($17))|0;\n $19 = ($16>>>0)<(1073741823);\n if ($19) {\n  $22 = $16 << 1;\n  $23 = ($22>>>0)<($14>>>0);\n  $24 = $23 ? $14 : $22;\n  $25 = HEAP32[$2>>2]|0;\n  $26 = (($25) - ($17))|0;\n  $27 = ($24|0)==(0);\n  if ($27) {\n   $$0$i35 = 0;$30 = 0;$31 = $26;\n  } else {\n   $$0$i34 = $24;$49 = $26;\n   label = 9;\n  }\n } else {\n  $20 = HEAP32[$2>>2]|0;\n  $21 = (($20) - ($17))|0;\n  $$0$i34 = 2147483647;$49 = $21;\n  label = 9;\n }\n if ((label|0) == 9) {\n  $28 = (__Znwj($$0$i34)|0);\n  $$0$i35 = $$0$i34;$30 = $28;$31 = $49;\n }\n $29 = (($30) + ($31)|0);\n $32 = $29;\n $33 = (($30) + ($$0$i35)|0);\n $$0$i2 = $__n;$34 = $29;$__v$sroa$12$0 = $32;\n while(1) {\n  HEAP8[$34>>0] = 0;\n  $35 = $__v$sroa$12$0;\n  $36 = ((($35)) + 1|0);\n  $37 = $36;\n  $38 = (($$0$i2) + -1)|0;\n  $39 = ($38|0)==(0);\n  if ($39) {\n   $$lcssa = $37;\n   break;\n  } else {\n   $$0$i2 = $38;$34 = $36;$__v$sroa$12$0 = $37;\n  }\n }\n $40 = $33;\n $41 = HEAP32[$this>>2]|0;\n $42 = HEAP32[$2>>2]|0;\n $43 = $41;\n $44 = (($42) - ($43))|0;\n $45 = (0 - ($44))|0;\n $46 = (($29) + ($45)|0);\n $47 = $46;\n _memcpy(($46|0),($41|0),($44|0))|0;\n HEAP32[$this>>2] = $47;\n HEAP32[$2>>2] = $$lcssa;\n HEAP32[$0>>2] = $40;\n $48 = ($41|0)==(0|0);\n if ($48) {\n  return;\n }\n __ZdlPv($41);\n return;\n}\nfunction __ZNSt3__16vectorIhNS_9allocatorIhEEE6assignIPhEENS_9enable_ifIXaasr21__is_forward_iteratorIT_EE5valuesr16is_constructibleIhNS_15iterator_traitsIS7_E9referenceEEE5valueEvE4typeES7_S7_($this,$__first,$__last) {\n $this = $this|0;\n $__first = $__first|0;\n $__last = $__last|0;\n var $$0$i5 = 0, $$01$i = 0, $$01$i3 = 0, $$__last = 0, $$mux = 0, $$not = 0, $$not10 = 0, $$pre = 0, $$pre$i1 = 0, $$pre8 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;\n var $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0;\n var $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $brmerge = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = $__last;\n $1 = $__first;\n $2 = (($0) - ($1))|0;\n $3 = ((($this)) + 8|0);\n $4 = HEAP32[$3>>2]|0;\n $5 = HEAP32[$this>>2]|0;\n $6 = (($4) - ($5))|0;\n $7 = ($2>>>0)>($6>>>0);\n $8 = $5;\n if (!($7)) {\n  $9 = ((($this)) + 4|0);\n  $10 = HEAP32[$9>>2]|0;\n  $11 = (($10) - ($5))|0;\n  $12 = ($2>>>0)>($11>>>0);\n  $13 = (($__first) + ($11)|0);\n  $$__last = $12 ? $13 : $__last;\n  $14 = $$__last;\n  $15 = (($14) - ($1))|0;\n  _memmove(($8|0),($__first|0),($15|0))|0;\n  $16 = (($8) + ($15)|0);\n  if (!($12)) {\n   $24 = HEAP32[$9>>2]|0;\n   $25 = ($24|0)==($16|0);\n   if ($25) {\n    return;\n   }\n   HEAP32[$9>>2] = $16;\n   return;\n  }\n  $17 = ($$__last|0)==($__last|0);\n  if ($17) {\n   return;\n  }\n  $$pre$i1 = HEAP32[$9>>2]|0;\n  $$01$i3 = $13;$19 = $$pre$i1;\n  while(1) {\n   $18 = HEAP8[$$01$i3>>0]|0;\n   HEAP8[$19>>0] = $18;\n   $20 = HEAP32[$9>>2]|0;\n   $21 = ((($20)) + 1|0);\n   HEAP32[$9>>2] = $21;\n   $22 = ((($$01$i3)) + 1|0);\n   $23 = ($22|0)==($__last|0);\n   if ($23) {\n    break;\n   } else {\n    $$01$i3 = $22;$19 = $21;\n   }\n  }\n  return;\n }\n $26 = ($5|0)==(0);\n if ($26) {\n  $46 = $4;\n } else {\n  $27 = ((($this)) + 4|0);\n  $28 = HEAP32[$27>>2]|0;\n  $29 = ($28|0)==($8|0);\n  if (!($29)) {\n   HEAP32[$27>>2] = $8;\n  }\n  __ZdlPv($8);\n  HEAP32[$3>>2] = 0;\n  HEAP32[$27>>2] = 0;\n  HEAP32[$this>>2] = 0;\n  $46 = 0;\n }\n $30 = ($2|0)<(0);\n if ($30) {\n  __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($this);\n  $$pre = HEAP32[$3>>2]|0;\n  $$pre8 = HEAP32[$this>>2]|0;\n  $32 = $$pre8;$33 = $$pre;\n } else {\n  $32 = 0;$33 = $46;\n }\n $31 = (($33) - ($32))|0;\n $34 = ($31>>>0)<(1073741823);\n if ($34) {\n  $35 = $31 << 1;\n  $$not = ($35>>>0)>=($2>>>0);\n  $$not10 = $30 ^ 1;\n  $brmerge = $$not | $$not10;\n  $$mux = $$not ? $35 : $2;\n  if ($brmerge) {\n   $$0$i5 = $$mux;\n  } else {\n   __ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv($this);\n   $$0$i5 = $2;\n  }\n } else {\n  $$0$i5 = 2147483647;\n }\n $36 = (__Znwj($$0$i5)|0);\n $37 = ((($this)) + 4|0);\n HEAP32[$37>>2] = $36;\n HEAP32[$this>>2] = $36;\n $38 = (($36) + ($$0$i5)|0);\n HEAP32[$3>>2] = $38;\n $39 = ($__first|0)==($__last|0);\n if ($39) {\n  return;\n } else {\n  $$01$i = $__first;$41 = $36;\n }\n while(1) {\n  $40 = HEAP8[$$01$i>>0]|0;\n  HEAP8[$41>>0] = $40;\n  $42 = HEAP32[$37>>2]|0;\n  $43 = ((($42)) + 1|0);\n  HEAP32[$37>>2] = $43;\n  $44 = ((($$01$i)) + 1|0);\n  $45 = ($44|0)==($__last|0);\n  if ($45) {\n   break;\n  } else {\n   $$01$i = $44;$41 = $43;\n  }\n }\n return;\n}\nfunction __ZN10Page_image9draw_maskERK4Mask($this,$m) {\n $this = $this|0;\n $m = $m|0;\n var $$pre = 0, $$pre21 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0;\n var $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0;\n var $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0;\n var $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0;\n var $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0;\n var $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0;\n var $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $col$018 = 0, $col1$015 = 0, $col2$0722 = 0, $col5$0823 = 0, $lprev$0$ = 0, $lprev$012 = 0, $rnew$0 = 0, $row$013 = 0, $row$013$in = 0, $rprev$011 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = ((($this)) + 4|0);\n $1 = HEAP32[$0>>2]|0;\n $2 = ((($m)) + 4|0);\n $3 = HEAP32[$2>>2]|0;\n $4 = ($1|0)<($3|0);\n $5 = $4 ? $3 : $1;\n $6 = ((($this)) + 12|0);\n $7 = HEAP32[$6>>2]|0;\n $8 = ((($m)) + 12|0);\n $9 = HEAP32[$8>>2]|0;\n $10 = ($9|0)<($7|0);\n $11 = $10 ? $9 : $7;\n $12 = ($5|0)==($3|0);\n if ($12) {\n  $13 = (__ZNK4Mask4leftEi($m,$3)|0);\n  $14 = ($13|0)>(-1);\n  if ($14) {\n   $15 = (__ZNK4Mask5rightEi($m,$3)|0);\n   $16 = ($15|0)>(-1);\n   if ($16) {\n    $17 = (__ZNK4Mask4leftEi($m,$3)|0);\n    $18 = (__ZNK4Mask5rightEi($m,$3)|0);\n    $19 = ($17|0)>($18|0);\n    if (!($19)) {\n     $20 = ((($this)) + 16|0);\n     $col$018 = $17;\n     while(1) {\n      $21 = HEAP32[$0>>2]|0;\n      $22 = (($3) - ($21))|0;\n      $23 = HEAP32[$20>>2]|0;\n      $24 = HEAP32[$this>>2]|0;\n      $25 = (($col$018) - ($24))|0;\n      $26 = (($23) + (($22*12)|0)|0);\n      $27 = HEAP32[$26>>2]|0;\n      $28 = (($27) + ($25)|0);\n      HEAP8[$28>>0] = 0;\n      $29 = (($col$018) + 1)|0;\n      $30 = (__ZNK4Mask5rightEi($m,$3)|0);\n      $31 = ($col$018|0)<($30|0);\n      if ($31) {\n       $col$018 = $29;\n      } else {\n       break;\n      }\n     }\n    }\n   }\n  }\n }\n $32 = HEAP32[$8>>2]|0;\n $33 = ($11|0)==($32|0);\n if ($33) {\n  $34 = (__ZNK4Mask4leftEi($m,$11)|0);\n  $35 = ($34|0)>(-1);\n  if ($35) {\n   $36 = (__ZNK4Mask5rightEi($m,$11)|0);\n   $37 = ($36|0)>(-1);\n   if ($37) {\n    $38 = (__ZNK4Mask4leftEi($m,$11)|0);\n    $39 = (__ZNK4Mask5rightEi($m,$11)|0);\n    $40 = ($38|0)>($39|0);\n    if (!($40)) {\n     $41 = ((($this)) + 16|0);\n     $col1$015 = $38;\n     while(1) {\n      $42 = HEAP32[$0>>2]|0;\n      $43 = (($11) - ($42))|0;\n      $44 = HEAP32[$41>>2]|0;\n      $45 = HEAP32[$this>>2]|0;\n      $46 = (($col1$015) - ($45))|0;\n      $47 = (($44) + (($43*12)|0)|0);\n      $48 = HEAP32[$47>>2]|0;\n      $49 = (($48) + ($46)|0);\n      HEAP8[$49>>0] = 0;\n      $50 = (($col1$015) + 1)|0;\n      $51 = (__ZNK4Mask5rightEi($m,$11)|0);\n      $52 = ($col1$015|0)<($51|0);\n      if ($52) {\n       $col1$015 = $50;\n      } else {\n       break;\n      }\n     }\n    }\n   }\n  }\n }\n $53 = (__ZNK4Mask4leftEi($m,$5)|0);\n $54 = (__ZNK4Mask5rightEi($m,$5)|0);\n $55 = ($5|0)<($11|0);\n if (!($55)) {\n  return;\n }\n $56 = ((($this)) + 8|0);\n $57 = ((($this)) + 16|0);\n $lprev$012 = $53;$row$013$in = $5;$rprev$011 = $54;\n while(1) {\n  $row$013 = (($row$013$in) + 1)|0;\n  $58 = (__ZNK4Mask4leftEi($m,$row$013)|0);\n  $59 = (__ZNK4Mask5rightEi($m,$row$013)|0);\n  $60 = ($58|0)<(0);\n  $lprev$0$ = $60 ? $lprev$012 : $58;\n  $61 = ($59|0)<(0);\n  $rnew$0 = $61 ? $rprev$011 : $59;\n  $62 = $lprev$0$ | $lprev$012;\n  $63 = ($62|0)>(-1);\n  if ($63) {\n   $64 = HEAP32[$this>>2]|0;\n   $65 = ($lprev$0$|0)<($lprev$012|0);\n   $66 = $65 ? $lprev$0$ : $lprev$012;\n   $67 = ($64|0)<($66|0);\n   $68 = $67 ? $66 : $64;\n   $69 = HEAP32[$56>>2]|0;\n   $70 = ($lprev$012|0)<($lprev$0$|0);\n   $71 = $70 ? $lprev$0$ : $lprev$012;\n   $72 = ($71|0)<($69|0);\n   $73 = $72 ? $71 : $69;\n   $74 = ($68|0)>($73|0);\n   if (!($74)) {\n    $75 = HEAP32[$0>>2]|0;\n    $76 = (($row$013) - ($75))|0;\n    $77 = HEAP32[$57>>2]|0;\n    $78 = (($68) - ($64))|0;\n    $79 = (($77) + (($76*12)|0)|0);\n    $80 = HEAP32[$79>>2]|0;\n    $81 = (($80) + ($78)|0);\n    HEAP8[$81>>0] = 0;\n    $82 = ($68|0)<($73|0);\n    if ($82) {\n     $col2$0722 = $68;\n     while(1) {\n      $83 = (($col2$0722) + 1)|0;\n      $$pre = HEAP32[$this>>2]|0;\n      $84 = HEAP32[$0>>2]|0;\n      $85 = (($row$013) - ($84))|0;\n      $86 = HEAP32[$57>>2]|0;\n      $87 = (($83) - ($$pre))|0;\n      $88 = (($86) + (($85*12)|0)|0);\n      $89 = HEAP32[$88>>2]|0;\n      $90 = (($89) + ($87)|0);\n      HEAP8[$90>>0] = 0;\n      $91 = ($83|0)<($73|0);\n      if ($91) {\n       $col2$0722 = $83;\n      } else {\n       break;\n      }\n     }\n    }\n   }\n  }\n  $92 = $rnew$0 | $rprev$011;\n  $93 = ($92|0)>(-1);\n  if ($93) {\n   $95 = HEAP32[$this>>2]|0;\n   $96 = ($rnew$0|0)<($rprev$011|0);\n   $97 = $96 ? $rnew$0 : $rprev$011;\n   $98 = ($95|0)<($97|0);\n   $99 = $98 ? $97 : $95;\n   $100 = HEAP32[$56>>2]|0;\n   $101 = ($rprev$011|0)<($rnew$0|0);\n   $102 = $101 ? $rnew$0 : $rprev$011;\n   $103 = ($102|0)<($100|0);\n   $104 = $103 ? $102 : $100;\n   $105 = ($99|0)>($104|0);\n   if (!($105)) {\n    $106 = HEAP32[$0>>2]|0;\n    $107 = (($row$013) - ($106))|0;\n    $108 = HEAP32[$57>>2]|0;\n    $109 = (($99) - ($95))|0;\n    $110 = (($108) + (($107*12)|0)|0);\n    $111 = HEAP32[$110>>2]|0;\n    $112 = (($111) + ($109)|0);\n    HEAP8[$112>>0] = 0;\n    $113 = ($99|0)<($104|0);\n    if ($113) {\n     $col5$0823 = $99;\n     while(1) {\n      $114 = (($col5$0823) + 1)|0;\n      $$pre21 = HEAP32[$this>>2]|0;\n      $115 = HEAP32[$0>>2]|0;\n      $116 = (($row$013) - ($115))|0;\n      $117 = HEAP32[$57>>2]|0;\n      $118 = (($114) - ($$pre21))|0;\n      $119 = (($117) + (($116*12)|0)|0);\n      $120 = HEAP32[$119>>2]|0;\n      $121 = (($120) + ($118)|0);\n      HEAP8[$121>>0] = 0;\n      $122 = ($114|0)<($104|0);\n      if ($122) {\n       $col5$0823 = $114;\n      } else {\n       break;\n      }\n     }\n    }\n   }\n  }\n  $94 = ($row$013|0)<($11|0);\n  if ($94) {\n   $lprev$012 = $lprev$0$;$row$013$in = $row$013;$rprev$011 = $rnew$0;\n  } else {\n   break;\n  }\n }\n return;\n}\nfunction __ZN10Page_image14draw_rectangleERK9Rectangle($this,$re) {\n $this = $this|0;\n $re = $re|0;\n var $$pre = 0, $$pre17 = 0, $$pre18 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;\n var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0;\n var $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0;\n var $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0;\n var $79 = 0, $8 = 0, $9 = 0, $col$010 = 0, $col2$07 = 0, $or$cond = 0, $or$cond14 = 0, $or$cond15 = 0, $or$cond16 = 0, $row$01219 = 0, $row1$08 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = HEAP32[$this>>2]|0;\n $1 = HEAP32[$re>>2]|0;\n $2 = ($1|0)>($0|0);\n $3 = $2 ? $1 : $0;\n $4 = ((($this)) + 4|0);\n $5 = HEAP32[$4>>2]|0;\n $6 = ((($re)) + 4|0);\n $7 = HEAP32[$6>>2]|0;\n $8 = ($5|0)<($7|0);\n $9 = $8 ? $7 : $5;\n $10 = ((($this)) + 8|0);\n $11 = HEAP32[$10>>2]|0;\n $12 = ((($re)) + 8|0);\n $13 = HEAP32[$12>>2]|0;\n $14 = ($13|0)<($11|0);\n $15 = $14 ? $13 : $11;\n $16 = ((($this)) + 12|0);\n $17 = HEAP32[$16>>2]|0;\n $18 = ((($re)) + 12|0);\n $19 = HEAP32[$18>>2]|0;\n $20 = ($19|0)<($17|0);\n $21 = $20 ? $19 : $17;\n $22 = ($3|0)!=($1|0);\n $23 = ($9|0)>($21|0);\n $or$cond = $22 | $23;\n if ($or$cond) {\n  $41 = $7;\n } else {\n  $24 = ((($this)) + 16|0);\n  $25 = (($9) - ($5))|0;\n  $26 = HEAP32[$24>>2]|0;\n  $27 = (($1) - ($0))|0;\n  $28 = (($26) + (($25*12)|0)|0);\n  $29 = HEAP32[$28>>2]|0;\n  $30 = (($29) + ($27)|0);\n  HEAP8[$30>>0] = 0;\n  $31 = ($9|0)<($21|0);\n  if ($31) {\n   $row$01219 = $9;\n   while(1) {\n    $32 = (($row$01219) + 1)|0;\n    $$pre = HEAP32[$4>>2]|0;\n    $$pre17 = HEAP32[$this>>2]|0;\n    $33 = (($32) - ($$pre))|0;\n    $34 = HEAP32[$24>>2]|0;\n    $35 = (($1) - ($$pre17))|0;\n    $36 = (($34) + (($33*12)|0)|0);\n    $37 = HEAP32[$36>>2]|0;\n    $38 = (($37) + ($35)|0);\n    HEAP8[$38>>0] = 0;\n    $39 = ($32|0)<($21|0);\n    if ($39) {\n     $row$01219 = $32;\n    } else {\n     break;\n    }\n   }\n  }\n  $$pre18 = HEAP32[$6>>2]|0;\n  $41 = $$pre18;\n }\n $40 = ($9|0)!=($41|0);\n $42 = ($3|0)>($15|0);\n $or$cond14 = $40 | $42;\n if (!($or$cond14)) {\n  $43 = ((($this)) + 16|0);\n  $col$010 = $3;\n  while(1) {\n   $44 = HEAP32[$4>>2]|0;\n   $45 = (($9) - ($44))|0;\n   $46 = HEAP32[$43>>2]|0;\n   $47 = HEAP32[$this>>2]|0;\n   $48 = (($col$010) - ($47))|0;\n   $49 = (($46) + (($45*12)|0)|0);\n   $50 = HEAP32[$49>>2]|0;\n   $51 = (($50) + ($48)|0);\n   HEAP8[$51>>0] = 0;\n   $52 = (($col$010) + 1)|0;\n   $53 = ($col$010|0)<($15|0);\n   if ($53) {\n    $col$010 = $52;\n   } else {\n    break;\n   }\n  }\n }\n $54 = HEAP32[$12>>2]|0;\n $55 = ($15|0)!=($54|0);\n $or$cond15 = $55 | $23;\n if (!($or$cond15)) {\n  $56 = ((($this)) + 16|0);\n  $row1$08 = $9;\n  while(1) {\n   $57 = HEAP32[$4>>2]|0;\n   $58 = (($row1$08) - ($57))|0;\n   $59 = HEAP32[$56>>2]|0;\n   $60 = HEAP32[$this>>2]|0;\n   $61 = (($15) - ($60))|0;\n   $62 = (($59) + (($58*12)|0)|0);\n   $63 = HEAP32[$62>>2]|0;\n   $64 = (($63) + ($61)|0);\n   HEAP8[$64>>0] = 0;\n   $65 = (($row1$08) + 1)|0;\n   $66 = ($row1$08|0)<($21|0);\n   if ($66) {\n    $row1$08 = $65;\n   } else {\n    break;\n   }\n  }\n }\n $67 = HEAP32[$18>>2]|0;\n $68 = ($21|0)!=($67|0);\n $or$cond16 = $68 | $42;\n if ($or$cond16) {\n  return;\n }\n $69 = ((($this)) + 16|0);\n $col2$07 = $3;\n while(1) {\n  $70 = HEAP32[$4>>2]|0;\n  $71 = (($21) - ($70))|0;\n  $72 = HEAP32[$69>>2]|0;\n  $73 = HEAP32[$this>>2]|0;\n  $74 = (($col2$07) - ($73))|0;\n  $75 = (($72) + (($71*12)|0)|0);\n  $76 = HEAP32[$75>>2]|0;\n  $77 = (($76) + ($74)|0);\n  HEAP8[$77>>0] = 0;\n  $78 = (($col2$07) + 1)|0;\n  $79 = ($col2$07|0)<($15|0);\n  if ($79) {\n   $col2$07 = $78;\n  } else {\n   break;\n  }\n }\n return;\n}\nfunction __ZN10Page_image10draw_trackERK5Track($this,$tr) {\n $this = $this|0;\n $tr = $tr|0;\n var $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;\n var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;\n var $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0;\n var $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0;\n var $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0;\n var $98 = 0, $99 = 0, $col$03 = 0, $row$07 = 0, $row1$04 = 0, label = 0, sp = 0;\n sp = STACKTOP;\n $0 = HEAP32[$this>>2]|0;\n $1 = HEAP32[$tr>>2]|0;\n $2 = ((($tr)) + 4|0);\n $3 = HEAP32[$2>>2]|0;\n $4 = ($1|0)==($3|0);\n if ($4) {\n  $5 = ($0|0)<(0);\n  $6 = $5 ? 0 : $0;\n  $7 = ((($this)) + 8|0);\n  $8 = HEAP32[$7>>2]|0;\n  $9 = ($8|0)>(0);\n  $10 = $9 ? 0 : $8;\n  $21 = $6;$23 = 0;$49 = $10;\n } else {\n  $11 = HEAP32[$1>>2]|0;\n  $12 = ($0|0)<($11|0);\n  $13 = $12 ? $11 : $0;\n  $14 = ((($this)) + 8|0);\n  $15 = HEAP32[$14>>2]|0;\n  $16 = ((($3)) + -12|0);\n  $17 = HEAP32[$16>>2]|0;\n  $18 = ($17|0)<($15|0);\n  $19 = $18 ? $17 : $15;\n  $20 = HEAP32[$1>>2]|0;\n  $21 = $13;$23 = $20;$49 = $19;\n }\n $22 = ($21|0)==($23|0);\n if ($22) {\n  $24 = (__ZNK5Track3topEi($tr,$21)|0);\n  $25 = (__ZNK5Track6bottomEi($tr,$21)|0);\n  $26 = ($24|0)>($25|0);\n  if (!($26)) {\n   $27 = ((($this)) + 4|0);\n   $28 = ((($this)) + 12|0);\n   $29 = ((($this)) + 16|0);\n   $row$07 = $24;\n   while(1) {\n    $30 = HEAP32[$27>>2]|0;\n    $31 = ($row$07|0)<($30|0);\n    if (!($31)) {\n     $32 = HEAP32[$28>>2]|0;\n     $33 = ($row$07|0)>($32|0);\n     if (!($33)) {\n      $34 = (($row$07) - ($30))|0;\n      $35 = HEAP32[$29>>2]|0;\n      $36 = HEAP32[$this>>2]|0;\n      $37 = (($21) - ($36))|0;\n      $38 = (($35) + (($34*12)|0)|0);\n      $39 = HEAP32[$38>>2]|0;\n      $40 = (($39) + ($37)|0);\n      HEAP8[$40>>0] = 0;\n     }\n    }\n    $41 = (($row$07) + 1)|0;\n    $42 = (__ZNK5Track6bottomEi($tr,$21)|0);\n    $43 = ($row$07|0)<($42|0);\n    if ($43) {\n     $row$07 = $41;\n    } else {\n     break;\n    }\n   }\n  }\n }\n $44 = HEAP32[$tr>>2]|0;\n $45 = HEAP32[$2>>2]|0;\n $46 = ($44|0)==($45|0);\n if ($46) {\n  $51 = 0;\n } else {\n  $47 = ((($45)) + -12|0);\n  $48 = HEAP32[$47>>2]|0;\n  $51 = $48;\n }\n $50 = ($49|0)==($51|0);\n if ($50) {\n  $56 = (__ZNK5Track3topEi($tr,$49)|0);\n  $57 = (__ZNK5Track6bottomEi($tr,$49)|0);\n  $58 = ($56|0)>($57|0);\n  if (!($58)) {\n   $59 = ((($this)) + 4|0);\n   $60 = ((($this)) + 12|0);\n   $61 = ((($this)) + 16|0);\n   $row1$04 = $56;\n   while(1) {\n    $62 = HEAP32[$59>>2]|0;\n    $63 = ($row1$04|0)<($62|0);\n    if (!($63)) {\n     $64 = HEAP32[$60>>2]|0;\n     $65 = ($row1$04|0)>($64|0);\n     if (!($65)) {\n      $66 = (($row1$04) - ($62))|0;\n      $67 = HEAP32[$61>>2]|0;\n      $68 = HEAP32[$this>>2]|0;\n      $69 = (($49) - ($68))|0;\n      $70 = (($67) + (($66*12)|0)|0);\n      $71 = HEAP32[$70>>2]|0;\n      $72 = (($71) + ($69)|0);\n      HEAP8[$72>>0] = 0;\n     }\n    }\n    $73 = (($row1$04) + 1)|0;\n    $74 = (__ZNK5Track6bottomEi($tr,$49)|0);\n    $75 = ($row1$04|0)<($74|0);\n    if ($75) {\n     $row1$04 = $73;\n    } else {\n     break;\n    }\n   }\n  }\n }\n $52 = ($21|0)>($49|0);\n if ($52) {\n  return;\n }\n $53 = ((($this)) + 4|0);\n $54 = ((($this)) + 12|0);\n $55 = ((($this)) + 16|0);\n $col$03 = $21;\n while(1) {\n  $76 = (__ZNK5Track3topEi($tr,$col$03)|0);\n  $77 = HEAP32[$53>>2]|0;\n  $78 = ($76|0)<($77|0);\n  if (!($78)) {\n   $79 = HEAP32[$54>>2]|0;\n   $80 = ($76|0)>($79|0);\n   if (!($80)) {\n    $81 = (($76) - ($77))|0;\n    $82 = HEAP32[$55>>2]|0;\n    $83 = HEAP32[$this>>2]|0;\n    $84 = (($col$03) - ($83))|0;\n    $85 = (($82) + (($81*12)|0)|0);\n    $86 = HEAP32[$85>>2]|0;\n    $87 = (($86) + ($84)|0);\n    HEAP8[$87>>0] = 0;\n   }\n  }\n  $88 = (__ZNK5Track6bottomEi($tr,$col$03)|0);\n  $89 = HEAP32[$53>>2]|0;\n  $90 = ($88|0)<($89|0);\n  if (!($90)) {\n   $91 = HEAP32[$54>>2]|0;\n   $92 = ($88|0)>($91|0);\n   if (!($92)) {\n    $93 = (($88) - ($89))|0;\n    $94 = HEAP32[$55>>2]|0;\n    $95 = HEAP32[$this>>2]|0;\n    $96 = (($col$03) - ($95))|0;\n    $97 = (($94) + (($93*12)|0)|0);\n    $98 = HEAP32[$97>>2]|0;\n    $99 = (($98) + ($96)|0);\n    HEAP8[$99>>0] = 0;\n   }\n  }\n  $100 = (($col$03) + 1)|0;\n  $101 = ($col$03|0)<($49|0);\n  if ($101) {\n   $col$03 = $100;\n  } else {\n   break;\n  }\n }\n return;\n}\nfunction __ZN10Page_image12change_scaleEi($this,$n) {\n $this = $this|0;\n $n = $n|0;\n var $$0 = 0, $$0$i1$i$i$i = 0, $$0$i1$i$i$i137 = 0, $$0$i1$i$i$us$i = 0, $$0$i1$i$i15$i = 0, $$0$i1$i$i26$i = 0, $$0$i1$i$i26$us$i = 0, $$0$i1$i$i43$i = 0, $$0$i1$i$i43$i125 = 0, $$0$i1$i$i58$i = 0, $$0$i2$i$i$i = 0, $$0$i2$i$i$i138 = 0, $$0$i2$i$i$us$i = 0, $$0$i2$i$i16$i = 0, $$0$i2$i$i27$i = 0, $$0$i2$i$i27$us$i = 0, $$0$i2$i$i44$i = 0, $$0$i2$i$i44$i126 = 0, $$0$i2$i$i59$i = 0, $$01 = 0;\n var $$01$i$i$i$i$i = 0, $$01150 = 0, $$cast$i = 0, $$cast$i101 = 0, $$cast$i25 = 0, $$cast$i40 = 0, $$cast$i83 = 0, $$in$i$i$i = 0, $$in$i$i$i134 = 0, $$in$i$i$us$i = 0, $$in$i$i12$i = 0, $$in$i$i23$i = 0, $$in$i$i23$us$i = 0, $$in$i$i40$i = 0, $$in$i$i40$i121 = 0, $$in$i$i55$i = 0, $$lcssa211 = 0, $$lcssa211$lcssa = 0, $$lcssa212 = 0, $$lcssa213 = 0;\n var $$lcssa75$i = 0, $$not$i = 0, $$not$i47 = 0, $$not23$i = 0, $$not34$i = 0, $$not4$i = 0, $$not4$i53 = 0, $$not5$i = 0, $$not5$i48 = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i$i$i = 0, $$pre$i$i$i$i = 0, $$pre$i$i$i$i143 = 0, $$pre$i$i$i$i18 = 0, $$pre$i$i$i$i32 = 0, $$pre$i$i$i$i75 = 0, $$pre$i$i$i$i8 = 0, $$pre$i$i$i$i93 = 0;\n var $$pre$i$i$i130 = 0, $$pre$i$i$i26$i = 0, $$pre$i$i$i27$i = 0, $$pre$i$i$i5$i = 0, $$pre$i$i$i59$i = 0, $$pre$i$i$i9$i = 0, $$pre$i$i$us$i = 0, $$pre$i$i11 = 0, $$pre$i$i146 = 0, $$pre$i$i19$i = 0, $$pre$i$i19$us$i = 0, $$pre$i$i21 = 0, $$pre$i$i35 = 0, $$pre$i$i36$i = 0, $$pre$i$i36$i118 = 0, $$pre$i$i51$i = 0, $$pre$i$i78 = 0, $$pre$i$i8$i = 0, $$pre$i$i96 = 0, $$pre$i10$i = 0;\n var $$pre$i103 = 0, $$pre$i12$i = 0, $$pre$i21$i = 0, $$pre$i21$us$i = 0, $$pre$i27$us$i = 0, $$pre$i29$i = 0, $$pre$i3$i = 0, $$pre$i3$i132 = 0, $$pre$i30$i = 0, $$pre$i38$i = 0, $$pre$i38$i119 = 0, $$pre$i42 = 0, $$pre$i53$i = 0, $$pre$i62$i = 0, $$pre$i8$i = 0, $$pre$i84 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i$us$iZ2D = 0, $$pre$phi$i27Z2D = 0, $$pre$phi$i54$iZ2D = 0;\n var $$pre$phi175Z2D = 0, $$pre$phi177Z2D = 0, $$pre$phi179Z2D = 0, $$pre$phi51$iZ2D = 0, $$pre$phi87$iZ2D = 0, $$pre172 = 0, $$pre47$i = 0, $$pre48$i = 0, $$pre49$i = 0, $$pre82$i = 0, $$pre83$i = 0, $$pre85$i = 0, $$pre86$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0;\n var $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0, $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0, $1010 = 0, $1011 = 0, $1012 = 0, $1013 = 0, $1014 = 0, $1015 = 0, $1016 = 0, $1017 = 0, $1018 = 0, $1019 = 0, $102 = 0, $1020 = 0;\n var $1021 = 0, $1022 = 0, $1023 = 0, $1024 = 0, $1025 = 0, $1026 = 0, $1027 = 0, $1028 = 0, $1029 = 0, $103 = 0, $1030 = 0, $1031 = 0, $1032 = 0, $1033 = 0, $1034 = 0, $1035 = 0, $1036 = 0, $1037 = 0, $1038 = 0, $1039 = 0;\n var $104 = 0, $1040 = 0, $1041 = 0, $1042 = 0, $1043 = 0, $1044 = 0, $1045 = 0, $1046 = 0, $1047 = 0, $1048 = 0, $1049 = 0, $105 = 0, $1050 = 0, $1051 = 0, $1052 = 0, $1053 = 0, $1054 = 0, $1055 = 0, $1056 = 0, $1057 = 0;\n var $1058 = 0, $1059 = 0, $106 = 0, $1060 = 0, $1061 = 0, $1062 = 0, $1063 = 0, $1064 = 0, $1065 = 0, $1066 = 0, $1067 = 0, $1068 = 0, $1069 = 0, $107 = 0, $1070 = 0, $1071 = 0, $1072 = 0, $1073 = 0, $1074 = 0, $1075 = 0;\n var $1076 = 0, $1077 = 0, $1078 = 0, $1079 = 0, $108 = 0, $1080 = 0, $1081 = 0, $1082 = 0, $1083 = 0, $1084 = 0, $1085 = 0, $1086 = 0, $1087 = 0, $1088 = 0, $1089 = 0, $109 = 0, $1090 = 0, $1091 = 0, $1092 = 0, $1093 = 0;\n var $1094 = 0, $1095 = 0, $1096 = 0, $1097 = 0, $1098 = 0, $1099 = 0, $11 = 0, $110 = 0, $1100 = 0, $1101 = 0, $1102 = 0, $1103 = 0, $1104 = 0, $1105 = 0, $1106 = 0, $1107 = 0, $1108 = 0, $1109 = 0, $111 = 0, $1110 = 0;\n var $1111 = 0, $1112 = 0, $1113 = 0, $1114 = 0, $1115 = 0, $1116 = 0, $1117 = 0, $1118 = 0, $1119 = 0, $112 = 0, $1120 = 0, $1121 = 0, $1122 = 0, $1123 = 0, $1124 = 0, $1125 = 0, $1126 = 0, $1127 = 0, $1128 = 0, $1129 = 0;\n var $113 = 0, $1130 = 0, $1131 = 0, $1132 = 0, $1133 = 0, $1134 = 0, $1135 = 0, $1136 = 0, $1137 = 0, $1138 = 0, $1139 = 0, $114 = 0, $1140 = 0, $1141 = 0, $1142 = 0, $1143 = 0, $1144 = 0, $1145 = 0, $1146 = 0, $1147 = 0;\n var $1148 = 0, $1149 = 0, $115 = 0, $1150 = 0, $1151 = 0, $1152 = 0, $1153 = 0, $1154 = 0, $1155 = 0, $1156 = 0, $1157 = 0, $1158 = 0, $1159 = 0, $116 = 0, $1160 = 0, $1161 = 0, $1162 = 0, $1163 = 0, $1164 = 0, $1165 = 0;\n var $1166 = 0, $1167 = 0, $1168 = 0, $1169 = 0, $117 = 0, $1170 = 0, $1171 = 0, $1172 = 0, $1173 = 0, $1174 = 0, $1175 = 0, $1176 = 0, $1177 = 0, $1178 = 0, $1179 = 0, $118 = 0, $1180 = 0, $1181 = 0, $1182 = 0, $1183 = 0;\n var $1184 = 0, $1185 = 0, $1186 = 0, $1187 = 0, $1188 = 0, $1189 = 0, $119 = 0, $1190 = 0, $1191 = 0, $1192 = 0, $1193 = 0, $1194 = 0, $1195 = 0, $1196 = 0, $1197 = 0, $1198 = 0, $1199 = 0, $12 = 0, $120 = 0, $1200 = 0;\n var $1201 = 0, $1202 = 0, $1203 = 0, $1204 = 0, $1205 = 0, $1206 = 0, $1207 = 0, $1208 = 0, $1209 = 0, $121 = 0, $1210 = 0, $1211 = 0, $1212 = 0, $1213 = 0, $1214 = 0, $1215 = 0, $1216 = 0, $1217 = 0, $1218 = 0, $1219 = 0;\n var $122 = 0, $1220 = 0, $1221 = 0, $1222 = 0, $1223 = 0, $1224 = 0, $1225 = 0, $1226 = 0, $1227 = 0, $1228 = 0, $1229 = 0, $123 = 0, $1230 = 0, $1231 = 0, $1232 = 0, $1233 = 0, $1234 = 0, $1235 = 0, $1236 = 0, $1237 = 0;\n var $1238 = 0, $1239 = 0, $124 = 0, $1240 = 0, $1241 = 0, $1242 = 0, $1243 = 0, $1244 = 0, $1245 = 0, $1246 = 0, $1247 = 0, $1248 = 0, $1249 = 0, $125 = 0, $1250 = 0, $1251 = 0, $1252 = 0, $1253 = 0, $1254 = 0, $1255 = 0;\n var $1256 = 0, $1257 = 0, $1258 = 0, $1259 = 0, $126 = 0, $1260 = 0, $1261 = 0, $1262 = 0, $1263 = 0, $1264 = 0, $1265 = 0, $1266 = 0, $1267 = 0, $1268 = 0, $1269 = 0, $127 = 0, $1270 = 0, $1271 = 0, $1272 = 0, $1273 = 0;\n var $1274 = 0, $1275 = 0, $1276 = 0, $1277 = 0, $1278 = 0, $1279 = 0, $128 = 0, $1280 = 0, $1281 = 0, $1282 = 0, $1283 = 0, $1284 = 0, $1285 = 0, $1286 = 0, $1287 = 0, $1288 = 0, $1289 = 0, $129 = 0, $1290 = 0, $1291 = 0;\n var $1292 = 0, $1293 = 0, $1294 = 0, $1295 = 0, $1296 = 0, $1297 = 0, $1298 = 0, $1299 = 0, $13 = 0, $130 = 0, $1300 = 0, $1301 = 0, $1302 = 0, $1303 = 0, $1304 = 0, $1305 = 0, $1306 = 0, $1307 = 0, $1308 = 0, $1309 = 0;\n var $131 = 0, $1310 = 0, $1311 = 0, $1312 = 0, $1313 = 0, $1314 = 0, $1315 = 0, $1316 = 0, $1317 = 0, $1318 = 0, $1319 = 0, $132 = 0, $1320 = 0, $1321 = 0, $1322 = 0, $1323 = 0, $1324 = 0, $1325 = 0, $1326 = 0, $1327 = 0;\n var $1328 = 0, $1329 = 0, $133 = 0, $1330 = 0, $1331 = 0, $1332 = 0, $1333 = 0, $1334 = 0, $1335 = 0, $1336 = 0, $1337 = 0, $1338 = 0, $1339 = 0, $134 = 0, $1340 = 0, $1341 = 0, $1342 = 0, $1343 = 0, $1344 = 0, $1345 = 0;\n var $1346 = 0, $1347 = 0, $1348 = 0, $1349 = 0, $135 = 0, $1350 = 0, $1351 = 0, $1352 = 0, $1353 = 0, $1354 = 0, $1355 = 0, $1356 = 0, $1357 = 0, $1358 = 0, $1359 = 0, $136 = 0, $1360 = 0, $1361 = 0, $1362 = 0, $1363 = 0;\n var $1364 = 0, $1365 = 0, $1366 = 0, $1367 = 0, $1368 = 0, $1369 = 0, $137 = 0, $1370 = 0, $1371 = 0, $1372 = 0, $1373 = 0, $1374 = 0, $1375 = 0, $1376 = 0, $1377 = 0, $1378 = 0, $1379 = 0, $138 = 0, $1380 = 0, $1381 = 0;\n var $1382 = 0, $1383 = 0, $1384 = 0, $1385 = 0, $1386 = 0, $1387 = 0, $1388 = 0, $1389 = 0, $139 = 0, $1390 = 0, $1391 = 0, $1392 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0;\n var $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0;\n var $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0;\n var $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0;\n var $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0;\n var $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0;\n var $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0;\n var $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0;\n var $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0;\n var $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0;\n var $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0;\n var $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0;\n var $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0;\n var $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0;\n var $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0;\n var $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0;\n var $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0;\n var $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0;\n var $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0;\n var $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0;\n var $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0;\n var $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0;\n var $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0;\n var $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0;\n var $561 = 0, $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0;\n var $58 = 0, $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0;\n var $598 = 0, $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0;\n var $615 = 0, $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0;\n var $633 = 0, $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0;\n var $651 = 0, $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0;\n var $67 = 0, $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0;\n var $688 = 0, $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0;\n var $705 = 0, $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0;\n var $723 = 0, $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0;\n var $741 = 0, $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0;\n var $76 = 0, $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0;\n var $778 = 0, $779 = 0, $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0;\n var $796 = 0, $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0;\n var $813 = 0, $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0;\n var $831 = 0, $832 = 0, $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0;\n var $85 = 0, $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0;\n var $868 = 0, $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0;\n var $886 = 0, $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0;\n var $903 = 0, $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0;\n var $921 = 0, $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0;\n var $94 = 0, $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0;\n var $958 = 0, $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0;\n var $976 = 0, $977 = 0, $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0;\n var $994 = 0, $995 = 0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $brmerge$i = 0, $brmerge$i54 = 0, $brmerge10$i = 0, $brmerge10$i60 = 0, $brmerge11$i = 0, $brmerge11$i61 = 0, $brmerge12$i = 0, $brmerge12$i62 = 0, $brmerge12$not$i = 0, $brmerge12$not$i63 = 0, $brmerge13$i = 0, $brmerge13$i64 = 0, $brmerge14$i = 0, $brmerge14$i65 = 0;\n var $brmerge15$i = 0, $brmerge15$i66 = 0, $brmerge15$not$i = 0, $brmerge15$not$i67 = 0, $brmerge17$i = 0, $brmerge17$i68 = 0, $brmerge18$i = 0, $brmerge18$i69 = 0, $brmerge18$not$i = 0, $brmerge18$not$i70 = 0, $brmerge22$demorgan$i = 0, $brmerge22$i = 0, $brmerge24$i = 0, $brmerge27$demorgan$i = 0, $brmerge30$not$i = 0, $brmerge32$not$i = 0, $brmerge35$i = 0, $brmerge38$not$i = 0, $brmerge40$not$i = 0, $brmerge46$demorgan$i = 0;\n var $brmerge48$demorgan$i = 0, $brmerge51$i = 0, $brmerge7$i = 0, $brmerge7$i56 = 0, $brmerge8$i = 0, $brmerge8$i57 = 0, $brmerge9$i = 0, $brmerge9$i58 = 0, $brmerge9$not$i = 0, $brmerge9$not$i59 = 0, $c$069$us$us$i = 0, $col$037$i = 0, $col$038$us$i = 0, $col$067$i = 0, $col$073$i = 0, $col$078$i = 0, $col2$077$i = 0, $col4$076$i = 0, $col4$076$us$i = 0, $col5$080$i = 0;\n var $eh$lpad$body$sink$i$index6Z2D = 0, $eh$lpad$body$sink$i$indexZ2D = 0, $exitcond$i = 0, $exitcond$i105 = 0, $exitcond$i71 = 0, $exitcond113$i = 0, $exitcond114$i = 0, $exitcond115$i = 0, $i$037$us$i = 0, $i1$040$i = 0, $lpad$phi$i$index = 0, $lpad$phi$i$index31 = 0, $lpad$phi$i112$index = 0, $lpad$phi$i112$index18 = 0, $new_data$i = 0, $new_data$i100 = 0, $new_data$i24 = 0, $new_data$i39 = 0, $new_data$i82 = 0, $or$cond$i102 = 0;\n var $or$cond$i28 = 0, $or$cond$i52 = 0, $or$cond1$i = 0, $or$cond20$i = 0, $or$cond21$i = 0, $or$cond22$i = 0, $or$cond23$i = 0, $or$cond3$i = 0, $or$cond3$i55 = 0, $or$cond52$i = 0, $or$cond53$i = 0, $or$cond54$i = 0, $or$cond55$i = 0, $or$cond66$i = 0, $or$cond67$i = 0, $or$cond68$i = 0, $or$cond69$i = 0, $r$072$us$us$i = 0, $reduced = 0, $row$043$i = 0;\n var $row$043$i86 = 0, $row$078$i = 0, $row$082$i = 0, $row$082$us$i = 0, $row$093$i = 0, $row1$039$i = 0, $row1$074$i = 0, $row1$080$i = 0, $row1$090$i = 0, $row1$090$us$i = 0, $row2$088$i = 0, $row3$083$i = 0, $sum$071$us$us$i = 0, $sum$168$us$us$i = 0, label = 0, sp = 0;\n sp = STACKTOP;\n STACKTOP = STACKTOP + 112|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();\n $new_data$i100 = sp + 92|0;\n $new_data$i82 = sp + 80|0;\n $0 = sp + 68|0;\n $new_data$i39 = sp + 56|0;\n $1 = sp + 105|0;\n $new_data$i24 = sp + 44|0;\n $2 = sp + 104|0;\n $new_data$i = sp + 32|0;\n $reduced = sp;\n $3 = ($n|0)<(-1);\n if ($3) {\n  $4 = (0 - ($n))|0;\n  __ZN10Page_imageC2ERKS_i($reduced,$this,$4);\n  ;HEAP32[$this>>2]=HEAP32[$reduced>>2]|0;HEAP32[$this+4>>2]=HEAP32[$reduced+4>>2]|0;HEAP32[$this+8>>2]=HEAP32[$reduced+8>>2]|0;HEAP32[$this+12>>2]=HEAP32[$reduced+12>>2]|0;\n  $5 = ($reduced|0)==($this|0);\n  if (!($5)) {\n   $6 = ((($this)) + 16|0);\n   $7 = ((($reduced)) + 16|0);\n   $8 = HEAP32[$7>>2]|0;\n   $9 = ((($reduced)) + 20|0);\n   $10 = HEAP32[$9>>2]|0;\n   __THREW__ = 0;\n   invoke_viii(50,($6|0),($8|0),($10|0));\n   $11 = __THREW__; __THREW__ = 0;\n   $12 = $11&1;\n   if ($12) {\n    $32 = ___cxa_find_matching_catch_2()|0;\n    $33 = tempRet0;\n    $34 = ((($reduced)) + 16|0);\n    $35 = HEAP32[$34>>2]|0;\n    $36 = ($35|0)==(0|0);\n    if ($36) {\n     ___resumeException($32|0);\n     // unreachable;\n    }\n    $37 = HEAP32[$9>>2]|0;\n    $38 = ($37|0)==($35|0);\n    if ($38) {\n     $48 = $35;\n    } else {\n     $40 = $37;\n     while(1) {\n      $39 = ((($40)) + -12|0);\n      HEAP32[$9>>2] = $39;\n      $41 = HEAP32[$39>>2]|0;\n      $42 = ($41|0)==(0|0);\n      if ($42) {\n       $43 = $39;\n      } else {\n       $45 = ((($40)) + -8|0);\n       $46 = HEAP32[$45>>2]|0;\n       $47 = ($46|0)==($41|0);\n       if (!($47)) {\n        HEAP32[$45>>2] = $41;\n       }\n       __ZdlPv($41);\n       $$pre$i$i$i$i8 = HEAP32[$9>>2]|0;\n       $43 = $$pre$i$i$i$i8;\n      }\n      $44 = ($43|0)==($35|0);\n      if ($44) {\n       break;\n      } else {\n       $40 = $43;\n      }\n     }\n     $$pre$i$i11 = HEAP32[$34>>2]|0;\n     $48 = $$pre$i$i11;\n    }\n    __ZdlPv($48);\n    ___resumeException($32|0);\n    // unreachable;\n   }\n  }\n  $13 = ((($this)) + 28|0);\n  $14 = ((($reduced)) + 28|0);\n  $15 = HEAP16[$14>>1]|0;\n  HEAP16[$13>>1] = $15;\n  $16 = ((($reduced)) + 16|0);\n  $17 = HEAP32[$16>>2]|0;\n  $18 = ($17|0)==(0|0);\n  if (!($18)) {\n   $19 = ((($reduced)) + 20|0);\n   $20 = HEAP32[$19>>2]|0;\n   $21 = ($20|0)==($17|0);\n   if ($21) {\n    $31 = $17;\n   } else {\n    $23 = $20;\n    while(1) {\n     $22 = ((($23)) + -12|0);\n     HEAP32[$19>>2] = $22;\n     $24 = HEAP32[$22>>2]|0;\n     $25 = ($24|0)==(0|0);\n     if ($25) {\n      $26 = $22;\n     } else {\n      $28 = ((($23)) + -8|0);\n      $29 = HEAP32[$28>>2]|0;\n      $30 = ($29|0)==($24|0);\n      if (!($30)) {\n       HEAP32[$28>>2] = $24;\n      }\n      __ZdlPv($24);\n      $$pre$i$i$i$i = HEAP32[$19>>2]|0;\n      $26 = $$pre$i$i$i$i;\n     }\n     $27 = ($26|0)==($17|0);\n     if ($27) {\n      break;\n     } else {\n      $23 = $26;\n     }\n    }\n    $$pre$i$i = HEAP32[$16>>2]|0;\n    $31 = $$pre$i$i;\n   }\n   __ZdlPv($31);\n  }\n  $$0 = 1;\n  STACKTOP = sp;return ($$0|0);\n }\n $49 = ($n|0)>(1);\n if (!($49)) {\n  $$0 = 0;\n  STACKTOP = sp;return ($$0|0);\n }\n $50 = (2147483647 / ($n|0))&-1;\n $51 = ((($this)) + 8|0);\n $52 = HEAP32[$51>>2]|0;\n $53 = HEAP32[$this>>2]|0;\n $54 = (($52) + 1)|0;\n $55 = (($54) - ($53))|0;\n $56 = ((($this)) + 12|0);\n $57 = HEAP32[$56>>2]|0;\n $58 = ((($this)) + 4|0);\n $59 = HEAP32[$58>>2]|0;\n $60 = (($57) + 1)|0;\n $61 = (($60) - ($59))|0;\n $62 = Math_imul($61, $55)|0;\n $63 = ($50|0)<($62|0);\n if ($63) {\n  $64 = (___cxa_allocate_exception(4)|0);\n  HEAP32[$64>>2] = 1509;\n  ___cxa_throw(($64|0),(8|0),(0|0));\n  // unreachable;\n }\n $65 = ((($this)) + 28|0);\n $66 = HEAP8[$65>>0]|0;\n $67 = ($66<<24>>24)==(1);\n do {\n  if ($67) {\n   $68 = $n & 1;\n   $69 = ($68|0)==(0);\n   if ($69) {\n    $70 = ((($this)) + 16|0);\n    $71 = ((($this)) + 20|0);\n    $72 = HEAP32[$71>>2]|0;\n    $73 = HEAP32[$70>>2]|0;\n    $74 = (($72) - ($73))|0;\n    $75 = (($74|0) / 12)&-1;\n    $$cast$i25 = $73;\n    $76 = ((($$cast$i25)) + 4|0);\n    $77 = HEAP32[$76>>2]|0;\n    $78 = $73;\n    $79 = HEAP32[$78>>2]|0;\n    $80 = (($77) - ($79))|0;\n    $81 = $75 << 1;\n    __ZNSt3__16vectorINS0_IhNS_9allocatorIhEEEENS1_IS3_EEEC2Ej($new_data$i24,$81);\n    $82 = ((($new_data$i24)) + 4|0);\n    $83 = HEAP32[$82>>2]|0;\n    $84 = HEAP32[$new_data$i24>>2]|0;\n    $85 = ($83|0)==($84|0);\n    $86 = $84;\n    L48: do {\n     if ($85) {\n      $1364 = $86;\n     } else {\n      $87 = $80 << 1;\n      $1365 = $86;$1366 = $84;$1367 = $83;$93 = $86;$row$043$i = 0;\n      while(1) {\n       $92 = (($93) + (($row$043$i*12)|0)|0);\n       HEAP8[$2>>0] = 1;\n       $94 = (((($93) + (($row$043$i*12)|0)|0)) + 4|0);\n       $95 = HEAP32[$94>>2]|0;\n       $96 = HEAP32[$92>>2]|0;\n       $97 = (($95) - ($96))|0;\n       $98 = ($87>>>0)>($97>>>0);\n       $99 = $96;\n       $100 = $95;\n       if ($98) {\n        $101 = (($87) - ($97))|0;\n        __THREW__ = 0;\n        invoke_viii(51,($92|0),($101|0),($2|0));\n        $102 = __THREW__; __THREW__ = 0;\n        $103 = $102&1;\n        if ($103) {\n         break;\n        }\n        $$pre$i = HEAP32[$82>>2]|0;\n        $$pre47$i = HEAP32[$new_data$i24>>2]|0;\n        $104 = $$pre47$i;\n        $110 = $$pre47$i;$111 = $$pre$i;$1368 = $104;\n       } else {\n        $105 = ($87>>>0)<($97>>>0);\n        if ($105) {\n         $106 = (($99) + ($87)|0);\n         $107 = ($100|0)==($106|0);\n         if ($107) {\n          $110 = $1366;$111 = $1367;$1368 = $1365;\n         } else {\n          HEAP32[$94>>2] = $106;\n          $110 = $1366;$111 = $1367;$1368 = $1365;\n         }\n        } else {\n         $110 = $1366;$111 = $1367;$1368 = $1365;\n        }\n       }\n       $108 = (($row$043$i) + 1)|0;\n       $109 = (($111) - ($110))|0;\n       $112 = (($109|0) / 12)&-1;\n       $113 = ($108>>>0)<($112>>>0);\n       $114 = $110;\n       if ($113) {\n        $1365 = $1368;$1366 = $110;$1367 = $111;$93 = $114;$row$043$i = $108;\n       } else {\n        $1364 = $1368;\n        break L48;\n       }\n      }\n      $115 = ___cxa_find_matching_catch_2()|0;\n      $116 = tempRet0;\n      $117 = HEAP32[$new_data$i24>>2]|0;\n      $118 = ($117|0)==(0|0);\n      if ($118) {\n       ___resumeException($115|0);\n       // unreachable;\n      }\n      $119 = HEAP32[$82>>2]|0;\n      $120 = ($119|0)==($117|0);\n      if ($120) {\n       $130 = $117;\n      } else {\n       $122 = $119;\n       while(1) {\n        $121 = ((($122)) + -12|0);\n        HEAP32[$82>>2] = $121;\n        $123 = HEAP32[$121>>2]|0;\n        $124 = ($123|0)==(0|0);\n        if ($124) {\n         $125 = $121;\n        } else {\n         $127 = ((($122)) + -8|0);\n         $128 = HEAP32[$127>>2]|0;\n         $129 = ($128|0)==($123|0);\n         if (!($129)) {\n          HEAP32[$127>>2] = $123;\n         }\n         __ZdlPv($123);\n         $$pre$i$i$i27$i = HEAP32[$82>>2]|0;\n         $125 = $$pre$i$i$i27$i;\n        }\n        $126 = ($125|0)==($117|0);\n        if ($126) {\n         break;\n        } else {\n         $122 = $125;\n        }\n       }\n       $$pre$i30$i = HEAP32[$new_data$i24>>2]|0;\n       $130 = $$pre$i30$i;\n      }\n      __ZdlPv($130);\n      ___resumeException($115|0);\n      // unreachable;\n     }\n    } while(0);\n    $88 = ($74|0)>(0);\n    L76: do {\n     if ($88) {\n      $89 = ($80|0)>(0);\n      $90 = (($80) + -1)|0;\n      $91 = (($75) + -1)|0;\n      $140 = $1364;$row1$039$i = 0;\n      while(1) {\n       $131 = $row1$039$i << 1;\n       if ($89) {\n        $132 = $131 | 1;\n        $133 = HEAP32[$70>>2]|0;\n        $134 = (($133) + (($row1$039$i*12)|0)|0);\n        $135 = ($row1$039$i|0)>(0);\n        $136 = (($row1$039$i) + -1)|0;\n        $137 = ($row1$039$i|0)<($91|0);\n        $138 = (($row1$039$i) + 1)|0;\n        $$not$i = $135 ^ 1;\n        $$not5$i = $137 ^ 1;\n        $139 = (($140) + (($132*12)|0)|0);\n        $141 = (($140) + (($131*12)|0)|0);\n        $col$037$i = 0;\n        while(1) {\n         $143 = HEAP32[$134>>2]|0;\n         $144 = (($143) + ($col$037$i)|0);\n         $145 = HEAP8[$144>>0]|0;\n         $146 = ($145<<24>>24)==(0);\n         do {\n          if ($146) {\n           $147 = ($col$037$i|0)>(0);\n           if ($147) {\n            $148 = (($col$037$i) + -1)|0;\n            $149 = (($143) + ($148)|0);\n            $150 = HEAP8[$149>>0]|0;\n            $151 = ($150<<24>>24)==(0);\n            $198 = $151;\n           } else {\n            $198 = 0;\n           }\n           if ($135) {\n            $152 = HEAP32[$70>>2]|0;\n            $153 = (($152) + (($136*12)|0)|0);\n            $154 = HEAP32[$153>>2]|0;\n            $155 = (($154) + ($col$037$i)|0);\n            $156 = HEAP8[$155>>0]|0;\n            $157 = ($156<<24>>24)==(0);\n            $197 = $157;\n           } else {\n            $197 = 0;\n           }\n           $158 = ($col$037$i|0)<($90|0);\n           if ($158) {\n            $159 = (($col$037$i) + 1)|0;\n            $160 = (($143) + ($159)|0);\n            $161 = HEAP8[$160>>0]|0;\n            $162 = ($161<<24>>24)==(0);\n            $205 = $162;\n           } else {\n            $205 = 0;\n           }\n           if ($137) {\n            $163 = HEAP32[$70>>2]|0;\n            $164 = (($163) + (($138*12)|0)|0);\n            $165 = HEAP32[$164>>2]|0;\n            $166 = (($165) + ($col$037$i)|0);\n            $167 = HEAP8[$166>>0]|0;\n            $168 = ($167<<24>>24)==(0);\n            $211 = $168;\n           } else {\n            $211 = 0;\n           }\n           $or$cond$i28 = $135 & $147;\n           if ($or$cond$i28) {\n            $169 = HEAP32[$70>>2]|0;\n            $170 = (($col$037$i) + -1)|0;\n            $171 = (($169) + (($136*12)|0)|0);\n            $172 = HEAP32[$171>>2]|0;\n            $173 = (($172) + ($170)|0);\n            $174 = HEAP8[$173>>0]|0;\n            $175 = ($174<<24>>24)==(0);\n            $199 = $175;\n           } else {\n            $199 = 0;\n           }\n           $$not4$i = $158 ^ 1;\n           $brmerge$i = $$not$i | $$not4$i;\n           if ($brmerge$i) {\n            $201 = 0;\n           } else {\n            $176 = HEAP32[$70>>2]|0;\n            $177 = (($col$037$i) + 1)|0;\n            $178 = (($176) + (($136*12)|0)|0);\n            $179 = HEAP32[$178>>2]|0;\n            $180 = (($179) + ($177)|0);\n            $181 = HEAP8[$180>>0]|0;\n            $182 = ($181<<24>>24)==(0);\n            $201 = $182;\n           }\n           $or$cond3$i = $137 & $147;\n           if ($or$cond3$i) {\n            $183 = HEAP32[$70>>2]|0;\n            $184 = (($col$037$i) + -1)|0;\n            $185 = (($183) + (($138*12)|0)|0);\n            $186 = HEAP32[$185>>2]|0;\n            $187 = (($186) + ($184)|0);\n            $188 = HEAP8[$187>>0]|0;\n            $189 = ($188<<24>>24)==(0);\n            $200 = $189;\n           } else {\n            $200 = 0;\n           }\n           $brmerge7$i = $$not5$i | $$not4$i;\n           if ($brmerge7$i) {\n            $206 = 0;\n           } else {\n            $190 = HEAP32[$70>>2]|0;\n            $191 = (($col$037$i) + 1)|0;\n            $192 = (($190) + (($138*12)|0)|0);\n            $193 = HEAP32[$192>>2]|0;\n            $194 = (($193) + ($191)|0);\n            $195 = HEAP8[$194>>0]|0;\n            $196 = ($195<<24>>24)==(0);\n            $206 = $196;\n           }\n           $brmerge8$i = $198 | $197;\n           $brmerge9$i = $brmerge8$i | $199;\n           $brmerge9$not$i = $brmerge9$i ^ 1;\n           $brmerge10$i = $201 | $200;\n           $or$cond20$i = $brmerge10$i & $brmerge9$not$i;\n           if (!($or$cond20$i)) {\n            $202 = $col$037$i << 1;\n            $203 = HEAP32[$141>>2]|0;\n            $204 = (($203) + ($202)|0);\n            HEAP8[$204>>0] = 0;\n           }\n           $brmerge11$i = $197 | $205;\n           $brmerge12$i = $brmerge11$i | $201;\n           $brmerge12$not$i = $brmerge12$i ^ 1;\n           $brmerge13$i = $199 | $206;\n           $or$cond21$i = $brmerge13$i & $brmerge12$not$i;\n           if (!($or$cond21$i)) {\n            $207 = $col$037$i << 1;\n            $208 = $207 | 1;\n            $209 = HEAP32[$141>>2]|0;\n            $210 = (($209) + ($208)|0);\n            HEAP8[$210>>0] = 0;\n           }\n           $brmerge14$i = $198 | $211;\n           $brmerge15$i = $brmerge14$i | $200;\n           $brmerge15$not$i = $brmerge15$i ^ 1;\n           $or$cond22$i = $brmerge13$i & $brmerge15$not$i;\n           if (!($or$cond22$i)) {\n            $212 = $col$037$i << 1;\n            $213 = HEAP32[$139>>2]|0;\n            $214 = (($213) + ($212)|0);\n            HEAP8[$214>>0] = 0;\n           }\n           $brmerge17$i = $205 | $211;\n           $brmerge18$i = $brmerge17$i | $206;\n           $brmerge18$not$i = $brmerge18$i ^ 1;\n           $or$cond23$i = $brmerge10$i & $brmerge18$not$i;\n           if ($or$cond23$i) {\n            break;\n           }\n           $215 = $col$037$i << 1;\n           $216 = $215 | 1;\n           $217 = HEAP32[$139>>2]|0;\n           $218 = (($217) + ($216)|0);\n           HEAP8[$218>>0] = 0;\n          }\n         } while(0);\n         $219 = (($col$037$i) + 1)|0;\n         $exitcond$i = ($219|0)==($80|0);\n         if ($exitcond$i) {\n          $$pre$phi$i27Z2D = $138;\n          break;\n         } else {\n          $col$037$i = $219;\n         }\n        }\n       } else {\n        $$pre49$i = (($row1$039$i) + 1)|0;\n        $$pre$phi$i27Z2D = $$pre49$i;\n       }\n       $142 = ($$pre$phi$i27Z2D|0)<($75|0);\n       if (!($142)) {\n        break L76;\n       }\n       $$pre48$i = HEAP32[$new_data$i24>>2]|0;\n       $140 = $$pre48$i;$row1$039$i = $$pre$phi$i27Z2D;\n      }\n     }\n    } while(0);\n    $220 = HEAP32[$70>>2]|0;\n    $221 = HEAP32[$new_data$i24>>2]|0;\n    HEAP32[$70>>2] = $221;\n    HEAP32[$new_data$i24>>2] = $220;\n    $222 = HEAP32[$71>>2]|0;\n    $223 = HEAP32[$82>>2]|0;\n    HEAP32[$71>>2] = $223;\n    HEAP32[$82>>2] = $222;\n    $224 = ((($this)) + 24|0);\n    $225 = ((($new_data$i24)) + 8|0);\n    $226 = HEAP32[$224>>2]|0;\n    $227 = HEAP32[$225>>2]|0;\n    HEAP32[$224>>2] = $227;\n    HEAP32[$225>>2] = $226;\n    $228 = $220;\n    $229 = ($220|0)==(0);\n    $230 = $222;\n    if (!($229)) {\n     $231 = $220;\n     $232 = ($230|0)==($228|0);\n     if ($232) {\n      $242 = $231;\n     } else {\n      $234 = $230;\n      while(1) {\n       $233 = ((($234)) + -12|0);\n       HEAP32[$82>>2] = $233;\n       $235 = HEAP32[$233>>2]|0;\n       $236 = ($235|0)==(0|0);\n       if ($236) {\n        $237 = $233;\n       } else {\n        $239 = ((($234)) + -8|0);\n        $240 = HEAP32[$239>>2]|0;\n        $241 = ($240|0)==($235|0);\n        if (!($241)) {\n         HEAP32[$239>>2] = $235;\n        }\n        __ZdlPv($235);\n        $$pre$i$i$i$i32 = HEAP32[$82>>2]|0;\n        $237 = $$pre$i$i$i$i32;\n       }\n       $238 = ($237|0)==($228|0);\n       if ($238) {\n        break;\n       } else {\n        $234 = $237;\n       }\n      }\n      $$pre$i$i35 = HEAP32[$new_data$i24>>2]|0;\n      $242 = $$pre$i$i35;\n     }\n     __ZdlPv($242);\n    }\n    $243 = (($n|0) / 2)&-1;\n    $$01 = $243;\n   } else {\n    $244 = (($n|0) % 3)&-1;\n    $245 = ($244|0)==(0);\n    if (!($245)) {\n     $$01150 = $n;\n     label = 163;\n     break;\n    }\n    $246 = ((($this)) + 16|0);\n    $247 = ((($this)) + 20|0);\n    $248 = HEAP32[$247>>2]|0;\n    $249 = HEAP32[$246>>2]|0;\n    $250 = (($248) - ($249))|0;\n    $251 = (($250|0) / 12)&-1;\n    $$cast$i40 = $249;\n    $252 = ((($$cast$i40)) + 4|0);\n    $253 = HEAP32[$252>>2]|0;\n    $254 = $249;\n    $255 = HEAP32[$254>>2]|0;\n    $256 = (($253) - ($255))|0;\n    $257 = ($251*3)|0;\n    __ZNSt3__16vectorINS0_IhNS_9allocatorIhEEEENS1_IS3_EEEC2Ej($new_data$i39,$257);\n    $258 = ((($new_data$i39)) + 4|0);\n    $259 = HEAP32[$258>>2]|0;\n    $260 = HEAP32[$new_data$i39>>2]|0;\n    $261 = ($259|0)==($260|0);\n    $262 = $260;\n    L141: do {\n     if ($261) {\n      $1369 = $262;\n     } else {\n      $263 = ($256*3)|0;\n      $1370 = $262;$1371 = $260;$1372 = $259;$269 = $262;$row$078$i = 0;\n      while(1) {\n       $268 = (($269) + (($row$078$i*12)|0)|0);\n       HEAP8[$1>>0] = 1;\n       $270 = (((($269) + (($row$078$i*12)|0)|0)) + 4|0);\n       $271 = HEAP32[$270>>2]|0;\n       $272 = HEAP32[$268>>2]|0;\n       $273 = (($271) - ($272))|0;\n       $274 = ($263>>>0)>($273>>>0);\n       $275 = $272;\n       $276 = $271;\n       if ($274) {\n        $277 = (($263) - ($273))|0;\n        __THREW__ = 0;\n        invoke_viii(51,($268|0),($277|0),($1|0));\n        $278 = __THREW__; __THREW__ = 0;\n        $279 = $278&1;\n        if ($279) {\n         break;\n        }\n        $$pre$i42 = HEAP32[$258>>2]|0;\n        $$pre82$i = HEAP32[$new_data$i39>>2]|0;\n        $280 = $$pre82$i;\n        $1373 = $280;$286 = $$pre82$i;$287 = $$pre$i42;\n       } else {\n        $281 = ($263>>>0)<($273>>>0);\n        if ($281) {\n         $282 = (($275) + ($263)|0);\n         $283 = ($276|0)==($282|0);\n         if ($283) {\n          $1373 = $1370;$286 = $1371;$287 = $1372;\n         } else {\n          HEAP32[$270>>2] = $282;\n          $1373 = $1370;$286 = $1371;$287 = $1372;\n         }\n        } else {\n         $1373 = $1370;$286 = $1371;$287 = $1372;\n        }\n       }\n       $284 = (($row$078$i) + 1)|0;\n       $285 = (($287) - ($286))|0;\n       $288 = (($285|0) / 12)&-1;\n       $289 = ($284>>>0)<($288>>>0);\n       $290 = $286;\n       if ($289) {\n        $1370 = $1373;$1371 = $286;$1372 = $287;$269 = $290;$row$078$i = $284;\n       } else {\n        $1369 = $1373;\n        break L141;\n       }\n      }\n      $291 = ___cxa_find_matching_catch_2()|0;\n      $292 = tempRet0;\n      $293 = HEAP32[$new_data$i39>>2]|0;\n      $294 = ($293|0)==(0|0);\n      if ($294) {\n       ___resumeException($291|0);\n       // unreachable;\n      }\n      $295 = HEAP32[$258>>2]|0;\n      $296 = ($295|0)==($293|0);\n      if ($296) {\n       $306 = $293;\n      } else {\n       $298 = $295;\n       while(1) {\n        $297 = ((($298)) + -12|0);\n        HEAP32[$258>>2] = $297;\n        $299 = HEAP32[$297>>2]|0;\n        $300 = ($299|0)==(0|0);\n        if ($300) {\n         $301 = $297;\n        } else {\n         $303 = ((($298)) + -8|0);\n         $304 = HEAP32[$303>>2]|0;\n         $305 = ($304|0)==($299|0);\n         if (!($305)) {\n          HEAP32[$303>>2] = $299;\n         }\n         __ZdlPv($299);\n         $$pre$i$i$i59$i = HEAP32[$258>>2]|0;\n         $301 = $$pre$i$i$i59$i;\n        }\n        $302 = ($301|0)==($293|0);\n        if ($302) {\n         break;\n        } else {\n         $298 = $301;\n        }\n       }\n       $$pre$i62$i = HEAP32[$new_data$i39>>2]|0;\n       $306 = $$pre$i62$i;\n      }\n      __ZdlPv($306);\n      ___resumeException($291|0);\n      // unreachable;\n     }\n    } while(0);\n    $264 = ($250|0)>(0);\n    L169: do {\n     if ($264) {\n      $265 = ($256|0)>(0);\n      $266 = (($256) + -1)|0;\n      $267 = (($251) + -1)|0;\n      $317 = $1369;$row1$074$i = 0;\n      while(1) {\n       $307 = ($row1$074$i*3)|0;\n       if ($265) {\n        $308 = (($307) + 2)|0;\n        $309 = HEAP32[$246>>2]|0;\n        $310 = (($307) + 1)|0;\n        $311 = (($309) + (($row1$074$i*12)|0)|0);\n        $312 = ($row1$074$i|0)>(0);\n        $313 = (($row1$074$i) + -1)|0;\n        $314 = ($row1$074$i|0)<($267|0);\n        $315 = (($row1$074$i) + 1)|0;\n        $$not$i47 = $312 ^ 1;\n        $$not5$i48 = $314 ^ 1;\n        $316 = (($317) + (($307*12)|0)|0);\n        $318 = (($317) + (($310*12)|0)|0);\n        $319 = (($317) + (($308*12)|0)|0);\n        $col$073$i = 0;\n        while(1) {\n         $321 = ($col$073$i*3)|0;\n         $322 = ($col$073$i|0)>(0);\n         if ($322) {\n          $323 = (($col$073$i) + -1)|0;\n          $324 = HEAP32[$311>>2]|0;\n          $325 = (($324) + ($323)|0);\n          $326 = HEAP8[$325>>0]|0;\n          $327 = ($326<<24>>24)==(0);\n          $379 = $327;\n         } else {\n          $379 = 0;\n         }\n         if ($312) {\n          $328 = HEAP32[$246>>2]|0;\n          $329 = (($328) + (($313*12)|0)|0);\n          $330 = HEAP32[$329>>2]|0;\n          $331 = (($330) + ($col$073$i)|0);\n          $332 = HEAP8[$331>>0]|0;\n          $333 = ($332<<24>>24)==(0);\n          $378 = $333;\n         } else {\n          $378 = 0;\n         }\n         $334 = ($col$073$i|0)<($266|0);\n         if ($334) {\n          $335 = (($col$073$i) + 1)|0;\n          $336 = HEAP32[$311>>2]|0;\n          $337 = (($336) + ($335)|0);\n          $338 = HEAP8[$337>>0]|0;\n          $339 = ($338<<24>>24)==(0);\n          $388 = $339;\n         } else {\n          $388 = 0;\n         }\n         if ($314) {\n          $340 = HEAP32[$246>>2]|0;\n          $341 = (($340) + (($315*12)|0)|0);\n          $342 = HEAP32[$341>>2]|0;\n          $343 = (($342) + ($col$073$i)|0);\n          $344 = HEAP8[$343>>0]|0;\n          $345 = ($344<<24>>24)==(0);\n          $398 = $345;\n         } else {\n          $398 = 0;\n         }\n         $or$cond$i52 = $312 & $322;\n         if ($or$cond$i52) {\n          $346 = HEAP32[$246>>2]|0;\n          $347 = (($col$073$i) + -1)|0;\n          $348 = (($346) + (($313*12)|0)|0);\n          $349 = HEAP32[$348>>2]|0;\n          $350 = (($349) + ($347)|0);\n          $351 = HEAP8[$350>>0]|0;\n          $352 = ($351<<24>>24)==(0);\n          $380 = $352;\n         } else {\n          $380 = 0;\n         }\n         $$not4$i53 = $334 ^ 1;\n         $brmerge$i54 = $$not$i47 | $$not4$i53;\n         if ($brmerge$i54) {\n          $382 = 0;\n         } else {\n          $353 = HEAP32[$246>>2]|0;\n          $354 = (($col$073$i) + 1)|0;\n          $355 = (($353) + (($313*12)|0)|0);\n          $356 = HEAP32[$355>>2]|0;\n          $357 = (($356) + ($354)|0);\n          $358 = HEAP8[$357>>0]|0;\n          $359 = ($358<<24>>24)==(0);\n          $382 = $359;\n         }\n         $or$cond3$i55 = $314 & $322;\n         if ($or$cond3$i55) {\n          $360 = HEAP32[$246>>2]|0;\n          $361 = (($col$073$i) + -1)|0;\n          $362 = (($360) + (($315*12)|0)|0);\n          $363 = HEAP32[$362>>2]|0;\n          $364 = (($363) + ($361)|0);\n          $365 = HEAP8[$364>>0]|0;\n          $366 = ($365<<24>>24)==(0);\n          $381 = $366;\n         } else {\n          $381 = 0;\n         }\n         $brmerge7$i56 = $$not5$i48 | $$not4$i53;\n         if ($brmerge7$i56) {\n          $389 = 0;\n         } else {\n          $367 = HEAP32[$246>>2]|0;\n          $368 = (($col$073$i) + 1)|0;\n          $369 = (($367) + (($315*12)|0)|0);\n          $370 = HEAP32[$369>>2]|0;\n          $371 = (($370) + ($368)|0);\n          $372 = HEAP8[$371>>0]|0;\n          $373 = ($372<<24>>24)==(0);\n          $389 = $373;\n         }\n         $374 = HEAP32[$311>>2]|0;\n         $375 = (($374) + ($col$073$i)|0);\n         $376 = HEAP8[$375>>0]|0;\n         $377 = ($376<<24>>24)==(0);\n         do {\n          if ($377) {\n           $brmerge8$i57 = $379 | $378;\n           $brmerge9$i58 = $brmerge8$i57 | $380;\n           $brmerge9$not$i59 = $brmerge9$i58 ^ 1;\n           $brmerge10$i60 = $382 | $381;\n           $or$cond52$i = $brmerge10$i60 & $brmerge9$not$i59;\n           if (!($or$cond52$i)) {\n            $383 = HEAP32[$316>>2]|0;\n            $384 = (($383) + ($321)|0);\n            HEAP8[$384>>0] = 0;\n           }\n           $385 = (($321) + 1)|0;\n           $386 = HEAP32[$316>>2]|0;\n           $387 = (($386) + ($385)|0);\n           HEAP8[$387>>0] = 0;\n           $brmerge11$i61 = $378 | $388;\n           $brmerge12$i62 = $brmerge11$i61 | $382;\n           $brmerge12$not$i63 = $brmerge12$i62 ^ 1;\n           $brmerge13$i64 = $380 | $389;\n           $or$cond53$i = $brmerge13$i64 & $brmerge12$not$i63;\n           $$pre85$i = (($321) + 2)|0;\n           if (!($or$cond53$i)) {\n            $390 = HEAP32[$316>>2]|0;\n            $391 = (($390) + ($$pre85$i)|0);\n            HEAP8[$391>>0] = 0;\n           }\n           $392 = HEAP32[$318>>2]|0;\n           $393 = (($392) + ($$pre85$i)|0);\n           HEAP8[$393>>0] = 0;\n           $394 = HEAP32[$318>>2]|0;\n           $395 = (($394) + ($385)|0);\n           HEAP8[$395>>0] = 0;\n           $396 = HEAP32[$318>>2]|0;\n           $397 = (($396) + ($321)|0);\n           HEAP8[$397>>0] = 0;\n           $brmerge14$i65 = $379 | $398;\n           $brmerge15$i66 = $brmerge14$i65 | $381;\n           $brmerge15$not$i67 = $brmerge15$i66 ^ 1;\n           $or$cond54$i = $brmerge13$i64 & $brmerge15$not$i67;\n           if (!($or$cond54$i)) {\n            $399 = HEAP32[$319>>2]|0;\n            $400 = (($399) + ($321)|0);\n            HEAP8[$400>>0] = 0;\n           }\n           $401 = HEAP32[$319>>2]|0;\n           $402 = (($401) + ($385)|0);\n           HEAP8[$402>>0] = 0;\n           $brmerge17$i68 = $388 | $398;\n           $brmerge18$i69 = $brmerge17$i68 | $389;\n           $brmerge18$not$i70 = $brmerge18$i69 ^ 1;\n           $or$cond55$i = $brmerge10$i60 & $brmerge18$not$i70;\n           if ($or$cond55$i) {\n            break;\n           }\n           $403 = HEAP32[$319>>2]|0;\n           $404 = (($403) + ($$pre85$i)|0);\n           HEAP8[$404>>0] = 0;\n          } else {\n           $brmerge22$demorgan$i = $379 & $378;\n           $brmerge22$i = $brmerge22$demorgan$i ^ 1;\n           $$not23$i = $380 ^ 1;\n           $brmerge24$i = $brmerge22$i | $$not23$i;\n           $brmerge27$demorgan$i = $382 & $381;\n           $or$cond69$i = $brmerge24$i | $brmerge27$demorgan$i;\n           if (!($or$cond69$i)) {\n            $405 = HEAP32[$316>>2]|0;\n            $406 = (($405) + ($321)|0);\n            HEAP8[$406>>0] = 0;\n           }\n           $brmerge30$not$i = $378 & $388;\n           $brmerge32$not$i = $brmerge30$not$i & $382;\n           $$not34$i = $389 ^ 1;\n           $brmerge35$i = $$not23$i | $$not34$i;\n           $or$cond66$i = $brmerge32$not$i & $brmerge35$i;\n           if ($or$cond66$i) {\n            $407 = (($321) + 2)|0;\n            $408 = HEAP32[$316>>2]|0;\n            $409 = (($408) + ($407)|0);\n            HEAP8[$409>>0] = 0;\n           }\n           $brmerge38$not$i = $379 & $398;\n           $brmerge40$not$i = $brmerge38$not$i & $381;\n           $or$cond67$i = $brmerge40$not$i & $brmerge35$i;\n           if ($or$cond67$i) {\n            $410 = HEAP32[$319>>2]|0;\n            $411 = (($410) + ($321)|0);\n            HEAP8[$411>>0] = 0;\n           }\n           $brmerge46$demorgan$i = $388 & $398;\n           $brmerge48$demorgan$i = $brmerge46$demorgan$i & $389;\n           $brmerge51$i = $brmerge27$demorgan$i ^ 1;\n           $or$cond68$i = $brmerge48$demorgan$i & $brmerge51$i;\n           if (!($or$cond68$i)) {\n            break;\n           }\n           $412 = (($321) + 2)|0;\n           $413 = HEAP32[$319>>2]|0;\n           $414 = (($413) + ($412)|0);\n           HEAP8[$414>>0] = 0;\n          }\n         } while(0);\n         $415 = (($col$073$i) + 1)|0;\n         $exitcond$i71 = ($415|0)==($256|0);\n         if ($exitcond$i71) {\n          $$pre$phi87$iZ2D = $315;\n          break;\n         } else {\n          $col$073$i = $415;\n         }\n        }\n       } else {\n        $$pre86$i = (($row1$074$i) + 1)|0;\n        $$pre$phi87$iZ2D = $$pre86$i;\n       }\n       $320 = ($$pre$phi87$iZ2D|0)<($251|0);\n       if (!($320)) {\n        break L169;\n       }\n       $$pre83$i = HEAP32[$new_data$i39>>2]|0;\n       $317 = $$pre83$i;$row1$074$i = $$pre$phi87$iZ2D;\n      }\n     }\n    } while(0);\n    $416 = HEAP32[$246>>2]|0;\n    $417 = HEAP32[$new_data$i39>>2]|0;\n    HEAP32[$246>>2] = $417;\n    HEAP32[$new_data$i39>>2] = $416;\n    $418 = HEAP32[$247>>2]|0;\n    $419 = HEAP32[$258>>2]|0;\n    HEAP32[$247>>2] = $419;\n    HEAP32[$258>>2] = $418;\n    $420 = ((($this)) + 24|0);\n    $421 = ((($new_data$i39)) + 8|0);\n    $422 = HEAP32[$420>>2]|0;\n    $423 = HEAP32[$421>>2]|0;\n    HEAP32[$420>>2] = $423;\n    HEAP32[$421>>2] = $422;\n    $424 = $416;\n    $425 = ($416|0)==(0);\n    $426 = $418;\n    if (!($425)) {\n     $427 = $416;\n     $428 = ($426|0)==($424|0);\n     if ($428) {\n      $438 = $427;\n     } else {\n      $430 = $426;\n      while(1) {\n       $429 = ((($430)) + -12|0);\n       HEAP32[$258>>2] = $429;\n       $431 = HEAP32[$429>>2]|0;\n       $432 = ($431|0)==(0|0);\n       if ($432) {\n        $433 = $429;\n       } else {\n        $435 = ((($430)) + -8|0);\n        $436 = HEAP32[$435>>2]|0;\n        $437 = ($436|0)==($431|0);\n        if (!($437)) {\n         HEAP32[$435>>2] = $431;\n        }\n        __ZdlPv($431);\n        $$pre$i$i$i$i75 = HEAP32[$258>>2]|0;\n        $433 = $$pre$i$i$i$i75;\n       }\n       $434 = ($433|0)==($424|0);\n       if ($434) {\n        break;\n       } else {\n        $430 = $433;\n       }\n      }\n      $$pre$i$i78 = HEAP32[$new_data$i39>>2]|0;\n      $438 = $$pre$i$i78;\n     }\n     __ZdlPv($438);\n    }\n    $439 = (($n|0) / 3)&-1;\n    $$01 = $439;\n   }\n   $440 = ($$01|0)>(1);\n   if ($440) {\n    $$01150 = $$01;\n    label = 163;\n   } else {\n    $$pre = ((($this)) + 16|0);\n    $$pre172 = ((($this)) + 20|0);\n    $$pre$phi175Z2D = $$pre172;$$pre$phi177Z2D = $$pre;$$pre$phi179Z2D = $$pre;\n   }\n  } else {\n   $$01150 = $n;\n   label = 163;\n  }\n } while(0);\n L245: do {\n  if ((label|0) == 163) {\n   $441 = ((($this)) + 16|0);\n   $442 = ((($this)) + 20|0);\n   $443 = HEAP32[$442>>2]|0;\n   $444 = HEAP32[$441>>2]|0;\n   $445 = (($443) - ($444))|0;\n   $446 = (($445|0) / 12)&-1;\n   $$cast$i83 = $444;\n   $447 = ((($$cast$i83)) + 4|0);\n   $448 = HEAP32[$447>>2]|0;\n   $449 = $444;\n   $450 = HEAP32[$449>>2]|0;\n   $451 = (($448) - ($450))|0;\n   HEAP32[$new_data$i82>>2] = 0;\n   $452 = ((($new_data$i82)) + 4|0);\n   HEAP32[$452>>2] = 0;\n   $453 = ((($new_data$i82)) + 8|0);\n   HEAP32[$453>>2] = 0;\n   $454 = Math_imul($446, $$01150)|0;\n   __THREW__ = 0;\n   invoke_vii(52,($new_data$i82|0),($454|0));\n   $455 = __THREW__; __THREW__ = 0;\n   $456 = $455&1;\n   L247: do {\n    if ($456) {\n     $464 = ___cxa_find_matching_catch_2()|0;\n     $465 = tempRet0;\n     $eh$lpad$body$sink$i$index6Z2D = $465;$eh$lpad$body$sink$i$indexZ2D = $464;\n    } else {\n     $457 = ($445|0)>(0);\n     L250: do {\n      if ($457) {\n       $458 = ((($0)) + 4|0);\n       $459 = ((($0)) + 8|0);\n       $460 = ((($new_data$i82)) + 8|0);\n       $461 = ($451|0)>(0);\n       $row$043$i86 = 0;\n       L252: while(1) {\n        $466 = HEAP32[$441>>2]|0;\n        HEAP32[$0>>2] = 0;\n        HEAP32[$458>>2] = 0;\n        HEAP32[$459>>2] = 0;\n        $467 = HEAP32[$452>>2]|0;\n        $468 = HEAP32[$460>>2]|0;\n        $469 = ($467|0)==($468|0);\n        if ($469) {\n         __THREW__ = 0;\n         invoke_vii(53,($new_data$i82|0),($0|0));\n         $473 = __THREW__; __THREW__ = 0;\n         $474 = $473&1;\n         if ($474) {\n          label = 190;\n          break;\n         }\n        } else {\n         HEAP32[$467>>2] = 0;\n         $470 = ((($467)) + 4|0);\n         HEAP32[$470>>2] = 0;\n         $471 = ((($467)) + 8|0);\n         HEAP32[$471>>2] = 0;\n         $472 = ((($467)) + 12|0);\n         HEAP32[$452>>2] = $472;\n        }\n        if ($461) {\n         $475 = (($466) + (($row$043$i86*12)|0)|0);\n         $col$038$us$i = 0;\n         while(1) {\n          $476 = HEAP32[$475>>2]|0;\n          $477 = (($476) + ($col$038$us$i)|0);\n          $478 = HEAP8[$477>>0]|0;\n          $i$037$us$i = 0;\n          while(1) {\n           $479 = HEAP32[$452>>2]|0;\n           $480 = ((($479)) + -12|0);\n           $481 = ((($479)) + -8|0);\n           $482 = HEAP32[$481>>2]|0;\n           $483 = ((($479)) + -4|0);\n           $484 = HEAP32[$483>>2]|0;\n           $485 = ($482|0)==($484|0);\n           $486 = $484;\n           if ($485) {\n            $489 = $482;\n            $490 = HEAP32[$480>>2]|0;\n            $491 = (($489) - ($490))|0;\n            $492 = (($491) + 1)|0;\n            $493 = ($492|0)<(0);\n            if ($493) {\n             __THREW__ = 0;\n             invoke_vi(46,($480|0));\n             $494 = __THREW__; __THREW__ = 0;\n             $495 = $494&1;\n             if ($495) {\n              label = 189;\n              break L252;\n             }\n             $$pre$i$i$us$i = HEAP32[$480>>2]|0;\n             $$pre$i27$us$i = HEAP32[$483>>2]|0;\n             $$in$i$i$us$i = $$pre$i$i$us$i;$$pre$phi$i$us$iZ2D = $483;$498 = $$pre$i27$us$i;\n            } else {\n             $$in$i$i$us$i = $490;$$pre$phi$i$us$iZ2D = $483;$498 = $486;\n            }\n            $496 = $$in$i$i$us$i;\n            $497 = (($498) - ($$in$i$i$us$i))|0;\n            $499 = ($497>>>0)<(1073741823);\n            if ($499) {\n             $502 = $497 << 1;\n             $503 = ($502>>>0)<($492>>>0);\n             $504 = $503 ? $492 : $502;\n             $505 = HEAP32[$481>>2]|0;\n             $506 = (($505) - ($$in$i$i$us$i))|0;\n             $507 = ($504|0)==(0);\n             if ($507) {\n              $$0$i2$i$i$us$i = 0;$512 = 0;$513 = $506;$519 = $505;\n             } else {\n              $$0$i1$i$i$us$i = $504;$1374 = $505;$1375 = $506;\n              label = 184;\n             }\n            } else {\n             $500 = HEAP32[$481>>2]|0;\n             $501 = (($500) - ($$in$i$i$us$i))|0;\n             $$0$i1$i$i$us$i = 2147483647;$1374 = $500;$1375 = $501;\n             label = 184;\n            }\n            if ((label|0) == 184) {\n             label = 0;\n             __THREW__ = 0;\n             $508 = (invoke_ii(29,($$0$i1$i$i$us$i|0))|0);\n             $509 = __THREW__; __THREW__ = 0;\n             $510 = $509&1;\n             if ($510) {\n              label = 189;\n              break L252;\n             } else {\n              $$0$i2$i$i$us$i = $$0$i1$i$i$us$i;$512 = $508;$513 = $1375;$519 = $1374;\n             }\n            }\n            $511 = (($512) + ($513)|0);\n            $514 = (($512) + ($$0$i2$i$i$us$i)|0);\n            $515 = $514;\n            HEAP8[$511>>0] = $478;\n            $516 = ((($511)) + 1|0);\n            $517 = $516;\n            $518 = (($519) - ($$in$i$i$us$i))|0;\n            $520 = (0 - ($518))|0;\n            $521 = (($511) + ($520)|0);\n            $522 = $521;\n            _memcpy(($521|0),($496|0),($518|0))|0;\n            HEAP32[$480>>2] = $522;\n            HEAP32[$481>>2] = $517;\n            HEAP32[$$pre$phi$i$us$iZ2D>>2] = $515;\n            $523 = ($$in$i$i$us$i|0)==(0);\n            if (!($523)) {\n             __ZdlPv($496);\n            }\n           } else {\n            HEAP8[$482>>0] = $478;\n            $487 = HEAP32[$481>>2]|0;\n            $488 = ((($487)) + 1|0);\n            HEAP32[$481>>2] = $488;\n           }\n           $524 = (($i$037$us$i) + 1)|0;\n           $525 = ($524|0)<($$01150|0);\n           if ($525) {\n            $i$037$us$i = $524;\n           } else {\n            break;\n           }\n          }\n          $526 = (($col$038$us$i) + 1)|0;\n          $527 = ($526|0)<($451|0);\n          if ($527) {\n           $col$038$us$i = $526;\n          } else {\n           $i1$040$i = 1;\n           break;\n          }\n         }\n        } else {\n         $i1$040$i = 1;\n        }\n        while(1) {\n         $534 = HEAP32[$452>>2]|0;\n         $535 = ((($534)) + -12|0);\n         $536 = HEAP32[$460>>2]|0;\n         $537 = ($534|0)==($536|0);\n         if ($537) {\n          __THREW__ = 0;\n          invoke_vii(53,($new_data$i82|0),($535|0));\n          $570 = __THREW__; __THREW__ = 0;\n          $571 = $570&1;\n          if ($571) {\n           label = 167;\n           break L252;\n          }\n         } else {\n          HEAP32[$534>>2] = 0;\n          $538 = ((($534)) + 4|0);\n          HEAP32[$538>>2] = 0;\n          $539 = ((($534)) + 8|0);\n          HEAP32[$539>>2] = 0;\n          $540 = ((($534)) + -8|0);\n          $541 = HEAP32[$540>>2]|0;\n          $542 = HEAP32[$535>>2]|0;\n          $543 = (($541) - ($542))|0;\n          $544 = ($541|0)==($542|0);\n          if (!($544)) {\n           $545 = ($543|0)<(0);\n           if ($545) {\n            __THREW__ = 0;\n            invoke_vi(46,($534|0));\n            $546 = __THREW__; __THREW__ = 0;\n            $547 = $546&1;\n            if ($547) {\n             $$lcssa212 = $534;$$lcssa213 = $538;\n             label = 199;\n             break L252;\n            }\n           }\n           __THREW__ = 0;\n           $548 = (invoke_ii(29,($543|0))|0);\n           $549 = __THREW__; __THREW__ = 0;\n           $550 = $549&1;\n           if ($550) {\n            $$lcssa212 = $534;$$lcssa213 = $538;\n            label = 199;\n            break L252;\n           }\n           HEAP32[$538>>2] = $548;\n           HEAP32[$534>>2] = $548;\n           $551 = (($548) + ($543)|0);\n           $552 = ((($534)) + 8|0);\n           HEAP32[$552>>2] = $551;\n           $553 = HEAP32[$535>>2]|0;\n           $554 = HEAP32[$540>>2]|0;\n           $555 = ($553|0)==($554|0);\n           if (!($555)) {\n            $$01$i$i$i$i$i = $553;$557 = $548;\n            while(1) {\n             $556 = HEAP8[$$01$i$i$i$i$i>>0]|0;\n             HEAP8[$557>>0] = $556;\n             $558 = HEAP32[$538>>2]|0;\n             $559 = ((($558)) + 1|0);\n             HEAP32[$538>>2] = $559;\n             $560 = ((($$01$i$i$i$i$i)) + 1|0);\n             $561 = ($560|0)==($554|0);\n             if ($561) {\n              break;\n             } else {\n              $$01$i$i$i$i$i = $560;$557 = $559;\n             }\n            }\n           }\n          }\n          $568 = HEAP32[$452>>2]|0;\n          $569 = ((($568)) + 12|0);\n          HEAP32[$452>>2] = $569;\n         }\n         $572 = (($i1$040$i) + 1)|0;\n         $573 = ($572|0)<($$01150|0);\n         if ($573) {\n          $i1$040$i = $572;\n         } else {\n          break;\n         }\n        }\n        $532 = (($row$043$i86) + 1)|0;\n        $533 = ($532|0)<($446|0);\n        if ($533) {\n         $row$043$i86 = $532;\n        } else {\n         $$pre$phi51$iZ2D = $460;\n         break L250;\n        }\n       }\n       if ((label|0) == 167) {\n        $462 = ___cxa_find_matching_catch_2()|0;\n        $463 = tempRet0;\n        $eh$lpad$body$sink$i$index6Z2D = $463;$eh$lpad$body$sink$i$indexZ2D = $462;\n        break L247;\n       }\n       else if ((label|0) == 189) {\n        $528 = ___cxa_find_matching_catch_2()|0;\n        $529 = tempRet0;\n        $eh$lpad$body$sink$i$index6Z2D = $529;$eh$lpad$body$sink$i$indexZ2D ="
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.4970703125,
          "content": "{\n  \"name\": \"ocrad.js\",\n  \"version\": \"0.1.0\",\n  \"description\": \"OCR in JavaScript\",\n  \"keywords\": [\"ocr\"],\n  \"homepage\": \"https://github.com/antimatter15/ocrad.js\",\n  \"bugs\": {\n    \"url\": \"https://github.com/antimatter15/ocrad.js/issues\",\n    \"email\": \"antimatter15@gmail.com\"\n  },\n  \"license\": \"GPL-3.0\",\n  \"author\": {\n    \"name\": \"Kevin Kwok\",\n    \"email\": \"antimatter15@gmail.com\"\n  },\n  \"main\": \"ocrad\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/antimatter15/ocrad.js.git\"\n  }\n}\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "worker.js",
          "type": "blob",
          "size": 0.0791015625,
          "content": "importScripts('ocrad.js')\nonmessage = function(e){\n\tpostMessage(OCRAD(e.data))\n}\n"
        }
      ]
    }
  ]
}