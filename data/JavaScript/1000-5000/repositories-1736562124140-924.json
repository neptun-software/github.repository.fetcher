{
  "metadata": {
    "timestamp": 1736562124140,
    "page": 924,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "paperwm/PaperWM",
      "stars": 3132,
      "defaultBranch": "release",
      "files": [
        {
          "name": ".eslintrc.yml",
          "type": "blob",
          "size": 7.1220703125,
          "content": "---\n# Adapted from \"GNOME Project\"'s `eslintrc-gjs.yml` found at:\n# https://gitlab.gnome.org/GNOME/gnome-shell-extensions/-/blob/main/lint/eslintrc-gjs.yml\n#\n# SPDX-License-Identifier: MIT OR LGPL-2.0-or-later\n# SPDX-FileCopyrightText: 2018 Claudio André <claudioandre.br@gmail.com>\nenv:\n  es2021: true\nextends: 'eslint:recommended'\n# plugins:\n#    - jsdoc\nrules:\n  array-bracket-newline:\n    - error\n    - consistent\n  array-bracket-spacing:\n    - error\n    - never\n  array-callback-return: error\n  arrow-parens:\n    - error\n    - as-needed\n  arrow-spacing: error\n  block-scoped-var: error\n  block-spacing: error\n  #brace-style: error\n  # Waiting for this to have matured a bit in eslint\n  # camelcase:\n  #   - error\n  #   - properties: never\n  #     allow: [^vfunc_, ^on_, _instance_init]\n  comma-dangle:\n    - error\n    - arrays: always-multiline\n      objects: always-multiline\n      functions: never\n  comma-spacing:\n    - error\n    - before: false\n      after: true\n  comma-style:\n    - error\n    - last\n  computed-property-spacing: error\n    #curly:\n    #    - error\n    #    - multi-or-nest\n    #    #  - consistent\n  dot-location:\n    - error\n    - property\n  eol-last: error\n  eqeqeq: error\n  func-call-spacing: error\n  func-name-matching: error\n  func-style:\n    - error\n    - declaration\n    - allowArrowFunctions: true\n  indent:\n    - error\n    - 4\n    - ignoredNodes:\n      # Allow not indenting the body of GObject.registerClass, since in the\n      # future it's intended to be a decorator\n      - 'CallExpression[callee.object.name=GObject][callee.property.name=registerClass] > ClassExpression:first-child'\n      # Allow dedenting chained member expressions\n      MemberExpression: 'off'\n  # # disabling jsdoc while as plugin jsdoc is disabled (have always had issues with plugin)\n  # jsdoc/check-alignment: error\n  # jsdoc/check-param-names: error\n  # jsdoc/check-tag-names: error\n  # jsdoc/check-types: error\n  # jsdoc/implements-on-classes: error\n  # jsdoc/tag-lines:\n  #   - error\n  #   - any\n  #   - startLines: 1\n  # jsdoc/require-jsdoc: error\n  # jsdoc/require-param: error\n  # jsdoc/require-param-description: error\n  # jsdoc/require-param-name: error\n  # jsdoc/require-param-type: error\n  key-spacing:\n    - error\n    - beforeColon: false\n      afterColon: true\n  keyword-spacing:\n    - error\n    - before: true\n      after: true\n  linebreak-style:\n    - error\n    - unix\n  lines-between-class-members:\n    - error\n    - always\n    - exceptAfterSingleLine: true\n  max-nested-callbacks: error\n  max-statements-per-line: error\n  new-parens: error\n  no-array-constructor: error\n  no-await-in-loop: error\n  no-caller: error\n  no-constant-condition:\n    - error\n    - checkLoops: false\n  no-div-regex: error\n  no-empty:\n    - error\n    - allowEmptyCatch: true\n  no-extra-bind: error\n  no-extra-parens:\n    - error\n    - all\n    - conditionalAssign: false\n      nestedBinaryExpressions: false\n      returnAssign: false\n  no-implicit-coercion:\n    - error\n    - allow:\n      - '!!'\n  # no-invalid-this: error\n  no-iterator: error\n  no-label-var: error\n  no-lonely-if: error\n  no-loop-func: error\n  no-nested-ternary: error\n  no-new-object: error\n  no-new-wrappers: error\n  no-octal-escape: error\n  no-proto: error\n  no-prototype-builtins: 'off'\n  no-restricted-globals: [error, window]\n  no-restricted-properties:\n    - error\n    - object: imports\n      property: format\n      message: Use template strings\n    - object: pkg\n      property: initFormat\n      message: Use template strings\n    - object: Lang\n      property: copyProperties\n      message: Use Object.assign()\n    - object: Lang\n      property: bind\n      message: Use arrow notation or Function.prototype.bind()\n    - object: Lang\n      property: Class\n      message: Use ES6 classes\n  no-restricted-syntax:\n    - error\n    - selector: >-\n        MethodDefinition[key.name=\"_init\"] >\n        FunctionExpression[params.length=1] >\n        BlockStatement[body.length=1]\n        CallExpression[arguments.length=1][callee.object.type=\"Super\"][callee.property.name=\"_init\"] >\n        Identifier:first-child\n      message: _init() that only calls super._init() is unnecessary\n    - selector: >-\n        MethodDefinition[key.name=\"_init\"] >\n        FunctionExpression[params.length=0] >\n        BlockStatement[body.length=1]\n        CallExpression[arguments.length=0][callee.object.type=\"Super\"][callee.property.name=\"_init\"]\n      message: _init() that only calls super._init() is unnecessary\n    - selector: BinaryExpression[operator=\"instanceof\"][right.name=\"Array\"]\n      message: Use Array.isArray()\n  no-return-assign: error\n  no-return-await: error\n  no-self-compare: error\n  no-shadow-restricted-names: error\n  no-spaced-func: error\n  no-tabs: error\n  no-template-curly-in-string: error\n  no-throw-literal: error\n  no-trailing-spaces: error\n  no-undef-init: error\n  no-unneeded-ternary: error\n  #no-unused-expressions: error\n  no-unused-vars:\n    - error\n    # Vars use a suffix _ instead of a prefix because of file-scope private vars\n    - varsIgnorePattern: (^unused|_$)\n      argsIgnorePattern: ^(unused|_)\n  no-useless-call: error\n  no-useless-computed-key: error\n  no-useless-concat: error\n  no-useless-constructor: error\n  no-useless-rename: error\n  no-useless-return: error\n  no-whitespace-before-property: error\n  no-with: error\n  nonblock-statement-body-position:\n    - error\n    - below\n  object-curly-newline:\n    - error\n    - consistent: true\n      multiline: true\n  #object-curly-spacing: error\n  object-curly-spacing: \n    - error\n    - always\n  object-shorthand: error\n  operator-assignment: error\n  operator-linebreak: error\n  padded-blocks:\n    - error\n    - never\n  # These may be a bit controversial, we can try them out and enable them later\n  # prefer-const: error\n  # prefer-destructuring: error\n  prefer-numeric-literals: error\n  prefer-promise-reject-errors: error\n  prefer-rest-params: error\n  prefer-spread: error\n  prefer-template: error\n    #quotes:\n    #  - error\n    #  - single\n    #  - avoidEscape: true\n  require-await: error\n  rest-spread-spacing: error\n  semi:\n    - error\n    - always\n  semi-spacing:\n    - error\n    - before: false\n      after: true\n  semi-style: error\n  space-before-blocks: error\n    #space-before-function-paren:\n    #  - error\n    #  - named: never\n    #    # for `function ()` and `async () =>`, preserve space around keywords\n    #    anonymous: always\n    #    asyncArrow: always\n    #space-in-parens: error\n  space-infix-ops:\n    - error\n    - int32Hint: false\n  space-unary-ops: error\n  spaced-comment: error\n  switch-colon-spacing: error\n  symbol-description: error\n  template-curly-spacing: error\n  template-tag-spacing: error\n  unicode-bom: error\n  wrap-iife:\n    - error\n    - inside\n  yield-star-spacing: error\n  yoda: error\nsettings:\n  jsdoc:\n    mode: typescript\nglobals:\n  ARGV: readonly\n  Debugger: readonly\n  GIRepositoryGType: readonly\n  global: readonly\n  globalThis: readonly\n  imports: readonly\n  Intl: readonly\n  log: readonly\n  logError: readonly\n  print: readonly\n  printerr: readonly\n  window: readonly\n  TextEncoder: readonly\n  TextDecoder: readonly\n  console: readonly\n  setTimeout: readonly\n  setInterval: readonly\n  clearTimeout: readonly\n  clearInterval: readonly\nparserOptions:\n  ecmaVersion: 2022\n  sourceType: module\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1875,
          "content": ".config\nTAGS\n\n# any generated extension zip\npaperwm@paperwm.github.com.zip\n\n# eslint support files\nnode_modules/\npackage.json\npackage-lock.json\n\n# generated disk image for test VM\nnixos.qcow2\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 3.5146484375,
          "content": "# History / Admins\n\nPaperWM was originally written by [@hedning] and [@olejorgenb]. However, they became busy with other things and stepped away from active development. They may return some day, and you might see them around every couple months, but don't ping them and expect a response.\n\n[@smichel17] [joined](https://github.com/paperwm/PaperWM/issues/407) to facilitate transitioning PaperWM to a community project. Unfortunately, he's *also* too busy (and doesn't know Gnome Shell's code base well enough) to take over development directly. So, his role is basically to be a trustworthy person (he hopes!) to manage adding more maintainers. Including writing this document (👋).\n\n[@jtaala] stepped into PaperWM development in late 2022, having discovered PaperWM around that time. He came from i3wm and quickly fell in love with PaperWM and the concept of scrollable tiling window managers. Jay's a PaperWM maintainer, but is currently [stepping back](https://github.com/paperwm/PaperWM/issues/980). He has been keeping PaperWM up to date (including releases and maintaining/submitting PaperWM's [EGO](https://extensions.gnome.org/extension/6099/paperwm/) versions), fixing issues, developing & implementing requested features, and just trying to make PaperWM a reliable window manager that stays awesome and is loved by its users.  He was active until about November 2024.\n\n[@thesola10] joined PaperWM development in early 2023. Like Jay, he was quickly enamored by the scrollable tiling paradigm. He started contributing features related to touch screens and multiple displays, as this matches his current workflow. Karim is a PaperWM maintainer, focused on keeping PaperWM up to date, and handling pull requests.\n\n## Community Transition\n\n### Concerns\n\n- **Focus** — without one person to enforce the vision of what the software should be, it's easy for it to try and be many different things. End result: software that is inconsistent and difficult to use.\n    - Same thing for the code base. End result: difficult to maintain.\n- **Trust** — obviously we only want to give permissions to people who we trust not to push malicious (or otherwise bad) code. However, it's difficult for someone to prove they are trustworthy without trusting them first.\n- **Momentum** — trying to avoid pitfalls in the first two areas can lead to no actual development progress. For example, long deliberation trying to reach consensus, or a cumbersome contribution process that drives away potential maintainers.\n\n### Plan\n\nTo balance those issues, the plan is something like this (details may change):\n\n- Give out write access to the repo fairly easily. If someone makes a number of small contributions, or 1-2 large contributions, invite them as a Collaborator.\n- Require all contributions to be via PR. That way it's difficult for anyone to sneak changes in without others noticing.\n- Protect branches\\*. Require 2 Collaborators to approve a PR before it's merged (so one person can't unilaterally push changes).\n    - \\*[`develop`](https://github.com/paperwm/PaperWM/tree/develop), [`release`](https://github.com/paperwm/PaperWM/tree/release), and any branch referenced in the README. Also all tags.\n    - If there are not enough active maintainers, maybe relax the 2-person requirement.\n\n### Governance\n\nIf it's not clear who will make a decision, it's the current maintainer's decision.\n\n[@hedning]: https://github.com/hedning\n[@olejorgenb]: https://github.com/olejorgenb\n[@smichel17]: https://github.com/smichel17\n[@jtaala]: https://github.com/jtaala\n[@thesola10]: https://github.com/thesola10\n"
        },
        {
          "name": "KeybindingsComboRow.ui",
          "type": "blob",
          "size": 4.2119140625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<interface>\n  <requires lib=\"gtk\" version=\"4.0\" />\n  <template class=\"ComboRow\" parent=\"GtkListBoxRow\">\n    <property name=\"selectable\">False</property>\n    <property name=\"activatable\">True</property>\n    <property name=\"focusable\">True</property>\n    <property name=\"focus-on-click\">True</property>\n\n    <property name=\"child\">\n      <object class=\"GtkStack\" id=\"stack\">\n        <child>\n          <object class=\"GtkStackPage\">\n            <property name=\"child\">\n              <object class=\"GtkBox\" id=\"shortcutPage\">\n                <property name=\"hexpand\">True</property>\n                <property name=\"spacing\">12</property>\n                <child>\n                  <object class=\"GtkShortcutLabel\" id=\"shortcutLabel\">\n                    <property name=\"disabled_text\" translatable=\"yes\">Disabled</property>\n                  </object>\n                </child>\n\n                <child>\n                  <object class=\"GtkMenuButton\" id=\"conflictButton\">\n                    <property name=\"tooltip_text\" translatable=\"yes\">Conflicts</property>\n                    <property name=\"icon_name\">dialog-error-symbolic</property>\n                    <property name=\"popover\">conflictPopover</property>\n                    <property name=\"visible\">False</property>\n                    <style>\n                      <class name=\"flat\" />\n                      <class name=\"circular\" />\n                    </style>\n                  </object>\n                </child>\n\n                <child>\n                  <object class=\"GtkButton\" id=\"deleteButton\">\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"halign\">end</property>\n                    <property name=\"tooltip_text\" translatable=\"yes\">Remove shortcut</property>\n                    <property name=\"icon_name\">edit-clear-symbolic</property>\n                    <style>\n                      <class name=\"flat\" />\n                      <class name=\"circular\" />\n                    </style>\n                    <signal name=\"clicked\" handler=\"_onDeleteButtonClicked\" />\n                  </object>\n                </child>\n\n              </object>\n            </property>\n          </object>\n        </child>\n        <child>\n          <object class=\"GtkStackPage\">\n            <property name=\"child\">\n              <object class=\"GtkLabel\" id=\"placeholderPage\">\n                <property name=\"hexpand\">True</property>\n                <property name=\"xalign\">0.0</property>\n                <property name=\"use_markup\">True</property>\n                <property name=\"label\" translatable=\"yes\">&lt;i&gt;Add shortcut…&lt;/i&gt;</property>\n              </object>\n            </property>\n          </object>\n        </child>\n        <child>\n          <object class=\"GtkStackPage\">\n            <property name=\"child\">\n              <object class=\"GtkLabel\" id=\"editPage\">\n                <property name=\"use_markup\">True</property>\n                <property name=\"label\" translatable=\"yes\">Enter keyboard shortcut, &lt;b&gt;Backspace&lt;/b&gt; to delete or &lt;b&gt;Esc&lt;/b&gt; to cancel</property>\n              </object>\n            </property>\n          </object>\n        </child>\n      </object>\n    </property>\n  </template>\n\n  <object class=\"GtkPopover\" id=\"conflictPopover\">\n    <child>\n      <object class=\"GtkBox\" id=\"about\">\n        <property name=\"focusable\">False</property>\n        <property name=\"orientation\">vertical</property>\n        <property name=\"margin-start\">12</property>\n        <property name=\"margin-end\">12</property>\n        <property name=\"margin-top\">12</property>\n        <property name=\"margin-bottom\">12</property>\n        <property name=\"spacing\">8</property>\n\n        <child>\n          <object class=\"GtkLabel\">\n            <property name=\"label\" translatable=\"yes\">Conflicts:</property>\n            <style>\n              <class name=\"heading\" />\n            </style>\n          </object>\n        </child>\n\n        <child>\n          <object class=\"GtkListBox\" id=\"conflictList\">\n            <property name=\"selection-mode\">none</property>\n            <signal name=\"row-activated\"\n                    handler=\"_onConflictRowActivated\" />\n\n          </object>\n        </child>\n      </object>\n    </child>\n  </object>\n</interface>\n"
        },
        {
          "name": "KeybindingsPane.ui",
          "type": "blob",
          "size": 1.62109375,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<interface>\n  <requires lib=\"gtk\" version=\"4.0\"/>\n  <template class=\"KeybindingsPane\" parent=\"GtkBox\">\n    <property name=\"focusable\">False</property>\n    <property name=\"orientation\">vertical</property>\n    <child>\n      <object class=\"GtkSearchEntry\" id=\"search\">\n        <property name=\"activates-default\">False</property>\n        <property name=\"halign\">center</property>\n        <property name=\"margin-top\">12</property>\n        <signal name=\"search-changed\"\n                handler=\"_onSearchChanged\" />\n      </object>\n    </child>\n    <child>\n      <object class=\"GtkScrolledWindow\">\n        <property name=\"hscrollbar_policy\">never</property>\n        <child>\n          <object class=\"GtkViewport\">\n            <property name=\"focusable\">False</property>\n            <property name=\"vexpand\">True</property>\n            <child>\n              <object class=\"GtkListBox\" id=\"listbox\">\n                <property name=\"hexpand\">True</property>\n                <property name=\"margin_start\">36</property>\n                <property name=\"margin_end\">36</property>\n                <property name=\"margin_top\">16</property>\n                <property name=\"margin_bottom\">36</property>\n                <property name=\"width_request\">480</property>\n                <style>\n                  <class name=\"keybindings\" />\n                  <class name=\"frame\" />\n                </style>\n                <signal name=\"row-activated\"\n                        handler=\"_onRowActivated\" />\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>\n"
        },
        {
          "name": "KeybindingsRow.ui",
          "type": "blob",
          "size": 4.5693359375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<interface>\n  <requires lib=\"gtk\" version=\"4.0\" />\n  <template class=\"KeybindingsRow\" parent=\"GtkListBoxRow\">\n    <style>\n      <class name=\"keybinding\" />\n    </style>\n    <property name=\"selectable\">False</property>\n    <property name=\"activatable\">True</property>\n    <property name=\"focusable\">True</property>\n\n    <child>\n      <object class=\"GtkBox\">\n        <property name=\"orientation\">vertical</property>\n\n        <child>\n          <object class=\"GtkBox\" id=\"header\">\n            <property name=\"spacing\">12</property>\n            <style>\n              <class name=\"header\" />\n            </style>\n\n            <child>\n              <object class=\"GtkLabel\" id=\"descLabel\">\n                <style>\n                  <class name=\"description\" />\n                </style>\n                <property name=\"ellipsize\">end</property>\n                <property name=\"halign\">start</property>\n                <property name=\"lines\">1</property>\n                <property name=\"wrap\">False</property>\n                <property name=\"xalign\">0</property>\n              </object>\n            </child>\n\n            <child>\n              <object class=\"GtkImage\" id=\"conflictIcon\">\n                <property name=\"visible\">False</property>\n                <property name=\"icon-name\">dialog-error-symbolic</property>\n                <property name=\"halign\">start</property>\n              </object>\n            </child>\n\n            <child>\n              <object class=\"GtkLabel\" id=\"accelLabel\">\n                <property name=\"hexpand\">True</property>\n                <property name=\"halign\">end</property>\n                <property name=\"xalign\">1.0</property>\n                <property name=\"use-markup\">True</property>\n                <style>\n                  <class name=\"dim-label\" />\n                </style>\n              </object>\n            </child>\n          </object>\n        </child>\n\n        <child>\n          <object class=\"GtkRevealer\" id=\"revealer\">\n            <child>\n              <object class=\"GtkGrid\">\n                <property name=\"hexpand\">True</property>\n\n                <child>\n                  <object class=\"GtkListBox\" id=\"comboList\">\n                    <property name=\"activate-on-single-click\">True</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"selection-mode\">none</property>\n                    <style>\n                      <class name=\"combos\" />\n                    </style>\n                    <signal name=\"row-activated\"\n                            handler=\"_onRowActivated\" />\n                    <layout>\n                      <property name=\"row\">0</property>\n                      <property name=\"column\">0</property>\n                      <property name=\"column-span\">2</property>\n                    </layout>\n                  </object>\n                </child>\n\n                <child>\n                  <object class=\"GtkButton\" id=\"resetButton\">\n                    <property name=\"label\" translatable=\"yes\">Reset</property>\n                    <property name=\"action-name\">keybinding.reset</property>\n                    <property name=\"halign\">start</property>\n                    <property name=\"margin-start\">12px</property>\n                    <property name=\"margin-top\">8px</property>\n                    <property name=\"margin-bottom\">8px</property>\n                    <layout>\n                      <property name=\"row\">1</property>\n                      <property name=\"column\">0</property>\n                    </layout>\n                  </object>\n                </child>\n\n                <child>\n                  <object class=\"GtkButton\" id=\"addButton\">\n                    <property name=\"label\" translatable=\"yes\">Add shortcut…</property>\n                    <property name=\"action-name\">keybinding.add</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"halign\">end</property>\n                    <property name=\"margin-top\">8px</property>\n                    <property name=\"margin-end\">12px</property>\n                    <property name=\"margin-bottom\">8px</property>\n\n                    <layout>\n                      <property name=\"row\">1</property>\n                      <property name=\"column\">1</property>\n                    </layout>\n                    <style>\n                      <class name=\"suggested-action\" />\n                    </style>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.3173828125,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    {one line to give the program's name and a brief idea of what it does.}\n    Copyright (C) {year}  {name of author}\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    {project}  Copyright (C) {year}  {fullname}\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 34.8212890625,
          "content": "# PaperWM #\n\n[![project chat](https://img.shields.io/badge/PaperWM_Discussions-join_chat-brightgreen)](https://github.com/paperwm/PaperWM/discussions)\n\nPaperWM is a [Gnome Shell](https://www.gnome.org/) extension which provides scrollable tiling of windows and per monitor workspaces. It's inspired by paper notebooks and tiling window managers.\n\nWhile technically an [extension](https://extensions.gnome.org/about/) it's to a large extent built on top of the Gnome desktop rather than merely extending it.\n\nPaperWM aims to continually support [current stable](https://release.gnome.org/calendar/#branches) Gnome shell versions (currently Gnome 45 & Gnome 46).  Older versions of PaperWM can generally be installed on older Gnome Shell versions (see [Install via Source](#install-via-source) for more information on targeting an older/EOL Gnome version).\n\nNew features and fixes aren't generally backported to older Gnome shell versions.  [Pull requests](https://github.com/paperwm/PaperWM/pulls) for fixes to older PaperWM versions (that run on previous Gnome versions) will be accepted if the submitter can help test and update related documentation.\n\nHave questions or comments?  Please ask on our [Github Discussions](https://github.com/paperwm/PaperWM/discussions) board.\n\n## Installation\n\n### Install via [extensions.gnome.org](https://extensions.gnome.org/extension/6099/paperwm/) (recommended)\n\n[<img alt=\"Install it on extensions.gnome.org\" src=\"media/get-it-on-ego.svg\" width=\"150px\">](https://extensions.gnome.org/extension/6099/paperwm/)\n\n### Install via Source\n\nClone the repo and check out the branch for the Gnome Shell version you're running:\n\n- 45-47 (currently developed/supported): https://github.com/paperwm/PaperWM/tree/release\n- 42-44 ([EOL](https://release.gnome.org/calendar/#releases)): https://github.com/paperwm/PaperWM/tree/gnome-44\n- 40-41 ([EOL](https://release.gnome.org/calendar/#releases)): https://github.com/paperwm/PaperWM/tree/gnome-40\n- 3.28-3.38 ([EOL](https://release.gnome.org/calendar/#releases)): https://github.com/paperwm/PaperWM/tree/gnome-3.38\n\nthen run the [`install.sh`](https://github.com/paperwm/PaperWM/blob/release/install.sh) script\nfrom the repository. The installer will create a link to the repo in\n`~/.local/share/gnome-shell/extensions`. It will then ask if you want to enable PaperWM.\n```bash\n./install.sh # install, load and enable paperwm\n```\n> #### ➡️ You'll need to restart Gnome shell after installing PaperWM, e.g. logout then login, or restart in place with an `alt-F2` and entering `r` (X11 only).\n>\n> After logging back in, you can then enable PaperWM via the `Extensions` application, or by running the following command from the command-line:\n>\n> `/usr/bin/gnome-extensions enable paperwm@paperwm.github.com`\n>\n\n> if you have run into issues, delete any older `paperwm@...` symlinks from `~/.local/share/gnome-shell/extensions` and re-run the `install.sh` script.\n\n#### Uninstall PaperWM (if installed via source)\n\nTo uninstall simply run `./uninstall.sh`.\n\nRunning the extension will automatically install a user config file as described in [User configuration & development](#user-configuration--development).\n\n\n### Try without installing\n\nThis repo provides a lightweight VM based on [NixOS](https://nixos.org) to try PaperWM and aid with development. You can launch it if [Nix](https://nixos.org/nix) is installed on your system using this command:\n\n```sh\nnix run .\\#vm\n```\n\nAlternatively, the VM can also be launched with GPU acceleration, by installing [NixGL](https://github.com/nix-community/nixgl) first:\n\n```sh\nnixGLIntel nix run .\\#vm -- -device virtio-gpu-gl -display gtk,gl=on\n# or nixGLNvidia depending on your host GPU\n```\n\n## Contributing\nUsers are encouraged to submit [issues](https://github.com/paperwm/PaperWM/issues/new/choose) and [Pull Requests](https://github.com/paperwm/PaperWM/pulls)!\n\n> #### ➡️ Please ensure pull requests are based off, and submitted to, [develop](https://github.com/paperwm/PaperWM/tree/develop) branch.\n> \n> Pull requests submitted to the `release` branch will not be accepted (but don't worry, if you accidentally submit a PR to the `release` branch, the target branch will automatically be changed to `develop` branch).\n\n## Usage ##\n\nMost functionality is available using a mouse, eg. activating a window at the edge of the monitor by clicking on it. Wayland support gestures (See the [Touchpad Gestures](#touchpad-gestures) section). PaperWM is designed to work work well with keyboard + mouse, trackpads etc.\n\nMost keybindings start with the <kbd>Super</kbd> modifier (by default), which is usually the Windows key, or on mac keyboards it's the Command key. It's possible to modify the keyboard layout so that <kbd>Super</kbd> is switched with <kbd>Alt</kbd> making all the keybindings easier to reach. This can be done through Gnome Tweaks under `Keyboard & Mouse` ⟶ `Additional Layout Options` ⟶ `Alt/Win key behavior` ⟶ `Left Alt is swapped with Left Win`.\n\nMost keybindings will grab the keyboard while <kbd>Super</kbd> is held down, only switching focus when <kbd>Super</kbd> is released. <kbd>Escape</kbd> will abort the navigation taking you back to the previously active window.\n\nAll PaperWM keybinds can be changed (and disabled) via PaperWM extension settings, which can be accessed through [`Extensions`](https://apps.gnome.org/Extensions/) ⟶ `PaperWM` ⟶ `Settings`.\n\nWindow management and navigation is based around the three following concepts.\n\n### Scrollable window tiling ###\n\n![The window tiling with the minimap shown](https://github.com/paperwm/media/blob/master/tiling.png)\n\nNew windows are automatically tiled to the right of the active window (see [here](#window-insertion-position-for-new-windows-and-dropped-windows-in-take-mode) for dynamically changing the insertion position of new windows), taking up as much height as possible. <kbd>Super</kbd><kbd>Return</kbd> will open a new window of the same type as the active window.\n\nActivating a window will ensure it's fully visible, scrolling the tiling if necessary. By default, pressing <kbd>Super</kbd><kbd>.</kbd> activates the window to the right. <kbd>Super</kbd><kbd>,</kbd> activates the window to the left. On a US keyboard these keys are intuitively marked by <kbd><</kbd> and <kbd>></kbd>, they are also ordered the same way on almost all keyboard layouts. Navigating around windows brings up the minimap as can be seen in the above screenshot. The minimap will stay visible as long as <kbd>Super</kbd> is continually being pressed.\n\nPressing <kbd>Super</kbd><kbd>I</kbd> will move the window to the right below the active window, tiling them vertically in a column. <kbd>Super</kbd><kbd>O</kbd> will do the opposite, pushing the bottom window out of the current column.\n\nSwiping the trackpad horizontally with three fingers (only available in Wayland) or swiping the panel horizontally on a touch screen will scroll the tiling.\n\n<kbd>Alt</kbd><kbd>Tab</kbd> is of course also available.\n\n| Default `window` Keybindings                                                                      | _Can be changed in PaperWM extension settings_ | \n| ------                                                                                            | ------- |\n| <kbd>Super</kbd><kbd>Return</kbd> or <kbd>Super</kbd><kbd>N</kbd>                                 | Open a new windows (of the current application) |\n| <kbd>Super</kbd><kbd>Backspace</kbd>                                                              | Close the active window |\n| <kbd>Super</kbd><kbd>.</kbd> or <kbd>Super</kbd><kbd>,</kbd>                                      | Switch to the next or previous window |\n| <kbd>Super</kbd><kbd>Left</kbd> or <kbd>Super</kbd><kbd>Right</kbd>                               | Activate the window to the left or right |\n| <kbd>Super</kbd><kbd>Up</kbd> or <kbd>Super</kbd><kbd>Down</kbd>                                  | Activate the window above or below |\n| <kbd>Super</kbd><kbd>Home</kbd> or <kbd>Super</kbd><kbd>End</kbd>                                 | Activate the first or last window |\n| _Not set by default (set in extension settings)_                                                  | Switch to the [second _to_ eleventh] window |\n| <kbd>Super</kbd><kbd>Tab</kbd> or <kbd>Alt</kbd><kbd>Tab</kbd>                                    | Cycle through previously active windows |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>Tab</kbd> or <kbd>Shift</kbd><kbd>Alt</kbd><kbd>Tab</kbd>    | Cycle through previously active windows (backward order) |\n| <kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>Tab</kbd>                                                       | Cycle through previously active scratch windows | \n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>Tab</kbd>                                       | Cycle through previously active scratch windows (backward order) |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>C</kbd>                                                      | Switch between window focus modes |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>W</kbd>                                                      | Switch between positions for creating/dropping new windows |\n| _Not set by default (set in extension settings)_                                                  | Create/drop windows to the right of current window |\n| _Not set by default (set in extension settings)_                                                  | Create/drop windows to the left of current window |\n| _Not set by default (set in extension settings)_                                                  | Create/drop windows in vertical stack (down) |\n| _Not set by default (set in extension settings)_                                                  | Create/drop windows in vertical stack (up) |\n| _Not set by default (set in extension settings)_                                                  | Create/drop windows at start position |\n| _Not set by default (set in extension settings)_                                                  | Create/drop windows at end position |\n| <kbd>Super</kbd><kbd>Ctrl</kbd><kbd>,</kbd> or <kbd>Super</kbd><kbd>Ctrl</kbd><kbd>.</kbd>        | Move the current window to the left or right |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>,</kbd> or <kbd>Shift</kbd><kbd>Super</kbd><kbd>.</kbd>      | Move the current window to the left or right |\n| <kbd>Super</kbd><kbd>Ctrl</kbd><kbd>Left</kbd> or <kbd>Super</kbd><kbd>Ctrl</kbd><kbd>Right</kbd> | Move the current window to the left or right |\n| <kbd>Super</kbd><kbd>Ctrl</kbd><kbd>Up</kbd> or <kbd>Super</kbd><kbd>Ctrl</kbd><kbd>Down</kbd>    | Move the current window up or down |\n| <kbd>Super</kbd><kbd>I</kbd>                                                                      | Absorb window into the active column |\n| <kbd>Super</kbd><kbd>O</kbd>                                                                      | Expel the bottom window from vertically tiled windows |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>O</kbd>                                                      | Expel the active window from vertically tiled windows |\n| <kbd>Super</kbd><kbd>C</kbd>                                                                      | Center windows horizontally |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>F</kbd>                                                      | Toggle fullscreen |\n| <kbd>Super</kbd><kbd>F</kbd>                                                                      | Maximize the width of a window |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>+</kbd>                                                      | Increment window height (scratch or vertically tiled windows) |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>-</kbd>                                                      | Decrement window height (scratch or vertically tiled windows) |\n| <kbd>Super</kbd><kbd>+</kbd>                                                                      | Increment window width |\n| <kbd>Super</kbd><kbd>-</kbd>                                                                      | Decrement window width |\n| <kbd>Super</kbd><kbd>R</kbd>                                                                      | Resize the window (cycles through useful widths) |\n| <kbd>Super</kbd><kbd>Alt</kbd><kbd>R</kbd>                                                        | Resize the window (cycles backwards through useful widths)  |\n| <kbd>Super</kbd><kbd>Shift</kbd><kbd>R</kbd>                                                      | Resize the window (cycles through useful heights) |\n| <kbd>Super</kbd><kbd>Shift</kbd><kbd>Alt</kbd><kbd>R</kbd>                                        | Resize the window (cycles backwards through useful heights) |\n| <kbd>Super</kbd><kbd>t</kbd>                                                                      | Take window(s) dropping when finished navigating |\n| _Not set by default (set in extension settings)_                                                  | Activate the window under mouse cursor |\n\n### The workspace stack & monitors ###\n\nPressing <kbd>Super</kbd><kbd>Above_Tab</kbd> will slide the active workspace down revealing the stack as shown in the above screenshot. You can then flip through the most recently used workspaces with repeated <kbd>Above_Tab</kbd> presses while holding <kbd>Super</kbd> down. <kbd>Above_Tab</kbd> is the key above <kbd>Tab</kbd> (<kbd>\\`</kbd> in a US qwerty layout). Like alt-tab <kbd>Shift</kbd> is added to move in reverse order:\n\n![The most recently used workspace stack](https://github.com/paperwm/media/blob/master/stack.png)\n\nPressing <kbd>Super</kbd><kbd>Page_Down</kbd> and <kbd>Super</kbd><kbd>Page_Up</kbd> will slide between workspaces sequentially:\n\n![Sequential workspace navigation](https://github.com/paperwm/media/blob/master/sequence.png)\n\nBy default <kbd>Super</kbd><kbd>Page_Down</kbd> and <kbd>Super</kbd><kbd>Page_Down</kbd> are bound to the keybindings \"Switch to workspace below/above (**ws from current monitor**)\". That means using the keybindings you can select all workspaces that were previously shown on the current monitor and all empty once.\n\nAlternatively you can change these keybindings to \"Switch to workspace below/above (**ws from all monitors**)\" in the settings. That way you can switch to **all** workspaces (that are not currently shown on another monitor). Depending on your workflow this might feel more natural.\n\nThe workspace name is shown in the top left corner replacing the `Activities` button adding a few enhancements. Scrolling on the name will let you browse the workspace stack just like <kbd>Super</kbd><kbd>Above_Tab</kbd>. Left clicking on the name opens Gnome overview, while right clicking the name lets you access and change the workspace name.\n\n> If you prefer to use Gnome workspace \"pill\", you can replace the workspace name element, and enable the Gnome pill from the `General` section of PaperWM preferences:\n>\n> <img alt=\"Using the Gnome pill\" src=\"media/gnome-pill-option.png\" width=\"560px\">\n\nSwiping down on the trackpad vertically with three fingers will initiate the workspace stack, and then allow you navigate the workspace stack with 3-finger vertical swipes (only available in Wayland).  See the [Touchpad Gestures](#touchpad-gestures) section for more information on gesture support in PaperWM.\n\nThere's a single scrollable tiling per workspace. Adding another monitor simply makes it possible to have another workspace visible. The workspace stack is shared among all the monitors, windows being resized vertically as necessary when workspace is displayed on another monitor.\n\n| `workspace` keybindings                                                                           | _Can be changed in PaperWM extension settings_ | \n| ------                                                                                            | ------- |\n| <kbd>Super</kbd><kbd>\\`</kbd>                                                                     | Switch to previously active workspace |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>\\`</kbd>                                                     | Switch to previously active workspace (backwards order) |\n| <kbd>Ctrl</kbd><kbd>Super</kbd><kbd>\\`</kbd>                                                      | Move active window to previously active workspace |\n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Super</kbd><kbd>\\`</kbd>                                      | Move active window to previously active workspace (backwards order) |\n| <kbd>Super</kbd><kbd>PageUp</kbd>                                                                 | Switch to workspace above |\n| <kbd>Super</kbd><kbd>PageDown</kbd>                                                               | Switch to workspace below |\n| <kbd>Ctrl</kbd><kbd>Super</kbd><kbd>PageUp</kbd>                                                  | Move active window one workspace up |\n| <kbd>Ctrl</kbd><kbd>Super</kbd><kbd>PageDown</kbd>                                                | Move active window one workspace down |\n| <kbd>Ctrl</kbd><kbd>Super</kbd><kbd>B</kbd>                                                       | Toggle show/hide (GNOME) TopBar and Window Position Bar |\n| _Not set by default (set in extension settings)_                                                  | Toggle show/hide (GNOME) TopBar |\n| _Not set by default (set in extension settings)_                                                  | Toggle show/hide Window Position Bar |\n\n\n| `monitor` keybindings                                                                             | _Can be changed in PaperWM extension settings_ | \n| ------                                                                                            | ------- |\n| <kbd>Super</kbd><kbd>Shift</kbd><kbd>Right</kbd>                                                  | Switch to the right monitor |\n| <kbd>Super</kbd><kbd>Shift</kbd><kbd>Left</kbd>                                                   | Switch to the left monitor |\n| <kbd>Super</kbd><kbd>Shift</kbd><kbd>Up</kbd>                                                     | Switch to the above monitor |\n| <kbd>Super</kbd><kbd>Shift</kbd><kbd>Down</kbd>                                                   | Switch to the below monitor |\n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>Right</kbd>                                     | Move workspace to monitor on the right |\n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>Left</kbd>                                      | Move workspace to monitor on the left |\n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>Up</kbd>                                        | Move workspace to monitor above |\n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Alt</kbd><kbd>Down</kbd>                                      | Move workspace to monitor below |\n| <kbd>Super</kbd><kbd>Alt</kbd><kbd>Right</kbd>                                                    | Swap workspace with monitor to the right |\n| <kbd>Super</kbd><kbd>Alt</kbd><kbd>Left</kbd>                                                     | Swap workspace with monitor to the left |\n| <kbd>Super</kbd><kbd>Alt</kbd><kbd>Up</kbd>                                                       | Swap workspace with monitor above |\n| <kbd>Super</kbd><kbd>Alt</kbd><kbd>Down</kbd>                                                     | Swap workspace with monitor below |\n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Super</kbd><kbd>Right</kbd>                                   | Move active window to the right monitor |\n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Super</kbd><kbd>Left</kbd>                                    | Move active window to the left monitor |\n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Super</kbd><kbd>Up</kbd>                                      | Move active window to the above monitor |\n| <kbd>Shift</kbd><kbd>Ctrl</kbd><kbd>Super</kbd><kbd>Down</kbd>                                    | Move active window to the below monitor |\n\n### Scratch layer ###\n\n![The floating scratch layer, with the alt tab menu open](https://github.com/paperwm/media/blob/master/scratch.png)\n\nThe scratch layer is an escape hatch to a familiar floating layout. This layer is intended to store windows that are globally useful like chat applications and in general serve as the kitchen sink.\nWhen the scratch layer is active it will float above the tiled windows, when hidden the windows will be minimized.\n\nPressing <kbd>Super</kbd><kbd>Escape</kbd> toggles between showing and hiding the windows in the scratch layer.\nActivating windows in the scratch layer is done using <kbd>Super</kbd><kbd>Tab</kbd>, the floating windows having priority in the list while active.\nWhen the tiling is active <kbd>Super</kbd><kbd>Shift</kbd><kbd>Tab</kbd> selects the most recently used scratch window.\n\n<kbd>Super</kbd><kbd>Ctrl</kbd><kbd>Escape</kbd> will move a tiled window into the scratch layer or alternatively tile an already floating window. This functionality can also be accessed through the window context menu (<kbd>Alt</kbd><kbd>Space</kbd>).\n\n| `scratch` keybindings                                                                             | _Can be changed in PaperWM extension settings_ | \n| ------                                                                                            | ------- |\n| <kbd>Shift</kbd><kbd>Super</kbd><kbd>Escape</kbd>                                                 | Toggles the floating scratch layer |\n| <kbd>Ctrl</kbd><kbd>Super</kbd><kbd>Escape</kbd>                                                  | Attach/detach active window into scratch layer |\n| <kbd>Super</kbd><kbd>Escape</kbd>                                                                 | Toggle the most recent scratch window |\n\n## Touchpad Gestures  ###\n\nPaperWM implements the following touchpad gestures by default:\n\nGesture                       | Action              \n------------------------------|------------------------------------------------------\nthree-finger swipe up         | Gnome Overview\nthree-finger swipe down       | PaperWM workspace stack view (see [here](#the-workspace-stack--monitors))\nthree-finger swipe left/right | Moves tiling viewport (windows) left / right\n\nPaperWM touchpad gesture behaviour can be modified via the `General` tab in PaperWM settings:\n\n<img alt=\"Touchpad gesture settings\" src=\"media/gesture-settings.png\" width=\"560px\">\n\n## Window Position Bar (colored bar segment in Top Bar) ##\n\n[#476](https://github.com/paperwm/PaperWM/pull/476) added a coloured window position bar to the Gnome Top Bar.  This allows users to visually identify the current selected window position of the scrollable viewport in the current workspace.  This is demonstrated in the following video:\n\nhttps://user-images.githubusercontent.com/30424662/221416159-464d7512-5174-451b-9035-0ee84f9eb4ec.mp4\n\nThe window position bar can be _disabled_ from `PaperWM extension settings`:\n\n<img alt=\"Window indicator bar\" src=\"media/window-indicator-bar.png\" width=\"560px\">\n\nYou can style both the coloured position bar and the dimmed \"position bar backdrop\" by overriding the `paperwm-window-position-bar` and `paperwm-window-position-bar-backdrop` CSS classes respectively (see `user.css` in [User configuration & development](#user-configuration--development) section for more information). The `paperwm-window-position-bar` will also inherit the selection color (same as window borders) from `tile-preview`.\n\n_Note: PaperWM overrides the default Gnome Top Bar style to be completely transparent so that the dimmed `window-position-bar-backdrop` and `window-position-bar` elements are visible._\n\n## Window Focus Modes ##\n\n[#482](https://github.com/paperwm/PaperWM/pull/482) added the concept of `window focus modes` to PaperWM.  A `focus mode` controls how windows are \"focused\".  The following modes are currently available:\n\n- the `DEFAULT` focus mode is the traditional PaperWM behaviour (no snapping, just free scrolling)\n- the `CENTER` focus mode causes all windows to be centered horizontally on selection\n- the `EDGE` focus mode causes windows to snap to the closest edge horizontally on selection (but while there is only one window, it is centered)\n\nFocus modes can be toggled by user-settable keybinding (default is `Super`+`Shift`+`c`), or by clicking the new focus-mode button in the Top Bar:\n\n![Focus mode button](media/focus-mode-button.png)\n\n### Setting the default focus mode\n\nThe default focus mode is the standard PaperWM focus mode (i.e. not centered).  This can be changed according to preference by changing the `Default focus mode` setting PaperWM settings.  \n\n<img alt=\"Default focus mode\" src=\"media/default-focus-mode.png\" width=\"560px\">\n\n_Note: changing this setting during a PaperWM session will set all spaces to the new default focus mode._\n\n### Hiding the focus mode icon\n\nUsers may also prefer to hide the focus mode icon.  You can do so from the `Advanced` tab in PaperWM extension settings:\n\n<img alt=\"Hiding the focus mode icon\" src=\"media/hide-focus-mode-icon.png\" width=\"560px\">\n\n## Setting window specific properties\n\nIt's possible to set window properties using simple rules that will be applied when placing new windows. Properties can applied to windows identified by their `wm_class` or `title`.  The following properties are currently supported:\n\nProperty              | Input type                          | Input example | Description\n----------------------|-------------------------------------|------------------|------------------\n`scratch_layer`       | Boolean                             | `true`, `false`  | if `true` window will be placed on the scratch layer.\n`preferredWidth`      | String value with `%` or `px` unit         | `\"50%\"`, `\"450px\"`    | resizes the window width to the preferred width when it's created. </br>_Note<sup>1</sup>: property not applicable to windows on scratch layer._\n\nWindow properties can be added using the `Winprops` tab of the PaperWM extension settings:\n\nhttps://user-images.githubusercontent.com/30424662/211422647-79e64d56-5dbb-4054-b9a6-32bf3194b636.mp4\n\nThe `wm_class` or `title` of a window can be found by using looking glass: <kbd>Alt</kbd><kbd>F2</kbd> `lg` <kbd>Return</kbd> Go to the \"Windows\" section at the top right and find the window. X11 users can also use the `xprop` command line tool (`title` is referred as `WM_NAME` in `xprop`). The match of `wm_class` and `title` are with an OR condition; and in addition to a plain string matching, a constructed [`RegExp()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp) can be used to utilise regex matching.  For example, e.g. `/.*terminal.*/i` would match on any value that contains the word \"terminal\" (case-insensitive).\n\n### Setting a default window property rule\n\nYou can use the functionality defined in the [setting window specific properties](#setting-window-specific-properties) section to define a `default` window property rule that will be applied to all windows NOT matched by a more specific window property rule.\n\nYou do this by using the special \"match all\" operator `*` as an input for `wm_class` or `title`.  The below image shows setting a default `Preferred width` value of `50%`.\n\n<img alt=\"Setting default window property rule\" src=\"media/default-star-winprop.png\" width=\"560px\">\n\nThis special operator is at a lower precedence, so more specific properties that match a window will always take precedence and be applied.\n\n\n## Window insertion position for new windows (and dropped windows in `take` mode)\n\nBy default PaperWM inserts new windows (and drops windows in `take` mode, see [Managing multiple windows at once](#managing-multiple-windows-at-once)) to the right of the currently active window.  This behaviour can be changed via PaperWM settings, or with the `Open Window Position` button/icon (which is to the right of the focus mode icon):\n\n![Open positions button](media/open-position-button.png)\n\nThere are several `positions` available for selection.  Namely, `right`, `left`, `start`, `end`.  The latter two will insert windows at the start or end of tiled windows container.\n\nOptions for these settings, as well as settings to enable/disable specific positions in the `Open Window Position` buttons, are provided in PaperWM settings:\n\nhttps://github.com/paperwm/PaperWM/assets/30424662/4e4aa415-d047-44cb-b87a-d7e08493ecbd\n\n## Managing multiple windows at once\n\nPaperWM provides functionality to move, reorder, and close multiple windows at once.  These \"multi-window\" operations are initialised with the `Take the window, dropping it when finished navigating` keybind (default <kbd>Super</kbd><kbd>T</kbd>).\n\nThis allows you to `take` multiple windows and temporarily store them in the bottom-right corner of the workspace.  The following operations are available while there are one or more windows \"taken\":\n\n_Selectively take/drop windows (pressing `spacebar` to drop the latest taken window):_\n\nhttps://github.com/paperwm/PaperWM/assets/30424662/f736adea-d5ba-4c9d-aca0-2f63322c08cb\n\n_Selecting all windows across spaces to close at once (pressing `q`):_\n\nhttps://github.com/paperwm/PaperWM/assets/30424662/e6596de2-f5f7-46af-b447-044f17f326f9\n\n_Reordering \"taken\" windows and selectively dropping them:_\n\nhttps://github.com/paperwm/PaperWM/assets/30424662/c7c50471-f352-4693-a936-2e711189f933\n\n## User configuration & development ##\n\nYou can supply a custom `user.css` in `~/.config/paperwm/`. This user stylesheet can override the default styles of paperwm (e.g. from `~/.local/share/gnome-shell/extensions/paperwm@paperwm.github.com/user.css` or `/usr/share/gnome-shell/extensions/paperwm@paperwm.github.com/user.css`), gnome or even other extensions. The same rules as for CSS in the browser apply (i.e. CSS rules are additive). \n\nYou can reload the `user.css` by disabling (turning off) PaperWM and then re-enabling PaperWM (turning on), e.g via `Extensions` app, or by running `Main.loadTheme()` in looking glass (i.e. <kbd>Alt</kbd><kbd>F2</kbd> `lg` <kbd>Return</kbd>). Note that the latter approach will reload all other .css files (e.g. from other extensions) and `user.css` needs to already be loaded for this to work. So after initially creating the file you'll need to disable then enable PaperWM (or restart Gnome).\n\n### Using PaperWM extension settings (UI) to modify settings\nPaperWM provides an extension settings UI to modify many of PaperWM's more prevalent settings.  This is available in the `gnome-extensions` application.\n\n### Using dconf-editor to modify settings\nYou can also use `dconf-editor` to view and modify all PaperWM user settings.  You can view all settings by executing the following command from a terminal:\n\n```shell\nGSETTINGS_SCHEMA_DIR=::$HOME/.local/share/gnome-shell/extensions/paperwm@paperwm.github.com/schemas dconf-editor /org/gnome/shell/extensions/paperwm/ &>/dev/null\n```\n\n### PaperWM user-configurable settings _not_ available in settings UI\n\nBelow is a list of user-configurable settings that are not exposed in the PaperWM settings UI.  These can be modified via [`dconf-editor`](#using-dconf-editor-to-modify-settings).\n\nSetting | Description | Input Type | Default value\n--------|-------------|------------|--------------\n<code>default&#8209;background</code>| Sets the (default) background used for PaperWM workspaces.  If set will use this background instead of colors defined in `workspace-colors`. | _absolute path_ | _empty_\n\n_Note: you can override this for individual workspaces in the settings UI._\n\n__Example:__\n```\ndconf write /org/gnome/shell/extensions/paperwm/default-background '\"/home/user/Wallpaper/mars-sunset-2k.jpg\"'\n```\n\nSetting | Description | Input Type | Default value\n--------|-------------|------------|--------------\n<code>workspace&#8209;colors</code>  | Sets the workspace background color palette. | _String array of colors_ | `['#314E6C', '#565248', '#445632', '#663822', '#494066',   '#826647', '#4B6983', '#807D74', '#5D7555', '#884631', '#625B81', '#B39169', '#7590AE', '#BAB5AB', '#83A67F', '#C1665A', '#887FA3', '#E0C39E']`\n\n## Gnome Top Bar opacity / styling ##\n\nPaperWM by default changes the opacity of the Gnome Top Bar.  This styling is used for certain PaperWM features.  However, this styling may conflict with the Top Bar styling of other extensions (that you may prefer have style the Top Bar instead).\n\nUsers can disable PaperWM's ability to change GNOME Top Bar styling from PaperWM settings:\n\n<img alt=\"Enable Top Bar Styling\" src=\"media/topbar-styling.png\" width=\"560px\">\n\n_Note: several PaperWM specific features are dependent on changing the Gnome Top Bar to function correctly.  If you choose to disable PaperWM's ability to change the Top Bar styles (with the setting above), you may also want to disable the [Window Position Bar](#window-position-bar-colored-bar-segment-in-top-bar)_.\n\n## Managed Gnome Shell Settings ##\n\nThere's a few Gnome Shell settings that are incompatible with, or work poorly with, PaperWM. Namely\n- `workspaces-only-on-primary`: Multi monitor support require workspaces\n  spanning all monitors\n- `edge-tiling`: We don't support the native half tiled windows\n- `attach-modal-dialogs`: Attached modal dialogs can cause visual glitching\n\nPaperWM manages these settings (disables them) during runtime.  It will then restore these settings to their prior values when PaperWM is disabled.\n\n## Recommended extensions ##\n\nThese extensions are good complements to PaperWM:\n\n- [Switcher](https://github.com/daniellandau/switcher) - combined window switcher and launcher\n- [Dash to Dock](https://micheleg.github.io/dash-to-dock/) - a great dock\n\n## Incompatible extensions\n\nIn most cases it should be enough to disable these extensions.\n\n- [DING (Desktop Icons NG)](https://gitlab.com/rastersoft/desktop-icons-ng) (shipped by default with Ubuntu) or similar extensions that add desktop icons. Creates invisible windows and does not properly show icons. See #784, #266\n- Fedoras builtin desktop watermark (shipped with Fedora) See #706\n- [Rounded Window Corners](https://github.com/yilozt/rounded-window-corners) or similar extensions that change the window shape. See #763, #431\n- [Space Bar](https://github.com/christopher-l/space-bar) or similar extensions that modify workspace names etc. See #720\n- [Dash to Panel](https://github.com/home-sweet-gnome/dash-to-panel) or similar panels. Works in some configurations and in some not. Is incompatible with PaperWMs window position bar. See #170, #199, #646, #382, #166, #258\n\nSee issues tagged with the [extension-conflict](https://github.com/paperwm/PaperWM/issues?q=is%3Aissue+label%3Aextension-conflict+sort%3Aupdated-desc) label for current and closed issues related to extension conflicts.\n\nIn general extensions that do one of the following are problematic when used together with PaperWM (although they might partially work):\n\n- Modify the desktop\n- Modify window \"shapes\" (e.g. rounded corners)\n- Modify workspaces\n- Modify touch gestures\n\nPaperWM will attempt to disable keybindings of some known extensions if they clash. E.g. the Ubuntu Tiling Assistant from Ubuntu 23.10.\n\n## Related / similar projects ##\n\nMore projects are embracing the scrollable tiling concept!  The following projects may be of interest to others (especially if PaperWM doesn't quite work for you):\n\n- Niri: https://github.com/YaLTeR/niri\n- Karousel (for KDE): https://github.com/peterfajdiga/karousel\n- papersway (for i3/sway): https://spwhitton.name/tech/code/papersway/\n\nA similar idea was apparently tried out a while back: [10/GUI](https://web.archive.org/web/20201123162403/http://10gui.com/).\n"
        },
        {
          "name": "Settings.ui",
          "type": "blob",
          "size": 146.0654296875,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<interface>\n  <requires lib=\"gtk\" version=\"4.0\"/>\n  <object class=\"GtkAdjustment\" id=\"horizontal-friction-adjustment\">\n    <property name=\"upper\">10</property>\n    <property name=\"step_increment\">0.1</property>\n    <property name=\"page_increment\">1</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"horizontal-sensitivity-adjustment\">\n    <property name=\"upper\">10</property>\n    <property name=\"step_increment\">0.1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"horizontal_margin\">\n    <property name=\"upper\">100</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkImage\" id=\"image1\">\n    <property name=\"focusable\">False</property>\n    <property name=\"icon_name\"></property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"vertical-friction-adjustment\">\n    <property name=\"upper\">10</property>\n    <property name=\"step_increment\">0.1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"vertical-sensitivity-adjustment\">\n    <property name=\"upper\">10</property>\n    <property name=\"step_increment\">0.1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"vertical_margin\">\n    <property name=\"upper\">100</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"vertical_margin_bottom\">\n    <property name=\"upper\">100</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"window_gap\">\n    <property name=\"upper\">99</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"selection_size\">\n    <property name=\"upper\">50</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">5</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"selection_radius_size_top\">\n    <property name=\"upper\">50</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">5</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"selection_radius_size_bottom\">\n    <property name=\"upper\">50</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">5</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"animation_time_adjustment\">\n    <property name=\"upper\">6.00</property>\n    <property name=\"lower\">0.00</property>\n    <property name=\"step_increment\">0.01</property>\n    <property name=\"page_increment\">0.1</property>\n  </object>\n    <object class=\"GtkAdjustment\" id=\"drift_speed_adjustment\">\n    <property name=\"upper\">15</property>\n    <property name=\"lower\">0</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">5</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"drag_drift_speed_adjustment\">\n    <property name=\"upper\">15</property>\n    <property name=\"lower\">0</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">5</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"minimap_scale\">\n    <property name=\"upper\">95</property>\n    <property name=\"lower\">0</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"minimap_shade_opacity_scale\">\n    <property name=\"upper\">255</property>\n    <property name=\"lower\">0</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"edge_preview_scale\">\n    <property name=\"upper\">95</property>\n    <property name=\"lower\">0</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"edge_preview_timeout_scale\">\n    <property name=\"upper\">10000</property>\n    <property name=\"lower\">0</property>\n    <property name=\"step_increment\">100</property>\n    <property name=\"page_increment\">1000</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"window_switcher_preview_scale\">\n    <property name=\"upper\">95</property>\n    <property name=\"lower\">5</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"maximize_width_percent_scale\">\n    <property name=\"upper\">100</property>\n    <property name=\"lower\">50</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"overview_max_window_scale\">\n    <property name=\"upper\">95</property>\n    <property name=\"lower\">10</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">10</property>\n  </object>\n  <object class=\"GtkAdjustment\" id=\"overview_min_windows_per_row\">\n    <property name=\"upper\">20</property>\n    <property name=\"lower\">1</property>\n    <property name=\"step_increment\">1</property>\n    <property name=\"page_increment\">5</property>\n  </object>\n  <object class=\"AdwPreferencesPage\" id=\"general_page\">\n    <property name=\"title\" translatable=\"yes\">General</property>\n    <property name=\"icon-name\">text-x-generic-symbolic</property>\n    <child>\n      <object class=\"GtkScrolledWindow\" id=\"scrolledWindow\">\n        <property name=\"hscrollbar_policy\">never</property>\n        <child>\n          <object class=\"GtkViewport\">\n            <property name=\"focusable\">False</property>\n            <property name=\"vexpand\">True</property>\n            <child>\n              <object class=\"GtkBox\" id=\"general\">\n                <property name=\"halign\">center</property>\n                <property name=\"margin_start\">36</property>\n                <property name=\"margin_end\">36</property>\n                <property name=\"margin_top\">16</property>\n                <property name=\"margin_bottom\">16</property>\n                <property name=\"orientation\">vertical</property>\n                <property name=\"spacing\">12</property>\n                <property name=\"width_request\">480</property>\n                <child>\n                  <object class=\"GtkLabel\">\n                    <property name=\"halign\">start</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"label\" translatable=\"yes\">Settings</property>\n                    <attributes>\n                      <attribute name=\"weight\" value=\"bold\" />\n                    </attributes>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkListBox\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"selection_mode\">none</property>\n                    <property name=\"margin-bottom\">16</property>\n                    <style>\n                      <class name=\"frame\" />\n                    </style>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"tooltip_text\" translatable=\"yes\">Sets the position when creating/inserting new tiled windows, e.g. to the right/left of the current window, or at the start/end of all tiled windows.</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Position when creating new windows</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkComboBoxText\" id=\"open-window-position\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">0</property>\n                                <property name=\"width-request\">106</property>\n                                <items>\n                                  <item id=\"right\" translatable=\"yes\">To Right</item>\n                                  <item id=\"left\" translatable=\"yes\">To Left</item>\n                                  <item id=\"start\" translatable=\"yes\">At Start</item>\n                                  <item id=\"end\" translatable=\"yes\">At End</item>\n                                </items>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets default focus mode used in workspaces</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Default &lt;i&gt;window focus mode&lt;/i&gt; for workspaces</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkComboBoxText\" id=\"default-focus-mode\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">0</property>\n                                <property name=\"width-request\">106</property>\n                                <items>\n                                  <item id=\"default\" translatable=\"yes\">Default</item>\n                                  <item id=\"center\" translatable=\"yes\">Center</item>\n                                  <item id=\"edge\" translatable=\"yes\">Edge</item>\n                                </items>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Show scratch windows in overview</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkComboBoxText\" id=\"scratch-in-overview\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">0</property>\n                                <property name=\"width-request\">106</property>\n                                <items>\n                                  <item id=\"always\" translatable=\"yes\">Always</item>\n                                  <item id=\"only\" translatable=\"yes\">Only</item>\n                                  <item id=\"never\" translatable=\"yes\">Never</item>\n                                </items>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"tooltip_text\" translatable=\"yes\">Enables PaperWM's Window Position Bar (colored bar overlay on the Gnome topbar)</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Enable Window Position Bar</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show-window-position-bar\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Replaces PaperWM's workspace indicator with the Gnome Workspace Indicator Pill (introduced in Gnome 45)</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Enable Gnome Workspace Indicator Pill</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"use-gnome-pill\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkLabel\">\n                    <property name=\"halign\">start</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"label\" translatable=\"yes\">Touchpad Gestures</property>\n                    <attributes>\n                      <attribute name=\"weight\" value=\"bold\" />\n                    </attributes>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkListBox\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"selection_mode\">none</property>\n                    <property name=\"margin-bottom\">16</property>\n                    <style>\n                      <class name=\"frame\" />\n                    </style>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Enables / disables PaperWM gestures. Disabling this restores Gnome's default touchpad gestures.</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Enable Touchpad Gestures</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"gesture-enabled\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the number of fingers used for moving the tiling viewport (windows) left/right.</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Swipe tiling windows &lt;i&gt;(swipe left/right)&lt;/i&gt;</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkComboBoxText\" id=\"gesture-horizontal-fingers\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">0</property>\n                                <property name=\"width-request\">106</property>\n                                <items>\n                                  <item id=\"fingers-disabled\" translatable=\"yes\">Disabled</item>\n                                  <item id=\"three-fingers\" translatable=\"yes\">3 Fingers</item>\n                                  <item id=\"four-fingers\" translatable=\"yes\">4 Fingers</item>\n                                </items>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the number of fingers used for PaperWM workspace stack view.</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">PaperWM workspace switching &lt;i&gt;(swipe down)&lt;/i&gt;</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkComboBoxText\" id=\"gesture-workspace-fingers\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">0</property>\n                                <property name=\"width-request\">106</property>\n                                <items>\n                                  <item id=\"fingers-disabled\" translatable=\"yes\">Disabled</item>\n                                  <item id=\"three-fingers\" translatable=\"yes\">3 Fingers</item>\n                                  <item id=\"four-fingers\" translatable=\"yes\">4 Fingers</item>\n                                </items>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkLabel\">\n                    <property name=\"halign\">start</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"label\" translatable=\"yes\">Border | Gaps | Margins</property>\n                    <attributes>\n                      <attribute name=\"weight\" value=\"bold\" />\n                    </attributes>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkListBox\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"selection_mode\">none</property>\n                    <property name=\"margin-bottom\">16</property>\n                    <style>\n                      <class name=\"frame\" />\n                    </style>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">The size / thickness of the selected/focused window border</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Selected window border size (px)</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"selection_size_spin\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">selection_size</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">The pixel size of border-radius for top corners</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Selected window border-radius for top corners (px)</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"selection_radius_top_spin\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">selection_radius_size_top</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">The pixel size of border radius for bottom corners</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Selected window border-radius for bottom corners (px)</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"selection_radius_bottom_spin\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">selection_radius_size_bottom</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Gap between windows</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"window_gap_spin\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">window_gap</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"general_row1\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\" id=\"workspace_grid1\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">The minimum margin to the left and right monitor edge</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Horizontal margin</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"hmargin_spinner\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"text\" translatable=\"yes\">0</property>\n                                <property name=\"adjustment\">horizontal_margin</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\" id=\"general_row2\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\" id=\"workspace_grid5\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Top margin</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"top_margin_spinner\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"text\" translatable=\"yes\">0</property>\n                                <property name=\"adjustment\">vertical_margin</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Bottom margin</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"bottom_margin_spinner\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"text\" translatable=\"yes\">0</property>\n                                <property name=\"adjustment\">vertical_margin_bottom</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <property name=\"tooltip_text\" translatable=\"yes\">Semicolon separated values of \"useful window widths\" that will be cycled through. Values types can be either percentage (of available screen width), e.g. \"50%\" or pixel values, e.g. \"500px\". Mixed value types are not supported.</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Useful window widths</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkGrid\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                                <child>\n                                  <object class=\"GtkButton\" id=\"cycle_widths_reset_button\">\n                                    <property name=\"margin_end\">8</property>\n                                    <property name=\"label\">reset</property>\n                                    <property name=\"tooltip_text\" translatable=\"yes\">Resets width values to the default PaperWM width values</property>\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkEntry\" id=\"cycle_widths_entry\">\n                                    <property name=\"width_chars\">24</property>\n                                    <property name=\"max_width_chars\">24</property>\n                                    <layout>\n                                      <property name=\"column\">2</property>\n                                      <property name=\"row\">0</property>\n                                    </layout>\n                                  </object>\n                                </child>\n                                </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <property name=\"tooltip_text\" translatable=\"yes\">Semicolon separated values of \"useful window heights\" that will be cycled through. Values types can be either percentage (of available screen width), e.g. \"50%\" or pixel values, e.g. \"500px\". Mixed value types are not supported.</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Useful window heights</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkGrid\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                                <child>\n                                  <object class=\"GtkButton\" id=\"cycle_heights_reset_button\">\n                                    <property name=\"margin_end\">8</property>\n                                    <property name=\"label\">reset</property>\n                                    <property name=\"tooltip_text\" translatable=\"yes\">Resets height values to the default PaperWM height values</property>\n                                  </object>\n                                </child>\n                                <child>\n                                  <object class=\"GtkEntry\" id=\"cycle_heights_entry\">\n                                    <property name=\"width_chars\">24</property>\n                                    <property name=\"max_width_chars\">24</property>\n                                    <layout>\n                                      <property name=\"column\">1</property>\n                                      <property name=\"row\">0</property>\n                                    </layout>\n                                  </object>\n                                </child>\n                                </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class=\"AdwPreferencesPage\" id=\"workspaces_page\">\n    <property name=\"icon-name\">view-list-symbolic</property>\n    <property name=\"title\" translatable=\"yes\">Workspaces</property>\n    <child>\n      <object class=\"GtkBox\" id=\"workspaces\">\n        <property name=\"focusable\">False</property>\n        <property name=\"halign\">center</property>\n        <property name=\"margin_start\">36</property>\n        <property name=\"margin_end\">36</property>\n        <property name=\"margin_top\">16</property>\n        <property name=\"margin_bottom\">16</property>\n        <property name=\"orientation\">vertical</property>\n        <property name=\"spacing\">12</property>\n        <property name=\"width_request\">480</property>\n        <child type=\"label\">\n          <object class=\"GtkLabel\">\n            <property name=\"halign\">start</property>\n            <property name=\"hexpand\">True</property>\n            <property name=\"label\" translatable=\"yes\">All workspaces</property>\n            <attributes>\n              <attribute name=\"weight\" value=\"bold\"></attribute>\n            </attributes>\n          </object>\n        </child>\n        <child>\n          <object class=\"GtkListBox\">\n            <property name=\"focusable\">False</property>\n            <property name=\"selection_mode\">none</property>\n            <property name=\"margin_bottom\">16</property>\n            <style>\n              <class name=\"frame\" />\n            </style>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"workspace_default_background_row\">\n                <property name=\"activatable\">False</property>\n                <property name=\"focusable\">False</property>\n                <child>\n                  <object class=\"GtkGrid\" id=\"workspace_default_background_grid\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">24</property>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"workspace_default_background_label\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Use default GNOME Shell background</property>\n                        <property name=\"xalign\">0</property>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkSwitch\" id=\"use-default-background\">\n                        <property name=\"valign\">center</property>\n                        <layout>\n                          <property name=\"column\">2</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkButton\" id=\"gnome-background-panel\">\n                        <property name=\"receives_default\">1</property>\n                        <property name=\"tooltip_text\" translatable=\"yes\">Launch gnome background picker</property>\n                        <property name=\"icon-name\">org.gnome.Settings-symbolic</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\">\n                <property name=\"activatable\">False</property>\n                <property name=\"focusable\">False</property>\n                <property name=\"tooltip_text\" translatable=\"yes\">Resets workspace names to default.</property>\n                <child>\n                  <object class=\"GtkGrid\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">6</property>\n                    <property name=\"margin_bottom\">6</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkLabel\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Reset workspace names</property>\n                        <property name=\"xalign\">0</property>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkButton\" id=\"workspace_reset_button\">\n                        <property name=\"label\">Reset</property>\n                        <layout>\n                          <property name=\"column\">2</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                        <style>\n                          <class name=\"destructive-action\" />\n                        </style>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n        <child type=\"label\">\n          <object class=\"GtkLabel\">\n            <property name=\"halign\">start</property>\n            <property name=\"hexpand\">True</property>\n            <property name=\"label\" translatable=\"yes\">Per workspace</property>\n            <attributes>\n              <attribute name=\"weight\" value=\"bold\"></attribute>\n            </attributes>\n          </object>\n        </child>\n        <child>\n          <object class=\"GtkListBox\">\n            <property name=\"focusable\">False</property>\n            <property name=\"selection_mode\">none</property>\n            <property name=\"margin-bottom\">16</property>\n            <style>\n              <class name=\"frame\" />\n            </style>\n            <child>\n              <object class=\"GtkListBoxRow\" id=\"workspace_list_row\">\n                <property name=\"activatable\">False</property>\n                <property name=\"focusable\">False</property>\n                <child>\n                  <object class=\"GtkGrid\" id=\"workspace_grid\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"margin_start\">12</property>\n                    <property name=\"margin_end\">12</property>\n                    <property name=\"margin_top\">12</property>\n                    <property name=\"margin_bottom\">12</property>\n                    <property name=\"column_spacing\">32</property>\n                    <child>\n                      <object class=\"GtkLabel\" id=\"workspace_label\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"hexpand\">1</property>\n                        <property name=\"label\" translatable=\"yes\">Configure workspace</property>\n                        <property name=\"xalign\">0</property>\n                        <layout>\n                          <property name=\"column\">0</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkComboBoxText\" id=\"workspace_combo_text\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"valign\">center</property>\n                        <layout>\n                          <property name=\"column\">1</property>\n                          <property name=\"row\">0</property>\n                        </layout>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\">\n                <property name=\"activatable\">False</property>\n                <property name=\"focusable\">False</property>\n                <child>\n                  <object class=\"GtkSeparator\">\n                    <property name=\"orientation\">horizontal</property>\n                    <property name=\"hexpand\">True</property>\n                  </object>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkListBoxRow\">\n                <property name=\"activatable\">False</property>\n                <property name=\"focusable\">False</property>\n                <property name=\"width_request\">100</property>\n                <property name=\"height_request\">80</property>\n                <child>\n                  <object class=\"GtkStack\" id=\"workspace_stack\">\n                    <property name=\"focusable\">False</property>\n                    <child>\n                      <placeholder/>\n                    </child>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class=\"AdwPreferencesPage\" id=\"keybindings_page\">\n    <property name=\"title\" translatable=\"yes\">Keybindings</property>\n    <property name=\"icon-name\">input-keyboard-symbolic</property>\n    <child>\n      <object class=\"KeybindingsPane\" id=\"keybindings_pane\"/>\n    </child>\n  </object>\n  <object class=\"AdwPreferencesPage\" id=\"winprops_page\">\n    <property name=\"title\" translatable=\"yes\">Winprops</property>\n    <property name=\"icon-name\">sidebar-show-right-symbolic</property>\n    <child>\n      <object class=\"WinpropsPane\" id=\"winpropsPane\" />\n    </child>\n  </object>\n  <object class=\"AdwPreferencesPage\" id=\"advanced_page\">\n    <property name=\"title\" translatable=\"yes\">Advanced</property>\n    <property name=\"icon-name\">emblem-system-symbolic</property>\n    <child>\n      <object class=\"GtkScrolledWindow\" id=\"advanced_scrolledWindow\">\n        <property name=\"hscrollbar_policy\">never</property>\n        <child>\n          <object class=\"GtkViewport\">\n            <property name=\"focusable\">False</property>\n            <property name=\"vexpand\">True</property>\n            <child>\n              <object class=\"GtkBox\">\n                <property name=\"halign\">center</property>\n                <property name=\"margin_start\">36</property>\n                <property name=\"margin_end\">36</property>\n                <property name=\"margin_top\">16</property>\n                <property name=\"margin_bottom\">16</property>\n                <property name=\"orientation\">vertical</property>\n                <property name=\"spacing\">12</property>\n                <property name=\"width_request\">480</property>\n                <child>\n                  <object class=\"GtkLabel\">\n                    <property name=\"halign\">start</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"label\" translatable=\"yes\">Animation | Visual Settings</property>\n                    <attributes>\n                      <attribute name=\"weight\" value=\"bold\" />\n                    </attributes>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkListBox\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"selection_mode\">none</property>\n                    <property name=\"margin-bottom\">16</property>\n                    <style>\n                      <class name=\"frame\" />\n                    </style>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the duration of PaperWM animated transitions (e.g. switching windows, workspaces etc.). Lower values result in faster transitions.</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Animation / transition time (seconds)</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"animation_time_spin\">\n                                <property name=\"width_chars\">3</property>\n                                <property name=\"max_width_chars\">3</property>\n                                <property name=\"adjustment\">animation_time_adjustment</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"digits\">2</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the drift speed (px/ms) when using \"drifting view to the left/right\" keybinds.</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Drift speed (px/ms) when using \"viewport drift\" keybinds</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"drift_speed_spin\">\n                                <property name=\"width_chars\">3</property>\n                                <property name=\"max_width_chars\">3</property>\n                                <property name=\"adjustment\">drift_speed_adjustment</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the drift speed (px/ms) when mouse is at edge of montior when dragging windows.</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Drift speed (px/ms) when dragging windows (at edge)</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"drag_drift_speed_spin\">\n                                <property name=\"width_chars\">3</property>\n                                <property name=\"max_width_chars\">3</property>\n                                <property name=\"adjustment\">drag_drift_speed_adjustment</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Disables PaperWM's ability to style the Gnome TopBar</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Enable Top Bar styling &lt;i&gt;(required for Window Position Bar)&lt;/i&gt;</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"disable-topbar-styling\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Shows/hides the focus mode icon in TopBar</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Show focus mode icon</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show-focus-mode-icon\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Shows/hides the open window position icon in TopBar</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Show open window position icon</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show-open-position-icon\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>                    \n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the animation when exiting GNOME overview and ensuring selected window is in view</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">GNOME overview exit &lt;i&gt;select window&lt;/i&gt; animation </property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkComboBoxText\" id=\"overview-ensure-viewport-animation\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">0</property>\n                                <property name=\"width-request\">106</property>\n                                <items>\n                                  <item id=\"none\" translatable=\"yes\">None</item>\n                                  <item id=\"translate\" translatable=\"yes\">Translate</item>\n                                  <item id=\"fade\" translatable=\"yes\">Fade</item>\n                                </items>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the minimum number of windows for each row in Gnome overview. Increasing this can make Gnome overview appear more like the current tiling layout.</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">&lt;i&gt;Minimum&lt;/i&gt; number of windows per GNOME overview row</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\"  id=\"overview_min_windows_per_row_spin\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">overview_min_windows_per_row</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the opacity [5-255] of the dimming/shade used on non-selected windows during mini-map navigation.</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Dimming opacity of windows during mini-map navigation</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\"  id=\"minimap_shade_opacity_spin\">\n                                <property name=\"width_chars\">3</property>\n                                <property name=\"max_width_chars\">3</property>\n                                <property name=\"adjustment\">minimap_shade_opacity_scale</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkLabel\">\n                    <property name=\"halign\">start</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"label\" translatable=\"yes\">Tiling Edge Preview Settings</property>\n                    <attributes>\n                      <attribute name=\"weight\" value=\"bold\" />\n                    </attributes>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkListBox\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"selection_mode\">none</property>\n                    <property name=\"margin-bottom\">16</property>\n                    <style>\n                      <class name=\"frame\" />\n                    </style>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Enables tiling edge previews</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Enable tiling edge previews</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"edge-preview-enable\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Controls the \"size\" of tiling edge window previews, as compared to their actual window size (e.g. \"15\" corresponds to an edge preview size being approximately 15% of the actual window size)</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Tiling edge preview scale (%)</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"edge_scale_spin\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">edge_preview_scale</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Enables activating edge window by mouse click</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Click to activate edge window</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"edge-preview-click-enable\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Enables activating edge window by hover timeout</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Hover to activate edge window</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"edge-preview-timeout-enable\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the timeout before activating window (milliseconds)</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Hover timeout (milliseconds)</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"edge-preview-timeout\">\n                                <property name=\"width_chars\">5</property>\n                                <property name=\"max_width_chars\">5</property>\n                                <property name=\"adjustment\">edge_preview_timeout_scale</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Enables the continual activation of windows if pointer is still at edge of monitor</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">&lt;i&gt;Continual &lt;/i&gt; edge window activation on hover</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"edge-preview-timeout-continual\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </child>               \n                <child>\n                  <object class=\"GtkLabel\">\n                    <property name=\"halign\">start</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"label\" translatable=\"yes\">PaperWM Component Size Settings</property>\n                    <attributes>\n                      <attribute name=\"weight\" value=\"bold\" />\n                    </attributes>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkListBox\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"selection_mode\">none</property>\n                    <property name=\"margin-bottom\">16</property>\n                    <style>\n                      <class name=\"frame\" />\n                    </style>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Controls the \"size\" of mini-map tiles (as shown during window navigation keybinds), as compared to their actual window size (e.g. \"15\" corresponds to a mini-map tile size being approximately 15% of the actual window size)</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Mini-map scale (%) &lt;i&gt;(0 hides Mini-map)&lt;/i&gt;</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"minimap_scale_spin\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">minimap_scale</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Controls the \"size\" of window switcher previews (e.g. Super+Tab switcher), as compared to their actual window size (e.g. \"15\" corresponds to an edge preview size being approximately 15% of the actual window size)</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Window-switcher preview scale (%)</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"window_switcher_preview_scale_spin\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">window_switcher_preview_scale</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Controls the maximum window \"size\" of GNOME overview windows, as compared to their actual window size (e.g. \"95\" corresponds to an edge preview size being approximately 95% of the actual window size)</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">&lt;i&gt;Maximum&lt;/i&gt; window scale (%) of GNOME overview windows</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\"  id=\"overview_max_window_scale_spin\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">overview_max_window_scale</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkLabel\">\n                    <property name=\"halign\">start</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"label\" translatable=\"yes\">Other Settings</property>\n                    <attributes>\n                      <attribute name=\"weight\" value=\"bold\" />\n                    </attributes>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkListBox\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"selection_mode\">none</property>\n                    <property name=\"margin-bottom\">16</property>\n                    <style>\n                      <class name=\"frame\" />\n                    </style>\n                    <!--<child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Shows/hides the workspace indicator element in Topbar</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Show workspace indicator</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"show-workspace-indicator\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>-->\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"tooltip_text\" translatable=\"yes\">Sets the percentage of workspace width the \"window maximize horizontally\" function (default keybind Super+F) uses.</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Maximised horizontal width</property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"maximize-width-percent\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"adjustment\">maximize_width_percent_scale</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"tooltip_text\" translatable=\"yes\">Enables handling maximize events (like double clicking the header bar) by stretching window width but not going out of the tiling margins</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Maximize within tiling</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"maximize-within-tiling\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"tooltip_text\" translatable=\"yes\">Enables mouse scrolling on Top Bar to switch window (left/right)</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Mouse scrolling on Top Bar switches window (left/right)</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSwitch\" id=\"topbar-mouse-scroll-enable\">\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"margin_end\">12</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"wrap\">True</property>\n                                <property name=\"label\" translatable=\"yes\">Availble options for the &lt;i&gt;open window position&lt;/i&gt; button. \n\nSelected options will be cycled through when clicking the\nbutton or using the &lt;i&gt;Switch between positions for creating windows (e.g. right, left)&lt;/i&gt; shortcut.\n                                </property>\n                                <property name=\"use_markup\">1</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkListBox\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"selection_mode\">none</property>\n                                <style>\n                                  <class name=\"frame\" />\n                                </style>\n                                <child>\n                                  <object class=\"GtkListBoxRow\">\n                                    <property name=\"activatable\">False</property>\n                                    <property name=\"focusable\">False</property>\n                                    <child>\n                                      <object class=\"GtkGrid\">\n                                        <property name=\"focusable\">False</property>\n                                        <property name=\"margin_start\">6</property>\n                                        <property name=\"margin_end\">6</property>\n                                        <property name=\"margin_top\">4</property>\n                                        <property name=\"margin_bottom\">4</property>\n                                        <property name=\"row_spacing\">5</property>\n                                        <property name=\"column_spacing\">12</property>\n                                        <child>\n                                          <object class=\"GtkLabel\">\n                                            <property name=\"focusable\">False</property>\n                                            <property name=\"hexpand\">1</property>\n                                            <property name=\"label\" translatable=\"yes\">RIGHT</property>\n                                            <property name=\"xalign\">0</property>\n                                            <layout>\n                                              <property name=\"column\">0</property>\n                                              <property name=\"row\">0</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkSwitch\" id=\"open-window-position-option-right\">\n                                            <layout>\n                                              <property name=\"column\">1</property>\n                                              <property name=\"row\">0</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkLabel\">\n                                            <property name=\"focusable\">False</property>\n                                            <property name=\"hexpand\">1</property>\n                                            <property name=\"label\" translatable=\"yes\">LEFT</property>\n                                            <property name=\"xalign\">0</property>\n                                            <layout>\n                                              <property name=\"column\">0</property>\n                                              <property name=\"row\">1</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkSwitch\" id=\"open-window-position-option-left\">\n                                            <layout>\n                                              <property name=\"column\">1</property>\n                                              <property name=\"row\">1</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkLabel\">\n                                            <property name=\"focusable\">False</property>\n                                            <property name=\"hexpand\">1</property>\n                                            <property name=\"label\" translatable=\"yes\">DOWN</property>\n                                            <property name=\"xalign\">0</property>\n                                            <layout>\n                                              <property name=\"column\">0</property>\n                                              <property name=\"row\">2</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkSwitch\" id=\"open-window-position-option-down\">\n                                            <layout>\n                                              <property name=\"column\">1</property>\n                                              <property name=\"row\">2</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkLabel\">\n                                            <property name=\"focusable\">False</property>\n                                            <property name=\"hexpand\">1</property>\n                                            <property name=\"label\" translatable=\"yes\">UP</property>\n                                            <property name=\"xalign\">0</property>\n                                            <layout>\n                                              <property name=\"column\">0</property>\n                                              <property name=\"row\">3</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkSwitch\" id=\"open-window-position-option-up\">\n                                            <layout>\n                                              <property name=\"column\">1</property>\n                                              <property name=\"row\">3</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkLabel\">\n                                            <property name=\"focusable\">False</property>\n                                            <property name=\"hexpand\">1</property>\n                                            <property name=\"label\" translatable=\"yes\">START</property>\n                                            <property name=\"xalign\">0</property>\n                                            <layout>\n                                              <property name=\"column\">0</property>\n                                              <property name=\"row\">4</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkSwitch\" id=\"open-window-position-option-start\">\n                                            <layout>\n                                              <property name=\"column\">1</property>\n                                              <property name=\"row\">4</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkLabel\">\n                                            <property name=\"focusable\">False</property>\n                                            <property name=\"hexpand\">1</property>\n                                            <property name=\"label\" translatable=\"yes\">END</property>\n                                            <property name=\"xalign\">0</property>\n                                            <layout>\n                                              <property name=\"column\">0</property>\n                                              <property name=\"row\">5</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                        <child>\n                                          <object class=\"GtkSwitch\" id=\"open-window-position-option-end\">\n                                            <layout>\n                                              <property name=\"column\">1</property>\n                                              <property name=\"row\">5</property>\n                                            </layout>\n                                          </object>\n                                        </child>\n                                      </object>\n                                    </child>\n                                  </object>\n                                </child>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkLabel\">\n                    <property name=\"halign\">start</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"label\" translatable=\"yes\">Three-finger Swipe Sensitivity</property>\n                    <attributes>\n                      <attribute name=\"weight\" value=\"bold\" />\n                    </attributes>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkListBox\">\n                    <property name=\"focusable\">False</property>\n                    <property name=\"selection_mode\">none</property>\n                    <property name=\"margin-bottom\">16</property>\n                    <style>\n                      <class name=\"frame\" />\n                    </style>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\" id=\"workspace_grid7\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">16</property>\n                            <property name=\"row_spacing\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"workspace_label1\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Horizontal sensitivity</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"horizontal-sensitivity\">\n                                <property name=\"can_focus\">True</property>\n                                <property name=\"editable\">True</property>\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"text\" translatable=\"yes\">0</property>\n                                <property name=\"adjustment\">horizontal-sensitivity-adjustment</property>\n                                <property name=\"digits\">1</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\" id=\"workspace_label3\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Horizontal friction</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"horizontal-friction\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"text\" translatable=\"yes\">0,0</property>\n                                <property name=\"adjustment\">horizontal-friction-adjustment</property>\n                                <property name=\"digits\">1</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkListBoxRow\">\n                        <property name=\"activatable\">False</property>\n                        <property name=\"focusable\">False</property>\n                        <child>\n                          <object class=\"GtkGrid\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"margin_start\">12</property>\n                            <property name=\"margin_end\">12</property>\n                            <property name=\"margin_top\">6</property>\n                            <property name=\"margin_bottom\">6</property>\n                            <property name=\"row_spacing\">12</property>\n                            <property name=\"column_spacing\">32</property>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Vertical sensitivity</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"vertical-sensitivity\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"text\" translatable=\"yes\">0</property>\n                                <property name=\"adjustment\">vertical-sensitivity-adjustment</property>\n                                <property name=\"digits\">1</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">0</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkLabel\">\n                                <property name=\"focusable\">False</property>\n                                <property name=\"hexpand\">1</property>\n                                <property name=\"label\" translatable=\"yes\">Vertical friction</property>\n                                <property name=\"xalign\">0</property>\n                                <layout>\n                                  <property name=\"column\">0</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                            <child>\n                              <object class=\"GtkSpinButton\" id=\"vertical-friction\">\n                                <property name=\"width_chars\">2</property>\n                                <property name=\"max_width_chars\">2</property>\n                                <property name=\"text\" translatable=\"yes\">0,0</property>\n                                <property name=\"adjustment\">vertical-friction-adjustment</property>\n                                <property name=\"digits\">1</property>\n                                <property name=\"snap_to_ticks\">1</property>\n                                <property name=\"numeric\">1</property>\n                                <property name=\"update_policy\">always</property>\n                                <layout>\n                                  <property name=\"column\">1</property>\n                                  <property name=\"row\">1</property>\n                                </layout>\n                              </object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </object>\n  <object class=\"AdwPreferencesPage\" id=\"about_page\">\n    <property name=\"title\" translatable=\"yes\">About</property>\n    <property name=\"icon-name\">help-about-symbolic</property>\n    <child>\n      <object class=\"GtkScrolledWindow\" id=\"about_scrolledWindow\">\n        <property name=\"hscrollbar_policy\">never</property>\n        <child>\n          <object class=\"GtkViewport\">\n            <property name=\"focusable\">False</property>\n            <property name=\"vexpand\">True</property>\n            <child>\n              <object class=\"GtkBox\">\n                <property name=\"halign\">center</property>\n                <property name=\"margin_start\">36</property>\n                <property name=\"margin_end\">36</property>\n                <property name=\"margin_top\">16</property>\n                <property name=\"margin_bottom\">16</property>\n                <property name=\"orientation\">vertical</property>\n                <property name=\"spacing\">12</property>\n                <property name=\"width_request\">480</property>\n                <child>\n                  <object class=\"GtkLabel\">\n                    <property name=\"halign\">start</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"label\" translatable=\"yes\">PaperWM Version Information</property>\n                    <attributes>\n                      <attribute name=\"weight\" value=\"bold\" />\n                    </attributes>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkTextView\" id=\"about_version_textView\">\n                    <property name=\"editable\">False</property>\n                    <property name=\"vexpand\">True</property>\n                    <property name=\"top-margin\">6</property>\n                    <property name=\"right-margin\">6</property>\n                    <property name=\"bottom-margin\">6</property>\n                    <property name=\"left-margin\">6</property>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkButton\" id=\"about_version_copy_button\">\n                    <property name=\"label\">Copy to Clipboard</property>\n                    <property name=\"tooltip_text\" translatable=\"yes\">Copies PaperWM version information to clipboard</property>\n                    <style>\n                      <class name=\"suggested-action\" />\n                    </style>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </object>\n</interface>\n"
        },
        {
          "name": "WinpropsPane.ui",
          "type": "blob",
          "size": 2.9013671875,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<interface>\n  <requires lib=\"gtk\" version=\"4.0\"/>\n  <template class=\"WinpropsPane\" parent=\"GtkBox\">\n    <property name=\"focusable\">False</property>\n    <property name=\"orientation\">vertical</property>\n    <child>\n      <object class=\"GtkBox\">\n          <property name=\"focusable\">False</property>\n          <property name=\"halign\">center</property>\n          <property name=\"orientation\">horizontal</property>\n          <property name=\"spacing\">12</property>\n      <child>\n        <object class=\"GtkSearchEntry\" id=\"search\">\n          <property name=\"activates-default\">False</property>\n          <property name=\"halign\">center</property>\n          <property name=\"margin-top\">12</property>\n        </object>\n      </child>\n      <child>\n        <object class=\"GtkButton\" id=\"addButton\">\n          <property name=\"label\" translatable=\"yes\">Add Winprop</property>\n          <property name=\"hexpand\">True</property>\n          <property name=\"halign\">center</property>\n          <property name=\"margin-top\">12px</property>\n          <signal name=\"clicked\" handler=\"_onAddButtonClicked\" />\n          <style>\n            <class name=\"winprops\" />\n            <class name=\"add-button\" />\n            <class name=\"suggested-action\" />\n          </style>\n        </object>\n      </child>\n      </object>\n    </child>\n    <child>\n      <object class=\"GtkLabel\">\n        <property name=\"label\" translatable=\"yes\">&lt;i&gt;Winprops allow setting window properties to be applied to new windows&lt;/i&gt;</property>\n        <property name=\"max_width_chars\">-1</property>\n        <property name=\"margin-top\">12px</property>\n        <property name=\"margin-bottom\">2px</property>\n        <property name=\"use_markup\">True</property>\n      </object>\n    </child>\n    <child>\n      <object class=\"GtkScrolledWindow\" id=\"scrolledWindow\">\n        <property name=\"hscrollbar_policy\">never</property>\n        <child>\n          <object class=\"GtkViewport\">\n            <property name=\"focusable\">False</property>\n            <property name=\"vexpand\">True</property>\n            <child>\n              <object class=\"GtkListBox\" id=\"listbox\">\n                <property name=\"hexpand\">True</property>\n                <property name=\"margin_start\">36</property>\n                <property name=\"margin_end\">36</property>\n                <property name=\"margin_top\">16</property>\n                <property name=\"margin_bottom\">36</property>\n                <property name=\"width_request\">480</property>\n                <property name=\"show_separators\">True</property>\n                <style>\n                  <class name=\"keybindings\" />\n                  <class name=\"winprops\" />\n                  <class name=\"frame\" />\n                </style>\n                <signal name=\"row-activated\" handler=\"_onRowActivated\" />\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>\n"
        },
        {
          "name": "WinpropsRow.ui",
          "type": "blob",
          "size": 14.828125,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<interface>\n  <requires lib=\"gtk\" version=\"4.0\" />\n  <template class=\"WinpropsRow\" parent=\"GtkListBoxRow\">\n    <style>\n      <class name=\"winprop-row\" />\n    </style>\n    <property name=\"selectable\">False</property>\n    <property name=\"activatable\">True</property>\n    <property name=\"focusable\">True</property>\n    <child>\n      <object class=\"GtkBox\">\n        <property name=\"orientation\">vertical</property>\n        <child>\n          <object class=\"GtkBox\" id=\"header\">\n            <property name=\"spacing\">12</property>\n            <style>\n              <class name=\"header\" />\n            </style>\n            <child>\n              <object class=\"GtkLabel\" id=\"descLabel\">\n                <style>\n                  <class name=\"description\" />\n                </style>\n                <property name=\"ellipsize\">end</property>\n                <property name=\"halign\">start</property>\n                <property name=\"lines\">1</property>\n                <property name=\"wrap\">False</property>\n                <property name=\"xalign\">0</property>\n              </object>\n            </child>\n            <child>\n              <object class=\"GtkLabel\" id=\"accelLabel\">\n                <property name=\"hexpand\">True</property>\n                <property name=\"halign\">end</property>\n                <property name=\"xalign\">1.0</property>\n                <property name=\"use-markup\">True</property>\n                <style>\n                  <class name=\"dim-label\" />\n                </style>\n              </object>\n            </child>\n          </object>\n        </child>\n        <child>\n          <object class=\"GtkRevealer\" id=\"revealer\">\n            <child>\n              <object class=\"GtkGrid\">\n                <property name=\"hexpand\">True</property>\n\n                <child>\n                  <object class=\"GtkListBox\" id=\"optionList\">\n                    <property name=\"activate-on-single-click\">True</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"selection-mode\">none</property>\n                    <style>\n                      <class name=\"option-list\" />\n                    </style>\n                    <layout>\n                      <property name=\"row\">0</property>\n                      <property name=\"column\">0</property>\n                      <property name=\"column-span\">2</property>\n                    </layout>\n                    <child>\n                      <object class=\"GtkGrid\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"margin_start\">12</property>\n                        <property name=\"margin_end\">12</property>\n                        <property name=\"margin_top\">6</property>\n                        <property name=\"margin_bottom\">6</property>\n                        <property name=\"column_spacing\">32</property>\n                        <property name=\"tooltip_markup\" translatable=\"yes\">Window class value used to identify windows to have this winprop applied.  Can be a &lt;b&gt;string&lt;/b&gt; or &lt;b&gt;javascript regex expression literal&lt;/b&gt;, e.g. &lt;b&gt;/.*terminal.*/i&lt;/b&gt; would match on any value that contains the word &lt;b&gt;terminal&lt;/b&gt; (case-insensitive).</property>\n                        <child>\n                          <object class=\"GtkLabel\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"label\" translatable=\"yes\">wm_class</property>\n                            <property name=\"xalign\">0</property>\n                            <layout>\n                              <property name=\"column\">0</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkEntry\" id=\"wmClass\">\n                            <property name=\"width_chars\">24</property>\n                            <property name=\"max_width_chars\">24</property>\n                            <layout>\n                              <property name=\"column\">2</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkGrid\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"margin_start\">12</property>\n                        <property name=\"margin_end\">12</property>\n                        <property name=\"margin_top\">6</property>\n                        <property name=\"margin_bottom\">6</property>\n                        <property name=\"column_spacing\">32</property>\n                        <property name=\"tooltip_markup\" translatable=\"yes\">Window title value used to identify windows to have this winprop applied.  Can be a &lt;b&gt;string&lt;/b&gt; or &lt;b&gt;javascript regex expression literal&lt;/b&gt;, e.g. &lt;b&gt;/.*terminal.*/i&lt;/b&gt; would match on any value that contains the word &lt;b&gt;terminal&lt;/b&gt; (case-insensitive).</property>\n                        <child>\n                          <object class=\"GtkLabel\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"label\" translatable=\"yes\">title</property>\n                            <property name=\"xalign\">0</property>\n                            <layout>\n                              <property name=\"column\">0</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkEntry\" id=\"title\">\n                            <property name=\"width_chars\">24</property>\n                            <property name=\"max_width_chars\">24</property>\n                            <layout>\n                              <property name=\"column\">2</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkGrid\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"margin_start\">12</property>\n                        <property name=\"margin_end\">12</property>\n                        <property name=\"margin_top\">6</property>\n                        <property name=\"margin_bottom\">6</property>\n                        <property name=\"column_spacing\">32</property>\n                        <child>\n                          <object class=\"GtkLabel\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"label\" translatable=\"yes\">Open on scratch layer</property>\n                            <property name=\"xalign\">0</property>\n                            <layout>\n                              <property name=\"column\">0</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkSwitch\" id=\"scratchLayer\">\n                            <layout>\n                              <property name=\"column\">1</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkGrid\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"margin_start\">12</property>\n                        <property name=\"margin_end\">12</property>\n                        <property name=\"margin_top\">6</property>\n                        <property name=\"margin_bottom\">6</property>\n                        <property name=\"column_spacing\">32</property>\n                        <property name=\"tooltip_markup\" translatable=\"yes\">Preferred width.  Can be a percent value (e.g. &lt;i&gt;50%&lt;/i&gt;) or pixel value (e.g. &lt;i&gt;500px&lt;/i&gt;). &lt;i&gt;Note: this property is ignored for windows opened on the scratch layer.&lt;/i&gt;</property>\n                        <child>\n                          <object class=\"GtkLabel\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"use_markup\">True</property>\n                            <property name=\"label\" translatable=\"yes\">Preferred width &lt;i&gt;(with &lt;b&gt;%&lt;/b&gt; or &lt;b&gt;px&lt;/b&gt; unit)&lt;/i&gt;</property>\n                            <property name=\"xalign\">0</property>\n                            <layout>\n                              <property name=\"column\">0</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkEntry\" id=\"preferredWidth\">\n                            <property name=\"width_chars\">12</property>\n                            <property name=\"max_width_chars\">12</property>\n                            <layout>\n                              <property name=\"column\">2</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkGrid\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"margin_start\">12</property>\n                        <property name=\"margin_end\">12</property>\n                        <property name=\"margin_top\">6</property>\n                        <property name=\"margin_bottom\">6</property>\n                        <property name=\"column_spacing\">32</property>\n                        <child>\n                          <object class=\"GtkLabel\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"use_markup\">True</property>\n                            <property name=\"label\" translatable=\"yes\">Insert into workspace</property>\n                            <property name=\"xalign\">0</property>\n                            <layout>\n                              <property name=\"column\">0</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkComboBoxText\" id=\"space\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"hexpand\">0</property>\n                            <property name=\"width-request\">120</property>\n                            <!-- <property name=\"width_chars\">12</property> -->\n                            <!-- <property name=\"max_width_chars\">12</property> -->\n                            <layout>\n                              <property name=\"column\">2</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                    <child>\n                      <object class=\"GtkGrid\">\n                        <property name=\"focusable\">False</property>\n                        <property name=\"margin_start\">12</property>\n                        <property name=\"margin_end\">12</property>\n                        <property name=\"margin_top\">6</property>\n                        <property name=\"margin_bottom\">6</property>\n                        <property name=\"column_spacing\">32</property>\n                        <child>\n                          <object class=\"GtkLabel\">\n                            <property name=\"focusable\">False</property>\n                            <property name=\"hexpand\">1</property>\n                            <property name=\"use_markup\">True</property>\n                            <property name=\"label\" translatable=\"yes\">Focus window after inserting into workspace</property>\n                            <property name=\"xalign\">0</property>\n                            <layout>\n                              <property name=\"column\">0</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                        <child>\n                          <object class=\"GtkSwitch\" id=\"focus\">\n                            <layout>\n                              <property name=\"column\">2</property>\n                              <property name=\"row\">0</property>\n                            </layout>\n                          </object>\n                        </child>\n                      </object>\n                    </child>\n                  </object>\n                </child>\n                <child>\n                  <object class=\"GtkButton\" id=\"deleteButton\">\n                    <property name=\"label\" translatable=\"yes\">Delete</property>\n                    <property name=\"hexpand\">True</property>\n                    <property name=\"halign\">end</property>\n                    <property name=\"margin-top\">8px</property>\n                    <property name=\"margin-end\">12px</property>\n                    <property name=\"margin-bottom\">8px</property>\n                    <layout>\n                      <property name=\"row\">1</property>\n                      <property name=\"column\">1</property>\n                    </layout>\n                    <style>\n                      <class name=\"destructive-action\" />\n                    </style>\n                    <signal name=\"clicked\" handler=\"_onDeleteButtonClicked\" />\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>\n"
        },
        {
          "name": "acceleratorparse.js",
          "type": "blob",
          "size": 93.4833984375,
          "content": "/**\n * Provides replacement for Gtk.accelerator_parse.\n */\nexport class AcceleratorParse {\n    constructor() {\n        /**\n         * GDK keystr mask values.\n         * Refer to:\n         * https://gitlab.gnome.org/GNOME/gtk/-/blob/4.13.0/gdk/gdkenums.h?ref_type=tags#L115\n         */\n        this.GDK_SHIFT_MASK    = 1 << 0;\n        this.GDK_CONTROL_MASK  = 1 << 2;\n        this.GDK_ALT_MASK      = 1 << 3;\n        this.GDK_SUPER_MASK    = 1 << 26;\n        this.GDK_HYPER_MASK    = 1 << 27;\n        this.GDK_META_MASK     = 1 << 28;\n    }\n\n    accelerator_parse(keystr) {\n        let mask = this.accelerator_mask(keystr);\n        const mods = this.accelerator_mods(keystr);\n\n        // remove mods from keystr\n        let key = keystr;\n        mods.forEach(m => {\n            key = key.replace(m, '');\n        });\n        key = key.trim();\n\n        // now lookup key in map\n        this._initKeycodeMap();\n        let ok = true;\n        const mapped = this.keycodeMap.get(key);\n        if (mapped) {\n            key = mapped;\n        }\n        else {\n            ok = false;\n            key = 0;\n            mask = 0;\n        }\n\n        // console.log(keystr, key, mask);\n        return [ok, key, mask];\n    }\n\n    /**\n     * Returns array of mods for a keystr, e.g. ['<Control>', '<Shift>', '<Alt>'].\n     * @param {String} keystr\n     */\n    accelerator_mods(keystr) {\n        return keystr.match(/<.*?>/g) ?? [];\n    }\n\n    /**\n     * Returns the GDK mask value for a keystr (keybind string representation).\n     * Refer to:\n     * https://gitlab.gnome.org/GNOME/gtk/-/blob/4.13.0/gdk/gdkenums.h?ref_type=tags#L115\n     * https://gitlab.gnome.org/GNOME/gtk/-/blob/4.13.0/gtk/gtkaccelgroup.c#L571\n     * @param {String} keystr\n     */\n    accelerator_mask(keystr) {\n        // need to extact all mods from keystr\n        const mods = this.accelerator_mods(keystr);\n        let result = 0;\n        for (let mod of mods) {\n            switch (mod.toLowerCase()) {\n            case '<shift>':\n                result |= this.GDK_SHIFT_MASK;\n                break;\n            case '<control>':\n            case '<ctrl>':\n            case '<primary>':\n                result |= this.GDK_CONTROL_MASK;\n                break;\n            case '<alt>':\n                result |= this.GDK_ALT_MASK;\n                break;\n            case '<super>':\n                result |= this.GDK_SUPER_MASK;\n                break;\n            case '<hyper>':\n                result |= this.GDK_HYPER_MASK;\n                break;\n            case '<meta>':\n                result |= this.GDK_META_MASK;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Replicates Gdk full keyset.\n     * https://gitlab.gnome.org/GNOME/gtk/-/blob/4.13.0/gdk/gdkkeysyms.h?ref_type=tags\n     */\n    _initKeycodeMap(force = false) {\n        if (!force && this.keycodeMap) {\n            return;\n        }\n        const map = new Map();\n        map.set('VoidSymbol', 0xffffff);\n        map.set('BackSpace', 0xff08);\n        map.set('Tab', 0xff09);\n        map.set('Linefeed', 0xff0a);\n        map.set('Clear', 0xff0b);\n        map.set('Return', 0xff0d);\n        map.set('Pause', 0xff13);\n        map.set('Scroll_Lock', 0xff14);\n        map.set('Sys_Req', 0xff15);\n        map.set('Escape', 0xff1b);\n        map.set('Delete', 0xffff);\n        map.set('Multi_key', 0xff20);\n        map.set('Codeinput', 0xff37);\n        map.set('SingleCandidate', 0xff3c);\n        map.set('MultipleCandidate', 0xff3d);\n        map.set('PreviousCandidate', 0xff3e);\n        map.set('Kanji', 0xff21);\n        map.set('Muhenkan', 0xff22);\n        map.set('Henkan_Mode', 0xff23);\n        map.set('Henkan', 0xff23);\n        map.set('Romaji', 0xff24);\n        map.set('Hiragana', 0xff25);\n        map.set('Katakana', 0xff26);\n        map.set('Hiragana_Katakana', 0xff27);\n        map.set('Zenkaku', 0xff28);\n        map.set('Hankaku', 0xff29);\n        map.set('Zenkaku_Hankaku', 0xff2a);\n        map.set('Touroku', 0xff2b);\n        map.set('Massyo', 0xff2c);\n        map.set('Kana_Lock', 0xff2d);\n        map.set('Kana_Shift', 0xff2e);\n        map.set('Eisu_Shift', 0xff2f);\n        map.set('Eisu_toggle', 0xff30);\n        map.set('Kanji_Bangou', 0xff37);\n        map.set('Zen_Koho', 0xff3d);\n        map.set('Mae_Koho', 0xff3e);\n        map.set('Home', 0xff50);\n        map.set('Left', 0xff51);\n        map.set('Up', 0xff52);\n        map.set('Right', 0xff53);\n        map.set('Down', 0xff54);\n        map.set('Prior', 0xff55);\n        map.set('Page_Up', 0xff55);\n        map.set('Next', 0xff56);\n        map.set('Page_Down', 0xff56);\n        map.set('End', 0xff57);\n        map.set('Begin', 0xff58);\n        map.set('Select', 0xff60);\n        map.set('Print', 0xff61);\n        map.set('Execute', 0xff62);\n        map.set('Insert', 0xff63);\n        map.set('Undo', 0xff65);\n        map.set('Redo', 0xff66);\n        map.set('Menu', 0xff67);\n        map.set('Find', 0xff68);\n        map.set('Cancel', 0xff69);\n        map.set('Help', 0xff6a);\n        map.set('Break', 0xff6b);\n        map.set('Mode_switch', 0xff7e);\n        map.set('script_switch', 0xff7e);\n        map.set('Num_Lock', 0xff7f);\n        map.set('KP_Space', 0xff80);\n        map.set('KP_Tab', 0xff89);\n        map.set('KP_Enter', 0xff8d);\n        map.set('KP_F1', 0xff91);\n        map.set('KP_F2', 0xff92);\n        map.set('KP_F3', 0xff93);\n        map.set('KP_F4', 0xff94);\n        map.set('KP_Home', 0xff95);\n        map.set('KP_Left', 0xff96);\n        map.set('KP_Up', 0xff97);\n        map.set('KP_Right', 0xff98);\n        map.set('KP_Down', 0xff99);\n        map.set('KP_Prior', 0xff9a);\n        map.set('KP_Page_Up', 0xff9a);\n        map.set('KP_Next', 0xff9b);\n        map.set('KP_Page_Down', 0xff9b);\n        map.set('KP_End', 0xff9c);\n        map.set('KP_Begin', 0xff9d);\n        map.set('KP_Insert', 0xff9e);\n        map.set('KP_Delete', 0xff9f);\n        map.set('KP_Equal', 0xffbd);\n        map.set('KP_Multiply', 0xffaa);\n        map.set('KP_Add', 0xffab);\n        map.set('KP_Separator', 0xffac);\n        map.set('KP_Subtract', 0xffad);\n        map.set('KP_Decimal', 0xffae);\n        map.set('KP_Divide', 0xffaf);\n        map.set('KP_0', 0xffb0);\n        map.set('KP_1', 0xffb1);\n        map.set('KP_2', 0xffb2);\n        map.set('KP_3', 0xffb3);\n        map.set('KP_4', 0xffb4);\n        map.set('KP_5', 0xffb5);\n        map.set('KP_6', 0xffb6);\n        map.set('KP_7', 0xffb7);\n        map.set('KP_8', 0xffb8);\n        map.set('KP_9', 0xffb9);\n        map.set('F1', 0xffbe);\n        map.set('F2', 0xffbf);\n        map.set('F3', 0xffc0);\n        map.set('F4', 0xffc1);\n        map.set('F5', 0xffc2);\n        map.set('F6', 0xffc3);\n        map.set('F7', 0xffc4);\n        map.set('F8', 0xffc5);\n        map.set('F9', 0xffc6);\n        map.set('F10', 0xffc7);\n        map.set('F11', 0xffc8);\n        map.set('L1', 0xffc8);\n        map.set('F12', 0xffc9);\n        map.set('L2', 0xffc9);\n        map.set('F13', 0xffca);\n        map.set('L3', 0xffca);\n        map.set('F14', 0xffcb);\n        map.set('L4', 0xffcb);\n        map.set('F15', 0xffcc);\n        map.set('L5', 0xffcc);\n        map.set('F16', 0xffcd);\n        map.set('L6', 0xffcd);\n        map.set('F17', 0xffce);\n        map.set('L7', 0xffce);\n        map.set('F18', 0xffcf);\n        map.set('L8', 0xffcf);\n        map.set('F19', 0xffd0);\n        map.set('L9', 0xffd0);\n        map.set('F20', 0xffd1);\n        map.set('L10', 0xffd1);\n        map.set('F21', 0xffd2);\n        map.set('R1', 0xffd2);\n        map.set('F22', 0xffd3);\n        map.set('R2', 0xffd3);\n        map.set('F23', 0xffd4);\n        map.set('R3', 0xffd4);\n        map.set('F24', 0xffd5);\n        map.set('R4', 0xffd5);\n        map.set('F25', 0xffd6);\n        map.set('R5', 0xffd6);\n        map.set('F26', 0xffd7);\n        map.set('R6', 0xffd7);\n        map.set('F27', 0xffd8);\n        map.set('R7', 0xffd8);\n        map.set('F28', 0xffd9);\n        map.set('R8', 0xffd9);\n        map.set('F29', 0xffda);\n        map.set('R9', 0xffda);\n        map.set('F30', 0xffdb);\n        map.set('R10', 0xffdb);\n        map.set('F31', 0xffdc);\n        map.set('R11', 0xffdc);\n        map.set('F32', 0xffdd);\n        map.set('R12', 0xffdd);\n        map.set('F33', 0xffde);\n        map.set('R13', 0xffde);\n        map.set('F34', 0xffdf);\n        map.set('R14', 0xffdf);\n        map.set('F35', 0xffe0);\n        map.set('R15', 0xffe0);\n        map.set('Shift_L', 0xffe1);\n        map.set('Shift_R', 0xffe2);\n        map.set('Control_L', 0xffe3);\n        map.set('Control_R', 0xffe4);\n        map.set('Caps_Lock', 0xffe5);\n        map.set('Shift_Lock', 0xffe6);\n        map.set('Meta_L', 0xffe7);\n        map.set('Meta_R', 0xffe8);\n        map.set('Alt_L', 0xffe9);\n        map.set('Alt_R', 0xffea);\n        map.set('Super_L', 0xffeb);\n        map.set('Super_R', 0xffec);\n        map.set('Hyper_L', 0xffed);\n        map.set('Hyper_R', 0xffee);\n        map.set('ISO_Lock', 0xfe01);\n        map.set('ISO_Level2_Latch', 0xfe02);\n        map.set('ISO_Level3_Shift', 0xfe03);\n        map.set('ISO_Level3_Latch', 0xfe04);\n        map.set('ISO_Level3_Lock', 0xfe05);\n        map.set('ISO_Level5_Shift', 0xfe11);\n        map.set('ISO_Level5_Latch', 0xfe12);\n        map.set('ISO_Level5_Lock', 0xfe13);\n        map.set('ISO_Group_Shift', 0xff7e);\n        map.set('ISO_Group_Latch', 0xfe06);\n        map.set('ISO_Group_Lock', 0xfe07);\n        map.set('ISO_Next_Group', 0xfe08);\n        map.set('ISO_Next_Group_Lock', 0xfe09);\n        map.set('ISO_Prev_Group', 0xfe0a);\n        map.set('ISO_Prev_Group_Lock', 0xfe0b);\n        map.set('ISO_First_Group', 0xfe0c);\n        map.set('ISO_First_Group_Lock', 0xfe0d);\n        map.set('ISO_Last_Group', 0xfe0e);\n        map.set('ISO_Last_Group_Lock', 0xfe0f);\n        map.set('ISO_Left_Tab', 0xfe20);\n        map.set('ISO_Move_Line_Up', 0xfe21);\n        map.set('ISO_Move_Line_Down', 0xfe22);\n        map.set('ISO_Partial_Line_Up', 0xfe23);\n        map.set('ISO_Partial_Line_Down', 0xfe24);\n        map.set('ISO_Partial_Space_Left', 0xfe25);\n        map.set('ISO_Partial_Space_Right', 0xfe26);\n        map.set('ISO_Set_Margin_Left', 0xfe27);\n        map.set('ISO_Set_Margin_Right', 0xfe28);\n        map.set('ISO_Release_Margin_Left', 0xfe29);\n        map.set('ISO_Release_Margin_Right', 0xfe2a);\n        map.set('ISO_Release_Both_Margins', 0xfe2b);\n        map.set('ISO_Fast_Cursor_Left', 0xfe2c);\n        map.set('ISO_Fast_Cursor_Right', 0xfe2d);\n        map.set('ISO_Fast_Cursor_Up', 0xfe2e);\n        map.set('ISO_Fast_Cursor_Down', 0xfe2f);\n        map.set('ISO_Continuous_Underline', 0xfe30);\n        map.set('ISO_Discontinuous_Underline', 0xfe31);\n        map.set('ISO_Emphasize', 0xfe32);\n        map.set('ISO_Center_Object', 0xfe33);\n        map.set('ISO_Enter', 0xfe34);\n        map.set('dead_grave', 0xfe50);\n        map.set('dead_acute', 0xfe51);\n        map.set('dead_circumflex', 0xfe52);\n        map.set('dead_tilde', 0xfe53);\n        map.set('dead_perispomeni', 0xfe53);\n        map.set('dead_macron', 0xfe54);\n        map.set('dead_breve', 0xfe55);\n        map.set('dead_abovedot', 0xfe56);\n        map.set('dead_diaeresis', 0xfe57);\n        map.set('dead_abovering', 0xfe58);\n        map.set('dead_doubleacute', 0xfe59);\n        map.set('dead_caron', 0xfe5a);\n        map.set('dead_cedilla', 0xfe5b);\n        map.set('dead_ogonek', 0xfe5c);\n        map.set('dead_iota', 0xfe5d);\n        map.set('dead_voiced_sound', 0xfe5e);\n        map.set('dead_semivoiced_sound', 0xfe5f);\n        map.set('dead_belowdot', 0xfe60);\n        map.set('dead_hook', 0xfe61);\n        map.set('dead_horn', 0xfe62);\n        map.set('dead_stroke', 0xfe63);\n        map.set('dead_abovecomma', 0xfe64);\n        map.set('dead_psili', 0xfe64);\n        map.set('dead_abovereversedcomma', 0xfe65);\n        map.set('dead_dasia', 0xfe65);\n        map.set('dead_doublegrave', 0xfe66);\n        map.set('dead_belowring', 0xfe67);\n        map.set('dead_belowmacron', 0xfe68);\n        map.set('dead_belowcircumflex', 0xfe69);\n        map.set('dead_belowtilde', 0xfe6a);\n        map.set('dead_belowbreve', 0xfe6b);\n        map.set('dead_belowdiaeresis', 0xfe6c);\n        map.set('dead_invertedbreve', 0xfe6d);\n        map.set('dead_belowcomma', 0xfe6e);\n        map.set('dead_currency', 0xfe6f);\n        map.set('dead_lowline', 0xfe90);\n        map.set('dead_aboveverticalline', 0xfe91);\n        map.set('dead_belowverticalline', 0xfe92);\n        map.set('dead_longsolidusoverlay', 0xfe93);\n        map.set('dead_a', 0xfe80);\n        map.set('dead_A', 0xfe81);\n        map.set('dead_e', 0xfe82);\n        map.set('dead_E', 0xfe83);\n        map.set('dead_i', 0xfe84);\n        map.set('dead_I', 0xfe85);\n        map.set('dead_o', 0xfe86);\n        map.set('dead_O', 0xfe87);\n        map.set('dead_u', 0xfe88);\n        map.set('dead_U', 0xfe89);\n        map.set('dead_small_schwa', 0xfe8a);\n        map.set('dead_capital_schwa', 0xfe8b);\n        map.set('dead_greek', 0xfe8c);\n        map.set('First_Virtual_Screen', 0xfed0);\n        map.set('Prev_Virtual_Screen', 0xfed1);\n        map.set('Next_Virtual_Screen', 0xfed2);\n        map.set('Last_Virtual_Screen', 0xfed4);\n        map.set('Terminate_Server', 0xfed5);\n        map.set('AccessX_Enable', 0xfe70);\n        map.set('AccessX_Feedback_Enable', 0xfe71);\n        map.set('RepeatKeys_Enable', 0xfe72);\n        map.set('SlowKeys_Enable', 0xfe73);\n        map.set('BounceKeys_Enable', 0xfe74);\n        map.set('StickyKeys_Enable', 0xfe75);\n        map.set('MouseKeys_Enable', 0xfe76);\n        map.set('MouseKeys_Accel_Enable', 0xfe77);\n        map.set('Overlay1_Enable', 0xfe78);\n        map.set('Overlay2_Enable', 0xfe79);\n        map.set('AudibleBell_Enable', 0xfe7a);\n        map.set('Pointer_Left', 0xfee0);\n        map.set('Pointer_Right', 0xfee1);\n        map.set('Pointer_Up', 0xfee2);\n        map.set('Pointer_Down', 0xfee3);\n        map.set('Pointer_UpLeft', 0xfee4);\n        map.set('Pointer_UpRight', 0xfee5);\n        map.set('Pointer_DownLeft', 0xfee6);\n        map.set('Pointer_DownRight', 0xfee7);\n        map.set('Pointer_Button_Dflt', 0xfee8);\n        map.set('Pointer_Button1', 0xfee9);\n        map.set('Pointer_Button2', 0xfeea);\n        map.set('Pointer_Button3', 0xfeeb);\n        map.set('Pointer_Button4', 0xfeec);\n        map.set('Pointer_Button5', 0xfeed);\n        map.set('Pointer_DblClick_Dflt', 0xfeee);\n        map.set('Pointer_DblClick1', 0xfeef);\n        map.set('Pointer_DblClick2', 0xfef0);\n        map.set('Pointer_DblClick3', 0xfef1);\n        map.set('Pointer_DblClick4', 0xfef2);\n        map.set('Pointer_DblClick5', 0xfef3);\n        map.set('Pointer_Drag_Dflt', 0xfef4);\n        map.set('Pointer_Drag1', 0xfef5);\n        map.set('Pointer_Drag2', 0xfef6);\n        map.set('Pointer_Drag3', 0xfef7);\n        map.set('Pointer_Drag4', 0xfef8);\n        map.set('Pointer_Drag5', 0xfefd);\n        map.set('Pointer_EnableKeys', 0xfef9);\n        map.set('Pointer_Accelerate', 0xfefa);\n        map.set('Pointer_DfltBtnNext', 0xfefb);\n        map.set('Pointer_DfltBtnPrev', 0xfefc);\n        map.set('ch', 0xfea0);\n        map.set('Ch', 0xfea1);\n        map.set('CH', 0xfea2);\n        map.set('c_h', 0xfea3);\n        map.set('C_h', 0xfea4);\n        map.set('C_H', 0xfea5);\n        map.set('3270_Duplicate', 0xfd01);\n        map.set('3270_FieldMark', 0xfd02);\n        map.set('3270_Right2', 0xfd03);\n        map.set('3270_Left2', 0xfd04);\n        map.set('3270_BackTab', 0xfd05);\n        map.set('3270_EraseEOF', 0xfd06);\n        map.set('3270_EraseInput', 0xfd07);\n        map.set('3270_Reset', 0xfd08);\n        map.set('3270_Quit', 0xfd09);\n        map.set('3270_PA1', 0xfd0a);\n        map.set('3270_PA2', 0xfd0b);\n        map.set('3270_PA3', 0xfd0c);\n        map.set('3270_Test', 0xfd0d);\n        map.set('3270_Attn', 0xfd0e);\n        map.set('3270_CursorBlink', 0xfd0f);\n        map.set('3270_AltCursor', 0xfd10);\n        map.set('3270_KeyClick', 0xfd11);\n        map.set('3270_Jump', 0xfd12);\n        map.set('3270_Ident', 0xfd13);\n        map.set('3270_Rule', 0xfd14);\n        map.set('3270_Copy', 0xfd15);\n        map.set('3270_Play', 0xfd16);\n        map.set('3270_Setup', 0xfd17);\n        map.set('3270_Record', 0xfd18);\n        map.set('3270_ChangeScreen', 0xfd19);\n        map.set('3270_DeleteWord', 0xfd1a);\n        map.set('3270_ExSelect', 0xfd1b);\n        map.set('3270_CursorSelect', 0xfd1c);\n        map.set('3270_PrintScreen', 0xfd1d);\n        map.set('3270_Enter', 0xfd1e);\n        map.set('space', 0x020);\n        map.set('exclam', 0x021);\n        map.set('quotedbl', 0x022);\n        map.set('numbersign', 0x023);\n        map.set('dollar', 0x024);\n        map.set('percent', 0x025);\n        map.set('ampersand', 0x026);\n        map.set('apostrophe', 0x027);\n        map.set('quoteright', 0x027);\n        map.set('parenleft', 0x028);\n        map.set('parenright', 0x029);\n        map.set('asterisk', 0x02a);\n        map.set('plus', 0x02b);\n        map.set('comma', 0x02c);\n        map.set('minus', 0x02d);\n        map.set('period', 0x02e);\n        map.set('slash', 0x02f);\n        map.set('0', 0x030);\n        map.set('1', 0x031);\n        map.set('2', 0x032);\n        map.set('3', 0x033);\n        map.set('4', 0x034);\n        map.set('5', 0x035);\n        map.set('6', 0x036);\n        map.set('7', 0x037);\n        map.set('8', 0x038);\n        map.set('9', 0x039);\n        map.set('colon', 0x03a);\n        map.set('semicolon', 0x03b);\n        map.set('less', 0x03c);\n        map.set('equal', 0x03d);\n        map.set('greater', 0x03e);\n        map.set('question', 0x03f);\n        map.set('at', 0x040);\n        map.set('A', 0x041);\n        map.set('B', 0x042);\n        map.set('C', 0x043);\n        map.set('D', 0x044);\n        map.set('E', 0x045);\n        map.set('F', 0x046);\n        map.set('G', 0x047);\n        map.set('H', 0x048);\n        map.set('I', 0x049);\n        map.set('J', 0x04a);\n        map.set('K', 0x04b);\n        map.set('L', 0x04c);\n        map.set('M', 0x04d);\n        map.set('N', 0x04e);\n        map.set('O', 0x04f);\n        map.set('P', 0x050);\n        map.set('Q', 0x051);\n        map.set('R', 0x052);\n        map.set('S', 0x053);\n        map.set('T', 0x054);\n        map.set('U', 0x055);\n        map.set('V', 0x056);\n        map.set('W', 0x057);\n        map.set('X', 0x058);\n        map.set('Y', 0x059);\n        map.set('Z', 0x05a);\n        map.set('bracketleft', 0x05b);\n        map.set('backslash', 0x05c);\n        map.set('bracketright', 0x05d);\n        map.set('asciicircum', 0x05e);\n        map.set('underscore', 0x05f);\n        map.set('grave', 0x060);\n        map.set('quoteleft', 0x060);\n        map.set('a', 0x061);\n        map.set('b', 0x062);\n        map.set('c', 0x063);\n        map.set('d', 0x064);\n        map.set('e', 0x065);\n        map.set('f', 0x066);\n        map.set('g', 0x067);\n        map.set('h', 0x068);\n        map.set('i', 0x069);\n        map.set('j', 0x06a);\n        map.set('k', 0x06b);\n        map.set('l', 0x06c);\n        map.set('m', 0x06d);\n        map.set('n', 0x06e);\n        map.set('o', 0x06f);\n        map.set('p', 0x070);\n        map.set('q', 0x071);\n        map.set('r', 0x072);\n        map.set('s', 0x073);\n        map.set('t', 0x074);\n        map.set('u', 0x075);\n        map.set('v', 0x076);\n        map.set('w', 0x077);\n        map.set('x', 0x078);\n        map.set('y', 0x079);\n        map.set('z', 0x07a);\n        map.set('braceleft', 0x07b);\n        map.set('bar', 0x07c);\n        map.set('braceright', 0x07d);\n        map.set('asciitilde', 0x07e);\n        map.set('nobreakspace', 0x0a0);\n        map.set('exclamdown', 0x0a1);\n        map.set('cent', 0x0a2);\n        map.set('sterling', 0x0a3);\n        map.set('currency', 0x0a4);\n        map.set('yen', 0x0a5);\n        map.set('brokenbar', 0x0a6);\n        map.set('section', 0x0a7);\n        map.set('diaeresis', 0x0a8);\n        map.set('copyright', 0x0a9);\n        map.set('ordfeminine', 0x0aa);\n        map.set('guillemotleft', 0x0ab);\n        map.set('notsign', 0x0ac);\n        map.set('hyphen', 0x0ad);\n        map.set('registered', 0x0ae);\n        map.set('macron', 0x0af);\n        map.set('degree', 0x0b0);\n        map.set('plusminus', 0x0b1);\n        map.set('twosuperior', 0x0b2);\n        map.set('threesuperior', 0x0b3);\n        map.set('acute', 0x0b4);\n        map.set('mu', 0x0b5);\n        map.set('paragraph', 0x0b6);\n        map.set('periodcentered', 0x0b7);\n        map.set('cedilla', 0x0b8);\n        map.set('onesuperior', 0x0b9);\n        map.set('masculine', 0x0ba);\n        map.set('guillemotright', 0x0bb);\n        map.set('onequarter', 0x0bc);\n        map.set('onehalf', 0x0bd);\n        map.set('threequarters', 0x0be);\n        map.set('questiondown', 0x0bf);\n        map.set('Agrave', 0x0c0);\n        map.set('Aacute', 0x0c1);\n        map.set('Acircumflex', 0x0c2);\n        map.set('Atilde', 0x0c3);\n        map.set('Adiaeresis', 0x0c4);\n        map.set('Aring', 0x0c5);\n        map.set('AE', 0x0c6);\n        map.set('Ccedilla', 0x0c7);\n        map.set('Egrave', 0x0c8);\n        map.set('Eacute', 0x0c9);\n        map.set('Ecircumflex', 0x0ca);\n        map.set('Ediaeresis', 0x0cb);\n        map.set('Igrave', 0x0cc);\n        map.set('Iacute', 0x0cd);\n        map.set('Icircumflex', 0x0ce);\n        map.set('Idiaeresis', 0x0cf);\n        map.set('ETH', 0x0d0);\n        map.set('Eth', 0x0d0);\n        map.set('Ntilde', 0x0d1);\n        map.set('Ograve', 0x0d2);\n        map.set('Oacute', 0x0d3);\n        map.set('Ocircumflex', 0x0d4);\n        map.set('Otilde', 0x0d5);\n        map.set('Odiaeresis', 0x0d6);\n        map.set('multiply', 0x0d7);\n        map.set('Oslash', 0x0d8);\n        map.set('Ooblique', 0x0d8);\n        map.set('Ugrave', 0x0d9);\n        map.set('Uacute', 0x0da);\n        map.set('Ucircumflex', 0x0db);\n        map.set('Udiaeresis', 0x0dc);\n        map.set('Yacute', 0x0dd);\n        map.set('THORN', 0x0de);\n        map.set('Thorn', 0x0de);\n        map.set('ssharp', 0x0df);\n        map.set('agrave', 0x0e0);\n        map.set('aacute', 0x0e1);\n        map.set('acircumflex', 0x0e2);\n        map.set('atilde', 0x0e3);\n        map.set('adiaeresis', 0x0e4);\n        map.set('aring', 0x0e5);\n        map.set('ae', 0x0e6);\n        map.set('ccedilla', 0x0e7);\n        map.set('egrave', 0x0e8);\n        map.set('eacute', 0x0e9);\n        map.set('ecircumflex', 0x0ea);\n        map.set('ediaeresis', 0x0eb);\n        map.set('igrave', 0x0ec);\n        map.set('iacute', 0x0ed);\n        map.set('icircumflex', 0x0ee);\n        map.set('idiaeresis', 0x0ef);\n        map.set('eth', 0x0f0);\n        map.set('ntilde', 0x0f1);\n        map.set('ograve', 0x0f2);\n        map.set('oacute', 0x0f3);\n        map.set('ocircumflex', 0x0f4);\n        map.set('otilde', 0x0f5);\n        map.set('odiaeresis', 0x0f6);\n        map.set('division', 0x0f7);\n        map.set('oslash', 0x0f8);\n        map.set('ooblique', 0x0f8);\n        map.set('ugrave', 0x0f9);\n        map.set('uacute', 0x0fa);\n        map.set('ucircumflex', 0x0fb);\n        map.set('udiaeresis', 0x0fc);\n        map.set('yacute', 0x0fd);\n        map.set('thorn', 0x0fe);\n        map.set('ydiaeresis', 0x0ff);\n        map.set('Aogonek', 0x1a1);\n        map.set('breve', 0x1a2);\n        map.set('Lstroke', 0x1a3);\n        map.set('Lcaron', 0x1a5);\n        map.set('Sacute', 0x1a6);\n        map.set('Scaron', 0x1a9);\n        map.set('Scedilla', 0x1aa);\n        map.set('Tcaron', 0x1ab);\n        map.set('Zacute', 0x1ac);\n        map.set('Zcaron', 0x1ae);\n        map.set('Zabovedot', 0x1af);\n        map.set('aogonek', 0x1b1);\n        map.set('ogonek', 0x1b2);\n        map.set('lstroke', 0x1b3);\n        map.set('lcaron', 0x1b5);\n        map.set('sacute', 0x1b6);\n        map.set('caron', 0x1b7);\n        map.set('scaron', 0x1b9);\n        map.set('scedilla', 0x1ba);\n        map.set('tcaron', 0x1bb);\n        map.set('zacute', 0x1bc);\n        map.set('doubleacute', 0x1bd);\n        map.set('zcaron', 0x1be);\n        map.set('zabovedot', 0x1bf);\n        map.set('Racute', 0x1c0);\n        map.set('Abreve', 0x1c3);\n        map.set('Lacute', 0x1c5);\n        map.set('Cacute', 0x1c6);\n        map.set('Ccaron', 0x1c8);\n        map.set('Eogonek', 0x1ca);\n        map.set('Ecaron', 0x1cc);\n        map.set('Dcaron', 0x1cf);\n        map.set('Dstroke', 0x1d0);\n        map.set('Nacute', 0x1d1);\n        map.set('Ncaron', 0x1d2);\n        map.set('Odoubleacute', 0x1d5);\n        map.set('Rcaron', 0x1d8);\n        map.set('Uring', 0x1d9);\n        map.set('Udoubleacute', 0x1db);\n        map.set('Tcedilla', 0x1de);\n        map.set('racute', 0x1e0);\n        map.set('abreve', 0x1e3);\n        map.set('lacute', 0x1e5);\n        map.set('cacute', 0x1e6);\n        map.set('ccaron', 0x1e8);\n        map.set('eogonek', 0x1ea);\n        map.set('ecaron', 0x1ec);\n        map.set('dcaron', 0x1ef);\n        map.set('dstroke', 0x1f0);\n        map.set('nacute', 0x1f1);\n        map.set('ncaron', 0x1f2);\n        map.set('odoubleacute', 0x1f5);\n        map.set('rcaron', 0x1f8);\n        map.set('uring', 0x1f9);\n        map.set('udoubleacute', 0x1fb);\n        map.set('tcedilla', 0x1fe);\n        map.set('abovedot', 0x1ff);\n        map.set('Hstroke', 0x2a1);\n        map.set('Hcircumflex', 0x2a6);\n        map.set('Iabovedot', 0x2a9);\n        map.set('Gbreve', 0x2ab);\n        map.set('Jcircumflex', 0x2ac);\n        map.set('hstroke', 0x2b1);\n        map.set('hcircumflex', 0x2b6);\n        map.set('idotless', 0x2b9);\n        map.set('gbreve', 0x2bb);\n        map.set('jcircumflex', 0x2bc);\n        map.set('Cabovedot', 0x2c5);\n        map.set('Ccircumflex', 0x2c6);\n        map.set('Gabovedot', 0x2d5);\n        map.set('Gcircumflex', 0x2d8);\n        map.set('Ubreve', 0x2dd);\n        map.set('Scircumflex', 0x2de);\n        map.set('cabovedot', 0x2e5);\n        map.set('ccircumflex', 0x2e6);\n        map.set('gabovedot', 0x2f5);\n        map.set('gcircumflex', 0x2f8);\n        map.set('ubreve', 0x2fd);\n        map.set('scircumflex', 0x2fe);\n        map.set('kra', 0x3a2);\n        map.set('kappa', 0x3a2);\n        map.set('Rcedilla', 0x3a3);\n        map.set('Itilde', 0x3a5);\n        map.set('Lcedilla', 0x3a6);\n        map.set('Emacron', 0x3aa);\n        map.set('Gcedilla', 0x3ab);\n        map.set('Tslash', 0x3ac);\n        map.set('rcedilla', 0x3b3);\n        map.set('itilde', 0x3b5);\n        map.set('lcedilla', 0x3b6);\n        map.set('emacron', 0x3ba);\n        map.set('gcedilla', 0x3bb);\n        map.set('tslash', 0x3bc);\n        map.set('ENG', 0x3bd);\n        map.set('eng', 0x3bf);\n        map.set('Amacron', 0x3c0);\n        map.set('Iogonek', 0x3c7);\n        map.set('Eabovedot', 0x3cc);\n        map.set('Imacron', 0x3cf);\n        map.set('Ncedilla', 0x3d1);\n        map.set('Omacron', 0x3d2);\n        map.set('Kcedilla', 0x3d3);\n        map.set('Uogonek', 0x3d9);\n        map.set('Utilde', 0x3dd);\n        map.set('Umacron', 0x3de);\n        map.set('amacron', 0x3e0);\n        map.set('iogonek', 0x3e7);\n        map.set('eabovedot', 0x3ec);\n        map.set('imacron', 0x3ef);\n        map.set('ncedilla', 0x3f1);\n        map.set('omacron', 0x3f2);\n        map.set('kcedilla', 0x3f3);\n        map.set('uogonek', 0x3f9);\n        map.set('utilde', 0x3fd);\n        map.set('umacron', 0x3fe);\n        map.set('Wcircumflex', 0x1000174);\n        map.set('wcircumflex', 0x1000175);\n        map.set('Ycircumflex', 0x1000176);\n        map.set('ycircumflex', 0x1000177);\n        map.set('Babovedot', 0x1001e02);\n        map.set('babovedot', 0x1001e03);\n        map.set('Dabovedot', 0x1001e0a);\n        map.set('dabovedot', 0x1001e0b);\n        map.set('Fabovedot', 0x1001e1e);\n        map.set('fabovedot', 0x1001e1f);\n        map.set('Mabovedot', 0x1001e40);\n        map.set('mabovedot', 0x1001e41);\n        map.set('Pabovedot', 0x1001e56);\n        map.set('pabovedot', 0x1001e57);\n        map.set('Sabovedot', 0x1001e60);\n        map.set('sabovedot', 0x1001e61);\n        map.set('Tabovedot', 0x1001e6a);\n        map.set('tabovedot', 0x1001e6b);\n        map.set('Wgrave', 0x1001e80);\n        map.set('wgrave', 0x1001e81);\n        map.set('Wacute', 0x1001e82);\n        map.set('wacute', 0x1001e83);\n        map.set('Wdiaeresis', 0x1001e84);\n        map.set('wdiaeresis', 0x1001e85);\n        map.set('Ygrave', 0x1001ef2);\n        map.set('ygrave', 0x1001ef3);\n        map.set('OE', 0x13bc);\n        map.set('oe', 0x13bd);\n        map.set('Ydiaeresis', 0x13be);\n        map.set('overline', 0x47e);\n        map.set('kana_fullstop', 0x4a1);\n        map.set('kana_openingbracket', 0x4a2);\n        map.set('kana_closingbracket', 0x4a3);\n        map.set('kana_comma', 0x4a4);\n        map.set('kana_conjunctive', 0x4a5);\n        map.set('kana_middledot', 0x4a5);\n        map.set('kana_WO', 0x4a6);\n        map.set('kana_a', 0x4a7);\n        map.set('kana_i', 0x4a8);\n        map.set('kana_u', 0x4a9);\n        map.set('kana_e', 0x4aa);\n        map.set('kana_o', 0x4ab);\n        map.set('kana_ya', 0x4ac);\n        map.set('kana_yu', 0x4ad);\n        map.set('kana_yo', 0x4ae);\n        map.set('kana_tsu', 0x4af);\n        map.set('kana_tu', 0x4af);\n        map.set('prolongedsound', 0x4b0);\n        map.set('kana_A', 0x4b1);\n        map.set('kana_I', 0x4b2);\n        map.set('kana_U', 0x4b3);\n        map.set('kana_E', 0x4b4);\n        map.set('kana_O', 0x4b5);\n        map.set('kana_KA', 0x4b6);\n        map.set('kana_KI', 0x4b7);\n        map.set('kana_KU', 0x4b8);\n        map.set('kana_KE', 0x4b9);\n        map.set('kana_KO', 0x4ba);\n        map.set('kana_SA', 0x4bb);\n        map.set('kana_SHI', 0x4bc);\n        map.set('kana_SU', 0x4bd);\n        map.set('kana_SE', 0x4be);\n        map.set('kana_SO', 0x4bf);\n        map.set('kana_TA', 0x4c0);\n        map.set('kana_CHI', 0x4c1);\n        map.set('kana_TI', 0x4c1);\n        map.set('kana_TSU', 0x4c2);\n        map.set('kana_TU', 0x4c2);\n        map.set('kana_TE', 0x4c3);\n        map.set('kana_TO', 0x4c4);\n        map.set('kana_NA', 0x4c5);\n        map.set('kana_NI', 0x4c6);\n        map.set('kana_NU', 0x4c7);\n        map.set('kana_NE', 0x4c8);\n        map.set('kana_NO', 0x4c9);\n        map.set('kana_HA', 0x4ca);\n        map.set('kana_HI', 0x4cb);\n        map.set('kana_FU', 0x4cc);\n        map.set('kana_HU', 0x4cc);\n        map.set('kana_HE', 0x4cd);\n        map.set('kana_HO', 0x4ce);\n        map.set('kana_MA', 0x4cf);\n        map.set('kana_MI', 0x4d0);\n        map.set('kana_MU', 0x4d1);\n        map.set('kana_ME', 0x4d2);\n        map.set('kana_MO', 0x4d3);\n        map.set('kana_YA', 0x4d4);\n        map.set('kana_YU', 0x4d5);\n        map.set('kana_YO', 0x4d6);\n        map.set('kana_RA', 0x4d7);\n        map.set('kana_RI', 0x4d8);\n        map.set('kana_RU', 0x4d9);\n        map.set('kana_RE', 0x4da);\n        map.set('kana_RO', 0x4db);\n        map.set('kana_WA', 0x4dc);\n        map.set('kana_N', 0x4dd);\n        map.set('voicedsound', 0x4de);\n        map.set('semivoicedsound', 0x4df);\n        map.set('kana_switch', 0xff7e);\n        map.set('Farsi_0', 0x10006f0);\n        map.set('Farsi_1', 0x10006f1);\n        map.set('Farsi_2', 0x10006f2);\n        map.set('Farsi_3', 0x10006f3);\n        map.set('Farsi_4', 0x10006f4);\n        map.set('Farsi_5', 0x10006f5);\n        map.set('Farsi_6', 0x10006f6);\n        map.set('Farsi_7', 0x10006f7);\n        map.set('Farsi_8', 0x10006f8);\n        map.set('Farsi_9', 0x10006f9);\n        map.set('Arabic_percent', 0x100066a);\n        map.set('Arabic_superscript_alef', 0x1000670);\n        map.set('Arabic_tteh', 0x1000679);\n        map.set('Arabic_peh', 0x100067e);\n        map.set('Arabic_tcheh', 0x1000686);\n        map.set('Arabic_ddal', 0x1000688);\n        map.set('Arabic_rreh', 0x1000691);\n        map.set('Arabic_comma', 0x5ac);\n        map.set('Arabic_fullstop', 0x10006d4);\n        map.set('Arabic_0', 0x1000660);\n        map.set('Arabic_1', 0x1000661);\n        map.set('Arabic_2', 0x1000662);\n        map.set('Arabic_3', 0x1000663);\n        map.set('Arabic_4', 0x1000664);\n        map.set('Arabic_5', 0x1000665);\n        map.set('Arabic_6', 0x1000666);\n        map.set('Arabic_7', 0x1000667);\n        map.set('Arabic_8', 0x1000668);\n        map.set('Arabic_9', 0x1000669);\n        map.set('Arabic_semicolon', 0x5bb);\n        map.set('Arabic_question_mark', 0x5bf);\n        map.set('Arabic_hamza', 0x5c1);\n        map.set('Arabic_maddaonalef', 0x5c2);\n        map.set('Arabic_hamzaonalef', 0x5c3);\n        map.set('Arabic_hamzaonwaw', 0x5c4);\n        map.set('Arabic_hamzaunderalef', 0x5c5);\n        map.set('Arabic_hamzaonyeh', 0x5c6);\n        map.set('Arabic_alef', 0x5c7);\n        map.set('Arabic_beh', 0x5c8);\n        map.set('Arabic_tehmarbuta', 0x5c9);\n        map.set('Arabic_teh', 0x5ca);\n        map.set('Arabic_theh', 0x5cb);\n        map.set('Arabic_jeem', 0x5cc);\n        map.set('Arabic_hah', 0x5cd);\n        map.set('Arabic_khah', 0x5ce);\n        map.set('Arabic_dal', 0x5cf);\n        map.set('Arabic_thal', 0x5d0);\n        map.set('Arabic_ra', 0x5d1);\n        map.set('Arabic_zain', 0x5d2);\n        map.set('Arabic_seen', 0x5d3);\n        map.set('Arabic_sheen', 0x5d4);\n        map.set('Arabic_sad', 0x5d5);\n        map.set('Arabic_dad', 0x5d6);\n        map.set('Arabic_tah', 0x5d7);\n        map.set('Arabic_zah', 0x5d8);\n        map.set('Arabic_ain', 0x5d9);\n        map.set('Arabic_ghain', 0x5da);\n        map.set('Arabic_tatweel', 0x5e0);\n        map.set('Arabic_feh', 0x5e1);\n        map.set('Arabic_qaf', 0x5e2);\n        map.set('Arabic_kaf', 0x5e3);\n        map.set('Arabic_lam', 0x5e4);\n        map.set('Arabic_meem', 0x5e5);\n        map.set('Arabic_noon', 0x5e6);\n        map.set('Arabic_ha', 0x5e7);\n        map.set('Arabic_heh', 0x5e7);\n        map.set('Arabic_waw', 0x5e8);\n        map.set('Arabic_alefmaksura', 0x5e9);\n        map.set('Arabic_yeh', 0x5ea);\n        map.set('Arabic_fathatan', 0x5eb);\n        map.set('Arabic_dammatan', 0x5ec);\n        map.set('Arabic_kasratan', 0x5ed);\n        map.set('Arabic_fatha', 0x5ee);\n        map.set('Arabic_damma', 0x5ef);\n        map.set('Arabic_kasra', 0x5f0);\n        map.set('Arabic_shadda', 0x5f1);\n        map.set('Arabic_sukun', 0x5f2);\n        map.set('Arabic_madda_above', 0x1000653);\n        map.set('Arabic_hamza_above', 0x1000654);\n        map.set('Arabic_hamza_below', 0x1000655);\n        map.set('Arabic_jeh', 0x1000698);\n        map.set('Arabic_veh', 0x10006a4);\n        map.set('Arabic_keheh', 0x10006a9);\n        map.set('Arabic_gaf', 0x10006af);\n        map.set('Arabic_noon_ghunna', 0x10006ba);\n        map.set('Arabic_heh_doachashmee', 0x10006be);\n        map.set('Farsi_yeh', 0x10006cc);\n        map.set('Arabic_farsi_yeh', 0x10006cc);\n        map.set('Arabic_yeh_baree', 0x10006d2);\n        map.set('Arabic_heh_goal', 0x10006c1);\n        map.set('Arabic_switch', 0xff7e);\n        map.set('Cyrillic_GHE_bar', 0x1000492);\n        map.set('Cyrillic_ghe_bar', 0x1000493);\n        map.set('Cyrillic_ZHE_descender', 0x1000496);\n        map.set('Cyrillic_zhe_descender', 0x1000497);\n        map.set('Cyrillic_KA_descender', 0x100049a);\n        map.set('Cyrillic_ka_descender', 0x100049b);\n        map.set('Cyrillic_KA_vertstroke', 0x100049c);\n        map.set('Cyrillic_ka_vertstroke', 0x100049d);\n        map.set('Cyrillic_EN_descender', 0x10004a2);\n        map.set('Cyrillic_en_descender', 0x10004a3);\n        map.set('Cyrillic_U_straight', 0x10004ae);\n        map.set('Cyrillic_u_straight', 0x10004af);\n        map.set('Cyrillic_U_straight_bar', 0x10004b0);\n        map.set('Cyrillic_u_straight_bar', 0x10004b1);\n        map.set('Cyrillic_HA_descender', 0x10004b2);\n        map.set('Cyrillic_ha_descender', 0x10004b3);\n        map.set('Cyrillic_CHE_descender', 0x10004b6);\n        map.set('Cyrillic_che_descender', 0x10004b7);\n        map.set('Cyrillic_CHE_vertstroke', 0x10004b8);\n        map.set('Cyrillic_che_vertstroke', 0x10004b9);\n        map.set('Cyrillic_SHHA', 0x10004ba);\n        map.set('Cyrillic_shha', 0x10004bb);\n        map.set('Cyrillic_SCHWA', 0x10004d8);\n        map.set('Cyrillic_schwa', 0x10004d9);\n        map.set('Cyrillic_I_macron', 0x10004e2);\n        map.set('Cyrillic_i_macron', 0x10004e3);\n        map.set('Cyrillic_O_bar', 0x10004e8);\n        map.set('Cyrillic_o_bar', 0x10004e9);\n        map.set('Cyrillic_U_macron', 0x10004ee);\n        map.set('Cyrillic_u_macron', 0x10004ef);\n        map.set('Serbian_dje', 0x6a1);\n        map.set('Macedonia_gje', 0x6a2);\n        map.set('Cyrillic_io', 0x6a3);\n        map.set('Ukrainian_ie', 0x6a4);\n        map.set('Ukranian_je', 0x6a4);\n        map.set('Macedonia_dse', 0x6a5);\n        map.set('Ukrainian_i', 0x6a6);\n        map.set('Ukranian_i', 0x6a6);\n        map.set('Ukrainian_yi', 0x6a7);\n        map.set('Ukranian_yi', 0x6a7);\n        map.set('Cyrillic_je', 0x6a8);\n        map.set('Serbian_je', 0x6a8);\n        map.set('Cyrillic_lje', 0x6a9);\n        map.set('Serbian_lje', 0x6a9);\n        map.set('Cyrillic_nje', 0x6aa);\n        map.set('Serbian_nje', 0x6aa);\n        map.set('Serbian_tshe', 0x6ab);\n        map.set('Macedonia_kje', 0x6ac);\n        map.set('Ukrainian_ghe_with_upturn', 0x6ad);\n        map.set('Byelorussian_shortu', 0x6ae);\n        map.set('Cyrillic_dzhe', 0x6af);\n        map.set('Serbian_dze', 0x6af);\n        map.set('numerosign', 0x6b0);\n        map.set('Serbian_DJE', 0x6b1);\n        map.set('Macedonia_GJE', 0x6b2);\n        map.set('Cyrillic_IO', 0x6b3);\n        map.set('Ukrainian_IE', 0x6b4);\n        map.set('Ukranian_JE', 0x6b4);\n        map.set('Macedonia_DSE', 0x6b5);\n        map.set('Ukrainian_I', 0x6b6);\n        map.set('Ukranian_I', 0x6b6);\n        map.set('Ukrainian_YI', 0x6b7);\n        map.set('Ukranian_YI', 0x6b7);\n        map.set('Cyrillic_JE', 0x6b8);\n        map.set('Serbian_JE', 0x6b8);\n        map.set('Cyrillic_LJE', 0x6b9);\n        map.set('Serbian_LJE', 0x6b9);\n        map.set('Cyrillic_NJE', 0x6ba);\n        map.set('Serbian_NJE', 0x6ba);\n        map.set('Serbian_TSHE', 0x6bb);\n        map.set('Macedonia_KJE', 0x6bc);\n        map.set('Ukrainian_GHE_WITH_UPTURN', 0x6bd);\n        map.set('Byelorussian_SHORTU', 0x6be);\n        map.set('Cyrillic_DZHE', 0x6bf);\n        map.set('Serbian_DZE', 0x6bf);\n        map.set('Cyrillic_yu', 0x6c0);\n        map.set('Cyrillic_a', 0x6c1);\n        map.set('Cyrillic_be', 0x6c2);\n        map.set('Cyrillic_tse', 0x6c3);\n        map.set('Cyrillic_de', 0x6c4);\n        map.set('Cyrillic_ie', 0x6c5);\n        map.set('Cyrillic_ef', 0x6c6);\n        map.set('Cyrillic_ghe', 0x6c7);\n        map.set('Cyrillic_ha', 0x6c8);\n        map.set('Cyrillic_i', 0x6c9);\n        map.set('Cyrillic_shorti', 0x6ca);\n        map.set('Cyrillic_ka', 0x6cb);\n        map.set('Cyrillic_el', 0x6cc);\n        map.set('Cyrillic_em', 0x6cd);\n        map.set('Cyrillic_en', 0x6ce);\n        map.set('Cyrillic_o', 0x6cf);\n        map.set('Cyrillic_pe', 0x6d0);\n        map.set('Cyrillic_ya', 0x6d1);\n        map.set('Cyrillic_er', 0x6d2);\n        map.set('Cyrillic_es', 0x6d3);\n        map.set('Cyrillic_te', 0x6d4);\n        map.set('Cyrillic_u', 0x6d5);\n        map.set('Cyrillic_zhe', 0x6d6);\n        map.set('Cyrillic_ve', 0x6d7);\n        map.set('Cyrillic_softsign', 0x6d8);\n        map.set('Cyrillic_yeru', 0x6d9);\n        map.set('Cyrillic_ze', 0x6da);\n        map.set('Cyrillic_sha', 0x6db);\n        map.set('Cyrillic_e', 0x6dc);\n        map.set('Cyrillic_shcha', 0x6dd);\n        map.set('Cyrillic_che', 0x6de);\n        map.set('Cyrillic_hardsign', 0x6df);\n        map.set('Cyrillic_YU', 0x6e0);\n        map.set('Cyrillic_A', 0x6e1);\n        map.set('Cyrillic_BE', 0x6e2);\n        map.set('Cyrillic_TSE', 0x6e3);\n        map.set('Cyrillic_DE', 0x6e4);\n        map.set('Cyrillic_IE', 0x6e5);\n        map.set('Cyrillic_EF', 0x6e6);\n        map.set('Cyrillic_GHE', 0x6e7);\n        map.set('Cyrillic_HA', 0x6e8);\n        map.set('Cyrillic_I', 0x6e9);\n        map.set('Cyrillic_SHORTI', 0x6ea);\n        map.set('Cyrillic_KA', 0x6eb);\n        map.set('Cyrillic_EL', 0x6ec);\n        map.set('Cyrillic_EM', 0x6ed);\n        map.set('Cyrillic_EN', 0x6ee);\n        map.set('Cyrillic_O', 0x6ef);\n        map.set('Cyrillic_PE', 0x6f0);\n        map.set('Cyrillic_YA', 0x6f1);\n        map.set('Cyrillic_ER', 0x6f2);\n        map.set('Cyrillic_ES', 0x6f3);\n        map.set('Cyrillic_TE', 0x6f4);\n        map.set('Cyrillic_U', 0x6f5);\n        map.set('Cyrillic_ZHE', 0x6f6);\n        map.set('Cyrillic_VE', 0x6f7);\n        map.set('Cyrillic_SOFTSIGN', 0x6f8);\n        map.set('Cyrillic_YERU', 0x6f9);\n        map.set('Cyrillic_ZE', 0x6fa);\n        map.set('Cyrillic_SHA', 0x6fb);\n        map.set('Cyrillic_E', 0x6fc);\n        map.set('Cyrillic_SHCHA', 0x6fd);\n        map.set('Cyrillic_CHE', 0x6fe);\n        map.set('Cyrillic_HARDSIGN', 0x6ff);\n        map.set('Greek_ALPHAaccent', 0x7a1);\n        map.set('Greek_EPSILONaccent', 0x7a2);\n        map.set('Greek_ETAaccent', 0x7a3);\n        map.set('Greek_IOTAaccent', 0x7a4);\n        map.set('Greek_IOTAdieresis', 0x7a5);\n        map.set('Greek_IOTAdiaeresis', 0x7a5);\n        map.set('Greek_OMICRONaccent', 0x7a7);\n        map.set('Greek_UPSILONaccent', 0x7a8);\n        map.set('Greek_UPSILONdieresis', 0x7a9);\n        map.set('Greek_OMEGAaccent', 0x7ab);\n        map.set('Greek_accentdieresis', 0x7ae);\n        map.set('Greek_horizbar', 0x7af);\n        map.set('Greek_alphaaccent', 0x7b1);\n        map.set('Greek_epsilonaccent', 0x7b2);\n        map.set('Greek_etaaccent', 0x7b3);\n        map.set('Greek_iotaaccent', 0x7b4);\n        map.set('Greek_iotadieresis', 0x7b5);\n        map.set('Greek_iotaaccentdieresis', 0x7b6);\n        map.set('Greek_omicronaccent', 0x7b7);\n        map.set('Greek_upsilonaccent', 0x7b8);\n        map.set('Greek_upsilondieresis', 0x7b9);\n        map.set('Greek_upsilonaccentdieresis', 0x7ba);\n        map.set('Greek_omegaaccent', 0x7bb);\n        map.set('Greek_ALPHA', 0x7c1);\n        map.set('Greek_BETA', 0x7c2);\n        map.set('Greek_GAMMA', 0x7c3);\n        map.set('Greek_DELTA', 0x7c4);\n        map.set('Greek_EPSILON', 0x7c5);\n        map.set('Greek_ZETA', 0x7c6);\n        map.set('Greek_ETA', 0x7c7);\n        map.set('Greek_THETA', 0x7c8);\n        map.set('Greek_IOTA', 0x7c9);\n        map.set('Greek_KAPPA', 0x7ca);\n        map.set('Greek_LAMDA', 0x7cb);\n        map.set('Greek_LAMBDA', 0x7cb);\n        map.set('Greek_MU', 0x7cc);\n        map.set('Greek_NU', 0x7cd);\n        map.set('Greek_XI', 0x7ce);\n        map.set('Greek_OMICRON', 0x7cf);\n        map.set('Greek_PI', 0x7d0);\n        map.set('Greek_RHO', 0x7d1);\n        map.set('Greek_SIGMA', 0x7d2);\n        map.set('Greek_TAU', 0x7d4);\n        map.set('Greek_UPSILON', 0x7d5);\n        map.set('Greek_PHI', 0x7d6);\n        map.set('Greek_CHI', 0x7d7);\n        map.set('Greek_PSI', 0x7d8);\n        map.set('Greek_OMEGA', 0x7d9);\n        map.set('Greek_alpha', 0x7e1);\n        map.set('Greek_beta', 0x7e2);\n        map.set('Greek_gamma', 0x7e3);\n        map.set('Greek_delta', 0x7e4);\n        map.set('Greek_epsilon', 0x7e5);\n        map.set('Greek_zeta', 0x7e6);\n        map.set('Greek_eta', 0x7e7);\n        map.set('Greek_theta', 0x7e8);\n        map.set('Greek_iota', 0x7e9);\n        map.set('Greek_kappa', 0x7ea);\n        map.set('Greek_lamda', 0x7eb);\n        map.set('Greek_lambda', 0x7eb);\n        map.set('Greek_mu', 0x7ec);\n        map.set('Greek_nu', 0x7ed);\n        map.set('Greek_xi', 0x7ee);\n        map.set('Greek_omicron', 0x7ef);\n        map.set('Greek_pi', 0x7f0);\n        map.set('Greek_rho', 0x7f1);\n        map.set('Greek_sigma', 0x7f2);\n        map.set('Greek_finalsmallsigma', 0x7f3);\n        map.set('Greek_tau', 0x7f4);\n        map.set('Greek_upsilon', 0x7f5);\n        map.set('Greek_phi', 0x7f6);\n        map.set('Greek_chi', 0x7f7);\n        map.set('Greek_psi', 0x7f8);\n        map.set('Greek_omega', 0x7f9);\n        map.set('Greek_switch', 0xff7e);\n        map.set('leftradical', 0x8a1);\n        map.set('topleftradical', 0x8a2);\n        map.set('horizconnector', 0x8a3);\n        map.set('topintegral', 0x8a4);\n        map.set('botintegral', 0x8a5);\n        map.set('vertconnector', 0x8a6);\n        map.set('topleftsqbracket', 0x8a7);\n        map.set('botleftsqbracket', 0x8a8);\n        map.set('toprightsqbracket', 0x8a9);\n        map.set('botrightsqbracket', 0x8aa);\n        map.set('topleftparens', 0x8ab);\n        map.set('botleftparens', 0x8ac);\n        map.set('toprightparens', 0x8ad);\n        map.set('botrightparens', 0x8ae);\n        map.set('leftmiddlecurlybrace', 0x8af);\n        map.set('rightmiddlecurlybrace', 0x8b0);\n        map.set('topleftsummation', 0x8b1);\n        map.set('botleftsummation', 0x8b2);\n        map.set('topvertsummationconnector', 0x8b3);\n        map.set('botvertsummationconnector', 0x8b4);\n        map.set('toprightsummation', 0x8b5);\n        map.set('botrightsummation', 0x8b6);\n        map.set('rightmiddlesummation', 0x8b7);\n        map.set('lessthanequal', 0x8bc);\n        map.set('notequal', 0x8bd);\n        map.set('greaterthanequal', 0x8be);\n        map.set('integral', 0x8bf);\n        map.set('therefore', 0x8c0);\n        map.set('variation', 0x8c1);\n        map.set('infinity', 0x8c2);\n        map.set('nabla', 0x8c5);\n        map.set('approximate', 0x8c8);\n        map.set('similarequal', 0x8c9);\n        map.set('ifonlyif', 0x8cd);\n        map.set('implies', 0x8ce);\n        map.set('identical', 0x8cf);\n        map.set('radical', 0x8d6);\n        map.set('includedin', 0x8da);\n        map.set('includes', 0x8db);\n        map.set('intersection', 0x8dc);\n        map.set('union', 0x8dd);\n        map.set('logicaland', 0x8de);\n        map.set('logicalor', 0x8df);\n        map.set('partialderivative', 0x8ef);\n        map.set('function', 0x8f6);\n        map.set('leftarrow', 0x8fb);\n        map.set('uparrow', 0x8fc);\n        map.set('rightarrow', 0x8fd);\n        map.set('downarrow', 0x8fe);\n        map.set('blank', 0x9df);\n        map.set('soliddiamond', 0x9e0);\n        map.set('checkerboard', 0x9e1);\n        map.set('ht', 0x9e2);\n        map.set('ff', 0x9e3);\n        map.set('cr', 0x9e4);\n        map.set('lf', 0x9e5);\n        map.set('nl', 0x9e8);\n        map.set('vt', 0x9e9);\n        map.set('lowrightcorner', 0x9ea);\n        map.set('uprightcorner', 0x9eb);\n        map.set('upleftcorner', 0x9ec);\n        map.set('lowleftcorner', 0x9ed);\n        map.set('crossinglines', 0x9ee);\n        map.set('horizlinescan1', 0x9ef);\n        map.set('horizlinescan3', 0x9f0);\n        map.set('horizlinescan5', 0x9f1);\n        map.set('horizlinescan7', 0x9f2);\n        map.set('horizlinescan9', 0x9f3);\n        map.set('leftt', 0x9f4);\n        map.set('rightt', 0x9f5);\n        map.set('bott', 0x9f6);\n        map.set('topt', 0x9f7);\n        map.set('vertbar', 0x9f8);\n        map.set('emspace', 0xaa1);\n        map.set('enspace', 0xaa2);\n        map.set('em3space', 0xaa3);\n        map.set('em4space', 0xaa4);\n        map.set('digitspace', 0xaa5);\n        map.set('punctspace', 0xaa6);\n        map.set('thinspace', 0xaa7);\n        map.set('hairspace', 0xaa8);\n        map.set('emdash', 0xaa9);\n        map.set('endash', 0xaaa);\n        map.set('signifblank', 0xaac);\n        map.set('ellipsis', 0xaae);\n        map.set('doubbaselinedot', 0xaaf);\n        map.set('onethird', 0xab0);\n        map.set('twothirds', 0xab1);\n        map.set('onefifth', 0xab2);\n        map.set('twofifths', 0xab3);\n        map.set('threefifths', 0xab4);\n        map.set('fourfifths', 0xab5);\n        map.set('onesixth', 0xab6);\n        map.set('fivesixths', 0xab7);\n        map.set('careof', 0xab8);\n        map.set('figdash', 0xabb);\n        map.set('leftanglebracket', 0xabc);\n        map.set('decimalpoint', 0xabd);\n        map.set('rightanglebracket', 0xabe);\n        map.set('marker', 0xabf);\n        map.set('oneeighth', 0xac3);\n        map.set('threeeighths', 0xac4);\n        map.set('fiveeighths', 0xac5);\n        map.set('seveneighths', 0xac6);\n        map.set('trademark', 0xac9);\n        map.set('signaturemark', 0xaca);\n        map.set('trademarkincircle', 0xacb);\n        map.set('leftopentriangle', 0xacc);\n        map.set('rightopentriangle', 0xacd);\n        map.set('emopencircle', 0xace);\n        map.set('emopenrectangle', 0xacf);\n        map.set('leftsinglequotemark', 0xad0);\n        map.set('rightsinglequotemark', 0xad1);\n        map.set('leftdoublequotemark', 0xad2);\n        map.set('rightdoublequotemark', 0xad3);\n        map.set('prescription', 0xad4);\n        map.set('permille', 0xad5);\n        map.set('minutes', 0xad6);\n        map.set('seconds', 0xad7);\n        map.set('latincross', 0xad9);\n        map.set('hexagram', 0xada);\n        map.set('filledrectbullet', 0xadb);\n        map.set('filledlefttribullet', 0xadc);\n        map.set('filledrighttribullet', 0xadd);\n        map.set('emfilledcircle', 0xade);\n        map.set('emfilledrect', 0xadf);\n        map.set('enopencircbullet', 0xae0);\n        map.set('enopensquarebullet', 0xae1);\n        map.set('openrectbullet', 0xae2);\n        map.set('opentribulletup', 0xae3);\n        map.set('opentribulletdown', 0xae4);\n        map.set('openstar', 0xae5);\n        map.set('enfilledcircbullet', 0xae6);\n        map.set('enfilledsqbullet', 0xae7);\n        map.set('filledtribulletup', 0xae8);\n        map.set('filledtribulletdown', 0xae9);\n        map.set('leftpointer', 0xaea);\n        map.set('rightpointer', 0xaeb);\n        map.set('club', 0xaec);\n        map.set('diamond', 0xaed);\n        map.set('heart', 0xaee);\n        map.set('maltesecross', 0xaf0);\n        map.set('dagger', 0xaf1);\n        map.set('doubledagger', 0xaf2);\n        map.set('checkmark', 0xaf3);\n        map.set('ballotcross', 0xaf4);\n        map.set('musicalsharp', 0xaf5);\n        map.set('musicalflat', 0xaf6);\n        map.set('malesymbol', 0xaf7);\n        map.set('femalesymbol', 0xaf8);\n        map.set('telephone', 0xaf9);\n        map.set('telephonerecorder', 0xafa);\n        map.set('phonographcopyright', 0xafb);\n        map.set('caret', 0xafc);\n        map.set('singlelowquotemark', 0xafd);\n        map.set('doublelowquotemark', 0xafe);\n        map.set('cursor', 0xaff);\n        map.set('leftcaret', 0xba3);\n        map.set('rightcaret', 0xba6);\n        map.set('downcaret', 0xba8);\n        map.set('upcaret', 0xba9);\n        map.set('overbar', 0xbc0);\n        map.set('downtack', 0xbc2);\n        map.set('upshoe', 0xbc3);\n        map.set('downstile', 0xbc4);\n        map.set('underbar', 0xbc6);\n        map.set('jot', 0xbca);\n        map.set('quad', 0xbcc);\n        map.set('uptack', 0xbce);\n        map.set('circle', 0xbcf);\n        map.set('upstile', 0xbd3);\n        map.set('downshoe', 0xbd6);\n        map.set('rightshoe', 0xbd8);\n        map.set('leftshoe', 0xbda);\n        map.set('lefttack', 0xbdc);\n        map.set('righttack', 0xbfc);\n        map.set('hebrew_doublelowline', 0xcdf);\n        map.set('hebrew_aleph', 0xce0);\n        map.set('hebrew_bet', 0xce1);\n        map.set('hebrew_beth', 0xce1);\n        map.set('hebrew_gimel', 0xce2);\n        map.set('hebrew_gimmel', 0xce2);\n        map.set('hebrew_dalet', 0xce3);\n        map.set('hebrew_daleth', 0xce3);\n        map.set('hebrew_he', 0xce4);\n        map.set('hebrew_waw', 0xce5);\n        map.set('hebrew_zain', 0xce6);\n        map.set('hebrew_zayin', 0xce6);\n        map.set('hebrew_chet', 0xce7);\n        map.set('hebrew_het', 0xce7);\n        map.set('hebrew_tet', 0xce8);\n        map.set('hebrew_teth', 0xce8);\n        map.set('hebrew_yod', 0xce9);\n        map.set('hebrew_finalkaph', 0xcea);\n        map.set('hebrew_kaph', 0xceb);\n        map.set('hebrew_lamed', 0xcec);\n        map.set('hebrew_finalmem', 0xced);\n        map.set('hebrew_mem', 0xcee);\n        map.set('hebrew_finalnun', 0xcef);\n        map.set('hebrew_nun', 0xcf0);\n        map.set('hebrew_samech', 0xcf1);\n        map.set('hebrew_samekh', 0xcf1);\n        map.set('hebrew_ayin', 0xcf2);\n        map.set('hebrew_finalpe', 0xcf3);\n        map.set('hebrew_pe', 0xcf4);\n        map.set('hebrew_finalzade', 0xcf5);\n        map.set('hebrew_finalzadi', 0xcf5);\n        map.set('hebrew_zade', 0xcf6);\n        map.set('hebrew_zadi', 0xcf6);\n        map.set('hebrew_qoph', 0xcf7);\n        map.set('hebrew_kuf', 0xcf7);\n        map.set('hebrew_resh', 0xcf8);\n        map.set('hebrew_shin', 0xcf9);\n        map.set('hebrew_taw', 0xcfa);\n        map.set('hebrew_taf', 0xcfa);\n        map.set('Hebrew_switch', 0xff7e);\n        map.set('Thai_kokai', 0xda1);\n        map.set('Thai_khokhai', 0xda2);\n        map.set('Thai_khokhuat', 0xda3);\n        map.set('Thai_khokhwai', 0xda4);\n        map.set('Thai_khokhon', 0xda5);\n        map.set('Thai_khorakhang', 0xda6);\n        map.set('Thai_ngongu', 0xda7);\n        map.set('Thai_chochan', 0xda8);\n        map.set('Thai_choching', 0xda9);\n        map.set('Thai_chochang', 0xdaa);\n        map.set('Thai_soso', 0xdab);\n        map.set('Thai_chochoe', 0xdac);\n        map.set('Thai_yoying', 0xdad);\n        map.set('Thai_dochada', 0xdae);\n        map.set('Thai_topatak', 0xdaf);\n        map.set('Thai_thothan', 0xdb0);\n        map.set('Thai_thonangmontho', 0xdb1);\n        map.set('Thai_thophuthao', 0xdb2);\n        map.set('Thai_nonen', 0xdb3);\n        map.set('Thai_dodek', 0xdb4);\n        map.set('Thai_totao', 0xdb5);\n        map.set('Thai_thothung', 0xdb6);\n        map.set('Thai_thothahan', 0xdb7);\n        map.set('Thai_thothong', 0xdb8);\n        map.set('Thai_nonu', 0xdb9);\n        map.set('Thai_bobaimai', 0xdba);\n        map.set('Thai_popla', 0xdbb);\n        map.set('Thai_phophung', 0xdbc);\n        map.set('Thai_fofa', 0xdbd);\n        map.set('Thai_phophan', 0xdbe);\n        map.set('Thai_fofan', 0xdbf);\n        map.set('Thai_phosamphao', 0xdc0);\n        map.set('Thai_moma', 0xdc1);\n        map.set('Thai_yoyak', 0xdc2);\n        map.set('Thai_rorua', 0xdc3);\n        map.set('Thai_ru', 0xdc4);\n        map.set('Thai_loling', 0xdc5);\n        map.set('Thai_lu', 0xdc6);\n        map.set('Thai_wowaen', 0xdc7);\n        map.set('Thai_sosala', 0xdc8);\n        map.set('Thai_sorusi', 0xdc9);\n        map.set('Thai_sosua', 0xdca);\n        map.set('Thai_hohip', 0xdcb);\n        map.set('Thai_lochula', 0xdcc);\n        map.set('Thai_oang', 0xdcd);\n        map.set('Thai_honokhuk', 0xdce);\n        map.set('Thai_paiyannoi', 0xdcf);\n        map.set('Thai_saraa', 0xdd0);\n        map.set('Thai_maihanakat', 0xdd1);\n        map.set('Thai_saraaa', 0xdd2);\n        map.set('Thai_saraam', 0xdd3);\n        map.set('Thai_sarai', 0xdd4);\n        map.set('Thai_saraii', 0xdd5);\n        map.set('Thai_saraue', 0xdd6);\n        map.set('Thai_sarauee', 0xdd7);\n        map.set('Thai_sarau', 0xdd8);\n        map.set('Thai_sarauu', 0xdd9);\n        map.set('Thai_phinthu', 0xdda);\n        map.set('Thai_maihanakat_maitho', 0xdde);\n        map.set('Thai_baht', 0xddf);\n        map.set('Thai_sarae', 0xde0);\n        map.set('Thai_saraae', 0xde1);\n        map.set('Thai_sarao', 0xde2);\n        map.set('Thai_saraaimaimuan', 0xde3);\n        map.set('Thai_saraaimaimalai', 0xde4);\n        map.set('Thai_lakkhangyao', 0xde5);\n        map.set('Thai_maiyamok', 0xde6);\n        map.set('Thai_maitaikhu', 0xde7);\n        map.set('Thai_maiek', 0xde8);\n        map.set('Thai_maitho', 0xde9);\n        map.set('Thai_maitri', 0xdea);\n        map.set('Thai_maichattawa', 0xdeb);\n        map.set('Thai_thanthakhat', 0xdec);\n        map.set('Thai_nikhahit', 0xded);\n        map.set('Thai_leksun', 0xdf0);\n        map.set('Thai_leknung', 0xdf1);\n        map.set('Thai_leksong', 0xdf2);\n        map.set('Thai_leksam', 0xdf3);\n        map.set('Thai_leksi', 0xdf4);\n        map.set('Thai_lekha', 0xdf5);\n        map.set('Thai_lekhok', 0xdf6);\n        map.set('Thai_lekchet', 0xdf7);\n        map.set('Thai_lekpaet', 0xdf8);\n        map.set('Thai_lekkao', 0xdf9);\n        map.set('Hangul', 0xff31);\n        map.set('Hangul_Start', 0xff32);\n        map.set('Hangul_End', 0xff33);\n        map.set('Hangul_Hanja', 0xff34);\n        map.set('Hangul_Jamo', 0xff35);\n        map.set('Hangul_Romaja', 0xff36);\n        map.set('Hangul_Codeinput', 0xff37);\n        map.set('Hangul_Jeonja', 0xff38);\n        map.set('Hangul_Banja', 0xff39);\n        map.set('Hangul_PreHanja', 0xff3a);\n        map.set('Hangul_PostHanja', 0xff3b);\n        map.set('Hangul_SingleCandidate', 0xff3c);\n        map.set('Hangul_MultipleCandidate', 0xff3d);\n        map.set('Hangul_PreviousCandidate', 0xff3e);\n        map.set('Hangul_Special', 0xff3f);\n        map.set('Hangul_switch', 0xff7e);\n        map.set('Hangul_Kiyeog', 0xea1);\n        map.set('Hangul_SsangKiyeog', 0xea2);\n        map.set('Hangul_KiyeogSios', 0xea3);\n        map.set('Hangul_Nieun', 0xea4);\n        map.set('Hangul_NieunJieuj', 0xea5);\n        map.set('Hangul_NieunHieuh', 0xea6);\n        map.set('Hangul_Dikeud', 0xea7);\n        map.set('Hangul_SsangDikeud', 0xea8);\n        map.set('Hangul_Rieul', 0xea9);\n        map.set('Hangul_RieulKiyeog', 0xeaa);\n        map.set('Hangul_RieulMieum', 0xeab);\n        map.set('Hangul_RieulPieub', 0xeac);\n        map.set('Hangul_RieulSios', 0xead);\n        map.set('Hangul_RieulTieut', 0xeae);\n        map.set('Hangul_RieulPhieuf', 0xeaf);\n        map.set('Hangul_RieulHieuh', 0xeb0);\n        map.set('Hangul_Mieum', 0xeb1);\n        map.set('Hangul_Pieub', 0xeb2);\n        map.set('Hangul_SsangPieub', 0xeb3);\n        map.set('Hangul_PieubSios', 0xeb4);\n        map.set('Hangul_Sios', 0xeb5);\n        map.set('Hangul_SsangSios', 0xeb6);\n        map.set('Hangul_Ieung', 0xeb7);\n        map.set('Hangul_Jieuj', 0xeb8);\n        map.set('Hangul_SsangJieuj', 0xeb9);\n        map.set('Hangul_Cieuc', 0xeba);\n        map.set('Hangul_Khieuq', 0xebb);\n        map.set('Hangul_Tieut', 0xebc);\n        map.set('Hangul_Phieuf', 0xebd);\n        map.set('Hangul_Hieuh', 0xebe);\n        map.set('Hangul_A', 0xebf);\n        map.set('Hangul_AE', 0xec0);\n        map.set('Hangul_YA', 0xec1);\n        map.set('Hangul_YAE', 0xec2);\n        map.set('Hangul_EO', 0xec3);\n        map.set('Hangul_E', 0xec4);\n        map.set('Hangul_YEO', 0xec5);\n        map.set('Hangul_YE', 0xec6);\n        map.set('Hangul_O', 0xec7);\n        map.set('Hangul_WA', 0xec8);\n        map.set('Hangul_WAE', 0xec9);\n        map.set('Hangul_OE', 0xeca);\n        map.set('Hangul_YO', 0xecb);\n        map.set('Hangul_U', 0xecc);\n        map.set('Hangul_WEO', 0xecd);\n        map.set('Hangul_WE', 0xece);\n        map.set('Hangul_WI', 0xecf);\n        map.set('Hangul_YU', 0xed0);\n        map.set('Hangul_EU', 0xed1);\n        map.set('Hangul_YI', 0xed2);\n        map.set('Hangul_I', 0xed3);\n        map.set('Hangul_J_Kiyeog', 0xed4);\n        map.set('Hangul_J_SsangKiyeog', 0xed5);\n        map.set('Hangul_J_KiyeogSios', 0xed6);\n        map.set('Hangul_J_Nieun', 0xed7);\n        map.set('Hangul_J_NieunJieuj', 0xed8);\n        map.set('Hangul_J_NieunHieuh', 0xed9);\n        map.set('Hangul_J_Dikeud', 0xeda);\n        map.set('Hangul_J_Rieul', 0xedb);\n        map.set('Hangul_J_RieulKiyeog', 0xedc);\n        map.set('Hangul_J_RieulMieum', 0xedd);\n        map.set('Hangul_J_RieulPieub', 0xede);\n        map.set('Hangul_J_RieulSios', 0xedf);\n        map.set('Hangul_J_RieulTieut', 0xee0);\n        map.set('Hangul_J_RieulPhieuf', 0xee1);\n        map.set('Hangul_J_RieulHieuh', 0xee2);\n        map.set('Hangul_J_Mieum', 0xee3);\n        map.set('Hangul_J_Pieub', 0xee4);\n        map.set('Hangul_J_PieubSios', 0xee5);\n        map.set('Hangul_J_Sios', 0xee6);\n        map.set('Hangul_J_SsangSios', 0xee7);\n        map.set('Hangul_J_Ieung', 0xee8);\n        map.set('Hangul_J_Jieuj', 0xee9);\n        map.set('Hangul_J_Cieuc', 0xeea);\n        map.set('Hangul_J_Khieuq', 0xeeb);\n        map.set('Hangul_J_Tieut', 0xeec);\n        map.set('Hangul_J_Phieuf', 0xeed);\n        map.set('Hangul_J_Hieuh', 0xeee);\n        map.set('Hangul_RieulYeorinHieuh', 0xeef);\n        map.set('Hangul_SunkyeongeumMieum', 0xef0);\n        map.set('Hangul_SunkyeongeumPieub', 0xef1);\n        map.set('Hangul_PanSios', 0xef2);\n        map.set('Hangul_KkogjiDalrinIeung', 0xef3);\n        map.set('Hangul_SunkyeongeumPhieuf', 0xef4);\n        map.set('Hangul_YeorinHieuh', 0xef5);\n        map.set('Hangul_AraeA', 0xef6);\n        map.set('Hangul_AraeAE', 0xef7);\n        map.set('Hangul_J_PanSios', 0xef8);\n        map.set('Hangul_J_KkogjiDalrinIeung', 0xef9);\n        map.set('Hangul_J_YeorinHieuh', 0xefa);\n        map.set('Korean_Won', 0xeff);\n        map.set('Armenian_ligature_ew', 0x1000587);\n        map.set('Armenian_full_stop', 0x1000589);\n        map.set('Armenian_verjaket', 0x1000589);\n        map.set('Armenian_separation_mark', 0x100055d);\n        map.set('Armenian_but', 0x100055d);\n        map.set('Armenian_hyphen', 0x100058a);\n        map.set('Armenian_yentamna', 0x100058a);\n        map.set('Armenian_exclam', 0x100055c);\n        map.set('Armenian_amanak', 0x100055c);\n        map.set('Armenian_accent', 0x100055b);\n        map.set('Armenian_shesht', 0x100055b);\n        map.set('Armenian_question', 0x100055e);\n        map.set('Armenian_paruyk', 0x100055e);\n        map.set('Armenian_AYB', 0x1000531);\n        map.set('Armenian_ayb', 0x1000561);\n        map.set('Armenian_BEN', 0x1000532);\n        map.set('Armenian_ben', 0x1000562);\n        map.set('Armenian_GIM', 0x1000533);\n        map.set('Armenian_gim', 0x1000563);\n        map.set('Armenian_DA', 0x1000534);\n        map.set('Armenian_da', 0x1000564);\n        map.set('Armenian_YECH', 0x1000535);\n        map.set('Armenian_yech', 0x1000565);\n        map.set('Armenian_ZA', 0x1000536);\n        map.set('Armenian_za', 0x1000566);\n        map.set('Armenian_E', 0x1000537);\n        map.set('Armenian_e', 0x1000567);\n        map.set('Armenian_AT', 0x1000538);\n        map.set('Armenian_at', 0x1000568);\n        map.set('Armenian_TO', 0x1000539);\n        map.set('Armenian_to', 0x1000569);\n        map.set('Armenian_ZHE', 0x100053a);\n        map.set('Armenian_zhe', 0x100056a);\n        map.set('Armenian_INI', 0x100053b);\n        map.set('Armenian_ini', 0x100056b);\n        map.set('Armenian_LYUN', 0x100053c);\n        map.set('Armenian_lyun', 0x100056c);\n        map.set('Armenian_KHE', 0x100053d);\n        map.set('Armenian_khe', 0x100056d);\n        map.set('Armenian_TSA', 0x100053e);\n        map.set('Armenian_tsa', 0x100056e);\n        map.set('Armenian_KEN', 0x100053f);\n        map.set('Armenian_ken', 0x100056f);\n        map.set('Armenian_HO', 0x1000540);\n        map.set('Armenian_ho', 0x1000570);\n        map.set('Armenian_DZA', 0x1000541);\n        map.set('Armenian_dza', 0x1000571);\n        map.set('Armenian_GHAT', 0x1000542);\n        map.set('Armenian_ghat', 0x1000572);\n        map.set('Armenian_TCHE', 0x1000543);\n        map.set('Armenian_tche', 0x1000573);\n        map.set('Armenian_MEN', 0x1000544);\n        map.set('Armenian_men', 0x1000574);\n        map.set('Armenian_HI', 0x1000545);\n        map.set('Armenian_hi', 0x1000575);\n        map.set('Armenian_NU', 0x1000546);\n        map.set('Armenian_nu', 0x1000576);\n        map.set('Armenian_SHA', 0x1000547);\n        map.set('Armenian_sha', 0x1000577);\n        map.set('Armenian_VO', 0x1000548);\n        map.set('Armenian_vo', 0x1000578);\n        map.set('Armenian_CHA', 0x1000549);\n        map.set('Armenian_cha', 0x1000579);\n        map.set('Armenian_PE', 0x100054a);\n        map.set('Armenian_pe', 0x100057a);\n        map.set('Armenian_JE', 0x100054b);\n        map.set('Armenian_je', 0x100057b);\n        map.set('Armenian_RA', 0x100054c);\n        map.set('Armenian_ra', 0x100057c);\n        map.set('Armenian_SE', 0x100054d);\n        map.set('Armenian_se', 0x100057d);\n        map.set('Armenian_VEV', 0x100054e);\n        map.set('Armenian_vev', 0x100057e);\n        map.set('Armenian_TYUN', 0x100054f);\n        map.set('Armenian_tyun', 0x100057f);\n        map.set('Armenian_RE', 0x1000550);\n        map.set('Armenian_re', 0x1000580);\n        map.set('Armenian_TSO', 0x1000551);\n        map.set('Armenian_tso', 0x1000581);\n        map.set('Armenian_VYUN', 0x1000552);\n        map.set('Armenian_vyun', 0x1000582);\n        map.set('Armenian_PYUR', 0x1000553);\n        map.set('Armenian_pyur', 0x1000583);\n        map.set('Armenian_KE', 0x1000554);\n        map.set('Armenian_ke', 0x1000584);\n        map.set('Armenian_O', 0x1000555);\n        map.set('Armenian_o', 0x1000585);\n        map.set('Armenian_FE', 0x1000556);\n        map.set('Armenian_fe', 0x1000586);\n        map.set('Armenian_apostrophe', 0x100055a);\n        map.set('Georgian_an', 0x10010d0);\n        map.set('Georgian_ban', 0x10010d1);\n        map.set('Georgian_gan', 0x10010d2);\n        map.set('Georgian_don', 0x10010d3);\n        map.set('Georgian_en', 0x10010d4);\n        map.set('Georgian_vin', 0x10010d5);\n        map.set('Georgian_zen', 0x10010d6);\n        map.set('Georgian_tan', 0x10010d7);\n        map.set('Georgian_in', 0x10010d8);\n        map.set('Georgian_kan', 0x10010d9);\n        map.set('Georgian_las', 0x10010da);\n        map.set('Georgian_man', 0x10010db);\n        map.set('Georgian_nar', 0x10010dc);\n        map.set('Georgian_on', 0x10010dd);\n        map.set('Georgian_par', 0x10010de);\n        map.set('Georgian_zhar', 0x10010df);\n        map.set('Georgian_rae', 0x10010e0);\n        map.set('Georgian_san', 0x10010e1);\n        map.set('Georgian_tar', 0x10010e2);\n        map.set('Georgian_un', 0x10010e3);\n        map.set('Georgian_phar', 0x10010e4);\n        map.set('Georgian_khar', 0x10010e5);\n        map.set('Georgian_ghan', 0x10010e6);\n        map.set('Georgian_qar', 0x10010e7);\n        map.set('Georgian_shin', 0x10010e8);\n        map.set('Georgian_chin', 0x10010e9);\n        map.set('Georgian_can', 0x10010ea);\n        map.set('Georgian_jil', 0x10010eb);\n        map.set('Georgian_cil', 0x10010ec);\n        map.set('Georgian_char', 0x10010ed);\n        map.set('Georgian_xan', 0x10010ee);\n        map.set('Georgian_jhan', 0x10010ef);\n        map.set('Georgian_hae', 0x10010f0);\n        map.set('Georgian_he', 0x10010f1);\n        map.set('Georgian_hie', 0x10010f2);\n        map.set('Georgian_we', 0x10010f3);\n        map.set('Georgian_har', 0x10010f4);\n        map.set('Georgian_hoe', 0x10010f5);\n        map.set('Georgian_fi', 0x10010f6);\n        map.set('Xabovedot', 0x1001e8a);\n        map.set('Ibreve', 0x100012c);\n        map.set('Zstroke', 0x10001b5);\n        map.set('Gcaron', 0x10001e6);\n        map.set('Ocaron', 0x10001d1);\n        map.set('Obarred', 0x100019f);\n        map.set('xabovedot', 0x1001e8b);\n        map.set('ibreve', 0x100012d);\n        map.set('zstroke', 0x10001b6);\n        map.set('gcaron', 0x10001e7);\n        map.set('ocaron', 0x10001d2);\n        map.set('obarred', 0x1000275);\n        map.set('SCHWA', 0x100018f);\n        map.set('schwa', 0x1000259);\n        map.set('EZH', 0x10001b7);\n        map.set('ezh', 0x1000292);\n        map.set('Lbelowdot', 0x1001e36);\n        map.set('lbelowdot', 0x1001e37);\n        map.set('Abelowdot', 0x1001ea0);\n        map.set('abelowdot', 0x1001ea1);\n        map.set('Ahook', 0x1001ea2);\n        map.set('ahook', 0x1001ea3);\n        map.set('Acircumflexacute', 0x1001ea4);\n        map.set('acircumflexacute', 0x1001ea5);\n        map.set('Acircumflexgrave', 0x1001ea6);\n        map.set('acircumflexgrave', 0x1001ea7);\n        map.set('Acircumflexhook', 0x1001ea8);\n        map.set('acircumflexhook', 0x1001ea9);\n        map.set('Acircumflextilde', 0x1001eaa);\n        map.set('acircumflextilde', 0x1001eab);\n        map.set('Acircumflexbelowdot', 0x1001eac);\n        map.set('acircumflexbelowdot', 0x1001ead);\n        map.set('Abreveacute', 0x1001eae);\n        map.set('abreveacute', 0x1001eaf);\n        map.set('Abrevegrave', 0x1001eb0);\n        map.set('abrevegrave', 0x1001eb1);\n        map.set('Abrevehook', 0x1001eb2);\n        map.set('abrevehook', 0x1001eb3);\n        map.set('Abrevetilde', 0x1001eb4);\n        map.set('abrevetilde', 0x1001eb5);\n        map.set('Abrevebelowdot', 0x1001eb6);\n        map.set('abrevebelowdot', 0x1001eb7);\n        map.set('Ebelowdot', 0x1001eb8);\n        map.set('ebelowdot', 0x1001eb9);\n        map.set('Ehook', 0x1001eba);\n        map.set('ehook', 0x1001ebb);\n        map.set('Etilde', 0x1001ebc);\n        map.set('etilde', 0x1001ebd);\n        map.set('Ecircumflexacute', 0x1001ebe);\n        map.set('ecircumflexacute', 0x1001ebf);\n        map.set('Ecircumflexgrave', 0x1001ec0);\n        map.set('ecircumflexgrave', 0x1001ec1);\n        map.set('Ecircumflexhook', 0x1001ec2);\n        map.set('ecircumflexhook', 0x1001ec3);\n        map.set('Ecircumflextilde', 0x1001ec4);\n        map.set('ecircumflextilde', 0x1001ec5);\n        map.set('Ecircumflexbelowdot', 0x1001ec6);\n        map.set('ecircumflexbelowdot', 0x1001ec7);\n        map.set('Ihook', 0x1001ec8);\n        map.set('ihook', 0x1001ec9);\n        map.set('Ibelowdot', 0x1001eca);\n        map.set('ibelowdot', 0x1001ecb);\n        map.set('Obelowdot', 0x1001ecc);\n        map.set('obelowdot', 0x1001ecd);\n        map.set('Ohook', 0x1001ece);\n        map.set('ohook', 0x1001ecf);\n        map.set('Ocircumflexacute', 0x1001ed0);\n        map.set('ocircumflexacute', 0x1001ed1);\n        map.set('Ocircumflexgrave', 0x1001ed2);\n        map.set('ocircumflexgrave', 0x1001ed3);\n        map.set('Ocircumflexhook', 0x1001ed4);\n        map.set('ocircumflexhook', 0x1001ed5);\n        map.set('Ocircumflextilde', 0x1001ed6);\n        map.set('ocircumflextilde', 0x1001ed7);\n        map.set('Ocircumflexbelowdot', 0x1001ed8);\n        map.set('ocircumflexbelowdot', 0x1001ed9);\n        map.set('Ohornacute', 0x1001eda);\n        map.set('ohornacute', 0x1001edb);\n        map.set('Ohorngrave', 0x1001edc);\n        map.set('ohorngrave', 0x1001edd);\n        map.set('Ohornhook', 0x1001ede);\n        map.set('ohornhook', 0x1001edf);\n        map.set('Ohorntilde', 0x1001ee0);\n        map.set('ohorntilde', 0x1001ee1);\n        map.set('Ohornbelowdot', 0x1001ee2);\n        map.set('ohornbelowdot', 0x1001ee3);\n        map.set('Ubelowdot', 0x1001ee4);\n        map.set('ubelowdot', 0x1001ee5);\n        map.set('Uhook', 0x1001ee6);\n        map.set('uhook', 0x1001ee7);\n        map.set('Uhornacute', 0x1001ee8);\n        map.set('uhornacute', 0x1001ee9);\n        map.set('Uhorngrave', 0x1001eea);\n        map.set('uhorngrave', 0x1001eeb);\n        map.set('Uhornhook', 0x1001eec);\n        map.set('uhornhook', 0x1001eed);\n        map.set('Uhorntilde', 0x1001eee);\n        map.set('uhorntilde', 0x1001eef);\n        map.set('Uhornbelowdot', 0x1001ef0);\n        map.set('uhornbelowdot', 0x1001ef1);\n        map.set('Ybelowdot', 0x1001ef4);\n        map.set('ybelowdot', 0x1001ef5);\n        map.set('Yhook', 0x1001ef6);\n        map.set('yhook', 0x1001ef7);\n        map.set('Ytilde', 0x1001ef8);\n        map.set('ytilde', 0x1001ef9);\n        map.set('Ohorn', 0x10001a0);\n        map.set('ohorn', 0x10001a1);\n        map.set('Uhorn', 0x10001af);\n        map.set('uhorn', 0x10001b0);\n        map.set('EcuSign', 0x10020a0);\n        map.set('ColonSign', 0x10020a1);\n        map.set('CruzeiroSign', 0x10020a2);\n        map.set('FFrancSign', 0x10020a3);\n        map.set('LiraSign', 0x10020a4);\n        map.set('MillSign', 0x10020a5);\n        map.set('NairaSign', 0x10020a6);\n        map.set('PesetaSign', 0x10020a7);\n        map.set('RupeeSign', 0x10020a8);\n        map.set('WonSign', 0x10020a9);\n        map.set('NewSheqelSign', 0x10020aa);\n        map.set('DongSign', 0x10020ab);\n        map.set('EuroSign', 0x20ac);\n        map.set('zerosuperior', 0x1002070);\n        map.set('foursuperior', 0x1002074);\n        map.set('fivesuperior', 0x1002075);\n        map.set('sixsuperior', 0x1002076);\n        map.set('sevensuperior', 0x1002077);\n        map.set('eightsuperior', 0x1002078);\n        map.set('ninesuperior', 0x1002079);\n        map.set('zerosubscript', 0x1002080);\n        map.set('onesubscript', 0x1002081);\n        map.set('twosubscript', 0x1002082);\n        map.set('threesubscript', 0x1002083);\n        map.set('foursubscript', 0x1002084);\n        map.set('fivesubscript', 0x1002085);\n        map.set('sixsubscript', 0x1002086);\n        map.set('sevensubscript', 0x1002087);\n        map.set('eightsubscript', 0x1002088);\n        map.set('ninesubscript', 0x1002089);\n        map.set('partdifferential', 0x1002202);\n        map.set('emptyset', 0x1002205);\n        map.set('elementof', 0x1002208);\n        map.set('notelementof', 0x1002209);\n        map.set('containsas', 0x100220b);\n        map.set('squareroot', 0x100221a);\n        map.set('cuberoot', 0x100221b);\n        map.set('fourthroot', 0x100221c);\n        map.set('dintegral', 0x100222c);\n        map.set('tintegral', 0x100222d);\n        map.set('because', 0x1002235);\n        map.set('approxeq', 0x1002248);\n        map.set('notapproxeq', 0x1002247);\n        map.set('notidentical', 0x1002262);\n        map.set('stricteq', 0x1002263);\n        map.set('braille_dot_1', 0xfff1);\n        map.set('braille_dot_2', 0xfff2);\n        map.set('braille_dot_3', 0xfff3);\n        map.set('braille_dot_4', 0xfff4);\n        map.set('braille_dot_5', 0xfff5);\n        map.set('braille_dot_6', 0xfff6);\n        map.set('braille_dot_7', 0xfff7);\n        map.set('braille_dot_8', 0xfff8);\n        map.set('braille_dot_9', 0xfff9);\n        map.set('braille_dot_10', 0xfffa);\n        map.set('braille_blank', 0x1002800);\n        map.set('braille_dots_1', 0x1002801);\n        map.set('braille_dots_2', 0x1002802);\n        map.set('braille_dots_12', 0x1002803);\n        map.set('braille_dots_3', 0x1002804);\n        map.set('braille_dots_13', 0x1002805);\n        map.set('braille_dots_23', 0x1002806);\n        map.set('braille_dots_123', 0x1002807);\n        map.set('braille_dots_4', 0x1002808);\n        map.set('braille_dots_14', 0x1002809);\n        map.set('braille_dots_24', 0x100280a);\n        map.set('braille_dots_124', 0x100280b);\n        map.set('braille_dots_34', 0x100280c);\n        map.set('braille_dots_134', 0x100280d);\n        map.set('braille_dots_234', 0x100280e);\n        map.set('braille_dots_1234', 0x100280f);\n        map.set('braille_dots_5', 0x1002810);\n        map.set('braille_dots_15', 0x1002811);\n        map.set('braille_dots_25', 0x1002812);\n        map.set('braille_dots_125', 0x1002813);\n        map.set('braille_dots_35', 0x1002814);\n        map.set('braille_dots_135', 0x1002815);\n        map.set('braille_dots_235', 0x1002816);\n        map.set('braille_dots_1235', 0x1002817);\n        map.set('braille_dots_45', 0x1002818);\n        map.set('braille_dots_145', 0x1002819);\n        map.set('braille_dots_245', 0x100281a);\n        map.set('braille_dots_1245', 0x100281b);\n        map.set('braille_dots_345', 0x100281c);\n        map.set('braille_dots_1345', 0x100281d);\n        map.set('braille_dots_2345', 0x100281e);\n        map.set('braille_dots_12345', 0x100281f);\n        map.set('braille_dots_6', 0x1002820);\n        map.set('braille_dots_16', 0x1002821);\n        map.set('braille_dots_26', 0x1002822);\n        map.set('braille_dots_126', 0x1002823);\n        map.set('braille_dots_36', 0x1002824);\n        map.set('braille_dots_136', 0x1002825);\n        map.set('braille_dots_236', 0x1002826);\n        map.set('braille_dots_1236', 0x1002827);\n        map.set('braille_dots_46', 0x1002828);\n        map.set('braille_dots_146', 0x1002829);\n        map.set('braille_dots_246', 0x100282a);\n        map.set('braille_dots_1246', 0x100282b);\n        map.set('braille_dots_346', 0x100282c);\n        map.set('braille_dots_1346', 0x100282d);\n        map.set('braille_dots_2346', 0x100282e);\n        map.set('braille_dots_12346', 0x100282f);\n        map.set('braille_dots_56', 0x1002830);\n        map.set('braille_dots_156', 0x1002831);\n        map.set('braille_dots_256', 0x1002832);\n        map.set('braille_dots_1256', 0x1002833);\n        map.set('braille_dots_356', 0x1002834);\n        map.set('braille_dots_1356', 0x1002835);\n        map.set('braille_dots_2356', 0x1002836);\n        map.set('braille_dots_12356', 0x1002837);\n        map.set('braille_dots_456', 0x1002838);\n        map.set('braille_dots_1456', 0x1002839);\n        map.set('braille_dots_2456', 0x100283a);\n        map.set('braille_dots_12456', 0x100283b);\n        map.set('braille_dots_3456', 0x100283c);\n        map.set('braille_dots_13456', 0x100283d);\n        map.set('braille_dots_23456', 0x100283e);\n        map.set('braille_dots_123456', 0x100283f);\n        map.set('braille_dots_7', 0x1002840);\n        map.set('braille_dots_17', 0x1002841);\n        map.set('braille_dots_27', 0x1002842);\n        map.set('braille_dots_127', 0x1002843);\n        map.set('braille_dots_37', 0x1002844);\n        map.set('braille_dots_137', 0x1002845);\n        map.set('braille_dots_237', 0x1002846);\n        map.set('braille_dots_1237', 0x1002847);\n        map.set('braille_dots_47', 0x1002848);\n        map.set('braille_dots_147', 0x1002849);\n        map.set('braille_dots_247', 0x100284a);\n        map.set('braille_dots_1247', 0x100284b);\n        map.set('braille_dots_347', 0x100284c);\n        map.set('braille_dots_1347', 0x100284d);\n        map.set('braille_dots_2347', 0x100284e);\n        map.set('braille_dots_12347', 0x100284f);\n        map.set('braille_dots_57', 0x1002850);\n        map.set('braille_dots_157', 0x1002851);\n        map.set('braille_dots_257', 0x1002852);\n        map.set('braille_dots_1257', 0x1002853);\n        map.set('braille_dots_357', 0x1002854);\n        map.set('braille_dots_1357', 0x1002855);\n        map.set('braille_dots_2357', 0x1002856);\n        map.set('braille_dots_12357', 0x1002857);\n        map.set('braille_dots_457', 0x1002858);\n        map.set('braille_dots_1457', 0x1002859);\n        map.set('braille_dots_2457', 0x100285a);\n        map.set('braille_dots_12457', 0x100285b);\n        map.set('braille_dots_3457', 0x100285c);\n        map.set('braille_dots_13457', 0x100285d);\n        map.set('braille_dots_23457', 0x100285e);\n        map.set('braille_dots_123457', 0x100285f);\n        map.set('braille_dots_67', 0x1002860);\n        map.set('braille_dots_167', 0x1002861);\n        map.set('braille_dots_267', 0x1002862);\n        map.set('braille_dots_1267', 0x1002863);\n        map.set('braille_dots_367', 0x1002864);\n        map.set('braille_dots_1367', 0x1002865);\n        map.set('braille_dots_2367', 0x1002866);\n        map.set('braille_dots_12367', 0x1002867);\n        map.set('braille_dots_467', 0x1002868);\n        map.set('braille_dots_1467', 0x1002869);\n        map.set('braille_dots_2467', 0x100286a);\n        map.set('braille_dots_12467', 0x100286b);\n        map.set('braille_dots_3467', 0x100286c);\n        map.set('braille_dots_13467', 0x100286d);\n        map.set('braille_dots_23467', 0x100286e);\n        map.set('braille_dots_123467', 0x100286f);\n        map.set('braille_dots_567', 0x1002870);\n        map.set('braille_dots_1567', 0x1002871);\n        map.set('braille_dots_2567', 0x1002872);\n        map.set('braille_dots_12567', 0x1002873);\n        map.set('braille_dots_3567', 0x1002874);\n        map.set('braille_dots_13567', 0x1002875);\n        map.set('braille_dots_23567', 0x1002876);\n        map.set('braille_dots_123567', 0x1002877);\n        map.set('braille_dots_4567', 0x1002878);\n        map.set('braille_dots_14567', 0x1002879);\n        map.set('braille_dots_24567', 0x100287a);\n        map.set('braille_dots_124567', 0x100287b);\n        map.set('braille_dots_34567', 0x100287c);\n        map.set('braille_dots_134567', 0x100287d);\n        map.set('braille_dots_234567', 0x100287e);\n        map.set('braille_dots_1234567', 0x100287f);\n        map.set('braille_dots_8', 0x1002880);\n        map.set('braille_dots_18', 0x1002881);\n        map.set('braille_dots_28', 0x1002882);\n        map.set('braille_dots_128', 0x1002883);\n        map.set('braille_dots_38', 0x1002884);\n        map.set('braille_dots_138', 0x1002885);\n        map.set('braille_dots_238', 0x1002886);\n        map.set('braille_dots_1238', 0x1002887);\n        map.set('braille_dots_48', 0x1002888);\n        map.set('braille_dots_148', 0x1002889);\n        map.set('braille_dots_248', 0x100288a);\n        map.set('braille_dots_1248', 0x100288b);\n        map.set('braille_dots_348', 0x100288c);\n        map.set('braille_dots_1348', 0x100288d);\n        map.set('braille_dots_2348', 0x100288e);\n        map.set('braille_dots_12348', 0x100288f);\n        map.set('braille_dots_58', 0x1002890);\n        map.set('braille_dots_158', 0x1002891);\n        map.set('braille_dots_258', 0x1002892);\n        map.set('braille_dots_1258', 0x1002893);\n        map.set('braille_dots_358', 0x1002894);\n        map.set('braille_dots_1358', 0x1002895);\n        map.set('braille_dots_2358', 0x1002896);\n        map.set('braille_dots_12358', 0x1002897);\n        map.set('braille_dots_458', 0x1002898);\n        map.set('braille_dots_1458', 0x1002899);\n        map.set('braille_dots_2458', 0x100289a);\n        map.set('braille_dots_12458', 0x100289b);\n        map.set('braille_dots_3458', 0x100289c);\n        map.set('braille_dots_13458', 0x100289d);\n        map.set('braille_dots_23458', 0x100289e);\n        map.set('braille_dots_123458', 0x100289f);\n        map.set('braille_dots_68', 0x10028a0);\n        map.set('braille_dots_168', 0x10028a1);\n        map.set('braille_dots_268', 0x10028a2);\n        map.set('braille_dots_1268', 0x10028a3);\n        map.set('braille_dots_368', 0x10028a4);\n        map.set('braille_dots_1368', 0x10028a5);\n        map.set('braille_dots_2368', 0x10028a6);\n        map.set('braille_dots_12368', 0x10028a7);\n        map.set('braille_dots_468', 0x10028a8);\n        map.set('braille_dots_1468', 0x10028a9);\n        map.set('braille_dots_2468', 0x10028aa);\n        map.set('braille_dots_12468', 0x10028ab);\n        map.set('braille_dots_3468', 0x10028ac);\n        map.set('braille_dots_13468', 0x10028ad);\n        map.set('braille_dots_23468', 0x10028ae);\n        map.set('braille_dots_123468', 0x10028af);\n        map.set('braille_dots_568', 0x10028b0);\n        map.set('braille_dots_1568', 0x10028b1);\n        map.set('braille_dots_2568', 0x10028b2);\n        map.set('braille_dots_12568', 0x10028b3);\n        map.set('braille_dots_3568', 0x10028b4);\n        map.set('braille_dots_13568', 0x10028b5);\n        map.set('braille_dots_23568', 0x10028b6);\n        map.set('braille_dots_123568', 0x10028b7);\n        map.set('braille_dots_4568', 0x10028b8);\n        map.set('braille_dots_14568', 0x10028b9);\n        map.set('braille_dots_24568', 0x10028ba);\n        map.set('braille_dots_124568', 0x10028bb);\n        map.set('braille_dots_34568', 0x10028bc);\n        map.set('braille_dots_134568', 0x10028bd);\n        map.set('braille_dots_234568', 0x10028be);\n        map.set('braille_dots_1234568', 0x10028bf);\n        map.set('braille_dots_78', 0x10028c0);\n        map.set('braille_dots_178', 0x10028c1);\n        map.set('braille_dots_278', 0x10028c2);\n        map.set('braille_dots_1278', 0x10028c3);\n        map.set('braille_dots_378', 0x10028c4);\n        map.set('braille_dots_1378', 0x10028c5);\n        map.set('braille_dots_2378', 0x10028c6);\n        map.set('braille_dots_12378', 0x10028c7);\n        map.set('braille_dots_478', 0x10028c8);\n        map.set('braille_dots_1478', 0x10028c9);\n        map.set('braille_dots_2478', 0x10028ca);\n        map.set('braille_dots_12478', 0x10028cb);\n        map.set('braille_dots_3478', 0x10028cc);\n        map.set('braille_dots_13478', 0x10028cd);\n        map.set('braille_dots_23478', 0x10028ce);\n        map.set('braille_dots_123478', 0x10028cf);\n        map.set('braille_dots_578', 0x10028d0);\n        map.set('braille_dots_1578', 0x10028d1);\n        map.set('braille_dots_2578', 0x10028d2);\n        map.set('braille_dots_12578', 0x10028d3);\n        map.set('braille_dots_3578', 0x10028d4);\n        map.set('braille_dots_13578', 0x10028d5);\n        map.set('braille_dots_23578', 0x10028d6);\n        map.set('braille_dots_123578', 0x10028d7);\n        map.set('braille_dots_4578', 0x10028d8);\n        map.set('braille_dots_14578', 0x10028d9);\n        map.set('braille_dots_24578', 0x10028da);\n        map.set('braille_dots_124578', 0x10028db);\n        map.set('braille_dots_34578', 0x10028dc);\n        map.set('braille_dots_134578', 0x10028dd);\n        map.set('braille_dots_234578', 0x10028de);\n        map.set('braille_dots_1234578', 0x10028df);\n        map.set('braille_dots_678', 0x10028e0);\n        map.set('braille_dots_1678', 0x10028e1);\n        map.set('braille_dots_2678', 0x10028e2);\n        map.set('braille_dots_12678', 0x10028e3);\n        map.set('braille_dots_3678', 0x10028e4);\n        map.set('braille_dots_13678', 0x10028e5);\n        map.set('braille_dots_23678', 0x10028e6);\n        map.set('braille_dots_123678', 0x10028e7);\n        map.set('braille_dots_4678', 0x10028e8);\n        map.set('braille_dots_14678', 0x10028e9);\n        map.set('braille_dots_24678', 0x10028ea);\n        map.set('braille_dots_124678', 0x10028eb);\n        map.set('braille_dots_34678', 0x10028ec);\n        map.set('braille_dots_134678', 0x10028ed);\n        map.set('braille_dots_234678', 0x10028ee);\n        map.set('braille_dots_1234678', 0x10028ef);\n        map.set('braille_dots_5678', 0x10028f0);\n        map.set('braille_dots_15678', 0x10028f1);\n        map.set('braille_dots_25678', 0x10028f2);\n        map.set('braille_dots_125678', 0x10028f3);\n        map.set('braille_dots_35678', 0x10028f4);\n        map.set('braille_dots_135678', 0x10028f5);\n        map.set('braille_dots_235678', 0x10028f6);\n        map.set('braille_dots_1235678', 0x10028f7);\n        map.set('braille_dots_45678', 0x10028f8);\n        map.set('braille_dots_145678', 0x10028f9);\n        map.set('braille_dots_245678', 0x10028fa);\n        map.set('braille_dots_1245678', 0x10028fb);\n        map.set('braille_dots_345678', 0x10028fc);\n        map.set('braille_dots_1345678', 0x10028fd);\n        map.set('braille_dots_2345678', 0x10028fe);\n        map.set('braille_dots_12345678', 0x10028ff);\n        map.set('Sinh_ng', 0x1000d82);\n        map.set('Sinh_h2', 0x1000d83);\n        map.set('Sinh_a', 0x1000d85);\n        map.set('Sinh_aa', 0x1000d86);\n        map.set('Sinh_ae', 0x1000d87);\n        map.set('Sinh_aee', 0x1000d88);\n        map.set('Sinh_i', 0x1000d89);\n        map.set('Sinh_ii', 0x1000d8a);\n        map.set('Sinh_u', 0x1000d8b);\n        map.set('Sinh_uu', 0x1000d8c);\n        map.set('Sinh_ri', 0x1000d8d);\n        map.set('Sinh_rii', 0x1000d8e);\n        map.set('Sinh_lu', 0x1000d8f);\n        map.set('Sinh_luu', 0x1000d90);\n        map.set('Sinh_e', 0x1000d91);\n        map.set('Sinh_ee', 0x1000d92);\n        map.set('Sinh_ai', 0x1000d93);\n        map.set('Sinh_o', 0x1000d94);\n        map.set('Sinh_oo', 0x1000d95);\n        map.set('Sinh_au', 0x1000d96);\n        map.set('Sinh_ka', 0x1000d9a);\n        map.set('Sinh_kha', 0x1000d9b);\n        map.set('Sinh_ga', 0x1000d9c);\n        map.set('Sinh_gha', 0x1000d9d);\n        map.set('Sinh_ng2', 0x1000d9e);\n        map.set('Sinh_nga', 0x1000d9f);\n        map.set('Sinh_ca', 0x1000da0);\n        map.set('Sinh_cha', 0x1000da1);\n        map.set('Sinh_ja', 0x1000da2);\n        map.set('Sinh_jha', 0x1000da3);\n        map.set('Sinh_nya', 0x1000da4);\n        map.set('Sinh_jnya', 0x1000da5);\n        map.set('Sinh_nja', 0x1000da6);\n        map.set('Sinh_tta', 0x1000da7);\n        map.set('Sinh_ttha', 0x1000da8);\n        map.set('Sinh_dda', 0x1000da9);\n        map.set('Sinh_ddha', 0x1000daa);\n        map.set('Sinh_nna', 0x1000dab);\n        map.set('Sinh_ndda', 0x1000dac);\n        map.set('Sinh_tha', 0x1000dad);\n        map.set('Sinh_thha', 0x1000dae);\n        map.set('Sinh_dha', 0x1000daf);\n        map.set('Sinh_dhha', 0x1000db0);\n        map.set('Sinh_na', 0x1000db1);\n        map.set('Sinh_ndha', 0x1000db3);\n        map.set('Sinh_pa', 0x1000db4);\n        map.set('Sinh_pha', 0x1000db5);\n        map.set('Sinh_ba', 0x1000db6);\n        map.set('Sinh_bha', 0x1000db7);\n        map.set('Sinh_ma', 0x1000db8);\n        map.set('Sinh_mba', 0x1000db9);\n        map.set('Sinh_ya', 0x1000dba);\n        map.set('Sinh_ra', 0x1000dbb);\n        map.set('Sinh_la', 0x1000dbd);\n        map.set('Sinh_va', 0x1000dc0);\n        map.set('Sinh_sha', 0x1000dc1);\n        map.set('Sinh_ssha', 0x1000dc2);\n        map.set('Sinh_sa', 0x1000dc3);\n        map.set('Sinh_ha', 0x1000dc4);\n        map.set('Sinh_lla', 0x1000dc5);\n        map.set('Sinh_fa', 0x1000dc6);\n        map.set('Sinh_al', 0x1000dca);\n        map.set('Sinh_aa2', 0x1000dcf);\n        map.set('Sinh_ae2', 0x1000dd0);\n        map.set('Sinh_aee2', 0x1000dd1);\n        map.set('Sinh_i2', 0x1000dd2);\n        map.set('Sinh_ii2', 0x1000dd3);\n        map.set('Sinh_u2', 0x1000dd4);\n        map.set('Sinh_uu2', 0x1000dd6);\n        map.set('Sinh_ru2', 0x1000dd8);\n        map.set('Sinh_e2', 0x1000dd9);\n        map.set('Sinh_ee2', 0x1000dda);\n        map.set('Sinh_ai2', 0x1000ddb);\n        map.set('Sinh_o2', 0x1000ddc);\n        map.set('Sinh_oo2', 0x1000ddd);\n        map.set('Sinh_au2', 0x1000dde);\n        map.set('Sinh_lu2', 0x1000ddf);\n        map.set('Sinh_ruu2', 0x1000df2);\n        map.set('Sinh_luu2', 0x1000df3);\n        map.set('Sinh_kunddaliya', 0x1000df4);\n        map.set('ModeLock', 0x1008ff01);\n        map.set('MonBrightnessUp', 0x1008ff02);\n        map.set('MonBrightnessDown', 0x1008ff03);\n        map.set('KbdLightOnOff', 0x1008ff04);\n        map.set('KbdBrightnessUp', 0x1008ff05);\n        map.set('KbdBrightnessDown', 0x1008ff06);\n        map.set('Standby', 0x1008ff10);\n        map.set('AudioLowerVolume', 0x1008ff11);\n        map.set('AudioMute', 0x1008ff12);\n        map.set('AudioRaiseVolume', 0x1008ff13);\n        map.set('AudioPlay', 0x1008ff14);\n        map.set('AudioStop', 0x1008ff15);\n        map.set('AudioPrev', 0x1008ff16);\n        map.set('AudioNext', 0x1008ff17);\n        map.set('HomePage', 0x1008ff18);\n        map.set('Mail', 0x1008ff19);\n        map.set('Start', 0x1008ff1a);\n        map.set('Search', 0x1008ff1b);\n        map.set('AudioRecord', 0x1008ff1c);\n        map.set('Calculator', 0x1008ff1d);\n        map.set('Memo', 0x1008ff1e);\n        map.set('ToDoList', 0x1008ff1f);\n        map.set('Calendar', 0x1008ff20);\n        map.set('PowerDown', 0x1008ff21);\n        map.set('ContrastAdjust', 0x1008ff22);\n        map.set('RockerUp', 0x1008ff23);\n        map.set('RockerDown', 0x1008ff24);\n        map.set('RockerEnter', 0x1008ff25);\n        map.set('Back', 0x1008ff26);\n        map.set('Forward', 0x1008ff27);\n        map.set('Stop', 0x1008ff28);\n        map.set('Refresh', 0x1008ff29);\n        map.set('PowerOff', 0x1008ff2a);\n        map.set('WakeUp', 0x1008ff2b);\n        map.set('Eject', 0x1008ff2c);\n        map.set('ScreenSaver', 0x1008ff2d);\n        map.set('WWW', 0x1008ff2e);\n        map.set('Sleep', 0x1008ff2f);\n        map.set('Favorites', 0x1008ff30);\n        map.set('AudioPause', 0x1008ff31);\n        map.set('AudioMedia', 0x1008ff32);\n        map.set('MyComputer', 0x1008ff33);\n        map.set('VendorHome', 0x1008ff34);\n        map.set('LightBulb', 0x1008ff35);\n        map.set('Shop', 0x1008ff36);\n        map.set('History', 0x1008ff37);\n        map.set('OpenURL', 0x1008ff38);\n        map.set('AddFavorite', 0x1008ff39);\n        map.set('HotLinks', 0x1008ff3a);\n        map.set('BrightnessAdjust', 0x1008ff3b);\n        map.set('Finance', 0x1008ff3c);\n        map.set('Community', 0x1008ff3d);\n        map.set('AudioRewind', 0x1008ff3e);\n        map.set('BackForward', 0x1008ff3f);\n        map.set('Launch0', 0x1008ff40);\n        map.set('Launch1', 0x1008ff41);\n        map.set('Launch2', 0x1008ff42);\n        map.set('Launch3', 0x1008ff43);\n        map.set('Launch4', 0x1008ff44);\n        map.set('Launch5', 0x1008ff45);\n        map.set('Launch6', 0x1008ff46);\n        map.set('Launch7', 0x1008ff47);\n        map.set('Launch8', 0x1008ff48);\n        map.set('Launch9', 0x1008ff49);\n        map.set('LaunchA', 0x1008ff4a);\n        map.set('LaunchB', 0x1008ff4b);\n        map.set('LaunchC', 0x1008ff4c);\n        map.set('LaunchD', 0x1008ff4d);\n        map.set('LaunchE', 0x1008ff4e);\n        map.set('LaunchF', 0x1008ff4f);\n        map.set('ApplicationLeft', 0x1008ff50);\n        map.set('ApplicationRight', 0x1008ff51);\n        map.set('Book', 0x1008ff52);\n        map.set('CD', 0x1008ff53);\n        map.set('WindowClear', 0x1008ff55);\n        map.set('Close', 0x1008ff56);\n        map.set('Copy', 0x1008ff57);\n        map.set('Cut', 0x1008ff58);\n        map.set('Display', 0x1008ff59);\n        map.set('DOS', 0x1008ff5a);\n        map.set('Documents', 0x1008ff5b);\n        map.set('Excel', 0x1008ff5c);\n        map.set('Explorer', 0x1008ff5d);\n        map.set('Game', 0x1008ff5e);\n        map.set('Go', 0x1008ff5f);\n        map.set('iTouch', 0x1008ff60);\n        map.set('LogOff', 0x1008ff61);\n        map.set('Market', 0x1008ff62);\n        map.set('Meeting', 0x1008ff63);\n        map.set('MenuKB', 0x1008ff65);\n        map.set('MenuPB', 0x1008ff66);\n        map.set('MySites', 0x1008ff67);\n        map.set('New', 0x1008ff68);\n        map.set('News', 0x1008ff69);\n        map.set('OfficeHome', 0x1008ff6a);\n        map.set('Open', 0x1008ff6b);\n        map.set('Option', 0x1008ff6c);\n        map.set('Paste', 0x1008ff6d);\n        map.set('Phone', 0x1008ff6e);\n        map.set('Reply', 0x1008ff72);\n        map.set('Reload', 0x1008ff73);\n        map.set('RotateWindows', 0x1008ff74);\n        map.set('RotationPB', 0x1008ff75);\n        map.set('RotationKB', 0x1008ff76);\n        map.set('Save', 0x1008ff77);\n        map.set('ScrollUp', 0x1008ff78);\n        map.set('ScrollDown', 0x1008ff79);\n        map.set('ScrollClick', 0x1008ff7a);\n        map.set('Send', 0x1008ff7b);\n        map.set('Spell', 0x1008ff7c);\n        map.set('SplitScreen', 0x1008ff7d);\n        map.set('Support', 0x1008ff7e);\n        map.set('TaskPane', 0x1008ff7f);\n        map.set('Terminal', 0x1008ff80);\n        map.set('Tools', 0x1008ff81);\n        map.set('Travel', 0x1008ff82);\n        map.set('UserPB', 0x1008ff84);\n        map.set('User1KB', 0x1008ff85);\n        map.set('User2KB', 0x1008ff86);\n        map.set('Video', 0x1008ff87);\n        map.set('WheelButton', 0x1008ff88);\n        map.set('Word', 0x1008ff89);\n        map.set('Xfer', 0x1008ff8a);\n        map.set('ZoomIn', 0x1008ff8b);\n        map.set('ZoomOut', 0x1008ff8c);\n        map.set('Away', 0x1008ff8d);\n        map.set('Messenger', 0x1008ff8e);\n        map.set('WebCam', 0x1008ff8f);\n        map.set('MailForward', 0x1008ff90);\n        map.set('Pictures', 0x1008ff91);\n        map.set('Music', 0x1008ff92);\n        map.set('Battery', 0x1008ff93);\n        map.set('Bluetooth', 0x1008ff94);\n        map.set('WLAN', 0x1008ff95);\n        map.set('UWB', 0x1008ff96);\n        map.set('AudioForward', 0x1008ff97);\n        map.set('AudioRepeat', 0x1008ff98);\n        map.set('AudioRandomPlay', 0x1008ff99);\n        map.set('Subtitle', 0x1008ff9a);\n        map.set('AudioCycleTrack', 0x1008ff9b);\n        map.set('CycleAngle', 0x1008ff9c);\n        map.set('FrameBack', 0x1008ff9d);\n        map.set('FrameForward', 0x1008ff9e);\n        map.set('Time', 0x1008ff9f);\n        map.set('SelectButton', 0x1008ffa0);\n        map.set('View', 0x1008ffa1);\n        map.set('TopMenu', 0x1008ffa2);\n        map.set('Red', 0x1008ffa3);\n        map.set('Green', 0x1008ffa4);\n        map.set('Yellow', 0x1008ffa5);\n        map.set('Blue', 0x1008ffa6);\n        map.set('Suspend', 0x1008ffa7);\n        map.set('Hibernate', 0x1008ffa8);\n        map.set('TouchpadToggle', 0x1008ffa9);\n        map.set('TouchpadOn', 0x1008ffb0);\n        map.set('TouchpadOff', 0x1008ffb1);\n        map.set('AudioMicMute', 0x1008ffb2);\n        map.set('Keyboard', 0x1008ffb3);\n        map.set('WWAN', 0x1008ffb4);\n        map.set('RFKill', 0x1008ffb5);\n        map.set('AudioPreset', 0x1008ffb6);\n        map.set('Switch_VT_1', 0x1008fe01);\n        map.set('Switch_VT_2', 0x1008fe02);\n        map.set('Switch_VT_3', 0x1008fe03);\n        map.set('Switch_VT_4', 0x1008fe04);\n        map.set('Switch_VT_5', 0x1008fe05);\n        map.set('Switch_VT_6', 0x1008fe06);\n        map.set('Switch_VT_7', 0x1008fe07);\n        map.set('Switch_VT_8', 0x1008fe08);\n        map.set('Switch_VT_9', 0x1008fe09);\n        map.set('Switch_VT_10', 0x1008fe0a);\n        map.set('Switch_VT_11', 0x1008fe0b);\n        map.set('Switch_VT_12', 0x1008fe0c);\n        map.set('Ungrab', 0x1008fe20);\n        map.set('ClearGrab', 0x1008fe21);\n        map.set('Next_VMode', 0x1008fe22);\n        map.set('Prev_VMode', 0x1008fe23);\n        map.set('LogWindowTree', 0x1008fe24);\n        map.set('LogGrabInfo', 0x1008fe25);\n        this.keycodeMap = map;\n    }\n}\n"
        },
        {
          "name": "app.js",
          "type": "blob",
          "size": 6.095703125,
          "content": "import GLib from 'gi://GLib';\nimport Gio from 'gi://Gio';\nimport Shell from 'gi://Shell';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\n\nimport { Patches, Tiling } from './imports.js';\n\n/*\n  Application functionality, like global new window actions etc.\n */\n\nlet Tracker = Shell.WindowTracker.get_default();\nlet CouldNotLaunch = Symbol();\n\n// Lookup table for custom handlers, keys being the app id\nexport let customHandlers, customSpawnHandlers;\nexport function enable() {\n    customHandlers = { 'org.gnome.Terminal.desktop': newGnomeTerminal };\n    customSpawnHandlers = {\n        'com.gexperts.Tilix.desktop': mkCommandLineSpawner('tilix --working-directory %d'),\n    };\n\n    function spawnWithFallback(fallback, ...args) {\n        try {\n            return trySpawnWindow(...args);\n        } catch (e) {\n            return fallback();\n        }\n    }\n\n    let overrideWithFallback = Patches.overrideWithFallback;\n\n    overrideWithFallback(\n        Shell.App, \"open_new_window\",\n        (fallback, app, workspaceId) => {\n            return spawnWithFallback(fallback, app, global.workspace_manager.get_workspace_by_index(workspaceId));\n        }\n    );\n\n    overrideWithFallback(\n        Shell.App, \"launch_action\",\n        (fallback, app, name, ...args) => {\n            if (name === 'new-window')\n                return spawnWithFallback(fallback, app);\n            else {\n                return fallback();\n            }\n        }\n    );\n\n    overrideWithFallback(\n        Gio.DesktopAppInfo, \"launch\",\n        (fallback, appInfo) => {\n            return spawnWithFallback(fallback, appInfo.get_id());\n        }\n    );\n\n    overrideWithFallback(\n        Gio.DesktopAppInfo, \"launch_action\",\n        (fallback, appInfo, name, ...args) => {\n            if (name === 'new-window')\n                return spawnWithFallback(fallback, appInfo.get_id());\n            else {\n                return fallback();\n            }\n        }\n    );\n}\n\nexport function disable() {\n    customHandlers = null;\n    customSpawnHandlers = null;\n}\n\nexport function launchFromWorkspaceDir(app, workspace = null) {\n    if (typeof  app === 'string') {\n        app = new Shell.App({ app_info: Gio.DesktopAppInfo.new(app) });\n    }\n    let dir = getWorkspaceDirectory(workspace);\n    let cmd = app.app_info.get_commandline();\n    if (!cmd || dir == '') {\n        throw CouldNotLaunch;\n    }\n\n    /* Note: One would think working directory could be specified in the AppLaunchContext\n       The dbus spec https://specifications.freedesktop.org/desktop-entry-spec/1.1/ar01s07.html\n       indicates otherwise (for dbus activated actions). Can affect arbitrary environment\n       variables of exec activated actions, but no environment variable determine working\n       directory of new processes. */\n    // TODO: substitute correct values according to https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#exec-variables\n    cmd = cmd.replace(/%./g, \"\");\n    let [success, cmdArgs] = GLib.shell_parse_argv(cmd);\n    if (!success) {\n        console.error(\"launchFromWorkspaceDir:\", \"Could not parse command line\", cmd);\n        throw CouldNotLaunch;\n    }\n    GLib.spawn_async(dir, cmdArgs, GLib.get_environ(), GLib.SpawnFlags.SEARCH_PATH, null);\n}\n\nexport function newGnomeTerminal(metaWindow, app) {\n    /* Note: this action activation is _not_ bound to the window - instead it\n       relies on the window being active when called.\n\n       If the new window doesn't start in the same directory it's probably\n       because 'vte.sh' haven't been sourced by the shell in this terminal */\n    app.action_group.activate_action(\n        \"win.new-terminal\", new GLib.Variant(\"(ss)\", [\"window\", \"current\"]));\n}\n\nexport function duplicateWindow(metaWindow) {\n    metaWindow = metaWindow || global.display.focus_window;\n    let app = Tracker.get_window_app(metaWindow);\n\n    let handler = customHandlers[app.id];\n    if (handler) {\n        let space = Tiling.spaces.spaceOfWindow(metaWindow);\n        return handler(metaWindow, app, space);\n    }\n\n    let workspaceId = metaWindow.get_workspace().workspace_index;\n\n    let original = Patches.getSavedProp(Shell.App.prototype, \"open_new_window\");\n    original.call(app, workspaceId);\n    return true;\n}\n\nexport function trySpawnWindow(app, workspace) {\n    if (typeof  app === 'string') {\n        app = new Shell.App({ app_info: Gio.DesktopAppInfo.new(app) });\n    }\n    let handler = customSpawnHandlers[app.id];\n    if (handler) {\n        let space = Tiling.spaces.selectedSpace;\n        return handler(app, space);\n    } else {\n        launchFromWorkspaceDir(app, workspace);\n    }\n}\n\nexport function spawnWindow(app, workspace) {\n    if (typeof  app === 'string') {\n        app = new Shell.App({ app_info: Gio.DesktopAppInfo.new(app) });\n    }\n    try {\n        return trySpawnWindow(app, workspace);\n    } catch (e) {\n        // Let the overide take care any fallback\n        return app.open_new_window(-1);\n    }\n}\n\nexport function getWorkspaceDirectory(workspace = null) {\n    let space  = workspace ? Tiling.spaces.get(workspace) : Tiling.spaces.selectedSpace;\n\n    let dir = space.settings.get_string(\"directory\");\n    if (dir[0] === \"~\") {\n        dir = GLib.getenv(\"HOME\") + dir.slice(1);\n    }\n    return dir;\n}\n\nexport function expandCommandline(commandline, workspace) {\n    let dir = getWorkspaceDirectory(workspace);\n\n    commandline = commandline.replace(/%d/g, () => GLib.shell_quote(dir));\n\n    return commandline;\n}\n\nexport function mkCommandLineSpawner(commandlineTemplate, spawnInWorkspaceDir = false) {\n    return (app, space) => {\n        let workspace = space.workspace;\n        let commandline = expandCommandline(commandlineTemplate, workspace);\n        let workingDir = spawnInWorkspaceDir ? getWorkspaceDirectory(workspace) : null;\n        let [success, cmdArgs] = GLib.shell_parse_argv(commandline);\n        if (success) {\n            success = GLib.spawn_async(workingDir, cmdArgs, GLib.get_environ(), GLib.SpawnFlags.SEARCH_PATH, null);\n        }\n        if (!success) {\n            Main.notifyError(\n                `Failed to run custom spawn handler for ${app.id}`,\n                `Attempted to run '${commandline}'`);\n        }\n    };\n}\n"
        },
        {
          "name": "background.js",
          "type": "blob",
          "size": 18.119140625,
          "content": "/**\n * This is a copy and modification of Gnome shell's background.js (keeping only the\n * relevant parts).\n *\n * This was done since `Background` class isn't exported in Gnome 47, and we use the\n * `Background` to add support for animated wallpapers in PaperWM spaces\n * (we previously used Meta.Background but it doesn't support animated wallpapers).\n *\n * See https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/449a7a13034d507cd8b6776c8e1a021264c8bf41/js/ui/background.js\n */\nimport Cogl from 'gi://Cogl';\nimport GDesktopEnums from 'gi://GDesktopEnums';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport GObject from 'gi://GObject';\nimport GnomeBG from 'gi://GnomeBG';\nimport GnomeDesktop from 'gi://GnomeDesktop';\nimport Meta from 'gi://Meta';\nimport * as Signals from 'resource:///org/gnome/shell/misc/signals.js';\n\nimport * as LoginManager from 'resource:///org/gnome/shell/misc/loginManager.js';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as Params from 'resource:///org/gnome/shell/misc/params.js';\n\nimport { Utils } from './imports.js';\n\nconst PRIMARY_COLOR_KEY = 'primary-color';\nconst SECONDARY_COLOR_KEY = 'secondary-color';\nconst COLOR_SHADING_TYPE_KEY = 'color-shading-type';\nconst BACKGROUND_STYLE_KEY = 'picture-options';\nconst PICTURE_URI_KEY = 'picture-uri';\nconst PICTURE_URI_DARK_KEY = 'picture-uri-dark';\n\nconst INTERFACE_SCHEMA = 'org.gnome.desktop.interface';\nconst COLOR_SCHEME_KEY = 'color-scheme';\n\n// These parameters affect how often we redraw.\n// The first is how different (percent crossfaded) the slide show\n// has to look before redrawing and the second is the minimum\n// frequency (in seconds) we're willing to wake up\nconst ANIMATION_OPACITY_STEP_INCREMENT = 4.0;\nconst ANIMATION_MIN_WAKEUP_INTERVAL = 1.0;\n\nlet _backgroundCache = null;\n\nfunction _fileEqual0(file1, file2) {\n    if (file1 === file2)\n        return true;\n\n    if (!file1 || !file2)\n        return false;\n\n    return file1.equal(file2);\n}\n\nclass BackgroundCache extends Signals.EventEmitter {\n    constructor() {\n        super();\n\n        this._fileMonitors = {};\n        this._backgroundSources = {};\n        this._animations = {};\n    }\n\n    monitorFile(file) {\n        let key = file.hash();\n        if (this._fileMonitors[key])\n            return;\n\n        let monitor = file.monitor(Gio.FileMonitorFlags.NONE, null);\n        monitor.connect('changed',\n            (obj, theFile, otherFile, eventType) => {\n                // Ignore CHANGED and CREATED events, since in both cases\n                // we'll get a CHANGES_DONE_HINT event when done.\n                if (eventType !== Gio.FileMonitorEvent.CHANGED &&\n                    eventType !== Gio.FileMonitorEvent.CREATED)\n                    this.emit('file-changed', file);\n            });\n\n        this._fileMonitors[key] = monitor;\n    }\n\n    getAnimation(params) {\n        params = Params.parse(params, {\n            file: null,\n            settingsSchema: null,\n            onLoaded: null,\n        });\n\n        let animation = this._animations[params.settingsSchema];\n        if (animation && _fileEqual0(animation.file, params.file)) {\n            if (params.onLoaded) {\n                let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {\n                    params.onLoaded(this._animations[params.settingsSchema]);\n                    return GLib.SOURCE_REMOVE;\n                });\n                GLib.Source.set_name_by_id(id, '[gnome-shell] params.onLoaded');\n            }\n            return;\n        }\n\n        animation = new Animation({ file: params.file });\n\n        animation.load_async(null, () => {\n            this._animations[params.settingsSchema] = animation;\n\n            if (params.onLoaded) {\n                let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {\n                    params.onLoaded(this._animations[params.settingsSchema]);\n                    return GLib.SOURCE_REMOVE;\n                });\n                GLib.Source.set_name_by_id(id, '[gnome-shell] params.onLoaded');\n            }\n        });\n    }\n\n    getBackgroundSource(layoutManager, settingsSchema) {\n        // The layoutManager is always the same one; we pass in it since\n        // Main.layoutManager may not be set yet\n\n        if (!(settingsSchema in this._backgroundSources)) {\n            this._backgroundSources[settingsSchema] = new BackgroundSource(layoutManager, settingsSchema);\n            this._backgroundSources[settingsSchema]._useCount = 1;\n        } else {\n            this._backgroundSources[settingsSchema]._useCount++;\n        }\n\n        return this._backgroundSources[settingsSchema];\n    }\n\n    releaseBackgroundSource(settingsSchema) {\n        if (settingsSchema in this._backgroundSources) {\n            let source = this._backgroundSources[settingsSchema];\n            source._useCount--;\n            if (source._useCount === 0) {\n                delete this._backgroundSources[settingsSchema];\n                source.destroy();\n            }\n        }\n    }\n}\n\n/**\n * @returns {BackgroundCache}\n */\nfunction getBackgroundCache() {\n    if (!_backgroundCache)\n        _backgroundCache = new BackgroundCache();\n    return _backgroundCache;\n}\n\nexport const Background = GObject.registerClass({\n    Signals: { 'loaded': {}, 'bg-changed': {} },\n}, class Background extends Meta.Background {\n    _init(params) {\n        params = Params.parse(params, {\n            monitorIndex: 0,\n            layoutManager: Main.layoutManager,\n            settings: null,\n            file: null,\n            style: null,\n        });\n\n        super._init({ meta_display: global.display });\n\n        this._settings = params.settings;\n        this._file = params.file;\n        this._style = params.style;\n        this._monitorIndex = params.monitorIndex;\n        this._layoutManager = params.layoutManager;\n        this._fileWatches = {};\n        this._cancellable = new Gio.Cancellable();\n        this.isLoaded = false;\n\n        this._interfaceSettings = new Gio.Settings({ schema_id: INTERFACE_SCHEMA });\n\n        this._clock = new GnomeDesktop.WallClock();\n        this._clock.connectObject('notify::timezone',\n            () => {\n                if (this._animation)\n                    this._loadAnimation(this._animation.file);\n            }, this);\n\n        let loginManager = LoginManager.getLoginManager();\n        loginManager.connectObject('prepare-for-sleep',\n            (lm, aboutToSuspend) => {\n                if (aboutToSuspend)\n                    return;\n                this._refreshAnimation();\n            }, this);\n\n        this._settings.connectObject('changed',\n            this._emitChangedSignal.bind(this), this);\n\n        this._interfaceSettings.connectObject(`changed::${COLOR_SCHEME_KEY}`,\n            this._emitChangedSignal.bind(this), this);\n\n        this._load();\n    }\n\n    destroy() {\n        this._cancellable.cancel();\n        this._removeAnimationTimeout();\n\n        let i;\n        let keys = Object.keys(this._fileWatches);\n        for (i = 0; i < keys.length; i++)\n            this._cache.disconnect(this._fileWatches[keys[i]]);\n\n        this._fileWatches = null;\n\n        this._clock.disconnectObject(this);\n        this._clock = null;\n\n        LoginManager.getLoginManager().disconnectObject(this);\n        this._settings.disconnectObject(this);\n        this._interfaceSettings.disconnectObject(this);\n\n        if (this._changedIdleId) {\n            GLib.source_remove(this._changedIdleId);\n            this._changedIdleId = 0;\n        }\n    }\n\n    _emitChangedSignal() {\n        if (this._changedIdleId)\n            return;\n\n        this._changedIdleId = GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {\n            this._changedIdleId = 0;\n            this.emit('bg-changed');\n            return GLib.SOURCE_REMOVE;\n        });\n        GLib.Source.set_name_by_id(this._changedIdleId,\n            '[gnome-shell] Background._emitChangedSignal');\n    }\n\n    updateResolution() {\n        if (this._animation)\n            this._refreshAnimation();\n    }\n\n    _refreshAnimation() {\n        if (!this._animation)\n            return;\n\n        this._removeAnimationTimeout();\n        this._updateAnimation();\n    }\n\n    _setLoaded() {\n        if (this.isLoaded)\n            return;\n\n        this.isLoaded = true;\n        if (this._cancellable?.is_cancelled())\n            return;\n\n        let id = GLib.idle_add(GLib.PRIORITY_DEFAULT, () => {\n            this.emit('loaded');\n            return GLib.SOURCE_REMOVE;\n        });\n        GLib.Source.set_name_by_id(id, '[gnome-shell] Background._setLoaded Idle');\n    }\n\n    _loadPattern() {\n        let colorString, res_, color, secondColor;\n\n        colorString = this._settings.get_string(PRIMARY_COLOR_KEY);\n        [res_, color] = Utils.color_from_string(colorString);\n        colorString = this._settings.get_string(SECONDARY_COLOR_KEY);\n        [res_, secondColor] = Utils.color_from_string(colorString);\n\n        let shadingType = this._settings.get_enum(COLOR_SHADING_TYPE_KEY);\n\n        if (shadingType === GDesktopEnums.BackgroundShading.SOLID)\n            this.set_color(color);\n        else\n            this.set_gradient(shadingType, color, secondColor);\n    }\n\n    _watchFile(file) {\n        let key = file.hash();\n        if (this._fileWatches[key])\n            return;\n\n        this._cache.monitorFile(file);\n        let signalId = this._cache.connect('file-changed',\n            (cache, changedFile) => {\n                if (changedFile.equal(file)) {\n                    let imageCache = Meta.BackgroundImageCache.get_default();\n                    imageCache.purge(changedFile);\n                    this._emitChangedSignal();\n                }\n            });\n        this._fileWatches[key] = signalId;\n    }\n\n    _removeAnimationTimeout() {\n        if (this._updateAnimationTimeoutId) {\n            GLib.source_remove(this._updateAnimationTimeoutId);\n            this._updateAnimationTimeoutId = 0;\n        }\n    }\n\n    _updateAnimation() {\n        this._updateAnimationTimeoutId = 0;\n\n        this._animation.update(this._layoutManager.monitors[this._monitorIndex]);\n        let files = this._animation.keyFrameFiles;\n\n        let finish = () => {\n            this._setLoaded();\n            if (files.length > 1) {\n                this.set_blend(files[0], files[1],\n                    this._animation.transitionProgress,\n                    this._style);\n            } else if (files.length > 0) {\n                this.set_file(files[0], this._style);\n            } else {\n                this.set_file(null, this._style);\n            }\n            this._queueUpdateAnimation();\n        };\n\n        let cache = Meta.BackgroundImageCache.get_default();\n        let numPendingImages = files.length;\n        for (let i = 0; i < files.length; i++) {\n            this._watchFile(files[i]);\n            let image = cache.load(files[i]);\n            if (image.is_loaded()) {\n                numPendingImages--;\n                if (numPendingImages === 0)\n                    finish();\n            } else {\n                // eslint-disable-next-line no-loop-func\n                let id = image.connect('loaded', () => {\n                    image.disconnect(id);\n                    numPendingImages--;\n                    if (numPendingImages === 0)\n                        finish();\n                });\n            }\n        }\n    }\n\n    _queueUpdateAnimation() {\n        if (this._updateAnimationTimeoutId !== 0)\n            return;\n\n        if (!this._cancellable || this._cancellable.is_cancelled())\n            return;\n\n        if (!this._animation.transitionDuration)\n            return;\n\n        let nSteps = 255 / ANIMATION_OPACITY_STEP_INCREMENT;\n        let timePerStep = (this._animation.transitionDuration * 1000) / nSteps;\n\n        let interval = Math.max(\n            ANIMATION_MIN_WAKEUP_INTERVAL * 1000,\n            timePerStep);\n\n        if (interval > GLib.MAXUINT32)\n            return;\n\n        this._updateAnimationTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT,\n            interval,\n            () => {\n                this._updateAnimationTimeoutId = 0;\n                this._updateAnimation();\n                return GLib.SOURCE_REMOVE;\n            });\n        GLib.Source.set_name_by_id(this._updateAnimationTimeoutId, '[gnome-shell] this._updateAnimation');\n    }\n\n    _loadAnimation(file) {\n        this._cache.getAnimation({\n            file,\n            settingsSchema: this._settings.schema_id,\n            onLoaded: animation => {\n                this._animation = animation;\n\n                if (!this._animation || this._cancellable.is_cancelled()) {\n                    this._setLoaded();\n                    return;\n                }\n\n                this._updateAnimation();\n                this._watchFile(file);\n            },\n        });\n    }\n\n    _loadImage(file) {\n        this.set_file(file, this._style);\n        this._watchFile(file);\n\n        let cache = Meta.BackgroundImageCache.get_default();\n        let image = cache.load(file);\n        if (image.is_loaded()) {\n            this._setLoaded();\n        } else {\n            let id = image.connect('loaded', () => {\n                this._setLoaded();\n                image.disconnect(id);\n            });\n        }\n    }\n\n    async _loadFile(file) {\n        let info;\n        try {\n            info = await file.query_info_async(\n                Gio.FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE,\n                Gio.FileQueryInfoFlags.NONE,\n                0,\n                this._cancellable);\n        } catch (e) {\n            this._setLoaded();\n            return;\n        }\n\n        const contentType = info.get_content_type();\n        if (contentType === 'application/xml')\n            this._loadAnimation(file);\n        else\n            this._loadImage(file);\n    }\n\n    _load() {\n        this._cache = getBackgroundCache();\n\n        this._loadPattern();\n\n        if (!this._file) {\n            this._setLoaded();\n            return;\n        }\n\n        this._loadFile(this._file);\n    }\n});\n\nclass BackgroundSource {\n    constructor(layoutManager, settingsSchema) {\n        // Allow override the background image setting for performance testing\n        this._layoutManager = layoutManager;\n        this._overrideImage = GLib.getenv('SHELL_BACKGROUND_IMAGE');\n        this._settings = new Gio.Settings({ schema_id: settingsSchema });\n        this._backgrounds = [];\n\n        const monitorManager = global.backend.get_monitor_manager();\n        this._monitorsChangedId =\n            monitorManager.connect('monitors-changed',\n                this._onMonitorsChanged.bind(this));\n\n        this._interfaceSettings = new Gio.Settings({ schema_id: INTERFACE_SCHEMA });\n    }\n\n    _onMonitorsChanged() {\n        for (let monitorIndex in this._backgrounds) {\n            let background = this._backgrounds[monitorIndex];\n\n            if (monitorIndex < this._layoutManager.monitors.length) {\n                background.updateResolution();\n            } else {\n                background.disconnect(background._changedId);\n                background.destroy();\n                delete this._backgrounds[monitorIndex];\n            }\n        }\n    }\n\n    getBackground(monitorIndex) {\n        let file = null;\n        let style;\n\n        // We don't watch changes to settings here,\n        // instead we rely on Background to watch those\n        // and emit 'bg-changed' at the right time\n\n        if (this._overrideImage != null) {\n            file = Gio.File.new_for_path(this._overrideImage);\n            style = GDesktopEnums.BackgroundStyle.ZOOM; // Hardcode\n        } else {\n            style = this._settings.get_enum(BACKGROUND_STYLE_KEY);\n            if (style !== GDesktopEnums.BackgroundStyle.NONE) {\n                const colorScheme = this._interfaceSettings.get_enum('color-scheme');\n                const uri = this._settings.get_string(\n                    colorScheme === GDesktopEnums.ColorScheme.PREFER_DARK\n                        ? PICTURE_URI_DARK_KEY\n                        : PICTURE_URI_KEY);\n\n                file = Gio.File.new_for_commandline_arg(uri);\n            }\n        }\n\n        // Animated backgrounds are (potentially) per-monitor, since\n        // they can have variants that depend on the aspect ratio and\n        // size of the monitor; for other backgrounds we can use the\n        // same background object for all monitors.\n        if (file == null || !file.get_basename().endsWith('.xml'))\n            monitorIndex = 0;\n\n        if (!(monitorIndex in this._backgrounds)) {\n            let background = new Background({\n                monitorIndex,\n                layoutManager: this._layoutManager,\n                settings: this._settings,\n                file,\n                style,\n            });\n\n            background._changedId = background.connect('bg-changed', () => {\n                background.disconnect(background._changedId);\n                background.destroy();\n                delete this._backgrounds[monitorIndex];\n            });\n\n            this._backgrounds[monitorIndex] = background;\n        }\n\n        return this._backgrounds[monitorIndex];\n    }\n\n    destroy() {\n        const monitorManager = global.backend.get_monitor_manager();\n        monitorManager.disconnect(this._monitorsChangedId);\n\n        for (let monitorIndex in this._backgrounds) {\n            let background = this._backgrounds[monitorIndex];\n            background.disconnect(background._changedId);\n            background.destroy();\n        }\n\n        this._backgrounds = null;\n    }\n}\n\nconst Animation = GObject.registerClass(\nclass Animation extends GnomeBG.BGSlideShow {\n    _init(params) {\n        super._init(params);\n\n        this.keyFrameFiles = [];\n        this.transitionProgress = 0.0;\n        this.transitionDuration = 0.0;\n        this.loaded = false;\n    }\n\n    // eslint-disable-next-line camelcase\n    load_async(cancellable, callback) {\n        super.load_async(cancellable, () => {\n            this.loaded = true;\n\n            callback?.();\n        });\n    }\n\n    update(monitor) {\n        this.keyFrameFiles = [];\n\n        if (this.get_num_slides() < 1)\n            return;\n\n        let [progress, duration, isFixed_, filename1, filename2] =\n            this.get_current_slide(monitor.width, monitor.height);\n\n        this.transitionDuration = duration;\n        this.transitionProgress = progress;\n\n        if (filename1)\n            this.keyFrameFiles.push(Gio.File.new_for_path(filename1));\n\n        if (filename2)\n            this.keyFrameFiles.push(Gio.File.new_for_path(filename2));\n    }\n});\n"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "debug",
          "type": "blob",
          "size": 2.4228515625,
          "content": "#!/usr/bin/env zsh\n\nindent=\"  \"\n\n# Ref: https://gitlab.gnome.org/GNOME/gnome-shell/issues/1\nfunction skip-crap {\n    local datep=\"[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: \"\n    local crap_start=\"^${datep}Object [^ ]+ \\(.*\\), has been already finalized. Impossible to \\w* any property \\w* it.*\"\n\n    local crap_continue=(\n        \"^${datep}== Stack trace for context.*\"\n        \"^${datep}#[0-9]+\\s*0x.*\"\n    )\n\n    local skip=0\n    local skipped=0\n    local begin_skip_date\n\n    # Could probably be done more elegantly with awk/sed ?\n    while IFS=$'\\n' read -r line; do\n        if [[ $line =~ $crap_start ]]; then\n            # echo setting skip\n            skip=1\n            begin_skip=$line\n            ((skipped += 1))\n            continue\n        fi\n\n        if [[ $skip == 1 ]]; then\n            if [[ ($line =~ $crap_continue[1]) ||\n                      ($line =~ $crap_continue[2]) ]]; then\n                ((skipped += 1))\n                continue\n            else\n                # echo reset skip\n                echo -E \"$begin_skip\"\n                printf \"${indent}... skipped \\\"already finalized\\\" crap ($skipped lines)\\n\"\n                skip=0\n                skipped=0\n            fi\n        fi\n\n        echo -E \"$line\"\n    done\n}\n\n\n# We use non-breaking space to encode newlines in multiline messages\nfunction decode-multiline-message {\n    stdbuf -oL sed -e 's| |\\n    |g'\n}\n\nfunction gnome-shell-exe-path {\n    if systemctl --user status gnome-shell-x11.service > /dev/null; then\n        echo --user-unit=gnome-shell-x11.service\n    elif systemctl --user status gnome-shell-wayland.service > /dev/null; then\n        echo --user-unit=gnome-shell-wayland.service\n    elif uname -a | grep --silent \"NixOS\"; then\n        echo $(dirname =gnome-shell(:A))/.gnome-shell-wrapped\n    else\n        echo =gnome-shell\n    fi\n}\n\nfunction procees {\n    jq --unbuffered --raw-output '\n       {ts: .__REALTIME_TIMESTAMP, message: .MESSAGE}\n       | @sh \"TS=\\(.ts); MESSAGE=\\(.message)\\u0000\"\n    ' | while read -r -d $'\\0' DATA; do\n        eval $DATA\n\n        TS=$((TS/1000000))\n\n        PP_TS=$(date -d @${TS} +'%T')\n\n        if [[ $MESSAGE == *$'\\n'* ]]; then\n            echo $PP_TS:\n            echo -E $MESSAGE | sed 's/^/  /'\n        else\n            echo -E \"$PP_TS: $MESSAGE\"\n        fi\n    done\n\n}\n\njournalctl --follow --lines 400 -o json --output-fields MESSAGE \\\n           $@ $(gnome-shell-exe-path) \\\n    | procees \\\n    | skip-crap \\\n    | decode-multiline-message\n\n\n"
        },
        {
          "name": "default.nix",
          "type": "blob",
          "size": 0.4970703125,
          "content": "{ pkgs, stdenv, glib, ... }:\n\nlet\n  uuid = \"paperwm@paperwm.github.com\";\nin\nstdenv.mkDerivation {\n  pname = \"gnome-shell-extension-paperwm\";\n  version = \"unstable\";\n  src = ./.;\n\n  nativeBuildInputs = with pkgs;\n    [ glib\n    ];\n  buildPhase = ''\n    make -C schemas gschemas.compiled\n  '';\n\n  installPhase = ''\n    mkdir -p $out/share/gnome-shell/extensions\n    cp -r -T . $out/share/gnome-shell/extensions/${uuid}\n  '';\n\n  passthru = {\n    extensionPortalSlug = \"paperwm\";\n    extensionUuid = uuid;\n  };\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "extension.js",
          "type": "blob",
          "size": 6.6005859375,
          "content": "import Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport St from 'gi://St';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as Util from 'resource:///org/gnome/shell/misc/util.js';\n\nimport {\n    Utils, Settings, Gestures, Keybindings, LiveAltTab, Navigator,\n    Stackoverlay, Scratch, Workspace, Tiling, Topbar, Patches, App, Grab\n} from './imports.js';\n\nimport { Extension } from 'resource:///org/gnome/shell/extensions/extension.js';\n\n/**\n   The currently used modules\n     - tiling is the main module, responsible for tiling and workspaces\n\n     - navigator is used to initiate a discrete navigation.\n       Focus is only switched when the navigation is done.\n\n     - keybindings is a utility wrapper around mutters keybinding facilities.\n\n     - scratch is used to manage floating windows, or scratch windows.\n\n     - liveAltTab is a simple altTab implementiation with live previews.\n\n     - stackoverlay is somewhat kludgy. It makes clicking on the left or right\n       edge of the screen always activate the partially (or sometimes wholly)\n       concealed window at the edges.\n\n     - app creates new windows based on the current application. It's possible\n       to create custom new window handlers.\n\n     - Patches is used for monkey patching gnome shell behavior which simply\n       doesn't fit paperwm.\n\n     - topbar adds the workspace name to the topbar and styles it.\n\n     - gestures is responsible for 3-finger swiping (only works in wayland).\n\n     Notes of ordering:\n        - several modules import settings, so settings should be before them;\n          - settings.js should not depend on other paperwm modules;\n        - Settings should be before Patches (for reverse order disable);\n */\n\nexport default class PaperWM extends Extension {\n    modules = [\n        Utils, Settings, Patches,\n        Gestures, Keybindings, LiveAltTab, Navigator, Stackoverlay, Scratch,\n        Workspace, Tiling, Topbar, App, Grab,\n    ];\n\n    #userStylesheet = null;\n\n    enable() {\n        console.log(`#PaperWM enabled`);\n        this.enableUserConfig();\n        this.enableUserStylesheet();\n\n        // run enable method (with extension argument on all modules)\n        this.modules.forEach(m => {\n            if (m['enable']) {\n                m.enable(this);\n            }\n        });\n    }\n\n    disable() {\n        console.log('#PaperWM disabled');\n        this.prepareForDisable();\n        [...this.modules].reverse().forEach(m => {\n            if (m['disable']) {\n                m.disable();\n            }\n        });\n\n        this.disableUserStylesheet();\n    }\n\n    /**\n     * Prepares PaperWM for disable across modules.\n     */\n    prepareForDisable() {\n        /**\n         * Finish any navigation (e.g. workspace switch view).\n         * Can put PaperWM in a breakable state of lock/disable\n         * while navigating.\n         */\n        Navigator.finishNavigation();\n    }\n\n    getConfigDir() {\n        return Gio.file_new_for_path(`${GLib.get_user_config_dir()}/paperwm`);\n    }\n\n    configDirExists() {\n        return this.getConfigDir().query_exists(null);\n    }\n\n    hasUserConfigFile() {\n        return this.getConfigDir().get_child(\"user.js\").query_exists(null);\n    }\n\n    hasUserStyleFile() {\n        return this.getConfigDir().get_child(\"user.css\").query_exists(null);\n    }\n\n    /**\n     * Update the metadata.json in user config dir to always keep it up to date.\n     * We copy metadata.json to the config directory so gnome-shell-mode\n     * knows which extension the files belong to (ideally we'd symlink, but\n     * that trips up the importer: Extension.imports.<complete> in\n     * gnome-shell-mode crashes gnome-shell..)\n     */\n    updateUserConfigFiles() {\n        if (!this.configDirExists()) {\n            return;\n        }\n        const configDir = this.getConfigDir();\n\n        try {\n            const metadata = this.dir.get_child(\"metadata.json\");\n            metadata.copy(configDir.get_child(\"metadata.json\"), Gio.FileCopyFlags.OVERWRITE, null, null);\n        } catch (error) {\n            console.error('PaperWM', `could not update user config metadata.json: ${error}`);\n        }\n\n        if (!this.hasUserStyleFile()) {\n            try {\n                const user = this.dir.get_child(\"config/user.css\");\n                user.copy(configDir.get_child(\"user.css\"), Gio.FileCopyFlags.NONE, null, null);\n            } catch (error) {\n                console.error('PaperWM', `could not update user config metadata.json: ${error}`);\n            }\n        }\n    }\n\n    installConfig() {\n        const configDir = this.getConfigDir();\n        // if user config folder doesn't exist, create it\n        if (!this.configDirExists()) {\n            configDir.make_directory_with_parents(null);\n        }\n    }\n\n    enableUserConfig() {\n        if (!this.configDirExists()) {\n            try {\n                this.installConfig();\n\n                const configDir = this.getConfigDir().get_path();\n                Main.notify(\"PaperWM\", `Created user configuration folder: ${configDir}`);\n            } catch (e) {\n                Main.notifyError(\"PaperWM\", `Failed create user configuration folder: ${e.message}`);\n            }\n        }\n\n        this.updateUserConfigFiles();\n\n        /* TODO: figure out something here\n        fmuellner:\n        > you can't\n        > as I said, it's part of gjs legacy imports\n        > you'll have to do something like const userMod = await import(${this.getConfigDir()}/user.js)\n        */\n        /*\n        // add to searchpath if user has config file and action user.js\n        if (this.hasUserConfigFile()) {\n            let SearchPath = Extension.imports.searchPath;\n            let path = this.getConfigDir().get_path();\n            if (!SearchPath.includes(path)) {\n                SearchPath.push(path);\n            }\n        }\n        */\n    }\n\n    /**\n     * Reloads user.css styles (if user.css present in ~/.config/paperwm).\n     */\n    enableUserStylesheet() {\n        this.#userStylesheet = this.getConfigDir().get_child(\"user.css\");\n        if (this.#userStylesheet.query_exists(null)) {\n            let themeContext = St.ThemeContext.get_for_stage(global.stage);\n            themeContext.get_theme().load_stylesheet(this.#userStylesheet);\n        }\n    }\n\n    /**\n     * Unloads user.css styles (if user.css present in ~/.config/paperwm).\n     */\n    disableUserStylesheet() {\n        let themeContext = St.ThemeContext.get_for_stage(global.stage);\n        themeContext.get_theme().unload_stylesheet(this.#userStylesheet);\n        this.#userStylesheet = null;\n    }\n\n    spawnPager(content) {\n        const quoted = GLib.shell_quote(content);\n        Util.spawn([\"sh\", \"-c\", `echo -En ${quoted} | gedit --new-window -`]);\n    }\n}\n"
        },
        {
          "name": "flake.lock",
          "type": "blob",
          "size": 1.40234375,
          "content": "{\n  \"nodes\": {\n    \"flake-utils\": {\n      \"inputs\": {\n        \"systems\": \"systems\"\n      },\n      \"locked\": {\n        \"lastModified\": 1710146030,\n        \"narHash\": \"sha256-SZ5L6eA7HJ/nmkzGG7/ISclqe6oZdOZTNoesiInkXPQ=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"b1d9ab70662946ef0850d488da1c9019f3a9752a\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"id\": \"flake-utils\",\n        \"type\": \"indirect\"\n      }\n    },\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1736331163,\n        \"narHash\": \"sha256-3mcSChVm6bWdYaTbUSHBpErhkVmfgJ39emO1TW+erjM=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"e09d079fe4b202c1b7c1153b229f35ee83e81275\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"flake-utils\": \"flake-utils\",\n        \"nixpkgs\": \"nixpkgs\"\n      }\n    },\n    \"systems\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n"
        },
        {
          "name": "flake.nix",
          "type": "blob",
          "size": 1.0654296875,
          "content": "{ description = \"Tiled, scrollable window management for GNOME Shell\";\n\n  inputs.\"nixpkgs\".url = github:NixOS/nixpkgs;\n\n  outputs = { self, nixpkgs, flake-utils, ... }:\n  flake-utils.lib.eachDefaultSystem\n    (system:\n    let pkgs = import nixpkgs { inherit system; };\n    in\n    { packages.default = pkgs.callPackage ./default.nix {};\n      packages.vm = let hostConfig = self.nixosConfigurations.testbox.config;\n                        localConfig = hostConfig // {\n                          virtualisation = hostConfig.virtualisation // {\n                            host.pkgs = pkgs;   # Use host system's Qemu\n                          };\n                        };\n                     in localConfig.system.build.vm;\n    }) // {\n      nixosConfigurations.\"testbox\" =\n        let system = \"x86_64-linux\";\n        in nixpkgs.lib.nixosSystem {\n          inherit system;\n          modules = [\n            ./vm.nix\n            { nixpkgs.overlays = [\n                (s: super: { paperwm = self.packages.${system}.default; })\n              ];\n            }\n          ];\n        };\n    };\n}\n"
        },
        {
          "name": "gather-system-info.sh",
          "type": "blob",
          "size": 2.5322265625,
          "content": "#!/usr/bin/env bash\n# Gather and print version information about the system.\n#\n# Expects the following commands to be available:\n# - git\n# - gnome-shell\n# - gnome-extensions\n# Optionally:\n# - awk\n\nREPO=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\n\nmain() {\n    cd \"${REPO}\"\n\n    echo \"Please include this information in your bug report on GitHub!\"\n\n    show_distribution\n    show_gnome_version\n    show_display_server\n    show_paperwm_version\n    show_gnome_extensions\n}\n\nshow_distribution() {\n    echo -n \"Distribution: \"\n    if [ -f /etc/os-release ]; then\n        source /etc/os-release && echo \"${NAME}\"\n    fi\n}\n\nshow_gnome_version() {\n    gnome-shell --version\n}\n\nshow_display_server() {\n    echo -n \"Display server: \"\n    if [ \"${XDG_SESSION_TYPE}\" = \"wayland\" ]; then\n        echo \"Wayland\"\n    else\n        echo \"Xorg\"\n    fi\n}\n\nshow_paperwm_version() {\n    echo -n \"PaperWM branch/tag: \"\n    git symbolic-ref --short -q HEAD || git name-rev --tags --name-only --no-undefined \"$(git rev-parse HEAD)\"\n    echo -n \"PaperWM commit: \"\n    git rev-parse HEAD\n\n}\n\nshow_gnome_extensions() {\n    echo \"Enabled extensions:\"\n    # make a markdown list out of gnome-extensions list\n    # use gnome-extensions if it exists and falls back to bash on older gnome\n    # versions\n    if command -v gnome-extensions >/dev/null; then\n        gnome-extensions list --enabled | {\n            if command -v awk >/dev/null; then\n                awk '{print \"- \" $0}'\n            else\n                cat\n            fi\n        }\n    else\n        # compare enabled extensions to installed extensions\n        # because some uninstalled extensions could still be enabled because of\n        # stale gsettings\n        for ext in $(_enabled_extensions); do\n            if is_extension_installed \"$ext\"; then\n                echo \"- $ext\"\n            fi\n        done\n    fi\n}\n\nis_extension_installed() {\n    local ext=$1\n    [[ -d \"$HOME/.local/share/gnome-shell/extensions/$ext\" ]] || [[ -d \"/usr/share/gnome-shell/extensions/$ext\" ]]\n}\n\n_enabled_extensions() {\n    local s matches\n    s=$(gsettings get org.gnome.shell enabled-extensions)\n    # $matches contains lines with the extension uuid and lines with \", \"\n    mapfile -t matches < <(_global_rematch \"$s\" \"'([^']*)'\")\n    for match in \"${matches[@]}\"; do\n        if [[ \"$match\" =~ ^,\\s* ]]; then\n            continue\n        fi\n        echo \"$match\"\n    done\n}\n\n_global_rematch() {\n    local s=$1 regex=$2\n    while [[ $s =~ $regex ]]; do\n        echo \"${BASH_REMATCH[1]}\"\n        s=${s#*\"${BASH_REMATCH[1]}\"}\n    done\n}\n\nmain \"$@\"\n"
        },
        {
          "name": "generate-extension-zip.sh",
          "type": "blob",
          "size": 0.3876953125,
          "content": "#!/bin/sh\n\n# Creates a zip of (only) the necessary files required by Gnome for the PaperWM extension.\n# Designed for submitting a zip to extensions.gnome.org.\nzip -r paperwm@paperwm.github.com.zip \\\n\tmetadata.json \\\n\tstylesheet.css \\\n\t*.js \\\n\tconfig/user.js \\\n\tconfig/user.css \\\n\t*.ui \\\n\tLICENSE \\\n\tschemas/gschemas.compiled \\\n\tschemas/org.gnome.shell.extensions.paperwm.gschema.xml \\\n\tresources/\n"
        },
        {
          "name": "gestures.js",
          "type": "blob",
          "size": 17.796875,
          "content": "import Clutter from 'gi://Clutter';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport Meta from 'gi://Meta';\nimport Shell from 'gi://Shell';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\n\nimport { Patches, Settings, Tiling, Utils, Lib, Navigator } from './imports.js';\nimport { Easer } from './utils.js';\n\nconst DIRECTIONS = {\n    Horizontal: true,\n    Vertical: false,\n};\n\nlet vy, time, vState, navigator, direction, signals;\n// 1 is natural scrolling, -1 is unnatural\nlet natural = 1;\nexport let gliding = false; // exported\n\nlet touchpadSettings;\nexport function enable(extension) {\n    signals = new Utils.Signals();\n    // Touchpad swipes only works in Wayland\n    if (!Meta.is_wayland_compositor())\n        return;\n\n    touchpadSettings = new Gio.Settings({\n        schema_id: 'org.gnome.desktop.peripherals.touchpad',\n    });\n\n    // monitor gesture-enabled for changes\n    const gsettings = extension.getSettings();\n    signals.connect(gsettings, 'changed::gesture-enabled', () => {\n        gestureEnabled() ? swipeTrackersEnable(false) : swipeTrackersEnable();\n    });\n\n    /**\n     * Swipetrackers are reset by gnome during overview, once exits overview\n     * ensure swipe trackers are reset.\n     */\n    signals.connect(Main.overview, 'hidden', () => {\n        if (gestureEnabled()) {\n            swipeTrackersEnable(false);\n        }\n    });\n\n    /**\n       In order for the space.background actors to get any input we need to hide\n       all the window actors from the stage.\n\n       The stage takes care of scrolling vertically through the workspace mru.\n       Delegating the horizontal scrolling to each space. This way vertical\n       scrolling works anywhere, while horizontal scrolling is done on the space\n       under the mouse cursor.\n     */\n    signals.connect(global.stage, 'captured-event', (actor, event) => {\n        if (event.type() !== Clutter.EventType.TOUCHPAD_SWIPE) {\n            return Clutter.EVENT_PROPAGATE;\n        }\n\n        const fingers = event.get_touchpad_gesture_finger_count();\n        if (\n            fingers <= 2 ||\n            (Main.actionMode & Shell.ActionMode.OVERVIEW) > 0\n        ) {\n            return Clutter.EVENT_PROPAGATE;\n        }\n\n        const enabled = gestureEnabled();\n        if (!enabled) {\n            // switch to default swipe trackers\n            swipeTrackersEnable();\n        }\n\n        const phase = event.get_gesture_phase();\n        const [dx, dy] = event.get_gesture_motion_delta();\n        switch (phase) {\n        case Clutter.TouchpadGesturePhase.BEGIN:\n            if (shouldPropagate(fingers)) {\n                return Clutter.EVENT_PROPAGATE;\n            }\n\n            // PaperWM behaviour\n            time = event.get_time();\n            natural = touchpadSettings.get_boolean(\"natural-scroll\") ? 1 : -1;\n            direction = undefined;\n            navigator = Navigator.getNavigator();\n            navigator.connect('destroy', () => {\n                vState = -1;\n            });\n            return Clutter.EVENT_STOP;\n        case Clutter.TouchpadGesturePhase.UPDATE:\n            if (shouldPropagate(fingers)) {\n                return Clutter.EVENT_PROPAGATE;\n            }\n\n            if (direction === DIRECTIONS.Horizontal) {\n                return Clutter.EVENT_PROPAGATE;\n            }\n\n            if (enabled && direction === undefined) {\n                if (Math.abs(dx) < Math.abs(dy)) {\n                    vy = 0;\n                    vState = phase;\n                    direction = DIRECTIONS.Vertical;\n                }\n            }\n            if (enabled && direction === DIRECTIONS.Vertical) {\n                // if in overview => propagate event to overview\n                if (Main.overview.visible) {\n                    return Clutter.EVENT_PROPAGATE;\n                }\n\n                let dir_y = -dy * natural * Settings.prefs.swipe_sensitivity[1];\n                // if not Tiling.inPreview and swipe is UP => propagate event to overview\n                if (!Tiling.inPreview && dir_y > 0) {\n                    // enable swipe trackers which enables 3-finger up overview\n                    swipeTrackersEnable();\n                    return Clutter.EVENT_PROPAGATE;\n                }\n\n                if (gestureWorkspaceFingers() !== fingers) {\n                    return Clutter.EVENT_PROPAGATE;\n                }\n\n                // initiates workspace stack switching\n                swipeTrackersEnable(false);\n                updateVertical(dir_y, event.get_time());\n                return Clutter.EVENT_STOP;\n            }\n            return Clutter.EVENT_PROPAGATE;\n        case Clutter.TouchpadGesturePhase.CANCEL:\n        case Clutter.TouchpadGesturePhase.END:\n            if (direction === DIRECTIONS.Vertical) {\n                vState = phase;\n                endVertical();\n                return Clutter.EVENT_STOP;\n            }\n        }\n        return Clutter.EVENT_PROPAGATE;\n    });\n}\n\nfunction shouldPropagate(fingers) {\n    if (\n        // gestures disabled ==> gnome default behaviour\n        !gestureEnabled()\n    ) {\n        swipeTrackersEnable();\n        return true;\n    }\n    else if (\n        fingers === 3 && gestureHorizontalFingers() !== 3\n    ) {\n        swipeTrackersEnable();\n        return true;\n    }\n    else if (\n        // if gesure enabled AND finger 4 AND horizontal finger != 4\n        fingers === 4 &&\n        gestureHorizontalFingers() !== 4 &&\n        gestureWorkspaceFingers() !== 4\n    ) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nexport function disable() {\n    signals.destroy();\n    signals = null;\n    Utils.timeout_remove(endVerticalTimeout);\n    endVerticalTimeout = null;\n    touchpadSettings = null;\n}\n\nexport function gestureEnabled() {\n    return Settings.prefs.gesture_enabled;\n}\n\nexport function gestureHorizontalFingers() {\n    return Settings.prefs.gesture_horizontal_fingers;\n}\n\nexport function gestureWorkspaceFingers() {\n    return Settings.prefs.gesture_workspace_fingers;\n}\n\n/**\n   Handle scrolling horizontally in a space. The handler is meant to be\n   connected from each space.background and bound to the space.\n */\nlet start, dxs = [], dts = [];\nexport function horizontalScroll(space, _actor, event) {\n    if (event.type() !== Clutter.EventType.TOUCHPAD_SWIPE) {\n        return Clutter.EVENT_PROPAGATE;\n    }\n\n    const fingers = event.get_touchpad_gesture_finger_count();\n    if (\n        fingers <= 2 || gestureHorizontalFingers() !== fingers\n    ) {\n        return Clutter.EVENT_PROPAGATE;\n    }\n    else if (\n        /**\n         * If gestures are disabled AND doing a 3-finger swipe (gnome default)\n         * AND horizontal fingers are set to 3, then propagate.\n         */\n        !gestureEnabled() && fingers === 3\n    ) {\n        return Clutter.EVENT_PROPAGATE;\n    }\n\n    const phase = event.get_gesture_phase();\n    const [dx] = event.get_gesture_motion_delta();\n    switch (phase) {\n    case Clutter.TouchpadGesturePhase.UPDATE:\n        if (direction === undefined) {\n            space.vx = 0;\n            dxs = [];\n            dts = [];\n            space.hState = phase;\n            start = space.targetX;\n            Easer.removeEase(space.cloneContainer);\n            direction = DIRECTIONS.Horizontal;\n        }\n        return update(space, -dx * natural * Settings.prefs.swipe_sensitivity[0], event.get_time());\n    case Clutter.TouchpadGesturePhase.CANCEL:\n    case Clutter.TouchpadGesturePhase.END:\n        space.hState = phase;\n        done(space, event);\n        dxs = [];\n        dts = [];\n        return Clutter.EVENT_STOP;\n    }\n}\n\n/**\n   Handle scrolling horizontally using a touchscreen. This handler is meant to\n   be connected to the global Panel and recreated every time the active space\n   is changed.\n */\nlet walk = 0;\nlet sdx = null;\nexport function horizontalTouchScroll(_actor, event) {\n    const type = event.type();\n    const [myx] = event.get_coords();\n\n    switch (type) {\n    case Clutter.EventType.TOUCH_BEGIN:\n        this.vx = 0;\n        dxs = [];\n        dts = [];\n        sdx = myx;\n        walk = 0;\n        start = this.targetX;\n        this.hState = Clutter.TouchpadGesturePhase.UPDATE;\n        Easer.removeEase(this.cloneContainer);\n        navigator = Navigator.getNavigator();\n        direction = DIRECTIONS.Horizontal;\n        update(this, 0, event.get_time());\n        return Clutter.EVENT_PROPAGATE;\n    case Clutter.EventType.TOUCH_UPDATE: {\n        let dx = 0;\n        if (sdx !== null) {\n            dx = myx - sdx;\n        }\n        sdx = myx;\n        walk += Math.abs(dx);\n\n        /**\n         * Here, we ignore the friction setting and reduce the reported time\n         * scale, because the distances involved on a touch screen would make\n         * the flick motion as understood by the trackpad handler impractical.\n         */\n        update(this, -dx, event.get_time() * .75);\n        return Clutter.EVENT_PROPAGATE;\n    }\n    case Clutter.EventType.TOUCH_CANCEL:\n    case Clutter.EventType.TOUCH_END:\n        done(this, event);\n        dxs = [];\n        dts = [];\n        sdx = null;\n        walk = 0;\n        this.hState = Clutter.TouchpadGesturePhase.END;\n        if (walk < 20)\n            return Clutter.EVENT_PROPAGATE; // Don't steal non-swipe events\n        else\n            return Clutter.EVENT_STOP;\n    }\n}\n\nexport function update(space, dx, t) {\n    dxs.push(dx);\n    dts.push(t);\n\n    space.cloneContainer.x -= dx;\n    space.targetX = space.cloneContainer.x;\n\n    // Check which target window will be selected if we release the swipe at this\n    // moment\n    dx = Lib.sum(dxs.slice(-3));\n    let v = dx / (t - dts.slice(-3)[0]);\n    if (Number.isFinite(v)) {\n        space.vx = v;\n    }\n\n    let accel = Settings.prefs.swipe_friction[0] / 16; // px/ms^2\n    accel = space.vx > 0 ? -accel : accel;\n    let duration = -space.vx / accel;\n    let d = space.vx * duration + .5 * accel * duration ** 2;\n    let target = Math.round(space.targetX - d);\n\n    space.targetX = target;\n    const selected = findTargetWindow(space, start - space.targetX > 0);\n    space.targetX = space.cloneContainer.x;\n    Tiling.updateSelection(space, selected);\n    space.selectedWindow = selected;\n    space.emit('select');\n\n    return Clutter.EVENT_STOP;\n}\n\nexport function done(space) {\n    if (!Number.isFinite(space.vx) || space.length === 0) {\n        navigator.finish();\n        space.hState = -1;\n        return Clutter.EVENT_STOP;\n    }\n\n    let startGlide = space.targetX;\n\n    // timetravel\n    let accel = Settings.prefs.swipe_friction[0] / 16; // px/ms^2\n    accel = space.vx > 0 ? -accel : accel;\n    let t = -space.vx / accel;\n    let d = space.vx * t + .5 * accel * t ** 2;\n    let target = Math.round(space.targetX - d);\n\n    let mode = Clutter.AnimationMode.EASE_OUT_QUAD;\n    let first;\n    let last;\n\n    let full = space.cloneContainer.width > space.width;\n    // Only snap to the edges if we started gliding when the viewport is fully covered\n    let snap = !(space.targetX >= 0 ||\n                 space.targetX + space.cloneContainer.width <= space.width);\n    if ((snap && target > 0) ||\n        (full && target > space.width * 2)) {\n        // Snap to left edge\n        first = space[0][0];\n        target = 0;\n        mode = Clutter.AnimationMode.EASE_OUT_BACK;\n    } else if ((snap && target + space.cloneContainer.width < space.width) ||\n               (full && target + space.cloneContainer.width < -space.width)) {\n        // Snap to right edge\n        last = space[space.length - 1][0];\n        target = space.width - space.cloneContainer.width;\n        mode = Clutter.AnimationMode.EASE_OUT_BACK;\n    }\n\n    // Adjust for target window\n    let selected;\n    space.targetX = Math.round(target);\n    selected = last || first || findTargetWindow(space, start - target > 0 );\n    delete selected.lastFrame; // Invalidate frame information\n    let x = Tiling.ensuredX(selected, space);\n    target = x - selected.clone.targetX;\n\n    // Scale down travel time if we've cut down the discance to travel\n    let newD = Math.abs(startGlide - target);\n    if (newD < Math.abs(d))\n        t *= Math.abs(newD / d);\n\n    // Use a minimum duration if we've adjusted travel\n    if (target !== space.targetX || mode === Clutter.AnimationMode.EASE_OUT_BACK) {\n        t = Math.max(t, 200);\n    }\n    space.targetX = target;\n\n    Tiling.updateSelection(space, selected);\n    space.selectedWindow = selected;\n    space.emit('select');\n    gliding = true;\n    Easer.addEase(space.cloneContainer, {\n        x: space.targetX,\n        duration: t,\n        mode,\n        onStopped: () => {\n            gliding = false;\n        },\n        onComplete: () => {\n            if (!Tiling.inPreview)\n                Navigator.getNavigator().finish();\n        },\n    });\n}\n\n/**\n * Finds a target window given a space and direction (-1 is left, 1 is right)\n * @param {Tiling.Space} space\n * @param {Boolean} direction\n * @returns\n */\nexport function findTargetWindow(space, direction) {\n    let selected = space.selectedWindow?.clone;\n    if (!selected) {\n        return;\n    }\n\n    if (selected.x + space.targetX >= 0 &&\n          selected.x + selected.width + space.targetX <= space.width) {\n        return selected.meta_window;\n    }\n    selected = selected && space.selectedWindow;\n    let workArea = space.workArea();\n    let min = workArea.x;\n\n    let windows = space.getWindows().filter(w => {\n        let  clone = w.clone;\n        let x = clone.targetX + space.targetX;\n        return !(x + clone.width < min ||\n                 x > min + workArea.width);\n    });\n    if (!direction) // scroll left\n        windows.reverse();\n    let visible = windows.filter(w => {\n        let clone = w.clone;\n        let x = clone.targetX + space.targetX;\n        return x >= 0 &&\n            x + clone.width <= min + workArea.width;\n    });\n    if (visible.length > 0) {\n        return visible[0];\n    }\n\n    if (windows.length === 0) {\n        let first = space.getWindow(0, 0);\n        let last = space.getWindow(space.length - 1, 0);\n        if (direction) {\n            return last;\n        } else {\n            return first;\n        }\n    }\n\n    if (windows.length === 1)\n        return windows[0];\n\n    let closest = windows[0].clone;\n    let next = windows[1].clone;\n    let r1, r2;\n    if (direction) { // ->\n        r1 = Math.abs(closest.targetX + closest.width + space.targetX) / closest.width;\n        r2 = Math.abs(next.targetX + space.targetX - space.width) / next.width;\n    } else {\n        r1 = Math.abs(closest.targetX + space.targetX - space.width) / closest.width;\n        r2 = Math.abs(next.targetX + next.width + space.targetX) / next.width;\n    }\n    // Choose the window the most visible width (as a ratio)\n    if (r1 > r2)\n        return closest.meta_window;\n    else\n        return next.meta_window;\n}\n\nlet transition = 'easeOutQuad';\nexport function updateVertical(dy, t) {\n    // if here then initiate workspace stack (for tiling inPreview show)\n    if (!Tiling.inPreview) {\n        Tiling.spaces.initWorkspaceStack();\n    }\n\n    let selected = Tiling.spaces.selectedSpace;\n    let monitor = navigator.monitor;\n    let v = dy / (t - time);\n    time = t;\n    const StackPositions = Tiling.StackPositions;\n    if (dy > 0 &&\n        selected !== navigator.from &&\n        (selected.actor.y - dy < StackPositions.up * monitor.height)\n    ) {\n        dy = 0;\n        vy = 1;\n        selected.actor.y = StackPositions.up * selected.height;\n        Tiling.spaces.selectStackSpace(Meta.MotionDirection.UP, false, transition);\n        selected = Tiling.spaces.selectedSpace;\n        Easer.removeEase(selected.actor);\n        Easer.addEase(selected.actor, {\n            scale_x: 0.9, scale_y: 0.9, time:\n                Settings.prefs.animation_time, transition,\n        });\n    } else if (dy < 0 &&\n        (selected.actor.y - dy > StackPositions.down * monitor.height)) {\n        dy = 0;\n        vy = -1;\n        selected.actor.y = StackPositions.down * selected.height;\n        Tiling.spaces.selectStackSpace(Meta.MotionDirection.DOWN, false, transition);\n        selected = Tiling.spaces.selectedSpace;\n        Easer.removeEase(selected.actor);\n        Easer.addEase(selected.actor, {\n            scale_x: 0.9, scale_y: 0.9, time:\n                Settings.prefs.animation_time, transition,\n        });\n    } else if (Number.isFinite(v)) {\n        vy = v;\n    }\n\n    selected.actor.y -= dy;\n    if (selected === navigator.from) {\n        let scale = 0.90;\n        let s = 1 - (1 - scale) * (selected.actor.y / (0.1 * monitor.height));\n        s = Math.max(s, scale);\n        Easer.removeEase(selected.actor);\n        selected.actor.set_scale(s, s);\n    }\n}\n\nlet endVerticalTimeout;\nexport function endVertical() {\n    let test = vy > 0 ? () => vy < 0 : () => vy > 0;\n    let glide = () => {\n        if (vState < Clutter.TouchpadGesturePhase.END) {\n            endVerticalTimeout = null;\n            return false;\n        }\n\n        if (!Number.isFinite(vy)) {\n            endVerticalTimeout = null;\n            return false;\n        }\n\n        let selected = Tiling.spaces.selectedSpace;\n        let y = selected.actor.y;\n        if (selected === navigator.from && y <= 0.1 * selected.height) {\n            navigator.finish();\n            endVerticalTimeout = null;\n            return false;\n        }\n\n        if (test()) {\n            endVerticalTimeout = null;\n            return false;\n        }\n\n        let dy = vy * 16;\n        let v = vy;\n        let accel = Settings.prefs.swipe_friction[1];\n        accel = v > 0 ? -accel : accel;\n        updateVertical(dy, time + 16);\n        vy += accel;\n        return true; // repeat\n    };\n\n    /**\n     * The below timeout_add will be destroyed by the glide\n     * function - which returns false (thus destroying this timeout)\n     * when user gesture fininshes, a space is selected, etc.\n     */\n    endVerticalTimeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 16, glide);\n}\n\n/**\n * Enables (or disables) gnome swipe trackers which take care of the\n * default 3 finger swipe actions.\n * @param {Boolean} option\n */\nexport function swipeTrackersEnable(option) {\n    let enable = option ?? true;\n    Patches.swipeTrackers.forEach(t => t.enabled = enable);\n}\n"
        },
        {
          "name": "grab.js",
          "type": "blob",
          "size": 21.8720703125,
          "content": "import Clutter from 'gi://Clutter';\nimport GLib from 'gi://GLib';\nimport Graphene from 'gi://Graphene';\nimport Meta from 'gi://Meta';\nimport St from 'gi://St';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\n\nimport { Settings, Utils, Tiling, Navigator, Scratch, Gestures } from './imports.js';\nimport { Easer } from './utils.js';\n\nexport let grabbed = false;\n\nlet dragDriftTimeout;\nexport function enable() {\n\n}\n\nexport function disable() {\n    grabbed = null;\n    Utils.timeout_remove(dragDriftTimeout);\n    dragDriftTimeout = null;\n}\n\n/**\n * Returns a virtual pointer (i.e. mouse) device that can be used to\n * \"clickout\" of a drag operation when `grab_end_op` is unavailable\n * (i.e. as of Gnome 44 where `grab_end_op` was removed).\n * @returns Clutter.VirtualInputDevice\n*/\nlet virtualPointer;\nexport function getVirtualPointer() {\n    if (!virtualPointer) {\n        virtualPointer = Clutter.get_default_backend()\n            .get_default_seat()\n            .create_virtual_device(Clutter.InputDeviceType.POINTER_DEVICE);\n    }\n\n    return virtualPointer;\n}\n\nexport class MoveGrab {\n    constructor(metaWindow, type, space) {\n        this.window = metaWindow;\n        this.type = type;\n        this.signals = new Utils.Signals();\n\n        this.dragDriftPx = 12;\n\n        this.initialSpace = space || Tiling.spaces.spaceOfWindow(metaWindow);\n        this.zoneActors = new Set();\n\n        // save whether this was tiled window at start of grab\n        this.wasTiled = !(this.initialSpace.isFloating(metaWindow) ||\n            Scratch.isScratchWindow(metaWindow));\n\n        this.dndTargets = [];\n    }\n\n    begin({ center } = {}) {\n        console.debug(\"#grab\", \"begin\");\n\n        this.center = center;\n        if (grabbed)\n            return;\n\n        grabbed = true;\n        global.display.end_grab_op?.(global.get_current_time());\n        global.display.set_cursor(Meta.Cursor.MOVE_OR_RESIZE_WINDOW);\n        this.dispatcher = new Navigator.getActionDispatcher(Clutter.GrabState.POINTER);\n        this.actor = this.dispatcher.actor;\n\n        let metaWindow = this.window;\n        let actor = metaWindow.get_compositor_private();\n        let clone = metaWindow.clone;\n        let space = this.initialSpace;\n        let frame = metaWindow.get_frame_rect();\n\n        this.initialY = clone.targetY;\n        Easer.removeEase(clone);\n        let [gx, gy] = Utils.getPointerCoords();\n\n        let px = (gx - actor.x) / actor.width;\n        let py = (gy - actor.y) / actor.height;\n        actor.set_pivot_point(px, py);\n\n        let [x, y] = space.globalToScroll(gx, gy);\n        if (clone.get_parent() === this.initialSpace.cloneContainer) {\n            this.pointerOffset = [x - clone.x, y - clone.y];\n            px = (x - clone.x) / clone.width;\n            py = (y - clone.y) / clone.height;\n        } else {\n            this.pointerOffset = [gx - frame.x, gy - frame.y];\n            clone.x = frame.x;\n            clone.y = frame.y;\n            px = (gx - clone.x) / clone.width;\n            py = (gy - clone.y) / clone.height;\n        }\n        !center && clone.set_pivot_point(px, py);\n        center && clone.set_pivot_point(0, 0);\n\n        this.signals.connect(this.actor, \"button-release-event\", this.end.bind(this));\n        this.signals.connect(this.actor, \"touch-event\", (act, evt) => {\n            if (evt.type() === Clutter.EventType.TOUCH_END) {\n                this.end();\n            }\n            else {\n                this.motion(act, evt);\n            }\n        });\n        this.signals.connect(this.actor, \"motion-event\", this.motion.bind(this));\n        this.signals.connect(global.display, \"window-entered-monitor\",\n            this.beginDnD.bind(this)\n        );\n\n        this.scrollAnchor = x;\n        space.startAnimate();\n        // Make sure the window actor is visible\n        Navigator.getNavigator();\n        Tiling.animateWindow(metaWindow);\n        Easer.removeEase(space.cloneContainer);\n    }\n\n    beginDnD({ center } = {}) {\n        if (this.dnd) {\n            return;\n        }\n\n        this.center = center;\n        this.dnd = true;\n        console.debug(\"#grab\", \"begin DnD\");\n        Navigator.getNavigator().minimaps.forEach(m => typeof m === 'number'\n            ? Utils.timeout_remove(m) : m.hide());\n        global.display.set_cursor(Meta.Cursor.MOVE_OR_RESIZE_WINDOW);\n        let metaWindow = this.window;\n        let clone = metaWindow.clone;\n        let space = this.initialSpace;\n\n        let [gx, gy] = global.get_pointer();\n        let point = {};\n        if (center) {\n            point = space.cloneContainer.apply_relative_transform_to_point(\n                global.stage, new Graphene.Point3D({ x: Math.round(clone.x), y: Math.round(clone.y) }));\n        } else {\n            // For some reason the above isn't smooth when DnD is triggered from dragging\n            let [dx, dy] = this.pointerOffset;\n            point.x = gx - dx;\n            point.y = gy - dy;\n        }\n\n        let i = space.indexOf(metaWindow);\n        let single = i !== -1 && space[i].length === 1;\n        space.removeWindow(metaWindow);\n        Utils.actor_reparent(clone, Main.uiGroup);\n        clone.x = Math.round(point.x);\n        clone.y = Math.round(point.y);\n        let newScale = clone.scale_x * space.actor.scale_x;\n        clone.set_scale(newScale, newScale);\n\n        let params = { time: Settings.prefs.animation_time, scale_x: 0.5, scale_y: 0.5, opacity: 240 };\n        if (center) {\n            this.pointerOffset = [0, 0];\n            clone.set_pivot_point(0, 0);\n            params.x = gx;\n            params.y = gy;\n        }\n\n        clone.__oldOpacity = clone.opacity;\n        Easer.addEase(clone, params);\n\n        this.signals.connect(global.stage, \"button-press-event\", this.end.bind(this));\n\n        let monitor = Utils.monitorAtPoint(gx, gy);\n        let onSame = monitor === space.monitor;\n\n        let [x] = space.globalToViewport(gx, gy);\n        if (!this.center && onSame && single && space[i]) {\n            Tiling.move_to(space, space[i][0], { x: x + Settings.prefs.window_gap / 2 });\n        } else if (!this.center && onSame && single && space[i - 1]) {\n            Tiling.move_to(space, space[i - 1][0], { x: x - space[i - 1][0].clone.width - Settings.prefs.window_gap / 2 });\n        } else if (!this.center && onSame && space.length === 0) {\n            space.targetX = x;\n            space.cloneContainer.x = x;\n        }\n\n        let [sx, sy] = space.globalToScroll(gx, gy, { useTarget: true });\n\n        Tiling.spaces.forEach(space => {\n            this.signals.connect(space.background, \"motion-event\", this.spaceMotion.bind(this, space));\n        });\n        this.selectDndZone(space, sx, sy, single && onSame);\n    }\n\n    spaceMotion(space, _background, _event) {\n        let [gx, gy] = global.get_pointer();\n        let [sx, sy] = space.globalToScroll(gx, gy, { useTarget: true });\n        this.selectDndZone(space, sx, sy);\n    }\n\n    /** x,y in scroll cooridinates */\n    selectDndZone(space, x, y, initial = false) {\n        const gap = Settings.prefs.window_gap;\n        const halfGap = gap / 2;\n        const columnZoneMarginViz = 100 + halfGap;\n        const columnZoneMargin = space.length > 0 ? columnZoneMarginViz : Math.round(space.width / 4);\n        const rowZoneMargin = 250 + halfGap;\n\n        let target = null;\n        const tilingHeight = space.height - Main.layoutManager.panelBox.height;\n\n        let fakeClone = {\n            targetX: null,\n            targetY: 0,\n            width: columnZoneMargin,\n            height: tilingHeight,\n        };\n        if (space.length > 0) {\n            const lastClone = space[space.length - 1][0].clone;\n            fakeClone.targetX = lastClone.x + lastClone.width + gap;\n        } else {\n            let [sx] = space.viewportToScroll(Math.round(space.width / 2), 0);\n            fakeClone.targetX = sx + halfGap;\n        }\n\n        const columns = [...space, [{ clone: fakeClone }]];\n        for (let j = 0; j < columns.length; j++) {\n            const column = columns[j];\n            const metaWindow = column[0];\n            const clone = metaWindow.clone;\n\n            // FIXME: Non-uniform column width\n            const colX = clone.targetX;\n            const colW = clone.width;\n\n            // Fast forward if pointer is not inside the column or the column zone\n            if (x < colX - gap - columnZoneMargin) {\n                continue;\n            }\n            if (colX + colW < x) {\n                continue;\n            }\n\n            const cx = colX - halfGap;\n            const l = cx - columnZoneMargin;\n            const r = cx + columnZoneMargin;\n            if (l <= x && x <= r) {\n                target = {\n                    position: [j],\n                    center: cx,\n                    originProp: \"x\",\n                    sizeProp: \"width\",\n                    marginA: columnZoneMarginViz,\n                    marginB: columnZoneMarginViz,\n                    space,\n                    actorParams: {\n                        y: Main.layoutManager.panelBox.height,\n                        height: tilingHeight,\n                    },\n                };\n                break;\n            }\n\n            // Must be strictly within the column to tile vertically\n            if (x < colX)\n                continue;\n\n            // vertically tiled\n            for (let i = 0; i < column.length + 1; i++) {\n                let clone;\n                if (i < column.length) {\n                    clone = column[i].clone;\n                } else {\n                    let lastClone = column[i - 1].clone;\n                    clone = {\n                        targetX: lastClone.targetX,\n                        targetY: lastClone.targetY + lastClone.height + gap,\n                        width: lastClone.width,\n                        height: 0,\n                    };\n                }\n                const isFirst = i === 0;\n                const isLast = i === column.length;\n                const cy = clone.targetY - halfGap;\n                const t = cy - rowZoneMargin;\n                const b = cy + rowZoneMargin;\n                if (t <= y && y <= b) {\n                    target = {\n                        position: [j, i],\n                        center: cy,\n                        originProp: \"y\",\n                        sizeProp: \"height\",\n                        marginA: isFirst ? 0 : rowZoneMargin,\n                        marginB: isLast  ? 0 : rowZoneMargin,\n                        space,\n                        actorParams: {\n                            x: clone.targetX,\n                            width: clone.width,\n                        },\n                    };\n                    break;\n                }\n            }\n        }\n\n        const sameTarget = (a, b) => {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            if (a.space !== b.space) {\n                return false;\n            }\n            if (a.position.length !== b.position.length) {\n                return false;\n            }\n            return a.position[0] === b.position[0] &&\n                a.position[1] === b.position[1];\n        };\n\n        if (!sameTarget(target, this.dndTarget)) {\n            this.activateDndTarget(target, initial);\n        }\n    }\n\n    _dragDrfit(space, dx, xfunc) {\n        // only dift is more than one tiled window\n        if (space.getWindows().filter(w => Tiling.isTiled(w)).length <= 0) {\n            return;\n        }\n\n        Utils.timeout_remove(dragDriftTimeout);\n        dragDriftTimeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 1, () => {\n            const [px] = global.get_pointer();\n            if (xfunc(px)) {\n                return false;\n            }\n            if (space !== Tiling?.spaces?.activeSpace) {\n                return false;\n            }\n            Gestures.update(space, dx, 1);\n            return true;\n        });\n    }\n\n    motion(_actor, event) {\n        const metaWindow = this.window;\n        let [gx, gy] = global.get_pointer();\n\n        // drift move\n        const monitor = Utils.monitorAtPoint(gx, gy);\n        if (gx >= monitor.x && gx <= monitor.x + this.dragDriftPx) {\n            this._dragDrfit(\n                this.initialSpace,\n                -1 * Settings.prefs.drag_drift_speed, x => x > monitor.x + this.dragDriftPx\n            );\n        }\n        if (gx <= monitor.x + monitor.width && gx >= monitor.x + monitor.width - this.dragDriftPx) {\n            this._dragDrfit(\n                this.initialSpace,\n                Settings.prefs.drag_drift_speed, x => x < monitor.x + monitor.width - this.dragDriftPx\n            );\n        }\n\n        if (event.type() === Clutter.EventType.TOUCH_UPDATE) {\n            [gx, gy] = event.get_coords();\n            // We update global pointer to match touch event\n            Utils.warpPointer(gx, gy, false);\n        }\n        let [dx, dy] = this.pointerOffset;\n        const clone = metaWindow?.clone;\n\n        // check if window and clone exists\n        if (!clone) {\n            this.end();\n            return;\n        }\n\n        let tx = clone.get_transition('x');\n        let ty = clone.get_transition('y');\n\n        if (this.dnd) {\n            if (tx) {\n                tx.set_to(gx - dx);\n                ty.set_to(gy - dy);\n            } else {\n                clone.x = gx - dx;\n                clone.y = gy - dy;\n            }\n            return;\n        }\n\n        if (monitor !== this.initialSpace.monitor) {\n            this.beginDnD();\n            return;\n        }\n\n        if (event.get_state() & Clutter.ModifierType.CONTROL_MASK) {\n            // NB: only works in wayland\n            this.beginDnD();\n            return;\n        }\n\n        const space = this.initialSpace;\n        let [x, y] = space.globalToViewport(gx, gy);\n        space.targetX = x - this.scrollAnchor;\n        space.cloneContainer.x = space.targetX;\n\n        clone.y = y - dy;\n\n        const threshold = 300;\n        dy = Math.min(threshold, Math.abs(clone.y - this.initialY));\n        let s = 1 - Math.pow(dy / 500, 3);\n        let actor = metaWindow.get_compositor_private();\n        actor.set_scale(s, s);\n        clone.set_scale(s, s);\n\n        if (dy >= threshold) {\n            this.beginDnD();\n        }\n    }\n\n    end() {\n        grabbed = null;\n        Utils.timeout_remove(dragDriftTimeout);\n        console.debug(\"#grab\", \"end\");\n        this.signals.destroy();\n        this.signals = null;\n\n        let metaWindow = this.window;\n        let actor = metaWindow.get_compositor_private();\n        let clone = metaWindow.clone;\n        let [gx, gy] = global.get_pointer();\n\n        this.zoneActors.forEach(actor => actor.destroy());\n        let params = {\n            time: Settings.prefs.animation_time,\n            scale_x: 1,\n            scale_y: 1,\n            opacity: clone?.__oldOpacity ?? 255,\n        };\n\n        if (clone && this.dnd) {\n            const dndTarget = this.dndTarget;\n            if (dndTarget) {\n                const space = dndTarget.space;\n                space.showSelection();\n\n                if (Scratch.isScratchWindow(metaWindow)) {\n                    Scratch.unmakeScratch(metaWindow);\n                }\n\n                // Remember the global coordinates of the clone\n                let [x] = clone.get_position();\n                space.addWindow(metaWindow, ...dndTarget.position);\n\n                let [sx, sy] = space.globalToScroll(gx, gy);\n                let [dx, dy] = this.pointerOffset;\n                clone.x = sx - dx;\n                clone.y = sy - dy;\n                let newScale = clone.scale_x / space.actor.scale_x;\n                clone.set_scale(newScale, newScale);\n\n                actor.set_scale(1, 1);\n                actor.set_pivot_point(0, 0);\n\n                // Tiling.animateWindow(metaWindow);\n                params.onStopped = () => {\n                    space.moveDone();\n                    clone.set_pivot_point(0, 0);\n                };\n                Easer.addEase(clone, params);\n\n                space.targetX = space.cloneContainer.x;\n                space.selectedWindow = metaWindow;\n                if (dndTarget.position) {\n                    space.layout(true, { customAllocators: { [dndTarget.position[0]]: Tiling.allocateEqualHeight } });\n                } else {\n                    space.layout();\n                }\n                Tiling.move_to(space, metaWindow, { x: x - space.monitor.x });\n                Tiling.ensureViewport(metaWindow, space);\n\n                Utils.actor_raise(clone);\n            }\n            else if (clone) {\n                metaWindow.move_frame(true, clone.x, clone.y);\n                Scratch.makeScratch(metaWindow);\n                this.initialSpace.moveDone();\n                this.initialSpace.showSelection();\n\n                actor.set_scale(clone.scale_x, clone.scale_y);\n                actor.opacity = clone.opacity;\n\n                clone.opacity = clone.__oldOpacity || 255;\n                clone.set_scale(1, 1);\n                clone.set_pivot_point(0, 0);\n\n                const halftime = 0.5 * Settings.prefs.animation_time;\n                params.time = halftime;\n                params.onComplete = () => {\n                    Easer.addEase(actor, {\n                        time: halftime,\n                        onComplete: () => {\n                            Scratch.unmakeScratch(metaWindow);\n                        },\n                    });\n                };\n                Easer.addEase(actor, params);\n            }\n\n            Navigator.getNavigator().accept();\n        }\n        else if (\n            clone &&\n            this.initialSpace.indexOf(metaWindow) !== -1) {\n            let space = this.initialSpace;\n            space.targetX = space.cloneContainer.x;\n\n            actor.set_scale(1, 1);\n            actor.set_pivot_point(0, 0);\n\n            Tiling.animateWindow(metaWindow);\n            params.onStopped = () => {\n                space.moveDone();\n                clone.set_pivot_point(0, 0);\n            };\n            Easer.addEase(clone, params);\n\n            Tiling.ensureViewport(metaWindow, space);\n            Navigator.getNavigator().accept();\n        }\n\n        // NOTE: we reset window here so `window-added` will handle the window,\n        // and layout will work correctly etc.\n        this.window = null;\n\n        this.initialSpace.layout();\n        // ensure window is properly activated after layout/ensureViewport tweens\n        Utils.later_add(Meta.LaterType.IDLE, () => {\n            metaWindow?.get_workspace() && Main.activateWindow(metaWindow);\n        });\n\n        // // Make sure the window is on the correct workspace.\n        // // If the window is transient this will take care of its parent too.\n        Tiling.setInGrab(false);\n        if (this.dispatcher) {\n            Navigator.dismissDispatcher(Clutter.GrabState.POINTER);\n        }\n\n        global.display.set_cursor(Meta.Cursor.DEFAULT);\n\n        /**\n         * Gnome 44 removed the ability to manually end_grab_op.\n         * Previously we would end the grab_op before doing\n         * PaperWM grabs.  In 44, we can't do this so the grab op\n         * may still be in progress, which is okay, but won't be ended\n         * until we \"click out\".  We do this here if needed.\n         */\n        Utils.later_add(Meta.LaterType.IDLE, () => {\n            if (!global.display.end_grab_op && this.wasTiled) {\n                // move to current cursor position\n                let [x, y] = global.get_pointer();\n                getVirtualPointer().notify_absolute_motion(\n                    Clutter.get_current_event_time(),\n                    x, y);\n\n                getVirtualPointer().notify_button(Clutter.get_current_event_time(),\n                    Clutter.BUTTON_PRIMARY, Clutter.ButtonState.PRESSED);\n                getVirtualPointer().notify_button(Clutter.get_current_event_time(),\n                    Clutter.BUTTON_PRIMARY, Clutter.ButtonState.RELEASED);\n            }\n        });\n    }\n\n    activateDndTarget(zone, first) {\n        if (!zone) {\n            return;\n        }\n        const mkZoneActor = props => {\n            let actor = new St.Widget({ style_class: \"tile-preview\" });\n            actor.x = props.x ?? 0;\n            actor.y = props.y ?? 0;\n            actor.width = props.width ?? 0;\n            actor.height = props.height ?? 0;\n            return actor;\n        };\n\n        zone.actor = mkZoneActor({ ...zone.actorParams });\n\n        // deactivate previous target\n        this.dndTargets.filter(t => t !== zone).forEach(t => this.deactivateDndTarget(t));\n        this.dndTargets = [zone];\n\n        this.dndTarget = zone;\n        this.zoneActors.add(zone.actor);\n        const raise = () => Utils.actor_raise(zone.actor);\n\n        let params = {\n            time: Settings.prefs.animation_time,\n            [zone.originProp]: zone.center - zone.marginA,\n            [zone.sizeProp]: zone.marginA + zone.marginB,\n            onComplete: raise,\n        };\n\n        if (first) {\n            params.height = zone.actor.height;\n            params.y = zone.actor.y;\n\n            let clone = this.window.clone;\n            let space = zone.space;\n            let [x, y] = space.globalToScroll(...clone.get_transformed_position());\n            zone.actor.set_position(x, y);\n            zone.actor.set_size(...clone.get_transformed_size());\n        } else {\n            zone.actor[zone.sizeProp] = 0;\n            zone.actor[zone.originProp] = zone.center;\n        }\n\n        // zone.space.cloneContainer.add_child(zone.actor);\n        Utils.actor_add_child(zone.space.cloneContainer, zone.actor);\n        zone.space.hideSelection();\n        zone.actor.show();\n        raise();\n        Easer.addEase(zone.actor, params);\n    }\n\n    deactivateDndTarget(zone) {\n        if (zone) {\n            zone.space.showSelection();\n            Easer.addEase(zone.actor, {\n                time: Settings.prefs.animation_time,\n                [zone.originProp]: zone.center,\n                [zone.sizeProp]: 0,\n                onComplete: () => {\n                    zone.actor.destroy();\n                    this.zoneActors.delete(zone.actor);\n                },\n            });\n        }\n    }\n}\n\n/**\n * Resize grab class currently used to identify window grab type.\n */\nexport class ResizeGrab {\n    end() {\n\n    }\n}\n"
        },
        {
          "name": "imports.js",
          "type": "blob",
          "size": 0.8037109375,
          "content": "export * as AcceleratorParse from './acceleratorparse.js';\nexport * as App from './app.js';\nexport * as Background from './background.js';\nexport * as Gestures from './gestures.js';\nexport * as Grab from './grab.js';\nexport * as Keybindings from './keybindings.js';\nexport * as Lib from './lib.js';\nexport * as LiveAltTab from './liveAltTab.js';\nexport * as Minimap from './minimap.js';\nexport * as Navigator from './navigator.js';\nexport * as Patches from './patches.js';\nexport * as Scratch from './scratch.js';\nexport * as Settings from './settings.js';\nexport * as Stackoverlay from './stackoverlay.js';\nexport * as Tiling from './tiling.js';\nexport * as Topbar from './topbar.js';\nexport * as Utils from './utils.js';\nexport * as Workspace from './workspace.js';\nexport * as OverviewLayout from './overviewlayout.js';\n"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 0.8310546875,
          "content": "#!/usr/bin/env bash\n\nREPO=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\nUUID=paperwm@paperwm.github.com\nEXT_DIR=${XDG_DATA_HOME:-$HOME/.local/share}/gnome-shell/extensions\nEXT=\"$EXT_DIR\"/\"$UUID\"\nmkdir -p \"$EXT_DIR\"\n\n# Check if ext path already exists and if is a folder\nif [[ ! -L \"$EXT\" && -d \"$EXT\" ]]; then\ncat << EOF\n\nINSTALL FAILED:\n\nA previous (non-symlinked) installation of PaperWM already exists at:\n\"$EXT\".\n\nPlease remove the installed version from that path and re-run this install script.\n\nEOF\nexit 1\nfi\n\nln -snf \"$REPO\" \"$EXT\"\n\ncat << EOF\n\nINSTALL SUCCESSFUL:\n\nIf this is the first time installing PaperWM, then please logout/login \nand enable the PaperWM extension, either with the Gnome Extensions application, \nor manually by executing the following command from a terminal:\n\ngnome-extensions enable ${UUID}\n\nEOF\n"
        },
        {
          "name": "keybindings.js",
          "type": "blob",
          "size": 22.373046875,
          "content": "import Clutter from 'gi://Clutter';\nimport Meta from 'gi://Meta';\nimport Shell from 'gi://Shell';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\n\nimport {\n    Settings, Utils, Tiling, Navigator,\n    App, Scratch, LiveAltTab, Topbar\n} from './imports.js';\n\nconst Seat = Clutter.get_default_backend().get_default_seat();\nconst display = global.display;\n\nconst KEYBINDINGS_KEY = 'org.gnome.shell.extensions.paperwm.keybindings';\n\nlet keybindSettings;\nexport function enable(extension) {\n    // restore previous keybinds (in case failed to restore last time, e.g. gnome crash etc)\n    Settings.updateOverrides();\n\n    keybindSettings = extension.getSettings(KEYBINDINGS_KEY);\n    setupActions(keybindSettings);\n    signals.connect(display, 'accelerator-activated', (display, actionId, deviceId, timestamp) => {\n        handleAccelerator(display, actionId, deviceId, timestamp);\n    });\n    actions.forEach(enableAction);\n    Settings.overrideConflicts();\n\n    let schemas = [...Settings.getConflictSettings(), extension.getSettings(KEYBINDINGS_KEY)];\n    schemas.forEach(schema => {\n        signals.connect(schema, 'changed', (settings, key) => {\n            const numConflicts = Settings.conflictKeyChanged(settings, key);\n            if (numConflicts > 0) {\n                Main.notifyError(\n                    `PaperWM: overriding '${key}' keybind`,\n                    `this Gnome Keybind will be restored when PaperWM is disabled`);\n            }\n        });\n    });\n}\n\nexport function disable() {\n    signals.destroy();\n    signals = null;\n    actions.forEach(disableAction);\n    Settings.restoreConflicts();\n\n    keybindSettings = null;\n    actions = null;\n    nameMap = null;\n    actionIdMap = null;\n    keycomboMap = null;\n}\n\nexport function registerPaperAction(actionName, handler, flags) {\n    registerAction(\n        actionName,\n        handler,\n        { settings: keybindSettings, mutterFlags: flags, activeInNavigator: true });\n}\n\nexport function registerNavigatorAction(name, handler) {\n    registerAction(\n        name,\n        handler,\n        { settings: keybindSettings, opensNavigator: true });\n}\n\nexport function registerMinimapAction(name, handler) {\n    registerAction(\n        name,\n        handler,\n        {\n            settings: keybindSettings,\n            opensNavigator: true,\n            opensMinimap: true,\n            mutterFlags: Meta.KeyBindingFlags.PER_WINDOW,\n        }\n    );\n}\n\n\nlet signals, actions, nameMap, actionIdMap, keycomboMap;\nexport function setupActions(settings) {\n    signals = new Utils.Signals();\n    actions = [];\n    nameMap = {};     // mutter keybinding action name -> action\n    actionIdMap = {}; // actionID   -> action\n    keycomboMap = {}; // keycombo   -> action\n\n    /* Initialize keybindings */\n    registerAction('live-alt-tab', LiveAltTab.liveAltTab, { settings });\n    registerAction('live-alt-tab-backward', LiveAltTab.liveAltTab,\n        { settings, mutterFlags: Meta.KeyBindingFlags.IS_REVERSED });\n\n    registerAction('live-alt-tab-scratch', LiveAltTab.liveAltTabScratch, { settings });\n    registerAction('live-alt-tab-scratch-backward', LiveAltTab.liveAltTabScratch,\n        { settings, mutterFlags: Meta.KeyBindingFlags.IS_REVERSED });\n\n    registerAction('move-monitor-right', () => {\n        Tiling.spaces.switchMonitor(Meta.DisplayDirection.RIGHT, true);\n    }, { settings });\n    registerAction('move-monitor-left', () => {\n        Tiling.spaces.switchMonitor(Meta.DisplayDirection.LEFT, true);\n    }, { settings });\n    registerAction('move-monitor-above', () => {\n        Tiling.spaces.switchMonitor(Meta.DisplayDirection.UP, true);\n    }, { settings });\n    registerAction('move-monitor-below', () => {\n        Tiling.spaces.switchMonitor(Meta.DisplayDirection.DOWN, true);\n    }, { settings });\n\n    registerAction('switch-monitor-right', () => {\n        Tiling.spaces.switchMonitor(Meta.DisplayDirection.RIGHT, false);\n    }, { settings });\n    registerAction('switch-monitor-left', () => {\n        Tiling.spaces.switchMonitor(Meta.DisplayDirection.LEFT, false);\n    }, { settings });\n    registerAction('switch-monitor-above', () => {\n        Tiling.spaces.switchMonitor(Meta.DisplayDirection.UP, false);\n    }, { settings });\n    registerAction('switch-monitor-below', () => {\n        Tiling.spaces.switchMonitor(Meta.DisplayDirection.DOWN, false);\n    }, { settings });\n\n    registerAction('move-space-monitor-right', () => {\n        Tiling.spaces.moveToMonitor(Meta.DisplayDirection.RIGHT, Meta.DisplayDirection.LEFT);\n    }, { settings });\n    registerAction('move-space-monitor-left', () => {\n        Tiling.spaces.moveToMonitor(Meta.DisplayDirection.LEFT, Meta.DisplayDirection.RIGHT);\n    }, { settings });\n    registerAction('move-space-monitor-above', () => {\n        Tiling.spaces.moveToMonitor(Meta.DisplayDirection.UP, Meta.DisplayDirection.DOWN);\n    }, { settings });\n    registerAction('move-space-monitor-below', () => {\n        Tiling.spaces.moveToMonitor(Meta.DisplayDirection.DOWN, Meta.DisplayDirection.UP);\n    }, { settings });\n\n    registerAction('swap-monitor-right', () => {\n        Tiling.spaces.swapMonitor(Meta.DisplayDirection.RIGHT, Meta.DisplayDirection.LEFT);\n    }, { settings });\n    registerAction('swap-monitor-left', () => {\n        Tiling.spaces.swapMonitor(Meta.DisplayDirection.LEFT, Meta.DisplayDirection.RIGHT);\n    }, { settings });\n    registerAction('swap-monitor-above', () => {\n        Tiling.spaces.swapMonitor(Meta.DisplayDirection.UP, Meta.DisplayDirection.DOWN);\n    }, { settings });\n    registerAction('swap-monitor-below', () => {\n        Tiling.spaces.swapMonitor(Meta.DisplayDirection.DOWN, Meta.DisplayDirection.UP);\n    }, { settings });\n\n    registerNavigatorAction('previous-workspace', Tiling.selectPreviousSpace);\n    registerNavigatorAction('previous-workspace-backward', Tiling.selectPreviousSpaceBackwards);\n\n    registerNavigatorAction('move-previous-workspace', Tiling.movePreviousSpace);\n    registerNavigatorAction('move-previous-workspace-backward', Tiling.movePreviousSpaceBackwards);\n\n    registerNavigatorAction('switch-down-workspace', (mw, space) => {\n        Tiling.selectDownSpace(mw, space, false);\n    });\n    registerNavigatorAction('switch-up-workspace', (mw, space) => {\n        Tiling.selectUpSpace(mw, space, false);\n    });\n    registerNavigatorAction('switch-down-workspace-from-all-monitors', (mw, space) => {\n        Tiling.selectDownSpace(mw, space, true);\n    });\n    registerNavigatorAction('switch-up-workspace-from-all-monitors', (mw, space) => {\n        Tiling.selectUpSpace(mw, space, true);\n    });\n\n    registerNavigatorAction('move-down-workspace', Tiling.moveDownSpace);\n    registerNavigatorAction('move-up-workspace', Tiling.moveUpSpace);\n\n    registerPaperAction('toggle-top-and-position-bar', (_mw, space) => {\n        const value = !space.settings.get_boolean('show-top-bar');\n        space.settings.set_boolean('show-top-bar', value);\n        space.settings.set_boolean('show-position-bar', value);\n    });\n    registerPaperAction('toggle-top-bar', (_mw, space) => {\n        const value = space.settings.get_boolean('show-top-bar');\n        space.settings.set_boolean('show-top-bar', !value);\n    });\n    registerPaperAction('toggle-position-bar', (_mw, space) => {\n        const value = space.settings.get_boolean('show-position-bar');\n        space.settings.set_boolean('show-position-bar', !value);\n    });\n\n    registerNavigatorAction('take-window', Tiling.takeWindow);\n\n    registerMinimapAction(\"switch-next\", (mw, space) => space.switchLinear(1, false));\n    registerMinimapAction(\"switch-previous\", (mw, space) => space.switchLinear(-1, false));\n    registerMinimapAction(\"switch-next-loop\", (mw, space) => space.switchLinear(1, true));\n    registerMinimapAction(\"switch-previous-loop\", (mw, space) => space.switchLinear(-1, true));\n\n    registerMinimapAction(\"switch-right\", (mw, space) => space.switchRight(false));\n    registerMinimapAction(\"switch-left\", (mw, space) => space.switchLeft(false));\n    registerMinimapAction(\"switch-up\", (mw, space) => space.switchUp(false));\n    registerMinimapAction(\"switch-down\", (mw, space) => space.switchDown(false));\n\n    registerNavigatorAction(\"drift-left\", (mw, space) => space.driftLeft());\n    registerNavigatorAction(\"drift-right\", (mw, space) => space.driftRight());\n\n    registerMinimapAction(\"switch-right-loop\", (mw, space) => space.switchRight(true));\n    registerMinimapAction(\"switch-left-loop\", (mw, space) => space.switchLeft(true));\n    registerMinimapAction(\"switch-up-loop\", (mw, space) => space.switchUp(true));\n    registerMinimapAction(\"switch-down-loop\", (mw, space) => space.switchDown(true));\n\n    registerNavigatorAction(\"switch-up-or-else-workspace\", Tiling.switchUpOrElseWorkspace);\n    registerNavigatorAction(\"switch-down-or-else-workspace\", Tiling.switchDownOrElseWorkspace);\n\n    registerMinimapAction(\"switch-first\", Tiling.activateFirstWindow);\n    registerMinimapAction(\"switch-second\", (mw, space) => Tiling.activateNthWindow(1, space));\n    registerMinimapAction(\"switch-third\", (mw, space) => Tiling.activateNthWindow(2, space));\n    registerMinimapAction(\"switch-fourth\", (mw, space) => Tiling.activateNthWindow(3, space));\n    registerMinimapAction(\"switch-fifth\", (mw, space) => Tiling.activateNthWindow(4, space));\n    registerMinimapAction(\"switch-sixth\", (mw, space) => Tiling.activateNthWindow(5, space));\n    registerMinimapAction(\"switch-seventh\", (mw, space) => Tiling.activateNthWindow(6, space));\n    registerMinimapAction(\"switch-eighth\", (mw, space) => Tiling.activateNthWindow(7, space));\n    registerMinimapAction(\"switch-ninth\", (mw, space) => Tiling.activateNthWindow(8, space));\n    registerMinimapAction(\"switch-tenth\", (mw, space) => Tiling.activateNthWindow(9, space));\n    registerMinimapAction(\"switch-eleventh\", (mw, space) => Tiling.activateNthWindow(10, space));\n    registerMinimapAction(\"switch-last\", Tiling.activateLastWindow);\n\n    registerMinimapAction(\"switch-global-right\", (mw, space) => space.switchGlobalRight());\n    registerMinimapAction(\"switch-global-left\", (mw, space) => space.switchGlobalLeft());\n    registerMinimapAction(\"switch-global-up\", (mw, space) => space.switchGlobalUp());\n    registerMinimapAction(\"switch-global-down\", (mw, space) => space.switchGlobalDown());\n\n    registerMinimapAction(\"move-left\",\n        (_mw, space) => space.swap(Meta.MotionDirection.LEFT));\n    registerMinimapAction(\"move-right\",\n        (_mw, space) => space.swap(Meta.MotionDirection.RIGHT));\n    registerMinimapAction(\"move-up\",\n        (_mw, space) => space.swap(Meta.MotionDirection.UP));\n    registerMinimapAction(\"move-down\",\n        (_mw, space) => space.swap(Meta.MotionDirection.DOWN));\n\n    registerPaperAction(\"toggle-scratch-window\",\n        Scratch.toggleScratchWindow);\n\n    registerPaperAction(\"toggle-scratch-layer\",\n        Scratch.toggleScratch);\n\n    registerPaperAction(\"toggle-scratch\",\n        Scratch.toggle,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"activate-window-under-cursor\",\n        Tiling.activateWindowUnderCursor);\n\n    registerPaperAction(\"switch-focus-mode\",\n        Tiling.switchToNextFocusMode);\n\n    registerPaperAction(\"switch-open-window-position\",\n        Topbar.switchToNextOpenPositionMode);\n    registerPaperAction(\"open-window-position-right\",\n        (_mw, _space) => Topbar.setOpenPositionMode(Settings.OpenWindowPositions.RIGHT));\n    registerPaperAction(\"open-window-position-left\",\n        (_mw, _space) => Topbar.setOpenPositionMode(Settings.OpenWindowPositions.LEFT));\n    registerPaperAction(\"open-window-position-start\",\n        (_mw, _space) => Topbar.setOpenPositionMode(Settings.OpenWindowPositions.START));\n    registerPaperAction(\"open-window-position-end\",\n        (_mw, _space) => Topbar.setOpenPositionMode(Settings.OpenWindowPositions.END));\n    registerPaperAction(\"open-window-position-down\",\n        (_mw, _space) => Topbar.setOpenPositionMode(Settings.OpenWindowPositions.DOWN));\n    registerPaperAction(\"open-window-position-up\",\n        (_mw, _space) => Topbar.setOpenPositionMode(Settings.OpenWindowPositions.UP));\n\n    registerPaperAction(\"resize-h-inc\",\n        Tiling.resizeHInc,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"resize-h-dec\",\n        Tiling.resizeHDec,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"resize-w-inc\",\n        Tiling.resizeWInc,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"resize-w-dec\",\n        Tiling.resizeWDec,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"cycle-width\",\n        Tiling.cycleWindowWidth,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"cycle-width-backwards\",\n        Tiling.cycleWindowWidthBackwards,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"cycle-height\",\n        Tiling.cycleWindowHeight,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"cycle-height-backwards\",\n        Tiling.cycleWindowHeightBackwards,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"center-horizontally\",\n        (mw, _space) => Tiling.centerWindow(mw, true, false),\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"center-vertically\",\n        (mw, _space) => Tiling.centerWindow(mw, false, true),\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction(\"center\",\n        (mw, _space) => Tiling.centerWindow(mw, true, true),\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction('new-window',\n        App.duplicateWindow,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction('close-window',\n        metaWindow => metaWindow.delete(global.get_current_time()),\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction('slurp-in',\n        (mw, _space) => Tiling.slurp(mw),\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction('barf-out',\n        (mw, _space) => Tiling.barf(mw),\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction('barf-out-active',\n        (mw, _space) => Tiling.barf(mw, mw),\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction('toggle-maximize-width',\n        Tiling.toggleMaximizeHorizontally,\n        Meta.KeyBindingFlags.PER_WINDOW);\n\n    registerPaperAction('paper-toggle-fullscreen',\n        metaWindow => {\n            if (metaWindow.fullscreen) {\n                metaWindow.unmake_fullscreen();\n            }\n            else {\n                metaWindow.make_fullscreen();\n            }\n            Tiling.resizeHandler(metaWindow);\n        }, Meta.KeyBindingFlags.PER_WINDOW);\n}\n\nexport function idOf(mutterName) {\n    let action = byMutterName(mutterName);\n    if (action) {\n        return action.id;\n    } else {\n        return Meta.KeyBindingAction.NONE;\n    }\n}\n\nexport function byMutterName(name) {\n    return nameMap[name];\n}\n\nexport function byId(mutterId) {\n    return actionIdMap[mutterId];\n}\n\nexport function asKeyHandler(actionHandler) {\n    return (display, mw, binding) => actionHandler(mw, Tiling.spaces.selectedSpace, { display, binding });\n}\n\nexport function impliedOptions(options) {\n    options = options = Object.assign({ mutterFlags: Meta.KeyBindingFlags.NONE }, options);\n\n    if (options.opensMinimap)\n        options.opensNavigator = true;\n\n    if (options.opensNavigator)\n        options.activeInNavigator = true;\n\n    return options;\n}\n\n/**\n * handler: function(metaWindow, space, {binding, display, screen}) -> ignored\n * options: {\n *   opensMinimap:      true|false Start navigation and open the minimap\n *   opensNavigator:    true|false Start navigation (eg. Esc will restore selected space and window)\n *   activeInNavigator: true|false Action is available during navigation\n *   ...\n * }\n */\nexport function registerAction(actionName, handler, options) {\n    options = impliedOptions(options);\n\n    const {\n        settings,\n        opensNavigator,\n    } = options;\n\n    let mutterName, keyHandler;\n    if (settings) {\n        Utils.assert(actionName, \"Schema action must have a name\");\n        mutterName = actionName;\n        keyHandler = opensNavigator\n            ? asKeyHandler(Navigator.preview_navigate)\n            : asKeyHandler(handler);\n    } else {\n        // actionId, mutterName and keyHandler will be set if/when the action is bound\n    }\n\n    const action = {\n        id: Meta.KeyBindingAction.NONE,\n        name: actionName,\n        mutterName,\n        keyHandler,\n        handler,\n        options,\n    };\n\n    actions.push(action);\n    if (actionName)\n        nameMap[actionName] = action;\n\n    return action;\n}\n\n/**\n * Bind a key to an action (possibly creating a new action)\n */\nexport function bindkey(keystr, actionName = null, handler = null, options = {}) {\n    Utils.assert(!options.settings,\n        \"Can only bind schemaless actions - change action's settings instead\",\n        actionName);\n\n    let action = actionName && actions.find(a => a.name === actionName);\n    let keycombo = Settings.keystrToKeycombo(keystr);\n\n    if (!action) {\n        action = registerAction(actionName, handler, options);\n    } else {\n        let boundAction = keycomboMap[keycombo];\n        if (boundAction && boundAction !== action) {\n            console.debug(\"Rebinding\", keystr, \"to\", actionName, \"from\", boundAction?.name);\n            disableAction(boundAction);\n        }\n\n        disableAction(action);\n\n        action.handler = handler;\n        action.options = impliedOptions(options);\n    }\n\n    action.keystr = keystr;\n    action.keycombo = keycombo;\n\n    if (enableAction(action) === Meta.KeyBindingAction.NONE) {\n        // Keybinding failed: try to supply a useful error message\n        let message;\n        let boundAction = keycomboMap[keycombo];\n        if (boundAction) {\n            message = `${keystr} already bound to paperwm action: ${boundAction.name}`;\n        } else {\n            let boundId = getBoundActionId(keystr);\n            if (boundId !== Meta.KeyBindingAction.NONE) {\n                let builtInAction =\n                    Object.entries(Meta.KeyBindingAction).find(([_name, id]) => id === boundId);\n                if (builtInAction) {\n                    message = `${keystr} already bound to built-in action: ${builtInAction[0]}`;\n                } else {\n                    message = `${keystr} already bound to unknown action with id: ${boundId}`;\n                }\n            }\n        }\n\n        if (!message) {\n            message = \"Usually caused by the binding already being taken, but could not identify which action\";\n        }\n\n        Main.notifyError(\n            \"PaperWM (user.js): Could not enable keybinding\",\n            `Tried to bind ${keystr} to ${actionName}\\n${message}`);\n    }\n\n    return action.id;\n}\n\nexport function unbindkey(actionIdOrKeystr) {\n    let actionId;\n    if (typeof  actionIdOrKeystr === \"string\") {\n        const action = keycomboMap[Settings.keystrToKeycombo(actionIdOrKeystr)];\n        actionId = action && action.id;\n    } else {\n        actionId = actionIdOrKeystr;\n    }\n\n    disableAction(actionIdMap[actionId]);\n}\n\nexport function devirtualizeMask(gdkVirtualMask) {\n    const keymap = Seat.get_keymap();\n    let [success, rawMask] = keymap.map_virtual_modifiers(gdkVirtualMask);\n    if (!success)\n        throw new Error(`Couldn't devirtualize mask ${gdkVirtualMask}`);\n    return rawMask;\n}\n\nexport function rawMaskOfKeystr(keystr) {\n    let [, , mask] = Settings.accelerator_parse(keystr);\n    return devirtualizeMask(mask);\n}\n\nexport function openNavigatorHandler(actionName, keystr) {\n    const mask = rawMaskOfKeystr(keystr) & 0xff;\n\n    const binding = {\n        get_name: () => actionName,\n        get_mask: () => mask,\n        is_reversed: () => false,\n    };\n    return function(display, screen, metaWindow) {\n        return Navigator.preview_navigate(\n            metaWindow, null, { screen, display, binding });\n    };\n}\n\nexport function getBoundActionId(keystr) {\n    let [, keycodes, mask] = Settings.accelerator_parse(keystr);\n    if (keycodes.length > 1) {\n        throw new Error(`Multiple keycodes ${keycodes} ${keystr}`);\n    }\n    const rawMask = devirtualizeMask(mask);\n    return display.get_keybinding_action(keycodes[0], rawMask);\n}\n\nexport function handleAccelerator(display, actionId, _deviceId, _timestamp) {\n    const action = actionIdMap[actionId];\n    if (action) {\n        console.debug(\"#keybindings\", \"Schemaless keybinding activated\",\n            actionId, action.name);\n        action.keyHandler(display, display.focus_window);\n    }\n}\n\nexport function disableAction(action) {\n    if (action.id === Meta.KeyBindingAction.NONE) {\n        return;\n    }\n\n    const oldId = action.id;\n    if (action.options.settings) {\n        Main.wm.removeKeybinding(action.mutterName);\n        action.id = Meta.KeyBindingAction.NONE;\n        delete actionIdMap[oldId];\n    } else {\n        display.ungrab_accelerator(action.id);\n        action.id = Meta.KeyBindingAction.NONE;\n\n        delete nameMap[action.mutterName];\n        delete actionIdMap[oldId];\n        delete keycomboMap[action.keycombo];\n\n        action.mutterName = undefined;\n    }\n}\n\nexport function enableAction(action) {\n    if (action.id !== Meta.KeyBindingAction.NONE)\n        return action.id; // Already enabled (happens on enable right after init)\n\n    if (action.options.settings) {\n        let actionId = Main.wm.addKeybinding(\n            action.mutterName,\n            action.options.settings,\n            action.options.mutterFlags || Meta.KeyBindingFlags.NONE,\n            Shell.ActionMode.NORMAL,\n            action.keyHandler);\n\n        if (actionId !== Meta.KeyBindingAction.NONE) {\n            action.id = actionId;\n            actionIdMap[actionId] = action;\n        } else {\n            console.warn(\"Could not enable action\", action.name);\n        }\n    } else {\n        if (keycomboMap[action.keycombo]) {\n            console.warn(\"Other action bound to\", action.keystr, keycomboMap[action.keycombo].name);\n            return Meta.KeyBindingAction.NONE;\n        }\n\n        let actionId = Utils.grab_accelerator(action.keystr);\n        if (actionId === Meta.KeyBindingAction.NONE) {\n            console.warn(\"Failed to grab. Binding probably already taken\");\n            return Meta.KeyBindingAction.NONE;\n        }\n\n        let mutterName = Meta.external_binding_name_for_action(actionId);\n\n        action.id = actionId;\n        action.mutterName = mutterName;\n\n        actionIdMap[actionId] = action;\n        keycomboMap[action.keycombo] = action;\n        nameMap[mutterName] = action;\n\n        if (action.options.opensNavigator) {\n            action.keyHandler = openNavigatorHandler(mutterName, action.keystr);\n        } else {\n            action.keyHandler = asKeyHandler(action.handler);\n        }\n\n        Main.wm.allowKeybinding(action.mutterName, Shell.ActionMode.ALL);\n\n        return action.id;\n    }\n}\n"
        },
        {
          "name": "lib.js",
          "type": "blob",
          "size": 2.0029296875,
          "content": "/**\n * Library of simple functions for use in all other modules.\n * This libary should be clean and not depend on any other modules.\n */\n\n/**\n   Find the first x in `values` that's larger than `cur`.\n   Cycle to first value if no larger value is found.\n   `values` should be sorted in ascending order.\n */\nexport function findNext(cur, values, slack = 0) {\n    for (let i = 0; i < values.length; i++) {\n        let x = values[i];\n        if (cur < x) {\n            if (x - cur < slack) {\n                // Consider `cur` practically equal to `x`\n                continue;\n            } else {\n                return x;\n            }\n        }\n    }\n    return values[0]; // cycle\n}\n\nexport function findPrev(cur, values, slack = 0) {\n    let i = 0;\n    for (;i < values.length; i++) {\n        let x = values[i];\n        if (x + slack >= cur) {\n            break;\n        }\n    }\n    let target_i = i - 1;\n    if (target_i < 0) {\n        target_i = values.length - 1;\n    }\n\n    return values[target_i];\n}\n\nexport function arrayEqual(a, b) {\n    if (a === b)\n        return true;\n    if (!a || !b)\n        return false;\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\n\n/** Is the floating point numbers equal enough */\nexport function eq(a, b, epsilon = 0.00000001) {\n    return Math.abs(a - b) < epsilon;\n}\n\nexport function swap(array, i, j) {\n    let temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}\n\nexport function in_bounds(array, i) {\n    return i >= 0 && i < array.length;\n}\n\nexport function indent(level, str) {\n    let blank = \"\";\n    for (let i = 0; i < level; i++) {\n        blank += \"  \";\n    }\n    return blank + str;\n}\n\nexport function sum(array) {\n    return array.reduce((a, b) => a + b, 0);\n}\n\nexport function zip(...as) {\n    let r = [];\n    let minLength = Math.min(...as.map(x => x.length));\n    for (let i = 0; i < minLength; i++) {\n        r.push(as.map(a => a[i]));\n    }\n    return r;\n}\n"
        },
        {
          "name": "liveAltTab.js",
          "type": "blob",
          "size": 7.1689453125,
          "content": "import Clutter from 'gi://Clutter';\nimport Meta from 'gi://Meta';\nimport Gio from 'gi://Gio';\nimport GObject from 'gi://GObject';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as AltTab from 'resource:///org/gnome/shell/ui/altTab.js';\n\nimport { Settings, Keybindings, Tiling, Scratch, Utils } from './imports.js';\nimport { Easer } from './utils.js';\n\nlet switcherSettings;\nexport function enable() {\n    switcherSettings = new Gio.Settings({\n        schema_id: 'org.gnome.shell.app-switcher',\n    });\n}\n\nexport function disable() {\n    switcherSettings = null;\n}\n\nexport function liveAltTab(meta_window, space, { _display, _screen, binding }) {\n    let tabPopup = new LiveAltTab(binding.is_reversed(), false);\n    tabPopup.show(binding.is_reversed(), binding.get_name(), binding.get_mask());\n}\n\nexport function liveAltTabScratch(meta_window, space, { _display, _screen, binding }) {\n    let tabPopup = new LiveAltTab(binding.is_reversed(), true);\n    tabPopup.show(binding.is_reversed(), binding.get_name(), binding.get_mask());\n}\n\nexport const LiveAltTab = GObject.registerClass(\n    class LiveAltTab extends AltTab.WindowSwitcherPopup {\n        _init(reverse, scratchOnly) {\n            this.reverse = reverse;\n            this.scratchOnly = scratchOnly;\n            this.space = Tiling.spaces.selectedSpace;\n            this.monitor = Tiling.spaces.selectedSpace.monitor;\n            super._init();\n        }\n\n        _getWindowList(reverse) {\n            let tabList = global.display.get_tab_list(\n                Meta.TabList.NORMAL_ALL,\n                switcherSettings.get_boolean('current-workspace-only')\n                    ? global.workspace_manager.get_active_workspace() : null)\n                .filter(w => !Scratch.isScratchWindow(w));\n\n            let scratch = Scratch.getScratchWindows();\n\n            if (this.scratchOnly) {\n                return reverse ? scratch.reverse() : scratch;\n            }\n            else if (Scratch.isScratchWindow(global.display.focus_window)) {\n                // Access scratch windows in mru order with shift-super-tab\n                return scratch.concat(reverse ? tabList.reverse() : tabList);\n            } else {\n                return tabList.concat(reverse ? scratch.reverse() : scratch);\n            }\n        }\n\n        _initialSelection(backward, actionName) {\n            this.space.startAnimate();\n            let workArea = Main.layoutManager.getWorkAreaForMonitor(this.monitor.index);\n            let fog = new Clutter.Actor({\n                x: workArea.x, y: workArea.y,\n                width: workArea.width, height: workArea.height,\n                opacity: 0, background_color: Utils.color_from_string(\"black\")[1],\n            });\n\n            // this.blur = new Clutter.BlurEffect();\n            // this.space.cloneContainer.add_effect(this.blur);\n            this.space.setSelectionInactive();\n\n            Main.uiGroup.insert_child_above(fog, global.window_group);\n            Easer.addEase(fog, {\n                time: Settings.prefs.animation_time,\n                opacity: 100,\n            });\n            this.fog = fog;\n\n            super._initialSelection(backward, actionName);\n        }\n\n        _keyPressHandler(keysym, mutterActionId) {\n            if (keysym === Clutter.KEY_Escape)\n                return Clutter.EVENT_PROPAGATE;\n            // After the first super-tab the mutterActionId we get is apparently\n            // SWITCH_APPLICATIONS so we need to case on those too.\n            switch (mutterActionId) {\n            case Meta.KeyBindingAction.SWITCH_APPLICATIONS:\n                mutterActionId = Meta.KeyBindingAction.SWITCH_WINDOWS;\n                break;\n            case Meta.KeyBindingAction.SWITCH_APPLICATIONS_BACKWARD:\n                mutterActionId = Meta.KeyBindingAction.SWITCH_WINDOWS_BACKWARD;\n                break;\n            case Keybindings.idOf('live-alt-tab'):\n                mutterActionId = Meta.KeyBindingAction.SWITCH_WINDOWS;\n                break;\n            case Keybindings.idOf('live-alt-tab-backward'):\n                mutterActionId = Meta.KeyBindingAction.SWITCH_WINDOWS_BACKWARD;\n                break;\n            case Keybindings.idOf('live-alt-tab-scratch'):\n                mutterActionId = Meta.KeyBindingAction.SWITCH_WINDOWS;\n                break;\n            case Keybindings.idOf('live-alt-tab-scratch-backward'):\n                mutterActionId = Meta.KeyBindingAction.SWITCH_WINDOWS_BACKWARD;\n                break;\n            }\n            // let action = Keybindings.byId(mutterActionId);\n            // if (action && action.options.activeInNavigator) {\n            //     let space = Tiling.spaces.selectedSpace;\n            //     let metaWindow = space.selectedWindow;\n            //     action.handler(metaWindow, space);\n            //     return true;\n            // }\n            return super._keyPressHandler(keysym, mutterActionId);\n        }\n\n        _select(num) {\n            let to = this._switcherList.windows[num];\n\n            this.clone && this.clone.destroy();\n            this.clone = null;\n\n            let actor = to.get_compositor_private();\n            actor.remove_clip();\n            let frame = to.get_frame_rect();\n            let clone = new Clutter.Clone({ source: actor });\n            clone.position = actor.position;\n\n            let space = Tiling.spaces.spaceOfWindow(to);\n            if (space.indexOf(to) !== -1) {\n                clone.x = Tiling.ensuredX(to, space) + space.monitor.x;\n                clone.x -= frame.x - actor.x;\n            }\n\n            this.clone = clone;\n            Main.uiGroup.insert_child_above(clone, this.fog);\n\n            // Tiling.ensureViewport(to, space);\n            this._selectedIndex = num;\n            this._switcherList.highlight(num);\n        }\n\n        _finish() {\n            this.was_accepted = true;\n            super._finish();\n        }\n\n        _itemEnteredHandler() {\n            // The item-enter (mouse hover) event is triggered even after a item is\n            // accepted. This can cause _select to run on the item below the pointer\n            // ensuring the wrong window.\n            if (!this.was_accepted) {\n                // eslint-disable-next-line prefer-rest-params\n                super._itemEnteredHandler.apply(this, arguments);\n            }\n        }\n\n        _onDestroy() {\n            super._onDestroy();\n            console.debug('#preview', 'onDestroy', this.was_accepted);\n            Easer.addEase(this.fog, {\n                time: Settings.prefs.animation_time,\n                opacity: 0,\n                onStopped: () => {\n                    this.fog.destroy();\n                    this.fog = null;\n                    // this.space.cloneContainer.remove_effect(this.blur);\n                    this.clone && this.clone.destroy();\n                    this.clone = null;\n                    this.space.moveDone();\n                },\n            });\n            let index = this.was_accepted ? this._selectedIndex : 0;\n            let to = this._switcherList.windows[index];\n            Tiling.focus_handler(to);\n            let actor = to.get_compositor_private();\n            if (this.was_accepted) {\n                actor.x = this.clone.x;\n                actor.y = this.clone.y;\n            }\n            actor.set_scale(1, 1);\n        }\n    });\n"
        },
        {
          "name": "media",
          "type": "tree",
          "content": null
        },
        {
          "name": "metadata.json",
          "type": "blob",
          "size": 0.287109375,
          "content": "{\n  \"uuid\": \"paperwm@paperwm.github.com\",\n  \"name\": \"PaperWM\",\n  \"description\": \"Tiling window manager with a twist\",\n  \"url\": \"https://github.com/paperwm/PaperWM\",\n  \"settings-schema\": \"org.gnome.shell.extensions.paperwm\",\n  \"shell-version\": [ \"45\", \"46\", \"47\" ],\n  \"version-name\": \"47.1.0\"\n}\n"
        },
        {
          "name": "minimap.js",
          "type": "blob",
          "size": 9.5595703125,
          "content": "import Clutter from 'gi://Clutter';\nimport St from 'gi://St';\nimport Pango from 'gi://Pango';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\n\nimport { Settings, Utils, Lib } from './imports.js';\nimport { Easer } from './utils.js';\n\nexport function calcOffset(metaWindow) {\n    let buffer = metaWindow.get_buffer_rect();\n    let frame = metaWindow.get_frame_rect();\n    let x_offset = frame.x - buffer.x;\n    let y_offset = frame.y - buffer.y;\n    return [x_offset, y_offset];\n}\n\nexport class Minimap extends Array {\n    constructor(space, monitor) {\n        super();\n        this.space = space;\n        // initial fade\n        space.getWindows()\n            .forEach(w => {\n                w.clone?.shade?.show();\n                if (w === space.selectedWindow) {\n                    return;\n                }\n\n                Easer.addEase(w.clone?.shade, {\n                    time: Settings.prefs.animation_time,\n                    opacity: Settings.prefs.minimap_shade_opacity,\n                });\n            });\n\n        this.monitor = monitor;\n        let actor = new St.Widget({\n            name: 'minimap',\n            style_class: 'paperwm-minimap switcher-list',\n        });\n        this.actor = actor;\n        actor.height = space.height * 0.20;\n\n        let highlight = new St.Widget({\n            name: 'minimap-selection',\n            style_class: 'paperwm-minimap-selection item-box',\n        });\n        highlight.add_style_pseudo_class('selected');\n        this.highlight = highlight;\n        let label = new St.Label({ style_class: 'paperwm-minimap-label' });\n        label.clutter_text.ellipsize = Pango.EllipsizeMode.END;\n        this.label = label;\n\n        let clip = new St.Widget({ name: 'container-clip' });\n        this.clip = clip;\n        let container = new St.Widget({ name: 'minimap-container' });\n        this.container = container;\n\n        actor.add_child(highlight);\n        actor.add_child(label);\n        actor.add_child(clip);\n        clip.add_child(container);\n        clip.set_position(12 + Settings.prefs.window_gap, 12 + Math.round(1.5 * Settings.prefs.window_gap));\n        highlight.y = clip.y - 10;\n        Main.uiGroup.add_child(this.actor);\n        this.actor.opacity = 0;\n        this.createClones();\n\n        this.signals = new Utils.Signals();\n        this.signals.connect(space, 'select', this.select.bind(this));\n        this.signals.connect(space, 'window-added', this.addWindow.bind(this));\n        this.signals.connect(space, 'window-removed', this.removeWindow.bind(this));\n        this.signals.connect(space, 'layout', this.layout.bind(this));\n        this.signals.connect(space, 'swapped', this.swapped.bind(this));\n        this.signals.connect(space, 'full-layout', this.reset.bind(this));\n\n        this.layout();\n    }\n\n    static get [Symbol.species]() { return Array; }\n\n    reset() {\n        this.splice(0, this.length).forEach(c => c.forEach(x => x.destroy()));\n        this.createClones();\n        this.layout();\n    }\n\n    addWindow(space, metaWindow, index, row) {\n        let clone = this.createClone(metaWindow);\n        if (row !== undefined && this[index]) {\n            let column = this[index];\n            column.splice(row, 0, clone);\n        } else {\n            row = row || 0;\n            this.splice(index, 0, [clone]);\n        }\n        this.layout();\n    }\n\n    removeWindow(space, metaWindow, index, row) {\n        let clone = this[index][row];\n        let column = this[index];\n        column.splice(row, 1);\n        if (column.length === 0)\n            this.splice(index, 1);\n        // this.container.remove_child(clone);\n        Utils.actor_remove_child(this.container, clone);\n        this.layout();\n    }\n\n    swapped(space, index, targetIndex, row, targetRow) {\n        let column = this[index];\n        Lib.swap(this, index, targetIndex);\n        Lib.swap(column, row, targetRow);\n        this.layout();\n    }\n\n    show(animate) {\n        if (this.destroyed)\n            return;\n\n        // if minimap_scale preference is 0, then don't show\n        if (Settings.prefs.minimap_scale <= 0) {\n            return;\n        }\n\n        this.layout();\n        let time = animate ? Settings.prefs.animation_time : 0;\n        this.actor.show();\n        Easer.addEase(this.actor,\n            { opacity: 255, time, mode: Clutter.AnimationMode.EASE_OUT_EXPO });\n    }\n\n    hide(animate) {\n        if (this.destroyed)\n            return;\n        let time = animate ? Settings.prefs.animation_time : 0;\n        Easer.addEase(this.actor,\n            {\n                opacity: 0, time, mode: Clutter.AnimationMode.EASE_OUT_EXPO,\n                onComplete: () => this.actor.hide(),\n            });\n    }\n\n    createClones() {\n        for (let column of this.space) {\n            this.push(column.map(this.createClone.bind(this)));\n        }\n    }\n\n    createClone(mw) {\n        const windowActor = mw.get_compositor_private();\n        const clone = new Clutter.Clone({ source: windowActor });\n        const container = new Clutter.Actor({\n            // layout_manager: new WindowCloneLayout(this),\n            name: \"window-clone-container\",\n        });\n        clone.meta_window = mw;\n        container.clone = clone;\n        container.meta_window = mw;\n        container.add_child(clone);\n        this.container.add_child(container);\n        return container;\n    }\n\n    _allocateClone(container) {\n        let clone = container.clone;\n        let meta_window = clone.meta_window;\n        let buffer = meta_window.get_buffer_rect();\n        let frame = meta_window.get_frame_rect();\n        let scale = Settings.prefs.minimap_scale;\n        clone.set_size(buffer.width * scale, buffer.height * scale - Settings.prefs.window_gap);\n        clone.set_position((buffer.x - frame.x) * scale, (buffer.y - frame.y) * scale);\n        container.set_size(frame.width * scale, frame.height * scale);\n    }\n\n    layout() {\n        if (this.destroyed)\n            return;\n        let gap = Settings.prefs.window_gap;\n        let x = 0;\n        for (let column of this) {\n            let y = 0, w = 0;\n            for (let c of column) {\n                c.set_position(x, y);\n                this._allocateClone(c);\n                w = Math.max(w, c.width);\n                y += c.height;\n            }\n            x += w + gap;\n        }\n\n        this.clip.width = Math.min(this.container.width,\n            this.monitor.width - this.clip.x * 2 - 24);\n        this.actor.width = this.clip.width + this.clip.x * 2;\n        this.clip.set_clip(0, 0, this.clip.width, this.clip.height);\n        this.label.set_style(`max-width: ${this.clip.width}px;`);\n        this.actor.set_position(\n            this.monitor.x + Math.floor((this.monitor.width - this.actor.width) / 2),\n            this.monitor.y + Math.floor((this.monitor.height - this.actor.height) / 2));\n        this.select();\n    }\n\n    select() {\n        let position = this.space.positionOf();\n        let highlight = this.highlight;\n        if (!position) {\n            this.highlight.hide();\n            return;\n        }\n        let [index, row] = position;\n        if (!(index in this && row in this[index]))\n            return;\n        highlight.show();\n        let clip = this.clip;\n        let container = this.container;\n        let label = this.label;\n        let selected = this[index][row];\n        if (!selected)\n            return;\n\n        this.space.getWindows().forEach(w => {\n            const shade = w.clone.shade;\n            // if selected\n            if (w === selected.meta_window) {\n                shade.opacity = 0;\n                return;\n            }\n\n            // others\n            Easer.addEase(shade, {\n                time: Settings.prefs.animation_time,\n                opacity: Settings.prefs.minimap_shade_opacity,\n            });\n        });\n\n        label.text = selected.meta_window.title;\n\n        if (selected.x + selected.width + container.x > clip.width) {\n            // Align right edge of selected with the clip\n            container.x = clip.width - (selected.x + selected.width);\n            container.x -= 500; // margin\n        }\n        if (selected.x + container.x < 0) {\n            // Align left edge of selected with the clip\n            container.x = -selected.x;\n            container.x += 500; // margin\n        }\n\n        if (container.x + container.width < clip.width)\n            container.x = clip.width - container.width;\n\n        if (container.x > 0)\n            container.x = 0;\n\n        let gap = Settings.prefs.window_gap;\n        highlight.x = Math.round(\n            clip.x + container.x + selected.x - gap / 2);\n        highlight.y = Math.round(\n            clip.y + selected.y - Settings.prefs.window_gap);\n        highlight.set_size(Math.round(selected.width + gap),\n            Math.round(Math.min(selected.height, this.clip.height + gap) + gap));\n\n        let x = highlight.x + (highlight.width - label.width) / 2;\n        if (x + label.width > clip.x + clip.width)\n            x = clip.x + clip.width - label.width + 5;\n        if (x < 0)\n            x = clip.x - 5;\n\n        label.set_position(Math.round(x), this.clip.y + this.clip.height + 8);\n        this.actor.height = this.clip.y + this.clip.height + 40;\n    }\n\n    destroy() {\n        if (this.destroyed)\n            return;\n        this.space.getWindows()\n            .forEach(w => {\n                Easer.addEase(w.clone?.shade, {\n                    time: Settings.prefs.animation_time,\n                    opacity: 0,\n                    onComplete: () => w.clone?.shade.hide(),\n                });\n            });\n        this.destroyed = true;\n        this.signals.destroy();\n        this.signals = null;\n        this.splice(0, this.length);\n        this.actor.destroy();\n        this.actor = null;\n    }\n}\n"
        },
        {
          "name": "navigator.js",
          "type": "blob",
          "size": 16.4140625,
          "content": "import Clutter from 'gi://Clutter';\nimport GLib from 'gi://GLib';\nimport Meta from 'gi://Meta';\nimport St from 'gi://St';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\n\nimport {\n    Utils, Tiling, Keybindings, Topbar,\n    Scratch, Minimap, Settings\n} from './imports.js';\n\n/**\n  Navigation and previewing functionality.\n\n  This is a somewhat messy tangle of functionality relying on\n  `SwitcherPopup.SwitcherPopup` when we really should just take full control.\n */\n\nconst { signals: Signals } = imports;\nconst display = global.display;\n\nexport let navigating; // exported\nlet grab, dispatcher, signals;\nexport function enable() {\n    navigating = false;\n\n    /**\n     * Stop navigation before before/after overview. Avoids a corner-case issue\n     * in multimonitors where workspaces can get snapped to another monitor.\n     */\n    signals = new Utils.Signals();\n    signals.connect(Main.overview, 'showing', () => {\n        finishNavigation();\n    });\n    signals.connect(Main.overview, 'hidden', () => {\n        finishNavigation();\n    });\n}\n\nexport function disable() {\n    navigating = false;\n    grab = null;\n    dispatcher = null;\n    signals.destroy();\n    signals = null;\n    index = null;\n}\n\nexport function primaryModifier(mask) {\n    if (mask === 0)\n        return 0;\n\n    let primary = 1;\n    while (mask > 1) {\n        mask >>= 1;\n        primary <<= 1;\n    }\n    return primary;\n}\n\n/**\n   Handle catching keyevents and dispatching actions\n\n   Adapted from SwitcherPopup, without any visual handling.\n */\nclass ActionDispatcher {\n    /** @type {import('@gi-types/clutter10').GrabState} */\n    mode;\n\n    constructor() {\n        console.debug(\"#dispatch\", \"created\");\n        this.signals = new Utils.Signals();\n        this.actor = Tiling.spaces.spaceContainer;\n        this.actor.reactive = true;\n        this.navigator = getNavigator();\n\n        if (grab) {\n            console.debug(\"#dispatch\", \"already in grab\");\n            return;\n        }\n\n        // grab = stage.grab(this.actor)\n        grab = Main.pushModal(this.actor);\n        // We expect at least a keyboard grab here\n        if ((grab.get_seat_state() & Clutter.GrabState.KEYBOARD) === 0) {\n            console.error(\"Failed to grab modal\");\n            throw new Error('Could not grab modal');\n        }\n\n        this.signals.connect(this.actor, 'key-press-event', this._keyPressEvent.bind(this));\n        this.signals.connect(this.actor, 'key-release-event', this._keyReleaseEvent.bind(this));\n\n        this.keyPressCallbacks = [];\n        this.keyReleaseCallbacks = [];\n\n        this._noModsTimeoutId = null;\n        this._doActionTimeout = null;\n    }\n\n    /**\n     * Adds a signal to this dispatcher.  Will be destroyed when this\n     * dispatcher is destroyed.\n     */\n    addKeypressCallback(handler) {\n        this.keyPressCallbacks.push(handler);\n        return this;\n    }\n\n    /**\n     * Adds a signal to this dispatcher.  Will be destroyed when this\n     * dispatcher is destroyed.\n     */\n    addKeyReleaseCallback(handler) {\n        this.keyReleaseCallbacks.push(handler);\n        return this;\n    }\n\n    show(_backward, binding, mask) {\n        this._modifierMask = primaryModifier(mask);\n        this.navigator = getNavigator();\n        Topbar.fixTopBar();\n        let actionId = Keybindings.idOf(binding);\n        if (actionId === Meta.KeyBindingAction.NONE) {\n            try {\n                // Check for built-in actions\n                actionId = Meta.prefs_get_keybinding_action(binding);\n            } catch (e) {\n                console.debug(\"Couldn't resolve action name\");\n                return false;\n            }\n        }\n\n        this._doAction(actionId);\n\n        // There's a race condition; if the user released Alt before\n        // we got the grab, then we won't be notified. (See\n        // https://bugzilla.gnome.org/show_bug.cgi?id=596695 for\n        // details.) So we check now. (straight from SwitcherPopup)\n        if (this._modifierMask) {\n            let [, , mods] = global.get_pointer();\n            if (!(mods & this._modifierMask)) {\n                this._finish(global.get_current_time());\n                return false;\n            }\n        } else {\n            this._resetNoModsTimeout();\n        }\n\n        return true;\n    }\n\n    _resetNoModsTimeout() {\n        Utils.timeout_remove(this._noModsTimeoutId);\n        this._noModsTimeoutId = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT,\n            0, () => {\n                this._finish(global.get_current_time());\n                this._noModsTimeoutId = null;\n                return false; // stops timeout recurrence\n            });\n    }\n\n    _keyPressEvent(_actor, event) {\n        if (!this._modifierMask) {\n            this._modifierMask = primaryModifier(event.get_state());\n        }\n        let keysym = event.get_key_symbol();\n        let action = global.display.get_keybinding_action(\n            event.get_key_code(),\n            event.get_state());\n\n        // run callbacks and if any return true, stop bubbling\n        if (this.keyPressCallbacks.some(callback => {\n            return callback(this._modifierMask, keysym, event);\n        })) {\n            return Clutter.EVENT_STOP;\n        }\n\n        // Popping the modal on keypress doesn't work properly, as the release\n        // event will leak to the active window. To work around this we initate\n        // visual destruction on key-press and signal to the release handler\n        // that we should destroy the dispactcher too\n        // https://github.com/paperwm/PaperWM/issues/70\n        if (keysym === Clutter.KEY_Escape) {\n            this._destroy = true;\n            getNavigator().accept();\n            getNavigator().destroy();\n            return Clutter.EVENT_STOP;\n        }\n\n        this._doAction(action);\n\n        return Clutter.EVENT_STOP;\n    }\n\n    _keyReleaseEvent(_actor, event) {\n        if (this._destroy) {\n            dismissDispatcher(Clutter.GrabState.KEYBOARD);\n        }\n\n        if (this._modifierMask) {\n            let [, , mods] = global.get_pointer();\n            let state = mods & this._modifierMask;\n\n            if (state === 0)\n                this._finish(event.get_time());\n        } else {\n            this._resetNoModsTimeout();\n        }\n\n        this.keyReleaseCallbacks.forEach(callback => callback());\n        return Clutter.EVENT_STOP;\n    }\n\n    _doAction(mutterActionId) {\n        let action = Keybindings.byId(mutterActionId);\n        let space = Tiling.spaces.selectedSpace;\n        let metaWindow = space.selectedWindow;\n        const nav = getNavigator();\n\n        if (mutterActionId === Meta.KeyBindingAction.MINIMIZE) {\n            metaWindow.minimize();\n        } else if (action && action.options.activeInNavigator) {\n            // action is performed while navigator is open (e.g. switch-left)\n            if (!metaWindow && (action.options.mutterFlags & Meta.KeyBindingFlags.PER_WINDOW)) {\n                return;\n            }\n\n            if (!Tiling.inGrab && action.options.opensMinimap) {\n                nav.showMinimap(space);\n            }\n            action.handler(metaWindow, space, { navigator: this.navigator });\n            if (space !== Tiling.spaces.selectedSpace) {\n                this.navigator.minimaps.forEach(m => typeof m === 'number'\n                    ? Utils.timeout_remove(m) : m.hide());\n            }\n            if (Tiling.inGrab && !Tiling.inGrab.dnd && Tiling.inGrab.window) {\n                Tiling.inGrab.beginDnD();\n            }\n        } else if (action) {\n            // closes navigator and action is performed afterwards\n            // (e.g. switch-monitor-left)\n            this._resetNoModsTimeout();\n            this._doActionTimeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 0, () => {\n                action.handler(metaWindow, space);\n                this._doActionTimeout = null;\n                return false; // on return false destroys timeout\n            });\n        }\n    }\n\n    _finish(_timestamp) {\n        let nav = getNavigator();\n        nav.accept();\n        !this._destroy && nav.destroy();\n        dismissDispatcher(Clutter.GrabState.KEYBOARD);\n        let space = Tiling.spaces.selectedSpace;\n        let metaWindow = space.selectedWindow;\n        if (metaWindow) {\n            if (!metaWindow.appears_focused) {\n                space.setSelectionInactive();\n            }\n        }\n    }\n\n    destroy() {\n        Utils.timeout_remove(this._noModsTimeoutId);\n        this._noModsTimeoutId = null;\n        Utils.timeout_remove(this._doActionTimeout);\n        this._doActionTimeout = null;\n\n        try {\n            if (grab) {\n                Main.popModal(grab);\n                grab = null;\n            }\n        } catch (e) {\n            console.debug(\"Failed to release grab: \", e);\n        }\n\n        this.actor.reactive = false;\n        this.signals.destroy();\n        this.signals = null;\n        // We have already destroyed the navigator\n        getNavigator().destroy();\n        dispatcher = null;\n    }\n}\n\nlet index = 0;\nexport let navigator;\nclass NavigatorClass {\n    constructor() {\n        console.debug(\"#navigator\", \"nav created\");\n\n        /**\n         * Hint for using take window mode (used in `takeWindow`).\n         */\n        this.takeHint = new St.Label({ style_class: 'take-window-hint' });\n        this.takeHint.clutter_text.set_markup(\n            `<i>• press <span foreground=\"#6be67b\">spacebar</span> to return the last taken window</i>\n<i>• press <span foreground=\"#6be67b\">tab</span> to cycle forward through taken windows</i>\n<i>• press <span foreground=\"#6be67b\">shift+tab</span> to cycle backward through taken windows</i>\n<i>• press <span foreground=\"#6be67b\">q</span> to close all taken windows</i>`\n        );\n\n        navigating = true;\n\n        this.was_accepted = false;\n        this.index = index++;\n\n        this._block = Main.wm._blockAnimations;\n        Main.wm._blockAnimations = true;\n        // Meta.disable_unredirect_for_screen(screen);\n        this.space = Tiling.spaces.activeSpace;\n\n        this._startWindow = this.space.selectedWindow;\n        this.from = this.space;\n        this.monitor = this.space.monitor;\n        this.monitor.clickOverlay.hide();\n        this.minimaps = new Map();\n\n        Topbar.fixTopBar();\n\n        Scratch.animateWindows();\n        this.space.startAnimate();\n    }\n\n    showMinimap(space) {\n        let minimap = this.minimaps.get(space);\n        if (!minimap) {\n            let minimapId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 200, () => {\n                minimap = new Minimap.Minimap(space, this.monitor);\n                space.startAnimate();\n                minimap.show(false);\n                this.minimaps.set(space, minimap);\n                return false; // on return false destroys timeout\n            });\n            this.minimaps.set(space, minimapId);\n        } else {\n            typeof minimap !== 'number' && minimap.show();\n        }\n    }\n\n    /**\n     * Shows the \"take window\" hint.\n     * @param {Boolean} show\n     */\n    showTakeHint(show = true) {\n        if (show) {\n            // set position on stage, take into account monitor\n            const monitor = this.space.monitor;\n            const x = monitor.x + monitor.width - 402;\n            const y = monitor.height - 100;\n\n            this.takeHint.opacity = 0;\n            // global.stage.add_child(this.takeHint);\n            Utils.actor_add_child(global.stage, this.takeHint);\n            this.takeHint.set_position(x, y);\n\n            Utils.Easer.addEase(this.takeHint, {\n                time: Settings.prefs.animation_time,\n                opacity: 255,\n            });\n        } else {\n            this.takeHint.opacity = 255;\n            // global.stage.add_child(this.takeHint);\n            Utils.actor_add_child(global.stage, this.takeHint);\n            Utils.Easer.addEase(this.takeHint, {\n                time: Settings.prefs.animation_time,\n                opacity: 0,\n                onComplete: () => {\n                    // global.stage.remove_child(this.takeHint);\n                    Utils.actor_remove_child(global.stage, this.takeHint);\n                },\n            });\n        }\n    }\n\n    accept() {\n        this.was_accepted = true;\n    }\n\n    finish(force = false) {\n        if (!force && grab) {\n            return;\n        }\n\n        this.accept();\n        this.destroy();\n    }\n\n    destroy() {\n        this.minimaps.forEach(m => {\n            if (typeof  m === 'number') {\n                Utils.timeout_remove(m);\n            }\n            else {\n                m.destroy();\n            }\n        });\n\n        if (Tiling.inGrab && !Tiling.inGrab.dnd) {\n            Tiling.inGrab?.beginDnD();\n        }\n\n        if (Main.panel.statusArea.appMenu)\n            Main.panel.statusArea.appMenu.container.show();\n\n        let force = Tiling.inPreview;\n        navigating = false;\n\n        if (force) {\n            this?.space?.monitor?.clickOverlay.hide();\n        }\n\n        let space = Tiling.spaces.selectedSpace;\n        this.space = space;\n\n        let from = this.from;\n        let selected = this.space.selectedWindow;\n        if (!this.was_accepted) {\n            // Abort the navigation\n            this.space = from;\n            if (this.startWindow && this._startWindow.get_compositor_private())\n                selected = this._startWindow;\n            else\n                selected = display.focus_window;\n        }\n\n        let visible = [];\n        for (let monitor of Main.layoutManager.monitors) {\n            visible.push(Tiling.spaces.monitors.get(monitor));\n        }\n\n        if (!visible.includes(space) && this.monitor !== this.space.monitor) {\n            this.space.setMonitor(this.monitor, true);\n        }\n\n        const workspaceId = this.space.workspace.index();\n        if (this.space === from) {\n            // Animate the selected space into full view - normally this\n            // happens on workspace switch, but activating the same workspace\n            // again doesn't trigger a switch signal\n            if (force) {\n                Tiling.spaces.switchWorkspace(null, workspaceId, workspaceId, force);\n            }\n        } else if (Tiling.inGrab && Tiling.inGrab.window) {\n            this.space.activateWithFocus(Tiling.inGrab.window, false, true);\n        } else {\n            this.space.activate(false, true);\n        }\n\n        selected = this.space.indexOf(selected) !== -1 ? selected\n            : this.space.selectedWindow;\n\n        let curFocus = display.focus_window;\n        if (force && curFocus && curFocus.is_on_all_workspaces()) {\n            selected = curFocus;\n        }\n\n        if (selected && !Tiling.inGrab) {\n            let hasFocus = selected && selected.has_focus();\n            selected.foreach_transient(mw => {\n                hasFocus = mw.has_focus() || hasFocus;\n            });\n            if (hasFocus) {\n                Tiling.focus_handler(selected);\n            } else {\n                Main.activateWindow(selected);\n            }\n        }\n        if (selected && Tiling.inGrab && !this.was_accepted) {\n            Tiling.focus_handler(selected);\n        }\n\n        if (!Tiling.inGrab)\n            Scratch.showWindows();\n\n        Topbar.fixTopBar();\n\n        Main.wm._blockAnimations = this._block;\n        this.space.moveDone();\n\n        this.emit('destroy', this.was_accepted);\n        navigator = false;\n    }\n}\nexport let Navigator = NavigatorClass;\nSignals.addSignalMethods(Navigator.prototype);\n\nexport function getNavigator() {\n    if (navigator)\n        return navigator;\n\n    navigator = new Navigator();\n    return navigator;\n}\n\n/**\n * Finishes navigation if navigator exists.\n * Useful to call before disabling other modules.\n */\nexport function finishNavigation(force = true) {\n    if (navigator) {\n        navigator.finish(force);\n    }\n}\n\n/**\n *\n * @param {import('@gi-types/clutter10').GrabState} mode\n * @returns {ActionDispatcher}\n */\nexport function getActionDispatcher(mode) {\n    if (dispatcher) {\n        dispatcher.mode |= mode;\n        return dispatcher;\n    }\n    dispatcher = new ActionDispatcher();\n    return getActionDispatcher(mode);\n}\n\n/**\n * Fishes current dispatcher (if any).\n */\nexport function finishDispatching() {\n    dispatcher?._finish(global.get_current_time());\n}\n\n/**\n *\n * @param {import('@gi-types/clutter10').GrabState} mode\n */\nexport function dismissDispatcher(mode) {\n    if (!dispatcher) {\n        return;\n    }\n\n    dispatcher.mode ^= mode;\n    if (dispatcher.mode === Clutter.GrabState.NONE) {\n        dispatcher.destroy();\n    }\n}\n\nexport function preview_navigate(meta_window, space, { _display, _screen, binding }) {\n    let tabPopup = getActionDispatcher(Clutter.GrabState.KEYBOARD);\n    tabPopup.show(binding.is_reversed(), binding.get_name(), binding.get_mask());\n}\n"
        },
        {
          "name": "overviewlayout.js",
          "type": "blob",
          "size": 10.111328125,
          "content": "import * as Workspace from 'resource:///org/gnome/shell/ui/workspace.js';\nimport * as Util from 'resource:///org/gnome/shell/misc/util.js';\nimport * as Params from 'resource:///org/gnome/shell/misc/params.js';\n\nimport { Settings, Tiling } from './imports.js';\n\n/**\n * Gnome 45's UnalignedLayoutStrategy is not exported.  Hence, we recreate this class\n * with modifications to ensure window ordering reflects tiling window order in overview.\n *\n * See https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-45/js/ui/workspace.js\n */\nexport class UnalignedLayoutStrategy extends Workspace.LayoutStrategy {\n    _newRow() {\n        // Row properties:\n        //\n        // * x, y are the position of row, relative to area\n        //\n        // * width, height are the scaled versions of fullWidth, fullHeight\n        //\n        // * width also has the spacing in between windows. It's not in\n        //   fullWidth, as the spacing is constant, whereas fullWidth is\n        //   meant to be scaled\n        //\n        // * neither height/fullHeight have any sort of spacing or padding\n        return {\n            x: 0, y: 0,\n            width: 0, height: 0,\n            fullWidth: 0, fullHeight: 0,\n            windows: [],\n        };\n    }\n\n    // Computes and returns an individual scaling factor for @window,\n    // to be applied in addition to the overall layout scale.\n    _computeWindowScale(window) {\n        // Since we align windows next to each other, the height of the\n        // thumbnails is much more important to preserve than the width of\n        // them, so two windows with equal height, but maybe differering\n        // widths line up.\n        let ratio = window.boundingBox.height / this._monitor.height;\n\n        // The purpose of this manipulation here is to prevent windows\n        // from getting too small. For something like a calculator window,\n        // we need to bump up the size just a bit to make sure it looks\n        // good. We'll use a multiplier of 1.5 for this.\n\n        // Map from [0, 1] to [1.5, 1]\n        return Util.lerp(1.5, 1, ratio);\n    }\n\n    _computeRowSizes(layout) {\n        let { rows, scale } = layout;\n        for (let i = 0; i < rows.length; i++) {\n            let row = rows[i];\n            row.width = row.fullWidth * scale + (row.windows.length - 1) * this._columnSpacing;\n            row.height = row.fullHeight * scale;\n        }\n    }\n\n    _keepSameRow(row, window, width, idealRowWidth) {\n        // enforce a minimum number of windows per overview row\n        if (row.windows.length < Settings.prefs.overview_min_windows_per_row) {\n            return true;\n        }\n\n        if (row.fullWidth + width <= idealRowWidth)\n            return true;\n\n        let oldRatio = row.fullWidth / idealRowWidth;\n        let newRatio = (row.fullWidth + width) / idealRowWidth;\n\n        if (Math.abs(1 - newRatio) < Math.abs(1 - oldRatio))\n            return true;\n\n        return false;\n    }\n\n    computeLayout(windows, layoutParams) {\n        layoutParams = Params.parse(layoutParams, {\n            numRows: 0,\n        });\n\n        if (layoutParams.numRows === 0)\n            throw new Error(`${this.constructor.name}: No numRows given in layout params`);\n\n        let numRows = layoutParams.numRows;\n\n        let rows = [];\n        let totalWidth = 0;\n        for (let i = 0; i < windows.length; i++) {\n            let window = windows[i];\n            let s = this._computeWindowScale(window);\n            totalWidth += window.boundingBox.width * s;\n        }\n\n        let idealRowWidth = totalWidth / numRows;\n\n        let sortedWindows = windows.slice();\n        // sorting needs to be done here to address moved windows\n        sortedWindows.sort(sortWindows);\n\n        let windowIdx = 0;\n        for (let i = 0; i < numRows; i++) {\n            let row = this._newRow();\n            rows.push(row);\n\n            for (; windowIdx < sortedWindows.length; windowIdx++) {\n                let window = sortedWindows[windowIdx];\n                let s = this._computeWindowScale(window);\n                let width = window.boundingBox.width * s;\n                let height = window.boundingBox.height * s;\n                row.fullHeight = Math.max(row.fullHeight, height);\n\n                // either new width is < idealWidth or new width is nearer from idealWidth then oldWidth\n                if (this._keepSameRow(row, window, width, idealRowWidth) || (i === numRows - 1)) {\n                    row.windows.push(window);\n                    row.fullWidth += width;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        let gridHeight = 0;\n        let maxRow;\n        for (let i = 0; i < numRows; i++) {\n            let row = rows[i];\n\n            if (!maxRow || row.fullWidth > maxRow.fullWidth)\n                maxRow = row;\n            gridHeight += row.fullHeight;\n        }\n\n        return {\n            numRows,\n            rows,\n            maxColumns: maxRow.windows.length,\n            gridWidth: maxRow.fullWidth,\n            gridHeight,\n        };\n    }\n\n    computeScaleAndSpace(layout, area) {\n        let hspacing = (layout.maxColumns - 1) * this._columnSpacing;\n        let vspacing = (layout.numRows - 1) * this._rowSpacing;\n\n        let spacedWidth = area.width - hspacing;\n        let spacedHeight = area.height - vspacing;\n\n        let horizontalScale = spacedWidth / layout.gridWidth;\n        let verticalScale = spacedHeight / layout.gridHeight;\n\n        // Thumbnails should be less than 70% of the original size\n        let scale = Math.min(\n            horizontalScale, verticalScale, Settings.prefs.overview_max_window_scale);\n\n        let scaledLayoutWidth = layout.gridWidth * scale + hspacing;\n        let scaledLayoutHeight = layout.gridHeight * scale + vspacing;\n        let space = (scaledLayoutWidth * scaledLayoutHeight) / (area.width * area.height);\n\n        layout.scale = scale;\n\n        return [scale, space];\n    }\n\n    computeWindowSlots(layout, area) {\n        this._computeRowSizes(layout);\n\n        let { rows, scale } = layout;\n\n        let slots = [];\n\n        // Do this in three parts.\n        let heightWithoutSpacing = 0;\n        for (let i = 0; i < rows.length; i++) {\n            let row = rows[i];\n            heightWithoutSpacing += row.height;\n        }\n\n        let verticalSpacing = (rows.length - 1) * this._rowSpacing;\n        let additionalVerticalScale = Math.min(1, (area.height - verticalSpacing) / heightWithoutSpacing);\n\n        // keep track how much smaller the grid becomes due to scaling\n        // so it can be centered again\n        let compensation = 0;\n        let y = 0;\n\n        for (let i = 0; i < rows.length; i++) {\n            let row = rows[i];\n\n            // If this window layout row doesn't fit in the actual\n            // geometry, then apply an additional scale to it.\n            let horizontalSpacing = (row.windows.length - 1) * this._columnSpacing;\n            let widthWithoutSpacing = row.width - horizontalSpacing;\n            let additionalHorizontalScale = Math.min(1, (area.width - horizontalSpacing) / widthWithoutSpacing);\n\n            if (additionalHorizontalScale < additionalVerticalScale) {\n                row.additionalScale = additionalHorizontalScale;\n                // Only consider the scaling in addition to the vertical scaling for centering.\n                compensation += (additionalVerticalScale - additionalHorizontalScale) * row.height;\n            } else {\n                row.additionalScale = additionalVerticalScale;\n                // No compensation when scaling vertically since centering based on a too large\n                // height would undo what vertical scaling is trying to achieve.\n            }\n\n            row.x = area.x + (Math.max(area.width - (widthWithoutSpacing * row.additionalScale + horizontalSpacing), 0) / 2);\n            row.y = area.y + (Math.max(area.height - (heightWithoutSpacing + verticalSpacing), 0) / 2) + y;\n            y += row.height * row.additionalScale + this._rowSpacing;\n        }\n\n        compensation /= 2;\n\n        for (let i = 0; i < rows.length; i++) {\n            const row = rows[i];\n            const rowY = row.y + compensation;\n            const rowHeight = row.height * row.additionalScale;\n\n            let x = row.x;\n            for (let j = 0; j < row.windows.length; j++) {\n                let window = row.windows[j];\n\n                let s = scale * this._computeWindowScale(window) * row.additionalScale;\n                let cellWidth = window.boundingBox.width * s;\n                let cellHeight = window.boundingBox.height * s;\n\n                s = Math.min(s, Settings.prefs.overview_max_window_scale);\n                let cloneWidth = window.boundingBox.width * s;\n                const cloneHeight = window.boundingBox.height * s;\n\n                let cloneX = x + (cellWidth - cloneWidth) / 2;\n                let cloneY;\n\n                // If there's only one row, align windows vertically centered inside the row\n                if (rows.length === 1)\n                    cloneY = rowY + (rowHeight - cloneHeight) / 2;\n                // If there are multiple rows, align windows to the bottom edge of the row\n                else\n                    cloneY = rowY + rowHeight - cellHeight;\n\n                // Align with the pixel grid to prevent blurry windows at scale = 1\n                cloneX = Math.floor(cloneX);\n                cloneY = Math.floor(cloneY);\n\n                slots.push([cloneX, cloneY, cloneWidth, cloneHeight, window]);\n                x += cellWidth + this._columnSpacing;\n            }\n        }\n        return slots;\n    }\n}\n\n/**\n * Ensures windows are sorted correctly in overview (correctly being the tiled order in the space).\n */\nexport function sortWindows(a, b) {\n    let aw = a.metaWindow;\n    let bw = b.metaWindow;\n    if (!aw && !bw) {\n        return 0;\n    }\n    if (!aw) {\n        return -1;\n    }\n    if (!bw) {\n        return 1;\n    }\n\n    let spaceA = Tiling.spaces.spaceOfWindow(aw);\n    let spaceB = Tiling.spaces.spaceOfWindow(bw);\n    let ia = spaceA.indexOf(aw);\n    let ib = spaceB.indexOf(bw);\n    if (ia === -1 && ib === -1) {\n        return aw.get_stable_sequence() - bw.get_stable_sequence();\n    }\n    if (ia === -1) {\n        return -1;\n    }\n    if (ib === -1) {\n        return 1;\n    }\n    return ia - ib;\n}\n"
        },
        {
          "name": "patches.js",
          "type": "blob",
          "size": 23.1865234375,
          "content": "/* eslint-disable no-undef */\n/* eslint-disable no-invalid-this */\nimport Clutter from 'gi://Clutter';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport Meta from 'gi://Meta';\nimport Shell from 'gi://Shell';\nimport St from 'gi://St';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as Workspace from 'resource:///org/gnome/shell/ui/workspace.js';\nimport * as WorkspaceThumbnail from 'resource:///org/gnome/shell/ui/workspaceThumbnail.js';\nimport * as WorkspaceAnimation from 'resource:///org/gnome/shell/ui/workspaceAnimation.js';\nimport * as AltTab from 'resource:///org/gnome/shell/ui/altTab.js';\nimport * as WindowManager from 'resource:///org/gnome/shell/ui/windowManager.js';\nimport * as WindowPreview from 'resource:///org/gnome/shell/ui/windowPreview.js';\nimport * as Screenshot from 'resource:///org/gnome/shell/ui/screenshot.js';\n\nimport { Utils, Tiling, Scratch, Settings, OverviewLayout } from './imports.js';\n\n/**\n  Some of Gnome Shell's default behavior is really sub-optimal when using\n  paperWM. Other features are simply not possible to implement without monkey\n  patching. This is a collection of monkey patches and preferences which works\n  around these problems and facilitates new features.\n */\n\nlet savedProps, signals;\nlet gsettings, mutterSettings;\nlet pillSwipeTimer;\nexport function enable(extension) {\n    savedProps = new Map();\n    gsettings = extension.getSettings();\n\n    // save the last display server used\n    gsettings.set_string(\n        'last-used-display-server',\n        Meta.is_wayland_compositor() ? \"Wayland\" : \"Xorg\"\n    );\n\n    mutterSettings = new Gio.Settings({ schema_id: 'org.gnome.mutter' });\n    signals = new Utils.Signals();\n    setupSwipeTrackers();\n    setupOverrides();\n    enableOverrides();\n    setupRuntimeDisables();\n    setupActions();\n}\n\nexport function disable() {\n    disableOverrides();\n    restoreRuntimeDisables();\n    actions.forEach(a => global.stage.add_action(a));\n    actions = null;\n\n    signals.destroy();\n    signals = null;\n\n    savedProps = null;\n    swipeTrackers = null;\n    gsettings = null;\n    mutterSettings = null;\n    Utils.timeout_remove(pillSwipeTimer);\n    pillSwipeTimer = null;\n    actions = null;\n}\n\nexport function registerOverrideProp(obj, name, override, warn = true) {\n    if (!obj)\n        return;\n\n    // check if prop exists\n    const exists = obj?.[name];\n    if (!exists && warn) {\n        console.warn(`#PaperWM: attempt to override prop for '${name}' failed: is null or undefined`);\n    }\n\n    let saved = getSavedProp(obj, name) ?? obj[name];\n    let props = savedProps.get(obj);\n    if (!props) {\n        props = {};\n        savedProps.set(obj, props);\n    }\n    props[name] = {\n        saved,\n        override,\n    };\n}\n\nexport function registerOverridePrototype(obj, name, override) {\n    if (!obj)\n        return;\n\n    // check if method for prototype exists\n    const exists = obj?.prototype?.[name];\n    if (!exists) {\n        console.warn(`#PaperWM: attempt to override prototype for '${name}' failed: is null or undefined`);\n    }\n\n    registerOverrideProp(obj.prototype, name, override);\n}\n\nexport function makeFallback(obj, method, ...args) {\n    let fallback = getSavedPrototype(obj, method);\n    return fallback.bind(...args);\n}\n\nexport function overrideWithFallback(obj, method, body) {\n    registerOverridePrototype(\n        obj, method, function(...args) {\n            let fallback = makeFallback(obj, method, this, ...args);\n            body(fallback, this, ...args);\n        }\n    );\n}\n\nexport function getSavedProp(obj, name) {\n    let props = savedProps.get(obj);\n    if (!props)\n        return undefined;\n    let prop = props[name];\n    if (!prop)\n        return undefined;\n    return prop.saved;\n}\n\nexport function getSavedPrototype(obj, name) {\n    return getSavedProp(obj.prototype, name);\n}\n\nexport function disableOverride(obj, name) {\n    obj[name] = getSavedProp(obj, name);\n}\n\nexport function enableOverride(obj, name) {\n    let props = savedProps.get(obj);\n    let override = props[name].override;\n    if (override !== undefined) {\n        obj[name] = override;\n    }\n}\n\n/**\n * Sets up PaperWM overrides (needed for operations).  These overrides are registered and restored\n * on PaperWM disable.\n */\nexport function setupOverrides() {\n    registerOverridePrototype(WorkspaceAnimation.WorkspaceAnimationController, 'animateSwitch',\n        // WorkspaceAnimation.WorkspaceAnimationController.animateSwitch\n        // Disable the workspace switching animation in Gnome 40+\n        function (_from, _to, _direction, onComplete) {\n            // ensure swipeTrackers are disabled after this\n            const reset = () => {\n                // gnome windows switch animation time = 250, do that plus a little more\n                pillSwipeTimer = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 300, () => {\n                    swipeTrackers.forEach(t => {\n                        t.enabled = false;\n                    });\n                    pillSwipeTimer = null;\n                    return false; // on return false destroys timeout\n                });\n            };\n\n            if (Tiling.inPreview) {\n                onComplete();\n                reset();\n                return;\n            }\n\n            // if using PaperWM workspace switch animation, just do complete here\n            if (!Tiling.spaces.space_defaultAnimation) {\n                onComplete();\n                reset();\n                return;\n            }\n\n            // if switching to a paperwm space that is already shown on a monitor\n            // from / to are workspace indices\n            const toSpace = Tiling.spaces.spaceOfIndex(_to);\n\n            const spaces = Array.from(Tiling.spaces.monitors.values());\n            const toOnMonitor = spaces.some(space => space === toSpace);\n            if (toOnMonitor) {\n                onComplete();\n                reset();\n                return;\n            }\n\n            // standard gnome switch animation\n            const saved = getSavedPrototype(WorkspaceAnimation.WorkspaceAnimationController, 'animateSwitch');\n            saved.call(this, _from, _to, _direction, onComplete);\n            reset();\n        });\n\n    registerOverridePrototype(WorkspaceAnimation.WorkspaceAnimationController, '_prepareWorkspaceSwitch',\n        function (workspaceIndices) {\n            const saved = getSavedPrototype(WorkspaceAnimation.WorkspaceAnimationController, '_prepareWorkspaceSwitch');\n            // hide selection during workspace switch\n            Tiling.spaces.forEach(s => s.hideSelection());\n            saved.call(this, workspaceIndices);\n        });\n\n    registerOverridePrototype(WorkspaceAnimation.WorkspaceAnimationController, '_finishWorkspaceSwitch',\n        function (switchData) {\n            const saved = getSavedPrototype(WorkspaceAnimation.WorkspaceAnimationController,\n                '_finishWorkspaceSwitch');\n            // ensure selection is shown after workspaces swtching\n            Tiling.spaces.forEach(s => s.showSelection());\n            saved.call(this, switchData);\n        });\n\n    registerOverrideProp(Main.wm._workspaceTracker, '_checkWorkspaces', _checkWorkspaces);\n\n    if (WindowManager.TouchpadWorkspaceSwitchAction) // disable 4-finger swipe\n        registerOverridePrototype(WindowManager.TouchpadWorkspaceSwitchAction, '_checkActivated', () => false);\n\n    // disable swipe gesture trackers\n    swipeTrackers.forEach(t => {\n        registerOverrideProp(t, \"enabled\", false, false);\n    });\n\n    /**\n     * Used on overview layout.  UnalignedLayoutStrategy is not exported in Gnome 45, and hence\n     * we need to override this function and call PaperWM customised UnalignedLayoutStrategy found\n     * in overlayout.js.\n     */\n    registerOverridePrototype(Workspace.WorkspaceLayout, '_createBestLayout', function(area) {\n        const [rowSpacing, columnSpacing] =\n        this._adjustSpacingAndPadding(this._spacing, this._spacing, null);\n\n        // We look for the largest scale that allows us to fit the\n        // largest row/tallest column on the workspace.\n        this._layoutStrategy = new OverviewLayout.UnalignedLayoutStrategy({\n            monitor: Main.layoutManager.monitors[this._monitorIndex],\n            rowSpacing,\n            columnSpacing,\n        });\n\n        let lastLayout = null;\n        let lastNumColumns = -1;\n        let lastScale = 0;\n        let lastSpace = 0;\n\n        for (let numRows = 1; ; numRows++) {\n            const numColumns = Math.ceil(this._sortedWindows.length / numRows);\n\n            // If adding a new row does not change column count just stop\n            // (for instance: 9 windows, with 3 rows -> 3 columns, 4 rows ->\n            // 3 columns as well => just use 3 rows then)\n            if (numColumns === lastNumColumns)\n                break;\n\n            const layout = this._layoutStrategy.computeLayout(this._sortedWindows, {\n                numRows,\n            });\n\n            const [scale, space] = this._layoutStrategy.computeScaleAndSpace(layout, area);\n\n            if (lastLayout && !this._isBetterScaleAndSpace(lastScale, lastSpace, scale, space))\n                break;\n\n            lastLayout = layout;\n            lastNumColumns = numColumns;\n            lastScale = scale;\n            lastSpace = space;\n        }\n\n        return lastLayout;\n    });\n\n\n    registerOverridePrototype(Workspace.Workspace, '_isOverviewWindow', win => {\n        win = win.meta_window ?? win; // should be metawindow, but get if not\n        // upstream (gnome value result - whta it would have done)\n        const saved = getSavedPrototype(Workspace.Workspace, '_isOverviewWindow');\n        const upstreamValue = saved?.call(this, win) ?? !win.skip_taskbar;\n\n        if (Scratch.isScratchWindow(win)) {\n            if (gsettings.get_boolean('only-scratch-in-overview')) {\n                return upstreamValue;\n            }\n\n            if (gsettings.get_boolean('disable-scratch-in-overview')) {\n                return false;\n            }\n        }\n\n        // if here then not scratch\n        if (gsettings.get_boolean('only-scratch-in-overview')) {\n            return false;\n        }\n\n        return upstreamValue;\n    });\n\n    const checkScratch = (metaWindow, metaWorkspace) => {\n        if (Scratch.isScratchWindow(metaWindow)) {\n            // check workspace match\n            return metaWorkspace === metaWindow?.get_workspace();\n        }\n\n        return false;\n    };\n    registerOverridePrototype(Workspace.Workspace, '_isMyWindow', function(window) {\n        if (checkScratch(window, this.metaWorkspace)) {\n            return true;\n        }\n\n        const space = Tiling.spaces.spaceOf(this.metaWorkspace);\n        const onSpace = space.indexOf(window) >= 0;\n        const onMonitor = this._monitor === space.monitor;\n        return onSpace && onMonitor;\n    });\n    registerOverridePrototype(WorkspaceThumbnail.WorkspaceThumbnail, '_isMyWindow', function(actor) {\n        const window = actor.meta_window;\n        if (checkScratch(window, this.metaWorkspace)) {\n            return true;\n        }\n\n        const space = Tiling.spaces.spaceOf(this.metaWorkspace);\n        const onSpace = space.indexOf(window) >= 0;\n        const onMonitor = this.monitorIndex === space.monitor.index;\n        return onSpace && onMonitor;\n    });\n\n    /**\n     * Resolve issue where window that is set to minimise-on-close should be removed\n     * from tiling (stick) before closing.  See https://github.com/paperwm/PaperWM/issues/608.\n     */\n    registerOverridePrototype(WindowPreview.WindowPreview, '_deleteAll', function() {\n        const windows = this.window_container.layout_manager.get_windows();\n\n        // Delete all windows, starting from the bottom-most (most-modal) one\n        for (const window of windows.reverse()) {\n            window.stick();\n            window.delete(global.get_current_time());\n        }\n\n        this._closeRequested = true;\n    });\n\n    /**\n     * Always show workspace thumbnails in overview if more than one workspace.\n     * See original function at:\n     * https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-44/js/ui/workspaceThumbnail.js#L690\n     */\n    registerOverridePrototype(WorkspaceThumbnail.ThumbnailsBox, '_updateShouldShow',\n        function () {\n            const { nWorkspaces } = global.workspace_manager;\n            const shouldShow = nWorkspaces > 1;\n\n            if (this._shouldShow === shouldShow)\n                return;\n\n            this._shouldShow = shouldShow;\n            this.notify('should-show');\n        });\n\n    /**\n     * Provides ability to set AltTab window preview sizes (which is a little harder in 45+).\n     * https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/main/js/ui/altTab.js#L1002\n     */\n    registerOverridePrototype(AltTab.WindowIcon, '_init', function(window, mode) {\n        const saved = getSavedPrototype(AltTab.WindowIcon, '_init');\n        saved.call(this, window, mode);\n\n        const WINDOW_PREVIEW_SIZE = 128;\n        const AppIconMode = {\n            THUMBNAIL_ONLY: 1,\n            APP_ICON_ONLY: 2,\n            BOTH: 3,\n        };\n        const APP_ICON_SIZE = 96;\n        const APP_ICON_SIZE_SMALL = 48;\n\n        let mutterWindow = this.window.get_compositor_private();\n\n        this._icon.destroy_all_children();\n\n        this.monitor = Tiling.spaces.selectedSpace.monitor;\n        let _createWindowClone = (window, size) => {\n            let [width, height] = window.get_size();\n            let scale = Math.min(1.0, size / width, size / height);\n            return new Clutter.Clone({\n                source: window,\n                width: width * scale,\n                height: height * scale,\n                x_align: Clutter.ActorAlign.CENTER,\n                y_align: Clutter.ActorAlign.CENTER,\n                // usual hack for the usual bug in ClutterBinLayout...\n                x_expand: true,\n                y_expand: true,\n            });\n        };\n\n        let size;\n        let scaleFactor = St.ThemeContext.get_for_stage(global.stage).scale_factor;\n        const scale = Settings.prefs.window_switcher_preview_scale;\n        // scale size based on PaperWM's minimap-scale\n        if (scale > 0) {\n            size = Math.round(this.monitor.height * scale);\n        } else {\n            size = WINDOW_PREVIEW_SIZE;\n        }\n        switch (mode) {\n        case AppIconMode.THUMBNAIL_ONLY:\n            this._icon.add_child(_createWindowClone(mutterWindow, size * scaleFactor));\n            break;\n\n        case AppIconMode.BOTH:\n            this._icon.add_child(_createWindowClone(mutterWindow, size * scaleFactor));\n\n            if (this.app) {\n                this._icon.add_child(\n                    this._createAppIcon(this.app, APP_ICON_SIZE_SMALL));\n            }\n            break;\n\n        case AppIconMode.APP_ICON_ONLY:\n            size = APP_ICON_SIZE;\n            this._icon.add_child(this._createAppIcon(this.app, size));\n        }\n\n        this._icon.set_size(size * scaleFactor, size * scaleFactor);\n    });\n\n    registerOverridePrototype(Screenshot.ScreenshotUI, 'open', async function(mode) {\n        const saved = getSavedPrototype(Screenshot.ScreenshotUI, 'open');\n\n        if (!Main.overview.visible) {\n            Tiling?.spaces.forEach(s => {\n                s.visible.forEach(w => {\n                    w.get_compositor_private()?.remove_clip();\n                });\n            });\n        }\n\n        await saved.call(this, mode);\n    });\n\n    registerOverridePrototype(Screenshot.ScreenshotUI, 'close', function(instantly) {\n        const saved = getSavedPrototype(Screenshot.ScreenshotUI, 'close');\n\n        if (!Main.overview.visible) {\n            Tiling?.spaces.forEach(s => {\n                s.visible.forEach(w => {\n                    s.applyClipToClone(w);\n                });\n            });\n        }\n\n        saved.call(this, instantly);\n    });\n}\n\n/**\n * Enables any registered overrides.\n */\nexport function enableOverrides() {\n    for (let [obj, props] of savedProps) {\n        for (let name in props) {\n            enableOverride(obj, name);\n        }\n    }\n}\n\nexport function disableOverrides() {\n    for (let [obj, props] of savedProps) {\n        for (let name in props) {\n            obj[name] = props[name].saved;\n        }\n    }\n}\n\n/**\n * Saves the original setting value (boolean) to restore on disable.\n * We save a backup of the user's setting to PaperWM settings (schema)\n * for safety (in case gnome terminates etc.).  This ensures original\n * user settings will be restored on next PaperWM disable.\n * @param key\n */\nlet runtimeDisables = [];\nexport function saveRuntimeDisable(schemaSettings, key, disableValue) {\n    try {\n        let origValue = schemaSettings.get_boolean(key);\n        schemaSettings.set_boolean(key, disableValue);\n\n        // save a backup copy to PaperWM settings (for restore)\n        let pkey = `restore-${key}`;\n\n        /**\n         * Now if paperwm settings has restore values, it means\n         * that they weren't previously restore properly (since on\n         * successful restore we clear the values).\n         */\n        if (gsettings.get_string(pkey) === '') {\n            gsettings.set_string(pkey, origValue.toString());\n        }\n\n        // we want to restore from PaperWM back settings (safer)\n        let restore = () => {\n            let value = gsettings.get_string(pkey);\n            // if value is empty, do nothing\n            if (value === '') {\n                return;\n            }\n\n            let bvalue = value === 'true';\n            schemaSettings.set_boolean(key, bvalue);\n\n            // after restore, empty papermw saved value\n            gsettings.set_string(pkey, '');\n        };\n\n        runtimeDisables.push(restore);\n    } catch (e) {\n        console.error(e);\n    }\n}\n\n/**\n * PaperWM disables certain behaviours during runtime.\n * The user original settings are saved to PaperWM's settings (schema) for restoring\n * purposes (we save to PaperWM's setting just in gnome terminates before PaperWM can\n * restore the original user settings).  These settings are then restored on disable().\n */\nexport function setupRuntimeDisables() {\n    saveRuntimeDisable(mutterSettings, 'attach-modal-dialogs', false);\n    saveRuntimeDisable(mutterSettings, 'workspaces-only-on-primary', false);\n    saveRuntimeDisable(mutterSettings, 'edge-tiling', false);\n}\n\n/**\n * Restores the runtime settings that were disabled when\n * PaperWM was enabled.\n */\nexport function restoreRuntimeDisables() {\n    if (Main.sessionMode.isLocked) {\n        return;\n    }\n    runtimeDisables.forEach(restore => {\n        try {\n            restore();\n        } catch (e) {\n            console.error(e);\n        }\n    });\n}\n\n/**\n * Swipetrackers that should be disabled.  Locations of swipetrackers may\n * move from gnome version to gnome version.  Next to the swipe tracker locations\n * below are the gnome versions when they were first (or last) seen.\n */\nexport let swipeTrackers; // exported\nexport function setupSwipeTrackers() {\n    swipeTrackers = [\n        Main?.overview?._swipeTracker, // gnome 40+\n        Main?.overview?._overview?._controls?._workspacesDisplay?._swipeTracker, // gnome 40+\n        Main?.wm?._workspaceAnimation?._swipeTracker, // gnome 40+\n        Main?.wm?._swipeTracker, // gnome 38 (and below)\n    ].filter(t => typeof t !== 'undefined');\n}\n\nlet actions;\nexport function setupActions() {\n    /*\n     * Some actions work rather poorly.\n     * In particular the 3-finger hold + tap can randomly activate a minimized\n     * window when tapping after a 3-finger swipe\n     */\n    // eslint-disable-next-line array-callback-return\n    actions = global.stage.get_actions().filter(a => {\n        switch (a.constructor) {\n        case WindowManager.AppSwitchAction:\n            return true;\n        }\n    });\n    actions.forEach(a => global.stage.remove_action(a));\n}\n\nexport function _checkWorkspaces() {\n    let workspaceManager = global.workspace_manager;\n    let i;\n    let emptyWorkspaces = [];\n    let minimum = Main.layoutManager.monitors.length + 1;\n\n    if (!Meta.prefs_get_dynamic_workspaces()) {\n        // if less spaces than minimum, create!\n        let created = 0;\n        while (workspaceManager.nWorkspaces < minimum) {\n            workspaceManager.append_new_workspace(false, global.get_current_time());\n            created++;\n        }\n\n        if (created > 0) {\n            Main.notify(\n                `PaperWM (created ${created} workspaces)`,\n                `PaperWM requires a minimum of ${minimum} workspaces for you monitor configuration.`\n            );\n        }\n\n        this._checkWorkspacesId = 0;\n        return false;\n    }\n\n    // Update workspaces only if Dynamic Workspace Management has not been paused by some other function\n    if (this._pauseWorkspaceCheck || Tiling.inPreview)\n        return true;\n\n    for (i = 0; i < this._workspaces.length; i++) {\n        let lastRemoved = this._workspaces[i]._lastRemovedWindow;\n        if ((lastRemoved &&\n             (lastRemoved.get_window_type() === Meta.WindowType.SPLASHSCREEN ||\n              lastRemoved.get_window_type() === Meta.WindowType.DIALOG ||\n              lastRemoved.get_window_type() === Meta.WindowType.MODAL_DIALOG)) ||\n            this._workspaces[i]._keepAliveId)\n            emptyWorkspaces[i] = false;\n        else\n            emptyWorkspaces[i] = true;\n    }\n\n    let sequences = Shell.WindowTracker.get_default().get_startup_sequences();\n    for (i = 0; i < sequences.length; i++) {\n        let index = sequences[i].get_workspace();\n        if (index >= 0 && index <= workspaceManager.n_workspaces)\n            emptyWorkspaces[index] = false;\n    }\n\n    let windows = global.get_window_actors();\n    for (i = 0; i < windows.length; i++) {\n        let actor = windows[i];\n        let win = actor.get_meta_window();\n\n        if (win.is_on_all_workspaces())\n            continue;\n\n        let workspaceIndex = win.get_workspace().index();\n        emptyWorkspaces[workspaceIndex] = false;\n    }\n\n    /**\n     * Set minimum workspaces to be max of num_monitors+1.\n     * This ensures that we have at least one workspace at the end.\n     */\n    // Make sure we have a minimum number of spaces\n    for (i = 0; i < minimum; i++) {\n        if (i >= emptyWorkspaces.length) {\n            workspaceManager.append_new_workspace(false, global.get_current_time());\n            emptyWorkspaces.push(true);\n        }\n    }\n\n    // If we don't have an empty workspace at the end, add one\n    if (!emptyWorkspaces[emptyWorkspaces.length - 1]) {\n        workspaceManager.append_new_workspace(false, global.get_current_time());\n        emptyWorkspaces.push(true);\n    }\n\n    let lastIndex = emptyWorkspaces.length - 1;\n    let lastEmptyIndex = emptyWorkspaces.lastIndexOf(false) + 1;\n    let activeWorkspaceIndex = workspaceManager.get_active_workspace_index();\n\n    // Keep the active workspace\n    emptyWorkspaces[activeWorkspaceIndex] = false;\n\n    // Keep a minimum number of spaces\n    for (i = 0; i < Math.max(Main.layoutManager.monitors.length, minimum); i++) {\n        emptyWorkspaces[i] = false;\n    }\n\n    // Keep visible spaces\n    if (Tiling?.spaces?.monitors) {\n        for (let [, space] of Tiling.spaces.monitors) {\n            emptyWorkspaces[space.workspace.index()] = false;\n        }\n    }\n\n    // Delete empty workspaces except for the last one; do it from the end\n    // to avoid index changes\n    for (i = lastIndex; i >= 0; i--) {\n        // eslint-disable-next-line eqeqeq\n        if (emptyWorkspaces[i] && i != lastEmptyIndex) {\n            workspaceManager.remove_workspace(this._workspaces[i]\n                , global.get_current_time());\n        }\n    }\n\n    this._checkWorkspacesId = 0;\n    return false;\n}\n"
        },
        {
          "name": "prefs.js",
          "type": "blob",
          "size": 31.4072265625,
          "content": "import Gdk from 'gi://Gdk';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport Gtk from 'gi://Gtk';\n\nimport { ExtensionPreferences } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js';\n\nimport * as Settings from './settings.js';\nimport { WorkspaceSettings } from './workspace.js';\n// eslint-disable-next-line no-unused-vars\nimport * as KeybindingsPane from './prefsKeybinding.js';\n// eslint-disable-next-line no-unused-vars\nimport * as WinpropsPane from './winpropsPane.js';\n\nconst _ = s => s;\n\nexport default class PaperWMPrefs extends ExtensionPreferences {\n    fillPreferencesWindow(window) {\n        const provider = new Gtk.CssProvider();\n        provider.load_from_path(`${this.path}/resources/prefs.css`);\n        Gtk.StyleContext.add_provider_for_display(\n            Gdk.Display.get_default(),\n            provider,\n            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION\n        );\n\n        let selectedWorkspace = null;\n        try {\n            const tempFile = Gio.File.new_for_path(GLib.get_tmp_dir()).get_child('paperwm.workspace');\n            let [, contents] = tempFile.load_contents(null);\n            const decoder = new TextDecoder('utf-8');\n            const contentsString = decoder.decode(contents);\n            let workspaceN = parseInt(contentsString);\n            if (!isNaN(workspaceN)) {\n                selectedWorkspace = workspaceN;\n            }\n            tempFile.delete(null);\n        } catch (e) { }\n\n        const selectedTab = selectedWorkspace !== null ? 1 : 0;\n        window.set_size_request(626, 700);\n        new SettingsWidget(\n            this,\n            window,\n            selectedTab,\n            selectedWorkspace || 0);\n    }\n}\n\nclass SettingsWidget {\n    /**\n       selectedWorkspace: index of initially selected workspace in workspace settings tab\n       selectedTab: index of initially shown tab\n     */\n    constructor(extension, prefsWindow, selectedPage = 0, selectedWorkspace = 0) {\n        this.extension = extension;\n        this._settings = extension.getSettings();\n        this.workspaceSettings = new WorkspaceSettings(extension);\n        const wmSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.wm.preferences' });\n        this.builder = Gtk.Builder.new_from_file(`${extension.path}/Settings.ui`);\n        this.window = prefsWindow;\n\n        const pages = [\n            this.builder.get_object('general_page'),\n            this.builder.get_object('workspaces_page'),\n            this.builder.get_object('keybindings_page'),\n            this.builder.get_object('winprops_page'),\n            this.builder.get_object('advanced_page'),\n            this.builder.get_object('about_page'),\n        ];\n\n        pages.forEach(page => prefsWindow.add(page));\n        prefsWindow.set_visible_page(pages[selectedPage]);\n\n        this._backgroundFilter = new Gtk.FileFilter();\n        this._backgroundFilter.add_pixbuf_formats();\n\n        // value-changed methods\n        const booleanStateChanged = (key, inverted = false) => {\n            const builder = this.builder.get_object(key);\n            builder.active = inverted\n                ? !this._settings.get_boolean(key) : this._settings.get_boolean(key);\n            builder.connect('state-set', (obj, state) => {\n                this._settings.set_boolean(key, inverted ? !state : state);\n            });\n        };\n\n        const intValueChanged = (builderKey, settingKey) => {\n            const builder = this.builder.get_object(builderKey);\n            const value = this._settings.get_int(settingKey);\n            builder.set_value(value);\n            builder.connect('value-changed', () => {\n                this._settings.set_int(settingKey, builder.get_value());\n            });\n        };\n\n        const doubleValueChanged = (builderKey, settingKey) => {\n            const builder = this.builder.get_object(builderKey);\n            const value = this._settings.get_double(settingKey);\n            builder.set_value(value);\n            builder.connect('value-changed', () => {\n                this._settings.set_double(settingKey, builder.get_value());\n            });\n        };\n\n        const percentValueChanged = (builderKey, settingKey) => {\n            const builder = this.builder.get_object(builderKey);\n            const value = this._settings.get_double(settingKey);\n            builder.set_value(value * 100.0);\n            builder.connect('value-changed', () => {\n                this._settings.set_double(settingKey, builder.get_value() / 100.0);\n            });\n        };\n\n        const enumOptionsChanged = (settingKey, optionNumberEnum, defaultOption, defaultNumber) => {\n            const builder = this.builder.get_object(settingKey);\n            const setting = this._settings.get_int(settingKey);\n            const numberOptionEnum = Object.fromEntries(\n                Object.entries(optionNumberEnum).map(a => a.reverse())\n            );\n\n            builder.set_active_id(numberOptionEnum[setting] ?? defaultOption);\n            builder.connect('changed', obj => {\n                const value = optionNumberEnum[obj.get_active_id()] ?? defaultNumber;\n                this._settings.set_int(settingKey, value);\n            });\n        };\n\n        // const gestureFingersChanged = key => {\n        //     const builder = this.builder.get_object(key);\n        //     const setting = this._settings.get_int(key);\n        //     const valueToFingers = {\n        //         0: 'fingers-disabled',\n        //         3: 'three-fingers',\n        //         4: 'four-fingers',\n        //     };\n        //     const fingersToValue = Object.fromEntries(\n        //         Object.entries(valueToFingers).map(a => a.reverse())\n        //     );\n\n        //     builder.set_active_id(valueToFingers[setting] ?? 'fingers-disable');\n        //     builder.connect('changed', obj => {\n        //         const value = fingersToValue[obj.get_active_id()] ?? 0;\n        //         this._settings.set_int(key, value);\n        //     });\n        // };\n\n        // General\n        intValueChanged('selection_size_spin', 'selection-border-size');\n        intValueChanged('selection_radius_top_spin', 'selection-border-radius-top');\n        intValueChanged('selection_radius_bottom_spin', 'selection-border-radius-bottom');\n        intValueChanged('window_gap_spin', 'window-gap');\n        intValueChanged('hmargin_spinner', 'horizontal-margin');\n        intValueChanged('top_margin_spinner', 'vertical-margin');\n        intValueChanged('bottom_margin_spinner', 'vertical-margin-bottom');\n\n        // processing function for cycle values\n        const cycleProcessor = (elementName, settingName, resetElementName) => {\n            const element = this.builder.get_object(elementName);\n            const steps = this._settings.get_value(settingName).deep_unpack();\n\n            // need to check if current values are ratio or pixel ==> assume if all <=1 is ratio\n            const isRatio = steps.every(v => v <= 1);\n            let value;\n            if (isRatio) {\n                value = steps.map(v => `${(v * 100.0).toString()}%`).toString();\n            } else {\n                value = steps.map(v => `${v.toString()}px`).toString();\n            }\n            element.set_text(value.replaceAll(',', '; '));\n\n            element.connect('changed', () => {\n                // process values\n                // check if values are percent or pixel\n                const value = element.get_text();\n                const isPercent = value.split(';').map(v => v.trim()).every(v => /^.*%$/.test(v));\n                const isPixels = value.split(';').map(v => v.trim()).every(v => /^.*px$/.test(v));\n                if (isPercent && isPixels) {\n                    console.error(\"cycle width/height values cannot mix percentage and pixel values\");\n                    element.add_css_class('error');\n                    return;\n                }\n                if (!isPercent && !isPixels) {\n                    console.error(\"no cycle width/height value units present\");\n                    element.add_css_class('error');\n                    return;\n                }\n\n                // now process element value into internal array\n                const varr = value\n                    .split(';')\n                    .map(v => v.trim())\n                    .map(v => v.replaceAll(/[^\\d.]/g, '')) // strip everything but digits and period\n                    .filter(v => v.length > 0) // needed to remove invalid inputs\n                    .map(Number) // only accept valid numbers\n                    .map(v => isPercent ? v / 100.0 : v)\n                    .sort((a, b) => a - b); // sort values to ensure monotonicity\n\n                // check to make sure if percent than input cannot be > 100%\n                if (isPercent && varr.some(v => v > 1)) {\n                    console.error(\"cycle width/height percent inputs cannot be greater than 100%\");\n                    element.add_css_class('error');\n                    return;\n                }\n                element.remove_css_class('error');\n\n                this._settings.set_value(settingName, new GLib.Variant('ad', varr));\n            });\n            this.builder.get_object(resetElementName).connect('clicked', () => {\n                // text value here should match the gshema value for cycle-width-steps\n                element.set_text('38.195%; 50%; 61.804%');\n            });\n        };\n        cycleProcessor('cycle_widths_entry', 'cycle-width-steps', 'cycle_widths_reset_button');\n        cycleProcessor('cycle_heights_entry', 'cycle-height-steps', 'cycle_heights_reset_button');\n\n        const vSens = this.builder.get_object('vertical-sensitivity');\n        const hSens = this.builder.get_object('horizontal-sensitivity');\n        const [sx, sy] = this._settings.get_value('swipe-sensitivity').deep_unpack();\n        hSens.set_value(sx);\n        vSens.set_value(sy);\n        const sensChanged = () => {\n            this._settings.set_value('swipe-sensitivity', new GLib.Variant('ad', [hSens.get_value(), vSens.get_value()]));\n        };\n        vSens.connect('value-changed', sensChanged);\n        hSens.connect('value-changed', sensChanged);\n\n        const vFric = this.builder.get_object('vertical-friction');\n        const hFric = this.builder.get_object('horizontal-friction');\n        const [fx, fy] = this._settings.get_value('swipe-friction').deep_unpack();\n        hFric.set_value(fx);\n        vFric.set_value(fy);\n        const fricChanged = () => {\n            this._settings.set_value('swipe-friction', new GLib.Variant('ad', [hFric.get_value(), vFric.get_value()]));\n        };\n        vFric.connect('value-changed', fricChanged);\n        hFric.connect('value-changed', fricChanged);\n\n        doubleValueChanged('animation_time_spin', 'animation-time');\n        intValueChanged('drift_speed_spin', 'drift-speed');\n        intValueChanged('drag_drift_speed_spin', 'drag-drift-speed');\n        percentValueChanged('minimap_scale_spin', 'minimap-scale');\n        percentValueChanged('window_switcher_preview_scale_spin', 'window-switcher-preview-scale');\n        percentValueChanged('overview_max_window_scale_spin', 'overview-max-window-scale');\n        intValueChanged('minimap_shade_opacity_spin', 'minimap-shade-opacity');\n\n        // tiling edge preview settings\n        booleanStateChanged('edge-preview-enable');\n        percentValueChanged('edge_scale_spin', 'edge-preview-scale');\n        booleanStateChanged('edge-preview-click-enable');\n        booleanStateChanged('edge-preview-timeout-enable');\n        intValueChanged('edge_preview_timeout_scale', 'edge-preview-timeout');\n        booleanStateChanged('edge-preview-timeout-continual');\n\n        const openWindowPosition = this.builder.get_object('open-window-position');\n        const owpos = this._settings.get_int('open-window-position');\n        switch (owpos) {\n        case Settings.OpenWindowPositions.LEFT:\n            openWindowPosition.set_active_id('left');\n            break;\n        case Settings.OpenWindowPositions.START:\n            openWindowPosition.set_active_id('start');\n            break;\n        case Settings.OpenWindowPositions.END:\n            openWindowPosition.set_active_id('end');\n            break;\n        case Settings.OpenWindowPositions.STACK:\n            openWindowPosition.set_active_id('stack');\n            break;\n        default:\n            openWindowPosition.set_active_id('right');\n        }\n\n        openWindowPosition.connect('changed', obj => {\n            switch (obj.get_active_id()) {\n            case 'left':\n                this._settings.set_int('open-window-position', Settings.OpenWindowPositions.LEFT);\n                break;\n            case 'start':\n                this._settings.set_int('open-window-position', Settings.OpenWindowPositions.START);\n                break;\n            case 'end':\n                this._settings.set_int('open-window-position', Settings.OpenWindowPositions.END);\n                break;\n            case 'down':\n                this._settings.set_int('open-window-position', Settings.OpenWindowPositions.DOWN);\n                break;\n            case 'up':\n                this._settings.set_int('open-window-position', Settings.OpenWindowPositions.UP);\n                break;\n            default:\n                this._settings.set_int('open-window-position', Settings.OpenWindowPositions.RIGHT);\n            }\n        });\n\n        // plug up options\n        booleanStateChanged('open-window-position-option-right');\n        booleanStateChanged('open-window-position-option-left');\n        booleanStateChanged('open-window-position-option-start');\n        booleanStateChanged('open-window-position-option-end');\n        booleanStateChanged('open-window-position-option-down');\n        booleanStateChanged('open-window-position-option-up');\n\n        const scratchOverview = this.builder.get_object('scratch-in-overview');\n        if (this._settings.get_boolean('only-scratch-in-overview'))\n            scratchOverview.set_active_id('only');\n        else if (this._settings.get_boolean('disable-scratch-in-overview'))\n            scratchOverview.set_active_id('never');\n        else\n            scratchOverview.set_active_id('always');\n\n        scratchOverview.connect('changed', obj => {\n            if (obj.get_active_id() === 'only') {\n                this._settings.set_boolean('only-scratch-in-overview', true);\n                this._settings.set_boolean('disable-scratch-in-overview', false);\n            } else if (obj.get_active_id() === 'never') {\n                this._settings.set_boolean('only-scratch-in-overview', false);\n                this._settings.set_boolean('disable-scratch-in-overview', true);\n            } else {\n                this._settings.set_boolean('only-scratch-in-overview', false);\n                this._settings.set_boolean('disable-scratch-in-overview', false);\n            }\n        });\n\n        booleanStateChanged('show-window-position-bar');\n\n        const enableGnomePill = this.builder.get_object('use-gnome-pill');\n        enableGnomePill.active = !this._settings.get_boolean('show-workspace-indicator');\n        enableGnomePill.connect('state-set', (obj, state) => {\n            this._settings.set_boolean('show-workspace-indicator', !state);\n        });\n\n        // Workspaces\n        booleanStateChanged('use-default-background');\n\n        const backgroundPanelButton = this.builder.get_object('gnome-background-panel');\n        backgroundPanelButton.connect('clicked', () => {\n            GLib.spawn_async(null, ['gnome-control-center', 'background'],\n                GLib.get_environ(),\n                GLib.SpawnFlags.SEARCH_PATH | GLib.SpawnFlags.DO_NOT_REAP_CHILD,\n                null);\n        });\n\n        const workspaceCombo = this.builder.get_object('workspace_combo_text');\n        const workspaceStack = this.builder.get_object('workspace_stack');\n        const nWorkspaces = this.workspaceSettings.getWorkspaceList().get_strv('list').length;\n\n        // Note: For some reason we can't set the visible child of the workspace\n        //       stack at construction time.. (!)\n        //       Ensure the initially selected workspace is added to the stack\n        //       first as a workaround.\n        const wsIndices = this.range(nWorkspaces);\n        const wsSettingsByIndex = wsIndices.map(i => this.workspaceSettings.getWorkspaceSettings(i)[1]);\n        const wsIndicesSelectedFirst =\n            this.swapArrayElements(wsIndices.slice(), 0, selectedWorkspace);\n\n        for (let i of wsIndicesSelectedFirst) {\n            const view = this.createWorkspacePage(wsSettingsByIndex[i], i);\n            workspaceStack.add_named(view, i.toString());\n        }\n\n        const workspaces = [];\n        for (let i of wsIndices) {\n            // Combo box entries in normal workspace index order\n            const name = this.getWorkspaceName(wsSettingsByIndex[i], i);\n            workspaceCombo.append_text(name);\n            workspaces.push(name);\n        }\n\n        this.builder.get_object('winpropsPane').setWorkspaces(workspaces);\n\n        this.builder.get_object('workspace_reset_button').connect('clicked', () => {\n            this._updatingName = true;\n            wmSettings.set_strv('workspace-names', []);\n\n            const settings = i => wsSettingsByIndex[i];\n            const name = (s, i) => this.getWorkspaceName(s, i);\n            workspaceCombo.remove_all();\n            for (let i of wsIndices) {\n                settings(i).reset('name');\n                workspaceCombo.append_text(name(settings(i), i));\n            }\n\n            // update pages\n            for (let j of wsIndicesSelectedFirst) {\n                const view = workspaceStack.get_child_by_name(j.toString());\n                const nameEntry = view.get_first_child().get_last_child();\n                nameEntry.set_text(name(settings(j), j));\n            }\n            this._updatingName = false;\n\n            workspaceCombo.set_active(0);\n        });\n\n        workspaceCombo.connect('changed', () => {\n            if (this._updatingName)\n                return;\n\n            const active = workspaceCombo.get_active();\n            workspaceStack.set_visible_child_name(active.toString());\n        });\n\n        workspaceCombo.set_active(selectedWorkspace);\n\n        // Keybindings\n        const keybindingsPane = this.builder.get_object('keybindings_pane');\n        keybindingsPane.init(extension);\n\n        // Winprops\n        const winprops = this._settings.get_value('winprops').deep_unpack()\n            .map(p => JSON.parse(p));\n        // sort a little nicer\n        const valueFn = wp => {\n            if (wp.wm_class) {\n                return wp.wm_class;\n            }\n            if (wp.title) {\n                return wp.title;\n            }\n            return '';\n        };\n        winprops.sort((a, b) => {\n            const aa = valueFn(a).replaceAll(/[/]/g, '');\n            const bb = valueFn(b).replaceAll(/[/]/g, '');\n            return aa.localeCompare(bb);\n        });\n        const winpropsPane = this.builder.get_object('winpropsPane');\n        winpropsPane.addWinprops(winprops);\n        winpropsPane.connect('changed', () => {\n            // update gsettings with changes\n            const rows = winpropsPane.rows\n                .filter(r => r.checkHasWmClassOrTitle())\n                .map(r => JSON.stringify(r.winprop));\n\n            this._settings.set_value('winprops', new GLib.Variant('as', rows));\n        });\n\n        // Advanced\n        booleanStateChanged('gesture-enabled');\n\n        const fingerOptions = {\n            'fingers-disabled': 0,\n            'three-fingers': 3,\n            'four-fingers': 4,\n        };\n        const fingerOptionDefault = 'fingers-disabled';\n        const fingerNumberDefault = 0;\n        enumOptionsChanged('gesture-horizontal-fingers', fingerOptions, fingerOptionDefault, fingerNumberDefault);\n        enumOptionsChanged('gesture-workspace-fingers', fingerOptions, fingerOptionDefault, fingerNumberDefault);\n        enumOptionsChanged(\n            'default-focus-mode',\n            {\n                'default': 0,\n                'center': 1,\n                'edge': 2,\n            },\n            'default',\n            0);\n\n        enumOptionsChanged(\n            'overview-ensure-viewport-animation',\n            {\n                'none': 0,\n                'translate': 1,\n                'fade': 2,\n            },\n            'translate',\n            1);\n\n        intValueChanged('overview_min_windows_per_row_spin', 'overview-min-windows-per-row');\n        booleanStateChanged('show-focus-mode-icon');\n        booleanStateChanged('show-open-position-icon');\n        booleanStateChanged('disable-topbar-styling', true);\n        // disabled since opposite of gnome-pill\n        // booleanSetState('show-workspace-indicator');\n        percentValueChanged('maximize-width-percent', 'maximize-width-percent');\n        booleanStateChanged('maximize-within-tiling');\n        booleanStateChanged('topbar-mouse-scroll-enable');\n\n        // About\n        // build version information\n        const text = `\n        Distribution: ${GLib.get_os_info('NAME') ?? 'UNKNOWN'} ${GLib.get_os_info('VERSION') ?? \"\"}\n        GNOME Shell: ${this._getGnomeVersion()}\\\n        ${this._getLastDisplayServer()}\n        PaperWM version: ${this.extension.metadata['version-name'] ?? 'UNKNOWN'}\\\n        ${this._getExtensions()}\n        `.split('\\n')\n        .map(v => v.trim())\n        .join('\\n').trim();\n\n        const buffer = new Gtk.TextBuffer();\n        buffer.set_text(text, -1);\n\n        const clipboard = Gdk.Display.get_default()?.get_clipboard();\n        if (clipboard) {\n            const copyToClipboard = this.builder.get_object('about_version_copy_button');\n            copyToClipboard.connect('clicked', () => {\n                clipboard.set_content(Gdk.ContentProvider.new_for_value(text));\n            });\n        }\n\n        // set text to buffer\n        const aboutVersionView = this.builder.get_object('about_version_textView');\n        aboutVersionView.set_wrap_mode(Gtk.WrapMode.WORD_CHAR);\n        aboutVersionView.set_buffer(buffer);\n    }\n\n    /**\n     * Returns the current detected Gnome shell version.\n     * @returns String\n     */\n    _getGnomeVersion() {\n        try {\n            const reply = Gio.DBus.session.call_sync(\n                'org.gnome.Shell',\n                '/org/gnome/Shell',\n                'org.freedesktop.DBus.Properties',\n                'Get',\n                new GLib.Variant('(ss)', [\n                    'org.gnome.Shell',\n                    'ShellVersion',\n                ]),\n                null,\n                Gio.DBusCallFlags.NONE,\n                -1,\n                null);\n\n            const [version] = reply.deep_unpack();\n            return version.deep_unpack();\n        } catch (error) {\n            console.error(error);\n            return 'UNKNOWN';\n        }\n    }\n\n    /**\n     * Returns the last used display server (Wayland / X11)\n     * @returns String\n     */\n    _getLastDisplayServer() {\n        const ds = this._settings.get_string('last-used-display-server');\n        if (ds.length > 0) {\n            return `\\nDisplay server: ${ds}`;\n        }\n        else {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns a formatted list of currently active extensions.\n     * @returns String\n     */\n    _getExtensions() {\n        try {\n            const reply = Gio.DBus.session.call_sync(\n                'org.gnome.Shell',\n                '/org/gnome/Shell',\n                'org.gnome.Shell.Extensions',\n                'ListExtensions',\n                null,\n                new GLib.VariantType('(a{sa{sv}})'),\n                Gio.DBusCallFlags.NONE,\n                -1,\n                null\n            );\n\n            const [ext] = reply.deep_unpack();\n            const extensions = Object.keys(ext).map(\n                k => {\n                    return {\n                        uuid: k,\n                        active: ext[k].state.deep_unpack() === 1, // state 1 = active\n                    };\n                }\n            )\n                .filter(v => v.active === true)\n                .map(v => `- ${v.uuid}`)\n                .join(\"\\n\");\n\n            if (extensions.length <= 0) {\n                return '';\n            }\n            return `\\nEnabled extensions:\\n${extensions}`;\n        } catch (error) {\n            console.error(error);\n            return '\\nEnabled extensions: UNKNOWN';\n        }\n    }\n\n    range(n) {\n        const r = [];\n        for (let i = 0; i < n; i++)\n            r.push(i);\n        return r;\n    }\n\n    swapArrayElements(array, i, j) {\n        const iVal = array[i];\n        array[i] = array[j];\n        array[j] = iVal;\n        return array;\n    }\n\n    createWorkspacePage(settings, index) {\n        const list = new Gtk.Box({\n            orientation: Gtk.Orientation.VERTICAL,\n            focusable: false,\n        });\n        const nameEntry = new Gtk.Entry();\n        const colorButton = new Gtk.ColorButton();\n\n        // Background\n\n        const backgroundBox = new Gtk.Box({ spacing: 16 });\n        const background = this.createFileChooserButton(\n            settings,\n            'background',\n            'image-x-generic',\n            'document-open-symbolic',\n            {\n                action: Gtk.FileChooserAction.OPEN,\n                title: 'Select workspace background',\n                filter: this._backgroundFilter,\n                select_multiple: false,\n                modal: true,\n                transient_for: this.window.get_root(),\n            }\n        );\n        const clearBackground = new Gtk.Button({\n            icon_name: 'edit-clear-symbolic',\n            tooltip_text: 'Clear workspace background',\n            sensitive: settings.get_string('background') !== '',\n        });\n        backgroundBox.append(background);\n        backgroundBox.append(clearBackground);\n\n        const hideTopBarSwitch = new Gtk.Switch({ active: !settings.get_boolean('show-top-bar') });\n        const hidePositionBarSwitch = new Gtk.Switch({ active: !settings.get_boolean('show-position-bar') });\n\n        const directoryBox = new Gtk.Box({ spacing: 16 });\n        const directoryChooser = this.createFileChooserButton(\n            settings,\n            'directory',\n            'folder',\n            'folder-open-symbolic',\n            {\n                action: Gtk.FileChooserAction.SELECT_FOLDER,\n                title: 'Select workspace directory',\n                select_multiple: false,\n                modal: true,\n                transient_for: this.window.get_root(),\n            }\n        );\n        const clearDirectory = new Gtk.Button({\n            icon_name: 'edit-clear-symbolic',\n            tooltip_text: 'Clear workspace directory',\n            sensitive: settings.get_string('directory') !== '',\n        });\n        directoryBox.append(directoryChooser);\n        directoryBox.append(clearDirectory);\n\n        list.append(this.createRow('Name', nameEntry));\n        list.append(this.createRow('Color', colorButton));\n        list.append(this.createRow('Background', backgroundBox));\n        list.append(this.createRow('Hide Gnome Top Bar', hideTopBarSwitch));\n        list.append(this.createRow('Hide Window Position Bar', hidePositionBarSwitch));\n        list.append(this.createRow('Directory', directoryBox));\n\n        const rgba = new Gdk.RGBA();\n        let color = settings.get_string('color');\n        const palette = this._settings.get_strv('workspace-colors');\n        if (color === '')\n            color = palette[index % palette.length];\n\n        rgba.parse(color);\n        colorButton.set_rgba(rgba);\n\n        nameEntry.set_text(this.getWorkspaceName(settings, index));\n\n        const workspace_combo = this.builder.get_object('workspace_combo_text');\n\n        nameEntry.connect('changed', () => {\n            if (this._updatingName) {\n                return;\n            }\n            let active = workspace_combo.get_active();\n            let name = nameEntry.get_text();\n\n            this._updatingName = true;\n            workspace_combo.remove(active);\n            workspace_combo.insert_text(active, name);\n\n            workspace_combo.set_active(active);\n            this._updatingName = false;\n\n            settings.set_string('name', name);\n        });\n\n        colorButton.connect('color-set', () => {\n            let color = colorButton.get_rgba().to_string();\n            settings.set_string('color', color);\n            settings.set_string('background', '');\n            background.unselect_all();\n        });\n\n        clearBackground.connect('clicked', () => {\n            settings.reset('background');\n        });\n\n        settings.connect('changed::background', () => {\n            // eslint-disable-next-line eqeqeq\n            clearBackground.sensitive = settings.get_string('background') != '';\n        });\n\n        hideTopBarSwitch.connect('state-set', (_switch, state) => {\n            settings.set_boolean('show-top-bar', !state);\n        });\n        settings.connect('changed::show-top-bar', () => {\n            hideTopBarSwitch.set_active(!settings.get_boolean('show-top-bar'));\n        });\n\n        hidePositionBarSwitch.connect('state-set', (_switch, state) => {\n            settings.set_boolean('show-position-bar', !state);\n        });\n        settings.connect('changed::show-position-bar', () => {\n            hidePositionBarSwitch.set_active(!settings.get_boolean('show-position-bar'));\n        });\n\n\n        clearDirectory.connect('clicked', () => {\n            settings.reset('directory');\n        });\n        settings.connect('changed::directory', () => {\n            // eslint-disable-next-line eqeqeq\n            clearDirectory.sensitive = settings.get_string('directory') != '';\n        });\n\n        return list;\n    }\n\n    getWorkspaceName(settings, index) {\n        return this.workspaceSettings.getWorkspaceName(settings, index);\n    }\n\n    createRow(text, widget) {\n        const margin = 12;\n        const box = new Gtk.Box({\n            margin_start: margin, margin_end: margin,\n            margin_top: margin / 2, margin_bottom: margin / 2,\n            orientation: Gtk.Orientation.HORIZONTAL,\n        });\n        const label = new Gtk.Label({\n            label: text, hexpand: true, xalign: 0,\n        });\n\n        box.append(label);\n        box.append(widget);\n\n        return box;\n    }\n\n    createFileChooserButton(settings, key, iconName, symbolicIconName, properties) {\n        const buttonIcon = Gtk.Image.new_from_icon_name(iconName);\n        const buttonLabel = new Gtk.Label();\n        const buttonBox = new Gtk.Box({\n            orientation: Gtk.Orientation.HORIZONTAL,\n            spacing: 8,\n        });\n\n        buttonBox.append(buttonIcon);\n        buttonBox.append(buttonLabel);\n        if (symbolicIconName) {\n            buttonBox.append(new Gtk.Image({ icon_name: symbolicIconName, margin_start: 8 }));\n        }\n\n        const button = new Gtk.Button({ child: buttonBox });\n\n        this.syncStringSetting(settings, key, path => {\n            buttonIcon.visible = path !== '';\n            buttonLabel.label = path === '' ? '(None)' : GLib.filename_display_basename(path);\n        });\n        button.connect('clicked', () => {\n            const chooser = new Gtk.FileChooserDialog(properties);\n            let path = settings.get_string(key);\n            if (path !== '')\n                chooser.set_file(Gio.File.new_for_path(path));\n            chooser.add_button('Open', Gtk.ResponseType.OK);\n            chooser.add_button('Cancel', Gtk.ResponseType.CANCEL);\n            chooser.connect('response', (dialog, response) => {\n                if (response === Gtk.ResponseType.OK) {\n                    settings.set_string(key, chooser.get_file().get_path());\n                }\n                chooser.destroy();\n            });\n            chooser.show();\n        });\n        return button;\n    }\n\n    syncStringSetting(settings, key, callback) {\n        settings.connect(`changed::${key}`, () => {\n            callback(settings.get_string(key));\n        });\n        callback(settings.get_string(key));\n    }\n}\n"
        },
        {
          "name": "prefsKeybinding.js",
          "type": "blob",
          "size": 32.6123046875,
          "content": "import Gdk from 'gi://Gdk';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport GObject from 'gi://GObject';\nimport Gtk from 'gi://Gtk';\n\nimport { AcceleratorParse } from './acceleratorparse.js';\n\nconst _ = s => s;\n\nconst KEYBINDINGS_KEY = 'org.gnome.shell.extensions.paperwm.keybindings';\n\nconst sections = {\n    windows: 'Windows',\n    workspaces: 'Workspaces',\n    monitors: 'Monitors',\n    scratch: 'Scratch layer',\n};\n\nconst actions = {\n    windows: [\n        'new-window',\n        'close-window',\n        'switch-next',\n        'switch-previous',\n        'switch-left',\n        'switch-right',\n        'switch-up',\n        'switch-down',\n        'switch-next-loop',\n        'switch-previous-loop',\n        'switch-left-loop',\n        'switch-right-loop',\n        'switch-up-loop',\n        'switch-down-loop',\n        'drift-left',\n        'drift-right',\n        'switch-global-left',\n        'switch-global-right',\n        'switch-global-up',\n        'switch-global-down',\n        'switch-up-or-else-workspace',\n        'switch-down-or-else-workspace',\n        'switch-first',\n        'switch-second',\n        'switch-third',\n        'switch-fourth',\n        'switch-fifth',\n        'switch-sixth',\n        'switch-seventh',\n        'switch-eighth',\n        'switch-ninth',\n        'switch-tenth',\n        'switch-eleventh',\n        'switch-last',\n        'live-alt-tab',\n        'live-alt-tab-backward',\n        'live-alt-tab-scratch',\n        'live-alt-tab-scratch-backward',\n        'switch-focus-mode',\n        'switch-open-window-position',\n        'open-window-position-right',\n        'open-window-position-left',\n        'open-window-position-down',\n        'open-window-position-up',\n        'open-window-position-start',\n        'open-window-position-end',\n        'move-left',\n        'move-right',\n        'move-up',\n        'move-down',\n        'slurp-in',\n        'barf-out',\n        'barf-out-active',\n        'center-horizontally',\n        'center-vertically',\n        'center',\n        'paper-toggle-fullscreen',\n        'toggle-maximize-width',\n        'resize-h-inc',\n        'resize-h-dec',\n        'resize-w-inc',\n        'resize-w-dec',\n        'cycle-width',\n        'cycle-width-backwards',\n        'cycle-height',\n        'cycle-height-backwards',\n        'take-window',\n        'activate-window-under-cursor',\n    ],\n    workspaces: [\n        'previous-workspace',\n        'previous-workspace-backward',\n        'move-previous-workspace',\n        'move-previous-workspace-backward',\n        'switch-up-workspace',\n        'switch-down-workspace',\n        'switch-up-workspace-from-all-monitors',\n        'switch-down-workspace-from-all-monitors',\n        'move-up-workspace',\n        'move-down-workspace',\n        'toggle-top-and-position-bar',\n        'toggle-top-bar',\n        'toggle-position-bar',\n    ],\n    monitors: [\n        'switch-monitor-right',\n        'switch-monitor-left',\n        'switch-monitor-above',\n        'switch-monitor-below',\n        'move-space-monitor-right',\n        'move-space-monitor-left',\n        'move-space-monitor-above',\n        'move-space-monitor-below',\n        'swap-monitor-right',\n        'swap-monitor-left',\n        'swap-monitor-above',\n        'swap-monitor-below',\n        'move-monitor-right',\n        'move-monitor-left',\n        'move-monitor-above',\n        'move-monitor-below',\n    ],\n    scratch: [\n        'toggle-scratch-layer',\n        'toggle-scratch',\n        'toggle-scratch-window',\n    ],\n};\n\nconst forbiddenKeyvals = [\n    Gdk.KEY_Home,\n    Gdk.KEY_Left,\n    Gdk.KEY_Up,\n    Gdk.KEY_Right,\n    Gdk.KEY_Down,\n    Gdk.KEY_Page_Up,\n    Gdk.KEY_Page_Down,\n    Gdk.KEY_End,\n    Gdk.KEY_Tab,\n    Gdk.KEY_KP_Enter,\n    Gdk.KEY_Return,\n    Gdk.KEY_Mode_switch,\n];\n\nfunction isValidBinding(combo) {\n    if ((combo.mods === 0 || combo.mods === Gdk.ModifierType.SHIFT_MASK) && combo.keycode !== 0) {\n        const keyval = combo.keyval;\n        if ((keyval >= Gdk.KEY_a && keyval <= Gdk.KEY_z) ||\n            (keyval >= Gdk.KEY_A && keyval <= Gdk.KEY_Z) ||\n            (keyval >= Gdk.KEY_0 && keyval <= Gdk.KEY_9) ||\n            (keyval >= Gdk.KEY_kana_fullstop && keyval <= Gdk.KEY_semivoicedsound) ||\n            (keyval >= Gdk.KEY_Arabic_comma && keyval <= Gdk.KEY_Arabic_sukun) ||\n            (keyval >= Gdk.KEY_Serbian_dje && keyval <= Gdk.KEY_Cyrillic_HARDSIGN) ||\n            (keyval >= Gdk.KEY_Greek_ALPHAaccent && keyval <= Gdk.KEY_Greek_omega) ||\n            (keyval >= Gdk.KEY_hebrew_doublelowline && keyval <= Gdk.KEY_hebrew_taf) ||\n            (keyval >= Gdk.KEY_Thai_kokai && keyval <= Gdk.KEY_Thai_lekkao) ||\n            (keyval >= Gdk.KEY_Hangul_Kiyeog && keyval <= Gdk.KEY_Hangul_J_YeorinHieuh) ||\n            (keyval === Gdk.KEY_space && combo.mods === 0) ||\n            forbiddenKeyvals.includes(keyval)) {\n            return false;\n        }\n    }\n\n    // Allow Tab in addition to accelerators allowed by GTK\n    if (!Gtk.accelerator_valid(combo.keyval, combo.mods) &&\n        (combo.keyval !== Gdk.KEY_Tab || combo.mods === 0)) {\n        return false;\n    }\n\n    return true;\n}\n\nfunction isEmptyBinding(combo) {\n    return combo.keyval === 0 && combo.mods === 0 && combo.keycode === 0;\n}\n\nconst Combo = GObject.registerClass({\n    GTypeName: 'Combo',\n    Properties: {\n        keycode: GObject.ParamSpec.uint(\n            'keycode',\n            'Keycode',\n            'Key code',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            0,\n            GLib.MAXUINT32,\n            0\n        ),\n        keyval: GObject.ParamSpec.uint(\n            'keyval',\n            'Keyval',\n            'Key value',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            0,\n            GLib.MAXUINT32,\n            0\n        ),\n        mods: GObject.ParamSpec.uint(\n            'mods',\n            'Mods',\n            'Key modifiers',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            0,\n            GLib.MAXUINT32,\n            0\n        ),\n        keystr: GObject.ParamSpec.string(\n            'keystr',\n            'Keystr',\n            'Key string',\n            GObject.ParamFlags.READABLE,\n            null\n        ),\n        label: GObject.ParamSpec.string(\n            'label',\n            'Label',\n            'Key label',\n            GObject.ParamFlags.READABLE,\n            null\n        ),\n        disabled: GObject.ParamSpec.boolean(\n            'disabled',\n            'Disabled',\n            'Disabled sentinel',\n            GObject.ParamFlags.READABLE,\n            false\n        ),\n        placeholder: GObject.ParamSpec.boolean(\n            'placeholder',\n            'Placeholder',\n            'Placeholder sentinel',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            false\n        ),\n    },\n}, class Combo extends GObject.Object {\n    _init(params, acceleratorParse) {\n        super._init(params);\n        this.acceleratorParse = acceleratorParse;\n    }\n\n    get keycode() {\n        if (this.disabled) {\n            return 0;\n        } else if (!this._keycode) {\n            let [ok, key, mask] = this.acceleratorParse.accelerator_parse(this.keystr);\n\n            if (ok && key.length) {\n                return key;\n            } else {\n                return 0;\n            }\n        } else {\n            return this._keycode;\n        }\n    }\n\n    get keystr() {\n        if (this.disabled)\n            return '';\n        else\n            return Gtk.accelerator_name(this.keyval, this.mods);\n    }\n\n    get label() {\n        if (this.disabled)\n            return _('Disabled');\n        else\n            return Gtk.accelerator_get_label(this.keyval, this.mods);\n    }\n\n    get disabled() {\n        return !this.keyval && !this.mods;\n    }\n\n    toString() {\n        return `Combo(keycode=${this.keycode}, keyval=${this.keyval}, mods=${this.mods})`;\n    }\n});\n\nconst Keybinding = GObject.registerClass({\n    GTypeName: 'Keybinding',\n    Implements: [Gio.ListModel],\n    Properties: {\n        section: GObject.ParamSpec.string(\n            'section',\n            'Section',\n            'Keybinding section title',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            null\n        ),\n        action: GObject.ParamSpec.string(\n            'action',\n            'Action',\n            'Keybinding action ID',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            null\n        ),\n        description: GObject.ParamSpec.string(\n            'description',\n            'Description',\n            'Keybinding action description',\n            GObject.ParamFlags.READABLE,\n            null\n        ),\n        label: GObject.ParamSpec.string(\n            'label',\n            'Label',\n            'Keybinding combo label',\n            GObject.ParamFlags.READABLE,\n            null\n        ),\n        combos: GObject.ParamSpec.object(\n            'combos',\n            'Combos',\n            'Key combos',\n            GObject.ParamFlags.READABLE,\n            Gio.ListModel.$gtype\n        ),\n        modified: GObject.ParamSpec.boolean(\n            'modified',\n            'Modified',\n            'True if the user has modified the shortcut from its default value',\n            GObject.ParamFlags.READABLE,\n            false\n        ),\n        enabled: GObject.ParamSpec.boolean(\n            'enabled',\n            'Enabled',\n            'True if this keybinding has any shortcuts',\n            GObject.ParamFlags.READABLE,\n            false\n        ),\n    },\n    Signals: {\n        changed: {},\n    },\n}, class Keybinding extends GObject.Object {\n    _init(params = {}, settings, acceleratorParse) {\n        super._init(params);\n        this._settings = settings;\n        this.acceleratorParse = acceleratorParse;\n        this._description = _(this._settings.settings_schema.get_key(this.action).get_summary());\n\n        this._combos = new Gio.ListStore();\n        this._combos.connect('items-changed', (_, position, removed, added) => {\n            this.items_changed(position, removed, added);\n            this.notify('label');\n        });\n\n        this._settings.connect(`changed::${this.action}`, () => this._load());\n        GLib.idle_add(0, () => this._load());\n    }\n\n    get description() {\n        return this._description;\n    }\n\n    get label() {\n        const labels = [...this.combos]\n              .filter(c => !isEmptyBinding(c))\n              .map(c => c.label);\n\n        let label = '';\n        if (labels.length === 0) {\n            label = _('Disabled');\n        } else {\n            label = labels.join(', ');\n        }\n\n        if (this.modified) {\n            label = `<b>${label}</b>`;\n        }\n\n        return label;\n    }\n\n    get combos() {\n        return this._combos;\n    }\n\n    get modified() {\n        return this._settings.get_user_value(this.action) !== null;\n    }\n\n    get enabled() {\n        return [...this.combos].some(c => !c.disabled);\n    }\n\n    vfunc_get_item_type() {\n        return Combo.$gtype;\n    }\n\n    vfunc_get_item(position) {\n        return this.combos.get_item(position);\n    }\n\n    vfunc_get_n_items() {\n        return this.combos.get_n_items();\n    }\n\n    add(combo) {\n        const [found, _] = this.find(combo);\n        if (found)\n            return;\n        this.combos.append(combo);\n        if (!combo.disabled) {\n            this._store();\n        }\n    }\n\n    remove(combo) {\n        const [found, pos] = this.find(combo);\n        if (!found)\n            return;\n        this.combos.remove(pos);\n        if (this.combos.get_n_items() === 0)\n            this.combos.append(new Combo({}, this.acceleratorParse));\n        this._store();\n    }\n\n    replace(oldCombo, newCombo) {\n        const [found, _] = this.find(newCombo);\n        if (found)\n            return;\n        const [oldFound, pos] = this.find(oldCombo);\n        if (oldFound) {\n            this.combos.splice(pos, 1, [newCombo]);\n        } else {\n            this.combos.append(newCombo);\n        }\n        this._store();\n    }\n\n    disable() {\n        this._settings.set_strv(this.action, ['']);\n    }\n\n    reset() {\n        if (this._settings.get_user_value(this.action)) {\n            this._settings.reset(this.action);\n        }\n    }\n\n    find(combo) {\n        const pos = [...this.combos].findIndex(c => c.keystr === combo.keystr);\n        if (pos === -1) {\n            return [false];\n        } else {\n            return [true, pos];\n        }\n    }\n\n    _load() {\n        const keystrs = this._settings.get_strv(this.action) || [];\n        let combos = keystrs\n            .map(this._translateAboveTab)\n            .map(keystr => {\n                if (keystr !== '')\n                    return this.acceleratorParse.accelerator_parse(keystr);\n                else\n                    return [true, 0, 0];\n            })\n            .map(([, keyval, mods]) => new Combo({ keyval, mods }, this.acceleratorParse));\n\n        if (combos.length === 0) {\n            combos.push(new Combo({}, this.acceleratorParse));\n        }\n\n        this.combos.splice(0, this.combos.get_n_items(), combos);\n    }\n\n    _store() {\n        let filtered = [...this.combos]\n            .filter(c => !isEmptyBinding(c))\n            .map(c => c.keystr);\n        if (filtered.length === 0) {\n            filtered = [''];\n        }\n        this._settings.set_strv(this.action, filtered);\n    }\n\n    _translateAboveTab(keystr) {\n        if (!keystr.match(/Above_Tab/)) {\n            return keystr;\n        } else {\n            let keyvals = aboveTabKeyvals();\n            if (!keyvals)\n                return keystr.replace('Above_Tab', 'grave');\n\n            let keyname = Gdk.keyval_name(keyvals[0]);\n            return keystr.replace('Above_Tab', keyname);\n        }\n    }\n});\n\nexport const KeybindingsModel = GObject.registerClass({\n    GTypeName: 'KeybindingsModel',\n    Implements: [Gio.ListModel],\n    Signals: {\n        'collisions-changed': {\n            flags: GObject.SignalFlags.RUN_LAST | GObject.SignalFlags.DETAILED,\n        },\n    },\n}, class KeybindingsModel extends GObject.Object {\n    _init(params = {}, acceleratorParse) {\n        super._init(params);\n        this.acceleratorParse = acceleratorParse;\n        this._model = Gio.ListStore.new(Keybinding.$gtype);\n        this._model.connect('items-changed', (_, position, removed, added) => {\n            this.items_changed(position, removed, added);\n        });\n\n        this._combos = Gtk.FlattenListModel.new(this._model);\n        this._combos.connect('items-changed', () => {\n            // Room for optimization here.\n            this._updateCollisions();\n        });\n\n        this._actionToBinding = new Map();\n    }\n\n    init(settings) {\n        this._settings = settings;\n        this.load();\n    }\n\n    vfunc_get_item_type() {\n        return this._model.get_item_type();\n    }\n\n    vfunc_get_item(position) {\n        return this._model.get_item(position);\n    }\n\n    vfunc_get_n_items() {\n        return this._model.get_n_items();\n    }\n\n    get collisions() {\n        if (this._collisions === undefined) {\n            this._collisions = new Map();\n            this._updateCollisions();\n        }\n        return this._collisions;\n    }\n\n    getKeybinding(action) {\n        return this._actionToBinding.get(action);\n    }\n\n    find(binding) {\n        return this._model.find(binding);\n    }\n\n    load() {\n        let bindings = [];\n        for (const section in actions) {\n            for (const action of actions[section]) {\n                const binding = new Keybinding({\n                    section,\n                    action,\n                }, this._settings, this.acceleratorParse);\n                bindings.push(binding);\n                this._actionToBinding.set(action, binding);\n            }\n        }\n        this._model.splice(0, this._model.get_n_items(), bindings);\n    }\n\n    _updateCollisions(position, removed, added) {\n        let map = new Map();\n        for (const binding of this._model) {\n            for (const combo of binding.combos) {\n                if (combo.disabled)\n                    continue;\n                map.set(combo.keystr, (map.get(combo.keystr) || new Set()).add(binding.action));\n            }\n        }\n        let changed = new Set();\n        for (const [keystr, actions] of map.entries()) {\n            if (actions.size > 1) {\n                if (!this.collisions.has(keystr)) {\n                    for (const action of actions) {\n                        changed.add(action);\n                    }\n                } else {\n                    let old = this.collisions.get(keystr);\n                    for (const action of symmetricDifference(old, actions)) {\n                        changed.add(action);\n                    }\n                }\n                this.collisions.set(keystr, actions);\n            } else {\n                for (const action of actions) {\n                    changed.add(action);\n                }\n                this.collisions.delete(keystr);\n            }\n        }\n        if (changed.size > 0) {\n            for (const action of changed) {\n                this.emit(`collisions-changed::${action}`);\n            }\n        }\n    }\n});\n\nconst ComboRow = GObject.registerClass({\n    GTypeName: 'ComboRow',\n    Template: GLib.uri_resolve_relative(import.meta.url, './KeybindingsComboRow.ui', GLib.UriFlags.NONE),\n    InternalChildren: [\n        'stack',\n        'shortcutPage',\n        'placeholderPage',\n        'editPage',\n        'shortcutLabel',\n        'deleteButton',\n        'conflictButton',\n        'conflictList',\n    ],\n    Properties: {\n        keybinding: GObject.ParamSpec.object(\n            'keybinding',\n            'Keybinding',\n            'Keybinding',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            Keybinding.$gtype\n        ),\n        combo: GObject.ParamSpec.object(\n            'combo',\n            'Combo',\n            'Key combo',\n            GObject.ParamFlags.READWRITE,\n            Combo.$gtype\n        ),\n        editing: GObject.ParamSpec.boolean(\n            'editing',\n            'Editing',\n            'Editing',\n            GObject.ParamFlags.READWRITE,\n            false\n        ),\n    },\n    Signals: {\n        'collision-activated': {\n            param_types: [Keybinding.$gtype],\n        },\n    },\n}, class ComboRow extends Gtk.ListBoxRow {\n    _init(params = {}) {\n        super._init(params);\n\n        let controller;\n        controller = Gtk.EventControllerKey.new();\n        controller.connect('key-pressed', (controller, keyval, keycode, state) => {\n            this._onKeyPressed(controller, keyval, keycode, state);\n        });\n        this.add_controller(controller);\n\n        controller = Gtk.EventControllerFocus.new();\n        controller.connect('leave', () => {\n            this.editing = false;\n        });\n        this.add_controller(controller);\n\n        this._collisions = Gio.ListStore.new(Keybinding.$gtype);\n\n        this._conflictList.bind_model(this._collisions, binding => this._createConflictRow(binding));\n\n        GLib.idle_add(0, () => this._updateState());\n    }\n\n    get combo() {\n        if (this._combo === undefined)\n            this._combo = null;\n        return this._combo;\n    }\n\n    set combo(value) {\n        if (value && this._combo && this._combo.keystr === value.keystr)\n            return;\n        this._combo = value;\n        this.notify('combo');\n        this._updateState();\n    }\n\n    get editing() {\n        if (this._editing === undefined)\n            this._editing = false;\n        return this._editing;\n    }\n\n    set editing(value) {\n        if (this.editing === value)\n            return;\n        this._editing = value;\n        this.notify('editing');\n        this._updateState();\n    }\n\n    get collisions() {\n        return [...this._collisions];\n    }\n\n    set collisions(value) {\n        this._collisions.splice(0, this._collisions.get_n_items(), value);\n    }\n\n    _createConflictRow(binding) {\n        return new Gtk.Label({\n            label: binding.description,\n        });\n    }\n\n    _onConflictRowActivated(list, row) {\n        const binding = this._collisions.get_item(row.get_index());\n        this.emit('collision-activated', binding);\n    }\n\n    _grabKeyboard() {\n        this.get_root().get_surface().inhibit_system_shortcuts(null);\n    }\n\n    _ungrabKeyboard() {\n        // using optionals here since may have already been ungrabbed\n        this.get_root()?.get_surface()?.restore_system_shortcuts();\n    }\n\n    _onDeleteButtonClicked() {\n        GLib.idle_add(0, () => this.keybinding.remove(this.combo));\n    }\n\n    _onKeyPressed(controller, keyval, keycode, state) {\n        // Adapted from Control Center, cc-keyboard-shortcut-editor.c\n        if (!this.editing)\n            return Gdk.EVENT_PROPAGATE;\n\n        /**\n         * Replace KEY_less (\"<\") with comma, see\n         * https://github.com/paperwm/PaperWM/issues/545\n         */\n        if (keyval === Gdk.KEY_less) {\n            keycode = Gdk.KEY_comma;\n            keyval = Gdk.KEY_comma;\n        }\n\n        let modmask = state & Gtk.accelerator_get_default_mod_mask();\n        let keyvalLower = Gdk.keyval_to_lower(keyval);\n\n        // Normalize <Tab>\n        if (keyvalLower === Gdk.KEY_ISO_Left_Tab) {\n            keyvalLower = Gdk.KEY_Tab;\n        }\n\n        // Put Shift back if it changed the case of the key\n        if (keyvalLower !== keyval) {\n            modmask |= Gdk.ModifierType.SHIFT_MASK;\n        }\n\n        if (keyvalLower === Gdk.KEY_Sys_Req && (modmask & Gdk.ModifierType.ALT_MASK) !== 0) {\n            // Don't allow SysRq as a keybinding, but allow Alt+Print\n            keyvalLower = Gdk.KEY_Print;\n        }\n\n        const event = controller.get_current_event();\n        const isModifier = event.is_modifier();\n\n        // Escape cancels\n        if (!isModifier && modmask === 0 && keyvalLower === Gdk.KEY_Escape) {\n            this.editing = false;\n            if (this.combo.placeholder) {\n                this.keybinding.remove(this.combo);\n            }\n            return Gdk.EVENT_STOP;\n        }\n\n        // Backspace deletes\n        if (!isModifier && modmask === 0 && keyvalLower === Gdk.KEY_BackSpace) {\n            this._updateKeybinding(new Combo({}, this.acceleratorParse));\n            return Gdk.EVENT_STOP;\n        }\n\n        // Remove CapsLock\n        modmask &= ~Gdk.ModifierType.LOCK_MASK;\n\n        this._updateKeybinding(new Combo({ keycode, keyval: keyvalLower, mods: modmask },\n            this.acceleratorParse));\n\n        return Gdk.EVENT_STOP;\n    }\n\n    _updateKeybinding(newCombo) {\n        let isValid = isValidBinding(newCombo);\n        let isEmpty = isEmptyBinding(newCombo);\n\n        const oldCombo = this.combo;\n        if (isEmptyBinding(oldCombo) && isValid) {\n            this.editing = false;\n            this.keybinding.add(newCombo);\n            return;\n        }\n\n        if (isEmpty) {\n            this.editing = false;\n            this.keybinding.remove(oldCombo);\n            return;\n        }\n\n        if (isValid) {\n            this.editing = false;\n            this.keybinding.replace(oldCombo, newCombo);\n        }\n    }\n\n    _updateState() {\n        if (!this._stack) {\n            return;\n        }\n\n        if (this.editing) {\n            this.add_css_class('editing');\n            this._stack.visible_child = this._editPage;\n            this.grab_focus();\n            this._grabKeyboard();\n        } else {\n            this.remove_css_class('editing');\n            this._stack.visible_child = this._shortcutPage;\n            this._ungrabKeyboard();\n\n            if (this._combo && !this._combo.disabled) {\n                this._shortcutLabel.accelerator = this._combo.keystr;\n                this._deleteButton.visible = true;\n                this._conflictButton.visible = this.collisions.length > 0;\n            } else {\n                this._shortcutLabel.accelerator = '';\n                this._deleteButton.visible = false;\n            }\n        }\n    }\n});\n\nconst KeybindingsRow = GObject.registerClass({\n    GTypeName: 'KeybindingsRow',\n    Template: GLib.uri_resolve_relative(import.meta.url, './KeybindingsRow.ui', GLib.UriFlags.NONE),\n    InternalChildren: [\n        'header',\n        'descLabel',\n        'accelLabel',\n        'conflictIcon',\n        'revealer',\n        'comboList',\n    ],\n    Properties: {\n        keybindings: GObject.ParamSpec.object(\n            'keybindings',\n            'Keybindings',\n            'Keybindings model',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            KeybindingsModel.$gtype\n        ),\n        keybinding: GObject.ParamSpec.object(\n            'keybinding',\n            'Keybinding',\n            'Keybinding',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY,\n            Keybinding.$gtype\n        ),\n        expanded: GObject.ParamSpec.boolean(\n            'expanded',\n            'Expanded',\n            'Expanded',\n            GObject.ParamFlags.READWRITE,\n            false\n        ),\n        collisions: GObject.ParamSpec.jsobject(\n            'collisions',\n            'Collisions',\n            'Colliding keybindings',\n            GObject.ParamFlags.READABLE\n        ),\n    },\n    Signals: {\n        'collision-activated': {\n            param_types: [Keybinding.$gtype],\n        },\n    },\n}, class KeybindingsRow extends Gtk.ListBoxRow {\n    _init(params = {}, acceleratorParse) {\n        super._init(params);\n        this.acceleratorParse = acceleratorParse;\n        this._actionGroup = new Gio.SimpleActionGroup();\n        this.insert_action_group('keybinding', this._actionGroup);\n\n        let action;\n        action = new Gio.SimpleAction({\n            name: 'reset',\n            enabled: this.keybinding.modified,\n        });\n        action.connect('activate', () => this.keybinding.reset());\n        this._actionGroup.add_action(action);\n\n        action = new Gio.SimpleAction({ name: 'add' });\n        action.connect('activate', () => this.keybinding.add(new Combo({ placeholder: true },\n            this.acceleratorParse)));\n        this._actionGroup.add_action(action);\n\n        const gesture = Gtk.GestureClick.new();\n        gesture.set_button(Gdk.BUTTON_PRIMARY);\n        gesture.connect('released', controller => {\n            this.expanded = !this.expanded;\n            controller.set_state(Gtk.EventSequenceState.CLAIMED);\n        });\n        this._header.add_controller(gesture);\n\n        this._descLabel.label = this.keybinding.description;\n        this._descLabel.tooltip_text = this.keybinding.description;\n\n        this.keybinding.connect('notify::label', () => this._updateState());\n\n        this._comboList.bind_model(this.keybinding, combo => this._createRow(combo));\n\n        this.keybindings.connect(\n            `collisions-changed::${this.keybinding.action}`,\n            () => { this._onCollisionsChanged(); }\n        );\n\n        this._updateState();\n    }\n\n    get expanded() {\n        if (this._expanded === undefined)\n            this._expanded = false;\n        return this._expanded;\n    }\n\n    set expanded(value) {\n        if (this._expanded === value)\n            return;\n\n        this._expanded = value;\n        this.notify('expanded');\n        this._updateState();\n    }\n\n    get collisions() {\n        if (this._collisions === undefined) {\n            this._collisions = new Map();\n        }\n        return this._collisions;\n    }\n\n    _createRow(combo) {\n        const row = new ComboRow({\n            keybinding: this.keybinding,\n            combo,\n        });\n        if (combo.placeholder) {\n            GLib.idle_add(0, () => { row.editing = true; });\n        }\n        this.connect('notify::collisions', () => {\n            row.collisions = this.collisions.get(combo.keystr) || [];\n        });\n        row.connect('collision-activated', (_, binding) => {\n            this.emit('collision-activated', binding);\n        });\n        return row;\n    }\n\n    _onCollisionsChanged() {\n        const map = new Map();\n        const collisions = this.keybindings.collisions;\n        for (const combo of this.keybinding.combos) {\n            const actions = collisions.get(combo.keystr);\n            if (!actions)\n                continue;\n            map.set(\n                combo.keystr,\n                [...actions]\n                    .filter(a => a !== this.keybinding.action)\n                    .map(a => this.keybindings.getKeybinding(a))\n            );\n        }\n        this._collisions = map;\n        this.notify('collisions');\n        this._updateState();\n    }\n\n    _onRowActivated(list, row) {\n        if (row.is_focus()) {\n            row.editing = !row.editing;\n        }\n    }\n\n    _updateState() {\n        GLib.idle_add(0, () => {\n            this._accelLabel.label = this.keybinding.label;\n            if (this.expanded) {\n                this._accelLabel.hide();\n                this._conflictIcon.visible = false;\n                this._revealer.reveal_child = true;\n                this.add_css_class('expanded');\n            } else {\n                this._accelLabel.show();\n                this._conflictIcon.visible = this.collisions.size > 0;\n                this._revealer.reveal_child = false;\n                this.remove_css_class('expanded');\n            }\n        });\n    }\n});\n\nexport const KeybindingsPane = GObject.registerClass({\n    GTypeName: 'KeybindingsPane',\n    Template: GLib.uri_resolve_relative(import.meta.url, './KeybindingsPane.ui', GLib.UriFlags.NONE),\n    InternalChildren: [\n        'search',\n        'listbox',\n    ],\n}, class KeybindingsPane extends Gtk.Box {\n    _init(params = {}) {\n        super._init(params);\n    }\n\n    init(extension) {\n        this._settings = extension.getSettings(KEYBINDINGS_KEY);\n        this.acceleratorParse = new AcceleratorParse();\n        this._model = new KeybindingsModel({}, this.acceleratorParse);\n\n        this._filter = new Gtk.StringFilter({\n            expression: Gtk.PropertyExpression.new(Keybinding.$gtype, null, 'description'),\n            ignore_case: true,\n            match_mode: Gtk.StringFilterMatchMode.SUBSTRING,\n        });\n\n        const filteredBindings = new Gtk.FilterListModel({\n            model: this._model,\n            filter: this._filter,\n        });\n\n        this._listbox.bind_model(filteredBindings, keybinding => this._createRow(keybinding));\n        this._listbox.set_header_func((row, before, data) => this._onSetHeader(row, before, data));\n\n        this._expandedRow = null;\n\n        // send settings to model (which processes and creates rows)\n        this._model.init(this._settings);\n    }\n\n    _createHeader(row, before) {\n        const box = new Gtk.Box({ orientation: Gtk.Orientation.VERTICAL });\n        if (before)\n            box.append(new Gtk.Separator({ orientation: Gtk.Orientation.HORIZONTAL }));\n        box.append(new Gtk.Label({\n            use_markup: true,\n            label: _(`<b>${sections[row.keybinding.section]}</b>`),\n            xalign: 0.0,\n            margin_top: 24,\n            margin_bottom: 6,\n            margin_start: 12,\n            margin_end: 12,\n        }));\n        box.append(new Gtk.Separator({ orientation: Gtk.Orientation.HORIZONTAL }));\n        return box;\n    }\n\n    _createRow(keybinding) {\n        const row = new KeybindingsRow({ keybindings: this._model, keybinding }, this.acceleratorParse);\n        row.connect('notify::expanded', row => this._onRowExpanded(row));\n        row.connect('collision-activated', (_, binding) => this._onCollisionActivated(binding));\n        return row;\n    }\n\n    _onCollisionActivated(keybinding) {\n        const [found, pos] = this._model.find(keybinding);\n        if (found) {\n            const row = this._listbox.get_row_at_index(pos);\n            row.activate();\n        }\n    }\n\n    _onSearchChanged() {\n        this._filter.search = this._search.text || null;\n    }\n\n    _onRowActivated(list, row) {\n        if (!row.is_focus())\n            return;\n        row.expanded = !row.expanded;\n    }\n\n    _onRowExpanded(row) {\n        if (row.expanded) {\n            if (this._expandedRow)\n                this._expandedRow.expanded = false;\n            this._expandedRow = row;\n        } else if (this._expandedRow === row) {\n            this._expandedRow = null;\n        }\n    }\n\n    _onSetHeader(row, before, data) {\n        const header = row.get_header();\n        if (!before || before.keybinding.section !== row.keybinding.section) {\n            if (!header || header instanceof Gtk.Separator) {\n                row.set_header(this._createHeader(row, before));\n            }\n        } else if (!header || !(header instanceof Gtk.Separator)) {\n            row.set_header(new Gtk.Separator({ orientation: Gtk.Orientation.HORIZONTAL }));\n        }\n    }\n});\n\nlet _aboveTabKeyvals = null;\n\nfunction aboveTabKeyvals() {\n    if (!_aboveTabKeyvals) {\n        const keycode = 0x29 + 8; // KEY_GRAVE\n        let display = Gdk.Display.get_default();\n        let [, , keyvals] = display.map_keycode(keycode);\n        _aboveTabKeyvals = keyvals;\n    }\n    return _aboveTabKeyvals;\n}\n\nfunction symmetricDifference(setA, setB) {\n    let _difference = new Set(setA);\n    for (let elem of setB) {\n        if (_difference.has(elem)) {\n            _difference.delete(elem);\n        } else {\n            _difference.add(elem);\n        }\n    }\n    return _difference;\n}\n"
        },
        {
          "name": "resources",
          "type": "tree",
          "content": null
        },
        {
          "name": "schemas",
          "type": "tree",
          "content": null
        },
        {
          "name": "scratch.js",
          "type": "blob",
          "size": 7.0380859375,
          "content": "import Meta from 'gi://Meta';\nimport Mtk from 'gi://Mtk';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as PopupMenu from 'resource:///org/gnome/shell/ui/popupMenu.js';\nimport * as WindowMenu from 'resource:///org/gnome/shell/ui/windowMenu.js';\n\nimport { Settings, Utils, Tiling, Topbar } from './imports.js';\nimport { Easer } from './utils.js';\n\nlet originalBuildMenu;\nlet float, scratchFrame; // symbols used for expando properties on metawindow\nexport function enable() {\n    originalBuildMenu = WindowMenu.WindowMenu.prototype._buildMenu;\n    float = Symbol();\n    scratchFrame = Symbol();\n    WindowMenu.WindowMenu.prototype._buildMenu =\n        function (window) {\n            let item;\n            item = this.addAction(_('Scratch'), () => {\n                toggle(window);\n            });\n            if (isScratchWindow(window))\n                item.setOrnament(PopupMenu.Ornament.CHECK);\n\n            originalBuildMenu.call(this, window);\n        };\n}\n\nexport function disable() {\n    WindowMenu.WindowMenu.prototype._buildMenu = originalBuildMenu;\n    originalBuildMenu = null;\n    float = null;\n    scratchFrame = null;\n}\n\n/**\n   Tween window to \"frame-coordinate\" (targetX, targetY).\n   The frame is moved once the tween is done.\n\n   The actual window actor (not clone) is tweened to ensure it's on top of the\n   other windows/clones (clones if the space animates)\n */\nexport function easeScratch(metaWindow, targetX, targetY, params = {}) {\n    const complete = params?.onComplete ?? function() {};\n    const f = metaWindow.get_frame_rect();\n    const b = metaWindow.get_buffer_rect();\n    const dx = f.x - b.x;\n    const dy = f.y - b.y;\n\n    Easer.addEase(metaWindow.get_compositor_private(), {\n        x: targetX - dx,\n        y: targetY - dy,\n        time: Settings.prefs.animation_time,\n        onComplete: () => {\n            metaWindow.move_frame(true, targetX, targetY);\n            complete();\n        },\n    });\n}\n\nexport function makeScratch(metaWindow) {\n    let fromNonScratch = !metaWindow[float];\n    let fromTiling = false;\n    // Relevant when called while navigating. Use the position the user actually sees.\n    let windowPositionSeen;\n\n    if (fromNonScratch) {\n        // Figure out some stuff before the window is removed from the tiling\n        let space = Tiling.spaces.spaceOfWindow(metaWindow);\n        fromTiling = space.indexOf(metaWindow) > -1;\n        if (fromTiling) {\n            windowPositionSeen = metaWindow.clone\n                .get_transformed_position()\n                .map(Math.round);\n        }\n    }\n\n    metaWindow[float] = true;\n    metaWindow.make_above();\n    metaWindow.stick();  // NB! Removes the window from the tiling (synchronously)\n\n    if (!metaWindow.minimized)\n        Tiling.showWindow(metaWindow);\n\n    if (fromTiling) {\n        let f = metaWindow.get_frame_rect();\n        let targetFrame = null;\n\n        if (metaWindow[scratchFrame]) {\n            let sf = metaWindow[scratchFrame];\n            if (Utils.monitorOfPoint(sf.x, sf.y) === Tiling.focusMonitor()) {\n                targetFrame = sf;\n            }\n        }\n\n        if (!targetFrame) {\n            // Default to moving the window slightly down and reducing the height\n            let vDisplacement = 30;\n            let [x, y] = windowPositionSeen;  // The window could be non-placable so can't use frame\n\n            targetFrame = new Mtk.Rectangle({\n                x, y: y + vDisplacement,\n                width: f.width,\n                height: Math.min(f.height - vDisplacement, Math.floor(f.height * 0.9)),\n            });\n        }\n\n        if (!metaWindow.minimized) {\n            metaWindow.move_resize_frame(true, f.x, f.y,\n                targetFrame.width, targetFrame.height);\n            easeScratch(\n                metaWindow,\n                targetFrame.x,\n                targetFrame.y,\n                {\n                    onComplete: () => {\n                        delete metaWindow[scratchFrame];\n                        Main.activateWindow(metaWindow);\n                    },\n                });\n        } else {\n            // Can't restore the scratch geometry immediately since it distort the minimize animation\n            // ASSUMPTION: minimize animation is not disabled and not already done\n            let actor = metaWindow.get_compositor_private();\n            let signal = actor.connect('effects-completed', () => {\n                metaWindow.move_resize_frame(true, targetFrame.x, targetFrame.y,\n                    targetFrame.width, targetFrame.height);\n                actor.disconnect(signal);\n            });\n        }\n    }\n\n    Tiling.focusMonitor()?.clickOverlay?.hide();\n}\n\nexport function unmakeScratch(metaWindow) {\n    if (!metaWindow[scratchFrame])\n        metaWindow[scratchFrame] = metaWindow.get_frame_rect();\n    metaWindow[float] = false;\n    metaWindow.unmake_above();\n    metaWindow.unstick();\n}\n\nexport function toggle(metaWindow) {\n    if (isScratchWindow(metaWindow)) {\n        unmakeScratch(metaWindow);\n    } else {\n        makeScratch(metaWindow);\n\n        if (metaWindow.has_focus) {\n            let space = Tiling.spaces.activeSpace;\n            space.setSelectionInactive();\n        }\n    }\n}\n\nexport function isScratchWindow(metaWindow) {\n    return metaWindow && metaWindow[float];\n}\n\n/** Return scratch windows in MRU order */\nexport function getScratchWindows() {\n    return global.display.get_tab_list(Meta.TabList.NORMAL, null)\n        .filter(isScratchWindow);\n}\n\nexport function isScratchActive() {\n    return getScratchWindows().some(metaWindow => !metaWindow.minimized);\n}\n\nexport function toggleScratch() {\n    if (isScratchActive())\n        hide();\n    else\n        show();\n}\n\nexport function toggleScratchWindow() {\n    let focus = global.display.focus_window;\n    if (isScratchWindow(focus))\n        hide();\n    else\n        show(true);\n}\n\nexport function show(top) {\n    let windows = getScratchWindows();\n    if (windows.length === 0) {\n        return;\n    }\n    if (top)\n        windows = windows.slice(0, 1);\n\n    Topbar.fixTopBar();\n\n    windows.slice().reverse()\n        .map(function(meta_window) {\n            meta_window.unminimize();\n            meta_window.make_above();\n            meta_window.get_compositor_private().show();\n        });\n    windows[0].activate(global.get_current_time());\n\n    let monitor = Tiling.focusMonitor();\n    monitor.clickOverlay?.hide();\n}\n\nexport function hide() {\n    let windows = getScratchWindows();\n    windows.map(function(meta_window) {\n        meta_window.minimize();\n    });\n}\n\nexport function animateWindows() {\n    let ws = getScratchWindows().filter(w => !w.minimized);\n    ws = global.display.sort_windows_by_stacking(ws);\n    for (let w of ws) {\n        // let parent = w.clone.get_parent();\n        // parent && parent.remove_child(w.clone);\n        Utils.actor_remove_parent(w.clone);\n\n        Main.uiGroup.insert_child_above(w.clone, global.window_group);\n        let f = w.get_frame_rect();\n        w.clone.set_position(f.x, f.y);\n        Tiling.animateWindow(w);\n    }\n}\n\nexport function showWindows() {\n    let ws = getScratchWindows().filter(w => !w.minimized);\n    ws.forEach(Tiling.showWindow);\n}\n"
        },
        {
          "name": "settings.js",
          "type": "blob",
          "size": 14.65234375,
          "content": "import Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\n\nimport { AcceleratorParse } from './acceleratorparse.js';\n\n/**\n    Settings utility shared between the running extension and the preference UI.\n    settings.js shouldn't depend on other modules (e.g with `imports` for other modules\n    at the top).\n */\n\nconst KEYBINDINGS_KEY = 'org.gnome.shell.extensions.paperwm.keybindings';\nconst RESTORE_KEYBINDS_KEY = 'restore-keybinds';\n\n// This is the value mutter uses for the keyvalue of above_tab\nconst META_KEY_ABOVE_TAB = 0x2f7259c9;\n\n// position to open window at (e.g. to the right of current window)\nexport const OpenWindowPositions = { RIGHT: 0, LEFT: 1, START: 2, END: 3, DOWN: 4, UP: 5 };\n\n// Animation used when ensuring viewport on a window\nexport const EnsureViewportAnimation = { NONE: 0, TRANSLATE: 1, FADE: 2 };\n\nexport let prefs;\nlet gsettings, keybindSettings, _overriddingConflicts;\nlet acceleratorParse;\nexport function enable(extension) {\n    gsettings = extension.getSettings();\n    keybindSettings = extension.getSettings(KEYBINDINGS_KEY);\n\n    acceleratorParse = new AcceleratorParse();\n    _overriddingConflicts = false;\n    prefs = {};\n    [\n        'window-gap',\n        'vertical-margin',\n        'vertical-margin-bottom',\n        'horizontal-margin',\n        'workspace-colors',\n        'default-background',\n        'animation-time',\n        'drift-speed',\n        'drag-drift-speed',\n        'default-show-top-bar',\n        'swipe-sensitivity',\n        'swipe-friction',\n        'cycle-width-steps',\n        'cycle-height-steps',\n        'maximize-width-percent',\n        'maximize-within-tiling',\n        'minimap-scale',\n        'edge-preview-enable',\n        'edge-preview-scale',\n        'edge-preview-click-enable',\n        'edge-preview-timeout-enable',\n        'edge-preview-timeout',\n        'edge-preview-timeout-continual',\n        'window-switcher-preview-scale',\n        'winprops',\n        'show-workspace-indicator',\n        'show-window-position-bar',\n        'show-focus-mode-icon',\n        'show-open-position-icon',\n        'topbar-mouse-scroll-enable',\n        'disable-topbar-styling',\n        'default-focus-mode',\n        'gesture-enabled',\n        'gesture-horizontal-fingers',\n        'gesture-workspace-fingers',\n        'open-window-position',\n        'overview-ensure-viewport-animation',\n        'overview-min-windows-per-row',\n        'overview-max-window-scale',\n        'minimap-shade-opacity',\n        'selection-border-size',\n        'selection-border-radius-top',\n        'selection-border-radius-bottom',\n        'open-window-position-option-right',\n        'open-window-position-option-left',\n        'open-window-position-option-start',\n        'open-window-position-option-end',\n        'open-window-position-option-down',\n        'open-window-position-option-up',\n    ]\n        .forEach(k => setState(null, k));\n    prefs.__defineGetter__(\"minimum_margin\", () => {\n        return Math.min(15, prefs.horizontal_margin);\n    });\n    gsettings.connect('changed', setState);\n\n    // connect to settings and update winprops array when it's updated\n    gsettings.connect('changed::winprops', () => reloadWinpropsFromGSettings());\n\n    // A intermediate window is created before the prefs dialog is created.\n    // Prevent it from being inserted into the tiling causing flickering and general disorder\n    defwinprop({\n        wm_class: \"Gnome-shell-extension-prefs\",\n        scratch_layer: true,\n        focus: true,\n    });\n    defwinprop({\n        wm_class: /gnome-screenshot/i,\n        scratch_layer: true,\n        focus: true,\n    });\n\n    addWinpropsFromGSettings();\n}\n\nexport function disable() {\n    gsettings = null;\n    acceleratorParse = null;\n    _overriddingConflicts = null;\n    prefs = null;\n    conflictSettings = null;\n}\n\nexport function setState($, key) {\n    let value = gsettings.get_value(key);\n    let name = key.replace(/-/g, '_');\n    prefs[name] = value.deep_unpack();\n}\n\nexport let conflictSettings; // exported\nexport function getConflictSettings() {\n    if (!conflictSettings) {\n        // Schemas that may contain conflicting keybindings\n        conflictSettings = [];\n        addSchemaToConflictSettings('org.gnome.mutter.keybindings');\n        addSchemaToConflictSettings('org.gnome.mutter.wayland.keybindings');\n        addSchemaToConflictSettings('org.gnome.desktop.wm.keybindings');\n        addSchemaToConflictSettings('org.gnome.shell.keybindings');\n\n        // below schemas are checked but may not exist in all distributions\n        addSchemaToConflictSettings('org.gnome.settings-daemon.plugins.media-keys', false);\n        // ubuntu tiling-assistant (enabled by default on Ubuntu 23.10)\n        addSchemaToConflictSettings('org.gnome.shell.extensions.tiling-assistant', false);\n    }\n\n    return conflictSettings;\n}\n\n/**\n * Adds a Gio.Settings object to conflictSettings.  Fails gracefully.\n * @param {Gio.Settings} schemaId\n */\nexport function addSchemaToConflictSettings(schemaId, warn = true) {\n    try {\n        conflictSettings.push(new Gio.Settings({ schema_id: schemaId }));\n    }\n    catch (e) {\n        if (warn) {\n            console.warn(`Invalid schema_id '${schemaId}': could not add to keybind conflict checks`);\n        }\n    }\n}\n\n// / Keybindings\n\nexport function accelerator_parse(keystr) {\n    return acceleratorParse.accelerator_parse(keystr);\n}\n\n/**\n * Two keystrings can represent the same key combination\n */\nexport function keystrToKeycombo(keystr) {\n    // Above_Tab is a fake keysymbol provided by mutter\n    let aboveTab = false;\n    if (keystr.match(/Above_Tab/) || keystr.match(/grave/)) {\n        keystr = keystr.replace('Above_Tab', 'a');\n        aboveTab = true;\n    }\n\n    let [, key, mask] = accelerator_parse(keystr);\n    if (aboveTab)\n        key = META_KEY_ABOVE_TAB;\n    return `${key}|${mask}`; // Since js doesn't have a mapable tuple type\n}\n\nexport function generateKeycomboMap(settings) {\n    let map = {};\n    for (let name of settings.list_keys()) {\n        let value = settings.get_value(name);\n        if (value.get_type_string() !== 'as')\n            continue;\n\n        for (let combo of value.deep_unpack().map(keystrToKeycombo)) {\n            if (combo === '0|0')\n                continue;\n            if (map[combo]) {\n                map[combo].push(name);\n            } else {\n                map[combo] = [name];\n            }\n        }\n    }\n    return map;\n}\n\nexport function findConflicts(schemas) {\n    schemas = schemas || getConflictSettings();\n    let conflicts = [];\n    const paperMap = generateKeycomboMap(keybindSettings);\n\n    for (let settings of schemas) {\n        const against = generateKeycomboMap(settings);\n        for (let combo in paperMap) {\n            if (against[combo]) {\n                conflicts.push({\n                    name: paperMap[combo][0],\n                    conflicts: against[combo],\n                    settings, combo,\n                });\n            }\n        }\n    }\n    return conflicts;\n}\n\n/**\n * Returns / reconstitutes saved overrides list.\n */\nexport function getSavedOverrides() {\n    let saveListJson = gsettings.get_string(RESTORE_KEYBINDS_KEY);\n    let saveList;\n    try {\n        saveList = new Map(Object.entries(JSON.parse(saveListJson)));\n    } catch (error) {\n        saveList = new Map();\n    }\n    return saveList;\n}\n\n/**\n * Saves an overrides list.\n */\nexport function saveOverrides(overrides) {\n    gsettings.set_string(RESTORE_KEYBINDS_KEY, JSON.stringify(Object.fromEntries(overrides)));\n}\n\nexport function conflictKeyChanged(settings, key) {\n    if (_overriddingConflicts) {\n        return;\n    }\n\n    const newKeybind = settings.get_value(key).deep_unpack();\n    if (Array.isArray(newKeybind) && newKeybind.length === 0) {\n        return;\n    }\n\n    const saveList = getSavedOverrides();\n    saveList.delete(key);\n    saveOverrides(saveList);\n\n    // check for new conflicts\n    return overrideConflicts(key);\n}\n\n/**\n * Override conflicts and save original values for restore.\n */\nexport function overrideConflicts(checkKey = null) {\n    if (_overriddingConflicts) {\n        return;\n    }\n\n    _overriddingConflicts = true;\n    let saveList = getSavedOverrides();\n\n    // restore orignal keybinds prior to conflict overriding\n    restoreConflicts();\n\n    let disableAll = [];\n    const foundConflicts = findConflicts();\n    for (let conflict of foundConflicts) {\n        // save conflicts (list of names of conflicting keybinds)\n        let { conflicts, settings } = conflict;\n\n        conflicts.forEach(c => {\n            // get current value\n            const keybind = settings.get_value(c);\n            saveList.set(c, {\n                bind: JSON.stringify(keybind.deep_unpack()),\n                schema_id: settings.schema_id,\n            });\n\n            // now disable conflict\n            disableAll.push(() => settings.set_value(c, new GLib.Variant('as', [])));\n        });\n    }\n\n    // save override list\n    saveOverrides(saveList);\n\n    // now disable all conflicts\n    disableAll.forEach(d => d());\n    _overriddingConflicts = false;\n\n    return checkKey ? saveList.has(checkKey) : false;\n}\n\n/**\n * Update overrides to their current keybinds.\n */\nexport function updateOverrides() {\n    let saveList = getSavedOverrides();\n    saveList.forEach((saved, key) => {\n        const settings = getConflictSettings().find(s => s.schema_id === saved.schema_id);\n        if (settings) {\n            const newKeybind = settings.get_value(key).deep_unpack();\n            if (Array.isArray(newKeybind) && newKeybind.length === 0) {\n                return;\n            }\n\n            saveList.set(key, {\n                bind: JSON.stringify(newKeybind),\n                schema_id: settings.schema_id,\n            });\n        }\n    });\n\n    // save override list\n    saveOverrides(saveList);\n}\n\n/**\n * Restores previously overridden conflicts.\n */\nexport function restoreConflicts() {\n    let saveList = getSavedOverrides();\n    const toRemove = [];\n    saveList.forEach((saved, key) => {\n        const settings = getConflictSettings().find(s => s.schema_id === saved.schema_id);\n        if (settings) {\n            const keybind = JSON.parse(saved.bind);\n            toRemove.push({ key, remove: () => settings.set_value(key, new GLib.Variant('as', keybind)) });\n        }\n    });\n\n    // now remove retored keybinds from list\n    toRemove.forEach(r => {\n        r.remove();\n        saveList.delete(r.key);\n    });\n    saveOverrides(saveList);\n}\n\n// / Winprops\n\n/**\n   Modelled after notion/ion3's system\n\n   Examples:\n\n   defwinprop({\n     wm_class: \"Riot\",\n     scratch_layer: true\n   })\n*/\nexport let winprops = [];\nexport function winprop_match_p(meta_window, prop) {\n    let wm_class = meta_window.wm_class || \"\";\n    let title = meta_window.title;\n    if (prop.wm_class) {\n        if (prop.wm_class instanceof RegExp) {\n            if (!wm_class.match(prop.wm_class))\n                return false;\n        } else if (prop.wm_class !== wm_class) {\n            return false;\n        }\n    }\n    if (prop.title) {\n        if (prop.title instanceof RegExp) {\n            if (!title.match(prop.title))\n                return false;\n        } else if (prop.title !== title)\n            return false;\n    }\n\n    return true;\n}\n\nexport function find_winprop(meta_window)  {\n    // sort by title first (prioritise title over wm_class)\n    let props = winprops.filter(winprop_match_p.bind(null, meta_window));\n\n    // if matching props found, return first one\n    if (props.length > 0) {\n        return props[0];\n    }\n\n    // fall back, if star (catch-all) winprop exists, return the first one\n    let starProps = winprops.filter(w => w.wm_class === \"*\" || w.title === \"*\");\n    if (starProps.length > 0) {\n        return starProps[0];\n    }\n\n    return null;\n}\n\nexport function defwinprop(spec) {\n    // process preferredWidth - expects inputs like 50% or 400px\n    if (spec.preferredWidth) {\n        spec.preferredWidth = {\n            // value is first contiguous block of digits\n            // eslint-disable-next-line no-new-wrappers\n            value: new Number((spec.preferredWidth.match(/\\d+/) ?? ['0'])[0]),\n            // unit is first contiguous block of apha chars or % char\n            unit: (spec.preferredWidth.match(/[a-zA-Z%]+/) ?? ['NO_UNIT'])[0],\n        };\n    }\n\n    /**\n     * we order specs with gsettings rirst ==> gsetting winprops take precedence\n     * over winprops defined in user.js.  This was done since gsetting winprops\n     * are easier to add/remove (and can be added/removed/edited instantly without\n     * restarting shell).\n     */\n    // add winprop\n    winprops.push(spec);\n\n    // now order winprops with gsettings first, then title over wm_class\n    winprops.sort((a, b) => {\n        let firstresult = 0;\n        if (a.gsetting && !b.gsetting) {\n            firstresult = -1;\n        }\n        else if (!a.gsetting && b.gsetting) {\n            firstresult = 1;\n        }\n\n        // second compare, prioritise title\n        let secondresult = 0;\n        if (a.title && !b.title) {\n            secondresult = -1;\n        }\n        else if (!a.title && b.title) {\n            secondresult = 1;\n        }\n\n        return firstresult || secondresult;\n    });\n}\n\n/**\n * Adds user-defined winprops from gsettings (as defined in\n * org.gnome.shell.extensions.paperwm.winprops) to the winprops array.\n */\nexport function addWinpropsFromGSettings() {\n    // add gsetting (user config) winprops\n    gsettings.get_value('winprops').deep_unpack()\n        .map(value => JSON.parse(value))\n        .forEach(prop => {\n            // test if wm_class or title is a regex expression\n            if (/^\\/.+\\/[igmsuy]*$/.test(prop.wm_class)) {\n                // extract inner regex and flags from wm_class\n                let matches = prop.wm_class.match(/^\\/(.+)\\/([igmsuy]*)$/);\n                let inner = matches[1];\n                let flags = matches[2];\n                prop.wm_class = new RegExp(inner, flags);\n            }\n            if (/^\\/.+\\/[igmsuy]*$/.test(prop.title)) {\n                // extract inner regex and flags from title\n                let matches = prop.title.match(/^\\/(.+)\\/([igmsuy]*)$/);\n                let inner = matches[1];\n                let flags = matches[2];\n                prop.title = new RegExp(inner, flags);\n            }\n            prop.gsetting = true; // set property that is from user gsettings\n            defwinprop(prop);\n        });\n}\n\n/**\n * Removes winprops with the `gsetting:true` property from the winprops array.\n */\nexport function removeGSettingWinpropsFromArray() {\n    winprops = winprops.filter(prop => !prop.gsetting ?? true);\n}\n\n/**\n * Effectively reloads winprops from gsettings.\n * This is a convenience function which removes gsetting winprops from winprops\n * array and then adds the currently defined\n * org.gnome.shell.extensions.paperwm.winprops winprops.\n */\nexport function reloadWinpropsFromGSettings() {\n    removeGSettingWinpropsFromArray();\n    addWinpropsFromGSettings();\n}\n"
        },
        {
          "name": "shell.nix",
          "type": "blob",
          "size": 0.076171875,
          "content": "with import <nixpkgs> {};\n\nrunCommand \"shell\" {\nbuildInputs = [ glib ];\n} \"\"\n\n"
        },
        {
          "name": "shell.sh",
          "type": "blob",
          "size": 0.974609375,
          "content": "#!/usr/bin/env bash\n\n# Simple helper script to start nested wayland/x11 gnome sessions\n\n# The new dbus address is copied into the clipboard so you're able to run\n# `M-x # gnome-shell-set-dbus-address` and paste the address.\n\nold_display=$DISPLAY\n\nd=0\nwhile [ -e /tmp/.X11-unix/X${d} ]; do\n    d=$((d + 1))\ndone\n\nNEW_DISPLAY=:$d\n\nexport XDG_CONFIG_HOME=$HOME/paperwm/.config\n\nargs=()\n\nDISPLAY=$NEW_DISPLAY\neval $(dbus-launch --exit-with-session --sh-syntax)\necho $DBUS_SESSION_BUS_ADDRESS\n\necho -n $DBUS_SESSION_BUS_ADDRESS \\\n    | DISPLAY=$old_display xclip -i -selection clipboard\n\nDISPLAY=$old_display\ncase $1 in\n    w*|-w*|--w*)\n        echo \"Running Wayland Gnome Shell\"\n        args=(--nested --wayland)\n        ;;\n    *)\n        echo \"Running X11 Gnome Shell\"\n        Xephyr $NEW_DISPLAY &\n        DISPLAY=$NEW_DISPLAY\n        args=--x11\n        ;;\nesac\n\n\ndconf reset -f /  # Reset settings\ndconf write /org/gnome/shell/enabled-extensions \"['paperwm@paperwm.github.com']\"\n\ngnome-shell $args\n\n"
        },
        {
          "name": "stackoverlay.js",
          "type": "blob",
          "size": 15.587890625,
          "content": "import Clutter from 'gi://Clutter';\nimport GLib from 'gi://GLib';\nimport Meta from 'gi://Meta';\nimport Shell from 'gi://Shell';\nimport St from 'gi://St';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as PointerWatcher from 'resource:///org/gnome/shell/ui/pointerWatcher.js';\n\nimport { Settings, Utils, Tiling, Grab, Scratch } from './imports.js';\n\n/*\n  The stack overlay decorates the top stacked window with its icon and\n  captures mouse input such that a mouse click only _activates_ the\n  window. A very limited portion of the window is visible and due to\n  the animation the button-up event will be triggered at an\n  unpredictable position\n\n  See #10\n*/\n\n/*\n  Parent of the overlay?\n\n  Most natural parent is the window actor, but then the overlay\n  becomes visible in the clones too.\n\n  Since the stacked windows doesn't really move it's not a big problem\n  that the overlay doesn't track the window. The main challenge with\n  using a different parent becomes controlling the \"z-index\".\n\n  If I understand clutter correctly that can only be done by managing\n  the order of the scene graph nodes. Descendants of node A will thus\n  always be drawn in the same plane compared to a non-descendants.\n\n  The overlay thus have to be parented to `global.window_group`. One\n  would think that was ok, but unfortunately mutter keeps syncing the\n  window_group with the window stacking and in the process destroy the\n  stacking of any non-window actors.\n\n  Adding a \"clutter restack\" to the `MetaScreen` `restacked` signal\n  seems keep the stacking in sync (without entering into infinite\n  restack loops)\n*/\n\nlet pointerWatch, previewPointerWatcher;\nexport function enable(_extension) {\n\n}\n\nexport function disable() {\n    previewPointerWatcher?.remove();\n    previewPointerWatcher = null;\n    disableMultimonitorSupport();\n}\n\n/**\n * Checks for multiple monitors and if so, then enables multimonitor\n * support in PaperWM.\n */\nexport function multimonitorSupport() {\n    // if only one monitor, return\n    if (Tiling.spaces.monitors?.size > 1) {\n        enableMultimonitorSupport();\n    }\n    else {\n        disableMultimonitorSupport();\n    }\n}\n\nexport function enableMultimonitorSupport() {\n    pointerWatch = PointerWatcher.getPointerWatcher().addWatch(100,\n        () => {\n            // if overview return\n            if (Main.overview.visible) {\n                return;\n            }\n\n            const monitor = Utils.monitorAtCurrentPoint();\n            const space = Tiling.spaces.monitors.get(monitor);\n\n            // same space\n            if (space === Tiling.spaces.activeSpace) {\n                return;\n            }\n\n            // check if in the midst of a window resize action\n            if (Tiling.inGrab &&\n                Tiling.inGrab instanceof Grab.ResizeGrab) {\n                const window = global.display?.focus_window;\n                if (window) {\n                    Scratch.makeScratch(window);\n                }\n                return;\n            }\n\n            // if drag/grabbing window, do simple activate\n            if (Tiling.inGrab) {\n                space?.activate(false, false);\n                return;\n            }\n\n            const selected = space?.selectedWindow;\n            space?.activateWithFocus(selected, false, false);\n        });\n    console.debug('paperwm multimonitor support is ENABLED');\n}\n\nexport function disableMultimonitorSupport() {\n    pointerWatch?.remove();\n    pointerWatch = null;\n    console.debug('paperwm multimonitor support is DISABLED');\n}\n\nexport function createAppIcon(metaWindow, size) {\n    let tracker = Shell.WindowTracker.get_default();\n    let app = tracker.get_window_app(metaWindow);\n    let appIcon = app ? app.create_icon_texture(size)\n        : new St.Icon({\n            icon_name: 'icon-missing',\n            icon_size: size,\n        });\n    appIcon.x_expand = appIcon.y_expand = true;\n    appIcon.x_align = appIcon.y_align = Clutter.ActorAlign.END;\n\n    return appIcon;\n}\n\nexport class ClickOverlay {\n    constructor(monitor, onlyOnPrimary) {\n        this.monitor = monitor;\n        this.onlyOnPrimary = onlyOnPrimary;\n        this.left = new StackOverlay(Meta.MotionDirection.LEFT, monitor);\n        this.right = new StackOverlay(Meta.MotionDirection.RIGHT, monitor);\n    }\n\n    reset() {\n        this.left.setTarget(null);\n        this.right.setTarget(null);\n    }\n\n    hide() {\n        this.left.overlay.hide();\n        this.right.overlay.hide();\n    }\n\n    show() {\n        if (Main.overview.visible)\n            return;\n        this.left.overlay.show();\n        this.right.overlay.show();\n    }\n\n    destroy() {\n        for (let overlay of [this.left, this.right]) {\n            let actor = overlay.overlay;\n            overlay.signals.destroy();\n            overlay.signals = null;\n            if (overlay.clone) {\n                overlay.clone.destroy();\n                overlay.clone = null;\n            }\n            actor.destroy();\n        }\n    }\n}\n\nexport class StackOverlay {\n    constructor(direction, monitor) {\n        this.SHOW_DELAY = 100;\n\n        this._direction = direction;\n\n        const overlay = new Clutter.Actor({\n            reactive: true,\n            name: \"stack-overlay\",\n        });\n\n        // Uncomment to debug the overlays\n        // overlay.background_color = Utils.color_from_string('green')[1];\n        // overlay.opacity = 100;\n\n        this.monitor = monitor;\n        const panelBox = Main.layoutManager.panelBox;\n        overlay.y = monitor.y + panelBox.height + Settings.prefs.vertical_margin;\n        overlay.height = this.monitor.height - panelBox.height - Settings.prefs.vertical_margin;\n        overlay.width = Tiling.stack_margin;\n\n        this.signals = new Utils.Signals();\n\n        // preview timeouts\n        this.triggerPreviewTimeout = null;\n        this.showPreviewTimeout = null;\n        this.activatePreviewTimeout = null;\n\n        this.signals.connect(overlay, 'button-press-event', () => {\n            if (!Settings.prefs.edge_preview_enable) {\n                return;\n            }\n\n            if (!Settings.prefs.edge_preview_click_enable) {\n                return;\n            }\n\n            this._activateTarget();\n        });\n\n        this.signals.connect(overlay, 'enter-event', () => this.triggerPreview());\n        this.signals.connect(overlay, 'leave-event', () => this.removePreview());\n\n        global.window_group.add_child(overlay);\n        Main.layoutManager.trackChrome(overlay);\n\n        this.overlay = overlay;\n        this.setTarget(null);\n    }\n\n    _activateTarget() {\n        Main.activateWindow(this.target);\n        // remove/cleanup the previous preview\n        this.removePreview();\n\n        // if pointer is still at edge (within 2px), trigger preview\n        this.triggerPreviewTimeout = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT,\n            (Settings.prefs.animation_time * 1000) + 50,\n            () => {\n                if (this._pointerIsAtEdge()) {\n                    this.triggerPreview(true);\n                }\n\n                this.triggerPreviewTimeout = null;\n                return false; // on return false destroys timeout\n            });\n    }\n\n    /**\n     * Returns true if pointer x position is at monitor edge.\n     * @returns Boolean\n     */\n    _pointerIsAtEdge() {\n        const [x] = global.get_pointer();\n        switch (this._direction) {\n        case Meta.MotionDirection.LEFT:\n            if (\n                x >= this.monitor.x &&\n                x <= this.monitor.x + 2\n            ) {\n                return true;\n            }\n            break;\n        case Meta.MotionDirection.RIGHT:\n            if (\n                x <= this.monitor.x + this.monitor.width &&\n                x >= this.monitor.x + this.monitor.width - 2\n            ) {\n                return true;\n            }\n            break;\n        }\n\n        return false;\n    }\n\n    /**\n     * Triggers edge window preview.\n     * @param {Boolean} postActivatePreview: true if an auto preview after previous activation\n     * @returns\n     */\n    triggerPreview(postActivatePreview = false) {\n        if (!Settings.prefs.edge_preview_enable) {\n            return;\n        }\n\n        if (this.showPreviewTimeout) {\n            return;\n        }\n\n        if (!this.target) {\n            return;\n        }\n\n        // create pointerwatcher to ensure preview is removed\n        previewPointerWatcher?.remove();\n        previewPointerWatcher = PointerWatcher.getPointerWatcher().addWatch(200, () => {\n            if (!this._pointerIsAtEdge()) {\n                this.removePreview();\n                previewPointerWatcher?.remove();\n                previewPointerWatcher = null;\n            }\n        });\n\n        this.showPreviewTimeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, this.SHOW_DELAY, () => {\n            this.removePreview();\n            this.showPreview();\n            this.showPreviewTimeout = null;\n\n            // activate preview on timeout\n            if (Settings.prefs.edge_preview_timeout_enable) {\n                // if no continual activation\n                if (postActivatePreview &&\n                    !Settings.prefs.edge_preview_timeout_continual) {\n                    // check have a target\n                    if (!this.target) {\n                        return;\n                    }\n\n                    // push pointer back\n                    let [, py] = global.get_pointer();\n                    const offset = 3;\n                    let x;\n                    switch (this._direction) {\n                    case Meta.MotionDirection.LEFT:\n                        x = this.monitor.x + offset;\n                        break;\n                    case Meta.MotionDirection.RIGHT:\n                        x = this.monitor.x + this.monitor.width - offset;\n                        break;\n                    }\n                    Utils.warpPointer(\n                        x,\n                        py,\n                        false\n                    );\n                    return;\n                }\n\n                this.activatePreviewTimeout = GLib.timeout_add(\n                    GLib.PRIORITY_DEFAULT,\n                    Settings.prefs.edge_preview_timeout, () => {\n                        // check if still at edge\n                        if (this._pointerIsAtEdge()) {\n                            this._activateTarget();\n                        }\n                    });\n            }\n\n            return false; // on return false destroys timeout\n        });\n    }\n\n    removePreview() {\n        if (this.showPreviewTimeout) {\n            Utils.timeout_remove(this.showPreviewTimeout);\n            this.showPreviewTimeout = null;\n        }\n\n        if (this.clone) {\n            this.clone.destroy();\n            this.clone = null;\n        }\n    }\n\n    /**\n     * Shows the window preview in from the side it was triggered on.\n     */\n    showPreview() {\n        // only show if have valid scale\n        const scale = Settings.prefs.edge_preview_scale;\n        if (scale <= 0) {\n            return;\n        }\n\n        // don't show if window grabbed\n        if (Grab.grabbed) {\n            return;\n        }\n\n        /**\n         * if timeout is enabled, only show if valid timeout (e.g. if SHOW_DELAY <= timeout,\n         * then won't see the preview anyway).\n         */\n        if (Settings.prefs.edge_preview_timeout_enable &&\n            Settings.prefs.edge_preview_timeout <= this.SHOW_DELAY\n        ) {\n            return;\n        }\n\n        let [x, y] = global.get_pointer();\n        const actor = this.target.get_compositor_private();\n        const clone = new Clutter.Clone({ source: actor });\n        this.clone = clone;\n\n        // Remove any window clips, and show the metaWindow.clone's\n        actor.remove_clip();\n        Tiling.animateWindow(this.target);\n\n        // set clone parameters\n        clone.opacity = 255 * 0.95;\n\n        clone.set_scale(scale, scale);\n        Main.uiGroup.add_child(clone);\n\n        const monitor = this.monitor;\n        const scaleWidth = scale * clone.width;\n        const scaleHeight = scale * clone.height;\n        if (this._direction === Meta.MotionDirection.RIGHT) {\n            x = monitor.x + monitor.width - scaleWidth;\n        }\n        else {\n            x = monitor.x;\n        }\n\n        // calculate y position - center of mouse\n        y -= (scale * clone.height) / 2;\n\n        // bound to remain within view\n        const workArea = this.getWorkArea();\n        y = Math.max(y, workArea.y);\n        y = Math.min(y, workArea.y + workArea.height - scaleHeight);\n\n        clone.set_position(x, y);\n    }\n\n    setTarget(space, index) {\n        this.removePreview();\n\n        let bail = () => {\n            this.target = null;\n            this.overlay.width = 0;\n            return false;\n        };\n\n        if (space === null || Tiling.inPreview) {\n            // No target. Eg. if we're at the left- or right-most window\n            return bail();\n        }\n\n        let mru = global.display.get_tab_list(Meta.TabList.NORMAL_ALL,\n            space.workspace);\n        let column = space[index];\n        this.target = mru.filter(w => column.includes(w))[0];\n        let metaWindow = this.target;\n        if (!metaWindow)\n            return;\n\n        let overlay = this.overlay;\n        overlay.y = this.monitor.y + Main.layoutManager.panelBox.height + Settings.prefs.vertical_margin;\n\n        // Assume the resize edge is at least this big (empirically found..)\n        const minResizeEdge = 8;\n\n        if (this._direction === Meta.MotionDirection.LEFT) {\n            let column = space[space.indexOf(metaWindow) + 1];\n            let neighbour = column &&\n                global.display.sort_windows_by_stacking(column).reverse()[0];\n\n            if (!neighbour)\n                return bail(); // Should normally have a neighbour. Bail!\n\n            let width = neighbour.clone.targetX + space.targetX - minResizeEdge;\n            if (space.isPlaceable(metaWindow) || Meta.is_wayland_compositor())\n                width = Math.min(width, 1);\n            overlay.x = this.monitor.x;\n            overlay.width = Math.max(width, 1);\n            Utils.actor_raise(overlay, neighbour.get_compositor_private());\n        } else {\n            let column = space[space.indexOf(metaWindow) - 1];\n            let neighbour = column &&\n                global.display.sort_windows_by_stacking(column).reverse()[0];\n            if (!neighbour)\n                return bail(); // Should normally have a neighbour. Bail!\n\n            let frame = neighbour.get_frame_rect();\n            frame.x = neighbour.clone.targetX + space.targetX;\n            let width = this.monitor.width - (frame.x + frame.width) - minResizeEdge;\n            if (space.isPlaceable(metaWindow) || Meta.is_wayland_compositor())\n                width = 1;\n            width = Math.max(width, 1);\n            overlay.x = this.monitor.x + this.monitor.width - width;\n            overlay.width = width;\n            Utils.actor_raise(overlay, neighbour.get_compositor_private());\n        }\n\n        if (space.selectedWindow.fullscreen || space.selectedWindow.maximized_vertically)\n            overlay.hide();\n        else\n            overlay.show();\n\n        return true;\n    }\n\n    destroy() {\n        Utils.timeout_remove(this.triggerPreviewTimeout);\n        this.triggerPreviewTimeout = null;\n\n        Utils.timeout_remove(this.showPreviewTimeout);\n        this.showPreviewTimeout = null;\n\n        Utils.timeout_remove(this.activatePreviewTimeout);\n        this.activatePreviewTimeout = null;\n\n        this.signals.destroy();\n        this.signals = null;\n        this.removePreview();\n\n        Main.layoutManager.untrackChrome(this.overlay);\n        this.overlay.destroy();\n    }\n\n    /**\n     * Convenience method to return WorkArea for current monitor.\n     * @returns WorkArea\n     */\n    getWorkArea() {\n        return Main.layoutManager.getWorkAreaForMonitor(this.monitor.index);\n    }\n}\n"
        },
        {
          "name": "stylesheet.css",
          "type": "blob",
          "size": 1.3779296875,
          "content": "/*\nNOTE: please update `./config/users.css` with any new styles added here.\n*/\n.background-clear {\n    background-color: rgba(0, 0, 0, 0);\n}\n\n.topbar-transparent-background {\n    background-color: rgba(0, 0, 0, 0.35);\n    box-shadow: none;\n}\n\n.space-workspace-indicator {\n    padding: 0 10px 0 0;\n    background-color: transparent;\n    border-image: none;\n    background-image: none;\n    border: none;\n}\n\n.space-focus-mode-icon {\n    icon-size: 16px;\n    padding: 0 18px 0 18px;\n    margin-left: 3px;\n    background-color: transparent;\n}\n\n.open-position-icon {\n    icon-size: 22px;\n    padding: 0;\n    background-color: transparent;\n}\n\n.focus-button-tooltip {\n    background-color: rgba(0, 0, 0, 0.8);\n    padding: 8px;\n    border-radius: 8px;\n    font-weight: 600;\n}\n\n.take-window-hint {\n    background-color: rgba(0, 0, 0, 0.8);\n    padding: 8px;\n    border-radius: 8px;\n}\n\n.workspace-icon-button {\n    -st-icon-style: symbolic;\n    border: none;\n    border-radius: 8px;\n    padding: 8px;\n}\n\n.workspace-icon-button StIcon {\n    icon-size: 16px;\n}\n\n.paperwm-minimap-selection {\n    border-radius: 8px;\n}\n\n.paperwm-clone-shade {\n    background-color: rgba(0, 0, 0, 0.7);\n    border-radius: 7px 7px 0px 0px;\n}\n\n.paperwm-window-position-bar-backdrop {\n    background-color: rgba(0, 0, 0, 0.35);\n}\n\n.paperwm-window-position-bar {\n    border: 0; /* disable border to calm it down a bit */\n    border-radius: 1px;\n}\n"
        },
        {
          "name": "tiling.js",
          "type": "blob",
          "size": 181.525390625,
          "content": "import Clutter from 'gi://Clutter';\nimport GDesktopEnums from 'gi://GDesktopEnums';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport Graphene from 'gi://Graphene';\nimport Meta from 'gi://Meta';\nimport St from 'gi://St';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\n\nimport {\n    Settings, Utils, Lib, Gestures, Navigator, Grab, Topbar, Scratch, Stackoverlay, Background\n} from './imports.js';\nimport { Easer } from './utils.js';\nimport { ClickOverlay } from './stackoverlay.js';\nimport { WorkspaceSettings } from './workspace.js';\n\nconst { signals: Signals } = imports;\nconst workspaceManager = global.workspace_manager;\nconst display = global.display;\n\n/** @type {Spaces} */\nexport let spaces;\n\nlet borderWidth = 8;\n\n// Mutter prevints windows from being placed further off the screen than 75 pixels.\nexport const stack_margin = 75;\n\n// Some features use this to determine if to sizes is considered equal. ie. `abs(w1 - w2) < sizeSlack`\nlet sizeSlack = 30;\n\nexport const PreviewMode = { NONE: 0, STACK: 1, SEQUENTIAL: 2 }; // export\nexport let inPreview = PreviewMode.NONE; // export\n\n// DEFAULT mode is normal/original PaperWM window focus behaviour\nexport const FocusModes = { DEFAULT: 0, CENTER: 1, EDGE: 2 }; // export\n\nexport const CycleWindowSizesDirection = { FORWARD: 0, BACKWARDS: 1 };\n\nexport const SlurpInsertPosition = { BOTTOM: 0, TOP: 1, ABOVE: 2, BELOW: 3 };\n\n/**\n   Scrolled and tiled per monitor workspace.\n\n   The tiling is composed of an array of columns. A column being an array of\n   MetaWindows. Ie. the type being [[MetaWindow]].\n\n   A Space also contains a visual representation of the tiling. The structure is\n   currently like this:\n\n   A @clip actor which spans the monitor and clips all its contents to the\n   monitor. The clip lives along side all other space's clips in an actor\n   spanning the whole global.workspaceManager\n\n   An @actor to hold everything that's visible, it contains a @background,\n   a @label and a @cloneContainer.\n\n   The @cloneContainer holds clones of all the tiled windows, it's clipped\n   by @cloneClip to avoid protruding into neighbouringing monitors.\n\n   The @border surrounds the outside of the monitor so is only visible when\n   using the workspace carousel.\n\n   Clones are necessary due to restrictions mutter places on MetaWindowActors.\n   WindowActors can only live in the `global.window_group` and can't be\n   moved reliably outside the monitor. We create a Clutter.Clone for every window which\n   live in @cloneContainer to avoid these problems. Scrolling to a window in\n   the tiling is then done by simply moving the @cloneContainer.\n\n   While eg. animating the cloneContainer WindowActors are all hidden, while the\n   clones are shown. When animation is done, the MetaWindows are moved to their\n   correct position and the WindowActors are shown.\n\n   The clones are also useful when constructing the workspace stack as it's\n   easier to scale and move the whole @actor in one go.\n\n   # Coordinate system\n\n   MetaWindows live in the stage (global) coordinate system. NB: This system\n   covers all monitors - a window positioned top-left in a monitor might have\n   non-zero coordinates.\n\n   The space (technically the @clip) has it's own coordinate system relative to\n   its monitor. Ie. 0,0 is the top-left corner of the monitor.\n\n   To transform a stage point to space coordinates: `space.actor.transform_stage_point(aX, aY)`\n */\n\nlet signals, backgroundGroup, grabSignals;\nlet gsettings, backgroundSettings, interfaceSettings;\nlet displayConfig;\nlet saveState;\nlet startupTimeoutId, timerId, fullscreenStartTimeout, stackSlurpTimeout, workspaceChangeTimeouts;\nlet monitorChangeTimeout, driftTimeout;\nlet workspaceSettings;\nexport let inGrab;\nexport function enable(extension) {\n    inGrab = false;\n\n    displayConfig = new Utils.DisplayConfig();\n    saveState = saveState ?? new SaveState();\n\n    gsettings = extension.getSettings();\n    backgroundSettings = new Gio.Settings({\n        schema_id: 'org.gnome.desktop.background',\n    });\n    interfaceSettings = new Gio.Settings({\n        schema_id: \"org.gnome.desktop.interface\",\n    });\n\n    signals = new Utils.Signals();\n    grabSignals = new Utils.Signals();\n\n    workspaceChangeTimeouts = []; // init array to hold timeouts\n\n    // setup actions on gap changes\n    let marginsGapChanged = () => {\n        Utils.timeout_remove(timerId);\n        timerId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 500, () => {\n            spaces.mru().forEach(space => {\n                space.layout(true, {\n                    callback: () => {\n                        const selected = spaces.activeSpace?.selectedWindow;\n                        allocateClone(selected);\n                    },\n                });\n            });\n            timerId = null;\n            return false; // on return false destroys timeout\n        });\n    };\n    gsettings.connect('changed::vertical-margin', marginsGapChanged);\n    gsettings.connect('changed::vertical-margin-bottom', marginsGapChanged);\n    gsettings.connect('changed::window-gap', marginsGapChanged);\n    const changedBorder = () => {\n        spaces.forEach(s => {\n            Settings.prefs.selection_border_size <= 0 ? s.hideSelection() : s.showSelection();\n            if (s.selectedWindow) {\n                allocateClone(s.selectedWindow);\n            }\n        });\n    };\n    gsettings.connect('changed::selection-border-size', changedBorder);\n    gsettings.connect('changed::selection-border-radius-top', changedBorder);\n    gsettings.connect('changed::selection-border-radius-bottom', changedBorder);\n\n    backgroundGroup = Main.layoutManager._backgroundGroup;\n\n    workspaceSettings = new WorkspaceSettings(extension);\n    spaces = new Spaces();\n    let initWorkspaces = () => {\n        try {\n            spaces.init();\n        } catch (e) {\n            console.error(e);\n        }\n\n        // Fix the stack overlay\n        spaces.mru().reverse().forEach(s => {\n            // if s.selectedWindow exists and is in view, then use option moveto: false\n            if (s.selectedWindow) {\n                let options = s.isFullyVisible(s.selectedWindow) ? { moveto: false } : { force: true };\n                ensureViewport(s.selectedWindow, s, options);\n            }\n            s.monitor.clickOverlay.show();\n        });\n        Topbar.fixTopBar();\n\n        // on idle update space topbar elements and name\n        Utils.later_add(Meta.LaterType.IDLE, () => {\n            spaces.forEach(s => {\n                s.setSpaceTopbarElementsVisible();\n                s.updateName();\n\n                /**\n                 * The below resolves https://github.com/paperwm/PaperWM/issues/758.\n                 */\n                const x = s.cloneContainer.x;\n                s.viewportMoveToX(0);\n                s.viewportMoveToX(x);\n            });\n        });\n    };\n\n    if (Main.layoutManager._startingUp) {\n        // Defer workspace initialization until existing windows are accessible.\n        // Otherwise we're unable to restore the tiling-order. (when restarting\n        // gnome-shell)\n        signals.connectOneShot(Main.layoutManager, 'startup-complete',\n            () => displayConfig.upgradeGnomeMonitors(initWorkspaces));\n    } else {\n        /**\n         * Upgrade gnome monitor info objects by add \"connector\" information, and\n         * when done (async) callback to initworkspaces.\n         */\n        // NOTE: this should happen after Patches.enable() have run, so we do\n        // it in a timeout\n        startupTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 0, () => {\n            displayConfig.upgradeGnomeMonitors(initWorkspaces);\n            startupTimeoutId = null;\n            return false; // on return false destroys timeout\n        });\n    }\n}\n\nexport function disable() {\n    Utils.timeout_remove(startupTimeoutId);\n    startupTimeoutId = null;\n    Utils.timeout_remove(timerId);\n    timerId = null;\n    Utils.timeout_remove(fullscreenStartTimeout);\n    fullscreenStartTimeout = null;\n    Utils.timeout_remove(stackSlurpTimeout);\n    stackSlurpTimeout = null;\n    workspaceChangeTimeouts?.forEach(t => Utils.timeout_remove(t));\n    workspaceChangeTimeouts = null;\n    Utils.timeout_remove(monitorChangeTimeout);\n    monitorChangeTimeout = null;\n    Utils.timeout_remove(driftTimeout);\n    driftTimeout = null;\n\n    grabSignals.destroy();\n    grabSignals = null;\n    signals.destroy();\n    signals = null;\n\n    saveState.prepare();\n    displayConfig.downgradeGnomeMonitors();\n    displayConfig = null;\n    spaces.destroy();\n    inGrab = null;\n    gsettings = null;\n    backgroundGroup = null;\n    backgroundSettings = null;\n    interfaceSettings = null;\n    workspaceSettings = null;\n}\n\n/**\n * Exported inGrab is read-only from other modules.\n * This method allows other modules to change inGrab.\n */\nexport function setInGrab(value) {\n    inGrab = value;\n}\n\nexport class Space extends Array {\n    /** @type {import('@gi-types/clutter10').Actor} */\n    actor;\n\n    /** @type {import('@gi-types/meta').BackgroundActor} */\n    background;\n\n    constructor(workspace, container, doInit) {\n        super(0);\n        this.workspace = workspace;\n        this.signals = new Utils.Signals();\n\n        // windows that should be represented by their WindowActor\n        this.visible = [];\n        this._floating = [];\n        this._populated = false;\n\n        // default focusMode (can be overriden by saved user pref in Space.init method)\n        this.focusMode = FocusModes.DEFAULT;\n        this.focusModeIcon = new Topbar.FocusIcon({\n            name: 'panel',\n            style_class: 'space-focus-mode-icon',\n        })\n            .setClickFunction(() => {\n                switchToNextFocusMode(this);\n            })\n            .setVisible(false); // hide by default\n        this.unfocusXPosition = null; // init\n\n        let clip = new Clutter.Actor({ name: \"clip\" });\n        this.clip = clip;\n        let actor = new Clutter.Actor({ name: \"space-actor\" });\n        actor.set_pivot_point(0.5, 0);\n\n        this._visible = true;\n        this.hide(); // We keep the space actor hidden when inactive due to performance\n\n        this.actor = actor;\n        let cloneClip = new Clutter.Actor({ name: \"clone-clip\" });\n        this.cloneClip = cloneClip;\n        let cloneContainer = new St.Widget({ name: \"clone-container\" });\n        this.cloneContainer = cloneContainer;\n\n        const workspaceIndicator = new St.Widget({\n            reactive: true,\n            name: 'panel',\n            style_class: 'space-workspace-indicator',\n        });\n        signals.connect(workspaceIndicator, 'button-press-event', () => Main.overview.toggle());\n        signals.connect(workspaceIndicator, 'scroll-event', (_actor, event) => {\n            const direction = event.get_scroll_direction();\n            switch (direction) {\n            case Clutter.ScrollDirection.DOWN:\n                spaces.selectSequenceSpace(Meta.MotionDirection.DOWN);\n                Navigator.getNavigator().finish();\n                return Clutter.EVENT_STOP;\n            case Clutter.ScrollDirection.UP:\n                spaces.selectSequenceSpace(Meta.MotionDirection.UP);\n                Navigator.getNavigator().finish();\n                return Clutter.EVENT_STOP;\n            default:\n                return Clutter.EVENT_STOP;\n            }\n        });\n        this.workspaceIndicator = workspaceIndicator;\n        const workspaceLabel = new St.Label();\n        workspaceIndicator.add_child(workspaceLabel);\n        this.workspaceLabel = workspaceLabel;\n        workspaceLabel.hide();\n\n        const selection = new St.Widget({\n            name: 'selection',\n            style_class: 'paperwm-selection tile-preview',\n        });\n        this.selection = selection;\n        // initial state is shown (unless border-size is 0)\n        if (Settings.prefs.selection_border_size <= 0) {\n            this.hideSelection();\n        }\n\n        clip.space = this;\n        cloneContainer.space = this;\n\n        container.add_child(clip);\n        clip.add_child(actor);\n        actor.add_child(workspaceIndicator);\n        actor.add_child(this.focusModeIcon);\n        actor.add_child(cloneClip);\n        cloneClip.add_child(cloneContainer);\n\n        this.border = new St.Widget({ name: \"border\" });\n        this.actor.add_child(this.border);\n        this.border.hide();\n\n        let monitor = Main.layoutManager.primaryMonitor;\n        const prevSpace = saveState.prevSpaces.get(workspace);\n        this.targetX = 0;\n        if (prevSpace && prevSpace.monitor) {\n            let prevMonitor = Main.layoutManager.monitors[prevSpace.monitor.index];\n            if (prevMonitor)\n                monitor = prevMonitor;\n        }\n\n        // init workspace settings from preferences\n        this.setSettings(workspaceSettings.getWorkspaceSettings(this.index));\n\n        this.selectedWindow = null;\n        this.leftStack = 0; // not implemented\n        this.rightStack = 0; // not implemented\n\n        this.windowPositionBarBackdrop = new St.Widget({\n            name: 'windowPositionBarBackdrop',\n            style_class: 'paperwm-window-position-bar-backdrop',\n            reactive: true,\n        });\n        signals.connect(this.windowPositionBarBackdrop, 'scroll-event', (_actor, event) => {\n            Topbar.topBarScrollAction(event);\n        });\n        this.windowPositionBar = new St.Widget({\n            name: 'windowPositionBar',\n            style_class: 'paperwm-window-position-bar tile-preview',\n        });\n        this.windowPositionBar.hide(); // default on empty space\n        Utils.actor_raise(this.windowPositionBar);\n\n        this.showPositionBar && this.enableWindowPositionBar();\n        this.showFocusModeIcon();\n\n        // now set monitor for this space\n        this.setMonitor(monitor);\n\n        if (doInit) {\n            this.init();\n        }\n    }\n\n    init() {\n        if (this._populated || Main.layoutManager._startingUp)\n            return;\n\n        let workspace = this.workspace;\n        let prevSpace = saveState.getPrevSpaceByUUID(this.uuid);\n        console.info(`restore by uuid: ${this.uuid}, prevSpace name: ${prevSpace?.name}`);\n\n        // get previous focus mode (if exists)\n        const focusMode = prevSpace?.focusMode;\n        this.addAll(prevSpace);\n        saveState.prevSpaces.delete(workspace);\n        this._populated = true;\n\n        // init window position bar and space topbar elements\n        this.windowPositionBarBackdrop.height = Topbar.panelBox.height;\n        this.setSpaceTopbarElementsVisible();\n\n        // restore focus mode (or fallback to default)\n        setFocusMode(focusMode ?? getDefaultFocusMode(), this);\n\n        this.getWindows().forEach(w => {\n            animateWindow(w);\n        });\n\n        this.layout(false);\n\n        this.signals.connect(workspace, \"window-added\", (ws, metawindow) => add_handler(ws, metawindow));\n        this.signals.connect(workspace, \"window-removed\", (ws, metawindow) => remove_handler(ws, metawindow));\n        this.signals.connect(Main.overview, 'showing', this.startAnimate.bind(this));\n        this.signals.connect(Main.overview, 'hidden', () => {\n            if (!spaces.isActiveSpace(this)) {\n                return;\n            }\n\n            // check if after hiding the mouse is on another monitor\n            const monitor = Utils.monitorAtCurrentPoint();\n            const space = spaces.monitors.get(monitor);\n\n            // if space is different, activate that one\n            if (this !== space) {\n                space?.activateWithFocus(space?.selectedWindow, false, false);\n            }\n\n            Utils.later_add(Meta.LaterType.IDLE, () => {\n                space.moveDone(() => {\n                    ensureViewport(display.focus_window, this, {\n                        moveto: true,\n                        force: true,\n                        ensureAnimation: Settings.prefs.overview_ensure_viewport_animation,\n                    });\n                });\n            });\n        });\n\n        this.signals.connect(gsettings, 'changed::default-focus-mode', () => {\n            setFocusMode(getDefaultFocusMode(), this);\n        });\n\n        this.signals.connect(interfaceSettings, \"changed::color-scheme\", this.updateBackground.bind(this));\n        this.signals.connect(gsettings, 'changed::default-background', this.updateBackground.bind(this));\n        this.signals.connect(gsettings, 'changed::use-default-background', this.updateBackground.bind(this));\n        this.signals.connect(backgroundSettings, 'changed::picture-uri', this.updateBackground.bind(this));\n        this.signals.connect(backgroundSettings, \"changed::picture-uri-dark\", this.updateBackground.bind(this));\n    }\n\n    /**\n     * Returns the space index (which is equivalent to the workspace index).\n     */\n    get index() {\n        return this.workspace.index();\n    }\n\n    /**\n     * Activates this space. Safer alternative to space.workspace.activate.  Also allows\n     * setting animation on workspaceSwitch.\n     * @param {Boolean} animate\n     */\n    activate(defaultAnimation = true, paperwmAnimation = false) {\n        spaces.space_defaultAnimation = defaultAnimation;\n        spaces.space_paperwmAnimation = paperwmAnimation;\n\n        this.workspace.activate(global.get_current_time());\n\n        spaces.space_defaultAnimation = true;\n        spaces.space_paperwmAnimation = false; // switch to default\n    }\n\n    /**\n     * Activates this space. Safer alternative to space.workspace.activate_with_focus. Also allows\n     * setting animation on workspaceSwitch.\n     * @param {Boolean} animate\n     */\n    activateWithFocus(metaWindow, defaultAnimation = true, paperwmAnimation = false) {\n        spaces.space_defaultAnimation = defaultAnimation;\n        spaces.space_paperwmAnimation = paperwmAnimation;\n\n        if (metaWindow) {\n            this.workspace.activate_with_focus(metaWindow, global.get_current_time());\n        }\n        else {\n            this.workspace.activate(global.get_current_time());\n        }\n        spaces.space_defaultAnimation = true;\n        spaces.space_paperwmAnimation = false; // switch to default\n    }\n\n    show() {\n        if (this._visible)\n            return;\n        this._visible = true;\n        this.clip.show();\n        for (let col of this) {\n            for (let w of col) {\n                let actor = w.get_compositor_private();\n                w.clone.cloneActor.source = actor;\n            }\n        }\n    }\n\n    hide() {\n        if (!this._visible)\n            return;\n        this._visible = false;\n        this.clip.hide();\n        for (let col of this)\n            for (let w of col)\n                w.clone.cloneActor.source = null;\n    }\n\n    /**\n     * Returns current workArea parameters for this space.\n     * @returns object with x, y, width, and height values for this WorkArea.\n     */\n    workArea() {\n        let workArea = Main.layoutManager.getWorkAreaForMonitor(this.monitor.index);\n        return {\n            x: workArea.x - this.monitor.x,\n            y: workArea.y - this.monitor.y + Settings.prefs.vertical_margin,\n            width: workArea.width,\n            height: workArea.height - Settings.prefs.vertical_margin - Settings.prefs.vertical_margin_bottom,\n        };\n    }\n\n    layoutGrabColumn(column, x, y0, targetWidth, availableHeight, time, grabWindow) {\n        let space = this;\n        let needRelayout = false;\n\n        function mosh(windows, height, y0) {\n            let targetHeights = fitProportionally(\n                windows.map(mw => mw.get_frame_rect().height),\n                height\n            );\n            let [, relayout, y] = space.layoutColumnSimple(windows, x, y0, targetWidth, targetHeights, time);\n            needRelayout = needRelayout || relayout;\n            return y;\n        }\n\n        const k = column.indexOf(grabWindow);\n        if (k < 0) {\n            throw new Error(`Anchor doesn't exist in column ${grabWindow.title}`);\n        }\n\n        const gap = Settings.prefs.window_gap;\n        const f = grabWindow.get_frame_rect();\n        let yGrabRel = f.y - this.monitor.y;\n        targetWidth = f.width;\n\n        const H1 = (yGrabRel - y0) - gap - (k - 1) * gap;\n        const H2 = availableHeight - (yGrabRel + f.height - y0) - gap - (column.length - k - 2) * gap;\n        k > 0 && mosh(column.slice(0, k), H1, y0);\n        let y = mosh(column.slice(k, k + 1), f.height, yGrabRel);\n        k + 1 < column.length && mosh(column.slice(k + 1), H2, y);\n\n        return [targetWidth, needRelayout];\n    }\n\n    layoutColumnSimple(windows, x, y0, targetWidth, targetHeights, time) {\n        let space = this;\n        let y = y0;\n\n        let widthChanged = false;\n        let heightChanged = false;\n\n        for (let i = 0; i < windows.length; i++) {\n            let mw = windows[i];\n            let targetHeight = targetHeights[i];\n\n            let f = mw.get_frame_rect();\n\n            let resizable = !mw.fullscreen &&\n                mw.get_maximized() !== Meta.MaximizeFlags.BOTH;\n\n            if (mw.preferredWidth) {\n                let prop = mw.preferredWidth;\n                if (prop.value <= 0) {\n                    console.warn(\"invalid preferredWidth value\");\n                }\n                else if (prop.unit === 'px') {\n                    targetWidth = prop.value;\n                }\n                else if (prop.unit === '%') {\n                    let availableWidth = space.workArea().width - Settings.prefs.horizontal_margin * 2 - Settings.prefs.window_gap;\n                    targetWidth = Math.floor(availableWidth * Math.min(prop.value / 100.0, 1.0));\n                }\n                else {\n                    console.warn(\"invalid preferredWidth unit:\", `'${prop.unit}'`, \"(should be 'px' or '%')\");\n                }\n            }\n\n            if (resizable) {\n                const hasNewTarget = mw._targetWidth !== targetWidth || mw._targetHeight !== targetHeight;\n                const targetReached = f.width === targetWidth && f.height === targetHeight;\n\n                // Update targets (NB: must happen before resize request)\n                mw._targetWidth = targetWidth;\n                mw._targetHeight = targetHeight;\n\n                if (!targetReached && hasNewTarget) {\n                    // Explanation for `hasNewTarget` check in commit message\n                    mw.move_resize_frame(true, f.x, f.y, targetWidth, targetHeight);\n                }\n            } else {\n                mw.move_frame(true, space.monitor.x, space.monitor.y);\n                targetWidth = f.width;\n                targetHeight = f.height;\n            }\n            if (mw.maximized_vertically) {\n                // NOTE: This should really be f.y - monitor.y, but eg. firefox\n                // on wayland reports the wrong y coordinates at this point.\n                y -= Settings.prefs.vertical_margin;\n            }\n\n            // When resize is synchronous, ie. for X11 windows\n            let nf = mw.get_frame_rect();\n            if (nf.width !== targetWidth && nf.width !== f.width) {\n                widthChanged = true;\n            }\n            if (nf.height !== targetHeight && nf.height !== f.height) {\n                heightChanged = true;\n                targetHeight = nf.height; // Use actually height for layout\n            }\n\n            let c = mw.clone;\n            if (c.x !== x || c.targetX !== x ||\n                c.y !== y || c.targetY !== y) {\n                // console.debug(\"  Position window\", mw.title, `y: ${c.targetY} -> ${y} x: ${c.targetX} -> ${x}`);\n                c.targetX = x;\n                c.targetY = y;\n                if (time === 0) {\n                    c.x = x;\n                    c.y = y;\n                } else {\n                    Easer.addEase(c, {\n                        x, y,\n                        time,\n                        onComplete: this.moveDone.bind(this),\n                    });\n                }\n            }\n\n            y += targetHeight + Settings.prefs.window_gap;\n        }\n        return [targetWidth, widthChanged || heightChanged, y];\n    }\n\n    layout(animate = true, options = {}) {\n        // Guard against recursively calling layout\n        if (!this._populated)\n            return;\n        if (this._inLayout)\n            return;\n\n        // option properties\n        const ensure = options?.ensure ?? true;\n        const allocators = options?.customAllocators;\n        const centerIfOne = options?.centerIfOne ?? true;\n        const callback = options?.callback;\n\n        this._inLayout = true;\n        this.startAnimate();\n\n        let time = Settings.prefs.animation_time;\n        let gap = Settings.prefs.window_gap;\n        let x = gap; // init (ensures autostart apps in particular start properly gapped)\n        let selectedIndex = this.selectedIndex();\n        let workArea = this.workArea();\n\n        // Happens on monitors-changed\n        if (workArea.width === 0) {\n            this._inLayout = false;\n            return;\n        }\n\n        /**\n         * If current window is fullscreened, then treat workarea as fullscreen (y = 0).\n         * This a \"flash of topbar spacing\") before consecutive layout call resolves.\n         */\n        const panelBoxHeight = Topbar.panelBox.height;\n        const primaryMonitor = Main.layoutManager.primaryMonitor;\n        switch (true) {\n        case this.selectedWindow?.fullscreen:\n            workArea.y = 0;\n            this.setSpaceTopbarElementsVisible(false);\n            break;\n        case this.monitor === primaryMonitor: {\n            if (!this.showTopBar) {\n                // remove panelbox height\n                workArea.y -= panelBoxHeight;\n                workArea.height += panelBoxHeight;\n\n                if (this.showPositionBar) {\n                    // add panelbox height if need to show window position bar\n                    workArea.y += panelBoxHeight;\n                    workArea.height -= panelBoxHeight;\n                }\n            }\n            break;\n        }\n        default:\n            if (this.showPositionBar) {\n                workArea.y += panelBoxHeight;\n                workArea.height -= panelBoxHeight;\n            }\n            break;\n        }\n\n        let availableHeight = workArea.height;\n        let y0 = workArea.y;\n        let fixPointAttempCount = 0;\n\n        for (let i = 0; i < this.length; i++) {\n            let column = this[i];\n            // Actorless windows are trouble. Layout could conceivable run while a window is dying or being born.\n            column = column.filter(mw => mw.get_compositor_private());\n            if (column.length === 0)\n                continue;\n\n            // selected window in column\n            const selectedInColumn = i === selectedIndex ? this.selectedWindow : null;\n\n            let targetWidth;\n            if (selectedInColumn) {\n                // if selected window - use tiledWidth or frame.width (fallback)\n                targetWidth =\n                    selectedInColumn?._fullscreen_frame?.tiledWidth ??\n                    selectedInColumn.get_frame_rect().width;\n            }\n            else {\n                // otherwise get max of tiledWith or frame.with (fallback)\n                targetWidth = Math.max(...column.map(w => {\n                    return w?._fullscreen_frame?.tiledWidth ?? w.get_frame_rect().width;\n                }));\n            }\n\n            // enforce minimum\n            targetWidth = Math.min(targetWidth, workArea.width - 2 * Settings.prefs.minimum_margin);\n\n            let resultingWidth, relayout;\n            let allocator = allocators && allocators[i];\n            if (inGrab && column.includes(inGrab.window) && !allocator) {\n                [resultingWidth, relayout] =\n                    this.layoutGrabColumn(column, x, y0, targetWidth, availableHeight, time,\n                        selectedInColumn);\n            } else {\n                allocator = allocator || allocateDefault;\n                let targetHeights = allocator(column, availableHeight, selectedInColumn);\n                [resultingWidth, relayout] =\n                    this.layoutColumnSimple(column, x, y0, targetWidth, targetHeights, time);\n            }\n\n            if (relayout) {\n                if (fixPointAttempCount < 5) {\n                    i--;\n                    fixPointAttempCount++;\n                    continue;\n                } else {\n                    console.warn(\"Bail at fixpoint, max tries reached\");\n                }\n            }\n\n            x += resultingWidth + gap;\n        }\n        // final gap add - required to resolve https://github.com/paperwm/PaperWM/issues/684\n        x += gap;\n\n        this._inLayout = false;\n        let oldWidth = this.cloneContainer.width;\n        let min = workArea.x;\n        let auto = (this.targetX + oldWidth >= min + workArea.width && this.targetX <= 0) ||\n            this.targetX === min + Math.round((workArea.width - oldWidth) / 2);\n\n        // transforms break on width 1\n        let width = Math.max(1, x - gap);\n        this.cloneContainer.width = width;\n\n        if (auto && animate) {\n            if (width < workArea.width) {\n                this.targetX = min + Math.round((workArea.width - width) / 2);\n            } else if (this.targetX + width < min + workArea.width) {\n                this.targetX = min + workArea.width - width;\n            } else if (this.targetX > workArea.min) {\n                this.targetX = workArea.x;\n            }\n            Easer.addEase(this.cloneContainer,\n                {\n                    x: this.targetX,\n                    time,\n                    onComplete: this.moveDone.bind(this),\n                });\n        }\n        if (animate && ensure) {\n            ensureViewport(this.selectedWindow, this);\n        } else {\n            this.moveDone();\n        }\n\n        // if only one column on space, then center it\n        if (centerIfOne && this.length === 1) {\n            const mw = this.getWindows()[0];\n            centerWindow(mw);\n        }\n\n        callback && callback();\n\n        // save the last size frame (for use in restoring)\n        this.getWindows().forEach(w => {\n            w._last_layout_frame = w.get_frame_rect();\n        });\n\n        this.emit('layout', this);\n    }\n\n    queueLayout(animate = true, options = {}) {\n        if (this._layoutQueued)\n            return;\n        this._layoutQueued = true;\n\n        const laterType = options.laterType ?? Meta.LaterType.RESIZE;\n        Utils.later_add(laterType, () => {\n            this._layoutQueued = false;\n            this.layout(animate, options);\n        });\n    }\n\n    // Space.prototype.isVisible = function\n    isVisible(metaWindow, margin = 0) {\n        let clone = metaWindow.clone;\n        let x = clone.x + this.cloneContainer.x;\n        let workArea = this.workArea();\n        let min = workArea.x;\n\n        if (x - margin + clone.width < min ||\n            x + margin > min + workArea.width) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    isFullyVisible(metaWindow) {\n        let clone = metaWindow.clone;\n        let x = this.visibleX(metaWindow);\n        let workArea = this.workArea();\n        let min = workArea.x;\n\n        return min <= x && x + clone.width < min + workArea.width;\n    }\n\n    visibleRatio(metaWindow) {\n        let clone = metaWindow.clone;\n        let x = this.visibleX(metaWindow);\n        let workArea = this.workArea();\n        let min = workArea.x;\n        return min <= x && x + clone.width < min + workArea.width;\n    }\n\n    isPlaceable(metaWindow) {\n        let clone = metaWindow.clone;\n        let x = this.visibleX(metaWindow);\n        let workArea = Main.layoutManager.getWorkAreaForMonitor(this.monitor.index);\n        let min = workArea.x - this.monitor.x;\n\n        if (x + clone.width < min + stack_margin ||\n            x > min + workArea.width - stack_margin) {\n            return false;\n        } else {\n            // Fullscreen windows are only placeable on the monitor origin\n            if ((metaWindow.get_maximized() === Meta.MaximizeFlags.BOTH && x !== min) ||\n                (metaWindow.fullscreen && x !== 0)) {\n                return false;\n            }\n            return true;\n        }\n    }\n\n    getWindows() {\n        return this.reduce((ws, column) => ws.concat(column), []);\n    }\n\n    getWindow(index, row) {\n        if (row < 0 || index < 0 || index >= this.length)\n            return false;\n\n        let column = this[index];\n        if (row >= column.length)\n            return false;\n        return column[row];\n    }\n\n    isWindowAtPoint(metaWindow, x, y) {\n        let clone = metaWindow.clone;\n        let wX = clone.x + this.cloneContainer.x;\n        return x >= wX && x <= wX + clone.width &&\n            y >= clone.y && y <= clone.y + clone.height;\n    }\n\n    getWindowAtPoint(x, y) {\n        for (let column of this) {\n            for (let w of column) {\n                if (this.isWindowAtPoint(w, x, y))\n                    return w;\n            }\n        }\n        return null;\n    }\n\n    addWindow(metaWindow, index, row) {\n        if (!this.selectedWindow)\n            this.selectedWindow = metaWindow;\n        if (this.indexOf(metaWindow) !== -1)\n            return false;\n\n        if (row !== undefined && this[index]) {\n            let column = this[index];\n            column.splice(row, 0, metaWindow);\n        } else {\n            this.splice(index, 0, [metaWindow]);\n        }\n\n        /*\n         * Fix (still needed in 45) for bug where move_frame sometimes triggers\n         * another move back to its original position. Make sure tiled windows are\n         * always positioned correctly (synced with clone position).\n         */\n        this.signals.connect(metaWindow, 'position-changed', w => {\n            if (inGrab)\n                return;\n\n            let f = w.get_frame_rect();\n            let clone = w.clone;\n            let x = this.visibleX(w);\n            let y = this.monitor.y + clone.targetY;\n            x = Math.min(this.width - stack_margin, Math.max(stack_margin - f.width, x));\n            x += this.monitor.x;\n\n            // check if mismatch tracking needed, otherwise leave\n            if (f.x === x && f.y === y) {\n                // delete any mismatch counter (e.g. from previous attempt)\n                delete w._pos_mismatch_count;\n                return;\n            }\n\n            // guard against recursively calling this method\n            // see https://github.com/paperwm/PaperWM/issues/769\n            if (w._pos_mismatch_count &&\n                w._pos_mismatch_count > 1) {\n                console.warn(`clone/window position-changed recursive call: ${w.title}`);\n                return;\n            }\n\n            // mismatch detected\n            // move frame to ensure window position matches clone\n            try {\n                if (!w._pos_mismatch_count) {\n                    w._pos_mismatch_count = 0;\n                }\n                else {\n                    w._pos_mismatch_count += 1;\n                }\n                w.move_frame(true, x, y);\n            }\n            catch (ex) {\n\n            }\n        });\n\n        Utils.actor_reparent(metaWindow.clone, this.cloneContainer);\n\n        // Make sure the cloneContainer is in a clean state (centered) before layout\n        if (this.length === 1) {\n            let workArea = this.workArea();\n            this.targetX = workArea.x + Math.round((workArea.width - this.cloneContainer.width) / 2);\n        }\n        this.emit('window-added', metaWindow, index, row);\n        return true;\n    }\n\n    removeWindow(metaWindow) {\n        const index = this.indexOf(metaWindow);\n        if (index === -1)\n            return this.removeFloating(metaWindow);\n\n        this.signals.disconnect(metaWindow);\n\n        if (this.selectedWindow === metaWindow) {\n            // Select a new window using the stack ordering;\n            let windows = this.getWindows();\n            let i = windows.indexOf(metaWindow);\n            let neighbours = [windows[i - 1], windows[i + 1]].filter(w => w);\n            let stack = sortWindows(this, neighbours);\n            this.selectedWindow = stack[stack.length - 1];\n        }\n\n        const column = this[index];\n        const row = column.indexOf(metaWindow);\n        column.splice(row, 1);\n        if (column.length === 0) {\n            this.splice(index, 1);\n        }\n\n        this.visible.splice(this.visible.indexOf(metaWindow), 1);\n\n        const clone = metaWindow.clone;\n        // this.cloneContainer.remove_child(clone);\n        Utils.actor_remove_child(this.cloneContainer, clone);\n\n        // Don't destroy the selection highlight widget\n        if (clone.first_child.name === 'selection') {\n            // clone.remove_child(clone.first_child);\n            Utils.actor_remove_child(clone, clone.first_child);\n        }\n\n        const actor = metaWindow.get_compositor_private();\n        if (actor)\n            actor.remove_clip();\n\n        this.layout();\n        if (this.selectedWindow) {\n            ensureViewport(this.selectedWindow, this);\n        } else {\n            // can also be undefined here, will set to null explicitly\n            this.selectedWindow = null;\n        }\n\n        this.emit('window-removed', metaWindow, index, row);\n        return true;\n    }\n\n    isFloating(metaWindow) {\n        return this._floating.indexOf(metaWindow) !== -1;\n    }\n\n    addFloating(metaWindow) {\n        if (this._floating.indexOf(metaWindow) !== -1 ||\n            metaWindow.is_on_all_workspaces())\n            return false;\n        this._floating.push(metaWindow);\n        let clone = metaWindow.clone;\n        Utils.actor_reparent(clone, this.actor);\n        return true;\n    }\n\n    removeFloating(metaWindow) {\n        let i = this._floating.indexOf(metaWindow);\n        if (i === -1)\n            return false;\n        this._floating.splice(i, 1);\n        // this.actor.remove_child(metaWindow.clone);\n        Utils.actor_remove_child(this.actor, metaWindow.clone);\n        return true;\n    }\n\n    /**\n     * Returns true iff this space has a currently fullscreened window.\n     */\n    hasFullScreenWindow() {\n        return this.getWindows().some(w => w.fullscreen);\n    }\n\n    swap(direction, metaWindow) {\n        metaWindow = metaWindow || this.selectedWindow;\n\n        let [index, row] = this.positionOf(metaWindow);\n        let targetIndex = index;\n        let targetRow = row;\n        switch (direction) {\n        case Meta.MotionDirection.LEFT:\n            targetIndex--;\n            break;\n        case Meta.MotionDirection.RIGHT:\n            targetIndex++;\n            break;\n        case Meta.MotionDirection.DOWN:\n            targetRow++;\n            break;\n        case Meta.MotionDirection.UP:\n            targetRow--;\n            break;\n        }\n        let column = this[index];\n        if (targetIndex < 0 || targetIndex >= this.length ||\n            targetRow < 0 || targetRow >= column.length)\n            return;\n\n        Lib.swap(this[index], row, targetRow);\n        Lib.swap(this, index, targetIndex);\n\n        this.layout();\n        this.emit('swapped', index, targetIndex, row, targetRow);\n        ensureViewport(this.selectedWindow, this, { force: true });\n    }\n\n    switchLinear(dir, loop) {\n        let index = this.selectedIndex();\n        let column = this[index];\n        if (!column)\n            return false;\n        let row = column.indexOf(this.selectedWindow);\n        if (Lib.in_bounds(column, row + dir) === false) {\n            index += dir;\n            if (loop) {\n                if (index >= this.length) {\n                    index = 0;\n                } else if (index < 0) {\n                    index = this.length - 1;\n                }\n            }\n            if (dir === 1) {\n                if (index < this.length)\n                    row = 0;\n            } else if (index >= 0)\n                row = this[index].length - 1;\n        } else {\n            row += dir;\n        }\n\n        let metaWindow = this.getWindow(index, row);\n        ensureViewport(metaWindow, this);\n        return true;\n    }\n\n    switchLeft(loop) { return this.switch(Meta.MotionDirection.LEFT, loop); }\n    switchRight(loop) { return this.switch(Meta.MotionDirection.RIGHT, loop); }\n    switchUp(loop) { return this.switch(Meta.MotionDirection.UP, loop); }\n    switchDown(loop) { return this.switch(Meta.MotionDirection.DOWN, loop); }\n    switch(direction, loop) {\n        let space = this;\n        let index = space.selectedIndex();\n        if (index === -1) {\n            return false;\n        }\n        let row = space[index].indexOf(space.selectedWindow);\n        switch (direction) {\n        case Meta.MotionDirection.RIGHT:\n            index++;\n            row = -1;\n            break;\n        case Meta.MotionDirection.LEFT:\n            index--;\n            row = -1;\n        }\n        if (loop) {\n            if (index < 0) {\n                index = space.length - 1;\n            } else if (index >= space.length) {\n                index = 0;\n            }\n        } else if (index < 0 || index >= space.length) {\n            return false;\n        }\n\n        let column = space[index];\n\n        if (row === -1) {\n            let selected =\n                sortWindows(this, column)[column.length - 1];\n            row = column.indexOf(selected);\n        }\n\n        switch (direction) {\n        case Meta.MotionDirection.UP:\n            row--;\n            break;\n        case Meta.MotionDirection.DOWN:\n            row++;\n        }\n        if (loop) {\n            if (row < 0) {\n                row = column.length - 1;\n            } else if (row >= column.length) {\n                row = 0;\n            }\n        } else if (row < 0 || row >= column.length) {\n            return false;\n        }\n\n        let metaWindow = space.getWindow(index, row);\n        ensureViewport(metaWindow, space);\n\n        return true;\n    }\n\n    switchGlobalLeft() { this.switchGlobal(Meta.MotionDirection.LEFT); }\n    switchGlobalRight() { this.switchGlobal(Meta.MotionDirection.RIGHT); }\n    switchGlobalUp() { this.switchGlobal(Meta.MotionDirection.UP); }\n    switchGlobalDown() { this.switchGlobal(Meta.MotionDirection.DOWN); }\n    switchGlobal(direction) {\n        let space = this;\n        let index = space.selectedIndex();\n        if (index === -1) {\n            return;\n        }\n        let row = space[index].indexOf(space.selectedWindow);\n\n        switch (direction) {\n        case Meta.MotionDirection.RIGHT:\n            index++;\n            break;\n        case Meta.MotionDirection.LEFT:\n            index--;\n        }\n        if (index < 0 || index >= space.length) {\n            let monitor = focusMonitor();\n            let dir = index < 0\n                ? Meta.DisplayDirection.LEFT : Meta.DisplayDirection.RIGHT;\n            let i = display.get_monitor_neighbor_index(monitor.index, dir);\n            if (i === -1)\n                return;\n\n            let newMonitor = Main.layoutManager.monitors[i];\n            space = spaces.monitors.get(newMonitor);\n            if (dir === Meta.DisplayDirection.LEFT) {\n                index = space.length - 1;\n            } else {\n                index = 0;\n            }\n            if (space[index].length <= row)\n                row = space[index].length - 1;\n            space.activate(false, false);\n            Navigator.finishNavigation();\n            Navigator.getNavigator().showMinimap(space);\n        }\n\n        let column = space[index];\n        if (column.length <= row)\n            row = column.length - 1;\n\n        switch (direction) {\n        case Meta.MotionDirection.UP:\n            row--;\n            break;\n        case Meta.MotionDirection.DOWN:\n            row++;\n        }\n        if (row < 0 || row >= column.length) {\n            let monitor = focusMonitor();\n            let dir = row < 0\n                ? Meta.DisplayDirection.UP : Meta.DisplayDirection.DOWN;\n            let i = display.get_monitor_neighbor_index(monitor.index, dir);\n            if (i === -1)\n                return;\n\n            let newMonitor = Main.layoutManager.monitors[i];\n            space = spaces.monitors.get(newMonitor);\n            if (space.length <= index)\n                index = space.length - 1;\n            if (dir === Meta.DisplayDirection.UP) {\n                row = space[index].length - 1;\n            } else {\n                row = 0;\n            }\n            space.activate(false, false);\n            Navigator.finishNavigation();\n            Navigator.getNavigator().showMinimap(space);\n        }\n\n        let metaWindow = space.getWindow(index, row);\n        ensureViewport(metaWindow, space);\n    }\n\n    _drift(dx) {\n        if (dx === 0) {\n            return;\n        }\n        if (this.drifting) {\n            return;\n        }\n        this.drifting = true;\n\n        // stop drifting on key_release\n        Navigator.getActionDispatcher(Clutter.GrabState.KEYBOARD)\n            .addKeyReleaseCallback(() => {\n                Utils.timeout_remove(driftTimeout);\n                this.drifting = null;\n            });\n\n        Utils.timeout_remove(driftTimeout);\n        driftTimeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 1, () => {\n            Gestures.update(this, dx, 1);\n            this.selectedWindow = Gestures.findTargetWindow(this, dx < 0 ? -1 : 1);\n            ensureViewport(this.selectedWindow, this);\n            return true;\n        });\n    }\n\n    driftLeft() { this._drift(-1 * Settings.prefs.drift_speed); }\n    driftRight() { this._drift(Settings.prefs.drift_speed); }\n\n\n    /**\n     * Return the x position of the visible element of this window.\n     */\n    visibleX(metaWindow) {\n        return metaWindow.clone.targetX + this.targetX;\n    }\n\n    /**\n     * Return the y position of the visible element of this window.\n     */\n    visibleY(metaWindow) {\n        return metaWindow.clone.targetY + this.monitor.y;\n    }\n\n    positionOf(metaWindow) {\n        metaWindow = metaWindow || this.selectedWindow;\n        for (let i = 0; i < this.length; i++) {\n            if (this[i].includes(metaWindow))\n                return [i, this[i].indexOf(metaWindow)];\n        }\n        return false;\n    }\n\n    indexOf(metaWindow) {\n        for (let i = 0; i < this.length; i++) {\n            if (this[i].includes(metaWindow))\n                return i;\n        }\n        return -1;\n    }\n\n    rowOf(metaWindow) {\n        let column = this[this.indexOf(metaWindow)];\n        return column.indexOf(metaWindow);\n    }\n\n    globalToViewport(gx, gy) {\n        let [, vx, vy] = this.actor.transform_stage_point(gx, gy);\n        return [Math.round(vx), Math.round(vy)];\n    }\n\n    /** Transform global coordinates to scroll cooridinates (cloneContainer relative) */\n    globalToScroll(gx, gy, { useTarget = false } = {}) {\n        // Use the smart transform on the actor, as that's the one we scale etc.\n        // We can then use straight translation on the scroll which makes it possible to use target instead if wanted.\n        let [vx, vy] = this.globalToViewport(gx, gy);\n        let sx = vx - (useTarget ? this.targetX : this.cloneContainer.x);\n        let sy = vy - this.cloneContainer.y;\n        return [Math.round(sx), Math.round(sy)];\n    }\n\n    viewportToScroll(vx, vy = 0) {\n        return [vx - this.cloneContainer.x, vy - this.cloneContainer.y];\n    }\n\n    /**\n     * Moves the space viewport to position x.\n     * @param {Number} x\n     */\n    viewportMoveToX(x, animate = true) {\n        this.targetX = x;\n        this.cloneContainer.x = x;\n        this.startAnimate();\n        if (animate) {\n            Easer.addEase(this.cloneContainer,\n                {\n                    x,\n                    time: Settings.prefs.animation_time,\n                    onComplete: this.moveDone.bind(this),\n                });\n        }\n        else {\n            this.moveDone.bind(this);\n        }\n    }\n\n    moveDone(focusedWindowCallback = _focusedWindow => { }) {\n        if (this.cloneContainer.x !== this.targetX ||\n            this.actor.y !== 0 ||\n            Navigator.navigating || inPreview ||\n            Main.overview.visible ||\n            // Block when we're carrying a window in dnd\n            (inGrab && inGrab.window)\n        ) {\n            return;\n        }\n\n        this.visible = [];\n        const monitor = this.monitor;\n        this.getWindows().forEach(w => {\n            let actor = w.get_compositor_private();\n            if (!actor)\n                return;\n\n            let placeable = this.isPlaceable(w);\n            if (placeable)\n                this.visible.push(w);\n\n            // Guard against races between move_to and layout\n            // eg. moving can kill ongoing resize on wayland\n            if (Easer.isEasing(w.clone))\n                return;\n\n            let unMovable = w.fullscreen ||\n                w.get_maximized() === Meta.MaximizeFlags.BOTH;\n            if (unMovable)\n                return;\n\n            let f = w.get_frame_rect();\n            let x = this.visibleX(w);\n            let y = this.visibleY(w);\n            x = Math.max(stack_margin - f.width, x);\n            x = Math.min(this.width - stack_margin, x);\n            x += monitor.x;\n            // let b = w.get_frame_rect();\n            if (f.x !== x || f.y !== y) {\n                w.move_frame(true, x, y);\n            }\n        });\n\n        this.visible.forEach(w => {\n            if (Easer.isEasing(w.clone))\n                return;\n            this.applyClipToClone(w);\n            showWindow(w);\n        });\n\n        this._floating.forEach(showWindow);\n\n        this.fixOverlays();\n\n        if (!Meta.is_wayland_compositor()) {\n            // See startAnimate\n            Main.layoutManager.untrackChrome(this.background);\n        }\n\n        this._isAnimating = false;\n\n        if (this.selectedWindow && this.selectedWindow === display.focus_window) {\n            let index = this.indexOf(this.selectedWindow);\n            // eslint-disable-next-line no-return-assign\n            this[index].forEach(w => w.lastFrame = w.get_frame_rect());\n\n            // callback on display.focusWindow window\n            focusedWindowCallback(display.focus_window);\n        }\n\n        this.emit('move-done');\n    }\n\n    /**\n     * Applies clipping to metaWindow's clone.\n     * @param {Meta.Window} metaWindow\n     */\n    applyClipToClone(metaWindow) {\n        if (!metaWindow) {\n            return;\n        }\n\n        let actor = metaWindow.get_compositor_private();\n        if (!actor) {\n            return;\n        }\n\n        // The actor's width/height is not correct right after resize\n        const b = metaWindow.get_buffer_rect();\n        const x = this.monitor.x - b.x;\n        const y = this.monitor.y - b.y;\n        const cw = this.monitor.width;\n        const ch = this.monitor.height;\n        actor.set_clip(x, y, cw, ch);\n    }\n\n    startAnimate() {\n        if (!this._isAnimating && !Meta.is_wayland_compositor()) {\n            // Tracking the background fixes issue #80\n            // It also let us activate window clones clicked during animation\n            // Untracked in moveDone\n            Main.layoutManager.trackChrome(this.background);\n        }\n\n        this.visible.forEach(w => {\n            let actor = w.get_compositor_private();\n            if (!actor)\n                return;\n            actor.remove_clip();\n            if (inGrab && inGrab.window === w)\n                return;\n            animateWindow(w);\n        });\n\n        this._floating.forEach(w => {\n            let f = w.get_frame_rect();\n            if (!animateWindow(w))\n                return;\n            w.clone.x = f.x - this.monitor.x;\n            w.clone.y = f.y - this.monitor.y;\n        });\n\n        this._isAnimating = true;\n    }\n\n    fixOverlays(metaWindow) {\n        metaWindow = metaWindow || this.selectedWindow;\n        let index = this.indexOf(metaWindow);\n        let target = this.targetX;\n        this.monitor.clickOverlay.reset();\n        for (let overlay = this.monitor.clickOverlay.right,\n            n = index + 1; n < this.length; n++) {\n            let metaWindow = this[n][0];\n            let clone = metaWindow.clone;\n            let x = clone.targetX + target;\n            if (!overlay.target && x + clone.width > this.width) {\n                overlay.setTarget(this, n);\n                break;\n            }\n        }\n\n        for (let overlay = this.monitor.clickOverlay.left,\n            n = index - 1; n >= 0; n--) {\n            let metaWindow = this[n][0];\n            let clone = metaWindow.clone;\n            let x = clone.targetX + target;\n            if (!overlay.target && x < 0) {\n                overlay.setTarget(this, n);\n                break;\n            }\n        }\n    }\n\n    hideSelection() {\n        this.selection.set_style_class_name('background-clear');\n    }\n\n    showSelection() {\n        if (Settings.prefs.selection_border_size <= 0) {\n            return;\n        }\n        this.selection.set_style_class_name('paperwm-selection tile-preview');\n    }\n\n    setSelectionActive() {\n        this.selection.opacity = 255;\n    }\n\n    setSelectionInactive() {\n        this.selection.opacity = 140;\n    }\n\n    setSettings([uuid, settings]) {\n        this.signals.disconnect(this.settings);\n\n        this.settings = settings;\n        this.uuid = uuid;\n        if (this.background) {\n            this.updateColor();\n            this.updateBackground();\n        }\n        this.updateName();\n        this.signals.connect(this.settings, 'changed::name', this.updateName.bind(this));\n        this.signals.connect(this.settings, 'changed::color', () => {\n            this.updateColor();\n            this.updateBackground();\n        });\n        this.signals.connect(this.settings, 'changed::background',\n            this.updateBackground.bind(this));\n\n        this.updateShowTopBar();\n        this.signals.connect(gsettings, 'changed::default-show-top-bar',\n            this.showTopBarChanged.bind(this));\n        this.signals.connect(this.settings, 'changed::show-top-bar', () => {\n            this.showTopBarChanged();\n            this.layout(false);\n        });\n\n        this.updateShowPositionBar();\n        this.signals.connect(this.settings, 'changed::show-position-bar', () => {\n            this.showPositionBarChanged();\n            this.layout(false);\n        });\n    }\n\n    /**\n     * Returns the user show-top-bar setting if it exists, otherwise returns the\n     * default-show-top-bar setting.\n     * @returns Boolean\n     */\n    _getShowTopBarSetting() {\n        const value = Settings.prefs.default_show_top_bar;\n        let userValue = true;\n        try {\n            userValue = this.settings.get_boolean('show-top-bar');\n        } catch (error) {\n\n        }\n        return value && userValue;\n    }\n\n    updateShowTopBar() {\n        this.showTopBar = this._getShowTopBarSetting();\n        this._populated && Topbar.fixTopBar();\n    }\n\n    showTopBarChanged() {\n        this._removeAddPositionBar();\n        this.updateShowTopBar();\n    }\n\n    /**\n     * Removes the window position bar actor, and re-adds if needed.\n     */\n    _removeAddPositionBar() {\n        // remove window position bar actors\n        Utils.actor_remove_child(this.actor, this.windowPositionBarBackdrop);\n        Utils.actor_remove_child(this.actor, this.windowPositionBar);\n\n        // adds them is should show for this space\n        if (this._getShowPositionBar()) {\n            // this.actor.add_child(this.windowPositionBarBackdrop);\n            // this.actor.add_child(this.windowPositionBar);\n            Utils.actor_add_child(this.actor, this.windowPositionBarBackdrop);\n            Utils.actor_add_child(this.actor, this.windowPositionBar);\n        }\n    }\n\n    /**\n     * Returns the show-position-bar (workspace) setting.\n     * @returns Boolean\n     */\n    _getShowPositionBar() {\n        const value = Settings.prefs.show_window_position_bar;\n        let userValue = true;\n        try {\n            userValue = this.settings.get_boolean('show-position-bar');\n        } catch (error) {\n\n        }\n        return value && userValue;\n    }\n\n    updateShowPositionBar() {\n        this.showPositionBar = this._getShowPositionBar();\n        Topbar.fixStyle();\n    }\n\n    showPositionBarChanged() {\n        this._removeAddPositionBar();\n        this.updateShowPositionBar();\n        this.setSpaceTopbarElementsVisible(true);\n    }\n\n    /**\n     * Returns true if this space has the topbar.\n     */\n    get hasTopBar() {\n        return this.monitor && this.monitor === Topbar.panelMonitor();\n    }\n\n    updateColor() {\n        let color = this.settings.get_string('color');\n        if (color === '') {\n            let colors = Settings.prefs.workspace_colors;\n            let index = this.index % Settings.prefs.workspace_colors.length;\n            color = colors[index];\n        }\n        this.color = color;\n        this.border.set_style(`\nborder: ${borderWidth}px ${this.color};\nborder-radius: ${borderWidth}px;\n`);\n    }\n\n    updateBackground() {\n        if (!this.monitor) {\n            return;\n        }\n\n        let path = this.settings.get_string('background') || Settings.prefs.default_background;\n        let useDefault = gsettings.get_boolean('use-default-background');\n        if (!path && useDefault) {\n            if (interfaceSettings.get_string(\"color-scheme\") === \"default\") {\n                path = backgroundSettings.get_string(\"picture-uri\");\n            } else {\n                path = backgroundSettings.get_string(\"picture-uri-dark\");\n            }\n        }\n\n        // destroy old background\n        this.metaBackground?.destroy();\n        this.metaBackground = null;\n\n        this.metaBackground = new Background.Background({\n            monitorIndex: this.monitor.index,\n            layoutManager: Main.layoutManager,\n            settings: backgroundSettings,\n            file: Gio.File.new_for_commandline_arg(path),\n            style: GDesktopEnums.BackgroundStyle.ZOOM,\n        });\n\n        this.background.content.set({\n            background: this.metaBackground,\n        });\n\n        // after creating new background apply this space's color\n        if (this.color) {\n            this.metaBackground.set_color(Utils.color_from_string(this.color)[1]);\n        }\n    }\n\n    updateName() {\n        let name = workspaceSettings.getWorkspaceName(this.settings, this.index);\n        Meta.prefs_change_workspace_name(this.index, name);\n        this.workspaceLabel.text = name;\n        this.name = name;\n\n        if (this.workspace === workspaceManager.get_active_workspace()) {\n            Topbar.updateWorkspaceIndicator(this.index);\n        }\n    }\n\n    /**\n     * Enables or disables this space's window position bar.\n     * @param {boolean} enable\n     */\n    enableWindowPositionBar(enable = true) {\n        const add = enable && this.showPositionBar;\n        if (add) {\n            // [this.windowPositionBarBackdrop, this.windowPositionBar]\n            //     .forEach(i => {\n            //         if (!i.get_parent()) {\n            //             this.actor.add_child(i);\n            //         }\n            //     });\n            Utils.actor_add_child(this.actor, this.windowPositionBarBackdrop);\n            Utils.actor_add_child(this.actor, this.windowPositionBar);\n            this.updateWindowPositionBar();\n        }\n        else {\n            // [this.windowPositionBarBackdrop, this.windowPositionBar]\n            //     .forEach(i => {\n            //         if (i.get_parent()) {\n            //             this.actor.remove_child(i);\n            //         }\n            //     });\n            Utils.actor_remove_child(this.actor, this.windowPositionBarBackdrop);\n            Utils.actor_remove_child(this.actor, this.windowPositionBar);\n        }\n    }\n\n    updateWindowPositionBar() {\n        // if pref show-window-position-bar, exit\n        if (!this.showPositionBar) {\n            return;\n        }\n\n        // show space duplicate elements if not primary monitor\n        if (!this.hasTopBar) {\n            Utils.actor_raise(this.workspaceIndicator);\n            this.workspaceLabel.show();\n        }\n\n        // number of columns (a column have one or more windows)\n        let cols = this.length;\n        if (cols <= 1) {\n            this.windowPositionBar.hide();\n            return;\n        } else {\n            this.windowPositionBar.show();\n        }\n\n        let width = this.monitor.width;\n        this.windowPositionBarBackdrop.width = width;\n        let segments = width / cols;\n        this.windowPositionBar.width = segments;\n        this.windowPositionBar.height = Topbar.panelBox.height;\n\n        // index of currently selected window\n        let windex = this.indexOf(this.selectedWindow);\n        this.windowPositionBar.x = windex * segments;\n    }\n\n    /**\n     * A space contains several elements that are duplicated (in the topbar) so that\n     * they can be seen in the space \"topbar\" when switching workspaces. This function\n     * sets these elements' visibility when not needed.\n     * @param {boolean} visible\n     */\n    setSpaceTopbarElementsVisible(visible = false, options = {}) {\n        const force = options?.force ?? false;\n        const setVisible = v => {\n            if (v) {\n                this.updateSpaceIconPositions();\n                this.showWorkspaceIndicator(true, force);\n                this.showFocusModeIcon(true, force);\n            }\n            else {\n                this.showWorkspaceIndicator(false, force);\n                this.showFocusModeIcon(false, force);\n            }\n        };\n\n        // if windowPositionBar is disabled ==> don't show elements\n        if (!this.showPositionBar) {\n            setVisible(false);\n            this.enableWindowPositionBar(false);\n            return;\n        }\n\n        if (this.selectedWindow?.fullscreen) {\n            setVisible(false);\n            this.enableWindowPositionBar(false);\n            return;\n        }\n\n        if (this.hasTopBar && inPreview) {\n            Topbar.setTransparentStyle();\n        }\n\n        // if on different monitor then override to show elements\n        if (!this.hasTopBar) {\n            visible = true;\n        }\n\n        // don't show elements on spaces with actual TopBar (unless inPreview)\n        if (this.hasTopBar && !inPreview) {\n            visible = false;\n        }\n\n        // if current window is fullscreen, don't show\n        if (this?.selectedWindow?.fullscreen) {\n            visible = false;\n        }\n\n        setVisible(visible);\n    }\n\n    /**\n    * Updates workspace topbar icon positions.\n    */\n    updateSpaceIconPositions() {\n        // get positions of topbar elements to replicate positions in spaces\n        const vertex = new Graphene.Point3D({ x: 0, y: 0 });\n        const labelPosition = Topbar.menu.label.apply_relative_transform_to_point(Main.panel, vertex);\n        this.workspaceLabel.set_position(labelPosition.x, labelPosition.y);\n\n        if (Settings.prefs.show_workspace_indicator) {\n            const focusPosition = Topbar.focusButton.apply_relative_transform_to_point(Main.panel, vertex);\n            this.focusModeIcon.set_position(focusPosition.x, focusPosition.y);\n        } else {\n            // using gnome pill, set focus icon at first position\n            this.focusModeIcon.set_position(0, 0);\n        }\n    }\n\n    /**\n     * Shows the workspace indicator space element.\n     * @param {boolean} show\n     */\n    showWorkspaceIndicator(show = true, force = false) {\n        this.updateName();\n        if (show && Settings.prefs.show_workspace_indicator) {\n            // if already shown then do nothing\n            if (!force && this.workspaceIndicator.is_visible()) {\n                return;\n            }\n\n            Utils.actor_raise(this.workspaceIndicator);\n            this.workspaceIndicator.opacity = 0;\n            this.workspaceIndicator.show();\n            Easer.addEase(this.workspaceIndicator, {\n                opacity: 255,\n                time: Settings.prefs.animation_time,\n            });\n        } else {\n            // if already shown then do nothing\n            if (!force && !this.workspaceIndicator.is_visible()) {\n                return;\n            }\n\n            Easer.addEase(this.workspaceIndicator, {\n                opacity: 0,\n                time: Settings.prefs.animation_time,\n                onComplete: () => this.workspaceIndicator.hide(),\n            });\n        }\n    }\n\n    /**\n     * Shows the focusModeIcon space element.\n     * @param {boolean} show\n     */\n    showFocusModeIcon(show = true, force = false) {\n        if (show && Settings.prefs.show_focus_mode_icon) {\n            // if already shown then do nothing\n            if (!force && this.focusModeIcon.is_visible()) {\n                return;\n            }\n\n            Utils.actor_raise(this.focusModeIcon);\n            this.focusModeIcon.opacity = 0;\n            this.focusModeIcon.show();\n            Easer.addEase(this.focusModeIcon, {\n                opacity: 255,\n                time: Settings.prefs.animation_time,\n            });\n        } else {\n            // if already hidden then do nothing\n            if (!force && !this.focusModeIcon.is_visible()) {\n                return;\n            }\n            Easer.addEase(this.focusModeIcon, {\n                opacity: 0,\n                time: Settings.prefs.animation_time,\n                onComplete: () => this.focusModeIcon.hide(),\n            });\n        }\n    }\n\n    createBackground() {\n        const monitor = this.monitor;\n        if (!monitor) {\n            return;\n        }\n\n        if (this.background) {\n            this.signals.disconnect(this.background);\n            this.background.destroy();\n        }\n\n\n        this.background = new Meta.BackgroundActor(\n            Object.assign({\n                name: \"background\",\n                monitor: monitor.index,\n                reactive: true, // Disable the background menu\n            }, { meta_display: display })\n        );\n\n        this.actor.insert_child_below(this.background, null);\n\n        this.signals.connect(this.background, 'button-press-event',\n            (_actor, _event) => {\n                if (inGrab) {\n                    return;\n                }\n\n                /**\n                 * if user clicks on window, then ensureViewport on that window before exiting\n                 */\n                let [gx, gy] = global.get_pointer();\n                let [, x, y] = this.actor.transform_stage_point(gx, gy);\n                let windowAtPoint = !Gestures.gliding && this.getWindowAtPoint(x, y);\n                if (windowAtPoint) {\n                    ensureViewport(windowAtPoint, this);\n                }\n\n                spaces.selectedSpace = this;\n                Navigator.finishNavigation();\n            });\n\n        // ensure this space is active if touched\n        this.signals.connect(this.background, 'touch-event',\n            (_actor, _event) => {\n                this.activateWithFocus(this.selectedWindow, false, false);\n            });\n\n        this.signals.connect(this.background, 'scroll-event',\n            (_actor, event) => {\n                if (!inGrab && !Navigator.navigating)\n                    return;\n                let dir = event.get_scroll_direction();\n                if (dir === Clutter.ScrollDirection.SMOOTH)\n                    return;\n\n                let [gx] = event.get_coords();\n                if (!gx) {\n                    return;\n                }\n\n                switch (dir) {\n                case Clutter.ScrollDirection.LEFT:\n                case Clutter.ScrollDirection.UP:\n                    this.switchLeft(false);\n                    break;\n                case Clutter.ScrollDirection.RIGHT:\n                case Clutter.ScrollDirection.DOWN:\n                    this.switchRight(false);\n                    break;\n                }\n            });\n\n        this.signals.connect(this.background, 'captured-event', (actor, event) => {\n            Gestures.horizontalScroll(this, actor, event);\n        });\n    }\n\n    setMonitor(monitor, animate = false, options = {}) {\n        const commit = options?.commit ?? true;\n\n        // check monitor exists\n        if (!monitor) {\n            return;\n        }\n\n        // Remake the background when we move monitors. The size/scale will be\n        // incorrect when using fractional scaling.\n        if (monitor !== this.monitor) {\n            if (commit) {\n                this.monitor = monitor;\n            }\n            this.createBackground();\n            this.updateColor();\n            this.updateBackground();\n\n            // update width of windowPositonBarBackdrop (to match monitor)\n            this.windowPositionBarBackdrop.width = monitor.width;\n        }\n\n        let background = this.background;\n        let clip = this.clip;\n\n        this.width = monitor.width;\n        this.height = monitor.height;\n\n        let time = animate ? Settings.prefs.animation_time : 0;\n\n        Easer.addEase(this.actor,\n            {\n                x: 0, y: 0, scale_x: 1, scale_y: 1,\n                time,\n            });\n        Easer.addEase(clip,\n            { scale_x: 1, scale_y: 1, time });\n\n        clip.set_position(monitor.x, monitor.y);\n        clip.set_size(monitor.width, monitor.height);\n        clip.set_clip(0, 0,\n            monitor.width,\n            monitor.height);\n\n        let scale = St.ThemeContext.get_for_stage(global.stage).scale_factor;\n        this.border.set_position(-borderWidth * scale, -borderWidth * scale);\n        this.border.set_size(monitor.width + scale * borderWidth * 2,\n            monitor.height + scale * borderWidth * 2);\n\n        background.set_size(this.width, this.height);\n\n        this.cloneClip.set_size(monitor.width, monitor.height);\n        this.cloneClip.set_clip(0, 0, this.width, this.height);\n        // transforms break if there's no height\n        this.cloneContainer.height = this.monitor.height;\n\n        this.layout(true, { centerIfOne: false });\n        this.emit('monitor-changed');\n    }\n\n    /**\n       Add existing windows on workspace to the space. Restore the\n       layout of prevSpace if present.\n    */\n    addAll(prevSpace) {\n        // On gnome-shell-restarts the windows are moved into the viewport, but\n        // they're moved minimally and the stacking is not changed, so the tiling\n        // order is preserved (sans full-width windows..)\n        let xz_comparator = windows => {\n            // Seems to be the only documented way to get stacking order?\n            // Could also rely on the MetaWindowActor's index in it's parent\n            // children array: That seem to correspond to clutters z-index (note:\n            // z_position is something else)\n            let z_sorted = display.sort_windows_by_stacking(windows);\n            let xkey = mw => {\n                let frame = mw.get_frame_rect();\n                if (frame.x <= 0)\n                    return 0;\n                if (frame.x + frame.width === this.width) {\n                    return this.width;\n                }\n                return frame.x;\n            };\n            // xorder: a|b c|d\n            // zorder: a d b c\n            return (a, b) => {\n                let ax = xkey(a);\n                let bx = xkey(b);\n                // Yes, this is not efficient\n                let az = z_sorted.indexOf(a);\n                let bz = z_sorted.indexOf(b);\n                let xcmp = ax - bx;\n                if (xcmp !== 0)\n                    return xcmp;\n\n                if (ax === 0) {\n                    // Left side: lower stacking first\n                    return az - bz;\n                } else {\n                    // Right side: higher stacking first\n                    return bz - az;\n                }\n            };\n        };\n\n        if (prevSpace) {\n            for (let i = 0; i < prevSpace.length; i++) {\n                let column = prevSpace[i];\n                for (let j = 0; j < column.length; j++) {\n                    let metaWindow = column[j];\n                    // Prune removed windows\n                    if (metaWindow.get_compositor_private()) {\n                        this.addWindow(metaWindow, i, j);\n                    } else {\n                        // eslint-disable-next-line max-statements-per-line\n                        column.splice(j, 1); j--;\n                    }\n                }\n                if (column.length === 0) {\n                    // eslint-disable-next-line max-statements-per-line\n                    prevSpace.splice(i, 1); i--;\n                }\n            }\n        }\n\n        let workspace = this.workspace;\n        let windows = workspace.list_windows()\n            .sort(xz_comparator(workspace.list_windows()));\n\n        windows.forEach((meta_window, _i) => {\n            if (meta_window.above || meta_window.minimized) {\n                // Rough heuristic to figure out if a window should float\n                Scratch.makeScratch(meta_window);\n                return;\n            }\n            if (this.indexOf(meta_window) < 0 && add_filter(meta_window)) {\n                this.addWindow(meta_window, this.length);\n            }\n        });\n\n        let tabList = display.get_tab_list(Meta.TabList.NORMAL, workspace)\n            .filter(metaWindow => { return this.indexOf(metaWindow) !== -1; });\n        if (tabList[0]) {\n            this.selectedWindow = tabList[0];\n        }\n    }\n\n    // Fix for eg. space.map, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Species\n    static get [Symbol.species]() { return Array; }\n\n    selectedIndex() {\n        if (this.selectedWindow) {\n            return this.indexOf(this.selectedWindow);\n        } else {\n            return -1;\n        }\n    }\n\n    destroy() {\n        this.getWindows().forEach(w => {\n            removePaperWMFlags(w);\n        });\n        this.signals.destroy();\n        this.signals = null;\n        this.background.destroy();\n        this.background = null;\n        this.cloneContainer.destroy();\n        this.cloneContainer = null;\n        this.clip.destroy();\n        this.clip = null;\n    }\n}\n\nSignals.addSignalMethods(Space.prototype);\n\n// static object\nexport const StackPositions = {\n    top: 0.01,\n    up: 0.035,\n    selected: 0.1,\n    down: 0.95,\n    bottom: 1.1,\n};\n\n/**\n   A `Map` to store all `Spaces`'s, indexed by the corresponding workspace.\n*/\nexport const Spaces = class Spaces extends Map {\n    // Fix for eg. space.map, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Species\n    static get [Symbol.species]() { return Map; }\n    constructor() {\n        super();\n        this._initDone = false;\n        this.clickOverlays = [];\n        this.signals = new Utils.Signals();\n        this.stack = [];\n        let spaceContainer = new Clutter.Actor({ name: 'spaceContainer' });\n        spaceContainer.hide();\n        this.spaceContainer = spaceContainer;\n        this.space_defaultAnimation = true;\n        this.space_paperwmAnimation = false;\n\n        backgroundGroup.add_child(this.spaceContainer);\n\n        // Hook up existing workspaces\n        for (let i = 0; i < workspaceManager.n_workspaces; i++) {\n            let workspace = workspaceManager.get_workspace_by_index(i);\n            this.addSpace(workspace);\n        }\n        this.signals.connect(workspaceManager, 'notify::n-workspaces',\n            () => this.workspacesChanged());\n\n        this.signals.connect(workspaceManager, 'workspaces-reordered',\n            () => this.workspacesChanged());\n\n        const OVERRIDE_SCHEMA = 'org.gnome.mutter';\n        this.overrideSettings = new Gio.Settings({ schema_id: OVERRIDE_SCHEMA });\n    }\n\n    init() {\n        // Create extra workspaces if required\n        Main.wm._workspaceTracker._checkWorkspaces();\n\n        // Monitors aren't set up properly on `enable`, so we need it enable here.\n        this.monitorsChanged();\n        this.signals.connect(Main.layoutManager, 'monitors-changed', () => {\n            displayConfig.upgradeGnomeMonitors(() => this.monitorsChanged());\n        });\n\n        this.signals.connect(display, 'window-created',\n            (display, metaWindow, _user_data) => this.window_created(metaWindow));\n\n        this.signals.connect(display, 'grab-op-begin', (display, mw, type) => grabBegin(mw, type));\n        this.signals.connect(display, 'grab-op-end', (display, mw, type) => grabEnd(mw, type));\n\n\n        this.signals.connect(global.window_manager, 'switch-workspace',\n            (wm, from, to, _direction) => this.switchWorkspace(wm, from, to));\n\n        this.signals.connect(this.overrideSettings, 'changed::workspaces-only-on-primary', () => {\n            displayConfig.upgradeGnomeMonitors(() => this.monitorsChanged());\n        });\n\n        // Clone and hook up existing windows\n        display.get_tab_list(Meta.TabList.NORMAL_ALL, null)\n            .forEach(w => {\n                // remove flags\n                removePaperWMFlags(w);\n\n                registerWindow(w);\n                // Fixup allocations on reload\n                allocateClone(w);\n                addResizeHandler(w);\n                addPositionHandler(w);\n            });\n        this._initDone = true;\n\n        // Initialize spaces _after_ monitors are set up\n        this.forEach(space => space.init());\n\n        // Bind to visible workspace when starting up\n        this.touchSignal = signals.connect(Main.panel, \"touch-event\", Gestures.horizontalTouchScroll.bind(this.activeSpace));\n\n        this.stack = this.mru();\n    }\n\n    /**\n       The monitors-changed signal can trigger _many_ times when\n       connection/disconnecting monitors.\n\n       Monitors are now upgraded via a dbus proxy connector which upgrades\n       Main.layoutManager.monitors with a \"connector\" property (e.g \"eDP-1\")\n       which is more stable for restoring monitor layouts.\n     */\n    monitorsChanged() {\n        this.onlyOnPrimary = this.overrideSettings.get_boolean('workspaces-only-on-primary');\n        this.monitors = new Map();\n\n        // can be called async (after delay) on disable - use activeSpace as check\n        if (!this.activeSpace) {\n            return;\n        }\n\n        this.activeSpace.getWindows().forEach(w => {\n            animateWindow(w);\n        });\n\n        this.spaceContainer.set_size(global.screen_width, global.screen_height);\n\n        for (let overlay of this.clickOverlays) {\n            overlay.destroy();\n        }\n        this.clickOverlays = [];\n        let mru = this.mru();\n\n        let primary = Main.layoutManager.primaryMonitor;\n        if (!primary) {\n            // setup periodic timout to call layout on all spaces 5 times (1 second apart)\n            monitorChangeTimeout = Utils.periodic_timeout({\n                count: 5,\n                init: () => {\n                    Utils.timeout_remove(monitorChangeTimeout);\n                },\n                callback: () => {\n                    this?.forEach(s => s.layout());\n                },\n                onContinue: called => {\n                    console.warn(`MONITORS_CHANGED: no primary monitor - 'layout' on spaces call ${called}`);\n                },\n                onComplete: () => {\n                    monitorChangeTimeout = null;\n                },\n            });\n            return;\n        }\n\n        // get monitors but ensure primary monitor is first\n        let monitors = Main.layoutManager.monitors.filter(m => m !== primary);\n        monitors.unshift(primary);\n\n        for (let monitor of monitors) {\n            let overlay = new ClickOverlay(monitor, this.onlyOnPrimary);\n            monitor.clickOverlay = overlay;\n            this.clickOverlays.push(overlay);\n        }\n\n        let finish = () => {\n            /**\n             * Gnome may select a workspace that just had it monitor removed (gone).\n             * This this case find the next most recent space that's maintained it's\n             * monitor, and select that.\n             */\n            let recent = this.mru().filter(s => !monitorGoneSpaces.includes(s));\n            let activeSpace = recent?.[0] ?? this.monitors.get(primary);\n            activeSpace.activate(false, false);\n\n            this.selectedSpace = activeSpace;\n            this.setMonitors(activeSpace.monitor, activeSpace);\n            this.monitors.forEach(space => {\n                space.show();\n                Utils.actor_raise(space.clip);\n            });\n\n            this.spaceContainer.show();\n            Topbar.refreshWorkspaceIndicator();\n            this.forEach(s => s.setSpaceTopbarElementsVisible());\n            Stackoverlay.multimonitorSupport();\n        };\n\n        if (this.onlyOnPrimary) {\n            this.forEach(space => {\n                space.setMonitor(primary);\n            });\n            this.setMonitors(primary, mru[0]);\n            finish();\n            return;\n        }\n\n        /**\n         * Schedule to restore space targetX after this.  Needs to be\n         * scheduled before other loops since prevTargetX will be\n         * updated after this.\n         */\n        Utils.later_add(Meta.LaterType.IDLE, () => {\n            if (saveState.hasPrevTargetX()) {\n                for (let [uuid, targetX] of saveState.prevTargetX) {\n                    let space = this.spaceOfUuid(uuid);\n                    if (space && Number.isFinite(targetX)) {\n                        space.viewportMoveToX(targetX, false);\n                    }\n                }\n            }\n\n            // save restore state after restored previous targetX's\n            saveState.update();\n\n            // run layout on spaces after monitor to ensure windows layout is correct\n            this.forEach(space => space.layout(false));\n        });\n\n        // add any new / need workspaces that were present from prev state\n        let prevNSpaces = saveState?.prevSpaces?.size ?? 0;\n        let addSpaces = Math.max(0, prevNSpaces - workspaceManager.n_workspaces);\n        console.info(`nPrevSpaces ${prevNSpaces}, current nSpaces ${workspaceManager.n_workspaces}, need to add ${addSpaces}`);\n        for (let i = 0; i < addSpaces; i++) {\n            workspaceManager.append_new_workspace(false, global.get_current_time());\n        }\n\n        // Persist as many monitors as possible\n        let indexTracker = [];\n        if (saveState.hasPrevMonitors()) {\n            for (let monitor of monitors) {\n                // if processed spaceIndex, skip\n                let spaceIndex = saveState.prevMonitors.get(monitor.connector);\n                if (indexTracker.includes(spaceIndex)) {\n                    continue;\n                }\n                indexTracker.push(spaceIndex);\n\n                let space = this.spaceOfIndex(spaceIndex);\n                if (space) {\n                    console.info(`${space.name} restored to monitor ${monitor.connector}`);\n                    this.setMonitors(monitor, space);\n                    space.setMonitor(monitor);\n                    mru = mru.filter(s => s !== space);\n                }\n            }\n        }\n\n        // Populate any remaining monitors\n        for (let monitor of monitors) {\n            if (this.monitors.get(monitor) === undefined) {\n                let space = mru[0];\n                if (space === undefined) {\n                    continue;\n                }\n                this.setMonitors(monitor, space);\n                space.setMonitor(monitor);\n                mru = mru.slice(1);\n            }\n        }\n\n        /**\n         * Reset spaces where their monitors no longer exist.\n         * These spaces should be be restored.  We'll track\n         * which spaces have their monitor gone.\n         */\n        let monitorGoneSpaces = [];\n        this.forEach(space => {\n            if (!monitors.includes(space.monitor)) {\n                monitorGoneSpaces.push(space);\n                space.setMonitor(primary);\n            }\n        });\n\n        finish();\n    }\n\n    /**\n     * Sets this.monitors map and updates prevMonitors map (for restore).\n     */\n    setMonitors(monitor, space, save = false) {\n        this.monitors.set(monitor, space);\n        saveState.update(save);\n    }\n\n    _updateMonitor() {\n        let monitorSpaces = this._getOrderedSpaces(this.selectedSpace.monitor);\n        let currentMonitor = this.selectedSpace.monitor;\n        monitorSpaces.forEach((space, _i) => {\n            space.setMonitor(currentMonitor);\n        });\n    }\n\n    destroy() {\n        for (let overlay of this.clickOverlays) {\n            overlay.destroy();\n        }\n        for (let monitor of Main.layoutManager.monitors) {\n            delete monitor.clickOverlay;\n        }\n\n        display.get_tab_list(Meta.TabList.NORMAL_ALL, null)\n            .forEach(metaWindow => {\n                let actor = metaWindow.get_compositor_private();\n                actor.remove_clip();\n\n                if (metaWindow.clone) {\n                    metaWindow.clone.destroy();\n                    metaWindow.clone = null;\n                }\n\n                metaWindow._targetHeight = null;\n                metaWindow._targetWidth = null;\n\n                if (\n                    metaWindow.get_workspace() === workspaceManager.get_active_workspace() &&\n                    !metaWindow.minimized\n                ) {\n                    actor.show();\n                }\n                else {\n                    actor.hide();\n                }\n            });\n\n        this.signals.destroy();\n        this.signals = null;\n\n        // remove spaces\n        for (let [, space] of this) {\n            this.removeSpace(space);\n        }\n\n        this.spaceContainer.destroy();\n        this.spaceContainer = null;\n    }\n\n    workspacesChanged() {\n        let nWorkspaces = workspaceManager.n_workspaces;\n\n        // Identifying destroyed workspaces is rather bothersome,\n        // as it will for example report having windows,\n        // but will crash when looking at the workspace index\n\n        // Gather all indexed workspaces for easy comparison\n        let workspaces = {};\n        for (let i = 0; i < nWorkspaces; i++) {\n            let workspace = workspaceManager.get_workspace_by_index(i);\n            workspaces[workspace] = true;\n            if (this.spaceOf(workspace) === undefined) {\n                this.addSpace(workspace);\n            }\n        }\n\n        let nextUnusedWorkspaceIndex = nWorkspaces;\n        for (let [, space] of this) {\n            if (workspaces[space.workspace] !== true) {\n                this.removeSpace(space);\n\n                // Maps in javascript (and thus Spaces) remember insertion order\n                // so the workspaces are sorted by index. The relative ordering\n                // of the removed workspaces will thus be preserved when resurrected.\n                space.settings.set_int('index', nextUnusedWorkspaceIndex);\n                nextUnusedWorkspaceIndex++;\n            }\n        }\n\n        // Ensure the live spaces have correct indices\n        for (let [workspace, space] of this) {\n            space.settings.set_int('index', workspace.index());\n            Meta.prefs_change_workspace_name(workspace.index(), space.name);\n        }\n    }\n\n    /**\n     * Return true if there are less-than-or-equal-to spaces than monitors.\n     */\n    lteSpacesThanMonitors(onFalseCallback) {\n        const cb = onFalseCallback ?? function (_nSpaces, _nMonitors) { };\n        const nSpaces = [...this].length;\n        const nMonitors = Main.layoutManager.monitors.length;\n\n        if (nSpaces <= nMonitors) {\n            cb(nSpaces, nMonitors);\n        }\n        return nSpaces <= nMonitors;\n    }\n\n    switchMonitor(direction, move, warp = true) {\n        let focus = display.focus_window;\n        let monitor = focusMonitor();\n        let currentSpace = this.monitors.get(monitor);\n        let i = display.get_monitor_neighbor_index(monitor.index, direction);\n        if (i === -1)\n            return;\n        let newMonitor = Main.layoutManager.monitors[i];\n        if (warp) {\n            Utils.warpPointerToMonitor(newMonitor);\n        }\n        let space = this.monitors.get(newMonitor);\n\n        if (move && focus) {\n            let metaWindow = focus.get_transient_for() || focus;\n\n            if (currentSpace && currentSpace.indexOf(metaWindow) !== -1) {\n                currentSpace.removeWindow(metaWindow);\n                metaWindow.foreach_transient(t => {\n                    currentSpace.removeWindow(t);\n                });\n            } else {\n                metaWindow.move_to_monitor(newMonitor.index);\n            }\n            metaWindow.foreach_transient(t => {\n                t.move_to_monitor(newMonitor.index);\n            });\n            if (space) {\n                metaWindow.change_workspace(space.workspace);\n                metaWindow.foreach_transient(t => {\n                    space.addFloating(t);\n                });\n                space.activateWithFocus(focus, false, false);\n            } else {\n                metaWindow.move_to_monitor(newMonitor.index);\n            }\n        } else {\n            space.activate(false, false);\n        }\n    }\n\n    moveToMonitor(direction, backDirection) {\n        const monitor = focusMonitor();\n        const i = display.get_monitor_neighbor_index(monitor.index, direction);\n        if (i === -1)\n            return;\n\n        if (this.lteSpacesThanMonitors(\n            (s, m) => Main.notify(\n                `PaperWM (cannot move workspace)`,\n                `You need at least ${m + 1} workspaces to complete this operation.`\n            )\n        )) {\n            return;\n        }\n\n        // check how many spaces are on this monitor\n        const numSpaces = [...this].filter(([_monitor, space]) => space?.monitor === monitor).length;\n        // if last space on this monitor, then swap\n        if (numSpaces <= 1) {\n            this.swapMonitor(direction, backDirection);\n            return;\n        }\n\n        let navFinish = () => Navigator.getNavigator().finish();\n        // action on current monitor\n        this.selectStackSpace(Meta.MotionDirection.DOWN);\n        navFinish();\n        // switch to target monitor and action mru\n        this.switchMonitor(direction, false, true);\n        this.selectStackSpace(Meta.MotionDirection.DOWN);\n        navFinish();\n\n        // /**\n        //  * Fullscreen monitor workaround.\n        //  * see https://github.com/paperwm/PaperWM/issues/638\n        //  */\n        // this.forEach(space => {\n        //     space.getWindows().filter(w => w.fullscreen).forEach(w => {\n        //         animateWindow(w);\n        //         w.unmake_fullscreen();\n        //         w.make_fullscreen();\n        //         showWindow(w);\n        //     });\n        // });\n\n        // ensure after swapping that the space elements are shown correctly\n        this.forEach(s => s.setSpaceTopbarElementsVisible(true, { force: true }));\n    }\n\n    swapMonitor(direction, backDirection, options = {}) {\n        const checkIfLast = options.checkIfLast ?? true;\n        const warpIfLast = options.warpIfLast ?? true;\n\n        const monitor = focusMonitor();\n        const i = display.get_monitor_neighbor_index(monitor.index, direction);\n        if (i === -1)\n            return;\n\n        if (this.lteSpacesThanMonitors(\n            (s, m) => Main.notify(\n                `PaperWM (cannot swap workspaces)`,\n                `You need at least ${m + 1} workspaces to complete this operation.`\n            )\n        )) {\n            return;\n        }\n\n        if (checkIfLast) {\n            // check how many spaces are on this monitor\n            const numSpaces = [...this].filter(([_monitor, space]) => space?.monitor === monitor).length;\n            // if last space on this monitor, then swap\n            if (numSpaces <= 1) {\n                // focus other monitor for a switchback\n                this.switchMonitor(direction, false, false);\n                this.swapMonitor(backDirection, direction, {\n                    checkIfLast: false,\n                    warpIfLast: false,\n                });\n\n                // now switch monitor with warp since we back-flipped\n                this.switchMonitor(direction, false, true);\n                return;\n            }\n        }\n\n        let navFinish = () => Navigator.getNavigator().finish();\n        // action on current monitor\n        this.selectStackSpace(Meta.MotionDirection.DOWN);\n        navFinish();\n        // switch to target monitor and action mru\n        this.switchMonitor(direction, false, false);\n        this.selectStackSpace(Meta.MotionDirection.DOWN);\n        navFinish();\n        // switch back to orig monitor and action mru\n        this.switchMonitor(backDirection, false, false);\n        this.selectStackSpace(Meta.MotionDirection.DOWN);\n        navFinish();\n        // final switch with warp\n        this.switchMonitor(direction, false, warpIfLast);\n\n        // /**\n        //  * Fullscreen monitor workaround.\n        //  * see https://github.com/paperwm/PaperWM/issues/638\n        //  */\n        // this.forEach(space => {\n        //     space.getWindows().filter(w => w.fullscreen).forEach(w => {\n        //         animateWindow(w);\n        //         w.unmake_fullscreen();\n        //         w.make_fullscreen();\n        //         showWindow(w);\n        //     });\n        // });\n\n        // ensure after swapping that the space elements are shown correctly\n        this.forEach(s => s.setSpaceTopbarElementsVisible(true, { force: true }));\n    }\n\n    switchSpace(fromSpace, toSpace, animate = false) {\n        const fromId = fromSpace?.index;\n        const toId = toSpace?.index;\n        if (!fromSpace || !toSpace) {\n            return;\n        }\n        spaces.switchWorkspace(null, fromId, toId, animate);\n    }\n\n    switchWorkspace(wm, fromIndex, toIndex, animate = false) {\n        /**\n         * disable swipetrackers on workspace switch to avoid gesture confusion\n         * see https://github.com/paperwm/PaperWM/issues/682\n         */\n        if (Gestures.gestureEnabled()) {\n            // if in overview exit -> overview will disable swipetrackers when done\n            if (!Main.overview.visible) {\n                Gestures.swipeTrackersEnable(false);\n            }\n        }\n\n        let to = workspaceManager.get_workspace_by_index(toIndex);\n        let from = workspaceManager.get_workspace_by_index(fromIndex);\n        let toSpace = this.spaceOf(to);\n        let fromSpace = this.spaceOf(from);\n\n        if (inGrab && inGrab.window) {\n            inGrab.window.change_workspace(toSpace.workspace);\n        }\n\n        for (let metaWindow of toSpace.getWindows()) {\n            // Make sure all windows belong to the correct workspace.\n            // Note: The 'switch-workspace' signal (this method) runs before mutter decides on focus window.\n            // This simplifies other code moving windows between workspaces.\n            // Eg.: The DnD-window defer changing its workspace until the workspace actually is activated.\n            //      This ensures the DnD window keep focus the whole time.\n            metaWindow.change_workspace(toSpace.workspace);\n        }\n\n        if (inPreview === PreviewMode.NONE &&\n            toSpace.monitor === fromSpace.monitor) {\n            // Only start an animation if we're moving between workspaces on the\n            // same monitor\n            this.initWorkspaceSequence();\n        } else {\n            this.selectedSpace.setMonitor(this.selectedSpace.monitor);\n        }\n\n        this.stack = this.stack.filter(s => s !== toSpace);\n        this.stack = [toSpace, ...this.stack];\n\n        let monitor = toSpace.monitor;\n        this.setMonitors(monitor, toSpace, true);\n\n        this.forEach(s => s.setSpaceTopbarElementsVisible());\n        let doAnimate = animate || this.space_paperwmAnimation;\n        this.animateToSpace(\n            toSpace,\n            fromSpace,\n            doAnimate);\n\n        // Update panel to handle target workspace\n        signals.disconnect(Main.panel, this.touchSignal);\n        this.touchSignal = signals.connect(Main.panel, \"touch-event\", Gestures.horizontalTouchScroll.bind(toSpace));\n\n        inPreview = PreviewMode.NONE;\n    }\n\n    _getOrderedSpaces(monitor) {\n        let nWorkspaces = workspaceManager.n_workspaces;\n        let out = [];\n        for (let i = 0; i < nWorkspaces; i++) {\n            let space = this.spaceOf(workspaceManager.get_workspace_by_index(i));\n\n            if (space.monitor === monitor) {\n                out.push(space);\n                continue;\n            }\n\n            // include workspace if it is the current one\n            // or if it is empty and not active on another monitor\n            if (space.length === 0 &&\n                this.monitors.get(space.monitor) !== space) {\n                out.push(space);\n                continue;\n            }\n        }\n        return out;\n    }\n\n    _getOrderedSpacesFromAllMonitors(monitor) {\n        let nWorkspaces = workspaceManager.n_workspaces;\n        let out = [];\n        for (let i = 0; i < nWorkspaces; i++) {\n            let space = this.spaceOf(workspaceManager.get_workspace_by_index(i));\n            if (this.monitors.get(space.monitor) !== space || space.monitor === monitor) {\n                // include workspace if it is the current one\n                // or if it is not active on another monitor\n                out.push(space);\n            }\n        }\n        return out;\n    }\n\n    _animateToSpaceOrdered(toSpace, animate = true) {\n        // Always show the topbar when using the workspace stack\n        Topbar.fixTopBar();\n\n        toSpace = toSpace || this.selectedSpace;\n        let monitorSpaces = this._getOrderedSpaces(toSpace.monitor);\n\n        let currentMonitor = toSpace.monitor;\n        this.selectedSpace = toSpace;\n\n        const scale = 1;\n        const padding_percentage = 4;\n        const to = monitorSpaces.indexOf(toSpace);\n        monitorSpaces.forEach((space, i) => {\n            space.setMonitor(currentMonitor);\n            space.startAnimate();\n\n            Easer.removeEase(space.border);\n            space.border.opacity = 255;\n            space.border.show();\n\n            space.show();\n\n            let padding = (space.height * scale / 100) * padding_percentage;\n            let y = ((space.height + padding) * (i - to)) * scale;\n            if (animate) {\n                Easer.addEase(space.actor, {\n                    time: Settings.prefs.animation_time,\n                    y, scale_y: scale, scale_x: scale,\n                });\n            } else {\n                // Remove any lingering onComplete handlers from animateToSpace\n                Easer.removeEase(space.actor);\n\n                space.actor.y = y;\n                space.actor.scale_y = scale;\n                space.actor.scale_x = scale;\n            }\n\n            let selected = space.selectedWindow;\n            if (selected && selected.fullscreen && space !== toSpace) {\n                selected.clone.y = Main.panel.height + Settings.prefs.vertical_margin;\n            }\n        });\n    }\n\n    initWorkspaceSequence() {\n        if (inPreview) {\n            return;\n        }\n        inPreview = PreviewMode.SEQUENTIAL;\n\n        if (Main.panel.statusArea.appMenu) {\n            Main.panel.statusArea.appMenu.container.hide();\n        }\n\n        this.forEach(s => s.setSpaceTopbarElementsVisible(true));\n        this._animateToSpaceOrdered(this.selectedSpace, false);\n\n        let selected = this.selectedSpace.selectedWindow;\n        if (selected && selected.fullscreen) {\n            Easer.addEase(selected.clone, {\n                y: Main.panel.height + Settings.prefs.vertical_margin,\n                time: Settings.prefs.animation_time,\n            });\n        }\n    }\n\n    selectSequenceSpace(direction, move, fromAllMonitors = false) {\n        // if in stack preview do not run sequence preview\n        if (inPreview === PreviewMode.STACK) {\n            return;\n        }\n\n        let currentSpace = this.activeSpace;\n        let monitorSpaces;\n        if (fromAllMonitors) {\n            monitorSpaces = this._getOrderedSpacesFromAllMonitors(currentSpace.monitor);\n        } else {\n            monitorSpaces = this._getOrderedSpaces(currentSpace.monitor);\n        }\n\n        let from = monitorSpaces.indexOf(this.selectedSpace);\n        let newSpace = this.selectedSpace;\n        let to = from;\n\n        if (move && this.selectedSpace.selectedWindow) {\n            const navigator = Navigator.getNavigator();\n            if (!navigator._moving ||\n                (Array.isArray(navigator._moving) && navigator._moving.length === 0)) {\n                takeWindow(this.selectedSpace.selectedWindow,\n                    this.selectedSpace,\n                    { navigator });\n            }\n        }\n\n        if (direction === Meta.MotionDirection.DOWN) {\n            to = from + 1;\n        }\n        else {\n            to = from - 1;\n        }\n\n        if (to < 0 || to >= monitorSpaces.length) {\n            return;\n        }\n\n        if (to === from && Easer.isEasing(newSpace.actor)) {\n            return;\n        }\n\n        if (!inPreview) {\n            this.initWorkspaceSequence();\n        }\n\n        newSpace = monitorSpaces[to];\n        this.selectedSpace = newSpace;\n\n        // if active (source space) is panelMonitor update indicator\n        if (currentSpace.monitor === Topbar.panelMonitor()) {\n            Topbar.updateWorkspaceIndicator(newSpace.index);\n        }\n\n        const scale = 0.825;\n        const padding_percentage = 4;\n        let last = monitorSpaces.length - 1;\n        monitorSpaces.forEach((space, i) => {\n            // need to set monitor here so it shows up during selection, when it\n            // was previously on another monitor\n            space.setMonitor(currentSpace.monitor, false, { commit: false });\n\n            let padding = (space.height * scale / 100) * padding_percentage;\n            let center = (space.height - (space.height * scale)) / 2;\n            let space_y;\n            if (to === 0) {\n                space_y = padding + (space.height + padding) * (i - to) * scale;\n            } else if (to === last) {\n                space_y = (center * 2 - padding) + (space.height + padding) * (i - to) * scale;\n            } else {\n                space_y = center + (space.height + padding) * (i - to) * scale;\n            }\n\n            space.show();\n            Easer.addEase(space.actor, {\n                y: space_y,\n                time: Settings.prefs.animation_time,\n                scale_x: scale,\n                scale_y: scale,\n            });\n        });\n    }\n\n    initWorkspaceStack() {\n        if (inPreview) {\n            return;\n        }\n\n        inPreview = PreviewMode.STACK;\n\n        // Always show the topbar when using the workspace stack\n        Topbar.fixTopBar();\n        const scale = 0.9;\n        let space = this.activeSpace;\n        let mru = [...this.stack];\n        this.monitors.forEach(space => mru.splice(mru.indexOf(space), 1));\n        mru = [space, ...mru];\n\n        if (Main.panel.statusArea.appMenu)\n            Main.panel.statusArea.appMenu.container.hide();\n        let monitor = space.monitor;\n        this.selectedSpace = space;\n\n        this.forEach(s => s.setSpaceTopbarElementsVisible(true));\n        let cloneParent = space.clip.get_parent();\n        mru.forEach((space, i) => {\n            space.startAnimate();\n\n            if (space.length !== 0) {\n                let scaleX = monitor.width / space.width;\n                let scaleY = monitor.height / space.height;\n                space.clip.set_scale(scaleX, scaleY);\n                space.clip.set_position(monitor.x, monitor.y);\n            } else {\n                space.setMonitor(monitor);\n            }\n\n            Easer.removeEase(space.border);\n            space.border.opacity = 255;\n            space.border.show();\n\n            let h;\n            if (i === 0) {\n                h = 0;\n                space.show();\n            } else if (i === 1) {\n                h = StackPositions.up;\n                space.show();\n            } else if (i === 2) {\n                h = StackPositions.top;\n                space.show();\n            } else {\n                h = StackPositions.top;\n                space.hide();\n            }\n\n            space.actor.set_position(0, space.height * h);\n\n            space.actor.scale_y = scale - i * 0.01;\n            space.actor.scale_x = scale - i * 0.01;\n\n            // Remove any lingering onComplete handlers from animateToSpace\n            Easer.removeEase(space.actor);\n\n            if (mru[i - 1] === undefined) {\n                return;\n            }\n            let child = space.clip;\n            let sibling = mru[i - 1].clip;\n            child !== sibling && cloneParent.set_child_below_sibling(child, sibling);\n            let selected = space.selectedWindow;\n            if (selected && selected.fullscreen) {\n                selected.clone.y = Main.panel.height + Settings.prefs.vertical_margin;\n            }\n        });\n\n        space.actor.scale_y = 1;\n        space.actor.scale_x = 1;\n\n        let selected = space.selectedWindow;\n        if (selected && selected.fullscreen) {\n            Easer.addEase(selected.clone, {\n                y: Main.panel.height + Settings.prefs.vertical_margin,\n                time: Settings.prefs.animation_time,\n            });\n        }\n    }\n\n    selectStackSpace(direction, move) {\n        // if in sequence preview do not run stack preview\n        if (inPreview === PreviewMode.SEQUENTIAL) {\n            return;\n        }\n\n        const scale = 0.9;\n        let space = this.activeSpace;\n        let mru = [...this.stack];\n\n        this.monitors.forEach(space => mru.splice(mru.indexOf(space), 1));\n        mru = [space, ...mru];\n\n        if (!inPreview) {\n            this.initWorkspaceStack();\n        }\n\n        let from = mru.indexOf(this.selectedSpace);\n        let newSpace = this.selectedSpace;\n        let to = from;\n        if (move && this.selectedSpace.selectedWindow) {\n            takeWindow(this.selectedSpace.selectedWindow,\n                this.selectedSpace,\n                { navigator: Navigator.getNavigator() });\n        }\n\n        if (direction === Meta.MotionDirection.DOWN)\n            to = from + 1;\n        else\n            to = from - 1;\n\n        // wrap around workspaces\n        if (to < 0) {\n            to = mru.length - 1;\n        }\n        else if (to >= mru.length) {\n            to = 0;\n        }\n\n        if (to === from && Easer.isEasing(newSpace.actor)) {\n            return;\n        }\n\n        newSpace = mru[to];\n        this.selectedSpace = newSpace;\n\n        // if active (source space) is panelMonitor update indicator\n        if (space.monitor === Topbar.panelMonitor()) {\n            Topbar.updateWorkspaceIndicator(newSpace.index);\n        }\n\n        mru.forEach((space, i) => {\n            let actor = space.actor;\n            let h, onComplete = () => { };\n            if (to === i)\n                h = StackPositions.selected;\n            else if (to + 1 === i)\n                h = StackPositions.up;\n            else if (to - 1 === i)\n                h = StackPositions.down;\n            else if (i > to)\n                h = StackPositions.top;\n            else if (i < to)\n                h = StackPositions.bottom;\n\n            if (Math.abs(i - to) > 2) {\n                onComplete = () => {\n                    space.hide();\n                };\n            } else {\n                space.show();\n            }\n            Easer.addEase(actor,\n                {\n                    y: h * space.height,\n                    time: Settings.prefs.animation_time,\n                    scale_x: scale + (to - i) * 0.01,\n                    scale_y: scale + (to - i) * 0.01,\n                    onComplete,\n                });\n        });\n    }\n\n    animateToSpace(to, from, animate = true, callback) {\n        let currentPreviewMode = inPreview;\n        inPreview = PreviewMode.NONE;\n\n        Topbar.updateWorkspaceIndicator(to.index);\n        if (to.hasTopBar) {\n            if (to.showPositionBar) {\n                Topbar.setNoBackgroundStyle();\n            } else {\n                Topbar.setTransparentStyle();\n            }\n        }\n\n        this.selectedSpace = to;\n        to.show();\n        let selected = to.selectedWindow;\n        if (selected)\n            ensureViewport(selected, to);\n\n        if (from) {\n            from.startAnimate();\n        }\n\n        let visible = new Map();\n        for (let [, space] of this.monitors) {\n            visible.set(space, true);\n        }\n\n        let time = animate ? Settings.prefs.animation_time : 0;\n        let onComplete = () => {\n            // Hide any spaces that aren't visible This\n            // avoids a nasty preformance degregration in some\n            // cases\n            for (const space of spaces.values()) {\n                if (!visible.get(space)) {\n                    space.hide();\n                }\n            }\n\n            to.border.hide();\n            to.border.opacity = 255;\n            Utils.actor_raise(to.clip);\n\n            // Fixes a weird bug where mouse input stops\n            // working after mousing to another monitor on\n            // X11.\n            if (!Meta.is_wayland_compositor()) {\n                to.startAnimate();\n            }\n\n            to.moveDone();\n            if (callback) {\n                callback();\n            }\n        };\n\n        if (currentPreviewMode === PreviewMode.SEQUENTIAL) {\n            this._animateToSpaceOrdered(to, animate);\n            let t = to.actor.get_transition('y');\n            if (t) {\n                t.connect('stopped', (timeline, finished) => {\n                    if (finished) {\n                        onComplete();\n                    }\n                });\n            } else {\n                // When switching between monitors there's no animation we can\n                // connect to\n                onComplete();\n            }\n            return;\n        }\n\n        this._updateMonitor();\n        Easer.addEase(to.actor,\n            {\n                x: 0,\n                y: 0,\n                scale_x: 1,\n                scale_y: 1,\n                time,\n                onComplete,\n            });\n\n        // Animate all the spaces above `to` down below the monitor. We get\n        // these spaces by looking at siblings of upper most actor, ie. the\n        // `clip`. This is done since `this.stack` is already updated.\n        let above = to.clip.get_next_sibling();\n        while (above) {\n            let space = above.space;\n            if (!visible.get(space)) {\n                Easer.addEase(space.actor,\n                    {\n                        x: 0, y: space.height + 20,\n                        time,\n                    });\n            }\n            above = above.get_next_sibling();\n        }\n    }\n\n    addSpace(workspace) {\n        let space = new Space(workspace, this.spaceContainer, this._initDone);\n        this.set(workspace, space);\n        this.stack.push(space);\n    }\n\n    removeSpace(space) {\n        this.delete(space.workspace);\n        this.stack.splice(this.stack.indexOf(space), 1);\n        space.destroy();\n    }\n\n    spaceOfWindow(meta_window) {\n        return this.get(meta_window.get_workspace());\n    }\n\n    /**\n     *\n     * @param {import('@gi-types/meta').Workspace} workspace\n     * @returns {Space}\n     */\n    spaceOf(workspace) {\n        return this.get(workspace);\n    }\n\n    /**\n     * Returns the space by it's workspace index value.\n     */\n    spaceOfIndex(workspaceIndex) {\n        let workspace = [...this.keys()].find(w => workspaceIndex === w.index());\n        return this.spaceOf(workspace);\n    }\n\n    /**\n     * Returns the space of a specific uuid.\n     */\n    spaceOfUuid(uuid) {\n        return [...this.values()].find(s => uuid === s.uuid);\n    }\n\n    get selectedSpace() {\n        return this._selectedSpace ?? this.activeSpace;\n    }\n\n    set selectedSpace(space) {\n        this._selectedSpace = space;\n    }\n\n    /**\n     * Returns the currently active space.\n     */\n    get activeSpace() {\n        return this.spaceOf(workspaceManager.get_active_workspace());\n    }\n\n    /**\n     * Returns true if the space is the currently active space.\n     * @param {Space} space\n     * @returns\n     */\n    isActiveSpace(space) {\n        return space === this.activeSpace;\n    }\n\n    /**\n       Return an array of Space's ordered in most recently used order.\n     */\n    mru() {\n        let seen = new Map(), out = [];\n        let active = workspaceManager.get_active_workspace();\n        out.push(this.get(active));\n        seen.set(active, true);\n\n        display.get_tab_list(Meta.TabList.NORMAL_ALL, null)\n            .forEach((metaWindow, _i) => {\n                let workspace = metaWindow.get_workspace();\n                if (!seen.get(workspace)) {\n                    out.push(this.get(workspace));\n                    seen.set(workspace, true);\n                }\n            });\n\n        let workspaces = workspaceManager.get_n_workspaces();\n        for (let i = 0; i < workspaces; i++) {\n            let workspace = workspaceManager.get_workspace_by_index(i);\n            if (!seen.get(workspace)) {\n                out.push(this.get(workspace));\n                seen.set(workspace, true);\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * @param display\n     * @param metaWindow {import(\"@gi-types/meta\").Window}\n     */\n    window_created(metaWindow) {\n        if (!registerWindow(metaWindow)) {\n            return;\n        }\n\n        metaWindow.unmapped = true;\n\n        console.debug('window-created', metaWindow?.title);\n        let actor = metaWindow.get_compositor_private();\n        animateWindow(metaWindow);\n\n        /*\n          We need reliable `window_type`, `wm_class` et. all to handle window insertion correctly.\n\n          On wayland this is completely broken before `first-frame`. It's\n          somewhat more stable on X11, but there's at minimum some racing with\n          `wm_class` which can break the users winprop rules.\n        */\n        signals.connectOneShot(actor, 'first-frame', () => {\n            allocateClone(metaWindow);\n            insertWindow(metaWindow, { existing: false });\n        });\n    }\n};\nSignals.addSignalMethods(Spaces.prototype);\n\n/**\n * Return true if a window is tiled (e.g. not floating, not scratch, not transient).\n * @param metaWindow\n */\nexport function isTiled(metaWindow) {\n    if (\n        !metaWindow ||\n        metaWindow?.is_on_all_workspaces() ||\n        isFloating(metaWindow) ||\n        isScratch(metaWindow) ||\n        isTransient(metaWindow)\n    ) {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Transient windows are connected to a parent window and take focus.\n * On Wayland it takes entire focus (can't focus parent window while it's open).\n * @param metaWindow\n * @returns\n */\nexport function isTransient(metaWindow) {\n    if (!metaWindow) {\n        return false;\n    }\n    if (metaWindow.get_transient_for()) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n/**\n * Returns true if a metaWindow has at least one transient window.\n * @param metaWindow\n * @returns\n */\nexport function hasTransient(metaWindow) {\n    if (!metaWindow) {\n        return false;\n    }\n    let hasTransient = false;\n    metaWindow.foreach_transient(_t => {\n        hasTransient = true;\n    });\n\n    return hasTransient;\n}\n\n/**\n * Conveniece method for checking if a window is floating.\n * Will determine what space this window is on.\n * @param metaWindow\n * @returns\n */\nexport function isFloating(metaWindow) {\n    if (!metaWindow) {\n        return false;\n    }\n    let space = spaces.spaceOfWindow(metaWindow);\n    return space.isFloating?.(metaWindow) ?? false;\n}\n\nexport function isScratch(metaWindow) {\n    if (!metaWindow) {\n        return false;\n    }\n    return Scratch.isScratchWindow(metaWindow);\n}\n\nexport function is_override_redirect(metaWindow) {\n    // Note: is_overrride_redirect() seem to be false for all wayland windows\n    const windowType = metaWindow.windowType;\n    return (\n        metaWindow.is_override_redirect() ||\n        windowType === Meta.WindowType.DROPDOWN_MENU ||\n        windowType === Meta.WindowType.TOOLTIP\n    );\n}\n\nexport function registerWindow(metaWindow) {\n    if (is_override_redirect(metaWindow)) {\n        return false;\n    }\n\n    if (metaWindow.clone) {\n        // Can now happen when setting session-modes to \"unlock-dialog\" or\n        // resetting gnome-shell in-place (e.g. on X11)\n        console.warn(\"window already registered\", metaWindow.title);\n        return false;\n    }\n\n    const actor = metaWindow.get_compositor_private();\n    const cloneActor = new Clutter.Clone({ source: actor });\n    const clone = new Clutter.Actor();\n    clone.add_child(cloneActor);\n\n    // create shade\n    const shade = new St.Widget({ style_class: 'paperwm-clone-shade' });\n    // default opacity\n    clone.add_child(shade);\n    Utils.actor_raise(shade);\n    shade.opacity = 0;\n    shade.hide();\n\n    metaWindow.clone = clone;\n    metaWindow.clone.cloneActor = cloneActor;\n    metaWindow.clone.shade = shade;\n\n    clone.targetX = 0;\n    clone.meta_window = metaWindow;\n\n    signals.connect(metaWindow, \"focus\", (metaWindow, user_data) => {\n        focus_handler(metaWindow, user_data);\n    });\n    signals.connect(metaWindow, 'size-changed', allocateClone);\n    // Note: runs before gnome-shell's minimize handling code\n    signals.connect(metaWindow, 'notify::fullscreen', () => {\n        // if window is in a column, expel it\n        barf(metaWindow, metaWindow);\n\n        /**\n         * Set fullscreen windows to \"always on top\".  This is to ensure\n         * that the fullscreened window is \"above\" modal windows.\n         */\n        if (metaWindow.fullscreen) {\n            // get current \"above\" value (for later restoring)\n            metaWindow._fullscreen_above = metaWindow.is_above();\n            metaWindow.make_above();\n        }\n        else if (metaWindow._fullscreen_above !== null) {\n            if (!metaWindow._fullscreen_above) {\n                metaWindow.unmake_above();\n            }\n            delete metaWindow._fullscreen_above;\n        }\n\n        spaces.spaceOfWindow(metaWindow)?.setSpaceTopbarElementsVisible(true);\n    });\n    signals.connect(metaWindow, 'notify::minimized', metaWindow => {\n        minimizeHandler(metaWindow);\n    });\n\n    signals.connect(metaWindow, 'notify::maximized-horizontally', metaWindow => {\n        if (\n            Settings.prefs.maximize_within_tiling &&\n            metaWindow.get_maximized() === Meta.MaximizeFlags.BOTH) {\n            metaWindow.unmaximize(Meta.MaximizeFlags.BOTH);\n\n            // restore last layout frame\n            if (metaWindow._last_layout_frame) {\n                const lsf = metaWindow._last_layout_frame;\n                metaWindow.move_resize_frame(true, lsf.x, lsf.y, lsf.width, lsf.height);\n            }\n\n            toggleMaximizeHorizontally(metaWindow);\n            // spaces.spaceOfWindow(metaWindow)?.layout();\n        }\n    });\n\n    signals.connect(actor, 'show', actor => {\n        showHandler(actor);\n    });\n\n    /**\n     * Check when moving window that it's targetHeight is correct.\n     */\n    signals.connect(actor, 'stage-views-changed', _actor => {\n        const f = metaWindow.get_frame_rect();\n        if (metaWindow._targetHeight !== f.height) {\n            resizeHandler(metaWindow);\n        }\n    });\n\n    /**\n     * Not all applications (and application states) work well with `stage-views-change`\n     * actor signal (and the resizeHandler).  For example, some apps if too wide\n     * (e.g. full width of tiling window) won't get detected with `stage-views-changed`\n     * signal when it's workspace has changed (e.g. keybind to move to another monitor).\n     * The below works around this issue by continually (up to a number of tries)\n     * checking the height and resizing.\n     */\n    const done = t => {\n        const index = workspaceChangeTimeouts.indexOf(t);\n        workspaceChangeTimeouts.splice(index, 1);\n        // console.log(`num workspaceChangeTimeouts ${workspaceChangeTimeouts.length}`);\n    };\n    signals.connect(metaWindow, 'workspace-changed', mw => {\n        if (!isTiled(mw)) {\n            return;\n        }\n\n        const timeout = Utils.periodic_timeout(\n            {\n                period_ms: 100,\n                count: 10,\n                callback: () => {\n                    const f = metaWindow.get_frame_rect();\n                    if (metaWindow._targetHeight !== f.height) {\n                        if (!isNaN(metaWindow._targetHeight)) {\n                            metaWindow.move_resize_frame(\n                                true,\n                                f.x,\n                                f.y,\n                                f.width,\n                                metaWindow._targetHeight\n                            );\n                        }\n                    }\n                },\n                onComplete: () => {\n                    done(timeout);\n                },\n            }\n        );\n        workspaceChangeTimeouts.push(timeout);\n    });\n\n    signals.connect(actor, 'destroy', destroyHandler);\n    return true;\n}\n\nexport function allocateClone(metaWindow) {\n    if (!metaWindow?.clone) {\n        return;\n    }\n\n    let frame = metaWindow.get_frame_rect();\n    let buffer = metaWindow.get_buffer_rect();\n    // Adjust the clone's origin to the north-west, so it will line up\n    // with the frame.\n    let clone = metaWindow.clone;\n    let cloneActor = clone.cloneActor;\n    cloneActor.set_position(\n        buffer.x - frame.x,\n        buffer.y - frame.y);\n    cloneActor.set_size(buffer.width, buffer.height);\n    clone.set_size(frame.width, frame.height);\n\n    // update shade sizing too, we want it a little bigger\n    const [width, height] = clone.get_size();\n    metaWindow.clone.shade.set_position(-1, -1);\n    metaWindow.clone.shade.set_size(width + 2, height + 2);\n\n    if (metaWindow.clone.first_child.name === 'selection') {\n        let selection = metaWindow.clone.first_child;\n        let vMax = metaWindow.maximized_vertically;\n        let hMax = metaWindow.maximized_horizontally;\n\n        const protrusion = Math.min(\n            Settings.prefs.selection_border_size,\n            Settings.prefs.vertical_margin,\n            Settings.prefs.window_gap\n        );\n\n        selection.x = hMax ? 0 : -protrusion;\n        selection.y = vMax ? 0 : -protrusion;\n        selection.set_size(\n            frame.width + (hMax ? 0 : protrusion * 2),\n            frame.height + (vMax ? 0 : protrusion * 2));\n\n        const rtop = Settings.prefs.selection_border_radius_top;\n        const rbottom = Settings.prefs.selection_border_radius_bottom;\n        selection.style = `border-radius: ${rtop}px ${rtop}px ${rbottom}px ${rbottom}px`;\n    }\n}\n\nexport function destroyHandler(actor) {\n    signals.disconnect(actor);\n}\n\n/**\n * Removes resize, position, and other flags.  Used during cleanup etc.\n * @param {Meta.Window} metaWindow\n */\nexport function removePaperWMFlags(w) {\n    delete w._targetWidth;\n    delete w._targetHeight;\n    delete w._resizeHandlerAdded;\n    delete w._positionHandlerAdded;\n    delete w._pos_mismatch_count;\n    delete w._tiled_on_minimize;\n    delete w._fullscreen_frame;\n    delete w._fullscreen_lock;\n    delete w._fullscreen_above;\n    delete w._last_layout_frame;\n}\n\nexport function addPositionHandler(metaWindow) {\n    if (metaWindow._positionHandlerAdded) {\n        return;\n    }\n    signals.connect(metaWindow, 'position-changed', positionChangeHandler);\n    metaWindow._positionHandlerAdded = true;\n}\n\nexport function addResizeHandler(metaWindow) {\n    if (metaWindow._resizeHandlerAdded) {\n        return;\n    }\n    signals.connect(metaWindow, 'size-changed', mw => {\n        Utils.later_add(Meta.LaterType.RESIZE, () => {\n            resizeHandler(mw);\n        });\n    });\n    metaWindow._resizeHandlerAdded = true;\n}\n\nexport function positionChangeHandler(metaWindow) {\n    // don't update saved position if fullscreen\n    if (metaWindow.fullscreen || metaWindow?._fullscreen_lock) {\n        return;\n    }\n\n    saveFullscreenFrame(metaWindow);\n}\n\nexport function resizeHandler(metaWindow) {\n    // if navigator is showing, reset/refresh it after a window has resized\n    if (Navigator.navigating) {\n        Navigator.getNavigator().minimaps.forEach(m => typeof m !== 'number' && m.reset());\n    }\n\n    if (inGrab && inGrab.window === metaWindow)\n        return;\n\n    const space = spaces.spaceOfWindow(metaWindow);\n    if (!space) {\n        return;\n    }\n\n    const f = metaWindow.get_frame_rect();\n    metaWindow._targetWidth = null;\n    metaWindow._targetHeight = null;\n\n    if (space.indexOf(metaWindow) === -1) {\n        nonTiledSizeHandler(metaWindow);\n        return;\n    }\n\n    const fsf = metaWindow?._fullscreen_frame;\n    const selected = metaWindow === space.selectedWindow;\n    let addCallback = false;\n    let x;\n\n    let needLayout = false;\n    // if target width differs ==> layout\n    if (metaWindow._targetWidth !== f.width || metaWindow._targetHeight !== f.height) {\n        needLayout = true;\n    }\n\n    // if saved size differs ==> layout\n    if (fsf) {\n        if (fsf.width !== f.width || fsf.height !== f.height) {\n            needLayout = true;\n        }\n    }\n\n    const moveTo = (x, animate) => {\n        move_to(space, metaWindow, {\n            x,\n            animate,\n        });\n    };\n\n    // if window is fullscreened, then don't animate background space.container animation etc.\n    if (metaWindow.fullscreen) {\n        metaWindow._fullscreen_lock = true;\n        space.hideSelection();\n        space.layout(false, { callback: moveTo(0, false), centerIfOne: false });\n        return;\n    }\n\n    space.showSelection();\n    x = metaWindow?._fullscreen_frame?.x ?? f.x;\n    x -= space.monitor.x;\n\n    // for non-maximised windows, enforce horizontal margin in restore position\n    if (metaWindow.get_maximized() !== Meta.MaximizeFlags.BOTH &&\n        metaWindow.get_maximized() !== Meta.MaximizeFlags.Horizontal) {\n        x = Math.max(x, Settings.prefs.horizontal_margin);\n    }\n\n\n    // if pwm fullscreen previously\n    if (metaWindow._fullscreen_lock) {\n        space.enableWindowPositionBar();\n        delete metaWindow._fullscreen_lock;\n        needLayout = true;\n        addCallback = true;\n    }\n    else {\n        // save width for later exit-fullscreen restoring\n        saveFullscreenFrame(metaWindow, true);\n    }\n\n    if (needLayout && !space._inLayout) {\n        // Restore window position when eg. exiting fullscreen\n        let callback = () => { };\n        if (addCallback && !Navigator.navigating && selected) {\n            callback = () => {\n                moveTo(x, true);\n            };\n        }\n\n        // Resizing from within a size-changed signal is troube (#73). Queue instead.\n        space.queueLayout(true, { callback, centerIfOne: false });\n    }\n\n    if (space.length === 1) {\n        centerWindow(metaWindow);\n    }\n}\n\n/**\n * ResizeHandler for non-tiled windows\n * @param {*} metaWindow\n */\nexport function nonTiledSizeHandler(metaWindow) {\n    // if window is fullscreen ==> set lock\n    if (metaWindow.fullscreen) {\n        metaWindow._fullscreen_lock = true;\n        return;\n    }\n\n    // if here then was previously in fullscreen (and came out of)\n    if (metaWindow._fullscreen_lock) {\n        delete metaWindow._fullscreen_lock;\n        let fsf = metaWindow._fullscreen_frame;\n        if (fsf) {\n            metaWindow.move_resize_frame(true, fsf.x, fsf.y, fsf.width, fsf.height);\n            delete metaWindow._fullscreen_frame;\n        }\n    }\n    else {\n        saveFullscreenFrame(metaWindow);\n    }\n}\n\n/**\n * Saves a metaWindow's frame x, y ,width, and height for restoring\n * after exiting fullscreen mode.\n * @param {Meta.Window} metaWindow\n */\nexport function saveFullscreenFrame(metaWindow, tiled) {\n    const f = metaWindow.get_frame_rect();\n    const fsf = metaWindow._fullscreen_frame ?? {};\n    metaWindow._fullscreen_frame = fsf;\n    // offset by space's monitor.x\n    fsf.x = f.x;\n    fsf.y = f.y;\n    fsf.width = f.width;\n    fsf.height = f.height;\n\n    // if from tiled, save tiledWidth for tiling width tracking\n    if (tiled) {\n        fsf.tiledWidth = f.width;\n    }\n}\n\n/**\n * Saves current state for controlled restarts of PaperWM.\n */\nclass SaveState {\n    constructor() {\n        this.prevMonitors = new Map();\n        this.prevSpaces = new Map();\n        this.prevTargetX = new Map();\n    }\n\n    hasPrevMonitors() {\n        return this.prevMonitors?.size > 0;\n    }\n\n    hasPrevSpaces() {\n        return this.prevSpaces?.size > 0;\n    }\n\n    hasPrevTargetX() {\n        return this.prevTargetX?.size > 0;\n    }\n\n    getPrevSpaceByUUID(uuid) {\n        return [...this.prevSpaces.values()].find(s => uuid === s.uuid);\n    }\n\n    /**\n     * Updates save state based on current monitors, spaces, and layouts.\n     */\n    update(save = true) {\n        if (!save) {\n            return;\n        }\n\n        /**\n         * For monitors, since these are upgraded with \"connector\" field,\n         * which we delete on disable. Beefore we delete this field, we want\n         * a copy on connector (and index) to restore space to monitor.\n         */\n        if (spaces?.monitors) {\n            for (let [monitor, space] of spaces.monitors) {\n                this.prevMonitors.set(monitor.connector, space.index);\n            }\n        }\n\n        // store space targetx values\n        this.prevTargetX = new Map();\n        spaces.forEach(s => {\n            if (s.getWindows().length > 0 && s.targetX !== 0) {\n                this.prevTargetX.set(s.uuid, s.targetX);\n            }\n        });\n\n        // save spaces (for window restore)\n        this.prevSpaces = new Map(spaces);\n    }\n\n    /**\n     * Prepares state for restoring on next enable.\n     */\n    prepare() {\n        this.update();\n        this.prevSpaces.forEach(space => {\n            let windows = space.getWindows();\n            let selected = windows.indexOf(space.selectedWindow);\n            if (selected === -1)\n                return;\n            // Stack windows correctly for controlled restarts\n            for (let i = selected; i < windows.length; i++) {\n                windows[i].lower();\n            }\n            for (let i = selected; i >= 0; i--) {\n                windows[i].lower();\n            }\n        });\n    }\n}\n\n/**\n * Return the currently focused monitor (or more specifically, the current\n * active space's monitor).\n */\nexport function focusMonitor() {\n    return spaces?.activeSpace?.monitor;\n}\n\n/**\n * Convenience method to run a callback method when an actor is shown the stage.\n * Uses a `connectOneShot` signal.\n * @param actor\n * @param callback\n */\nfunction callbackOnActorShow(actor, callback) {\n    signals.connectOneShot(actor, 'show', callback);\n}\n\n/**\n   Types of windows which never should be tiled.\n */\nexport function add_filter(meta_window) {\n    if (isTransient(meta_window)) {\n        // Never add transient windows\n        return false;\n    }\n    if (meta_window.window_type !== Meta.WindowType.NORMAL) {\n        // And only add Normal windows\n        return false;\n    }\n\n    if (meta_window.is_on_all_workspaces()) {\n        return false;\n    }\n    if (Scratch.isScratchWindow(meta_window)) {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n   Handle windows leaving workspaces.\n */\nexport function remove_handler(workspace, meta_window) {\n    // Note: If `meta_window` was closed and had focus at the time, the next\n    // window has already received the `focus` signal at this point.\n    // Not sure if we can check directly if _this_ window had focus when closed.\n\n    let space = spaces.spaceOf(workspace);\n    space.removeWindow(meta_window);\n    space.enableWindowPositionBar();\n\n    let actor = meta_window.get_compositor_private();\n    if (!actor) {\n        signals.disconnect(meta_window);\n        if (meta_window.clone && meta_window.clone.mapped) {\n            meta_window.clone.destroy();\n            meta_window.clone = null;\n        }\n    }\n}\n\n/**\n   Handle windows entering workspaces.\n*/\nexport function add_handler(_ws, metaWindow) {\n    // Do not handle grabbed windows\n    if (inGrab && inGrab.window === metaWindow)\n        return;\n\n    let actor = metaWindow.get_compositor_private();\n    if (actor) {\n        // Set position and hookup signals, with `existing` set to true\n        insertWindow(metaWindow, { existing: true && !metaWindow.redirected });\n        delete metaWindow.redirected;\n    }\n    // Otherwise we're dealing with a new window, so we let `window-created`\n    // handle initial positioning.\n}\n\n/**\n   Insert the window into its space if appropriate. Requires MetaWindowActor\n\n   This gets called from `Workspace::window-added` if the window already exists,\n   and `Display::window-created` through `WindowActor::show` if window is newly\n   created to ensure that the WindowActor exists.\n*/\nexport function insertWindow(metaWindow, options = {}) {\n    const existing = options?.existing ?? false;\n    const dropping = options?.dropping ?? false;\n    const dropCallback = options?.dropCallback ?? function() {};\n\n    // Add newly created windows to the space being previewed\n    if (!existing &&\n        !metaWindow.is_on_all_workspaces() &&\n        metaWindow.get_workspace() !== spaces.selectedSpace.workspace) {\n        metaWindow.redirected = true;\n        metaWindow.change_workspace(spaces.selectedSpace.workspace);\n        return;\n    }\n\n    const connectSizeChanged = tiled => {\n        if (tiled) {\n            animateWindow(metaWindow);\n        }\n        addResizeHandler(metaWindow);\n        addPositionHandler(metaWindow);\n\n        delete metaWindow.unmapped;\n    };\n\n    const actor = metaWindow.get_compositor_private();\n\n    let overwriteSpace;\n    if (!existing) {\n        /**\n         * Note: Can't trust global.display.focus_window to determine currently focused window.\n         * The mru is more flexible. (global.display.focus_window does not always agree with mru[0]).\n         */\n        let mru = display.get_tab_list(Meta.TabList.NORMAL_ALL, null);\n        let focusWindow = mru[0];\n\n        if (focusWindow === metaWindow) {\n            focusWindow = mru[1];\n        }\n\n        let addToScratch = false;\n\n        let winprop = Settings.find_winprop(metaWindow);\n        if (winprop) {\n            if (winprop.oneshot) {\n                Settings.winprops.splice(Settings.winprops.indexOf(winprop), 1);\n            }\n            if (winprop.scratch_layer) {\n                console.debug(\"#winprops\", `Move ${metaWindow?.title} to scratch`);\n                addToScratch = true;\n            }\n\n            // pass winprop properties to metaWindow\n            metaWindow.preferredWidth = winprop.preferredWidth;\n\n            overwriteSpace = winprop.spaceIndex;\n            if (overwriteSpace !== undefined) {\n                if (typeof overwriteSpace !== \"number\") {\n                    console.error(\"#winprops\", `${overwriteSpace} is not a valid index. Ignoring.`);\n                    overwriteSpace = undefined;\n                }\n                // save temporary as metaWindow property\n                metaWindow.overwriteSpace = overwriteSpace;\n            }\n\n            if (winprop.focus) {\n                console.debug(\"#winprops\", `setting ${metaWindow?.title} to focusOnOpen`);\n                metaWindow.focusOnOpen = true;\n            }\n        }\n\n        if (addToScratch) {\n            connectSizeChanged();\n            Scratch.makeScratch(metaWindow);\n            activateWindowAfterRendered(actor, metaWindow);\n            return;\n        }\n\n        /**\n         * Address inserting windows that are already fullscreen: windows will be inserted\n         * as normal (non-fullscreen) and will be fullscreened after a timeout on actor show.\n         * see https://github.com/paperwm/PaperWM/issues/638\n         */\n        if (metaWindow.fullscreen) {\n            animateWindow(metaWindow);\n            callbackOnActorShow(actor, () => {\n                fullscreenStartTimeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, () => {\n                    metaWindow.unmake_fullscreen();\n                    showWindow(metaWindow);\n                    metaWindow.make_fullscreen();\n                    fullscreenStartTimeout = null;\n                    return false; // on return false destroys timeout\n                });\n            });\n        }\n    }\n\n    if (metaWindow.is_on_all_workspaces()) {\n        // Only connect the necessary signals and show windows on shared\n        // secondary monitors.\n        connectSizeChanged();\n        showWindow(metaWindow);\n        return;\n    } else if (Scratch.isScratchWindow(metaWindow)) {\n        // And make sure scratch windows are stuck\n        Scratch.makeScratch(metaWindow);\n        return;\n    }\n\n    const space = spaces.spaceOfWindow(metaWindow);\n\n    if (overwriteSpace !== undefined) {\n        const newspace = spaces.spaceOfIndex(overwriteSpace);\n        if (!newspace) {\n            Main.notify(\n                `PaperWM [winprop]: cannot open window on workspace ${overwriteSpace} (index)`,\n                `\"${metaWindow?.title}\" cannot be opened on workspace with index ${overwriteSpace} \n(workspace not found). Opening on current workspace instead.`\n            );\n            console.warn(\"#winprops\", `overwriteSpace with index ${overwriteSpace} does not exist. \\\nOpening \"${metaWindow?.title}\" on current space.`);\n        }\n        else {\n            console.debug(\"#winprops\", `inserting window into space ${newspace.name}`);\n            metaWindow.change_workspace(newspace.workspace);\n            metaWindow.foreach_transient(t => {\n                space.addFloating(t);\n            });\n            connectSizeChanged(true);\n            insertWindow(metaWindow, { existing: true });\n            return;\n        }\n    }\n    const active = space.selectedWindow;\n\n    if (!add_filter(metaWindow)) {\n        connectSizeChanged();\n        space.addFloating(metaWindow);\n        // Make sure the window is on the correct monitor\n        metaWindow.move_to_monitor(space.monitor.index);\n        showWindow(metaWindow);\n        // Make sure the window isn't hidden behind the space (eg. dialogs)\n        !existing && metaWindow.make_above();\n        return;\n    }\n\n    if (space.indexOf(metaWindow) !== -1) {\n        return;\n    }\n\n    let clone = metaWindow.clone;\n    let ok, x, y;\n    // Figure out the matching coordinates before the clone is reparented.\n    if (isWindowAnimating(metaWindow)) {\n        let point = clone.apply_transform_to_point(new Graphene.Point3D({ x: 0, y: 0 }));\n        [ok, x, y] = space.cloneContainer.transform_stage_point(point.x, point.y);\n    } else {\n        let frame = metaWindow.get_frame_rect();\n        [ok, x, y] = space.cloneContainer.transform_stage_point(frame.x, frame.y);\n    }\n    ok && clone.set_position(x, y);\n\n    if (!space.addWindow(metaWindow, getOpenWindowPositionIndex(space)))\n        return;\n\n    metaWindow.unmake_above();\n    if (metaWindow.get_maximized() === Meta.MaximizeFlags.BOTH) {\n        metaWindow.unmaximize(Meta.MaximizeFlags.BOTH);\n        toggleMaximizeHorizontally(metaWindow);\n    }\n\n    // run a simple layout in pre-prepare layout\n    space.layout(false);\n\n    const slurpCheck = timeout => {\n        let slurpPosition;\n        switch (Settings.prefs.open_window_position) {\n        case Settings.OpenWindowPositions.DOWN:\n            slurpPosition = SlurpInsertPosition.BELOW;\n            break;\n        case Settings.OpenWindowPositions.UP:\n            slurpPosition = SlurpInsertPosition.ABOVE;\n            break;\n        }\n\n        if (!slurpPosition) {\n            dropCallback(metaWindow);\n            return;\n        }\n\n        // has slurpPosition but no timeout\n        if (!timeout) {\n            slurp(active, slurpPosition);\n            dropCallback(metaWindow);\n            return;\n        }\n\n        // if need to slurp (i.e. vertical stack)\n        stackSlurpTimeout = GLib.timeout_add(\n            GLib.PRIORITY_DEFAULT,\n            100,\n            () => {\n                slurp(active, slurpPosition);\n                dropCallback(metaWindow);\n                return false; // on return false destroys timeout\n            });\n    };\n\n    /**\n     * If window is new, then setup and ensure is in view\n     * after actor is shown on stage.\n     */\n    if (!existing) {\n        clone.x = clone.targetX;\n        clone.y = clone.targetY;\n        space.layout();\n\n        // run focus and resize to ensure new window is correctly shown\n        focus_handler(metaWindow);\n        resizeHandler(metaWindow);\n        connectSizeChanged(true);\n\n        // // remove winprop props after window shown\n        callbackOnActorShow(actor, () => {\n            delete metaWindow.preferredWidth;\n\n            Main.activateWindow(metaWindow);\n            ensureViewport(space.selectedWindow, space);\n            space.setSpaceTopbarElementsVisible(true);\n\n            slurpCheck(true);\n        });\n\n        return;\n    }\n\n    space.layout();\n    animateWindow(metaWindow);\n    if (metaWindow.overwriteSpace !== undefined) {\n        delete metaWindow.overwriteSpace;\n        if (!metaWindow.focusOnOpen) {\n            return;\n        }\n        else {\n            delete metaWindow.focusOnOpen;\n            console.debug(\"#winprops\", \"focusing space of inserted window\");\n            spaces.spaceOfWindow(metaWindow)?.activateWithFocus(metaWindow, false, true);\n        }\n    }\n\n    if (metaWindow === display.focus_window) {\n        focus_handler(metaWindow);\n    } else if (space === spaces.activeSpace) {\n        Main.activateWindow(metaWindow);\n    } else {\n        ensureViewport(space.selectedWindow, space);\n    }\n\n    if (dropping) {\n        slurpCheck(false);\n    }\n}\n\n/**\n * Gets the window index to add a new window in the space:\n * { RIGHT: 0, LEFT: 1, START: 2, END: 3 };\n */\nexport function getOpenWindowPositionIndex(space) {\n    let index = -1; // init (-1 -> at beginning)\n    if (space?.selectedWindow) {\n        index = space.indexOf(space.selectedWindow);\n    }\n\n    const pos = Settings.prefs.open_window_position;\n    switch (pos) {\n    case Settings.OpenWindowPositions.LEFT:\n        return index;\n    case Settings.OpenWindowPositions.START:\n        return 0;\n    case Settings.OpenWindowPositions.END:\n        // get number of columns in space\n        return space.length + 1;\n    default:\n        return index + 1;\n    }\n}\n\nexport function animateDown(metaWindow) {\n    let space = spaces.spaceOfWindow(metaWindow);\n    let workArea = space.workArea();\n    Easer.addEase(metaWindow.clone, {\n        y: workArea.y,\n        time: Settings.prefs.animation_time,\n    });\n}\n\nexport function ensuredX(meta_window, space) {\n    let index = space.indexOf(meta_window);\n    let last = space.selectedWindow;\n    let lastIndex = space.indexOf(last);\n    let neighbour = Math.abs(lastIndex - index) <= 1;\n\n    let monitor = space.monitor;\n    let frame = meta_window.get_frame_rect();\n    let clone = meta_window.clone;\n\n    let x;\n    if (neighbour || space.isVisible(meta_window) || meta_window.lastFrame === undefined)\n        x = Math.round(clone.targetX) + space.targetX;\n    else\n        x = meta_window.lastFrame.x - monitor.x;\n    let workArea = space.workArea();\n    let min = workArea.x;\n    let max = min + workArea.width;\n\n    if (space.focusMode === FocusModes.CENTER) {\n        // window switching should centre focus\n        x = workArea.x + Math.round(workArea.width / 2 - frame.width / 2);\n    } else if (meta_window.fullscreen) {\n        x = 0;\n    } else if (space.focusMode === FocusModes.EDGE) {\n        // Align to the closest edge, with special cases for\n        // only (center), first (left), and last (right) windows\n        if (index === 0 && space.length === 1)\n            x = min + Math.round((workArea.width - frame.width) / 2);\n        else if (index === 0 || (Math.abs(x - min) < Math.abs(x + frame.width - max) &&\n            index !== space.length - 1))\n            x = min + Settings.prefs.horizontal_margin;\n        else\n            x = max - Settings.prefs.horizontal_margin - frame.width;\n    } else if (frame.width > workArea.width * 0.9 - 2 * (Settings.prefs.horizontal_margin + Settings.prefs.window_gap)) {\n        // Consider the window to be wide and center it\n        x = min + Math.round((workArea.width - frame.width) / 2);\n    } else if (x + frame.width > max) {\n        // Align to the right prefs.horizontal_margin\n        x = max - Settings.prefs.horizontal_margin - frame.width;\n    } else if (x < min) {\n        // Align to the left prefs.horizontal_margin\n        x = min + Settings.prefs.horizontal_margin;\n    } else if (x + frame.width === max) {\n        // When opening new windows at the end, in the background, we want to\n        // show some minimup margin\n        x = max - Settings.prefs.minimum_margin - frame.width;\n    } else if (x === min) {\n        // Same for the start (though the case isn't as common)\n        x = min + Settings.prefs.minimum_margin;\n    }\n\n    return x;\n}\n\n/**\n   Make sure that `meta_window` is in view, scrolling the space if needed.\n * @param meta_window\n * @param {Space} space\n * @param {Object} options\n * @param {boolean} options.force\n * @param {boolean} options.moveto if true, executes a move_to animated action\n * @returns\n */\nexport function ensureViewport(meta_window, space, options = {}) {\n    space = space ?? spaces.spaceOfWindow(meta_window);\n    let force = options?.force ?? false;\n    let moveto = options?.moveto ?? true;\n    let animate = options?.animate ?? true;\n    let ensureAnimation = options.ensureAnimation ?? Settings.EnsureViewportAnimation.TRANSLATE;\n    let callback = options.callback ?? function () { };\n\n    let index = space.indexOf(meta_window);\n    if (index === -1 || space.length === 0)\n        return undefined;\n\n    if (space.selectedWindow.fullscreen &&\n        !meta_window.fullscreen) {\n        animateDown(space.selectedWindow);\n    }\n    let x = ensuredX(meta_window, space);\n\n    space.selectedWindow = meta_window;\n    let selected = space.selectedWindow;\n    if (!inPreview && selected.fullscreen) {\n        let y = 0;\n        let ty = selected.clone.get_transition('y');\n        if (!space.isVisible(selected)) {\n            selected.clone.y = y;\n        } else if (!ty || ty.get_interval().final !== y) {\n            Easer.addEase(selected.clone,\n                {\n                    y,\n                    time: Settings.prefs.animation_time,\n                    onComplete: space.moveDone.bind(space),\n                });\n        }\n    }\n\n    if (moveto) {\n        move_to(space, meta_window, {\n            x,\n            force,\n            animate,\n            ensureAnimation,\n            callback,\n        });\n    }\n\n    selected.raise();\n    Utils.actor_raise(selected.clone);\n    updateSelection(space, meta_window);\n    space.emit('select');\n}\n\nexport function updateSelection(space, metaWindow) {\n    if (!metaWindow) {\n        return;\n    }\n    let clone = metaWindow.clone;\n    let cloneActor = clone.cloneActor;\n\n    // first set all selections inactive\n    // this means not active workspaces are shown as inactive\n    setAllWorkspacesInactive();\n\n    // if metawindow has transient window(s) and it's NOT focused,\n    // don't update visual selection (since transient is actually focused)\n    if (hasTransient(metaWindow) && metaWindow !== display.focus_window) {\n        space.setSelectionInactive();\n    }\n    else {\n        // then set the new selection active\n        space.setSelectionActive();\n    }\n\n    space.updateWindowPositionBar();\n\n    if (space.selection.get_parent() === clone)\n        return;\n    Utils.actor_reparent(space.selection, clone);\n    clone.set_child_below_sibling(space.selection, cloneActor);\n    allocateClone(metaWindow);\n}\n\n/**\n * Move the column containing @meta_window to x, y and propagate the change\n * in @space. Coordinates are relative to monitor and y is optional.\n */\nexport function move_to(space, metaWindow, options = {}) {\n    let x = options.x ?? 0;\n    let force = options.force ?? false;\n    let animate = options.animate ?? true;\n    let ensureAnimation = options.ensureAnimation ?? Settings.EnsureViewportAnimation.TRANSLATE;\n    let callback = options.callback ?? function () { };\n    if (space.indexOf(metaWindow) === -1)\n        return;\n\n    let clone = metaWindow.clone;\n    let target = x - clone.targetX;\n    if (target === space.targetX && !force) {\n        space.moveDone();\n        callback();\n        return;\n    }\n\n    const done = () => {\n        space.moveDone();\n        space.fixOverlays(metaWindow);\n        callback();\n    };\n\n    space.targetX = target;\n    if (space.cloneContainer.x === target ||\n        Main.overview.visible) {\n        // Do the move immediately, and let the overview take care of animation\n        space.cloneContainer.x = target;\n        done();\n        return;\n    }\n\n    // if here need to animate\n    space.startAnimate();\n    if (!animate ||\n        ensureAnimation === Settings.EnsureViewportAnimation.NONE) {\n        space.cloneContainer.x = target;\n        Easer.addEase(space.cloneContainer, {\n            instant: true,\n            onComplete: () => done(),\n        });\n    }\n    else if (ensureAnimation === Settings.EnsureViewportAnimation.FADE) {\n        space.cloneContainer.x = target;\n        space.cloneContainer.opacity = 0;\n        Easer.addEase(space.cloneContainer, {\n            opacity: 255,\n            time: Settings.prefs.animation_time,\n            onComplete: () => done(),\n        });\n    }\n    else {\n        Easer.addEase(space.cloneContainer, {\n            x: target,\n            time: Settings.prefs.animation_time,\n            onComplete: () => done(),\n        });\n    }\n}\n\nexport function grabBegin(metaWindow, type) {\n    switch (type) {\n    case Meta.GrabOp.COMPOSITOR:\n    case Meta.GrabOp.FRAME_BUTTON:\n        // Don't handle pushModal grabs and SCD button (close/minimize/etc.) grabs\n        break;\n    case Meta.GrabOp.KEYBOARD_MOVING:\n        inGrab = new Grab.MoveGrab(metaWindow, type);\n        if (!isTiled(metaWindow)) {\n            return;\n        }\n\n        // NOTE: Keyboard grab moves the cursor, but it happens after grab\n        // signals have run. Simply delay the dnd so it will get the correct\n        // pointer coordinates.\n        Utils.later_add(Meta.LaterType.IDLE, () => {\n            inGrab.begin();\n            inGrab.beginDnD();\n        });\n        break;\n    case Meta.GrabOp.MOVING:\n    case Meta.GrabOp.MOVING_UNCONSTRAINED: // introduced in Gnome 44\n        if (!isTiled(metaWindow)) {\n            return;\n        }\n\n        inGrab = new Grab.MoveGrab(metaWindow, type);\n\n        if (Utils.getModiferState() & Clutter.ModifierType.CONTROL_MASK) {\n            inGrab.begin();\n            inGrab.beginDnD();\n        } else if (inGrab.initialSpace && inGrab.initialSpace.indexOf(metaWindow) > -1) {\n            inGrab.begin();\n        }\n\n        break;\n    case Meta.GrabOp.RESIZING_NW:\n    case Meta.GrabOp.RESIZING_N:\n    case Meta.GrabOp.RESIZING_NE:\n    case Meta.GrabOp.RESIZING_E:\n    case Meta.GrabOp.RESIZING_SW:\n    case Meta.GrabOp.RESIZING_S:\n    case Meta.GrabOp.RESIZING_SE:\n    case Meta.GrabOp.RESIZING_W:\n    case Meta.GrabOp.KEYBOARD_RESIZING_UNKNOWN:\n    case Meta.GrabOp.KEYBOARD_RESIZING_NW:\n    case Meta.GrabOp.KEYBOARD_RESIZING_N:\n    case Meta.GrabOp.KEYBOARD_RESIZING_NE:\n    case Meta.GrabOp.KEYBOARD_RESIZING_E:\n    case Meta.GrabOp.KEYBOARD_RESIZING_SW:\n    case Meta.GrabOp.KEYBOARD_RESIZING_S:\n    case Meta.GrabOp.KEYBOARD_RESIZING_SE:\n    case Meta.GrabOp.KEYBOARD_RESIZING_W:\n        inGrab = new Grab.ResizeGrab();\n        break;\n    }\n}\n\nexport function grabEnd(_metaWindow, _type) {\n    if (!inGrab || inGrab.dnd || inGrab.grabbed)\n        return;\n\n    inGrab.end();\n    inGrab = false;\n}\n\n/**\n * Sets the selected window on other workspaces inactive.\n * Particularly noticable with multi-monitor setups.\n */\nexport function setAllWorkspacesInactive() {\n    spaces.forEach(s => s.setSelectionInactive());\n}\n\n/**\n * Returns the default focus mode (can be user-defined).\n */\nexport function getDefaultFocusMode() {\n    // find matching focus mode\n    const mode = Settings.prefs.default_focus_mode;\n    const modes = FocusModes;\n    let result = null;\n    Object.entries(modes).forEach(([k, v]) => {\n        if (v === mode) {\n            result = k;\n        }\n    });\n\n    // if found return, otherwise return default\n    if (result) {\n        return modes[result];\n    } else {\n        return modes.DEFAULT;\n    }\n}\n\n// `MetaWindow::focus` handling\nexport function focus_handler(metaWindow) {\n    console.debug(\"focus:\", metaWindow?.title);\n    if (Scratch.isScratchWindow(metaWindow)) {\n        setAllWorkspacesInactive();\n        Scratch.makeScratch(metaWindow);\n        Topbar.fixTopBar();\n        return;\n    }\n\n    // If metaWindow is a transient window, return (after deselecting tiled focus indicators)\n    if (isTransient(metaWindow)) {\n        setAllWorkspacesInactive();\n        return;\n    }\n\n    let space = spaces.spaceOfWindow(metaWindow);\n\n    // if window is on another monitor then warp pointer there\n    if (!Main.overview.visible &&\n        Utils.monitorAtCurrentPoint() !== space.monitor) {\n        Utils.warpPointerToMonitor(space.monitor);\n    }\n\n    if (metaWindow.fullscreen) {\n        space.enableWindowPositionBar(false);\n        space.setSpaceTopbarElementsVisible(false);\n        space.hideSelection();\n        if (!metaWindow.is_above()) {\n            metaWindow.make_above();\n        }\n    }\n    else {\n        space.getWindows().filter(w => w.fullscreen).forEach(w => {\n            if (\n                w._fullscreen_above !== null &&\n                !w._fullscreen_above\n            ) {\n                w.unmake_above();\n            }\n        });\n\n        let needLayout = false;\n        /**\n         * If has fullscreen window - when selected non-fullscreen window, do layout:\n         * For non-topbar spaces, Bring down fullscreen windows to mimic gnome behaviour with a topbar,\n         * Also ensures if columns group, then it's windows are correctly proportioned.\n         */\n        if (space.hasFullScreenWindow()) {\n            needLayout = true;\n        }\n\n        /**\n         * if there then clone.y shouldn't be 0.  This can happen though if a window\n         * is fullscreened when `layout` is called.  In this case, when we focuse on a\n         * window that isn't fullscreen but has clone.y 0 ==> need a layout call.\n         */\n        if (\n            metaWindow.clone.y === 0 &&\n            Settings.prefs.vertical_margin !== 0 &&\n            Settings.prefs.window_gap !== 0\n        ) {\n            needLayout = true;\n        }\n\n        if (needLayout) {\n            space.layout(false);\n        }\n\n        space.setSpaceTopbarElementsVisible(true);\n        space.enableWindowPositionBar(true);\n        space.showSelection();\n    }\n    space.monitor.clickOverlay.show();\n\n    /**\n       Find the closest neighbours. Remove any dead windows in the process to\n       work around the fact that `focus` runs before `window-removed` (and there\n       doesn't seem to be a better signal to use)\n     */\n    let windows = space.getWindows();\n    let around = windows.indexOf(metaWindow);\n    if (around === -1)\n        return;\n\n    let neighbours = [];\n    for (let i = around - 1; i >= 0; i--) {\n        let w = windows[i];\n        if (w.get_compositor_private()) {\n            neighbours.push(windows[i]);\n            break;\n        }\n        space.removeWindow(w);\n    }\n    for (let i = around + 1; i < windows.length; i++) {\n        let w = windows[i];\n        if (w.get_compositor_private()) {\n            neighbours.push(windows[i]);\n            break;\n        }\n        space.removeWindow(w);\n    }\n\n    /**\n       We need to stack windows in mru order, since mutter picks from the\n       stack, not the mru, when auto choosing focus after closing a window.\n    */\n    let stack = sortWindows(space, neighbours);\n    stack.forEach(w => w.raise());\n    metaWindow.raise();\n\n    /**\n     * Call to move viewport to metaWindow, except if in overview - if in\n     * overview, we'll ensure viewport on focused window AFTER overview is\n     * hidden.\n     */\n    ensureViewport(metaWindow, space, { moveto: !Main.overview.visible });\n\n    Topbar.fixTopBar();\n}\n\n/**\n   Push all minimized windows to the scratch layer\n */\nexport function minimizeHandler(metaWindow) {\n    if (metaWindow.minimized) {\n        console.debug('minimized', metaWindow?.title);\n        // check if was tiled\n        if (isTiled(metaWindow)) {\n            metaWindow._tiled_on_minimize = true;\n        }\n        Scratch.makeScratch(metaWindow);\n    }\n    else {\n        console.debug('unminimized', metaWindow?.title);\n        if (metaWindow._tiled_on_minimize) {\n            delete metaWindow._tiled_on_minimize;\n            Utils.later_add(Meta.LaterType.IDLE, () => {\n                Scratch.unmakeScratch(metaWindow);\n            });\n        }\n    }\n}\n\n/**\n  `WindowActor::show` handling\n\n  Kill any falsely shown WindowActor.\n*/\nexport function showHandler(actor) {\n    let metaWindow = actor.meta_window;\n    let onActive = metaWindow.get_workspace() === workspaceManager.get_active_workspace();\n\n    if (!metaWindow.clone.get_parent() && !metaWindow.unmapped)\n        return;\n\n    if (metaWindow.unmapped) {\n        return;\n    }\n\n    if (!onActive ||\n        isWindowAnimating(metaWindow) ||\n        // The built-in workspace-change animation is running: suppress it\n        actor.get_parent() !== global.window_group\n    ) {\n        animateWindow(metaWindow);\n    }\n}\n\nexport function showWindow(metaWindow) {\n    let actor = metaWindow.get_compositor_private();\n    if (!actor)\n        return false;\n    if (metaWindow.clone?.cloneActor) {\n        metaWindow.clone.cloneActor.hide();\n        metaWindow.clone.cloneActor.source = null;\n    }\n    actor.show();\n    return true;\n}\n\nexport function animateWindow(metaWindow) {\n    let actor = metaWindow.get_compositor_private();\n    if (!actor)\n        return false;\n    if (metaWindow.clone?.cloneActor) {\n        metaWindow.clone.cloneActor.show();\n        metaWindow.clone.cloneActor.source = actor;\n    }\n    actor.hide();\n    return true;\n}\n\nexport function isWindowAnimating(metaWindow) {\n    let clone = metaWindow.clone;\n    return clone.get_parent() && clone.cloneActor.visible;\n}\n\nexport function toggleMaximizeHorizontally(metaWindow) {\n    metaWindow = metaWindow || display.focus_window;\n\n    if (metaWindow.get_maximized() === Meta.MaximizeFlags.BOTH) {\n        // ASSUMPTION: MaximizeFlags.HORIZONTALLY is not used\n        metaWindow.unmaximize(Meta.MaximizeFlags.BOTH);\n        metaWindow.unmaximizedRect = null;\n        return;\n    }\n\n    let maxWidthPrc = Settings.prefs.maximize_width_percent;\n    // add some sane limits to width percents: 0.5 <= x <= 1.0\n    maxWidthPrc = Math.max(0.5, maxWidthPrc);\n    maxWidthPrc = Math.min(1.0, maxWidthPrc);\n\n    let space = spaces.spaceOfWindow(metaWindow);\n    let workArea = space.workArea();\n    let frame = metaWindow.get_frame_rect();\n    let reqWidth = maxWidthPrc * workArea.width - Settings.prefs.minimum_margin * 2;\n\n    // Some windows only resize in increments > 1px so we can't rely on a precise width\n    // Hopefully this heuristic is good enough\n    let isFullWidth = (reqWidth - frame.width) < sizeSlack;\n\n    if (isFullWidth && metaWindow.unmaximizedRect) {\n        let unmaximizedRect = metaWindow.unmaximizedRect;\n        metaWindow.move_resize_frame(\n            true, unmaximizedRect.x, frame.y,\n            unmaximizedRect.width, frame.height);\n\n        metaWindow.unmaximizedRect = null;\n    } else {\n        let x = workArea.x + space.monitor.x + Settings.prefs.minimum_margin;\n        metaWindow.unmaximizedRect = frame;\n        metaWindow.move_resize_frame(true, x, frame.y, reqWidth, frame.height);\n    }\n}\n\nexport function resizeHInc(metaWindow) {\n    metaWindow = metaWindow || display.focus_window;\n    let frame = metaWindow.get_frame_rect();\n    let space = spaces.spaceOfWindow(metaWindow);\n    let workArea = space.workArea();\n\n    let maxHeight = workArea.height - Settings.prefs.horizontal_margin * 2 - Settings.prefs.window_gap;\n    let step = Math.floor(maxHeight * 0.1);\n    let currentHeight = Math.round(frame.height / step) * step;\n    let targetHeight = Math.min(currentHeight + step, maxHeight);\n    let targetY = frame.y;\n\n    if (metaWindow.get_maximized() === Meta.MaximizeFlags.BOTH) {\n        metaWindow.unmaximize(Meta.MaximizeFlags.BOTH);\n    }\n\n    // Space.layout will ensure the window is moved if necessary\n    metaWindow.move_resize_frame(true, frame.x, targetY, frame.width, targetHeight);\n}\n\nexport function resizeHDec(metaWindow) {\n    metaWindow = metaWindow || display.focus_window;\n    let frame = metaWindow.get_frame_rect();\n    let space = spaces.spaceOfWindow(metaWindow);\n    let workArea = space.workArea();\n\n    let maxHeight = workArea.height - Settings.prefs.horizontal_margin * 2 - Settings.prefs.window_gap;\n    let step = Math.floor(maxHeight * 0.1);\n    let currentHeight = Math.round(frame.height / step) * step;\n    let minHeight = step;\n    let targetHeight = Math.max(currentHeight - step, minHeight);\n    let targetY = frame.y;\n\n    if (metaWindow.get_maximized() === Meta.MaximizeFlags.BOTH) {\n        metaWindow.unmaximize(Meta.MaximizeFlags.BOTH);\n    }\n\n    // Space.layout will ensure the window is moved if necessary\n    metaWindow.move_resize_frame(true, frame.x, targetY, frame.width, targetHeight);\n}\n\nexport function resizeWInc(metaWindow) {\n    metaWindow = metaWindow || display.focus_window;\n    let frame = metaWindow.get_frame_rect();\n    let space = spaces.spaceOfWindow(metaWindow);\n    let workArea = space.workArea();\n\n    let maxWidth = workArea.width - Settings.prefs.horizontal_margin * 2 - Settings.prefs.window_gap;\n    let step = Math.floor(maxWidth * 0.1);\n    let currentWidth = Math.round(frame.width / step) * step;\n    let targetWidth = Math.min(currentWidth + step, maxWidth);\n    let targetX = frame.x;\n\n    if (metaWindow.get_maximized() === Meta.MaximizeFlags.BOTH) {\n        metaWindow.unmaximize(Meta.MaximizeFlags.BOTH);\n    }\n\n    // Space.layout will ensure the window is moved if necessary\n    metaWindow.move_resize_frame(true, targetX, frame.y, targetWidth, frame.height);\n}\n\nexport function resizeWDec(metaWindow) {\n    metaWindow = metaWindow || display.focus_window;\n    let frame = metaWindow.get_frame_rect();\n    let space = spaces.spaceOfWindow(metaWindow);\n    let workArea = space.workArea();\n\n    let maxWidth = workArea.width - Settings.prefs.horizontal_margin * 2 - Settings.prefs.window_gap;\n    let step = Math.floor(maxWidth * 0.1);\n    let currentWidth = Math.round(frame.width / step) * step;\n    let minWidth = step;\n    let targetWidth = Math.max(currentWidth - step, minWidth);\n    let targetX = frame.x;\n\n    if (metaWindow.get_maximized() === Meta.MaximizeFlags.BOTH) {\n        metaWindow.unmaximize(Meta.MaximizeFlags.BOTH);\n    }\n\n    // Space.layout will ensure the window is moved if necessary\n    metaWindow.move_resize_frame(true, targetX, frame.y, targetWidth, frame.height);\n}\n\nexport function getCycleWindowWidths(metaWindow) {\n    let steps = Settings.prefs.cycle_width_steps;\n    let space = spaces.spaceOfWindow(metaWindow);\n    let workArea = space.workArea();\n\n    if (steps[0] <= 1) {\n        // Steps are specifed as ratios -> convert to pixels\n        // Make sure two windows of \"compatible\" width will have room:\n        let availableWidth = workArea.width - Settings.prefs.horizontal_margin * 2 - Settings.prefs.window_gap;\n        steps = steps.map(x => Math.floor(x * availableWidth));\n    }\n\n    return steps;\n}\n\nexport function cycleWindowWidth(metawindow) {\n    return cycleWindowWidthDirection(metawindow, CycleWindowSizesDirection.FORWARD);\n}\n\nexport function cycleWindowWidthBackwards(metawindow) {\n    return cycleWindowWidthDirection(metawindow, CycleWindowSizesDirection.BACKWARDS);\n}\n\nexport function cycleWindowWidthDirection(metaWindow, direction) {\n    let frame = metaWindow.get_frame_rect();\n    let space = spaces.spaceOfWindow(metaWindow);\n    let workArea = space.workArea();\n    workArea.x += space.monitor.x;\n\n    let findFn = direction === CycleWindowSizesDirection.FORWARD ? Lib.findNext : Lib.findPrev;\n\n    // 10px slack to avoid locking up windows that only resize in increments > 1px\n    let targetWidth = Math.min(\n        findFn(frame.width, getCycleWindowWidths(metaWindow), sizeSlack),\n        workArea.width\n    );\n\n    let targetX = frame.x;\n\n    if (Scratch.isScratchWindow(metaWindow)) {\n        if (targetX + targetWidth > workArea.x + workArea.width - Settings.prefs.minimum_margin) {\n            // Move the window so it remains fully visible\n            targetX = workArea.x + workArea.width - Settings.prefs.minimum_margin - targetWidth;\n        }\n    }\n\n    if (metaWindow.get_maximized() === Meta.MaximizeFlags.BOTH) {\n        metaWindow.unmaximize(Meta.MaximizeFlags.BOTH);\n    }\n\n    // Space.layout will ensure the window is moved if necessary\n    metaWindow.move_resize_frame(true, targetX, frame.y, targetWidth, frame.height);\n}\n\nexport function cycleWindowHeight(metawindow) {\n    return cycleWindowHeightDirection(metawindow, CycleWindowSizesDirection.FORWARD);\n}\n\nexport function cycleWindowHeightBackwards(metawindow) {\n    return cycleWindowHeightDirection(metawindow, CycleWindowSizesDirection.BACKWARDS);\n}\n\nexport function cycleWindowHeightDirection(metaWindow, direction) {\n    let steps = Settings.prefs.cycle_height_steps;\n    let frame = metaWindow.get_frame_rect();\n\n    let space = spaces.spaceOfWindow(metaWindow);\n    let i = space.indexOf(metaWindow);\n\n    let findFn = direction === CycleWindowSizesDirection.FORWARD ? Lib.findNext : Lib.findPrev;\n\n    function calcTargetHeight(available) {\n        let targetHeight;\n        if (steps[0] <= 1) { // ratio steps\n            let targetR = findFn(frame.height / available, steps, sizeSlack / available);\n            targetHeight = Math.floor(targetR * available);\n        } else { // pixel steps\n            targetHeight = findFn(frame.height, steps, sizeSlack);\n        }\n        return Math.min(targetHeight, available);\n    }\n\n    if (i > -1) {\n        const allocate = (column, available) => {\n            // NB: important to not retrieve the frame size inside allocate. Allocation of\n            // metaWindow should stay the same during a potential fixpoint evaluation.\n            available -= (column.length - 1) * Settings.prefs.window_gap;\n            let targetHeight = calcTargetHeight(available);\n            return column.map(mw => {\n                if (mw === metaWindow) {\n                    return targetHeight;\n                } else {\n                    return Math.floor((available - targetHeight) / (column.length - 1));\n                }\n            });\n        };\n\n        if (space[i].length > 1) {\n            space.layout(false, { customAllocators: { [i]: allocate } });\n        }\n    } else {\n        // Not in tiling\n        let workspace = metaWindow.get_workspace();\n        let available = workspace.get_work_area_for_monitor(metaWindow.get_monitor()).height;\n        let targetHeight = calcTargetHeight(available);\n        metaWindow.move_resize_frame(true, frame.x, frame.y, frame.width, targetHeight);\n    }\n}\n\nexport function activateNthWindow(n, space) {\n    space = space || spaces.activeSpace;\n    let nth = space[n][0];\n    ensureViewport(nth, space);\n}\n\nexport function activateFirstWindow(_mw, space) {\n    space = space || spaces.activeSpace;\n    activateNthWindow(0, space);\n}\n\nexport function activateLastWindow(_mw, space) {\n    space = space || spaces.activeSpace;\n    activateNthWindow(space.length - 1, space);\n}\n\n/**\n * Calls `activateWindow` only after an actor is visible and rendered on the stage.\n * The standard `Main.activateWindow(mw)` should be used in general, but this method\n * may be requried under certain use cases (such as activating a floating window\n * programmatically before it's rendered, see\n * https://github.com/paperwm/PaperWM/issues/448 for details).\n */\nfunction activateWindowAfterRendered(actor, mw) {\n    callbackOnActorShow(actor, () => {\n        Main.activateWindow(mw);\n    });\n}\n\n/**\n * Centers the currently selected window.\n */\nexport function centerWindow(metaWindow, horizontal = true, vertical = false) {\n    const frame = metaWindow.get_frame_rect();\n    const space = spaces.spaceOfWindow(metaWindow);\n    const monitor = space.monitor;\n    const workArea = space.workArea();\n\n    const targetX = horizontal ? workArea.x + Math.round((workArea.width - frame.width) / 2) : frame.x;\n    let targetY = vertical ? workArea.y + Math.round((workArea.height - frame.height) / 2) : frame.y;\n    targetY = Math.max(targetY, workArea.y);\n    if (space.indexOf(metaWindow) === -1) {\n        Scratch.easeScratch(metaWindow, targetX + monitor.x, targetY + monitor.y);\n    } else {\n        move_to(space, metaWindow, {\n            x: targetX,\n        });\n    }\n}\n\n/**\n * Activates the window under the mouse cursor, if any.\n */\nexport function activateWindowUnderCursor(metaWindow, space) {\n    const [gx, gy] = global.get_pointer();\n    const [, x, y] = space.actor.transform_stage_point(gx, gy);\n    const mw = space?.getWindowAtPoint(x, y);\n    if (mw) {\n        ensureViewport(mw, space);\n    }\n}\n\n/**\n * Sets the focus mode for a space.\n * @param {FocusModes} mode\n * @param {Space} space\n */\nexport function setFocusMode(mode, space) {\n    space = space ?? spaces.activeSpace;\n    space.focusMode = mode;\n    space.focusModeIcon.setMode(mode);\n    if (space.hasTopBar) {\n        Topbar.focusButton.setFocusMode(mode);\n    }\n\n    const workArea = space.workArea();\n    const selectedWin = space.selectedWindow;\n    // if centre also center selectedWindow\n    switch (mode) {\n    case FocusModes.CENTER:\n        if (selectedWin) {\n            // check it closer to min or max of workArea\n            const frame = selectedWin.get_frame_rect();\n            const winMidpoint = space.visibleX(selectedWin) + frame.width / 2;\n            const workAreaMidpoint = workArea.width / 2;\n            if (winMidpoint <= workAreaMidpoint) {\n                space.unfocusXPosition = 0;\n            } else {\n                space.unfocusXPosition = workArea.width;\n            }\n            centerWindow(selectedWin);\n        }\n        break;\n    default:\n        // for other modes run a `layout` call to action the mode\n        space.layout();\n        break;\n    }\n\n    // if normal and has saved x position from previous\n    // eslint-disable-next-line eqeqeq\n    if (mode === FocusModes.DEFAULT && space.unfocusXPosition != null) {\n        // if window is first, move to left edge\n        let position;\n        // eslint-disable-next-line eqeqeq\n        if (space.indexOf(selectedWin) == 0) {\n            position = 0;\n        }\n        // if windows is last, move to right edge\n        // eslint-disable-next-line eqeqeq\n        else if (space.indexOf(selectedWin) == space.length - 1) {\n            position = workArea.width;\n        }\n        else {\n            position = space.unfocusXPosition;\n        }\n        // do the move\n        move_to(space, space.selectedWindow, { x: position });\n        ensureViewport(space.selectedWindow, space, { force: true });\n        space.unfocusXPosition = null;\n    }\n}\n\n/**\n * Switches to the next focus mode for a space.\n * @param {Space} space\n */\nexport function switchToNextFocusMode(space) {\n    space = space ?? spaces.activeSpace;\n    const numModes = Object.keys(FocusModes).length;\n    // for currMode we switch to 1-based to use it validly in remainder operation\n    const currMode = Object.values(FocusModes).indexOf(space.focusMode) + 1;\n    const nextMode = currMode % numModes;\n    setFocusMode(nextMode, space);\n}\n\n/**\n * \"Fit\" values such that they sum to `targetSum`\n */\nexport function fitProportionally(values, targetSum) {\n    let sum = Lib.sum(values);\n    let weights = values.map(v => v / sum);\n\n    let fitted = Lib.zip(values, weights).map(\n        ([_h, w]) => Math.round(targetSum * w)\n    );\n    let r = targetSum - Lib.sum(fitted);\n    fitted[0] += r;\n    return fitted;\n}\n\nexport function allocateDefault(column, availableHeight, selectedWindow) {\n    if (column.length === 1) {\n        return [availableHeight];\n    } else {\n        // Distribute available height amongst non-selected windows in proportion to their existing height\n        const gap = Settings.prefs.window_gap;\n        const minHeight = 50;\n\n        const heightOf = mw => {\n            return mw._targetHeight || mw.get_frame_rect().height;\n        };\n\n        const k = selectedWindow && column.indexOf(selectedWindow);\n        const selectedHeight = selectedWindow && heightOf(selectedWindow);\n\n        let nonSelected = column.slice();\n        if (selectedWindow)\n            nonSelected.splice(k, 1);\n\n        const nonSelectedHeights = nonSelected.map(heightOf);\n        let availableForNonSelected = Math.max(\n            0,\n            availableHeight -\n            (column.length - 1) * gap -\n            (selectedWindow ? selectedHeight : 0)\n        );\n\n        const deficit = Math.max(\n            0, nonSelected.length * minHeight - availableForNonSelected);\n\n        let heights = fitProportionally(\n            nonSelectedHeights,\n            availableForNonSelected + deficit\n        );\n\n        if (selectedWindow)\n            heights.splice(k, 0, selectedHeight - deficit);\n\n        return heights;\n    }\n}\n\nexport function allocateEqualHeight(column, available) {\n    available -= (column.length - 1) * Settings.prefs.window_gap;\n    return column.map(_ => Math.floor(available / column.length));\n}\n\n/**\n * \"Slurps\" a window into the currently active column, vertically\n * stacking it.\n * @param {Meta.Window} metaWindow\n * @param {Boolean} below\n * @returns\n */\nexport function slurp(metaWindow, insertAt = SlurpInsertPosition.BOTTOM) {\n    if (!metaWindow) {\n        return;\n    }\n\n    const space = spaces.spaceOfWindow(metaWindow);\n    if (!space) {\n        return;\n    }\n\n    const index = space.indexOf(metaWindow);\n    let to, from, metaWindowToSlurp;\n\n    if (space.length < 2) {\n        return;\n    }\n\n    // get current direction mode\n    const direction = Settings.prefs.open_window_position;\n    switch (direction) {\n    case Settings.OpenWindowPositions.LEFT:\n    case Settings.OpenWindowPositions.START:\n        to = index;\n        from = index - 1;\n        break;\n    case Settings.OpenWindowPositions.RIGHT:\n    case Settings.OpenWindowPositions.END:\n    default:\n        to = index;\n        from = index + 1;\n        break;\n    }\n\n    metaWindowToSlurp = space[from]?.[0];\n    if (!metaWindowToSlurp) {\n        return;\n    }\n\n    // slurping fullscreen windows is trouble, unfullscreen when slurping\n    if (metaWindowToSlurp?.fullscreen) {\n        metaWindowToSlurp.unmake_fullscreen();\n    }\n\n    const spaceTo = space[to];\n    const rowIndex = spaceTo.indexOf(metaWindow);\n    switch (insertAt) {\n    case SlurpInsertPosition.ABOVE:\n        spaceTo.splice(rowIndex, 0, metaWindowToSlurp);\n        break;\n    case SlurpInsertPosition.BELOW:\n        spaceTo.splice(rowIndex + 1, 0, metaWindowToSlurp);\n        break;\n    case SlurpInsertPosition.TOP:\n        spaceTo.unshift(metaWindowToSlurp);\n        break;\n    case SlurpInsertPosition.BOTTOM:\n    default:\n        spaceTo.push(metaWindowToSlurp);\n        break;\n    }\n\n    { // Remove the slurped window\n        const column = space[from];\n        const row = column.indexOf(metaWindowToSlurp);\n        column.splice(row, 1);\n\n        // if from column is now empty, remove column from space\n        if (column.length === 0) {\n            space.splice(from, 1);\n        }\n\n        // with column removed, `to` column may have changed\n        to = space.indexOf(metaWindow);\n    }\n\n    // after columns have slurped, \"to\" index may have changed\n    space.layout(true, {\n        customAllocators: {\n            [to]: allocateEqualHeight,\n        },\n        ensure: false,\n    });\n}\n\n/**\n * Barfs (expels) a specific window from a column.\n * @param {Meta.Window} metaWindow\n * @returns\n */\nexport function barf(metaWindow, expelWindow) {\n    if (!metaWindow)\n        return;\n\n    const space = spaces.spaceOfWindow(metaWindow);\n    const index = space.indexOf(metaWindow);\n    if (index === -1)\n        return;\n\n    const column = space[index];\n    if (column.length < 2)\n        return;\n\n    let to;\n    const direction = Settings.prefs.open_window_position;\n    switch (direction) {\n    case Settings.OpenWindowPositions.LEFT:\n    case Settings.OpenWindowPositions.START:\n        to = index; // if left then current index will increment\n        break;\n    case Settings.OpenWindowPositions.RIGHT:\n    case Settings.OpenWindowPositions.END:\n    default:\n        to = index + 1;\n        break;\n    }\n\n    // // remove metawindow from column\n    if (expelWindow) {\n        // remove expelWindow from current column\n        const indexOfWindow = column.indexOf(expelWindow);\n        column.splice(indexOfWindow, 1);\n    }\n    else {\n        // remove from bottom\n        expelWindow = column.splice(-1, 1)[0];\n    }\n    space.splice(to, 0, [expelWindow]);\n\n    space.layout(true, {\n        customAllocators: { [space.indexOf(metaWindow)]: allocateEqualHeight, ensure: false },\n    });\n}\n\nexport function selectPreviousSpace(_mw, _space) {\n    spaces.selectStackSpace(Meta.MotionDirection.DOWN);\n}\n\nexport function selectPreviousSpaceBackwards(_mw, _space) {\n    spaces.selectStackSpace(Meta.MotionDirection.UP);\n}\n\nexport function movePreviousSpace(_mw, _space) {\n    spaces.selectStackSpace(Meta.MotionDirection.DOWN, true);\n}\n\nexport function movePreviousSpaceBackwards(_mw, _space) {\n    spaces.selectStackSpace(Meta.MotionDirection.UP, true);\n}\n\nexport function selectDownSpace(mw, space, fromAllMonitors) {\n    spaces.selectSequenceSpace(Meta.MotionDirection.DOWN, false, fromAllMonitors);\n}\n\nexport function selectUpSpace(mw, space, fromAllMonitors) {\n    spaces.selectSequenceSpace(Meta.MotionDirection.UP, false, fromAllMonitors);\n}\n\nexport function switchDownOrElseWorkspace(mw, space) {\n    if (!space.switchDown(false))\n        selectDownSpace(mw, space, false);\n}\n\nexport function switchUpOrElseWorkspace(mw, space) {\n    if (!space.switchUp(false))\n        selectUpSpace(mw, space, false);\n}\n\nexport function moveDownSpace(_mw, _space) {\n    spaces.selectSequenceSpace(Meta.MotionDirection.DOWN, true);\n}\n\nexport function moveUpSpace(_mw, _space) {\n    spaces.selectSequenceSpace(Meta.MotionDirection.UP, true);\n}\n\n/**\n   Detach the @metaWindow, storing it at the bottom right corner while\n   navigating. When done, insert all the detached windows again.\n */\nexport function takeWindow(metaWindow, space, options = {}) {\n    space = space ?? spaces.selectedSpace;\n    metaWindow = metaWindow ?? space.selectedWindow;\n    const navigator = options?.navigator ?? Navigator.getNavigator();\n    const existing = options?.existing ?? false;\n\n    if (!existing && !space.removeWindow(metaWindow))\n        return;\n\n    // setup animate function\n    const animateTake = (window, existing) => {\n        navigator._moving.push(window);\n        if (!existing) {\n            Utils.actor_add_child(backgroundGroup, metaWindow.clone);\n        }\n\n        const lowest = navigator._moving[navigator._moving.length - 2];\n        lowest && backgroundGroup.set_child_below_sibling(\n            window.clone,\n            lowest.clone);\n        const point = space.cloneContainer.apply_relative_transform_to_point(\n            backgroundGroup, new Graphene.Point3D({\n                x: window.clone.x,\n                y: window.clone.y,\n            }));\n\n        if (!existing) {\n            window.clone.set_position(point.x, point.y);\n        }\n\n        let x = Math.round(space.monitor.x + space.monitor.width -\n            (0.08 * space.monitor.width * (1 + navigator._moving.length)));\n        let y = Math.round(space.monitor.y + space.monitor.height * 2 / 3) +\n            16 * navigator._moving.length;\n        animateWindow(window);\n        Easer.addEase(window.clone,\n            {\n                x, y,\n                time: Settings.prefs.animation_time,\n            });\n    };\n\n    if (!navigator._moving) {\n        navigator.showTakeHint(true);\n        navigator._moving = [];\n\n        const selectedSpace = () => spaces.selectedSpace;\n        const changeSpace = metaWindow => {\n            const space = selectedSpace();\n            if (spaces.spaceOfWindow(metaWindow) !== space) {\n                metaWindow.change_workspace(space.workspace);\n            }\n        };\n\n        /**\n         * Cycling function which orders the navigator._moving\n         * array according to direction.\n         */\n        const cycler = order => {\n            order(navigator._moving);\n            const temparr = [...navigator._moving];\n            navigator._moving = [];\n            temparr.forEach(w => {\n                animateTake(w, true);\n            });\n        };\n\n        // get the action dispatcher signal to connect to\n        Navigator.getActionDispatcher(Clutter.GrabState.KEYBOARD)\n            .addKeypressCallback((_modmask, keysym, _event) => {\n                switch (keysym) {\n                case Clutter.KEY_space: {\n                    // remove the last window you got\n                    const pop = navigator._moving.pop();\n                    if (pop) {\n                        changeSpace(pop);\n                        insertWindow(pop, { existing: true, dropping: true });\n                        // make space selectedWindow (keeps index for next insert)\n                        selectedSpace().selectedWindow = pop;\n                        ensureViewport(pop);\n                    }\n                    // return true if this was actioned\n                    return true;\n                }\n\n                // cycle forwards through taken windows\n                case Clutter.KEY_Tab: {\n                    cycler(moving => moving.unshift(moving.pop()));\n                    return true;\n                }\n\n                // cycle backwards through taken windows (shift+tab)\n                case Clutter.KEY_ISO_Left_Tab: {\n                    cycler(moving => moving.push(moving.shift()));\n                    return true;\n                }\n\n                // close all taken windows\n                case Clutter.KEY_q: {\n                    navigator._moving.forEach(w => {\n                        changeSpace(w);\n                        insertWindow(\n                            w,\n                            {\n                                existing: true,\n                                dropping: true,\n                                dropCallback: mw => {\n                                    mw.delete(global.get_current_time());\n                                },\n                            });\n                    });\n\n                    navigator._moving = [];\n                    return true;\n                }\n\n                default:\n                    return false;\n                }\n            });\n\n        signals.connectOneShot(navigator, 'destroy', () => {\n            // ensure keyboard grabstate is dimissed (in case moving stopped via pointer)\n            Navigator.dismissDispatcher(Clutter.GrabState.KEYBOARD);\n            navigator.showTakeHint(false);\n\n            let selectedSpace = spaces.selectedSpace;\n            navigator._moving.forEach(w => {\n                changeSpace(w);\n                insertWindow(w, { existing: true, dropping: true });\n\n                // make space selectedWindow (keeps index for next insert)\n                selectedSpace.selectedWindow = w;\n            });\n\n            // activate last metaWindow after taken windows inserted\n            let firstWindow = navigator._moving.find(v => v !== undefined);\n            if (firstWindow) {\n                Utils.later_add(Meta.LaterType.IDLE, () => {\n                    Main.activateWindow(firstWindow);\n                });\n            }\n\n            // clean up after move\n            navigator._moving = [];\n        });\n    }\n\n    animateTake(metaWindow, false);\n}\n\n/**\n   Sort the @windows based on their clone's stacking order\n   in @space.cloneContainer.\n */\nexport function sortWindows(space, windows) {\n    if (windows.length === 1)\n        return windows;\n    let clones = windows.map(w => w.clone);\n    return space.cloneContainer.get_children()\n        .filter(c => clones.includes(c))\n        .map(c => c.meta_window);\n}\n\nexport function rotated(list, dir = 1) {\n    return [].concat(\n        list.slice(dir),\n        list.slice(0, dir)\n    );\n}\n\nexport function cycleWorkspaceSettings(dir = 1) {\n    let n = workspaceManager.get_n_workspaces();\n    let N = workspaceSettings.getWorkspaceList().get_strv('list').length;\n    let space = spaces.selectedSpace;\n    let wsI = space.index;\n\n    // 2 6 7 8   <-- indices\n    // x a b c   <-- settings\n    // a b c x   <-- rotated settings\n\n    let uuids = workspaceSettings.getWorkspaceList().get_strv('list');\n    // Work on tuples of [uuid, settings] since we need to uuid association\n    // in the last step\n    let settings = uuids.map(\n        uuid => [uuid, workspaceSettings.getWorkspaceSettingsByUUID(uuid)]\n    );\n    settings.sort((a, b) => a[1].get_int('index') - b[1].get_int('index'));\n\n    let unbound = settings.slice(n);\n    let strip = [settings[wsI]].concat(unbound);\n\n    strip = rotated(strip, dir);\n\n    let nextSettings = strip[0];\n    unbound = strip.slice(1);\n\n    nextSettings[1].set_int('index', wsI);\n    space.setSettings(nextSettings); // ASSUMPTION: ok that two settings have same index here\n\n    // Re-assign unbound indices:\n    for (let i = n; i < N; i++) {\n        unbound[i - n][1].set_int('index', i);\n    }\n    return space;\n}\n\n// Backward compatibility\nexport function defwinprop(...args) {\n    return Settings.defwinprop(...args);\n}\n"
        },
        {
          "name": "topbar.js",
          "type": "blob",
          "size": 31.814453125,
          "content": "import Clutter from 'gi://Clutter';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport GObject from 'gi://GObject';\nimport Graphene from 'gi://Graphene';\nimport Meta from 'gi://Meta';\nimport St from 'gi://St';\nimport Pango from 'gi://Pango';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as panelMenu from 'resource:///org/gnome/shell/ui/panelMenu.js';\nimport * as popupMenu from 'resource:///org/gnome/shell/ui/popupMenu.js';\n\nimport { Settings, Utils, Tiling, Navigator, Scratch } from './imports.js';\n\n// eslint-disable-next-line no-undef\nconst workspaceManager = global.workspace_manager;\n// eslint-disable-next-line no-undef\nconst display = global.display;\n\n/*\n  Functionality related to the top bar, often called the statusbar.\n */\n\nexport let panelBox = Main.layoutManager.panelBox;\n\nexport let menu, focusButton, openPositionButton;\nlet openPrefs, screenSignals, signals, gsettings;\nlet activeOpenWindowPositions;\n\nexport function enable (extension) {\n    activeOpenWindowPositions = [\n        {\n            mode: Settings.OpenWindowPositions.RIGHT,\n            active: () => Settings.prefs.open_window_position_option_right,\n        },\n        {\n            mode: Settings.OpenWindowPositions.LEFT,\n            active: () => Settings.prefs.open_window_position_option_left,\n        },\n        {\n            mode: Settings.OpenWindowPositions.START,\n            active: () => Settings.prefs.open_window_position_option_start,\n        },\n        {\n            mode: Settings.OpenWindowPositions.END,\n            active: () => Settings.prefs.open_window_position_option_end,\n        },\n        {\n            mode: Settings.OpenWindowPositions.DOWN,\n            active: () => Settings.prefs.open_window_position_option_down,\n        },\n        {\n            mode: Settings.OpenWindowPositions.UP,\n            active: () => Settings.prefs.open_window_position_option_up,\n        },\n    ];\n\n    openPrefs = () => extension.openPreferences();\n    gsettings = extension.getSettings();\n\n    screenSignals = [];\n    signals = new Utils.Signals();\n\n    Main.panel.statusArea.activities.hide();\n\n    menu = new WorkspaceMenu();\n    focusButton = new FocusButton();\n    openPositionButton = new OpenPositionButton();\n\n    Main.panel.addToStatusArea('WorkspaceMenu', menu, 1, 'left');\n    Main.panel.addToStatusArea('FocusButton', focusButton, 2, 'left');\n    Main.panel.addToStatusArea('OpenPositionButton', openPositionButton, 3, 'left');\n\n    Tiling.spaces.forEach(s => {\n        s.workspaceLabel.clutter_text.set_font_description(menu.label.clutter_text.font_description);\n    });\n\n    fixWorkspaceIndicator();\n    fixFocusModeIcon();\n    fixOpenPositionIcon();\n    fixStyle();\n\n    screenSignals.push(\n        workspaceManager.connect_after('workspace-switched',\n            (_workspaceManager, _from, to) => updateWorkspaceIndicator(to)));\n\n    signals.connect(Main.overview, 'showing', fixTopBar);\n    signals.connect(Main.overview, 'hidden', () => {\n        fixTopBar();\n    });\n\n    signals.connect(gsettings, 'changed::disable-topbar-styling', (_settings, _key) => {\n        if (Settings.prefs.disable_topbar_styling) {\n            removeStyles();\n        }\n        else {\n            fixStyle();\n        }\n    });\n\n    signals.connect(gsettings, 'changed::show-window-position-bar', (_settings, _key) => {\n        const spaces = Tiling.spaces;\n        spaces.forEach(s => s.showPositionBarChanged());\n        fixStyle();\n    });\n\n    signals.connect(gsettings, 'changed::show-workspace-indicator', (_settings, _key) => {\n        fixWorkspaceIndicator();\n    });\n\n    signals.connect(gsettings, 'changed::show-focus-mode-icon', (_settings, _key) => {\n        fixFocusModeIcon();\n    });\n\n    signals.connect(gsettings, 'changed::show-open-position-icon', (_settings, _key) => {\n        fixOpenPositionIcon();\n    });\n\n    signals.connect(panelBox, 'show', () => {\n        fixTopBar();\n    });\n    // signals.connect(panelBox, 'hide', () => {\n    //     fixTopBar();\n    // });\n\n    signals.connect(Main.panel, 'scroll-event', (_actor, event) => {\n        topBarScrollAction(event);\n    });\n\n    /**\n     * Set clear-style when hiding overview.\n     */\n    signals.connect(Main.overview, 'hiding', () => {\n        fixStyle();\n    });\n}\n\nexport function disable() {\n    signals.destroy();\n    signals = null;\n    focusButton.destroy();\n    focusButton = null;\n    openPositionButton.destroy();\n    openPositionButton = null;\n    activeOpenWindowPositions = null;\n    menu.destroy();\n    menu = null;\n    Main.panel.statusArea.activities.show();\n    // remove PaperWM style classes names for Main.panel\n    removeStyles();\n\n    screenSignals.forEach(id => workspaceManager.disconnect(id));\n    screenSignals = [];\n    openPrefs = null;\n    gsettings = null;\n}\n\n/**\n * Action when mouse scrolling on topbar.\n * @param {Clutter.event} event\n * @returns\n */\nexport function topBarScrollAction(event) {\n    if (!Settings.prefs.topbar_mouse_scroll_enable) {\n        return Clutter.EVENT_PROPAGATE;\n    }\n\n    // if topbar workspaceMenu (indicator) has pointer, exit\n    if (menu && menu.has_pointer) {\n        return Clutter.EVENT_PROPAGATE;\n    }\n\n    // same check for gnome pill\n    const pill = Main.panel?.statusArea?.activities;\n    if (pill && pill.has_pointer) {\n        return Clutter.EVENT_PROPAGATE;\n    }\n\n    let direction = event.get_scroll_direction();\n    switch (direction) {\n    case Clutter.ScrollDirection.DOWN:\n        Tiling.spaces?.activeSpace.switchRight(false);\n        break;\n    case Clutter.ScrollDirection.UP:\n        Tiling.spaces?.activeSpace.switchLeft(false);\n        break;\n    }\n    const selected = Tiling.spaces?.activeSpace?.selectedWindow;\n    if (selected) {\n        let hasFocus = selected.has_focus();\n        selected.foreach_transient(mw => {\n            hasFocus = mw.has_focus() || hasFocus;\n        });\n        if (hasFocus) {\n            Tiling.focus_handler(selected);\n        } else {\n            Main.activateWindow(selected);\n        }\n    }\n\n    return Clutter.EVENT_PROPAGATE;\n}\n\nexport function showWorkspaceMenu(show = false) {\n    if (show) {\n        Main.panel.statusArea.activities.hide();\n        menu.show();\n    }\n    else {\n        menu.hide();\n        Main.panel.statusArea.activities.show();\n    }\n}\n\nexport function createButton(icon_name, accessible_name) {\n    return new St.Button({\n        reactive: true,\n        can_focus: true,\n        track_hover: true,\n        accessible_name,\n        style_class: 'button workspace-icon-button',\n        child: new St.Icon({ icon_name }),\n    });\n}\n\n// registerClass, breaking our somewhat lame registerClass polyfill.\nexport const PopupMenuEntry = GObject.registerClass(\n    class PopupMenuEntry extends popupMenu.PopupBaseMenuItem {\n        _init(text) {\n            super._init({\n                activate: false,\n                reactive: true,\n                hover: false,\n                can_focus: false,\n            });\n\n            this.label = new St.Entry({\n                text,\n                // While not a search entry, this looks much better\n                style_class: 'search-entry',\n                name: 'workspace-name-entry',\n                track_hover: true,\n                reactive: true,\n                can_focus: true,\n            });\n\n            this.label.set_style(`\n              width: 232px;\n            `);\n\n            this.prevIcon = createButton('go-previous-symbolic', 'previous workspace setting');\n            this.nextIcon = createButton('go-next-symbolic', 'next workspace setting');\n\n            this.nextIcon.connect('clicked', () => {\n                let space = Tiling.cycleWorkspaceSettings(-1);\n                this.label.text = space.name;\n                this.nextIcon.grab_key_focus();\n            });\n            this.prevIcon.connect('clicked', () => {\n                let space = Tiling.cycleWorkspaceSettings(1);\n                this.label.text = space.name;\n                this.prevIcon.grab_key_focus();\n            });\n\n            this.actor.add_child(this.prevIcon);\n            this.actor.add_child(this.label);\n            this.actor.add_child(this.nextIcon);\n            this.actor.label_actor = this.label;\n            this.label.clutter_text.connect('activate', this.emit.bind(this, 'activate'));\n        }\n\n        activate(_event) {\n            this.label.grab_key_focus();\n        }\n\n        _onKeyFocusIn(_actor) {\n            this.activate();\n        }\n    });\n\n// class Color {\n//     constructor(color, container) {\n//         this.container = container;\n//         this.color = color;\n//         this.actor = new St.Button();\n//         let icon = new St.Widget();\n//         this.actor.add_child(icon);\n//         icon.set_style(`background: ${color}`);\n//         icon.set_size(20, 20);\n//         icon.set_position(4, 4);\n//         this.actor.set_size(24, 24);\n\n//         this.actor.connect('clicked', this.clicked.bind(this));\n//     }\n\n//     clicked() {\n//         this.container.entry.actor.text = this.color;\n//         this.container.clicked();\n//     }\n// }\n\n// class ColorEntry {\n//     constructor(startColor) {\n//         this.actor = new St.BoxLayout({ vertical: true });\n\n//         let flowbox = new St.Widget();\n//         let flowLayout = new Clutter.FlowLayout();\n//         let flow = new St.Widget();\n//         flowbox.add_child(flow);\n//         flow.layout_manager = flowLayout;\n//         flow.width = 24 * 16;\n//         for (let c of colors) {\n//             flow.add_child(new Color(c, this).actor);\n//         }\n\n//         this.entry = new PopupMenuEntry(startColor, 'Set color');\n//         this.entry.actor.clutter_text.connect(\n//             'text-changed', () => {\n//                 let color = this.entry.actor.text;\n//                 this.entry.actor.set_style(`color: ${color}; `);\n//             });\n\n//         this.entry.button.connect('clicked', this.clicked.bind(this));\n\n//         this.actor.add_child(this.entry.actor);\n//         this.actor.add_child(flowbox);\n//     }\n\n//     clicked() {\n//         let space = Tiling.spaces.activeSpace;\n//         let color = this.entry.actor.text;\n//         space.settings.set_string('color', color);\n//     }\n// }\n\nconst BaseIcon = GObject.registerClass(\n    class BaseIcon extends St.Icon {\n        _init(\n            props = {},\n            tooltipProps = {},\n            init = () => {},\n            setMode = _mode => {},\n            updateTooltipText = () => {}\n        ) {\n            super._init(props);\n\n            // allow custom x position for tooltip\n            this.tooltip_parent = tooltipProps?.parent ?? this;\n            this.tooltip_x_point = tooltipProps?.x_point ?? 0;\n            this.mode;\n\n            // assign functions\n            this.setMode = setMode;\n            this.updateTooltipText = updateTooltipText;\n\n            init();\n            this.initToolTip();\n            this.setMode();\n\n            this.reactive = true;\n            this.connect('button-press-event', () => {\n                if (this.clickFunction) {\n                    this.clickFunction();\n                    this.updateTooltipText();\n                }\n            });\n        }\n\n        initToolTip() {\n            const tt = new St.Label({ style_class: 'focus-button-tooltip' });\n            tt.hide();\n            // global.stage.add_child(tt);\n            Utils.actor_add_child(global.stage, tt);\n            this.tooltip_parent.connect('enter-event', _icon => {\n                this._updateTooltipPosition(this.tooltip_x_point);\n                this.updateTooltipText();\n                tt.show();\n\n                // alignment needs to be set after actor is shown\n                tt.clutter_text.set_line_alignment(Pango.Alignment.CENTER);\n            });\n            this.tooltip_parent.connect('leave-event', (_icon, _event) => {\n                if (!this.has_pointer) {\n                    tt.hide();\n                }\n            });\n            this.tooltip = tt;\n        }\n\n        /**\n         * Updates tooltip position relative to this button.\n         */\n        _updateTooltipPosition(xpoint = 0) {\n            let point = this.apply_transform_to_point(\n                new Graphene.Point3D({ x: xpoint, y: 0 }));\n            this.tooltip.set_position(Math.max(0, point.x - 62), point.y + 34);\n        }\n\n        /**\n         * Sets a function to be executed on click.\n         * @param {Function} clickFunction\n         * @returns\n         */\n        setClickFunction(clickFunction) {\n            this.clickFunction = clickFunction;\n            return this;\n        }\n\n        /**\n         * Sets visibility of icon.\n         * @param {boolean} visible\n         */\n        setVisible(visible = true) {\n            this.visible = visible;\n            return this;\n        }\n\n        /**\n         * Returns a nicely formatted keybind string from PaperWM\n         * @param {String} key\n         */\n        getKeybindString(key) {\n            // get first keybind\n            try {\n                let kb = gsettings.get_child('keybindings').get_strv(key)[0]\n                    .replace(/[<>]/g, ' ')\n                    .trim()\n                    .replace(/\\s+/g, '+');\n\n                // empty\n                if (kb.length === 0) {\n                    return '';\n                }\n                return `\\n<i>(${kb})</i>`;\n            } catch (error) {\n                return '';\n            }\n        }\n    }\n);\n\nexport const FocusIcon = GObject.registerClass(\n    class FocusIcon extends BaseIcon {\n        _init(\n            props = {},\n            tooltipProps = {}\n        ) {\n            super._init(\n                props,\n                tooltipProps,\n                () => {\n                    const pather = relativePath => GLib.uri_resolve_relative(import.meta.url, relativePath, GLib.UriFlags.NONE);\n                    this.gIconDefault = Gio.icon_new_for_string(pather('./resources/focus-mode-default-symbolic.svg'));\n                    this.gIconCenter = Gio.icon_new_for_string(pather('./resources/focus-mode-center-symbolic.svg'));\n                    this.gIconEdge = Gio.icon_new_for_string(pather('./resources/focus-mode-edge-symbolic.svg'));\n                },\n                mode => {\n                    mode = mode ?? Tiling.FocusModes.DEFAULT;\n                    this.mode = mode;\n\n                    switch (mode) {\n                    case Tiling.FocusModes.CENTER:\n                        this.gicon = this.gIconCenter;\n                        break;\n                    case Tiling.FocusModes.EDGE:\n                        this.gicon = this.gIconEdge;\n                        break;\n                    default:\n                        this.gicon = this.gIconDefault;\n                        break;\n                    }\n\n                    return this;\n                },\n                () => {\n                    const markup = (color, mode) => {\n                        const ct = this.tooltip.clutter_text;\n                        ct.set_markup(`<i>Window focus mode</i>\nCurrent mode: <span foreground=\"${color}\"><b>${mode}</b></span>\\\n${this.getKeybindString('switch-focus-mode')}`);\n                    };\n                    switch (this.mode) {\n                    case Tiling.FocusModes.DEFAULT:\n                        markup('#6be67b', 'DEFAULT');\n                        return;\n                    case Tiling.FocusModes.CENTER:\n                        markup('#6be6cb', 'CENTER');\n                        break;\n                    case Tiling.FocusModes.EDGE:\n                        markup('#abe67b', 'EDGE');\n                        break;\n                    default:\n                        markup('#6be67b', 'DEFAULT');\n                        this.tooltip.set_text('');\n                        break;\n                    }\n                }\n            );\n        }\n    }\n);\n\nexport const FocusButton = GObject.registerClass(\n    class FocusButton extends panelMenu.Button {\n        _init() {\n            super._init(0.0, 'FocusMode');\n\n            this._icon = new FocusIcon({\n                style_class: 'system-status-icon focus-mode-button',\n            }, { parent: this, x_point: -10 });\n\n            this.setFocusMode();\n            this.add_child(this._icon);\n            this.connect('event', this._onClicked.bind(this));\n        }\n\n        /**\n         * Sets the focus mode with this button.\n         * @param {*} mode\n         */\n        setFocusMode(mode) {\n            mode = mode ?? Tiling.FocusModes.DEFAULT;\n            this.focusMode = mode;\n            this._icon.setMode(mode);\n            return this;\n        }\n\n        _onClicked(_actor, event) {\n            if (Tiling.inPreview !== Tiling.PreviewMode.NONE || Main.overview.visible) {\n                return Clutter.EVENT_PROPAGATE;\n            }\n\n            if (event.type() !== Clutter.EventType.TOUCH_BEGIN &&\n                event.type() !== Clutter.EventType.BUTTON_PRESS) {\n                return Clutter.EVENT_PROPAGATE;\n            }\n\n            Tiling.switchToNextFocusMode();\n            this._icon.updateTooltipText();\n            return Clutter.EVENT_PROPAGATE;\n        }\n    }\n);\n\nexport const OpenPositionIcon = GObject.registerClass(\n    class OpenPositionIcon extends BaseIcon {\n        _init(\n            props = {},\n            tooltipProps = {}\n        ) {\n            super._init(\n                props,\n                tooltipProps,\n                () => {\n                    const pather = relativePath => GLib.uri_resolve_relative(import.meta.url, relativePath, GLib.UriFlags.NONE);\n                    this.gIconRight = Gio.icon_new_for_string(pather('./resources/open-position-right-symbolic.svg'));\n                    this.gIconLeft = Gio.icon_new_for_string(pather('./resources/open-position-left-symbolic.svg'));\n                    this.gIconStart = Gio.icon_new_for_string(pather('./resources/open-position-start-symbolic.svg'));\n                    this.gIconEnd = Gio.icon_new_for_string(pather('./resources/open-position-end-symbolic.svg'));\n                    this.gIconDown = Gio.icon_new_for_string(pather('./resources/open-position-down-symbolic.svg'));\n                    this.gIconUp = Gio.icon_new_for_string(pather('./resources/open-position-up-symbolic.svg'));\n\n\n                    // connection to update based on gsetting\n                    signals.connect(gsettings, 'changed::open-window-position', (_settings, _key) => {\n                        const mode = Settings.prefs.open_window_position;\n                        this.setMode(mode);\n                    });\n                },\n                mode => {\n                    mode = mode ?? Settings.OpenWindowPositions.RIGHT;\n                    this.mode = mode;\n\n                    switch (mode) {\n                    case Settings.OpenWindowPositions.LEFT:\n                        this.gicon = this.gIconLeft;\n                        break;\n                    case Settings.OpenWindowPositions.START:\n                        this.gicon = this.gIconStart;\n                        break;\n                    case Settings.OpenWindowPositions.END:\n                        this.gicon = this.gIconEnd;\n                        break;\n                    case Settings.OpenWindowPositions.DOWN:\n                        this.gicon = this.gIconDown;\n                        break;\n                    case Settings.OpenWindowPositions.UP:\n                        this.gicon = this.gIconUp;\n                        break;\n                    default:\n                        this.gicon = this.gIconRight;\n                        break;\n                    }\n\n                    this.updateTooltipText();\n                    return this;\n                },\n                () => {\n                    const markup = mode => {\n                        const ct = this.tooltip.clutter_text;\n                        ct.set_markup(`<i>Open Window Position</i>\nCurrent position: <b>${mode}</b>\\\n${this.getKeybindString('switch-open-window-position')}\n<span foreground=\"#a3a2a2\" style=\"oblique\" size=\"10pt\">change available modes\nin advanced settings</span>`);\n                    };\n                    switch (this.mode) {\n                    case Settings.OpenWindowPositions.LEFT:\n                        markup('LEFT');\n                        return;\n                    case Settings.OpenWindowPositions.START:\n                        markup('START');\n                        break;\n                    case Settings.OpenWindowPositions.END:\n                        markup('END');\n                        break;\n                    case Settings.OpenWindowPositions.DOWN:\n                        markup('DOWN');\n                        break;\n                    case Settings.OpenWindowPositions.UP:\n                        markup('UP');\n                        break;\n                    default:\n                        markup('RIGHT');\n                        break;\n                    }\n                }\n            );\n        }\n    }\n);\n\n/**\n * Switches to the next position for opening new windows.\n */\nexport function switchToNextOpenPositionMode() {\n    const activeModes = activeOpenWindowPositions\n        .filter(m => m.active())\n        .map(m => m.mode);\n\n    // if activeModes are empty, do nothing\n    if (activeModes.length <= 0) {\n        return;\n    }\n\n    const currIndex = activeModes.indexOf(Settings.prefs.open_window_position);\n    // if current mode is -1, then set the mode to the first option\n    let nextMode;\n    if (currIndex < 0) {\n        nextMode = activeModes[0];\n    }\n    else {\n        nextMode = activeModes[(currIndex + 1) % activeModes.length];\n    }\n\n    // simply need to set gsettings and mode will be set and updated\n    gsettings.set_int('open-window-position', nextMode);\n}\n\n/**\n * Switches to the next position for opening new windows.\n */\nexport function setOpenPositionMode(mode) {\n    gsettings.set_int('open-window-position', mode);\n}\n\nexport const OpenPositionButton = GObject.registerClass(\n    class OpenPositionButton extends panelMenu.Button {\n        _init() {\n            super._init(0.0, 'OpenPosition');\n\n            this._icon = new OpenPositionIcon({\n                style_class: 'system-status-icon open-position-icon',\n            }, { parent: this, x_point: -10 });\n\n            this.setPositionMode(Settings.prefs.open_window_position);\n            this.add_child(this._icon);\n            this.connect('button-press-event', this._onClicked.bind(this));\n        }\n\n        /**\n         * Sets the position mode with this button.\n         * @param {*} mode\n         */\n        setPositionMode(mode) {\n            mode = mode ?? Settings.OpenWindowPositions.RIGHT;\n            this.positionMode = mode;\n            this._icon.setMode(mode);\n            return this;\n        }\n\n        _onClicked(_actor, _event) {\n            switchToNextOpenPositionMode();\n            return Clutter.EVENT_PROPAGATE;\n        }\n    }\n);\n\nexport const WorkspaceMenu = GObject.registerClass(\n    class WorkspaceMenu extends panelMenu.Button {\n        _init() {\n            super._init(0.5, 'Workspace', false);\n\n            this.name = 'workspace-button';\n\n            let scale = display.get_monitor_scale(Main.layoutManager.primaryIndex);\n            this.label = new St.Label({\n                y_align: Clutter.ActorAlign.CENTER,\n                // Avoid moving the menu on short names\n                // TODO: update on scale changes\n                min_width: 60 * scale,\n            });\n\n            this.setName(Meta.prefs_get_workspace_name(workspaceManager.get_active_workspace_index()));\n\n            this.add_child(this.label);\n\n            this.signals = new Utils.Signals();\n            // eslint-disable-next-line no-undef\n            this.signals.connect(global.window_manager,\n                'switch-workspace',\n                this.workspaceSwitched.bind(this));\n\n            this.menu.addMenuItem(new popupMenu.PopupSeparatorMenuItem('Workspace Settings'));\n\n            this.entry = new PopupMenuEntry(this.label.text);\n            this.menu.addMenuItem(this.entry);\n            let changed = () => {\n                let name = this.entry.label.text;\n                let space = Tiling.spaces.activeSpace;\n                space.settings.set_string('name', name);\n                this.setName(name);\n            };\n            this.signals.connect(this.entry.label.clutter_text, 'text-changed',\n                changed);\n\n            // this._zenItem = new popupMenu.PopupSwitchMenuItem('Hide top bar', false);\n            // this.menu.addMenuItem(this._zenItem);\n            // this._zenItem.connect('toggled', item => {\n            //     Tiling.spaces.selectedSpace.settings.set_boolean('show-top-bar', !item.state);\n            // });\n\n            this.menu.addMenuItem(new popupMenu.PopupSeparatorMenuItem());\n\n            this._prefItem = new popupMenu.PopupImageMenuItem('Workspace preference', 'preferences-system-symbolic');\n            this.menu.addMenuItem(this._prefItem);\n\n            // this.prefsIcon = createButton('preferences-system-symbolic', 'workspace preference');\n            // this.prevIcon = createButton('go-previous-symbolic', 'previous workspace setting');\n            // this.nextIcon = createButton('go-next-symbolic', 'next workspace setting');\n\n            this._prefItem.connect('activate', () => {\n                this.menu.close(true);\n                let wi = workspaceManager.get_active_workspace_index();\n                let temp_file = Gio.File.new_for_path(GLib.get_tmp_dir()).get_child('paperwm.workspace');\n                temp_file.replace_contents(wi.toString(), null, false, Gio.FileCreateFlags.REPLACE_DESTINATION, null);\n                openPrefs();\n            });\n\n            // this.iconBox = new St.BoxLayout();\n            // this.menu.box.add(this.iconBox);\n\n            // this.iconBox.add(this.prefsIcon, { expand: true, x_fill: false });\n\n            // this.entry.actor.width = this.colors.actor.width;\n            // this.colors.entry.actor.width = this.colors.actor.width;\n            this.state = \"NORMAL\";\n        }\n\n        _finishWorkspaceSelect() {\n            this.state = \"NORMAL\";\n            this._enterbox.destroy();\n            delete this.selected;\n            delete this._enterbox;\n            delete this._navigator;\n        }\n\n        _onEvent(actor, event) {\n            if (!this.menu) {\n                console.warn(\"?? no menu ??\");\n                Utils.print_stacktrace();\n                return Clutter.EVENT_PROPAGATE;\n            }\n\n            if (this.state === \"MENU\" && !this.menu.isOpen) {\n                this.state = \"NORMAL\";\n            }\n\n            let type = event.type();\n\n            if (type === Clutter.EventType.TOUCH_END ||\n                type === Clutter.EventType.BUTTON_RELEASE) {\n                if (Navigator.navigating) {\n                    Navigator.getNavigator().finish();\n                } else {\n                    if (this.menu.isOpen) {\n                        this.menu.toggle();\n                    } else if (event.get_button() === Clutter.BUTTON_SECONDARY) {\n                        this.menu.toggle();\n                    } else {\n                        Main.overview.toggle();\n                    }\n                    this.state = this.menu.isOpen ? \"MENU\" : \"NORMAL\";\n                }\n                return Clutter.EVENT_PROPAGATE;\n            }\n\n            if (Main.overview.visible) {\n                return Clutter.EVENT_PROPAGATE;\n            }\n\n            if ([\"NORMAL\", \"SCROLL\"].includes(this.state) &&\n                type === Clutter.EventType.SCROLL) {\n                const direction = event.get_scroll_direction();\n                switch (direction) {\n                case Clutter.ScrollDirection.DOWN:\n                    Tiling.spaces.selectSequenceSpace(Meta.MotionDirection.DOWN);\n                    Navigator.getNavigator().finish();\n                    break;\n                case Clutter.ScrollDirection.UP:\n                    Tiling.spaces.selectSequenceSpace(Meta.MotionDirection.UP);\n                    Navigator.getNavigator().finish();\n                    break;\n                }\n            }\n\n            return Clutter.EVENT_PROPAGATE;\n        }\n\n        vfunc_event(event) {\n            this._onEvent(null, event);\n        }\n\n        // WorkspaceMenu.prototype._onOpenStateChanged = function\n        _onOpenStateChanged(menu, open) {\n            if (!open)\n                return;\n\n            let space = Tiling.spaces.activeSpace;\n            this.entry.label.text = space.name;\n            GLib.idle_add(GLib.PRIORITY_DEFAULT, this.entry.activate.bind(this.entry));\n\n            // this._zenItem._switch.setToggleState(!space.showTopBar);\n        }\n\n        workspaceSwitched(wm, fromIndex, toIndex) {\n            updateWorkspaceIndicator(toIndex);\n        }\n\n        destroy() {\n            this.signals.destroy();\n            this.signals = null;\n            super.destroy();\n        }\n\n        setName(name) {\n            this.label.text = name;\n        }\n    });\n\n/**\n * Returns monitor where panel is currently on.\n * @returns Monitor\n */\nexport function panelMonitor() {\n    return Main.layoutManager.primaryMonitor;\n}\n\n/**\n * Returns space where panel is currently on.\n * @returns Tiling.Space\n */\nexport function panelSpace() {\n    return Tiling?.spaces?.monitors?.get(panelMonitor());\n}\n\nexport function setNoBackgroundStyle() {\n    if (Settings.prefs.disable_topbar_styling) {\n        return;\n    }\n\n    removeStyles();\n    Main.panel.add_style_class_name('background-clear');\n}\n\nexport function setTransparentStyle() {\n    if (Settings.prefs.disable_topbar_styling) {\n        return;\n    }\n\n    removeStyles();\n    Main.panel.add_style_class_name('topbar-transparent-background');\n}\n\nexport function removeStyles() {\n    ['background-clear', 'topbar-transparent-background'].forEach(s => {\n        Main.panel.remove_style_class_name(s);\n    });\n}\n\n/**\n * Applies correct style based on whether we use the windowPositionBar or not.\n */\nexport function fixStyle() {\n    const space = panelSpace();\n    if (\n        Settings.prefs.show_window_position_bar &&\n        (space?.showPositionBar ?? true)\n    ) {\n        setNoBackgroundStyle();\n    }\n    else {\n        setTransparentStyle();\n    }\n}\n\nexport function fixTopBar() {\n    const space = panelSpace();\n    if (!space)\n        return;\n\n    const normal = !Main.overview.visible && !Tiling.inPreview;\n    // selected is current (tiled) selected window (can be different to focused window)\n    const selected = space.selectedWindow;\n    const focused = display.focus_window;\n    const focusIsFloatOrScratch = focused && (space.isFloating(focused) || Scratch.isScratchWindow(focused));\n    // check if is currently fullscreened (check focused-floating, focused-scratch, and selected/tiled window)\n    const fullscreen = focusIsFloatOrScratch ? focused.fullscreen : selected && selected.fullscreen;\n\n    if (normal && !space.showTopBar) {\n        hideTopBar();\n    }\n    else if (normal && fullscreen) {\n        hideTopBar();\n    }\n    else {\n        showTopBar();\n    }\n}\n\nexport function showTopBar() {\n    panelBox.show();\n}\n\nexport function hideTopBar() {\n    panelBox.hide();\n}\n\nexport function fixWorkspaceIndicator() {\n    const show = Settings.prefs.show_workspace_indicator;\n    if (show) {\n        Main.panel.statusArea.activities.hide();\n        menu.show();\n    }\n    else {\n        menu.hide();\n        Main.panel.statusArea.activities.show();\n    }\n}\n\nexport function fixFocusModeIcon() {\n    Settings.prefs.show_focus_mode_icon ? focusButton.show() : focusButton.hide();\n    Tiling.spaces.forEach(s => s.showFocusModeIcon());\n}\n\nexport function fixOpenPositionIcon() {\n    Settings.prefs.show_open_position_icon ? openPositionButton.show() : openPositionButton.hide();\n}\n\n/**\n   Override the activities label with the workspace name.\n   let workspaceIndex = 0\n*/\nexport function updateWorkspaceIndicator(index) {\n    let spaces = Tiling.spaces;\n    let space = spaces?.spaceOf(workspaceManager.get_workspace_by_index(index));\n    if (space && space.monitor === panelMonitor()) {\n        setWorkspaceName(space.name);\n\n        // also update focus mode\n        focusButton.setFocusMode(space.focusMode);\n    }\n}\n\n/**\n * Refreshes topbar workspace indicator.\n */\nexport function refreshWorkspaceIndicator() {\n    const space = panelSpace();\n    if (space) {\n        updateWorkspaceIndicator(space.index);\n    }\n}\n\nexport function setWorkspaceName (name) {\n    menu && menu.setName(name);\n}\n"
        },
        {
          "name": "uninstall.sh",
          "type": "blob",
          "size": 0.791015625,
          "content": "#!/usr/bin/env bash\n\n# NOTE: gnome-extensions uninstall will delete all files in the linked directory\n\nREPO=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\nif [[ -L \"$REPO\" ]]; then\n   REPO=`readlink --canonicalize \"$REPO\"`\nfi\nUUID=paperwm@paperwm.github.com\nif type gnome-extensions > /dev/null; then\n    gnome-extensions disable \"$UUID\"\nelse\n    gnome-shell-extension-tool --disable=\"$UUID\"\nfi\nEXT_DIR=${XDG_DATA_HOME:-$HOME/.local/share}/gnome-shell/extensions\nEXT=$EXT_DIR/$UUID\nLINK=`readlink --canonicalize \"$EXT\"`\nif [[ \"$LINK\" != \"$REPO\" ]]; then\n    echo \"$EXT\" does not link to \"$REPO\", refusing to remove\n    exit 1\nfi\nif [ -L \"$EXT\" ]; then\n    rm \"$EXT\"\nelse\n    read -p \"Remove $EXT? (y/N): \" -n 1 -r\n    echo\n    if [[ $REPLY =~ ^[Yy]$ ]]; then\n        rm -rf $EXT\n    fi\nfi\n"
        },
        {
          "name": "utils.js",
          "type": "blob",
          "size": 19.07421875,
          "content": "import Clutter from 'gi://Clutter';\nimport Cogl from 'gi://Cogl';\nimport GdkPixbuf from 'gi://GdkPixbuf';\nimport Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\nimport Meta from 'gi://Meta';\nimport St from 'gi://St';\n\nimport * as Main from 'resource:///org/gnome/shell/ui/main.js';\nimport * as Ripples from 'resource:///org/gnome/shell/ui/ripples.js';\nimport * as Config from 'resource:///org/gnome/shell/misc/config.js';\n\nimport { Lib } from './imports.js';\n\nconst Display = global.display;\nexport let version = Config.PACKAGE_VERSION.split('.').map(Number);\n\nlet warpRipple;\n\nlet signals, touchCoords;\nlet inTouch = false;\n\nexport function enable() {\n    warpRipple = new Ripples.Ripples(0.5, 0.5, 'ripple-pointer-location');\n    warpRipple.addTo(Main.uiGroup);\n\n    signals = new Signals();\n    signals.connect(global.stage, \"touch-event\", (_actor, event) => {\n        switch (event.type()) {\n        case Clutter.EventType.TOUCH_BEGIN:\n        case Clutter.EventType.TOUCH_UPDATE:\n            inTouch = true;\n            break;\n        case Clutter.EventType.TOUCH_END:\n        case Clutter.EventType.TOUCH_CANCEL:\n            inTouch = false;\n            break;\n        default:\n            return Clutter.EVENT_PROPAGATE;\n        }\n\n        // was one of our touch events\n        touchCoords = event.get_coords();\n        return Clutter.EVENT_PROPAGATE;\n    });\n}\n\nexport function disable() {\n    warpRipple?.destroy();\n    warpRipple = null;\n    markNewClonesSignalId = null;\n\n    signals.destroy();\n    signals = null;\n}\n\nexport function assert(condition, message, ...dump) {\n    if (!condition) {\n        throw new Error(`${message}\\n`, dump);\n    }\n}\n\nexport function print_stacktrace(error) {\n    let trace;\n    if (!error) {\n        trace = new Error().stack.split(\"\\n\");\n        // Remove _this_ frame\n        trace.splice(0, 1);\n    } else {\n        trace = error.stack.split(\"\\n\");\n    }\n    console.error(`JS ERROR: ${error}\\n ${trace.join('\\n')}`);\n}\n\n/**\n * Pretty prints args using JSON.stringify.\n * @param  {...any} arugs\n */\nexport function prettyPrintToLog(...args) {\n    console.log(args.map(v => JSON.stringify(v, null), 2));\n}\n\nexport function framestr(rect) {\n    return `[ x:${rect.x}, y:${rect.y} w:${rect.width} h:${rect.height} ]`;\n}\n\nexport function isPointInsideActor(actor, x, y) {\n    return (actor.x <= x && x <= actor.x + actor.width) &&\n        (actor.y <= y && y <= actor.y + actor.height);\n}\n\nexport function setBackgroundImage(actor, resource_path) {\n    // resource://{resource_path}\n    let image = new Clutter.Image();\n\n    let pixbuf = GdkPixbuf.Pixbuf.new_from_resource(resource_path);\n\n    image.set_data(pixbuf.get_pixels(),\n        pixbuf.get_has_alpha() ? Cogl.PixelFormat.RGBA_8888\n            : Cogl.PixelFormat.RGB_888,\n        pixbuf.get_width(),\n        pixbuf.get_height(),\n        pixbuf.get_rowstride());\n    actor.set_content(image);\n    actor.content_repeat = Clutter.ContentRepeat.BOTH;\n}\n\n/**\n * Backwards compatible function.  Attempts to use Cogl.Color with a fallback\n * to Clutter.Color.\n * @param {String} colorString\n */\nexport function color_from_string(colorString) {\n    try {\n        // Gnome 47+ merged Clutter.Color into Cogl.Color\n        return Cogl.Color.from_string(colorString);\n    } catch (error) {\n        // fallback for Gnome 45, 46\n        return Clutter.Color.from_string(colorString);\n    }\n}\n\n\n// // Debug and development utils\n\n/**\n * Visualize the frame and buffer bounding boxes of a meta window\n */\nexport function toggleWindowBoxes(metaWindow) {\n    metaWindow = metaWindow || Display.focus_window;\n\n    if (metaWindow._paperDebugBoxes) {\n        metaWindow._paperDebugBoxes.forEach(box => {\n            box.destroy();\n        });\n        delete metaWindow._paperDebugBoxes;\n        return [];\n    }\n\n    const frame = metaWindow.get_frame_rect();\n    const inputFrame = metaWindow.get_buffer_rect();\n    const actor = metaWindow.get_compositor_private();\n\n    const makeFrameBox = ({ x, y, width, height }, color)  => {\n        let frameBox = new St.Widget();\n        frameBox.set_position(x, y);\n        frameBox.set_size(width, height);\n        frameBox.set_style(`border: 2px${color} solid`);\n        return frameBox;\n    };\n\n    const boxes = [];\n    boxes.push(makeFrameBox(frame, \"red\"));\n    boxes.push(makeFrameBox(inputFrame, \"blue\"));\n\n    if (inputFrame.x !== actor.x || inputFrame.y !== actor.y ||\n       inputFrame.width !== actor.width || inputFrame.height !== actor.height) {\n        boxes.push(makeFrameBox(actor, \"yellow\"));\n    }\n\n    boxes.forEach(box => global.stage.add_child(box));\n    metaWindow._paperDebugBoxes = boxes;\n    return boxes;\n}\n\nlet markNewClonesSignalId = null;\nexport function toggleCloneMarks() {\n    // NB: doesn't clean up signal on disable\n\n    function markCloneOf(metaWindow) {\n        if (metaWindow.clone) {\n            metaWindow.clone.opacity = 190;\n            metaWindow.clone.__oldOpacity = 190;\n            metaWindow.clone.background_color = color_from_string(\"red\")[1];\n        }\n    }\n    function unmarkCloneOf(metaWindow) {\n        if (metaWindow.clone) {\n            metaWindow.clone.opacity = 255;\n            metaWindow.clone.__oldOpacity = 255;\n            metaWindow.clone.background_color = null;\n        }\n    }\n\n    let windows = Display.get_tab_list(Meta.TabList.NORMAL_ALL, null);\n\n    if (markNewClonesSignalId) {\n        Display.disconnect(markNewClonesSignalId);\n        markNewClonesSignalId = null;\n        windows.forEach(unmarkCloneOf);\n    } else {\n        markNewClonesSignalId = Display.connect_after(\n            \"window-created\", (_, mw) => markCloneOf(mw));\n\n        windows.forEach(markCloneOf);\n    }\n}\n\nexport function isInRect(x, y, r) {\n    return r.x <= x && x < r.x + r.width &&\n        r.y <= y && y < r.y + r.height;\n}\n\n/**\n * Retrieves global pointer coordinates taking into account touch screen events.\n * May not work for continuous tracking, see #766.\n */\nexport function getPointerCoords() {\n    if (inTouch) {\n        return touchCoords;\n    } else {\n        return global.get_pointer();\n    }\n}\n\n/**\n * Returns monitor a pointer co-ordinates.\n */\nexport function monitorAtPoint(gx, gy) {\n    for (let monitor of Main.layoutManager.monitors) {\n        if (isInRect(gx, gy, monitor))\n            return monitor;\n    }\n    return null;\n}\n\n/**\n * Returns the monitor current pointer coordinates.\n */\nexport function monitorAtCurrentPoint() {\n    const [gx, gy] = getPointerCoords();\n    return monitorAtPoint(gx, gy);\n}\n\n/**\n * Warps pointer to the center of a monitor.\n */\nexport function warpPointerToMonitor(monitor, params = { center: false, ripple: true }) {\n    const center = params?.center ?? false;\n    const ripple = params?.ripple ?? true;\n\n    // no need to warp if already on this monitor\n    let currMonitor = monitorAtCurrentPoint();\n    if (currMonitor === monitor) {\n        return;\n    }\n\n    let [x, y] = global.get_pointer();\n    if (center) {\n        x -= monitor.x;\n        y -= monitor.y;\n        warpPointer(\n            monitor.x + Math.floor(monitor.width / 2),\n            monitor.y + Math.floor(monitor.height / 2),\n            ripple);\n        return;\n    }\n\n    let proportionalX = (x - currMonitor.x) / currMonitor.width;\n    let proportionalY = (y - currMonitor.y) / currMonitor.height;\n    warpPointer(\n        monitor.x + Math.floor(proportionalX * monitor.width),\n        monitor.y + Math.floor(proportionalY * monitor.height),\n        ripple\n    );\n}\n\n/**\n * Warps pointer to x, y coordinates.\n * Optionally shows a ripple effect after warp.\n */\nexport function warpPointer(x, y, ripple = true) {\n    const seat = Clutter.get_default_backend().get_default_seat();\n    seat.warp_pointer(x, y);\n    if (ripple) {\n        warpRipple.playAnimation(x, y);\n    }\n}\n\n/**\n * Return current modifiers state (or'ed Clutter.ModifierType.*)\n */\nexport function getModiferState() {\n    let [, , mods] = global.get_pointer();\n    return mods;\n}\n\nexport function monitorOfPoint(x, y) {\n    // get_monitor_index_for_rect \"helpfully\" returns the primary monitor index for out of bounds rects..\n    for (let monitor of Main.layoutManager.monitors) {\n        if ((monitor.x <= x && x <= monitor.x + monitor.width) &&\n            (monitor.y <= y && y <= monitor.y + monitor.height))\n        {\n            return monitor;\n        }\n    }\n\n    return null;\n}\n\nexport function mkFmt({ nameOnly } = { nameOnly: false }) {\n    function defaultFmt(actor, prefix = \"\") {\n        const fmtNum = num => num.toFixed(0);\n        let extra = [\n            `${actor.get_position().map(fmtNum)}`,\n            `${actor.get_size().map(fmtNum)}`,\n        ];\n        let metaWindow = actor.meta_window || actor.metaWindow;\n        if (metaWindow) {\n            metaWindow = `(mw: ${metaWindow.title})`;\n            extra.push(metaWindow);\n        }\n        const extraStr = extra.join(\" | \");\n        let actorId = \"\";\n        if (nameOnly) {\n            // eslint-disable-next-line no-nested-ternary, eqeqeq\n            actorId = actor.name ? actor.name : prefix.length == 0 ? \"\" : \"#\";\n        } else {\n            actorId = actor.toString();\n        }\n        actorId = prefix + actorId;\n        let spacing = actorId.length > 0 ? \" \" : \"\";\n        return `*${spacing}${actorId} ${extraStr}`;\n    }\n    return defaultFmt;\n}\n\nexport function printActorTree(node, fmt = mkFmt(), options = {}, state = null) {\n    state = Object.assign({}, state || { level: 0, actorPrefix: \"\" });\n    const defaultOptions = {\n        limit: 9999,\n        collapseChains: true,\n    };\n    options = Object.assign(defaultOptions, options);\n\n    if (state.level > options.limit) {\n        return;\n    }\n    let collapse = false;\n    if (options.collapseChains) {\n        /*\n          a\n            b\n              s\n              t\n            c 30,10\n              u\n          ->\n          a.b.s\n          a.b.t\n          a.b.c ...\n            u\n        */\n        if (node.get_children().length > 0) {\n            if (node.x === 0 && node.y === 0) {\n                state.actorPrefix += `${node.name ? node.name : \"#\"}.`;\n                collapse = true;\n            } else {\n                collapse = false;\n            }\n        } else {\n            collapse = false;\n        }\n    }\n    if (!collapse) {\n        console.debug(Lib.indent(state.level, fmt(node, state.actorPrefix)));\n        state.actorPrefix = \"\";\n        state.level += 1;\n    }\n\n    for (let child of node.get_children()) {\n        printActorTree(child, fmt, options, state);\n    }\n}\n\nexport function isMetaWindow(obj) {\n    return obj && obj.window_type && obj.get_compositor_private;\n}\n\nexport function actor_raise(actor, above) {\n    const parent = actor.get_parent();\n    if (!parent) {\n        return;\n    }\n    // needs to be null (not undefined) for valid second argument\n    above = above ?? null;\n    parent.set_child_above_sibling(actor, above);\n}\n\nexport function actor_reparent(actor, newParent) {\n    actor_remove_parent(actor);\n    newParent.add_child(actor);\n}\n\n/**\n * Removes a child from a parent actor.  Checks child\n * exists in parent first.\n * @param {Clutter.Actor} parent\n * @param {Clutter.Actor} child\n */\nexport function actor_remove_child(parent, child) {\n    if (parent.get_children().includes(child)) {\n        parent.remove_child(child);\n    }\n}\n\n/**\n * Removes the parent from this actor (if it has one).\n * @param {Clutter.Actor} actor\n */\nexport function actor_remove_parent(actor) {\n    const parent = actor.get_parent();\n    if (parent) {\n        parent.remove_child(actor);\n    }\n}\n\n/**\n * Adds a child from a parent actor.  Checks child if is already\n * attached.\n * @param {Clutter.Actor} parent\n * @param {Clutter.Actor} child\n */\nexport function actor_add_child(parent, child) {\n    // check if already a child of this parent\n    if (parent.get_children().includes(child)) {\n        return;\n    }\n\n    actor_remove_parent(child);\n    parent.add_child(child);\n}\n\n/**\n * Backwards compatible later_add function.\n */\nexport function later_add(...args) {\n    global.compositor.get_laters().add(...args);\n}\n\n/**\n * Backwards compatible Display.grab_accelerator function.\n */\nexport function grab_accelerator(keystr, keyBindingFlags = Meta.KeyBindingFlags.NONE) {\n    if (Display.grab_accelerator.length > 1) {\n        return Display.grab_accelerator(keystr, keyBindingFlags);\n    } else  {\n        return Display.grab_accelerator(keystr);\n    }\n}\n\n/**\n * Convenience method for removing timeout source(s) from Mainloop.\n */\nexport function timeout_remove(...timeouts) {\n    timeouts.forEach(t => {\n        if (t) {\n            GLib.source_remove(t);\n        }\n    });\n}\n\n/**\n * Calls a period timeout (GLib.timeout_add) that calls a callback function.\n * Also contains parameters for init (call for initialisation), onContinue (callback when continuing),\n * onComplete (callback when completed last callback).\n * @param {Object} options\n * @param {Number} options.period_ms\n * @param {Number} options.count\n * @param {Function} options.init\n * @param {Function} options.callback\n * @param {Function} options.onContinue\n * @param {Function} options.onComplete\n * @returns GLib timeout id\n */\nexport function periodic_timeout(options = { }) {\n    const operiod = options?.period_ms ?? 1000;\n    const ocount = options?.count ?? 1;\n    const oinit = options?.init ?? function() {};\n    const ocallback = options?.callback ?? function() {};\n    const ocontinue = options?.onContinue ?? function() {};\n    const ocomplete = options?.onComplete ?? function() {};\n\n    oinit();\n    let called = 0;\n    return GLib.timeout_add(\n        GLib.PRIORITY_DEFAULT,\n        operiod,\n        () => {\n            // check for early exit (if callback returns false)\n            if (ocallback() === false) {\n                ocomplete();\n                return false;\n            }\n\n            if (called < ocount) {\n                called++;\n                ocontinue(called);\n                return true;\n            }\n\n            ocomplete();\n            return false; // on return false destroys timeout\n        });\n}\n\nexport class Signals extends Map {\n    static get [Symbol.species]() { return Map; }\n\n    _getOrCreateSignals(object) {\n        let signals = this.get(object);\n        if (!signals) {\n            signals = [];\n            this.set(object, signals);\n        }\n        return signals;\n    }\n\n    connectOneShot(object, signal, handler) {\n        let id = this.connect(object, signal, (...args) => {\n            this.disconnect(object, id);\n            return handler(...args);\n        });\n    }\n\n    connect(object, signal, handler) {\n        let id = object.connect(signal, handler);\n        let signals = this._getOrCreateSignals(object);\n        signals.push(id);\n        return id;\n    }\n\n    disconnect(object, id = null) {\n        let ids = this.get(object);\n        if (ids) {\n            if (id === null) {\n                ids.forEach(id => object.disconnect(id));\n                ids = [];\n            } else {\n                object.disconnect(id);\n                let i = ids.indexOf(id);\n                if (i > -1) {\n                    ids.splice(i, 1);\n                }\n            }\n            if (ids.length === 0)\n                this.delete(object);\n        }\n    }\n\n    destroy() {\n        for (let [object, signals] of this) {\n            signals.forEach(id => object.disconnect(id));\n            this.delete(object);\n        }\n    }\n}\n\n/**\n * Note the name 'Tweener' used previously was just a legacy name, we're actually using\n * Widget.ease here.  This was renamed to avoid confusion with the deprecated `Tweener`\n * module.\n */\nexport let Easer = {\n    /**\n     * Safer time setting to essentiall disable easer animation.\n     * Setting to values lower than this can have some side-effects\n     * like \"jumpy\" three-finger left/right swiping etc.\n     */\n    ANIMATION_SAFE_TIME: 0.03,\n\n    /**\n     * Can set animation to instant time.  Used for to override animation\n     * time to effectively \"disable\" an animation.  Setting to 0 can have\n     * some side-effects and cause race aconditions\n     */\n    ANIMATION_INSTANT_TIME: 0.0001,\n\n    addEase(actor, params) {\n        if (params.time) {\n            params.duration = this._safeDuration(params.time, params.instant);\n            delete params.time;\n        }\n\n        if (!params.mode) {\n            params.mode = Clutter.AnimationMode.EASE_IN_OUT_QUAD;\n        }\n\n        actor.ease(params);\n    },\n\n    /**\n     * Returns a safe animation time to avoid timing\n     * race conditions etc.\n     */\n    _safeDuration(time, instant) {\n        let duration = Math.max(time, this.ANIMATION_SAFE_TIME);\n        if (instant === true) {\n            duration = this.ANIMATION_INSTANT_TIME;\n        }\n\n        return duration * 1000;\n    },\n\n    removeEase(actor) {\n        actor.remove_all_transitions();\n    },\n\n    isEasing(actor) {\n        return actor.get_transition('x') ||\n        actor.get_transition('y') ||\n        actor.get_transition('scale-x') ||\n        actor.get_transition('scale-x');\n    },\n};\n\nexport class DisplayConfig {\n    static get proxyWrapper() {\n        return Gio.DBusProxy.makeProxyWrapper('<node>\\\n        <interface name=\"org.gnome.Mutter.DisplayConfig\">\\\n            <method name=\"GetCurrentState\">\\\n            <arg name=\"serial\" direction=\"out\" type=\"u\" />\\\n            <arg name=\"monitors\" direction=\"out\" type=\"a((ssss)a(siiddada{sv})a{sv})\" />\\\n            <arg name=\"logical_monitors\" direction=\"out\" type=\"a(iiduba(ssss)a{sv})\" />\\\n            <arg name=\"properties\" direction=\"out\" type=\"a{sv}\" />\\\n            </method>\\\n            <signal name=\"MonitorsChanged\" />\\\n        </interface>\\\n    </node>');\n    }\n\n    constructor() {\n        this.proxy = new DisplayConfig.proxyWrapper(\n            Gio.DBus.session,\n            'org.gnome.Mutter.DisplayConfig',\n            '/org/gnome/Mutter/DisplayConfig',\n            (proxy, error) => {\n                if (error) {\n                    console.error(error);\n                    return;\n                }\n                this.upgradeGnomeMonitors();\n            }\n        );\n    }\n\n    /**\n     * Upgrades Main.layoutManager.monitors by adding a dbus monitor connector\n     * (e.g. \"eDP-1\" or \"DP-1\", etc.).  Used for stable restoring for monitor\n     * layouts.\n     */\n    upgradeGnomeMonitors(callback = () => {}) {\n        this.proxy.GetCurrentStateRemote((state, error) => {\n            if (error) {\n                console.error(error);\n                return;\n            }\n\n            const [, monitors] = state;\n            for (const monitor of monitors) {\n                const [specs] = monitor;\n                const [connector] = specs;\n\n                // upgrade gnome monitor object to add connector\n                let gnomeIndex = this.monitorManager.get_monitor_for_connector(connector);\n                let gnomeMonitor = this.gnomeMonitors.find(m => m.index === gnomeIndex);\n                if (gnomeMonitor) {\n                    gnomeMonitor.connector = connector;\n                }\n            }\n\n            callback();\n        });\n    }\n\n    /**\n     * Downgrades Main.layoutManager.monitors to default gnome state (without \"connector\"\n     * information).\n     */\n    downgradeGnomeMonitors() {\n        this.gnomeMonitors.forEach(m => {\n            delete m.connector;\n        });\n    }\n\n    get monitorManager() {\n        return global.backend.get_monitor_manager();\n    }\n\n    get gnomeMonitors() {\n        return Main.layoutManager.monitors;\n    }\n}\n"
        },
        {
          "name": "virtTiling.js",
          "type": "blob",
          "size": 7.9306640625,
          "content": "import St from 'gi://St';\n\nimport { Utils, Tiling } from './imports.js';\n\nlet fitProportionally = Tiling.fitProportionally;\nlet prefs = {\n    window_gap: 5,\n    minimum_margin: 3,\n};\n\nlet virtStage = null;\n\nexport function repl() {\n    if (virtStage) {\n        virtStage.destroy();\n    }\n\n    let realMonitor = space.monitor;\n    let scale = 0.10;\n    let padding = 10;\n    const monitorWidth = realMonitor.width * scale;\n    const monitorHeight = realMonitor.height * scale;\n    let stageStyle = 'background-color: white;';\n    virtStage = new St.Widget({\n        name: 'stage',\n        style: stageStyle,\n        height: monitorHeight + padding * 2,\n        width: monitorWidth * 3,\n    });\n\n    let monitorStyle = `background-color: blue;`;\n    let monitor = new St.Widget({\n        name: \"monitor0\",\n        style: monitorStyle,\n        x: virtStage.width / 2 - monitorWidth / 2, y: padding,\n        width: monitorWidth,\n        height: virtStage.height - padding * 2,\n    });\n\n    let panel = new St.Widget({\n        name: \"panel\",\n        style: `background-color: gray`,\n        x: 0, y: 0,\n        width: monitor.width,\n        height: 10,\n\n    });\n    let workArea = {\n        x: monitor.x,\n        y: panel.height,\n        width: monitor.width,\n        height: monitor.height - panel.height,\n    };\n\n    let tilingStyle = `background-color: rgba(190, 190, 0, 0.3);`;\n    let tilingContainer = new St.Widget({ name: \"tiling\", style: tilingStyle });\n\n    global.stage.add_child(virtStage);\n    virtStage.x = 3000;\n    virtStage.y = 300;\n\n    virtStage.add_child(monitor);\n    monitor.add_child(panel);\n    monitor.add_child(tilingContainer);\n\n    function sync(space_ = space) {\n        let columns = layout(\n            fromSpace(space_, scale),\n            workArea,\n            prefs\n        );\n        renderAndView(\n            tilingContainer,\n            columns\n        );\n        tilingContainer.x = space_.targetX * scale;\n    }\n\n    sync();\n\n    Utils.printActorTree(virtStage, Utils.mkFmt({ nameOnly: true }));\n\n    movecolumntoviewportposition(tilingContainer, monitor, columns[1][0], 30);\n\n    virtStage.hide();\n    virtStage.show();\n    virtStage.y = 400;\n}\n\n/** tiling position given:\n    m_s: monitor position\n    w_m: window position (relative to monitor)\n    w_t: window position (relative to tiling)\n */\nexport function t_s(m_s, w_m, w_t) {\n    return w_m - w_t + m_s;\n}\n\n/**\n   Calculates the tiling position such that column `k` is positioned at `x`\n   relative to the viewport (or workArea?)\n */\nexport function movecolumntoviewportposition(tilingActor, viewport, window, x) {\n    tilingActor.x = t_s(viewport.x, x, window.x);\n}\n\nexport function renderAndView(container, columns) {\n    for (let child of container.get_children()) {\n        child.destroy();\n    }\n\n    render(columns, container);\n}\n\nexport function fromSpace(space, scale = 1) {\n    return space.map(\n        col => col.map(\n            metaWindow => {\n                let f = metaWindow.get_frame_rect();\n                return {\n                    width: f.width * scale,\n                    height: f.height * scale,\n                };\n            }\n        )\n    );\n}\n\n/** Render a dummy view of the windows */\nexport function render(columns, tiling) {\n    const windowStyle = `border: black solid 1px; background-color: red`;\n\n    function createWindowActor(window) {\n        return new St.Widget({\n            style: windowStyle,\n            width: window.width,\n            height: window.height,\n            x: window.x,\n            y: window.y,\n        });\n    }\n\n    for (let col of columns) {\n        for (let window of col) {\n            let windowActor = createWindowActor(window);\n            tiling.add_child(windowActor);\n        }\n    }\n}\n\nexport function allocateDefault(column, availableHeight, preAllocatedWindow) {\n    if (column.length === 1) {\n        return [availableHeight];\n    } else {\n        // Distribute available height amongst non-selected windows in proportion to their existing height\n        const gap = prefs.window_gap;\n        const minHeight = 15;\n\n        const heightOf = window => {\n            return window.height;\n        };\n\n        const k = preAllocatedWindow && column.indexOf(preAllocatedWindow);\n        const selectedHeight = preAllocatedWindow && heightOf(preAllocatedWindow);\n\n        let nonSelected = column.slice();\n        if (preAllocatedWindow) {\n            nonSelected.splice(k, 1);\n        }\n\n        const nonSelectedHeights = nonSelected.map(heightOf);\n        let availableForNonSelected = Math.max(\n            0,\n            availableHeight -\n                (column.length - 1) * gap -\n                (preAllocatedWindow ? selectedHeight : 0)\n        );\n\n        const deficit = Math.max(\n            0, nonSelected.length * minHeight - availableForNonSelected);\n\n        let heights = fitProportionally(\n            nonSelectedHeights,\n            availableForNonSelected + deficit\n        );\n\n        if (preAllocatedWindow) {\n            heights.splice(k, 0, selectedHeight - deficit);\n        }\n\n        return heights;\n    }\n}\n\nexport function allocateEqualHeight(column, available) {\n    available -= (column.length - 1) * prefs.window_gap;\n    return column.map(_ => Math.floor(available / column.length));\n}\n\nexport function layoutGrabColumn(column, x, y0, targetWidth, availableHeight, grabWindow) {\n    function mosh(windows, height, y0) {\n        let targetHeights = fitProportionally(\n            windows.map(mw => mw.rect.height),\n            height\n        );\n        let [w, y] = layoutColumnSimple(windows, x, y0, targetWidth, targetHeights);\n        return y;\n    }\n\n    const k = column.indexOf(grabWindow);\n    if (k < 0) {\n        throw new Error(`Anchor doesn't exist in column ${grabWindow.title}`);\n    }\n\n    const gap = prefs.window_gap;\n    const f = grabWindow.globalRect();\n    let yGrabRel = f.y - this.monitor.y;\n    targetWidth = f.width;\n\n    const H1 = (yGrabRel - y0) - gap - (k - 1) * gap;\n    const H2 = availableHeight - (yGrabRel + f.height - y0) - gap - (column.length - k - 2) * gap;\n    k > 0 && mosh(column.slice(0, k), H1, y0);\n    let y = mosh(column.slice(k, k + 1), f.height, yGrabRel);\n    k + 1 < column.length && mosh(column.slice(k + 1), H2, y);\n\n    return targetWidth;\n}\n\n\nexport function layoutColumnSimple(windows, x, y0, targetWidth, targetHeights, time) {\n    let y = y0;\n\n    for (let i = 0; i < windows.length; i++) {\n        let virtWindow = windows[i];\n        let targetHeight = targetHeights[i];\n\n        virtWindow.x = x;\n        virtWindow.y = y;\n        virtWindow.width = targetWidth;\n        virtWindow.height = targetHeight;\n\n        y += targetHeight + prefs.window_gap;\n    }\n    return targetWidth, y;\n}\n\n\n/**\n   Mutates columns\n */\nexport function layout(columns, workArea, prefs, options = {}) {\n    let gap = prefs.window_gap;\n    let availableHeight = workArea.height;\n\n    let { inGrab, selectedWindow } = options;\n    let selectedIndex = -1;\n\n    if (selectedWindow) {\n        selectedIndex = columns.findIndex(col => col.includes(selectedWindow));\n    }\n\n    let y0 = workArea.y;\n    let x = 0;\n\n    for (let i = 0; i < columns.length; i++) {\n        let column = columns[i];\n\n        let selectedInColumn = i === selectedIndex ? selectedWindow : null;\n\n        let targetWidth;\n        if (i === selectedIndex) {\n            targetWidth = selectedInColumn.width;\n        } else {\n            targetWidth = Math.max(...column.map(w => w.width));\n        }\n        targetWidth = Math.min(targetWidth, workArea.width - 2 * prefs.minimum_margin);\n\n        if (inGrab && i === selectedIndex) {\n            layoutGrabColumn(column, x, y0, targetWidth, availableHeight, selectedInColumn);\n        } else {\n            let allocator = options.customAllocators && options.customAllocators[i];\n            allocator = allocator || allocateDefault;\n\n            let targetHeights = allocator(column, availableHeight, selectedInColumn);\n            layoutColumnSimple(column, x, y0, targetWidth, targetHeights);\n        }\n\n        x += targetWidth + gap;\n    }\n\n    return columns;\n}\n"
        },
        {
          "name": "vm.nix",
          "type": "blob",
          "size": 0.9873046875,
          "content": "{ pkgs, config, lib, ... }:\n\n{\n  ### Make PaperWM available in system environment\n  environment.systemPackages = with pkgs;\n  [ paperwm\n  ];\n\n  ### Set graphical session to auto-login GNOME\n  services.xserver =\n  { enable = true;\n    displayManager.autoLogin =\n    { enable = true;\n      user = \"user\";\n    };\n    displayManager.gdm.enable = true;\n    desktopManager.gnome.enable = true;\n  };\n\n  ### Set dconf to enable PaperWM out of the box\n  programs.dconf =\n  { enable = true;\n    profiles.\"user\".databases = [\n      { settings =\n        { \"org/gnome/shell\" =\n          { enabled-extensions = [ \"paperwm@paperwm.github.com\" ];\n          };\n        };\n      }\n    ];\n  };\n\n  ### Set default user\n  users.users.\"user\" =\n  { isNormalUser = true;\n    createHome = true;\n    home = \"/home\";\n    description = \"PaperWM test user\";\n    extraGroups = [ \"wheel\" ];\n    password = \"paperwm\";\n  };\n\n  ### No-password sudo\n  security.sudo =\n  { enable = true;\n    extraConfig = \"%wheel ALL=(ALL) NOPASSWD: ALL\";\n  };\n}\n"
        },
        {
          "name": "winpropsPane.js",
          "type": "blob",
          "size": 10.2607421875,
          "content": "import GLib from 'gi://GLib';\nimport GObject from 'gi://GObject';\nimport Gtk from 'gi://Gtk';\n\nexport const WinpropsPane = GObject.registerClass({\n    GTypeName: 'WinpropsPane',\n    Template: GLib.uri_resolve_relative(import.meta.url, './WinpropsPane.ui', GLib.UriFlags.NONE),\n    InternalChildren: [\n        'search',\n        'listbox',\n        'addButton',\n        'scrolledWindow',\n    ],\n    Signals: {\n        'changed': {},\n    },\n}, class WinpropsPane extends Gtk.Box {\n    _init(params = {}) {\n        super._init(params);\n\n        // define search box filter function (searches wm_class, title, and accelLabel)\n        this._listbox.set_filter_func(row => {\n            let search = this._search.get_text().toLowerCase();\n            let wmclass = row.winprop.wm_class?.toLowerCase() ?? '';\n            let title = row.winprop.title?.toLowerCase() ?? '';\n            let accelLabel = row._accelLabel.label?.toLowerCase() ?? '';\n            return wmclass.includes(search) || title.includes(search) || accelLabel.includes(search);\n        });\n        this._search.connect('changed', () => {\n            this._listbox.invalidate_filter();\n        });\n\n        this._expandedRow = null;\n        this.rows = [];\n        this.workspaces = [];\n    }\n\n    addWinprops(winprops) {\n        winprops.forEach(winprop => {\n            this._listbox.insert(this._createRow(winprop), -1);\n        });\n    }\n\n    setWorkspaces(workspaces) {\n        this.workspaces = workspaces;\n    }\n\n    _removeRow(row) {\n        this._listbox.remove(row);\n        let remove = this.rows.findIndex(r => r === row);\n        if (remove >= 0) {\n            this.rows.splice(remove, 1);\n        }\n        this.emit('changed');\n    }\n\n    _onAddButtonClicked() {\n        // first clear search text, otherwise won't be able to see new row\n        this._search.set_text('');\n\n        let row = this._createRow();\n        row.expanded = true;\n        this._listbox.insert(row, 0);\n        this._scrolledWindow.get_vadjustment().set_value(0);\n    }\n\n    _createRow(winprop) {\n        let wp = winprop ?? { wm_class: '' };\n        const row = new WinpropsRow({ winprop: wp, workspaces: this.workspaces });\n        this.rows.push(row);\n        row.connect('notify::expanded', row => this._onRowExpanded(row));\n        row.connect('row-deleted', row => this._removeRow(row));\n        row.connect('changed', () => this.emit('changed'));\n        return row;\n    }\n\n    _onRowActivated(list, row) {\n        if (!row.is_focus()) {\n            return;\n        }\n        row.expanded = !row.expanded;\n    }\n\n    _onRowExpanded(row) {\n        if (row.expanded) {\n            if (this._expandedRow) {\n                this._expandedRow.expanded = false;\n            }\n            this._expandedRow = row;\n        } else if (this._expandedRow === row) {\n            this._expandedRow = null;\n        }\n    }\n});\n\nexport const WinpropsRow = GObject.registerClass({\n    GTypeName: 'WinpropsRow',\n    Template: GLib.uri_resolve_relative(import.meta.url, './WinpropsRow.ui', GLib.UriFlags.NONE),\n    InternalChildren: [\n        'header',\n        'descLabel',\n        'accelLabel',\n        'revealer',\n        'optionList',\n        'wmClass',\n        'title',\n        'scratchLayer',\n        'preferredWidth',\n        'space',\n        'focus',\n        'deleteButton',\n    ],\n    Properties: {\n        winprop: GObject.ParamSpec.jsobject(\n            'winprop',\n            'winprop',\n            'Winprop',\n            GObject.ParamFlags.READWRITE | GObject.ParamFlags.CONSTRUCT_ONLY\n        ),\n        workspaces: GObject.ParamSpec.jsobject(\n            'workspaces',\n            'workspaces',\n            'Workspaces',\n            GObject.ParamFlags.READWRITE\n        ),\n        expanded: GObject.ParamSpec.boolean(\n            'expanded',\n            'Expanded',\n            'Expanded',\n            GObject.ParamFlags.READWRITE,\n            false\n        ),\n    },\n    Signals: {\n        'changed': {},\n        'row-deleted': {},\n    },\n}, class WinpropsRow extends Gtk.ListBoxRow {\n    _init(params = {}) {\n        super._init(params);\n\n        // description label\n        this._setDescLabel();\n\n        // set the values to current state and connect to 'changed' signal\n        this._wmClass.set_text(this.winprop.wm_class ?? '');\n        this._wmClass.connect('changed', () => {\n            // check if null or empty (we still emit changed if wm_class is wiped)\n            this.checkHasWmClassOrTitle();\n            this.winprop.wm_class = this._wmClass.get_text();\n            this._setDescLabel();\n            this.emit('changed');\n        });\n\n        this._title.set_text(this.winprop.title ?? '');\n        this._title.connect('changed', () => {\n            this.checkHasWmClassOrTitle();\n            this.winprop.title = this._title.get_text();\n            this._setDescLabel();\n            this.emit('changed');\n        });\n\n        this._scratchLayer.set_active(this.winprop.scratch_layer ?? false);\n        this._scratchLayer.connect('state-set', () => {\n            let isActive = this._scratchLayer.get_active();\n            this.winprop.scratch_layer = isActive;\n\n            // if is active then disable the preferredWidth input\n            this._preferredWidth.set_sensitive(!isActive);\n\n            this.emit('changed');\n        });\n\n        this._preferredWidth.set_text(this.winprop.preferredWidth ?? '');\n        // if scratchLayer is active then users can't edit preferredWidth\n        this._preferredWidth.set_sensitive(!this.winprop.scratch_layer ?? true);\n\n        this._preferredWidth.connect('changed', () => {\n            // if has value, needs to be valid (have a value or unit)\n            if (this._preferredWidth.get_text()) {\n                let value = this._preferredWidth.get_text();\n                let digits = (value.match(/\\d+/) ?? [null])[0];\n                let isPercent = /^.*%$/.test(value);\n                let isPixel = /^.*px$/.test(value);\n\n                // check had valid number\n                if (!digits) {\n                    this._setError(this._preferredWidth);\n                }\n                // if no unit defined\n                else if (!isPercent && !isPixel) {\n                    this._setError(this._preferredWidth);\n                }\n                else {\n                    this._setError(this._preferredWidth, false);\n                    this.winprop.preferredWidth = this._preferredWidth.get_text();\n                    this.emit('changed');\n                }\n            } else {\n                // having no preferredWidth is valid\n                this._setError(this._preferredWidth, false);\n                delete this.winprop.preferredWidth;\n                this.emit('changed');\n            }\n        });\n\n        this._space.append_text(\"CURRENT\");\n        for (const [i, name] of this.workspaces.entries()) {\n            // Combo box entries in normal workspace index order\n            this._space.append_text(`${i}: ${name}`);\n        }\n        // index 0 is CURRENT, so add 1\n        this._space.set_active((this.winprop.spaceIndex ?? -1) + 1);\n        this._space.connect('changed', () => {\n            let value = this._space.get_active() - 1;\n            if (value < 0) {\n                value = undefined;\n            }\n            this.winprop.spaceIndex = value;\n            this.emit('changed');\n        });\n\n        this._focus.set_active(this.winprop.focus ?? true);\n        this._focus.connect('state-set', () => {\n            let isActive = this._focus.get_active();\n            this.winprop.focus = isActive;\n            this.emit('changed');\n        });\n\n        this._updateState();\n    }\n\n    /**\n     * Checks has an input for either wmClass or title.\n     * Sets 'error' cssClass is neither.\n     */\n    checkHasWmClassOrTitle() {\n        if (!this._wmClass.get_text() && !this._title.get_text()) {\n            this._setError(this._wmClass);\n            this._setError(this._title);\n            return false;\n        } else {\n            this._setError(this._wmClass, false);\n            this._setError(this._title, false);\n            return true;\n        }\n    }\n\n    /**\n     * Get the wmClass if it exists, otherwise returns the title.\n     * @returns String\n     */\n    getWmClassOrTitle() {\n        if (this.winprop.wm_class) {\n            return this.winprop.wm_class;\n        }\n        else if (this.winprop.title) {\n            return this.winprop.title;\n        }\n        else {\n            return '';\n        }\n    }\n\n    _setError(child, option = true) {\n        if (child) {\n            if (option) {\n                child.add_css_class('error');\n            } else {\n                child.remove_css_class('error');\n            }\n        }\n    }\n\n    get expanded() {\n        if (this._expanded === undefined)\n            this._expanded = false;\n        return this._expanded;\n    }\n\n    set expanded(value) {\n        if (this._expanded === value)\n            return;\n\n        this._expanded = value;\n        this.notify('expanded');\n        this._updateState();\n    }\n\n    _onDeleteButtonClicked() {\n        this.emit('row-deleted');\n    }\n\n    _onRowActivated(list, row) {\n        if (row.is_focus()) {\n            row.editing = !row.editing;\n        }\n    }\n\n    _setAccelLabel() {\n        if (this.winprop.scratch_layer ?? false) {\n            return 'scratch layer';\n        }\n        else if (this.winprop.preferredWidth ?? false) {\n            return 'preferred width';\n        }\n        else if (this.winprop.spaceIndex !== undefined) {\n            return 'workspace';\n        }\n        else {\n            return 'no setting';\n        }\n    }\n\n    /**\n     * Sets the description label for this row.\n     * @returns boolean\n     */\n    _setDescLabel() {\n        // if wmClass, use that, otherwise use title (fallback)\n        if (this.winprop.wm_class) {\n            this._descLabel.label = this.winprop.wm_class;\n        }\n        else if (this.winprop.title) {\n            this._descLabel.label = this.winprop.title;\n        }\n    }\n\n    _updateState() {\n        GLib.idle_add(0, () => {\n            this._accelLabel.label = this._setAccelLabel();\n            if (this.expanded) {\n                this._accelLabel.hide();\n                this._revealer.reveal_child = true;\n                this.add_css_class('expanded');\n            } else {\n                this._accelLabel.show();\n                this._revealer.reveal_child = false;\n                this.remove_css_class('expanded');\n            }\n        });\n    }\n});\n"
        },
        {
          "name": "workspace.js",
          "type": "blob",
          "size": 4.5546875,
          "content": "import Gio from 'gi://Gio';\nimport GLib from 'gi://GLib';\n\nimport * as Lib from './lib.js';\n\n/**\n * Workspace related utility functions used by other modules.\n */\nconst WORKSPACE_LIST_KEY = 'org.gnome.shell.extensions.paperwm.workspacelist';\nconst WORKSPACE_KEY = 'org.gnome.shell.extensions.paperwm.workspace';\n\nexport class WorkspaceSettings {\n    constructor(extension) {\n        this.workspaceSettingsCache = {};\n        this.schemaSource = Gio.SettingsSchemaSource.new_from_directory(\n            GLib.build_filenamev([extension.path, \"schemas\"]),\n            Gio.SettingsSchemaSource.get_default(),\n            false\n        );\n\n        this.workspaceList = new Gio.Settings({\n            settings_schema: this.getSchemaSource().lookup(WORKSPACE_LIST_KEY, true),\n        });\n    }\n\n    getSchemaSource() {\n        return this.schemaSource;\n    }\n\n    getWorkspaceName(settings, index) {\n        let name = settings.get_string('name') ?? `Workspace ${index + 1}`;\n        if (!name || name === '') {\n            name = `Workspace ${index + 1}`;\n        }\n        return name;\n    }\n\n    getWorkspaceList() {\n        return this.workspaceList;\n    }\n\n    /**\n     * Returns list of ordered workspace UUIDs.\n     */\n    getListUUID() {\n        return this.getWorkspaceList().get_strv('list');\n    }\n\n    getWorkspaceSettings(index) {\n        let list = this.getListUUID();\n        for (let uuid of list) {\n            let settings = this.getWorkspaceSettingsByUUID(uuid);\n            if (settings.get_int('index') === index) {\n                return [uuid, settings];\n            }\n        }\n        return this.getNewWorkspaceSettings(index);\n    }\n\n    getNewWorkspaceSettings(index) {\n        let uuid = GLib.uuid_string_random();\n        let settings = this.getWorkspaceSettingsByUUID(uuid);\n        let list = this.getListUUID();\n        list.push(uuid);\n        this.getWorkspaceList().set_strv('list', list);\n        settings.set_int('index', index);\n        return [uuid, settings];\n    }\n\n    getWorkspaceSettingsByUUID(uuid) {\n        if (!this.workspaceSettingsCache[uuid]) {\n            let settings = new Gio.Settings({\n                settings_schema: this.getSchemaSource().lookup(WORKSPACE_KEY, true),\n                path: `/org/gnome/shell/extensions/paperwm/workspaces/${uuid}/`,\n            });\n            this.workspaceSettingsCache[uuid] = settings;\n        }\n        return this.workspaceSettingsCache[uuid];\n    }\n\n    /** Returns [[uuid, settings, name], ...] (Only used for debugging/development atm.) */\n    findWorkspaceSettingsByName(regex) {\n        let list = this.getListUUID();\n        let settings = list.map(this.getWorkspaceSettingsByUUID);\n        return Lib.zip(list, settings, settings.map(s => s.get_string('name')))\n            .filter(([uuid, s, name]) => name.match(regex));\n    }\n\n    /** Only used for debugging/development atm. */\n    deleteWorkspaceSettingsByName(regex, dryrun = true) {\n        let out = \"\";\n        function rprint(...args) { console.debug(...args); out += `${args.join(\" \")}\\n`; }\n        let n = global.workspace_manager.get_n_workspaces();\n        for (let [uuid, s, name] of this.findWorkspaceSettingsByName(regex)) {\n            let index = s.get_int('index');\n            if (index < n) {\n                rprint(\"Skipping in-use settings\", name, index);\n                continue;\n            }\n            rprint(dryrun ? \"[dry]\" : \"\", `Delete settings for '${name}' (${uuid})`);\n            if (!dryrun) {\n                this.deleteWorkspaceSettings(uuid);\n            }\n        }\n        return out;\n    }\n\n    /** Only used for debugging/development atm. */\n    deleteWorkspaceSettings(uuid) {\n        // NB! Does not check if the settings is currently in use. Does not reindex subsequent settings.\n        let list = this.getListUUID();\n        let i = list.indexOf(uuid);\n        let settings = this.getWorkspaceSettingsByUUID(list[i]);\n        for (let key of settings.list_keys()) {\n            // Hopefully resetting all keys will delete the relocatable settings from dconf?\n            settings.reset(key);\n        }\n\n        list.splice(i, 1);\n        this.getWorkspaceList().set_strv('list', list);\n    }\n\n    // Useful for debugging\n    printWorkspaceSettings() {\n        let list = this.getListUUID();\n        let settings = list.map(this.getWorkspaceSettingsByUUID);\n        let zipped = Lib.zip(list, settings);\n        const key = s => s[1].get_int('index');\n        zipped.sort((a, b) => key(a) - key(b));\n        for (let [uuid, s] of zipped) {\n            console.log('index:', s.get_int('index'), s.get_string('name'), s.get_string('color'), uuid);\n        }\n    }\n}\n"
        }
      ]
    }
  ]
}