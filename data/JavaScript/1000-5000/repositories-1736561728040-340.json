{
  "metadata": {
    "timestamp": 1736561728040,
    "page": 340,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jimmywarting/StreamSaver.js",
      "stars": 4105,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.05078125,
          "content": "root = true\n\n[*]\nindent_style = tab\nindent_size = 4\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0673828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Jimmy Karl Roland Wärting\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.6005859375,
          "content": "StreamSaver.js (legacy-ish)\n===========================\n\n... Don't worry it's not deprecated. It's still maintained and i still recommend \nusing this when needed. Just want to let you know that there is this new native way\nto save files to the HD: https://github.com/whatwg/fs which is more\nor less going to make FileSaver, StreamSaver and similar packages a bit obsolete\nin the future, it'still in a experimental stage and not implemented by all browser.\nThat is why I also built [native-file-system-adapter](https://github.com/jimmywarting/native-file-system-adapter)\nso you can have it in all Browsers, Deno, and NodeJS with different storages\n\n[![npm version][npm-image]][npm-url]\n\n**StreamSaver.js is the solution to saving streams in the web browser.\nIt is perfect for web apps where there's a need to save large amounts of data on devices with e.g. limited RAM.**\n\nFirst I want to thank [Eli Grey][1] for a fantastic work implementing the\n[FileSaver.js][2] to save files & blobs so easily!\nBut there is one obstacle - The RAM it can hold and the max blob size limitation\n\nStreamSaver.js takes a different approach. Instead of saving data in client-side\nstorage or in memory you could now actually create a writable stream directly to\nthe file system (I'm not talking about chromes sandboxed file system or any other\nweb storage). This is accomplish by emulating how a server would instruct the\nbrowser to save a file using some response header + service worker\n\n**If the file you are trying to save comes from the cloud/server** use the server instead\nof emulating what the browser does to save files on the disk using StreamSaver.\nAdd those extra Response headers and **don't use AJAX** to get it. FileSaver has\na good [wiki](https://github.com/eligrey/FileSaver.js/wiki/Saving-a-remote-file)\nabout using headers. If you can't change the headers then you may use StreamSaver\nas a last resort. FileSaver, streamsaver and others alike are mostly for client\ngenerated content inside the browser.\n\nGetting started\n===============\nStreamSaver in it's simplest form\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/web-streams-polyfill@2.0.2/dist/ponyfill.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/streamsaver@2.0.3/StreamSaver.min.js\"></script>\n<script>\n  import streamSaver from 'streamsaver'\n  const streamSaver = require('streamsaver')\n  const streamSaver = window.streamSaver\n</script>\n<script>\n  const uInt8 = new TextEncoder().encode('StreamSaver is awesome')\n\n  // streamSaver.createWriteStream() returns a writable byte stream\n  // The WritableStream only accepts Uint8Array chunks\n  // (no other typed arrays, arrayBuffers or strings are allowed)\n  const fileStream = streamSaver.createWriteStream('filename.txt', {\n    size: uInt8.byteLength, // (optional filesize) Will show progress\n    writableStrategy: undefined, // (optional)\n    readableStrategy: undefined  // (optional)\n  })\n\n  if (manual) {\n    const writer = fileStream.getWriter()\n    writer.write(uInt8)\n    writer.close()\n  } else {\n    // using Response can be a great tool to convert\n    // mostly anything (blob, string, buffers) into a byte stream\n    // that can be piped to StreamSaver\n    //\n    // You could also use a transform stream that would sit\n    // between and convert everything to Uint8Arrays\n    new Response('StreamSaver is awesome').body\n      .pipeTo(fileStream)\n      .then(success, error)\n  }\n</script>\n```\n\nSome browser have ReadableStream but not WritableStream. [web-streams-polyfill](https://github.com/MattiasBuelens/web-streams-polyfill) can fix this gap. It's better to load the ponyfill instead of the polyfill and override the existing implementation because StreamSaver works better when a native ReadableStream is transferable to the service worker. hopefully [MattiasBuelens](https://github.com/MattiasBuelens) will fix the missing implementations instead of overriding the existing. If you think you can help out here is the [issue](https://github.com/MattiasBuelens/web-streams-polyfill/issues/20)\n\n## Best practice\n\n**Use https** if you can. That way you don't have to open the man in the middle\nin a popup to install the service worker from another secure context. Popups are often blocked\nbut if you can't it's best that you **initiate the `createWriteStream`\non user interaction**. Even if you don't have any data ready - this is so that you can get around the popup blockers. (In secure context this don't matter)\nAnother benefit of using https is that the mitm-iframe can ping the service worker to prevent it from going idle. (worker goes idle after 30 sec in firefox, 5 minutes in blink) but also this won't mater if the browser supports [transferable streams](https://github.com/whatwg/streams/blob/master/transferable-streams-explainer.md) throught postMessage since service worker don't have to handle any logic. (the stream that you transfer to the service worker will be the stream we respond with)\n\n**Handle unload event** when user leaves the page. The download gets broken when you leave the page.\nBecause it looks like a regular native download process some might think that it's okey to leave the page beforehand since it's is downloading in the background directly from some a server, but it isn't.\n\n```js\n// abort so it dose not look stuck\nwindow.onunload = () => {\n  writableStream.abort()\n  // also possible to call abort on the writer you got from `getWriter()`\n  writer.abort()\n}\n\nwindow.onbeforeunload = evt => {\n  if (!done) {\n    evt.returnValue = `Are you sure you want to leave?`;\n  }\n}\n```\nNote that when using insecure context StreamSaver will navigate to the download url instead of using an hidden iframe to initiate the download, this will trigger the `onbefureunload` event when the download starts, but it will not call the `onunload` event... In secure context you can add this handler immediately. Otherwise this has to be added sometime later.\n\n# Configuration\n\nThere a some few settings you can apply to StreamSaver to configure what it should use\n\n```js\n// StreamSaver can detect and use the Ponyfill that is loaded from the cdn.\nstreamSaver.WritableStream = streamSaver.WritableStream\nstreamSaver.TransformStream = streamSaver.TransformStream\n// if you decide to host mitm + sw yourself\nstreamSaver.mitm = 'https://example.com/custom_mitm.html'\n```\n\nExamples\n========\n\nThere are a few examples in the [examples] directory\n\n- [Saving audio or video stream using mediaRecorder](https://jimmywarting.github.io/StreamSaver.js/examples/media-stream.html)\n- [Piping a fetch response to StreamSaver](https://jimmywarting.github.io/StreamSaver.js/examples/fetch.html)\n- [Write as you type](https://jimmywarting.github.io/StreamSaver.js/examples/plain-text.html)\n- [Saving a blob/file](https://jimmywarting.github.io/StreamSaver.js/examples/saving-a-blob.html)\n- [Saving a file using webtorrent](https://jimmywarting.github.io/StreamSaver.js/examples/torrent.html)\n- [Saving multiple files as a zip](https://jimmywarting.github.io/StreamSaver.js/examples/saving-multiple-files.html)\n- [slowly write 1 byte / sec](https://jimmywarting.github.io/StreamSaver.js/examples/write-slowly.html)\n\nIn the wild\n- [Adding ID3 tag to mp3 file on the fly](https://egoroof.github.io/browser-id3-writer/stream.html) - by [Artyom Egorov](https://github.com/egoroof)\n\n\nHow does it work?\n=====================\nThere is no magical `saveAs()` function that saves a stream, file or blob. (at least not if/when native-filesystem api becomes available)\nThe way we mostly save Blobs/Files today is with the help of [Object URLs](https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL) and  [`a[download]`][5] attribute\n[FileSaver.js][2] takes advantage of this and create a convenient `saveAs(blob, filename)`. fantastic! But you can't create a objectUrl from a stream and attach\nit to a link...\n```javascript\nlink = document.createElement('a')\nlink.href = URL.createObjectURL(stream) // DOES NOT WORK\nlink.download = 'filename'\nlink.click() // Save\n```\nSo the one and only other solution is to do what the server does: Send a stream\nwith `Content-Disposition` header to tell the browser to save the file.\nBut we don't have a server or the content isn't on a server! So the solution is to create a service worker\nthat can intercept request and use [respondWith()][4] and act as a server.<br>\nBut a service workers are only allowed in secure contexts and it requires some effort to put up. Most of the time you are working in the main thread and the service worker are only alive for < 5 minutes before it goes idle.<br>\n\n 1. So StreamSaver creates a own man in the middle that installs the service worker in a secure context hosted on github static pages. either from a iframe (in secure context) or a new popup if your page is insecure.\n 2. Transfer the stream (or DataChannel) over to the service worker using postMessage.\n 3. And then the worker creates a download link that we then open.\n\nif a \"transferable\" readable stream was not passed to the service worker then the mitm will also try to keep the service worker alive by pinging it every x second to prevent it from going idle.\n\nTo test this locally, spin up a local server<br>\n(we don't use any pre compiler or such)\n```bash\n# A simple php or python server is enough\nphp -S localhost:3001\npython -m SimpleHTTPServer 3001\n# then open localhost:3001/example.html\n```\n\n\n[1]: https://github.com/eligrey\n[2]: https://github.com/eligrey/FileSaver.js\n[3]: https://github.com/jimmywarting/StreamSaver.js/blob/master/example.html\n[4]: https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith\n[5]: https://developer.mozilla.org/en/docs/Web/HTML/Element/a#attr-download\n[6]: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\n[7]: https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel\n[8]: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/postMessage\n[9]: https://developer.mozilla.org/en/docs/Web/API/Fetch_API\n[10]: https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith\n[11]: https://developer.mozilla.org/en/docs/Web/HTML/Element/iframe\n[12]: https://developer.mozilla.org/en-US/docs/Web/API/Window/open\n[13]: https://developer.mozilla.org/en-US/docs/Web/API/Response\n[14]: https://streams.spec.whatwg.org/#rs-class\n[ReadableStream]: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\n[WritableStream]: https://developer.mozilla.org/en-US/docs/Web/API/WritableStream\n[15]: https://www.npmjs.com/package/@mattiasbuelens/web-streams-polyfill\n[16]: https://developer.microsoft.com/en-us/microsoft-edge/platform/status/fetchapi\n[19]: https://webtorrent.io\n[examples]: https://github.com/jimmywarting/StreamSaver.js/blob/master/examples\n[npm-image]: https://img.shields.io/npm/v/streamsaver.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/streamsaver\n"
        },
        {
          "name": "StreamSaver.js",
          "type": "blob",
          "size": 10.0615234375,
          "content": "/*! streamsaver. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n/* global chrome location ReadableStream define MessageChannel TransformStream */\n\n;((name, definition) => {\n  typeof module !== 'undefined'\n    ? module.exports = definition()\n    : typeof define === 'function' && typeof define.amd === 'object'\n      ? define(definition)\n      : this[name] = definition()\n})('streamSaver', () => {\n  'use strict'\n\n  const global = typeof window === 'object' ? window : this\n  if (!global.HTMLElement) console.warn('streamsaver is meant to run on browsers main thread')\n\n  let mitmTransporter = null\n  let supportsTransferable = false\n  const test = fn => { try { fn() } catch (e) {} }\n  const ponyfill = global.WebStreamsPolyfill || {}\n  const isSecureContext = global.isSecureContext\n  // TODO: Must come up with a real detection test (#69)\n  let useBlobFallback = /constructor/i.test(global.HTMLElement) || !!global.safari || !!global.WebKitPoint\n  const downloadStrategy = isSecureContext || 'MozAppearance' in document.documentElement.style\n    ? 'iframe'\n    : 'navigate'\n\n  const streamSaver = {\n    createWriteStream,\n    WritableStream: global.WritableStream || ponyfill.WritableStream,\n    supported: true,\n    version: { full: '2.0.5', major: 2, minor: 0, dot: 5 },\n    mitm: 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0'\n  }\n\n  /**\n   * create a hidden iframe and append it to the DOM (body)\n   *\n   * @param  {string} src page to load\n   * @return {HTMLIFrameElement} page to load\n   */\n  function makeIframe (src) {\n    if (!src) throw new Error('meh')\n    const iframe = document.createElement('iframe')\n    iframe.hidden = true\n    iframe.src = src\n    iframe.loaded = false\n    iframe.name = 'iframe'\n    iframe.isIframe = true\n    iframe.postMessage = (...args) => iframe.contentWindow.postMessage(...args)\n    iframe.addEventListener('load', () => {\n      iframe.loaded = true\n    }, { once: true })\n    document.body.appendChild(iframe)\n    return iframe\n  }\n\n  /**\n   * create a popup that simulates the basic things\n   * of what a iframe can do\n   *\n   * @param  {string} src page to load\n   * @return {object}     iframe like object\n   */\n  function makePopup (src) {\n    const options = 'width=200,height=100'\n    const delegate = document.createDocumentFragment()\n    const popup = {\n      frame: global.open(src, 'popup', options),\n      loaded: false,\n      isIframe: false,\n      isPopup: true,\n      remove () { popup.frame.close() },\n      addEventListener (...args) { delegate.addEventListener(...args) },\n      dispatchEvent (...args) { delegate.dispatchEvent(...args) },\n      removeEventListener (...args) { delegate.removeEventListener(...args) },\n      postMessage (...args) { popup.frame.postMessage(...args) }\n    }\n\n    const onReady = evt => {\n      if (evt.source === popup.frame) {\n        popup.loaded = true\n        global.removeEventListener('message', onReady)\n        popup.dispatchEvent(new Event('load'))\n      }\n    }\n\n    global.addEventListener('message', onReady)\n\n    return popup\n  }\n\n  try {\n    // We can't look for service worker since it may still work on http\n    new Response(new ReadableStream())\n    if (isSecureContext && !('serviceWorker' in navigator)) {\n      useBlobFallback = true\n    }\n  } catch (err) {\n    useBlobFallback = true\n  }\n\n  test(() => {\n    // Transferable stream was first enabled in chrome v73 behind a flag\n    const { readable } = new TransformStream()\n    const mc = new MessageChannel()\n    mc.port1.postMessage(readable, [readable])\n    mc.port1.close()\n    mc.port2.close()\n    supportsTransferable = true\n    // Freeze TransformStream object (can only work with native)\n    Object.defineProperty(streamSaver, 'TransformStream', {\n      configurable: false,\n      writable: false,\n      value: TransformStream\n    })\n  })\n\n  function loadTransporter () {\n    if (!mitmTransporter) {\n      mitmTransporter = isSecureContext\n        ? makeIframe(streamSaver.mitm)\n        : makePopup(streamSaver.mitm)\n    }\n  }\n\n  /**\n   * @param  {string} filename filename that should be used\n   * @param  {object} options  [description]\n   * @param  {number} size     deprecated\n   * @return {WritableStream<Uint8Array>}\n   */\n  function createWriteStream (filename, options, size) {\n    let opts = {\n      size: null,\n      pathname: null,\n      writableStrategy: undefined,\n      readableStrategy: undefined\n    }\n\n    let bytesWritten = 0 // by StreamSaver.js (not the service worker)\n    let downloadUrl = null\n    let channel = null\n    let ts = null\n\n    // normalize arguments\n    if (Number.isFinite(options)) {\n      [ size, options ] = [ options, size ]\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else if (options && options.highWaterMark) {\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else {\n      opts = options || {}\n    }\n    if (!useBlobFallback) {\n      loadTransporter()\n\n      channel = new MessageChannel()\n\n      // Make filename RFC5987 compatible\n      filename = encodeURIComponent(filename.replace(/\\//g, ':'))\n        .replace(/['()]/g, escape)\n        .replace(/\\*/g, '%2A')\n\n      const response = {\n        transferringReadable: supportsTransferable,\n        pathname: opts.pathname || Math.random().toString().slice(-6) + '/' + filename,\n        headers: {\n          'Content-Type': 'application/octet-stream; charset=utf-8',\n          'Content-Disposition': \"attachment; filename*=UTF-8''\" + filename\n        }\n      }\n\n      if (opts.size) {\n        response.headers['Content-Length'] = opts.size\n      }\n\n      const args = [ response, '*', [ channel.port2 ] ]\n\n      if (supportsTransferable) {\n        const transformer = downloadStrategy === 'iframe' ? undefined : {\n          // This transformer & flush method is only used by insecure context.\n          transform (chunk, controller) {\n            if (!(chunk instanceof Uint8Array)) {\n              throw new TypeError('Can only write Uint8Arrays')\n            }\n            bytesWritten += chunk.length\n            controller.enqueue(chunk)\n\n            if (downloadUrl) {\n              location.href = downloadUrl\n              downloadUrl = null\n            }\n          },\n          flush () {\n            if (downloadUrl) {\n              location.href = downloadUrl\n            }\n          }\n        }\n        ts = new streamSaver.TransformStream(\n          transformer,\n          opts.writableStrategy,\n          opts.readableStrategy\n        )\n        const readableStream = ts.readable\n\n        channel.port1.postMessage({ readableStream }, [ readableStream ])\n      }\n\n      channel.port1.onmessage = evt => {\n        // Service worker sent us a link that we should open.\n        if (evt.data.download) {\n          // Special treatment for popup...\n          if (downloadStrategy === 'navigate') {\n            mitmTransporter.remove()\n            mitmTransporter = null\n            if (bytesWritten) {\n              location.href = evt.data.download\n            } else {\n              downloadUrl = evt.data.download\n            }\n          } else {\n            if (mitmTransporter.isPopup) {\n              mitmTransporter.remove()\n              mitmTransporter = null\n              // Special case for firefox, they can keep sw alive with fetch\n              if (downloadStrategy === 'iframe') {\n                makeIframe(streamSaver.mitm)\n              }\n            }\n\n            // We never remove this iframes b/c it can interrupt saving\n            makeIframe(evt.data.download)\n          }\n        } else if (evt.data.abort) {\n          chunks = []\n          channel.port1.postMessage('abort') //send back so controller is aborted\n          channel.port1.onmessage = null\n          channel.port1.close()\n          channel.port2.close()\n          channel = null\n        }\n      }\n\n      if (mitmTransporter.loaded) {\n        mitmTransporter.postMessage(...args)\n      } else {\n        mitmTransporter.addEventListener('load', () => {\n          mitmTransporter.postMessage(...args)\n        }, { once: true })\n      }\n    }\n\n    let chunks = []\n\n    return (!useBlobFallback && ts && ts.writable) || new streamSaver.WritableStream({\n      write (chunk) {\n        if (!(chunk instanceof Uint8Array)) {\n          throw new TypeError('Can only write Uint8Arrays')\n        }\n        if (useBlobFallback) {\n          // Safari... The new IE6\n          // https://github.com/jimmywarting/StreamSaver.js/issues/69\n          //\n          // even though it has everything it fails to download anything\n          // that comes from the service worker..!\n          chunks.push(chunk)\n          return\n        }\n\n        // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transferable streams solves this...\n        channel.port1.postMessage(chunk)\n        bytesWritten += chunk.length\n\n        if (downloadUrl) {\n          location.href = downloadUrl\n          downloadUrl = null\n        }\n      },\n      close () {\n        if (useBlobFallback) {\n          const blob = new Blob(chunks, { type: 'application/octet-stream; charset=utf-8' })\n          const link = document.createElement('a')\n          link.href = URL.createObjectURL(blob)\n          link.download = filename\n          link.click()\n        } else {\n          channel.port1.postMessage('end')\n        }\n      },\n      abort () {\n        chunks = []\n        channel.port1.postMessage('abort')\n        channel.port1.onmessage = null\n        channel.port1.close()\n        channel.port2.close()\n        channel = null\n      }\n    }, opts.writableStrategy)\n  }\n\n  return streamSaver\n})\n"
        },
        {
          "name": "example.html",
          "type": "blob",
          "size": 2.6474609375,
          "content": "<!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>StreamSaver example codes</title>\n  </head>\n  <body>\n    <a class=\"github-corner\" target=\"_blank\" href=\"https://github.com/jimmywarting/StreamSaver.js\">\n      <svg width=\"100\" height=\"100\" viewbox=\"0 0 250 250\" style=\"fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;\">\n        <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\"></path>\n        <path d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\" fill=\"currentColor\" style=\"transform-origin: 130px 106px;\" class=\"octo-arm\"></path><path d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\" fill=\"currentColor\" class=\"octo-body\"></path>\n        <text class=\"github-corner-text\" text-anchor=\"middle\" x=\"175\" y=\"25\" transform=\"rotate(45)\" font-size=\"30\" font-weight=\"bold\">Fork me on Github</text>\n      </svg>\n      <style>.github-corner:hover .octo-arm{animation: octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%, 100%{transform: rotate(0)}20%, 60%{transform: rotate(-25deg)}40%, 80%{transform: rotate(10deg)}}@media (max-width: 500px){.github-corner:hover .octo-arm{animation: none}.github-corner .octo-arm{animation: octocat-wave 560ms ease-in-out}.github-corner-text{display: none;}.github-corner svg{height: 50px; width: 50px;}}</style>\n    </a>\n\n    <h2>Example of saving a stream directly to the filesystem</h2>\n    <nav itemscope=\"itemscope\" itemtype=\"http://www.schema.org/SiteNavigationElement\">\n      <li><a href=\"examples/media-stream.html\">Saving audio or video stream using mediaRecorder</a>\n      <li><a href=\"examples/fetch.html\">Piping a fetch response to StreamSaver</a>\n      <li><a href=\"examples/plain-text.html\">Write as you type</a>\n      <li><a href=\"examples/torrent.html\">Saving a file using webtorrent</a>\n      <li><a href=\"examples/saving-a-blob.html\">Saving one Blob (File)</a>\n      <li><a href=\"examples/saving-multiple-files.html\">Saving multiple files as a zip</a>\n      <li><a href=\"examples/write-slowly.html\">Slowly write 1 byte / sec</a>\n    </nav>\n  </body>\n</html>\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "mitm.html",
          "type": "blob",
          "size": 5.50390625,
          "content": "<!--\n\tmitm.html is the lite \"man in the middle\"\n\n\tThis is only meant to signal the opener's messageChannel to\n\tthe service worker - when that is done this mitm can be closed\n    but it's better to keep it alive since this also stops the sw\n    from restarting\n\n\tThe service worker is capable of intercepting all request and fork their\n\town \"fake\" response - wish we are going to craft\n\twhen the worker then receives a stream then the worker will tell the opener\n\tto open up a link that will start the download\n-->\n<script>\n// This will prevent the sw from restarting\nlet keepAlive = () => {\n  keepAlive = () => {}\n  var ping = location.href.substr(0, location.href.lastIndexOf('/')) + '/ping'\n  var interval = setInterval(() => {\n    if (sw) {\n      sw.postMessage('ping')\n    } else {\n      fetch(ping).then(res => res.text(!res.ok && clearInterval(interval)))\n    }\n  }, 10000)\n}\n\n// message event is the first thing we need to setup a listner for\n// don't want the opener to do a random timeout - instead they can listen for\n// the ready event\n// but since we need to wait for the Service Worker registration, we store the\n// message for later\nlet messages = []\nwindow.onmessage = evt => messages.push(evt)\n\nlet sw = null\nlet scope = ''\n\nfunction registerWorker() {\n  return navigator.serviceWorker.getRegistration('./').then(swReg => {\n    return swReg || navigator.serviceWorker.register('sw.js', { scope: './' })\n  }).then(swReg => {\n    const swRegTmp = swReg.installing || swReg.waiting\n\n    scope = swReg.scope\n\n    return (sw = swReg.active) || new Promise(resolve => {\n      swRegTmp.addEventListener('statechange', fn = () => {\n        if (swRegTmp.state === 'activated') {\n          swRegTmp.removeEventListener('statechange', fn)\n          sw = swReg.active\n          resolve()\n        }\n      })\n    })\n  })\n}\n\n// Now that we have the Service Worker registered we can process messages\nfunction onMessage (event) {\n  let { data, ports, origin } = event\n\n  // It's important to have a messageChannel, don't want to interfere\n  // with other simultaneous downloads\n  if (!ports || !ports.length) {\n    throw new TypeError(\"[StreamSaver] You didn't send a messageChannel\")\n  }\n\n  if (typeof data !== 'object') {\n    throw new TypeError(\"[StreamSaver] You didn't send a object\")\n  }\n\n  // the default public service worker for StreamSaver is shared among others.\n  // so all download links needs to be prefixed to avoid any other conflict\n  data.origin = origin\n\n  // if we ever (in some feature versoin of streamsaver) would like to\n  // redirect back to the page of who initiated a http request\n  data.referrer = data.referrer || document.referrer || origin\n\n  // pass along version for possible backwards compatibility in sw.js\n  data.streamSaverVersion = new URLSearchParams(location.search).get('version')\n\n  if (data.streamSaverVersion === '1.2.0') {\n    console.warn('[StreamSaver] please update streamsaver')\n  }\n\n  /** @since v2.0.0 */\n  if (!data.headers) {\n    console.warn(\"[StreamSaver] pass `data.headers` that you would like to pass along to the service worker\\nit should be a 2D array or a key/val object that fetch's Headers api accepts\")\n  } else {\n    // test if it's correct\n    // should thorw a typeError if not\n    new Headers(data.headers)\n  }\n\n  /** @since v2.0.0 */\n  if (typeof data.filename === 'string') {\n    console.warn(\"[StreamSaver] You shouldn't send `data.filename` anymore. It should be included in the Content-Disposition header option\")\n    // Do what File constructor do with fileNames\n    data.filename = data.filename.replace(/\\//g, ':')\n  }\n\n  /** @since v2.0.0 */\n  if (data.size) {\n    console.warn(\"[StreamSaver] You shouldn't send `data.size` anymore. It should be included in the content-length header option\")\n  }\n\n  /** @since v2.0.0 */\n  if (data.readableStream) {\n    console.warn(\"[StreamSaver] You should send the readableStream in the messageChannel, not throught mitm\")\n  }\n\n  /** @since v2.0.0 */\n  if (!data.pathname) {\n    console.warn(\"[StreamSaver] Please send `data.pathname` (eg: /pictures/summer.jpg)\")\n    data.pathname = Math.random().toString().slice(-6) + '/' + data.filename\n  }\n\n  // remove all leading slashes\n  data.pathname = data.pathname.replace(/^\\/+/g, '')\n\n  // remove protocol\n  let org = origin.replace(/(^\\w+:|^)\\/\\//, '')\n\n  // set the absolute pathname to the download url.\n  data.url = new URL(`${scope + org}/${data.pathname}`).toString()\n\n  if (!data.url.startsWith(`${scope + org}/`)) {\n    throw new TypeError('[StreamSaver] bad `data.pathname`')\n  }\n\n  // This sends the message data as well as transferring\n  // messageChannel.port2 to the service worker. The service worker can\n  // then use the transferred port to reply via postMessage(), which\n  // will in turn trigger the onmessage handler on messageChannel.port1.\n\n  const transferable = data.readableStream\n    ? [ ports[0], data.readableStream ]\n    : [ ports[0] ]\n\n  if (!(data.readableStream || data.transferringReadable)) {\n    keepAlive()\n  }\n\n  return sw.postMessage(data, transferable)\n}\n\nif (window.opener) {\n  // The opener can't listen to onload event, so we need to help em out!\n  // (telling them that we are ready to accept postMessage's)\n  window.opener.postMessage('StreamSaver::loadedPopup', '*')\n}\n\nif (navigator.serviceWorker) {\n  registerWorker().then(() => {\n    window.onmessage = onMessage\n    messages.forEach(window.onmessage)\n  })\n}\n\n// FF v102 just started to supports transferable streams, but still needs to ping sw.js\n// even tough the service worker dose not have to do any kind of work and listen to any\n// messages... #305\nkeepAlive()\n\n</script>\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.861328125,
          "content": "{\n    \"name\": \"streamsaver\",\n    \"version\": \"2.0.6\",\n    \"description\": \"StreamSaver writes stream to the filesystem directly - asynchronous\",\n    \"main\": \"StreamSaver.js\",\n    \"scripts\": {\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 0\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"git+https://jimmywarting@github.com/jimmywarting/StreamSaver.js.git\"\n    },\n    \"keywords\": [\n        \"saving\",\n        \"streams\",\n        \"stream\",\n        \"html5\",\n        \"file\",\n        \"blob\"\n    ],\n    \"author\": \"Jimmy Wärting <jimmy@warting.se>\",\n    \"license\": \"MIT\",\n    \"bugs\": {\n        \"url\": \"https://github.com/jimmywarting/StreamSaver.js/issues\"\n    },\n    \"homepage\": \"https://github.com/jimmywarting/StreamSaver.js#readme\",\n\t\"funding\": [\n      {\n        \"type\": \"github\",\n        \"url\": \"https://github.com/sponsors/jimmywarting\"\n      }\n    ]\n}\n"
        },
        {
          "name": "sw.js",
          "type": "blob",
          "size": 3.6455078125,
          "content": "/* global self ReadableStream Response */\n\nself.addEventListener('install', () => {\n  self.skipWaiting()\n})\n\nself.addEventListener('activate', event => {\n  event.waitUntil(self.clients.claim())\n})\n\nconst map = new Map()\n\n// This should be called once per download\n// Each event has a dataChannel that the data will be piped through\nself.onmessage = event => {\n  // We send a heartbeat every x second to keep the\n  // service worker alive if a transferable stream is not sent\n  if (event.data === 'ping') {\n    return\n  }\n\n  const data = event.data\n  const downloadUrl = data.url || self.registration.scope + Math.random() + '/' + (typeof data === 'string' ? data : data.filename)\n  const port = event.ports[0]\n  const metadata = new Array(3) // [stream, data, port]\n\n  metadata[1] = data\n  metadata[2] = port\n\n  // Note to self:\n  // old streamsaver v1.2.0 might still use `readableStream`...\n  // but v2.0.0 will always transfer the stream through MessageChannel #94\n  if (event.data.readableStream) {\n    metadata[0] = event.data.readableStream\n  } else if (event.data.transferringReadable) {\n    port.onmessage = evt => {\n      port.onmessage = null\n      metadata[0] = evt.data.readableStream\n    }\n  } else {\n    metadata[0] = createStream(port)\n  }\n\n  map.set(downloadUrl, metadata)\n  port.postMessage({ download: downloadUrl })\n}\n\nfunction createStream (port) {\n  // ReadableStream is only supported by chrome 52\n  return new ReadableStream({\n    start (controller) {\n      // When we receive data on the messageChannel, we write\n      port.onmessage = ({ data }) => {\n        if (data === 'end') {\n          return controller.close()\n        }\n\n        if (data === 'abort') {\n          controller.error('Aborted the download')\n          return\n        }\n\n        controller.enqueue(data)\n      }\n    },\n    cancel (reason) {\n      console.log('user aborted', reason)\n      port.postMessage({ abort: true })\n    }\n  })\n}\n\nself.onfetch = event => {\n  const url = event.request.url\n\n  // this only works for Firefox\n  if (url.endsWith('/ping')) {\n    return event.respondWith(new Response('pong'))\n  }\n\n  const hijacke = map.get(url)\n\n  if (!hijacke) return null\n\n  const [ stream, data, port ] = hijacke\n\n  map.delete(url)\n\n  // Not comfortable letting any user control all headers\n  // so we only copy over the length & disposition\n  const responseHeaders = new Headers({\n    'Content-Type': 'application/octet-stream; charset=utf-8',\n\n    // To be on the safe side, The link can be opened in a iframe.\n    // but octet-stream should stop it.\n    'Content-Security-Policy': \"default-src 'none'\",\n    'X-Content-Security-Policy': \"default-src 'none'\",\n    'X-WebKit-CSP': \"default-src 'none'\",\n    'X-XSS-Protection': '1; mode=block',\n    'Cross-Origin-Embedder-Policy': 'require-corp'\n  })\n\n  let headers = new Headers(data.headers || {})\n\n  if (headers.has('Content-Length')) {\n    responseHeaders.set('Content-Length', headers.get('Content-Length'))\n  }\n\n  if (headers.has('Content-Disposition')) {\n    responseHeaders.set('Content-Disposition', headers.get('Content-Disposition'))\n  }\n\n  // data, data.filename and size should not be used anymore\n  if (data.size) {\n    console.warn('Depricated')\n    responseHeaders.set('Content-Length', data.size)\n  }\n\n  let fileName = typeof data === 'string' ? data : data.filename\n  if (fileName) {\n    console.warn('Depricated')\n    // Make filename RFC5987 compatible\n    fileName = encodeURIComponent(fileName).replace(/['()]/g, escape).replace(/\\*/g, '%2A')\n    responseHeaders.set('Content-Disposition', \"attachment; filename*=UTF-8''\" + fileName)\n  }\n\n  event.respondWith(new Response(stream, { headers: responseHeaders }))\n\n  port.postMessage({ debug: 'Download started' })\n}\n"
        }
      ]
    }
  ]
}