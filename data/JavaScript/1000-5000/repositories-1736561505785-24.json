{
  "metadata": {
    "timestamp": 1736561505785,
    "page": 24,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "MikeMcl/big.js",
      "stars": 4937,
      "defaultBranch": "master",
      "files": [
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.05078125,
          "content": "#### 6.2.2\n\n* 10/09/24\n* #212 Bugfix: `sqrt` error when `Big.strict` is `true`.\n\n#### 6.2.1\n\n* 09/07/22\n* #191 Bugfix: `round` may result in improper coefficient.\n\n#### 6.2.0\n\n* 04/06/22\n* Add note that a Big number is created from a numbers `toString` value.\n* #173 Add `Symbol.for('nodejs.util.inspect.custom')`.\n* Allow `BigInt` when `Big.strict` is `true`.\n* #177 Add `neg` method to negate a Big number.\n* Add to *package.json* exports.\n\n#### 6.1.1\n\n* 03/05/21\n* #169 Bugfix: `round`, `toFixed` etc. using original constructor `RM` (bug introduced in *v6.0.0*).\n* #169 Correct rounding mode documentation.\n* Add version number to legacy documentation.\n\n#### 6.1.0\n\n* 26/04/21\n* #165 Add missing documentation of `toFixed` etc. rounding mode parameter.\n* #150 Add static rounding modes to `Big` constructor.\n\n#### 6.0.3\n\n* 02/12/20\n* #148 Bugfix: primitive numbers passed to constructor internally in strict mode.\n\n#### 6.0.2\n\n* 31/10/20\n* #147 Change `toJSON` to be an alias of `toString`.\n\n#### 6.0.1\n\n* 30/09/20\n* Correct `sqrt` initial estimate.\n\n#### 6.0.0\n\n* 25/09/20\n* Add optional rounding mode parameter to `toExponential`, `toFixed` and `toPrecision`.\n* Add a strict mode to disallow imprecise number/Big conversions when `Big.strict = true`.\n* Add `toNumber` method.\n* Add `prec` method to round a Big to a specified number of significant digits.\n* Add version selector to API documentation.\n* Change `toJSON` to return exponential format.\n* Remove *big.min.js*.\n* Remove `Big.version`.\n* Rename *doc* folder to *docs* to use it as the GitHub publishing source.\n* Add legacy API documentation to *docs*.\n* Add *README* to *perf* directory.\n* Refactor test suite, and add `toNumber` and `prec` tests.\n* Update *README*.\n\n#### 5.2.2\n\n* 18/10/18\n* #109 Remove opencollective dependency.\n\n#### 5.2.1\n\n* Delete *bower.json*.\n\n#### 5.2.0\n\n* 09/10/18\n* #63 Allow negative argument for `round`.\n* #107 `sqrt` of large number.\n\n#### 5.1.2\n\n* 24/05/18\n* #95 Add `browser` field to *package.json*.\n* Restore named export to enable `import {Big}`.\n\n#### 5.1.1\n\n* 22/05/18\n* #95 Remove named export.\n\n#### 5.1.0\n\n* 22/05/18\n* Amend *.mjs* exports.\n* Remove extension from `main` field in *package.json*.\n\n#### 5.0.3\n\n* 23/10/17\n* #89 Optimisation of internal `round` function.\n\n#### 5.0.2\n\n* 13/10/17\n* Update *README.md*.\n\n#### 5.0.1\n\n* 13/10/17\n* Correct `Big.version` number.\n\n#### 5.0.0\n\n* 13/10/17\n* Return `-0` from `valueOf` for negative zero.\n* Refactor the methods which return a string.\n* Amend error messaging.\n* Update API document and change its colour scheme.\n* Add `Big.version`.\n* Remove bitcoin address.\n\n#### 4.0.2\n\n* 28/09/17\n* Add *big.mjs* for use with Node.js with `--experimental-modules` flag.\n\n#### 4.0.0\n\n* 27/09/17\n* Rename `Big.E_POS` to `Big.PE`, `Big.E_NEG` to `Big.NE`.\n* Refactor error messaging.\n* Throw if `null` is passed to `toFixed` etc.\n\n#### 3.2.0\n\n* 14/09/17 Aid ES6 import.\n\n#### 3.1.3\n\n* Minor documentation updates.\n\n#### 3.1.2\n\n* README typo.\n\n#### 3.1.1\n\n* API documentation update, including FAQ additions.\n\n#### 3.1.0\n\n* Renamed and exposed `TO_EXP_NEG` and `TO_EXP_POS` as `Big.E_NEG` and `Big.E_POS`.\n\n#### 3.0.2\n\n* Remove *.npmignore*, use `files` field in *package.json* instead.\n\n#### 3.0.1\n\n* Added `sub`, `add` and `mul` aliases.\n* Clean-up after lint.\n\n#### 3.0.0\n\n* 10/12/14 Added [multiple constructor functionality](http://mikemcl.github.io/big.js/#faq).\n* No breaking changes or other additions, but a major code reorganisation, so *v3* seemed appropiate.\n\n#### 2.5.2\n\n* 1/11/14 Added bower.json.\n\n#### 2.5.1\n\n* 8/06/14 Amend README requires.\n\n#### 2.5.0\n\n* 26/01/14 Added `toJSON` method so serialization uses `toString`.\n\n#### 2.4.1\n\n* 17/10/13 Conform signed zero to IEEEE 754 (2008).\n\n#### 2.4.0\n\n* 19/09/13 Throw instances of `Error`.\n\n#### 2.3.0\n\n* 16/09/13 Added `cmp` method.\n\n#### 2.2.0\n\n* 11/07/13 Added 'round up' mode.\n\n#### 2.1.0\n\n* 26/06/13 Allow e.g. `.1` and `2.`.\n\n#### 2.0.0\n\n* 12/05/13 Added `abs` method and replaced `cmp` with `eq`, `gt`, `gte`, `lt`, and `lte` methods.\n\n#### 1.0.1\n\n* Changed default value of MAX_DP to 1E6\n\n#### 1.0.0\n\n* 7/11/2012 Initial release\n"
        },
        {
          "name": "LICENCE.md",
          "type": "blob",
          "size": 1.0947265625,
          "content": "The MIT License (MIT)\n=====================\n\nCopyright © `<2024>` `Michael Mclaughlin`\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the “Software”), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.7421875,
          "content": "# big.js\n\n**A small, fast JavaScript library for arbitrary-precision decimal arithmetic.**\n\n[![npm version](https://img.shields.io/npm/v/big.js.svg)](https://www.npmjs.com/package/big.js)\n[![npm downloads](https://img.shields.io/npm/dw/big.js)](https://www.npmjs.com/package/big.js)\n\n## Features\n\n- Simple API\n- Faster, smaller and easier-to-use than JavaScript versions of Java's BigDecimal\n- Only 6 KB minified\n- Replicates the `toExponential`, `toFixed` and `toPrecision` methods of JavaScript Numbers\n- Stores values in an accessible decimal floating point format\n- Comprehensive [documentation](http://mikemcl.github.io/big.js/) and test set\n- No dependencies\n- Uses ECMAScript 3 only, so works in all browsers\n\nThe little sister to [bignumber.js](https://github.com/MikeMcl/bignumber.js/) and [decimal.js](https://github.com/MikeMcl/decimal.js/). See [here](https://github.com/MikeMcl/big.js/wiki) for some notes on the difference between them.\n\n## Install\n\nThe library is the single JavaScript file *big.js* or the ES module *big.mjs*.\n\n### Browsers\n\nAdd Big to global scope:\n\n```html\n<script src='path/to/big.js'></script>\n```\n\nES module:\n\n```html\n<script type='module'>\nimport Big from './path/to/big.mjs';\n```\n\nGet a minified version from a CDN:\n\n```html\n<script src='https://cdn.jsdelivr.net/npm/big.js@6.2.2/big.min.js'></script>\n```\n\n### [Node.js](http://nodejs.org)\n\n```bash\n$ npm install big.js\n```\n\nCommonJS:\n\n```javascript\nconst Big = require('big.js');\n```\n\nES module:\n\n```javascript\nimport Big from 'big.js';\n```\n\n### [Deno](https://deno.land/)\n\n```javascript\nimport Big from 'https://raw.githubusercontent.com/mikemcl/big.js/v6.2.2/big.mjs';\nimport Big from 'https://unpkg.com/big.js@6.2.2/big.mjs';\n```\n\n## Use\n\n*In the code examples below, semicolons and `toString` calls are not shown.*\n\nThe library exports a single constructor function, `Big`.\n\nA Big number is created from a primitive number, string, or other Big number.\n\n```javascript\nx = new Big(123.4567)\ny = Big('123456.7e-3')                 // 'new' is optional\nz = new Big(x)\nx.eq(y) && x.eq(z) && y.eq(z)          // true\n```\n\nIn Big strict mode, creating a Big number from a primitive number is disallowed.\n\n```javascript\nBig.strict = true\nx = new Big(1)                         // TypeError: [big.js] Invalid number\ny = new Big('1.0000000000000001')\ny.toNumber()                           // Error: [big.js] Imprecise conversion\n```\n\nA Big number is immutable in the sense that it is not changed by its methods.\n\n```javascript\n0.3 - 0.1                              // 0.19999999999999998\nx = new Big(0.3)\nx.minus(0.1)                           // \"0.2\"\nx                                      // \"0.3\"\n```\n\nThe methods that return a Big number can be chained.\n\n```javascript\nx.div(y).plus(z).times(9).minus('1.234567801234567e+8').plus(976.54321).div('2598.11772')\nx.sqrt().div(y).pow(3).gt(y.mod(z))    // true\n```\n\nLike JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods.\n\n```javascript\nx = new Big(255.5)\nx.toExponential(5)                     // \"2.55500e+2\"\nx.toFixed(5)                           // \"255.50000\"\nx.toPrecision(5)                       // \"255.50\"\n```\n\nThe arithmetic methods always return the exact result except `div`, `sqrt` and `pow`\n(with negative exponent), as these methods involve division.\n\nThe maximum number of decimal places and the rounding mode used to round the results of these methods is determined by the value of the `DP` and `RM` properties of the `Big` number constructor.\n\n```javascript\nBig.DP = 10\nBig.RM = Big.roundHalfUp\n\nx = new Big(2);\ny = new Big(3);\nz = x.div(y)                           // \"0.6666666667\"\nz.sqrt()                               // \"0.8164965809\"\nz.pow(-3)                              // \"3.3749999995\"\nz.times(z)                             // \"0.44444444448888888889\"\nz.times(z).round(10)                   // \"0.4444444445\"\n```\n\nThe value of a Big number is stored in a decimal floating point format in terms of a coefficient, exponent and sign.\n\n```javascript\nx = new Big(-123.456);\nx.c                                    // [1,2,3,4,5,6]    coefficient (i.e. significand)\nx.e                                    // 2                exponent\nx.s                                    // -1               sign\n```\n\nFor advanced usage, multiple Big number constructors can be created, each with an independent configuration.\n\nFor further information see the [API](http://mikemcl.github.io/big.js/) reference documentation.\n\n## Minify\n\nTo minify using, for example, npm and [terser](https://github.com/terser/terser)\n\n```bash\n$ npm install -g terser\n```\n\n```bash\n$ terser big.js -c -m -o big.min.js\n```\n\n## Test\n\nThe *test* directory contains the test scripts for each Big number method.\n\nThe tests can be run with Node.js or a browser.\n\nRun all the tests:\n\n```bash\n$ npm test\n```\n\nTest a single method:\n\n```bash\n$ node test/toFixed\n```\n\nFor the browser, see *runner.html* and *test.html* in the *test/browser* directory.\n\n*big-vs-number.html* is a old application that enables some of the methods of big.js to be compared with those of JavaScript's Number type.\n\n## TypeScript\n\nThe [DefinitelyTyped](https://github.com/borisyankov/DefinitelyTyped) project has a Typescript type definitions file for big.js.\n\n```bash\n$ npm install --save-dev @types/big.js\n```\n\nAny questions about the TypeScript type definitions file should be addressed to the DefinitelyTyped project.\n\n## Licence\n\n[MIT](LICENCE.md)\n\n## Contributors\n\n<a href=\"graphs/contributors\"><img src=\"https://opencollective.com/bigjs/contributors.svg?width=890&button=false\" /></a>\n\n## Financial supporters\n\nThank you to all who have supported this project via [Open Collective](https://opencollective.com/bigjs), particularly [Coinbase](https://www.coinbase.com/).\n\n<img src=\"https://opencollective.com/bigjs/sponsor/0/avatar.svg\">\n"
        },
        {
          "name": "big.js",
          "type": "blob",
          "size": 24.4267578125,
          "content": "/*\n *  big.js v6.2.2\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\n *  Copyright (c) 2024 Michael Mclaughlin\n *  https://github.com/MikeMcl/big.js/LICENCE.md\n */\n;(function (GLOBAL) {\n  'use strict';\n  var Big,\n\n\n/************************************** EDITABLE DEFAULTS *****************************************/\n\n\n    // The default values below must be integers within the stated ranges.\n\n    /*\n     * The maximum number of decimal places (DP) of the results of operations involving division:\n     * div and sqrt, and pow with negative exponents.\n     */\n    DP = 20,            // 0 to MAX_DP\n\n    /*\n     * The rounding mode (RM) used when rounding to the above decimal places.\n     *\n     *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\n     *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\n     *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\n     *  3  Away from zero.                                  (ROUND_UP)\n     */\n    RM = 1,             // 0, 1, 2 or 3\n\n    // The maximum value of DP and Big.DP.\n    MAX_DP = 1E6,       // 0 to 1000000\n\n    // The maximum magnitude of the exponent argument to the pow method.\n    MAX_POWER = 1E6,    // 1 to 1000000\n\n    /*\n     * The negative exponent (NE) at and beneath which toString returns exponential notation.\n     * (JavaScript numbers: -7)\n     * -1000000 is the minimum recommended exponent value of a Big.\n     */\n    NE = -7,            // 0 to -1000000\n\n    /*\n     * The positive exponent (PE) at and above which toString returns exponential notation.\n     * (JavaScript numbers: 21)\n     * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\n     */\n    PE = 21,            // 0 to 1000000\n\n    /*\n     * When true, an error will be thrown if a primitive number is passed to the Big constructor,\n     * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\n     * primitive number without a loss of precision.\n     */\n    STRICT = false,     // true or false\n\n\n/**************************************************************************************************/\n\n\n    // Error messages.\n    NAME = '[big.js] ',\n    INVALID = NAME + 'Invalid ',\n    INVALID_DP = INVALID + 'decimal places',\n    INVALID_RM = INVALID + 'rounding mode',\n    DIV_BY_ZERO = NAME + 'Division by zero',\n\n    // The shared prototype object.\n    P = {},\n    UNDEFINED = void 0,\n    NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n\n\n  /*\n   * Create and return a Big constructor.\n   */\n  function _Big_() {\n\n    /*\n     * The Big constructor and exported function.\n     * Create and return a new instance of a Big number object.\n     *\n     * n {number|string|Big} A numeric value.\n     */\n    function Big(n) {\n      var x = this;\n\n      // Enable constructor usage without new.\n      if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\n\n      // Duplicate.\n      if (n instanceof Big) {\n        x.s = n.s;\n        x.e = n.e;\n        x.c = n.c.slice();\n      } else {\n        if (typeof n !== 'string') {\n          if (Big.strict === true && typeof n !== 'bigint') {\n            throw TypeError(INVALID + 'value');\n          }\n\n          // Minus zero?\n          n = n === 0 && 1 / n < 0 ? '-0' : String(n);\n        }\n\n        parse(x, n);\n      }\n\n      // Retain a reference to this Big constructor.\n      // Shadow Big.prototype.constructor which points to Object.\n      x.constructor = Big;\n    }\n\n    Big.prototype = P;\n    Big.DP = DP;\n    Big.RM = RM;\n    Big.NE = NE;\n    Big.PE = PE;\n    Big.strict = STRICT;\n    Big.roundDown = 0;\n    Big.roundHalfUp = 1;\n    Big.roundHalfEven = 2;\n    Big.roundUp = 3;\n\n    return Big;\n  }\n\n\n  /*\n   * Parse the number or string value passed to a Big constructor.\n   *\n   * x {Big} A Big number instance.\n   * n {number|string} A numeric value.\n   */\n  function parse(x, n) {\n    var e, i, nl;\n\n    if (!NUMERIC.test(n)) {\n      throw Error(INVALID + 'number');\n    }\n\n    // Determine sign.\n    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\n\n    // Decimal point?\n    if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');\n\n    // Exponential form?\n    if ((i = n.search(/e/i)) > 0) {\n\n      // Determine exponent.\n      if (e < 0) e = i;\n      e += +n.slice(i + 1);\n      n = n.substring(0, i);\n    } else if (e < 0) {\n\n      // Integer.\n      e = n.length;\n    }\n\n    nl = n.length;\n\n    // Determine leading zeros.\n    for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\n\n    if (i == nl) {\n\n      // Zero.\n      x.c = [x.e = 0];\n    } else {\n\n      // Determine trailing zeros.\n      for (; nl > 0 && n.charAt(--nl) == '0';);\n      x.e = e - i - 1;\n      x.c = [];\n\n      // Convert string to array of digits without leading/trailing zeros.\n      for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\n    }\n\n    return x;\n  }\n\n\n  /*\n   * Round Big x to a maximum of sd significant digits using rounding mode rm.\n   *\n   * x {Big} The Big to round.\n   * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\n   * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n   * [more] {boolean} Whether the result of division was truncated.\n   */\n  function round(x, sd, rm, more) {\n    var xc = x.c;\n\n    if (rm === UNDEFINED) rm = x.constructor.RM;\n    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\n      throw Error(INVALID_RM);\n    }\n\n    if (sd < 1) {\n      more =\n        rm === 3 && (more || !!xc[0]) || sd === 0 && (\n        rm === 1 && xc[0] >= 5 ||\n        rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))\n      );\n\n      xc.length = 1;\n\n      if (more) {\n\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n        x.e = x.e - sd + 1;\n        xc[0] = 1;\n      } else {\n\n        // Zero.\n        xc[0] = x.e = 0;\n      }\n    } else if (sd < xc.length) {\n\n      // xc[sd] is the digit after the digit that may be rounded up.\n      more =\n        rm === 1 && xc[sd] >= 5 ||\n        rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&\n          (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||\n        rm === 3 && (more || !!xc[0]);\n\n      // Remove any digits after the required precision.\n      xc.length = sd;\n\n      // Round up?\n      if (more) {\n\n        // Rounding up may mean the previous digit has to be rounded up.\n        for (; ++xc[--sd] > 9;) {\n          xc[sd] = 0;\n          if (sd === 0) {\n            ++x.e;\n            xc.unshift(1);\n            break;\n          }\n        }\n      }\n\n      // Remove trailing zeros.\n      for (sd = xc.length; !xc[--sd];) xc.pop();\n    }\n\n    return x;\n  }\n\n\n  /*\n   * Return a string representing the value of Big x in normal or exponential notation.\n   * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\n   */\n  function stringify(x, doExponential, isNonzero) {\n    var e = x.e,\n      s = x.c.join(''),\n      n = s.length;\n\n    // Exponential notation?\n    if (doExponential) {\n      s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\n\n    // Normal notation.\n    } else if (e < 0) {\n      for (; ++e;) s = '0' + s;\n      s = '0.' + s;\n    } else if (e > 0) {\n      if (++e > n) {\n        for (e -= n; e--;) s += '0';\n      } else if (e < n) {\n        s = s.slice(0, e) + '.' + s.slice(e);\n      }\n    } else if (n > 1) {\n      s = s.charAt(0) + '.' + s.slice(1);\n    }\n\n    return x.s < 0 && isNonzero ? '-' + s : s;\n  }\n\n\n  // Prototype/instance methods\n\n\n  /*\n   * Return a new Big whose value is the absolute value of this Big.\n   */\n  P.abs = function () {\n    var x = new this.constructor(this);\n    x.s = 1;\n    return x;\n  };\n\n\n  /*\n   * Return 1 if the value of this Big is greater than the value of Big y,\n   *       -1 if the value of this Big is less than the value of Big y, or\n   *        0 if they have the same value.\n   */\n  P.cmp = function (y) {\n    var isneg,\n      x = this,\n      xc = x.c,\n      yc = (y = new x.constructor(y)).c,\n      i = x.s,\n      j = y.s,\n      k = x.e,\n      l = y.e;\n\n    // Either zero?\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\n\n    // Signs differ?\n    if (i != j) return i;\n\n    isneg = i < 0;\n\n    // Compare exponents.\n    if (k != l) return k > l ^ isneg ? 1 : -1;\n\n    j = (k = xc.length) < (l = yc.length) ? k : l;\n\n    // Compare digit by digit.\n    for (i = -1; ++i < j;) {\n      if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n    }\n\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n  };\n\n\n  /*\n   * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\n   * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n   */\n  P.div = function (y) {\n    var x = this,\n      Big = x.constructor,\n      a = x.c,                  // dividend\n      b = (y = new Big(y)).c,   // divisor\n      k = x.s == y.s ? 1 : -1,\n      dp = Big.DP;\n\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n      throw Error(INVALID_DP);\n    }\n\n    // Divisor is zero?\n    if (!b[0]) {\n      throw Error(DIV_BY_ZERO);\n    }\n\n    // Dividend is 0? Return +-0.\n    if (!a[0]) {\n      y.s = k;\n      y.c = [y.e = 0];\n      return y;\n    }\n\n    var bl, bt, n, cmp, ri,\n      bz = b.slice(),\n      ai = bl = b.length,\n      al = a.length,\n      r = a.slice(0, bl),   // remainder\n      rl = r.length,\n      q = y,                // quotient\n      qc = q.c = [],\n      qi = 0,\n      p = dp + (q.e = x.e - y.e) + 1;    // precision of the result\n\n    q.s = k;\n    k = p < 0 ? 0 : p;\n\n    // Create version of divisor with leading zero.\n    bz.unshift(0);\n\n    // Add zeros to make remainder as long as divisor.\n    for (; rl++ < bl;) r.push(0);\n\n    do {\n\n      // n is how many times the divisor goes into current remainder.\n      for (n = 0; n < 10; n++) {\n\n        // Compare divisor and remainder.\n        if (bl != (rl = r.length)) {\n          cmp = bl > rl ? 1 : -1;\n        } else {\n          for (ri = -1, cmp = 0; ++ri < bl;) {\n            if (b[ri] != r[ri]) {\n              cmp = b[ri] > r[ri] ? 1 : -1;\n              break;\n            }\n          }\n        }\n\n        // If divisor < remainder, subtract divisor from remainder.\n        if (cmp < 0) {\n\n          // Remainder can't be more than 1 digit longer than divisor.\n          // Equalise lengths using divisor with extra leading zero?\n          for (bt = rl == bl ? b : bz; rl;) {\n            if (r[--rl] < bt[rl]) {\n              ri = rl;\n              for (; ri && !r[--ri];) r[ri] = 9;\n              --r[ri];\n              r[rl] += 10;\n            }\n            r[rl] -= bt[rl];\n          }\n\n          for (; !r[0];) r.shift();\n        } else {\n          break;\n        }\n      }\n\n      // Add the digit n to the result array.\n      qc[qi++] = cmp ? n : ++n;\n\n      // Update the remainder.\n      if (r[0] && cmp) r[rl] = a[ai] || 0;\n      else r = [a[ai]];\n\n    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\n    if (!qc[0] && qi != 1) {\n\n      // There can't be more than one zero.\n      qc.shift();\n      q.e--;\n      p--;\n    }\n\n    // Round?\n    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\n\n    return q;\n  };\n\n\n  /*\n   * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\n   */\n  P.eq = function (y) {\n    return this.cmp(y) === 0;\n  };\n\n\n  /*\n   * Return true if the value of this Big is greater than the value of Big y, otherwise return\n   * false.\n   */\n  P.gt = function (y) {\n    return this.cmp(y) > 0;\n  };\n\n\n  /*\n   * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\n   * return false.\n   */\n  P.gte = function (y) {\n    return this.cmp(y) > -1;\n  };\n\n\n  /*\n   * Return true if the value of this Big is less than the value of Big y, otherwise return false.\n   */\n  P.lt = function (y) {\n    return this.cmp(y) < 0;\n  };\n\n\n  /*\n   * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\n   * return false.\n   */\n  P.lte = function (y) {\n    return this.cmp(y) < 1;\n  };\n\n\n  /*\n   * Return a new Big whose value is the value of this Big minus the value of Big y.\n   */\n  P.minus = P.sub = function (y) {\n    var i, j, t, xlty,\n      x = this,\n      Big = x.constructor,\n      a = x.s,\n      b = (y = new Big(y)).s;\n\n    // Signs differ?\n    if (a != b) {\n      y.s = -b;\n      return x.plus(y);\n    }\n\n    var xc = x.c.slice(),\n      xe = x.e,\n      yc = y.c,\n      ye = y.e;\n\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n      if (yc[0]) {\n        y.s = -b;\n      } else if (xc[0]) {\n        y = new Big(x);\n      } else {\n        y.s = 1;\n      }\n      return y;\n    }\n\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\n    if (a = xe - ye) {\n\n      if (xlty = a < 0) {\n        a = -a;\n        t = xc;\n      } else {\n        ye = xe;\n        t = yc;\n      }\n\n      t.reverse();\n      for (b = a; b--;) t.push(0);\n      t.reverse();\n    } else {\n\n      // Exponents equal. Check digit by digit.\n      j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n\n      for (a = b = 0; b < j; b++) {\n        if (xc[b] != yc[b]) {\n          xlty = xc[b] < yc[b];\n          break;\n        }\n      }\n    }\n\n    // x < y? Point xc to the array of the bigger number.\n    if (xlty) {\n      t = xc;\n      xc = yc;\n      yc = t;\n      y.s = -y.s;\n    }\n\n    /*\n     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\n     * needs to start at yc.length.\n     */\n    if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;\n\n    // Subtract yc from xc.\n    for (b = i; j > a;) {\n      if (xc[--j] < yc[j]) {\n        for (i = j; i && !xc[--i];) xc[i] = 9;\n        --xc[i];\n        xc[j] += 10;\n      }\n\n      xc[j] -= yc[j];\n    }\n\n    // Remove trailing zeros.\n    for (; xc[--b] === 0;) xc.pop();\n\n    // Remove leading zeros and adjust exponent accordingly.\n    for (; xc[0] === 0;) {\n      xc.shift();\n      --ye;\n    }\n\n    if (!xc[0]) {\n\n      // n - n = +0\n      y.s = 1;\n\n      // Result must be zero.\n      xc = [ye = 0];\n    }\n\n    y.c = xc;\n    y.e = ye;\n\n    return y;\n  };\n\n\n  /*\n   * Return a new Big whose value is the value of this Big modulo the value of Big y.\n   */\n  P.mod = function (y) {\n    var ygtx,\n      x = this,\n      Big = x.constructor,\n      a = x.s,\n      b = (y = new Big(y)).s;\n\n    if (!y.c[0]) {\n      throw Error(DIV_BY_ZERO);\n    }\n\n    x.s = y.s = 1;\n    ygtx = y.cmp(x) == 1;\n    x.s = a;\n    y.s = b;\n\n    if (ygtx) return new Big(x);\n\n    a = Big.DP;\n    b = Big.RM;\n    Big.DP = Big.RM = 0;\n    x = x.div(y);\n    Big.DP = a;\n    Big.RM = b;\n\n    return this.minus(x.times(y));\n  };\n  \n  \n  /*\n   * Return a new Big whose value is the value of this Big negated.\n   */\n  P.neg = function () {\n    var x = new this.constructor(this);\n    x.s = -x.s;\n    return x;\n  };\n\n\n  /*\n   * Return a new Big whose value is the value of this Big plus the value of Big y.\n   */\n  P.plus = P.add = function (y) {\n    var e, k, t,\n      x = this,\n      Big = x.constructor;\n\n    y = new Big(y);\n\n    // Signs differ?\n    if (x.s != y.s) {\n      y.s = -y.s;\n      return x.minus(y);\n    }\n\n    var xe = x.e,\n      xc = x.c,\n      ye = y.e,\n      yc = y.c;\n\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n      if (!yc[0]) {\n        if (xc[0]) {\n          y = new Big(x);\n        } else {\n          y.s = x.s;\n        }\n      }\n      return y;\n    }\n\n    xc = xc.slice();\n\n    // Prepend zeros to equalise exponents.\n    // Note: reverse faster than unshifts.\n    if (e = xe - ye) {\n      if (e > 0) {\n        ye = xe;\n        t = yc;\n      } else {\n        e = -e;\n        t = xc;\n      }\n\n      t.reverse();\n      for (; e--;) t.push(0);\n      t.reverse();\n    }\n\n    // Point xc to the longer array.\n    if (xc.length - yc.length < 0) {\n      t = yc;\n      yc = xc;\n      xc = t;\n    }\n\n    e = yc.length;\n\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n    for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\n\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n\n    if (k) {\n      xc.unshift(k);\n      ++ye;\n    }\n\n    // Remove trailing zeros.\n    for (e = xc.length; xc[--e] === 0;) xc.pop();\n\n    y.c = xc;\n    y.e = ye;\n\n    return y;\n  };\n\n\n  /*\n   * Return a Big whose value is the value of this Big raised to the power n.\n   * If n is negative, round to a maximum of Big.DP decimal places using rounding\n   * mode Big.RM.\n   *\n   * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\n   */\n  P.pow = function (n) {\n    var x = this,\n      one = new x.constructor('1'),\n      y = one,\n      isneg = n < 0;\n\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\n      throw Error(INVALID + 'exponent');\n    }\n\n    if (isneg) n = -n;\n\n    for (;;) {\n      if (n & 1) y = y.times(x);\n      n >>= 1;\n      if (!n) break;\n      x = x.times(x);\n    }\n\n    return isneg ? one.div(y) : y;\n  };\n\n\n  /*\n   * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\n   * significant digits using rounding mode rm, or Big.RM if rm is not specified.\n   *\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n   */\n  P.prec = function (sd, rm) {\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n      throw Error(INVALID + 'precision');\n    }\n    return round(new this.constructor(this), sd, rm);\n  };\n\n\n  /*\n   * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\n   * using rounding mode rm, or Big.RM if rm is not specified.\n   * If dp is negative, round to an integer which is a multiple of 10**-dp.\n   * If dp is not specified, round to 0 decimal places.\n   *\n   * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n   */\n  P.round = function (dp, rm) {\n    if (dp === UNDEFINED) dp = 0;\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\n      throw Error(INVALID_DP);\n    }\n    return round(new this.constructor(this), dp + this.e + 1, rm);\n  };\n\n\n  /*\n   * Return a new Big whose value is the square root of the value of this Big, rounded, if\n   * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n   */\n  P.sqrt = function () {\n    var r, c, t,\n      x = this,\n      Big = x.constructor,\n      s = x.s,\n      e = x.e,\n      half = new Big('0.5');\n\n    // Zero?\n    if (!x.c[0]) return new Big(x);\n\n    // Negative?\n    if (s < 0) {\n      throw Error(NAME + 'No square root');\n    }\n\n    // Estimate.\n    s = Math.sqrt(+stringify(x, true, true));\n\n    // Math.sqrt underflow/overflow?\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n    if (s === 0 || s === 1 / 0) {\n      c = x.c.join('');\n      if (!(c.length + e & 1)) c += '0';\n      s = Math.sqrt(c);\n      e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n      r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\n    } else {\n      r = new Big(s + '');\n    }\n\n    e = r.e + (Big.DP += 4);\n\n    // Newton-Raphson iteration.\n    do {\n      t = r;\n      r = half.times(t.plus(x.div(t)));\n    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\n\n    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\n  };\n\n\n  /*\n   * Return a new Big whose value is the value of this Big times the value of Big y.\n   */\n  P.times = P.mul = function (y) {\n    var c,\n      x = this,\n      Big = x.constructor,\n      xc = x.c,\n      yc = (y = new Big(y)).c,\n      a = xc.length,\n      b = yc.length,\n      i = x.e,\n      j = y.e;\n\n    // Determine sign of result.\n    y.s = x.s == y.s ? 1 : -1;\n\n    // Return signed 0 if either 0.\n    if (!xc[0] || !yc[0]) {\n      y.c = [y.e = 0];\n      return y;\n    }\n\n    // Initialise exponent of result as x.e + y.e.\n    y.e = i + j;\n\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n    if (a < b) {\n      c = xc;\n      xc = yc;\n      yc = c;\n      j = a;\n      a = b;\n      b = j;\n    }\n\n    // Initialise coefficient array of result with zeros.\n    for (c = new Array(j = a + b); j--;) c[j] = 0;\n\n    // Multiply.\n\n    // i is initially xc.length.\n    for (i = b; i--;) {\n      b = 0;\n\n      // a is yc.length.\n      for (j = a + i; j > i;) {\n\n        // Current sum of products at this digit position, plus carry.\n        b = c[j] + yc[i] * xc[j - i - 1] + b;\n        c[j--] = b % 10;\n\n        // carry\n        b = b / 10 | 0;\n      }\n\n      c[j] = b;\n    }\n\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\n    if (b) ++y.e;\n    else c.shift();\n\n    // Remove trailing zeros.\n    for (i = c.length; !c[--i];) c.pop();\n    y.c = c;\n\n    return y;\n  };\n\n\n  /*\n   * Return a string representing the value of this Big in exponential notation rounded to dp fixed\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\n   *\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n   */\n  P.toExponential = function (dp, rm) {\n    var x = this,\n      n = x.c[0];\n\n    if (dp !== UNDEFINED) {\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n      }\n      x = round(new x.constructor(x), ++dp, rm);\n      for (; x.c.length < dp;) x.c.push(0);\n    }\n\n    return stringify(x, true, !!n);\n  };\n\n\n  /*\n   * Return a string representing the value of this Big in normal notation rounded to dp fixed\n   * decimal places using rounding mode rm, or Big.RM if rm is not specified.\n   *\n   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n   *\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\n   */\n  P.toFixed = function (dp, rm) {\n    var x = this,\n      n = x.c[0];\n\n    if (dp !== UNDEFINED) {\n      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n      }\n      x = round(new x.constructor(x), dp + x.e + 1, rm);\n\n      // x.e may have changed if the value is rounded up.\n      for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);\n    }\n\n    return stringify(x, false, !!n);\n  };\n\n\n  /*\n   * Return a string representing the value of this Big.\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\n   * Omit the sign for negative zero.\n   */\n  P.toJSON = P.toString = function () {\n    var x = this,\n      Big = x.constructor;\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\n  };\n\n\n  /*\n   * Return the value of this Big as a primitve number.\n   */\n  P.toNumber = function () {\n    var n = +stringify(this, true, true);\n    if (this.constructor.strict === true && !this.eq(n.toString())) {\n      throw Error(NAME + 'Imprecise conversion');\n    }\n    return n;\n  };\n\n\n  /*\n   * Return a string representing the value of this Big rounded to sd significant digits using\n   * rounding mode rm, or Big.RM if rm is not specified.\n   * Use exponential notation if sd is less than the number of digits necessary to represent\n   * the integer part of the value in normal notation.\n   *\n   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\n   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n   */\n  P.toPrecision = function (sd, rm) {\n    var x = this,\n      Big = x.constructor,\n      n = x.c[0];\n\n    if (sd !== UNDEFINED) {\n      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n        throw Error(INVALID + 'precision');\n      }\n      x = round(new Big(x), sd, rm);\n      for (; x.c.length < sd;) x.c.push(0);\n    }\n\n    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\n  };\n\n\n  /*\n   * Return a string representing the value of this Big.\n   * Return exponential notation if this Big has a positive exponent equal to or greater than\n   * Big.PE, or a negative exponent equal to or less than Big.NE.\n   * Include the sign for negative zero.\n   */\n  P.valueOf = function () {\n    var x = this,\n      Big = x.constructor;\n    if (Big.strict === true) {\n      throw Error(NAME + 'valueOf disallowed');\n    }\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\n  };\n\n\n  // Export\n\n\n  Big = _Big_();\n\n  Big['default'] = Big.Big = Big;\n\n  //AMD.\n  if (typeof define === 'function' && define.amd) {\n    define(function () { return Big; });\n\n  // Node and other CommonJS-like environments that support module.exports.\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Big;\n\n  //Browser.\n  } else {\n    GLOBAL.Big = Big;\n  }\n})(this);\n"
        },
        {
          "name": "big.mjs",
          "type": "blob",
          "size": 22.640625,
          "content": "/*\n *  big.js v6.2.2\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\n *  Copyright (c) 2024 Michael Mclaughlin\n *  https://github.com/MikeMcl/big.js/LICENCE.md\n */\n\n\n/************************************** EDITABLE DEFAULTS *****************************************/\n\n\n  // The default values below must be integers within the stated ranges.\n\n  /*\n   * The maximum number of decimal places (DP) of the results of operations involving division:\n   * div and sqrt, and pow with negative exponents.\n   */\nvar DP = 20,          // 0 to MAX_DP\n\n  /*\n   * The rounding mode (RM) used when rounding to the above decimal places.\n   *\n   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\n   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\n   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\n   *  3  Away from zero.                                  (ROUND_UP)\n   */\n  RM = 1,             // 0, 1, 2 or 3\n\n  // The maximum value of DP and Big.DP.\n  MAX_DP = 1E6,       // 0 to 1000000\n\n  // The maximum magnitude of the exponent argument to the pow method.\n  MAX_POWER = 1E6,    // 1 to 1000000\n\n  /*\n   * The negative exponent (NE) at and beneath which toString returns exponential notation.\n   * (JavaScript numbers: -7)\n   * -1000000 is the minimum recommended exponent value of a Big.\n   */\n  NE = -7,            // 0 to -1000000\n\n  /*\n   * The positive exponent (PE) at and above which toString returns exponential notation.\n   * (JavaScript numbers: 21)\n   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\n   */\n  PE = 21,            // 0 to 1000000\n\n  /*\n   * When true, an error will be thrown if a primitive number is passed to the Big constructor,\n   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\n   * primitive number without a loss of precision.\n   */\n  STRICT = false,     // true or false\n\n\n/**************************************************************************************************/\n\n\n  // Error messages.\n  NAME = '[big.js] ',\n  INVALID = NAME + 'Invalid ',\n  INVALID_DP = INVALID + 'decimal places',\n  INVALID_RM = INVALID + 'rounding mode',\n  DIV_BY_ZERO = NAME + 'Division by zero',\n\n  // The shared prototype object.\n  P = {},\n  UNDEFINED = void 0,\n  NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n\n\n/*\n * Create and return a Big constructor.\n */\nfunction _Big_() {\n\n  /*\n   * The Big constructor and exported function.\n   * Create and return a new instance of a Big number object.\n   *\n   * n {number|string|Big} A numeric value.\n   */\n  function Big(n) {\n    var x = this;\n\n    // Enable constructor usage without new.\n    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\n\n    // Duplicate.\n    if (n instanceof Big) {\n      x.s = n.s;\n      x.e = n.e;\n      x.c = n.c.slice();\n    } else {\n      if (typeof n !== 'string') {\n        if (Big.strict === true && typeof n !== 'bigint') {\n          throw TypeError(INVALID + 'value');\n        }\n\n        // Minus zero?\n        n = n === 0 && 1 / n < 0 ? '-0' : String(n);\n      }\n\n      parse(x, n);\n    }\n\n    // Retain a reference to this Big constructor.\n    // Shadow Big.prototype.constructor which points to Object.\n    x.constructor = Big;\n  }\n\n  Big.prototype = P;\n  Big.DP = DP;\n  Big.RM = RM;\n  Big.NE = NE;\n  Big.PE = PE;\n  Big.strict = STRICT;\n  Big.roundDown = 0;\n  Big.roundHalfUp = 1;\n  Big.roundHalfEven = 2;\n  Big.roundUp = 3;\n\n  return Big;\n}\n\n\n/*\n * Parse the number or string value passed to a Big constructor.\n *\n * x {Big} A Big number instance.\n * n {number|string} A numeric value.\n */\nfunction parse(x, n) {\n  var e, i, nl;\n\n  if (!NUMERIC.test(n)) {\n    throw Error(INVALID + 'number');\n  }\n\n  // Determine sign.\n  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\n\n  // Decimal point?\n  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');\n\n  // Exponential form?\n  if ((i = n.search(/e/i)) > 0) {\n\n    // Determine exponent.\n    if (e < 0) e = i;\n    e += +n.slice(i + 1);\n    n = n.substring(0, i);\n  } else if (e < 0) {\n\n    // Integer.\n    e = n.length;\n  }\n\n  nl = n.length;\n\n  // Determine leading zeros.\n  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;\n\n  if (i == nl) {\n\n    // Zero.\n    x.c = [x.e = 0];\n  } else {\n\n    // Determine trailing zeros.\n    for (; nl > 0 && n.charAt(--nl) == '0';);\n    x.e = e - i - 1;\n    x.c = [];\n\n    // Convert string to array of digits without leading/trailing zeros.\n    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);\n  }\n\n  return x;\n}\n\n\n/*\n * Round Big x to a maximum of sd significant digits using rounding mode rm.\n *\n * x {Big} The Big to round.\n * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\n * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n * [more] {boolean} Whether the result of division was truncated.\n */\nfunction round(x, sd, rm, more) {\n  var xc = x.c;\n\n  if (rm === UNDEFINED) rm = x.constructor.RM;\n  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\n    throw Error(INVALID_RM);\n  }\n\n  if (sd < 1) {\n    more =\n      rm === 3 && (more || !!xc[0]) || sd === 0 && (\n      rm === 1 && xc[0] >= 5 ||\n      rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))\n    );\n\n    xc.length = 1;\n\n    if (more) {\n\n      // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n      x.e = x.e - sd + 1;\n      xc[0] = 1;\n    } else {\n\n      // Zero.\n      xc[0] = x.e = 0;\n    }\n  } else if (sd < xc.length) {\n\n    // xc[sd] is the digit after the digit that may be rounded up.\n    more =\n      rm === 1 && xc[sd] >= 5 ||\n      rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&\n        (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||\n      rm === 3 && (more || !!xc[0]);\n\n    // Remove any digits after the required precision.\n    xc.length = sd;\n\n    // Round up?\n    if (more) {\n\n      // Rounding up may mean the previous digit has to be rounded up.\n      for (; ++xc[--sd] > 9;) {\n        xc[sd] = 0;\n        if (sd === 0) {\n          ++x.e;\n          xc.unshift(1);\n          break;\n        }\n      }\n    }\n\n    // Remove trailing zeros.\n    for (sd = xc.length; !xc[--sd];) xc.pop();\n  }\n\n  return x;\n}\n\n\n/*\n * Return a string representing the value of Big x in normal or exponential notation.\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\n */\nfunction stringify(x, doExponential, isNonzero) {\n  var e = x.e,\n    s = x.c.join(''),\n    n = s.length;\n\n  // Exponential notation?\n  if (doExponential) {\n    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;\n\n  // Normal notation.\n  } else if (e < 0) {\n    for (; ++e;) s = '0' + s;\n    s = '0.' + s;\n  } else if (e > 0) {\n    if (++e > n) {\n      for (e -= n; e--;) s += '0';\n    } else if (e < n) {\n      s = s.slice(0, e) + '.' + s.slice(e);\n    }\n  } else if (n > 1) {\n    s = s.charAt(0) + '.' + s.slice(1);\n  }\n\n  return x.s < 0 && isNonzero ? '-' + s : s;\n}\n\n\n// Prototype/instance methods\n\n\n/*\n * Return a new Big whose value is the absolute value of this Big.\n */\nP.abs = function () {\n  var x = new this.constructor(this);\n  x.s = 1;\n  return x;\n};\n\n\n/*\n * Return 1 if the value of this Big is greater than the value of Big y,\n *       -1 if the value of this Big is less than the value of Big y, or\n *        0 if they have the same value.\n */\nP.cmp = function (y) {\n  var isneg,\n    x = this,\n    xc = x.c,\n    yc = (y = new x.constructor(y)).c,\n    i = x.s,\n    j = y.s,\n    k = x.e,\n    l = y.e;\n\n  // Either zero?\n  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\n\n  // Signs differ?\n  if (i != j) return i;\n\n  isneg = i < 0;\n\n  // Compare exponents.\n  if (k != l) return k > l ^ isneg ? 1 : -1;\n\n  j = (k = xc.length) < (l = yc.length) ? k : l;\n\n  // Compare digit by digit.\n  for (i = -1; ++i < j;) {\n    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n  }\n\n  // Compare lengths.\n  return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n\n\n/*\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\nP.div = function (y) {\n  var x = this,\n    Big = x.constructor,\n    a = x.c,                  // dividend\n    b = (y = new Big(y)).c,   // divisor\n    k = x.s == y.s ? 1 : -1,\n    dp = Big.DP;\n\n  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n    throw Error(INVALID_DP);\n  }\n\n  // Divisor is zero?\n  if (!b[0]) {\n    throw Error(DIV_BY_ZERO);\n  }\n\n  // Dividend is 0? Return +-0.\n  if (!a[0]) {\n    y.s = k;\n    y.c = [y.e = 0];\n    return y;\n  }\n\n  var bl, bt, n, cmp, ri,\n    bz = b.slice(),\n    ai = bl = b.length,\n    al = a.length,\n    r = a.slice(0, bl),   // remainder\n    rl = r.length,\n    q = y,                // quotient\n    qc = q.c = [],\n    qi = 0,\n    p = dp + (q.e = x.e - y.e) + 1;    // precision of the result\n\n  q.s = k;\n  k = p < 0 ? 0 : p;\n\n  // Create version of divisor with leading zero.\n  bz.unshift(0);\n\n  // Add zeros to make remainder as long as divisor.\n  for (; rl++ < bl;) r.push(0);\n\n  do {\n\n    // n is how many times the divisor goes into current remainder.\n    for (n = 0; n < 10; n++) {\n\n      // Compare divisor and remainder.\n      if (bl != (rl = r.length)) {\n        cmp = bl > rl ? 1 : -1;\n      } else {\n        for (ri = -1, cmp = 0; ++ri < bl;) {\n          if (b[ri] != r[ri]) {\n            cmp = b[ri] > r[ri] ? 1 : -1;\n            break;\n          }\n        }\n      }\n\n      // If divisor < remainder, subtract divisor from remainder.\n      if (cmp < 0) {\n\n        // Remainder can't be more than 1 digit longer than divisor.\n        // Equalise lengths using divisor with extra leading zero?\n        for (bt = rl == bl ? b : bz; rl;) {\n          if (r[--rl] < bt[rl]) {\n            ri = rl;\n            for (; ri && !r[--ri];) r[ri] = 9;\n            --r[ri];\n            r[rl] += 10;\n          }\n          r[rl] -= bt[rl];\n        }\n\n        for (; !r[0];) r.shift();\n      } else {\n        break;\n      }\n    }\n\n    // Add the digit n to the result array.\n    qc[qi++] = cmp ? n : ++n;\n\n    // Update the remainder.\n    if (r[0] && cmp) r[rl] = a[ai] || 0;\n    else r = [a[ai]];\n\n  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n\n  // Leading zero? Do not remove if result is simply zero (qi == 1).\n  if (!qc[0] && qi != 1) {\n\n    // There can't be more than one zero.\n    qc.shift();\n    q.e--;\n    p--;\n  }\n\n  // Round?\n  if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\n\n  return q;\n};\n\n\n/*\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\n */\nP.eq = function (y) {\n  return this.cmp(y) === 0;\n};\n\n\n/*\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\n * false.\n */\nP.gt = function (y) {\n  return this.cmp(y) > 0;\n};\n\n\n/*\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\n * return false.\n */\nP.gte = function (y) {\n  return this.cmp(y) > -1;\n};\n\n\n/*\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\n */\nP.lt = function (y) {\n  return this.cmp(y) < 0;\n};\n\n\n/*\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\n * return false.\n */\nP.lte = function (y) {\n  return this.cmp(y) < 1;\n};\n\n\n/*\n * Return a new Big whose value is the value of this Big minus the value of Big y.\n */\nP.minus = P.sub = function (y) {\n  var i, j, t, xlty,\n    x = this,\n    Big = x.constructor,\n    a = x.s,\n    b = (y = new Big(y)).s;\n\n  // Signs differ?\n  if (a != b) {\n    y.s = -b;\n    return x.plus(y);\n  }\n\n  var xc = x.c.slice(),\n    xe = x.e,\n    yc = y.c,\n    ye = y.e;\n\n  // Either zero?\n  if (!xc[0] || !yc[0]) {\n    if (yc[0]) {\n      y.s = -b;\n    } else if (xc[0]) {\n      y = new Big(x);\n    } else {\n      y.s = 1;\n    }\n    return y;\n  }\n\n  // Determine which is the bigger number. Prepend zeros to equalise exponents.\n  if (a = xe - ye) {\n\n    if (xlty = a < 0) {\n      a = -a;\n      t = xc;\n    } else {\n      ye = xe;\n      t = yc;\n    }\n\n    t.reverse();\n    for (b = a; b--;) t.push(0);\n    t.reverse();\n  } else {\n\n    // Exponents equal. Check digit by digit.\n    j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n\n    for (a = b = 0; b < j; b++) {\n      if (xc[b] != yc[b]) {\n        xlty = xc[b] < yc[b];\n        break;\n      }\n    }\n  }\n\n  // x < y? Point xc to the array of the bigger number.\n  if (xlty) {\n    t = xc;\n    xc = yc;\n    yc = t;\n    y.s = -y.s;\n  }\n\n  /*\n   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\n   * needs to start at yc.length.\n   */\n  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;\n\n  // Subtract yc from xc.\n  for (b = i; j > a;) {\n    if (xc[--j] < yc[j]) {\n      for (i = j; i && !xc[--i];) xc[i] = 9;\n      --xc[i];\n      xc[j] += 10;\n    }\n\n    xc[j] -= yc[j];\n  }\n\n  // Remove trailing zeros.\n  for (; xc[--b] === 0;) xc.pop();\n\n  // Remove leading zeros and adjust exponent accordingly.\n  for (; xc[0] === 0;) {\n    xc.shift();\n    --ye;\n  }\n\n  if (!xc[0]) {\n\n    // n - n = +0\n    y.s = 1;\n\n    // Result must be zero.\n    xc = [ye = 0];\n  }\n\n  y.c = xc;\n  y.e = ye;\n\n  return y;\n};\n\n\n/*\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\n */\nP.mod = function (y) {\n  var ygtx,\n    x = this,\n    Big = x.constructor,\n    a = x.s,\n    b = (y = new Big(y)).s;\n\n  if (!y.c[0]) {\n    throw Error(DIV_BY_ZERO);\n  }\n\n  x.s = y.s = 1;\n  ygtx = y.cmp(x) == 1;\n  x.s = a;\n  y.s = b;\n\n  if (ygtx) return new Big(x);\n\n  a = Big.DP;\n  b = Big.RM;\n  Big.DP = Big.RM = 0;\n  x = x.div(y);\n  Big.DP = a;\n  Big.RM = b;\n\n  return this.minus(x.times(y));\n};\n\n\n/*\n * Return a new Big whose value is the value of this Big negated.\n */\nP.neg = function () {\n  var x = new this.constructor(this);\n  x.s = -x.s;\n  return x;\n};\n\n\n/*\n * Return a new Big whose value is the value of this Big plus the value of Big y.\n */\nP.plus = P.add = function (y) {\n  var e, k, t,\n    x = this,\n    Big = x.constructor;\n\n  y = new Big(y);\n\n  // Signs differ?\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.minus(y);\n  }\n\n  var xe = x.e,\n    xc = x.c,\n    ye = y.e,\n    yc = y.c;\n\n  // Either zero?\n  if (!xc[0] || !yc[0]) {\n    if (!yc[0]) {\n      if (xc[0]) {\n        y = new Big(x);\n      } else {\n        y.s = x.s;\n      }\n    }\n    return y;\n  }\n\n  xc = xc.slice();\n\n  // Prepend zeros to equalise exponents.\n  // Note: reverse faster than unshifts.\n  if (e = xe - ye) {\n    if (e > 0) {\n      ye = xe;\n      t = yc;\n    } else {\n      e = -e;\n      t = xc;\n    }\n\n    t.reverse();\n    for (; e--;) t.push(0);\n    t.reverse();\n  }\n\n  // Point xc to the longer array.\n  if (xc.length - yc.length < 0) {\n    t = yc;\n    yc = xc;\n    xc = t;\n  }\n\n  e = yc.length;\n\n  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\n\n  // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n\n  if (k) {\n    xc.unshift(k);\n    ++ye;\n  }\n\n  // Remove trailing zeros.\n  for (e = xc.length; xc[--e] === 0;) xc.pop();\n\n  y.c = xc;\n  y.e = ye;\n\n  return y;\n};\n\n\n/*\n * Return a Big whose value is the value of this Big raised to the power n.\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\n * mode Big.RM.\n *\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\n */\nP.pow = function (n) {\n  var x = this,\n    one = new x.constructor('1'),\n    y = one,\n    isneg = n < 0;\n\n  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\n    throw Error(INVALID + 'exponent');\n  }\n\n  if (isneg) n = -n;\n\n  for (;;) {\n    if (n & 1) y = y.times(x);\n    n >>= 1;\n    if (!n) break;\n    x = x.times(x);\n  }\n\n  return isneg ? one.div(y) : y;\n};\n\n\n/*\n * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\n * significant digits using rounding mode rm, or Big.RM if rm is not specified.\n *\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.prec = function (sd, rm) {\n  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n    throw Error(INVALID + 'precision');\n  }\n  return round(new this.constructor(this), sd, rm);\n};\n\n\n/*\n * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\n * using rounding mode rm, or Big.RM if rm is not specified.\n * If dp is negative, round to an integer which is a multiple of 10**-dp.\n * If dp is not specified, round to 0 decimal places.\n *\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.round = function (dp, rm) {\n  if (dp === UNDEFINED) dp = 0;\n  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\n    throw Error(INVALID_DP);\n  }\n  return round(new this.constructor(this), dp + this.e + 1, rm);\n};\n\n\n/*\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\n */\nP.sqrt = function () {\n  var r, c, t,\n    x = this,\n    Big = x.constructor,\n    s = x.s,\n    e = x.e,\n    half = new Big('0.5');\n\n  // Zero?\n  if (!x.c[0]) return new Big(x);\n\n  // Negative?\n  if (s < 0) {\n    throw Error(NAME + 'No square root');\n  }\n\n  // Estimate.\n  s = Math.sqrt(+stringify(x, true, true));\n\n  // Math.sqrt underflow/overflow?\n  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n  if (s === 0 || s === 1 / 0) {\n    c = x.c.join('');\n    if (!(c.length + e & 1)) c += '0';\n    s = Math.sqrt(c);\n    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);\n  } else {\n    r = new Big(s + '');\n  }\n\n  e = r.e + (Big.DP += 4);\n\n  // Newton-Raphson iteration.\n  do {\n    t = r;\n    r = half.times(t.plus(x.div(t)));\n  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));\n\n  return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\n};\n\n\n/*\n * Return a new Big whose value is the value of this Big times the value of Big y.\n */\nP.times = P.mul = function (y) {\n  var c,\n    x = this,\n    Big = x.constructor,\n    xc = x.c,\n    yc = (y = new Big(y)).c,\n    a = xc.length,\n    b = yc.length,\n    i = x.e,\n    j = y.e;\n\n  // Determine sign of result.\n  y.s = x.s == y.s ? 1 : -1;\n\n  // Return signed 0 if either 0.\n  if (!xc[0] || !yc[0]) {\n    y.c = [y.e = 0];\n    return y;\n  }\n\n  // Initialise exponent of result as x.e + y.e.\n  y.e = i + j;\n\n  // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n  if (a < b) {\n    c = xc;\n    xc = yc;\n    yc = c;\n    j = a;\n    a = b;\n    b = j;\n  }\n\n  // Initialise coefficient array of result with zeros.\n  for (c = new Array(j = a + b); j--;) c[j] = 0;\n\n  // Multiply.\n\n  // i is initially xc.length.\n  for (i = b; i--;) {\n    b = 0;\n\n    // a is yc.length.\n    for (j = a + i; j > i;) {\n\n      // Current sum of products at this digit position, plus carry.\n      b = c[j] + yc[i] * xc[j - i - 1] + b;\n      c[j--] = b % 10;\n\n      // carry\n      b = b / 10 | 0;\n    }\n\n    c[j] = b;\n  }\n\n  // Increment result exponent if there is a final carry, otherwise remove leading zero.\n  if (b) ++y.e;\n  else c.shift();\n\n  // Remove trailing zeros.\n  for (i = c.length; !c[--i];) c.pop();\n  y.c = c;\n\n  return y;\n};\n\n\n/*\n * Return a string representing the value of this Big in exponential notation rounded to dp fixed\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\n *\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.toExponential = function (dp, rm) {\n  var x = this,\n    n = x.c[0];\n\n  if (dp !== UNDEFINED) {\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n      throw Error(INVALID_DP);\n    }\n    x = round(new x.constructor(x), ++dp, rm);\n    for (; x.c.length < dp;) x.c.push(0);\n  }\n\n  return stringify(x, true, !!n);\n};\n\n\n/*\n * Return a string representing the value of this Big in normal notation rounded to dp fixed\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\n *\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n *\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\n */\nP.toFixed = function (dp, rm) {\n  var x = this,\n    n = x.c[0];\n\n  if (dp !== UNDEFINED) {\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n      throw Error(INVALID_DP);\n    }\n    x = round(new x.constructor(x), dp + x.e + 1, rm);\n\n    // x.e may have changed if the value is rounded up.\n    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);\n  }\n\n  return stringify(x, false, !!n);\n};\n\n\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Omit the sign for negative zero.\n */\nP[Symbol.for('nodejs.util.inspect.custom')] = P.toJSON = P.toString = function () {\n  var x = this,\n    Big = x.constructor;\n  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\n};\n\n\n/*\n * Return the value of this Big as a primitive number.\n */\nP.toNumber = function () {\n  var n = +stringify(this, true, true);\n  if (this.constructor.strict === true && !this.eq(n.toString())) {\n    throw Error(NAME + 'Imprecise conversion');\n  }\n  return n;\n};\n\n\n/*\n * Return a string representing the value of this Big rounded to sd significant digits using\n * rounding mode rm, or Big.RM if rm is not specified.\n * Use exponential notation if sd is less than the number of digits necessary to represent\n * the integer part of the value in normal notation.\n *\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\n */\nP.toPrecision = function (sd, rm) {\n  var x = this,\n    Big = x.constructor,\n    n = x.c[0];\n\n  if (sd !== UNDEFINED) {\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n      throw Error(INVALID + 'precision');\n    }\n    x = round(new Big(x), sd, rm);\n    for (; x.c.length < sd;) x.c.push(0);\n  }\n\n  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\n};\n\n\n/*\n * Return a string representing the value of this Big.\n * Return exponential notation if this Big has a positive exponent equal to or greater than\n * Big.PE, or a negative exponent equal to or less than Big.NE.\n * Include the sign for negative zero.\n */\nP.valueOf = function () {\n  var x = this,\n    Big = x.constructor;\n  if (Big.strict === true) {\n    throw Error(NAME + 'valueOf disallowed');\n  }\n  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\n};\n\n\n// Export\n\n\nexport var Big = _Big_();\n\n/// <reference types=\"https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts\" />\nexport default Big;\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.08203125,
          "content": "{\n  \"name\": \"big.js\",\n  \"description\": \"A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic\",\n  \"version\": \"6.2.2\",\n  \"keywords\": [\n    \"arbitrary\",\n    \"precision\",\n    \"arithmetic\",\n    \"big\",\n    \"number\",\n    \"decimal\",\n    \"float\",\n    \"biginteger\",\n    \"bigdecimal\",\n    \"bignumber\",\n    \"bigint\",\n    \"bignum\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": \"./big.mjs\",\n      \"require\": \"./big.js\"\n    },\n    \"./big.mjs\": \"./big.mjs\",\n    \"./big.js\": \"./big.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/MikeMcl/big.js.git\"\n  },\n  \"main\": \"big\",\n  \"browser\": \"big.js\",\n  \"module\": \"big.mjs\",\n  \"author\": {\n    \"name\": \"Michael Mclaughlin\",\n    \"email\": \"M8ch88l@gmail.com\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/MikeMcl/big.js/issues\"\n  },\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"test\": \"node ./test/runner.js\"\n  },\n  \"files\": [\n    \"big.js\",\n    \"big.mjs\"\n  ],\n  \"funding\": {\n    \"type\": \"opencollective\",\n    \"url\": \"https://opencollective.com/bigjs\"\n  }\n}\n"
        },
        {
          "name": "perf",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}