{
  "metadata": {
    "timestamp": 1736563375624,
    "page": 377,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "paulmillr/chokidar",
      "stars": 11137,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0927734375,
          "content": "*.bak\n*.log\n/coverage/\n/node_modules/\n/test-fixtures/\n/*.d.ts\n/*.map\n/index.js\n/handler.js\n/esm"
        },
        {
          "name": ".prettierrc.json",
          "type": "blob",
          "size": 0.0712890625,
          "content": "{\n  \"printWidth\": 100,\n  \"singleQuote\": true,\n  \"trailingComma\": \"es5\"\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.09765625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2012 Paul Miller (https://paulmillr.com), Elan Shanker\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.818359375,
          "content": "# Chokidar [![Weekly downloads](https://img.shields.io/npm/dw/chokidar.svg)](https://github.com/paulmillr/chokidar)\n\n> Minimal and efficient cross-platform file watching library\n\n## Why?\n\nThere are many reasons to prefer Chokidar to raw fs.watch / fs.watchFile in 2024:\n\n- Events are properly reported\n    - macOS events report filenames\n    - events are not reported twice\n    - changes are reported as add / change / unlink instead of useless `rename`\n- Atomic writes are supported, using `atomic` option\n    - Some file editors use them\n- Chunked writes are supported, using `awaitWriteFinish` option\n    - Large files are commonly written in chunks\n- File / dir filtering is supported\n- Symbolic links are supported\n- Recursive watching is always supported, instead of partial when using raw events\n    - Includes a way to limit recursion depth\n\nChokidar relies on the Node.js core `fs` module, but when using\n`fs.watch` and `fs.watchFile` for watching, it normalizes the events it\nreceives, often checking for truth by getting file stats and/or dir contents.\nThe `fs.watch`-based implementation is the default, which\navoids polling and keeps CPU usage down. Be advised that chokidar will initiate\nwatchers recursively for everything within scope of the paths that have been\nspecified, so be judicious about not wasting system resources by watching much\nmore than needed. For some cases, `fs.watchFile`, which utilizes polling and uses more resources, is used.\n\nMade for [Brunch](https://brunch.io/) in 2012,\nit is now used in [~30 million repositories](https://www.npmjs.com/browse/depended/chokidar) and\nhas proven itself in production environments.\n\n**Sep 2024 update:** v4 is out! It decreases dependency count from 13 to 1, removes\nsupport for globs, adds support for ESM / Common.js modules, and bumps minimum node.js version from v8 to v14.\nCheck out [upgrading](#upgrading).\n\n## Getting started\n\nInstall with npm:\n\n```sh\nnpm install chokidar\n```\n\nUse it in your code:\n\n```javascript\nimport chokidar from 'chokidar';\n\n// One-liner for current directory\nchokidar.watch('.').on('all', (event, path) => {\n  console.log(event, path);\n});\n\n\n// Extended options\n// ----------------\n\n// Initialize watcher.\nconst watcher = chokidar.watch('file, dir, or array', {\n  ignored: (path, stats) => stats?.isFile() && !path.endsWith('.js'), // only watch js files\n  persistent: true\n});\n\n// Something to use when events are received.\nconst log = console.log.bind(console);\n// Add event listeners.\nwatcher\n  .on('add', path => log(`File ${path} has been added`))\n  .on('change', path => log(`File ${path} has been changed`))\n  .on('unlink', path => log(`File ${path} has been removed`));\n\n// More possible events.\nwatcher\n  .on('addDir', path => log(`Directory ${path} has been added`))\n  .on('unlinkDir', path => log(`Directory ${path} has been removed`))\n  .on('error', error => log(`Watcher error: ${error}`))\n  .on('ready', () => log('Initial scan complete. Ready for changes'))\n  .on('raw', (event, path, details) => { // internal\n    log('Raw event info:', event, path, details);\n  });\n\n// 'add', 'addDir' and 'change' events also receive stat() results as second\n// argument when available: https://nodejs.org/api/fs.html#fs_class_fs_stats\nwatcher.on('change', (path, stats) => {\n  if (stats) console.log(`File ${path} changed size to ${stats.size}`);\n});\n\n// Watch new files.\nwatcher.add('new-file');\nwatcher.add(['new-file-2', 'new-file-3']);\n\n// Get list of actual paths being watched on the filesystem\nlet watchedPaths = watcher.getWatched();\n\n// Un-watch some files.\nawait watcher.unwatch('new-file');\n\n// Stop watching. The method is async!\nawait watcher.close().then(() => console.log('closed'));\n\n// Full list of options. See below for descriptions.\n// Do not use this example!\nchokidar.watch('file', {\n  persistent: true,\n\n  // ignore .txt files\n  ignored: (file) => file.endsWith('.txt'),\n  // watch only .txt files\n  // ignored: (file, _stats) => _stats?.isFile() && !file.endsWith('.txt'),\n\n  awaitWriteFinish: true, // emit single event when chunked writes are completed\n  atomic: true, // emit proper events when \"atomic writes\" (mv _tmp file) are used\n\n  // The options also allow specifying custom intervals in ms\n  // awaitWriteFinish: {\n  //   stabilityThreshold: 2000,\n  //   pollInterval: 100\n  // },\n  // atomic: 100,\n\n  interval: 100,\n  binaryInterval: 300,\n\n  cwd: '.',\n  depth: 99,\n\n  followSymlinks: true,\n  ignoreInitial: false,\n  ignorePermissionErrors: false,\n  usePolling: false,\n  alwaysStat: false,\n});\n\n```\n\n`chokidar.watch(paths, [options])`\n\n* `paths` (string or array of strings). Paths to files, dirs to be watched\nrecursively.\n* `options` (object) Options object as defined below:\n\n#### Persistence\n\n* `persistent` (default: `true`). Indicates whether the process\nshould continue to run as long as files are being watched.\n\n#### Path filtering\n\n* `ignored` function, regex, or path. Defines files/paths to be ignored.\nThe whole relative or absolute path is tested, not just filename. If a function with two arguments\nis provided, it gets called twice per path - once with a single argument (the path), second\ntime with two arguments (the path and the\n[`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats)\nobject of that path).\n* `ignoreInitial` (default: `false`). If set to `false` then `add`/`addDir` events are also emitted for matching paths while\ninstantiating the watching as chokidar discovers these file paths (before the `ready` event).\n* `followSymlinks` (default: `true`). When `false`, only the\nsymlinks themselves will be watched for changes instead of following\nthe link references and bubbling events through the link's path.\n* `cwd` (no default). The base directory from which watch `paths` are to be\nderived. Paths emitted with events will be relative to this.\n\n#### Performance\n\n* `usePolling` (default: `false`).\nWhether to use fs.watchFile (backed by polling), or fs.watch. If polling\nleads to high CPU utilization, consider setting this to `false`. It is\ntypically necessary to **set this to `true` to successfully watch files over\na network**, and it may be necessary to successfully watch files in other\nnon-standard situations. Setting to `true` explicitly on MacOS overrides the\n`useFsEvents` default. You may also set the CHOKIDAR_USEPOLLING env variable\nto true (1) or false (0) in order to override this option.\n* _Polling-specific settings_ (effective when `usePolling: true`)\n  * `interval` (default: `100`). Interval of file system polling, in milliseconds. You may also\n    set the CHOKIDAR_INTERVAL env variable to override this option.\n  * `binaryInterval` (default: `300`). Interval of file system\n  polling for binary files.\n  ([see list of binary extensions](https://github.com/sindresorhus/binary-extensions/blob/master/binary-extensions.json))\n* `alwaysStat` (default: `false`). If relying upon the\n[`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats)\nobject that may get passed with `add`, `addDir`, and `change` events, set\nthis to `true` to ensure it is provided even in cases where it wasn't\nalready available from the underlying watch events.\n* `depth` (default: `undefined`). If set, limits how many levels of\nsubdirectories will be traversed.\n* `awaitWriteFinish` (default: `false`).\nBy default, the `add` event will fire when a file first appears on disk, before\nthe entire file has been written. Furthermore, in some cases some `change`\nevents will be emitted while the file is being written. In some cases,\nespecially when watching for large files there will be a need to wait for the\nwrite operation to finish before responding to a file creation or modification.\nSetting `awaitWriteFinish` to `true` (or a truthy value) will poll file size,\nholding its `add` and `change` events until the size does not change for a\nconfigurable amount of time. The appropriate duration setting is heavily\ndependent on the OS and hardware. For accurate detection this parameter should\nbe relatively high, making file watching much less responsive.\nUse with caution.\n  * *`options.awaitWriteFinish` can be set to an object in order to adjust\n  timing params:*\n  * `awaitWriteFinish.stabilityThreshold` (default: 2000). Amount of time in\n  milliseconds for a file size to remain constant before emitting its event.\n  * `awaitWriteFinish.pollInterval` (default: 100). File size polling interval, in milliseconds.\n\n#### Errors\n\n* `ignorePermissionErrors` (default: `false`). Indicates whether to watch files\nthat don't have read permissions if possible. If watching fails due to `EPERM`\nor `EACCES` with this set to `true`, the errors will be suppressed silently.\n* `atomic` (default: `true` if `useFsEvents` and `usePolling` are `false`).\nAutomatically filters out artifacts that occur when using editors that use\n\"atomic writes\" instead of writing directly to the source file. If a file is\nre-added within 100 ms of being deleted, Chokidar emits a `change` event\nrather than `unlink` then `add`. If the default of 100 ms does not work well\nfor you, you can override it by setting `atomic` to a custom value, in\nmilliseconds.\n\n### Methods & Events\n\n`chokidar.watch()` produces an instance of `FSWatcher`. Methods of `FSWatcher`:\n\n* `.add(path / paths)`: Add files, directories for tracking.\nTakes an array of strings or just one string.\n* `.on(event, callback)`: Listen for an FS event.\nAvailable events: `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `ready`,\n`raw`, `error`.\nAdditionally `all` is available which gets emitted with the underlying event\nname and path for every event other than `ready`, `raw`, and `error`.  `raw` is internal, use it carefully.\n* `.unwatch(path / paths)`: Stop watching files or directories.\nTakes an array of strings or just one string.\n* `.close()`: **async** Removes all listeners from watched files. Asynchronous, returns Promise. Use with `await` to ensure bugs don't happen.\n* `.getWatched()`: Returns an object representing all the paths on the file\nsystem being watched by this `FSWatcher` instance. The object's keys are all the\ndirectories (using absolute paths unless the `cwd` option was used), and the\nvalues are arrays of the names of the items contained in each directory.\n\n### CLI\n\nCheck out third party [chokidar-cli](https://github.com/open-cli-tools/chokidar-cli),\nwhich allows to execute a command on each change, or get a stdio stream of change events.\n\n## Troubleshooting\n\nSometimes, Chokidar runs out of file handles, causing `EMFILE` and `ENOSP` errors:\n\n* `bash: cannot set terminal process group (-1): Inappropriate ioctl for device bash: no job control in this shell`\n* `Error: watch /home/ ENOSPC`\n\nThere are two things that can cause it.\n\n1. Exhausted file handles for generic fs operations\n    - Can be solved by using [graceful-fs](https://www.npmjs.com/package/graceful-fs),\n      which can monkey-patch native `fs` module used by chokidar: `let fs = require('fs'); let grfs = require('graceful-fs'); grfs.gracefulify(fs);`\n    - Can also be solved by tuning OS: `echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p`.\n2. Exhausted file handles for `fs.watch`\n    - Can't seem to be solved by graceful-fs or OS tuning\n    - It's possible to start using `usePolling: true`, which will switch backend to resource-intensive `fs.watchFile`\n\nAll fsevents-related issues (`WARN optional dep failed`, `fsevents is not a constructor`) are solved by upgrading to v4+.\n\n## Changelog\n\n- **v4 (Sep 2024):** remove glob support and bundled fsevents. Decrease dependency count from 13 to 1. Rewrite in typescript. Bumps minimum node.js requirement to v14+\n- **v3 (Apr 2019):** massive CPU & RAM consumption improvements; reduces deps / package size by a factor of 17x and bumps Node.js requirement to v8.16+.\n- **v2 (Dec 2017):** globs are now posix-style-only. Tons of bugfixes.\n- **v1 (Apr 2015):** glob support, symlink support, tons of bugfixes. Node 0.8+ is supported\n- **v0.1 (Apr 2012):** Initial release, extracted from [Brunch](https://github.com/brunch/brunch/blob/9847a065aea300da99bd0753f90354cde9de1261/src/helpers.coffee#L66)\n\n### Upgrading\n\nIf you've used globs before and want do replicate the functionality with v4:\n\n```js\n// v3\nchok.watch('**/*.js');\nchok.watch(\"./directory/**/*\");\n\n// v4\nchok.watch('.', {\n  ignored: (path, stats) => stats?.isFile() && !path.endsWith('.js'), // only watch js files\n});\nchok.watch('./directory');\n\n// other way\nimport { glob } from 'node:fs/promises';\nconst watcher = watch(await Array.fromAsync(glob('**/*.js')));\n\n// unwatching\n// v3\nchok.unwatch('**/*.js');\n// v4\nchok.unwatch(await glob('**/*.js'));\n```\n\n## Also\n\nWhy was chokidar named this way? What's the meaning behind it?\n\n>Chowkidar is a transliteration of a Hindi word meaning 'watchman, gatekeeper', चौकीदार. This ultimately comes from Sanskrit _ चतुष्क_ (crossway, quadrangle, consisting-of-four). This word is also used in other languages like Urdu as (چوکیدار) which is widely used in Pakistan and India. \n\n## License\n\nMIT (c) Paul Miller (<https://paulmillr.com>), see [LICENSE](LICENSE) file.\n"
        },
        {
          "name": "esm",
          "type": "tree",
          "content": null
        },
        {
          "name": "example.js",
          "type": "blob",
          "size": 0.34375,
          "content": "global.watcher = require('./index.js').default.watch('.', {\n  ignored: /node_modules|\\.git/,\n  persistent: true,\n  // followSymlinks: false,\n  // useFsEvents: false,\n  // usePolling: false,\n})\n.on('all', (event, path) => { console.log(event, path); })\n.on('ready', () => { console.log('Ready'); })\n//.on('raw', console.log.bind(console, 'Raw event:'))\n"
        },
        {
          "name": "package-lock.json",
          "type": "blob",
          "size": 17.1845703125,
          "content": "{\n  \"name\": \"chokidar\",\n  \"version\": \"4.0.3\",\n  \"lockfileVersion\": 3,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"chokidar\",\n      \"version\": \"4.0.3\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"readdirp\": \"^4.0.1\"\n      },\n      \"devDependencies\": {\n        \"@paulmillr/jsbt\": \"0.2.1\",\n        \"@types/node\": \"20.14.8\",\n        \"chai\": \"4.3.4\",\n        \"prettier\": \"3.1.1\",\n        \"rimraf\": \"5.0.5\",\n        \"sinon\": \"12.0.1\",\n        \"sinon-chai\": \"3.7.0\",\n        \"typescript\": \"5.5.2\",\n        \"upath\": \"2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 14.16.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://paulmillr.com/funding/\"\n      }\n    },\n    \"node_modules/@isaacs/cliui\": {\n      \"version\": \"8.0.2\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"string-width\": \"^5.1.2\",\n        \"string-width-cjs\": \"npm:string-width@^4.2.0\",\n        \"strip-ansi\": \"^7.0.1\",\n        \"strip-ansi-cjs\": \"npm:strip-ansi@^6.0.1\",\n        \"wrap-ansi\": \"^8.1.0\",\n        \"wrap-ansi-cjs\": \"npm:wrap-ansi@^7.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@paulmillr/jsbt\": {\n      \"version\": \"0.2.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"bin\": {\n        \"jsbt\": \"jsbt.js\"\n      }\n    },\n    \"node_modules/@pkgjs/parseargs\": {\n      \"version\": \"0.11.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"optional\": true,\n      \"engines\": {\n        \"node\": \">=14\"\n      }\n    },\n    \"node_modules/@sinonjs/commons\": {\n      \"version\": \"1.8.6\",\n      \"dev\": true,\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"type-detect\": \"4.0.8\"\n      }\n    },\n    \"node_modules/@sinonjs/commons/node_modules/type-detect\": {\n      \"version\": \"4.0.8\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/@sinonjs/fake-timers\": {\n      \"version\": \"8.1.0\",\n      \"dev\": true,\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"@sinonjs/commons\": \"^1.7.0\"\n      }\n    },\n    \"node_modules/@sinonjs/samsam\": {\n      \"version\": \"6.1.3\",\n      \"dev\": true,\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"@sinonjs/commons\": \"^1.6.0\",\n        \"lodash.get\": \"^4.4.2\",\n        \"type-detect\": \"^4.0.8\"\n      }\n    },\n    \"node_modules/@sinonjs/text-encoding\": {\n      \"version\": \"0.7.3\",\n      \"dev\": true,\n      \"license\": \"(Unlicense OR Apache-2.0)\"\n    },\n    \"node_modules/@types/node\": {\n      \"version\": \"20.14.8\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"undici-types\": \"~5.26.4\"\n      }\n    },\n    \"node_modules/ansi-regex\": {\n      \"version\": \"6.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-regex?sponsor=1\"\n      }\n    },\n    \"node_modules/ansi-styles\": {\n      \"version\": \"6.2.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-styles?sponsor=1\"\n      }\n    },\n    \"node_modules/assertion-error\": {\n      \"version\": \"1.1.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/balanced-match\": {\n      \"version\": \"1.0.2\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/brace-expansion\": {\n      \"version\": \"2.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\"\n      }\n    },\n    \"node_modules/chai\": {\n      \"version\": \"4.3.4\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"assertion-error\": \"^1.1.0\",\n        \"check-error\": \"^1.0.2\",\n        \"deep-eql\": \"^3.0.1\",\n        \"get-func-name\": \"^2.0.0\",\n        \"pathval\": \"^1.1.1\",\n        \"type-detect\": \"^4.0.5\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/check-error\": {\n      \"version\": \"1.0.3\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"get-func-name\": \"^2.0.2\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/color-convert\": {\n      \"version\": \"2.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"color-name\": \"~1.1.4\"\n      },\n      \"engines\": {\n        \"node\": \">=7.0.0\"\n      }\n    },\n    \"node_modules/color-name\": {\n      \"version\": \"1.1.4\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/cross-spawn\": {\n      \"version\": \"7.0.3\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"path-key\": \"^3.1.0\",\n        \"shebang-command\": \"^2.0.0\",\n        \"which\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/deep-eql\": {\n      \"version\": \"3.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"type-detect\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.12\"\n      }\n    },\n    \"node_modules/diff\": {\n      \"version\": \"5.2.0\",\n      \"dev\": true,\n      \"license\": \"BSD-3-Clause\",\n      \"engines\": {\n        \"node\": \">=0.3.1\"\n      }\n    },\n    \"node_modules/eastasianwidth\": {\n      \"version\": \"0.2.0\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/emoji-regex\": {\n      \"version\": \"9.2.2\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/foreground-child\": {\n      \"version\": \"3.3.0\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"cross-spawn\": \"^7.0.0\",\n        \"signal-exit\": \"^4.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=14\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/get-func-name\": {\n      \"version\": \"2.0.2\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/glob\": {\n      \"version\": \"10.4.5\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"foreground-child\": \"^3.1.0\",\n        \"jackspeak\": \"^3.1.2\",\n        \"minimatch\": \"^9.0.4\",\n        \"minipass\": \"^7.1.2\",\n        \"package-json-from-dist\": \"^1.0.0\",\n        \"path-scurry\": \"^1.11.1\"\n      },\n      \"bin\": {\n        \"glob\": \"dist/esm/bin.mjs\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/has-flag\": {\n      \"version\": \"4.0.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/is-fullwidth-code-point\": {\n      \"version\": \"3.0.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/isexe\": {\n      \"version\": \"2.0.0\",\n      \"dev\": true,\n      \"license\": \"ISC\"\n    },\n    \"node_modules/jackspeak\": {\n      \"version\": \"3.4.3\",\n      \"dev\": true,\n      \"license\": \"BlueOak-1.0.0\",\n      \"dependencies\": {\n        \"@isaacs/cliui\": \"^8.0.2\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      },\n      \"optionalDependencies\": {\n        \"@pkgjs/parseargs\": \"^0.11.0\"\n      }\n    },\n    \"node_modules/just-extend\": {\n      \"version\": \"6.2.0\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/lodash.get\": {\n      \"version\": \"4.4.2\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/lru-cache\": {\n      \"version\": \"10.4.3\",\n      \"dev\": true,\n      \"license\": \"ISC\"\n    },\n    \"node_modules/minimatch\": {\n      \"version\": \"9.0.5\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"brace-expansion\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=16 || 14 >=14.17\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/minipass\": {\n      \"version\": \"7.1.2\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"engines\": {\n        \"node\": \">=16 || 14 >=14.17\"\n      }\n    },\n    \"node_modules/nise\": {\n      \"version\": \"5.1.9\",\n      \"dev\": true,\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"@sinonjs/commons\": \"^3.0.0\",\n        \"@sinonjs/fake-timers\": \"^11.2.2\",\n        \"@sinonjs/text-encoding\": \"^0.7.2\",\n        \"just-extend\": \"^6.2.0\",\n        \"path-to-regexp\": \"^6.2.1\"\n      }\n    },\n    \"node_modules/nise/node_modules/@sinonjs/commons\": {\n      \"version\": \"3.0.1\",\n      \"dev\": true,\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"type-detect\": \"4.0.8\"\n      }\n    },\n    \"node_modules/nise/node_modules/@sinonjs/fake-timers\": {\n      \"version\": \"11.3.1\",\n      \"dev\": true,\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"@sinonjs/commons\": \"^3.0.1\"\n      }\n    },\n    \"node_modules/nise/node_modules/type-detect\": {\n      \"version\": \"4.0.8\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/package-json-from-dist\": {\n      \"version\": \"1.0.0\",\n      \"dev\": true,\n      \"license\": \"BlueOak-1.0.0\"\n    },\n    \"node_modules/path-key\": {\n      \"version\": \"3.1.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/path-scurry\": {\n      \"version\": \"1.11.1\",\n      \"dev\": true,\n      \"license\": \"BlueOak-1.0.0\",\n      \"dependencies\": {\n        \"lru-cache\": \"^10.2.0\",\n        \"minipass\": \"^5.0.0 || ^6.0.2 || ^7.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=16 || 14 >=14.18\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/path-to-regexp\": {\n      \"version\": \"6.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-6.3.0.tgz\",\n      \"integrity\": \"sha512-Yhpw4T9C6hPpgPeA28us07OJeqZ5EzQTkbfwuhsUg0c237RomFoETJgmp2sa3F/41gfLE6G5cqcYwznmeEeOlQ==\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/pathval\": {\n      \"version\": \"1.1.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/prettier\": {\n      \"version\": \"3.1.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"bin\": {\n        \"prettier\": \"bin/prettier.cjs\"\n      },\n      \"engines\": {\n        \"node\": \">=14\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/prettier/prettier?sponsor=1\"\n      }\n    },\n    \"node_modules/readdirp\": {\n      \"version\": \"4.0.1\",\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">= 14.16.0\"\n      },\n      \"funding\": {\n        \"type\": \"individual\",\n        \"url\": \"https://paulmillr.com/funding/\"\n      }\n    },\n    \"node_modules/rimraf\": {\n      \"version\": \"5.0.5\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"glob\": \"^10.3.7\"\n      },\n      \"bin\": {\n        \"rimraf\": \"dist/esm/bin.mjs\"\n      },\n      \"engines\": {\n        \"node\": \">=14\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/shebang-command\": {\n      \"version\": \"2.0.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"shebang-regex\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/shebang-regex\": {\n      \"version\": \"3.0.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/signal-exit\": {\n      \"version\": \"4.1.0\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"engines\": {\n        \"node\": \">=14\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/sinon\": {\n      \"version\": \"12.0.1\",\n      \"dev\": true,\n      \"license\": \"BSD-3-Clause\",\n      \"dependencies\": {\n        \"@sinonjs/commons\": \"^1.8.3\",\n        \"@sinonjs/fake-timers\": \"^8.1.0\",\n        \"@sinonjs/samsam\": \"^6.0.2\",\n        \"diff\": \"^5.0.0\",\n        \"nise\": \"^5.1.0\",\n        \"supports-color\": \"^7.2.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/sinon\"\n      }\n    },\n    \"node_modules/sinon-chai\": {\n      \"version\": \"3.7.0\",\n      \"dev\": true,\n      \"license\": \"(BSD-2-Clause OR WTFPL)\",\n      \"peerDependencies\": {\n        \"chai\": \"^4.0.0\",\n        \"sinon\": \">=4.0.0\"\n      }\n    },\n    \"node_modules/string-width\": {\n      \"version\": \"5.1.2\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"eastasianwidth\": \"^0.2.0\",\n        \"emoji-regex\": \"^9.2.2\",\n        \"strip-ansi\": \"^7.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/string-width-cjs\": {\n      \"name\": \"string-width\",\n      \"version\": \"4.2.3\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"emoji-regex\": \"^8.0.0\",\n        \"is-fullwidth-code-point\": \"^3.0.0\",\n        \"strip-ansi\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/string-width-cjs/node_modules/ansi-regex\": {\n      \"version\": \"5.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/string-width-cjs/node_modules/emoji-regex\": {\n      \"version\": \"8.0.0\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/string-width-cjs/node_modules/strip-ansi\": {\n      \"version\": \"6.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/strip-ansi\": {\n      \"version\": \"7.1.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/strip-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/strip-ansi-cjs\": {\n      \"name\": \"strip-ansi\",\n      \"version\": \"6.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/strip-ansi-cjs/node_modules/ansi-regex\": {\n      \"version\": \"5.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/supports-color\": {\n      \"version\": \"7.2.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"has-flag\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/type-detect\": {\n      \"version\": \"4.1.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/typescript\": {\n      \"version\": \"5.5.2\",\n      \"dev\": true,\n      \"license\": \"Apache-2.0\",\n      \"bin\": {\n        \"tsc\": \"bin/tsc\",\n        \"tsserver\": \"bin/tsserver\"\n      },\n      \"engines\": {\n        \"node\": \">=14.17\"\n      }\n    },\n    \"node_modules/undici-types\": {\n      \"version\": \"5.26.5\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/upath\": {\n      \"version\": \"2.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=4\",\n        \"yarn\": \"*\"\n      }\n    },\n    \"node_modules/which\": {\n      \"version\": \"2.0.2\",\n      \"dev\": true,\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"isexe\": \"^2.0.0\"\n      },\n      \"bin\": {\n        \"node-which\": \"bin/node-which\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/wrap-ansi\": {\n      \"version\": \"8.1.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-styles\": \"^6.1.0\",\n        \"string-width\": \"^5.0.1\",\n        \"strip-ansi\": \"^7.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/wrap-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs\": {\n      \"name\": \"wrap-ansi\",\n      \"version\": \"7.0.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-styles\": \"^4.0.0\",\n        \"string-width\": \"^4.1.0\",\n        \"strip-ansi\": \"^6.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/wrap-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/ansi-regex\": {\n      \"version\": \"5.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/ansi-styles\": {\n      \"version\": \"4.3.0\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"color-convert\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-styles?sponsor=1\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/emoji-regex\": {\n      \"version\": \"8.0.0\",\n      \"dev\": true,\n      \"license\": \"MIT\"\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/string-width\": {\n      \"version\": \"4.2.3\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"emoji-regex\": \"^8.0.0\",\n        \"is-fullwidth-code-point\": \"^3.0.0\",\n        \"strip-ansi\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/wrap-ansi-cjs/node_modules/strip-ansi\": {\n      \"version\": \"6.0.1\",\n      \"dev\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    }\n  }\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.4814453125,
          "content": "{\n  \"name\": \"chokidar\",\n  \"description\": \"Minimal and efficient cross-platform file watching library\",\n  \"version\": \"4.0.3\",\n  \"homepage\": \"https://github.com/paulmillr/chokidar\",\n  \"author\": \"Paul Miller (https://paulmillr.com)\",\n  \"files\": [\n    \"index.js\",\n    \"index.d.ts\",\n    \"handler.js\",\n    \"handler.d.ts\",\n    \"esm\"\n  ],\n  \"main\": \"./index.js\",\n  \"module\": \"./esm/index.js\",\n  \"types\": \"./index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./esm/index.js\",\n      \"require\": \"./index.js\"\n    },\n    \"./handler.js\": {\n      \"import\": \"./esm/handler.js\",\n      \"require\": \"./handler.js\"\n    }\n  },\n  \"dependencies\": {\n    \"readdirp\": \"^4.0.1\"\n  },\n  \"devDependencies\": {\n    \"@paulmillr/jsbt\": \"0.2.1\",\n    \"@types/node\": \"20.14.8\",\n    \"chai\": \"4.3.4\",\n    \"prettier\": \"3.1.1\",\n    \"rimraf\": \"5.0.5\",\n    \"sinon\": \"12.0.1\",\n    \"sinon-chai\": \"3.7.0\",\n    \"typescript\": \"5.5.2\",\n    \"upath\": \"2.0.1\"\n  },\n  \"sideEffects\": false,\n  \"engines\": {\n    \"node\": \">= 14.16.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/paulmillr/chokidar.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/paulmillr/chokidar/issues\"\n  },\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"build\": \"tsc && tsc -p tsconfig.esm.json\",\n    \"lint\": \"prettier --check src\",\n    \"format\": \"prettier --write src\",\n    \"test\": \"node --test\"\n  },\n  \"keywords\": [\n    \"fs\",\n    \"watch\",\n    \"watchFile\",\n    \"watcher\",\n    \"watching\",\n    \"file\",\n    \"fsevents\"\n  ],\n  \"funding\": \"https://paulmillr.com/funding/\"\n}\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.mjs",
          "type": "blob",
          "size": 85.126953125,
          "content": "import fs from 'node:fs';\nimport sysPath from 'node:path';\nimport {describe, it, before, after, beforeEach, afterEach} from 'node:test';\nimport {fileURLToPath, pathToFileURL} from 'node:url';\nimport {promisify} from 'node:util';\nimport childProcess from 'node:child_process';\nimport chai from 'chai';\nimport {rimraf} from 'rimraf';\nimport sinon from 'sinon';\nimport sinonChai from 'sinon-chai';\nimport upath from 'upath';\n\nimport chokidar from './esm/index.js';\nimport { EVENTS as EV, isWindows, isMacos, isIBMi } from './esm/handler.js';\n\nimport { URL } from 'url'; // in Browser, the URL in native accessible on window\n\nconst __filename = fileURLToPath(new URL('', import.meta.url));\n// Will contain trailing slash\nconst __dirname = fileURLToPath(new URL('.', import.meta.url));\n\nconst {expect} = chai;\nchai.use(sinonChai);\nchai.should();\n\nconst exec = promisify(childProcess.exec);\nconst write = promisify(fs.writeFile);\nconst fs_symlink = promisify(fs.symlink);\nconst fs_rename = promisify(fs.rename);\nconst fs_mkdir = promisify(fs.mkdir);\nconst fs_rmdir = promisify(fs.rmdir);\nconst fs_unlink = promisify(fs.unlink);\n\nconst FIXTURES_PATH_REL = 'test-fixtures';\nconst FIXTURES_PATH = sysPath.join(__dirname, FIXTURES_PATH_REL);\nconst allWatchers = [];\nconst PERM_ARR = 0o755; // rwe, r+e, r+e\nconst TEST_TIMEOUT = 8000;\nlet subdirId = 0;\nlet currentDir;\nlet slowerDelay;\n\n// spyOnReady\nconst aspy = (watcher, eventName, spy = null, noStat = false) => {\n  if (typeof eventName !== 'string') {\n    throw new TypeError('aspy: eventName must be a String');\n  }\n  if (spy == null) spy = sinon.spy();\n  return new Promise((resolve, reject) => {\n    const handler = noStat ?\n      (eventName === EV.ALL ?\n      (event, path) => spy(event, path) :\n      (path) => spy(path)) :\n      spy;\n    const timeout = setTimeout(() => {\n      reject(new Error('timeout'));\n    }, TEST_TIMEOUT);\n    watcher.on(EV.ERROR, (...args) => {\n      clearTimeout(timeout);\n      reject(...args);\n    });\n    watcher.on(EV.READY, () => {\n      clearTimeout(timeout);\n      resolve(spy);\n    });\n    watcher.on(eventName, handler);\n  });\n};\n\nconst waitForWatcher = (watcher) => {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      reject(new Error('timeout'));\n    }, TEST_TIMEOUT);\n    watcher.on(EV.ERROR, (...args) => {\n      clearTimeout(timeout);\n      reject(...args);\n    });\n    watcher.on(EV.READY, (...args) => {\n      clearTimeout(timeout);\n      resolve(...args);\n    });\n  });\n};\n\nconst delay = async (time) => {\n  return new Promise((resolve) => {\n    const timer = time || slowerDelay || 20;\n    setTimeout(resolve, timer);\n  });\n};\n\nconst getFixturePath = (subPath) => {\n  const subd = subdirId && subdirId.toString() || '';\n  return sysPath.join(FIXTURES_PATH, subd, subPath);\n};\nconst getGlobPath = (subPath) => {\n  const subd = subdirId && subdirId.toString() || '';\n  return upath.join(FIXTURES_PATH, subd, subPath);\n};\ncurrentDir = getFixturePath('');\n\nconst chokidar_watch = (path = currentDir, opts) => {\n  const wt = chokidar.watch(path, opts);\n  allWatchers.push(wt);\n  return wt;\n};\n\nconst waitFor = (spies) => {\n  if (spies.length === 0) throw new TypeError('SPies zero');\n  return new Promise((resolve, reject) => {\n    let checkTimer;\n    const timeout = setTimeout(() => {\n      clearTimeout(checkTimer);\n      reject(new Error('timeout'));\n    }, TEST_TIMEOUT);\n    const isSpyReady = (spy) => {\n      if (Array.isArray(spy)) {\n        return spy[0].callCount >= spy[1];\n      }\n      return spy.callCount >= 1;\n    };\n    const checkSpiesReady = () => {\n      clearTimeout(checkTimer);\n\n      if (spies.every(isSpyReady)) {\n        clearTimeout(timeout);\n        resolve();\n      } else {\n        checkTimer = setTimeout(checkSpiesReady, 20);\n      }\n    };\n    checkSpiesReady();\n  });\n};\n\nconst waitForEvents = (watcher, count) => {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      reject(new Error('timeout'));\n    }, TEST_TIMEOUT);\n    const events = [];\n    const handler = (event, path) => {\n      events.push(`[ALL] ${event}: ${path}`)\n\n      if (events.length === count) {\n        watcher.off('all', handler);\n        clearTimeout(timeout);\n        resolve(events);\n      }\n    };\n\n    watcher.on('all', handler);\n  });\n};\n\nconst dateNow = () => Date.now().toString();\n\nconst runTests = (baseopts) => {\n  let macosFswatch;\n  let win32Polling;\n  let options;\n\n  baseopts.persistent = true;\n\n  before(() => {\n    // flags for bypassing special-case test failures on CI\n    macosFswatch = isMacos && !baseopts.usePolling;\n    win32Polling = isWindows && baseopts.usePolling;\n    slowerDelay = macosFswatch ? 100 : undefined;\n  });\n\n  beforeEach(function clean() {\n    options = {};\n    Object.keys(baseopts).forEach((key) => {\n      options[key] = baseopts[key];\n    });\n  });\n\n  describe('watch a directory', () => {\n    let readySpy, rawSpy, watcher, watcher2;\n    beforeEach(async () => {\n      options.ignoreInitial = true;\n      options.alwaysStat = true;\n      readySpy = sinon.spy(function readySpy(){});\n      rawSpy = sinon.spy(function rawSpy(){});\n      watcher = chokidar_watch(currentDir, options).on(EV.READY, readySpy).on(EV.RAW, rawSpy);\n      await waitForWatcher(watcher);\n    });\n    afterEach(async () => {\n      await waitFor([readySpy]);\n      await watcher.close();\n      readySpy.should.have.been.calledOnce;\n      readySpy = undefined;\n      rawSpy = undefined;\n    });\n    it('should produce an instance of chokidar.FSWatcher', () => {\n      watcher.should.be.an.instanceof(chokidar.FSWatcher);\n    });\n    it('should expose public API methods', () => {\n      watcher.on.should.be.a('function');\n      watcher.emit.should.be.a('function');\n      watcher.add.should.be.a('function');\n      watcher.close.should.be.a('function');\n      watcher.getWatched.should.be.a('function');\n    });\n    it('should emit `add` event when file was added', async () => {\n      const testPath = getFixturePath('add.txt');\n      const spy = sinon.spy(function addSpy(){});\n      watcher.on(EV.ADD, spy);\n      await delay();\n      await write(testPath, dateNow());\n      await waitFor([spy]);\n      spy.should.have.been.calledOnce;\n      spy.should.have.been.calledWith(testPath);\n      expect(spy.args[0][1]).to.be.ok; // stats\n      rawSpy.should.have.been.called;\n    });\n    it('should emit nine `add` events when nine files were added in one directory', async () => {\n      const paths = [];\n      for (let i = 1; i <= 9; i++) {\n        paths.push(getFixturePath(`add${i}.txt`));\n      }\n\n      const spy = sinon.spy();\n      watcher.on(EV.ADD, (path) => {\n        spy(path);\n      });\n\n      write(paths[0], dateNow());\n      write(paths[1], dateNow());\n      write(paths[2], dateNow());\n      write(paths[3], dateNow());\n      write(paths[4], dateNow());\n      await delay(100);\n\n      write(paths[5], dateNow());\n      write(paths[6], dateNow());\n\n      await delay(150);\n      write(paths[7], dateNow());\n      write(paths[8], dateNow());\n\n      await waitFor([[spy, 4]]);\n\n      await delay(1000);\n      await waitFor([[spy, 9]]);\n      paths.forEach(path => {\n        spy.should.have.been.calledWith(path);\n      });\n    });\n    it('should emit thirtythree `add` events when thirtythree files were added in nine directories', async () => {\n      await watcher.close();\n\n      const test1Path = getFixturePath('add1.txt');\n      const testb1Path = getFixturePath('b/add1.txt');\n      const testc1Path = getFixturePath('c/add1.txt');\n      const testd1Path = getFixturePath('d/add1.txt');\n      const teste1Path = getFixturePath('e/add1.txt');\n      const testf1Path = getFixturePath('f/add1.txt');\n      const testg1Path = getFixturePath('g/add1.txt');\n      const testh1Path = getFixturePath('h/add1.txt');\n      const testi1Path = getFixturePath('i/add1.txt');\n      const test2Path = getFixturePath('add2.txt');\n      const testb2Path = getFixturePath('b/add2.txt');\n      const testc2Path = getFixturePath('c/add2.txt');\n      const test3Path = getFixturePath('add3.txt');\n      const testb3Path = getFixturePath('b/add3.txt');\n      const testc3Path = getFixturePath('c/add3.txt');\n      const test4Path = getFixturePath('add4.txt');\n      const testb4Path = getFixturePath('b/add4.txt');\n      const testc4Path = getFixturePath('c/add4.txt');\n      const test5Path = getFixturePath('add5.txt');\n      const testb5Path = getFixturePath('b/add5.txt');\n      const testc5Path = getFixturePath('c/add5.txt');\n      const test6Path = getFixturePath('add6.txt');\n      const testb6Path = getFixturePath('b/add6.txt');\n      const testc6Path = getFixturePath('c/add6.txt');\n      const test7Path = getFixturePath('add7.txt');\n      const testb7Path = getFixturePath('b/add7.txt');\n      const testc7Path = getFixturePath('c/add7.txt');\n      const test8Path = getFixturePath('add8.txt');\n      const testb8Path = getFixturePath('b/add8.txt');\n      const testc8Path = getFixturePath('c/add8.txt');\n      const test9Path = getFixturePath('add9.txt');\n      const testb9Path = getFixturePath('b/add9.txt');\n      const testc9Path = getFixturePath('c/add9.txt');\n      fs.mkdirSync(getFixturePath('b'), PERM_ARR);\n      fs.mkdirSync(getFixturePath('c'), PERM_ARR);\n      fs.mkdirSync(getFixturePath('d'), PERM_ARR);\n      fs.mkdirSync(getFixturePath('e'), PERM_ARR);\n      fs.mkdirSync(getFixturePath('f'), PERM_ARR);\n      fs.mkdirSync(getFixturePath('g'), PERM_ARR);\n      fs.mkdirSync(getFixturePath('h'), PERM_ARR);\n      fs.mkdirSync(getFixturePath('i'), PERM_ARR);\n\n      await delay();\n\n      readySpy.resetHistory();\n      watcher2 = chokidar_watch(currentDir, options).on(EV.READY, readySpy).on(EV.RAW, rawSpy);\n      const spy = await aspy(watcher2, EV.ADD, null, true);\n\n      const filesToWrite = [\n        test1Path,\n        test2Path,\n        test3Path,\n        test4Path,\n        test5Path,\n        test6Path,\n        test7Path,\n        test8Path,\n        test9Path,\n        testb1Path,\n        testb2Path,\n        testb3Path,\n        testb4Path,\n        testb5Path,\n        testb6Path,\n        testb7Path,\n        testb8Path,\n        testb9Path,\n        testc1Path,\n        testc2Path,\n        testc3Path,\n        testc4Path,\n        testc5Path,\n        testc6Path,\n        testc7Path,\n        testc8Path,\n        testc9Path,\n        testd1Path,\n        teste1Path,\n        testf1Path,\n        testg1Path,\n        testh1Path,\n        testi1Path\n      ];\n\n      let currentCallCount = 0;\n\n      for (const fileToWrite of filesToWrite) {\n        await write(fileToWrite, dateNow());\n        await waitFor([[spy, ++currentCallCount]]);\n      }\n\n      spy.should.have.been.calledWith(test1Path);\n      spy.should.have.been.calledWith(test2Path);\n      spy.should.have.been.calledWith(test3Path);\n      spy.should.have.been.calledWith(test4Path);\n      spy.should.have.been.calledWith(test5Path);\n      spy.should.have.been.calledWith(test6Path);\n      spy.should.have.been.calledWith(test7Path);\n      spy.should.have.been.calledWith(test8Path);\n      spy.should.have.been.calledWith(test9Path);\n      spy.should.have.been.calledWith(testb1Path);\n      spy.should.have.been.calledWith(testb2Path);\n      spy.should.have.been.calledWith(testb3Path);\n      spy.should.have.been.calledWith(testb4Path);\n      spy.should.have.been.calledWith(testb5Path);\n      spy.should.have.been.calledWith(testb6Path);\n      spy.should.have.been.calledWith(testb7Path);\n      spy.should.have.been.calledWith(testb8Path);\n      spy.should.have.been.calledWith(testb9Path);\n      spy.should.have.been.calledWith(testc1Path);\n      spy.should.have.been.calledWith(testc2Path);\n      spy.should.have.been.calledWith(testc3Path);\n      spy.should.have.been.calledWith(testc4Path);\n      spy.should.have.been.calledWith(testc5Path);\n      spy.should.have.been.calledWith(testc6Path);\n      spy.should.have.been.calledWith(testc7Path);\n      spy.should.have.been.calledWith(testc8Path);\n      spy.should.have.been.calledWith(testc9Path);\n      spy.should.have.been.calledWith(testd1Path);\n      spy.should.have.been.calledWith(teste1Path);\n      spy.should.have.been.calledWith(testf1Path);\n      spy.should.have.been.calledWith(testg1Path);\n      spy.should.have.been.calledWith(testh1Path);\n      spy.should.have.been.calledWith(testi1Path);\n    });\n    it('should emit `addDir` event when directory was added', async () => {\n      const testDir = getFixturePath('subdir');\n      const spy = sinon.spy(function addDirSpy(){});\n      watcher.on(EV.ADD_DIR, spy);\n      spy.should.not.have.been.called;\n      await fs_mkdir(testDir, PERM_ARR);\n      await waitFor([spy]);\n      spy.should.have.been.calledOnce;\n      spy.should.have.been.calledWith(testDir);\n      expect(spy.args[0][1]).to.be.ok; // stats\n      rawSpy.should.have.been.called;\n    });\n    it('should emit `change` event when file was changed', async () => {\n      const testPath = getFixturePath('change.txt');\n      const spy = sinon.spy(function changeSpy(){});\n      watcher.on(EV.CHANGE, spy);\n      spy.should.not.have.been.called;\n      await write(testPath, dateNow());\n      await waitFor([spy]);\n      spy.should.have.been.calledWith(testPath);\n      expect(spy.args[0][1]).to.be.ok; // stats\n      rawSpy.should.have.been.called;\n      spy.should.have.been.calledOnce;\n    });\n    it('should emit `unlink` event when file was removed', async () => {\n      const testPath = getFixturePath('unlink.txt');\n      const spy = sinon.spy(function unlinkSpy(){});\n      watcher.on(EV.UNLINK, spy);\n      spy.should.not.have.been.called;\n      await fs_unlink(testPath);\n      await waitFor([spy]);\n      spy.should.have.been.calledWith(testPath);\n      expect(spy.args[0][1]).to.not.be.ok; // no stats\n      rawSpy.should.have.been.called;\n      spy.should.have.been.calledOnce;\n    });\n    it('should emit `unlinkDir` event when a directory was removed', async () => {\n      const testDir = getFixturePath('subdir');\n      const spy = sinon.spy(function unlinkDirSpy(){});\n\n      await fs_mkdir(testDir, PERM_ARR);\n      await delay(300);\n      watcher.on(EV.UNLINK_DIR, spy);\n\n      await fs_rmdir(testDir);\n      await waitFor([spy]);\n      spy.should.have.been.calledWith(testDir);\n      expect(spy.args[0][1]).to.not.be.ok; // no stats\n      rawSpy.should.have.been.called;\n      spy.should.have.been.calledOnce;\n    });\n    it('should emit two `unlinkDir` event when two nested directories were removed', async () => {\n      const testDir = getFixturePath('subdir');\n      const testDir2 = getFixturePath('subdir/subdir2');\n      const testDir3 = getFixturePath('subdir/subdir2/subdir3');\n      const spy = sinon.spy(function unlinkDirSpy(){});\n\n      await fs_mkdir(testDir, PERM_ARR);\n      await fs_mkdir(testDir2, PERM_ARR);\n      await fs_mkdir(testDir3, PERM_ARR);\n      await delay(300);\n\n      watcher.on(EV.UNLINK_DIR, spy);\n\n      await rimraf(testDir2);\n      await waitFor([[spy, 2]]);\n\n      spy.should.have.been.calledWith(testDir2);\n      spy.should.have.been.calledWith(testDir3);\n      expect(spy.args[0][1]).to.not.be.ok; // no stats\n      rawSpy.should.have.been.called;\n      spy.should.have.been.calledTwice;\n    });\n    it('should emit `unlink` and `add` events when a file is renamed', async () => {\n      const unlinkSpy = sinon.spy(function unlink(){});\n      const addSpy = sinon.spy(function add(){});\n      const testPath = getFixturePath('change.txt');\n      const newPath = getFixturePath('moved.txt');\n      watcher.on(EV.UNLINK, unlinkSpy).on(EV.ADD, addSpy);\n      unlinkSpy.should.not.have.been.called;\n      addSpy.should.not.have.been.called;\n\n      await delay();\n      await fs_rename(testPath, newPath);\n      await waitFor([unlinkSpy, addSpy]);\n      unlinkSpy.should.have.been.calledWith(testPath);\n      expect(unlinkSpy.args[0][1]).to.not.be.ok; // no stats\n      addSpy.should.have.been.calledOnce;\n      addSpy.should.have.been.calledWith(newPath);\n      expect(addSpy.args[0][1]).to.be.ok; // stats\n      rawSpy.should.have.been.called;\n      if (!macosFswatch) unlinkSpy.should.have.been.calledOnce;\n    });\n    it('should emit `add`, not `change`, when previously deleted file is re-added', async () => {\n      if (isWindows) {\n        console.warn('test skipped')\n        return true;\n      }\n      const unlinkSpy = sinon.spy(function unlink(){});\n      const addSpy = sinon.spy(function add(){});\n      const changeSpy = sinon.spy(function change(){});\n      const testPath = getFixturePath('add.txt');\n      watcher\n        .on(EV.UNLINK, unlinkSpy)\n        .on(EV.ADD, addSpy)\n        .on(EV.CHANGE, changeSpy);\n      await write(testPath, 'hello');\n      await waitFor([[addSpy.withArgs(testPath), 1]]);\n      unlinkSpy.should.not.have.been.called;\n      changeSpy.should.not.have.been.called;\n      await fs_unlink(testPath);\n      await waitFor([unlinkSpy.withArgs(testPath)]);\n      unlinkSpy.should.have.been.calledWith(testPath);\n\n      await delay(100);\n      await write(testPath, dateNow());\n      await waitFor([[addSpy.withArgs(testPath), 2]]);\n      addSpy.should.have.been.calledWith(testPath);\n      changeSpy.should.not.have.been.called;\n      expect(addSpy.callCount).to.equal(2);\n    });\n    it('should not emit `unlink` for previously moved files', async () => {\n      const unlinkSpy = sinon.spy(function unlink(){});\n      const testPath = getFixturePath('change.txt');\n      const newPath1 = getFixturePath('moved.txt');\n      const newPath2 = getFixturePath('moved-again.txt');\n      watcher.on(EV.UNLINK, unlinkSpy);\n      await fs_rename(testPath, newPath1);\n\n      await delay(300);\n      await fs_rename(newPath1, newPath2);\n      await waitFor([unlinkSpy.withArgs(newPath1)]);\n      unlinkSpy.withArgs(testPath).should.have.been.calledOnce;\n      unlinkSpy.withArgs(newPath1).should.have.been.calledOnce;\n      unlinkSpy.withArgs(newPath2).should.not.have.been.called;\n    });\n    it('should survive ENOENT for missing subdirectories', async () => {\n      const testDir = getFixturePath('notadir');\n      watcher.add(testDir);\n    });\n    it('should notice when a file appears in a new directory', async () => {\n      const testDir = getFixturePath('subdir');\n      const testPath = getFixturePath('subdir/add.txt');\n      const spy = sinon.spy(function addSpy(){});\n      watcher.on(EV.ADD, spy);\n      spy.should.not.have.been.called;\n      await fs_mkdir(testDir, PERM_ARR);\n      await write(testPath, dateNow());\n      await waitFor([spy]);\n      spy.should.have.been.calledOnce;\n      spy.should.have.been.calledWith(testPath);\n      expect(spy.args[0][1]).to.be.ok; // stats\n      rawSpy.should.have.been.called;\n    });\n    it('should watch removed and re-added directories', async () => {\n      const unlinkSpy = sinon.spy(function unlinkSpy(){});\n      const addSpy = sinon.spy(function addSpy(){});\n      const parentPath = getFixturePath('subdir2');\n      const subPath = getFixturePath('subdir2/subsub');\n      watcher.on(EV.UNLINK_DIR, unlinkSpy).on(EV.ADD_DIR, addSpy);\n      await fs_mkdir(parentPath, PERM_ARR);\n\n      await delay(win32Polling ? 900 : 300);\n      await fs_rmdir(parentPath);\n      await waitFor([unlinkSpy.withArgs(parentPath)]);\n      unlinkSpy.should.have.been.calledWith(parentPath);\n      await fs_mkdir(parentPath, PERM_ARR);\n\n      await delay(win32Polling ? 2200 : 1200);\n      await fs_mkdir(subPath, PERM_ARR);\n      await waitFor([[addSpy, 3]]);\n      addSpy.should.have.been.calledWith(parentPath);\n      addSpy.should.have.been.calledWith(subPath);\n    });\n    it('should emit `unlinkDir` and `add` when dir is replaced by file', async () => {\n      options.ignoreInitial = true;\n      const unlinkSpy = sinon.spy(function unlinkSpy(){});\n      const addSpy = sinon.spy(function addSpy(){});\n      const testPath = getFixturePath('dirFile');\n      await fs_mkdir(testPath, PERM_ARR);\n      await delay(300);\n      watcher.on(EV.UNLINK_DIR, unlinkSpy).on(EV.ADD, addSpy);\n\n      await fs_rmdir(testPath);\n      await waitFor([unlinkSpy]);\n\n      await write(testPath, 'file content');\n      await waitFor([addSpy]);\n\n      unlinkSpy.should.have.been.calledWith(testPath);\n      addSpy.should.have.been.calledWith(testPath);\n    });\n    it('should emit `unlink` and `addDir` when file is replaced by dir', async () => {\n      options.ignoreInitial = true;\n      const unlinkSpy = sinon.spy(function unlinkSpy(){});\n      const addSpy = sinon.spy(function addSpy(){});\n      const testPath = getFixturePath('fileDir');\n      await write(testPath, 'file content');\n      watcher.on(EV.UNLINK, unlinkSpy).on(EV.ADD_DIR, addSpy);\n\n      await delay(300);\n      await fs_unlink(testPath);\n      await delay(300);\n      await fs_mkdir(testPath, PERM_ARR);\n\n      await waitFor([addSpy, unlinkSpy]);\n      unlinkSpy.should.have.been.calledWith(testPath);\n      addSpy.should.have.been.calledWith(testPath);\n    });\n  });\n  describe('watch individual files', () => {\n    it('should emit `ready` when three files were added', async () => {\n      const readySpy = sinon.spy(function readySpy(){});\n      const watcher = chokidar_watch(currentDir, options).on(EV.READY, readySpy);\n      const path1 = getFixturePath('add1.txt');\n      const path2 = getFixturePath('add2.txt');\n      const path3 = getFixturePath('add3.txt');\n\n      watcher.add(path1);\n      watcher.add(path2);\n      watcher.add(path3);\n\n      await waitForWatcher(watcher);\n      // callCount is 1 on macOS, 4 on Ubuntu\n      readySpy.callCount.should.be.greaterThanOrEqual(1);\n    });\n    it('should detect changes', async () => {\n      const testPath = getFixturePath('change.txt');\n      const watcher = chokidar_watch(testPath, options);\n      const spy = await aspy(watcher, EV.CHANGE);\n      await write(testPath, dateNow());\n      await waitFor([spy]);\n      spy.should.have.always.been.calledWith(testPath);\n    });\n    it('should detect unlinks', async () => {\n      const testPath = getFixturePath('unlink.txt');\n      const watcher = chokidar_watch(testPath, options);\n      const spy = await aspy(watcher, EV.UNLINK);\n\n      await delay();\n      await fs_unlink(testPath);\n      await waitFor([spy]);\n      spy.should.have.been.calledWith(testPath);\n    });\n    it('should detect unlink and re-add', async () => {\n      options.ignoreInitial = true;\n      const unlinkSpy = sinon.spy(function unlinkSpy(){});\n      const addSpy = sinon.spy(function addSpy(){});\n      const testPath = getFixturePath('unlink.txt');\n      const watcher = chokidar_watch([testPath], options)\n        .on(EV.UNLINK, unlinkSpy)\n        .on(EV.ADD, addSpy);\n      await waitForWatcher(watcher);\n\n      await delay();\n      await fs_unlink(testPath);\n      await waitFor([unlinkSpy]);\n      unlinkSpy.should.have.been.calledWith(testPath);\n\n      await delay();\n      await write(testPath, 're-added');\n      await waitFor([addSpy]);\n      addSpy.should.have.been.calledWith(testPath);\n    });\n\n    it('should ignore unwatched siblings', async () => {\n      const testPath = getFixturePath('add.txt');\n      const siblingPath = getFixturePath('change.txt');\n      const watcher = chokidar_watch(testPath, options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      await delay();\n      await write(siblingPath, dateNow());\n      await write(testPath, dateNow());\n      await waitFor([spy]);\n      spy.should.have.always.been.calledWith(EV.ADD, testPath);\n    });\n\n    it('should detect safe-edit', async () => {\n      const testPath = getFixturePath('change.txt');\n      const safePath = getFixturePath('tmp.txt');\n      await write(testPath, dateNow());\n      const watcher = chokidar_watch(testPath, options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      await delay();\n      await write(safePath, dateNow());\n      await fs_rename(safePath, testPath);\n      await delay(300);\n      await write(safePath, dateNow());\n      await fs_rename(safePath, testPath);\n      await delay(300);\n      await write(safePath, dateNow());\n      await fs_rename(safePath, testPath);\n      await delay(300);\n      await waitFor([spy]);\n      spy.withArgs(EV.CHANGE, testPath).should.have.been.calledThrice;\n    });\n\n\n    // PR 682 is failing.\n    describe.skip('Skipping gh-682: should detect unlink', () => {\n      it('should detect unlink while watching a non-existent second file in another directory', async () => {\n        const testPath = getFixturePath('unlink.txt');\n        const otherDirPath = getFixturePath('other-dir');\n        const otherPath = getFixturePath('other-dir/other.txt');\n        fs.mkdirSync(otherDirPath, PERM_ARR);\n        const watcher = chokidar_watch([testPath, otherPath], options);\n        // intentionally for this test don't write fs.writeFileSync(otherPath, 'other');\n        const spy = await aspy(watcher, EV.UNLINK);\n\n        await delay();\n        await fs_unlink(testPath);\n        await waitFor([spy]);\n        spy.should.have.been.calledWith(testPath);\n      });\n      it('should detect unlink and re-add while watching a second file', async () => {\n        options.ignoreInitial = true;\n        const unlinkSpy = sinon.spy(function unlinkSpy(){});\n        const addSpy = sinon.spy(function addSpy(){});\n        const testPath = getFixturePath('unlink.txt');\n        const otherPath = getFixturePath('other.txt');\n        fs.writeFileSync(otherPath, 'other');\n        const watcher = chokidar_watch([testPath, otherPath], options)\n          .on(EV.UNLINK, unlinkSpy)\n          .on(EV.ADD, addSpy);\n        await waitForWatcher(watcher);\n\n        await delay();\n        await fs_unlink(testPath);\n        await waitFor([unlinkSpy]);\n\n        await delay();\n        unlinkSpy.should.have.been.calledWith(testPath);\n\n        await delay();\n        write(testPath, 're-added');\n        await waitFor([addSpy]);\n        addSpy.should.have.been.calledWith(testPath);\n      });\n      it('should detect unlink and re-add while watching a non-existent second file in another directory', async () => {\n        options.ignoreInitial = true;\n        const unlinkSpy = sinon.spy(function unlinkSpy(){});\n        const addSpy = sinon.spy(function addSpy(){});\n        const testPath = getFixturePath('unlink.txt');\n        const otherDirPath = getFixturePath('other-dir');\n        const otherPath = getFixturePath('other-dir/other.txt');\n        fs.mkdirSync(otherDirPath, PERM_ARR);\n        // intentionally for this test don't write fs.writeFileSync(otherPath, 'other');\n        const watcher = chokidar_watch([testPath, otherPath], options)\n          .on(EV.UNLINK, unlinkSpy)\n          .on(EV.ADD, addSpy);\n        await waitForWatcher(watcher);\n\n        await delay();\n        await fs_unlink(testPath);\n        await waitFor([unlinkSpy]);\n\n        await delay();\n        unlinkSpy.should.have.been.calledWith(testPath);\n\n        await delay();\n        await write(testPath, 're-added');\n        await waitFor([addSpy]);\n        addSpy.should.have.been.calledWith(testPath);\n      });\n      it('should detect unlink and re-add while watching a non-existent second file in the same directory', async () => {\n        options.ignoreInitial = true;\n        const unlinkSpy = sinon.spy(function unlinkSpy(){});\n        const addSpy = sinon.spy(function addSpy(){});\n        const testPath = getFixturePath('unlink.txt');\n        const otherPath = getFixturePath('other.txt');\n        // intentionally for this test don't write fs.writeFileSync(otherPath, 'other');\n        const watcher = chokidar_watch([testPath, otherPath], options)\n          .on(EV.UNLINK, unlinkSpy)\n          .on(EV.ADD, addSpy);\n        await waitForWatcher(watcher);\n\n        await delay();\n        await fs_unlink(testPath);\n        await waitFor([unlinkSpy]);\n\n        await delay();\n        unlinkSpy.should.have.been.calledWith(testPath);\n\n        await delay();\n        await write(testPath, 're-added');\n        await waitFor([addSpy]);\n        addSpy.should.have.been.calledWith(testPath);\n      });\n      it('should detect two unlinks and one re-add', async () => {\n        options.ignoreInitial = true;\n        const unlinkSpy = sinon.spy(function unlinkSpy(){});\n        const addSpy = sinon.spy(function addSpy(){});\n        const testPath = getFixturePath('unlink.txt');\n        const otherPath = getFixturePath('other.txt');\n        fs.writeFileSync(otherPath, 'other');\n        const watcher = chokidar_watch([testPath, otherPath], options)\n          .on(EV.UNLINK, unlinkSpy)\n          .on(EV.ADD, addSpy);\n        await waitForWatcher(watcher);\n\n        await delay();\n        await fs_unlink(otherPath);\n\n        await delay();\n        await fs_unlink(testPath);\n        await waitFor([[unlinkSpy, 2]]);\n\n        await delay();\n        unlinkSpy.should.have.been.calledWith(otherPath);\n        unlinkSpy.should.have.been.calledWith(testPath);\n\n        await delay();\n        await write(testPath, 're-added');\n        await waitFor([addSpy]);\n        addSpy.should.have.been.calledWith(testPath);\n      });\n      it('should detect unlink and re-add while watching a second file and a non-existent third file', async () => {\n        options.ignoreInitial = true;\n        const unlinkSpy = sinon.spy(function unlinkSpy(){});\n        const addSpy = sinon.spy(function addSpy(){});\n        const testPath = getFixturePath('unlink.txt');\n        const otherPath = getFixturePath('other.txt');\n        const other2Path = getFixturePath('other2.txt');\n        fs.writeFileSync(otherPath, 'other');\n        // intentionally for this test don't write fs.writeFileSync(other2Path, 'other2');\n        const watcher = chokidar_watch([testPath, otherPath, other2Path], options)\n          .on(EV.UNLINK, unlinkSpy)\n          .on(EV.ADD, addSpy);\n        await waitForWatcher(watcher);\n        await delay();\n        await fs_unlink(testPath);\n\n        await waitFor([unlinkSpy]);\n        await delay();\n        unlinkSpy.should.have.been.calledWith(testPath);\n\n        await delay();\n        await write(testPath, 're-added');\n        await waitFor([addSpy]);\n        addSpy.should.have.been.calledWith(testPath);\n      });\n    });\n  });\n  describe('renamed directory', () => {\n    it('should emit `add` for a file in a renamed directory', async () => {\n      options.ignoreInitial = true;\n      const testDir = getFixturePath('subdir');\n      const testPath = getFixturePath('subdir/add.txt');\n      const renamedDir = getFixturePath('subdir-renamed');\n      const expectedPath = sysPath.join(renamedDir, 'add.txt');\n      await fs_mkdir(testDir, PERM_ARR);\n      await write(testPath, dateNow());\n      const watcher = chokidar_watch(currentDir, options);\n      const spy = await aspy(watcher, EV.ADD);\n\n      await delay(1000);\n      await fs_rename(testDir, renamedDir);\n      await waitFor([spy.withArgs(expectedPath)]);\n      spy.should.have.been.calledWith(expectedPath);\n    });\n  });\n  describe('watch non-existent paths', () => {\n    it('should watch non-existent file and detect add', async () => {\n      const testPath = getFixturePath('add.txt');\n      const watcher = chokidar_watch(testPath, options);\n      const spy = await aspy(watcher, EV.ADD);\n\n      await delay();\n      await write(testPath, dateNow());\n      await waitFor([spy]);\n      spy.should.have.been.calledWith(testPath);\n    });\n    it('should watch non-existent dir and detect addDir/add', async () => {\n      const testDir = getFixturePath('subdir');\n      const testPath = getFixturePath('subdir/add.txt');\n      const watcher = chokidar_watch(testDir, options);\n      const spy = await aspy(watcher, EV.ALL);\n      spy.should.not.have.been.called;\n\n      await delay();\n      await fs_mkdir(testDir, PERM_ARR);\n      await waitFor([spy.withArgs(EV.ADD_DIR)]);\n      await write(testPath, 'hello');\n      await waitFor([spy.withArgs(EV.ADD)]);\n      spy.should.have.been.calledWith(EV.ADD_DIR, testDir);\n      spy.should.have.been.calledWith(EV.ADD, testPath);\n    });\n  });\n  describe('not watch glob patterns', () => {\n    it('should not confuse glob-like filenames with globs', async () => {\n      const filePath = getFixturePath('nota[glob].txt');\n      await write(filePath, 'b');\n      await delay();\n      const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n      spy.should.have.been.calledWith(EV.ADD, filePath);\n\n      await delay();\n      await write(filePath, dateNow());\n      await waitFor([spy.withArgs(EV.CHANGE, filePath)]);\n      spy.should.have.been.calledWith(EV.CHANGE, filePath);\n    });\n    it('should treat glob-like directory names as literal directory names when globbing is disabled', async () => {\n      options.disableGlobbing = true;\n      const filePath = getFixturePath('nota[glob]/a.txt');\n      const watchPath = getFixturePath('nota[glob]');\n      const testDir = getFixturePath('nota[glob]');\n      const matchingDir = getFixturePath('notag');\n      const matchingFile = getFixturePath('notag/b.txt');\n      const matchingFile2 = getFixturePath('notal');\n      fs.mkdirSync(testDir, PERM_ARR);\n      fs.writeFileSync(filePath, 'b');\n      fs.mkdirSync(matchingDir, PERM_ARR);\n      fs.writeFileSync(matchingFile, 'c');\n      fs.writeFileSync(matchingFile2, 'd');\n      const watcher = chokidar_watch(watchPath, options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      spy.should.have.been.calledWith(EV.ADD, filePath);\n      spy.should.not.have.been.calledWith(EV.ADD_DIR, matchingDir);\n      spy.should.not.have.been.calledWith(EV.ADD, matchingFile);\n      spy.should.not.have.been.calledWith(EV.ADD, matchingFile2);\n      await delay();\n      await write(filePath, dateNow());\n\n      await waitFor([spy.withArgs(EV.CHANGE, filePath)]);\n      spy.should.have.been.calledWith(EV.CHANGE, filePath);\n    });\n    it('should treat glob-like filenames as literal filenames', async () => {\n      options.disableGlobbing = true;\n      const filePath = getFixturePath('nota[glob]');\n      // This isn't using getGlobPath because it isn't treated as a glob\n      const watchPath = getFixturePath('nota[glob]');\n      const matchingDir = getFixturePath('notag');\n      const matchingFile = getFixturePath('notag/a.txt');\n      const matchingFile2 = getFixturePath('notal');\n      fs.writeFileSync(filePath, 'b');\n      fs.mkdirSync(matchingDir, PERM_ARR);\n      fs.writeFileSync(matchingFile, 'c');\n      fs.writeFileSync(matchingFile2, 'd');\n      const watcher = chokidar_watch(watchPath, options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      spy.should.have.been.calledWith(EV.ADD, filePath);\n      spy.should.not.have.been.calledWith(EV.ADD_DIR, matchingDir);\n      spy.should.not.have.been.calledWith(EV.ADD, matchingFile);\n      spy.should.not.have.been.calledWith(EV.ADD, matchingFile2);\n      await delay();\n      await write(filePath, dateNow());\n\n      await waitFor([spy.withArgs(EV.CHANGE, filePath)]);\n      spy.should.have.been.calledWith(EV.CHANGE, filePath);\n    });\n  });\n  describe('watch symlinks', () => {\n    if (isWindows) return true;\n    let linkedDir;\n    beforeEach(async () => {\n      linkedDir = sysPath.resolve(currentDir, '..', `${subdirId}-link`);\n      await fs_symlink(currentDir, linkedDir, isWindows ? 'dir' : null);\n      await fs_mkdir(getFixturePath('subdir'), PERM_ARR);\n      await write(getFixturePath('subdir/add.txt'), 'b');\n      return true;\n    });\n    afterEach(async () => {\n      await fs_unlink(linkedDir);\n      return true;\n    });\n\n    it('should watch symlinked dirs', async () => {\n      const dirSpy = sinon.spy(function dirSpy(){});\n      const addSpy = sinon.spy(function addSpy(){});\n      const watcher = chokidar_watch(linkedDir, options)\n        .on(EV.ADD_DIR, dirSpy)\n        .on(EV.ADD, addSpy);\n      await waitForWatcher(watcher);\n\n      dirSpy.should.have.been.calledWith(linkedDir);\n      addSpy.should.have.been.calledWith(sysPath.join(linkedDir, 'change.txt'));\n      addSpy.should.have.been.calledWith(sysPath.join(linkedDir, 'unlink.txt'));\n    });\n    it('should watch symlinked files', async () => {\n      const changePath = getFixturePath('change.txt');\n      const linkPath = getFixturePath('link.txt');\n      fs.symlinkSync(changePath, linkPath);\n      const watcher = chokidar_watch(linkPath, options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      await write(changePath, dateNow());\n      await waitFor([spy.withArgs(EV.CHANGE)]);\n      spy.should.have.been.calledWith(EV.ADD, linkPath);\n      spy.should.have.been.calledWith(EV.CHANGE, linkPath);\n    });\n    it('should follow symlinked files within a normal dir', async () => {\n      const changePath = getFixturePath('change.txt');\n      const linkPath = getFixturePath('subdir/link.txt');\n      fs.symlinkSync(changePath, linkPath);\n      const watcher = chokidar_watch(getFixturePath('subdir'), options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      await write(changePath, dateNow());\n      await waitFor([spy.withArgs(EV.CHANGE, linkPath)]);\n      spy.should.have.been.calledWith(EV.ADD, linkPath);\n      spy.should.have.been.calledWith(EV.CHANGE, linkPath);\n    });\n    it('should watch paths with a symlinked parent', async () => {\n      const testDir = sysPath.join(linkedDir, 'subdir');\n      const testFile = sysPath.join(testDir, 'add.txt');\n      const watcher = chokidar_watch(testDir, options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      spy.should.have.been.calledWith(EV.ADD_DIR, testDir);\n      spy.should.have.been.calledWith(EV.ADD, testFile);\n      await write(getFixturePath('subdir/add.txt'), dateNow());\n      await waitFor([spy.withArgs(EV.CHANGE)]);\n      spy.should.have.been.calledWith(EV.CHANGE, testFile);\n    });\n    it('should not recurse indefinitely on circular symlinks', async () => {\n      await fs_symlink(currentDir, getFixturePath('subdir/circular'), isWindows ? 'dir' : null);\n      return new Promise((resolve, reject) => {\n        const watcher = chokidar_watch(currentDir, options);\n        watcher.on(EV.ERROR, resolve());\n        watcher.on(EV.READY, reject('The watcher becomes ready, although he watches a circular symlink.'));\n      })\n    });\n    it('should recognize changes following symlinked dirs', async () => {\n      const linkedFilePath = sysPath.join(linkedDir, 'change.txt');\n      const watcher = chokidar_watch(linkedDir, options);\n      const spy = await aspy(watcher, EV.CHANGE);\n      const wa = spy.withArgs(linkedFilePath);\n      await write(getFixturePath('change.txt'), dateNow());\n      await waitFor([wa]);\n      spy.should.have.been.calledWith(linkedFilePath);\n    });\n    it('should follow newly created symlinks', async () => {\n      options.ignoreInitial = true;\n      const watcher = chokidar_watch(currentDir, options);\n      const spy = await aspy(watcher, EV.ALL);\n      await delay();\n      await fs_symlink(getFixturePath('subdir'), getFixturePath('link'), isWindows ? 'dir' : null);\n      await waitFor([\n        spy.withArgs(EV.ADD, getFixturePath('link/add.txt')),\n        spy.withArgs(EV.ADD_DIR, getFixturePath('link'))\n      ]);\n      spy.should.have.been.calledWith(EV.ADD_DIR, getFixturePath('link'));\n      spy.should.have.been.calledWith(EV.ADD, getFixturePath('link/add.txt'));\n    });\n    it('should watch symlinks as files when followSymlinks:false', async () => {\n      options.followSymlinks = false;\n      const watcher = chokidar_watch(linkedDir, options);\n      const spy = await aspy(watcher, EV.ALL);\n      spy.should.not.have.been.calledWith(EV.ADD_DIR);\n      spy.should.have.been.calledWith(EV.ADD, linkedDir);\n      spy.should.have.been.calledOnce;\n    });\n    it('should survive ENOENT for missing symlinks when followSymlinks:false', async () => {\n      options.followSymlinks = false;\n      const targetDir = getFixturePath('subdir/nonexistent');\n      await fs_mkdir(targetDir);\n      await fs_symlink(targetDir, getFixturePath('subdir/broken'), isWindows ? 'dir' : null);\n      await fs_rmdir(targetDir);\n      await delay();\n\n      const watcher = chokidar_watch(getFixturePath('subdir'), options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      spy.should.have.been.calledTwice;\n      spy.should.have.been.calledWith(EV.ADD_DIR, getFixturePath('subdir'));\n      spy.should.have.been.calledWith(EV.ADD, getFixturePath('subdir/add.txt'));\n    });\n    it('should watch symlinks within a watched dir as files when followSymlinks:false', async () => {\n      options.followSymlinks = false;\n      // Create symlink in linkPath\n      const linkPath = getFixturePath('link');\n      fs.symlinkSync(getFixturePath('subdir'), linkPath);\n      const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n      await delay(300);\n      setTimeout(() => {\n        fs.writeFileSync(getFixturePath('subdir/add.txt'), dateNow());\n        fs.unlinkSync(linkPath);\n        fs.symlinkSync(getFixturePath('subdir/add.txt'), linkPath);\n      }, options.usePolling ? 1200 : 300);\n\n      await delay(300);\n      await waitFor([spy.withArgs(EV.CHANGE, linkPath)]);\n      spy.should.not.have.been.calledWith(EV.ADD_DIR, linkPath);\n      spy.should.not.have.been.calledWith(EV.ADD, getFixturePath('link/add.txt'));\n      spy.should.have.been.calledWith(EV.ADD, linkPath);\n      spy.should.have.been.calledWith(EV.CHANGE, linkPath);\n    });\n    it('should not reuse watcher when following a symlink to elsewhere', async () => {\n      const linkedPath = getFixturePath('outside');\n      const linkedFilePath = sysPath.join(linkedPath, 'text.txt');\n      const linkPath = getFixturePath('subdir/subsub');\n      fs.mkdirSync(linkedPath, PERM_ARR);\n      fs.writeFileSync(linkedFilePath, 'b');\n      fs.symlinkSync(linkedPath, linkPath);\n      const watcher2 = chokidar_watch(getFixturePath('subdir'), options);\n      await waitForWatcher(watcher2);\n\n      await delay(options.usePolling ? 900 : undefined);\n      const watchedPath = getFixturePath('subdir/subsub/text.txt');\n      const watcher = chokidar_watch(watchedPath, options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      await delay();\n      await write(linkedFilePath, dateNow());\n      await waitFor([spy.withArgs(EV.CHANGE)]);\n      spy.should.have.been.calledWith(EV.CHANGE, watchedPath);\n    });\n    it('should emit ready event even when broken symlinks are encountered', async () => {\n      const targetDir = getFixturePath('subdir/nonexistent');\n      await fs_mkdir(targetDir);\n      await fs_symlink(targetDir, getFixturePath('subdir/broken'), isWindows ? 'dir' : null);\n      await fs_rmdir(targetDir);\n      const readySpy = sinon.spy(function readySpy(){});\n      const watcher = chokidar_watch(getFixturePath('subdir'), options)\n          .on(EV.READY, readySpy);\n      await waitForWatcher(watcher);\n      readySpy.should.have.been.calledOnce;\n    });\n  });\n  describe('watch arrays of paths/globs', () => {\n    it('should watch all paths in an array', async () => {\n      const testPath = getFixturePath('change.txt');\n      const testDir = getFixturePath('subdir');\n      fs.mkdirSync(testDir);\n      const watcher = chokidar_watch([testDir, testPath], options);\n      const spy = await aspy(watcher, EV.ALL);\n      spy.should.have.been.calledWith(EV.ADD, testPath);\n      spy.should.have.been.calledWith(EV.ADD_DIR, testDir);\n      spy.should.not.have.been.calledWith(EV.ADD, getFixturePath('unlink.txt'));\n      await write(testPath, dateNow());\n      await waitFor([spy.withArgs(EV.CHANGE)]);\n      spy.should.have.been.calledWith(EV.CHANGE, testPath);\n    });\n    it('should accommodate nested arrays in input', async () => {\n      const testPath = getFixturePath('change.txt');\n      const testDir = getFixturePath('subdir');\n      await fs_mkdir(testDir);\n      const watcher = chokidar_watch([[testDir], [testPath]], options);\n      const spy = await aspy(watcher, EV.ALL);\n      spy.should.have.been.calledWith(EV.ADD, testPath);\n      spy.should.have.been.calledWith(EV.ADD_DIR, testDir);\n      spy.should.not.have.been.calledWith(EV.ADD, getFixturePath('unlink.txt'));\n      await write(testPath, dateNow());\n      await waitFor([spy.withArgs(EV.CHANGE)]);\n      spy.should.have.been.calledWith(EV.CHANGE, testPath);\n    });\n    it('should throw if provided any non-string paths', () => {\n      expect(chokidar_watch.bind(null, [[currentDir], /notastring/], options))\n        .to.throw(TypeError, /non-string/i);\n    });\n  });\n  describe('watch options', () => {\n    describe('ignoreInitial', () => {\n      describe('false', () => {\n        beforeEach(() => { options.ignoreInitial = false; });\n        it('should emit `add` events for preexisting files', async () => {\n          const watcher = chokidar_watch(currentDir, options);\n          const spy = await aspy(watcher, EV.ADD);\n          spy.should.have.been.calledTwice;\n        });\n        it('should emit `addDir` event for watched dir', async () => {\n          const watcher = chokidar_watch(currentDir, options);\n          const spy = await aspy(watcher, EV.ADD_DIR);\n          spy.should.have.been.calledOnce;\n          spy.should.have.been.calledWith(currentDir);\n        });\n        it('should emit `addDir` events for preexisting dirs', async () => {\n          await fs_mkdir(getFixturePath('subdir'), PERM_ARR);\n          await fs_mkdir(getFixturePath('subdir/subsub'), PERM_ARR);\n          const watcher = chokidar_watch(currentDir, options);\n          const spy = await aspy(watcher, EV.ADD_DIR);\n          spy.should.have.been.calledWith(currentDir);\n          spy.should.have.been.calledWith(getFixturePath('subdir'));\n          spy.should.have.been.calledWith(getFixturePath('subdir/subsub'));\n          spy.should.have.been.calledThrice;\n        });\n      });\n      describe('true', () => {\n        beforeEach(() => { options.ignoreInitial = true; });\n        it('should ignore initial add events', async () => {\n          const watcher = chokidar_watch(currentDir, options);\n          const spy = await aspy(watcher, EV.ADD);\n          await delay();\n          spy.should.not.have.been.called;\n        });\n        it('should ignore add events on a subsequent .add()', async () => {\n          const watcher = chokidar_watch(getFixturePath('subdir'), options);\n          const spy = await aspy(watcher, EV.ADD);\n          watcher.add(currentDir);\n          await delay(1000);\n          spy.should.not.have.been.called;\n        });\n        it('should notice when a file appears in an empty directory', async () => {\n          const testDir = getFixturePath('subdir');\n          const testPath = getFixturePath('subdir/add.txt');\n          const spy = await aspy(chokidar_watch(currentDir, options), EV.ADD);\n          spy.should.not.have.been.called;\n          await fs_mkdir(testDir, PERM_ARR);\n          await write(testPath, dateNow());\n          await waitFor([spy]);\n          spy.should.have.been.calledOnce;\n          spy.should.have.been.calledWith(testPath);\n        });\n        it('should emit a change on a preexisting file as a change', async () => {\n          const testPath = getFixturePath('change.txt');\n          const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n          spy.should.not.have.been.called;\n          await write(testPath, dateNow());\n          await waitFor([spy.withArgs(EV.CHANGE, testPath)]);\n          spy.should.have.been.calledWith(EV.CHANGE, testPath);\n          spy.should.not.have.been.calledWith(EV.ADD);\n        });\n        it('should not emit for preexisting dirs when depth is 0', async () => {\n          options.depth = 0;\n          const testPath = getFixturePath('add.txt');\n          await fs_mkdir(getFixturePath('subdir'), PERM_ARR);\n\n          await delay(200);\n          const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n          await write(testPath, dateNow());\n          await waitFor([spy]);\n\n          await delay(200);\n          spy.should.have.been.calledWith(EV.ADD, testPath);\n          spy.should.not.have.been.calledWith(EV.ADD_DIR);\n        });\n      });\n    });\n    describe('ignored', () => {\n      it('should check ignore after stating', async () => {\n        options.ignored = (path, stats) => {\n          if (upath.normalizeSafe(path) === upath.normalizeSafe(testDir) || !stats) return false;\n          return stats.isDirectory();\n        };\n        const testDir = getFixturePath('subdir');\n        fs.mkdirSync(testDir, PERM_ARR);\n        fs.writeFileSync(sysPath.join(testDir, 'add.txt'), '');\n        fs.mkdirSync(sysPath.join(testDir, 'subsub'), PERM_ARR);\n        fs.writeFileSync(sysPath.join(testDir, 'subsub', 'ab.txt'), '');\n        const watcher = chokidar_watch(testDir, options);\n        const spy = await aspy(watcher, EV.ADD);\n        spy.should.have.been.calledOnce;\n        spy.should.have.been.calledWith(sysPath.join(testDir, 'add.txt'));\n      });\n      it('should not choke on an ignored watch path', async () => {\n        options.ignored = () => { return true; };\n        await waitForWatcher(chokidar_watch(currentDir, options));\n      });\n      it('should ignore the contents of ignored dirs', async () => {\n        const testDir = getFixturePath('subdir');\n        const testFile = sysPath.join(testDir, 'add.txt');\n        options.ignored = testDir;\n        fs.mkdirSync(testDir, PERM_ARR);\n        fs.writeFileSync(testFile, 'b');\n        const watcher = chokidar_watch(currentDir, options);\n        const spy = await aspy(watcher, EV.ALL);\n\n        await delay();\n        await write(testFile, dateNow());\n\n        await delay(300);\n        spy.should.not.have.been.calledWith(EV.ADD_DIR, testDir);\n        spy.should.not.have.been.calledWith(EV.ADD, testFile);\n        spy.should.not.have.been.calledWith(EV.CHANGE, testFile);\n      });\n      it('should allow regex/fn ignores', async () => {\n        options.cwd = currentDir;\n        options.ignored = /add/;\n\n        fs.writeFileSync(getFixturePath('add.txt'), 'b');\n        const watcher = chokidar_watch(currentDir, options);\n        const spy = await aspy(watcher, EV.ALL);\n\n        await delay();\n        await write(getFixturePath('add.txt'), dateNow());\n        await write(getFixturePath('change.txt'), dateNow());\n\n        await waitFor([spy.withArgs(EV.CHANGE, 'change.txt')]);\n        spy.should.not.have.been.calledWith(EV.ADD, 'add.txt');\n        spy.should.not.have.been.calledWith(EV.CHANGE, 'add.txt');\n        spy.should.have.been.calledWith(EV.ADD, 'change.txt');\n        spy.should.have.been.calledWith(EV.CHANGE, 'change.txt');\n      });\n    });\n    describe('depth', () => {\n      beforeEach(async () => {\n        await fs_mkdir(getFixturePath('subdir'), PERM_ARR);\n        await write(getFixturePath('subdir/add.txt'), 'b');\n        await delay();\n        await fs_mkdir(getFixturePath('subdir/subsub'), PERM_ARR);\n        await write(getFixturePath('subdir/subsub/ab.txt'), 'b');\n        await delay();\n      });\n      it('should not recurse if depth is 0', async () => {\n        options.depth = 0;\n        const watcher = chokidar_watch(currentDir, options);\n        const spy = await aspy(watcher, EV.ALL);\n        await write(getFixturePath('subdir/add.txt'), dateNow());\n        await waitFor([[spy, 4]]);\n        spy.should.have.been.calledWith(EV.ADD_DIR, currentDir);\n        spy.should.have.been.calledWith(EV.ADD_DIR, getFixturePath('subdir'));\n        spy.should.have.been.calledWith(EV.ADD, getFixturePath('change.txt'));\n        spy.should.have.been.calledWith(EV.ADD, getFixturePath('unlink.txt'));\n        spy.should.not.have.been.calledWith(EV.CHANGE);\n        if (!macosFswatch) spy.callCount.should.equal(4);\n      });\n      it('should recurse to specified depth', async () => {\n        options.depth = 1;\n        const addPath = getFixturePath('subdir/add.txt');\n        const changePath = getFixturePath('change.txt');\n        const ignoredPath = getFixturePath('subdir/subsub/ab.txt');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await delay();\n        await write(getFixturePath('change.txt'), dateNow());\n        await write(addPath, dateNow());\n        await write(ignoredPath, dateNow());\n        await waitFor([spy.withArgs(EV.CHANGE, addPath), spy.withArgs(EV.CHANGE, changePath)]);\n        spy.should.have.been.calledWith(EV.ADD_DIR, getFixturePath('subdir/subsub'));\n        spy.should.have.been.calledWith(EV.CHANGE, changePath);\n        spy.should.have.been.calledWith(EV.CHANGE, addPath);\n        spy.should.not.have.been.calledWith(EV.ADD, ignoredPath);\n        spy.should.not.have.been.calledWith(EV.CHANGE, ignoredPath);\n        if (!macosFswatch) spy.callCount.should.equal(8);\n      });\n      it('should respect depth setting when following symlinks', async () => {\n        if (isWindows) return true; // skip on windows\n        options.depth = 1;\n        await fs_symlink(getFixturePath('subdir'), getFixturePath('link'), isWindows ? 'dir' : null);\n        await delay();\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        spy.should.have.been.calledWith(EV.ADD_DIR, getFixturePath('link'));\n        spy.should.have.been.calledWith(EV.ADD_DIR, getFixturePath('link/subsub'));\n        spy.should.have.been.calledWith(EV.ADD, getFixturePath('link/add.txt'));\n        spy.should.not.have.been.calledWith(EV.ADD, getFixturePath('link/subsub/ab.txt'));\n      });\n      it('should respect depth setting when following a new symlink', async () => {\n        if (isWindows) return true; // skip on windows\n        options.depth = 1;\n        options.ignoreInitial = true;\n        const linkPath = getFixturePath('link');\n        const dirPath = getFixturePath('link/subsub');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await fs_symlink(getFixturePath('subdir'), linkPath, isWindows ? 'dir' : null);\n        await waitFor([[spy, 3], spy.withArgs(EV.ADD_DIR, dirPath)]);\n        spy.should.have.been.calledWith(EV.ADD_DIR, linkPath);\n        spy.should.have.been.calledWith(EV.ADD_DIR, dirPath);\n        spy.should.have.been.calledWith(EV.ADD, getFixturePath('link/add.txt'));\n        spy.should.have.been.calledThrice;\n      });\n      it('should correctly handle dir events when depth is 0', async () => {\n        options.depth = 0;\n        const subdir2 = getFixturePath('subdir2');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        const addSpy = spy.withArgs(EV.ADD_DIR);\n        const unlinkSpy = spy.withArgs(EV.UNLINK_DIR);\n        spy.should.have.been.calledWith(EV.ADD_DIR, currentDir);\n        spy.should.have.been.calledWith(EV.ADD_DIR, getFixturePath('subdir'));\n        await fs_mkdir(subdir2, PERM_ARR);\n        await waitFor([[addSpy, 3]]);\n        addSpy.should.have.been.calledThrice;\n\n        await fs_rmdir(subdir2);\n        await waitFor([unlinkSpy]);\n        await delay();\n        unlinkSpy.should.have.been.calledWith(EV.UNLINK_DIR, subdir2);\n        unlinkSpy.should.have.been.calledOnce;\n      });\n    });\n    describe('atomic', () => {\n      beforeEach(() => {\n        options.atomic = true;\n        options.ignoreInitial = true;\n      });\n      it('should ignore vim/emacs/Sublime swapfiles', async () => {\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await write(getFixturePath('.change.txt.swp'), 'a'); // vim\n        await write(getFixturePath('add.txt~'), 'a'); // vim/emacs\n        await write(getFixturePath('.subl5f4.tmp'), 'a'); // sublime\n        await delay(300);\n        await write(getFixturePath('.change.txt.swp'), 'c');\n        await write(getFixturePath('add.txt~'), 'c');\n        await write(getFixturePath('.subl5f4.tmp'), 'c');\n        await delay(300);\n        await fs_unlink(getFixturePath('.change.txt.swp'));\n        await fs_unlink(getFixturePath('add.txt~'));\n        await fs_unlink(getFixturePath('.subl5f4.tmp'));\n        await delay(300);\n        spy.should.not.have.been.called;\n      });\n      it('should ignore stale tilde files', async () => {\n        options.ignoreInitial = false;\n        await write(getFixturePath('old.txt~'), 'a');\n        await delay();\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        spy.should.not.have.been.calledWith(getFixturePath('old.txt'));\n        spy.should.not.have.been.calledWith(getFixturePath('old.txt~'));\n      });\n    });\n    describe('cwd', () => {\n      it('should emit relative paths based on cwd', async () => {\n        options.cwd = currentDir;\n        const watcher = chokidar_watch('.', options);\n        const spy = await aspy(watcher, EV.ALL);\n        await fs_unlink(getFixturePath('unlink.txt'));\n        await write(getFixturePath('change.txt'), dateNow());\n        await waitFor([spy.withArgs(EV.UNLINK)]);\n        spy.should.have.been.calledWith(EV.ADD, 'change.txt');\n        spy.should.have.been.calledWith(EV.ADD, 'unlink.txt');\n        spy.should.have.been.calledWith(EV.CHANGE, 'change.txt');\n        spy.should.have.been.calledWith(EV.UNLINK, 'unlink.txt');\n      });\n      it('should emit `addDir` with alwaysStat for renamed directory', async () => {\n        options.cwd = currentDir;\n        options.alwaysStat = true;\n        options.ignoreInitial = true;\n        const spy = sinon.spy();\n        const testDir = getFixturePath('subdir');\n        const renamedDir = getFixturePath('subdir-renamed');\n\n        await fs_mkdir(testDir, PERM_ARR);\n        const watcher = chokidar_watch('.', options);\n\n        await new Promise((resolve) => {\n          setTimeout(() => {\n            watcher.on(EV.ADD_DIR, spy);\n            fs_rename(testDir, renamedDir);\n            resolve();\n          }, 1000);\n        });\n\n        await waitFor([spy]);\n        spy.should.have.been.calledOnce;\n        spy.should.have.been.calledWith('subdir-renamed');\n        expect(spy.args[0][1]).to.be.ok; // stats\n      });\n      it('should allow separate watchers to have different cwds', async () => {\n        options.cwd = currentDir;\n        const options2 = {};\n        Object.keys(options).forEach((key) => {\n          options2[key] = options[key];\n        });\n        options2.cwd = getFixturePath('subdir');\n        const watcher = chokidar_watch(getGlobPath('.'), options);\n        const watcherEvents = waitForEvents(watcher, 3);\n        const spy1 = await aspy(watcher, EV.ALL);\n\n        await delay();\n        const watcher2 = chokidar_watch(currentDir, options2);\n        const watcher2Events = waitForEvents(watcher2, 5);\n        const spy2 = await aspy(watcher2, EV.ALL);\n\n        await fs_unlink(getFixturePath('unlink.txt'));\n        await write(getFixturePath('change.txt'), dateNow());\n        await Promise.all([watcherEvents, watcher2Events]);\n        spy1.should.have.been.calledWith(EV.CHANGE, 'change.txt');\n        spy1.should.have.been.calledWith(EV.UNLINK, 'unlink.txt');\n        spy2.should.have.been.calledWith(EV.ADD, sysPath.join('..', 'change.txt'));\n        spy2.should.have.been.calledWith(EV.ADD, sysPath.join('..', 'unlink.txt'));\n        spy2.should.have.been.calledWith(EV.CHANGE, sysPath.join('..', 'change.txt'));\n        spy2.should.have.been.calledWith(EV.UNLINK, sysPath.join('..', 'unlink.txt'));\n      });\n      it('should ignore files even with cwd', async () => {\n        options.cwd = currentDir;\n        options.ignored = ['ignored-option.txt', 'ignored.txt'];\n        const files = [\n          '.'\n        ];\n        fs.writeFileSync(getFixturePath('change.txt'), 'hello');\n        fs.writeFileSync(getFixturePath('ignored.txt'), 'ignored');\n        fs.writeFileSync(getFixturePath('ignored-option.txt'), 'ignored option');\n        const watcher = chokidar_watch(files, options);\n\n        const spy = await aspy(watcher, EV.ALL);\n        fs.writeFileSync(getFixturePath('ignored.txt'), dateNow());\n        fs.writeFileSync(getFixturePath('ignored-option.txt'), dateNow());\n        await fs_unlink(getFixturePath('ignored.txt'));\n        await fs_unlink(getFixturePath('ignored-option.txt'));\n        await delay();\n        await write(getFixturePath('change.txt'), EV.CHANGE);\n        await waitFor([spy.withArgs(EV.CHANGE, 'change.txt')]);\n        spy.should.have.been.calledWith(EV.ADD, 'change.txt');\n        spy.should.not.have.been.calledWith(EV.ADD, 'ignored.txt');\n        spy.should.not.have.been.calledWith(EV.ADD, 'ignored-option.txt');\n        spy.should.not.have.been.calledWith(EV.CHANGE, 'ignored.txt');\n        spy.should.not.have.been.calledWith(EV.CHANGE, 'ignored-option.txt');\n        spy.should.not.have.been.calledWith(EV.UNLINK, 'ignored.txt');\n        spy.should.not.have.been.calledWith(EV.UNLINK, 'ignored-option.txt');\n        spy.should.have.been.calledWith(EV.CHANGE, 'change.txt');\n      });\n    });\n    describe('ignorePermissionErrors', () => {\n      let filePath;\n      beforeEach(async () => {\n        filePath = getFixturePath('add.txt');\n        await write(filePath, 'b', {mode: 128});\n        await delay();\n      });\n      describe('false', () => {\n        beforeEach(() => {\n          options.ignorePermissionErrors = false;\n          // chokidar_watch();\n        });\n        it('should not watch files without read permissions', async () => {\n          if (isWindows) return true;\n          const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n          spy.should.not.have.been.calledWith(EV.ADD, filePath);\n          await write(filePath, dateNow());\n\n          await delay(200);\n          spy.should.not.have.been.calledWith(EV.CHANGE, filePath);\n        });\n      });\n      describe('true', () => {\n        beforeEach(() => { options.ignorePermissionErrors = true; });\n        it('should watch unreadable files if possible', async () => {\n          const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n          spy.should.have.been.calledWith(EV.ADD, filePath);\n        });\n        it('should not choke on non-existent files', async () => {\n          const watcher = chokidar_watch(getFixturePath('nope.txt'), options);\n          await waitForWatcher(watcher);\n        });\n      });\n    });\n    describe('awaitWriteFinish', () => {\n      beforeEach(() => {\n        options.awaitWriteFinish = {stabilityThreshold: 500};\n        options.ignoreInitial = true;\n      });\n      it('should use default options if none given', () => {\n        options.awaitWriteFinish = true;\n        const watcher = chokidar_watch(currentDir, options);\n        expect(watcher.options.awaitWriteFinish.pollInterval).to.equal(100);\n        expect(watcher.options.awaitWriteFinish.stabilityThreshold).to.equal(2000);\n      });\n      it('should not emit add event before a file is fully written', async () => {\n        const testPath = getFixturePath('add.txt');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await write(testPath, 'hello');\n        await delay(200);\n        spy.should.not.have.been.calledWith(EV.ADD);\n      });\n      it('should wait for the file to be fully written before emitting the add event', async () => {\n        const testPath = getFixturePath('add.txt');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await write(testPath, 'hello');\n\n        await delay(300);\n        spy.should.not.have.been.called;\n        await waitFor([spy]);\n        spy.should.have.been.calledWith(EV.ADD, testPath);\n      });\n      it('should emit with the final stats', async () => {\n        const testPath = getFixturePath('add.txt');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await write(testPath, 'hello ');\n\n        await delay(300);\n        fs.appendFileSync(testPath, 'world!');\n\n        await waitFor([spy]);\n        spy.should.have.been.calledWith(EV.ADD, testPath);\n        expect(spy.args[0][2].size).to.equal(12);\n      });\n      it('should not emit change event while a file has not been fully written', async () => {\n        const testPath = getFixturePath('add.txt');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await write(testPath, 'hello');\n        await delay(100);\n        await write(testPath, 'edit');\n        await delay(200);\n        spy.should.not.have.been.calledWith(EV.CHANGE, testPath);\n      });\n      it('should not emit change event before an existing file is fully updated', async () => {\n        const testPath = getFixturePath('change.txt');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await write(testPath, 'hello');\n        await delay(300);\n        spy.should.not.have.been.calledWith(EV.CHANGE, testPath);\n      });\n      it('should wait for an existing file to be fully updated before emitting the change event', async () => {\n        const testPath = getFixturePath('change.txt');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        fs.writeFile(testPath, 'hello', () => {});\n\n        await delay(300);\n        spy.should.not.have.been.called;\n        await waitFor([spy]);\n        spy.should.have.been.calledWith(EV.CHANGE, testPath);\n      });\n      it('should emit change event after the file is fully written', async () => {\n        const testPath = getFixturePath('add.txt');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await delay();\n        await write(testPath, 'hello');\n\n        await waitFor([spy]);\n        spy.should.have.been.calledWith(EV.ADD, testPath);\n        await write(testPath, 'edit');\n        await waitFor([spy.withArgs(EV.CHANGE)]);\n        spy.should.have.been.calledWith(EV.CHANGE, testPath);\n      });\n      it('should not raise any event for a file that was deleted before fully written', async () => {\n        const testPath = getFixturePath('add.txt');\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await write(testPath, 'hello');\n        await delay(400);\n        await fs_unlink(testPath);\n        await delay(400);\n        spy.should.not.have.been.calledWith(sinon.match.string, testPath);\n      });\n      it('should be compatible with the cwd option', async () => {\n        const testPath = getFixturePath('subdir/add.txt');\n        const filename = sysPath.basename(testPath);\n        options.cwd = sysPath.dirname(testPath);\n        await fs_mkdir(options.cwd);\n\n        await delay(200);\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n\n        await delay(400);\n        await write(testPath, 'hello');\n\n        await waitFor([spy.withArgs(EV.ADD)]);\n        spy.should.have.been.calledWith(EV.ADD, filename);\n      });\n      it('should still emit initial add events', async () => {\n        options.ignoreInitial = false;\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        spy.should.have.been.calledWith(EV.ADD);\n        spy.should.have.been.calledWith(EV.ADD_DIR);\n      });\n      it('should emit an unlink event when a file is updated and deleted just after that', async () => {\n        const testPath = getFixturePath('subdir/add.txt');\n        const filename = sysPath.basename(testPath);\n        options.cwd = sysPath.dirname(testPath);\n        await fs_mkdir(options.cwd);\n        await delay();\n        await write(testPath, 'hello');\n        await delay();\n        const spy = await aspy(chokidar_watch(currentDir, options), EV.ALL);\n        await write(testPath, 'edit');\n        await delay();\n        await fs_unlink(testPath);\n        await waitFor([spy.withArgs(EV.UNLINK)]);\n        spy.should.have.been.calledWith(EV.UNLINK, filename);\n        spy.should.not.have.been.calledWith(EV.CHANGE, filename);\n      });\n      describe('race condition', () => {\n        function w(fn, to) {\n          return setTimeout.bind(null, fn, to || slowerDelay || 50);\n        }\n        function simpleCb(err) { if (err) throw err; }\n\n        // Reproduces bug https://github.com/paulmillr/chokidar/issues/546, which was causing an\n        // uncaught exception. The race condition is likelier to happen when stat() is slow.\n        const _realStat = fs.stat;\n        beforeEach(() => {\n          options.awaitWriteFinish = {pollInterval: 50, stabilityThreshold: 50};\n          options.ignoreInitial = true;\n\n          // Stub fs.stat() to take a while to return.\n          sinon.stub(fs, 'stat').callsFake((path, cb) => {\n            _realStat(path, w(cb, 250));\n          });\n        });\n\n        afterEach(() => {\n          // Restore fs.stat() back to normal.\n          sinon.restore();\n        });\n\n        function _waitFor(spies, fn) {\n          function isSpyReady(spy) {\n            return Array.isArray(spy) ? spy[0].callCount >= spy[1] : spy.callCount;\n          }\n          // eslint-disable-next-line prefer-const\n          let intrvl;\n          // eslint-disable-next-line prefer-const\n          let to;\n          function finish() {\n            clearInterval(intrvl);\n            clearTimeout(to);\n            fn();\n            fn = Function.prototype;\n          }\n          intrvl = setInterval(() => {\n            if (spies.every(isSpyReady)) finish();\n          }, 5);\n          to = setTimeout(finish, 3500);\n        }\n\n        it('should handle unlink that happens while waiting for stat to return', (done) => {\n          const spy = sinon.spy();\n          const testPath = getFixturePath('add.txt');\n          chokidar_watch(currentDir, options)\n          .on(EV.ALL, spy)\n          .on(EV.READY, () => {\n            fs.writeFile(testPath, 'hello', simpleCb);\n            _waitFor([spy], () => {\n              spy.should.have.been.calledWith(EV.ADD, testPath);\n              fs.stat.resetHistory();\n              fs.writeFile(testPath, 'edit', simpleCb);\n              w(() => {\n                // There will be a stat() call after we notice the change, plus pollInterval.\n                // After waiting a bit less, wait specifically for that stat() call.\n                fs.stat.resetHistory();\n                _waitFor([fs.stat], () => {\n                  // Once stat call is made, it will take some time to return. Meanwhile, unlink\n                  // the file and wait for that to be noticed.\n                  fs.unlink(testPath, simpleCb);\n                  _waitFor([spy.withArgs(EV.UNLINK)], w(() => {\n                    // Wait a while after unlink to ensure stat() had time to return. That's where\n                    // an uncaught exception used to happen.\n                    spy.should.have.been.calledWith(EV.UNLINK, testPath);\n                    spy.should.not.have.been.calledWith(EV.CHANGE);\n                    done();\n                  }, 400));\n                });\n              }, 40)();\n            });\n          });\n        });\n      });\n    });\n  });\n  describe('getWatched', () => {\n    it('should return the watched paths', async () => {\n      const expected = {};\n      expected[sysPath.dirname(currentDir)] = [subdirId.toString()];\n      expected[currentDir] = ['change.txt', 'unlink.txt'];\n      const watcher = chokidar_watch(currentDir, options);\n      await waitForWatcher(watcher);\n      expect(watcher.getWatched()).to.deep.equal(expected);\n    });\n    it('should set keys relative to cwd & include added paths', async () => {\n      options.cwd = currentDir;\n      const expected = {\n        '.': ['change.txt', 'subdir', 'unlink.txt'],\n        '..': [subdirId.toString()],\n        'subdir': []\n      };\n      await fs_mkdir(getFixturePath('subdir'), PERM_ARR);\n      const watcher = chokidar_watch(currentDir, options);\n      await waitForWatcher(watcher);\n      expect(watcher.getWatched()).to.deep.equal(expected);\n    });\n  });\n  describe('unwatch', () => {\n    beforeEach(async () => {\n      options.ignoreInitial = true;\n      await fs_mkdir(getFixturePath('subdir'), PERM_ARR);\n      await delay();\n    });\n    it('should stop watching unwatched paths', async () => {\n      const watchPaths = [getFixturePath('subdir'), getFixturePath('change.txt')];\n      const watcher = chokidar_watch(watchPaths, options);\n      const spy = await aspy(watcher, EV.ALL);\n      watcher.unwatch(getFixturePath('subdir'));\n\n      await delay();\n      await write(getFixturePath('subdir/add.txt'), dateNow());\n      await write(getFixturePath('change.txt'), dateNow());\n      await waitFor([spy]);\n\n      await delay(300);\n      spy.should.have.been.calledWith(EV.CHANGE, getFixturePath('change.txt'));\n      spy.should.not.have.been.calledWith(EV.ADD);\n      if (!macosFswatch) spy.should.have.been.calledOnce;\n    });\n    it('should ignore unwatched paths that are a subset of watched paths', async () => {\n      const subdirRel = upath.relative(process.cwd(), getFixturePath('subdir'));\n      const unlinkFile = getFixturePath('unlink.txt');\n      const addFile = getFixturePath('subdir/add.txt');\n      const changedFile = getFixturePath('change.txt');\n      const watcher = chokidar_watch(currentDir, options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      // test with both relative and absolute paths\n      watcher.unwatch([subdirRel, getGlobPath('unlink.txt')]);\n\n      await delay();\n      await fs_unlink(unlinkFile);\n      await write(addFile, dateNow());\n      await write(changedFile, dateNow());\n      await waitFor([spy.withArgs(EV.CHANGE)]);\n\n      await delay(300);\n      spy.should.have.been.calledWith(EV.CHANGE, changedFile);\n      spy.should.not.have.been.calledWith(EV.ADD, addFile);\n      spy.should.not.have.been.calledWith(EV.UNLINK, unlinkFile);\n      if (!macosFswatch) spy.should.have.been.calledOnce;\n    });\n    it('should unwatch relative paths', async () => {\n      const fixturesDir = sysPath.relative(process.cwd(), currentDir);\n      const subdir = sysPath.join(fixturesDir, 'subdir');\n      const changeFile = sysPath.join(fixturesDir, 'change.txt');\n      const watchPaths = [subdir, changeFile];\n      const watcher = chokidar_watch(watchPaths, options);\n      const spy = await aspy(watcher, EV.ALL);\n\n      await delay();\n      watcher.unwatch(subdir);\n      await write(getFixturePath('subdir/add.txt'), dateNow());\n      await write(getFixturePath('change.txt'), dateNow());\n      await waitFor([spy]);\n\n      await delay(300);\n      spy.should.have.been.calledWith(EV.CHANGE, changeFile);\n      spy.should.not.have.been.calledWith(EV.ADD);\n      if (!macosFswatch) spy.should.have.been.calledOnce;\n    });\n    it('should watch paths that were unwatched and added again', async () => {\n      const spy = sinon.spy();\n      const watchPaths = [getFixturePath('change.txt')];\n      const watcher = chokidar_watch(watchPaths, options);\n      await waitForWatcher(watcher);\n\n      await delay();\n      watcher.unwatch(getFixturePath('change.txt'));\n\n      await delay();\n      watcher.on(EV.ALL, spy).add(getFixturePath('change.txt'));\n\n      await delay();\n      await write(getFixturePath('change.txt'), dateNow());\n      await waitFor([spy]);\n      spy.should.have.been.calledWith(EV.CHANGE, getFixturePath('change.txt'));\n      if (!macosFswatch) spy.should.have.been.calledOnce;\n    });\n    it('should unwatch paths that are relative to options.cwd', async () => {\n      options.cwd = currentDir;\n      const watcher = chokidar_watch('.', options);\n      const spy = await aspy(watcher, EV.ALL);\n      watcher.unwatch(['subdir', getFixturePath('unlink.txt')]);\n\n      await delay();\n      await fs_unlink(getFixturePath('unlink.txt'));\n      await write(getFixturePath('subdir/add.txt'), dateNow());\n      await write(getFixturePath('change.txt'), dateNow());\n      await waitFor([spy]);\n\n      await delay(300);\n      spy.should.have.been.calledWith(EV.CHANGE, 'change.txt');\n      spy.should.not.have.been.calledWith(EV.ADD);\n      spy.should.not.have.been.calledWith(EV.UNLINK);\n      if (!macosFswatch) spy.should.have.been.calledOnce;\n    });\n  });\n  describe('env variable option override', () => {\n    describe('CHOKIDAR_USEPOLLING', () => {\n      afterEach(() => {\n        delete process.env.CHOKIDAR_USEPOLLING;\n      });\n\n      it('should make options.usePolling `true` when CHOKIDAR_USEPOLLING is set to true', async () => {\n        options.usePolling = false;\n        process.env.CHOKIDAR_USEPOLLING = 'true';\n        const watcher = chokidar_watch(currentDir, options);\n        await waitForWatcher(watcher);\n        watcher.options.usePolling.should.be.true;\n      });\n\n      it('should make options.usePolling `true` when CHOKIDAR_USEPOLLING is set to 1', async () => {\n        options.usePolling = false;\n        process.env.CHOKIDAR_USEPOLLING = '1';\n\n        const watcher = chokidar_watch(currentDir, options);\n        await waitForWatcher(watcher);\n        watcher.options.usePolling.should.be.true;\n      });\n\n      it('should make options.usePolling `false` when CHOKIDAR_USEPOLLING is set to false', async () => {\n        options.usePolling = true;\n        process.env.CHOKIDAR_USEPOLLING = 'false';\n\n        const watcher = chokidar_watch(currentDir, options);\n        await waitForWatcher(watcher);\n        watcher.options.usePolling.should.be.false;\n      });\n\n      it('should make options.usePolling `false` when CHOKIDAR_USEPOLLING is set to 0', async () => {\n        options.usePolling = true;\n        process.env.CHOKIDAR_USEPOLLING = 'false';\n\n        const watcher = chokidar_watch(currentDir, options);\n        await waitForWatcher(watcher);\n        watcher.options.usePolling.should.be.false;\n      });\n\n      it('should not attenuate options.usePolling when CHOKIDAR_USEPOLLING is set to an arbitrary value', async () => {\n        options.usePolling = true;\n        process.env.CHOKIDAR_USEPOLLING = 'foo';\n\n        const watcher = chokidar_watch(currentDir, options);\n        await waitForWatcher(watcher);\n        watcher.options.usePolling.should.be.true;\n      });\n    });\n    if (options && options.usePolling) {\n      describe('CHOKIDAR_INTERVAL', () => {\n        afterEach(() => {\n          delete process.env.CHOKIDAR_INTERVAL;\n        });\n        it('should make options.interval = CHOKIDAR_INTERVAL when it is set', async () => {\n          options.interval = 100;\n          process.env.CHOKIDAR_INTERVAL = '1500';\n\n          const watcher = chokidar_watch(currentDir, options);\n          await waitForWatcher(watcher);\n          watcher.options.interval.should.be.equal(1500);\n        });\n      });\n    }\n  });\n  describe('reproduction of bug in issue #1040', () => {\n    it('should detect change on symlink folders when consolidateThreshhold is reach', async () => {\n      const id = subdirId.toString();\n\n      const fixturesPathRel = sysPath.join(FIXTURES_PATH_REL, id, 'test-case-1040');\n      const linkPath = sysPath.join(fixturesPathRel, 'symlinkFolder');\n      const packagesPath = sysPath.join(fixturesPathRel, 'packages');\n      await fs_mkdir(fixturesPathRel);\n      await fs_mkdir(linkPath);\n      await fs_mkdir(packagesPath);\n\n      // Init chokidar\n      const watcher = chokidar.watch([]);\n\n      // Add more than 10 folders to cap consolidateThreshhold\n      for (let i = 0 ; i < 20 ; i += 1) {\n        const folderPath = sysPath.join(packagesPath, `folder${i}`);\n        await fs_mkdir(folderPath);\n        const filePath = sysPath.join(folderPath, `file${i}.js`);\n        await write(sysPath.resolve(filePath), 'file content');\n        const symlinkPath = sysPath.join(linkPath, `folder${i}`);\n        await fs_symlink(sysPath.resolve(folderPath), symlinkPath, isWindows ? 'dir' : null);\n        watcher.add(sysPath.resolve(sysPath.join(symlinkPath, `file${i}.js`)));\n      }\n\n      // Wait to be sure that we have no other event than the update file\n      await delay(300);\n\n      const eventsWaiter = waitForEvents(watcher, 1);\n\n      // Update a random generated file to fire an event\n      const randomFilePath = sysPath.join(fixturesPathRel, 'packages', 'folder17', 'file17.js');\n      await write(sysPath.resolve(randomFilePath), 'file content changer zeri ezhriez');\n\n      // Wait chokidar watch\n      await delay(300);\n\n      const events = await eventsWaiter;\n\n      expect(events.length).to.equal(1);\n    })\n  });\n  describe('reproduction of bug in issue #1024', () => {\n    it('should detect changes to folders, even if they were deleted before', async () => {\n      const id = subdirId.toString();\n      const relativeWatcherDir = sysPath.join(FIXTURES_PATH_REL, id, 'test');\n      const watcher = chokidar.watch(relativeWatcherDir, {\n        persistent: true,\n      });\n      try {\n        const eventsWaiter = waitForEvents(watcher, 5);\n        const testSubDir = sysPath.join(relativeWatcherDir, 'dir');\n        const testSubDirFile = sysPath.join(relativeWatcherDir, 'dir', 'file');\n\n        // Command sequence from https://github.com/paulmillr/chokidar/issues/1042.\n        await delay();\n        await fs_mkdir(relativeWatcherDir);\n        await fs_mkdir(testSubDir);\n        // The following delay is essential otherwise the call of mkdir and rmdir will be equalize\n        await delay(300);\n        await fs_rmdir(testSubDir);\n        // The following delay is essential otherwise the call of rmdir and mkdir will be equalize\n        await delay(300);\n        await fs_mkdir(testSubDir);\n        await delay(300);\n        await write(testSubDirFile, '');\n        await delay(300);\n\n        const events = await eventsWaiter;\n\n        chai.assert.deepStrictEqual(events, [\n          `[ALL] addDir: ${sysPath.join('test-fixtures', id, 'test')}`,\n          `[ALL] addDir: ${sysPath.join('test-fixtures', id, 'test', 'dir')}`,\n          `[ALL] unlinkDir: ${sysPath.join('test-fixtures', id, 'test', 'dir')}`,\n          `[ALL] addDir: ${sysPath.join('test-fixtures', id, 'test', 'dir')}`,\n          `[ALL] add: ${sysPath.join('test-fixtures', id, 'test', 'dir', 'file')}`,\n        ]);\n      } finally {\n        watcher.close();\n      }\n    });\n\n    it('should detect changes to symlink folders, even if they were deleted before', async () => {\n      const id = subdirId.toString();\n      const relativeWatcherDir = sysPath.join(FIXTURES_PATH_REL, id, 'test');\n      const linkedRelativeWatcherDir = sysPath.join(FIXTURES_PATH_REL, id, 'test-link');\n      await fs_symlink(\n        sysPath.resolve(relativeWatcherDir),\n        linkedRelativeWatcherDir,\n        isWindows ? 'dir' : null\n      );\n      await delay();\n      const watcher = chokidar.watch(linkedRelativeWatcherDir, {\n        persistent: true,\n      });\n      try {\n        const eventsWaiter = waitForEvents(watcher, 5);\n        const testSubDir = sysPath.join(relativeWatcherDir, 'dir');\n        const testSubDirFile = sysPath.join(relativeWatcherDir, 'dir', 'file');\n\n        // Command sequence from https://github.com/paulmillr/chokidar/issues/1042.\n        await delay();\n        await fs_mkdir(relativeWatcherDir);\n        await fs_mkdir(testSubDir);\n        // The following delay is essential otherwise the call of mkdir and rmdir will be equalize\n        await delay(300);\n        await fs_rmdir(testSubDir);\n        // The following delay is essential otherwise the call of rmdir and mkdir will be equalize\n        await delay(300);\n        await fs_mkdir(testSubDir);\n        await delay(300);\n        await write(testSubDirFile, '');\n        await delay(300);\n\n        const events = await eventsWaiter;\n\n        chai.assert.deepStrictEqual(events, [\n          `[ALL] addDir: ${sysPath.join('test-fixtures', id, 'test-link')}`,\n          `[ALL] addDir: ${sysPath.join('test-fixtures', id, 'test-link', 'dir')}`,\n          `[ALL] unlinkDir: ${sysPath.join('test-fixtures', id, 'test-link', 'dir')}`,\n          `[ALL] addDir: ${sysPath.join('test-fixtures', id, 'test-link', 'dir')}`,\n          `[ALL] add: ${sysPath.join('test-fixtures', id, 'test-link', 'dir', 'file')}`,\n        ]);\n      } finally {\n        watcher.close();\n      }\n    });\n  });\n\n  describe('close', () => {\n    it('should ignore further events on close', async () => {\n      const spy = sinon.spy();\n      const watcher = chokidar_watch(currentDir, options);\n      await waitForWatcher(watcher);\n\n      watcher.on(EV.ALL, spy);\n      await watcher.close();\n\n      await write(getFixturePath('add.txt'), dateNow());\n      await write(getFixturePath('add.txt'), 'hello');\n      await delay(300);\n      await fs_unlink(getFixturePath('add.txt'));\n\n      spy.should.not.have.been.called;\n    });\n    it('should not ignore further events on close with existing watchers', async () => {\n      const spy = sinon.spy();\n      const watcher1 = chokidar_watch(currentDir);\n      const watcher2 = chokidar_watch(currentDir);\n      await Promise.all([\n        waitForWatcher(watcher1),\n        waitForWatcher(watcher2)\n      ]);\n\n      // The EV_ADD event should be called on the second watcher even if the first watcher is closed\n      watcher2.on(EV.ADD, spy);\n      await watcher1.close();\n\n      await write(getFixturePath('add.txt'), 'hello');\n      // Ensures EV_ADD is called. Immediately removing the file causes it to be skipped\n      await delay(200);\n      await fs_unlink(getFixturePath('add.txt'));\n\n      spy.should.have.been.calledWith(sinon.match('add.txt'));\n    });\n    it('should not prevent the process from exiting', async () => {\n      const scriptFile = getFixturePath('script.js');\n      const chokidarPath = pathToFileURL(sysPath.join(__dirname, 'esm/index.js'))\n        .href\n        .replace(/\\\\/g, '\\\\\\\\');\n      const scriptContent = `\n      (async () => {\n        const chokidar = await import(\"${chokidarPath}\");\n        const watcher = chokidar.watch(\"${scriptFile.replace(/\\\\/g, '\\\\\\\\')}\");\n        watcher.on(\"ready\", () => {\n          watcher.close();\n          process.stdout.write(\"closed\");\n        });\n      })();`;\n      await write(scriptFile, scriptContent);\n      const obj = await exec(`node ${scriptFile}`);\n      const {stdout} = obj;\n      expect(stdout.toString()).to.equal('closed');\n    });\n    it('should always return the same promise', async () => {\n      const watcher = chokidar_watch(currentDir, options);\n      const closePromise = watcher.close();\n      expect(closePromise).to.be.a('promise');\n      expect(watcher.close()).to.be.equal(closePromise);\n      await closePromise;\n    });\n  });\n};\n\ndescribe('chokidar', async () => {\n  before(async () => {\n    await rimraf(FIXTURES_PATH);\n    const _content = fs.readFileSync(__filename, 'utf-8');\n    const _only = _content.match(/\\sit\\.only\\(/g);\n    const itCount = _only && _only.length || _content.match(/\\sit\\(/g).length;\n    const testCount = itCount * 3;\n    fs.mkdirSync(currentDir, PERM_ARR);\n    while (subdirId++ < testCount) {\n      currentDir = getFixturePath('');\n      fs.mkdirSync(currentDir, PERM_ARR);\n      fs.writeFileSync(sysPath.join(currentDir, 'change.txt'), 'b');\n      fs.writeFileSync(sysPath.join(currentDir, 'unlink.txt'), 'b');\n    }\n    subdirId = 0;\n  });\n\n  after(async () => {\n    await rimraf(FIXTURES_PATH);\n  });\n\n  beforeEach(() => {\n    subdirId++;\n    currentDir = getFixturePath('');\n  });\n\n  afterEach(async () => {\n    let watcher;\n    while ((watcher = allWatchers.pop())) {\n      await watcher.close();\n    }\n  });\n\n  it('should expose public API methods', () => {\n    chokidar.FSWatcher.should.be.a('function');\n    chokidar.watch.should.be.a('function');\n  });\n\n  if (!isIBMi) {\n    describe('fs.watch (non-polling)', runTests.bind(this, {usePolling: false}));\n  }\n  describe('fs.watchFile (polling)', runTests.bind(this, {usePolling: true, interval: 10}));\n});\n"
        },
        {
          "name": "tsconfig.esm.json",
          "type": "blob",
          "size": 0.359375,
          "content": "{\n  \"extends\": \"@paulmillr/jsbt/tsconfig.esm.json\",\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"outDir\": \"esm\",\n    \"module\": \"es2020\",\n    \"moduleResolution\": \"bundler\",\n    \"noImplicitReturns\": false,\n    \"sourceMap\": false,\n    \"declarationMap\": false,\n    \"isolatedDeclarations\": true\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n"
        },
        {
          "name": "tsconfig.json",
          "type": "blob",
          "size": 0.2998046875,
          "content": "{\n  \"extends\": \"@paulmillr/jsbt/tsconfig.cjs.json\",\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"outDir\": \".\",\n    \"noImplicitReturns\": false,\n    \"sourceMap\": false,\n    \"declarationMap\": false,\n    \"isolatedDeclarations\": true\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n"
        }
      ]
    }
  ]
}