{
  "metadata": {
    "timestamp": 1736563408753,
    "page": 422,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "1c7/Crash-Course-Computer-Science-Chinese",
      "stars": 10461,
      "defaultBranch": "master",
      "files": [
        {
          "name": "(字幕)全40集中英字幕文本.txt",
          "type": "blob",
          "size": 937.9365234375,
          "content": "Hello world, I'm Carrie Anne, and welcome to Crash Course Computer Science!\nHello world！我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nOver the course of this series, we're going to go from bits, bytes, transistors and logic gates,\n在这个系列中，我们会学习 Bits(位)，Bytes(字节)，晶体管, 逻辑门，\n\nall the way to Operating Systems, Virtual Reality and Robots!\n一直到操作系统，虚拟现实和机器人!\n\nWe're going to cover a lot, but just to clear things up\n我们要学很多东西，但预先说明\n\nwe ARE NOT going to teach you how to program.\n我们 *不会* 教你怎么编程\n\nInstead, we're going to explore a range of computing topics as a discipline and a technology.\n我们会从高层次上纵览一系列计算机话题\n\nComputers are the lifeblood of today's world.\n计算机是当今世界的命脉\n\nIf they were to suddenly turn off, all at once,\n如果突然关掉所有的计算机\n\nthe power grid would shut down, cars would crash, planes would fall,\n电网会关闭，车辆会相撞，飞机会坠毁\n\nwater treatment plants would stop, stock markets would freeze,\n净水厂会关闭，证券市场会停止运作\n\ntrucks with food wouldn't know where to deliver, and employees wouldn't get paid.\n装满食物的卡车不知运往何方，员工得不到薪水\n\nEven many non-computer objects -like DFTBA shirts and the chair I'm sitting on-\n甚至很多和计算机无关的东西，例如 DFTBA 的 T 恤和我现在坐的椅子\n\nare made in factories run by computers.\n也都是在计算机管理的工厂中制造的\n\nComputing really has transformed nearly every aspect of our lives.\n计算机改变了我们生活中几乎所有方面\n\nAnd this isn't the first time we've seen this sort of technology-driven global change.\n我们也不是第一次遇到推动全球发展的科技了\n\nAdvances in manufacturing during the Industrial Revolution\n工业革命中生产能力的提高\n\nbrought a new scale to human civilization - in agriculture, industry and domestic life.\n大幅提升了农业，工业，畜牧业的规模\n\nMechanization meant superior harvests and more food, mass produced goods,\n机械化导致更好的收成，更多的食物，商品可以大批量生产\n\ncheaper and faster travel and communication, and usually a better quality of life.\n旅行和通讯变得更便宜更快，生活质量变得更好.\n\nAnd computing technology is doing the same right now\n计算机和工业革命有一样的影响\n\n- from automated farming and medical equipment,\n从自动化农业和医疗设备\n\nto global telecommunications and educational opportunities,\n到全球通信和教育机会\n\nand new frontiers like Virtual Reality and Self Driving Cars.\n还有 虚拟现实 和 无人驾驶汽车 等新领域\n\nWe are living in a time likely to be remembered as the Electronic Age.\n现在这个时代很可能会被后人总结成 \"信息时代\"\n\nAnd with billions of transistors in just your smartphones, computers can seem pretty complicated,\n你的智能手机中有数十亿个晶体管，看起来好像很复杂\n\nbut really, they're just simple machines\n但实际上它是很简单的机器\n\nthat perform complex actions through many layers of abstraction.\n通过一层层的抽象  来做出复杂操作\n\nSo in this series, we're going break down those layers,\n在这个系列中，我们会一层层讲解，\n\nand build up from simple 1's and 0's, to logic units, CPUs,\n从最底层的1和0，到逻辑门，CPU\n\noperating systems, the entire internet and beyond.\n操作系统，整个互联网，以及更多~~\n\nAnd don't worry, in the same way someone buying t-shirts on a webpage\n不用担心，正如在网上买T恤的人 不用知道网站代码是怎么写的\n\ndoesn't need to know how that webpage was programmed,\n不用担心，正如在网上买T恤的人 不用知道网站代码是怎么写的\n\nor the web designer doesn't need to know how all the packets are routed,\n设计师不用知道数据包是怎么传输的\n\nor router engineers don't need to know about transistor logic,\n设计路由器的工程师不用理解晶体管的逻辑\n\nthis series will build on previous episodes but not be dependent on them.\n本系列中每个视频会接着上集继续讲，但并不依赖前面的视频\n\nBy the end of this series,\n等这个系列结束后\n\nI hope that you can better contextualize computing's role both in your own life and society,\n希望你能了解计算机在你的人生 以及社会中扮演什么角色\n\nand how humanity's (arguably) greatest invention is just in its infancy,\n以及这个人类史上最伟大的发明（可以这样说啦）是怎么开始的，\n\nwith its biggest impacts yet to come.\n它对未来还会有更大的影响\n\nBut before we get into all that, we should start at computing's origins,\n但深入之前，我们应该从计算的起源讲起,\n\nbecause although electronic computers are relatively new, the need for computation is not.\n虽然电子计算机才出现不久，但人类对计算的需求早就有了\n\nThe earliest recognized device for computing was the abacus,\n公认最早的计算设备是 算盘\n\ninvented in Mesopotamia around 2500 BCE.\n发明于\"美索不达米亚\"，大约公元前 2500 年\n\nIt's essentially a hand operated calculator,\n它是手动计算器，用来帮助加减数字\n\nthat helps add and subtract many numbers.\n它是手动计算器，用来帮助加减数字\n\nIt also stores the current state of the computation, much like your hard drive does today.\n它存储着当前的计算状态，类似于如今的硬盘\n\nThe abacus was created because,\n人们制造算盘是因为\n\nthe scale of society had become greater than\n社会的规模已经超出个人心算的能力\n\nwhat a single person could keep and manipulate in their mind.\n社会的规模已经超出个人心算的能力\n\nThere might be thousands of people in a village or tens of thousands of cattle.\n一个村庄可能有上千个人和上万头牛\n\nThere are many variants of the abacus,\n算盘有很多变种\n\nbut let's look at a really basic version with each row representing a different power of ten.\n但我们来看一个基础版，每行代表 10 的不同次方\n\nSo each bead on the bottom row represents a single unit,\n最底下那行，一个珠子代表 10 的 0 次方，也就是 1，\n\nin the next row they represent 10, the row above 100, and so on.\n再上面一行是 10 的 1 次方（也就是 10） \\N 再上面一行是 10 的 2 次方 （以此类推）\n\nLet's say we have 3 heads of cattle represented by 3 beads on the bottom row on the right side.\n假设最底部的 3 颗珠子，代表 3 头牛\n\nIf we were to buy 4 more cattle we would just slide 4 more beads to the right for a total of 7.\n假设再买 4 头牛，只需要向右移动 4 颗珠子，共 7 个珠子\n\nBut if we were to add 5 more after the first 3 we would run out of beads,\n但如果再买 5 头，珠子就不够用了\n\nso we would slide everything back to the left,\n所以把所有珠子移回左边\n\nslide one bead on the second row to the right, representing ten,\n在第二排把 1 颗珠子向右移动，代表 10\n\nand then add the final 2 beads on the bottom row for a total of 12.\n然后最底下那行，向右移动 2 颗珠子，代表 12\n\nThis is particularly useful with large numbers.\n这种方法处理大数字很有效\n\nSo if we were to add 1,251\n假设要表示 1251\n\nwe would just add 1 to the bottom row, 5 to the second row, 2 to the third row, and 1 to the fourth row\n从下往上：\\N第一行移 1 个，第二行移 5 个\\N第三行移 2 个，第四行移 1 个\n\n- we don't have to add in our head and the abacus stores the total for us.\n我们不用记在脑子里，算盘会记住.\n\nOver the next 4000 years, humans developed all sorts of clever computing devices,\n在接下来 4000 年，人类发明了各种巧妙的计算设备\n\nlike the astrolabe, which enabled ships to calculate their latitude at sea.\n比如星盘，让船只可以在海上计算纬度\n\nOr the slide rule, for assisting with multiplication and division.\n或计算尺，帮助计算乘法和除法\n\nAnd there are literally hundred of types of clocks created\n人们还创造了上百种时钟\n\nthat could be used to calculate sunrise, tides, positions of celestial bodies, and even just the time.\n算日出，潮汐，天体的位置，或纯粹拿来计时\n\nEach one of these devices made something that was previously laborious to calculate much faster,\n这些设备让原先很费力的事变得更快，更简单，更精确\n\neasier, and often more accurate\n这些设备让原先很费力的事变得更快，更简单，更精确\n\n- it lowered the barrier to entry,\n降低了门槛\n\nand at the same time, amplified our mental abilities -\n加强了我们的能力\n\ntake note, this is a theme we're going to touch on a lot in this series.\n记笔记!（敲黑板）这个系列会多次提到这一点\n\nAs early computer pioneer Charles Babbage said:\n计算机先驱 Charles Babbage 说过：\n\n\"At each increase of knowledge, as well as on the contrivance of every new tool,\n\"随着知识的增长和新工具的诞生，人工劳力会越来越少\"\n\nhuman labour becomes abridged.\"\n\"随着知识的增长和新工具的诞生，人工劳力会越来越少\"\n\nHowever, none of these devices were called \"computers\".\n然而，这些设备那时都不叫 \"计算机\"\n\nThe earliest documented use of the word \"computer\" is from 1613, in a book by Richard Braithwait.\n最早使用 \"计算机\" 一词的文献 \\N 来自 1613 年的一本书，作者 Richard Braithwait\n\nAnd it wasn't a machine at all - it was a job title.\n然而指的不是机器，而是一种职业\n\nBraithwait said,\nBraithwait 说：\n\n\"I have read the truest computer of times,\n\"我听说过的计算者里最厉害的，能把好几天的工作量大大缩减\"\n\nand the best arithmetician that ever breathed, and he reduceth thy dayes into a short number\".\n\"我听说过的计算者里最厉害的，能把好几天的工作量大大缩减\"\n\nIn those days, computer was a person who did calculations,\n那时, \"Computer\" 指负责计算的人\n\nsometimes with the help of machines, but often not.\n\"Computer\" 偶尔会用机器帮忙，但大部分时候靠自己\n\nThis job title persisted until the late 1800s,\n这个职位一直到 1800 年代还存在\n\nwhen the meaning of computer started shifting to refer to devices.\n之后 \"Computer\" 逐渐开始代表机器\n\nNotable among these devices was the Step Reckoner,\n其中\"步进计算器\"最有名\n\nbuilt by German polymath Gottfried Leibniz in 1694.\n由德国博学家 戈特弗里德·莱布尼茨 建造于 1694 年\n\nLeibniz said \"... it is beneath the dignity of excellent men to waste their time in calculation\n莱布尼茨说过 \"... 让优秀的人浪费时间算数简直侮辱尊严\n\nwhen any peasant could do the work just as accurately with the aid of a machine.\"\n农民用机器能算得一样准\"\n\nIt worked kind of like the odometer in your car,\n\"步进计算器\"有点像汽车里的里程表，不断累加里程数\n\nwhich is really just a machine for adding up the number of miles your car has driven.\n\"步进计算器\"有点像汽车里的里程表，不断累加里程数\n\nThe device had a series of gears that turned;\n它有一连串可以转动的齿轮\n\neach gear had ten teeth, to represent the digits from 0 to 9.\n每个齿轮有十个齿，代表数字0到9\n\nWhenever a gear bypassed nine, it rotated back to 0 and advanced the adjacent gear by one tooth.\n每当一个齿轮转过 9，它会转回 0，同时让旁边的齿轮前进 1 个齿\n\nKind of like when hitting 10 on that basic abacus.\n就像算盘超过 10 一样.\n\nThis worked in reverse when doing subtraction, too.\n做减法时，机器会反向运作.\n\nWith some clever mechanical tricks,\n利用一些巧妙的机械结构\n\nthe Step Reckoner was also able to multiply and divide numbers.\n步进计算器也能做乘法和除法\n\nMultiplications and divisions are really just many additions and subtractions.\n乘法和除法 实际上只是多个加法和减法\n\nFor example, if we want to divide 17 by 5, we just subtract 5, then 5, then 5 again,\n举例，17除以5，我们只要减5，减5，再减5\n\nand then we can't subtract any more 5's… so we know 5 goes into 17 three times, with 2 left over.\n直到不能再减 5，就知道了 17=5x3+2\n\nThe Step Reckoner was able to do this in an automated way,\n步进计算器 可以自动完成这种操作\n\nand was the first machine that could do all four of these operations.\n它是第一台能做\"加减乘除\"全部四种运算的机器\n\nAnd this design was so successful it was used for the next three centuries of calculator design.\n它的设计非常成功，以至于沿用了 3 个世纪.\n\nUnfortunately, even with mechanical calculators,\n不幸的是，即使有机械计算器\n\nmost real world problems required many steps of computation before an answer was determined.\n许多现实问题 依然需要很多步\n\nIt could take hours or days to generate a single result.\n算一个结果可能要几小时甚至几天\n\nAlso, these hand-crafted machines were expensive, and not accessible to most of the population.\n而且这些手工制作的机器非常昂贵，大部分人买不起\n\nSo, before 20th century,\n所以在 20 世纪以前\n\nmost people experienced computing through pre-computed tables\n大部分人会用预先算好的计算表\n\nassembled by those amazing \"human computers\" we talked about.\n这些计算表由之前说的 \"人力计算器\" 编撰\n\nSo if you needed to know the square root of 8 million 6 hundred and 75 thousand 3 hundred and 9,\n如果你想知道 867,5309 的平方根\n\ninstead of spending all day hand-cranking your step reckoner,\n与其花一整天来手摇 \"步进计算器\"\n\nyou could look it up in a huge book full of square root tables in a minute or so.\n你可以花一分钟在表里找答案\n\nSpeed and accuracy is particularly important on the battlefield,\n速度和准确性在战场上尤为重要\n\nand so militaries were among the first to apply computing to complex problems.\n因此军队很早就开始用计算解决复杂问题\n\nA particularly difficult problem is accurately firing artillery shells,\n如何精确瞄准炮弹是一个很难的问题\n\nwhich by the 1800s could travel well over a kilometer (or a bit more than half a mile).\n19世纪，这些炮弹的射程可以达到 1 公里以上（比半英里多一点）\n\nAdd to this varying wind conditions, temperature, and atmospheric pressure,\n因为风力，温度，大气压力会不断变化\n\nand even hitting something as large as a ship was difficult.\n想打中船一样大的物体也非常困难\n\nRange Tables were created that allowed gunners to look up environmental conditions\n于是出现了射程表，炮手可以查环境条件和射击距离\n\nand the distance they wanted to fire,\n于是出现了射程表，炮手可以查环境条件和射击距离\n\nand the table would tell them the angle to set the canon.\n然后这张表会告诉他们，角度要设成多少\n\nThese Range Tables worked so well, they were used well into World War Two.\n这些射程表很管用，二战中被广泛应用\n\nThe problem was, if you changed the design of the cannon or of the shell,\n问题是如果改了大炮或炮弹的设计，就要算一张新表\n\na whole new table had to be computed,\n问题是如果改了大炮或炮弹的设计，就要算一张新表\n\nwhich was massively time consuming and inevitably led to errors.\n这样很耗时而且会出错\n\nCharles Babbage acknowledged this problem in 1822\nCharles Babbage 在 1822 年写了一篇论文\n\nin a paper to the Royal Astronomical Society entitled:\n向皇家天文学会指出了这个问题\n\n\"Note on the application of machinery to the computation of astronomical and mathematical tables\".\n标题叫： \"机械在天文与计算表中的应用\"\n\nLet's go to the thought bubble.\n让我们进入思想泡泡\n\nCharles Babbage proposed a new mechanical device called the Difference Engine,\nCharles Babbage 提出了一种新型机械装置叫 \"差分机\"\n\na much more complex machine that could approximate polynomials.\n一个更复杂的机器，能近似多项式.\n\nPolynomials describe the relationship between several variables\n多项式描述了几个变量之间的关系\n\n- like range and air pressure, or amount of pizza Carrie Anne eats and happiness.\n比如射程和大气压力，或者 Carrie Anne 要吃多少披萨才开心\n\nPolynomials could also be used to approximate logarithmic and trigonometric functions,\n多项式也可以用于近似对数和三角函数\n\nwhich are a real hassle to calculate by hand.\n这些函数手算相当麻烦\n\nBabbage started construction in 1823,\nCharles Babbage 在 1823 年开始建造差分机\n\nand over the next two decades, tried to fabricate and assemble the 25,000 components,\n并在接下来二十年，试图制造和组装 25,000 个零件\n\ncollectively weighing around 15 tons.\n总重接近 15 吨\n\nUnfortunately, the project was ultimately abandoned.\n不幸的是，该项目最终放弃了\n\nBut, in 1991,\n但在 1991 年\n\nhistorians finished constructing a Difference Engine based on Babbage's drawings and writings\n历史学家根据 Charles Babbage 的草稿做了一个差分机\n\n- and it worked!\n而且它还管用！\n\nBut more importantly, during construction of the Difference Engine,\n但更重要的是，在差分机的建造期间\n\nBabbage imagined an even more complex machine - the Analytical Engine.\nCharles Babbage 构想了一个更复杂的机器 - 分析机\n\nUnlike the Difference Engine,\n不像差分机，步进计算器 和以前的其他计算设备\n\nStep Reckoner and all other computational devices before it\n不像差分机，步进计算器 和以前的其他计算设备\n\n- the Analytical Engine was a \"general purpose computer\".\n分析机是 \"通用计算机\"\n\nIt could be used for many things, not just one particular computation;\n它可以做很多事情，不只是一种特定运算\n\nit could be given data and run operations in sequence;\n甚至可以给它数据，然后按顺序执行一系列操作\n\nit had memory and even a primitive printer.\n它有内存 甚至一个很原始的打印机\n\nLike the Difference Engine, it was ahead of its time, and was never fully constructed.\n就像差分机，这台机器太超前了，所以没有建成\n\nHowever, the idea of an \"automatic computer\"\n然而，这种 \"自动计算机\" 的概念\n\n- one that could guide itself through a series of operations automatically,\n-计算机可以自动完成一系列操作\n\nwas a huge deal, and would foreshadow computer programs.\n是个跨时代的概念，预示着计算机程序的诞生\n\nEnglish mathematician Ada Lovelace wrote hypothetical programs for the Analytical Engine, saying,\n英国数学家 Ada Lovelace 给分析机写了假想的程序，她说：\n\n\"A new, a vast, and a powerful language is developed for the future use of analysis.\"\n\"未来会诞生一门全新的，强大的，专为分析所用的语言\"\n\nFor her work, Ada is often considered the world's first programmer.\n因此 Ada 被认为是世上第一位程序员.\n\nThe Analytical Engine would inspire, arguably, the first generation of computer scientists,\n分析机激励了（可以这么讲）第一代计算机科学家\n\nwho incorporated many of Babbage's ideas in their machines.\n这些计算机科学家 \\N 把很多 Charles Babbage 的点子融入到他们的机器\n\nThis is why Babbage is often considered the \"father of computing\".\n所以 Charles Babbage 经常被认为是 \"计算之父\"\n\nThanks! Thought Bubble\n谢啦！思想泡泡\n\nSo by the end of the 19th century,\n到了 19 世纪末\n\ncomputing devices were used for special purpose tasks in the sciences and engineering,\n科学和工程领域中的特定任务 会用上计算设备\n\nbut rarely seen in business, government or domestic life.\n但公司，政府，家庭中很少见到计算设备\n\nHowever, the US government faced a serious problem for its 1890 census\n然而，美国政府在 1890 年的人口普查中面临着严重的问题\n\nthat demanded the kind of efficiency that only computers could provide.\n只有计算机能提供所需的效率\n\nThe US Constitution requires that a census be conducted every ten years,\n美国宪法要求 10 年进行一次人口普查\n\nfor the purposes of distributing federal funds, representation in congress, and good stuff like that.\n目的是分配联邦资金，国会代表，等等\n\nAnd by 1880s, the US population was booming, mostly due to immigration.\n到 1880 年代，美国人口迅速增长，大部分因为移民\n\nThat census took seven years to manually compile\n人口普查要七年时间来手工编制，等做完都过时了\n\nand by the time it was completed, it was already out of date\n人口普查要七年时间来手工编制，等做完都过时了\n\n- and it was predicted that the 1890 census would take 13 years to compute.\n而且 1890 年的人口普查，预计要 13 年完成\n\nThat's a little problematic when it's required every decade!\n但人口普查可是 10 年一次啊！\n\nThe Census bureau turned to Herman Hollerith, who had built a tabulating machine.\n人口普查局找了 Herman Hollerith，他发明了打孔卡片制表机\n\nHis machine was \"electro-mechanical\"\n他的机器是 \"电动机械的\"\n\n- it used traditional mechanical systems for keeping count,\n- 用传统机械来计数\n\nlike Leibniz's Step Reckoner - but coupled them with electrically-powered components.\n结构类似莱布尼茨的乘法器，但用电动结构连接其他组件\n\nHollerith's machine used punch cards\nHollerith 的机器用打孔卡\n\nwhich were paper cards with a grid of locations that can be punched out to represent data.\n一种纸卡，上面有网格，用打孔来表示数据.\n\nFor example, there was a series of holes for marital status.\n举个例子，有一连串孔代表婚姻状况\n\nIf you were married, you would punch out the married spot,\n如果你结婚了，就在 \"结婚\" 的位置打孔\n\nthen when the card was inserted into Hollerith's machine, little metal pins would come down over the card\n当卡插入 Hollerith 的机器时，小金属针会到卡片上\n\n- if a spot was punched out, the pin would pass through the hole in the paper\n-如果有个地方打孔了，针会穿过孔\n\nand into a little vial of mercury, which completed the circuit.\n泡入一小瓶汞，联通电路\n\nThis now completed circuit powered an electric motor,\n电路会驱动电机\n\nwhich turned a gear to add one, in this case, to the \"married\" total.\n然后给 \"已婚\" 的齿轮 + 1\n\nHollerith's machine was roughly 10x faster than manual tabulations,\nHollerith 的机器速度是手动的 10 倍左右\n\nand the Census was completed in just two and a half years\n使人口普查在短短两年半内完成\n\n- saving the census office millions of dollars.\n给人口普查办公室省了上百万美元\n\nBusinesses began recognizing the value of computing,\n企业开始意识到计算机的价值\n\nand saw its potential to boost profits by improving labor- and data-intensive tasks,\n可以提升劳动力以及数据密集型任务 来提升利润\n\nlike accounting, insurance appraisals, and inventory management.\n比如会计，保险评估和库存管理等行业\n\nTo meet this demand, Hollerith founded The Tabulating Machine Company,\n为了满足这一需求，Hollerith 成立了制表机器公司\n\nwhich later merged with other machine makers in 1924\n这家公司后来在 1924 年与其它机械制造商合并\n\nto become The International Business Machines Corporation or IBM\n成为了 \"国际商业机器公司\"，简称 IBM\n\n- which you've probably heard of.\n-你可能听过 IBM\n\nThese electro-mechanical \"business machines\" were a huge success, transforming commerce and government,\n这些电子机械的 \"商业机器\" 取得了巨大成功，改变了商业和政府.\n\nand by the mid-1900s, the explosion in world population and the rise of globalized trade\n到了 1900 年代中叶，世界人口的爆炸和全球贸易的兴起\n\ndemanded even faster and more flexible tools for processing data,\n要求更快，更灵活的工具来处理数据\n\nsetting the stage for digital computers,\n为电子计算机的发展奠定了基础\n\nwhich we'll talk about next week.\n我们下周讨论\n\nOur last episode brought us to the start of the 20th century,\n上集讲到 20 世纪初\n\nwhere early, special purpose computing devices, like tabulating machines,\n当时的早期计算设备都针对特定用途  比如 制表机\n\nwere a huge boon to governments and business\n大大推进了政府和企业\n\n- aiding, and sometimes replacing, rote manual tasks.\n它们帮助, 甚至代替了人工\n\nBut the scale of human systems continued to increase at an unprecedented rate.\n然而人类社会的规模  在以前所未有的速度增长\n\nThe first half of the 20th century saw the world's population almost double.\n20世纪上半叶，世界人口几乎翻倍\n\nWorld War 1 mobilized 70 million people, and World War 2 involved more than 100 million.\n一战动员7千万人，二战1亿多人\n\nGlobal trade and transit networks became interconnected like never before,\n全球贸易和运输更加紧密\n\nand the sophistication of our engineering and scientific endeavors reached new heights\n工程和科学的复杂度也达到新高\n\n- we even started to seriously consider visiting other planets.\n- 我们甚至开始考虑造访其他行星\n\nAnd it was this explosion of complexity, bureaucracy, and ultimately data,\n复杂度的增高导致数据量暴增\n\nthat drove an increasing need for automation and computation.\n人们需要更多自动化 更强的计算能力\n\nSoon those cabinet-sized electro-mechanical computers grew into room-sized behemoths\n很快，柜子大小的计算机变成房间大小\n\nthat were expensive to maintain and prone to errors.\n维护费用高 而且容易出错\n\nAnd it was these machines that would set the stage for future innovation.\n而正是这些机器 为未来的创新打下基础\n\nOne of the largest electro-mechanical computers built was the Harvard Mark I,\n最大的机电计算机之一是 哈佛马克一号\n\ncompleted in 1944 by IBM for the Allies during World War 2.\nIBM 在 1944 完成建造，给二战同盟国建造的.\n\nIt contained 765,000 components, three million connections, and five hundred miles of wire.\n它有76万5千个组件，300万个连接点和500英里长的导线\n\nTo keep its internal mechanics synchronized,\n为了保持内部机械装置同步\n\nit used a 50-foot shaft running right through the machine driven by a five horsepower motor.\n它有一个50英尺的传动轴，由一个 5 马力的电机驱动\n\nOne of the earliest uses for this technology was running simulations for the Manhattan Project.\n这台机器最早的用途之一 是给\"曼哈顿计划\"跑模拟\n\nThe brains of these huge electro-mechanical beasts were relays:\n这台机器的大脑是\"继电器\"\n\nelectrically-controlled mechanical switches.\n继电器是：用电控制的机械开关\n\nIn a relay, there is a control wire that determines whether a circuit is opened or closed.\n继电器里，有根\"控制线路\"，控制电路是开还是关\n\nThe control wire connects to a coil of wire inside the relay.\n\"控制线路\" 连着一个线圈\n\nWhen current flows through the coil, an electromagnetic field is created,\n当电流流过线圈，线圈产生电磁场\n\nwhich in turn, attracts a metal arm inside the relay, snapping it shut and completing the circuit.\n吸引金属臂，从而闭合电路\n\nYou can think of a relay like a water faucet.\n你可以把继电器 想成水龙头\n\nThe control wire is like the faucet handle.\n把控制线路 想成水龙头把\n\nOpen the faucet, and water flows through the pipe.\n打开水龙头，水会流出来\n\nClose the faucet, and the flow of water stops.\n关闭水龙头，水就没有了\n\nRelays are doing the same thing, just with electrons instead of water.\n继电器是一样的，只不过控制的是电子  而不是水\n\nThe controlled circuit can then connect to other circuits, or to something like a motor,\n这个控制电路可以连到其他电路，比如马达\n\nwhich might increment a count on a gear,\n马达让计数齿轮 +1\n\nlike in Hollerith's tabulating machine we talked about last episode.\n就像上集中 Hollerith 的制表机一样\n\nUnfortunately, the mechanical arm inside of a relay *has mass*,\n不幸的是，继电器内的机械臂 *有质量*\n\nand therefore can't move instantly between opened and closed states.\n因此无法快速开关\n\nA good relay in the 1940's might be able to flick back and forth fifty times in a second.\n1940 年代一个好的继电器 1 秒能翻转 50 次\n\nThat might seem pretty fast, but it's not fast enough to be useful at solving large, complex problems.\n看起来好像很快，但还不够快，不足以解决复杂的大问题\n\nThe Harvard Mark I could do 3 additions or subtractions per second;\n哈佛马克一号，1 秒能做 3 次加法或减法运算\n\nmultiplications took 6 seconds, and divisions took 15.\n一次乘法要花 6 秒，除法要花 15 秒\n\nAnd more complex operations, like a trigonometric function, could take over a minute.\n更复杂的操作 比如三角函数，可能要一分钟以上\n\nIn addition to slow switching speed, another limitation was wear and tear.\n除了速度慢，另一个限制是齿轮磨损\n\nAnything mechanical that moves will wear over time.\n任何会动的机械都会随时间磨损\n\nSome things break entirely, and other things start getting sticky, slow, and just plain unreliable.\n有些部件会完全损坏，有些则是变黏，变慢，变得不可靠\n\nAnd as the number of relays increases, the probability of a failure increases too.\n并且随着继电器数量增加，故障概率也会增加\n\nThe Harvard Mark I had roughly 3500 relays.\n哈佛马克一号 有大约 3500 个继电器\n\nEven if you assume a relay has an operational life of 10 years,\n哪怕假设继电器的使用寿命是 10 年\n\nthis would mean you'd have to replace, on average, one faulty relay every day!\n也意味着平均每天得换一个故障继电器！\n\nThat's a big problem when you are in the middle of running some important, multi-day calculation.\n这个问题很严重，因为有些重要运算要运行好几天\n\nAnd that's not all engineers had to contend with.\n而且还有更多其他问题要考虑\n\nThese huge, dark, and warm machines also attracted insects.\n这些巨大，黑色，温暖的机器也会吸引昆虫\n\nIn September 1947, operators on the Harvard Mark II pulled a dead moth from a malfunctioning relay.\n1947年9月，哈佛马克2型的操作员从故障继电器中，拔出一只死虫\n\nGrace Hopper who we'll talk more about in a later episode noted,\nGrace Hopper（这位我们以后还会提到）曾说\n\n\"From then on, when anything went wrong with a computer,\n\"从那时起，每当电脑出了问题，\n\nwe said it had bugs in it.\"\n我们就说它出了 bug（虫子）\"\n\nAnd that's where we get the term computer bug.\n这就是术语 \"bug\" 的来源\n\nIt was clear that a faster, more reliable alternative to electro-mechanical relays was needed\n显然，如果想进一步提高计算能力\n\nif computing was going to advance further,\n我们需要更快更可靠的东西，来替代继电器\n\nand fortunately that alternative already existed!\n幸运的是，替代品已经存在了！\n\nIn 1904, English physicist John Ambrose Fleming\n在 1904 年，英国物理学家 \"约翰·安布罗斯·弗莱明\"\n\ndeveloped a new electrical component called a thermionic valve,\n开发了一种新的电子组件，叫\"热电子管\"\n\nwhich housed two electrodes inside an airtight glass bulb\n把两个电极装在一个气密的玻璃灯泡里\n\n- this was the first vacuum tube.\n-这是世上第一个真空管\n\nOne of the electrodes could be heated, which would cause it to emit electrons\n其中一个电极可以加热，从而发射电子\n\n– a process called thermionic emission.\n-这叫 \"热电子发射\"\n\nThe other electrode could then attract these electrons to create the flow of our electric faucet,\n另一个电极会吸引电子，形成\"电龙头\"的电流\n\nbut only if it was positively charged\n但只有带正电才行\n\n- if it had a negative or neutral charge, the electrons would no longer be attracted across the vacuum\n- 如果带负电荷或中性电荷，电子就没办法被吸引，越过真空区域\n\nso no current would flow.\n因此没有电流\n\nAn electronic component that permits the one-way flow of current is called a diode,\n电流只能单向流动的电子部件叫 \"二极管\"\n\nbut what was really needed was a switch to help turn this flow on and off.\n但我们需要的是，一个能开关电流的东西\n\nLuckily, shortly after, in 1906, American inventor Lee de Forest\n幸运的是，不久之后在 1906 年，美国发明家 \"李·德富雷斯特\"\n\nadded a third \"control\" electrode that sits between the two electrodes in Fleming's design.\n他在\"弗莱明\"设计的两个电极之间，加入了第三个 \"控制\" 电极\n\nBy applying a positive charge to the control electrode, it would permit the flow of electrons as before.\n向\"控制\"电极施加正电荷，它会允许电子流动\n\nBut if the control electrode was given a negative charge,\n但如果施加负电荷\n\nit would prevent the flow of electrons.\n它会阻止电子流动\n\nSo by manipulating the control wire, one could open or close the circuit.\n因此通过控制线路，可以断开或闭合电路\n\nIt's pretty much the same thing as a relay\n和继电器的功能一样\n\n- but importantly, vacuum tubes have no moving parts.\n- 但重要的是，真空管内没有会动的组件\n\nThis meant there was less wear,\n这意味着更少的磨损\n\nand more importantly, they could switch thousands of times per second.\n更重要的是，每秒可以开闭数千次\n\nThese triode vacuum tubes would become the basis of radio, long distance telephone,\n因此这些\"三极真空管\"成为了无线电，长途电话\n\nand many other electronic devices for nearly a half century.\n以及其他电子设备的基础，持续了接近半个世纪\n\nI should note here that vacuum tubes weren't perfect\n我应该提到，真空管不是完美的\n\n- they're kind of fragile, and can burn out like light bulbs,\n-它们有点脆弱，并且像灯泡一样会烧坏\n\nthey were a big improvement over mechanical relays.\n但比起机械继电器是一次巨大进步\n\nAlso, initially vacuum tubes were expensive\n起初，真空管非常昂贵\n\n– a radio set often used just one,\n收音机一般只用一个\n\nbut a computer might require hundreds or thousands of electrical switches.\n但计算机可能要上百甚至上千个电气开关\n\nBut by the 1940s,\n但到了 1940 年代\n\ntheir cost and reliability had improved to the point where they became feasible for use in computers….\n它的成本和可靠性得到改进，可以用在计算机里\n\nat least by people with deep pockets, like governments.\n至少有钱人负担得起，比如政府\n\nThis marked the shift from electro-mechanical computing to electronic computing.\n这标志着计算机 从机电转向电子\n\nLet's go to the Thought Bubble.\n我们来进入思想泡泡\n\nThe first large-scale use of vacuum tubes for computing was the Colossus MK 1,\n第一个大规模使用真空管的计算机是 \"巨人1号\"\n\ndesigned by engineer Tommy Flowers and completed in December of 1943.\n由工程师 Tommy Flowers 设计，完工于1943年12月\n\nThe Colossus was installed at Bletchley Park, in the UK,\n巨人1号 在英国的\"布莱切利园\", 用于破解纳粹通信\n\nand helped to decrypt Nazi communications.\n巨人1号 在英国的\"布莱切利园\", 用于破解纳粹通信\n\nThis may sound familiar because two years prior Alan Turing,\n听起来可能有点熟，因为 2 年前 阿兰·图灵\n\noften called the father of computer science,\n他经常被称为\"计算机科学之父\"\n\nhad created an electromechanical device, also at Bletchley Park, called the Bombe.\n图灵也在\"布莱切利园\"做了台机电装置，叫 \"Bombe\"\n\nIt was an electromechanical machine designed to break Nazi Enigma codes,\n这台机器的设计目的是  破解纳粹\"英格码\"通讯加密设备\n\nbut the Bombe wasn't technically a computer,\n但 Bombe 严格来说不算计算机\n\nand we'll get to Alan Turing's contributions later.\n我们之后会讨论\"阿兰·图灵\"的贡献\n\nAnyway, the first version of Colossus contained 1,600 vacuum tubes,\n总之，巨人1号有 1600 个真空管\n\nand in total, ten Colossi were built to help with code-breaking.\n总共造了 10 台巨人计算机，来帮助破解密码\n\nColossus is regarded as the first programmable, electronic computer.\n巨人 被认为是第一个可编程的电子计算机\n\nProgramming was done by plugging hundreds of wires into plugboards,\n编程的方法是把几百根电线插入插板\n\nsort of like old school telephone switchboards,\n有点像老电话交换机\n\nin order to set up the computer to perform the right operations.\n这是为了让计算机执行正确操作\n\nSo while \"programmable\", it still had to be configured to perform a specific computation.\n虽然\"可编程\" ，但还是要配置它\n\nEnter the The Electronic Numerical Integrator and Calculator - or ENIAC -\n电子数值积分计算机 \"ENIAC\"\n\ncompleted a few years later in 1946 at the University of Pennsylvania.\n几年后在 1946 年，在\"宾夕法尼亚大学\"完成建造\n\nDesigned by John Mauchly and J. Presper Eckert,\n设计者是 John Mauchly 和 J. Presper Eckert\n\nthis was the world's first truly general purpose, programmable, electronic computer.\n这是世上第一个真正的通用，可编程，电子计算机\n\nENIAC could perform 5000 ten-digit additions or subtractions per second,\nENIAC 每秒可执行 5000 次十位数加减法\n\nmany, many times faster than any machine that came before it.\n比前辈快了很多倍\n\nIt was operational for ten years,\n它运作了十年\n\nand is estimated to have done more arithmetic than the entire human race up to that point.\n据估计，它完成的运算，比全人类加起来还多\n\nBut with that many vacuum tubes failures were common,\n因为真空管很多，所以故障很常见\n\nand ENIAC was generally only operational for about half a day at a time before breaking down.\nENIAC 运行半天左右就会出一次故障\n\nThanks Thought Bubble.\n谢了 思想泡泡\n\nBy the 1950's, even vacuum-tube-based computing was reaching its limits.\n到 1950 年代，真空管计算机都达到了极限\n\nThe US Air Force's AN/FSQ-7 computer, which was completed in 1955,\n美国空军的 AN/FSQ-7 计算机于 1955 年完成\n\nwas part of the \"SAGE\" air defense computer system,\n是 \"SAGE\" 防空计算机系统的一部分\n\nwhich we'll talk more about in a later episode.\n之后的视频还会提到.\n\nTo reduce cost and size, as well as improve reliability and speed,\n为了降低成本和大小，同时提高可靠性和速度\n\na radical new electronic switch would be needed.\n我们需要一种新的电子开关\n\nIn 1947, Bell Laboratory scientists John Bardeen, Walter Brattain, and William Shockley\n1947 年，贝尔实验室科学家 \\N John Bardeen，Walter Brattain，William Shockley\n\ninvented the transistor,\n发明了晶体管\n\nand with it, a whole new era of computing was born!\n一个全新的计算机时代诞生了！\n\nThe physics behind transistors is pretty complex, relying on quantum mechanics,\n晶体管的物理学相当复杂，牵扯到量子力学\n\nso we're going to stick to the basics.\n所以我们只讲基础\n\nA transistor is just like a relay or vacuum tube\n晶体管 就像之前提过的\"继电器\"或\"真空管\"\n\n- it's a switch that can be opened or closed by applying electrical power via a control wire.\n-它是一个开关，可以用控制线路来控制开或关\n\nTypically, transistors have two electrodes separated by a material that sometimes can conduct electricity,\n晶体管有两个电极，\\N 电极之间有一种材料隔开它们，这种材料有时候导电\n\nand other times resist it\n有时候不导电\n\n- a semiconductor.\n- 这叫\"半导体\"\n\nIn this case, the control wire attaches to a \"gate\" electrode.\n控制线连到一个 \"门\" 电极\n\nBy changing the electrical charge of the gate,\n通过改变 \"门\" 的电荷\n\nthe conductivity of the semiconducting material can be manipulated,\n我们可以控制半导体材料的导电性\n\nallowing current to flow or be stopped\n来允许或不允许 电流流动\n\n- like the water faucet analogy we discussed earlier.\n- 就像之前的水龙头比喻\n\nEven the very first transistor at Bell Labs showed tremendous promise\n贝尔实验室的第一个晶体管就展示了巨大的潜力\n\n- it could switch between on and off states 10,000 times per second.\n每秒可以开关 10,000 次\n\nFurther, unlike vacuum tubes made of glass and with carefully suspended, fragile components,\n而且，比起玻璃制成，小心易碎的真空管\n\ntransistors were solid material known as a solid state component.\n晶体管是固态的\n\nAlmost immediately, transistors could be made smaller than the smallest possible relays or vacuum tubes.\n晶体管可以远远小于继电器或真空管\n\nThis led to dramatically smaller and cheaper computers, like the IBM 608, released in 1957\n导致更小更便宜的计算机，比如1957年发布的IBM 608\n\n– the first fully transistor-powered, commercially-available computer.\n- 第一个完全用晶体管，而且消费者也可以买到的计算机\n\nIt contained 3000 transistors and could perform 4,500 additions,\n它有 3000 个晶体管，每秒执行 4500 次加法\n\nor roughly 80 multiplications or divisions, every second.\n每秒能执行 80 次左右的乘除法\n\nIBM soon transitioned all of its computing products to transistors,\nIBM 很快把所有产品都转向了晶体管\n\nbringing transistor-based computers into offices, and eventually, homes.\n把晶体管计算机带入办公室，最终引入家庭\n\nToday, computers use transistors that are smaller than 50 nanometers in size\n如今，计算机里的晶体管小于 50 纳米\n\n- for reference, a sheet of paper is roughly 100,000 nanometers thick.\n- 而一张纸的厚度大概是 10 万纳米\n\nAnd they're not only incredibly small, they're super fast\n晶体管不仅小，还超级快\n\n- they can switch states millions of times per second, and can run for decades.\n- 每秒可以切换上百万次，并且能工作几十年\n\nA lot of this transistor and semiconductor development happened\n很多晶体管和半导体的开发在\"圣克拉拉谷\"\n\nin the Santa Clara Valley, between San Francisco and San Jose, California.\n这个地方在加州，位于\"旧金山\"和\"圣荷西\"之间\n\nAs the most common material used to create semiconductors is silicon,\n而生产半导体最常见的材料是 \"硅\"\n\nthis region soon became known as Silicon Valley.\n所以这个地区被称为 \"硅谷\"\n\nEven William Shockley moved there, founding Shockley Semiconductor,\n甚至 William Shockley 都搬了过去，创立了\"肖克利半导体\"\n\nwhose employees later founded Fairchild Semiconductors,\n里面的员工后来成立了\"仙童半导体\"\n\nwhose employees later founded Intel - the world's largest computer chip maker today.\n这里面的员工后来创立了英特尔 - 当今世界上最大的计算机芯片制造商\n\nOk, so we've gone from relays to vacuum tubes to transistors.\n好了，我们从\"继电器\"到\"真空管\"到\"晶体管\"\n\nWe can turn electricity on and off really, really, really fast.\n我们可以让电路开闭得非常非常快\n\nBut how do we get from transistors to actually computing something,\n但我们是如何用晶体管做计算的？\n\nespecially if we don't have motors and gears?\n我们没有马达和齿轮啊？\n\nThat's what we're going to cover over the next few episodes.\n我们接下来几集会讲\n\nThanks for watching. See you next week.\n感谢观看 下周见\n\nHi, I'm Carrie Anne and welcome to Crash Course Computer Science!\n嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nToday we start our journey up the ladder of abstraction,\n今天我们开始\"抽象\"的旅程\n\nwhere we leave behind the simplicity of being able to see every switch and gear,\n不用管底层细节，把精力用来构建更复杂的系统\n\nbut gain the ability to assemble increasingly complex systems.\n不用管底层细节，把精力用来构建更复杂的系统\n\nLast episode, we talked about how computers evolved from electromechanical devices,\n上集，我们谈了计算机最早是机电设备\n\nthat often had decimal representations of numbers\n一般用十进制计数\n\n- like those represented by teeth on a gear\n- 比如用齿轮数来代表十进制\n\n- to electronic computers with transistors that can turn the flow of electricity on or off.\n- 再到晶体管计算机\n\nAnd fortunately, even with just two states of electricity,\n幸运的是，只用 开/关 两种状态也可以代表信息\n\nwe can represent important information.\n幸运的是，只用 开/关 两种状态也可以代表信息\n\nWe call this representation Binary\n这叫 二进制\n\n-- which literally means \"of two states\",\n- 意思是\"用两种状态表示\"\n\nin the same way a bicycle has two wheels or a biped has two legs.\n就像自行车有两个轮，双足动物有两条腿\n\nYou might think two states isn't a lot to work with, and you'd be right!\n你可能觉得两种状态不多，你是对的！\n\nBut, it's exactly what you need for representing the values \"true\" and \"false\".\n但如果只需要表示 true 和 false，两个值就够了\n\nIn computers, an \"on\" state, when electricity is flowing, represents true.\n电路闭合，电流流过，代表 \"真\"\n\nThe off state, no electricity flowing, represents false.\n电路断开，无电流流过，代表\"假\"\n\nWe can also write binary as 1's and 0's instead of true's and false's\n二进制也可以写成 1 和 0 而不是 true 和 false\n\n- they are just different expressions of the same signal\n- 只是不同的表达方式罢了\n\n- but we'll talk more about that in the next episode.\n- 我们下集会讲更多细节\n\nNow it is actually possible to use transistors for more than just turning electrical current on and off,\n晶体管的确可以不只是 开/关，还可以让不同大小的电流通过\n\nand to allow for different levels of current.\n晶体管的确可以不只是 开/关，还可以让不同大小的电流通过\n\nSome early electronic computers were ternary, that's three states,\n一些早期电子计算机是三进制的，有 3 种状态\n\nand even quinary, using 5 states.\n甚至五进制，5 种状态\n\nThe problem is, the more intermediate states there are,\n问题是，状态越多，越难区分信号\n\nthe harder it is to keep them all seperate\n问题是，状态越多，越难区分信号\n\n-- if your smartphone battery starts running low or there's electrical noise\n- 如果手机快没电了或者附近有电噪音\n\nbecause someone's running a microwave nearby,\n因为有人在用微波炉，\n\nthe signals can get mixed up...\n信号可能会混在一起...\n\nand this problem only gets worse with transistors changing states millions of times per second!\n而每秒百万次变化的晶体管会让这个问题变得更糟！\n\nSo, placing two signals as far apart as possible\n所以我们把两种信号尽可能分开\n\n- using just 'on and off' - gives us the most distinct signal to minimize these issues.\n- 只用\"开\"和\"关\"两种状态，可以尽可能减少这类问题\n\nAnother reason computers use binary\n计算机用二进制的另一个原因是\n\nis that an entire branch of mathematics already existed that dealt exclusively with true and false values.\n有一整个数学分支存在，专门处理\"真\"和\"假\"\n\nAnd it had figured out all of the necessary rules and operations for manipulating them.\n它已经解决了所有法则和运算\n\nIt's called Boolean Algebra!\n叫\"布尔代数\"！\n\nGeorge Boole, from which Boolean Algebra later got its name,\n乔治·布尔（George Boole）是布尔二字的由来\n\nwas a self-taught English mathematician in the 1800s.\n是一位 19 世纪自学成才的英国数学家\n\nHe was interested in representing logical statements that went \"under, over, and beyond\"\n他有兴趣用数学式子 扩展亚里士多德基于哲学的逻辑方法\n\nAristotle's approach to logic, which was, unsurprisingly, grounded in philosophy.\n他有兴趣用数学式子 扩展亚里士多德基于哲学的逻辑方法\n\nBoole's approach allowed truth to be systematically and formally proven, through logic equations\n布尔用 逻辑方程 系统而正式的证明真理(truth)\n\nwhich he introduced in his first book, \"The Mathematical Analysis of Logic\" in 1847.\n他在 1847 年的第一本书\"逻辑的数学分析\"中介绍过\n\nIn \"regular\" algebra -- the type you probably learned in high school -- the values of variables\n在\"常规\"代数里 - 你在高中学的那种 - 变量的值\n\nare numbers, and operations on those numbers are things like addition and multiplication.\n是数字，可以进行加法或乘法之类的操作\n\nBut in Boolean Algebra, the values of variables are true and false, and the operations are logical.\n但在布尔代数中，变量的值是 true 和 false，\\N 能进行逻辑操作\n\nThere are three fundamental operations in Boolean Algebra: a NOT, an AND, and an OR operation.\n布尔代数中有三个基本操作：NOT, AND 和 OR\n\nAnd these operations turn out to be really useful so we're going to look at them individually.\n这些操作非常有用，我们一个个来看\n\nA NOT takes a single boolean value, either true or false, and negates it.\nNOT 操作把布尔值反转，\\N把 true 进行 NOT 就会变成 false，反之亦然\n\nIt flips true to false, and false to true.\nNOT 操作把布尔值反转，\\N把 true 进行 NOT 就会变成 false，反之亦然\n\nWe can write out a little logic table that shows the original value under Input,\n我们可以根据 NOT 操作的输入和输出，做出这个表\n\nand the outcome after applying the operation under Output.\n我们可以根据 NOT 操作的输入和输出，做出这个表\n\nNow here's the cool part -- we can easily build boolean logic out of transistors.\n酷的地方是 - 用晶体管可以轻松实现这个逻辑\n\nAs we discussed last episode, transistors are really just little electrically controlled switches.\n上集说过，晶体管只是电控制的开关\n\nThey have three wires: two electrodes and one control wire.\n有 3 根线：2 根电极和 1 根控制线\n\nWhen you apply electricity to the control wire,\n控制线通电时\n\nit lets current flow through from one electrode, through the transistor, to the other electrode.\n电流就可以从一个电极流到另一个电极\n\nThis is a lot like a spigot on a pipe\n就像水龙头一样\n\n-- open the tap, water flows,\n- 打开水龙头，就有水流出来\n\nclose the tap, water shuts off.\n关掉水龙头，就没水了\n\nYou can think of the control wire as an input,\n可以把控制线，当做输入 ( input ) \\N 底部的电极，当做输出（output）\n\nand the wire coming from the bottom electrode as the output.\n可以把控制线，当做输入 ( input ) \\N 底部的电极，当做输出（output）\n\nSo with a single transistor, we have one input and one output.\n所以 1 个晶体管，有一个输入和一个输出\n\nIf we turn the input on, the output is also on because the current can flow through it.\n如果我们打开输入（input on) \\N 输出也会打开（output on） \\N 因为电流可以流过\n\nIf we turn the input off, the output is also off and the current can no longer pass through.\n如果关闭输入（input off） \\N 输出也会关闭（output off）\\N 因为电流无法通过\n\nOr in boolean terms, when the input is true, the output is true.\n或者用布尔术语来说\\N 输入为 真，输出为 真\n\nAnd when the input is false, the output is also false.\n输入为 假 \\N 输出为 假\n\nWhich again we can show on a logic table.\n我们也可以把这个做成\"真值表\"\n\nThis isn't a very exciting circuit though because its not doing anything\n这个电路没什么意思，因为它没做什么事\n\n-- the input and output are the same.\n- 输入和输出是一样的\n\nBut, we can modify this circuit just a little bit to create a NOT.\n但我们可以稍加修改，实现 NOT\n\nInstead of having the output wire at the end of the transistor, we can move it before.\n与其把下面那根线当做 输出，我们可以把 输出 放到上面\n\nIf we turn the input on, the transistor allows current to pass through it to the \"ground\",\n如果打开 输入，电流可以流过然后 \"接地\"\n\nand the output wire won't receive that current\n输出就没有电流，所以输出是 off\n\n- so it will be off.\n输出就没有电流，所以输出是 off\n\nIn our water metaphor grounding would be like\n如果用水来举例\n\nif all the water in your house was flowing out of a huge hose\n就像家里的水都从一个大管子流走了\n\nso there wasn't any water pressure left for your shower.\n打开淋浴头一点水也没有\n\nSo in this case if the input is on, output is off.\n如果输入是 on，输出是 off\n\nWhen we turn off the transistor, though, current is prevented from flowing down it to the ground,\n当输入是 off，电流没法接地，就流过了输出，所以输出是 on\n\nso instead, current flows through the output wire.\n当输入是 off，电流没法接地，就流过了输出，所以输出是 on\n\nSo the input will be off and the output will be on.\n如果输入是 off，输出是 on\n\nAnd this matches our logic table for NOT, so congrats, we just built a circuit that computes NOT!\n和 NOT 操作表一样！太棒了！我们做了个有点用的电路！\n\nWe call them NOT gates - we call them gates because they're controlling the path of our current.\n我们叫它 \"NOT 门\" \\N 之所以叫 \"门\"，是因为它能控制电流的路径\n\nThe AND Boolean operation takes two inputs, but still has a single output.\n\"AND\"操作有 2 个输入，1 个输出\n\nIn this case the output is only true if both inputs are true.\n如果 2 个输入都是 true，输出才是 true\n\nThink about it like telling the truth.\n你可以想成是 说真话\n\nYou're only being completely honest if you don't lie even a little.\n如果完全不说谎，才是诚实\n\nFor example, let's take the statement,\n举例，看如下这个句子\n\n\"My name is Carrie Anne AND I'm wearing a blue dress\".\n我叫 Carrie Anne \"而且\"我穿着蓝色的衣服\n\nBoth of those facts are true, so the whole statement is true.\n2 个都是真的，所以整个是真的\n\nBut if I said, \"My name is Carrie Anne AND I'm wearing pants\" that would be false,\n但如果说，我叫 Carrie Anne\"而且\"我穿了裤子, 就是假的\n\nbecause I'm not wearing pants.\n因为我没穿裤子\n\nOr trousers.\n或长裤，如果你是英国人你会用这个词……（英/美单词不同梗）\n\nIf you're in England.\n或长裤，如果你是英国人你会用这个词……（英/美单词不同梗）\n\nThe Carrie Anne part is true, but a true AND a false, is still false.\n虽然前半句是真的，但是 真 \"AND\" 假，还是假\n\nIf I were to reverse that statement it would still obviously be false,\n就算把前后顺序反过来，也依然是 假\n\nand if I were to tell you two complete lies that is also false,\n如果我说 2 个假的事情，那么结果是假。\n\nand again we can write all of these combinations out in a table.\n和上次一样，可以给\"AND\"做个表\n\nTo build an AND gate, we need two transistors connected together\n为了实现 \"AND 门\"，我们需要 2 个晶体管连在一起\n\nso we have our two inputs and one output.\n这样有 2 个输入和 1 个输出\n\nIf we turn on just transistor A, current won't flow because the current is stopped by transistor B.\n如果只打开 A，不打开 B \\N 电流无法流到 output，所以输出是 false\n\nAlternatively, if transistor B is on, but the transistor A is off,\n如果只打开 B，不打开 A ，也一样，电流无法流到 output\n\nthe same thing, the current can't get through.\n如果只打开 B，不打开 A ，也一样，电流无法流到 output\n\nOnly if transistor A AND transistor B are on does the output wire have current.\n只有 A 和 B 都打开了，output 才有电流\n\nThe last boolean operation is OR\n最后一个是 OR （前面讲了 NOT 和 AND)\n\n-- where only one input has to be true for the output to be true.\n只要 2 个输入里，其中 1 个是 true，输出就是 true\n\nFor example, my name is Margaret Hamilton OR I'm wearing a blue dress.\n比如，我叫 Margaret Hamilton\"或\"我穿着蓝色衣服\n\nThis is a true statement because although I'm not Margaret Hamilton unfortunately,\n结果是 true，虽然我不是 Margaret Hamilton\n\nI am wearing a blue dress, so the overall statement is true.\n但是我穿着蓝色衣服，所以结果是 true\n\nAn OR statement is also true if both facts are true.\n对于\"OR 操作\"来说，\\N如果 2 个 输入都是 true，输出也是 true\n\nThe only time an OR statement is false is if both inputs are false.\n只有 2 个输入都是 false，OR 的结果才是 false\n\nBuilding an OR gate from transistors needs a few extra wires.\n实现 \"OR 门\" 除了晶体管还要额外的线\n\nInstead of having two transistors in series -- one after the other --\n不是串联起来。而是并联\n\nwe have them in parallel.\n不是串联起来。而是并联\n\nWe run wires from the current source to both transistors.\n然后左边这条线有电流输入\n\nWe use this little arc to note that the wires jump over one another and aren't connected,\n我们用\"小拱门\"代表 2 条线没连在一起，只是跨过而已\n\neven though they look like they cross.\n虽然看起来像连在一起\n\nIf both transistors are turned off, the current is prevented from flowing to the output,\n如果 A 和 B 都是 off，电流无法流过\n\nso the output is also off.\n所以输出是 off\n\nNow, if we turn on just Transistor A, current can flow to the output.\n如果打开 A，电流可以流过。输出是 on\n\nSame thing if transistor A is off, but Transistor B in on.\n如果只打开 B 也一样\n\nBasically if A OR B is on, the output is also on.\n只要 A OR B 是 on， 输出就是 on\n\nAlso, if both transistors are on, the output is still on.\n如果 A 和 B 都 on，结果是 on\n\nOk, now that we've got NOT, AND, and OR gates,\n好，现在 NOT 门, AND 门, OR 门 都搞定了\n\nand we can leave behind the constituent transistors and move up a layer of abstraction.\n我们可以进行一次抽象\n\nThe standard engineers use for these gates are a triangle with a dot for a NOT,\nNOT 门的画法是三角形前面一个圆点\n\na D for the AND, and a spaceship for the OR.\nAND 门用 D 表示 ，OR 门用太空船表示\n\nThose aren't the official names, but that's howI like to think of them.\n\"D 形状和太空船\"不是标准叫法, 只是我喜欢这样叫而已\n\nRepresenting them and thinking about them this way allows us to build even bigger components\n我们可以用这种方法表示它们，构建更大的组件\n\nwhile keeping the overall complexity relatively the same\n就不会变得很复杂\n\n- just remember that that mess of transistors and wires is still there.\n- 晶体管和电线依然在那里，我们只是用符号来代表而已\n\nFor example, another useful boolean operation in computation is called an Exclusive OR\n除了前面说的三个\\N 另一个有用的布尔操作叫 \"异或\"\n\n- or XOR for short.\n- 简称 XOR\n\nXOR is like a regular OR, but with one difference:\nXOR 就像普通 OR，但有一个区别：\n\nif both inputs are true, the XOR is false.\n如果 2 个输入都是 true，XOR 输出 false\n\nThe only time an XOR is true is when one input is true and the other input is false.\n想要 XOR 输出 true \\N 一个输入必须是 true，另一个必须是 false\n\nIt's like when you go out to dinner and your meal comes with a side salad OR a soup\n就像你出去吃晚饭，你点的饭要么配沙拉，要么配汤\n\n- sadly, you can't have both!\n- 你不能两个都要！\n\nAnd building this from transistors is pretty confusing,\n用晶体管实现 XOR 门有点烧脑子\n\nbut we can show how an XOR is created from our three basic boolean gates.\n但我可以展示一下\\N 怎么用前面提到的 3 种门来做 XOR 门\n\nWe know we have two inputs again -- A and B -- and one output.\n我们有 2 个输入，A 和 B ，还有 1 个输出.\n\nLet's start with an OR gate, since the logic table looks almost identical to an OR.\n我们先放一个 OR 门. 因为 OR 和 XOR 的逻辑表很像\n\nThere's only one problem - when A and B are true, the logic is different from OR,\n只有 1 个问题 - 当 A 和 B 都是 true 时 \\N OR 的输出和想要的 XOR 输出不一样\n\nand we need to output \"false\".\n我们想要 false\n\nAnd XOR turns out to be a very useful component,\nXOR 超有用的\n\nand we'll get to it in another episode,\n我们下次再说它\n\nso useful in fact engineers gave it its own symbol too -- an OR gate with a smile :)\n因为超有用，\\N 工程师给了它一个符号，一个 OR 门 + 一个笑脸\n\nBut most importantly, we can now put XOR into our metaphorical toolbox\n重要的是，现在可以把 XOR 放入\"工具箱\"了\n\nand not have to worry about the individual logic gates that make it up,\n不用担心 XOR 具体用了几个门\n\nor the transistors that make up those gates,\n这几个门又是怎么用晶体管拼的\n\nor how electrons are flowing through a semiconductor.\n或电子是怎么流过半导体的\n\nMoving up another layer of abstraction.\n再次向上抽象\n\nWhen computer engineers are designing processors, they rarely work at the transistor level,\n工程师设计处理器时，很少在晶体管的层面上思考，\n\nand instead work with much larger blocks, like logic gates, and even larger components\n而是用更大的组件，比如逻辑门，或者由逻辑门组成的更大组件，\n\nmade up of logic gates, which we'll discuss in future episodes.\n我们以后会讲\n\nAnd even if you are a professional computer programmer,\n就算是专业程序员\n\nit's not often that you think about\n也不用考虑逻辑是怎样在物理层面实现的\n\nhow the logic that you are programming is actually implemented\n也不用考虑逻辑是怎样在物理层面实现的\n\nin the physical world by these teeny tiny components.\n也不用考虑逻辑是怎样在物理层面实现的\n\nWe've also moved from thinking about raw electrical signals to our first representation of data\n我们从电信号开始，到现在第一次表示数据\n\n- true and false - and we've even gotten a little taste of computation.\n- 真和假 - 开始有点\"计算\"的感觉了\n\nWith just the logic gates in this episode,\n仅用这集讲的 逻辑门\n\nwe could build a machine that evaluates complex logic statements,\n我们可以判断复杂的语句 比如：\n\nlike if \"Name is John Green AND after 5pm OR is Weekend AND near Pizza Hut\",\n[如果是 John Green] AND [下午 5 点后] \\N OR [周末] AND [在比萨店附近]\n\nthen \"John will want pizza\" equals true.\n那么 \"John 想要比萨\" = 真\n\nAnd with that, I'm starving, I'll see you next week.\n我都说饿了，下周见\n\nHi I'm Carrie Anne, this is Crash Course Computer Science\n嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nand today we're going to talk about how computers store and represent numerical data.\n今天，我们讲计算机如何存储和表示数字\n\nWhich means we've got to talk about Math!\n所以会有一些数学\n\nBut don't worry.\n不过别担心\n\nEvery single one of you already knows exactly what you need to know to follow along.\n你们的数学水平绝对够用了\n\nSo, last episode we talked about how transistors can be used to build logic gates,\n上集我们讲了，怎么用晶体管做逻辑门\n\nwhich can evaluate boolean statements.\n逻辑门可以判断布尔语句\n\nAnd in boolean algebra, there are only two, binary values: true and false.\n布尔代数只有两个值：True 和 False\n\nBut if we only have two values,\n但如果只有两个值，我们怎么表达更多东西？\n\nhow in the world do we represent information beyond just these two values?\n但如果只有两个值，我们怎么表达更多东西？\n\nThat's where the Math comes in.\n这就需要数学了\n\nSo, as we mentioned last episode, a single binary value can be used to represent a number.\n上集提到，1 个二进制值可以代表 1 个数\n\nInstead of true and false, we can call these two states 1 and 0 which is actually incredibly useful.\n我们可以把真和假 ，当做 1 和 0\n\nAnd if we want to represent larger things we just need to add more binary digits.\n如果想表示更多东西，加位数就行了\n\nThis works exactly the same way as the decimal numbers that we're all familiar with.\n和我们熟悉的十进制一样\n\nWith decimal numbers there are \"only\" 10 possible values a single digit can be; 0 through 9,\n十进制只有 10 个数（0到9）\n\nand to get numbers larger than 9 we just start adding more digits to the front.\n要表示大于 9 的数，加位数就行了\n\nWe can do the same with binary.\n二进制也可以这样玩\n\nFor example, let's take the number two hundred and sixty three.\n拿 263 举例\n\nWhat does this number actually represent?\n这个数字 \"实际\" 代表什么？\n\nWell, it means we've got 2 one-hundreds, 6 tens, and 3 ones.\n2 个 100 \\N6 个 10 \\N 3 个 1\n\nIf you add those all together, we've got 263.\n加在一起，就是 263\n\nNotice how each column has a different multiplier.\n注意每列有不同的乘数\n\nIn this case, it's 100, 10, and 1.\n100, 10, 1\n\nEach multiplier is ten times larger than the one to the right.\n每个乘数都比右边大十倍\n\nThat's because each column has ten possible digits to work with, 0 through 9,\n因为每列有 10 个可能的数字（0到9）\n\nafter which you have to carry one to the next column.\n如果超过 9，要在下一列进 1.\n\nFor this reason, it's called base-ten notation, also called decimal since deci means ten.\n因此叫 \"基于十的表示法\"  或十进制\n\nAND Binary works exactly the same way, it's just base-two.\n二进制也一样，只不过是基于 2 而已\n\nThat's because there are only two possible digits in binary - 1 and 0.\n因为二进制只有两个可能的数， 1 和 0\n\nThis means that each multiplier has to be two times larger than the column to its right.\n意味着每个乘数必须是右侧乘数的两倍\n\nInstead of hundreds, tens, and ones, we now have fours, twos and ones.\n就不是之前的 100, 10, 1 \\N 而是 4, 2, 1\n\nTake for example the binary number: 101.\n拿二进制数 101 举例\n\nThis means we have 1 four, 0 twos, and 1 one.\n意味着有\\N 1个 \"4\"  \\N 0个 \"2\"  \\N 1个 \"1\"\n\nAdd those all together and we've got the number 5 in base ten.\n加在一起，得到十进制的 5\n\nBut to represent larger numbers, binary needs a lot more digits.\n为了表示更大的数字，二进制需要更多位数\n\nTake this number in binary 10110111.\n拿二进制数 10110111 举例\n\nWe can convert it to decimal in the same way.\n我们可以用相同的方法转成十进制\n\nWe have 1 x 128, 0 x 64, 1 x 32, 1 x 16, 0 x 8, 1 x 4, 1 x 2, and 1 x 1.\n1 x 128 ，0 x 64 ，1 x 32 ，1 x 16 \\N 0 x 8 ，1 x 4 ，1 x 2 ，1 x 1\n\nWhich all adds up to 183.\n加起来等于 183\n\nMath with binary numbers isn't hard either.\n二进制数的计算也不难\n\nTake for example decimal addition of 183 plus 19.\n以十进制数 183 加 19 举例\n\nFirst we add 3 + 9, that's 12, so we put 2 as the sum and carry 1 to the ten's column.\n首先 3 + 9，得到 12，然后位数记作 2，向前进 1\n\nNow we add 8 plus 1 plus the 1 we carried, thats 10, so the sum is 0 carry 1.\n现在算 8+1+1=10，所以位数记作0，再向前进 1\n\nFinally we add 1 plus the 1 we carried, which equals 2.\n最后 1+1=2，位数记作2\n\nSo the total sum is 202.\n所以和是202\n\nHere's the same sum but in binary.\n二进制也一样\n\nJust as before, we start with the ones column.\n和之前一样，从个位开始\n\nAdding 1+1 results in 2, even in binary.\n1+1=2，在二进制中也是如此\n\nBut, there is no symbol \"2\" so we use 10 and put 0 as our sum and carry the 1.\n但二进制中没有 2，所以位数记作 0 ，进 1\n\nJust like in our decimal example.\n就像十进制的例子一样\n\n1 plus 1, plus the 1 carried,\n1+1，再加上进位的1\n\nequals 3 or 11 in binary,\n等于 3，用二进制表示是 11\n\nso we put the sum as 1 and we carry 1 again, and so on.\n所以位数记作 1，再进 1，以此类推\n\nWe end up with this number, which is the same as the number 202 in base ten.\n最后得到这个数字，跟十进制 202 是一样的\n\nEach of these binary digits, 1 or 0, is called a \"bit\".\n二进制中，一个 1 或 0  叫一\"位\"\n\nSo in these last few examples, we were using 8-bit numbers with their lowest value of zero\n上个例子我们用了 8 位 , 8 位能表示的最小数是 0,  8位都是0\n\nand highest value is 255, which requires all 8 bits to be set to 1.\n最大数是 255，8 位都是 1\n\nThats 256 different values, or 2 to the 8th power.\n能表示 256 个不同的值，2 的 8 次方\n\nYou might have heard of 8-bit computers, or 8-bit graphics or audio.\n你可能听过 8 位机，8 位图像，8 位音乐\n\nThese were computers that did most of their operations in chunks of 8 bits.\n意思是计算机里\\N 大部分操作都是 8 位 8 位这样处理的\n\nBut 256 different values isn't a lot to work with, so it meant things like 8-bit games\n但 256 个值不算多，意味着 8位游戏只能用 256 种颜色\n\nwere limited to 256 different colors for their graphics.\n但 256 个值不算多，意味着 8位游戏只能用 256 种颜色\n\nAnd 8-bits is such a common size in computing, it has a special word: a byte.\n8 位是如此常见，以至于有专门的名字：字节\n\nA byte is 8 bits.\n1 字节 = 8 位 \\N 1 bytes = 8 bits\n\nIf you've got 10 bytes, it means you've really got 80 bits.\n如果有 10 个字节，意味着有 80 位\n\nYou've heard of kilobytes, megabytes, gigabytes and so on.\n你听过 千字节（KB）兆字节（MB）千兆字节（GB）等等\n\nThese prefixes denote different scales of data.\n不同前缀代表不同数量级\n\nJust like one kilogram is a thousand grams,\n就像 1 千克 = 1000 克，1 千字节 = 1000 字节\n\n1 kilobyte is a thousand bytes.\n就像 1 千克 = 1000 克，1 千字节 = 1000 字节\n\nor really 8000 bits.\n或 8000 位\n\nMega is a million bytes (MB), and giga is a billion bytes (GB).\nMega 是百万字节（MB）, Giga 是十亿字节（GB）\n\nToday you might even have a hard drive that has 1 terabyte (TB) of storage.\n如今你可能有 1 TB 的硬盘\n\nThat's 8 trillion ones and zeros.\n8 万亿个1和0\n\nBut hold on!\n等等，我们有另一种计算方法\n\nThat's not always true.\n等等，我们有另一种计算方法\n\nIn binary, a kilobyte has two to the power of 10 bytes, or 1024.\n二进制里，1 千字节 = 2的10次方 = 1024 字节\n\n1000 is also right when talking about kilobytes,\n1000 也是千字节（KB）的正确单位\n\nbut we should acknowledge it isn't the only correct definition.\n1000 和 1024 都对\n\nYou've probably also heard the term 32-bit or 64-bit computers\n你可能听过 32 位 或 64 位计算机\n\nyou're almost certainly using one right now.\n你现在用的电脑几乎肯定是其中一种\n\nWhat this means is that they operate in chunks of 32 or 64 bits.\n意思是一块块处理数据，每块是 32 位或 64 位\n\nThat's a lot of bits!\n这可是很多位\n\nThe largest number you can represent with 32 bits is just under 4.3 billion.\n32 位能表示的最大数，是 43 亿左右\n\nWhich is thirty-two 1's in binary.\n也就是 32 个 1\n\nThis is why our Instagram photos are so smooth and pretty\n所以 Instagram 照片很清晰\n\n- they are composed of millions of colors,\n- 它们有上百万种颜色\n\nbecause computers today use 32-bit color graphics\n因为如今都用 32 位颜色\n\nOf course, not everything is a positive number\n当然，不是所有数都是正数\n\n- like my bank account in college.\n比如我上大学时的银行账户 T_T\n\nSo we need a way to represent positive and negative numbers.\n我们需要有方法表示正数和负数\n\nMost computers use the first bit for the sign:\n大部分计算机用第一位表示正负：\n\n1 for negative, 0 for positive numbers,\n1 是负，0 是正\n\nand then use the remaining 31 bits for the number itself.\n用剩下 31 位来表示符号外的数值\n\nThat gives us a range of roughly plus or minus two billion.\n能表示的数的范围大约是正 20 亿到负 20 亿\n\nWhile this is a pretty big range of numbers, it's not enough for many tasks.\n虽然是很大的数，但许多情况下还不够用\n\nThere are 7 billion people on the earth, and the US national debt is almost 20 trillion dollars after all.\n全球有 70 亿人口，美国国债近 20 万亿美元\n\nThis is why 64-bit numbers are useful.\n所以 64 位数很有用\n\nThe largest value a 64-bit number can represent is around 9.2 quintillion!\n64 位能表达最大数大约是 9.2×10 ^ 18\n\nThat's a lot of possible numbers and will hopefully stay above the US national debt for a while!\n希望美国国债在一段时间内不会超过这个数！\n\nMost importantly, as we'll discuss in a later episode,\n重要的是（我们之后的视频会深入讲）\n\ncomputers must label locations in their memory,\n计算机必须给内存中每一个位置，做一个 \"标记\"\n\nknown as addresses, in order to store and retrieve values.\n这个标记叫 \"地址\", 目的是为了方便存取数据\n\nAs computer memory has grown to gigabytes and terabytes - that's trillions of bytes\n如今硬盘已经增长到 GB 和 TB，上万亿个字节！\n\nit was necessary to have 64-bit memory addresses as well.\n内存地址也应该有 64 位\n\nIn addition to negative and positive numbers,\n除了负数和正数，计算机也要处理非整数\n\ncomputers must deal with numbers that are not whole numbers,\n除了负数和正数，计算机也要处理非整数\n\nlike 12.7 and 3.14, or maybe even stardate: 43989.1.\n比如 12.7 和 3.14，或\"星历 43989.1\"\n\nThese are called \"floating point\" numbers,\n这叫 浮点数\n\nbecause the decimal point can float around in the middle of number.\n因为小数点可以在数字间浮动\n\nSeveral methods have been developed to represent floating point numbers.\n有好几种方法 表示浮点数\n\nThe most common of which is the IEEE 754 standard.\n最常见的是 IEEE 754 标准\n\nAnd you thought historians were the only people bad at naming things!\n你以为只有历史学家取名很烂吗？\n\nIn essence, this standard stores decimal values sort of like scientific notation.\n它用类似科学计数法的方法，来存十进制值\n\nFor example, 625.9 can be written as 0.6259 x 10^3.\n例如，625.9 可以写成 0.6259×10 ^ 3\n\nThere are two important numbers here: the .6259 is called the significand.\n这里有两个重要的数：.6259 叫 \"有效位数\" , 3 是指数\n\nAnd 3 is the exponent.\n这里有两个重要的数：.6259 叫 \"有效位数\" , 3 是指数\n\nIn a 32-bit floating point number,\n在 32 位浮点数中\n\nthe first bit is used for the sign of the number -- positive or negative.\n第 1 位表示数的符号——正或负\n\nThe next 8 bits are used to store the exponent\n接下来 8 位存指数\n\nand the remaining 23 bits are used to store the significand.\n剩下 23 位存有效位数\n\nOk, we've talked a lot about numbers, but your name is probably composed of letters,\n好了，聊够数了，但你的名字是字母组成的\n\nso it's really useful for computers to also have a way to represent text.\n所以我们也要表示文字\n\nHowever, rather than have a special form of storage for letters,\n与其用特殊方式来表示字母 \\N 计算机可以用数表示字母\n\ncomputers simply use numbers to represent letters.\n与其用特殊方式来表示字母 \\N 计算机可以用数表示字母\n\nThe most straightforward approach might be to simply number the letters of the alphabet:\n最直接的方法是给字母编号：\n\nA being 1, B being 2, C 3, and so on.\nA是1，B是2，C是3，以此类推\n\nIn fact, Francis Bacon, the famous English writer,\n著名英国作家 弗朗西斯·培根（Francis Bacon）\n\nused five-bit sequences to encode all 26 letters of the English alphabet\n曾用 5位序列 来编码英文的 26 个字母\n\nto send secret messages back in the 1600s.\n在十六世纪传递机密信件\n\nAnd five bits can store 32 possible values - so that's enough for the 26 letters,\n五位（bit）可以存 32 个可能值（2^5） - 这对26个字母够了\n\nbut not enough for punctuation, digits, and upper and lower case letters.\n但不能表示 标点符号，数字和大小写字母\n\nEnter ASCII, the American Standard Code for Information Interchange.\nASCII，美国信息交换标准代码\n\nInvented in 1963, ASCII was a 7-bit code, enough to store 128 different values.\n发明于 1963 年，ASCII 是 7 位代码，足够存 128 个不同值\n\nWith this expanded range, it could encode capital letters, lowercase letters,\n范围扩大之后，可以表示大写字母，小写字母,\n\ndigits 0 through 9, and symbols like the @ sign and punctuation marks.\n数字 0 到 9, @ 这样的符号, 以及标点符号\n\nFor example, a lowercase 'a' is represented by the number 97, while a capital 'A' is 65.\n举例，小写字母 a 用数字 97 表示，大写字母 A 是 65\n\nA colon is 58 and a closed parenthesis is 41.\n: 是58  \\n ) 是41\n\nASCII even had a selection of special command codes,\nASCII 甚至有特殊命令符号\n\nsuch as a newline character to tell the computer where to wrap a line to the next row.\n比如换行符，用来告诉计算机换行\n\nIn older computer systems,\n在老计算机系统中\n\nthe line of text would literally continue off the edge of the screen if you didn't include a new line character!\n如果没换行符，文字会超出屏幕\n\nBecause ASCII was such an early standard,\n因为 ASCII 是个很早的标准\n\nit became widely used,\n所以它被广泛使用\n\nand critically, allowed different computers built by different companies to exchange data.\n让不同公司制作的计算机，能互相交换数据\n\nThis ability to universally exchange information is called \"interoperability\".\n这种通用交换信息的能力叫 \"互操作性\"\n\nHowever, it did have a major limitation: it was really only designed for English.\n但有个限制：它是为英语设计的\n\nFortunately, there are 8 bits in a byte, not 7,\n幸运的是，一个字节有8位，而不是7位\n\nand it soon became popular to use codes 128 through 255,\n128 到 255 的字符渐渐变得常用\n\npreviously unused, for \"national\" characters.\n这些字符以前是空的，是给各个国家自己  \"保留使用的\"\n\nIn the US, those extra numbers were largely used to encode additional symbols,\n在美国，这些额外的数字主要用于编码附加符号\n\nlike mathematical notation, graphical elements, and common accented characters.\n比如数学符号，图形元素和常用的重音字符\n\nOn the other hand, while the Latin characters were used universally,\n另一方面，虽然拉丁字符被普遍使用\n\nRussian computers used the extra codes to encode Cyrillic characters,\n在俄罗斯，他们用这些额外的字符表示西里尔字符\n\nand Greek computers, Greek letters, and so on.\n而希腊电脑用希腊字母，等等\n\nAnd national character codes worked pretty well for most countries.\n这些保留下来给每个国家自己安排的空位，\\N 对大部分国家都够用\n\nThe problem was,\n问题是\n\nif you opened an email written in Latvian on a Turkish computer,\n如果在 土耳其 电脑上打开 拉脱维亚语 写的电子邮件\n\nthe result was completely incomprehensible.\n会显示乱码\n\nAnd things totally broke with the rise of computing in Asia,\n随着计算机在亚洲兴起，这种做法彻底失效了\n\nas languages like Chinese and Japanese have thousands of characters.\n中文和日文这样的语言有数千个字符\n\nThere was no way to encode all those characters in 8-bits!\n根本没办法用 8 位来表示所有字符！\n\nIn response, each country invented multi-byte encoding schemes,\n为了解决这个问题，每个国家都发明了多字节编码方案\n\nall of which were mutually incompatible.\n但相互不兼容\n\nThe Japanese were so familiar with this encoding problem that they had a special name for it:\n日本人总是碰到编码问题，以至于专门有词来称呼：\n\n\"mojibake\", which means \"scrambled text\".\n\"mojibake\" 意思是 乱码\n\nAnd so it was born - Unicode - one format to rule them all.\n所以 Unicode 诞生了 - 统一所有编码的标准\n\nDevised in 1992 to finally do away with all of the different international schemes\n设计于 1992 年，解决了不同国家不同标准的问题\n\nit replaced them with one universal encoding scheme.\nUnicode 用一个统一编码方案\n\nThe most common version of Unicode uses 16 bits with space for over a million codes -\n最常见的 Unicode 是 16 位的，有超过一百万个位置 -\n\nenough for every single character from every language ever used\n对所有语言的每个字符都够了\n\nmore than 120,000 of them in over 100 types of script\n100 多种字母表加起来占了 12 万个位置。\n\nplus space for mathematical symbols and even graphical characters like Emoji.\n还有位置放数学符号，甚至 Emoji\n\nAnd in the same way that ASCII defines a scheme for encoding letters as binary numbers,\n就像 ASCII 用二进制来表示字母一样\n\nother file formats - like MP3s or GIFs -\n其他格式 - 比如 MP3 或 GIF  -\n\nuse binary numbers to encode sounds or colors of a pixel in our photos, movies, and music.\n用二进制编码声音/颜色，表示照片,电影,音乐\n\nMost importantly, under the hood it all comes down to long sequences of bits.\n重要的是，这些标准归根到底是一长串位\n\nText messages, this YouTube video, every webpage on the internet,\n短信，这个 YouTube 视频，互联网上的每个网页\n\nand even your computer's operating system, are nothing but long sequences of 1s and 0s.\n甚至操作系统，只不过是一长串 1 和 0\n\nSo next week,\n下周\n\nwe'll start talking about how your computer starts manipulating those binary sequences,\n我们会聊计算机怎么操作二进制\n\nfor our first true taste of computation.\n初尝\"计算\"的滋味\n\nThanks for watching. See you next week.\n感谢观看，下周见\n\nHi, I'm Carrie Ann and this is Crash Course Computer Science.\n嗨，我是 Carrie Anne，欢迎收看计算机科学速成课\n\nSo last episode, we talked about how numbers can be represented in binary.\n上集，我们谈了如何用二进制表示数字\n\nRepresenting Like, 00101010 is 42 in decimal.\n比如二进制 00101010 是十进制的 42\n\nRepresenting and storing numbers is an important function of a computer,\n表示和存储数字是计算机的重要功能\n\nbut the real goal is computation, or manipulating numbers in a structured and purposeful way,\n但真正的目标是计算，有意义的处理数字\n\nlike adding two numbers together.\n比如把两个数字相加\n\nThese operations are handled by a computer's Arithmetic and Logic Unit,\n这些操作由计算机的 \"算术逻辑单元 \"处理\n\nbut most people call it by its street name:\n但大家会简称：ALU\n\nthe ALU.\n但大家会简称：ALU\n\nThe ALU is the mathematical brain of a computer.\nALU 是计算机的数学大脑\n\nWhen you understand an ALU's design and function,\n等你理解了 ALU 的设计和功能之后\n\nyou'll understand a fundamental part of modern computers.\n你就理解了现代计算机的基石\n\nIt is THE thing that does all of the computation in a computer,\nALU *就是* 计算机里负责运算的组件\\N 基本其他所有部件都用到了它\n\nso basically everything uses it.\nALU *就是* 计算机里负责运算的组件\\N 基本其他所有部件都用到了它\n\nFirst though, look at this beauty.\n先来看看这个美人\n\nThis is perhaps the most famous ALU ever, the Intel 74181.\n这可能是最著名的 ALU，英特尔 74181\n\nWhen it was released in 1970,\n1970 年发布时，它是第一个封装在单个芯片内的完整 ALU\n\nit was It was the first complete ALU that fit entirely inside of a single chip -\n1970 年发布时，它是第一个封装在单个芯片内的完整 ALU\n\nWhich was a huge engineering feat at the time.\n这在当时是惊人的工程壮举\n\nSo today we're going to take those Boolean logic gates we learned about last week\n今天我们用上周学的布尔逻辑门\n\nto build a simple ALU circuit with much of the same functionality as the 74181.\n做一个简单的 ALU 电路，功能和 74181 一样\n\nAnd over the next few episodes we'll use this to construct a computer from scratch.\n然后接下来几集，用它从头做出一台电脑\n\nSo it's going to get a little bit complicated,\n所以会有点复杂\n\nbut I think you guys can handle it.\n但我觉得你们搞的定\n\nAn ALU is really two units in one\nALU 有 2 个单元，1 个算术单元和 1 个逻辑单元\n\n-- there's an arithmetic unit and a logic unit.\nALU 有 2 个单元，1 个算术单元和 1 个逻辑单元\n\nLet's start with the arithmetic unit,\n我们先讲\"算术单元\"，它负责计算机里的所有数字操作\n\nwhich is responsible for handling all numerical operations in a computer,\n我们先讲\"算术单元\"，它负责计算机里的所有数字操作\n\nlike addition and subtraction.\n比如加减法\n\nIt also does a bunch of other simple things like add one to a number,\n它还做很多其他事情，比如给某个数字+1\n\nwhich is called an increment operation, but we'll talk about those later.\n这叫增量运算，我们之后会说\n\nToday, we're going to focus on the piece of rsistance, the crme de la crme of operations\n今天的重点是一切的根本 - \"把两个数字相加\"\n\nthat underlies almost everything else a computer does - adding two numbers together.\n今天的重点是一切的根本 - \"把两个数字相加\"\n\nWe could build this circuit entirely out of individual transistors,\n我们可以用单个晶体管一个个拼，把这个电路做出来，\\N 但很快就会复杂的难以理解\n\nbut that would get confusing really fast.\n我们可以用单个晶体管一个个拼，把这个电路做出来，\\N 但很快就会复杂的难以理解\n\nSo instead as we talked about in Episode 3\n所以与其用晶体管，我们会像第 3 集\n\n- we can use a high-level of abstraction and build our components out of logic gates,\n- 用更高层的抽象，用逻辑门来做\n\nin this case: AND, OR, NOT and XOR gates.\n我们会用到 AND，OR，NOT 和 XOR 逻辑门\n\nThe simplest adding circuit that we can build takes two binary digits, and adds them together.\n最简单的加法电路， \\N 是拿 2 个 bit 加在一起（bit 是 0 或 1）\n\nSo we have two inputs, A and B, and one output, which is the sum of those two digits.\n有 2 个输入：A 和 B， 1 个输出：就是两个数字的和\n\nJust to clarify: A, B and the output are all single bits.\n需要注意的是：A, B, 输出，这3个都是单个 Bit （ 0 或 1 ）\n\nThere are only four possible input combinations.\n输入只有四种可能\n\nThe first three are: 0+0 = 0\n前三个是\\N 0 + 0 = 0 \\N 1 + 0 = 1 \\N 0 + 1 = 1\n\n1+0 = 1 0+1 = 1\n前三个是\\N 0 + 0 = 0 \\N 1 + 0 = 1 \\N 0 + 1 = 1\n\nRemember that in binary, 1 is the same as true, and 0 is the same as false.\n记住二进制里，1 与 true 相同，0 与 false 相同\n\nSo this set of inputs exactly matches the boolean logic of an XOR gate,\n这组输入和输出，和 XOR 门的逻辑完全一样\n\nand we can use it as our 1-bit adder.\n所以我们可以把 XOR 用作 1 位加法器（adder）\n\nBut the fourth input combination, 1 + 1, is a special case. 1 + 1 is 2 (obviously)\n但第四个输入组合，1+1，是个特例 \\N 1+1=2（显然）\n\nbut there's no 2 digit in binary,\n但二进制里没有 2\n\nso as we talked about last episode, the result is 0 and the 1 is carried to the next column.\n上集说过，二进制 1+1 的结果是0，1进到下一位\n\nSo the sum is really 10 in binary.\n和是 10 (二进制)\n\nNow, the output of our XOR gate is partially correct - 1 plus 1, outputs 0.\nXOR 门的输出，只对了一部分， 1+1 输出 0\n\nBut, we need an extra output wire for that carry bit.\n但我们需要一根额外的线代表 \"进位\"\n\nThe carry bit is only \"true\" when the inputs are 1 AND 1,\n只有输入是 1 和 1 时，进位才是 \"true\"\n\nbecause that's the only time when the result (two) is bigger than 1 bit can store\n因为算出来的结果用 1 个 bit 存不下\n\nand conveniently we have a gate for that!\n方便的是，我们刚好有个逻辑门能做这个事！\n\nIt's not that complicated - just two logic gates -\n没那么复杂 - 就两个逻辑门而已\n\nbut let's abstract away even this level of detail\n让我们抽象化\n\nand encapsulate our newly minted half adder as its own component,\n把 \"半加器\" 封装成一个单独组件\n\nwith two inputs - bits A and B - and two outputs, the sum and the carry bits.\n两个输入   A 和 B 都是 1 位 \\N 两个输出  \"总和\" 与 \"进位\"\n\nThis takes us to another level of abstraction\n这进入了另一层抽象\n\nheh I feel like I say that a lot.\n我好像说了很多次，说不定会变成一个梗\n\nI wonder if this is going to become a thing.\n我好像说了很多次，说不定会变成一个梗\n\nAnyway, If you want to add more than 1 + 1\n如果想处理超过 1+1 的运算，我们需要\"全加器\"\n\nwe're going to need a \"Full Adder.\"\n如果想处理超过 1+1 的运算，我们需要\"全加器\"\n\nThat half-adder left us with a carry bit as output.\n半加器 输出了进位\n\nThat means that when we move on to the next column in a multi-column addition,\n意味着，我们算下一列的时候\n\nand every column after that, we are going to have to add three bits together, no two.\n还有之后的每一列，我们得加 3 个位在一起，并不是 2 个\n\nA full adder is a bit more complicated\n全加器复杂了一点点\n\n全加器表格\n\n- it takes three bits as inputs: A, B and C.\n有 3 个输入：A, B, C （都是 1 个 bit)\n\nSo the maximum possible input is 1 + 1 + 1,\n所以最大的可能是 1 + 1 + 1\n\nwhich equals 1 carry out 1, so we still only need two output wires: sum and carry.\n\"总和\"1 \"进位\"1 \\N 所以要两条输出线： \"总和\"和\"进位\"\n\nWe can build a full adder using half adders.\n我们可以用 半加器 做 全加器\n\nTo do this, we use a half adder to add A plus B\n我们先用半加器将 A 和 B 相加\n\njust like before - but then feed that result and input C into a second half adder.\n然后把 C 输入到第二个半加器\n\nLastly, we need a OR gate to check if either one of the carry bits was true.\n最后用一个 OR 门检查进位是不是 true\n\nThat's it, we just made a full adder!\n这样就做出了一个全加器！\n\nAgain,we can go up a level of abstraction and wrap up this full adder as its own component.\n我们可以再提升一层抽象，把全加器作为独立组件\n\nIt takes three inputs, adds them, and outputs the sum and the carry, if there is one.\n全加器会把 A，B，C 三个输入加起来 \\N 输出 \"总和\" 和 \"进位\"\n\nArmed with our new components, we can now build a circuit that takes two, 8-bit numbers\n现在有了新组件，我们可以相加两个 8 位数字\n\nLet's call them A and B  and adds them together.\n叫两个数字叫 A 和 B 好了\n\nLet's start with the very first bit of A and B,\n我们从 A  和 B 的第一位开始\n\nwhich we'll call A0 and B0.\n叫 A0 和 B0 好了\n\nAt this point, there is no carry bit to deal with,\n现在不用处理任何进位，因为是第一次加法\n\nbecause this is our first addition.\n现在不用处理任何进位，因为是第一次加法\n\nSo we can use our half adder to add these two bits together.\n所以我们可以用半加器，来加这2个数字\n\nThe output is sum0.\n输出叫 sum0\n\nNow we want to add A1 and B1 together.\n现在加 A1 和 B1\n\nIt's possible there was a carry from the previous addition of A0 and B0,\n因为 A0 和 B0 的结果有可能进位\n\nso this time we need to use a full adder that also inputs the carry bit.\n所以这次要用全加器，除了 A1 和 B1，还要连上进位\n\nWe output this result as sum1.\n输出叫 sum1\n\nThen, we take any carry from this full adder,\n然后，把这个全加器的进位 \\N 连到下个全加器的输入，处理 A2 和 B2\n\nand run it into the next full adder that handles A2 and B2.\n然后，把这个全加器的进位 \\N 连到下个全加器的输入，处理 A2 和 B2\n\nAnd we just keep doing this in a big chain until all 8 bits have been added.\n以此类推，把 8 个 bit 都搞定\n\nNotice how the carry bits ripple forward to each subsequent adder.\n注意每个进位是怎么连到下一个全加器的\n\nFor this reason, this is called an 8-bit ripple carry adder.\n所以叫 \"8位行波进位加法器\"\n\nNotice how our last full adder has a carry out.\n注意最后一个全加器有 \"进位\" 的输出\n\nIf there is a carry into the 9th bit, it means the sum of the two numbers is too large to fit into 8-bits.\n如果第 9 位有进位，代表着 2 个数字的和太大了，超过了 8 位\n\nThis is called an overflow.\n这叫 \"溢出\" (overflow)\n\nIn general, an overflow occurs when the result of an addition is too large\n一般来说 \"溢出\" 的意思是, 两个数字的和太大了\n\nto be represented by the number of bits you are using.\n超过了用来表示的位数\n\nThis can usually cause errors and unexpected behavior.\n这会导致错误和不可预期的结果\n\nFamously, the original PacMan arcade game used 8 bits to keep track of what level you were on.\n著名的例子是，吃豆人用 8 位存当前关卡数\n\nThis meant that if you made it past level 255 - the largest number storablein 8 bits - to level 256,\n如果你玩到了第 256 关（ 8 位 bit 最大表示 255）\n\nthe ALU overflowed.\nALU 会溢出\n\nThis caused a bunch of errors and glitches making the level unbeatable.\n造成一连串错误和乱码，使得该关卡无法进行\n\nThe bug became a rite of passage for the greatest PacMan players.\n这个 bug 成了厉害吃豆人玩家的代表\n\nSo if we want to avoid overflows,\n如果想避免溢出\n\nwe can extend our circuit with more full adders, allowing us to add 16 or 32 bit numbers.\n我们可以加更多全加器，可以操作 16 或 32 位数字\n\nThis makes overflows less likely to happen, but at the expense of more gates.\n让溢出更难发生，但代价是更多逻辑门\n\nAn additional downside is that it takes a little bit of time for each of the carries to ripple forward.\n另外一个缺点是，每次进位都要一点时间\n\nAdmittedly, not very much time, electrons move pretty fast,\n当然时间不久，因为电子移动的很快\n\nso we're talking about billionths of a second,\n但如今的量级是每秒几十亿次运算，所以会造成影响\n\nbut that's enough to make a difference in today's fast computers.\n但如今的量级是每秒几十亿次运算，所以会造成影响\n\nFor this reason, modern computers use a slightly different adding circuit\n所以，现代计算机用的加法电路有点不同\n\ncalled a 'carry-look-ahead' adder\n叫 \"超前进位加法器\"\n\nwhich is faster, but ultimately does exactly the same thing\n它更快，做的事情是一样的 - 把二进制数相加\n\n-- adds binary numbers.\n它更快，做的事情是一样的 - 把二进制数相加\n\nThe ALU's arithmetic unit also has circuits for other math operations\nALU 的算术单元，也能做一些其他数学运算\n\nand in general these 8 operations are always supported.\n一般支持这 8 个操作\n\nAnd like our adder, these other operations are built from individual logic gates.\n就像加法器一样，这些操作也是由逻辑门构成的\n\nInterestingly, you may have noticed that there are no multiply and divide operations.\n有趣的是，你可能注意到没有乘法和除法\n\nThat's because simple ALUs don't have a circuit for this,\n因为简单的 ALU 没有专门的电路来处理\n\nand instead just perform a series of additions.\n而是把乘法用多次加法来实现\n\nLet's say you want to multiply 12 by 5.\n假设想算 12x5\n\nThat's the same thing as adding 12 to itself 5 times.\n这和把 \"12\" 加 5 次是一样的\n\nSo it would take 5 passes through the ALU to do this one multiplication.\n所以要 5 次 ALU 操作来实现这个乘法\n\nAnd this is how many simple processors,\n很多简单处理器都是这样做的\n\nlike those in your thermostat, TV remote, and microwave, do multiplication.\n比如恒温器，电视遥控器和微波炉\n\nIt's slow, but it gets the job done.\n慢是慢，但是搞的定\n\nHowever, fancier processors, like those in your laptop or smartphone,\n然而笔记本和手机有更好的处理器\n\nhave arithmetic units with dedicated circuits for multiplication.\n有专门做乘法的算术单元\n\nAnd as you might expect, the circuit is more complicated than addition\n你可能猜到了，乘法电路比加法复杂\n\n-- there's no magic, it just takes a lot more logic gates\n- 没什么魔法，只是更多逻辑门\n\nwhich is why less expensive processors don't have this feature.\n所以便宜的处理器没有.\n\nOk, let's move on to the other half of the ALU:\n好了，我们现在讲 ALU 的另一半：逻辑单元\n\nthe Logic Unit.\n好了，我们现在讲 ALU 的另一半：逻辑单元\n\nInstead of arithmetic operations, the Logic Unit performs well...\n逻辑单元执行逻辑操作\n\nlogical operations, like AND, OR and NOT, which we've talked about previously.\n比如之前讨论过的 AND，OR 和 NOT 操作\n\nIt also performs simple numerical tests,\n它也能做简单的数值测试\n\nlike checking if a number is negative.\n比如一个数字是不是负数\n\nFor example, here's a circuit that tests if the output of the ALU is zero.\n例如，这是检查 ALU 输出是否为 0 的电路\n\nIt does this using a bunch of OR gates to see if any of the bits are 1.\n它用一堆 OR 门检查其中一位是否为 1\n\nEven if one single bit is 1,\n哪怕只有一个 Bit (位) 是1，\n\nwe know the number can't be zero and then we use a final NOT gate to flip this input\n我们就知道那个数字肯定不是 0，然后用一个 NOT 门取反\n\nso the output is 1 only if the input number is 0.\n所以只有输入的数字是 0，输出才为 1\n\nSo that's a high level overview of what makes up an ALU.\n以上就是 ALU 的一个高层次概括\n\nWe even built several of the main components from scratch, like our ripple adder.\n我们甚至从零做了几个主要组件，比如行波进位加法器\n\nAs you saw, it's just a big bunch of logic gates connected in clever ways.\n它们只是一大堆逻辑门巧妙的连在一起而已.\n\nWhich brings us back to that ALU you admired so much at the beginning of the episode.\n让我们回到视频开始时的 ALU，英特尔 74181\n\nThe Intel 74181.\n让我们回到视频开始时的 ALU，英特尔 74181\n\nUnlike the 8-bit ALU we made today, the 74181 could only handle 4-bit inputs,\n和我们刚刚做的 8 位 ALU 不同，74181 只能处理 4 位输入\n\nwhich means\n也就是说\n\nYOU BUILT AN ALU THAT'S LIKE TWICE AS GOOD AS THAT SUPER FAMOUS ONE. WITH YOUR MIND!\n你刚做了一个比英特尔 74181 还好的 ALU ！\n\nWell.. sort of.\n其实 差不多啦..\n\nWe didn't build the whole thing\n我们虽然没有全部造出来\n\nbut you get the idea.\n但你理解了整体概念\n\nThe 74181 used about 70 logic gates, and it couldn't multiply or divide.\n74181 用了大概 70 个逻辑门，但不能执行乘除.\n\nBut it was a huge step forward in miniaturization,\n但它向小型化迈出了一大步\n\nopening the doors to more capable and less expensive computers.\n让计算机可以更强大更便宜\n\nThis 4-bit ALU circuit is already a lot to take in,\n4 位 ALU 已经要很多逻辑门了\n\nbut our 8-bit ALU would require hundreds of logic gates to fully build\n但我们的 8 位 ALU 会需要数百个逻辑门\n\nand engineers don't want to see all that complexity when using an ALU,\n工程师不想在用 ALU 时去想那些事情,\n\nso they came up with a special symbol to wrap it all up, which looks like a big V'.\n所以想了一个特殊符号来代表它，看起来像一个大 \"V\"\n\nJust another level of abstraction!\n又一层抽象！\n\nOur 8-bit ALU has two inputs, A and B, each with 8 bits.\n我们的 8 位  ALU 有两个输入，A和B，都是 8 位 (bits)\n\nWe also need a way to specify what operation the ALU should perform,\n我们还需要告诉 ALU 执行什么操作\n\nfor example, addition or subtraction.\n例如加法或减法\n\nFor that, we use a 4-bit operation code.\n所以我们用 4 位的操作代码\n\nWe'll talk about this more in a later episode,\n我们之后的视频会再细说\n\nbut in brief, 1000 might be the command to add, while 1100 is the command for subtract.\n简言之,\"1000\"可能代表加法命令 \\N \"1100\"代表减法命令\n\nBasically, the operation code tells the ALU what operation to perform.\n操作代码告诉 ALU 执行什么操作\n\nAnd the result of that operation on inputs A and B is an 8-bit output.\n输出结果是 8 位的\n\nALUs also output a series of Flags,\nALU 还会输出一堆标志（Flag）\n\nwhich are 1-bit outputs for particular states and statuses.\n\"标志\"是1位的，代表特定状态.\n\nFor example, if we subtract two numbers, and the result is 0,\n比如相减两个数字，结果为 0\n\nour zero-testing circuit, the one we made earlier, sets the Zero Flag to True (1).\n我们的零测试电路（前面做的）\\N 会将零标志设为 True（1）\n\nThis is useful if we are trying to determine if two numbers are are equal.\n如果想知道两个数字是否相等，这个非常有用\n\nIf we wanted to test if A was less than B,\n如果想知道： A 是否小于 B\n\nwe can use the ALU to calculate A subtract B and look to see if the Negative Flag was set to true.\n可以用 ALU 来算 A 减 B，看负标志是否为 true\n\nIf it was, we know that A was smaller than B.\n如果是 true，我们就知道 A 小于 B\n\nAnd finally, there's also a wire attached to the carry out on the adder we built,\n最后，还有一条线连到加法器的进位\n\nso if there is an overflow, we'll know about it.\n如果有溢出，我们就知道\n\nThis is called the Overflow Flag.\n这叫溢出标志\n\nFancier ALUs will have more flags,\n高级 ALU 有更多标志\n\nbut these three flags are universal and frequently used.\n但这 3 个标志是 ALU 普遍用的\n\nIn fact, we'll be using them soon in a future episode.\n其实，我们之后的视频会用到它们\n\nSo now you know how your computer does all its basic mathematical operations digitally\n现在你知道了\\N 计算机是怎样在没有齿轮或杠杆的情况下 进行运算\n\nwith no gears or levers required.\n现在你知道了\\N 计算机是怎样在没有齿轮或杠杆的情况下 进行运算\n\nWe're going to use this ALU when we construct our CPU two episodes from now.\n接下来两集  我们会用 ALU 做 CPU\n\nBut before that, our computer is going to need some memory!\n但在此之前，计算机需要一些 \"记忆\" ！\n\nWe'll talk about that next week.\n我们下周会讲\n\nHi, I'm Carrie Anne and welcome to Crash Course Computer Science.\n嗨，我是 Carrie Anne，欢迎收看计算机科学速成课\n\nSo last episode, using just logic gates, we built a simple ALU,\n上集，我们用逻辑门做了个简单 ALU\n\nwhich performs arithmetic and logic operations, hence the 'A' and the 'L'.\n它能执行算术(Arithmetic)和逻辑(Logic)运算 \\N ALU 里的 A 和 L 因此得名\n\nBut of course, there's not much point in calculating a result only to throw it away\n当然，算出来之后如果扔掉就没什么意义了\n\n- it would be useful to store that value somehow,\n得找个方法存起来\n\nand maybe even run several operations in a row.\n可能还要进行多个连续操作\n\nThat's where computer memory comes in!\n这就用到计算机内存了\n\nIf you've ever been in the middle of a long RPG campaign on your console,\n如果你在主机上打过一场长时间的对局\n\nor slogging through a difficult level on Minesweeper on your desktop,\n或玩困难模式的 \"扫雷\"\n\nand your dog came by, tripped and pulled the power cord out of the wall,\n然后狗跑过来，被电源线绊倒，把插头拔了出来\n\nyou know the agony of losing all your progress.\n你知道失去进度的痛苦\n\nCondolences.\n真同情你 :(\n\nBut the reason for your loss is that your console, your laptop and your computers\n你损失数据的原因是 \\N 电脑用的是\"随机存取存储器\"，简称\"RAM\"\n\nmake use of Random Access Memory, or RAM,\n你损失数据的原因是 \\N 电脑用的是\"随机存取存储器\"，简称\"RAM\"\n\nwhich stores things like game state - as long as the power stays on.\n它只能在有电的情况下存储东西，比如游戏状态\n\nAnother type of memory, called persistent memory, can survive without power,\n另一种存储 (memory) 叫持久存储，电源关闭时数据也不会丢失\n\nand it's used for different things;\n它用来存其他东西.\n\nWe'll talk about the persistence of memory in a later episode.\n我们之后会讨论存储 (memory) 的持久性问题\n\nToday, we're going to start small\n今天我们从简单开始\n\n- literally by building a circuit that can store one.. single.. bit of information.\n- 做只能存储 1 位的电路\n\nAfter that, we'll scale up, and build our very own memory module,\n之后再扩大，做出我们的内存模块\n\nand we'll combine it with our ALU next time, when we finally build our very own CPU!\n下次和 ALU 结合起来，做出 CPU！\n\nAll of the logic circuits we've discussed so far go in one direction\n我们至今说过的电路都是单向的\n\n- always flowing forward.\n- 总是向前流动\n\nlike our 8-bit ripple adder from last episode.\n比如上集的 8 位 \"脉动进位加法器\"\n\nBut we can also create circuits that loop back on themselves.\n但也可以做回向电路，把输出连回输入\n\nLet's try taking an ordinary OR gate, and feed the output back into one of its inputs\n我们拿一个 OR 门试试，把输出连回输入\n\nand see what happens.\n看看会发生什么\n\nFirst, let's set both inputs to 0.\n首先，两个输入都设为 0\n\nSo 0 OR 0 is 0, and so this circuit always outputs 0.\n\"0 OR 0\" 是 0，所以电路输出0\n\nIf we were to flip input A to 1.\n如果将 A 变成1\n\n1 OR 0 is 1, so now the output of the OR gate is 1.\n\"1 OR 0\" 为 1，所以输出 1\n\nA fraction of a second later, that loops back around into input B,\n一转眼的功夫，输出回到 B\n\nso the OR gate sees that both of its inputs are now 1.\nOR 门看到两个输入都是 1\n\n1 OR 1 is still 1, so there is no change in output.\n\"1 OR 1\" 仍然为1，所以输出不变\n\nIf we flip input A back to 0, the OR gate still outputs 1.\n如果将 A 变成 0，OR 门依然输出 1\n\nSo now we've got a circuit that records a \"1\" for us.\n现在我们有个电路能记录 \"1\"\n\nExcept, we've got a teensy tiny problem - this change is permanent!\n然而有个小问题：这是永久的！\n\nNo matter how hard we try, there's no way to get this circuit to flip back from a 1 to a 0.\n无论怎么试，都没法从 1 变回 0\n\nNow let's look at this same circuit, but with an AND gate instead.\n我们换成 AND 门看看会怎样\n\nWe'll start inputs A and B both at 1.\n开始时，A 和 B 都设 1\n\n1 AND 1 outputs 1 forever.\n\"1 AND 1\" 永远输出 1\n\nBut, if we then flip input A to 0, because it's an AND gate, the output will go to 0.\n如果之后 A 设为 0，由于是 AND 门，输出会变成 0\n\nSo this circuit records a 0, the opposite of our other circuit.\n这个电路能记录 0，和之前那个相反\n\nLike before, no matter what input we apply to input A afterwards, the circuit will always output 0.\n就像之前，无论 A 设什么值，电路始终输出 0\n\nNow we've got circuits that can record both 0s and 1s.\n现在有了能存 0 和 1 的电路\n\nThe key to making this a useful piece of memory is to combine our two circuits into what is\n为了做出有用的存储 (memory) \\N 我们把两个电路结合起来\n\ncalled the AND-OR Latch.\n这叫 \"AND-OR 锁存器\"\n\nIt has two inputs, a \"set\" input, which sets the output to a 1,\\Ncalled the AND-OR Latch.\nIt has two inputs, a \"set\" input, which sets the output to a 1,\n它有两个输入\\N  \"设置\"输入, 把输出变成 1\\N \"复位\"输入, 把输出变成 0\n\nand a \"reset\" input, which resets the output to a 0.\n它有两个输入\\N  \"设置\"输入, 把输出变成 1\\N \"复位\"输入, 把输出变成 0\n\nIf set and reset are both 0, the circuit just outputs whatever was last put in it.\n如果\"设置\"和\"复位\"都是 0，电路会输出最后放入的内容\n\nIn other words, it remembers a single bit of information!\n也就是说，它存住了 1 位的信息！\n\nMemory!\n存储！\n\nThis is called a \"latch\" because it \"latches onto\" a particular value and stays that way.\n这叫\"锁存\", 因为它\"锁定\"了一个值\n\nThe action of putting data into memory is called writing, whereas getting the data out is called reading.\n放入数据的动作叫 \"写入\"  ，拿出数据的动作叫 \"读取\"\n\nOk, so we've got a way to store a single bit of information!\n现在我们终于有办法存一个位了！\n\nGreat!\n超棒！\n\nUnfortunately, having two different wires for input - set and reset - is a bit confusing.\n麻烦的是, 用两条线 \"设置\"和\"复位\" 来输入, 有点难理解\n\nTo make this a little easier to use, we really want a single wire to input data,\n为了更容易用，我们希望只有一条输入线\n\nthat we can set to either 0 or 1 to store the value.\n将它设为 0 或 1 来存储值\n\nAdditionally, we are going to need a wire that enables the memory\n还需要一根线来\"启用\"内存\n\nto be either available for writing or \"locked\" down\n启用时允许写入，没启用时就 \"锁定\"\n\n- which is called the write enable line.\n- 这条线叫 \"允许写入线\"\n\nBy adding a few extra logic gates, we can build this circuit,\n加一些额外逻辑门，可以做出这个电路\n\nwhich is called a Gated Latch since the \"gate\" can be opened or closed.\n这叫\"门锁\"，因为门可以打开和关上\n\nNow this circuit is starting to get a little complicated.\n现在有点复杂了\n\nWe don't want to have to deal with all the individual logic gates...\n我们不想关心单独的逻辑门\n\nso as before, we're going to bump up a level of abstraction,\n所以我们提升一层抽象\n\nand put our whole Gated Latch circuit in a box -- a box that stores one bit.\n把 \"门锁\" 放到盒子里 - 这个盒子能存一个 bit\n\nLet's test out our new component!\n我们来测一下新组件！\n\nLet's start everything at 0.\n一切从 0 开始\n\nIf we toggle the Data wire from 0 to 1 or 1 to 0,\n数据输入从0换到1, 从1换到0\n\nnothing happens - the output stays at 0.\n什么也不会发生 - 输出依然是 0\n\nThat's because the write enable wire is off, which prevents any change to the memory.\n因为 \"允许写入线\" 是关闭的，所以内容不会变化\n\nSo we need to \"open\" the \"gate\" by turning the write enable wire to 1.\n所以要给 \"允许写入线\" 输入 1, \"打开\" 门\n\nNow we can put a 1 on the data line to save the value 1 to our latch.\n现在往 \"数据线\" 放 1，1 就能存起来了\n\nNotice how the output is now 1.\\NNow we can put a 1 on the data line to save the value 1 to our latch.\nNotice how the output is now 1.\n注意输出现在是 1 了\n\nSuccess!\n成功！\n\nWe can turn off the enable line and the output stays as 1.\n现在可以关掉  \"允许写入线\" ，输出会保持 1\n\nOnce again, we can toggle the value on the data line all we want,\n现在不管给 \"数据线\" 什么值\n\nbut the output will stay the same.\n输出都不会变\n\nThe value is saved in memory.\n值存起来了\n\nNow let's turn the enable line on again use our data line to set the latch to 0.\n现在又打开 \"允许写入线\"  \\N  \"数据线\" 设为0\n\nDone.\n完成\n\nEnable line off, and the output is 0.\n\"允许写入线\" 关闭，输出 0\n\nAnd it works!\n成功了！\n\nNow, of course, computer memory that only stores one bit of information isn't very useful\n当然，只能存 1 bit 没什么大用\n\n-- definitely not enough to run Frogger.\n- 肯定玩不了游戏\n\nOr anything, really.\n或做其它事情\n\nBut we're not limited to using only one latch.\n但我们没限制只能用一个锁存器\n\nIf we put 8 latches side-by-side, we can store 8 bits of information like an 8-bit number.\n如果我们并排放 8 个锁存器，\\N 可以存 8 位信息，比如一个 8 bit 数字\n\nA group of latches operating like this is called a register,\n一组这样的锁存器叫 \"寄存器\"\n\nwhich holds a single number, and the number of bits in a register is called its width.\n寄存器能存一个数字，这个数字有多少位，叫\"位宽\"\n\nEarly computers had 8-bit registers, then 16, 32,\n早期电脑用 8 位寄存器，然后是 16 位，32 位\n\nand today, many computers have registers that are 64-bits wide.\n如今许多计算机都有 64 位宽的寄存器\n\nTo write to our register, we first have to enable all of the latches.\n写入寄存器前，要先启用里面所有锁存器\n\nWe can do this with a single wire that connects to all of their enable inputs, which we set to 1.\n我们可以用一根线连接所有 \"允许输入线\", 把它设为 1\n\nWe then send our data in using the 8 data wires, and then set enable back to 0,\n然后用 8 条数据线发数据，然后将 \"允许写入线\" 设回 0\n\nand the 8 bit value is now saved in memory.\n现在 8 位的值就存起来了\n\nPutting latches side-by-side works ok for a small-ish number of bits.\n如果只有很少的位(bits)，把锁存器并排放置，也勉强够用了.\n\nA 64-bit register would need 64 wires running to the data pins, and 64 wires running to the outputs.\n64 位寄存器要 64 根数据线，64 根连到输出端\n\nLuckily we only need 1 wire to enable all the latches, but that's still 129 wires.\n幸运的是，我们只要 1 根线启用所有锁存器 \\N 但加起来也有 129 条线了\n\nFor 256 bits, we end up with 513 wires!\n如果存 256 位要 513 条线！\n\nThe solution is a matrix!\n解决方法是矩阵！\n\nIn this matrix, we don't arrange our latches in a row,\n在矩阵中，我们不并列排放锁存器\n\nwe put them in a grid.\n而是做成网格\n\nFor 256 bits, we need a 16 by 16 grid of latches with 16 rows and columns of wires.\n存 256 位，我们用 16x16 网格的锁存器，有 16 行 16 列\n\nTo activate any one latch, we must turn on the corresponding row AND column wire.\n要启用某个锁存器，就打开相应的 行线 和 列线\n\nLet's zoom in and see how this works.\n放大看看怎么做的\n\nWe only want the latch at the intersection of the two active wires to be enabled,\n我们只想打开交叉处  锁存器的 \"允许写入线\"\n\nbut all of the other latches should stay disabled.\n所有其他锁存器，保持关闭\n\nFor this, we can use our trusty AND gate!\n我们可以用 AND 门！\n\nThe AND gate will output a 1 only if the row and the column wires are both 1.\n只有 行线和列线 均为 1 ，AND 门才输出 1\n\nSo we can use this signal to uniquely select a single latch.\n所以可以用选择单个锁存器\n\nThis row/column setup connects all our latches with a single, shared, write enable wire.\n这种行/列排列法，用一根 \"允许写入线\" 连所有锁存器\n\nIn order for a latch to become write enabled,\n为了让锁存器变成 \"允许写入\"\n\nthe row wire, the column wire, and the write enable wire must all be 1.\n行线，列线和 \"允许写入线\" 都必须是 1\n\nThat should only ever be true for one single latch at any given time.\n每次只有 1 个锁存器会这样\n\nThis means we can use a single, shared wire for data.\n代表我们可以只用一根 \"数据线\"  \\N 连所有锁存器来传数据\n\nBecause only one latch will ever be write enabled, only one will ever save the data\n因为只有一个锁存器会启用，只有那个会存数据\n\n-- the rest of the latches will simply ignore values on the data wire because they are not write enabled.\n其他锁存器会忽略数据线上的值，因为没有 \"允许写入\"\n\nWe can use the same trick with a read enable wire to read the data later,\n我们可以用类似的技巧, 做\"允许读取线\"来读数据\n\nto get the data out of one specific latch.\n从一个指定的锁存器，读取数据\n\nThis means in total, for 256 bits of memory,\n所以对于 256 位的存储\n\nwe only need 35 wires - 1 data wire, 1 write enable wire, 1 read enable wire,\n只要 35 条线 \\N1条\"数据线\", 1条\"允许写入线\", 1条\"允许读取线\"\n\nand 16 rows and columns for the selection.\n还有16行16列的线用于选择锁存器 \\N （16+16=32, 32+3=35）\n\nThat's significant wire savings!\n这省了好多线！\n\nBut we need a way to uniquely specify each intersection.\n但我们需要某种方法来 唯一指定 交叉路口\n\nWe can think of this like a city,\n我们可以想成城市\n\nwhere you might want to meet someone at 12th avenue and 8th street\n你可能想和别人  在第 12 大道和第 8 街的交界碰面\n\n-- that's an address that defines an intersection.\n- 这是一个交叉点的地址\n\nThe latch we just saved our one bit into has an address of row 12 and column 8.\n我们刚刚存了一位的地址是 \"12行 8列\"\n\nSince there is a maximum of 16 rows, we store the row address in a 4 bit number.\n由于最多 16 行, 用 4 位就够了\n\n12 is 1100 in binary.\n12 用二进制表示为 1100\n\nWe can do the same for the column address: 8 is 1000 in binary.\n列地址也可以这样： 8 用二进制表示为 1000\n\nSo the address for the particular latch we just used can be written as 11001000.\n刚才说的\"12行 8列\"可以写成 11001000\n\nTo convert from an address into something that selects the right row or column,\n为了将地址转成  行和列\n\nwe need a special component called a multiplexer\n我们需要 \"多路复用器\"\n\n-- which is the computer component with a pretty cool name at least compared to the ALU.\n- 这个名字起码比 ALU 酷一点\n\nMultiplexers come in all different sizes,\n多路复用器有不同大小\n\nbut because we have 16 rows, we need a 1 to 16 multiplexer.\n因为有 16 行，我们需要 1 到 16 多路复用器\n\nIt works like this.\n工作方式是\n\nYou feed it a 4 bit number, and it connects the input line to a corresponding output line.\n输入一个 4 位数字，它会把那根线，连到相应的输出线\n\nSo if we pass in 0000, it will select the very first column for us.\n如果输入 0000，它会选择第一列\n\nIf we pass in 0001, the next column is selected, and so on.\n如果输入 0001，会选择下一列，依此类推\n\nWe need one multiplexer to handle our rows and another multiplexer to handle the columns.\n一个多路复用器处理行(row) \\N 另一个多路复用器处理列(column)\n\nOk, it's starting to get complicated again,\n好吧，开始有点复杂了\n\nso let's make our 256-bit memory its own component.\n那么把 256 位内存当成一个整体好了\n\nOnce again a new level of abstraction!\n又提升了一层抽象！\n\nIt takes an 8-bit address for input - the 4 bits for the column and 4 for the row.\n它输入一个 8 位地址：4 位代表列，4 位代表行\n\nWe also need write and read enable wires.\n我们还需要 \"允许写入线\" 和 \"允许读取线\"\n\nAnd finally, we need just one data wire, which can be used to read or write data.\n最后，还需要一条数据线，用于读/写数据\n\nUnfortunately, even 256-bits of memory isn't enough to run much of anything,\n不幸的是， 256 位的内存也没法做什么事\n\nso we need to scale up even more!\n所以还要扩大规模\n\nWe're going to put them in a row.\n把它们并排放置\n\nJust like with the registers.\n就像寄存器一样\n\nWe'll make a row of 8 of them, so we can store an 8 bit number - also known as a byte.\n一行8个，可以存一个 8 位数字 \\N 8 位也叫一个字节（byte）\n\nTo do this, we feed the exact same address into all 8 of our 256-bit memory components at the same time,\n为了存一个 8 位数字，我们同时给 8 个 256 位内存一样的地址\n\nand each one saves one bit of the number.\n每个地址存 1 位\n\nThat means the component we just made can store 256 bytes at 256 different addresses.\n意味着这里总共能存 256 个字节 （byte）\n\nAgain, to keep things simple, we want to leave behind this inner complexity.\n再次，为了简单，我们不管内部\n\nInstead of thinking of this as a series of individual memory modules and circuits,\n不看作是一堆独立的存储模块和电路\n\nwe'll think of it as a uniform bank of addressable memory.\n而是看成一个整体的可寻址内存\n\nWe have 256 addresses,\n我们有 256 个地址\n\nand at each address, we can read or write an 8-bit value.\n每个地址能读或写一个 8 位值\n\nWe're going to use this memory component next episode when we build our CPU.\n我们下集做 CPU 时会用到这个内存\n\nThe way that modern computers scale to megabytes and gigabytes of memory\n现代计算机的内存 \\N 扩展到上兆字节（MB）和千兆字节（GB）的方式\n\nis by doing the same thing we've been doing here\n和我们这里做的一样\n\n-- keep packaging up little bundles of memory into larger, and larger, and larger arrangements.\n不断把内存打包到更大规模\n\nAs the number of memory locations grow, our addresses have to grow as well.\n随着内存地址增多，内存地址也必须增长\n\n8 bits hold enough numbers to provide addresses for 256 bytes of our memory,\n8 位最多能代表 256 个内存地址 \\N（1111 1111 是255，0~255 一共 256 个数字）\n\nbut that's all.\n只有这么多\n\nTo address a gigabyte - or a billion bytes of memory - we need 32-bit addresses.\n要给千兆或十亿字节的内存寻址，需要 32 位的地址\n\nAn important property of this memory is that we can access any memory location, at any time, and in a random order.\n内存的一个重要特性是：可以随时访问任何位置\n\nFor this reason, it's called Random-Access Memory or RAM.\n因此叫 \"随机存取存储器\" ，简称 RAM\n\nWhen you hear people talking about how much RAM a computer has\n当你听到有人说 RAM 有多大\n\n- that's the computer's memory.\n他的意思是内存有多大\n\nRAM is like a human's short term or working memory,\nRAM 就像人类的短期记忆\n\nwhere you keep track of things going on right now\n记录当前在做什么事\n\n- like whether or not you had lunch or paid your phone bill.\n比如吃了午饭没，或有没有交电话费\n\nHere's an actual stick of RAM - with 8 memory modules soldered onto the board.\n这是一条真的内存，上面焊了 8 个内存模块\n\nIf we carefully opened up one of these modules and zoomed in,\n如果打开其中一个，然后放大\n\nThe first thing you would see are 32 squares of memory.\n会看到 32 个内存方块\n\nZoom into one of those squares, and we can see each one is comprised of 4 smaller blocks.\n放大其中一个方块，可以看到有 4 个小块\n\nIf we zoom in again, we get down to the matrix of individual bits.\n如果再放大，可以看到存一个\"位\"的矩阵\n\nThis is a matrix of 128 by 64 bits.\n这个矩阵是 128 位 x 64 位\n\nThat's 8192 bits in total.\n总共 8192 位\n\nEach of our 32 squares has 4 matrices, so that's 32 thousand, 7 hundred and 68 bits.\n每个方格 4 个矩阵 \\N 所以一个方格有 32768 个位 （8192 x 4 = 32768）\n\nAnd there are 32 squares in total.\n而一共 32 个方格\n\nSo all in all, that's roughly 1 million bits of memory in each chip.\n总而言之，1 个芯片大约存 100 万位\n\nOur RAM stick has 8 of these chips, so in total, this RAM can store 8 millions bits,\nRAM 有 8 个芯片，所以总共 800 万位\n\notherwise known as 1 megabyte.\n也就是 1 兆字节（1 MB）\n\nThat's not a lot of memory these days -- this is a RAM module from the 1980's.\n1 MB 如今不算大 - 这是 1980 年代的 RAM\n\nToday you can buy RAM that has a gigabyte or more of memory\n如今你可以买到千兆字节（GB）的 RAM\n\n- that's billions of bytes of memory.\n那可是数十亿字节的内存\n\nSo, today, we built a piece of SRAM - Static Random-Access Memory - which uses latches.\n今天，我们用锁存器做了一块 SRAM（静态随机存取存储器）\n\nThere are other types of RAM, such as DRAM, Flash memory, and NVRAM.\n还有其他类型的 RAM，如 DRAM，闪存和 NVRAM\n\nThese are very similar in function to SRAM,\n它们在功能上与 SRAM 相似\n\nbut use different circuits to store the individual bits\n但用不同的电路存单个位\n\n- for example, using different logic gates, capacitors, charge traps, or memristors.\n- 比如用不同的逻辑门，电容器，电荷捕获或忆阻器\n\nBut fundamentally, all of these technologies store bits of information\n但根本上  这些技术都是矩阵层层嵌套，来存储大量信息\n\nin massively nested matrices of memory cells.\n但根本上  这些技术都是矩阵层层嵌套，来存储大量信息\n\nLike many things in computing, the fundamental operation is relatively simple.\n就像计算机中的很多事情，底层其实都很简单\n\nit's the layers and layers of abstraction that's mind blowing\n让人难以理解的，是一层层精妙的抽象\n\n-- like a russian doll that keeps getting smaller and smaller and smaller.\n像一个越来越小的俄罗斯套娃\n\nI'll see you next week.\n下周见\n\nHi, I'm Carrie Anne, this is Crash Course Computer Science\n嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nand today, we're talking about processors.\n今天我们讲 处理器\n\nJust a warning though - this is probably the most complicated episode in the series.\n提示下 - 这集可能是最难的一集\n\nSo once you get this, you're golden.\n所以一旦你理解了，就会变得超厉害der~\n\nWe've already made a Arithmetic and Logic Unit,\n我们已经做了一个算术逻辑单元（ALU）\n\nwhich takes in binary numbers and performs calculations,\n输入二进制，它会执行计算\n\nand we've made two types of computer memory:\n我们还做了两种内存：\n\nRegisters -- small, linear chunks of memory, useful for storing a single value\n寄存器 - 很小的一块内存，能存一个值\n\nand then we scaled up, and made some RAM,\n之后我们增大做出了 RAM\n\na larger bank of memory that can store a lot of numbers located at different addresses.\nRAM 是一大块内存，能在不同地址存大量数字\n\nNow it's time to put it all together and build ourselves the heart of any computer,\n现在是时候把这些放在一起，组建计算机的 \"心脏\" 了\n\nbut without any of the emotional baggage that comes with human hearts.\n但这个 \"心脏\" 不会有任何包袱，比如人类情感.\n\nFor computers, this is the Central Processing Unit, most commonly called the CPU.\n计算机的心脏是\"中央处理单元\"，简称 \"CPU\"\n\nA CPU's job is to execute programs.\nCPU 负责执行程序\n\nPrograms, like Microsoft Office, Safari, or your beloved copy of Half Life: 2,\n比如 Office，Safari 浏览器，你最爱的 《半条命2》\n\nare made up of a series of individual operations,\n程序由一个个操作组成\n\ncalled instructions, because they \"instruct\" the computer what to do.\n这些操作叫\"指令\"(Instruction) \\N 因为它们\"指示\"计算机要做什么\n\nIf these are mathematical instructions, like add or subtract,\n如果是数学指令，比如加/减\n\nthe CPU will configure its ALU to do the mathematical operation.\nCPU 会让 ALU 进行数学运算\n\nOr it might be a memory instruction,\n也可能是内存指令，CPU 会和内存通信，然后读/写值\n\nin which case the CPU will talk with memory to read and write values.\n也可能是内存指令，CPU 会和内存通信，然后读/写值\n\nThere are a lot of parts in a CPU,\nCPU 里有很多组件.\n\nso we're going to lay it out piece by piece, building up as we go.\n所以我们一边说一边建\n\nWe'll focus on functional blocks, rather than showing every single wire.\n我们把重点放在功能，而不是一根根线具体怎么连\n\nWhen we do connect two components with a line,\n当我们用一条线连接两个组件时\n\nthis is an abstraction for all of the necessary wires.\n这条线只是所有必须线路的一个抽象\n\nThis high level view is called the microarchitecture.\n这种高层次视角叫  \"微体系架构\"\n\nOK, first, we're going to need some memory.\n好，我们首先要一些内存，把上集做的 RAM 拿来就行\n\nLets drop in the RAM module we created last episode.\n好，我们首先要一些内存，把上集做的 RAM 拿来就行\n\nTo keep things simple, we'll assume it only has 16 memory locations, each containing 8 bits.\n为了保持简单，假设它只有 16 个位置，每个位置存 8 位\n\nLet's also give our processor four, 8-bit memory registers, labeled A, B, C and D\n再来四个 8 位寄存器，叫 A，B，C，D\n\nwhich will be used to temporarily store and manipulate values.\n寄存器用来 临时存数据 和 操作数据\n\nWe already know that data can be stored in memory as binary values\n我们已经知道数据  是以二进制值存在内存里\n\nand programs can be stored in memory too.\n程序也可以存在内存里\n\nWe can assign an ID to each instruction supported by our CPU.\n我们可以给 CPU 支持的所有指令，分配一个 ID\n\n指令表\n\n指令\n\n描述\n\n4位操作码\n\n地址或寄存器\n\nIn our hypothetical example, we use the first four bits to store the \"operation code\",\n在这个假设的例子 \\N 我们用前四位存 \"操作代码\" （operation code）\n\nor opcode for short.\n简称 \"操作码\" （opcode）\n\nThe final four bits specify where the data for that operation should come from -\n后四位代表数据来自哪里\n\nthis could be registers or an address in memory.\n- 可以是寄存器或内存地址\n\nWe also need two more registers to complete our CPU.\n我们还需要两个寄存器，来完成 CPU.\n\nFirst, we need a register to keep track of where we are in a program.\n1. 一个寄存器追踪程序运行到哪里了，我们叫它  \"指令地址寄存器\"\n\nFor this, we use an instruction address register,\n1. 一个寄存器追踪程序运行到哪里了，我们叫它  \"指令地址寄存器\"\n\nwhich as the name suggests, stores the memory address of the current instruction.\n顾名思义，存当前指令的内存地址\n\nAnd then we need the other register to store the current instruction,\n2. 另一个寄存器存当前指令，叫  \"指令寄存器\"\n\nwhich we'll call the instruction register.\n2. 另一个寄存器存当前指令，叫  \"指令寄存器\"\n\nWhen we first boot up our computer, all of our registers start at 0.\n当启动计算机时，所有寄存器从 0 开始\n\nAs an example, we've initialized our RAM with a simple computer program that we'll to through today.\n为了举例，我们在 RAM 里放了一个程序，我们今天会过一遍\n\nThe first phase of a CPU's operation is called the fetch phase.\nCPU 的第一个阶段叫 \"取指令阶段\"\n\nThis is where we retrieve our first instruction.\n负责拿到指令\n\nFirst, we wire our Instruction Address Register to our RAM module.\n首先，将 \"指令地址寄存器\" 连到 RAM\n\nThe register's value is 0, so the RAM returns whatever value is stored in address 0.\n寄存器的值为 0，因此 RAM 返回地址 0 的值\n\nIn this case, 0010 1110.\n0010 1110 会复制到 \"指令寄存器\" 里\n\nThen this value is copied into our instruction register.\n0010 1110 会复制到 \"指令寄存器\" 里\n\nNow that we've fetched an instruction from memory,\n现在指令拿到了\n\nwe need to figure out what that instruction is\n要弄清是什么指令，才能执行（execute）\n\nso we can execute it.\n要弄清是什么指令，才能执行（execute）\n\nThat is run it.\n而不是杀死（kill）它\n\nNot kill it.\n而不是杀死（kill）它\n\nThis is called the decode phase.\n这是 \"解码阶段\"\n\n指令表\n\n指令\n\n描述\n\n4位操作码\n\n地址或寄存器\n\nIn this case the opcode, which is the first four bits, is: 0010.\n前 4 位 0010 是 LOAD A 指令\n\nThis opcode corresponds to the \"LOAD A\" instruction,\n前 4 位 0010 是 LOAD A 指令\n\nwhich loads a value from RAM into Register A.\n意思是，把 RAM 的值放入寄存器 A\n\nThe RAM address is the last four bits of our instruction which are 1110, or 14 in decimal.\n后 4 位 1110 是 RAM 的地址, 转成十进制是 14\n\nNext, instructions are decoded and interpreted by a Control Unit.\n接下来，指令由 \"控制单元\" 进行解码\n\nLike everything else we've built, it too is made out of logic gates.\n就像之前的所有东西 \\N  \"控制单元\" 也是逻辑门组成的\n\nFor example, to recognize a LOAD A instruction,\n比如，为了识别 \"LOAD A\" 指令\n\nwe need a circuit that checks if the opcode matches 0010\n需要一个电路，检查操作码是不是 0010\n\nwhich we can do with a handful of logic gates.\n我们可以用很少的逻辑门来实现.\n\nNow that we know what instruction we're dealing with,\n现在知道了是什么指令\n\nwe can go ahead and perform that instruction which is the beginning of the execute phase!\n就可以开始执行了，开始 \"执行阶段\"\n\nUsing the output of our LOAD_A checking circuit,\n用 \"检查是否 LOAD_A 指令的电路\"\n\nwe can turn on the RAM's read enable line and send in address 14.\n可以打开 RAM 的 \"允许读取线\", 把地址 14 传过去\n\nThe RAM retrieves the value at that address, which is 00000011, or 3 in decimal.\nRAM 拿到值，0000 0011，十进制的 3\n\nNow, because this is a LOAD_A instruction,\n因为是 LOAD_A 指令 \\N 我们想把这个值只放到寄存器 A，其他寄存器不受影响\n\nwe want that value to only be saved into Register A and not any of the other registers.\n因为是 LOAD_A 指令 \\N 我们想把这个值只放到寄存器 A，其他寄存器不受影响\n\nSo if we connect the RAM's data wires to our four data registers,\n所以需要一根线，把 RAM 连到 4 个寄存器\n\nwe can use our LOAD_A check circuit to enable the write enable only for Register A.\n用 \"检查是否 LOAD_A 指令的电路\" \\N 启用寄存器 A 的 \"允许写入线\"\n\nAnd there you have it\n这就成功了\n\n-- we've successfully loaded the value at RAM address 14 into Register A.\n- 把 RAM 地址 14 的值，放到了寄存器 A.\n\nWe've completed the instruction, so we can turn all of our wires off,\n既然指令完成了，我们可以关掉所有线路\n\nand we are ready to fetch the next instruction in memory.\n去拿下一条指令\n\nTo do this, we increment the Instruction Address Register by 1 which completes the execute phase.\n我们把 \"指令地址寄存器\"+1，\"执行阶段\"就此结束.\n\nLOAD_A is just one of several possible instructions that our CPU can execute.\nLOAD_A 只是 CPU 可以执行的各种指令之一\n\nDifferent instructions are decoded by different logic circuits,\n不同指令由不同逻辑电路解码\n\nwhich configure the CPU's components to perform that action.\n这些逻辑电路会配置 CPU 内的组件来执行对应操作\n\nLooking at all those individual decode circuits is too much detail,\n具体分析这些解码电路太繁琐了\n\nso since we looked at one example,\n既然已经看了 1 个例子，\n\nwe're going to go head and package them all up as a single Control Unit to keep things simple.\n干脆把 \"控制单元 \"包成一个整体，简洁一些.\n\nThat's right a new level of abstraction.\n没错，一层新抽象\n\nThe Control Unit is comparable to the conductor of an orchestra,\n控制单元就像管弦乐队的指挥\n\ndirecting all of the different parts of the CPU.\n\"指挥\" CPU 的所有组件\n\nHaving completed one full fetch/decode/execute cycle,\n\"取指令→解码→执行\" 完成后\n\nwe're ready to start all over again, beginning with the fetch phase.\n现在可以再来一次，从 \"取指令\" 开始\n\nThe Instruction Address Register now has the value 1 in it,\n\"指令地址寄存器\" 现在的值是 1\n\nso the RAM gives us the value stored at address 1, which is 0001 1111.\n所以 RAM 返回地址 1 里的值：0001 1111\n\nOn to the decode phase!\n到 \"解码\" 阶段！\n\n0001 is the \"LOAD B\" instruction, which moves a value from RAM into Register B.\n0001 是 LOAD B 指令 \\N 从 RAM 里把一个值复制到寄存器 B\n\nThe memory location this time is 1111, which is 15 in decimal.\n这次内存地址是 1111，十进制的 15\n\nNow to the execute phase!\n现在到 \"执行阶段\"！\n\nThe Control Unit configures the RAM to read address 15 and configures Register B to receive the data.\n\"控制单元\" 叫 RAM 读地址 15，并配置寄存器 B 接收数据\n\nBingo, we just saved the value 00001110, or the number 14 in decimal, into Register B.\n成功，我们把值 0000 1110 \\N 也就是十进制的 14 存到了寄存器 B\n\nLast thing to do is increment our instruction address register by 1,\n最后一件事是 \"指令地址寄存器\" +1\n\nand we're done with another cycle.\n我们又完成了一个循环\n\nOur next instruction is a bit different.\n下一条指令有点不同\n\nLet's fetch it.\n来取它吧\n\n1000 0100.\n1000 0100\n\nThat opcode 1000 is an ADD instruction.\n1000 是 ADD 指令\n\nInstead of an 4-bit RAM address, this instruction uses two sets of 2 bits.\n这次后面的 4 位不是 RAM 地址，\\N 而是 2 位 2 位分别代表 2 个寄存器\n\nRemember that 2 bits can encode 4 values,\n2 位可以表示 4 个值\n\nso 2 bits is enough to select any one of our 4 registers.\n所以足够表示 4 个寄存器\n\nThe first set of 2 bits is 01, which in this case corresponds to Register B,\n第一个地址是 01, 代表寄存器B\n\nand 00, which is Register A.\n第二个地址是 00, 代表寄存器A\n\nSo \"1000 01 00\" is the instruction for adding the value in Register B into the value in register A.\n因此，1000 0100，代表把寄存器 B 的值，加到寄存器 A 里\n\nSo to execute this instruction, we need to integrate the ALU we made in Episode 5 into our CPU.\n为了执行这个指令，我们要整合第 5 集的 ALU\n\nThe Control Unit is responsible for selecting the right registers to pass in as inputs,\n\"控制单元\" 负责选择正确的寄存器作为输入\n\nand configuring the ALU to perform the right operation.\n并配置 ALU 执行正确的操作\n\nFor this ADD instruction, the Control Unit enables Register B\n对于 \"ADD\" 指令， \"控制单元\" 会\n\nand feeds its value into the first input of the ALU.\n启用寄存器 B，作为 ALU 的第一个输入\n\nIt also enables Register A and feeds it into the second ALU input.\n还启用寄存器 A，作为 ALU 的第二个输入\n\nAs we already discussed, the ALU itself can perform several different operations,\n之前说过，ALU 可以执行不同操作\n\nso the Control Unit must configure it to perform an ADD operation by passing in the ADD opcode.\n所以控制单元必须传递 ADD 操作码告诉它要做什么\n\nFinally, the output should be saved into Register A.\n最后，结果应该存到寄存器 A\n\nBut it can't be written directly\n但不能直接写入寄存器 A\n\nbecause the new value would ripple back into the ALU and then keep adding to itself.\n这样新值会进入 ALU ，不断和自己相加\n\nSo the Control Unit uses an internal register to temporarily save the output,\n因此，控制单元用一个自己的寄存器暂时保存结果\n\nturn off the ALU, and then write the value into the proper destination register.\n关闭 ALU，然后把值写入正确的寄存器\n\nIn this case, our inputs were 3 and 14, and so the sum is 17, or 00010001 in binary,\n这里 3+14=17，二进制是 0001 0001\n\nwhich is now sitting in Register A.\n现在存到了寄存器 A\n\nAs before, the last thing to do is increment our instruction address by 1,\n和之前一样，最后一件事是把指令地址 + 1\n\nand another cycle is complete.\n这个循环就完成了\n\nOkay, so let's fetch one last instruction: 0100 1101.\n好，来看最后一个指令：0100 1101\n\nWhen we decode it we see that 0100 is a STORE_A instruction, with a RAM address of 13.\n解码得知是 STORE A 指令（把寄存器 A 的值放入内存） \\N RAM 地址 13\n\nAs usual, we pass the address to the RAM module,\n接下来，把地址传给 RAM\n\nbut instead of read-enabling the memory, we write-enable it.\n但这次不是 \"允许读取\" ，而是 \"允许写入\"\n\nAt the same time, we read-enable Register A.\n同时，打开寄存器 A 的 \"允许读取\"\n\nThis allows us to use the data line to pass in the value stored in register A.\n这样就可以把寄存器 A 里的值，传给 RAM\n\nCongrats, we just ran our first computer program!\n恭喜，我们刚运行了第一个电脑程序！\n\nIt loaded two values from memory, added them together,\n它从内存中加载两个值，相加，然后把结果放回内存\n\nand then saved that sum back into memory.\n它从内存中加载两个值，相加，然后把结果放回内存\n\nOf course, by me talking you through the individual steps,\n刚刚是我一步步来讲的,\n\nI was manually transitioning the CPU through its fetch, decode and execute phases.\n我们人工切换 CPU 的状态 \"取指令→解码→执行\"\n\nBut there isn't a mini Carrie Anne inside of every computer.\n但不是每台电脑里都有一个迷你 Carrie Anne\n\nSo the responsibility of keeping the CPU ticking along falls to a component called the clock.\n其实是 \"时钟\" 来负责管理 CPU 的节奏\n\nAs it's name suggests, the clock triggers an electrical signal at a precise and regular interval.\n时钟以精确的间隔  触发电信号\n\nIts signal is used by the Control Unit to advance the internal operation of the CPU,\n控制单元会用这个信号，推进 CPU 的内部操作\n\nkeeping everything in lock-step\n确保一切按步骤进行\n\n- like the dude on a Roman galley drumming rhythmically at the front,\n- 就像罗马帆船的船头，有一个人负责按节奏的击鼓,\n\nkeeping all the rowers synchronized... or a metronome.\n让所有划船的人同步... 就像节拍器一样\n\nOf course you can't go too fast,\n节奏不能太快\n\nbecause even electricity takes some time to travel down wires and for the signal to settle.\n因为就算是电也要一定时间来传输\n\nThe speed at which a CPU can carry out each step of the fetch-decode-execute cycle\nCPU \"取指令→解码→执行\" 的速度叫 \"时钟速度\"\n\nis called its Clock Speed.\nCPU \"取指令→解码→执行\" 的速度叫 \"时钟速度\"\n\nThis speed is measured in Hertz - a unit of frequency.\n单位是赫兹 - 赫兹是用来表示频率的单位\n\nOne Hertz means one cycle per second.\n1 赫兹代表一秒 1 个周期\n\nGiven that it took me about 6 minutes to talk you through 4 instructions\n因为我花了大概 6 分钟，给你讲了 4 条指令\n\nLOAD, LOAD, ADD and STORE\n读取→读取→相加→存储\n\nthat means I have an effective clock speed of roughly .03 Hertz.\n所以我的时钟速度大概是 0.03 赫兹\n\nAdmittedly, I'm not a great computer\n我承认我算数不快\n\nbut even someone handy with math might only be able to do one calculation in their head every second or 1 Hertz.\n但哪怕有人算数很快，最多也就是一秒一次，或 1 赫兹\n\nThe very first, single-chip CPU was the Intel 4004, a 4-bit CPU released in 1971.\n第一个单芯片 CPU 是 \"英特尔 4004\" \\N 1971 年发布的 4 位CPU\n\nIt's microarchitecture is actually pretty similar to our example CPU.\n它的微架构 很像我们之前说的 CPU\n\nDespite being the first processor of its kind,\n虽然是第一个单芯片的处理器\n\nit had a mind-blowing clock speed of 740 Kilohertz\n但它的时钟速度达到了 740 千赫兹 - 每秒 74 万次\n\n-- that's 740 thousand cycles per second.\n但它的时钟速度达到了 740 千赫兹 - 每秒 74 万次\n\nYou might think that's fast,\n你可能觉得很快\n\nbut it's nothing compared to the processors that we use today.\n但和如今的处理器相比不值一提\n\nOne megahertz is one million clock cycles per second,\n一兆赫兹是 1 秒 1 百万个时钟周期\n\nand the computer or even phone that you are watching this video on right now is no doubt a few gigahertz\n你现在看视频的电脑或手机，肯定有几千兆赫兹\n\n-- that's BILLIONs of CPU cycles every single... second.\n- 1 秒 10 亿次时钟周期\n\nAlso, you may have heard of people overclocking their computers.\n你可能听过有人会把计算机超频\n\nThis is when you modify the clock to speed up the tempo of the CPU\n意思是修改时钟速度，加快 CPU 的速度\n\n-- like when the drummer speeds up when the Roman Galley needs to ram another ship.\n- 就像罗马帆船要撞另一艘船时，鼓手会加快敲鼓速度\n\nChip makers often design CPUs with enough tolerance to handle a little bit of overclocking,\n芯片制造商经常给 CPU 留一点余地，可以接受一点超频\n\nbut too much can either overheat the CPU,\n但超频太多会让 CPU 过热\n\nor produce gobbledygook as the signals fall behind the clock.\n或产生乱码，因为信号跟不上时钟\n\nAnd although you don't hear very much about underclocking,\n你可能很少听说降频\n\nit's actually super useful.\n但降频其实很有用\n\nSometimes it's not necessary to run the processor at full speed...\n有时没必要让处理器全速运行\n\nmaybe the user has stepped away, or just not running a particularly demanding program.\n可能用户走开了，或者在跑一个性能要求较低的程序\n\nBy slowing the CPU down, you can save a lot of power,\n把 CPU 的速度降下来，可以省很多电\n\nwhich is important for computers that run on batteries, like laptops and smartphones.\n省电对用电池的设备很重要，比如笔记本和手机\n\nTo meet these needs,\n为了尽可能省电\n\nmany modern processors can increase or decrease their clock speed based on demand,\n很多现代处理器可以按需求  加快或减慢时钟速度\n\nwhich is called dynamic frequency scaling.\n这叫 \"动态调整频率\"\n\nSo, with the addition of a clock, our CPU is complete.\n加上时钟后，CPU 才是完整的.\n\nWe can now put a box around it, and make it its own component.\n现在可以放到盒子里，变成一个独立组件\n\nYup.\n对\n\nA new level of abstraction!\n一层新的抽象！\n\nRAM, as I showed you last episode,\nRAM，上集说过，是在 CPU 外面的独立组件\n\nlies outside the CPU as its own component,\nRAM，上集说过，是在 CPU 外面的独立组件\n\nand they communicate with each other using address, data and enable wires.\nCPU 和 RAM 之间 \\N 用 \"地址线\"  \"数据线\" 和 \"允许读/写线\" 进行通信\n\nAlthough the CPU we designed today is a simplified example,\n虽然今天我们设计的 CPU 是简化版的,\n\nmany of the basic mechanics we discussed are still found in modern processors.\n但我们提到的很多机制，依然存在于现代处理器里\n\nNext episode, we're going to beef up our CPU,\n下一集，我们要加强 CPU，给它扩展更多指令.\n\nextending it with more instructions as we take our first baby steps into software.\n同时开始讲软件.\n\nI'll see you next week.\n下周见\n\nHi, I’m Carrie Anne and this is Crash Course Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nLast episode, we combined an ALU, control unit, some memory, and a clock together to\n上集我们把 ALU, 控制单元, RAM, 时钟 结合在一起\n\nmake a basic, but functional Central Processing Unit – or CPU\n做了个基本，但可用的\"中央处理单元\", 简称 CPU\n\n– the beating, ticking heart of a computer.\n它是计算机的核心\n\nWe’ve done all the hard work of building many of these components from the electronic\n我们已经用电路做了很多组件.\n\ncircuits up, and now it’s time to give our CPU some actual instructions to process!\n这次我们给 CPU 一些指令来运行!\n\nThe thing that makes a CPU powerful is the fact that it is programmable –\nCPU 之所以强大，是因为它是可编程的 -\n\nif you write a different sequence of instructions, then the CPU will perform a different task.\n如果写入不同指令，就会执行不同任务\n\nSo the CPU is a piece of hardware which is controlled by easy-to-modify software!\nCPU 是一块硬件，可以被软件控制!\n\nLet’s quickly revisit the simple program that we stepped through last episode.\n我们重新看一下上集的简单程序\n\nThe computer memory looked like this.\n内存里有这些值\n\nEach address contained 8 bits of data.\n每个地址可以存 8 位数据\n\nFor our hypothetical CPU, the first four bits specified the operation code, or opcode, and\n因为我们的 CPU 是假设的，这里前4位是\"操作码\"\n\nthe second set of four bits specified an address or registers.\n后4位指定一个内存地址，或寄存器.\n\nIn memory address zero we have 0010 1110.\n内存地址 0 是 0010 1110\n\nAgain, those first four bits are our opcode which corresponds to a \"LOAD_A\" instruction.\n前 4 位代表 LOAD_A 指令\n\nThis instruction reads data from a location of memory specified in those last four bits\n意思是：把后 4 位指定的内存地址的值，放入寄存器 A\n\nof the instruction and saves it into Register A. In this case, 1110, or 14 in decimal.\n后 4 位是 1110，十进制的 14\n\nSo let’s not think of this of memory address 0 as \"0010 1110\", but rather as the instruction\n我们来把 0010 1110 看成 \"LOAD_A 14\" 指令\n\n\"LOAD_A 14\".\n我们来把 0010 1110 看成 \"LOAD_A 14\" 指令\n\nThat’s much easier to read and understand!\n这样更好理解！\n\nAnd for me to say!\n也更方便说清楚\n\nAnd we can do the same thing for the rest of the data in memory.\n可以对内存里剩下的数也这样转换.\n\nIn this case, our program is just four instructions long,\n这里，我们的程序只有4个指令\n\nand we’ve put some numbers into memory too, 3 and 14.\n还有数字 3 和 14\n\nSo now let’s step through this program:\n现在一步步看\n\nFirst is LOAD_A 14, which takes the value in address 14, which is the number 3,\n\"LOAD_A 14\" 是从地址 14 中拿到数字3，放入寄存器A\n\nand stores it into Register A.\n\"LOAD_A 14\" 是从地址 14 中拿到数字3，放入寄存器A\n\nThen we have a \"LOAD_B 15\" instruction, which takes the value in memory location 15,\n\"LOAD_B 15\" 是从地址 15 中拿到数字14，放入寄存器B\n\nwhich is the number 14, and saves it into Register B.\n\"LOAD_B 15\" 是从地址 15 中拿到数字14，放入寄存器B\n\nOkay.\n好.\n\nEasy enough.\n挺简单的！\n\nBut now we have an \"ADD\" instruction.\n下一个是 ADD 指令\n\nThis tells the processor to use the ALU to add two registers together,\n\"ADD B A\" 告诉 ALU \\N 把寄存器 B 和寄存器 A 里的数字加起来\n\nin this case, B and A are specified.\n\"ADD B A\" 告诉 ALU \\N 把寄存器 B 和寄存器 A 里的数字加起来\n\nThe ordering is important, because the resulting sum is saved into the second register that’s specified.\n（B和A的）顺序很重要，因为结果会存在第二个寄存器\n\nSo in this case, the resulting sum is saved into Register A.\n也就是寄存器 A\n\nAnd finally, our last instruction is \"STORE_A 13\", which instructs the CPU to write whatever\n最后一条指令是 \"STORE_A 13\" \\N 把寄存器 A 的值存入内存地址 13\n\nvalue is in Register A into memory location 13.\n最后一条指令是 \"STORE_A 13\" \\N 把寄存器 A 的值存入内存地址 13\n\nYesss!\n好棒！\n\nOur program adds two numbers together.\n我们把 2 个数加在了一起!\n\nThat’s about as exciting as it gets when we only have four instructions to play with.\n毕竟只有4个指令，也只能做这个了.\n\nSo let’s add some more!\n加多一些指令吧!\n\nNow we’ve got a subtract function, which like ADD, specifies two registers to operate on.\nSUB 是减法，和 ADD 一样也要 2 个寄存器来操作.\n\nWe’ve also got a fancy new instruction called JUMP.\n还有 JUMP（跳转）\n\nAs the name implies, this causes the program to \"jump\" to a new location.\n让程序跳转到新位置\n\nThis is useful if we want to change the order of instructions, or choose to skip some instructions.\n如果想改变指令顺序，或跳过一些指令，这个很实用\n\nFor example, a JUMP 0, would cause the program to go back to the beginning.\n举例, JUMP 0 可以跳回开头\n\nAt a low level, this is done by writing the value specified in the last four bits into\nJUMP 在底层的实现方式是 \\N 把指令后 4 位代表的内存地址的值\n\nthe instruction address register, overwriting the current value.\n覆盖掉 \"指令地址寄存器\" 里的值\n\nWe’ve also added a special version of JUMP called JUMP_NEGATIVE.\n还有一个特别版的 JUMP 叫 JUMP_NEGATIVE\n\n\"This only jumps the program if the ALU’s negative flag is set to true.\n它只在 ALU 的 \"负数标志\" 为真时，进行 JUMP\n\nAs we talked about in Episode 5, the negative flag is only set\n第5集讲过，算术结果为负，\"负数标志\"才是真\n\nwhen the result of an arithmetic operation is negative.\n第5集讲过，算术结果为负，\"负数标志\"才是真\n\nIf the result of the arithmetic was zero or positive, the negative flag would not be set.\n结果不是负数时, \"负数标志\"为假\n\nSo the JUMP NEGATIVE won’t jump anywhere, and the CPU will just continue on to the next instruction.\n如果是假，JUMP_NEGATIVE 就不会执行 \\N 程序照常进行\n\nOur previous program really should have looked like this to be correct,\n我们之前的例子程序，其实应该是这样，才能正确工作.\n\notherwise the CPU would have just continued on after the STORE instruction, processing all those 0’s.\n否则跑完  STORE_A 13 之后，\\N CPU 会不停运行下去，处理后面的 0\n\nBut there is no instruction with an opcode of 0, and so the computer would have crashed!\n因为 0 不是操作码，所以电脑会崩掉!\n\nIt’s important to point out here that we’re storing\n我还想指出一点，指令和数据都是存在同一个内存里的.\n\nboth instructions and data in the same memory.\n我还想指出一点，指令和数据都是存在同一个内存里的.\n\nThere is no difference fundamentally -- it’s all just binary numbers.\n它们在根本层面上毫无区别 - 都是二进制数\n\nSo the HALT instruction is really important because it allows us to separate the two.\nHALT 很重要，能区分指令和数据\n\nOkay, so let’s make our program a bit more interesting, by adding a JUMP.\n好，现在用 JUMP 让程序更有趣一些.\n\nWe’ll also modify our two starting values in memory to 1 and 1.\n我们还把内存中 3 和 14 两个数字，改成 1 和 1\n\nLets step through this program just as our CPU would.\n现在来从 CPU 的视角走一遍程序\n\nFirst, LOAD_A 14 loads the value 1 into Register A.\n首先 LOAD_A 14，把 1 存入寄存器A \\N（因为地址 14 里的值是 1）\n\nNext, LOAD_B 15 loads the value 1 into Register B.\n然后 LOAD_B 15，把 1 存入寄存器B\\N（因为地址 15 里的值也是 1）\n\nAs before, we ADD registers B and A together, with the sum going into Register A. 1+1 = 2,\n然后 ADD B A 把寄存器 B 和 A 相加 \\N 结果放到寄存器 A 里\n\nso now Register A has the value 2 in it (stored in binary of course)\n现在寄存器 A 的值是 2 \\N (当然是以二进制存的）\n\nThen the STORE instruction saves that into memory location 13.\n然后 STORE_A 13 指令，把寄存器 A 的值存入内存地址 13\n\nNow we hit a \"JUMP 2\" instruction.\n现在遇到 JUMP 2 指令\n\nThis causes the processor to overwrite the value in the instruction address register,\nCPU 会把\"指令地址寄存器\"的值，现在是 4，改成 2\n\nwhich is currently 4, with the new value, 2.\nCPU 会把\"指令地址寄存器\"的值，现在是 4，改成 2\n\nNow, on the processor’s next fetch cycle, we don’t fetch HALT,\n因此下一步不再是 HALT\n\ninstead we fetch the instruction at memory location 2, which is ADD B A.\n而是读内存地址 2 里的指令，也就是 ADD B A\n\nWe’ve jumped!\n我们跳转了!\n\nRegister A contains the value 2, and register B contains the value 1.\n寄存器 A 里是 2，寄存器 B 里是 1\n\nSo 1+2 = 3, so now Register A has the value 3.\n1+2=3，寄存器 A 变成 3\n\nWe store that into memory.\n存入内存\n\nAnd we’ve hit the JUMP again, back to ADD B A.\n又碰到 JUMP 2，又回到 ADD B A.\n\n1+3=4\n1+3=4\n\nSo now register A has the value 4.\n现在寄存器 A 是 4\n\nSee what's happening here?\n发现了吗？\n\nEvery loop, we’re adding one.\n每次循环都+1\n\nIts counting up!\n不断增多\n\nCooooool.\n酷\n\nBut notice there’s no way to ever escape.\n但没法结束啊\n\nWe’re never.. ever.. going to get to that halt instruction,\n永远不会碰到 HALT\n\nbecause we’re always going to hit that JUMP.\n总是会碰到 JUMP\n\nThis is called an infinite loop – a program that runs forever… ever… ever… ever…\n这叫无限循环 - 这个程序会永远跑下去.. 下去.. 下去.. 下去\n\never\n下去\n\nTo break the loop, we need a conditional jump.\n为了停下来，我们需要有条件的 JUMP\n\nA jump that only happens if a certain condition is met.\n只有特定条件满足了，才执行 JUMP.\n\nOur JUMP_NEGATIVE is one example of a conditional jump,\n比如 JUMP NEGATIVE 就是条件跳转的一个例子\n\nbut computers have other types too - like JUMP IF EQUAL and JUMP IF GREATER.\n还有其他类型的条件跳转，比如\\N  JUMP IF EQUAL（如果相等）\\N JUMP IF GREATER（如果更大）\n\nSo let’s make our code a little fancier and step through it.\n现在把代码弄花哨一点，再过一遍代码\n\nLike before, the program starts by loading values from memory into registers A and B.\n就像之前，程序先把内存值放入寄存器 A 和 B.\n\nIn this example, the number 11 gets loaded into Register A, and 5 gets loaded into Register B.\n寄存器 A 是 11，寄存器 B 是 5\n\nNow we subtract register B from register A. That’s 11 minus 5, which is 6,\nSUB B A，用 A 减 B，11-5=6\n\nand so 6 gets saved into Register A.\n6 存入寄存器 A\n\nNow we hit our JUMP NEGATIVE.\nJUMP NEGATIVE 出场\n\nThe last ALU result was 6.\n上一次 ALU 运算的结果是 6\n\nThat’s a positive number, so the the negative flag is false.\n是正数，所以 \"负数标志\" 是假\n\nThat means the processor does not jump.\n因此处理器不会执行 JUMP\n\nSo we continue on to the next instruction...\n继续下一条指令\n\n...which is a JUMP 2.\nJUMP 2\n\nNo conditional on this one, so we jump to instruction 2 no matter what.\nJUMP 2 没有条件，直接执行！\n\nOk, so we’re back at our SUBTRACT Register B from Register A. 6 minus 5 equals 1.\n又回到寄存器 A-B，6-5=1\n\nSo 1 gets saved into register A.\nA 变成 1\n\nNext instruction.\n下一条指令\n\nWe’re back again at our JUMP NEGATIVE.\n又是 JUMP NEGATIVE\n\n1 is also a positive number, so the CPU continues on to the JUMP 2, looping back around again\n因为 1 还是正数，因此 JUMP NEGATIVE 不会执行 \\N 来到下一条指令，JUMP 2\n\nto the SUBTRACT instruction.\n又来减一次\n\nThis time is different though.\n这次就不一样了\n\n1 minus 5 is negative 4.\n1-5=-4\n\nAnd so the ALU sets its negative flag to true for the first time.\n这次ALU的 \"负数标志\" 是真\n\nNow, when we advance to the next instruction,\n现在下一条指令\n\nJUMP_NEGATIVE 5, the CPU executes the jump to memory location 5.\nJUMP NEGATIVE 5, CPU 的执行跳到内存地址 5\n\nWe’re out of the infinite loop!\n跳出了无限循环！\n\nNow we have a ADD B to A. Negative 4 plus 5, is positive 1, and we save that into Register A.\n现在的指令是 ADD B A，-4+5=1，1 存入寄存器 A\n\nNext we have a STORE instruction that saves Register A into memory address 13.\n下一条指令  STORE_A 13，把 A 的值存入内存地址 13\n\nLastly, we hit our HALT instruction and the computer rests.\n最后碰到 HALT 指令，停下来.\n\nSo even though this program is only 7 instructions long, the CPU ended up executing 13 instructions,\n虽然程序只有 7 个指令，但 CPU 执行了 13 个指令,\n\nand that's because it looped twice internally.\n因为在内部循环了 2 次.\n\nThis code calculated the remainder if we divide 5 into 11, which is one.\n这些代码其实是算余数的，11除5余1\n\nWith a few extra lines of code, we could also keep track of how many loops we did, the count\n如果加多几行指令，我们还可以跟踪循环了多少次\n\nof which would be how many times 5 went into 11… we did two loops, so that means 5 goes\n11除5，循环2次\n\ninto 11 two times... with a remainder of 1.\n余1\n\nAnd of course this code could work for any two numbers, which we can just change in memory\n当然，我们可以用任意2个数，7和81，18和54，什么都行\n\nto whatever we want: 7 and 81, 18 and 54, it doesn’t matter\n当然，我们可以用任意2个数，7和81，18和54，什么都行\n\n-- that’s the power of software!\n这就是软件的强大之处\n\nSoftware also allowed us to do something our hardware could not.\n软件还让我们做到硬件做不到的事\n\nRemember, our ALU didn’t have the functionality to divide two numbers,\nALU 可没有除法功能\n\ninstead it’s the program we made that gave us that functionality.\n是程序给了我们这个功能.\n\nAnd then other programs can use our divide program to do even fancier things.\n别的程序也可以用我们的除法程序，来做其他事情\n\nAnd you know what that means.\n这意味着  一层新抽象！\n\nNew levels of abstraction!\n这意味着  一层新抽象！\n\nSo, our hypothetical CPU is very basic – all of its instructions are 8 bits long,\n我们这里假设的 CPU 很基础，所有指令都是 8 位,\n\nwith the opcode occupying only the first four bits.\n操作码只占了前面 4 位\n\nSo even if we used every combination of 4 bits, our CPU would only be able to support\n即便用尽 4 位，也只能代表 16 个指令\n\na maximum of 16 different instructions.\n即便用尽 4 位，也只能代表 16 个指令\n\nOn top of that, several of our instructions used the last 4 bits to specify a memory location.\n而且我们有几条指令，是用后 4 位来指定内存地址\n\nBut again, 4 bits can only encode 16 different values,\n因为 4 位最多只能表示 16 个值，\n\nmeaning we can address a maximum of 16 memory locations - that’s not a lot to work with.\n所以我们只能操作 16 个地址，这可不多.\n\nFor example, we couldn’t even JUMP to location 17,\n我们甚至不能 JUMP 17\n\nbecause we literally can’t fit the number 17 into 4 bits.\n因为 4 位二进制无法表示数字 17\n\nFor this reason, real, modern CPUs use two strategies.\n因此，真正的现代 CPU 用两种策略\n\nThe most straightforward approach is just to have bigger instructions, with more bits,\n最直接的方法是用更多位来代表指令，比如 32 位或 64 位\n\nlike 32 or 64 bits.\n最直接的方法是用更多位来代表指令，比如 32 位或 64 位\n\nThis is called the instruction length.\n这叫 指令长度\n\nUnsurprisingly.\n毫不意外\n\nThe second approach is to use variable length instructions.\n第二个策略是 \"可变指令长度\"\n\nFor example, imagine a CPU that uses 8 bit opcodes.\n举个例子，比如某个 CPU 用 8 位长度的操作码\n\nWhen the CPU sees an instruction that needs no extra values, like the HALT instruction,\n如果看到 HALT 指令，HALT 不需要额外数据\n\nit can just execute it immediately.\n那么会马上执行.\n\nHowever, if it sees something like a JUMP instruction, it knows it must also fetch\n如果看到 JUMP，它得知道位置值\n\nthe address to jump to, which is saved immediately behind the JUMP instruction in memory.\n这个值在 JUMP 的后面\n\nThis is called, logically enough, an Immediate Value.\n这叫 \"立即值\"\n\nIn such processor designs, instructions can be any number of bytes long,\n这样设计，指令可以是任意长度\n\nwhich makes the fetch cycle of the CPU a tad more complicated.\n但会让读取阶段复杂一点点\n\nNow, our example CPU and instruction set is hypothetical,\n要说明的是，我们拿来举例的 CPU 和指令集都是假设的,\n\ndesigned to illustrate key working principles.\n是为了展示核心原理\n\nSo I want to leave you with a real CPU example.\n所以我们来看个真的 CPU 例子.\n\nIn 1971, Intel released the 4004 processor.\n1971年，英特尔发布了 4004 处理器.\n\nIt was the first CPU put all into a single chip\n这是第一次把 CPU 做成一个芯片  \\N 给后来的英特尔处理器打下了基础\n\nand paved the path to the intel processors we know and love today.\n这是第一次把 CPU 做成一个芯片  \\N 给后来的英特尔处理器打下了基础\n\nIt supported 46 instructions, shown here.\n它支持 46 个指令\n\nWhich was enough to build an entire working computer.\n足够做一台能用的电脑\n\nAnd it used many of the instructions we’ve talked about like JUMP ADD SUBTRACT and LOAD.\n它用了很多我们说过的指令，比如 JUMP ADD SUB LOAD\n\nIt also uses 8-bit immediate values, like we just talked about, for things like JUMPs,\n它也用 8 位的\"立即值\"来执行 JUMP, 以表示更多内存地址.\n\nin order to address more memory.\n它也用 8 位的\"立即值\"来执行 JUMP, 以表示更多内存地址.\n\nAnd processors have come a long way since 1971.\n处理器从 1971 年到现在发展巨大.\n\nA modern computer processor, like an Intel Core i7, has thousands of different instructions\n现代 CPU, 比如英特尔酷睿 i7, 有上千个指令和指令变种\n\nand instruction variants, ranging from one to fifteen bytes long.\n长度从1到15个字节.\n\nFor example, there’s over a dozens different opcodes just for variants of ADD!\n举例，光 ADD 指令就有很多变种!\n\nAnd this huge growth in instruction set size is due in large part to extra bells and whistles\n指令越来越多，是因为给 CPU 设计了越来越多功能\n\nthat have been added to processor designs overtime, which we’ll talk about next episode.\n下集我们会讲\n\nSee you next week!\n下周见\n\nHi, I’m Carrie Anne and welcome to CrashCourse Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nAs we’ve discussed throughout the series, computers have come a long way from mechanical devices\n随着本系列进展，我们知道计算机进步巨大\n\ncapable of maybe one calculation per second,\n从 1 秒 1 次运算，到现在有千赫甚至兆赫的CPU\n\nto CPUs running at kilohertz and megahertz speeds.\n从 1 秒 1 次运算，到现在有千赫甚至兆赫的CPU\n\nThe device you’re watching this video on right now is almost certainly running at Gigahertz speeds\n你现在看视频的设备八成也有 GHz 速度\n\n- that’s billions of instructions executed every second.\n1 秒十亿条指令\n\nWhich, trust me, is a lot of computation!\n这是很大的计算量！\n\nIn the early days of electronic computing, processors were typically made faster by\n早期计算机的提速方式是  减少晶体管的切换时间.\n\nimproving the switching time of the transistors inside the chip\n早期计算机的提速方式是  减少晶体管的切换时间.\n\n- the ones that make up all the logic gates, ALUs\n晶体管组成了逻辑门，ALU 以及前几集的其他组件\n\nand other stuff we’ve talked about over the past few episodes.\n晶体管组成了逻辑门，ALU 以及前几集的其他组件\n\nBut just making transistors faster and more efficient only went so far, so processor designers\n但这种提速方法最终会碰到瓶颈，所以处理器厂商\n\nhave developed various techniques to boost performance allowing not only simple instructions\n发明各种新技术来提升性能，不但让简单指令运行更快\n\nto run fast, but also performing much more sophisticated operations.\n也让它能进行更复杂的运算\n\nLast episode, we created a small program for our CPU that allowed us to divide two numbers.\n上集我们写了个做除法的程序，给 CPU 执行\n\nWe did this by doing many subtractions in a row... so, for example, 16 divided by 4\n方法是做一连串减法，比如16除4 会变成\n\ncould be broken down into the smaller problem of 16 minus 4, minus 4, minus 4, minus 4.\n16-4 -4 -4 -4\n\nWhen we hit zero, or a negative number, we knew that we we’re done.\n碰到 0 或负数才停下.\n\nBut this approach gobbles up a lot of clock cycles, and isn’t particularly efficient.\n但这种方法要多个时钟周期，很低效\n\nSo most computer processors today have divide as one of the instructions\n所以现代 CPU 直接在硬件层面设计了除法 \\N 可以直接给 ALU 除法指令\n\nthat the ALU can perform in hardware.\n所以现代 CPU 直接在硬件层面设计了除法 \\N 可以直接给 ALU 除法指令\n\nOf course, this extra circuitry makes the ALU bigger and more complicated to design,\n这让 ALU 更大也更复杂一些\n\nbut also more capable - a complexity-for-speed tradeoff that\n但也更厉害 - \\N  复杂度 vs 速度 的平衡在计算机发展史上经常出现\n\nhas been made many times in computing history.\n但也更厉害 - \\N  复杂度 vs 速度 的平衡在计算机发展史上经常出现\n\nFor instance, modern computer processors now have special circuits for things like\n举例，现代处理器有专门电路来处理 \\N 图形操作, 解码压缩视频, 加密文档 等等\n\ngraphics operations, decoding compressed video, and encrypting files\n举例，现代处理器有专门电路来处理 \\N 图形操作, 解码压缩视频, 加密文档 等等\n\nall of which are operations that would take many many many clock cycles to perform with standard operations.\n如果用标准操作来实现，要很多个时钟周期.\n\nYou may have even heard of processors with MMX, 3DNow!, or SSE.\n你可能听过某些处理器有 MMX, 3DNOW, SEE\n\nThese are processors with additional, fancy circuits that allow them to\n它们有额外电路做更复杂的操作\n\nexecute additional fancy instructions - for things like gaming and encryption.\n用于游戏和加密等场景\n\nThese extensions to the instruction set have grown, and grown over time, and once people\n指令不断增加，人们一旦习惯了它的便利就很难删掉\n\nhave written programs to take advantage of them, it’s hard to remove them.\n指令不断增加，人们一旦习惯了它的便利就很难删掉\n\nSo instruction sets tend to keep getting larger and larger keeping all the old opcodes around for backwards compatibility.\n所以为了兼容旧指令集，指令数量越来越多\n\nThe Intel 4004, the first truly integrated CPU, had 46 instructions\n英特尔 4004，第一个集成CPU，有 46 条指令\n\n- which was enough to build a fully functional computer.\n足够做一台能用的计算机\n\nBut a modern computer processor has thousands of different instructions,\n但现代处理器有上千条指令，有各种巧妙复杂的电路\n\nwhich utilize all sorts of clever and complex internal circuitry.\n但现代处理器有上千条指令，有各种巧妙复杂的电路\n\nNow, high clock speeds and fancy instruction sets lead to another problem\n超高的时钟速度带来另一个问题\n\n- getting data in and out of the CPU quickly enough.\n- 如何快速传递数据给 CPU\n\nIt’s like having a powerful steam locomotive, but no way to shovel in coal fast enough.\n就像有强大的蒸汽机  但无法快速加煤\n\nIn this case, the bottleneck is RAM.\nRAM 成了瓶颈\n\nRAM is typically a memory module that lies outside the CPU.\nRAM 是 CPU 之外的独立组件\n\nThis means that data has to be transmitted to and from RAM along sets of data wires,\n意味着数据要用线来传递，叫\"总线\"\n\ncalled a bus.\n意味着数据要用线来传递，叫\"总线\"\n\nThis bus might only be a few centimeters long,\n总线可能只有几厘米\n\nand remember those electrical signals are traveling near the speed of light,\n别忘了电信号的传输接近光速\n\nbut when you are operating at gigahertz speeds\n但 CPU 每秒可以处理上亿条指令\n\n– that’s billionths of a second – even this small delay starts to become problematic.\n很小的延迟也会造成问题\n\nIt also takes time for RAM itself to lookup the address, retrieve the data\nRAM 还需要时间找地址 \\N 取数据，配置，输出数据\n\nand configure itself for output.\nRAM 还需要时间找地址 \\N 取数据，配置，输出数据\n\nSo a “load from RAM” instruction might take dozens of clock cycles to complete, and during\n一条\"从内存读数据\"的指令可能要多个时钟周期\n\nthis time the processor is just sitting there idly waiting for the data.\nCPU 空等数据\n\nOne solution is to put a little piece of RAM right on the CPU -- called a cache.\n解决延迟的方法之一是 \\N 给 CPU 加一点 RAM - 叫\"缓存\"\n\nThere isn’t a lot of space on a processor’s chip,\n因为处理器里空间不大，所以缓存一般只有 KB 或 MB\n\nso most caches are just kilobytes or maybe megabytes in size,\n因为处理器里空间不大，所以缓存一般只有 KB 或 MB\n\nwhere RAM is usually gigabytes.\n而 RAM 都是 GB 起步\n\nHaving a cache speeds things up in a clever way.\n缓存提高了速度\n\nWhen the CPU requests a memory location from RAM, the RAM can transmit\nCPU 从 RAM 拿数据时 \\N RAM 不用传一个，可以传一批\n\nnot just one single value, but a whole block of data.\nCPU 从 RAM 拿数据时 \\N RAM 不用传一个，可以传一批\n\nThis takes only a little bit more time,\n虽然花的时间久一点，但数据可以存在缓存\n\nbut it allows this data block to be saved into the cache.\n虽然花的时间久一点，但数据可以存在缓存\n\nThis tends to be really useful because computer data is often arranged and processed sequentially.\n这很实用，因为数据常常是一个个按顺序处理\n\nFor example, let say the processor is totalling up daily sales for a restaurant.\n举个例子，算餐厅的当日收入\n\nIt starts by fetching the first transaction from RAM at memory location 100.\n先取 RAM 地址 100 的交易额\n\nThe RAM, instead of sending back just that one value, sends a block of data, from memory\nRAM 与其只给1个值，直接给一批值\n\nlocation 100 through 200, which are then all copied into the cache.\n把地址100到200都复制到缓存\n\nNow, when the processor requests the next transaction to add to its running total, the\n当处理器要下一个交易额时\n\nvalue at address 101, the cache will say “Oh, I’ve already got that value right here,\n地址 101，缓存会说：\"我已经有了，现在就给你\"\n\nso I can give it to you right away!”\n地址 101，缓存会说：\"我已经有了，现在就给你\"\n\nAnd there’s no need to go all the way to RAM.\n不用去 RAM 取数据\n\nBecause the cache is so close to the processor,\n因为缓存离 CPU 近, 一个时钟周期就能给数据 - CPU 不用空等！\n\nit can typically provide the data in a single clock cycle -- no waiting required.\n因为缓存离 CPU 近, 一个时钟周期就能给数据 - CPU 不用空等！\n\nThis speeds things up tremendously over having to go back and forth to RAM every single time.\n比反复去 RAM 拿数据快得多\n\nWhen data requested in RAM is already stored in the cache like this it’s called a\n如果想要的数据已经在缓存，叫 缓存命中\n\ncache hit,\n如果想要的数据已经在缓存，叫 缓存命中\n\nand if the data requested isn’t in the cache, so you have to go to RAM, it’s a called\n如果想要的数据不在缓存，叫 缓存未命中\n\na cache miss.\n如果想要的数据不在缓存，叫 缓存未命中\n\nThe cache can also be used like a scratch space,\n缓存也可以当临时空间，存一些中间值，适合长/复杂的运算\n\nstoring intermediate values when performing a longer, or more complicated calculation.\n缓存也可以当临时空间，存一些中间值，适合长/复杂的运算\n\nContinuing our restaurant example, let’s say the processor has finished totalling up\n继续餐馆的例子，假设 CPU 算完了一天的销售额\n\nall of the sales for the day, and wants to store the result in memory address 150.\n想把结果存到地址 150\n\nLike before, instead of going back all the way to RAM to save that value,\n就像之前，数据不是直接存到 RAM\n\nit can be stored in cached copy, which is faster to save to,\n而是存在缓存，这样不但存起来快一些\n\nand also faster to access later if more calculations are needed.\n如果还要接着算，取值也快一些\n\nBut this introduces an interesting problem -\n但这样带来了一个有趣的问题\n\n- the cache’s copy of the data is now different to the real version stored in RAM.\n缓存和 RAM 不一致了.\n\nThis mismatch has to be recorded, so that at some point everything can get synced up.\n这种不一致必须记录下来，之后要同步\n\nFor this purpose, the cache has a special flag for each block of memory it stores, called\n因此缓存里每块空间  有一个特殊标记\n\nthe dirty bit\n叫 \"脏位\"\n\n-- which might just be the best term computer scientists have ever invented.\n- 这可能是计算机科学家取的最贴切的名字\n\nMost often this synchronization happens when the cache is full,\n同步一般发生在 当缓存满了而 CPU 又要缓存时\n\nbut a new block of memory is being requested by the processor.\n同步一般发生在 当缓存满了而 CPU 又要缓存时\n\nBefore the cache erases the old block to free up space, it checks its dirty bit,\n在清理缓存腾出空间之前，会先检查 \"脏位\"\n\nand if it’s dirty, the old block of data is written back to RAM before loading in the new block.\n如果是\"脏\"的, 在加载新内容之前, 会把数据写回 RAM\n\nAnother trick to boost cpu performance is called instruction pipelining.\n另一种提升性能的方法叫 \"指令流水线\"\n\nImagine you have to wash an entire hotel’s worth of sheets,\n想象下你要洗一整个酒店的床单\n\nbut you’ve only got one washing machine and one dryer.\n但只有 1 个洗衣机, 1 个干燥机\n\nOne option is to do it all sequentially: put a batch of sheets in the washer\n选择1：按顺序来，放洗衣机等 30 分钟洗完\n\nand wait 30 minutes for it to finish.\n选择1：按顺序来，放洗衣机等 30 分钟洗完\n\nThen take the wet sheets out and put them in the dryer and wait another 30 minutes for that to finish.\n然后拿出湿床单，放进干燥机等 30 分钟烘干\n\nThis allows you to do one batch of sheets every hour.\n这样1小时洗一批\n\nSide note: if you have a dryer that can dry a load of laundry in 30 minutes,\n另外一说：如果你有 30 分钟就能烘干的干燥机\n\nPlease tell me the brand and model in the comments, because I’m living with 90 minute dry times, minimum.\n请留言告诉我是什么牌子，我的至少要 90 分钟.\n\nBut, even with this magic clothes dryer,\n即使有这样的神奇干燥机,  \\N 我们可以用\"并行处理\"进一步提高效率\n\nyou can speed things up even more if you parallelize your operation.\n即使有这样的神奇干燥机,  \\N 我们可以用\"并行处理\"进一步提高效率\n\nAs before, you start off putting one batch of sheets in the washer.\n就像之前，先放一批床单到洗衣机\n\nYou wait 30 minutes for it to finish.\n等 30 分钟洗完\n\nThen you take the wet sheets out and put them in the dryer.\n然后把湿床单放进干燥机\n\nBut this time, instead of just waiting 30 minutes for the dryer to finish,\n但这次，与其干等 30 分钟烘干，\\N 可以放另一批进洗衣机\n\nyou simultaneously start another load in the washing machine.\n但这次，与其干等 30 分钟烘干，\\N 可以放另一批进洗衣机\n\nNow you’ve got both machines going at once.\n让两台机器同时工作\n\nWait 30 minutes, and one batch is now done, one batch is half done,\n30 分钟后，一批床单完成, 另一批完成一半\n\nand another is ready to go in.\n另一批准备开始\n\nThis effectively doubles your throughput.\n效率x2！\n\nProcessor designs can apply the same idea.\n处理器也可以这样设计\n\nIn episode 7, our example processor performed the fetch-decode-execute cycle sequentially\n第7集，我们演示了 CPU 按序处理\n\nand in a continuous loop: Fetch-decode-execute, fetch-decode-execute, fetch-decode-execute, and so on\n取指 → 解码 → 执行, 不断重复\n\nThis meant our design required three clock cycles to execute one instruction.\n这种设计，三个时钟周期执行 1 条指令\n\nBut each of these stages uses a different part of the CPU,\n但因为每个阶段用的是 CPU 的不同部分\n\nmeaning there is an opportunity to parallelize!\n意味着可以并行处理！\n\nWhile one instruction is getting executed, the next instruction could be getting decoded,\n\"执行\"一个指令时，同时\"解码\"下一个指令\n\nand the instruction beyond that fetched from memory.\n\"读取\"下下个指令\n\nAll of these separate processes can overlap\n不同任务重叠进行，同时用上 CPU 里所有部分.\n\nso that all parts of the CPU are active at any given time.\n不同任务重叠进行，同时用上 CPU 里所有部分.\n\nIn this pipelined design, an instruction is executed every single clock cycle\n这样的流水线  每个时钟周期执行1个指令\n\nwhich triples the throughput.\n吞吐量 x 3\n\nBut just like with caching this can lead to some tricky problems.\n和缓存一样，这也会带来一些问题\n\nA big hazard is a dependency in the instructions.\n第一个问题是 指令之间的依赖关系\n\nFor example, you might fetch something that the currently executing instruction is just about to modify,\n举个例子，你在读某个数据 \\N 而正在执行的指令会改这个数据\n\nwhich means you’ll end up with the old value in the pipeline.\n也就是说拿的是旧数据\n\nTo compensate for this, pipelined processors have to look ahead for data dependencies,\n因此流水线处理器  要先弄清数据依赖性\n\nand if necessary, stall their pipelines to avoid problems.\n必要时停止流水线，避免出问题\n\nHigh end processors, like those found in laptops and smartphones,\n高端 CPU，比如笔记本和手机里那种\n\ngo one step further and can dynamically reorder instructions with dependencies\n会更进一步，动态排序 有依赖关系的指令\n\nin order to minimize stalls and keep the pipeline moving,\n最小化流水线的停工时间\n\nwhich is called out-of-order execution.\n这叫 \"乱序执行\"\n\nAs you might imagine, the circuits that figure this all out are incredibly complicated.\n和你猜的一样，这种电路非常复杂\n\nNonetheless, pipelining is tremendously effective and almost all processors implement it today.\n但因为非常高效，几乎所有现代处理器都有流水线\n\nAnother big hazard are conditional jump instructions -- we talked about one example, a JUMP NEGATIVE,last episode.\n第二个问题是 \"条件跳转\"，比如上集的 JUMP NEGATIVE\n\nThese instructions can change the execution flow of a program depending on a value.\n这些指令会改变程序的执行流\n\nA simple pipelined processor will perform a long stall when it sees a jump instruction,\n简单的流水线处理器，看到 JUMP 指令会停一会儿 \\N 等待条件值确定下来\n\nwaiting for the value to be finalized.\n简单的流水线处理器，看到 JUMP 指令会停一会儿 \\N 等待条件值确定下来\n\nOnly once the jump outcome is known, does the processor start refilling its pipeline.\n一旦 JUMP 的结果出了，处理器就继续流水线\n\nBut, this can produce long delays, so high-end processors have some tricks to deal with this problem too.\n因为空等会造成延迟，所以高端处理器会用一些技巧\n\nImagine an upcoming jump instruction as a fork in a road - a branch.\n可以把 JUMP 想成是 \"岔路口\"\n\nAdvanced CPUs guess which way they are going to go, and start filling their pipeline with\n高端 CPU 会猜哪条路的可能性大一些\n\ninstructions based off that guess – a technique called speculative execution.\n然后提前把指令放进流水线，这叫 \"推测执行\"\n\nWhen the jump instruction is finally resolved, if the CPU guessed correctly,\n当 JUMP 的结果出了，如果 CPU 猜对了\n\nthen the pipeline is already full of the correct instructions and it can motor along without delay.\n流水线已经塞满正确指令，可以马上运行\n\nHowever, if the CPU guessed wrong, it has to discard all its speculative results and\n如果 CPU 猜错了，就要清空流水线\n\nperform a pipeline flush - sort of like when you miss a turn and have to do a u-turn to\n就像走错路掉头\n\nget back on route, and stop your GPS’s insistent shouting.\n让 GPS 不要再！叫！了！\n\nTo minimize the effects of these flushes, CPU manufacturers have developed sophisticated\n为了尽可能减少清空流水线的次数，CPU 厂商开发了复杂的方法\n\nways to guess which way branches will go, called branch prediction.\n来猜测哪条分支更有可能，叫\"分支预测\"\n\nInstead of being a 50/50 guess, today’s processors can often guess with over 90% accuracy!\n现代 CPU 的正确率超过 90%\n\nIn an ideal case, pipelining lets you complete one instruction every single clock cycle,\n理想情况下，流水线一个时钟周期完成 1 个指令\n\nbut then superscalar processors came along\n然后\"超标量处理器\"出现了，一个时钟周期完成多个指令\n\nwhich can execute more than one instruction per clock cycle.\n然后\"超标量处理器\"出现了，一个时钟周期完成多个指令\n\nDuring the execute phase even in a pipelined design,\n即便有流水线设计，在指令执行阶段\n\nwhole areas of the processor might be totally idle.\n处理器里有些区域还是可能会空闲\n\nFor example, while executing an instruction that fetches a value from memory,\n比如，执行一个 \"从内存取值\" 指令期间\n\nthe ALU is just going to be sitting there, not doing a thing.\nALU 会闲置\n\nSo why not fetch-and-decode several instructions at once, and whenever possible, execute instructions\n所以一次性处理多条指令（取指令+解码） 会更好.\n\nthat require different parts of the CPU all at the same time\n如果多条指令要 ALU 的不同部分，就多条同时执行\n\nBut we can take this one step further and add duplicate circuitry\n我们可以再进一步，加多几个相同的电路 \\N 执行出现频次很高的指令\n\nfor popular instructions.\n我们可以再进一步，加多几个相同的电路 \\N 执行出现频次很高的指令\n\nFor example, many processors will have four, eight or more identical ALUs,\n举例，很多 CPU 有四个, 八个甚至更多 完全相同的ALU\n\nso they can execute many mathematical instructions all in parallel!\n可以同时执行多个数学运算\n\nOk, the techniques we’ve discussed so far primarily optimize the execution throughput\n好了，目前说过的方法，都是优化 1 个指令流的吞吐量\n\nof a single stream of instructions,\n好了，目前说过的方法，都是优化 1 个指令流的吞吐量\n\nbut another way to increase performance is to run several streams of instructions at once\n另一个提升性能的方法是 同时运行多个指令流\n\nwith multi-core processors.\n用多核处理器\n\nYou might have heard of dual core or quad core processors.\n你应该听过双核或四核处理器\n\nThis means there are multiple independent processing units inside of a single CPU chip.\n意思是一个 CPU 芯片里，有多个独立处理单元\n\nIn many ways, this is very much like having multiple separate CPUs,\n很像是有多个独立 CPU\n\nbut because they’re tightly integrated, they can share some resources,\n但因为它们整合紧密，可以共享一些资源\n\nlike cache, allowing the cores to work together on shared computations.\n比如缓存，使得多核可以合作运算\n\nBut, when more cores just isn’t enough, you can build computers with multiple independent CPUs!\n但多核不够时，可以用多个 CPU\n\nHigh end computers, like the servers streaming this video from YouTube’s datacenter, often\n高端计算机，比如现在给你传视频的 Youtube 服务器\n\nneed the extra horsepower to keep it silky smooth for the hundreds of people watching simultaneously.\n需要更多马力，让上百人能同时流畅观看\n\nTwo- and four-processor configuration are the most common right now,\n2个或4个CPU是最常见的\n\nbut every now and again even that much processing power isn’t enough.\n但有时人们有更高的性能要求\n\nSo we humans get extra ambitious and build ourselves a supercomputer!\n所以造了超级计算机！\n\nIf you’re looking to do some really monster calculations\n如果要做怪兽级运算\n\n– like simulating the formation of the universe - you’ll need some pretty serious compute power.\n比如模拟宇宙形成，你需要强大的计算能力\n\nA few extra processors in a desktop computer just isn’t going to cut it.\n给普通台式机加几个 CPU 没什么用\n\nYou’re going to need a lot of processors.\n你需要很多处理器！\n\nNo.. no... even more than that.\n不…不…还要更多\n\nA lot more!\n更多\n\nWhen this video was made, the world’s fastest computer was located in\n截止至视频发布，世上最快的计算机在\n\nThe National Supercomputing Center in Wuxi, China.\n中国无锡的国家超算中心\n\nThe Sunway TaihuLight contains a brain-melting 40,960 CPUs, each with 256 cores!\n神威·太湖之光有 40960 个CPU，每个 CPU 有 256 个核心\n\nThats over ten million cores in total... and each one of those cores runs at 1.45 gigahertz.\n总共超过1千万个核心，每个核心的频率是 1.45GHz\n\nIn total, this machine can process 93 Quadrillion -- that’s 93 million-billions\n每秒可以进行 9.3 亿亿次浮点数运算\n\nfloating point math operations per second, knows as FLOPS.\n也叫 每秒浮点运算次数 (FLOPS)\n\nAnd trust me, that’s a lot of FLOPS!!\n相信我  这个速度很可怕\n\nNo word on whether it can run Crysis at max settings, but I suspect it might.\n没人试过跑最高画质的《孤岛危机》但我估计没问题\n\nSo long story short, not only have computer processors gotten a lot faster over the years,\n长话短说，这些年处理器不但大大提高了速度\n\nbut also a lot more sophisticated, employing all sorts of clever tricks to squeeze out\n而且也变得更复杂，用各种技巧\n\nmore and more computation per clock cycle.\n榨干每个时钟周期 做尽可能多运算\n\nOur job is to wield that incredible processing power to do cool and useful things.\n我们的任务是利用这些运算能力，做又酷又实用的事\n\nThat’s the essence of programming, which we’ll start discussing next episode.\n编程就是为了这个，我们下集说\n\nSee you next week.\n下周见\n\nHi, I'm Carrie Anne and welcome to Crash Course Computer Science.\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nOver the last few episodes,\n前几集我们把重点放在计算机的原理\n\nWe've talked a lot about the mechanics of how computers work.\n前几集我们把重点放在计算机的原理\n\nHow they use complex circuits to save and retrieve values from memory,\n怎么从内存读写数据，执行操作\n\nand perform operations on those values\n怎么从内存读写数据，执行操作\n\nlike adding two numbers together.\n比如把两个数字加在一起\n\nWe've even briefly talked about sequences of operations,\n还简单讲了下指令的执行，也就是计算机程序\n\nwhich is a computer program\n还简单讲了下指令的执行，也就是计算机程序\n\nWhat we haven't talked about is how a program gets into a computer?\n但我们还没讲的是：程序如何\"进入\"计算机\n\nYou might remember in episode 7 and 8 ,\n你应该记得在第 7, 8 集，我们一步步讲了例子程序\n\nwe step through some simple example programs for the CPU that we had created\n你应该记得在第 7, 8 集，我们一步步讲了例子程序\n\nFor simplicity, we just waved our hands and said that the program was already magically in memory\n当时为了简单，我们假设程序已经魔法般在内存里了\n\nBut in reality, programs have to be loaded into a computer's memory.\n但事实是，程序需要加载进内存\n\nIt's not magic. It's computer science\n这不是魔法，是计算机科学！\n\nThe need to program machines existed way before the development of computers.\n给机器编程这个需求，早在计算机出现之前就有了\n\nThe most famous example of this was in textile manufacturing\n最著名的例子来自纺织业\n\nIf you just wanted to weave a big red tablecloth\n如果你只想织一块红色大桌布\n\nYou could simply feed red thread into a loom and let it run\n可以直接放红线进织布机\n\nWhat about if you wanted the cloth to have a pattern like stripes or plaid?\n但如果想要图案怎么办? 比如条纹或者方格\n\nWorkers would have to periodically reconfigure the loom as dictated by the pattern,\n工人要每隔一会儿 调整一次织布机\n\nbut this was labor intensive which made patterned fabrics expensive.\n因为非常消耗劳动力，所以图案纺织品很贵\n\nThe presence or absence of a hole in the card determined if a specific thread was held high or low in the loom\n特定位置有没有穿孔，决定了线是高是低\n\nSuch as the cross thread, called the weft,  passed above or below the thread\n横线是从上/从下穿过\n\nTo vary the pattern across rows these punch cards were arranged in long chains\n为了让每行图案不同，纸卡连成长条\n\nForming a sequence of commands for the loom.\n形成连续指令\n\nSound familiar?\n听起来很熟？\n\nMany consider Jacquard loom to be one of the earliest forms of programming.\n很多人认为雅卡尔织布机是最早的编程\n\nPunched cards, turned out to be a cheap, reliable, fairly human-readable way to store data.\n事实证明 穿孔纸卡便宜、可靠、也易懂\n\nNearly a century later,\n近一个世纪后\n\npunch cards were used to help tabulate the 1890 US census\n穿孔纸卡用于 1890 年美国人口普查\n\nwhich we talked about in episode 1\n我们在第一集提过\n\nEach card held an individual person's data.\n一张卡存一个人的信息\n\nthings like race\n比如种族\n\nmarital status\n婚姻状况\n\nnumber of children\n子女数量\n\ncountry of birth and so on\n出生国家 等等\n\nfor each demographic question\n针对每个问题，人口普查工作者会在对应位置打孔\n\na census worker would punch out a hole of the appropriate position\n针对每个问题，人口普查工作者会在对应位置打孔\n\nwhen a card was fed into the tabulating machine\n当卡片插入汇总机\n\na hole would cause the running total for that specific answer to be increased by one\n孔会让对应总和值+1\n\nin this way you could afeed the entire counties worth of people\n可以插入整个国家人口的卡片\n\nand at the end you'd have running totals for all of the questions that you ask\n在结束后得到各个总值\n\nIt is important to note here that early tabulating machines were not truly computers\n值得注意的是，早期汇总机不算计算机\n\nas they can only do one thing-tabulate\n因为它们只做一件事 - 汇总数据\n\ntheir operation was fixed and not programmable\n操作是固定的，不能编程\n\npunched cards stored data, but not a program\n穿孔纸卡存的是数据，不是程序.\n\nover the next 60 years, these business machines grew in capability\n之后60年，这些机器被加强，可以做减、乘、除\n\nAdding features to subtract multiply divide\n之后60年，这些机器被加强，可以做减、乘、除\n\nand even make simple decisions about when to perform certain operations.\n甚至可以做一些小决定，决定何时执行某指令\n\nTo trigger these functions appropriately\n为了正确执行不同计算，程序员需要某种控制面板\n\nso that different calculations could be performed, a programmer accessed a control panel\n为了正确执行不同计算，程序员需要某种控制面板\n\nthis panel was full of little sockets into which a programmer would plug cables\n面板有很多小插孔，程序员可以插电线\n\nto pass values and signals between different parts of the machine\n让机器的不同部分  互相传数据和信号\n\nfor this reason they were also called plug boards\n因此也叫 \"插线板\"\n\nUnfortunately this meant having to rewire the machine each time a different program needed to be run\n不幸的是, 这意味着 运行不同程序要重新接线\n\nAnd so by the 1920s these plug boards were made swappable\n所以到 1920 年代，控制面板变成了可拔插\n\nThis not only made programming a lot more comfortable\n让编程更方便\n\nbut also allowed for different programs be plugged into a machine\n可以给机器插入不同程序\n\nFor example one board might be wired to calculate sales tax\n比如，一个插线板算销售税，另一个算工资单\n\nWhile another helps with payroll\n比如，一个插线板算销售税，另一个算工资单\n\nBut plug boards were fiendishly complicated to program\n但给插线板编程很复杂\n\nThis tangle of wires is a program for calculating a profit loss summary using an IBM 402 accounting machine\n图中乱成一团的线  负责算盈亏总额 \\N 用于 IBM 402 核算机\n\nwhich were popular in the 1940s\n在 1940 年代这样做很流行\n\nAnd this style of plug board programming wasn't unique through electromechanical computers\n用插线板编程  不只在机电计算机流行\n\nThe world's first general-purpose electronic computer, the ENIAC, completed in 1946\n世上第一台通用电子计算机，ENIAC，完成于 1946 年\n\nused a ton of them\n用了一大堆插线板\n\nEven after a program had been completely figured out on paper\n程序在纸上设计好之后\n\nPhysically wiring up the ENIAC and getting the program to run could take upwards of three weeks\n给 ENIAC 连线，最多可能花三个星期\n\nGiven the enormous cost of these early computers, weeks of downtime simply to switch programs was unacceptable\n因为早期计算机非常昂贵 \\N 停机几个星期只为换程序  完全无法接受\n\nand the new faster more flexible way to program machines was badly needed\n人们急需更快、更灵活的新方式来编程\n\nFortunately by the late 1940s and into the 50s\n幸运的是，到 1940 年代晚期 1950 年代初\n\nelectronic memory was becoming feasible\n内存变得可行\n\nAs costs fell, memory size grew, instead of storing a program as a physical plug board of wires\n价格下降, 容量上升.  与其把程序存在插线板\n\nit became possible to store a program entirely in a computer's memory\n存在内存变得可行\n\nwhere it could be easily changed by programmers and quickly accessed by the CPU\n这样程序易于修改、方便 CPU 快速读取\n\nthese machines were called Stored-program Computers\n这类机器叫 \"存储程序计算机\"\n\nWith enough computer memory you could store not only the program you wanted to run\n如果内存足够，不仅可以存要运行的程序\n\nbut also any data your program would need\n还可以存程序需要的数据\n\nincluding new values it created along the way\n包括程序运行时产生的新数据\n\nUnifying the program and data into a single shared memory is called the Von Neumann Architecture\n程序和数据都存在一个地方，叫 \"冯诺依曼结构\"\n\nnamed after John Von Neumann\n命名自 约翰·冯·诺依曼\n\na prominent mathematician and physicist who worked on the Manhattan project and several early electronic computers\n杰出的数学家和物理学家 \\N 参与了曼哈顿计划和早期电子计算机项目\n\nand once said I am thinking about something much more important than Bombs\n他曾说：我在思考比炸弹重要得多的东西\n\nI'm thinking about computers\n计算机\n\nThe hallmarks of a Von Neumann computer are a processing unit containing an arithmetic logic unit\n冯诺依曼计算机的标志是，一个处理器(有算术逻辑单元)+\n\ndata registers and instruction register and instruction address register\n数据寄存器+指令寄存器+指令地址寄存器\n\nAnd finally a memory to store both data and instructions\n+内存（负责存数据和指令)\n\nHopefully this sounds familiar\n希望这听起来很耳熟\n\nBecause we actually built a Von Neumann computer in episode 7\n因为第7集我们造了一个冯诺依曼计算机\n\nThe very first Von Neumann Architecture Stored-program computer\n第一台冯诺依曼架构的\"储存程序计算机\"\n\nwas constructed in 1948 by the University of Manchester, nicknamed Baby.\n由曼彻斯特大学于 1948 年建造完成，绰号\"宝宝\"\n\nand even the computer you are watching this video right now\n甚至你现在看视频的计算机，也在用一样的架构\n\nuses the same architecture\n甚至你现在看视频的计算机，也在用一样的架构\n\nNow electronic computer memory is great and all\n虽然有内存很棒\n\nbut you still have to load the program and data into the computer before it can run\n但程序和数据  依然需要某种方式输入计算机\n\nand for this reason punch cards were used\n所以用穿孔纸卡\n\nLet's get to the Thought bubbles\n让我们进入  思维泡泡\n\nWell into the 1980s almost all computers have a punch card reader\n到1980年代，几乎所有的计算机都有穿孔纸卡读取器\n\nwhich could suck in a single punch card at a time\n可以吸入一张卡片，把卡片内容写进内存\n\nand write the contents of the card into the computer's memory\n可以吸入一张卡片，把卡片内容写进内存\n\nIf you load it in a stack of punch cards,\n如果放了一叠卡片，读取器会一个个写进内存\n\nthe reader would load them all into memory sequentially as a big block\n如果放了一叠卡片，读取器会一个个写进内存\n\nonce the program and data were in memory, the computer would be told to execute it\n一旦程序和数据写入完毕，电脑会开始执行\n\nOf course even simple computer programs might have hundreds of instructions\n即便简单程序也有几百条指令，要用一叠纸卡来存\n\nwhich meant that programs were stored as stacks of punch cards\n即便简单程序也有几百条指令，要用一叠纸卡来存\n\nSo if you ever have the misfortune of accidentally dropping your program on the floor\n如果不小心摔倒弄撒了\n\nit could take you hours days or even weeks to put the code back in the right order\n要花上几小时、几天、甚至几周来整理\n\nA common trick was to draw a diagonal line on the side of the card stack called striping,\n有个小技巧是  在卡片侧面画对角线\n\nso you'd have at least some clue how to get it back into the right order\n如果弄散了，整理起来会方便很多\n\nThe largest program ever punched into punch cards was the US Air Force's SAGE air defense system, completed in 1955.\n用纸卡的最大型程序 \\N 是美国空军的 SAGE 防空系统，于 1955 年完成\n\nand its peak, the project is said to have employed 20% of the world's programmers\n据称顶峰时期 雇佣了世上 20% 程序员\n\nIts main control program was stored on a whopping 62,500 punch cards\n主控制程序用了 62500 张穿孔纸卡\n\nwhich is equivalent to roughly 5 megabytes of data\n等同于大约 5MB 的数据\n\nPretty underwhelming by today's standards\n以如今的标准，不值一提\n\nAnd punch cards weren't only useful for getting data into computers\n穿孔纸卡不仅可以往计算机放数据\n\nbut also getting data out of them\n还可以取出数据\n\nAt the end of a program results could be written out of computer memory and onto punch cards by, well, punching cards\n程序运行到最后，结果可以输到纸卡上，方式嘛，当然是打孔\n\nthen this data could be analyzed by humans or loaded into a second program for additional computation\n然后人可以分析结果，或者再次放进计算机，做进一步计算\n\nThanks, thought-bubble\n谢了 思维泡泡\n\nA close cousin to punch cards was punched paper tape\n穿孔纸卡 的亲戚是纸带\n\nWhich is basically the same idea, but continuous instead of being on individual cards\n基本是一回事，只不过更连续，不是一张张卡.\n\nAnd of course we haven't talked about Hard Drives, CD-ROMs, DVDs, USB-Thumb drives and other similar goodies\n当然我们还没提硬盘, 只读光盘, DVD, U盘等等\n\nWe'll get to those more advanced types of data storage in a future episode\n以后我们会讲这些更先进的存储方法\n\nFinally in addition to plug boards and punch paper\n最后，除了插线板和穿孔纸卡\n\nthere was another common way to program and control computers in pre-1980\n在 1980 年代前，还有一种常见编程方式\n\nPanel programming\n面板编程\n\nRather than having to physically plug in cables to activate certain functions\n与其插一堆线到插线板\n\nthis could also be done with huge panels full of switches and buttons\n可以用一大堆开关和按钮，做到一样的效果\n\nAnd there were indicator lights to display the status of various functions and values in memory\n面板上有指示灯，代表各种函数的状态和内存中的值\n\nComputers of the 50s and 60s often featured huge control consoles that look like this\n50和60年代的计算机，一般都有这样巨大的控制台\n\nAlthough it was rare to input a whole program using just switches,it was possible\n很少有人只用开关来输入一整个程序，但技术上是可行的\n\nAnd early home computers made for the hobbyist market use switches extensively\n早期针对计算机爱好者的家用计算机，大量使用了开关\n\nbecause most home users couldn't afford expensive peripherals like punch card readers\n因为大多数家庭用户负担不起昂贵的外围设备 \\N 比如穿孔纸卡读取器\n\nThe first commercially successful home computer was the Altair 8800\n第一款取得商业成功的家用计算机是 Altair 8800\n\nwhich sold in two versions: Pre-assembled and the Kit\n有两种版本可以买: \\N 1. 预先装好的整机  \\N 2. 需要组装的组件\n\nthe Kit which was popular with amateur computing enthusiasts,\n计算机爱好者 喜欢买组件版\n\nsold for the then unprecedented low price are around $400 in 1975\n售价极低，在 1975 年卖 400 美元左右\n\nOr about $2,000 in 2017\n相当于 2017 年的 2000 美元\n\nTo program the 8800, you'd literally toggle the switches on the front panel\n为了给 8800 编程，你要拨动面板上的开关\n\nto enter the binary op-codes for the instruction you wanted\n输入二进制操作码\n\nThen you press the deposit button to write that value into memory\n然后按 \"存储键\" 把值存入内存\n\nThen in the next location in memory you toggle the switches again\n然后会到下一个内存位置 \\N 你可以再次拨开关，写下一个指令\n\nfor your next instruction deposit it and so on\n重复这样做\n\nWhen you finally entered your whole program into memory\n把整个程序都写入内存之后\n\nyou would toggle the switches moves back to memory address 0\n可以推动开关，回到内存地址0\n\npress the run button and watch the little lights blink\n然后按运行按钮，灯会闪烁\n\nThat was home computing in 1975, Wow.\n这就是 1975 年的家用计算机, 哇.\n\nWhether it was plug board, switches or punched paper\n不管是插线板、开关或穿孔纸卡\n\nProgramming these early computers was the realm of experts\n早期编程都是专家活\n\neither professionals who did this for living or technology enthusiasts\n不管是全职还是技术控，都要非常了解底层硬件\n\nyou needed intimate knowledge of the underlying hardware,\n不管是全职还是技术控，都要非常了解底层硬件\n\nso things like processor op-codes and register wits, to write programs\n比如 操作码, 寄存器等, 才能写程序\n\nThis meant programming was hard and tedious and even professional engineers\n所以编程很难，很烦\n\nand scientists struggled to take full advantage of what computing could offer\n哪怕工程师和科学家都无法 完全发挥计算机的能力\n\nWhat was needed was a simpler way to tell computers what to do,\n我们需要一种更简单方式  告诉计算机要做什么\n\na simpler way to write programs\n一种更简单的编程方式\n\nAnd that brings us to programming languages, which we'll talk about next episode\n这带领我们到下一个话题 - 编程语言, 我们下集会讲\n\nSee you next week\n下周见\n\nThis episode is brought to you by CuriosityStream.\n本集由 CuriosityStream 赞助播出\n\nHi, I'm Carrie Anne and welcome to Crash Course Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nSo far, for most of this series, we've focused on hardware\n之前我们把重点放在硬件 - 组成计算机的物理组件\n\n-- the physical components of computing --\n之前我们把重点放在硬件 - 组成计算机的物理组件\n\nthings like: electricity and circuits, registers and RAM, ALUs and CPUs.\n比如电，电路，寄存器，RAM，ALU，CPU\n\nBut programming at the hardware level is cumbersome and inflexible,\n但在硬件层面编程非常麻烦\n\nso programmers wanted a more versatile way to program computers\n所以程序员想要一种更通用的方法编程\n\n- what you might call a \"softer\" medium.\n- 一种\"更软的\"媒介\n\nThat's right, we're going to talk about Software!\n没错，我们要讲软件！\n\nIn episode 8, we walked through a simple program for the CPU we designed.\n第 8 集我们一步步讲了一个简单程序\n\nThe very first instruction to be executed, the one at memory address 0, was 0010 1110.\n第一条指令在内存地址 0：0010 1110\n\nAs we discussed, the first four bits of an instruction is the operation code,\n之前说过，前 4 位是操作码\n\nor OPCODE for short.\n简称 OPCODE\n\nOn our hypothetical CPU, 0010 indicated a LOAD_A instruction\n对于这个假设 CPU，0010 代表 LOAD_A 指令\n\n-- which moves a value from memory into Register A.\n- 把值从内存复制到寄存器 A\n\nThe second set of four bits defines the memory location,\n后 4 位是内存地址，1110 是十进制的 14\n\nin this case, 1110, which is 14 in decimal.\n后 4 位是内存地址，1110 是十进制的 14\n\nSo what these eight numbers really mean is \"LOAD Address 14 into Register A\".\n所以这 8 位表达的意思是 \\N  \"读内存地址 14，放入寄存器 A\"\n\nWe're just using two different languages.\n只是用了两种不同语言\n\nYou can think of it like English and Morse Code.\n可以想成是英语和摩尔斯码的区别\n\n\"Hello\" and \".... . .-.. .-.. ---\" mean the same thing -- hello! --\n\"你好\" 和 \".... . .-.. .-.. ---\" 是一个意思：你好\n\nthey're just encoded differently.\n只是编码方式不同\n\nEnglish and Morse Code also have different levels of complexity.\n英语和摩尔斯码的复杂度也不同\n\nEnglish has 26 different letters in its alphabet and way more possible sounds.\n英文有 26 个字母以及各种发音\n\nMorse only has dots and dashes.\n摩尔斯码只有\"点\"和\"线\"\n\nBut, they can convey the same information, and computer languages are similar.\n但它们可以传达相同的信息，计算机语言也类似.\n\nAs we've seen, computer hardware can only handle raw, binary instructions.\n计算机能处理二进制，二进制是处理器的\"母语\"\n\nThis is the \"language\" computer processors natively speak.\n计算机能处理二进制，二进制是处理器的\"母语\"\n\nIn fact, it's the only language they're able to speak.\n事实上，它们*只能*理解二进制\n\nIt's called Machine Language or Machine Code.\n这叫\"机器语言\"或\"机器码\"\n\nIn the early days of computing, people had to write entire programs in machine code.\n在计算机早期阶段，必须用机器码写程序\n\nMore specifically, they'd first write a high-level version of a program on paper, in English,\n具体来讲，会先在纸上用英语写一个\"高层次版\"\n\nFor example \"retrieve the next sale from memory,\n举例：\"从内存取下一个销售额，\n\nthen add this to the running total for the day, week and year,\n然后加到天、周、年的总和\n\nthen calculate any tax to be added\"\n然后算税\"\n\n...and so on.\n等等...\n\nAn informal, high-level description of a program like this is called Pseudo-Code.\n这种对程序的高层次描述，叫 \"伪代码\"\n\nThen, when the program was all figured out on paper,\n在纸上写好后\n\nthey'd painstakingly expand and translate it into binary machine code by hand,\n用\"操作码表\"把伪代码转成二进制机器码\n\nusing things like opcode tables.\n用\"操作码表\"把伪代码转成二进制机器码\n\nAfter the translation was complete, the program could be fed into the computer and run.\n翻译完成后，程序可以喂入计算机并运行\n\nAs you might imagine, people quickly got fed up with this process.\n你可能猜到了，很快人们就厌烦了\n\nSo, by the late 1940s and into the 50s,\n所以在 1940~1950 年代\n\nprogrammers had developed slightly higher-level languages that were more human-readable.\n程序员开发出一种新语言， 更可读 更高层次\n\nOpcodes were given simple names, called mnemonics,\n每个操作码分配一个简单名字，叫\"助记符\"\n\nwhich were followed by operands, to form instructions.\n\"助记符\"后面紧跟数据，形成完整指令\n\nSo instead of having to write instructions as a bunch of 1's and 0's,\n与其用 1 和 0 写代码，程序员可以写\"LOAD_A 14\"\n\nprogrammers could write something like \"LOAD_A 14\".\n与其用 1 和 0 写代码，程序员可以写\"LOAD_A 14\"\n\nWe used this mnemonic in Episode 8 because it's so much easier to understand!\n我们在第 8 集用过这个助记符，因为容易理解得多！\n\nOf course, a CPU has no idea what \"LOAD_A 14\" is.\n当然，CPU 不知道 LOAD_A 14 是什么\n\nIt doesn't understand text-based language, only binary.\n它不能理解文字，只能理解二进制\n\nAnd so programmers came up with a clever trick.\n所以程序员想了一个技巧，写二进制程序来帮忙\n\nThey created reusable helper programs, in binary,\n所以程序员想了一个技巧，写二进制程序来帮忙\n\nthat read in text-based instructions,\n它可以读懂文字指令，自动转成二进制指令\n\nand assemble them into the corresponding binary instructions automatically.\n它可以读懂文字指令，自动转成二进制指令\n\nThis program is called\n这种程序叫\n\n-- you guessed it --\n你可能猜到了\n\nan Assembler.\n汇编器\n\nIt reads in a program written in an Assembly Language\n汇编器读取用\"汇编语言\"写的程序，然后转成\"机器码\"\n\nand converts it to native machine code.\n汇编器读取用\"汇编语言\"写的程序，然后转成\"机器码\"\n\n\"LOAD_A 14\" is one example of an assembly instruction.\n\"LOAD_A 14\" 是一个汇编指令的例子\n\nOver time, Assemblers gained new features that made programming even easier.\n随着时间推移，汇编器有越来越多功能，让编程更容易\n\nOne nifty feature is automatically figuring out JUMP addresses.\n其中一个功能是自动分析 JUMP 地址\n\nThis was an example program I used in episode 8:\n这里有一个第8集用过的例子：\n\nNotice how our JUMP NEGATIVE instruction jumps to address 5,\n注意, JUMP NEGATIVE 指令跳到地址 5\n\nand our regular JUMP goes to address 2.\nJUMP 指令跳到地址 2\n\nThe problem is, if we add more code to the beginning of this program,\n问题是，如果在程序开头多加一些代码\n\nall of the addresses would change.\n所有地址都会变\n\nThat's a huge pain if you ever want to update your program!\n更新程序会很痛苦！\n\nAnd so an assembler does away with raw jump addresses,\n所以汇编器不用固定跳转地址\n\nand lets you insert little labels that can be jumped to.\n而是让你插入可跳转的标签\n\nWhen this program is passed into the assembler,\n当程序被传入汇编器，汇编器会自己搞定跳转地址\n\nit does the work of figuring out all of the jump addresses.\n当程序被传入汇编器，汇编器会自己搞定跳转地址\n\nNow the programmer can focus more on programming\n程序员可以专心编程，不用管底层细节\n\nand less on the underlying mechanics under the hood\n程序员可以专心编程，不用管底层细节\n\nenabling more sophisticated things to be built by hiding unnecessary complexity.\n隐藏不必要细节来做更复杂的工作\n\nAs we've done many times in this series,\n我们又提升了一层抽象\n\nwe're once again moving up another level of abstraction.\n我们又提升了一层抽象\n\nHowever, even with nifty assembler features like auto-linking JUMPs to labels,\n然而，即使汇编器有这些厉害功能，比如自动跳转\n\nAssembly Languages are still a thin veneer over machine code.\n汇编只是修饰了一下机器码\n\nIn general, each assembly language instruction converts directly\n一般来说，一条汇编指令对应一条机器指令\n\nto a corresponding machine instruction - a one-to-one mapping -\n一般来说，一条汇编指令对应一条机器指令\n\nso it's inherently tied to the underlying hardware.\n所以汇编码和底层硬件的连接很紧密\n\nAnd the assembler still forces programmers to think about\n汇编器仍然强迫程序员思考  用什么寄存器和内存地址\n\nwhich registers and memory locations they will use.\n汇编器仍然强迫程序员思考  用什么寄存器和内存地址\n\nIf you suddenly needed an extra value,\n如果你突然要一个额外的数，可能要改很多代码\n\nyou might have to change a lot of code to fit it in.\n如果你突然要一个额外的数，可能要改很多代码\n\nLet's go to the Thought Bubble.\n让我们进入思考泡泡\n\nThis problem did not escape Dr. Grace Hopper.\n葛丽丝·霍普博士 也遇到了这个问题\n\nAs a US naval officer, she was one of the first programmers on the Harvard Mark 1 computer,\n作为美国海军军官，她是哈佛1号计算机的首批程序员之一\n\nwhich we talked about in Episode 2.\n这台机器我们在第 2 集提过\n\nThis was a colossal, electro-mechanical beast\n这台巨大机电野兽在 1944 年战时建造完成，帮助盟军作战\n\ncompleted in 1944 as part of the allied war effort.\n这台巨大机电野兽在 1944 年战时建造完成，帮助盟军作战\n\nPrograms were stored and fed into the computer on punched paper tape.\n程序写在打孔纸带上，放进计算机执行\n\nBy the way, as you can see,\n顺便一说，如果程序里有漏洞\n\nthey \"patched\" some bugs in this program\n顺便一说，如果程序里有漏洞\n\nby literally putting patches of paper over the holes on the punch tape.\n真的就 直接用胶带来补\"漏洞\"\n\nThe Mark 1's instruction set was so primitive,\nMark 1 的指令集非常原始，甚至没有 JUMP 指令\n\nthere weren't even JUMP instructions.\nMark 1 的指令集非常原始，甚至没有 JUMP 指令\n\nTo create code that repeated the same operation multiple times,\n如果代码要跑不止一次\n\nyou'd tape the two ends of the punched tape together, creating a physical loop.\n得把带子的两端连起来  做成循环\n\nIn other words, programming the Mark 1 was kind of a nightmare!\n换句话说，给 Mark 1 编程简直是噩梦！\n\nAfter the war, Hopper continued to work at the forefront of computing.\n战后，霍普继续在计算机前沿工作\n\nTo unleash the potential of computers,\n为了释放电脑的潜力\n\nshe designed a high-level programming language called \"Arithmetic Language Version 0\",\n她设计了一个高级编程语言，叫\"算术语言版本 0\"\n\nor A-0 for short.\n简称\"A-0\"\n\nAssembly languages have direct, one-to-one mapping to machine instructions.\n汇编与机器指令是一一对应的\n\nBut, a single line of a high-level programming language\n但一行高级编程语言  可能会转成几十条二进制指令\n\nmight result in dozens of instructions being executed by the CPU.\n但一行高级编程语言  可能会转成几十条二进制指令\n\nTo perform this complex translation, Hopper built the first compiler in 1952.\n为了做到这种复杂转换 \\N Hopper 在 1952 年创造了第一个编译器\n\nThis is a specialized program\n编译器专门把高级语言 转成低级语言\n\nthat transforms \"source\" code written in a programming language into a low-level language,\n编译器专门把高级语言 转成低级语言\n\nlike assembly or the binary \"machine code\" that the CPU can directly process.\n比如汇编或机器码（CPU 可以直接执行机器码）\n\nThanks, Thought Bubble.\n谢了 思想泡泡\n\nSo, despite the promise of easier programming,\n尽管\"使编程更简单\"很诱人\n\nmany people were skeptical of Hopper's idea.\n但很多人对霍普的点子持怀疑态度\n\nShe once said, \"I had a running compiler and nobody would touch it.\n她曾说\"我有能用的编译器，但没人愿意用\n\nthey carefully told me, computers could only do arithmetic;\n他们告诉我计算机只能做算术,不能运行程序\"\n\nthey could not do programs.\"\n他们告诉我计算机只能做算术,不能运行程序\"\n\nBut the idea was a good one,\n但这个点子是好的\n\nand soon many efforts were underway to craft new programming languages\n不久，很多人尝试创造新编程语言\n\n-- today there are hundreds!\n- 如今有上百种语言！\n\nSadly, there are no surviving examples of A-0 code,\n可惜的是，没有任何 A-0 的代码遗留下来\n\nso we'll use Python, a modern programming language, as an example.\n所以我们用 Python 举例（一门现代编程语言）\n\nLet's say we want to add two numbers and save that value.\n假设我们想相加两个数字，保存结果\n\nRemember, in assembly code,\n记住，如果用汇编代码\n\nwe had to fetch values from memory, deal with registers, and other low-level details.\n我们得从内存取值，和寄存器打交道，以及其他底层细节\n\nBut this same program can be written in python like so:\n但同样的程序可以用 Python 这样写：\n\nNotice how there are no registers or memory locations to deal with\n不用管寄存器或内存位置\n\n-- the compiler takes care of that stuff, abstracting away a lot of low-level and unnecessary complexity.\n- 编译器会搞定这些细节，不用管底层细节\n\nThe programmer just creates abstractions for needed memory locations, known as variables,\n程序员只需要创建 代表内存地址的抽象，叫\"变量\"\n\nand gives them names.\n给变量取名字\n\nSo now we can just take our two numbers, store them in variables we give names to\n现在可以把两个数 存在变量里\n\n-- in this case, I picked a and b but those variables could be anything -\n这里取名 A 和 B, 实际编程时你可以随便取名\n\nand then add those together, saving the result in c, another variable I created.\n然后相加两个数，把结果存在变量 C\n\nIt might be that the compiler assigns Register A under the hood to store the value in a,\n底层操作时，编译器可能把变量 A 存在寄存器 A\n\nbut I don't need to know about it!\n但我不需要知道这些！\n\nOut of sight, out of mind!\n眼不见心不烦\n\nIt was an important historical milestone,\n这是个重要历史里程碑\n\nbut A-0 and its later variants weren't widely used.\n但 A-0 和之后的版本没有广泛使用\n\nFORTRAN, derived from \"Formula Translation\",\nFORTRAN，名字来自 \"公式翻译\"\n\nwas released by IBM a few years later, in 1957,\n这门语言数年后由 IBM 在 1957 年发布\n\nand came to dominate early computer programming.\n主宰了早期计算机编程\n\nJohn Backus, the FORTRAN project director,\nFORTRAN 项目总监 John Backus 说过\n\nsaid: \"Much of my work has come from being lazy.\n\"我做的大部分工作都是因为懒\n\nI didn't like writing programs,\n我不喜欢写程序\n\nand so ... I started work on a programming system to make it easier to write programs.\"\n所以我写这门语言，让编程更容易\"\n\nYou know, typical lazy person.\n你懂的，典型的\"懒人\"\n\nThey're always creating their own programming systems.\n（白眼）创造自己的编程语言\n\nAnyway, on average, programs written in FORTRAN\n平均来说，FORTRAN 写的程序\n\nwere 20 times shorter than equivalent handwritten assembly code.\n比等同的手写汇编代码短 20 倍\n\nThen the FORTRAN Compiler would translate and expand that into native machine code.\n然后 FORTRAN 编译器会把代码转成机器码\n\nThe community was skeptical that the performance would be as good as hand written code,\n人们怀疑性能是否比得上手写代码\n\nbut the fact that programmers could write more code more quickly,\n但因为能让程序员写程序更快，所以成了一个更经济的选择\n\nmade it an easy choice economically:\n但因为能让程序员写程序更快，所以成了一个更经济的选择\n\ntrading a small increase in computation time for a significant decrease in programmer time.\n运行速度慢一点点，编程速度大大加快\n\nOf course, IBM was in the business of selling computers,\n当时 IBM 在卖计算机\n\nand so initially, FORTRAN code could only be compiled and run on IBM computers.\n因此最初 FORTRAN 代码只能跑在 IBM 计算机上\n\nAnd most programing languages and compilers of the 1950s\n1950 年代大多数编程语言和编译器\n\ncould only run on a single type of computer.\n只能运行在一种计算机上\n\nSo, if you upgraded your computer,\n如果升级电脑\n\nyou'd often have to re-write all the code too!\n可能要重写所有代码！\n\nIn response, computer experts from industry,\n因此工业界，学术界，政府的计算机专家 \\N 在 1959 年组建了一个联盟\n\nacademia and government formed a consortium in 1959\n因此工业界，学术界，政府的计算机专家 \\N 在 1959 年组建了一个联盟\n\n-- the Committee on Data Systems Languages, advised by our friend Grace Hopper --\n- 数据系统语言委员会，Grace Hopper 担任顾问\n\nto guide the development of a common programming language\n开发一种通用编程语言，可以在不同机器上通用\n\nthat could be used across different machines.\n开发一种通用编程语言，可以在不同机器上通用\n\nThe result was the high-level, easy to use,\n最后诞生了一门高级，易于使用，\n\nCommon Business-Oriented Language, or COBOL for short.\n\"普通面向商业语言\"，简称 COBOL\n\nTo deal with different underlying hardware,\n为了兼容不同底层硬件\n\neach computing architecture needed its own COBOL compiler.\n每个计算架构需要一个 COBOL 编译器\n\nBut critically, these compilers could all accept the same COBOL source code,\n最重​​要的是，这些编译器都可以接收相同 COBOL 代码\n\nno matter what computer it was run on.\n不管是什么电脑\n\nThis notion is called write once, run anywhere.\n这叫\"一次编写，到处运行\"\n\nIt's true of most programming languages today,\n如今大多数编程语言都是这样\n\na benefit of moving away from assembly and machine code,\n不必接触 CPU 特有的汇编码和机器码\n\nwhich is still CPU specific.\n不必接触 CPU 特有的汇编码和机器码\n\nThe biggest impact of all this was reducing computing's barrier to entry.\n减小了使用门槛\n\nBefore high level programming languages existed,\n在高级编程语言出现之前\n\nit was a realm exclusive to computer experts and enthusiasts.\n编程只是计算机专家和爱好者才会做的事\n\nAnd it was often their full time profession.\n而且通常是主职\n\nBut now, scientists, engineers, doctors, economists, teachers,\n但现在，科学家，工程师，医生，经济学家，教师\n\nand many others could incorporate computation into their work .\n等等，都可以把计算机用于工作\n\nThanks to these languages,\n感谢这些语言\n\ncomputing went from a cumbersome and esoteric discipline\n计算机科学从深奥学科 变成了大众化工具\n\nto a general purpose and accessible tool.\n计算机科学从深奥学科 变成了大众化工具\n\nAt the same time, abstraction in programming allowed those computer experts\n同时，编程的抽象也让计算机专家\n\n- now \"professional programmers\" -\n现在叫\"专业程序员\"\n\nto create increasingly sophisticated programs,\n制作更复杂的程序\n\nwhich would have taken millions, tens of millions, or even more lines of assembly code.\n如果用汇编写可能要上百万行\n\nNow, this history didn't end in 1959.\n当然，计算机的历史没有在 1959 年结束\n\nIn fact, a golden era in programming language design jump started,\n编程语言设计的黄金时代才刚刚开始\n\nevolving in lockstep with dramatic advances in computer hardware.\n和硬件一起飞速发展\n\nIn the 1960s, we had languages like ALGOL, LISP and BASIC.\n在 1960 年代，有 ALGOL, LISP 和 BASIC 等语言\n\nIn the 70's: Pascal, C and Smalltalk were released.\n70年代有：Pascal，C 和 Smalltalk\n\nThe 80s gave us C++, Objective-C, and Perl.\n80年代有：C++，Objective-C 和 Perl\n\nAnd the 90's: python, ruby, and Java.\n90年代有：Python，Ruby 和 Java\n\nAnd the new millennium has seen the rise of Swift, C#, and Go\n新千年 Swift, C#, Go 在崛起\n\n- not to be confused with Let it Go and Pokemon Go.\n不要把 Go 和\\N 《冰雪奇缘》的 Let it Go 和游戏 Pokemon Go 弄混\n\nAnyway, some of these might sound familiar\n有些语言你可能听起来耳熟 - 很多现在还存在\n\n-- many are still around today.\n有些语言你可能听起来耳熟 - 很多现在还存在\n\nIt's extremely likely that the web browser you're using right now\n你现在用的浏览器很可能是 C++ 或 Objective-C 写的\n\nwas written in C++ or Objective-C.\n你现在用的浏览器很可能是 C++ 或 Objective-C 写的\n\nThat list I just gave is the tip of the iceberg.\n我刚才说的编程语言名字 只是冰山一角\n\nAnd languages with fancy, new features are proposed all the time.\n新的编程语言在不断诞生\n\nEach new language attempts to leverage new and clever abstractions\n新语言想用更聪明的抽象\n\nto make some aspect of programming easier or more powerful,\n让某些方面更容易或更强大\n\nor take advantage of emerging technologies and platforms,\n或利用新技术和新平台带来的优势\n\nso that more people can do more amazing things, more quickly.\n让更多人能快速做出美妙的事情\n\nMany consider the holy grail of programming to be the use of \"plain ol' English\",\n许多人认为编程的\"圣杯\"是直接用英文\n\nwhere you can literally just speak what you want the computer to do,\n直接对计算机说话，然后它会理解并执行\n\nit figures it out, and executes it.\n直接对计算机说话，然后它会理解并执行\n\nThis kind of intelligent system is science fiction for now.\n这种智能系统目前只存在于科幻小说\n\nAnd fans of 2001: A Space Odyssey may be okay with that.\n\"2001：太空漫游\" 的粉丝可能没什么意见\n\nNow that you know all about programming languages,\n现在你理解了编程语言,\n\nwe're going to deep dive for the next couple of episodes,\n接下来几集 我们会深入了解\n\nand we'll continue to build your understanding\n接下来几集 我们会深入了解\n\nof how programming languages, and the software they create,\n编程语言和用语言写的软件\n\nare used to do cool and unbelievable things.\n是怎么做到那些酷事\n\nSee you next week.\n下周见\n\n（给 Curiosity Stream 打广告）\n\nHi, I’m Carrie Anne, and welcome to CrashCourse Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nLast episode we discussed how writing programs in native machine code,\n上集讲到用机器码写程序,\n\nand having to contend with so many low level details, was a huge impediment to writing complex programs.\n还要处理那么多底层细节  对写大型程序是个巨大障碍\n\nTo abstract away many of these low-level details, Programming Languages were developed that\n为了脱离底层细节，开发了编程语言\n\nlet programmers concentrate on solving a problem with computation, and less on nitty gritty hardware details.\n让程序员专心解决问题，不用管硬件细节\n\nSo today, we’re going to continue that discussion, and introduce some fundamental building blocks\n今天我们讨论  大多数编程语言都有的基本元素\n\nthat almost all programming languages provide.\n今天我们讨论  大多数编程语言都有的基本元素\n\nJust like spoken languages, programming languages have statements.\n就像口语一样，编程语言有\"语句\"\n\nThese are individual complete thoughts, like \"I want tea\" or \"it is raining\".\n语句表达单个完整思想，比如\"我想要茶\"或者\"在下雨\"\n\nBy using different words, we can change the meaning;\n用不同词汇可以代表不同含义 \\N 比如\"我想要茶\"变成\"我想要独角兽\"\n\nfor example, \"I want tea\" to \"I want unicorns\".\n用不同词汇可以代表不同含义 \\N 比如\"我想要茶\"变成\"我想要独角兽\"\n\nBut we can’t change \"I want tea\" to \"I want raining\" - that doesn’t make grammatical sense.\n但没法把\"我想要茶\"改成\"我想要雨\"- 语法毫无意义\n\nThe set of rules that govern the structure and composition of statements in a language\n规定句子结构的一系列规则 叫语法\n\nis called syntax.\n规定句子结构的一系列规则 叫语法\n\nThe English language has syntax, and so do all programming languages.\n英语有语法，所有编程语言也都有语法\n\n\"a = 5\" is a programming language statement.\na=5 是一个编程语言语句\n\nIn this case, the statement says a variable named A has the number 5 stored in it.\n意思是创建一个叫 a 的变量，把数字 5 放里面.\n\nThis is called an assignment statement because we're assigning a value to a variable.\n这叫\"赋值语句\"，把一个值赋给一个变量\n\nTo express more complex things, we need a series of statements,\n为了表达更复杂的含义，需要更多语句\n\nlike \"A is 5, B is 10, C equals A plus B\"\n比如 \\Na=5 \\N b=10 \\Nc=a+b\n\nThis program tells the computer to set variable ‘A’ equal to 5, variable ‘B’ to 10,\n意思是，变量 a 设为5，变量 b 设为10\n\nand finally to add ‘A’ and ‘B’ together, and put that result, which is 15, into -- you guessed it -- variable C.\n把 a 和 b 加起来，把结果 15 放进变量 c\n\nNote that we can call variables whatever we want.\n注意，变量名可以随意取\n\nInstead of A, B and C, it could be apples, pears, and fruits.\n除了 a b c，也可以叫苹果、梨、水果\n\nThe computer doesn’t care, as long as variables are uniquely named.\n计算机不在乎你取什么名，只要不重名就行\n\nBut it’s probably best practice to name them things that make sense\n当然取名最好还是有点意义，方便别人读懂\n\nin case someone else is trying to understand your code.\n当然取名最好还是有点意义，方便别人读懂\n\nA program, which is a list of instructions, is a bit like a recipe:\n程序由一个个指令组成，有点像菜谱：\n\nboil water, add noodles, wait 10 minutes, drain and enjoy.\n烧水、加面，等10分钟，捞出来就可以吃了\n\nIn the same way, the program starts at the first statement\n程序也是这样，从第一条语句开始\n\nand runs down one at a time until it hits the end.\n一句一句运行到结尾\n\nSo far, we’ve added two numbers together.\n刚才我们只是把两个数字加在一起\n\nBoring.\n无聊\n\nLet’s make a video game instead!\n我们来做一款游戏吧\n\nOf course, it’s way too early to think about coding an entire game,\n当然，现在这个学习阶段 \\N来编写一整个游戏还太早了\n\nso instead, we’ll use our example to write little snippets of code\n所以我们只写一小段一小段的代码\n\nthat cover some programming fundamentals.\n来讲解一些基础知识\n\nImagine we’re building an old-school arcade game where Grace Hopper has to capture bugs\n假设我们在写一款老派街机游戏：Grace Hopper 拍虫子\n\nbefore they get into the Harvard Mark 1 and crash the computer!\n阻止虫子飞进计算机造成故障\n\nOn every level, the number of bugs increases.\n关卡越高，虫子越多\n\nGrace has to catch them before they wear out any relays in the machine.\nGrace 要在虫子损坏继电器之前  抓住虫子\n\nFortunately, she has a few extra relays for repairs.\n好消息是  她有几个备用继电器\n\nTo get started, we’ll need to keep track of a bunch of values that are important for gameplay\n开始编写时，我们需要一些值 来保存游戏数据\n\nlike what level the player is on, the score, the number of bugs remaining,\n比如当前关卡数、分数、剩余虫子数、\n\nas well as the number of spare relays in Grace’s inventory.\nGrace 还剩几个备用继电器\n\nSo, we must \"initialize\" our variables, that is, set their initial value:\n所以我们要\"初始化\"变量 \\N \"初始化\"的意思是设置最开始的值.\n\n\"level equals 1, score equals 0, bugs equals 5, spare relays equals 4, and player name equals \"Andre\".\n关卡=1  分数=0  虫子数=5 \\N 备用继电器=4   玩家名=Andre\n\nTo create an interactive game, we need to control the flow of the program\n为了做成交互式游戏，程序的执行顺序要更灵活\n\nbeyond just running from top to bottom.\n不只是从上到下执行\n\nTo do this, we use Control Flow Statements.\n因此用 \"控制流语句\"\n\nThere are several types, but If Statements are the most common.\n控制流语句有好几种，最常见的是 if 语句\n\nYou can think of them as \"If X is true, then do Y\".\n可以想成是 \"如果 X 为真，那么执行 Y\"\n\nAn English language example is: \"If I am tired, then get tea\"\n用英语举例就是 \"如果累了, 就去喝茶\"\n\nSo if \"I am tired\" is a true statement, then I will go get tea\n如果 \"累了\" 为真，就去喝茶\n\nIf \"I am tired\" is false, then I will not go get tea.\n如果 \"累了\" 为假，就不喝茶\n\nAn IF statement is like a fork in the road.\nif 语句就像岔路口\n\nWhich path you take is conditional on whether the expression is true or false\n走哪条路  取决于 \"表达式\" 的真假，\n\nso these expressions are called Conditional Statements.\n因此这些表达式又叫 \"条件语句\"\n\nIn most programming languages, an if statement looks something like\n在大多数编程语言中，if 语句看起来像这样：\n\n\"If, expression, then, some code, then end the if statement\".\nif [条件], then [一些代码]，结束 if 语句.\n\nFor example, if \"level\" is 1, then we set the score to zero, because the player is just starting.\n比如，if [第一关]，then [分数设为0] \\N 因为玩家才刚开始游戏\n\nWe also set the number of bugs to 1, to keep it easy for now.\n同时把虫子数设为 1，让游戏简单些\n\nNotice the lines of code that are conditional on the if-statement are nested between the\n注意, 依赖于 if 条件的代码，要放在 IF 和 END IF 之间\n\nIF and END IF.\n注意, 依赖于 if 条件的代码，要放在 IF 和 END IF 之间\n\nOf course, we can change the conditional expression to whatever we want to test, like\n当然，条件表达式 可以改成别的，比如：\n\n\"is score greater than 10\"  or \"is bugs less than 1\".\n\"分数 >10\" 或者 \"虫子数 <1\"\n\nAnd If-Statements can be combined with an ELSE statement, which acts as a catch-all if the expression is false.\nif 还可以和 else 结合使用 \\N 条件为假会执行 else 里的代码\n\nIf the level is not 1, the code inside the ELSE block will be executed instead, and the\n如果不是第1关，else 里的指令就会被执行\n\nnumber of bugs that Grace has to battle is set to 3 times the level number.\nGrace 要抓的虫子数，是当前关卡数 * 3\n\nSo on level 2, it would be six bugs, and on level 3 there’s 9, and so on.\n所以第 2 关有 6 个虫子，第 3 关有 9 个虫子，以此类推\n\nScore isn’t modified in the ELSE block, so Grace gets to keep any points earned.\nelse 中没有改分数，所以 Grace 的分数不会变\n\nHere are some examples of if-then-else statements from some popular programming languages\n这里列了一些热门编程语言  if-then-else 的具体语法\n\n-- you can see the syntax varies a little, but the underlying structure is roughly the same.\n具体语法略有不同，但主体结构一样\n\nIf-statements are executed once, a conditional path is chosen, and the program moves on.\nif 语句 根据条件执行一次\n\nTo repeat some statements many times, we need to create a conditional loop.\n如果希望根据条件执行多次，需要\"条件循环\"\n\nOne way is a while statement, also called a while loop.\n比如 while 语句，也叫 \"while 循环\"\n\nAs you might have guessed, this loops a piece of code \"while\" a condition is true.\n当 while 条件为真，代码会重复执行\n\nRegardless of the programming language, they look something like this:\n不管是哪种编程语言，结构都是这样\n\nIn our game, let’s say at certain points, a friendly colleague restocks Grace with relays!\n假设到达一定分数会冒出一个同事，给 Grace 补充继电器\n\nHooray!\n棒极了！\n\nTo animate him replenishing our stock back up to a maximum of 4, we can use a while loop.\n把继电器补满到最大数 4 个 \\N 我们可以用 while 语句来做\n\nLet’s walk through this code.\n来过一遍代码\n\nFirst we’ll assume that Grace only has 1 tube left when her colleague enters.\n假设同事入场时， Grace 只剩一个继电器\n\nWhen we enter the while loop, the first thing the computer does is test its conditional…\n当执行 while 循环，第一件事是检查条件\n\nis relays less than 4?\n继电器数量<4?\n\nWell, relays is currently 1, so yes.\n继电器数量现在是1，所以是真\n\nNow we enter the loop!\n进入循环！\n\nThen, we hit the line of code: \"relays equals relays plus 1\".\n碰到这一行：继电器数量=继电器数量+1\n\nThis is a bit confusing because the variable is using itself in an assignment statement,\n看起来有点怪，变量的赋值用到了自己\n\nso let's unpack it.\n我们讲下这个\n\nYou always start by figuring out the right side of the equals sign first,\n总是从等号右边开始，\n\nso what does \"relays plus 1\" come out to be?\n\"继电器数量+1\" 是多少？\n\nWell, relays is currently the value 1, so 1 plus 1 equals 2.\n当前值是1，所以 1+1=2\n\nThen, this result gets saved back into the variable relays, writing over the old value,\n结果存到\"继电器数量\"，覆盖旧的值\n\nso now relays stores the value 2.\n所以现在继电器数量是 2\n\nWe’ve hit the end of the while loop, which jumps the program back up.\n现在到了结尾，跳回开始点\n\nJust as before, we test the conditional to see if we’re going to enter the loop.\n和之前一样，先判断条件，看要不要进入循环\n\nIs relays less than 4?\n继电器数量<4？\n\nWell, yes, relays now equals 2, so we enter the loop again!\n是，继电器数量是2，所以再次进入循环!\n\n2 plus 1 equals 3.\n2+1=3\n\nso 3 is saved into relays.\n3 存入\"继电器数量\"\n\nLoop again.\n回到开头\n\nIs 3 less than 4?\n3<4？\n\nYes it is!\n是!\n\nInto the loop again.\n进入循环\n\n3 plus 1 equals 4.\n3+1=4\n\nSo we save 4 into relays.\n4 存入\"继电器数量\"\n\nLoop again.\n回到开头\n\nIs 4 less than 4?....\n4<4?\n\nNo!\n不！\n\nSo the condition is now false, and thus we exit the loop and move on to any remaining code\n现在条件为假，退出循环，执行后面的代码\n\nThat’s how a while loop works!\nwhile 循环就是这样运作的!\n\nThere’s also the common For Loop.\n另一种常见的叫 \"for 循环\"\n\nInstead of being a condition-controlled loop that can repeat forever until the condition is false\n不判断条件，判断次数，会循环特定次数\n\na FOR loop is count-controlled; it repeats a specific number of times.\n不判断条件，判断次数，会循环特定次数\n\nThey look something like this:\n看起来像上图\n\nNow, let’s put in some real values.\n现在放些真正的值进去\n\nThis example loops 10 times, because we’ve specified that variable ‘i’\n上图例子会循环10次，因为设了变量 i\n\nstarts at the value 1 and goes up to 10.\n从 1 开始，一直到 10\n\nThe unique thing about a FOR loop is that each time it hits NEXT, it adds one to ‘i’.\nfor 的特点是，每次结束， i 会 +1\n\nWhen ‘i’ equals 10, the computer knows it’s been looped 10 times, and the loop exits\n当 i 等于10，就知道循环了10次，然后退出.\n\nWe can set the number to whatever we want -- 10, 42, or a billion -- it’s up to us.\n我们可以用任何数字，10, 42, 10 亿\n\nLet’s say we want to give the player a bonus at the end of each level\n假设每关结束后  给玩家一些奖励分\n\nfor the number of vacuum relays they have left over.\n奖励分多少取决于 继电器剩余数量\n\nAs the game gets harder, it takes more skill to have unused relays,\n随着难度增加，剩下继电器会越来越难\n\nso we want the bonus to go up exponentially based on the level.\n因此奖励分会根据当前关卡数，指数级增长\n\nWe need to write a piece of code that calculates exponents -\n我们要写一小段代码来算指数\n\nthat is, multiplying a number by itself a specific number of times.\n指数是一个数乘自己，乘特定次数\n\nA loop is perfect for this!\n用循环来实现简直完美!\n\nFirst lets initialize a new variable called \"bonus\" and set it to 1.\n首先，创建一个叫\"奖励分\"的新变量，设为 1 （看上图）\n\nThen, we create a FOR loop starting at 1, and looping up to the level number.\n然后 for 循环，从 1 到 [当前关卡数]\n\nInside that loop, we multiply bonus times the number of relays,\n[奖励分] x [继电器剩余数]，结果存入 [奖励分]\n\nand save that new value back into bonus.\n[奖励分] x [继电器剩余数]，结果存入 [奖励分]\n\nFor example, let’s say relays equals 2, and level equals 3.\n比如继电器数是2，关卡数是3\n\nSo the FOR loop will loop three times, which means bonus is going to get multiplied by\nfor 会循环3次，奖励分会乘\n\nrelays... by relays... by relays.\n继电器数量 x 继电器数量 x 继电器数量\n\nOr in this case, times 2, times 2, times 2, which is a bonus of 8!\n也就是1×2×2×2，奖励分是8，2的3次方\n\nThat’s 2 to the 3rd power!\n也就是1×2×2×2，奖励分是8，2的3次方\n\nThis exponent code is useful, and we might want to use it in other parts of our code.\n这个指数代码很实用，其他地方可能会用到\n\nIt’d be annoying to copy and paste this everywhere, and have to update the variable names each time.\n如果每次想用就复制粘贴，会很麻烦，每次都要改变量名\n\nAlso, if we found a bug, we’d have to hunt around and update every place we used it.\n如果代码发现问题，要补漏洞时 \\N 要把每一个复制黏贴过的地方都找出来改\n\nIt also makes code more confusing to look at.\n而且会让代码更难懂\n\nLess is more!\n少即是多！\n\nWhat we want is a way to package up our exponent code so we can use it, get the result, and\n我们想要某种方法，把代码\"打包\" \\N 可以直接使用，得出结果，\n\nnot have to see all the internal complexity.\n不用管内部复杂度.\n\nWe’re once again moving up a new level of abstraction!\n这又提升了一层抽象！\n\nTo compartmentalize and hide complexity,\n为了隐藏复杂度\n\nprogramming languages can package pieces of code into named functions,\n可以把代码打包成 \"函数\"\n\nalso called methods or subroutines in different programming languages.\n也叫 \"方法\" 或 \"子程序\"\\N（有些编程语言这么叫）\n\nThese functions can then be used by any other part of that program just by calling its name.\n其他地方想用这个函数，直接写函数名就可以了\n\nLet’s turn our exponent code into a function! First, we should name it.\n现在我们把指数代码变成函数.  第一步，取名.\n\nWe can call it anything we want, like HappyUnicorn,\n叫什么都行，比如\"快乐独角兽\"\n\nbut since our code calculates exponents, let’s call it exponent.\n但因为是算指数,  直接叫\"指数\"合适一些\n\nAlso, instead of using specific variable names, like \"relays\" and \"levels\",\n还有，与其用特定变量名，比如 \"继电器\" 和 \"关卡数\"\n\nwe specify generic variable names, like Base and Exp,\n用更通用的名字，比如 底数(Base) 和 指数(Exp)\n\nwhose initial values are going to be \"passed\" into our function from some other part of the program.\nBase 和 Exp 的初始值需要外部传入\n\nThe rest of our code is the same as before\n剩余代码和之前一样\n\nNow tucked into our function and with new variable names.\n现在完成了，有函数名和新变量名.\n\nFinally, we need to send the result of our exponent code back to the part of the program that requested it.\n最后, 我们还需要把结果 交给使用这个函数的代码\n\nFor this, we use a RETURN statement, and specify that the value in ‘result’ be returned.\n所以用 RETURN 语句，指明返回什么.\n\nSo our full function code looks like this:\n完整版代码是这样\n\nNow we can use this function anywhere in our program,\n现在可以随意用这个函数\n\nsimply by calling its name and passing in two numbers.\n只需要写出名字 然后传入2个数字  就可以了\n\nFor example, if we want to calculate 2 to the 44th power, we can just call \"exponent 2 comma 44.\"\n如果要算 2 的 44 次方，写 exponent(2,44)\n\nand like 18 trillion comes back.\n结果是 18 万亿左右\n\nBehind the scenes, 2 and 44 get saved into variables Base and Exp inside the function,\n幕后原理是，2 和 44 存进 Base 和 Exp\n\nit does all its loops as necessary, and then the function returns with the result.\n跑循环，然后返回结果\n\nLet’s use our newly minted function to calculate a score bonus.\n我们来用这个新函数 算奖励分\n\nFirst, we initialize bonus to 0.\n首先，奖励分初始化为 0\n\nThen we check if the player has any remaining relays with an if-statement.\n然后用 if 语句，看剩不剩继电器（看上图的 > 0）\n\nIf they do, we call our exponent function, passing in relays and level,\n如果还剩，用指数函数，传入 [继电器数] 和 [关卡数]\n\nwhich calculates relays to the power of level, and returns the result, which we save into bonus.\n它会算 [继电器数]的[关卡数]次方,  存入奖励分\n\nThis bonus calculating code might be useful later, so let’s wrap it up as a function too!\n这段算奖励分的代码，之后可能还会用，也打包成一个函数\n\nYes, a function that calls a function!\n没错，这个函数 (CalcBonus) \\N 会调用另一个函数 (Exponent)\n\nAnd then, wait for it…. we can use this function in an even more complex function.\n还有！这个 CalcBonus 函数，可以用在其他更复杂的函数\n\nLet’s write one that gets called everytime the player finishes a level.\n我们来写一个函数, 每一关结束后都会调用\n\nWe’ll call it \"LevelFinished\"\n叫 LevelFinished (关卡结束)\n\n- it needs to know the number of relays left, what level it was, and the current score;\n需要传入 [剩余继电器数]  [关卡数] [当前分]\n\nthose values have to get passed in.\n这些数据必须传入.\n\nInside our function, we’ll calculate the bonus, using our CalcBonus function,\n里面用 CalcBonus 算奖励分，并加进总分\n\nand add that to the running score.\n里面用 CalcBonus 算奖励分，并加进总分\n\nAlso, if the current score is higher than the game’s high score,\n还有，如果当前分 > 游戏最高分\n\nwe save the new high score and the players name.\n把新高分和玩家名 存起来\n\nNow we’re getting pretty fancy.\n现在代码变得蛮\"花哨\"了\n\nFunctions are calling functions are calling functions!\n函数调函数调函数\n\nWhen we call a single line of code, like this the complexity is hidden.\n我们写这样一行代码时，复杂度都隐藏起来了\n\nWe don’t see all the internal loops and variables,\n不需要知道内部的循环和变量\n\nwe just see the result come back as if by magic…. a total score of 53.\n只知道结果会像魔术一样返回，总分 53\n\nBut it’s not magic, it’s the power of abstraction!\n但是这不是魔术，是抽象的力量\n\nIf you understand this example, then you understand the power of functions,\n如果你理解了这个例子，就明白了函数的强大之处\n\nand the entire essence of modern programming.\n和现代编程的核心\n\nIt’s not feasible to write, for example, a web browser as one gigantically long list of statements.\n比如浏览器这样的复杂程序，用一长串语句来写是不可能的\n\nIt would be millions of lines long and impossible to comprehend!\n会有几百万行代码，没人能理解\n\nSo instead, software consists of thousands of smaller functions,\n所以现代软件由上千个函数组成\n\neach responsible for different features.\n每个负责不同的事\n\nIn modern programming, it’s uncommon to see functions longer than around 100 lines of code\n如今超过100行代码的函数很少见\n\nbecause by then, there’s probably something that\n如果多于 100 行，应该有东西可以拆出来做成一个函数\n\nshould be pulled out and made into its own function.\n如果多于 100 行，应该有东西可以拆出来做成一个函数\n\nModularizing programs into functions not only allows a single programmer to write an entire app\n模块化编程  不仅可以让单个程序员独立制作 App\n\nbut also allows teams of people to work efficiently on even bigger programs.\n也让团队协作可以写更大型的程序\n\nDifferent programmers can work on different functions,\n不同程序员写不同函数\n\nand if everyone makes sure their code works correctly,\n只需要确保自己的代码工作正常\n\nthen when everything is put together, the whole program should work too!\n把所有人的拼起来，整个程序也应该能正常运作！\n\nAnd in the real world, programmers aren’t wasting time writing things like exponents.\n现实中，程序员不会浪费时间写指数函数这种东西\n\nModern programming languages come with huge bundles of pre-written functions, called Libraries.\n现代编程语言 有很多预先写好的函数集合，叫 \"库\"\n\nThese are written by expert coders, made efficient and rigorously tested, and then given to everyone.\n由专业人员编写，不仅效率高，而且经过了仔细检查\n\nThere are libraries for almost everything, including networking, graphics, and sound\n几乎做所有事情都有库，网络、图像、声音\n\n-- topics we’ll discuss in future episodes.\n我们之后会讲这些主题.\n\nBut before we get to those, we need to talk about Algorithms.\n但在此之前，我们先讲算法\n\nIntrigued?\n好奇吗？\n\nYou should be.\n你应该才是！\n\nI’ll see you next week.\n下周见\n\nHi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nOver the past two episodes, we got our first taste of programming in a high-level language,\n前两集，我们\"初尝\"了高级编程语言\\N （比如 Python 和 Java）\n\nlike Python or Java.\n前两集，我们\"初尝\"了高级编程语言\\N （比如 Python 和 Java）\n\nWe talked about different types of programming language statements\n我们讨论了几种语句 - 赋值语句，if 语句，循环语句\n\n- like assignments, ifs, and loops -\n我们讨论了几种语句 - 赋值语句，if 语句，循环语句\n\nas well as putting statements into functions that perform a computation,\n以及把代码打包成 \"函数\"\n\nlike calculating an exponent.\n比如算指数\n\nImportantly, the function we wrote to calculate exponents is only one possible solution.\n重要的是，之前写的指数函数 \\N 只是无数解决方案的一种\n\nThere are other ways to write this function\n还有其它方案\n\n- using different statements in different orders -\n- 用不同顺序写不同语句 也能得到一样结果\n\nthat achieve exactly the same numerical result.\n- 用不同顺序写不同语句 也能得到一样结果\n\nThe difference between them is the algorithm,\n不同的是 \"算法\"，意思是：解决问题的具体步骤\n\nthat is the specific steps used to complete the computation.\n不同的是 \"算法\"，意思是：解决问题的具体步骤\n\nSome algorithms are better than others even if they produce equal results.\n即使结果一致，有些算法会更好\n\nGenerally, the fewer steps it takes to compute, the better it is,\n一般来说，所需步骤越少越好\n\nthough sometimes we care about other factors, like how much memory it uses.\n不过有时我们也会关心其他因素，比如占多少内存\n\nThe term algorithm comes from Persian polymath Muhammad ibn Musa al-Khwarizmi\n\"算法\" 一词来自 波斯博识者 阿尔·花拉子密\n\nwho was one of the fathers of algebra more than a millennium ago.\n1000 多年前的代数之父之一\n\nThe crafting of efficient algorithms\n如何想出高效算法 - 是早在计算机出现前就有的问题\n\n- a problem that existed long before modern computers -\n如何想出高效算法 - 是早在计算机出现前就有的问题\n\nled to a whole science surrounding computation,\n诞生了专门研究计算的领域，然后发展成一门现代学科\n\nwhich evolved into the modern discipline of...\n诞生了专门研究计算的领域，然后发展成一门现代学科\n\nyou guessed it!\n你猜对了！\n\nComputer Science!\n计算机科学！\n\nOne of the most storied algorithmic problems in all of computer science is sorting\n记载最多的算法之一是\"排序\"\n\nas in sorting names or sorting numbers.\n比如给名字、数字排序\n\nComputers sort all the time.\n排序到处都是\n\nLooking for the cheapest airfare,\n找最便宜的机票\n\narranging your email by most recently sent,\n按最新时间排邮件\n\nor scrolling your contacts by last name\n按姓氏排联系人\n\n-- those all require sorting.\n-这些都要排序\n\nYou might think\n你可能想\"排序看起来不怎么难… 能有几种算法呢?\"\n\n\"sorting isn't so tough how many algorithms can there possibly be?\"\n你可能想\"排序看起来不怎么难… 能有几种算法呢?\"\n\nThe answer is: a lot.\n答案是超多\n\nComputer Scientists have spent decades inventing algorithms for sorting,\n计算机科学家花了数十年发明各种排序算法\n\nwith cool names like Bubble Sort and Spaghetti Sort.\n还起了酷酷的名字，\"冒泡排序\"\"意面排序\"\n\nLet's try sorting!\n我们来试试排序！\n\nImagine we have a set of airfare prices to Indianapolis.\n试想有一堆机票价格，都飞往  印第安纳波利斯 (美国地名)\n\nWe'll talk about how data like this is represented in memory next week,\n数据具体怎么在内存中表示  下周再说\n\nbut for now, a series of items like this is called an array.\n上图的这样一组数据  叫\"数组\"（Array）\n\nLet's take a look at these numbers to help see how we might sort this programmatically.\n来看看怎么排序\n\nWe'll start with a simple algorithm.\n先从一种简单算法开始\n\nFirst, let's scan down the array to find the smallest number.\n先找到最小数，从最上面的 307 开始\n\nStarting at the top with 307.\n先找到最小数，从最上面的 307 开始\n\nIt's the only number we've seen, so it's also the smallest.\n因为现在只看了这一个，所以它是最小数\n\nThe next is 239, that's smaller than 307,\n下一个是 239，比 307 小\n\nso it becomes our new smallest number.\n所以新的最小数变成 239\n\nNext is 214, our new smallest number.\n下一个是 214 ，新的最小数\n\n250 is not, neither is 384, 299, 223 or 312.\n250 不是，384, 299, 223, 312 都不是\n\nSo we've finished scanning all numbers,\n现在扫完了所有数字\n\nand 214 is the smallest.\n214 是最小的\n\nTo put this into ascending order,\n为了升序排列（从小到大排序）\n\nwe swap 214 with the number in the top location.\n把 214 和最上面的数字，交换位置\n\nGreat! We sorted one number!\n好棒! 刚排序了一个数字！\n\nNow we repeat the same procedure,\n现在重复同样的过程\n\nbut instead of starting at the top, we can start one spot below.\n这次不从最上面开始，从第 2 个数开始\n\nFirst we see 239, which we save as our new smallest number.\n先看到 239，我们当作是 \"最小数\"\n\nScanning the rest of the array, we find 223 is the next smallest,\n扫描剩下的部分，发现 223 最小\n\nso we swap this with the number in the second spot.\n所以把它和第 2 位交换\n\nNow we repeat again, starting from the third number down.\n重复这个过程，从第 3 位数字开始\n\nThis time, we swap 239 with 307.\n让 239 和 307 互换位置\n\nThis process continues until we get to the very last number,\n重复直到最后一个数字\n\nand voila, the array is sorted and you're ready to book that flight to Indianapolis!\n瞧，数字排好了，可以买机票了！\n\nThe process we just walked through is one way\n刚刚这种方法，或者说算法，\n\n- or one algorithm - for sorting an array.\n刚刚这种方法，或者说算法，\n\nIt's called Selection sort - and it's pretty basic.\n叫 选择排序 - 非常基础的一种算法\n\nHere's the pseudo-code.\n以下是\"伪代码\"\n\nThis function can be used to sort 8, 80, or 80 million numbers\n这个函数可以排序8个, 80个或8千万个数字\n\n- and once you've written the function, you can use it over and over again.\n函数写好了就可以重复使用\n\nWith this sort algorithm, we loop through each position in the array, from top to bottom,\n这里用循环 遍历数组\n\nand then for each of those positions,\n每个数组位置都跑一遍循环，找最小数然后互换位置\n\nwe have to loop through the array to find the smallest number to swap.\n每个数组位置都跑一遍循环，找最小数然后互换位置\n\nYou can see this in the code, where one FOR loop is nested inside of another FOR loop.\n可以在代码中看到这一点 \\N （一个 for 循环套另一个 for 循环）\n\nThis means, very roughly, that if we want to sort N items, we have to loop N times,\n这意味着，大致来说，如果要排 N 个东西，要循环 N 次，\n\ninside of which, we loop N times, for a grand total of roughly N times N loops, or N squared.\n每次循环中再循环 N 次，共 N*N,  或 N\n\nThis relationship of input size to the number of steps the algorithm takes to run\n算法的 输入大小 和 运行步骤 之间的关系\n\ncharacterizes the complexity of the Selection Sort algorithm.\n叫算法的 复杂度\n\nIt gives you an approximation of how fast, or slow, an algorithm is going to be.\n表示运行速度的量级\n\nComputer Scientists write this order of growth in something known as - no joke -\n计算机科学家们把算法复杂度叫 - 没开玩笑\n\n\"big O notation\".\n大 O 表示法\n\nN squared is not particularly efficient.\n算法复杂度 O(N  ) 效率不高\n\nOur example array had n = 8 items, and 8 squared is 64.\n前面的例子有 8 个元素（n=8）, 8  = 64\n\nIf we increase the size of our array from 8 items to 80,\n如果 8 个变 80 个\n\nthe running time is now 80 squared, which is 6,400.\n运行时间变成 80  = 6400\n\nSo although our array only grew by 10 times - from 8 to 80 -\n虽然大小只增长了 10 倍（8 到 80）\n\nthe running time increased by 100 times - from 64 to 6,400!\n但运行时间增加了 100 倍！（64 到 6400 ）\n\nThis effect magnifies as the array gets larger.\n随着数组增大，对效率的影响会越来越大\n\nThat's a big problem for a company like Google,\n这对大公司来说是个问题，比如 谷歌\n\nwhich has to sort arrays with millions or billions of entries.\n要对几十亿条信息排序\n\nSo, you might ask,\n作为未来的计算机科学家你可能会问：有没有更高效的排序算法？\n\nas a burgeoning computer scientist, is there a more efficient sorting algorithm?\n作为未来的计算机科学家你可能会问：有没有更高效的排序算法？\n\nLet's go back to our old, unsorted array\n回到未排序的数组\n\nand try a different algorithm, merge sort.\n试另一个算法 \"归并排序\"\n\nThe first thing merge sort does is check if the size of the array is greater than 1.\n第一件事是检查数组大小是否 > 1\n\nIf it is, it splits the array into two halves.\n如果是，就把数组分成两半\n\nSince our array is size 8, it gets split into two arrays of size 4.\n因为数组大小是 8，所以分成两个数组，大小是 4\n\nThese are still bigger than size 1, so they get split again, into arrays of size 2,\n但依然大于 1，所以再分成大小是 2 的数组\n\nand finally they split into 8 arrays with 1 item in each.\n最后变成 8 个数组，每个大小为 1\n\nNow we are ready to merge, which is how \"merge sort\" gets its name.\n现在可以\"归并\"了，\"归并排序\"因此得名\n\nStarting with the first two arrays, we read the first - and only - value in them,\n从前两个数组开始，读第一个（也是唯一一个）值\n\nin this case, 307 and 239.\n307 和 239\n\n239 is smaller, so we take that value first.\n239 更小，所以放前面\n\nThe only number left is 307, so we put that value second.\n剩下的唯一数字是 307 ，所以放第二位\n\nWe've successfully merged two arrays.\n成功合并了两个数组\n\nWe now repeat this process for the remaining pairs, putting them each in sorted order.\n重复这个过程，按序排列\n\nThen the merge process repeats.\n然后再归并一次\n\nAgain, we take the first two arrays, and we compare the first numbers in them.\n同样，取前两个数组，比较第一个数\n\nThis time its 239 and 214.\n239 和 214\n\n214 is lowest, so we take that number first.\n214 更小，放前面\n\nNow we look again at the first two numbers in both arrays: 239 and 250.\n再看两个数组里的第一个数：239 和 250\n\n239 is lower, so we take that number next.\n239 更小，所以放下一位\n\nNow we look at the next two numbers: 307 and 250.\n看剩下两个数：307 和 250\n\n250 is lower, so we take that.\n250 更小，所以放下一位\n\nFinally, we're left with just 307, so that gets added last.\n最后剩下 307 ，所以放最后\n\nIn every case, we start with two arrays,\n每次都以 2 个数组开始\n\neach individually sorted, and merge them into a larger sorted array.\n然后合并成更大的有序数组\n\nWe repeat the exact same merging process for the two remaining arrays of size two.\n我们把刚隐藏起来的，下面的数组也这样做\n\nNow we have two sorted arrays of size 4.\n现在有两个大小是 4 的有序数组\n\nJust as before, we merge,\n就像之前，比较两个数组的第一个数，取最小数\n\ncomparing the first two numbers in each array, and taking the lowest.\n就像之前，比较两个数组的第一个数，取最小数\n\nWe repeat this until all the numbers are merged,\n重复这个过程，直到完成\n\nand then our array is fully sorted again!\n就排好了！\n\nThe bad news is: no matter how many times we sort these,\n但坏消息是：无论排多少次\n\nyou're still going to have to pay $214 to get to Indianapolis.\n你还是得付 214 美元到 印第安纳波利斯\n\nAnyway, the \"Big O\" computational complexity of merge sort is N times the Log of N.\n总之，\"归并排序\"的算法复杂度是 O(n * log n)\n\nThe N comes from the number of times we need to compare and merge items,\nn 是需要 比较+合并 的次数\n\nwhich is directly proportional to the number of items in the array.\n和数组大小成正比\n\nThe Log N comes from the number of merge steps.\nlog N 是合并步骤的次数\n\nIn our example, we broke our array of 8 items into 4,\n例子中把大小是 8 的数组，分成四个数组\n\nthen 2, and finally 1.\n然后分成 2 个，最后分成 1 个\n\nThat's 3 splits.\n分了 3 次\n\nSplitting in half repeatedly like this has a logarithmic relationship with the number of items\n重复切成两半，和数量成对数关系\n\n- trust me!\n相信我！\n\nLog base 2 of 8 equals 3 splits.\nLog   8=3\n\nIf we double the size of our array to 16 - that's twice as many items to sort -\n如果数组大小变成 16 - 之前的两倍\n\nit only increases the number of split steps by 1\n也只要多分割 1 次\n\nsince log base 2 of 16 equals 4.\n因为 Log   16=4\n\nEven if we increase the size of the array more than a thousand times,\n即使扩大一千倍\n\nfrom 8 items to 8000 items, the number of split steps stays pretty low.\n从8到8000，分割次数也不会增大多少\n\nLog base 2 of 8000 is roughly 13.\nlog   8000≈13\n\nThat's more, but not much more than 3 -- about four times larger --\n13 比 3 只是4倍多一点\n\nand yet we're sorting a lot more numbers.\n然而排序的元素多得多\n\nFor this reason, merge sort is much more efficient than selection sort.\n因此\"归并排序\"比\"选择排序\"更有效率\n\nAnd now I can put my ceramic cat collection in name order MUCH faster!\n这下我收藏的陶瓷猫  可以更快排序了！\n\nThere are literally dozens of sorting algorithms we could review,\n有好几十种排序算法，但没时间讲\n\nbut instead, I want to move on to my other favorite category of classic algorithmic problems:\n所以我们来谈一个经典算法问题：\n\ngraph search!\n图搜索\n\nA graph is a network of nodes connected by lines.\n\"图\" 是用线连起来的一堆 \"节点\"\n\nYou can think of it like a map, with cities and roads connecting them.\n可以想成地图，每个节点是一个城市，线是公路\n\nRoutes between these cities take different amounts of time.\n一个城市到另一个城市，花的时间不同\n\nWe can label each line with what is called a cost or weight.\n可以用 成本(cost) 或 权重(weight) 来代称\n\nIn this case, it's weeks of travel.\n代表要几个星期\n\nNow let's say we want to find the fastest route\n假设想找\"高庭\"到\"凛冬城\"的最快路线\n\nfor an army at Highgarden to reach the castle at Winterfell.\n假设想找\"高庭\"到\"凛冬城\"的最快路线\n\nThe simplest approach would just be to try every single path exhaustively\n最简单的方法是尝试每一条路\n\nand calculate the total cost of each.\n计算总成本\n\nThat's a brute force approach.\n这是蛮力方法\n\nWe could have used a brute force approach in sorting,\n假设用蛮力方法 来排序数组\n\nby systematically trying every permutation of the array to check if it's sorted.\n尝试每一种组合，看是否排好序\n\nThis would have an N factorial complexity\n这样的时间复杂度是 O(n!)\n\n- that is the number of nodes, times one less, times one less than that, and so on until 1.\nn 是节点数，n! 是 n 乘 n-1 乘 n-2... 一直到 1\n\nWhich is way worse than even N squared.\n比 O(n  ) 还糟糕\n\nBut, we can be way more clever!\n我们可以更聪明些！\n\nThe classic algorithmic solution to this graph problem was invented by\n图搜索问题的经典算法  发明者是\n\none of the greatest minds in computer science practice and theory, Edsger Dijkstra\n理论计算机科学的伟人 Edsger Dijkstra\n\nso it's appropriately named Dijkstra's algorithm.\n所以叫 \"Dijkstra 算法\"\n\nWe start in Highgarden with a cost of 0, which we mark inside the node.\n从\"高庭\"开始，此时成本为0，把0标在节点里\n\nFor now, we mark all other cities with question marks\n其他城市标成问号，因为不知道成本多少\n\n- we don't know the cost of getting to them yet.\n其他城市标成问号，因为不知道成本多少\n\nDijkstra's algorithm always starts with the node with lowest cost.\nDijkstra 算法总是从成本最低的节点开始\n\nIn this case, it only knows about one node, Highgarden, so it starts there.\n目前只知道一个节点 \"高庭\", 所以从这里开始\n\nIt follows all paths from that node to all connecting nodes that are one step away,\n跑到所有相邻节点，记录成本\n\nand records the cost to get to each of them.\n跑到所有相邻节点，记录成本\n\nThat completes one round of the algorithm.\n完成了一轮算法\n\nWe haven't encountered Winterfell yet,\n但还没到\"凛冬城\"\n\nso we loop and run Dijkstra's algorithm again.\n所以再跑一次 Dijkstra 算法\n\nWith Highgarden already checked,\n\"高庭\" 已经知道了\n\nthe next lowest cost node is King's Landing.\n下一个成本最低的节点，是 \"君临城\"\n\nJust as before, we follow every unvisited line to any connecting cities.\n就像之前，记录所有相邻节点的成本\n\nThe line to The Trident has a cost of 5.\n到\"三叉戟河\"的成本是 5\n\nHowever, we want to keep a running cost from Highgarden,\n然而我们想记录的是，从\"高庭\"到这里的成本\n\nso the total cost of getting to The Trident is 8 plus 5, which is 13 weeks.\n所以\"三叉戟河\"的总成本是 8+5=13周\n\nNow we follow the offroad path to Riverrun,\n现在走另一条路到\"奔流城\"\n\nwhich has a high cost of 25, for a total of 33.\n成本高达 25 ，总成本 33\n\nBut we can see inside of Riverrun that we've already found a path with a lower cost of just 10.\n但 \"奔流城\" 中最低成本是 10\n\nSo we disregard our new path, and stick with the previous, better path.\n所以无视新数字，保留之前的成本 10\n\nWe've now explored every line from King's Landing and didn't find Winterfell, so we move on.\n现在看了\"君临城\"的每一条路，还没到\"凛冬城\" 所以继续.\n\nThe next lowest cost node is Riverrun, at 10 weeks.\n下一个成本最低的节点，是\"奔流城\"，要 10 周\n\nFirst we check the path to The Trident, which has a total cost of 10 plus 2, or 12.\n先看 \"三叉戟河\" 成本： 10+2=12\n\nThat's slightly better than the previous path we found, which had a cost of 13,\n比之前的 13 好一点\n\nso we update the path and cost to The Trident.\n所以更新 \"三叉戟河\" 为 12\n\nThere is also a line from Riverrun to Pyke with a cost of 3.\n\"奔流城\"到\"派克城\"成本是 3\n\n10 plus 3 is 13, which beats the previous cost of 14,\n10+3=13，之前是14\n\nand so we update Pyke's path and cost as well.\n所以更新 \"派克城\" 为 13\n\nThat's all paths from Riverrun checked. so you guessed it, Dijkstra's algorithm loops again.\n\"奔流城\"出发的所有路径都走遍了， \\N 你猜对了，再跑一次 Dijkstra 算法\n\nThe node with the next lowest cost is The Trident\n下一个成本最低的节点，是\"三叉戟河\"\n\nand the only line from The Trident that we haven't checked is a path to Winterfell!\n从\"三叉戟河\"出发，唯一没看过的路，通往\"凛冬城\"！\n\nIt has a cost of 10,\n成本是 10\n\nplus we need to add in the cost of 12 it takes to get to The Trident,\n加\"三叉戟河\"的成本 12\n\nfor a grand total cost of 22.\n总成本 22\n\nWe check our last path, from Pyke to Winterfell, which sums to 31.\n再看最后一条路，\"派克城\"到\"凛冬城\"，成本 31\n\nNow we know the lowest total cost, and also the fastest route for the army to get there,\n现在知道了最低成本路线，让军队最快到达,\n\nwhich avoids King's Landing!\n还绕过了\"君临城\"！\n\nDijkstra's original algorithm, conceived in 1956,\nDijkstra 算法的原始版本，构思于 1956 年\n\nhad a complexity of the number of nodes in the graph squared.\n算法复杂度是 O(n  )\n\nAnd squared, as we already discussed, is never great,\n前面说过这个效率不够好\n\nbecause it means the algorithm can't scale to big problems\n意味着输入不能很大\n\n- like the entire road map of the United States.\n比如美国的完整路线图\n\nFortunately, Dijkstra's algorithm was improved a few years later\n幸运的是，Dijkstra 算法几年后得到改进\n\nto take the number of nodes in the graph,\n变成 O(n log n + l)\n\ntimes the log of the number of nodes, PLUS the number of lines.\nn 是节点数，l 是多少条线\n\nAlthough this looks more complicated,\n虽然看起来更复杂\n\nit's actually quite a bit faster.\n但实际更快一些\n\nPlugging in our example graph, with 6 cities and 9 lines, proves it.\n用之前的例子，可以证明更快 \\N （6 个节点 9 条线）\n\nOur algorithm drops from 36 loops to around 14.\n从 36 减少到 14 左右\n\nAs with sorting,\n就像排序，图搜索算法也有很多，有不同优缺点\n\nthere are innumerable graph search algorithms, with different pros and cons.\n就像排序，图搜索算法也有很多，有不同优缺点\n\nEvery time you use a service like Google Maps to find directions,\n每次用谷歌地图时\n\nan algorithm much like Dijkstra's is running on servers to figure out the best route for you.\n类似 Dijkstra 的算法就在服务器上运行，找最佳路线\n\nAlgorithms are everywhere\n算法无处不在\n\nand the modern world would not be possible without them.\n现代世界离不开它们\n\nWe touched only the very tip of the algorithmic iceberg in this episode,\n这集只触及了算法的冰山一角\n\nbut a central part of being a computer scientist\n但成为计算机科学家的核心\n\nis leveraging existing algorithms and writing new ones when needed,\n是根据情况合理决定 用现有算法 还是自己写新算法\n\nand I hope this little taste has intrigued you to SEARCH further.\n希望这集的小例子能让你体会到这点\n\nI'll see you next week.\n下周见\n\nHi, I'm Carrie Anne, and welcome to Crash Course Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nLast episode, we discussed a few example classic algorithms,\n上集讲了一些经典算法\n\nlike sorting a list of numbers and finding the shortest path in a graph.\n比如给数组排序，找图的最短路径\n\nWhat we didn't talk much about,\n而上集没讲的是\n\nis how the data the algorithms ran on was stored in computer memory.\n算法处理的数据  存在内存里的格式是什么\n\nYou don't want your data to be like John Green's college dorm room,\n你肯定不想数据像 John Green 的大学宿舍一样乱 \\N 到处都是食物，衣服和纸\n\nwith food, clothing and papers strewn everywhere.\n你肯定不想数据像 John Green 的大学宿舍一样乱 \\N 到处都是食物，衣服和纸\n\nInstead, we want our data to be structured,\n我们希望数据是结构化的，方便读取\n\nso that it's organized, allowing things to be easily retrieved and read.\n我们希望数据是结构化的，方便读取\n\nFor this, computer scientists use Data Structures!\n因此计算机科学家发明了 \"数据结构\"！\n\nWe already introduced one basic data structure last episode,\n上集已经介绍了一种基本数据结构：\n\nArrays, also called lists or Vectors in some languages.\n数组（Array）\\N 也叫列表（list）或向量（Vector）（在其它编程语言里）\n\nThese are a series of values stored in memory.\n数组的值一个个连续存在内存里\n\nSo instead of just a single value being saved into a variable, like 'j equals 5',\n所以不像之前，一个变量里只存一个值（比如 j = 5）\n\nwe can define a whole series of numbers, and save that into an array variable.\n我们可以把多个值存在数组变量里\n\nTo be able to find a particular value in this array, we have to specify an index.\n为了拿出数组中某个值，我们要指定一个下标（index）\n\nAlmost all programing languages start arrays at index 0,\n大多数编程语言里，数组下标都从 0 开始\n\nand use a square bracket syntax to denote array access.\n用方括号 [ ] 代表访问数组\n\nSo, for example, if we want to add the values in the first and third spots of our array 'j',\n如果想相加数组 J 的第一个和第三个元素\n\nand save that into a variable 'a', we would write a line of code like this.\n把结果存在变量 a，可以写上图这样一行代码\n\nHow an array is stored in memory is pretty straightforward.\n数组存在内存里的方式  十分易懂\n\nFor simplicity, let's say that the compiler chose to store ours at memory location 1,000.\n为了简单，假设编译器从内存地址 1000 开始存数组\n\nThe array contains 7 numbers, and these are stored one after another in memory, as seen here.\n数组有7个数字，像上图一样按顺序存.\n\nSo when we write \"j index of 0\", the computer goes to memory location 1,000,\n写 j[0]，会去内存地址 1000\n\nwith an offset of 0, and we get the value 5.\n加 0 个偏移，得到地址 1000，拿值：5\n\nIf we wanted to retrieve \"j index of 5\", our program goes to memory location 1000,\n如果写 j[5]，会去内存地址 1000\n\nplus an offset of 5, which in this case, holds a value of 4.\n加 5 个偏移，得到地址 1005，拿值： 4\n\nIt's easy to confuse the fifth number in the array with the number at index 5.\n很容易混淆 \"数组中第 5 个数\" 和 \"数组下标为 5 的数\"\n\nThey are not the same.\n它们不是一回事\n\nRemember, the number at index 5 is the 6th number in the array\n记住，下标 5 其实是数组中第 6 个数\n\nbecause the first number is at index 0.\n因为下标是从 0 开始算的\n\nArrays are extremely versatile data structures, used all the time,\n数组的用途广泛\n\nand so there are many functions that can handle them to do useful things.\n所以几乎所有编程语言  都自带了很多函数来处理数组\n\nFor example, pretty much every programming language comes with a built-in sort function,\n举例，数组排序函数很常见\n\nwhere you just pass in your array, and it comes back sorted.\n只需要传入数组，就会返回排序后的数组\n\nSo there's no need to write that algorithm from scratch.\n不需要写排序算法\n\nVery closely related are Strings, which are just arrays of characters,\n数组的亲戚是 字符串 (string)\n\nlike letters, numbers, punctuation and other written symbols.\n其实就是字母,数字,标点符号等  组成的数组\n\nWe talked about how computers store characters way back in Episode 4.\n第 4 集讨论过计算机怎么存储字符\n\nMost often, to save a string into memory, you just put it in quotes, like so.\n写代码时 用引号括起来就行了  \\N j = \"STAN ROCKS\"\n\nAlthough it doesn't look like an array, it is.\n虽然长的不像数组，但的确是数组\n\nBehind the scenes, the memory looks like this.\n幕后看起来像这样\n\nNote that the string ends with a zero in memory.\n注意，字符串在内存里以 0 结尾\n\nIt's not the character zero, but the binary value 0.\n不是\"字符0\"，是\"二进制值0\" \\N 这叫字符\"null\"，表示字符串结尾\n\nThis is called the null character, and denotes the end of the string in memory.\n不是\"字符0\"，是\"二进制值0\" \\N 这叫字符\"null\"，表示字符串结尾\n\nThis is important because if I call a function like \"print quote\",\n这个字符非常重要，如果调用 print 函数\n\nwhich writes the string to the screen,\nprint 在屏幕上输出字符串\n\nit prints out each character in turn starting at the first memory location,\n会从开始位置，逐个显示到屏幕\n\nbut it needs to know when to stop!\n但得知道什么时候停下来！\n\nOtherwise, it would print out every single thing in memory as text.\n否则会把内存里所有东西 都显示出来\n\nThe zero tells string functions when to stop.\n0 告诉函数何时停下\n\nBecause computers work with text so often,\n因为计算机经常处理字符串，所以有很多函数专门处理字符串\n\nthere are many functions that specifically handle strings.\n因为计算机经常处理字符串，所以有很多函数专门处理字符串\n\nFor example, many programming languages have a string concatenation function, or \"strcat\",\n比如连接字符串的 strcat\n\nwhich takes in two strings, and copies the second one to the end of the first.\nstrcat 接收两个字符串，把第二个放到第一个结尾.\n\nWe can use arrays for making one dimensional lists,\n我们可以用数组做一维列表\n\nbut sometimes you want to manipulate data that is two dimensional,\n但有时想操作二维数据\n\nlike a grid of numbers in a spreadsheet, or the pixels on your computer screen.\n比如电子表格，或屏幕上的像素\n\nFor this, we need a Matrix.\n那么需要 矩阵（Matrix）\n\nYou can think of a Matrix as an array of arrays!\n可以把矩阵看成  数组的数组！\n\nSo a 3 by 3 matrix is really  an array of size 3, with each index storing an array of size 3.\n一个 3x3 矩阵就是一个长度为3的数组 \\N 数组里每个元素都是一个长度为3的数组\n\nWe can initialize a matrix like so.\n可以这样初始化.\n\nIn memory, this is packed together in order like this.\n内存里是这样排列的\n\nTo access a value, you need to specify two indexes, like \"J index of 2, then index of 1\" -\n为了拿一个值，需要两个下标，比如 j[2][1]\n\nthis tells the computer you're looking for the item in subarray 2 at position 1.\n告诉计算机在找数组 2 里，位置是 1 的元素\n\nAnd this would give us the value 12.\n得到数字 12\n\nThe cool thing about matrices is we're not limited to 3 by 3\n矩阵酷的地方是，不止能做 3x3 的矩阵\n\n-- we can make them any size we want\n任何维度都行\n\n-- and we can also make them any number of dimensions we want.\n任何维度都行\n\nFor example, we can create a five dimensional matrix and access it like this.\n可以做一个5维矩阵，然后这样访问 \\N a = j[2][0][18][18][3]\n\nThat's right, you now know how to access a five dimensional matrix\n现在你知道了  怎么读一个 5 维矩阵\n\n-- tell your friends!\n快去告诉你的朋友！\n\nSo far, we've been storing individual numbers or letters into our arrays or matrices.\n目前我们只存过单个数字/字符，存进数组或矩阵\n\nBut often it's useful to store a block of related variables together.\n但有时, 把几个有关系的变量存在一起, 会很有用\n\nLike, you might want to store a bank account number along with its balance.\n比如银行账户号和余额\n\nGroups of variables like these can be bundled together into a Struct.\n多个变量打包在一起叫  结构体 (Struct)\n\nNow we can create variables that aren't just single numbers,\n现在多个不同类型数据，可以放在一起\n\nbut are compound data structures, able to store several pieces of data at once.\n现在多个不同类型数据，可以放在一起\n\nWe can even make arrays of structs that we define,\n甚至可以做一个数组，里面放很多结构体\n\nwhich are automatically bundled together in memory.\n这些数据在内存里  会自动打包在一起\n\nIf we access, for example, J index of 0, we get back the whole struct stored there,\n如果写 j[0]，能拿到  j[0] 里的结构体\n\nand we can pull the specific account number and balance data we want.\n然后拿银行账户和余额\n\nThis array of structs, like any other array,\n存结构体的数组，和其它数组一样\n\ngets created at a fixed size that can't be enlarged to add more items.\n创建时就有固定大小，不能动态增加大小\n\nAlso, arrays must be stored in order in memory,\n还有，数组在内存中 按顺序存储\n\nmaking it hard to add a new item to the middle.\n在中间插入一个值很困难\n\nBut, the struct data structure can be used for\n但结构体可以创造更复杂的数据结构，消除这些限制\n\nbuilding more complicated data structures that avoid these restrictions.\n但结构体可以创造更复杂的数据结构，消除这些限制\n\nLet's take a look at this struct that's called a \"node\".\n我们来看一个结构体，叫 节点(node)\n\nIt stores a variable, like a number, and also a pointer.\n它存一个变量 \\N 一个指针（pointer）\n\nA pointer is a special variable that points, hence the name, to a location in memory.\n\"指针\" 是一种特殊变量，指向一个内存地址，因此得名.\n\nUsing this struct, we can create a linked list,\n用 节点 可以做 链表（linked list）\n\nwhich is a flexible data structure that can store many nodes.\n链表是一种灵活数据结构，能存很多个 节点 (node)\n\nIt does this by having each node point to the next node in the list.\n灵活性是通过每个节点 指向 下一个节点实现的\n\nLet's imagine we have three node structs saved in memory, at locations 1000, 1002 and 1008.\n假设有三个节点，在内存地址 1000，1002, 1008\n\nThey might be spaced apart because they were created at different times,\n隔开的原因 可能是创建时间不同\n\nand other data can sit between them.\n它们之间有其他数据\n\nSo, you see that the first node contains the value 7, and the location 1008 in its \"next\" pointer.\n可以看到第一个节点，值是 7，指向地址 1008\n\nThis means that the next node in the linked list is located at memory location 1008.\n代表下一个节点，位于内存地址 1008\n\nLooking down the linked list, to the next node,\n现在来到下一个节点\n\nwe see it stores the value 112 and points to another node at location 1002.\n值是 112，指向地址 1002\n\nIf we follow that, we find a node that contains the value 14\n如果跟着它，会看到一个值为 14 的节点\n\nand points back to the first node at location 1000.\n这个节点  指回地址 1000，也就是第一个节点\n\nSo this linked list happened to be circular,\n这叫 循环链表\n\nbut it could also have been terminated by using a next pointer value of 0\n但链表也可以是非循环的，最后一个指针是 0\n\n-- the null value -- which would indicate we've reached the end of the list.\n\"null\"，代表链表尽头\n\nWhen programmers use linked lists,\n当程序员用链表时\n\nthey rarely look at the memory values stored in the next pointers.\n很少看指针具体指向哪里\n\nInstead, they can use an abstraction of a linked list, that looks like this,\n而是用链表的抽象模型，就像上图\n\nwhich is much easier to conceptualize.\n更容易看懂\n\nUnlike an array, whose size has to be pre-defined,\n数组大小需要预先定好\n\nlinked lists can be dynamically extended or shortened.\n链表大小可以动态增减\n\nFor example, we can allocate a new node in memory,\n可以创建一个新节点，通过改变指针值，把新节点插入链表\n\nand insert it into this list, just by changing the next pointers.\n可以创建一个新节点，通过改变指针值，把新节点插入链表\n\nLinked Lists can also easily be re-ordered, trimmed, split, reversed, and so on.\n链表也很容易重新排序，两端缩减，分割，倒序等\n\nWhich is pretty nifty!\n超方便！\n\nAnd pretty useful for algorithms like sorting, which we talked about last week.\n链表也适合上集的排序算法\n\nOwing to this flexibility, many more-complex data structures are built on top of linked lists\n因为灵活，很多复杂数据结构 都用链表\n\nThe most famous and universal are queues and stacks.\n最出名的是 队列（queue）和 栈（stack）\n\nA queue - like the line at your post office - goes in order of arrival.\n\"队列\" 就像邮局排队，谁先来就排前面\n\nThe person who has been waiting the longest, gets served first.\n\"队列\" 就像邮局排队，谁先来就排前面\n\nNo matter how frustrating it is that all you want to do is buy stamps\n虽然你可能只想买邮票，而前面的人要寄 23 个包裹\n\nand the person in front of you seems to be mailing 23 packages.\n虽然你可能只想买邮票，而前面的人要寄 23 个包裹\n\nBut, regardless, this behavior is called First-In First-Out, or FIFO.\n这叫 先进先出（FIFO）\n\nThat's the first part.\n我指队列，不是指那 23 个包裹\n\nNot the 23 packages thing.\n我指队列，不是指那 23 个包裹\n\nImagine we have a pointer, named \"post office queue\", that points to the first node in our linked list.\n想象有个指针叫\"邮局队列\"，指向链表第一个节点\n\nOnce we're done serving Hank, we can read Hank's next pointer,\n第一个节点是 Hank，服务完 Hank 之后 \\N 读取 Hank 的指针\n\nand update our \"post office queue\" pointer to the next person in the line.\n把\"邮局队列\"指向下一个人\n\nWe've successfully dequeued Hank -- he's gone, done, finished.\n这样就把 Hank \"出队\"（dequeue）了\n\nIf we want to enqueue someone, that is, add them to the line,\n如果我们想把某人\"入队\"（enqueue） \\N 意思是加到队列里\n\nwe have to traverse down the linked list until we hit the end,\n要遍历整个链表到结尾\n\nand then change that next pointer to point to the new person.\n然后把结尾的指针，指向新人（Nick）\n\nWith just a small change, we can use linked lists as stacks, which are LIFO…\n只要稍作修改，就能用链表做 栈，\\N 栈是后进先出(LIFO)\n\nLast-In First-Out.\n只要稍作修改，就能用链表做 栈，\\N 栈是后进先出(LIFO)\n\nYou can think of this like a stack of pancakes...\n可以把\"栈\"想成一堆松饼\n\nas you make them, you add them to the top of stack.\n做好一个新松饼，就堆在之前上面\n\nAnd when you want to eat one, you take them from the top of the stack.\n吃的时候，是从最上面开始\n\nDelicious!\n美味！\n\nInstead of enqueueing and dequeuing,\n栈就不叫\"入队\"\"出队\"了\n\ndata is pushed onto the stack and popped from the stacks.\n叫\"入栈\"（push） \"出栈\"（pop）\n\nYep, those are the official terms!\n对，这些是正确术语！\n\nIf we update our node struct to contain not just one, but two pointers,\n如果节点改一下，改成 2 个指针\n\nwe can build trees,\n就能做 树（tree）\n\nanother data structure that's used in many algorithms.\n很多算法用了 \"树\" 这种数据结构\n\nAgain, programmers rarely look at the values of these pointers,\n同样，程序员很少看指针的具体值\n\nand instead conceptualize trees like this: The top most node is called the root.\n而是把\"树\"抽象成这样：最高的节点叫\"根节点\"（root）\n\nAnd any nodes that hang from other nodes are called children nodes.\n\"根节点\"下的所有节点   都叫\"子节点\"（children）\n\nAs you might expect, nodes above children are called parent nodes.\n任何子节点的直属上层节点，叫\"母节点\"（parent node）\n\nDoes this example imply that Thomas Jefferson is the parent of Aaron Burr?\n这个例子能说明 托马斯·杰斐逊 是 阿龙·伯尔 的父亲吗？\n\nI'll leave that to your fanfiction to decide.\n我让你们的同人文来决定\n\nAnd finally, any nodes that have no children\n没有任何\"子节点\"的节点\n\n-- where the tree ends -- are called Leaf Nodes.\n也就是\"树\"结束的地方，叫\"叶节点\"（leaf）\n\nIn our example, nodes can have up to two children,\n在这里的例子中，节点最多只可以有 2 个子节点\n\nand for that reason, this particular data structure is called a binary tree.\n因此叫 二叉树（binary tree）\n\nBut you could just as easily have trees with three, four or any number of children\n但你可以随便改，弄成 3个，4个，或更多\n\nby modifying the data structure accordingly.\n但你可以随便改，弄成 3个，4个，或更多\n\nYou can even have tree nodes that use linked lists to store all the nodes they point to.\n甚至节点 可以用链表存所有子节点\n\nAn important property of trees - both in real life and in data structures - is that\n\"树\"的一个重要性质是（不管现实中还是数据结构中）\n\nthere's a one-way path from roots to leaves.\n\"根\"到\"叶\"是 单向 的\n\nIt'd be weird if roots connected to leaves, that connected to roots.\n如果根连到叶，叶连到根  就很奇怪\n\nFor data that links arbitrarily, that include things like loops,\n如果数据随意连接，包括循环\n\nwe can use a graph data structure instead.\n可以用\"图\"表示\n\nRemember our graph from last episode of cities connected by roads?\n还记得上集用路连接城市的\"图\"吗？\n\nThis can be stored as nodes with many pointers, very much like a tree,\n这种结构  可以用有多个指针的节点表示\n\nbut there is no notion of roots and leaves, and children and parents…\n因此没有 根 叶 子节点 父节点 这些概念\n\nAnything can point to anything!\n可以随意指向！\n\nSo that's a whirlwind overview\n以上概述了计算机科学中，最主要的一些数据结构\n\nof pretty much all of the fundamental data structures used in computer science.\n以上概述了计算机科学中，最主要的一些数据结构\n\nOn top of these basic building blocks,\n这些基本结构之上，程序员做了各种新变体，有不同性质.\n\nprogrammers have built all sorts of clever variants, with slightly different properties\n这些基本结构之上，程序员做了各种新变体，有不同性质.\n\n-- data structures like red-black trees and heaps, which we don't have time to cover.\n比如\"红黑树\"和\"堆\"，我们没时间讲\n\nThese different data structures have properties that are useful for particular computations.\n不同数据结构适用于不同场景\n\nThe right choice of data structure can make your job a lot easier,\n选择正确数据结构会让工作更简单\n\nso it pays off to think about how you want to structure your data before you jump in.\n所以花时间考虑用什么数据结构是值得的\n\nFortunately, most programming languages come with\n幸运的是，大多数编程语言自带了预先做好的数据结构\n\nlibraries packed full of ready-made data structures.\n幸运的是，大多数编程语言自带了预先做好的数据结构\n\nFor example, C++ has its Standard Template Library, and Java has the Java Class Library.\n比如，C++有\"标准模板库\"，Java有\"Java 类库\"\n\nThese mean programmers don't have to waste time implementing things from scratch,\n程序员不用浪费时间从零写\n\nand can instead wield the power of data structures to do more interesting things,\n时间可以花在更有趣的事情\n\nonce again allowing us to operate at a new level of abstraction!\n又提升了一层抽象！\n\nI'll see you next week.\n下周见！\n\nHi, I'm Carrie Anne and welcome to Crash Course computer science.\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nOver the past a few episodes,\n前几集我们聊了基础，比如函数，算法和数据结构\n\nwe've been building up our understanding of computer science fundamentals,\n前几集我们聊了基础，比如函数，算法和数据结构\n\nsuch as functions, algorithms and data structures.\n前几集我们聊了基础，比如函数，算法和数据结构\n\nToday, we're going to take a step back and look at the person\n今天，我们来看一位对计算机理论 贡献巨大的人\n\nwho formulated many of the theoretical concepts that underline modern computation.\n今天，我们来看一位对计算机理论 贡献巨大的人\n\nThe father of computer science\n计算机科学之父\n\nand not quite Benedict Cumberbatch lookalike, Alan Turing.\n长得不怎么像 本尼 的 阿兰·图灵\n\nAlan Mathison Turing was born in London in 1912\n阿兰·马蒂森·图灵 于 1921 年出生在伦敦，\\N 从小就表现出惊人数学和科学能力\n\nand showed an incredible aptitude for maths and science throughout his early education.\n阿兰·马蒂森·图灵 于 1921 年出生在伦敦，\\N 从小就表现出惊人数学和科学能力\n\nHis first brush of what we now call computer science came in 1935\n他对计算机科学的建树始于 1935 年\n\nwhile he was a master student at King's College in Cambridge.\n当时他是剑桥国王学院的硕士生\n\nHe set out to solve a problem posed by German Mathematician David Hilbert\n他开始解决德国数学家 大卫·希尔伯特 提出的问题\n\nknown as the Entscheidungsproblem\n叫 Entscheidungsproblem （德语）\n\nor decision problem,\n即\"可判定性问题\":\n\nwhich asked the following:\n即\"可判定性问题\":\n\nis there an algorithm that takes, as input, a statement written in formal logic,\n是否存在一种算法，输入正式逻辑语句 \\N 输出准确的\"是\"或\"否\"答案？\n\nand produces a \"yes\" or \"no\" answer that's always accurate?\n是否存在一种算法，输入正式逻辑语句 \\N 输出准确的\"是\"或\"否\"答案？\n\nIf such an algorithm existed,\n如果这样的算法存在， \\N 可以回答比如 \"是否有一个数大于所有数\"\n\nwe could use it to answer questions like, \"Is there a number bigger than all numbers?\"\n如果这样的算法存在， \\N 可以回答比如 \"是否有一个数大于所有数\"\n\nNo, there's not. We know the answer to that one,\n不, 没有.  我们知道答案\n\nbut there are many other questions in mathematics that we'd like to know the answer too.\n但有很多其他数学问题，我们想知道答案\n\nSo if this algorithm existed, we'd want to know it.\n所以如果这种算法存在,  我们想知道\n\nThe American mathematician Alonzo Church first presented a solution to this problem in 1935.\n美国数学家 阿隆佐·丘奇  \\N 于 1935年 首先提出解决方法\n\nHe developed a system of mathematical expressions called Lambda Calculus\n开发了一个叫\"Lambda 算子\"的数学表达系统\n\nand demonstrated that no such universal algorithm could exist.\n证明了这样的算法不存在\n\nAlthough Lambda Calculus was capable of representing any computation,\n虽然\"Lambda 算子\"能表示任何计算\n\nthe mathematical technique was difficult to apply and understand.\n但它使用的数学技巧 难以理解和使用\n\nAt pretty much the same time on the other side of the Atlantic,\n同时在大西洋另一边\n\nAlan Turing came up with his own approach to solve the decision problem.\n阿兰·图灵 想出了自己的办法来解决\"可判定性问题\"\n\nHe proposed a hypothetical computing machine, which we now call a Turing Machine.\n提出了一种假想的计算机，现在叫\"图灵机\"\n\nTuring Machines provided a simple, yet powerful\n图灵机提供了简单又强大的数学计算模型\n\nmathematical model of computation.\n图灵机提供了简单又强大的数学计算模型\n\nAlthough using totally different mathematics,\n虽然用的数学不一样\n\nthey were functionally equivalent to lambda calculus in terms of their computational power.\n但图灵机的计算能力和 Lambda 算子一样\n\nHowever their relative simplicity made them much more popular\n同时因为图灵机更简单，所以在新兴的计算机领域更受欢迎\n\nin the burgeoning field of computer science.\n同时因为图灵机更简单，所以在新兴的计算机领域更受欢迎\n\nIn fact, they're simple enough that I'm going to explain it right now.\n因为它如此简单，我现在就给你解释\n\nA Turing Machine is a theoretical computing device\n图灵机是一台理论计算设备\n\nThere's also a state variable in which we can hold a piece of information\n还有一个状态变量，保存当前状态\n\nabout the current state of the machine.\n还有一个状态变量，保存当前状态\n\nAnd a set of rules that describes what the machine does.\n还有一组规则，描述机器做什么\n\nGiven a state and the current symbol the head is reading,\n规则是根据 当前状态+读写头看到的符号，决定机器做什么\n\nthe rule can be to write a symbol on the tape,\n结果可能是在纸带写入一个符号\n\nchange the state of the machine, move the read/write head to the left or right by one spot\n或改变状态，或把读写头移动一格\n\nor any combination of these actions.\n或执行这些动作的组合\n\nTo make this concrete, let's work through a simple example:\n为了更好理解，讲个简单例子：\n\na Turing Machine that reads a string of ones ending in a zero\n让图灵机读一个以零结尾的字符串\n\nand computes whether there is an even number of ones.\n并计算 1 的出现次数  是不是偶数\n\nIf that's true,\n如果是, 在纸带上写一个 1\n\nthe machine will write a one to the tape\n如果是, 在纸带上写一个 1\n\nand if it's false, it'll write a zero.\n如果不是，在纸带上写一个 0\n\nFirst we need to define our Turing machine rules.\n首先要定义\"图灵机\"的规则\n\nIf the state is even and the current symbol of the tape is one,\n如果当前状态是\"偶数\",  当前符号是1\n\nthen we update the machine state to odd and move the head to the right.\n那么把状态更新为\"奇数\"，把读写头向右移动\n\nOn the other hand if the state is even and the current symbol is zero,\n如果当前状态为偶数，当前符号是 0\n\nwhich means we've reached the end of the string of ones,\n意味着到了字符串结尾\n\nthen we write one to the tape and change the state to halt,\n那么在纸带上写一个 1，并且把状态改成 停机(halt)\n\nas in we're finished and the Turing machine has completed the computation.\n状态改为\"停机\" 是因为图灵机已完成计算\n\nWe also need rules for when the Turing machine is in an odd state,\n但我们还需要 2 条规则，来处理状态为奇数的情况\n\none rule for the symbol on the tape is a zero and another for when it is one.\n一条处理 奇数 + 纸带是 0 的情况 \\N 一条处理 奇数 + 纸带是 1 的情况\n\nLastly we need to define a Starting state, which we'll set to be even.\n最后，要决定机器的初始状态，这里定成\"偶数\"\n\nNow we've defined the rules in the starting state of our Turing machine,\n定义好了 起始状态+规则\n\nwhich is comparable to a computer program, we can run it on some example input.\n就像写好了程序，现在可以输入了\n\nLet's say we store 1 1 0 onto tape.\n假设把\"1 1 0\"放在纸带上，有两个 1，是偶数\n\nThat's two ones, which means there is an even number of ones,\n假设把\"1 1 0\"放在纸带上，有两个 1，是偶数\n\nand if that's news to you,\n如果\"偶数\"对你是新知识 \\N 也许我们该开一门【十分钟速成课：数学】\n\nWe should probably get working on crash course Math.\n如果\"偶数\"对你是新知识 \\N 也许我们该开一门【十分钟速成课：数学】\n\nNotice that our rules only ever move their head to the right\n注意，规则只让 读写头 向右移动\n\nso the rest of the tape is irrelevant.\n其他部分无关紧要，为了简单所以留空\n\nWe'll leave it blank for simplicity.\n其他部分无关紧要，为了简单所以留空\n\nOur Turing machine is all ready to go so let's start it.\n\"图灵机\"准备好了，开始吧\n\nOur state is even and the first number we see is one.\n机器起始状态为\"偶数\"，看到的第一个数是 1\n\nThat matches our topmost rule and so we execute the effect,\n符合最上面那条规则，所以执行对应的步骤\n\nwhich is to update the state to odd and move the read/write head to the right by one spot.\n把状态更新到\"奇数\"， 读写头向右移动一格\n\nOkay, now we see another one on the tape, But this time our state is odd\n然后又看到 1, 但机器状态是\"奇数\"，所以执行第三条规则\n\nand so we execute our third rule\n然后又看到 1, 但机器状态是\"奇数\"，所以执行第三条规则\n\nwhich sets the state back to even and moves the head to the right.\n使机器状态变回\"偶数\"，读写头向右移动一格\n\nNow we see a 0 and our current state is even\n现在看到 0，并且机器状态是 偶数，所以执行第二条规则\n\nso we execute our second rule\n现在看到 0，并且机器状态是 偶数，所以执行第二条规则\n\nwhich is to write a 1 to the tape signifying that yes, it's true,\n在纸带上写 1，表示\"真\" 的确有偶数个 1\n\nthere is an even number of ones,\n在纸带上写 1，表示\"真\" 的确有偶数个 1\n\nand finally the machine halts.\n然后机器停机\n\nThat's how Turing machines work.\n这就是图灵机的原理，很简单对吧？\n\nPretty simple, right?\n这就是图灵机的原理，很简单对吧？\n\nso you might be wondering why there's such a big deal.\n你可能想知道 有什么大不了的\n\nWell, Turing shows that this simple hypothetical machine\n图灵证明了这个简单假想机器\n\ncan perform any computation if given enough time and memory.\n如果有足够时间和内存，可以执行任何计算\n\nIt's a general-purpose computer.\n它是一台通用计算机\n\nOur program was a simple example.\n刚才的程序就是个简单例子\n\nBut with enough rules, states and tape,\n只要有足够的规则，状态和纸带  可以创造任何东西\n\nyou could build anything\n只要有足够的规则，状态和纸带  可以创造任何东西\n\n- a web browser, world of warcraft, whatever!\n浏览器, 魔兽世界 任何东西！\n\nOf course it would be ridiculously inefficient, but it is theoretically possible.\n当然 这样做效率很低，但理论上可行.\n\nAnd that's why, as a model of computing,\n所以图灵机是很强大的计算模型\n\nit's such a powerful idea.\n所以图灵机是很强大的计算模型\n\nIn fact, in terms of what it can and cannot compute\n事实上，就可计算和不可计算而言\n\nthere's no computer more powerful than a turing machine.\n没有计算机比图灵机更强大\n\nA computer that is as powerful is called Turing complete.\n和图灵机一样强大的，叫 \"图灵完备\"\n\nEvery modern computing system, your laptop, your smartphone\n每个现代计算系统 比如笔记本电脑，智能手机\n\nand even the little computer inside your microwave and thermostat\n甚至微波炉和恒温器内部的小电脑\n\nare all Turing Complete.\n都是\"图灵完备\"的\n\nTo answer Hilbert's decision problem,\n为了回答可判定性问题\n\nTuring applied these new Turing machines to an intriguing computational puzzle:\n他把图灵机用于一个有趣计算问题：\n\nthe halting problem.\n\"停机问题\"\n\nPut simply this asks\n简单说就是\n\n\"Is there an algorithm that can determine,\n\"给定图灵机描述和输入纸带，是否有算法可以确定\n\ngiven a description of a turing machine and the input from its tape,\n\"给定图灵机描述和输入纸带，是否有算法可以确定\n\nwhether the Machine will run forever or halt?\"\n机器会永远算下去还是到某一点会停机？\n\nFor example we know our Turing machine will halt when given the input 1 1 0\n我们知道输入 1 1 0，图灵机会停机\n\nBecause we literally walk through the example until it halted,\n因为刚做过这个例子，它最后停机了\n\nbut what about a more complex problem?\n但如果是更复杂的问题呢？\n\nIs there a way to figure out if the program will halt without executing it?\n有没有办法在不执行的情况，弄清会不会停机？\n\nSome programs might take years to run\n一些程序可能要运行好几年\n\nso it would be useful to know before we run it\n所以在运行前知道 会不会出结果很有用\n\nand wait and wait and wait and then start getting worried and wonder\n否则就要一直等啊等，忧虑到底会不会出结果\n\nand then decades later when you're old and gray control-alt-delete.\n当几十年后变老了，再按强制结束\n\nSo much sadness!\n好悲伤！\n\nUnfortunately, Turing came up with a proof that shows the halting problem was in fact unsolvable,\n图灵通过一个巧妙逻辑矛盾 \\N 证明了停机问题是无法解决的\n\nthrough a clever logical contradiction.\n图灵通过一个巧妙逻辑矛盾 \\N 证明了停机问题是无法解决的\n\nLet's follow his reasoning.\n我们来看看他的推理\n\nImagine we have a hypothetical Turing machine that takes a description of a program\n想象有一个假想图灵机，\\N 输入：问题的描述 + 纸带的数据\n\nand some input for his tape\n想象有一个假想图灵机，\\N 输入：问题的描述 + 纸带的数据\n\nand always outputs either Yes, it halts, or no, it doesn't.\n输出 Yes 代表会\"停机\"，输出 No 代表不会\n\nAnd I'm going to give this machine a fun name\n我要给这台机器一个有趣的名字叫 H， \\N 来自\"停机\"的第一个字母\n\nH for Halts.\n我要给这台机器一个有趣的名字叫 H， \\N 来自\"停机\"的第一个字母\n\nDon't worry about how it works.\n不用担心它具体怎么工作\n\nLet's just assume such a machine exists.\n假设这样的机器存在就好  毕竟重点是推论\n\nWe're talking theory here.\n假设这样的机器存在就好  毕竟重点是推论\n\nTuring reasons if there existed a program whose halting behavior was not decidable by H,\n图灵推理说： 如果有个程序， H 无法判断是否会\"停机\"\n\nit would mean the halting problem is unsolvable.\n意味着\"停机问题\"无法解决\n\nTo find one, Turing designed another Turing machine that built on top of H.\n为了找到这样的程序，图灵用 H 设计了另一个图灵机\n\nIf H says the program halts,\n如果 H 说程序会\"停机\"，那么新机器会永远运行（即不会停机）\n\nthen we'll make our new machine loop forever.\n如果 H 说程序会\"停机\"，那么新机器会永远运行（即不会停机）\n\nIf the answer is no, it doesn't the halt.\n如果 H 的结果为 No，代表不会停机\n\nThat will have the new machine output no and halt.\n那么让新机器输出 No，然后\"停机\"\n\nIn essence, we're building a machine that does the opposite of what H says.\n实质上是一台和 H 输出相反的机器\n\nHalt if the program doesn't halt\n如果程序不停机，就停机\n\nand run forever if the program halts.\n如果程序停机，就永远运行下去\n\nSo this argument will also need to add a splitter to the front of our new machine.\n我们还需要在机器前面加一个分离器\n\nSo it accepts only one input and passes that as both the program and input into H.\n让机器只接收一个输入，\\N 这个输入既是程序，也是输入\n\nLet's call this new Machine Bizzaro.\n我们把这台新机器叫 异魔\n\nSo far this seems like a plausible machine right.\n目前为止，这个机器不难理解\n\nNow it's going to get pretty complicated.\n但接下来马上会变复杂，会有点难懂\n\nBut bear with me for a second.\n但接下来马上会变复杂，会有点难懂\n\nLook what happens when you pass bizzaro a description of itself as the input.\n如果把 异魔 的描述，作为本身的输入会怎样\n\nThis means We're asking h what bizzaro will do when asked to evaluate itself.\n意味着在问 H ，当异魔的输入是自己时会怎样\n\nBut if H says Bizzaro halts,\n但如果 H 说异魔会停机\n\nthen Bizzaro enters its infinite loop and thus doesn't halt.\n那么异魔会进入无限循环，因此不会停机\n\nAnd if H says the Bizzaro doesn't halt, then Bizzaro outputs no and halt.\n如果 H 说异魔不会停机，那么异魔会输出 No 然后停机\n\nSo H can't possibly decide the halting problem correctly\n所以 H 不能正确判定 停机问题\n\nbecause there is no answer.\n因为没有答案\n\nIt's a paradox.\n这是一个悖论\n\nAnd this paradox means that the halting problem cannot be solved with Turing machines.\n意味着\"停机问题\"不能用图灵机解决\n\nRemember Turing proves that Turing machines could implement any computation.\n还记得刚刚说： 图灵证明了图灵机可以实现任何计算\n\nSo this solution to the halting problem proves\n\"停机问题\"证明了，不是所有问题都能用计算解决\n\nthat not all problems can be solved by computation.\n\"停机问题\"证明了，不是所有问题都能用计算解决\n\nWow, that's some heavy stuff.\n哇，好难理解\n\nI might have to watch that again myself.\n我都可能要再看一遍\n\nLong story short, Church and Turing showed there were limits to the ability of computers.\n长话短说，丘奇和图灵证明了计算机的能力有极限\n\nNo matter how much time or memory you have,\n无论有多少时间或内存，有些问题是计算机无法解决的\n\nthere are just some problems that cannot be solved ever.\n无论有多少时间或内存，有些问题是计算机无法解决的\n\nThe concurrent efforts by Church and Turing to determine the limits of computation,\n丘奇和图灵证明了计算是有极限的，\n\nand in general, formalize computability, are now called the Church-Turing Thesis.\n起步了可计算性理论，现在叫\"丘奇-图灵论题\"\n\nAt this point in 1936, Turing was only 24 years old\n当时是1936年，图灵只有24岁\n\nand really only just beginning his career.\n他的职业生涯才刚刚开始\n\nFrom 1936 through 1938,\n从1936年到1938年 \\N 在丘奇指导下，他在普林斯顿拿到博士学位\n\nhe completed a PhD at Princeton University under the guidance of Church\n从1936年到1938年 \\N 在丘奇指导下，他在普林斯顿拿到博士学位\n\nthen after graduating he returned to Cambridge.\n毕业后回到剑桥\n\nShortly after in 1939, Britain became embroiled in World War II.\n1939年后不久，英国卷入第二次世界大战\n\nTuring's genius was quickly applied for the war effort.\n图灵的才能很快被投入战争\n\nIn fact, a year before the war started,\n事实上，在战争开始前一年\n\nhe was already working part-time at the UK's government Code and Cypher school,\n他已经在英国政府的 密码破译学校兼职\n\nwhich was the British code breaking group based out of Bletchley Park.\n位于\"布莱切利园\"的一个密码破译组织\n\nOne of his main efforts was figuring out how to decrypt German communications.\n他的工作内容之一是破解德国的通信加密\n\nEspecially those that use the Enigma Machine.\n特别是\"英格玛机\"加密的信息\n\nIn short, these machines scrambled text\n简单说，英格玛机会加密明文\n\nlike you type the letters H-E-L-L-O\n如果输入字母 H-E-L-L-O\n\nand the letters X-W-D-B-J would come out.\n机器输出 X-W-D-B-J\n\nThis process is called Encryption.\n这个过程叫\"加密\"\n\nThe scrambling wasn't random.\n文字不是随便打乱的\n\nThe behavior was defined by a series of real world rotors on the top of the enigma machine.\n加密由\"英格玛机\"顶部的齿轮组合决定\n\nEach were 26 possible rotational positions.\n每个齿轮有26个可能位置\n\nThere was also a plug board at the front of the machine that allow pairs of letters to be swapped.\n机器前面还有插板，可以将两个字母互换\n\nIn total, there were billions of possible settings.\n总共有上十亿种可能\n\nIf you had your only enigma machine and you knew the correct rotor and plug board settings,\n如果你有\"英格玛机\"，并且知道正确的齿轮和插头设置\n\nyou could type in X-W-D-B-J and \"hello\" would come out.\n输入X-W-D-B-J，机器会输出 hello\n\nIn other words, you decrypted the message.\n解密了这条消息\n\nOf course, the German military wasn't sharing their enigma settings on Social Media.\n当然，德军不会把机器设置发到微博上\n\nSo the allies had to break the code.\n盟军必须自己破译密码\n\nWith billions of Rotor and plug board combinations,\n有数十亿种组合，根本没法手工尝试所有组合\n\nthere was no way to check them all by hand.\n有数十亿种组合，根本没法手工尝试所有组合\n\nFortunately for Turing, Enigma Machines and the people who operated them were not perfect.\n幸运的是，英格玛机和操作员不是完美的\n\nLike one key flaw was that a letter would never be encoded as itself,\n一个大缺陷是：字母加密后绝不会是自己\n\nas in an H was never encrypted as an H.\nH 加密后绝对不是 H\n\nTuring building on earlier work by Polish code breakers\n图灵接着之前波兰破译专家的成果继续工作\n\ndesigned a special-purpose electro-mechanical computer called the bombe\n设计了一个机电计算机，叫 Bombe\n\nthat took advantages of this flaw.\n利用了这个缺陷，它对加密消息尝试多种组合\n\nIt tried lots and lots of combinations of enigma settings for a given encrypted message.\n利用了这个缺陷，它对加密消息尝试多种组合\n\nIf the bombe found a setting that led to a letter being encoded as itself\n如果发现字母解密后和原先一样\n\nwhich we know no enigma machines could do.\n我们知道英格玛机决不会这么做\n\nThat combination was discarded then the machine moved on to try another combination.\n这个组合会被跳过，接着试另一个组合\n\nSo bombe was used to greatly narrow the number of Possible enigma settings.\nBombe 大幅减少了搜索量\n\nThis allowed human code breakers to hone their efforts on the most probable solutions,\n让破译人员把精力花在更有可能的组合\n\nlooking for things like common german words in fragments of decoded text.\n比如在解码文本中找常见的德语单词\n\nPeriodically, the Germans would suspect someone was decoding their communications\n德国人时不时会怀疑有人在破解，然后升级英格玛机\n\nand upgrade the enigma machine,\n德国人时不时会怀疑有人在破解，然后升级英格玛机\n\nlike they'd add another rotor creating many more combinations.\n比如加一个齿轮，创造更多可能组合\n\nThey even built entirely new encryption machines.\n他们甚至还做了全新的加密机\n\nThroughout the war, Turing and his colleagues at Bletchley Park\n整个战争期间，图灵和同事在布莱切利园努力破解加密\n\nworked tirelessly to defeat these mechanisms.\n整个战争期间，图灵和同事在布莱切利园努力破解加密\n\nAnd overall, the intelligence gained from decrypted German communications\n解密得到的德国情报，为盟军赢得了很多优势\n\ngave the allies an edge in many theaters\n解密得到的德国情报，为盟军赢得了很多优势\n\nwith some historians arguing is shortened the war by years.\n有些史学家认为他们把战争减短了好几年\n\nAfter the war, Turing return to academia\n战后，图灵回到学术界 \\N 为许多早期计算机工作做出贡献\n\nand contributed to many early electronic computing efforts\n战后，图灵回到学术界 \\N 为许多早期计算机工作做出贡献\n\nlike the Manchester Mark 1, which was an early and influential stored-program computer.\n比如曼彻斯特 1 号，一个早期有影响力的存储程序计算机\n\nBut his most famous post-war contribution was the Artificial Intelligence.\n但他最有名的战后贡献是\"人工智能\"\n\nA field's so new that it didn't get that name until 1956.\n这个领域很新，直到1956年才有名字\n\nIt's a huge topic. So we'll get to it again in future episodes.\n这个话题很大，以后再谈（第34集）\n\nIn 1950, Turing could envision a future where computers\n1950 年，图灵设想了未来的计算机\n\nwere powerful enough to exhibit intelligence equivalent to\n拥有和人类一样的智力，或至少难以区分\n\nor at least indistinguishable from that of a human.\n拥有和人类一样的智力，或至少难以区分\n\nTuring postulated that a computer would deserve to be called intelligent\n图灵提出 \\N 如果计算机能欺骗人类相信它是人类，才算是智能\n\nif it could deceive a human into believing that it was human.\n图灵提出 \\N 如果计算机能欺骗人类相信它是人类，才算是智能\n\nThis became the basis of a simple test, now called the Turing test.\n这成了智能测试的基础，如今叫\"图灵测试\"\n\nImagine that you are having a conversation with two different people\n想像你在和两个人沟通 \\N 不用嘴或面对面，而是来回发消息\n\nnot by voice or in person, but by sending type notes back and forth,\n想像你在和两个人沟通 \\N 不用嘴或面对面，而是来回发消息\n\nyou can ask any questions you want and you get replies.\n可以问任何问题，然后会收到回答\n\nBut one of those two people is actually a computer.\n但其中一个是计算机\n\nIf you can't tell which one is human and which one is a computer,\n如果你分不出哪个是人类，哪个是计算机\n\nthen the computer passes the test.\n那么计算机就通过了图灵测试\n\nThere's a modern version of this test called\n这个测试的现代版叫\n\na completely automated public turing test to tell computers and humans apart\n\"公开全自动图灵测试，用于区分计算机和人类\"\n\nor Captcha for short.\n简称\"验证码\"\n\nThese are frequently used on the internet to prevent automated systems\n防止机器人发垃圾信息等\n\nfrom doing things like posting spam on websites.\n防止机器人发垃圾信息等\n\nI'll admit sometimes I can't read what those squiggly things say.\n我承认 有时我都认不出那些扭曲的东西是什么字\n\nDoes that mean I'm a computer?\n这难道意味着我是计算机？\n\nNormally in this series, we don't delve into the personal lives of these historical figures.\n通常这个系列我们不会深入历史人物的个人生活\n\nBut in Turing's case his name has been inextricably tied to tragedy\n但图灵与悲剧密不可分\n\nso his story is worth mentioning.\n所以他的故事值得一提\n\nTuring was gained a time when homosexuality was illegal in the United Kingdom and much of the world.\n图灵那个时代，同性恋是违法的，英国和大部分国家都是\n\nAnd an investigation into a 1952 Burglary at his home\n1952 年调查他家的入室盗窃案时，向当局暴露了他的性取向\n\nrevealed his sexual orientation to the authorities,\n1952 年调查他家的入室盗窃案时，向当局暴露了他的性取向\n\nwho charged him with gross indecency.\n被起诉 \"行为严重不检点\"\n\nTuring was convicted and given a choice between imprisonment,\n图灵被定罪，有2个选择： \\N 1. 入狱  2. 接受激素来压制性欲\n\nor probation with hormonal treatments to suppress his sexuality.\n图灵被定罪，有2个选择： \\N 1. 入狱  2. 接受激素来压制性欲\n\nHe chose the latter in part to continue his academic work,\n他选了后者，部分原因是为了继续学术工作\n\nbut it altered his mood and personality.\n但药物改变了他的情绪和性格\n\nAlthough the exact circumstances will never be known,\n虽然确切情况永远无法得知\n\nit's most widely accepted that Alan Turing took his own life by poison in 1954.\n图灵于1954年服毒自尽，年仅41岁\n\nHe was only 41.\n图灵于1954年服毒自尽，年仅41岁\n\nMany things have been named in recognition of Turing's contributions to theoretical computer science\n由于图灵对计算机科学贡献巨大，许多东西以他命名\n\nBut perhaps the most prestigious among them is the Turing award\n其中最出名的是\"图灵奖\"\n\nthe highest distinction in the field of computer science.\n计算机领域的最高奖项\n\nEquivalent to a Nobel prize in Physics, chemistry or other sciences.\n相当于物理, 化学等其它领域的诺贝尔奖\n\nDespite a life cut short, Alan inspire the first generation of computer scientists\n虽然英年早逝，但图灵激励了第一代计算机科学家\n\nand lead key groundwork that enabled a digital era that we get to enjoy today.\n而且为如今便利的数字时代 做出了重要基石性工作\n\nI'll see you next week.\n我们下周见\n\nHi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nSo we've talked a lot about sorting in this series\n之前花了很多时间讲排序\n\nand often code to sort a list of numbers might only be ten lines long,\n也写了些 10 行左右的排序代码\n\nwhich is easy enough for a single programmer to write.\n对1个程序员来说很容易写\n\nPlus, it's short enough that you don't need any special tools\n而且代码很短，不必用专门工具\n\n- you could do it in Notepad.\n- 记事本就够了\n\nReally!\n真的！\n\nBut, a sorting algorithm isn't a program;\n但排序算法很少会是独立程序 \\N 更可能是大项目的一小部分\n\nit's likely only a small part of a much larger program.\n但排序算法很少会是独立程序 \\N 更可能是大项目的一小部分\n\nFor example, Microsoft Office has roughly 40 millions lines of code.\n举个例子，微软的 Office 大约有 4000 万代码\n\n40 MILLION!\n4000 万！\n\nThat's way too big for any one person to figure out and write!\n太多了，一个人不可能做到\n\nTo build huge programs like this, programmers use a set of tools and practices.\n为了写大型程序，程序员用各种工具和方法\n\nTaken together, these form the discipline of Software Engineering\n所有这些形成了\"软件工程\"学科\n\n- a term coined by engineer Margaret Hamilton,\n- 这个词由工程师 Margaret Hamilton 创造\n\nwho helped NASA prevent serious problems during the Apollo missions to the moon.\n她帮助 NASA 在阿波罗计划中避免了严重问题\n\nShe once explained it this way:\n她曾说过：\n\n\"It's kind of like a root canal: you waited till the end,\n\"有点像牙根管治疗：你总是拖到最后才做 \\N 但有些事可以预先做好\n\n[but] there are things you could have done beforehand.\n\"有点像牙根管治疗：你总是拖到最后才做 \\N 但有些事可以预先做好\n\nIt's like preventative healthcare,\n有点像预防性体检, 只不过是预防软件出错\"\n\nbut it's preventative software.\"\n有点像预防性体检, 只不过是预防软件出错\"\n\nAs I mentioned in episode 12,\n第 12 集提过\n\nbreaking big programs into smaller functions allows many people to work simultaneously.\n把大项目分解成小函数  可以让多人同时工作\n\nThey don't have to worry about the whole thing,\n不用关心整个项目，关心自己的函数就好了\n\njust the function they're working on.\n不用关心整个项目，关心自己的函数就好了\n\nSo, if you're tasked with writing a sort algorithm,\n如果你的任务是写排序算法\n\nyou only need to make sure it sorts properly and efficiently.\n你只需要确保高效和正确就可以了\n\nHowever, even packing code up into functions isn't enough.\n然而把代码打包成函数 依然不够\n\nMicrosoft Office probably contains hundreds of thousands of them.\n如果只是这样，微软 Office 会有几十万个函数\n\nThat's better than dealing with 40 million lines of code,\n虽然比 4000 万行代码要好一些，但还是太多了\n\nbut it's still way too many \"things\" for one person or team to manage.\n虽然比 4000 万行代码要好一些，但还是太多了\n\nThe solution is to package functions into hierarchies,\n解决办法是：把函数打包成层级. \\N 把相关代码都放在一起，打包成对象（objects）\n\npulling related code together into \"objects\".\n解决办法是：把函数打包成层级. \\N 把相关代码都放在一起，打包成对象（objects）\n\nFor example, car's software might have several functions related to cruise control,\n例如，汽车软件中 可能有几个和定速巡航有关的函数\n\nlike setting speed, nudging speed up or down, and stopping cruise control altogether.\n比如 设定速度，逐渐加速减速，停止定速巡航\n\nSince they're all related,\n因为这些函数都相关，可以包装成一个\"定速巡航对象\"\n\nwe can wrap them up into a unified cruise control object.\n因为这些函数都相关，可以包装成一个\"定速巡航对象\"\n\nBut, we don't have to stop there,\n但不止如此，我们还可以做更多\n\ncruise control is just one part of the engine's software.\n\"定速巡航\"只是引擎软件的一部分\n\nThere might also be sets of functions that control spark plug ignition,\n可能还有 \"火花塞点火\" \"燃油泵\" 和 \"散热器\"\n\nfuel pumps, and the radiator.\n可能还有 \"火花塞点火\" \"燃油泵\" 和 \"散热器\"\n\nSo we can create a \"parent\" Engine Object\n我们可以做一个\"引擎对象\" 来包括所有\"子\"对象\n\nthat contains all of these \"children\" objects.\n我们可以做一个\"引擎对象\" 来包括所有\"子\"对象\n\nIn addition to children *objects*,\n除了子对象，\"引擎对象\"可能有自己的函数\n\nthe engine itself might have its *own* functions.\n除了子对象，\"引擎对象\"可能有自己的函数\n\nYou want to be able to stop and start it, for example.\n比如 开关引擎\n\nIt'll also have its own variables,\n它也会有自己的变量，比如汽车行驶了多少英里\n\nlike how many miles the car has traveled.\n它也会有自己的变量，比如汽车行驶了多少英里\n\nIn general, objects can contain other objects, functions and variables.\n总的来说，对象可以包其它对象，函数和变量\n\nAnd of course, the engine is just one part of a Car Object.\n当然，\"引擎对象\"只是\"汽车对象\"的一部分\n\nThere's also the transmission, wheels, doors, windows, and so on.\n还有传动装置，车轮，门，窗等\n\nNow, as a programmer, if I want to set the cruise control,\n作为程序员，如果想设\"定速巡航\"\n\nI navigate down the object hierarchy,\n要一层层向下\n\nfrom the outermost objects to more and more deeply nested ones.\n从最外面的对象往里找\n\nEventually, I reach the function I want to trigger:\n最后找到想执行的函数：\n\n\"Car, then engine, then cruise control, then set cruise speed to 55\".\nCar. Engine.  CruiseControl.  setCruiseSpeed(55)\n\nProgramming languages often use something equivalent to the syntax shown here.\n编程语言经常用类似这样的语法\n\nThe idea of packing up functional units into nested objects is called\n把函数打包成对象的思想叫 \"面向对象编程\"\n\nObject Oriented Programming.\n把函数打包成对象的思想叫 \"面向对象编程\"\n\nThis is very similar to what we've done all series long:\n这种思想和之前类似\n\nhide complexity by encapsulating low-level details in higher-order components.\n通过封装组件，隐藏复杂度\n\nBefore we packed up things like transistor circuits into higher-level boolean gates.\n之前把晶体管  打包成了逻辑门\n\nNow we're doing the same thing with software.\n现在软件也这样做\n\nYet again, it's a way to move up a new level of abstraction!\n又提升了一层抽象！\n\nBreaking up a big program, like a car's software,\n把大型软件（如汽车软件）\\N 拆成一个个更小单元，适合团队合作\n\ninto functional units is perfect for teams.\n把大型软件（如汽车软件）\\N 拆成一个个更小单元，适合团队合作\n\nOne team might be responsible for the cruise control system,\n一个团队负责定速巡航系统\n\nand a single programmer on that team tackles a handful of functions.\n团队里的一位程序员负责其中一些函数\n\nThis is similar to how big, physical things are built, like skyscrapers.\n类似建摩天大楼\n\nYou'll have electricians running wires,\n有电工装电线\n\nplumbers fitting pipes,\n管道工配管\n\nwelders welding,\n焊接工焊接\n\npainters painting,\n油漆工涂油漆\n\nand hundreds of other people teeming all over the hull.\n还有成百上千人做其他事情\n\nThey work together on different parts simultaneously,\n在不同岗位同时工作，各尽其能\n\nleveraging their different skills.\n在不同岗位同时工作，各尽其能\n\nUntil one day, you've got a whole working building!\n直到整栋楼完成\n\nBut, returning to our cruise control example\n回到定速巡航的例子\n\nits code is going to have to make use of functions in other parts of the engine's software,\n定速巡航 要用到引擎的其它函数，来保持车速\n\nto, you know, keep the car at a constant speed.\n定速巡航 要用到引擎的其它函数，来保持车速\n\nThat code isn't part of the cruise control team's responsibility.\n定速巡航 团队不负责这些代码，另一个团队负责\n\nIt's another team's code.\n定速巡航 团队不负责这些代码，另一个团队负责\n\nBecause the cruise control team didn't write that,\n因为是其他团队的代码，\n\nthey're going to need good documentation about what each function in the code does,\n定速巡航 团队需要文档 帮助理解代码都做什么\n\nand a well-defined Application Programming Interface\n以及定义好的 \"程序编程接口\" -简称 API\n\n-- or API for short.\n以及定义好的 \"程序编程接口\" -简称 API\n\nYou can think of an API as the way that\nAPI 帮助不同程序员合作 \\N 不用知道具体细节，只要知道怎么使用就行了\n\ncollaborating programmers interact across various parts of the code.\nAPI 帮助不同程序员合作 \\N 不用知道具体细节，只要知道怎么使用就行了\n\nFor example, in the IgnitionControl object,\n例如\"点火控制\"对象中，可能有\"设置发动机转数\"函数\n\nthere might be functions to set the RPM of the engine,\n例如\"点火控制\"对象中，可能有\"设置发动机转数\"函数\n\ncheck the spark plug voltage,\n\"检查火花塞电压\"函数\n\nas well as fire the individual spark plugs.\n\"点燃单个火花塞\"函数\n\nBeing able to set the motor's RPM is really useful,\n\"设置发动机转速\"非常有用\n\nthe cruise control team is going to need to call that function.\n\"定速巡航\"团队要用到这个函数\n\nBut, they don't know much about how the ignition system works.\n但他们对点火系统不怎么了解\n\nIt's not a good idea to let them call functions that fire the individual spark plugs.\n让他们调用\"点燃单个火花塞\"函数，不是好主意\n\nOr the engine might explode!\n引擎可能会炸！\n\nMaybe.\n可能啦\n\nThe API allows the right people access to the right functions and data.\nAPI 控制哪些函数和数据让外部访问 \\N 哪些仅供内部\n\nObject Oriented Programming languages do this\n\"面向对象\"的编程语言 \\N 可以指定函数是 public 或 private，来设置权限\n\nby letting you specify whether functions are public or private.\n\"面向对象\"的编程语言 \\N 可以指定函数是 public 或 private，来设置权限\n\nIf a function is marked as \"private\",\n如果函数标记成 private\n\nit means only functions inside that object can call it.\n意味着 只有同一个对象内的其他函数能调用它\n\nSo, in this example, only other functions inside of IgnitionControl,\n在这个例子里，只有内部函数比如 setRPM\n\nlike the setRPM function,\n在这个例子里，只有内部函数比如 setRPM\n\ncan fire the sparkplugs.\n才能调用 fireSparkplug 函数\n\nOn the other hand, because the setRPM function is marked as public,\n而 setRPM 函数是 public  \\N 所以其它对象可以调用它，比如 定速巡航\n\nother objects can call it, like cruise control.\n而 setRPM 函数是 public  \\N 所以其它对象可以调用它，比如 定速巡航\n\nThis ability to hide complexity, and selectively reveal it,\n\"面向对象编程\"的核心是 \\N 隐藏复杂度，选择性的公布功能\n\nis the essence of Object Oriented Programming,\n\"面向对象\"的核心是 \\N 隐藏复杂度，选择性的公布功能\n\nand it's a powerful and popular way to tackle building large and complex programs.\n因为做大型项目很有效，所以广受欢迎\n\nPretty much every piece of software on your computer, or game running on your console,\n计算机上几乎所有软件，游戏机里几乎所有游戏\n\nwas built using an Object Oriented Programming Language,\n都是 \"面向对象\" 编程语言写的\n\nlike C++, C# or Objective-C.\n比如 C++, C#, Objective-C 等\n\nOther popular \"OO\" languages you may have heard of are Python and Java.\n其他流行 OO 语言，你可能听过 Python 和 Java\n\nIt's important to remember that code, before being compiled, is just text.\n有一点很重要：代码在编译前就只是文字而已\n\nAs I mentioned earlier,\n前面提过，你可以用记事本或任何文字处理器\n\nyou could write code in Notepad or any old word processor.\n前面提过，你可以用记事本或任何文字处理器\n\nSome people do.\n有人确实这样做\n\nBut generally, today's software developers use special-purpose applications for writing programs,\n但一般来说，现代软件开发者  会用专门的工具来写代码\n\nones that integrate many useful tools for writing, organizing, compiling and testing code.\n工具里集成了很多有用功能\\N 帮助写代码，整理，编译和测代码\n\nBecause they put everything you need in one place,\n因为集成了所有东西\n\nthey're called Integrated Development Environments ,\n因此叫 集成开发环境，简称 IDE\n\nor IDEs for short.\n因此叫 集成开发环境，简称 IDE\n\nAll IDEs provide a text editor for writing code,\n所有 IDE 都有写代码的界面\n\noften with useful features like automatic color-coding to improve readability.\n还带一些有用功能，比如代码高亮，来提高可读性\n\nMany even check for syntax errors as you type, like spell check for code.\n许多 IDE 提供实时检查，比如拼写\n\nBig programs contain lots of individual source files,\n大型项目有很多源代码文件\n\nso IDEs allow programmers to organize and efficiently navigate everything.\nIDE 帮助开发者整理和看代码\n\nAlso built right into the IDE is the ability to compile and run code.\n很多 IDE 还可以直接编译和运行代码\n\nAnd if your program crashes,\n如果程序崩了，因为你还没写完呢\n\nbecause it's still a work in progress,\n如果程序崩了，因为你还没写完呢\n\nthe IDE can take you back to the line of code where it happened,\nIDE 可以定位到出错代码\n\nand often provide additional information to help you track down and fix the bug,\n还会提供信息 帮你解决问题\n\nwhich is a process called debugging.\n这叫 调试（debug）\n\nThis is important\n调试很重要\n\nbecause most programmers spend 70 to 80% of their time testing and debugging,\n大多数程序员会花 70％~80％ 时间调试，而不是在写代码\n\nnot writing new code.\n大多数程序员会花 70％~80％ 时间调试，而不是在写代码\n\nGood tools, contained in IDEs,\n好工具能极大帮助程序员防止和解决错误\n\ncan go a long way when it comes to helping programmers prevent and find errors.\n好工具能极大帮助程序员防止和解决错误\n\nMany computer programmers can be pretty loyal to their IDEs though\n很多开发者只用一款 IDE\n\nBut let's be honest.\n但承认吧，VIM 才是最棒的编辑器\n\nVIM is where it's at.\n但承认吧，VIM 才是最棒的编辑器\n\nProviding you know how to quit.\n如果你知道怎么退出的话\n\nIn addition to coding and debugging,\n除了写代码和调试\n\nanother important part of a programmer's job is documenting their code.\n程序员工作的另一个重要部分是  给代码写文档\n\nThis can be done in standalone files called \"readme\",\n文档一般放在一个叫 README 的文件里\n\nwhich tell other programmers to read that help file before diving in.\n告诉其他程序员，看代码前先看这个文件\n\nIt can also happen right in the code itself with comment\n文档也可以直接写成\"注释\"，放在源代码里\n\nThese are specially-marked statements that the program knows\n注释是标记过的一段文字\n\nto ignore when the code is compiled.\n编译代码时  注释会被忽略\n\nThey exist only to help programmers figure out what's what in the source code.\n注释存在的唯一作用 \\N 就是帮助开发者理解代码\n\nGood documentation helps programmers when they revisit code they haven't seen for awhile,\n好文档能帮助开发者 \\N 几个月后理解自己的代码，对其他人也很重要\n\nbut it's also crucial for programmers who are totally new to it.\n好文档能帮助开发者 \\N 几个月后理解自己的代码，对其他人也很重要\n\nI just want to take a second here and reiterate that it's THE WORST\n我想花一秒 再强调一下注释很重要\n\nwhen someone parachutes a load of uncommented and undocumented code into your lap,\n最糟糕的就是拿到一堆代码，没有任何注释和文档\n\nand you literally have to go line by line to understand what the code is doing.\n结果得逐行读代码，理解到底干嘛的\n\nSeriously.\n我是认真的\n\nDon't be that person.\n别做那种人\n\nDocumentation also promotes code reuse.\n文档还可以提高复用性\n\nSo, instead of having programmers constantly write the same things over and over,\n与其让程序员一遍遍写同样的东西\n\nthey can track down someone else's code that does what they need.\n可以直接用别人写好的来解决问题\n\nThen, thanks to documentation,\n读文档看怎么用就行，不用读代码\n\nthey can put it to work in their program, without ever having to read through the code.\n读文档看怎么用就行，不用读代码\n\n\"Read the docs\" as they say.\n\"读文档啊\"\n\nIn addition to IDEs,\n除了 IDE，还有一个重要软件帮助团队协作\n\nanother important piece of software that\n除了 IDE，还有一个重要软件帮助团队协作\n\nhelps big teams work collaboratively on big coding projects is called\n除了 IDE，还有一个重要软件帮助团队协作\n\nSource Control,\n源代码管理\n\nalso known as version control or revision control.\n也叫\"版本控制\"\n\nMost often, at a big software company like Apple or Microsoft,\n苹果或微软这样的大型软件公司\n\ncode for projects is stored on centralized servers,\n会把代码放到一个中心服务器上\n\ncalled a code repository .\n叫\"代码仓库\"\n\nWhen a programmer wants to work on a piece of code,\n程序员想改一段代码时\n\nthey can check it out,\n可以 check out\n\nsort of like checking out a book out from a library.\n有点像从图书馆借书\n\nOften, this can be done right in an IDE.\n一般这种操作，可以直接在 IDE 内完成\n\nThen, they can edit this code all they want on their personal computer,\n然后开发者在自己的电脑上编辑代码\n\nadding new features and testing if they work.\n加新功能，测试\n\nWhen the programmer is confident their changes are working and there are no loose ends,\n如果代码没问题了，所有测试通过了\n\nthey can check the code back into the repository,\n可以把代码放回去\n\nknown as committing code, for everyone else to use.\n这叫  提交 (commit)\n\nWhile a piece of code is checked out,\n当代码被 check out，而且可能被改过了\n\nand presumably getting updated or modified,\n当代码被 check out，而且可能被改过了\n\nother programmers leave it alone.\n其他开发者不会动这段代码\n\nThis prevents weird conflicts and duplicated work.\n防止代码冲突和重复劳动\n\nIn this way, hundreds of programmers can be simultaneously checking in and out pieces of code,\n这样多名程序员可以同时写代码，建立庞大的系统\n\niteratively building up huge systems.\n这样多名程序员可以同时写代码，建立庞大的系统\n\nCritically, you don't want someone committing buggy code,\n重要的是，你不希望提交的代码里有问题 \\N 因为其他人可能用到了这些代码\n\nbecause other people and teams may rely on it.\n重要的是，你不希望提交的代码里有问题 \\N 因为其他人可能用到了这些代码\n\nTheir code could crash, creating confusion and lost time.\n导致他们的代码崩溃，造成困惑而且浪费时间\n\nThe master version of the code, stored on the server,\n代码的主版本 (master)\n\nshould always compile without errors and run with minimal bugs.\n应该总是编译正常，尽可能少 bug\n\nBut sometimes bugs creep in.\n但有时 bug 还是会出现\n\nFortunately, source control software keeps track of all changes,\n幸运的是，源代码管理可以跟踪所有变化\n\nand if a bug is found,\n如果发现 bug\n\nthe whole code, or just a piece,\n全部或部分代码，可以\"回滚\"到之前的稳定版\n\ncan be rolled back to an earlier, stable version.\n全部或部分代码，可以\"回滚\"到之前的稳定版\n\nIt also keeps track of who made each change,\n\"源代码管理\" 也记录了谁改了什么代码\n\nso coworkers can send nasty,\n所以同事可以给你发 讨厌的\n\nI mean, helpful\n我是说\"有帮助的\" 邮件给写代码的人\n\nand encouraging emails to the offending person.\n我是说\"有帮助的\" 邮件给写代码的人\n\nDebugging goes hand in hand with writing code,\n写代码和测代码密不可分\n\nand it's most often done by an individual or small team.\n测试一般由个人或小团队完成\n\nThe big picture version of debugging is Quality Assurance testing, or QA.\n测试可以统称 \"质量保证测试\"，简称 QA\n\nThis is where a team rigorously tests out a piece of software,\n严格测试软件的方方面面\n\nattempting to create unforeseen conditions that might trip it up.\n模拟各种可能情况，看软件会不会出错\n\nBasically, they elicit bugs.\n基本上就是找 bug\n\nGetting all the wrinkles out is a huge effort,\n解决大大小小的错误需要很多工作\n\nbut vital in making sure the software works\n但对确保软件质量至关重要\n\nas intended for as many users in as many situations as imaginable before it ships.\n让软件在各种情况下按预期运行\n\nYou've probably heard of beta software.\n你可能听过 \"beta 版\" 软件\n\nThis is a version of software that's mostly complete,\n意思是软件接近完成\n\nbut not 100% fully tested.\n但不是 100％ 完全测试过\n\nCompanies will sometimes release beta versions to the public to help them identify issues,\n公司有时会向公众发布 beta 版，以帮助发现问题\n\nit's essentially like getting a free QA team.\n用户就像免费的 QA 团队\n\nWhat you don't hear about as much\n你听过比较少的是 \\N beta 版之前的版本：alpha 版本\n\nis the version that comes before the beta: the alpha version.\n你听过比较少的是 \\N beta 版之前的版本：alpha 版本\n\nThis is usually so rough and buggy, it's only tested internally.\nalpha 版一般很粗糙，错误很多，\\N 经常只在公司内部测试\n\nSo, that's the tip of the iceberg in terms of the tools, tricks and techniques\n以上只是软件工程师用的工具和技巧的冰山一角\n\nthat allow software engineers to construct the huge pieces of software that we know and love today,\n它们帮助软件工程师制作令人喜爱的软件\n\nlike YouTube, Grand Theft Auto 5, and Powerpoint.\n如 YouTube，GTA5 和 PPT 等等\n\nAs you might expect,\n如你所料\n\nall those millions of lines of code needs some serious processing power to run at useful speeds,\n这些代码要强大的处理能力 才能高速速度运行\n\nso next episode we'll be talking about how computers got so incredibly fast.\n所以下集讨论，计算机怎么发展到如今这么快\n\nSee you then.\n到时见\n\nThis episode is brought to you by Curiosity Stream.\n本集由 Curiosity Stream 赞助播出\n\nHi, I’m Carrie Anne, and welcome to CrashCourse Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne \\N欢迎收看计算机科学速成课！\n\nOver the past six episodes, we delved into software,\n过去 6 集我们聊了软件 \\N 从早期编程方式到现代软件工程\n\nfrom early programming efforts to modern software engineering practices.\n过去 6 集我们聊了软件 \\N 从早期编程方式到现代软件工程\n\nWithin about 50 years, software grew in complexity from machine code punched by hand onto paper tape\n在大概50年里  软件从纸带打孔  \\N 变成面向对象编程语言  在集成开发环境中写程序\n\nto object oriented programming languages, compiled in integrated development environments.\n在大概50年里  软件从纸带打孔  \\N 变成面向对象编程语言  在集成开发环境中写程序\n\nBut this growth in sophistication would not have been possible without improvements in hardware.\n但如果没有硬件的大幅度进步 \\N 软件是不可能做到这些的\n\nTo appreciate computing hardware’s explosive growth in power and sophistication,\n为了体会硬件性能的爆炸性增长 \\N 我们要回到电子计算机的诞生年代\n\nwe need to go back to the birth of electronic computing.\n为了体会硬件性能的爆炸性增长 \\N 我们要回到电子计算机的诞生年代\n\nFrom roughly the 1940’s through the mid-1960s, every computer was built from individual parts,\n大约 1940年代~1960年代中期这段时间里 \\N 计算机都由独立部件组成\n\ncalled discrete components, which were all wired together.\n叫\"分立元件\" \\N 然后不同组件再用线连在一起\n\nFor example, the ENIAC, consisted of more than 17,000 vacuum tubes, 70,000 resistors,\n举例, ENIAC 有1万7千多个真空管, 7万个电阻\n\n10,000 capacitors, and 7,000 diodes, all of which required 5 million hand-soldered connections.\n1万个电容器, 7千个二极管, 5百万个手工焊点\n\nAdding more components to increase performance meant more connections, more wires\n如果想提升性能，就要加更多部件 \\N 这导致更多电线，更复杂\n\nand just more complexity, what was dubbed the Tyranny of Numbers.\n这个问题叫 \"数字暴政''\n\nBy the mid 1950s, transistors were becoming commercially available\n1950 年代中期，晶体管开始商业化（市场上买得到） \\N 开始用在计算机里\n\nand being incorporated into computers.\n1950 年代中期，晶体管开始商业化（市场上买得到） \\N 开始用在计算机里\n\nThese were much smaller, faster and more reliable than vacuum tubes\n晶体管比电子管 更小更快更可靠\n\nbut each transistor was still one discrete component.\n但晶体管依然是分立元件\n\nIn 1959, IBM upgraded their vacuum-tube-based \"709\" computers to transistors by replacing\n1959年，IBM 把 709 计算机从原本的电子管 \\N 全部换成晶体管\n\nby replacing all the discrete vacuum tubes with discrete transistors.\n1959年，IBM 把 709 计算机从原本的电子管 \\N 全部换成晶体管\n\nThe new machine, the IBM 7090, was six times faster and half the cost.\n诞生的新机器 IBM 7090  \\N 速度快 6 倍，价格只有一半\n\nThese transistorized computers marked the second generation of electronic computing.\n晶体管标志着\"计算 2.0 时代\"的到来\n\nHowever, although faster and smaller,\n虽然更快更小 \\N 但晶体管的出现 还是没有解决\"数字暴政\"的问题\n\ndiscrete transistors didn’t solve the Tyranny of Numbers.\n虽然更快更小 \\N 但晶体管的出现 还是没有解决\"数字暴政\"的问题\n\nIt was getting unwieldy to design,\n有几十万个独立元件的计算机不但难设计 \\N 而且难生产\n\nlet alone physically manufacture computers with hundreds of thousands of individual components.\n有几十万个独立元件的计算机不但难设计 \\N 而且难生产\n\nBy the the 1960s, this was reaching a breaking point.\n1960 年代，这个问题的严重性达到顶点 \\N 电脑内部常常一大堆电线缠绕在一起\n\nThe insides of computers were often just huge tangles of wires.\n1960 年代，这个问题的严重性达到顶点 \\N 电脑内部常常一大堆电线缠绕在一起\n\nJust look at what the inside of a PDP-8 from 1965 looked like!\n看看这个 1965 年 PDP-8 计算机的内部\n\nThe answer was to bump up a new level of abstraction, and package up underlying complexity!\n解决办法是引入一层新抽象，封装复杂性\n\nThe breakthrough came in 1958, when Jack Kilby, working at Texas Instruments,\n突破性进展在 1958 年 \\N 当时 Jack Killby 在德州仪器工作\n\ndemonstrated such an electronic part, \"wherein all the components of the electronic circuit are completely integrated.\n演示了一个电子部件：\\N \"电路的所有组件都集成在一起\"\n\nPut simply: instead of building computer parts out of many discrete components\n简单说就是：\\N 与其把多个独立部件用电线连起来，拼装出计算机\n\nand wiring them all together,\n简单说就是：\\N 与其把多个独立部件用电线连起来，拼装出计算机\n\nyou put many components together, inside of a new, single component.\n我们把多个组件包在一起，变成一个新的独立组件\n\nThese are called Integrated Circuits, or ICs.\n这就是 集成电路（IC）\n\nA few months later in 1959, Fairchild Semiconductor, lead by Robert Noyce, made ICs practical.\n几个月后，在1959年 Robert Noyce 的仙童半导体 \\N 让集成电路变为现实\n\nKilby built his ICs out of germanium, a rare and unstable material.\nKilby 用锗来做集成电路，锗很稀少而且不稳定\n\nBut, Fairchild used the abundant silicon, which makes up about a quarter of the earth's crust!\n仙童半导体公司用硅 \\N 硅的蕴藏量丰富，占地壳四分之一\n\nIt’s also more stable, therefore more reliable.\n也更稳定可靠\n\nFor this reason, Noyce is widely regarded as the father of modern ICs,\n所以 Noyce 被公认为现代集成电路之父\n\nushering in the electronics era... and also Silicon Valley, where Fairchild was based\n开创了电子时代，创造了硅谷（仙童公司所在地）\n\nand where many other semiconductor companies would soon pop up.\n之后有很多半导体企业都出现在硅谷\n\nIn the early days, an IC might only contain a simple circuit with just a few transistors,\n起初，一个 IC 只有几个晶体管 \\N 例如这块早期样品，由西屋公司制造\n\nlike this early Westinghouse example.\n起初，一个 IC 只有几个晶体管 \\N 例如这块早期样品，由西屋公司制造\n\nBut even this allowed simple circuits, like the logic gates from Episode 3,\n即使只有几个晶体管 \\N 也可以把简单电路，第 3 集的逻辑门，能封装成单独组件\n\nto be packaged up into a single component.\n即使只有几个晶体管 \\N 也可以把简单电路，第 3 集的逻辑门，能封装成单独组件\n\nICs are sort of like lego for computer engineers\nIC 就像电脑工程师的乐高积木 \\N 可以组合出无数种设计\n\n\"building blocks\" that can be arranged into an infinite array of possible designs.\nIC 就像电脑工程师的乐高积木 \\N 可以组合出无数种设计\n\nHowever, they still have to be wired together at some point\n但最终还是需要连起来， \\N 创造更大更复杂的电路，比如整个计算机\n\nto create even bigger and more complex circuits, like a whole computer.\n但最终还是需要连起来， \\N 创造更大更复杂的电路，比如整个计算机\n\nFor this, engineers had another innovation: printed circuit boards, or PCB\n所以工程师们再度创新：印刷电路板，简称 PCB\n\nInstead of soldering and bundling up bazillions of wires, PCBs, which could be mass manufactured,\nPCB 可以大规模生产，无需焊接或用一大堆线. \\N 它通过蚀刻金属线的方式，把零件连接到一起\n\nhave all the metal wires etched right into them to connect components together.\nPCB 可以大规模生产，无需焊接或用一大堆线. \\N 它通过蚀刻金属线的方式，把零件连接到一起\n\nBy using PCBs and ICs together, one could achieve exactly the same functional circuit\n把 PCB 和 IC 结合使用 \\N 可以大幅减少独立组件和电线，但做到相同的功能\n\nas that made from discrete components,\n把 PCB 和 IC 结合使用 \\N 可以大幅减少独立组件和电线，但做到相同的功能\n\nbut with far fewer individual components and tangled wires.\n把 PCB 和 IC 结合使用 \\N 可以大幅减少独立组件和电线，但做到相同的功能\n\nPlus, it’s smaller, cheaper and more reliable.\n而且更小，更便宜，更可靠.  三赢！\n\nTriple win!\n而且更小，更便宜，更可靠.  三赢！\n\nMany early ICs were manufactured using teeny tiny discrete components\n许多早期 IC 都是把很小的分立元件 \\N 封装成一个独立单元，例如这块 1964 年的IBM样品\n\npackaged up as a single unit, like this IBM example from 1964.\n许多早期 IC 都是把很小的分立元件 \\N 封装成一个独立单元，例如这块 1964 年的IBM样品\n\nHowever, even when using really really itty-bitty components,\n不过，即使组件很小 \\N 塞5个以上的晶体管还是很困难\n\nit was hard to get much more than around five transistors onto a single IC.\n不过，即使组件很小 \\N 塞5个以上的晶体管还是很困难\n\nTo achieve more complex designs, a radically different fabrication process was needed that\n为了实现更复杂的设计，需要全新的制作工艺 \\N \"光刻\"登场！\n\nchanged everything: Photolithography!\n为了实现更复杂的设计，需要全新的制作工艺 \\N \"光刻\"登场！\n\nIn short, it’s a way to use light to transfer complex patterns to a material, like a semiconductor\n简单说就是 \\N用光把复杂图案印到材料上，比如半导体\n\nIt only has a few basic operations, but these can be used to create incredibly complex circuits.\n它只有几个基础操作，但可以制作出复杂电路\n\nLet’s walk through a simple, although extensive example, to make one of these!\n下面用一个简单例子，来做一片这个！\n\nWe start with a slice of silicon, which, like a thin cookie, is called a wafer.\n我们从一片硅开始，叫\"晶圆\" \\N 长得像薄饼干一样\n\nDelicious!\n美味！\n\nSilicon, as we discussed briefly in episode 2, is special because it’s a semiconductor,\n我们在第 2 集讨论过 \\N 硅很特别，它是半导体\n\nthat is, a material that can sometimes conduct electricity and other times does not.\n它有时导电，有时不导电 \\N 我们可以控制导电时机\n\nWe can control where and when this happens,\n它有时导电，有时不导电 \\N 我们可以控制导电时机\n\nmaking Silicon the perfect raw material for making transistors.\n所以硅是做晶体管的绝佳材料\n\nWe can also use a wafer as a base to lay down complex metal circuits, so everything is integrated,\n我们可以用晶圆做基础 \\N 把复杂金属电路放上面，集成所有东西\n\nperfect for... integrated circuits!\n非常适合做.. 集成电路!\n\nThe next step is to add a thin oxide layer on top of the silicon,\n下一步是在硅片顶部  \\N 加一层薄薄的氧化层, 作为保护层\n\nwhich acts as a protective coating.\n下一步是在硅片顶部  \\N 加一层薄薄的氧化层, 作为保护层\n\nThen, we apply a special chemical called a photoresist.\n然后加一层特殊化学品, 叫 \"光刻胶\" \\N 光刻胶被光照射后 会变得可溶\n\nWhen exposed to light, the chemical changes, and becomes soluble,\n然后加一层特殊化学品, 叫 \"光刻胶\" \\N 光刻胶被光照射后 会变得可溶\n\nso it can be washed away with a different special chemical.\n可以用一种特殊化学药剂洗掉\n\nPhotoresists aren’t very useful by themselves,\n单单光刻胶本身，并不是很有用 \\N 但和\"光掩膜\"配合使用会很强大\n\nbut are super powerful when used in conjunction with a photomask.\n单单光刻胶本身，并不是很有用 \\N 但和\"光掩膜\"配合使用会很强大\n\nThis is just like a piece of photographic film, but instead of a photo of\n光掩膜就像胶片一样，只不过不是 \\N 吃墨西哥卷饼的可爱仓鼠，而是要转移到晶圆上的图案\n\na hamster eating a tiny burrito, it contains a pattern to be transferred onto the wafer.\n光掩膜就像胶片一样，只不过不是 \\N 吃墨西哥卷饼的可爱仓鼠，而是要转移到晶圆上的图案\n\nWe do this by putting a photomask over the wafer, and turning on a powerful light.\n把光掩膜盖到晶圆上，用强光照射 \\N 挡住光的地方，光刻胶不会变化\n\nWhere the mask blocks the light, the photoresist is unchanged.\n把光掩膜盖到晶圆上，用强光照射 \\N 挡住光的地方，光刻胶不会变化\n\nBut where the light does hit the photoresist it changes chemically ，\n光照到的地方，光刻胶会发生化学变化 \\N 洗掉它之后，暴露出氧化层\n\nwhich lets us wash away only the photoresist that was exposed to light, selectively revealing areas of our oxide layer.\n光照到的地方，光刻胶会发生化学变化 \\N 洗掉它之后，暴露出氧化层\n\nNow, by using another special chemical, often an acid, we can remove any exposed oxide,\n用另一种化学物质 - 通常是一种酸 \\N 可以洗掉\"氧化层\"露出的部分, 蚀刻到硅层\n\nand etch a little hole the entire way down to the raw silicon.\n用另一种化学物质 - 通常是一种酸 \\N 可以洗掉\"氧化层\"露出的部分, 蚀刻到硅层\n\nNote that the oxide layer under the photoresist is protected.\n注意，氧化层被光刻胶保护住了.\n\nTo clean up, we use yet another special chemical that washes away any remaining photoresist.\n为了清理光刻胶，我们用另一种化学药品洗掉它\n\nYep, there are a lot of special chemicals in photolithography,\n是的，光刻法用很多化学品，每种都有特定用途\n\neach with a very specific function!\n是的，光刻法用很多化学品，每种都有特定用途\n\nSo now we can see the silicon again,\n现在硅又露出来了 \\N 我们想修改硅露出来的区域  让它导电性更好\n\nwe want to modify only the exposed areas to better conduct electricity.\n现在硅又露出来了 \\N 我们想修改硅露出来的区域  让它导电性更好\n\nTo do that, we need to change it chemically through a process called: doping.\n所以用一种化学过程来改变它，叫\"掺杂\"\n\nI’m not even going to make a joke. Let’s move on.\n不是开玩笑！我们继续\n\nMost often this is done with a high temperature gas, something like Phosphorus,\n\"掺杂\" 通常用高温气体来做，比如磷 \\N 渗透进暴露出的硅，改变电学性质\n\nwhich penetrates into the exposed area of silicon.\n\"掺杂\" 通常用高温气体来做，比如磷 \\N 渗透进暴露出的硅，改变电学性质\n\nThis alters its electrical properties.\n\"掺杂\" 通常用高温气体来做，比如磷 \\N 渗透进暴露出的硅，改变电学性质\n\nWe’re not going to wade into the physics and chemistry of semiconductors,\n半导体的具体物理和化学性质我们不会深究,\n\nbut if you’re interested, there’s a link in the description to an excellent video\n如果你感兴趣，描述里有个视频链接 \\N 视频制作者是 Derek Muller 他的频道叫 Veritasium\n\nby our friend Derek Muller from Veritasium.\n如果你感兴趣，描述里有个视频链接 \\N 视频制作者是 Derek Muller 他的频道叫 Veritasium\n\nBut, we still need a few more rounds of photolithography to build a transistor.\n但我们还需要几轮光刻法 来做晶体管\n\nThe process essentially starts again, first by building up a fresh oxide layer ...\n过程基本一样，先盖氧化层，再盖光刻胶\n\nwhich we coat in photoresist.\n过程基本一样，先盖氧化层，再盖光刻胶\n\nNow, we use a photomask with a new and different pattern,\n然后用新的光掩膜，这次图案不同 \\N 在掺杂区域上方开一个缺口\n\nallowing us to open a small window above the doped area.\n然后用新的光掩膜，这次图案不同 \\N 在掺杂区域上方开一个缺口\n\nOnce again, we wash away remaining photoresist.\n洗掉光刻胶\n\nNow we dope, and avoid telling a hilarious joke, again, but with a different gas that\n然后用另一种气体掺杂 \\N 把一部分硅转成另一种形式\n\nconverts part of the silicon into yet a different form.\n然后用另一种气体掺杂 \\N 把一部分硅转成另一种形式\n\nTiming is super important in photolithography in order to control things like doping diffusionand etch depth.\n为了控制深度，时机很重要 \\N 我们不想超过之前的区域\n\nIn this case, we only want to dope a little region nested inside the other.\n为了控制深度，时机很重要 \\N 我们不想超过之前的区域\n\nNow we have all the pieces we need to create our transistor!\n现在 所有需要的组件都有了\n\nThe final step is to make channels in the oxide layer\n最后一步，在氧化层上做通道 \\N 这样可以用细小金属导线，连接不同晶体管\n\nso that we can run little metal wires to different parts of our transistor.\n最后一步，在氧化层上做通道 \\N 这样可以用细小金属导线，连接不同晶体管\n\nOnce more, we apply a photoresist, and use a new photomask to etch little channels.\n再次用光刻胶和光掩膜  蚀刻出小通道\n\nNow, we use a new process, called metalization,\n现在用新的处理方法 叫\"金属化\" \\N 放一层薄薄的金属，比如铝或铜\n\nthat allows us to deposit a thin layer of metal, like aluminium or copper.\n现在用新的处理方法 叫\"金属化\" \\N 放一层薄薄的金属，比如铝或铜\n\nBut we don’t want to cover everything in metal.\n但我们不想用金属盖住所有东西 \\N 我们想蚀刻出具体的电路\n\nWe want to etch a very specific circuit design.\n但我们不想用金属盖住所有东西 \\N 我们想蚀刻出具体的电路\n\nSo, very similar to before, we apply a photoresist, use a photomask, dissolve the exposed resist,\n所以又是类似的步骤 \\N 用光刻胶+光掩膜，然后溶掉暴露的光刻胶，暴露的金属\n\nand use a chemical to remove any exposed metal.\n所以又是类似的步骤 \\N 用光刻胶+光掩膜，然后溶掉暴露的光刻胶，暴露的金属\n\nWhew!\n咻~\n\nOur transistor is finally complete!\n晶体管终于做好了！ \\N 它有三根线，连接着硅的三个不同区域\n\nIt has three little wires that connect to three different parts of the silicon\n晶体管终于做好了！ \\N 它有三根线，连接着硅的三个不同区域\n\neach doped a particular way to create, in this example, what’s called a bipolar junction transistor.\n每个区域的掺杂方式不同，这叫双极型晶体管\n\nHere’s the actual patent from 1962, an invention that changed our world forever!\n这个 1962 年的真实专利，永远改变了世界\n\nUsing similar steps, photolithography can create other useful electronic elements, like\n用类似步骤，光刻可以制作其他电子元件 \\N 比如电阻和电容，都在一片硅上\n\nresistors and capacitors, all on a single piece of silicon\n用类似步骤，光刻可以制作其他电子元件 \\N 比如电阻和电容，都在一片硅上\n\nplus all the wires needed to hook them up into circuits\n而且互相连接的电路也做好了\n\nGoodbye discrete components!\n再见了，分立元件！\n\nIn our example, we made one transistor, but in the real world,\n之前的例子 只做了一个晶体管，但现实中 \\N 光刻法一次会做上百万个细节\n\nphotomasks lay down millions of little details all at once.\n之前的例子 只做了一个晶体管，但现实中 \\N 光刻法一次会做上百万个细节\n\nHere is what an IC might look like from above, with wires crisscrossing above and below each other,\n芯片放大是这样的，导线上下交错，连接各个元件\n\ninterconnecting all the individual elements together into complex circuits.\n芯片放大是这样的，导线上下交错，连接各个元件\n\nAlthough we could create a photomask for an entire wafer,\n尽管可以把光掩膜投影到一整片晶圆上 \\N 但光可以投射成任意大小\n\nwe can take advantage of the fact that light can be focused and projected to any size we want.\n尽管可以把光掩膜投影到一整片晶圆上 \\N 但光可以投射成任意大小\n\nIn the same way that a film can be projected to fill an entire movie screen,\n就像投影仪可以投满荧幕一样\n\nwe can focus a photomask onto a very small patch of silicon, creating incredibly fine details.\n我们可以把光掩膜 \\N 聚焦到极小的区域，制作出非常精细的细节\n\nA single silicon wafer is generally used to create dozens of ICs.\n一片晶圆可以做很多 IC \\N 整块都做完后，可以切割然后包进微型芯片\n\nThen, once you’ve got a whole wafer full, you cut them up and package them into microchips,\n一片晶圆可以做很多 IC \\N 整块都做完后，可以切割然后包进微型芯片\n\nthose little black rectangles you see in electronics all the time.\n微型芯片就是在电子设备中那些小长方体\n\nJust remember: at the heart of each of those chips is one of these small pieces of silicon.\n记住，芯片的核心都是一小片 IC\n\nAs photolithography techniques improved, the size of transistors shrunk, allowing for greater densities.\n随着光刻技术发展，晶体管变小  密度变高\n\nAt the start of the 1960s, an IC rarely contained more than 5 transistors,\n1960 年代初，IC 很少超过 5 个晶体管，因为塞不下\n\nthey just couldn’t possibly fit.\n1960 年代初，IC 很少超过 5 个晶体管，因为塞不下\n\nBut, by the mid 1960s, we were starting to see ICs with over 100 transistors on the market.\n但 1960 年代中期 \\N 市场上开始出现超过 100 个晶体管的 IC\n\nIn 1965, Gordon Moore could see the trend: that approximately every two years,\n1965年，戈登·摩尔看到了趋势：每两年左右，\n\nthanks to advances in materials and manufacturing, you could fit twice the number of transistors\n得益于材料和制造技术的发展 \\N 同样大小的空间，能塞进两倍数量的晶体管！\n\ninto the same amount of space.\n得益于材料和制造技术的发展 \\N 同样大小的空间，能塞进两倍数量的晶体管！\n\nThis is called Moore’s Law.\n这叫 摩尔定律\n\nThe term is a bit of a misnomer though.\n然而这个名字不太对 \\N 因为它不是定律，只是一种趋势\n\nIt’s not really a law at all, more of a trend.\n然而这个名字不太对 \\N 因为它不是定律，只是一种趋势\n\nBut it’s a good one.\n但它是对的\n\nIC prices also fell dramatically, from an average of $50 in 1962 to around $2 in 1968.\n芯片的价格也急剧下降 \\N 1962年平均50美元，下降到1968年2美元左右\n\nToday, you can buy ICs for cents.\n如今 几美分就能买到 IC\n\nSmaller transistors and higher densities had other benefits too.\n晶体管更小密度更高 还有其他好处\n\nThe smaller the transistor, the less charge you have to move around, allowing it to switch\n晶体管越小，要移动的电荷量就越少 \\N 能更快切换状态  耗电更少\n\nstates faster and consume less power.\n晶体管越小，要移动的电荷量就越少 \\N 能更快切换状态  耗电更少\n\nPlus, more compact circuits meant less delay in signals resulting in faster clock speeds.\n电路更紧凑 还意味着信号延迟更低 \\N 导致时钟速度更快\n\nIn 1968, Robert Noyce and Gordon Moore teamed up and founded a new company,\n1968年，罗伯特·诺伊斯 和 戈登·摩尔  \\N 联手成立了一家新公司\n\ncombining the words Integrated and Electronics...\n结合 Intergrated(集成) 和 Electronics(电子) 两个词\n\nIntel. the largest chip maker today.\n取名 Intel， 如今最大的芯片制造商\n\nThe Intel 4004 CPU, from Episodes 7 and 8, was a major milestone.\nIntel 4004 CPU, 在第 7, 8 集介绍过 \\N 是个重要里程碑\n\nReleased in 1971, it was the first processor that shipped as an IC, what’s called a microprocessor,\n发布于1971年 \\N 是第一个用 IC 做的处理器，也叫微型处理器\n\nbecause it was so beautifully small!\n因为真的非常小！\n\nIt contained 2,300 transistors.\n它有2300个晶体管\n\nPeople marveled at the level of integration, an entire CPU in one chip,\n人们惊叹于它的整合水平 \\N 整个 CPU 在一个芯片里\n\nwhich just two decades earlier would have filled an entire room using discrete components.\n而仅仅 20 年前，用分立元件会占满整个屋子\n\nThis era of integrated circuits, especially microprocessors, ushered in the third generation of computing.\n集成电路的出现 \\N 尤其是用来做微处理器，开启了计算 3.0\n\nAnd the Intel 4004 was just the start.\n而 Intel 4004 只是个开始，CPU 晶体管数量爆发增长\n\nCPU transistor count exploded!\n而 Intel 4004 只是个开始，CPU 晶体管数量爆发增长\n\nBy 1980, CPUs contained 30 thousand transistors.\n1980年，3 万晶体管 \\N  1990年，100 万晶体管\n\nBy 1990, CPUs breached the 1 million transistor count.\n1980年，3 万晶体管 \\N  1990年，100 万晶体管\n\nBy 2000, 30 million transistors,\n2000年，3000 万个晶体管\n\nand by 2010, ONE. BILLION. TRANSISTORS. IN ONE. IC. OMG!\n2010年，10亿个晶体管！\\N 在一个芯片里！我的天啊！\n\nTo achieve this density, the finest resolution possible with photolithography has improved\n为了达到这种密度，光刻的分辨率 \\N 从大约一万纳米，大概是人类头发直径的 1/10\n\nfrom roughly 10 thousand nanometers, that’s about 1/10th the thickness of a human hair,\n为了达到这种密度，光刻的分辨率 \\N 从大约一万纳米，大概是人类头发直径的 1/10\n\nto around 14 nanometers today.\n发展到如今的 14 纳米 \\N 比血红细胞小 400 倍！\n\nThat’s over 400 times smaller than a red blood cell!\n发展到如今的 14 纳米 \\N 比血红细胞小 400 倍！\n\nAnd of course, CPU’s weren’t the only components to benefit.\n当然，CPU 不是唯一受益的元件\n\nMost electronics advanced essentially exponentially:\n大多数电子器件都在指数式发展：\\N 内存，显卡，固态硬盘，摄像头感光元件，等等\n\nRAM, graphics cards, solid state hard drives, camera sensors, you name it.\n大多数电子器件都在指数式发展：\\N 内存，显卡，固态硬盘，摄像头感光元件，等等\n\nToday’s processors, like the A10 CPU inside Of an iPhone 7, contains a mind melting 3.3 BILLION\n如今的处理器，比如 iPhone 7 的 A10 CPU \\N 有33亿个晶体管\n\ntransistors in an IC roughly 1cm by 1cm.\n面积仅有 1cm x 1cm，比一张邮票还小\n\nThat’s smaller than a postage stamp!\n面积仅有 1cm x 1cm，比一张邮票还小\n\nAnd modern engineers aren’t laying out these designs by hand, one transistor at a time\n现代工程师设计电路时，当然不是手工一个个设计晶体管 \\N 这不是人力能做到的\n\n- it’s not humanly possible.\n现代工程师设计电路时，当然不是手工一个个设计晶体管 \\N 这不是人力能做到的\n\nStarting in the 1970’s, very-large-scale integration, or VLSI software, has been used\n1970年代开始，超大规模集成(VLSI)软件 \\N 用来自动生成芯片设计\n\nto automatically generate chip designs instead.\n1970年代开始，超大规模集成(VLSI)软件 \\N 用来自动生成芯片设计\n\nUsing techniques like logic synthesis, where whole, high-level components can be laid down,like a memory cache\n用比如 \"逻辑综合\" 这种技术 \\N 可以放一整个高级组件，比如内存缓存\n\nthe software generates the circuit in the most efficient way possible.\n软件会自动生成电路，做到尽可能高效\n\nMany consider this to be the start of fourth generation computers.\n许多人认为这是计算 4.0 的开始\n\nUnfortunately, experts have been predicting the end of Moore’s Law for decades\n坏消息是，专家们几十年来 \\N 一直在预言摩尔定律的终结\n\nand we might finally be getting close to it.\n现在可能终于接近了\n\nThere are two significant issues holding us back from further miniaturization.\n进一步做小，会面临 2 个大问题\n\nFirst, we’re bumping into limits on how fine we can make features on a photomask and\n1. 用光掩膜把图案弄到晶圆上 \\N 因为光的波长，精度已达极限\n\nit’s resultant wafer due to the wavelengths of light used in photolithography.\n1. 用光掩膜把图案弄到晶圆上 \\N 因为光的波长，精度已达极限\n\nIn response, scientists have been developing light sources with smaller and smaller wavelengths\n所以科学家在研制波长更短的光源，投射更小的形状\n\nthat can project smaller and smaller features.\n所以科学家在研制波长更短的光源，投射更小的形状\n\nThe second issue is that when transistors get really really small, where electrodes\n2. 当晶体管非常小，电极之间可能只距离几个原子 \\N 电子会跳过间隙，这叫：量子隧道贯穿\n\nmight be separated by only a few dozen atoms, electrons can jump the gap, a phenomenon called\n2. 当晶体管非常小，电极之间可能只距离几个原子 \\N 电子会跳过间隙，这叫：量子隧穿效应\n\nquantum tunneling.\n2. 当晶体管非常小，电极之间可能只距离几个原子 \\N 电子会跳过间隙，这叫：量子隧穿效应\n\nIf transistors leak current, they don’t make very good switches.\n如果晶体管漏电，就不是好开关\n\nNonetheless, scientists and engineers are hard at work figuring out ways around these problems.\n科学家和工程师在努力找解决方法\n\nTransistors as small as 1 nanometer have been demonstrated in research labs.\n实验室中已造出小至1纳米的晶体管\n\nWhether this will ever be commercially feasible remains MASKED in mystery.\n能不能商业量产依然未知，未来也许能解决\n\nBut maybe we’ll be able to RESOLVE it in the future.\n能不能商业量产依然未知，未来也许能解决\n\nI’m DIEING to know. See you next week.\n我非常期待！下周见！\n\nThis episode is supported by Hover.\n本集由 Hover 赞助播出\n\nHi, I'm Carrie Anne, and welcome to Crash Course Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nComputers in the 1940s and early 50s ran one program at a time.\n1940,1950 年代的电脑，每次只能运行一个程序\n\nA programmer would write one at their desk, for example, on punch cards.\n程序员在打孔纸卡上写程序\n\nThen, they'd carry it to a room containing a room-sized computer,\n然后拿到一个计算机房间,  交给操作员\n\nand hand it to a dedicated computer operator.\n然后拿到一个计算机房间,  交给操作员\n\nThat person would then feed the program into the computer when it was next available.\n等计算机空下来了，操作员会把程序放入\n\nThe computer would run it, spit out some output, and halt.\n然后运行，输出结果，停机\n\nThis very manual process worked OK back when computers were slow,\n以前计算机慢，这种手动做法可以接受\n\nand running a program often took hours, days or even weeks.\n运行一个程序通常要几小时，几天甚至几周\n\nBut, as we discussed last episode,\n但上集说过，计算机越来越快，越来越快\n\ncomputers became faster... and faster... and faster\n但上集说过，计算机越来越快，越来越快\n\nexponentially so!\n指数级增长！\n\nPretty soon, having humans run around and inserting programs into readers\n很快，放程序的时间 比程序运行时间还长\n\nwas taking longer than running the actual programs themselves.\n很快，放程序的时间 比程序运行时间还长\n\nWe needed a way for computers to operate themselves,\n我们需要一种方式 让计算机自动运作\n\nand so, operating systems were born.\n于是\"操作系统\"诞生了\n\nOperating systems , or OS for short, are just programs.\n操作系统，简称 OS，其实也是程序\n\nBut, special privileges on the hardware let them run and manage other programs.\n但它有操作硬件的特殊权限  \\N 可以运行和管理其它程序\n\nThey're typically the first one to start when a computer is turned on,\n操作系统一般是开机第一个启动的程序\n\nand all subsequent programs are launched by the OS.\n其他所有程序 都由操作系统启动\n\nThey got their start in the 1950s,\n操作系统开始于 1950 年代 \\N 那时计算机开始变得更强大更流行\n\nas computers became more widespread and more powerful.\n操作系统开始于 1950 年代 \\N 那时计算机开始变得更强大更流行\n\nThe very first OS augmented the mundane, manual task of loading programs by hand.\n第一个操作系统 加强了程序加载方式\n\nInstead of being given one program at a time,\n之前只能一次给一个程序，现在可以一次多个\n\ncomputers could be given batches.\n之前只能一次给一个程序，现在可以一次多个\n\nWhen the computer was done with one,\n当计算机运行完一个程序，会自动运行下一个程序\n\nit would automatically and near-instantly start the next.\n当计算机运行完一个程序，会自动运行下一个程序\n\nThere was no downtime while someone scurried around an office to find the next program to run.\n这样就不会浪费时间，找下一个程序的纸卡\n\nThis was called batch processing .\n这叫 批处理\n\nWhile computers got faster, they also got cheaper.\n电脑变得更快更便宜，开始在出现在世界各地\n\nSo, they were popping up all over the world,\n电脑变得更快更便宜，开始在出现在世界各地\n\nespecially in universities and government offices.\n特别是大学和政府办公室\n\nSoon, people started sharing software.\n很快，人们开始分享软件，但有一个问题\n\nBut there was a problem\n很快，人们开始分享软件，但有一个问题\n\nIn the era of one-off computers, like the Harvard Mark 1 or ENIAC,\n在哈佛1号和 ENIAC 那个时代，计算都是一次性的\n\nprogrammers only had to write code for that one single machine.\n程序员只需要给那\"一台\"机器写代码\n\nThe processor, punch card readers, and printers were known and unchanging.\n处理器，读卡器，打印机都是已知的\n\nBut as computers became more widespread,\n但随着电脑越来越普遍，计算机配置并不总是相同的\n\ntheir configurations were not always identical,\n但随着电脑越来越普遍，计算机配置并不总是相同的\n\nlike computers might have the same CPU, but not the same printer.\n比如计算机可能有相同 CPU，但不同的打印机\n\nThis was a huge pain for programmers.\n这对程序员很痛苦\n\nNot only did they have to worry about writing their program,\n不仅要担心写程序，还要担心程序怎么和不同型号打印机交互\n\nbut also how to interface with each and every model of printer,\n不仅要担心写程序，还要担心程序怎么和不同型号打印机交互\n\nand all devices connected to a computer, what are called peripherals.\n以及计算机连着的其他设备，这些统称\"外部设备\"\n\nInterfacing with early peripherals was very low level,\n和早期的外部设备交互，是非常底层的\n\nrequiring programmers to know intimate hardware details about each device.\n程序员要了解设备的硬件细节\n\nOn top of that, programmers rarely had access to every model of a peripheral to test their code on.\n加重问题的是，程序员很少能拿到所有型号的设备来测代码\n\nSo, they had to write code as best they could, often just by reading manuals,\n所以一般是阅读手册来写代码，祈祷能正常运行\n\nand hope it worked when shared.\n所以一般是阅读手册来写代码，祈祷能正常运行\n\nThings weren't exactly plug-and-play\n现在是\"即插即用\"，以前是\"祈祷能用\"\n\nback then more plug-and-pray.\n现在是\"即插即用\"，以前是\"祈祷能用\"\n\nThis was clearly terrible,\n这很糟糕，所以为了程序员写软件更容易\n\nso to make it easier for programmers,\n这很糟糕，所以为了程序员写软件更容易\n\nOperating Systems stepped in as intermediaries between software programs and hardware peripherals.\n操作系统充当软件和硬件之间的媒介\n\nMore specifically, they provided a software abstraction, through APIs,\n更具体地说，操作系统提供 API 来抽象硬件，叫\"设备驱动程序\"\n\ncalled device drivers .\n更具体地说，操作系统提供 API 来抽象硬件，叫\"设备驱动程序\"\n\nThese allow programmers to talk to common input and output hardware,\n程序员可以用标准化机制  和输入输出硬件（I/O）交互\n\nor I/O for short, using standardized mechanisms.\n程序员可以用标准化机制  和输入输出硬件（I/O）交互\n\nFor example, programmers could call a function like \"print highscore\",\n比如，程序员只需调用 print(highscore)\n\nand the OS would do the heavy lifting to get it onto paper.\n操作系统会处理  输到纸上的具体细节\n\nBy the end of the 1950s, computers had gotten so fast,\n到 1950 年代尾声，电脑已经非常快了\n\nthey were often idle waiting for slow mechanical things, like printers and punch card readers.\n处理器经常闲着，等待慢的机械设备（比如打印机和读卡器）\n\nWhile programs were blocked on I/O,\n程序阻塞在 I/O 上\n\nthe expensive processor was just chillin'... not like a villain\n而昂贵的处理器则在度假，就是放松啥也不做\n\nyou know, just relaxing.\n而昂贵的处理器则在度假，就是放松啥也不做\n\nIn the late 50's, the University of Manchester, in the UK,\n50年代后期，英国曼彻斯特大学 \\N 开始研发世界上第一台超级计算机，Atlas\n\nstarted work on a supercomputer called Atlas, one of the first in the world.\n50年代后期，英国曼彻斯特大学 \\N 开始研发世界上第一台超级计算机，Atlas\n\nThey knew it was going to be wicked fast,\n他们知道机器会超级快，所以需要一种方式来最大限度的利用它\n\nso they needed a way to make maximal use of the expensive machine.\n他们知道机器会超级快，所以需要一种方式来最大限度的利用它\n\nTheir solution was a program called the Atlas Supervisor, finished in 1962.\n他们的解决方案是一个程序叫 Atlas Supervisor  \\N 于1962年完成\n\nThis operating system not only loaded programs automatically, like earlier batch systems,\n这个操作系统 \\N不仅像更早期的批处理系统那样，能自动加载程序\n\nbut could also run several at the same time on its single CPU.\n还能在单个 CPU 上同时运行几个程序\n\nIt did this through clever scheduling.\n它通过调度来做到这一点\n\nLet's say we have a game program running on Atlas,\n假设 Atlas 上有一个游戏在运行\n\nand we call the function \"print(highscore)\"\n并且我们调用一个函数 print(highscore)\n\nwhich instructs Atlas to print the value of a variable named \"highscore\"\n它让 Atlas 打印一个叫 highscore 的变量值\n\nonto paper to show our friends that we're the ultimate champion of virtual tiddlywinks.\n让朋友知道 我是最高分冠军\n\nThat function call is going to take a while, the equivalent of thousands of clock cycles,\nprint 函数运行需要一点时间，大概上千个时钟周期\n\nbecause mechanical printers are slow in comparison to electronic CPUs.\n但因为打印机比 CPU 慢，与其等着它完成操作\n\nSo instead of waiting for the I/O to finish,\n但因为打印机比 CPU 慢，与其等着它完成操作\n\nAtlas instead puts our program to sleep,\nAtlas 会把程序休眠，运行另一个程序\n\nthen selects and runs another program that's waiting and ready to run.\nAtlas 会把程序休眠，运行另一个程序\n\nEventually, the printer will report back to Atlas that it finished printing the value of \"highscore\".\n最终, 打印机会告诉 Atlas, 打印已完成\n\nAtlas then marks our program as ready to go,\nAtlas 会把程序标记成可继续运行\n\nand at some point, it will be scheduled to run again on the CPU,\n之后在某时刻会安排给 CPU 运行\n\nand continue onto the next line of code following the print statement.\n并继续 print 语句之后的下一行代码\n\nIn this way, Atlas could have one program running calculations on the CPU,\n这样, Atlas 可以在 CPU 上运行一个程序\n\nwhile another was printing out data,\n同时另一个程序在打印数据\n\nand yet another reading in data from a punch tape.\n同时另一个程序读数据\n\nAtlas' engineers doubled down on this idea,\nAtlas 的工程师做的还要多，配了4台纸带读取器，4台纸带打孔机\n\nand outfitted their computer with 4 paper tape readers, 4 paper tape punches,\nAtlas 的工程师做的还要多，配了4台纸带读取器，4台纸带打孔机\n\nand up to 8 magnetic tape drives.\n多达8个磁带驱动器\n\nThis allowed many programs to be in progress all at once,\n使多个程序可以同时运行，在单个 CPU 上共享时间\n\nsharing time on a single CPU.\n使多个程序可以同时运行，在单个 CPU 上共享时间\n\nThis ability, enabled by the Operating System, is called\n操作系统的这种能力叫\"多任务处理\"\n\nmultitasking.\n操作系统的这种能力叫\"多任务处理\"\n\nThere's one big catch to having many programs running simultaneously on a single computer, though.\n同时运行多个程序有个问题\n\nEach one is going to need some memory,\n每个程序都会占一些内存 \\N 当切换到另一个程序时，我们不能丢失数据\n\nand we can't lose that program's data when we switch to another program.\n每个程序都会占一些内存 \\N 当切换到另一个程序时，我们不能丢失数据\n\nThe solution is to allocate each program its own block of memory.\n解决办法是 给每个程序分配专属内存块\n\nSo, for example, let's say a computer has 10,000 memory locations in total.\n举个例子，假设计算机一共有 10000 个内存位置\n\nProgram A might get allocated memory addresses 0 through 999,\n程序 A 分配到内存地址 0 到 999\n\nand Program B might get 1000 through 1999, and so on.\n而程序 B 分配到内存地址 1000 到 1999，以此类推\n\nIf a program asks for more memory,\n如果一个程序请求更多内存，操作系统会决定是否同意\n\nthe operating system decides if it can grant that request,\n如果一个程序请求更多内存，操作系统会决定是否同意\n\nand if so, what memory block to allocate next.\n如果同意，分配哪些内存块\n\nThis flexibility is great, but introduces a quirk.\n这种灵活性很好，但带来一个奇怪的后果\n\nIt means that Program A could end up being allocated non-sequential blocks of memory,\n程序 A 可能会分配到非连续的内存块\n\nin say addresses 0 through 999, and 2000 through 2999.\n比如内存地址 0 到 999，以及 2000 到 2999\n\nAnd this is just a simple example\n这只是个简单例子\n\n- a real program might be allocated dozens of blocks scattered all over memory.\n真正的程序可能会分配到内存中数十个地方\n\nAs you might imagine,\n你可能想到了，这对程序员来说很难跟踪\n\nthis would get really confusing for programmers to keep track of.\n你可能想到了，这对程序员来说很难跟踪\n\nMaybe there's a long list of sales data in memory that\n也许内存里有一长串销售额，每天下班后要算销售总额\n\na program has to total up at the end of the day,\n也许内存里有一长串销售额，每天下班后要算销售总额\n\nbut this list is stored across a bunch of different blocks of memory.\n但列表 存在一堆不连续的内存块里\n\nTo hide this complexity, Operating Systems virtualize memory locations.\n为了隐藏这种复杂性，操作系统会把内存地址进行 \"虚拟化\"\n\nWith Virtual Memory, programs can assume their memory always starts at address 0,\n这叫 \"虚拟内存\"，程序可以假定内存总是从地址0开始\n\nkeeping things simple and consistent.\n简单又一致\n\nHowever, the actual, physical location in computer memory\n而实际物理位置  被操作系统隐藏和抽象了\n\nis hidden and abstracted by the operating system.\n而实际物理位置  被操作系统隐藏和抽象了\n\nJust a new level of abstraction.\n一层新的抽象\n\nLet's take our example Program B,\n用程序 B 来举例 \\N 它被分配了内存地址 1000 到 1999\n\nwhich has been allocated a block of memory from address 1000 to 1999.\n用程序 B 来举例 \\N 它被分配了内存地址 1000 到 1999\n\nAs far as Program B can tell, this appears to be a block from 0 to 999.\n对程序 B 而言，它看到的地址是 0 到 999\n\nThe OS and CPU handle the virtual-to-physical memory remapping automatically.\n操作系统会自动处理 \\N 虚拟内存和物理内存之间的映射\n\nSo, if Program B requests memory location 42,\n如果程序 B 要地址 42，实际上是物理地址 1042\n\nit really ends up reading address 1042.\n如果程序 B 要地址 42，实际上是物理地址 1042\n\nThis virtualization of memory addresses is even more useful for Program A,\n这种内存地址的虚拟化  对程序 A 甚至更有用\n\nwhich in our example, has been allocated two blocks of memory\n在例子中，A 被分配了两块隔开的内存\n\nthat are separated from one another.\n在例子中，A 被分配了两块隔开的内存\n\nThis too is invisible to Program A.\n程序 A 不知道这点.\n\nAs far as it can tell, it's been allocated a continuous block of 2000 addresses.\n以 A 的视角，它有 2000 个连续地址\n\nWhen Program A reads memory address 999,\n当程序 A 读内存地址 999 时 \\N 会刚好映射到物理内存地址 999\n\nthat does coincidentally map to physical memory address 999.\n当程序 A 读内存地址 999 时 \\N 会刚好映射到物理内存地址 999\n\nBut if Program A reads the very next value in memory, at address 1000,\n但如果程序 A 读下一个地址 1000\n\nthat gets mapped behind the scenes to physical memory address 2000.\n会映射到物理地址 2000\n\nThis mechanism allows programs to have flexible memory sizes,\n这种机制使程序的内存大小可以灵活增减 \\N 叫\"动态内存分配\"\n\ncalled dynamic memory allocation,\n这种机制使程序的内存大小可以灵活增减 \\N 叫\"动态内存分配\"\n\nthat appear to be continuous to them.\n对程序来说，内存看起来是连续的.\n\nIt simplifies everything and offers tremendous flexibility to the Operating System\n它简化了一切，为操作系统同时运行多个程序 \\N 提供了极大的灵活性\n\nin running multiple programs simultaneously.\n它简化了一切，为操作系统同时运行多个程序 \\N 提供了极大的灵活性\n\nAnother upside of allocating each program its own memory,\n给程序分配专用的内存范围，\\N 另一个好处是 这样隔离起来会更好\n\nis that they're better isolated from one another.\n给程序分配专用的内存范围，\\N 另一个好处是 这样隔离起来会更好\n\nSo, if a buggy program goes awry, and starts writing gobbledygook,\n如果一个程序出错，开始写乱七八糟的数据\n\nit can only trash its own memory, not that of other programs.\n它只能捣乱自己的内存，不会影响到其它程序.\n\nThis feature is called Memory Protection.\n这叫 \"内存保护\"\n\nThis is also really useful in protecting against malicious software, like viruses.\n防止恶意软件（如病毒）也很有用\n\nFor example, we generally don't want other programs to have the ability\n例如，我们不希望其他程序有能力 \\N 读或改邮件程序的内存\n\nto read or modify the memory of, let say, our email,\n例如，我们不希望其他程序有能力 \\N 读或改邮件程序的内存\n\nwith that kind of access,\n如果有这种权限 \\N 恶意软件可能以你的名义发邮件，甚至窃取个人信息\n\nmalware could send emails on your behalf and maybe steal personal information.\n如果有这种权限 \\N 恶意软件可能以你的名义发邮件，甚至窃取个人信息\n\nNot good!\n一点都不好！\n\nAtlas had both virtual and protected memory.\nAtlas 既有\"虚拟内存\"也有\"内存保护\"\n\nIt was the first computer and OS to support these features!\n是第一台支持这些功能的计算机和操作系统！\n\nBy the 1970s, computers were sufficiently fast and cheap.\n到 1970 年代，计算机足够快且便宜\n\nInstitutions like a university could buy a computer and let students use it.\n大学会买电脑让学生用\n\nIt was not only fast enough to run several programs at once,\n计算机不仅能同时运行多个程序，还能让多用户能同时访问\n\nbut also give several users simultaneous, interactive access.\n计算机不仅能同时运行多个程序，还能让多用户能同时访问\n\nThis was done through a terminal,\n多个用户用\"终端\"来访问计算机\n\nwhich is a keyboard and screen that connects to a big computer,\n\"终端\"只是键盘+屏幕，连到主计算机 \\N 终端本身没有处理能力\n\nbut doesn't contain any processing power itself.\n\"终端\"只是键盘+屏幕，连到主计算机 \\N 终端本身没有处理能力\n\nA refrigerator-sized computer might have 50 terminals connected to it,\n冰箱大小的计算机可能有50个终端，能让50个用户使用\n\nallowing up to 50 users.\n冰箱大小的计算机可能有50个终端，能让50个用户使用\n\nNow operating systems had to handle not just multiple programs,\n这时操作系统不但要处理多个程序，还要处理多个用户\n\nbut also multiple users.\n这时操作系统不但要处理多个程序，还要处理多个用户\n\nSo that no one person could gobble up all of a computer's resources,\n为了确保其中一个人  不会占满计算机资源\n\noperating systems were developed that offered time-sharing.\n开发了 分时操作系统\n\nWith time-sharing each individual user was only allowed to utilize\n意思是 每个用户只能用一小部分处理器，内存等\n\na small fraction of the computer's processor, memory, and so on.\n意思是 每个用户只能用一小部分处理器，内存等\n\nBecause computers are so fast,\n因为电脑很快 \\N 即使拿到 1/50 的资源也足以完成许多任务\n\neven getting just 1/50th of its resources was enough for individuals to complete many tasks.\n因为电脑很快 \\N 即使拿到 1/50 的资源也足以完成许多任务\n\nThe most influential of early time-sharing Operating Systems was\n早期分时操作系统中，最有影响力的是 \\N Multics（多任务信息与计算系统）\n\nMultics,  or Multiplexed Information and Computing Service,\n早期分时操作系统中，最有影响力的是 \\N Multics（多任务信息与计算系统）\n\nreleased in 1969.\n于 1969 年发布\n\nMultics was the first major operating system designed to be secure from the outset.\nMultics 是第一个，从设计时就考虑到安全的操作系统\n\nDevelopers didn't want mischievous users accessing data they shouldn't,\n开发人员不希望恶意用户 访问不该访问的数据\n\nlike students attempting to access the final exam on their professor's account.\n比如学生假装成教授，访问期末考试的文件\n\nFeatures like this meant Multics was really complicated for its time,\n这导致 Multics 的复杂度超过当时的平均水准\n\nusing around 1 Megabit of memory, which was a lot back then!\n操作系统会占大约 1 Mb 内存，这在当时很多！\n\nThat might be half of a computer's memory, just to run the OS!\n可能是内存的一半，只拿来运行操作系统！\n\nDennis Ritchie, one of the researchers working on Multics, once said:\nMultics 的研究人员之一 Dennis Ritchie 曾说过\n\n\"One of the obvious things that went wrong with Multics as a commercial success\n\"阻碍 Multics 获得商业成功的一个明显问题是\n\nwas just that it was sort of over-engineered in a sense.\n从某种方面来说，它被过度设计了，功能太多了\"\n\nThere was just too much in it.\"\n从某种方面来说，它被过度设计了，功能太多了\"\n\nThis lead Dennis, and another Multics researcher,\n所以 Dennis 和另一个 Multics 研究员 \\N Ken Thompson 联手打造新的操作系统\n\nKen Thompson, to strike out on their own and build a new, lean operating system\n所以 Dennis 和另一个 Multics 研究员 \\N Ken Thompson 联手打造新的操作系统\n\ncalled Unix.\n叫 Unix\n\nThey wanted to separate the OS into two parts:\n他们想把操作系统分成两部分：\n\nFirst was the core functionality of the OS,\n首先是操作系统的核心功能\n\nthings like memory management, multitasking,and dealing with I/O,\n如内存管理，多任务和输入/输出处理 \\N 这叫\"内核\"\n\nwhich is called the kernel .\n如内存管理，多任务和输入/输出处理 \\N 这叫\"内核\"\n\nThe second part was a wide array of useful tools that came bundled with,\n第二部分是一堆有用的工具\n\nbut not part of the kernel, things like programs and libraries.\n但它们不是内核的一部分（比如程序和运行库）\n\nBuilding a compact, lean kernel meant intentionally leaving some functionality out.\n紧凑的内核 意味着功能没有那么全面\n\nTom Van Vleck, another Multics developer, recalled:\nMultics 的另一个开发者 Tom Van Vleck 回忆说：\n\n\"I remarked to Dennis that easily half the code I was writing in Multics was error recovery code.\"\n\"我对 Dennis 说，我在 Multics 写的一半代码都是错误恢复代码\"\n\nHe said, \"We left all that stuff out of Unix.\n他说:\"Unix 不会有这些东西\n\nIf there's an error, we have this routine called panic,\n如果有错误发生，我们就让内核\"恐慌\"（panic）\n\nand when it is called, the machine crashes,\n当调用它时，机器会崩溃\n\nand you holler down the hall, 'Hey, reboot it.'\"\"\n你得在走廊里大喊，\"嘿，重启电脑\"\n\nYou might have heard of kernel panics.\n你可能听过 \"内核恐慌\"（kernel panic）\n\nThis is where the term came from.\n这就是这个词的来源\n\nIt's literally when the kernel crashes, has no recourse to recover,\n内核如果崩溃，没有办法恢复\n\nand so calls a function called \"panic\".\n所以调用一个叫\"恐慌\"（panic）的函数\n\nOriginally, all it did was print the word \"panic\" and then enter an infinite loop.\n起初只是打印\"恐慌\"一词，然后无限循环\n\nThis simplicity meant that Unix could be run on cheaper and more diverse hardware,\n这种简单性意味着  \\N Unix 可以在更便宜更多的硬件上运行\n\nmaking it popular inside Bell Labs, where Dennis and Ken worked.\n使 Unix 在 Dennis 和 Ken 工作的 \\N 贝尔实验室大受欢迎\n\nAs more developers started using Unix to build and run their own programs,\n越来越多开发人员用 Unix 写程序和运行程序\n\nthe number of contributed tools grew.\n工具数量日益增长\n\nSoon after its release in 1971,\n1971 年发布后不久\n\nit gained compilers for different programming languages and even a word processor,\n就有人写了不同编程语言的编译器 \\N 甚至文字处理器\n\nquickly making it one of the most popular OSes of the 1970s and 80s.\n使得 Unix 迅速成为 \\N 1970~80年代最流行的操作系统之一\n\nAt the same time, by the early 1980s,\n到 1980 年代早期\n\nthe cost of a basic computer had fallen to the point where individual people could afford one,\n计算机的价格 降到普通人买得起  \\N 这些叫\"个人电脑\"或\"家庭电脑\"\n\ncalled a personal or home computer.\n计算机的价格 降到普通人买得起  \\N 这些叫\"个人电脑\"或\"家庭电脑\"\n\nThese were much simpler than the big mainframes\n这些电脑比大型主机简单得多 \\N 主机一般在大学，公司和政府\n\nfound at universities, corporations, and governments.\n这些电脑比大型主机简单得多 \\N 主机一般在大学，公司和政府\n\nSo, their operating systems had to be equally simple.\n因此操作系统也得简单\n\nFor example, Microsoft's Disk Operating System, or MS-DOS, was just 160 kilobytes,\n举例，微软的磁盘操作系统（MS-DOS）只有 160 kB \\N 一张磁盘就可以容纳\n\nallowing it to fit, as the name suggests, onto a single disk.\n举例，微软的磁盘操作系统（MS-DOS）只有 160 kB \\N 一张磁盘就可以容纳\n\nFirst released in 1981, it became the most popular OS for early home computers,\n于 1981 年发布，成为早期家用电脑最受欢迎的操作系统\n\neven though it lacked multitasking and protected memory.\n虽然缺少\"多任务\"和\"保护内存\"这样功能\n\nThis meant that programs could,\n意味着程序经常使系统崩溃\n\nand would, regularly crash the system.\n意味着程序经常使系统崩溃\n\nWhile annoying, it was an acceptable tradeoff,\n虽然很讨厌但还可以接受，因为用户可以重启\n\nas users could just turn their own computers off and on again!\n虽然很讨厌但还可以接受，因为用户可以重启\n\nEven early versions of Windows,\n哪怕是微软 1985 年发布的早期 Windows \\N 虽然在 90 年代很流行\n\nfirst released by Microsoft in 1985  and which dominated the OS scene throughout the 1990s,\n哪怕是微软 1985 年发布的早期 Windows \\N 虽然在 90 年代很流行\n\nlacked strong memory protection.\n但却缺乏\"内存保护\"\n\nWhen programs misbehaved,\n当程序行为不当时，就会\"蓝屏\"\n\nyou could get the blue screen of death,\n当程序行为不当时，就会\"蓝屏\"\n\na sign that a program had crashed so badly that it took down the whole operating system.\n代表程序崩溃的非常严重，把系统也带崩溃了\n\nLuckily, newer versions of Windows have better protections and usually don't crash that often.\n幸运的是，新版Windows有更好的保护，不会经常崩溃\n\nToday, computers run modern operating systems,\n如今的计算机 有现代操作系统\n\nlike Mac OS X, Windows 10, Linux, iOS and Android.\n比如 Mac OS X，Windows 10 \\NLinux，iOS和Android\n\nEven though the computers we own are most often used by just a single person,\n虽然大部分设备只有一个人使用\n\nyou!\n你！\n\ntheir OS all have multitasking and virtual and protected memory.\n操作系统依然有\"多任务, \"虚拟内存\", \"内存保护\"\n\nSo, they can run many programs at once:\n因此可以同时运行多个程序：\n\nyou can watch YouTube in your web browser,\n一边在浏览器看 YouTube，一边在 Photoshop 修图\n\nedit a photo in Photoshop,\n一边在浏览器看 YouTube，一边在 Photoshop 修图\n\nplay music in Spotify and sync Dropbox all at the same time.\n用 Spotify 放音乐，同步 Dropbox\n\nThis wouldn't be possible without those decades of research and development on Operating Systems,\n如果没有操作系统这几十年的发展，这些都不可能,\n\nand of course the proper memory to store those programs.\n当然，我们也需要地方放程序\n\nWhich we'll get to next week.\n下周会讨论\n\nHi, I'm Carrie Anne, and welcome to Crash Course Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nWe've talked about computer memory several times in this series,\n系列中 我们多次谈到内存（Memory）\n\nand we even designed some in Episode 6.\n甚至在第 6 集设计了一个简单内存\n\nIn general, computer memory is non-permanent.\n一般来说，电脑内存是 \"非永久性\"\n\nIf your xbox accidently gets unplugged and turns off,\n如果 Xbox 电源线不小心拔掉了，内存里所有数据都会丢失\n\nany data saved in memory is lost.\n如果 Xbox 电源线不小心拔掉了，内存里所有数据都会丢失\n\nFor this reason, it's called volatile memory.\n所以内存叫\"易失性\"存储器\n\nWhat we haven't talked so much about this series is storage,\n我们还没谈过的话题  是存储器（Storage）\n\nwhich is a tad different.\n存储器（Storage）和内存（Memory）有点不同\n\nAny data written to storage, like your hard drive,\n任何写入\"存储器\"的数据，比如你的硬盘 \\N 数据会一直存着，直到被覆盖或删除，断电也不会丢失\n\nwill stay there until it's over-written or deleted, even if the power goes out.\n任何写入\"存储器\"的数据，比如你的硬盘 \\N 数据会一直存着，直到被覆盖或删除，断电也不会丢失\n\nIt's non-volatile.\n存储器是\"非易失性\"的\n\nIt used to be that volatile memory was fast and non-volatile storage was slow,\n以前是\"易失性\"的速度快，\"非易失性\"的速度慢\n\nbut as computing technologies have improved, this distinction is becoming less true,\n但随着技术发展，两者的差异越来越小\n\nand the terms have started to blend together.\n但随着技术发展，两者的差异越来越小\n\nNowadays, we take for granted technologies like this little USB stick,\n如今我们认为稀松平常的技术，比如这个 U 盘\n\nwhich offers gigabytes of memory, reliable over long periods of time, all at low cost,\n能低成本+可靠+长时间  存储上 GB 的数据\n\nbut this wasn't always true.\n但以前可不是这样的\n\nThe earliest computer storage was paper punch cards,\n最早的存储介质是 打孔纸卡 \\N 以及纸卡的亲戚    打孔纸带\n\nand its close cousin, punched paper tape.\n最早的存储介质是 打孔纸卡 \\N 以及纸卡的亲戚    打孔纸带\n\nBy the 1940s, punch cards had largely standardized into a grid of 80 columns and 12 rows,\n到1940年代，纸卡标准是 80列x12行\n\nallowing for a maximum of 960 bits of data to be stored on a single card.\n一张卡能存 960 位数据 (80x12=960)\n\nThe largest program ever punched onto cards, that we know of,\n据我们所知的  最大纸卡程序\n\nwas the US Military's Semi-Automatic Ground Environment, or SAGE,\n是美国军方的\"半自动地面防空系统\" 简称 SAGE\n\nan Air Defense System that became operational in 1958.\n一个在 1958 年投入使用的防空系统\n\nThe main program was stored on 62,500 punchcards,\n主程序存储在 62,500 个纸卡上\n\nroughly equivalent to 5 megabytes of data,\n大小 5MB 左右, 相当如今手机拍张照\n\nthat's the size of an average smartphone photo today.\n大小 5MB 左右, 相当如今手机拍张照\n\nPunch cards were a useful and popular form of storage for decades,\n纸卡用了十几年，因为不用电而且便宜耐用\n\nthey didn't need power, plus paper was cheap and reasonably durable.\n纸卡用了十几年，因为不用电而且便宜耐用\n\nHowever, punchcards were slow and write-once,\n然而坏处是读取慢，只能写入一次\n\nyou can't easily un-punch a hole.\n打的孔无法轻易补上\n\nSo they were a less useful form of memory,\n对于存临时值，纸卡不好用\n\nwhere a value might only be needed for a fraction of a second during a program's execution,\n对于存临时值，纸卡不好用\n\nand then discarded.\n对于存临时值，纸卡不好用\n\nA faster, larger and more flexible form of computer memory was needed.\n我们需要更快更大更灵活的存储方式\n\nAn early and practical approach was developed by J. Presper Eckert,\nJ. Presper Eckert 在 1944 年建造 ENIAC 时发明了一种方法\n\nas he was finishing work on ENIAC in 1944.\nJ. Presper Eckert 在 1944 年建造 ENIAC 时发明了一种方法\n\nHis invention was called Delay Line Memory, and it worked like this.\n叫\"延迟线存储器\"（Delay Line Memory）原理如下\n\nYou take a tube and fill it with a liquid, like mercury.\n拿一个管子装满液体，如水银\n\nThen, you put a speaker at one end and microphone at the other.\n管子一端放扬声器，另一端放麦克风\n\nWhen you pulse the speaker, it creates a pressure wave.\n扬声器发出脉冲时  会产生压力波\n\nThis takes time to propagate to the other end of the tube,\n压力波需要时间  传播到另一端的麦克风\n\nwhere it hits the microphone,\n压力波需要时间  传播到另一端的麦克风\n\nconverting it back into an electrical signal.\n麦克风将压力波 转换回电信号.\n\nAnd we can use this propagation delay to store data!\n我们可以用压力波的传播延迟  来存储数据！\n\nImagine that the presence of a pressure wave is a 1\n假设有压力波代表 1，没有代表 0\n\nand the absence of a pressure wave is a 0.\n假设有压力波代表 1，没有代表 0\n\nOur speaker can output a binary sequence like 1010 0111.\n扬声器可以输出 1​​010 0111\n\nThe corresponding waves will travel down the tube, in order,\n压力波沿管子传播，过了一会儿，撞上麦克风，\n\nand a little while later, hit the microphone,\n压力波沿管子传播，过了一会儿，撞上麦克风，\n\nwhich converts the signal back into 1's and 0's.\n将信号转换回 1 和 0\n\nIf we create a circuit that connects the microphone to the speaker,\n如果加一个电路，连接麦克风和扬声器\n\nplus a little amplifier to compensate for any loss,\n再加一个放大器（Amplifier）来弥补信号衰弱\n\nwe can create a loop that stores data.\n就能做一个存储数据的循环\n\nThe signal traveling along the wire is near instantaneous,\n信号沿电线传播几乎是瞬时的,\n\nso there's only ever one bit of data showing at any moment in time.\n所以任何时间点只显示  1 bit 数据\n\nBut in the tube, you can store many bits!\n但管子中可以存储多个位(bit)\n\nAfter working on ENIAC, Eckert and his colleague John Mauchly,\n忙完 ENIAC 后，Eckert 和同事 John Mauchly\n\nset out to build a bigger and better computer called EDVAC, incorporating Delay Line Memory.\n着手做一个更大更好的计算机叫 EDVAC，使用了延迟线存储器\n\nIn total, the computer had 128 Delay Lines,\n总共有 128 条延迟线，每条能存 352 位（bits）\n\neach capable of storing 352 bits.\n总共有 128 条延迟线，每条能存 352 位（bits）\n\nThat's a grand total of 45 thousands bits of memory,\n总共能存 45,000 位(bit)\n\nnot too shabby for 1949!\n对 1949 年来说还不错！\n\nThis allowed EDVAC to be one of the very earliest Stored-Program Computers,\n这使得 EDVAC 成为最早的 \"存储程序计算机\" 之一\n\nwhich we talked about in Episode 10.\n我们在第 10 集讨论过\n\nHowever, a big drawback with delay line memory\n但\"延迟线存储器\"的一大缺点是\n\nis that you could only read one bit of data from a tube at any given instant.\n每一个时刻只能读一位 (bit) 数据\n\nIf you wanted to access a specific bit, like bit 112,\n如果想访问一个特定的 bit，比如第 112 位(bit) \\N 你得等待它从循环中出现\n\nyou'd have to wait for it to come around in the loop,\n如果想访问一个特定的 bit，比如第 112 位(bit) \\N 你得等待它从循环中出现\n\nwhat's called sequential or cyclic-access memory,\n所以又叫 \"顺序存储器\"或\"循环存储器\"\n\nwhereas we really want random access memory,\n而我们想要的是 \"随机存取存储器\" \\N 可以随时访问任何位置\n\nwhere we can access any bit at any time.\n而我们想要的是 \"随机存取存储器\" \\N 可以随时访问任何位置\n\nIt also proved challenging to increase the density of the memory,\n增加内存密度也是一个挑战\n\npacking waves closer together meant they were more easily mixed up.\n把压力波变得更紧密  意味着更容易混在一起\n\nIn response, new forms of delay line memory were invented,\n所以出现了其他类型的 \"延迟线存储器\"\n\nsuch as magnetostrictive delay lines .\n如 \"磁致伸缩延迟存储器\"\n\nThese delay lines use a metal wire that could be twisted,\n用金属线的振动来代表数据\n\ncreating little torsional waves that represented data.\n用金属线的振动来代表数据\n\nBy forming the wire into a coil, you could store around 1000 bits in a 1 foot by 1 foot square.\n通过把线卷成线圈，1英尺×1英尺的面积能存储大概 1000位(bit)\n\nHowever, delay line memory was largely obsolete by the mid 1950s,\n然而，延迟线存储器在 1950 年代中期就基本过时了\n\nsurpassed in performance, reliability and cost by a new kid on the block:\n因为出现了新技术，性能,可靠性和成本都更好\n\nmagnetic core memory which was constructed out of little magnetic donuts,\n\"磁芯存储器\"，用了像甜甜圈的小型磁圈\n\ncalled cores.\n\"磁芯存储器\"，用了像甜甜圈的小型磁圈\n\nIf you loop a wire around this core.\n如果给磁芯绕上电线，并施加电流，可以将磁化在一个方向\n\nand run an electrical current through the wire,\n如果给磁芯绕上电线，并施加电流，可以将磁化在一个方向\n\nwe can magnetize the core in a certain direction.\n如果给磁芯绕上电线，并施加电流，可以将磁化在一个方向\n\nIf we turn the current off, the core will stay magnetized.\n如果关掉电流，磁芯保持磁化\n\nIf we pass current through the wire in the opposite direction,\n如果沿相反方向施加电流\n\nthe magnetization direction, called polarity,\n磁化的方向（极性）会翻转\n\nflips the other way.\n磁化的方向（极性）会翻转\n\nIn this way, we can store 1's and 0's!\n这样就可以存 1 和 0！\n\n1 bit of memory isn't very useful, so these little donuts were arranged into grids.\n如果只存 1 位不够有用，所以把小甜甜圈排列成网格\n\nThere were wires for selecting the right row and column, and a wire that ran through every core,\n有电线负责选行和列 \\N 也有电线贯穿每个磁芯, 用于读写一位(bit)\n\nwhich could be used to read or write a bit.\n有电线负责选行和列 \\N 也有电线贯穿每个磁芯, 用于读写一位(bit)\n\nHere is an actual piece of core memory!\n我手上有一块磁芯存储器\n\nIn each of these little yellow squares, there are 32 rows and 32 columns of tiny cores,\n每个黄色方格  有32行x32列的磁芯 \\N 每个磁芯存 1 位数据\n\neach one holding 1 bit of data.\n每个黄色方格  有32行x32列的磁芯 \\N 每个磁芯存 1 位数据\n\nSo, each of these yellow squares could hold 1024 bits.\n所以能存 1024 位(bit)  (32x32=1024)\n\nIn total, there are 9 of these,\n总共 9 个黄色方格\n\nso this memory board could hold a maximum of 9216 bits,\n所以这块板子最多能存 9216 位(bit) (1024x9=9216)\n\nwhich is around 9 kilobytes.\n换算过来大约是 9 千字节 \\N (9216 bit ~= 9 kb)\n\nThe first big use of core memory was MIT's Whirlwind 1 computer, in 1953,\n磁芯内存的第一次大规模运用\\N 是 1953 年麻省理工学院的 Whirlwind 1 计算机\n\nwhich used a 32 by 32 core arrangement.\n磁芯排列是 32×32\n\nAnd, instead of just a single plane of cores, like this,\n用了 16 块板子，能存储大约 16000 位(bit)\n\nit was 16 boards deep, providing roughly 16 thousand bits of storage.\n用了 16 块板子，能存储大约 16000 位(bit)\n\nImportantly, unlike delay line memory,\n更重要的是，不像\"延迟线存储器\" \\N 磁芯存储器能随时访问任何一位(bit)\n\nany bit could be accessed at any time.\n更重要的是，不像\"延迟线存储器\" \\N 磁芯存储器能随时访问任何一位(bit)\n\nThis was a killer feature,\n这在当时非常了不起\n\nand magnetic core memory became the predominant Random Access Memory technology\n\"磁芯存储器\" 从 1950 年代中期开始成为主流 \\N 流行了 20 多年\n\nfor two decades, beginning in the mid 1950\n\"磁芯存储器\" 从 1950 年代中期开始成为主流 \\N 流行了 20 多年\n\neven though it was typically woven by hand!\n而且一般还是手工编织的！\n\nAlthough starting at roughly 1 dollar per bit,\n刚开始时  存储成本大约 1 美元 1 位(bit) \\N 到1970年代，下降到 1 美分左右\n\nthe cost fell to around 1 cent per bit by the 1970s.\n刚开始时  存储成本大约 1 美元 1 位(bit) \\N 到1970年代，下降到 1 美分左右\n\nUnfortunately, even 1 cent per bit isn't cheap enough for storage.\n不幸的是，即使每位 1 美分也不够便宜\n\nAs previously mentioned,\n之前提过，现代手机随便拍张照片都有 5 MB\n\nan average smartphone photo is around 5 megabytes in size,\n之前提过，现代手机随便拍张照片都有 5 MB\n\nthat's roughly 40 million bits.\n5MB 约等于 4000 万 bit\n\nWould you pay 4 hundred thousand dollars to store a photo on core memory?\n你愿意花 40 万美元在\"磁芯存储器\"上存照片吗？\n\nIf you have that kind of money to drop,\n如果你有这么多钱\n\ndid you know that Crash Course is on Patreon?\n你知道 Crash Course 在 Patreon 有赞助页吗？\n\nRight? Wink wink.\n对吧？你懂的\n\nAnyway, there was tremendous research into storage technologies happening at this time.\n总之，当时对存储技术进行了大量的研究\n\nBy 1951, Eckert and Mauchly had started their own company,\n到 1951 年，Eckert 和 Mauchly 创立了自己的公司\n\nand designed a new computer called UNIVAC,\n设计了一台叫 UNIVAC 的新电脑\n\none of the earliest commercially sold computers.\n最早进行商业销售的电脑之一\n\nIt debuted with a new form of computer storage:\n它推出了一种新存储：磁带\n\nmagnetic tape.\n它推出了一种新存储：磁带\n\nThis was a long, thin and flexible strip of magnetic material, stored in reels.\n磁带是纤薄柔软的一长条磁性带子  卷在轴上\n\nThe tape could be moved forwards or backwards inside of a machine called a tape drive.\n磁带可以在\"磁带驱动器\"内前后移动\n\nInside is a write head,\n里面有一个\"写头\"绕了电线，电流通过产生磁场\n\nwhich passes current through a wound wire to generate a magnetic field,\n里面有一个\"写头\"绕了电线，电流通过产生磁场\n\ncausing a small section of the tape to become magnetized.\n导致磁带的一小部分被磁化\n\nThe direction of the current sets the polarity, again, perfect for storing 1's and 0's.\n电流方向决定了极性，代表 1 和 0\n\nThere was also a separate read head could detect the polarity non-destructively.\n还有一个\"读头\"，可以非破坏性地检测极性\n\nThe UNIVAC used half-inch-wide tape with 8 parallel data tracks,\nUNIVAC 用了半英寸宽，8条并行的磁带\n\neach able to store 128 bits of data per inch.\n磁带每英寸可存 128 位数据\n\nWith each reel containing 1200 feet of tape,\n每卷有 1200 英尺长\n\nit meant you could store roughly 15 million bits\n意味着一共可以存 1500 万位左右\n\n- that's almost 2 megabytes!\n- 接近2兆字节！（2 MB）\n\nAlthough tape drives were expensive,\n虽然磁带驱动器很贵，但磁带又便宜又小\n\nthe magnetic tape itself was cheap and compact,\n虽然磁带驱动器很贵，但磁带又便宜又小\n\nand for this reason, they're still used today for archiving data.\n因此磁带至今仍用于存档\n\nThe main drawback is access speed.\n磁带的主要缺点是访问速度\n\nTape is inherently sequential,\n磁带是连续的，必须倒带或快进到达特定位置\n\nyou have to rewind or fast-forward to get to data you want.\n磁带是连续的，必须倒带或快进到达特定位置\n\nThis might mean traversing hundreds of feet of tape to retrieve a single byte,\n可能要几百英尺才能得到某个字节(byte)，这很慢\n\nwhich is slow.\n可能要几百英尺才能得到某个字节(byte)，这很慢\n\nA related popular technology in the 1950s and 60s was Magnetic Drum Memory.\n1950,60年代，有个类似技术是 \"磁鼓存储器\"\n\nThis was a metal cylinder - called a drum - coated in a magnetic material for recording data\n有金属圆筒，盖满了磁性材料以记录数据\n\nThe drum was rotated continuously,\n滚筒会持续旋转，周围有数十个读写头\n\nand positioned along its length were dozens of read and write heads.\n滚筒会持续旋转，周围有数十个读写头\n\nThese would wait for the right spot to rotate underneath them to read or write a bit of data.\n等滚筒转到正确的位置\\N 读写头会读或写 1 位(bit) 数据\n\nTo keep this delay as short as possible,\n为了尽可能缩短延迟, 鼓轮每分钟上千转！\n\ndrums were rotated thousand of revolutions per minute!\n为了尽可能缩短延迟, 鼓轮每分钟上千转！\n\nBy 1953, when the technology started to take off,\n到 1953 年，磁鼓技术飞速发展 \\N 可以买到存 80,000 位的\"磁鼓存储器\"\n\nyou could buy units able to record 80,000 bits of data\n到 1953 年，磁鼓技术飞速发展 \\N 可以买到存 80,000 位的\"磁鼓存储器\"\n\n- that's 10 kilobytes,\n- 也就是 10 KB\n\nbut the manufacture of drums ceased in the 1970s.\n但到 1970 年代 \"磁鼓存储器\" 不再生产\n\nHowever, Magnetic Drums did directly lead to the development of Hard Disk Drives,\n然而，磁鼓导致了硬盘的发展 \\N 硬盘和磁鼓很相似\n\nwhich are very similar, but use a different geometric configuration.\n然而，磁鼓导致了硬盘的发展 \\N 硬盘和磁鼓很相似\n\nInstead of large cylinder, hard disks use,\n不过硬盘用的是盘，不像磁鼓用圆柱体，因此得名\n\nwell disks that are hard.\n不过硬盘用的是盘，不像磁鼓用圆柱体，因此得名\n\nHence the name!\n不过硬盘用的是盘，不像磁鼓用圆柱体，因此得名\n\nThe storage principle is the same,\n原理是一样的，磁盘表面有磁性\n\nthe surface of a disk is magnetic,\n原理是一样的，磁盘表面有磁性\n\nallowing write and read heads to store and retrieve 1's and 0's.\n写入头和读取头  可以处理上面的 1 和 0\n\nThe great thing about disks is that they are thin,\n硬盘的好处是薄，可以叠在一起\n\nso you can stack many of them together,\n硬盘的好处是薄，可以叠在一起\n\nproviding a lot of surface area for data storage.\n提供更多表面积来存数据\n\nThat's exactly what IBM did for the world's first computer with a disk drive:\nIBM 对世上第一台磁盘计算机就是这样做的\n\nthe RAMAC 305.\nRAMAC 305\n\nSweet name BTW.\n顺便一说名字不错\n\nIt contained fifty, 24-inch diameter disks,\n它有 50 张 24 英寸直径的磁盘，总共能存 5 MB 左右\n\noffering a total storage capacity of roughly 5 megabytes.\n它有 50 张 24 英寸直径的磁盘，总共能存 5 MB 左右\n\nYess!! We've finally gotten to a technology that can store a single smartphone photo!\n太棒啦! 终于能存一张现代手机的照片了！这年是 1956 年\n\nThe year was 1956.\n太棒啦! 终于能存一张现代手机的照片了！这年是 1956 年\n\nTo access any bit of data,\n要访问某个特定 bit\n\na read/write head would travel up or down the stack to the right disk,\n一个读/写磁头会向上或向下移动，找到正确的磁盘\n\nand then slide in between them.\n然后磁头会滑进去\n\nLike drum memory, the disks are spinning,\n就像磁鼓存储器一样，磁盘也会高速旋转\n\nso the head has to wait for the right section to come around.\n所以读写头要等到正确的部分转过来\n\nThe RAMAC 305 could access any block of data, on average, in around 6/10ths of a second,\nRAMAC 305 访问任意数据，平均只要六分之一秒左右\n\nwhat's called the seek time.\n也叫寻道时间\n\nWhile great for storage, this was not nearly fast enough for memory,\n虽然六分之一秒对存储器来说算不错 \\N 但对内存来说还不够快\n\nso the RAMAC 305 also had drum memory and magnetic core memory.\n所以 RAMAC 305 还有\"磁鼓存储器\"和\"磁芯存储器\"\n\nThis is an example of a memory hierarchy,\n这是\"内存层次结构\"的一个例子\n\nwhere you have a little bit of fast memory, which is expensive,\n一小部分高速+昂贵的内存\n\nslightly more medium-speed memory, which is less expensive,\n一部分稍慢+相对便宜些的内存\n\nand then a lot of slowish memory, which is cheap.\n还有更慢+更便宜的内存\n\nThis mixed approach strikes a balance between cost and speed.\n这种混合  在成本和速度间取得平衡\n\nHard disk drives rapidly improved and became commonplace by the 1970s.\n1970 年代，硬盘大幅度改进并变得普遍\n\nA hard disk like this can easily hold 1 terabyte of data today\n如今的硬盘可以轻易容纳 1TB 的数据\n\n- that's a trillion bytes - or roughly 200,000 five megabyte photos!\n能存 20 万张 5MB 的照片！\n\nAnd these types of drives can be bought online for as little as 40 US dollars.\n网上最低 40 美元就可以买到\n\nThat's 0.0000000005 cents per bit.\n每 bit 成本 0.0000000005 美分\n\nA huge improvement over core memory's 1 cent per bit!\n比磁芯内存 1 美分 1 bit 好多了！\n\nAlso, modern drives have an average seek time of under 1/100th of a second.\n另外，现代硬盘的平均寻道时间低于 1/100 秒\n\nI should also briefly mention a close cousin of hard disks, the floppy disk,\n我简单地提一下硬盘的亲戚，软盘\n\nwhich is basically the same thing, but uses a magnetic medium that's, floppy.\n除了磁盘是软的，其他基本一样\n\nYou might recognise it as the save icon on some of your applications,\n你可能见过某些程序的保存图标是一个软盘\n\nbut it was once a real physical object!\n软盘曾经是真实存在的东西！\n\nIt was most commonly used for portable storage,\n软盘是为了便携，在 1970~1990 非常流行\n\nand became near ubiquitous from the mid 1970s up to the mid 90s.\n软盘是为了便携，在 1970~1990 非常流行\n\nAnd today it makes a pretty good coaster.\n如今当杯垫挺不错的\n\nHigher density floppy disks, like Zip Disks,\n密度更高的软盘，如 Zip Disks，在90年代中期流行起来\n\nbecame popular in the mid 1990s,\n密度更高的软盘，如 Zip Disks，在90年代中期流行起来\n\nbut fell out of favor within a decade.\n但十年内就消失了\n\nOptical storage came onto the scene in 1972, in the form of a 12-inch \"laser disc.\"\n光学存储器于 1972 年出现，12 英寸的\"激光盘\"\n\nHowever, you are probably more familiar with its later, smaller, are more popular cousin,\n你可能对后来的产品更熟：光盘（简称 CD）\n\nthe Compact Disk, or CD,\n你可能对后来的产品更熟：光盘（简称 CD）\n\nas well as the DVD which took off in the 90s.\n以及 90 年代流行的 DVD\n\nFunctionally, these technologies are pretty similar to hard disks and floppy disks,\n功能和硬盘软盘一样，都是存数据.\n\nbut instead of storing data magnetically,\n但用的不是磁性\n\noptical disks have little physical divots in their surface that cause light to be reflected differently,\n光盘表面有很多小坑，造成光的不同反射\n\nwhich is captured by an optical sensor, and decoded into 1's and 0's.\n光学传感器会捕获到，并解码为 1 和 0\n\nHowever, today, things are moving to solid state technologies, with no moving parts,\n如今，存储技术在朝固态前进，没有机械活动部件\n\nlike this hard drive and also this USB stick.\n比如这个硬盘，以及 U 盘\n\nInside are Integrated Circuits,\n里面是集成电路，我们在第 15 集讨论过\n\nwhich we talked about in Episode 15.\n里面是集成电路，我们在第 15 集讨论过\n\nThe first RAM integrated circuits became available in 1972 at 1 cent per bit,\n第一个 RAM 集成电路出现于 1972 年 \\N 成本每比特 1 美分\n\nquickly making magnetic core memory obsolete.\n使\"磁芯存储器\"迅速过时\n\nToday, costs have fallen so far,\n如今成本下降了更多 \\N 机械硬盘 被 固态硬盘 逐渐替代，简称 SSD\n\nthat hard disk drives are being replaced with non-volatile,\n如今成本下降了更多 \\N 机械硬盘 被 固态硬盘 逐渐替代，简称 SSD\n\nSolid State Drives, or SSDs, as the cool kids say.\n如今成本下降了更多 \\N 机械硬盘 被 固态硬盘 逐渐替代，简称 SSD\n\nBecause they contain no moving parts,\n由于 SSD 没有移动部件\n\nthey don't really have to seek anywhere,\n磁头不用等磁盘转\n\nso SSD access times are typically under 1/1000th of a second.\n所以 SSD 访问时间低于 1/1000 秒\n\nThat's fast!\n这很快！\n\nBut it's still many times slower than your computer's RAM.\n但还是比 RAM 慢很多倍\n\nFor this reason, computers today still use memory hierarchies.\n所以现代计算机 仍然用存储层次结构\n\nSo, we've come along way since the 1940s.\n我们从 1940 年代到现在进步巨大\n\nMuch like transistor count and Moore's law,\n就像在第 14 集讨论过的  晶体管数量和摩尔定律\n\nwhich we talked about in Episode 14,\n就像在第 14 集讨论过的  晶体管数量和摩尔定律\n\nmemory and storage technologies have followed a similar exponential trend.\n内存和存储技术也有类似的趋势\n\nFrom early core memory costing millions of dollars per megabyte, we're steadily fallen,\n从早期每 MB 成本上百万美元，下滑到\n\nto mere cents by 2000, and only fractions of a cent today.\n2000 年只要几分钱，如今远远低于 1 分钱\n\nPlus, there's WAY less punch cards to keep track of.\n完全没有打孔纸卡\n\nSeriously, can you imagine if there was a slight breeze in that room containing the SAGE program?\n你能想象 SEGA 的纸卡房间风一吹会怎样吗？\n\n62,500 punch cards.\n62,500 张卡\n\nI don't even want to think about it.\n我想都不敢想\n\nI'll see you next week.\n我们下周见\n\nHi, I'm Carrie Anne, and welcome to Crash Course Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nLast episode we talked about data storage, how technologies like magnetic tape and hard\n上集我们讲了数据存储，磁带和硬盘这样的技术\n\ndisks can store trillions of bits of data,\n可以在断电状态长时间存上万亿个位\n\nfor long durations, even without power.\n可以在断电状态长时间存上万亿个位\n\nWhich is perfect for recording \"big blobs\" of related data,\n非常合适存一整块有关系的数据，或者说\"文件\"\n\nwhat are more commonly called computer files.\n非常合适存一整块有关系的数据，或者说\"文件\"\n\nYou've no doubt encountered many types,\n你肯定见过很多种文件 \\N 比如文本文件，音乐文件，照片和视频\n\nlike text files, music files, photos and videos.\n你肯定见过很多种文件 \\N 比如文本文件，音乐文件，照片和视频\n\nToday, we're going to talk about how files work,\n今天，我们要讨论文件到底是什么 \\N 以及计算机怎么管理文件\n\nand how computers keep them all organized with File Systems.\n今天，我们要讨论文件到底是什么 \\N 以及计算机怎么管理文件\n\nIt's perfectly legal for a file to contain arbitrary, unformatted data,\n随意排列文件数据完全没问题，但按格式排会更好\n\nbut it's most useful and practical if the data inside the file is organized somehow.\n随意排列文件数据完全没问题，但按格式排会更好\n\nThis is called a file format.\n这叫 \"文件格式\"\n\nYou can invent your own, and programmers do that from time to time,\n你可以发明自己的文件格式，程序员偶尔会这样做\n\nbut it's usually best and easiest to use an existing standard, like JPEG and MP3.\n但最好用现成标准，比如 JPEG 和 MP3\n\nLet's look at some simple file formats.\n来看一些简单文件格式，最简单的是文本文件\n\nThe most straightforward are text files,\n来看一些简单文件格式，最简单的是文本文件\n\nalso know as TXT file, which contain...surprise! text.\n也叫 TXT 文件, 里面包含的是... 文字 （惊喜吧）\n\nLike all computer files, this is just a huge list of numbers, stored as binary.\n就像所有其它文件，文本文件只是一长串二进制数\n\nIf we look at the raw values of a text file in storage, it would look something like this:\n原始值看起来会像这样：\n\nWe can view this as decimal numbers instead of binary,\n可以转成十进制看，但帮助不大\n\nbut that still doesn't help us read the text.\n可以转成十进制看，但帮助不大\n\nThe key to interpreting this data is knowing that TXT files use ASCII,\n解码数据的关键是 ASCII 编码\n\na character encoding standard we discussed way back in Episode 4.\n一种字符编码标准，第 4 集讨论过.\n\nSo, in ASCII, our first value, 72, maps to the capital letter H.\n第一个值 72 \\N 在 ASCII 中是大写字母 H\n\nAnd in this way, we decode the whole file.\n以此类推 解码其他数字\n\nLet's look at a more complicated example: a WAVE File, also called a WAV,\n来看一个更复杂的例子：波形(Wave)文件，也叫 WAV \\N 它存音频数据\n\nwhich stores audio.\n来看一个更复杂的例子：波形(Wave)文件，也叫 WAV \\N 它存音频数据\n\nBefore we can correctly read the data, we need to know some information,\n在正确读取数据前，需要知道一些信息\n\nlike the bit rate and whether it's a single track or stereo.\n比如码率(bit rate)，以及是单声道还是立体声\n\nData about data, is called meta data.\n关于数据的数据，叫\"元数据\"(meta data)\n\nThis metadata is stored at the front of the file, ahead of any actual data,\n元数据存在文件开头，在实际数据前面 \\N 因此也叫 文件头(Header)\n\nin what's known as a Header.\n元数据存在文件开头，在实际数据前面 \\N 因此也叫 文件头(Header)\n\nHere's what the first 44 bytes of a WAV file looks like.\nWAV 文件的前 44 个字节长这样\n\nSome parts are always the same, like where it spells out W-A-V-E.\n有的部分总是一样的，比如写着 WAVE 的部分\n\nOther parts contain numbers that change depending on the data contained within.\n其他部分的内容，会根据数据变化\n\nThe audio data comes right behind the metadata, and it's stored as a long list of numbers.\n音频数据紧跟在元数据后面，是一长串数字\n\nThese values represent the amplitude of sound captured many times per second, and if you\n数字代表每秒捕获多次的声音幅度\n\nwant a primer on sound, check out our video all about it in Crash Course Physics.\n如果想学声音的基础知识 \\N 可以看物理速成课第18集\n\nLink in the dobblydoo.\n如果想学声音的基础知识 \\N 可以看物理速成课第18集\n\nAs an example, let's look at a waveform of me saying: \"hello!\" Hello!\n举个例子，看一下\"你好\"的波形\n\nNow that we've captured some sound, let's zoom into a little snippet.\n现在捕获到了一些声音，我们放大看一下\n\nA digital microphone, like the one in your computer or smartphone,\n电脑和手机麦克风，每秒可以对声音进行上千次采样\n\nsamples the sound pressure thousands of times.\n电脑和手机麦克风，每秒可以对声音进行上千次采样\n\nEach sample can be represented as a number.\n每次采样可以用一个数字表示\n\nLarger numbers mean higher sound pressure, what's called amplitude.\n声压越高数字越大，也叫\"振幅\"\n\nAnd these numbers are exactly what gets stored in a WAVE file!\nWAVE 文件里存的就是这些数据！\n\nThousands of amplitudes for every single second of audio!\n每秒上千次的振幅！\n\nWhen it's time to play this file, an audio program needs to actuate the computer's speakers\n播放声音文件时，扬声器会产生相同的波形\n\nsuch that the original waveform is emitted.\n播放声音文件时，扬声器会产生相同的波形\n\n\"Hello!\"\n\"你好！\"\n\nSo, now that you're getting the hang of file formats, let's talk about bitmaps or\n现在来谈谈 位图(Bitmap)，后缀 .bmp, 它存图片\n\nBMP, which store pictures.\n现在来谈谈 位图(Bitmap)，后缀 .bmp, 它存图片\n\nOn a computer, Pictures are made up of little tiny square elements called pixels.\n计算机上，图片由很多个叫\"像素\"的方块组成\n\nEach pixel is a combination of three colors: red, green and blue.\n每个像素由三种颜色组成：红，绿，蓝\n\nThese are called additive primary colors, and they can be mixed together to create any\n叫\"加色三原色\"，混在一起可以创造其它颜色\n\nother color on our electronic displays.\n叫\"加色三原色\"，混在一起可以创造其它颜色\n\nNow, just like WAV files, BMPs start with metadata,\n就像 WAV 文件一样，BMP 文件开头也是元数据 \\N 有图片宽度，图片高度，颜色深度\n\nincluding key values like image width, image height, and color depth.\n就像 WAV 文件一样，BMP 文件开头也是元数据 \\N 有图片宽度，图片高度，颜色深度\n\nAs an example, let's say the metadata specified an image 4 pixels wide, by 4 pixels tall,\n举例，假设元数据说图是 4像素宽 x 4像素高\n\nwith a 24-bit color depth - that's 8-bits for red, 8-bits for green, and 8-bits for blue.\n颜色深度 24 位\\N  8 位红色，8 位绿色，8 位蓝色\n\nAs a reminder, 8 bits is the same as one byte.\n提醒一下，8位 (bit) 和 1字节(byte)是一回事\n\nThe smallest number a byte can store is 0, and the largest is 255.\n一个字节能表示的最小数是 0，最大 255\n\nOur image data is going to look something like this:\n图像数据看起来会类似这样：\\N 来看看第一个像素的颜色\n\nLet's look at the color of our first pixel.\n图像数据看起来会类似这样：\\N 来看看第一个像素的颜色\n\nIt has 255 for its red value, 255 for green and 255 for blue.\n红色是255，绿色是255，蓝色也是255\n\nThis equates to full intensity red, full intensity green and full intensity blue.\n这等同于全强度红色，全强度绿色和全强度蓝色\n\nThese colors blend together on your computer monitor to become white.\n混合在一起变成白色\n\nSo our first pixel is white!\n所以第一个像素是白色！\n\nThe next pixel has a Red-Green-Blue, or RGB value of 255, 255, 0.\n下一个像素的红绿蓝值，或 RGB 值 \\N  255,255,0 是黄色！\n\nThat's the color yellow!\n下一个像素的红绿蓝值，或 RGB 值 \\N  255,255,0 是黄色！\n\nThe pixel after that has a RGB value of 0,0,0 - that's zero intensity everything, which is black.\n下一个像素是 0,0,0 ，黑色\n\nAnd the next one is yellow.\n下一个是黄色\n\nBecause the metadata specified this was a 4 by 4 image, we know that we've reached\n因为元数据说图片是 4x4 \\N 我们知道现在到了第一行结尾\n\nthe end of our first row of pixels.\n因为元数据说图片是 4x4 \\N 我们知道现在到了第一行结尾\n\nSo, we need to drop down a row.\n所以换一行\n\nThe next RGB value is 255,255,0 yellow again.\n下一个 RGB 值是 255,255,0，又是黄色\n\nOkay, let's go ahead and read all the pixels in our 4x4 image tada!\n好，我们读完剩下的像素\n\nA very low resolution pac-man!\n一个低分辨率的吃豆人\n\nObviously this is a simple example of a small image,\n刚才显然只是一个简单例子，但这张图片也可以用 BMP 存\n\nbut we could just as easily store this image in a BMP.\n刚才显然只是一个简单例子，但这张图片也可以用 BMP 存\n\nI want to emphasize again that it doesn't matter if it's a text file, WAV,\n我想再次强调，不管是文本文件，WAV，BMP\n\nBMP, or fancier formats we don't have time to discuss,\n或是我们没时间讨论的其他格式\n\nUnder the hood, they're all the same: long lists of numbers, stored as binary, on a storage device.\n文件在底层全是一样的： 一长串二进制\n\nFile formats are the key to reading and understanding the data inside.\n为了知道文件是什么，文件格式至关重要\n\nNow that you understand files a little better, let's move on to\n现在你对文件更了解了 \\N 我们接下来讨论计算机怎么存文件\n\nhow computers go about storing them.\n现在你对文件更了解了 \\N 我们接下来讨论计算机怎么存文件\n\nEven though the underlying storage medium might be\n虽然硬件可能是磁带，磁鼓，磁盘或集成电路\n\na strip of tape, a drum, a disk, or integrated circuits...\n虽然硬件可能是磁带，磁鼓，磁盘或集成电路\n\nhardware and software abstractions let us think of storage as a\n通过软硬件抽象后，可以看成一排能存数据的桶\n\nlong line of little buckets that store values.\n通过软硬件抽象后，可以看成一排能存数据的桶\n\nIn the early days, when computers only performed one computation\n在很早期时，计算机只做一件事，比如算火炮射程表 \\N 整个储存器就像一整个文件\n\nlike calculating artillery range tables. the entire storage operated like one big file.\n在很早期时，计算机只做一件事，比如算火炮射程表 \\N 整个储存器就像一整个文件\n\nData started at the beginning of storage, and then filled it up in order as output was\n数据从头存到尾，直到占满\n\nproduced, up to the storage capacity.\n数据从头存到尾，直到占满\n\nHowever, as computational power and storage capacity improved, it became possible, and\n但随着计算能力和存储容量的提高 \\N 存多个文件变得非常有用\n\nuseful, to store more than one file at a time.\n但随着计算能力和存储容量的提高 \\N 存多个文件变得非常有用\n\nThe simplest option is to store files back-to-back.\n最简单的方法  是把文件连续存储\n\nThis can work... but how does the computer know where files begin and end?\n这样能用, \\N 但怎么知道文件开头和结尾在哪里？\n\nStorage devices have no notion of files C they're just a mechanism for storing lots of bits.\n储存器没有文件的概念，只是存储大量位\n\nSo, for this to work, we need to have a special file that records where other ones are located.\n所以为了存多个文件 \\N 需要一个特殊文件，记录其他文件的位置\n\nThis goes by many names, but a good general term is Directory File.\n这个特殊文件有很多名字，这里泛称 \"目录文件\"\n\nMost often, it's kept right at the front of storage, so we always know where to access it.\n这个文件经常存在最开头，方便找\n\nLocation zero!\n位置 0！\n\nInside the Directory File are the names of all the other files in storage.\n目录文件里，存所有其他文件的名字\n\nIn our example, they each have a name, followed by a period\n格式是文件名 + 一个句号 + 扩展名，比如 BMP 或 WAV\n\nand end with what's called a File Extension, like \"BMP\" or \"WAV\".\n格式是文件名 + 一个句号 + 扩展名，比如 BMP 或 WAV\n\nThose further assist programs in identifying file types.\n扩展名帮助得知文件类型\n\nThe Directory File also stores metadata about these files, like when they were created and\n目录文件还存文件的元数据，比如创建时间\n\nlast modified, who the owner is, and if it can be read, written or both.\n最后修改时间，文件所有者是谁\\N是否能读/写  或读写都行\n\nBut most importantly, the directory file contains where these files\n最重要的是，目录文件有文件起始位置和长度\n\nbegin in storage, and how long they are.\n最重要的是，目录文件有文件起始位置和长度\n\nIf we want to add a file, remove a file, change a filename, or similar,\n如果要添加文件，删除文件，更改文件名等\n\nwe have to update the information in the Directory File.\n必须更新目录文件\n\nIt's like the Table of Contents in a book, if you make a chapter shorter, or move it\n就像书的目录，如果缩短或移动了一个章节 \\N 要更新目录，不然页码对不上\n\nsomewhere else, you have to update the table of contents, otherwise the page numbers won't match!\n就像书的目录，如果缩短或移动了一个章节 \\N 要更新目录，不然页码对不上\n\nThe Directory File, and the maintenance of it, is an example of a very basic File System,\n目录文件，以及对目录文件的管理 \\N 是一个非常简单的文件系统例子\n\nthe part of an Operating System that manages and keep track of stored files.\n文件系统专门负责管理文件\n\nThis particular example is a called a Flat File System, because they're all stored at one level.\n刚刚的例子叫\"平面文件系统\" \\N因为文件都在同一个层次\n\nIt's flat!\n平的！\n\nOf course, packing files together, back-to-back, is a bit of a problem,\n当然，把文件前后排在一起  有个问题\n\nbecause if we want to add some data to let's say \"todo.txt\",\n如果给 todo.txt 加一点数据 \\N 会覆盖掉后面 carrie.bmp 的一部分\n\nthere's no room to do it without overwriting part of \"carrie.bmp\".\n如果给 todo.txt 加一点数据 \\N 会覆盖掉后面 carrie.bmp 的一部分\n\nSo modern File Systems do two things.\n所以现代文件系统会做两件事\n\nFirst, they store files in blocks.\n1. 把空间划分成一块块 \\N 导致有一些 \"预留空间\" 可以方便改动\n\nThis leaves a little extra space for changes, called slack space.\n1. 把空间划分成一块块 \\N 导致有一些 \"预留空间\" 可以方便改动\n\nIt also means that all file data is aligned to a common size, which simplifies management.\n同时也方便管理\n\nIn a scheme like this, our Directory File needs to keep track of\n用这样的方案，目录文件要记录文件在哪些块里\n\nwhat block each one is stored in.\n用这样的方案，目录文件要记录文件在哪些块里\n\nThe second thing File Systems do, is allow files to be broken up into chunks\n2. 拆分文件，存在多个块里\n\nand stored across many blocks.\n2. 拆分文件，存在多个块里\n\nSo let's say we open \"todo.txt\", and we add a few more items then the file becomes\n假设打开 todo.txt 加了些内容\\N 文件太大存不进一块里\n\ntoo big to be saved in its one block.\n假设打开 todo.txt 加了些内容\\N 文件太大存不进一块里\n\nWe don't want to overwrite the neighboring one, so instead, the File System allocates\n我们不想覆盖掉隔壁的块，所以文件系统会分配 \\N 一个没使用的块，容纳额外的数据\n\nan unused block, which can accommodate extra data.\n我们不想覆盖掉隔壁的块，所以文件系统会分配 \\N 一个没使用的块，容纳额外的数据\n\nWith a File System scheme like this, the Directory File needs to store\n目录文件会记录不止一个块，而是多个块\n\nnot just one block per file, but rather a list of blocks per file.\n目录文件会记录不止一个块，而是多个块\n\nIn this way, we can have files of variable sizes that can be easily\n只要分配块，文件可以轻松增大缩小\n\nexpanded and shrunk, simply by allocating and deallocating blocks.\n只要分配块，文件可以轻松增大缩小\n\nIf you watched our episode on Operating Systems, this should sound a lot like Virtual Memory.\n如果你看了第18集 操作系统 \\N 这听起来很像\"虚拟内存\"\n\nConceptually it's very similar!\n概念上讲的确很像！\n\nNow let's say we want to delete \"carrie.bmp\".\n假设想删掉 carrie.bmp \\N 只需要在目录文件删掉那条记录\n\nTo do that, we can simply remove the entry from the Directory File.\n假设想删掉 carrie.bmp \\N 只需要在目录文件删掉那条记录\n\nThis, in turn, causes one block to become free.\n让一块空间变成了可用\n\nNote that we didn't actually erase the file's data in storage, we just deleted the record of it.\n注意这里没有擦除数据，只是把记录删了\n\nAt some point, that block will be overwritten with new data, but until then, it just sits there.\n之后某个时候，那些块会被新数据覆盖 \\N 但在此之前，数据还在原处\n\nThis is one way that computer forensic teams can \"recover\" data from computers even\n所以计算机取证团队可以\"恢复\"数据\n\nthough people think it has been deleted. Crafty!\n虽然别人以为数据已经\"删了\", 狡猾！\n\nOk, let's say we add even more items to our todo list, which causes the File System\n假设往 todo.txt 加了更多数据 \\N 所以操作系统分配了一个新块，用了刚刚 carrie.bmp 的块\n\nto allocate yet another block to the file, in this case,\n假设往 todo.txt 加了更多数据 \\N 所以操作系统分配了一个新块，用了刚刚 carrie.bmp 的块\n\nrecycling the block freed from carrie.bmp.\n假设往 todo.txt 加了更多数据 \\N 所以操作系统分配了一个新块，用了刚刚 carrie.bmp 的块\n\nNow our \"todo.txt\" is stored across 3 blocks, spaced apart, and also out of order.\n现在 todo.txt 在 3 个块里，隔开了，顺序也是乱的\n\nFiles getting broken up across storage like this is called fragmentation.\n这叫碎片\n\nIt's the inevitable byproduct of files being created, deleted and modified.\n碎片是增/删/改文件导致的，不可避免\n\nFor many storage technologies, this is bad news.\n对很多存储技术来说，碎片是坏事\n\nOn magnetic tape, reading todo.txt into memory would require\n如果 todo.txt 存在磁带上，读取文件要\n\nseeking to block 1, then fast forwarding to block 5, and then rewinding to block 3\n先读块1, 然后快进到块5，然后往回转到块2\n\nthat's a lot of back and forth!\n来回转个半天\n\nIn real world File Systems, large files might be stored across hundreds of blocks,\n现实世界中，大文件可能存在数百个块里\n\nand you don't want to have to wait five minutes for your files to open.\n你可不想等五分钟才打开文件\n\nThe answer is defragmentation!\n答案是碎片整理！\n\nThat might sound like technobabble, but the process is really simple,\n这个词听起来好像很复杂，但实际过程很简单\n\nand once upon a time it was really fun to watch!\n以前看计算机做碎片整理 真的很有趣！\n\nThe computer copies around data so that files have blocks located together\n计算机会把数据来回移动，排列成正确的顺序\n\nin storage and in the right order.\n计算机会把数据来回移动，排列成正确的顺序\n\nAfter we've defragged, we can read our todo file,\n整理后 todo.txt 在 1 2 3，方便读取.\n\nnow located in blocks 1 through 3, in a single, quick read pass.\n整理后 todo.txt 在 1 2 3，方便读取.\n\nSo far, we've only been talking about Flat File Systems,\n目前只说了平面文件系统，文件都在同一个目录里.\n\nwhere they're all stored in one directory.\n目前只说了平面文件系统，文件都在同一个目录里.\n\nThis worked ok when computers only had a little bit of storage,\n如果存储空间不多，这可能就够用了 \\N 因为只有十几个文件\n\nand you might only have a dozen or so files.\n如果存储空间不多，这可能就够用了 \\N 因为只有十几个文件\n\nBut as storage capacity exploded, like we discussed last episode,\n但上集说过，容量爆炸式增长，文件数量也飞速增长\n\nso did the number of files on computers.\n但上集说过，容量爆炸式增长，文件数量也飞速增长\n\nVery quickly, it became impractical to store all files together at one level.\n很快，所有文件都存在同一层变得不切实际\n\nJust like documents in the real world, it's handy to store related files together in folders.\n就像现实世界\\N 相关文件放在同一个文件夹会方便很多\n\nThen we can put connected folders into folders, and so on.\n然后文件夹套文件夹.\n\nThis is a Hierarchical File System, and its what your computer uses.\n这叫\"分层文件系统\"，你的计算机现在就在用这个.\n\nThere are a variety of ways to implement this, but let's stick with the File System example\n实现方法有很多种，我们用之前的例子来讲重点好了\n\nwe've been using to convey the main idea.\n实现方法有很多种，我们用之前的例子来讲重点好了\n\nThe biggest change is that our Directory File needs to be able to point not just to files,\n最大的变化是 目录文件不仅要指向文件, 还要指向目录\n\nbut also other directories.\n最大的变化是 目录文件不仅要指向文件, 还要指向目录\n\nTo keep track of what's a file and what's a directory, we need some extra metadata.\n我们需要额外元数据  来区分开文件和目录，\n\nThis Directory File is the top-most one, known as the Root Directory.\n这个目录文件在最顶层，因此叫根目录\n\nAll other files and folders lie beneath this directory along various file paths.\n所有其他文件和文件夹，都在根目录下\n\nWe can see inside of our \"Root\" Directory File that we have 3 files\n图中可以看到根目录文件有3个文件 \\N 2个子文件夹：\"音乐\"和\"照片\"\n\nand 2 subdirectories: music and photos.\n图中可以看到根目录文件有3个文件 \\N 2个子文件夹：\"音乐\"和\"照片\"\n\nIf we want to see what's stored in our music directory, we have to go to that block and\n如果想知道\"音乐\"文件夹里有什么 \\N 必须去那边读取目录文件（格式和根目录文件一样）\n\nread the Directory File located there; the format is the same as our root directory.\n如果想知道\"音乐\"文件夹里有什么 \\N 必须去那边读取目录文件（格式和根目录文件一样）\n\nThere's a lot of great songs in there!\n有很多好歌啊！\n\nIn addition to being able to create hierarchies of unlimited depth,\n除了能做无限深度的文件夹 \\N 这个方法也让我们可以轻松移动文件\n\nthis method also allows us to easily move around files.\n除了能做无限深度的文件夹 \\N 这个方法也让我们可以轻松移动文件\n\nSo, if we wanted to move \"theme.wav\" from our root directory to the music directory,\n如果想把 theme.wav 从根目录移到音乐目录\n\nwe don't have to re-arrange any blocks of data.\n不用移动任何数据块\n\nWe can simply modify the two Directory Files, removing an entry from one and adding it to another.\n只需要改两个目录文件 \\N 一个文件里删一条记录，另一个文件里加一条记录\n\nImportantly, the theme.wav file stays in block 5.\ntheme.wav 依然在块5\n\nSo that's a quick overview of the key principles of File Systems.\n文件系统的几个重要概念  现在介绍完了.\n\nThey provide yet another way to move up a new level of abstraction.\n它提供了一层新抽象！\n\nFile systems allow us to hide the raw bits stored on magnetic tape, spinning disks and\n文件系统使我们不必关心 \\N 文件在磁带或磁盘的具体位置\n\nthe like, and they let us think of data as neatly organized and easily accessible files.\n整理和访问文件更加方便\n\nWe even started talking about users, not programmers, manipulating data,\n我们像普通用户一样直观操纵数据，比如打开和整理文件\n\nlike opening files and organizing them,\n我们像普通用户一样直观操纵数据，比如打开和整理文件\n\nforeshadowing where the series will be going in a few episodes.\n接下来几集也会从用户角度看问题\n\nI'll see  you next week.\n下周见\n\nThis episode is brought to you by Curiosity Stream.\n本集由 Curiosity Stream 赞助播出\n\nHi, I'm Carrie Anne, and welcome to Crash Course Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nLast episode we talked about Files, bundles of data, stored on a computer, that\n上集我们讨论了文件格式，如何编码文字，声音，图片\n\nare formatted and arranged to encode information, like text, sound or images.\n上集我们讨论了文件格式，如何编码文字，声音，图片\n\nWe even discussed some basic file formats, like text, wave, and bitmap.\n还举了具体例子 .txt .wav .bmp\n\nWhile these formats are perfectly fine and still used today,\n这些格式虽然管用，而且现在还在用 \\N 但它们的简单性意味着效率不高\n\ntheir simplicity also means they're not very efficient.\n这些格式虽然管用，而且现在还在用 \\N 但它们的简单性意味着效率不高\n\nIdeally, we want files to be as small as possible, so we can store lots of them without filling\n我们希望文件能小一点，这样能存大量文件，传输也会快一些\n\nup our hard drives, and also transmit them more quickly.\n我们希望文件能小一点，这样能存大量文件，传输也会快一些\n\nNothing is more frustrating than waiting for an email attachment to download. Ugh!\n等邮件附件下载烦死人了\n\nThe answer is compression, which literally squeezes data into a smaller size.\n解决方法是 压缩，把数据占用的空间压得更小\n\nTo do this, we have to encode data using fewer bits than the original representation.\n用更少的位(bit)来表示数据\n\nThat might sound like magic, but it's actually computer science!\n听起来像魔法，但其实是计算机科学！\n\nLets return to our old friend from last episode, Mr. Pac-man!\n我们继续用上集的 吃豆人例子，图像是 4像素x4像素\n\nThis image is 4 pixels by 4 pixels.\n我们继续用上集的 吃豆人例子，图像是 4像素x4像素\n\nAs we discussed, image data is typically stored as a list of pixel values.\n之前说过，图像一般存成一长串像素值\n\nTo know where rows end, image files have metadata, which defines properties like dimensions.\n为了知道一行在哪里结束 \\N 图像要有元数据，写明尺寸等属性\n\nBut, to keep it simple today, we're not going to worry about it.\n但为了简单起见，今天忽略这些细节\n\nIf you mix full intensity red, green and blue - that's 255 for all\n如果红绿蓝都是 255 会得到白色\n\nthree values - you get the color white.\n如果红绿蓝都是 255 会得到白色\n\nIf you mix full intensity red and green, but no blue (it's 0), you get yellow.\n如果混合 255红色和255绿色，会得到黄色\n\nWe have 16 pixels in our image, and each of those needs 3 bytes of color data.\n这个图像有16个像素(4x4),  每个像素3个字节\n\nThat means this image's data will consume 48 bytes of storage.\n总共占48个字节（16x3=48）\n\nBut, we can compress the data and pack it into a smaller number of bytes than 48!\n但我们可以压缩到少于 48 个字节\n\nOne way to compress data is to reduce repeated or redundant information.\n一种方法是 减少重复信息\n\nThe most straightforward way to do this is called Run-Length Encoding.\n最简单的方法叫 游程编码(Run-Length Encoding)\n\nThis takes advantage of the fact that there are often runs of identical values in files.\n适合经常出现相同值的文件\n\nFor example, in our pac-man image, there are 7 yellow pixels in a row.\n比如吃豆人 有7个连续黄色像素\n\nInstead of encoding redundant data: yellow pixel, yellow pixel, yellow pixel, and so\n与其全存下来：黄色，黄色，黄色...\n\non, we can just say \"there's 7 yellow pixels in a row\" by inserting\n可以插入一个额外字节，代表有7个连续黄色像素\n\nan extra byte that specifies the length of the run, like so:\n可以插入一个额外字节，代表有7个连续黄色像素\n\nAnd then we can eliminate the redundant data behind it.\n然后删掉后面的重复数据.\n\nTo ensure that computers don't get confused with which bytes are run lengths and which\n为了让计算机能分辨哪些字节是\"长度\" 哪些字节是\"颜色\" \\N 格式要一致\n\nbytes represent color, we have to be consistent in how we apply this scheme.\n为了让计算机能分辨哪些字节是\"长度\" 哪些字节是\"颜色\" \\N 格式要一致\n\nSo, we need to preface all pixels with their run-length.\n所以我们要给所有像素前面标上长度\n\nIn some cases, this actually adds data, but on the whole, we've dramatically reduced\n有时候数据反而会变多，但就这个例子而言\n\nthe number of bytes we need to encode this image.\n我们大大减少了字节数，之前是48 现在是24\n\nWe're now at 24 bytes, down from 48.\n我们大大减少了字节数，之前是48 现在是24\n\nThat's 50% smaller!\n小了50％！省了很多空间！\n\nA huge saving!\n小了50％！省了很多空间！\n\nAlso note that we haven't lost any data.\n还有，我们没有损失任何数据 \\N 我们可以轻易恢复到原来的数据\n\nWe can easily expand this back to the original form without any degradation.\n还有，我们没有损失任何数据 \\N 我们可以轻易恢复到原来的数据\n\nA compression technique that has this characteristic is called\n这叫\"无损压缩\"，没有丢失任何数据\n\nlossless compression, because we don't lose anything.\n这叫\"无损压缩\"，没有丢失任何数据\n\nThe decompressed data is identical to the original before compression, bit for bit.\n解压缩后，数据和压缩前完全一样\n\nLet's take a look at another type of lossless compression, where\n我们来看另一种无损压缩，它用更紧凑的方式表示数据块\n\nblocks of data are replaced by more compact representations.\n我们来看另一种无损压缩，它用更紧凑的方式表示数据块\n\nThis is sort of like \" don't forget to be awesome \" being replaced by DFTBA.\n有点像 \"别忘了变厉害\" 简写成 DFTBA\n\nTo do this, we need a dictionary that stores the mapping from codes to data.\n为此，我们需要一个字典，存储\"代码\"和\"数据\"间的对应关系\n\nLets see how this works for our example.\n我们看个例子\n\nWe can view our image as not just a string of individual pixels,\n我们可以把图像看成一块块，而不是一个个像素\n\nbut as little blocks of data.\n我们可以把图像看成一块块，而不是一个个像素\n\nFor simplicity, we're going to use pixel pairs, which are 6 bytes long,\n为了简单，我们把2个像素当成1块（占6个字节）\n\nbut blocks can be any size.\n但你也可以定成其他大小\n\nIn our example, there are only four pairings: White-yellow, black-yellow,\n我们只有四对： 白黄 黑黄 黄黄 白白\n\nyellow-yellow and white-white.\n我们只有四对： 白黄 黑黄 黄黄 白白\n\nThose are the data blocks in our dictionary we want to generate compact codes for.\n我们会为这四对  生成紧凑代码(compact codes)\n\nWhat's interesting, is that these blocks occur at different frequencies.\n有趣的是，这些块的出现频率不同\n\nOne method for generating efficient codes is building a Huffman Tree, invented by David\n1950年代 大卫·霍夫曼 发明了一种高效编码方式叫 \\N \"霍夫曼树\"（Huffman Tree） 当时他是麻省理工学院的学生\n\nHuffman while he was a student at MIT in the 1950s.\n1950年代 大卫·霍夫曼 发明了一种高效编码方式叫 \\N \"霍夫曼树\"（Huffman Tree） 当时他是麻省理工学院的学生\n\nHis algorithm goes like this.\n算法是这样的\n\nFirst, you layout all the possible blocks and their frequencies.\n首先，列出所有块和出现频率，每轮选两个最低的频率\n\nAt every round, you select the two with the lowest frequencies.\n首先，列出所有块和出现频率，每轮选两个最低的频率\n\nHere, that's Black-Yellow and White-White, each with a frequency of 1.\n这里 黑黄 和 白白 的频率最低，它们都是 1\n\nYou combine these into a little tree. which have a combined frequency of 2,\n可以把它们组成一个树，总频率 2\n\nso we record that.\n可以把它们组成一个树，总频率 2\n\nAnd now one step of the algorithm done.\n现在完成了一轮算法\n\nNow we repeat the process.\n现在我们重复这样做\n\nThis time we have three things to choose from.\n这次有3个可选\n\nJust like before, we select the two with the lowest frequency, put them into a little tree,\n就像上次一样，选频率最低的两个，放在一起，并记录总频率\n\nand record the new total frequency of all the sub items.\n就像上次一样，选频率最低的两个，放在一起，并记录总频率\n\nOk, we're almost done.\n好，我们快完成了\n\nThis time it's easy to select the two items with the lowest frequency\n这次很简单，因为只有2个选择\n\nbecause there are only two things left to pick.\n这次很简单，因为只有2个选择\n\nWe combine these into a tree, and now we're done!\n把它们组合成一棵树就完成了！\n\nOur tree looks like this, and it has a very cool property: it's arranged by frequency,\n现在看起来像这样，它有一个很酷的属性：按频率排列\n\nwith less common items lower down.\n频率低的在下面\n\nSo, now we have a tree, but you may be wondering how this gets us to a dictionary.\n现在有了一棵树，你可能在想  \"怎么把树变成字典？\"\n\nWell, we use our frequency-sorted tree to generate the codes we need\n我们可以把每个分支用 0 和 1 标注，就像这样\n\nby labeling each branch with a 0 or a 1, like so.\n我们可以把每个分支用 0 和 1 标注，就像这样\n\nWith this, we can write out our code dictionary.\n现在可以生成字典\n\nYellow-yellow is encoded as just a single 0.  White-yellow is encoded as 10\n黄黄 编码成 0  \\N 白黄 编码成 10 \\N 黑黄 编码成 110 \\N 白白 编码成 111\n\nBlack-Yellow is 1 1 0. and finally white-white is 1 1 1.\n黄黄 编码成 0  \\N 白黄 编码成 10 \\N 黑黄 编码成 110 \\N 白白 编码成 111\n\nThe really cool thing about these codewords is that there's no way to\n酷的地方是  它们绝对不会冲突\n\nhave conflicting codes, because each path down the tree is unique.\n因为树的每条路径是唯一的\n\nThis means our codes are prefix-free, that is no code starts with another complete code.\n意味着代码是\"无前缀\"的，没有代码是以另一个代码开头的\n\nNow, let's return to our image data and compress it!\n现在我们来压缩！\n\n-- NOT BYTES -- BITS!! That's less than 2 bytes of data!\n注意是位(bit)！ 不是字节(byte)！ \\N 14位(bit) 还不到2个字节(byte)！\n\nBut, don't break out the champagne quite yet!\n但，先别急着开香槟！\n\nThis data is meaningless unless we also save our code dictionary.\n字典也要保存下来，否则 14 bit 毫无意义\n\nSo, we'll need to append it to the front of the image data, like this.\n所以我们把字典 加到 14 bit 前面，就像这样\n\nNow, including the dictionary, our image data is 30 bytes long.\n现在加上字典，图像是 30 个字节(bytes)  \\N 比 48 字节好很多\n\nThat's still a significant improvement over 48 bytes.\n现在加上字典，图像是 30 个字节(bytes)  \\N 比 48 字节好很多\n\nThe two approaches we discussed,\n\"消除冗余\"和\"用更紧凑的表示方法\"，这两种方法通常会组合使用\n\nremoving redundancies and using more compact representations, are often combined,\n\"消除冗余\"和\"用更紧凑的表示方法\"，这两种方法通常会组合使用\n\nand underlie almost all lossless compressed file formats,\n几乎所有无损压缩格式都用了它们 \\N 比如 GIF, PNG, PDF, ZIP\n\nlike GIF, PNG, PDF and ZIP files.\n几乎所有无损压缩格式都用了它们 \\N 比如 GIF, PNG, PDF, ZIP\n\nBoth run-length encoding and dictionary coders are lossless compression techniques.\n游程编码 和 字典编码 都是无损压缩\n\nNo information is lost; when you decompress, you get the original file.\n压缩时不会丢失信息，解压后，数据和之前完全一样\n\nThat's really important for many types of files.\n无损对很多文件很重要\n\nLike, it'd be very odd if I zipped up a word document to send to you,\n比如我给你发了个压缩的 word 文档\\N 你解压之后发现内容变了，这就很糟糕了\n\nand when you decompressed it on your computer, the text was different.\n比如我给你发了个压缩的 word 文档\\N 你解压之后发现内容变了，这就很糟糕了\n\nBut, there are other types of files where we can get away with little changes, perhaps\n但其他一些文件，丢掉一些数据没什么关系\n\nby removing unnecessary or less important information, especially information\n丢掉那些人类看不出区别的数据\n\nthat human perception is not good at detecting.\n丢掉那些人类看不出区别的数据\n\nAnd this trick underlies most lossy compression techniques.\n大多数有损压缩技术，都用到了这点\n\nThese tend to be pretty complicated, so we're going to attack this at a conceptual level.\n实际细节比较复杂，所以我们讲概念就好\n\nLet's take sound as an example.\n以声音为例，你的听力不是完美的\n\nYour hearing is not perfect.\n以声音为例，你的听力不是完美的\n\nWe can hear some frequencies of sound better than others.\n有些频率我们很擅长，其他一些我们根本听不见，比如超声波\n\nAnd there are some we can't hear at all, like ultrasound.\n有些频率我们很擅长，其他一些我们根本听不见，比如超声波\n\nUnless you're a bat.\n除非你是蝙蝠\n\nBasically, if we make a recording of music, and there's data in the ultrasonic frequency range,\n举个例子，如果录音乐，超声波数据都可以扔掉 \\N 因为人类听不到超声波\n\nwe can discard it, because we know that humans can't hear it.\n举个例子，如果录音乐，超声波数据都可以扔掉 \\N 因为人类听不到超声波\n\nOn the other hand, humans are very sensitive to frequencies in the vocal range, like people\n另一方面，人类对人声很敏感，所以应该尽可能保持原样\n\nsinging, so it's best to preserve quality there as much as possible.\n另一方面，人类对人声很敏感，所以应该尽可能保持原样\n\nDeep bass is somewhere in between.\n低音介于两者之间，人类听得到，但不怎么敏感\n\nHumans can hear it, but we're less attuned to it.\n低音介于两者之间，人类听得到，但不怎么敏感\n\nWe mostly sense it.\n一般是感觉到震动\n\nLossy audio compressors takes advantage of this, and encode different\n有损音频压缩利用这一点，用不同精度编码不同频段\n\nfrequency bands at different precisions.\n有损音频压缩利用这一点，用不同精度编码不同频段\n\nEven if the result is rougher, it's likely that users won't perceive the difference.\n听不出什么区别，不会明显影响体验\n\nOr at least it doesn't dramatically affect the experience.\n听不出什么区别，不会明显影响体验\n\nAnd here comes the hate mail from the audiophiles!\n音乐发烧友估计要吐槽了！\n\nYou encounter this type of audio compression all the time.\n日常生活中你会经常碰到这类音频压缩\n\nIt's one of the reasons you sound different on a cellphone versus in person.\n所以你在电话里的声音 和现实中不一样\n\nThe audio data is being compressed, allowing more people to take calls at once.\n压缩音频是为了让更多人能同时打电话\n\nAs the signal quality or bandwidth get worse, compression algorithms remove more data,\n如果网速变慢了，压缩算法会删更多数据\n\nfurther reducing precision, which is why Skype calls sometimes sound like robots talking.\n进一步降低声音质量，所以 Skype 通话有时听起来像机器人\n\nCompared to an uncompressed audio format, like a WAV or FLAC (there we go, got the audiophiles back)\n和没压缩的音频格式相比，比如 WAV 或 FLAC \\N ( 这下音乐发烧友满意了）\n\ncompressed audio files, like MP3s, are often 10 times smaller.\n压缩音频文件如 MP3，能小10倍甚至更多.\n\nThat's a huge saving!\n省了超多空间！\n\nAnd it's why I've got a killer music collection on my retro iPod.\n所以我的旧 iPod 上有一堆超棒的歌\n\nDon't judge.\n别批判我\n\nThis idea of discarding or reducing precision in a manner that aligns with human perception\n这种删掉人类无法感知的数据的方法，叫\"感知编码\"\n\nis called perceptual coding,\n这种删掉人类无法感知的数据的方法，叫\"感知编码\"\n\nand it relies on models of human perception,\n它依赖于人类的感知模型，模型来自\"心理物理学\"领域\n\nwhich come from a field of study called Psychophysics.\n它依赖于人类的感知模型，模型来自\"心理物理学\"领域\n\nThis same idea is the basis of lossy compressed image formats, most famously JPEGs.\n这是各种\"有损压缩图像格式\"的基础，最著名的是 JPEG\n\nLike hearing, the human visual system is imperfect.\n就像听力一样，人的视觉系统也不是完美的.\n\nWe're really good at detecting sharp contrasts, like the edges of objects,\n我们善于看到尖锐对比，比如物体的边缘\n\nbut our perceptual system isn't so hot with subtle color variations.\n但我们看不出颜色的细微变化\n\nJPEG takes advantage of this by breaking images up into blocks of 8x8 pixels,\nJPEG 利用了这一点，把图像分解成 8x8 像素块\n\nthen throwing away a lot of the high-frequency spatial data.\n然后删掉大量高频率空间数据\n\nFor example, take this photo of our directors dog - Noodle.\n举个例子，这是导演的狗，面面\n\nSo cute!\n超可爱！\n\nLet's look at a patch of 8x8 pixels.\n我们来看其中一个 8x8 像素\n\nPretty much every pixel is different from its neighbor,\n几乎每个像素都和相邻像素不同，用无损技术很难压缩 \\N 因为太多不同点了\n\nmaking it hard to compress with loss-less techniques because there's just a lot going on.\n几乎每个像素都和相邻像素不同，用无损技术很难压缩 \\N 因为太多不同点了\n\nLots of little details.\n很多小细节\n\nBut human perception doesn't register all those details.\n但人眼看不出这些细节\n\nSo, we can discard a lot of that detail, and replace it with a simplified patch like this.\n因此可以删掉很多，用这样一个简单的块来代替\n\nThis maintains the visual essence, but might only use 10% of the data.\n这看起来一样，但可能只占10％的原始数据\n\nWe can do this for all the patches in the image and get this result.\n我们可以对所有 8x8 块做一样的操作\n\nYou can still see it's a dog, but the image is rougher.\n图片依然可以认出是一只狗，只是更粗糙一些\n\nSo, that's an extreme example, going from a slightly compressed JPEG to a highly compressed one,\n以上例子比较极端，进行了高度压缩，只有原始大小的八分之一\n\none-eighth the original file size.\n以上例子比较极端，进行了高度压缩，只有原始大小的八分之一\n\nOften, you can get away with a quality somewhere in between, and perceptually,\n通常你可以取得平衡，图片看起来差不多，但文件小不少\n\nit's basically the same as the original.\n通常你可以取得平衡，图片看起来差不多，但文件小不少\n\nCan you tell the difference between the two?\n你看得出两张图的区别吗？\n\nProbably not, but I should mention that video compression plays a role in that too,\n估计看不出，但我想提一下，视频压缩也造成了影响\n\nsince I'm literally being compressed in a video right now.\n毕竟你现在在看视频啊\n\nVideos are really just long sequences of images, so a lot of what I said\n视频只是一长串连续图片 \\N 所以图片的很多方面也适用于视频\n\nabout them applies here too.\n视频只是一长串连续图片 \\N 所以图片的很多方面也适用于视频\n\nBut videos can do some extra clever stuff, because between frames,\n但视频可以做一些小技巧 \\N 因为帧和帧之间很多像素一样\n\na lot of pixels are going to be the same.\n但视频可以做一些小技巧 \\N 因为帧和帧之间很多像素一样\n\nLike this whole background behind me!\n比如我后面的背景！\n\nThis is called temporal redundancy.\n这叫 时间冗余\n\nWe don't need to re-transmit those pixels every frame of the video.\n视频里不用每一帧都存这些像素 \\N 可以只存变了的部分\n\nWe can just copy patches of data forward.\n视频里不用每一帧都存这些像素 \\N 可以只存变了的部分\n\nWhen there are small pixel differences, like the readout on this frequency generator behind me,\n当帧和帧之间有小小的差异时，比如后面这个频率发生器\n\nmost video formats send data that encodes just the difference between patches,\n很多视频编码格式，只存变化的部分\n\nwhich is more efficient than re-transmitting all the pixels afresh, again taking advantage\n这比存所有像素更有效率 \\N 利用了帧和帧之间的相似性\n\nof inter-frame similarity.\n这比存所有像素更有效率 \\N 利用了帧和帧之间的相似性\n\nThe fanciest video compression formats go one step further.\n更高级的视频压缩格式 会更进一步\n\nThey find patches that are similar between frames, and not only copy them forward, with\n找出帧和帧之间相似的补丁 \\N 然后用简单效果实现，比如移动和旋转\n\nor without differences, but also can apply simple effects to them, like a shift or rotation.\n找出帧和帧之间相似的补丁 \\N 然后用简单效果实现，比如移动和旋转\n\nThey can also lighten or darken a patch between frames.\n变亮和变暗\n\nSo, if I move my hand side to side like this the video compressor will identify the similarity,\n如果我这样摆手，视频压缩器会识别到相似性\n\ncapture my hand in one or more patches, then just move these patches around between frames.\n用一个或多个补丁代表我的手，然后帧之间直接移动这些补丁\n\nYou're actually seeing my hand from the past kinda freaky, but it uses a lot less data.\n所以你看到的是我过去的手（不是实时的）\\N 有点可怕 但数据量少得多\n\nMPEG-4 videos, a common standard, are often 20 to 200 times\nMPEG-4 是常见标准，可以比原文件小20倍到200倍\n\nsmaller than the original, uncompressed file.\nMPEG-4 是常见标准，可以比原文件小20倍到200倍\n\nHowever, encoding frames as translations and rotations of patches from previous frames\n但用补丁的移动和旋转 来更新画面\n\ncan go horribly wrong when you compress too heavily, and there isn't\n当压缩太严重时会出错 \\N 没有足够空间更新补丁内的像素\n\nenough space to update pixel data inside of the patches.\n当压缩太严重时会出错 \\N 没有足够空间更新补丁内的像素\n\nThe video player will forge ahead, applying the right motions,\n即使补丁是错的，视频播放器也会照样播放\n\neven if the patch data is wrong.\n即使补丁是错的，视频播放器也会照样播放\n\nAnd this leads to some hilarious and trippy effects, which I'm sure you've seen.\n导致一些怪异又搞笑的结果，你肯定见过这些.\n\nOverall, it's extremely useful to have compression techniques for all the types of data I discussed today.\n总的来说，压缩对大部分文件类型都有用\n\n(I guess our imperfect vision and hearing are \"useful,\" too.)\n从这个角度来讲，人类不完美的视觉和听觉 也算有用\n\nAnd it's important to know about compression because it allows users to\n学习压缩非常重要 \\N 因为可以高效存储图片，音乐，视频\n\nstore pictures, music, and videos in efficient ways.\n学习压缩非常重要 \\N 因为可以高效存储图片，音乐，视频\n\nWithout it, streaming your favorite Carpool Karaoke videos on YouTube would be nearly impossible,\n如果没有压缩 \\N 在 YouTube 看\"明星拼车唱歌\"几乎不可能\n\ndue to bandwidth and the economics of transmitting that volume of data for free.\n因为你的带宽可能不够（会很卡） \\N 而且供应商不愿意免费传输那么多数据\n\nAnd now when your Skype calls sound like they're being taken over by demons,\n现在你知道为什么打 Skype 电话 \\N 有时像在和恶魔通话\n\nyou'll know what's really going on.\n现在你知道为什么打 Skype 电话 \\N 有时像在和恶魔通话\n\nI'll see you next week.\n下周见\n\nHi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nWe've talked a lot about inputs and outputs in this series,\n我们之前讨论过 输入输出 \\N 但都是计算机组件互相输入输出\n\nbut they've mostly been between different parts of a computer\n我们之前讨论过 输入输出 \\N 但都是计算机组件互相输入输出\n\nlike outputting data from RAM or inputting instructions to a CPU.\n比如 RAM 输出数据，或输指令进 CPU\n\nWe haven't discussed much about inputs coming from humans.\n我们还没讲 来自人类的输入\n\nWe also haven't learned how people get information out of a computer,\n也没讲怎么从电脑中拿出信息，除了用打孔纸卡\n\nother than by printing or punching it onto paper.\n也没讲怎么从电脑中拿出信息，除了用打孔纸卡\n\nOf course, there's a wide variety of input and output devices that\n当然，有很多种 \"输入输出设备\"  \\N 让我们和计算机交互\n\nallow us users to communicate with computers.\n当然，有很多种 \"输入输出设备\"  \\N 让我们和计算机交互\n\nThey provide an interface between human and computer.\n它们在人类和机器间提供了界面\n\nAnd today, there's a whole field of study called Human-Computer Interaction.\n如今有整个学科专门研究这个，叫 \"人机交互\"\n\nThese interfaces are so fundamental to the user experience\n界面对用户体验非常重要 \\N 所以是我们接下来几集的重点\n\nthat they're the focus of the next few episodes.\n界面对用户体验非常重要 \\N 所以是我们接下来几集的重点\n\nAs we discussed at the very beginning of the series,\n在系列开头的几集，我们提过\n\nthe earliest mechanical and electro-mechanical computing devices\n早期机械计算设备 \\N 用齿轮，旋钮和开关等机械结构来输入输出\n\nused physical controls for inputs and outputs, like gears, knobs and switches,\n早期机械计算设备 \\N 用齿轮，旋钮和开关等机械结构来输入输出\n\nand this was pretty much the extent of the human interface.\n这些就是交互界面\n\nEven the first electronic computers, like Colossus and ENIAC,\n甚至早期电子计算机  比如 Colossus 和 ENIAC\n\nwere configured using huge panels of mechanical controls and patch wires.\n也是用一大堆机械面板和线 来操作\n\nIt could take weeks to enter in a single program, let alone run it,\n输入一个程序可能要几星期，还没提运行时间.\n\nand to get data out after running a program, results were most often printed to paper.\n运行完毕后想拿出数据，一般是打印到纸上\n\nPaper printers were so useful\n打印机超有用\n\nthat even Babbage designed one for his Difference Engine,\n甚至 查尔斯·巴贝奇 都给差分机专门设计了一个\n\nand that was in the 1820s!\n那可是 1820 年代!\n\nHowever, by the 1950s, mechanical inputs were rendered obsolete\n然而，到 1950 年代，机械输入完全消失\n\nby programs and data stored entirely on mediums like punch cards and magnetic tape.\n因为出现了打孔纸卡和磁带\n\nPaper printouts were still used for the final output,\n但输出仍然是打印到纸上\n\nand huge banks of indicator lights were developed\n还有大量指示灯，在运行中提供实时反馈\n\nto provide real time feedback while the program was in progress.\n还有大量指示灯，在运行中提供实时反馈\n\nIt's important to recognize that computer input of this era was\n那个时代的特点是 尽可能迁就机器 \\N 对人类好不好用是其次\n\ndesigned to be as simple and robust as possible for computers.\n那个时代的特点是 尽可能迁就机器 \\N 对人类好不好用是其次\n\nEase and understanding for users was a secondary concern.\n那个时代的特点是 尽可能迁就机器 \\N 对人类好不好用是其次\n\nPunch tape is a great example\n打孔纸带就是个好例子\n\nthis was explicitly designed to be easy for computers to read.\n就是为了方便计算机读取\n\nThe continuous nature of tape made it easy to handle mechanically,\n纸带是连续的，方便机器处理\n\nand the holes could be reliably detected with a mechanical or optical system,\n纸孔可以方便地 用机械或光学手段识别\n\nwhich encoded instructions and data.\n纸孔可以编码程序和数据\n\nBut of course, humans don't think in terms of little punched holes on strips of paper.\n当然, 人类不是以纸孔方式思考的.\n\nSo, the burden was on programmers.\n所以负担放到了程序员身上\n\nThey had to spend the extra time and effort to convert their ideas and programs\n他们要花额外时间和精力 \\N 转成计算机能理解的格式\n\ninto a language and a format that was easy for computers of the era to understand\n他们要花额外时间和精力 \\N 转成计算机能理解的格式\n\noften with the help of additional staff and auxiliary devices.\n一般需要额外人员和设备帮忙\n\nIt's also important to note that early computers, basically pre-1950,\n要注意的是，基本上 1950 年前的早期计算机 \\N \"输入\"的概念很原始\n\nhad an extremely simple notion of human input.\n要注意的是，基本上 1950 年前的早期计算机 \\N \"输入\"的概念很原始\n\nYes, humans input programs and data into computers,\n是的，的确是人类负责输入程序和数据 \\N 但计算机不会交互式回应\n\nbut these machines generally didn't respond interactively to humans.\n是的，的确是人类负责输入程序和数据 \\N 但计算机不会交互式回应\n\nOnce a program was started, it typically ran until it was finished.\n程序开始运行后会一直运行  直到结束\n\nThat's because these machines were way too expensive to be\n因为机器太贵了 \\N 不能等人类慢慢敲命令和给数据\n\nwaiting around for humans to type a command or enter data.\n因为机器太贵了 \\N 不能等人类慢慢敲命令和给数据\n\nAny input needed for a computation was fed in at the same time as the program.\n要同时放入程序和数据\n\nThis started to change in the late 1950s.\n这在 1950 年代晚期开始发生变化\n\nOn one hand, smaller-scale computers started to become cheap enough\n一方面，小型计算机变得足够便宜\n\nthat it was feasible to have a human-in-the loop;\n让人类来回和计算机交互  变得可以接受\n\nthat is, a back and forth between human and computer.\n交互式就是人和计算机之间来回沟通\n\nAnd on the other hand,\n而另一方面\n\nbig fancy computers became fast and sophisticated enough to support many programs and users at once,\n大型计算机变得更快，能同时支持多个程序和多个用户\n\nwhat were called multitasking and time-sharing systems .\n这叫\"多任务\"和\"分时系统\"\n\nBut these computers needed a way to get input from users.\n但交互式操作时 \\N 计算机需要某种方法来获得用户输入\n\nFor this, computers borrowed the ubiquitous data entry mechanism of the era: keyboards.\n所以借用了当时已经存在的数据录入机制：键盘\n\nAt this point, typing machines had already been in use for a few centuries,\n当时，打字机已经存在几个世纪了\n\nbut it was Christopher Latham Sholes, who invented the modern typewriter in 1868.\n但现代打字机是 \\N克里斯托弗·莱瑟姆·肖尔斯 在 1868 年发明的\n\nIt took until 1874 to refine the design and manufacture it,\n虽然到 1874 年才完成设计和制造\n\nbut it went on to be a commercial success.\n但之后取得了商业成功\n\nSholes' typewriter adopted an unusual keyboard layout that you know well QWERTY\n肖尔斯 的打字机用了不寻常的布局，QWERTY\n\nnamed for the top-left row of letter keys.\n名字来自键盘左上角按键\n\nThere has been a lot of speculation as to why this design was used.\n为什么这么设计 有很多猜测\n\nThe most prevalent theory is that it put common letter pairings in English far apart\n最流行的理论是  这样设计是为了 \\N 把常见字母放得远一些，避免按键卡住\n\nto reduce the likelihood of typebars jamming when entered in sequence.\n最流行的理论是  这样设计是为了 \\N 把常见字母放得远一些，避免按键卡住\n\nIt's a convenient explanation, but it's also probably false,\n这个解释虽然省事，但可能是错的，或至少不够全面\n\nor at least not the full story.\n这个解释虽然省事，但可能是错的，或至少不够全面\n\nIn fact, QWERTY puts many common letter pairs together,\n事实上，QWERTY 把很多常见字母放在了一起 \\N 比如 TH 和 ER\n\nlike \"TH\" and \"ER\".\n事实上，QWERTY 把很多常见字母放在了一起 \\N 比如 TH 和 ER\n\nAnd we know that Sholes and his team went through many iterations\n我们知道 肖尔斯和他的团队设计了很多版 \\N 才进化到这个布局\n\nbefore arriving at this iconic arrangement.\n我们知道 肖尔斯和他的团队设计了很多版 \\N 才进化到这个布局\n\nRegardless of the reason, the commercial success of Sholes' typewriter meant\n总之，肖尔斯 的打字机取得了成功 \\N 所以其它公司很快开始抄他的设计\n\nthe competitor companies that soon followed duplicated his design.\n总之，肖尔斯 的打字机取得了成功 \\N 所以其它公司很快开始抄他的设计\n\nMany alternative keyboard layouts have been proposed over the last century,\n过去一个世纪有不少新的键盘布局被发明，宣称各种好处\n\nclaiming various benefits.\n过去一个世纪有不少新的键盘布局被发明，宣称各种好处\n\nBut, once people had invested the time to learn QWERTY,\n但人们已经熟悉了 QWERTY 布局 \\N 根本不想学新布局\n\nthey just didn't want to learn something new.\n但人们已经熟悉了 QWERTY 布局 \\N 根本不想学新布局\n\nThis is what economists would call a switching barrier or switching cost.\n这是经济学家所说的 转换成本\n\nAnd it's for this very basic human reason\n所以现在都快1个半世纪了 \\N 我们还在用 QWERTY 键盘布局\n\nthat we still use QWERTY keyboards almost a century and a half later!\n所以现在都快1个半世纪了 \\N 我们还在用 QWERTY 键盘布局\n\nI should mention that QWERTY isn't universal.\n我应该提一下，QWERTY 不是通用的\n\nThere are many international variants,\n有很多变体，比如法国 AZERTY 布局\n\nlike the French AZERTY layout,\n有很多变体，比如法国 AZERTY 布局\n\nor the QWERTZ layout common in central Europe.\n以及中欧常见的 QWERTZ 布局\n\nInterestingly, Sholes didn't envision that typing would ever be faster than handwriting,\n有趣的是，肖尔斯 根本没想到打字会比手写快\n\nwhich is around 20 words per minute.\n手写速度大约是每分钟 20 个\n\nTypewriters were introduced chiefly for legibility and standardization of documents, not speed.\n打字机主要为了易读性和标准化，而不是速度\n\nHowever, as they became standard equipment in offices, the desire for speedy typing grew,\n然而随着打字机成为办公室标配 \\N 对快速打字的渴望越来越大\n\nand there were two big advances that unlocked typing's true potential.\n有两个重大进步  解放了打字的潜力\n\nAround 1880, Elizabeth Longley, a teacher at the Cincinnati Shorthand and Type-Writer Institute,\n1880年左右，辛辛那提速记学院 \\N 一名叫 伊丽莎白·朗利 的老师\n\nstarted to promote ten-finger typing.\n开始推广 十指打字\n\nThis required much less finger movement than hunt-and-peck,\n比一个手指打字要移动的距离短得多，所以速度更快\n\nso it offered enhanced typing speeds.\n比一个手指打字要移动的距离短得多，所以速度更快\n\nThen, a few years later, Frank Edward McGurrin, a federal court clerk in Salt Lake City,\n几年后，弗兰克·爱德华·麦克格林 \\N 盐湖城的一位联邦法庭书记\n\ntaught himself to touch-type; as in, he didn't need to look at the keys while typing.\n学会了盲打，打字时不用看键盘\n\nIn 1888, McGurrin won a highly publicized typing-speed contest,\n1888年，麦格高林 赢了备受关注的打字速度比赛\n\nafter which ten-finger, touch-typing began to catch on.\n之后\"十指盲打\"开始流行\n\nProfessional typists were soon able to achieve speeds upwards of 100 words per minute,\n专业打字员  每分钟 100 字以上\n\nmuch faster than handwriting!\n比手写快多了！而且清晰又整洁！\n\nAnd nice and neat too!\n比手写快多了！而且清晰又整洁！\n\nSo, humans are pretty good with typewriters,\n虽然人类擅长用打字机\n\nbut we can't just plunk down a typewriter in front of a computer and have it type\n但我们没法把打字机塞到计算机面前，让它打字\n\nthey have no fingers!\n计算机又没有手指\n\nInstead, early computers adapted a special type of typewriter that was used for telegraphs,\n所以早期计算机用了一种特殊打字机，是专门用来发电报的,\n\ncalled a teletype machine.\n叫 电传打字机\n\nThese were electromechanically-augmented typewriters\n这些打字机是强化过的，可以用电报线发送和接收文本\n\nthat can send and receive text over telegraph lines.\n这些打字机是强化过的，可以用电报线发送和接收文本\n\nPressing a letter on one teletype keyboard would cause a signal to be sent,\n按一个字母，信号会通过电报线，发到另一端\n\nover telegraph wires, to a teletype machine on the other end,\n按一个字母，信号会通过电报线，发到另一端\n\nwhich would then electromechanically type that letter.\n另一端的电传打字机会打出来\n\nThis allowed two humans to type to one another over long distances.\n使得两人可以长距离沟通\n\nbasically a steampunk version of a chat room.\n基本是个蒸汽朋克版聊天室\n\nSince these teletype machines already had an electronic interface,\n因为电传打字机有电子接口，稍作修改就能用于计算机\n\nthey were easily adapted for computer use,\n因为电传打字机有电子接口，稍作修改就能用于计算机\n\nand teletype computer interfaces were common in the 1960s and 70s.\n电传交互界面在 1960~1970 很常见\n\nInteraction was pretty straightforward.\n用起来很简单\n\nUsers would type a command, hit enter, and then the computer would type back.\n输入一个命令，按回车，然后计算机会输回来\n\nThis text \"conversation\" between a user and a computer went back and forth.\n用户和计算机来回\"对话\"\n\nThese were called command line interfaces,\n这叫\"命令行界面\"\n\nand they remained the most prevalent form of human-computer interaction\n它是最主要的人机交互方式，一直到 1980 年代\n\nup until around the 1980s.\n它是最主要的人机交互方式，一直到 1980 年代\n\nCommand Line interaction on a teletype machine looks something like this.\n用电传打字机的命令行交互  类似这样：\n\nA user can type any number of possible commands.\n用户可以输入各种命令\n\nLet's check out a few,\n我们来看几个命令，先看当前目录有什么文件\n\nbeginning with seeing all of the files in the current directory we're in.\n我们来看几个命令，先看当前目录有什么文件\n\nFor this, we would type the command, \"ls\", which is short for list,\n输入命令 ls，名字来自 list 的缩写\n\nand the computer replies with a list of the files in our current directory.\n然后计算机会列出 当前目录里的所有文件\n\nIf we want to see what's in our \"secretStarTrekDiscoveryCast.txt.txt file\",\n如果想看 secretStarTrekDiscoveryCast.txt 有什么\n\nwe use yet another command to display the contents.\n要用另一个命令 显示文件内容\n\nIn unix, we can call \"cat\" - short for concatenate.\nunix 用 cat 命令显示文件内容 \\N cat 是连接(concatenate)的缩写\n\nWe need to specify which file to display, so we include that after the command, called an argument.\n然后指定文件名，指定的方法是写在 cat 命令后面 \\N 传给命令的值叫 参数\n\nIf you're connected to a network with other users,\n如果同一个网络里有其他人\n\nyou can use a primitive version of a Find My Friends app\n你可以用 finger 命令找朋友 \\N 就像是个很原始的\"找朋友\" App\n\nto get more info on them with the command \"finger\".\n你可以用 finger 命令找朋友 \\N 就像是个很原始的\"找朋友\" App\n\nElectromechanical teletype machines\n电传打字机 直到1970年代左右都是主流交互方式\n\nwere the primary computing interface for most users up until around the 1970s.\n电传打字机 直到1970年代左右都是主流交互方式\n\nAlthough computer screens first emerged in the 1950s,\n尽管屏幕最早出现在 1950 年代 \\N 但对日常使用太贵 而且分辨率低\n\nand were used for graphics they were too expensive and low resolution for everyday use.\n尽管屏幕最早出现在 1950 年代 \\N 但对日常使用太贵 而且分辨率低\n\nHowever, mass production of televisions for the consumer market, and general improvements\n然而因为针对普通消费者的电视机开始量产 \\N 同时处理器与内存也在发展\n\nin processors and memory, meant that by 1970, it was economically viable\n到1970年代，屏幕代替电传打字机 变得可行\n\nto replace electromechanical teletype machines with screen-based equivalents.\n到1970年代，屏幕代替电传打字机 变得可行\n\nBut rather than build a whole new standard to interface computers with these screens,\n但与其为屏幕  专门做全新的标准\n\nengineers simply recycled the existing text-only, teletype protocol.\n工程师直接用现有的 电传打字机协议\n\nThese machines used a screen, which simulated endless paper.\n屏幕就像无限长度的纸 \\N 除了输入和输出字，没有其它东西\n\nIt was text in and text out, nothing more.\n屏幕就像无限长度的纸 \\N 除了输入和输出字，没有其它东西\n\nThe protocol was identical, so computers couldn't even tell if it was paper or a screen.\n协议是一样的，所以计算机分不出是纸还是屏幕\n\nThese virtual teletype or glass teletype machines became known as terminals .\n这些\"虚拟电传打字机\"或\"玻璃电传打字机\"\\N 叫 终端\n\nBy 1971, it was estimated, in the United States,\n到1971年，美国大约有 7 万台电传打字机 \\N 以及 7 万个终端\n\nthere was something on the order of 70,000 electro-mechanical teletype machines\n到1971年，美国大约有 7 万台电传打字机 \\N 以及 7 万个终端\n\nand 70,000 screen-based terminals in use.\n到1971年，美国大约有 7 万台电传打字机 \\N 以及 7 万个终端\n\nScreens were so much better, faster and more flexible, though.\n屏幕又好又快又灵活\n\nLike, you could delete a mistake and it would disappear.\n如果删一个错别字 会立刻消失\n\nSo, by the end of the 1970s, screens were standard.\n所以到 1970 年代末  屏幕成了标配\n\nYou might think that command line interfaces are way too primitive to do anything interesting.\n你也许会想，命令行界面太原始了 \\N 做不了什么有意思的事\n\nBut even when the only interaction was through text, programmers found a way to make it fun.\n即便只有文字 \\N 程序员也找到了一些方法，让它变得有趣一些\n\nEarly interactive, text-based computer games include famous titles like Zork,\n早期的著名交互式文字游戏  Zork\n\ncreated in 1977.\n出现于 1977 年\n\nPlayers of these sorts of early games were expected to engage their limitless imaginations\n早期游戏玩家需要丰富的想象力\n\nas they visualized the fictional world around them, like what terrifying monster confronted them\n想像自己身在虚构世界，比如\"四周漆黑一片\n\nwhen it was pitch black and you were likely to be eaten by a grue.\n附近可能有怪物会吃掉你\"\n\nLet's go back to our command line, now on a fancy screen-based terminal, and play!\n我们用命令行玩玩看\n\nJust like before, we can see what's in our current directory with the \"ls\" command.\n就像之前，我们可以用 ls 命令，看当前目录有什么\n\nThen, let's go into our games directory by using the \"cd\" command,  for \" change directory \".\n然后用 cd 命令，进入游戏文件夹 \\N cd 的意思是 \"改变文件夹\"\n\nNow, we can use our \"ls\" command again to see what games are installed on our computer.\n再用 ls 看有哪些游戏\n\nSweet, we have Adventure!\n超棒！我们有\"冒险旅程\"！(adventure)\n\nAll we have to do to run this program is type its name.\n想运行这个程序，只需要输入它的名字\n\nUntil this application halts, or we quit it, it takes over the command line.\n在程序自行停止或我们主动退出前 \\N 它会接管命令行\n\nWhat you're seeing here is actual interaction from \"Colossal Cave Adventure\",\n你现在看到的，是\"巨大洞穴冒险\"这款游戏的真实输出\n\nfirst developed by Will Crowther in 1976.\n由 Will Crowther 在 1976 年开发\n\nIn the game, players can type in one- or two-word commands to move around,\n游戏中，玩家可以输入1个词或2个词的命令 \\N 来移动人物，和其他东西交互，捡物品等\n\ninteract with objects, pickup items and so on.\n游戏中，玩家可以输入1个词或2个词的命令 \\N 来移动人物，和其他东西交互，捡物品等\n\nThe program acts as the narrator, describing locations, possible actions,\n然后游戏会像旁白一样，输出你的当前位置， \\N 告诉你能做什么动作，以及你的动作造成的结果\n\nand the results of those actions.\n然后游戏会像旁白一样，输出你的当前位置， \\N 告诉你能做什么动作，以及你的动作造成的结果\n\nCertain ones resulted in death!\n有些动作会导致死亡！\n\nThe original version only had 66 locations to explore,\n原始版本只有 66 个地方可供探索\n\nbut it's widely considered to be the first example of interactive fiction.\n但它被广泛认为是最早的互动式小说\n\nThese text adventure games later became multiplayer, called MUDs or Multi-User Dungeons.\n游戏后来从纯文字进化成多人游戏 \\N 简称 MUD，或多人地牢游戏\n\nAnd they're the great-forbearers of the awesome graphical MMORPG's\n是如今 MMORPG 的前辈 \\N （大型多人在线角色扮演游戏）\n\n(massive, multiplayer online role playing games) we enjoy today.\n是如今 MMORPG 的前辈 \\N （大型多人在线角色扮演游戏）\n\nAnd if you want to know more about the history of these and other games\n如果你想了解游戏史，我们有游戏速成课  \\N 主持人 Andre Meadows\n\nwe've got a whole series on it hosted by Andre Meadows!\n如果你想了解游戏史，我们有游戏速成课  \\N 主持人 Andre Meadows\n\nCommand line interfaces, while simple, are very powerful.\n命令行界面虽然简单  但十分强大\n\nComputer programming is still very much a written task, and as such,\n编程大部分依然是打字活 \\N 所以用命令行比较自然\n\ncommand lines are a natural interface.\n编程大部分依然是打字活 \\N 所以用命令行比较自然\n\nFor this reason, even today, most programmers use\n因此，即使是现在  \\N 大多数程序员工作中依然用命令行界面\n\ncommand line interfaces as part of their work.\n因此，即使是现在  \\N 大多数程序员工作中依然用命令行界面\n\nAnd they're also the most common way to access computers that are far away,\n而且用命令行访问远程计算机 是最常见的方式 \\N 比如服务器在另一个国家\n\nlike a server in a different country.\n而且用命令行访问远程计算机 是最常见的方式 \\N 比如服务器在另一个国家\n\nIf you're running Windows, macOS or Linux,\n如果你用 Windows, macOS, Linux\n\nyour computer has a command line interface one you may have never used.\n你的计算机有命令行界面，但你可能从来没用过\n\nCheck it out by typing \"cmd\" in your Windows search bar,\n你可以在 Windows 搜索栏中输入 cmd\n\nor search for Terminal on Mac.\n或在 Mac 上搜 Terminal\n\nThen install a copy of Zork and play on!\n然后你可以装 Zork 玩！\n\nSo, you can see how these early advancements still have an impact on computing today.\n现在你知道了 \\N 早期计算机的发展是如何影响到现在的.\n\nJust imagine if your phone didn't have a good ol' fashioned QWERTY keyboard.\n想想要是手机没有 QWERTY 键盘 \\N 在 Instagram 给图片配标题可就麻烦了\n\nIt could take forever to type your Instagram captions.\n想想要是手机没有 QWERTY 键盘 \\N 在 Instagram 给图片配标题可就麻烦了\n\nBut, there's still something missing from our discussion.\n但我们还有一个重要话题没讲\n\nAll the sweet sweet graphics!\n美妙的图形界面！\n\nThat's our topic for next week.\n这是下周的主题\n\nSee you soon.\n下周见\n\nHi, I'm Carrie Anne, and welcome to Crash Course Computer Science!\n(｡･∀･)ﾉﾞ嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！\n\nThis 1960 PDP-1 is a great example of early computing with graphics.\n这台 1960 年的 PDP-1 \\N 是一个早期图形计算机的好例子\n\nYou can see a cabinet-sized computer on the left,\n你可以看到 左边是柜子大小的电脑\n\nan electromechanical teletype machine in the middle,\n中间是电传打字机\n\nand a round screen on the right.\n右边是一个圆形的屏幕\n\nNote how they're separated.\n注意它们是分开的\n\nThat's because text-based tasks and graphical tasks were often distinct back then.\n因为当时文本任务和图形任务是分开的.\n\nIn fact, these early computer screens had a very hard time rendering crisp text, whereas\n事实上，早期的屏幕无法显示清晰的文字\n\ntyped paper offered much higher contrast and resolution.\n而打印到纸上  有更高的对比度和分辨率\n\nThe most typical use for early computer screens was to keep track of a program's operation,\n早期屏幕的典型用途 是跟踪程序的运行情况\n\nlike values in registers.\n比如寄存器的值\n\nIt didn't make sense to have a teletype machine print this on paper\n如果用打印机 \\N 一遍又一遍打印出来没有意义\n\nover and over and over again -- that'd waste a lot of paper, and it was slow.\n不仅费纸而且慢\n\nOn the other hand, screens were dynamic and quick to update -- perfect for temporary values.\n另一方面，屏幕更新很快，对临时值简直完美\n\nComputer screens were rarely considered for program output, though.\n但屏幕很少用于输出计算结果，结果一般都打印到纸上\n\nInstead, any results from a computation were typically written to paper\n但屏幕很少用于输出计算结果，结果一般都打印到纸上\n\nor some other more permanent medium.\n或其它更永久的东西上\n\nBut, screens were so darn useful\n但屏幕超有用 \\N 到1960年代，人们开始用屏幕做很多酷炫的事情\n\nthat by the early 1960s, people started to use them for awesome things.\n但屏幕超有用 \\N 到1960年代，人们开始用屏幕做很多酷炫的事情\n\nA lot of different display technologies have been created over the decades,\n几十年间出现了很多显示技术\n\nbut the most influential, and also the earliest, were Cathode Ray Tubes, or CRT\n但最早最有影响力的是 阴极射线管（CRT）\n\nThese work by shooting electrons out of an emitter at a phosphor-coated screen.\n原理是把电子发射到 有磷光体涂层的屏幕上\n\nWhen electrons hit the coating, it glows for a fraction of a second.\n当电子撞击涂层时 会发光几分之一秒\n\nBecause electrons are charged particles,\n由于电子是带电粒子，路径可以用磁场控制\n\ntheir paths can be manipulated with electromagnetic fields.\n由于电子是带电粒子，路径可以用磁场控制\n\nPlates or coils are used inside to steer electrons to a desired position,\n屏幕内用板子或线圈  把电子引导到想要的位置\n\nboth left-right and up-down.\n上下左右都行\n\nWith this control, there are two ways you can draw graphics.\n既然可以这样控制，有 2 种方法绘制图形 \\N 1. 引导电子�"
        },
        {
          "name": "(字幕)全40集中英字幕文本",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.091796875,
          "content": "extract_from_ass_subtitle/node_modules\nextract_from_ass_subtitle/package-lock.json\n*.DS_Store\n"
        },
        {
          "name": "1. screenshot.py",
          "type": "blob",
          "size": 0.7568359375,
          "content": "# Crash Course Computer Science\n# 这里的程序只是为了截图视频开头 00:00:00 的时间表\n# 最后的输出结果：40张 jpg 图片\n\nimport os\n\nfiles = [f for f in os.listdir('.') if os.path.isfile(f)]\nfor f in files:\n    # 文件名举例： \n    # 1. 计算机早期历史-Early Computing_BiliBili.mp4\n    # 23. 屏幕&2D 图形显示-Screens&2D Graphics_BiliBili.mp4\n    filename = f\n    filename_array = filename.split('.')\n    number = filename_array[0] # 拿 1\n    suffix = filename_array[-1] # 拿 mp4\n    if suffix == 'mp4':\n        cmd = \"ffmpeg -ss 00:00:00 -i '{0}' -vframes 1 -q:v 2 {1}.jpg\".format(filename, number)\n        # 截图第一帧图片#\n        # {0} 是 input 文件名\n        # {1} 是输出的 jpg 名\n        os.system(cmd) # 执行"
        },
        {
          "name": "README-about-subtitle.md",
          "type": "blob",
          "size": 2.470703125,
          "content": "## 1. 关于公开字幕的一些说明\n公开字幕是为了方便大家学习   \n因为字幕是可以搜索的，而视频是没法搜索的   \n这里只公开了 txt 格式    \n\n* `(字幕)全40集中英字幕文本.txt`  这个 txt 文件\n* `(字幕)全40集中英字幕文本` 这个文件夹     \n\n都是用 Node.js 脚本从 .ass 字幕文件中提取出来的    \n\n## 2. 我们不会公开中英双语 .ass 字幕文件   \n\n因为大部分人都没做过字幕，我解释一下，翻译视频时，字幕是一个 .ass 文件   \n里面有字幕的样式，大小，颜色，时间轴（字幕的出现时间和消失时间）等等，我们用来做字幕的软件是 Aegisub    \n如果对字幕翻译有兴趣，可以看我做的教程：   \n\n[教程] 0基础入门字幕翻译（下载->翻译->压制, 教整个流程） @糖醋陈皮 制作   \nhttps://www.bilibili.com/video/av23046009     \n\n\n而视频的压制则是把 .mp4 视频视频和 .ass 字幕文件通过软件压制一下（我们是用小丸工具箱）   \n得到最后的成品（就是你在 B 站上看的那个）         \n\n因为国内目前环境不太好，我们之前遭遇过被中国电信的天翼把视频盗过去收费的事情        \n（请看如下的微博链接）     \nhttps://weibo.com/5237129097/Fy61opQ2B?from=page_1005055237129097_profile&wvr=6&mod=weibotime\nhttps://weibo.com/5237129097/Fy5UT1qaf?from=page_1005055237129097_profile&wvr=6&mod=weibotime&type=comment#_rnd1528465493854\nhttps://weibo.com/5237129097/FyfXvdVp8?from=page_1005055237129097_profile&wvr=6&mod=weibotime&type=comment#_rnd1528465495773\n\n而且，别忘了国内有很多垃圾自媒体（你在 B 站 App 的首页随便扫两下估计能看到3-4个）     \n所以如果把 .ass 文件放出来，对抄袭者来说成本就很低了，只需要把源视频下载一下，把 ass 字幕批量压制一下，   \n然后改个名字就可以说是自己的了，扯皮都扯不清楚。    \n\n所以 ass 字幕文件是不会放出来的。     \n\n## 3. 总结\n为了方便大家学习 + 防止抄袭者拿走然后低成本就变成自己的视频，所以放 txt 格式的文件     \n这里写这一堆只是为了给没做过字幕的同学一些小科普 + 解释为什么这么做      \n\n## 4. 最后\n参与字幕翻译的所有翻译君都是出于热爱 Crash Course，花费了大量个人时间免费翻译           \n希望大家好好学习~~    \n让自己变得更厉害，让这个世界变得更美好 ;)       \nDon't forget to be Awesome!    \n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.9208984375,
          "content": "## 计算机科学速成课 :fire: 2018年5月1号 - 全40集完结撒花\n\n### 精校版：      \nhttps://www.bilibili.com/video/av21376839/     \n\n<br/>\n\n![bilibili](/image/cs40.jpg)    \n\n## 字幕也放出来了(40集中英字幕)         \n两个版本：        \n\n* [所有字幕放一个文件里](./(字幕)全40集中英字幕文本.txt)       \n* [每一集一个文件，共40个文件](./(字幕)全40集中英字幕文本)  \n\n另外，片头总结在 **这篇文章的底部**  \n感谢观看，Don't forget to be Awesome!      \n\n## 感谢所有翻译人员！\n* 不想膨胀的小R - [Github](https://github.com/coolralf), [微博](https://weibo.com/u/2207493917), [B站](https://space.bilibili.com/5385034#!/video)\n* 糖醋陈皮 - [Github](https://github.com/1c7), [微博](https://weibo.com/2004104451), [博客](http://1c7.me/)\n* ZireHao - [B站](http://space.bilibili.com/27167876/)    \n* gilot - [B站](https://space.bilibili.com/43595622/)\n* 晴空\n* Crazycat\n* Cindy\n* 出门去\n* TMC - RN\n* LCAR979（推特 `_lincr_`）  \n\n## 高赞的课程学习笔记\n* [别人家的孩子小明](https://space.bilibili.com/528566) : [石墨文档(`首发`)](https://shimo.im/docs/vkCKkj3YxGtygrVg/)\n* [汉苍茫茫](https://space.bilibili.com/357394001) : [石墨文档(`很全`)](https://shimo.im/docs/PJAUY30F1uYksv0h/)\n* [GoogTech](https://space.bilibili.com/364361791) : [知识点脑图(`超详细`)](https://www.processon.com/view/link/61ef6e8f0e3e7439ae917672#map)\n\n### 第一版翻译（不推荐观看，看精校版即可）：\n* 1 - [早期的计算 - Early Computing](https://www.bilibili.com/video/av8861057/)\n* 2 - [电子计算 - Electronic Computing](https://www.bilibili.com/video/av9066628/)\n* 3 - [布尔逻辑与逻辑电路 - Boolean Logic & Logic Gates](https://www.bilibili.com/video/av11557339/)\n* 4 - [二进制 - Representing Numbers and Letters with Binary](https://www.bilibili.com/video/av11592079/)\n* 5 - [算术逻辑单元 - How Computers Calculate - the ALU](https://www.bilibili.com/video/av12742941/)\n* 6 - [寄存器 & 内存 - Registers and RAM](https://www.bilibili.com/video/av12881796/)\n* 7 - [中央处理器 - The Central Processing Unit(CPU)](https://www.bilibili.com/video/av12881976/)\n* 8 - [指令和程序 - Instructions & Programs](https://www.bilibili.com/video/av9875360/)\n* 9 -  [高级 CPU 设计 - Advanced CPU Designs](https://www.bilibili.com/video/av11867964/)\n* 10 - [编程史话 - Early Programming](https://www.bilibili.com/video/av13582556/)\n* 11 - [编程语言 - The First Programming Languages](https://www.bilibili.com/video/av14228148/)\n* 12 - [编程原理：语句和函数 - Programming Basics: Statements & Functions](https://www.bilibili.com/video/av14885759/)\n* 13 - [算法初步 - Intro to Algorithms](https://www.bilibili.com/video/av15987761/)\n* 14 - [数据结构 - Data Structures](https://www.bilibili.com/video/av15987774/)\n* 15 - [阿兰·图灵 - Alan Turing](https://www.bilibili.com/video/av16090115/)\n* 16 - [软件工程 - Software Engineering](https://www.bilibili.com/video/av16751202/)\n* 17 - [集成电路、摩尔定律 - Integrated Circuits & Moore’s Law](https://www.bilibili.com/video/av17186768)\n* 18 - [操作系统 - Operating Systems](https://www.bilibili.com/video/av17192468)\n* 19 - [内存 & 储存介质 - Memory & Storage](https://www.bilibili.com/video/av17192483/)\n* 20 - [文件系统 - Files & File Systems](https://www.bilibili.com/video/av17209268/)\n* 21 - [压缩 - Compression](https://www.bilibili.com/video/av17192511/)\n* 22 - [命令行界面 - Keyboards & Command Line Interfaces](https://www.bilibili.com/video/av17451718/)\n* 23 - [屏幕 & 2D 图形显示 - Screens & 2D Graphics](https://www.bilibili.com/video/av17476087/)\n* 24 - [冷战和消费主义 - The Cold War and Consumerism](https://www.bilibili.com/video/av15637307/)\n* 25 - [个人计算机革命 - The Personal Computer Revolution](https://www.bilibili.com/video/av18789303/)\n* 26 - [图形用户界面 - Graphical User Interfaces](https://www.bilibili.com/video/av19035296/)\n* 27 - [3D 图形 - 3D Graphics](https://www.bilibili.com/video/av19164942/)\n* 28 - [计算机网络 - Computer Networks](https://www.bilibili.com/video/av19209394/)\n* 29 - [互联网 - The Internet](https://www.bilibili.com/video/av20716104/)\n* 30 - [万维网 - The World Wide Web](https://www.bilibili.com/video/av20767130/)\n* 31 - [网络安全 - Cybersecurity](https://www.bilibili.com/video/av20785456/)\n* 32 - [黑客与攻击 - Hackers & Cyber Attacks](https://www.bilibili.com/video/av20831479/)\n* 33 - [加密 - Cryptography](https://www.bilibili.com/video/av20882310/)\n* 34 - [机器学习与人工智能 - Machine Learning & Artificial Intelligence](https://www.bilibili.com/video/av20922906)\n* 35 - [计算机视觉 - Computer Vision](https://www.bilibili.com/video/av20974735)\n* 36 - [自然语言处理 - Natural Language Processing](https://www.bilibili.com/video/av21004070)\n* 37 - [机器人 - Robots](https://www.bilibili.com/video/av21043523)\n* 38 - [计算机中的心理学 - Psychology of Computing](https://www.bilibili.com/video/av21066931)\n* 39 - [教育型科技 - Educational Technology](https://www.bilibili.com/video/av21103744)\n* 40 - [(完结) 奇点，天网，计算机的未来 - The Singularity, Skynet, and the Future of Computing](https://www.bilibili.com/video/av21126704)      \n\n精校版质量更好，建议看精校版，之所以第一版目录不删：      \n1. 方便快速扫视，看都聊什么话题     \n2. 方便翻阅之前的版本（如果有需要）        \n\n备注：精校负责人是 @糖醋陈皮\n\n## 翻译时间\n英文版：    \n第 1 集发布： 2017年2月22号    \n第 40 集发布：2017年12月21号     \n\n中文版：     \n第 1 集发布：  2017年2月27号  \n全 40 集翻译完成：2018年3月24号  \n全 40 集精校完成：2018年5月1号  \n\n\n### 原视频\n[Youtube - Crash Course Computer Science Playlist](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo)     \n![Crash Course CS screenshoht](/image/english.png)       \n\n\n# Thank you Crash Course & Carrie Anne!\n* Patron support Crash Course：https://www.patreon.com/crashcourse  <br/>\n* Crash Course website：https://thecrashcourse.com/\n* Youtube Crash Course: https://www.youtube.com/user/crashcourse\n\n# 感谢速成课！感谢 Carrie Anne！\n* Patron 支持 Crash Course：https://www.patreon.com/crashcourse  <br/>\n* Crash Course 官方网站：https://thecrashcourse.com/\n* Youtube Crash Course: https://www.youtube.com/user/crashcourse\n\n## 片头总结\n\n## 第 1 集：计算机早期历史  \n提到的设备：算盘 → 步进计算器 → 差分机 → 分析机 → 打孔卡片制表机  \n提到的人名：Charles Babbage, Ada Lovelace  \n\n02:27  最早的计算设备是算盘，举例如何使用  \n04:31  Computer 从指代职业变成指代机器  \n04:57  机器里有名的是：步进计算器。第一个可以做加减乘除的机器  \n06:44  炮弹为了精准，要计算弹道，二战是查表来做。但每次改设计了就需要做一张新表  \n07:30  Charles Babbage 提出了 &quot;差分机&quot;, 在构造差分机期间，想出了分析机, 分析机是通用计算机  \n08:50  Lovelace 给分析机写了假想程序，因此成为了第一位程序员  \n09:25  人口普查 10 年一次.  Herman Hollerith 的打孔卡片制表机大大提升了效率  \n\n\n## 第 2 集：电子计算机  \n提到的设备：继电器 → 真空管 → 晶体管  \n\n00:17  20世纪的发展要求更强的计算能力。柜子大小的计算机发展到房间大小  \n01:06  哈佛  Mark 1 号，IBM 1944 年做的  \n02:25  继电器，继电器一秒最多 50 次开关  \n03:24  继电器出 bug  \n03:49  1904 年，热电子管出现，第一个真空管。改进后变成和继电器的功能一样  \n05:34  &quot;巨人1号&quot; 计算机在英国 布莱切利园 首次大规模使用真空管。但编程麻烦，还要配置  \n06:40  1946 年，宾夕法尼亚大学的 ENIAC 是第一个通用可编程计算机  \n07:36  1947 年，贝尔实验室做出了晶体管，晶体管有诸多好处，IBM 很快全面转向晶体管  \n09:27  硅谷的典故：很多晶体管和半导体的开发都是这里做的。而生产半导体最常见的材料是硅  \n09:41  肖克利半导体 → 仙童半导体 → 英特尔  \n\n\n## 第 3 集：布尔逻辑和逻辑门  \n01:00  什么是二进制, 为什么用二进制, 布尔逻辑  \n02:46  3个基本操作：NOT，AND，OR  \n02:51  解释3个基本操作  \n07:11  XOR 异或  \n\n\n## 第 4 集：二进制  \n00:46  用十进制举例二进制的原理，演示二进制加法。存储单位 MB GB TB 等  \n05:30  正数，负数，整数，浮点数的表示  \n07:20  美国信息交换标准代码 - ASCII, 用来表示字符  \n09:00  UNICODE 1992 年诞生，是字符编码标准， 解决 ASCII 不够表达所有语言的问题  \n\n\n## 第 5 集：算数逻辑单元 - ALU  \n00:03  简单介绍 ALU ，英特尔 74181  \n01:24  ALU 有 2 个单元，1 个算术单元和 1 个逻辑单元  \n\n01:32  算术单元  \n半加器 (处理1个 bit，2个输入)  \n全加器 (处理1个 bit，3个输入)  \n8 bit 加法 (1个半加器，7个全加器）  \n溢出的概念，吃豆人的例子  \n乘法除法  \n\n07:32  逻辑单元  \n检测数字是否为 0 的电路（一堆 OR 门最后加个 NOT 门）  \nALU 抽象成一个 V 符号  \nFlag 标志（是否相等，是否小于，是否溢出等等）  \n\n\n## 第 6 集：寄存器和内存  \n本集重点是 Memory （存储 / 内存 两种含义）  \n\n03:30  存 1 位  (Gated Latch - 锁存器）  \n04:48  存 8 位  (Register - 寄存器)  \n\n05:46  16x16 的矩阵存 256 位  \n数据选择器/多路复用器 (Multiplexer) 解码 8 位地址，定位到单个锁存器  \n\n07:38  4 位代表行， 4 位代表列  \n\n08:16  组合 256 位内存 + 多路复用器  \n09:01  可寻址的 256 字节 内存  \n一条1980年代的内存，1M 大小  \n\n10:14  8个模块，每个模块有32个小方块，  \n每个小方块有 4 个小块，每个小块是 128 位 x 64 位  \n\n\n## 第 7 集：中央处理器（CPU)  \n重点  \n1. 拼个 CPU 出来  \n2. CPU 怎么执行命令  \n\n01:00  RAM + 寄存器 + ALU  做个 CPU  \n04:00  解释  &quot;取指令→解释→执行&quot; 这个循环  \n08:00  时钟是什么, 时钟速度和赫兹  \n10:00  超频提升性能, 降频省电  \n\n\n## 第 8 集：指令和程序  \n本集重点：一步步带你运行一遍程序  \n\n00:45  回顾上集的例子程序，一步步讲解。介绍”指令集”的概念  \nLOAD_A，LOAD_B，SUB，JUMP，ADD，HALT 等指令  \n05:16  带条件跳转，JUMP NEGATIVE 是负数才跳转，还有其他类型的 JUMP  \n08:00  真正现代 CPU 用更多指令集。位数更长。  \n09:07  1971年的英特尔 4004 处理器，有 46 个指令  \n09:36  如今英特尔酷睿 i7, 有上千条指令  \n\n\n\n## 第 9 集：高级 CPU 设计  \n00:24  早期是加快晶体管切换速度，来提升 CPU 速度  \n01:20  给 CPU 专门的除法电路 + 其他电路来做复杂操作，比如游戏，视频解码  \n02:28  给 CPU 加缓存，提高数据存取速度，更快喂给 CPU，用计算餐馆销售额举例  \n05:13  脏位 -  Dirty bit  \n05:33  流水线设计，用 1 个洗衣机和 1 个干燥机举例  \n06:01  并行处理 -  parallelize  \n07:33  乱序执行 -  out-of-order execution  \n08:21  推测执行 -  speculative execution  \n08:50  分支预测 -  branch prediction  \n09:34  多个 ALU  \n09:54  多核 (Core)  \n10:11  多个独立 CPU  \n10:52  超级计算机，中国的&quot;神威 太湖之光&quot;  \n\n\n## 第 10 集：早期的编程方式  \n本集重点：早期计算机如何编程  \n打孔纸卡 → 插线板 → 面板拨开关  \n\n00:00  开头说本集重点：程序如何进入计算机  \n00:53  拿纺织业举例，给机器编程的需求远在计算机出现前就有了  \n01:41  打孔纸卡 - Punched card  \n02:36  插线板 - Plugboard  \n04:20  冯诺依曼架构 - Von Neumann Architecture  \n07:00  面板编程 - Panel programming  \n07:29  第一款取得商业成功的家用计算机:  Altair 8800  \n08:15  编程依然很困难，人们需要更友好更简单的方式编程  \n08:44  下周主题：编程语言  \n\n\n## 第 11 集：编程语言发展史  \n编程：二进制 → 助记符（汇编器）→ A-0（编译器）→ FORTRAIN  \n\n01:45  二进制写程序，先纸上写伪代码，手工转二进制，很快就烦了  \n02:28  用 &quot;助记符” 写代码（LOAD_A 14）为了把助记符转二进制，汇编器诞生 (Assembler)  \n04:32  葛丽丝·霍普 (Grace Hopper)  - 哈佛1号计算机首批程序员, 海军军官  \n05:13  Grace 设计了编程语言 A-0  \n05:29  Grace 1952 年做了第一个编译器 (Compiler)，实现 A-0  \n06:29  变量 (Variables)  \n07:01  FORTRAN  \n08:18  COBOL  \n09:25  新语言  \n1960 年代：ALGOL，LISP，BASIC  \n1970 年代：Pascal，C，Smalltalk  \n1980 年代：C++，Objective-C，Perl  \n1990 年代：Python，Ruby，Java  \n\n\n## 第 12 集：编程基础 - 语句和函数  \n00:50  变量, 赋值语句  \n02:08  Grace Hopper 拍虫子游戏  \n02:52  if 判断  \n04:19  while 循环  \n05:48  for 循环  \n07:00  函数  \n11:11  下集介绍算法  \n\n\n## 第 13 集：算法入门  \n03:00  选择排序 - Selection sort  \n03:52  大 O 表示法 - Big O notation  \n04:31  归并排序 - Merge sort  \n08:03  Dijkstra 算法  \n\n\n## 第 14 集：数据结构  \n00:39   数组     - Array  \n02:06   字符串  - String  \n03:12   矩阵     - Matrix  \n04:05   结构体  - Struct  \n04:46   指针     - Pointer  \n04:44   节点     - Node  \n04:53   链表     - Linked List  \n06:21   队列     - Queue  \n06:21   栈        - Stack  \n07:31   树        - Tree  \n08:01   二叉树 - Binary Tree  \n08:26   图        - Graph  \n08:50   没时间讲红黑树和堆, 不同数据结构适用不同场景  \n\n\n## 第 15 集：阿兰·图灵  \n00:33   介绍图灵  \n00:52   可判定性问题  \n01:14   阿隆佐·丘奇，Lambda 算子  \n01:38   图灵机  \n04:54   停机问题  \n08:09   破解德军英格玛加密机  \n10:40   图灵测试  \n11:18   图灵的个人生活  \n12:07   图灵奖  \n\n\n## 第 16 集：软件工程  \n01:31  对象  Object  \n02:39  面向对象编程  Object Oriented Programming.  \n03:55  API  Application Programming Interface  \n04:33  public, private  \n05:36  集成开发环境, IDE - Integrated Development Environments  \n06:09  调试 debugging  \n06:31  文档和注释 - readme, comment  \n07:33  版本控制   Version control  \n08:50  质量控制   Quality Assurance testing，QA  \n09:21  Beta, Alpha  \n\n\n## 第 17 集：集成电路与摩尔定律  \n本集重点：晶圆的制作流程：光刻  (04:21~07:42)  \n\n00:51  分立元件  Discrete components  \n01:09  数字暴政  Tyranny of Numbers - 是 1960 年代工程师碰到的问题  \n意思是如果想加强电脑性能，就要更多部件，这导致更多线路，更复杂。所以很难做  \n04:21  光刻         Photolithography  \n04:26  晶圆         Wafer  \n04:57  光刻胶     Photoresist  \n05:08  光掩膜     Photomask  \n06:00  掺杂         Doping  \n09:09  摩尔定律   Moore’s Law.  \n09:38  英特尔      Intel  \n10:20  晶体管数量大幅度增长, 1980年三万个，1990年一百万个，2000年三千万个，2010年十亿个  \n11:44  进一步小型化会碰到 2 个问题  1. 光的波长不足以制作更精细的设计  2. 量子隧穿效应  \n\n\n## 第 18 集：操作系统  \n00:48  操作系统  Operating systems  \n01:34  批处理     Batch processing  \n01:58  计算机变便宜变多，有不同配置，写程序处理不同硬件细节很痛苦，因此操作系统负责抽象硬件  \n02:12  外部设备         Peripherals  \n02:48  设备驱动程序   Device drivers  \n04:43  多任务处理      Multitasking  \n05:54  虚拟内存         Virtual Memory  \n07:09  动态内存分配  Dynamic memory allocation  \n07:31  内存保护         Memory Protection  \n07:54  1970年代，计算机足够便宜，大学买了让学生用，多个学生用多个 &quot;终端&quot; 连接到主机  \n08:29  多用户分时操作系统，Multics  \n09:32  Unix  \n11:02  MS-DOS  \n12:09  下集是内存&amp;存储介质  \n\n\n## 第 19 集：内存&amp;储存介质  \n本集重点：存储技术的发展  \n\n01:01  纸卡                Paper punch cards  \n02:01  延迟线存储器  Delay Line Memory  \n04:06  磁芯               Magnetic Core Memory  \n06:08  磁带               Magnetic Tape  \n07:08  磁鼓               Magnetic Drum Memory  \n07:43  硬盘               Hard Disk Drives  \n08:53  内存层次结构  Memory Hierarchy  \n09:36  软盘                Floppy Disk  \n10:09  光盘                Compact Disk  \n10:51  固态硬盘         Solid State Drives  \n\n\n## 第 20 集：文件系统  \n00:47  文件格式：可以随便存文件数据，但按格式存会更方便  \n01:00  TXT   文本文件：ASCII  \n01:31  WAV 音频文件：每秒上千次的音频采样数字  \n02:47  BMP  图片文件：像素的红绿蓝 RGB 值  \n04:43  文件系统：很早期时空间小，整个存储器就像一整个文件。后来随容量增长，多文件非常必要  \n05:37  目录文件：用来解决多文件问题，存其他文件的信息，比如开头，结尾，创建时间等  \n\n06:39  平面文件系统 - Flat File System：文件都在同一个层次，早期空间小，只有十几个文件，平面系统够用  \n\n06:57  如果文件紧密的一个个前后排序会造成问题，所以文件系统会： 1. 把空间划分成一块块  2. 文件拆分存在多个块里  \n\n08:30  文件的增删改查会不可避免的造成文件散落在各个块里，  \n如果是磁带这样的存储介质就会造成问题，所以做碎片整理  \n\n09:46  分层文件系统 - Hierarchical File System：有不同文件夹，文件夹可以层层嵌套  \n\n第21集讲压缩  \n\n\n## 第 21 集：压缩  \n00:26  压缩的好处是能存更多文件，传输也更快  \n01:52  游程编码   Run-Length Encoding  \n02:45  无损压缩   Lossless compression  \n03:55  霍夫曼树   Huffman Tree  \n05:56  &quot;消除冗余&quot;和&quot;用更紧凑的表示方法&quot;，这两种方法通常会组合使用  \n06:07  字典编码   Dictionary coders,  游程编码 和 字典编码 都是无损压缩  \n08:03  感知编码   Perceptual coding  \n08:09  有损压缩   jpeg 格式  \n09:39  时间冗余   Temporal redundancy  \n10:30  MPEG-4 视频编码  \n\n\n## 第 22 集：命令行界面  \n本集重点：计算机早期同时输入程序和数据（用纸卡/纸带）  \n运行开始直到结束，中间没有人类进行操作，  \n原因是计算机很贵，不能等人类慢慢输入，执行完结果打印到纸上 (02:34)  \n\n到1950年代，计算机足够便宜+快，人类和计算机交互式操作变得可行  \n为了让人类输入到计算机，改造之前就有的打字机，变成电传打字机 (02:44~05:38)  \n\n到1970年代末，屏幕成本足够低，屏幕代替电传打字机，屏幕成为标配 (07:24)  \n\n00:32  人机交互  Human-Computer Interaction  \n00:50  早期输出数据是打印到纸上，而输入是用纸卡/纸带一次性把程序和数据都给进去  \n03:00  QWERTY  打字机的发展，克里斯托弗·莱瑟姆·肖尔斯 发明于 1868 年  \n05:38  电传打字机  Teletype machine  \n06:32  命令行界面  Command line interface  \n06:38  ls 命令  \n08:22  早期文字游戏  Zork  (1977年)  \n08:47  cd 命令  \n\n\n## 第 23 集：屏幕与 2D 图形显示  \n00:05   PDP-1 计算机。键盘和显示器分开，屏幕显示临时值  \n01:14   阴极射线管  Cathode Ray Tube (CRT)  \n01:38   CRT 有两种绘图方式：  \n矢量扫描  Vector Scanning  \n光栅扫描  Raster Scanning  \n\n02:14   液晶显示器   Liquid Crystal Displays (LCD)，像素 (Pixel)  \n03:32   字符生成器   Character generator  \n03:45   屏幕缓冲区   Screen buffer  \n05:09   矢量命令画图  \n06:34   Sketchpad,  光笔 (Light pen)  \n09:00   函数画线，矩形  \n\n\n## 第 24 集：冷战和消费主义  \n本集重点：冷战导致美国往计算机领域投入大量资源  (00:00~01:43)  \n\n范内瓦·布什 预见了计算机的潜力，提出假想机器 Memex  \n帮助建立 国家科学基金会，给科学研究提供资金  (01:43~03:43)  \n\n1950 年代消费者开始买晶体管设备，收音机大卖  \n日本取得晶体管授权后，索尼做了晶体管收音机，为日本半导体行业崛起埋下种子 (03:43~04:29）  \n\n苏联 1961 年把宇航员加加林送上太空，导致美国提出登月  \nNASA 预算大大增加，用集成电路来制作登月计算机 (04:29~06:27)  \n\n集成电路的发展实际上是由军事应用大大推进的，阿波罗登月毕竟只有 17 次  \n美国造超级计算机进一步推进集成电路 (04:29~07:11)  \n\n美国半导体行业一开始靠政府高利润合同活着，忽略消费者市场，1970年代冷战渐消，行业开始衰败  \n很多公司倒闭，英特尔转型处理器 (07:11~08:23)  \n\n末尾总结：政府和消费者推动了计算机的发展  \n早期靠政府资金，让技术发展到足够商用，然后消费者购买商用产品继续推动产品发展 (08:23~10:41)  \n\n\n## 第 25 集：个人计算机革命  \n本集：全是历史故事  \n00:18   1970年代初成本下降，个人计算机变得可行  \n01:51   Altair 8800  \n02:32   比尔·盖茨 和 保罗·艾伦写 BASIC 解释器  \n03:45   乔布斯提议卖组装好的计算机，Apple-I 诞生  \n04:40   1977年出现3款开箱即用计算机：  \n&quot;Apple-II&quot;，&quot;TRS-80 Model I&quot;，&quot;Commodore PET 2001&quot;  \n\n06:26   IBM 意识到个人计算机市场  \nIBM PC 发布，采用开放架构，兼容的机器都叫 IBM Compatible (IBM 兼容)  \n生态系统产生雪球效应：  \n因为用户多，软硬件开发人员更愿意花精力在这个平台  \n因为软硬件多，用户也更乐意买 &quot;IBM 兼容&quot; 的计算机  \n\n08:44   苹果选封闭架构，一切都自己来，只有苹果在非  &quot;IBM 兼容&quot; 下保持了足够市场份额  \n\n\n## 第 26 集：图形用户界面 (GUI)  \n01:10  图形界面先驱：道格拉斯·恩格尔巴特（Douglas Engelbart）  \n03:20  1970年成立 帕洛阿尔托研究中心（Palo Alto Research Center）  \n03:29  1973年完成 Xerox Alto(施乐奥托) 计算机  \n04:42  举例：写一个简单的 GUI 程序  \n06:38  1981年的 Xerox Star system(施乐之星系统)  \n08:18  史蒂夫·乔布斯去施乐参观  \n07:45  所见即所得 WYSIWYG  \n09:15  1983年推出 Apple Lisa  \n09:31  1984年推出 Macintosh  \n10:12  1985年推出 Windows 1.0，之后出到 3.1  \n10:43  1995年推出 Windows 95 提供图形界面  \n11:08  1995年微软做失败的 Microsoft Bob  \n\n\n## 第 27 集：3D 图形  \n01:15   线框渲染  Wireframe Rendering  \n01:39   正交投影  Orthographic Projection  \n01:50   透视投射  Perspective Projection  \n02:14   网格  Mesh  \n02:37   三角形更常用因为能定义唯一的平面  \n03:09   扫描线渲染  Scanline Rendering  \n05:04   遮挡            Occlusion  \n05:19   画家算法     Painter&apos;s Algorithm  \n06:09   深度缓冲      Z Buffering  \n07:45   Z Fighting 错误  \n07:51   背面剔除      Back Face Culling  \n08:53   表面法线      Surface Normal  \n09:33   平面着色      Flat Shading  \n09:43   高洛德着色   Gouraud shading,  冯氏着色  Phong Shading  \n10:06   纹理映射      Texture Mapping  \n11:24   图形处理单元  GPU, Graphics Processing Unit  \n\n\n## 第 28 集：计算机网络  \n02:05   局域网   Local Area Networks - LAN  \n02:36   媒体访问控制地址   Media Access Control address - MAC  \n02:55   载波侦听多路访问   Carrier Sense Multiple Access - CSMA  \n05:18   指数退避   Exponential Backoff  \n05:36   冲突域       Collision Domain  \n07:08   电路交换   Circuit Switching  \n07:36   报文交换   Message Switching  \n10:20   分组交换   Packet Switching  \n\n\n## 第 29 集：互联网  \n02:23  IP - 互联网协议 - Internet Protocol  \n03:00  UDP - 用户数据报协议 - User Datagram Protocol  \n03:41  校验和 - Checksum  \n05:26  TCP - 传输控制协议 - Transmission Control Protocol  \n08:21  DNS - 域名系统 - Domain Name System  \n10:47  OSI - 开放式系统互联通信参考模型 - Open System Interconnection  \n\n\n## 第 30 集：万维网  \n01:01  超链接  Hyperlinks  \n02:20  URL - 统一资源定位器 - Uniform Resource Locator  \n03:01  HTTP - 超文本传输协议 -  HyperText Transfer Protocol  \n04:13  HTML - 超文本标记语言  - HyperText Markup Language  \n04:24  写一个简单网页，用到了 &lt;h1&gt; &lt;a&gt; &lt;h2&gt; &lt;ol&gt; &lt;li&gt; 标签  \n06:04  第一个浏览器和服务器是 Tim Berners-Lee 花了 2 个月在 CERN 写的  \n06:32  1991年正式发布，万维网就此诞生  \n07:19  开始讲搜索引擎的故事  \n07:40  Jerry 和 David 的万维网指南 后来改名成 Yahoo  \n07:52  搜索引擎  JumpStation  \n09:07  搜索引擎  Google  \n09:20  网络中立性  \n\n\n## 第 31 集：计算机安全  \n01:00   Secrecy, Integrity, Availability  \n保密性, 完整性, 可用性  \n01:49   Threat Model 威胁模型  \n\n03:14   身份验证 (Authentication) 的三种方式：  \nWhat you know, 你知道什么  \nWhat you have, 你有什么  \nWhat you are, 你是什么  \n\n07:34   访问控制   Access Control  \n08:48   Bell LaPadula model  不能向上读取，不能向下写入  \n11:00   隔离 Isolation, 沙盒 Sandbox  \n\n\n## 第 32 集：黑客与攻击  \n01:28  社会工程学   Social Engineering  \n01:38  钓鱼             Phishing  \n02:06  假托             Pretexting  \n02:50  木马             Trojan Horses  \n03:32  NAND镜像  NAND Mirroring  \n04:12  漏洞利用      Exploit  \n04:16  缓冲区溢出   Buffer Overflow  \n05:45  边界检查      Bounds Checking  \n06:16  代码注入      Code Injection  \n09:32  零日漏洞      Zero Day Vulnerability  \n09:53  计算机蠕虫   Worms  \n09:58  僵尸网络      Botnet  \n10:11  拒绝服务攻击   DDoS  \n\n\n## 第 33 集：加密  \n00:16  多层防御  Defence in depth  \n01:00  加密 - Encryption，解密 - Decryption  \n01:11  凯撒加密  Caesar cipher  \n01:27  替换加密  Substitution cipher  \n01:59  移位加密  Permutation cipher  \n02:03  列移位加密  Columnar transposition cipher  \n02:37  德国 Enigma 加密机  \n04:54  1977年&quot;数据加密标准&quot; - Data Encryption Standard (DES)  \n05:24  2001年&quot;高级加密标准&quot; - Advanced Encryption Standard (AES)  \n07:06  密钥交换 - Key exchange  \n07:33  用颜色来举例&quot;单向函数&quot;和&quot;密钥加密&quot;的原理  \n08:24  迪菲-赫尔曼密钥交换 - Diffie-Hellman Key Exchange  \n10:18  非对称加密 - Asymmetric encryption  \n11:22  非对称加密算法  RSA  \n\n\n## 第 34 集：机器学习与人工智能  \n01:23   分类              Classification  \n01:25   分类器           Classifier  \n01:34   特征               Feature  \n02:03   标记数据        Labeled data  \n02:38   决策边界        Decision boundaries  \n03:00   混淆矩阵        Confusion matrix  \n03:39   未标签数据     Unlabeled data  \n03:49   决策树            Decision tree  \n04:25   支持向量机     Support Vector Machines  \n05:52  人工神经网络   Artificial Neural Network  \n08:34  深度学习         Deep learning  \n09:21  弱AI, 窄AI      Weak AI, Narrow AI  \n09:43  强AI               Strong AI  \n10:42  强化学习         Reinforcement Learning  \n\n\n## 第 35 集：计算机视觉  \n02:41  检测垂直边缘的算法  \n03:26  核/过滤器  kernel or filter  \n03:56  卷积 convolution  \n04:23  Prewitt 算子   Prewitt Operators  \n05:34  维奥拉·琼斯 人脸检测   Viola-Jones Face Detection  \n05:35  卷积神经网络   Convolutional Neural Networks  \n07:33  识别出脸之后，可以进一步用其他算法定位面部标志，如眼睛和眉毛具体位置，从而判断心情等信息  \n08:52  跟踪全身的标记点，如肩部，手臂等  \n\n\n## 第 36 集：自然语言处理  \n01:50  词性                   Parts of speech  \n02:15  短语结构规则      Phrase structure rules  \n02:32  分析树                Parse tree  \n05:30  语音识别             Speech recognition  \n07:26  谱图                    Spectrogram  \n07:44  快速傅立叶变换   Fast Fourier Transform  \n08:42  音素                   Phonemes  \n09:29   语音合成           Speech Synthesis  \n\n\n## 第 37 集：机器人  \n02:08  法国吃饭鸭 - Digesting Duck, Canard Digerateur  \n02:23  土耳其行棋傀儡, 下国际象棋  \n02:43  第一台计算机控制的机器出现在1940年代晚期，叫数控机器, Computer Numerical Control(CNC)  \n03:32  1960年 Unimate，第一个商业贩卖的 可编程工业机器人  \n03:47  简单控制回路  simple control loop  \n04:08  负反馈回路  negative feedback loop  \n05:17  比例-积分-微分控制器   Proportional–Integral–Derivative controller   PID 控制器  \n10:48  机器人三定律   Three Laws of Robotics  \n\n\n## 第 38 集：计算机心理学  \n00:45  我们需要了解人类心理学，做出更好的计算机  \n01:12  易用度 - Usability  \n01:31  颜色强度排序 和 颜色排序  \n02:30  分组更好记，电话号码 317-555-3897 比 3175553897 好记  \n03:25  直观功能 - Affordances  \n04:33  认出 vs 回想 Recognition vs Recall  \n05:45  让机器有一定情商以及 Facebook 的研究  \n08:40  用软件修正注视位置。让视频通话时看起来像盯着对方，而不是盯着下方  \n09:58  把机器人做的像人，恐怖谷理论  \n11:35  有很多开放式的问题，心理学帮助我们明白不同选择可能带来的影响  \n\n\n## 第 39 集：教育科技  \n02:15  通过调速，暂停等技巧，加强学习效率  \n03:15  大型开放式在线课程  - Massive Open Online Courses  (MOOC)  \n05:08  智能辅导系统 - Intelligent Tutoring Systems  \n05:22  判断规则 - Production rule  \n06:10  域模型 - Domain Model  \n06:46  贝叶斯知识追踪  Bayesian knowledge tracing  \n1. 学生已经学会的概率  \n2. 瞎猜的概率  \n3. 失误的概率  \n4. 做题过程中学会的概率  \n09:27  教育数据挖掘  Educational Data Mining  \n\n\n## （完结）第 40 集：奇点，天网，计算机的未来  \n01:21  普适计算  Ubiquitous Computing  \n04:55  奇点         Singularity  \n06:51  把工作分为4个象限，讨论自动化带来的影响  \n10:15  机器人的存在时间可能长过人类，可以长时间探索宇宙  \n"
        },
        {
          "name": "extract_from_ass_subtitle",
          "type": "tree",
          "content": null
        },
        {
          "name": "image",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}