{
  "metadata": {
    "timestamp": 1736563242836,
    "page": 212,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hapijs/hapi",
      "stars": 14653,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.10546875,
          "content": "**/node_modules\n**/package-lock.json\n\ncoverage.*\n\n**/.DS_Store\n**/._*\n\n**/*.pem\n\n**/.vs\n**/.vscode\n**/.idea\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.01171875,
          "content": "save=false\n\n"
        },
        {
          "name": "API.md",
          "type": "blob",
          "size": 192.9990234375,
          "content": "\n## Server\n\nThe server object is the main application container. The server manages all incoming requests\nalong with all the facilities provided by the framework. Each server supports a single connection\n(e.g. listen to port `80`).\n\n### <a name=\"server()\" /> `server([options])`\n\nCreates a new server object where:\n- `options` - (optional) a [server configuration object](#server.options).\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nconst server = Hapi.server({ load: { sampleInterval: 1000 } });\n```\n\n### <a name=\"server.options\" /> Server options\n\nThe server options control the behavior of the server object. Note that the options object is\ndeeply cloned (with the exception of [`listener`](#server.options.listener) which is shallowly\ncopied) and should not contain any values that are unsafe to perform deep copy on.\n\nAll options are optionals.\n\n#### <a name=\"server.options.address\" /> `server.options.address`\n\nDefault value: `'::'` if IPv6 is available, otherwise `'0.0.0.0'` (i.e. all available network interfaces).\n\nSets the hostname or IP address the server will listen on. If not configured, defaults to\n[`host`](#server.options.host) if present, otherwise to all available network interfaces. Set to\n`'127.0.0.1'`, `'::1'`, or `'localhost'` to restrict the server to only those coming from the same host.\n\n#### <a name=\"server.options.app\" /> `server.options.app`\n\nDefault value: `{}`.\n\nProvides application-specific configuration which can later be accessed via\n[`server.settings.app`](#server.settings). The framework does not interact with this object. It is\nsimply a reference made available anywhere a `server` reference is provided.\n\nNote the difference between `server.settings.app` which is used to store static configuration\nvalues and [`server.app`](#server.app) which is meant for storing run-time state.\n\n#### <a name=\"server.options.autolisten\" /> `server.options.autoListen`\n\nDefault value: `true`.\n\nUsed to disable the automatic initialization of the [`listener`](#server.options.listener). When\n`false`, indicates that the [`listener`](#server.options.listener) will be started manually outside\nthe framework.\n\nCannot be set to `false` along with a [`port`](#server.options.port) value.\n\n#### <a name=\"server.options.cache\" /> `server.options.cache`\n\nDefault value: `{ provider: { constructor: require('@hapi/catbox-memory'), options: { partition: 'hapi-cache' } } }`.\n\nSets up server-side caching providers. Every server includes a default cache for storing\napplication state. By default, a simple memory-based cache is created which has limited capacity\nand capabilities.\n\n**hapi** uses [**catbox**](https://hapi.dev/family/catbox/api) for its cache implementation which\nincludes support for common storage solutions (e.g. Redis, MongoDB, Memcached, Riak, among others).\nCaching is only utilized if [methods](#server.methods) and [plugins](#plugins) explicitly store\ntheir state in the cache.\n\nThe server cache configuration only defines the storage container itself. The configuration can be\nassigned one or more (array):\n\n- a class or prototype function (usually obtained by calling `require()` on a **catbox** strategy\n    such as `require('@hapi/catbox-redis')`). A new **catbox** [client](https://hapi.dev/family/catbox/api#client)\n    will be created internally using this constructor.\n\n- a configuration object with the following:\n\n    - `engine` - a **catbox** engine object instance.\n\n    - `name` - an identifier used later when provisioning or configuring caching for\n        [server methods](#server.methods) or [plugins](#plugins). Each cache name must be unique.\n        A single item may omit the `name` option which defines the default cache. If every cache\n        includes a `name`, a default memory cache is provisioned as well.\n\n    - `provider` - a class, a constructor function, or an object with the following:\n\n        - `constructor` - a class or a prototype function.\n\n        - `options` - (optional) a settings object passed as-is to the `constructor` with the following:\n\n            - `partition` - (optional) string used to isolate cached data. Defaults to `'hapi-cache'`.\n            - other constructor-specific options passed to the `constructor` on instantiation.\n\n    - `shared` - if `true`, allows multiple cache users to share the same segment (e.g.\n        multiple methods using the same cache storage container). Default to `false`.\n\n    - One (and only one) of `engine` or `provider` is required per configuration object.\n\n#### <a name=\"server.options.compression\" /> `server.options.compression`\n\nDefault value: `{ minBytes: 1024 }`.\n\nDefines server handling of content encoding requests. If `false`, response content encoding is\ndisabled and no compression is performed by the server.\n\n##### <a name=\"server.options.compression.minBytes\" /> `server.options.compression.minBytes`\n\nDefault value: '1024'.\n\nSets the minimum response payload size in bytes that is required for content encoding compression.\nIf the payload size is under the limit, no compression is performed.\n\n#### <a name=\"server.options.debug\" /> `server.options.debug`\n\nDefault value: `{ request: ['implementation'] }`.\n\nDetermines which logged events are sent to the console. This should only be used for development\nand does not affect which events are actually logged internally and recorded. Set to `false` to\ndisable all console logging, or to an object with:\n\n- `log` - a string array of server log tags to be displayed via `console.error()` when\n    the events are logged via [`server.log()`](#server.log()) as well as\n    internally generated [server logs](#server-logs). Defaults to no output.\n\n- `request` - a string array of request log tags to be displayed via `console.error()` when\n    the events are logged via [`request.log()`](#request.log()) as well as\n    internally generated [request logs](#request-logs). For example, to display all errors,\n    set the option to `['error']`. To turn off all console debug messages set it to `false`.\n    To display all request logs, set it to `'*'`.\n    Defaults to uncaught errors thrown in external code (these errors are handled\n    automatically and result in an Internal Server Error response) or runtime errors due to\n    developer error.\n\nFor example, to display all errors, set the `log` or `request` to `['error']`. To turn off all\noutput set the `log` or `request` to `false`. To display all server logs, set the `log` or\n`request` to `'*'`. To disable all debug information, set `debug` to `false`.\n\n#### <a name=\"server.options.host\" /> `server.options.host`\n\nDefault value: the operating system hostname and if not available, to `'localhost'`.\n\nThe public hostname or IP address. Used to set [`server.info.host`](#server.info) and\n[`server.info.uri`](#server.info) and as [`address`](#server.options.address) if none is provided.\n\n#### <a name=\"server.options.info.remote\" /> `server.options.info.remote`\n\nDefault value: `false`.\n\nIf `true`, the `request.info.remoteAddress` and `request.info.remotePort` are populated when the request is received which can consume more resource (but is ok if the information is needed, especially for aborted requests). When `false`, the fields are only populated upon demand (but will be `undefined` if accessed after the request is aborted).\n\n#### <a name=\"server.options.listener\" /> `server.options.listener`\n\nDefault value: none.\n\nAn optional node HTTP (or HTTPS) [`http.Server`](https://nodejs.org/api/http.html#http_class_http_server)\nobject (or an object with a compatible interface).\n\nIf the `listener` needs to be manually started, set [`autoListen`](#server.options.autolisten) to\n`false`.\n\nIf the `listener` uses TLS, set [`tls`](#server.options.tls) to `true`.\n\n#### <a name=\"server.options.load\" /> `server.options.load`\n\nDefault value: `{ sampleInterval: 0, maxHeapUsedBytes: 0, maxRssBytes: 0, maxEventLoopDelay: 0, maxEventLoopUtilization: 0 }`.\n\nServer excessive load handling limits where:\n\n- `sampleInterval` - the frequency of sampling in milliseconds. When set to `0`, the other load options are ignored. Defaults to `0` (no sampling).\n\n- `maxHeapUsedBytes` - maximum V8 heap size over which incoming requests are rejected with an HTTP Server Timeout (503) response. Defaults to `0` (no limit).\n\n- `maxRssBytes` - maximum process RSS size over which incoming requests are rejected with an HTTP Server Timeout (503) response. Defaults to `0` (no limit).\n\n- `maxEventLoopDelay` - maximum event loop delay duration in milliseconds over which incoming requests are rejected with an HTTP Server Timeout (503) response. Defaults to `0` (no limit).\n\n- `maxEventLoopUtilization` - maximum event loop utilization value over which incoming requests are rejected with an HTTP Server Timeout (503) response. Defaults to `0` (no limit).\n\n#### <a name=\"server.options.mime\" /> `server.options.mime`\n\nDefault value: none.\n\nOptions passed to the [**mimos**](https://hapi.dev/family/mimos/api) module when generating the mime database used by the server (and accessed via [`server.mime`](#server.mime)):\n\n- `override` - an object hash that is merged into the built in mime information specified [here](https://github.com/jshttp/mime-db). Each key value pair represents a single mime object. Each override value must contain:\n\n    - `key` - the lower-cased mime-type string (e.g. `'application/javascript'`).\n\n    - `value` - an object following the specifications outlined [here](https://github.com/jshttp/mime-db#data-structure). Additional values include:\n\n        - `type` - specify the `type` value of result objects, defaults to `key`.\n\n        - `predicate` - method with signature `function(mime)` when this mime type is found in the database, this function will execute to allows customizations.\n\n```js\nconst options = {\n    mime: {\n        override: {\n            'node/module': {\n                source: 'iana',\n                compressible: true,\n                extensions: ['node', 'module', 'npm'],\n                type: 'node/module'\n            },\n            'application/javascript': {\n                source: 'iana',\n                charset: 'UTF-8',\n                compressible: true,\n                extensions: ['js', 'javascript'],\n                type: 'text/javascript'\n            },\n            'text/html': {\n                predicate: function(mime) {\n                    if (someCondition) {\n                        mime.foo = 'test';\n                    }\n                    else {\n                        mime.foo = 'bar';\n                    }\n                    return mime;\n                }\n            }\n        }\n    }\n};\n```\n\n#### <a name=\"server.options.operations\" /> `server.options.operations`\n\nDefault value: `{ cleanStop: true }`.\n\nDefines server handling of server operations:\n\n- `cleanStop` - if `true`, the server keeps track of open connections and properly closes them\n  when the server is stopped. Under normal load, this should not interfere with server performance.\n  However, under severe load connection monitoring can consume additional resources and aggravate\n  the situation. If the server is never stopped, or if it is forced to stop without waiting for\n  open connection to close, setting this to `false` can save resources that are not being utilized\n  anyway. Defaults to `true`.\n\n#### <a name=\"server.options.plugins\" /> `server.options.plugins`\n\nDefault value: `{}`.\n\nPlugin-specific configuration which can later be accessed via [`server.settings.plugins`](#server.settings).\n`plugins` is an object where each key is a plugin name and the value is the configuration.\nNote the difference between [`server.settings.plugins`](#server.settings) which is used to store\nstatic configuration values and [`server.plugins`](#server.plugins) which is meant for storing\nrun-time state.\n\n#### <a name=\"server.options.port\" /> `server.options.port`\n\nDefault value: `0` (an ephemeral port).\n\nThe TCP port the server will listen to. Defaults the next available port when the server is started\n(and assigned to [`server.info.port`](#server.info)).\n\nIf `port` is a string containing a '/' character, it is used as a UNIX domain socket path.\nIf it starts with '\\\\.\\pipe', it is used as a Windows named pipe.\n\n#### <a name=\"server.options.query\" /> `server.options.query`\n\nDefault value: `{}`.\n\nDefines server handling of the request path query component.\n\n##### <a name=\"server.options.query.parser\" /> `server.options.query.parser`\n\nDefault value: none.\n\nSets a query parameters parser method using the signature `function(query)` where:\n\n- `query` - an object containing the incoming [`request.query`](#request.query) parameters.\n- the method must return an object where each key is a parameter and matching value is the\n  parameter value. If the method throws, the error is used as the response or returned when\n  [`request.setUrl()`](#request.setUrl()) is called.\n\n```js\nconst Qs = require('qs');\n\nconst options = {\n    query: {\n        parser: (query) => Qs.parse(query)\n    }\n};\n```\n\n#### <a name=\"server.options.router\" /> `server.options.router`\n\nDefault value: `{ isCaseSensitive: true, stripTrailingSlash: false }`.\n\nControls how incoming request URIs are matched against the routing table:\n\n- `isCaseSensitive` - determines whether the paths '/example' and '/EXAMPLE' are considered\n  different resources. Defaults to `true`.\n\n- `stripTrailingSlash` - removes trailing slashes on incoming paths. Defaults to `false`.\n\n#### <a name=\"server.options.routes\" /> `server.options.routes`\n\nDefault value: none.\n\nA [route options](#route-options) object used as the default configuration for every route.\n\n#### <a name=\"server.options.state\" /> `server.options.state`\n\nDefault value:\n```js\n{\n    strictHeader: true,\n    ignoreErrors: false,\n    isSecure: true,\n    isHttpOnly: true,\n    isSameSite: 'Strict',\n    encoding: 'none'\n}\n```\n\nSets the default configuration for every state (cookie) set explicitly via\n[`server.state()`](#server.state()) or implicitly (without definition) using the\n[state configuration](#server.state()) object.\n\n#### <a name=\"server.options.tls\" /> `server.options.tls`\n\nDefault value: none.\n\nUsed to create an HTTPS connection. The `tls` object is passed unchanged to the node\nHTTPS server as described in the [node HTTPS documentation](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener).\n\nSet to `true` when passing a [`listener`](#server.options.listener) object that has been configured\nto use TLS directly.\n\n#### <a name=\"server.options.uri\" /> `server.options.uri`\n\nDefault value: constructed from runtime server information.\n\nThe full public URI without the path (e.g. 'http://example.com:8080'). If present, used as the\nserver [`server.info.uri`](#server.info), otherwise constructed from the server settings.\n\n### Server properties\n\n#### <a name=\"server.app\" /> `server.app`\n\nAccess: read / write.\n\nProvides a safe place to store server-specific run-time application data without potential\nconflicts with the framework internals. The data can be accessed whenever the server is\naccessible. Initialized with an empty object.\n\n```js\nconst server = Hapi.server();\n\nserver.app.key = 'value';\n\nconst handler = function (request, h) {\n\n    return request.server.app.key;        // 'value'\n};\n```\n\n#### <a name=\"server.auth.api\" /> `server.auth.api`\n\nAccess: authentication strategy specific.\n\nAn object where each key is an authentication strategy name and the value is the exposed strategy\nAPI. Available only when the authentication scheme exposes an API by returning an `api` key in the\nobject returned from its implementation function.\n\n```js\nconst server = Hapi.server({ port: 80 });\n\nconst scheme = function (server, options) {\n\n    return {\n        api: {\n            settings: {\n                x: 5\n            }\n        },\n        authenticate: function (request, h) {\n\n            const authorization = request.headers.authorization;\n            if (!authorization) {\n                throw Boom.unauthorized(null, 'Custom');\n            }\n\n            return h.authenticated({ credentials: { user: 'john' } });\n        }\n    };\n};\n\nserver.auth.scheme('custom', scheme);\nserver.auth.strategy('default', 'custom');\n\nconsole.log(server.auth.api.default.settings.x);    // 5\n```\n\n#### <a name=\"server.auth.settings.default\" /> `server.auth.settings.default`\n\nAccess: read only.\n\nContains the default authentication configuration if a default strategy was set via\n[`server.auth.default()`](#server.auth.default()).\n\n#### <a name=\"server.decorations\" /> `server.decorations`\n\nAccess: read only.\n\nProvides access to the decorations already applied to various framework interfaces. The object must\nnot be modified directly, but only through [`server.decorate`](#server.decorate()).\nContains:\n\n- `request` - decorations on the [request object](#request).\n- `response` - decorations on the [response object](#response-object).\n- `toolkit` - decorations on the [response toolkit](#response-toolkit).\n- `server` - decorations on the [server](#server) object.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst success = function () {\n\n    return this.response({ status: 'ok' });\n};\n\nserver.decorate('toolkit', 'success', success);\nconsole.log(server.decorations.toolkit);            // ['success']\n```\n\n#### <a name=\"server.events\" /> `server.events`\n\nAccess: **podium** public interface.\n\nThe server events emitter. Utilizes the [**podium**](https://hapi.dev/family/podium/api) with support\nfor event criteria validation, channels, and filters.\n\nUse the following methods to interact with `server.events`:\n\n- [`server.event(events)`](#server.event()) - register application events.\n- [`server.events.emit(criteria, data)`](#server.events.emit()) - emit server events.\n- [`server.events.on(criteria, listener, context)`](#server.events.on()) - subscribe to all events.\n- [`server.events.once(criteria, listener, context)`](#server.events.once()) - subscribe to a single event.\n\nOther methods include: `server.events.removeListener(name, listener)`,\n`server.events.removeAllListeners(name)`, and `server.events.hasListeners(name)`.\n\n##### <a name=\"server.events.log\" /> `'log'` Event\n\nThe `'log'` event type emits internal server events generated by the framework as well as\napplication events logged with [`server.log()`](#server.log()).\n\nThe `'log'` event handler uses the function signature `function(event, tags)` where:\n\n- `event` - an object with the following properties:\n    - `timestamp` - the event timestamp.\n    - `tags` - an array of tags identifying the event (e.g. `['error', 'http']`).\n    - `channel` - set to `'internal'` for internally generated events, otherwise `'app'` for events\n      generated by [`server.log()`](#server.log()).\n    - `data` - event-specific information. Available when event data was provided and is not an\n      error. Errors are passed via `error`.\n    - `error` - the error object related to the event if applicable. Cannot appear together with\n      `data`.\n\n- `tags` - an object where each `event.tag` is a key and the value is `true`. Useful for quick\n  identification of events.\n\n```js\nserver.events.on('log', (event, tags) => {\n\n    if (tags.error) {\n        console.log(`Server error: ${event.error ? event.error.message : 'unknown'}`);\n    }\n});\n```\n\nThe internally generated events are (identified by their `tags`):\n\n- `load` - logs the current server load measurements when the server rejects a request due to\n  [high load](#server.options.load). The event data contains the process load metrics.\n\n- `connection` `client` `error` - a `clientError` event was received from the HTTP or HTTPS\n  listener. The event data is the error object received.\n\n##### <a name=\"server.events.cachePolicy\" /> `'cachePolicy'` Event\n\nThe `'cachePolicy'` event type is emitted when a server [cache policy](https://hapi.dev/module/catbox/api#policy)\nis created via [`server.cache()`](#server.cache()) or a [`server.method()`](#server.method()) with caching enabled is registered.\nThe `'cachePolicy'` event handler uses the function signature `function(cachePolicy, cache, segment)` where:\n\n- `cachePolicy` - the catbox [cache policy](https://hapi.dev/module/catbox/api#policy).\n- `cache` - the [cache provision](#server.options.cache) name used when the policy was created or `undefined` if the default cache was used.\n- `segment` - the segment name used when the policy was created.\n\n```js\nserver.events.on('cachePolicy', (cachePolicy, cache, segment) => {\n\n    console.log(`New cache policy created using cache: ${cache === undefined ? 'default' : cache} and segment: ${segment}`);\n});\n```\n\n##### <a name=\"server.events.request\" /> `'request'` Event\n\nThe `'request'` event type emits internal request events generated by the framework as well as\napplication events logged with [`request.log()`](#request.log()).\n\nThe `'request'` event handler uses the function signature `function(request, event, tags)` where:\n\n- `request` - the [request object](#request).\n\n- `event` - an object with the following properties:\n    - `timestamp` - the event timestamp.\n    - `tags` - an array of tags identifying the event (e.g. `['error', 'http']`).\n    - `channel` - one of\n        - `'app'` - events generated by [`request.log()`](#request.log()).\n        - `'error'` - emitted once per request if the response had a `500` status code.\n        - `'internal'` - internally generated events.\n    - `request` - the request [identifier](#request.info.id).\n    - `data` - event-specific information. Available when event data was provided and is not an\n      error. Errors are passed via `error`.\n    - `error` - the error object related to the event if applicable. Cannot appear together with\n      `data`.\n\n- `tags` - an object where each `event.tag` is a key and the value is `true`. Useful for quick\n  identification of events.\n\n```js\nserver.events.on('request', (request, event, tags) => {\n\n    if (tags.error) {\n        console.log(`Request ${event.request} error: ${event.error ? event.error.message : 'unknown'}`);\n    }\n});\n```\n\nTo listen to only one of the channels, use the event criteria object:\n\n```js\nserver.events.on({ name: 'request', channels: 'error' }, (request, event, tags) => {\n\n    console.log(`Request ${event.request} failed`);\n});\n```\n\nThe internally generated events are (identified by their `tags`):\n\n- `accept-encoding` `error` - a request received contains an invalid Accept-Encoding header.\n- `auth` `unauthenticated` - no authentication scheme included with the request.\n- `auth` `unauthenticated` `response` `{strategy}` - the authentication strategy listed returned a non-error response (e.g. a redirect to a login page).\n- `auth` `unauthenticated` `error` `{strategy}` - the request failed to pass the listed authentication strategy (invalid credentials).\n- `auth` `unauthenticated` `missing` `{strategy}` - the request failed to pass the listed authentication strategy (no credentials found).\n- `auth` `unauthenticated` `try` `{strategy}` - the request failed to pass the listed authentication strategy in `'try'` mode and will continue.\n- `auth` `scope` `error` - the request authenticated but failed to meet the scope requirements.\n- `auth` `entity` `user` `error` - the request authenticated but included an application entity when a user entity was required.\n- `auth` `entity` `app` `error` - the request authenticated but included a user entity when an application entity was required.\n- `ext` `error` - an `onPostResponse` extension handler errored.\n- `handler` `error` - the route handler returned an error. Includes the execution duration and the error message.\n- `pre` `error` - a pre method was executed and returned an error. Includes the execution duration, assignment key, and error.\n- `internal` `error` - an HTTP 500 error response was assigned to the request.\n- `internal` `implementation` `error` - an incorrectly implemented [lifecycle method](#lifecycle-methods).\n- `request` `abort` `error` - the request aborted.\n- `request` `closed` `error` - the request closed prematurely.\n- `request` `error` - the request stream emitted an error. Includes the error.\n- `request` `server` `timeout` `error` - the request took too long to process by the server. Includes the timeout configuration value and the duration.\n- `state` `error` - the request included an invalid cookie or cookies. Includes the cookies and error details.\n- `state` `response` `error` - the response included an invalid cookie which prevented generating a valid header. Includes the error.\n- `payload` `error` - failed processing the request payload. Includes the error.\n- `response` `error` - failed writing the response to the client. Includes the error.\n- `response` `error` `close` - failed writing the response to the client due to prematurely closed connection.\n- `response` `error` `aborted` - failed writing the response to the client due to prematurely aborted connection.\n- `response` `error` `cleanup` - failed freeing response resources.\n- `validation` `error` `{input}` - input (i.e. payload, query, params, headers) validation failed. Includes the error. Only emitted when `failAction` is set to `'log'`.\n- `validation` `response` `error` - response validation failed. Includes the error message. Only emitted when `failAction` is set to `'log'`.\n\n##### <a name=\"server.events.response\" /> `'response'` Event\n\nThe `'response'` event type is emitted after the response is sent back to the client (or when the\nclient connection closed and no response sent, in which case [`request.response`](#request.response)\nis `null`). A single event is emitted per request. The `'response'` event handler uses the function\nsignature `function(request)` where:\n\n- `request` - the [request object](#request).\n\n```js\nserver.events.on('response', (request) => {\n\n    console.log(`Response sent for request: ${request.info.id}`);\n});\n```\n\n##### <a name=\"server.events.route\" /> `'route'` Event\n\nThe `'route'` event type is emitted when a route is added via [`server.route()`](#server.route()).\nThe `'route'` event handler uses the function signature `function(route)` where:\n\n- `route` - the [route information](#request.route). The `route` object must not be modified.\n\n```js\nserver.events.on('route', (route) => {\n\n    console.log(`New route added: ${route.path}`);\n});\n```\n\n##### <a name=\"server.events.start\" /> `'start'` Event\n\nThe `'start'` event type is emitted when the server is started using [`server.start()`](#server.start()).\nThe `'start'` event handler uses the function signature `function()`.\n\n```js\nserver.events.on('start', () => {\n\n    console.log('Server started');\n});\n```\n\n##### <a name=\"server.events.closing\" /> `'closing'` Event\n\nThe `'closing'` event type is emitted when the server is stopped using [`server.stop()`](#server.stop()). It is triggered when incoming requests are no longer accepted but before all underlying active connections have been closed, and thus before the [`'stop'`](#server.events.stop) event is triggered.\nThe `'closing'` event handler uses the function signature `function()`.\n\n```js\nserver.events.on('closing', () => {\n\n    console.log('Server is closing');\n});\n```\n\n##### <a name=\"server.events.stop\" /> `'stop'` Event\n\nThe `'stop'` event type is emitted when the server is stopped using [`server.stop()`](#server.stop()).\nThe `'stop'` event handler uses the function signature `function()`.\n\n```js\nserver.events.on('stop', () => {\n\n    console.log('Server stopped');\n});\n```\n\n#### <a name=\"server.info\" /> `server.info`\n\nAccess: read only.\n\nAn object containing information about the server where:\n\n- `id` - a unique server identifier (using the format '{hostname}:{pid}:{now base36}').\n\n- `created` - server creation timestamp.\n\n- `started` - server start timestamp (`0` when stopped).\n\n- `port` - the connection port based on the following rules:\n\n    - before the server has been started: the configured [`port`](#server.options.port) value.\n    - after the server has been started: the actual port assigned when no port is configured or was\n      set to `0`.\n\n- `host` - The [`host`](#server.options.host) configuration value.\n\n- `address` - the active IP address the connection was bound to after starting. Set to `undefined`\n  until the server has been started or when using a non TCP port (e.g. UNIX domain socket).\n\n- `protocol` - the protocol used:\n\n    - `'http'` - HTTP.\n    - `'https'` - HTTPS.\n    - `'socket'` - UNIX domain socket or Windows named pipe.\n\n- `uri` - a string representing the connection (e.g. 'http://example.com:8080' or\n  'socket:/unix/domain/socket/path'). Contains the [`uri`](#server.options.uri) value if set,\n  otherwise constructed from the available settings. If no [`port`](#server.options.port) is\n  configured or is set to `0`, the `uri` will not include a port component until the server is\n  started.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconsole.log(server.info.port);            // 80\n```\n\n#### <a name=\"server.listener\" /> `server.listener`\n\nAccess: read only and listener public interface.\n\nThe node HTTP server object.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst SocketIO = require('socket.io');\n\nconst server = Hapi.server({ port: 80 });\n\nconst io = SocketIO.listen(server.listener);\nio.sockets.on('connection', (socket) => {\n\n    socket.emit({ msg: 'welcome' });\n});\n```\n\n#### <a name=\"server.load\" /> `server.load`\n\nAccess: read only.\n\nAn object containing the process load metrics (when [`load.sampleInterval`](#server.options.load)\nis enabled):\n\n- `eventLoopDelay` - event loop delay milliseconds.\n- `eventLoopUtilization` - current event loop utilization value.\n- `heapUsed` - V8 heap usage.\n- `rss` - RSS memory usage.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ load: { sampleInterval: 1000 } });\n\nconsole.log(server.load.rss);\n```\n\n#### <a name=\"server.methods\" /> `server.methods`\n\nAccess: read only.\n\nServer methods are functions registered with the server and used throughout the application as a\ncommon utility. Their advantage is in the ability to configure them to use the built-in cache and\nshare across multiple request handlers without having to create a common module.\n\n`sever.methods` is an object which provides access to the methods registered via\n[server.method()](#server.method()) where each server method name is an object\nproperty.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server();\n\nserver.method('add', (a, b) => (a + b));\nconst result = server.methods.add(1, 2);    // 3\n```\n\n#### <a name=\"server.mime\" /> `server.mime`\n\nAccess: read only and **mimos** public interface.\n\nProvides access to the server MIME database used for setting content-type information. The object\nmust not be modified directly but only through the [`mime`](#server.options.mime) server setting.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nconst options = {\n    mime: {\n        override: {\n            'node/module': {\n                source: 'steve',\n                compressible: false,\n                extensions: ['node', 'module', 'npm'],\n                type: 'node/module'\n            }\n        }\n    }\n};\n\nconst server = Hapi.server(options);\nconsole.log(server.mime.path('code.js').type)        // 'application/javascript'\nconsole.log(server.mime.path('file.npm').type)        // 'node/module'\n```\n\n#### <a name=\"server.plugins\" /> `server.plugins`\n\nAccess: read / write.\n\nAn object containing the values exposed by each registered plugin where each key is a plugin name\nand the values are the exposed properties by each plugin using\n[`server.expose()`](#server.expose()). Plugins may set the value of the\n`server.plugins[name]` object directly or via the `server.expose()` method.\n\n```js\nexports.plugin = {\n    name: 'example',\n    register: function (server, options) {\n\n        server.expose('key', 'value');\n        server.plugins.example.other = 'other';\n\n        console.log(server.plugins.example.key);      // 'value'\n        console.log(server.plugins.example.other);    // 'other'\n    }\n};\n```\n\n#### <a name=\"server.realm\" /> `server.realm`\n\nAccess: read only.\n\nThe realm object contains sandboxed server settings specific to each plugin or authentication\nstrategy. When registering a plugin or an authentication scheme, a `server` object reference is\nprovided with a new `server.realm` container specific to that registration. It allows each plugin\nto maintain its own settings without leaking and affecting other plugins.\n\nFor example, a plugin can set a default file path for local resources without breaking other\nplugins' configured paths. When calling [`server.bind()`](#server.bind()), the active realm's\n`settings.bind` property is set which is then used by routes and extensions added at the same level\n(server root or plugin).\n\nThe `server.realm` object contains:\n\n- `modifiers` - when the server object is provided as an argument to the plugin `register()`\n  method, `modifiers` provides the registration preferences passed the\n  [`server.register()`](#server.register()) method and includes:\n\n    - `route` - routes preferences:\n\n        - `prefix` - the route path prefix used by any calls to [`server.route()`](#server.route())\n          from the server. Note that if a prefix is used and the route path is set to `'/'`, the\n          resulting path will not include the trailing slash.\n        - `vhost` - the route virtual host settings used by any calls to\n          [`server.route()`](#server.route()) from the server.\n\n- `parent` - the realm of the parent server object, or `null` for the root server.\n\n- `plugin` - the active plugin name (empty string if at the server root).\n\n- `pluginOptions` - the plugin options passed at registration.\n\n- `plugins` - plugin-specific state to be shared only among activities sharing the same active\n  state. `plugins` is an object where each key is a plugin name and the value is the plugin state.\n\n- `settings` - settings overrides:\n\n    - `files.relativeTo`\n    - `bind`\n\nThe `server.realm` object should be considered read-only and must not be changed directly except\nfor the `plugins` property which can be directly manipulated by each plugin, setting its properties\ninside `plugins[name]`.\n\n```js\nexports.register = function (server, options) {\n\n    console.log(server.realm.modifiers.route.prefix);\n};\n```\n\n#### <a name=\"server.registrations\" /> `server.registrations`\n\nAccess: read only.\n\nAn object of the currently registered plugins where each key is a registered plugin name and the\nvalue is an object containing:\n\n- `version` - the plugin version.\n- `name` - the plugin name.\n- `options` - (optional) options passed to the plugin during registration.\n\n#### <a name=\"server.settings\" /> `server.settings`\n\nAccess: read only.\n\nThe server configuration object after defaults applied.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({\n    app: {\n        key: 'value'\n    }\n});\n\nconsole.log(server.settings.app);   // { key: 'value' }\n```\n\n#### <a name=\"server.states\" /> `server.states`\n\nAccess: read only and **statehood** public interface.\n\nThe server cookies manager.\n\n#### <a name=\"server.states.settings\" /> `server.states.settings`\n\nAccess: read only.\n\nThe server cookies manager settings. The settings are based on the values configured in\n[`server.options.state`](#server.options.state).\n\n#### <a name=\"server.states.cookies\" /> `server.states.cookies`\n\nAccess: read only.\n\nAn object containing the configuration of each cookie added via [`server.state()`](#server.state())\nwhere each key is the cookie name and value is the configuration object.\n\n#### <a name=\"server.states.names\" /> `server.states.names`\n\nAccess: read only.\n\nAn array containing the names of all configured cookies.\n\n#### <a name=\"server.type\" /> `server.type`\n\nAccess: read only.\n\nA string indicating the listener type where:\n- `'socket'` - UNIX domain socket or Windows named pipe.\n- `'tcp'` - an HTTP listener.\n\n#### <a name=\"server.version\" /> `server.version`\n\nAccess: read only.\n\nThe **hapi** module version number.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server();\n\nconsole.log(server.version);        // '17.0.0'\n```\n\n### <a name=\"server.auth.default()\" /> `server.auth.default(options)`\n\nSets a default strategy which is applied to every route where:\n\n- `options` - one of:\n\n    - a string with the default strategy name\n    - an authentication configuration object using the same format as the\n      [route `auth` handler options](#route.options.auth).\n\nReturn value: none.\n\nThe default does not apply when a route config specifies `auth` as `false`, or has an\nauthentication strategy configured (contains the [`strategy`](#route.options.auth.strategy) or\n[`strategies`](#route.options.auth.strategies) authentication settings). Otherwise, the route\nauthentication config is applied to the defaults.\n\nNote that if the route has authentication configured, the default only applies at the time of\nadding the route, not at runtime. This means that calling `server.auth.default()` after adding a\nroute with some authentication config will have no impact on the routes added prior. However, the\ndefault will apply to routes added before `server.auth.default()` is called if those routes lack\nany authentication config.\n\nThe default auth strategy configuration can be accessed via [`server.auth.settings.default`](#server.auth.settings.default).\nTo obtain the active authentication configuration of a route, use `server.auth.lookup(request.route)`.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nserver.auth.scheme('custom', scheme);\nserver.auth.strategy('default', 'custom');\nserver.auth.default('default');\n\nserver.route({\n    method: 'GET',\n    path: '/',\n    handler: function (request, h) {\n\n        return request.auth.credentials.user;\n    }\n});\n```\n\n### <a name=\"server.auth.scheme()\" /> `server.auth.scheme(name, scheme)`\n\nRegisters an authentication scheme where:\n\n- `name` - the scheme name.\n- `scheme` - the method implementing the scheme with signature `function(server, options)` where:\n    - `server` - a reference to the server object the scheme is added to. Each auth strategy is given its own [`server.realm`](#server.realm) whose parent is the realm of the `server` in the call to [`server.auth.strategy()`](#server.auth.strategy()).\n    - `options` - (optional) the scheme `options` argument passed to\n      [`server.auth.strategy()`](#server.auth.strategy()) when instantiation a strategy.\n\nReturn value: none.\n\nThe `scheme` function must return an [authentication scheme object](#authentication-scheme) when\ninvoked.\n\n#### Authentication scheme\n\nAn authentication scheme is an object with the following properties:\n\n- `api` - (optional) object which is exposed via the [`server.auth.api`](#server.auth.api) object.\n\n- `async authenticate(request, h)` - (required) a [lifecycle method](#lifecycle-methods) function\n  called for each incoming request configured with the authentication scheme. The method is\n  provided with two special toolkit methods for returning an authenticated or an unauthenticate\n  result:\n    - [`h.authenticated()`](#h.authenticated()) - indicate request authenticated successfully.\n    - [`h.unauthenticated()`](#h.unauthenticated()) - indicate request failed to authenticate.\n\n- `async payload(request, h)` - (optional) a [lifecycle method](#lifecycle-methods) to authenticate\n  the request payload.\n\n- `async response(request, h)` - (optional) a [lifecycle method](#lifecycle-methods) to decorate\n  the response with authentication headers before the response headers or payload is written.\n\n- `async verify(auth)` - (optional) a method used to verify the authentication credentials provided\n  are still valid (e.g. not expired or revoked after the initial authentication) where:\n  - `auth` - the [`request.auth`](#request.auth) object containing the `credentials` and\n    `artifacts` objects returned by the scheme's `authenticate()` method.\n  - the method throws an `Error` when the credentials passed are no longer valid (e.g. expired or\n  revoked). Note that the method does not have access to the original request, only to the\n  credentials and artifacts produced by the `authenticate()` method.\n\n- `options` - (optional) an object with the following keys:\n    - `payload` - if `true`, requires payload validation as part of the scheme and forbids routes\n      from disabling payload auth validation. Defaults to `false`.\n\nWhen the scheme `authenticate()` method implementation throws an error or calls\n[`h.unauthenticated()`](#h.unauthenticated()), the specifics of the error affect whether additional\nauthentication strategies will be attempted (if configured for the route). If the error includes a\nmessage, no additional strategies will be attempted. If the `err` does not include a message but\ndoes include the scheme name (e.g. `Boom.unauthorized(null, 'Custom')`), additional strategies will\nbe attempted in the order of preference (defined in the route configuration). If authentication\nfails, the scheme names will be present in the 'WWW-Authenticate' header.\n\nWhen the scheme `payload()` method throws an error with a message, it means payload validation\nfailed due to bad payload. If the error has no message but includes a scheme name (e.g.\n`Boom.unauthorized(null, 'Custom')`), authentication may still be successful if the route\n[`auth.payload`](#route.options.auth.payload) configuration is set to `'optional'`.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst scheme = function (server, options) {\n\n    return {\n        authenticate: function (request, h) {\n\n            const req = request.raw.req;\n            const authorization = req.headers.authorization;\n            if (!authorization) {\n                throw Boom.unauthorized(null, 'Custom');\n            }\n\n            return h.authenticated({ credentials: { user: 'john' } });\n        }\n    };\n};\n\nserver.auth.scheme('custom', scheme);\n```\n\n### <a name=\"server.auth.strategy()\" /> `server.auth.strategy(name, scheme, [options])`\n\nRegisters an authentication strategy where:\n\n- `name` - the strategy name.\n- `scheme` - the scheme name (must be previously registered using\n  [`server.auth.scheme()`](#server.auth.scheme())).\n- `options` - scheme options based on the scheme requirements.\n\nReturn value: none.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nserver.auth.scheme('custom', scheme);\nserver.auth.strategy('default', 'custom');\n\nserver.route({\n    method: 'GET',\n    path: '/',\n    options: {\n        auth: 'default',\n        handler: function (request, h) {\n\n            return request.auth.credentials.user;\n        }\n    }\n});\n```\n\n### <a name=\"server.auth.test()\" /> `await server.auth.test(strategy, request)`\n\nTests a request against an authentication strategy where:\n\n- `strategy` - the strategy name registered with [`server.auth.strategy()`](#server.auth.strategy()).\n- `request` - the [request object](#request).\n\nReturn value: an object containing the authentication `credentials` and `artifacts` if authentication\nwas successful, otherwise throws an error.\n\nNote that the `test()` method does not take into account the route authentication configuration. It\nalso does not perform payload authentication. It is limited to the basic strategy authentication\nexecution. It does not include verifying scope, entity, or other route properties.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nserver.auth.scheme('custom', scheme);\nserver.auth.strategy('default', 'custom');\n\nserver.route({\n    method: 'GET',\n    path: '/',\n    handler: async function (request, h) {\n\n        try {\n            const { credentials, artifacts } = await request.server.auth.test('default', request);\n            return { status: true, user: credentials.name };\n        }\n        catch (err) {\n            return { status: false };\n        }\n    }\n});\n```\n\n\n### <a name=\"server.auth.verify()\" /> `await server.auth.verify(request)`\n\nVerify a request's authentication credentials against an authentication strategy where:\n\n- `request` - the [request object](#request).\n\nReturn value: nothing if verification was successful, otherwise throws an error.\n\nNote that the `verify()` method does not take into account the route authentication configuration\nor any other information from the request other than the `request.auth` object. It also does not\nperform payload authentication. It is limited to verifying that the previously valid credentials\nare still valid (e.g. have not been revoked or expired). It does not include verifying scope,\nentity, or other route properties.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nserver.auth.scheme('custom', scheme);\nserver.auth.strategy('default', 'custom');\n\nserver.route({\n    method: 'GET',\n    path: '/',\n    handler: async function (request, h) {\n\n        try {\n            const credentials = await request.server.auth.verify(request);\n            return { status: true, user: credentials.name };\n        }\n        catch (err) {\n            return { status: false };\n        }\n    }\n});\n```\n\n### <a name=\"server.bind()\" /> `server.bind(context)`\n\nSets a global context used as the default bind object when adding a route or an extension where:\n\n- `context` - the object used to bind `this` in [lifecycle methods](#lifecycle-methods) such as\n  the [route handler](#route.options.handler) and [extension methods](#server.ext()). The context\n  is also made available as [`h.context`](#h.context).\n\nReturn value: none.\n\nWhen setting a context inside a plugin, the context is applied only to methods set up by the\nplugin. Note that the context applies only to routes and extensions added after it has been set.\nIgnored if the method being bound is an arrow function.\n\n```js\nconst handler = function (request, h) {\n\n    return this.message;    // Or h.context.message\n};\n\nexports.plugin = {\n    name: 'example',\n    register: function (server, options) {\n\n        const bind = {\n            message: 'hello'\n        };\n\n        server.bind(bind);\n        server.route({ method: 'GET', path: '/', handler });\n    }\n};\n```\n\n### <a name=\"server.cache()\" /> `server.cache(options)`\n\nProvisions a cache segment within the server cache facility where:\n\n- `options` - [**catbox** policy](https://hapi.dev/family/catbox/api#policy) configuration where:\n\n    - `expiresIn` - relative expiration expressed in the number of milliseconds since the item was\n      saved in the cache. Cannot be used together with `expiresAt`.\n\n    - `expiresAt` - time of day expressed in 24h notation using the 'HH:MM' format, at which point\n      all cache records expire. Uses local time. Cannot be used together with `expiresIn`.\n\n    - `generateFunc` - a function used to generate a new cache item if one is not found in the\n      cache when calling `get()`. The method's signature is `async function(id, flags)` where:\n\n          - `id` - the `id` string or object provided to the `get()` method.\n          - `flags` - an object used to pass back additional flags to the cache where:\n              - `ttl` - the cache ttl value in milliseconds. Set to `0` to skip storing in the\n                cache. Defaults to the cache global policy.\n\n    - `staleIn` - number of milliseconds to mark an item stored in cache as stale and attempt to\n      regenerate it when `generateFunc` is provided. Must be less than `expiresIn`.\n\n    - `staleTimeout` - number of milliseconds to wait before checking if an item is stale.\n\n    - `generateTimeout` - number of milliseconds to wait before returning a timeout error when the\n      `generateFunc` function takes too long to return a value. When the value is eventually\n      returned, it is stored in the cache for future requests. Required if `generateFunc` is\n      present. Set to `false` to disable timeouts which may cause all `get()` requests to get stuck\n      forever.\n\n    - `generateOnReadError` - if `false`, an upstream cache read error will stop the `cache.get()`\n      method from calling the generate function and will instead pass back the cache error. Defaults\n      to `true`.\n\n    - `generateIgnoreWriteError` - if `false`, an upstream cache write error when calling\n      `cache.get()` will be passed back with the generated value when calling. Defaults to `true`.\n\n    - `dropOnError` - if `true`, an error or timeout in the `generateFunc` causes the stale value\n      to be evicted from the cache.  Defaults  to `true`.\n\n    - `pendingGenerateTimeout` - number of milliseconds while `generateFunc` call is in progress\n      for a given id, before a subsequent `generateFunc` call is allowed. Defaults to `0` (no\n      blocking of concurrent `generateFunc` calls beyond `staleTimeout`).\n\n    - `cache` - the cache name configured in [`server.cache`](#server.options.cache). Defaults to\n      the default cache.\n\n    - `segment` - string segment name, used to isolate cached items within the cache partition.\n      When called within a plugin, defaults to '!name' where 'name' is the plugin name. When called\n      within a server method, defaults to '#name' where 'name' is the server method name. Required\n      when called outside of a plugin.\n\n    - `shared` - if `true`, allows multiple cache provisions to share the same segment. Default to\n      `false`.\n\nReturn value: a [**catbox** policy](https://hapi.dev/family/catbox/api#policy) object.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    const cache = server.cache({ segment: 'countries', expiresIn: 60 * 60 * 1000 });\n    await cache.set('norway', { capital: 'oslo' });\n    const value = await cache.get('norway');\n}\n```\n\n### <a name=\"server.cache.provision()\" /> `await server.cache.provision(options)`\n\nProvisions a server cache as described in [`server.cache`](#server.options.cache) where:\n\n- `options` - same as the server [`cache`](#server.options.cache) configuration options.\n\nReturn value: none.\n\nNote that if the server has been initialized or started, the cache will be automatically started\nto match the state of any other provisioned server cache.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    await server.initialize();\n    await server.cache.provision({ provider: require('@hapi/catbox-memory'), name: 'countries' });\n\n    const cache = server.cache({ cache: 'countries', expiresIn: 60 * 60 * 1000 });\n    await cache.set('norway', { capital: 'oslo' });\n    const value = await cache.get('norway');\n}\n```\n\n### <a name=\"server.control()\" /> `server.control(server)`\n\nLinks another server to the initialize/start/stop state of the current server by calling the\ncontrolled server `initialize()`/`start()`/`stop()` methods whenever the current server methods\nare called, where:\n\n- `server` - the **hapi** server object to be controlled.\n\n### <a name=\"server.decoder()\" /> `server.decoder(encoding, decoder)`\n\nRegisters a custom content decoding compressor to extend the built-in support for `'gzip'` and\n'`deflate`' where:\n\n- `encoding` - the decoder name string.\n\n- `decoder` - a function using the signature `function(options)` where `options` are the encoding\n  specific options configured in the route [`payload.compression`](#route.options.payload.compression)\n  configuration option, and the return value is an object compatible with the output of node's\n  [`zlib.createGunzip()`](https://nodejs.org/api/zlib.html#zlib_zlib_creategunzip_options).\n\nReturn value: none.\n\n```js\nconst Zlib = require('zlib');\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80, routes: { payload: { compression: { special: { chunkSize: 16 * 1024 } } } } });\n\nserver.decoder('special', (options) => Zlib.createGunzip(options));\n```\n\n### <a name=\"server.decorate()\" /> `server.decorate(type, property, method, [options])`\n\nExtends various framework interfaces with custom methods where:\n\n- `type` - the interface being decorated. Supported types:\n\n    - `'handler'` - adds a new handler type to be used in [routes handlers](#route.options.handler).\n    - `'request'` - adds methods to the [Request object](#request).\n    - `'response'` - adds methods to the [Response object](#response-object).\n    - `'server'` - adds methods to the [Server](#server) object.\n    - `'toolkit'` - adds methods to the [response toolkit](#response-toolkit).\n\n- `property` - the object decoration key name or symbol.\n\n- `method` - the extension function or other value.\n\n- `options` - (optional) supports the following optional settings:\n    - `apply` - when the `type` is `'request'`, if `true`, the `method` function is invoked using\n      the signature `function(request)` where `request` is the current request object and the\n      returned value is assigned as the decoration.\n    - `extend` - if `true`, overrides an existing decoration. The `method` must be a function with\n      the signature `function(existing)` where:\n        - `existing` - is the previously set decoration method value.\n        - must return the new decoration function or value.\n        - cannot be used to extend handler decorations.\n\nReturn value: none.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst success = function () {\n\n    return this.response({ status: 'ok' });\n};\n\nserver.decorate('toolkit', 'success', success);\n\nserver.route({\n    method: 'GET',\n    path: '/',\n    handler: function (request, h) {\n\n        return h.success();\n    }\n});\n```\n\nWhen registering a handler decoration, the `method` must be a function using the signature\n`function(route, options)` where:\n\n- `route` - the [route information](#request.route).\n- `options` - the configuration object provided in the handler config.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ host: 'localhost', port: 8000 });\n\n    // Defines new handler for routes on this server\n\n    const handler = function (route, options) {\n\n        return function (request, h) {\n\n            return 'new handler: ' + options.msg;\n        }\n    };\n\n    server.decorate('handler', 'test', handler);\n\n    server.route({\n        method: 'GET',\n        path: '/',\n        handler: { test: { msg: 'test' } }\n    });\n\n    await server.start();\n}\n```\n\nThe `method` function can have a `defaults` object or function property. If the property is set to\nan object, that object is used as the default route config for routes using this handler. If the\nproperty is set to a function, the function uses the signature `function(method)` and returns the\nroute default configuration.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ host: 'localhost', port: 8000 });\n\nconst handler = function (route, options) {\n\n    return function (request, h) {\n\n        return 'new handler: ' + options.msg;\n    }\n};\n\n// Change the default payload processing for this handler\n\nhandler.defaults = {\n    payload: {\n        output: 'stream',\n        parse: false\n    }\n};\n\nserver.decorate('handler', 'test', handler);\n```\n\n### <a name=\"server.dependency()\" /> `server.dependency(dependencies, [after])`\n\nUsed within a plugin to declare a required dependency on other [plugins](#plugins) required for\nthe current plugin to operate (plugins listed must be registered before the server is initialized\nor started) where:\n\n- `dependencies` - one of:\n  - a single plugin name string.\n  - an array of plugin name strings.\n  - an object where each key is a plugin name and each matching value is a\n   [version range string](https://www.npmjs.com/package/semver) which must match the registered\n   plugin version.\n\n- `after` - (optional) a function that is called after all the specified dependencies have been\nregistered and before the server starts. The function is only called if the server is initialized\nor started. The function signature is `async function(server)` where:\n\n    - `server` - the server the `dependency()` method was called on.\n\nReturn value: none.\n\nThe `after` method is identical to setting a server extension point on `'onPreStart'`.\n\nIf a circular  dependency is detected, an exception is thrown (e.g. two plugins each has an `after`\nfunction to be called after the other).\n\n```js\nconst after = function (server) {\n\n    // Additional plugin registration logic\n};\n\nexports.plugin = {\n    name: 'example',\n    register: function (server, options) {\n\n        server.dependency('yar', after);\n    }\n};\n```\n\nDependencies can also be set via the plugin `dependencies` property (does not support setting\n`after`):\n\n```js\nexports.plugin = {\n    name: 'test',\n    version: '1.0.0',\n    dependencies: {\n        yar: '1.x.x'\n    },\n    register: function (server, options) { }\n};\n```\n\nThe `dependencies` configuration accepts one of:\n  - a single plugin name string.\n  - an array of plugin name strings.\n  - an object where each key is a plugin name and each matching value is a\n   [version range string](https://www.npmjs.com/package/semver) which must match the registered\n   plugin version.\n\n### <a name=\"server.encoder()\" /> `server.encoder(encoding, encoder)`\n\nRegisters a custom content encoding compressor to extend the built-in support for `'gzip'` and\n'`deflate`' where:\n\n- `encoding` - the encoder name string.\n\n- `encoder` - a function using the signature `function(options)` where `options` are the encoding\n  specific options configured in the route [`compression`](#route.options.compression) option, and\n  the return value is an object compatible with the output of node's\n  [`zlib.createGzip()`](https://nodejs.org/api/zlib.html#zlib_zlib_creategzip_options).\n\nReturn value: none.\n\n```js\nconst Zlib = require('zlib');\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80, routes: { compression: { special: { chunkSize: 16 * 1024 } } } });\n\nserver.encoder('special', (options) => Zlib.createGzip(options));\n```\n\n### <a name=\"server.event()\" /> `server.event(events)`\n\nRegister custom application events where:\n\n- `events` - must be one of:\n\n    - an event name string.\n\n    - an event options object with the following optional keys (unless noted otherwise):\n\n        - `name` - the event name string (required).\n\n        - `channels` - a string or array of strings specifying the event channels available. Defaults to no channel restrictions (event updates can specify a channel or not).\n\n        - `clone` - if `true`, the `data` object passed to [`server.events.emit()`](#server.events.emit()) is cloned before it is passed to the listeners (unless an override specified by each listener). Defaults to `false` (`data` is passed as-is).\n\n        - `spread` - if `true`, the `data` object passed to [`server.event.emit()`](#server.event.emit()) must be an array and the `listener` method is called with each array element passed as a separate argument (unless an override specified by each listener). This should only be used when the emitted data structure is known and predictable. Defaults to `false` (`data` is emitted as a single argument regardless of its type).\n\n        - `tags` - if `true` and the `criteria` object passed to [`server.event.emit()`](#server.event.emit()) includes `tags`, the tags are mapped to an object (where each tag string is the key and the value is `true`) which is appended to the arguments list at the end. A configuration override can be set by each listener. Defaults to `false`.\n\n        - `shared` - if `true`, the same event `name` can be registered multiple times where the second registration is ignored. Note that if the registration config is changed between registrations, only the first configuration is used. Defaults to `false` (a duplicate registration will throw an error).\n\n    - an array containing any of the above.\n\nReturn value: none.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    server.event('test');\n    server.events.on('test', (update) => console.log(update));\n    await server.events.gauge('test', 'hello');\n}\n```\n\n### <a name=\"server.events.emit()\" /> `server.events.emit(criteria, data)`\n\nEmits a custom application event to all the subscribed listeners where:\n\n- `criteria` - the event update criteria which must be one of:\n\n    - the event name string.\n    - an object with the following optional keys (unless noted otherwise):\n        - `name` - the event name string (required).\n        - `channel` - the channel name string.\n        - `tags` - a tag string or array of tag strings.\n\n- `data` - the value emitted to the subscribers. If `data` is a function, the function signature is `function()` and it called once to generate (return value) the actual data emitted to the listeners. If no listeners match the event, the `data` function is not invoked.\n\nReturn value: none.\n\nNote that events must be registered before they can be emitted or subscribed to by calling [`server.event(events)`](#server.event()). This is done to detect event name misspelling and invalid event activities.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    server.event('test');\n    server.events.on('test', (update) => console.log(update));\n    server.events.emit('test', 'hello');\n}\n```\n\n### <a name=\"server.events.on()\" /> `server.events.on(criteria, listener, context)`\n\nSubscribe to an event where:\n\n- `criteria` - the subscription criteria which must be one of:\n\n    - event name string which can be any of the [built-in server events](#server.events) or a\n      custom application event registered with [`server.event()`](#server.event()).\n\n    - a criteria object with the following optional keys (unless noted otherwise):\n\n        - `name` - (required) the event name string.\n\n        - `channels` - a string or array of strings specifying the event channels to subscribe to.\n          If the event registration specified a list of allowed channels, the `channels` array must\n          match the allowed channels. If `channels` are specified, event updates without any\n          channel designation will not be included in the subscription. Defaults to no channels\n          filter.\n\n        - `clone` - if `true`, the `data` object passed to [`server.event.emit()`](#server.event.emit())\n           is cloned before it is passed to the `listener` method. Defaults to the event\n           registration option (which defaults to `false`).\n\n        - `count` - a positive integer indicating the number of times the `listener` can be called\n          after which the subscription is automatically removed. A count of `1` is the same as\n          calling `server.events.once()`. Defaults to no limit.\n\n        - `filter` - the event tags (if present) to subscribe to which can be one of:\n\n            - a tag string.\n            - an array of tag strings.\n            - an object with the following:\n\n                - `tags` - a tag string or array of tag strings.\n                - `all` - if `true`, all `tags` must be present for the event update to match the\n                  subscription. Defaults to `false` (at least one matching tag).\n\n        - `spread` - if `true`, and the `data` object passed to [`server.event.emit()`](#server.event.emit())\n          is an array, the `listener` method is called with each array element passed as a separate\n          argument. This should only be used when the emitted data structure is known and\n          predictable. Defaults to the event registration option (which defaults to `false`).\n\n        - `tags` - if `true` and the `criteria` object passed to [`server.event.emit()`](#server.event.emit())\n          includes `tags`, the tags are mapped to an object (where each tag string is the key and\n          the value is `true`) which is appended to the arguments list at the end. Defaults to the\n          event registration option (which defaults to `false`).\n\n- `listener` - the handler method set to receive event updates. The function signature depends on\n  the event argument, and the `spread` and `tags` options.\n- `context` - an object that binds to the listener handler.\n\nReturn value: none.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    server.event('test');\n    server.events.on('test', (update) => console.log(update));\n    server.events.emit('test', 'hello');\n}\n```\n\n### <a name=\"server.events.once()\" /> `server.events.once(criteria, listener, context)`\n\nSame as calling [`server.events.on()`](#server.events.on()) with the `count` option set to `1`.\n\nReturn value: none.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    server.event('test');\n    server.events.once('test', (update) => console.log(update));\n    server.events.emit('test', 'hello');\n    server.events.emit('test', 'hello');       // Ignored\n}\n```\n\n### <a name=\"server.events.once.await()\" /> `await server.events.once(criteria)`\n\nSame as calling [`server.events.on()`](#server.events.on()) with the `count` option set to `1`.\n\n Return value: a promise that resolves when the event is emitted.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    server.event('test');\n    const pending = server.events.once('test');\n    server.events.emit('test', 'hello');\n    const update = await pending;\n}\n```\n\n### <a name=\"server.events.gauge()\" /> `await server.events.gauge(criteria, data)`\n\nBehaves identically to [`server.events.emit()`](#server.events.emit()), but also returns an array of the results of all the event listeners that run. The return value is that of `Promise.allSettled()`, where each item in the resulting array is `{ status: 'fulfilled', value }` in the case of a successful handler, or `{ status: 'rejected', reason }` in the case of a handler that throws.\n\nPlease note that system errors such as a `TypeError` are not handled specially, and it's recommended to scrutinize any rejections using something like [bounce](https://hapi.dev/module/bounce/).\n\n### <a name=\"server.expose()\" /> `server.expose(key, value, [options])`\n\nUsed within a plugin to expose a property via [`server.plugins[name]`](#server.plugins) where:\n\n- `key` - the key assigned ([`server.plugins[name][key]`](#server.plugins)).\n- `value` - the value assigned.\n- `options` - optional settings:\n    - `scope` - controls how to handle the presence of a plugin scope in the name (e.g. `@hapi/test`):\n        - `false` - the scope is removed (e.g. `@hapi/test` is changed to `test` under `server.plugins`). This is the default.\n        - `true` - the scope is retained as-is (e.g. `@hapi/test` is used as `server.plugins['@hapi/test']`).\n        - `'underscore'` - the scope is rewritten (e.g. `@hapi/test` is used as `server.plugins.hapi__test`).\n\nReturn value: none.\n\n```js\nexports.plugin =\n    name: 'example',\n    register: function (server, options) {\n\n        server.expose('util', () => console.log('something'));\n    }\n};\n```\n\n### <a name=\"server.expose.obj()\" /> `server.expose(obj)`\n\nMerges an object into to the existing content of [`server.plugins[name]`](#server.plugins) where:\n\n- `obj` - the object merged into the exposed properties container.\n\nReturn value: none.\n\n```js\nexports.plugin = {\n    name: 'example',\n    register: function (server, options) {\n\n        server.expose({ util: () => console.log('something') });\n    }\n};\n```\n\nNote that all the properties of `obj` are deeply cloned into [`server.plugins[name]`](#server.plugins),\nso avoid using this method for exposing large objects that may be expensive to clone or singleton\nobjects such as database client objects. Instead favor [`server.expose(key, value)`](#server.expose()),\nwhich only copies a reference to `value`.\n\n### <a name=\"server.ext()\" /> `server.ext(events)`\n\nRegisters an extension function in one of the [request lifecycle](#request-lifecycle) extension\npoints where:\n\n- `events` - an object or array of objects with the following:\n\n    - `type` - (required) the extension point event name. The available extension points include\n      the [request extension points](#request-lifecycle) as well as the following server extension\n      points:\n\n        - `'onPreStart'` - called before the connection listeners are started.\n        - `'onPostStart'` - called after the connection listeners are started.\n        - `'onPreStop'` - called before the connection listeners are stopped.\n        - `'onPostStop'` - called after the connection listeners are stopped.\n\n    - `method` - (required) a function or an array of functions to be executed at a specified point\n      during request processing. The required extension function signature is:\n\n        - server extension points: `async function(server)` where:\n\n            - `server` - the server object.\n            - `this` - the object provided via `options.bind` or the current active context set\n              with [`server.bind()`](#server.bind()).\n\n        - request extension points: a [lifecycle method](#lifecycle-methods).\n\n    - `options` - (optional) an object with the following:\n\n        - `before` - a string or array of strings of plugin names this method must execute before\n          (on the same event). Otherwise, extension methods are executed in the order added.\n\n        - `after` - a string or array of strings of plugin names this method must execute after (on\n          the same event). Otherwise, extension methods are executed in the order added.\n\n        - `bind` - a context object passed back to the provided method (via `this`) when called.\n           Ignored if the method is an arrow function.\n\n        - `sandbox` - if set to `'plugin'` when adding a [request extension points](#request-lifecycle)\n          the extension is only added to routes defined by the current plugin. Not allowed when\n          configuring route-level extensions, or when adding server extensions. Defaults to\n          `'server'` which applies to any route added to the server the extension is added to.\n\n        - `timeout` - number of milliseconds to wait for the `method` to complete before returning\n          a timeout error. Defaults to no timeout.\n\nReturn value: none.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n\n    server.ext({\n        type: 'onRequest',\n        method: function (request, h) {\n\n            // Change all requests to '/test'\n\n            request.setUrl('/test');\n            return h.continue;\n        }\n    });\n\n    server.route({ method: 'GET', path: '/test', handler: () => 'ok' });\n    await server.start();\n\n    // All requests will get routed to '/test'\n}\n```\n\n### <a name=\"server.ext.args()\" /> `server.ext(event, [method, [options]])`\n\nRegisters a single extension event using the same properties as used in [`server.ext(events)`](#server.ext()), but passed as arguments.\n\nThe `method` may be omitted (if `options` isn't present) or passed `null` which will cause the function to return a promise. The promise is resolved with the `request` object on the first invocation of the extension point. This is primarily used for writing tests without having to write custom handlers just to handle a single event.\n\nReturn value: a promise if `method` is omitted, otherwise `undefined`.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n\n    server.ext('onRequest', function (request, h) {\n\n        // Change all requests to '/test'\n\n        request.setUrl('/test');\n        return h.continue;\n    });\n\n    server.route({ method: 'GET', path: '/test', handler: () => 'ok' });\n    await server.start();\n\n    // All requests will get routed to '/test'\n}\n```\n\n### <a name=\"server.initialize()\" /> `await server.initialize()`\n\nInitializes the server (starts the caches, finalizes plugin registration) but does not start\nlistening on the connection port.\n\nReturn value: none.\n\nNote that if the method fails and throws an error, the server is considered to be in an undefined\nstate and should be shut down. In most cases it would be impossible to fully recover as the various\nplugins, caches, and other event listeners will get confused by repeated attempts to start the\nserver or make assumptions about the healthy state of the environment. It is recommended to abort\nthe process when the server fails to start properly. If you must try to resume after an error, call\n[`server.stop()`](#server.stop()) first to reset the server state.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst Hoek = require('@hapi/hoek');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    await server.initialize();\n}\n```\n\n### <a name=\"server.inject()\" /> `await server.inject(options)`\n\nInjects a request into the server simulating an incoming HTTP request without making an actual\nsocket connection. Injection is useful for testing purposes as well as for invoking routing logic\ninternally without the overhead and limitations of the network stack.\n\nThe method utilizes the [**shot**](https://hapi.dev/family/shot/api) module for performing\ninjections, with some additional options and response properties:\n\n- `options` - can be assigned a string with the requested URI, or an object with:\n\n    - `method` - (optional) the request HTTP method (e.g. `'POST'`). Defaults to `'GET'`.\n\n    - `url` - (required) the request URL. If the URI includes an authority\n      (e.g. `'example.com:8080'`), it is used to automatically set an HTTP 'Host' header, unless\n      one was specified in `headers`.\n\n    - `authority` - (optional) a string specifying the HTTP 'Host' header value. Only used if 'Host'\n      is not specified in `headers` and the `url` does not include an authority component.\n      Default is inferred from runtime server information.\n\n    - `headers` - (optional) an object with optional request headers where each key is the header\n      name and the value is the header content. Defaults to no additions to the default **shot**\n      headers.\n\n    - `payload` - (optional) an string, buffer or object containing the request payload. In case of\n      an object it will be converted to a string for you. Defaults to no payload. Note that payload\n      processing defaults to `'application/json'` if no 'Content-Type' header provided.\n\n    - `auth` - (optional) an object containing parsed authentication credentials where:\n\n        - `strategy` - (required) the authentication strategy name matching the provided\n          credentials.\n\n        - `credentials` - (required) a credentials object containing authentication information.\n          The `credentials` are used to bypass the default authentication strategies, and are\n          validated directly as if they were received via an authentication scheme.\n\n        - `artifacts` - (optional) an artifacts object containing authentication artifact\n          information. The `artifacts` are used to bypass the default authentication strategies,\n          and are validated directly as if they were received via an authentication scheme.\n          Defaults to no artifacts.\n\n        - `payload` - (optional) disables payload authentication when set to false.\n          Only required when an authentication strategy requires payload authentication.\n          Defaults to `true`.\n\n    - `app` - (optional) sets the initial value of `request.app`, defaults to `{}`.\n\n    - `plugins` - (optional) sets the initial value of `request.plugins`, defaults to `{}`.\n\n    - `allowInternals` - (optional) allows access to routes with `options.isInternal` set to `true`.\n      Defaults to `false`.\n\n    - `remoteAddress` - (optional) sets the remote address for the incoming connection.\n\n    - `simulate` - (optional) an object with options used to simulate client request stream\n      conditions for testing:\n\n        - `error` - if `true`, emits an `'error'` event after payload transmission (if any).\n          Defaults to `false`.\n\n        - `close` - if `true`, emits a `'close'` event after payload transmission (if any).\n          Defaults to `false`.\n\n        - `end` - if `false`, does not end the stream. Defaults to `true`.\n\n        - `split` - indicates whether the request payload will be split into chunks. Defaults to\n          `undefined`, meaning payload will not be chunked.\n\n    - `validate` - (optional) if `false`, the `options` inputs are not validated. This is\n      recommended for run-time usage of `inject()` to make it perform faster where input validation\n      can be tested separately.\n\nReturn value: a response object with the following properties:\n\n- `statusCode` - the HTTP status code.\n\n- `headers` - an object containing the headers set.\n\n- `payload` - the response payload string.\n\n- `rawPayload` - the raw response payload buffer.\n\n- `raw` - an object with the injection request and response objects:\n\n    - `req` - the simulated node request object.\n    - `res` - the simulated node response object.\n\n- `result` - the raw handler response (e.g. when not a stream or a view) before it is\n    serialized for transmission. If not available, the value is set to `payload`. Useful for\n    inspection and reuse of the internal objects returned (instead of parsing the response\n    string).\n\n- `request` - the [request object](#request).\n\nThrows a Boom error if the request processing fails. The partial response object is exposed on\nthe `data` property.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    server.route({ method: 'GET', path: '/', handler: () => 'Success!' });\n\n    const res = await server.inject('/');\n    console.log(res.result);                // 'Success!'\n}\n```\n\n### <a name=\"server.log()\" /> `server.log(tags, [data, [timestamp]])`\n\nLogs server events that cannot be associated with a specific request. When called the server emits\na `'log'` event which can be used by other listeners or [plugins](#plugins) to record the\ninformation or output to the console. The arguments are:\n\n- `tags` - (required) a string or an array of strings (e.g. `['error', 'database', 'read']`) used\n  to identify the event. Tags are used instead of log levels and provide a much more expressive\n  mechanism for describing and filtering events. Any logs generated by the server internally\n  include the `'hapi'` tag along with event-specific information.\n\n- `data` - (optional) an message string or object with the application data being logged. If `data`\n  is a function, the function signature is `function()` and it called once to generate (return\n  value) the actual data emitted to the listeners. If no listeners match the event, the `data`\n  function is not invoked.\n\n- `timestamp` - (optional) an timestamp expressed in milliseconds. Defaults to `Date.now()` (now).\n\nReturn value: none.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nserver.events.on('log', (event, tags) => {\n\n    if (tags.error) {\n        console.log(event);\n    }\n});\n\nserver.log(['test', 'error'], 'Test event');\n```\n\n### <a name=\"server.lookup()\" /> `server.lookup(id)`\n\nLooks up a route configuration where:\n\n- `id` - the [route identifier](#route.options.id).\n\nReturn value: the [route information](#request.route) if found, otherwise `null`.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server();\nserver.route({\n    method: 'GET',\n    path: '/',\n    options: {\n        id: 'root',\n        handler: () => 'ok'\n    }\n});\n\nconst route = server.lookup('root');\n```\n\n### <a name=\"server.match()\" /> `server.match(method, path, [host])`\n\nLooks up a route configuration where:\n\n- `method` - the HTTP method (e.g. 'GET', 'POST').\n- `path` - the requested path (must begin with '/').\n- `host` - (optional) hostname (to match against routes with `vhost`).\n\nReturn value: the [route information](#request.route) if found, otherwise `null`.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server();\nserver.route({\n    method: 'GET',\n    path: '/',\n    options: {\n        id: 'root',\n        handler: () => 'ok'\n    }\n});\n\nconst route = server.match('get', '/');\n```\n\n### <a name=\"server.method()\" /> `server.method(name, method, [options])`\n\nRegisters a [server method](#server.methods) where:\n\n- `name` - a unique method name used to invoke the method via [`server.methods[name]`](#server.method).\n\n- `method` - the method function with a signature `async function(...args, [flags])` where:\n    - `...args` - the method function arguments (can be any number of arguments or none).\n    - `flags` - when caching is enabled, an object used to set optional method result flags. This\n      parameter is provided automatically and can only be accessed/modified within the method\n      function. It cannot be passed as an argument.\n        - `ttl` - `0` if result is valid but cannot be cached. Defaults to cache policy.\n\n- `options` - (optional) configuration object:\n\n    - `bind` - a context object passed back to the method function (via `this`) when called.\n      Defaults to active context (set via [`server.bind()`](#server.bind()) when the method is\n      registered. Ignored if the method is an arrow function.\n\n    - `cache` - the same cache configuration used in [`server.cache()`](#server.cache()). The\n      `generateTimeout` option is required, and the `generateFunc` options is not allowed.\n\n    - `generateKey` - a function used to generate a unique key (for caching) from the arguments\n      passed to the method function (the `flags` argument is not passed as input). The server\n      will automatically generate a unique key if the function's arguments are all of types\n      `'string'`, `'number'`, or `'boolean'`. However if the method uses other types of arguments,\n      a key generation function must be provided which takes the same arguments as the function and\n      returns a unique string (or `null` if no key can be generated).\n\nReturn value: none.\n\nMethod names can be nested (e.g. `utils.users.get`) which will automatically create the full path\nunder [`server.methods`](#server.methods) (e.g. accessed via `server.methods.utils.users.get`).\n\nWhen configured with caching enabled, `server.methods[name].cache` is assigned an object with the\nfollowing properties and methods:\n    - `await drop(...args)` - a function that can be used to clear the cache for a given key.\n    - `stats` - an object with cache statistics, see **catbox** for stats documentation.\n\nSimple arguments example:\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n\n    const add = (a, b) => (a + b);\n    server.method('sum', add, { cache: { expiresIn: 2000, generateTimeout: 100 } });\n\n    console.log(await server.methods.sum(4, 5));          // 9\n}\n```\n\nObject argument example:\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n\n    const addArray = function (array) {\n\n        let sum = 0;\n        array.forEach((item) => {\n\n            sum += item;\n        });\n\n        return sum;\n    };\n\n    const options = {\n        cache: { expiresIn: 2000, generateTimeout: 100 },\n        generateKey: (array) => array.join(',')\n    };\n\n    server.method('sumObj', addArray, options);\n\n    console.log(await server.methods.sumObj([5, 6]));     // 11\n}\n```\n\n### <a name=\"server.method.array()\" /> `server.method(methods)`\n\nRegisters a server method function as described in [`server.method()`](#server.method()) using a\nconfiguration object where:\n\n- `methods` - an object or an array of objects where each one contains:\n\n    - `name` - the method name.\n    - `method` - the method function.\n    - `options` - (optional) settings.\n\nReturn value: none.\n\n```js\nconst add = function (a, b) {\n\n    return a + b;\n};\n\nserver.method({\n    name: 'sum',\n    method: add,\n    options: {\n        cache: {\n            expiresIn: 2000,\n            generateTimeout: 100\n        }\n    }\n});\n```\n\n### <a name=\"server.path()\" /> `server.path(relativeTo)`\n\nSets the path prefix used to locate static resources (files and view templates) when relative paths\nare used where:\n\n- `relativeTo` - the path prefix added to any relative file path starting with `'.'`.\n\nReturn value: none.\n\nNote that setting a path within a plugin only applies to resources accessed by plugin methods.\nIf no path is set, the server default [route configuration](#server.options.routes)\n[`files.relativeTo`](#route.options.files) settings is used. The path only applies to routes added\nafter it has been set.\n\n```js\nexports.plugin = {\n    name: 'example',\n    register: function (server, options) {\n\n        // Assuming the Inert plugin was registered previously\n\n        server.path(__dirname + '../static');\n        server.route({ path: '/file', method: 'GET', handler: { file: './test.html' } });\n    }\n};\n```\n\n### <a name=\"server.register()\" /> `await server.register(plugins, [options])`\n\nRegisters a plugin where:\n\n- `plugins` - one or an array of:\n\n    - a [plugin object](#plugins).\n\n    - an object with the following:\n        - `plugin` - a [plugin object](#plugins).\n        - `options` - (optional) options passed to the plugin during registration.\n        - `once`, `routes` - (optional) plugin-specific registration options as defined below.\n\n- `options` - (optional) registration options (different from the options passed to the\n  registration function):\n\n    - `once` - if `true`, subsequent registrations of the same plugin are skipped without error.\n      Cannot be used with plugin options. Defaults to `false`.\n      If not set to `true`, an error will be thrown the second time a plugin is registered on the server.\n\n    - `routes` - modifiers applied to each route added by the plugin:\n\n        - `prefix` - string added as prefix to any route path (must begin with `'/'`). If a plugin\n          registers a child plugin the `prefix` is passed on to the child or is added in front of\n          the child-specific prefix.\n        - `vhost` - virtual host string (or array of strings) applied to every route. The\n          outer-most `vhost` overrides the any nested configuration.\n\nReturn value: a reference to the `server`.\n\n```js\nasync function example() {\n\n    await server.register({ plugin: require('plugin_name'), options: { message: 'hello' } });\n}\n```\n\n### <a name=\"server.route()\" /> `server.route(route)`\n\nAdds a route where:\n\n- `route` - a route configuration object or an array of configuration objects where each object\n  contains:\n\n    - `path` - (required) the absolute path used to match incoming requests (must begin with '/').\n      Incoming requests are compared to the configured paths based on the server's\n      [`router`](#server.options.router) configuration. The path can include named parameters\n      enclosed in `{}` which  will be matched against literal values in the request as described in\n      [Path parameters](#path-parameters).\n\n    - `method` - (required) the HTTP method. Typically one of 'GET', 'POST', 'PUT', 'PATCH',\n      'DELETE', or 'OPTIONS'. Any HTTP method is allowed, except for 'HEAD'. Use `'*'` to match\n      against any HTTP method (only when an exact match was not found, and any match with a\n      specific method will be given a higher priority over a wildcard match). Can be assigned an\n      array of methods which has the same result as adding the same route with different methods\n      manually.\n\n    - `vhost` - (optional) a domain string or an array of domain strings for limiting the route to\n      only requests with a matching host header field. Matching is done against the hostname part\n      of the header only (excluding the port). Defaults to all hosts.\n\n    - `handler` - (required when [`handler`](#route.options.handler) is not set) the route\n      handler function called to generate the response after successful authentication and\n      validation.\n\n    - `options` - additional [route options](#route-options). The `options` value can be an object\n      or a function that returns an object using the signature `function(server)` where `server` is\n      the server the route is being added to and `this` is bound to the current\n      [realm](#server.realm)'s `bind` option.\n\n    - `rules` - route custom rules object. The object is passed to each rules processor registered\n      with [`server.rules()`](#server.rules()). Cannot be used if\n      [`route.options.rules`](#route.options.rules) is defined.\n\nReturn value: none.\n\nNote that the `options` object is deeply cloned (with the exception of `bind` which is shallowly\ncopied) and cannot contain any values that are unsafe to perform deep copy on.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\n// Handler in top level\n\nserver.route({ method: 'GET', path: '/status', handler: () => 'ok' });\n\n// Handler in config\n\nconst user = {\n    cache: { expiresIn: 5000 },\n    handler: function (request, h) {\n\n        return { name: 'John' };\n    }\n};\n\nserver.route({ method: 'GET', path: '/user', options: user });\n\n// An array of routes\n\nserver.route([\n    { method: 'GET', path: '/1', handler: function (request, h) { return 'ok'; } },\n    { method: 'GET', path: '/2', handler: function (request, h) { return 'ok'; } }\n]);\n```\n\n#### Path parameters\n\nParameterized paths are processed by matching the named parameters to the content of the incoming\nrequest path at that path segment. For example, `'/book/{id}/cover'` will match `'/book/123/cover'` and\n`request.params.id` will be set to `'123'`. Each path segment (everything between the opening `'/'`\nand the closing `'/'` unless it is the end of the path) can only include one named parameter. A\nparameter can cover the entire segment (`'/{param}'`) or part of the segment (`'/file.{ext}'`).  A path\nparameter may only contain letters, numbers and underscores, e.g. `'/{file-name}'` is invalid\nand `'/{file_name}'` is valid.\n\nAn optional `'?'` suffix following the parameter name indicates an optional parameter (only allowed\nif the parameter is at the ends of the path or only covers part of the segment as in\n`'/a{param?}/b'`). For example, the route `'/book/{id?}'` matches `'/book/'` with the value of\n`request.params.id` set to an empty string `''`.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst getAlbum = function (request, h) {\n\n    return 'You asked for ' +\n        (request.params.song ? request.params.song + ' from ' : '') +\n        request.params.album;\n};\n\nserver.route({\n    path: '/{album}/{song?}',\n    method: 'GET',\n    handler: getAlbum\n});\n```\n\nIn addition to the optional `?` suffix, a parameter name can also specify the number of matching\nsegments using the `*` suffix, followed by a number greater than 1. If the number of expected parts\ncan be anything, then use `*` without a number (matching any number of segments can only be used in\nthe last path segment).\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst getPerson = function (request, h) {\n\n    const nameParts = request.params.name.split('/');\n    return { first: nameParts[0], last: nameParts[1] };\n};\n\nserver.route({\n    path: '/person/{name*2}',   // Matches '/person/john/doe'\n    method: 'GET',\n    handler: getPerson\n});\n```\n\n#### Path matching order\n\nThe router iterates through the routing table on each incoming request and executes the first (and\nonly the first) matching route. Route matching is done based on the combination of the request path\nand the HTTP verb (e.g. 'GET, 'POST'). The query is excluded from the routing logic. Requests are\nmatched in a deterministic order where the order in which routes are added does not matter.\n\nRoutes are matched based on the specificity of the route which is evaluated at each segment of the\nincoming request path. Each request path is split into its segment (the parts separated by `'/'`).\nThe segments are compared to the routing table one at a time and are matched against the most\nspecific path until a match is found. If no match is found, the next match is tried.\n\nWhen matching routes, string literals (no path parameter) have the highest priority, followed by\nmixed parameters (`'/a{p}b'`), parameters (`'/{p}'`), and then wildcard (`/{p*}`).\n\nNote that mixed parameters are slower to compare as they cannot be hashed and require an array\niteration over all the regular expressions representing the various mixed parameter at each\nrouting table node.\n\n#### Catch all route\n\nIf the application needs to override the default Not Found (404) error response, it can add a\ncatch-all route for a specific method or all methods. Only one catch-all route can be defined.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst handler = function (request, h) {\n\n    return h.response('The page was not found').code(404);\n};\n\nserver.route({ method: '*', path: '/{p*}', handler });\n```\n\n### <a name=\"server.rules()\" /> `server.rules(processor, [options])`\n\nDefines a route rules processor for converting route rules object into route configuration where:\n\n- `processor` - a function using the signature `function(rules, info)` where:\n    - `rules` - the [custom object](#route.options.rules) defined in your routes configuration for you to use its values.\n    - `info` - an object with the following properties:\n        - `method` - the route method.\n        - `path` - the route path.\n        - `vhost` - the route virtual host (if any defined).\n    - returns a route config object.\n\n- `options` - optional settings:\n    - `validate` - rules object validation:\n        - `schema` - **joi** schema.\n        - `options` - optional **joi** validation options. Defaults to `{ allowUnknown: true }`.\n\nNote that the root server and each plugin server instance can only register one rules processor.\nIf a route is added after the rules are configured, it will not include the rules config. Routes\nadded by plugins apply the rules to each of the parent realms' rules from the root to the route's\nrealm. This means the processor defined by the plugin overrides the config generated by the root\nprocessor if they overlap. Similarly, the route's own config overrides the config produced by the rules processors.\n\n```js\nconst validateSchema = {\n    auth: Joi.string(),\n    myCustomPre: Joi.array().min(2).items(Joi.string()),\n    payload: Joi.object()\n};\n\nconst myPreHelper = (name) => {\n\n    return {\n        method: (request, h) => {\n\n            return `hello ${name || 'world'}!`;\n        },\n        assign: 'myPreHelper'\n    };\n};\n\nconst processor = (rules, info) => {\n\n    if (!rules) {\n        return null;\n    }\n\n    const options = {};\n\n    if (rules.auth) {\n        options.auth = {\n            strategy: rules.auth,\n            validate: {\n                entity: 'user'\n            }\n        };\n    }\n\n    if (rules.myCustomPre) {\n        options.pre = [\n            myPreHelper(...rules.myCustomPre)\n        ];\n    }\n\n    if (rules.payload) {\n        options.validate = { payload: Joi.object(rules.payload) };\n    }\n\n    return options;\n};\n\nserver.rules(processor, {\n    validate: { schema: validateSchema }\n});\n\nserver.route({\n    method: 'GET',\n    path: '/',\n    rules: {\n        auth: 'jwt',\n        myCustomPre: ['arg1', 'arg2'],\n        payload: { a: Joi.boolean(), b: Joi.string() }\n    },\n    options: {\n        id: 'my-route'\n    }\n});\n```\n\n### <a name=\"server.start()\" /> `await server.start()`\n\nStarts the server by listening for incoming requests on the configured port (unless the connection\nwas configured with [`autoListen`](#server.options.autoListen) set to `false`).\n\nReturn value: none.\n\nNote that if the method fails and throws an error, the server is considered to be in an undefined\nstate and should be shut down. In most cases it would be impossible to fully recover as the various\nplugins, caches, and other event listeners will get confused by repeated attempts to start the\nserver or make assumptions about the healthy state of the environment. It is recommended to abort\nthe process when the server fails to start properly. If you must try to resume after an error, call\n[`server.stop()`](#server.stop()) first to reset the server state.\n\nIf a started server is started again, the second call to `server.start()` is ignored. No events\nwill be emitted and no extension points invoked.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    await server.start();\n    console.log('Server started at: ' + server.info.uri);\n}\n```\n\n### <a name=\"server.state()\" /> `server.state(name, [options])`\n\n[HTTP state management](https://tools.ietf.org/html/rfc6265) uses client cookies to persist a state\nacross multiple requests. Registers a cookie definitions where:\n\n- `name` - the cookie name string.\n\n- `options` - are the optional cookie settings:\n\n    - `ttl` - time-to-live in milliseconds. Defaults to `null` (session time-life - cookies are deleted when the browser is closed).\n\n    - `isSecure` - sets the 'Secure' flag. Defaults to `true`.\n\n    - `isHttpOnly` - sets the 'HttpOnly' flag. Defaults to `true`.\n\n    - `isSameSite` - sets the ['SameSite' flag](https://www.owasp.org/index.php/SameSite).  The value must be one of:\n\n        - `false` - no flag.\n        - `'Strict'` - sets the value to `'Strict'` (this is the default value).\n        - `'Lax'` - sets the value to `'Lax'`.\n        - `'None'` - sets the value to `'None'`.\n\n    - `path` - the path scope. Defaults to `null` (no path).\n\n    - `domain` - the domain scope. Defaults to `null` (no domain).\n\n    - `autoValue` - if present and the cookie was not received from the client or explicitly set by the route handler, the cookie is automatically added to the response with the provided value. The value can be a function with signature `async function(request)` where:\n\n        - `request` - the [request object](#request).\n\n    - `encoding` - encoding performs on the provided value before serialization. Options are:\n\n        - `'none'` - no encoding. When used, the cookie value must be a string. This is the default value.\n        - `'base64'` - string value is encoded using Base64.\n        - `'base64json'` - object value is JSON-stringified then encoded using Base64.\n        - `'form'` - object value is encoded using the _x-www-form-urlencoded_ method.\n        - `'iron'` - Encrypts and sign the value using [**iron**](https://hapi.dev/family/iron/api).\n\n    - `sign` - an object used to calculate an HMAC for cookie integrity validation. This does not provide privacy, only a mean to verify that the cookie value was generated by the server. Redundant when `'iron'` encoding is used. Options are:\n\n        - `integrity` - algorithm options. Defaults to [`require('iron').defaults.integrity`](https://hapi.dev/family/iron/api/#options).\n        - `password` - password used for HMAC key generation (must be at least 32 characters long).\n\n    - `password` - password used for `'iron'` encoding (must be at least 32 characters long).\n\n    - `iron` - options for `'iron'` encoding. Defaults to [`require('iron').defaults`](https://hapi.dev/family/iron/api/#options).\n\n    - `ignoreErrors` - if `true`, errors are ignored and treated as missing cookies.\n\n    - `clearInvalid` - if `true`, automatically instruct the client to remove invalid cookies. Defaults to `false`.\n\n    - `strictHeader` - if `false`, allows any cookie value including values in violation of [RFC 6265](https://tools.ietf.org/html/rfc6265). Defaults to `true`.\n\n    - `passThrough` - used by proxy plugins (e.g. [**h2o2**](https://hapi.dev/family/h2o2/api)).\n\n    - `contextualize` - a function using the signature `async function(definition, request)` used to override a request-specific cookie settings where:\n\n        - `definition` - a copy of the `options` to be used for formatting the cookie that can be manipulated by the function to customize the request cookie header. Note that changing the `definition.contextualize` property will be ignored.\n        - `request` - the current request object.\n\nReturn value: none.\n\nState defaults can be modified via the [server.options.state](#server.options.state) configuration\noption.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\n// Set cookie definition\n\nserver.state('session', {\n    ttl: 24 * 60 * 60 * 1000,     // One day\n    isSecure: true,\n    path: '/',\n    encoding: 'base64json'\n});\n\n// Set state in route handler\n\nconst handler = function (request, h) {\n\n    let session = request.state.session;\n    if (!session) {\n        session = { user: 'joe' };\n    }\n\n    session.last = Date.now();\n\n    return h.response('Success').state('session', session);\n};\n```\n\nRegistered cookies are automatically parsed when received. Parsing rules depends on the route\n[`state.parse`](#route.options.state) configuration. If an incoming registered cookie fails parsing,\nit is not included in [`request.state`](#request.state), regardless of the\n[`state.failAction`](#route.options.state.failAction) setting. When [`state.failAction`](#route.options.state.failAction)\nis set to `'log'` and an invalid cookie value is received, the server will emit a\n[`'request'` event](#server.events.request). To capture these errors subscribe to the `'request'`\nevent on the `'internal'` channel and filter on `'error'` and `'state'` tags:\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nserver.events.on({ name: 'request', channels: 'internal' }, (request, event, tags) => {\n\n    if (tags.error && tags.state) {\n        console.error(event);\n    }\n});\n```\n\n### <a name=\"server.states.add()\" /> `server.states.add(name, [options])`\n\nAccess: read only.\n\nSame as calling [`server.state()`](#server.state()).\n\n### <a name=\"server.states.format()\" /> `await server.states.format(cookies)`\n\nFormats an HTTP 'Set-Cookie' header based on the [`server.options.state`](#server.options.state)\nwhere:\n\n- `cookies` - a single object or an array of object where each contains:\n    - `name` - the cookie name.\n    - `value` - the cookie value.\n    - `options` - cookie configuration to override the server settings.\n\nReturn value: a header string.\n\nNote that this utility uses the server configuration but does not change the server state. It is\nprovided for manual cookie formatting (e.g. when headers are set manually).\n\n### <a name=\"server.states.parse()\" /> `await server.states.parse(header)`\n\nParses an HTTP 'Cookies' header based on the [`server.options.state`](#server.options.state) where:\n\n- `header` - the HTTP header.\n\nReturn value: an object where each key is a cookie name and value is the parsed cookie.\n\nNote that this utility uses the server configuration but does not change the server state. It is\nprovided for manual cookie parsing (e.g. when server parsing is disabled).\n\n### <a name=\"server.stop()\" /> `await server.stop([options])`\n\nStops the server's listener by refusing to accept any new connections or requests (existing\nconnections will continue until closed or timeout), where:\n\n- `options` - (optional) object with:\n\n    - `timeout` - sets the timeout in millisecond before forcefully terminating any open\n      connections that arrived before the server stopped accepting new connections. The timeout\n      only applies to waiting for existing connections to close, and not to any\n      [`'onPreStop'` or `'onPostStop'` server extensions](#server.ext.args()) which can\n      delay or block the stop operation indefinitely. Ignored if\n      [`server.options.operations.cleanStop`](#server.options.operations) is `false`. Note that if\n      the server is set as a [group controller](#server.control()), the timeout is per controlled\n      server and the controlling server itself. Defaults to `5000` (5 seconds).\n\nReturn value: none.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    await server.start();\n    await server.stop({ timeout: 60 * 1000 });\n    console.log('Server stopped');\n}\n```\n\n### <a name=\"server.table()\" /> `server.table([host])`\n\nReturns a copy of the routing table where:\n\n- `host` - (optional) host to filter routes matching a specific virtual host. Defaults to all\n  virtual hosts.\n\nReturn value: an array of routes where each route contains:\n- `settings` - the route config with defaults applied.\n- `method` - the HTTP method in lower case.\n- `path` - the route path.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\nserver.route({ method: 'GET', path: '/example', handler: () => 'ok' });\n\nconst table = server.table();\n```\n\n### <a name=\"server.validator()\" /> `server.validator(validator)`\n\nRegisters a server validation module used to compile raw validation rules into validation schemas for all routes where:\n\n- `validator` - the validation module (e.g. **joi**).\n\nReturn value: none.\n\nNote: the validator is only used when validation rules are not pre-compiled schemas. When a validation rules is a function or schema object, the rule is used as-is and the validator is not used. When setting a validator inside a plugin, the validator is only applied to routes set up by the plugin and plugins registered by it.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst Joi = require('joi');\n\nasync function example() {\n\n    const server = Hapi.server({ port: 80 });\n    server.validator(Joi);\n}\n```\n\n## Route options\n\nEach route can be customized to change the default behavior of the request lifecycle.\n\n### <a name=\"route.options.app\" /> `route.options.app`\n\nApplication-specific route configuration state. Should not be used by [plugins](#plugins) which\nshould use `options.plugins[name]` instead.\n\n### <a name=\"route.options.auth\" /> `route.options.auth`\n\nRoute authentication configuration. Value can be:\n\n- `false` to disable authentication if a default strategy is set.\n\n- a string with the name of an authentication strategy registered with\n  [`server.auth.strategy()`](#server.auth.strategy()). The strategy will be\n  set to `'required'` mode.\n\n- an [authentication configuration object](#authentication-options).\n\n#### <a name=\"route.options.auth.access\" /> `route.options.auth.access`\n\nDefault value: none.\n\nAn object or array of objects specifying the route access rules. Each rule is evaluated against an\nincoming request and access is granted if at least one of the rules matches. Each rule object must\ninclude at least one of [`scope`](#route.options.auth.access.scope) or\n[`entity`](#route.options.auth.access.entity).\n\n#### <a name=\"route.options.auth.access.scope\" /> `route.options.auth.access.scope`\n\nDefault value: `false` (no scope requirements).\n\nThe application scope required to access the route. Value can be a scope string or an\narray of scope strings. When authenticated, the credentials object `scope` property must contain\nat least one of the scopes defined to access the route.\n\nIf a scope string begins with a `+` character, that scope is required. If a scope string begins\nwith a `!` character, that scope is forbidden. For example, the scope `['!a', '+b', 'c', 'd']`\nmeans the incoming request credentials' `scope` must not include 'a', must include 'b', and must\ninclude one of 'c' or 'd'.\n\nYou may also access properties on the request object (`query`, `params`, `payload`, and\n`credentials`) to populate a dynamic scope by using the '{' and '}' characters around the property\nname, such as `'user-{params.id}'`.\n\n#### <a name=\"route.options.auth.access.entity\" /> `route.options.auth.access.entity`\n\nDefault value: `'any'`.\n\nThe required authenticated entity type. If set, must match the `entity` value of the request\nauthenticated credentials. Available values:\n\n- `'any'` - the authentication can be on behalf of a user or application.\n- `'user'` - the authentication must be on behalf of a user which is identified by the presence of\n  a `'user'` attribute in the `credentials` object returned by the authentication strategy.\n- `'app'` - the authentication must be on behalf of an application which is identified by the lack\n  of presence of a `user` attribute in the `credentials` object returned by the authentication\n  strategy.\n\n#### <a name=\"route.options.auth.mode\" /> `route.options.auth.mode`\n\nDefault value: `'required'`.\n\nThe authentication mode. Available values:\n\n- `'required'` - authentication is required.\n- `'optional'` - authentication is optional - the request must include valid credentials or no\n  credentials at all.\n- `'try'` - similar to `'optional'`, any request credentials are attempted authentication, but if\n  the credentials are invalid, the request proceeds regardless of the authentication error.\n\n#### <a name=\"route.options.auth.payload\" /> `route.options.auth.payload`\n\nDefault value: `false`, unless the scheme requires payload authentication.\n\nIf set, the incoming request payload is authenticated after it is processed. Requires a strategy\nwith payload authentication support (e.g. [Hawk](https://hapi.dev/family/hawk/api)). Cannot be\nset to a value other than `'required'` when the scheme sets the authentication `options.payload` to\n`true`.\n\nAvailable values:\n\n- `false` - no payload authentication.\n- `'required'` - payload authentication required.\n- `'optional'` - payload authentication performed only when the client includes payload\n  authentication information (e.g. `hash` attribute in Hawk).\n\n#### <a name=\"route.options.auth.strategies\" /> `route.options.auth.strategies`\n\nDefault value: the default strategy set via [`server.auth.default()`](#server.auth.default()).\n\nAn array of string strategy names in the order they should be attempted. Cannot be used together\nwith [`strategy`](#route.options.auth.strategy).\n\n#### <a name=\"route.options.auth.strategy\" /> `route.options.auth.strategy`\n\nDefault value: the default strategy set via [`server.auth.default()`](#server.auth.default()).\n\nA string strategy names. Cannot be used together with [`strategies`](#route.options.auth.strategies).\n\n### <a name=\"route.options.bind\" /> `route.options.bind`\n\nDefault value: `null`.\n\nAn object passed back to the provided `handler` (via `this`) when called. Ignored if the method is\nan arrow function.\n\n### <a name=\"route.options.cache\" /> `route.options.cache`\n\nDefault value: `{ privacy: 'default', statuses: [200], otherwise: 'no-cache' }`.\n\nIf the route method is 'GET', the route can be configured to include HTTP caching directives in the\nresponse. Caching can be customized using an object with the following options:\n\n- `privacy` - determines the privacy flag included in client-side caching using the 'Cache-Control'\n  header. Values are:\n\n    - `'default'` - no privacy flag.\n    - `'public'` - mark the response as suitable for public caching.\n    - `'private'` - mark the response as suitable only for private caching.\n\n- `expiresIn` - relative expiration expressed in the number of milliseconds since the\n  item was saved in the cache. Cannot be used together with `expiresAt`.\n\n- `expiresAt` - time of day expressed in 24h notation using the 'HH:MM' format, at which\n  point all cache records for the route expire. Cannot be used together with `expiresIn`.\n\n- `statuses` - an array of HTTP response status code numbers (e.g. `200`) which are allowed to\n  include a valid caching directive.\n\n- `otherwise` - a string with the value of the 'Cache-Control' header when caching is disabled.\n\nThe default `Cache-Control: no-cache` header can be disabled by setting `cache` to `false`.\n\n### <a name=\"route.options.compression\" /> `route.options.compression`\n\nAn object where each key is a content-encoding name and each value is an object with the desired\nencoder settings. Note that decoder settings are set in [`compression`](#route.options.payload.compression).\n\n### <a name=\"route.options.cors\" /> `route.options.cors`\n\nDefault value: `false` (no CORS headers).\n\nThe [Cross-Origin Resource Sharing](https://www.w3.org/TR/cors/) protocol allows browsers to make\ncross-origin API calls. CORS is required by web applications running inside a browser which are\nloaded from a different domain than the API server. To enable, set `cors` to `true`, or to an\nobject with the following options:\n\n- `origin` - an array of allowed origin servers strings ('Access-Control-Allow-Origin'). The array\n  can contain any combination of fully qualified origins along with origin strings containing a\n  wildcard `'*'` character, or a single `'*'` origin string. If set to `'ignore'`, any incoming\n  Origin header is ignored (present or not) and the 'Access-Control-Allow-Origin' header is set to\n  `'*'`. Defaults to any origin `['*']`.\n\n- `maxAge` - number of seconds the browser should cache the CORS response\n  ('Access-Control-Max-Age'). The greater the value, the longer it will take before the browser\n  checks for changes in policy. Defaults to `86400` (one day).\n\n- `headers` - a strings array of allowed headers ('Access-Control-Allow-Headers'). Defaults to\n  `['Accept', 'Authorization', 'Content-Type', 'If-None-Match']`.\n\n- `additionalHeaders` - a strings array of additional headers to `headers`. Use this to keep the\n  default headers in place.\n\n- `exposedHeaders` - a strings array of exposed headers ('Access-Control-Expose-Headers').\n  Defaults to `['WWW-Authenticate', 'Server-Authorization']`.\n\n- `additionalExposedHeaders` - a strings array of additional headers to `exposedHeaders`. Use this\n  to keep the default headers in place.\n\n- `credentials` - if `true`, allows user credentials to be sent\n  ('Access-Control-Allow-Credentials'). Defaults to `false`.\n\n - `preflightStatusCode` - the status code used for CORS preflight responses, either `200` or `204`.\n   Defaults to `200`.\n\n### <a name=\"route.options.description\" /> `route.options.description`\n\nDefault value: none.\n\nRoute description used for generating documentation (string).\n\nThis setting is not available when setting server route defaults using\n[`server.options.routes`](#server.options.routes).\n\n### <a name=\"route.options.ext\" /> `route.options.ext`\n\nDefault value: none.\n\nRoute-level [request extension points](#request-lifecycle) by setting the option to an object with\na key for each of the desired extension points (`'onRequest'` is not allowed), and the value is the\nsame as the [`server.ext(events)`](#server.ext()) `event` argument.\n\n### <a name=\"route.options.files\" /> `route.options.files`\n\nDefault value: `{ relativeTo: '.' }`.\n\nDefines the behavior for accessing files:\n\n- `relativeTo` - determines the folder relative paths are resolved against.\n\n### <a name=\"route.options.handler\" /> `route.options.handler`\n\nDefault value: none.\n\nThe route handler function performs the main business logic of the route and sets the response.\n`handler` can be assigned:\n\n- a [lifecycle method](#lifecycle-methods).\n\n- an object with a single property using the name of a handler type registered with the\n  [`server.decorate()`](#server.decorate()) method. The matching property value is passed\n  as options to the registered handler generator.\n\n```js\nconst handler = function (request, h) {\n\n    return 'success';\n};\n```\n\nNote: handlers using a fat arrow style function cannot be bound to any `bind` property. Instead,\nthe bound context is available under [`h.context`](#h.context).\n\n### <a name=\"route.options.id\" /> `route.options.id`\n\nDefault value: none.\n\nAn optional unique identifier used to look up the route using [`server.lookup()`](#server.lookup()).\nCannot be assigned to routes added with an array of methods.\n\n### <a name=\"route.options.isInternal\" /> `route.options.isInternal`\n\nDefault value: `false`.\n\nIf `true`, the route cannot be accessed through the HTTP listener but only through the\n[`server.inject()`](#server.inject()) interface with the `allowInternals` option set to `true`.\nUsed for internal routes that should not be accessible to the outside world.\n\n### <a name=\"route.options.json\" /> `route.options.json`\n\nDefault value: none.\n\nOptional arguments passed to `JSON.stringify()` when converting an object or error response to a\nstring payload or escaping it after stringification. Supports the following:\n\n- `replacer` - the replacer function or array. Defaults to no action.\n\n- `space` - number of spaces to indent nested object keys. Defaults to no indentation.\n\n- `suffix` - string suffix added after conversion to JSON string. Defaults to no suffix.\n\n- `escape` - calls [`Hoek.jsonEscape()`](https://hapi.dev/family/hoek/api/#escapejsonstring)\n  after conversion to JSON string. Defaults to `false`.\n\n### <a name=\"route.options.log\" /> `route.options.log`\n\nDefault value: `{ collect: false }`.\n\nRequest logging options:\n\n- `collect` - if `true`, request-level logs (both internal and application) are collected and\n  accessible via [`request.logs`](#request.logs).\n\n### <a name=\"route.options.notes\" /> `route.options.notes`\n\nDefault value: none.\n\nRoute notes used for generating documentation (string or array of strings).\n\nThis setting is not available when setting server route defaults using\n[`server.options.routes`](#server.options.routes).\n\n### <a name=\"route.options.payload\" /> `route.options.payload`\n\nDetermines how the request payload is processed.\n\n#### <a name=\"route.options.payload.allow\" /> `route.options.payload.allow`\n\nDefault value: allows parsing of the following mime types:\n- application/json\n- application/*+json\n- application/octet-stream\n- application/x-www-form-urlencoded\n- multipart/form-data\n- text/*\n\nA string or an array of strings with the allowed mime types for the endpoint. Use this settings to\nlimit the set of allowed mime types. Note that allowing additional mime types not listed above will\nnot enable them to be parsed, and if [`parse`](#route.options.payload.parse) is `true`, the request\nwill result in an error response.\n\n#### <a name=\"route.options.payload.compression\" /> `route.options.payload.compression`\n\nDefault value: none.\n\nAn object where each key is a content-encoding name and each value is an object with the desired\ndecoder settings. Note that encoder settings are set in [`compression`](#server.options.compression).\n\n#### <a name=\"route.options.payload.defaultContentType\" /> `route.options.payload.defaultContentType`\n\nDefault value: `'application/json'`.\n\nThe default content type if the 'Content-Type' request header is missing.\n\n#### <a name=\"route.options.payload.failAction\" /> `route.options.payload.failAction`\n\nDefault value: `'error'` (return a Bad Request (400) error response).\n\nA [`failAction` value](#lifecycle-failAction) which determines how to handle payload parsing\nerrors.\n\n#### <a name=\"route.options.payload.maxBytes\" /> `route.options.payload.maxBytes`\n\nDefault value: `1048576` (1MB).\n\nLimits the size of incoming payloads to the specified byte count. Allowing very large payloads may\ncause the server to run out of memory.\n\n#### <a name=\"route.options.payload.maxParts\" /> `route.options.payload.maxParts`\n\nDefault value: `1000`.\n\nLimits the number of parts allowed in multipart payloads.\n\n#### <a name=\"route.options.payload.multipart\" /> `route.options.payload.multipart`\n\nDefault value: `false`.\n\nOverrides payload processing for multipart requests. Value can be one of:\n\n- `false` - disable multipart processing (this is the default value).\n\n- `true` - enable multipart processing using the [`output`](#route.options.payload.output) value.\n\n- an object with the following required options:\n\n    - `output` - same as the [`output`](#route.options.payload.output) option with an additional\n      value option:\n        - `annotated` - wraps each multipart part in an object with the following keys:\n\n            - `headers` - the part headers.\n            - `filename` - the part file name.\n            - `payload` - the processed part payload.\n\n#### <a name=\"route.options.payload.output\" /> `route.options.payload.output`\n\nDefault value: `'data'`.\n\nThe processed payload format. The value must be one of:\n\n- `'data'` - the incoming payload is read fully into memory. If [`parse`](#route.options.payload.parse)\n  is `true`, the payload is parsed (JSON, form-decoded, multipart) based on the 'Content-Type'\n  header. If [`parse`](#route.options.payload.parse) is `false`, a raw `Buffer` is returned.\n\n- `'stream'` - the incoming payload is made available via a `Stream.Readable` interface. If the\n  payload is 'multipart/form-data' and [`parse`](#route.options.payload.parse) is `true`, field\n  values are presented as text while files are provided as streams. File streams from a\n  'multipart/form-data' upload will also have a `hapi` property containing the `filename` and\n  `headers` properties. Note that payload streams for multipart payloads are a synthetic interface\n  created on top of the entire multipart content loaded into memory. To avoid loading large\n  multipart payloads into memory, set [`parse`](#route.options.payload.parse) to `false` and handle\n  the multipart payload in the handler using a streaming parser (e.g. [**pez**](https://hapi.dev/family/pez/api)).\n\n- `'file'` - the incoming payload is written to temporary file in the directory specified by the\n  [`uploads`](#route.options.payload.uploads) settings. If the payload is 'multipart/form-data' and\n  [`parse`](#route.options.payload.parse) is `true`, field values are presented as text while files\n  are saved to disk. Note that it is the sole responsibility of the application to clean up the\n  files generated by the framework. This can be done by keeping track of which files are used (e.g.\n  using the `request.app` object), and listening to the server `'response'` event to perform\n  cleanup.\n\n#### <a name=\"route.options.payload.override\" /> `route.options.payload.override`\n\nDefault value: none.\n\nA mime type string overriding the 'Content-Type' header value received.\n\n#### <a name=\"route.options.payload.parse\" /> `route.options.payload.parse`\n\nDefault value: `true`.\n\nDetermines if the incoming payload is processed or presented raw. Available values:\n\n- `true` - if the request 'Content-Type' matches the allowed mime types set by\n  [`allow`](#route.options.payload.allow) (for the whole payload as well as parts), the payload is\n  converted into an object when possible. If the format is unknown, a Bad Request (400) error\n  response is sent. Any known content encoding is decoded.\n\n- `false` - the raw payload is returned unmodified.\n\n- `'gunzip'` - the raw payload is returned unmodified after any known content encoding is decoded.\n\n#### <a name=\"route.options.payload.protoAction\" /> `route.options.payload.protoAction`\n\nDefault value: `'error'`.\n\nSets handling of incoming payload that may contain a prototype poisoning security attack. Available\nvalues:\n\n- `'error'` - returns a `400` bad request error when the payload contains a prototype.\n\n- `'remove'` - sanitizes the payload to remove the prototype.\n\n- `'ignore'` - disables the protection and allows the payload to pass as received. Use this option\n  only when you are sure that such incoming data cannot pose any risks to your application.\n\n#### <a name=\"route.options.payload.timeout\" /> `route.options.payload.timeout`\n\nDefault value: to `10000` (10 seconds).\n\nPayload reception timeout in milliseconds. Sets the maximum time allowed for the client to transmit\nthe request payload (body) before giving up and responding with a Request Timeout (408) error\nresponse.\n\nSet to `false` to disable.\n\n#### <a name=\"route.options.payload.uploads\" /> `route.options.payload.uploads`\n\nDefault value: `os.tmpdir()`.\n\nThe directory used for writing file uploads.\n\n### <a name=\"route.options.plugins\" /> `route.options.plugins`\n\nDefault value: `{}`.\n\nPlugin-specific configuration. `plugins` is an object where each key is a plugin name and the value\nis the plugin configuration.\n\n### <a name=\"route.options.pre\" /> `route.options.pre`\n\nDefault value: none.\n\nThe `pre` option allows defining methods for performing actions before the handler is called. These\nmethods allow breaking the handler logic into smaller, reusable components that can be shared\nacross routes, as well as provide a cleaner error handling of prerequisite operations (e.g. load\nrequired reference data from a database).\n\n`pre` is assigned an ordered array of methods which are called serially in order. If the `pre`\narray contains another array of methods as one of its elements, those methods are called in\nparallel. Note that during parallel execution, if any of the methods error, return a\n[takeover response](#takeover-response), or abort signal, the other parallel methods will continue\nto execute but will be ignored once completed.\n\n`pre` can be assigned a mixed array of:\n\n- an array containing the elements listed below, which are executed in parallel.\n\n- an object with:\n    - `method` - a [lifecycle method](#lifecycle-methods).\n    - `assign` - key name used to assign the response of the method to in [`request.pre`](#request.pre)\n      and [`request.preResponses`](#request.preResponses).\n    - `failAction` - A [`failAction` value](#lifecycle-failAction) which determine what to do when\n      a pre-handler method throws an error. If `assign` is specified and the `failAction` setting\n      is not `'error'`, the error will be assigned.\n\n- a method function - same as including an object with a single `method` key.\n\nNote that pre-handler methods do not behave the same way other [lifecycle methods](#lifecycle-methods)\ndo when a value is returned. Instead of the return value becoming the new response payload, the\nvalue is used to assign the corresponding [`request.pre`](#request.pre) and\n[`request.preResponses`](#request.preResponses) properties. Otherwise, the handling of errors,\n[takeover response](#takeover-response) response, or abort signal behave the same as any other\n[lifecycle methods](#lifecycle-methods).\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst pre1 = function (request, h) {\n\n    return 'Hello';\n};\n\nconst pre2 = function (request, h) {\n\n    return 'World';\n};\n\nconst pre3 = function (request, h) {\n\n    return request.pre.m1 + ' ' + request.pre.m2;\n};\n\nserver.route({\n    method: 'GET',\n    path: '/',\n    options: {\n        pre: [\n            [\n                // m1 and m2 executed in parallel\n                { method: pre1, assign: 'm1' },\n                { method: pre2, assign: 'm2' }\n            ],\n            { method: pre3, assign: 'm3' },\n        ],\n        handler: function (request, h) {\n\n            return request.pre.m3 + '!\\n';\n        }\n    }\n});\n```\n\n### <a name=\"route.options.response\" /> `route.options.response`\n\nProcessing rules for the outgoing response.\n\n#### <a name=\"route.options.response.disconnectStatusCode\" /> `route.options.response.disconnectStatusCode`\n\n Default value: `499`.\n\nThe default HTTP status code used to set a response error when the request is closed or aborted\nbefore the response is fully transmitted. Value can be any integer greater or equal to `400`. The\ndefault value `499` is based on the non-standard nginx \"CLIENT CLOSED REQUEST\" error. The value is\nonly used for logging as the request has already ended.\n\n#### <a name=\"route.options.response.emptyStatusCode\" /> `route.options.response.emptyStatusCode`\n\n Default value: `204`.\n\nThe default HTTP status code when the payload is considered empty. Value can be `200` or `204`.\nNote that a `200` status code is converted to a `204` only at the time of response transmission\n(the response status code will remain `200` throughout the request lifecycle unless manually set).\n\n#### <a name=\"route.options.response.failAction\" /> `route.options.response.failAction`\n\nDefault value: `'error'` (return an Internal Server Error (500) error response).\n\nA [`failAction` value](#lifecycle-failAction) which defines what to do when a response fails\npayload validation.\n\n#### <a name=\"route.options.response.modify\" /> `route.options.response.modify`\n\nDefault value: `false`.\n\nIf `true`, applies the validation rule changes to the response payload.\n\n#### <a name=\"route.options.response.options\" /> `route.options.response.options`\n\nDefault value: none.\n\n[**joi**](https://joi.dev/api) options object pass to the validation function. Useful to set global options such as `stripUnknown` or `abortEarly`. If a custom validation function is defined via [`schema`](#route.options.response.schema) or [`status`](#route.options.response.status) then `options` can an arbitrary object that will be passed to this function as the second argument.\n\n#### <a name=\"route.options.response.ranges\" /> `route.options.response.ranges`\n\nDefault value: `true`.\n\nIf `false`, payload [range](https://tools.ietf.org/html/rfc7233#section-3) support is disabled.\n\n#### <a name=\"route.options.response.sample\" /> `route.options.response.sample`\n\nDefault value: `100` (all responses).\n\nThe percent of response payloads validated (0 - 100). Set to `0` to disable all validation.\n\n#### <a name=\"route.options.response.schema\" /> `route.options.response.schema`\n\nDefault value: `true` (no validation).\n\nThe default response payload validation rules (for all non-error responses) expressed as one of:\n\n- `true` - any payload allowed (no validation).\n\n- `false` - no payload allowed.\n\n- a [**joi**](https://joi.dev/api) validation object. The [`options`](#route.options.response.options)\n  along with the request context (`{ headers, params, query, payload, state, app, auth }`) are passed to\n  the validation function.\n\n- a validation function using the signature `async function(value, options)` where:\n\n    - `value` - the pending response payload.\n    - `options` - The [`options`](#route.options.response.options) along with the request context\n      (`{ headers, params, query, payload, state, app, auth }`).\n\n    - if the function returns a value and [`modify`](#route.options.response.modify) is `true`,\n      the value is used as the new response. If the original response is an error, the return\n      value is used to override the original error `output.payload`. If an error is thrown, the\n      error is processed according to [`failAction`](#route.options.response.failAction).\n\n#### <a name=\"route.options.response.status\" /> `route.options.response.status`\n\nDefault value: none.\n\nValidation schemas for specific HTTP status codes. Responses (excluding errors) not matching the\nlisted status codes are validated using the default [`schema`](#route.options.response.schema).\n\n`status` is set to an object where each key is a 3 digit HTTP status code and the value has the\nsame definition as [`schema`](#route.options.response.schema).\n\n### <a name=\"route.options.rules\" /> `route.options.rules`\n\nDefault value: none.\n\nA custom rules object passed to each rules processor registered with [`server.rules()`](#server.rules()).\n\n### <a name=\"route.options.security\" /> `route.options.security`\n\nDefault value: `false` (security headers disabled).\n\nSets common security headers. To enable, set `security` to `true` or to an object with the\nfollowing options:\n\n- `hsts` - controls the 'Strict-Transport-Security' header, where:\n\n    - `true` - the header will be set to `max-age=15768000`. This is the default value.\n    - a number - the maxAge parameter will be set to the provided value.\n\n    - an object with the following fields:\n        - `maxAge` - the max-age portion of the header, as a number. Default is `15768000`.\n        - `includeSubDomains` - a boolean specifying whether to add the `includeSubDomains` flag to\n          the header.\n        - `preload` - a boolean specifying whether to add the `'preload'` flag (used to submit\n          domains inclusion in Chrome's HTTP Strict Transport Security (HSTS) preload list) to the\n          header.\n\n- `xframe` - controls the 'X-Frame-Options' header, where:\n\n    - `true` - the header will be set to `'DENY'`. This is the default value.\n    - `'deny'` - the headers will be set to `'DENY'`.\n    - `'sameorigin'` - the headers will be set to `'SAMEORIGIN'`.\n\n    - an object for specifying the 'allow-from' rule, where:\n        - `rule` - one of:\n            - `'deny'`\n            - `'sameorigin'`\n            - `'allow-from'`\n        - `source` - when `rule` is `'allow-from'` this is used to form the rest of the header,\n          otherwise this field is ignored. If `rule` is `'allow-from'` but `source` is unset, the\n          rule will be automatically changed to `'sameorigin'`.\n\n- `xss` - controls the 'X-XSS-Protection' header, where:\n\n    - `'disabled'` - the header will be set to `'0'`.  This is the default value.\n    - `'enabled'` - the header will be set to `'1; mode=block'`.\n    - `false` - the header will be omitted.\n\n    Note: when enabled, this setting can create a security vulnerabilities in versions of Internet Explorer\n    below 8, unpatched versions of IE8, and browsers that employ an XSS filter/auditor. See\n    [here](https://hackademix.net/2009/11/21/ies-xss-filter-creates-xss-vulnerabilities/),\n    [here](https://technet.microsoft.com/library/security/ms10-002), and\n    [here](https://blog.innerht.ml/the-misunderstood-x-xss-protection/) for more information.\n\n- `noOpen` - boolean controlling the 'X-Download-Options' header for Internet Explorer, preventing\n  downloads from executing in your context. Defaults to `true` setting the header to `'noopen'`.\n\n- `noSniff` - boolean controlling the 'X-Content-Type-Options' header. Defaults to `true` setting\n  the header to its only and default option, `'nosniff'`.\n\n- `referrer` - controls the ['Referrer-Policy'](https://www.w3.org/TR/referrer-policy/) header, which has the following possible values.\n    - `false` - the 'Referrer-Policy' header will not be sent to clients with responses. This is the default value.\n    - `''` - instructs clients that the Referrer-Policy will be [defined elsewhere](https://www.w3.org/TR/referrer-policy/#referrer-policy-empty-string), such as in a meta html tag.\n    - `'no-referrer'` - instructs clients to never include the referrer header when making requests.\n    - `'no-referrer-when-downgrade'` - instructs clients to never include the referrer when navigating from HTTPS to HTTP.\n    - `'same-origin'` - instructs clients to only include the referrer on the current site origin.\n    - `'origin'` - instructs clients to include the referrer but strip off path information so that the value is the current origin only.\n    - `'strict-origin'` - same as `'origin'` but instructs clients to omit the referrer header when going from HTTPS to HTTP.\n    - `'origin-when-cross-origin'` - instructs clients to include the full path in the referrer header for same-origin requests but only the origin components of the URL are included for cross origin requests.\n    - `'strict-origin-when-cross-origin'` - same as `'origin-when-cross-origin'` but the client is instructed to omit the referrer when going from HTTPS to HTTP.\n    - `'unsafe-url'` - instructs the client to always include the referrer with the full URL.\n\n### <a name=\"route.options.state\" /> `route.options.state`\n\nDefault value: `{ parse: true, failAction: 'error' }`.\n\nHTTP state management (cookies) allows the server to store information on the client which is sent\nback to the server with every request (as defined in [RFC 6265](https://tools.ietf.org/html/rfc6265)).\n`state` supports the following options:\n\n- `parse` - determines if incoming 'Cookie' headers are parsed and stored in the\n  [`request.state`](#request.state) object.\n\n- `failAction` - A [`failAction` value](#lifecycle-failAction) which determines how to handle\n  cookie parsing errors. Defaults to `'error'` (return a Bad Request (400) error response).\n\n### <a name=\"route.options.tags\" /> `route.options.tags`\n\nDefault value: none.\n\nRoute tags used for generating documentation (array of strings).\n\nThis setting is not available when setting server route defaults using\n[`server.options.routes`](#server.options.routes).\n\n### <a name=\"route.options.timeout\" /> `route.options.timeout`\n\nDefault value: `{ server: false }`.\n\nTimeouts for processing durations.\n\n#### <a name=\"route.options.timeout.server\" /> `route.options.timeout.server`\n\nDefault value: `false`.\n\nResponse timeout in milliseconds. Sets the maximum time allowed for the server to respond to an\nincoming request before giving up and responding with a Service Unavailable (503) error response.\n\n#### <a name=\"route.options.timeout.socket\" /> `route.options.timeout.socket`\n\nDefault value: none (use node default of 2 minutes).\n\nBy default, node sockets automatically timeout after 2 minutes. Use this option to override this\nbehavior. Set to `false` to disable socket timeouts.\n\n### <a name=\"route.options.validate\" /> `route.options.validate`\n\nDefault value: `{ headers: true, params: true, query: true, payload: true, state: true, failAction: 'error' }`.\n\nRequest input validation rules for various request components.\n\n#### <a name=\"route.options.validate.errorFields\" /> `route.options.validate.errorFields`\n\nDefault value: none.\n\nAn optional object with error fields copied into every validation error response.\n\n#### <a name=\"route.options.validate.failAction\" /> `route.options.validate.failAction`\n\nDefault value: `'error'` (return a Bad Request (400) error response).\n\nA [`failAction` value](#lifecycle-failAction) which determines how to handle failed validations.\nWhen set to a function, the `err` argument includes the type of validation error under\n`err.output.payload.validation.source`. The default error that would otherwise have been logged\n or returned can be accessed under `err.data.defaultError`.\n\n#### <a name=\"route.options.validate.headers\" /> `route.options.validate.headers`\n\nDefault value: `true` (no validation).\n\nValidation rules for incoming request headers:\n\n- `true` - any headers allowed (no validation performed).\n\n- a [**joi**](https://joi.dev/api) validation object.\n\n- a validation function using the signature `async function(value, options)` where:\n\n    - `value` - the [`request.headers`](#request.headers) object containing the request headers.\n    - `options` - [`options`](#route.options.validate.options).\n    - if a value is returned, the value is used as the new [`request.headers`](#request.headers)\n      value and the original value is stored in [`request.orig.headers`](#request.orig).\n      Otherwise, the headers are left unchanged. If an error is thrown, the error is handled\n      according to [`failAction`](#route.options.validate.failAction).\n\nNote that all header field names must be in lowercase to match the headers normalized by node.\n\n#### <a name=\"route.options.validate.options\" /> `route.options.validate.options`\n\nDefault value: none.\n\nAn options object passed to the [**joi**](https://joi.dev/api) rules or the custom\nvalidation methods. Used for setting global options such as `stripUnknown` or `abortEarly`.\n\nIf a custom validation function (see `headers`, `params`, `query`, or `payload` above) is defined\nthen `options` can an arbitrary object that will be passed to this function as the second\nparameter.\n\nThe values of the other inputs (i.e. `headers`, `query`, `params`, `payload`, `state`, `app`, and `auth`)\nare added to the `options` object under the validation `context` (accessible in rules as\n`Joi.ref('$query.key')`).\n\nNote that validation is performed in order (i.e. headers, params, query, and payload) and if type\ncasting is used (e.g. converting a string to a number), the value of inputs not yet validated will\nreflect the raw, unvalidated and unmodified values.\n\nIf the validation rules for `headers`, `params`, `query`, and `payload` are defined at both the\nserver [`routes`](#server.options.routes) level and at the route level, the individual route\nsettings override the routes defaults (the rules are not merged).\n\n#### <a name=\"route.options.validate.params\" /> `route.options.validate.params`\n\nDefault value: `true` (no validation).\n\nValidation rules for incoming request path parameters, after matching the path against the route,\nextracting any parameters, and storing them in [`request.params`](#request.params), where:\n\n- `true` - any path parameter value allowed (no validation performed).\n\n- a [**joi**](https://joi.dev/api) validation object.\n\n- a validation function using the signature `async function(value, options)` where:\n\n    - `value` - the [`request.params`](#request.params) object containing the request path\n      parameters.\n    - `options` - [`options`](#route.options.validate.options).\n    - if a value is returned, the value is used as the new [`request.params`](#request.params)\n      value and the original value is stored in [`request.orig.params`](#request.orig). Otherwise,\n      the path parameters are left unchanged. If an error is thrown, the error is handled according\n      to [`failAction`](#route.options.validate.failAction).\n\nNote that failing to match the validation rules to the route path parameters definition will cause\nall requests to fail.\n\n#### <a name=\"route.options.validate.payload\" /> `route.options.validate.payload`\n\nDefault value: `true` (no validation).\n\nValidation rules for incoming request payload (request body), where:\n\n- `true` - any payload allowed (no validation performed).\n\n- `false` - no payload allowed.\n\n- a [**joi**](https://joi.dev/api) validation object.\n    - Note that empty payloads are represented by a `null` value. If a validation schema is\n      provided and empty payload are allowed, the schema must be explicitly defined by setting the\n      rule to a **joi** schema with `null` allowed (e.g.\n      `Joi.object({ /* keys here */ }).allow(null)`).\n\n- a validation function using the signature `async function(value, options)` where:\n\n    - `value` - the [`request.payload`](#request.payload) object containing the request payload.\n    - `options` - [`options`](#route.options.validate.options).\n    - if a value is returned, the value is used as the new [`request.payload`](#request.payload)\n      value and the original value is stored in [`request.orig.payload`](#request.orig). Otherwise,\n      the payload is left unchanged. If an error is thrown, the error is handled according to\n      [`failAction`](#route.options.validate.failAction).\n\nNote that validating large payloads and modifying them will cause memory duplication of the payload\n(since the original is kept), as well as the significant performance cost of validating large\namounts of data.\n\n#### <a name=\"route.options.validate.query\" /> `route.options.validate.query`\n\nDefault value: `true` (no validation).\n\nValidation rules for incoming request URI query component (the key-value part of the URI between\n'?' and '#'). The query is parsed into its individual key-value pairs, decoded, and stored in\n[`request.query`](#request.query) prior to validation. Where:\n\n- `true` - any query parameter value allowed (no validation performed).\n\n- `false` - no query parameter value allowed.\n\n- a [**joi**](https://joi.dev/api) validation object.\n\n- a validation function using the signature `async function(value, options)` where:\n\n    - `value` - the [`request.query`](#request.query) object containing the request query\n      parameters.\n    - `options` - [`options`](#route.options.validate.options).\n    - if a value is returned, the value is used as the new [`request.query`](#request.query) value\n      and the original value is stored in [`request.orig.query`](#request.orig). Otherwise, the\n      query parameters are left unchanged. If an error is thrown, the error is handled according to\n      [`failAction`](#route.options.validate.failAction).\n\nNote that changes to the query parameters will not be reflected in [`request.url`](#request.url).\n\n#### <a name=\"route.options.validate.state\" /> `route.options.validate.state`\n\nDefault value: `true` (no validation).\n\nValidation rules for incoming cookies. The `cookie` header is parsed and decoded into the\n[`request.state`](#request.state) prior to validation. Where:\n\n- `true` - any cookie value allowed (no validation performed).\n\n- `false` - no cookies allowed.\n\n- a [**joi**](https://joi.dev/api) validation object.\n\n- a validation function using the signature `async function(value, options)` where:\n\n    - `value` - the [`request.state`](#request.state) object containing all parsed cookie values.\n    - `options` - [`options`](#route.options.validate.options).\n    - if a value is returned, the value is used as the new [`request.state`](#request.state) value\n      and the original value is stored in [`request.orig.state`](#request.orig). Otherwise, the\n      cookie values are left unchanged. If an error is thrown, the error is handled according to\n      [`failAction`](#route.options.validate.failAction).\n\n#### <a name=\"route.options.validate.validator\" /> `route.options.validate.validator`\n\nDefault value: `null` (no default validator).\n\nSets a server validation module used to compile raw validation rules into validation schemas (e.g. **joi**).\n\nNote: the validator is only used when validation rules are not pre-compiled schemas. When a validation rules is a function or schema object, the rule is used as-is and the validator is not used.\n\n## Request lifecycle\n\nEach incoming request passes through the request lifecycle. The specific steps vary based on the\nserver and route configurations, but the order in which the applicable steps are executed is always\nthe same. The following is the complete list of steps a request can go through:\n\n- _**onRequest**_\n    - always called when `onRequest` extensions exist.\n    - the request path and method can be modified via the [`request.setUrl()`](#request.setUrl()) and [`request.setMethod()`](#request.setMethod()) methods. Changes to the request path or method will impact how the request is routed and can be used for rewrite rules.\n    - [`request.payload`](#request.payload) is `undefined` and can be overridden with any non-`undefined` value to bypass payload processing.\n    - [`request.route`](#request.route) is unassigned.\n    - [`request.url`](#request.url) can be `null` if the incoming request path is invalid.\n    - [`request.path`](#request.path) can be an invalid path.\n\n- _**Route lookup**_\n    - lookup based on `request.path` and `request.method`.\n    - skips to _**onPreResponse**_ if no route is found or if the path violates the HTTP\n      specification.\n\n- _**Cookies processing**_\n    - based on the route [`state`](#route.options.state) option.\n    - error handling based on [`failAction`](#route.options.state.failAction).\n\n- _**onPreAuth**_\n    - called regardless if authentication is performed.\n\n- _**Authentication**_\n    - based on the route [`auth`](#route.options.auth) option.\n\n- _**Payload processing**_\n    - based on the route [`payload`](#route.options.payload) option and if [`request.payload`](#request.payload) has not been overridden in _**onRequest**_.\n    - error handling based on [`failAction`](#route.options.payload.failAction).\n\n- _**Payload authentication**_\n    - based on the route [`auth`](#route.options.auth) option.\n\n- _**onCredentials**_\n    - called only if authentication is performed.\n\n- _**Authorization**_\n    - based on the route authentication [`access`](#route.options.auth.access) option.\n\n- _**onPostAuth**_\n    - called regardless if authentication is performed.\n\n- _**Headers validation**_\n    - based on the route [`validate.headers`](#route.options.validate.headers) option.\n    - error handling based on [`failAction`](#route.options.validate.failAction).\n\n- _**Path parameters validation**_\n    - based on the route [`validate.params`](#route.options.validate.params) option.\n    - error handling based on [`failAction`](#route.options.validate.failAction).\n\n- _**Query validation**_\n    - based on the route [`validate.query`](#route.options.validate.query) option.\n    - error handling based on [`failAction`](#route.options.validate.failAction).\n\n- _**Payload validation**_\n    - based on the route [`validate.payload`](#route.options.validate.payload) option.\n    - error handling based on [`failAction`](#route.options.validate.failAction).\n\n- _**State validation**_\n    - based on the route [`validate.state`](#route.options.validate.state) option.\n    - error handling based on [`failAction`](#route.options.validate.failAction).\n\n- _**onPreHandler**_\n\n- _**Pre-handler methods**_\n    - based on the route [`pre`](#route.options.pre) option.\n    - error handling based on each pre-handler method's `failAction` setting.\n\n- _**Route handler**_\n    - executes the route [`handler`](#route.options.handler).\n\n- _**onPostHandler**_\n    - the response contained in [`request.response`](#request.response) may be modified (but not\n      assigned a new value). To return a different response type (for example, replace an error\n      with an HTML response), return a new response value.\n\n- _**Response validation**_\n    - error handling based on [`failAction`](#route.options.response.failAction).\n\n- _**onPreResponse**_\n    - always called, unless the request is aborted.\n    - the response contained in [`request.response`](#request.response) may be modified (but not\n      assigned a new value). To return a different response type (for example, replace an error\n      with an HTML response), return a new response value. Note that any errors generated will not\n      be passed back to _**onPreResponse**_ to prevent an infinite loop.\n\n- _**Response transmission**_\n    - may emit a [`'request'` event](#server.events.request) on the `'error'` channel.\n\n- _**Finalize request**_\n    - emits `'response'` event.\n\n- _**onPostResponse**_\n    - return value is ignored since the response is already set.\n    - emits a [`'request'` event](#server.events.request) on the `'error'` channel if an error is returned.\n    - all extension handlers are executed even if some error.\n    - note that since the handlers are executed in serial (each is `await`ed), care must be taken to avoid blocking execution if other extension handlers expect to be called immediately when the response is sent. If an _**onPostResponse**_ handler is performing IO, it should defer that activity to another tick and return immediately (either without a return value or without a promise that is solve to resolve).\n\n### Lifecycle methods\n\nLifecycle methods are the interface between the framework and the application. Many of the request\nlifecycle steps: [extensions](#server.ext()), [authentication](#authentication-scheme),\n[handlers](#route.options.handler), [pre-handler methods](#route.options.pre), and\n[`failAction` function values](#lifecycle-failAction) are lifecyle methods provided by the\ndeveloper and executed by the framework.\n\nEach lifecycle method is a function with the signature `await function(request, h, [err])` where:\n- `request` - the [request object](#request).\n- `h` - the [response toolkit](#response-toolkit) the handler must call to set a response and\n  return control back to the framework.\n- `err` - an error object available only when the method is used as a\n  [`failAction` value](#lifecycle-failAction).\n\nEach lifecycle method must return a value or a promise that resolves into a value. If a lifecycle\nmethod returns without a value or resolves to an `undefined` value, an Internal Server Error (500)\nerror response is sent.\n\nThe return value must be one of:\n- Plain value:\n    - `null`\n    - string\n    - number\n    - boolean\n- `Buffer` object\n- `Error` object\n    - plain `Error`.\n    - a [`Boom`](https://hapi.dev/family/boom/api) object.\n- `Stream` object\n    - must be compatible with the \"streams2\" API and not be in `objectMode`.\n    - if the stream object has a `statusCode` property, that status code will be used as\n      the default response code based on the [`passThrough`](#response.settings.passThrough)\n      option.\n    - if the stream object has a `headers` property, the headers will be included in the response\n      based on the [`passThrough`](#response.settings.passThrough) option.\n    - if the stream object has a function property `setCompressor(compressor)` and the response\n      passes through a compressor, a reference to the compressor stream will be passed to the\n      response stream via this method.\n- any object or array\n    - must not include circular references.\n- a toolkit signal:\n    - [`h.abandon`](#h.abandon) - abort processing the request.\n    - [`h.close`](#h.close) - abort processing the request and call `end()` to ensure the response\n      is closed.\n    - [`h.continue`](#h.continue) - continue processing the request lifecycle without changing the\n      response.\n- a toolkit method response:\n    - [`h.response()`](#h.response()) - wraps a plain response in a [response object](#response-object).\n    - [`h.redirect()`](#h.redirect()) - wraps a plain response with a redirection directive.\n    - [`h.authenticated()`](#h.authenticated()) - indicate request authenticated successfully\n      (auth scheme only).\n    - [`h.unauthenticated()`](#h.unauthenticated()) - indicate request failed to authenticate\n      (auth scheme only).\n- a promise object that resolve to any of the above values\n\nAny error thrown by a lifecycle method will be used as the [response object](#response-object). While errors and valid\nvalues can be returned, it is recommended to throw errors. Throwing non-error values will generate\na Bad Implementation (500) error response.\n\n```js\nconst handler = function (request, h) {\n\n    if (request.query.forbidden) {\n        throw Boom.badRequest();\n    }\n\n    return 'success';\n};\n```\n\nIf the route has a [`bind`](#route.options.bind) option or [`server.bind()`](#server.bind()) was\ncalled, the lifecycle method will be bound to the provided context via `this` as well as accessible\nvia [`h.context`](#h.context).\n\n#### Lifecycle workflow\n\nThe flow between each lifecycle step depends on the value returned by each lifecycle method as\nfollows:\n\n- an error:\n    - the lifecycle skips to the _**Response validation**_ step.\n    - if returned by the _**onRequest**_ step it skips to the _**onPreResponse**_ step.\n    - if returned by the _**Response validation**_ step it skips to the _**onPreResponse**_ step.\n    - if returned by the _**onPreResponse**_ step it skips to the _**Response transmission**_ step.\n\n- an abort signal ([`h.abandon`](#h.abandon) or [`h.close`](#h.close)):\n    - skips to the _**Finalize request**_ step.\n\n- a [`h.continue`](#h.continue) signal:\n    - continues processing the request lifecycle without changing the request response.\n    - cannot be used by the [`authenticate()`](#authentication-scheme) scheme method.\n\n- a [takeover response](#takeover-response):\n    - overrides the request response with the provided value and skips to the\n      _**Response validation**_ step.\n    - if returned by the _**Response validation**_ step it skips to the _**onPreResponse**_ step.\n    - if returned by the _**onPreResponse**_ step it skips to the _**Response transmission**_ step.\n\n- any other response:\n    - overrides the request response with the provided value and continues processing the request\n      lifecycle.\n    - cannot be returned from any step prior to the _**Pre-handler methods**_ step.\n\nThe [`authenticate()`](#authentication-scheme) method has access to two additional return values:\n    - [`h.authenticated()`](#h.authenticated()) - indicate request authenticated successfully.\n    - [`h.unauthenticated()`](#h.unauthenticated()) - indicate request failed to authenticate.\n\nNote that these rules apply somewhat differently when used in a [pre-handler method](#route.options.pre).\n\n#### Takeover response\n\nA takeover response is a [`response object`](#response-object) on which [`response.takeover()`](#response.takever())\nwas called to signal that the [lifecycle method](#lifecycle-methods) return value should be set as\nthe response and skip to immediately validate and trasmit the value, bypassing other lifecycle\nsteps.\n\n#### <a name=\"lifecycle-failAction\" /> `failAction` configuration\n\nVarious configuration options allows defining how errors are handled. For example, when invalid\npayload is received or malformed cookie, instead of returning an error, the framework can be\nconfigured to perform another action. When supported the `failAction` option supports the following\nvalues:\n\n- `'error'` - return the error object as the response.\n- `'log'` - report the error but continue processing the request.\n- `'ignore'` - take no action and continue processing the request.\n\n- a [lifecycle method](#lifecycle-methods) with the signature `async function(request, h, err)`\n  where:\n    - `request` - the [request object](#request).\n    - `h` - the [response toolkit](#response-toolkit).\n    - `err` - the error object.\n\n#### Errors\n\n**hapi** uses the [**boom**](https://hapi.dev/family/boom/api) error library for all its internal\nerror generation. **boom** provides an expressive interface to return HTTP errors. Any error\nthrown by a [lifecycle method](#lifecycle-methods) is converted into a **boom** object and defaults to status\ncode `500` if the error is not already a **boom** object.\n\nWhen the error is sent back to the client, the response contains a JSON object with the\n`statusCode`, `error`, and `message` keys.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst Boom = require('@hapi/boom');\n\nconst server = Hapi.server();\n\nserver.route({\n    method: 'GET',\n    path: '/badRequest',\n    handler: function (request, h) {\n\n        throw Boom.badRequest('Unsupported parameter');     // 400\n    }\n});\n\nserver.route({\n    method: 'GET',\n    path: '/internal',\n    handler: function (request, h) {\n\n        throw new Error('unexpect error');                  // 500\n    }\n});\n```\n\n##### Error transformation\n\nErrors can be customized by changing their `output` content. The **boom** error object includes the\nfollowing properties:\n\n- `isBoom` - if `true`, indicates this is a `Boom` object instance.\n\n- `message` - the error message.\n\n- `output` - the formatted response. Can be directly manipulated after object construction to\n  return a custom error response. Allowed root keys:\n\n    - `statusCode` - the HTTP status code (typically 4xx or 5xx).\n\n    - `headers` - an object containing any HTTP headers where each key is a header name and value\n      is the header content.\n\n    - `payload` - the formatted object used as the response payload. Can be directly\n      manipulated but any changes will be lost\n      if `reformat()` is called. Any content allowed and by default includes the following content:\n\n        - `statusCode` - the HTTP status code, derived from `error.output.statusCode`.\n\n        - `error` - the HTTP status message (e.g. 'Bad Request', 'Internal Server Error') derived\n          from `statusCode`.\n\n        - `message` - the error message derived from `error.message`.\n\n- inherited `Error` properties.\n\nIt also supports the following method:\n\n- `reformat()` - rebuilds `error.output` using the other object properties.\n\n```js\nconst Boom = require('@hapi/boom');\n\nconst handler = function (request, h) {\n\n    const error = Boom.badRequest('Cannot feed after midnight');\n    error.output.statusCode = 499;    // Assign a custom error code\n    error.reformat();\n    error.output.payload.custom = 'abc_123'; // Add custom key\n    throw error;\n});\n```\n\nWhen a different error representation is desired, such as an HTML page or a different payload\nformat, the `'onPreResponse'` extension point may be used to identify errors and replace them with\na different [response object](#response-object), as in this example using [Vision's](https://hapi.dev/family/vision/api)\n`.view()` [response toolkit](#response-toolkit) property.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst Vision = require('@hapi/vision');\n\nconst server = Hapi.server({ port: 80 });\nserver.register(Vision, (err) => {\n    server.views({\n        engines: {\n            html: require('handlebars')\n        }\n    });\n});\n\nconst preResponse = function (request, h) {\n\n    const response = request.response;\n    if (!response.isBoom) {\n        return h.continue;\n    }\n\n    // Replace error with friendly HTML\n\n      const error = response;\n      const ctx = {\n          message: (error.output.statusCode === 404 ? 'page not found' : 'something went wrong')\n      };\n\n      return h.view('error', ctx).code(error.output.statusCode);\n};\n\nserver.ext('onPreResponse', preResponse);\n```\n\n### Response Toolkit\n\nAccess: read only.\n\nThe response toolkit is a collection of properties and utilities passed to every\n[lifecycle method](#lifecycle-methods). It is somewhat hard to define as it provides both\nutilities for manipulating responses as well as other information. Since the toolkit is passed\nas a function argument, developers can name it whatever they want. For the purpose of this document\nthe `h` notation is used. It is named in the spirit of the RethinkDB `r` method, with `h` for\n**h**api.\n\n#### Toolkit properties\n\n##### <a name=\"h.abandon\" /> `h.abandon`\n\nAccess: read only.\n\nA response symbol. When returned by a lifecycle method, the request lifecycle skips to the\nfinalizing step without further interaction with the node response stream. It is the developer's\nresponsibility to write and end the response directly via [`request.raw.res`](#request.raw).\n\n##### <a name=\"h.close\" /> `h.close`\n\nAccess: read only.\n\nA response symbol. When returned by a lifecycle method, the request lifecycle skips to the\nfinalizing step after calling `request.raw.res.end())` to close the node response stream.\n\n##### <a name=\"h.context\" /> `h.context`\n\nAccess: read / write (will impact the shared context if the object is modified).\n\nA response symbol. Provides access to the route or server context set via the route\n[`bind`](#route.options.bind) option or [`server.bind()`](#server.bind()).\n\n##### <a name=\"h.continue\" /> `h.continue`\n\nAccess: read only.\n\nA response symbol. When returned by a lifecycle method, the request lifecycle continues without\nchanging the response.\n\n##### <a name=\"h.realm\" /> `h.realm`\n\nAccess: read only.\n\nThe [server realm](#server.realm) associated with the matching route. Defaults to the root server\nrealm in the _**onRequest**_ step.\n\n##### <a name=\"h.request\" /> `h.request`\n\nAccess: read only and public request interface.\n\nThe [request] object. This is a duplication of the `request` lifecycle method argument used by\n[toolkit decorations](#server.decorate()) to access the current request.\n\n#### <a name=\"h.authenticated()\" /> `h.authenticated(data)`\n\nUsed by the [authentication] method to pass back valid credentials where:\n\n- `data` - an object with:\n\n    - `credentials` - (required) object representing the authenticated entity.\n    - `artifacts` - (optional) authentication artifacts object specific to the authentication\n      scheme.\n\nReturn value: an internal authentication object.\n\n#### <a name=\"h.entity()\" /> `h.entity(options)`\n\nSets the response 'ETag' and 'Last-Modified' headers and checks for any conditional request headers\nto decide if the response is going to qualify for an HTTP 304 (Not Modified). If the entity values\nmatch the request conditions, `h.entity()` returns a [response object](#response-object) for the lifecycle method to\nreturn as its value which will set a 304 response. Otherwise, it sets the provided entity headers\nand returns `undefined`. The method arguments are:\n\n- `options` - a required configuration object with:\n    - `etag` - the ETag string. Required if `modified` is not present. Defaults to no header.\n    - `modified` - the Last-Modified header value. Required if `etag` is not present. Defaults to\n      no header.\n    - `vary` - same as the [`response.etag()`](#response.etag()) option. Defaults to `true`.\n\nReturn value:\n    - a [response object](#response-object) if the response is unmodified.\n    - `undefined` if the response has changed.\n\nIf `undefined` is returned, the developer must return a valid lifecycle method value. If a response\nis returned, it should be used as the return value (but may be customize using the response\nmethods).\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nserver.route({\n    method: 'GET',\n    path: '/',\n    options: {\n        cache: { expiresIn: 5000 },\n        handler: function (request, h) {\n\n            const response = h.entity({ etag: 'abc' });\n            if (response) {\n                response.header('X', 'y');\n                return response;\n            }\n\n            return 'ok';\n        }\n    }\n});\n```\n\n#### <a name=\"h.redirect()\" /> `h.redirect(uri)`\n\nRedirects the client to the specified uri. Same as calling `h.response().redirect(uri)`.\n\nReturns a [response object](#response-object).\n\n```js\nconst handler = function (request, h) {\n\n    return h.redirect('http://example.com');\n};\n```\n\n#### <a name=\"h.response()\" /> `h.response([value])`\n\nWraps the provided value and returns a [`response`](#response-object) object which allows\ncustomizing the response (e.g. setting the HTTP status code, custom headers, etc.), where:\n\n- `value` - (optional) return value. Defaults to `null`.\n\nReturns a [response object](#response-object).\n\n```js\n// Detailed notation\n\nconst handler = function (request, h) {\n\n    const response = h.response('success');\n    response.type('text/plain');\n    response.header('X-Custom', 'some-value');\n    return response;\n};\n\n// Chained notation\n\nconst handler = function (request, h) {\n\n    return h.response('success')\n        .type('text/plain')\n        .header('X-Custom', 'some-value');\n};\n```\n\n#### <a name=\"h.state()\" /> `h.state(name, value, [options])`\n\nSets a response cookie using the same arguments as [`response.state()`](#response.state()).\n\nReturn value: none.\n\n```js\nconst ext = function (request, h) {\n\n    h.state('cookie-name', 'value');\n    return h.continue;\n};\n```\n\n#### <a name=\"h.unauthenticated()\" /> `h.unauthenticated(error, [data])`\n\nUsed by the [authentication] method to indicate authentication failed and pass back the credentials\nreceived where:\n- `error` - (required) the authentication error.\n- `data` - (optional) an object with:\n    - `credentials` - (required) object representing the authenticated entity.\n    - `artifacts` - (optional) authentication artifacts object specific to the authentication\n      scheme.\n\nThe method is used to pass both the authentication error and the credentials. For example, if a\nrequest included expired credentials, it allows the method to pass back the user information\n(combined with a `'try'` authentication [`mode`](#route.options.auth.mode)) for error customization.\n\nThere is no difference between throwing the error or passing it with the `h.unauthenticated()`\nmethod if no credentials are passed, but it might still be helpful for code clarity.\n\n#### <a name=\"h.unstate()\" /> `h.unstate(name, [options])`\n\nClears a response cookie using the same arguments as [`response.unstate()`](#response.unstate()).\n\n```js\nconst ext = function (request, h) {\n\n    h.unstate('cookie-name');\n    return h.continue;\n};\n```\n\n### Response object\n\nThe response object contains the request response value along with various HTTP headers and flags.\nWhen a [lifecycle method](#lifecycle-methods) returns a value, the value is wrapped in a response\nobject along with some default flags (e.g. `200` status code). In order to customize a response\nbefore it is returned, the [`h.response()`](#h.response()) method is provided.\n\n#### Response properties\n\n##### <a name=\"response.app\" /> `response.app`\n\nAccess: read / write.\n\nDefault value: `{}`.\n\nApplication-specific state. Provides a safe place to store application data without potential\nconflicts with the framework. Should not be used by [plugins](#plugins) which should use\n[`plugins[name]`](#response.plugins).\n\n##### <a name=\"response.contentType\" /> `response.contentType`\n\nAccess: read.\n\nDefault value: none.\n\nProvides a preview of the response HTTP Content-Type header based on the implicit response type, any explicit Content-Type header set, and any content character-set defined. The returned value is only a preview as the content type can change later both internally and by user code (it represents current response state). The value is `null` if no implicit type can be determined.\n\n##### <a name=\"response.events\" /> `response.events`\n\nAccess: read only and the public **podium** interface.\n\nThe `response.events` object supports the following events:\n\n- `'peek'` - emitted for each chunk of data written back to the client connection. The event method\n  signature is `function(chunk, encoding)`.\n\n- `'finish'` - emitted when the response finished writing but before the client response connection\n  is ended. The event method signature is `function ()`.\n\n```js\nconst Crypto = require('crypto');\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst preResponse = function (request, h) {\n\n    const response = request.response;\n    if (response.isBoom) {\n        return null;\n    }\n\n    const hash = Crypto.createHash('sha1');\n    response.events.on('peek', (chunk) => {\n\n        hash.update(chunk);\n    });\n\n    response.events.once('finish', () => {\n\n        console.log(hash.digest('hex'));\n    });\n\n    return h.continue;\n};\n\nserver.ext('onPreResponse', preResponse);\n```\n\n##### <a name=\"response.headers\" /> `response.headers`\n\nAccess: read only.\n\nDefault value: `{}`.\n\nAn object containing the response headers where each key is a header field name and the value is\nthe string header value or array of string.\n\nNote that this is an incomplete list of headers to be included with the response. Additional\nheaders will be added once the response is prepared for transmission.\n\n##### <a name=\"response.plugins\" /> `response.plugins`\n\nAccess: read / write.\n\nDefault value: `{}`.\n\nPlugin-specific state. Provides a place to store and pass request-level plugin data. `plugins` is\nan object where each key is a plugin name and the value is the state.\n\n##### <a name=\"response.settings\" /> `response.settings`\n\nAccess: read only.\n\nObject containing the response handling flags.\n\n###### <a name=\"response.settings.passThrough\" /> `response.settings.passThrough`\n\nAccess: read only.\n\nDefaults value: `true`.\n\nIf `true` and [`source`](#response.source) is a `Stream`, copies the `statusCode` and `headers`\nproperties of the stream object to the outbound response.\n\n###### <a name=\"response.settings.stringify\" /> `response.settings.stringify`\n\nAccess: read only.\n\nDefault value: `null` (use route defaults).\n\nOverride the route [`json`](#route.options.json) options used when [`source`](#response.source)\nvalue requires stringification.\n\n###### <a name=\"response.settings.ttl\" /> `response.settings.ttl`\n\nAccess: read only.\n\nDefault value: `null` (use route defaults).\n\nIf set, overrides the route [`cache`](#route.options.cache) with an expiration value in\nmilliseconds.\n\n###### <a name=\"response.settings.varyEtag\" /> `response.settings.varyEtag`\n\nDefault value: `false`.\n\nIf `true`, a suffix will be automatically added to the 'ETag' header at transmission time\n(separated by a `'-'` character) when the HTTP 'Vary' header is present.\n\n##### <a name=\"response.source\" /> `response.source`\n\nAccess: read only.\n\nThe raw value returned by the [lifecycle method](#lifecycle-methods).\n\n##### <a name=\"response.statusCode\" /> `response.statusCode`\n\nAccess: read only.\n\nDefault value: `200`.\n\nThe HTTP response status code.\n\n##### <a name=\"response.variety\" /> `response.variety`\n\nAccess: read only.\n\nA string indicating the type of [`source`](#response.source) with available values:\n\n- `'plain'` - a plain response such as string, number, `null`, or simple object.\n- `'buffer'` - a `Buffer`.\n- `'stream'` - a `Stream`.\n\n#### <a name=\"response.bytes()\" /> `response.bytes(length)`\n\nSets the HTTP 'Content-Length' header (to avoid chunked transfer encoding) where:\n\n- `length` - the header value. Must match the actual payload size.\n\nReturn value: the current response object.\n\n#### <a name=\"response.charset()\" /> `response.charset(charset)`\n\nSets the 'Content-Type' HTTP header 'charset' property where:\n\n- `charset` - the charset property value. When `charset` value is falsy, it will prevent hapi from using its default charset setting.\n\nReturn value: the current response object.\n\n#### <a name=\"response.code()\" /> `response.code(statusCode)`\n\nSets the HTTP status code where:\n\n- `statusCode` - the HTTP status code (e.g. 200).\n\nReturn value: the current response object.\n\n#### <a name=\"response.message()\" /> `response.message(httpMessage)`\n\nSets the HTTP status message where:\n\n- `httpMessage` - the HTTP status message (e.g. 'Ok' for status code 200).\n\nReturn value: the current response object.\n\n#### <a name=\"response.compressed()\" /> `response.compressed(encoding)`\n\nSets the HTTP 'content-encoding' header where:\n\n- `encoding` - the header value string.\n\nReturn value: the current response object.\n\nNote that setting content encoding via this method does not set a 'vary' HTTP header with 'accept-encoding' value. To vary the response, use the `response.header()` method instead.\n\n#### <a name=\"response.created()\" /> `response.created(uri)`\n\nSets the HTTP status code to Created (201) and the HTTP 'Location' header where:\n\n- `uri` - an absolute or relative URI used as the 'Location' header value.\n\nReturn value: the current response object.\n\n#### <a name=\"response.encoding()\" /> `response.encoding(encoding)`\n\nSets the string encoding scheme used to serial data into the HTTP payload where:\n- `encoding` - the encoding property value (see [node Buffer encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings)).\n\nReturn value: the current response object.\n\n#### <a name=\"response.etag()\" /> `response.etag(tag, options)`\n\nSets the representation [entity tag](https://tools.ietf.org/html/rfc7232#section-2.3) where:\n\n- `tag` - the entity tag string without the double-quote.\n\n- `options` - (optional) settings where:\n\n    - `weak` - if `true`, the tag will be prefixed with the `'W/'` weak signifier. Weak tags will\n      fail to match identical tags for the purpose of determining 304 response status. Defaults to\n      `false`.\n\n    - `vary` - if `true` and content encoding is set or applied to the response (e.g 'gzip' or\n      'deflate'), the encoding name will be automatically added to the tag at transmission time\n      (separated by a `'-'` character). Ignored when `weak` is `true`. Defaults to `true`.\n\nReturn value: the current response object.\n\n#### <a name=\"response.header()\" /> `response.header(name, value, options)`\n\nSets an HTTP header where:\n\n- `name` - the header name.\n\n- `value` - the header value.\n\n- `options` - (optional) object where:\n\n    - `append` - if `true`, the value is appended to any existing header value using `separator`.\n      Defaults to `false`.\n\n    - `separator` - string used as separator when appending to an existing value. Defaults to `','`.\n\n    - `override` - if `false`, the header value is not set if an existing value present. Defaults\n      to `true`.\n\n    - `duplicate` - if `false`, the header value is not modified if the provided value is already\n      included. Does not apply when `append` is `false` or if the `name` is `'set-cookie'`.\n      Defaults to `true`.\n\nReturn value: the current response object.\n\n#### <a name=\"response.location()\" /> `response.location(uri)`\n\nSets the HTTP 'Location' header where:\n\n- `uri` - an absolute or relative URI used as the 'Location' header value.\n\nReturn value: the current response object.\n\n#### <a name=\"response.redirect()\" /> `response.redirect(uri)`\n\nSets an HTTP redirection response (302) and decorates the response with additional methods, where:\n\n- `uri` - an absolute or relative URI used to redirect the client to another resource.\n\nReturn value: the current response object.\n\nDecorates the response object with the [`response.temporary()`](#response.temporary()),\n[`response.permanent()`](#response.permanent()), and [`response.rewritable()`](#response.rewritable())\nmethods to easily change the default redirection code (302).\n\n|                |  Permanent | Temporary |\n| -------------- | ---------- | --------- |\n| Rewritable     | 301        | 302       |\n| Non-rewritable | 308        | 307       |\n\n#### <a name=\"response.replacer()\" /> `response.replacer(method)`\n\nSets the `JSON.stringify()` `replacer` argument where:\n\n- `method` - the replacer function or array. Defaults to none.\n\nReturn value: the current response object.\n\n#### <a name=\"response.spaces()\" /> `response.spaces(count)`\n\nSets the `JSON.stringify()` `space` argument where:\n\n- `count` - the number of spaces to indent nested object keys. Defaults to no indentation.\n\nReturn value: the current response object.\n\n#### <a name=\"response.state()\" /> `response.state(name, value, [options])`\n\nSets an HTTP cookie where:\n\n- `name` - the cookie name.\n\n- `value` - the cookie value. If no `options.encoding` is defined, must be a string. See\n  [`server.state()`](#server.state()) for supported `encoding` values.\n\n- `options` - (optional) configuration. If the state was previously registered with the server\n  using [`server.state()`](#server.state()), the specified keys in `options` are merged with the\n  default server definition.\n\nReturn value: the current response object.\n\n#### <a name=\"response.suffix()\" /> `response.suffix(suffix)`\n\nSets a string suffix when the response is process via `JSON.stringify()` where:\n\n- `suffix` - the string suffix.\n\nReturn value: the current response object.\n\n#### <a name=\"response.ttl()\" /> `response.ttl(msec)`\n\nOverrides the default route cache expiration rule for this response instance where:\n\n- `msec` - the time-to-live value in milliseconds.\n\nReturn value: the current response object.\n\n#### <a name=\"response.type()\" /> `response.type(mimeType)`\n\nSets the HTTP 'Content-Type' header where:\n\n- `mimeType` - is the mime type.\n\nReturn value: the current response object.\n\nShould only be used to override the built-in default for each response type.\n\n#### <a name=\"response.unstate()\" /> `response.unstate(name, [options])`\n\nClears the HTTP cookie by setting an expired value where:\n- `name` - the cookie name.\n- `options` - (optional) configuration for expiring cookie. If the state was previously registered\n  with the server using [`server.state()`](#serverstatename-options), the specified `options` are\n  merged with the server definition.\n\nReturn value: the current response object.\n\n#### <a name=\"response.vary()\" /> `response.vary(header)`\n\nAdds the provided header to the list of inputs affected the response generation via the HTTP 'Vary'\nheader where:\n\n- `header` - the HTTP request header name.\n\nReturn value: the current response object.\n\n#### <a name=\"response.takeover()\" /> `response.takeover()`\n\nMarks the response object as a [takeover response](#takeover-response).\n\nReturn value: the current response object.\n\n#### <a name=\"response.temporary()\" /> `response.temporary(isTemporary)`\n\nSets the status code to `302` or `307` (based on the [`response.rewritable()`](#response.rewriteable())\nsetting) where:\n\n- `isTemporary` - if `false`, sets status to permanent. Defaults to `true`.\n\nReturn value: the current response object.\n\nOnly available after calling the [`response.redirect()`](#response.redirect()) method.\n\n#### <a name=\"response.permanent()\" /> `response.permanent(isPermanent)`\n\nSets the status code to `301` or `308` (based on the [`response.rewritable()`](#response.rewritable())\nsetting) where:\n\n- `isPermanent` - if `false`, sets status to temporary. Defaults to `true`.\n\nReturn value: the current response object.\n\nOnly available after calling the [`response.redirect()`](#response.redirect()) method.\n\n#### <a name=\"response.rewritable()\" /> `response.rewritable(isRewritable)`\n\nSets the status code to `301`/`302` for rewritable (allows changing the request method from 'POST'\nto 'GET') or `307`/`308` for non-rewritable (does not allow changing the request method from 'POST'\nto 'GET'). Exact code based on the [`response.temporary()`](#response.temporary()) or\n[`response.permanent()`](#response.permanent()) setting. Arguments:\n\n- `isRewritable` - if `false`, sets to non-rewritable. Defaults to `true`.\n\nReturn value: the current response object.\n\nOnly available after calling the [`response.redirect()`](#response.redirect()) method.\n\n## Request\n\nThe request object is created internally for each incoming request. It is not the same object\nreceived from the node HTTP server callback (which is available via [`request.raw.req`](#request.raw)).\nThe request properties change throughout the [request lifecycle](#request-lifecycle).\n\n### Request properties\n\n#### <a name=\"request.app\" /> `request.app`\n\nAccess: read / write.\n\nApplication-specific state. Provides a safe place to store application data without potential\nconflicts with the framework. Should not be used by [plugins](#plugins) which should use\n`plugins[name]`.\n\n#### <a name=\"request.auth\" /> `request.auth`\n\nAccess: read only.\n\nAuthentication information:\n\n- `artifacts` - an artifact object received from the authentication strategy and used in\n  authentication-related actions.\n\n- `credentials` - the `credential` object received during the authentication process. The\n  presence of an object does not mean successful authentication.\n\n- `error` - the authentication error if failed and mode set to `'try'`.\n\n- `isAuthenticated` - `true` if the request has been successfully authenticated, otherwise `false`.\n\n- `isAuthorized` - `true` is the request has been successfully authorized against the route\n  authentication [`access`](#route.options.auth.access) configuration. If the route has not\n  access rules defined or if the request failed authorization, set to `false`.\n\n- `isInjected` - `true` if the request has been authenticated via the\n  [`server.inject()`](#server.inject()) `auth` option, otherwise `undefined`.\n\n- `mode` - the route authentication mode.\n\n- `strategy` - the name of the strategy used.\n\n#### <a name=\"request.events\" /> `request.events`\n\nAccess: read only and the public **podium** interface.\n\nThe `request.events` supports the following events:\n\n- `'peek'` - emitted for each chunk of payload data read from the client connection. The event\n  method signature is `function(chunk, encoding)`.\n\n- `'finish'` - emitted when the request payload finished reading. The event method signature is\n  `function ()`.\n\n- `'disconnect'` - emitted when a request errors or aborts unexpectedly.\n\n```js\nconst Crypto = require('crypto');\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst onRequest = function (request, h) {\n\n    const hash = Crypto.createHash('sha1');\n    request.events.on('peek', (chunk) => {\n\n        hash.update(chunk);\n    });\n\n    request.events.once('finish', () => {\n\n        console.log(hash.digest('hex'));\n    });\n\n    request.events.once('disconnect', () => {\n\n        console.error('request aborted');\n    });\n\n    return h.continue;\n};\n\nserver.ext('onRequest', onRequest);\n```\n\n#### <a name=\"request.headers\" /> `request.headers`\n\nAccess: read only.\n\nThe raw request headers (references `request.raw.req.headers`).\n\n#### <a name=\"request.info\" /> `request.info`\n\nAccess: read only.\n\nRequest information:\n\n- `acceptEncoding` - the request preferred encoding.\n\n- `completed` - request processing completion timestamp (`0` is still processing).\n\n- `cors` - request CORS information (available only after the `'onRequest'` extension point as CORS\n  is configured per-route and no routing decisions are made at that point in the request\n  lifecycle), where:\n    - `isOriginMatch` - `true` if the request 'Origin' header matches the configured CORS\n      restrictions. Set to `false` if no 'Origin' header is found or if it does not match.\n\n- `host` - content of the HTTP 'Host' header (e.g. 'example.com:8080').\n\n- `hostname` - the hostname part of the 'Host' header (e.g. 'example.com').\n\n- `id` - a unique request identifier (using the format '{now}:{server.info.id}:{5 digits counter}').\n\n- `received` - request reception timestamp.\n\n- `referrer` - content of the HTTP 'Referrer' (or 'Referer') header.\n\n- `remoteAddress` - remote client IP address.\n\n- `remotePort` - remote client port.\n\n- `responded` - request response timestamp (`0` is not responded yet or response failed when `completed` is set).\n\nNote that the `request.info` object is not meant to be modified.\n\n#### <a name=\"request.isInjected\" /> `request.isInjected`\n\nAccess: read only.\n\n`true` if the request was created via [`server.inject()`](#server.inject()), and `false` otherwise.\n\n#### <a name=\"request.logs\" /> `request.logs`\n\nAccess: read only.\n\nAn array containing the logged request events.\n\nNote that this array will be empty if route [`log.collect`](#route.options.log) is set to `false`.\n\n#### <a name=\"request.method\" /> `request.method`\n\nAccess: read only.\n\nThe request method in lower case (e.g. `'get'`, `'post'`).\n\n#### <a name=\"request.mime\" /> `request.mime`\n\nAccess: read only.\n\nThe parsed content-type header. Only available when payload parsing enabled and no  payload error occurred.\n\n#### <a name=\"request.orig\" /> `request.orig`\n\nAccess: read only.\n\nAn object containing the values of `params`, `query`, `payload` and `state` before any validation modifications made. Only set when input validation is performed.\n\n#### <a name=\"request.params\" /> `request.params`\n\nAccess: read only.\n\nAn object where each key is a path parameter name with matching value as described in [Path parameters](#path-parameters).\n\n#### <a name=\"request.paramsArray\" /> `request.paramsArray`\n\nAccess: read only.\n\nAn array containing all the path `params` values in the order they appeared in the path.\n\n#### <a name=\"request.path\" /> `request.path`\n\nAccess: read only.\n\nThe request URI's [pathname](https://nodejs.org/api/url.html#url_urlobject_pathname) component.\n\n#### <a name=\"request.payload\" /> `request.payload`\n\nAccess: read only / write in `'onRequest'` extension method.\n\nThe request payload based on the route `payload.output` and `payload.parse` settings. Set to `undefined` in `'onRequest'` extension methods and can be overridden to any non-`undefined` value to bypass payload processing.\n\n#### <a name=\"request.plugins\" /> `request.plugins`\n\nAccess: read / write.\n\nPlugin-specific state. Provides a place to store and pass request-level plugin data. The `plugins` is an object where each key is a plugin name and the value is the state.\n\n#### <a name=\"request.pre\" /> `request.pre`\n\nAccess: read only.\n\nAn object where each key is the name assigned by a [route pre-handler methods](#route.options.pre) function. The values are the raw values provided to the continuation function as argument. For the wrapped response object, use `responses`.\n\n#### <a name=\"request.response\" /> `request.response`\n\nAccess: read / write (see limitations below).\n\nThe response object when set. The object can be modified but must not be assigned another object. To replace the response with another from within an [extension point](#server.ext()), return a new response value. Contains an error when a request terminates prematurely when the client disconnects.\n\n#### <a name=\"request.preResponses\" /> `request.preResponses`\n\nAccess: read only.\n\nSame as `pre` but represented as the response object created by the pre method.\n\n#### <a name=\"request.query\" /> `request.query`\n\nAccess: read only.\n\nAn object where each key is a query parameter name and each matching value is the parameter value or an array of values if a parameter repeats. Can be modified indirectly via [request.setUrl](#request.setUrl()).\n\n#### <a name=\"request.raw\" /> `request.raw`\n\nAccess: read only.\n\nAn object containing the Node HTTP server objects. **Direct interaction with these raw objects is not recommended.**\n- `req` - the node request object.\n- `res` - the node response object.\n\n#### <a name=\"request.route\" /> `request.route`\n\nAccess: read only.\n\nThe request route information object, where:\n- `method` - the route HTTP method.\n- `path` - the route path.\n- `vhost` - the route vhost option if configured.\n- `realm` - the [active realm](#server.realm) associated with the route.\n- `settings` - the [route options](#route-options) object with all defaults applied.\n- `fingerprint` - the route internal normalized string representing the normalized path.\n\n#### <a name=\"request.server\" /> `request.server`\n\nAccess: read only and the public server interface.\n\nThe server object.\n\n#### <a name=\"request.state\" /> `request.state`\n\nAccess: read only.\n\nAn object containing parsed HTTP state information (cookies) where each key is the cookie name and value is the matching cookie content after processing using any registered cookie definition.\n\n#### <a name=\"request.url\" /> `request.url`\n\nAccess: read only.\n\nThe parsed request URI.\n\n### <a name=\"request.generateResponse()\" /> `request.generateResponse(source, [options])`\n\nReturns a [`response`](#response-object) which you can pass to [h.response()](#h.response()) where:\n- `source` - the value to set as the source of [h.response()](#h.response()), optional.\n- `options` - optional object with the following optional properties:\n    - `variety` - a sting name of the response type (e.g. `'file'`).\n    - `prepare` - a function with the signature `async function(response)` used to prepare the response after it is returned by a [lifecycle method](#lifecycle-methods) such as setting a file descriptor, where:\n        - `response` - the response object being prepared.\n        - must return the prepared response object (`response`).\n        - may throw an error which is used as the prepared response.\n    - `marshal` - a function with the signature `async function(response)` used to prepare the response for transmission to the client before it is sent, where:\n        - `response` - the response object being marshaled.\n        - must return the prepared value (not as response object) which can be any value accepted by the [`h.response()`](#h.response()) `value` argument.\n        - may throw an error which is used as the marshaled value.\n    - `close` - a function with the signature `function(response)` used to close the resources opened by the response object (e.g. file handlers), where:\n        - `response` - the response object being marshaled.\n        - should not throw errors (which are logged but otherwise ignored).\n\n### <a name=\"request.active()\" /> `request.active()`\n\nReturns `true` when the request is active and processing should continue and `false` when the request terminated early or completed its lifecycle. Useful when request processing is a resource-intensive operation and should be terminated early if the request is no longer active (e.g. client disconnected or aborted early).\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nserver.route({\n    method: 'POST',\n    path: '/worker',\n    handler: function (request, h) {\n\n        // Do some work...\n\n        // Check if request is still active\n        if (!request.active()) {\n            return h.close;\n        }\n\n        // Do some more work...\n\n        return null;\n    }\n});\n```\n\n### <a name=\"request.log()\" /> `request.log(tags, [data])`\n\nLogs request-specific events. When called, the server emits a [`'request'` event](#server.events.request)\non the `'app'` channel which can be used by other listeners or [plugins](#plugins). The arguments\nare:\n- `tags` - a string or an array of strings (e.g. `['error', 'database', 'read']`) used to identify\n  the event. Tags are used instead of log levels and provide a much more expressive mechanism for\n  describing and filtering events.\n- `data` - (optional) an message string or object with the application data being logged. If `data`\n  is a function, the function signature is `function()` and it called once to generate (return\n  value) the actual data emitted to the listeners.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80, routes: { log: { collect: true } } });\n\nserver.events.on({ name: 'request', channels: 'app' }, (request, event, tags) => {\n\n    if (tags.error) {\n        console.log(event);\n    }\n});\n\nconst handler = function (request, h) {\n\n    request.log(['test', 'error'], 'Test event');\n    return null;\n};\n```\n\nNote that any logs generated by the server internally will be emitted using the\n[`'request'` event](#server.events.request) on the `'internal'` channel.\n\n```js\nserver.events.on({ name: 'request', channels: 'internal' }, (request, event, tags) => {\n\n    console.log(event);\n});\n```\n\n### <a name=\"request.route.auth.access()\" /> `request.route.auth.access(request)`\n\nValidates a request against the route's authentication [`access`](#route.options.auth.access)\nconfiguration, where:\n\n- `request` - the [request object](#request).\n\nReturn value: `true` if the `request` would have passed the route's access requirements.\n\nNote that the route's authentication mode and strategies are ignored. The only match is made\nbetween the `request.auth.credentials` scope and entity information and the route\n[`access`](#route.options.auth.access) configuration.\n\nIf the route uses dynamic scopes, the scopes are constructed against the [`request.query`](#request.query),\n[`request.params`](#request.params), [`request.payload`](#request.payload), and\n[`request.auth.credentials`](#request.auth) which may or may not match between the route and the\nrequest's route. If this method is called using a request that has not been authenticated (yet or\nnot at all), it will return `false` if the route requires any authentication.\n\n### <a name=\"request.setMethod()\" /> `request.setMethod(method)`\n\nChanges the request method before the router begins processing the request where:\n- `method` - is the request HTTP method (e.g. `'GET'`).\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst onRequest = function (request, h) {\n\n    // Change all requests to 'GET'\n    request.setMethod('GET');\n    return h.continue;\n};\n\nserver.ext('onRequest', onRequest);\n```\n\nCan only be called from an `'onRequest'` extension method.\n\n### <a name=\"request.setUrl()\" /> `request.setUrl(url, [stripTrailingSlash]`\n\nChanges the request URI before the router begins processing the request where:\n- `url` - the new request URI. `url` can be a string or an instance of\n  [`Url.URL`](https://nodejs.org/dist/latest-v10.x/docs/api/url.html#url_class_url) in which case\n  `url.href` is used.\n- `stripTrailingSlash` - if `true`, strip the trailing slash from the path. Defaults to `false`.\n\n```js\nconst Hapi = require('@hapi/hapi');\nconst server = Hapi.server({ port: 80 });\n\nconst onRequest = function (request, h) {\n\n    // Change all requests to '/test'\n    request.setUrl('/test');\n    return h.continue;\n};\n\nserver.ext('onRequest', onRequest);\n```\n\nCan only be called from an `'onRequest'` extension method.\n\n## Plugins\n\nPlugins provide a way to organize application code by splitting the server logic into smaller\ncomponents. Each plugin can manipulate the server through the standard server interface, but with\nthe added ability to sandbox certain properties. For example, setting a file path in one plugin\ndoesn't affect the file path set in another plugin.\n\nA plugin is an object with the following properties:\n\n- `register` - (required) the registration function with the signature\n  `async function(server, options)` where:\n\n    - `server` - the server object with a plugin-specific [`server.realm`](#server.realm).\n    - `options` - any options passed to the plugin during registration via [`server.register()`](#server.register()).\n\n- `name` - (required) the plugin name string. The name is used as a unique key. Published plugins\n  (e.g. published in the npm registry) should  use the same name as the name field in their\n  'package.json' file. Names must be unique within each application.\n\n- `version` - (optional) plugin version string. The version is only used informatively to enable\n  other plugins to find out the versions loaded. The version should be the same as the one\n  specified in the plugin's 'package.json' file.\n\n- `multiple` - (optional) if `true`, allows the plugin to be registered multiple times with the same server.\n  Defaults to `false`.\n\n- `dependencies` - (optional) a string or an array of strings indicating a plugin dependency. Same\n  as setting dependencies via [`server.dependency()`](#server.dependency()).\n\n- `requirements` - (optional) object declaring the plugin supported [semver range](https://semver.org/) for:\n\n  - `node` runtime [semver range](https://nodejs.org/en/about/releases/) string.\n  - `hapi` framework [semver range](#server.version) string.\n\n- `once` - (optional) if `true`, will only register the plugin once per server. If set, overrides\n  the `once` option passed to [`server.register()`](#server.register()). Defaults to no override.\n\n```js\nconst plugin = {\n    name: 'test',\n    version: '1.0.0',\n    register: function (server, options) {\n\n        server.route({\n            method: 'GET',\n            path: '/test',\n            handler: function (request, h) {\n\n                return 'ok';\n            }\n        });\n    }\n};\n```\n\nAlternatively, the `name` and `version` can be included via the `pkg` property containing the\n'package.json' file for the module which already has the name and version included:\n\n```js\nconst plugin = {\n    pkg: require('./package.json'),\n    register: function (server, options) {\n\n        server.route({\n            method: 'GET',\n            path: '/test',\n            handler: function (request, h) {\n\n                return 'ok';\n            }\n        });\n    }\n};\n```\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.51953125,
          "content": "Copyright (c) 2011-2022, Project contributors\nCopyright (c) 2011-2020, Sideway Inc\nCopyright (c) 2011-2014, Walmart  \nCopyright (c) 2011, Yahoo Inc.  \nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n- The names of any contributors may not be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS OFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.0966796875,
          "content": "<img src=\"https://raw.githubusercontent.com/hapijs/assets/master/images/hapi.png\" width=\"400px\" />\n\n# @hapi/hapi\n\n#### The Simple, Secure Framework Developers Trust\n\nBuild powerful, scalable applications, with minimal overhead and full out-of-the-box functionality - your code, your way.\n\n### Visit the [hapi.dev](https://hapi.dev) Developer Portal for tutorials, documentation, and support\n\n## Useful resources\n\n- [Documentation and API](https://hapi.dev/)\n- [Version status](https://hapi.dev/resources/status/#hapi) (builds, dependencies, node versions, licenses, eol)\n- [Changelog](https://hapi.dev/resources/changelog/)\n- [Project policies](https://hapi.dev/policies/)\n- [Support](https://hapi.dev/support/)\n\n## Technical Steering Committee (TSC) Members\n\n - Devin Ivy ([@devinivy](https://github.com/devinivy))\n - Lloyd Benson ([@lloydbenson](https://github.com/lloydbenson))\n - Nathan LaFreniere ([@nlf](https://github.com/nlf))\n - Wyatt Lyon Preul ([@geek](https://github.com/geek))\n - Nicolas Morel ([@marsup](https://github.com/marsup))\n - Jonathan Samines ([@jonathansamines](https://github.com/jonathansamines))\n"
        },
        {
          "name": "SPONSORS.md",
          "type": "blob",
          "size": 0.6748046875,
          "content": "We'd like to thank our sponsors as well as the legacy sponsors who have supported hapi throughout the years. Thanks so much for your support!\n\n> Below are hapi's top recurring sponsors, but there are many more to thank. For the complete list, see [hapi.dev/policies/sponsors](https://hapi.dev/policies/sponsors/) or [hapijs/.github/SPONSORS.md](https://github.com/hapijs/.github/blob/master/SPONSORS.md).\n\n# Staff Sponsors\n\n- [Big Room Studios](https://www.bigroomstudios.com/)\n- [Dixeed](https://dixeed.com/)\n\n# Top Sponsors\n\n- Fabian Gündel / [DataWrapper.de](https://www.datawrapper.de/)\n- Devin Stewart\n- [Raider.IO](https://raider.io/)\n- [Florence Healthcare](https://florencehc.com/)\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.6552734375,
          "content": "{\n  \"name\": \"@hapi/hapi\",\n  \"description\": \"HTTP Server framework\",\n  \"homepage\": \"https://hapi.dev\",\n  \"version\": \"21.3.12\",\n  \"repository\": \"git://github.com/hapijs/hapi\",\n  \"main\": \"lib/index.js\",\n  \"types\": \"lib/index.d.ts\",\n  \"engines\": {\n    \"node\": \">=14.15.0\"\n  },\n  \"files\": [\n    \"lib\"\n  ],\n  \"keywords\": [\n    \"framework\",\n    \"http\",\n    \"api\",\n    \"web\"\n  ],\n  \"eslintConfig\": {\n    \"extends\": [\n      \"plugin:@hapi/module\"\n    ]\n  },\n  \"dependencies\": {\n    \"@hapi/accept\": \"^6.0.3\",\n    \"@hapi/ammo\": \"^6.0.1\",\n    \"@hapi/boom\": \"^10.0.1\",\n    \"@hapi/bounce\": \"^3.0.2\",\n    \"@hapi/call\": \"^9.0.1\",\n    \"@hapi/catbox\": \"^12.1.1\",\n    \"@hapi/catbox-memory\": \"^6.0.2\",\n    \"@hapi/heavy\": \"^8.0.1\",\n    \"@hapi/hoek\": \"^11.0.6\",\n    \"@hapi/mimos\": \"^7.0.1\",\n    \"@hapi/podium\": \"^5.0.1\",\n    \"@hapi/shot\": \"^6.0.1\",\n    \"@hapi/somever\": \"^4.1.1\",\n    \"@hapi/statehood\": \"^8.1.1\",\n    \"@hapi/subtext\": \"^8.1.0\",\n    \"@hapi/teamwork\": \"^6.0.0\",\n    \"@hapi/topo\": \"^6.0.2\",\n    \"@hapi/validate\": \"^2.0.1\"\n  },\n  \"devDependencies\": {\n    \"@hapi/code\": \"^9.0.3\",\n    \"@hapi/eslint-plugin\": \"^6.0.0\",\n    \"@hapi/inert\": \"^7.1.0\",\n    \"@hapi/joi-legacy-test\": \"npm:@hapi/joi@^15.0.0\",\n    \"@hapi/lab\": \"^25.3.2\",\n    \"@hapi/vision\": \"^7.0.3\",\n    \"@hapi/wreck\": \"^18.1.0\",\n    \"@types/node\": \"^18.19.59\",\n    \"handlebars\": \"^4.7.8\",\n    \"joi\": \"^17.13.3\",\n    \"legacy-readable-stream\": \"npm:readable-stream@^1.0.34\",\n    \"typescript\": \"^4.9.4\"\n  },\n  \"scripts\": {\n    \"test\": \"lab -a @hapi/code -t 100 -L -m 5000 -Y\",\n    \"test-tap\": \"lab -a @hapi/code -r tap -o tests.tap -m 5000\",\n    \"test-cov-html\": \"lab -a @hapi/code -r html -o coverage.html -m 5000\"\n  },\n  \"license\": \"BSD-3-Clause\"\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}