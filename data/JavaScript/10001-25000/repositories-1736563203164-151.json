{
  "metadata": {
    "timestamp": 1736563203164,
    "page": 151,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "defunkt/jquery-pjax",
      "stars": 16714,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".eslintrc",
          "type": "blob",
          "size": 0.3203125,
          "content": "{ \"extends\": \"eslint:recommended\",\n  \"env\": {\n    \"browser\": true,\n    \"jquery\": true\n  },\n  \"rules\": {\n    \"eqeqeq\": \"warn\",\n    \"no-eval\": \"error\",\n    \"no-extra-parens\": \"error\",\n    \"no-implicit-globals\": \"error\",\n    \"no-trailing-spaces\": \"error\",\n    \"no-unused-expressions\": \"error\",\n    \"semi\": [\"error\", \"never\"]\n  }\n}\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.013671875,
          "content": "node_modules/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.40234375,
          "content": "sudo: false\nlanguage: node_js\nnode_js: \"6\"\nbefore_script: script/bootstrap\n\nnotifications:\n  email: false\ndeploy:\n  provider: npm\n  email: mislav.marohnic@gmail.com\n  api_key:\n    secure: nstPtsdxAHGPkKl2wOnMW4FXHg1nKxG/yCYQYqiC61JqhbfSaZFVjIQrdH+9GSel7F/K7VLwGZwSVgfiWUymWeEsNw8R/cyI9xCXf5iNF6WHIwuX6Q3Tnvb3Cx/bkeoc8+4v7qR172FtzwKWJq2iKXawd58/4zf2sduOwld1PMw=\n  on:\n    tags: true\n    repo: defunkt/jquery-pjax\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.8857421875,
          "content": "# Contributing\n\nFor running the tests, you will need:\n\n* Ruby 1.9.3+ with Bundler\n* PhantomJS (for headless testing)\n\nFirst run bootstrap to ensure necessary dependencies:\n\n```\n$ script/bootstrap\n```\n\nThen run headless tests in the console:\n\n```\n$ script/test [<test-file>]\n```\n\nTo run tests in other browsers, start a server:\n\n```\n$ script/server\n# now open http://localhost:4567/\n```\n\n## Test structure\n\nThere are 3 main test modules:\n\n* `test/unit/fn_pjax.js` - Primarily tests the `$.fn.pjax` method and its options\n* `test/unit/pjax.js` - Main comprehensive pjax functionality tests\n* `test/unit/pjax_fallback.js` - Tests that verify same result after navigation\n  even if pjax is disabled (like for browsers that don't support pushState).\n\nEach test drives a hidden test page in an `<iframe>`. See other tests to see how\nthey trigger pjax by using the `frame` reference and remember to do so as well.\n"
        },
        {
          "name": "Gemfile",
          "type": "blob",
          "size": 0.0439453125,
          "content": "source 'https://rubygems.org'\n\ngem 'sinatra'\n"
        },
        {
          "name": "Gemfile.lock",
          "type": "blob",
          "size": 0.2783203125,
          "content": "GEM\n  remote: https://rubygems.org/\n  specs:\n    rack (1.5.2)\n    rack-protection (1.5.3)\n      rack\n    sinatra (1.4.5)\n      rack (~> 1.4)\n      rack-protection (~> 1.4)\n      tilt (~> 1.3, >= 1.3.4)\n    tilt (1.4.1)\n\nPLATFORMS\n  ruby\n\nDEPENDENCIES\n  sinatra\n\nBUNDLED WITH\n   1.14.6\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.025390625,
          "content": "Copyright (c) Chris Wanstrath\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\nSoftware), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.0185546875,
          "content": "# pjax = pushState + ajax\n\npjax is a jQuery plugin that uses ajax and pushState to deliver a fast browsing experience with real permalinks, page titles, and a working back button.\n\npjax works by fetching HTML from your server via ajax and replacing the content\nof a container element on your page with the loaded HTML. It then updates the\ncurrent URL in the browser using pushState. This results in faster page\nnavigation for two reasons:\n\n* No page resources (JS, CSS) get re-executed or re-applied;\n* If the server is configured for pjax, it can render only partial page\n  contents and thus avoid the potentially costly full layout render.\n\n### Status of this project\n\njquery-pjax is **largely unmaintained** at this point. It might continue to\nreceive important bug fixes, but _its feature set is frozen_ and it's unlikely\nthat it will get new features or enhancements.\n\n## Installation\n\npjax depends on jQuery 1.8 or higher.\n\n### npm\n\n```\n$ npm install jquery-pjax\n```\n\n### standalone script\n\nDownload and include `jquery.pjax.js` in your web page:\n\n```\ncurl -LO https://raw.github.com/defunkt/jquery-pjax/master/jquery.pjax.js\n```\n\n## Usage\n\n### `$.fn.pjax`\n\nThe simplest and most common use of pjax looks like this:\n\n``` javascript\n$(document).pjax('a', '#pjax-container')\n```\n\nThis will enable pjax on all links on the page and designate the container as `#pjax-container`.\n\nIf you are migrating an existing site, you probably don't want to enable pjax\neverywhere just yet. Instead of using a global selector like `a`, try annotating\npjaxable links with `data-pjax`, then use `'a[data-pjax]'` as your selector. Or,\ntry this selector that matches any `<a data-pjax href=>` links inside a `<div\ndata-pjax>` container:\n\n``` javascript\n$(document).pjax('[data-pjax] a, a[data-pjax]', '#pjax-container')\n```\n\n#### Server-side configuration\n\nIdeally, your server should detect pjax requests by looking at the special\n`X-PJAX` HTTP header, and render only the HTML meant to replace the contents of\nthe container element (`#pjax-container` in our example) without the rest of\nthe page layout. Here is an example of how this might be done in Ruby on Rails:\n\n``` ruby\ndef index\n  if request.headers['X-PJAX']\n    render :layout => false\n  end\nend\n```\n\nIf you'd like a more automatic solution than pjax for Rails check out [Turbolinks][].\n\n[Check if there is a pjax plugin][plugins] for your favorite server framework.\n\nAlso check out [RailsCasts #294: Playing with PJAX][railscasts].\n\n#### Arguments\n\nThe synopsis for the `$.fn.pjax` function is:\n\n``` javascript\n$(document).pjax(selector, [container], options)\n```\n\n1. `selector` is a string to be used for click [event delegation][$.fn.on].\n2. `container` is a string selector that uniquely identifies the pjax container.\n3. `options` is an object with keys described below.\n\n##### pjax options\n\nkey | default | description\n----|---------|------------\n`timeout` | 650 | ajax timeout in milliseconds after which a full refresh is forced\n`push` | true | use [pushState][] to add a browser history entry upon navigation\n`replace` | false | replace URL without adding browser history entry\n`maxCacheLength` | 20 | maximum cache size for previous container contents\n`version` | | a string or function returning the current pjax version\n`scrollTo` | 0 | vertical position to scroll to after navigation. To avoid changing scroll position, pass `false`.\n`type` | `\"GET\"` | see [$.ajax][]\n`dataType` | `\"html\"` | see [$.ajax][]\n`container` | | CSS selector for the element where content should be replaced\n`url` | link.href | a string or function that returns the URL for the ajax request\n`target` | link | eventually the `relatedTarget` value for [pjax events](#events)\n`fragment` | | CSS selector for the fragment to extract from ajax response\n\nYou can change the defaults globally by writing to the `$.pjax.defaults` object:\n\n``` javascript\n$.pjax.defaults.timeout = 1200\n```\n\n### `$.pjax.click`\n\nThis is a lower level function used by `$.fn.pjax` itself. It allows you to get a little more control over the pjax event handling.\n\nThis example uses the current click context to set an ancestor element as the container:\n\n``` javascript\nif ($.support.pjax) {\n  $(document).on('click', 'a[data-pjax]', function(event) {\n    var container = $(this).closest('[data-pjax-container]')\n    var containerSelector = '#' + container.id\n    $.pjax.click(event, {container: containerSelector})\n  })\n}\n```\n\n**NOTE** Use the explicit `$.support.pjax` guard. We aren't using `$.fn.pjax` so we should avoid binding this event handler unless the browser is actually going to use pjax.\n\n### `$.pjax.submit`\n\nSubmits a form via pjax.\n\n``` javascript\n$(document).on('submit', 'form[data-pjax]', function(event) {\n  $.pjax.submit(event, '#pjax-container')\n})\n```\n\n### `$.pjax.reload`\n\nInitiates a request for the current URL to the server using pjax mechanism and replaces the container with the response. Does not add a browser history entry.\n\n``` javascript\n$.pjax.reload('#pjax-container', options)\n```\n\n### `$.pjax`\n\nManual pjax invocation. Used mainly when you want to start a pjax request in a handler that didn't originate from a click. If you can get access to a click `event`, consider `$.pjax.click(event)` instead.\n\n``` javascript\nfunction applyFilters() {\n  var url = urlForFilters()\n  $.pjax({url: url, container: '#pjax-container'})\n}\n```\n\n## Events\n\nAll pjax events except `pjax:click` & `pjax:clicked` are fired from the pjax\ncontainer element.\n\n<table>\n<tr>\n  <th>event</th>\n  <th>cancel</th>\n  <th>arguments</th>\n  <th>notes</th>\n</tr>\n<tr>\n  <th colspan=4>event lifecycle upon following a pjaxed link</th>\n</tr>\n<tr>\n  <td><code>pjax:click</code></td>\n  <td>✔︎</td>\n  <td><code>options</code></td>\n  <td>fires from a link that got activated; cancel to prevent pjax</td>\n</tr>\n<tr>\n  <td><code>pjax:beforeSend</code></td>\n  <td>✔︎</td>\n  <td><code>xhr, options</code></td>\n  <td>can set XHR headers</td>\n</tr>\n<tr>\n  <td><code>pjax:start</code></td>\n  <td></td>\n  <td><code>xhr, options</code></td>\n  <td></td>\n</tr>\n<tr>\n  <td><code>pjax:send</code></td>\n  <td></td>\n  <td><code>xhr, options</code></td>\n  <td></td>\n</tr>\n<tr>\n  <td><code>pjax:clicked</code></td>\n  <td></td>\n  <td><code>options</code></td>\n  <td>fires after pjax has started from a link that got clicked</td>\n</tr>\n<tr>\n  <td><code>pjax:beforeReplace</code></td>\n  <td></td>\n  <td><code>contents, options</code></td>\n  <td>before replacing HTML with content loaded from the server</td>\n</tr>\n<tr>\n  <td><code>pjax:success</code></td>\n  <td></td>\n  <td><code>data, status, xhr, options</code></td>\n  <td>after replacing HTML content loaded from the server</td>\n</tr>\n<tr>\n  <td><code>pjax:timeout</code></td>\n  <td>✔︎</td>\n  <td><code>xhr, options</code></td>\n  <td>fires after <code>options.timeout</code>; will hard refresh unless canceled</td>\n</tr>\n<tr>\n  <td><code>pjax:error</code></td>\n  <td>✔︎</td>\n  <td><code>xhr, textStatus, error, options</code></td>\n  <td>on ajax error; will hard refresh unless canceled</td>\n</tr>\n<tr>\n  <td><code>pjax:complete</code></td>\n  <td></td>\n  <td><code>xhr, textStatus, options</code></td>\n  <td>always fires after ajax, regardless of result</td>\n</tr>\n<tr>\n  <td><code>pjax:end</code></td>\n  <td></td>\n  <td><code>xhr, options</code></td>\n  <td></td>\n</tr>\n<tr>\n  <th colspan=4>event lifecycle on browser Back/Forward navigation</th>\n</tr>\n<tr>\n  <td><code>pjax:popstate</code></td>\n  <td></td>\n  <td></td>\n  <td>event <code>direction</code> property: &quot;back&quot;/&quot;forward&quot;</td>\n</tr>\n<tr>\n  <td><code>pjax:start</code></td>\n  <td></td>\n  <td><code>null, options</code></td>\n  <td>before replacing content</td>\n</tr>\n<tr>\n  <td><code>pjax:beforeReplace</code></td>\n  <td></td>\n  <td><code>contents, options</code></td>\n  <td>right before replacing HTML with content from cache</td>\n</tr>\n<tr>\n  <td><code>pjax:end</code></td>\n  <td></td>\n  <td><code>null, options</code></td>\n  <td>after replacing content</td>\n</tr>\n</table>\n\n`pjax:send` & `pjax:complete` are a good pair of events to use if you are implementing a\nloading indicator. They'll only be triggered if an actual XHR request is made,\nnot if the content is loaded from cache:\n\n``` javascript\n$(document).on('pjax:send', function() {\n  $('#loading').show()\n})\n$(document).on('pjax:complete', function() {\n  $('#loading').hide()\n})\n```\n\nAn example of canceling a `pjax:timeout` event would be to disable the fallback\ntimeout behavior if a spinner is being shown:\n\n``` javascript\n$(document).on('pjax:timeout', function(event) {\n  // Prevent default timeout redirection behavior\n  event.preventDefault()\n})\n```\n\n## Advanced configuration\n\n### Reinitializing plugins/widget on new page content\n\nThe whole point of pjax is that it fetches and inserts new content _without_\nrefreshing the page. However, other jQuery plugins or libraries that are set to\nreact on page loaded event (such as `DOMContentLoaded`) will not pick up on\nthese changes. Therefore, it's usually a good idea to configure these plugins to\nreinitialize in the scope of the updated page content. This can be done like so:\n\n``` js\n$(document).on('ready pjax:end', function(event) {\n  $(event.target).initializeMyPlugin()\n})\n```\n\nThis will make `$.fn.initializeMyPlugin()` be called at the document level on\nnormal page load, and on the container level after any pjax navigation (either\nafter clicking on a link or going Back in the browser).\n\n### Response types that force a reload\n\nBy default, pjax will force a full reload of the page if it receives one of the\nfollowing responses from the server:\n\n* Page content that includes `<html>` when `fragment` selector wasn't explicitly\n  configured. Pjax presumes that the server's response hasn't been properly\n  configured for pjax. If `fragment` pjax option is given, pjax will extract the\n  content based on that selector.\n\n* Page content that is blank. Pjax assumes that the server is unable to deliver\n  proper pjax contents.\n\n* HTTP response code that is 4xx or 5xx, indicating some server error.\n\n### Affecting the browser URL\n\nIf the server needs to affect the URL which will appear in the browser URL after\npjax navigation (like HTTP redirects work for normal requests), it can set the\n`X-PJAX-URL` header:\n\n``` ruby\ndef index\n  request.headers['X-PJAX-URL'] = \"http://example.com/hello\"\nend\n```\n\n### Layout Reloading\n\nLayouts can be forced to do a hard reload when assets or html changes.\n\nFirst set the initial layout version in your header with a custom meta tag.\n\n``` html\n<meta http-equiv=\"x-pjax-version\" content=\"v123\">\n```\n\nThen from the server side, set the `X-PJAX-Version` header to the same.\n\n``` ruby\nif request.headers['X-PJAX']\n  response.headers['X-PJAX-Version'] = \"v123\"\nend\n```\n\nDeploying a deploy, bumping the version constant to force clients to do a full reload the next request getting the new layout and assets.\n\n\n[$.fn.on]: http://api.jquery.com/on/\n[$.ajax]: http://api.jquery.com/jQuery.ajax/\n[pushState]: https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history#Adding_and_modifying_history_entries\n[plugins]: https://gist.github.com/4283721\n[turbolinks]: https://github.com/rails/turbolinks\n[railscasts]: http://railscasts.com/episodes/294-playing-with-pjax\n"
        },
        {
          "name": "bower.json",
          "type": "blob",
          "size": 0.2373046875,
          "content": "{\n  \"name\": \"jquery-pjax\",\n  \"main\": \"./jquery.pjax.js\",\n  \"dependencies\": {\n    \"jquery\": \">=1.8\"\n  },\n  \"ignore\": [\n    \".travis.yml\",\n    \"Gemfile\",\n    \"Gemfile.lock\",\n    \"CONTRIBUTING.md\",\n    \"vendor/\",\n    \"script/\",\n    \"test/\"\n  ]\n}\n"
        },
        {
          "name": "jquery.pjax.js",
          "type": "blob",
          "size": 24.66796875,
          "content": "/*!\n * Copyright 2012, Chris Wanstrath\n * Released under the MIT License\n * https://github.com/defunkt/jquery-pjax\n */\n\n(function($){\n\n// When called on a container with a selector, fetches the href with\n// ajax into the container or with the data-pjax attribute on the link\n// itself.\n//\n// Tries to make sure the back button and ctrl+click work the way\n// you'd expect.\n//\n// Exported as $.fn.pjax\n//\n// Accepts a jQuery ajax options object that may include these\n// pjax specific options:\n//\n//\n// container - String selector for the element where to place the response body.\n//      push - Whether to pushState the URL. Defaults to true (of course).\n//   replace - Want to use replaceState instead? That's cool.\n//\n// For convenience the second parameter can be either the container or\n// the options object.\n//\n// Returns the jQuery object\nfunction fnPjax(selector, container, options) {\n  options = optionsFor(container, options)\n  return this.on('click.pjax', selector, function(event) {\n    var opts = options\n    if (!opts.container) {\n      opts = $.extend({}, options)\n      opts.container = $(this).attr('data-pjax')\n    }\n    handleClick(event, opts)\n  })\n}\n\n// Public: pjax on click handler\n//\n// Exported as $.pjax.click.\n//\n// event   - \"click\" jQuery.Event\n// options - pjax options\n//\n// Examples\n//\n//   $(document).on('click', 'a', $.pjax.click)\n//   // is the same as\n//   $(document).pjax('a')\n//\n// Returns nothing.\nfunction handleClick(event, container, options) {\n  options = optionsFor(container, options)\n\n  var link = event.currentTarget\n  var $link = $(link)\n\n  if (link.tagName.toUpperCase() !== 'A')\n    throw \"$.fn.pjax or $.pjax.click requires an anchor element\"\n\n  // Middle click, cmd click, and ctrl click should open\n  // links in a new tab as normal.\n  if ( event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey )\n    return\n\n  // Ignore cross origin links\n  if ( location.protocol !== link.protocol || location.hostname !== link.hostname )\n    return\n\n  // Ignore case when a hash is being tacked on the current URL\n  if ( link.href.indexOf('#') > -1 && stripHash(link) == stripHash(location) )\n    return\n\n  // Ignore event with default prevented\n  if (event.isDefaultPrevented())\n    return\n\n  var defaults = {\n    url: link.href,\n    container: $link.attr('data-pjax'),\n    target: link\n  }\n\n  var opts = $.extend({}, defaults, options)\n  var clickEvent = $.Event('pjax:click')\n  $link.trigger(clickEvent, [opts])\n\n  if (!clickEvent.isDefaultPrevented()) {\n    pjax(opts)\n    event.preventDefault()\n    $link.trigger('pjax:clicked', [opts])\n  }\n}\n\n// Public: pjax on form submit handler\n//\n// Exported as $.pjax.submit\n//\n// event   - \"click\" jQuery.Event\n// options - pjax options\n//\n// Examples\n//\n//  $(document).on('submit', 'form', function(event) {\n//    $.pjax.submit(event, '[data-pjax-container]')\n//  })\n//\n// Returns nothing.\nfunction handleSubmit(event, container, options) {\n  options = optionsFor(container, options)\n\n  var form = event.currentTarget\n  var $form = $(form)\n\n  if (form.tagName.toUpperCase() !== 'FORM')\n    throw \"$.pjax.submit requires a form element\"\n\n  var defaults = {\n    type: ($form.attr('method') || 'GET').toUpperCase(),\n    url: $form.attr('action'),\n    container: $form.attr('data-pjax'),\n    target: form\n  }\n\n  if (defaults.type !== 'GET' && window.FormData !== undefined) {\n    defaults.data = new FormData(form)\n    defaults.processData = false\n    defaults.contentType = false\n  } else {\n    // Can't handle file uploads, exit\n    if ($form.find(':file').length) {\n      return\n    }\n\n    // Fallback to manually serializing the fields\n    defaults.data = $form.serializeArray()\n  }\n\n  pjax($.extend({}, defaults, options))\n\n  event.preventDefault()\n}\n\n// Loads a URL with ajax, puts the response body inside a container,\n// then pushState()'s the loaded URL.\n//\n// Works just like $.ajax in that it accepts a jQuery ajax\n// settings object (with keys like url, type, data, etc).\n//\n// Accepts these extra keys:\n//\n// container - String selector for where to stick the response body.\n//      push - Whether to pushState the URL. Defaults to true (of course).\n//   replace - Want to use replaceState instead? That's cool.\n//\n// Use it just like $.ajax:\n//\n//   var xhr = $.pjax({ url: this.href, container: '#main' })\n//   console.log( xhr.readyState )\n//\n// Returns whatever $.ajax returns.\nfunction pjax(options) {\n  options = $.extend(true, {}, $.ajaxSettings, pjax.defaults, options)\n\n  if ($.isFunction(options.url)) {\n    options.url = options.url()\n  }\n\n  var hash = parseURL(options.url).hash\n\n  var containerType = $.type(options.container)\n  if (containerType !== 'string') {\n    throw \"expected string value for 'container' option; got \" + containerType\n  }\n  var context = options.context = $(options.container)\n  if (!context.length) {\n    throw \"the container selector '\" + options.container + \"' did not match anything\"\n  }\n\n  // We want the browser to maintain two separate internal caches: one\n  // for pjax'd partial page loads and one for normal page loads.\n  // Without adding this secret parameter, some browsers will often\n  // confuse the two.\n  if (!options.data) options.data = {}\n  if ($.isArray(options.data)) {\n    options.data.push({name: '_pjax', value: options.container})\n  } else {\n    options.data._pjax = options.container\n  }\n\n  function fire(type, args, props) {\n    if (!props) props = {}\n    props.relatedTarget = options.target\n    var event = $.Event(type, props)\n    context.trigger(event, args)\n    return !event.isDefaultPrevented()\n  }\n\n  var timeoutTimer\n\n  options.beforeSend = function(xhr, settings) {\n    // No timeout for non-GET requests\n    // Its not safe to request the resource again with a fallback method.\n    if (settings.type !== 'GET') {\n      settings.timeout = 0\n    }\n\n    xhr.setRequestHeader('X-PJAX', 'true')\n    xhr.setRequestHeader('X-PJAX-Container', options.container)\n\n    if (!fire('pjax:beforeSend', [xhr, settings]))\n      return false\n\n    if (settings.timeout > 0) {\n      timeoutTimer = setTimeout(function() {\n        if (fire('pjax:timeout', [xhr, options]))\n          xhr.abort('timeout')\n      }, settings.timeout)\n\n      // Clear timeout setting so jquerys internal timeout isn't invoked\n      settings.timeout = 0\n    }\n\n    var url = parseURL(settings.url)\n    if (hash) url.hash = hash\n    options.requestUrl = stripInternalParams(url)\n  }\n\n  options.complete = function(xhr, textStatus) {\n    if (timeoutTimer)\n      clearTimeout(timeoutTimer)\n\n    fire('pjax:complete', [xhr, textStatus, options])\n\n    fire('pjax:end', [xhr, options])\n  }\n\n  options.error = function(xhr, textStatus, errorThrown) {\n    var container = extractContainer(\"\", xhr, options)\n\n    var allowed = fire('pjax:error', [xhr, textStatus, errorThrown, options])\n    if (options.type == 'GET' && textStatus !== 'abort' && allowed) {\n      locationReplace(container.url)\n    }\n  }\n\n  options.success = function(data, status, xhr) {\n    var previousState = pjax.state\n\n    // If $.pjax.defaults.version is a function, invoke it first.\n    // Otherwise it can be a static string.\n    var currentVersion = typeof $.pjax.defaults.version === 'function' ?\n      $.pjax.defaults.version() :\n      $.pjax.defaults.version\n\n    var latestVersion = xhr.getResponseHeader('X-PJAX-Version')\n\n    var container = extractContainer(data, xhr, options)\n\n    var url = parseURL(container.url)\n    if (hash) {\n      url.hash = hash\n      container.url = url.href\n    }\n\n    // If there is a layout version mismatch, hard load the new url\n    if (currentVersion && latestVersion && currentVersion !== latestVersion) {\n      locationReplace(container.url)\n      return\n    }\n\n    // If the new response is missing a body, hard load the page\n    if (!container.contents) {\n      locationReplace(container.url)\n      return\n    }\n\n    pjax.state = {\n      id: options.id || uniqueId(),\n      url: container.url,\n      title: container.title,\n      container: options.container,\n      fragment: options.fragment,\n      timeout: options.timeout\n    }\n\n    if (options.push || options.replace) {\n      window.history.replaceState(pjax.state, container.title, container.url)\n    }\n\n    // Only blur the focus if the focused element is within the container.\n    var blurFocus = $.contains(context, document.activeElement)\n\n    // Clear out any focused controls before inserting new page contents.\n    if (blurFocus) {\n      try {\n        document.activeElement.blur()\n      } catch (e) { /* ignore */ }\n    }\n\n    if (container.title) document.title = container.title\n\n    fire('pjax:beforeReplace', [container.contents, options], {\n      state: pjax.state,\n      previousState: previousState\n    })\n    context.html(container.contents)\n\n    // FF bug: Won't autofocus fields that are inserted via JS.\n    // This behavior is incorrect. So if theres no current focus, autofocus\n    // the last field.\n    //\n    // http://www.w3.org/html/wg/drafts/html/master/forms.html\n    var autofocusEl = context.find('input[autofocus], textarea[autofocus]').last()[0]\n    if (autofocusEl && document.activeElement !== autofocusEl) {\n      autofocusEl.focus()\n    }\n\n    executeScriptTags(container.scripts)\n\n    var scrollTo = options.scrollTo\n\n    // Ensure browser scrolls to the element referenced by the URL anchor\n    if (hash) {\n      var name = decodeURIComponent(hash.slice(1))\n      var target = document.getElementById(name) || document.getElementsByName(name)[0]\n      if (target) scrollTo = $(target).offset().top\n    }\n\n    if (typeof scrollTo == 'number') $(window).scrollTop(scrollTo)\n\n    fire('pjax:success', [data, status, xhr, options])\n  }\n\n\n  // Initialize pjax.state for the initial page load. Assume we're\n  // using the container and options of the link we're loading for the\n  // back button to the initial page. This ensures good back button\n  // behavior.\n  if (!pjax.state) {\n    pjax.state = {\n      id: uniqueId(),\n      url: window.location.href,\n      title: document.title,\n      container: options.container,\n      fragment: options.fragment,\n      timeout: options.timeout\n    }\n    window.history.replaceState(pjax.state, document.title)\n  }\n\n  // Cancel the current request if we're already pjaxing\n  abortXHR(pjax.xhr)\n\n  pjax.options = options\n  var xhr = pjax.xhr = $.ajax(options)\n\n  if (xhr.readyState > 0) {\n    if (options.push && !options.replace) {\n      // Cache current container element before replacing it\n      cachePush(pjax.state.id, [options.container, cloneContents(context)])\n\n      window.history.pushState(null, \"\", options.requestUrl)\n    }\n\n    fire('pjax:start', [xhr, options])\n    fire('pjax:send', [xhr, options])\n  }\n\n  return pjax.xhr\n}\n\n// Public: Reload current page with pjax.\n//\n// Returns whatever $.pjax returns.\nfunction pjaxReload(container, options) {\n  var defaults = {\n    url: window.location.href,\n    push: false,\n    replace: true,\n    scrollTo: false\n  }\n\n  return pjax($.extend(defaults, optionsFor(container, options)))\n}\n\n// Internal: Hard replace current state with url.\n//\n// Work for around WebKit\n//   https://bugs.webkit.org/show_bug.cgi?id=93506\n//\n// Returns nothing.\nfunction locationReplace(url) {\n  window.history.replaceState(null, \"\", pjax.state.url)\n  window.location.replace(url)\n}\n\n\nvar initialPop = true\nvar initialURL = window.location.href\nvar initialState = window.history.state\n\n// Initialize $.pjax.state if possible\n// Happens when reloading a page and coming forward from a different\n// session history.\nif (initialState && initialState.container) {\n  pjax.state = initialState\n}\n\n// Non-webkit browsers don't fire an initial popstate event\nif ('state' in window.history) {\n  initialPop = false\n}\n\n// popstate handler takes care of the back and forward buttons\n//\n// You probably shouldn't use pjax on pages with other pushState\n// stuff yet.\nfunction onPjaxPopstate(event) {\n\n  // Hitting back or forward should override any pending PJAX request.\n  if (!initialPop) {\n    abortXHR(pjax.xhr)\n  }\n\n  var previousState = pjax.state\n  var state = event.state\n  var direction\n\n  if (state && state.container) {\n    // When coming forward from a separate history session, will get an\n    // initial pop with a state we are already at. Skip reloading the current\n    // page.\n    if (initialPop && initialURL == state.url) return\n\n    if (previousState) {\n      // If popping back to the same state, just skip.\n      // Could be clicking back from hashchange rather than a pushState.\n      if (previousState.id === state.id) return\n\n      // Since state IDs always increase, we can deduce the navigation direction\n      direction = previousState.id < state.id ? 'forward' : 'back'\n    }\n\n    var cache = cacheMapping[state.id] || []\n    var containerSelector = cache[0] || state.container\n    var container = $(containerSelector), contents = cache[1]\n\n    if (container.length) {\n      if (previousState) {\n        // Cache current container before replacement and inform the\n        // cache which direction the history shifted.\n        cachePop(direction, previousState.id, [containerSelector, cloneContents(container)])\n      }\n\n      var popstateEvent = $.Event('pjax:popstate', {\n        state: state,\n        direction: direction\n      })\n      container.trigger(popstateEvent)\n\n      var options = {\n        id: state.id,\n        url: state.url,\n        container: containerSelector,\n        push: false,\n        fragment: state.fragment,\n        timeout: state.timeout,\n        scrollTo: false\n      }\n\n      if (contents) {\n        container.trigger('pjax:start', [null, options])\n\n        pjax.state = state\n        if (state.title) document.title = state.title\n        var beforeReplaceEvent = $.Event('pjax:beforeReplace', {\n          state: state,\n          previousState: previousState\n        })\n        container.trigger(beforeReplaceEvent, [contents, options])\n        container.html(contents)\n\n        container.trigger('pjax:end', [null, options])\n      } else {\n        pjax(options)\n      }\n\n      // Force reflow/relayout before the browser tries to restore the\n      // scroll position.\n      container[0].offsetHeight // eslint-disable-line no-unused-expressions\n    } else {\n      locationReplace(location.href)\n    }\n  }\n  initialPop = false\n}\n\n// Fallback version of main pjax function for browsers that don't\n// support pushState.\n//\n// Returns nothing since it retriggers a hard form submission.\nfunction fallbackPjax(options) {\n  var url = $.isFunction(options.url) ? options.url() : options.url,\n      method = options.type ? options.type.toUpperCase() : 'GET'\n\n  var form = $('<form>', {\n    method: method === 'GET' ? 'GET' : 'POST',\n    action: url,\n    style: 'display:none'\n  })\n\n  if (method !== 'GET' && method !== 'POST') {\n    form.append($('<input>', {\n      type: 'hidden',\n      name: '_method',\n      value: method.toLowerCase()\n    }))\n  }\n\n  var data = options.data\n  if (typeof data === 'string') {\n    $.each(data.split('&'), function(index, value) {\n      var pair = value.split('=')\n      form.append($('<input>', {type: 'hidden', name: pair[0], value: pair[1]}))\n    })\n  } else if ($.isArray(data)) {\n    $.each(data, function(index, value) {\n      form.append($('<input>', {type: 'hidden', name: value.name, value: value.value}))\n    })\n  } else if (typeof data === 'object') {\n    var key\n    for (key in data)\n      form.append($('<input>', {type: 'hidden', name: key, value: data[key]}))\n  }\n\n  $(document.body).append(form)\n  form.submit()\n}\n\n// Internal: Abort an XmlHttpRequest if it hasn't been completed,\n// also removing its event handlers.\nfunction abortXHR(xhr) {\n  if ( xhr && xhr.readyState < 4) {\n    xhr.onreadystatechange = $.noop\n    xhr.abort()\n  }\n}\n\n// Internal: Generate unique id for state object.\n//\n// Use a timestamp instead of a counter since ids should still be\n// unique across page loads.\n//\n// Returns Number.\nfunction uniqueId() {\n  return (new Date).getTime()\n}\n\nfunction cloneContents(container) {\n  var cloned = container.clone()\n  // Unmark script tags as already being eval'd so they can get executed again\n  // when restored from cache. HAXX: Uses jQuery internal method.\n  cloned.find('script').each(function(){\n    if (!this.src) $._data(this, 'globalEval', false)\n  })\n  return cloned.contents()\n}\n\n// Internal: Strip internal query params from parsed URL.\n//\n// Returns sanitized url.href String.\nfunction stripInternalParams(url) {\n  url.search = url.search.replace(/([?&])(_pjax|_)=[^&]*/g, '').replace(/^&/, '')\n  return url.href.replace(/\\?($|#)/, '$1')\n}\n\n// Internal: Parse URL components and returns a Locationish object.\n//\n// url - String URL\n//\n// Returns HTMLAnchorElement that acts like Location.\nfunction parseURL(url) {\n  var a = document.createElement('a')\n  a.href = url\n  return a\n}\n\n// Internal: Return the `href` component of given URL object with the hash\n// portion removed.\n//\n// location - Location or HTMLAnchorElement\n//\n// Returns String\nfunction stripHash(location) {\n  return location.href.replace(/#.*/, '')\n}\n\n// Internal: Build options Object for arguments.\n//\n// For convenience the first parameter can be either the container or\n// the options object.\n//\n// Examples\n//\n//   optionsFor('#container')\n//   // => {container: '#container'}\n//\n//   optionsFor('#container', {push: true})\n//   // => {container: '#container', push: true}\n//\n//   optionsFor({container: '#container', push: true})\n//   // => {container: '#container', push: true}\n//\n// Returns options Object.\nfunction optionsFor(container, options) {\n  if (container && options) {\n    options = $.extend({}, options)\n    options.container = container\n    return options\n  } else if ($.isPlainObject(container)) {\n    return container\n  } else {\n    return {container: container}\n  }\n}\n\n// Internal: Filter and find all elements matching the selector.\n//\n// Where $.fn.find only matches descendants, findAll will test all the\n// top level elements in the jQuery object as well.\n//\n// elems    - jQuery object of Elements\n// selector - String selector to match\n//\n// Returns a jQuery object.\nfunction findAll(elems, selector) {\n  return elems.filter(selector).add(elems.find(selector))\n}\n\nfunction parseHTML(html) {\n  return $.parseHTML(html, document, true)\n}\n\n// Internal: Extracts container and metadata from response.\n//\n// 1. Extracts X-PJAX-URL header if set\n// 2. Extracts inline <title> tags\n// 3. Builds response Element and extracts fragment if set\n//\n// data    - String response data\n// xhr     - XHR response\n// options - pjax options Object\n//\n// Returns an Object with url, title, and contents keys.\nfunction extractContainer(data, xhr, options) {\n  var obj = {}, fullDocument = /<html/i.test(data)\n\n  // Prefer X-PJAX-URL header if it was set, otherwise fallback to\n  // using the original requested url.\n  var serverUrl = xhr.getResponseHeader('X-PJAX-URL')\n  obj.url = serverUrl ? stripInternalParams(parseURL(serverUrl)) : options.requestUrl\n\n  var $head, $body\n  // Attempt to parse response html into elements\n  if (fullDocument) {\n    $body = $(parseHTML(data.match(/<body[^>]*>([\\s\\S.]*)<\\/body>/i)[0]))\n    var head = data.match(/<head[^>]*>([\\s\\S.]*)<\\/head>/i)\n    $head = head != null ? $(parseHTML(head[0])) : $body\n  } else {\n    $head = $body = $(parseHTML(data))\n  }\n\n  // If response data is empty, return fast\n  if ($body.length === 0)\n    return obj\n\n  // If there's a <title> tag in the header, use it as\n  // the page's title.\n  obj.title = findAll($head, 'title').last().text()\n\n  if (options.fragment) {\n    var $fragment = $body\n    // If they specified a fragment, look for it in the response\n    // and pull it out.\n    if (options.fragment !== 'body') {\n      $fragment = findAll($fragment, options.fragment).first()\n    }\n\n    if ($fragment.length) {\n      obj.contents = options.fragment === 'body' ? $fragment : $fragment.contents()\n\n      // If there's no title, look for data-title and title attributes\n      // on the fragment\n      if (!obj.title)\n        obj.title = $fragment.attr('title') || $fragment.data('title')\n    }\n\n  } else if (!fullDocument) {\n    obj.contents = $body\n  }\n\n  // Clean up any <title> tags\n  if (obj.contents) {\n    // Remove any parent title elements\n    obj.contents = obj.contents.not(function() { return $(this).is('title') })\n\n    // Then scrub any titles from their descendants\n    obj.contents.find('title').remove()\n\n    // Gather all script[src] elements\n    obj.scripts = findAll(obj.contents, 'script[src]').remove()\n    obj.contents = obj.contents.not(obj.scripts)\n  }\n\n  // Trim any whitespace off the title\n  if (obj.title) obj.title = $.trim(obj.title)\n\n  return obj\n}\n\n// Load an execute scripts using standard script request.\n//\n// Avoids jQuery's traditional $.getScript which does a XHR request and\n// globalEval.\n//\n// scripts - jQuery object of script Elements\n//\n// Returns nothing.\nfunction executeScriptTags(scripts) {\n  if (!scripts) return\n\n  var existingScripts = $('script[src]')\n\n  scripts.each(function() {\n    var src = this.src\n    var matchedScripts = existingScripts.filter(function() {\n      return this.src === src\n    })\n    if (matchedScripts.length) return\n\n    var script = document.createElement('script')\n    var type = $(this).attr('type')\n    if (type) script.type = type\n    script.src = $(this).attr('src')\n    document.head.appendChild(script)\n  })\n}\n\n// Internal: History DOM caching class.\nvar cacheMapping      = {}\nvar cacheForwardStack = []\nvar cacheBackStack    = []\n\n// Push previous state id and container contents into the history\n// cache. Should be called in conjunction with `pushState` to save the\n// previous container contents.\n//\n// id    - State ID Number\n// value - DOM Element to cache\n//\n// Returns nothing.\nfunction cachePush(id, value) {\n  cacheMapping[id] = value\n  cacheBackStack.push(id)\n\n  // Remove all entries in forward history stack after pushing a new page.\n  trimCacheStack(cacheForwardStack, 0)\n\n  // Trim back history stack to max cache length.\n  trimCacheStack(cacheBackStack, pjax.defaults.maxCacheLength)\n}\n\n// Shifts cache from directional history cache. Should be\n// called on `popstate` with the previous state id and container\n// contents.\n//\n// direction - \"forward\" or \"back\" String\n// id        - State ID Number\n// value     - DOM Element to cache\n//\n// Returns nothing.\nfunction cachePop(direction, id, value) {\n  var pushStack, popStack\n  cacheMapping[id] = value\n\n  if (direction === 'forward') {\n    pushStack = cacheBackStack\n    popStack  = cacheForwardStack\n  } else {\n    pushStack = cacheForwardStack\n    popStack  = cacheBackStack\n  }\n\n  pushStack.push(id)\n  id = popStack.pop()\n  if (id) delete cacheMapping[id]\n\n  // Trim whichever stack we just pushed to to max cache length.\n  trimCacheStack(pushStack, pjax.defaults.maxCacheLength)\n}\n\n// Trim a cache stack (either cacheBackStack or cacheForwardStack) to be no\n// longer than the specified length, deleting cached DOM elements as necessary.\n//\n// stack  - Array of state IDs\n// length - Maximum length to trim to\n//\n// Returns nothing.\nfunction trimCacheStack(stack, length) {\n  while (stack.length > length)\n    delete cacheMapping[stack.shift()]\n}\n\n// Public: Find version identifier for the initial page load.\n//\n// Returns String version or undefined.\nfunction findVersion() {\n  return $('meta').filter(function() {\n    var name = $(this).attr('http-equiv')\n    return name && name.toUpperCase() === 'X-PJAX-VERSION'\n  }).attr('content')\n}\n\n// Install pjax functions on $.pjax to enable pushState behavior.\n//\n// Does nothing if already enabled.\n//\n// Examples\n//\n//     $.pjax.enable()\n//\n// Returns nothing.\nfunction enable() {\n  $.fn.pjax = fnPjax\n  $.pjax = pjax\n  $.pjax.enable = $.noop\n  $.pjax.disable = disable\n  $.pjax.click = handleClick\n  $.pjax.submit = handleSubmit\n  $.pjax.reload = pjaxReload\n  $.pjax.defaults = {\n    timeout: 650,\n    push: true,\n    replace: false,\n    type: 'GET',\n    dataType: 'html',\n    scrollTo: 0,\n    maxCacheLength: 20,\n    version: findVersion\n  }\n  $(window).on('popstate.pjax', onPjaxPopstate)\n}\n\n// Disable pushState behavior.\n//\n// This is the case when a browser doesn't support pushState. It is\n// sometimes useful to disable pushState for debugging on a modern\n// browser.\n//\n// Examples\n//\n//     $.pjax.disable()\n//\n// Returns nothing.\nfunction disable() {\n  $.fn.pjax = function() { return this }\n  $.pjax = fallbackPjax\n  $.pjax.enable = enable\n  $.pjax.disable = $.noop\n  $.pjax.click = $.noop\n  $.pjax.submit = $.noop\n  $.pjax.reload = function() { window.location.reload() }\n\n  $(window).off('popstate.pjax', onPjaxPopstate)\n}\n\n\n// Add the state property to jQuery's event object so we can use it in\n// $(window).bind('popstate')\nif ($.event.props && $.inArray('state', $.event.props) < 0) {\n  $.event.props.push('state')\n} else if (!('state' in $.Event.prototype)) {\n  $.event.addProp('state')\n}\n\n// Is pjax supported by this browser?\n$.support.pjax =\n  window.history && window.history.pushState && window.history.replaceState &&\n  // pushState isn't reliable on iOS until 5.\n  !navigator.userAgent.match(/((iPod|iPhone|iPad).+\\bOS\\s+[1-4]\\D|WebApps\\/.+CFNetwork)/)\n\nif ($.support.pjax) {\n  enable()\n} else {\n  disable()\n}\n\n})(jQuery)\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.3486328125,
          "content": "{\n  \"name\": \"jquery-pjax\",\n  \"description\": \"jQuery plugin for ajax + pushState navigation\",\n  \"version\": \"2.0.1\",\n  \"main\": \"jquery.pjax.js\",\n  \"repository\": \"defunkt/jquery-pjax\",\n  \"license\": \"MIT\",\n  \"files\": [\n    \"LICENSE\",\n    \"jquery.pjax.js\"\n  ],\n  \"devDependencies\": {\n    \"eslint\": \"^3.19.0\"\n  },\n  \"scripts\": {\n    \"test\": \"./script/test\"\n  }\n}\n"
        },
        {
          "name": "script",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}