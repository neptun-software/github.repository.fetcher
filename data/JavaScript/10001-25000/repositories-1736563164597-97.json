{
  "metadata": {
    "timestamp": 1736563164597,
    "page": 97,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jorgebucaran/hyperapp",
      "stars": 19096,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0712890625,
          "content": "*.html\n*.map\n*.br\n*.gz\n\npackage-lock.json\nnode_modules\ncoverage\nprivate\n\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0546875,
          "content": "Copyright © Jorge Bucaran <<https://jorgebucaran.com>>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.451171875,
          "content": "# Hyperapp\n\n> The tiny framework for building hypertext applications.\n\n- **Do more with less**—We have minimized the concepts you need to learn to get stuff done. Views, actions, effects, and subscriptions are all pretty easy to get to grips with and work together seamlessly.\n- **Write what, not how**—With a declarative API that's easy to read and fun to write, Hyperapp is the best way to build purely functional, feature-rich, browser-based apps using idiomatic JavaScript.\n- **Smaller than a favicon**—1 kB, give or take. Hyperapp is an ultra-lightweight Virtual DOM, [highly-optimized diff algorithm](https://javascript.plainenglish.io/javascript-frameworks-performance-comparison-2020-cd881ac21fce), and state management library obsessed with minimalism.\n\nHere's the first example to get you started. [Try it here](https://codepen.io/jorgebucaran/pen/zNxZLP?editors=1000)—no build step required!\n\n<!-- prettier-ignore -->\n```html\n<script type=\"module\">\n  import { h, text, app } from \"https://unpkg.com/hyperapp\"\n\n  const AddTodo = (state) => ({\n    ...state,\n    value: \"\",\n    todos: state.todos.concat(state.value),\n  })\n\n  const NewValue = (state, event) => ({\n    ...state,\n    value: event.target.value,\n  })\n\n  app({\n    init: { todos: [], value: \"\" },\n    view: ({ todos, value }) =>\n      h(\"main\", {}, [\n        h(\"h1\", {}, text(\"To do list\")),\n        h(\"input\", { type: \"text\", oninput: NewValue, value }),\n        h(\"ul\", {},\n          todos.map((todo) => h(\"li\", {}, text(todo)))\n        ),\n        h(\"button\", { onclick: AddTodo }, text(\"New!\")),\n      ]),\n    node: document.getElementById(\"app\"),\n  })\n</script>\n\n<main id=\"app\"></main>\n```\n\n[Check out more examples](https://codepen.io/collection/nLLvrz?grid_type=grid)\n\nThe app starts by setting the initial state and rendering the view on the page. User input flows into actions, whose function is to update the state, causing Hyperapp to re-render the view.\n\nWhen describing how a page looks in Hyperapp, we don't write markup. Instead, we use `h()` and `text()` to create a lightweight representation of the DOM (or virtual DOM for short), and Hyperapp takes care of updating the real DOM efficiently.\n\n## Installation\n\n```console\nnpm install hyperapp\n```\n\n## Documentation\n\nLearn the basics in the [Tutorial](docs/tutorial.md), check out the [Examples](https://codepen.io/collection/nLLvrz?grid_type=grid), or visit the [Reference](docs/reference.md).\n\n## Packages\n\nOfficial packages provide access to [Web Platform](https://platform.html5.org) APIs in a way that makes sense for Hyperapp. For third-party packages and real-world examples, browse the [Hyperawesome](https://github.com/jorgebucaran/hyperawesome) collection.\n\n| Package                                        | Status                                                                                                                                              | About                                                                                                     |\n| ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |\n| [`@hyperapp/dom`](/packages/dom)               | [![npm](https://img.shields.io/npm/v/@hyperapp/dom.svg?style=for-the-badge&color=0366d6&label=)](https://www.npmjs.com/package/@hyperapp/dom)       | Inspect the DOM, focus and blur.                                                                          |\n| [`@hyperapp/svg`](/packages/svg)               | [![npm](https://img.shields.io/npm/v/@hyperapp/svg.svg?style=for-the-badge&color=0366d6&label=)](https://www.npmjs.com/package/@hyperapp/svg)       | Draw SVG with plain functions.                                                                            |\n| [`@hyperapp/html`](/packages/html)             | [![npm](https://img.shields.io/npm/v/@hyperapp/html.svg?style=for-the-badge&color=0366d6&label=)](https://www.npmjs.com/package/@hyperapp/html)     | Write HTML with plain functions.                                                                          |\n| [`@hyperapp/time`](/packages/time)             | [![npm](https://img.shields.io/npm/v/@hyperapp/time.svg?style=for-the-badge&color=0366d6&label=)](https://www.npmjs.com/package/@hyperapp/time)     | Subscribe to intervals, get the time now.                                                                 |\n| [`@hyperapp/events`](/packages/events)         | [![npm](https://img.shields.io/npm/v/@hyperapp/events.svg?style=for-the-badge&color=0366d6&label=)](https://www.npmjs.com/package/@hyperapp/events) | Subscribe to mouse, keyboard, window, and frame events.                                                   |\n| [`@hyperapp/http`](/packages/http)             | [![npm](https://img.shields.io/badge/-planned-6a737d?style=for-the-badge&label=)](https://www.npmjs.com/package/@hyperapp/http)                     | Talk to servers, make HTTP requests ([#1027](https://github.com/jorgebucaran/hyperapp/discussions/1027)). |\n| [`@hyperapp/random`](/packages/random)         | [![npm](https://img.shields.io/badge/-planned-6a737d?style=for-the-badge&label=)](https://www.npmjs.com/package/@hyperapp/random)                   | Declarative random numbers and values.                                                                    |\n| [`@hyperapp/navigation`](/packages/navigation) | [![npm](https://img.shields.io/badge/-planned-6a737d?style=for-the-badge&label=)](https://www.npmjs.com/package/@hyperapp/navigation)               | Subscribe and manage the browser URL history.                                                             |\n\n> Need to create your own effects and subscriptions? [You can do that too](docs/reference.md).\n\n## Help, I'm stuck!\n\nIf you've hit a stumbling block, hop on our [Discord](https://discord.gg/eFvZXzXF9U) server to get help, and if you remain stuck, [please file an issue](https://github.com/jorgebucaran/hyperapp/issues/new), and we'll help you figure it out.\n\n## Contributing\n\nHyperapp is free and open-source software. If you want to support Hyperapp, becoming a contributor or [sponsoring](https://github.com/sponsors/jorgebucaran) is the best way to give back. Thank you to everyone who already contributed to Hyperapp! <3\n\n[![](https://opencollective.com/hyperapp/contributors.svg?width=1024&button=false)](https://github.com/jorgebucaran/hyperapp/graphs/contributors)\n\n## License\n\n[MIT](LICENSE.md)\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.d.ts",
          "type": "blob",
          "size": 8.1962890625,
          "content": "// Minimum TypeScript Version: 4.2\n\n// This requires every property of an object or none at all.\ntype AllOrNothing<T> = T | { [K in keyof T]?: never }\n\n// This ensures at least one property in an object is present.\ntype AtLeastOne<T> = { [K in keyof T]: Pick<T, K> }[keyof T]\n// Credit: https://stackoverflow.com/a/59987826/1935675\n\n// This ensures at least one object property group is present.\ntype AtLeastSomething<T, U> = U | AtLeastOne<T> & AllOrNothing<U>\n\n// Most event typings are provided by TypeScript itself.\ntype EventsMap =\n  & { [K in keyof HTMLElementEventMap as `on${K}`]: HTMLElementEventMap[K] }\n  & { [K in keyof WindowEventMap as `on${K}`]: WindowEventMap[K] }\n  & { onsearch: Event }\n\n// Indexable values are able to use subscripting.\ntype Indexable = string | unknown[] | Record<string, any>\n\n// This validates plain objects while invalidating array objects and string\n// objects by disallowing numerical indexing.\ntype IndexableByKey = Record<number, never>\n\n// Empty strings can cause issues in certain places.\ntype NonEmptyString<T> = T extends \"\" ? never : T\n\n// -----------------------------------------------------------------------------\n\ndeclare module \"hyperapp\" {\n  // `app()` initiates a Hyperapp instance. Only `app()`'s `node:` property and\n  // effecters and subscribers are allowed to have side effects.\n  function app<S>(props: App<S>): Dispatch<S>\n\n  // `h()` builds a virtual DOM node.\n  function h<S, C = unknown, T extends string = string>(\n    tag: NonEmptyString<T>,\n    props: CustomPayloads<S, C> & Props<S>,\n    children?: MaybeVNode<S> | readonly MaybeVNode<S>[]\n  ): ElementVNode<S>\n\n  // `memo()` stores a view along with any given data for it.\n  function memo<S, D extends Indexable = Indexable>(\n    view: (data: D) => VNode<S>,\n    data: D\n  ): VNode<S>\n\n  // `text()` creates a virtual DOM node representing plain text.\n  function text<T = unknown>(\n    // Values, aside from symbols and functions, can be handled.\n    value: T extends symbol | ((..._: unknown[]) => unknown) ? never : T\n  ): TextVNode\n\n  // ---------------------------------------------------------------------------\n\n  // This lets you make a variant of `h()` which is aware of your Hyperapp\n  // instance's state. The `_ extends never` ensures that any state-aware\n  // `h()` doesn't have an explicit state type that contradicts the\n  // state type it actually uses.\n  interface TypedH<S> {\n    <_ extends never, C = unknown, T extends string = string>(\n      tag: NonEmptyString<T>,\n      props: CustomPayloads<S, C> & Props<S>,\n      children?: MaybeVNode<S> | readonly MaybeVNode<S>[]\n    ): ElementVNode<S>\n  }\n\n  // ---------------------------------------------------------------------------\n\n  // An action transforms existing state and/or wraps another action.\n  type Action<S, P = any> = (state: S, payload: P) => Dispatchable<S>\n\n  // A Hyperapp instance typically has an initial state and a top-level view\n  // mounted over an available DOM element.\n  type App<S> =\n    Readonly<AtLeastSomething<{\n      // State is established through either direct assignment or an action.\n      init: Dispatchable<S>\n\n      // The subscriptions function manages a set of subscriptions.\n      subscriptions: (state: S) =>\n        readonly (boolean | undefined | Subscription<S>)[]\n\n      // Dispatching can be augmented to do custom processing.\n      dispatch: (dispatch: Dispatch<S>) => Dispatch<S>\n    }, {\n      // The top-level view can build a virtual DOM node depending on the state.\n      view: (state: S) => VNode<S>\n\n      // The mount node is where a Hyperapp instance will get placed.\n      node: Node\n    }>>\n\n  // The `class` property represents an HTML class attribute string.\n  type ClassProp =\n    | boolean\n    | string\n    | undefined\n    | Record<string, boolean | undefined>\n    | ClassProp[]\n\n  // This lets event-handling actions properly accept custom payloads.\n  type CustomPayloads<S, T> = {\n    [K in keyof T]?:\n      K extends \"style\"\n      ? StyleProp\n      : T[K] extends [action: Action<S, infer P>, payload: unknown]\n      ? readonly [action: Action<S, P>, payload: P]\n      : T[K]\n  }\n\n  // Dispatching will cause state transitions.\n  type Dispatch<S> = (dispatchable: Dispatchable<S>, payload?: unknown) => void\n\n  // A dispatchable entity is used to cause a state transition.\n  type Dispatchable<S, P = any> =\n    | S\n    | [state: S, ...effects: MaybeEffect<S, P>[]]\n    | Action<S, P>\n    | readonly [action: Action<S, P>, payload: P]\n\n  // An effecter is the function that runs an effect.\n  type Effecter<S, P = any> = (\n    dispatch: Dispatch<S>,\n    payload: P\n  ) => void | Promise<void>\n\n  // An effect is where side effects and any additional dispatching may occur.\n  type Effect<S, P = any> =\n    | Effecter<S, P>\n    | readonly [effecter: Effecter<S, P>, payload: P]\n\n  \n  // Effects can be declared conditionally.\n  type MaybeEffect<S, P> = null | undefined | boolean | \"\" | 0 | Effect<S, P>\n\n\n  // Event handlers are implemented using actions.\n  type EventActions<S> = {\n    [K in keyof EventsMap]:\n      | Action<S, EventsMap[K]>\n      | readonly [action: Action<S>, payload: unknown]\n  }\n\n  // In certain places a virtual DOM node can be made optional.\n  type MaybeVNode<S> = boolean | null | undefined | VNode<S>\n\n  // Virtual DOM properties will often correspond to HTML attributes.\n  type Props<S> =\n    Readonly<\n      Partial<\n        Omit<HTMLElement, keyof (\n          DocumentAndElementEventHandlers &\n          ElementCSSInlineStyle &\n          GlobalEventHandlers\n        )> &\n        ElementCreationOptions &\n        EventActions<S>\n      > &\n      {\n        [_: string]: unknown\n        class?: ClassProp\n        key?: VNode<S>[\"key\"]\n        style?: StyleProp\n\n        // By disallowing `_VNode` we ensure values having the `VNode` type are\n        // not mistaken for also having the `Props` type.\n        _VNode?: never\n      }\n    >\n\n  // The `style` property represents inline CSS. This relies on TypeScript's CSS\n  // property definitions. Custom properties aren't covered as well as any newer\n  // properties yet to be recognized by TypeScript. The only way to accommodate\n  // them is to relax the adherence to TypeScript's CSS property definitions.\n  // It's a poor trade-off given the likelihood of using such properties.\n  // However, you can use type casting if you want to use them.\n  type StyleProp = IndexableByKey & {\n    [K in keyof CSSStyleDeclaration]?: CSSStyleDeclaration[K] | null\n  }\n\n  // A subscription reacts to external activity.\n  type Subscription<S, P = any> = readonly [\n    subscriber: (dispatch: Dispatch<S>, payload: P) => Unsubscribe,\n    payload: P\n  ]\n\n  // An unsubscribe function cleans up a canceled subscription.\n  type Unsubscribe = () => void\n\n  // A virtual DOM node (a.k.a. VNode) represents an actual DOM element.\n  type ElementVNode<S> = {\n    readonly props: Props<S>\n    readonly children: readonly MaybeVNode<S>[]\n    node: null | undefined | Node\n\n    // Hyperapp takes care of using native Web platform event handlers for us.\n    events?:\n      Record<\n        string,\n        Action<S> | readonly [action: Action<S>, payload: unknown]\n      >\n\n    // A key can uniquely associate a VNode with a certain DOM element.\n    readonly key: string | null | undefined\n\n    // A VNode's tag is either an element name or a memoized view function.\n    readonly tag: string | ((data: Indexable) => VNode<S>)\n\n    // If the VNode's tag is a function then this data will get passed to it.\n    memo?: Indexable\n\n    // VNode types are based on actual DOM node types:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n    readonly type: 1\n\n    // `_VNode` is a phantom guard property which gives us a way to tell `VNode`\n    // objects apart from `Props` objects. Since we don't expect users to make\n    // their own VNodes manually, we can take advantage of this trick which\n    // is unique to TypeScript type definitions for JavaScript code.\n    _VNode: true\n  }\n\n  // Certain VNodes specifically represent Text nodes and don't rely on state.\n  type TextVNode = {\n    readonly props: {}\n    readonly children: []\n    node: null | undefined | Node\n    readonly key: undefined\n    readonly tag: string\n    readonly type: 3\n    _VNode: true\n  }\n  \n  // VNodes may represent either Text or Element nodes.\n  type VNode<S> = ElementVNode<S> | TextVNode\n}\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 9.9423828125,
          "content": "var SSR_NODE = 1\nvar TEXT_NODE = 3\nvar EMPTY_OBJ = {}\nvar EMPTY_ARR = []\nvar SVG_NS = \"http://www.w3.org/2000/svg\"\n\nvar id = (a) => a\nvar map = EMPTY_ARR.map\nvar isArray = Array.isArray\n\nvar createClass = (obj) => {\n  var out = \"\"\n\n  if (typeof obj === \"string\") return obj\n\n  if (isArray(obj)) {\n    for (var k = 0, tmp; k < obj.length; k++) {\n      if ((tmp = createClass(obj[k]))) {\n        out += (out && \" \") + tmp\n      }\n    }\n  } else {\n    for (var k in obj) {\n      if (obj[k]) out += (out && \" \") + k\n    }\n  }\n\n  return out\n}\n\nvar shouldRestart = (a, b) => {\n  for (var k in { ...a, ...b }) {\n    if (typeof (isArray(a[k]) ? a[k][0] : a[k]) === \"function\") {\n      b[k] = a[k]\n    } else if (a[k] !== b[k]) return true\n  }\n}\n\nvar patchSubs = (oldSubs, newSubs = EMPTY_ARR, dispatch) => {\n  for (\n    var subs = [], i = 0, oldSub, newSub;\n    i < oldSubs.length || i < newSubs.length;\n    i++\n  ) {\n    oldSub = oldSubs[i]\n    newSub = newSubs[i]\n\n    subs.push(\n      newSub && newSub !== true\n        ? !oldSub ||\n          newSub[0] !== oldSub[0] ||\n          shouldRestart(newSub[1], oldSub[1])\n          ? [\n              newSub[0],\n              newSub[1],\n              (oldSub && oldSub[2](), newSub[0](dispatch, newSub[1])),\n            ]\n          : oldSub\n        : oldSub && oldSub[2]()\n    )\n  }\n  return subs\n}\n\nvar getKey = (vdom) => (vdom == null ? vdom : vdom.key)\n\nvar patchProperty = (node, key, oldValue, newValue, listener, isSvg) => {\n  if (key === \"style\") {\n    for (var k in { ...oldValue, ...newValue }) {\n      oldValue = newValue == null || newValue[k] == null ? \"\" : newValue[k]\n      if (k[0] === \"-\") {\n        node[key].setProperty(k, oldValue)\n      } else {\n        node[key][k] = oldValue\n      }\n    }\n  } else if (key[0] === \"o\" && key[1] === \"n\") {\n    if (\n      !((node.events || (node.events = {}))[(key = key.slice(2))] = newValue)\n    ) {\n      node.removeEventListener(key, listener)\n    } else if (!oldValue) {\n      node.addEventListener(key, listener)\n    }\n  } else if (!isSvg && key !== \"list\" && key !== \"form\" && key in node) {\n    node[key] = newValue == null ? \"\" : newValue\n  } else if (newValue == null || newValue === false) {\n    node.removeAttribute(key)\n  } else {\n    node.setAttribute(key, newValue)\n  }\n}\n\nvar createNode = (vdom, listener, isSvg) => {\n  var props = vdom.props\n  var node =\n    vdom.type === TEXT_NODE\n      ? document.createTextNode(vdom.tag)\n      : (isSvg = isSvg || vdom.tag === \"svg\")\n      ? document.createElementNS(SVG_NS, vdom.tag, props.is && props)\n      : document.createElement(vdom.tag, props.is && props)\n\n  for (var k in props) {\n    patchProperty(node, k, null, props[k], listener, isSvg)\n  }\n\n  for (var i = 0; i < vdom.children.length; i++) {\n    node.appendChild(\n      createNode(\n        (vdom.children[i] = maybeVNode(vdom.children[i])),\n        listener,\n        isSvg\n      )\n    )\n  }\n\n  return (vdom.node = node)\n}\n\nvar patch = (parent, node, oldVNode, newVNode, listener, isSvg) => {\n  if (oldVNode === newVNode) {\n  } else if (\n    oldVNode != null &&\n    oldVNode.type === TEXT_NODE &&\n    newVNode.type === TEXT_NODE\n  ) {\n    if (oldVNode.tag !== newVNode.tag) node.nodeValue = newVNode.tag\n  } else if (oldVNode == null || oldVNode.tag !== newVNode.tag) {\n    node = parent.insertBefore(\n      createNode((newVNode = maybeVNode(newVNode)), listener, isSvg),\n      node\n    )\n    if (oldVNode != null) {\n      parent.removeChild(oldVNode.node)\n    }\n  } else {\n    var tmpVKid\n    var oldVKid\n\n    var oldKey\n    var newKey\n\n    var oldProps = oldVNode.props\n    var newProps = newVNode.props\n\n    var oldVKids = oldVNode.children\n    var newVKids = newVNode.children\n\n    var oldHead = 0\n    var newHead = 0\n    var oldTail = oldVKids.length - 1\n    var newTail = newVKids.length - 1\n\n    isSvg = isSvg || newVNode.tag === \"svg\"\n\n    for (var i in { ...oldProps, ...newProps }) {\n      if (\n        (i === \"value\" || i === \"selected\" || i === \"checked\"\n          ? node[i]\n          : oldProps[i]) !== newProps[i]\n      ) {\n        patchProperty(node, i, oldProps[i], newProps[i], listener, isSvg)\n      }\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldHead])) == null ||\n        oldKey !== getKey(newVKids[newHead])\n      ) {\n        break\n      }\n\n      patch(\n        node,\n        oldVKids[oldHead].node,\n        oldVKids[oldHead],\n        (newVKids[newHead] = maybeVNode(\n          newVKids[newHead++],\n          oldVKids[oldHead++]\n        )),\n        listener,\n        isSvg\n      )\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldTail])) == null ||\n        oldKey !== getKey(newVKids[newTail])\n      ) {\n        break\n      }\n\n      patch(\n        node,\n        oldVKids[oldTail].node,\n        oldVKids[oldTail],\n        (newVKids[newTail] = maybeVNode(\n          newVKids[newTail--],\n          oldVKids[oldTail--]\n        )),\n        listener,\n        isSvg\n      )\n    }\n\n    if (oldHead > oldTail) {\n      while (newHead <= newTail) {\n        node.insertBefore(\n          createNode(\n            (newVKids[newHead] = maybeVNode(newVKids[newHead++])),\n            listener,\n            isSvg\n          ),\n          (oldVKid = oldVKids[oldHead]) && oldVKid.node\n        )\n      }\n    } else if (newHead > newTail) {\n      while (oldHead <= oldTail) {\n        node.removeChild(oldVKids[oldHead++].node)\n      }\n    } else {\n      for (var keyed = {}, newKeyed = {}, i = oldHead; i <= oldTail; i++) {\n        if ((oldKey = oldVKids[i].key) != null) {\n          keyed[oldKey] = oldVKids[i]\n        }\n      }\n\n      while (newHead <= newTail) {\n        oldKey = getKey((oldVKid = oldVKids[oldHead]))\n        newKey = getKey(\n          (newVKids[newHead] = maybeVNode(newVKids[newHead], oldVKid))\n        )\n\n        if (\n          newKeyed[oldKey] ||\n          (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))\n        ) {\n          if (oldKey == null) {\n            node.removeChild(oldVKid.node)\n          }\n          oldHead++\n          continue\n        }\n\n        if (newKey == null || oldVNode.type === SSR_NODE) {\n          if (oldKey == null) {\n            patch(\n              node,\n              oldVKid && oldVKid.node,\n              oldVKid,\n              newVKids[newHead],\n              listener,\n              isSvg\n            )\n            newHead++\n          }\n          oldHead++\n        } else {\n          if (oldKey === newKey) {\n            patch(\n              node,\n              oldVKid.node,\n              oldVKid,\n              newVKids[newHead],\n              listener,\n              isSvg\n            )\n            newKeyed[newKey] = true\n            oldHead++\n          } else {\n            if ((tmpVKid = keyed[newKey]) != null) {\n              patch(\n                node,\n                node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),\n                tmpVKid,\n                newVKids[newHead],\n                listener,\n                isSvg\n              )\n              newKeyed[newKey] = true\n            } else {\n              patch(\n                node,\n                oldVKid && oldVKid.node,\n                null,\n                newVKids[newHead],\n                listener,\n                isSvg\n              )\n            }\n          }\n          newHead++\n        }\n      }\n\n      while (oldHead <= oldTail) {\n        if (getKey((oldVKid = oldVKids[oldHead++])) == null) {\n          node.removeChild(oldVKid.node)\n        }\n      }\n\n      for (var i in keyed) {\n        if (newKeyed[i] == null) {\n          node.removeChild(keyed[i].node)\n        }\n      }\n    }\n  }\n\n  return (newVNode.node = node)\n}\n\nvar propsChanged = (a, b) => {\n  for (var k in a) if (a[k] !== b[k]) return true\n  for (var k in b) if (a[k] !== b[k]) return true\n}\n\nvar maybeVNode = (newVNode, oldVNode) =>\n  newVNode !== true && newVNode !== false && newVNode\n    ? typeof newVNode.tag === \"function\"\n      ? ((!oldVNode ||\n          oldVNode.memo == null ||\n          propsChanged(oldVNode.memo, newVNode.memo)) &&\n          ((oldVNode = newVNode.tag(newVNode.memo)).memo = newVNode.memo),\n        oldVNode)\n      : newVNode\n    : text(\"\")\n\nvar recycleNode = (node) =>\n  node.nodeType === TEXT_NODE\n    ? text(node.nodeValue, node)\n    : createVNode(\n        node.nodeName.toLowerCase(),\n        EMPTY_OBJ,\n        map.call(node.childNodes, recycleNode),\n        SSR_NODE,\n        node\n      )\n\nvar createVNode = (tag, { key, ...props }, children, type, node) => ({\n  tag,\n  props,\n  key,\n  children,\n  type,\n  node,\n})\n\nexport var memo = (tag, memo) => ({ tag, memo })\n\nexport var text = (value, node) =>\n  createVNode(value, EMPTY_OBJ, EMPTY_ARR, TEXT_NODE, node)\n\nexport var h = (tag, { class: c, ...props }, children = EMPTY_ARR) =>\n  createVNode(\n    tag,\n    { ...props, ...(c ? { class: createClass(c) } : EMPTY_OBJ) },\n    isArray(children) ? children : [children]\n  )\n\nexport var app = ({\n  node,\n  view,\n  subscriptions,\n  dispatch = id,\n  init = EMPTY_OBJ,\n}) => {\n  var vdom = node && recycleNode(node)\n  var subs = []\n  var state\n  var busy\n\n  var update = (newState) => {\n    if (state !== newState) {\n      if ((state = newState) == null) dispatch = subscriptions = render = id\n      if (subscriptions) subs = patchSubs(subs, subscriptions(state), dispatch)\n      if (view && !busy) requestAnimationFrame(render, (busy = true))\n    }\n  }\n\n  var render = () =>\n    (node = patch(\n      node.parentNode,\n      node,\n      vdom,\n      (vdom = view(state)),\n      listener,\n      (busy = false)\n    ))\n\n  var listener = function (event) {\n    dispatch(this.events[event.type], event)\n  }\n\n  return (\n    (dispatch = dispatch((action, props) =>\n      typeof action === \"function\"\n        ? dispatch(action(state, props))\n        : isArray(action)\n        ? typeof action[0] === \"function\"\n          ? dispatch(action[0], action[1])\n          : action\n              .slice(1)\n              .map(\n                (fx) => fx && fx !== true && (fx[0] || fx)(dispatch, fx[1]),\n                update(action[0])\n              )\n        : update(action)\n    ))(init),\n    dispatch\n  )\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.9365234375,
          "content": "{\n  \"name\": \"hyperapp\",\n  \"version\": \"2.0.22\",\n  \"type\": \"module\",\n  \"main\": \"index.js\",\n  \"types\": \"index.d.ts\",\n  \"description\": \"The tiny framework for building hypertext applications.\",\n  \"repository\": \"jorgebucaran/hyperapp\",\n  \"homepage\": \"https://hyperapp.dev\",\n  \"author\": \"Jorge Bucaran\",\n  \"license\": \"MIT\",\n  \"files\": [\n    \"*.[tj]s\"\n  ],\n  \"keywords\": [\n    \"framework\",\n    \"hyperapp\",\n    \"frontend\",\n    \"vdom\",\n    \"web\",\n    \"app\",\n    \"ui\"\n  ],\n  \"scripts\": {\n    \"test\": \"c8 twist tests/*.js\",\n    \"info\": \"node --print \\\"('$pkg' ? '@$npm_package_name/$pkg@' : '') + require('./${pkg:+packages/$pkg/}package').version\\\"\",\n    \"deploy\": \"npm test && git commit --all --message $tag && git tag --sign $tag --message $tag && git push && git push --tags\",\n    \"release\": \"tag=$(npm run --silent info) npm run deploy && cd ./${pkg:+packages/$pkg} && npm publish --access public\"\n  },\n  \"devDependencies\": {\n    \"twist\": \"*\",\n    \"c8\": \"*\"\n  }\n}\n"
        },
        {
          "name": "packages",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}