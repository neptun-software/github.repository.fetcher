{
  "metadata": {
    "timestamp": 1736563404376,
    "page": 416,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "reactide/reactide",
      "stars": 10530,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".eslintignore",
          "type": "blob",
          "size": 0.0205078125,
          "content": "public/\nnode_modules/"
        },
        {
          "name": ".eslintrc",
          "type": "blob",
          "size": 0.2978515625,
          "content": "{\n  \"extends\": [\n    \"airbnb\",\n    \"prettier\",\n    \"prettier/react\"\n  ],\n  \"plugins\": [\n    \"prettier\"\n  ],\n  \"parserOptions\": {\n    \"ecmaVersion\": 2016,\n    \"sourceType\": \"module\",\n    \"ecmaFeatures\": {\n      \"jsx\": true\n    }\n  },\n  \"env\": {\n    \"es6\": true,\n    \"browser\": true,\n    \"node\": true\n  }\n}\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.10546875,
          "content": "renderer/assets/* linguist-vendored\nlib/new-project-template/* linguist-\n*.jsx linguist-language=JavaScript\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.20703125,
          "content": "node_modules\ndist\n.DS_Store\nyarn-error.log\nyarn.lock\n!/lib/new-project-template/new-project/**\n/lib/new-project-template/new-project/.DS_Store\n/lib/new-project/**\n/lib/projInfo.js\npackage-lock.json\nrelease-builds"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.033203125,
          "content": "language: node_js\nnode_js:\n  - \"6\""
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0400390625,
          "content": "MIT License\n\nCopyright (c) 2017 reactide\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.896484375,
          "content": "<p align=\"center\"><a href='http://reactide.io/'><img alt=\"reactide\" src=\"https://i.imgur.com/HRNmuJs.png\" width=\"30%\"></a></p>\n\n[![GitHub license](https://img.shields.io/github/license/reactide/reactide)](https://github.com/reactide/reactide/blob/master/LICENSE.txt) [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/reactide/reactide/pulls)\n\n### Reactide is the first dedicated IDE for React web application development.\nReactide is a cross-platform desktop application that offers a simulator, made for live reloading and quick React component prototyping. React brings an integrated suite of development tools to streamline react development. The days of flipping between browser, IDE, and server are over.\n\n#### Reactide is in active development. Please follow this repo for contribution guidelines and our development road map.\n\n##\n<p align=\"center\">\n  <img alt=\"Reactide Screenshot\" src=\"https://i.imgur.com/A29J8fs.jpg\">\n\n</p>\n\n## Get right to coding\nReactide runs an integrated Node server and custom browser simulator. As projects evolve, the developer can continually track changes through live reloading directly in the development environment without the need for constant flipping to the browser. Reactide also offers integration with Create React App for faster project boilerplate configuration. The simulator and component tree are both functioning for all React applications.\n\n## State flow visualization.\nManaging state across a complex React application is the biggest pain point of developing React apps. Reactide offers a visual component tree that dynamically loads and changes based on components within the working directory while giving information about props and state at every component. By navigating through a live-representation of the architecture of a project, developers can quickly identify and pinpoint the parent-child relationships of even the most complex applications.\n\nThe component tree works out-of-the-box by finding the entry point to your React application that you provide inside the reactide.config.js file.\n\n## Integrated Terminal for powerful commands and workflows\nThe terminal is the life and blood of any IDE, allowing for complex manipulation of the file system, node, and even build-tools. Reactide offers a compatible terminal for running commands in bin/bash for Unix, and cmd for Windows to provide powerful workflows to even seasoned developers.\n\n## Getting Started with Reactide\nThe Reactide IDE can be set up in two ways, the first is to bundle the electron app and run it as a native desktop App. The instructions are as follows:\n\n1. go to your terminal and type the following:\n```\ngit checkout 3.0-release\nnpm install\nnpm run webpack-production\nnpm run electron-packager\n```\n2. in your Reactide folder, navigate to the release-builds folder and double-click on Reactide (executable).\n\n## To check out Reactide in developer mode follow these instructions:\n1. go to your terminal and type the following:\n```\ngit checkout 3.0-release\nnpm install\nnpm run webpack-production\nnpm start\n```\n\n## Setting up the Simulator\nIn order to take advantage of the live simulator, please follow the below steps in your project directory. \n\n1. Go to the reactide.config.js file and change the .html and .js entry points to the relative path of your respective files. \n2. In the terminal run: `npm run reactide-server`\n\nFor any questions, please look at the example project in the example folder for how to set-up webpack and dev-server.\n\n## Contributors\n[Jin Choi](https://github.com/jinihendrix) | [Mark Marcelo](https://github.com/markmarcelo) | [Bita Djaghouri](https://github.com/bitadj) | [Pablo Lee](https://github.com/pablytolee) | [Ryan Yang](https://github.com/ryany1819) | [Oscar Chan](https://github.com/chanoscar0) | [Juan Hart](https://github.com/juanhart1) | [Eric Pham](https://github.com/EP36) | [Khalid Umar](https://github.com/khalid050) | [Rocky Liao](https://github.com/seemsrocky)\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "icons",
          "type": "tree",
          "content": null
        },
        {
          "name": "importPath.js",
          "type": "blob",
          "size": 10.0009765625,
          "content": "\nconst fs = require('fs');\nconst path = require('path');\n//The Flow Parser is a JavaScript parser written in OCaml. It produces an AST that conforms to the ESTree spec and that mostly matches what esprima produces.\nconst flowParser = require('flow-parser');\n\n/**\n *  Iterates through AST Object and returns the entry point for the Class or Function Block;\n * @param {Object} obj AST JSON Object\n */\nfunction getClassEntry(obj) {\n  let entry = null;\n  // Start lookup if Program body has ClassDeclaration or inside ExportDefaultDeclaration has ClassDeclaration\n  for (let elem of obj.body) {\n    if (elem.type === 'ClassDeclaration') {\n      return entry = elem.body;\n    }\n    else if (elem.type === 'ExportDefaultDeclaration' && elem.declaration.type === 'ClassDeclaration') {\n      return entry = elem.declaration.body;\n    }\n  }\n  return entry;\n}\n/**\n *  grabs state of stateful Component if available;\n * @param {Object} obj AST object created from file at Class Block\n */\nfunction grabState(obj) {\n  let ret = [];\n  let entry = getClassEntry(obj);\n  if (entry) ret = digStateInClassBody(entry);\n  return ret;\n}\n/**\n * traverses through AST object and returns entry point for constructor Object;\n * @param {Object} obj - classBody object from AST \n */\nfunction digStateInClassBody(obj) {\n  if (obj.type !== 'ClassBody')\n    return;\n  let ret = [];\n  obj.body.forEach((elem) => {\n    if (elem.type = \"MethodDefinition\" && elem.key.name === \"constructor\") {\n      ret = digStateInBlockStatement(elem.value.body);\n    }\n  });\n  return ret;\n}\n\nfunction parseNestedObjects(stateValue, nested=false){\n  //check if the array is nested. Only use for arrays\n  const curr = nested ? stateValue : stateValue.value;\n  if(curr.type === 'ObjectExpression'){\n    //iterate through object properties and store them in values\n    let values = {}\n    for(let key in stateValue.value.properties){\n      values[key] = parseNestedObjects(stateValue.value.properties[key])\n    }\n    return values\n  }\n  else if(curr.type === 'ArrayExpression'){\n    let values = []\n    let currObj = curr.elements;\n    for(let key in currObj){\n      values.push(parseNestedObjects(currObj[key],true))\n    }\n    return values\n  }\n  else {\n    return curr.value;\n  }\n}\n/**\n * traverses through AST BlockStatement object and returns the state of Component;\n * @param {*} obj \n */\nfunction digStateInBlockStatement(obj) {\n  if (obj.type !== 'BlockStatement') return;\n  let ret = {};\n  obj.body.forEach((element) => {\n    if (element.type === \"ExpressionStatement\" && element.expression.type === \"AssignmentExpression\")\n      if (element.expression.left.property.name === 'state') {\n        if (element.expression.right.type === \"ObjectExpression\"){\n           element.expression.right.properties.forEach(elem => {\n            //  ret[elem.key.name] = elem.value.value;\n            ret[elem.key.name] = parseNestedObjects(elem)\n            // console.log('parseNestedObjects return value', parseNestedObjects(elem))\n          });\n        }\n      }\n  });\n  // console.log('return' ,ret)\n  return ret;\n }\n\n /**\n  *  parses through AST Object and returns an object of props \n  * @param {Array} arrOfAttr - Array of AST Object attributes\n  */\nfunction grabAttr(arrOfAttr) {\n  return arrOfAttr.reduce((acc, curr) => {\n    if (curr.value.type === 'JSXExpressionContainer') {\n      if (curr.value.expression.type === 'ArrowFunctionExpression' || curr.value.expression.type === 'FunctionExpression') {\n        if(curr.value.expression.body.body) {\n          acc[curr.name.name] = curr.value.expression.body.body[0].expression.callee.name\n        } else {\n          acc[curr.name.name] = curr.value.expression.body.callee.name\n        }\n      } else if (curr.value.expression.type === 'Literal') {\n          acc[curr.name.name] = curr.value.expression.value;\n      } else if (curr.value.expression.type === 'MemberExpression') {\n          acc[curr.name.name] = curr.value.expression.property.name;\n      } else if (curr.value.expression.type === 'ConditionalExpression') {\n        let condition, consequent, alternate;\n          if(curr.value.expression.test.type === 'MemberExpression') {\n            condition = curr.value.expression.test.property.name;\n          } else{\n            condition = curr.value.expression.test.name;\n          }\n          if(curr.value.expression.consequent.type === 'MemberExpression') {\n            consequent = curr.value.expression.consequent.property.name;\n          } else {\n            consequent = curr.value.expression.consequent.name;\n          }\n          if(curr.value.expression.alternate.type === 'MemberExpression') {\n            alternate = curr.value.expression.alternate.property.name;\n          } else{\n            alternate = curr.value.expression.consequent.name;\n          }\n          acc[curr.name.name + 'True'] = {condition: condition, value:consequent};\n\n          acc[curr.name.name + 'False'] = {condition: condition, value: alternate}\n      } else {\n          acc[curr.name.name] = curr.value.expression.name;\n      }\n    } else {\n      acc[curr.name.name] = curr.value.value;\n    }\n    return acc;\n  },{})\n};\n/**\n * returns an Array of Objects with the name and path of IMPORT objects\n * @param {Object} json- AST Object\n */\nfunction grabImportNameAndPath(json) {\n  let output;\n  //inputted AST has a property named body that is an array of objects\n  //importObjectArr is filtered\n  const importObjectArr = json.body.filter((importObj) => {\n    //whatever importObjs have a 'type' value of 'ImportDeclaration' are what are returned\n    if (importObj.type === 'ImportDeclaration') {\n      return {\n        importObj\n      }\n    }\n  })\n  //importObjectArr is mappped over and if the importObj.specifiers[0] is true/truthy, a new object is returned\n  // console.log(importObjectArr, 'XXX');\n  output = importObjectArr.map((importObj) => {\n    if (importObj.specifiers[0]) {\n      return {\n        name: importObj.specifiers[0].local.name,\n        path: importObj.source.value,\n      }\n    }\n  })\n  // output is reassigned to the array returned by filtering anything that isn't true/truthy\n  // console.log(output, '***');\n  output = output.filter((obj) => {\n    if (obj) {\n      return obj;\n    }\n  })\n  // console.log(output, 'SSS');\n  //an array of imported objects is returned\n  return output;\n}\n/**\n *  returns an Object with Component name and props from AST Object;\n * @param {Object} returnObj - AST object  \n */\nconst constructComponentProps = (returnObj) => {\n  const output = {};\n  output[returnObj.openingElement.name.name] = grabAttr(returnObj.openingElement.attributes)\n  return output;\n}\n/**\n *  returns Object with name and props of current Component;\n * @param {String} jsxPath - Path of file to convert into a AST object\n */\nfunction constructSingleLevel(jsxPath) {\n  let reactObj = {};\n  // fileContent stores the file at the jsxPath\n  const fileContent = fs.readFileSync(jsxPath, { encoding: 'utf-8' });\n  //jsonObj uses flowParser to turn the file into an AST\n  let jsonObj = flowParser.parse(fileContent);\n  // checks for Components in imports section  \n  let imports = grabImportNameAndPath(jsonObj);\n  let componentTags = grabChildComponents(imports, fileContent);\n  // checks if component is Stateful and grabs state;\n  let state = grabState(jsonObj);\n  // iterates through components array and creates object with Component name, props and path;\n  if (componentTags !== null){\n    componentTags.forEach(elem => {\n      let ast = flowParser.parse(elem).body[0].expression\n      reactObj = Object.assign(reactObj, constructComponentProps(ast));\n    });\n    imports = imports.filter(comp => {\n        comp.props = reactObj[comp.name]\n        return Object.keys(reactObj).includes(comp.name);\n    });\n  } else {\n    imports = [];\n  }\n  let outputObj = {\n    name: path.basename(jsxPath).split('.')[0],\n    childProps: imports,\n    stateProps: state,\n    children: []\n  }\n  return outputObj;\n}\n/**\n * recursively traverses through all folders given from filePath and creates JSON Object;\n * @param {String} filePath Path to Component folder\n * @param {String} rootPath - name of File\n */\nfunction constructComponentTree(filePath, rootPath) {\n  // create object at current level;\n  let result = constructSingleLevel(path.join(rootPath, filePath));\n  // checks if current Object has children and traverses through children to create Object;\n  if(result && Object.keys(result.childProps).length > 0){\n    for(let childProp of result.childProps) {\n      //creates new path for children components - if girootPath doesnt have an extension adds .js extension\n      let fullPath = path.join(rootPath, childProp.path);\n      let newRootPath = path.dirname(fullPath);\n      let newFileName = path.basename(fullPath);\n      let childPathSplit = newFileName.split('.');\n      if (childPathSplit.length === 1)\n        newFileName += '.js';\n      let newFullPath = path.join(newRootPath, newFileName);\n      //traverses through children \n      result.children.push(constructComponentTree(newFileName, newRootPath));\n    }\n  }  \n  return result;\n}\n/**\n * returns an array of React Components in String Format, checks imports array and filters fileContent to find Components;\n * @param {Array} imports - Array of Objects with name and path of all Import Objects;\n * @param {String} fileContent - String of File Content;\n */\nfunction grabChildComponents(imports, fileContent) {\n  // console.log(imports, fileContent, '***');\n  // grab all import object name from import array;\n  let compNames = imports.reduce((arr, cur) => {\n    // skips <Provider/> component from redux\n    if (cur.name !== 'Provider') {\n      arr.push(cur.name);\n    }\n    return arr;\n  }, []);\n  // console.log(compNames, 'XXX');\n  // format all import names for regex\n  compNames = compNames.join('|');\n  let pattern = '<\\s*(' + compNames + ')(>|(.|[\\r\\n])*?[^?]>)'\n  const regExp = new RegExp(pattern, 'g');\n  // finds all components that match imports;\n  let matchedComponents = fileContent.match(regExp);\n\n  return matchedComponents;\n}\n\nmodule.exports = {grabChildComponents, constructComponentTree, constructSingleLevel, constructComponentProps, grabImportNameAndPath, grabAttr, digStateInBlockStatement, digStateInClassBody, grabState, getClassEntry}\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "main",
          "type": "tree",
          "content": null
        },
        {
          "name": "nodeTerminal.js",
          "type": "blob",
          "size": 2.2998046875,
          "content": "const {exec, spawn} = require('child_process');\nrequire('fix-path')();\n/**\n * Takes in a command and current working directory from Terminal.js then runs and executes command using Node child process\n * @param {String} cwd Current working directory of the terminal\n * @param {String} command Command entered by the user\n * @param {Terminal} terminal Terminal instance to write messages to the pseudo terminal GUI\n */\nconst runTerminal = (cwd, command, terminal) => {\n  //Clear weird case where command includes \\r\n  const basicCommands = ['cd', 'pwd', 'hostname', 'mkdir', 'ls', 'find', 'rmdir', 'less', 'cp', 'mv', 'pushd', 'popd', 'grep', 'xargs', 'cat', 'env', 'export', 'echo', 'man', 'apropos', 'chown', 'chmod', 'exit']\n  if(command[0] === '\\\\'){\n    command = command.slice(2);\n  }\n  //If not npm, just run an exec because its faster output\n  if(command.split(' ')[0] !== 'npm' || basicCommands.includes(command.split(' ')[0])){\n    return new Promise((resolve, reject) => {\n      let child = exec(command, \n        {\n          cwd: cwd\n        });\n        //when data is returned, write it to the terminal\n      child.stdout.on('data', (data) => {\n        terminal.write('\\r\\n' + data.toString().replace(/(\\r\\n|\\n|\\r)/gm,\" \") + ' \\r\\n');\n      });\n        //When child process is done executing, write a new prompt line in terminal\n      child.on('close', (code) => {\n        terminal.write('\\r\\n' + cwd + '\\r\\n');\n        terminal.write('$');\n        resolve();\n      });\n        //Error handling\n      child.stderr.on('data', (data) => {\n        terminal.write(data.toString() + '\\r\\n');\n        reject();\n      })\n    })\n      //If it is an npm command, use SPAWN for heavier computation\n  } else{\n    //user prompt to understand their command is running\n    terminal.write('\\r\\n' + 'Running ' + command + '...' + '\\r\\n');\n    //Create the child_process spawn with current working directory\n    let child = spawn(command.split(' ')[0], command.split(' ').slice(1), {cwd: cwd, shell: true});\n    //On data, write it to the terminal\n    child.stdout.on('data', (data) => {\n      let output = data.toString().replace(/(\\r\\n|\\n|\\r)/gm,\"\");\n      terminal.write(output + '\\r\\n');\n    });\n    //on close, reprompt\n    child.on('close', () => {\n      terminal.write(cwd + '\\r\\n');\n      terminal.write('$');\n    })\n  }\n}\nmodule.exports = {runTerminal}"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 2.232421875,
          "content": "{\n  \"name\": \"reactide\",\n  \"productName\": \"Reactide\",\n  \"version\": \"3.0.0\",\n  \"description\": \"\",\n  \"main\": \"./main/main.js\",\n  \"scripts\": {\n    \"test\": \"mocha --compilers js:babel-register test/test.js\",\n    \"start\": \"cross-env NODE_ENV=production electron .\",\n    \"dev-start\": \"cross-env NODE_ENV=development electron .\",\n    \"dev\": \"webpack-dev-server --inline --content-base ./renderer\",\n    \"webpack\": \"webpack --mode development\",\n    \"webpack-production\": \"webpack --mode production\",\n    \"electron-packager\": \"electron-packager . --overwrite --platform=darwin --arch=x64 --icon=/Users/ep/Codesmith/reactide/icons/icon.png --prune=true --out=release-builds\"\n  },\n  \"author\": \"Mark Cruz, Jin Choi, Bita Djaghouri, Pablo Lee, Ryan Yang, Oscar Chan, Juan Hart, Eric Pham, Rocky Liao, Khalid Umar\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"@babel/core\": \"^7.1.2\",\n    \"@babel/preset-env\": \"^7.1.0\",\n    \"@babel/preset-react\": \"^7.0.0\",\n    \"@fortawesome/fontawesome-free\": \"^5.5.0\",\n    \"babel-loader\": \"^8.0.4\",\n    \"chai\": \"^4.2.0\",\n    \"chai-enzyme\": \"^1.0.0-beta.1\",\n    \"cross-env\": \"^4.0.0\",\n    \"css-loader\": \"^1.0.1\",\n    \"devtron\": \"^1.4.0\",\n    \"electron-builder\": \"^20.36.2\",\n    \"electron-debug\": \"^2.0.0\",\n    \"electron-devtools-installer\": \"^2.1.0\",\n    \"electron-hot-loader\": \"^0.8.0\",\n    \"electron-localshortcut\": \"^3.1.0\",\n    \"electron-packager\": \"^12.2.0\",\n    \"electron-reload\": \"^1.1.0\",\n    \"enzyme\": \"^2.8.0\",\n    \"eslint\": \"^3.19.0\",\n    \"executive\": \"^1.6.3\",\n    \"expect\": \"^1.20.2\",\n    \"fix-path\": \"^2.1.0\",\n    \"flow-parser\": \"^0.85.0\",\n    \"mocha\": \"^3.2.0\",\n    \"monaco-editor\": \"^0.14.3\",\n    \"monaco-editor-webpack-plugin\": \"^1.5.4\",\n    \"prop-types\": \"^15.5.8\",\n    \"react\": \"^16.6.0\",\n    \"react-addons-test-utils\": \"^15.4.2\",\n    \"react-dom\": \"^16.6.0\",\n    \"react-iframe\": \"^1.3.3\",\n    \"react-redux\": \"^5.0.7\",\n    \"react-xterm\": \"^2.0.4\",\n    \"redux\": \"^4.0.1\",\n    \"remote\": \"^0.2.6\",\n    \"sinon\": \"^2.1.0\",\n    \"spectron\": \"^3.6.2\",\n    \"style-loader\": \"^0.23.1\",\n    \"webpack\": \"4.25.1\",\n    \"webpack-dev-server\": \"^3.1.10\",\n    \"webpack-electron-packager\": \"^1.0.0\",\n    \"worker-loader\": \"^2.0.0\",\n    \"xterm\": \"^3.8.0\"\n  },\n  \"devDependencies\": {\n    \"electron\": \"^3.0.9\",\n    \"file-loader\": \"^4.1.0\",\n    \"webpack-cli\": \"^3.3.6\"\n  }\n}\n"
        },
        {
          "name": "renderer",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "webpack.config.js",
          "type": "blob",
          "size": 1.5185546875,
          "content": "const path = require('path');\nconst MonacoWebpackPlugin = require('monaco-editor-webpack-plugin');\n\nmodule.exports = {\n  entry: './renderer/index.js',\n  output: {\n    globalObject: 'self',\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'webpack-bundle.js',\n    publicPath: '../dist/',\n  },\n  // Compile for Electron for main process.\n  target: 'electron-main',\n  // configure whether to polyfill or mock certain Node.js globals\n  node: {\n    __dirname: false,\n    __filename: false\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.worker\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'worker-loader',\n          options: {\n            name: '[name].js',\n          },\n        },\n      },\n      {\n        test: /\\.css$/,\n        use:\n          process.env.NODE_ENV === 'production'\n            ? [MiniCssExtractPlugin.loader, 'css-loader']\n            : ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.scss$/,\n        use: [\n          \"style-loader\", // creates style nodes from JS strings\n          \"css-loader\", // translates CSS into CommonJS\n          \"sass-loader\" // compiles Sass to CSS, using Node Sass by default\n        ]\n      },\n      {\n        test: /\\.jsx?$/,\n        loader: 'babel-loader',\n        exclude: /(node_modules|(vendor\\/.+.bundle\\.js))/,\n        query: {\n          \"presets\": [\n            \"@babel/preset-env\",\n            \"@babel/preset-react\"\n          ]\n        }\n      }\n    ]\n  },\n  plugins: [\n    new MonacoWebpackPlugin()\n  ],\n  devServer: {\n    port: 8081\n  }\n}\n"
        }
      ]
    }
  ]
}