{
  "metadata": {
    "timestamp": 1736563345138,
    "page": 335,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "muaz-khan/WebRTC-Experiment",
      "stars": 11825,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.158203125,
          "content": "RecordRTC/RecordRTC-to-Nodejs/uploads/\n*.DS_Store\nffmpeg/ffmpeg_asm.js\nnode_modules\nRecordRTC/node_modules\nDetectRTC/node_modules\nRTCMultiConnection/node_modules\n"
        },
        {
          "name": "Canvas-Designer",
          "type": "tree",
          "content": null
        },
        {
          "name": "Chrome-Extensions",
          "type": "tree",
          "content": null
        },
        {
          "name": "ConcatenateBlobs",
          "type": "tree",
          "content": null
        },
        {
          "name": "Conversation.js",
          "type": "tree",
          "content": null
        },
        {
          "name": "DataChannel",
          "type": "tree",
          "content": null
        },
        {
          "name": "DetectRTC",
          "type": "tree",
          "content": null
        },
        {
          "name": "FileBufferReader",
          "type": "tree",
          "content": null
        },
        {
          "name": "Firefox-Extensions",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0869140625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2012-2020 [Muaz Khan](https://github.com/muaz-khan)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "MediaStreamRecorder",
          "type": "tree",
          "content": null
        },
        {
          "name": "MultiRTC",
          "type": "tree",
          "content": null
        },
        {
          "name": "MultiStreamsMixer",
          "type": "tree",
          "content": null
        },
        {
          "name": "PluginRTC",
          "type": "tree",
          "content": null
        },
        {
          "name": "Pluginfree-Screen-Sharing",
          "type": "tree",
          "content": null
        },
        {
          "name": "Pre-recorded-Media-Streaming",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.2509765625,
          "content": "# WebRTC Demos, Experiments, Libraries, Examples\n\n----\n\n# RecordRTC | WebRTC Audio+Video+Screen Recording\n\nWebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows.\n\nLive Demo: https://www.webrtc-experiment.com/RecordRTC/\n\n[![npm](https://img.shields.io/npm/v/recordrtc.svg)](https://npmjs.org/package/recordrtc) [![downloads](https://img.shields.io/npm/dm/recordrtc.svg)](https://npmjs.org/package/recordrtc) [![Build Status: Linux](https://travis-ci.org/muaz-khan/RecordRTC.png?branch=master)](https://travis-ci.org/muaz-khan/RecordRTC)\n\nGithub (open sourced): https://github.com/muaz-khan/RecordRTC\n\nRecordRTC extension is [available in the Chrome Web Store](https://chrome.google.com/webstore/detail/recordrtc/ndcljioonkecdnaaihodjgiliohngojp).\n\n----\n\n# MultiStreamsMixer\n\nPass multiple streams (e.g. screen+camera or multiple-cameras) and get single stream.\n\nLive Demo: https://www.webrtc-experiment.com/MultiStreamsMixer/\n\nGithub: https://github.com/muaz-khan/MultiStreamsMixer\n\n----\n\n# DetectRTC | Is WebRTC Supported In Your Browser?\n\nA tiny JavaScript library that can be used to detect WebRTC features e.g. system having speakers, microphone or webcam, screen capturing is supported, number of audio/video devices etc.\n\nLive Demo: https://www.webrtc-experiment.com/DetectRTC/\n\n[![npm](https://img.shields.io/npm/v/detectrtc.svg)](https://npmjs.org/package/detectrtc) [![downloads](https://img.shields.io/npm/dm/detectrtc.svg)](https://npmjs.org/package/detectrtc)  [![Build Status: Linux](https://travis-ci.org/muaz-khan/DetectRTC.png?branch=master)](https://travis-ci.org/muaz-khan/DetectRTC)\n\nGithub (open sourced): https://github.com/muaz-khan/DetectRTC\n\n----\n\n# RTCMultiConnection\n\nWebRTC JavaScript library for peer-to-peer applications (screen sharing, audio/video conferencing, file sharing, media streaming etc.)\n\n[![npm](https://img.shields.io/npm/v/rtcmulticonnection.svg)](https://npmjs.org/package/rtcmulticonnection) [![downloads](https://img.shields.io/npm/dm/rtcmulticonnection.svg)](https://npmjs.org/package/rtcmulticonnection) [![Build Status: Linux](https://travis-ci.org/muaz-khan/RTCMultiConnection.png?branch=master)](https://travis-ci.org/muaz-khan/RTCMultiConnection)\n\nGithub: https://github.com/muaz-khan/RTCMultiConnection\n\nSocket.io signaling server: https://github.com/muaz-khan/RTCMultiConnection-Server\n\n----\n\n# WebRTC Scalable Broadcasting\n\nThis module simply initializes socket.io and configures it in a way that single broadcast can be relayed over unlimited users without any bandwidth/CPU usage issues. Everything happens peer-to-peer!\n\nLive Demo: https://rtcmulticonnection.herokuapp.com/demos/Scalable-Broadcast.html\n\n[![npm](https://img.shields.io/npm/v/webrtc-scalable-broadcast.svg)](https://npmjs.org/package/webrtc-scalable-broadcast) [![downloads](https://img.shields.io/npm/dm/webrtc-scalable-broadcast.svg)](https://npmjs.org/package/webrtc-scalable-broadcast)\n\nGithub (open sourced): https://github.com/muaz-khan/WebRTC-Scalable-Broadcast\n\n----\n\n# WebRTC Dashboard | Canvas2D Drawing Tool\n\nCollaborative, extendable, JavaScript Canvas2D drawing tool, supports dozens of builtin tools, as well as generates JavaScript code for 2D animations.\n\nLive Demo: https://www.webrtc-experiment.com/Canvas-Designer/\n\nGithub (open-sourced): https://github.com/muaz-khan/Canvas-Designer\n\n[![npm](https://img.shields.io/npm/v/canvas-designer.svg)](https://npmjs.org/package/canvas-designer) [![downloads](https://img.shields.io/npm/dm/canvas-designer.svg)](https://npmjs.org/package/canvas-designer) [![Build Status: Linux](https://travis-ci.org/muaz-khan/Canvas-Designer.png?branch=master)](https://travis-ci.org/muaz-khan/Canvas-Designer)\n\nYou video presentation: https://www.youtube.com/watch?v=pvAj5l_v3cM\n\n----\n\n# WebRTC Voice & Text Translator\n\nTranslator.js is a JavaScript library built top on Google Speech-Recognition & Translation API to transcript and translate voice and text. It supports many locales and brings globalization in WebRTC!\n\nLive Demo: https://www.webrtc-experiment.com/Translator/\n\nGithub (open-sourced): https://github.com/muaz-khan/Translator\n\n----\n\n# getStats | Get WebRTC Peer Connection Stats\n\nA tiny JavaScript library using WebRTC getStats API to return peer connection stats i.e. bandwidth usage, packets lost, local/remote ip addresses and ports, type of connection etc.\n\nLive Demo: https://www.webrtc-experiment.com/getStats/\n\n[![npm](https://img.shields.io/npm/v/getstats.svg)](https://npmjs.org/package/getstats) [![downloads](https://img.shields.io/npm/dm/getstats.svg)](https://npmjs.org/package/getstats)\n\nGithub (open-sourced): https://github.com/muaz-khan/getStats\n\n----\n\n# FileBufferReader | File Sharing\n\nFileBufferReader is a JavaScript library reads file and returns chunkified array-buffers. The resulting buffers can be shared using WebRTC data channels or socket.io. \n\nLive Demo: https://www.webrtc-experiment.com/FileBufferReader/\n\nGithub (open-sourced): https://github.com/muaz-khan/FileBufferReader\n\n[![npm](https://img.shields.io/npm/v/fbr.svg)](https://npmjs.org/package/fbr) [![downloads](https://img.shields.io/npm/dm/fbr.svg)](https://npmjs.org/package/fbr) [![Build Status: Linux](https://travis-ci.org/muaz-khan/FileBufferReader.png?branch=master)](https://travis-ci.org/muaz-khan/FileBufferReader)\n\nYoutube video presentation: https://www.youtube.com/watch?v=gv8xpdGdS4o\n\n----\n\n# WebRTC Video Conferencing Demos\n\n* Simple Demo: https://rtcmulticonnection.herokuapp.com/demos/Video-Conferencing.html\n\n----\n\n# WebRTC File Sharing\n\n* Advance file sharing demo: https://rtcmulticonnection.herokuapp.com/demos/file-sharing.html\n\n----\n\n# WebRTC Screen Sharing\n\n* P2P Screen Sharing: https://www.webrtc-experiment.com/Pluginfree-Screen-Sharing/\n* Simple getDisplayMedia: https://www.webrtc-experiment.com/getDisplayMedia/\n\n----\n\n# Ffmpeg.js demos, both for browsers and node.js\n\n* https://github.com/muaz-khan/Ffmpeg.js\n\n----\n\n# XHR-Signaling\n\nXHR/XMLHttpRequest based WebRTC signaling implementation.\n\nGithub (open-sourced): https://github.com/muaz-khan/XHR-Signaling\n\n----\n\n# ASP.NET MVC based WebRTC Demo\n\nA simple WebRTC one-to-one demo written in September, 2012! It supports public rooms as well as password-protected private rooms! MS-SQL database is used as signaling gateway!\n\nGithub (open-sourced): https://github.com/muaz-khan/WebRTC-ASPNET-MVC\n\n----\n\n# WebSync-Signaling\n\nWebSync is used as signaling gateway with/for WebRTC-Experiments e.g. RTCMultiConnection.js, DataChannel.js, Plugin-free screen sharing, and video conferencing.\n\nGithub (open-sourced): https://github.com/muaz-khan/WebSync-Signaling\n\n----\n\n# Server Sent Events (SSE) over PHP\n\nServer Sent Events (SSE) are used to setup WebRTC peer-to-peer connections.\n\nGithub (open-sourced): https://github.com/muaz-khan/RTCMultiConnection/tree/master/demos/SSEConnection\n\n----\n\n# SignalR\n\nSignalR project for RTCMultiConnection: https://github.com/muaz-khan/RTCMultiConnection-SignalR\n\n* https://github.com/muaz-khan/WebRTC-Experiment/blob/master/Signaling.md#how-to-use-signalr-for-signaling\n\n----\n\n# License\n\nAll [WebRTC Experiments](https://github.com/muaz-khan/WebRTC-Experiment) are released under [MIT license](https://github.com/muaz-khan/WebRTC-Experiment/blob/master/LICENSE) . Copyright (c) [Muaz Khan](https://muazkhan.com/).\n"
        },
        {
          "name": "RTCMultiConnection-Server",
          "type": "tree",
          "content": null
        },
        {
          "name": "RTCMultiConnection-SignalR",
          "type": "tree",
          "content": null
        },
        {
          "name": "RTCMultiConnection",
          "type": "tree",
          "content": null
        },
        {
          "name": "RTCPeerConnection",
          "type": "tree",
          "content": null
        },
        {
          "name": "RTCall",
          "type": "tree",
          "content": null
        },
        {
          "name": "Record-Entire-Meeting",
          "type": "tree",
          "content": null
        },
        {
          "name": "RecordRTC",
          "type": "tree",
          "content": null
        },
        {
          "name": "Reliable-Signaler",
          "type": "tree",
          "content": null
        },
        {
          "name": "Signaling.md",
          "type": "blob",
          "size": 18.587890625,
          "content": "# WebRTC Signaling\n\nYou can use any signaling implementation with any [WebRTC Experiment](https://www.webrtc-experiment.com/); whether it is XMPP/SIP or PHP/MySQL or Socket.io/WebSockets or WebSync/SignalR or PeerServer/SignalMaster or other gateway.\n\nRemember, there are some built-in implementations:\n\n1. [RTCMultiConnection.js and Reliable Signaling](https://github.com/muaz-khan/Reliable-Signaler/tree/master/rtcmulticonnection-client)\n2. [DataChanel.js and Reliable Signaling](https://github.com/muaz-khan/Reliable-Signaler/tree/master/datachannel-client)\n1. [Socket.io over Node.js](https://github.com/muaz-khan/WebRTC-Experiment/tree/master/socketio-over-nodejs)\n2. [WebSocket over Node.js](https://github.com/muaz-khan/WebRTC-Experiment/tree/master/websocket-over-nodejs)\n3. [WebSync for Signaling](https://github.com/muaz-khan/WebSync-Signaling) � useful only for .NET developers\n4. [XHR/XMLHttpRequest Signaling](https://github.com/muaz-khan/XHR-Signaling) � useful for both .NET and PHP developers!\n5. [RTCMultiConnection](https://github.com/muaz-khan/RTCMultiConnection) / [Demo](https://rtcmulticonnection.herokuapp.com/)\n\nIf you wanna understand basics of WebRTC signaling; then scroll to bottom and check [this section](https://github.com/muaz-khan/WebRTC-Experiment/blob/master/Signaling.md#a-few-other-resources).\n\n# Nodejs/Socketio Server-Side Code\n\nYour server side code can be as simple as possible like this:\n\n```javascript\nio.sockets.on('connection', function (socket) {\n    socket.on('message', function (data) {\n        socket.broadcast.emit('message', data);\n    });\n});\n```\n\nYou can even use existing services like (for server side code only!):\n\n1. https://github.com/andyet/signalmaster\n2. https://github.com/peers/peerjs-server\n3. https://github.com/SignalR/SignalR\n4. http://millermedeiros.github.io/js-signals/\n5. https://github.com/sockjs/sockjs-client\n\n# Browser side coding?\n\nThere are dozens of WebRTC Experiments and Libraries; you can use any existing signaling server with any WebRTC Experiment/Library!\n\nYou just need to understand how signaling is implemented in WebRTC Experiments:\n\n1. All WebRTC Experiments has `openSocket` method; that can be defined in the HTML page; which allows you override/use any signaling implementation there!\n2. All WebRTC Libraries has a public method i.e. [`openSignalingChannel`](http://www.rtcmulticonnection.org/docs/openSignalingChannel/);  which can also be overridden/defined in the HTML page; also you can override it to easily use any signaling implementation exists out there!\n\nNow you understood how default implementations can be overridden; it is time to understand how to override for any signaling implementation exists out there!\n\n# Example code to explain how to override `openSignalingChannel`\n\n## First Step: Initialize a global array-like object\n\nThis array-like object will store `onmessage` callbacks.\n\n```javascript\nvar onMessageCallbacks = {};\n```\n\n## Second Step: Initialize Signaling Server\n\n```javascript\nvar websocket = new WebSocket('wss://something:port/');\nvar socket = io.connect('https://domain:port/');\nvar firebase = new Firebase('https://user.firebaseio.com/' + connection.channel);\n```\n\nFor socket.io; you can pass default channel as URL parameter:\n\n```javascript\nvar socket = io.connect('https://domain:port/?channel=' + connection.channel);\n```\n\n## 3rd Step: Subscribe to server messages\n\nCapture server messages:\n\n```javascript\nwebsocket.onmessage = function (event) {\n    onMessageCallBack(event.data);\n};\n\nsocket.on('message', function (data) {\n    onMessageCallBack(data);\n});\n\nfirebase.on('child_added', function (snap) {\n    onMessageCallBack(snap.val());\n    snap.ref().remove(); // for socket.io live behaviour\n});\n```\n\nand `onMessageCallBack`:\n\n```javascript\nfunction onMessageCallBack(data) {\n    data = JSON.parse(e.data);\n\n    if (data.sender == connection.userid) return;\n\n    if (onMessageCallbacks[data.channel]) {\n        onMessageCallbacks[data.channel](data.message);\n    };\n}\n```\n\n## 4th and final Step: Override `openSignalingChannel` method\n\n```javascript\nconnection.openSignalingChannel = function (config) {\n    var channel = config.channel || this.channel;\n    onMessageCallbacks[channel] = config.onmessage;\n\n    if (config.onopen) setTimeout(config.onopen, 1000);\n    return {\n        send: function (message) {\n            websocket.send(JSON.stringify({\n                sender: connection.userid,\n                channel: channel,\n                message: message\n            }));\n        },\n        channel: channel\n    };\n};\n```\n\nRead more [here](https://github.com/muaz-khan/WebRTC-Experiment/issues/180#issuecomment-38318694).\n\n# `openSignalingChannel` for [RTCMultiConnection.js](https://github.com/muaz-khan/RTCMultiConnection) and [DataChanel.js](https://github.com/muaz-khan/DataChannel) (Client-Side Code)\n\nPutting above 4-steps together! Here is your browser side code that overrides default signaling implementations:\n\n```javascript\nvar onMessageCallbacks = {};\nvar socketio = io.connect('http://localhost:8888/');\n\nsocketio.on('message', function(data) {\n    if(data.sender == connection.userid) return;\n\n    if (onMessageCallbacks[data.channel]) {\n        onMessageCallbacks[data.channel](data.message);\n    };\n});\n\nconnection.openSignalingChannel = function (config) {\n    var channel = config.channel || this.channel;\n    onMessageCallbacks[channel] = config.onmessage;\n\n    if (config.onopen) setTimeout(config.onopen, 1000);\n    return {\n        send: function (message) {\n            socketio.emit('message', {\n                sender: connection.userid,\n                channel: channel,\n                message: message\n            });\n        },\n        channel: channel\n    };\n};\n```\n\n# `openSocket` for all standalone WebRTC Experiments\n\n```javascript\nvar onMessageCallbacks = {};\nvar currentUserUUID = Math.round(Math.random() * 60535) + 5000;\nvar socketio = io.connect('http://localhost:8888/');\n\nsocketio.on('message', function(data) {\n    if(data.sender == currentUserUUID) return;\n\n    if (onMessageCallbacks[data.channel]) {\n        onMessageCallbacks[data.channel](data.message);\n    };\n});\n\nvar config = {\n    openSocket = function (config) {\n        var channel = config.channel || 'main-channel';\n        onMessageCallbacks[channel] = config.onmessage;\n\n        if (config.onopen) setTimeout(config.onopen, 1000);\n        return {\n            send: function (message) {\n                socketio.emit('message', {\n                    sender: currentUserUUID,\n                    channel: channel,\n                    message: message\n                });\n            },\n            channel: channel\n        };\n    }\n};\n```\n\n# \"Any WebSocket Server!\" for Signaling\n\n```javascript\n// global stuff\nvar onMessageCallbacks = {};\nvar currentUserUUID = Math.round(Math.random() * 60535) + 5000;\nvar websocket = new WebSocket('ws://localhost:8888/');\n\nwebsocket.onmessage =  function(e) {\n    data = JSON.parse(e.data);\n\n    if(data.sender == currentUserUUID) return;\n\n    if (onMessageCallbacks[data.channel]) {\n        onMessageCallbacks[data.channel](data.message);\n    };\n};\n\nwebsocket.push = websocket.send;\nwebsocket.send = function(data) {\n    data.sender = currentUserUUID;\n    websocket.push(JSON.stringify(data));\n};\n\n// overriding \"openSignalingChannel\" method\nconnection.openSignalingChannel = function (config) {\n    var channel = config.channel || this.channel;\n    onMessageCallbacks[channel] = config.onmessage;\n\n    if (config.onopen) setTimeout(config.onopen, 1000);\n\n    // directly returning socket object using \"return\" statement\n    return {\n        send: function (message) {\n            websocket.send(JSON.stringify({\n                sender: currentUserUUID,\n                channel: channel,\n                message: message\n            }));\n        },\n        channel: channel\n    };\n};\n```\n\n# A few points to remember:\n\n1. The object returned by overridden `openSignalingChannel` or `openSocket` method MUST return an object with two things:\n\n   1. `send` method. Used to send data via signaling gateway.\n   2. `channel` object. Used for video-conferencing. If you skip it; it will make one-to-many instead of many-to-many.\n\n2. `onmessage` or `on('message', callback)` MUST have same code as you can see a few lines above.\n\n`openSocket` method can return `socket` object in three ways:\n\n1. Directly returning using `return` statement.\n2. Passing back over `config.callback` object.\n3. Passing back over `config.onopen` object.\n\nSecond option i.e. `config.callback` is preferred.\n\n## First Option\n\n```javascript\n var config = {\n     openSocket: function (config) {\n         var channel = config.channel || location.href.replace(/\\/|:|#|%|\\.|\\[|\\]/g, '');\n         var socket = new Firebase('https://chat.firebaseIO.com/' + channel);\n         socket.channel = channel;\n         socket.on(\"child_added\", function (data) {\n             config.onmessage && config.onmessage(data.val());\n         });\n         socket.send = function (data) {\n             this.push(data);\n         };\n         socket.onDisconnect().remove();\n\n         // first option: returning socket object using \"return\" statement!\n         return socket;\n     }\n };\n```\n\n## Second Option\n\n```javascript\n var config = {\n     openSocket: function (config) {\n         var SIGNALING_SERVER = 'wss://wsnodejs.nodejitsu.com:443';\n         var channel = config.channel || location.href.replace(/\\/|:|#|%|\\.|\\[|\\]/g, '');\n         var websocket = new WebSocket(SIGNALING_SERVER);\n         websocket.channel = config.channel;\n         websocket.onopen = function () {\n             websocket.push(JSON.stringify({\n                 open: true,\n                 channel: config.channel\n             }));\n\n             // second option: returning socket object using \"config.callback\" method\n             if (config.callback)\n                 config.callback(websocket);\n         };\n         websocket.onmessage = function (event) {\n             config.onmessage(JSON.parse(event.data));\n         };\n         websocket.push = websocket.send;\n         websocket.send = function (data) {\n             websocket.push(JSON.stringify({\n                 data: data,\n                 channel: config.channel\n             }));\n         };\n     }\n };\n```\n\n## Third Option\n\n```javascript\n var config = {\n     openSocket: function (config) {\n         // --------\n         websocket.onopen = function () {\n             // --------\n\n             // third option: returning socket object using \"config.onopen\" method\n             if (config.onopen)\n                 config.onopen(websocket);\n         };\n         // --------\n     }\n };\n```\n\n# How to use [WebSync for Signaling](https://github.com/muaz-khan/WebSync-Signaling)?\n\n```html\n<script src=\"fm.js\"> </script>\n<script src=\"fm.websync.js\"> </script>\n<script src=\"fm.websync.subscribers.js\"> </script>\n<script src=\"fm.websync.chat.js\"> </script>\n```\n\n```javascript\n// www.RTCMultiConnection.org/latest.js\n\nvar connection = new RTCMultiConnection();\n\n// ------------------------------------------------------------------\n// start-using WebSync for signaling\nvar onMessageCallbacks = {};\n\nvar client = new fm.websync.client('websync.ashx');\n\nclient.setAutoDisconnect({\n    synchronous: true\n});\n\nclient.connect({\n    onSuccess: function () {\n        client.join({\n            channel: '/chat',\n            userId: connection.userid,\n            userNickname: connection.userid,\n            onReceive: function (event) {\n                var message = JSON.parse(event.getData().text);\n                if (onMessageCallbacks[message.channel]) {\n                    onMessageCallbacks[message.channel](message.message);\n                }\n            }\n        });\n    }\n});\n\nconnection.openSignalingChannel = function (config) {\n    var channel = config.channel || this.channel;\n    onMessageCallbacks[channel] = config.onmessage;\n\n    if (config.onopen) setTimeout(config.onopen, 1000);\n    return {\n        send: function (message) {\n            client.publish({\n                channel: '/chat',\n                data: {\n                    username: connection.userid,\n                    text: JSON.stringify({\n                        message: message,\n                        channel: channel\n                    })\n                }\n            });\n        }\n    };\n};\n// end-using WebSync for signaling\n// ------------------------------------------------------------------\n\n// check existing sessions\nconnection.connect();\n\n// open new session\ndocument.getElementById('open-new-session').onclick = function() {\n    connection.open();\n};\n```\n\n# How to use SignalR for Signaling?\n\n**First Step:** Create Hub class:\n\n```csharp\npublic class WebRtcHub3: Hub {\n    public void Send(string message) {\n        Clients.All.onMessageReceived(message);\n    }\n}\n```\n\n**Second Step:** Client side stuff:\n\n```javascript\nvar onMessageCallbacks = {};\n\nvar connection = new RTCMultiConnection();\n\nvar hub = $.connection.webRtcHub3;\n$.support.cors = true;\n\n$.connection.hub.url = '/signalr/hubs';\n\nhub.client.onMessageReceived = function (message) {\n    var message = JSON.parse(message);\n    if (onMessageCallbacks[message.channel]) {\n        onMessageCallbacks[message.channel](message.message);\n    }\n};\n\n// start the hub\n$.connection.hub.start();\n\n```\n\n**Third Step:** Overriding `openSignalingChannel` method:\n\n```javascript\nconnection.openSignalingChannel = function (config) {\n    var channel = config.channel || this.channel;\n    onMessageCallbacks[channel] = config.onmessage;\n\n    if (config.onopen) setTimeout(config.onopen, 1000);\n    return {\n        send: function (message) {\n            message = JSON.stringify({\n                message: message,\n                channel: channel\n            });\n\n            hub.server.send(message);\n        }\n    };\n};\n```\n\n# Room Presence Detection\n\n[Using Firebase](https://github.com/muaz-khan/WebRTC-Experiment/issues/38#issuecomment-20527305):\n\n```javascript\nnew window.Firebase('https://' + connection.firebase + '.firebaseIO.com/' + connection.channel).once('value', function (data) {\n    var isRoomPresent = data.val() != null;\n    if (!isRoomPresent) {\n        connection.open(connection.sessionid);\n    } else {\n        connection.join(connection.sessionid);\n    }\n});\n```\n\n[Using Socket.io over Node.js](https://github.com/muaz-khan/WebRTC-Experiment/issues/38#issuecomment-18821960):\n\n```javascript\nvar socket = io.connect('/');\n\nsocket.on('presence', function (isChannelPresent) {\n    if (!isChannelPresent)\n        connection.open(connection.sessionid);\n    else\n        connection.join(connection.sessionid);\n});\n\nsocket.emit('presence', channel);\n```\n\nSocket.io over Node.js demos can be found [here](https://github.com/muaz-khan/WebRTC-Experiment/blob/master/socketio-over-nodejs).\n\n[Using WebSocket over Node.js](https://github.com/muaz-khan/WebRTC-Experiment/blob/master/websocket-over-nodejs)\n\n```javascript\nvar SIGNALING_SERVER = 'wss://wsnodejs.nodejitsu.com:443';\nvar websocket = new WebSocket(SIGNALING_SERVER);\n\nwebsocket.onmessage = function (event) {\n    var data = JSON.parse(event.data);\n\n    if (data.isChannelPresent == false) {\n        connection.open(connection.sessionid);\n    } else {\n        connection.join(connection.sessionid);\n    }\n};\n\nwebsocket.onopen = function () {\n    websocket.send(JSON.stringify({\n        checkPresence: true,\n        channel: connection.channel\n    }));\n};\n```\n\nWebSocket over Node.js demos can be found [here](https://github.com/muaz-khan/WebRTC-Experiment/blob/master/websocket-over-nodejs).\n\n# XHR/XMLHttpRequest for Signaling\n\n```javascript\n// database has a single table; which has two columns:\n// 1) Message (required to store JSON data)\n// 2) ID (optional: as primary key)\n\n// a simple function to make XMLHttpRequests\nfunction xhr(url, callback, data) {\n    if (!window.XMLHttpRequest || !window.JSON) return;\n\n    var request = new XMLHttpRequest();\n    request.onreadystatechange = function () {\n        if (callback && request.readyState == 4 && request.status == 200) {\n            // server MUST return JSON text\n            callback(JSON.parse(request.responseText));\n        }\n    };\n    request.open('POST', url);\n\n    var formData = new FormData();\n\n    // you're passing \"message\" parameter\n    formData.append('message', data);\n\n    request.send(formData);\n}\n\n// this object is used to store \"onmessage\" callbacks from \"openSignalingChannel handler\nvar onMessageCallbacks = {};\n\n// this object is used to make sure identical messages are not used multiple times\nvar messagesReceived = {};\n\nfunction repeatedlyCheck() {\n    xhr('/Home/GetData', function (data) {\n        // if server says nothing; wait.\n        if (data == false) return setTimeout(repeatedlyCheck, 400);\n\n        // if already receied same message; skip.\n        if (messagesReceived[data.ID]) return setTimeout(repeatedlyCheck, 400);\n        messagesReceived[data.ID] = data.Message;\n\n        // \"Message\" property is JSON-ified in \"openSignalingChannel handler\n        data = JSON.parse(data.Message);\n\n        // don't pass self messages over \"onmessage\" handlers\n        if (data.sender != connection.userid && onMessageCallbacks[data.channel]) {\n            onMessageCallbacks[data.channel](data.message);\n        }\n\n        // repeatedly check the database\n        setTimeout(repeatedlyCheck, 1);\n    });\n}\n\nrepeatedlyCheck();\n\n// overriding \"openSignalingChannel handler\nconnection.openSignalingChannel = function (config) {\n    var channel = config.channel || this.channel;\n    onMessageCallbacks[channel] = config.onmessage;\n\n    // let RTCMultiConnection know that server connection is opened!\n    if (config.onopen) setTimeout(config.onopen, 1);\n\n    // returning an object to RTCMultiConnection\n    // so it can send data using \"send\" method\n    return {\n        send: function (data) {\n            data = {\n                channel: channel,\n                message: data,\n                sender: connection.userid\n            };\n\n            // posting data to server\n            // data is also JSON-ified.\n            xhr('/Home/PostData', null, JSON.stringify(data));\n        },\n        channel: channel\n    };\n};\n```\n\nSource code is available here: https://github.com/muaz-khan/XHR-Signaling\n\nRemember: You can use same code JavaScript code both for PHP and ASP.NET.\n\n# Server Sent Events (SSE) over PHP\n\n* https://github.com/muaz-khan/RTCMultiConnection/tree/master/demos/SSEConnection\n\nYou can find many other good examples here:\n\nhttp://www.RTCMultiConnection.org/docs/openSignalingChannel/\n\n# A few other resources:\n\n1. https://www.webrtc-experiment.com/docs/WebRTC-Signaling-Concepts.html\n2. http://www.RTCMultiConnection.org/FAQ/\n3. http://www.RTCMultiConnection.org/docs/sessionid/\n4. http://www.RTCMultiConnection.org/docs/channel-id/\n\n# License\n\n[WebRTC Experiments](https://www.webrtc-experiment.com/) are released under [MIT licence](https://www.webrtc-experiment.com/licence/) . Copyright (c) [Muaz Khan](http://www.muazkhan.com/).\n"
        },
        {
          "name": "Translator.js",
          "type": "tree",
          "content": null
        },
        {
          "name": "WebRTC-File-Sharing",
          "type": "tree",
          "content": null
        },
        {
          "name": "WebRTC-Scalable-Broadcast",
          "type": "tree",
          "content": null
        },
        {
          "name": "audio-broadcast",
          "type": "tree",
          "content": null
        },
        {
          "name": "broadcast",
          "type": "tree",
          "content": null
        },
        {
          "name": "chat-hangout",
          "type": "tree",
          "content": null
        },
        {
          "name": "demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "desktop-sharing",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "experimental",
          "type": "tree",
          "content": null
        },
        {
          "name": "ffmpeg",
          "type": "tree",
          "content": null
        },
        {
          "name": "file-hangout",
          "type": "tree",
          "content": null
        },
        {
          "name": "file-sharing",
          "type": "tree",
          "content": null
        },
        {
          "name": "getDisplayMedia",
          "type": "tree",
          "content": null
        },
        {
          "name": "getMediaElement",
          "type": "tree",
          "content": null
        },
        {
          "name": "getScreenId.js",
          "type": "tree",
          "content": null
        },
        {
          "name": "getStats",
          "type": "tree",
          "content": null
        },
        {
          "name": "gumadapter",
          "type": "tree",
          "content": null
        },
        {
          "name": "hark",
          "type": "tree",
          "content": null
        },
        {
          "name": "meeting",
          "type": "tree",
          "content": null
        },
        {
          "name": "navigator.customGetUserMediaBar",
          "type": "tree",
          "content": null
        },
        {
          "name": "one-to-many-audio-broadcasting",
          "type": "tree",
          "content": null
        },
        {
          "name": "one-to-many-video-broadcasting",
          "type": "tree",
          "content": null
        },
        {
          "name": "part-of-screen-sharing",
          "type": "tree",
          "content": null
        },
        {
          "name": "realtime-pluginfree-calls",
          "type": "tree",
          "content": null
        },
        {
          "name": "screen-broadcast",
          "type": "tree",
          "content": null
        },
        {
          "name": "screen-sharing",
          "type": "tree",
          "content": null
        },
        {
          "name": "server.js",
          "type": "blob",
          "size": 2,
          "content": "// http://127.0.0.1:9001\n// http://localhost:9001\n\nvar server = require('http'),\n    url = require('url'),\n    path = require('path'),\n    fs = require('fs');\n\nfunction serverHandler(request, response) {\n    var uri = url.parse(request.url).pathname,\n        filename = path.join(process.cwd(), uri);\n\n    fs.exists(filename, function(exists) {\n        if (!exists) {\n            response.writeHead(404, {\n                'Content-Type': 'text/plain'\n            });\n            response.write('404 Not Found: ' + filename + '\\n');\n            response.end();\n            return;\n        }\n\n        if (filename.indexOf('favicon.ico') !== -1) {\n            return;\n        }\n\n        var isWin = !!process.platform.match(/^win/);\n\n        if (fs.statSync(filename).isDirectory() && !isWin) {\n            filename += '/index.html';\n        } else if (fs.statSync(filename).isDirectory() && !!isWin) {\n            filename += '\\\\index.html';\n        }\n\n        fs.readFile(filename, 'binary', function(err, file) {\n            if (err) {\n                response.writeHead(500, {\n                    'Content-Type': 'text/plain'\n                });\n                response.write(err + '\\n');\n                response.end();\n                return;\n            }\n\n            var contentType;\n\n            if (filename.indexOf('.html') !== -1) {\n                contentType = 'text/html';\n            }\n\n            if (filename.indexOf('.js') !== -1) {\n                contentType = 'application/javascript';\n            }\n\n            if (contentType) {\n                response.writeHead(200, {\n                    'Content-Type': contentType\n                });\n            } else response.writeHead(200);\n\n            response.write(file, 'binary');\n            response.end();\n        });\n    });\n}\n\nvar app;\n\napp = server.createServer(serverHandler);\n\napp = app.listen(process.env.PORT || 9001, process.env.IP || \"0.0.0.0\", function() {\n    var addr = app.address();\n    console.log(\"Server listening at\", addr.address + \":\" + addr.port);\n});\n"
        },
        {
          "name": "socket.io",
          "type": "tree",
          "content": null
        },
        {
          "name": "socketio-over-nodejs",
          "type": "tree",
          "content": null
        },
        {
          "name": "text-chat",
          "type": "tree",
          "content": null
        },
        {
          "name": "video-conferencing",
          "type": "tree",
          "content": null
        },
        {
          "name": "webrtc-broadcasting",
          "type": "tree",
          "content": null
        },
        {
          "name": "websocket-over-nodejs",
          "type": "tree",
          "content": null
        },
        {
          "name": "websocket",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}