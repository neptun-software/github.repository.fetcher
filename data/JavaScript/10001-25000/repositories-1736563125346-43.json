{
  "metadata": {
    "timestamp": 1736563125346,
    "page": 43,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "websockets/ws",
      "stars": 21906,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0185546875,
          "content": "* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.044921875,
          "content": "node_modules/\n.nyc_output/\ncoverage/\n.vscode/\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "package-lock=false\n"
        },
        {
          "name": ".prettierrc.yaml",
          "type": "blob",
          "size": 0.087890625,
          "content": "arrowParens: always\nendOfLine: lf\nproseWrap: always\nsingleQuote: true\ntrailingComma: none\n"
        },
        {
          "name": "FUNDING.json",
          "type": "blob",
          "size": 0.1044921875,
          "content": "{\n  \"drips\": {\n    \"ethereum\": {\n      \"ownedBy\": \"0x3D4f997A071d2BA735AC767E68052679423c3dBe\"\n    }\n  }\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1552734375,
          "content": "Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\nCopyright (c) 2013 Arnout Kazemier and contributors\nCopyright (c) 2016 Luigi Pinca and contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.947265625,
          "content": "# ws: a Node.js WebSocket library\n\n[![Version npm](https://img.shields.io/npm/v/ws.svg?logo=npm)](https://www.npmjs.com/package/ws)\n[![CI](https://img.shields.io/github/actions/workflow/status/websockets/ws/ci.yml?branch=master&label=CI&logo=github)](https://github.com/websockets/ws/actions?query=workflow%3ACI+branch%3Amaster)\n[![Coverage Status](https://img.shields.io/coveralls/websockets/ws/master.svg?logo=coveralls)](https://coveralls.io/github/websockets/ws)\n\nws is a simple to use, blazing fast, and thoroughly tested WebSocket client and\nserver implementation.\n\nPasses the quite extensive Autobahn test suite: [server][server-report],\n[client][client-report].\n\n**Note**: This module does not work in the browser. The client in the docs is a\nreference to a backend with the role of a client in the WebSocket communication.\nBrowser clients must use the native\n[`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\nobject. To make the same code work seamlessly on Node.js and the browser, you\ncan use one of the many wrappers available on npm, like\n[isomorphic-ws](https://github.com/heineiuo/isomorphic-ws).\n\n## Table of Contents\n\n- [Protocol support](#protocol-support)\n- [Installing](#installing)\n  - [Opt-in for performance](#opt-in-for-performance)\n    - [Legacy opt-in for performance](#legacy-opt-in-for-performance)\n- [API docs](#api-docs)\n- [WebSocket compression](#websocket-compression)\n- [Usage examples](#usage-examples)\n  - [Sending and receiving text data](#sending-and-receiving-text-data)\n  - [Sending binary data](#sending-binary-data)\n  - [Simple server](#simple-server)\n  - [External HTTP/S server](#external-https-server)\n  - [Multiple servers sharing a single HTTP/S server](#multiple-servers-sharing-a-single-https-server)\n  - [Client authentication](#client-authentication)\n  - [Server broadcast](#server-broadcast)\n  - [Round-trip time](#round-trip-time)\n  - [Use the Node.js streams API](#use-the-nodejs-streams-api)\n  - [Other examples](#other-examples)\n- [FAQ](#faq)\n  - [How to get the IP address of the client?](#how-to-get-the-ip-address-of-the-client)\n  - [How to detect and close broken connections?](#how-to-detect-and-close-broken-connections)\n  - [How to connect via a proxy?](#how-to-connect-via-a-proxy)\n- [Changelog](#changelog)\n- [License](#license)\n\n## Protocol support\n\n- **HyBi drafts 07-12** (Use the option `protocolVersion: 8`)\n- **HyBi drafts 13-17** (Current default, alternatively option\n  `protocolVersion: 13`)\n\n## Installing\n\n```\nnpm install ws\n```\n\n### Opt-in for performance\n\n[bufferutil][] is an optional module that can be installed alongside the ws\nmodule:\n\n```\nnpm install --save-optional bufferutil\n```\n\nThis is a binary addon that improves the performance of certain operations such\nas masking and unmasking the data payload of the WebSocket frames. Prebuilt\nbinaries are available for the most popular platforms, so you don't necessarily\nneed to have a C++ compiler installed on your machine.\n\nTo force ws to not use bufferutil, use the\n[`WS_NO_BUFFER_UTIL`](./doc/ws.md#ws_no_buffer_util) environment variable. This\ncan be useful to enhance security in systems where a user can put a package in\nthe package search path of an application of another user, due to how the\nNode.js resolver algorithm works.\n\n#### Legacy opt-in for performance\n\nIf you are running on an old version of Node.js (prior to v18.14.0), ws also\nsupports the [utf-8-validate][] module:\n\n```\nnpm install --save-optional utf-8-validate\n```\n\nThis contains a binary polyfill for [`buffer.isUtf8()`][].\n\nTo force ws not to use utf-8-validate, use the\n[`WS_NO_UTF_8_VALIDATE`](./doc/ws.md#ws_no_utf_8_validate) environment variable.\n\n## API docs\n\nSee [`/doc/ws.md`](./doc/ws.md) for Node.js-like documentation of ws classes and\nutility functions.\n\n## WebSocket compression\n\nws supports the [permessage-deflate extension][permessage-deflate] which enables\nthe client and server to negotiate a compression algorithm and its parameters,\nand then selectively apply it to the data payloads of each WebSocket message.\n\nThe extension is disabled by default on the server and enabled by default on the\nclient. It adds a significant overhead in terms of performance and memory\nconsumption so we suggest to enable it only if it is really needed.\n\nNote that Node.js has a variety of issues with high-performance compression,\nwhere increased concurrency, especially on Linux, can lead to [catastrophic\nmemory fragmentation][node-zlib-bug] and slow performance. If you intend to use\npermessage-deflate in production, it is worthwhile to set up a test\nrepresentative of your workload and ensure Node.js/zlib will handle it with\nacceptable performance and memory usage.\n\nTuning of permessage-deflate can be done via the options defined below. You can\nalso use `zlibDeflateOptions` and `zlibInflateOptions`, which is passed directly\ninto the creation of [raw deflate/inflate streams][node-zlib-deflaterawdocs].\n\nSee [the docs][ws-server-options] for more options.\n\n```js\nimport WebSocket, { WebSocketServer } from 'ws';\n\nconst wss = new WebSocketServer({\n  port: 8080,\n  perMessageDeflate: {\n    zlibDeflateOptions: {\n      // See zlib defaults.\n      chunkSize: 1024,\n      memLevel: 7,\n      level: 3\n    },\n    zlibInflateOptions: {\n      chunkSize: 10 * 1024\n    },\n    // Other options settable:\n    clientNoContextTakeover: true, // Defaults to negotiated value.\n    serverNoContextTakeover: true, // Defaults to negotiated value.\n    serverMaxWindowBits: 10, // Defaults to negotiated value.\n    // Below options specified as default values.\n    concurrencyLimit: 10, // Limits zlib concurrency for perf.\n    threshold: 1024 // Size (in bytes) below which messages\n    // should not be compressed if context takeover is disabled.\n  }\n});\n```\n\nThe client will only use the extension if it is supported and enabled on the\nserver. To always disable the extension on the client, set the\n`perMessageDeflate` option to `false`.\n\n```js\nimport WebSocket from 'ws';\n\nconst ws = new WebSocket('ws://www.host.com/path', {\n  perMessageDeflate: false\n});\n```\n\n## Usage examples\n\n### Sending and receiving text data\n\n```js\nimport WebSocket from 'ws';\n\nconst ws = new WebSocket('ws://www.host.com/path');\n\nws.on('error', console.error);\n\nws.on('open', function open() {\n  ws.send('something');\n});\n\nws.on('message', function message(data) {\n  console.log('received: %s', data);\n});\n```\n\n### Sending binary data\n\n```js\nimport WebSocket from 'ws';\n\nconst ws = new WebSocket('ws://www.host.com/path');\n\nws.on('error', console.error);\n\nws.on('open', function open() {\n  const array = new Float32Array(5);\n\n  for (var i = 0; i < array.length; ++i) {\n    array[i] = i / 2;\n  }\n\n  ws.send(array);\n});\n```\n\n### Simple server\n\n```js\nimport { WebSocketServer } from 'ws';\n\nconst wss = new WebSocketServer({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('error', console.error);\n\n  ws.on('message', function message(data) {\n    console.log('received: %s', data);\n  });\n\n  ws.send('something');\n});\n```\n\n### External HTTP/S server\n\n```js\nimport { createServer } from 'https';\nimport { readFileSync } from 'fs';\nimport { WebSocketServer } from 'ws';\n\nconst server = createServer({\n  cert: readFileSync('/path/to/cert.pem'),\n  key: readFileSync('/path/to/key.pem')\n});\nconst wss = new WebSocketServer({ server });\n\nwss.on('connection', function connection(ws) {\n  ws.on('error', console.error);\n\n  ws.on('message', function message(data) {\n    console.log('received: %s', data);\n  });\n\n  ws.send('something');\n});\n\nserver.listen(8080);\n```\n\n### Multiple servers sharing a single HTTP/S server\n\n```js\nimport { createServer } from 'http';\nimport { WebSocketServer } from 'ws';\n\nconst server = createServer();\nconst wss1 = new WebSocketServer({ noServer: true });\nconst wss2 = new WebSocketServer({ noServer: true });\n\nwss1.on('connection', function connection(ws) {\n  ws.on('error', console.error);\n\n  // ...\n});\n\nwss2.on('connection', function connection(ws) {\n  ws.on('error', console.error);\n\n  // ...\n});\n\nserver.on('upgrade', function upgrade(request, socket, head) {\n  const { pathname } = new URL(request.url, 'wss://base.url');\n\n  if (pathname === '/foo') {\n    wss1.handleUpgrade(request, socket, head, function done(ws) {\n      wss1.emit('connection', ws, request);\n    });\n  } else if (pathname === '/bar') {\n    wss2.handleUpgrade(request, socket, head, function done(ws) {\n      wss2.emit('connection', ws, request);\n    });\n  } else {\n    socket.destroy();\n  }\n});\n\nserver.listen(8080);\n```\n\n### Client authentication\n\n```js\nimport { createServer } from 'http';\nimport { WebSocketServer } from 'ws';\n\nfunction onSocketError(err) {\n  console.error(err);\n}\n\nconst server = createServer();\nconst wss = new WebSocketServer({ noServer: true });\n\nwss.on('connection', function connection(ws, request, client) {\n  ws.on('error', console.error);\n\n  ws.on('message', function message(data) {\n    console.log(`Received message ${data} from user ${client}`);\n  });\n});\n\nserver.on('upgrade', function upgrade(request, socket, head) {\n  socket.on('error', onSocketError);\n\n  // This function is not defined on purpose. Implement it with your own logic.\n  authenticate(request, function next(err, client) {\n    if (err || !client) {\n      socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n      socket.destroy();\n      return;\n    }\n\n    socket.removeListener('error', onSocketError);\n\n    wss.handleUpgrade(request, socket, head, function done(ws) {\n      wss.emit('connection', ws, request, client);\n    });\n  });\n});\n\nserver.listen(8080);\n```\n\nAlso see the provided [example][session-parse-example] using `express-session`.\n\n### Server broadcast\n\nA client WebSocket broadcasting to all connected WebSocket clients, including\nitself.\n\n```js\nimport WebSocket, { WebSocketServer } from 'ws';\n\nconst wss = new WebSocketServer({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('error', console.error);\n\n  ws.on('message', function message(data, isBinary) {\n    wss.clients.forEach(function each(client) {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(data, { binary: isBinary });\n      }\n    });\n  });\n});\n```\n\nA client WebSocket broadcasting to every other connected WebSocket clients,\nexcluding itself.\n\n```js\nimport WebSocket, { WebSocketServer } from 'ws';\n\nconst wss = new WebSocketServer({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('error', console.error);\n\n  ws.on('message', function message(data, isBinary) {\n    wss.clients.forEach(function each(client) {\n      if (client !== ws && client.readyState === WebSocket.OPEN) {\n        client.send(data, { binary: isBinary });\n      }\n    });\n  });\n});\n```\n\n### Round-trip time\n\n```js\nimport WebSocket from 'ws';\n\nconst ws = new WebSocket('wss://websocket-echo.com/');\n\nws.on('error', console.error);\n\nws.on('open', function open() {\n  console.log('connected');\n  ws.send(Date.now());\n});\n\nws.on('close', function close() {\n  console.log('disconnected');\n});\n\nws.on('message', function message(data) {\n  console.log(`Round-trip time: ${Date.now() - data} ms`);\n\n  setTimeout(function timeout() {\n    ws.send(Date.now());\n  }, 500);\n});\n```\n\n### Use the Node.js streams API\n\n```js\nimport WebSocket, { createWebSocketStream } from 'ws';\n\nconst ws = new WebSocket('wss://websocket-echo.com/');\n\nconst duplex = createWebSocketStream(ws, { encoding: 'utf8' });\n\nduplex.on('error', console.error);\n\nduplex.pipe(process.stdout);\nprocess.stdin.pipe(duplex);\n```\n\n### Other examples\n\nFor a full example with a browser client communicating with a ws server, see the\nexamples folder.\n\nOtherwise, see the test cases.\n\n## FAQ\n\n### How to get the IP address of the client?\n\nThe remote IP address can be obtained from the raw socket.\n\n```js\nimport { WebSocketServer } from 'ws';\n\nconst wss = new WebSocketServer({ port: 8080 });\n\nwss.on('connection', function connection(ws, req) {\n  const ip = req.socket.remoteAddress;\n\n  ws.on('error', console.error);\n});\n```\n\nWhen the server runs behind a proxy like NGINX, the de-facto standard is to use\nthe `X-Forwarded-For` header.\n\n```js\nwss.on('connection', function connection(ws, req) {\n  const ip = req.headers['x-forwarded-for'].split(',')[0].trim();\n\n  ws.on('error', console.error);\n});\n```\n\n### How to detect and close broken connections?\n\nSometimes, the link between the server and the client can be interrupted in a\nway that keeps both the server and the client unaware of the broken state of the\nconnection (e.g. when pulling the cord).\n\nIn these cases, ping messages can be used as a means to verify that the remote\nendpoint is still responsive.\n\n```js\nimport { WebSocketServer } from 'ws';\n\nfunction heartbeat() {\n  this.isAlive = true;\n}\n\nconst wss = new WebSocketServer({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n  ws.isAlive = true;\n  ws.on('error', console.error);\n  ws.on('pong', heartbeat);\n});\n\nconst interval = setInterval(function ping() {\n  wss.clients.forEach(function each(ws) {\n    if (ws.isAlive === false) return ws.terminate();\n\n    ws.isAlive = false;\n    ws.ping();\n  });\n}, 30000);\n\nwss.on('close', function close() {\n  clearInterval(interval);\n});\n```\n\nPong messages are automatically sent in response to ping messages as required by\nthe spec.\n\nJust like the server example above, your clients might as well lose connection\nwithout knowing it. You might want to add a ping listener on your clients to\nprevent that. A simple implementation would be:\n\n```js\nimport WebSocket from 'ws';\n\nfunction heartbeat() {\n  clearTimeout(this.pingTimeout);\n\n  // Use `WebSocket#terminate()`, which immediately destroys the connection,\n  // instead of `WebSocket#close()`, which waits for the close timer.\n  // Delay should be equal to the interval at which your server\n  // sends out pings plus a conservative assumption of the latency.\n  this.pingTimeout = setTimeout(() => {\n    this.terminate();\n  }, 30000 + 1000);\n}\n\nconst client = new WebSocket('wss://websocket-echo.com/');\n\nclient.on('error', console.error);\nclient.on('open', heartbeat);\nclient.on('ping', heartbeat);\nclient.on('close', function clear() {\n  clearTimeout(this.pingTimeout);\n});\n```\n\n### How to connect via a proxy?\n\nUse a custom `http.Agent` implementation like [https-proxy-agent][] or\n[socks-proxy-agent][].\n\n## Changelog\n\nWe're using the GitHub [releases][changelog] for changelog entries.\n\n## License\n\n[MIT](LICENSE)\n\n[`buffer.isutf8()`]: https://nodejs.org/api/buffer.html#bufferisutf8input\n[bufferutil]: https://github.com/websockets/bufferutil\n[changelog]: https://github.com/websockets/ws/releases\n[client-report]: http://websockets.github.io/ws/autobahn/clients/\n[https-proxy-agent]: https://github.com/TooTallNate/node-https-proxy-agent\n[node-zlib-bug]: https://github.com/nodejs/node/issues/8871\n[node-zlib-deflaterawdocs]:\n  https://nodejs.org/api/zlib.html#zlib_zlib_createdeflateraw_options\n[permessage-deflate]: https://tools.ietf.org/html/rfc7692\n[server-report]: http://websockets.github.io/ws/autobahn/servers/\n[session-parse-example]: ./examples/express-session-parse\n[socks-proxy-agent]: https://github.com/TooTallNate/node-socks-proxy-agent\n[utf-8-validate]: https://github.com/websockets/utf-8-validate\n[ws-server-options]: ./doc/ws.md#new-websocketserveroptions-callback\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 1.9150390625,
          "content": "# Security Guidelines\n\nPlease contact us directly at **security@3rd-Eden.com** for any bug that might\nimpact the security of this project. Please prefix the subject of your email\nwith `[security]` in lowercase and square brackets. Our email filters will\nautomatically prevent these messages from being moved to our spam box.\n\nYou will receive an acknowledgement of your report within **24 hours**.\n\nAll emails that do not include security vulnerabilities will be removed and\nblocked instantly.\n\n## Exceptions\n\nIf you do not receive an acknowledgement within the said time frame, please give\nus the benefit of the doubt as it's possible that we haven't seen it yet. In\nthis case, please send us a message **without details** using one of the\nfollowing methods:\n\n- Contact the lead developers of this project on their personal e-mails. You can\n  find the e-mails in the git logs, for example, using the following command:\n  `git --no-pager show -s --format='%an <%ae>' <gitsha>` where `<gitsha>` is the\n  SHA1 of their latest commit in the project.\n- Create a GitHub issue stating contact details and the severity of the issue.\n\nOnce we have acknowledged receipt of your report and confirmed the bug\nourselves, we will work with you to fix the vulnerability and publicly\nacknowledge your responsible disclosure, if you wish. In addition to that, we\nwill create and publish a security advisory to\n[GitHub Security Advisories](https://github.com/websockets/ws/security/advisories?state=published).\n\n## History\n\n- 04 Jan 2016:\n  [Buffer vulnerability](https://github.com/websockets/ws/releases/tag/1.0.1)\n- 08 Nov 2017:\n  [DoS in the `Sec-Websocket-Extensions` header parser](https://github.com/websockets/ws/releases/tag/3.3.1)\n- 25 May 2021:\n  [ReDoS in `Sec-Websocket-Protocol` header](https://github.com/websockets/ws/releases/tag/7.4.6)\n- 16 Jun 2024:\n  [DoS when handling a request with many HTTP headers](https://github.com/websockets/ws/releases/tag/8.17.1)\n"
        },
        {
          "name": "bench",
          "type": "tree",
          "content": null
        },
        {
          "name": "browser.js",
          "type": "blob",
          "size": 0.171875,
          "content": "'use strict';\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "eslint.config.js",
          "type": "blob",
          "size": 0.6611328125,
          "content": "'use strict';\n\nconst pluginPrettierRecommended = require('eslint-plugin-prettier/recommended');\nconst globals = require('globals');\nconst js = require('@eslint/js');\n\nmodule.exports = [\n  js.configs.recommended,\n  {\n    ignores: ['.nyc_output/', '.vscode/', 'coverage/', 'node_modules/'],\n    languageOptions: {\n      ecmaVersion: 'latest',\n      globals: {\n        ...globals.browser,\n        ...globals.mocha,\n        ...globals.node\n      },\n      sourceType: 'module'\n    },\n    rules: {\n      'no-console': 'off',\n      'no-unused-vars': ['error', { caughtErrors: 'none' }],\n      'no-var': 'error',\n      'prefer-const': 'error'\n    }\n  },\n  pluginPrettierRecommended\n];\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 0.3671875,
          "content": "'use strict';\n\nconst WebSocket = require('./lib/websocket');\n\nWebSocket.createWebSocketStream = require('./lib/stream');\nWebSocket.Server = require('./lib/websocket-server');\nWebSocket.Receiver = require('./lib/receiver');\nWebSocket.Sender = require('./lib/sender');\n\nWebSocket.WebSocket = WebSocket;\nWebSocket.WebSocketServer = WebSocket.Server;\n\nmodule.exports = WebSocket;\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.681640625,
          "content": "{\n  \"name\": \"ws\",\n  \"version\": \"8.18.0\",\n  \"description\": \"Simple to use, blazing fast and thoroughly tested websocket client and server for Node.js\",\n  \"keywords\": [\n    \"HyBi\",\n    \"Push\",\n    \"RFC-6455\",\n    \"WebSocket\",\n    \"WebSockets\",\n    \"real-time\"\n  ],\n  \"homepage\": \"https://github.com/websockets/ws\",\n  \"bugs\": \"https://github.com/websockets/ws/issues\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/websockets/ws.git\"\n  },\n  \"author\": \"Einar Otto Stangvik <einaros@gmail.com> (http://2x.io)\",\n  \"license\": \"MIT\",\n  \"main\": \"index.js\",\n  \"exports\": {\n    \".\": {\n      \"browser\": \"./browser.js\",\n      \"import\": \"./wrapper.mjs\",\n      \"require\": \"./index.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"browser\": \"browser.js\",\n  \"engines\": {\n    \"node\": \">=10.0.0\"\n  },\n  \"files\": [\n    \"browser.js\",\n    \"index.js\",\n    \"lib/*.js\",\n    \"wrapper.mjs\"\n  ],\n  \"scripts\": {\n    \"test\": \"nyc --reporter=lcov --reporter=text mocha --throw-deprecation test/*.test.js\",\n    \"integration\": \"mocha --throw-deprecation test/*.integration.js\",\n    \"lint\": \"eslint . && prettier --check --ignore-path .gitignore \\\"**/*.{json,md,yaml,yml}\\\"\"\n  },\n  \"peerDependencies\": {\n    \"bufferutil\": \"^4.0.1\",\n    \"utf-8-validate\": \">=5.0.2\"\n  },\n  \"peerDependenciesMeta\": {\n    \"bufferutil\": {\n      \"optional\": true\n    },\n    \"utf-8-validate\": {\n      \"optional\": true\n    }\n  },\n  \"devDependencies\": {\n    \"benchmark\": \"^2.1.4\",\n    \"bufferutil\": \"^4.0.1\",\n    \"eslint\": \"^9.0.0\",\n    \"eslint-config-prettier\": \"^9.0.0\",\n    \"eslint-plugin-prettier\": \"^5.0.0\",\n    \"globals\": \"^15.0.0\",\n    \"mocha\": \"^8.4.0\",\n    \"nyc\": \"^15.0.0\",\n    \"prettier\": \"^3.0.0\",\n    \"utf-8-validate\": \"^6.0.0\"\n  }\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "wrapper.mjs",
          "type": "blob",
          "size": 0.3330078125,
          "content": "import createWebSocketStream from './lib/stream.js';\nimport Receiver from './lib/receiver.js';\nimport Sender from './lib/sender.js';\nimport WebSocket from './lib/websocket.js';\nimport WebSocketServer from './lib/websocket-server.js';\n\nexport { createWebSocketStream, Receiver, Sender, WebSocket, WebSocketServer };\nexport default WebSocket;\n"
        }
      ]
    }
  ]
}