{
  "metadata": {
    "timestamp": 1736563219233,
    "page": 174,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pedroslopez/whatsapp-web.js",
      "stars": 15845,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1279296875,
          "content": "root = true\n\n[*]\nindent_style = space\nindent_size = 4\ncharset = utf-8\ntrim_trailing_whitespace = false\ninsert_final_newline = false"
        },
        {
          "name": ".env.example",
          "type": "blob",
          "size": 0.087890625,
          "content": "WWEBJS_TEST_REMOTE_ID=XXXXXXXXXX@c.us\nWWEBJS_TEST_CLIENT_ID=authenticated\nWWEBJS_TEST_MD=1"
        },
        {
          "name": ".eslintrc.json",
          "type": "blob",
          "size": 0.6875,
          "content": "{\n    \"env\": {\n        \"browser\": true,\n        \"commonjs\": true,\n        \"es6\": true,\n        \"node\": true\n    },\n    \"extends\": [\"eslint:recommended\", \"plugin:mocha/recommended\"],\n    \"globals\": {\n        \"Atomics\": \"readonly\",\n        \"SharedArrayBuffer\": \"readonly\"\n    },\n    \"parserOptions\": {\n        \"ecmaVersion\": 2020\n    },\n    \"plugins\": [\"mocha\"],\n    \"ignorePatterns\": [\"docs\"],\n    \"rules\": {\n        \"indent\": [\n            \"error\",\n            4\n        ],\n        \"linebreak-style\": [\n            \"error\",\n            \"unix\"\n        ],\n        \"quotes\": [\n            \"error\",\n            \"single\"\n        ],\n        \"semi\": [\n            \"error\",\n            \"always\"\n        ]\n    }\n}"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.05859375,
          "content": "# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# Bower dependency directory (https://bower.io/)\nbower_components\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (https://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules/\njspm_packages/\n\n# Lock files\npackage-lock.json\nyarn.lock\n\n# TypeScript v1 declaration files\ntypings/\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Yarn Integrity file\n.yarn-integrity\n\n# dotenv environment variables file\n.env\n\n# next.js build output\n.next\n\n# macOS\n._*\n.DS_Store\n\n# Test sessions\n*session.json\n.wwebjs_auth/\n\n# local version cache\n.wwebjs_cache/\n\n# IDE's\n.idea\n.vscode"
        },
        {
          "name": ".jsdoc.json",
          "type": "blob",
          "size": 0.6083984375,
          "content": "{\n    \"tags\": {\n        \"allowUnknownTags\": true,\n        \"dictionaries\": [\"jsdoc\"]\n    },\n    \"source\": {\n        \"include\": [\"src\", \"package.json\", \"README.md\"],\n        \"includePattern\": \".js$\",\n        \"excludePattern\": \"(node_modules/|docs)\"\n    },\n    \"plugins\": [\n        \"plugins/markdown\"\n    ],\n    \"templates\": {\n        \"cleverLinks\": false,\n        \"monospaceLinks\": true,\n        \"useLongnameInNav\": false,\n        \"showInheritedInNav\": true\n    },\n    \"opts\": {\n        \"destination\": \"./docs/\",\n        \"encoding\": \"utf8\",\n        \"recurse\": true,\n        \"template\": \"./node_modules/jsdoc-baseline\"\n    }\n}"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.177734375,
          "content": "docs/*\n.github/*\n\n.eslintrc.json\n.jsdoc.json\n.editorconfig\n\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n*session.json\n.wwebjs_auth/\n.wwebjs_cache/\n\n.env\ntools/\ntests/\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.373046875,
          "content": "\n# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\n[pedroslopez@me.com](mailto:pedroslopez@me.com).\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\n[https://www.contributor-covenant.org/version/2/0/code_of_conduct.html][v2.0].\n\nCommunity Impact Guidelines were inspired by \n[Mozilla's code of conduct enforcement ladder][Mozilla CoC].\n\nFor answers to common questions about this code of conduct, see the FAQ at\n[https://www.contributor-covenant.org/faq][FAQ]. Translations are available \nat [https://www.contributor-covenant.org/translations][translations].\n\n[homepage]: https://www.contributor-covenant.org\n[v2.0]: https://www.contributor-covenant.org/version/2/0/code_of_conduct.html\n[Mozilla CoC]: https://github.com/mozilla/diversity\n[FAQ]: https://www.contributor-covenant.org/faq\n[translations]: https://www.contributor-covenant.org/translations\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0771484375,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2019 Pedro S Lopez\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.966796875,
          "content": "<div align=\"center\">\n    <br />\n    <p>\n        <a href=\"https://wwebjs.dev\"><img src=\"https://github.com/wwebjs/logos/blob/main/4_Full%20Logo%20Lockup_Small/small_banner_blue.png?raw=true\" title=\"whatsapp-web.js\" alt=\"WWebJS Website\" width=\"500\" /></a>\n    </p>\n    <br />\n    <p>\n\t\t<a href=\"https://www.npmjs.com/package/whatsapp-web.js\"><img src=\"https://img.shields.io/npm/v/whatsapp-web.js.svg\" alt=\"npm\" /></a>\n        <a href=\"https://depfu.com/github/pedroslopez/whatsapp-web.js?project_id=9765\"><img src=\"https://badges.depfu.com/badges/4a65a0de96ece65fdf39e294e0c8dcba/overview.svg\" alt=\"Depfu\" /></a>\n        <img src=\"https://img.shields.io/badge/WhatsApp_Web-2.3000.1017054665-brightgreen.svg\" alt=\"WhatsApp_Web 2.2346.52\" />\n        <a href=\"https://discord.gg/H7DqQs4\"><img src=\"https://img.shields.io/discord/698610475432411196.svg?logo=discord\" alt=\"Discord server\" /></a>\n\t</p>\n    <br />\n</div>\n\n## About\n**A WhatsApp API client that connects through the WhatsApp Web browser app**\n\nThe library works by launching the WhatsApp Web browser application and managing it using Puppeteer to create an instance of WhatsApp Web, thereby mitigating the risk of being blocked. The WhatsApp API client connects through the WhatsApp Web browser app, accessing its internal functions. This grants you access to nearly all the features available on WhatsApp Web, enabling dynamic handling similar to any other Node.js application.\n\n> [!IMPORTANT]\n> **It is not guaranteed you will not be blocked by using this method. WhatsApp does not allow bots or unofficial clients on their platform, so this shouldn't be considered totally safe.**\n\n## Links\n\n* [Website][website]\n* [Guide][guide] ([source][guide-source]) _(work in progress)_\n* [Documentation][documentation] ([source][documentation-source])\n* [WWebJS Discord][discord]\n* [GitHub][gitHub]\n* [npm][npm]\n\n## Installation\n\nThe module is now available on npm! `npm i whatsapp-web.js`\n\n> [!NOTE]\n> **Node ``v18+`` is required.**\n\n## QUICK STEPS TO UPGRADE NODE\n\n### Windows\n\n#### Manual\nJust get the latest LTS from the [official node website][nodejs].\n\n#### npm\n```powershell\nsudo npm install -g n\nsudo n stable\n```\n\n#### Choco\n```powershell\nchoco install nodejs-lts\n```\n\n#### Winget\n```powershell\nwinget install OpenJS.NodeJS.LTS\n```\n\n### Ubuntu / Debian\n```bash\ncurl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash - &&\\\nsudo apt-get install -y nodejs\n```\n\n## Example usage\n\n```js\nconst { Client } = require('whatsapp-web.js');\n\nconst client = new Client();\n\nclient.on('qr', (qr) => {\n    // Generate and scan this code with your phone\n    console.log('QR RECEIVED', qr);\n});\n\nclient.on('ready', () => {\n    console.log('Client is ready!');\n});\n\nclient.on('message', msg => {\n    if (msg.body == '!ping') {\n        msg.reply('pong');\n    }\n});\n\nclient.initialize();\n```\n\nTake a look at [example.js][examples] for another examples with additional use cases.  \nFor further details on saving and restoring sessions, explore the provided [Authentication Strategies][auth-strategies].\n\n\n## Supported features\n\n| Feature  | Status |\n| ------------- | ------------- |\n| Multi Device  | âœ…  |\n| Send messages  | âœ…  |\n| Receive messages  | âœ…  |\n| Send media (images/audio/documents)  | âœ…  |\n| Send media (video)  | âœ… [(requires Google Chrome)][google-chrome]  |\n| Send stickers | âœ… |\n| Receive media (images/audio/video/documents)  | âœ…  |\n| Send contact cards | âœ… |\n| Send location | âœ… |\n| Send buttons | âŒ  [(DEPRECATED)][deprecated-video] |\n| Send lists | âŒ  [(DEPRECATED)][deprecated-video] |\n| Receive location | âœ… | \n| Message replies | âœ… |\n| Join groups by invite  | âœ… |\n| Get invite for group  | âœ… |\n| Modify group info (subject, description)  | âœ…  |\n| Modify group settings (send messages, edit info)  | âœ…  |\n| Add group participants  | âœ…  |\n| Kick group participants  | âœ…  |\n| Promote/demote group participants | âœ… |\n| Mention users | âœ… |\n| Mention groups | âœ… |\n| Mute/unmute chats | âœ… |\n| Block/unblock contacts | âœ… |\n| Get contact info | âœ… |\n| Get profile pictures | âœ… |\n| Set user status message | âœ… |\n| React to messages | âœ… |\n| Create polls | âœ… |\n| Vote in polls | ðŸ”œ |\n| Communities | ðŸ”œ |\n| Channels | ðŸ”œ |\n\nSomething missing? Make an issue and let us know!\n\n## Contributing\n\nFeel free to open pull requests; we welcome contributions! However, for significant changes, it's best to open an issue beforehand. Make sure to review our [contribution guidelines][contributing] before creating a pull request. Before creating your own issue or pull request, always check to see if one already exists!\n\n## Supporting the project\n\nYou can support the maintainer of this project through the links below\n\n- [Support via GitHub Sponsors][gitHub-sponsors]\n- [Support via PayPal][support-payPal]\n- [Sign up for DigitalOcean][digitalocean] and get $200 in credit when you sign up (Referral)\n\n## Disclaimer\n\nThis project is not affiliated, associated, authorized, endorsed by, or in any way officially connected with WhatsApp or any of its subsidiaries or its affiliates. The official WhatsApp website can be found at [whatsapp.com][whatsapp]. \"WhatsApp\" as well as related names, marks, emblems and images are registered trademarks of their respective owners. Also it is not guaranteed you will not be blocked by using this method. WhatsApp does not allow bots or unofficial clients on their platform, so this shouldn't be considered totally safe.\n\n## License\n\nCopyright 2019 Pedro S Lopez  \n\nLicensed under the Apache License, Version 2.0 (the \"License\");  \nyou may not use this project except in compliance with the License.  \nYou may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  \n\nUnless required by applicable law or agreed to in writing, software  \ndistributed under the License is distributed on an \"AS IS\" BASIS,  \nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  \nSee the License for the specific language governing permissions and  \nlimitations under the License.  \n\n\n[website]: https://wwebjs.dev\n[guide]: https://guide.wwebjs.dev/guide\n[guide-source]: https://github.com/wwebjs/wwebjs.dev/tree/main\n[documentation]: https://docs.wwebjs.dev/\n[documentation-source]: https://github.com/pedroslopez/whatsapp-web.js/tree/main/docs\n[discord]: https://discord.gg/H7DqQs4\n[gitHub]: https://github.com/pedroslopez/whatsapp-web.js\n[npm]: https://npmjs.org/package/whatsapp-web.js\n[nodejs]: https://nodejs.org/en/download/\n[examples]: https://github.com/pedroslopez/whatsapp-web.js/blob/master/example.js\n[auth-strategies]: https://wwebjs.dev/guide/creating-your-bot/authentication.html\n[google-chrome]: https://wwebjs.dev/guide/creating-your-bot/handling-attachments.html#caveat-for-sending-videos-and-gifs\n[deprecated-video]: https://www.youtube.com/watch?v=hv1R1rLeVVE\n[gitHub-sponsors]: https://github.com/sponsors/pedroslopez\n[support-payPal]: https://www.paypal.me/psla/\n[digitalocean]: https://m.do.co/c/73f906a36ed4\n[contributing]: https://github.com/pedroslopez/whatsapp-web.js/blob/main/CODE_OF_CONDUCT.md\n[whatsapp]: https://whatsapp.com\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "example.js",
          "type": "blob",
          "size": 25.443359375,
          "content": "const { Client, Location, Poll, List, Buttons, LocalAuth } = require('./index');\n\nconst client = new Client({\n    authStrategy: new LocalAuth(),\n    // proxyAuthentication: { username: 'username', password: 'password' },\n    puppeteer: { \n        // args: ['--proxy-server=proxy-server-that-requires-authentication.example.com'],\n        headless: false,\n    }\n});\n\n// client initialize does not finish at ready now.\nclient.initialize();\n\nclient.on('loading_screen', (percent, message) => {\n    console.log('LOADING SCREEN', percent, message);\n});\n\n// Pairing code only needs to be requested once\nlet pairingCodeRequested = false;\nclient.on('qr', async (qr) => {\n    // NOTE: This event will not be fired if a session is specified.\n    console.log('QR RECEIVED', qr);\n\n    // paiuting code example\n    const pairingCodeEnabled = false;\n    if (pairingCodeEnabled && !pairingCodeRequested) {\n        const pairingCode = await client.requestPairingCode('96170100100'); // enter the target phone number\n        console.log('Pairing code enabled, code: '+ pairingCode);\n        pairingCodeRequested = true;\n    }\n});\n\nclient.on('authenticated', () => {\n    console.log('AUTHENTICATED');\n});\n\nclient.on('auth_failure', msg => {\n    // Fired if session restore was unsuccessful\n    console.error('AUTHENTICATION FAILURE', msg);\n});\n\nclient.on('ready', async () => {\n    console.log('READY');\n    const debugWWebVersion = await client.getWWebVersion();\n    console.log(`WWebVersion = ${debugWWebVersion}`);\n\n    client.pupPage.on('pageerror', function(err) {\n        console.log('Page error: ' + err.toString());\n    });\n    client.pupPage.on('error', function(err) {\n        console.log('Page error: ' + err.toString());\n    });\n    \n});\n\nclient.on('message', async msg => {\n    console.log('MESSAGE RECEIVED', msg);\n\n    if (msg.body === '!ping reply') {\n        // Send a new message as a reply to the current one\n        msg.reply('pong');\n\n    } else if (msg.body === '!ping') {\n        // Send a new message to the same chat\n        client.sendMessage(msg.from, 'pong');\n\n    } else if (msg.body.startsWith('!sendto ')) {\n        // Direct send a new message to specific id\n        let number = msg.body.split(' ')[1];\n        let messageIndex = msg.body.indexOf(number) + number.length;\n        let message = msg.body.slice(messageIndex, msg.body.length);\n        number = number.includes('@c.us') ? number : `${number}@c.us`;\n        let chat = await msg.getChat();\n        chat.sendSeen();\n        client.sendMessage(number, message);\n\n    } else if (msg.body.startsWith('!subject ')) {\n        // Change the group subject\n        let chat = await msg.getChat();\n        if (chat.isGroup) {\n            let newSubject = msg.body.slice(9);\n            chat.setSubject(newSubject);\n        } else {\n            msg.reply('This command can only be used in a group!');\n        }\n    } else if (msg.body.startsWith('!echo ')) {\n        // Replies with the same message\n        msg.reply(msg.body.slice(6));\n    } else if (msg.body.startsWith('!preview ')) {\n        const text = msg.body.slice(9);\n        msg.reply(text, null, { linkPreview: true });\n    } else if (msg.body.startsWith('!desc ')) {\n        // Change the group description\n        let chat = await msg.getChat();\n        if (chat.isGroup) {\n            let newDescription = msg.body.slice(6);\n            chat.setDescription(newDescription);\n        } else {\n            msg.reply('This command can only be used in a group!');\n        }\n    } else if (msg.body === '!leave') {\n        // Leave the group\n        let chat = await msg.getChat();\n        if (chat.isGroup) {\n            chat.leave();\n        } else {\n            msg.reply('This command can only be used in a group!');\n        }\n    } else if (msg.body.startsWith('!join ')) {\n        const inviteCode = msg.body.split(' ')[1];\n        try {\n            await client.acceptInvite(inviteCode);\n            msg.reply('Joined the group!');\n        } catch (e) {\n            msg.reply('That invite code seems to be invalid.');\n        }\n    } else if (msg.body.startsWith('!addmembers')) {\n        const group = await msg.getChat();\n        const result = await group.addParticipants(['number1@c.us', 'number2@c.us', 'number3@c.us']);\n        /**\n         * The example of the {@link result} output:\n         *\n         * {\n         *   'number1@c.us': {\n         *     code: 200,\n         *     message: 'The participant was added successfully',\n         *     isInviteV4Sent: false\n         *   },\n         *   'number2@c.us': {\n         *     code: 403,\n         *     message: 'The participant can be added by sending private invitation only',\n         *     isInviteV4Sent: true\n         *   },\n         *   'number3@c.us': {\n         *     code: 404,\n         *     message: 'The phone number is not registered on WhatsApp',\n         *     isInviteV4Sent: false\n         *   }\n         * }\n         *\n         * For more usage examples:\n         * @see https://github.com/pedroslopez/whatsapp-web.js/pull/2344#usage-example1\n         */\n        console.log(result);\n    } else if (msg.body === '!creategroup') {\n        const partitipantsToAdd = ['number1@c.us', 'number2@c.us', 'number3@c.us'];\n        const result = await client.createGroup('Group Title', partitipantsToAdd);\n        /**\n         * The example of the {@link result} output:\n         * {\n         *   title: 'Group Title',\n         *   gid: {\n         *     server: 'g.us',\n         *     user: '1111111111',\n         *     _serialized: '1111111111@g.us'\n         *   },\n         *   participants: {\n         *     'botNumber@c.us': {\n         *       statusCode: 200,\n         *       message: 'The participant was added successfully',\n         *       isGroupCreator: true,\n         *       isInviteV4Sent: false\n         *     },\n         *     'number1@c.us': {\n         *       statusCode: 200,\n         *       message: 'The participant was added successfully',\n         *       isGroupCreator: false,\n         *       isInviteV4Sent: false\n         *     },\n         *     'number2@c.us': {\n         *       statusCode: 403,\n         *       message: 'The participant can be added by sending private invitation only',\n         *       isGroupCreator: false,\n         *       isInviteV4Sent: true\n         *     },\n         *     'number3@c.us': {\n         *       statusCode: 404,\n         *       message: 'The phone number is not registered on WhatsApp',\n         *       isGroupCreator: false,\n         *       isInviteV4Sent: false\n         *     }\n         *   }\n         * }\n         *\n         * For more usage examples:\n         * @see https://github.com/pedroslopez/whatsapp-web.js/pull/2344#usage-example2\n         */\n        console.log(result);\n    } else if (msg.body === '!groupinfo') {\n        let chat = await msg.getChat();\n        if (chat.isGroup) {\n            msg.reply(`\n                *Group Details*\n                Name: ${chat.name}\n                Description: ${chat.description}\n                Created At: ${chat.createdAt.toString()}\n                Created By: ${chat.owner.user}\n                Participant count: ${chat.participants.length}\n            `);\n        } else {\n            msg.reply('This command can only be used in a group!');\n        }\n    } else if (msg.body === '!chats') {\n        const chats = await client.getChats();\n        client.sendMessage(msg.from, `The bot has ${chats.length} chats open.`);\n    } else if (msg.body === '!info') {\n        let info = client.info;\n        client.sendMessage(msg.from, `\n            *Connection info*\n            User name: ${info.pushname}\n            My number: ${info.wid.user}\n            Platform: ${info.platform}\n        `);\n    } else if (msg.body === '!mediainfo' && msg.hasMedia) {\n        const attachmentData = await msg.downloadMedia();\n        msg.reply(`\n            *Media info*\n            MimeType: ${attachmentData.mimetype}\n            Filename: ${attachmentData.filename}\n            Data (length): ${attachmentData.data.length}\n        `);\n    } else if (msg.body === '!quoteinfo' && msg.hasQuotedMsg) {\n        const quotedMsg = await msg.getQuotedMessage();\n\n        quotedMsg.reply(`\n            ID: ${quotedMsg.id._serialized}\n            Type: ${quotedMsg.type}\n            Author: ${quotedMsg.author || quotedMsg.from}\n            Timestamp: ${quotedMsg.timestamp}\n            Has Media? ${quotedMsg.hasMedia}\n        `);\n    } else if (msg.body === '!resendmedia' && msg.hasQuotedMsg) {\n        const quotedMsg = await msg.getQuotedMessage();\n        if (quotedMsg.hasMedia) {\n            const attachmentData = await quotedMsg.downloadMedia();\n            client.sendMessage(msg.from, attachmentData, { caption: 'Here\\'s your requested media.' });\n        }\n        if (quotedMsg.hasMedia && quotedMsg.type === 'audio') {\n            const audio = await quotedMsg.downloadMedia();\n            await client.sendMessage(msg.from, audio, { sendAudioAsVoice: true });\n        }\n    } else if (msg.body === '!isviewonce' && msg.hasQuotedMsg) {\n        const quotedMsg = await msg.getQuotedMessage();\n        if (quotedMsg.hasMedia) {\n            const media = await quotedMsg.downloadMedia();\n            await client.sendMessage(msg.from, media, { isViewOnce: true });\n        }\n    } else if (msg.body === '!location') {\n        // only latitude and longitude\n        await msg.reply(new Location(37.422, -122.084));\n        // location with name only\n        await msg.reply(new Location(37.422, -122.084, { name: 'Googleplex' }));\n        // location with address only\n        await msg.reply(new Location(37.422, -122.084, { address: '1600 Amphitheatre Pkwy, Mountain View, CA 94043, USA' }));\n        // location with name, address and url\n        await msg.reply(new Location(37.422, -122.084, { name: 'Googleplex', address: '1600 Amphitheatre Pkwy, Mountain View, CA 94043, USA', url: 'https://google.com' }));\n    } else if (msg.location) {\n        msg.reply(msg.location);\n    } else if (msg.body.startsWith('!status ')) {\n        const newStatus = msg.body.split(' ')[1];\n        await client.setStatus(newStatus);\n        msg.reply(`Status was updated to *${newStatus}*`);\n    } else if (msg.body === '!mentionUsers') {\n        const chat = await msg.getChat();\n        const userNumber = 'XXXXXXXXXX';\n        /**\n         * To mention one user you can pass user's ID to 'mentions' property as is,\n         * without wrapping it in Array, and a user's phone number to the message body:\n         */\n        await chat.sendMessage(`Hi @${userNumber}`, {\n            mentions: userNumber + '@c.us'\n        });\n        // To mention a list of users:\n        await chat.sendMessage(`Hi @${userNumber}, @${userNumber}`, {\n            mentions: [userNumber + '@c.us', userNumber + '@c.us']\n        });\n    } else if (msg.body === '!mentionGroups') {\n        const chat = await msg.getChat();\n        const groupId = 'YYYYYYYYYY@g.us';\n        /**\n         * Sends clickable group mentions, the same as user mentions.\n         * When the mentions are clicked, it opens a chat with the mentioned group.\n         * The 'groupMentions.subject' can be custom\n         * \n         * @note The user that does not participate in the mentioned group,\n         * will not be able to click on that mentioned group, the same if the group does not exist\n         *\n         * To mention one group:\n         */\n        await chat.sendMessage(`Check the last message here: @${groupId}`, {\n            groupMentions: { subject: 'GroupSubject', id: groupId }\n        });\n        // To mention a list of groups:\n        await chat.sendMessage(`Check the last message in these groups: @${groupId}, @${groupId}`, {\n            groupMentions: [\n                { subject: 'FirstGroup', id: groupId },\n                { subject: 'SecondGroup', id: groupId }\n            ]\n        });\n    } else if (msg.body === '!getGroupMentions') {\n        // To get group mentions from a message:\n        const groupId = 'ZZZZZZZZZZ@g.us';\n        const msg = await client.sendMessage('chatId', `Check the last message here: @${groupId}`, {\n            groupMentions: { subject: 'GroupSubject', id: groupId }\n        });\n        /** {@link groupMentions} is an array of `GroupChat` */\n        const groupMentions = await msg.getGroupMentions();\n        console.log(groupMentions);\n    } else if (msg.body === '!delete') {\n        if (msg.hasQuotedMsg) {\n            const quotedMsg = await msg.getQuotedMessage();\n            if (quotedMsg.fromMe) {\n                quotedMsg.delete(true);\n            } else {\n                msg.reply('I can only delete my own messages');\n            }\n        }\n    } else if (msg.body === '!pin') {\n        const chat = await msg.getChat();\n        await chat.pin();\n    } else if (msg.body === '!archive') {\n        const chat = await msg.getChat();\n        await chat.archive();\n    } else if (msg.body === '!mute') {\n        const chat = await msg.getChat();\n        // mute the chat for 20 seconds\n        const unmuteDate = new Date();\n        unmuteDate.setSeconds(unmuteDate.getSeconds() + 20);\n        await chat.mute(unmuteDate);\n    } else if (msg.body === '!typing') {\n        const chat = await msg.getChat();\n        // simulates typing in the chat\n        chat.sendStateTyping();\n    } else if (msg.body === '!recording') {\n        const chat = await msg.getChat();\n        // simulates recording audio in the chat\n        chat.sendStateRecording();\n    } else if (msg.body === '!clearstate') {\n        const chat = await msg.getChat();\n        // stops typing or recording in the chat\n        chat.clearState();\n    } else if (msg.body === '!jumpto') {\n        if (msg.hasQuotedMsg) {\n            const quotedMsg = await msg.getQuotedMessage();\n            client.interface.openChatWindowAt(quotedMsg.id._serialized);\n        }\n    } else if (msg.body === '!buttons') {\n        let button = new Buttons('Button body', [{ body: 'bt1' }, { body: 'bt2' }, { body: 'bt3' }], 'title', 'footer');\n        client.sendMessage(msg.from, button);\n    } else if (msg.body === '!list') {\n        let sections = [\n            { title: 'sectionTitle', rows: [{ title: 'ListItem1', description: 'desc' }, { title: 'ListItem2' }] }\n        ];\n        let list = new List('List body', 'btnText', sections, 'Title', 'footer');\n        client.sendMessage(msg.from, list);\n    } else if (msg.body === '!reaction') {\n        msg.react('ðŸ‘');\n    } else if (msg.body === '!sendpoll') {\n        /** By default the poll is created as a single choice poll: */\n        await msg.reply(new Poll('Winter or Summer?', ['Winter', 'Summer']));\n        /** If you want to provide a multiple choice poll, add allowMultipleAnswers as true: */\n        await msg.reply(new Poll('Cats or Dogs?', ['Cats', 'Dogs'], { allowMultipleAnswers: true }));\n        /**\n         * You can provide a custom message secret, it can be used as a poll ID:\n         * @note It has to be a unique vector with a length of 32\n         */\n        await msg.reply(\n            new Poll('Cats or Dogs?', ['Cats', 'Dogs'], {\n                messageSecret: [\n                    1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n                ]\n            })\n        );\n    } else if (msg.body === '!edit') {\n        if (msg.hasQuotedMsg) {\n            const quotedMsg = await msg.getQuotedMessage();\n            if (quotedMsg.fromMe) {\n                quotedMsg.edit(msg.body.replace('!edit', ''));\n            } else {\n                msg.reply('I can only edit my own messages');\n            }\n        }\n    } else if (msg.body === '!updatelabels') {\n        const chat = await msg.getChat();\n        await chat.changeLabels([0, 1]);\n    } else if (msg.body === '!addlabels') {\n        const chat = await msg.getChat();\n        let labels = (await chat.getLabels()).map((l) => l.id);\n        labels.push('0');\n        labels.push('1');\n        await chat.changeLabels(labels);\n    } else if (msg.body === '!removelabels') {\n        const chat = await msg.getChat();\n        await chat.changeLabels([]);\n    } else if (msg.body === '!approverequest') {\n        /**\n         * Presented an example for membership request approvals, the same examples are for the request rejections.\n         * To approve the membership request from a specific user:\n         */\n        await client.approveGroupMembershipRequests(msg.from, { requesterIds: 'number@c.us' });\n        /** The same for execution on group object (no need to provide the group ID): */\n        const group = await msg.getChat();\n        await group.approveGroupMembershipRequests({ requesterIds: 'number@c.us' });\n        /** To approve several membership requests: */\n        const approval = await client.approveGroupMembershipRequests(msg.from, {\n            requesterIds: ['number1@c.us', 'number2@c.us']\n        });\n        /**\n         * The example of the {@link approval} output:\n         * [\n         *   {\n         *     requesterId: 'number1@c.us',\n         *     message: 'Rejected successfully'\n         *   },\n         *   {\n         *     requesterId: 'number2@c.us',\n         *     error: 404,\n         *     message: 'ParticipantRequestNotFoundError'\n         *   }\n         * ]\n         *\n         */\n        console.log(approval);\n        /** To approve all the existing membership requests (simply don't provide any user IDs): */\n        await client.approveGroupMembershipRequests(msg.from);\n        /** To change the sleep value to 300 ms: */\n        await client.approveGroupMembershipRequests(msg.from, {\n            requesterIds: ['number1@c.us', 'number2@c.us'],\n            sleep: 300\n        });\n        /** To change the sleep value to random value between 100 and 300 ms: */\n        await client.approveGroupMembershipRequests(msg.from, {\n            requesterIds: ['number1@c.us', 'number2@c.us'],\n            sleep: [100, 300]\n        });\n        /** To explicitly disable the sleep: */\n        await client.approveGroupMembershipRequests(msg.from, {\n            requesterIds: ['number1@c.us', 'number2@c.us'],\n            sleep: null\n        });\n    } else if (msg.body === '!pinmsg') {\n        /**\n         * Pins a message in a chat, a method takes a number in seconds for the message to be pinned.\n         * WhatsApp default values for duration to pass to the method are:\n         * 1. 86400 for 24 hours\n         * 2. 604800 for 7 days\n         * 3. 2592000 for 30 days\n         * You can pass your own value:\n         */\n        const result = await msg.pin(60); // Will pin a message for 1 minute\n        console.log(result); // True if the operation completed successfully, false otherwise\n    } else if (msg.body === '!howManyConnections') {\n        /**\n         * Get user device count by ID\n         * Each WaWeb Connection counts as one device, and the phone (if exists) counts as one\n         * So for a non-enterprise user with one WaWeb connection it should return \"2\"\n         */\n        let deviceCount = await client.getContactDeviceCount(msg.from);\n        await msg.reply(`You have *${deviceCount}* devices connected`);\n    } else if (msg.body === '!syncHistory') {\n        const isSynced = await client.syncHistory(msg.from);\n        // Or through the Chat object:\n        // const chat = await client.getChatById(msg.from);\n        // const isSynced = await chat.syncHistory();\n        \n        await msg.reply(isSynced ? 'Historical chat is syncing..' : 'There is no historical chat to sync.');\n    } else if (msg.body === '!statuses') {\n        const statuses = await client.getBroadcasts();\n        console.log(statuses);\n        const chat = await statuses[0]?.getChat(); // Get user chat of a first status\n        console.log(chat);\n    }\n});\n\nclient.on('message_create', async (msg) => {\n    // Fired on all message creations, including your own\n    if (msg.fromMe) {\n        // do stuff here\n    }\n\n    // Unpins a message\n    if (msg.fromMe && msg.body.startsWith('!unpin')) {\n        const pinnedMsg = await msg.getQuotedMessage();\n        if (pinnedMsg) {\n            // Will unpin a message\n            const result = await pinnedMsg.unpin();\n            console.log(result); // True if the operation completed successfully, false otherwise\n        }\n    }\n});\n\nclient.on('message_ciphertext', (msg) => {\n    // Receiving new incoming messages that have been encrypted\n    // msg.type === 'ciphertext'\n    msg.body = 'Waiting for this message. Check your phone.';\n    \n    // do stuff here\n});\n\nclient.on('message_revoke_everyone', async (after, before) => {\n    // Fired whenever a message is deleted by anyone (including you)\n    console.log(after); // message after it was deleted.\n    if (before) {\n        console.log(before); // message before it was deleted.\n    }\n});\n\nclient.on('message_revoke_me', async (msg) => {\n    // Fired whenever a message is only deleted in your own view.\n    console.log(msg.body); // message before it was deleted.\n});\n\nclient.on('message_ack', (msg, ack) => {\n    /*\n        == ACK VALUES ==\n        ACK_ERROR: -1\n        ACK_PENDING: 0\n        ACK_SERVER: 1\n        ACK_DEVICE: 2\n        ACK_READ: 3\n        ACK_PLAYED: 4\n    */\n\n    if (ack == 3) {\n        // The message was read\n    }\n});\n\nclient.on('group_join', (notification) => {\n    // User has joined or been added to the group.\n    console.log('join', notification);\n    notification.reply('User joined.');\n});\n\nclient.on('group_leave', (notification) => {\n    // User has left or been kicked from the group.\n    console.log('leave', notification);\n    notification.reply('User left.');\n});\n\nclient.on('group_update', (notification) => {\n    // Group picture, subject or description has been updated.\n    console.log('update', notification);\n});\n\nclient.on('change_state', state => {\n    console.log('CHANGE STATE', state);\n});\n\n// Change to false if you don't want to reject incoming calls\nlet rejectCalls = true;\n\nclient.on('call', async (call) => {\n    console.log('Call received, rejecting. GOTO Line 261 to disable', call);\n    if (rejectCalls) await call.reject();\n    await client.sendMessage(call.from, `[${call.fromMe ? 'Outgoing' : 'Incoming'}] Phone call from ${call.from}, type ${call.isGroup ? 'group' : ''} ${call.isVideo ? 'video' : 'audio'} call. ${rejectCalls ? 'This call was automatically rejected by the script.' : ''}`);\n});\n\nclient.on('disconnected', (reason) => {\n    console.log('Client was logged out', reason);\n});\n\nclient.on('contact_changed', async (message, oldId, newId, isContact) => {\n    /** The time the event occurred. */\n    const eventTime = (new Date(message.timestamp * 1000)).toLocaleString();\n\n    console.log(\n        `The contact ${oldId.slice(0, -5)}` +\n        `${!isContact ? ' that participates in group ' +\n            `${(await client.getChatById(message.to ?? message.from)).name} ` : ' '}` +\n        `changed their phone number\\nat ${eventTime}.\\n` +\n        `Their new phone number is ${newId.slice(0, -5)}.\\n`);\n\n    /**\n     * Information about the @param {message}:\n     * \n     * 1. If a notification was emitted due to a group participant changing their phone number:\n     * @param {message.author} is a participant's id before the change.\n     * @param {message.recipients[0]} is a participant's id after the change (a new one).\n     * \n     * 1.1 If the contact who changed their number WAS in the current user's contact list at the time of the change:\n     * @param {message.to} is a group chat id the event was emitted in.\n     * @param {message.from} is a current user's id that got an notification message in the group.\n     * Also the @param {message.fromMe} is TRUE.\n     * \n     * 1.2 Otherwise:\n     * @param {message.from} is a group chat id the event was emitted in.\n     * @param {message.to} is @type {undefined}.\n     * Also @param {message.fromMe} is FALSE.\n     * \n     * 2. If a notification was emitted due to a contact changing their phone number:\n     * @param {message.templateParams} is an array of two user's ids:\n     * the old (before the change) and a new one, stored in alphabetical order.\n     * @param {message.from} is a current user's id that has a chat with a user,\n     * whos phone number was changed.\n     * @param {message.to} is a user's id (after the change), the current user has a chat with.\n     */\n});\n\nclient.on('group_admin_changed', (notification) => {\n    if (notification.type === 'promote') {\n        /** \n          * Emitted when a current user is promoted to an admin.\n          * {@link notification.author} is a user who performs the action of promoting/demoting the current user.\n          */\n        console.log(`You were promoted by ${notification.author}`);\n    } else if (notification.type === 'demote')\n        /** Emitted when a current user is demoted to a regular user. */\n        console.log(`You were demoted by ${notification.author}`);\n});\n\nclient.on('group_membership_request', async (notification) => {\n    /**\n     * The example of the {@link notification} output:\n     * {\n     *     id: {\n     *         fromMe: false,\n     *         remote: 'groupId@g.us',\n     *         id: '123123123132132132',\n     *         participant: 'number@c.us',\n     *         _serialized: 'false_groupId@g.us_123123123132132132_number@c.us'\n     *     },\n     *     body: '',\n     *     type: 'created_membership_requests',\n     *     timestamp: 1694456538,\n     *     chatId: 'groupId@g.us',\n     *     author: 'number@c.us',\n     *     recipientIds: []\n     * }\n     *\n     */\n    console.log(notification);\n    /** You can approve or reject the newly appeared membership request: */\n    await client.approveGroupMembershipRequestss(notification.chatId, notification.author);\n    await client.rejectGroupMembershipRequests(notification.chatId, notification.author);\n});\n\nclient.on('message_reaction', async (reaction) => {\n    console.log('REACTION RECEIVED', reaction);\n});\n\nclient.on('vote_update', (vote) => {\n    /** The vote that was affected: */\n    console.log(vote);\n});\n"
        },
        {
          "name": "index.d.ts",
          "type": "blob",
          "size": 66.3359375,
          "content": "\nimport { EventEmitter } from 'events'\nimport { RequestInit } from 'node-fetch'\nimport * as puppeteer from 'puppeteer'\nimport InterfaceController from './src/util/InterfaceController'\n\ndeclare namespace WAWebJS {\n\n    export class Client extends EventEmitter {\n        constructor(options: ClientOptions)\n\n        /** Current connection information */\n        public info: ClientInfo\n\n        /** Puppeteer page running WhatsApp Web */\n        pupPage?: puppeteer.Page\n\n        /** Puppeteer browser running WhatsApp Web */\n        pupBrowser?: puppeteer.Browser\n\n        /** Client interactivity interface */\n        interface?: InterfaceController\n\n        /**Accepts an invitation to join a group */\n        acceptInvite(inviteCode: string): Promise<string>\n\n        /** Accepts a private invitation to join a group (v4 invite) */\n        acceptGroupV4Invite: (inviteV4: InviteV4Data) => Promise<{status: number}>\n\n        /**Returns an object with information about the invite code's group */\n        getInviteInfo(inviteCode: string): Promise<object>\n\n        /** Enables and returns the archive state of the Chat */\n        archiveChat(chatId: string): Promise<boolean>\n\n        /** Pins the Chat and returns its new Pin state */\n        pinChat(chatId: string): Promise<boolean>\n\n        /** Unpins the Chat and returns its new Pin state */\n        unpinChat(chatId: string): Promise<boolean>\n\n        /** Creates a new group */\n        createGroup(title: string, participants?: string | Contact | Contact[] | string[], options?: CreateGroupOptions): Promise<CreateGroupResult|string>\n\n        /** Closes the client */\n        destroy(): Promise<void>\n\n        /** Logs out the client, closing the current session */\n        logout(): Promise<void>\n\n        /** Get all blocked contacts by host account */\n        getBlockedContacts(): Promise<Contact[]>\n\n        /** Get chat instance by ID */\n        getChatById(chatId: string): Promise<Chat>\n\n        /** Get all current chat instances */\n        getChats(): Promise<Chat[]>\n\n        /** Get contact instance by ID */\n        getContactById(contactId: string): Promise<Contact>\n\n        /** Get message by ID */\n        getMessageById(messageId: string): Promise<Message>\n\n        /** Get all current contact instances */\n        getContacts(): Promise<Contact[]>\n        \n        /** Get the country code of a WhatsApp ID. (154185968@c.us) => (1) */\n        getCountryCode(number: string): Promise<string>\n\n        /** Get the formatted number of a WhatsApp ID. (12345678901@c.us) => (+1 (234) 5678-901) */\n        getFormattedNumber(number: string): Promise<string>\n\n        /** Get all current Labels  */\n        getLabels(): Promise<Label[]>\n        \n        /** Get all current Broadcasts  */\n        getBroadcasts(): Promise<Broadcast[]>\n        \n        /** Change labels in chats  */\n        addOrRemoveLabels(labelIds: Array<number|string>, chatIds: Array<string>): Promise<void>\n\n        /** Get Label instance by ID */\n        getLabelById(labelId: string): Promise<Label>\n\n        /** Get all Labels assigned to a Chat */\n        getChatLabels(chatId: string): Promise<Label[]>\n\n        /** Get all Chats for a specific Label */\n        getChatsByLabelId(labelId: string): Promise<Chat[]>\n\n        /** Returns the contact ID's profile picture URL, if privacy settings allow it */\n        getProfilePicUrl(contactId: string): Promise<string>\n\n        /** Gets the Contact's common groups with you. Returns empty array if you don't have any common group. */\n        getCommonGroups(contactId: string): Promise<ChatId[]>\n\n        /** Gets the current connection state for the client */\n        getState(): Promise<WAState>\n\n        /** Returns the version of WhatsApp Web currently being run */\n        getWWebVersion(): Promise<string>\n\n        /** Sets up events and requirements, kicks off authentication request */\n        initialize(): Promise<void>\n\n        /** Check if a given ID is registered in whatsapp */\n        isRegisteredUser(contactId: string): Promise<boolean>\n\n        /** Get the registered WhatsApp ID for a number. Returns null if the number is not registered on WhatsApp. */\n        getNumberId(number: string): Promise<ContactId | null>\n\n        /**\n         * Mutes this chat forever, unless a date is specified\n         * @param chatId ID of the chat that will be muted\n         * @param unmuteDate Date when the chat will be unmuted, leave as is to mute forever\n         */\n        muteChat(chatId: string, unmuteDate?: Date): Promise<void>\n\n        /**\n         * Request authentication via pairing code instead of QR code\n         * @param phoneNumber - Phone number in international, symbol-free format (e.g. 12025550108 for US, 551155501234 for Brazil)\n         * @param showNotification - Show notification to pair on phone number\n         * @returns {Promise<string>} - Returns a pairing code in format \"ABCDEFGH\"\n         */\n        requestPairingCode(phoneNumber: string, showNotification = true): Promise<string>\n\n        /** Force reset of connection state for the client */\n        resetState(): Promise<void>\n\n        /** Send a message to a specific chatId */\n        sendMessage(chatId: string, content: MessageContent, options?: MessageSendOptions): Promise<Message>\n        \n        /** Searches for messages */\n        searchMessages(query: string, options?: { chatId?: string, page?: number, limit?: number }): Promise<Message[]>\n\n        /** Marks the client as online */\n        sendPresenceAvailable(): Promise<void>\n\n        /** Marks the client as offline */\n        sendPresenceUnavailable(): Promise<void>\n\n        /** Mark as seen for the Chat */\n        sendSeen(chatId: string): Promise<boolean>\n\n        /** Mark the Chat as unread */\n        markChatUnread(chatId: string): Promise<void>\n\n        /** \n         * Sets the current user's status message\n         * @param status New status message\n         */\n        setStatus(status: string): Promise<void>\n\n        /** \n         * Sets the current user's display name\n         * @param displayName New display name\n         */\n        setDisplayName(displayName: string): Promise<boolean>\n        \n        /**\n         * Changes the autoload Audio\n         * @param flag true/false on or off\n         */\n        setAutoDownloadAudio(flag: boolean): Promise<void>\n        /**\n         * Changes the autoload Documents\n         * @param flag true/false on or off\n         */\n        setAutoDownloadDocuments(flag: boolean): Promise<void>\n        /**\n         * Changes the autoload Photos\n         * @param flag true/false on or off\n         */\n        setAutoDownloadPhotos(flag: boolean): Promise<void>\n        /**\n         * Changes the autoload Videos\n         * @param flag true/false on or off\n         */\n        setAutoDownloadVideos(flag: boolean): Promise<void>\n\n        /**\n         * Get user device count by ID\n         * Each WaWeb Connection counts as one device, and the phone (if exists) counts as one\n         * So for a non-enterprise user with one WaWeb connection it should return \"2\"\n         * @param {string} contactId\n         */\n        getContactDeviceCount(userId: string): Promise<number>\n        \n        /** Sync history conversation of the Chat */\n        syncHistory(chatId: string): Promise<boolean>\n        \n        /** Changes and returns the archive state of the Chat */\n        unarchiveChat(chatId: string): Promise<boolean>\n\n        /** Unmutes the Chat */\n        unmuteChat(chatId: string): Promise<void>\n\n        /** Sets the current user's profile picture */\n        setProfilePicture(media: MessageMedia): Promise<boolean>\n\n        /** Deletes the current user's profile picture */\n        deleteProfilePicture(): Promise<boolean>\n\n        /** Gets an array of membership requests */\n        getGroupMembershipRequests: (groupId: string) => Promise<Array<GroupMembershipRequest>>\n\n        /** Approves membership requests if any */\n        approveGroupMembershipRequests: (groupId: string, options: MembershipRequestActionOptions) => Promise<Array<MembershipRequestActionResult>>;\n\n        /** Rejects membership requests if any */\n        rejectGroupMembershipRequests: (groupId: string, options: MembershipRequestActionOptions) => Promise<Array<MembershipRequestActionResult>>;\n\n        /** Generic event */\n        on(event: string, listener: (...args: any) => void): this\n\n        /** Emitted when there has been an error while trying to restore an existing session */\n        on(event: 'auth_failure', listener: (message: string) => void): this\n\n        /** Emitted when authentication is successful */\n        on(event: 'authenticated', listener: (\n            /** \n             * Object containing session information, when using LegacySessionAuth. Can be used to restore the session\n             */\n            session?: ClientSession\n        ) => void): this\n\n        /** \n         * Emitted when the battery percentage for the attached device changes\n         * @deprecated \n         */\n        on(event: 'change_battery', listener: (batteryInfo: BatteryInfo) => void): this\n\n        /** Emitted when the connection state changes */\n        on(event: 'change_state', listener: (\n            /** the new connection state */\n            state: WAState\n        ) => void): this\n\n        /** Emitted when the client has been disconnected */\n        on(event: 'disconnected', listener: (\n            /** reason that caused the disconnect */\n            reason: WAState | \"LOGOUT\"\n        ) => void): this\n\n        /** Emitted when a user joins the chat via invite link or is added by an admin */\n        on(event: 'group_join', listener: (\n            /** GroupNotification with more information about the action */\n            notification: GroupNotification\n        ) => void): this\n\n        /** Emitted when a user leaves the chat or is removed by an admin */\n        on(event: 'group_leave', listener: (\n            /** GroupNotification with more information about the action */\n            notification: GroupNotification\n        ) => void): this\n\n        /** Emitted when a current user is promoted to an admin or demoted to a regular user */\n        on(event: 'group_admin_changed', listener: (\n            /** GroupNotification with more information about the action */\n            notification: GroupNotification\n        ) => void): this\n\n        /**\n         * Emitted when some user requested to join the group\n         * that has the membership approval mode turned on\n         */\n        on(event: 'group_membership_request', listener: (\n            /** GroupNotification with more information about the action */\n            notification: GroupNotification\n        ) => void): this\n\n        /** Emitted when group settings are updated, such as subject, description or picture */\n        on(event: 'group_update', listener: (\n            /** GroupNotification with more information about the action */\n            notification: GroupNotification\n        ) => void): this\n\n        /** Emitted when a contact or a group participant changed their phone number. */\n        on(event: 'contact_changed', listener: (\n            /** Message with more information about the event. */\n            message: Message,\n            /** Old user's id. */\n            oldId : String,\n            /** New user's id. */\n            newId : String,\n            /** Indicates if a contact or a group participant changed their phone number. */\n            isContact : Boolean\n        ) => void): this\n\n        /** Emitted when media has been uploaded for a message sent by the client */\n        on(event: 'media_uploaded', listener: (\n            /** The message with media that was uploaded */\n            message: Message\n        ) => void): this\n\n        /** Emitted when a new message is received */\n        on(event: 'message', listener: (\n            /** The message that was received */\n            message: Message\n        ) => void): this\n\n        /** Emitted when an ack event occurrs on message type */\n        on(event: 'message_ack', listener: (\n            /** The message that was affected */\n            message: Message,\n            /** The new ACK value */\n            ack: MessageAck\n        ) => void): this\n        \n        /** Emitted when an ack event occurrs on message type */\n        on(event: 'message_edit', listener: (\n            /** The message that was affected */\n            message: Message,\n            /** New text message */\n            newBody: String,\n            /** Prev text message */\n            prevBody: String\n        ) => void): this\n        \n        /** Emitted when a chat unread count changes */\n        on(event: 'unread_count', listener: (\n            /** The chat that was affected */\n            chat: Chat\n        ) => void): this\n\n        /** Emitted when a new message is created, which may include the current user's own messages */\n        on(event: 'message_create', listener: (\n            /** The message that was created */\n            message: Message\n        ) => void): this\n        \n        /** Emitted when a new message ciphertext is received  */\n        on(event: 'message_ciphertext', listener: (\n            /** The message that was ciphertext */\n            message: Message\n        ) => void): this\n\n        /** Emitted when a message is deleted for everyone in the chat */\n        on(event: 'message_revoke_everyone', listener: (\n            /** The message that was revoked, in its current state. It will not contain the original message's data */\n            message: Message,\n            /**The message that was revoked, before it was revoked. \n             * It will contain the message's original data. \n             * Note that due to the way this data is captured, \n             * it may be possible that this param will be undefined. */\n            revoked_msg?: Message | null\n        ) => void): this\n\n        /** Emitted when a message is deleted by the current user */\n        on(event: 'message_revoke_me', listener: (\n            /** The message that was revoked */\n            message: Message\n        ) => void): this\n\n        /** Emitted when a reaction is sent, received, updated or removed */\n        on(event: 'message_reaction', listener: (\n            /** The reaction object */\n            reaction: Reaction\n        ) => void): this\n\n        /** Emitted when a chat is removed */\n        on(event: 'chat_removed', listener: (\n            /** The chat that was removed */\n            chat: Chat\n        ) => void): this\n\n        /** Emitted when a chat is archived/unarchived */\n        on(event: 'chat_archived', listener: (\n            /** The chat that was archived/unarchived */\n            chat: Chat,\n            /** State the chat is currently in */\n            currState: boolean,\n            /** State the chat was previously in */\n            prevState: boolean\n        ) => void): this\n\n        /** Emitted when loading screen is appearing */\n        on(event: 'loading_screen', listener: (percent: string, message: string) => void): this\n\n        /** Emitted when the QR code is received */\n        on(event: 'qr', listener: (\n            /** qr code string\n             *  @example ```1@9Q8tWf6bnezr8uVGwVCluyRuBOJ3tIglimzI5dHB0vQW2m4DQ0GMlCGf,f1/vGcW4Z3vBa1eDNl3tOjWqLL5DpYTI84DMVkYnQE8=,ZL7YnK2qdPN8vKo2ESxhOQ==``` */\n            qr: string\n        ) => void): this\n\n        /** Emitted when a call is received */\n        on(event: 'call', listener: (\n            /** The call that started */\n            call: Call\n        ) => void): this\n\n        /** Emitted when the client has initialized and is ready to receive messages */\n        on(event: 'ready', listener: () => void): this\n\n        /** Emitted when the RemoteAuth session is saved successfully on the external Database */\n        on(event: 'remote_session_saved', listener: () => void): this\n\n        /**\n         * Emitted when some poll option is selected or deselected,\n         * shows a user's current selected option(s) on the poll\n         */\n        on(event: 'vote_update', listener: (\n            vote: PollVote\n        ) => void): this\n    }\n\n    /** Current connection information */\n    export interface ClientInfo {\n        /** \n         * Current user ID \n         * @deprecated Use .wid instead \n         */\n        me: ContactId\n        /** Current user ID */\n        wid: ContactId\n        /** \n         * Information about the phone this client is connected to.  Not available in multi-device. \n         * @deprecated \n         */\n        phone: ClientInfoPhone\n        /** Platform the phone is running on */\n        platform: string\n        /** Name configured to be shown in push notifications */\n        pushname: string\n\n        /** Get current battery percentage and charging status for the attached device */\n        getBatteryStatus: () => Promise<BatteryInfo>\n    }\n\n    /** \n     * Information about the phone this client is connected to \n     * @deprecated\n     */\n    export interface ClientInfoPhone {\n        /** WhatsApp Version running on the phone */\n        wa_version: string\n        /** OS Version running on the phone (iOS or Android version) */\n        os_version: string\n        /** Device manufacturer */\n        device_manufacturer: string\n        /** Device model */\n        device_model: string\n        /** OS build number */\n        os_build_number: string\n    }\n\n    /** Options for initializing the whatsapp client */\n    export interface ClientOptions {\n        /** Timeout for authentication selector in puppeteer\n         * @default 0 */\n        authTimeoutMs?: number,\n        /** Puppeteer launch options. View docs here: https://github.com/puppeteer/puppeteer/ */\n        puppeteer?: puppeteer.PuppeteerNodeLaunchOptions & puppeteer.ConnectOptions\n\t\t/** Determines how to save and restore sessions. Will use LegacySessionAuth if options.session is set. Otherwise, NoAuth will be used. */\n        authStrategy?: AuthStrategy,\n        /** The version of WhatsApp Web to use. Use options.webVersionCache to configure how the version is retrieved. */\n        webVersion?: string,\n        /**  Determines how to retrieve the WhatsApp Web version specified in options.webVersion. */\n        webVersionCache?: WebCacheOptions,\n        /** How many times should the qrcode be refreshed before giving up\n\t\t * @default 0 (disabled) */\n\t\tqrMaxRetries?: number,\n        /** \n         * @deprecated This option should be set directly on the LegacySessionAuth\n         */\n        restartOnAuthFail?: boolean\n        /** \n         * @deprecated Only here for backwards-compatibility. You should move to using LocalAuth, or set the authStrategy to LegacySessionAuth explicitly.  \n         */\n        session?: ClientSession\n        /** If another whatsapp web session is detected (another browser), take over the session in the current browser\n         * @default false */\n        takeoverOnConflict?: boolean,\n        /** How much time to wait before taking over the session\n         * @default 0 */\n        takeoverTimeoutMs?: number,\n        /** User agent to use in puppeteer.\n         * @default 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36' */\n        userAgent?: string\n        /** Ffmpeg path to use when formatting videos to webp while sending stickers \n         * @default 'ffmpeg' */\n        ffmpegPath?: string,\n        /** Object with proxy autentication requirements @default: undefined */\n        proxyAuthentication?: {username: string, password: string} | undefined\n    }\n\n    export interface LocalWebCacheOptions {\n        type: 'local',\n        path?: string,\n        strict?: boolean\n    }\n\n    export interface RemoteWebCacheOptions {\n        type: 'remote',\n        remotePath: string,\n        strict?: boolean\n    }\n\n    export interface NoWebCacheOptions {\n        type: 'none'\n    }\n\n    export type WebCacheOptions = NoWebCacheOptions | LocalWebCacheOptions | RemoteWebCacheOptions;\n\n    /**\n     * Base class which all authentication strategies extend\n     */\n    export abstract class AuthStrategy {\n        setup: (client: Client) => void;\n        beforeBrowserInitialized: () => Promise<void>;\n        afterBrowserInitialized: () => Promise<void>;\n        onAuthenticationNeeded: () => Promise<{\n            failed?: boolean; \n            restart?: boolean; \n            failureEventPayload?: any\n        }>;\n        getAuthEventPayload: () => Promise<any>;\n        afterAuthReady: () => Promise<void>;\n        disconnect: () => Promise<void>;\n        destroy: () => Promise<void>;\n        logout: () => Promise<void>;\n    }\n\n    /**\n     * No session restoring functionality\n     * Will need to authenticate via QR code every time\n     */\n    export class NoAuth extends AuthStrategy {}\n\n    /**\n     * Local directory-based authentication\n     */\n    export class LocalAuth extends AuthStrategy {\n        public clientId?: string;\n        public dataPath?: string;\n        constructor(options?: {\n            clientId?: string,\n            dataPath?: string,\n            rmMaxRetries?: number\n        })\n    }\n    \n    /**\n     * Remote-based authentication\n     */\n     export class RemoteAuth extends AuthStrategy {\n        public clientId?: string;\n        public dataPath?: string;\n        constructor(options?: {\n            store: Store,\n            clientId?: string,\n            dataPath?: string,\n            backupSyncIntervalMs: number,\n            rmMaxRetries?: number\n        })\n    }\n\n    /** \n     * Remote store interface\n     */\n    export interface Store {\n        sessionExists: (options: { session: string }) => Promise<boolean> | boolean,\n        delete: (options: { session: string }) => Promise<any> | any,\n        save: (options: { session: string }) => Promise<any> | any,\n        extract: (options: { session: string, path: string }) => Promise<any> | any,\n    }\n\n    /**\n     * Legacy session auth strategy\n     * Not compatible with multi-device accounts.\n     */\n     export class LegacySessionAuth extends AuthStrategy {\n        constructor(options?: {\n            session?: ClientSession,\n            restartOnAuthFail?: boolean,\n        })\n    }\n\n    /** \n     * Represents a WhatsApp client session\n     */\n    export interface ClientSession {\n        WABrowserId: string,\n        WASecretBundle: string,\n        WAToken1: string,\n        WAToken2: string,\n    }\n\n    /** \n     * @deprecated\n     */\n    export interface BatteryInfo {\n        /** The current battery percentage */\n        battery: number,\n        /** Indicates if the phone is plugged in (true) or not (false) */\n        plugged: boolean,\n    }\n\n    /** An object that handles options for group creation */\n    export interface CreateGroupOptions {\n        /**\n         * The number of seconds for the messages to disappear in the group,\n         * won't take an effect if the group is been creating with myself only\n         * @default 0\n         */\n        messageTimer?: number\n        /**\n         * The ID of a parent community group to link the newly created group with,\n         * won't take an effect if the group is been creating with myself only\n         */\n        parentGroupId?: string\n        /** If true, the inviteV4 will be sent to those participants\n         * who have restricted others from being automatically added to groups,\n         * otherwise the inviteV4 won't be sent\n         * @default true\n         */\n        autoSendInviteV4?: boolean,\n        /**\n         * The comment to be added to an inviteV4 (empty string by default)\n         * @default ''\n         */\n        comment?: string\n    }\n\n    /** An object that handles the result for createGroup method */\n    export interface CreateGroupResult {\n        /** A group title */\n        title: string;\n        /** An object that handles the newly created group ID */\n        gid: ChatId;\n        /** An object that handles the result value for each added to the group participant */\n        participants: {\n            [participantId: string]: {\n                statusCode: number,\n                message: string,\n                isGroupCreator: boolean,\n                isInviteV4Sent: boolean\n            };\n        };\n    }\n\n    export interface GroupNotification {\n        /** ContactId for the user that produced the GroupNotification */\n        author: string,\n        /** Extra content */\n        body: string,\n        /** ID for the Chat that this groupNotification was sent for */\n        chatId: string,\n        /** ID that represents the groupNotification \n         *  @todo create a more specific type for the id object */\n        id: object,\n        /** Contact IDs for the users that were affected by this GroupNotification */\n        recipientIds: string[],\n        /** Unix timestamp for when the groupNotification was created */\n        timestamp: number,\n        /** GroupNotification type */\n        type: GroupNotificationTypes,\n\n        /** Returns the Chat this GroupNotification was sent in */\n        getChat: () => Promise<Chat>,\n        /** Returns the Contact this GroupNotification was produced by */\n        getContact: () => Promise<Contact>,\n        /** Returns the Contacts affected by this GroupNotification */\n        getRecipients: () => Promise<Contact[]>,\n        /** Sends a message to the same chat this GroupNotification was produced in */\n        reply: (content: MessageContent, options?: MessageSendOptions) => Promise<Message>,\n\n    }\n    \n    /** whatsapp web url */\n    export const WhatsWebURL: string\n\n    /** default client options */\n    export const DefaultOptions: ClientOptions\n\n    /** Chat types */\n    export enum ChatTypes {\n        SOLO = 'solo',\n        GROUP = 'group',\n        UNKNOWN = 'unknown',\n    }\n\n    /** Events that can be emitted by the client */\n    export enum Events {\n        AUTHENTICATED = 'authenticated',\n        AUTHENTICATION_FAILURE = 'auth_failure',\n        READY = 'ready',\n        MESSAGE_RECEIVED = 'message',\n        MESSAGE_CIPHERTEXT = 'message_ciphertext',\n        MESSAGE_CREATE = 'message_create',\n        MESSAGE_REVOKED_EVERYONE = 'message_revoke_everyone',\n        MESSAGE_REVOKED_ME = 'message_revoke_me',\n        MESSAGE_ACK = 'message_ack',\n        MESSAGE_EDIT = 'message_edit',\n        MEDIA_UPLOADED = 'media_uploaded',\n        CONTACT_CHANGED = 'contact_changed',\n        GROUP_JOIN = 'group_join',\n        GROUP_LEAVE = 'group_leave',\n        GROUP_ADMIN_CHANGED = 'group_admin_changed',\n        GROUP_MEMBERSHIP_REQUEST = 'group_membership_request',\n        GROUP_UPDATE = 'group_update',\n        QR_RECEIVED = 'qr',\n        LOADING_SCREEN = 'loading_screen',\n        DISCONNECTED = 'disconnected',\n        STATE_CHANGED = 'change_state',\n        BATTERY_CHANGED = 'change_battery',\n        REMOTE_SESSION_SAVED = 'remote_session_saved',\n        CALL = 'call'\n    }\n\n    /** Group notification types */\n    export enum GroupNotificationTypes {\n        ADD = 'add',\n        INVITE = 'invite',\n        REMOVE = 'remove',\n        LEAVE = 'leave',\n        SUBJECT = 'subject',\n        DESCRIPTION = 'description',\n        PICTURE = 'picture',\n        ANNOUNCE = 'announce',\n        RESTRICT = 'restrict',\n    }\n\n    /** Message ACK */\n    export enum MessageAck {\n        ACK_ERROR = -1,\n        ACK_PENDING = 0,\n        ACK_SERVER = 1,\n        ACK_DEVICE = 2,\n        ACK_READ = 3,\n        ACK_PLAYED = 4,\n    }\n\n    /** Message types */\n    export enum MessageTypes {\n        TEXT = 'chat',\n        AUDIO = 'audio',\n        VOICE = 'ptt',\n        IMAGE = 'image',\n        VIDEO = 'video',\n        DOCUMENT = 'document',\n        STICKER = 'sticker',\n        LOCATION = 'location',\n        CONTACT_CARD = 'vcard',\n        CONTACT_CARD_MULTI = 'multi_vcard',\n        REVOKED = 'revoked',\n        ORDER = 'order',\n        PRODUCT = 'product',\n        PAYMENT = 'payment',\n        UNKNOWN = 'unknown',\n        GROUP_INVITE = 'groups_v4_invite',\n        LIST = 'list',\n        LIST_RESPONSE = 'list_response',\n        BUTTONS_RESPONSE = 'buttons_response',\n        BROADCAST_NOTIFICATION = 'broadcast_notification',\n        CALL_LOG = 'call_log',\n        CIPHERTEXT = 'ciphertext',\n        DEBUG = 'debug',\n        E2E_NOTIFICATION = 'e2e_notification',\n        GP2 = 'gp2',\n        GROUP_NOTIFICATION = 'group_notification',\n        HSM = 'hsm',\n        INTERACTIVE = 'interactive',\n        NATIVE_FLOW = 'native_flow',\n        NOTIFICATION = 'notification',\n        NOTIFICATION_TEMPLATE = 'notification_template',\n        OVERSIZED = 'oversized',\n        PROTOCOL = 'protocol',\n        REACTION = 'reaction',\n        TEMPLATE_BUTTON_REPLY = 'template_button_reply',\n        POLL_CREATION = 'poll_creation',\n    }\n\n    /** Client status */\n    export enum Status {\n        INITIALIZING = 0,\n        AUTHENTICATING = 1,\n        READY = 3,\n    }\n\n    /** WhatsApp state */\n    export enum WAState {\n        CONFLICT = 'CONFLICT',\n        CONNECTED = 'CONNECTED',\n        DEPRECATED_VERSION = 'DEPRECATED_VERSION',\n        OPENING = 'OPENING',\n        PAIRING = 'PAIRING',\n        PROXYBLOCK = 'PROXYBLOCK',\n        SMB_TOS_BLOCK = 'SMB_TOS_BLOCK',\n        TIMEOUT = 'TIMEOUT',\n        TOS_BLOCK = 'TOS_BLOCK',\n        UNLAUNCHED = 'UNLAUNCHED',\n        UNPAIRED = 'UNPAIRED',\n        UNPAIRED_IDLE = 'UNPAIRED_IDLE',\n    }\n\n    export type MessageInfo = {\n        delivery: Array<{id: ContactId, t: number}>,\n        deliveryRemaining: number,\n        played: Array<{id: ContactId, t: number}>,\n        playedRemaining: number,\n        read: Array<{id: ContactId, t: number}>,\n        readRemaining: number\n    }\n\n    export type InviteV4Data = {\n        inviteCode: string,\n        inviteCodeExp: number,\n        groupId: string,\n        groupName?: string,\n        fromId: string,\n        toId: string\n    }\n\n    /**\n     * Represents a Message on WhatsApp\n     * \n     * @example\n     * {\n     *   mediaKey: undefined,\n     *   id: {\n     *     fromMe: false,\n     *     remote: `554199999999@c.us`,\n     *     id: '1234567890ABCDEFGHIJ',\n     *     _serialized: `false_554199999999@c.us_1234567890ABCDEFGHIJ`\n     *   },\n     *   ack: -1,\n     *   hasMedia: false,\n     *   body: 'Hello!',\n     *   type: 'chat',\n     *   timestamp: 1591482682,\n     *   from: `554199999999@c.us`,\n     *   to: `554188888888@c.us`,\n     *   author: undefined,\n     *   isForwarded: false,\n     *   broadcast: false,\n     *   fromMe: false,\n     *   hasQuotedMsg: false,\n     *   hasReaction: false,\n     *   location: undefined,\n     *   mentionedIds: []\n     * }\n     */\n    export interface Message {\n        /** ACK status for the message */\n        ack: MessageAck,\n        /** If the message was sent to a group, this field will contain the user that sent the message. */\n        author?: string,\n        /** String that represents from which device type the message was sent */\n        deviceType: string,\n        /** Message content */\n        body: string,\n        /** Indicates if the message was a broadcast */\n        broadcast: boolean,\n        /** Indicates if the message was a status update */\n        isStatus: boolean,\n        /** Indicates if the message is a Gif */\n        isGif: boolean,\n        /** Indicates if the message will disappear after it expires */\n        isEphemeral: boolean,\n        /** ID for the Chat that this message was sent to, except if the message was sent by the current user */\n        from: string,\n        /** Indicates if the message was sent by the current user */\n        fromMe: boolean,\n        /** Indicates if the message has media available for download */\n        hasMedia: boolean,\n        /** Indicates if the message was sent as a reply to another message */\n        hasQuotedMsg: boolean,\n        /** Indicates whether there are reactions to the message */\n        hasReaction: boolean,\n        /** Indicates the duration of the message in seconds */\n        duration: string,\n        /** ID that represents the message */\n        id: MessageId,\n        /** Indicates if the message was forwarded */\n        isForwarded: boolean,\n        /**\n         * Indicates how many times the message was forwarded.\n         * The maximum value is 127.\n         */\n        forwardingScore: number,\n        /** Indicates if the message was starred */\n        isStarred: boolean,\n        /** Location information contained in the message, if the message is type \"location\" */\n        location: Location,\n        /** List of vCards contained in the message */\n        vCards: string[],\n        /** Invite v4 info */\n        inviteV4?: InviteV4Data,\n        /** MediaKey that represents the sticker 'ID' */\n        mediaKey?: string,\n        /** Indicates the mentions in the message body. */\n        mentionedIds: ChatId[],\n        /** Indicates whether there are group mentions in the message body */\n        groupMentions: {\n            groupSubject: string;\n            groupJid: {\n                server: string;\n                user: string;\n                _serialized: string;\n            };\n        }[],\n        /** Unix timestamp for when the message was created */\n        timestamp: number,\n        /**\n         * ID for who this message is for.\n         * If the message is sent by the current user, it will be the Chat to which the message is being sent.\n         * If the message is sent by another user, it will be the ID for the current user.\n         */\n        to: string,\n        /** Message type */\n        type: MessageTypes,\n        /** Links included in the message. */\n        links: Array<{\n            link: string,\n            isSuspicious: boolean\n        }>,\n        /** Order ID */\n        orderId: string,\n        /** title */\n        title?: string,\n        /** description*/\n        description?: string,\n        /** Business Owner JID */\n        businessOwnerJid?: string,\n        /** Product JID */\n        productId?: string,\n        /** Last edit time */\n        latestEditSenderTimestampMs?: number,\n        /** Last edit message author */\n        latestEditMsgKey?: MessageId,\n        /** Message buttons */\n        dynamicReplyButtons?: object,\n        /** Selected button ID */\n        selectedButtonId?: string,\n        /** Selected list row ID */\n        selectedRowId?: string,\n        /** Returns message in a raw format */\n        rawData: object,\n        pollName: string,\n        /** Avaiaible poll voting options */\n        pollOptions: string[],\n        /** False for a single choice poll, true for a multiple choice poll */\n        allowMultipleAnswers: boolean,\n        /* \n        * Reloads this Message object's data in-place with the latest values from WhatsApp Web. \n        * Note that the Message must still be in the web app cache for this to work, otherwise will return null.\n        */\n        reload: () => Promise<Message>,\n        /** Accept the Group V4 Invite in message */\n        acceptGroupV4Invite: () => Promise<{status: number}>,\n        /** Deletes the message from the chat */\n        delete: (everyone?: boolean) => Promise<void>,\n        /** Downloads and returns the attached message media */\n        downloadMedia: () => Promise<MessageMedia>,\n        /** Returns the Chat this message was sent in */\n        getChat: () => Promise<Chat>,\n        /** Returns the Contact this message was sent from */\n        getContact: () => Promise<Contact>,\n        /** Returns the Contacts mentioned in this message */\n        getMentions: () => Promise<Contact[]>,\n        /** Returns groups mentioned in this message */\n        getGroupMentions: () => Promise<GroupChat[]|[]>,\n        /** Returns the quoted message, if any */\n        getQuotedMessage: () => Promise<Message>,\n        /** \n         * Sends a message as a reply to this message. \n         * If chatId is specified, it will be sent through the specified Chat.\n         * If not, it will send the message in the same Chat as the original message was sent. \n         */\n        reply: (content: MessageContent, chatId?: string, options?: MessageSendOptions) => Promise<Message>,\n        /** React to this message with an emoji*/\n        react: (reaction: string) => Promise<void>,\n        /** \n         * Forwards this message to another chat (that you chatted before, otherwise it will fail)\n         */\n        forward: (chat: Chat | string) => Promise<void>,\n        /** Star this message */\n        star: () => Promise<void>,\n        /** Unstar this message */\n        unstar: () => Promise<void>,\n        /** Pins the message (group admins can pin messages of all group members) */\n        pin: (duration: number) => Promise<boolean>,\n        /** Unpins the message (group admins can unpin messages of all group members) */\n        unpin: () => Promise<boolean>,\n        /** Get information about message delivery status */\n        getInfo: () => Promise<MessageInfo | null>,\n        /**\n         * Gets the order associated with a given message\n         */\n        getOrder: () => Promise<Order>,\n        /**\n         * Gets the payment details associated with a given message\n         */\n        getPayment: () => Promise<Payment>,\n        /**\n         * Gets the reactions associated with the given message\n         */\n        getReactions: () => Promise<ReactionList[]>,\n        /** Edits the current message */\n        edit: (content: MessageContent, options?: MessageEditOptions) => Promise<Message | null>,\n    }\n\n    /** ID that represents a message */\n    export interface MessageId {\n        fromMe: boolean,\n        remote: string,\n        id: string,\n        _serialized: string,\n    }\n\n    /** Options for sending a location */\n    export interface LocationSendOptions {\n        /** Location name */\n        name?: string;\n        /** Location address */\n        address?: string;\n        /** URL address to be shown within a location message */\n        url?: string;\n    }\n\n    /** Location information */\n    export class Location {\n        latitude: string;\n        longitude: string;\n        options?: LocationSendOptions;\n        \n        constructor(latitude: number, longitude: number, options?: LocationSendOptions)\n    }\n\n    /** Poll send options */\n    export interface PollSendOptions {\n        /** False for a single choice poll, true for a multiple choice poll (false by default) */\n        allowMultipleAnswers?: boolean,\n        /**\n         * The custom message secret, can be used as a poll ID\n         * @note It has to be a unique vector with a length of 32\n         */\n        messageSecret: Array<number>|undefined\n    }\n\n    /** Represents a Poll on WhatsApp */\n    export class Poll {\n        pollName: string\n        pollOptions: Array<{\n            name: string,\n            localId: number\n        }>\n        options: PollSendOptions\n\n        constructor(pollName: string, pollOptions: Array<string>, options?: PollSendOptions)\n    }\n\n    /** Represents a Poll Vote on WhatsApp */\n    export interface PollVote {\n        /** The person who voted */\n        voter: string;\n\n        /**\n         * The selected poll option(s)\n         * If it's an empty array, the user hasn't selected any options on the poll,\n         * may occur when they deselected all poll options\n         */\n        selectedOptions: SelectedPollOption[];\n\n        /** Timestamp the option was selected or deselected at */\n        interractedAtTs: number;\n\n        /** The poll creation message associated with the poll vote */\n        parentMessage: Message;\n    }\n\n    /** Selected poll option structure */\n    export interface SelectedPollOption {\n        /** The local selected option ID */\n        id: number;\n\n        /** The option name */\n        name: string;\n    }\n\n    export interface Label {\n        /** Label name */\n        name: string,\n        /** Label ID */\n        id: string,\n        /** Color assigned to the label */\n        hexColor: string,\n\n        /** Get all chats that have been assigned this Label */\n        getChats: () => Promise<Chat[]>\n    }\n\n    export interface Broadcast {\n        /** Chat Object ID */\n        id: {\n            server: string,\n            user: string,\n            _serialized: string\n        },\n        /** Unix timestamp of last story */\n        timestamp: number,\n        /** Number of available statuses */\n        totalCount: number,\n        /** Number of not viewed */\n        unreadCount: number,\n        /** Unix timestamp of last story */\n        msgs: Message[],\n\n        /** Returns the Chat of the owner of the story */\n        getChat: () => Promise<Chat>,\n        /** Returns the Contact of the owner of the story */\n        getContact: () => Promise<Contact>,\n    }\n\n    /** Options for sending a message */\n    export interface MessageSendOptions {\n        /** Show links preview. Has no effect on multi-device accounts. */\n        linkPreview?: boolean\n        /** Send audio as voice message with a generated waveform */\n        sendAudioAsVoice?: boolean\n        /** Send video as gif */\n        sendVideoAsGif?: boolean\n        /** Send media as sticker */\n        sendMediaAsSticker?: boolean\n        /** Send media as document */\n        sendMediaAsDocument?: boolean\n        /** Send photo/video as a view once message */\n        isViewOnce?: boolean\n        /** Automatically parse vCards and send them as contacts */\n        parseVCards?: boolean\n        /** Image or videos caption */\n        caption?: string\n        /** Id of the message that is being quoted (or replied to) */\n        quotedMessageId?: string\n        /** User IDs to mention in the message */\n        mentions?: string[]\n        /** An array of object that handle group mentions */\n        groupMentions?: {\n            /** The name of a group to mention (can be custom) */\n            subject: string,\n            /** The group ID, e.g.: 'XXXXXXXXXX@g.us' */\n            id: string\n        }[]\n        /** Send 'seen' status */\n        sendSeen?: boolean\n        /** Bot Wid when doing a bot mention like @Meta AI */\n        invokedBotWid?: string\n        /** Media to be sent */\n        media?: MessageMedia\n        /** Extra options */\n        extra?: any\n        /** Sticker name, if sendMediaAsSticker is true */\n        stickerName?: string\n        /** Sticker author, if sendMediaAsSticker is true */\n        stickerAuthor?: string\n        /** Sticker categories, if sendMediaAsSticker is true */\n        stickerCategories?: string[]\n    }\n\n    /** Options for editing a message */\n    export interface MessageEditOptions {\n        /** Show links preview. Has no effect on multi-device accounts. */\n        linkPreview?: boolean\n        /** Contacts that are being mentioned in the message */\n        mentions?: Contact[]\n        /** Extra options */\n        extra?: any\n    }\n\n    export interface MediaFromURLOptions {\n        client?: Client\n        filename?: string\n        unsafeMime?: boolean\n        reqOptions?: RequestInit\n    }\n\n    /** Media attached to a message */\n    export class MessageMedia {\n        /** MIME type of the attachment */\n        mimetype: string\n        /** Base64-encoded data of the file */\n        data: string\n        /** Document file name. Value can be null */\n        filename?: string | null\n        /** Document file size in bytes. Value can be null. */\n        filesize?: number | null\n\n        /**\n         * @param {string} mimetype MIME type of the attachment\n         * @param {string} data Base64-encoded data of the file\n         * @param {?string} filename Document file name. Value can be null\n         * @param {?number} filesize Document file size in bytes. Value can be null.\n         */\n        constructor(mimetype: string, data: string, filename?: string | null, filesize?: number | null)\n\n        /** Creates a MessageMedia instance from a local file path */\n        static fromFilePath: (filePath: string) => MessageMedia\n\n        /** Creates a MessageMedia instance from a URL */\n        static fromUrl: (url: string, options?: MediaFromURLOptions) => Promise<MessageMedia>\n    }\n\n    export type MessageContent = string | MessageMedia | Location | Poll | Contact | Contact[] | List | Buttons\n\n    /**\n     * Represents a Contact on WhatsApp\n     *\n     * @example \n     * {\n     *   id: {\n     *     server: 'c.us',\n     *     user: '554199999999',\n     *     _serialized: `554199999999@c.us`\n     *   },\n     *   number: '554199999999',\n     *   isBusiness: false,\n     *   isEnterprise: false,\n     *   labels: [],\n     *   name: undefined,\n     *   pushname: 'John',\n     *   sectionHeader: undefined,\n     *   shortName: undefined,\n     *   statusMute: false,\n     *   type: 'in',\n     *   verifiedLevel: undefined,\n     *   verifiedName: undefined,\n     *   isMe: false,\n     *   isUser: true,\n     *   isGroup: false,\n     *   isWAContact: true,\n     *   isMyContact: false\n     * }\n     */\n    export interface Contact {\n        /** Contact's phone number */\n        number: string,\n        /** Indicates if the contact is a business contact */\n        isBusiness: boolean,\n        /** ID that represents the contact */\n        id: ContactId,\n        /** Indicates if the contact is an enterprise contact */\n        isEnterprise: boolean,\n        /** Indicates if the contact is a group contact */\n        isGroup: boolean,\n        /** Indicates if the contact is the current user's contact */\n        isMe: boolean,\n        /** Indicates if the number is saved in the current phone's contacts */\n        isMyContact: boolean\n        /** Indicates if the contact is a user contact */\n        isUser: boolean,\n        /** Indicates if the number is registered on WhatsApp */\n        isWAContact: boolean,\n        /** Indicates if you have blocked this contact */\n        isBlocked: boolean,\n        /** @todo verify labels type. didn't have any documentation */\n        labels?: string[],\n        /** The contact's name, as saved by the current user */\n        name?: string,\n        /** The name that the contact has configured to be shown publically */\n        pushname: string,\n        /** @todo missing documentation */\n        sectionHeader: string,\n        /** A shortened version of name */\n        shortName?: string,\n        /** Indicates if the status from the contact is muted */\n        statusMute: boolean,\n        /** @todo missing documentation */\n        type: string,\n        /** @todo missing documentation */\n        verifiedLevel?: undefined,\n        /** @todo missing documentation */\n        verifiedName?: undefined,\n\n        /** Returns the contact's profile picture URL, if privacy settings allow it */\n        getProfilePicUrl: () => Promise<string>,\n\n        /** Returns the Chat that corresponds to this Contact.  \n         * Will return null when getting chat for currently logged in user.\n         */\n        getChat: () => Promise<Chat>,\n        \n        /** Returns the contact's countrycode, (1541859685@c.us) => (1) */\n        getCountryCode(): Promise<string>,\n        \n        /** Returns the contact's formatted phone number, (12345678901@c.us) => (+1 (234) 5678-901) */\n        getFormattedNumber(): Promise<string>,\n        \n        /** Blocks this contact from WhatsApp */\n        block: () => Promise<boolean>,\n\n        /** Unlocks this contact from WhatsApp */\n        unblock: () => Promise<boolean>,\n\n        /** Gets the Contact's current \"about\" info. Returns null if you don't have permission to read their status.  */\n        getAbout: () => Promise<string | null>,\n        \n        /** Gets the Contact's common groups with you. Returns empty array if you don't have any common group. */\n        getCommonGroups: () => Promise<ChatId[]>\n\n    }\n\n    export interface ContactId {\n        server: string,\n        user: string,\n        _serialized: string,\n    }\n    \n    export interface BusinessCategory {\n        id: string,\n        localized_display_name: string,\n    }\n\n    export interface BusinessHoursOfDay {\n        mode: string,\n        hours: number[] \n    }\n    \n    export interface BusinessHours {\n        config: {\n            sun: BusinessHoursOfDay,\n            mon: BusinessHoursOfDay,\n            tue: BusinessHoursOfDay,\n            wed: BusinessHoursOfDay,\n            thu: BusinessHoursOfDay,\n            fri: BusinessHoursOfDay,\n        }\n        timezone: string,\n    }\n    \n    \n\n    export interface BusinessContact extends Contact {\n        /** \n         * The contact's business profile\n         */\n        businessProfile: {\n            /** The contact's business profile id */\n            id: ContactId,\n\n            /** The contact's business profile tag */\n            tag: string,\n\n            /** The contact's business profile description */\n            description: string,\n\n            /** The contact's business profile categories */\n            categories: BusinessCategory[],\n\n            /** The contact's business profile options */\n            profileOptions: {\n                /** The contact's business profile commerce experience*/\n                commerceExperience: string,\n                \n                /** The contact's business profile cart options */\n                cartEnabled: boolean,\n            }\n\n            /** The contact's business profile email */\n            email: string,\n\n            /** The contact's business profile websites */\n            website: string[],\n\n            /** The contact's business profile latitude */\n            latitude: number,\n            \n            /** The contact's business profile longitude */\n            longitude: number,\n            \n            /** The contact's business profile work hours*/\n            businessHours: BusinessHours\n            \n            /** The contact's business profile address */\n            address: string,\n            \n            /** The contact's business profile facebook page */\n            fbPage: object,\n            \n            /** Indicate if the contact's business profile linked */\n            ifProfileLinked: boolean\n            \n            /** The contact's business profile coverPhoto */\n            coverPhoto: null | any,\n        }\n    }\n\n    export interface PrivateContact extends Contact {\n\n    }\n\n    /**\n     * Represents a Chat on WhatsApp\n     *\n     * @example\n     * {\n     *   id: {\n     *     server: 'c.us',\n     *     user: '554199999999',\n     *     _serialized: `554199999999@c.us`\n     *   },\n     *   name: '+55 41 9999-9999',\n     *   isGroup: false,\n     *   isReadOnly: false,\n     *   unreadCount: 6,\n     *   timestamp: 1591484087,\n     *   archived: false\n     * }\n     */\n    export interface Chat {\n        /** Indicates if the Chat is archived */\n        archived: boolean,\n        /** ID that represents the chat */\n        id: ChatId,\n        /** Indicates if the Chat is a Group Chat */\n        isGroup: boolean,\n        /** Indicates if the Chat is readonly */\n        isReadOnly: boolean,\n        /** Indicates if the Chat is muted */\n        isMuted: boolean,\n        /** Unix timestamp for when the mute expires */\n        muteExpiration: number,\n        /** Title of the chat */\n        name: string,\n        /** Unix timestamp for when the last activity occurred */\n        timestamp: number,\n        /** Amount of messages unread */\n        unreadCount: number,\n        /** Last message of chat */\n        lastMessage: Message,\n        /** Indicates if the Chat is pinned */\n        pinned: boolean,\n\n        /** Archives this chat */\n        archive: () => Promise<void>,\n        /** Pins this chat and returns its new Pin state */\n        pin: () => Promise<boolean>,\n        /** Unpins this chat and returns its new Pin state */\n        unpin: () => Promise<boolean>,\n        /** Clears all messages from the chat */\n        clearMessages: () => Promise<boolean>,\n        /** Stops typing or recording in chat immediately. */\n        clearState: () => Promise<boolean>,\n        /** Deletes the chat */\n        delete: () => Promise<boolean>,\n        /** Loads chat messages, sorted from earliest to latest. */\n        fetchMessages: (searchOptions: MessageSearchOptions) => Promise<Message[]>,\n        /** Mutes this chat forever, unless a date is specified */\n        mute: (unmuteDate?: Date) => Promise<void>,\n        /** Send a message to this chat */\n        sendMessage: (content: MessageContent, options?: MessageSendOptions) => Promise<Message>,\n        /** Set the message as seen */\n        sendSeen: () => Promise<void>,\n        /** Simulate recording audio in chat. This will last for 25 seconds */\n        sendStateRecording: () => Promise<void>,\n        /** Simulate typing in chat. This will last for 25 seconds. */\n        sendStateTyping: () => Promise<void>,\n        /** un-archives this chat */\n        unarchive: () => Promise<void>,\n        /** Unmutes this chat */\n        unmute: () => Promise<void>,\n        /** Returns the Contact that corresponds to this Chat. */\n        getContact: () => Promise<Contact>,\n        /** Marks this Chat as unread */\n        markUnread: () => Promise<void>,\n        /** Returns array of all Labels assigned to this Chat */\n        getLabels: () => Promise<Label[]>,\n        /** Add or remove labels to this Chat */\n        changeLabels: (labelIds: Array<string | number>) => Promise<void>\n        /** Sync history conversation of the Chat */\n        syncHistory: () => Promise<boolean>\n    }\n\n    export interface MessageSearchOptions {\n        /**\n         * The amount of messages to return. If no limit is specified, the available messages will be returned.\n         * Note that the actual number of returned messages may be smaller if there aren't enough messages in the conversation. \n         * Set this to Infinity to load all messages.\n         */\n        limit?: number\n        /**\n        * Return only messages from the bot number or vise versa. To get all messages, leave the option undefined.\n        */\n        fromMe?: boolean\n    }\n\n    /**\n     * Id that represents the chat\n     * \n     * @example\n     * id: {\n     *   server: 'c.us',\n     *   user: '554199999999',\n     *   _serialized: `554199999999@c.us`\n     * },\n     */\n    export interface ChatId {\n        /**\n         * Whatsapp server domain\n         * @example `c.us`\n         */\n        server: string,\n        /**\n         * User whatsapp number\n         * @example `554199999999`\n         */\n        user: string,\n        /**\n         * Serialized id\n         * @example `554199999999@c.us`\n         */\n        _serialized: string,\n    }\n\n    export interface PrivateChat extends Chat {\n\n    }\n\n    export type GroupParticipant = {\n        id: ContactId,\n        isAdmin: boolean\n        isSuperAdmin: boolean\n    }\n\n    /** Promotes or demotes participants by IDs to regular users or admins */\n    export type ChangeParticipantsPermissions = \n        (participantIds: Array<string>) => Promise<{ status: number }>\n\n    /** An object that handles the result for addParticipants method */\n    export interface AddParticipantsResult {\n        [participantId: string]: {\n            code: number;\n            message: string;\n            isInviteV4Sent: boolean,\n        }\n    }\n\n    /** An object that handles options for adding participants */\n    export interface AddParticipantsOptions {\n        /**\n         * The number of milliseconds to wait before adding the next participant.\n         * If it is an array, a random sleep time between the sleep[0] and sleep[1] values will be added\n         * (the difference must be >=100 ms, otherwise, a random sleep time between sleep[1] and sleep[1] + 100\n         * will be added). If sleep is a number, a sleep time equal to its value will be added\n         * @default [250,500]\n         */\n        sleep?: Array<number>|number,\n        /**\n         * If true, the inviteV4 will be sent to those participants\n         * who have restricted others from being automatically added to groups,\n         * otherwise the inviteV4 won't be sent\n         * @default true\n         */\n        autoSendInviteV4?: boolean,\n        /**\n         * The comment to be added to an inviteV4 (empty string by default)\n         * @default ''\n         */\n        comment?: string\n    }\n\n    /** An object that handles the information about the group membership request */\n    export interface GroupMembershipRequest {\n        /** The wid of a user who requests to enter the group */\n        id: Object;\n        /** The wid of a user who created that request */\n        addedBy: Object;\n        /** The wid of a community parent group to which the current group is linked */\n        parentGroupId: Object | null;\n        /** The method used to create the request: NonAdminAdd/InviteLink/LinkedGroupJoin */\n        requestMethod: string,\n        /** The timestamp the request was created at */\n        t: number\n    }\n\n    /** An object that handles the result for membership request action */\n    export interface MembershipRequestActionResult {\n        /** User ID whos membership request was approved/rejected */\n        requesterId: Array<string> | string | null;\n        /** An error code that occurred during the operation for the participant */\n        error?: number;\n        /** A message with a result of membership request action */\n        message: string;\n    }\n\n    /** Options for performing a membership request action  */\n    export interface MembershipRequestActionOptions {\n        /** User ID/s who requested to join the group, if no value is provided, the method will search for all membership requests for that group */\n        requesterIds: Array<string> | string | null;\n        /** The number of milliseconds to wait before performing an operation for the next requester. If it is an array, a random sleep time between the sleep[0] and sleep[1] values will be added (the difference must be >=100 ms, otherwise, a random sleep time between sleep[1] and sleep[1] + 100 will be added). If sleep is a number, a sleep time equal to its value will be added. By default, sleep is an array with a value of [250, 500] */\n        sleep: Array<number> | number | null;\n    }\n\n    export interface GroupChat extends Chat {\n        /** Group owner */\n        owner: ContactId;\n        /** Date at which the group was created */\n        createdAt: Date;\n        /** Group description */\n        description: string;\n        /** Group participants */\n        participants: Array<GroupParticipant>;\n        /** Adds a list of participants by ID to the group */\n        addParticipants: (participantIds: string | string[], options?: AddParticipantsOptions) => Promise<{ [key: string]: AddParticipantsResult } | string>;\n        /** Removes a list of participants by ID to the group */\n        removeParticipants: (participantIds: string[]) => Promise<{ status: number }>;\n        /** Promotes participants by IDs to admins */\n        promoteParticipants: ChangeParticipantsPermissions;\n        /** Demotes participants by IDs to regular users */\n        demoteParticipants: ChangeParticipantsPermissions;\n        /** Updates the group subject */\n        setSubject: (subject: string) => Promise<boolean>;\n        /** Updates the group description */\n        setDescription: (description: string) => Promise<boolean>;\n        /**\n         * Updates the group setting to allow only admins to add members to the group.\n         * @param {boolean} [adminsOnly=true] Enable or disable this option \n         * @returns {Promise<boolean>} Returns true if the setting was properly updated. This can return false if the user does not have the necessary permissions.\n         */\n        setAddMembersAdminsOnly: (adminsOnly?: boolean) => Promise<boolean>;\n        /** Updates the group settings to only allow admins to send messages\n         * @param {boolean} [adminsOnly=true] Enable or disable this option\n         * @returns {Promise<boolean>} Returns true if the setting was properly updated. This can return false if the user does not have the necessary permissions.\n         */\n        setMessagesAdminsOnly: (adminsOnly?: boolean) => Promise<boolean>;\n        /**\n         * Updates the group settings to only allow admins to edit group info (title, description, photo).\n         * @param {boolean} [adminsOnly=true] Enable or disable this option\n         * @returns {Promise<boolean>} Returns true if the setting was properly updated. This can return false if the user does not have the necessary permissions.\n         */\n        setInfoAdminsOnly: (adminsOnly?: boolean) => Promise<boolean>;\n        /**\n         * Gets an array of membership requests\n         * @returns {Promise<Array<GroupMembershipRequest>>} An array of membership requests\n         */\n        getGroupMembershipRequests: () => Promise<Array<GroupMembershipRequest>>;\n        /**\n         * Approves membership requests if any\n         * @param {MembershipRequestActionOptions} options Options for performing a membership request action\n         * @returns {Promise<Array<MembershipRequestActionResult>>} Returns an array of requester IDs whose membership requests were approved and an error for each requester, if any occurred during the operation. If there are no requests, an empty array will be returned\n         */\n        approveGroupMembershipRequests: (options: MembershipRequestActionOptions) => Promise<Array<MembershipRequestActionResult>>;\n        /**\n         * Rejects membership requests if any\n         * @param {MembershipRequestActionOptions} options Options for performing a membership request action\n         * @returns {Promise<Array<MembershipRequestActionResult>>} Returns an array of requester IDs whose membership requests were rejected and an error for each requester, if any occurred during the operation. If there are no requests, an empty array will be returned\n         */\n        rejectGroupMembershipRequests: (options: MembershipRequestActionOptions) => Promise<Array<MembershipRequestActionResult>>;\n        /** Gets the invite code for a specific group */\n        getInviteCode: () => Promise<string>;\n        /** Invalidates the current group invite code and generates a new one */\n        revokeInvite: () => Promise<void>;\n        /** Makes the bot leave the group */\n        leave: () => Promise<void>;\n        /** Sets the group's picture.*/\n        setPicture: (media: MessageMedia) => Promise<boolean>;\n        /** Deletes the group's picture */\n        deletePicture: () => Promise<boolean>;\n    }\n\n    /**\n     * Represents the metadata associated with a given product\n     *\n     */\n    export interface ProductMetadata {\n        /** Product Id */\n        id: string,\n        /** Product Name */\n        name: string,\n        /** Product Description */\n        description: string,\n        /** Retailer ID */\n        retailer_id?: string\n    }\n\n    /**\n     * Represents a Product on Whatsapp\n     * @example\n     * {\n     * \"id\": \"123456789\",\n     * \"price\": \"150000\",\n     * \"thumbnailId\": \"123456789\",\n     * \"thumbnailUrl\": \"https://mmg.whatsapp.net\",\n     * \"currency\": \"GTQ\",\n     * \"name\": \"Store Name\",\n     * \"quantity\": 1\n     * }\n     */\n    export interface Product {\n        /** Product Id */\n        id: string,\n        /** Price */\n        price?: string,\n        /** Product Thumbnail*/\n        thumbnailUrl: string,\n        /** Currency */\n        currency: string,\n        /** Product Name */\n        name: string,\n        /** Product Quantity*/\n        quantity: number,\n        /** Gets the Product metadata */\n        getData: () => Promise<ProductMetadata>\n    }\n\n    /**\n     * Represents a Order on WhatsApp\n     *\n     * @example\n     * {\n     * \"products\": [\n     * {\n     * \"id\": \"123456789\",\n     * \"price\": \"150000\",\n     * \"thumbnailId\": \"123456789\",\n     * \"thumbnailUrl\": \"https://mmg.whatsapp.net\",\n     * \"currency\": \"GTQ\",\n     * \"name\": \"Store Name\",\n     * \"quantity\": 1\n     * }\n     * ],\n     * \"subtotal\": \"150000\",\n     * \"total\": \"150000\",\n     * \"currency\": \"GTQ\",\n     * \"createdAt\": 1610136796,\n     * \"sellerJid\": \"55555555@s.whatsapp.net\"\n     * }\n     */\n    export interface Order {\n        /** List of products*/\n        products: Array<Product>,\n        /** Order Subtotal */\n        subtotal: string,\n        /** Order Total */\n        total: string,\n        /** Order Currency */\n        currency: string,\n        /** Order Created At*/\n        createdAt: number;\n    }\n\n    /**\n     * Represents a Payment on WhatsApp\n     *\n     * @example\n     * {\n     * id: {\n     * fromMe: true,\n     * remote: {\n     * server: 'c.us',\n     * user: '5511999999999',\n     * _serialized: '5511999999999@c.us'\n     * },\n     *  id: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n     * _serialized: 'true_5511999999999@c.us_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'\n     * },\n     * paymentCurrency: 'BRL',\n     * paymentAmount1000: 1000,\n     * paymentMessageReceiverJid: {\n     * server: 'c.us',\n     * user: '5511999999999',\n     * _serialized: '5511999999999@c.us'\n     * },\n     * paymentTransactionTimestamp: 1623463058,\n     * paymentStatus: 4,\n     * paymentTxnStatus: 4,\n     * paymentNote: 'note'\n     * }\n     */\n    export interface Payment {\n        /** Payment Id*/\n        id: object,\n        /** Payment currency */\n        paymentCurrency: string,\n        /** Payment ammount  */\n        paymentAmount1000 : number,\n        /** Payment receiver */\n        paymentMessageReceiverJid : object,\n        /** Payment transaction timestamp */\n        paymentTransactionTimestamp : number,\n        /** Payment paymentStatus */\n        paymentStatus : number,\n        /** Integer that represents the payment Text */\n        paymentTxnStatus  : number,\n        /** The note sent with the payment */\n        paymentNote  : string;\n    }\n    \n    /**\n     * Represents a Call on WhatsApp\n     *\n     * @example\n     * Call {\n     * id: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',\n     * from: '5511999999@c.us',\n     * timestamp: 1625003709,\n     * isVideo: false,\n     * isGroup: false,\n     * fromMe: false,\n     * canHandleLocally: false,\n     * webClientShouldHandle: false,\n     * participants: []\n     * }\n     */\n    export interface Call {\n        /** Call Id */\n        id: string,\n        /** from */\n        from?: string,\n        /** Unix timestamp for when the call was created*/\n        timestamp: number,\n        /** Is video */\n        isVideo: boolean,\n        /** Is Group */\n        isGroup: boolean,\n        /** Indicates if the call was sent by the current user */\n        fromMe: boolean,\n        /** indicates if the call can be handled in waweb */\n        canHandleLocally: boolean,\n        /** indicates if the call should be handled in waweb */\n        webClientShouldHandle: boolean,\n        /** Object with participants */\n        participants: object\n\n        /** Reject the call */\n        reject: () => Promise<void>\n    }\n\n    /** Message type List */\n    export class List {\n        body: string\n        buttonText: string\n        sections: Array<any>\n        title?: string | null\n        footer?: string | null\n        \n        constructor(body: string, buttonText: string, sections: Array<any>, title?: string | null, footer?: string | null)\n    }\n    \n    /** Message type Buttons */\n    export class Buttons {\n        body: string | MessageMedia\n        buttons: Array<{ buttonId: string; buttonText: {displayText: string}; type: number }>\n        title?: string | null\n        footer?: string | null\n        \n        constructor(body: string, buttons: Array<{ id?: string; body: string }>, title?: string | null, footer?: string | null)\n    }\n\n    /** Message type Reaction */\n    export class Reaction {\n        id: MessageId\n        orphan: number\n        orphanReason?: string\n        timestamp: number\n        reaction: string\n        read: boolean\n        msgId: MessageId\n        senderId: string\n        ack?: number\n    }\n    \n    export type ReactionList = {\n        id: string,\n        aggregateEmoji: string,\n        hasReactionByMe: boolean,\n        senders: Array<Reaction>\n    }\n}\n\nexport = WAWebJS\n"
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 1.201171875,
          "content": "'use strict';\n\nconst Constants = require('./src/util/Constants');\n\nmodule.exports = {\n    Client: require('./src/Client'),\n    \n    version: require('./package.json').version,\n\n    // Structures\n    Chat: require('./src/structures/Chat'),\n    PrivateChat: require('./src/structures/PrivateChat'),\n    GroupChat: require('./src/structures/GroupChat'),\n    Message: require('./src/structures/Message'),\n    MessageMedia: require('./src/structures/MessageMedia'),\n    Contact: require('./src/structures/Contact'),\n    PrivateContact: require('./src/structures/PrivateContact'),\n    BusinessContact: require('./src/structures/BusinessContact'),\n    ClientInfo: require('./src/structures/ClientInfo'),\n    Location: require('./src/structures/Location'),\n    Poll: require('./src/structures/Poll'),\n    ProductMetadata: require('./src/structures/ProductMetadata'),\n    List: require('./src/structures/List'),\n    Buttons: require('./src/structures/Buttons'),\n    Broadcast: require('./src/structures/Broadcast'),\n    \n    // Auth Strategies\n    NoAuth: require('./src/authStrategies/NoAuth'),\n    LocalAuth: require('./src/authStrategies/LocalAuth'),\n    RemoteAuth: require('./src/authStrategies/RemoteAuth'),\n    \n    ...Constants\n};\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.4345703125,
          "content": "{\n  \"name\": \"whatsapp-web.js\",\n  \"version\": \"1.26.1-alpha.3\",\n  \"description\": \"Library for interacting with the WhatsApp Web API \",\n  \"main\": \"./index.js\",\n  \"typings\": \"./index.d.ts\",\n  \"scripts\": {\n    \"test\": \"mocha tests --recursive --timeout 5000\",\n    \"test-single\": \"mocha\",\n    \"shell\": \"node --experimental-repl-await ./shell.js\",\n    \"generate-docs\": \"npx jsdoc --configure .jsdoc.json --verbose\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/pedroslopez/whatsapp-web.js.git\"\n  },\n  \"keywords\": [\n    \"whatsapp\",\n    \"whatsapp-web\",\n    \"api\",\n    \"bot\",\n    \"client\",\n    \"node\"\n  ],\n  \"author\": \"Pedro Lopez\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/pedroslopez/whatsapp-web.js/issues\"\n  },\n  \"homepage\": \"https://wwebjs.dev/\",\n  \"dependencies\": {\n    \"@pedroslopez/moduleraid\": \"^5.0.2\",\n    \"fluent-ffmpeg\": \"2.1.2\",\n    \"mime\": \"^3.0.0\",\n    \"node-fetch\": \"^2.6.9\",\n    \"node-webpmux\": \"3.1.7\",\n    \"puppeteer\": \"^18.2.1\"\n  },\n  \"devDependencies\": {\n    \"@types/node-fetch\": \"^2.5.12\",\n    \"chai\": \"^4.3.4\",\n    \"chai-as-promised\": \"^7.1.1\",\n    \"dotenv\": \"^16.0.0\",\n    \"eslint\": \"^8.4.1\",\n    \"eslint-plugin-mocha\": \"^10.0.3\",\n    \"jsdoc\": \"^3.6.4\",\n    \"jsdoc-baseline\": \"^0.1.5\",\n    \"mocha\": \"^9.0.2\",\n    \"sinon\": \"^13.0.1\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"optionalDependencies\": {\n    \"archiver\": \"^5.3.1\",\n    \"fs-extra\": \"^10.1.0\",\n    \"unzipper\": \"^0.10.11\"\n  }\n}\n"
        },
        {
          "name": "shell.js",
          "type": "blob",
          "size": 0.8046875,
          "content": "/**\n * ==== wwebjs-shell ====\n * Used for quickly testing library features\n * \n * Running `npm run shell` will start WhatsApp Web with headless=false\n * and then drop you into Node REPL with `client` in its context. \n */\n\nconst repl = require('repl');\n\nconst { Client, LocalAuth } = require('./index');\n\nconst client = new Client({\n    puppeteer: { headless: false }, \n    authStrategy: new LocalAuth()\n});\n\nconsole.log('Initializing...');\n\nclient.initialize();\n\nclient.on('qr', () => {\n    console.log('Please scan the QR code on the browser.');\n});\n\nclient.on('authenticated', (session) => {\n    console.log(JSON.stringify(session));\n});\n\nclient.on('ready', () => {\n    const shell = repl.start('wwebjs> ');\n    shell.context.client = client;\n    shell.on('exit', async () => {\n        await client.destroy();\n    });\n});\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}