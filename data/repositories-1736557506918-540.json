{
  "metadata": {
    "timestamp": 1736557506918,
    "page": 540,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "chenfei-wu/TaskMatrix",
      "stars": 34546,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".DS_Store",
          "type": "blob",
          "size": 6,
          "content": null
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.43,
          "content": "# Microsoft Open Source Code of Conduct\n\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/).\n\nResources:\n\n- [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/)\n- [Microsoft Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/)\n- Contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with questions or concerns"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.67,
          "content": "\nTo contribute to this GitHub project, you can follow these steps:\n\n1. Fork the repository you want to contribute to by clicking the \"Fork\" button on the project page.\n\n2. Clone the repository to your local machine and enter the newly created repo using the following commands:\n\n```\ngit clone https://github.com/YOUR-GITHUB-USERNAME/TaskMatrix.git\ncd TaskMatrix\n```\n3. Create a new branch for your changes using the following command:\n\n```\ngit checkout -b \"branch-name\"\n```\n4. Make your changes to the code or documentation.\n\n5. Add the changes to the staging area using the following command:\n```\ngit add . \n```\n\n6. Commit the changes with a meaningful commit message using the following command:\n```\ngit commit -m \"your commit message\"\n```\n7. Push the changes to your forked repository using the following command:\n```\ngit push origin branch-name\n```\n8. Go to the GitHub website and navigate to your forked repository.\n\n9. Click the \"New pull request\" button.\n\n10. Select the branch you just pushed to and the branch you want to merge into on the original repository.\n\n11. Add a description of your changes and click the \"Create pull request\" button.\n\n12. Wait for the project maintainer to review your changes and provide feedback.\n\n13. Make any necessary changes based on feedback and repeat steps 5-12 until your changes are accepted and merged into the main project.\n\n14. Once your changes are merged, you can update your forked repository and local copy of the repository with the following commands:\n\n```\ngit fetch upstream\ngit checkout main\ngit merge upstream/main\n```\nFinally, delete the branch you created with the following command:\n```\ngit branch -d branch-name\n```\nThat's it you made it üê£‚≠ê‚≠ê"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.91,
          "content": "MIT License\n\nCopyright (c) 2023 Microsoft\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nThe recommended models in this Repo are just examples, used for scientific research exploring the concept of task automation and benchmarking with the paper published at [Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models](https://arxiv.org/abs/2303.04671). Users can replace the models in this Repo according to their research needs. When using the recommended models in this Repo, you need to comply with the licenses of these models respectively. Microsoft shall not be held liable for any infringement of third-party rights resulting from your usage of this repo. Users agree to defend, indemnify and hold Microsoft harmless from and against all damages, costs, and attorneys' fees in connection with any claims arising from this Repo. If anyone believes that this Repo infringes on your rights, please notify the project owner [email](chewu@microsoft.com).\n"
        },
        {
          "name": "LowCodeLLM",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.54,
          "content": "# TaskMatrix\n\n**TaskMatrix** connects ChatGPT and a series of Visual Foundation Models to enable **sending** and **receiving** images during chatting.\n\nSee our paper: [<font size=5>Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models</font>](https://arxiv.org/abs/2303.04671)\n\n<a src=\"https://img.shields.io/badge/%F0%9F%A4%97-Open%20in%20Spaces-blue\" href=\"https://huggingface.co/spaces/microsoft/visual_chatgpt\">\n    <img src=\"https://img.shields.io/badge/%F0%9F%A4%97-Open%20in%20Spaces-blue\" alt=\"Open in Spaces\">\n</a>\n\n<a src=\"https://colab.research.google.com/assets/colab-badge.svg\" href=\"https://colab.research.google.com/drive/1P3jJqKEWEaeNcZg8fODbbWeQ3gxOHk2-?usp=sharing\">\n    <img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open in Colab\">\n</a>\n\n## Updates:\n- Now TaskMatrix supports [GroundingDINO](https://github.com/IDEA-Research/GroundingDINO) and [segment-anything](https://github.com/facebookresearch/segment-anything)! Thanks **@jordddan** for his efforts. For the image editing case, `GroundingDINO` is first used to locate bounding boxes guided by given text, then `segment-anything` is used to generate the related mask, and finally stable diffusion inpainting is used to edit image based on the mask. \n    - Firstly, run `python visual_chatgpt.py --load \"Text2Box_cuda:0,Segmenting_cuda:0,Inpainting_cuda:0,ImageCaptioning_cuda:0\"`\n    - Then, say `find xxx in the image` or `segment xxx in the image`. `xxx` is an object. TaskMatrix will return the detection or segmentation result!\n\n\n- Now TaskMatrix can support Chinese! Thanks to **@Wang-Xiaodong1899** for his efforts.\n- We propose the **template** idea in TaskMatrix!\n    - A template is a **pre-defined execution flow** that assists ChatGPT in assembling complex tasks involving multiple foundation models. \n    - A template contains the **experiential solution** to complex tasks as determined by humans. \n    - A template can **invoke multiple foundation models** or even **establish a new ChatGPT session**\n    - To define a **template**, simply adding a class with attributes `template_model = True`\n- Thanks to **@ShengmingYin** and **@thebestannie** for providing a template example in `InfinityOutPainting` class (see the following gif)\n    - Firstly, run `python visual_chatgpt.py --load \"Inpainting_cuda:0,ImageCaptioning_cuda:0,VisualQuestionAnswering_cuda:0\"`\n    - Secondly, say `extend the image to 2048x1024` to TaskMatrix!\n    - By simply creating an `InfinityOutPainting` template, TaskMatrix can seamlessly extend images to any size through collaboration with existing `ImageCaptioning`, `Inpainting`, and `VisualQuestionAnswering` foundation models, **without the need for additional training**.\n- **TaskMatrix needs the effort of the community! We crave your contribution to add new and interesting features!**\n<img src=\"./assets/demo_inf.gif\" width=\"750\">\n\n\n## Insight & Goal:\nOn the one hand, **ChatGPT (or LLMs)** serves as a **general interface** that provides a broad and diverse understanding of a\nwide range of topics. On the other hand, **Foundation Models** serve as **domain experts** by providing deep knowledge in specific domains.\nBy leveraging **both general and deep knowledge**, we aim at building an AI that is capable of handling various tasks.\n\n\n## Demo \n<img src=\"./assets/demo_short.gif\" width=\"750\">\n\n##  System Architecture \n\n \n<p align=\"center\"><img src=\"./assets/figure.jpg\" alt=\"Logo\"></p>\n\n\n## Quick Start\n\n```\n# clone the repo\ngit clone https://github.com/microsoft/TaskMatrix.git\n\n# Go to directory\ncd visual-chatgpt\n\n# create a new environment\nconda create -n visgpt python=3.8\n\n# activate the new environment\nconda activate visgpt\n\n#  prepare the basic environments\npip install -r requirements.txt\npip install  git+https://github.com/IDEA-Research/GroundingDINO.git\npip install  git+https://github.com/facebookresearch/segment-anything.git\n\n# prepare your private OpenAI key (for Linux)\nexport OPENAI_API_KEY={Your_Private_Openai_Key}\n\n# prepare your private OpenAI key (for Windows)\nset OPENAI_API_KEY={Your_Private_Openai_Key}\n\n# Start TaskMatrix !\n# You can specify the GPU/CPU assignment by \"--load\", the parameter indicates which \n# Visual Foundation Model to use and where it will be loaded to\n# The model and device are separated by underline '_', the different models are separated by comma ','\n# The available Visual Foundation Models can be found in the following table\n# For example, if you want to load ImageCaptioning to cpu and Text2Image to cuda:0\n# You can use: \"ImageCaptioning_cpu,Text2Image_cuda:0\"\n\n# Advice for CPU Users\npython visual_chatgpt.py --load ImageCaptioning_cpu,Text2Image_cpu\n\n# Advice for 1 Tesla T4 15GB  (Google Colab)                       \npython visual_chatgpt.py --load \"ImageCaptioning_cuda:0,Text2Image_cuda:0\"\n                                \n# Advice for 4 Tesla V100 32GB                            \npython visual_chatgpt.py --load \"Text2Box_cuda:0,Segmenting_cuda:0,\n    Inpainting_cuda:0,ImageCaptioning_cuda:0,\n    Text2Image_cuda:1,Image2Canny_cpu,CannyText2Image_cuda:1,\n    Image2Depth_cpu,DepthText2Image_cuda:1,VisualQuestionAnswering_cuda:2,\n    InstructPix2Pix_cuda:2,Image2Scribble_cpu,ScribbleText2Image_cuda:2,\n    SegText2Image_cuda:2,Image2Pose_cpu,PoseText2Image_cuda:2,\n    Image2Hed_cpu,HedText2Image_cuda:3,Image2Normal_cpu,\n    NormalText2Image_cuda:3,Image2Line_cpu,LineText2Image_cuda:3\"\n\n```\n\n## GPU memory usage\nHere we list the GPU memory usage of each visual foundation model, you can specify which one you like:\n\n| Foundation Model        | GPU Memory (MB) |\n|------------------------|-----------------|\n| ImageEditing           | 3981            |\n| InstructPix2Pix        | 2827            |\n| Text2Image             | 3385            |\n| ImageCaptioning        | 1209            |\n| Image2Canny            | 0               |\n| CannyText2Image        | 3531            |\n| Image2Line             | 0               |\n| LineText2Image         | 3529            |\n| Image2Hed              | 0               |\n| HedText2Image          | 3529            |\n| Image2Scribble         | 0               |\n| ScribbleText2Image     | 3531            |\n| Image2Pose             | 0               |\n| PoseText2Image         | 3529            |\n| Image2Seg              | 919             |\n| SegText2Image          | 3529            |\n| Image2Depth            | 0               |\n| DepthText2Image        | 3531            |\n| Image2Normal           | 0               |\n| NormalText2Image       | 3529            |\n| VisualQuestionAnswering| 1495            |\n\n## Acknowledgement\nWe appreciate the open source of the following projects:\n\n[Hugging Face](https://github.com/huggingface) &#8194;\n[LangChain](https://github.com/hwchase17/langchain) &#8194;\n[Stable Diffusion](https://github.com/CompVis/stable-diffusion) &#8194; \n[ControlNet](https://github.com/lllyasviel/ControlNet) &#8194; \n[InstructPix2Pix](https://github.com/timothybrooks/instruct-pix2pix) &#8194; \n[CLIPSeg](https://github.com/timojl/clipseg) &#8194;\n[BLIP](https://github.com/salesforce/BLIP) &#8194;\n\n## Contact Information\nFor help or issues using the TaskMatrix, please submit a GitHub issue.\n\nFor other communications, please contact Chenfei WU (chewu@microsoft.com) or Nan DUAN (nanduan@microsoft.com).\n\n## Trademark Notice\n\nTrademarks This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow [Microsoft‚Äôs Trademark & Brand Guidelines](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks). Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party‚Äôs policies.\n\n## Disclaimer\nThe recommended models in this Repo are just examples, used for scientific research exploring the concept of task automation and benchmarking with the paper published at [Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models](https://arxiv.org/abs/2303.04671). Users can replace the models in this Repo according to their research needs. When using the recommended models in this Repo, you need to comply with the licenses of these models respectively. Microsoft shall not be held liable for any infringement of third-party rights resulting from your usage of this repo. Users agree to defend, indemnify and hold Microsoft harmless from and against all damages, costs, and attorneys' fees in connection with any claims arising from this Repo. If anyone believes that this Repo infringes on your rights, please notify the project owner [email](chewu@microsoft.com).\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 2.69,
          "content": "<!-- BEGIN MICROSOFT SECURITY.MD V0.0.7 BLOCK -->\n\n## Security\n\nMicrosoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet), [Xamarin](https://github.com/xamarin), and [our GitHub organizations](https://opensource.microsoft.com/).\n\nIf you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/opensource/security/definition), please report it to us as described below.\n\n## Reporting Security Issues\n\n**Please do not report security vulnerabilities through public GitHub issues.**\n\nInstead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/opensource/security/create-report).\n\nIf you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/opensource/security/pgpkey).\n\nYou should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://aka.ms/opensource/security/msrc). \n\nPlease include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:\n\n  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)\n  * Full paths of source file(s) related to the manifestation of the issue\n  * The location of the affected source code (tag/branch/commit or direct URL)\n  * Any special configuration required to reproduce the issue\n  * Step-by-step instructions to reproduce the issue\n  * Proof-of-concept or exploit code (if possible)\n  * Impact of the issue, including how an attacker might exploit the issue\n\nThis information will help us triage your report more quickly.\n\nIf you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/opensource/security/bounty) page for more details about our active programs.\n\n## Preferred Languages\n\nWe prefer all communications to be in English.\n\n## Policy\n\nMicrosoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/opensource/security/cvd).\n\n<!-- END MICROSOFT SECURITY.MD BLOCK -->"
        },
        {
          "name": "TaskMatrix.AI",
          "type": "tree",
          "content": null
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.33,
          "content": "langchain==0.0.101\ntorch==1.13.1\ntorchvision==0.14.1\nwget==3.2\naccelerate\naddict\nalbumentations\nbasicsr\ncontrolnet-aux\ndiffusers\neinops\ngradio\nimageio\nimageio-ffmpeg\ninvisible-watermark\nkornia\nnumpy\nomegaconf\nopen_clip_torch\nopenai\nopencv-python\nprettytable\nsafetensors\nstreamlit\ntest-tube\ntimm\ntorchmetrics\ntransformers\nwebdataset\nyapf\n"
        },
        {
          "name": "visual_chatgpt.py",
          "type": "blob",
          "size": 79.14,
          "content": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n\n# coding: utf-8\nimport os\nimport gradio as gr\nimport random\nimport torch\nimport cv2\nimport re\nimport uuid\nfrom PIL import Image, ImageDraw, ImageOps, ImageFont\nimport math\nimport numpy as np\nimport argparse\nimport inspect\nimport tempfile\nfrom transformers import CLIPSegProcessor, CLIPSegForImageSegmentation\nfrom transformers import pipeline, BlipProcessor, BlipForConditionalGeneration, BlipForQuestionAnswering\nfrom transformers import AutoImageProcessor, UperNetForSemanticSegmentation\n\nfrom diffusers import StableDiffusionPipeline, StableDiffusionInpaintPipeline, StableDiffusionInstructPix2PixPipeline\nfrom diffusers import EulerAncestralDiscreteScheduler\nfrom diffusers import StableDiffusionControlNetPipeline, ControlNetModel, UniPCMultistepScheduler\nfrom diffusers.pipelines.stable_diffusion import StableDiffusionSafetyChecker\n\nfrom controlnet_aux import OpenposeDetector, MLSDdetector, HEDdetector\n\nfrom langchain.agents.initialize import initialize_agent\nfrom langchain.agents.tools import Tool\nfrom langchain.chains.conversation.memory import ConversationBufferMemory\nfrom langchain.llms.openai import OpenAI\n\n# Grounding DINO\nimport groundingdino.datasets.transforms as T\nfrom groundingdino.models import build_model\nfrom groundingdino.util import box_ops\nfrom groundingdino.util.slconfig import SLConfig\nfrom groundingdino.util.utils import clean_state_dict, get_phrases_from_posmap\n\n# segment anything\nfrom segment_anything import build_sam, SamPredictor, SamAutomaticMaskGenerator\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport wget\n\nVISUAL_CHATGPT_PREFIX = \"\"\"Visual ChatGPT is designed to be able to assist with a wide range of text and visual related tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. Visual ChatGPT is able to generate human-like text based on the input it receives, allowing it to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.\n\nVisual ChatGPT is able to process and understand large amounts of text and images. As a language model, Visual ChatGPT can not directly read images, but it has a list of tools to finish different visual tasks. Each image will have a file name formed as \"image/xxx.png\", and Visual ChatGPT can invoke different tools to indirectly understand pictures. When talking about images, Visual ChatGPT is very strict to the file name and will never fabricate nonexistent files. When using tools to generate new image files, Visual ChatGPT is also known that the image may not be the same as the user's demand, and will use other visual question answering tools or description tools to observe the real image. Visual ChatGPT is able to use tools in a sequence, and is loyal to the tool observation outputs rather than faking the image content and image file name. It will remember to provide the file name from the last tool observation, if a new image is generated.\n\nHuman may provide new figures to Visual ChatGPT with a description. The description helps Visual ChatGPT to understand this image, but Visual ChatGPT should use tools to finish following tasks, rather than directly imagine from the description.\n\nOverall, Visual ChatGPT is a powerful visual dialogue assistant tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. \n\n\nTOOLS:\n------\n\nVisual ChatGPT  has access to the following tools:\"\"\"\n\nVISUAL_CHATGPT_FORMAT_INSTRUCTIONS = \"\"\"To use a tool, please use the following format:\n\n```\nThought: Do I need to use a tool? Yes\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n```\n\nWhen you have a response to say to the Human, or if you do not need to use a tool, you MUST use the format:\n\n```\nThought: Do I need to use a tool? No\n{ai_prefix}: [your response here]\n```\n\"\"\"\n\nVISUAL_CHATGPT_SUFFIX = \"\"\"You are very strict to the filename correctness and will never fake a file name if it does not exist.\nYou will remember to provide the image file name loyally if it's provided in the last tool observation.\n\nBegin!\n\nPrevious conversation history:\n{chat_history}\n\nNew input: {input}\nSince Visual ChatGPT is a text language model, Visual ChatGPT must use tools to observe images rather than imagination.\nThe thoughts and observations are only visible for Visual ChatGPT, Visual ChatGPT should remember to repeat important information in the final response for Human. \nThought: Do I need to use a tool? {agent_scratchpad} Let's think step by step.\n\"\"\"\n\nVISUAL_CHATGPT_PREFIX_CN = \"\"\"Visual ChatGPT Êó®Âú®ËÉΩÂ§üÂçèÂä©ÂÆåÊàêËåÉÂõ¥ÂπøÊ≥õÁöÑÊñáÊú¨ÂíåËßÜËßâÁõ∏ÂÖ≥‰ªªÂä°Ôºå‰ªéÂõûÁ≠îÁÆÄÂçïÁöÑÈóÆÈ¢òÂà∞Êèê‰æõÂØπÂπøÊ≥õ‰∏ªÈ¢òÁöÑÊ∑±ÂÖ•Ëß£ÈáäÂíåËÆ®ËÆ∫„ÄÇ Visual ChatGPT ËÉΩÂ§üÊ†πÊçÆÊî∂Âà∞ÁöÑËæìÂÖ•ÁîüÊàêÁ±ª‰ºº‰∫∫Á±ªÁöÑÊñáÊú¨Ôºå‰ΩøÂÖ∂ËÉΩÂ§üËøõË°åÂê¨Ëµ∑Êù•Ëá™ÁÑ∂ÁöÑÂØπËØùÔºåÂπ∂Êèê‰æõËøûË¥Ø‰∏î‰∏éÊâãÂ§¥‰∏ªÈ¢òÁõ∏ÂÖ≥ÁöÑÂìçÂ∫î„ÄÇ\n\nVisual ChatGPT ËÉΩÂ§üÂ§ÑÁêÜÂíåÁêÜËß£Â§ßÈáèÊñáÊú¨ÂíåÂõæÂÉè„ÄÇ‰Ωú‰∏∫‰∏ÄÁßçËØ≠Ë®ÄÊ®°ÂûãÔºåVisual ChatGPT ‰∏çËÉΩÁõ¥Êé•ËØªÂèñÂõæÂÉèÔºå‰ΩÜÂÆÉÊúâ‰∏ÄÁ≥ªÂàóÂ∑•ÂÖ∑Êù•ÂÆåÊàê‰∏çÂêåÁöÑËßÜËßâ‰ªªÂä°„ÄÇÊØèÂº†ÂõæÁâáÈÉΩ‰ºöÊúâ‰∏Ä‰∏™Êñá‰ª∂ÂêçÔºåÊ†ºÂºè‰∏∫‚Äúimage/xxx.png‚ÄùÔºåVisual ChatGPTÂèØ‰ª•Ë∞ÉÁî®‰∏çÂêåÁöÑÂ∑•ÂÖ∑Êù•Èó¥Êé•ÁêÜËß£ÂõæÁâá„ÄÇÂú®Ë∞àËÆ∫ÂõæÁâáÊó∂ÔºåVisual ChatGPT ÂØπÊñá‰ª∂ÂêçÁöÑË¶ÅÊ±ÇÈùûÂ∏∏‰∏•Ê†ºÔºåÁªù‰∏ç‰ºö‰º™ÈÄ†‰∏çÂ≠òÂú®ÁöÑÊñá‰ª∂„ÄÇÂú®‰ΩøÁî®Â∑•ÂÖ∑ÁîüÊàêÊñ∞ÁöÑÂõæÂÉèÊñá‰ª∂Êó∂ÔºåVisual ChatGPT‰πüÁü•ÈÅìÂõæÂÉèÂèØËÉΩ‰∏éÁî®Êà∑ÈúÄÊ±Ç‰∏ç‰∏ÄÊ†∑Ôºå‰ºö‰ΩøÁî®ÂÖ∂‰ªñËßÜËßâÈóÆÁ≠îÂ∑•ÂÖ∑ÊàñÊèèËø∞Â∑•ÂÖ∑Êù•ËßÇÂØüÁúüÂÆûÂõæÂÉè„ÄÇ Visual ChatGPT ËÉΩÂ§üÊåâÈ°∫Â∫è‰ΩøÁî®Â∑•ÂÖ∑ÔºåÂπ∂‰∏îÂø†‰∫éÂ∑•ÂÖ∑ËßÇÂØüËæìÂá∫ÔºåËÄå‰∏çÊòØ‰º™ÈÄ†ÂõæÂÉèÂÜÖÂÆπÂíåÂõæÂÉèÊñá‰ª∂Âêç„ÄÇÂ¶ÇÊûúÁîüÊàêÊñ∞ÂõæÂÉèÔºåÂÆÉÂ∞ÜËÆ∞ÂæóÊèê‰æõ‰∏äÊ¨°Â∑•ÂÖ∑ËßÇÂØüÁöÑÊñá‰ª∂Âêç„ÄÇ\n\nHuman ÂèØËÉΩ‰ºöÂêë Visual ChatGPT Êèê‰æõÂ∏¶ÊúâÊèèËø∞ÁöÑÊñ∞ÂõæÂΩ¢„ÄÇÊèèËø∞Â∏ÆÂä© Visual ChatGPT ÁêÜËß£Ëøô‰∏™ÂõæÂÉèÔºå‰ΩÜ Visual ChatGPT Â∫îËØ•‰ΩøÁî®Â∑•ÂÖ∑Êù•ÂÆåÊàê‰ª•‰∏ã‰ªªÂä°ÔºåËÄå‰∏çÊòØÁõ¥Êé•‰ªéÊèèËø∞‰∏≠ÊÉ≥Ë±°„ÄÇÊúâ‰∫õÂ∑•ÂÖ∑Â∞Ü‰ºöËøîÂõûËã±ÊñáÊèèËø∞Ôºå‰ΩÜ‰Ω†ÂØπÁî®Êà∑ÁöÑËÅäÂ§©Â∫îÂΩìÈááÁî®‰∏≠Êñá„ÄÇ\n\nÊÄªÁöÑÊù•ËØ¥ÔºåVisual ChatGPT ÊòØ‰∏Ä‰∏™Âº∫Â§ßÁöÑÂèØËßÜÂåñÂØπËØùËæÖÂä©Â∑•ÂÖ∑ÔºåÂèØ‰ª•Â∏ÆÂä©Â§ÑÁêÜËåÉÂõ¥ÂπøÊ≥õÁöÑ‰ªªÂä°ÔºåÂπ∂Êèê‰æõÂÖ≥‰∫éËåÉÂõ¥ÂπøÊ≥õÁöÑ‰∏ªÈ¢òÁöÑÊúâ‰ª∑ÂÄºÁöÑËßÅËß£Âíå‰ø°ÊÅØ„ÄÇ\n\nÂ∑•ÂÖ∑ÂàóË°®:\n------\n\nVisual ChatGPT ÂèØ‰ª•‰ΩøÁî®Ëøô‰∫õÂ∑•ÂÖ∑:\"\"\"\n\nVISUAL_CHATGPT_FORMAT_INSTRUCTIONS_CN = \"\"\"Áî®Êà∑‰ΩøÁî®‰∏≠ÊñáÂíå‰Ω†ËøõË°åËÅäÂ§©Ôºå‰ΩÜÊòØÂ∑•ÂÖ∑ÁöÑÂèÇÊï∞Â∫îÂΩì‰ΩøÁî®Ëã±Êñá„ÄÇÂ¶ÇÊûúË¶ÅË∞ÉÁî®Â∑•ÂÖ∑Ôºå‰Ω†ÂøÖÈ°ªÈÅµÂæ™Â¶Ç‰∏ãÊ†ºÂºè:\n\n```\nThought: Do I need to use a tool? Yes\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n```\n\nÂΩì‰Ω†‰∏çÂÜçÈúÄË¶ÅÁªßÁª≠Ë∞ÉÁî®Â∑•ÂÖ∑ÔºåËÄåÊòØÂØπËßÇÂØüÁªìÊûúËøõË°åÊÄªÁªìÂõûÂ§çÊó∂Ôºå‰Ω†ÂøÖÈ°ª‰ΩøÁî®Â¶Ç‰∏ãÊ†ºÂºèÔºö\n\n\n```\nThought: Do I need to use a tool? No\n{ai_prefix}: [your response here]\n```\n\"\"\"\n\nVISUAL_CHATGPT_SUFFIX_CN = \"\"\"‰Ω†ÂØπÊñá‰ª∂ÂêçÁöÑÊ≠£Á°ÆÊÄßÈùûÂ∏∏‰∏•Ê†ºÔºåËÄå‰∏îÊ∞∏Ëøú‰∏ç‰ºö‰º™ÈÄ†‰∏çÂ≠òÂú®ÁöÑÊñá‰ª∂„ÄÇ\n\nÂºÄÂßã!\n\nÂõ†‰∏∫Visual ChatGPTÊòØ‰∏Ä‰∏™ÊñáÊú¨ËØ≠Ë®ÄÊ®°ÂûãÔºåÂøÖÈ°ª‰ΩøÁî®Â∑•ÂÖ∑ÂéªËßÇÂØüÂõæÁâáËÄå‰∏çÊòØ‰æùÈù†ÊÉ≥Ë±°„ÄÇ\nÊé®ÁêÜÊÉ≥Ê≥ïÂíåËßÇÂØüÁªìÊûúÂè™ÂØπVisual ChatGPTÂèØËßÅÔºåÈúÄË¶ÅËÆ∞ÂæóÂú®ÊúÄÁªàÂõûÂ§çÊó∂ÊääÈáçË¶ÅÁöÑ‰ø°ÊÅØÈáçÂ§çÁªôÁî®Êà∑Ôºå‰Ω†Âè™ËÉΩÁªôÁî®Êà∑ËøîÂõû‰∏≠ÊñáÂè•Â≠ê„ÄÇÊàë‰ª¨‰∏ÄÊ≠•‰∏ÄÊ≠•ÊÄùËÄÉ„ÄÇÂú®‰Ω†‰ΩøÁî®Â∑•ÂÖ∑Êó∂ÔºåÂ∑•ÂÖ∑ÁöÑÂèÇÊï∞Âè™ËÉΩÊòØËã±Êñá„ÄÇ\n\nËÅäÂ§©ÂéÜÂè≤:\n{chat_history}\n\nÊñ∞ËæìÂÖ•: {input}\nThought: Do I need to use a tool? {agent_scratchpad}\n\"\"\"\n\nos.makedirs('image', exist_ok=True)\n\n\ndef seed_everything(seed):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    return seed\n\n\ndef prompts(name, description):\n    def decorator(func):\n        func.name = name\n        func.description = description\n        return func\n\n    return decorator\n\n\ndef blend_gt2pt(old_image, new_image, sigma=0.15, steps=100):\n    new_size = new_image.size\n    old_size = old_image.size\n    easy_img = np.array(new_image)\n    gt_img_array = np.array(old_image)\n    pos_w = (new_size[0] - old_size[0]) // 2\n    pos_h = (new_size[1] - old_size[1]) // 2\n\n    kernel_h = cv2.getGaussianKernel(old_size[1], old_size[1] * sigma)\n    kernel_w = cv2.getGaussianKernel(old_size[0], old_size[0] * sigma)\n    kernel = np.multiply(kernel_h, np.transpose(kernel_w))\n\n    kernel[steps:-steps, steps:-steps] = 1\n    kernel[:steps, :steps] = kernel[:steps, :steps] / kernel[steps - 1, steps - 1]\n    kernel[:steps, -steps:] = kernel[:steps, -steps:] / kernel[steps - 1, -(steps)]\n    kernel[-steps:, :steps] = kernel[-steps:, :steps] / kernel[-steps, steps - 1]\n    kernel[-steps:, -steps:] = kernel[-steps:, -steps:] / kernel[-steps, -steps]\n    kernel = np.expand_dims(kernel, 2)\n    kernel = np.repeat(kernel, 3, 2)\n\n    weight = np.linspace(0, 1, steps)\n    top = np.expand_dims(weight, 1)\n    top = np.repeat(top, old_size[0] - 2 * steps, 1)\n    top = np.expand_dims(top, 2)\n    top = np.repeat(top, 3, 2)\n\n    weight = np.linspace(1, 0, steps)\n    down = np.expand_dims(weight, 1)\n    down = np.repeat(down, old_size[0] - 2 * steps, 1)\n    down = np.expand_dims(down, 2)\n    down = np.repeat(down, 3, 2)\n\n    weight = np.linspace(0, 1, steps)\n    left = np.expand_dims(weight, 0)\n    left = np.repeat(left, old_size[1] - 2 * steps, 0)\n    left = np.expand_dims(left, 2)\n    left = np.repeat(left, 3, 2)\n\n    weight = np.linspace(1, 0, steps)\n    right = np.expand_dims(weight, 0)\n    right = np.repeat(right, old_size[1] - 2 * steps, 0)\n    right = np.expand_dims(right, 2)\n    right = np.repeat(right, 3, 2)\n\n    kernel[:steps, steps:-steps] = top\n    kernel[-steps:, steps:-steps] = down\n    kernel[steps:-steps, :steps] = left\n    kernel[steps:-steps, -steps:] = right\n\n    pt_gt_img = easy_img[pos_h:pos_h + old_size[1], pos_w:pos_w + old_size[0]]\n    gaussian_gt_img = kernel * gt_img_array + (1 - kernel) * pt_gt_img  # gt img with blur img\n    gaussian_gt_img = gaussian_gt_img.astype(np.int64)\n    easy_img[pos_h:pos_h + old_size[1], pos_w:pos_w + old_size[0]] = gaussian_gt_img\n    gaussian_img = Image.fromarray(easy_img)\n    return gaussian_img\n\n\ndef cut_dialogue_history(history_memory, keep_last_n_words=500):\n    if history_memory is None or len(history_memory) == 0:\n        return history_memory\n    tokens = history_memory.split()\n    n_tokens = len(tokens)\n    print(f\"history_memory:{history_memory}, n_tokens: {n_tokens}\")\n    if n_tokens < keep_last_n_words:\n        return history_memory\n    paragraphs = history_memory.split('\\n')\n    last_n_tokens = n_tokens\n    while last_n_tokens >= keep_last_n_words:\n        last_n_tokens -= len(paragraphs[0].split(' '))\n        paragraphs = paragraphs[1:]\n    return '\\n' + '\\n'.join(paragraphs)\n\n\ndef get_new_image_name(org_img_name, func_name=\"update\"):\n    head_tail = os.path.split(org_img_name)\n    head = head_tail[0]\n    tail = head_tail[1]\n    name_split = tail.split('.')[0].split('_')\n    this_new_uuid = str(uuid.uuid4())[:4]\n    if len(name_split) == 1:\n        most_org_file_name = name_split[0]\n    else:\n        assert len(name_split) == 4\n        most_org_file_name = name_split[3]\n    recent_prev_file_name = name_split[0]\n    new_file_name = f'{this_new_uuid}_{func_name}_{recent_prev_file_name}_{most_org_file_name}.png'\n    return os.path.join(head, new_file_name)\n\nclass InstructPix2Pix:\n    def __init__(self, device):\n        print(f\"Initializing InstructPix2Pix to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n       \n        self.pipe = StableDiffusionInstructPix2PixPipeline.from_pretrained(\"timbrooks/instruct-pix2pix\",\n                                                                           safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n                                                                           torch_dtype=self.torch_dtype).to(device)\n        self.pipe.scheduler = EulerAncestralDiscreteScheduler.from_config(self.pipe.scheduler.config)\n\n    @prompts(name=\"Instruct Image Using Text\",\n             description=\"useful when you want to the style of the image to be like the text. \"\n                         \"like: make it look like a painting. or make it like a robot. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the text. \")\n    def inference(self, inputs):\n        \"\"\"Change style of image.\"\"\"\n        print(\"===>Starting InstructPix2Pix Inference\")\n        image_path, text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        original_image = Image.open(image_path)\n        image = self.pipe(text, image=original_image, num_inference_steps=40, image_guidance_scale=1.2).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"pix2pix\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed InstructPix2Pix, Input Image: {image_path}, Instruct Text: {text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Text2Image:\n    def __init__(self, device):\n        print(f\"Initializing Text2Image to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.pipe = StableDiffusionPipeline.from_pretrained(\"runwayml/stable-diffusion-v1-5\",\n                                                            torch_dtype=self.torch_dtype)\n        self.pipe.to(device)\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                        'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image From User Input Text\",\n             description=\"useful when you want to generate an image from a user input text and save it to a file. \"\n                         \"like: generate an image of an object or something, or generate an image that includes some objects. \"\n                         \"The input to this tool should be a string, representing the text used to generate image. \")\n    def inference(self, text):\n        image_filename = os.path.join('image', f\"{str(uuid.uuid4())[:8]}.png\")\n        prompt = text + ', ' + self.a_prompt\n        image = self.pipe(prompt, negative_prompt=self.n_prompt).images[0]\n        image.save(image_filename)\n        print(\n            f\"\\nProcessed Text2Image, Input Text: {text}, Output Image: {image_filename}\")\n        return image_filename\n\n\nclass ImageCaptioning:\n    def __init__(self, device):\n        print(f\"Initializing ImageCaptioning to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.processor = BlipProcessor.from_pretrained(\"Salesforce/blip-image-captioning-base\")\n        self.model = BlipForConditionalGeneration.from_pretrained(\n            \"Salesforce/blip-image-captioning-base\", torch_dtype=self.torch_dtype).to(self.device)\n\n    @prompts(name=\"Get Photo Description\",\n             description=\"useful when you want to know what is inside the photo. receives image_path as input. \"\n                         \"The input to this tool should be a string, representing the image_path. \")\n    def inference(self, image_path):\n        inputs = self.processor(Image.open(image_path), return_tensors=\"pt\").to(self.device, self.torch_dtype)\n        out = self.model.generate(**inputs)\n        captions = self.processor.decode(out[0], skip_special_tokens=True)\n        print(f\"\\nProcessed ImageCaptioning, Input Image: {image_path}, Output Text: {captions}\")\n        return captions\n\n\nclass Image2Canny:\n    def __init__(self, device):\n        print(\"Initializing Image2Canny\")\n        self.low_threshold = 100\n        self.high_threshold = 200\n\n    @prompts(name=\"Edge Detection On Image\",\n             description=\"useful when you want to detect the edge of the image. \"\n                         \"like: detect the edges of this image, or canny detection on image, \"\n                         \"or perform edge detection on this image, or detect the canny image of this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        image = np.array(image)\n        canny = cv2.Canny(image, self.low_threshold, self.high_threshold)\n        canny = canny[:, :, None]\n        canny = np.concatenate([canny, canny, canny], axis=2)\n        canny = Image.fromarray(canny)\n        updated_image_path = get_new_image_name(inputs, func_name=\"edge\")\n        canny.save(updated_image_path)\n        print(f\"\\nProcessed Image2Canny, Input Image: {inputs}, Output Text: {updated_image_path}\")\n        return updated_image_path\n\n\nclass CannyText2Image:\n    def __init__(self, device):\n        print(f\"Initializing CannyText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-canny\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                            'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Canny Image\",\n             description=\"useful when you want to generate a new real image from both the user description and a canny image.\"\n                         \" like: generate a real image of a object or something from this canny image,\"\n                         \" or generate a new real image of a object or something from this edge image. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description. \")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"canny2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed CannyText2Image, Input Canny: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Text: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Line:\n    def __init__(self, device):\n        print(\"Initializing Image2Line\")\n        self.detector = MLSDdetector.from_pretrained('lllyasviel/ControlNet')\n\n    @prompts(name=\"Line Detection On Image\",\n             description=\"useful when you want to detect the straight line of the image. \"\n                         \"like: detect the straight lines of this image, or straight line detection on image, \"\n                         \"or perform straight line detection on this image, or detect the straight line image of this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        mlsd = self.detector(image)\n        updated_image_path = get_new_image_name(inputs, func_name=\"line-of\")\n        mlsd.save(updated_image_path)\n        print(f\"\\nProcessed Image2Line, Input Image: {inputs}, Output Line: {updated_image_path}\")\n        return updated_image_path\n\n\nclass LineText2Image:\n    def __init__(self, device):\n        print(f\"Initializing LineText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-mlsd\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype\n        )\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                            'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Line Image\",\n             description=\"useful when you want to generate a new real image from both the user description \"\n                         \"and a straight line image. \"\n                         \"like: generate a real image of a object or something from this straight line image, \"\n                         \"or generate a new real image of a object or something from this straight lines. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description. \")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"line2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed LineText2Image, Input Line: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Text: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Hed:\n    def __init__(self, device):\n        print(\"Initializing Image2Hed\")\n        self.detector = HEDdetector.from_pretrained('lllyasviel/ControlNet')\n\n    @prompts(name=\"Hed Detection On Image\",\n             description=\"useful when you want to detect the soft hed boundary of the image. \"\n                         \"like: detect the soft hed boundary of this image, or hed boundary detection on image, \"\n                         \"or perform hed boundary detection on this image, or detect soft hed boundary image of this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        hed = self.detector(image)\n        updated_image_path = get_new_image_name(inputs, func_name=\"hed-boundary\")\n        hed.save(updated_image_path)\n        print(f\"\\nProcessed Image2Hed, Input Image: {inputs}, Output Hed: {updated_image_path}\")\n        return updated_image_path\n\n\nclass HedText2Image:\n    def __init__(self, device):\n        print(f\"Initializing HedText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-hed\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype\n        )\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                            'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Soft Hed Boundary Image\",\n             description=\"useful when you want to generate a new real image from both the user description \"\n                         \"and a soft hed boundary image. \"\n                         \"like: generate a real image of a object or something from this soft hed boundary image, \"\n                         \"or generate a new real image of a object or something from this hed boundary. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"hed2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed HedText2Image, Input Hed: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Scribble:\n    def __init__(self, device):\n        print(\"Initializing Image2Scribble\")\n        self.detector = HEDdetector.from_pretrained('lllyasviel/ControlNet')\n\n    @prompts(name=\"Sketch Detection On Image\",\n             description=\"useful when you want to generate a scribble of the image. \"\n                         \"like: generate a scribble of this image, or generate a sketch from this image, \"\n                         \"detect the sketch from this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        scribble = self.detector(image, scribble=True)\n        updated_image_path = get_new_image_name(inputs, func_name=\"scribble\")\n        scribble.save(updated_image_path)\n        print(f\"\\nProcessed Image2Scribble, Input Image: {inputs}, Output Scribble: {updated_image_path}\")\n        return updated_image_path\n\n\nclass ScribbleText2Image:\n    def __init__(self, device):\n        print(f\"Initializing ScribbleText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-scribble\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype\n        )\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                            'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Sketch Image\",\n             description=\"useful when you want to generate a new real image from both the user description and \"\n                         \"a scribble image or a sketch image. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"scribble2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed ScribbleText2Image, Input Scribble: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Pose:\n    def __init__(self, device):\n        print(\"Initializing Image2Pose\")\n        self.detector = OpenposeDetector.from_pretrained('lllyasviel/ControlNet')\n\n    @prompts(name=\"Pose Detection On Image\",\n             description=\"useful when you want to detect the human pose of the image. \"\n                         \"like: generate human poses of this image, or generate a pose image from this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        pose = self.detector(image)\n        updated_image_path = get_new_image_name(inputs, func_name=\"human-pose\")\n        pose.save(updated_image_path)\n        print(f\"\\nProcessed Image2Pose, Input Image: {inputs}, Output Pose: {updated_image_path}\")\n        return updated_image_path\n\n\nclass PoseText2Image:\n    def __init__(self, device):\n        print(f\"Initializing PoseText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-openpose\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.num_inference_steps = 20\n        self.seed = -1\n        self.unconditional_guidance_scale = 9.0\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit,' \\\n                            ' fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Pose Image\",\n             description=\"useful when you want to generate a new real image from both the user description \"\n                         \"and a human pose image. \"\n                         \"like: generate a real image of a human from this human pose image, \"\n                         \"or generate a new real image of a human from this pose. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"pose2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed PoseText2Image, Input Pose: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\nclass SegText2Image:\n    def __init__(self, device):\n        print(f\"Initializing SegText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-seg\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit,' \\\n                            ' fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Segmentations\",\n             description=\"useful when you want to generate a new real image from both the user description and segmentations. \"\n                         \"like: generate a real image of a object or something from this segmentation image, \"\n                         \"or generate a new real image of a object or something from these segmentations. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"segment2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed SegText2Image, Input Seg: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Depth:\n    def __init__(self, device):\n        print(\"Initializing Image2Depth\")\n        self.depth_estimator = pipeline('depth-estimation')\n\n    @prompts(name=\"Predict Depth On Image\",\n             description=\"useful when you want to detect depth of the image. like: generate the depth from this image, \"\n                         \"or detect the depth map on this image, or predict the depth for this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        depth = self.depth_estimator(image)['depth']\n        depth = np.array(depth)\n        depth = depth[:, :, None]\n        depth = np.concatenate([depth, depth, depth], axis=2)\n        depth = Image.fromarray(depth)\n        updated_image_path = get_new_image_name(inputs, func_name=\"depth\")\n        depth.save(updated_image_path)\n        print(f\"\\nProcessed Image2Depth, Input Image: {inputs}, Output Depth: {updated_image_path}\")\n        return updated_image_path\n\n\nclass DepthText2Image:\n    def __init__(self, device):\n        print(f\"Initializing DepthText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\n            \"fusing/stable-diffusion-v1-5-controlnet-depth\", torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit,' \\\n                            ' fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Depth\",\n             description=\"useful when you want to generate a new real image from both the user description and depth image. \"\n                         \"like: generate a real image of a object or something from this depth image, \"\n                         \"or generate a new real image of a object or something from the depth map. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"depth2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed DepthText2Image, Input Depth: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Normal:\n    def __init__(self, device):\n        print(\"Initializing Image2Normal\")\n        self.depth_estimator = pipeline(\"depth-estimation\", model=\"Intel/dpt-hybrid-midas\")\n        self.bg_threhold = 0.4\n\n    @prompts(name=\"Predict Normal Map On Image\",\n             description=\"useful when you want to detect norm map of the image. \"\n                         \"like: generate normal map from this image, or predict normal map of this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        original_size = image.size\n        image = self.depth_estimator(image)['predicted_depth'][0]\n        image = image.numpy()\n        image_depth = image.copy()\n        image_depth -= np.min(image_depth)\n        image_depth /= np.max(image_depth)\n        x = cv2.Sobel(image, cv2.CV_32F, 1, 0, ksize=3)\n        x[image_depth < self.bg_threhold] = 0\n        y = cv2.Sobel(image, cv2.CV_32F, 0, 1, ksize=3)\n        y[image_depth < self.bg_threhold] = 0\n        z = np.ones_like(x) * np.pi * 2.0\n        image = np.stack([x, y, z], axis=2)\n        image /= np.sum(image ** 2.0, axis=2, keepdims=True) ** 0.5\n        image = (image * 127.5 + 127.5).clip(0, 255).astype(np.uint8)\n        image = Image.fromarray(image)\n        image = image.resize(original_size)\n        updated_image_path = get_new_image_name(inputs, func_name=\"normal-map\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed Image2Normal, Input Image: {inputs}, Output Depth: {updated_image_path}\")\n        return updated_image_path\n\n\nclass NormalText2Image:\n    def __init__(self, device):\n        print(f\"Initializing NormalText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\n            \"fusing/stable-diffusion-v1-5-controlnet-normal\", torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit,' \\\n                            ' fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Normal Map\",\n             description=\"useful when you want to generate a new real image from both the user description and normal map. \"\n                         \"like: generate a real image of a object or something from this normal map, \"\n                         \"or generate a new real image of a object or something from the normal map. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"normal2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed NormalText2Image, Input Normal: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass VisualQuestionAnswering:\n    def __init__(self, device):\n        print(f\"Initializing VisualQuestionAnswering to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.device = device\n        self.processor = BlipProcessor.from_pretrained(\"Salesforce/blip-vqa-base\")\n        self.model = BlipForQuestionAnswering.from_pretrained(\n            \"Salesforce/blip-vqa-base\", torch_dtype=self.torch_dtype).to(self.device)\n\n    @prompts(name=\"Answer Question About The Image\",\n             description=\"useful when you need an answer for a question based on an image. \"\n                         \"like: what is the background color of the last image, how many cats in this figure, what is in this figure. \"\n                         \"The input to this tool should be a comma separated string of two, representing the image_path and the question\")\n    def inference(self, inputs):\n        image_path, question = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        raw_image = Image.open(image_path).convert('RGB')\n        inputs = self.processor(raw_image, question, return_tensors=\"pt\").to(self.device, self.torch_dtype)\n        out = self.model.generate(**inputs)\n        answer = self.processor.decode(out[0], skip_special_tokens=True)\n        print(f\"\\nProcessed VisualQuestionAnswering, Input Image: {image_path}, Input Question: {question}, \"\n              f\"Output Answer: {answer}\")\n        return answer\n\n\nclass Segmenting:\n    def __init__(self, device):\n        print(f\"Inintializing Segmentation to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.model_checkpoint_path = os.path.join(\"checkpoints\",\"sam\")\n\n        self.download_parameters()\n        self.sam = build_sam(checkpoint=self.model_checkpoint_path).to(device)\n        self.sam_predictor = SamPredictor(self.sam)\n        self.mask_generator = SamAutomaticMaskGenerator(self.sam)\n        \n        self.saved_points = []\n        self.saved_labels = []\n\n    def download_parameters(self):\n        url = \"https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\"\n        if not os.path.exists(self.model_checkpoint_path):\n            wget.download(url,out=self.model_checkpoint_path)\n\n        \n    def show_mask(self, mask: np.ndarray,image: np.ndarray,\n                random_color: bool = False, transparency=1) -> np.ndarray:\n        \n        \"\"\"Visualize a mask on top of an image.\n        Args:\n            mask (np.ndarray): A 2D array of shape (H, W).\n            image (np.ndarray): A 3D array of shape (H, W, 3).\n            random_color (bool): Whether to use a random color for the mask.\n        Outputs:\n            np.ndarray: A 3D array of shape (H, W, 3) with the mask\n            visualized on top of the image.\n            transparenccy: the transparency of the segmentation mask\n        \"\"\"\n        \n        if random_color:\n            color = np.concatenate([np.random.random(3)], axis=0)\n        else:\n            color = np.array([30 / 255, 144 / 255, 255 / 255])\n        h, w = mask.shape[-2:]\n        mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1) * 255\n\n        image = cv2.addWeighted(image, 0.7, mask_image.astype('uint8'), transparency, 0)\n\n\n        return image\n\n    def show_box(self, box, ax, label):\n        x0, y0 = box[0], box[1]\n        w, h = box[2] - box[0], box[3] - box[1]\n        ax.add_patch(plt.Rectangle((x0, y0), w, h, edgecolor='green', facecolor=(0,0,0,0), lw=2)) \n        ax.text(x0, y0, label)\n\n    \n    def get_mask_with_boxes(self, image_pil, image, boxes_filt):\n\n        size = image_pil.size\n        H, W = size[1], size[0]\n        for i in range(boxes_filt.size(0)):\n            boxes_filt[i] = boxes_filt[i] * torch.Tensor([W, H, W, H])\n            boxes_filt[i][:2] -= boxes_filt[i][2:] / 2\n            boxes_filt[i][2:] += boxes_filt[i][:2]\n\n        boxes_filt = boxes_filt.cpu()\n        transformed_boxes = self.sam_predictor.transform.apply_boxes_torch(boxes_filt, image.shape[:2]).to(self.device)\n\n        masks, _, _ = self.sam_predictor.predict_torch(\n            point_coords = None,\n            point_labels = None,\n            boxes = transformed_boxes.to(self.device),\n            multimask_output = False,\n        )\n        return masks\n    \n    def segment_image_with_boxes(self, image_pil, image_path, boxes_filt, pred_phrases):\n\n        image = cv2.imread(image_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        self.sam_predictor.set_image(image)\n\n        masks = self.get_mask_with_boxes(image_pil, image, boxes_filt)\n\n        # draw output image\n\n        for mask in masks:\n            image = self.show_mask(mask[0].cpu().numpy(), image, random_color=True, transparency=0.3)\n\n        updated_image_path = get_new_image_name(image_path, func_name=\"segmentation\")\n        \n        new_image = Image.fromarray(image)\n        new_image.save(updated_image_path)\n\n        return updated_image_path\n\n    def set_image(self, img) -> None:\n        \"\"\"Set the image for the predictor.\"\"\"\n        with torch.cuda.amp.autocast():\n            self.sam_predictor.set_image(img)\n\n    def show_points(self, coords: np.ndarray, labels: np.ndarray,\n                image: np.ndarray) -> np.ndarray:\n        \"\"\"Visualize points on top of an image.\n\n        Args:\n            coords (np.ndarray): A 2D array of shape (N, 2).\n            labels (np.ndarray): A 1D array of shape (N,).\n            image (np.ndarray): A 3D array of shape (H, W, 3).\n        Returns:\n            np.ndarray: A 3D array of shape (H, W, 3) with the points\n            visualized on top of the image.\n        \"\"\"\n        pos_points = coords[labels == 1]\n        neg_points = coords[labels == 0]\n        for p in pos_points:\n            image = cv2.circle(\n                image, p.astype(int), radius=3, color=(0, 255, 0), thickness=-1)\n        for p in neg_points:\n            image = cv2.circle(\n                image, p.astype(int), radius=3, color=(255, 0, 0), thickness=-1)\n        return image\n\n\n    def segment_image_with_click(self, img, is_positive: bool,\n                            evt: gr.SelectData):\n                            \n        self.sam_predictor.set_image(img)\n        self.saved_points.append([evt.index[0], evt.index[1]])\n        self.saved_labels.append(1 if is_positive else 0)\n        input_point = np.array(self.saved_points)\n        input_label = np.array(self.saved_labels)\n        \n        # Predict the mask\n        with torch.cuda.amp.autocast():\n            masks, scores, logits = self.sam_predictor.predict(\n                point_coords=input_point,\n                point_labels=input_label,\n                multimask_output=False,\n            )\n\n        img = self.show_mask(masks[0], img, random_color=False, transparency=0.3)\n\n        img = self.show_points(input_point, input_label, img)\n\n        return img\n\n    def segment_image_with_coordinate(self, img, is_positive: bool,\n                            coordinate: tuple):\n        '''\n            Args:\n                img (numpy.ndarray): the given image, shape: H x W x 3.\n                is_positive: whether the click is positive, if want to add mask use True else False.\n                coordinate: the position of the click\n                          If the position is (x,y), means click at the x-th column and y-th row of the pixel matrix.\n                          So x correspond to W, and y correspond to H.\n            Output:\n                img (PLI.Image.Image): the result image\n                result_mask (numpy.ndarray): the result mask, shape: H x W\n\n            Other parameters:\n                transparency (float): the transparenccy of the mask\n                                      to control he degree of transparency after the mask is superimposed.\n                                      if transparency=1, then the masked part will be completely replaced with other colors.\n        '''\n        self.sam_predictor.set_image(img)\n        self.saved_points.append([coordinate[0], coordinate[1]])\n        self.saved_labels.append(1 if is_positive else 0)\n        input_point = np.array(self.saved_points)\n        input_label = np.array(self.saved_labels)\n\n        # Predict the mask\n        with torch.cuda.amp.autocast():\n            masks, scores, logits = self.sam_predictor.predict(\n                point_coords=input_point,\n                point_labels=input_label,\n                multimask_output=False,\n            )\n\n\n        img = self.show_mask(masks[0], img, random_color=False, transparency=0.3)\n\n        img = self.show_points(input_point, input_label, img)\n\n        img = Image.fromarray(img)\n        \n        result_mask = masks[0]\n\n        return img, result_mask\n\n    @prompts(name=\"Segment the Image\",\n             description=\"useful when you want to segment all the part of the image, but not segment a certain object.\"\n                         \"like: segment all the object in this image, or generate segmentations on this image, \"\n                         \"or segment the image,\"\n                         \"or perform segmentation on this image, \"\n                         \"or segment all the object in this image.\"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference_all(self,image_path):\n        image = cv2.imread(image_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        masks = self.mask_generator.generate(image)\n        plt.figure(figsize=(20,20))\n        plt.imshow(image)\n        if len(masks) == 0:\n            return\n        sorted_anns = sorted(masks, key=(lambda x: x['area']), reverse=True)\n        ax = plt.gca()\n        ax.set_autoscale_on(False)\n        polygons = []\n        color = []\n        for ann in sorted_anns:\n            m = ann['segmentation']\n            img = np.ones((m.shape[0], m.shape[1], 3))\n            color_mask = np.random.random((1, 3)).tolist()[0]\n            for i in range(3):\n                img[:,:,i] = color_mask[i]\n            ax.imshow(np.dstack((img, m)))\n\n        updated_image_path = get_new_image_name(image_path, func_name=\"segment-image\")\n        plt.axis('off')\n        plt.savefig(\n            updated_image_path, \n            bbox_inches=\"tight\", dpi=300, pad_inches=0.0\n        )\n        return updated_image_path\n    \nclass Text2Box:\n    def __init__(self, device):\n        print(f\"Initializing ObjectDetection to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.model_checkpoint_path = os.path.join(\"checkpoints\",\"groundingdino\")\n        self.model_config_path = os.path.join(\"checkpoints\",\"grounding_config.py\")\n        self.download_parameters()\n        self.box_threshold = 0.3\n        self.text_threshold = 0.25\n        self.grounding = (self.load_model()).to(self.device)\n\n    def download_parameters(self):\n        url = \"https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth\"\n        if not os.path.exists(self.model_checkpoint_path):\n            wget.download(url,out=self.model_checkpoint_path)\n        config_url = \"https://raw.githubusercontent.com/IDEA-Research/GroundingDINO/main/groundingdino/config/GroundingDINO_SwinT_OGC.py\"\n        if not os.path.exists(self.model_config_path):\n            wget.download(config_url,out=self.model_config_path)\n    def load_image(self,image_path):\n         # load image\n        image_pil = Image.open(image_path).convert(\"RGB\")  # load image\n\n        transform = T.Compose(\n            [\n                T.RandomResize([512], max_size=1333),\n                T.ToTensor(),\n                T.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n            ]\n        )\n        image, _ = transform(image_pil, None)  # 3, h, w\n        return image_pil, image\n\n    def load_model(self):\n        args = SLConfig.fromfile(self.model_config_path)\n        args.device = self.device\n        model = build_model(args)\n        checkpoint = torch.load(self.model_checkpoint_path, map_location=\"cpu\")\n        load_res = model.load_state_dict(clean_state_dict(checkpoint[\"model\"]), strict=False)\n        print(load_res)\n        _ = model.eval()\n        return model\n\n    def get_grounding_boxes(self, image, caption, with_logits=True):\n        caption = caption.lower()\n        caption = caption.strip()\n        if not caption.endswith(\".\"):\n            caption = caption + \".\"\n        image = image.to(self.device)\n        with torch.no_grad():\n            outputs = self.grounding(image[None], captions=[caption])\n        logits = outputs[\"pred_logits\"].cpu().sigmoid()[0]  # (nq, 256)\n        boxes = outputs[\"pred_boxes\"].cpu()[0]  # (nq, 4)\n        logits.shape[0]\n\n        # filter output\n        logits_filt = logits.clone()\n        boxes_filt = boxes.clone()\n        filt_mask = logits_filt.max(dim=1)[0] > self.box_threshold\n        logits_filt = logits_filt[filt_mask]  # num_filt, 256\n        boxes_filt = boxes_filt[filt_mask]  # num_filt, 4\n        logits_filt.shape[0]\n\n        # get phrase\n        tokenlizer = self.grounding.tokenizer\n        tokenized = tokenlizer(caption)\n        # build pred\n        pred_phrases = []\n        for logit, box in zip(logits_filt, boxes_filt):\n            pred_phrase = get_phrases_from_posmap(logit > self.text_threshold, tokenized, tokenlizer)\n            if with_logits:\n                pred_phrases.append(pred_phrase + f\"({str(logit.max().item())[:4]})\")\n            else:\n                pred_phrases.append(pred_phrase)\n\n        return boxes_filt, pred_phrases\n    \n    def plot_boxes_to_image(self, image_pil, tgt):\n        H, W = tgt[\"size\"]\n        boxes = tgt[\"boxes\"]\n        labels = tgt[\"labels\"]\n        assert len(boxes) == len(labels), \"boxes and labels must have same length\"\n\n        draw = ImageDraw.Draw(image_pil)\n        mask = Image.new(\"L\", image_pil.size, 0)\n        mask_draw = ImageDraw.Draw(mask)\n\n        # draw boxes and masks\n        for box, label in zip(boxes, labels):\n            # from 0..1 to 0..W, 0..H\n            box = box * torch.Tensor([W, H, W, H])\n            # from xywh to xyxy\n            box[:2] -= box[2:] / 2\n            box[2:] += box[:2]\n            # random color\n            color = tuple(np.random.randint(0, 255, size=3).tolist())\n            # draw\n            x0, y0, x1, y1 = box\n            x0, y0, x1, y1 = int(x0), int(y0), int(x1), int(y1)\n\n            draw.rectangle([x0, y0, x1, y1], outline=color, width=6)\n            # draw.text((x0, y0), str(label), fill=color)\n\n            font = ImageFont.load_default()\n            if hasattr(font, \"getbbox\"):\n                bbox = draw.textbbox((x0, y0), str(label), font)\n            else:\n                w, h = draw.textsize(str(label), font)\n                bbox = (x0, y0, w + x0, y0 + h)\n            # bbox = draw.textbbox((x0, y0), str(label))\n            draw.rectangle(bbox, fill=color)\n            draw.text((x0, y0), str(label), fill=\"white\")\n\n            mask_draw.rectangle([x0, y0, x1, y1], fill=255, width=2)\n\n        return image_pil, mask\n    \n    @prompts(name=\"Detect the Give Object\",\n             description=\"useful when you only want to detect or find out given objects in the picture\"  \n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path, the text description of the object to be found\")\n    def inference(self, inputs):\n        image_path, det_prompt = inputs.split(\",\")\n        print(f\"image_path={image_path}, text_prompt={det_prompt}\")\n        image_pil, image = self.load_image(image_path)\n\n        boxes_filt, pred_phrases = self.get_grounding_boxes(image, det_prompt)\n\n        size = image_pil.size\n        pred_dict = {\n        \"boxes\": boxes_filt,\n        \"size\": [size[1], size[0]],  # H,W\n        \"labels\": pred_phrases,}\n\n        image_with_box = self.plot_boxes_to_image(image_pil, pred_dict)[0]\n\n        updated_image_path = get_new_image_name(image_path, func_name=\"detect-something\")\n        updated_image = image_with_box.resize(size)\n        updated_image.save(updated_image_path)\n        print(\n            f\"\\nProcessed ObejectDetecting, Input Image: {image_path}, Object to be Detect {det_prompt}, \"\n            f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Inpainting:\n    def __init__(self, device):\n        self.device = device\n        self.revision = 'fp16' if 'cuda' in self.device else None\n        self.torch_dtype = torch.float16 if 'cuda' in self.device else torch.float32\n\n        self.inpaint = StableDiffusionInpaintPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-inpainting\", revision=self.revision, torch_dtype=self.torch_dtype,safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker')).to(device)\n    def __call__(self, prompt, image, mask_image, height=512, width=512, num_inference_steps=50):\n        update_image = self.inpaint(prompt=prompt, image=image.resize((width, height)),\n                                     mask_image=mask_image.resize((width, height)), height=height, width=width, num_inference_steps=num_inference_steps).images[0]\n        return update_image\n\nclass InfinityOutPainting:\n    template_model = True # Add this line to show this is a template model.\n    def __init__(self, ImageCaptioning, Inpainting, VisualQuestionAnswering):\n        self.llm = OpenAI(temperature=0)\n        self.ImageCaption = ImageCaptioning\n        self.inpaint = Inpainting\n        self.ImageVQA = VisualQuestionAnswering\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                        'fewer digits, cropped, worst quality, low quality'\n\n    def get_BLIP_vqa(self, image, question):\n        inputs = self.ImageVQA.processor(image, question, return_tensors=\"pt\").to(self.ImageVQA.device,\n                                                                                  self.ImageVQA.torch_dtype)\n        out = self.ImageVQA.model.generate(**inputs)\n        answer = self.ImageVQA.processor.decode(out[0], skip_special_tokens=True)\n        print(f\"\\nProcessed VisualQuestionAnswering, Input Question: {question}, Output Answer: {answer}\")\n        return answer\n\n    def get_BLIP_caption(self, image):\n        inputs = self.ImageCaption.processor(image, return_tensors=\"pt\").to(self.ImageCaption.device,\n                                                                                self.ImageCaption.torch_dtype)\n        out = self.ImageCaption.model.generate(**inputs)\n        BLIP_caption = self.ImageCaption.processor.decode(out[0], skip_special_tokens=True)\n        return BLIP_caption\n\n    def check_prompt(self, prompt):\n        check = f\"Here is a paragraph with adjectives. \" \\\n                f\"{prompt} \" \\\n                f\"Please change all plural forms in the adjectives to singular forms. \"\n        return self.llm(check)\n\n    def get_imagine_caption(self, image, imagine):\n        BLIP_caption = self.get_BLIP_caption(image)\n        background_color = self.get_BLIP_vqa(image, 'what is the background color of this image')\n        style = self.get_BLIP_vqa(image, 'what is the style of this image')\n        imagine_prompt = f\"let's pretend you are an excellent painter and now \" \\\n                         f\"there is an incomplete painting with {BLIP_caption} in the center, \" \\\n                         f\"please imagine the complete painting and describe it\" \\\n                         f\"you should consider the background color is {background_color}, the style is {style}\" \\\n                         f\"You should make the painting as vivid and realistic as possible\" \\\n                         f\"You can not use words like painting or picture\" \\\n                         f\"and you should use no more than 50 words to describe it\"\n        caption = self.llm(imagine_prompt) if imagine else BLIP_caption\n        caption = self.check_prompt(caption)\n        print(f'BLIP observation: {BLIP_caption}, ChatGPT imagine to {caption}') if imagine else print(\n            f'Prompt: {caption}')\n        return caption\n\n    def resize_image(self, image, max_size=1000000, multiple=8):\n        aspect_ratio = image.size[0] / image.size[1]\n        new_width = int(math.sqrt(max_size * aspect_ratio))\n        new_height = int(new_width / aspect_ratio)\n        new_width, new_height = new_width - (new_width % multiple), new_height - (new_height % multiple)\n        return image.resize((new_width, new_height))\n\n    def dowhile(self, original_img, tosize, expand_ratio, imagine, usr_prompt):\n        old_img = original_img\n        while (old_img.size != tosize):\n            prompt = self.check_prompt(usr_prompt) if usr_prompt else self.get_imagine_caption(old_img, imagine)\n            crop_w = 15 if old_img.size[0] != tosize[0] else 0\n            crop_h = 15 if old_img.size[1] != tosize[1] else 0\n            old_img = ImageOps.crop(old_img, (crop_w, crop_h, crop_w, crop_h))\n            temp_canvas_size = (expand_ratio * old_img.width if expand_ratio * old_img.width < tosize[0] else tosize[0],\n                                expand_ratio * old_img.height if expand_ratio * old_img.height < tosize[1] else tosize[\n                                    1])\n            temp_canvas, temp_mask = Image.new(\"RGB\", temp_canvas_size, color=\"white\"), Image.new(\"L\", temp_canvas_size,\n                                                                                                  color=\"white\")\n            x, y = (temp_canvas.width - old_img.width) // 2, (temp_canvas.height - old_img.height) // 2\n            temp_canvas.paste(old_img, (x, y))\n            temp_mask.paste(0, (x, y, x + old_img.width, y + old_img.height))\n            resized_temp_canvas, resized_temp_mask = self.resize_image(temp_canvas), self.resize_image(temp_mask)\n            image = self.inpaint(prompt=prompt, image=resized_temp_canvas, mask_image=resized_temp_mask,\n                                              height=resized_temp_canvas.height, width=resized_temp_canvas.width,\n                                              num_inference_steps=50).resize(\n                (temp_canvas.width, temp_canvas.height), Image.ANTIALIAS)\n            image = blend_gt2pt(old_img, image)\n            old_img = image\n        return old_img\n\n    @prompts(name=\"Extend An Image\",\n             description=\"useful when you need to extend an image into a larger image.\"\n                         \"like: extend the image into a resolution of 2048x1024, extend the image into 2048x1024. \"\n                         \"The input to this tool should be a comma separated string of two, representing the image_path and the resolution of widthxheight\")\n    def inference(self, inputs):\n        image_path, resolution = inputs.split(',')\n        width, height = resolution.split('x')\n        tosize = (int(width), int(height))\n        image = Image.open(image_path)\n        image = ImageOps.crop(image, (10, 10, 10, 10))\n        out_painted_image = self.dowhile(image, tosize, 4, True, False)\n        updated_image_path = get_new_image_name(image_path, func_name=\"outpainting\")\n        out_painted_image.save(updated_image_path)\n        print(f\"\\nProcessed InfinityOutPainting, Input Image: {image_path}, Input Resolution: {resolution}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\n\nclass ObjectSegmenting:\n    template_model = True # Add this line to show this is a template model.\n    def __init__(self,  Text2Box:Text2Box, Segmenting:Segmenting):\n        # self.llm = OpenAI(temperature=0)\n        self.grounding = Text2Box\n        self.sam = Segmenting\n\n\n    @prompts(name=\"Segment the given object\",\n            description=\"useful when you only want to segment the certain objects in the picture\"\n                        \"according to the given text\"  \n                        \"like: segment the cat,\"\n                        \"or can you segment an obeject for me\"\n                        \"The input to this tool should be a comma separated string of two, \"\n                        \"representing the image_path, the text description of the object to be found\")\n    def inference(self, inputs):\n        image_path, det_prompt = inputs.split(\",\")\n        print(f\"image_path={image_path}, text_prompt={det_prompt}\")\n        image_pil, image = self.grounding.load_image(image_path)\n\n        boxes_filt, pred_phrases = self.grounding.get_grounding_boxes(image, det_prompt)\n        updated_image_path = self.sam.segment_image_with_boxes(image_pil,image_path,boxes_filt,pred_phrases)\n        print(\n            f\"\\nProcessed ObejectSegmenting, Input Image: {image_path}, Object to be Segment {det_prompt}, \"\n            f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n    def merge_masks(self, masks):\n        '''\n            Args:\n                mask (numpy.ndarray): shape N x 1 x H x W\n            Outputs:\n                new_mask (numpy.ndarray): shape H x W       \n        '''\n        if type(masks) == torch.Tensor:\n            x = masks\n        elif type(masks) == np.ndarray:\n            x = torch.tensor(masks,dtype=int)\n        else:   \n            raise TypeError(\"the type of the input masks must be numpy.ndarray or torch.tensor\")\n        x = x.squeeze(dim=1)\n        value, _ = x.max(dim=0)\n        new_mask = value.cpu().numpy()\n        new_mask.astype(np.uint8)\n        return new_mask\n    \n    def get_mask(self, image_path, text_prompt):\n\n        print(f\"image_path={image_path}, text_prompt={text_prompt}\")\n        # image_pil (PIL.Image.Image) -> size: W x H\n        # image (numpy.ndarray) -> H x W x 3\n        image_pil, image = self.grounding.load_image(image_path)\n\n        boxes_filt, pred_phrases = self.grounding.get_grounding_boxes(image, text_prompt)\n        image = cv2.imread(image_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        self.sam.sam_predictor.set_image(image)\n        \n        # masks (torch.tensor) -> N x 1 x H x W \n        masks = self.sam.get_mask_with_boxes(image_pil, image, boxes_filt)\n\n        # merged_mask -> H x W\n        merged_mask = self.merge_masks(masks)\n        # draw output image\n\n        for mask in masks:\n            image = self.sam.show_mask(mask[0].cpu().numpy(), image, random_color=True, transparency=0.3)\n\n\n        merged_mask_image = Image.fromarray(merged_mask)\n\n        return merged_mask\n\n\nclass ImageEditing:\n    template_model = True\n    def __init__(self, Text2Box:Text2Box, Segmenting:Segmenting, Inpainting:Inpainting):\n        print(f\"Initializing ImageEditing\")\n        self.sam = Segmenting\n        self.grounding = Text2Box\n        self.inpaint = Inpainting\n\n    def pad_edge(self,mask,padding):\n        #mask Tensor [H,W]\n        mask = mask.numpy()\n        true_indices = np.argwhere(mask)\n        mask_array = np.zeros_like(mask, dtype=bool)\n        for idx in true_indices:\n            padded_slice = tuple(slice(max(0, i - padding), i + padding + 1) for i in idx)\n            mask_array[padded_slice] = True\n        new_mask = (mask_array * 255).astype(np.uint8)\n        #new_mask\n        return new_mask\n\n    @prompts(name=\"Remove Something From The Photo\",\n             description=\"useful when you want to remove and object or something from the photo \"\n                         \"from its description or location. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the object need to be removed. \")    \n    def inference_remove(self, inputs):\n        image_path, to_be_removed_txt = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        return self.inference_replace_sam(f\"{image_path},{to_be_removed_txt},background\")\n\n    @prompts(name=\"Replace Something From The Photo\",\n            description=\"useful when you want to replace an object from the object description or \"\n                        \"location with another object from its description. \"\n                        \"The input to this tool should be a comma separated string of three, \"\n                        \"representing the image_path, the object to be replaced, the object to be replaced with \")\n    def inference_replace_sam(self,inputs):\n        image_path, to_be_replaced_txt, replace_with_txt = inputs.split(\",\")\n        \n        print(f\"image_path={image_path}, to_be_replaced_txt={to_be_replaced_txt}\")\n        image_pil, image = self.grounding.load_image(image_path)\n        boxes_filt, pred_phrases = self.grounding.get_grounding_boxes(image, to_be_replaced_txt)\n        image = cv2.imread(image_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        self.sam.sam_predictor.set_image(image)\n        masks = self.sam.get_mask_with_boxes(image_pil, image, boxes_filt)\n        mask = torch.sum(masks, dim=0).unsqueeze(0)\n        mask = torch.where(mask > 0, True, False)\n        mask = mask.squeeze(0).squeeze(0).cpu() #tensor\n\n        mask = self.pad_edge(mask,padding=20) #numpy\n        mask_image = Image.fromarray(mask)\n\n        updated_image = self.inpaint(prompt=replace_with_txt, image=image_pil,\n                                     mask_image=mask_image)\n        updated_image_path = get_new_image_name(image_path, func_name=\"replace-something\")\n        updated_image = updated_image.resize(image_pil.size)\n        updated_image.save(updated_image_path)\n        print(\n            f\"\\nProcessed ImageEditing, Input Image: {image_path}, Replace {to_be_replaced_txt} to {replace_with_txt}, \"\n            f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\nclass BackgroundRemoving:\n    '''\n        using to remove the background of the given picture\n    '''\n    template_model = True\n    def __init__(self,VisualQuestionAnswering:VisualQuestionAnswering, Text2Box:Text2Box, Segmenting:Segmenting):\n        self.vqa = VisualQuestionAnswering\n        self.obj_segmenting = ObjectSegmenting(Text2Box,Segmenting)\n\n    @prompts(name=\"Remove the background\",\n             description=\"useful when you want to extract the object or remove the background,\"\n                         \"the input should be a string image_path\"\n                                )\n    def inference(self, image_path):\n        '''\n            given a image, return the picture only contains the extracted main object\n        '''\n        updated_image_path = None\n\n        mask = self.get_mask(image_path)\n\n        image = Image.open(image_path)\n        mask = Image.fromarray(mask)\n        image.putalpha(mask)\n\n        updated_image_path = get_new_image_name(image_path, func_name=\"detect-something\")\n        image.save(updated_image_path)\n\n        return updated_image_path\n\n    def get_mask(self, image_path):\n        '''\n            Description:\n                given an image path, return the mask of the main object.\n            Args:\n                image_path (string): the file path of the image\n            Outputs:\n                mask (numpy.ndarray): H x W\n        '''\n        vqa_input = f\"{image_path}, what is the main object in the image?\"\n        text_prompt = self.vqa.inference(vqa_input)\n\n        mask = self.obj_segmenting.get_mask(image_path,text_prompt)\n\n        return mask\n\n\nclass ConversationBot:\n    def __init__(self, load_dict):\n        # load_dict = {'VisualQuestionAnswering':'cuda:0', 'ImageCaptioning':'cuda:1',...}\n        print(f\"Initializing VisualChatGPT, load_dict={load_dict}\")\n        if 'ImageCaptioning' not in load_dict:\n            raise ValueError(\"You have to load ImageCaptioning as a basic function for VisualChatGPT\")\n\n        self.models = {}\n        # Load Basic Foundation Models\n        for class_name, device in load_dict.items():\n            self.models[class_name] = globals()[class_name](device=device)\n\n        # Load Template Foundation Models\n        for class_name, module in globals().items():\n            if getattr(module, 'template_model', False):\n                template_required_names = {k for k in inspect.signature(module.__init__).parameters.keys() if k!='self'}\n                loaded_names = set([type(e).__name__ for e in self.models.values()])\n                if template_required_names.issubset(loaded_names):\n                    self.models[class_name] = globals()[class_name](\n                        **{name: self.models[name] for name in template_required_names})\n        \n        print(f\"All the Available Functions: {self.models}\")\n\n        self.tools = []\n        for instance in self.models.values():\n            for e in dir(instance):\n                if e.startswith('inference'):\n                    func = getattr(instance, e)\n                    self.tools.append(Tool(name=func.name, description=func.description, func=func))\n        self.llm = OpenAI(temperature=0)\n        self.memory = ConversationBufferMemory(memory_key=\"chat_history\", output_key='output')\n\n    def init_agent(self, lang):\n        self.memory.clear() #clear previous history\n        if lang=='English':\n            PREFIX, FORMAT_INSTRUCTIONS, SUFFIX = VISUAL_CHATGPT_PREFIX, VISUAL_CHATGPT_FORMAT_INSTRUCTIONS, VISUAL_CHATGPT_SUFFIX\n            place = \"Enter text and press enter, or upload an image\"\n            label_clear = \"Clear\"\n        else:\n            PREFIX, FORMAT_INSTRUCTIONS, SUFFIX = VISUAL_CHATGPT_PREFIX_CN, VISUAL_CHATGPT_FORMAT_INSTRUCTIONS_CN, VISUAL_CHATGPT_SUFFIX_CN\n            place = \"ËæìÂÖ•ÊñáÂ≠óÂπ∂ÂõûËΩ¶ÔºåÊàñËÄÖ‰∏ä‰º†ÂõæÁâá\"\n            label_clear = \"Ê∏ÖÈô§\"\n        self.agent = initialize_agent(\n            self.tools,\n            self.llm,\n            agent=\"conversational-react-description\",\n            verbose=True,\n            memory=self.memory,\n            return_intermediate_steps=True,\n            agent_kwargs={'prefix': PREFIX, 'format_instructions': FORMAT_INSTRUCTIONS,\n                          'suffix': SUFFIX}, )\n        return gr.update(visible = True), gr.update(visible = False), gr.update(placeholder=place), gr.update(value=label_clear)\n\n    def run_text(self, text, state):\n        self.agent.memory.buffer = cut_dialogue_history(self.agent.memory.buffer, keep_last_n_words=500)\n        res = self.agent({\"input\": text.strip()})\n        res['output'] = res['output'].replace(\"\\\\\", \"/\")\n        response = re.sub('(image/[-\\w]*.png)', lambda m: f'![](file={m.group(0)})*{m.group(0)}*', res['output'])\n        state = state + [(text, response)]\n        print(f\"\\nProcessed run_text, Input text: {text}\\nCurrent state: {state}\\n\"\n              f\"Current Memory: {self.agent.memory.buffer}\")\n        return state, state\n\n    def run_image(self, image, state, txt, lang):\n        image_filename = os.path.join('image', f\"{str(uuid.uuid4())[:8]}.png\")\n        print(\"======>Auto Resize Image...\")\n        img = Image.open(image.name)\n        width, height = img.size\n        ratio = min(512 / width, 512 / height)\n        width_new, height_new = (round(width * ratio), round(height * ratio))\n        width_new = int(np.round(width_new / 64.0)) * 64\n        height_new = int(np.round(height_new / 64.0)) * 64\n        img = img.resize((width_new, height_new))\n        img = img.convert('RGB')\n        img.save(image_filename, \"PNG\")\n        print(f\"Resize image form {width}x{height} to {width_new}x{height_new}\")\n        description = self.models['ImageCaptioning'].inference(image_filename)\n        if lang == 'Chinese':\n            Human_prompt = f'\\nHuman: Êèê‰æõ‰∏ÄÂº†Âêç‰∏∫ {image_filename}ÁöÑÂõæÁâá„ÄÇÂÆÉÁöÑÊèèËø∞ÊòØ: {description}„ÄÇ Ëøô‰∫õ‰ø°ÊÅØÂ∏ÆÂä©‰Ω†ÁêÜËß£Ëøô‰∏™ÂõæÂÉèÔºå‰ΩÜÊòØ‰Ω†Â∫îËØ•‰ΩøÁî®Â∑•ÂÖ∑Êù•ÂÆåÊàê‰∏ãÈù¢ÁöÑ‰ªªÂä°ÔºåËÄå‰∏çÊòØÁõ¥Êé•‰ªéÊàëÁöÑÊèèËø∞‰∏≠ÊÉ≥Ë±°„ÄÇ Â¶ÇÊûú‰Ω†ÊòéÁôΩ‰∫Ü, ËØ¥ \\\"Êî∂Âà∞\\\". \\n'\n            AI_prompt = \"Êî∂Âà∞„ÄÇ  \"\n        else:\n            Human_prompt = f'\\nHuman: provide a figure named {image_filename}. The description is: {description}. This information helps you to understand this image, but you should use tools to finish following tasks, rather than directly imagine from my description. If you understand, say \\\"Received\\\". \\n'\n            AI_prompt = \"Received.  \"\n        self.agent.memory.buffer = self.agent.memory.buffer + Human_prompt + 'AI: ' + AI_prompt\n        state = state + [(f\"![](file={image_filename})*{image_filename}*\", AI_prompt)]\n        print(f\"\\nProcessed run_image, Input image: {image_filename}\\nCurrent state: {state}\\n\"\n              f\"Current Memory: {self.agent.memory.buffer}\")\n        return state, state, f'{txt} {image_filename} '\n\n\nif __name__ == '__main__':\n    if not os.path.exists(\"checkpoints\"):\n        os.mkdir(\"checkpoints\")\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--load', type=str, default=\"ImageCaptioning_cuda:0,Text2Image_cuda:0\")\n    args = parser.parse_args()\n    load_dict = {e.split('_')[0].strip(): e.split('_')[1].strip() for e in args.load.split(',')}\n    bot = ConversationBot(load_dict=load_dict)\n    with gr.Blocks(css=\"#chatbot .overflow-y-auto{height:500px}\") as demo:\n        lang = gr.Radio(choices = ['Chinese','English'], value=None, label='Language')\n        chatbot = gr.Chatbot(elem_id=\"chatbot\", label=\"Visual ChatGPT\")\n        state = gr.State([])\n        with gr.Row(visible=False) as input_raws:\n            with gr.Column(scale=0.7):\n                txt = gr.Textbox(show_label=False, placeholder=\"Enter text and press enter, or upload an image\").style(\n                    container=False)\n            with gr.Column(scale=0.15, min_width=0):\n                clear = gr.Button(\"Clear\")\n            with gr.Column(scale=0.15, min_width=0):\n                btn = gr.UploadButton(label=\"üñºÔ∏è\",file_types=[\"image\"])\n\n        lang.change(bot.init_agent, [lang], [input_raws, lang, txt, clear])\n        txt.submit(bot.run_text, [txt, state], [chatbot, state])\n        txt.submit(lambda: \"\", None, txt)\n        btn.upload(bot.run_image, [btn, state, txt, lang], [chatbot, state, txt])\n        clear.click(bot.memory.clear)\n        clear.click(lambda: [], None, chatbot)\n        clear.click(lambda: [], None, state)\n    demo.launch(server_name=\"0.0.0.0\", server_port=7861)\n"
        }
      ]
    }
  ]
}