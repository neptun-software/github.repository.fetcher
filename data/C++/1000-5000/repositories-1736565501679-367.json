{
  "metadata": {
    "timestamp": 1736565501679,
    "page": 367,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "p-ranav/indicators",
      "stars": 3063,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 0.462890625,
          "content": "environment:\n  CONAN_RUN_TESTS: True\n  matrix:\n    - APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      PATH: C:\\\\Python37;C:\\\\Python37\\Scripts;C:\\Users\\appveyor\\AppData\\Roaming\\Python\\Python37\\Scripts;%PATH%\n    # - APPVEYOR_BUILD_WORKER_IMAGE: Ubuntu\n    #   PATH: /home/appveyor/.local/bin:$PATH\n    # - APPVEYOR_BUILD_WORKER_IMAGE: macOS\n\ninstall:\n  - python --version\n  - python -m pip install conan --upgrade --user\n  - conan user\n\nbuild_script:\n  - conan create .\n"
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 3.2041015625,
          "content": "---\nLanguage:        Cpp\n# BasedOnStyle:  LLVM\nAccessModifierOffset: -2\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: Right\nAlignOperands:   true\nAlignTrailingComments: true\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: All\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: false\nBinPackArguments: true\nBinPackParameters: true\nBraceWrapping:   \n  AfterClass:      false\n  AfterControlStatement: false\n  AfterEnum:       false\n  AfterFunction:   false\n  AfterNamespace:  false\n  AfterObjCDeclaration: false\n  AfterStruct:     false\n  AfterUnion:      false\n  AfterExternBlock: false\n  BeforeCatch:     false\n  BeforeElse:      false\n  IndentBraces:    false\n  SplitEmptyFunction: true\n  SplitEmptyRecord: true\n  SplitEmptyNamespace: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Attach\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeColon\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: true\nColumnLimit:     80\nCommentPragmas:  '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: false\nConstructorInitializerIndentWidth: 4\nContinuationIndentWidth: 4\nCpp11BracedListStyle: true\nDerivePointerAlignment: false\nDisableFormat:   false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: true\nForEachMacros:   \n  - foreach\n  - Q_FOREACH\n  - BOOST_FOREACH\nIncludeBlocks:   Preserve\nIncludeCategories: \n  - Regex:           '^\"(llvm|llvm-c|clang|clang-c)/'\n    Priority:        2\n  - Regex:           '^(<|\"(gtest|gmock|isl|json)/)'\n    Priority:        3\n  - Regex:           '.*'\n    Priority:        1\nIncludeIsMainRegex: '(Test)?$'\nIndentCaseLabels: false\nIndentPPDirectives: None\nIndentWidth:     2\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: true\nMacroBlockBegin: ''\nMacroBlockEnd:   ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBlockIndentWidth: 2\nObjCSpaceAfterProperty: false\nObjCSpaceBeforeProtocolList: true\nPenaltyBreakAssignment: 2\nPenaltyBreakBeforeFirstCallParameter: 19\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 60\nPointerAlignment: Right\nRawStringFormats:\n  - Language: TextProto\n    Delimiters:\n      - 'pb'\n      - 'proto'\n    BasedOnStyle: google\nReflowComments:  true\nSortIncludes:    true\nSortUsingDeclarations: true\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeParens: ControlStatements\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles:  false\nSpacesInContainerLiterals: true\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard:        Cpp11\nTabWidth:        8\nUseTab:          Never\n...\n\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 4.3427734375,
          "content": "## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015 cache/options directory\n.vs/\n.vscode/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# DNX\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# TODO: Comment the next line if you want to checkin your web deploy settings\n# but database connection strings (with potential passwords) will be unencrypted\n#*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/packages/*\n# except build/, which is used as an MSBuild target.\n!**/packages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/packages/repositories.config\n# NuGet v3's project.json files produces more ignoreable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\nnode_modules/\norleans.codegen.cs\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush\n.cr/\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# CMake build directory\nbuild\n\n# Cppcheck build directory\nanalysis-cppcheck-build-dir\n\n# Ideas directory\nideas\n\ndesktop.iniimages/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.4287109375,
          "content": "language: generic\n\ndist: bionic\n\nmatrix:\n    include:\n    - env: CXX=g++-9 CC=gcc-9\n      addons:\n        apt:\n          packages:\n            - g++-9\n          sources:\n            - sourceline: 'ppa:ubuntu-toolchain-r/test'\n    - env: CXX=g++-8 CC=gcc-8\n      addons:\n        apt:\n          packages:\n            - g++-8\n    - env: CXX=g++-7 CC=gcc-7\n      addons:\n        apt:\n          packages:\n            - g++-7\n    - env: CXX=g++-6 CC=gcc-6\n      addons:\n        apt:\n          packages:\n            - g++-6\n    - env: CXX=g++-5 CC=gcc-5\n      addons:\n        apt:\n          packages:\n            - g++-5\n\n    - env: CXX=clang++-9 CC=clang-9\n      addons:\n        apt:\n          packages:\n            - clang-9\n            - libc++-9-dev\n            - libc++abi-9-dev\n          sources:\n            - sourceline: 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-9 main'\n              key_url: 'https://apt.llvm.org/llvm-snapshot.gpg.key'\n    - env: CXX=clang++-8 CC=clang-8\n      addons:\n        apt:\n          packages:\n            - clang-8\n            - libc++-8-dev\n            - libc++abi-8-dev\n    - env: CXX=clang++-7 CC=clang-7\n      addons:\n        apt:\n          packages:\n            - clang-7\n            - libc++-7-dev\n            - libc++abi-7-dev\n\n\nscript:\n    - if [[ \"$CXX\" == clang* ]]; then export CXXFLAGS=\"-stdlib=libc++\"; fi\n    - mkdir build && cd build\n    - cmake -DINDICATORS_DEMO=ON -DINDICATORS_SAMPLES=ON ..\n    - make\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 3.728515625,
          "content": "cmake_minimum_required(VERSION 3.8)\n\nif(DEFINED PROJECT_NAME)\n  set(INDICATORS_SUBPROJECT ON)\nendif()\n\nif(CMAKE_VERSION VERSION_GREATER_EQUAL \"3.12\")\n  project(indicators VERSION 2.3.0 LANGUAGES CXX\n    HOMEPAGE_URL \"https://github.com/p-ranav/indicators\"\n    DESCRIPTION \"Activity Indicators for Modern C++\")\nelseif(CMAKE_VERSION VERSION_GREATER_EQUAL \"3.9\")\n  project(indicators VERSION 2.3.0 LANGUAGES CXX\n    DESCRIPTION \"Activity Indicators for Modern C++\")\nelse()\n  project(indicators VERSION 2.3.0 LANGUAGES CXX)\nendif()\n\nif(EXISTS \"${CMAKE_BINARY_DIR}/conanbuildinfo.cmake\")\n    include(\"${CMAKE_BINARY_DIR}/conanbuildinfo.cmake\")\n    conan_basic_setup()\nendif()\n\noption(INDICATORS_BUILD_TESTS \"Build indicators tests + enable CTest\")\noption(INDICATORS_SAMPLES \"Build indicators samples\")\noption(INDICATORS_DEMO \"Build indicators demo\" OFF)\n\ninclude(CMakePackageConfigHelpers)\ninclude(GNUInstallDirs)\n\nfind_package(Threads REQUIRED)\n\nadd_library(indicators INTERFACE)\nadd_library(indicators::indicators ALIAS indicators)\n\ntarget_compile_features(indicators INTERFACE cxx_std_11)\ntarget_include_directories(indicators INTERFACE\n  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n  $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>)\ntarget_link_libraries(indicators INTERFACE Threads::Threads)\n\nif(INDICATORS_DEMO)\n  add_subdirectory(demo)\nendif()\n\nif(INDICATORS_SAMPLES)\n  add_subdirectory(samples)\nendif()\n\nif(NOT INDICATORS_SUBPROJECT)\n  configure_package_config_file(indicatorsConfig.cmake.in\n    ${CMAKE_CURRENT_BINARY_DIR}/indicatorsConfig.cmake\n    INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/indicators)\n  write_basic_package_version_file(indicatorsConfigVersion.cmake\n                                   COMPATIBILITY AnyNewerVersion)\n\n  configure_file(indicators.pc.in indicators.pc @ONLY)\n\n  install(TARGETS indicators EXPORT indicatorsTargets)\n  install(EXPORT indicatorsTargets\n          FILE indicatorsTargets.cmake\n          NAMESPACE indicators::\n          DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/indicators)\n  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/indicatorsConfig.cmake\n                ${CMAKE_CURRENT_BINARY_DIR}/indicatorsConfigVersion.cmake\n          DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/indicators)\n  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/indicators.pc\n          DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n  install(DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/include/indicators\n          DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n          USE_SOURCE_PERMISSIONS\n          PATTERN \"*.hpp\")\n  install(FILES LICENSE LICENSE.termcolor\n          DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/licenses/indicators)\n\n  if(EXISTS \"${PROJECT_SOURCE_DIR}/.gitignore\")\n    # Simple glob to regex conversion (.gitignore => CPACK_SOURCE_IGNORE_FILES)\n    file(READ \".gitignore\" DOT_GITIGNORE)\n    string(REPLACE \";\" \"RANDOMSEQUENCE\" DOT_GITIGNORE \"${DOT_GITIGNORE}\")\n    string(REPLACE \"\\n\" \";\" DOT_GITIGNORE \"${DOT_GITIGNORE}\")\n    string(REPLACE \"RANDOMSEQUENCE\" \"\\\\;\" DOT_GITIGNORE \"${DOT_GITIGNORE}\")\n    foreach(IGNORE_LINE ${DOT_GITIGNORE})\n      if(NOT IGNORE_LINE OR IGNORE_LINE MATCHES \"^#\")\n        continue()\n      endif()\n      string(REPLACE \"\\\\\" \"\\\\\\\\\" IGNORE_LINE \"${IGNORE_LINE}\")\n      string(REPLACE \".\" \"\\\\\\\\.\" IGNORE_LINE \"${IGNORE_LINE}\")\n      string(REPLACE \"*\" \".*\" IGNORE_LINE \"${IGNORE_LINE}\")\n      string(REPLACE \"+\" \"\\\\\\\\+\" IGNORE_LINE \"${IGNORE_LINE}\")\n      list(APPEND CPACK_SOURCE_IGNORE_FILES \"${IGNORE_LINE}\")\n    endforeach()\n  endif()\n\n  # extra ignored files\n  list(APPEND CPACK_SOURCE_IGNORE_FILES\n    .editorconfig\n    .git\n    .gitignore\n    .travis.yml\n    .appveyor.yml\n  )\n  set(CPACK_SOURCE_PACKAGE_FILE_NAME \"${PROJECT_NAME}-${PROJECT_VERSION}\")\n  set(CPACK_GENERATOR \"TGZ;TXZ\")\n  set(CPACK_SOURCE_GENERATOR \"TGZ;TXZ\")\n  include(CPack)\nendif()\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.306640625,
          "content": "# Contributing\nContributions are welcomed. Open a pull-request or an issue.\n\n## Code of conduct\nThis project adheres to the [Open Code of Conduct][code-of-conduct]. By participating, you are expected to honor this code.\n\n[code-of-conduct]: https://github.com/spotify/code-of-conduct/blob/master/code-of-conduct.md\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0380859375,
          "content": "MIT License\n\nCopyright (c) 2019 Pranav\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "LICENSE.termcolor",
          "type": "blob",
          "size": 1.4951171875,
          "content": "Copyright (c) 2013, Ihor Kalnytskyi.\nAll rights reserved.\n\nRedistribution and use in source and binary forms of the software as well\nas documentation, with or without modification, are permitted provided\nthat the following conditions are met:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the following\n  disclaimer in the documentation and/or other materials provided\n  with the distribution.\n\n* The names of the contributors may not be used to endorse or\n  promote products derived from this software without specific\n  prior written permission.\n\nTHIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE COPYRIGHT HOLDERS AND\nCONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT\nNOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER\nOR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE AND DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.939453125,
          "content": "<p align=\"center\">\n  <img height=\"70\" src=\"img/logo.png\"/>  \n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.codacy.com/manual/p-ranav/indicators?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=p-ranav/indicators&amp;utm_campaign=Badge_Grade\">\n    <img src=\"https://api.codacy.com/project/badge/Grade/93401e73f250407cb32445afec4e3e99\" alt=\"codacy\"/>\n  </a>\n  <a href=\"https://github.com/p-ranav/indicators/blob/master/LICENSE\">\n    <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"license\"/>\n  </a>\n  <img src=\"https://img.shields.io/badge/version-2.3-blue.svg?cacheSeconds=2592000\" alt=\"version\"/>\n</p>\n\n\n<p align=\"center\">\n  <img src=\"img/demo.gif\"/> \n</p>\n\n## Highlights\n\n* Thread-safe progress bars and spinners\n* Header-only library. Grab a copy of `include/indicators`. \n* Single-header version in `single_include/indicators`.\n* Source for the above GIF can be found [here](demo/demo.cpp)\n* MIT License\n\n## Table of Contents\n\n*    Supported Indicators\n     *    [Basic Progress Bar](#basic-progress-bar)\n     *    [Indeterminate Progress Bar](#indeterminate-progress-bar)\n     *    [Block Progress Bar](#block-progress-bar)\n     *    [Multi Progress](#multiprogress)\n     *    [Dynamic Progress](#dynamicprogress)\n     *    [Progress Spinner](#progress-spinner)\n*    Additional Samples\n     *    [Decremental Progress](#decremental-progress)\n     *    [Working with Iterables](#working-with-iterables)\n     *    [Unicode Support](#unicode-support)\n*    [Building Samples](#building-samples)\n*    [Generating Single Header](#generating-single-header)\n*    [Contributing](#contributing)\n*    [License](#license)\n\n## Basic Progress bar\n\nTo introduce a progress bar in your application, include `indicators/progress_bar.hpp` and create a `ProgressBar` object. Here's the general structure of a progress bar:\n\n```\n{prefix} {start} {fill} {lead} {remaining} {end} {percentage} [{elapsed}<{remaining}] {postfix}\n         ^^^^^^^^^^^^^ Bar Width ^^^^^^^^^^^^^^^   \n```\n\nThe amount of progress in ProgressBar is maintained as a `size_t` in range `[0, 100]`. When progress reaches 100, the progression is complete. \n\nFrom application-level code, there are two ways in which you can update this progress:\n\n### Update progress using `bar.tick()`\n\nYou can update the progress bar using `bar.tick()` which increments progress by exactly `1%`.\n\n<p align=\"center\">\n  <img src=\"img/progress_bar_tick.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/progress_bar.hpp>\n#include <thread>\n#include <chrono>\n\nint main() {\n  using namespace indicators;\n  ProgressBar bar{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"=\"},\n    option::Lead{\">\"},\n    option::Remainder{\" \"},\n    option::End{\"]\"},\n    option::PostfixText{\"Extracting Archive\"},\n    option::ForegroundColor{Color::green},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n  \n  // Update bar state\n  while (true) {\n    bar.tick();\n    if (bar.is_completed())\n      break;\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n\n  return 0;\n}\n```\n\nThe above code will print a progress bar that goes from 0 to 100% at the rate of 1% every 100 ms.\n\n### Updating progress using `bar.set_progress(value)`\n\nIf you'd rather control progress of the bar in discrete steps, consider using `bar.set_progress(value)`. Example:\n\n\n<p align=\"center\">\n  <img src=\"img/progress_bar_set_progress.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/cursor_control.hpp>\n#include <indicators/progress_bar.hpp>\n#include <thread>\n\nint main() {\n  using namespace indicators;\n\n  // Hide cursor\n  show_console_cursor(false);\n\n  ProgressBar bar{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"‚ñ†\"},\n    option::Lead{\"‚ñ†\"},\n    option::Remainder{\"-\"},\n    option::End{\" ]\"},\n    option::PostfixText{\"Loading dependency 1/4\"},\n    option::ForegroundColor{Color::cyan},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n\n  // Update bar state\n  bar.set_progress(10); // 10% done\n\n  // do some work\n  std::this_thread::sleep_for(std::chrono::milliseconds(800));\n\n  bar.set_option(option::PostfixText{\"Loading dependency 2/4\"});  \n\n  bar.set_progress(30); // 30% done\n\n  // do some more work\n  std::this_thread::sleep_for(std::chrono::milliseconds(700));\n\n  bar.set_option(option::PostfixText{\"Loading dependency 3/4\"});  \n\n  bar.set_progress(65); // 65% done\n\n  // do final bit of work\n  std::this_thread::sleep_for(std::chrono::milliseconds(900));\n\n  bar.set_option(option::PostfixText{\"Loaded dependencies!\"});\n\n  bar.set_progress(100); // all done\n\n  // Show cursor\n  show_console_cursor(true);\n\n  return 0;\n}\n```\n\n### Showing Time Elapsed/Remaining\n\nAll progress bars and spinners in `indicators` support showing time elapsed and time remaining. Inspired by python's [tqdm](https://github.com/tqdm/tqdm) module, the format of this meter is `[{elapsed}<{remaining}]`:\n\n<p align=\"center\">\n  <img src=\"img/time_meter.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/cursor_control.hpp>\n#include <indicators/progress_bar.hpp>\n#include <thread>\n\nint main() {\n  using namespace indicators;\n\n  // Hide cursor\n  show_console_cursor(false);\n\n  indicators::ProgressBar bar{\n    option::BarWidth{50},\n    option::Start{\" [\"},\n    option::Fill{\"‚ñà\"},\n    option::Lead{\"‚ñà\"},\n    option::Remainder{\"-\"},\n    option::End{\"]\"},\n    option::PrefixText{\"Training Gaze Network üëÄ\"},\n    option::ForegroundColor{Color::yellow},\n    option::ShowElapsedTime{true},\n    option::ShowRemainingTime{true},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n\n  // Update bar state\n  while (true) {\n    bar.tick();\n    if (bar.is_completed())\n      break;\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n  }\n\n  // Show cursor\n  show_console_cursor(true);\n\n  return 0;\n}\n```\n\n## Indeterminate Progress Bar\n\nYou might have a use-case for a progress bar where the maximum amount of progress is unknown, e.g., you're downloading from a remote server that isn't advertising the total bytes. \n\nUse an `indicators::IndeterminateProgressBar` for such cases. An `IndeterminateProgressBar` is similar to a regular progress bar except the total amount to progress towards is unknown. Ticking on this progress bar will happily run forever. \n\nWhen you know progress is complete, simply call `bar.mark_as_completed()`. \n\n<p align=\"center\">\n  <img src=\"img/indeterminate_progress_bar.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/indeterminate_progress_bar.hpp>\n#include <indicators/cursor_control.hpp>\n#include <indicators/termcolor.hpp>\n#include <thread>\n\nint main() {\n  indicators::IndeterminateProgressBar bar{\n      indicators::option::BarWidth{40},\n      indicators::option::Start{\"[\"},\n      indicators::option::Fill{\"¬∑\"},\n      indicators::option::Lead{\"<==>\"},\n      indicators::option::End{\"]\"},\n      indicators::option::PostfixText{\"Checking for Updates\"},\n      indicators::option::ForegroundColor{indicators::Color::yellow},\n      indicators::option::FontStyles{\n          std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n  };\n\n  indicators::show_console_cursor(false);\n\n  auto job = [&bar]() {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10000));\n    bar.mark_as_completed();\n    std::cout << termcolor::bold << termcolor::green \n        << \"System is up to date!\\n\" << termcolor::reset;\n  };\n  std::thread job_completion_thread(job);\n\n  // Update bar state\n  while (!bar.is_completed()) {\n    bar.tick();\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n\n  job_completion_thread.join();\n  \n  indicators::show_console_cursor(true);  \n  return 0;\n}\n```\n\n## Block Progress Bar\n\nAre you in need of a smooth block progress bar using [unicode block elements](https://en.wikipedia.org/wiki/Block_Elements)? Use `BlockProgressBar` instead of `ProgressBar`. Thanks to [this blog post](https://mike42.me/blog/2018-06-make-better-cli-progress-bars-with-unicode-block-characters) for making `BlockProgressBar` an easy addition to the library. \n\n<p align=\"center\">\n  <img src=\"img/block_progress_bar.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/block_progress_bar.hpp>\n#include <indicators/cursor_control.hpp>\n#include <thread>\n#include <chrono>\n\nint main() {\n\n  using namespace indicators;\n\n  // Hide cursor\n  show_console_cursor(false);\n\n  BlockProgressBar bar{\n    option::BarWidth{80},\n    option::Start{\"[\"},\n    option::End{\"]\"},\n    option::ForegroundColor{Color::white}  ,\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n  \n  // Update bar state\n  auto progress = 0.0f;\n  while (true) {\n    bar.set_progress(progress);\n    progress += 0.25f;\n    if (bar.is_completed())\n      break;\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n  }\n\n  // Show cursor\n  show_console_cursor(true);\n\n  return 0;\n}\n```\n\n## MultiProgress\n\n`indicators` supports management of multiple progress bars with the `MultiProgress` class template. \n\n`template <typename Indicator, size_t count> class MultiProgress` is a class template that holds references to multiple progress bars and provides a safe interface to update the state of each bar. `MultiProgress` works with both `ProgressBar` and `BlockProgressBar` classes.\n\nUse this class if you know the number of progress bars to manage at compile time.\n\nBelow is an example `MultiProgress` object that manages three `ProgressBar` objects.\n\n<p align=\"center\">\n  <img src=\"img/multi_progress.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/multi_progress.hpp>\n#include <indicators/progress_bar.hpp>\n\nint main() {\n  using namespace indicators;\n  // Configure first progress bar\n  ProgressBar bar1{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"‚ñ†\"},\n    option::Lead{\"‚ñ†\"},\n    option::Remainder{\" \"},\n    option::End{\" ]\"},\n    option::ForegroundColor{Color::yellow},\n    option::ShowElapsedTime{true},\n    option::ShowRemainingTime{true},\n    option::PrefixText{\"Progress Bar #1 \"},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n\n  // Configure second progress bar\n\n  ProgressBar bar2{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"=\"},\n    option::Lead{\">\"},\n    option::Remainder{\" \"},\n    option::End{\" ]\"},\n    option::ForegroundColor{Color::cyan},\n    option::ShowElapsedTime{true},\n    option::ShowRemainingTime{true},\n    option::PrefixText{\"Progress Bar #2 \"},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n  \n  // Configure third progress bar\n  indicators::ProgressBar bar3{\n    option::BarWidth{50},\n    option::Start{\"[\"},\n    option::Fill{\"#\"},\n    option::Lead{\"#\"},\n    option::Remainder{\" \"},\n    option::End{\" ]\"},\n    option::ForegroundColor{Color::red},\n    option::ShowElapsedTime{true},\n    option::ShowRemainingTime{true},\n    option::PrefixText{\"Progress Bar #3 \"},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n\n  // Construct MultiProgress object\n  indicators::MultiProgress<indicators::ProgressBar, 3> bars(bar1, bar2, bar3);\n\n  std::cout << \"Multiple Progress Bars:\\n\";\n\n  auto job1 = [&bars]() {\n    while (true) {\n      bars.tick<0>();\n      if (bars.is_completed<0>())\n        break;\n      std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n  };\n\n  auto job2 = [&bars]() {\n    while (true) {\n      bars.tick<1>();\n      if (bars.is_completed<1>())\n        break;\n      std::this_thread::sleep_for(std::chrono::milliseconds(200));\n    }\n  };\n\n  auto job3 = [&bars]() {\n    while (true) {\n      bars.tick<2>();\n      if (bars.is_completed<2>())\n        break;\n      std::this_thread::sleep_for(std::chrono::milliseconds(60));\n    }\n  };\n\n  std::thread first_job(job1);\n  std::thread second_job(job2);\n  std::thread third_job(job3);\n\n  first_job.join();\n  second_job.join();\n  third_job.join();\n\n  return 0;\n}\n```\n\n## DynamicProgress\n\n`DynamicProgress` is a container class, similar to `MultiProgress`, for managing multiple progress bars. As the name suggests, with `DynamicProgress`, you can dynamically add new progress bars. \n\nTo add new progress bars, call `bars.push_back(new_bar)`. This call will return the index of the appended bar. You can then refer to this bar with the indexing operator, e.g., `bars[4].set_progress(55)`.  \n\nUse this class if you don't know the number of progress bars at compile time.\n\nBelow is an example `DynamicProgress` object that manages six `ProgressBar` objects. Three of these bars are added dynamically.\n\n<p align=\"center\">\n  <img src=\"img/dynamic_progress_bar.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/dynamic_progress.hpp>\n#include <indicators/progress_bar.hpp>\nusing namespace indicators;\n\nint main() {\n\n  auto bar1 = std::make_unique<ProgressBar>(option::BarWidth{50},\n                   option::ForegroundColor{Color::red},\n                   option::ShowElapsedTime{true},\n                   option::ShowRemainingTime{true},\n                   option::PrefixText{\"5c90d4a2d1a8: Downloading \"},\n                   indicators::option::FontStyles{\n                       std::vector<indicators::FontStyle>{indicators::FontStyle::bold}});\n\n  auto bar2 = std::make_unique<ProgressBar>(option::BarWidth{50},\n                   option::ForegroundColor{Color::yellow},\n                   option::ShowElapsedTime{true},\n                   option::ShowRemainingTime{true},\n                   option::PrefixText{\"22337bfd13a9: Downloading \"},\n                   indicators::option::FontStyles{\n                       std::vector<indicators::FontStyle>{indicators::FontStyle::bold}});\n\n  auto bar3 = std::make_unique<ProgressBar>(option::BarWidth{50},\n                   option::ForegroundColor{Color::green},\n                   option::ShowElapsedTime{true},\n                   option::ShowRemainingTime{true},\n                   option::PrefixText{\"10f26c680a34: Downloading \"},\n                   indicators::option::FontStyles{\n                       std::vector<indicators::FontStyle>{indicators::FontStyle::bold}});\n\n  auto bar4 = std::make_unique<ProgressBar>(option::BarWidth{50},\n                   option::ForegroundColor{Color::white},\n                   option::ShowElapsedTime{true},\n                   option::ShowRemainingTime{true},\n                   option::PrefixText{\"6364e0d7a283: Downloading \"},\n                   indicators::option::FontStyles{\n                       std::vector<indicators::FontStyle>{indicators::FontStyle::bold}});\n\n  auto bar5 = std::make_unique<ProgressBar>(option::BarWidth{50},\n                   option::ForegroundColor{Color::blue},\n                   option::ShowElapsedTime{true},\n                   option::ShowRemainingTime{true},\n                   option::PrefixText{\"ff1356ba118b: Downloading \"},\n                   indicators::option::FontStyles{\n                       std::vector<indicators::FontStyle>{indicators::FontStyle::bold}});\n\n  auto bar6 = std::make_unique<ProgressBar>(option::BarWidth{50},\n                   option::ForegroundColor{Color::cyan},\n                   option::ShowElapsedTime{true},\n                   option::ShowRemainingTime{true},\n                   option::PrefixText{\"5a17453338b4: Downloading \"},\n                   indicators::option::FontStyles{\n                       std::vector<indicators::FontStyle>{indicators::FontStyle::bold}});\n\n  std::cout << termcolor::bold << termcolor::white << \"Pulling image foo:bar/baz\\n\";\n\n  // Construct with 3 progress bars. We'll add 3 more at a later point\n  DynamicProgress<ProgressBar> bars(bar1, bar2, bar3);\n\n  // Do not hide bars when completed\n  bars.set_option(option::HideBarWhenComplete{false});\n\n  std::thread fourth_job, fifth_job, sixth_job;\n\n  auto job4 = [&bars](size_t i) {\n    while (true) {\n      bars[i].tick();\n      if (bars[i].is_completed()) {\n        bars[i].set_option(option::PrefixText{\"6364e0d7a283: Pull complete \"});\n        bars[i].mark_as_completed();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    }\n  };\n\n  auto job5 = [&bars](size_t i) {\n    while (true) {\n      bars[i].tick();\n      if (bars[i].is_completed()) {\n        bars[i].set_option(option::PrefixText{\"ff1356ba118b: Pull complete \"});\n        bars[i].mark_as_completed();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n  };\n\n  auto job6 = [&bars](size_t i) {\n    while (true) {\n      bars[i].tick();\n      if (bars[i].is_completed()) {\n        bars[i].set_option(option::PrefixText{\"5a17453338b4: Pull complete \"});\n        bars[i].mark_as_completed();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(40));\n    }\n  };\n\n  auto job1 = [&bars, &bar6, &sixth_job, &job6]() {\n    while (true) {\n      bars[0].tick();\n      if (bars[0].is_completed()) {\n        bars[0].set_option(option::PrefixText{\"5c90d4a2d1a8: Pull complete \"});\n        // bar1 is completed, adding bar6\n        auto i = bars.push_back(std::move(bar6));\n        sixth_job = std::thread(job6, i);\n        sixth_job.join();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(140));\n    }\n  };\n\n  auto job2 = [&bars, &bar5, &fifth_job, &job5]() {\n    while (true) {\n      bars[1].tick();\n      if (bars[1].is_completed()) {\n        bars[1].set_option(option::PrefixText{\"22337bfd13a9: Pull complete \"});\n        // bar2 is completed, adding bar5\n        auto i = bars.push_back(std::move(bar5));\n        fifth_job = std::thread(job5, i);\n        fifth_job.join();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(25));\n    }\n  };\n\n  auto job3 = [&bars, &bar4, &fourth_job, &job4]() {\n    while (true) {\n      bars[2].tick();\n      if (bars[2].is_completed()) {\n        bars[2].set_option(option::PrefixText{\"10f26c680a34: Pull complete \"});\n        // bar3 is completed, adding bar4\n        auto i = bars.push_back(std::move(bar4));\n        fourth_job = std::thread(job4, i);\n        fourth_job.join();\n        break;\n      }\n      std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    }\n  };\n\n  std::thread first_job(job1);\n  std::thread second_job(job2);\n  std::thread third_job(job3);\n\n  third_job.join();\n  second_job.join();\n  first_job.join();\n\n  std::cout << termcolor::bold << termcolor::green << \"‚úî Downloaded image foo/bar:baz\" << std::endl;\n  std::cout << termcolor::reset;\n\n  return 0;\n}\n```\n\nIn the above code, notice the option `bars.set_option(option::HideBarWhenComplete{true});`. Yes, you can hide progress bars as and when they complete by setting this option to `true`. If you do so, the above example will look like this:\n\n<p align=\"center\">\n  <img src=\"img/dynamic_progress_bar_hide_completed.gif\"/>  \n</p>\n\n## Progress Spinner\n\nTo introduce a progress spinner in your application, include `indicators/progress_spinner.hpp` and create a `ProgressSpinner` object. Here's the general structure of a progress spinner:\n\n```\n{prefix} {spinner} {percentage} [{elapsed}<{remaining}] {postfix}\n```\n\nProgressSpinner has a vector of strings: `spinner_states`. At each update, the spinner will pick the next string from this sequence to print to the console. The spinner state can be updated similarly to ProgressBars: Using either `tick()` or `set_progress(value)`. \n\n<p align=\"center\">\n  <img src=\"img/progress_spinner.gif\"/>  \n</p>\n\n```cpp\n#include <indicators/progress_spinner.hpp>\n\nint main() {\n  using namespace indicators;\n  indicators::ProgressSpinner spinner{\n    option::PostfixText{\"Checking credentials\"},\n    option::ForegroundColor{Color::yellow},\n    option::SpinnerStates{std::vector<std::string>{\"‚†à\", \"‚†ê\", \"‚††\", \"‚¢Ä\", \"‚°Ä\", \"‚†Ñ\", \"‚†Ç\", \"‚†Å\"}},\n    option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}\n  };\n \n  // Update spinner state\n  auto job = [&spinner]() {\n    while (true) {\n      if (spinner.is_completed()) {\n        spinner.set_option(option::ForegroundColor{Color::green});\n        spinner.set_option(option::PrefixText{\"‚úî\"});\n        spinner.set_option(option::ShowSpinner{false});\n        spinner.set_option(option::ShowPercentage{false});\n        spinner.set_option(option::PostfixText{\"Authenticated!\"});\n        spinner.mark_as_completed();\t\n        break;\n      } else\n        spinner.tick();\n      std::this_thread::sleep_for(std::chrono::milliseconds(40));\n    }\n  };\n  std::thread thread(job);\n  thread.join();  \n\n  return 0;\n}\n```\n\n## Decremental Progress\n\n`indicators` allows you to easily control the progress direction, i.e., incremental or decremental progress by using  `option::ProgressType`. To program a countdown progress bar, use `option::ProgressType::decremental`\n\n<p align=\"center\">\n  <img src=\"img/progress_bar_countdown.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/progress_bar.hpp>\n#include <thread>\nusing namespace indicators;\n\nint main() {\n\n  ProgressBar bar{option::BarWidth{50},\n                  option::ProgressType{ProgressType::decremental},\n                  option::Start{\"[\"},\n                  option::Fill{\"‚ñ†\"},\n                  option::Lead{\"‚ñ†\"},\n                  option::Remainder{\"-\"},\n                  option::End{\"]\"},\n                  option::PostfixText{\"Reverting System Restore\"},\n                  option::ForegroundColor{Color::yellow},\n                  option::FontStyles{std::vector<FontStyle>{FontStyle::bold}}};\n\n  // Update bar state\n  while (true) {\n    bar.tick();\n    if (bar.is_completed())\n      break;\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n  }\n\n  std::cout << termcolor::bold << termcolor::white\n            << \"Task Failed Successfully\\n\" << termcolor::reset;\n\n  return 0;\n}\n```\n\n## Working with Iterables\n\nIf you'd like to use progress bars to indicate progress while iterating over iterables, e.g., a list of numbers, this\ncan be achieved by using the `option::MaxProgress`:\n\n<p align=\"center\">\n  <img src=\"img/block_progress_bar_iterable.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/block_progress_bar.hpp>\n#include <indicators/cursor_control.hpp>\n#include <thread>\n\nint main() {\n\n  // Hide cursor\n  indicators::show_console_cursor(false);\n\n  // Random list of numbers\n  std::vector<size_t> numbers;\n  for (size_t i = 0; i < 1259438; ++i) {\n      numbers.push_back(i);\n  }\n\n  using namespace indicators;\n  BlockProgressBar bar{\n    option::BarWidth{80},\n    option::ForegroundColor{Color::white},\n    option::FontStyles{\n          std::vector<FontStyle>{FontStyle::bold}},\n    option::MaxProgress{numbers.size()}\n  };\n\n  std::cout << \"Iterating over a list of numbers (size = \"\n            << numbers.size() << \")\\n\";\n\n  std::vector<size_t> result;\n  for (size_t i = 0; i < numbers.size(); ++i) {\n\n    // Perform some computation\n    result.push_back(numbers[i] * numbers[i]);\n\n    // Show iteration as postfix text\n    bar.set_option(option::PostfixText{\n      std::to_string(i) + \"/\" + std::to_string(numbers.size())\n    });\n\n    // update progress bar\n    bar.tick();\n  }\n\n  bar.mark_as_completed();\n\n  // Show cursor\n  indicators::show_console_cursor(true);\n\n  return 0;\n}\n```\n\n## Unicode Support\n\n`indicators` supports multi-byte unicode characters in progress bars. \n\nIf the `option::BarWidth` is set, the library aims to respect this setting. When filling the bar, if the next `Fill` string has a display width that would exceed the bar width, then the library will fill the remainder of the bar with `' '` space characters instead. \n\nSee below an example of some progress bars, each with a bar width of 50, displaying different unicode characters:\n\n<p align=\"center\">\n  <img src=\"img/unicode.gif\"/>  \n</p>\n\n```cpp\n#include <chrono>\n#include <indicators/progress_bar.hpp>\n#include <indicators/indeterminate_progress_bar.hpp>\n#include <indicators/cursor_control.hpp>\n#include <thread>\n\nint main() {\n\n    indicators::show_console_cursor(false);\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    {\n        // Plain old ASCII\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"=\"},\n            indicators::option::Lead{\">\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Plain-old ASCII\"},\n            indicators::option::ForegroundColor{indicators::Color::green},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Unicode\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"È©ö„Åè„Å∞„Åã„Çä\"},\n            indicators::option::Lead{\">\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Japanese\"},\n            indicators::option::ForegroundColor{indicators::Color::yellow},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Russian\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"–ü–æ—Ç—Ä—è—Å–∞—é—â–∏–µ\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Russian\"},\n            indicators::option::ForegroundColor{indicators::Color::red},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Greek\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"Œ¶ŒøŒ≤ŒµœÅœåœÇ\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Greek\"},\n            indicators::option::ForegroundColor{indicators::Color::cyan},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Chinese\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"Â§™Ê£í‰∫Ü\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Chinese\"},\n            indicators::option::ForegroundColor{indicators::Color::green},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }        \n    }\n\n    {\n        // Emojis\n        indicators::ProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"üî•\"},\n            indicators::option::Lead{\"üî•\"},\n            indicators::option::Remainder{\" \"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Emojis\"},\n            indicators::option::ForegroundColor{indicators::Color::white},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        // Update bar state\n        while (true) {\n            bar.tick();\n            if (bar.is_completed())\n            break;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n\n    {\n        // Indeterminate progress bar\n        indicators::IndeterminateProgressBar bar{\n            indicators::option::BarWidth{50},\n            indicators::option::Start{\"[\"},\n            indicators::option::Fill{\"‚úØ\"},\n            indicators::option::Lead{\"ËºâÂÖ•‰∏≠\"},\n            indicators::option::End{\" ]\"},\n            indicators::option::PostfixText{\"Loading Progress Bar\"},\n            indicators::option::ForegroundColor{indicators::Color::yellow},\n            indicators::option::FontStyles{\n                std::vector<indicators::FontStyle>{indicators::FontStyle::bold}}\n        };\n\n        auto job = [&bar]() {\n            std::this_thread::sleep_for(std::chrono::milliseconds(10000));\n            bar.mark_as_completed();\n        };\n        std::thread job_completion_thread(job);\n\n        // Update bar state\n        while (!bar.is_completed()) {\n            bar.tick();\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n\n        job_completion_thread.join();\n    }\n\n    indicators::show_console_cursor(true);\n\n  return 0;\n}\n```\n\n## Building Samples\n\n```bash\ngit clone https://github.com/p-ranav/indicators\ncd indicators\nmkdir build && cd build\ncmake -DINDICATORS_SAMPLES=ON -DINDICATORS_DEMO=ON ..\nmake\n```\n\n### WinLibs + MinGW\n\nFor Windows, if you use WinLibs like I do, the cmake command would look like this:\n\n```console\nfoo@bar:~$ mkdir build && cd build\nfoo@bar:~$ cmake -G \"MinGW Makefiles\" -DCMAKE_CXX_COMPILER=\"C:/WinLibs/mingw64/bin/g++.exe\" -DINDICATORS_SAMPLES=ON -DINDICATORS_DEMO=ON ..\nfoo@bar:~$ make -j4\n```\n\n## Generating Single Header\n\n```bash\npython3 utils/amalgamate/amalgamate.py -c single_include.json -s .\n```\n\n## Contributing\nContributions are welcome, have a look at the [CONTRIBUTING.md](CONTRIBUTING.md) document for more information.\n\n## License\nThe project is available under the [MIT](https://opensource.org/licenses/MIT) license.\n"
        },
        {
          "name": "clang-format.bash",
          "type": "blob",
          "size": 0.1650390625,
          "content": "#!/usr/bin/env bash\nfind ./include ./demo/ ./samples/ ./single_include -type f \\( -iname \\*.cpp -o -iname \\*.hpp \\) | xargs clang-format -style=\"{ColumnLimit : 100}\" -i\n"
        },
        {
          "name": "conanfile.py",
          "type": "blob",
          "size": 2.9130859375,
          "content": "from conans import CMake, ConanFile, tools\nfrom conans.errors import ConanException\nfrom contextlib import contextmanager\nimport os\n\n\nclass IndicatorsConan(ConanFile):\n    name = \"indicators\"\n    description = \"Activity Indicators for Modern C++\"\n    topics = (\"indicators\", \"progress\", \"activity\", \"indicator\", \"header-only\", \"c++11\")\n    homepage = \"https://github.com/p-ranav/indicators\"\n    url = \"https://github.com/p-ranav/indicators\"\n    license = (\"MIT\", \"BSD-3-Clause\")\n    exports_sources = \"demo/**\", \"include/**\", \"samples/**\", \"CMakeLists.txt\", \"LICENSE*\", \\\n                      \"indicators.pc.in\", \"indicatorsConfig.cmake.in\", \"README*\", \"img/**\"\n    exports = \"LICENSE\"\n    no_copy_source = True\n    settings = \"os\", \"arch\", \"compiler\", \"build_type\"\n    generators = \"cmake\"\n\n    def set_version(self):\n        import re\n        m = re.search(r\"project\\(.*VERSION ([0-9a-zA-Z.-]+)[ )]\",\n                      open(os.path.join(self.recipe_folder, \"CMakeLists.txt\")).read())\n        if not m:\n            raise ConanException(\"Could not extract version from CMakeLists.txt\")\n        self.version = m.group(1)\n\n    _cmake = None\n\n    def _configure_cmake(self):\n        if self._cmake:\n            return self._cmake\n        generator = None\n        if self.settings.compiler == \"Visual Studio\":\n            generator = \"NMake Makefiles\"\n        self._cmake = CMake(self, generator=generator)\n        if tools.get_env(\"CONAN_RUN_TESTS\", default=False):\n            self._cmake.definitions[\"INDICATORS_DEMO\"] = True\n            self._cmake.definitions[\"INDICATORS_SAMPLES\"] = True\n        self._cmake.configure()\n        return self._cmake\n\n    @property\n    def _test_programs(self):\n        programs = []\n        import re\n        for subdir in (\"demo\", \"samples\", ):\n            for match in re.finditer(r\"add_executable\\((\\S+)\",\n                                     open(os.path.join(self.source_folder, subdir, \"CMakeLists.txt\")).read()):\n                programs.append(os.path.join(self.build_folder, \"bin\", match.group(1)))\n        return programs\n\n    @contextmanager\n    def _build_context(self):\n        with tools.vcvars(self.settings) if self.settings.compiler == \"Visual Studio\" else tools.no_op():\n            yield\n\n    def build(self):\n        with self._build_context():\n            cmake = self._configure_cmake()\n            cmake.build()\n            cmake.build(target=\"package_source\")\n            # if tools.get_env(\"CONAN_RUN_TESTS\", default=False):\n            #     for program in self._test_programs:\n            #         self.output.info(\"Running program '{}'\".format(program))\n            #         self.run(program, run_environment=True)\n\n    def package(self):\n        with self._build_context():\n            cmake = self._configure_cmake()\n            cmake.install()\n\n    def package_id(self):\n        self.info.header_only()\n\n    def package_info(self):\n        self.cpp_info.includedirs.append(os.path.join(\"include\", \"indicators\"))\n"
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "indicators.pc.in",
          "type": "blob",
          "size": 0.1748046875,
          "content": "includedir=@CMAKE_INSTALL_FULL_INCLUDEDIR@\n\nName: @PROJECT_NAME@\nDescription: @PROJECT_DESCRIPTION@\nURL: @PROJECT_HOMEPAGE_URL@\nVersion: @PROJECT_VERSION@\nCflags: -I${includedir}\n"
        },
        {
          "name": "indicatorsConfig.cmake.in",
          "type": "blob",
          "size": 0.1904296875,
          "content": "@PACKAGE_INIT@\n\ninclude(CMakeFindDependencyMacro)\n\nfind_dependency(Threads REQUIRED)\n\nif (NOT TARGET indicators::indicators)\n  include(${CMAKE_CURRENT_LIST_DIR}/indicatorsTargets.cmake)\nendif ()\n"
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "single_include.json",
          "type": "blob",
          "size": 0.8837890625,
          "content": "{\n    \"project\": \"Activity Indicators for Modern C++\",\n    \"target\": \"single_include/indicators/indicators.hpp\",\n    \"sources\": [\n        \"include/indicators/color.hpp\",\n        \"include/indicators/font_style.hpp\",\n        \"include/indicators/progress_type.hpp\",\n        \"include/indicators/termcolor.hpp\",\n        \"include/indicators/terminal_size.hpp\",\n        \"include/indicators/setting.hpp\",\n        \"include/indicators/cursor_control.hpp\",\n        \"include/indicators/cursor_movement.hpp\",\n        \"include/indicators/details/stream_helper.hpp\",\n        \"include/indicators/progress_bar.hpp\",\n        \"include/indicators/block_progress_bar.hpp\",\n        \"include/indicators/indeterminate_progress_bar.hpp\",\n        \"include/indicators/multi_progress.hpp\",\n        \"include/indicators/dynamic_progress.hpp\",\n        \"include/indicators/progress_spinner.hpp\"\n    ],\n    \"include_paths\": [\"include\"]\n}\n"
        },
        {
          "name": "single_include",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}