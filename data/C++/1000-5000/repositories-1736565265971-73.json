{
  "metadata": {
    "timestamp": 1736565265971,
    "page": 73,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lava/matplotlib-cpp",
      "stars": 4493,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.310546875,
          "content": "# Compiled Object files\n*.slo\n*.lo\n*.o\n*.obj\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Compiled Dynamic libraries\n*.so\n*.dylib\n*.dll\n\n# Fortran module files\n*.mod\n\n# Compiled Static libraries\n*.lai\n*.la\n*.a\n*.lib\n\n# Executables\n*.exe\n*.out\n*.app\n\n# Logfiles\n*.tlog\n*.log\n\n# Build\n/examples/build/*\n\n# vim temp files\n*.sw*\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0908203125,
          "content": "language: minimal\ndist: trusty\nservices:\n  - docker\nscript:\n  - make -C contrib docker_build\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 4.6875,
          "content": "cmake_minimum_required(VERSION 3.8 FATAL_ERROR)\nproject(matplotlib_cpp LANGUAGES CXX)\n\ninclude(GNUInstallDirs)\nset(PACKAGE_NAME matplotlib_cpp)\nset(INSTALL_CONFIGDIR ${CMAKE_INSTALL_LIBDIR}/${PACKAGE_NAME}/cmake)\n\n\n# Library target\nadd_library(matplotlib_cpp INTERFACE)\ntarget_include_directories(matplotlib_cpp\n  INTERFACE\n    $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/examples>\n    $<INSTALL_INTERFACE:include>\n)\ntarget_compile_features(matplotlib_cpp INTERFACE\n  cxx_std_11\n)\n# TODO: Use `Development.Embed` component when requiring cmake >= 3.18\nfind_package(Python3 COMPONENTS Interpreter Development REQUIRED)\ntarget_link_libraries(matplotlib_cpp INTERFACE\n  Python3::Python\n  Python3::Module\n)\nfind_package(Python3 COMPONENTS NumPy)\nif(Python3_NumPy_FOUND)\n  target_link_libraries(matplotlib_cpp INTERFACE\n    Python3::NumPy\n  )\nelse()\n  target_compile_definitions(matplotlib_cpp INTERFACE WITHOUT_NUMPY)\nendif()\ninstall(\n  TARGETS matplotlib_cpp\n  EXPORT install_targets\n)\n\n\n# Examples\nadd_executable(minimal examples/minimal.cpp)\ntarget_link_libraries(minimal PRIVATE matplotlib_cpp)\nset_target_properties(minimal PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(basic examples/basic.cpp)\ntarget_link_libraries(basic PRIVATE matplotlib_cpp)\nset_target_properties(basic PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(modern examples/modern.cpp)\ntarget_link_libraries(modern PRIVATE matplotlib_cpp)\nset_target_properties(modern PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(animation examples/animation.cpp)\ntarget_link_libraries(animation PRIVATE matplotlib_cpp)\nset_target_properties(animation PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(nonblock examples/nonblock.cpp)\ntarget_link_libraries(nonblock PRIVATE matplotlib_cpp)\nset_target_properties(nonblock PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(xkcd examples/xkcd.cpp)\ntarget_link_libraries(xkcd PRIVATE matplotlib_cpp)\nset_target_properties(xkcd PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(bar examples/bar.cpp)\ntarget_link_libraries(bar PRIVATE matplotlib_cpp)\nset_target_properties(bar PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(fill_inbetween examples/fill_inbetween.cpp)\ntarget_link_libraries(fill_inbetween PRIVATE matplotlib_cpp)\nset_target_properties(fill_inbetween PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(fill examples/fill.cpp)\ntarget_link_libraries(fill PRIVATE matplotlib_cpp)\nset_target_properties(fill PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(update examples/update.cpp)\ntarget_link_libraries(update PRIVATE matplotlib_cpp)\nset_target_properties(update PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(subplot2grid examples/subplot2grid.cpp)\ntarget_link_libraries(subplot2grid PRIVATE matplotlib_cpp)\nset_target_properties(subplot2grid PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nadd_executable(lines3d examples/lines3d.cpp)\ntarget_link_libraries(lines3d PRIVATE matplotlib_cpp)\nset_target_properties(lines3d PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\nif(Python3_NumPy_FOUND)\n  add_executable(surface examples/surface.cpp)\n  target_link_libraries(surface PRIVATE matplotlib_cpp)\n  set_target_properties(surface PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\n  add_executable(colorbar examples/colorbar.cpp)\n  target_link_libraries(colorbar PRIVATE matplotlib_cpp)\n  set_target_properties(colorbar PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n  add_executable(contour examples/contour.cpp)\n  target_link_libraries(contour PRIVATE matplotlib_cpp)\n  set_target_properties(contour PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\n\n  add_executable(spy examples/spy.cpp)\n  target_link_libraries(spy PRIVATE matplotlib_cpp)\n  set_target_properties(spy PROPERTIES RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/bin\")\nendif()\n\n\n# Install headers\ninstall(FILES\n  \"${PROJECT_SOURCE_DIR}/matplotlibcpp.h\"\n  DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n\n\n# Install targets file\ninstall(EXPORT install_targets\n  FILE\n    ${PACKAGE_NAME}Targets.cmake\n  NAMESPACE\n    ${PACKAGE_NAME}::\n  DESTINATION\n    ${INSTALL_CONFIGDIR}\n)\n\n\n# Install matplotlib_cppConfig.cmake\ninclude(CMakePackageConfigHelpers)\nconfigure_package_config_file(\n  ${CMAKE_CURRENT_SOURCE_DIR}/cmake/${PACKAGE_NAME}Config.cmake.in\n  ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_NAME}Config.cmake\n  INSTALL_DESTINATION ${INSTALL_CONFIGDIR}\n)\ninstall(FILES\n  ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_NAME}Config.cmake\n  DESTINATION ${INSTALL_CONFIGDIR}\n)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.052734375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Benno Evers\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "LICENSE.matplotlib",
          "type": "blob",
          "size": 2.830078125,
          "content": "This library does not contain any files from the matplotlib project, nor\ndoes it make any changes to it. On the other hand, the code contained herein\nis perfectly useless without a separate installation of matplotlib.\nI don't know enough about US copyright law to decide whether this implies\nthat this library \"uses\" or is \"based on\" matplotlib.\nIn any case, matplotlib comes with the following license:\n\nLicense agreement for matplotlib 1.4.3\n1. This LICENSE AGREEMENT is between the Matplotlib Development Team (“MDT”),\n   and the Individual or Organization (“Licensee”) accessing and otherwise\n   using matplotlib software in source or binary form and its associated documentation.\n\n2. Subject to the terms and conditions of this License Agreement, MDT hereby grants\n   Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze,\n   test, perform and/or display publicly, prepare derivative works, distribute, and\n   otherwise use matplotlib 1.4.3 alone or in any derivative version, provided, however,\n   that MDT’s License Agreement and MDT’s notice of copyright, i.e.,\n   “Copyright (c) 2012-2013 Matplotlib Development Team; All Rights Reserved” are retained\n   in matplotlib 1.4.3 alone or in any derivative version prepared by Licensee.\n\n3. In the event Licensee prepares a derivative work that is based on or incorporates\n   matplotlib 1.4.3 or any part thereof, and wants to make the derivative work available\n   to others as provided herein, then Licensee hereby agrees to include in any such work a\n   brief summary of the changes made to matplotlib 1.4.3.\n\n4. MDT is making matplotlib 1.4.3 available to Licensee on an “AS IS” basis. MDT MAKES NO\n   REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION,\n   MDT MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS\n   FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF MATPLOTLIB 1.4.3 WILL NOT INFRINGE ANY\n   THIRD PARTY RIGHTS.\n\n5. MDT SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF MATPLOTLIB 1.4.3 FOR ANY\n   INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING,\n   DISTRIBUTING, OR OTHERWISE USING MATPLOTLIB 1.4.3, OR ANY DERIVATIVE THEREOF,\n   EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\n\n6. This License Agreement will automatically terminate upon a material breach of\n   its terms and conditions.\n\n7. Nothing in this License Agreement shall be deemed to create any relationship of\n   agency, partnership, or joint venture between MDT and Licensee. This License\n   Agreement does not grant permission to use MDT trademarks or trade name in a\n   trademark sense to endorse or promote products or services of Licensee, or any\n   third party.\n\n8. By copying, installing or otherwise using matplotlib 1.4.3, Licensee agrees to be\n   bound by the terms and conditions of this License Agreement.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.2314453125,
          "content": "matplotlib-cpp\n==============\n\nWelcome to matplotlib-cpp, possibly the simplest C++ plotting library.\nIt is built to resemble the plotting API used by Matlab and matplotlib.\n\n\n\nUsage\n-----\nComplete minimal example:\n```cpp\n#include \"matplotlibcpp.h\"\nnamespace plt = matplotlibcpp;\nint main() {\n    plt::plot({1,3,2,4});\n    plt::show();\n}\n```\n    g++ minimal.cpp -std=c++11 -I/usr/include/python2.7 -lpython2.7\n\n**Result:**\n\n![Minimal example](./examples/minimal.png)\n\nA more comprehensive example:\n```cpp\n#include \"matplotlibcpp.h\"\n#include <cmath>\n\nnamespace plt = matplotlibcpp;\n\nint main()\n{\n    // Prepare data.\n    int n = 5000;\n    std::vector<double> x(n), y(n), z(n), w(n,2);\n    for(int i=0; i<n; ++i) {\n        x.at(i) = i*i;\n        y.at(i) = sin(2*M_PI*i/360.0);\n        z.at(i) = log(i);\n    }\n\n    // Set the size of output image to 1200x780 pixels\n    plt::figure_size(1200, 780);\n    // Plot line from given x and y data. Color is selected automatically.\n    plt::plot(x, y);\n    // Plot a red dashed line from given x and y data.\n    plt::plot(x, w,\"r--\");\n    // Plot a line whose name will show up as \"log(x)\" in the legend.\n    plt::named_plot(\"log(x)\", x, z);\n    // Set x-axis to interval [0,1000000]\n    plt::xlim(0, 1000*1000);\n    // Add graph title\n    plt::title(\"Sample figure\");\n    // Enable legend.\n    plt::legend();\n    // Save the image (file format is determined by the extension)\n    plt::save(\"./basic.png\");\n}\n```\n    g++ basic.cpp -I/usr/include/python2.7 -lpython2.7\n\n**Result:**\n\n![Basic example](./examples/basic.png)\n\nAlternatively, matplotlib-cpp also supports some C++11-powered syntactic sugar:\n```cpp\n#include <cmath>\n#include \"matplotlibcpp.h\"\n\nusing namespace std;\nnamespace plt = matplotlibcpp;\n\nint main()\n{\n    // Prepare data.\n    int n = 5000; // number of data points\n    vector<double> x(n),y(n);\n    for(int i=0; i<n; ++i) {\n        double t = 2*M_PI*i/n;\n        x.at(i) = 16*sin(t)*sin(t)*sin(t);\n        y.at(i) = 13*cos(t) - 5*cos(2*t) - 2*cos(3*t) - cos(4*t);\n    }\n\n    // plot() takes an arbitrary number of (x,y,format)-triples.\n    // x must be iterable (that is, anything providing begin(x) and end(x)),\n    // y must either be callable (providing operator() const) or iterable.\n    plt::plot(x, y, \"r-\", x, [](double d) { return 12.5+abs(sin(d)); }, \"k-\");\n\n\n    // show plots\n    plt::show();\n}\n```\n    g++ modern.cpp -std=c++11 -I/usr/include/python2.7 -lpython\n\n**Result:**\n\n![Modern example](./examples/modern.png)\n\nOr some *funny-looking xkcd-styled* example:\n```cpp\n#include \"matplotlibcpp.h\"\n#include <vector>\n#include <cmath>\n\nnamespace plt = matplotlibcpp;\n\nint main() {\n    std::vector<double> t(1000);\n    std::vector<double> x(t.size());\n\n    for(size_t i = 0; i < t.size(); i++) {\n        t[i] = i / 100.0;\n        x[i] = sin(2.0 * M_PI * 1.0 * t[i]);\n    }\n\n    plt::xkcd();\n    plt::plot(t, x);\n    plt::title(\"AN ORDINARY SIN WAVE\");\n    plt::save(\"xkcd.png\");\n}\n\n```\n    g++ xkcd.cpp -std=c++11 -I/usr/include/python2.7 -lpython2.7\n\n**Result:**\n\n![xkcd example](./examples/xkcd.png)\n\nWhen working with vector fields, you might be interested in quiver plots:\n```cpp\n#include \"../matplotlibcpp.h\"\n\nnamespace plt = matplotlibcpp;\n\nint main()\n{\n    // u and v are respectively the x and y components of the arrows we're plotting\n    std::vector<int> x, y, u, v;\n    for (int i = -5; i <= 5; i++) {\n        for (int j = -5; j <= 5; j++) {\n            x.push_back(i);\n            u.push_back(-i);\n            y.push_back(j);\n            v.push_back(-j);\n        }\n    }\n\n    plt::quiver(x, y, u, v);\n    plt::show();\n}\n```\n    g++ quiver.cpp -std=c++11 -I/usr/include/python2.7 -lpython2.7\n\n**Result:**\n\n![quiver example](./examples/quiver.png)\n\nWhen working with 3d functions, you might be interested in 3d plots:\n```cpp\n#include \"../matplotlibcpp.h\"\n\nnamespace plt = matplotlibcpp;\n\nint main()\n{\n    std::vector<std::vector<double>> x, y, z;\n    for (double i = -5; i <= 5;  i += 0.25) {\n        std::vector<double> x_row, y_row, z_row;\n        for (double j = -5; j <= 5; j += 0.25) {\n            x_row.push_back(i);\n            y_row.push_back(j);\n            z_row.push_back(::std::sin(::std::hypot(i, j)));\n        }\n        x.push_back(x_row);\n        y.push_back(y_row);\n        z.push_back(z_row);\n    }\n\n    plt::plot_surface(x, y, z);\n    plt::show();\n}\n```\n\n**Result:**\n\n![surface example](./examples/surface.png)\n\nInstallation\n------------\n\nmatplotlib-cpp works by wrapping the popular python plotting library matplotlib. (matplotlib.org)\nThis means you have to have a working python installation, including development headers.\nOn Ubuntu:\n\n    sudo apt-get install python-matplotlib python-numpy python2.7-dev\n\nIf, for some reason, you're unable to get a working installation of numpy on your system,\nyou can define the macro `WITHOUT_NUMPY` before including the header file to erase this\ndependency.\n\nThe C++-part of the library consists of the single header file `matplotlibcpp.h` which\ncan be placed anywhere.\n\nSince a python interpreter is opened internally, it is necessary to link\nagainst `libpython` in order to user matplotlib-cpp. Most versions should\nwork, although python likes to randomly break compatibility from time to time\nso some caution is advised when using the bleeding edge.\n\n\n# CMake\n\nThe C++ code is compatible to both python2 and python3. However, the `CMakeLists.txt`\nfile is currently set up to use python3 by default, so if python2 is required this\nhas to be changed manually. (a PR that adds a cmake option for this would be highly\nwelcomed)\n\n**NOTE**: By design (of python), only a single python interpreter can be created per\nprocess. When using this library, *no other* library that is spawning a python\ninterpreter internally can be used.\n\nTo compile the code without using cmake, the compiler invocation should look like\nthis:\n\n    g++ example.cpp -I/usr/include/python2.7 -lpython2.7\n\nThis can also be used for linking against a custom build of python\n\n    g++ example.cpp -I/usr/local/include/fancy-python4 -L/usr/local/lib -lfancy-python4\n\n# Vcpkg\n\nYou can download and install matplotlib-cpp using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n\n    git clone https://github.com/Microsoft/vcpkg.git\n    cd vcpkg\n    ./bootstrap-vcpkg.sh\n    ./vcpkg integrate install\n    vcpkg install matplotlib-cpp\n  \nThe matplotlib-cpp port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n\n# C++11\n\nCurrently, c++11 is required to build matplotlib-cpp. The last working commit that did\nnot have this requirement was `717e98e752260245407c5329846f5d62605eff08`.\n\nNote that support for c++98 was dropped more or less accidentally, so if you have to work\nwith an ancient compiler and still want to enjoy the latest additional features, I'd\nprobably merge a PR that restores support.\n\n\n\nWhy?\n----\nI initially started this library during my diploma thesis. The usual approach of\nwriting data from the c++ algorithm to a file and afterwards parsing and plotting\nit in python using matplotlib proved insufficient: Keeping the algorithm\nand plotting code in sync requires a lot of effort when the C++ code frequently and substantially\nchanges. Additionally, the python yaml parser was not able to cope with files that\nexceed a few hundred megabytes in size.\n\nTherefore, I was looking for a C++ plotting library that was extremely easy to use\nand to add into an existing codebase, preferably header-only. When I found\nnone, I decided to write one myself, which is basically a C++ wrapper around\nmatplotlib. As you can see from the above examples, plotting data and saving it\nto an image file can be done as few as two lines of code.\n\nThe general approach of providing a simple C++ API for utilizing python code\nwas later generalized and extracted into a separate, more powerful\nlibrary in another project of mine, [wrappy](http://www.github.com/lava/wrappy).\n\n\nTodo/Issues/Wishlist\n--------------------\n* This library is not thread safe. Protect all concurrent access with a mutex.\n  Sadly, this is not easy to fix since it is not caused by the library itself but\n  by the python interpreter, which is itself not thread-safe.\n\n* It would be nice to have a more object-oriented design with a Plot class which would allow\n  multiple independent plots per program.\n\n* Right now, only a small subset of matplotlibs functionality is exposed. Stuff like xlabel()/ylabel() etc. should\n  be easy to add.\n\n* If you use Anaconda on Windows, you might need to set PYTHONHOME to Anaconda home directory and QT_QPA_PLATFORM_PLUGIN_PATH to %PYTHONHOME%Library/plugins/platforms. The latter is for especially when you get the error which says 'This application failed to start because it could not find or load the Qt platform plugin \"windows\"\nin \"\".'\n\n* MacOS: `Unable to import matplotlib.pyplot`. Cause: In mac os image rendering back end of matplotlib (what-is-a-backend to render using the API of Cocoa by default). There is Qt4Agg and GTKAgg and as a back-end is not the default. Set the back end of macosx that is differ compare with other windows or linux os.\nSolution is described [here](https://stackoverflow.com/questions/21784641/installation-issue-with-matplotlib-python?noredirect=1&lq=1), additional information can be found there too(see links in answers).\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "matplotlibcpp.h",
          "type": "blob",
          "size": 97.4033203125,
          "content": "#pragma once\n\n// Python headers must be included before any system headers, since\n// they define _POSIX_C_SOURCE\n#include <Python.h>\n\n#include <vector>\n#include <map>\n#include <array>\n#include <numeric>\n#include <algorithm>\n#include <stdexcept>\n#include <iostream>\n#include <cstdint> // <cstdint> requires c++11 support\n#include <functional>\n#include <string> // std::stod\n\n#ifndef WITHOUT_NUMPY\n#  define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION\n#  include <numpy/arrayobject.h>\n\n#  ifdef WITH_OPENCV\n#    include <opencv2/opencv.hpp>\n#  endif // WITH_OPENCV\n\n/*\n * A bunch of constants were removed in OpenCV 4 in favour of enum classes, so\n * define the ones we need here.\n */\n#  if CV_MAJOR_VERSION > 3\n#    define CV_BGR2RGB cv::COLOR_BGR2RGB\n#    define CV_BGRA2RGBA cv::COLOR_BGRA2RGBA\n#  endif\n#endif // WITHOUT_NUMPY\n\n#if PY_MAJOR_VERSION >= 3\n#  define PyString_FromString PyUnicode_FromString\n#  define PyInt_FromLong PyLong_FromLong\n#  define PyString_FromString PyUnicode_FromString\n#endif\n\n\nnamespace matplotlibcpp {\nnamespace detail {\n\nstatic std::string s_backend;\n\nstruct _interpreter {\n    PyObject* s_python_function_arrow;\n    PyObject *s_python_function_show;\n    PyObject *s_python_function_close;\n    PyObject *s_python_function_draw;\n    PyObject *s_python_function_pause;\n    PyObject *s_python_function_save;\n    PyObject *s_python_function_figure;\n    PyObject *s_python_function_fignum_exists;\n    PyObject *s_python_function_plot;\n    PyObject *s_python_function_quiver;\n    PyObject* s_python_function_contour;\n    PyObject *s_python_function_semilogx;\n    PyObject *s_python_function_semilogy;\n    PyObject *s_python_function_loglog;\n    PyObject *s_python_function_fill;\n    PyObject *s_python_function_fill_between;\n    PyObject *s_python_function_hist;\n    PyObject *s_python_function_imshow;\n    PyObject *s_python_function_scatter;\n    PyObject *s_python_function_boxplot;\n    PyObject *s_python_function_subplot;\n    PyObject *s_python_function_subplot2grid;\n    PyObject *s_python_function_legend;\n    PyObject *s_python_function_xlim;\n    PyObject *s_python_function_ion;\n    PyObject *s_python_function_ginput;\n    PyObject *s_python_function_ylim;\n    PyObject *s_python_function_title;\n    PyObject *s_python_function_axis;\n    PyObject *s_python_function_axhline;\n    PyObject *s_python_function_axvline;\n    PyObject *s_python_function_axvspan;\n    PyObject *s_python_function_xlabel;\n    PyObject *s_python_function_ylabel;\n    PyObject *s_python_function_gca;\n    PyObject *s_python_function_xticks;\n    PyObject *s_python_function_yticks;\n    PyObject* s_python_function_margins;\n    PyObject *s_python_function_tick_params;\n    PyObject *s_python_function_grid;\n    PyObject* s_python_function_cla;\n    PyObject *s_python_function_clf;\n    PyObject *s_python_function_errorbar;\n    PyObject *s_python_function_annotate;\n    PyObject *s_python_function_tight_layout;\n    PyObject *s_python_colormap;\n    PyObject *s_python_empty_tuple;\n    PyObject *s_python_function_stem;\n    PyObject *s_python_function_xkcd;\n    PyObject *s_python_function_text;\n    PyObject *s_python_function_suptitle;\n    PyObject *s_python_function_bar;\n    PyObject *s_python_function_barh;\n    PyObject *s_python_function_colorbar;\n    PyObject *s_python_function_subplots_adjust;\n    PyObject *s_python_function_rcparams;\n    PyObject *s_python_function_spy;\n\n    /* For now, _interpreter is implemented as a singleton since its currently not possible to have\n       multiple independent embedded python interpreters without patching the python source code\n       or starting a separate process for each. [1]\n       Furthermore, many python objects expect that they are destructed in the same thread as they\n       were constructed. [2] So for advanced usage, a `kill()` function is provided so that library\n       users can manually ensure that the interpreter is constructed and destroyed within the\n       same thread.\n\n         1: http://bytes.com/topic/python/answers/793370-multiple-independent-python-interpreters-c-c-program\n         2: https://github.com/lava/matplotlib-cpp/pull/202#issue-436220256\n       */\n\n    static _interpreter& get() {\n        return interkeeper(false);\n    }\n\n    static _interpreter& kill() {\n        return interkeeper(true);\n    }\n\n    // Stores the actual singleton object referenced by `get()` and `kill()`.\n    static _interpreter& interkeeper(bool should_kill) {\n        static _interpreter ctx;\n        if (should_kill)\n            ctx.~_interpreter();\n        return ctx;\n    }\n\n    PyObject* safe_import(PyObject* module, std::string fname) {\n        PyObject* fn = PyObject_GetAttrString(module, fname.c_str());\n\n        if (!fn)\n            throw std::runtime_error(std::string(\"Couldn't find required function: \") + fname);\n\n        if (!PyFunction_Check(fn))\n            throw std::runtime_error(fname + std::string(\" is unexpectedly not a PyFunction.\"));\n\n        return fn;\n    }\n\nprivate:\n\n#ifndef WITHOUT_NUMPY\n#  if PY_MAJOR_VERSION >= 3\n\n    void *import_numpy() {\n        import_array(); // initialize C-API\n        return NULL;\n    }\n\n#  else\n\n    void import_numpy() {\n        import_array(); // initialize C-API\n    }\n\n#  endif\n#endif\n\n    _interpreter() {\n\n        // optional but recommended\n#if PY_MAJOR_VERSION >= 3\n        wchar_t name[] = L\"plotting\";\n#else\n        char name[] = \"plotting\";\n#endif\n        Py_SetProgramName(name);\n        Py_Initialize();\n\n        wchar_t const *dummy_args[] = {L\"Python\", NULL};  // const is needed because literals must not be modified\n        wchar_t const **argv = dummy_args;\n        int             argc = sizeof(dummy_args)/sizeof(dummy_args[0])-1;\n\n#if PY_MAJOR_VERSION >= 3\n        PySys_SetArgv(argc, const_cast<wchar_t **>(argv));\n#else\n        PySys_SetArgv(argc, (char **)(argv));\n#endif\n\n#ifndef WITHOUT_NUMPY\n        import_numpy(); // initialize numpy C-API\n#endif\n\n        PyObject* matplotlibname = PyString_FromString(\"matplotlib\");\n        PyObject* pyplotname = PyString_FromString(\"matplotlib.pyplot\");\n        PyObject* cmname  = PyString_FromString(\"matplotlib.cm\");\n        PyObject* pylabname  = PyString_FromString(\"pylab\");\n        if (!pyplotname || !pylabname || !matplotlibname || !cmname) {\n            throw std::runtime_error(\"couldnt create string\");\n        }\n\n        PyObject* matplotlib = PyImport_Import(matplotlibname);\n\n        Py_DECREF(matplotlibname);\n        if (!matplotlib) {\n            PyErr_Print();\n            throw std::runtime_error(\"Error loading module matplotlib!\");\n        }\n\n        // matplotlib.use() must be called *before* pylab, matplotlib.pyplot,\n        // or matplotlib.backends is imported for the first time\n        if (!s_backend.empty()) {\n            PyObject_CallMethod(matplotlib, const_cast<char*>(\"use\"), const_cast<char*>(\"s\"), s_backend.c_str());\n        }\n\n\n\n        PyObject* pymod = PyImport_Import(pyplotname);\n        Py_DECREF(pyplotname);\n        if (!pymod) { throw std::runtime_error(\"Error loading module matplotlib.pyplot!\"); }\n\n        s_python_colormap = PyImport_Import(cmname);\n        Py_DECREF(cmname);\n        if (!s_python_colormap) { throw std::runtime_error(\"Error loading module matplotlib.cm!\"); }\n\n        PyObject* pylabmod = PyImport_Import(pylabname);\n        Py_DECREF(pylabname);\n        if (!pylabmod) { throw std::runtime_error(\"Error loading module pylab!\"); }\n\n        s_python_function_arrow = safe_import(pymod, \"arrow\");\n        s_python_function_show = safe_import(pymod, \"show\");\n        s_python_function_close = safe_import(pymod, \"close\");\n        s_python_function_draw = safe_import(pymod, \"draw\");\n        s_python_function_pause = safe_import(pymod, \"pause\");\n        s_python_function_figure = safe_import(pymod, \"figure\");\n        s_python_function_fignum_exists = safe_import(pymod, \"fignum_exists\");\n        s_python_function_plot = safe_import(pymod, \"plot\");\n        s_python_function_quiver = safe_import(pymod, \"quiver\");\n        s_python_function_contour = safe_import(pymod, \"contour\");\n        s_python_function_semilogx = safe_import(pymod, \"semilogx\");\n        s_python_function_semilogy = safe_import(pymod, \"semilogy\");\n        s_python_function_loglog = safe_import(pymod, \"loglog\");\n        s_python_function_fill = safe_import(pymod, \"fill\");\n        s_python_function_fill_between = safe_import(pymod, \"fill_between\");\n        s_python_function_hist = safe_import(pymod,\"hist\");\n        s_python_function_scatter = safe_import(pymod,\"scatter\");\n        s_python_function_boxplot = safe_import(pymod,\"boxplot\");\n        s_python_function_subplot = safe_import(pymod, \"subplot\");\n        s_python_function_subplot2grid = safe_import(pymod, \"subplot2grid\");\n        s_python_function_legend = safe_import(pymod, \"legend\");\n        s_python_function_xlim = safe_import(pymod, \"xlim\");\n        s_python_function_ylim = safe_import(pymod, \"ylim\");\n        s_python_function_title = safe_import(pymod, \"title\");\n        s_python_function_axis = safe_import(pymod, \"axis\");\n        s_python_function_axhline = safe_import(pymod, \"axhline\");\n        s_python_function_axvline = safe_import(pymod, \"axvline\");\n        s_python_function_axvspan = safe_import(pymod, \"axvspan\");\n        s_python_function_xlabel = safe_import(pymod, \"xlabel\");\n        s_python_function_ylabel = safe_import(pymod, \"ylabel\");\n        s_python_function_gca = safe_import(pymod, \"gca\");\n        s_python_function_xticks = safe_import(pymod, \"xticks\");\n        s_python_function_yticks = safe_import(pymod, \"yticks\");\n        s_python_function_margins = safe_import(pymod, \"margins\");\n        s_python_function_tick_params = safe_import(pymod, \"tick_params\");\n        s_python_function_grid = safe_import(pymod, \"grid\");\n        s_python_function_ion = safe_import(pymod, \"ion\");\n        s_python_function_ginput = safe_import(pymod, \"ginput\");\n        s_python_function_save = safe_import(pylabmod, \"savefig\");\n        s_python_function_annotate = safe_import(pymod,\"annotate\");\n        s_python_function_cla = safe_import(pymod, \"cla\");\n        s_python_function_clf = safe_import(pymod, \"clf\");\n        s_python_function_errorbar = safe_import(pymod, \"errorbar\");\n        s_python_function_tight_layout = safe_import(pymod, \"tight_layout\");\n        s_python_function_stem = safe_import(pymod, \"stem\");\n        s_python_function_xkcd = safe_import(pymod, \"xkcd\");\n        s_python_function_text = safe_import(pymod, \"text\");\n        s_python_function_suptitle = safe_import(pymod, \"suptitle\");\n        s_python_function_bar = safe_import(pymod,\"bar\");\n        s_python_function_barh = safe_import(pymod, \"barh\");\n        s_python_function_colorbar = PyObject_GetAttrString(pymod, \"colorbar\");\n        s_python_function_subplots_adjust = safe_import(pymod,\"subplots_adjust\");\n        s_python_function_rcparams = PyObject_GetAttrString(pymod, \"rcParams\");\n\ts_python_function_spy = PyObject_GetAttrString(pymod, \"spy\");\n#ifndef WITHOUT_NUMPY\n        s_python_function_imshow = safe_import(pymod, \"imshow\");\n#endif\n        s_python_empty_tuple = PyTuple_New(0);\n    }\n\n    ~_interpreter() {\n        Py_Finalize();\n    }\n};\n\n} // end namespace detail\n\n/// Select the backend\n///\n/// **NOTE:** This must be called before the first plot command to have\n/// any effect.\n///\n/// Mainly useful to select the non-interactive 'Agg' backend when running\n/// matplotlibcpp in headless mode, for example on a machine with no display.\n///\n/// See also: https://matplotlib.org/2.0.2/api/matplotlib_configuration_api.html#matplotlib.use\ninline void backend(const std::string& name)\n{\n    detail::s_backend = name;\n}\n\ninline bool annotate(std::string annotation, double x, double y)\n{\n    detail::_interpreter::get();\n\n    PyObject * xy = PyTuple_New(2);\n    PyObject * str = PyString_FromString(annotation.c_str());\n\n    PyTuple_SetItem(xy,0,PyFloat_FromDouble(x));\n    PyTuple_SetItem(xy,1,PyFloat_FromDouble(y));\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"xy\", xy);\n\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, str);\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_annotate, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\nnamespace detail {\n\n#ifndef WITHOUT_NUMPY\n// Type selector for numpy array conversion\ntemplate <typename T> struct select_npy_type { const static NPY_TYPES type = NPY_NOTYPE; }; //Default\ntemplate <> struct select_npy_type<double> { const static NPY_TYPES type = NPY_DOUBLE; };\ntemplate <> struct select_npy_type<float> { const static NPY_TYPES type = NPY_FLOAT; };\ntemplate <> struct select_npy_type<bool> { const static NPY_TYPES type = NPY_BOOL; };\ntemplate <> struct select_npy_type<int8_t> { const static NPY_TYPES type = NPY_INT8; };\ntemplate <> struct select_npy_type<int16_t> { const static NPY_TYPES type = NPY_SHORT; };\ntemplate <> struct select_npy_type<int32_t> { const static NPY_TYPES type = NPY_INT; };\ntemplate <> struct select_npy_type<int64_t> { const static NPY_TYPES type = NPY_INT64; };\ntemplate <> struct select_npy_type<uint8_t> { const static NPY_TYPES type = NPY_UINT8; };\ntemplate <> struct select_npy_type<uint16_t> { const static NPY_TYPES type = NPY_USHORT; };\ntemplate <> struct select_npy_type<uint32_t> { const static NPY_TYPES type = NPY_ULONG; };\ntemplate <> struct select_npy_type<uint64_t> { const static NPY_TYPES type = NPY_UINT64; };\n\n// Sanity checks; comment them out or change the numpy type below if you're compiling on\n// a platform where they don't apply\nstatic_assert(sizeof(long long) == 8);\ntemplate <> struct select_npy_type<long long> { const static NPY_TYPES type = NPY_INT64; };\nstatic_assert(sizeof(unsigned long long) == 8);\ntemplate <> struct select_npy_type<unsigned long long> { const static NPY_TYPES type = NPY_UINT64; };\n\ntemplate<typename Numeric>\nPyObject* get_array(const std::vector<Numeric>& v)\n{\n    npy_intp vsize = v.size();\n    NPY_TYPES type = select_npy_type<Numeric>::type;\n    if (type == NPY_NOTYPE) {\n        size_t memsize = v.size()*sizeof(double);\n        double* dp = static_cast<double*>(::malloc(memsize));\n        for (size_t i=0; i<v.size(); ++i)\n            dp[i] = v[i];\n        PyObject* varray = PyArray_SimpleNewFromData(1, &vsize, NPY_DOUBLE, dp);\n        PyArray_UpdateFlags(reinterpret_cast<PyArrayObject*>(varray), NPY_ARRAY_OWNDATA);\n        return varray;\n    }\n\n    PyObject* varray = PyArray_SimpleNewFromData(1, &vsize, type, (void*)(v.data()));\n    return varray;\n}\n\n\ntemplate<typename Numeric>\nPyObject* get_2darray(const std::vector<::std::vector<Numeric>>& v)\n{\n    if (v.size() < 1) throw std::runtime_error(\"get_2d_array v too small\");\n\n    npy_intp vsize[2] = {static_cast<npy_intp>(v.size()),\n                         static_cast<npy_intp>(v[0].size())};\n\n    PyArrayObject *varray =\n        (PyArrayObject *)PyArray_SimpleNew(2, vsize, NPY_DOUBLE);\n\n    double *vd_begin = static_cast<double *>(PyArray_DATA(varray));\n\n    for (const ::std::vector<Numeric> &v_row : v) {\n      if (v_row.size() != static_cast<size_t>(vsize[1]))\n        throw std::runtime_error(\"Missmatched array size\");\n      std::copy(v_row.begin(), v_row.end(), vd_begin);\n      vd_begin += vsize[1];\n    }\n\n    return reinterpret_cast<PyObject *>(varray);\n}\n\n#else // fallback if we don't have numpy: copy every element of the given vector\n\ntemplate<typename Numeric>\nPyObject* get_array(const std::vector<Numeric>& v)\n{\n    PyObject* list = PyList_New(v.size());\n    for(size_t i = 0; i < v.size(); ++i) {\n        PyList_SetItem(list, i, PyFloat_FromDouble(v.at(i)));\n    }\n    return list;\n}\n\n#endif // WITHOUT_NUMPY\n\n// sometimes, for labels and such, we need string arrays\ninline PyObject * get_array(const std::vector<std::string>& strings)\n{\n  PyObject* list = PyList_New(strings.size());\n  for (std::size_t i = 0; i < strings.size(); ++i) {\n    PyList_SetItem(list, i, PyString_FromString(strings[i].c_str()));\n  }\n  return list;\n}\n\n// not all matplotlib need 2d arrays, some prefer lists of lists\ntemplate<typename Numeric>\nPyObject* get_listlist(const std::vector<std::vector<Numeric>>& ll)\n{\n  PyObject* listlist = PyList_New(ll.size());\n  for (std::size_t i = 0; i < ll.size(); ++i) {\n    PyList_SetItem(listlist, i, get_array(ll[i]));\n  }\n  return listlist;\n}\n\n} // namespace detail\n\n/// Plot a line through the given x and y data points..\n///\n/// See: https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.plot.html\ntemplate<typename Numeric>\nbool plot(const std::vector<Numeric> &x, const std::vector<Numeric> &y, const std::map<std::string, std::string>& keywords)\n{\n    assert(x.size() == y.size());\n\n    detail::_interpreter::get();\n\n    // using numpy arrays\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    // construct positional args\n    PyObject* args = PyTuple_New(2);\n    PyTuple_SetItem(args, 0, xarray);\n    PyTuple_SetItem(args, 1, yarray);\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\n// TODO - it should be possible to make this work by implementing\n// a non-numpy alternative for `detail::get_2darray()`.\n#ifndef WITHOUT_NUMPY\ntemplate <typename Numeric>\nvoid plot_surface(const std::vector<::std::vector<Numeric>> &x,\n                  const std::vector<::std::vector<Numeric>> &y,\n                  const std::vector<::std::vector<Numeric>> &z,\n                  const std::map<std::string, std::string> &keywords =\n                      std::map<std::string, std::string>(),\n                  const long fig_number=0)\n{\n  detail::_interpreter::get();\n\n  // We lazily load the modules here the first time this function is called\n  // because I'm not sure that we can assume \"matplotlib installed\" implies\n  // \"mpl_toolkits installed\" on all platforms, and we don't want to require\n  // it for people who don't need 3d plots.\n  static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;\n  if (!mpl_toolkitsmod) {\n    detail::_interpreter::get();\n\n    PyObject* mpl_toolkits = PyString_FromString(\"mpl_toolkits\");\n    PyObject* axis3d = PyString_FromString(\"mpl_toolkits.mplot3d\");\n    if (!mpl_toolkits || !axis3d) { throw std::runtime_error(\"couldnt create string\"); }\n\n    mpl_toolkitsmod = PyImport_Import(mpl_toolkits);\n    Py_DECREF(mpl_toolkits);\n    if (!mpl_toolkitsmod) { throw std::runtime_error(\"Error loading module mpl_toolkits!\"); }\n\n    axis3dmod = PyImport_Import(axis3d);\n    Py_DECREF(axis3d);\n    if (!axis3dmod) { throw std::runtime_error(\"Error loading module mpl_toolkits.mplot3d!\"); }\n  }\n\n  assert(x.size() == y.size());\n  assert(y.size() == z.size());\n\n  // using numpy arrays\n  PyObject *xarray = detail::get_2darray(x);\n  PyObject *yarray = detail::get_2darray(y);\n  PyObject *zarray = detail::get_2darray(z);\n\n  // construct positional args\n  PyObject *args = PyTuple_New(3);\n  PyTuple_SetItem(args, 0, xarray);\n  PyTuple_SetItem(args, 1, yarray);\n  PyTuple_SetItem(args, 2, zarray);\n\n  // Build up the kw args.\n  PyObject *kwargs = PyDict_New();\n  PyDict_SetItemString(kwargs, \"rstride\", PyInt_FromLong(1));\n  PyDict_SetItemString(kwargs, \"cstride\", PyInt_FromLong(1));\n\n  PyObject *python_colormap_coolwarm = PyObject_GetAttrString(\n      detail::_interpreter::get().s_python_colormap, \"coolwarm\");\n\n  PyDict_SetItemString(kwargs, \"cmap\", python_colormap_coolwarm);\n\n  for (std::map<std::string, std::string>::const_iterator it = keywords.begin();\n       it != keywords.end(); ++it) {\n    if (it->first == \"linewidth\" || it->first == \"alpha\") {\n      PyDict_SetItemString(kwargs, it->first.c_str(),\n        PyFloat_FromDouble(std::stod(it->second)));\n    } else {\n      PyDict_SetItemString(kwargs, it->first.c_str(),\n        PyString_FromString(it->second.c_str()));\n    }\n  }\n\n  PyObject *fig_args = PyTuple_New(1);\n  PyObject* fig = nullptr;\n  PyTuple_SetItem(fig_args, 0, PyLong_FromLong(fig_number));\n  PyObject *fig_exists =\n    PyObject_CallObject(\n    detail::_interpreter::get().s_python_function_fignum_exists, fig_args);\n  if (!PyObject_IsTrue(fig_exists)) {\n    fig = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,\n      detail::_interpreter::get().s_python_empty_tuple);\n  } else {\n    fig = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,\n      fig_args);\n  }\n  Py_DECREF(fig_exists);\n  if (!fig) throw std::runtime_error(\"Call to figure() failed.\");\n\n  PyObject *gca_kwargs = PyDict_New();\n  PyDict_SetItemString(gca_kwargs, \"projection\", PyString_FromString(\"3d\"));\n\n  PyObject *gca = PyObject_GetAttrString(fig, \"gca\");\n  if (!gca) throw std::runtime_error(\"No gca\");\n  Py_INCREF(gca);\n  PyObject *axis = PyObject_Call(\n      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);\n\n  if (!axis) throw std::runtime_error(\"No axis\");\n  Py_INCREF(axis);\n\n  Py_DECREF(gca);\n  Py_DECREF(gca_kwargs);\n\n  PyObject *plot_surface = PyObject_GetAttrString(axis, \"plot_surface\");\n  if (!plot_surface) throw std::runtime_error(\"No surface\");\n  Py_INCREF(plot_surface);\n  PyObject *res = PyObject_Call(plot_surface, args, kwargs);\n  if (!res) throw std::runtime_error(\"failed surface\");\n  Py_DECREF(plot_surface);\n\n  Py_DECREF(axis);\n  Py_DECREF(args);\n  Py_DECREF(kwargs);\n  if (res) Py_DECREF(res);\n}\n\ntemplate <typename Numeric>\nvoid contour(const std::vector<::std::vector<Numeric>> &x,\n             const std::vector<::std::vector<Numeric>> &y,\n             const std::vector<::std::vector<Numeric>> &z,\n             const std::map<std::string, std::string> &keywords = {})\n{\n  detail::_interpreter::get();\n\n  // using numpy arrays\n  PyObject *xarray = detail::get_2darray(x);\n  PyObject *yarray = detail::get_2darray(y);\n  PyObject *zarray = detail::get_2darray(z);\n\n  // construct positional args\n  PyObject *args = PyTuple_New(3);\n  PyTuple_SetItem(args, 0, xarray);\n  PyTuple_SetItem(args, 1, yarray);\n  PyTuple_SetItem(args, 2, zarray);\n\n  // Build up the kw args.\n  PyObject *kwargs = PyDict_New();\n\n  PyObject *python_colormap_coolwarm = PyObject_GetAttrString(\n      detail::_interpreter::get().s_python_colormap, \"coolwarm\");\n\n  PyDict_SetItemString(kwargs, \"cmap\", python_colormap_coolwarm);\n\n  for (std::map<std::string, std::string>::const_iterator it = keywords.begin();\n       it != keywords.end(); ++it) {\n    PyDict_SetItemString(kwargs, it->first.c_str(),\n                         PyString_FromString(it->second.c_str()));\n  }\n\n  PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_contour, args, kwargs);\n  if (!res)\n    throw std::runtime_error(\"failed contour\");\n\n  Py_DECREF(args);\n  Py_DECREF(kwargs);\n  if (res) Py_DECREF(res);\n}\n\ntemplate <typename Numeric>\nvoid spy(const std::vector<::std::vector<Numeric>> &x,\n         const double markersize = -1,  // -1 for default matplotlib size\n         const std::map<std::string, std::string> &keywords = {})\n{\n  detail::_interpreter::get();\n\n  PyObject *xarray = detail::get_2darray(x);\n\n  PyObject *kwargs = PyDict_New();\n  if (markersize != -1) {\n    PyDict_SetItemString(kwargs, \"markersize\", PyFloat_FromDouble(markersize));\n  }\n  for (std::map<std::string, std::string>::const_iterator it = keywords.begin();\n       it != keywords.end(); ++it) {\n    PyDict_SetItemString(kwargs, it->first.c_str(),\n                         PyString_FromString(it->second.c_str()));\n  }\n\n  PyObject *plot_args = PyTuple_New(1);\n  PyTuple_SetItem(plot_args, 0, xarray);\n\n  PyObject *res = PyObject_Call(\n      detail::_interpreter::get().s_python_function_spy, plot_args, kwargs);\n\n  Py_DECREF(plot_args);\n  Py_DECREF(kwargs);\n  if (res) Py_DECREF(res);\n}\n#endif // WITHOUT_NUMPY\n\ntemplate <typename Numeric>\nvoid plot3(const std::vector<Numeric> &x,\n                  const std::vector<Numeric> &y,\n                  const std::vector<Numeric> &z,\n                  const std::map<std::string, std::string> &keywords =\n                      std::map<std::string, std::string>(),\n                  const long fig_number=0)\n{\n  detail::_interpreter::get();\n\n  // Same as with plot_surface: We lazily load the modules here the first time\n  // this function is called because I'm not sure that we can assume \"matplotlib\n  // installed\" implies \"mpl_toolkits installed\" on all platforms, and we don't\n  // want to require it for people who don't need 3d plots.\n  static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;\n  if (!mpl_toolkitsmod) {\n    detail::_interpreter::get();\n\n    PyObject* mpl_toolkits = PyString_FromString(\"mpl_toolkits\");\n    PyObject* axis3d = PyString_FromString(\"mpl_toolkits.mplot3d\");\n    if (!mpl_toolkits || !axis3d) { throw std::runtime_error(\"couldnt create string\"); }\n\n    mpl_toolkitsmod = PyImport_Import(mpl_toolkits);\n    Py_DECREF(mpl_toolkits);\n    if (!mpl_toolkitsmod) { throw std::runtime_error(\"Error loading module mpl_toolkits!\"); }\n\n    axis3dmod = PyImport_Import(axis3d);\n    Py_DECREF(axis3d);\n    if (!axis3dmod) { throw std::runtime_error(\"Error loading module mpl_toolkits.mplot3d!\"); }\n  }\n\n  assert(x.size() == y.size());\n  assert(y.size() == z.size());\n\n  PyObject *xarray = detail::get_array(x);\n  PyObject *yarray = detail::get_array(y);\n  PyObject *zarray = detail::get_array(z);\n\n  // construct positional args\n  PyObject *args = PyTuple_New(3);\n  PyTuple_SetItem(args, 0, xarray);\n  PyTuple_SetItem(args, 1, yarray);\n  PyTuple_SetItem(args, 2, zarray);\n\n  // Build up the kw args.\n  PyObject *kwargs = PyDict_New();\n\n  for (std::map<std::string, std::string>::const_iterator it = keywords.begin();\n       it != keywords.end(); ++it) {\n    PyDict_SetItemString(kwargs, it->first.c_str(),\n                         PyString_FromString(it->second.c_str()));\n  }\n\n  PyObject *fig_args = PyTuple_New(1);\n  PyObject* fig = nullptr;\n  PyTuple_SetItem(fig_args, 0, PyLong_FromLong(fig_number));\n  PyObject *fig_exists =\n    PyObject_CallObject(detail::_interpreter::get().s_python_function_fignum_exists, fig_args);\n  if (!PyObject_IsTrue(fig_exists)) {\n    fig = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,\n      detail::_interpreter::get().s_python_empty_tuple);\n  } else {\n    fig = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,\n      fig_args);\n  }\n  if (!fig) throw std::runtime_error(\"Call to figure() failed.\");\n\n  PyObject *gca_kwargs = PyDict_New();\n  PyDict_SetItemString(gca_kwargs, \"projection\", PyString_FromString(\"3d\"));\n\n  PyObject *gca = PyObject_GetAttrString(fig, \"gca\");\n  if (!gca) throw std::runtime_error(\"No gca\");\n  Py_INCREF(gca);\n  PyObject *axis = PyObject_Call(\n      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);\n\n  if (!axis) throw std::runtime_error(\"No axis\");\n  Py_INCREF(axis);\n\n  Py_DECREF(gca);\n  Py_DECREF(gca_kwargs);\n\n  PyObject *plot3 = PyObject_GetAttrString(axis, \"plot\");\n  if (!plot3) throw std::runtime_error(\"No 3D line plot\");\n  Py_INCREF(plot3);\n  PyObject *res = PyObject_Call(plot3, args, kwargs);\n  if (!res) throw std::runtime_error(\"Failed 3D line plot\");\n  Py_DECREF(plot3);\n\n  Py_DECREF(axis);\n  Py_DECREF(args);\n  Py_DECREF(kwargs);\n  if (res) Py_DECREF(res);\n}\n\ntemplate<typename Numeric>\nbool stem(const std::vector<Numeric> &x, const std::vector<Numeric> &y, const std::map<std::string, std::string>& keywords)\n{\n    assert(x.size() == y.size());\n\n    detail::_interpreter::get();\n\n    // using numpy arrays\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    // construct positional args\n    PyObject* args = PyTuple_New(2);\n    PyTuple_SetItem(args, 0, xarray);\n    PyTuple_SetItem(args, 1, yarray);\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for (std::map<std::string, std::string>::const_iterator it =\n            keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(),\n                PyString_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(\n            detail::_interpreter::get().s_python_function_stem, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    if (res)\n        Py_DECREF(res);\n\n    return res;\n}\n\ntemplate< typename Numeric >\nbool fill(const std::vector<Numeric>& x, const std::vector<Numeric>& y, const std::map<std::string, std::string>& keywords)\n{\n    assert(x.size() == y.size());\n\n    detail::_interpreter::get();\n\n    // using numpy arrays\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    // construct positional args\n    PyObject* args = PyTuple_New(2);\n    PyTuple_SetItem(args, 0, xarray);\n    PyTuple_SetItem(args, 1, yarray);\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for (auto it = keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_fill, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n\n    if (res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate< typename Numeric >\nbool fill_between(const std::vector<Numeric>& x, const std::vector<Numeric>& y1, const std::vector<Numeric>& y2, const std::map<std::string, std::string>& keywords)\n{\n    assert(x.size() == y1.size());\n    assert(x.size() == y2.size());\n\n    detail::_interpreter::get();\n\n    // using numpy arrays\n    PyObject* xarray = detail::get_array(x);\n    PyObject* y1array = detail::get_array(y1);\n    PyObject* y2array = detail::get_array(y2);\n\n    // construct positional args\n    PyObject* args = PyTuple_New(3);\n    PyTuple_SetItem(args, 0, xarray);\n    PyTuple_SetItem(args, 1, y1array);\n    PyTuple_SetItem(args, 2, y2array);\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_fill_between, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate <typename Numeric>\nbool arrow(Numeric x, Numeric y, Numeric end_x, Numeric end_y, const std::string& fc = \"r\",\n           const std::string ec = \"k\", Numeric head_length = 0.25, Numeric head_width = 0.1625) {\n    PyObject* obj_x = PyFloat_FromDouble(x);\n    PyObject* obj_y = PyFloat_FromDouble(y);\n    PyObject* obj_end_x = PyFloat_FromDouble(end_x);\n    PyObject* obj_end_y = PyFloat_FromDouble(end_y);\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"fc\", PyString_FromString(fc.c_str()));\n    PyDict_SetItemString(kwargs, \"ec\", PyString_FromString(ec.c_str()));\n    PyDict_SetItemString(kwargs, \"head_width\", PyFloat_FromDouble(head_width));\n    PyDict_SetItemString(kwargs, \"head_length\", PyFloat_FromDouble(head_length));\n\n    PyObject* plot_args = PyTuple_New(4);\n    PyTuple_SetItem(plot_args, 0, obj_x);\n    PyTuple_SetItem(plot_args, 1, obj_y);\n    PyTuple_SetItem(plot_args, 2, obj_end_x);\n    PyTuple_SetItem(plot_args, 3, obj_end_y);\n\n    PyObject* res =\n            PyObject_Call(detail::_interpreter::get().s_python_function_arrow, plot_args, kwargs);\n\n    Py_DECREF(plot_args);\n    Py_DECREF(kwargs);\n    if (res)\n        Py_DECREF(res);\n\n    return res;\n}\n\ntemplate< typename Numeric>\nbool hist(const std::vector<Numeric>& y, long bins=10,std::string color=\"b\",\n          double alpha=1.0, bool cumulative=false)\n{\n    detail::_interpreter::get();\n\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"bins\", PyLong_FromLong(bins));\n    PyDict_SetItemString(kwargs, \"color\", PyString_FromString(color.c_str()));\n    PyDict_SetItemString(kwargs, \"alpha\", PyFloat_FromDouble(alpha));\n    PyDict_SetItemString(kwargs, \"cumulative\", cumulative ? Py_True : Py_False);\n\n    PyObject* plot_args = PyTuple_New(1);\n\n    PyTuple_SetItem(plot_args, 0, yarray);\n\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);\n\n\n    Py_DECREF(plot_args);\n    Py_DECREF(kwargs);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\n#ifndef WITHOUT_NUMPY\nnamespace detail {\n\ninline void imshow(void *ptr, const NPY_TYPES type, const int rows, const int columns, const int colors, const std::map<std::string, std::string> &keywords, PyObject** out)\n{\n    assert(type == NPY_UINT8 || type == NPY_FLOAT);\n    assert(colors == 1 || colors == 3 || colors == 4);\n\n    detail::_interpreter::get();\n\n    // construct args\n    npy_intp dims[3] = { rows, columns, colors };\n    PyObject *args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, PyArray_SimpleNewFromData(colors == 1 ? 2 : 3, dims, type, ptr));\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_imshow, args, kwargs);\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    if (!res)\n        throw std::runtime_error(\"Call to imshow() failed\");\n    if (out)\n        *out = res;\n    else\n        Py_DECREF(res);\n}\n\n} // namespace detail\n\ninline void imshow(const unsigned char *ptr, const int rows, const int columns, const int colors, const std::map<std::string, std::string> &keywords = {}, PyObject** out = nullptr)\n{\n    detail::imshow((void *) ptr, NPY_UINT8, rows, columns, colors, keywords, out);\n}\n\ninline void imshow(const float *ptr, const int rows, const int columns, const int colors, const std::map<std::string, std::string> &keywords = {}, PyObject** out = nullptr)\n{\n    detail::imshow((void *) ptr, NPY_FLOAT, rows, columns, colors, keywords, out);\n}\n\n#ifdef WITH_OPENCV\nvoid imshow(const cv::Mat &image, const std::map<std::string, std::string> &keywords = {})\n{\n    // Convert underlying type of matrix, if needed\n    cv::Mat image2;\n    NPY_TYPES npy_type = NPY_UINT8;\n    switch (image.type() & CV_MAT_DEPTH_MASK) {\n    case CV_8U:\n        image2 = image;\n        break;\n    case CV_32F:\n        image2 = image;\n        npy_type = NPY_FLOAT;\n        break;\n    default:\n        image.convertTo(image2, CV_MAKETYPE(CV_8U, image.channels()));\n    }\n\n    // If color image, convert from BGR to RGB\n    switch (image2.channels()) {\n    case 3:\n        cv::cvtColor(image2, image2, CV_BGR2RGB);\n        break;\n    case 4:\n        cv::cvtColor(image2, image2, CV_BGRA2RGBA);\n    }\n\n    detail::imshow(image2.data, npy_type, image2.rows, image2.cols, image2.channels(), keywords);\n}\n#endif // WITH_OPENCV\n#endif // WITHOUT_NUMPY\n\ntemplate<typename NumericX, typename NumericY>\nbool scatter(const std::vector<NumericX>& x,\n             const std::vector<NumericY>& y,\n             const double s=1.0, // The marker size in points**2\n             const std::map<std::string, std::string> & keywords = {})\n{\n    detail::_interpreter::get();\n\n    assert(x.size() == y.size());\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"s\", PyLong_FromLong(s));\n    for (const auto& it : keywords)\n    {\n        PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));\n    }\n\n    PyObject* plot_args = PyTuple_New(2);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_scatter, plot_args, kwargs);\n\n    Py_DECREF(plot_args);\n    Py_DECREF(kwargs);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY, typename NumericColors>\n    bool scatter_colored(const std::vector<NumericX>& x,\n                 const std::vector<NumericY>& y,\n                 const std::vector<NumericColors>& colors,\n                 const double s=1.0, // The marker size in points**2\n                 const std::map<std::string, std::string> & keywords = {})\n    {\n        detail::_interpreter::get();\n\n        assert(x.size() == y.size());\n\n        PyObject* xarray = detail::get_array(x);\n        PyObject* yarray = detail::get_array(y);\n        PyObject* colors_array = detail::get_array(colors);\n\n        PyObject* kwargs = PyDict_New();\n        PyDict_SetItemString(kwargs, \"s\", PyLong_FromLong(s));\n        PyDict_SetItemString(kwargs, \"c\", colors_array);\n\n        for (const auto& it : keywords)\n        {\n            PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));\n        }\n\n        PyObject* plot_args = PyTuple_New(2);\n        PyTuple_SetItem(plot_args, 0, xarray);\n        PyTuple_SetItem(plot_args, 1, yarray);\n\n        PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_scatter, plot_args, kwargs);\n\n        Py_DECREF(plot_args);\n        Py_DECREF(kwargs);\n        if(res) Py_DECREF(res);\n\n        return res;\n    }\n    \n\ntemplate<typename NumericX, typename NumericY, typename NumericZ>\nbool scatter(const std::vector<NumericX>& x,\n             const std::vector<NumericY>& y,\n             const std::vector<NumericZ>& z,\n             const double s=1.0, // The marker size in points**2\n             const std::map<std::string, std::string> & keywords = {},\n             const long fig_number=0) {\n  detail::_interpreter::get();\n\n  // Same as with plot_surface: We lazily load the modules here the first time \n  // this function is called because I'm not sure that we can assume \"matplotlib \n  // installed\" implies \"mpl_toolkits installed\" on all platforms, and we don't \n  // want to require it for people who don't need 3d plots.\n  static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;\n  if (!mpl_toolkitsmod) {\n    detail::_interpreter::get();\n\n    PyObject* mpl_toolkits = PyString_FromString(\"mpl_toolkits\");\n    PyObject* axis3d = PyString_FromString(\"mpl_toolkits.mplot3d\");\n    if (!mpl_toolkits || !axis3d) { throw std::runtime_error(\"couldnt create string\"); }\n\n    mpl_toolkitsmod = PyImport_Import(mpl_toolkits);\n    Py_DECREF(mpl_toolkits);\n    if (!mpl_toolkitsmod) { throw std::runtime_error(\"Error loading module mpl_toolkits!\"); }\n\n    axis3dmod = PyImport_Import(axis3d);\n    Py_DECREF(axis3d);\n    if (!axis3dmod) { throw std::runtime_error(\"Error loading module mpl_toolkits.mplot3d!\"); }\n  }\n\n  assert(x.size() == y.size());\n  assert(y.size() == z.size());\n\n  PyObject *xarray = detail::get_array(x);\n  PyObject *yarray = detail::get_array(y);\n  PyObject *zarray = detail::get_array(z);\n\n  // construct positional args\n  PyObject *args = PyTuple_New(3);\n  PyTuple_SetItem(args, 0, xarray);\n  PyTuple_SetItem(args, 1, yarray);\n  PyTuple_SetItem(args, 2, zarray);\n\n  // Build up the kw args.\n  PyObject *kwargs = PyDict_New();\n\n  for (std::map<std::string, std::string>::const_iterator it = keywords.begin();\n       it != keywords.end(); ++it) {\n    PyDict_SetItemString(kwargs, it->first.c_str(),\n                         PyString_FromString(it->second.c_str()));\n  }\n  PyObject *fig_args = PyTuple_New(1);\n  PyObject* fig = nullptr;\n  PyTuple_SetItem(fig_args, 0, PyLong_FromLong(fig_number));\n  PyObject *fig_exists =\n    PyObject_CallObject(detail::_interpreter::get().s_python_function_fignum_exists, fig_args);\n  if (!PyObject_IsTrue(fig_exists)) {\n    fig = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,\n      detail::_interpreter::get().s_python_empty_tuple);\n  } else {\n    fig = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,\n      fig_args);\n  }\n  Py_DECREF(fig_exists);\n  if (!fig) throw std::runtime_error(\"Call to figure() failed.\");\n\n  PyObject *gca_kwargs = PyDict_New();\n  PyDict_SetItemString(gca_kwargs, \"projection\", PyString_FromString(\"3d\"));\n\n  PyObject *gca = PyObject_GetAttrString(fig, \"gca\");\n  if (!gca) throw std::runtime_error(\"No gca\");\n  Py_INCREF(gca);\n  PyObject *axis = PyObject_Call(\n      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);\n\n  if (!axis) throw std::runtime_error(\"No axis\");\n  Py_INCREF(axis);\n\n  Py_DECREF(gca);\n  Py_DECREF(gca_kwargs);\n\n  PyObject *plot3 = PyObject_GetAttrString(axis, \"scatter\");\n  if (!plot3) throw std::runtime_error(\"No 3D line plot\");\n  Py_INCREF(plot3);\n  PyObject *res = PyObject_Call(plot3, args, kwargs);\n  if (!res) throw std::runtime_error(\"Failed 3D line plot\");\n  Py_DECREF(plot3);\n\n  Py_DECREF(axis);\n  Py_DECREF(args);\n  Py_DECREF(kwargs);\n  Py_DECREF(fig);\n  if (res) Py_DECREF(res);\n  return res;\n\n}\n\ntemplate<typename Numeric>\nbool boxplot(const std::vector<std::vector<Numeric>>& data,\n             const std::vector<std::string>& labels = {},\n             const std::map<std::string, std::string> & keywords = {})\n{\n    detail::_interpreter::get();\n\n    PyObject* listlist = detail::get_listlist(data);\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, listlist);\n\n    PyObject* kwargs = PyDict_New();\n\n    // kwargs needs the labels, if there are (the correct number of) labels\n    if (!labels.empty() && labels.size() == data.size()) {\n        PyDict_SetItemString(kwargs, \"labels\", detail::get_array(labels));\n    }\n\n    // take care of the remaining keywords\n    for (const auto& it : keywords)\n    {\n        PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_boxplot, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename Numeric>\nbool boxplot(const std::vector<Numeric>& data,\n             const std::map<std::string, std::string> & keywords = {})\n{\n    detail::_interpreter::get();\n\n    PyObject* vector = detail::get_array(data);\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, vector);\n\n    PyObject* kwargs = PyDict_New();\n    for (const auto& it : keywords)\n    {\n        PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_boxplot, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate <typename Numeric>\nbool bar(const std::vector<Numeric> &               x,\n         const std::vector<Numeric> &               y,\n         std::string                                ec       = \"black\",\n         std::string                                ls       = \"-\",\n         double                                     lw       = 1.0,\n         const std::map<std::string, std::string> & keywords = {})\n{\n  detail::_interpreter::get();\n\n  PyObject * xarray = detail::get_array(x);\n  PyObject * yarray = detail::get_array(y);\n\n  PyObject * kwargs = PyDict_New();\n\n  PyDict_SetItemString(kwargs, \"ec\", PyString_FromString(ec.c_str()));\n  PyDict_SetItemString(kwargs, \"ls\", PyString_FromString(ls.c_str()));\n  PyDict_SetItemString(kwargs, \"lw\", PyFloat_FromDouble(lw));\n\n  for (std::map<std::string, std::string>::const_iterator it =\n         keywords.begin();\n       it != keywords.end();\n       ++it) {\n    PyDict_SetItemString(\n      kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n  }\n\n  PyObject * plot_args = PyTuple_New(2);\n  PyTuple_SetItem(plot_args, 0, xarray);\n  PyTuple_SetItem(plot_args, 1, yarray);\n\n  PyObject * res = PyObject_Call(\n    detail::_interpreter::get().s_python_function_bar, plot_args, kwargs);\n\n  Py_DECREF(plot_args);\n  Py_DECREF(kwargs);\n  if (res) Py_DECREF(res);\n\n  return res;\n}\n\ntemplate <typename Numeric>\nbool bar(const std::vector<Numeric> &               y,\n         std::string                                ec       = \"black\",\n         std::string                                ls       = \"-\",\n         double                                     lw       = 1.0,\n         const std::map<std::string, std::string> & keywords = {})\n{\n  using T = typename std::remove_reference<decltype(y)>::type::value_type;\n\n  detail::_interpreter::get();\n\n  std::vector<T> x;\n  for (std::size_t i = 0; i < y.size(); i++) { x.push_back(i); }\n\n  return bar(x, y, ec, ls, lw, keywords);\n}\n\n\ntemplate<typename Numeric>\nbool barh(const std::vector<Numeric> &x, const std::vector<Numeric> &y, std::string ec = \"black\", std::string ls = \"-\", double lw = 1.0, const std::map<std::string, std::string> &keywords = { }) {\n    PyObject *xarray = detail::get_array(x);\n    PyObject *yarray = detail::get_array(y);\n\n    PyObject *kwargs = PyDict_New();\n\n    PyDict_SetItemString(kwargs, \"ec\", PyString_FromString(ec.c_str()));\n    PyDict_SetItemString(kwargs, \"ls\", PyString_FromString(ls.c_str()));\n    PyDict_SetItemString(kwargs, \"lw\", PyFloat_FromDouble(lw));\n\n    for (std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject *plot_args = PyTuple_New(2);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n\n    PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_barh, plot_args, kwargs);\n\n    Py_DECREF(plot_args);\n    Py_DECREF(kwargs);\n    if (res) Py_DECREF(res);\n\n    return res;\n}\n\n\ninline bool subplots_adjust(const std::map<std::string, double>& keywords = {})\n{\n    detail::_interpreter::get();\n\n    PyObject* kwargs = PyDict_New();\n    for (std::map<std::string, double>::const_iterator it =\n            keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(),\n                             PyFloat_FromDouble(it->second));\n    }\n\n\n    PyObject* plot_args = PyTuple_New(0);\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_subplots_adjust, plot_args, kwargs);\n\n    Py_DECREF(plot_args);\n    Py_DECREF(kwargs);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate< typename Numeric>\nbool named_hist(std::string label,const std::vector<Numeric>& y, long bins=10, std::string color=\"b\", double alpha=1.0)\n{\n    detail::_interpreter::get();\n\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"label\", PyString_FromString(label.c_str()));\n    PyDict_SetItemString(kwargs, \"bins\", PyLong_FromLong(bins));\n    PyDict_SetItemString(kwargs, \"color\", PyString_FromString(color.c_str()));\n    PyDict_SetItemString(kwargs, \"alpha\", PyFloat_FromDouble(alpha));\n\n\n    PyObject* plot_args = PyTuple_New(1);\n    PyTuple_SetItem(plot_args, 0, yarray);\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);\n\n    Py_DECREF(plot_args);\n    Py_DECREF(kwargs);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool plot(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = \"\")\n{\n    assert(x.size() == y.size());\n\n    detail::_interpreter::get();\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(s.c_str());\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, pystring);\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_plot, plot_args);\n\n    Py_DECREF(plot_args);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate <typename NumericX, typename NumericY, typename NumericZ>\nbool contour(const std::vector<NumericX>& x, const std::vector<NumericY>& y,\n             const std::vector<NumericZ>& z,\n             const std::map<std::string, std::string>& keywords = {}) {\n    assert(x.size() == y.size() && x.size() == z.size());\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n    PyObject* zarray = detail::get_array(z);\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, zarray);\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for (std::map<std::string, std::string>::const_iterator it = keywords.begin();\n         it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject* res =\n            PyObject_Call(detail::_interpreter::get().s_python_function_contour, plot_args, kwargs);\n\n    Py_DECREF(kwargs);\n    Py_DECREF(plot_args);\n    if (res)\n        Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY, typename NumericU, typename NumericW>\nbool quiver(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::vector<NumericU>& u, const std::vector<NumericW>& w, const std::map<std::string, std::string>& keywords = {})\n{\n    assert(x.size() == y.size() && x.size() == u.size() && u.size() == w.size());\n\n    detail::_interpreter::get();\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n    PyObject* uarray = detail::get_array(u);\n    PyObject* warray = detail::get_array(w);\n\n    PyObject* plot_args = PyTuple_New(4);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, uarray);\n    PyTuple_SetItem(plot_args, 3, warray);\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(\n            detail::_interpreter::get().s_python_function_quiver, plot_args, kwargs);\n\n    Py_DECREF(kwargs);\n    Py_DECREF(plot_args);\n    if (res)\n        Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY, typename NumericZ, typename NumericU, typename NumericW, typename NumericV>\nbool quiver(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::vector<NumericZ>& z, const std::vector<NumericU>& u, const std::vector<NumericW>& w, const std::vector<NumericV>& v, const std::map<std::string, std::string>& keywords = {})\n{\n  //set up 3d axes stuff\n  static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;\n  if (!mpl_toolkitsmod) {\n    detail::_interpreter::get();\n\n    PyObject* mpl_toolkits = PyString_FromString(\"mpl_toolkits\");\n    PyObject* axis3d = PyString_FromString(\"mpl_toolkits.mplot3d\");\n    if (!mpl_toolkits || !axis3d) { throw std::runtime_error(\"couldnt create string\"); }\n\n    mpl_toolkitsmod = PyImport_Import(mpl_toolkits);\n    Py_DECREF(mpl_toolkits);\n    if (!mpl_toolkitsmod) { throw std::runtime_error(\"Error loading module mpl_toolkits!\"); }\n\n    axis3dmod = PyImport_Import(axis3d);\n    Py_DECREF(axis3d);\n    if (!axis3dmod) { throw std::runtime_error(\"Error loading module mpl_toolkits.mplot3d!\"); }\n  }\n  \n  //assert sizes match up\n  assert(x.size() == y.size() && x.size() == u.size() && u.size() == w.size() && x.size() == z.size() && x.size() == v.size() && u.size() == v.size());\n\n  //set up parameters\n  detail::_interpreter::get();\n\n  PyObject* xarray = detail::get_array(x);\n  PyObject* yarray = detail::get_array(y);\n  PyObject* zarray = detail::get_array(z);\n  PyObject* uarray = detail::get_array(u);\n  PyObject* warray = detail::get_array(w);\n  PyObject* varray = detail::get_array(v);\n\n  PyObject* plot_args = PyTuple_New(6);\n  PyTuple_SetItem(plot_args, 0, xarray);\n  PyTuple_SetItem(plot_args, 1, yarray);\n  PyTuple_SetItem(plot_args, 2, zarray);\n  PyTuple_SetItem(plot_args, 3, uarray);\n  PyTuple_SetItem(plot_args, 4, warray);\n  PyTuple_SetItem(plot_args, 5, varray);\n\n  // construct keyword args\n  PyObject* kwargs = PyDict_New();\n  for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n  {\n      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n  }\n    \n  //get figure gca to enable 3d projection\n  PyObject *fig =\n      PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,\n                          detail::_interpreter::get().s_python_empty_tuple);\n  if (!fig) throw std::runtime_error(\"Call to figure() failed.\");\n\n  PyObject *gca_kwargs = PyDict_New();\n  PyDict_SetItemString(gca_kwargs, \"projection\", PyString_FromString(\"3d\"));\n\n  PyObject *gca = PyObject_GetAttrString(fig, \"gca\");\n  if (!gca) throw std::runtime_error(\"No gca\");\n  Py_INCREF(gca);\n  PyObject *axis = PyObject_Call(\n      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);\n\n  if (!axis) throw std::runtime_error(\"No axis\");\n  Py_INCREF(axis);\n  Py_DECREF(gca);\n  Py_DECREF(gca_kwargs);\n  \n  //plot our boys bravely, plot them strongly, plot them with a wink and clap\n  PyObject *plot3 = PyObject_GetAttrString(axis, \"quiver\");\n  if (!plot3) throw std::runtime_error(\"No 3D line plot\");\n  Py_INCREF(plot3);\n  PyObject* res = PyObject_Call(\n          plot3, plot_args, kwargs);\n  if (!res) throw std::runtime_error(\"Failed 3D plot\");\n  Py_DECREF(plot3);\n  Py_DECREF(axis);\n  Py_DECREF(kwargs);\n  Py_DECREF(plot_args);\n  if (res)\n      Py_DECREF(res);\n\n  return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool stem(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = \"\")\n{\n    assert(x.size() == y.size());\n\n    detail::_interpreter::get();\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(s.c_str());\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, pystring);\n\n    PyObject* res = PyObject_CallObject(\n            detail::_interpreter::get().s_python_function_stem, plot_args);\n\n    Py_DECREF(plot_args);\n    if (res)\n        Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool semilogx(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = \"\")\n{\n    assert(x.size() == y.size());\n\n    detail::_interpreter::get();\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(s.c_str());\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, pystring);\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_semilogx, plot_args);\n\n    Py_DECREF(plot_args);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool semilogy(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = \"\")\n{\n    assert(x.size() == y.size());\n\n    detail::_interpreter::get();\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(s.c_str());\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, pystring);\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_semilogy, plot_args);\n\n    Py_DECREF(plot_args);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool loglog(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = \"\")\n{\n    assert(x.size() == y.size());\n\n    detail::_interpreter::get();\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(s.c_str());\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, pystring);\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_loglog, plot_args);\n\n    Py_DECREF(plot_args);\n    if(res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool errorbar(const std::vector<NumericX> &x, const std::vector<NumericY> &y, const std::vector<NumericX> &yerr, const std::map<std::string, std::string> &keywords = {})\n{\n    assert(x.size() == y.size());\n\n    detail::_interpreter::get();\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n    PyObject* yerrarray = detail::get_array(yerr);\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));\n    }\n\n    PyDict_SetItemString(kwargs, \"yerr\", yerrarray);\n\n    PyObject *plot_args = PyTuple_New(2);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n\n    PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_errorbar, plot_args, kwargs);\n\n    Py_DECREF(kwargs);\n    Py_DECREF(plot_args);\n\n    if (res)\n        Py_DECREF(res);\n    else\n        throw std::runtime_error(\"Call to errorbar() failed.\");\n\n    return res;\n}\n\ntemplate<typename Numeric>\nbool named_plot(const std::string& name, const std::vector<Numeric>& y, const std::string& format = \"\")\n{\n    detail::_interpreter::get();\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"label\", PyString_FromString(name.c_str()));\n\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(format.c_str());\n\n    PyObject* plot_args = PyTuple_New(2);\n\n    PyTuple_SetItem(plot_args, 0, yarray);\n    PyTuple_SetItem(plot_args, 1, pystring);\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);\n\n    Py_DECREF(kwargs);\n    Py_DECREF(plot_args);\n    if (res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool named_plot(const std::string& name, const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& format = \"\")\n{\n    detail::_interpreter::get();\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"label\", PyString_FromString(name.c_str()));\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(format.c_str());\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, pystring);\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);\n\n    Py_DECREF(kwargs);\n    Py_DECREF(plot_args);\n    if (res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool named_semilogx(const std::string& name, const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& format = \"\")\n{\n    detail::_interpreter::get();\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"label\", PyString_FromString(name.c_str()));\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(format.c_str());\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, pystring);\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_semilogx, plot_args, kwargs);\n\n    Py_DECREF(kwargs);\n    Py_DECREF(plot_args);\n    if (res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool named_semilogy(const std::string& name, const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& format = \"\")\n{\n    detail::_interpreter::get();\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"label\", PyString_FromString(name.c_str()));\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(format.c_str());\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, pystring);\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_semilogy, plot_args, kwargs);\n\n    Py_DECREF(kwargs);\n    Py_DECREF(plot_args);\n    if (res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename NumericX, typename NumericY>\nbool named_loglog(const std::string& name, const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& format = \"\")\n{\n    detail::_interpreter::get();\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"label\", PyString_FromString(name.c_str()));\n\n    PyObject* xarray = detail::get_array(x);\n    PyObject* yarray = detail::get_array(y);\n\n    PyObject* pystring = PyString_FromString(format.c_str());\n\n    PyObject* plot_args = PyTuple_New(3);\n    PyTuple_SetItem(plot_args, 0, xarray);\n    PyTuple_SetItem(plot_args, 1, yarray);\n    PyTuple_SetItem(plot_args, 2, pystring);\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_loglog, plot_args, kwargs);\n\n    Py_DECREF(kwargs);\n    Py_DECREF(plot_args);\n    if (res) Py_DECREF(res);\n\n    return res;\n}\n\ntemplate<typename Numeric>\nbool plot(const std::vector<Numeric>& y, const std::string& format = \"\")\n{\n    std::vector<Numeric> x(y.size());\n    for(size_t i=0; i<x.size(); ++i) x.at(i) = i;\n    return plot(x,y,format);\n}\n\ntemplate<typename Numeric>\nbool plot(const std::vector<Numeric>& y, const std::map<std::string, std::string>& keywords)\n{\n    std::vector<Numeric> x(y.size());\n    for(size_t i=0; i<x.size(); ++i) x.at(i) = i;\n    return plot(x,y,keywords);\n}\n\ntemplate<typename Numeric>\nbool stem(const std::vector<Numeric>& y, const std::string& format = \"\")\n{\n    std::vector<Numeric> x(y.size());\n    for (size_t i = 0; i < x.size(); ++i) x.at(i) = i;\n    return stem(x, y, format);\n}\n\ntemplate<typename Numeric>\nvoid text(Numeric x, Numeric y, const std::string& s = \"\")\n{\n    detail::_interpreter::get();\n\n    PyObject* args = PyTuple_New(3);\n    PyTuple_SetItem(args, 0, PyFloat_FromDouble(x));\n    PyTuple_SetItem(args, 1, PyFloat_FromDouble(y));\n    PyTuple_SetItem(args, 2, PyString_FromString(s.c_str()));\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_text, args);\n    if(!res) throw std::runtime_error(\"Call to text() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\ninline void colorbar(PyObject* mappable = NULL, const std::map<std::string, float>& keywords = {})\n{\n    if (mappable == NULL)\n        throw std::runtime_error(\"Must call colorbar with PyObject* returned from an image, contour, surface, etc.\");\n\n    detail::_interpreter::get();\n\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, mappable);\n\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, float>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyFloat_FromDouble(it->second));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_colorbar, args, kwargs);\n    if(!res) throw std::runtime_error(\"Call to colorbar() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    Py_DECREF(res);\n}\n\n\ninline long figure(long number = -1)\n{\n    detail::_interpreter::get();\n\n    PyObject *res;\n    if (number == -1)\n        res = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure, detail::_interpreter::get().s_python_empty_tuple);\n    else {\n        assert(number > 0);\n\n        // Make sure interpreter is initialised\n        detail::_interpreter::get();\n\n        PyObject *args = PyTuple_New(1);\n        PyTuple_SetItem(args, 0, PyLong_FromLong(number));\n        res = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure, args);\n        Py_DECREF(args);\n    }\n\n    if(!res) throw std::runtime_error(\"Call to figure() failed.\");\n\n    PyObject* num = PyObject_GetAttrString(res, \"number\");\n    if (!num) throw std::runtime_error(\"Could not get number attribute of figure object\");\n    const long figureNumber = PyLong_AsLong(num);\n\n    Py_DECREF(num);\n    Py_DECREF(res);\n\n    return figureNumber;\n}\n\ninline bool fignum_exists(long number)\n{\n    detail::_interpreter::get();\n\n    PyObject *args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, PyLong_FromLong(number));\n    PyObject *res = PyObject_CallObject(detail::_interpreter::get().s_python_function_fignum_exists, args);\n    if(!res) throw std::runtime_error(\"Call to fignum_exists() failed.\");\n\n    bool ret = PyObject_IsTrue(res);\n    Py_DECREF(res);\n    Py_DECREF(args);\n\n    return ret;\n}\n\ninline void figure_size(size_t w, size_t h)\n{\n    detail::_interpreter::get();\n\n    const size_t dpi = 100;\n    PyObject* size = PyTuple_New(2);\n    PyTuple_SetItem(size, 0, PyFloat_FromDouble((double)w / dpi));\n    PyTuple_SetItem(size, 1, PyFloat_FromDouble((double)h / dpi));\n\n    PyObject* kwargs = PyDict_New();\n    PyDict_SetItemString(kwargs, \"figsize\", size);\n    PyDict_SetItemString(kwargs, \"dpi\", PyLong_FromSize_t(dpi));\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_figure,\n            detail::_interpreter::get().s_python_empty_tuple, kwargs);\n\n    Py_DECREF(kwargs);\n\n    if(!res) throw std::runtime_error(\"Call to figure_size() failed.\");\n    Py_DECREF(res);\n}\n\ninline void legend()\n{\n    detail::_interpreter::get();\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_legend, detail::_interpreter::get().s_python_empty_tuple);\n    if(!res) throw std::runtime_error(\"Call to legend() failed.\");\n\n    Py_DECREF(res);\n}\n\ninline void legend(const std::map<std::string, std::string>& keywords)\n{\n  detail::_interpreter::get();\n\n  // construct keyword args\n  PyObject* kwargs = PyDict_New();\n  for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n  {\n    PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));\n  }\n\n  PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_legend, detail::_interpreter::get().s_python_empty_tuple, kwargs);\n  if(!res) throw std::runtime_error(\"Call to legend() failed.\");\n\n  Py_DECREF(kwargs);\n  Py_DECREF(res);\n}\n\ntemplate<typename Numeric>\ninline void set_aspect(Numeric ratio)\n{\n    detail::_interpreter::get();\n\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, PyFloat_FromDouble(ratio));\n    PyObject* kwargs = PyDict_New();\n\n    PyObject *ax =\n    PyObject_CallObject(detail::_interpreter::get().s_python_function_gca,\n      detail::_interpreter::get().s_python_empty_tuple);\n    if (!ax) throw std::runtime_error(\"Call to gca() failed.\");\n    Py_INCREF(ax);\n\n    PyObject *set_aspect = PyObject_GetAttrString(ax, \"set_aspect\");\n    if (!set_aspect) throw std::runtime_error(\"Attribute set_aspect not found.\");\n    Py_INCREF(set_aspect);\n\n    PyObject *res = PyObject_Call(set_aspect, args, kwargs);\n    if (!res) throw std::runtime_error(\"Call to set_aspect() failed.\");\n    Py_DECREF(set_aspect);\n\n    Py_DECREF(ax);\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n}\n\ninline void set_aspect_equal()\n{\n    // expect ratio == \"equal\". Leaving error handling to matplotlib.\n    detail::_interpreter::get();\n\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, PyString_FromString(\"equal\"));\n    PyObject* kwargs = PyDict_New();\n\n    PyObject *ax =\n    PyObject_CallObject(detail::_interpreter::get().s_python_function_gca,\n      detail::_interpreter::get().s_python_empty_tuple);\n    if (!ax) throw std::runtime_error(\"Call to gca() failed.\");\n    Py_INCREF(ax);\n\n    PyObject *set_aspect = PyObject_GetAttrString(ax, \"set_aspect\");\n    if (!set_aspect) throw std::runtime_error(\"Attribute set_aspect not found.\");\n    Py_INCREF(set_aspect);\n\n    PyObject *res = PyObject_Call(set_aspect, args, kwargs);\n    if (!res) throw std::runtime_error(\"Call to set_aspect() failed.\");\n    Py_DECREF(set_aspect);\n\n    Py_DECREF(ax);\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n}\n\ntemplate<typename Numeric>\nvoid ylim(Numeric left, Numeric right)\n{\n    detail::_interpreter::get();\n\n    PyObject* list = PyList_New(2);\n    PyList_SetItem(list, 0, PyFloat_FromDouble(left));\n    PyList_SetItem(list, 1, PyFloat_FromDouble(right));\n\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, list);\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);\n    if(!res) throw std::runtime_error(\"Call to ylim() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\ntemplate<typename Numeric>\nvoid xlim(Numeric left, Numeric right)\n{\n    detail::_interpreter::get();\n\n    PyObject* list = PyList_New(2);\n    PyList_SetItem(list, 0, PyFloat_FromDouble(left));\n    PyList_SetItem(list, 1, PyFloat_FromDouble(right));\n\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, list);\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);\n    if(!res) throw std::runtime_error(\"Call to xlim() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\n\ninline std::array<double, 2> xlim()\n{\n    PyObject* args = PyTuple_New(0);\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);\n\n    if(!res) throw std::runtime_error(\"Call to xlim() failed.\");\n\n    Py_DECREF(res);\n\n    PyObject* left = PyTuple_GetItem(res,0);\n    PyObject* right = PyTuple_GetItem(res,1);\n    return { PyFloat_AsDouble(left), PyFloat_AsDouble(right) };\n}\n\n\ninline std::array<double, 2> ylim()\n{\n    PyObject* args = PyTuple_New(0);\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);\n\n    if(!res) throw std::runtime_error(\"Call to ylim() failed.\");\n\n    Py_DECREF(res);\n\n    PyObject* left = PyTuple_GetItem(res,0);\n    PyObject* right = PyTuple_GetItem(res,1);\n    return { PyFloat_AsDouble(left), PyFloat_AsDouble(right) };\n}\n\ntemplate<typename Numeric>\ninline void xticks(const std::vector<Numeric> &ticks, const std::vector<std::string> &labels = {}, const std::map<std::string, std::string>& keywords = {})\n{\n    assert(labels.size() == 0 || ticks.size() == labels.size());\n\n    detail::_interpreter::get();\n\n    // using numpy array\n    PyObject* ticksarray = detail::get_array(ticks);\n\n    PyObject* args;\n    if(labels.size() == 0) {\n        // construct positional args\n        args = PyTuple_New(1);\n        PyTuple_SetItem(args, 0, ticksarray);\n    } else {\n        // make tuple of tick labels\n        PyObject* labelstuple = PyTuple_New(labels.size());\n        for (size_t i = 0; i < labels.size(); i++)\n            PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));\n\n        // construct positional args\n        args = PyTuple_New(2);\n        PyTuple_SetItem(args, 0, ticksarray);\n        PyTuple_SetItem(args, 1, labelstuple);\n    }\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_xticks, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    if(!res) throw std::runtime_error(\"Call to xticks() failed\");\n\n    Py_DECREF(res);\n}\n\ntemplate<typename Numeric>\ninline void xticks(const std::vector<Numeric> &ticks, const std::map<std::string, std::string>& keywords)\n{\n    xticks(ticks, {}, keywords);\n}\n\ntemplate<typename Numeric>\ninline void yticks(const std::vector<Numeric> &ticks, const std::vector<std::string> &labels = {}, const std::map<std::string, std::string>& keywords = {})\n{\n    assert(labels.size() == 0 || ticks.size() == labels.size());\n\n    detail::_interpreter::get();\n\n    // using numpy array\n    PyObject* ticksarray = detail::get_array(ticks);\n\n    PyObject* args;\n    if(labels.size() == 0) {\n        // construct positional args\n        args = PyTuple_New(1);\n        PyTuple_SetItem(args, 0, ticksarray);\n    } else {\n        // make tuple of tick labels\n        PyObject* labelstuple = PyTuple_New(labels.size());\n        for (size_t i = 0; i < labels.size(); i++)\n            PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));\n\n        // construct positional args\n        args = PyTuple_New(2);\n        PyTuple_SetItem(args, 0, ticksarray);\n        PyTuple_SetItem(args, 1, labelstuple);\n    }\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_yticks, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    if(!res) throw std::runtime_error(\"Call to yticks() failed\");\n\n    Py_DECREF(res);\n}\n\ntemplate<typename Numeric>\ninline void yticks(const std::vector<Numeric> &ticks, const std::map<std::string, std::string>& keywords)\n{\n    yticks(ticks, {}, keywords);\n}\n\ntemplate <typename Numeric> inline void margins(Numeric margin)\n{\n    // construct positional args\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, PyFloat_FromDouble(margin));\n\n    PyObject* res =\n            PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);\n    if (!res)\n        throw std::runtime_error(\"Call to margins() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\ntemplate <typename Numeric> inline void margins(Numeric margin_x, Numeric margin_y)\n{\n    // construct positional args\n    PyObject* args = PyTuple_New(2);\n    PyTuple_SetItem(args, 0, PyFloat_FromDouble(margin_x));\n    PyTuple_SetItem(args, 1, PyFloat_FromDouble(margin_y));\n\n    PyObject* res =\n            PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);\n    if (!res)\n        throw std::runtime_error(\"Call to margins() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\n\ninline void tick_params(const std::map<std::string, std::string>& keywords, const std::string axis = \"both\")\n{\n  detail::_interpreter::get();\n\n  // construct positional args\n  PyObject* args;\n  args = PyTuple_New(1);\n  PyTuple_SetItem(args, 0, PyString_FromString(axis.c_str()));\n\n  // construct keyword args\n  PyObject* kwargs = PyDict_New();\n  for (std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n  {\n    PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));\n  }\n\n\n  PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_tick_params, args, kwargs);\n\n  Py_DECREF(args);\n  Py_DECREF(kwargs);\n  if (!res) throw std::runtime_error(\"Call to tick_params() failed\");\n\n  Py_DECREF(res);\n}\n\ninline void subplot(long nrows, long ncols, long plot_number)\n{\n    detail::_interpreter::get();\n\n    // construct positional args\n    PyObject* args = PyTuple_New(3);\n    PyTuple_SetItem(args, 0, PyFloat_FromDouble(nrows));\n    PyTuple_SetItem(args, 1, PyFloat_FromDouble(ncols));\n    PyTuple_SetItem(args, 2, PyFloat_FromDouble(plot_number));\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_subplot, args);\n    if(!res) throw std::runtime_error(\"Call to subplot() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\ninline void subplot2grid(long nrows, long ncols, long rowid=0, long colid=0, long rowspan=1, long colspan=1)\n{\n    detail::_interpreter::get();\n\n    PyObject* shape = PyTuple_New(2);\n    PyTuple_SetItem(shape, 0, PyLong_FromLong(nrows));\n    PyTuple_SetItem(shape, 1, PyLong_FromLong(ncols));\n\n    PyObject* loc = PyTuple_New(2);\n    PyTuple_SetItem(loc, 0, PyLong_FromLong(rowid));\n    PyTuple_SetItem(loc, 1, PyLong_FromLong(colid));\n\n    PyObject* args = PyTuple_New(4);\n    PyTuple_SetItem(args, 0, shape);\n    PyTuple_SetItem(args, 1, loc);\n    PyTuple_SetItem(args, 2, PyLong_FromLong(rowspan));\n    PyTuple_SetItem(args, 3, PyLong_FromLong(colspan));\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_subplot2grid, args);\n    if(!res) throw std::runtime_error(\"Call to subplot2grid() failed.\");\n\n    Py_DECREF(shape);\n    Py_DECREF(loc);\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\ninline void title(const std::string &titlestr, const std::map<std::string, std::string> &keywords = {})\n{\n    detail::_interpreter::get();\n\n    PyObject* pytitlestr = PyString_FromString(titlestr.c_str());\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, pytitlestr);\n\n    PyObject* kwargs = PyDict_New();\n    for (auto it = keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_title, args, kwargs);\n    if(!res) throw std::runtime_error(\"Call to title() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    Py_DECREF(res);\n}\n\ninline void suptitle(const std::string &suptitlestr, const std::map<std::string, std::string> &keywords = {})\n{\n    detail::_interpreter::get();\n\n    PyObject* pysuptitlestr = PyString_FromString(suptitlestr.c_str());\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, pysuptitlestr);\n\n    PyObject* kwargs = PyDict_New();\n    for (auto it = keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_suptitle, args, kwargs);\n    if(!res) throw std::runtime_error(\"Call to suptitle() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    Py_DECREF(res);\n}\n\ninline void axis(const std::string &axisstr)\n{\n    detail::_interpreter::get();\n\n    PyObject* str = PyString_FromString(axisstr.c_str());\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, str);\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_axis, args);\n    if(!res) throw std::runtime_error(\"Call to title() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\ninline void axhline(double y, double xmin = 0., double xmax = 1., const std::map<std::string, std::string>& keywords = std::map<std::string, std::string>())\n{\n    detail::_interpreter::get();\n\n    // construct positional args\n    PyObject* args = PyTuple_New(3);\n    PyTuple_SetItem(args, 0, PyFloat_FromDouble(y));\n    PyTuple_SetItem(args, 1, PyFloat_FromDouble(xmin));\n    PyTuple_SetItem(args, 2, PyFloat_FromDouble(xmax));\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_axhline, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n\n    if(res) Py_DECREF(res);\n}\n\ninline void axvline(double x, double ymin = 0., double ymax = 1., const std::map<std::string, std::string>& keywords = std::map<std::string, std::string>())\n{\n    detail::_interpreter::get();\n\n    // construct positional args\n    PyObject* args = PyTuple_New(3);\n    PyTuple_SetItem(args, 0, PyFloat_FromDouble(x));\n    PyTuple_SetItem(args, 1, PyFloat_FromDouble(ymin));\n    PyTuple_SetItem(args, 2, PyFloat_FromDouble(ymax));\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_axvline, args, kwargs);\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n\n    if(res) Py_DECREF(res);\n}\n\ninline void axvspan(double xmin, double xmax, double ymin = 0., double ymax = 1., const std::map<std::string, std::string>& keywords = std::map<std::string, std::string>())\n{\n    // construct positional args\n    PyObject* args = PyTuple_New(4);\n    PyTuple_SetItem(args, 0, PyFloat_FromDouble(xmin));\n    PyTuple_SetItem(args, 1, PyFloat_FromDouble(xmax));\n    PyTuple_SetItem(args, 2, PyFloat_FromDouble(ymin));\n    PyTuple_SetItem(args, 3, PyFloat_FromDouble(ymax));\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for (auto it = keywords.begin(); it != keywords.end(); ++it) {\n      if (it->first == \"linewidth\" || it->first == \"alpha\") {\n        PyDict_SetItemString(kwargs, it->first.c_str(),\n          PyFloat_FromDouble(std::stod(it->second)));\n      } else {\n        PyDict_SetItemString(kwargs, it->first.c_str(),\n          PyString_FromString(it->second.c_str()));\n      }\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_axvspan, args, kwargs);\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n\n    if(res) Py_DECREF(res);\n}\n\ninline void xlabel(const std::string &str, const std::map<std::string, std::string> &keywords = {})\n{\n    detail::_interpreter::get();\n\n    PyObject* pystr = PyString_FromString(str.c_str());\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, pystr);\n\n    PyObject* kwargs = PyDict_New();\n    for (auto it = keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_xlabel, args, kwargs);\n    if(!res) throw std::runtime_error(\"Call to xlabel() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    Py_DECREF(res);\n}\n\ninline void ylabel(const std::string &str, const std::map<std::string, std::string>& keywords = {})\n{\n    detail::_interpreter::get();\n\n    PyObject* pystr = PyString_FromString(str.c_str());\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, pystr);\n\n    PyObject* kwargs = PyDict_New();\n    for (auto it = keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_ylabel, args, kwargs);\n    if(!res) throw std::runtime_error(\"Call to ylabel() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    Py_DECREF(res);\n}\n\ninline void set_zlabel(const std::string &str, const std::map<std::string, std::string>& keywords = {})\n{\n    detail::_interpreter::get();\n\n    // Same as with plot_surface: We lazily load the modules here the first time\n    // this function is called because I'm not sure that we can assume \"matplotlib\n    // installed\" implies \"mpl_toolkits installed\" on all platforms, and we don't\n    // want to require it for people who don't need 3d plots.\n    static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;\n    if (!mpl_toolkitsmod) {\n        PyObject* mpl_toolkits = PyString_FromString(\"mpl_toolkits\");\n        PyObject* axis3d = PyString_FromString(\"mpl_toolkits.mplot3d\");\n        if (!mpl_toolkits || !axis3d) { throw std::runtime_error(\"couldnt create string\"); }\n\n        mpl_toolkitsmod = PyImport_Import(mpl_toolkits);\n        Py_DECREF(mpl_toolkits);\n        if (!mpl_toolkitsmod) { throw std::runtime_error(\"Error loading module mpl_toolkits!\"); }\n\n        axis3dmod = PyImport_Import(axis3d);\n        Py_DECREF(axis3d);\n        if (!axis3dmod) { throw std::runtime_error(\"Error loading module mpl_toolkits.mplot3d!\"); }\n    }\n\n    PyObject* pystr = PyString_FromString(str.c_str());\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, pystr);\n\n    PyObject* kwargs = PyDict_New();\n    for (auto it = keywords.begin(); it != keywords.end(); ++it) {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject *ax =\n    PyObject_CallObject(detail::_interpreter::get().s_python_function_gca,\n      detail::_interpreter::get().s_python_empty_tuple);\n    if (!ax) throw std::runtime_error(\"Call to gca() failed.\");\n    Py_INCREF(ax);\n\n    PyObject *zlabel = PyObject_GetAttrString(ax, \"set_zlabel\");\n    if (!zlabel) throw std::runtime_error(\"Attribute set_zlabel not found.\");\n    Py_INCREF(zlabel);\n\n    PyObject *res = PyObject_Call(zlabel, args, kwargs);\n    if (!res) throw std::runtime_error(\"Call to set_zlabel() failed.\");\n    Py_DECREF(zlabel);\n\n    Py_DECREF(ax);\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    if (res) Py_DECREF(res);\n}\n\ninline void grid(bool flag)\n{\n    detail::_interpreter::get();\n\n    PyObject* pyflag = flag ? Py_True : Py_False;\n    Py_INCREF(pyflag);\n\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, pyflag);\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_grid, args);\n    if(!res) throw std::runtime_error(\"Call to grid() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\ninline void show(const bool block = true)\n{\n    detail::_interpreter::get();\n\n    PyObject* res;\n    if(block)\n    {\n        res = PyObject_CallObject(\n                detail::_interpreter::get().s_python_function_show,\n                detail::_interpreter::get().s_python_empty_tuple);\n    }\n    else\n    {\n        PyObject *kwargs = PyDict_New();\n        PyDict_SetItemString(kwargs, \"block\", Py_False);\n        res = PyObject_Call( detail::_interpreter::get().s_python_function_show, detail::_interpreter::get().s_python_empty_tuple, kwargs);\n       Py_DECREF(kwargs);\n    }\n\n\n    if (!res) throw std::runtime_error(\"Call to show() failed.\");\n\n    Py_DECREF(res);\n}\n\ninline void close()\n{\n    detail::_interpreter::get();\n\n    PyObject* res = PyObject_CallObject(\n            detail::_interpreter::get().s_python_function_close,\n            detail::_interpreter::get().s_python_empty_tuple);\n\n    if (!res) throw std::runtime_error(\"Call to close() failed.\");\n\n    Py_DECREF(res);\n}\n\ninline void xkcd() {\n    detail::_interpreter::get();\n\n    PyObject* res;\n    PyObject *kwargs = PyDict_New();\n\n    res = PyObject_Call(detail::_interpreter::get().s_python_function_xkcd,\n            detail::_interpreter::get().s_python_empty_tuple, kwargs);\n\n    Py_DECREF(kwargs);\n\n    if (!res)\n        throw std::runtime_error(\"Call to show() failed.\");\n\n    Py_DECREF(res);\n}\n\ninline void draw()\n{\n    detail::_interpreter::get();\n\n    PyObject* res = PyObject_CallObject(\n        detail::_interpreter::get().s_python_function_draw,\n        detail::_interpreter::get().s_python_empty_tuple);\n\n    if (!res) throw std::runtime_error(\"Call to draw() failed.\");\n\n    Py_DECREF(res);\n}\n\ntemplate<typename Numeric>\ninline void pause(Numeric interval)\n{\n    detail::_interpreter::get();\n\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, PyFloat_FromDouble(interval));\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_pause, args);\n    if(!res) throw std::runtime_error(\"Call to pause() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(res);\n}\n\ninline void save(const std::string& filename, const int dpi=0)\n{\n    detail::_interpreter::get();\n\n    PyObject* pyfilename = PyString_FromString(filename.c_str());\n\n    PyObject* args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, pyfilename);\n\n    PyObject* kwargs = PyDict_New();\n\n    if(dpi > 0)\n    {\n        PyDict_SetItemString(kwargs, \"dpi\", PyLong_FromLong(dpi));\n    }\n\n    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_save, args, kwargs);\n    if (!res) throw std::runtime_error(\"Call to save() failed.\");\n\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    Py_DECREF(res);\n}\n\ninline void rcparams(const std::map<std::string, std::string>& keywords = {}) {\n    detail::_interpreter::get();\n    PyObject* args = PyTuple_New(0);\n    PyObject* kwargs = PyDict_New();\n    for (auto it = keywords.begin(); it != keywords.end(); ++it) {\n        if (\"text.usetex\" == it->first)\n          PyDict_SetItemString(kwargs, it->first.c_str(), PyLong_FromLong(std::stoi(it->second.c_str())));\n        else PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));\n    }\n    \n    PyObject * update = PyObject_GetAttrString(detail::_interpreter::get().s_python_function_rcparams, \"update\");\n    PyObject * res = PyObject_Call(update, args, kwargs);\n    if(!res) throw std::runtime_error(\"Call to rcParams.update() failed.\");\n    Py_DECREF(args);\n    Py_DECREF(kwargs);\n    Py_DECREF(update);\n    Py_DECREF(res);\n}\n\ninline void clf() {\n    detail::_interpreter::get();\n\n    PyObject *res = PyObject_CallObject(\n        detail::_interpreter::get().s_python_function_clf,\n        detail::_interpreter::get().s_python_empty_tuple);\n\n    if (!res) throw std::runtime_error(\"Call to clf() failed.\");\n\n    Py_DECREF(res);\n}\n\ninline void cla() {\n    detail::_interpreter::get();\n\n    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_cla,\n                                        detail::_interpreter::get().s_python_empty_tuple);\n\n    if (!res)\n        throw std::runtime_error(\"Call to cla() failed.\");\n\n    Py_DECREF(res);\n}\n\ninline void ion() {\n    detail::_interpreter::get();\n\n    PyObject *res = PyObject_CallObject(\n        detail::_interpreter::get().s_python_function_ion,\n        detail::_interpreter::get().s_python_empty_tuple);\n\n    if (!res) throw std::runtime_error(\"Call to ion() failed.\");\n\n    Py_DECREF(res);\n}\n\ninline std::vector<std::array<double, 2>> ginput(const int numClicks = 1, const std::map<std::string, std::string>& keywords = {})\n{\n    detail::_interpreter::get();\n\n    PyObject *args = PyTuple_New(1);\n    PyTuple_SetItem(args, 0, PyLong_FromLong(numClicks));\n\n    // construct keyword args\n    PyObject* kwargs = PyDict_New();\n    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)\n    {\n        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));\n    }\n\n    PyObject* res = PyObject_Call(\n        detail::_interpreter::get().s_python_function_ginput, args, kwargs);\n\n    Py_DECREF(kwargs);\n    Py_DECREF(args);\n    if (!res) throw std::runtime_error(\"Call to ginput() failed.\");\n\n    const size_t len = PyList_Size(res);\n    std::vector<std::array<double, 2>> out;\n    out.reserve(len);\n    for (size_t i = 0; i < len; i++) {\n        PyObject *current = PyList_GetItem(res, i);\n        std::array<double, 2> position;\n        position[0] = PyFloat_AsDouble(PyTuple_GetItem(current, 0));\n        position[1] = PyFloat_AsDouble(PyTuple_GetItem(current, 1));\n        out.push_back(position);\n    }\n    Py_DECREF(res);\n\n    return out;\n}\n\n// Actually, is there any reason not to call this automatically for every plot?\ninline void tight_layout() {\n    detail::_interpreter::get();\n\n    PyObject *res = PyObject_CallObject(\n        detail::_interpreter::get().s_python_function_tight_layout,\n        detail::_interpreter::get().s_python_empty_tuple);\n\n    if (!res) throw std::runtime_error(\"Call to tight_layout() failed.\");\n\n    Py_DECREF(res);\n}\n\n// Support for variadic plot() and initializer lists:\n\nnamespace detail {\n\ntemplate<typename T>\nusing is_function = typename std::is_function<std::remove_pointer<std::remove_reference<T>>>::type;\n\ntemplate<bool obj, typename T>\nstruct is_callable_impl;\n\ntemplate<typename T>\nstruct is_callable_impl<false, T>\n{\n    typedef is_function<T> type;\n}; // a non-object is callable iff it is a function\n\ntemplate<typename T>\nstruct is_callable_impl<true, T>\n{\n    struct Fallback { void operator()(); };\n    struct Derived : T, Fallback { };\n\n    template<typename U, U> struct Check;\n\n    template<typename U>\n    static std::true_type test( ... ); // use a variadic function to make sure (1) it accepts everything and (2) its always the worst match\n\n    template<typename U>\n    static std::false_type test( Check<void(Fallback::*)(), &U::operator()>* );\n\npublic:\n    typedef decltype(test<Derived>(nullptr)) type;\n    typedef decltype(&Fallback::operator()) dtype;\n    static constexpr bool value = type::value;\n}; // an object is callable iff it defines operator()\n\ntemplate<typename T>\nstruct is_callable\n{\n    // dispatch to is_callable_impl<true, T> or is_callable_impl<false, T> depending on whether T is of class type or not\n    typedef typename is_callable_impl<std::is_class<T>::value, T>::type type;\n};\n\ntemplate<typename IsYDataCallable>\nstruct plot_impl { };\n\ntemplate<>\nstruct plot_impl<std::false_type>\n{\n    template<typename IterableX, typename IterableY>\n    bool operator()(const IterableX& x, const IterableY& y, const std::string& format)\n    {\n        detail::_interpreter::get();\n\n        // 2-phase lookup for distance, begin, end\n        using std::distance;\n        using std::begin;\n        using std::end;\n\n        auto xs = distance(begin(x), end(x));\n        auto ys = distance(begin(y), end(y));\n        assert(xs == ys && \"x and y data must have the same number of elements!\");\n\n        PyObject* xlist = PyList_New(xs);\n        PyObject* ylist = PyList_New(ys);\n        PyObject* pystring = PyString_FromString(format.c_str());\n\n        auto itx = begin(x), ity = begin(y);\n        for(size_t i = 0; i < xs; ++i) {\n            PyList_SetItem(xlist, i, PyFloat_FromDouble(*itx++));\n            PyList_SetItem(ylist, i, PyFloat_FromDouble(*ity++));\n        }\n\n        PyObject* plot_args = PyTuple_New(3);\n        PyTuple_SetItem(plot_args, 0, xlist);\n        PyTuple_SetItem(plot_args, 1, ylist);\n        PyTuple_SetItem(plot_args, 2, pystring);\n\n        PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_plot, plot_args);\n\n        Py_DECREF(plot_args);\n        if(res) Py_DECREF(res);\n\n        return res;\n    }\n};\n\ntemplate<>\nstruct plot_impl<std::true_type>\n{\n    template<typename Iterable, typename Callable>\n    bool operator()(const Iterable& ticks, const Callable& f, const std::string& format)\n    {\n        if(begin(ticks) == end(ticks)) return true;\n\n        // We could use additional meta-programming to deduce the correct element type of y,\n        // but all values have to be convertible to double anyways\n        std::vector<double> y;\n        for(auto x : ticks) y.push_back(f(x));\n        return plot_impl<std::false_type>()(ticks,y,format);\n    }\n};\n\n} // end namespace detail\n\n// recursion stop for the above\ntemplate<typename... Args>\nbool plot() { return true; }\n\ntemplate<typename A, typename B, typename... Args>\nbool plot(const A& a, const B& b, const std::string& format, Args... args)\n{\n    return detail::plot_impl<typename detail::is_callable<B>::type>()(a,b,format) && plot(args...);\n}\n\n/*\n * This group of plot() functions is needed to support initializer lists, i.e. calling\n *    plot( {1,2,3,4} )\n */\ninline bool plot(const std::vector<double>& x, const std::vector<double>& y, const std::string& format = \"\") {\n    return plot<double,double>(x,y,format);\n}\n\ninline bool plot(const std::vector<double>& y, const std::string& format = \"\") {\n    return plot<double>(y,format);\n}\n\ninline bool plot(const std::vector<double>& x, const std::vector<double>& y, const std::map<std::string, std::string>& keywords) {\n    return plot<double>(x,y,keywords);\n}\n\n/*\n * This class allows dynamic plots, ie changing the plotted data without clearing and re-plotting\n */\nclass Plot\n{\npublic:\n    // default initialization with plot label, some data and format\n    template<typename Numeric>\n    Plot(const std::string& name, const std::vector<Numeric>& x, const std::vector<Numeric>& y, const std::string& format = \"\") {\n        detail::_interpreter::get();\n\n        assert(x.size() == y.size());\n\n        PyObject* kwargs = PyDict_New();\n        if(name != \"\")\n            PyDict_SetItemString(kwargs, \"label\", PyString_FromString(name.c_str()));\n\n        PyObject* xarray = detail::get_array(x);\n        PyObject* yarray = detail::get_array(y);\n\n        PyObject* pystring = PyString_FromString(format.c_str());\n\n        PyObject* plot_args = PyTuple_New(3);\n        PyTuple_SetItem(plot_args, 0, xarray);\n        PyTuple_SetItem(plot_args, 1, yarray);\n        PyTuple_SetItem(plot_args, 2, pystring);\n\n        PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);\n\n        Py_DECREF(kwargs);\n        Py_DECREF(plot_args);\n\n        if(res)\n        {\n            line= PyList_GetItem(res, 0);\n\n            if(line)\n                set_data_fct = PyObject_GetAttrString(line,\"set_data\");\n            else\n                Py_DECREF(line);\n            Py_DECREF(res);\n        }\n    }\n\n    // shorter initialization with name or format only\n    // basically calls line, = plot([], [])\n    Plot(const std::string& name = \"\", const std::string& format = \"\")\n        : Plot(name, std::vector<double>(), std::vector<double>(), format) {}\n\n    template<typename Numeric>\n    bool update(const std::vector<Numeric>& x, const std::vector<Numeric>& y) {\n        assert(x.size() == y.size());\n        if(set_data_fct)\n        {\n            PyObject* xarray = detail::get_array(x);\n            PyObject* yarray = detail::get_array(y);\n\n            PyObject* plot_args = PyTuple_New(2);\n            PyTuple_SetItem(plot_args, 0, xarray);\n            PyTuple_SetItem(plot_args, 1, yarray);\n\n            PyObject* res = PyObject_CallObject(set_data_fct, plot_args);\n            if (res) Py_DECREF(res);\n            return res;\n        }\n        return false;\n    }\n\n    // clears the plot but keep it available\n    bool clear() {\n        return update(std::vector<double>(), std::vector<double>());\n    }\n\n    // definitely remove this line\n    void remove() {\n        if(line)\n        {\n            auto remove_fct = PyObject_GetAttrString(line,\"remove\");\n            PyObject* args = PyTuple_New(0);\n            PyObject* res = PyObject_CallObject(remove_fct, args);\n            if (res) Py_DECREF(res);\n        }\n        decref();\n    }\n\n    ~Plot() {\n        decref();\n    }\nprivate:\n\n    void decref() {\n        if(line)\n            Py_DECREF(line);\n        if(set_data_fct)\n            Py_DECREF(set_data_fct);\n    }\n\n\n    PyObject* line = nullptr;\n    PyObject* set_data_fct = nullptr;\n};\n\n} // end namespace matplotlibcpp\n"
        }
      ]
    }
  ]
}