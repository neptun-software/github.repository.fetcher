{
  "metadata": {
    "timestamp": 1736565828594,
    "page": 763,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ben-strasser/fast-cpp-csv-parser",
      "stars": 2188,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clusterfuzzlite",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.455078125,
          "content": "Copyright (c) 2015, ben-strasser\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of fast-cpp-csv-parser nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.6162109375,
          "content": "# Fast C++ CSV Parser\n\nThis is a small, easy-to-use and fast header-only library for reading comma separated value (CSV) files. \n\n## Features\n\n  * Automatically rearranges columns by parsing the header line.\n  * Disk I/O and CSV-parsing are overlapped using threads for efficiency.\n  * Parsing features such as escaped strings can be enabled and disabled at compile time using templates. You only pay in speed for the features you actually use.\n  * Can read multiple GB files in reasonable time.\n  * Support for custom columns separators (i.e. Tab separated value files are supported), quote escaped strings, automatic space trimming. \n  * Works with `*`nix and Windows newlines and automatically ignores UTF-8 BOMs.\n  * Exception classes with enough context to format useful error messages. what() returns error messages ready to be shown to a user. \n\n## Getting Started\n\nThe following small example should contain most of the syntax you need to use the library.\n\n```cpp\n# include \"csv.h\"\n\nint main(){\n  io::CSVReader<3> in(\"ram.csv\");\n  in.read_header(io::ignore_extra_column, \"vendor\", \"size\", \"speed\");\n  std::string vendor; int size; double speed;\n  while(in.read_row(vendor, size, speed)){\n    // do stuff with the data\n  }\n}\n```\n\n## Installation\n\nThe library only needs a standard conformant C++11 compiler. It has no further dependencies. The library is completely contained inside a single header file and therefore it is sufficient to copy this file to some place on your include path. The library does not have to be explicitly build. \n\nNote however, that threads are used and some compiler (for example GCC) require you to link against additional libraries to make it work. With GCC it is important to add -lpthread as the last item when linking, i.e. the order in \n\n```\ng++ -std=c++0x a.o b.o -o prog -lpthread\n```\n\nis important. If you for some reason do not want to use threads you can define CSV_IO_NO_THREAD before including the header.\n\nRemember that the library makes use of C++11 features and therefore you have to enable support for it (f.e. add -std=c++0x or -std=gnu++0x). \n\nThe library was developed and tested with GCC 4.6.1\n\n## Documentation\n\nThe library provides two classes:\n\n  * `LineReader`: A class to efficiently read large files line by line.\n  * `CSVReader`: A class that efficiently reads large CSV files.\n\nNote that everything is contained in the `io` namespace.\n\n### `LineReader`\n\n```cpp\nclass LineReader{\npublic:\n  // Constructors\n  LineReader(some_string_type file_name);\n  LineReader(some_string_type file_name, std::FILE*source);\n  LineReader(some_string_type file_name, std::istream&source);\n  LineReader(some_string_type file_name, std::unique_ptr<ByteSourceBase>source);\n\n  // Reading\n  char*next_line();\n\n  // File Location\n  // (These only affect the content of the error message)\n  void set_file_line(unsigned);\n  unsigned get_file_line()const;\n  void set_file_name(some_string_type file_name);\n  const char*get_truncated_file_name()const;\n};\n```\n\nThe constructor takes a file name and optionally a data source. If no data source is provided the function tries to open the file with the given name and throws an `error::can_not_open_file exception` on failure. If a data source is provided then the file name is only used to format error messages. In that case you can essentially put any string there. Using a string that describes the data source results in more informative error messages.\n\n`some_string_type` can be a `std::string` or a `char*`. If the data source is a `std::FILE*` then the library will take care of calling `std::fclose`. If it is a `std::istream` then the stream is not closed by the library. For best performance open the streams in binary mode. However using text mode also works. `ByteSourceBase` provides an interface that you can use to implement further data sources. \n\n```cpp\nclass ByteSourceBase{\npublic:\n  virtual int read(char*buffer, int size)=0;\n  virtual ~ByteSourceBase(){}\n};\n```\n\nThe read function should fill the provided buffer with at most `size` bytes from the data source. It should return the number of bytes actually written to the buffer. If data source has run out of bytes (because for example an end of file was reached) then the function should return 0. If a fatal error occurs then you can throw an exception. Note that the function can be called both from the main and the worker thread. However, it is guaranteed that they do not call the function at the same time.\n\nLines are read by calling the `next_line` function. It returns a pointer to a null terminated C-string that contains the line. If the end of file is reached a null pointer is returned. The newline character is not included in the string. You may modify the string as long as you do not write past the null terminator. The string stays valid until the destructor is called or until next_line is called again. Windows and `*`nix newlines are handled transparently. UTF-8 BOMs are automatically ignored and missing newlines at the end of the file are no problem.\n\n**Important:** There is a limit of 2^24-1 characters per line. If this limit is exceeded a `error::line_length_limit_exceeded` exception is thrown.\n\nLooping over all the lines in a file can be done in the following way.\n```cpp\nLineReader in(...);\nwhile(char*line = in.next_line()){\n  ...\n}\n```\n\nThe remaining functions are mainly used used to format error messages. The file line indicates the current position in the file, i.e., after the first `next_line` call it is 1 and after the second 2. Before the first call it is 0. The file name is truncated as internally C-strings are used to avoid `std::bad_alloc` exceptions during error reporting.\n\n**Note:** It is not possible to exchange the line termination character.\n\n### `CSVReader`\n\n`CSVReader` uses policies. These are classes with only static members to allow core functionality to be exchanged in an efficient way.\n\n```cpp\ntemplate<\n  unsigned column_count,\n  class trim_policy = trim_chars<' ', '\\t'>, \n  class quote_policy = no_quote_escape<','>,\n  class overflow_policy = throw_on_overflow,\n  class comment_policy = no_comment\n>\nclass CSVReader{\npublic:\n  // Constructors\n  // same as for LineReader\n\n  // Parsing Header\n  void read_header(ignore_column ignore_policy, some_string_type col_name1, some_string_type col_name2, ...);\n  void set_header(some_string_type col_name1, some_string_type col_name2, ...);\n  bool has_column(some_string_type col_name)const;\n\n  // Read\n  char*next_line();\n  bool read_row(ColType1&col1, ColType2&col2, ...);\n\n  // File Location \n  void set_file_line(unsigned);\n  unsigned get_file_line()const;\n  void set_file_name(some_string_type file_name);\n  const char*get_truncated_file_name()const;\n};\n```\n\nThe `column_count` template parameter indicates how many columns you want to read from the CSV file. This must not necessarily coincide with the actual number of columns in the file. The three policies govern various aspects of the parsing.\n\nThe trim policy indicates what characters should be ignored at the begin and the end of every column. The default ignores spaces and tabs. This makes sure that\n\n```\na,b,c\n1,2,3\n```\n\nis interpreted in the same way as\n\n```\n  a, b,   c\n1  , 2,   3\n```\n\nThe trim_chars can take any number of template parameters. For example `trim_chars<' ', '\\t', '_'> `is also valid. If no character should be trimmed use `trim_chars<>`.\n\nThe quote policy indicates how string should be escaped. It also specifies the column separator. The predefined policies are:\n\n  * `no_quote_escape<sep>` : Strings are not escaped. \"`sep`\" is used as column separator.\n  * `double_quote_escape<sep, quote>` : Strings are escaped using quotes. Quotes are escaped using two consecutive quotes. \"`sep`\" is used as column separator and \"`quote`\" as quoting character.\n\n**Important**: When combining trimming and quoting the rows are first trimmed and then unquoted. A consequence is that spaces inside the quotes will be conserved. If you want to get rid of spaces inside the quotes, you need to remove them yourself.\n\n**Important**: Quoting can be quite expensive. Disable it if you do not need it.\n\n**Important**: Quoted strings may not contain unescaped newlines. This is currently not supported.\n\nThe overflow policy indicates what should be done if the integers in the input are too large to fit into the variables. There following policies are predefined:\n\n  * `throw_on_overflow` : Throw an `error::integer_overflow` or `error::integer_underflow` exception.\n  * `ignore_overflow` : Do nothing and let the overflow happen.\n  * `set_to_max_on_overflow` : Set the value to `numeric_limits<...>::max()` (or to the min-pendant).\n\nThe comment policy allows to skip lines based on some criteria. Valid predefined policies are:\n\n  * `no_comment` : Do not ignore any line.\n  * `empty_line_comment` : Ignore all lines that are empty or only contains spaces and tabs. \n  * `single_line_comment<com1, com2, ...>` : Ignore all lines that start with com1 or com2 or ... as the first character. There may not be any space between the beginning of the line and the comment character. \n  * `single_and_empty_line_comment<com1, com2, ...>` : Ignore all empty lines and single line comments.\n\nExamples:\n\n  * `CSVReader<4, trim_chars<' '>, double_quote_escape<',','\\\"'> >` reads 4 columns from a normal CSV file with string escaping enabled.\n  * `CSVReader<3, trim_chars<' '>, no_quote_escape<'\\t'>, throw_on_overflow, single_line_comment<'#'> >` reads 3 columns from a tab separated file with string escaping disabled. Lines starting with a # are ignored.\n\nThe constructors and the file location functions are exactly the same as for `LineReader`. See its documentation for details.\n\nThere are three methods that deal with headers. The `read_header` methods reads a line from the file and rearranges the columns to match that order. It also checks whether all necessary columns are present. The `set_header` method does *not* read any input. Use it if the file does not have any header. Obviously it is impossible to rearrange columns or check for their availability when using it. The order in the file and in the program must match when using `set_header`. The `has_column` method checks whether a column is present in the file. The first argument of `read_header` is a bit field that determines how the function should react to column mismatches. The default behavior is to throw an `error::extra_column_in_header` exception if the file contains more columns than expected and an `error::missing_column_in_header` when there are not enough. This behavior can be altered using the following flags.\n\n  * `ignore_no_column`: The default behavior, no flags are set\n  * `ignore_extra_column`: If a column with a name is in the file but not in the argument list, then it is silently ignored.\n  * `ignore_missing_column`: If a column with a name is not in the file but is in the argument list, then `read_row` will not modify the corresponding variable. \n\nWhen using `ignore_missing_column` it is a good idea to initialize the variables passed to `read_row` with a default value, for example:\n\n```cpp\n// The file only contains column \"a\"\nCSVReader<2>in(...);\nin.read_header(ignore_missing_column, \"a\", \"b\");\nint a,b = 42;\nwhile(in.read_row(a,b)){\n  // a contains the value from the file\n  // b is left unchanged by read_row, i.e., it is 42\n}\n```\n\nIf only some columns are optional or their default value depends on other columns you have to use `has_column`, for example:\n\n```cpp\n// The file only contains the columns \"a\" and \"b\"\nCSVReader<3>in(...);\nin.read_header(ignore_missing_column, \"a\", \"b\", \"sum\");\nif(!in.has_column(\"a\") || !in.has_column(\"b\"))\n  throw my_neat_error_class();\nbool has_sum = in.has_column(\"sum\");\nint a,b,sum;\nwhile(in.read_row(a,b,sum)){\n  if(!has_sum)\n    sum = a+b;\n}\n```\n\n**Important**: Do not call `has_column` from within the read-loop. It would work correctly but significantly slowdown processing.\n\nIf two columns have the same name an error::duplicated_column_in_header exception is thrown. If `read_header` is called but the file is empty a `error::header_missing` exception is thrown.\n\nThe `next_line` functions reads a line without parsing it. It works analogous to `LineReader::next_line`. This can be used to skip broken lines in a CSV file. However, in nearly all applications you will want to use the `read_row` function.\n\nThe `read_row` function reads a line, splits it into the columns and arranges them correctly. It trims the entries and unescapes them. If requested the content is interpreted as integer or as floating point. The variables passed to read_row may be of the following types.\n\n  * builtin signed integer: These are `signed char`, `short`, `int`, `long` and `long long`. The input must be encoded as a base 10 ASCII number optionally preceded by a + or -. The function detects whether the integer is too large would overflow (or underflow) and behaves as indicated by overflow_policy.\n  * builtin unsigned integer: Just as the signed counterparts except that a leading + or - is not allowed.\n  * builtin floating point: These are `float`, `double` and `long double`. The input may have a leading + or -. The number must be base 10 encoded. The decimal point may either be a dot or a comma. (Note that a comma will only work if it is not also used as column separator or the number is escaped.) A base 10 exponent may be specified using the \"1e10\" syntax. The \"e\" may be lower- or uppercase. Examples for valid floating points are \"1\", \"-42.42\" and \"+123.456E789\". The input is rounded to the next floating point or infinity if it is too large or small.\n  * `char`: The column content must be a single character.\n  * `std::string`: The column content is assigned to the string. The std::string is filled with the trimmed and unescaped version.\n  * `char*`: A pointer directly into the buffer. The string is trimmed and unescaped and null terminated. This pointer stays valid until read_row is called again or the CSVReader is destroyed. Use this for user defined types. \n\nNote that there is no inherent overhead to using `char*` and then interpreting it compared to using one of the parsers directly build into `CSVReader`. The builtin number parsers are pure convenience. If you need a slightly different syntax then use `char*` and do the parsing yourself.\n\n## FAQ\n\nQ: The library is throwing a std::system_error with code -1. How to get it to work?\n\nA: Your compiler's std::thread implementation is broken. Define CSV\\_IO\\_NO\\_THREAD to disable threading support.\n\n\nQ: My values are not just ints or strings. I want to parse my customized type. Is this possible?\n\nA: Read a `char*` and parse the string. At first this seems expensive but it is not as the pointer you get points directly into the memory buffer. In fact there is no inherent reason why a custom int-parser realized this way must be any slower than the int-parser build into the library. By reading a `char*` the library takes care of column reordering and quote escaping and leaves the actual parsing to you. Note that using a std::string is slower as it involves a memory copy.\n\n\nQ: I get lots of compiler errors when compiling the header! Please fix it. :(\n\nA: Have you enabled the C++11 mode of your compiler? If you use GCC you have to add -std=c++0x to the command line. If this does not resolve the problem, then please open a ticket.\n\n\nQ: The library crashes when parsing large files! Please fix it. :(\n\nA: When using GCC have you linked against -lpthread? Read the installation section for details on how to do this. If this does not resolve the issue then please open a ticket. (The reason why it only crashes only on large files is that the first chuck is read synchronous and if the whole file fits into this chuck then no asynchronous call is performed.) Alternatively you can define CSV\\_IO\\_NO\\_THREAD.\n\n\nQ: Does the library support UTF?\n\nA: The library has basic UTF-8 support, or to be more precise it does not break when passing UTF-8 strings through it. If you read a `char*` then you get a pointer to the UTF-8 string. You will have to decode the string on your own. The separator, quoting, and commenting characters used by the library can only be ASCII characters.\n\n\nQ: Does the library support string fields that span multiple lines?\n\nA: No. This feature has been often requested in the past, however, it is difficult to make it work with the current design without breaking something else.\n\n\nQ: Can this library handle a variable number of columns?\n\nA: You can read a compile-time known constant number of columns from a file with a variable number of columns. Which columns will be read depends on the strings in the header line. There is no way to read a variable number of columns. You can think of the provided functionality as a SQL `select col1,col2,col3 from my_file.csv` statement and the CSV file as table. You can change the number of columns in the table without affecting the result of the select as long as the queried columns remain.\n"
        },
        {
          "name": "csv.h",
          "type": "blob",
          "size": 34.5986328125,
          "content": "// Copyright: (2012-2015) Ben Strasser <code@ben-strasser.net>\n// License: BSD-3\n//\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n//    this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its contributors\n//    may be used to endorse or promote products derived from this software\n//    without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\n#ifndef CSV_H\n#define CSV_H\n\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <exception>\n#include <string>\n#include <utility>\n#include <vector>\n#ifndef CSV_IO_NO_THREAD\n#include <condition_variable>\n#include <mutex>\n#include <thread>\n#endif\n#include <cassert>\n#include <cerrno>\n#include <istream>\n#include <limits>\n#include <memory>\n\nnamespace io {\n////////////////////////////////////////////////////////////////////////////\n//                                 LineReader                             //\n////////////////////////////////////////////////////////////////////////////\n\nnamespace error {\nstruct base : std::exception {\n  virtual void format_error_message() const = 0;\n\n  const char *what() const noexcept override {\n    format_error_message();\n    return error_message_buffer;\n  }\n\n  mutable char error_message_buffer[2048];\n};\n\n// this only affects the file name in the error message\nconst int max_file_name_length = 1024;\n\nstruct with_file_name {\n  with_file_name() { std::memset(file_name, 0, sizeof(file_name)); }\n\n  void set_file_name(const char *file_name) {\n    if (file_name != nullptr) {\n      // This call to strncpy has parenthesis around it\n      // to silence the GCC -Wstringop-truncation warning\n      (strncpy(this->file_name, file_name, sizeof(this->file_name)));\n      this->file_name[sizeof(this->file_name) - 1] = '\\0';\n    } else {\n      this->file_name[0] = '\\0';\n    }\n  }\n\n  char file_name[max_file_name_length + 1];\n};\n\nstruct with_file_line {\n  with_file_line() { file_line = -1; }\n\n  void set_file_line(int file_line) { this->file_line = file_line; }\n\n  int file_line;\n};\n\nstruct with_errno {\n  with_errno() { errno_value = 0; }\n\n  void set_errno(int errno_value) { this->errno_value = errno_value; }\n\n  int errno_value;\n};\n\nstruct can_not_open_file : base, with_file_name, with_errno {\n  void format_error_message() const override {\n    if (errno_value != 0)\n      std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n                    \"Can not open file \\\"%s\\\" because \\\"%s\\\".\", file_name,\n                    std::strerror(errno_value));\n    else\n      std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n                    \"Can not open file \\\"%s\\\".\", file_name);\n  }\n};\n\nstruct line_length_limit_exceeded : base, with_file_name, with_file_line {\n  void format_error_message() const override {\n    std::snprintf(\n        error_message_buffer, sizeof(error_message_buffer),\n        \"Line number %d in file \\\"%s\\\" exceeds the maximum length of 2^24-1.\",\n        file_line, file_name);\n  }\n};\n} // namespace error\n\nclass ByteSourceBase {\npublic:\n  virtual int read(char *buffer, int size) = 0;\n  virtual ~ByteSourceBase() {}\n};\n\nnamespace detail {\n\nclass OwningStdIOByteSourceBase : public ByteSourceBase {\npublic:\n  explicit OwningStdIOByteSourceBase(FILE *file) : file(file) {\n    // Tell the std library that we want to do the buffering ourself.\n    std::setvbuf(file, 0, _IONBF, 0);\n  }\n\n  int read(char *buffer, int size) { return std::fread(buffer, 1, size, file); }\n\n  ~OwningStdIOByteSourceBase() { std::fclose(file); }\n\nprivate:\n  FILE *file;\n};\n\nclass NonOwningIStreamByteSource : public ByteSourceBase {\npublic:\n  explicit NonOwningIStreamByteSource(std::istream &in) : in(in) {}\n\n  int read(char *buffer, int size) {\n    in.read(buffer, size);\n    return in.gcount();\n  }\n\n  ~NonOwningIStreamByteSource() {}\n\nprivate:\n  std::istream &in;\n};\n\nclass NonOwningStringByteSource : public ByteSourceBase {\npublic:\n  NonOwningStringByteSource(const char *str, long long size)\n      : str(str), remaining_byte_count(size) {}\n\n  int read(char *buffer, int desired_byte_count) {\n    int to_copy_byte_count = desired_byte_count;\n    if (remaining_byte_count < to_copy_byte_count)\n      to_copy_byte_count = remaining_byte_count;\n    std::memcpy(buffer, str, to_copy_byte_count);\n    remaining_byte_count -= to_copy_byte_count;\n    str += to_copy_byte_count;\n    return to_copy_byte_count;\n  }\n\n  ~NonOwningStringByteSource() {}\n\nprivate:\n  const char *str;\n  long long remaining_byte_count;\n};\n\n#ifndef CSV_IO_NO_THREAD\nclass AsynchronousReader {\npublic:\n  void init(std::unique_ptr<ByteSourceBase> arg_byte_source) {\n    std::unique_lock<std::mutex> guard(lock);\n    byte_source = std::move(arg_byte_source);\n    desired_byte_count = -1;\n    termination_requested = false;\n    worker = std::thread([&] {\n      std::unique_lock<std::mutex> guard(lock);\n      try {\n        for (;;) {\n          read_requested_condition.wait(guard, [&] {\n            return desired_byte_count != -1 || termination_requested;\n          });\n          if (termination_requested)\n            return;\n\n          read_byte_count = byte_source->read(buffer, desired_byte_count);\n          desired_byte_count = -1;\n          if (read_byte_count == 0)\n            break;\n          read_finished_condition.notify_one();\n        }\n      } catch (...) {\n        read_error = std::current_exception();\n      }\n      read_finished_condition.notify_one();\n    });\n  }\n\n  bool is_valid() const { return byte_source != nullptr; }\n\n  void start_read(char *arg_buffer, int arg_desired_byte_count) {\n    std::unique_lock<std::mutex> guard(lock);\n    buffer = arg_buffer;\n    desired_byte_count = arg_desired_byte_count;\n    read_byte_count = -1;\n    read_requested_condition.notify_one();\n  }\n\n  int finish_read() {\n    std::unique_lock<std::mutex> guard(lock);\n    read_finished_condition.wait(\n        guard, [&] { return read_byte_count != -1 || read_error; });\n    if (read_error)\n      std::rethrow_exception(read_error);\n    else\n      return read_byte_count;\n  }\n\n  ~AsynchronousReader() {\n    if (byte_source != nullptr) {\n      {\n        std::unique_lock<std::mutex> guard(lock);\n        termination_requested = true;\n      }\n      read_requested_condition.notify_one();\n      worker.join();\n    }\n  }\n\nprivate:\n  std::unique_ptr<ByteSourceBase> byte_source;\n\n  std::thread worker;\n\n  bool termination_requested;\n  std::exception_ptr read_error;\n  char *buffer;\n  int desired_byte_count;\n  int read_byte_count;\n\n  std::mutex lock;\n  std::condition_variable read_finished_condition;\n  std::condition_variable read_requested_condition;\n};\n#endif\n\nclass SynchronousReader {\npublic:\n  void init(std::unique_ptr<ByteSourceBase> arg_byte_source) {\n    byte_source = std::move(arg_byte_source);\n  }\n\n  bool is_valid() const { return byte_source != nullptr; }\n\n  void start_read(char *arg_buffer, int arg_desired_byte_count) {\n    buffer = arg_buffer;\n    desired_byte_count = arg_desired_byte_count;\n  }\n\n  int finish_read() { return byte_source->read(buffer, desired_byte_count); }\n\nprivate:\n  std::unique_ptr<ByteSourceBase> byte_source;\n  char *buffer;\n  int desired_byte_count;\n};\n} // namespace detail\n\nclass LineReader {\nprivate:\n  static const int block_len = 1 << 20;\n  std::unique_ptr<char[]> buffer; // must be constructed before (and thus\n                                  // destructed after) the reader!\n#ifdef CSV_IO_NO_THREAD\n  detail::SynchronousReader reader;\n#else\n  detail::AsynchronousReader reader;\n#endif\n  int data_begin;\n  int data_end;\n\n  char file_name[error::max_file_name_length + 1];\n  unsigned file_line;\n\n  static std::unique_ptr<ByteSourceBase> open_file(const char *file_name) {\n    // We open the file in binary mode as it makes no difference under *nix\n    // and under Windows we handle \\r\\n newlines ourself.\n    FILE *file = std::fopen(file_name, \"rb\");\n    if (file == 0) {\n      int x = errno; // store errno as soon as possible, doing it after\n                     // constructor call can fail.\n      error::can_not_open_file err;\n      err.set_errno(x);\n      err.set_file_name(file_name);\n      throw err;\n    }\n    return std::unique_ptr<ByteSourceBase>(\n        new detail::OwningStdIOByteSourceBase(file));\n  }\n\n  void init(std::unique_ptr<ByteSourceBase> byte_source) {\n    file_line = 0;\n\n    buffer = std::unique_ptr<char[]>(new char[3 * block_len]);\n    data_begin = 0;\n    data_end = byte_source->read(buffer.get(), 2 * block_len);\n\n    // Ignore UTF-8 BOM\n    if (data_end >= 3 && buffer[0] == '\\xEF' && buffer[1] == '\\xBB' &&\n        buffer[2] == '\\xBF')\n      data_begin = 3;\n\n    if (data_end == 2 * block_len) {\n      reader.init(std::move(byte_source));\n      reader.start_read(buffer.get() + 2 * block_len, block_len);\n    }\n  }\n\npublic:\n  LineReader() = delete;\n  LineReader(const LineReader &) = delete;\n  LineReader &operator=(const LineReader &) = delete;\n\n  explicit LineReader(const char *file_name) {\n    set_file_name(file_name);\n    init(open_file(file_name));\n  }\n\n  explicit LineReader(const std::string &file_name) {\n    set_file_name(file_name.c_str());\n    init(open_file(file_name.c_str()));\n  }\n\n  LineReader(const char *file_name,\n             std::unique_ptr<ByteSourceBase> byte_source) {\n    set_file_name(file_name);\n    init(std::move(byte_source));\n  }\n\n  LineReader(const std::string &file_name,\n             std::unique_ptr<ByteSourceBase> byte_source) {\n    set_file_name(file_name.c_str());\n    init(std::move(byte_source));\n  }\n\n  LineReader(const char *file_name, const char *data_begin,\n             const char *data_end) {\n    set_file_name(file_name);\n    init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningStringByteSource(\n        data_begin, data_end - data_begin)));\n  }\n\n  LineReader(const std::string &file_name, const char *data_begin,\n             const char *data_end) {\n    set_file_name(file_name.c_str());\n    init(std::unique_ptr<ByteSourceBase>(new detail::NonOwningStringByteSource(\n        data_begin, data_end - data_begin)));\n  }\n\n  LineReader(const char *file_name, FILE *file) {\n    set_file_name(file_name);\n    init(std::unique_ptr<ByteSourceBase>(\n        new detail::OwningStdIOByteSourceBase(file)));\n  }\n\n  LineReader(const std::string &file_name, FILE *file) {\n    set_file_name(file_name.c_str());\n    init(std::unique_ptr<ByteSourceBase>(\n        new detail::OwningStdIOByteSourceBase(file)));\n  }\n\n  LineReader(const char *file_name, std::istream &in) {\n    set_file_name(file_name);\n    init(std::unique_ptr<ByteSourceBase>(\n        new detail::NonOwningIStreamByteSource(in)));\n  }\n\n  LineReader(const std::string &file_name, std::istream &in) {\n    set_file_name(file_name.c_str());\n    init(std::unique_ptr<ByteSourceBase>(\n        new detail::NonOwningIStreamByteSource(in)));\n  }\n\n  void set_file_name(const std::string &file_name) {\n    set_file_name(file_name.c_str());\n  }\n\n  void set_file_name(const char *file_name) {\n    if (file_name != nullptr) {\n      strncpy(this->file_name, file_name, sizeof(this->file_name));\n      this->file_name[sizeof(this->file_name) - 1] = '\\0';\n    } else {\n      this->file_name[0] = '\\0';\n    }\n  }\n\n  const char *get_truncated_file_name() const { return file_name; }\n\n  void set_file_line(unsigned file_line) { this->file_line = file_line; }\n\n  unsigned get_file_line() const { return file_line; }\n\n  char *next_line() {\n    if (data_begin == data_end)\n      return nullptr;\n\n    ++file_line;\n\n    assert(data_begin < data_end);\n    assert(data_end <= block_len * 2);\n\n    if (data_begin >= block_len) {\n      std::memcpy(buffer.get(), buffer.get() + block_len, block_len);\n      data_begin -= block_len;\n      data_end -= block_len;\n      if (reader.is_valid()) {\n        data_end += reader.finish_read();\n        std::memcpy(buffer.get() + block_len, buffer.get() + 2 * block_len,\n                    block_len);\n        reader.start_read(buffer.get() + 2 * block_len, block_len);\n      }\n    }\n\n    int line_end = data_begin;\n    while (line_end != data_end && buffer[line_end] != '\\n') {\n      ++line_end;\n    }\n\n    if (line_end - data_begin + 1 > block_len) {\n      error::line_length_limit_exceeded err;\n      err.set_file_name(file_name);\n      err.set_file_line(file_line);\n      throw err;\n    }\n\n    if (line_end != data_end && buffer[line_end] == '\\n') {\n      buffer[line_end] = '\\0';\n    } else {\n      // some files are missing the newline at the end of the\n      // last line\n      ++data_end;\n      buffer[line_end] = '\\0';\n    }\n\n    // handle windows \\r\\n-line breaks\n    if (line_end != data_begin && buffer[line_end - 1] == '\\r')\n      buffer[line_end - 1] = '\\0';\n\n    char *ret = buffer.get() + data_begin;\n    data_begin = line_end + 1;\n    return ret;\n  }\n};\n\n////////////////////////////////////////////////////////////////////////////\n//                                 CSV                                    //\n////////////////////////////////////////////////////////////////////////////\n\nnamespace error {\nconst int max_column_name_length = 63;\nstruct with_column_name {\n  with_column_name() {\n    std::memset(column_name, 0, max_column_name_length + 1);\n  }\n\n  void set_column_name(const char *column_name) {\n    if (column_name != nullptr) {\n      std::strncpy(this->column_name, column_name, max_column_name_length);\n      this->column_name[max_column_name_length] = '\\0';\n    } else {\n      this->column_name[0] = '\\0';\n    }\n  }\n\n  char column_name[max_column_name_length + 1];\n};\n\nconst int max_column_content_length = 63;\n\nstruct with_column_content {\n  with_column_content() {\n    std::memset(column_content, 0, max_column_content_length + 1);\n  }\n\n  void set_column_content(const char *column_content) {\n    if (column_content != nullptr) {\n      std::strncpy(this->column_content, column_content,\n                   max_column_content_length);\n      this->column_content[max_column_content_length] = '\\0';\n    } else {\n      this->column_content[0] = '\\0';\n    }\n  }\n\n  char column_content[max_column_content_length + 1];\n};\n\nstruct extra_column_in_header : base, with_file_name, with_column_name {\n  void format_error_message() const override {\n    std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n                  R\"(Extra column \"%s\" in header of file \"%s\".)\", column_name,\n                  file_name);\n  }\n};\n\nstruct missing_column_in_header : base, with_file_name, with_column_name {\n  void format_error_message() const override {\n    std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n                  R\"(Missing column \"%s\" in header of file \"%s\".)\", column_name,\n                  file_name);\n  }\n};\n\nstruct duplicated_column_in_header : base, with_file_name, with_column_name {\n  void format_error_message() const override {\n    std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n                  R\"(Duplicated column \"%s\" in header of file \"%s\".)\",\n                  column_name, file_name);\n  }\n};\n\nstruct header_missing : base, with_file_name {\n  void format_error_message() const override {\n    std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n                  \"Header missing in file \\\"%s\\\".\", file_name);\n  }\n};\n\nstruct too_few_columns : base, with_file_name, with_file_line {\n  void format_error_message() const override {\n    std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n                  \"Too few columns in line %d in file \\\"%s\\\".\", file_line,\n                  file_name);\n  }\n};\n\nstruct too_many_columns : base, with_file_name, with_file_line {\n  void format_error_message() const override {\n    std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n                  \"Too many columns in line %d in file \\\"%s\\\".\", file_line,\n                  file_name);\n  }\n};\n\nstruct escaped_string_not_closed : base, with_file_name, with_file_line {\n  void format_error_message() const override {\n    std::snprintf(error_message_buffer, sizeof(error_message_buffer),\n                  \"Escaped string was not closed in line %d in file \\\"%s\\\".\",\n                  file_line, file_name);\n  }\n};\n\nstruct integer_must_be_positive : base,\n                                  with_file_name,\n                                  with_file_line,\n                                  with_column_name,\n                                  with_column_content {\n  void format_error_message() const override {\n    std::snprintf(\n        error_message_buffer, sizeof(error_message_buffer),\n        R\"(The integer \"%s\" must be positive or 0 in column \"%s\" in file \"%s\" in line \"%d\".)\",\n        column_content, column_name, file_name, file_line);\n  }\n};\n\nstruct no_digit : base,\n                  with_file_name,\n                  with_file_line,\n                  with_column_name,\n                  with_column_content {\n  void format_error_message() const override {\n    std::snprintf(\n        error_message_buffer, sizeof(error_message_buffer),\n        R\"(The integer \"%s\" contains an invalid digit in column \"%s\" in file \"%s\" in line \"%d\".)\",\n        column_content, column_name, file_name, file_line);\n  }\n};\n\nstruct integer_overflow : base,\n                          with_file_name,\n                          with_file_line,\n                          with_column_name,\n                          with_column_content {\n  void format_error_message() const override {\n    std::snprintf(\n        error_message_buffer, sizeof(error_message_buffer),\n        R\"(The integer \"%s\" overflows in column \"%s\" in file \"%s\" in line \"%d\".)\",\n        column_content, column_name, file_name, file_line);\n  }\n};\n\nstruct integer_underflow : base,\n                           with_file_name,\n                           with_file_line,\n                           with_column_name,\n                           with_column_content {\n  void format_error_message() const override {\n    std::snprintf(\n        error_message_buffer, sizeof(error_message_buffer),\n        R\"(The integer \"%s\" underflows in column \"%s\" in file \"%s\" in line \"%d\".)\",\n        column_content, column_name, file_name, file_line);\n  }\n};\n\nstruct invalid_single_character : base,\n                                  with_file_name,\n                                  with_file_line,\n                                  with_column_name,\n                                  with_column_content {\n  void format_error_message() const override {\n    std::snprintf(\n        error_message_buffer, sizeof(error_message_buffer),\n        R\"(The content \"%s\" of column \"%s\" in file \"%s\" in line \"%d\" is not a single character.)\",\n        column_content, column_name, file_name, file_line);\n  }\n};\n} // namespace error\n\nusing ignore_column = unsigned int;\nstatic const ignore_column ignore_no_column = 0;\nstatic const ignore_column ignore_extra_column = 1;\nstatic const ignore_column ignore_missing_column = 2;\n\ntemplate <char... trim_char_list> struct trim_chars {\nprivate:\n  constexpr static bool is_trim_char(char) { return false; }\n\n  template <class... OtherTrimChars>\n  constexpr static bool is_trim_char(char c, char trim_char,\n                                     OtherTrimChars... other_trim_chars) {\n    return c == trim_char || is_trim_char(c, other_trim_chars...);\n  }\n\npublic:\n  static void trim(char *&str_begin, char *&str_end) {\n    while (str_begin != str_end && is_trim_char(*str_begin, trim_char_list...))\n      ++str_begin;\n    while (str_begin != str_end &&\n           is_trim_char(*(str_end - 1), trim_char_list...))\n      --str_end;\n    *str_end = '\\0';\n  }\n};\n\nstruct no_comment {\n  static bool is_comment(const char *) { return false; }\n};\n\ntemplate <char... comment_start_char_list> struct single_line_comment {\nprivate:\n  constexpr static bool is_comment_start_char(char) { return false; }\n\n  template <class... OtherCommentStartChars>\n  constexpr static bool\n  is_comment_start_char(char c, char comment_start_char,\n                        OtherCommentStartChars... other_comment_start_chars) {\n    return c == comment_start_char ||\n           is_comment_start_char(c, other_comment_start_chars...);\n  }\n\npublic:\n  static bool is_comment(const char *line) {\n    return is_comment_start_char(*line, comment_start_char_list...);\n  }\n};\n\nstruct empty_line_comment {\n  static bool is_comment(const char *line) {\n    if (*line == '\\0')\n      return true;\n    while (*line == ' ' || *line == '\\t') {\n      ++line;\n      if (*line == 0)\n        return true;\n    }\n    return false;\n  }\n};\n\ntemplate <char... comment_start_char_list>\nstruct single_and_empty_line_comment {\n  static bool is_comment(const char *line) {\n    return single_line_comment<comment_start_char_list...>::is_comment(line) ||\n           empty_line_comment::is_comment(line);\n  }\n};\n\ntemplate <char sep> struct no_quote_escape {\n  static const char *find_next_column_end(const char *col_begin) {\n    while (*col_begin != sep && *col_begin != '\\0')\n      ++col_begin;\n    return col_begin;\n  }\n\n  static void unescape(char *&, char *&) {}\n};\n\ntemplate <char sep, char quote> struct double_quote_escape {\n  static const char *find_next_column_end(const char *col_begin) {\n    while (*col_begin != sep && *col_begin != '\\0')\n      if (*col_begin != quote)\n        ++col_begin;\n      else {\n        do {\n          ++col_begin;\n          while (*col_begin != quote) {\n            if (*col_begin == '\\0')\n              throw error::escaped_string_not_closed();\n            ++col_begin;\n          }\n          ++col_begin;\n        } while (*col_begin == quote);\n      }\n    return col_begin;\n  }\n\n  static void unescape(char *&col_begin, char *&col_end) {\n    if (col_end - col_begin >= 2) {\n      if (*col_begin == quote && *(col_end - 1) == quote) {\n        ++col_begin;\n        --col_end;\n        char *out = col_begin;\n        for (char *in = col_begin; in != col_end; ++in) {\n          if (*in == quote && (in + 1) != col_end && *(in + 1) == quote) {\n            ++in;\n          }\n          *out = *in;\n          ++out;\n        }\n        col_end = out;\n        *col_end = '\\0';\n      }\n    }\n  }\n};\n\nstruct throw_on_overflow {\n  template <class T> static void on_overflow(T &) {\n    throw error::integer_overflow();\n  }\n\n  template <class T> static void on_underflow(T &) {\n    throw error::integer_underflow();\n  }\n};\n\nstruct ignore_overflow {\n  template <class T> static void on_overflow(T &) {}\n\n  template <class T> static void on_underflow(T &) {}\n};\n\nstruct set_to_max_on_overflow {\n  template <class T> static void on_overflow(T &x) {\n    // using (std::numeric_limits<T>::max) instead of\n    // std::numeric_limits<T>::max to make code including windows.h with its max\n    // macro happy\n    x = (std::numeric_limits<T>::max)();\n  }\n\n  template <class T> static void on_underflow(T &x) {\n    x = (std::numeric_limits<T>::min)();\n  }\n};\n\nnamespace detail {\ntemplate <class quote_policy>\nvoid chop_next_column(char *&line, char *&col_begin, char *&col_end) {\n  assert(line != nullptr);\n\n  col_begin = line;\n  // the col_begin + (... - col_begin) removes the constness\n  col_end =\n      col_begin + (quote_policy::find_next_column_end(col_begin) - col_begin);\n\n  if (*col_end == '\\0') {\n    line = nullptr;\n  } else {\n    *col_end = '\\0';\n    line = col_end + 1;\n  }\n}\n\ntemplate <class trim_policy, class quote_policy>\nvoid parse_line(char *line, char **sorted_col,\n                const std::vector<int> &col_order) {\n  for (int i : col_order) {\n    if (line == nullptr)\n      throw ::io::error::too_few_columns();\n    char *col_begin, *col_end;\n    chop_next_column<quote_policy>(line, col_begin, col_end);\n\n    if (i != -1) {\n      trim_policy::trim(col_begin, col_end);\n      quote_policy::unescape(col_begin, col_end);\n\n      sorted_col[i] = col_begin;\n    }\n  }\n  if (line != nullptr)\n    throw ::io::error::too_many_columns();\n}\n\ntemplate <unsigned column_count, class trim_policy, class quote_policy>\nvoid parse_header_line(char *line, std::vector<int> &col_order,\n                       const std::string *col_name,\n                       ignore_column ignore_policy) {\n  col_order.clear();\n\n  bool found[column_count];\n  std::fill(found, found + column_count, false);\n  while (line) {\n    char *col_begin, *col_end;\n    chop_next_column<quote_policy>(line, col_begin, col_end);\n\n    trim_policy::trim(col_begin, col_end);\n    quote_policy::unescape(col_begin, col_end);\n\n    for (unsigned i = 0; i < column_count; ++i)\n      if (col_begin == col_name[i]) {\n        if (found[i]) {\n          error::duplicated_column_in_header err;\n          err.set_column_name(col_begin);\n          throw err;\n        }\n        found[i] = true;\n        col_order.push_back(i);\n        col_begin = 0;\n        break;\n      }\n    if (col_begin) {\n      if (ignore_policy & ::io::ignore_extra_column)\n        col_order.push_back(-1);\n      else {\n        error::extra_column_in_header err;\n        err.set_column_name(col_begin);\n        throw err;\n      }\n    }\n  }\n  if (!(ignore_policy & ::io::ignore_missing_column)) {\n    for (unsigned i = 0; i < column_count; ++i) {\n      if (!found[i]) {\n        error::missing_column_in_header err;\n        err.set_column_name(col_name[i].c_str());\n        throw err;\n      }\n    }\n  }\n}\n\ntemplate <class overflow_policy> void parse(char *col, char &x) {\n  if (!*col)\n    throw error::invalid_single_character();\n  x = *col;\n  ++col;\n  if (*col)\n    throw error::invalid_single_character();\n}\n\ntemplate <class overflow_policy> void parse(char *col, std::string &x) {\n  x = col;\n}\n\ntemplate <class overflow_policy> void parse(char *col, const char *&x) {\n  x = col;\n}\n\ntemplate <class overflow_policy> void parse(char *col, char *&x) { x = col; }\n\ntemplate <class overflow_policy, class T>\nvoid parse_unsigned_integer(const char *col, T &x) {\n  x = 0;\n  while (*col != '\\0') {\n    if ('0' <= *col && *col <= '9') {\n      T y = *col - '0';\n      if (x > ((std::numeric_limits<T>::max)() - y) / 10) {\n        overflow_policy::on_overflow(x);\n        return;\n      }\n      x = 10 * x + y;\n    } else\n      throw error::no_digit();\n    ++col;\n  }\n}\n\ntemplate <class overflow_policy> void parse(char *col, unsigned char &x) {\n  parse_unsigned_integer<overflow_policy>(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, unsigned short &x) {\n  parse_unsigned_integer<overflow_policy>(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, unsigned int &x) {\n  parse_unsigned_integer<overflow_policy>(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, unsigned long &x) {\n  parse_unsigned_integer<overflow_policy>(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, unsigned long long &x) {\n  parse_unsigned_integer<overflow_policy>(col, x);\n}\n\ntemplate <class overflow_policy, class T>\nvoid parse_signed_integer(const char *col, T &x) {\n  if (*col == '-') {\n    ++col;\n\n    x = 0;\n    while (*col != '\\0') {\n      if ('0' <= *col && *col <= '9') {\n        T y = *col - '0';\n        if (x < ((std::numeric_limits<T>::min)() + y) / 10) {\n          overflow_policy::on_underflow(x);\n          return;\n        }\n        x = 10 * x - y;\n      } else\n        throw error::no_digit();\n      ++col;\n    }\n    return;\n  } else if (*col == '+')\n    ++col;\n  parse_unsigned_integer<overflow_policy>(col, x);\n}\n\ntemplate <class overflow_policy> void parse(char *col, signed char &x) {\n  parse_signed_integer<overflow_policy>(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, signed short &x) {\n  parse_signed_integer<overflow_policy>(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, signed int &x) {\n  parse_signed_integer<overflow_policy>(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, signed long &x) {\n  parse_signed_integer<overflow_policy>(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, signed long long &x) {\n  parse_signed_integer<overflow_policy>(col, x);\n}\n\ntemplate <class T> void parse_float(const char *col, T &x) {\n  bool is_neg = false;\n  if (*col == '-') {\n    is_neg = true;\n    ++col;\n  } else if (*col == '+')\n    ++col;\n\n  x = 0;\n  while ('0' <= *col && *col <= '9') {\n    int y = *col - '0';\n    x *= 10;\n    x += y;\n    ++col;\n  }\n\n  if (*col == '.' || *col == ',') {\n    ++col;\n    T pos = 1;\n    while ('0' <= *col && *col <= '9') {\n      pos /= 10;\n      int y = *col - '0';\n      ++col;\n      x += y * pos;\n    }\n  }\n\n  if (*col == 'e' || *col == 'E') {\n    ++col;\n    int e;\n\n    parse_signed_integer<set_to_max_on_overflow>(col, e);\n\n    if (e != 0) {\n      T base;\n      if (e < 0) {\n        base = T(0.1);\n        e = -e;\n      } else {\n        base = T(10);\n      }\n\n      while (e != 1) {\n        if ((e & 1) == 0) {\n          base = base * base;\n          e >>= 1;\n        } else {\n          x *= base;\n          --e;\n        }\n      }\n      x *= base;\n    }\n  } else {\n    if (*col != '\\0')\n      throw error::no_digit();\n  }\n\n  if (is_neg)\n    x = -x;\n}\n\ntemplate <class overflow_policy> void parse(char *col, float &x) {\n  parse_float(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, double &x) {\n  parse_float(col, x);\n}\ntemplate <class overflow_policy> void parse(char *col, long double &x) {\n  parse_float(col, x);\n}\n\ntemplate <class overflow_policy, class T> void parse(char *col, T &x) {\n  // Mute unused variable compiler warning\n  (void)col;\n  (void)x;\n  // GCC evaluates \"false\" when reading the template and\n  // \"sizeof(T)!=sizeof(T)\" only when instantiating it. This is why\n  // this strange construct is used.\n  static_assert(sizeof(T) != sizeof(T),\n                \"Can not parse this type. Only builtin integrals, floats, \"\n                \"char, char*, const char* and std::string are supported\");\n}\n\n} // namespace detail\n\ntemplate <unsigned column_count, class trim_policy = trim_chars<' ', '\\t'>,\n          class quote_policy = no_quote_escape<','>,\n          class overflow_policy = throw_on_overflow,\n          class comment_policy = no_comment>\nclass CSVReader {\nprivate:\n  LineReader in;\n\n  char *row[column_count];\n  std::string column_names[column_count];\n\n  std::vector<int> col_order;\n\n  template <class... ColNames>\n  void set_column_names(std::string s, ColNames... cols) {\n    column_names[column_count - sizeof...(ColNames) - 1] = std::move(s);\n    set_column_names(std::forward<ColNames>(cols)...);\n  }\n\n  void set_column_names() {}\n\npublic:\n  CSVReader() = delete;\n  CSVReader(const CSVReader &) = delete;\n  CSVReader &operator=(const CSVReader &);\n\n  template <class... Args>\n  explicit CSVReader(Args &&... args) : in(std::forward<Args>(args)...) {\n    std::fill(row, row + column_count, nullptr);\n    col_order.resize(column_count);\n    for (unsigned i = 0; i < column_count; ++i)\n      col_order[i] = i;\n    for (unsigned i = 1; i <= column_count; ++i)\n      column_names[i - 1] = \"col\" + std::to_string(i);\n  }\n\n  char *next_line() { return in.next_line(); }\n\n  template <class... ColNames>\n  void read_header(ignore_column ignore_policy, ColNames... cols) {\n    static_assert(sizeof...(ColNames) >= column_count,\n                  \"not enough column names specified\");\n    static_assert(sizeof...(ColNames) <= column_count,\n                  \"too many column names specified\");\n    try {\n      set_column_names(std::forward<ColNames>(cols)...);\n\n      char *line;\n      do {\n        line = in.next_line();\n        if (!line)\n          throw error::header_missing();\n      } while (comment_policy::is_comment(line));\n\n      detail::parse_header_line<column_count, trim_policy, quote_policy>(\n          line, col_order, column_names, ignore_policy);\n    } catch (error::with_file_name &err) {\n      err.set_file_name(in.get_truncated_file_name());\n      throw;\n    }\n  }\n\n  template <class... ColNames> void set_header(ColNames... cols) {\n    static_assert(sizeof...(ColNames) >= column_count,\n                  \"not enough column names specified\");\n    static_assert(sizeof...(ColNames) <= column_count,\n                  \"too many column names specified\");\n    set_column_names(std::forward<ColNames>(cols)...);\n    std::fill(row, row + column_count, nullptr);\n    col_order.resize(column_count);\n    for (unsigned i = 0; i < column_count; ++i)\n      col_order[i] = i;\n  }\n\n  bool has_column(const std::string &name) const {\n    return col_order.end() !=\n           std::find(col_order.begin(), col_order.end(),\n                     std::find(std::begin(column_names), std::end(column_names),\n                               name) -\n                         std::begin(column_names));\n  }\n\n  void set_file_name(const std::string &file_name) {\n    in.set_file_name(file_name);\n  }\n\n  void set_file_name(const char *file_name) { in.set_file_name(file_name); }\n\n  const char *get_truncated_file_name() const {\n    return in.get_truncated_file_name();\n  }\n\n  void set_file_line(unsigned file_line) { in.set_file_line(file_line); }\n\n  unsigned get_file_line() const { return in.get_file_line(); }\n\nprivate:\n  void parse_helper(std::size_t) {}\n\n  template <class T, class... ColType>\n  void parse_helper(std::size_t r, T &t, ColType &... cols) {\n    if (row[r]) {\n      try {\n        try {\n          ::io::detail::parse<overflow_policy>(row[r], t);\n        } catch (error::with_column_content &err) {\n          err.set_column_content(row[r]);\n          throw;\n        }\n      } catch (error::with_column_name &err) {\n        err.set_column_name(column_names[r].c_str());\n        throw;\n      }\n    }\n    parse_helper(r + 1, cols...);\n  }\n\npublic:\n  template <class... ColType> bool read_row(ColType &... cols) {\n    static_assert(sizeof...(ColType) >= column_count,\n                  \"not enough columns specified\");\n    static_assert(sizeof...(ColType) <= column_count,\n                  \"too many columns specified\");\n    try {\n      try {\n\n        char *line;\n        do {\n          line = in.next_line();\n          if (!line)\n            return false;\n        } while (comment_policy::is_comment(line));\n\n        detail::parse_line<trim_policy, quote_policy>(line, row, col_order);\n\n        parse_helper(0, cols...);\n      } catch (error::with_file_name &err) {\n        err.set_file_name(in.get_truncated_file_name());\n        throw;\n      }\n    } catch (error::with_file_line &err) {\n      err.set_file_line(in.get_file_line());\n      throw;\n    }\n\n    return true;\n  }\n};\n} // namespace io\n#endif\n"
        }
      ]
    }
  ]
}