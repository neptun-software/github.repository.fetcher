{
  "metadata": {
    "timestamp": 1736565687860,
    "page": 587,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nodejs/node-addon-examples",
      "stars": 2519,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 3.1123046875,
          "content": "---\nLanguage:        Cpp\n# BasedOnStyle:  Google\nAccessModifierOffset: -1\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: Right\nAlignOperands:   true\nAlignTrailingComments: true\nAllowAllParametersOfDeclarationOnNextLine: true\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: Inline\nAllowShortIfStatementsOnASingleLine: true\nAllowShortLoopsOnASingleLine: true\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: true\nBinPackArguments: false\nBinPackParameters: false\nBraceWrapping:\n  AfterClass:      false\n  AfterControlStatement: false\n  AfterEnum:       false\n  AfterFunction:   false\n  AfterNamespace:  false\n  AfterObjCDeclaration: false\n  AfterStruct:     false\n  AfterUnion:      false\n  AfterExternBlock: false\n  BeforeCatch:     false\n  BeforeElse:      false\n  IndentBraces:    false\n  SplitEmptyFunction: true\n  SplitEmptyRecord: true\n  SplitEmptyNamespace: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Attach\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: true\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeColon\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: true\nColumnLimit:      80\nCommentPragmas:  '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: true\nConstructorInitializerIndentWidth: 4\nContinuationIndentWidth: 4\nCpp11BracedListStyle: true\nDerivePointerAlignment: false\nDisableFormat:   false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: true\nForEachMacros:\n  - foreach\n  - Q_FOREACH\n  - BOOST_FOREACH\nIncludeBlocks:   Preserve\nIncludeCategories:\n  - Regex:           '^<ext/.*\\.h>'\n    Priority:        2\n  - Regex:           '^<.*\\.h>'\n    Priority:        1\n  - Regex:           '^<.*'\n    Priority:        2\n  - Regex:           '.*'\n    Priority:        3\nIncludeIsMainRegex: '([-_](test|unittest))?$'\nIndentCaseLabels: true\nIndentPPDirectives: None\nIndentWidth:     2\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: false\nMacroBlockBegin: ''\nMacroBlockEnd:   ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBlockIndentWidth: 2\nObjCSpaceAfterProperty: false\nObjCSpaceBeforeProtocolList: false\nPenaltyBreakAssignment: 2\nPenaltyBreakBeforeFirstCallParameter: 1\nPenaltyBreakComment: 300\nPenaltyBreakFirstLessLess: 120\nPenaltyBreakString: 1000\nPenaltyExcessCharacter: 1000000\nPenaltyReturnTypeOnItsOwnLine: 200\nPointerAlignment: Left\nReflowComments:  true\nSortIncludes:    true\nSortUsingDeclarations: true\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeParens: ControlStatements\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 2\nSpacesInAngles:  false\nSpacesInContainerLiterals: true\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard:        Auto\nTabWidth:        8\nUseTab:          Never\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.107421875,
          "content": "build/\nnode_modules/\nDebug/\nRelease/\n*.lock\n*.log\npackage-lock.json\nnpm-debug.log*\n\n.idea/\n.vscode/\n.DS_Store\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.4775390625,
          "content": "repos:\n- repo: https://github.com/gitleaks/gitleaks\n  rev: v8.16.3\n  hooks:\n  - id: gitleaks\n- repo: https://github.com/pocc/pre-commit-hooks\n  rev: v1.3.5\n  hooks:\n  - id: cpplint\n- repo: https://github.com/pre-commit/mirrors-eslint\n  rev: v8.38.0\n  hooks:\n  - id: eslint\n- repo: https://github.com/pre-commit/pre-commit-hooks\n  rev: v4.4.0\n  hooks:\n  - id: end-of-file-fixer\n  - id: trailing-whitespace\n- repo: https://github.com/pylint-dev/pylint\n  rev: v2.17.2\n  hooks:\n  - id: pylint\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.1533203125,
          "content": "# Code of Conduct\n\nThe Node.js Code of Conduct, which applies to this project, can be found at\nhttps://github.com/nodejs/admin/blob/HEAD/CODE_OF_CONDUCT.md.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.1279296875,
          "content": "\n# Developer's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n (a) The contribution was created in whole or in part by me and I\n     have the right to submit it under the open-source license\n     indicated in the file; or\n\n (b) The contribution is based upon previous work that, to the best\n     of my knowledge, is covered under an appropriate open source\n     license and I have the right under that license to submit that\n     work with modifications, whether created in whole or in part\n     by me, under the same open-source license (unless I am\n     permitted to submit under a different license), as indicated\n     in the file; or\n\n (c) The contribution was provided directly to me by some other\n     person who certified (a), (b), or (c) and I have not modified\n     it.\n\n (d) I understand and agree that this project and the contribution\n     are public and that a record of the contribution (including all\n     personal information I submit with it, including my sign-off) is\n     maintained indefinitely and may be redistributed consistent with\n     this project or the open source license(s) involved.\n\n\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.2587890625,
          "content": "The MIT License (MIT)\n=====================\n\nCopyright (c) 2017 Node.js node-addon-examples collaborators\n-----------------------------------\n\n*Node.js node-addon-examples collaborators listed at <https://github.com/nodejs/node-addon-examples/graphs/contributors>*\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.27734375,
          "content": "Node.js Addon Examples\n=========================================\n\n**A repository of [Node.js Addons](https://nodejs.org/api/addons.html#addons_c_addons) examples.**\n\nImplementations of examples are named either after Node.js versions (`node_0.10`,\n`node_0.12`, etc), or Node.js addon implementation APIs:\n\n- [`nan`](https://github.com/nodejs/nan): C++-based abstraction between Node and direct V8 APIs.\n- [`Node-API`](https://nodejs.org/api/n-api.html): C-based API guaranteeing [ABI stability](https://nodejs.org/en/docs/guides/abi-stability/) across different node versions as well as JavaScript engines. (Node-API was previously known as N-API.)\n- [`node-addon-api`](https://github.com/nodejs/node-addon-api): header-only C++ wrapper classes which simplify the use of the C-based Node-API.\n- [`node-addon-api-addon-class`](https://github.com/nodejs/node-addon-api/tree/main/doc/addon.md): Similar to `node-addon-api`, but deriving from the `Napi::Addon` class. [1_hello_world](./1_hello_world) provides an example.\n\nImplementations against unsupported versions of Node.js are provided for\ncompleteness and historical context. They are not maintained.\n\nThe examples are primarily maintained for Node-API and node-addon-api and as outlined in\nthe Node.js [documentation](https://nodejs.org/dist/latest/docs/api/addons.html),\nunless there is a need for direct access to functionality which\nis not exposed by Node-API, use Node-API.\n\nThe [Node-API Resource](http://nodejs.github.io/node-addon-examples/) offers an\nexcellent orientation and tips for developers just getting started with Node-API\nand `node-addon-api`.\n\n## Usage\n\nThe directory structure is as follows:\n\n```sh\nREPO_ROOT\n├── test_all.js\n├── package.json\n├── README.md\n└── src\n    ├── 1-getting-started\n    │   ├── example1\n    │   │   ├── nan\n    │   │   ├── node-addon-api\n    │   │   └── napi\n    │   ├── example2\n    │   └── example3\n    ├── 2-js-to-native-conversion\n    ├── 3-context-awareness\n    ├── 4-references-and-handle-scope\n    ├── 5-async-work\n    ├── 6-threadsafe-function\n    ├── 7-events\n    └── 8-tooling\n```\n\nIn each example's implementation subdirectory, run\n\n```text\nnpm install\nnode ./\n```\n\nto see the example in action.\n"
        },
        {
          "name": "original_docs_source.md",
          "type": "blob",
          "size": 19.166015625,
          "content": "*This is the original document from the [joyent/node](https://github.com/joyent/node) repository as docs/api/addons.markdown. This documentation was used as a foundation for some of the documentation and code found in the [node-addon-examples](https://github.com/rvagg/node-addon-examples) repository.*\n\n*This documentation targets Node 0.10 and prior and is not relevant for Node 0.11 onwards due mainly to major V8 changes.*\n\n*This document is Copyright Joyent, Inc, Node.js is a trademark of Joyent, Inc. [LICENCE](https://raw.github.com/joyent/node/v0.10.22/LICENSE)*\n\n# Addons\n\nAddons are dynamically linked shared objects. They can provide glue to C and\nC++ libraries. The API (at the moment) is rather complex, involving\nknowledge of several libraries:\n\n - V8 JavaScript, a C++ library. Used for interfacing with JavaScript:\n   creating objects, calling functions, etc.  Documented mostly in the\n   `v8.h` header file (`deps/v8/include/v8.h` in the Node source\n   tree), which is also available\n   [online](http://izs.me/v8-docs/main.html).\n\n - [libuv](https://github.com/libuv/libuv), C event loop library.\n   Anytime one needs to wait for a file descriptor to become readable,\n   wait for a timer, or wait for a signal to be received one will need\n   to interface with libuv. That is, if you perform any I/O, libuv will\n   need to be used.\n\n - Internal Node libraries. Most importantly is the `node::ObjectWrap`\n   class which you will likely want to derive from.\n\n - Others. Look in `deps/` for what else is available.\n\nNode statically compiles all its dependencies into the executable.\nWhen compiling your module, you don't need to worry about linking to\nany of these libraries.\n\nAll of the following examples are available for\n[download](https://github.com/rvagg/node-addon-examples) and may be\nused as a starting-point for your own Addon.\n\n## Hello world\n\nTo get started let's make a small Addon which is the C++ equivalent of\nthe following JavaScript code:\n\n    module.exports.hello = function() { return 'world'; };\n\nFirst we create a file `hello.cc`:\n\n    #include <node.h>\n    #include <v8.h>\n\n    using namespace v8;\n\n    Handle<Value> Method(const Arguments& args) {\n      HandleScope scope;\n      return scope.Close(String::New(\"world\"));\n    }\n\n    void init(Handle<Object> exports) {\n      exports->Set(String::NewSymbol(\"hello\"),\n          FunctionTemplate::New(Method)->GetFunction());\n    }\n\n    NODE_MODULE(hello, init)\n\nNote that all Node addons must export an initialization function:\n\n    void Initialize (Handle<Object> exports);\n    NODE_MODULE(module_name, Initialize)\n\nThere is no semi-colon after `NODE_MODULE` as it's not a function (see `node.h`).\n\nThe `module_name` needs to match the filename of the final binary (minus the\n.node suffix).\n\nThe source code needs to be built into `hello.node`, the binary Addon. To\ndo this we create a file called `binding.gyp` which describes the configuration\nto build your module in a JSON-like format. This file gets compiled by\n[node-gyp](https://github.com/TooTallNate/node-gyp).\n\n    {\n      \"targets\": [\n        {\n          \"target_name\": \"hello\",\n          \"sources\": [ \"hello.cc\" ]\n        }\n      ]\n    }\n\nThe next step is to generate the appropriate project build files for the\ncurrent platform. Use `node-gyp configure` for that.\n\nNow you will have either a `Makefile` (on Unix platforms) or a `vcxproj` file\n(on Windows) in the `build/` directory. Next invoke the `node-gyp build`\ncommand.\n\nNow you have your compiled `.node` bindings file! The compiled bindings end up\nin `build/Release/`.\n\nYou can now use the binary addon in a Node project `hello.js` by pointing `require` to\nthe recently built `hello.node` module:\n\n    var addon = require('./build/Release/hello');\n\n    console.log(addon.hello()); // 'world'\n\nPlease see patterns below for further information or\n<https://github.com/arturadib/node-qt> for an example in production.\n\n\n## Addon patterns\n\nBelow are some addon patterns to help you get started. Consult the online\n[v8 reference](http://izs.me/v8-docs/main.html) for help with the various v8\ncalls, and v8's [Embedder's Guide](http://code.google.com/apis/v8/embed.html)\nfor an explanation of several concepts used such as handles, scopes,\nfunction templates, etc.\n\nIn order to use these examples you need to compile them using `node-gyp`.\nCreate the following `binding.gyp` file:\n\n    {\n      \"targets\": [\n        {\n          \"target_name\": \"addon\",\n          \"sources\": [ \"addon.cc\" ]\n        }\n      ]\n    }\n\nIn cases where there is more than one `.cc` file, simply add the file name to the\n`sources` array, e.g.:\n\n    \"sources\": [\"addon.cc\", \"myexample.cc\"]\n\nNow that you have your `binding.gyp` ready, you can configure and build the\naddon:\n\n    $ node-gyp configure build\n\n\n### Function arguments\n\nThe following pattern illustrates how to read arguments from JavaScript\nfunction calls and return a result. This is the main and only needed source\n`addon.cc`:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n\n    using namespace v8;\n\n    Handle<Value> Add(const Arguments& args) {\n      HandleScope scope;\n\n      if (args.Length() < 2) {\n        ThrowException(Exception::TypeError(String::New(\"Wrong number of arguments\")));\n        return scope.Close(Undefined());\n      }\n\n      if (!args[0]->IsNumber() || !args[1]->IsNumber()) {\n        ThrowException(Exception::TypeError(String::New(\"Wrong arguments\")));\n        return scope.Close(Undefined());\n      }\n\n      Local<Number> num = Number::New(args[0]->NumberValue() +\n          args[1]->NumberValue());\n      return scope.Close(num);\n    }\n\n    void Init(Handle<Object> exports) {\n      exports->Set(String::NewSymbol(\"add\"),\n          FunctionTemplate::New(Add)->GetFunction());\n    }\n\n    NODE_MODULE(addon, Init)\n\nYou can test it with the following JavaScript snippet:\n\n    var addon = require('./build/Release/addon');\n\n    console.log( 'This should be eight:', addon.add(3,5) );\n\n\n### Callbacks\n\nYou can pass JavaScript functions to a C++ function and execute them from\nthere. Here's `addon.cc`:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n\n    using namespace v8;\n\n    Handle<Value> RunCallback(const Arguments& args) {\n      HandleScope scope;\n\n      Local<Function> cb = Local<Function>::Cast(args[0]);\n      const unsigned argc = 1;\n      Local<Value> argv[argc] = { Local<Value>::New(String::New(\"hello world\")) };\n      cb->Call(Context::GetCurrent()->Global(), argc, argv);\n\n      return scope.Close(Undefined());\n    }\n\n    void Init(Handle<Object> exports, Handle<Object> module) {\n      module->Set(String::NewSymbol(\"exports\"),\n          FunctionTemplate::New(RunCallback)->GetFunction());\n    }\n\n    NODE_MODULE(addon, Init)\n\nNote that this example uses a two-argument form of `Init()` that receives\nthe full `module` object as the second argument. This allows the addon\nto completely overwrite `exports` with a single function instead of\nadding the function as a property of `exports`.\n\nTo test it run the following JavaScript snippet:\n\n    var addon = require('./build/Release/addon');\n\n    addon(function(msg){\n      console.log(msg); // 'hello world'\n    });\n\n\n### Object factory\n\nYou can create and return new objects from within a C++ function with this\n`addon.cc` pattern, which returns an object with property `msg` that echoes\nthe string passed to `createObject()`:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n\n    using namespace v8;\n\n    Handle<Value> CreateObject(const Arguments& args) {\n      HandleScope scope;\n\n      Local<Object> obj = Object::New();\n      obj->Set(String::NewSymbol(\"msg\"), args[0]->ToString());\n\n      return scope.Close(obj);\n    }\n\n    void Init(Handle<Object> exports, Handle<Object> module) {\n      module->Set(String::NewSymbol(\"exports\"),\n          FunctionTemplate::New(CreateObject)->GetFunction());\n    }\n\n    NODE_MODULE(addon, Init)\n\nTo test it in JavaScript:\n\n    var addon = require('./build/Release/addon');\n\n    var obj1 = addon('hello');\n    var obj2 = addon('world');\n    console.log(obj1.msg+' '+obj2.msg); // 'hello world'\n\n\n### Function factory\n\nThis pattern illustrates how to create and return a JavaScript function that\nwraps a C++ function:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n\n    using namespace v8;\n\n    Handle<Value> MyFunction(const Arguments& args) {\n      HandleScope scope;\n      return scope.Close(String::New(\"hello world\"));\n    }\n\n    Handle<Value> CreateFunction(const Arguments& args) {\n      HandleScope scope;\n\n      Local<FunctionTemplate> tpl = FunctionTemplate::New(MyFunction);\n      Local<Function> fn = tpl->GetFunction();\n      fn->SetName(String::NewSymbol(\"theFunction\")); // omit this to make it anonymous\n\n      return scope.Close(fn);\n    }\n\n    void Init(Handle<Object> exports, Handle<Object> module) {\n      module->Set(String::NewSymbol(\"exports\"),\n          FunctionTemplate::New(CreateFunction)->GetFunction());\n    }\n\n    NODE_MODULE(addon, Init)\n\n\nTo test:\n\n    var addon = require('./build/Release/addon');\n\n    var fn = addon();\n    console.log(fn()); // 'hello world'\n\n\n### Wrapping C++ objects\n\nHere we will create a wrapper for a C++ object/class `MyObject` that can be\ninstantiated in JavaScript through the `new` operator. First prepare the main\nmodule `addon.cc`:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n    #include \"myobject.h\"\n\n    using namespace v8;\n\n    void InitAll(Handle<Object> exports) {\n      MyObject::Init(exports);\n    }\n\n    NODE_MODULE(addon, InitAll)\n\nThen in `myobject.h` make your wrapper inherit from `node::ObjectWrap`:\n\n    #ifndef MYOBJECT_H\n    #define MYOBJECT_H\n\n    #include <node.h>\n\n    class MyObject : public node::ObjectWrap {\n     public:\n      static void Init(v8::Handle<v8::Object> exports);\n\n     private:\n      explicit MyObject(double value = 0);\n      ~MyObject();\n\n      static v8::Handle<v8::Value> New(const v8::Arguments& args);\n      static v8::Handle<v8::Value> PlusOne(const v8::Arguments& args);\n      static v8::Persistent<v8::Function> constructor;\n      double value_;\n    };\n\n    #endif\n\nAnd in `myobject.cc` implement the various methods that you want to expose.\nHere we expose the method `plusOne` by adding it to the constructor's\nprototype:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n    #include \"myobject.h\"\n\n    using namespace v8;\n\n    Persistent<Function> MyObject::constructor;\n\n    MyObject::MyObject(double value) : value_(value) {\n    }\n\n    MyObject::~MyObject() {\n    }\n\n    void MyObject::Init(Handle<Object> exports) {\n      // Prepare constructor template\n      Local<FunctionTemplate> tpl = FunctionTemplate::New(New);\n      tpl->SetClassName(String::NewSymbol(\"MyObject\"));\n      tpl->InstanceTemplate()->SetInternalFieldCount(1);\n      // Prototype\n      tpl->PrototypeTemplate()->Set(String::NewSymbol(\"plusOne\"),\n          FunctionTemplate::New(PlusOne)->GetFunction());\n      constructor = Persistent<Function>::New(tpl->GetFunction());\n      exports->Set(String::NewSymbol(\"MyObject\"), constructor);\n    }\n\n    Handle<Value> MyObject::New(const Arguments& args) {\n      HandleScope scope;\n\n      if (args.IsConstructCall()) {\n        // Invoked as constructor: `new MyObject(...)`\n        double value = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();\n        MyObject* obj = new MyObject(value);\n        obj->Wrap(args.This());\n        return args.This();\n      } else {\n        // Invoked as plain function `MyObject(...)`, turn into construct call.\n        const int argc = 1;\n        Local<Value> argv[argc] = { args[0] };\n        return scope.Close(constructor->NewInstance(argc, argv));\n      }\n    }\n\n    Handle<Value> MyObject::PlusOne(const Arguments& args) {\n      HandleScope scope;\n\n      MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.This());\n      obj->value_ += 1;\n\n      return scope.Close(Number::New(obj->value_));\n    }\n\nTest it with:\n\n    var addon = require('./build/Release/addon');\n\n    var obj = new addon.MyObject(10);\n    console.log( obj.plusOne() ); // 11\n    console.log( obj.plusOne() ); // 12\n    console.log( obj.plusOne() ); // 13\n\n\n### Factory of wrapped objects\n\nThis is useful when you want to be able to create native objects without\nexplicitly instantiating them with the `new` operator in JavaScript, e.g.\n\n    var obj = addon.createObject();\n    // instead of:\n    // var obj = new addon.Object();\n\nLet's register our `createObject` method in `addon.cc`:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n    #include \"myobject.h\"\n\n    using namespace v8;\n\n    Handle<Value> CreateObject(const Arguments& args) {\n      HandleScope scope;\n      return scope.Close(MyObject::NewInstance(args));\n    }\n\n    void InitAll(Handle<Object> exports, Handle<Object> module) {\n      MyObject::Init();\n\n      module->Set(String::NewSymbol(\"exports\"),\n          FunctionTemplate::New(CreateObject)->GetFunction());\n    }\n\n    NODE_MODULE(addon, InitAll)\n\nIn `myobject.h` we now introduce the static method `NewInstance` that takes\ncare of instantiating the object (i.e. it does the job of `new` in JavaScript):\n\n    #define BUILDING_NODE_EXTENSION\n    #ifndef MYOBJECT_H\n    #define MYOBJECT_H\n\n    #include <node.h>\n\n    class MyObject : public node::ObjectWrap {\n     public:\n      static void Init();\n      static v8::Handle<v8::Value> NewInstance(const v8::Arguments& args);\n\n     private:\n      explicit MyObject(double value = 0);\n      ~MyObject();\n\n      static v8::Handle<v8::Value> New(const v8::Arguments& args);\n      static v8::Handle<v8::Value> PlusOne(const v8::Arguments& args);\n      static v8::Persistent<v8::Function> constructor;\n      double value_;\n    };\n\n    #endif\n\nThe implementation is similar to the above in `myobject.cc`:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n    #include \"myobject.h\"\n\n    using namespace v8;\n\n    Persistent<Function> MyObject::constructor;\n\n    MyObject::MyObject(double value) : value_(value) {\n    }\n\n    MyObject::~MyObject() {\n    }\n\n    void MyObject::Init() {\n      // Prepare constructor template\n      Local<FunctionTemplate> tpl = FunctionTemplate::New(New);\n      tpl->SetClassName(String::NewSymbol(\"MyObject\"));\n      tpl->InstanceTemplate()->SetInternalFieldCount(1);\n      // Prototype\n      tpl->PrototypeTemplate()->Set(String::NewSymbol(\"plusOne\"),\n          FunctionTemplate::New(PlusOne)->GetFunction());\n      constructor = Persistent<Function>::New(tpl->GetFunction());\n    }\n\n    Handle<Value> MyObject::New(const Arguments& args) {\n      HandleScope scope;\n\n      if (args.IsConstructCall()) {\n        // Invoked as constructor: `new MyObject(...)`\n        double value = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();\n        MyObject* obj = new MyObject(value);\n        obj->Wrap(args.This());\n        return args.This();\n      } else {\n        // Invoked as plain function `MyObject(...)`, turn into construct call.\n        const int argc = 1;\n        Local<Value> argv[argc] = { args[0] };\n        return scope.Close(constructor->NewInstance(argc, argv));\n      }\n    }\n\n    Handle<Value> MyObject::NewInstance(const Arguments& args) {\n      HandleScope scope;\n\n      const unsigned argc = 1;\n      Handle<Value> argv[argc] = { args[0] };\n      Local<Object> instance = constructor->NewInstance(argc, argv);\n\n      return scope.Close(instance);\n    }\n\n    Handle<Value> MyObject::PlusOne(const Arguments& args) {\n      HandleScope scope;\n\n      MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.This());\n      obj->value_ += 1;\n\n      return scope.Close(Number::New(obj->value_));\n    }\n\nTest it with:\n\n    var createObject = require('./build/Release/addon');\n\n    var obj = createObject(10);\n    console.log( obj.plusOne() ); // 11\n    console.log( obj.plusOne() ); // 12\n    console.log( obj.plusOne() ); // 13\n\n    var obj2 = createObject(20);\n    console.log( obj2.plusOne() ); // 21\n    console.log( obj2.plusOne() ); // 22\n    console.log( obj2.plusOne() ); // 23\n\n\n### Passing wrapped objects around\n\nIn addition to wrapping and returning C++ objects, you can pass them around\nby unwrapping them with Node's `node::ObjectWrap::Unwrap` helper function.\nIn the following `addon.cc` we introduce a function `add()` that can take on two\n`MyObject` objects:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n    #include \"myobject.h\"\n\n    using namespace v8;\n\n    Handle<Value> CreateObject(const Arguments& args) {\n      HandleScope scope;\n      return scope.Close(MyObject::NewInstance(args));\n    }\n\n    Handle<Value> Add(const Arguments& args) {\n      HandleScope scope;\n\n      MyObject* obj1 = node::ObjectWrap::Unwrap<MyObject>(\n          args[0]->ToObject());\n      MyObject* obj2 = node::ObjectWrap::Unwrap<MyObject>(\n          args[1]->ToObject());\n\n      double sum = obj1->Value() + obj2->Value();\n      return scope.Close(Number::New(sum));\n    }\n\n    void InitAll(Handle<Object> exports) {\n      MyObject::Init();\n\n      exports->Set(String::NewSymbol(\"createObject\"),\n          FunctionTemplate::New(CreateObject)->GetFunction());\n\n      exports->Set(String::NewSymbol(\"add\"),\n          FunctionTemplate::New(Add)->GetFunction());\n    }\n\n    NODE_MODULE(addon, InitAll)\n\nTo make things interesting we introduce a public method in `myobject.h` so we\ncan probe private values after unwrapping the object:\n\n    #define BUILDING_NODE_EXTENSION\n    #ifndef MYOBJECT_H\n    #define MYOBJECT_H\n\n    #include <node.h>\n\n    class MyObject : public node::ObjectWrap {\n     public:\n      static void Init();\n      static v8::Handle<v8::Value> NewInstance(const v8::Arguments& args);\n      double Value() const { return value_; }\n\n     private:\n      explicit MyObject(double value = 0);\n      ~MyObject();\n\n      static v8::Handle<v8::Value> New(const v8::Arguments& args);\n      static v8::Persistent<v8::Function> constructor;\n      double value_;\n    };\n\n    #endif\n\nThe implementation of `myobject.cc` is similar as before:\n\n    #define BUILDING_NODE_EXTENSION\n    #include <node.h>\n    #include \"myobject.h\"\n\n    using namespace v8;\n\n    Persistent<Function> MyObject::constructor;\n\n    MyObject::MyObject(double value) : value_(value) {\n    }\n\n    MyObject::~MyObject() {\n    }\n\n    void MyObject::Init() {\n      // Prepare constructor template\n      Local<FunctionTemplate> tpl = FunctionTemplate::New(New);\n      tpl->SetClassName(String::NewSymbol(\"MyObject\"));\n      tpl->InstanceTemplate()->SetInternalFieldCount(1);\n      constructor = Persistent<Function>::New(tpl->GetFunction());\n    }\n\n    Handle<Value> MyObject::New(const Arguments& args) {\n      HandleScope scope;\n\n      if (args.IsConstructCall()) {\n        // Invoked as constructor: `new MyObject(...)`\n        double value = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();\n        MyObject* obj = new MyObject(value);\n        obj->Wrap(args.This());\n        return args.This();\n      } else {\n        // Invoked as plain function `MyObject(...)`, turn into construct call.\n        const int argc = 1;\n        Local<Value> argv[argc] = { args[0] };\n        return scope.Close(constructor->NewInstance(argc, argv));\n      }\n    }\n\n    Handle<Value> MyObject::NewInstance(const Arguments& args) {\n      HandleScope scope;\n\n      const unsigned argc = 1;\n      Handle<Value> argv[argc] = { args[0] };\n      Local<Object> instance = constructor->NewInstance(argc, argv);\n\n      return scope.Close(instance);\n    }\n\nTest it with:\n\n    var addon = require('./build/Release/addon');\n\n    var obj1 = addon.createObject(10);\n    var obj2 = addon.createObject(20);\n    var result = addon.add(obj1, obj2);\n\n    console.log(result); // 30\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.5927734375,
          "content": "{\n  \"name\": \"node-addon-examples\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Node.js Addon Examples\",\n  \"main\": \"test_all.js\",\n  \"scripts\": {\n    \"format\": \"clang-format -i --glob=*/**/*.{h,cpp,cc}\",\n    \"test\": \"node test_all.js\"\n  },\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"lint-staged\"\n    }\n  },\n  \"lint-staged\": {\n    \"*.{h,cpp,cc}\": [\n      \"npm run format\",\n      \"git add\"\n    ]\n  },\n  \"dependencies\": {\n    \"chalk\": \"^3.0.0\",\n    \"clang-format\": \"^1.4.0\",\n    \"cmake-js\": \"^7.1.1\",\n    \"semver\": \"^7.1.3\"\n  },\n  \"devDependencies\": {\n    \"husky\": \"^4.3.0\",\n    \"lint-staged\": \"^10.5.2\"\n  }\n}\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_all.js",
          "type": "blob",
          "size": 2.58984375,
          "content": "const fs = require(\"fs\");\nconst path = require(\"path\");\nconst { execSync } = require(\"child_process\");\nconst chalk = require(\"chalk\");\nconst semver = require(\"semver\");\n\nconst examplesFolder = path.join(__dirname, \"src\");\n\nfunction getAllExamples(pathToCheck) {\n  const directoriesToTest = [];\n  for (const fd of fs.readdirSync(pathToCheck)) {\n    const absPath = path.join(pathToCheck, fd);\n    if (fs.existsSync(path.join(absPath, \"package.json\"))) {\n      directoriesToTest.push(absPath);\n      continue;\n    }\n    if (fs.statSync(absPath).isDirectory()) {\n      directoriesToTest.push(...getAllExamples(absPath));\n    }\n  }\n  return directoriesToTest;\n}\n\nconst passed = [];\nconst failedInstalls = [];\nconst noTest = [];\nconst failedTests = [];\nfor (directoryToTest of getAllExamples(examplesFolder)) {\n  console.log(chalk.green(`testing: ${directoryToTest}`));\n  const pkgJson = require(path.join(directoryToTest, \"package.json\"));\n  if (pkgJson.engines && pkgJson.engines.node) {\n    const currentNodeVersion = process.versions.node;\n    const range = pkgJson.engines.node;\n    const engineOk = semver.satisfies(currentNodeVersion, range);\n    if (!engineOk) {\n      console.warn(\n        chalk.yellow(\n          `${directoryToTest} require Node.js ${range}, current is ${currentNodeVersion}, skipping`\n        )\n      );\n      continue;\n    }\n  }\n\n  try {\n    const stdout = execSync(\"npm install\", { cwd: directoryToTest });\n    console.log(stdout.toString());\n  } catch (err) {\n    console.log(err);\n    failedInstalls.push(directoryToTest);\n    continue;\n  }\n\n  let testCommand;\n  if (\"scripts\" in pkgJson && \"start\" in pkgJson.scripts) {\n    testCommand = \"npm start\";\n  } else if (\"scripts\" in pkgJson && \"test\" in pkgJson.scripts) {\n    testCommand = \"npm test\";\n  } else if (\"main\" in pkgJson) {\n    testCommand = `node ${pkgJson.main}`\n  } else {\n    noTest.push(directoryToTest);\n    continue;\n  }\n\n  try {\n    const stdout = execSync(testCommand, { cwd: directoryToTest });\n    console.log(stdout.toString());\n    passed.push(directoryToTest);\n  } catch (err) {\n    console.log(err);\n    failedTests.push(directoryToTest);\n  }\n}\n\npassed.map((dir) => console.log(chalk.green(`passed: ${dir}`)));\n\nif (noTest.length > 0) {\n  console.warn(chalk.yellow(\"no test found:\"));\n  noTest.map((dir) => console.warn(chalk.yellow(`    ${dir}`)));\n}\n\nif (failedInstalls.length > 0) {\n  console.error(chalk.red(\"failed to install:\"));\n  failedInstalls.map((dir) => console.warn(chalk.red(`    ${dir}`)));\n}\nif (failedTests.length > 0) {\n  console.error(chalk.red(\"failed tests:\"));\n  failedTests.map((dir) => console.warn(chalk.red(`    ${dir}`)));\n}\n"
        },
        {
          "name": "website",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}