{
  "metadata": {
    "timestamp": 1736565904271,
    "page": 868,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "adafruit/DHT-sensor-library",
      "stars": 2010,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0654296875,
          "content": "# osx\n.DS_Store\n\n# doxygen\nDoxyfile*\ndoxygen_sqlite3.db\nhtml\n*.tmp\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.2578125,
          "content": "# Contribution Guidlines\n\nThis library is the culmination of the expertise of many members of the open source community who have dedicated their time and hard work. The best way to ask for help or propose a new idea is to [create a new issue](https://github.com/adafruit/DHT-sensor-library/issues/new) while creating a Pull Request with your code changes allows you to share your own innovations with the rest of the community.\n\nThe following are some guidelines to observe when creating issues or PRs:\n\n- Be friendly; it is important that we can all enjoy a safe space as we are all working on the same project and it is okay for people to have different ideas\n\n- [Use code blocks](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#code); it helps us help you when we can read your code! On that note also refrain from pasting more than 30 lines of code in a post, instead [create a gist](https://gist.github.com/) if you need to share large snippets\n\n- Use reasonable titles; refrain from using overly long or capitalized titles as they are usually annoying and do little to encourage others to help :smile:\n\n- Be detailed; refrain from mentioning code problems without sharing your source code and always give information regarding your board and version of the library\n"
        },
        {
          "name": "DHT.cpp",
          "type": "blob",
          "size": 11.8681640625,
          "content": "/*!\n *  @file DHT.cpp\n *\n *  @mainpage DHT series of low cost temperature/humidity sensors.\n *\n *  @section intro_sec Introduction\n *\n *  This is a library for DHT series of low cost temperature/humidity sensors.\n *\n *  You must have Adafruit Unified Sensor Library library installed to use this\n * class.\n *\n *  Adafruit invests time and resources providing this open source code,\n *  please support Adafruit andopen-source hardware by purchasing products\n *  from Adafruit!\n *\n *  @section author Author\n *\n *  Written by Adafruit Industries.\n *\n *  @section license License\n *\n *  MIT license, all text above must be included in any redistribution\n */\n\n#include \"DHT.h\"\n\n#define MIN_INTERVAL 2000 /**< min interval value */\n#define TIMEOUT                                                                \\\n  UINT32_MAX /**< Used programmatically for timeout.                           \\\n                   Not a timeout duration. Type: uint32_t. */\n\n/*!\n *  @brief  Instantiates a new DHT class\n *  @param  pin\n *          pin number that sensor is connected\n *  @param  type\n *          type of sensor\n *  @param  count\n *          number of sensors\n */\nDHT::DHT(uint8_t pin, uint8_t type, uint8_t count) {\n  (void)count; // Workaround to avoid compiler warning.\n  _pin = pin;\n  _type = type;\n#ifdef __AVR\n  _bit = digitalPinToBitMask(pin);\n  _port = digitalPinToPort(pin);\n#endif\n  _maxcycles =\n      microsecondsToClockCycles(1000); // 1 millisecond timeout for\n                                       // reading pulses from DHT sensor.\n  // Note that count is now ignored as the DHT reading algorithm adjusts itself\n  // based on the speed of the processor.\n}\n\n/*!\n *  @brief  Setup sensor pins and set pull timings\n *  @param  usec\n *          Optionally pass pull-up time (in microseconds) before DHT reading\n *starts. Default is 55 (see function declaration in DHT.h).\n */\nvoid DHT::begin(uint8_t usec) {\n  // set up the pins!\n  pinMode(_pin, INPUT_PULLUP);\n  // Using this value makes sure that millis() - lastreadtime will be\n  // >= MIN_INTERVAL right away. Note that this assignment wraps around,\n  // but so will the subtraction.\n  _lastreadtime = millis() - MIN_INTERVAL;\n  DEBUG_PRINT(\"DHT max clock cycles: \");\n  DEBUG_PRINTLN(_maxcycles, DEC);\n  pullTime = usec;\n}\n\n/*!\n *  @brief  Read temperature\n *  @param  S\n *          Scale. Boolean value:\n *\t\t\t\t\t- true = Fahrenheit\n *\t\t\t\t\t- false = Celcius\n *  @param  force\n *          true if in force mode\n *\t@return Temperature value in selected scale\n */\nfloat DHT::readTemperature(bool S, bool force) {\n  float f = NAN;\n\n  if (read(force)) {\n    switch (_type) {\n    case DHT11:\n      f = data[2];\n      if (data[3] & 0x80) {\n        f = -1 - f;\n      }\n      f += (data[3] & 0x0f) * 0.1;\n      if (S) {\n        f = convertCtoF(f);\n      }\n      break;\n    case DHT12:\n      f = data[2];\n      f += (data[3] & 0x0f) * 0.1;\n      if (data[2] & 0x80) {\n        f *= -1;\n      }\n      if (S) {\n        f = convertCtoF(f);\n      }\n      break;\n    case DHT22:\n    case DHT21:\n      f = ((word)(data[2] & 0x7F)) << 8 | data[3];\n      f *= 0.1;\n      if (data[2] & 0x80) {\n        f *= -1;\n      }\n      if (S) {\n        f = convertCtoF(f);\n      }\n      break;\n    }\n  }\n  return f;\n}\n\n/*!\n *  @brief  Converts Celcius to Fahrenheit\n *  @param  c\n *\t\t\t\t\tvalue in Celcius\n *\t@return float value in Fahrenheit\n */\nfloat DHT::convertCtoF(float c) { return c * 1.8 + 32; }\n\n/*!\n *  @brief  Converts Fahrenheit to Celcius\n *  @param  f\n *\t\t\t\t\tvalue in Fahrenheit\n *\t@return float value in Celcius\n */\nfloat DHT::convertFtoC(float f) { return (f - 32) * 0.55555; }\n\n/*!\n *  @brief  Read Humidity\n *  @param  force\n *\t\t\t\t\tforce read mode\n *\t@return float value - humidity in percent\n */\nfloat DHT::readHumidity(bool force) {\n  float f = NAN;\n  if (read(force)) {\n    switch (_type) {\n    case DHT11:\n    case DHT12:\n      f = data[0] + data[1] * 0.1;\n      break;\n    case DHT22:\n    case DHT21:\n      f = ((word)data[0]) << 8 | data[1];\n      f *= 0.1;\n      break;\n    }\n  }\n  return f;\n}\n\n/*!\n *  @brief  Compute Heat Index\n *          Simplified version that reads temp and humidity from sensor\n *  @param  isFahrenheit\n * \t\t\t\t\ttrue if fahrenheit, false if celcius\n *(default true)\n *\t@return float heat index\n */\nfloat DHT::computeHeatIndex(bool isFahrenheit) {\n  float hi = computeHeatIndex(readTemperature(isFahrenheit), readHumidity(),\n                              isFahrenheit);\n  return hi;\n}\n\n/*!\n *  @brief  Compute Heat Index\n *  \t\t\t\tUsing both Rothfusz and Steadman's equations\n *\t\t\t\t\t(http://www.wpc.ncep.noaa.gov/html/heatindex_equation.shtml)\n *  @param  temperature\n *          temperature in selected scale\n *  @param  percentHumidity\n *          humidity in percent\n *  @param  isFahrenheit\n * \t\t\t\t\ttrue if fahrenheit, false if celcius\n *\t@return float heat index\n */\nfloat DHT::computeHeatIndex(float temperature, float percentHumidity,\n                            bool isFahrenheit) {\n  float hi;\n\n  if (!isFahrenheit)\n    temperature = convertCtoF(temperature);\n\n  hi = 0.5 * (temperature + 61.0 + ((temperature - 68.0) * 1.2) +\n              (percentHumidity * 0.094));\n\n  if (hi > 79) {\n    hi = -42.379 + 2.04901523 * temperature + 10.14333127 * percentHumidity +\n         -0.22475541 * temperature * percentHumidity +\n         -0.00683783 * pow(temperature, 2) +\n         -0.05481717 * pow(percentHumidity, 2) +\n         0.00122874 * pow(temperature, 2) * percentHumidity +\n         0.00085282 * temperature * pow(percentHumidity, 2) +\n         -0.00000199 * pow(temperature, 2) * pow(percentHumidity, 2);\n\n    if ((percentHumidity < 13) && (temperature >= 80.0) &&\n        (temperature <= 112.0))\n      hi -= ((13.0 - percentHumidity) * 0.25) *\n            sqrt((17.0 - abs(temperature - 95.0)) * 0.05882);\n\n    else if ((percentHumidity > 85.0) && (temperature >= 80.0) &&\n             (temperature <= 87.0))\n      hi += ((percentHumidity - 85.0) * 0.1) * ((87.0 - temperature) * 0.2);\n  }\n\n  return isFahrenheit ? hi : convertFtoC(hi);\n}\n\n/*!\n *  @brief  Read value from sensor or return last one from less than two\n *seconds.\n *  @param  force\n *          true if using force mode\n *\t@return float value\n */\nbool DHT::read(bool force) {\n  // Check if sensor was read less than two seconds ago and return early\n  // to use last reading.\n  uint32_t currenttime = millis();\n  if (!force && ((currenttime - _lastreadtime) < MIN_INTERVAL)) {\n    return _lastresult; // return last correct measurement\n  }\n  _lastreadtime = currenttime;\n\n  // Reset 40 bits of received data to zero.\n  data[0] = data[1] = data[2] = data[3] = data[4] = 0;\n\n#if defined(ESP8266)\n  yield(); // Handle WiFi / reset software watchdog\n#endif\n\n  // Send start signal.  See DHT datasheet for full signal diagram:\n  //   http://www.adafruit.com/datasheets/Digital%20humidity%20and%20temperature%20sensor%20AM2302.pdf\n\n  // Go into high impedence state to let pull-up raise data line level and\n  // start the reading process.\n  pinMode(_pin, INPUT_PULLUP);\n  delay(1);\n\n  // First set data line low for a period according to sensor type\n  pinMode(_pin, OUTPUT);\n  digitalWrite(_pin, LOW);\n  switch (_type) {\n  case DHT22:\n  case DHT21:\n    delayMicroseconds(1100); // data sheet says \"at least 1ms\"\n    break;\n  case DHT11:\n  default:\n    delay(20); // data sheet says at least 18ms, 20ms just to be safe\n    break;\n  }\n\n  uint32_t cycles[80];\n  {\n    // End the start signal by setting data line high for 40 microseconds.\n    pinMode(_pin, INPUT_PULLUP);\n\n    // Delay a moment to let sensor pull data line low.\n    delayMicroseconds(pullTime);\n\n    // Now start reading the data line to get the value from the DHT sensor.\n\n    // Turn off interrupts temporarily because the next sections\n    // are timing critical and we don't want any interruptions.\n    InterruptLock lock;\n\n    // First expect a low signal for ~80 microseconds followed by a high signal\n    // for ~80 microseconds again.\n    if (expectPulse(LOW) == TIMEOUT) {\n      DEBUG_PRINTLN(F(\"DHT timeout waiting for start signal low pulse.\"));\n      _lastresult = false;\n      return _lastresult;\n    }\n    if (expectPulse(HIGH) == TIMEOUT) {\n      DEBUG_PRINTLN(F(\"DHT timeout waiting for start signal high pulse.\"));\n      _lastresult = false;\n      return _lastresult;\n    }\n\n    // Now read the 40 bits sent by the sensor.  Each bit is sent as a 50\n    // microsecond low pulse followed by a variable length high pulse.  If the\n    // high pulse is ~28 microseconds then it's a 0 and if it's ~70 microseconds\n    // then it's a 1.  We measure the cycle count of the initial 50us low pulse\n    // and use that to compare to the cycle count of the high pulse to determine\n    // if the bit is a 0 (high state cycle count < low state cycle count), or a\n    // 1 (high state cycle count > low state cycle count). Note that for speed\n    // all the pulses are read into a array and then examined in a later step.\n    for (int i = 0; i < 80; i += 2) {\n      cycles[i] = expectPulse(LOW);\n      cycles[i + 1] = expectPulse(HIGH);\n    }\n  } // Timing critical code is now complete.\n\n  // Inspect pulses and determine which ones are 0 (high state cycle count < low\n  // state cycle count), or 1 (high state cycle count > low state cycle count).\n  for (int i = 0; i < 40; ++i) {\n    uint32_t lowCycles = cycles[2 * i];\n    uint32_t highCycles = cycles[2 * i + 1];\n    if ((lowCycles == TIMEOUT) || (highCycles == TIMEOUT)) {\n      DEBUG_PRINTLN(F(\"DHT timeout waiting for pulse.\"));\n      _lastresult = false;\n      return _lastresult;\n    }\n    data[i / 8] <<= 1;\n    // Now compare the low and high cycle times to see if the bit is a 0 or 1.\n    if (highCycles > lowCycles) {\n      // High cycles are greater than 50us low cycle count, must be a 1.\n      data[i / 8] |= 1;\n    }\n    // Else high cycles are less than (or equal to, a weird case) the 50us low\n    // cycle count so this must be a zero.  Nothing needs to be changed in the\n    // stored data.\n  }\n\n  DEBUG_PRINTLN(F(\"Received from DHT:\"));\n  DEBUG_PRINT(data[0], HEX);\n  DEBUG_PRINT(F(\", \"));\n  DEBUG_PRINT(data[1], HEX);\n  DEBUG_PRINT(F(\", \"));\n  DEBUG_PRINT(data[2], HEX);\n  DEBUG_PRINT(F(\", \"));\n  DEBUG_PRINT(data[3], HEX);\n  DEBUG_PRINT(F(\", \"));\n  DEBUG_PRINT(data[4], HEX);\n  DEBUG_PRINT(F(\" =? \"));\n  DEBUG_PRINTLN((data[0] + data[1] + data[2] + data[3]) & 0xFF, HEX);\n\n  // Check we read 40 bits and that the checksum matches.\n  if (data[4] == ((data[0] + data[1] + data[2] + data[3]) & 0xFF)) {\n    _lastresult = true;\n    return _lastresult;\n  } else {\n    DEBUG_PRINTLN(F(\"DHT checksum failure!\"));\n    _lastresult = false;\n    return _lastresult;\n  }\n}\n\n// Expect the signal line to be at the specified level for a period of time and\n// return a count of loop cycles spent at that level (this cycle count can be\n// used to compare the relative time of two pulses).  If more than a millisecond\n// ellapses without the level changing then the call fails with a 0 response.\n// This is adapted from Arduino's pulseInLong function (which is only available\n// in the very latest IDE versions):\n//   https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/cores/arduino/wiring_pulse.c\nuint32_t DHT::expectPulse(bool level) {\n// F_CPU is not be known at compile time on platforms such as STM32F103.\n// The preprocessor seems to evaluate it to zero in that case.\n#if (F_CPU > 16000000L) || (F_CPU == 0L)\n  uint32_t count = 0;\n#else\n  uint16_t count = 0; // To work fast enough on slower AVR boards\n#endif\n// On AVR platforms use direct GPIO port access as it's much faster and better\n// for catching pulses that are 10's of microseconds in length:\n#ifdef __AVR\n  uint8_t portState = level ? _bit : 0;\n  while ((*portInputRegister(_port) & _bit) == portState) {\n    if (count++ >= _maxcycles) {\n      return TIMEOUT; // Exceeded timeout, fail.\n    }\n  }\n// Otherwise fall back to using digitalRead (this seems to be necessary on\n// ESP8266 right now, perhaps bugs in direct port access functions?).\n#else\n  while (digitalRead(_pin) == level) {\n    if (count++ >= _maxcycles) {\n      return TIMEOUT; // Exceeded timeout, fail.\n    }\n  }\n#endif\n\n  return count;\n}\n"
        },
        {
          "name": "DHT.h",
          "type": "blob",
          "size": 3.1455078125,
          "content": "/*!\n *  @file DHT.h\n *\n *  This is a library for DHT series of low cost temperature/humidity sensors.\n *\n *  You must have Adafruit Unified Sensor Library library installed to use this\n * class.\n *\n *  Adafruit invests time and resources providing this open source code,\n *  please support Adafruit andopen-source hardware by purchasing products\n *  from Adafruit!\n *\n *  Written by Adafruit Industries.\n *\n *  MIT license, all text above must be included in any redistribution\n */\n\n#ifndef DHT_H\n#define DHT_H\n\n#include \"Arduino.h\"\n\n/* Uncomment to enable printing out nice debug messages. */\n//#define DHT_DEBUG\n\n#define DEBUG_PRINTER                                                          \\\n  Serial /**< Define where debug output will be printed.                       \\\n          */\n\n/* Setup debug printing macros. */\n#ifdef DHT_DEBUG\n#define DEBUG_PRINT(...)                                                       \\\n  { DEBUG_PRINTER.print(__VA_ARGS__); }\n#define DEBUG_PRINTLN(...)                                                     \\\n  { DEBUG_PRINTER.println(__VA_ARGS__); }\n#else\n#define DEBUG_PRINT(...)                                                       \\\n  {} /**< Debug Print Placeholder if Debug is disabled */\n#define DEBUG_PRINTLN(...)                                                     \\\n  {} /**< Debug Print Line Placeholder if Debug is disabled */\n#endif\n\n/* Define types of sensors. */\nstatic const uint8_t DHT11{11};  /**< DHT TYPE 11 */\nstatic const uint8_t DHT12{12};  /**< DHY TYPE 12 */\nstatic const uint8_t DHT21{21};  /**< DHT TYPE 21 */\nstatic const uint8_t DHT22{22};  /**< DHT TYPE 22 */\nstatic const uint8_t AM2301{21}; /**< AM2301 */\n\n#if defined(TARGET_NAME) && (TARGET_NAME == ARDUINO_NANO33BLE)\n#ifndef microsecondsToClockCycles\n/*!\n * As of 7 Sep 2020 the Arduino Nano 33 BLE boards do not have\n * microsecondsToClockCycles defined.\n */\n#define microsecondsToClockCycles(a) ((a) * (SystemCoreClock / 1000000L))\n#endif\n#endif\n\n/*!\n *  @brief  Class that stores state and functions for DHT\n */\nclass DHT {\npublic:\n  DHT(uint8_t pin, uint8_t type, uint8_t count = 6);\n  void begin(uint8_t usec = 55);\n  float readTemperature(bool S = false, bool force = false);\n  float convertCtoF(float);\n  float convertFtoC(float);\n  float computeHeatIndex(bool isFahrenheit = true);\n  float computeHeatIndex(float temperature, float percentHumidity,\n                         bool isFahrenheit = true);\n  float readHumidity(bool force = false);\n  bool read(bool force = false);\n\nprivate:\n  uint8_t data[5];\n  uint8_t _pin, _type;\n#ifdef __AVR\n  // Use direct GPIO access on an 8-bit AVR so keep track of the port and\n  // bitmask for the digital pin connected to the DHT.  Other platforms will use\n  // digitalRead.\n  uint8_t _bit, _port;\n#endif\n  uint32_t _lastreadtime, _maxcycles;\n  bool _lastresult;\n  uint8_t pullTime; // Time (in usec) to pull up data line before reading\n\n  uint32_t expectPulse(bool level);\n};\n\n/*!\n *  @brief  Class that defines Interrupt Lock Avaiability\n */\nclass InterruptLock {\npublic:\n  InterruptLock() {\n#if !defined(ARDUINO_ARCH_NRF52)\n    noInterrupts();\n#endif\n  }\n  ~InterruptLock() {\n#if !defined(ARDUINO_ARCH_NRF52)\n    interrupts();\n#endif\n  }\n};\n\n#endif\n"
        },
        {
          "name": "DHT_U.cpp",
          "type": "blob",
          "size": 6.287109375,
          "content": "/*!\n *  @file DHT_U.cpp\n *\n *  Temperature & Humidity Unified Sensor Library\n *\n *  This is a library for DHT series of low cost temperature/humidity sensors.\n *\n *  You must have Adafruit Unified Sensor Library library installed to use this\n * class.\n *\n *  Adafruit invests time and resources providing this open source code,\n *  please support Adafruit andopen-source hardware by purchasing products\n *  from Adafruit!\n */\n#include \"DHT_U.h\"\n\n/*!\n *  @brief  Instantiates a new DHT_Unified class\n *  @param  pin\n *          pin number that sensor is connected\n *  @param  type\n *          type of sensor\n *  @param  count\n *          number of sensors\n *  @param  tempSensorId\n *          temperature sensor id\n *  @param  humiditySensorId\n *          humidity sensor id\n */\nDHT_Unified::DHT_Unified(uint8_t pin, uint8_t type, uint8_t count,\n                         int32_t tempSensorId, int32_t humiditySensorId)\n    : _dht(pin, type, count), _type(type), _temp(this, tempSensorId),\n      _humidity(this, humiditySensorId) {}\n\n/*!\n *  @brief  Setup sensor (calls begin on It)\n */\nvoid DHT_Unified::begin() { _dht.begin(); }\n\n/*!\n *  @brief  Sets sensor name\n *  @param  sensor\n *          Sensor that will be set\n */\nvoid DHT_Unified::setName(sensor_t *sensor) {\n  switch (_type) {\n  case DHT11:\n    strncpy(sensor->name, \"DHT11\", sizeof(sensor->name) - 1);\n    break;\n  case DHT12:\n    strncpy(sensor->name, \"DHT12\", sizeof(sensor->name) - 1);\n    break;\n  case DHT21:\n    strncpy(sensor->name, \"DHT21\", sizeof(sensor->name) - 1);\n    break;\n  case DHT22:\n    strncpy(sensor->name, \"DHT22\", sizeof(sensor->name) - 1);\n    break;\n  default:\n    // TODO: Perhaps this should be an error?  However main DHT library doesn't\n    // enforce restrictions on the sensor type value.  Pick a generic name for\n    // now.\n    strncpy(sensor->name, \"DHT?\", sizeof(sensor->name) - 1);\n    break;\n  }\n  sensor->name[sizeof(sensor->name) - 1] = 0;\n}\n\n/*!\n *  @brief  Sets Minimum Delay Value\n *  @param  sensor\n *          Sensor that will be set\n */\nvoid DHT_Unified::setMinDelay(sensor_t *sensor) {\n  switch (_type) {\n  case DHT11:\n    sensor->min_delay = 1000000L; // 1 second (in microseconds)\n    break;\n  case DHT12:\n    sensor->min_delay = 2000000L; // 2 second (in microseconds)\n    break;\n  case DHT21:\n    sensor->min_delay = 2000000L; // 2 seconds (in microseconds)\n    break;\n  case DHT22:\n    sensor->min_delay = 2000000L; // 2 seconds (in microseconds)\n    break;\n  default:\n    // Default to slowest sample rate in case of unknown type.\n    sensor->min_delay = 2000000L; // 2 seconds (in microseconds)\n    break;\n  }\n}\n\n/*!\n *  @brief  Instantiates a new DHT_Unified Temperature Class\n *  @param  parent\n *          Parent Sensor\n *  @param  id\n *          Sensor id\n */\nDHT_Unified::Temperature::Temperature(DHT_Unified *parent, int32_t id)\n    : _parent(parent), _id(id) {}\n\n/*!\n *  @brief  Reads the sensor and returns the data as a sensors_event_t\n *  @param  event\n *  @return always returns true\n */\nbool DHT_Unified::Temperature::getEvent(sensors_event_t *event) {\n  // Clear event definition.\n  memset(event, 0, sizeof(sensors_event_t));\n  // Populate sensor reading values.\n  event->version = sizeof(sensors_event_t);\n  event->sensor_id = _id;\n  event->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;\n  event->timestamp = millis();\n  event->temperature = _parent->_dht.readTemperature();\n\n  return true;\n}\n\n/*!\n *  @brief  Provides the sensor_t data for this sensor\n *  @param  sensor\n */\nvoid DHT_Unified::Temperature::getSensor(sensor_t *sensor) {\n  // Clear sensor definition.\n  memset(sensor, 0, sizeof(sensor_t));\n  // Set sensor name.\n  _parent->setName(sensor);\n  // Set version and ID\n  sensor->version = DHT_SENSOR_VERSION;\n  sensor->sensor_id = _id;\n  // Set type and characteristics.\n  sensor->type = SENSOR_TYPE_AMBIENT_TEMPERATURE;\n  _parent->setMinDelay(sensor);\n  switch (_parent->_type) {\n  case DHT11:\n    sensor->max_value = 50.0F;\n    sensor->min_value = 0.0F;\n    sensor->resolution = 2.0F;\n    break;\n  case DHT12:\n    sensor->max_value = 60.0F;\n    sensor->min_value = -20.0F;\n    sensor->resolution = 0.5F;\n    break;\n  case DHT21:\n    sensor->max_value = 80.0F;\n    sensor->min_value = -40.0F;\n    sensor->resolution = 0.1F;\n    break;\n  case DHT22:\n    sensor->max_value = 125.0F;\n    sensor->min_value = -40.0F;\n    sensor->resolution = 0.1F;\n    break;\n  default:\n    // Unknown type, default to 0.\n    sensor->max_value = 0.0F;\n    sensor->min_value = 0.0F;\n    sensor->resolution = 0.0F;\n    break;\n  }\n}\n\n/*!\n *  @brief  Instantiates a new DHT_Unified Humidity Class\n *  @param  parent\n *          Parent Sensor\n *  @param  id\n *          Sensor id\n */\nDHT_Unified::Humidity::Humidity(DHT_Unified *parent, int32_t id)\n    : _parent(parent), _id(id) {}\n\n/*!\n *  @brief  Reads the sensor and returns the data as a sensors_event_t\n *  @param  event\n *  @return always returns true\n */\nbool DHT_Unified::Humidity::getEvent(sensors_event_t *event) {\n  // Clear event definition.\n  memset(event, 0, sizeof(sensors_event_t));\n  // Populate sensor reading values.\n  event->version = sizeof(sensors_event_t);\n  event->sensor_id = _id;\n  event->type = SENSOR_TYPE_RELATIVE_HUMIDITY;\n  event->timestamp = millis();\n  event->relative_humidity = _parent->_dht.readHumidity();\n\n  return true;\n}\n\n/*!\n *  @brief  Provides the sensor_t data for this sensor\n *  @param  sensor\n */\nvoid DHT_Unified::Humidity::getSensor(sensor_t *sensor) {\n  // Clear sensor definition.\n  memset(sensor, 0, sizeof(sensor_t));\n  // Set sensor name.\n  _parent->setName(sensor);\n  // Set version and ID\n  sensor->version = DHT_SENSOR_VERSION;\n  sensor->sensor_id = _id;\n  // Set type and characteristics.\n  sensor->type = SENSOR_TYPE_RELATIVE_HUMIDITY;\n  _parent->setMinDelay(sensor);\n  switch (_parent->_type) {\n  case DHT11:\n    sensor->max_value = 80.0F;\n    sensor->min_value = 20.0F;\n    sensor->resolution = 5.0F;\n    break;\n  case DHT12:\n    sensor->max_value = 95.0F;\n    sensor->min_value = 20.0F;\n    sensor->resolution = 5.0F;\n    break;\n  case DHT21:\n    sensor->max_value = 100.0F;\n    sensor->min_value = 0.0F;\n    sensor->resolution = 0.1F;\n    break;\n  case DHT22:\n    sensor->max_value = 100.0F;\n    sensor->min_value = 0.0F;\n    sensor->resolution = 0.1F;\n    break;\n  default:\n    // Unknown type, default to 0.\n    sensor->max_value = 0.0F;\n    sensor->min_value = 0.0F;\n    sensor->resolution = 0.0F;\n    break;\n  }\n}\n"
        },
        {
          "name": "DHT_U.h",
          "type": "blob",
          "size": 3.0078125,
          "content": "/*!\r\n *  @file DHT_U.h\r\n *\r\n *  DHT Temperature & Humidity Unified Sensor Library<Paste>\r\n *\r\n *  Adafruit invests time and resources providing this open source code,\r\n *  please support Adafruit andopen-source hardware by purchasing products\r\n *  from Adafruit!\r\n *\r\n *  Written by Tony DiCola (Adafruit Industries) 2014.\r\n *\r\n *  MIT license, all text above must be included in any redistribution\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"Software\"), to\r\n * deal in the Software without restriction, including without limitation the\r\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n * sell copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n * IN THE SOFTWARE.\r\n */\r\n\r\n#ifndef DHT_U_H\r\n#define DHT_U_H\r\n\r\n#include <Adafruit_Sensor.h>\r\n#include <DHT.h>\r\n\r\n#define DHT_SENSOR_VERSION 1 /**< Sensor Version */\r\n\r\n/*!\r\n *  @brief  Class that stores state and functions for interacting with\r\n * DHT_Unified.\r\n */\r\nclass DHT_Unified {\r\npublic:\r\n  DHT_Unified(uint8_t pin, uint8_t type, uint8_t count = 6,\r\n              int32_t tempSensorId = -1, int32_t humiditySensorId = -1);\r\n  void begin();\r\n\r\n  /*!\r\n   *  @brief  Class that stores state and functions about Temperature\r\n   */\r\n  class Temperature : public Adafruit_Sensor {\r\n  public:\r\n    Temperature(DHT_Unified *parent, int32_t id);\r\n    bool getEvent(sensors_event_t *event);\r\n    void getSensor(sensor_t *sensor);\r\n\r\n  private:\r\n    DHT_Unified *_parent;\r\n    int32_t _id;\r\n  };\r\n\r\n  /*!\r\n   *  @brief  Class that stores state and functions about Humidity\r\n   */\r\n  class Humidity : public Adafruit_Sensor {\r\n  public:\r\n    Humidity(DHT_Unified *parent, int32_t id);\r\n    bool getEvent(sensors_event_t *event);\r\n    void getSensor(sensor_t *sensor);\r\n\r\n  private:\r\n    DHT_Unified *_parent;\r\n    int32_t _id;\r\n  };\r\n\r\n  /*!\r\n   *  @brief  Returns temperature stored in _temp\r\n   *  @return Temperature value\r\n   */\r\n  Temperature temperature() { return _temp; }\r\n\r\n  /*!\r\n   *  @brief  Returns humidity stored in _humidity\r\n   *  @return Humidity value\r\n   */\r\n  Humidity humidity() { return _humidity; }\r\n\r\nprivate:\r\n  DHT _dht;\r\n  uint8_t _type;\r\n  Temperature _temp;\r\n  Humidity _humidity;\r\n\r\n  void setName(sensor_t *sensor);\r\n  void setMinDelay(sensor_t *sensor);\r\n};\r\n\r\n#endif\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.68359375,
          "content": "# DHT sensor library [![Build Status](https://github.com/adafruit/DHT-sensor-library/workflows/Arduino%20Library%20CI/badge.svg)](https://github.com/adafruit/DHT-sensor-library/actions)\n\n## Description\n\nAn Arduino library for the DHT series of low-cost temperature/humidity sensors.\n\nYou can find DHT tutorials [here](https://learn.adafruit.com/dht).\n\n# Dependencies\n * [Adafruit Unified Sensor Driver](https://github.com/adafruit/Adafruit_Sensor)\n\n# Contributing\n\nContributions are welcome!  Not only you’ll encourage the development of the library, but you’ll also learn how to best use the library and probably some C++ too\n\nPlease read our [Code of Conduct](https://github.com/adafruit/DHT-sensor-library/blob/master/CODE_OF_CONDUCT.md>)\nbefore contributing to help this project stay welcoming.\n\n## Documentation and doxygen\nDocumentation is produced by doxygen. Contributions should include documentation for any new code added.\n\nSome examples of how to use doxygen can be found in these guide pages:\n\nhttps://learn.adafruit.com/the-well-automated-arduino-library/doxygen\n\nhttps://learn.adafruit.com/the-well-automated-arduino-library/doxygen-tips\n\nWritten by Adafruit Industries based on work by:\n\n * T. DiCola\n * P. Y. Dragon\n * L. Fried\n * J. Hoffmann\n * M. Kooijman\n * J. M. Dana\n * S. Conaway\n * S. IJskes\n * T. Forbes\n * B. C\n * T. J Myers\n * L. Sørup\n * per1234\n * O. Duffy\n * matthiasdanner\n * J. Lim\n * G. Ambrozio\n * chelmi\n * adams13x13\n * Spacefish\n * I. Scheller\n * C. Miller\n * 7eggert\n\n\nMIT license, check license.txt for more information\nAll text above must be included in any redistribution\n\nTo install, use the Arduino Library Manager and search for \"DHT sensor library\" and install the library.\n"
        },
        {
          "name": "code-of-conduct.md",
          "type": "blob",
          "size": 5.6923828125,
          "content": "# Adafruit Community Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and leaders pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, gender identity and expression, level or type of\nexperience, education, socio-economic status, nationality, personal appearance,\nrace, religion, or sexual identity and orientation.\n\n## Our Standards\n\nWe are committed to providing a friendly, safe and welcoming environment for\nall.\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Be kind and courteous to others\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Collaborating with other community members\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and sexual attention or advances\n* The use of inappropriate images, including in a community member's avatar\n* The use of inappropriate language, including in a community member's nickname\n* Any spamming, flaming, baiting or other attention-stealing behavior\n* Excessive or unwelcome helping; answering outside the scope of the question\n  asked\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate\n\nThe goal of the standards and moderation guidelines outlined here is to build\nand maintain a respectful community. We ask that you don’t just aim to be\n\"technically unimpeachable\", but rather try to be your best self. \n\nWe value many things beyond technical expertise, including collaboration and\nsupporting others within our community. Providing a positive experience for\nother community members can have a much more significant impact than simply\nproviding the correct answer.\n\n## Our Responsibilities\n\nProject leaders are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject leaders have the right and responsibility to remove, edit, or\nreject messages, comments, commits, code, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any community member for other behaviors that they deem\ninappropriate, threatening, offensive, or harmful.\n\n## Moderation\n\nInstances of behaviors that violate the Adafruit Community Code of Conduct\nmay be reported by any member of the community. Community members are\nencouraged to report these situations, including situations they witness\ninvolving other community members.\n\nYou may report in the following ways:\n\nIn any situation, you may send an email to <support@adafruit.com>.\n\nOn the Adafruit Discord, you may send an open message from any channel\nto all Community Helpers by tagging @community helpers. You may also send an\nopen message from any channel, or a direct message to @kattni#1507,\n@tannewt#4653, @Dan Halbert#1614, @cater#2442, @sommersoft#0222, or\n@Andon#8175.\n\nEmail and direct message reports will be kept confidential.\n\nIn situations on Discord where the issue is particularly egregious, possibly\nillegal, requires immediate action, or violates the Discord terms of service,\nyou should also report the message directly to Discord.\n\nThese are the steps for upholding our community’s standards of conduct.\n\n1. Any member of the community may report any situation that violates the\nAdafruit Community Code of Conduct. All reports will be reviewed and\ninvestigated.\n2. If the behavior is an egregious violation, the community member who\ncommitted the violation may be banned immediately, without warning.\n3. Otherwise, moderators will first respond to such behavior with a warning.\n4. Moderators follow a soft \"three strikes\" policy - the community member may\nbe given another chance, if they are receptive to the warning and change their\nbehavior.\n5. If the community member is unreceptive or unreasonable when warned by a\nmoderator, or the warning goes unheeded, they may be banned for a first or\nsecond offense. Repeated offenses will result in the community member being\nbanned.\n\n## Scope\n\nThis Code of Conduct and the enforcement policies listed above apply to all\nAdafruit Community venues. This includes but is not limited to any community\nspaces (both public and private), the entire Adafruit Discord server, and\nAdafruit GitHub repositories. Examples of Adafruit Community spaces include\nbut are not limited to meet-ups, audio chats on the Adafruit Discord, or\ninteraction at a conference.\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. As a community\nmember, you are representing our community, and are expected to behave\naccordingly.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 1.4, available at\n<https://www.contributor-covenant.org/version/1/4/code-of-conduct.html>,\nand the [Rust Code of Conduct](https://www.rust-lang.org/en-US/conduct.html).\n\nFor other projects adopting the Adafruit Community Code of\nConduct, please contact the maintainers of those projects for enforcement.\nIf you wish to use this code of conduct for your own project, consider\nexplicitly mentioning your moderation policy or making a copy with your\nown moderation policy so as to avoid confusion.\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "keywords.txt",
          "type": "blob",
          "size": 0.5166015625,
          "content": "###########################################\n# Syntax Coloring Map For DHT-sensor-library\n###########################################\n\n###########################################\n# Datatypes (KEYWORD1)\n###########################################\n\nDHT\tKEYWORD1\n\n###########################################\n# Methods and Functions (KEYWORD2)\n###########################################\n\nbegin\tKEYWORD2\nreadTemperature\tKEYWORD2\nconvertCtoF\tKEYWORD2\nconvertFtoC\tKEYWORD2\ncomputeHeatIndex\tKEYWORD2\nreadHumidity\tKEYWORD2\nread\tKEYWORD2\n\n"
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.3447265625,
          "content": "name=DHT sensor library\nversion=1.4.6\nauthor=Adafruit\nmaintainer=Adafruit <info@adafruit.com>\nsentence=Arduino library for DHT11, DHT22, etc Temp & Humidity Sensors\nparagraph=Arduino library for DHT11, DHT22, etc Temp & Humidity Sensors\ncategory=Sensors\nurl=https://github.com/adafruit/DHT-sensor-library\narchitectures=*\ndepends=Adafruit Unified Sensor\n"
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 1.0390625,
          "content": "Copyright (c) 2020 Adafruit Industries\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\nOR OTHER DEALINGS IN THE SOFTWARE.\n"
        }
      ]
    }
  ]
}