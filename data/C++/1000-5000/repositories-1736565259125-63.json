{
  "metadata": {
    "timestamp": 1736565259125,
    "page": 63,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yedf2/handy",
      "stars": 4562,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.15625,
          "content": "BasedOnStyle: Chromium\nColumnLimit: 160\nIndentWidth: 4\nDerivePointerAlignment: false\nIndentCaseLabels: false\nPointerAlignment: Right\nSpaceAfterCStyleCast: true\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5478515625,
          "content": "handy.*\n*.cbp\n*.o\n*.a\na*\n*.mk\n*.pb.*\nssl\nopenssl-example\n*/*.dSYM\n.*\nCMake*\n10m/10m-cli\n10m/10m-svr\nexamples/chat\nexamples/cli\nexamples/codec-cli\nexamples/codec-svr\nexamples/daemon\nexamples/echo\nexamples/hsha\nexamples/http-echo\nexamples/log\nexamples/stat\nexamples/write-on-empty\nexamples/http-hello\nexamples/idle-close\nexamples/reconnect\nexamples/safe-close\nexamples/timer\nexamples/udp-cli\nexamples/udp-svr\nexamples/udp-hsha\nraw-examples/epoll\nraw-examples/epoll-et\nraw-examples/kqueue\nhandy_test\nprotobuf/middle\nprotobuf/test\nbuild/\n# Clion\ncmake-build-debug/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.724609375,
          "content": "sudo: required\n\nlanguage: cpp\ncompiler: g++\n\nmatrix:\n  include:\n    # Job1: This is the job of building project in linux os.\n    - os: linux\n      dist: jammy\n      before_install:\n        - sudo add-apt-repository -y ppa:ubuntu-toolchain-r/test\n        - sudo apt-get update -qq\n      install:\n        - sudo apt-get install -qq g++-4.8\n        - export CXX=\"g++-4.8\"\n      script: make && sudo ./handy_test\n      notifications:\n        email: true\n\n      # Job2: This is the job of checking code style.\n    - os: linux\n      dist: focal\n      env: LINT=1\n      before_install:\n        - sudo apt-get update\n        - sudo apt-get install clang-format-11\n      install: []\n      script:\n        - sudo bash .travis/check-git-clang-format.sh\n"
        },
        {
          "name": ".travis",
          "type": "tree",
          "content": null
        },
        {
          "name": "10m",
          "type": "tree",
          "content": null
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 4.2529296875,
          "content": "cmake_minimum_required(VERSION 3.2)\nproject(handy)\n\nset(CMAKE_CXX_STANDARD 11)\n\ninclude(GNUInstallDirs)\n\nfind_package(Threads REQUIRED)\n\nlist(APPEND HANDY_SRCS\n    ${PROJECT_SOURCE_DIR}/handy/daemon.cc\n    ${PROJECT_SOURCE_DIR}/handy/net.cc\n    ${PROJECT_SOURCE_DIR}/handy/codec.cc\n    ${PROJECT_SOURCE_DIR}/handy/http.cc\n    ${PROJECT_SOURCE_DIR}/handy/conn.cc\n    ${PROJECT_SOURCE_DIR}/handy/poller.cc\n    ${PROJECT_SOURCE_DIR}/handy/udp.cc\n    ${PROJECT_SOURCE_DIR}/handy/threads.cc\n    ${PROJECT_SOURCE_DIR}/handy/file.cc\n    ${PROJECT_SOURCE_DIR}/handy/util.cc\n    ${PROJECT_SOURCE_DIR}/handy/conf.cc\n    ${PROJECT_SOURCE_DIR}/handy/stat-svr.cc\n    ${PROJECT_SOURCE_DIR}/handy/port_posix.cc\n    ${PROJECT_SOURCE_DIR}/handy/event_base.cc\n    ${PROJECT_SOURCE_DIR}/handy/logging.cc)\n\nif(CMAKE_HOST_APPLE)\n    add_definitions(-DOS_MACOSX)\nelseif(CMAKE_HOST_UNIX)\n    add_definitions(-DOS_LINUX)\nelse(CMAKE_HOST_APPLE)\n    message(FATAL_ERROR \"Platform not supported\")\nendif(CMAKE_HOST_APPLE)\n\noption(BUILD_HANDY_SHARED_LIBRARY \"Build Handy Shared Library\" OFF)\noption(BUILD_HANDY_STATIC_LIBRARY \"Build Handy Shared Library\" ON)\noption(BUILD_HANDY_EXAMPLES \"Build Handy Examples\" OFF)\n\n##Handy Shared Library\nif(BUILD_HANDY_SHARED_LIBRARY)\n    add_library(handy SHARED ${HANDY_SRCS})\n    target_include_directories(handy PUBLIC ${PROJECT_SOURCE_DIR}/handy)\n    target_link_libraries(handy Threads::Threads)\n    install(TARGETS handy DESTINATION ${CMAKE_INSTALL_LIBDIR})\nendif(BUILD_HANDY_SHARED_LIBRARY)\n\n#Handy Static library\nif(BUILD_HANDY_STATIC_LIBRARY)\n    add_library(handy_s STATIC ${HANDY_SRCS})\n    target_include_directories(handy_s PUBLIC ${PROJECT_SOURCE_DIR}/handy/)\n    target_link_libraries(handy_s Threads::Threads)\n    install(TARGETS handy_s DESTINATION ${CMAKE_INSTALL_LIBDIR})\nendif(BUILD_HANDY_STATIC_LIBRARY)\n\nif(BUILD_HANDY_SHARED_LIBRARY OR BUILD_HANDY_STATIC_LIBRARY)\n    install(FILES \n        ${PROJECT_SOURCE_DIR}/handy/codec.h\n        ${PROJECT_SOURCE_DIR}/handy/conf.h\n        ${PROJECT_SOURCE_DIR}/handy/conn.h\n        ${PROJECT_SOURCE_DIR}/handy/daemon.h\n        ${PROJECT_SOURCE_DIR}/handy/event_base.h\n        ${PROJECT_SOURCE_DIR}/handy/file.h\n        ${PROJECT_SOURCE_DIR}/handy/handy.h\n        ${PROJECT_SOURCE_DIR}/handy/handy-imp.h\n        ${PROJECT_SOURCE_DIR}/handy/http.h\n        ${PROJECT_SOURCE_DIR}/handy/logging.h\n        ${PROJECT_SOURCE_DIR}/handy/net.h\n        ${PROJECT_SOURCE_DIR}/handy/poller.h\n        ${PROJECT_SOURCE_DIR}/handy/port_posix.h\n        ${PROJECT_SOURCE_DIR}/handy/slice.h\n        ${PROJECT_SOURCE_DIR}/handy/stat-svr.h\n        ${PROJECT_SOURCE_DIR}/handy/status.h\n        ${PROJECT_SOURCE_DIR}/handy/threads.h\n        ${PROJECT_SOURCE_DIR}/handy/udp.h\n        ${PROJECT_SOURCE_DIR}/handy/util.h\n        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/handy)\nendif(BUILD_HANDY_SHARED_LIBRARY OR BUILD_HANDY_STATIC_LIBRARY)\n\n\nfunction(add_handy_executable EXECUTABLE_NAME EXECUTABLE_SOURCES)\n    add_executable(${EXECUTABLE_NAME} ${EXECUTABLE_SOURCES})\n    target_link_libraries(${EXECUTABLE_NAME} handy_s)\n    target_include_directories(${EXECUTABLE_NAME} PUBLIC ${PROJECT_SOURCE_DIR})\n    install(TARGETS ${EXECUTABLE_NAME} DESTINATION ${CMAKE_INSTALL_BINDIR})\nendfunction(add_handy_executable)\n\n\nif(BUILD_HANDY_EXAMPLES)\n    add_handy_executable(codec-cli examples/codec-cli.cc)\n    add_handy_executable(codec-svr examples/codec-svr.cc)\n    add_handy_executable(daemon examples/daemon.cc)\n    add_handy_executable(echo examples/echo.cc)\n    add_handy_executable(hsha examples/hsha.cc)\n    add_handy_executable(http-hello examples/http-hello.cc)\n    add_handy_executable(idle-close examples/idle-close.cc)\n    add_handy_executable(reconnect examples/reconnect.cc)\n    add_handy_executable(safe-close examples/safe-close.cc)\n    add_handy_executable(stat examples/stat.cc)\n    add_handy_executable(timer examples/timer.cc)\n    add_handy_executable(udp-cli examples/udp-cli.cc)\n    add_handy_executable(udp-hsha examples/udp-hsha.cc)\n    add_handy_executable(udp-svr examples/udp-svr.cc)\n    add_handy_executable(write-on-empty examples/write-on-empty.cc)\n    add_handy_executable(10m-cli 10m/10m-cli.cc)\n    add_handy_executable(10m-svr 10m/10m-svr.cc)\n\n    if(CMAKE_HOST_APPLE)\n        add_handy_executable(kqueue raw-examples/kqueue.cc)\n    endif(CMAKE_HOST_APPLE)\nendif(BUILD_HANDY_EXAMPLES)\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 0.150390625,
          "content": "2014-08-03 yedongfu dongfuye@163.com\n  * start to work\n  * version 0.1.0\n\n2019-05-17 Qing Wang kingchin1218@gmail.com\n  * Some bug fix\n  * version 0.2.0\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2568359375,
          "content": "Copyright (c) 2014, yedf\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.4541015625,
          "content": "#OPT ?= -O2 -DNDEBUG\n# (B) Debug mode, w/ full line-level debugging symbols\nOPT ?= -g2\n# (C) Profiling mode: opt, but w/debugging symbols\n# OPT ?= -O2 -g2 -DNDEBUG\n$(shell CC=\"$(CC)\" CXX=\"$(CXX)\" TARGET_OS=\"$(TARGET_OS)\" ./build_config 1>&2)\ninclude config.mk\n\nCFLAGS += -I. $(PLATFORM_CCFLAGS) $(OPT)\nCXXFLAGS += -I. $(PLATFORM_CXXFLAGS) $(OPT)\n\nLDFLAGS += $(PLATFORM_LDFLAGS)\nLIBS += $(PLATFORM_LIBS)\n\nHANDY_SOURCES += $(shell find handy -name '*.cc')\nHANDY_OBJECTS = $(HANDY_SOURCES:.cc=.o)\n\nTEST_SOURCES = $(shell find test -name '*.cc')\nTEST_OBJECTS = $(TEST_SOURCES:.cc=.o)\n\nEXAMPLE_SOURCES += $(shell find examples -name '*.cc')\nEXAMPLES = $(EXAMPLE_SOURCES:.cc=)\n\nKW_SOURCES += $(shell find 10m -name '*.cc')\nKW = $(KW_SOURCES:.cc=)\n\nLIBRARY = libhandy.a\n\nTARGETS = $(LIBRARY) handy_test $(EXAMPLES) $(KW)\n\ndefault: $(TARGETS)\nhandy_examples: $(EXAMPLES)\n$(EXAMPLES): $(LIBRARY)\n$(KW): $(LIBRARY)\n\ninstall: libhandy.a\n\tmkdir -p $(PREFIX)/usr/local/include/handy\n\tcp -f handy/*.h $(PREFIX)/usr/local/include/handy\n\tcp -f libhandy.a $(PREFIX)/usr/local/lib\n\nuninstall:\n\trm -rf $(PREFIX)/usr/local/include/handy $(PREFIX)/usr/local/lib/libhandy.a\nclean:\n\t\t\t-rm -f $(TARGETS)\n\t\t\t-rm -f */*.o\n\n$(LIBRARY): $(HANDY_OBJECTS)\n\t\trm -f $@\n\t\t\t$(AR) -rs $@ $(HANDY_OBJECTS)\n\nhandy_test: $(TEST_OBJECTS) $(LIBRARY)\n\t$(CXX) $^ -o $@ $(LDFLAGS) $(LIBS)\n\n.cc.o:\n\t\t$(CXX) $(CXXFLAGS) -c $< -o $@\n\n.c.o:\n\t\t$(CC) $(CFLAGS) -c $< -o $@\n\n.cc:\n\t$(CXX) -o $@ $< $(CXXFLAGS) $(LDFLAGS) $(LIBRARY) $(LIBS)\n"
        },
        {
          "name": "README-en.md",
          "type": "blob",
          "size": 2.8486328125,
          "content": "handy[![Build Status](https://travis-ci.org/yedf2/handy.png)](https://travis-ci.org/yedf2/handy)\n====\n[中文版](https://github.com/yedf/handy/blob/master/README.md)\n## A C++11 non-blocking network library\n\n### multi platform support\n\n*   Linux: ubuntu14 64bit g++4.8.1 tested\n\n*   MacOSX: LLVM version 6.1.0 tested\n\n### elegant program exit\n\nprogrammer can write operations for exit\n\ncan use valgrind to check memory leak\n\n### high performance\n\n*   use epoll on Linux\n\n*   use kqueue on MacOSX\n\n[performance report](http://www.oschina.net/p/c11-handy)\n### elegant\n\nonly 10 lines can finish a complete server\n\n## Usage\n\n### Quick start\n```\n make && make install\n```\n\n### sample --echo-server\n\n```c\n#include <handy/handy.h>\nusing namespace handy;\n\nint main(int argc, const char* argv[]) {\n    EventBase base;\n    Signal::signal(SIGINT, [&]{ base.exit(); });\n    TcpServerPtr svr = TcpServer::startServer(&base, \"\", 2099);\n    exitif(svr == NULL, \"start tcp server failed\");\n    svr->onConnRead([](const TcpConnPtr& con) {\n        con->send(con->getInput());\n    });\n    base.loop();\n}\n```\n\n### half sync half async pattern\n\nprocessing I/O asynchronously and Request synchronously can greatly simplify the coding of business processing\n\nexample can be found examples/hsha.cc\n\n### openssl supported\n\nasynchronously handle the openssl connection. if you have installed openssl, then make will automatically download handy-ssl.\nssl support files are in [handy-ssl](https://github.com/yedf/handy-ssl.git) because of license.\n\n### protobuf supported\n\nexamples can be found in directory protobuf\n\n### contents\n\n*   handy--------handy library\n*   examples----\n*   ssl------------openssl support and examples\n*   protobuf-----protobuf support and examples\n*   test-----------handy test case\n\n### [hand book](https://github.com/yedf/handy/blob/master/doc-cn.md)\n\n## Advanced build option\n\n### Build handy shared library and examples:\n```\n$ git clone https://github.com/yedf/handy\n$ cd handy && mkdir build && cd build\n$ cmake -DBUILD_HANDY_SHARED_LIBRARY=ON -DBUILD_HANDY_EXAMPLES=ON -DCMAKE_INSTALL_PREFIX=/tmp/handy ..\n$ make -j4\n$ make install\n$ ls /tmp/handy\nbin  include  lib64\n$ ls /tmp/handy/bin/\n10m-cli  10m-svr  codec-cli  codec-svr  daemon  echo  hsha  http-hello  idle-close  reconnect  safe-close  stat  timer  udp-cli  udp-hsha  udp-svr  write-on-empty\n$ ls /tmp/handy/lib64/\nlibhandy_s.a  libhandy.so\n```\n\n### As a static library in your own programs:\n* add handy as a git submodule to say a folder called vendor\n* in your CMakeLists.txt\n\n```\nadd_subdirectory(\"vendor/handy\" EXCLUDE_FROM_ALL)\n\nadd_executable(${PROJECT_NAME} main.cpp)\n\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    \"vendor/handy\"\n)\n\ntarget_link_libraries(${PROJECT_NAME} PUBLIC\n    handy_s\n)\n```\n\nlicense\n====\nUse of this source code is governed by a BSD-style\nlicense that can be found in the License file.\n\nemail\n====\ndongfuye@163.com\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.2646484375,
          "content": "handy[![Build Status](https://travis-ci.org/yedf2/handy.png)](https://travis-ci.org/yedf2/handy)\n====\n[English](https://github.com/yedf/handy/blob/master/README-en.md)\n\n## 简洁易用的C++11网络库\n\n### 多平台支持\n\n*   Linux: ubuntu14 64bit g++4.8.1 上测试通过\n\n*   MacOSX: LLVM version 6.1.0 上测试通过\n\n*   MacOSX: 支持CLion IDE\n\n### 支持优雅退出\n\n优雅退出可以让程序员更好的定义自己程序的退出行为\n\n能够更好的借助valgrind等工具检查内存泄露。\n\n### 高性能\n\n*   linux上使用epoll\n*   MacOSX上使用kqueue\n*   [性能测试报告](http://www.oschina.net/p/c11-handy)\n*   [单机千万并发连接](https://zhuanlan.zhihu.com/p/21378825)\n\n### 简洁\n\n10行代码能够编写一个完整的服务器\n\n### 代码示例--echo-server\n\n```c\n#include <handy/handy.h>\nusing namespace handy;\n\nint main(int argc, const char* argv[]) {\n    EventBase base;\n    Signal::signal(SIGINT, [&]{ base.exit(); });\n    TcpServerPtr svr = TcpServer::startServer(&base, \"\", 2099);\n    exitif(svr == NULL, \"start tcp server failed\");\n    svr->onConnRead([](const TcpConnPtr& con) {\n        con->send(con->getInput());\n    });\n    base.loop();\n}\n```\n\n### 支持半同步半异步处理\n\n异步管理网络I/O，同步处理请求，可以简化服务器处理逻辑的编写，示例参见examples/hsha.cc\n\n### openssl支持\n\n异步连接管理，支持openssl连接，如果实现安装了openssl，能够找到<openssl/ssl.h>，项目会自动下载handy-ssl\n由于openssl的开源协议与此不兼容，所以项目文件单独放在[handy-ssl](https://github.com/yedf/handy-ssl.git)\n\n### protobuf支持\n\n使用protobuf的消息encode/decode示例在protobuf下\n\n### udp支持\n\n支持udp，udp的客户端采用connect方式使用，类似tcp\n\n### 安装与使用\n\n    make && make install\n\n### 目录结构\n\n*   handy--------handy库\n*   10m----------进行千万并发连接测试所使用的程序\n*   examples----示例\n*   raw-examples--原生api使用示例，包括了epoll，epoll ET模式，kqueue示例\n*   ssl------------openssl相关的代码与示例\n*   protobuf-----handy使用protobuf的示例\n*   test-----------handy相关的测试\n\n### [使用文档](https://github.com/yedf/handy/blob/master/doc.md)\n\n### raw-examples\n使用os提供的api如epoll，kqueue编写并发应用程序\n*   epoll.cc，演示了epoll的通常用法，使用epoll的LT模式\n*   epoll-et.cc，演示了epoll的ET模式，与LT模式非常像，区别主要体现在不需要手动开关EPOLLOUT事件\n\n### examples\n使用handy的示例\n*   echo.cc 简单的回显服务\n*   timer.cc 使用定时器来管理定时任务\n*   idle-close.cc 关闭一个空闲的连接\n*   reconnect.cc 设置连接关闭后自动重连\n*   safe-close.cc 在其他线程中安全操作连接\n*   chat.cc 简单的聊天应用，用户使用telnet登陆后，系统分配一个用户id，用户可以发送消息给某个用户，也可以发送消息给所有用户\n*   codec-cli.cc 发送消息给服务器，使用的消息格式为mBdT开始，紧接着4字节的长度，然后是消息内容\n*   codec-svr.cc 见上\n*   hsha.cc 半同步半异步示例，用户可以把IO交给handy框架进行处理，自己同步处理用户请求\n*   http-hello.cc 一个简单的http服务器程序\n*   stat.cc 一个简单的状态服务器示例，一个内嵌的http服务器，方便外部的工具查看应用程序的状态\n*   write-on-empty.cc 这个例子演示了需要写出大量数据，例如1G文件这种情景中的使用技巧\n*   daemon.cc 程序已以daemon方式启动，从conf文件中获取日志相关的配置，并初始化日志参数\n*   udp-cli.cc udp的客户端\n*   udp-svr.cc udp服务器\n*   udp-hsha.cc udp的半同步半异步服务器\n\nlicense\n====\nUse of this source code is governed by a BSD-style\nlicense that can be found in the License file.\n\nemail\n====\ndongfuye@163.com\n\n微信交流群\n====\n如果您希望更快的获得反馈，或者更多的了解其他用户在使用过程中的各种反馈，欢迎加入我们的微信交流群\n\n请加作者的微信 yedf2008 好友或者扫码加好友，备注 `handy` 按照指引进群\n\n![yedf2008](http://service.ivydad.com/cover/dubbingb6b5e2c0-2d2a-cd59-f7c5-c6b90aceb6f1.jpeg)\n\n如果您觉得此项目不错，或者对您有帮助，请赏颗星吧！\n"
        },
        {
          "name": "build_config",
          "type": "blob",
          "size": 5.6318359375,
          "content": "#!/bin/sh\n#\n# Detects OS we're compiling on and outputs a file specified by the first\n# argument, which in turn gets read while processing Makefile.\n#\n# The output will set the following variables:\n#   CC                          C Compiler path\n#   CXX                         C++ Compiler path\n#   PLATFORM_LDFLAGS            Linker flags\n#   PLATFORM_LIBS               Libraries flags\n#   PLATFORM_SHARED_EXT         Extension for shared libraries\n#   PLATFORM_SHARED_LDFLAGS     Flags for building shared library\n#                               This flag is embedded just before the name\n#                               of the shared library without intervening spaces\n#   PLATFORM_SHARED_CFLAGS      Flags for compiling objects for shared library\n#   PLATFORM_CCFLAGS            C compiler flags\n#   PLATFORM_CXXFLAGS           C++ compiler flags.  Will contain:\n#   PLATFORM_SHARED_VERSIONED   Set to 'true' if platform supports versioned\n#                               shared libraries, empty otherwise.\n#\n\nOUTPUT=config.mk\n# Delete existing output, if it exists\nrm -f $OUTPUT\ntouch $OUTPUT\n\nif test -z \"$CC\"; then\n    CC=cc\nfi\n\nif test -z \"$CXX\"; then\n    CXX=g++\nfi\n\nif test -z \"$TMPDIR\"; then\n    TMPDIR=/tmp\nfi\n\n# Detect OS\nif test -z \"$TARGET_OS\"; then\n    TARGET_OS=`uname -s`\nfi\nCOMMON_FLAGS=\nCROSS_COMPILE=\nPLATFORM_CCFLAGS=\nPLATFORM_CXXFLAGS=\nPLATFORM_LDFLAGS=\nPLATFORM_LIBS=\nPLATFORM_SHARED_EXT=\"so\"\nPLATFORM_SHARED_LDFLAGS=\"-shared -Wl,-soname -Wl,\"\nPLATFORM_SHARED_CFLAGS=\"-fPIC\"\nPLATFORM_SHARED_VERSIONED=true\n\ncase \"$TARGET_OS\" in\n    CYGWIN_*)\n        PLATFORM=OS_LINUX\n        COMMON_FLAGS=\"$MEMCMP_FLAG -lpthread -DOS_LINUX -DCYGWIN\"\n        PLATFORM_LDFLAGS=\"-lpthread\"\n        PORT_FILE=port/port_posix.cc\n        ;;\n    Darwin)\n        PLATFORM=OS_MACOSX\n        COMMON_FLAGS=\"$MEMCMP_FLAG -DOS_MACOSX -Dthread_local=__thread -Wno-deprecated-declarations\"\n        PLATFORM_SHARED_EXT=dylib\n        [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n        PLATFORM_SHARED_LDFLAGS=\"-dynamiclib -install_name $INSTALL_PATH/\"\n        PORT_FILE=port/port_posix.cc\n        ;;\n    Linux)\n        PLATFORM=OS_LINUX\n        COMMON_FLAGS=\"$MEMCMP_FLAG -pthread -DOS_LINUX\"\n        PLATFORM_LDFLAGS=\"-pthread\"\n        PORT_FILE=port/port_posix.cc\n        ;;\n    SunOS)\n        PLATFORM=OS_SOLARIS\n        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_SOLARIS\"\n        PLATFORM_LIBS=\"-lpthread -lrt\"\n        PORT_FILE=port/port_posix.cc\n        ;;\n    FreeBSD)\n        PLATFORM=OS_FREEBSD\n        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_FREEBSD\"\n        PLATFORM_LIBS=\"-lpthread\"\n        PORT_FILE=port/port_posix.cc\n        ;;\n    NetBSD)\n        PLATFORM=OS_NETBSD\n        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_NETBSD\"\n        PLATFORM_LIBS=\"-lpthread -lgcc_s\"\n        PORT_FILE=port/port_posix.cc\n        ;;\n    OpenBSD)\n        PLATFORM=OS_OPENBSD\n        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_OPENBSD\"\n        PLATFORM_LDFLAGS=\"-pthread\"\n        PORT_FILE=port/port_posix.cc\n        ;;\n    DragonFly)\n        PLATFORM=OS_DRAGONFLYBSD\n        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_DRAGONFLYBSD\"\n        PLATFORM_LIBS=\"-lpthread\"\n        PORT_FILE=port/port_posix.cc\n        ;;\n    OS_ANDROID_CROSSCOMPILE)\n        PLATFORM=OS_ANDROID\n        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_ANDROID -DLEVELDB_PLATFORM_POSIX\"\n        PLATFORM_LDFLAGS=\"\"  # All pthread features are in the Android C library\n        PORT_FILE=port/port_posix.cc\n        CROSS_COMPILE=true\n        ;;\n    HP-UX)\n        PLATFORM=OS_HPUX\n        COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_HPUX\"\n        PLATFORM_LDFLAGS=\"-pthread\"\n        PORT_FILE=port/port_posix.cc\n        # man ld: +h internal_name\n        PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,+h -Wl,\"\n        ;;\n    IOS)\n        PLATFORM=IOS\n        COMMON_FLAGS=\"$MEMCMP_FLAG -DOS_MACOSX\"\n        [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n        PORT_FILE=port/port_posix.cc\n        PLATFORM_SHARED_EXT=\n        PLATFORM_SHARED_LDFLAGS=\n        PLATFORM_SHARED_CFLAGS=\n        PLATFORM_SHARED_VERSIONED=\n        ;;\n    *)\n        echo \"Unknown platform!\" >&2\n        exit 1\nesac\n\n$CXX -x c++ - -o $TMPDIR/handy_build_config.out <<EOF\nint main(){\n  unsigned short a = 1;\n  return *(unsigned char*)&a == 1;\n}\nEOF\n$TMPDIR/handy_build_config.out\nPLATFORM_IS_LITTLE_ENDIAN=$?\n\n#$CXX -x c++ - -o $TMPDIR/handy_build_config.out >/dev/null 2>&1 <<EOF\n##include <sys/epoll.h>\n#int main() {}\n#EOF\n#[ $? = 0 ] && COMMON_FLAGS=\"$COMMON_FLAGS -DUSE_EPOLL\"\n\n$CXX -x c++ - -o $TMPDIR/handy_build_config.out >/dev/null 2>&1 <<EOF\n#include <openssl/ssl.h>\nint main() {}\nEOF\n[ $? = 0 ] && SSL=1 && ! [ -e ssl ] && git clone https://github.com/yedf/handy-ssl.git ssl\n[ x$SSL = x1 ] && PLATFORM_LIBS=\"$PLATFORM_LIBS -lssl -lcrypto\"\n\nPWD=`pwd`\nCOMMON_FLAGS=\"$COMMON_FLAGS -DLITTLE_ENDIAN=$PLATFORM_IS_LITTLE_ENDIAN -std=c++11 -I$PWD\"\nPLATFORM_CCFLAGS=\"$PLATFORM_CCFLAGS $COMMON_FLAGS\"\nPLATFORM_CXXFLAGS=\"$PLATFORM_CXXFLAGS $COMMON_FLAGS\"\nPLATFORM_LDFLAGS=\"$PLATFORM_LDFLAGS -L$PWD\"\n\necho \"CC=$CC\" >> $OUTPUT\necho \"CXX=$CXX\" >> $OUTPUT\necho \"PLATFORM=$PLATFORM\" >> $OUTPUT\necho \"PLATFORM_LDFLAGS=$PLATFORM_LDFLAGS\" >> $OUTPUT\necho \"PLATFORM_LIBS=$PLATFORM_LIBS\" >> $OUTPUT\necho \"PLATFORM_CCFLAGS=$PLATFORM_CCFLAGS\" >> $OUTPUT\necho \"PLATFORM_CXXFLAGS=$PLATFORM_CXXFLAGS\" >> $OUTPUT\necho \"PLATFORM_SHARED_CFLAGS=$PLATFORM_SHARED_CFLAGS\" >> $OUTPUT\necho \"PLATFORM_SHARED_EXT=$PLATFORM_SHARED_EXT\" >> $OUTPUT\necho \"PLATFORM_SHARED_LDFLAGS=$PLATFORM_SHARED_LDFLAGS\" >> $OUTPUT\necho \"PLATFORM_SHARED_VERSIONED=$PLATFORM_SHARED_VERSIONED\" >> $OUTPUT\n[ x$SSL = x1 ] && echo \"HANDY_SOURCES=ssl/ssl-conn.cc\" >> $OUTPUT\n[ x$SSL = x1 ] && echo \"EXAMPLE_SOURCES=ssl/ssl-cli.cc ssl/ssl-svr.cc ssl/https-svr.cc\" >> $OUTPUT\n\n"
        },
        {
          "name": "doc-en.md",
          "type": "blob",
          "size": 5.12890625,
          "content": "# handy\nyedongfu\n\nA C++11 non-blocking network library\n\n[Example](#sample)  \n[EventBase events dispatcher](#event-base)  \n[tcp connection](#tcp-conn)  \n[tcp server](#tcp-server)  \n[http server](#http-server)  \n[half sync half async server](#hsha)  \n<h2 id=\"sample\">example--echo</h2>\n\n```c\n#include <handy/handy.h>\n\nusing namespace std;\nusing namespace handy;\n\n\nint main(int argc, const char* argv[]) {\n    EventBase base;\n    //handle ctrl+c\n    Signal::signal(SIGINT, [&]{ base.exit(); }); \n    TcpServer echo(&base);\n    int r = echo.bind(\"\", 2099);\n    exitif(r, \"bind failed %d %s\", errno, strerror(errno));\n    echo.onConnRead([](const TcpConnPtr& con) {\n        con->send(con->getInput());\n    });\n    base.loop(); //enter events loop\n}\n```\n<h2 id=\"event-base\">EventBase: events dispatcher</h2>\nEventBase is an events dispatcher，use epoll/kqueue to handle non-blocking I/O\n\n```c\nEventBase base;\n```\n\n### events loop\n\n```c\n//call epoll_wait repeatedly, handle I/O events\nbase.loop();\n```\n\n### exit events loop\n\n```c\n//exit events loop, can be called from other threads\nbase.exit();\n```\n\n### is events loop exited?\n\n```c\nbool exited();\n```\n\n### add tcp connection\n\n```c\nTcpConnPtr con = TcpConn::createConnection(&base, host, port);\n```\n\n### add listen fd, and will add all socket return by accept(listen_fd)\n\n```c\nTcpServer echo(&base);\n```\n\n### perform tasks in I/O thread\nSome tasks must be called from I/O thread, for example writing some data to connection.\nIn order to avoid conflicting read/write, the operation should be performed in a single thread.\n\n```c\nvoid safeCall(const Task& task);\n\nbase.safeCall([](con){con->send(\"OK\");});\n```\n\n### manage timeout tasks\nEventBase will make itself return by setting a wait time form epoll_wait/kevent.\nIt will check and call timeout tasks. The precision rely on epoll_wait/kevent\n\n```c\n//interval: 0：once task；>0：repeated task, task will be execute every interval milliseconds\nTimerId runAfter(int64_t milli, const Task& task, int64_t interval=0);\n//runAt will specify the absolute time\nTimerId runAt(int64_t milli, const Task& task, int64_t interval=0)\n//cancel Task, Ignore if task is already removed or expired.\nbool cancel(TimerId timerid);\n\nTimerId tid = base.runAfter(1000, []{ info(\"a second passed\"); });\nbase.cancel(tid);\n```\n\n<h2 id=\"tcp-conn\">TcpConn tcp connection</h2>\nuse shared_ptr to manage connection, no need to release manually\n\n### reference count\n\n```c\ntypedef std::shared_ptr<TcpConn> TcpConnPtr;\n```\n\n### state\n\n```c\nenum State { Invalid=1, Handshaking, Connected, Closed, Failed, };\n```\n\n### example\n\n```c\nTcpConnPtr con = TcpConn::createConnection(base, host, port);\ncon->onState([=](const TcpConnPtr& con) {\n    info(\"onState called state: %d\", con->getState());\n});\ncon->onRead([](const TcpConnPtr& con){\n    info(\"recv %lu bytes\", con->getInput().size());\n    con->send(\"ok\");\n    con->getInput().clear();\n});\n\n```\n\n### reconnect setting\n\n```c\n//set reconnect. -1: no reconnect; 0 :reconnect now; other: wait millisecond; default -1\nvoid setReconnectInterval(int milli);\n```\n\n### callback for idle\n\n```c\nvoid addIdleCB(int idle, const TcpCallBack& cb);\n\n//close connection if idle for 30 seconds\ncon->addIdleCB(30, [](const TcpConnPtr& con)) { con->close(); });\n```\n\n### Message mode\nyou can onRead or onMsg to handle message\n\n```c\n//message callback, confict with onRead callback. You should set only one of these\n//codec will be released when connection destroyed\nvoid onMsg(CodecBase* codec, const MsgCallBack& cb);\n//send message\nvoid sendMsg(Slice msg);\n\ncon->onMsg(new LineCodec, [](const TcpConnPtr& con, Slice msg) {\n    info(\"recv msg: %.*s\", (int)msg.size(), msg.data());\n    con->sendMsg(\"hello\");\n});\n\n```\n\n### store you own data\n\n```c\ntemplate<class T> T& context();\n\ncon->context<std::string>() = \"user defined data\";\n```\n\n<h2 id=\"tcp-server\">TcpServer</h2>\n### example\n\n```c\nTcpServer echo(&base);\nint r = echo.bind(\"\", 2099);\nexitif(r, \"bind failed %d %s\", errno, strerror(errno));\necho.onConnRead([](const TcpConnPtr& con) {\n    con->send(con->getInput()); // echo data read\n});\n```\n\n### customize your connection\nwhen TcpServer accept a connection, it will call this to create an TcpConn\n\n```\nvoid onConnCreate(const std::function<TcpConnPtr()>& cb);\n\nchat.onConnCreate([&]{\n    TcpConnPtr con(new TcpConn);\n    con->onState([&](const TcpConnPtr& con) {\n        if (con->getState() == TcpConn::Connected) {\n            con->context<int>() = 1;\n        }\n    }\n    return con;\n});\n```\n\n<h2 id=\"http-server\">HttpServer</h2>\n\n```c\n//example\nHttpServer sample(&base);\nint r = sample.bind(\"\", 8081);\nexitif(r, \"bind failed %d %s\", errno, strerror(errno));\nsample.onGet(\"/hello\", [](const HttpConnPtr& con) {\n   HttpResponse resp;\n   resp.body = Slice(\"hello world\");\n   con.sendResponse(resp);\n});\n\n```\n<h2 id=\"hsha\">half sync half async server</h2>\n\n```c\n// empty string indicates unfinished handling of request. You may operate on con as you like.\nvoid onMsg(CodecBase* codec, const RetMsgCallBack& cb);\n\nhsha.onMsg(new LineCodec, [](const TcpConnPtr& con, const string& input){\n    int ms = rand() % 1000;\n    info(\"processing a msg\");\n    usleep(ms * 1000);\n    return util::format(\"%s used %d ms\", input.c_str(), ms);\n});\n\n```\nupdating.......\n"
        },
        {
          "name": "doc.md",
          "type": "blob",
          "size": 5.7314453125,
          "content": "# handy\nyedongfu\n\nHandy是一个简洁高效的C++11网络库，支持linux与mac平台，使用异步IO模型\n\n[使用示例](#sample)  \n[EventBase事件分发器](#event-base)  \n[tcp连接](#tcp-conn)  \n[tcp服务器](#tcp-server)  \n[http服务器](#http-server)  \n[半同步半异步服务器](#hsha)  \n<h2 id=\"sample\">使用示例--echo</h2>\n\n```c\n\n#include <handy/handy.h>\n\nusing namespace std;\nusing namespace handy;\n\n\nint main(int argc, const char* argv[]) {\n    EventBase base; //事件分发器\n    //注册Ctrl+C的信号处理器--退出事件分发循环\n    Signal::signal(SIGINT, [&]{ base.exit(); }); \n    TcpServer echo(&base); //创建服务器\n    int r = echo.bind(\"\", 2099); //绑定端口\n    exitif(r, \"bind failed %d %s\", errno, strerror(errno));\n    echo.onConnRead([](const TcpConnPtr& con) {\n        con->send(con->getInput()); // echo 读取的数据\n    });\n    base.loop(); //进入事件分发循环\n}\n```\n<h2 id=\"event-base\">EventBase事件分发器</h2>\nEventBase是事件分发器，内部使用epoll/kqueue来管理非阻塞IO\n\n```c\nEventBase base;\n```\n### 事件分发循环\n\n```c\n//不断调用epoll_wait，处理IO事件\nbase.loop();\n```\n### 退出事件循环\n\n```c\n//退出事件循环，线程安全，可在其他线程中调用\nbase.exit();\n```\n### 是否已退出\n\n```c\nbool exited();\n```\n\n### 在IO线程中执行任务\n一些任务必须在IO线程中完成，例如往连接中写入数据。非IO线程需要往连接中写入数据时，必须把任务交由IO线程进行处理\n\n```c\nvoid safeCall(const Task& task);\n\nbase.safeCall([con](){con->send(\"OK\");});\n```\n[例子程序](examples/safe-close.cc)\n### 管理定时任务\nEventBase通过设定epoll_wait/kevent的等待时间让自己及时返回，然后检查是否有到期的任务，因此时间精度依赖于epoll_wait/kevent的精度\n\n```c\n//interval: 0：一次性任务；>0：重复任务，每隔interval毫秒，任务被执行一次\nTimerId runAfter(int64_t milli, const Task& task, int64_t interval=0);\n//runAt则指定执行时刻\nTimerId runAt(int64_t milli, const Task& task, int64_t interval=0)\n//取消定时任务，若timer已经过期，则忽略\nbool cancel(TimerId timerid);\n\nTimerId tid = base.runAfter(1000, []{ info(\"a second passed\"); });\nbase.cancel(tid);\n```\n[例子程序](examples/timer.cc)\n<h2 id=\"tcp-conn\">TcpConn tcp连接</h2>\n连接采用引用计数的方式进行管理，因此用户无需手动释放连接\n### 引用计数\n\n```c\ntypedef std::shared_ptr<TcpConn> TcpConnPtr;\n```\n### 状态\n\n```c\n\nenum State { Invalid=1, Handshaking, Connected, Closed, Failed, };\n```\n\n### 创建连接\n\n```c\nTcpConnPtr con = TcpConn::createConnection(&base, host, port); #第一个参数为前面的EventBase*\n```\n### 使用示例\n\n```c\nTcpConnPtr con = TcpConn::createConnection(&base, host, port);\ncon->onState([=](const TcpConnPtr& con) {\n    info(\"onState called state: %d\", con->getState());\n});\ncon->onRead([](const TcpConnPtr& con){\n    info(\"recv %lu bytes\", con->getInput().size());\n    con->send(\"ok\");\n    con->getInput().clear();\n});\n```\n[例子程序](examples/echo.cc)\n\n### 设置重连\n\n```c\n//设置重连时间间隔，-1: 不重连，0:立即重连，其它：等待毫秒数，未设置不重连\nvoid setReconnectInterval(int milli);\n```\n[例子程序](examples/reconnect.cc)\n### 连接空闲回调\n\n```c\nvoid addIdleCB(int idle, const TcpCallBack& cb);\n\n//连接空闲30s关闭连接\ncon->addIdleCB(30, [](const TcpConnPtr& con)) { con->close(); });\n```\n[例子程序](examples/idle-close.cc)\n\n### 消息模式\n可以使用onRead处理消息，也可以选用onMsg方式处理消息\n\n```c\n//消息回调，此回调与onRead回调只有一个生效，后设置的生效\n//codec所有权交给onMsg\nvoid onMsg(CodecBase* codec, const MsgCallBack& cb);\n//发送消息\nvoid sendMsg(Slice msg);\n\ncon->onMsg(new LineCodec, [](const TcpConnPtr& con, Slice msg) {\n    info(\"recv msg: %.*s\", (int)msg.size(), msg.data());\n    con->sendMsg(\"hello\");\n});\n```\n[例子程序](examples/codec-svr.cc)\n### 存放自定义数据\n\n```c\ntemplate<class T> T& context();\n\ncon->context<std::string>() = \"user defined data\";\n```\n\n<h2 id=\"tcp-server\">TcpServer tcp服务器</h2>\n\n### 创建tcp服务器\n\n```c\nTcpServer echo(&base);\n```\n\n### 使用示例\n\n```c\nTcpServer echo(&base); //创建服务器\nint r = echo.bind(\"\", 2099); //绑定端口\nexitif(r, \"bind failed %d %s\", errno, strerror(errno));\necho.onConnRead([](const TcpConnPtr& con) {\n    con->send(con->getInput()); // echo 读取的数据\n});\n```\n[例子程序](examples/echo.cc)\n### 自定义创建的连接\n当服务器accept一个连接时，调用此函数\n\n```\nvoid onConnCreate(const std::function<TcpConnPtr()>& cb);\n\nchat.onConnCreate([&]{\n    TcpConnPtr con(new TcpConn);\n    con->onState([&](const TcpConnPtr& con) {\n        if (con->getState() == TcpConn::Connected) {\n            con->context<int>() = 1;\n        }\n    }\n    return con;\n});\n```\n\n[例子程序](examples/codec-svr.cc)\n\n<h2 id=\"http-server\">HttpServer http服务器</h2>\n\n```c\n//使用示例\nHttpServer sample(&base);\nint r = sample.bind(\"\", 8081);\nexitif(r, \"bind failed %d %s\", errno, strerror(errno));\nsample.onGet(\"/hello\", [](const HttpConnPtr& con) {\n   HttpResponse resp;\n   resp.body = Slice(\"hello world\");\n   con.sendResponse(resp);\n});\n```\n\n[例子程序](examples/http-hello.cc)\n<h2 id=\"hsha\">半同步半异步服务器</h2>\n\n```c\n//cb返回空string，表示无需返回数据。如果用户需要更灵活的控制，可以直接操作cb的con参数\nvoid onMsg(CodecBase* codec, const RetMsgCallBack& cb);\n\nhsha.onMsg(new LineCodec, [](const TcpConnPtr& con, const string& input){\n    int ms = rand() % 1000;\n    info(\"processing a msg\");\n    usleep(ms * 1000);\n    return util::format(\"%s used %d ms\", input.c_str(), ms);\n});\n```\n\n[例子程序](examples/hsha.cc)\n\n持续更新中......\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "handy",
          "type": "tree",
          "content": null
        },
        {
          "name": "protobuf",
          "type": "tree",
          "content": null
        },
        {
          "name": "raw-examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}